# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Linux
# This file is distributed under the same license as the linux_kernel_man_pages_l10n package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: linux_kernel_man_pages_l10n 5.03\n"
"Report-Msgid-Bugs-To: https://github.com/test/test\n"
"POT-Creation-Date: 2021-11-07 03:47+0300\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: TH
#: man-pages/man2/setresuid.2:27
#, no-wrap
msgid "SETRESUID"
msgstr ""

#. type: TH
#: man-pages/man2/setresuid.2:27 man-pages/man2/execveat.2:26
#: man-pages/man2/io_setup.2:7 man-pages/man2/set_mempolicy.2:27
#: man-pages/man2/epoll_create.2:24 man-pages/man2/setsid.2:31
#: man-pages/man2/io_cancel.2:7 man-pages/man2/mknod.2:15
#: man-pages/man2/umask.2:34 man-pages/man2/personality.2:33
#: man-pages/man2/timer_settime.2:26 man-pages/man2/getsockname.2:40
#: man-pages/man2/ioctl_getfsmap.2:23 man-pages/man2/signal.2:36
#: man-pages/man2/outb.2:26 man-pages/man2/io_getevents.2:7
#: man-pages/man2/set_tid_address.2:25 man-pages/man2/swapon.2:42
#: man-pages/man2/io_destroy.2:7 man-pages/man2/ioctl_tty.2:8
#: man-pages/man2/send.2:40 man-pages/man2/sigreturn.2:30
#: man-pages/man2/spu_create.2:25 man-pages/man2/delete_module.2:25
#: man-pages/man2/getrusage.2:39 man-pages/man2/inotify_rm_watch.2:27
#: man-pages/man2/seteuid.2:29 man-pages/man2/setreuid.2:46
#: man-pages/man2/sched_get_priority_max.2:29 man-pages/man2/utime.2:31
#: man-pages/man2/clock_nanosleep.2:26 man-pages/man2/sched_yield.2:29
#: man-pages/man2/uselib.2:31 man-pages/man2/arch_prctl.2:25
#: man-pages/man2/chmod.2:32 man-pages/man2/llseek.2:28
#: man-pages/man2/remap_file_pages.2:28 man-pages/man2/mmap2.2:29
#: man-pages/man2/query_module.2:10 man-pages/man2/unlink.2:33
#: man-pages/man2/syslog.2:33 man-pages/man2/symlink.2:33
#: man-pages/man2/socketcall.2:25 man-pages/man2/alloc_hugepages.2:25
#: man-pages/man2/msync.2:25 man-pages/man2/nanosleep.2:34
#: man-pages/man2/sigwaitinfo.2:25 man-pages/man2/ioctl_ficlonerange.2:23
#: man-pages/man2/iopl.2:33 man-pages/man2/cacheflush.2:25
#: man-pages/man2/sysinfo.2:35 man-pages/man2/sync_file_range.2:30
#: man-pages/man2/mbind.2:35 man-pages/man2/ioctl_iflags.2:26
#: man-pages/man2/utimensat.2:26 man-pages/man2/mq_getsetattr.2:26
#: man-pages/man2/nice.2:31 man-pages/man2/sched_setscheduler.2:26
#: man-pages/man2/getresuid.2:28 man-pages/man2/flock.2:35
#: man-pages/man2/quotactl.2:27 man-pages/man2/modify_ldt.2:25
#: man-pages/man2/sgetmask.2:26 man-pages/man2/sendfile.2:19
#: man-pages/man2/get_kernel_syms.2:10 man-pages/man2/s390_pci_mmio_write.2:25
#: man-pages/man2/lookup_dcookie.2:27 man-pages/man2/mincore.2:34
#: man-pages/man2/sigprocmask.2:29 man-pages/man2/timer_getoverrun.2:26
#: man-pages/man2/futimesat.2:25 man-pages/man2/getitimer.2:13
#: man-pages/man2/fork.2:39 man-pages/man2/getpeername.2:42
#: man-pages/man2/create_module.2:10 man-pages/man2/restart_syscall.2:33
#: man-pages/man2/recv.2:41 man-pages/man2/init_module.2:27
#: man-pages/man2/perfmonctl.2:27 man-pages/man2/link.2:32
#: man-pages/man2/listen.2:45 man-pages/man2/ioctl_list.2:31
#: man-pages/man2/sysfs.2:27 man-pages/man2/dup.2:37
#: man-pages/man2/getunwind.2:27 man-pages/man2/time.2:29
#: man-pages/man2/ioctl_console.2:40 man-pages/man2/getpagesize.2:25
#: man-pages/man2/getsockopt.2:44 man-pages/man2/getpriority.2:45
#: man-pages/man2/mkdir.2:11 man-pages/man2/getsid.2:27
#: man-pages/man2/statfs.2:28 man-pages/man2/sync.2:36
#: man-pages/man2/get_mempolicy.2:27 man-pages/man2/vfork.2:29
#: man-pages/man2/getrandom.2:27 man-pages/man2/times.2:38
#: man-pages/man2/ioperm.2:34 man-pages/man2/setpgid.2:48
#: man-pages/man2/umount.2:30 man-pages/man2/process_vm_readv.2:29
#: man-pages/man2/pread.2:25 man-pages/man2/sigpending.2:29
#: man-pages/man2/unimplemented.2:26 man-pages/man2/sched_rr_get_interval.2:29
#, no-wrap
msgid "2017-09-15"
msgstr ""

#. type: TH
#: man-pages/man2/setresuid.2:27 man-pages/man2/fallocate.2:11
#: man-pages/man2/signalfd.2:20 man-pages/man2/splice.2:26
#: man-pages/man2/bind.2:68 man-pages/man2/msgop.2:39
#: man-pages/man2/execveat.2:26 man-pages/man2/socketpair.2:42
#: man-pages/man2/seccomp.2:28 man-pages/man2/getrlimit.2:64
#: man-pages/man2/memfd_create.2:21 man-pages/man2/io_setup.2:7
#: man-pages/man2/request_key.2:12 man-pages/man2/set_mempolicy.2:27
#: man-pages/man2/statx.2:31 man-pages/man2/rmdir.2:30 man-pages/man2/kill.2:44
#: man-pages/man2/readdir.2:30 man-pages/man2/ioctl_userfaultfd.2:28
#: man-pages/man2/acct.2:31 man-pages/man2/epoll_create.2:24
#: man-pages/man2/io_submit.2:8 man-pages/man2/setsid.2:31
#: man-pages/man2/io_cancel.2:7 man-pages/man2/mknod.2:15
#: man-pages/man2/getdents.2:31 man-pages/man2/umask.2:34
#: man-pages/man2/personality.2:33 man-pages/man2/timer_settime.2:26
#: man-pages/man2/sigaction.2:49 man-pages/man2/getsockname.2:40
#: man-pages/man2/getpid.2:25 man-pages/man2/poll.2:31
#: man-pages/man2/ioctl_getfsmap.2:23 man-pages/man2/signal.2:36
#: man-pages/man2/rename.2:33 man-pages/man2/outb.2:26
#: man-pages/man2/shutdown.2:40 man-pages/man2/recvmmsg.2:31
#: man-pages/man2/io_getevents.2:7 man-pages/man2/truncate.2:43
#: man-pages/man2/set_tid_address.2:25 man-pages/man2/swapon.2:42
#: man-pages/man2/open.2:51 man-pages/man2/msgget.2:35
#: man-pages/man2/socket.2:43 man-pages/man2/select_tut.2:32
#: man-pages/man2/chroot.2:33 man-pages/man2/shmget.2:38
#: man-pages/man2/getxattr.2:25 man-pages/man2/io_destroy.2:7
#: man-pages/man2/setxattr.2:25 man-pages/man2/removexattr.2:25
#: man-pages/man2/ioctl_tty.2:8 man-pages/man2/ioctl_fideduperange.2:23
#: man-pages/man2/pivot_root.2:27 man-pages/man2/setfsuid.2:32
#: man-pages/man2/ioctl_ns.2:26 man-pages/man2/send.2:40
#: man-pages/man2/msgctl.2:38 man-pages/man2/sigreturn.2:30
#: man-pages/man2/setuid.2:31 man-pages/man2/spu_create.2:25
#: man-pages/man2/membarrier.2:25 man-pages/man2/delete_module.2:25
#: man-pages/man2/prctl.2:54 man-pages/man2/getrusage.2:39
#: man-pages/man2/inotify_rm_watch.2:27 man-pages/man2/seteuid.2:29
#: man-pages/man2/set_thread_area.2:9 man-pages/man2/semget.2:36
#: man-pages/man2/pipe.2:36 man-pages/man2/setreuid.2:46
#: man-pages/man2/unshare.2:20 man-pages/man2/setfsgid.2:32
#: man-pages/man2/sched_get_priority_max.2:29 man-pages/man2/utime.2:31
#: man-pages/man2/clock_nanosleep.2:26 man-pages/man2/copy_file_range.2:25
#: man-pages/man2/sched_setparam.2:30 man-pages/man2/sched_yield.2:29
#: man-pages/man2/access.2:43 man-pages/man2/intro.2:29
#: man-pages/man2/uselib.2:31 man-pages/man2/kexec_load.2:27
#: man-pages/man2/arch_prctl.2:25 man-pages/man2/mount.2:40
#: man-pages/man2/fanotify_init.2:24 man-pages/man2/ioctl.2:41
#: man-pages/man2/tee.2:26 man-pages/man2/chmod.2:32
#: man-pages/man2/move_pages.2:20 man-pages/man2/inotify_add_watch.2:28
#: man-pages/man2/chdir.2:33 man-pages/man2/stime.2:30
#: man-pages/man2/readv.2:32 man-pages/man2/mremap.2:30
#: man-pages/man2/llseek.2:28 man-pages/man2/remap_file_pages.2:28
#: man-pages/man2/rt_sigqueueinfo.2:25 man-pages/man2/mmap2.2:29
#: man-pages/man2/query_module.2:10 man-pages/man2/unlink.2:33
#: man-pages/man2/syscalls.2:31 man-pages/man2/syslog.2:33
#: man-pages/man2/symlink.2:33 man-pages/man2/gettid.2:26
#: man-pages/man2/socketcall.2:25 man-pages/man2/perf_event_open.2:27
#: man-pages/man2/alloc_hugepages.2:25 man-pages/man2/msync.2:25
#: man-pages/man2/ioprio_set.2:24 man-pages/man2/getdomainname.2:29
#: man-pages/man2/nanosleep.2:34 man-pages/man2/keyctl.2:28
#: man-pages/man2/sigwaitinfo.2:25 man-pages/man2/clone.2:42
#: man-pages/man2/timer_delete.2:26 man-pages/man2/ioctl_ficlonerange.2:23
#: man-pages/man2/iopl.2:33 man-pages/man2/cacheflush.2:25
#: man-pages/man2/_syscall.2:38 man-pages/man2/alarm.2:30
#: man-pages/man2/sysinfo.2:35 man-pages/man2/ioctl_fat.2:24
#: man-pages/man2/kcmp.2:28 man-pages/man2/sync_file_range.2:30
#: man-pages/man2/vmsplice.2:26 man-pages/man2/listxattr.2:26
#: man-pages/man2/write.2:39 man-pages/man2/brk.2:29 man-pages/man2/mbind.2:35
#: man-pages/man2/pkey_alloc.2:25 man-pages/man2/idle.2:32
#: man-pages/man2/ioctl_iflags.2:26 man-pages/man2/utimensat.2:26
#: man-pages/man2/mq_getsetattr.2:26 man-pages/man2/nice.2:31
#: man-pages/man2/sched_setscheduler.2:26 man-pages/man2/chown.2:38
#: man-pages/man2/madvise.2:35 man-pages/man2/sched_setattr.2:26
#: man-pages/man2/getresuid.2:28 man-pages/man2/flock.2:35
#: man-pages/man2/ipc.2:25 man-pages/man2/getcpu.2:12
#: man-pages/man2/capget.2:15 man-pages/man2/quotactl.2:27
#: man-pages/man2/modify_ldt.2:25 man-pages/man2/sgetmask.2:26
#: man-pages/man2/ustat.2:30 man-pages/man2/gettimeofday.2:40
#: man-pages/man2/sendfile.2:19 man-pages/man2/getuid.2:26
#: man-pages/man2/get_kernel_syms.2:10 man-pages/man2/connect.2:67
#: man-pages/man2/spu_run.2:26 man-pages/man2/timerfd_create.2:22
#: man-pages/man2/subpage_prot.2:30 man-pages/man2/lookup_dcookie.2:27
#: man-pages/man2/mincore.2:34 man-pages/man2/shmctl.2:46
#: man-pages/man2/epoll_wait.2:22 man-pages/man2/setup.2:34
#: man-pages/man2/sigprocmask.2:29 man-pages/man2/timer_getoverrun.2:26
#: man-pages/man2/futimesat.2:25 man-pages/man2/getitimer.2:13
#: man-pages/man2/fork.2:39 man-pages/man2/getpeername.2:42
#: man-pages/man2/create_module.2:10 man-pages/man2/sendmmsg.2:28
#: man-pages/man2/mprotect.2:33 man-pages/man2/_exit.2:29
#: man-pages/man2/add_key.2:12 man-pages/man2/restart_syscall.2:33
#: man-pages/man2/eventfd.2:22 man-pages/man2/posix_fadvise.2:29
#: man-pages/man2/recv.2:41 man-pages/man2/fanotify_mark.2:24
#: man-pages/man2/init_module.2:27 man-pages/man2/gethostname.2:32
#: man-pages/man2/userfaultfd.2:27 man-pages/man2/perfmonctl.2:27
#: man-pages/man2/stat.2:40 man-pages/man2/select.2:38
#: man-pages/man2/get_robust_list.2:30 man-pages/man2/link.2:32
#: man-pages/man2/listen.2:45 man-pages/man2/lseek.2:47
#: man-pages/man2/ioctl_list.2:31 man-pages/man2/sysfs.2:27
#: man-pages/man2/dup.2:37 man-pages/man2/tkill.2:29 man-pages/man2/getgid.2:25
#: man-pages/man2/getunwind.2:27 man-pages/man2/accept.2:41
#: man-pages/man2/readahead.2:28 man-pages/man2/nfsservctl.2:5
#: man-pages/man2/bpf.2:26 man-pages/man2/semctl.2:42 man-pages/man2/time.2:29
#: man-pages/man2/getgroups.2:32 man-pages/man2/readlink.2:44
#: man-pages/man2/ioctl_console.2:40 man-pages/man2/getpagesize.2:25
#: man-pages/man2/wait.2:49 man-pages/man2/fcntl.2:68
#: man-pages/man2/syscall.2:42 man-pages/man2/setns.2:8
#: man-pages/man2/mmap.2:40 man-pages/man2/getsockopt.2:44
#: man-pages/man2/ptrace.2:105 man-pages/man2/inotify_init.2:29
#: man-pages/man2/vhangup.2:28 man-pages/man2/getpriority.2:45
#: man-pages/man2/sysctl.2:30 man-pages/man2/mkdir.2:11
#: man-pages/man2/getsid.2:27 man-pages/man2/open_by_handle_at.2:25
#: man-pages/man2/epoll_ctl.2:20 man-pages/man2/wait4.2:33
#: man-pages/man2/pciconfig_read.2:8 man-pages/man2/statfs.2:28
#: man-pages/man2/sync.2:36 man-pages/man2/get_mempolicy.2:27
#: man-pages/man2/adjtimex.2:29 man-pages/man2/migrate_pages.2:18
#: man-pages/man2/execve.2:37 man-pages/man2/fsync.2:38
#: man-pages/man2/sched_setaffinity.2:34 man-pages/man2/reboot.2:28
#: man-pages/man2/read.2:35 man-pages/man2/sigaltstack.2:27
#: man-pages/man2/uname.2:27 man-pages/man2/sigsuspend.2:29
#: man-pages/man2/mlock.2:26 man-pages/man2/futex.2:22
#: man-pages/man2/semop.2:35 man-pages/man2/vfork.2:29
#: man-pages/man2/getrandom.2:27 man-pages/man2/timer_create.2:26
#: man-pages/man2/exit_group.2:25 man-pages/man2/times.2:38
#: man-pages/man2/setgid.2:30 man-pages/man2/ioperm.2:34
#: man-pages/man2/vm86.2:26 man-pages/man2/setpgid.2:48
#: man-pages/man2/shmop.2:41 man-pages/man2/umount.2:30
#: man-pages/man2/bdflush.2:27 man-pages/man2/pause.2:30
#: man-pages/man2/process_vm_readv.2:29 man-pages/man2/pread.2:25
#: man-pages/man2/sigpending.2:29 man-pages/man2/unimplemented.2:26
#: man-pages/man2/close.2:36 man-pages/man2/sched_rr_get_interval.2:29
#, no-wrap
msgid "Linux"
msgstr ""

#. type: TH
#: man-pages/man2/setresuid.2:27 man-pages/man2/fallocate.2:11
#: man-pages/man2/signalfd.2:20 man-pages/man2/splice.2:26
#: man-pages/man2/bind.2:68 man-pages/man2/msgop.2:39
#: man-pages/man2/execveat.2:26 man-pages/man2/socketpair.2:42
#: man-pages/man2/seccomp.2:28 man-pages/man2/getrlimit.2:64
#: man-pages/man2/memfd_create.2:21 man-pages/man2/io_setup.2:7
#: man-pages/man2/set_mempolicy.2:27 man-pages/man2/statx.2:31
#: man-pages/man2/rmdir.2:30 man-pages/man2/kill.2:44
#: man-pages/man2/readdir.2:30 man-pages/man2/ioctl_userfaultfd.2:28
#: man-pages/man2/acct.2:31 man-pages/man2/epoll_create.2:24
#: man-pages/man2/io_submit.2:8 man-pages/man2/setsid.2:31
#: man-pages/man2/io_cancel.2:7 man-pages/man2/mknod.2:15
#: man-pages/man2/getdents.2:31 man-pages/man2/umask.2:34
#: man-pages/man2/personality.2:33 man-pages/man2/timer_settime.2:26
#: man-pages/man2/sigaction.2:49 man-pages/man2/getsockname.2:40
#: man-pages/man2/getpid.2:25 man-pages/man2/poll.2:31
#: man-pages/man2/ioctl_getfsmap.2:23 man-pages/man2/signal.2:36
#: man-pages/man2/rename.2:33 man-pages/man2/outb.2:26
#: man-pages/man2/shutdown.2:40 man-pages/man2/recvmmsg.2:31
#: man-pages/man2/io_getevents.2:7 man-pages/man2/truncate.2:43
#: man-pages/man2/set_tid_address.2:25 man-pages/man2/swapon.2:42
#: man-pages/man2/open.2:51 man-pages/man2/msgget.2:35
#: man-pages/man2/socket.2:43 man-pages/man2/select_tut.2:32
#: man-pages/man2/chroot.2:33 man-pages/man2/shmget.2:38
#: man-pages/man2/getxattr.2:25 man-pages/man2/io_destroy.2:7
#: man-pages/man2/setxattr.2:25 man-pages/man2/removexattr.2:25
#: man-pages/man2/ioctl_tty.2:8 man-pages/man2/ioctl_fideduperange.2:23
#: man-pages/man2/pivot_root.2:27 man-pages/man2/setfsuid.2:32
#: man-pages/man2/ioctl_ns.2:26 man-pages/man2/send.2:40
#: man-pages/man2/msgctl.2:38 man-pages/man2/sigreturn.2:30
#: man-pages/man2/setuid.2:31 man-pages/man2/spu_create.2:25
#: man-pages/man2/membarrier.2:25 man-pages/man2/s390_guarded_storage.2:25
#: man-pages/man2/delete_module.2:25 man-pages/man2/prctl.2:54
#: man-pages/man2/getrusage.2:39 man-pages/man2/inotify_rm_watch.2:27
#: man-pages/man2/seteuid.2:29 man-pages/man2/set_thread_area.2:9
#: man-pages/man2/semget.2:36 man-pages/man2/pipe.2:36
#: man-pages/man2/setreuid.2:46 man-pages/man2/unshare.2:20
#: man-pages/man2/setfsgid.2:32 man-pages/man2/sched_get_priority_max.2:29
#: man-pages/man2/utime.2:31 man-pages/man2/clock_nanosleep.2:26
#: man-pages/man2/copy_file_range.2:25 man-pages/man2/sched_setparam.2:30
#: man-pages/man2/sched_yield.2:29 man-pages/man2/access.2:43
#: man-pages/man2/intro.2:29 man-pages/man2/uselib.2:31
#: man-pages/man2/kexec_load.2:27 man-pages/man2/arch_prctl.2:25
#: man-pages/man2/mount.2:40 man-pages/man2/fanotify_init.2:24
#: man-pages/man2/ioctl.2:41 man-pages/man2/tee.2:26 man-pages/man2/chmod.2:32
#: man-pages/man2/move_pages.2:20 man-pages/man2/inotify_add_watch.2:28
#: man-pages/man2/chdir.2:33 man-pages/man2/stime.2:30
#: man-pages/man2/readv.2:32 man-pages/man2/mremap.2:30
#: man-pages/man2/llseek.2:28 man-pages/man2/remap_file_pages.2:28
#: man-pages/man2/rt_sigqueueinfo.2:25 man-pages/man2/mmap2.2:29
#: man-pages/man2/query_module.2:10 man-pages/man2/unlink.2:33
#: man-pages/man2/syscalls.2:31 man-pages/man2/syslog.2:33
#: man-pages/man2/symlink.2:33 man-pages/man2/gettid.2:26
#: man-pages/man2/socketcall.2:25 man-pages/man2/perf_event_open.2:27
#: man-pages/man2/alloc_hugepages.2:25 man-pages/man2/msync.2:25
#: man-pages/man2/ioprio_set.2:24 man-pages/man2/getdomainname.2:29
#: man-pages/man2/nanosleep.2:34 man-pages/man2/sigwaitinfo.2:25
#: man-pages/man2/clone.2:42 man-pages/man2/timer_delete.2:26
#: man-pages/man2/ioctl_ficlonerange.2:23 man-pages/man2/iopl.2:33
#: man-pages/man2/cacheflush.2:25 man-pages/man2/_syscall.2:38
#: man-pages/man2/alarm.2:30 man-pages/man2/sysinfo.2:35
#: man-pages/man2/ioctl_fat.2:24 man-pages/man2/kcmp.2:28
#: man-pages/man2/sync_file_range.2:30 man-pages/man2/vmsplice.2:26
#: man-pages/man2/listxattr.2:26 man-pages/man2/write.2:39
#: man-pages/man2/brk.2:29 man-pages/man2/mbind.2:35
#: man-pages/man2/pkey_alloc.2:25 man-pages/man2/idle.2:32
#: man-pages/man2/ioctl_iflags.2:26 man-pages/man2/utimensat.2:26
#: man-pages/man2/mq_getsetattr.2:26 man-pages/man2/nice.2:31
#: man-pages/man2/sched_setscheduler.2:26 man-pages/man2/chown.2:38
#: man-pages/man2/madvise.2:35 man-pages/man2/sched_setattr.2:26
#: man-pages/man2/getresuid.2:28 man-pages/man2/flock.2:35
#: man-pages/man2/ipc.2:25 man-pages/man2/getcpu.2:12
#: man-pages/man2/capget.2:15 man-pages/man2/quotactl.2:27
#: man-pages/man2/modify_ldt.2:25 man-pages/man2/sgetmask.2:26
#: man-pages/man2/ustat.2:30 man-pages/man2/gettimeofday.2:40
#: man-pages/man2/sendfile.2:19 man-pages/man2/getuid.2:26
#: man-pages/man2/get_kernel_syms.2:10 man-pages/man2/connect.2:67
#: man-pages/man2/s390_pci_mmio_write.2:25 man-pages/man2/spu_run.2:26
#: man-pages/man2/timerfd_create.2:22 man-pages/man2/subpage_prot.2:30
#: man-pages/man2/lookup_dcookie.2:27 man-pages/man2/mincore.2:34
#: man-pages/man2/shmctl.2:46 man-pages/man2/epoll_wait.2:22
#: man-pages/man2/setup.2:34 man-pages/man2/sigprocmask.2:29
#: man-pages/man2/timer_getoverrun.2:26 man-pages/man2/futimesat.2:25
#: man-pages/man2/getitimer.2:13 man-pages/man2/fork.2:39
#: man-pages/man2/getpeername.2:42 man-pages/man2/create_module.2:10
#: man-pages/man2/sendmmsg.2:28 man-pages/man2/mprotect.2:33
#: man-pages/man2/_exit.2:29 man-pages/man2/restart_syscall.2:33
#: man-pages/man2/eventfd.2:22 man-pages/man2/posix_fadvise.2:29
#: man-pages/man2/recv.2:41 man-pages/man2/fanotify_mark.2:24
#: man-pages/man2/init_module.2:27 man-pages/man2/gethostname.2:32
#: man-pages/man2/userfaultfd.2:27 man-pages/man2/perfmonctl.2:27
#: man-pages/man2/stat.2:40 man-pages/man2/select.2:38 man-pages/man2/link.2:32
#: man-pages/man2/listen.2:45 man-pages/man2/lseek.2:47
#: man-pages/man2/ioctl_list.2:31 man-pages/man2/sysfs.2:27
#: man-pages/man2/dup.2:37 man-pages/man2/tkill.2:29 man-pages/man2/getgid.2:25
#: man-pages/man2/getunwind.2:27 man-pages/man2/accept.2:41
#: man-pages/man2/readahead.2:28 man-pages/man2/nfsservctl.2:5
#: man-pages/man2/bpf.2:26 man-pages/man2/semctl.2:42 man-pages/man2/time.2:29
#: man-pages/man2/getgroups.2:32 man-pages/man2/readlink.2:44
#: man-pages/man2/ioctl_console.2:40 man-pages/man2/getpagesize.2:25
#: man-pages/man2/s390_runtime_instr.2:25 man-pages/man2/wait.2:49
#: man-pages/man2/fcntl.2:68 man-pages/man2/syscall.2:42
#: man-pages/man2/setns.2:8 man-pages/man2/mmap.2:40
#: man-pages/man2/getsockopt.2:44 man-pages/man2/ptrace.2:105
#: man-pages/man2/inotify_init.2:29 man-pages/man2/vhangup.2:28
#: man-pages/man2/getpriority.2:45 man-pages/man2/sysctl.2:30
#: man-pages/man2/mkdir.2:11 man-pages/man2/getsid.2:27
#: man-pages/man2/open_by_handle_at.2:25 man-pages/man2/epoll_ctl.2:20
#: man-pages/man2/wait4.2:33 man-pages/man2/pciconfig_read.2:8
#: man-pages/man2/statfs.2:28 man-pages/man2/sync.2:36
#: man-pages/man2/get_mempolicy.2:27 man-pages/man2/adjtimex.2:29
#: man-pages/man2/migrate_pages.2:18 man-pages/man2/execve.2:37
#: man-pages/man2/fsync.2:38 man-pages/man2/sched_setaffinity.2:34
#: man-pages/man2/reboot.2:28 man-pages/man2/read.2:35
#: man-pages/man2/sigaltstack.2:27 man-pages/man2/uname.2:27
#: man-pages/man2/sigsuspend.2:29 man-pages/man2/mlock.2:26
#: man-pages/man2/futex.2:22 man-pages/man2/semop.2:35
#: man-pages/man2/vfork.2:29 man-pages/man2/clock_getres.2:30
#: man-pages/man2/getrandom.2:27 man-pages/man2/timer_create.2:26
#: man-pages/man2/exit_group.2:25 man-pages/man2/times.2:38
#: man-pages/man2/setgid.2:30 man-pages/man2/ioperm.2:34
#: man-pages/man2/vm86.2:26 man-pages/man2/setpgid.2:48
#: man-pages/man2/shmop.2:41 man-pages/man2/umount.2:30
#: man-pages/man2/s390_sthyi.2:25 man-pages/man2/bdflush.2:27
#: man-pages/man2/pause.2:30 man-pages/man2/process_vm_readv.2:29
#: man-pages/man2/pread.2:25 man-pages/man2/sigpending.2:29
#: man-pages/man2/unimplemented.2:26 man-pages/man2/close.2:36
#: man-pages/man2/sched_rr_get_interval.2:29
#, no-wrap
msgid "Linux Programmer's Manual"
msgstr ""

#. type: SH
#: man-pages/man2/setresuid.2:28 man-pages/man2/fallocate.2:12
#: man-pages/man2/signalfd.2:21 man-pages/man2/splice.2:27
#: man-pages/man2/bind.2:69 man-pages/man2/msgop.2:40
#: man-pages/man2/execveat.2:27 man-pages/man2/socketpair.2:43
#: man-pages/man2/seccomp.2:29 man-pages/man2/getrlimit.2:65
#: man-pages/man2/memfd_create.2:22 man-pages/man2/io_setup.2:8
#: man-pages/man2/request_key.2:13 man-pages/man2/set_mempolicy.2:28
#: man-pages/man2/statx.2:32 man-pages/man2/rmdir.2:31 man-pages/man2/kill.2:45
#: man-pages/man2/readdir.2:31 man-pages/man2/ioctl_userfaultfd.2:29
#: man-pages/man2/acct.2:32 man-pages/man2/epoll_create.2:25
#: man-pages/man2/io_submit.2:9 man-pages/man2/setsid.2:32
#: man-pages/man2/io_cancel.2:8 man-pages/man2/mknod.2:16
#: man-pages/man2/getdents.2:32 man-pages/man2/umask.2:35
#: man-pages/man2/personality.2:34 man-pages/man2/timer_settime.2:27
#: man-pages/man2/sigaction.2:50 man-pages/man2/getsockname.2:41
#: man-pages/man2/getpid.2:26 man-pages/man2/poll.2:32
#: man-pages/man2/ioctl_getfsmap.2:24 man-pages/man2/signal.2:37
#: man-pages/man2/rename.2:34 man-pages/man2/outb.2:27
#: man-pages/man2/shutdown.2:41 man-pages/man2/recvmmsg.2:32
#: man-pages/man2/io_getevents.2:8 man-pages/man2/truncate.2:44
#: man-pages/man2/set_tid_address.2:26 man-pages/man2/swapon.2:43
#: man-pages/man2/open.2:52 man-pages/man2/msgget.2:36
#: man-pages/man2/socket.2:44 man-pages/man2/select_tut.2:33
#: man-pages/man2/chroot.2:34 man-pages/man2/shmget.2:39
#: man-pages/man2/getxattr.2:26 man-pages/man2/io_destroy.2:8
#: man-pages/man2/setxattr.2:26 man-pages/man2/removexattr.2:26
#: man-pages/man2/ioctl_tty.2:9 man-pages/man2/ioctl_fideduperange.2:24
#: man-pages/man2/pivot_root.2:28 man-pages/man2/setfsuid.2:33
#: man-pages/man2/ioctl_ns.2:27 man-pages/man2/send.2:41
#: man-pages/man2/msgctl.2:39 man-pages/man2/sigreturn.2:31
#: man-pages/man2/setuid.2:32 man-pages/man2/spu_create.2:26
#: man-pages/man2/membarrier.2:26 man-pages/man2/s390_guarded_storage.2:26
#: man-pages/man2/delete_module.2:26 man-pages/man2/prctl.2:55
#: man-pages/man2/getrusage.2:40 man-pages/man2/inotify_rm_watch.2:28
#: man-pages/man2/seteuid.2:30 man-pages/man2/set_thread_area.2:10
#: man-pages/man2/semget.2:37 man-pages/man2/pipe.2:37
#: man-pages/man2/setreuid.2:47 man-pages/man2/unshare.2:21
#: man-pages/man2/setfsgid.2:33 man-pages/man2/sched_get_priority_max.2:30
#: man-pages/man2/utime.2:32 man-pages/man2/clock_nanosleep.2:27
#: man-pages/man2/copy_file_range.2:26 man-pages/man2/sched_setparam.2:31
#: man-pages/man2/sched_yield.2:30 man-pages/man2/access.2:44
#: man-pages/man2/intro.2:30 man-pages/man2/uselib.2:32
#: man-pages/man2/kexec_load.2:28 man-pages/man2/arch_prctl.2:26
#: man-pages/man2/mount.2:41 man-pages/man2/fanotify_init.2:25
#: man-pages/man2/ioctl.2:42 man-pages/man2/tee.2:27 man-pages/man2/chmod.2:33
#: man-pages/man2/move_pages.2:21 man-pages/man2/inotify_add_watch.2:29
#: man-pages/man2/chdir.2:34 man-pages/man2/stime.2:31
#: man-pages/man2/readv.2:33 man-pages/man2/mremap.2:31
#: man-pages/man2/llseek.2:29 man-pages/man2/remap_file_pages.2:29
#: man-pages/man2/rt_sigqueueinfo.2:26 man-pages/man2/mmap2.2:30
#: man-pages/man2/query_module.2:11 man-pages/man2/unlink.2:34
#: man-pages/man2/syscalls.2:32 man-pages/man2/syslog.2:34
#: man-pages/man2/symlink.2:34 man-pages/man2/gettid.2:27
#: man-pages/man2/socketcall.2:26 man-pages/man2/perf_event_open.2:28
#: man-pages/man2/alloc_hugepages.2:26 man-pages/man2/msync.2:26
#: man-pages/man2/ioprio_set.2:25 man-pages/man2/getdomainname.2:30
#: man-pages/man2/nanosleep.2:35 man-pages/man2/keyctl.2:29
#: man-pages/man2/sigwaitinfo.2:26 man-pages/man2/clone.2:43
#: man-pages/man2/timer_delete.2:27 man-pages/man2/ioctl_ficlonerange.2:24
#: man-pages/man2/iopl.2:34 man-pages/man2/cacheflush.2:26
#: man-pages/man2/_syscall.2:39 man-pages/man2/alarm.2:31
#: man-pages/man2/sysinfo.2:36 man-pages/man2/ioctl_fat.2:25
#: man-pages/man2/kcmp.2:29 man-pages/man2/sync_file_range.2:31
#: man-pages/man2/vmsplice.2:27 man-pages/man2/listxattr.2:27
#: man-pages/man2/write.2:40 man-pages/man2/brk.2:30 man-pages/man2/mbind.2:36
#: man-pages/man2/pkey_alloc.2:26 man-pages/man2/idle.2:33
#: man-pages/man2/ioctl_iflags.2:27 man-pages/man2/utimensat.2:27
#: man-pages/man2/mq_getsetattr.2:27 man-pages/man2/nice.2:32
#: man-pages/man2/sched_setscheduler.2:27 man-pages/man2/chown.2:39
#: man-pages/man2/madvise.2:36 man-pages/man2/sched_setattr.2:27
#: man-pages/man2/getresuid.2:29 man-pages/man2/flock.2:36
#: man-pages/man2/ipc.2:26 man-pages/man2/getcpu.2:13
#: man-pages/man2/capget.2:16 man-pages/man2/quotactl.2:28
#: man-pages/man2/modify_ldt.2:26 man-pages/man2/sgetmask.2:27
#: man-pages/man2/ustat.2:31 man-pages/man2/gettimeofday.2:41
#: man-pages/man2/sendfile.2:20 man-pages/man2/getuid.2:27
#: man-pages/man2/get_kernel_syms.2:11 man-pages/man2/connect.2:68
#: man-pages/man2/s390_pci_mmio_write.2:26 man-pages/man2/spu_run.2:27
#: man-pages/man2/timerfd_create.2:23 man-pages/man2/subpage_prot.2:31
#: man-pages/man2/lookup_dcookie.2:28 man-pages/man2/mincore.2:35
#: man-pages/man2/shmctl.2:47 man-pages/man2/epoll_wait.2:23
#: man-pages/man2/setup.2:35 man-pages/man2/sigprocmask.2:30
#: man-pages/man2/timer_getoverrun.2:27 man-pages/man2/futimesat.2:26
#: man-pages/man2/getitimer.2:14 man-pages/man2/fork.2:40
#: man-pages/man2/getpeername.2:43 man-pages/man2/create_module.2:11
#: man-pages/man2/sendmmsg.2:29 man-pages/man2/mprotect.2:34
#: man-pages/man2/_exit.2:30 man-pages/man2/add_key.2:13
#: man-pages/man2/restart_syscall.2:34 man-pages/man2/eventfd.2:23
#: man-pages/man2/posix_fadvise.2:30 man-pages/man2/recv.2:42
#: man-pages/man2/fanotify_mark.2:25 man-pages/man2/init_module.2:28
#: man-pages/man2/gethostname.2:33 man-pages/man2/userfaultfd.2:28
#: man-pages/man2/perfmonctl.2:28 man-pages/man2/stat.2:41
#: man-pages/man2/select.2:39 man-pages/man2/get_robust_list.2:31
#: man-pages/man2/link.2:33 man-pages/man2/listen.2:46
#: man-pages/man2/lseek.2:48 man-pages/man2/ioctl_list.2:32
#: man-pages/man2/sysfs.2:28 man-pages/man2/dup.2:38 man-pages/man2/tkill.2:30
#: man-pages/man2/getgid.2:26 man-pages/man2/getunwind.2:28
#: man-pages/man2/accept.2:42 man-pages/man2/readahead.2:29
#: man-pages/man2/nfsservctl.2:6 man-pages/man2/bpf.2:27
#: man-pages/man2/semctl.2:43 man-pages/man2/time.2:30
#: man-pages/man2/getgroups.2:33 man-pages/man2/readlink.2:45
#: man-pages/man2/ioctl_console.2:41 man-pages/man2/getpagesize.2:26
#: man-pages/man2/s390_runtime_instr.2:26 man-pages/man2/wait.2:50
#: man-pages/man2/fcntl.2:69 man-pages/man2/syscall.2:43
#: man-pages/man2/setns.2:9 man-pages/man2/mmap.2:41
#: man-pages/man2/getsockopt.2:45 man-pages/man2/ptrace.2:106
#: man-pages/man2/inotify_init.2:30 man-pages/man2/vhangup.2:29
#: man-pages/man2/getpriority.2:46 man-pages/man2/sysctl.2:31
#: man-pages/man2/mkdir.2:12 man-pages/man2/getsid.2:28
#: man-pages/man2/open_by_handle_at.2:26 man-pages/man2/epoll_ctl.2:21
#: man-pages/man2/wait4.2:34 man-pages/man2/pciconfig_read.2:9
#: man-pages/man2/statfs.2:29 man-pages/man2/sync.2:37
#: man-pages/man2/get_mempolicy.2:28 man-pages/man2/adjtimex.2:30
#: man-pages/man2/migrate_pages.2:19 man-pages/man2/execve.2:38
#: man-pages/man2/fsync.2:39 man-pages/man2/sched_setaffinity.2:35
#: man-pages/man2/reboot.2:29 man-pages/man2/read.2:36
#: man-pages/man2/sigaltstack.2:28 man-pages/man2/uname.2:28
#: man-pages/man2/sigsuspend.2:30 man-pages/man2/mlock.2:27
#: man-pages/man2/futex.2:23 man-pages/man2/semop.2:36
#: man-pages/man2/vfork.2:30 man-pages/man2/clock_getres.2:31
#: man-pages/man2/getrandom.2:28 man-pages/man2/timer_create.2:27
#: man-pages/man2/exit_group.2:26 man-pages/man2/times.2:39
#: man-pages/man2/setgid.2:31 man-pages/man2/ioperm.2:35
#: man-pages/man2/vm86.2:27 man-pages/man2/setpgid.2:49
#: man-pages/man2/shmop.2:42 man-pages/man2/umount.2:31
#: man-pages/man2/s390_sthyi.2:26 man-pages/man2/bdflush.2:28
#: man-pages/man2/pause.2:31 man-pages/man2/process_vm_readv.2:30
#: man-pages/man2/pread.2:26 man-pages/man2/sigpending.2:30
#: man-pages/man2/unimplemented.2:27 man-pages/man2/close.2:37
#: man-pages/man2/sched_rr_get_interval.2:30
#, no-wrap
msgid "NAME"
msgstr ""

#. type: Plain text
#: man-pages/man2/setresuid.2:30
msgid "setresuid, setresgid - set real, effective and saved user or group ID"
msgstr ""

#. type: SH
#: man-pages/man2/setresuid.2:30 man-pages/man2/fallocate.2:14
#: man-pages/man2/signalfd.2:23 man-pages/man2/splice.2:29
#: man-pages/man2/bind.2:71 man-pages/man2/msgop.2:42
#: man-pages/man2/execveat.2:29 man-pages/man2/socketpair.2:45
#: man-pages/man2/seccomp.2:31 man-pages/man2/getrlimit.2:67
#: man-pages/man2/memfd_create.2:24 man-pages/man2/io_setup.2:10
#: man-pages/man2/request_key.2:15 man-pages/man2/set_mempolicy.2:30
#: man-pages/man2/statx.2:34 man-pages/man2/rmdir.2:33 man-pages/man2/kill.2:47
#: man-pages/man2/readdir.2:33 man-pages/man2/ioctl_userfaultfd.2:32
#: man-pages/man2/acct.2:34 man-pages/man2/epoll_create.2:27
#: man-pages/man2/io_submit.2:11 man-pages/man2/setsid.2:34
#: man-pages/man2/io_cancel.2:10 man-pages/man2/mknod.2:18
#: man-pages/man2/getdents.2:34 man-pages/man2/umask.2:37
#: man-pages/man2/personality.2:36 man-pages/man2/timer_settime.2:30
#: man-pages/man2/sigaction.2:52 man-pages/man2/getsockname.2:43
#: man-pages/man2/getpid.2:28 man-pages/man2/poll.2:34
#: man-pages/man2/ioctl_getfsmap.2:26 man-pages/man2/signal.2:39
#: man-pages/man2/rename.2:36 man-pages/man2/outb.2:31
#: man-pages/man2/shutdown.2:43 man-pages/man2/recvmmsg.2:34
#: man-pages/man2/io_getevents.2:10 man-pages/man2/truncate.2:46
#: man-pages/man2/set_tid_address.2:28 man-pages/man2/swapon.2:45
#: man-pages/man2/open.2:54 man-pages/man2/msgget.2:38
#: man-pages/man2/socket.2:46 man-pages/man2/select_tut.2:36
#: man-pages/man2/chroot.2:36 man-pages/man2/shmget.2:41
#: man-pages/man2/getxattr.2:28 man-pages/man2/io_destroy.2:10
#: man-pages/man2/setxattr.2:28 man-pages/man2/removexattr.2:28
#: man-pages/man2/ioctl_tty.2:11 man-pages/man2/ioctl_fideduperange.2:26
#: man-pages/man2/pivot_root.2:30 man-pages/man2/setfsuid.2:35
#: man-pages/man2/send.2:43 man-pages/man2/msgctl.2:41
#: man-pages/man2/sigreturn.2:33 man-pages/man2/setuid.2:34
#: man-pages/man2/spu_create.2:28 man-pages/man2/membarrier.2:28
#: man-pages/man2/s390_guarded_storage.2:28 man-pages/man2/delete_module.2:28
#: man-pages/man2/prctl.2:57 man-pages/man2/getrusage.2:42
#: man-pages/man2/inotify_rm_watch.2:30 man-pages/man2/seteuid.2:32
#: man-pages/man2/set_thread_area.2:12 man-pages/man2/semget.2:39
#: man-pages/man2/pipe.2:39 man-pages/man2/setreuid.2:49
#: man-pages/man2/unshare.2:23 man-pages/man2/setfsgid.2:35
#: man-pages/man2/sched_get_priority_max.2:32 man-pages/man2/utime.2:34
#: man-pages/man2/clock_nanosleep.2:29 man-pages/man2/copy_file_range.2:28
#: man-pages/man2/sched_setparam.2:33 man-pages/man2/sched_yield.2:32
#: man-pages/man2/access.2:46 man-pages/man2/uselib.2:34
#: man-pages/man2/kexec_load.2:30 man-pages/man2/arch_prctl.2:28
#: man-pages/man2/mount.2:43 man-pages/man2/fanotify_init.2:27
#: man-pages/man2/ioctl.2:44 man-pages/man2/tee.2:29 man-pages/man2/chmod.2:35
#: man-pages/man2/move_pages.2:23 man-pages/man2/inotify_add_watch.2:31
#: man-pages/man2/chdir.2:36 man-pages/man2/stime.2:33
#: man-pages/man2/readv.2:35 man-pages/man2/mremap.2:33
#: man-pages/man2/llseek.2:31 man-pages/man2/remap_file_pages.2:31
#: man-pages/man2/rt_sigqueueinfo.2:28 man-pages/man2/mmap2.2:32
#: man-pages/man2/query_module.2:13 man-pages/man2/unlink.2:36
#: man-pages/man2/syscalls.2:34 man-pages/man2/syslog.2:37
#: man-pages/man2/symlink.2:36 man-pages/man2/gettid.2:29
#: man-pages/man2/socketcall.2:28 man-pages/man2/perf_event_open.2:30
#: man-pages/man2/alloc_hugepages.2:28 man-pages/man2/msync.2:28
#: man-pages/man2/ioprio_set.2:27 man-pages/man2/getdomainname.2:32
#: man-pages/man2/nanosleep.2:37 man-pages/man2/keyctl.2:31
#: man-pages/man2/sigwaitinfo.2:29 man-pages/man2/clone.2:45
#: man-pages/man2/timer_delete.2:29 man-pages/man2/ioctl_ficlonerange.2:26
#: man-pages/man2/iopl.2:36 man-pages/man2/cacheflush.2:28
#: man-pages/man2/_syscall.2:41 man-pages/man2/alarm.2:33
#: man-pages/man2/sysinfo.2:38 man-pages/man2/ioctl_fat.2:27
#: man-pages/man2/kcmp.2:31 man-pages/man2/sync_file_range.2:33
#: man-pages/man2/vmsplice.2:29 man-pages/man2/listxattr.2:29
#: man-pages/man2/write.2:42 man-pages/man2/brk.2:32 man-pages/man2/mbind.2:38
#: man-pages/man2/pkey_alloc.2:28 man-pages/man2/idle.2:35
#: man-pages/man2/utimensat.2:29 man-pages/man2/mq_getsetattr.2:29
#: man-pages/man2/nice.2:34 man-pages/man2/sched_setscheduler.2:30
#: man-pages/man2/chown.2:41 man-pages/man2/madvise.2:38
#: man-pages/man2/sched_setattr.2:30 man-pages/man2/getresuid.2:31
#: man-pages/man2/flock.2:38 man-pages/man2/ipc.2:28 man-pages/man2/getcpu.2:15
#: man-pages/man2/capget.2:18 man-pages/man2/quotactl.2:30
#: man-pages/man2/modify_ldt.2:28 man-pages/man2/sgetmask.2:29
#: man-pages/man2/ustat.2:33 man-pages/man2/gettimeofday.2:43
#: man-pages/man2/sendfile.2:22 man-pages/man2/getuid.2:29
#: man-pages/man2/get_kernel_syms.2:13 man-pages/man2/connect.2:70
#: man-pages/man2/s390_pci_mmio_write.2:29 man-pages/man2/spu_run.2:29
#: man-pages/man2/timerfd_create.2:26 man-pages/man2/subpage_prot.2:33
#: man-pages/man2/lookup_dcookie.2:30 man-pages/man2/mincore.2:37
#: man-pages/man2/shmctl.2:49 man-pages/man2/epoll_wait.2:25
#: man-pages/man2/setup.2:37 man-pages/man2/sigprocmask.2:32
#: man-pages/man2/timer_getoverrun.2:29 man-pages/man2/futimesat.2:29
#: man-pages/man2/getitimer.2:16 man-pages/man2/fork.2:42
#: man-pages/man2/getpeername.2:45 man-pages/man2/create_module.2:13
#: man-pages/man2/sendmmsg.2:31 man-pages/man2/mprotect.2:36
#: man-pages/man2/_exit.2:32 man-pages/man2/add_key.2:15
#: man-pages/man2/restart_syscall.2:36 man-pages/man2/eventfd.2:25
#: man-pages/man2/posix_fadvise.2:32 man-pages/man2/recv.2:44
#: man-pages/man2/fanotify_mark.2:28 man-pages/man2/init_module.2:30
#: man-pages/man2/gethostname.2:35 man-pages/man2/userfaultfd.2:30
#: man-pages/man2/perfmonctl.2:30 man-pages/man2/stat.2:43
#: man-pages/man2/select.2:42 man-pages/man2/get_robust_list.2:33
#: man-pages/man2/link.2:35 man-pages/man2/listen.2:48
#: man-pages/man2/lseek.2:50 man-pages/man2/sysfs.2:30 man-pages/man2/dup.2:40
#: man-pages/man2/tkill.2:32 man-pages/man2/getgid.2:28
#: man-pages/man2/getunwind.2:30 man-pages/man2/accept.2:44
#: man-pages/man2/readahead.2:31 man-pages/man2/nfsservctl.2:8
#: man-pages/man2/bpf.2:29 man-pages/man2/semctl.2:45 man-pages/man2/time.2:32
#: man-pages/man2/getgroups.2:35 man-pages/man2/readlink.2:47
#: man-pages/man2/getpagesize.2:28 man-pages/man2/s390_runtime_instr.2:28
#: man-pages/man2/wait.2:52 man-pages/man2/fcntl.2:71
#: man-pages/man2/syscall.2:45 man-pages/man2/setns.2:11
#: man-pages/man2/mmap.2:43 man-pages/man2/getsockopt.2:47
#: man-pages/man2/ptrace.2:108 man-pages/man2/inotify_init.2:32
#: man-pages/man2/vhangup.2:31 man-pages/man2/getpriority.2:48
#: man-pages/man2/sysctl.2:33 man-pages/man2/mkdir.2:14
#: man-pages/man2/getsid.2:30 man-pages/man2/open_by_handle_at.2:29
#: man-pages/man2/epoll_ctl.2:23 man-pages/man2/wait4.2:36
#: man-pages/man2/pciconfig_read.2:11 man-pages/man2/statfs.2:31
#: man-pages/man2/sync.2:39 man-pages/man2/get_mempolicy.2:30
#: man-pages/man2/adjtimex.2:32 man-pages/man2/migrate_pages.2:21
#: man-pages/man2/execve.2:40 man-pages/man2/fsync.2:41
#: man-pages/man2/sched_setaffinity.2:38 man-pages/man2/reboot.2:31
#: man-pages/man2/read.2:38 man-pages/man2/sigaltstack.2:30
#: man-pages/man2/uname.2:30 man-pages/man2/sigsuspend.2:32
#: man-pages/man2/mlock.2:29 man-pages/man2/futex.2:25
#: man-pages/man2/semop.2:38 man-pages/man2/vfork.2:32
#: man-pages/man2/clock_getres.2:33 man-pages/man2/getrandom.2:30
#: man-pages/man2/timer_create.2:29 man-pages/man2/exit_group.2:28
#: man-pages/man2/times.2:41 man-pages/man2/setgid.2:33
#: man-pages/man2/ioperm.2:37 man-pages/man2/vm86.2:29
#: man-pages/man2/setpgid.2:51 man-pages/man2/shmop.2:44
#: man-pages/man2/umount.2:33 man-pages/man2/s390_sthyi.2:28
#: man-pages/man2/bdflush.2:30 man-pages/man2/pause.2:33
#: man-pages/man2/process_vm_readv.2:32 man-pages/man2/pread.2:28
#: man-pages/man2/sigpending.2:32 man-pages/man2/unimplemented.2:31
#: man-pages/man2/close.2:39 man-pages/man2/sched_rr_get_interval.2:32
#, no-wrap
msgid "SYNOPSIS"
msgstr ""

#. type: Plain text
#: man-pages/man2/setresuid.2:32 man-pages/man2/getresuid.2:33
msgid "B<#define _GNU_SOURCE> /* See feature_test_macros(7) */"
msgstr ""

#. type: Plain text
#: man-pages/man2/setresuid.2:34 man-pages/man2/execveat.2:31
#: man-pages/man2/rmdir.2:35 man-pages/man2/setsid.2:39
#: man-pages/man2/getpid.2:32 man-pages/man2/truncate.2:48
#: man-pages/man2/swapon.2:47 man-pages/man2/chroot.2:38
#: man-pages/man2/setuid.2:38 man-pages/man2/seteuid.2:36
#: man-pages/man2/setreuid.2:53 man-pages/man2/uselib.2:36
#: man-pages/man2/chdir.2:38 man-pages/man2/getdomainname.2:34
#: man-pages/man2/write.2:44 man-pages/man2/brk.2:34 man-pages/man2/idle.2:37
#: man-pages/man2/nice.2:36 man-pages/man2/getresuid.2:35
#: man-pages/man2/getuid.2:31 man-pages/man2/mincore.2:39
#: man-pages/man2/setup.2:39 man-pages/man2/fork.2:46 man-pages/man2/_exit.2:34
#: man-pages/man2/gethostname.2:37 man-pages/man2/lseek.2:54
#: man-pages/man2/getgid.2:30 man-pages/man2/getgroups.2:39
#: man-pages/man2/getpagesize.2:30 man-pages/man2/vhangup.2:33
#: man-pages/man2/getsid.2:34 man-pages/man2/sync.2:41
#: man-pages/man2/execve.2:42 man-pages/man2/fsync.2:43
#: man-pages/man2/reboot.2:36 man-pages/man2/reboot.2:47
#: man-pages/man2/vfork.2:36 man-pages/man2/setgid.2:37
#: man-pages/man2/setpgid.2:55 man-pages/man2/pause.2:35
#: man-pages/man2/pread.2:30
msgid "B<#include E<lt>unistd.hE<gt>>"
msgstr ""

#. type: Plain text
#: man-pages/man2/setresuid.2:36
msgid "B<int setresuid(uid_t >I<ruid>B<, uid_t >I<euid>B<, uid_t >I<suid>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/setresuid.2:38
msgid "B<int setresgid(gid_t >I<rgid>B<, gid_t >I<egid>B<, gid_t >I<sgid>B<);>"
msgstr ""

#. type: SH
#: man-pages/man2/setresuid.2:38 man-pages/man2/fallocate.2:22
#: man-pages/man2/signalfd.2:27 man-pages/man2/splice.2:39
#: man-pages/man2/bind.2:79 man-pages/man2/msgop.2:55
#: man-pages/man2/execveat.2:37 man-pages/man2/socketpair.2:52
#: man-pages/man2/seccomp.2:44 man-pages/man2/getrlimit.2:88
#: man-pages/man2/memfd_create.2:30 man-pages/man2/io_setup.2:19
#: man-pages/man2/request_key.2:26 man-pages/man2/set_mempolicy.2:39
#: man-pages/man2/statx.2:45 man-pages/man2/rmdir.2:37 man-pages/man2/kill.2:64
#: man-pages/man2/readdir.2:42 man-pages/man2/ioctl_userfaultfd.2:38
#: man-pages/man2/acct.2:58 man-pages/man2/epoll_create.2:34
#: man-pages/man2/io_submit.2:21 man-pages/man2/setsid.2:43
#: man-pages/man2/io_cancel.2:20 man-pages/man2/mknod.2:48
#: man-pages/man2/getdents.2:44 man-pages/man2/umask.2:43
#: man-pages/man2/personality.2:40 man-pages/man2/timer_settime.2:50
#: man-pages/man2/sigaction.2:72 man-pages/man2/getsockname.2:50
#: man-pages/man2/getpid.2:36 man-pages/man2/poll.2:47
#: man-pages/man2/ioctl_getfsmap.2:35 man-pages/man2/signal.2:45
#: man-pages/man2/rename.2:77 man-pages/man2/outb.2:62
#: man-pages/man2/shutdown.2:47 man-pages/man2/recvmmsg.2:43
#: man-pages/man2/io_getevents.2:22 man-pages/man2/truncate.2:78
#: man-pages/man2/set_tid_address.2:37 man-pages/man2/swapon.2:53
#: man-pages/man2/open.2:88 man-pages/man2/msgget.2:46
#: man-pages/man2/socket.2:52 man-pages/man2/select_tut.2:68
#: man-pages/man2/chroot.2:62 man-pages/man2/shmget.2:49
#: man-pages/man2/getxattr.2:42 man-pages/man2/io_destroy.2:19
#: man-pages/man2/setxattr.2:42 man-pages/man2/removexattr.2:39
#: man-pages/man2/ioctl_tty.2:15 man-pages/man2/ioctl_fideduperange.2:33
#: man-pages/man2/pivot_root.2:35 man-pages/man2/setfsuid.2:39
#: man-pages/man2/ioctl_ns.2:29 man-pages/man2/send.2:58
#: man-pages/man2/msgctl.2:49 man-pages/man2/sigreturn.2:35
#: man-pages/man2/setuid.2:40 man-pages/man2/spu_create.2:40
#: man-pages/man2/membarrier.2:32 man-pages/man2/s390_guarded_storage.2:34
#: man-pages/man2/delete_module.2:35 man-pages/man2/prctl.2:64
#: man-pages/man2/getrusage.2:48 man-pages/man2/inotify_rm_watch.2:36
#: man-pages/man2/seteuid.2:54 man-pages/man2/set_thread_area.2:36
#: man-pages/man2/semget.2:49 man-pages/man2/pipe.2:58
#: man-pages/man2/setreuid.2:73 man-pages/man2/unshare.2:30
#: man-pages/man2/setfsgid.2:39 man-pages/man2/sched_get_priority_max.2:38
#: man-pages/man2/utime.2:45 man-pages/man2/clock_nanosleep.2:51
#: man-pages/man2/copy_file_range.2:37 man-pages/man2/sched_setparam.2:47
#: man-pages/man2/sched_yield.2:36 man-pages/man2/access.2:77
#: man-pages/man2/intro.2:32 man-pages/man2/uselib.2:41
#: man-pages/man2/kexec_load.2:46 man-pages/man2/arch_prctl.2:36
#: man-pages/man2/mount.2:51 man-pages/man2/fanotify_init.2:33
#: man-pages/man2/ioctl.2:50 man-pages/man2/tee.2:38 man-pages/man2/chmod.2:93
#: man-pages/man2/move_pages.2:32 man-pages/man2/inotify_add_watch.2:35
#: man-pages/man2/chdir.2:59 man-pages/man2/stime.2:48
#: man-pages/man2/readv.2:67 man-pages/man2/mremap.2:41
#: man-pages/man2/llseek.2:43 man-pages/man2/remap_file_pages.2:39
#: man-pages/man2/rt_sigqueueinfo.2:38 man-pages/man2/mmap2.2:39
#: man-pages/man2/query_module.2:23 man-pages/man2/unlink.2:66
#: man-pages/man2/syscalls.2:36 man-pages/man2/syslog.2:47
#: man-pages/man2/symlink.2:75 man-pages/man2/gettid.2:35
#: man-pages/man2/socketcall.2:32 man-pages/man2/perf_event_open.2:42
#: man-pages/man2/alloc_hugepages.2:38 man-pages/man2/msync.2:32
#: man-pages/man2/ioprio_set.2:35 man-pages/man2/getdomainname.2:57
#: man-pages/man2/nanosleep.2:49 man-pages/man2/keyctl.2:49
#: man-pages/man2/sigwaitinfo.2:47 man-pages/man2/clone.2:59
#: man-pages/man2/timer_delete.2:45 man-pages/man2/ioctl_ficlonerange.2:35
#: man-pages/man2/iopl.2:40 man-pages/man2/cacheflush.2:34
#: man-pages/man2/_syscall.2:47 man-pages/man2/alarm.2:39
#: man-pages/man2/sysinfo.2:42 man-pages/man2/ioctl_fat.2:40
#: man-pages/man2/kcmp.2:41 man-pages/man2/sync_file_range.2:41
#: man-pages/man2/vmsplice.2:39 man-pages/man2/listxattr.2:42
#: man-pages/man2/write.2:46 man-pages/man2/brk.2:74 man-pages/man2/mbind.2:48
#: man-pages/man2/pkey_alloc.2:36 man-pages/man2/idle.2:39
#: man-pages/man2/ioctl_iflags.2:29 man-pages/man2/utimensat.2:68
#: man-pages/man2/mq_getsetattr.2:40 man-pages/man2/nice.2:48
#: man-pages/man2/sched_setscheduler.2:39 man-pages/man2/chown.2:85
#: man-pages/man2/madvise.2:59 man-pages/man2/sched_setattr.2:41
#: man-pages/man2/getresuid.2:39 man-pages/man2/flock.2:42
#: man-pages/man2/ipc.2:34 man-pages/man2/getcpu.2:22
#: man-pages/man2/capget.2:24 man-pages/man2/quotactl.2:38
#: man-pages/man2/modify_ldt.2:37 man-pages/man2/sgetmask.2:36
#: man-pages/man2/ustat.2:41 man-pages/man2/gettimeofday.2:63
#: man-pages/man2/sendfile.2:47 man-pages/man2/getuid.2:37
#: man-pages/man2/get_kernel_syms.2:22 man-pages/man2/connect.2:79
#: man-pages/man2/s390_pci_mmio_write.2:38 man-pages/man2/spu_run.2:39
#: man-pages/man2/timerfd_create.2:38 man-pages/man2/subpage_prot.2:41
#: man-pages/man2/lookup_dcookie.2:32 man-pages/man2/mincore.2:54
#: man-pages/man2/shmctl.2:57 man-pages/man2/epoll_wait.2:35
#: man-pages/man2/setup.2:41 man-pages/man2/sigprocmask.2:57
#: man-pages/man2/timer_getoverrun.2:45 man-pages/man2/futimesat.2:45
#: man-pages/man2/getitimer.2:24 man-pages/man2/fork.2:48
#: man-pages/man2/getpeername.2:50 man-pages/man2/create_module.2:22
#: man-pages/man2/sendmmsg.2:40 man-pages/man2/mprotect.2:47
#: man-pages/man2/_exit.2:52 man-pages/man2/add_key.2:26
#: man-pages/man2/restart_syscall.2:41 man-pages/man2/eventfd.2:29
#: man-pages/man2/posix_fadvise.2:51 man-pages/man2/recv.2:59
#: man-pages/man2/fanotify_mark.2:36 man-pages/man2/init_module.2:45
#: man-pages/man2/gethostname.2:69 man-pages/man2/userfaultfd.2:40
#: man-pages/man2/perfmonctl.2:39 man-pages/man2/stat.2:92
#: man-pages/man2/select.2:74 man-pages/man2/get_robust_list.2:46
#: man-pages/man2/link.2:66 man-pages/man2/listen.2:55
#: man-pages/man2/lseek.2:56 man-pages/man2/ioctl_list.2:34
#: man-pages/man2/sysfs.2:36 man-pages/man2/dup.2:53 man-pages/man2/tkill.2:43
#: man-pages/man2/getgid.2:36 man-pages/man2/getunwind.2:40
#: man-pages/man2/accept.2:57 man-pages/man2/readahead.2:38
#: man-pages/man2/nfsservctl.2:15 man-pages/man2/bpf.2:35
#: man-pages/man2/semctl.2:53 man-pages/man2/time.2:36
#: man-pages/man2/getgroups.2:56 man-pages/man2/readlink.2:87
#: man-pages/man2/ioctl_console.2:43 man-pages/man2/getpagesize.2:59
#: man-pages/man2/s390_runtime_instr.2:34 man-pages/man2/wait.2:87
#: man-pages/man2/fcntl.2:78 man-pages/man2/syscall.2:53
#: man-pages/man2/setns.2:18 man-pages/man2/mmap.2:54
#: man-pages/man2/getsockopt.2:57 man-pages/man2/ptrace.2:115
#: man-pages/man2/inotify_init.2:39 man-pages/man2/vhangup.2:53
#: man-pages/man2/getpriority.2:56 man-pages/man2/sysctl.2:43
#: man-pages/man2/mkdir.2:46 man-pages/man2/getsid.2:53
#: man-pages/man2/open_by_handle_at.2:43 man-pages/man2/epoll_ctl.2:28
#: man-pages/man2/wait4.2:69 man-pages/man2/pciconfig_read.2:22
#: man-pages/man2/statfs.2:37 man-pages/man2/sync.2:67
#: man-pages/man2/get_mempolicy.2:40 man-pages/man2/adjtimex.2:40
#: man-pages/man2/migrate_pages.2:31 man-pages/man2/execve.2:46
#: man-pages/man2/fsync.2:62 man-pages/man2/sched_setaffinity.2:49
#: man-pages/man2/reboot.2:51 man-pages/man2/read.2:44
#: man-pages/man2/sigaltstack.2:51 man-pages/man2/uname.2:34
#: man-pages/man2/sigsuspend.2:46 man-pages/man2/mlock.2:40
#: man-pages/man2/futex.2:39 man-pages/man2/semop.2:57
#: man-pages/man2/vfork.2:62 man-pages/man2/clock_getres.2:57
#: man-pages/man2/getrandom.2:34 man-pages/man2/timer_create.2:47
#: man-pages/man2/exit_group.2:34 man-pages/man2/times.2:45
#: man-pages/man2/setgid.2:39 man-pages/man2/ioperm.2:42
#: man-pages/man2/vm86.2:35 man-pages/man2/setpgid.2:101
#: man-pages/man2/shmop.2:53 man-pages/man2/umount.2:41
#: man-pages/man2/s390_sthyi.2:35 man-pages/man2/bdflush.2:37
#: man-pages/man2/pause.2:37 man-pages/man2/process_vm_readv.2:65
#: man-pages/man2/pread.2:53 man-pages/man2/sigpending.2:46
#: man-pages/man2/unimplemented.2:33 man-pages/man2/close.2:45
#: man-pages/man2/sched_rr_get_interval.2:36
#, no-wrap
msgid "DESCRIPTION"
msgstr ""

#. type: Plain text
#: man-pages/man2/setresuid.2:42
msgid ""
"B<setresuid>()  sets the real user ID, the effective user ID, and the saved "
"set-user-ID of the calling process."
msgstr ""

#. type: Plain text
#: man-pages/man2/setresuid.2:47
msgid ""
"An unprivileged process may change its real UID, effective UID, and saved "
"set-user-ID, each to one of: the current real UID, the current effective UID "
"or the current saved set-user-ID."
msgstr ""

#. type: Plain text
#: man-pages/man2/setresuid.2:51
msgid ""
"A privileged process (on Linux, one having the B<CAP_SETUID> capability)  "
"may set its real UID, effective UID, and saved set-user-ID to arbitrary "
"values."
msgstr ""

#. type: Plain text
#: man-pages/man2/setresuid.2:53
msgid "If one of the arguments equals -1, the corresponding value is not changed."
msgstr ""

#. type: Plain text
#: man-pages/man2/setresuid.2:57
msgid ""
"Regardless of what changes are made to the real UID, effective UID, and "
"saved set-user-ID, the filesystem UID is always set to the same value as the "
"(possibly new) effective UID."
msgstr ""

#. type: Plain text
#: man-pages/man2/setresuid.2:64
msgid ""
"Completely analogously, B<setresgid>()  sets the real GID, effective GID, "
"and saved set-group-ID of the calling process (and always modifies the "
"filesystem GID to be the same as the effective GID), with the same "
"restrictions for unprivileged processes."
msgstr ""

#. type: SH
#: man-pages/man2/setresuid.2:64 man-pages/man2/fallocate.2:297
#: man-pages/man2/signalfd.2:291 man-pages/man2/splice.2:135
#: man-pages/man2/bind.2:152 man-pages/man2/msgop.2:337
#: man-pages/man2/execveat.2:108 man-pages/man2/socketpair.2:69
#: man-pages/man2/seccomp.2:677 man-pages/man2/getrlimit.2:507
#: man-pages/man2/memfd_create.2:157 man-pages/man2/io_setup.2:32
#: man-pages/man2/request_key.2:374 man-pages/man2/set_mempolicy.2:245
#: man-pages/man2/statx.2:464 man-pages/man2/rmdir.2:40
#: man-pages/man2/kill.2:99 man-pages/man2/readdir.2:93
#: man-pages/man2/ioctl_userfaultfd.2:652 man-pages/man2/acct.2:68
#: man-pages/man2/epoll_create.2:77 man-pages/man2/io_submit.2:195
#: man-pages/man2/setsid.2:59 man-pages/man2/io_cancel.2:37
#: man-pages/man2/mknod.2:153 man-pages/man2/getdents.2:179
#: man-pages/man2/umask.2:112 man-pages/man2/personality.2:249
#: man-pages/man2/timer_settime.2:173 man-pages/man2/sigaction.2:838
#: man-pages/man2/getsockname.2:67 man-pages/man2/poll.2:341
#: man-pages/man2/ioctl_getfsmap.2:325 man-pages/man2/signal.2:97
#: man-pages/man2/rename.2:303 man-pages/man2/shutdown.2:69
#: man-pages/man2/recvmmsg.2:147 man-pages/man2/io_getevents.2:51
#: man-pages/man2/truncate.2:109 man-pages/man2/set_tid_address.2:91
#: man-pages/man2/swapon.2:113 man-pages/man2/open.2:936
#: man-pages/man2/msgget.2:146 man-pages/man2/socket.2:417
#: man-pages/man2/select_tut.2:484 man-pages/man2/chroot.2:116
#: man-pages/man2/shmget.2:215 man-pages/man2/getxattr.2:104
#: man-pages/man2/io_destroy.2:29 man-pages/man2/setxattr.2:109
#: man-pages/man2/removexattr.2:78 man-pages/man2/ioctl_tty.2:531
#: man-pages/man2/ioctl_fideduperange.2:146 man-pages/man2/pivot_root.2:94
#: man-pages/man2/setfsuid.2:74 man-pages/man2/send.2:313
#: man-pages/man2/msgctl.2:243 man-pages/man2/sigreturn.2:67
#: man-pages/man2/setuid.2:73 man-pages/man2/spu_create.2:165
#: man-pages/man2/membarrier.2:193 man-pages/man2/s390_guarded_storage.2:105
#: man-pages/man2/delete_module.2:124 man-pages/man2/prctl.2:1384
#: man-pages/man2/getrusage.2:188 man-pages/man2/inotify_rm_watch.2:48
#: man-pages/man2/seteuid.2:68 man-pages/man2/set_thread_area.2:132
#: man-pages/man2/semget.2:156 man-pages/man2/pipe.2:149
#: man-pages/man2/setreuid.2:96 man-pages/man2/unshare.2:271
#: man-pages/man2/setfsgid.2:63 man-pages/man2/sched_get_priority_max.2:98
#: man-pages/man2/utime.2:123 man-pages/man2/clock_nanosleep.2:152
#: man-pages/man2/copy_file_range.2:88 man-pages/man2/sched_setparam.2:87
#: man-pages/man2/sched_yield.2:41 man-pages/man2/access.2:183
#: man-pages/man2/intro.2:68 man-pages/man2/uselib.2:51
#: man-pages/man2/kexec_load.2:242 man-pages/man2/arch_prctl.2:80
#: man-pages/man2/mount.2:614 man-pages/man2/fanotify_init.2:242
#: man-pages/man2/ioctl.2:85 man-pages/man2/tee.2:83 man-pages/man2/chmod.2:245
#: man-pages/man2/move_pages.2:159 man-pages/man2/inotify_add_watch.2:77
#: man-pages/man2/chdir.2:70 man-pages/man2/stime.2:56
#: man-pages/man2/readv.2:268 man-pages/man2/mremap.2:142
#: man-pages/man2/llseek.2:65 man-pages/man2/remap_file_pages.2:138
#: man-pages/man2/rt_sigqueueinfo.2:138 man-pages/man2/mmap2.2:54
#: man-pages/man2/query_module.2:129 man-pages/man2/unlink.2:153
#: man-pages/man2/syslog.2:319 man-pages/man2/symlink.2:141
#: man-pages/man2/gettid.2:47 man-pages/man2/perf_event_open.2:3142
#: man-pages/man2/alloc_hugepages.2:109 man-pages/man2/msync.2:71
#: man-pages/man2/ioprio_set.2:152 man-pages/man2/getdomainname.2:83
#: man-pages/man2/nanosleep.2:102 man-pages/man2/keyctl.2:1613
#: man-pages/man2/sigwaitinfo.2:106 man-pages/man2/clone.2:1018
#: man-pages/man2/timer_delete.2:53 man-pages/man2/ioctl_ficlonerange.2:85
#: man-pages/man2/iopl.2:67 man-pages/man2/cacheflush.2:53
#: man-pages/man2/alarm.2:54 man-pages/man2/sysinfo.2:99
#: man-pages/man2/ioctl_fat.2:189 man-pages/man2/kcmp.2:208
#: man-pages/man2/sync_file_range.2:141 man-pages/man2/vmsplice.2:131
#: man-pages/man2/listxattr.2:126 man-pages/man2/write.2:96
#: man-pages/man2/brk.2:103 man-pages/man2/mbind.2:328
#: man-pages/man2/pkey_alloc.2:70 man-pages/man2/idle.2:52
#: man-pages/man2/utimensat.2:223 man-pages/man2/nice.2:66
#: man-pages/man2/sched_setscheduler.2:133 man-pages/man2/chown.2:225
#: man-pages/man2/madvise.2:438 man-pages/man2/sched_setattr.2:299
#: man-pages/man2/getresuid.2:50 man-pages/man2/flock.2:112
#: man-pages/man2/getcpu.2:58 man-pages/man2/capget.2:164
#: man-pages/man2/quotactl.2:674 man-pages/man2/modify_ldt.2:137
#: man-pages/man2/sgetmask.2:59 man-pages/man2/ustat.2:68
#: man-pages/man2/gettimeofday.2:141 man-pages/man2/sendfile.2:108
#: man-pages/man2/get_kernel_syms.2:51 man-pages/man2/connect.2:127
#: man-pages/man2/s390_pci_mmio_write.2:67 man-pages/man2/spu_run.2:102
#: man-pages/man2/timerfd_create.2:384 man-pages/man2/subpage_prot.2:66
#: man-pages/man2/lookup_dcookie.2:43 man-pages/man2/mincore.2:97
#: man-pages/man2/shmctl.2:295 man-pages/man2/epoll_wait.2:159
#: man-pages/man2/setup.2:53 man-pages/man2/sigprocmask.2:108
#: man-pages/man2/timer_getoverrun.2:82 man-pages/man2/futimesat.2:84
#: man-pages/man2/getitimer.2:133 man-pages/man2/fork.2:214
#: man-pages/man2/getpeername.2:68 man-pages/man2/create_module.2:30
#: man-pages/man2/sendmmsg.2:119 man-pages/man2/mprotect.2:139
#: man-pages/man2/_exit.2:78 man-pages/man2/add_key.2:143
#: man-pages/man2/restart_syscall.2:88 man-pages/man2/eventfd.2:226
#: man-pages/man2/posix_fadvise.2:127 man-pages/man2/recv.2:430
#: man-pages/man2/fanotify_mark.2:344 man-pages/man2/init_module.2:154
#: man-pages/man2/gethostname.2:96 man-pages/man2/userfaultfd.2:420
#: man-pages/man2/perfmonctl.2:190 man-pages/man2/stat.2:374
#: man-pages/man2/select.2:319 man-pages/man2/get_robust_list.2:101
#: man-pages/man2/link.2:187 man-pages/man2/listen.2:81
#: man-pages/man2/lseek.2:185 man-pages/man2/ioctl_list.2:108
#: man-pages/man2/sysfs.2:76 man-pages/man2/dup.2:150 man-pages/man2/tkill.2:92
#: man-pages/man2/getunwind.2:83 man-pages/man2/accept.2:170
#: man-pages/man2/readahead.2:66 man-pages/man2/nfsservctl.2:56
#: man-pages/man2/bpf.2:1014 man-pages/man2/semctl.2:351
#: man-pages/man2/time.2:46 man-pages/man2/getgroups.2:104
#: man-pages/man2/readlink.2:154 man-pages/man2/ioctl_console.2:803
#: man-pages/man2/s390_runtime_instr.2:54 man-pages/man2/wait.2:383
#: man-pages/man2/fcntl.2:1610 man-pages/man2/syscall.2:74
#: man-pages/man2/setns.2:189 man-pages/man2/mmap.2:494
#: man-pages/man2/getsockopt.2:130 man-pages/man2/ptrace.2:2302
#: man-pages/man2/inotify_init.2:76 man-pages/man2/vhangup.2:58
#: man-pages/man2/getpriority.2:120 man-pages/man2/sysctl.2:73
#: man-pages/man2/mkdir.2:118 man-pages/man2/getsid.2:64
#: man-pages/man2/open_by_handle_at.2:276 man-pages/man2/epoll_ctl.2:259
#: man-pages/man2/wait4.2:142 man-pages/man2/pciconfig_read.2:50
#: man-pages/man2/statfs.2:218 man-pages/man2/sync.2:78
#: man-pages/man2/get_mempolicy.2:176 man-pages/man2/adjtimex.2:375
#: man-pages/man2/migrate_pages.2:88 man-pages/man2/execve.2:418
#: man-pages/man2/fsync.2:112 man-pages/man2/sched_setaffinity.2:107
#: man-pages/man2/reboot.2:212 man-pages/man2/read.2:82
#: man-pages/man2/sigaltstack.2:190 man-pages/man2/uname.2:63
#: man-pages/man2/sigsuspend.2:70 man-pages/man2/mlock.2:178
#: man-pages/man2/futex.2:1317 man-pages/man2/semop.2:298
#: man-pages/man2/clock_getres.2:193 man-pages/man2/getrandom.2:122
#: man-pages/man2/timer_create.2:195 man-pages/man2/exit_group.2:39
#: man-pages/man2/times.2:102 man-pages/man2/setgid.2:56
#: man-pages/man2/ioperm.2:77 man-pages/man2/vm86.2:54
#: man-pages/man2/setpgid.2:196 man-pages/man2/shmop.2:168
#: man-pages/man2/umount.2:113 man-pages/man2/s390_sthyi.2:85
#: man-pages/man2/bdflush.2:88 man-pages/man2/pause.2:42
#: man-pages/man2/process_vm_readv.2:216 man-pages/man2/pread.2:79
#: man-pages/man2/sigpending.2:53 man-pages/man2/unimplemented.2:35
#: man-pages/man2/close.2:65 man-pages/man2/sched_rr_get_interval.2:73
#, no-wrap
msgid "RETURN VALUE"
msgstr ""

#. type: Plain text
#: man-pages/man2/setresuid.2:69 man-pages/man2/bind.2:157
#: man-pages/man2/statx.2:469 man-pages/man2/rmdir.2:45
#: man-pages/man2/acct.2:73 man-pages/man2/getsockname.2:72
#: man-pages/man2/rename.2:308 man-pages/man2/shutdown.2:74
#: man-pages/man2/truncate.2:114 man-pages/man2/swapon.2:118
#: man-pages/man2/chroot.2:121 man-pages/man2/pivot_root.2:98
#: man-pages/man2/setuid.2:78 man-pages/man2/getrusage.2:193
#: man-pages/man2/seteuid.2:73 man-pages/man2/setreuid.2:101
#: man-pages/man2/utime.2:128 man-pages/man2/uselib.2:56
#: man-pages/man2/mount.2:619 man-pages/man2/chmod.2:250
#: man-pages/man2/chdir.2:75 man-pages/man2/stime.2:61
#: man-pages/man2/unlink.2:158 man-pages/man2/symlink.2:146
#: man-pages/man2/msync.2:76 man-pages/man2/getdomainname.2:88
#: man-pages/man2/iopl.2:72 man-pages/man2/chown.2:230
#: man-pages/man2/getresuid.2:55 man-pages/man2/flock.2:117
#: man-pages/man2/capget.2:169 man-pages/man2/getitimer.2:138
#: man-pages/man2/getpeername.2:73 man-pages/man2/gethostname.2:101
#: man-pages/man2/stat.2:379 man-pages/man2/link.2:192
#: man-pages/man2/listen.2:86 man-pages/man2/tkill.2:96
#: man-pages/man2/nfsservctl.2:61 man-pages/man2/vhangup.2:63
#: man-pages/man2/statfs.2:223 man-pages/man2/uname.2:68
#: man-pages/man2/setgid.2:61 man-pages/man2/ioperm.2:82
#: man-pages/man2/vm86.2:59 man-pages/man2/umount.2:118
msgid ""
"On success, zero is returned.  On error, -1 is returned, and I<errno> is set "
"appropriately."
msgstr ""

#. type: Plain text
#: man-pages/man2/setresuid.2:76
msgid ""
"I<Note>: there are cases where B<setresuid>()  can fail even when the caller "
"is UID 0; it is a grave security error to omit checking for a failure return "
"from B<setresuid>()."
msgstr ""

#. type: SH
#: man-pages/man2/setresuid.2:76 man-pages/man2/fallocate.2:304
#: man-pages/man2/signalfd.2:305 man-pages/man2/splice.2:153
#: man-pages/man2/bind.2:157 man-pages/man2/msgop.2:350
#: man-pages/man2/execveat.2:115 man-pages/man2/socketpair.2:84
#: man-pages/man2/seccomp.2:693 man-pages/man2/getrlimit.2:512
#: man-pages/man2/memfd_create.2:164 man-pages/man2/io_setup.2:37
#: man-pages/man2/request_key.2:381 man-pages/man2/set_mempolicy.2:252
#: man-pages/man2/statx.2:469 man-pages/man2/rmdir.2:45
#: man-pages/man2/kill.2:104 man-pages/man2/readdir.2:99
#: man-pages/man2/ioctl_userfaultfd.2:654 man-pages/man2/acct.2:73
#: man-pages/man2/epoll_create.2:84 man-pages/man2/io_submit.2:201
#: man-pages/man2/setsid.2:66 man-pages/man2/io_cancel.2:42
#: man-pages/man2/mknod.2:160 man-pages/man2/getdents.2:185
#: man-pages/man2/personality.2:256 man-pages/man2/timer_settime.2:182
#: man-pages/man2/sigaction.2:843 man-pages/man2/getsockname.2:72
#: man-pages/man2/getpid.2:53 man-pages/man2/poll.2:351
#: man-pages/man2/ioctl_getfsmap.2:330 man-pages/man2/signal.2:105
#: man-pages/man2/rename.2:308 man-pages/man2/shutdown.2:74
#: man-pages/man2/recvmmsg.2:155 man-pages/man2/io_getevents.2:65
#: man-pages/man2/truncate.2:114 man-pages/man2/set_tid_address.2:94
#: man-pages/man2/swapon.2:118 man-pages/man2/open.2:945
#: man-pages/man2/msgget.2:152 man-pages/man2/socket.2:422
#: man-pages/man2/chroot.2:121 man-pages/man2/shmget.2:220
#: man-pages/man2/getxattr.2:110 man-pages/man2/io_destroy.2:34
#: man-pages/man2/setxattr.2:114 man-pages/man2/removexattr.2:83
#: man-pages/man2/ioctl_tty.2:538 man-pages/man2/ioctl_fideduperange.2:151
#: man-pages/man2/pivot_root.2:98 man-pages/man2/ioctl_ns.2:177
#: man-pages/man2/send.2:318 man-pages/man2/msgctl.2:272
#: man-pages/man2/setuid.2:85 man-pages/man2/spu_create.2:172
#: man-pages/man2/membarrier.2:220 man-pages/man2/s390_guarded_storage.2:113
#: man-pages/man2/delete_module.2:129 man-pages/man2/prctl.2:1407
#: man-pages/man2/getrusage.2:193 man-pages/man2/inotify_rm_watch.2:55
#: man-pages/man2/seteuid.2:80 man-pages/man2/set_thread_area.2:146
#: man-pages/man2/semget.2:162 man-pages/man2/pipe.2:170
#: man-pages/man2/setreuid.2:108 man-pages/man2/unshare.2:276
#: man-pages/man2/sched_get_priority_max.2:108 man-pages/man2/utime.2:128
#: man-pages/man2/clock_nanosleep.2:158 man-pages/man2/copy_file_range.2:104
#: man-pages/man2/sched_setparam.2:96 man-pages/man2/sched_yield.2:48
#: man-pages/man2/access.2:199 man-pages/man2/uselib.2:56
#: man-pages/man2/kexec_load.2:247 man-pages/man2/arch_prctl.2:86
#: man-pages/man2/mount.2:619 man-pages/man2/fanotify_init.2:249
#: man-pages/man2/ioctl.2:94 man-pages/man2/tee.2:98 man-pages/man2/chmod.2:250
#: man-pages/man2/move_pages.2:168 man-pages/man2/inotify_add_watch.2:84
#: man-pages/man2/chdir.2:75 man-pages/man2/stime.2:61
#: man-pages/man2/readv.2:288 man-pages/man2/mremap.2:150
#: man-pages/man2/llseek.2:72 man-pages/man2/remap_file_pages.2:145
#: man-pages/man2/rt_sigqueueinfo.2:143 man-pages/man2/mmap2.2:61
#: man-pages/man2/query_module.2:134 man-pages/man2/unlink.2:158
#: man-pages/man2/syslog.2:335 man-pages/man2/symlink.2:146
#: man-pages/man2/gettid.2:49 man-pages/man2/perf_event_open.2:3148
#: man-pages/man2/alloc_hugepages.2:118 man-pages/man2/msync.2:76
#: man-pages/man2/ioprio_set.2:172 man-pages/man2/getdomainname.2:88
#: man-pages/man2/nanosleep.2:110 man-pages/man2/keyctl.2:1663
#: man-pages/man2/sigwaitinfo.2:115 man-pages/man2/clone.2:1027
#: man-pages/man2/timer_delete.2:60 man-pages/man2/ioctl_ficlonerange.2:90
#: man-pages/man2/iopl.2:72 man-pages/man2/cacheflush.2:59
#: man-pages/man2/sysinfo.2:106 man-pages/man2/ioctl_fat.2:200
#: man-pages/man2/kcmp.2:251 man-pages/man2/sync_file_range.2:147
#: man-pages/man2/vmsplice.2:140 man-pages/man2/listxattr.2:132
#: man-pages/man2/write.2:131 man-pages/man2/mbind.2:336
#: man-pages/man2/pkey_alloc.2:80 man-pages/man2/idle.2:55
#: man-pages/man2/utimensat.2:232 man-pages/man2/nice.2:78
#: man-pages/man2/sched_setscheduler.2:143 man-pages/man2/chown.2:230
#: man-pages/man2/madvise.2:445 man-pages/man2/sched_setattr.2:308
#: man-pages/man2/getresuid.2:55 man-pages/man2/flock.2:117
#: man-pages/man2/getcpu.2:63 man-pages/man2/capget.2:183
#: man-pages/man2/quotactl.2:682 man-pages/man2/modify_ldt.2:147
#: man-pages/man2/sgetmask.2:64 man-pages/man2/ustat.2:77
#: man-pages/man2/gettimeofday.2:148 man-pages/man2/sendfile.2:121
#: man-pages/man2/getuid.2:43 man-pages/man2/get_kernel_syms.2:57
#: man-pages/man2/connect.2:132 man-pages/man2/s390_pci_mmio_write.2:76
#: man-pages/man2/spu_run.2:153 man-pages/man2/timerfd_create.2:399
#: man-pages/man2/subpage_prot.2:71 man-pages/man2/lookup_dcookie.2:50
#: man-pages/man2/mincore.2:104 man-pages/man2/shmctl.2:319
#: man-pages/man2/epoll_wait.2:171 man-pages/man2/setup.2:56
#: man-pages/man2/sigprocmask.2:114 man-pages/man2/timer_getoverrun.2:90
#: man-pages/man2/futimesat.2:91 man-pages/man2/getitimer.2:138
#: man-pages/man2/fork.2:221 man-pages/man2/getpeername.2:73
#: man-pages/man2/create_module.2:35 man-pages/man2/sendmmsg.2:133
#: man-pages/man2/mprotect.2:148 man-pages/man2/add_key.2:150
#: man-pages/man2/restart_syscall.2:92 man-pages/man2/eventfd.2:233
#: man-pages/man2/posix_fadvise.2:130 man-pages/man2/recv.2:446
#: man-pages/man2/fanotify_mark.2:351 man-pages/man2/init_module.2:159
#: man-pages/man2/gethostname.2:101 man-pages/man2/userfaultfd.2:427
#: man-pages/man2/stat.2:379 man-pages/man2/select.2:337
#: man-pages/man2/get_robust_list.2:108 man-pages/man2/link.2:192
#: man-pages/man2/listen.2:86 man-pages/man2/lseek.2:193
#: man-pages/man2/sysfs.2:88 man-pages/man2/dup.2:156 man-pages/man2/tkill.2:96
#: man-pages/man2/getgid.2:42 man-pages/man2/getunwind.2:90
#: man-pages/man2/accept.2:206 man-pages/man2/readahead.2:72
#: man-pages/man2/bpf.2:1029 man-pages/man2/semctl.2:404
#: man-pages/man2/time.2:50 man-pages/man2/getgroups.2:118
#: man-pages/man2/readlink.2:163 man-pages/man2/ioctl_console.2:808
#: man-pages/man2/s390_runtime_instr.2:65 man-pages/man2/wait.2:413
#: man-pages/man2/fcntl.2:1648 man-pages/man2/setns.2:196
#: man-pages/man2/mmap.2:513 man-pages/man2/getsockopt.2:139
#: man-pages/man2/ptrace.2:2320 man-pages/man2/inotify_init.2:81
#: man-pages/man2/vhangup.2:63 man-pages/man2/getpriority.2:141
#: man-pages/man2/sysctl.2:80 man-pages/man2/mkdir.2:125
#: man-pages/man2/getsid.2:69 man-pages/man2/open_by_handle_at.2:287
#: man-pages/man2/epoll_ctl.2:268 man-pages/man2/wait4.2:145
#: man-pages/man2/pciconfig_read.2:77 man-pages/man2/statfs.2:223
#: man-pages/man2/sync.2:84 man-pages/man2/get_mempolicy.2:183
#: man-pages/man2/adjtimex.2:449 man-pages/man2/migrate_pages.2:96
#: man-pages/man2/execve.2:424 man-pages/man2/fsync.2:117
#: man-pages/man2/sched_setaffinity.2:119 man-pages/man2/reboot.2:225
#: man-pages/man2/read.2:98 man-pages/man2/sigaltstack.2:194
#: man-pages/man2/uname.2:68 man-pages/man2/sigsuspend.2:76
#: man-pages/man2/mlock.2:184 man-pages/man2/futex.2:1403
#: man-pages/man2/semop.2:308 man-pages/man2/clock_getres.2:201
#: man-pages/man2/getrandom.2:140 man-pages/man2/timer_create.2:203
#: man-pages/man2/times.2:111 man-pages/man2/setgid.2:61
#: man-pages/man2/ioperm.2:82 man-pages/man2/vm86.2:59
#: man-pages/man2/setpgid.2:217 man-pages/man2/shmop.2:182
#: man-pages/man2/umount.2:118 man-pages/man2/s390_sthyi.2:100
#: man-pages/man2/bdflush.2:97 man-pages/man2/pause.2:53
#: man-pages/man2/process_vm_readv.2:236 man-pages/man2/pread.2:97
#: man-pages/man2/sigpending.2:59 man-pages/man2/close.2:71
#: man-pages/man2/sched_rr_get_interval.2:80
#, no-wrap
msgid "ERRORS"
msgstr ""

#. type: TP
#: man-pages/man2/setresuid.2:77 man-pages/man2/setresuid.2:84
#: man-pages/man2/splice.2:154 man-pages/man2/msgop.2:362
#: man-pages/man2/io_setup.2:38 man-pages/man2/ioctl_userfaultfd.2:471
#: man-pages/man2/ioctl_userfaultfd.2:575 man-pages/man2/io_submit.2:202
#: man-pages/man2/io_cancel.2:43 man-pages/man2/send.2:342
#: man-pages/man2/setuid.2:86 man-pages/man2/setuid.2:93
#: man-pages/man2/setreuid.2:109 man-pages/man2/setreuid.2:116
#: man-pages/man2/tee.2:99 man-pages/man2/mremap.2:151
#: man-pages/man2/rt_sigqueueinfo.2:144 man-pages/man2/keyctl.2:1667
#: man-pages/man2/sigwaitinfo.2:116 man-pages/man2/clone.2:1028
#: man-pages/man2/vmsplice.2:141 man-pages/man2/write.2:132
#: man-pages/man2/madvise.2:452 man-pages/man2/sendfile.2:122
#: man-pages/man2/connect.2:169 man-pages/man2/fork.2:222
#: man-pages/man2/fork.2:251 man-pages/man2/tkill.2:97
#: man-pages/man2/tkill.2:104 man-pages/man2/fcntl.2:1652
#: man-pages/man2/mmap.2:532 man-pages/man2/read.2:99
#: man-pages/man2/mlock.2:217 man-pages/man2/futex.2:1407
#: man-pages/man2/futex.2:1425 man-pages/man2/futex.2:1433
#: man-pages/man2/semop.2:327 man-pages/man2/getrandom.2:141
#: man-pages/man2/timer_create.2:204 man-pages/man2/umount.2:124
#, no-wrap
msgid "B<EAGAIN>"
msgstr ""

#. type: Plain text
#: man-pages/man2/setresuid.2:84 man-pages/man2/setreuid.2:116
msgid ""
"The call would change the caller's real UID (i.e., I<ruid> does not match "
"the caller's real UID), but there was a temporary failure allocating the "
"necessary kernel data structures."
msgstr ""

#. type: Plain text
#: man-pages/man2/setresuid.2:99 man-pages/man2/setreuid.2:131
msgid ""
"I<ruid> does not match the caller's real UID and this call would bring the "
"number of processes belonging to the real user ID I<ruid> over the caller's "
"B<RLIMIT_NPROC> resource limit.  Since Linux 3.1, this error case no longer "
"occurs (but robust applications should check for this error); see the "
"description of B<EAGAIN> in B<execve>(2)."
msgstr ""

#. type: TP
#: man-pages/man2/setresuid.2:99 man-pages/man2/fallocate.2:323
#: man-pages/man2/fallocate.2:335 man-pages/man2/fallocate.2:345
#: man-pages/man2/fallocate.2:353 man-pages/man2/fallocate.2:365
#: man-pages/man2/fallocate.2:377 man-pages/man2/signalfd.2:311
#: man-pages/man2/signalfd.2:319 man-pages/man2/splice.2:166
#: man-pages/man2/splice.2:169 man-pages/man2/splice.2:174
#: man-pages/man2/splice.2:177 man-pages/man2/splice.2:180
#: man-pages/man2/bind.2:179 man-pages/man2/bind.2:184
#: man-pages/man2/msgop.2:381 man-pages/man2/msgop.2:431
#: man-pages/man2/execveat.2:126 man-pages/man2/seccomp.2:708
#: man-pages/man2/seccomp.2:712 man-pages/man2/seccomp.2:718
#: man-pages/man2/seccomp.2:725 man-pages/man2/seccomp.2:731
#: man-pages/man2/getrlimit.2:517 man-pages/man2/memfd_create.2:170
#: man-pages/man2/memfd_create.2:174 man-pages/man2/memfd_create.2:181
#: man-pages/man2/io_setup.2:46 man-pages/man2/request_key.2:401
#: man-pages/man2/request_key.2:408 man-pages/man2/set_mempolicy.2:260
#: man-pages/man2/statx.2:488 man-pages/man2/statx.2:492
#: man-pages/man2/rmdir.2:67 man-pages/man2/kill.2:105
#: man-pages/man2/readdir.2:107 man-pages/man2/ioctl_userfaultfd.2:245
#: man-pages/man2/ioctl_userfaultfd.2:250
#: man-pages/man2/ioctl_userfaultfd.2:349
#: man-pages/man2/ioctl_userfaultfd.2:356
#: man-pages/man2/ioctl_userfaultfd.2:359
#: man-pages/man2/ioctl_userfaultfd.2:367
#: man-pages/man2/ioctl_userfaultfd.2:391
#: man-pages/man2/ioctl_userfaultfd.2:402
#: man-pages/man2/ioctl_userfaultfd.2:405
#: man-pages/man2/ioctl_userfaultfd.2:479
#: man-pages/man2/ioctl_userfaultfd.2:494
#: man-pages/man2/ioctl_userfaultfd.2:583
#: man-pages/man2/ioctl_userfaultfd.2:592
#: man-pages/man2/ioctl_userfaultfd.2:641
#: man-pages/man2/ioctl_userfaultfd.2:662 man-pages/man2/epoll_create.2:85
#: man-pages/man2/epoll_create.2:89 man-pages/man2/io_submit.2:211
#: man-pages/man2/io_cancel.2:49 man-pages/man2/mknod.2:183
#: man-pages/man2/getdents.2:193 man-pages/man2/personality.2:257
#: man-pages/man2/timer_settime.2:191 man-pages/man2/timer_settime.2:199
#: man-pages/man2/sigaction.2:848 man-pages/man2/getsockname.2:84
#: man-pages/man2/poll.2:360 man-pages/man2/poll.2:367
#: man-pages/man2/ioctl_getfsmap.2:344 man-pages/man2/signal.2:106
#: man-pages/man2/rename.2:351 man-pages/man2/rename.2:476
#: man-pages/man2/rename.2:480 man-pages/man2/rename.2:488
#: man-pages/man2/rename.2:496 man-pages/man2/shutdown.2:79
#: man-pages/man2/recvmmsg.2:159 man-pages/man2/io_getevents.2:73
#: man-pages/man2/truncate.2:140 man-pages/man2/truncate.2:195
#: man-pages/man2/swapon.2:126 man-pages/man2/swapon.2:131
#: man-pages/man2/swapon.2:142 man-pages/man2/open.2:987
#: man-pages/man2/open.2:995 man-pages/man2/open.2:1000
#: man-pages/man2/open.2:1010 man-pages/man2/socket.2:430
#: man-pages/man2/socket.2:433 man-pages/man2/shmget.2:239
#: man-pages/man2/shmget.2:247 man-pages/man2/io_destroy.2:38
#: man-pages/man2/ioctl_tty.2:539 man-pages/man2/ioctl_fideduperange.2:162
#: man-pages/man2/pivot_root.2:127 man-pages/man2/pivot_root.2:131
#: man-pages/man2/pivot_root.2:134 man-pages/man2/pivot_root.2:139
#: man-pages/man2/pivot_root.2:142 man-pages/man2/pivot_root.2:149
#: man-pages/man2/ioctl_ns.2:111 man-pages/man2/ioctl_ns.2:173
#: man-pages/man2/send.2:375 man-pages/man2/msgctl.2:303
#: man-pages/man2/setuid.2:108 man-pages/man2/spu_create.2:186
#: man-pages/man2/membarrier.2:221 man-pages/man2/s390_guarded_storage.2:122
#: man-pages/man2/prctl.2:1473 man-pages/man2/prctl.2:1478
#: man-pages/man2/prctl.2:1490 man-pages/man2/prctl.2:1495
#: man-pages/man2/prctl.2:1504 man-pages/man2/prctl.2:1514
#: man-pages/man2/prctl.2:1554 man-pages/man2/prctl.2:1564
#: man-pages/man2/prctl.2:1572 man-pages/man2/prctl.2:1583
#: man-pages/man2/prctl.2:1592 man-pages/man2/prctl.2:1606
#: man-pages/man2/prctl.2:1618 man-pages/man2/prctl.2:1629
#: man-pages/man2/prctl.2:1641 man-pages/man2/prctl.2:1666
#: man-pages/man2/getrusage.2:198 man-pages/man2/inotify_rm_watch.2:60
#: man-pages/man2/seteuid.2:81 man-pages/man2/set_thread_area.2:150
#: man-pages/man2/semget.2:186 man-pages/man2/semget.2:192
#: man-pages/man2/pipe.2:175 man-pages/man2/setreuid.2:131
#: man-pages/man2/unshare.2:277 man-pages/man2/unshare.2:281
#: man-pages/man2/unshare.2:290 man-pages/man2/unshare.2:300
#: man-pages/man2/unshare.2:308 man-pages/man2/unshare.2:316
#: man-pages/man2/unshare.2:324 man-pages/man2/unshare.2:332
#: man-pages/man2/sched_get_priority_max.2:109
#: man-pages/man2/clock_nanosleep.2:169 man-pages/man2/clock_nanosleep.2:176
#: man-pages/man2/copy_file_range.2:137 man-pages/man2/copy_file_range.2:142
#: man-pages/man2/copy_file_range.2:148 man-pages/man2/sched_setparam.2:97
#: man-pages/man2/sched_setparam.2:104 man-pages/man2/access.2:241
#: man-pages/man2/access.2:262 man-pages/man2/kexec_load.2:279
#: man-pages/man2/kexec_load.2:283 man-pages/man2/kexec_load.2:292
#: man-pages/man2/kexec_load.2:298 man-pages/man2/kexec_load.2:301
#: man-pages/man2/kexec_load.2:306 man-pages/man2/arch_prctl.2:91
#: man-pages/man2/mount.2:673 man-pages/man2/mount.2:677
#: man-pages/man2/mount.2:685 man-pages/man2/mount.2:695
#: man-pages/man2/mount.2:703 man-pages/man2/mount.2:710
#: man-pages/man2/mount.2:719 man-pages/man2/mount.2:732
#: man-pages/man2/mount.2:735 man-pages/man2/fanotify_init.2:250
#: man-pages/man2/ioctl.2:103 man-pages/man2/tee.2:107
#: man-pages/man2/chmod.2:329 man-pages/man2/move_pages.2:183
#: man-pages/man2/inotify_add_watch.2:104 man-pages/man2/readv.2:302
#: man-pages/man2/readv.2:309 man-pages/man2/mremap.2:166
#: man-pages/man2/llseek.2:80 man-pages/man2/remap_file_pages.2:146
#: man-pages/man2/remap_file_pages.2:153 man-pages/man2/rt_sigqueueinfo.2:150
#: man-pages/man2/mmap2.2:65 man-pages/man2/query_module.2:143
#: man-pages/man2/unlink.2:257 man-pages/man2/syslog.2:336
#: man-pages/man2/perf_event_open.2:3204 man-pages/man2/msync.2:83
#: man-pages/man2/ioprio_set.2:173 man-pages/man2/getdomainname.2:95
#: man-pages/man2/getdomainname.2:108 man-pages/man2/nanosleep.2:125
#: man-pages/man2/keyctl.2:1734 man-pages/man2/keyctl.2:1741
#: man-pages/man2/keyctl.2:1764 man-pages/man2/keyctl.2:1770
#: man-pages/man2/keyctl.2:1777 man-pages/man2/keyctl.2:1790
#: man-pages/man2/sigwaitinfo.2:130 man-pages/man2/clone.2:1032
#: man-pages/man2/clone.2:1040 man-pages/man2/clone.2:1055
#: man-pages/man2/clone.2:1065 man-pages/man2/clone.2:1082
#: man-pages/man2/clone.2:1090 man-pages/man2/clone.2:1102
#: man-pages/man2/clone.2:1111 man-pages/man2/clone.2:1121
#: man-pages/man2/clone.2:1129 man-pages/man2/clone.2:1137
#: man-pages/man2/clone.2:1145 man-pages/man2/clone.2:1153
#: man-pages/man2/clone.2:1160 man-pages/man2/clone.2:1165
#: man-pages/man2/clone.2:1170 man-pages/man2/timer_delete.2:61
#: man-pages/man2/ioctl_ficlonerange.2:101 man-pages/man2/iopl.2:73
#: man-pages/man2/cacheflush.2:67 man-pages/man2/kcmp.2:267
#: man-pages/man2/sync_file_range.2:152 man-pages/man2/vmsplice.2:151
#: man-pages/man2/write.2:183 man-pages/man2/mbind.2:349
#: man-pages/man2/pkey_alloc.2:81 man-pages/man2/utimensat.2:303
#: man-pages/man2/utimensat.2:307 man-pages/man2/utimensat.2:318
#: man-pages/man2/sched_setscheduler.2:144
#: man-pages/man2/sched_setscheduler.2:151
#: man-pages/man2/sched_setscheduler.2:156 man-pages/man2/chown.2:306
#: man-pages/man2/madvise.2:458 man-pages/man2/madvise.2:466
#: man-pages/man2/madvise.2:470 man-pages/man2/madvise.2:480
#: man-pages/man2/madvise.2:489 man-pages/man2/sched_setattr.2:313
#: man-pages/man2/sched_setattr.2:337 man-pages/man2/sched_setattr.2:360
#: man-pages/man2/flock.2:127 man-pages/man2/capget.2:192
#: man-pages/man2/quotactl.2:707 man-pages/man2/quotactl.2:713
#: man-pages/man2/modify_ldt.2:152 man-pages/man2/ustat.2:82
#: man-pages/man2/gettimeofday.2:156 man-pages/man2/gettimeofday.2:161
#: man-pages/man2/sendfile.2:134 man-pages/man2/sendfile.2:143
#: man-pages/man2/s390_pci_mmio_write.2:86 man-pages/man2/spu_run.2:174
#: man-pages/man2/timerfd_create.2:402 man-pages/man2/timerfd_create.2:410
#: man-pages/man2/timerfd_create.2:446 man-pages/man2/timerfd_create.2:453
#: man-pages/man2/timerfd_create.2:459 man-pages/man2/subpage_prot.2:77
#: man-pages/man2/lookup_dcookie.2:54 man-pages/man2/mincore.2:111
#: man-pages/man2/shmctl.2:342 man-pages/man2/epoll_wait.2:188
#: man-pages/man2/sigprocmask.2:122 man-pages/man2/timer_getoverrun.2:91
#: man-pages/man2/getitimer.2:146 man-pages/man2/getpeername.2:85
#: man-pages/man2/create_module.2:43 man-pages/man2/mprotect.2:158
#: man-pages/man2/mprotect.2:162 man-pages/man2/mprotect.2:167
#: man-pages/man2/mprotect.2:175 man-pages/man2/mprotect.2:179
#: man-pages/man2/add_key.2:166 man-pages/man2/add_key.2:173
#: man-pages/man2/add_key.2:176 man-pages/man2/eventfd.2:234
#: man-pages/man2/posix_fadvise.2:134 man-pages/man2/recv.2:478
#: man-pages/man2/fanotify_mark.2:356 man-pages/man2/fanotify_mark.2:365
#: man-pages/man2/init_module.2:201 man-pages/man2/init_module.2:236
#: man-pages/man2/gethostname.2:106 man-pages/man2/userfaultfd.2:392
#: man-pages/man2/userfaultfd.2:428 man-pages/man2/stat.2:447
#: man-pages/man2/select.2:348 man-pages/man2/select.2:355
#: man-pages/man2/get_robust_list.2:112 man-pages/man2/link.2:295
#: man-pages/man2/lseek.2:198 man-pages/man2/sysfs.2:93
#: man-pages/man2/dup.2:186 man-pages/man2/dup.2:191 man-pages/man2/tkill.2:109
#: man-pages/man2/accept.2:233 man-pages/man2/accept.2:238
#: man-pages/man2/readahead.2:77 man-pages/man2/bpf.2:1067
#: man-pages/man2/bpf.2:1072 man-pages/man2/bpf.2:1079
#: man-pages/man2/bpf.2:1088 man-pages/man2/semctl.2:438
#: man-pages/man2/getgroups.2:126 man-pages/man2/getgroups.2:133
#: man-pages/man2/readlink.2:173 man-pages/man2/readlink.2:182
#: man-pages/man2/ioctl_console.2:814 man-pages/man2/s390_runtime_instr.2:66
#: man-pages/man2/wait.2:446 man-pages/man2/fcntl.2:1719
#: man-pages/man2/fcntl.2:1724 man-pages/man2/fcntl.2:1732
#: man-pages/man2/fcntl.2:1742 man-pages/man2/fcntl.2:1754
#: man-pages/man2/fcntl.2:1762 man-pages/man2/setns.2:201
#: man-pages/man2/setns.2:206 man-pages/man2/setns.2:210
#: man-pages/man2/setns.2:215 man-pages/man2/setns.2:219
#: man-pages/man2/setns.2:226 man-pages/man2/mmap.2:552
#: man-pages/man2/mmap.2:560 man-pages/man2/mmap.2:565
#: man-pages/man2/getsockopt.2:155 man-pages/man2/ptrace.2:2335
#: man-pages/man2/inotify_init.2:82 man-pages/man2/getpriority.2:142
#: man-pages/man2/mkdir.2:148 man-pages/man2/open_by_handle_at.2:304
#: man-pages/man2/open_by_handle_at.2:308
#: man-pages/man2/open_by_handle_at.2:356 man-pages/man2/epoll_ctl.2:283
#: man-pages/man2/epoll_ctl.2:296 man-pages/man2/epoll_ctl.2:302
#: man-pages/man2/epoll_ctl.2:311 man-pages/man2/epoll_ctl.2:321
#: man-pages/man2/pciconfig_read.2:78 man-pages/man2/get_mempolicy.2:191
#: man-pages/man2/adjtimex.2:468 man-pages/man2/adjtimex.2:473
#: man-pages/man2/migrate_pages.2:104 man-pages/man2/execve.2:467
#: man-pages/man2/sched_setaffinity.2:123
#: man-pages/man2/sched_setaffinity.2:133 man-pages/man2/reboot.2:230
#: man-pages/man2/read.2:134 man-pages/man2/read.2:145
#: man-pages/man2/sigaltstack.2:199 man-pages/man2/mlock.2:220
#: man-pages/man2/mlock.2:227 man-pages/man2/mlock.2:248
#: man-pages/man2/mlock.2:254 man-pages/man2/futex.2:1485
#: man-pages/man2/futex.2:1496 man-pages/man2/futex.2:1506
#: man-pages/man2/futex.2:1513 man-pages/man2/futex.2:1520
#: man-pages/man2/futex.2:1526 man-pages/man2/futex.2:1539
#: man-pages/man2/futex.2:1554 man-pages/man2/futex.2:1569
#: man-pages/man2/futex.2:1581 man-pages/man2/futex.2:1593
#: man-pages/man2/futex.2:1603 man-pages/man2/futex.2:1609
#: man-pages/man2/semop.2:356 man-pages/man2/clock_getres.2:206
#: man-pages/man2/clock_getres.2:214 man-pages/man2/getrandom.2:163
#: man-pages/man2/timer_create.2:207 man-pages/man2/setgid.2:62
#: man-pages/man2/ioperm.2:83 man-pages/man2/setpgid.2:226
#: man-pages/man2/shmop.2:197 man-pages/man2/shmop.2:220
#: man-pages/man2/umount.2:139 man-pages/man2/umount.2:143
#: man-pages/man2/s390_sthyi.2:108 man-pages/man2/bdflush.2:106
#: man-pages/man2/process_vm_readv.2:248 man-pages/man2/process_vm_readv.2:259
#: man-pages/man2/process_vm_readv.2:263
#: man-pages/man2/sched_rr_get_interval.2:84
#, no-wrap
msgid "B<EINVAL>"
msgstr ""

#. type: Plain text
#: man-pages/man2/setresuid.2:103 man-pages/man2/setreuid.2:135
msgid ""
"One or more of the target user or group IDs is not valid in this user "
"namespace."
msgstr ""

#. type: TP
#: man-pages/man2/setresuid.2:103 man-pages/man2/fallocate.2:424
#: man-pages/man2/fallocate.2:430 man-pages/man2/fallocate.2:445
#: man-pages/man2/getrlimit.2:529 man-pages/man2/getrlimit.2:534
#: man-pages/man2/getrlimit.2:542 man-pages/man2/request_key.2:428
#: man-pages/man2/rmdir.2:108 man-pages/man2/rmdir.2:119
#: man-pages/man2/kill.2:108 man-pages/man2/acct.2:125
#: man-pages/man2/io_submit.2:225 man-pages/man2/setsid.2:67
#: man-pages/man2/mknod.2:213 man-pages/man2/rename.2:508
#: man-pages/man2/truncate.2:164 man-pages/man2/truncate.2:170
#: man-pages/man2/swapon.2:158 man-pages/man2/open.2:1159
#: man-pages/man2/open.2:1166 man-pages/man2/chroot.2:157
#: man-pages/man2/shmget.2:273 man-pages/man2/setxattr.2:143
#: man-pages/man2/ioctl_tty.2:549 man-pages/man2/ioctl_fideduperange.2:186
#: man-pages/man2/pivot_root.2:157 man-pages/man2/ioctl_ns.2:97
#: man-pages/man2/msgctl.2:314 man-pages/man2/msgctl.2:332
#: man-pages/man2/setuid.2:113 man-pages/man2/spu_create.2:233
#: man-pages/man2/membarrier.2:240 man-pages/man2/delete_module.2:150
#: man-pages/man2/prctl.2:1708 man-pages/man2/prctl.2:1720
#: man-pages/man2/prctl.2:1728 man-pages/man2/prctl.2:1738
#: man-pages/man2/prctl.2:1746 man-pages/man2/prctl.2:1754
#: man-pages/man2/seteuid.2:84 man-pages/man2/setreuid.2:135
#: man-pages/man2/unshare.2:376 man-pages/man2/unshare.2:379
#: man-pages/man2/utime.2:152 man-pages/man2/copy_file_range.2:175
#: man-pages/man2/sched_setparam.2:109 man-pages/man2/kexec_load.2:323
#: man-pages/man2/arch_prctl.2:95 man-pages/man2/mount.2:788
#: man-pages/man2/fanotify_init.2:276 man-pages/man2/chmod.2:286
#: man-pages/man2/chmod.2:292 man-pages/man2/chmod.2:312
#: man-pages/man2/move_pages.2:199 man-pages/man2/stime.2:65
#: man-pages/man2/rt_sigqueueinfo.2:157 man-pages/man2/rt_sigqueueinfo.2:162
#: man-pages/man2/unlink.2:212 man-pages/man2/unlink.2:235
#: man-pages/man2/syslog.2:360 man-pages/man2/symlink.2:199
#: man-pages/man2/perf_event_open.2:3281 man-pages/man2/ioprio_set.2:182
#: man-pages/man2/getdomainname.2:99 man-pages/man2/keyctl.2:1919
#: man-pages/man2/keyctl.2:1929 man-pages/man2/clone.2:1210
#: man-pages/man2/clone.2:1220 man-pages/man2/clone.2:1225
#: man-pages/man2/ioctl_ficlonerange.2:118 man-pages/man2/iopl.2:80
#: man-pages/man2/kcmp.2:276 man-pages/man2/write.2:227
#: man-pages/man2/mbind.2:411 man-pages/man2/idle.2:56
#: man-pages/man2/utimensat.2:361 man-pages/man2/nice.2:79
#: man-pages/man2/sched_setscheduler.2:162 man-pages/man2/chown.2:263
#: man-pages/man2/chown.2:267 man-pages/man2/chown.2:289
#: man-pages/man2/madvise.2:516 man-pages/man2/sched_setattr.2:376
#: man-pages/man2/sched_setattr.2:379 man-pages/man2/capget.2:195
#: man-pages/man2/capget.2:200 man-pages/man2/quotactl.2:735
#: man-pages/man2/gettimeofday.2:177 man-pages/man2/lookup_dcookie.2:65
#: man-pages/man2/shmctl.2:369 man-pages/man2/setup.2:57
#: man-pages/man2/create_module.2:55 man-pages/man2/add_key.2:197
#: man-pages/man2/add_key.2:203 man-pages/man2/init_module.2:184
#: man-pages/man2/gethostname.2:124 man-pages/man2/get_robust_list.2:125
#: man-pages/man2/link.2:253 man-pages/man2/link.2:257
#: man-pages/man2/link.2:269 man-pages/man2/link.2:338
#: man-pages/man2/tkill.2:112 man-pages/man2/accept.2:270
#: man-pages/man2/bpf.2:1108 man-pages/man2/semctl.2:449
#: man-pages/man2/getgroups.2:142 man-pages/man2/ioctl_console.2:823
#: man-pages/man2/fcntl.2:1792 man-pages/man2/fcntl.2:1799
#: man-pages/man2/fcntl.2:1804 man-pages/man2/setns.2:233
#: man-pages/man2/mmap.2:616 man-pages/man2/mmap.2:625
#: man-pages/man2/ptrace.2:2345 man-pages/man2/vhangup.2:64
#: man-pages/man2/getpriority.2:168 man-pages/man2/mkdir.2:187
#: man-pages/man2/getsid.2:70 man-pages/man2/open_by_handle_at.2:369
#: man-pages/man2/epoll_ctl.2:361 man-pages/man2/pciconfig_read.2:105
#: man-pages/man2/adjtimex.2:484 man-pages/man2/migrate_pages.2:121
#: man-pages/man2/execve.2:523 man-pages/man2/execve.2:529
#: man-pages/man2/execve.2:533 man-pages/man2/sched_setaffinity.2:140
#: man-pages/man2/reboot.2:233 man-pages/man2/sigaltstack.2:209
#: man-pages/man2/mlock.2:205 man-pages/man2/mlock.2:265
#: man-pages/man2/futex.2:1647 man-pages/man2/futex.2:1659
#: man-pages/man2/clock_getres.2:234 man-pages/man2/setgid.2:67
#: man-pages/man2/ioperm.2:96 man-pages/man2/vm86.2:68
#: man-pages/man2/setpgid.2:232 man-pages/man2/umount.2:167
#: man-pages/man2/bdflush.2:110 man-pages/man2/process_vm_readv.2:274
#, no-wrap
msgid "B<EPERM>"
msgstr ""

#. type: Plain text
#: man-pages/man2/setresuid.2:116
msgid ""
"The calling process is not privileged (did not have the necessary capability "
"in its user namespace)  and tried to change the IDs to values that are not "
"permitted.  For B<setresuid>(), the necessary capability is B<CAP_SETUID>; "
"for B<setresgid>(), it is B<CAP_SETGID>."
msgstr ""

#. type: SH
#: man-pages/man2/setresuid.2:116 man-pages/man2/fallocate.2:463
#: man-pages/man2/signalfd.2:339 man-pages/man2/splice.2:196
#: man-pages/man2/execveat.2:160 man-pages/man2/seccomp.2:765
#: man-pages/man2/getrlimit.2:552 man-pages/man2/memfd_create.2:198
#: man-pages/man2/io_setup.2:58 man-pages/man2/request_key.2:433
#: man-pages/man2/set_mempolicy.2:300 man-pages/man2/statx.2:528
#: man-pages/man2/epoll_create.2:111 man-pages/man2/io_submit.2:234
#: man-pages/man2/io_cancel.2:56 man-pages/man2/mknod.2:244
#: man-pages/man2/personality.2:260 man-pages/man2/timer_settime.2:205
#: man-pages/man2/poll.2:376 man-pages/man2/ioctl_getfsmap.2:359
#: man-pages/man2/rename.2:516 man-pages/man2/recvmmsg.2:165
#: man-pages/man2/io_getevents.2:82 man-pages/man2/set_tid_address.2:97
#: man-pages/man2/open.2:1211 man-pages/man2/getxattr.2:140
#: man-pages/man2/io_destroy.2:45 man-pages/man2/setxattr.2:159
#: man-pages/man2/removexattr.2:99 man-pages/man2/ioctl_fideduperange.2:198
#: man-pages/man2/pivot_root.2:162 man-pages/man2/setfsuid.2:77
#: man-pages/man2/spu_create.2:246 man-pages/man2/membarrier.2:244
#: man-pages/man2/s390_guarded_storage.2:136 man-pages/man2/prctl.2:1781
#: man-pages/man2/inotify_rm_watch.2:67 man-pages/man2/set_thread_area.2:163
#: man-pages/man2/pipe.2:191 man-pages/man2/unshare.2:406
#: man-pages/man2/setfsgid.2:66 man-pages/man2/clock_nanosleep.2:183
#: man-pages/man2/copy_file_range.2:191 man-pages/man2/access.2:272
#: man-pages/man2/kexec_load.2:328 man-pages/man2/mount.2:799
#: man-pages/man2/fanotify_init.2:281 man-pages/man2/tee.2:120
#: man-pages/man2/chmod.2:345 man-pages/man2/move_pages.2:211
#: man-pages/man2/inotify_add_watch.2:139 man-pages/man2/readv.2:317
#: man-pages/man2/remap_file_pages.2:162 man-pages/man2/rt_sigqueueinfo.2:181
#: man-pages/man2/mmap2.2:74 man-pages/man2/query_module.2:168
#: man-pages/man2/unlink.2:274 man-pages/man2/symlink.2:227
#: man-pages/man2/gettid.2:51 man-pages/man2/ioprio_set.2:196
#: man-pages/man2/keyctl.2:1950 man-pages/man2/timer_delete.2:65
#: man-pages/man2/ioctl_ficlonerange.2:130 man-pages/man2/sysinfo.2:111
#: man-pages/man2/ioctl_fat.2:227 man-pages/man2/kcmp.2:298
#: man-pages/man2/sync_file_range.2:174 man-pages/man2/vmsplice.2:162
#: man-pages/man2/listxattr.2:154 man-pages/man2/mbind.2:421
#: man-pages/man2/pkey_alloc.2:103 man-pages/man2/idle.2:59
#: man-pages/man2/utimensat.2:407 man-pages/man2/chown.2:316
#: man-pages/man2/madvise.2:524 man-pages/man2/sched_setattr.2:386
#: man-pages/man2/getresuid.2:60 man-pages/man2/getcpu.2:67
#: man-pages/man2/sgetmask.2:66 man-pages/man2/ustat.2:92
#: man-pages/man2/sendfile.2:169 man-pages/man2/get_kernel_syms.2:63
#: man-pages/man2/s390_pci_mmio_write.2:97 man-pages/man2/spu_run.2:188
#: man-pages/man2/timerfd_create.2:465 man-pages/man2/subpage_prot.2:90
#: man-pages/man2/lookup_dcookie.2:73 man-pages/man2/mincore.2:135
#: man-pages/man2/epoll_wait.2:196 man-pages/man2/setup.2:60
#: man-pages/man2/timer_getoverrun.2:95 man-pages/man2/futimesat.2:108
#: man-pages/man2/create_module.2:61 man-pages/man2/sendmmsg.2:146
#: man-pages/man2/mprotect.2:211 man-pages/man2/add_key.2:213
#: man-pages/man2/restart_syscall.2:96 man-pages/man2/eventfd.2:257
#: man-pages/man2/posix_fadvise.2:147 man-pages/man2/fanotify_mark.2:447
#: man-pages/man2/init_module.2:256 man-pages/man2/userfaultfd.2:443
#: man-pages/man2/perfmonctl.2:196 man-pages/man2/stat.2:457
#: man-pages/man2/select.2:363 man-pages/man2/get_robust_list.2:138
#: man-pages/man2/link.2:347 man-pages/man2/dup.2:204
#: man-pages/man2/tkill.2:120 man-pages/man2/getunwind.2:96
#: man-pages/man2/accept.2:285 man-pages/man2/readahead.2:83
#: man-pages/man2/nfsservctl.2:61 man-pages/man2/bpf.2:1114
#: man-pages/man2/readlink.2:218 man-pages/man2/s390_runtime_instr.2:79
#: man-pages/man2/setns.2:237 man-pages/man2/inotify_init.2:99
#: man-pages/man2/mkdir.2:209 man-pages/man2/getsid.2:81
#: man-pages/man2/open_by_handle_at.2:380 man-pages/man2/epoll_ctl.2:370
#: man-pages/man2/sync.2:94 man-pages/man2/get_mempolicy.2:235
#: man-pages/man2/migrate_pages.2:136 man-pages/man2/sched_setaffinity.2:154
#: man-pages/man2/mlock.2:269 man-pages/man2/futex.2:1687
#: man-pages/man2/semop.2:379 man-pages/man2/clock_getres.2:238
#: man-pages/man2/getrandom.2:172 man-pages/man2/timer_create.2:219
#: man-pages/man2/exit_group.2:41 man-pages/man2/umount.2:170
#: man-pages/man2/s390_sthyi.2:121 man-pages/man2/bdflush.2:115
#: man-pages/man2/process_vm_readv.2:283 man-pages/man2/pread.2:112
#, no-wrap
msgid "VERSIONS"
msgstr ""

#. type: Plain text
#: man-pages/man2/setresuid.2:118
msgid "These calls are available under Linux since Linux 2.1.44."
msgstr ""

#. type: SH
#: man-pages/man2/setresuid.2:118 man-pages/man2/fallocate.2:471
#: man-pages/man2/signalfd.2:347 man-pages/man2/splice.2:201
#: man-pages/man2/bind.2:232 man-pages/man2/msgop.2:474
#: man-pages/man2/execveat.2:165 man-pages/man2/socketpair.2:105
#: man-pages/man2/seccomp.2:770 man-pages/man2/getrlimit.2:572
#: man-pages/man2/memfd_create.2:203 man-pages/man2/io_setup.2:61
#: man-pages/man2/request_key.2:438 man-pages/man2/set_mempolicy.2:304
#: man-pages/man2/statx.2:531 man-pages/man2/rmdir.2:128
#: man-pages/man2/kill.2:120 man-pages/man2/readdir.2:116
#: man-pages/man2/ioctl_userfaultfd.2:669 man-pages/man2/acct.2:138
#: man-pages/man2/epoll_create.2:121 man-pages/man2/io_submit.2:237
#: man-pages/man2/setsid.2:73 man-pages/man2/io_cancel.2:59
#: man-pages/man2/mknod.2:248 man-pages/man2/getdents.2:202
#: man-pages/man2/umask.2:115 man-pages/man2/personality.2:266
#: man-pages/man2/timer_settime.2:207 man-pages/man2/sigaction.2:855
#: man-pages/man2/getsockname.2:97 man-pages/man2/getpid.2:55
#: man-pages/man2/poll.2:393 man-pages/man2/ioctl_getfsmap.2:363
#: man-pages/man2/signal.2:110 man-pages/man2/rename.2:523
#: man-pages/man2/outb.2:87 man-pages/man2/shutdown.2:92
#: man-pages/man2/recvmmsg.2:170 man-pages/man2/io_getevents.2:85
#: man-pages/man2/truncate.2:208 man-pages/man2/set_tid_address.2:100
#: man-pages/man2/swapon.2:165 man-pages/man2/open.2:1215
#: man-pages/man2/msgget.2:191 man-pages/man2/socket.2:455
#: man-pages/man2/chroot.2:160 man-pages/man2/shmget.2:280
#: man-pages/man2/getxattr.2:143 man-pages/man2/io_destroy.2:48
#: man-pages/man2/setxattr.2:162 man-pages/man2/removexattr.2:102
#: man-pages/man2/ioctl_fideduperange.2:203 man-pages/man2/pivot_root.2:165
#: man-pages/man2/setfsuid.2:81 man-pages/man2/ioctl_ns.2:187
#: man-pages/man2/send.2:423 man-pages/man2/msgctl.2:343
#: man-pages/man2/sigreturn.2:70 man-pages/man2/setuid.2:120
#: man-pages/man2/spu_create.2:250 man-pages/man2/membarrier.2:249
#: man-pages/man2/s390_guarded_storage.2:139 man-pages/man2/delete_module.2:172
#: man-pages/man2/prctl.2:1786 man-pages/man2/getrusage.2:215
#: man-pages/man2/inotify_rm_watch.2:69 man-pages/man2/seteuid.2:103
#: man-pages/man2/set_thread_area.2:168 man-pages/man2/semget.2:219
#: man-pages/man2/pipe.2:213 man-pages/man2/setreuid.2:151
#: man-pages/man2/unshare.2:410 man-pages/man2/setfsgid.2:70
#: man-pages/man2/sched_get_priority_max.2:114 man-pages/man2/utime.2:165
#: man-pages/man2/clock_nanosleep.2:188 man-pages/man2/copy_file_range.2:205
#: man-pages/man2/sched_setparam.2:119 man-pages/man2/sched_yield.2:52
#: man-pages/man2/access.2:276 man-pages/man2/intro.2:93
#: man-pages/man2/uselib.2:79 man-pages/man2/kexec_load.2:335
#: man-pages/man2/arch_prctl.2:101 man-pages/man2/mount.2:813
#: man-pages/man2/fanotify_init.2:285 man-pages/man2/ioctl.2:119
#: man-pages/man2/tee.2:125 man-pages/man2/chmod.2:349
#: man-pages/man2/move_pages.2:214 man-pages/man2/inotify_add_watch.2:141
#: man-pages/man2/chdir.2:131 man-pages/man2/stime.2:71
#: man-pages/man2/readv.2:328 man-pages/man2/mremap.2:216
#: man-pages/man2/llseek.2:84 man-pages/man2/remap_file_pages.2:167
#: man-pages/man2/rt_sigqueueinfo.2:188 man-pages/man2/mmap2.2:77
#: man-pages/man2/query_module.2:172 man-pages/man2/unlink.2:278
#: man-pages/man2/syslog.2:375 man-pages/man2/symlink.2:231
#: man-pages/man2/gettid.2:61 man-pages/man2/socketcall.2:150
#: man-pages/man2/perf_event_open.2:3305 man-pages/man2/alloc_hugepages.2:131
#: man-pages/man2/msync.2:99 man-pages/man2/ioprio_set.2:199
#: man-pages/man2/getdomainname.2:119 man-pages/man2/nanosleep.2:132
#: man-pages/man2/keyctl.2:1952 man-pages/man2/sigwaitinfo.2:134
#: man-pages/man2/clone.2:1264 man-pages/man2/timer_delete.2:67
#: man-pages/man2/ioctl_ficlonerange.2:137 man-pages/man2/iopl.2:88
#: man-pages/man2/cacheflush.2:76 man-pages/man2/_syscall.2:87
#: man-pages/man2/alarm.2:59 man-pages/man2/sysinfo.2:114
#: man-pages/man2/ioctl_fat.2:244 man-pages/man2/kcmp.2:302
#: man-pages/man2/sync_file_range.2:177 man-pages/man2/vmsplice.2:167
#: man-pages/man2/listxattr.2:157 man-pages/man2/write.2:243
#: man-pages/man2/brk.2:123 man-pages/man2/mbind.2:425
#: man-pages/man2/pkey_alloc.2:109 man-pages/man2/idle.2:61
#: man-pages/man2/ioctl_iflags.2:193 man-pages/man2/utimensat.2:429
#: man-pages/man2/mq_getsetattr.2:50 man-pages/man2/nice.2:92
#: man-pages/man2/sched_setscheduler.2:168 man-pages/man2/chown.2:320
#: man-pages/man2/madvise.2:531 man-pages/man2/sched_setattr.2:389
#: man-pages/man2/getresuid.2:67 man-pages/man2/flock.2:139
#: man-pages/man2/ipc.2:45 man-pages/man2/getcpu.2:74
#: man-pages/man2/capget.2:222 man-pages/man2/modify_ldt.2:169
#: man-pages/man2/sgetmask.2:73 man-pages/man2/ustat.2:94
#: man-pages/man2/gettimeofday.2:184 man-pages/man2/sendfile.2:175
#: man-pages/man2/getuid.2:45 man-pages/man2/get_kernel_syms.2:67
#: man-pages/man2/connect.2:246 man-pages/man2/s390_pci_mmio_write.2:99
#: man-pages/man2/spu_run.2:192 man-pages/man2/timerfd_create.2:468
#: man-pages/man2/subpage_prot.2:96 man-pages/man2/lookup_dcookie.2:78
#: man-pages/man2/mincore.2:137 man-pages/man2/shmctl.2:393
#: man-pages/man2/epoll_wait.2:206 man-pages/man2/setup.2:62
#: man-pages/man2/sigprocmask.2:128 man-pages/man2/timer_getoverrun.2:97
#: man-pages/man2/futimesat.2:112 man-pages/man2/getitimer.2:159
#: man-pages/man2/fork.2:279 man-pages/man2/getpeername.2:101
#: man-pages/man2/create_module.2:65 man-pages/man2/sendmmsg.2:151
#: man-pages/man2/mprotect.2:215 man-pages/man2/_exit.2:80
#: man-pages/man2/add_key.2:215 man-pages/man2/restart_syscall.2:100
#: man-pages/man2/eventfd.2:283 man-pages/man2/posix_fadvise.2:162
#: man-pages/man2/recv.2:498 man-pages/man2/fanotify_mark.2:451
#: man-pages/man2/init_module.2:259 man-pages/man2/gethostname.2:132
#: man-pages/man2/userfaultfd.2:450 man-pages/man2/perfmonctl.2:199
#: man-pages/man2/stat.2:461 man-pages/man2/select.2:369
#: man-pages/man2/link.2:351 man-pages/man2/listen.2:118
#: man-pages/man2/lseek.2:223 man-pages/man2/sysfs.2:101
#: man-pages/man2/dup.2:209 man-pages/man2/tkill.2:129
#: man-pages/man2/getgid.2:44 man-pages/man2/getunwind.2:98
#: man-pages/man2/accept.2:290 man-pages/man2/readahead.2:88
#: man-pages/man2/nfsservctl.2:64 man-pages/man2/bpf.2:1118
#: man-pages/man2/semctl.2:480 man-pages/man2/time.2:64
#: man-pages/man2/getgroups.2:157 man-pages/man2/readlink.2:222
#: man-pages/man2/getpagesize.2:68 man-pages/man2/s390_runtime_instr.2:81
#: man-pages/man2/wait.2:451 man-pages/man2/fcntl.2:1814
#: man-pages/man2/setns.2:242 man-pages/man2/mmap.2:658
#: man-pages/man2/getsockopt.2:174 man-pages/man2/ptrace.2:2363
#: man-pages/man2/inotify_init.2:106 man-pages/man2/vhangup.2:71
#: man-pages/man2/getpriority.2:176 man-pages/man2/sysctl.2:99
#: man-pages/man2/mkdir.2:213 man-pages/man2/getsid.2:85
#: man-pages/man2/open_by_handle_at.2:383 man-pages/man2/epoll_ctl.2:375
#: man-pages/man2/wait4.2:148 man-pages/man2/pciconfig_read.2:112
#: man-pages/man2/statfs.2:280 man-pages/man2/sync.2:98
#: man-pages/man2/get_mempolicy.2:239 man-pages/man2/adjtimex.2:505
#: man-pages/man2/migrate_pages.2:140 man-pages/man2/execve.2:542
#: man-pages/man2/fsync.2:152 man-pages/man2/sched_setaffinity.2:165
#: man-pages/man2/reboot.2:240 man-pages/man2/read.2:182
#: man-pages/man2/sigaltstack.2:226 man-pages/man2/uname.2:73
#: man-pages/man2/sigsuspend.2:85 man-pages/man2/mlock.2:273
#: man-pages/man2/futex.2:1698 man-pages/man2/semop.2:386
#: man-pages/man2/vfork.2:162 man-pages/man2/clock_getres.2:255
#: man-pages/man2/getrandom.2:176 man-pages/man2/timer_create.2:221
#: man-pages/man2/exit_group.2:43 man-pages/man2/times.2:116
#: man-pages/man2/setgid.2:74 man-pages/man2/ioperm.2:99
#: man-pages/man2/vm86.2:73 man-pages/man2/setpgid.2:251
#: man-pages/man2/shmop.2:228 man-pages/man2/umount.2:176
#: man-pages/man2/s390_sthyi.2:123 man-pages/man2/bdflush.2:117
#: man-pages/man2/pause.2:57 man-pages/man2/process_vm_readv.2:286
#: man-pages/man2/pread.2:123 man-pages/man2/sigpending.2:64
#: man-pages/man2/close.2:100 man-pages/man2/sched_rr_get_interval.2:94
#, no-wrap
msgid "CONFORMING TO"
msgstr ""

#. type: Plain text
#: man-pages/man2/setresuid.2:121 man-pages/man2/getresuid.2:70
msgid "These calls are nonstandard; they also appear on HP-UX and some of the BSDs."
msgstr ""

#. type: SH
#: man-pages/man2/setresuid.2:121 man-pages/man2/signalfd.2:352
#: man-pages/man2/splice.2:203 man-pages/man2/bind.2:244
#: man-pages/man2/msgop.2:486 man-pages/man2/execveat.2:169
#: man-pages/man2/socketpair.2:112 man-pages/man2/seccomp.2:774
#: man-pages/man2/getrlimit.2:595 man-pages/man2/memfd_create.2:207
#: man-pages/man2/io_setup.2:66 man-pages/man2/request_key.2:440
#: man-pages/man2/set_mempolicy.2:306 man-pages/man2/kill.2:122
#: man-pages/man2/readdir.2:118 man-pages/man2/acct.2:145
#: man-pages/man2/epoll_create.2:124 man-pages/man2/io_submit.2:242
#: man-pages/man2/setsid.2:75 man-pages/man2/io_cancel.2:64
#: man-pages/man2/mknod.2:257 man-pages/man2/getdents.2:205
#: man-pages/man2/umask.2:117 man-pages/man2/sigaction.2:858
#: man-pages/man2/getsockname.2:103 man-pages/man2/getpid.2:57
#: man-pages/man2/poll.2:399 man-pages/man2/signal.2:112
#: man-pages/man2/rename.2:532 man-pages/man2/shutdown.2:96
#: man-pages/man2/io_getevents.2:90 man-pages/man2/truncate.2:222
#: man-pages/man2/set_tid_address.2:102 man-pages/man2/swapon.2:171
#: man-pages/man2/open.2:1259 man-pages/man2/msgget.2:193
#: man-pages/man2/socket.2:469 man-pages/man2/select_tut.2:502
#: man-pages/man2/chroot.2:165 man-pages/man2/shmget.2:288
#: man-pages/man2/io_destroy.2:53 man-pages/man2/ioctl_fideduperange.2:205
#: man-pages/man2/pivot_root.2:168 man-pages/man2/setfsuid.2:85
#: man-pages/man2/send.2:437 man-pages/man2/msgctl.2:346
#: man-pages/man2/sigreturn.2:76 man-pages/man2/setuid.2:125
#: man-pages/man2/spu_create.2:254 man-pages/man2/membarrier.2:256
#: man-pages/man2/s390_guarded_storage.2:143 man-pages/man2/delete_module.2:175
#: man-pages/man2/getrusage.2:226 man-pages/man2/seteuid.2:105
#: man-pages/man2/set_thread_area.2:174 man-pages/man2/semget.2:223
#: man-pages/man2/pipe.2:196 man-pages/man2/setreuid.2:157
#: man-pages/man2/unshare.2:414 man-pages/man2/setfsgid.2:74
#: man-pages/man2/utime.2:174 man-pages/man2/clock_nanosleep.2:190
#: man-pages/man2/copy_file_range.2:209 man-pages/man2/sched_yield.2:54
#: man-pages/man2/access.2:282 man-pages/man2/intro.2:98
#: man-pages/man2/uselib.2:83 man-pages/man2/kexec_load.2:337
#: man-pages/man2/arch_prctl.2:105 man-pages/man2/mount.2:816
#: man-pages/man2/ioctl.2:134 man-pages/man2/tee.2:127
#: man-pages/man2/chmod.2:356 man-pages/man2/move_pages.2:216
#: man-pages/man2/chdir.2:133 man-pages/man2/readv.2:345
#: man-pages/man2/mremap.2:222 man-pages/man2/llseek.2:87
#: man-pages/man2/remap_file_pages.2:171 man-pages/man2/rt_sigqueueinfo.2:190
#: man-pages/man2/mmap2.2:79 man-pages/man2/query_module.2:175
#: man-pages/man2/unlink.2:286 man-pages/man2/syscalls.2:895
#: man-pages/man2/syslog.2:378 man-pages/man2/symlink.2:241
#: man-pages/man2/gettid.2:65 man-pages/man2/socketcall.2:153
#: man-pages/man2/perf_event_open.2:3310 man-pages/man2/alloc_hugepages.2:134
#: man-pages/man2/msync.2:123 man-pages/man2/ioprio_set.2:201
#: man-pages/man2/getdomainname.2:122 man-pages/man2/nanosleep.2:134
#: man-pages/man2/keyctl.2:1954 man-pages/man2/sigwaitinfo.2:136
#: man-pages/man2/clone.2:861 man-pages/man2/clone.2:1268
#: man-pages/man2/ioctl_ficlonerange.2:139 man-pages/man2/iopl.2:92
#: man-pages/man2/_syscall.2:89 man-pages/man2/alarm.2:61
#: man-pages/man2/sysinfo.2:117 man-pages/man2/kcmp.2:305
#: man-pages/man2/sync_file_range.2:180 man-pages/man2/vmsplice.2:169
#: man-pages/man2/write.2:252 man-pages/man2/brk.2:131
#: man-pages/man2/mbind.2:427 man-pages/man2/pkey_alloc.2:115
#: man-pages/man2/ioctl_iflags.2:195 man-pages/man2/utimensat.2:434
#: man-pages/man2/mq_getsetattr.2:52 man-pages/man2/nice.2:99
#: man-pages/man2/sched_setscheduler.2:171 man-pages/man2/chown.2:337
#: man-pages/man2/madvise.2:552 man-pages/man2/sched_setattr.2:391
#: man-pages/man2/getresuid.2:70 man-pages/man2/flock.2:148
#: man-pages/man2/ipc.2:49 man-pages/man2/getcpu.2:77
#: man-pages/man2/capget.2:224 man-pages/man2/quotactl.2:766
#: man-pages/man2/modify_ldt.2:172 man-pages/man2/sgetmask.2:75
#: man-pages/man2/ustat.2:98 man-pages/man2/gettimeofday.2:195
#: man-pages/man2/sendfile.2:182 man-pages/man2/getuid.2:47
#: man-pages/man2/get_kernel_syms.2:70 man-pages/man2/connect.2:262
#: man-pages/man2/s390_pci_mmio_write.2:102 man-pages/man2/spu_run.2:196
#: man-pages/man2/subpage_prot.2:98 man-pages/man2/lookup_dcookie.2:81
#: man-pages/man2/shmctl.2:398 man-pages/man2/epoll_wait.2:209
#: man-pages/man2/setup.2:65 man-pages/man2/sigprocmask.2:130
#: man-pages/man2/timer_getoverrun.2:99 man-pages/man2/futimesat.2:119
#: man-pages/man2/getitimer.2:169 man-pages/man2/fork.2:281
#: man-pages/man2/getpeername.2:105 man-pages/man2/create_module.2:68
#: man-pages/man2/sendmmsg.2:154 man-pages/man2/mprotect.2:228
#: man-pages/man2/_exit.2:85 man-pages/man2/add_key.2:217
#: man-pages/man2/restart_syscall.2:102 man-pages/man2/eventfd.2:288
#: man-pages/man2/posix_fadvise.2:171 man-pages/man2/recv.2:508
#: man-pages/man2/fanotify_mark.2:453 man-pages/man2/init_module.2:264
#: man-pages/man2/gethostname.2:138 man-pages/man2/userfaultfd.2:454
#: man-pages/man2/perfmonctl.2:202 man-pages/man2/stat.2:500
#: man-pages/man2/select.2:384 man-pages/man2/get_robust_list.2:140
#: man-pages/man2/link.2:360 man-pages/man2/listen.2:122
#: man-pages/man2/lseek.2:233 man-pages/man2/sysfs.2:103
#: man-pages/man2/dup.2:219 man-pages/man2/tkill.2:135
#: man-pages/man2/getgid.2:46 man-pages/man2/getunwind.2:101
#: man-pages/man2/accept.2:320 man-pages/man2/readahead.2:93
#: man-pages/man2/bpf.2:1122 man-pages/man2/semctl.2:495
#: man-pages/man2/time.2:69 man-pages/man2/getgroups.2:166
#: man-pages/man2/readlink.2:231 man-pages/man2/ioctl_console.2:826
#: man-pages/man2/getpagesize.2:75 man-pages/man2/s390_runtime_instr.2:84
#: man-pages/man2/wait.2:453 man-pages/man2/fcntl.2:1879
#: man-pages/man2/syscall.2:80 man-pages/man2/setns.2:246
#: man-pages/man2/mmap.2:676 man-pages/man2/getsockopt.2:181
#: man-pages/man2/ptrace.2:2365 man-pages/man2/getpriority.2:179
#: man-pages/man2/sysctl.2:113 man-pages/man2/mkdir.2:220
#: man-pages/man2/getsid.2:87 man-pages/man2/open_by_handle_at.2:390
#: man-pages/man2/epoll_ctl.2:379 man-pages/man2/wait4.2:157
#: man-pages/man2/statfs.2:286 man-pages/man2/sync.2:104
#: man-pages/man2/get_mempolicy.2:241 man-pages/man2/adjtimex.2:514
#: man-pages/man2/migrate_pages.2:142 man-pages/man2/execve.2:550
#: man-pages/man2/fsync.2:167 man-pages/man2/sched_setaffinity.2:167
#: man-pages/man2/read.2:184 man-pages/man2/sigaltstack.2:232
#: man-pages/man2/uname.2:82 man-pages/man2/sigsuspend.2:87
#: man-pages/man2/mlock.2:303 man-pages/man2/futex.2:1700
#: man-pages/man2/semop.2:389 man-pages/man2/vfork.2:177
#: man-pages/man2/clock_getres.2:272 man-pages/man2/getrandom.2:178
#: man-pages/man2/timer_create.2:223 man-pages/man2/exit_group.2:45
#: man-pages/man2/times.2:118 man-pages/man2/setgid.2:76
#: man-pages/man2/ioperm.2:103 man-pages/man2/setpgid.2:273
#: man-pages/man2/shmop.2:243 man-pages/man2/umount.2:179
#: man-pages/man2/s390_sthyi.2:125 man-pages/man2/process_vm_readv.2:288
#: man-pages/man2/pread.2:125 man-pages/man2/sigpending.2:66
#: man-pages/man2/unimplemented.2:40 man-pages/man2/close.2:103
#: man-pages/man2/sched_rr_get_interval.2:96
#, no-wrap
msgid "NOTES"
msgstr ""

#. type: Plain text
#: man-pages/man2/setresuid.2:125
msgid ""
"Under HP-UX and FreeBSD, the prototype is found in I<E<lt>unistd.hE<gt>>.  "
"Under Linux, the prototype is provided by glibc since version 2.3.2."
msgstr ""

#. type: Plain text
#: man-pages/man2/setresuid.2:142
msgid ""
"The original Linux B<setresuid>()  and B<setresgid>()  system calls "
"supported only 16-bit user and group IDs.  Subsequently, Linux 2.4 added "
"B<setresuid32>()  and B<setresgid32>(), supporting 32-bit IDs.  The glibc "
"B<setresuid>()  and B<setresgid>()  wrapper functions transparently deal "
"with the variations across kernel versions."
msgstr ""

#. type: SS
#: man-pages/man2/setresuid.2:142 man-pages/man2/signalfd.2:413
#: man-pages/man2/sigaction.2:953 man-pages/man2/getpid.2:75
#: man-pages/man2/poll.2:434 man-pages/man2/open.2:1462
#: man-pages/man2/setfsuid.2:114 man-pages/man2/sigreturn.2:143
#: man-pages/man2/setuid.2:149 man-pages/man2/seteuid.2:136
#: man-pages/man2/setreuid.2:198 man-pages/man2/setfsgid.2:96
#: man-pages/man2/access.2:340 man-pages/man2/chmod.2:357
#: man-pages/man2/readv.2:359 man-pages/man2/sigwaitinfo.2:196
#: man-pages/man2/clone.2:878 man-pages/man2/brk.2:150
#: man-pages/man2/nice.2:109 man-pages/man2/gettimeofday.2:214
#: man-pages/man2/epoll_wait.2:253 man-pages/man2/sigprocmask.2:167
#: man-pages/man2/fork.2:288 man-pages/man2/_exit.2:115
#: man-pages/man2/eventfd.2:328 man-pages/man2/posix_fadvise.2:189
#: man-pages/man2/gethostname.2:148 man-pages/man2/stat.2:537
#: man-pages/man2/select.2:530 man-pages/man2/time.2:120
#: man-pages/man2/getgroups.2:206 man-pages/man2/wait.2:568
#: man-pages/man2/mmap.2:837 man-pages/man2/ptrace.2:2739
#: man-pages/man2/getpriority.2:222 man-pages/man2/wait4.2:169
#: man-pages/man2/sched_setaffinity.2:236 man-pages/man2/uname.2:138
#: man-pages/man2/sigsuspend.2:110 man-pages/man2/clock_getres.2:288
#: man-pages/man2/timer_create.2:276 man-pages/man2/setgid.2:87
#: man-pages/man2/pread.2:134 man-pages/man2/sigpending.2:86
#, no-wrap
msgid "C library/kernel differences"
msgstr ""

#. type: Plain text
#: man-pages/man2/setresuid.2:158
msgid ""
"At the kernel level, user IDs and group IDs are a per-thread attribute.  "
"However, POSIX requires that all threads in a process share the same "
"credentials.  The NPTL threading implementation handles the POSIX "
"requirements by providing wrapper functions for the various system calls "
"that change process UIDs and GIDs.  These wrapper functions (including those "
"for B<setresuid>()  and B<setresgid>())  employ a signal-based technique to "
"ensure that when one thread changes credentials, all of the other threads in "
"the process also change their credentials.  For details, see B<nptl>(7)."
msgstr ""

#. type: SH
#: man-pages/man2/setresuid.2:158 man-pages/man2/fallocate.2:474
#: man-pages/man2/signalfd.2:520 man-pages/man2/splice.2:267
#: man-pages/man2/bind.2:323 man-pages/man2/msgop.2:710
#: man-pages/man2/execveat.2:229 man-pages/man2/socketpair.2:138
#: man-pages/man2/seccomp.2:1112 man-pages/man2/getrlimit.2:835
#: man-pages/man2/memfd_create.2:531 man-pages/man2/io_setup.2:96
#: man-pages/man2/request_key.2:545 man-pages/man2/set_mempolicy.2:314
#: man-pages/man2/statx.2:534 man-pages/man2/rmdir.2:133
#: man-pages/man2/kill.2:170 man-pages/man2/readdir.2:129
#: man-pages/man2/ioctl_userfaultfd.2:685 man-pages/man2/acct.2:151
#: man-pages/man2/epoll_create.2:147 man-pages/man2/io_submit.2:272
#: man-pages/man2/setsid.2:110 man-pages/man2/io_cancel.2:94
#: man-pages/man2/mknod.2:288 man-pages/man2/getdents.2:308
#: man-pages/man2/umask.2:155 man-pages/man2/personality.2:270
#: man-pages/man2/timer_settime.2:212 man-pages/man2/sigaction.2:1034
#: man-pages/man2/getsockname.2:108 man-pages/man2/getpid.2:155
#: man-pages/man2/poll.2:469 man-pages/man2/ioctl_getfsmap.2:372
#: man-pages/man2/signal.2:270 man-pages/man2/rename.2:562
#: man-pages/man2/outb.2:96 man-pages/man2/shutdown.2:116
#: man-pages/man2/recvmmsg.2:287 man-pages/man2/io_getevents.2:125
#: man-pages/man2/truncate.2:274 man-pages/man2/set_tid_address.2:105
#: man-pages/man2/swapon.2:205 man-pages/man2/open.2:1770
#: man-pages/man2/msgget.2:242 man-pages/man2/socket.2:493
#: man-pages/man2/select_tut.2:819 man-pages/man2/chroot.2:181
#: man-pages/man2/shmget.2:414 man-pages/man2/getxattr.2:154
#: man-pages/man2/io_destroy.2:83 man-pages/man2/setxattr.2:170
#: man-pages/man2/removexattr.2:110 man-pages/man2/ioctl_tty.2:574
#: man-pages/man2/ioctl_fideduperange.2:213 man-pages/man2/pivot_root.2:411
#: man-pages/man2/setfsuid.2:140 man-pages/man2/ioctl_ns.2:358
#: man-pages/man2/send.2:466 man-pages/man2/msgctl.2:385
#: man-pages/man2/sigreturn.2:157 man-pages/man2/setuid.2:163
#: man-pages/man2/spu_create.2:270 man-pages/man2/s390_guarded_storage.2:174
#: man-pages/man2/delete_module.2:210 man-pages/man2/prctl.2:1804
#: man-pages/man2/getrusage.2:266 man-pages/man2/inotify_rm_watch.2:71
#: man-pages/man2/seteuid.2:145 man-pages/man2/set_thread_area.2:226
#: man-pages/man2/semget.2:315 man-pages/man2/pipe.2:286
#: man-pages/man2/setreuid.2:214 man-pages/man2/unshare.2:534
#: man-pages/man2/setfsgid.2:122 man-pages/man2/sched_get_priority_max.2:116
#: man-pages/man2/utime.2:184 man-pages/man2/clock_nanosleep.2:254
#: man-pages/man2/copy_file_range.2:296 man-pages/man2/sched_setparam.2:121
#: man-pages/man2/sched_yield.2:90 man-pages/man2/access.2:404
#: man-pages/man2/intro.2:112 man-pages/man2/uselib.2:120
#: man-pages/man2/kexec_load.2:341 man-pages/man2/arch_prctl.2:143
#: man-pages/man2/mount.2:924 man-pages/man2/fanotify_init.2:307
#: man-pages/man2/ioctl.2:142 man-pages/man2/tee.2:214
#: man-pages/man2/chmod.2:380 man-pages/man2/move_pages.2:246
#: man-pages/man2/inotify_add_watch.2:143 man-pages/man2/chdir.2:142
#: man-pages/man2/stime.2:73 man-pages/man2/readv.2:430
#: man-pages/man2/mremap.2:262 man-pages/man2/llseek.2:94
#: man-pages/man2/remap_file_pages.2:184 man-pages/man2/rt_sigqueueinfo.2:200
#: man-pages/man2/mmap2.2:95 man-pages/man2/query_module.2:193
#: man-pages/man2/unlink.2:305 man-pages/man2/syscalls.2:1101
#: man-pages/man2/syslog.2:386 man-pages/man2/symlink.2:263
#: man-pages/man2/gettid.2:81 man-pages/man2/socketcall.2:174
#: man-pages/man2/perf_event_open.2:3448 man-pages/man2/msync.2:150
#: man-pages/man2/ioprio_set.2:363 man-pages/man2/getdomainname.2:136
#: man-pages/man2/nanosleep.2:230 man-pages/man2/keyctl.2:2230
#: man-pages/man2/sigwaitinfo.2:238 man-pages/man2/clone.2:1449
#: man-pages/man2/timer_delete.2:69 man-pages/man2/ioctl_ficlonerange.2:144
#: man-pages/man2/iopl.2:111 man-pages/man2/_syscall.2:183
#: man-pages/man2/alarm.2:86 man-pages/man2/sysinfo.2:122
#: man-pages/man2/ioctl_fat.2:501 man-pages/man2/kcmp.2:428
#: man-pages/man2/sync_file_range.2:219 man-pages/man2/vmsplice.2:188
#: man-pages/man2/listxattr.2:330 man-pages/man2/write.2:337
#: man-pages/man2/brk.2:173 man-pages/man2/mbind.2:481
#: man-pages/man2/pkey_alloc.2:137 man-pages/man2/ioctl_iflags.2:203
#: man-pages/man2/utimensat.2:636 man-pages/man2/mq_getsetattr.2:56
#: man-pages/man2/nice.2:123 man-pages/man2/sched_setscheduler.2:225
#: man-pages/man2/chown.2:497 man-pages/man2/madvise.2:569
#: man-pages/man2/sched_setattr.2:423 man-pages/man2/getresuid.2:86
#: man-pages/man2/flock.2:240 man-pages/man2/ipc.2:57
#: man-pages/man2/getcpu.2:136 man-pages/man2/capget.2:232
#: man-pages/man2/quotactl.2:794 man-pages/man2/modify_ldt.2:207
#: man-pages/man2/sgetmask.2:89 man-pages/man2/ustat.2:118
#: man-pages/man2/gettimeofday.2:279 man-pages/man2/sendfile.2:239
#: man-pages/man2/getuid.2:89 man-pages/man2/get_kernel_syms.2:91
#: man-pages/man2/connect.2:284 man-pages/man2/s390_pci_mmio_write.2:106
#: man-pages/man2/spu_run.2:264 man-pages/man2/timerfd_create.2:638
#: man-pages/man2/subpage_prot.2:128 man-pages/man2/lookup_dcookie.2:90
#: man-pages/man2/mincore.2:169 man-pages/man2/shmctl.2:444
#: man-pages/man2/epoll_wait.2:266 man-pages/man2/sigprocmask.2:222
#: man-pages/man2/timer_getoverrun.2:131 man-pages/man2/futimesat.2:128
#: man-pages/man2/getitimer.2:259 man-pages/man2/fork.2:317
#: man-pages/man2/getpeername.2:137 man-pages/man2/create_module.2:76
#: man-pages/man2/sendmmsg.2:245 man-pages/man2/mprotect.2:372
#: man-pages/man2/_exit.2:122 man-pages/man2/add_key.2:270
#: man-pages/man2/restart_syscall.2:135 man-pages/man2/eventfd.2:443
#: man-pages/man2/posix_fadvise.2:236 man-pages/man2/recv.2:553
#: man-pages/man2/fanotify_mark.2:525 man-pages/man2/init_module.2:354
#: man-pages/man2/gethostname.2:184 man-pages/man2/userfaultfd.2:752
#: man-pages/man2/perfmonctl.2:205 man-pages/man2/stat.2:706
#: man-pages/man2/select.2:712 man-pages/man2/get_robust_list.2:164
#: man-pages/man2/link.2:424 man-pages/man2/listen.2:180
#: man-pages/man2/lseek.2:262 man-pages/man2/ioctl_list.2:1040
#: man-pages/man2/dup.2:275 man-pages/man2/tkill.2:148
#: man-pages/man2/getgid.2:78 man-pages/man2/getunwind.2:109
#: man-pages/man2/accept.2:373 man-pages/man2/readahead.2:107
#: man-pages/man2/bpf.2:1222 man-pages/man2/semctl.2:599
#: man-pages/man2/time.2:125 man-pages/man2/getgroups.2:220
#: man-pages/man2/readlink.2:350 man-pages/man2/ioctl_console.2:848
#: man-pages/man2/getpagesize.2:112 man-pages/man2/s390_runtime_instr.2:94
#: man-pages/man2/wait.2:690 man-pages/man2/fcntl.2:2089
#: man-pages/man2/syscall.2:372 man-pages/man2/setns.2:339
#: man-pages/man2/mmap.2:981 man-pages/man2/getsockopt.2:195
#: man-pages/man2/ptrace.2:2883 man-pages/man2/inotify_init.2:108
#: man-pages/man2/vhangup.2:74 man-pages/man2/getpriority.2:244
#: man-pages/man2/sysctl.2:180 man-pages/man2/mkdir.2:242
#: man-pages/man2/getsid.2:94 man-pages/man2/open_by_handle_at.2:751
#: man-pages/man2/epoll_ctl.2:425 man-pages/man2/wait4.2:175
#: man-pages/man2/pciconfig_read.2:114 man-pages/man2/statfs.2:388
#: man-pages/man2/sync.2:127 man-pages/man2/get_mempolicy.2:244
#: man-pages/man2/adjtimex.2:535 man-pages/man2/migrate_pages.2:172
#: man-pages/man2/execve.2:857 man-pages/man2/fsync.2:189
#: man-pages/man2/sched_setaffinity.2:416 man-pages/man2/reboot.2:244
#: man-pages/man2/read.2:254 man-pages/man2/sigaltstack.2:363
#: man-pages/man2/uname.2:167 man-pages/man2/sigsuspend.2:137
#: man-pages/man2/mlock.2:492 man-pages/man2/futex.2:1887
#: man-pages/man2/semop.2:547 man-pages/man2/vfork.2:331
#: man-pages/man2/clock_getres.2:345 man-pages/man2/getrandom.2:305
#: man-pages/man2/timer_create.2:465 man-pages/man2/exit_group.2:49
#: man-pages/man2/times.2:211 man-pages/man2/setgid.2:101
#: man-pages/man2/ioperm.2:119 man-pages/man2/setpgid.2:333
#: man-pages/man2/shmop.2:295 man-pages/man2/umount.2:223
#: man-pages/man2/s390_sthyi.2:141 man-pages/man2/bdflush.2:121
#: man-pages/man2/pause.2:59 man-pages/man2/process_vm_readv.2:338
#: man-pages/man2/pread.2:167 man-pages/man2/sigpending.2:119
#: man-pages/man2/unimplemented.2:64 man-pages/man2/close.2:244
#: man-pages/man2/sched_rr_get_interval.2:132
#, no-wrap
msgid "SEE ALSO"
msgstr ""

#. type: Plain text
#: man-pages/man2/setresuid.2:167
msgid ""
"B<getresuid>(2), B<getuid>(2), B<setfsgid>(2), B<setfsuid>(2), "
"B<setreuid>(2), B<setuid>(2), B<capabilities>(7), B<credentials>(7), "
"B<user_namespaces>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/fallocate.2:11
#, no-wrap
msgid "FALLOCATE"
msgstr ""

#. type: TH
#: man-pages/man2/fallocate.2:11 man-pages/man2/getrlimit.2:64
#: man-pages/man2/shutdown.2:40 man-pages/man2/open.2:51
#: man-pages/man2/membarrier.2:25 man-pages/man2/readv.2:32
#: man-pages/man2/wait.2:49 man-pages/man2/wait4.2:33
#, no-wrap
msgid "2018-04-30"
msgstr ""

#. type: Plain text
#: man-pages/man2/fallocate.2:14
msgid "fallocate - manipulate file space"
msgstr ""

#. type: Plain text
#: man-pages/man2/fallocate.2:18 man-pages/man2/readahead.2:35
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>             /* See feature_test_macros(7) */\n"
"B<#include E<lt>fcntl.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/fallocate.2:21
#, no-wrap
msgid ""
"B<int fallocate(int >I<fd>B<, int >I<mode>B<, off_t >I<offset>B<, off_t "
">I<len>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/fallocate.2:27
msgid ""
"This is a nonportable, Linux-specific system call.  For the portable, "
"POSIX.1-specified method of ensuring that space is allocated for a file, see "
"B<posix_fallocate>(3)."
msgstr ""

#. type: Plain text
#: man-pages/man2/fallocate.2:37
msgid ""
"B<fallocate>()  allows the caller to directly manipulate the allocated disk "
"space for the file referred to by I<fd> for the byte range starting at "
"I<offset> and continuing for I<len> bytes."
msgstr ""

#. type: Plain text
#: man-pages/man2/fallocate.2:42
msgid ""
"The I<mode> argument determines the operation to be performed on the given "
"range.  Details of the supported operations are given in the subsections "
"below."
msgstr ""

#. type: SS
#: man-pages/man2/fallocate.2:42
#, no-wrap
msgid "Allocating disk space"
msgstr ""

#. type: Plain text
#: man-pages/man2/fallocate.2:65
msgid ""
"The default operation (i.e., I<mode> is zero) of B<fallocate>()  allocates "
"the disk space within the range specified by I<offset> and I<len>.  The file "
"size (as reported by B<stat>(2))  will be changed if I<offset>+I<len> is "
"greater than the file size.  Any subregion within the range specified by "
"I<offset> and I<len> that did not contain data before the call will be "
"initialized to zero.  This default behavior closely resembles the behavior "
"of the B<posix_fallocate>(3)  library function, and is intended as a method "
"of optimally implementing that function."
msgstr ""

#. type: Plain text
#: man-pages/man2/fallocate.2:71
msgid ""
"After a successful call, subsequent writes into the range specified by "
"I<offset> and I<len> are guaranteed not to fail because of lack of disk "
"space."
msgstr ""

#. type: Plain text
#: man-pages/man2/fallocate.2:82
msgid ""
"If the B<FALLOC_FL_KEEP_SIZE> flag is specified in I<mode>, the behavior of "
"the call is similar, but the file size will not be changed even if "
"I<offset>+I<len> is greater than the file size.  Preallocating zeroed blocks "
"beyond the end of the file in this manner is useful for optimizing append "
"workloads."
msgstr ""

#. type: Plain text
#: man-pages/man2/fallocate.2:92
msgid ""
"If the B<FALLOC_FL_UNSHARE> flag is specified in I<mode>, shared file data "
"extents will be made private to the file to guarantee that a subsequent "
"write will not fail due to lack of space.  Typically, this will be done by "
"performing a copy-on-write operation on all shared data in the file.  This "
"flag may not be supported by all filesystems."
msgstr ""

#. type: Plain text
#: man-pages/man2/fallocate.2:96
msgid ""
"Because allocation is done in block size chunks, B<fallocate>()  may "
"allocate a larger range of disk space than was specified."
msgstr ""

#. type: SS
#: man-pages/man2/fallocate.2:96
#, no-wrap
msgid "Deallocating file space"
msgstr ""

#. type: Plain text
#: man-pages/man2/fallocate.2:111
msgid ""
"Specifying the B<FALLOC_FL_PUNCH_HOLE> flag (available since Linux 2.6.38) "
"in I<mode> deallocates space (i.e., creates a hole)  in the byte range "
"starting at I<offset> and continuing for I<len> bytes.  Within the specified "
"range, partial filesystem blocks are zeroed, and whole filesystem blocks are "
"removed from the file.  After a successful call, subsequent reads from this "
"range will return zeros."
msgstr ""

#. type: Plain text
#: man-pages/man2/fallocate.2:122
msgid ""
"The B<FALLOC_FL_PUNCH_HOLE> flag must be ORed with B<FALLOC_FL_KEEP_SIZE> in "
"I<mode>; in other words, even when punching off the end of the file, the "
"file size (as reported by B<stat>(2))  does not change."
msgstr ""

#. type: Plain text
#: man-pages/man2/fallocate.2:127
msgid ""
"Not all filesystems support B<FALLOC_FL_PUNCH_HOLE>; if a filesystem doesn't "
"support the operation, an error is returned.  The operation is supported on "
"at least the following filesystems:"
msgstr ""

#. type: IP
#: man-pages/man2/fallocate.2:127 man-pages/man2/fallocate.2:129
#: man-pages/man2/fallocate.2:132 man-pages/man2/fallocate.2:134
#: man-pages/man2/fallocate.2:233 man-pages/man2/fallocate.2:236
#: man-pages/man2/fallocate.2:239 man-pages/man2/fallocate.2:242
#: man-pages/man2/splice.2:55 man-pages/man2/splice.2:61
#: man-pages/man2/splice.2:70 man-pages/man2/msgop.2:116
#: man-pages/man2/msgop.2:121 man-pages/man2/msgop.2:145
#: man-pages/man2/msgop.2:152 man-pages/man2/msgop.2:219
#: man-pages/man2/msgop.2:224 man-pages/man2/msgop.2:238
#: man-pages/man2/msgop.2:306 man-pages/man2/msgop.2:308
#: man-pages/man2/msgop.2:314 man-pages/man2/seccomp.2:499
#: man-pages/man2/seccomp.2:503 man-pages/man2/seccomp.2:506
#: man-pages/man2/seccomp.2:511 man-pages/man2/seccomp.2:515
#: man-pages/man2/seccomp.2:652 man-pages/man2/seccomp.2:656
#: man-pages/man2/seccomp.2:664 man-pages/man2/seccomp.2:671
#: man-pages/man2/seccomp.2:675 man-pages/man2/seccomp.2:804
#: man-pages/man2/seccomp.2:807 man-pages/man2/seccomp.2:809
#: man-pages/man2/seccomp.2:811 man-pages/man2/seccomp.2:813
#: man-pages/man2/seccomp.2:815 man-pages/man2/seccomp.2:817
#: man-pages/man2/seccomp.2:819 man-pages/man2/seccomp.2:827
#: man-pages/man2/seccomp.2:842 man-pages/man2/seccomp.2:891
#: man-pages/man2/seccomp.2:899 man-pages/man2/seccomp.2:905
#: man-pages/man2/memfd_create.2:290 man-pages/man2/memfd_create.2:300
#: man-pages/man2/memfd_create.2:308 man-pages/man2/request_key.2:233
#: man-pages/man2/request_key.2:236 man-pages/man2/request_key.2:239
#: man-pages/man2/request_key.2:248 man-pages/man2/request_key.2:252
#: man-pages/man2/request_key.2:255 man-pages/man2/request_key.2:306
#: man-pages/man2/request_key.2:313 man-pages/man2/request_key.2:322
#: man-pages/man2/sigaction.2:357 man-pages/man2/sigaction.2:372
#: man-pages/man2/sigaction.2:388 man-pages/man2/sigaction.2:403
#: man-pages/man2/sigaction.2:450 man-pages/man2/sigaction.2:514
#: man-pages/man2/sigaction.2:532 man-pages/man2/sigaction.2:581
#: man-pages/man2/sigaction.2:584 man-pages/man2/sigaction.2:589
#: man-pages/man2/poll.2:134 man-pages/man2/poll.2:136
#: man-pages/man2/poll.2:138 man-pages/man2/poll.2:168
#: man-pages/man2/poll.2:171 man-pages/man2/poll.2:175
#: man-pages/man2/signal.2:68 man-pages/man2/signal.2:73
#: man-pages/man2/signal.2:80 man-pages/man2/signal.2:232
#: man-pages/man2/signal.2:236 man-pages/man2/rename.2:217
#: man-pages/man2/rename.2:220 man-pages/man2/rename.2:222
#: man-pages/man2/rename.2:229 man-pages/man2/open.2:512
#: man-pages/man2/open.2:516 man-pages/man2/open.2:625
#: man-pages/man2/open.2:627 man-pages/man2/open.2:632
#: man-pages/man2/open.2:635 man-pages/man2/open.2:640
#: man-pages/man2/open.2:646 man-pages/man2/open.2:652
#: man-pages/man2/open.2:658 man-pages/man2/open.2:671
#: man-pages/man2/open.2:843 man-pages/man2/open.2:851
#: man-pages/man2/open.2:1595 man-pages/man2/open.2:1598
#: man-pages/man2/delete_module.2:90 man-pages/man2/delete_module.2:92
#: man-pages/man2/delete_module.2:97 man-pages/man2/prctl.2:258
#: man-pages/man2/prctl.2:260 man-pages/man2/prctl.2:263
#: man-pages/man2/prctl.2:268 man-pages/man2/prctl.2:1521
#: man-pages/man2/prctl.2:1526 man-pages/man2/prctl.2:1531
#: man-pages/man2/prctl.2:1541 man-pages/man2/pipe.2:102
#: man-pages/man2/pipe.2:112 man-pages/man2/pipe.2:122
#: man-pages/man2/copy_file_range.2:55 man-pages/man2/copy_file_range.2:62
#: man-pages/man2/intro.2:44 man-pages/man2/intro.2:47
#: man-pages/man2/intro.2:50 man-pages/man2/kexec_load.2:145
#: man-pages/man2/kexec_load.2:156 man-pages/man2/kexec_load.2:163
#: man-pages/man2/mount.2:92 man-pages/man2/mount.2:97
#: man-pages/man2/mount.2:102 man-pages/man2/mount.2:111
#: man-pages/man2/mount.2:116 man-pages/man2/mount.2:291
#: man-pages/man2/mount.2:295 man-pages/man2/mount.2:300
#: man-pages/man2/fanotify_init.2:289 man-pages/man2/fanotify_init.2:297
#: man-pages/man2/chmod.2:102 man-pages/man2/chmod.2:107
#: man-pages/man2/move_pages.2:55 man-pages/man2/move_pages.2:61
#: man-pages/man2/mremap.2:171 man-pages/man2/mremap.2:174
#: man-pages/man2/mremap.2:181 man-pages/man2/mremap.2:184
#: man-pages/man2/mremap.2:189 man-pages/man2/mremap.2:198
#: man-pages/man2/mremap.2:202 man-pages/man2/mremap.2:205
#: man-pages/man2/rt_sigqueueinfo.2:88 man-pages/man2/rt_sigqueueinfo.2:97
#: man-pages/man2/syscalls.2:89 man-pages/man2/syscalls.2:92
#: man-pages/man2/syscalls.2:98 man-pages/man2/syscalls.2:114
#: man-pages/man2/syscalls.2:120 man-pages/man2/syscalls.2:126
#: man-pages/man2/syscalls.2:132 man-pages/man2/syscalls.2:140
#: man-pages/man2/syscalls.2:929 man-pages/man2/syscalls.2:950
#: man-pages/man2/syscalls.2:961 man-pages/man2/syscalls.2:968
#: man-pages/man2/syscalls.2:979 man-pages/man2/syscalls.2:991
#: man-pages/man2/syscalls.2:1014 man-pages/man2/syscalls.2:1022
#: man-pages/man2/syscalls.2:1077 man-pages/man2/syscalls.2:1083
#: man-pages/man2/syscalls.2:1088 man-pages/man2/syscalls.2:1092
#: man-pages/man2/syscalls.2:1097 man-pages/man2/perf_event_open.2:1416
#: man-pages/man2/perf_event_open.2:1434 man-pages/man2/keyctl.2:191
#: man-pages/man2/keyctl.2:200 man-pages/man2/keyctl.2:2034
#: man-pages/man2/keyctl.2:2038 man-pages/man2/keyctl.2:2043
#: man-pages/man2/keyctl.2:2047 man-pages/man2/utimensat.2:243
#: man-pages/man2/utimensat.2:274 man-pages/man2/utimensat.2:379
#: man-pages/man2/utimensat.2:385 man-pages/man2/utimensat.2:498
#: man-pages/man2/utimensat.2:513 man-pages/man2/utimensat.2:615
#: man-pages/man2/chown.2:93 man-pages/man2/chown.2:98
#: man-pages/man2/chown.2:102 man-pages/man2/chown.2:360
#: man-pages/man2/chown.2:365 man-pages/man2/chown.2:371
#: man-pages/man2/epoll_wait.2:62 man-pages/man2/epoll_wait.2:64
#: man-pages/man2/epoll_wait.2:66 man-pages/man2/fork.2:70
#: man-pages/man2/fork.2:75 man-pages/man2/fork.2:77 man-pages/man2/fork.2:81
#: man-pages/man2/fork.2:87 man-pages/man2/fork.2:90 man-pages/man2/fork.2:93
#: man-pages/man2/fork.2:101 man-pages/man2/fork.2:106
#: man-pages/man2/fork.2:118 man-pages/man2/fork.2:125
#: man-pages/man2/fork.2:131 man-pages/man2/fork.2:138
#: man-pages/man2/fork.2:144 man-pages/man2/fork.2:153
#: man-pages/man2/fork.2:158 man-pages/man2/fork.2:166
#: man-pages/man2/fork.2:175 man-pages/man2/fork.2:183
#: man-pages/man2/fork.2:197 man-pages/man2/fork.2:206
#: man-pages/man2/fork.2:228 man-pages/man2/fork.2:235
#: man-pages/man2/fork.2:240 man-pages/man2/fork.2:246
#: man-pages/man2/eventfd.2:103 man-pages/man2/eventfd.2:110
#: man-pages/man2/eventfd.2:117 man-pages/man2/eventfd.2:162
#: man-pages/man2/eventfd.2:172 man-pages/man2/eventfd.2:182
#: man-pages/man2/fanotify_mark.2:303 man-pages/man2/fanotify_mark.2:309
#: man-pages/man2/fanotify_mark.2:317 man-pages/man2/fanotify_mark.2:323
#: man-pages/man2/fanotify_mark.2:334 man-pages/man2/fanotify_mark.2:501
#: man-pages/man2/fanotify_mark.2:511 man-pages/man2/fanotify_mark.2:517
#: man-pages/man2/select.2:181 man-pages/man2/select.2:183
#: man-pages/man2/select.2:185 man-pages/man2/lseek.2:166
#: man-pages/man2/lseek.2:168 man-pages/man2/lseek.2:171
#: man-pages/man2/lseek.2:173 man-pages/man2/lseek.2:175
#: man-pages/man2/lseek.2:178 man-pages/man2/lseek.2:182
#: man-pages/man2/dup.2:106 man-pages/man2/dup.2:112 man-pages/man2/dup.2:129
#: man-pages/man2/dup.2:138 man-pages/man2/bpf.2:233 man-pages/man2/bpf.2:235
#: man-pages/man2/bpf.2:237 man-pages/man2/bpf.2:239 man-pages/man2/bpf.2:590
#: man-pages/man2/bpf.2:594 man-pages/man2/bpf.2:596 man-pages/man2/bpf.2:603
#: man-pages/man2/bpf.2:615 man-pages/man2/bpf.2:628 man-pages/man2/bpf.2:630
#: man-pages/man2/bpf.2:632 man-pages/man2/bpf.2:637 man-pages/man2/bpf.2:656
#: man-pages/man2/bpf.2:660 man-pages/man2/bpf.2:662 man-pages/man2/bpf.2:768
#: man-pages/man2/bpf.2:773 man-pages/man2/bpf.2:777 man-pages/man2/bpf.2:784
#: man-pages/man2/bpf.2:792 man-pages/man2/bpf.2:801 man-pages/man2/bpf.2:1188
#: man-pages/man2/bpf.2:1192 man-pages/man2/bpf.2:1195
#: man-pages/man2/bpf.2:1198 man-pages/man2/bpf.2:1201
#: man-pages/man2/bpf.2:1204 man-pages/man2/bpf.2:1208
#: man-pages/man2/bpf.2:1211 man-pages/man2/bpf.2:1214
#: man-pages/man2/bpf.2:1218 man-pages/man2/fcntl.2:462
#: man-pages/man2/fcntl.2:478 man-pages/man2/ptrace.2:2134
#: man-pages/man2/ptrace.2:2144 man-pages/man2/ptrace.2:2152
#: man-pages/man2/ptrace.2:2158 man-pages/man2/ptrace.2:2294
#: man-pages/man2/ptrace.2:2653 man-pages/man2/ptrace.2:2661
#: man-pages/man2/open_by_handle_at.2:149
#: man-pages/man2/open_by_handle_at.2:157
#: man-pages/man2/open_by_handle_at.2:168
#: man-pages/man2/open_by_handle_at.2:181 man-pages/man2/adjtimex.2:356
#: man-pages/man2/adjtimex.2:363 man-pages/man2/adjtimex.2:367
#: man-pages/man2/adjtimex.2:371 man-pages/man2/adjtimex.2:408
#: man-pages/man2/adjtimex.2:414 man-pages/man2/adjtimex.2:421
#: man-pages/man2/adjtimex.2:426 man-pages/man2/execve.2:109
#: man-pages/man2/execve.2:114 man-pages/man2/execve.2:122
#: man-pages/man2/execve.2:157 man-pages/man2/execve.2:161
#: man-pages/man2/execve.2:164 man-pages/man2/execve.2:167
#: man-pages/man2/execve.2:170 man-pages/man2/execve.2:173
#: man-pages/man2/execve.2:176 man-pages/man2/execve.2:179
#: man-pages/man2/execve.2:182 man-pages/man2/execve.2:185
#: man-pages/man2/execve.2:189 man-pages/man2/execve.2:193
#: man-pages/man2/execve.2:202 man-pages/man2/execve.2:209
#: man-pages/man2/execve.2:214 man-pages/man2/execve.2:221
#: man-pages/man2/execve.2:228 man-pages/man2/execve.2:235
#: man-pages/man2/execve.2:240 man-pages/man2/execve.2:247
#: man-pages/man2/execve.2:251 man-pages/man2/execve.2:254
#: man-pages/man2/execve.2:262 man-pages/man2/execve.2:266
#: man-pages/man2/execve.2:271 man-pages/man2/futex.2:597
#: man-pages/man2/futex.2:604 man-pages/man2/futex.2:610
#: man-pages/man2/futex.2:870 man-pages/man2/futex.2:872
#: man-pages/man2/futex.2:878 man-pages/man2/futex.2:962
#: man-pages/man2/futex.2:973 man-pages/man2/futex.2:1896
#: man-pages/man2/futex.2:1898 man-pages/man2/futex.2:1900
#: man-pages/man2/futex.2:1902 man-pages/man2/futex.2:1904
#: man-pages/man2/vfork.2:196 man-pages/man2/vfork.2:200
#: man-pages/man2/vfork.2:217 man-pages/man2/getrandom.2:202
#: man-pages/man2/getrandom.2:210 man-pages/man2/getrandom.2:301
#: man-pages/man2/timer_create.2:244 man-pages/man2/timer_create.2:247
#: man-pages/man2/timer_create.2:250 man-pages/man2/timer_create.2:254
#: man-pages/man2/timer_create.2:257 man-pages/man2/timer_create.2:280
#: man-pages/man2/timer_create.2:294 man-pages/man2/timer_create.2:301
#: man-pages/man2/shmop.2:62 man-pages/man2/shmop.2:68
#: man-pages/man2/shmop.2:80
#, no-wrap
msgid "*"
msgstr ""

#. type: Plain text
#: man-pages/man2/fallocate.2:129
msgid "XFS (since Linux 2.6.38)"
msgstr ""

#.  commit a4bb6b64e39abc0e41ca077725f2a72c868e7622
#. type: Plain text
#: man-pages/man2/fallocate.2:132
msgid "ext4 (since Linux 3.0)"
msgstr ""

#. type: Plain text
#: man-pages/man2/fallocate.2:134
msgid "Btrfs (since Linux 3.7)"
msgstr ""

#.  commit 83e4fa9c16e4af7122e31be3eca5d57881d236fe
#. type: Plain text
#: man-pages/man2/fallocate.2:138
msgid "B<tmpfs>(5)  (since Linux 3.5)\""
msgstr ""

#. type: SS
#: man-pages/man2/fallocate.2:138
#, no-wrap
msgid "Collapsing file space"
msgstr ""

#.  commit 00f5e61998dd17f5375d9dfc01331f104b83f841
#. type: Plain text
#: man-pages/man2/fallocate.2:158
msgid ""
"Specifying the B<FALLOC_FL_COLLAPSE_RANGE> flag (available since Linux 3.15) "
"in I<mode> removes a byte range from a file, without leaving a hole.  The "
"byte range to be collapsed starts at I<offset> and continues for I<len> "
"bytes.  At the completion of the operation, the contents of the file "
"starting at the location I<offset+len> will be appended at the location "
"I<offset>, and the file will be I<len> bytes smaller."
msgstr ""

#. type: Plain text
#: man-pages/man2/fallocate.2:172
msgid ""
"A filesystem may place limitations on the granularity of the operation, in "
"order to ensure efficient implementation.  Typically, I<offset> and I<len> "
"must be a multiple of the filesystem logical block size, which varies "
"according to the filesystem type and configuration.  If a filesystem has "
"such a requirement, B<fallocate>()  fails with the error B<EINVAL> if this "
"requirement is violated."
msgstr ""

#. type: Plain text
#: man-pages/man2/fallocate.2:181
msgid ""
"If the region specified by I<offset> plus I<len> reaches or passes the end "
"of file, an error is returned; instead, use B<ftruncate>(2)  to truncate a "
"file."
msgstr ""

#. type: Plain text
#: man-pages/man2/fallocate.2:186
msgid ""
"No other flags may be specified in I<mode> in conjunction with "
"B<FALLOC_FL_COLLAPSE_RANGE>."
msgstr ""

#.  commit 9eb79482a97152930b113b51dff530aba9e28c8e
#.  commit e1d8fb88a64c1f8094b9f6c3b6d2d9e6719c970d
#. type: Plain text
#: man-pages/man2/fallocate.2:194
msgid ""
"As at Linux 3.15, B<FALLOC_FL_COLLAPSE_RANGE> is supported by ext4 (only for "
"extent-based files)  and XFS."
msgstr ""

#. type: SS
#: man-pages/man2/fallocate.2:194
#, no-wrap
msgid "Zeroing file space"
msgstr ""

#.  commit 409332b65d3ed8cfa7a8030f1e9d52f372219642
#. type: Plain text
#: man-pages/man2/fallocate.2:210
msgid ""
"Specifying the B<FALLOC_FL_ZERO_RANGE> flag (available since Linux 3.15)  in "
"I<mode> zeros space in the byte range starting at I<offset> and continuing "
"for I<len> bytes.  Within the specified range, blocks are preallocated for "
"the regions that span the holes in the file.  After a successful call, "
"subsequent reads from this range will return zeros."
msgstr ""

#. type: Plain text
#: man-pages/man2/fallocate.2:216
msgid ""
"Zeroing is done within the filesystem preferably by converting the range "
"into unwritten extents.  This approach means that the specified range will "
"not be physically zeroed out on the device (except for partial blocks at the "
"either end of the range), and I/O is (otherwise) required only to update "
"metadata."
msgstr ""

#. type: Plain text
#: man-pages/man2/fallocate.2:228
msgid ""
"If the B<FALLOC_FL_KEEP_SIZE> flag is additionally specified in I<mode>, the "
"behavior of the call is similar, but the file size will not be changed even "
"if I<offset>+I<len> is greater than the file size.  This behavior is the "
"same as when preallocating space with B<FALLOC_FL_KEEP_SIZE> specified."
msgstr ""

#. type: Plain text
#: man-pages/man2/fallocate.2:233
msgid ""
"Not all filesystems support B<FALLOC_FL_ZERO_RANGE>; if a filesystem doesn't "
"support the operation, an error is returned.  The operation is supported on "
"at least the following filesystems:"
msgstr ""

#.  commit 376ba313147b4172f3e8cf620b9fb591f3e8cdfa
#. type: Plain text
#: man-pages/man2/fallocate.2:236
msgid "XFS (since Linux 3.15)"
msgstr ""

#.  commit b8a8684502a0fc852afa0056c6bb2a9273f6fcc0
#. type: Plain text
#: man-pages/man2/fallocate.2:239
msgid "ext4, for extent-based files (since Linux 3.15)"
msgstr ""

#.  commit 30175628bf7f521e9ee31ac98fa6d6fe7441a556
#. type: Plain text
#: man-pages/man2/fallocate.2:242
msgid "SMB3 (since Linux 3.17)"
msgstr ""

#.  commit f27451f229966874a8793995b8e6b74326d125df
#. type: Plain text
#: man-pages/man2/fallocate.2:245
msgid "Btrfs (since Linux 4.16)"
msgstr ""

#. type: SS
#: man-pages/man2/fallocate.2:245
#, no-wrap
msgid "Increasing file space"
msgstr ""

#.  commit dd46c787788d5bf5b974729d43e4c405814a4c7d
#. type: Plain text
#: man-pages/man2/fallocate.2:268
msgid ""
"Specifying the B<FALLOC_FL_INSERT_RANGE> flag (available since Linux 4.1)  "
"in I<mode> increases the file space by inserting a hole within the file size "
"without overwriting any existing data.  The hole will start at I<offset> and "
"continue for I<len> bytes.  When inserting the hole inside file, the "
"contents of the file starting at I<offset> will be shifted upward (i.e., to "
"a higher file offset) by I<len> bytes.  Inserting a hole inside a file "
"increases the file size by I<len> bytes."
msgstr ""

#. type: Plain text
#: man-pages/man2/fallocate.2:282
msgid ""
"This mode has the same limitations as B<FALLOC_FL_COLLAPSE_RANGE> regarding "
"the granularity of the operation.  If the granularity requirements are not "
"met, B<fallocate>()  fails with the error B<EINVAL>.  If the I<offset> is "
"equal to or greater than the end of file, an error is returned.  For such "
"operations (i.e., inserting a hole at the end of file), B<ftruncate>(2)  "
"should be used."
msgstr ""

#. type: Plain text
#: man-pages/man2/fallocate.2:287
msgid ""
"No other flags may be specified in I<mode> in conjunction with "
"B<FALLOC_FL_INSERT_RANGE>."
msgstr ""

#.  commit a904b1ca5751faf5ece8600e18cd3b674afcca1b
#.  commit 331573febb6a224bc50322e3670da326cb7f4cfc
#.  f2fs also has support since Linux 4.2
#.      commit f62185d0e283e9d311e3ac1020f159d95f0aab39
#. type: Plain text
#: man-pages/man2/fallocate.2:297
msgid ""
"B<FALLOC_FL_INSERT_RANGE> requires filesystem support.  Filesystems that "
"support this operation include XFS (since Linux 4.1)  and ext4 (since Linux "
"4.2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/fallocate.2:304
msgid ""
"On success, B<fallocate>()  returns zero.  On error, -1 is returned and "
"I<errno> is set to indicate the error."
msgstr ""

#. type: TP
#: man-pages/man2/fallocate.2:305 man-pages/man2/signalfd.2:306
#: man-pages/man2/splice.2:162 man-pages/man2/bind.2:175
#: man-pages/man2/execveat.2:122 man-pages/man2/statx.2:477
#: man-pages/man2/readdir.2:100 man-pages/man2/io_submit.2:205
#: man-pages/man2/mknod.2:234 man-pages/man2/getdents.2:186
#: man-pages/man2/getsockname.2:73 man-pages/man2/ioctl_getfsmap.2:334
#: man-pages/man2/rename.2:449 man-pages/man2/shutdown.2:75
#: man-pages/man2/truncate.2:187 man-pages/man2/open.2:1201
#: man-pages/man2/ioctl_fideduperange.2:153 man-pages/man2/send.2:358
#: man-pages/man2/prctl.2:1434 man-pages/man2/inotify_rm_watch.2:56
#: man-pages/man2/copy_file_range.2:105 man-pages/man2/copy_file_range.2:108
#: man-pages/man2/copy_file_range.2:114 man-pages/man2/access.2:258
#: man-pages/man2/kexec_load.2:269 man-pages/man2/ioctl.2:95
#: man-pages/man2/chmod.2:304 man-pages/man2/chmod.2:325
#: man-pages/man2/inotify_add_watch.2:88 man-pages/man2/chdir.2:123
#: man-pages/man2/llseek.2:73 man-pages/man2/unlink.2:253
#: man-pages/man2/symlink.2:211 man-pages/man2/perf_event_open.2:3184
#: man-pages/man2/ioctl_ficlonerange.2:92 man-pages/man2/kcmp.2:252
#: man-pages/man2/sync_file_range.2:148 man-pages/man2/vmsplice.2:147
#: man-pages/man2/write.2:155 man-pages/man2/utimensat.2:279
#: man-pages/man2/utimensat.2:284 man-pages/man2/chown.2:279
#: man-pages/man2/chown.2:302 man-pages/man2/madvise.2:455
#: man-pages/man2/flock.2:118 man-pages/man2/sendfile.2:127
#: man-pages/man2/connect.2:178 man-pages/man2/spu_run.2:154
#: man-pages/man2/timerfd_create.2:435 man-pages/man2/epoll_wait.2:172
#: man-pages/man2/futimesat.2:98 man-pages/man2/getpeername.2:74
#: man-pages/man2/posix_fadvise.2:131 man-pages/man2/recv.2:460
#: man-pages/man2/fanotify_mark.2:352 man-pages/man2/init_module.2:226
#: man-pages/man2/stat.2:387 man-pages/man2/stat.2:443
#: man-pages/man2/select.2:338 man-pages/man2/link.2:289
#: man-pages/man2/listen.2:103 man-pages/man2/lseek.2:194
#: man-pages/man2/dup.2:157 man-pages/man2/dup.2:161
#: man-pages/man2/accept.2:216 man-pages/man2/readahead.2:73
#: man-pages/man2/bpf.2:1052 man-pages/man2/readlink.2:208
#: man-pages/man2/ioctl_console.2:811 man-pages/man2/fcntl.2:1656
#: man-pages/man2/fcntl.2:1660 man-pages/man2/setns.2:197
#: man-pages/man2/mmap.2:536 man-pages/man2/getsockopt.2:140
#: man-pages/man2/mkdir.2:199 man-pages/man2/open_by_handle_at.2:348
#: man-pages/man2/epoll_ctl.2:269 man-pages/man2/statfs.2:231
#: man-pages/man2/sync.2:90 man-pages/man2/fsync.2:118
#: man-pages/man2/read.2:122 man-pages/man2/close.2:72
#, no-wrap
msgid "B<EBADF>"
msgstr ""

#. type: Plain text
#: man-pages/man2/fallocate.2:309
msgid "I<fd> is not a valid file descriptor, or is not opened for writing."
msgstr ""

#. type: TP
#: man-pages/man2/fallocate.2:309 man-pages/man2/fallocate.2:313
#: man-pages/man2/truncate.2:128 man-pages/man2/open.2:976
#: man-pages/man2/copy_file_range.2:122 man-pages/man2/copy_file_range.2:126
#: man-pages/man2/copy_file_range.2:131 man-pages/man2/write.2:174
#: man-pages/man2/init_module.2:231 man-pages/man2/semop.2:343
#, no-wrap
msgid "B<EFBIG>"
msgstr ""

#. type: Plain text
#: man-pages/man2/fallocate.2:313
msgid "I<offset>+I<len> exceeds the maximum file size."
msgstr ""

#. type: Plain text
#: man-pages/man2/fallocate.2:319
msgid ""
"I<mode> is B<FALLOC_FL_INSERT_RANGE>, and the current file size+I<len> "
"exceeds the maximum file size."
msgstr ""

#. type: TP
#: man-pages/man2/fallocate.2:319 man-pages/man2/msgop.2:378
#: man-pages/man2/msgop.2:426 man-pages/man2/request_key.2:397
#: man-pages/man2/poll.2:356 man-pages/man2/io_getevents.2:69
#: man-pages/man2/truncate.2:133 man-pages/man2/open.2:980
#: man-pages/man2/send.2:371 man-pages/man2/clock_nanosleep.2:165
#: man-pages/man2/nanosleep.2:114 man-pages/man2/sigwaitinfo.2:124
#: man-pages/man2/write.2:179 man-pages/man2/flock.2:122
#: man-pages/man2/connect.2:217 man-pages/man2/spu_run.2:164
#: man-pages/man2/epoll_wait.2:181 man-pages/man2/recv.2:473
#: man-pages/man2/select.2:344 man-pages/man2/dup.2:178
#: man-pages/man2/accept.2:228 man-pages/man2/wait.2:439
#: man-pages/man2/fcntl.2:1697 man-pages/man2/fcntl.2:1706
#: man-pages/man2/statfs.2:242 man-pages/man2/read.2:130
#: man-pages/man2/sigsuspend.2:81 man-pages/man2/futex.2:1475
#: man-pages/man2/semop.2:352 man-pages/man2/getrandom.2:153
#: man-pages/man2/pause.2:54 man-pages/man2/close.2:76
#, no-wrap
msgid "B<EINTR>"
msgstr ""

#. type: Plain text
#: man-pages/man2/fallocate.2:323
msgid "A signal was caught during execution; see B<signal>(7)."
msgstr ""

#.  FIXME . (raise a kernel bug) Probably the len==0 case should be
#.  a no-op, rather than an error. That would be consistent with
#.  similar APIs for the len==0 case.
#.  See "Re: [PATCH] fallocate.2: add FALLOC_FL_PUNCH_HOLE flag definition"
#.  21 Sep 2012
#.  http://thread.gmane.org/gmane.linux.file-systems/48331/focus=1193526
#. type: Plain text
#: man-pages/man2/fallocate.2:335
msgid "I<offset> was less than 0, or I<len> was less than or equal to 0."
msgstr ""

#. type: Plain text
#: man-pages/man2/fallocate.2:345
msgid ""
"I<mode> is B<FALLOC_FL_COLLAPSE_RANGE> and the range specified by I<offset> "
"plus I<len> reaches or passes the end of the file."
msgstr ""

#. type: Plain text
#: man-pages/man2/fallocate.2:353
msgid ""
"I<mode> is B<FALLOC_FL_INSERT_RANGE> and the range specified by I<offset> "
"reaches or passes the end of the file."
msgstr ""

#. type: Plain text
#: man-pages/man2/fallocate.2:365
msgid ""
"I<mode> is B<FALLOC_FL_COLLAPSE_RANGE> or B<FALLOC_FL_INSERT_RANGE>, but "
"either I<offset> or I<len> is not a multiple of the filesystem block size."
msgstr ""

#. type: Plain text
#: man-pages/man2/fallocate.2:377
msgid ""
"I<mode> contains one of B<FALLOC_FL_COLLAPSE_RANGE> or "
"B<FALLOC_FL_INSERT_RANGE> and also other flags; no other flags are permitted "
"with B<FALLOC_FL_COLLAPSE_RANGE> or B<FALLOC_FL_INSERT_RANGE>."
msgstr ""

#.  There was an inconsistency in 3.15-rc1, that should be resolved so that all
#.  filesystems use this error for this case. (Tytso says ex4 will change.)
#.  http://thread.gmane.org/gmane.comp.file-systems.xfs.general/60485/focus=5521
#.  From: Michael Kerrisk (man-pages <mtk.manpages@...>
#.  Subject: Re: [PATCH v5 10/10] manpage: update FALLOC_FL_COLLAPSE_RANGE flag in fallocate
#.  Newsgroups: gmane.linux.man, gmane.linux.file-systems
#.  Date: 2014-04-17 13:40:05 GMT
#. type: Plain text
#: man-pages/man2/fallocate.2:396
msgid ""
"I<mode> is B<FALLOC_FL_COLLAPSE_RANGE> or B<FALLOC_FL_ZERO_RANGE> or "
"B<FALLOC_FL_INSERT_RANGE>, but the file referred to by I<fd> is not a "
"regular file."
msgstr ""

#. type: TP
#: man-pages/man2/fallocate.2:396 man-pages/man2/acct.2:89
#: man-pages/man2/truncate.2:145 man-pages/man2/chroot.2:135
#: man-pages/man2/copy_file_range.2:155 man-pages/man2/access.2:245
#: man-pages/man2/chmod.2:266 man-pages/man2/chmod.2:309
#: man-pages/man2/chdir.2:91 man-pages/man2/unlink.2:182
#: man-pages/man2/symlink.2:168 man-pages/man2/sync_file_range.2:160
#: man-pages/man2/write.2:194 man-pages/man2/mbind.2:397
#: man-pages/man2/chown.2:283 man-pages/man2/madvise.2:501
#: man-pages/man2/sendfile.2:151 man-pages/man2/link.2:214
#: man-pages/man2/readlink.2:187 man-pages/man2/ptrace.2:2338
#: man-pages/man2/pciconfig_read.2:84 man-pages/man2/statfs.2:246
#: man-pages/man2/execve.2:471 man-pages/man2/fsync.2:122
#: man-pages/man2/read.2:155 man-pages/man2/ioperm.2:89
#: man-pages/man2/close.2:84
#, no-wrap
msgid "B<EIO>"
msgstr ""

#. type: Plain text
#: man-pages/man2/fallocate.2:399
msgid "An I/O error occurred while reading from or writing to a filesystem."
msgstr ""

#. type: TP
#: man-pages/man2/fallocate.2:399 man-pages/man2/signalfd.2:333
#: man-pages/man2/open.2:1069 man-pages/man2/spu_create.2:206
#: man-pages/man2/prctl.2:1676 man-pages/man2/mount.2:763
#: man-pages/man2/move_pages.2:190 man-pages/man2/perf_event_open.2:3236
#: man-pages/man2/s390_pci_mmio_write.2:91 man-pages/man2/timerfd_create.2:424
#: man-pages/man2/eventfd.2:245 man-pages/man2/fanotify_mark.2:375
#: man-pages/man2/mmap.2:581 man-pages/man2/pciconfig_read.2:87
#, no-wrap
msgid "B<ENODEV>"
msgstr ""

#. type: Plain text
#: man-pages/man2/fallocate.2:406
msgid ""
"I<fd> does not refer to a regular file or a directory.  (If I<fd> is a pipe "
"or FIFO, a different error results.)"
msgstr ""

#. type: TP
#: man-pages/man2/fallocate.2:406 man-pages/man2/mknod.2:203
#: man-pages/man2/rename.2:391 man-pages/man2/open.2:1109
#: man-pages/man2/msgget.2:185 man-pages/man2/shmget.2:265
#: man-pages/man2/setxattr.2:132 man-pages/man2/spu_create.2:218
#: man-pages/man2/semget.2:211 man-pages/man2/copy_file_range.2:168
#: man-pages/man2/inotify_add_watch.2:127 man-pages/man2/query_module.2:158
#: man-pages/man2/symlink.2:190 man-pages/man2/perf_event_open.2:3247
#: man-pages/man2/sync_file_range.2:166 man-pages/man2/write.2:222
#: man-pages/man2/pkey_alloc.2:88 man-pages/man2/fanotify_mark.2:400
#: man-pages/man2/link.2:244 man-pages/man2/mkdir.2:173
#: man-pages/man2/mkdir.2:178 man-pages/man2/epoll_ctl.2:351
#: man-pages/man2/fsync.2:136
#, no-wrap
msgid "B<ENOSPC>"
msgstr ""

#. type: Plain text
#: man-pages/man2/fallocate.2:411
msgid ""
"There is not enough space left on the device containing the file referred to "
"by I<fd>."
msgstr ""

#. type: TP
#: man-pages/man2/fallocate.2:411 man-pages/man2/io_setup.2:54
#: man-pages/man2/acct.2:114 man-pages/man2/io_submit.2:221
#: man-pages/man2/io_cancel.2:52 man-pages/man2/io_getevents.2:78
#: man-pages/man2/io_destroy.2:41 man-pages/man2/spu_create.2:223
#: man-pages/man2/membarrier.2:235 man-pages/man2/set_thread_area.2:153
#: man-pages/man2/fanotify_init.2:270 man-pages/man2/query_module.2:163
#: man-pages/man2/syslog.2:353 man-pages/man2/perf_event_open.2:3258
#: man-pages/man2/alloc_hugepages.2:119 man-pages/man2/iopl.2:77
#: man-pages/man2/quotactl.2:726 man-pages/man2/modify_ldt.2:165
#: man-pages/man2/ustat.2:86 man-pages/man2/get_kernel_syms.2:59
#: man-pages/man2/spu_run.2:183 man-pages/man2/fork.2:268
#: man-pages/man2/create_module.2:50 man-pages/man2/fanotify_mark.2:406
#: man-pages/man2/pciconfig_read.2:93 man-pages/man2/statfs.2:268
#: man-pages/man2/futex.2:1622 man-pages/man2/futex.2:1626
#: man-pages/man2/futex.2:1637 man-pages/man2/getrandom.2:167
#: man-pages/man2/vm86.2:64 man-pages/man2/sched_rr_get_interval.2:87
#, no-wrap
msgid "B<ENOSYS>"
msgstr ""

#. type: Plain text
#: man-pages/man2/fallocate.2:415
msgid "This kernel does not implement B<fallocate>()."
msgstr ""

#. type: TP
#: man-pages/man2/fallocate.2:415 man-pages/man2/socketpair.2:99
#: man-pages/man2/seccomp.2:754 man-pages/man2/ioctl_getfsmap.2:353
#: man-pages/man2/open.2:1133 man-pages/man2/ioctl_fideduperange.2:182
#: man-pages/man2/send.2:409 man-pages/man2/s390_guarded_storage.2:133
#: man-pages/man2/prctl.2:1700 man-pages/man2/readv.2:314
#: man-pages/man2/perf_event_open.2:3265 man-pages/man2/keyctl.2:1894
#: man-pages/man2/keyctl.2:1902 man-pages/man2/keyctl.2:1908
#: man-pages/man2/ioctl_ficlonerange.2:114 man-pages/man2/fanotify_mark.2:422
#: man-pages/man2/listen.2:113 man-pages/man2/accept.2:259
#: man-pages/man2/s390_runtime_instr.2:76
#: man-pages/man2/open_by_handle_at.2:332 man-pages/man2/pciconfig_read.2:98
#: man-pages/man2/s390_sthyi.2:116
#, no-wrap
msgid "B<EOPNOTSUPP>"
msgstr ""

#. type: Plain text
#: man-pages/man2/fallocate.2:424
msgid ""
"The filesystem containing the file referred to by I<fd> does not support "
"this operation; or the I<mode> is not supported by the filesystem containing "
"the file referred to by I<fd>."
msgstr ""

#. type: Plain text
#: man-pages/man2/fallocate.2:430
msgid "The file referred to by I<fd> is marked immutable (see B<chattr>(1))."
msgstr ""

#. type: Plain text
#: man-pages/man2/fallocate.2:445
msgid ""
"I<mode> specifies B<FALLOC_FL_PUNCH_HOLE> or B<FALLOC_FL_COLLAPSE_RANGE> or "
"B<FALLOC_FL_INSERT_RANGE> and the file referred to by I<fd> is marked "
"append-only (see B<chattr>(1))."
msgstr ""

#. type: Plain text
#: man-pages/man2/fallocate.2:449 man-pages/man2/truncate.2:174
#: man-pages/man2/open.2:1170 man-pages/man2/write.2:231
#: man-pages/man2/mmap.2:629
msgid "The operation was prevented by a file seal; see B<fcntl>(2)."
msgstr ""

#. type: TP
#: man-pages/man2/fallocate.2:449 man-pages/man2/splice.2:189
#: man-pages/man2/sync_file_range.2:169 man-pages/man2/sendfile.2:164
#: man-pages/man2/posix_fadvise.2:137 man-pages/man2/lseek.2:219
#, no-wrap
msgid "B<ESPIPE>"
msgstr ""

#. type: Plain text
#: man-pages/man2/fallocate.2:453
msgid "I<fd> refers to a pipe or FIFO."
msgstr ""

#. type: TP
#: man-pages/man2/fallocate.2:453 man-pages/man2/truncate.2:177
#: man-pages/man2/open.2:1175 man-pages/man2/open.2:1180
#: man-pages/man2/open.2:1186 man-pages/man2/ioctl_fideduperange.2:190
#: man-pages/man2/access.2:251 man-pages/man2/ioctl_ficlonerange.2:122
#: man-pages/man2/mmap.2:629 man-pages/man2/execve.2:539
#, no-wrap
msgid "B<ETXTBSY>"
msgstr ""

#. type: Plain text
#: man-pages/man2/fallocate.2:463
msgid ""
"I<mode> specifies B<FALLOC_FL_COLLAPSE_RANGE> or B<FALLOC_FL_INSERT_RANGE>, "
"but the file referred to by I<fd> is currently being executed."
msgstr ""

#.  See http://sourceware.org/bugzilla/show_bug.cgi?id=14964
#. type: Plain text
#: man-pages/man2/fallocate.2:471
msgid ""
"B<fallocate>()  is available on Linux since kernel 2.6.23.  Support is "
"provided by glibc since version 2.10.  The B<FALLOC_FL_*> flags are defined "
"in glibc headers only since version 2.18."
msgstr ""

#. type: Plain text
#: man-pages/man2/fallocate.2:474
msgid "B<fallocate>()  is Linux-specific."
msgstr ""

#. type: Plain text
#: man-pages/man2/fallocate.2:478
msgid "B<fallocate>(1), B<ftruncate>(2), B<posix_fadvise>(3), B<posix_fallocate>(3)"
msgstr ""

#. type: TH
#: man-pages/man2/signalfd.2:20
#, no-wrap
msgid "SIGNALFD"
msgstr ""

#. type: TH
#: man-pages/man2/signalfd.2:20 man-pages/man2/statx.2:31
#: man-pages/man2/kill.2:44 man-pages/man2/io_submit.2:8
#: man-pages/man2/sigaction.2:49 man-pages/man2/ioctl_fideduperange.2:23
#: man-pages/man2/copy_file_range.2:25 man-pages/man2/sched_setparam.2:30
#: man-pages/man2/move_pages.2:20 man-pages/man2/inotify_add_watch.2:28
#: man-pages/man2/rt_sigqueueinfo.2:25 man-pages/man2/syscalls.2:31
#: man-pages/man2/perf_event_open.2:27 man-pages/man2/getdomainname.2:29
#: man-pages/man2/kcmp.2:28 man-pages/man2/write.2:39
#: man-pages/man2/gethostname.2:32 man-pages/man2/get_robust_list.2:30
#: man-pages/man2/syscall.2:42 man-pages/man2/setns.2:8
#: man-pages/man2/mmap.2:40 man-pages/man2/ptrace.2:105
#: man-pages/man2/execve.2:37 man-pages/man2/sched_setaffinity.2:34
#: man-pages/man2/uname.2:27 man-pages/man2/close.2:36
#, no-wrap
msgid "2019-10-10"
msgstr ""

#. type: Plain text
#: man-pages/man2/signalfd.2:23
msgid "signalfd - create a file descriptor for accepting signals"
msgstr ""

#. type: Plain text
#: man-pages/man2/signalfd.2:25
msgid "B<#include E<lt>sys/signalfd.hE<gt>>"
msgstr ""

#. type: Plain text
#: man-pages/man2/signalfd.2:27
msgid "B<int signalfd(int >I<fd>B<, const sigset_t *>I<mask>B<, int >I<flags>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/signalfd.2:38
msgid ""
"B<signalfd>()  creates a file descriptor that can be used to accept signals "
"targeted at the caller.  This provides an alternative to the use of a signal "
"handler or B<sigwaitinfo>(2), and has the advantage that the file descriptor "
"may be monitored by B<select>(2), B<poll>(2), and B<epoll>(7)."
msgstr ""

#. type: Plain text
#: man-pages/man2/signalfd.2:58
msgid ""
"The I<mask> argument specifies the set of signals that the caller wishes to "
"accept via the file descriptor.  This argument is a signal set whose "
"contents can be initialized using the macros described in B<sigsetops>(3).  "
"Normally, the set of signals to be received via the file descriptor should "
"be blocked using B<sigprocmask>(2), to prevent the signals being handled "
"according to their default dispositions.  It is not possible to receive "
"B<SIGKILL> or B<SIGSTOP> signals via a signalfd file descriptor; these "
"signals are silently ignored if specified in I<mask>."
msgstr ""

#. type: Plain text
#: man-pages/man2/signalfd.2:72
msgid ""
"If the I<fd> argument is -1, then the call creates a new file descriptor and "
"associates the signal set specified in I<mask> with that file descriptor.  "
"If I<fd> is not -1, then it must specify a valid existing signalfd file "
"descriptor, and I<mask> is used to replace the signal set associated with "
"that file descriptor."
msgstr ""

#. type: Plain text
#: man-pages/man2/signalfd.2:77
msgid ""
"Starting with Linux 2.6.27, the following values may be bitwise ORed in "
"I<flags> to change the behavior of B<signalfd>():"
msgstr ""

#. type: TP
#: man-pages/man2/signalfd.2:77
#, no-wrap
msgid "B<SFD_NONBLOCK>"
msgstr ""

#. type: Plain text
#: man-pages/man2/signalfd.2:87 man-pages/man2/socket.2:275
#: man-pages/man2/timerfd_create.2:129 man-pages/man2/eventfd.2:69
#: man-pages/man2/accept.2:160 man-pages/man2/inotify_init.2:66
msgid ""
"Set the B<O_NONBLOCK> file status flag on the open file description (see "
"B<open>(2))  referred to by the new file descriptor.  Using this flag saves "
"extra calls to B<fcntl>(2)  to achieve the same result."
msgstr ""

#. type: TP
#: man-pages/man2/signalfd.2:87
#, no-wrap
msgid "B<SFD_CLOEXEC>"
msgstr ""

#. type: Plain text
#: man-pages/man2/signalfd.2:97 man-pages/man2/memfd_create.2:86
#: man-pages/man2/epoll_create.2:77 man-pages/man2/socket.2:285
#: man-pages/man2/timerfd_create.2:139 man-pages/man2/eventfd.2:59
#: man-pages/man2/accept.2:170 man-pages/man2/inotify_init.2:76
msgid ""
"Set the close-on-exec (B<FD_CLOEXEC>)  flag on the new file descriptor.  See "
"the description of the B<O_CLOEXEC> flag in B<open>(2)  for reasons why this "
"may be useful."
msgstr ""

#. type: Plain text
#: man-pages/man2/signalfd.2:101 man-pages/man2/eventfd.2:77
msgid ""
"In Linux up to version 2.6.26, the I<flags> argument is unused, and must be "
"specified as zero."
msgstr ""

#. type: Plain text
#: man-pages/man2/signalfd.2:104
msgid ""
"B<signalfd>()  returns a file descriptor that supports the following "
"operations:"
msgstr ""

#. type: TP
#: man-pages/man2/signalfd.2:104 man-pages/man2/syscalls.2:586
#: man-pages/man2/timerfd_create.2:272 man-pages/man2/eventfd.2:80
#, no-wrap
msgid "B<read>(2)"
msgstr ""

#. type: Plain text
#: man-pages/man2/signalfd.2:123
msgid ""
"If one or more of the signals specified in I<mask> is pending for the "
"process, then the buffer supplied to B<read>(2)  is used to return one or "
"more I<signalfd_siginfo> structures (see below) that describe the signals.  "
"The B<read>(2)  returns information for as many signals as are pending and "
"will fit in the supplied buffer.  The buffer must be at least "
"I<sizeof(struct signalfd_siginfo)> bytes.  The return value of the "
"B<read>(2)  is the total number of bytes read."
msgstr ""

#. type: Plain text
#: man-pages/man2/signalfd.2:131
msgid ""
"As a consequence of the B<read>(2), the signals are consumed, so that they "
"are no longer pending for the process (i.e., will not be caught by signal "
"handlers, and cannot be accepted using B<sigwaitinfo>(2))."
msgstr ""

#. type: Plain text
#: man-pages/man2/signalfd.2:142
msgid ""
"If none of the signals in I<mask> is pending for the process, then the "
"B<read>(2)  either blocks until one of the signals in I<mask> is generated "
"for the process, or fails with the error B<EAGAIN> if the file descriptor "
"has been made nonblocking."
msgstr ""

#. type: TP
#: man-pages/man2/signalfd.2:142 man-pages/man2/timerfd_create.2:323
#: man-pages/man2/eventfd.2:152
#, no-wrap
msgid "B<poll>(2), B<select>(2) (and similar)"
msgstr ""

#. type: Plain text
#: man-pages/man2/signalfd.2:155
msgid ""
"The file descriptor is readable (the B<select>(2)  I<readfds> argument; the "
"B<poll>(2)  B<POLLIN> flag)  if one or more of the signals in I<mask> is "
"pending for the process."
msgstr ""

#. type: Plain text
#: man-pages/man2/signalfd.2:162
msgid ""
"The signalfd file descriptor also supports the other file-descriptor "
"multiplexing APIs: B<pselect>(2), B<ppoll>(2), and B<epoll>(7)."
msgstr ""

#. type: TP
#: man-pages/man2/signalfd.2:162 man-pages/man2/syscalls.2:221
#: man-pages/man2/timerfd_create.2:359 man-pages/man2/eventfd.2:209
#, no-wrap
msgid "B<close>(2)"
msgstr ""

#. type: Plain text
#: man-pages/man2/signalfd.2:167
msgid ""
"When the file descriptor is no longer required it should be closed.  When "
"all file descriptors associated with the same signalfd object have been "
"closed, the resources for object are freed by the kernel."
msgstr ""

#. type: SS
#: man-pages/man2/signalfd.2:167
#, no-wrap
msgid "The signalfd_siginfo structure"
msgstr ""

#. type: Plain text
#: man-pages/man2/signalfd.2:173
msgid ""
"The format of the I<signalfd_siginfo> structure(s) returned by B<read>(2)s "
"from a signalfd file descriptor is as follows:"
msgstr ""

#.  ssi_trapno is unused on most arches
#.  ssi_addr_lsb: commit b8aeec34175fc8fe8b0d40efea4846dfc1ba663e
#. type: Plain text
#: man-pages/man2/signalfd.2:202
#, no-wrap
msgid ""
"struct signalfd_siginfo {\n"
"    uint32_t ssi_signo;    /* Signal number */\n"
"    int32_t  ssi_errno;    /* Error number (unused) */\n"
"    int32_t  ssi_code;     /* Signal code */\n"
"    uint32_t ssi_pid;      /* PID of sender */\n"
"    uint32_t ssi_uid;      /* Real UID of sender */\n"
"    int32_t  ssi_fd;       /* File descriptor (SIGIO) */\n"
"    uint32_t ssi_tid;      /* Kernel timer ID (POSIX timers)\n"
"    uint32_t ssi_band;     /* Band event (SIGIO) */\n"
"    uint32_t ssi_overrun;  /* POSIX timer overrun count */\n"
"    uint32_t ssi_trapno;   /* Trap number that caused signal */\n"
"    int32_t  ssi_status;   /* Exit status or signal (SIGCHLD) */\n"
"    int32_t  ssi_int;      /* Integer sent by sigqueue(3) */\n"
"    uint64_t ssi_ptr;      /* Pointer sent by sigqueue(3) */\n"
"    uint64_t ssi_utime;    /* User CPU time consumed (SIGCHLD) */\n"
"    uint64_t ssi_stime;    /* System CPU time consumed\n"
"                              (SIGCHLD) */\n"
"    uint64_t ssi_addr;     /* Address that generated signal\n"
"                              (for hardware-generated signals) */\n"
"    uint16_t ssi_addr_lsb; /* Least significant bit of address\n"
"                              (SIGBUS; since Linux 2.6.37)\n"
"    uint8_t  pad[I<X>];       /* Pad size to 128 bytes (allow for\n"
"                              additional fields in the future) */\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/signalfd.2:225
msgid ""
"Each of the fields in this structure is analogous to the similarly named "
"field in the I<siginfo_t> structure.  The I<siginfo_t> structure is "
"described in B<sigaction>(2).  Not all fields in the returned "
"I<signalfd_siginfo> structure will be valid for a specific signal; the set "
"of valid fields can be determined from the value returned in the I<ssi_code> "
"field.  This field is the analog of the I<siginfo_t> I<si_code> field; see "
"B<sigaction>(2)  for details."
msgstr ""

#. type: SS
#: man-pages/man2/signalfd.2:225 man-pages/man2/timerfd_create.2:366
#, no-wrap
msgid "fork(2) semantics"
msgstr ""

#. type: Plain text
#: man-pages/man2/signalfd.2:233
msgid ""
"After a B<fork>(2), the child inherits a copy of the signalfd file "
"descriptor.  A B<read>(2)  from the file descriptor in the child will return "
"information about signals queued to the child."
msgstr ""

#. type: SS
#: man-pages/man2/signalfd.2:233
#, no-wrap
msgid "Semantics of file descriptor passing"
msgstr ""

#. type: Plain text
#: man-pages/man2/signalfd.2:242
msgid ""
"As with other file descriptors, signalfd file descriptors can be passed to "
"another process via a UNIX domain socket (see B<unix>(7)).  In the receiving "
"process, a B<read>(2)  from the received file descriptor will return "
"information about signals queued to that process."
msgstr ""

#. type: SS
#: man-pages/man2/signalfd.2:242 man-pages/man2/timerfd_create.2:378
#, no-wrap
msgid "execve(2) semantics"
msgstr ""

#. type: Plain text
#: man-pages/man2/signalfd.2:254
msgid ""
"Just like any other file descriptor, a signalfd file descriptor remains open "
"across an B<execve>(2), unless it has been marked for close-on-exec (see "
"B<fcntl>(2)).  Any signals that were available for reading before the "
"B<execve>(2)  remain available to the newly loaded program.  (This is "
"analogous to traditional signal semantics, where a blocked signal that is "
"pending remains pending across an B<execve>(2).)"
msgstr ""

#. type: SS
#: man-pages/man2/signalfd.2:254
#, no-wrap
msgid "Thread semantics"
msgstr ""

#. type: Plain text
#: man-pages/man2/signalfd.2:265
msgid ""
"The semantics of signalfd file descriptors in a multithreaded program mirror "
"the standard semantics for signals.  In other words, when a thread reads "
"from a signalfd file descriptor, it will read the signals that are directed "
"to the thread itself and the signals that are directed to the process (i.e., "
"the entire thread group).  (A thread will not be able to read signals that "
"are directed to other threads in the process.)"
msgstr ""

#. type: SS
#: man-pages/man2/signalfd.2:265
#, no-wrap
msgid "epoll(7) semantics"
msgstr ""

#. type: Plain text
#: man-pages/man2/signalfd.2:291
msgid ""
"If a process adds (via B<epoll_ctl>(2))  a signalfd file descriptor to an "
"B<epoll>(7)  instance, then B<epoll_wait>(2)  returns events only for "
"signals sent to that process.  In particular, if the process then uses "
"B<fork>()  to create a child process, then the child will be able to "
"B<read>(2)  signals that are sent to it using the signalfd file descriptor, "
"but B<epoll_wait>(2)  will B<not> indicate that the signalfd file descriptor "
"is ready.  In this scenario, a possible workaround is that after the "
"B<fork>(2), the child process can close the signalfd file descriptor that it "
"inherited from the parent process and then create another signalfd file "
"descriptor and add it to the epoll instance.  Alternatively, the parent and "
"the child could delay creating their (separate) signalfd file descriptors "
"and adding them to the epoll instance until after the call to B<fork>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/signalfd.2:305
msgid ""
"On success, B<signalfd>()  returns a signalfd file descriptor; this is "
"either a new file descriptor (if I<fd> was -1), or I<fd> if I<fd> was a "
"valid signalfd file descriptor.  On error, -1 is returned and I<errno> is "
"set to indicate the error."
msgstr ""

#. type: Plain text
#: man-pages/man2/signalfd.2:311
msgid "The I<fd> file descriptor is not a valid file descriptor."
msgstr ""

#.  or, the
#.  .I sizemask
#.  argument is not equal to
#.  .IR sizeof(sigset_t) ;
#. type: Plain text
#: man-pages/man2/signalfd.2:319
msgid "I<fd> is not a valid signalfd file descriptor."
msgstr ""

#. type: Plain text
#: man-pages/man2/signalfd.2:326 man-pages/man2/timerfd_create.2:417
msgid "I<flags> is invalid; or, in Linux 2.6.26 or earlier, I<flags> is nonzero."
msgstr ""

#. type: TP
#: man-pages/man2/signalfd.2:326 man-pages/man2/socketpair.2:93
#: man-pages/man2/memfd_create.2:189 man-pages/man2/epoll_create.2:94
#: man-pages/man2/epoll_create.2:102 man-pages/man2/open.2:1055
#: man-pages/man2/socket.2:438 man-pages/man2/spu_create.2:196
#: man-pages/man2/pipe.2:180 man-pages/man2/mount.2:755
#: man-pages/man2/fanotify_init.2:261 man-pages/man2/fanotify_init.2:264
#: man-pages/man2/perf_event_open.2:3230 man-pages/man2/timerfd_create.2:417
#: man-pages/man2/eventfd.2:238 man-pages/man2/userfaultfd.2:432
#: man-pages/man2/dup.2:197 man-pages/man2/accept.2:243
#: man-pages/man2/fcntl.2:1773 man-pages/man2/inotify_init.2:87
#: man-pages/man2/inotify_init.2:90 man-pages/man2/execve.2:493
#, no-wrap
msgid "B<EMFILE>"
msgstr ""

#. type: Plain text
#: man-pages/man2/signalfd.2:329 man-pages/man2/socketpair.2:96
#: man-pages/man2/memfd_create.2:192 man-pages/man2/epoll_create.2:105
#: man-pages/man2/socket.2:441 man-pages/man2/spu_create.2:199
#: man-pages/man2/pipe.2:183 man-pages/man2/fanotify_init.2:267
#: man-pages/man2/timerfd_create.2:420 man-pages/man2/eventfd.2:241
#: man-pages/man2/accept.2:246 man-pages/man2/inotify_init.2:93
#: man-pages/man2/execve.2:496
msgid ""
"The per-process limit on the number of open file descriptors has been "
"reached."
msgstr ""

#. type: TP
#: man-pages/man2/signalfd.2:329 man-pages/man2/socketpair.2:96
#: man-pages/man2/memfd_create.2:192 man-pages/man2/acct.2:105
#: man-pages/man2/epoll_create.2:105 man-pages/man2/swapon.2:147
#: man-pages/man2/open.2:1066 man-pages/man2/socket.2:441
#: man-pages/man2/shmget.2:253 man-pages/man2/spu_create.2:203
#: man-pages/man2/pipe.2:183 man-pages/man2/pipe.2:186
#: man-pages/man2/uselib.2:70 man-pages/man2/timerfd_create.2:420
#: man-pages/man2/eventfd.2:241 man-pages/man2/userfaultfd.2:436
#: man-pages/man2/accept.2:246 man-pages/man2/mmap.2:573
#: man-pages/man2/inotify_init.2:93 man-pages/man2/execve.2:500
#: man-pages/man2/futex.2:1612
#, no-wrap
msgid "B<ENFILE>"
msgstr ""

#. type: Plain text
#: man-pages/man2/signalfd.2:333 man-pages/man2/socketpair.2:99
#: man-pages/man2/memfd_create.2:195 man-pages/man2/acct.2:108
#: man-pages/man2/epoll_create.2:108 man-pages/man2/swapon.2:150
#: man-pages/man2/open.2:1069 man-pages/man2/socket.2:444
#: man-pages/man2/shmget.2:257 man-pages/man2/spu_create.2:206
#: man-pages/man2/pipe.2:186 man-pages/man2/uselib.2:73
#: man-pages/man2/timerfd_create.2:424 man-pages/man2/eventfd.2:245
#: man-pages/man2/userfaultfd.2:440 man-pages/man2/accept.2:249
#: man-pages/man2/mmap.2:581 man-pages/man2/inotify_init.2:96
#: man-pages/man2/execve.2:503
msgid "The system-wide limit on the total number of open files has been reached."
msgstr ""

#.  Note from Davide:
#.  The ENODEV error is basically never going to happen if
#.  the kernel boots correctly. That error happen only if during
#.  the kernel initialization, some error occur in the anonymous
#.  inode source initialization.
#. type: Plain text
#: man-pages/man2/signalfd.2:336 man-pages/man2/timerfd_create.2:427
#: man-pages/man2/eventfd.2:253
msgid "Could not mount (internal) anonymous inode device."
msgstr ""

#. type: TP
#: man-pages/man2/signalfd.2:336 man-pages/man2/splice.2:186
#: man-pages/man2/bind.2:223 man-pages/man2/msgop.2:392
#: man-pages/man2/seccomp.2:741 man-pages/man2/seccomp.2:744
#: man-pages/man2/memfd_create.2:195 man-pages/man2/io_setup.2:51
#: man-pages/man2/request_key.2:425 man-pages/man2/set_mempolicy.2:297
#: man-pages/man2/statx.2:516 man-pages/man2/rmdir.2:85
#: man-pages/man2/acct.2:111 man-pages/man2/epoll_create.2:108
#: man-pages/man2/mknod.2:200 man-pages/man2/poll.2:373
#: man-pages/man2/ioctl_getfsmap.2:350 man-pages/man2/rename.2:388
#: man-pages/man2/swapon.2:155 man-pages/man2/open.2:1099
#: man-pages/man2/open.2:1106 man-pages/man2/msgget.2:181
#: man-pages/man2/chroot.2:149 man-pages/man2/shmget.2:262
#: man-pages/man2/ioctl_fideduperange.2:175 man-pages/man2/send.2:398
#: man-pages/man2/spu_create.2:215 man-pages/man2/s390_guarded_storage.2:127
#: man-pages/man2/semget.2:207 man-pages/man2/unshare.2:342
#: man-pages/man2/copy_file_range.2:165 man-pages/man2/access.2:248
#: man-pages/man2/kexec_load.2:320 man-pages/man2/mount.2:770
#: man-pages/man2/fanotify_init.2:267 man-pages/man2/tee.2:117
#: man-pages/man2/chmod.2:280 man-pages/man2/inotify_add_watch.2:124
#: man-pages/man2/chdir.2:107 man-pages/man2/mremap.2:210
#: man-pages/man2/unlink.2:204 man-pages/man2/symlink.2:187
#: man-pages/man2/msync.2:96 man-pages/man2/keyctl.2:1886
#: man-pages/man2/clone.2:1175 man-pages/man2/sync_file_range.2:163
#: man-pages/man2/vmsplice.2:159 man-pages/man2/mbind.2:408
#: man-pages/man2/chown.2:257 man-pages/man2/madvise.2:507
#: man-pages/man2/madvise.2:512 man-pages/man2/sendfile.2:155
#: man-pages/man2/s390_pci_mmio_write.2:94 man-pages/man2/spu_run.2:179
#: man-pages/man2/timerfd_create.2:427 man-pages/man2/subpage_prot.2:87
#: man-pages/man2/lookup_dcookie.2:61 man-pages/man2/mincore.2:115
#: man-pages/man2/mincore.2:127 man-pages/man2/shmctl.2:353
#: man-pages/man2/fork.2:258 man-pages/man2/fork.2:262
#: man-pages/man2/create_module.2:46 man-pages/man2/mprotect.2:186
#: man-pages/man2/mprotect.2:189 man-pages/man2/mprotect.2:199
#: man-pages/man2/add_key.2:194 man-pages/man2/eventfd.2:253
#: man-pages/man2/recv.2:482 man-pages/man2/fanotify_mark.2:397
#: man-pages/man2/init_module.2:181 man-pages/man2/userfaultfd.2:440
#: man-pages/man2/stat.2:413 man-pages/man2/select.2:360
#: man-pages/man2/link.2:241 man-pages/man2/bpf.2:1105
#: man-pages/man2/getgroups.2:139 man-pages/man2/readlink.2:199
#: man-pages/man2/s390_runtime_instr.2:73 man-pages/man2/setns.2:230
#: man-pages/man2/mmap.2:585 man-pages/man2/mmap.2:588
#: man-pages/man2/mmap.2:596 man-pages/man2/inotify_init.2:96
#: man-pages/man2/mkdir.2:170 man-pages/man2/epoll_ctl.2:346
#: man-pages/man2/statfs.2:265 man-pages/man2/execve.2:515
#: man-pages/man2/sigaltstack.2:203 man-pages/man2/mlock.2:185
#: man-pages/man2/mlock.2:193 man-pages/man2/mlock.2:232
#: man-pages/man2/mlock.2:236 man-pages/man2/futex.2:1616
#: man-pages/man2/semop.2:363 man-pages/man2/timer_create.2:215
#: man-pages/man2/ioperm.2:92 man-pages/man2/shmop.2:211
#: man-pages/man2/umount.2:164 man-pages/man2/s390_sthyi.2:113
#: man-pages/man2/process_vm_readv.2:269
#, no-wrap
msgid "B<ENOMEM>"
msgstr ""

#. type: Plain text
#: man-pages/man2/signalfd.2:339
msgid "There was insufficient memory to create a new signalfd file descriptor."
msgstr ""

#.  signalfd() is in glibc 2.7, but reportedly does not build
#. type: Plain text
#: man-pages/man2/signalfd.2:347
msgid ""
"B<signalfd>()  is available on Linux since kernel 2.6.22.  Working support "
"is provided in glibc since version 2.8.  The B<signalfd4>()  system call "
"(see NOTES) is available on Linux since kernel 2.6.27."
msgstr ""

#. type: Plain text
#: man-pages/man2/signalfd.2:352
msgid "B<signalfd>()  and B<signalfd4>()  are Linux-specific."
msgstr ""

#. type: Plain text
#: man-pages/man2/signalfd.2:366
msgid ""
"A process can create multiple signalfd file descriptors.  This makes it "
"possible to accept different signals on different file descriptors.  (This "
"may be useful if monitoring the file descriptors using B<select>(2), "
"B<poll>(2), or B<epoll>(7): the arrival of different signals will make "
"different file descriptors ready.)  If a signal appears in the I<mask> of "
"more than one of the file descriptors, then occurrences of that signal can "
"be read (once) from any one of the file descriptors."
msgstr ""

#. type: Plain text
#: man-pages/man2/signalfd.2:374
msgid ""
"Attempts to include B<SIGKILL> and B<SIGSTOP> in I<mask> are silently "
"ignored."
msgstr ""

#. type: Plain text
#: man-pages/man2/signalfd.2:383
msgid ""
"The signal mask employed by a signalfd file descriptor can be viewed via the "
"entry for the corresponding file descriptor in the process's "
"I</proc/[pid]/fdinfo> directory.  See B<proc>(5)  for further details."
msgstr ""

#. type: SS
#: man-pages/man2/signalfd.2:383
#, no-wrap
msgid "Limitations"
msgstr ""

#. type: Plain text
#: man-pages/man2/signalfd.2:392
msgid ""
"The signalfd mechanism can't be used to receive signals that are "
"synchronously generated, such as the B<SIGSEGV> signal that results from "
"accessing an invalid memory address or the B<SIGFPE> signal that results "
"from an arithmetic error.  Such signals can be caught only via signal "
"handler."
msgstr ""

#. type: Plain text
#: man-pages/man2/signalfd.2:413
msgid ""
"As described above, in normal usage one blocks the signals that will be "
"accepted via B<signalfd>().  If spawning a child process to execute a helper "
"program (that does not need the signalfd file descriptor), then, after the "
"call to B<fork>(2), you will normally want to unblock those signals before "
"calling B<execve>(2), so that the helper program can see any signals that it "
"expects to see.  Be aware, however, that this won't be possible in the case "
"of a helper program spawned behind the scenes by any library function that "
"the program may call.  In such cases, one must fall back to using a "
"traditional signal handler that writes to a file descriptor monitored by "
"B<select>(2), B<poll>(2), or B<epoll>(7)."
msgstr ""

#. type: Plain text
#: man-pages/man2/signalfd.2:423
msgid ""
"The underlying Linux system call requires an additional argument, I<size_t "
"sizemask>, which specifies the size of the I<mask> argument.  The glibc "
"B<signalfd>()  wrapper function does not include this argument, since it "
"provides the required value for the underlying system call."
msgstr ""

#. type: Plain text
#: man-pages/man2/signalfd.2:439
msgid ""
"There are two underlying Linux system calls: B<signalfd>()  and the more "
"recent B<signalfd4>().  The former system call does not implement a I<flags> "
"argument.  The latter system call implements the I<flags> values described "
"above.  Starting with glibc 2.9, the B<signalfd>()  wrapper function will "
"use B<signalfd4>()  where it is available."
msgstr ""

#. type: SH
#: man-pages/man2/signalfd.2:439 man-pages/man2/bind.2:255
#: man-pages/man2/msgop.2:537 man-pages/man2/execveat.2:210
#: man-pages/man2/getrlimit.2:646 man-pages/man2/rmdir.2:130
#: man-pages/man2/kill.2:160 man-pages/man2/ioctl_userfaultfd.2:673
#: man-pages/man2/sigaction.2:1022 man-pages/man2/poll.2:465
#: man-pages/man2/rename.2:551 man-pages/man2/shutdown.2:105
#: man-pages/man2/recvmmsg.2:173 man-pages/man2/io_getevents.2:120
#: man-pages/man2/truncate.2:266 man-pages/man2/open.2:1737
#: man-pages/man2/msgget.2:236 man-pages/man2/shmget.2:408
#: man-pages/man2/setfsuid.2:123 man-pages/man2/send.2:456
#: man-pages/man2/set_thread_area.2:201 man-pages/man2/semget.2:309
#: man-pages/man2/setfsgid.2:105 man-pages/man2/access.2:371
#: man-pages/man2/fanotify_init.2:287 man-pages/man2/mremap.2:241
#: man-pages/man2/unlink.2:302 man-pages/man2/perf_event_open.2:3320
#: man-pages/man2/ioprio_set.2:354 man-pages/man2/nanosleep.2:196
#: man-pages/man2/clone.2:1304 man-pages/man2/cacheflush.2:89
#: man-pages/man2/listxattr.2:165 man-pages/man2/write.2:298
#: man-pages/man2/utimensat.2:490 man-pages/man2/sched_setscheduler.2:217
#: man-pages/man2/sched_setattr.2:407 man-pages/man2/modify_ldt.2:198
#: man-pages/man2/get_kernel_syms.2:78 man-pages/man2/timerfd_create.2:470
#: man-pages/man2/mincore.2:147 man-pages/man2/epoll_wait.2:241
#: man-pages/man2/timer_getoverrun.2:115 man-pages/man2/getitimer.2:209
#: man-pages/man2/sendmmsg.2:169 man-pages/man2/posix_fadvise.2:231
#: man-pages/man2/fanotify_mark.2:499 man-pages/man2/userfaultfd.2:468
#: man-pages/man2/select.2:586 man-pages/man2/link.2:418
#: man-pages/man2/sysfs.2:110 man-pages/man2/readahead.2:98
#: man-pages/man2/time.2:105 man-pages/man2/wait.2:592
#: man-pages/man2/fcntl.2:1991 man-pages/man2/mmap.2:852
#: man-pages/man2/getsockopt.2:192 man-pages/man2/ptrace.2:2751
#: man-pages/man2/getpriority.2:237 man-pages/man2/sysctl.2:134
#: man-pages/man2/epoll_ctl.2:384 man-pages/man2/statfs.2:379
#: man-pages/man2/sync.2:124 man-pages/man2/read.2:215
#: man-pages/man2/sigaltstack.2:325 man-pages/man2/mlock.2:444
#: man-pages/man2/semop.2:490 man-pages/man2/vfork.2:310
#: man-pages/man2/clock_getres.2:335 man-pages/man2/getrandom.2:298
#: man-pages/man2/times.2:196 man-pages/man2/pread.2:155
#: man-pages/man2/sigpending.2:113
#, no-wrap
msgid "BUGS"
msgstr ""

#.  The fix also was put into 2.6.24.5
#. type: Plain text
#: man-pages/man2/signalfd.2:447
msgid ""
"In kernels before 2.6.25, the I<ssi_ptr> and I<ssi_int> fields are not "
"filled in with the data accompanying a signal sent by B<sigqueue>(3)."
msgstr ""

#. type: SH
#: man-pages/man2/signalfd.2:447 man-pages/man2/splice.2:264
#: man-pages/man2/bind.2:258 man-pages/man2/msgop.2:573
#: man-pages/man2/seccomp.2:912 man-pages/man2/getrlimit.2:779
#: man-pages/man2/memfd_create.2:335 man-pages/man2/request_key.2:447
#: man-pages/man2/ioctl_userfaultfd.2:682 man-pages/man2/getdents.2:219
#: man-pages/man2/timer_settime.2:209 man-pages/man2/sigaction.2:1031
#: man-pages/man2/ioctl_getfsmap.2:366 man-pages/man2/recvmmsg.2:192
#: man-pages/man2/socket.2:488 man-pages/man2/select_tut.2:528
#: man-pages/man2/getxattr.2:151 man-pages/man2/ioctl_tty.2:552
#: man-pages/man2/pivot_root.2:274 man-pages/man2/ioctl_ns.2:189
#: man-pages/man2/send.2:461 man-pages/man2/spu_create.2:265
#: man-pages/man2/membarrier.2:273 man-pages/man2/pipe.2:219
#: man-pages/man2/unshare.2:448 man-pages/man2/copy_file_range.2:229
#: man-pages/man2/tee.2:136 man-pages/man2/readv.2:411
#: man-pages/man2/perf_event_open.2:3389 man-pages/man2/keyctl.2:1964
#: man-pages/man2/clone.2:1352 man-pages/man2/_syscall.2:142
#: man-pages/man2/ioctl_fat.2:246 man-pages/man2/kcmp.2:322
#: man-pages/man2/listxattr.2:174 man-pages/man2/pkey_alloc.2:134
#: man-pages/man2/chown.2:449 man-pages/man2/connect.2:279
#: man-pages/man2/spu_run.2:207 man-pages/man2/timerfd_create.2:476
#: man-pages/man2/timer_getoverrun.2:128 man-pages/man2/fork.2:312
#: man-pages/man2/sendmmsg.2:177 man-pages/man2/mprotect.2:286
#: man-pages/man2/add_key.2:224 man-pages/man2/eventfd.2:360
#: man-pages/man2/recv.2:548 man-pages/man2/userfaultfd.2:478
#: man-pages/man2/stat.2:637 man-pages/man2/select.2:673
#: man-pages/man2/listen.2:177 man-pages/man2/accept.2:370
#: man-pages/man2/readlink.2:275 man-pages/man2/wait.2:607
#: man-pages/man2/syscall.2:355 man-pages/man2/setns.2:252
#: man-pages/man2/mmap.2:896 man-pages/man2/sysctl.2:142
#: man-pages/man2/open_by_handle_at.2:470 man-pages/man2/execve.2:762
#: man-pages/man2/sched_setaffinity.2:306 man-pages/man2/sigaltstack.2:289
#: man-pages/man2/futex.2:1714 man-pages/man2/semop.2:520
#: man-pages/man2/timer_create.2:317 man-pages/man2/process_vm_readv.2:302
#, no-wrap
msgid "EXAMPLE"
msgstr ""

#. type: Plain text
#: man-pages/man2/signalfd.2:457
msgid ""
"The program below accepts the signals B<SIGINT> and B<SIGQUIT> via a "
"signalfd file descriptor.  The program terminates after accepting a "
"B<SIGQUIT> signal.  The following shell session demonstrates the use of the "
"program:"
msgstr ""

#. type: Plain text
#: man-pages/man2/signalfd.2:468
#, no-wrap
msgid ""
"$B< ./signalfd_demo>\n"
"B<^C>                   # Control-C generates SIGINT\n"
"Got SIGINT\n"
"B<^C>\n"
"Got SIGINT\n"
"B<^\\e>                    # Control-\\e generates SIGQUIT\n"
"Got SIGQUIT\n"
"$\n"
msgstr ""

#. type: SS
#: man-pages/man2/signalfd.2:470 man-pages/man2/msgop.2:594
#: man-pages/man2/seccomp.2:1010 man-pages/man2/request_key.2:511
#: man-pages/man2/getdents.2:241 man-pages/man2/recvmmsg.2:225
#: man-pages/man2/pivot_root.2:312 man-pages/man2/ioctl_ns.2:250
#: man-pages/man2/pipe.2:235 man-pages/man2/unshare.2:471
#: man-pages/man2/tee.2:152 man-pages/man2/keyctl.2:2074
#: man-pages/man2/clone.2:1362 man-pages/man2/ioctl_fat.2:433
#: man-pages/man2/kcmp.2:348 man-pages/man2/chown.2:458
#: man-pages/man2/timerfd_create.2:504 man-pages/man2/mprotect.2:305
#: man-pages/man2/add_key.2:238 man-pages/man2/eventfd.2:385
#: man-pages/man2/userfaultfd.2:553 man-pages/man2/wait.2:642
#: man-pages/man2/setns.2:306 man-pages/man2/mmap.2:908
#: man-pages/man2/sched_setaffinity.2:355 man-pages/man2/futex.2:1741
#: man-pages/man2/timer_create.2:348
#, no-wrap
msgid "Program source"
msgstr ""

#. type: Plain text
#: man-pages/man2/signalfd.2:478
#, no-wrap
msgid ""
"#include E<lt>sys/signalfd.hE<gt>\n"
"#include E<lt>signal.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/signalfd.2:481 man-pages/man2/bind.2:283
#: man-pages/man2/spu_run.2:223 man-pages/man2/mprotect.2:318
#: man-pages/man2/eventfd.2:396 man-pages/man2/mmap.2:919
#, no-wrap
msgid ""
"#define handle_error(msg) \\e\n"
"    do { perror(msg); exit(EXIT_FAILURE); } while (0)\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/signalfd.2:489
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    sigset_t mask;\n"
"    int sfd;\n"
"    struct signalfd_siginfo fdsi;\n"
"    ssize_t s;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/signalfd.2:493
#, no-wrap
msgid ""
"    sigemptyset(&mask);\n"
"    sigaddset(&mask, SIGINT);\n"
"    sigaddset(&mask, SIGQUIT);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/signalfd.2:496
#, no-wrap
msgid ""
"    /* Block signals so that they aren\\(aqt handled\n"
"       according to their default dispositions */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/signalfd.2:499
#, no-wrap
msgid ""
"    if (sigprocmask(SIG_BLOCK, &mask, NULL) == -1)\n"
"        handle_error(\"sigprocmask\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/signalfd.2:503
#, no-wrap
msgid ""
"    sfd = signalfd(-1, &mask, 0);\n"
"    if (sfd == -1)\n"
"        handle_error(\"signalfd\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/signalfd.2:508
#, no-wrap
msgid ""
"    for (;;) {\n"
"        s = read(sfd, &fdsi, sizeof(struct signalfd_siginfo));\n"
"        if (s != sizeof(struct signalfd_siginfo))\n"
"            handle_error(\"read\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/signalfd.2:519
#, no-wrap
msgid ""
"        if (fdsi.ssi_signo == SIGINT) {\n"
"            printf(\"Got SIGINT\\en\");\n"
"        } else if (fdsi.ssi_signo == SIGQUIT) {\n"
"            printf(\"Got SIGQUIT\\en\");\n"
"            exit(EXIT_SUCCESS);\n"
"        } else {\n"
"            printf(\"Read unexpected signal\\en\");\n"
"        }\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/signalfd.2:532
msgid ""
"B<eventfd>(2), B<poll>(2), B<read>(2), B<select>(2), B<sigaction>(2), "
"B<sigprocmask>(2), B<sigwaitinfo>(2), B<timerfd_create>(2), B<sigsetops>(3), "
"B<sigwait>(3), B<epoll>(7), B<signal>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/splice.2:26
#, no-wrap
msgid "SPLICE"
msgstr ""

#. type: TH
#: man-pages/man2/splice.2:26 man-pages/man2/setfsuid.2:32
#: man-pages/man2/setfsgid.2:32
#, no-wrap
msgid "2019-05-09"
msgstr ""

#. type: Plain text
#: man-pages/man2/splice.2:29
msgid "splice - splice data to/from a pipe"
msgstr ""

#. type: Plain text
#: man-pages/man2/splice.2:33 man-pages/man2/tee.2:33
#: man-pages/man2/sync_file_range.2:37
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>         /* See feature_test_macros(7) */\n"
"B<#include E<lt>fcntl.hE<gt>>\n"
msgstr ""

#.  Return type was long before glibc 2.7
#. type: Plain text
#: man-pages/man2/splice.2:38
#, no-wrap
msgid ""
"B<ssize_t splice(int >I<fd_in>B<, loff_t *>I<off_in>B<, int >I<fd_out>B<,>\n"
"B<               loff_t *>I<off_out>B<, size_t >I<len>B<, unsigned int "
">I<flags>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/splice.2:50
msgid ""
"B<splice>()  moves data between two file descriptors without copying between "
"kernel address space and user address space.  It transfers up to I<len> "
"bytes of data from the file descriptor I<fd_in> to the file descriptor "
"I<fd_out>, where one of the file descriptors must refer to a pipe."
msgstr ""

#. type: Plain text
#: man-pages/man2/splice.2:55
msgid "The following semantics apply for I<fd_in> and I<off_in>:"
msgstr ""

#. type: Plain text
#: man-pages/man2/splice.2:61
msgid "If I<fd_in> refers to a pipe, then I<off_in> must be NULL."
msgstr ""

#. type: Plain text
#: man-pages/man2/splice.2:70
msgid ""
"If I<fd_in> does not refer to a pipe and I<off_in> is NULL, then bytes are "
"read from I<fd_in> starting from the file offset, and the file offset is "
"adjusted appropriately."
msgstr ""

#. type: Plain text
#: man-pages/man2/splice.2:83
msgid ""
"If I<fd_in> does not refer to a pipe and I<off_in> is not NULL, then "
"I<off_in> must point to a buffer which specifies the starting offset from "
"which bytes will be read from I<fd_in>; in this case, the file offset of "
"I<fd_in> is not changed."
msgstr ""

#. type: Plain text
#: man-pages/man2/splice.2:88
msgid "Analogous statements apply for I<fd_out> and I<off_out>."
msgstr ""

#. type: Plain text
#: man-pages/man2/splice.2:93 man-pages/man2/vmsplice.2:92
msgid ""
"The I<flags> argument is a bit mask that is composed by ORing together zero "
"or more of the following values:"
msgstr ""

#. type: TP
#: man-pages/man2/splice.2:93 man-pages/man2/tee.2:60
#: man-pages/man2/vmsplice.2:92
#, no-wrap
msgid "B<SPLICE_F_MOVE>"
msgstr ""

#. type: Plain text
#: man-pages/man2/splice.2:106
msgid ""
"Attempt to move pages instead of copying.  This is only a hint to the "
"kernel: pages may still be copied if the kernel cannot move the pages from "
"the pipe, or if the pipe buffers don't refer to full pages.  The initial "
"implementation of this flag was buggy: therefore starting in Linux 2.6.21 it "
"is a no-op (but is still permitted in a B<splice>()  call); in the future, a "
"correct implementation may be restored."
msgstr ""

#. type: TP
#: man-pages/man2/splice.2:106 man-pages/man2/tee.2:66
#: man-pages/man2/vmsplice.2:98
#, no-wrap
msgid "B<SPLICE_F_NONBLOCK>"
msgstr ""

#. type: Plain text
#: man-pages/man2/splice.2:115
msgid ""
"Do not block on I/O.  This makes the splice pipe operations nonblocking, but "
"B<splice>()  may nevertheless block because the file descriptors that are "
"spliced to/from may block (unless they have the B<O_NONBLOCK> flag set)."
msgstr ""

#. type: TP
#: man-pages/man2/splice.2:115 man-pages/man2/tee.2:71
#: man-pages/man2/vmsplice.2:105
#, no-wrap
msgid "B<SPLICE_F_MORE>"
msgstr ""

#. type: Plain text
#: man-pages/man2/splice.2:129
msgid ""
"More data will be coming in a subsequent splice.  This is a helpful hint "
"when the I<fd_out> refers to a socket (see also the description of "
"B<MSG_MORE> in B<send>(2), and the description of B<TCP_CORK> in B<tcp>(7))."
msgstr ""

#. type: TP
#: man-pages/man2/splice.2:129 man-pages/man2/tee.2:77
#: man-pages/man2/vmsplice.2:111
#, no-wrap
msgid "B<SPLICE_F_GIFT>"
msgstr ""

#. type: Plain text
#: man-pages/man2/splice.2:135
msgid "Unused for B<splice>(); see B<vmsplice>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/splice.2:140
msgid ""
"Upon successful completion, B<splice>()  returns the number of bytes spliced "
"to or from the pipe."
msgstr ""

#. type: Plain text
#: man-pages/man2/splice.2:147
msgid ""
"A return value of 0 means end of input.  If I<fd_in> refers to a pipe, then "
"this means that there was no data to transfer, and it would not make sense "
"to block because there are no writers connected to the write end of the "
"pipe."
msgstr ""

#. type: Plain text
#: man-pages/man2/splice.2:153
msgid "On error, B<splice>()  returns -1 and I<errno> is set to indicate the error."
msgstr ""

#. type: Plain text
#: man-pages/man2/splice.2:162 man-pages/man2/tee.2:107
msgid ""
"B<SPLICE_F_NONBLOCK> was specified in I<flags> or one of the file "
"descriptors had been marked as nonblocking (B<O_NONBLOCK>)B<,> and the "
"operation would block."
msgstr ""

#. type: Plain text
#: man-pages/man2/splice.2:166
msgid ""
"One or both file descriptors are not valid, or do not have proper read-write "
"mode."
msgstr ""

#. type: Plain text
#: man-pages/man2/splice.2:169
msgid "The target filesystem doesn't support splicing."
msgstr ""

#.  The append-mode error is given since 2.6.27; in earlier kernels,
#.  splice() in append mode was broken
#. type: Plain text
#: man-pages/man2/splice.2:174
msgid "The target file is opened in append mode."
msgstr ""

#. type: Plain text
#: man-pages/man2/splice.2:177
msgid "Neither of the file descriptors refers to a pipe."
msgstr ""

#. type: Plain text
#: man-pages/man2/splice.2:180
msgid "An offset was given for nonseekable device (e.g., a pipe)."
msgstr ""

#. type: Plain text
#: man-pages/man2/splice.2:186
msgid "I<fd_in> and I<fd_out> refer to the same pipe."
msgstr ""

#.  Could not allocate I/O bitmap.
#. type: Plain text
#: man-pages/man2/splice.2:189 man-pages/man2/seccomp.2:744
#: man-pages/man2/acct.2:114 man-pages/man2/copy_file_range.2:168
#: man-pages/man2/tee.2:120 man-pages/man2/sync_file_range.2:166
#: man-pages/man2/vmsplice.2:162 man-pages/man2/subpage_prot.2:90
#: man-pages/man2/init_module.2:184 man-pages/man2/getgroups.2:142
#: man-pages/man2/ioperm.2:96
msgid "Out of memory."
msgstr ""

#. type: Plain text
#: man-pages/man2/splice.2:196
msgid ""
"Either I<off_in> or I<off_out> was not NULL, but the corresponding file "
"descriptor refers to a pipe."
msgstr ""

#. type: Plain text
#: man-pages/man2/splice.2:201
msgid ""
"The B<splice>()  system call first appeared in Linux 2.6.17; library support "
"was added to glibc in version 2.5."
msgstr ""

#. type: Plain text
#: man-pages/man2/splice.2:203 man-pages/man2/set_mempolicy.2:306
#: man-pages/man2/readdir.2:118 man-pages/man2/set_tid_address.2:102
#: man-pages/man2/inotify_rm_watch.2:71 man-pages/man2/fanotify_init.2:287
#: man-pages/man2/tee.2:127 man-pages/man2/move_pages.2:216
#: man-pages/man2/inotify_add_watch.2:143 man-pages/man2/mmap2.2:79
#: man-pages/man2/vmsplice.2:169 man-pages/man2/mbind.2:427
#: man-pages/man2/subpage_prot.2:98 man-pages/man2/restart_syscall.2:102
#: man-pages/man2/fanotify_mark.2:453 man-pages/man2/get_mempolicy.2:241
#: man-pages/man2/migrate_pages.2:142 man-pages/man2/futex.2:1700
#: man-pages/man2/getrandom.2:178
msgid "This system call is Linux-specific."
msgstr ""

#. type: Plain text
#: man-pages/man2/splice.2:213
msgid ""
"The three system calls B<splice>(), B<vmsplice>(2), and B<tee>(2), provide "
"user-space programs with full control over an arbitrary kernel buffer, "
"implemented within the kernel using the same type of buffer that is used for "
"a pipe.  In overview, these system calls perform the following tasks:"
msgstr ""

#. type: TP
#: man-pages/man2/splice.2:213
#, no-wrap
msgid "B<splice>()"
msgstr ""

#. type: Plain text
#: man-pages/man2/splice.2:217
msgid ""
"moves data from the buffer to an arbitrary file descriptor, or vice versa, "
"or from one buffer to another."
msgstr ""

#. type: tbl table
#: man-pages/man2/splice.2:217 man-pages/man2/syscalls.2:780
#, no-wrap
msgid "B<tee>(2)"
msgstr ""

#. type: Plain text
#: man-pages/man2/splice.2:220
msgid "\"copies\" the data from one buffer to another."
msgstr ""

#. type: tbl table
#: man-pages/man2/splice.2:220 man-pages/man2/syscalls.2:829
#, no-wrap
msgid "B<vmsplice>(2)"
msgstr ""

#. type: Plain text
#: man-pages/man2/splice.2:223
msgid "\"copies\" data from user space into the buffer."
msgstr ""

#
#.  Linus: Now, imagine using the above in a media server, for example.
#.  Let's say that a year or two has passed, so that the video drivers
#.  have been updated to be able to do the splice thing, and what can
#.  you do? You can:
#
#.  - splice from the (mpeg or whatever - let's just assume that the video
#.    input is either digital or does the encoding on its own - like they
#.    pretty much all do) video input into a pipe (remember: no copies - the
#.    video input will just DMA directly into memory, and splice will just
#.    set up the pages in the pipe buffer)
#.  - tee that pipe to split it up
#.  - splice one end to a file (ie "save the compressed stream to disk")
#.  - splice the other end to a real-time video decoder window for your
#.    real-time viewing pleasure.
#
#.  Linus: Now, the advantage of splice()/tee() is that you can
#.  do zero-copy movement of data, and unlike sendfile() you can
#.  do it on _arbitrary_ data (and, as shown by "tee()", it's more
#.  than just sending the data to somebody else: you can duplicate
#.  the data and choose to forward it to two or more different
#.  users - for things like logging etc.).
#. type: Plain text
#: man-pages/man2/splice.2:254
msgid ""
"Though we talk of copying, actual copies are generally avoided.  The kernel "
"does this by implementing a pipe buffer as a set of reference-counted "
"pointers to pages of kernel memory.  The kernel creates \"copies\" of pages "
"in a buffer by creating new pointers (for the output buffer) referring to "
"the pages, and increasing the reference counts for the pages: only pointers "
"are copied, not the pages of the buffer."
msgstr ""

#.  commit 7c77f0b3f9208c339a4b40737bb2cb0f0319bb8d
#. type: Plain text
#: man-pages/man2/splice.2:264
msgid ""
"In Linux 2.6.30 and earlier, exactly one of I<fd_in> and I<fd_out> was "
"required to be a pipe.  Since Linux 2.6.31, both arguments may refer to "
"pipes."
msgstr ""

#. type: Plain text
#: man-pages/man2/splice.2:267
msgid "See B<tee>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/splice.2:272
msgid "B<copy_file_range>(2), B<sendfile>(2), B<tee>(2), B<vmsplice>(2), B<pipe>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/bind.2:68
#, no-wrap
msgid "BIND"
msgstr ""

#. type: TH
#: man-pages/man2/bind.2:68 man-pages/man2/socketpair.2:42
#: man-pages/man2/seccomp.2:28 man-pages/man2/memfd_create.2:21
#: man-pages/man2/request_key.2:12 man-pages/man2/readdir.2:30
#: man-pages/man2/ioctl_userfaultfd.2:28 man-pages/man2/getdents.2:31
#: man-pages/man2/getpid.2:25 man-pages/man2/rename.2:33
#: man-pages/man2/recvmmsg.2:31 man-pages/man2/truncate.2:43
#: man-pages/man2/socket.2:43 man-pages/man2/select_tut.2:32
#: man-pages/man2/chroot.2:33 man-pages/man2/getxattr.2:25
#: man-pages/man2/removexattr.2:25 man-pages/man2/ioctl_ns.2:26
#: man-pages/man2/setuid.2:31 man-pages/man2/s390_guarded_storage.2:25
#: man-pages/man2/set_thread_area.2:9 man-pages/man2/pipe.2:36
#: man-pages/man2/unshare.2:20 man-pages/man2/kexec_load.2:27
#: man-pages/man2/tee.2:26 man-pages/man2/mremap.2:30
#: man-pages/man2/gettid.2:26 man-pages/man2/ioprio_set.2:24
#: man-pages/man2/keyctl.2:28 man-pages/man2/_syscall.2:38
#: man-pages/man2/ioctl_fat.2:24 man-pages/man2/vmsplice.2:26
#: man-pages/man2/listxattr.2:26 man-pages/man2/chown.2:38
#: man-pages/man2/madvise.2:35 man-pages/man2/sched_setattr.2:26
#: man-pages/man2/getcpu.2:12 man-pages/man2/capget.2:15
#: man-pages/man2/ustat.2:30 man-pages/man2/gettimeofday.2:40
#: man-pages/man2/getuid.2:26 man-pages/man2/connect.2:67
#: man-pages/man2/spu_run.2:26 man-pages/man2/timerfd_create.2:22
#: man-pages/man2/subpage_prot.2:30 man-pages/man2/epoll_wait.2:22
#: man-pages/man2/sendmmsg.2:28 man-pages/man2/add_key.2:12
#: man-pages/man2/eventfd.2:22 man-pages/man2/posix_fadvise.2:29
#: man-pages/man2/userfaultfd.2:27 man-pages/man2/stat.2:40
#: man-pages/man2/select.2:38 man-pages/man2/lseek.2:47
#: man-pages/man2/getgid.2:25 man-pages/man2/accept.2:41
#: man-pages/man2/readahead.2:28 man-pages/man2/nfsservctl.2:5
#: man-pages/man2/getgroups.2:32 man-pages/man2/readlink.2:44
#: man-pages/man2/s390_runtime_instr.2:25 man-pages/man2/fcntl.2:68
#: man-pages/man2/inotify_init.2:29 man-pages/man2/sysctl.2:30
#: man-pages/man2/open_by_handle_at.2:25 man-pages/man2/epoll_ctl.2:20
#: man-pages/man2/adjtimex.2:29 man-pages/man2/migrate_pages.2:18
#: man-pages/man2/fsync.2:38 man-pages/man2/reboot.2:28
#: man-pages/man2/sigsuspend.2:29 man-pages/man2/futex.2:22
#: man-pages/man2/clock_getres.2:30 man-pages/man2/timer_create.2:26
#: man-pages/man2/setgid.2:30 man-pages/man2/s390_sthyi.2:25
#, no-wrap
msgid "2019-03-06"
msgstr ""

#. type: Plain text
#: man-pages/man2/bind.2:71
msgid "bind - bind a name to a socket"
msgstr ""

#. type: Plain text
#: man-pages/man2/bind.2:75 man-pages/man2/listen.2:52
#: man-pages/man2/accept.2:48 man-pages/man2/getsockopt.2:51
#, no-wrap
msgid ""
"B<#include E<lt>sys/types.hE<gt>>          /* See NOTES */\n"
"B<#include E<lt>sys/socket.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/bind.2:78
#, no-wrap
msgid ""
"B<int bind(int >I<sockfd>B<, const struct sockaddr *>I<addr>B<,>\n"
"B<         socklen_t >I<addrlen>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/bind.2:92
msgid ""
"When a socket is created with B<socket>(2), it exists in a name space "
"(address family) but has no address assigned to it.  B<bind>()  assigns the "
"address specified by I<addr> to the socket referred to by the file "
"descriptor I<sockfd>.  I<addrlen> specifies the size, in bytes, of the "
"address structure pointed to by I<addr>.  Traditionally, this operation is "
"called \\(lqassigning a name to a socket\\(rq."
msgstr ""

#. type: Plain text
#: man-pages/man2/bind.2:99
msgid ""
"It is normally necessary to assign a local address using B<bind>()  before a "
"B<SOCK_STREAM> socket may receive connections (see B<accept>(2))."
msgstr ""

#. type: Plain text
#: man-pages/man2/bind.2:130
msgid ""
"The rules used in name binding vary between address families.  Consult the "
"manual entries in Section 7 for detailed information.  For B<AF_INET>, see "
"B<ip>(7); for B<AF_INET6>, see B<ipv6>(7); for B<AF_UNIX>, see B<unix>(7); "
"for B<AF_APPLETALK>, see B<ddp>(7); for B<AF_PACKET>, see B<packet>(7); for "
"B<AF_X25>, see B<x25>(7); and for B<AF_NETLINK>, see B<netlink>(7)."
msgstr ""

#. type: Plain text
#: man-pages/man2/bind.2:137
msgid ""
"The actual structure passed for the I<addr> argument will depend on the "
"address family.  The I<sockaddr> structure is defined as something like:"
msgstr ""

#. type: Plain text
#: man-pages/man2/bind.2:144
#, no-wrap
msgid ""
"struct sockaddr {\n"
"    sa_family_t sa_family;\n"
"    char        sa_data[14];\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/bind.2:152
msgid ""
"The only purpose of this structure is to cast the structure pointer passed "
"in I<addr> in order to avoid compiler warnings.  See EXAMPLE below."
msgstr ""

#. type: TP
#: man-pages/man2/bind.2:158 man-pages/man2/bind.2:199
#: man-pages/man2/msgop.2:356 man-pages/man2/msgop.2:411
#: man-pages/man2/seccomp.2:696 man-pages/man2/request_key.2:382
#: man-pages/man2/statx.2:470 man-pages/man2/rmdir.2:46
#: man-pages/man2/acct.2:74 man-pages/man2/mknod.2:161
#: man-pages/man2/rename.2:309 man-pages/man2/truncate.2:117
#: man-pages/man2/open.2:951 man-pages/man2/msgget.2:156
#: man-pages/man2/socket.2:423 man-pages/man2/chroot.2:124
#: man-pages/man2/shmget.2:224 man-pages/man2/send.2:323
#: man-pages/man2/msgctl.2:276 man-pages/man2/spu_create.2:173
#: man-pages/man2/prctl.2:1408 man-pages/man2/prctl.2:1424
#: man-pages/man2/semget.2:166 man-pages/man2/utime.2:129
#: man-pages/man2/utime.2:136 man-pages/man2/access.2:204
#: man-pages/man2/uselib.2:62 man-pages/man2/mount.2:625
#: man-pages/man2/mount.2:630 man-pages/man2/mount.2:648
#: man-pages/man2/chmod.2:257 man-pages/man2/move_pages.2:175
#: man-pages/man2/inotify_add_watch.2:85 man-pages/man2/chdir.2:81
#: man-pages/man2/chdir.2:119 man-pages/man2/unlink.2:159
#: man-pages/man2/symlink.2:147 man-pages/man2/perf_event_open.2:3170
#: man-pages/man2/keyctl.2:1664 man-pages/man2/utimensat.2:233
#: man-pages/man2/chown.2:237 man-pages/man2/madvise.2:446
#: man-pages/man2/quotactl.2:683 man-pages/man2/connect.2:135
#: man-pages/man2/shmctl.2:320 man-pages/man2/mprotect.2:149
#: man-pages/man2/add_key.2:151 man-pages/man2/stat.2:380
#: man-pages/man2/link.2:193 man-pages/man2/bpf.2:1035
#: man-pages/man2/semctl.2:408 man-pages/man2/readlink.2:164
#: man-pages/man2/mmap.2:514 man-pages/man2/getpriority.2:161
#: man-pages/man2/mkdir.2:126 man-pages/man2/statfs.2:224
#: man-pages/man2/execve.2:432 man-pages/man2/execve.2:439
#: man-pages/man2/execve.2:442 man-pages/man2/execve.2:445
#: man-pages/man2/futex.2:1404 man-pages/man2/semop.2:320
#: man-pages/man2/setpgid.2:218 man-pages/man2/shmop.2:188
#, no-wrap
msgid "B<EACCES>"
msgstr ""

#.  e.g., privileged port in AF_INET domain
#. type: Plain text
#: man-pages/man2/bind.2:162
msgid "The address is protected, and the user is not the superuser."
msgstr ""

#. type: TP
#: man-pages/man2/bind.2:162 man-pages/man2/bind.2:165
#: man-pages/man2/connect.2:148 man-pages/man2/listen.2:87
#: man-pages/man2/listen.2:90
#, no-wrap
msgid "B<EADDRINUSE>"
msgstr ""

#. type: Plain text
#: man-pages/man2/bind.2:165
msgid "The given address is already in use."
msgstr ""

#. type: Plain text
#: man-pages/man2/bind.2:175
msgid ""
"(Internet domain sockets)  The port number was specified as zero in the "
"socket address structure, but, upon attempting to bind to an ephemeral port, "
"it was determined that all port numbers in the ephemeral port range are "
"currently in use.  See the discussion of "
"I</proc/sys/net/ipv4/ip_local_port_range> B<ip>(7)."
msgstr ""

#. type: Plain text
#: man-pages/man2/bind.2:179 man-pages/man2/shutdown.2:79
msgid "I<sockfd> is not a valid file descriptor."
msgstr ""

#.  This may change in the future: see
#.  .I linux/unix/sock.c for details.
#. type: Plain text
#: man-pages/man2/bind.2:184
msgid "The socket is already bound to an address."
msgstr ""

#. type: Plain text
#: man-pages/man2/bind.2:190
msgid ""
"I<addrlen> is wrong, or I<addr> is not a valid address for this socket's "
"domain."
msgstr ""

#. type: TP
#: man-pages/man2/bind.2:190 man-pages/man2/getsockname.2:92
#: man-pages/man2/shutdown.2:87 man-pages/man2/send.2:404
#: man-pages/man2/connect.2:229 man-pages/man2/getpeername.2:96
#: man-pages/man2/recv.2:493 man-pages/man2/listen.2:108
#: man-pages/man2/accept.2:254 man-pages/man2/getsockopt.2:169
#, no-wrap
msgid "B<ENOTSOCK>"
msgstr ""

#. type: Plain text
#: man-pages/man2/bind.2:195 man-pages/man2/getsockname.2:97
#: man-pages/man2/shutdown.2:92 man-pages/man2/send.2:409
#: man-pages/man2/connect.2:234 man-pages/man2/getpeername.2:101
#: man-pages/man2/recv.2:498 man-pages/man2/listen.2:113
#: man-pages/man2/accept.2:259 man-pages/man2/getsockopt.2:174
msgid "The file descriptor I<sockfd> does not refer to a socket."
msgstr ""

#. type: Plain text
#: man-pages/man2/bind.2:199
msgid "The following errors are specific to UNIX domain (B<AF_UNIX>)  sockets:"
msgstr ""

#. type: Plain text
#: man-pages/man2/bind.2:204 man-pages/man2/chroot.2:131
#: man-pages/man2/chmod.2:262 man-pages/man2/chown.2:242
msgid ""
"Search permission is denied on a component of the path prefix.  (See also "
"B<path_resolution>(7).)"
msgstr ""

#. type: TP
#: man-pages/man2/bind.2:204 man-pages/man2/kexec_load.2:248
#: man-pages/man2/kexec_load.2:260 man-pages/man2/connect.2:151
#, no-wrap
msgid "B<EADDRNOTAVAIL>"
msgstr ""

#. type: Plain text
#: man-pages/man2/bind.2:208
msgid ""
"A nonexistent interface was requested or the requested address was not "
"local."
msgstr ""

#. type: TP
#: man-pages/man2/bind.2:208 man-pages/man2/msgop.2:370
#: man-pages/man2/msgop.2:417 man-pages/man2/socketpair.2:88
#: man-pages/man2/seccomp.2:704 man-pages/man2/getrlimit.2:513
#: man-pages/man2/memfd_create.2:165 man-pages/man2/io_setup.2:43
#: man-pages/man2/request_key.2:389 man-pages/man2/set_mempolicy.2:253
#: man-pages/man2/statx.2:481 man-pages/man2/rmdir.2:64
#: man-pages/man2/readdir.2:104 man-pages/man2/ioctl_userfaultfd.2:240
#: man-pages/man2/ioctl_userfaultfd.2:344
#: man-pages/man2/ioctl_userfaultfd.2:658 man-pages/man2/acct.2:85
#: man-pages/man2/io_submit.2:208 man-pages/man2/io_cancel.2:46
#: man-pages/man2/mknod.2:180 man-pages/man2/getdents.2:190
#: man-pages/man2/timer_settime.2:184 man-pages/man2/sigaction.2:844
#: man-pages/man2/getsockname.2:78 man-pages/man2/poll.2:352
#: man-pages/man2/ioctl_getfsmap.2:341 man-pages/man2/rename.2:348
#: man-pages/man2/io_getevents.2:66 man-pages/man2/truncate.2:123
#: man-pages/man2/open.2:972 man-pages/man2/chroot.2:131
#: man-pages/man2/io_destroy.2:35 man-pages/man2/send.2:368
#: man-pages/man2/msgctl.2:289 man-pages/man2/spu_create.2:181
#: man-pages/man2/s390_guarded_storage.2:114 man-pages/man2/delete_module.2:143
#: man-pages/man2/prctl.2:1456 man-pages/man2/prctl.2:1460
#: man-pages/man2/getrusage.2:194 man-pages/man2/set_thread_area.2:147
#: man-pages/man2/pipe.2:171 man-pages/man2/clock_nanosleep.2:159
#: man-pages/man2/access.2:237 man-pages/man2/arch_prctl.2:87
#: man-pages/man2/mount.2:670 man-pages/man2/ioctl.2:99
#: man-pages/man2/chmod.2:262 man-pages/man2/move_pages.2:180
#: man-pages/man2/inotify_add_watch.2:100 man-pages/man2/chdir.2:87
#: man-pages/man2/stime.2:62 man-pages/man2/mremap.2:157
#: man-pages/man2/llseek.2:77 man-pages/man2/mmap2.2:62
#: man-pages/man2/query_module.2:135 man-pages/man2/unlink.2:178
#: man-pages/man2/symlink.2:165 man-pages/man2/perf_event_open.2:3199
#: man-pages/man2/getdomainname.2:91 man-pages/man2/nanosleep.2:111
#: man-pages/man2/keyctl.2:1697 man-pages/man2/cacheflush.2:60
#: man-pages/man2/sysinfo.2:107 man-pages/man2/kcmp.2:262
#: man-pages/man2/write.2:170 man-pages/man2/mbind.2:338
#: man-pages/man2/utimensat.2:293 man-pages/man2/chown.2:242
#: man-pages/man2/getresuid.2:56 man-pages/man2/getcpu.2:64
#: man-pages/man2/capget.2:184 man-pages/man2/quotactl.2:701
#: man-pages/man2/modify_ldt.2:148 man-pages/man2/ustat.2:78
#: man-pages/man2/gettimeofday.2:149 man-pages/man2/sendfile.2:131
#: man-pages/man2/connect.2:187 man-pages/man2/s390_pci_mmio_write.2:77
#: man-pages/man2/s390_pci_mmio_write.2:82 man-pages/man2/spu_run.2:158
#: man-pages/man2/timerfd_create.2:439 man-pages/man2/subpage_prot.2:72
#: man-pages/man2/lookup_dcookie.2:51 man-pages/man2/mincore.2:107
#: man-pages/man2/shmctl.2:328 man-pages/man2/epoll_wait.2:176
#: man-pages/man2/sigprocmask.2:115 man-pages/man2/getitimer.2:139
#: man-pages/man2/getpeername.2:79 man-pages/man2/create_module.2:39
#: man-pages/man2/add_key.2:158 man-pages/man2/recv.2:469
#: man-pages/man2/init_module.2:166 man-pages/man2/gethostname.2:102
#: man-pages/man2/stat.2:391 man-pages/man2/get_robust_list.2:121
#: man-pages/man2/link.2:211 man-pages/man2/sysfs.2:89
#: man-pages/man2/accept.2:223 man-pages/man2/bpf.2:1056
#: man-pages/man2/semctl.2:428 man-pages/man2/time.2:51
#: man-pages/man2/getgroups.2:119 man-pages/man2/readlink.2:169
#: man-pages/man2/fcntl.2:1693 man-pages/man2/getsockopt.2:145
#: man-pages/man2/ptrace.2:2324 man-pages/man2/sysctl.2:89
#: man-pages/man2/mkdir.2:145 man-pages/man2/open_by_handle_at.2:297
#: man-pages/man2/open_by_handle_at.2:352 man-pages/man2/statfs.2:236
#: man-pages/man2/get_mempolicy.2:184 man-pages/man2/adjtimex.2:450
#: man-pages/man2/migrate_pages.2:97 man-pages/man2/execve.2:459
#: man-pages/man2/sched_setaffinity.2:120 man-pages/man2/reboot.2:226
#: man-pages/man2/read.2:126 man-pages/man2/sigaltstack.2:195
#: man-pages/man2/uname.2:69 man-pages/man2/sigsuspend.2:77
#: man-pages/man2/futex.2:1467 man-pages/man2/semop.2:336
#: man-pages/man2/clock_getres.2:202 man-pages/man2/getrandom.2:148
#: man-pages/man2/times.2:112 man-pages/man2/vm86.2:60
#: man-pages/man2/umount.2:135 man-pages/man2/s390_sthyi.2:101
#: man-pages/man2/bdflush.2:102 man-pages/man2/process_vm_readv.2:237
#: man-pages/man2/process_vm_readv.2:242 man-pages/man2/sigpending.2:60
#: man-pages/man2/sched_rr_get_interval.2:81
#, no-wrap
msgid "B<EFAULT>"
msgstr ""

#. type: Plain text
#: man-pages/man2/bind.2:212
msgid "I<addr> points outside the user's accessible address space."
msgstr ""

#. type: TP
#: man-pages/man2/bind.2:212 man-pages/man2/execveat.2:130
#: man-pages/man2/statx.2:499 man-pages/man2/rmdir.2:73
#: man-pages/man2/acct.2:97 man-pages/man2/mknod.2:188
#: man-pages/man2/rename.2:361 man-pages/man2/truncate.2:151
#: man-pages/man2/open.2:1042 man-pages/man2/open.2:1046
#: man-pages/man2/chroot.2:138 man-pages/man2/spu_create.2:192
#: man-pages/man2/access.2:211 man-pages/man2/mount.2:746
#: man-pages/man2/mount.2:749 man-pages/man2/chmod.2:269
#: man-pages/man2/chdir.2:94 man-pages/man2/unlink.2:190
#: man-pages/man2/symlink.2:171 man-pages/man2/keyctl.2:1812
#: man-pages/man2/utimensat.2:330 man-pages/man2/chown.2:246
#: man-pages/man2/stat.2:394 man-pages/man2/link.2:217
#: man-pages/man2/readlink.2:190 man-pages/man2/mkdir.2:154
#: man-pages/man2/open_by_handle_at.2:362 man-pages/man2/epoll_ctl.2:329
#: man-pages/man2/statfs.2:249 man-pages/man2/execve.2:480
#: man-pages/man2/execve.2:485
#, no-wrap
msgid "B<ELOOP>"
msgstr ""

#. type: Plain text
#: man-pages/man2/bind.2:216
msgid "Too many symbolic links were encountered in resolving I<addr>."
msgstr ""

#. type: TP
#: man-pages/man2/bind.2:216 man-pages/man2/statx.2:502
#: man-pages/man2/rmdir.2:77 man-pages/man2/acct.2:101
#: man-pages/man2/mknod.2:192 man-pages/man2/rename.2:372
#: man-pages/man2/truncate.2:154 man-pages/man2/open.2:1062
#: man-pages/man2/chroot.2:142 man-pages/man2/spu_create.2:199
#: man-pages/man2/access.2:215 man-pages/man2/mount.2:759
#: man-pages/man2/chmod.2:273 man-pages/man2/inotify_add_watch.2:115
#: man-pages/man2/chdir.2:98 man-pages/man2/unlink.2:194
#: man-pages/man2/symlink.2:175 man-pages/man2/utimensat.2:335
#: man-pages/man2/chown.2:250 man-pages/man2/lookup_dcookie.2:58
#: man-pages/man2/gethostname.2:116 man-pages/man2/stat.2:397
#: man-pages/man2/link.2:233 man-pages/man2/readlink.2:193
#: man-pages/man2/mkdir.2:162 man-pages/man2/statfs.2:254
#: man-pages/man2/execve.2:496 man-pages/man2/umount.2:157
#, no-wrap
msgid "B<ENAMETOOLONG>"
msgstr ""

#. type: Plain text
#: man-pages/man2/bind.2:220
msgid "I<addr> is too long."
msgstr ""

#. type: TP
#: man-pages/man2/bind.2:220 man-pages/man2/execveat.2:140
#: man-pages/man2/statx.2:506 man-pages/man2/rmdir.2:80
#: man-pages/man2/readdir.2:110 man-pages/man2/acct.2:108
#: man-pages/man2/mknod.2:195 man-pages/man2/getdents.2:196
#: man-pages/man2/rename.2:375 man-pages/man2/rename.2:500
#: man-pages/man2/truncate.2:158 man-pages/man2/swapon.2:150
#: man-pages/man2/open.2:1076 man-pages/man2/open.2:1080
#: man-pages/man2/open.2:1085 man-pages/man2/msgget.2:173
#: man-pages/man2/chroot.2:146 man-pages/man2/shmget.2:257
#: man-pages/man2/spu_create.2:210 man-pages/man2/delete_module.2:147
#: man-pages/man2/semget.2:199 man-pages/man2/utime.2:148
#: man-pages/man2/access.2:219 man-pages/man2/mount.2:767
#: man-pages/man2/chmod.2:277 man-pages/man2/move_pages.2:193
#: man-pages/man2/inotify_add_watch.2:119 man-pages/man2/chdir.2:102
#: man-pages/man2/query_module.2:153 man-pages/man2/unlink.2:197
#: man-pages/man2/symlink.2:178 man-pages/man2/symlink.2:215
#: man-pages/man2/perf_event_open.2:3240 man-pages/man2/keyctl.2:1846
#: man-pages/man2/keyctl.2:1852 man-pages/man2/keyctl.2:1864
#: man-pages/man2/ioctl_fat.2:201 man-pages/man2/kcmp.2:271
#: man-pages/man2/utimensat.2:340 man-pages/man2/chown.2:254
#: man-pages/man2/chown.2:286 man-pages/man2/quotactl.2:719
#: man-pages/man2/fanotify_mark.2:388 man-pages/man2/stat.2:401
#: man-pages/man2/stat.2:406 man-pages/man2/link.2:236
#: man-pages/man2/link.2:299 man-pages/man2/link.2:307
#: man-pages/man2/link.2:317 man-pages/man2/bpf.2:1096
#: man-pages/man2/readlink.2:196 man-pages/man2/mkdir.2:165
#: man-pages/man2/open_by_handle_at.2:313 man-pages/man2/epoll_ctl.2:336
#: man-pages/man2/statfs.2:259 man-pages/man2/execve.2:503
#: man-pages/man2/umount.2:161
#, no-wrap
msgid "B<ENOENT>"
msgstr ""

#. type: Plain text
#: man-pages/man2/bind.2:223
msgid "A component in the directory prefix of the socket pathname does not exist."
msgstr ""

#. type: Plain text
#: man-pages/man2/bind.2:226 man-pages/man2/set_mempolicy.2:300
#: man-pages/man2/rmdir.2:88 man-pages/man2/mknod.2:203
#: man-pages/man2/rename.2:391 man-pages/man2/open.2:1109
#: man-pages/man2/chroot.2:152 man-pages/man2/access.2:251
#: man-pages/man2/chmod.2:283 man-pages/man2/inotify_add_watch.2:127
#: man-pages/man2/chdir.2:110 man-pages/man2/unlink.2:207
#: man-pages/man2/symlink.2:190 man-pages/man2/mbind.2:411
#: man-pages/man2/chown.2:260 man-pages/man2/userfaultfd.2:443
#: man-pages/man2/link.2:244 man-pages/man2/readlink.2:202
#: man-pages/man2/mkdir.2:173 man-pages/man2/statfs.2:268
#: man-pages/man2/execve.2:518
msgid "Insufficient kernel memory was available."
msgstr ""

#. type: TP
#: man-pages/man2/bind.2:226 man-pages/man2/execveat.2:154
#: man-pages/man2/statx.2:519 man-pages/man2/rmdir.2:88
#: man-pages/man2/readdir.2:113 man-pages/man2/acct.2:120
#: man-pages/man2/mknod.2:208 man-pages/man2/mknod.2:238
#: man-pages/man2/getdents.2:199 man-pages/man2/rename.2:395
#: man-pages/man2/rename.2:455 man-pages/man2/truncate.2:161
#: man-pages/man2/open.2:1115 man-pages/man2/open.2:1205
#: man-pages/man2/chroot.2:152 man-pages/man2/pivot_root.2:154
#: man-pages/man2/spu_create.2:228 man-pages/man2/access.2:224
#: man-pages/man2/access.2:266 man-pages/man2/mount.2:777
#: man-pages/man2/chmod.2:283 man-pages/man2/chmod.2:333
#: man-pages/man2/inotify_add_watch.2:131 man-pages/man2/chdir.2:110
#: man-pages/man2/chdir.2:127 man-pages/man2/unlink.2:207
#: man-pages/man2/unlink.2:268 man-pages/man2/symlink.2:194
#: man-pages/man2/symlink.2:221 man-pages/man2/keyctl.2:1890
#: man-pages/man2/ioctl_fat.2:210 man-pages/man2/utimensat.2:349
#: man-pages/man2/chown.2:260 man-pages/man2/chown.2:310
#: man-pages/man2/futimesat.2:102 man-pages/man2/fanotify_mark.2:412
#: man-pages/man2/stat.2:416 man-pages/man2/stat.2:451
#: man-pages/man2/link.2:248 man-pages/man2/link.2:328
#: man-pages/man2/readlink.2:202 man-pages/man2/readlink.2:212
#: man-pages/man2/fcntl.2:1784 man-pages/man2/sysctl.2:95
#: man-pages/man2/mkdir.2:182 man-pages/man2/mkdir.2:203
#: man-pages/man2/open_by_handle_at.2:320 man-pages/man2/statfs.2:271
#: man-pages/man2/execve.2:518
#, no-wrap
msgid "B<ENOTDIR>"
msgstr ""

#. type: Plain text
#: man-pages/man2/bind.2:229 man-pages/man2/truncate.2:164
#: man-pages/man2/chmod.2:286 man-pages/man2/chown.2:263
#: man-pages/man2/readlink.2:205
msgid "A component of the path prefix is not a directory."
msgstr ""

#. type: TP
#: man-pages/man2/bind.2:229 man-pages/man2/rmdir.2:124
#: man-pages/man2/acct.2:131 man-pages/man2/mknod.2:227
#: man-pages/man2/rename.2:433 man-pages/man2/truncate.2:174
#: man-pages/man2/open.2:1170 man-pages/man2/utime.2:161
#: man-pages/man2/access.2:229 man-pages/man2/mount.2:791
#: man-pages/man2/chmod.2:297 man-pages/man2/chmod.2:315
#: man-pages/man2/unlink.2:240 man-pages/man2/symlink.2:204
#: man-pages/man2/utimensat.2:399 man-pages/man2/chown.2:272
#: man-pages/man2/chown.2:292 man-pages/man2/link.2:275
#: man-pages/man2/mkdir.2:192
#, no-wrap
msgid "B<EROFS>"
msgstr ""

#. type: Plain text
#: man-pages/man2/bind.2:232
msgid "The socket inode would reside on a read-only filesystem."
msgstr ""

#.  SVr4 documents an additional
#.  .B ENOSR
#.  general error condition, and
#.  additional
#.  .B EIO
#.  and
#.  .B EISDIR
#.  UNIX-domain error conditions.
#. type: Plain text
#: man-pages/man2/bind.2:244
msgid ""
"POSIX.1-2001, POSIX.1-2008, SVr4, 4.4BSD (B<bind>()  first appeared in "
"4.2BSD)."
msgstr ""

#. type: Plain text
#: man-pages/man2/bind.2:250 man-pages/man2/socketpair.2:138
#: man-pages/man2/socket.2:475 man-pages/man2/connect.2:268
#: man-pages/man2/listen.2:148 man-pages/man2/getsockopt.2:187
msgid ""
"POSIX.1 does not require the inclusion of I<E<lt>sys/types.hE<gt>>, and this "
"header file is not required on Linux.  However, some historical (BSD) "
"implementations required this header file, and portable applications are "
"probably wise to include it."
msgstr ""

#. type: Plain text
#: man-pages/man2/bind.2:255 man-pages/man2/getsockname.2:108
#: man-pages/man2/connect.2:273 man-pages/man2/getpeername.2:110
#: man-pages/man2/getsockopt.2:192
msgid "For background on the I<socklen_t> type, see B<accept>(2)."
msgstr ""

#.  FIXME Document transparent proxy options
#. type: Plain text
#: man-pages/man2/bind.2:258
msgid "The transparent proxy options are not described."
msgstr ""

#. type: Plain text
#: man-pages/man2/bind.2:263
msgid ""
"An example of the use of B<bind>()  with Internet domain sockets can be "
"found in B<getaddrinfo>(3)."
msgstr ""

#.  listen.7 refers to this example.
#.  accept.7 refers to this example.
#.  unix.7 refers to this example.
#. type: Plain text
#: man-pages/man2/bind.2:270
msgid ""
"The following example shows how to bind a stream socket in the UNIX "
"(B<AF_UNIX>)  domain, and accept connections:"
msgstr ""

#. type: Plain text
#: man-pages/man2/bind.2:277
#, no-wrap
msgid ""
"#include E<lt>sys/socket.hE<gt>\n"
"#include E<lt>sys/un.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/bind.2:280
#, no-wrap
msgid ""
"#define MY_SOCK_PATH \"/somepath\"\n"
"#define LISTEN_BACKLOG 50\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/bind.2:290
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int sfd, cfd;\n"
"    struct sockaddr_un my_addr, peer_addr;\n"
"    socklen_t peer_addr_size;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/bind.2:294
#, no-wrap
msgid ""
"    sfd = socket(AF_UNIX, SOCK_STREAM, 0);\n"
"    if (sfd == -1)\n"
"        handle_error(\"socket\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/bind.2:300
#, no-wrap
msgid ""
"    memset(&my_addr, 0, sizeof(struct sockaddr_un));\n"
"                        /* Clear structure */\n"
"    my_addr.sun_family = AF_UNIX;\n"
"    strncpy(my_addr.sun_path, MY_SOCK_PATH,\n"
"            sizeof(my_addr.sun_path) - 1);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/bind.2:304
#, no-wrap
msgid ""
"    if (bind(sfd, (struct sockaddr *) &my_addr,\n"
"            sizeof(struct sockaddr_un)) == -1)\n"
"        handle_error(\"bind\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/bind.2:307
#, no-wrap
msgid ""
"    if (listen(sfd, LISTEN_BACKLOG) == -1)\n"
"        handle_error(\"listen\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/bind.2:310
#, no-wrap
msgid ""
"    /* Now we can accept incoming connections one\n"
"       at a time using accept(2) */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/bind.2:316
#, no-wrap
msgid ""
"    peer_addr_size = sizeof(struct sockaddr_un);\n"
"    cfd = accept(sfd, (struct sockaddr *) &peer_addr,\n"
"                 &peer_addr_size);\n"
"    if (cfd == -1)\n"
"        handle_error(\"accept\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/bind.2:318
#, no-wrap
msgid "    /* Code to deal with incoming connection(s)... */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/bind.2:322
#, no-wrap
msgid ""
"    /* When no longer required, the socket pathname, MY_SOCK_PATH\n"
"       should be deleted using unlink(2) or remove(3) */\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/bind.2:335
msgid ""
"B<accept>(2), B<connect>(2), B<getsockname>(2), B<listen>(2), B<socket>(2), "
"B<getaddrinfo>(3), B<getifaddrs>(3), B<ip>(7), B<ipv6>(7), "
"B<path_resolution>(7), B<socket>(7), B<unix>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/msgop.2:39
#, no-wrap
msgid "MSGOP"
msgstr ""

#. type: TH
#: man-pages/man2/msgop.2:39 man-pages/man2/poll.2:31
#: man-pages/man2/msgget.2:35 man-pages/man2/shmget.2:38
#: man-pages/man2/setxattr.2:25 man-pages/man2/pivot_root.2:27
#: man-pages/man2/msgctl.2:38 man-pages/man2/prctl.2:54
#: man-pages/man2/semget.2:36 man-pages/man2/intro.2:29
#: man-pages/man2/mount.2:40 man-pages/man2/fanotify_init.2:24
#: man-pages/man2/chdir.2:33 man-pages/man2/clone.2:42
#: man-pages/man2/pkey_alloc.2:25 man-pages/man2/ipc.2:25
#: man-pages/man2/shmctl.2:46 man-pages/man2/mprotect.2:33
#: man-pages/man2/fanotify_mark.2:24 man-pages/man2/tkill.2:29
#: man-pages/man2/bpf.2:26 man-pages/man2/semctl.2:42 man-pages/man2/semop.2:35
#: man-pages/man2/shmop.2:41
#, no-wrap
msgid "2019-08-02"
msgstr ""

#. type: Plain text
#: man-pages/man2/msgop.2:42
msgid "msgrcv, msgsnd - System V message queue operations"
msgstr ""

#. type: Plain text
#: man-pages/man2/msgop.2:47 man-pages/man2/msgget.2:43
#: man-pages/man2/msgctl.2:46
#, no-wrap
msgid ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>sys/ipc.hE<gt>>\n"
"B<#include E<lt>sys/msg.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/msgop.2:50
#, no-wrap
msgid ""
"B<int msgsnd(int >I<msqid>B<, const void *>I<msgp>B<, size_t >I<msgsz>B<, "
"int >I<msgflg>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/msgop.2:54
#, no-wrap
msgid ""
"B<ssize_t msgrcv(int >I<msqid>B<, void *>I<msgp>B<, size_t >I<msgsz>B<, long "
">I<msgtyp>B<,>\n"
"B<               int >I<msgflg>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/msgop.2:64
msgid ""
"The B<msgsnd>()  and B<msgrcv>()  system calls are used to send messages to, "
"and receive messages from, a System\\ V message queue.  The calling process "
"must have write permission on the message queue in order to send a message, "
"and read permission to receive a message."
msgstr ""

#. type: Plain text
#: man-pages/man2/msgop.2:69
msgid ""
"The I<msgp> argument is a pointer to a caller-defined structure of the "
"following general form:"
msgstr ""

#. type: Plain text
#: man-pages/man2/msgop.2:76
#, no-wrap
msgid ""
"struct msgbuf {\n"
"    long mtype;       /* message type, must be E<gt> 0 */\n"
"    char mtext[1];    /* message data */\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/msgop.2:95
msgid ""
"The I<mtext> field is an array (or other structure) whose size is specified "
"by I<msgsz>, a nonnegative integer value.  Messages of zero length (i.e., no "
"I<mtext> field) are permitted.  The I<mtype> field must have a strictly "
"positive integer value.  This value can be used by the receiving process for "
"message selection (see the description of B<msgrcv>()  below)."
msgstr ""

#. type: SS
#: man-pages/man2/msgop.2:95
#, no-wrap
msgid "msgsnd()"
msgstr ""

#. type: Plain text
#: man-pages/man2/msgop.2:103
msgid ""
"The B<msgsnd>()  system call appends a copy of the message pointed to by "
"I<msgp> to the message queue whose identifier is specified by I<msqid>."
msgstr ""

#. type: Plain text
#: man-pages/man2/msgop.2:116
msgid ""
"If sufficient space is available in the queue, B<msgsnd>()  succeeds "
"immediately.  The queue capacity is governed by the I<msg_qbytes> field in "
"the associated data structure for the message queue.  During queue creation "
"this field is initialized to B<MSGMNB> bytes, but this limit can be modified "
"using B<msgctl>(2).  A message queue is considered to be full if either of "
"the following conditions is true:"
msgstr ""

#. type: Plain text
#: man-pages/man2/msgop.2:121
msgid ""
"Adding a new message to the queue would cause the total number of bytes in "
"the queue to exceed the queue's maximum size (the I<msg_qbytes> field)."
msgstr ""

#. type: Plain text
#: man-pages/man2/msgop.2:130
msgid ""
"Adding another message to the queue would cause the total number of messages "
"in the queue to exceed the queue's maximum size (the I<msg_qbytes> field).  "
"This check is necessary to prevent an unlimited number of zero-length "
"messages being placed on the queue.  Although such messages contain no data, "
"they nevertheless consume (locked) kernel memory."
msgstr ""

#. type: Plain text
#: man-pages/man2/msgop.2:141
msgid ""
"If insufficient space is available in the queue, then the default behavior "
"of B<msgsnd>()  is to block until space becomes available.  If B<IPC_NOWAIT> "
"is specified in I<msgflg>, then the call instead fails with the error "
"B<EAGAIN>."
msgstr ""

#. type: Plain text
#: man-pages/man2/msgop.2:145
msgid "A blocked B<msgsnd>()  call may also fail if:"
msgstr ""

#. type: Plain text
#: man-pages/man2/msgop.2:152
msgid ""
"the queue is removed, in which case the system call fails with I<errno> set "
"to B<EIDRM>; or"
msgstr ""

#. type: Plain text
#: man-pages/man2/msgop.2:164
msgid ""
"a signal is caught, in which case the system call fails with I<errno> set to "
"B<EINTR>;B<see> B<signal>(7).  (B<msgsnd>()  is never automatically "
"restarted after being interrupted by a signal handler, regardless of the "
"setting of the B<SA_RESTART> flag when establishing a signal handler.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/msgop.2:167 man-pages/man2/msgop.2:328
msgid ""
"Upon successful completion the message queue data structure is updated as "
"follows:"
msgstr ""

#. type: Plain text
#: man-pages/man2/msgop.2:170
msgid "I<msg_lspid> is set to the process ID of the calling process."
msgstr ""

#. type: Plain text
#: man-pages/man2/msgop.2:173
msgid "I<msg_qnum> is incremented by 1."
msgstr ""

#. type: Plain text
#: man-pages/man2/msgop.2:176
msgid "I<msg_stime> is set to the current time."
msgstr ""

#. type: SS
#: man-pages/man2/msgop.2:176
#, no-wrap
msgid "msgrcv()"
msgstr ""

#. type: Plain text
#: man-pages/man2/msgop.2:184
msgid ""
"The B<msgrcv>()  system call removes a message from the queue specified by "
"I<msqid> and places it in the buffer pointed to by I<msgp>."
msgstr ""

#. type: Plain text
#: man-pages/man2/msgop.2:210
msgid ""
"The argument I<msgsz> specifies the maximum size in bytes for the member "
"I<mtext> of the structure pointed to by the I<msgp> argument.  If the "
"message text has length greater than I<msgsz>, then the behavior depends on "
"whether B<MSG_NOERROR> is specified in I<msgflg>.  If B<MSG_NOERROR> is "
"specified, then the message text will be truncated (and the truncated part "
"will be lost); if B<MSG_NOERROR> is not specified, then the message isn't "
"removed from the queue and the system call fails returning -1 with I<errno> "
"set to B<E2BIG>."
msgstr ""

#. type: Plain text
#: man-pages/man2/msgop.2:219
msgid ""
"Unless B<MSG_COPY> is specified in I<msgflg> (see below), the I<msgtyp> "
"argument specifies the type of message requested, as follows:"
msgstr ""

#. type: Plain text
#: man-pages/man2/msgop.2:224
msgid "If I<msgtyp> is 0, then the first message in the queue is read."
msgstr ""

#. type: Plain text
#: man-pages/man2/msgop.2:238
msgid ""
"If I<msgtyp> is greater than 0, then the first message in the queue of type "
"I<msgtyp> is read, unless B<MSG_EXCEPT> was specified in I<msgflg>, in which "
"case the first message in the queue of type not equal to I<msgtyp> will be "
"read."
msgstr ""

#. type: Plain text
#: man-pages/man2/msgop.2:246
msgid ""
"If I<msgtyp> is less than 0, then the first message in the queue with the "
"lowest type less than or equal to the absolute value of I<msgtyp> will be "
"read."
msgstr ""

#. type: Plain text
#: man-pages/man2/msgop.2:251
msgid ""
"The I<msgflg> argument is a bit mask constructed by ORing together zero or "
"more of the following flags:"
msgstr ""

#. type: TP
#: man-pages/man2/msgop.2:251
#, no-wrap
msgid "B<IPC_NOWAIT>"
msgstr ""

#. type: Plain text
#: man-pages/man2/msgop.2:258
msgid ""
"Return immediately if no message of the requested type is in the queue.  The "
"system call fails with I<errno> set to B<ENOMSG>."
msgstr ""

#. type: TP
#: man-pages/man2/msgop.2:258
#, no-wrap
msgid "B<MSG_COPY> (since Linux 3.8)"
msgstr ""

#.  commit 4a674f34ba04a002244edaf891b5da7fc1473ae8
#. type: Plain text
#: man-pages/man2/msgop.2:265
msgid ""
"Nondestructively fetch a copy of the message at the ordinal position in the "
"queue specified by I<msgtyp> (messages are considered to be numbered "
"starting at 0)."
msgstr ""

#. type: Plain text
#: man-pages/man2/msgop.2:279
msgid ""
"This flag must be specified in conjunction with B<IPC_NOWAIT>, with the "
"result that, if there is no message available at the given position, the "
"call fails immediately with the error B<ENOMSG>.  Because they alter the "
"meaning of I<msgtyp> in orthogonal ways, B<MSG_COPY> and B<MSG_EXCEPT> may "
"not both be specified in I<msgflg>."
msgstr ""

#. type: Plain text
#: man-pages/man2/msgop.2:287
msgid ""
"The B<MSG_COPY> flag was added for the implementation of the kernel "
"checkpoint-restore facility and is available only if the kernel was built "
"with the B<CONFIG_CHECKPOINT_RESTORE> option."
msgstr ""

#. type: TP
#: man-pages/man2/msgop.2:287
#, no-wrap
msgid "B<MSG_EXCEPT>"
msgstr ""

#. type: Plain text
#: man-pages/man2/msgop.2:295
msgid ""
"Used with I<msgtyp> greater than 0 to read the first message in the queue "
"with message type that differs from I<msgtyp>."
msgstr ""

#. type: TP
#: man-pages/man2/msgop.2:295
#, no-wrap
msgid "B<MSG_NOERROR>"
msgstr ""

#. type: Plain text
#: man-pages/man2/msgop.2:300
msgid "To truncate the message text if longer than I<msgsz> bytes."
msgstr ""

#. type: Plain text
#: man-pages/man2/msgop.2:306
msgid ""
"If no message of the requested type is available and B<IPC_NOWAIT> isn't "
"specified in I<msgflg>, the calling process is blocked until one of the "
"following conditions occurs:"
msgstr ""

#. type: Plain text
#: man-pages/man2/msgop.2:308
msgid "A message of the desired type is placed in the queue."
msgstr ""

#. type: Plain text
#: man-pages/man2/msgop.2:314
msgid ""
"The message queue is removed from the system.  In this case, the system call "
"fails with I<errno> set to B<EIDRM>."
msgstr ""

#. type: Plain text
#: man-pages/man2/msgop.2:325
msgid ""
"The calling process catches a signal.  In this case, the system call fails "
"with I<errno> set to B<EINTR>.  (B<msgrcv>()  is never automatically "
"restarted after being interrupted by a signal handler, regardless of the "
"setting of the B<SA_RESTART> flag when establishing a signal handler.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/msgop.2:331
msgid "I<msg_lrpid> is set to the process ID of the calling process."
msgstr ""

#. type: Plain text
#: man-pages/man2/msgop.2:334
msgid "I<msg_qnum> is decremented by 1."
msgstr ""

#. type: Plain text
#: man-pages/man2/msgop.2:337
msgid "I<msg_rtime> is set to the current time."
msgstr ""

#. type: Plain text
#: man-pages/man2/msgop.2:350
msgid ""
"On failure both functions return -1 with I<errno> indicating the error, "
"otherwise B<msgsnd>()  returns 0 and B<msgrcv>()  returns the number of "
"bytes actually copied into the I<mtext> array."
msgstr ""

#. type: Plain text
#: man-pages/man2/msgop.2:356
msgid ""
"When B<msgsnd>()  fails, I<errno> will be set to one among the following "
"values:"
msgstr ""

#. type: Plain text
#: man-pages/man2/msgop.2:362
msgid ""
"The calling process does not have write permission on the message queue, and "
"does not have the B<CAP_IPC_OWNER> capability in the user namespace that "
"governs its IPC namespace."
msgstr ""

#. type: Plain text
#: man-pages/man2/msgop.2:370
msgid ""
"The message can't be sent due to the I<msg_qbytes> limit for the queue and "
"B<IPC_NOWAIT> was specified in I<msgflg>."
msgstr ""

#. type: Plain text
#: man-pages/man2/msgop.2:375 man-pages/man2/msgop.2:422
msgid "The address pointed to by I<msgp> isn't accessible."
msgstr ""

#. type: TP
#: man-pages/man2/msgop.2:375 man-pages/man2/msgop.2:422
#: man-pages/man2/msgctl.2:300 man-pages/man2/shmctl.2:339
#: man-pages/man2/semctl.2:435 man-pages/man2/semop.2:349
#: man-pages/man2/shmop.2:194
#, no-wrap
msgid "B<EIDRM>"
msgstr ""

#. type: Plain text
#: man-pages/man2/msgop.2:378 man-pages/man2/msgctl.2:303
msgid "The message queue was removed."
msgstr ""

#. type: Plain text
#: man-pages/man2/msgop.2:381
msgid "Sleeping on a full message queue condition, the process caught a signal."
msgstr ""

#. type: Plain text
#: man-pages/man2/msgop.2:392
msgid ""
"Invalid I<msqid> value, or nonpositive I<mtype> value, or invalid I<msgsz> "
"value (less than 0 or greater than the system value B<MSGMAX>)."
msgstr ""

#. type: Plain text
#: man-pages/man2/msgop.2:397
msgid ""
"The system does not have enough memory to make a copy of the message pointed "
"to by I<msgp>."
msgstr ""

#. type: Plain text
#: man-pages/man2/msgop.2:403
msgid ""
"When B<msgrcv>()  fails, I<errno> will be set to one among the following "
"values:"
msgstr ""

#. type: TP
#: man-pages/man2/msgop.2:403 man-pages/man2/getxattr.2:111
#: man-pages/man2/move_pages.2:169 man-pages/man2/perf_event_open.2:3153
#: man-pages/man2/listxattr.2:133 man-pages/man2/sched_setattr.2:330
#: man-pages/man2/sched_setattr.2:347 man-pages/man2/bpf.2:1030
#: man-pages/man2/execve.2:425 man-pages/man2/semop.2:312
#, no-wrap
msgid "B<E2BIG>"
msgstr ""

#. type: Plain text
#: man-pages/man2/msgop.2:411
msgid ""
"The message text length is greater than I<msgsz> and B<MSG_NOERROR> isn't "
"specified in I<msgflg>."
msgstr ""

#. type: Plain text
#: man-pages/man2/msgop.2:417
msgid ""
"The calling process does not have read permission on the message queue, and "
"does not have the B<CAP_IPC_OWNER> capability in the user namespace that "
"governs its IPC namespace."
msgstr ""

#. type: Plain text
#: man-pages/man2/msgop.2:426
msgid ""
"While the process was sleeping to receive a message, the message queue was "
"removed."
msgstr ""

#. type: Plain text
#: man-pages/man2/msgop.2:431
msgid ""
"While the process was sleeping to receive a message, the process caught a "
"signal; see B<signal>(7)."
msgstr ""

#. type: Plain text
#: man-pages/man2/msgop.2:437
msgid "I<msqid> was invalid, or I<msgsz> was less than 0."
msgstr ""

#. type: TP
#: man-pages/man2/msgop.2:437 man-pages/man2/msgop.2:444
#, no-wrap
msgid "B<EINVAL> (since Linux 3.14)"
msgstr ""

#. type: Plain text
#: man-pages/man2/msgop.2:444
msgid "I<msgflg> specified B<MSG_COPY>, but not B<IPC_NOWAIT>."
msgstr ""

#. type: Plain text
#: man-pages/man2/msgop.2:451
msgid "I<msgflg> specified both B<MSG_COPY> and B<MSG_EXCEPT>."
msgstr ""

#. type: TP
#: man-pages/man2/msgop.2:451 man-pages/man2/msgop.2:457
#, no-wrap
msgid "B<ENOMSG>"
msgstr ""

#. type: Plain text
#: man-pages/man2/msgop.2:457
msgid ""
"B<IPC_NOWAIT> was specified in I<msgflg> and no message of the requested "
"type existed on the message queue."
msgstr ""

#. type: Plain text
#: man-pages/man2/msgop.2:467
msgid ""
"B<IPC_NOWAIT> and B<MSG_COPY> were specified in I<msgflg> and the queue "
"contains less than I<msgtyp> messages."
msgstr ""

#. type: TP
#: man-pages/man2/msgop.2:467
#, no-wrap
msgid "B<ENOSYS> (since Linux 3.8)"
msgstr ""

#. type: Plain text
#: man-pages/man2/msgop.2:474
msgid ""
"I<MSG_COPY> was specified in I<msgflg>, and this kernel was configured "
"without B<CONFIG_CHECKPOINT_RESTORE>."
msgstr ""

#.  SVr4 documents an additional error condition EMFILE.
#. type: Plain text
#: man-pages/man2/msgop.2:476 man-pages/man2/setsid.2:75
#: man-pages/man2/sigaction.2:858 man-pages/man2/msgget.2:193
#: man-pages/man2/shmget.2:283 man-pages/man2/msgctl.2:346
#: man-pages/man2/shmctl.2:398 man-pages/man2/semctl.2:483
#: man-pages/man2/getsid.2:87 man-pages/man2/mlock.2:275
#: man-pages/man2/semop.2:389 man-pages/man2/setgid.2:76
#: man-pages/man2/shmop.2:231
msgid "POSIX.1-2001, POSIX.1-2008, SVr4."
msgstr ""

#.  MSG_COPY since glibc 2.18
#. type: Plain text
#: man-pages/man2/msgop.2:486
msgid ""
"The B<MSG_EXCEPT> and B<MSG_COPY> flags are Linux-specific; their "
"definitions can be obtained by defining the B<_GNU_SOURCE> feature test "
"macro."
msgstr ""

#.  Like Linux, the FreeBSD man pages still document
#.  the inclusion of these header files.
#. type: Plain text
#: man-pages/man2/msgop.2:499 man-pages/man2/msgget.2:206
#: man-pages/man2/shmget.2:301 man-pages/man2/msgctl.2:359
#: man-pages/man2/semget.2:236 man-pages/man2/shmctl.2:411
#: man-pages/man2/semctl.2:508 man-pages/man2/semop.2:402
msgid ""
"The inclusion of I<E<lt>sys/types.hE<gt>> and I<E<lt>sys/ipc.hE<gt>> isn't "
"required on Linux or by any version of POSIX.  However, some old "
"implementations required the inclusion of these header files, and the SVID "
"also documented their inclusion.  Applications intended to be portable to "
"such old systems may need to include these header files."
msgstr ""

#. type: Plain text
#: man-pages/man2/msgop.2:506
msgid ""
"The I<msgp> argument is declared as I<struct msgbuf\\ *> in glibc 2.0 and "
"2.1.  It is declared as I<void\\ *> in glibc 2.2 and later, as required by "
"SUSv2 and SUSv3."
msgstr ""

#. type: Plain text
#: man-pages/man2/msgop.2:510
msgid ""
"The following limits on message queue resources affect the B<msgsnd>()  "
"call:"
msgstr ""

#. type: TP
#: man-pages/man2/msgop.2:510
#, no-wrap
msgid "B<MSGMAX>"
msgstr ""

#. type: Plain text
#: man-pages/man2/msgop.2:515
msgid ""
"Maximum size of a message text, in bytes (default value: 8192 bytes).  On "
"Linux, this limit can be read and modified via I</proc/sys/kernel/msgmax>."
msgstr ""

#. type: TP
#: man-pages/man2/msgop.2:515
#, no-wrap
msgid "B<MSGMNB>"
msgstr ""

#. type: Plain text
#: man-pages/man2/msgop.2:531
msgid ""
"Maximum number of bytes that can be held in a message queue (default value: "
"16384 bytes).  On Linux, this limit can be read and modified via "
"I</proc/sys/kernel/msgmnb>.  A privileged process (Linux: a process with the "
"B<CAP_SYS_RESOURCE> capability)  can increase the size of a message queue "
"beyond B<MSGMNB> using the B<msgctl>(2)  B<IPC_SET> operation."
msgstr ""

#. type: Plain text
#: man-pages/man2/msgop.2:537
msgid ""
"The implementation has no intrinsic system-wide limits on the number of "
"message headers (B<MSGTQL>)  and the number of bytes in the message pool "
"(B<MSGPOOL>)."
msgstr ""

#.  http://marc.info/?l=linux-kernel&m=139048542803605&w=2
#.  commit 4f87dac386cc43d5525da7a939d4b4e7edbea22c
#. type: Plain text
#: man-pages/man2/msgop.2:557
msgid ""
"In Linux 3.13 and earlier, if B<msgrcv>()  was called with the B<MSG_COPY> "
"flag, but without B<IPC_NOWAIT>, and the message queue contained less than "
"I<msgtyp> messages, then the call would block until the next message is "
"written to the queue.  At that point, the call would return a copy of the "
"message, I<regardless> of whether that message was at the ordinal position "
"I<msgtyp>.  This bug is fixed in Linux 3.14."
msgstr ""

#.  http://marc.info/?l=linux-kernel&m=139048542803605&w=2
#.  commit 4f87dac386cc43d5525da7a939d4b4e7edbea22c
#. type: Plain text
#: man-pages/man2/msgop.2:573
msgid ""
"Specifying both B<MSG_COPY> and B<MSC_EXCEPT> in I<msgflg> is a logical "
"error (since these flags impose different interpretations on I<msgtyp>).  In "
"Linux 3.13 and earlier, this error was not diagnosed by B<msgrcv>().  This "
"bug is fixed in Linux 3.14."
msgstr ""

#. type: Plain text
#: man-pages/man2/msgop.2:578
msgid "The program below demonstrates the use of B<msgsnd>()  and B<msgrcv>()."
msgstr ""

#. type: Plain text
#: man-pages/man2/msgop.2:582
msgid ""
"The example program is first run with the B<-s> option to send a message and "
"then run again with the B<-r> option to receive a message."
msgstr ""

#. type: Plain text
#: man-pages/man2/msgop.2:584 man-pages/man2/eventfd.2:371
msgid "The following shell session shows a sample run of the program:"
msgstr ""

#. type: Plain text
#: man-pages/man2/msgop.2:589
#, no-wrap
msgid ""
"$B< ./a.out -s>\n"
"sent: a message at Wed Mar  4 16:25:45 2015\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/msgop.2:592
#, no-wrap
msgid ""
"$B< ./a.out -r>\n"
"message received: a message at Wed Mar  4 16:25:45 2015\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/msgop.2:606
#, no-wrap
msgid ""
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>time.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"
"#include E<lt>sys/types.hE<gt>\n"
"#include E<lt>sys/ipc.hE<gt>\n"
"#include E<lt>sys/msg.hE<gt>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/msgop.2:611
#, no-wrap
msgid ""
"struct msgbuf {\n"
"    long mtype;\n"
"    char mtext[80];\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/msgop.2:617
#, no-wrap
msgid ""
"static void\n"
"usage(char *prog_name, char *msg)\n"
"{\n"
"    if (msg != NULL)\n"
"        fputs(msg, stderr);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/msgop.2:626
#, no-wrap
msgid ""
"    fprintf(stderr, \"Usage: %s [options]\\en\", prog_name);\n"
"    fprintf(stderr, \"Options are:\\en\");\n"
"    fprintf(stderr, \"-s        send message using msgsnd()\\en\");\n"
"    fprintf(stderr, \"-r        read message using msgrcv()\\en\");\n"
"    fprintf(stderr, \"-t        message type (default is 1)\\en\");\n"
"    fprintf(stderr, \"-k        message queue key (default is "
"1234)\\en\");\n"
"    exit(EXIT_FAILURE);\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/msgop.2:632
#, no-wrap
msgid ""
"static void\n"
"send_msg(int qid, int msgtype)\n"
"{\n"
"    struct msgbuf msg;\n"
"    time_t t;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/msgop.2:634
#, no-wrap
msgid "    msg.mtype = msgtype;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/msgop.2:638
#, no-wrap
msgid ""
"    time(&t);\n"
"    snprintf(msg.mtext, sizeof(msg.mtext), \"a message at %s\",\n"
"            ctime(&t));\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/msgop.2:646
#, no-wrap
msgid ""
"    if (msgsnd(qid, (void *) &msg, sizeof(msg.mtext),\n"
"                IPC_NOWAIT) == -1) {\n"
"        perror(\"msgsnd error\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
"    printf(\"sent: %s\\en\", msg.mtext);\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/msgop.2:651
#, no-wrap
msgid ""
"static void\n"
"get_msg(int qid, int msgtype)\n"
"{\n"
"    struct msgbuf msg;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/msgop.2:662
#, no-wrap
msgid ""
"    if (msgrcv(qid, (void *) &msg, sizeof(msg.mtext), msgtype,\n"
"               MSG_NOERROR | IPC_NOWAIT) == -1) {\n"
"        if (errno != ENOMSG) {\n"
"            perror(\"msgrcv\");\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"
"        printf(\"No message available for msgrcv()\\en\");\n"
"    } else\n"
"        printf(\"message received: %s\\en\", msg.mtext);\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/msgop.2:670
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int qid, opt;\n"
"    int mode = 0;               /* 1 = send, 2 = receive */\n"
"    int msgtype = 1;\n"
"    int msgkey = 1234;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/msgop.2:691
#, no-wrap
msgid ""
"    while ((opt = getopt(argc, argv, \"srt:k:\")) != -1) {\n"
"        switch (opt) {\n"
"        case \\(aqs\\(aq:\n"
"            mode = 1;\n"
"            break;\n"
"        case \\(aqr\\(aq:\n"
"            mode = 2;\n"
"            break;\n"
"        case \\(aqt\\(aq:\n"
"            msgtype = atoi(optarg);\n"
"            if (msgtype E<lt>= 0)\n"
"                usage(argv[0], \"-t option must be greater than 0\\en\");\n"
"            break;\n"
"        case \\(aqk\\(aq:\n"
"            msgkey = atoi(optarg);\n"
"            break;\n"
"        default:\n"
"            usage(argv[0], \"Unrecognized option\\en\");\n"
"        }\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/msgop.2:694
#, no-wrap
msgid ""
"    if (mode == 0)\n"
"        usage(argv[0], \"must use either -s or -r option\\en\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/msgop.2:696
#, no-wrap
msgid "    qid = msgget(msgkey, IPC_CREAT | 0666);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/msgop.2:701
#, no-wrap
msgid ""
"    if (qid == -1) {\n"
"        perror(\"msgget\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/msgop.2:706
#, no-wrap
msgid ""
"    if (mode == 2)\n"
"        get_msg(qid, msgtype);\n"
"    else\n"
"        send_msg(qid, msgtype);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/msgop.2:709 man-pages/man2/getrlimit.2:834
#: man-pages/man2/memfd_create.2:480 man-pages/man2/memfd_create.2:530
#: man-pages/man2/request_key.2:544 man-pages/man2/getdents.2:307
#: man-pages/man2/pivot_root.2:410 man-pages/man2/ioctl_ns.2:357
#: man-pages/man2/membarrier.2:325 man-pages/man2/membarrier.2:414
#: man-pages/man2/keyctl.2:2229 man-pages/man2/clone.2:1448
#: man-pages/man2/ioctl_fat.2:348 man-pages/man2/ioctl_fat.2:412
#: man-pages/man2/ioctl_fat.2:499 man-pages/man2/kcmp.2:427
#: man-pages/man2/chown.2:496 man-pages/man2/spu_run.2:261
#: man-pages/man2/timerfd_create.2:637 man-pages/man2/add_key.2:269
#: man-pages/man2/userfaultfd.2:751 man-pages/man2/stat.2:705
#: man-pages/man2/select.2:711 man-pages/man2/mmap.2:980
#: man-pages/man2/open_by_handle_at.2:610
#: man-pages/man2/open_by_handle_at.2:750 man-pages/man2/execve.2:783
#: man-pages/man2/futex.2:1886 man-pages/man2/timer_create.2:464
#, no-wrap
msgid ""
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/msgop.2:715
msgid ""
"B<msgctl>(2), B<msgget>(2), B<capabilities>(7), B<mq_overview>(7), "
"B<sysvipc>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/execveat.2:26
#, no-wrap
msgid "EXECVEAT"
msgstr ""

#. type: Plain text
#: man-pages/man2/execveat.2:29
msgid "execveat - execute program relative to a directory file descriptor"
msgstr ""

#. type: Plain text
#: man-pages/man2/execveat.2:33
msgid "B<int execveat(int >I<dirfd>B<, const char *>I<pathname>B<,>"
msgstr ""

#. type: Plain text
#: man-pages/man2/execveat.2:35
msgid "B< char *const >I<argv>B<[], char *const >I<envp>B<[],>"
msgstr ""

#. type: Plain text
#: man-pages/man2/execveat.2:37
msgid "B< int >I<flags>B<);>"
msgstr ""

#.  commit 51f39a1f0cea1cacf8c787f652f26dfee9611874
#. type: Plain text
#: man-pages/man2/execveat.2:48
msgid ""
"The B<execveat>()  system call executes the program referred to by the "
"combination of I<dirfd> and I<pathname>.  It operates in exactly the same "
"way as B<execve>(2), except for the differences described in this manual "
"page."
msgstr ""

#. type: Plain text
#: man-pages/man2/execveat.2:58
msgid ""
"If the pathname given in I<pathname> is relative, then it is interpreted "
"relative to the directory referred to by the file descriptor I<dirfd> "
"(rather than relative to the current working directory of the calling "
"process, as is done by B<execve>(2)  for a relative pathname)."
msgstr ""

#. type: Plain text
#: man-pages/man2/execveat.2:70
msgid ""
"If I<pathname> is relative and I<dirfd> is the special value B<AT_FDCWD>, "
"then I<pathname> is interpreted relative to the current working directory of "
"the calling process (like B<execve>(2))."
msgstr ""

#. type: Plain text
#: man-pages/man2/execveat.2:76 man-pages/man2/mknod.2:148
#: man-pages/man2/open.2:936 man-pages/man2/access.2:162
#: man-pages/man2/chmod.2:230 man-pages/man2/utimensat.2:211
#: man-pages/man2/chown.2:181 man-pages/man2/futimesat.2:84
#: man-pages/man2/stat.2:301 man-pages/man2/readlink.2:135
#: man-pages/man2/mkdir.2:113
msgid "If I<pathname> is absolute, then I<dirfd> is ignored."
msgstr ""

#. type: Plain text
#: man-pages/man2/execveat.2:86
msgid ""
"If I<pathname> is an empty string and the B<AT_EMPTY_PATH> flag is "
"specified, then the file descriptor I<dirfd> specifies the file to be "
"executed (i.e., I<dirfd> refers to an executable file, rather than a "
"directory)."
msgstr ""

#. type: Plain text
#: man-pages/man2/execveat.2:90
msgid ""
"The I<flags> argument is a bit mask that can include zero or more of the "
"following flags:"
msgstr ""

#. type: TP
#: man-pages/man2/execveat.2:90 man-pages/man2/statx.2:168
#, no-wrap
msgid "B<AT_EMPTY_PATH>"
msgstr ""

#. type: Plain text
#: man-pages/man2/execveat.2:100
msgid ""
"If I<pathname> is an empty string, operate on the file referred to by "
"I<dirfd> (which may have been obtained using the B<open>(2)  B<O_PATH> "
"flag)."
msgstr ""

#. type: TP
#: man-pages/man2/execveat.2:100 man-pages/man2/statx.2:209
#: man-pages/man2/access.2:172 man-pages/man2/chmod.2:233
#: man-pages/man2/utimensat.2:217 man-pages/man2/chown.2:209
#: man-pages/man2/stat.2:358
#, no-wrap
msgid "B<AT_SYMLINK_NOFOLLOW>"
msgstr ""

#. type: Plain text
#: man-pages/man2/execveat.2:108
msgid ""
"If the file identified by I<dirfd> and a non-NULL I<pathname> is a symbolic "
"link, then the call fails with the error B<ELOOP>."
msgstr ""

#. type: Plain text
#: man-pages/man2/execveat.2:115
msgid ""
"On success, B<execveat>()  does not return.  On error, -1 is returned, and "
"I<errno> is set appropriately."
msgstr ""

#. type: Plain text
#: man-pages/man2/execveat.2:122
msgid ""
"The same errors that occur for B<execve>(2)  can also occur for "
"B<execveat>().  The following additional errors can occur for B<execveat>():"
msgstr ""

#. type: Plain text
#: man-pages/man2/execveat.2:126 man-pages/man2/mknod.2:238
#: man-pages/man2/open.2:1205 man-pages/man2/access.2:262
#: man-pages/man2/chmod.2:329 man-pages/man2/unlink.2:257
#: man-pages/man2/chown.2:306 man-pages/man2/futimesat.2:102
#: man-pages/man2/stat.2:447 man-pages/man2/readlink.2:212
#: man-pages/man2/mkdir.2:203
msgid "I<dirfd> is not a valid file descriptor."
msgstr ""

#. type: Plain text
#: man-pages/man2/execveat.2:130 man-pages/man2/statx.2:492
#: man-pages/man2/access.2:266 man-pages/man2/chmod.2:333
#: man-pages/man2/chown.2:310 man-pages/man2/stat.2:451
msgid "Invalid flag specified in I<flags>."
msgstr ""

#. type: Plain text
#: man-pages/man2/execveat.2:140
msgid ""
"I<flags> includes B<AT_SYMLINK_NOFOLLOW> and the file identified by I<dirfd> "
"and a non-NULL I<pathname> is a symbolic link."
msgstr ""

#. type: Plain text
#: man-pages/man2/execveat.2:154
msgid ""
"The program identified by I<dirfd> and I<pathname> requires the use of an "
"interpreter program (such as a script starting with \"#!\"), but the file "
"descriptor I<dirfd> was opened with the B<O_CLOEXEC> flag, with the result "
"that the program file is inaccessible to the launched interpreter.  See "
"BUGS."
msgstr ""

#. type: Plain text
#: man-pages/man2/execveat.2:160 man-pages/man2/mknod.2:244
#: man-pages/man2/access.2:272 man-pages/man2/chmod.2:339
#: man-pages/man2/unlink.2:274 man-pages/man2/chown.2:316
#: man-pages/man2/futimesat.2:108 man-pages/man2/stat.2:457
#: man-pages/man2/readlink.2:218 man-pages/man2/mkdir.2:209
msgid ""
"I<pathname> is relative and I<dirfd> is a file descriptor referring to a "
"file other than a directory."
msgstr ""

#.  FIXME . check for glibc support in a future release
#. type: Plain text
#: man-pages/man2/execveat.2:165
msgid ""
"B<execveat>()  was added to Linux in kernel 3.19.  GNU C library support is "
"pending."
msgstr ""

#. type: Plain text
#: man-pages/man2/execveat.2:169
msgid "The B<execveat>()  system call is Linux-specific."
msgstr ""

#. type: Plain text
#: man-pages/man2/execveat.2:179
msgid ""
"In addition to the reasons explained in B<openat>(2), the B<execveat>()  "
"system call is also needed to allow B<fexecve>(3)  to be implemented on "
"systems that do not have the I</proc> filesystem mounted."
msgstr ""

#. type: Plain text
#: man-pages/man2/execveat.2:202
msgid ""
"When asked to execute a script file, the I<argv[0]> that is passed to the "
"script interpreter is a string of the form I</dev/fd/N> or I</dev/fd/N/P>, "
"where I<N> is the number of the file descriptor passed via the I<dirfd> "
"argument.  A string of the first form occurs when B<AT_EMPTY_PATH> is "
"employed.  A string of the second form occurs when the script is specified "
"via both I<dirfd> and I<pathname>; in this case, I<P> is the value given in "
"I<pathname>."
msgstr ""

#. type: Plain text
#: man-pages/man2/execveat.2:210
msgid ""
"For the same reasons described in B<fexecve>(3), the natural idiom when "
"using B<execveat>()  is to set the close-on-exec flag on I<dirfd>.  (But see "
"BUGS.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/execveat.2:215
msgid ""
"The B<ENOENT> error described above means that it is not possible to set the "
"close-on-exec flag on the file descriptor given to a call of the form:"
msgstr ""

#. type: Plain text
#: man-pages/man2/execveat.2:217
#, no-wrap
msgid "    execveat(fd, \"\", argv, envp, AT_EMPTY_PATH);\n"
msgstr ""

#.  For an example, see Michael Kerrisk's 2015-01-10 reply in this LKML
#.  thread (http://thread.gmane.org/gmane.linux.kernel/1836105/focus=20229):
#
#.      Subject: [PATCHv10 man-pages 5/5] execveat.2: initial man page.\"                        for execveat(2
#.      Date: Mon, 24 Nov 2014 11:53:59 +0000
#. type: Plain text
#: man-pages/man2/execveat.2:229
msgid ""
"However, the inability to set the close-on-exec flag means that a file "
"descriptor referring to the script leaks through to the script itself.  As "
"well as wasting a file descriptor, this leakage can lead to file-descriptor "
"exhaustion in scenarios where scripts recursively employ B<execveat>()."
msgstr ""

#. type: Plain text
#: man-pages/man2/execveat.2:232
msgid "B<execve>(2), B<openat>(2), B<fexecve>(3)"
msgstr ""

#. type: TH
#: man-pages/man2/socketpair.2:42
#, no-wrap
msgid "SOCKETPAIR"
msgstr ""

#. type: Plain text
#: man-pages/man2/socketpair.2:45
msgid "socketpair - create a pair of connected sockets"
msgstr ""

#. type: Plain text
#: man-pages/man2/socketpair.2:47 man-pages/man2/socket.2:48
msgid "B<#include E<lt>sys/types.hE<gt>> /* See NOTES */"
msgstr ""

#. type: Plain text
#: man-pages/man2/socketpair.2:49 man-pages/man2/shutdown.2:45
#: man-pages/man2/socket.2:50 man-pages/man2/getpeername.2:47
msgid "B<#include E<lt>sys/socket.hE<gt>>"
msgstr ""

#. type: Plain text
#: man-pages/man2/socketpair.2:52
msgid ""
"B<int socketpair(int >I<domain>B<, int >I<type>B<, int >I<protocol>B<, int "
">I<sv>B<[2]);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/socketpair.2:63
msgid ""
"The B<socketpair>()  call creates an unnamed pair of connected sockets in "
"the specified I<domain>, of the specified I<type>, and using the optionally "
"specified I<protocol>.  For further details of these arguments, see "
"B<socket>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/socketpair.2:69
msgid ""
"The file descriptors used in referencing the new sockets are returned in "
"I<sv>[0] and I<sv>[1].  The two sockets are indistinguishable."
msgstr ""

#. type: Plain text
#: man-pages/man2/socketpair.2:76
msgid ""
"On success, zero is returned.  On error, -1 is returned, I<errno> is set "
"appropriately, and I<sv> is left unchanged"
msgstr ""

#.  http://austingroupbugs.net/view.php?id=483
#. type: Plain text
#: man-pages/man2/socketpair.2:84
msgid ""
"On Linux (and other systems), B<socketpair>()  does not modify I<sv> on "
"failure.  A requirement standardizing this behavior was added in "
"POSIX.1-2016."
msgstr ""

#. type: TP
#: man-pages/man2/socketpair.2:85 man-pages/man2/socket.2:427
#: man-pages/man2/connect.2:164
#, no-wrap
msgid "B<EAFNOSUPPORT>"
msgstr ""

#. type: Plain text
#: man-pages/man2/socketpair.2:88
msgid "The specified address family is not supported on this machine."
msgstr ""

#. type: Plain text
#: man-pages/man2/socketpair.2:93
msgid ""
"The address I<sv> does not specify a valid part of the process address "
"space."
msgstr ""

#. type: Plain text
#: man-pages/man2/socketpair.2:102
msgid "The specified protocol does not support creation of socket pairs."
msgstr ""

#. type: TP
#: man-pages/man2/socketpair.2:102 man-pages/man2/socket.2:449
#, no-wrap
msgid "B<EPROTONOSUPPORT>"
msgstr ""

#. type: Plain text
#: man-pages/man2/socketpair.2:105
msgid "The specified protocol is not supported on this machine."
msgstr ""

#. type: Plain text
#: man-pages/man2/socketpair.2:112
msgid ""
"POSIX.1-2001, POSIX.1-2008, 4.4BSD.  B<socketpair>()  first appeared in "
"4.2BSD.  It is generally portable to/from non-BSD systems supporting clones "
"of the BSD socket layer (including System\\ V variants)."
msgstr ""

#.  commit: 70b03759e9ecfae400605fa34f3d7154cccbbba3
#. type: Plain text
#: man-pages/man2/socketpair.2:121
msgid ""
"On Linux, the only supported domains for this call are B<AF_UNIX> (or "
"synonymously, B<AF_LOCAL>)  and B<AF_TIPC> (since Linux 4.12)."
msgstr ""

#. type: Plain text
#: man-pages/man2/socketpair.2:132
msgid ""
"Since Linux 2.6.27, B<socketpair>()  supports the B<SOCK_NONBLOCK> and "
"B<SOCK_CLOEXEC> flags in the I<type> argument, as described in B<socket>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/socketpair.2:144
msgid "B<pipe>(2), B<read>(2), B<socket>(2), B<write>(2), B<socket>(7), B<unix>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/seccomp.2:28
#, no-wrap
msgid "SECCOMP"
msgstr ""

#. type: Plain text
#: man-pages/man2/seccomp.2:31
msgid "seccomp - operate on Secure Computing state of the process"
msgstr ""

#.  Kees Cook noted: Anything that uses SECCOMP_RET_TRACE returns will
#.                   need <sys/ptrace.h>
#. type: Plain text
#: man-pages/man2/seccomp.2:40
#, no-wrap
msgid ""
"B<#include E<lt>linux/seccomp.hE<gt>>\n"
"B<#include E<lt>linux/filter.hE<gt>>\n"
"B<#include E<lt>linux/audit.hE<gt>>\n"
"B<#include E<lt>linux/signal.hE<gt>>\n"
"B<#include E<lt>sys/ptrace.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/seccomp.2:43
#, no-wrap
msgid ""
"B<int seccomp(unsigned int >I<operation>B<, unsigned int >I<flags>B<, void "
"*>I<args>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/seccomp.2:49
msgid ""
"The B<seccomp>()  system call operates on the Secure Computing (seccomp) "
"state of the calling process."
msgstr ""

#. type: Plain text
#: man-pages/man2/seccomp.2:53
msgid "Currently, Linux supports the following I<operation> values:"
msgstr ""

#. type: TP
#: man-pages/man2/seccomp.2:53
#, no-wrap
msgid "B<SECCOMP_SET_MODE_STRICT>"
msgstr ""

#. type: Plain text
#: man-pages/man2/seccomp.2:69
msgid ""
"The only system calls that the calling thread is permitted to make are "
"B<read>(2), B<write>(2), B<_exit>(2)  (but not B<exit_group>(2)), and "
"B<sigreturn>(2).  Other system calls result in the delivery of a B<SIGKILL> "
"signal.  Strict secure computing mode is useful for number-crunching "
"applications that may need to execute untrusted byte code, perhaps obtained "
"by reading from a pipe or socket."
msgstr ""

#. type: Plain text
#: man-pages/man2/seccomp.2:96
msgid ""
"Note that although the calling thread can no longer call B<sigprocmask>(2), "
"it can use B<sigreturn>(2)  to block all signals apart from B<SIGKILL> and "
"B<SIGSTOP>.  This means that B<alarm>(2)  (for example) is not sufficient "
"for restricting the process's execution time.  Instead, to reliably "
"terminate the process, B<SIGKILL> must be used.  This can be done by using "
"B<timer_create>(2)  with B<SIGEV_SIGNAL> and I<sigev_signo> set to "
"B<SIGKILL>, or by using B<setrlimit>(2)  to set the hard limit for "
"B<RLIMIT_CPU>."
msgstr ""

#. type: Plain text
#: man-pages/man2/seccomp.2:100
msgid ""
"This operation is available only if the kernel is configured with "
"B<CONFIG_SECCOMP> enabled."
msgstr ""

#. type: Plain text
#: man-pages/man2/seccomp.2:106
msgid "The value of I<flags> must be 0, and I<args> must be NULL."
msgstr ""

#. type: Plain text
#: man-pages/man2/seccomp.2:108
msgid "This operation is functionally identical to the call:"
msgstr ""

#. type: Plain text
#: man-pages/man2/seccomp.2:112
#, no-wrap
msgid "prctl(PR_SET_SECCOMP, SECCOMP_MODE_STRICT);\n"
msgstr ""

#. type: TP
#: man-pages/man2/seccomp.2:114
#, no-wrap
msgid "B<SECCOMP_SET_MODE_FILTER>"
msgstr ""

#. type: Plain text
#: man-pages/man2/seccomp.2:129
msgid ""
"The system calls allowed are defined by a pointer to a Berkeley Packet "
"Filter (BPF) passed via I<args>.  This argument is a pointer to a I<struct\\ "
"sock_fprog>; it can be designed to filter arbitrary system calls and system "
"call arguments.  If the filter is invalid, B<seccomp>()  fails, returning "
"B<EINVAL> in I<errno>."
msgstr ""

#. type: Plain text
#: man-pages/man2/seccomp.2:141
msgid ""
"If B<fork>(2)  or B<clone>(2)  is allowed by the filter, any child processes "
"will be constrained to the same system call filters as the parent.  If "
"B<execve>(2)  is allowed, the existing filters will be preserved across a "
"call to B<execve>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/seccomp.2:151
msgid ""
"In order to use the B<SECCOMP_SET_MODE_FILTER> operation, either the calling "
"thread must have the B<CAP_SYS_ADMIN> capability in its user namespace, or "
"the thread must already have the I<no_new_privs> bit set.  If that bit was "
"not already set by an ancestor of this thread, the thread must make the "
"following call:"
msgstr ""

#. type: Plain text
#: man-pages/man2/seccomp.2:155
#, no-wrap
msgid "prctl(PR_SET_NO_NEW_PRIVS, 1);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/seccomp.2:176
msgid ""
"Otherwise, the B<SECCOMP_SET_MODE_FILTER> operation fails and returns "
"B<EACCES> in I<errno>.  This requirement ensures that an unprivileged "
"process cannot apply a malicious filter and then invoke a set-user-ID or "
"other privileged program using B<execve>(2), thus potentially compromising "
"that program.  (Such a malicious filter might, for example, cause an attempt "
"to use B<setuid>(2)  to set the caller's user IDs to nonzero values to "
"instead return 0 without actually making the system call.  Thus, the program "
"might be tricked into retaining superuser privileges in circumstances where "
"it is possible to influence it to do dangerous things because it did not "
"actually drop privileges.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/seccomp.2:184
msgid ""
"If B<prctl>(2)  or B<seccomp>()  is allowed by the attached filter, further "
"filters may be added.  This will increase evaluation time, but allows for "
"further reduction of the attack surface during execution of a thread."
msgstr ""

#. type: Plain text
#: man-pages/man2/seccomp.2:190
msgid ""
"The B<SECCOMP_SET_MODE_FILTER> operation is available only if the kernel is "
"configured with B<CONFIG_SECCOMP_FILTER> enabled."
msgstr ""

#. type: Plain text
#: man-pages/man2/seccomp.2:194
msgid "When I<flags> is 0, this operation is functionally identical to the call:"
msgstr ""

#. type: Plain text
#: man-pages/man2/seccomp.2:198
#, no-wrap
msgid "prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, args);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/seccomp.2:204
msgid "The recognized I<flags> are:"
msgstr ""

#. type: TP
#: man-pages/man2/seccomp.2:205
#, no-wrap
msgid "B<SECCOMP_FILTER_FLAG_TSYNC>"
msgstr ""

#. type: Plain text
#: man-pages/man2/seccomp.2:213
msgid ""
"When adding a new filter, synchronize all other threads of the calling "
"process to the same seccomp filter tree.  A \"filter tree\" is the ordered "
"list of filters attached to a thread.  (Attaching identical filters in "
"separate B<seccomp>()  calls results in different filters from this "
"perspective.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/seccomp.2:221
msgid ""
"If any thread cannot synchronize to the same filter tree, the call will not "
"attach the new seccomp filter, and will fail, returning the first thread ID "
"found that cannot synchronize.  Synchronization will fail if another thread "
"in the same process is in B<SECCOMP_MODE_STRICT> or if it has attached new "
"seccomp filters to itself, diverging from the calling thread's filter tree."
msgstr ""

#. type: TP
#: man-pages/man2/seccomp.2:221
#, no-wrap
msgid "B<SECCOMP_FILTER_FLAG_LOG> (since Linux 4.14)"
msgstr ""

#.  commit e66a39977985b1e69e17c4042cb290768eca9b02
#. type: Plain text
#: man-pages/man2/seccomp.2:231
msgid ""
"All filter return actions except B<SECCOMP_RET_ALLOW> should be logged.  An "
"administrator may override this filter flag by preventing specific actions "
"from being logged via the I</proc/sys/kernel/seccomp/actions_logged> file."
msgstr ""

#. type: TP
#: man-pages/man2/seccomp.2:231
#, no-wrap
msgid "B<SECCOMP_FILTER_FLAG_SPEC_ALLOW> (since Linux 4.17)"
msgstr ""

#.  commit 00a02d0c502a06d15e07b857f8ff921e3e402675
#. type: Plain text
#: man-pages/man2/seccomp.2:235
msgid "Disable Speculative Store Bypass mitigation."
msgstr ""

#. type: TP
#: man-pages/man2/seccomp.2:236
#, no-wrap
msgid "B<SECCOMP_GET_ACTION_AVAIL> (since Linux 4.14)"
msgstr ""

#.  commit d612b1fd8010d0d67b5287fe146b8b55bcbb8655
#. type: Plain text
#: man-pages/man2/seccomp.2:244
msgid ""
"Test to see if an action is supported by the kernel.  This operation is "
"helpful to confirm that the kernel knows of a more recently added filter "
"return action since the kernel treats all unknown actions as "
"B<SECCOMP_RET_KILL_PROCESS>."
msgstr ""

#. type: Plain text
#: man-pages/man2/seccomp.2:250
msgid ""
"The value of I<flags> must be 0, and I<args> must be a pointer to an "
"unsigned 32-bit filter return action."
msgstr ""

#. type: SS
#: man-pages/man2/seccomp.2:250
#, no-wrap
msgid "Filters"
msgstr ""

#. type: Plain text
#: man-pages/man2/seccomp.2:255
msgid ""
"When adding filters via B<SECCOMP_SET_MODE_FILTER>, I<args> points to a "
"filter program:"
msgstr ""

#. type: Plain text
#: man-pages/man2/seccomp.2:263
#, no-wrap
msgid ""
"struct sock_fprog {\n"
"    unsigned short      len;    /* Number of BPF instructions */\n"
"    struct sock_filter *filter; /* Pointer to array of\n"
"                                   BPF instructions */\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/seccomp.2:267
msgid "Each program must contain one or more BPF instructions:"
msgstr ""

#. type: Plain text
#: man-pages/man2/seccomp.2:276
#, no-wrap
msgid ""
"struct sock_filter {            /* Filter block */\n"
"    __u16 code;                 /* Actual filter code */\n"
"    __u8  jt;                   /* Jump true */\n"
"    __u8  jf;                   /* Jump false */\n"
"    __u32 k;                    /* Generic multiuse field */\n"
"};\n"
msgstr ""

#.  Quoting Kees Cook:
#.      If BPF even allows changing the data, it's not copied back to
#.      the syscall when it runs. Anything wanting to do things like
#.      that would need to use ptrace to catch the call and directly
#.      modify the registers before continuing with the call.
#. type: Plain text
#: man-pages/man2/seccomp.2:289
msgid ""
"When executing the instructions, the BPF program operates on the system call "
"information made available (i.e., use the B<BPF_ABS> addressing mode) as a "
"(read-only)  buffer of the following form:"
msgstr ""

#. type: Plain text
#: man-pages/man2/seccomp.2:299
#, no-wrap
msgid ""
"struct seccomp_data {\n"
"    int   nr;                   /* System call number */\n"
"    __u32 arch;                 /* AUDIT_ARCH_* value\n"
"                                   (see E<lt>linux/audit.hE<gt>) */\n"
"    __u64 instruction_pointer;  /* CPU instruction pointer */\n"
"    __u64 args[6];              /* Up to 6 system call arguments */\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/seccomp.2:311
msgid ""
"Because numbering of system calls varies between architectures and some "
"architectures (e.g., x86-64) allow user-space code to use the calling "
"conventions of multiple architectures (and the convention being used may "
"vary over the life of a process that uses B<execve>(2)  to execute binaries "
"that employ the different conventions), it is usually necessary to verify "
"the value of the I<arch> field."
msgstr ""

#. type: Plain text
#: man-pages/man2/seccomp.2:322
msgid ""
"It is strongly recommended to use a whitelisting approach whenever possible "
"because such an approach is more robust and simple.  A blacklist will have "
"to be updated whenever a potentially dangerous system call is added (or a "
"dangerous flag or option if those are blacklisted), and it is often possible "
"to alter the representation of a value without altering its meaning, leading "
"to a blacklist bypass.  See also I<Caveats> below."
msgstr ""

#.  As noted by Dave Drysdale in a note at the end of
#.  https://lwn.net/Articles/604515/
#.      One additional detail to point out for the x32 ABI case:
#.      the syscall number gets a high bit set (__X32_SYSCALL_BIT),
#.      to mark it as an x32 call.
#
#.      If x32 support is included in the kernel, then __SYSCALL_MASK
#.      will have a value that is not all-ones, and this will trigger
#.      an extra instruction in system_call to mask off the extra bit,
#.      so that the syscall table indexing still works.
#. type: Plain text
#: man-pages/man2/seccomp.2:344
msgid ""
"The I<arch> field is not unique for all calling conventions.  The x86-64 ABI "
"and the x32 ABI both use B<AUDIT_ARCH_X86_64> as I<arch>, and they run on "
"the same processors.  Instead, the mask B<__X32_SYSCALL_BIT> is used on the "
"system call number to tell the two ABIs apart."
msgstr ""

#. type: Plain text
#: man-pages/man2/seccomp.2:355
msgid ""
"This means that in order to create a seccomp-based blacklist for system "
"calls performed through the x86-64 ABI, it is necessary to not only check "
"that I<arch> equals B<AUDIT_ARCH_X86_64>, but also to explicitly reject all "
"system calls that contain B<__X32_SYSCALL_BIT> in I<nr>."
msgstr ""

#. type: Plain text
#: man-pages/man2/seccomp.2:369
msgid ""
"The I<instruction_pointer> field provides the address of the "
"machine-language instruction that performed the system call.  This might be "
"useful in conjunction with the use of I</proc/[pid]/maps> to perform checks "
"based on which region (mapping) of the program made the system call.  "
"(Probably, it is wise to lock down the B<mmap>(2)  and B<mprotect>(2)  "
"system calls to prevent the program from subverting such checks.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/seccomp.2:383
msgid ""
"When checking values from I<args> against a blacklist, keep in mind that "
"arguments are often silently truncated before being processed, but after the "
"seccomp check.  For example, this happens if the i386 ABI is used on an "
"x86-64 kernel: although the kernel will normally not look beyond the 32 "
"lowest bits of the arguments, the values of the full 64-bit registers will "
"be present in the seccomp data.  A less surprising example is that if the "
"x86-64 ABI is used to perform a system call that takes an argument of type "
"I<int>, the more-significant half of the argument register is ignored by the "
"system call, but visible in the seccomp data."
msgstr ""

#. type: Plain text
#: man-pages/man2/seccomp.2:392
msgid ""
"A seccomp filter returns a 32-bit value consisting of two parts: the most "
"significant 16 bits (corresponding to the mask defined by the constant "
"B<SECCOMP_RET_ACTION_FULL>)  contain one of the \"action\" values listed "
"below; the least significant 16-bits (defined by the constant "
"B<SECCOMP_RET_DATA>)  are \"data\" to be associated with this return value."
msgstr ""

#.  From an Aug 2015 conversation with Kees Cook where I asked why *all*
#.  filters are applied even if one of the early filters returns
#.  SECCOMP_RET_KILL:
#
#.      It's just because it would be an optimization that would only speed up
#.      the RET_KILL case, but it's the uncommon one and the one that doesn't
#.      benefit meaningfully from such a change (you need to kill the process
#.      really quickly?). We would speed up killing a program at the (albeit
#.      tiny) expense to all other filtered programs. Best to keep the filter
#.      execution logic clear, simple, and as fast as possible for all
#.      filters.
#. type: Plain text
#: man-pages/man2/seccomp.2:416
msgid ""
"If multiple filters exist, they are I<all> executed, in reverse order of "
"their addition to the filter tree\\(emthat is, the most recently installed "
"filter is executed first.  (Note that all filters will be called even if one "
"of the earlier filters returns B<SECCOMP_RET_KILL>.  This is done to "
"simplify the kernel code and to provide a tiny speed-up in the execution of "
"sets of filters by avoiding a check for this uncommon case.)  The return "
"value for the evaluation of a given system call is the first-seen action "
"value of highest precedence (along with its accompanying data)  returned by "
"execution of all of the filters."
msgstr ""

#. type: Plain text
#: man-pages/man2/seccomp.2:419
msgid ""
"In decreasing order of precedence, the action values that may be returned by "
"a seccomp filter are:"
msgstr ""

#. type: TP
#: man-pages/man2/seccomp.2:419
#, no-wrap
msgid "B<SECCOMP_RET_KILL_PROCESS> (since Linux 4.14)"
msgstr ""

#.  commit 4d3b0b05aae9ee9ce0970dc4cc0fb3fad5e85945
#.  commit 0466bdb99e8744bc9befa8d62a317f0fd7fd7421
#. type: Plain text
#: man-pages/man2/seccomp.2:433
msgid ""
"This value results in immediate termination of the process, with a core "
"dump.  The system call is not executed.  By contrast with "
"B<SECCOMP_RET_KILL_THREAD> below, all threads in the thread group are "
"terminated.  (For a discussion of thread groups, see the description of the "
"B<CLONE_THREAD> flag in B<clone>(2).)"
msgstr ""

#. type: Plain text
#: man-pages/man2/seccomp.2:449
msgid ""
"The process terminates I<as though> killed by a B<SIGSYS> signal.  Even if a "
"signal handler has been registered for B<SIGSYS>, the handler will be "
"ignored in this case and the process always terminates.  To a parent process "
"that is waiting on this process (using B<waitpid>(2)  or similar), the "
"returned I<wstatus> will indicate that its child was terminated as though by "
"a B<SIGSYS> signal."
msgstr ""

#. type: TP
#: man-pages/man2/seccomp.2:449
#, no-wrap
msgid "B<SECCOMP_RET_KILL_THREAD> (or B<SECCOMP_RET_KILL>)"
msgstr ""

#. type: Plain text
#: man-pages/man2/seccomp.2:455
msgid ""
"This value results in immediate termination of the thread that made the "
"system call.  The system call is not executed.  Other threads in the same "
"thread group will continue to execute."
msgstr ""

#. type: Plain text
#: man-pages/man2/seccomp.2:464
msgid ""
"The thread terminates I<as though> killed by a B<SIGSYS> signal.  See "
"B<SECCOMP_RET_KILL_PROCESS> above."
msgstr ""

#.  See these commits:
#.  seccomp: dump core when using SECCOMP_RET_KILL
#.     (b25e67161c295c98acda92123b2dd1e7d8642901)
#.  seccomp: Only dump core when single-threaded
#.     (d7276e321ff8a53106a59c85ca46d03e34288893)
#. type: Plain text
#: man-pages/man2/seccomp.2:479
msgid ""
"Before Linux 4.11, any process terminated in this way would not trigger a "
"coredump (even though B<SIGSYS> is documented in B<signal>(7)  as having a "
"default action of termination with a core dump).  Since Linux 4.11, a "
"single-threaded process will dump core if terminated in this way."
msgstr ""

#. type: Plain text
#: man-pages/man2/seccomp.2:487
msgid ""
"With the addition of B<SECCOMP_RET_KILL_PROCESS> in Linux 4.14, "
"B<SECCOMP_RET_KILL_THREAD> was added as a synonym for B<SECCOMP_RET_KILL>, "
"in order to more clearly distinguish the two actions."
msgstr ""

#. type: TP
#: man-pages/man2/seccomp.2:487
#, no-wrap
msgid "B<SECCOMP_RET_TRAP>"
msgstr ""

#. type: Plain text
#: man-pages/man2/seccomp.2:498
msgid ""
"This value results in the kernel sending a thread-directed B<SIGSYS> signal "
"to the triggering thread.  (The system call is not executed.)  Various "
"fields will be set in the I<siginfo_t> structure (see B<sigaction>(2))  "
"associated with signal:"
msgstr ""

#. type: Plain text
#: man-pages/man2/seccomp.2:503
msgid "I<si_signo> will contain B<SIGSYS>."
msgstr ""

#. type: Plain text
#: man-pages/man2/seccomp.2:506
msgid "I<si_call_addr> will show the address of the system call instruction."
msgstr ""

#. type: Plain text
#: man-pages/man2/seccomp.2:511
msgid "I<si_syscall> and I<si_arch> will indicate which system call was attempted."
msgstr ""

#. type: Plain text
#: man-pages/man2/seccomp.2:515
msgid "I<si_code> will contain B<SYS_SECCOMP>."
msgstr ""

#. type: Plain text
#: man-pages/man2/seccomp.2:520
msgid ""
"I<si_errno> will contain the B<SECCOMP_RET_DATA> portion of the filter "
"return value."
msgstr ""

#. type: Plain text
#: man-pages/man2/seccomp.2:529
msgid ""
"The program counter will be as though the system call happened (i.e., the "
"program counter will not point to the system call instruction).  The return "
"value register will contain an architecture-dependent value; if resuming "
"execution, set it to something appropriate for the system call.  (The "
"architecture dependency is because replacing it with B<ENOSYS> could "
"overwrite some useful information.)"
msgstr ""

#. type: TP
#: man-pages/man2/seccomp.2:529
#, no-wrap
msgid "B<SECCOMP_RET_ERRNO>"
msgstr ""

#. type: Plain text
#: man-pages/man2/seccomp.2:536
msgid ""
"This value results in the B<SECCOMP_RET_DATA> portion of the filter's return "
"value being passed to user space as the I<errno> value without executing the "
"system call."
msgstr ""

#. type: TP
#: man-pages/man2/seccomp.2:536
#, no-wrap
msgid "B<SECCOMP_RET_TRACE>"
msgstr ""

#. type: Plain text
#: man-pages/man2/seccomp.2:546
msgid ""
"When returned, this value will cause the kernel to attempt to notify a "
"B<ptrace>(2)-based tracer prior to executing the system call.  If there is "
"no tracer present, the system call is not executed and returns a failure "
"status with I<errno> set to B<ENOSYS>."
msgstr ""

#. type: Plain text
#: man-pages/man2/seccomp.2:557
msgid ""
"A tracer will be notified if it requests B<PTRACE_O_TRACESECCOMP> using "
"I<ptrace(PTRACE_SETOPTIONS)>.  The tracer will be notified of a "
"B<PTRACE_EVENT_SECCOMP> and the B<SECCOMP_RET_DATA> portion of the filter's "
"return value will be available to the tracer via B<PTRACE_GETEVENTMSG>."
msgstr ""

#. type: Plain text
#: man-pages/man2/seccomp.2:564
msgid ""
"The tracer can skip the system call by changing the system call number to "
"-1.  Alternatively, the tracer can change the system call requested by "
"changing the system call to a valid system call number.  If the tracer asks "
"to skip the system call, then the system call will appear to return the "
"value that the tracer puts in the return value register."
msgstr ""

#.  This was changed in ce6526e8afa4.
#.  A related hole, using PTRACE_SYSCALL instead of SECCOMP_RET_TRACE, was
#.  changed in arch-specific commits, e.g. 93e35efb8de4 for X86 and
#.  0f3912fd934c for ARM.
#. type: Plain text
#: man-pages/man2/seccomp.2:578
msgid ""
"Before kernel 4.8, the seccomp check will not be run again after the tracer "
"is notified.  (This means that, on older kernels, seccomp-based sandboxes "
"B<must not> allow use of B<ptrace>(2)\\(emeven of other sandboxed "
"processes\\(emwithout extreme care; ptracers can use this mechanism to "
"escape from the seccomp sandbox.)"
msgstr ""

#. type: TP
#: man-pages/man2/seccomp.2:578
#, no-wrap
msgid "B<SECCOMP_RET_LOG> (since Linux 4.14)"
msgstr ""

#.  commit 59f5cf44a38284eb9e76270c786fb6cc62ef8ac4
#. type: Plain text
#: man-pages/man2/seccomp.2:587
msgid ""
"This value results in the system call being executed after the filter return "
"action is logged.  An administrator may override the logging of this action "
"via the I</proc/sys/kernel/seccomp/actions_logged> file."
msgstr ""

#. type: TP
#: man-pages/man2/seccomp.2:587
#, no-wrap
msgid "B<SECCOMP_RET_ALLOW>"
msgstr ""

#. type: Plain text
#: man-pages/man2/seccomp.2:590
msgid "This value results in the system call being executed."
msgstr ""

#.  commit 4d3b0b05aae9ee9ce0970dc4cc0fb3fad5e85945
#. type: Plain text
#: man-pages/man2/seccomp.2:600
msgid ""
"If an action value other than one of the above is specified, then the filter "
"action is treated as either B<SECCOMP_RET_KILL_PROCESS> (since Linux 4.14)  "
"or B<SECCOMP_RET_KILL_THREAD> (in Linux 4.13 and earlier)."
msgstr ""

#. type: SS
#: man-pages/man2/seccomp.2:600
#, no-wrap
msgid "/proc interfaces"
msgstr ""

#. type: Plain text
#: man-pages/man2/seccomp.2:604
msgid ""
"The files in the directory I</proc/sys/kernel/seccomp> provide additional "
"seccomp information and configuration:"
msgstr ""

#. type: TP
#: man-pages/man2/seccomp.2:604
#, no-wrap
msgid "I<actions_avail> (since Linux 4.14)"
msgstr ""

#.  commit 8e5f1ad116df6b0de65eac458d5e7c318d1c05af
#. type: Plain text
#: man-pages/man2/seccomp.2:611
msgid ""
"A read-only ordered list of seccomp filter return actions in string form.  "
"The ordering, from left-to-right, is in decreasing order of precedence.  The "
"list represents the set of seccomp filter return actions supported by the "
"kernel."
msgstr ""

#. type: TP
#: man-pages/man2/seccomp.2:611
#, no-wrap
msgid "I<actions_logged> (since Linux 4.14)"
msgstr ""

#.  commit 0ddec0fc8900201c0897b87b762b7c420436662f
#. type: Plain text
#: man-pages/man2/seccomp.2:620
msgid ""
"A read-write ordered list of seccomp filter return actions that are allowed "
"to be logged.  Writes to the file do not need to be in ordered form but "
"reads from the file will be ordered in the same way as the I<actions_avail> "
"file."
msgstr ""

#. type: Plain text
#: man-pages/man2/seccomp.2:631
msgid ""
"It is important to note that the value of I<actions_logged> does not prevent "
"certain filter return actions from being logged when the audit subsystem is "
"configured to audit a task.  If the action is not found in the "
"I<actions_logged> file, the final decision on whether to audit the action "
"for that task is ultimately left up to the audit subsystem to decide for all "
"filter return actions other than B<SECCOMP_RET_ALLOW>."
msgstr ""

#. type: Plain text
#: man-pages/man2/seccomp.2:640
msgid ""
"The \"allow\" string is not accepted in the I<actions_logged> file as it is "
"not possible to log B<SECCOMP_RET_ALLOW> actions.  Attempting to write "
"\"allow\" to the file will fail with the error B<EINVAL>."
msgstr ""

#. type: SS
#: man-pages/man2/seccomp.2:640
#, no-wrap
msgid "Audit logging of seccomp actions"
msgstr ""

#.  commit 59f5cf44a38284eb9e76270c786fb6cc62ef8ac4
#.  or auditing could be enabled via the netlink API (AUDIT_SET)
#. type: Plain text
#: man-pages/man2/seccomp.2:652
msgid ""
"Since Linux 4.14, the kernel provides the facility to log the actions "
"returned by seccomp filters in the audit log.  The kernel makes the decision "
"to log an action based on the action type, whether or not the action is "
"present in the I<actions_logged> file, and whether kernel auditing is "
"enabled (e.g., via the kernel boot option I<audit=1>).  The rules are as "
"follows:"
msgstr ""

#. type: Plain text
#: man-pages/man2/seccomp.2:656
msgid "If the action is B<SECCOMP_RET_ALLOW>, the action is not logged."
msgstr ""

#. type: Plain text
#: man-pages/man2/seccomp.2:664
msgid ""
"Otherwise, if the action is either B<SECCOMP_RET_KILL_PROCESS> or "
"B<SECCOMP_RET_KILL_THREAD>, and that action appears in the I<actions_logged> "
"file, the action is logged."
msgstr ""

#. type: Plain text
#: man-pages/man2/seccomp.2:671
msgid ""
"Otherwise, if the filter has requested logging (the "
"B<SECCOMP_FILTER_FLAG_LOG> flag)  and the action appears in the "
"I<actions_logged> file, the action is logged."
msgstr ""

#. type: Plain text
#: man-pages/man2/seccomp.2:675
msgid ""
"Otherwise, if kernel auditing is enabled and the process is being audited "
"(B<autrace>(8)), the action is logged."
msgstr ""

#. type: Plain text
#: man-pages/man2/seccomp.2:677
msgid "Otherwise, the action is not logged."
msgstr ""

#. type: Plain text
#: man-pages/man2/seccomp.2:693
msgid ""
"On success, B<seccomp>()  returns 0.  On error, if "
"B<SECCOMP_FILTER_FLAG_TSYNC> was used, the return value is the ID of the "
"thread that caused the synchronization failure.  (This ID is a kernel thread "
"ID of the type returned by B<clone>(2)  and B<gettid>(2).)  On other errors, "
"-1 is returned, and I<errno> is set to indicate the cause of the error."
msgstr ""

#. type: Plain text
#: man-pages/man2/seccomp.2:696
msgid "B<seccomp>()  can fail for the following reasons:"
msgstr ""

#. type: Plain text
#: man-pages/man2/seccomp.2:704
msgid ""
"The caller did not have the B<CAP_SYS_ADMIN> capability in its user "
"namespace, or had not set I<no_new_privs> before using "
"B<SECCOMP_SET_MODE_FILTER>."
msgstr ""

#. type: Plain text
#: man-pages/man2/seccomp.2:708
msgid "I<args> was not a valid address."
msgstr ""

#. type: Plain text
#: man-pages/man2/seccomp.2:712
msgid ""
"I<operation> is unknown or is not supported by this kernel version or "
"configuration."
msgstr ""

#. type: Plain text
#: man-pages/man2/seccomp.2:718
msgid "The specified I<flags> are invalid for the given I<operation>."
msgstr ""

#. type: Plain text
#: man-pages/man2/seccomp.2:725
msgid ""
"I<operation> included B<BPF_ABS>, but the specified offset was not aligned "
"to a 32-bit boundary or exceeded I<sizeof(struct\\ seccomp_data)>."
msgstr ""

#.  See kernel/seccomp.c::seccomp_may_assign_mode() in 3.18 sources
#. type: Plain text
#: man-pages/man2/seccomp.2:731
msgid ""
"A secure computing mode has already been set, and I<operation> differs from "
"the existing setting."
msgstr ""

#. type: Plain text
#: man-pages/man2/seccomp.2:741
msgid ""
"I<operation> specified B<SECCOMP_SET_MODE_FILTER>, but the filter program "
"pointed to by I<args> was not valid or the length of the filter program was "
"zero or exceeded B<BPF_MAXINSNS> (4096) instructions."
msgstr ""

#.  ENOMEM in kernel/seccomp.c::seccomp_attach_filter() in 3.18 sources
#. type: Plain text
#: man-pages/man2/seccomp.2:754
msgid ""
"The total length of all filter programs attached to the calling thread would "
"exceed B<MAX_INSNS_PER_PATH> (32768) instructions.  Note that for the "
"purposes of calculating this limit, each already existing filter program "
"incurs an overhead penalty of 4 instructions."
msgstr ""

#. type: Plain text
#: man-pages/man2/seccomp.2:761
msgid ""
"I<operation> specified B<SECCOMP_GET_ACTION_AVAIL>, but the kernel does not "
"support the filter return action specified by I<args>."
msgstr ""

#. type: TP
#: man-pages/man2/seccomp.2:761 man-pages/man2/getrlimit.2:548
#: man-pages/man2/kill.2:112 man-pages/man2/set_thread_area.2:159
#: man-pages/man2/sched_setparam.2:116 man-pages/man2/move_pages.2:208
#: man-pages/man2/rt_sigqueueinfo.2:168 man-pages/man2/perf_event_open.2:3295
#: man-pages/man2/ioprio_set.2:190 man-pages/man2/kcmp.2:291
#: man-pages/man2/utimensat.2:402 man-pages/man2/sched_setscheduler.2:165
#: man-pages/man2/sched_setattr.2:321 man-pages/man2/capget.2:219
#: man-pages/man2/quotactl.2:746 man-pages/man2/quotactl.2:750
#: man-pages/man2/quotactl.2:756 man-pages/man2/get_robust_list.2:133
#: man-pages/man2/tkill.2:117 man-pages/man2/ptrace.2:2358
#: man-pages/man2/getpriority.2:150 man-pages/man2/getsid.2:76
#: man-pages/man2/migrate_pages.2:130 man-pages/man2/sched_setaffinity.2:151
#: man-pages/man2/futex.2:1663 man-pages/man2/futex.2:1671
#: man-pages/man2/setpgid.2:241 man-pages/man2/process_vm_readv.2:278
#: man-pages/man2/sched_rr_get_interval.2:90
#, no-wrap
msgid "B<ESRCH>"
msgstr ""

#. type: Plain text
#: man-pages/man2/seccomp.2:765
msgid ""
"Another thread caused a failure during thread sync, but its ID could not be "
"determined."
msgstr ""

#.  FIXME . Add glibc version
#. type: Plain text
#: man-pages/man2/seccomp.2:770
msgid "The B<seccomp>()  system call first appeared in Linux 3.17."
msgstr ""

#. type: Plain text
#: man-pages/man2/seccomp.2:774
msgid "The B<seccomp>()  system call is a nonstandard Linux extension."
msgstr ""

#. type: Plain text
#: man-pages/man2/seccomp.2:779
msgid ""
"Rather than hand-coding seccomp filters as shown in the example below, you "
"may prefer to employ the I<libseccomp> library, which provides a front-end "
"for generating seccomp filters."
msgstr ""

#. type: Plain text
#: man-pages/man2/seccomp.2:786
msgid ""
"The I<Seccomp> field of the I</proc/[pid]/status> file provides a method of "
"viewing the seccomp mode of a process; see B<proc>(5)."
msgstr ""

#. type: Plain text
#: man-pages/man2/seccomp.2:793
msgid ""
"B<seccomp>()  provides a superset of the functionality provided by the "
"B<prctl>(2)  B<PR_SET_SECCOMP> operation (which does not support I<flags>)."
msgstr ""

#. type: Plain text
#: man-pages/man2/seccomp.2:799
msgid ""
"Since Linux 4.4, the B<ptrace>(2)  B<PTRACE_SECCOMP_GET_FILTER> operation "
"can be used to dump a process's seccomp filters."
msgstr ""

#. type: SS
#: man-pages/man2/seccomp.2:799
#, no-wrap
msgid "Architecture support for seccomp BPF"
msgstr ""

#.  Check by grepping for HAVE_ARCH_SECCOMP_FILTER in Kconfig files in
#.  kernel source. Last checked in Linux 4.16-rc source.
#. type: Plain text
#: man-pages/man2/seccomp.2:804
msgid ""
"Architecture support for seccomp BPF filtering is available on the following "
"architectures:"
msgstr ""

#. type: Plain text
#: man-pages/man2/seccomp.2:806
msgid "x86-64, i386, x32 (since Linux 3.5)"
msgstr ""

#. type: Plain text
#: man-pages/man2/seccomp.2:809
msgid "ARM (since Linux 3.8)"
msgstr ""

#. type: Plain text
#: man-pages/man2/seccomp.2:811
msgid "s390 (since Linux 3.8)"
msgstr ""

#. type: Plain text
#: man-pages/man2/seccomp.2:813
msgid "MIPS (since Linux 3.16)"
msgstr ""

#. type: Plain text
#: man-pages/man2/seccomp.2:815
msgid "ARM-64 (since Linux 3.19)"
msgstr ""

#. type: Plain text
#: man-pages/man2/seccomp.2:817
msgid "PowerPC (since Linux 4.3)"
msgstr ""

#. type: Plain text
#: man-pages/man2/seccomp.2:819
msgid "Tile (since Linux 4.3)"
msgstr ""

#.  User mode Linux since Linux 4.6
#. type: Plain text
#: man-pages/man2/seccomp.2:822
msgid "PA-RISC (since Linux 4.6)"
msgstr ""

#. type: SS
#: man-pages/man2/seccomp.2:824 man-pages/man2/vfork.2:234
#, no-wrap
msgid "Caveats"
msgstr ""

#. type: Plain text
#: man-pages/man2/seccomp.2:827
msgid ""
"There are various subtleties to consider when applying seccomp filters to a "
"program, including the following:"
msgstr ""

#. type: Plain text
#: man-pages/man2/seccomp.2:842
msgid ""
"Some traditional system calls have user-space implementations in the "
"B<vdso>(7)  on many architectures.  Notable examples include "
"B<clock_gettime>(2), B<gettimeofday>(2), and B<time>(2).  On such "
"architectures, seccomp filtering for these system calls will have no "
"effect.  (However, there are cases where the B<vdso>(7)  implementations may "
"fall back to invoking the true system call, in which case seccomp filters "
"would see the system call.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/seccomp.2:848
msgid ""
"Seccomp filtering is based on system call numbers.  However, applications "
"typically do not directly invoke system calls, but instead call wrapper "
"functions in the C library which in turn invoke the system calls.  "
"Consequently, one must be aware of the following:"
msgstr ""

#. type: IP
#: man-pages/man2/seccomp.2:849 man-pages/man2/seccomp.2:860
#: man-pages/man2/seccomp.2:865 man-pages/man2/request_key.2:121
#: man-pages/man2/request_key.2:131 man-pages/man2/request_key.2:136
#: man-pages/man2/request_key.2:141 man-pages/man2/request_key.2:146
#: man-pages/man2/request_key.2:152 man-pages/man2/keyctl.2:1704
#: man-pages/man2/keyctl.2:1710 man-pages/man2/keyctl.2:1717
#: man-pages/man2/keyctl.2:1723 man-pages/man2/keyctl.2:1731
#: man-pages/man2/quotactl.2:772 man-pages/man2/quotactl.2:777
#: man-pages/man2/quotactl.2:782 man-pages/man2/syscall.2:252
#: man-pages/man2/syscall.2:259 man-pages/man2/ptrace.2:2563
#: man-pages/man2/ptrace.2:2569 man-pages/man2/ptrace.2:2610
#: man-pages/man2/ptrace.2:2615 man-pages/man2/semop.2:162
#: man-pages/man2/semop.2:167 man-pages/man2/semop.2:175
#: man-pages/man2/semop.2:227 man-pages/man2/semop.2:232
#: man-pages/man2/semop.2:239
#, no-wrap
msgid "\\(bu"
msgstr ""

#. type: Plain text
#: man-pages/man2/seccomp.2:860
msgid ""
"The glibc wrappers for some traditional system calls may actually employ "
"system calls with different names in the kernel.  For example, the "
"B<exit>(2)  wrapper function actually employs the B<exit_group>(2)  system "
"call, and the B<fork>(2)  wrapper function actually calls B<clone>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/seccomp.2:865
msgid ""
"The behavior of wrapper functions may vary across architectures, according "
"to the range of system calls provided on those architectures.  In other "
"words, the same wrapper function may invoke different system calls on "
"different architectures."
msgstr ""

#. type: Plain text
#: man-pages/man2/seccomp.2:873
msgid ""
"Finally, the behavior of wrapper functions can change across glibc "
"versions.  For example, in older versions, the glibc wrapper function for "
"B<open>(2)  invoked the system call of the same name, but starting in glibc "
"2.26, the implementation switched to calling B<openat>(2)  on all "
"architectures."
msgstr ""

#. type: Plain text
#: man-pages/man2/seccomp.2:881
msgid ""
"The consequence of the above points is that it may be necessary to filter "
"for a system call other than might be expected.  Various manual pages in "
"Section 2 provide helpful details about the differences between wrapper "
"functions and the underlying system calls in subsections entitled I<C "
"library/kernel differences>."
msgstr ""

#. type: Plain text
#: man-pages/man2/seccomp.2:889
msgid ""
"Furthermore, note that the application of seccomp filters even risks causing "
"bugs in an application, when the filters cause unexpected failures for "
"legitimate operations that the application might need to perform.  Such bugs "
"may not easily be discovered when testing the seccomp filters if the bugs "
"occur in rarely used application code paths."
msgstr ""

#. type: SS
#: man-pages/man2/seccomp.2:889
#, no-wrap
msgid "Seccomp-specific BPF details"
msgstr ""

#. type: Plain text
#: man-pages/man2/seccomp.2:891
msgid "Note the following BPF details specific to seccomp filters:"
msgstr ""

#. type: Plain text
#: man-pages/man2/seccomp.2:899
msgid ""
"The B<BPF_H> and B<BPF_B> size modifiers are not supported: all operations "
"must load and store (4-byte) words (B<BPF_W>)."
msgstr ""

#. type: Plain text
#: man-pages/man2/seccomp.2:905
msgid ""
"To access the contents of the I<seccomp_data> buffer, use the B<BPF_ABS> "
"addressing mode modifier."
msgstr ""

#. type: Plain text
#: man-pages/man2/seccomp.2:912
msgid ""
"The B<BPF_LEN> addressing mode modifier yields an immediate mode operand "
"whose value is the size of the I<seccomp_data> buffer."
msgstr ""

#. type: Plain text
#: man-pages/man2/seccomp.2:918
msgid ""
"The program below accepts four or more arguments.  The first three arguments "
"are a system call number, a numeric architecture identifier, and an error "
"number.  The program uses these values to construct a BPF filter that is "
"used at run time to perform the following checks:"
msgstr ""

#. type: IP
#: man-pages/man2/seccomp.2:918 man-pages/man2/request_key.2:272
#: man-pages/man2/syscall.2:213 man-pages/man2/syscall.2:345
#, no-wrap
msgid "[1]"
msgstr ""

#. type: Plain text
#: man-pages/man2/seccomp.2:922
msgid ""
"If the program is not running on the specified architecture, the BPF filter "
"causes system calls to fail with the error B<ENOSYS>."
msgstr ""

#. type: IP
#: man-pages/man2/seccomp.2:922 man-pages/man2/request_key.2:276
#: man-pages/man2/syscall.2:229
#, no-wrap
msgid "[2]"
msgstr ""

#. type: Plain text
#: man-pages/man2/seccomp.2:927
msgid ""
"If the program attempts to execute the system call with the specified "
"number, the BPF filter causes the system call to fail, with I<errno> being "
"set to the specified error number."
msgstr ""

#. type: Plain text
#: man-pages/man2/seccomp.2:936
msgid ""
"The remaining command-line arguments specify the pathname and additional "
"arguments of a program that the example program should attempt to execute "
"using B<execv>(3)  (a library function that employs the B<execve>(2)  system "
"call).  Some example runs of the program are shown below."
msgstr ""

#. type: Plain text
#: man-pages/man2/seccomp.2:940
msgid ""
"First, we display the architecture that we are running on (x86-64)  and then "
"construct a shell function that looks up system call numbers on this "
"architecture:"
msgstr ""

#. type: Plain text
#: man-pages/man2/seccomp.2:949
#, no-wrap
msgid ""
"$ B<uname -m>\n"
"x86_64\n"
"$ B<syscall_nr() {\n"
"    cat /usr/src/linux/arch/x86/syscalls/syscall_64.tbl | \\e\n"
"    awk '$2 != \"x32\" && $3 == \"'$1'\" { print $1 }'\n"
"}>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/seccomp.2:956
msgid ""
"When the BPF filter rejects a system call (case [2] above), it causes the "
"system call to fail with the error number specified on the command line.  In "
"the experiments shown here, we'll use error number 99:"
msgstr ""

#. type: Plain text
#: man-pages/man2/seccomp.2:961
#, no-wrap
msgid ""
"$ B<errno 99>\n"
"EADDRNOTAVAIL 99 Cannot assign requested address\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/seccomp.2:969
msgid ""
"In the following example, we attempt to run the command B<whoami>(1), but "
"the BPF filter rejects the B<execve>(2)  system call, so that the command is "
"not even executed:"
msgstr ""

#. type: Plain text
#: man-pages/man2/seccomp.2:980
#, no-wrap
msgid ""
"$ B<syscall_nr execve>\n"
"59\n"
"$ B<./a.out>\n"
"Usage: ./a.out E<lt>syscall_nrE<gt> E<lt>archE<gt> E<lt>errnoE<gt> "
"E<lt>progE<gt> [E<lt>argsE<gt>]\n"
"Hint for E<lt>archE<gt>: AUDIT_ARCH_I386: 0x40000003\n"
"                 AUDIT_ARCH_X86_64: 0xC000003E\n"
"$ B<./a.out 59 0xC000003E 99 /bin/whoami>\n"
"execv: Cannot assign requested address\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/seccomp.2:988
msgid ""
"In the next example, the BPF filter rejects the B<write>(2)  system call, so "
"that, although it is successfully started, the B<whoami>(1)  command is not "
"able to write output:"
msgstr ""

#. type: Plain text
#: man-pages/man2/seccomp.2:994
#, no-wrap
msgid ""
"$ B<syscall_nr write>\n"
"1\n"
"$ B<./a.out 1 0xC000003E 99 /bin/whoami>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/seccomp.2:1001
msgid ""
"In the final example, the BPF filter rejects a system call that is not used "
"by the B<whoami>(1)  command, so it is able to successfully execute and "
"produce output:"
msgstr ""

#. type: Plain text
#: man-pages/man2/seccomp.2:1008
#, no-wrap
msgid ""
"$ B<syscall_nr preadv>\n"
"295\n"
"$ B<./a.out 295 0xC000003E 99 /bin/whoami>\n"
"cecilia\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/seccomp.2:1021
#, no-wrap
msgid ""
"#include E<lt>errno.hE<gt>\n"
"#include E<lt>stddef.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>linux/audit.hE<gt>\n"
"#include E<lt>linux/filter.hE<gt>\n"
"#include E<lt>linux/seccomp.hE<gt>\n"
"#include E<lt>sys/prctl.hE<gt>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/seccomp.2:1023
#, no-wrap
msgid "#define X32_SYSCALL_BIT 0x40000000\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/seccomp.2:1028
#, no-wrap
msgid ""
"static int\n"
"install_filter(int syscall_nr, int t_arch, int f_errno)\n"
"{\n"
"    unsigned int upper_nr_limit = 0xffffffff;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/seccomp.2:1034
#, no-wrap
msgid ""
"    /* Assume that AUDIT_ARCH_X86_64 means the normal x86-64 ABI\n"
"       (in the x32 ABI, all system calls have bit 30 set in the\n"
"       'nr' field, meaning the numbers are E<gt>= X32_SYSCALL_BIT) */\n"
"    if (t_arch == AUDIT_ARCH_X86_64)\n"
"        upper_nr_limit = X32_SYSCALL_BIT - 1;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/seccomp.2:1040
#, no-wrap
msgid ""
"    struct sock_filter filter[] = {\n"
"        /* [0] Load architecture from 'seccomp_data' buffer into\n"
"               accumulator */\n"
"        BPF_STMT(BPF_LD | BPF_W | BPF_ABS,\n"
"                 (offsetof(struct seccomp_data, arch))),\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/seccomp.2:1044
#, no-wrap
msgid ""
"        /* [1] Jump forward 5 instructions if architecture does not\n"
"               match 't_arch' */\n"
"        BPF_JUMP(BPF_JMP | BPF_JEQ | BPF_K, t_arch, 0, 5),\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/seccomp.2:1049
#, no-wrap
msgid ""
"        /* [2] Load system call number from 'seccomp_data' buffer into\n"
"               accumulator */\n"
"        BPF_STMT(BPF_LD | BPF_W | BPF_ABS,\n"
"                 (offsetof(struct seccomp_data, nr))),\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/seccomp.2:1054
#, no-wrap
msgid ""
"        /* [3] Check ABI - only needed for x86-64 in blacklist use\n"
"               cases.  Use BPF_JGT instead of checking against the bit\n"
"               mask to avoid having to reload the syscall number. */\n"
"        BPF_JUMP(BPF_JMP | BPF_JGT | BPF_K, upper_nr_limit, 3, 0),\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/seccomp.2:1058
#, no-wrap
msgid ""
"        /* [4] Jump forward 1 instruction if system call number\n"
"               does not match 'syscall_nr' */\n"
"        BPF_JUMP(BPF_JMP | BPF_JEQ | BPF_K, syscall_nr, 0, 1),\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/seccomp.2:1063
#, no-wrap
msgid ""
"        /* [5] Matching architecture and system call: don't execute\n"
"\t       the system call, and return 'f_errno' in 'errno' */\n"
"        BPF_STMT(BPF_RET | BPF_K,\n"
"                 SECCOMP_RET_ERRNO | (f_errno & SECCOMP_RET_DATA)),\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/seccomp.2:1067
#, no-wrap
msgid ""
"        /* [6] Destination of system call number mismatch: allow other\n"
"               system calls */\n"
"        BPF_STMT(BPF_RET | BPF_K, SECCOMP_RET_ALLOW),\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/seccomp.2:1071
#, no-wrap
msgid ""
"        /* [7] Destination of architecture mismatch: kill task */\n"
"        BPF_STMT(BPF_RET | BPF_K, SECCOMP_RET_KILL),\n"
"    };\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/seccomp.2:1076
#, no-wrap
msgid ""
"    struct sock_fprog prog = {\n"
"        .len = (unsigned short) (sizeof(filter) / sizeof(filter[0])),\n"
"        .filter = filter,\n"
"    };\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/seccomp.2:1081
#, no-wrap
msgid ""
"    if (seccomp(SECCOMP_SET_MODE_FILTER, 0, &prog)) {\n"
"        perror(\"seccomp\");\n"
"        return 1;\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/seccomp.2:1084 man-pages/man2/membarrier.2:370
#: man-pages/man2/bpf.2:1009
#, no-wrap
msgid ""
"    return 0;\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/seccomp.2:1096
#, no-wrap
msgid ""
"int\n"
"main(int argc, char **argv)\n"
"{\n"
"    if (argc E<lt> 5) {\n"
"        fprintf(stderr, \"Usage: \"\n"
"                \"%s E<lt>syscall_nrE<gt> E<lt>archE<gt> E<lt>errnoE<gt> "
"E<lt>progE<gt> [E<lt>argsE<gt>]\\en\"\n"
"                \"Hint for E<lt>archE<gt>: AUDIT_ARCH_I386: 0x%X\\en\"\n"
"                \"                 AUDIT_ARCH_X86_64: 0x%X\\en\"\n"
"                \"\\en\", argv[0], AUDIT_ARCH_I386, AUDIT_ARCH_X86_64);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/seccomp.2:1101
#, no-wrap
msgid ""
"    if (prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0)) {\n"
"        perror(\"prctl\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/seccomp.2:1106
#, no-wrap
msgid ""
"    if (install_filter(strtol(argv[1], NULL, 0),\n"
"                       strtol(argv[2], NULL, 0),\n"
"                       strtol(argv[3], NULL, 0)))\n"
"        exit(EXIT_FAILURE);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/seccomp.2:1111
#, no-wrap
msgid ""
"    execv(argv[4], &argv[4]);\n"
"    perror(\"execv\");\n"
"    exit(EXIT_FAILURE);\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/seccomp.2:1122
msgid ""
"B<bpfc>(1), B<strace>(1), B<bpf>(2), B<prctl>(2), B<ptrace>(2), "
"B<sigaction>(2), B<proc>(5), B<signal>(7), B<socket>(7)"
msgstr ""

#. type: Plain text
#: man-pages/man2/seccomp.2:1132
msgid ""
"Various pages from the I<libseccomp> library, including: "
"B<scmp_sys_resolver>(1), B<seccomp_init>(3), B<seccomp_load>(3), "
"B<seccomp_rule_add>(3), and B<seccomp_export_bpf>(3)."
msgstr ""

#.  commit c061f33f35be0ccc80f4b8e0aea5dfd2ed7e01a3
#. type: Plain text
#: man-pages/man2/seccomp.2:1141
msgid ""
"The kernel source files I<Documentation/networking/filter.txt> and "
"I<Documentation/userspace-api/seccomp_filter.rst> (or "
"I<Documentation/prctl/seccomp_filter.txt> before Linux 4.13)."
msgstr ""

#. type: Plain text
#: man-pages/man2/seccomp.2:1146
msgid ""
"McCanne, S.\\& and Jacobson, V.\\& (1992)  I<The BSD Packet Filter: A New "
"Architecture for User-level Packet Capture>, Proceedings of the USENIX "
"Winter 1993 Conference E<.UR http://www.tcpdump.org/papers/bpf-usenix93.pdf> "
"E<.UE>"
msgstr ""

#. type: TH
#: man-pages/man2/getrlimit.2:64
#, no-wrap
msgid "GETRLIMIT"
msgstr ""

#. type: Plain text
#: man-pages/man2/getrlimit.2:67
msgid "getrlimit, setrlimit, prlimit - get/set resource limits"
msgstr ""

#. type: Plain text
#: man-pages/man2/getrlimit.2:69 man-pages/man2/getrusage.2:44
#: man-pages/man2/getpriority.2:50
msgid "B<#include E<lt>sys/time.hE<gt>>"
msgstr ""

#. type: Plain text
#: man-pages/man2/getrlimit.2:71 man-pages/man2/getrusage.2:46
#: man-pages/man2/getpriority.2:52
msgid "B<#include E<lt>sys/resource.hE<gt>>"
msgstr ""

#. type: Plain text
#: man-pages/man2/getrlimit.2:73
msgid "B<int getrlimit(int >I<resource>B<, struct rlimit *>I<rlim>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/getrlimit.2:75
msgid "B<int setrlimit(int >I<resource>B<, const struct rlimit *>I<rlim>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/getrlimit.2:78
msgid ""
"B<int prlimit(pid_t >I<pid>B<, int >I<resource>B<, const struct rlimit "
"*>I<new_limit>B<,>"
msgstr ""

#. type: Plain text
#: man-pages/man2/getrlimit.2:80
msgid "B< struct rlimit *>I<old_limit>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/getrlimit.2:84 man-pages/man2/kill.2:58
#: man-pages/man2/acct.2:46 man-pages/man2/mknod.2:37
#: man-pages/man2/timer_settime.2:45 man-pages/man2/sigaction.2:63
#: man-pages/man2/rename.2:56 man-pages/man2/truncate.2:58
#: man-pages/man2/open.2:73 man-pages/man2/select_tut.2:64
#: man-pages/man2/chroot.2:44 man-pages/man2/seteuid.2:44
#: man-pages/man2/setreuid.2:61 man-pages/man2/clock_nanosleep.2:44
#: man-pages/man2/access.2:62 man-pages/man2/chmod.2:53
#: man-pages/man2/chdir.2:46 man-pages/man2/stime.2:41
#: man-pages/man2/readv.2:59 man-pages/man2/unlink.2:51
#: man-pages/man2/symlink.2:52 man-pages/man2/getdomainname.2:42
#: man-pages/man2/nanosleep.2:45 man-pages/man2/sigwaitinfo.2:42
#: man-pages/man2/timer_delete.2:41 man-pages/man2/brk.2:42
#: man-pages/man2/utimensat.2:43 man-pages/man2/nice.2:42
#: man-pages/man2/chown.2:59 man-pages/man2/madvise.2:46
#: man-pages/man2/gettimeofday.2:56 man-pages/man2/mincore.2:47
#: man-pages/man2/sigprocmask.2:51 man-pages/man2/timer_getoverrun.2:41
#: man-pages/man2/futimesat.2:41 man-pages/man2/_exit.2:44
#: man-pages/man2/posix_fadvise.2:44 man-pages/man2/gethostname.2:45
#: man-pages/man2/stat.2:64 man-pages/man2/select.2:70 man-pages/man2/link.2:51
#: man-pages/man2/getgroups.2:49 man-pages/man2/readlink.2:64
#: man-pages/man2/getpagesize.2:36 man-pages/man2/wait.2:69
#: man-pages/man2/vhangup.2:39 man-pages/man2/mkdir.2:31
#: man-pages/man2/getsid.2:40 man-pages/man2/wait4.2:53
#: man-pages/man2/sync.2:49 man-pages/man2/fsync.2:51
#: man-pages/man2/sigaltstack.2:38 man-pages/man2/sigsuspend.2:40
#: man-pages/man2/semop.2:53 man-pages/man2/vfork.2:42
#: man-pages/man2/clock_getres.2:47 man-pages/man2/timer_create.2:43
#: man-pages/man2/setpgid.2:73 man-pages/man2/process_vm_readv.2:54
#: man-pages/man2/pread.2:40 man-pages/man2/sigpending.2:40
msgid "Feature Test Macro Requirements for glibc (see B<feature_test_macros>(7)):"
msgstr ""

#. type: Plain text
#: man-pages/man2/getrlimit.2:88
msgid "B<prlimit>(): _GNU_SOURCE"
msgstr ""

#. type: Plain text
#: man-pages/man2/getrlimit.2:97
msgid ""
"The B<getrlimit>()  and B<setrlimit>()  system calls get and set resource "
"limits.  Each resource has an associated soft and hard limit, as defined by "
"the I<rlimit> structure:"
msgstr ""

#. type: Plain text
#: man-pages/man2/getrlimit.2:104
#, no-wrap
msgid ""
"struct rlimit {\n"
"    rlim_t rlim_cur;  /* Soft limit */\n"
"    rlim_t rlim_max;  /* Hard limit (ceiling for rlim_cur) */\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/getrlimit.2:116
msgid ""
"The soft limit is the value that the kernel enforces for the corresponding "
"resource.  The hard limit acts as a ceiling for the soft limit: an "
"unprivileged process may set only its soft limit to a value in the range "
"from 0 up to the hard limit, and (irreversibly) lower its hard limit.  A "
"privileged process (under Linux: one with the B<CAP_SYS_RESOURCE> capability "
"in the initial user namespace)  may make arbitrary changes to either limit "
"value."
msgstr ""

#. type: Plain text
#: man-pages/man2/getrlimit.2:123
msgid ""
"The value B<RLIM_INFINITY> denotes no limit on a resource (both in the "
"structure returned by B<getrlimit>()  and in the structure passed to "
"B<setrlimit>())."
msgstr ""

#. type: Plain text
#: man-pages/man2/getrlimit.2:127
msgid "The I<resource> argument must be one of:"
msgstr ""

#. type: TP
#: man-pages/man2/getrlimit.2:127
#, no-wrap
msgid "B<RLIMIT_AS>"
msgstr ""

#.  since 2.0.27 / 2.1.12
#. type: Plain text
#: man-pages/man2/getrlimit.2:149
msgid ""
"This is the maximum size of the process's virtual memory (address space).  "
"The limit is specified in bytes, and is rounded down to the system page "
"size.  This limit affects calls to B<brk>(2), B<mmap>(2), and B<mremap>(2), "
"which fail with the error B<ENOMEM> upon exceeding this limit.  In addition, "
"automatic stack expansion fails (and generates a B<SIGSEGV> that kills the "
"process if no alternate stack has been made available via "
"B<sigaltstack>(2)).  Since the value is a I<long>, on machines with a 32-bit "
"I<long> either this limit is at most 2\\ GiB, or this resource is unlimited."
msgstr ""

#. type: TP
#: man-pages/man2/getrlimit.2:149
#, no-wrap
msgid "B<RLIMIT_CORE>"
msgstr ""

#. type: Plain text
#: man-pages/man2/getrlimit.2:158
msgid ""
"This is the maximum size of a I<core> file (see B<core>(5))  in bytes that "
"the process may dump.  When 0 no core dump files are created.  When nonzero, "
"larger dumps are truncated to this size."
msgstr ""

#. type: TP
#: man-pages/man2/getrlimit.2:158
#, no-wrap
msgid "B<RLIMIT_CPU>"
msgstr ""

#. type: Plain text
#: man-pages/man2/getrlimit.2:179
msgid ""
"This is a limit, in seconds, on the amount of CPU time that the process can "
"consume.  When the process reaches the soft limit, it is sent a B<SIGXCPU> "
"signal.  The default action for this signal is to terminate the process.  "
"However, the signal can be caught, and the handler can return control to the "
"main program.  If the process continues to consume CPU time, it will be sent "
"B<SIGXCPU> once per second until the hard limit is reached, at which time it "
"is sent B<SIGKILL>.  (This latter point describes Linux behavior.  "
"Implementations vary in how they treat processes which continue to consume "
"CPU time after reaching the soft limit.  Portable applications that need to "
"catch this signal should perform an orderly termination upon first receipt "
"of B<SIGXCPU>.)"
msgstr ""

#. type: TP
#: man-pages/man2/getrlimit.2:179
#, no-wrap
msgid "B<RLIMIT_DATA>"
msgstr ""

#.  commits 84638335900f1995495838fe1bd4870c43ec1f67
#.  ("mm: rework virtual memory accounting"),
#.  f4fcd55841fc9e46daac553b39361572453c2b88
#.  (mm: enable RLIMIT_DATA by default with workaround for valgrind).
#. type: Plain text
#: man-pages/man2/getrlimit.2:197
msgid ""
"This is the maximum size of the process's data segment (initialized data, "
"uninitialized data, and heap).  The limit is specified in bytes, and is "
"rounded down to the system page size.  This limit affects calls to "
"B<brk>(2), B<sbrk>(2), and (since Linux 4.7)  B<mmap>(2), which fail with "
"the error B<ENOMEM> upon encountering the soft limit of this resource."
msgstr ""

#. type: TP
#: man-pages/man2/getrlimit.2:197
#, no-wrap
msgid "B<RLIMIT_FSIZE>"
msgstr ""

#. type: Plain text
#: man-pages/man2/getrlimit.2:209
msgid ""
"This is the maximum size in bytes of files that the process may create.  "
"Attempts to extend a file beyond this limit result in delivery of a "
"B<SIGXFSZ> signal.  By default, this signal terminates a process, but a "
"process can catch this signal instead, in which case the relevant system "
"call (e.g., B<write>(2), B<truncate>(2))  fails with the error B<EFBIG>."
msgstr ""

#. type: TP
#: man-pages/man2/getrlimit.2:209
#, no-wrap
msgid "B<RLIMIT_LOCKS> (early Linux 2.4 only)"
msgstr ""

#.  to be precise: Linux 2.4.0-test9; no longer in 2.4.25 / 2.5.65
#. type: Plain text
#: man-pages/man2/getrlimit.2:217
msgid ""
"This is a limit on the combined number of B<flock>(2)  locks and B<fcntl>(2)  "
"leases that this process may establish."
msgstr ""

#. type: TP
#: man-pages/man2/getrlimit.2:217
#, no-wrap
msgid "B<RLIMIT_MEMLOCK>"
msgstr ""

#. type: Plain text
#: man-pages/man2/getrlimit.2:249
msgid ""
"This is the maximum number of bytes of memory that may be locked into RAM.  "
"This limit is in effect rounded down to the nearest multiple of the system "
"page size.  This limit affects B<mlock>(2), B<mlockall>(2), and the "
"B<mmap>(2)  B<MAP_LOCKED> operation.  Since Linux 2.6.9, it also affects the "
"B<shmctl>(2)  B<SHM_LOCK> operation, where it sets a maximum on the total "
"bytes in shared memory segments (see B<shmget>(2))  that may be locked by "
"the real user ID of the calling process.  The B<shmctl>(2)  B<SHM_LOCK> "
"locks are accounted for separately from the per-process memory locks "
"established by B<mlock>(2), B<mlockall>(2), and B<mmap>(2)  B<MAP_LOCKED>; a "
"process can lock bytes up to this limit in each of these two categories."
msgstr ""

#. type: Plain text
#: man-pages/man2/getrlimit.2:255
msgid ""
"In Linux kernels before 2.6.9, this limit controlled the amount of memory "
"that could be locked by a privileged process.  Since Linux 2.6.9, no limits "
"are placed on the amount of memory that a privileged process may lock, and "
"this limit instead governs the amount of memory that an unprivileged process "
"may lock."
msgstr ""

#. type: TP
#: man-pages/man2/getrlimit.2:255
#, no-wrap
msgid "B<RLIMIT_MSGQUEUE> (since Linux 2.6.8)"
msgstr ""

#. type: Plain text
#: man-pages/man2/getrlimit.2:263
msgid ""
"This is a limit on the number of bytes that can be allocated for POSIX "
"message queues for the real user ID of the calling process.  This limit is "
"enforced for B<mq_open>(3).  Each message queue that the user creates counts "
"(until it is removed)  against this limit according to the formula:"
msgstr ""

#. type: Plain text
#: man-pages/man2/getrlimit.2:265
#, no-wrap
msgid "    Since Linux 3.5:\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/getrlimit.2:273
#, no-wrap
msgid ""
"        bytes = attr.mq_maxmsg * sizeof(struct msg_msg) +\n"
"                min(attr.mq_maxmsg, MQ_PRIO_MAX) *\n"
"                      sizeof(struct posix_msg_tree_node)+\n"
"                                /* For overhead */\n"
"                attr.mq_maxmsg * attr.mq_msgsize;\n"
"                                /* For message data */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/getrlimit.2:276
#, no-wrap
msgid "    Linux 3.4 and earlier:\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/getrlimit.2:282
#, no-wrap
msgid ""
"        bytes = attr.mq_maxmsg * sizeof(struct msg_msg *) +\n"
"                                /* For overhead */\n"
"                attr.mq_maxmsg * attr.mq_msgsize;\n"
"                                /* For message data */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/getrlimit.2:295
msgid ""
"where I<attr> is the I<mq_attr> structure specified as the fourth argument "
"to B<mq_open>(3), and the I<msg_msg> and I<posix_msg_tree_node> structures "
"are kernel-internal structures."
msgstr ""

#. type: Plain text
#: man-pages/man2/getrlimit.2:301
msgid ""
"The \"overhead\" addend in the formula accounts for overhead bytes required "
"by the implementation and ensures that the user cannot create an unlimited "
"number of zero-length messages (such messages nevertheless each consume some "
"system memory for bookkeeping overhead)."
msgstr ""

#. type: TP
#: man-pages/man2/getrlimit.2:301
#, no-wrap
msgid "B<RLIMIT_NICE> (since Linux 2.6.12, but see BUGS below)"
msgstr ""

#. type: Plain text
#: man-pages/man2/getrlimit.2:320
msgid ""
"This specifies a ceiling to which the process's nice value can be raised "
"using B<setpriority>(2)  or B<nice>(2).  The actual ceiling for the nice "
"value is calculated as I<20\\ -\\ rlim_cur>.  The useful range for this "
"limit is thus from 1 (corresponding to a nice value of 19) to 40 "
"(corresponding to a nice value of -20).  This unusual choice of range was "
"necessary because negative numbers cannot be specified as resource limit "
"values, since they typically have special meanings.  For example, "
"B<RLIM_INFINITY> typically is the same as -1.  For more detail on the nice "
"value, see B<sched>(7)."
msgstr ""

#. type: TP
#: man-pages/man2/getrlimit.2:320
#, no-wrap
msgid "B<RLIMIT_NOFILE>"
msgstr ""

#. type: Plain text
#: man-pages/man2/getrlimit.2:334
msgid ""
"This specifies a value one greater than the maximum file descriptor number "
"that can be opened by this process.  Attempts (B<open>(2), B<pipe>(2), "
"B<dup>(2), etc.)  to exceed this limit yield the error B<EMFILE>.  "
"(Historically, this limit was named B<RLIMIT_OFILE> on BSD.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/getrlimit.2:346
msgid ""
"Since Linux 4.5, this limit also defines the maximum number of file "
"descriptors that an unprivileged process (one without the "
"B<CAP_SYS_RESOURCE> capability) may have \"in flight\" to other processes, "
"by being passed across UNIX domain sockets.  This limit applies to the "
"B<sendmsg>(2)  system call.  For further details, see B<unix>(7)."
msgstr ""

#. type: TP
#: man-pages/man2/getrlimit.2:346
#, no-wrap
msgid "B<RLIMIT_NPROC>"
msgstr ""

#. type: Plain text
#: man-pages/man2/getrlimit.2:356
msgid ""
"This is a limit on the number of extant process (or, more precisely on "
"Linux, threads)  for the real user ID of the calling process.  So long as "
"the current number of processes belonging to this process's real user ID is "
"greater than or equal to this limit, B<fork>(2)  fails with the error "
"B<EAGAIN>."
msgstr ""

#. type: Plain text
#: man-pages/man2/getrlimit.2:364
msgid ""
"The B<RLIMIT_NPROC> limit is not enforced for processes that have either the "
"B<CAP_SYS_ADMIN> or the B<CAP_SYS_RESOURCE> capability."
msgstr ""

#. type: TP
#: man-pages/man2/getrlimit.2:364
#, no-wrap
msgid "B<RLIMIT_RSS>"
msgstr ""

#.  As at kernel 2.6.12, this limit still does nothing in 2.6 though
#.  talk of making it do something has surfaced from time to time in LKML
#.        -- MTK, Jul 05
#. type: Plain text
#: man-pages/man2/getrlimit.2:376
msgid ""
"This is a limit (in bytes) on the process's resident set (the number of "
"virtual pages resident in RAM).  This limit has effect only in Linux 2.4.x, "
"x E<lt> 30, and there affects only calls to B<madvise>(2)  specifying "
"B<MADV_WILLNEED>."
msgstr ""

#. type: TP
#: man-pages/man2/getrlimit.2:376
#, no-wrap
msgid "B<RLIMIT_RTPRIO> (since Linux 2.6.12, but see BUGS)"
msgstr ""

#. type: Plain text
#: man-pages/man2/getrlimit.2:383
msgid ""
"This specifies a ceiling on the real-time priority that may be set for this "
"process using B<sched_setscheduler>(2)  and B<sched_setparam>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/getrlimit.2:386 man-pages/man2/getrlimit.2:415
msgid "For further details on real-time scheduling policies, see B<sched>(7)"
msgstr ""

#. type: TP
#: man-pages/man2/getrlimit.2:386
#, no-wrap
msgid "B<RLIMIT_RTTIME> (since Linux 2.6.25)"
msgstr ""

#. type: Plain text
#: man-pages/man2/getrlimit.2:398
msgid ""
"This is a limit (in microseconds)  on the amount of CPU time that a process "
"scheduled under a real-time scheduling policy may consume without making a "
"blocking system call.  For the purpose of this limit, each time a process "
"makes a blocking system call, the count of its consumed CPU time is reset to "
"zero.  The CPU time count is not reset if the process continues trying to "
"use the CPU but is preempted, its time slice expires, or it calls "
"B<sched_yield>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/getrlimit.2:409
msgid ""
"Upon reaching the soft limit, the process is sent a B<SIGXCPU> signal.  If "
"the process catches or ignores this signal and continues consuming CPU time, "
"then B<SIGXCPU> will be generated once each second until the hard limit is "
"reached, at which point the process is sent a B<SIGKILL> signal."
msgstr ""

#. type: Plain text
#: man-pages/man2/getrlimit.2:412
msgid ""
"The intended use of this limit is to stop a runaway real-time process from "
"locking up the system."
msgstr ""

#. type: TP
#: man-pages/man2/getrlimit.2:415
#, no-wrap
msgid "B<RLIMIT_SIGPENDING> (since Linux 2.6.8)"
msgstr ""

#.  This replaces the /proc/sys/kernel/rtsig-max system-wide limit
#.  that was present in kernels <= 2.6.7.  MTK Dec 04
#. type: Plain text
#: man-pages/man2/getrlimit.2:429
msgid ""
"This is a limit on the number of signals that may be queued for the real "
"user ID of the calling process.  Both standard and real-time signals are "
"counted for the purpose of checking this limit.  However, the limit is "
"enforced only for B<sigqueue>(3); it is always possible to use B<kill>(2)  "
"to queue one instance of any of the signals that are not already queued to "
"the process."
msgstr ""

#. type: TP
#: man-pages/man2/getrlimit.2:429
#, no-wrap
msgid "B<RLIMIT_STACK>"
msgstr ""

#. type: Plain text
#: man-pages/man2/getrlimit.2:437
msgid ""
"This is the maximum size of the process stack, in bytes.  Upon reaching this "
"limit, a B<SIGSEGV> signal is generated.  To handle this signal, a process "
"must employ an alternate signal stack (B<sigaltstack>(2))."
msgstr ""

#. type: Plain text
#: man-pages/man2/getrlimit.2:442
msgid ""
"Since Linux 2.6.23, this limit also determines the amount of space used for "
"the process's command-line arguments and environment variables; for details, "
"see B<execve>(2)."
msgstr ""

#. type: SS
#: man-pages/man2/getrlimit.2:442
#, no-wrap
msgid "prlimit()"
msgstr ""

#.  commit c022a0acad534fd5f5d5f17280f6d4d135e74e81
#.  Author: Jiri Slaby <jslaby@suse.cz>
#.  Date:   Tue May 4 18:03:50 2010 +0200
#
#.      rlimits: implement prlimit64 syscall
#
#.  commit 6a1d5e2c85d06da35cdfd93f1a27675bfdc3ad8c
#.  Author: Jiri Slaby <jslaby@suse.cz>
#.  Date:   Wed Mar 24 17:06:58 2010 +0100
#
#.      rlimits: add rlimit64 structure
#. type: Plain text
#: man-pages/man2/getrlimit.2:462
msgid ""
"The Linux-specific B<prlimit>()  system call combines and extends the "
"functionality of B<setrlimit>()  and B<getrlimit>().  It can be used to both "
"set and get the resource limits of an arbitrary process."
msgstr ""

#. type: Plain text
#: man-pages/man2/getrlimit.2:469
msgid ""
"The I<resource> argument has the same meaning as for B<setrlimit>()  and "
"B<getrlimit>()."
msgstr ""

#. type: Plain text
#: man-pages/man2/getrlimit.2:487
msgid ""
"If the I<new_limit> argument is a not NULL, then the I<rlimit> structure to "
"which it points is used to set new values for the soft and hard limits for "
"I<resource>.  If the I<old_limit> argument is a not NULL, then a successful "
"call to B<prlimit>()  places the previous soft and hard limits for "
"I<resource> in the I<rlimit> structure pointed to by I<old_limit>."
msgstr ""

#.  FIXME . this permission check is strange
#.  Asked about this on LKML, 7 Nov 2010
#.      "Inconsistent credential checking in prlimit() syscall"
#. type: Plain text
#: man-pages/man2/getrlimit.2:507
msgid ""
"The I<pid> argument specifies the ID of the process on which the call is to "
"operate.  If I<pid> is 0, then the call applies to the calling process.  To "
"set or get the resources of a process other than itself, the caller must "
"have the B<CAP_SYS_RESOURCE> capability in the user namespace of the process "
"whose resource limits are being changed, or the real, effective, and saved "
"set user IDs of the target process must match the real user ID of the caller "
"I<and> the real, effective, and saved set group IDs of the target process "
"must match the real group ID of the caller."
msgstr ""

#. type: Plain text
#: man-pages/man2/getrlimit.2:512
msgid ""
"On success, these system calls return 0.  On error, -1 is returned, and "
"I<errno> is set appropriately."
msgstr ""

#. type: Plain text
#: man-pages/man2/getrlimit.2:517
msgid ""
"A pointer argument points to a location outside the accessible address "
"space."
msgstr ""

#. type: Plain text
#: man-pages/man2/getrlimit.2:529
msgid ""
"The value specified in I<resource> is not valid; or, for B<setrlimit>()  or "
"B<prlimit>(): I<rlim-E<gt>rlim_cur> was greater than I<rlim-E<gt>rlim_max>."
msgstr ""

#. type: Plain text
#: man-pages/man2/getrlimit.2:534
msgid ""
"An unprivileged process tried to raise the hard limit; the "
"B<CAP_SYS_RESOURCE> capability is required to do this."
msgstr ""

#. type: Plain text
#: man-pages/man2/getrlimit.2:542
msgid ""
"The caller tried to increase the hard B<RLIMIT_NOFILE> limit above the "
"maximum defined by I</proc/sys/fs/nr_open> (see B<proc>(5))"
msgstr ""

#. type: Plain text
#: man-pages/man2/getrlimit.2:548
msgid ""
"(B<prlimit>())  The calling process did not have permission to set limits "
"for the process specified by I<pid>."
msgstr ""

#. type: Plain text
#: man-pages/man2/getrlimit.2:552
msgid "Could not find a process with the ID specified in I<pid>."
msgstr ""

#. type: Plain text
#: man-pages/man2/getrlimit.2:557
msgid ""
"The B<prlimit>()  system call is available since Linux 2.6.36.  Library "
"support is available since glibc 2.13."
msgstr ""

#. type: SH
#: man-pages/man2/getrlimit.2:557 man-pages/man2/getrusage.2:202
#: man-pages/man2/utimensat.2:415 man-pages/man2/eventfd.2:270
#: man-pages/man2/mmap.2:645 man-pages/man2/adjtimex.2:493
#: man-pages/man2/sigaltstack.2:214 man-pages/man2/clock_getres.2:240
#, no-wrap
msgid "ATTRIBUTES"
msgstr ""

#. type: Plain text
#: man-pages/man2/getrlimit.2:560 man-pages/man2/getrusage.2:205
#: man-pages/man2/utimensat.2:418 man-pages/man2/eventfd.2:273
#: man-pages/man2/mmap.2:648 man-pages/man2/adjtimex.2:496
#: man-pages/man2/sigaltstack.2:217 man-pages/man2/clock_getres.2:243
msgid "For an explanation of the terms used in this section, see B<attributes>(7)."
msgstr ""

#. type: tbl table
#: man-pages/man2/getrlimit.2:564 man-pages/man2/getrusage.2:209
#: man-pages/man2/utimensat.2:422 man-pages/man2/eventfd.2:277
#: man-pages/man2/mmap.2:652 man-pages/man2/adjtimex.2:500
#: man-pages/man2/sigaltstack.2:221 man-pages/man2/clock_getres.2:247
#, no-wrap
msgid "Interface"
msgstr ""

#. type: tbl table
#: man-pages/man2/getrlimit.2:564 man-pages/man2/getrusage.2:209
#: man-pages/man2/utimensat.2:422 man-pages/man2/eventfd.2:277
#: man-pages/man2/mmap.2:652 man-pages/man2/adjtimex.2:500
#: man-pages/man2/sigaltstack.2:221 man-pages/man2/clock_getres.2:247
#, no-wrap
msgid "Attribute"
msgstr ""

#. type: tbl table
#: man-pages/man2/getrlimit.2:564 man-pages/man2/getrusage.2:209
#: man-pages/man2/utimensat.2:422 man-pages/man2/eventfd.2:277
#: man-pages/man2/mmap.2:652 man-pages/man2/adjtimex.2:500
#: man-pages/man2/sigaltstack.2:221 man-pages/man2/clock_getres.2:247
#, no-wrap
msgid "Value"
msgstr ""

#. type: tbl table
#: man-pages/man2/getrlimit.2:569
#, no-wrap
msgid ""
"B<getrlimit>(),\n"
"B<setrlimit>(),\n"
"B<prlimit>()"
msgstr ""

#. type: tbl table
#: man-pages/man2/getrlimit.2:569 man-pages/man2/getrusage.2:212
#: man-pages/man2/utimensat.2:426 man-pages/man2/eventfd.2:280
#: man-pages/man2/mmap.2:656 man-pages/man2/adjtimex.2:503
#: man-pages/man2/sigaltstack.2:224 man-pages/man2/clock_getres.2:252
#, no-wrap
msgid "Thread safety"
msgstr ""

#. type: tbl table
#: man-pages/man2/getrlimit.2:569 man-pages/man2/getrusage.2:212
#: man-pages/man2/utimensat.2:426 man-pages/man2/eventfd.2:280
#: man-pages/man2/mmap.2:656 man-pages/man2/adjtimex.2:503
#: man-pages/man2/sigaltstack.2:224 man-pages/man2/clock_getres.2:252
#, no-wrap
msgid "MT-Safe"
msgstr ""

#. type: Plain text
#: man-pages/man2/getrlimit.2:576
msgid "B<getrlimit>(), B<setrlimit>(): POSIX.1-2001, POSIX.1-2008, SVr4, 4.3BSD."
msgstr ""

#. type: Plain text
#: man-pages/man2/getrlimit.2:579
msgid "B<prlimit>(): Linux-specific."
msgstr ""

#. type: Plain text
#: man-pages/man2/getrlimit.2:595
msgid ""
"B<RLIMIT_MEMLOCK> and B<RLIMIT_NPROC> derive from BSD and are not specified "
"in POSIX.1; they are present on the BSDs and Linux, but on few other "
"implementations.  B<RLIMIT_RSS> derives from BSD and is not specified in "
"POSIX.1; it is nevertheless present on most implementations.  "
"B<RLIMIT_MSGQUEUE>, B<RLIMIT_NICE>, B<RLIMIT_RTPRIO>, B<RLIMIT_RTTIME>, and "
"B<RLIMIT_SIGPENDING> are Linux-specific."
msgstr ""

#. type: Plain text
#: man-pages/man2/getrlimit.2:601
msgid ""
"A child process created via B<fork>(2)  inherits its parent's resource "
"limits.  Resource limits are preserved across B<execve>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/getrlimit.2:604
msgid ""
"Resource limits are per-process attributes that are shared by all of the "
"threads in a process."
msgstr ""

#. type: Plain text
#: man-pages/man2/getrlimit.2:609
msgid ""
"Lowering the soft limit for a resource below the process's current "
"consumption of that resource will succeed (but will prevent the process from "
"further increasing its consumption of the resource)."
msgstr ""

#. type: Plain text
#: man-pages/man2/getrlimit.2:618
msgid ""
"One can set the resource limits of the shell using the built-in I<ulimit> "
"command (I<limit> in B<csh>(1)).  The shell's resource limits are inherited "
"by the processes that it creates to execute commands."
msgstr ""

#. type: Plain text
#: man-pages/man2/getrlimit.2:623
msgid ""
"Since Linux 2.6.24, the resource limits of any process can be inspected via "
"I</proc/[pid]/limits>; see B<proc>(5)."
msgstr ""

#. type: Plain text
#: man-pages/man2/getrlimit.2:632
msgid ""
"Ancient systems provided a B<vlimit>()  function with a similar purpose to "
"B<setrlimit>().  For backward compatibility, glibc also provides "
"B<vlimit>().  All new applications should be written using B<setrlimit>()."
msgstr ""

#. type: SS
#: man-pages/man2/getrlimit.2:632 man-pages/man2/utimensat.2:459
#, no-wrap
msgid "C library/kernel ABI differences"
msgstr ""

#. type: Plain text
#: man-pages/man2/getrlimit.2:641
msgid ""
"Since version 2.13, the glibc B<getrlimit>()  and B<setrlimit>()  wrapper "
"functions no longer invoke the corresponding system calls, but instead "
"employ B<prlimit>(), for the reasons described in BUGS."
msgstr ""

#. type: Plain text
#: man-pages/man2/getrlimit.2:646
msgid ""
"The name of the glibc wrapper function is B<prlimit>(); the underlying "
"system call is B<prlimit64>()."
msgstr ""

#. type: Plain text
#: man-pages/man2/getrlimit.2:655
msgid ""
"In older Linux kernels, the B<SIGXCPU> and B<SIGKILL> signals delivered when "
"a process encountered the soft and hard B<RLIMIT_CPU> limits were delivered "
"one (CPU) second later than they should have been.  This was fixed in kernel "
"2.6.8."
msgstr ""

#.  see http://marc.theaimsgroup.com/?l=linux-kernel&m=114008066530167&w=2
#. type: Plain text
#: man-pages/man2/getrlimit.2:663
msgid ""
"In 2.6.x kernels before 2.6.17, a B<RLIMIT_CPU> limit of 0 is wrongly "
"treated as \"no limit\" (like B<RLIM_INFINITY>).  Since Linux 2.6.17, "
"setting a limit of 0 does have an effect, but is actually treated as a limit "
"of 1 second."
msgstr ""

#.  See https://lwn.net/Articles/145008/
#. type: Plain text
#: man-pages/man2/getrlimit.2:668
msgid ""
"A kernel bug means that B<RLIMIT_RTPRIO> does not work in kernel 2.6.12; the "
"problem is fixed in kernel 2.6.13."
msgstr ""

#.  see http://marc.theaimsgroup.com/?l=linux-kernel&m=112256338703880&w=2
#. type: Plain text
#: man-pages/man2/getrlimit.2:679
msgid ""
"In kernel 2.6.12, there was an off-by-one mismatch between the priority "
"ranges returned by B<getpriority>(2)  and B<RLIMIT_NICE>.  This had the "
"effect that the actual ceiling for the nice value was calculated as I<19\\ "
"-\\ rlim_cur>.  This was fixed in kernel 2.6.13."
msgstr ""

#.  The relevant patch, sent to LKML, seems to be
#.  http://thread.gmane.org/gmane.linux.kernel/273462
#.  From: Roland McGrath <roland <at> redhat.com>
#.  Subject: [PATCH 7/7] make RLIMIT_CPU/SIGXCPU per-process
#.  Date: 2005-01-23 23:27:46 GMT
#.  Tested Solaris 10, FreeBSD 9, OpenBSD 5.0
#.  FIXME . https://bugzilla.kernel.org/show_bug.cgi?id=50951
#. type: Plain text
#: man-pages/man2/getrlimit.2:706
msgid ""
"Since Linux 2.6.12, if a process reaches its soft B<RLIMIT_CPU> limit and "
"has a handler installed for B<SIGXCPU>, then, in addition to invoking the "
"signal handler, the kernel increases the soft limit by one second.  This "
"behavior repeats if the process continues to consume CPU time, until the "
"hard limit is reached, at which point the process is killed.  Other "
"implementations do not change the B<RLIMIT_CPU> soft limit in this manner, "
"and the Linux behavior is probably not standards conformant; portable "
"applications should avoid relying on this Linux-specific behavior.  The "
"Linux-specific B<RLIMIT_RTTIME> limit exhibits the same behavior when the "
"soft limit is encountered."
msgstr ""

#.  d3561f78fd379a7110e46c87964ba7aa4120235c
#. type: Plain text
#: man-pages/man2/getrlimit.2:716
msgid ""
"Kernels before 2.4.22 did not diagnose the error B<EINVAL> for "
"B<setrlimit>()  when I<rlim-E<gt>rlim_cur> was greater than "
"I<rlim-E<gt>rlim_max>."
msgstr ""

#. type: Plain text
#: man-pages/man2/getrlimit.2:721
msgid ""
"Linux doesn't return an error when an attempt to set B<RLIMIT_CPU> has "
"failed, for compatibility reasons."
msgstr ""

#. type: SS
#: man-pages/man2/getrlimit.2:721
#, no-wrap
msgid "Representation of \"large\" resource limit values on 32-bit platforms"
msgstr ""

#.  Linux still uses long for limits internally:
#.  c022a0acad534fd5f5d5f17280f6d4d135e74e81
#.  kernel/sys.c:do_prlimit() still uses struct rlimit which
#.  uses kernel_ulong_t for its members, i.e. 32-bit  on 32-bit kernel.
#.  https://bugzilla.kernel.org/show_bug.cgi?id=5042
#.  http://sources.redhat.com/bugzilla/show_bug.cgi?id=12201
#. type: Plain text
#: man-pages/man2/getrlimit.2:756
msgid ""
"The glibc B<getrlimit>()  and B<setrlimit>()  wrapper functions use a 64-bit "
"I<rlim_t> data type, even on 32-bit platforms.  However, the I<rlim_t> data "
"type used in the B<getrlimit>()  and B<setrlimit>()  system calls is a "
"(32-bit)  I<unsigned long>.  Furthermore, in Linux, the kernel represents "
"resource limits on 32-bit platforms as I<unsigned long>.  However, a 32-bit "
"data type is not wide enough.  The most pertinent limit here is "
"B<RLIMIT_FSIZE>, which specifies the maximum size to which a file can grow: "
"to be useful, this limit must be represented using a type that is as wide as "
"the type used to represent file offsets\\(emthat is, as wide as a 64-bit "
"B<off_t> (assuming a program compiled with I<_FILE_OFFSET_BITS=64>)."
msgstr ""

#. type: Plain text
#: man-pages/man2/getrlimit.2:766
msgid ""
"To work around this kernel limitation, if a program tried to set a resource "
"limit to a value larger than can be represented in a 32-bit I<unsigned "
"long>, then the glibc B<setrlimit>()  wrapper function silently converted "
"the limit value to B<RLIM_INFINITY>.  In other words, the requested resource "
"limit setting was silently ignored."
msgstr ""

#.  https://www.sourceware.org/bugzilla/show_bug.cgi?id=12201
#. type: Plain text
#: man-pages/man2/getrlimit.2:779
msgid ""
"Since version 2.13, glibc works around the limitations of the B<getrlimit>()  "
"and B<setrlimit>()  system calls by implementing B<setrlimit>()  and "
"B<getrlimit>()  as wrapper functions that call B<prlimit>()."
msgstr ""

#. type: Plain text
#: man-pages/man2/getrlimit.2:782
msgid "The program below demonstrates the use of B<prlimit>()."
msgstr ""

#. type: Plain text
#: man-pages/man2/getrlimit.2:791
#, no-wrap
msgid ""
"#define _GNU_SOURCE\n"
"#define _FILE_OFFSET_BITS 64\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>time.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>sys/resource.hE<gt>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/getrlimit.2:794
#, no-wrap
msgid ""
"#define errExit(msg) do { perror(msg); exit(EXIT_FAILURE); \\e\n"
"                        } while (0)\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/getrlimit.2:801
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    struct rlimit old, new;\n"
"    struct rlimit *newp;\n"
"    pid_t pid;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/getrlimit.2:807
#, no-wrap
msgid ""
"    if (!(argc == 2 || argc == 4)) {\n"
"        fprintf(stderr, \"Usage: %s E<lt>pidE<gt> [E<lt>new-soft-limitE<gt> "
"\"\n"
"                \"E<lt>new-hard-limitE<gt>]\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/getrlimit.2:809
#, no-wrap
msgid "    pid = atoi(argv[1]);        /* PID of target process */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/getrlimit.2:816
#, no-wrap
msgid ""
"    newp = NULL;\n"
"    if (argc == 4) {\n"
"        new.rlim_cur = atoi(argv[2]);\n"
"        new.rlim_max = atoi(argv[3]);\n"
"        newp = &new;\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/getrlimit.2:819
#, no-wrap
msgid ""
"    /* Set CPU time limit of target process; retrieve and display\n"
"       previous limit */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/getrlimit.2:824
#, no-wrap
msgid ""
"    if (prlimit(pid, RLIMIT_CPU, newp, &old) == -1)\n"
"        errExit(\"prlimit-1\");\n"
"    printf(\"Previous limits: soft=%lld; hard=%lld\\en\",\n"
"            (long long) old.rlim_cur, (long long) old.rlim_max);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/getrlimit.2:826
#, no-wrap
msgid "    /* Retrieve and display new CPU time limit */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/getrlimit.2:831
#, no-wrap
msgid ""
"    if (prlimit(pid, RLIMIT_CPU, NULL, &old) == -1)\n"
"        errExit(\"prlimit-2\");\n"
"    printf(\"New limits: soft=%lld; hard=%lld\\en\",\n"
"            (long long) old.rlim_cur, (long long) old.rlim_max);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/getrlimit.2:854
msgid ""
"B<prlimit>(1), B<dup>(2), B<fcntl>(2), B<fork>(2), B<getrusage>(2), "
"B<mlock>(2), B<mmap>(2), B<open>(2), B<quotactl>(2), B<sbrk>(2), "
"B<shmctl>(2), B<malloc>(3), B<sigqueue>(3), B<ulimit>(3), B<core>(5), "
"B<capabilities>(7), B<cgroups>(7), B<credentials>(7), B<signal>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/memfd_create.2:21
#, no-wrap
msgid "MEMFD_CREATE"
msgstr ""

#. type: Plain text
#: man-pages/man2/memfd_create.2:24
msgid "memfd_create - create an anonymous file"
msgstr ""

#. type: Plain text
#: man-pages/man2/memfd_create.2:28 man-pages/man2/mremap.2:37
#: man-pages/man2/remap_file_pages.2:35
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>         /* See feature_test_macros(7) */\n"
"B<#include E<lt>sys/mman.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/memfd_create.2:30
#, no-wrap
msgid "B<int memfd_create(const char *>I<name>B<, unsigned int >I<flags>B<);>\n"
msgstr ""

#.  David Herrmann:
#.      memfd uses VM_NORESERVE so each page is accounted on first access.
#.      This means, the overcommit-limits (see __vm_enough_memory()) and the
#.      memory-cgroup limits (mem_cgroup_try_charge()) are applied. Note that
#.      those are accounted on "current" and "current->mm", that is, the
#.      process doing the first page access.
#. type: Plain text
#: man-pages/man2/memfd_create.2:53
msgid ""
"B<memfd_create>()  creates an anonymous file and returns a file descriptor "
"that refers to it.  The file behaves like a regular file, and so can be "
"modified, truncated, memory-mapped, and so on.  However, unlike a regular "
"file, it lives in RAM and has a volatile backing storage.  Once all "
"references to the file are dropped, it is automatically released.  Anonymous "
"memory is used for all backing pages of the file.  Therefore, files created "
"by B<memfd_create>()  have the same semantics as other anonymous memory "
"allocations such as those allocated using B<mmap>(2)  with the "
"B<MAP_ANONYMOUS> flag."
msgstr ""

#. type: Plain text
#: man-pages/man2/memfd_create.2:60
msgid ""
"The initial size of the file is set to 0.  Following the call, the file size "
"should be set using B<ftruncate>(2).  (Alternatively, the file may be "
"populated by calls to B<write>(2)  or similar.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/memfd_create.2:71
msgid ""
"The name supplied in I<name> is used as a filename and will be displayed as "
"the target of the corresponding symbolic link in the directory "
"I</proc/self/fd/>.  The displayed name is always prefixed with I<memfd:> and "
"serves only for debugging purposes.  Names do not affect the behavior of the "
"file descriptor, and as such multiple files can have the same name without "
"any side effects."
msgstr ""

#. type: Plain text
#: man-pages/man2/memfd_create.2:76
msgid ""
"The following values may be bitwise ORed in I<flags> to change the behavior "
"of B<memfd_create>():"
msgstr ""

#. type: TP
#: man-pages/man2/memfd_create.2:76
#, no-wrap
msgid "B<MFD_CLOEXEC>"
msgstr ""

#. type: TP
#: man-pages/man2/memfd_create.2:86
#, no-wrap
msgid "B<MFD_ALLOW_SEALING>"
msgstr ""

#.  FIXME Why is the MFD_ALLOW_SEALING behavior not simply the default?
#.  Is it worth adding some text explaining this?
#. type: Plain text
#: man-pages/man2/memfd_create.2:102
msgid ""
"Allow sealing operations on this file.  See the discussion of the "
"B<F_ADD_SEALS> and B<F_GET_SEALS> operations in B<fcntl>(2), and also NOTES, "
"below.  The initial set of seals is empty.  If this flag is not set, the "
"initial set of seals will be B<F_SEAL_SEAL>, meaning that no other seals can "
"be set on the file."
msgstr ""

#. type: TP
#: man-pages/man2/memfd_create.2:102
#, no-wrap
msgid "B<MFD_HUGETLB> (since Linux 4.14)"
msgstr ""

#.  commit 749df87bd7bee5a79cef073f5d032ddb2b211de8
#.  commit 47b9012ecdc747f6936395265e677d41e11a31ff
#. type: Plain text
#: man-pages/man2/memfd_create.2:118
msgid ""
"The anonymous file will be created in the hugetlbfs filesystem using huge "
"pages.  See the Linux kernel source file "
"I<Documentation/admin-guide/mm/hugetlbpage.rst> for more information about "
"hugetlbfs.  Specifying both B<MFD_HUGETLB> and B<MFD_ALLOW_SEALING> in "
"I<flags> is supported since Linux 4.16."
msgstr ""

#. type: TP
#: man-pages/man2/memfd_create.2:118
#, no-wrap
msgid "B<MFD_HUGE_2MB>, B<MFD_HUGE_1GB>, B<...>"
msgstr ""

#. type: Plain text
#: man-pages/man2/memfd_create.2:127
msgid ""
"Used in conjunction with B<MFD_HUGETLB> to select alternative hugetlb page "
"sizes (respectively, 2\\ MB, 1\\ GB, ...)  on systems that support multiple "
"hugetlb page sizes.  Definitions for known huge page sizes are included in "
"the header file I<E<lt>linux/memfd.hE<gt>.>"
msgstr ""

#. type: Plain text
#: man-pages/man2/memfd_create.2:131
msgid ""
"For details on encoding huge page sizes not included in the header file, see "
"the discussion of the similarly named constants in B<mmap>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/memfd_create.2:135
msgid "Unused bits in I<flags> must be 0."
msgstr ""

#. type: Plain text
#: man-pages/man2/memfd_create.2:144
msgid ""
"As its return value, B<memfd_create>()  returns a new file descriptor that "
"can be used to refer to the file.  This file descriptor is opened for both "
"reading and writing (B<O_RDWR>)  and B<O_LARGEFILE> is set for the file "
"descriptor."
msgstr ""

#. type: Plain text
#: man-pages/man2/memfd_create.2:157
msgid ""
"With respect to B<fork>(2)  and B<execve>(2), the usual semantics apply for "
"the file descriptor created by B<memfd_create>().  A copy of the file "
"descriptor is inherited by the child produced by B<fork>(2)  and refers to "
"the same file.  The file descriptor is preserved across B<execve>(2), unless "
"the close-on-exec flag has been set."
msgstr ""

#. type: Plain text
#: man-pages/man2/memfd_create.2:164
msgid ""
"On success, B<memfd_create>()  returns a new file descriptor.  On error, -1 "
"is returned and I<errno> is set to indicate the error."
msgstr ""

#. type: Plain text
#: man-pages/man2/memfd_create.2:170
msgid "The address in I<name> points to invalid memory."
msgstr ""

#. type: Plain text
#: man-pages/man2/memfd_create.2:174
msgid "I<flags> included unknown bits."
msgstr ""

#.  NAME_MAX - strlen("memfd:")
#. type: Plain text
#: man-pages/man2/memfd_create.2:181
msgid ""
"I<name> was too long.  (The limit is 249 bytes, excluding the terminating "
"null byte.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/memfd_create.2:189
msgid "Both B<MFD_HUGETLB> and B<MFD_ALLOW_SEALING> were specified in I<flags>."
msgstr ""

#. type: Plain text
#: man-pages/man2/memfd_create.2:198
msgid "There was insufficient memory to create a new anonymous file."
msgstr ""

#. type: Plain text
#: man-pages/man2/memfd_create.2:203
msgid ""
"The B<memfd_create>()  system call first appeared in Linux 3.17; glibc "
"support was added in version 2.27."
msgstr ""

#. type: Plain text
#: man-pages/man2/memfd_create.2:207
msgid "The B<memfd_create>()  system call is Linux-specific."
msgstr ""

#.  See also http://lwn.net/Articles/593918/
#.  and http://lwn.net/Articles/594919/ and http://lwn.net/Articles/591108/
#. type: Plain text
#: man-pages/man2/memfd_create.2:221
msgid ""
"The B<memfd_create>()  system call provides a simple alternative to manually "
"mounting a B<tmpfs>(5)  filesystem and creating and opening a file in that "
"filesystem.  The primary purpose of B<memfd_create>()  is to create files "
"and associated file descriptors that are used with the file-sealing APIs "
"provided by B<fcntl>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/memfd_create.2:235
msgid ""
"The B<memfd_create>()  system call also has uses without file sealing (which "
"is why file-sealing is disabled, unless explicitly requested with the "
"B<MFD_ALLOW_SEALING> flag).  In particular, it can be used as an alternative "
"to creating files in I<tmp> or as an alternative to using the B<open>(2)  "
"B<O_TMPFILE> in cases where there is no intention to actually link the "
"resulting file into the filesystem."
msgstr ""

#. type: SS
#: man-pages/man2/memfd_create.2:235
#, no-wrap
msgid "File sealing"
msgstr ""

#. type: Plain text
#: man-pages/man2/memfd_create.2:253
msgid ""
"In the absence of file sealing, processes that communicate via shared memory "
"must either trust each other, or take measures to deal with the possibility "
"that an untrusted peer may manipulate the shared memory region in "
"problematic ways.  For example, an untrusted peer might modify the contents "
"of the shared memory at any time, or shrink the shared memory region.  The "
"former possibility leaves the local process vulnerable to "
"time-of-check-to-time-of-use race conditions (typically dealt with by "
"copying data from the shared memory region before checking and using it).  "
"The latter possibility leaves the local process vulnerable to B<SIGBUS> "
"signals when an attempt is made to access a now-nonexistent location in the "
"shared memory region.  (Dealing with this possibility necessitates the use "
"of a handler for the B<SIGBUS> signal.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/memfd_create.2:259
msgid ""
"Dealing with untrusted peers imposes extra complexity on code that employs "
"shared memory.  Memory sealing enables that extra complexity to be "
"eliminated, by allowing a process to operate secure in the knowledge that "
"its peer can't modify the shared memory in an undesired fashion."
msgstr ""

#. type: Plain text
#: man-pages/man2/memfd_create.2:261
msgid "An example of the usage of the sealing mechanism is as follows:"
msgstr ""

#. type: IP
#: man-pages/man2/memfd_create.2:261 man-pages/man2/select_tut.2:340
#: man-pages/man2/delete_module.2:51 man-pages/man2/remap_file_pages.2:67
#: man-pages/man2/utimensat.2:145 man-pages/man2/listen.2:125
#: man-pages/man2/ptrace.2:2538 man-pages/man2/sigaltstack.2:63
#: man-pages/man2/futex.2:1043
#, no-wrap
msgid "1."
msgstr ""

#. type: Plain text
#: man-pages/man2/memfd_create.2:267
msgid ""
"The first process creates a B<tmpfs>(5)  file using B<memfd_create>().  The "
"call yields a file descriptor used in subsequent steps."
msgstr ""

#. type: IP
#: man-pages/man2/memfd_create.2:267 man-pages/man2/select_tut.2:349
#: man-pages/man2/delete_module.2:55 man-pages/man2/remap_file_pages.2:75
#: man-pages/man2/utimensat.2:151 man-pages/man2/listen.2:128
#: man-pages/man2/ptrace.2:2541 man-pages/man2/sigaltstack.2:67
#: man-pages/man2/futex.2:1045
#, no-wrap
msgid "2."
msgstr ""

#. type: Plain text
#: man-pages/man2/memfd_create.2:274
msgid ""
"The first process sizes the file created in the previous step using "
"B<ftruncate>(2), maps it using B<mmap>(2), and populates the shared memory "
"with the desired data."
msgstr ""

#. type: IP
#: man-pages/man2/memfd_create.2:274 man-pages/man2/select_tut.2:353
#: man-pages/man2/delete_module.2:59 man-pages/man2/utimensat.2:153
#: man-pages/man2/listen.2:134 man-pages/man2/ptrace.2:2558
#: man-pages/man2/sigaltstack.2:73 man-pages/man2/futex.2:1051
#, no-wrap
msgid "3."
msgstr ""

#. type: Plain text
#: man-pages/man2/memfd_create.2:284
msgid ""
"The first process uses the B<fcntl>(2)  B<F_ADD_SEALS> operation to place "
"one or more seals on the file, in order to restrict further modifications on "
"the file.  (If placing the seal B<F_SEAL_WRITE>, then it will be necessary "
"to first unmap the shared writable mapping created in the previous step.)"
msgstr ""

#. type: IP
#: man-pages/man2/memfd_create.2:284 man-pages/man2/select_tut.2:360
#: man-pages/man2/listen.2:138 man-pages/man2/ptrace.2:2574
#, no-wrap
msgid "4."
msgstr ""

#. type: Plain text
#: man-pages/man2/memfd_create.2:289
msgid ""
"A second process obtains a file descriptor for the B<tmpfs>(5)  file and "
"maps it.  Among the possible ways in which this could happen are the "
"following:"
msgstr ""

#. type: Plain text
#: man-pages/man2/memfd_create.2:300
msgid ""
"The process that called B<memfd_create>()  could transfer the resulting file "
"descriptor to the second process via a UNIX domain socket (see B<unix>(7)  "
"and B<cmsg>(3)).  The second process then maps the file using B<mmap>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/memfd_create.2:308
msgid ""
"The second process is created via B<fork>(2)  and thus automatically "
"inherits the file descriptor and mapping.  (Note that in this case and the "
"next, there is a natural trust relationship between the two processes, since "
"they are running under the same user ID.  Therefore, file sealing would not "
"normally be necessary.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/memfd_create.2:322
msgid ""
"The second process opens the file I</proc/E<lt>pidE<gt>/fd/E<lt>fdE<gt>>, "
"where I<E<lt>pidE<gt>> is the PID of the first process (the one that called "
"B<memfd_create>()), and I<E<lt>fdE<gt>> is the number of the file descriptor "
"returned by the call to B<memfd_create>()  in that process.  The second "
"process then maps the file using B<mmap>(2)."
msgstr ""

#. type: IP
#: man-pages/man2/memfd_create.2:323 man-pages/man2/select_tut.2:366
#: man-pages/man2/ptrace.2:2584
#, no-wrap
msgid "5."
msgstr ""

#. type: Plain text
#: man-pages/man2/memfd_create.2:335
msgid ""
"The second process uses the B<fcntl>(2)  B<F_GET_SEALS> operation to "
"retrieve the bit mask of seals that has been applied to the file.  This bit "
"mask can be inspected in order to determine what kinds of restrictions have "
"been placed on file modifications.  If desired, the second process can apply "
"further seals to impose additional restrictions (so long as the "
"B<F_SEAL_SEAL> seal has not yet been applied)."
msgstr ""

#. type: Plain text
#: man-pages/man2/memfd_create.2:339
msgid ""
"Below are shown two example programs that demonstrate the use of "
"B<memfd_create>()  and the file sealing API."
msgstr ""

#. type: Plain text
#: man-pages/man2/memfd_create.2:354
msgid ""
"The first program, I<t_memfd_create.c>, creates a B<tmpfs>(5)  file using "
"B<memfd_create>(), sets a size for the file, maps it into memory, and "
"optionally places some seals on the file.  The program accepts up to three "
"command-line arguments, of which the first two are required.  The first "
"argument is the name to associate with the file, the second argument is the "
"size to be set for the file, and the optional third argument is a string of "
"characters that specify seals to be set on file."
msgstr ""

#. type: Plain text
#: man-pages/man2/memfd_create.2:360
msgid ""
"The second program, I<t_get_seals.c>, can be used to open an existing file "
"that was created via B<memfd_create>()  and inspect the set of seals that "
"have been applied to that file."
msgstr ""

#. type: Plain text
#: man-pages/man2/memfd_create.2:365
msgid ""
"The following shell session demonstrates the use of these programs.  First "
"we create a B<tmpfs>(5)  file and set some seals on it:"
msgstr ""

#. type: Plain text
#: man-pages/man2/memfd_create.2:371
#, no-wrap
msgid ""
"$ B<./t_memfd_create my_memfd_file 4096 sw &>\n"
"[1] 11775\n"
"PID: 11775; fd: 3; /proc/11775/fd/3\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/memfd_create.2:389
msgid ""
"At this point, the I<t_memfd_create> program continues to run in the "
"background.  From another program, we can obtain a file descriptor for the "
"file created by B<memfd_create>()  by opening the I</proc/[pid]/fd> file "
"that corresponds to the file descriptor opened by B<memfd_create>().  Using "
"that pathname, we inspect the content of the I</proc/[pid]/fd> symbolic "
"link, and use our I<t_get_seals> program to view the seals that have been "
"placed on the file:"
msgstr ""

#. type: Plain text
#: man-pages/man2/memfd_create.2:396
#, no-wrap
msgid ""
"$ B<readlink /proc/11775/fd/3>\n"
"/memfd:my_memfd_file (deleted)\n"
"$ B<./t_get_seals /proc/11775/fd/3>\n"
"Existing seals: WRITE SHRINK\n"
msgstr ""

#. type: SS
#: man-pages/man2/memfd_create.2:398
#, no-wrap
msgid "Program source: t_memfd_create.c"
msgstr ""

#. type: Plain text
#: man-pages/man2/memfd_create.2:408
#, no-wrap
msgid ""
"#define _GNU_SOURCE\n"
"#include E<lt>sys/mman.hE<gt>\n"
"#include E<lt>fcntl.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/memfd_create.2:411 man-pages/man2/memfd_create.2:494
#: man-pages/man2/pivot_root.2:331 man-pages/man2/unshare.2:490
#: man-pages/man2/clone.2:1375 man-pages/man2/kcmp.2:363
#: man-pages/man2/userfaultfd.2:579 man-pages/man2/setns.2:317
#: man-pages/man2/open_by_handle_at.2:553
#: man-pages/man2/open_by_handle_at.2:626
#: man-pages/man2/sched_setaffinity.2:367 man-pages/man2/futex.2:1770
#: man-pages/man2/timer_create.2:362
#, no-wrap
msgid ""
"#define errExit(msg)    do { perror(msg); exit(EXIT_FAILURE); \\e\n"
"                        } while (0)\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/memfd_create.2:420
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int fd;\n"
"    unsigned int seals;\n"
"    char *addr;\n"
"    char *name, *seals_arg;\n"
"    ssize_t len;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/memfd_create.2:431
#, no-wrap
msgid ""
"    if (argc E<lt> 3) {\n"
"        fprintf(stderr, \"%s name size [seals]\\en\", argv[0]);\n"
"        fprintf(stderr, \"\\et\\(aqseals\\(aq can contain any of the \"\n"
"                \"following characters:\\en\");\n"
"        fprintf(stderr, \"\\et\\etg - F_SEAL_GROW\\en\");\n"
"        fprintf(stderr, \"\\et\\ets - F_SEAL_SHRINK\\en\");\n"
"        fprintf(stderr, \"\\et\\etw - F_SEAL_WRITE\\en\");\n"
"        fprintf(stderr, \"\\et\\etS - F_SEAL_SEAL\\en\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/memfd_create.2:435
#, no-wrap
msgid ""
"    name = argv[1];\n"
"    len = atoi(argv[2]);\n"
"    seals_arg = argv[3];\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/memfd_create.2:438
#, no-wrap
msgid ""
"    /* Create an anonymous file in tmpfs; allow seals to be\n"
"       placed on the file */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/memfd_create.2:442
#, no-wrap
msgid ""
"    fd = memfd_create(name, MFD_ALLOW_SEALING);\n"
"    if (fd == -1)\n"
"        errExit(\"memfd_create\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/memfd_create.2:444
#, no-wrap
msgid "    /* Size the file as specified on the command line */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/memfd_create.2:447
#, no-wrap
msgid ""
"    if (ftruncate(fd, len) == -1)\n"
"        errExit(\"truncate\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/memfd_create.2:450
#, no-wrap
msgid ""
"    printf(\"PID: %ld; fd: %d; /proc/%ld/fd/%d\\en\",\n"
"            (long) getpid(), fd, (long) getpid(), fd);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/memfd_create.2:453
#, no-wrap
msgid ""
"    /* Code to map the file and populate the mapping with data\n"
"       omitted */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/memfd_create.2:456
#, no-wrap
msgid ""
"    /* If a \\(aqseals\\(aq command-line argument was supplied, set some\n"
"       seals on the file */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/memfd_create.2:459
#, no-wrap
msgid ""
"    if (seals_arg != NULL) {\n"
"        seals = 0;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/memfd_create.2:468
#, no-wrap
msgid ""
"        if (strchr(seals_arg, \\(aqg\\(aq) != NULL)\n"
"            seals |= F_SEAL_GROW;\n"
"        if (strchr(seals_arg, \\(aqs\\(aq) != NULL)\n"
"            seals |= F_SEAL_SHRINK;\n"
"        if (strchr(seals_arg, \\(aqw\\(aq) != NULL)\n"
"            seals |= F_SEAL_WRITE;\n"
"        if (strchr(seals_arg, \\(aqS\\(aq) != NULL)\n"
"            seals |= F_SEAL_SEAL;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/memfd_create.2:472
#, no-wrap
msgid ""
"        if (fcntl(fd, F_ADD_SEALS, seals) == -1)\n"
"            errExit(\"fcntl\");\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/memfd_create.2:475
#, no-wrap
msgid ""
"    /* Keep running, so that the file created by memfd_create()\n"
"       continues to exist */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/memfd_create.2:477
#, no-wrap
msgid "    pause();\n"
msgstr ""

#. type: SS
#: man-pages/man2/memfd_create.2:481
#, no-wrap
msgid "Program source: t_get_seals.c"
msgstr ""

#. type: Plain text
#: man-pages/man2/memfd_create.2:491
#, no-wrap
msgid ""
"#define _GNU_SOURCE\n"
"#include E<lt>sys/mman.hE<gt>\n"
"#include E<lt>fcntl.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/memfd_create.2:500
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int fd;\n"
"    unsigned int seals;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/memfd_create.2:505
#, no-wrap
msgid ""
"    if (argc != 2) {\n"
"        fprintf(stderr, \"%s /proc/PID/fd/FD\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/memfd_create.2:509
#, no-wrap
msgid ""
"    fd = open(argv[1], O_RDWR);\n"
"    if (fd == -1)\n"
"        errExit(\"open\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/memfd_create.2:513
#, no-wrap
msgid ""
"    seals = fcntl(fd, F_GET_SEALS);\n"
"    if (seals == -1)\n"
"        errExit(\"fcntl\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/memfd_create.2:524
#, no-wrap
msgid ""
"    printf(\"Existing seals:\");\n"
"    if (seals & F_SEAL_SEAL)\n"
"        printf(\" SEAL\");\n"
"    if (seals & F_SEAL_GROW)\n"
"        printf(\" GROW\");\n"
"    if (seals & F_SEAL_WRITE)\n"
"        printf(\" WRITE\");\n"
"    if (seals & F_SEAL_SHRINK)\n"
"        printf(\" SHRINK\");\n"
"    printf(\"\\en\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/memfd_create.2:527
#, no-wrap
msgid ""
"    /* Code to map the file and access the contents of the\n"
"       resulting mapping omitted */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/memfd_create.2:536
msgid "B<fcntl>(2), B<ftruncate>(2), B<mmap>(2), B<shmget>(2), B<shm_open>(3)"
msgstr ""

#. type: TH
#: man-pages/man2/io_setup.2:7
#, no-wrap
msgid "IO_SETUP"
msgstr ""

#. type: Plain text
#: man-pages/man2/io_setup.2:10
msgid "io_setup - create an asynchronous I/O context"
msgstr ""

#. type: Plain text
#: man-pages/man2/io_setup.2:13 man-pages/man2/io_submit.2:14
#: man-pages/man2/io_cancel.2:13 man-pages/man2/io_destroy.2:13
#, no-wrap
msgid "B<#include E<lt>linux/aio_abi.hE<gt>>          /* Defines needed types */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/io_setup.2:15
#, no-wrap
msgid "B<int io_setup(unsigned >I<nr_events>B<, aio_context_t *>I<ctx_idp>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/io_setup.2:19 man-pages/man2/readdir.2:42
#: man-pages/man2/io_submit.2:21 man-pages/man2/io_cancel.2:20
#: man-pages/man2/io_getevents.2:22 man-pages/man2/set_tid_address.2:37
#: man-pages/man2/io_destroy.2:19 man-pages/man2/pivot_root.2:35
#: man-pages/man2/spu_create.2:40 man-pages/man2/llseek.2:43
#: man-pages/man2/perf_event_open.2:42 man-pages/man2/kcmp.2:41
#: man-pages/man2/mq_getsetattr.2:40 man-pages/man2/modify_ldt.2:37
#: man-pages/man2/spu_run.2:39 man-pages/man2/subpage_prot.2:41
#: man-pages/man2/restart_syscall.2:41 man-pages/man2/userfaultfd.2:40
#: man-pages/man2/perfmonctl.2:39 man-pages/man2/getunwind.2:40
#: man-pages/man2/sysctl.2:43 man-pages/man2/futex.2:39
msgid "I<Note>: There is no glibc wrapper for this system call; see NOTES."
msgstr ""

#. type: Plain text
#: man-pages/man2/io_setup.2:32
msgid ""
"The B<io_setup>()  system call creates an asynchronous I/O context suitable "
"for concurrently processing I<nr_events> operations.  The I<ctx_idp> "
"argument must not point to an AIO context that already exists, and must be "
"initialized to 0 prior to the call.  On successful creation of the AIO "
"context, I<*ctx_idp> is filled in with the resulting handle."
msgstr ""

#. type: Plain text
#: man-pages/man2/io_setup.2:37
msgid "On success, B<io_setup>()  returns 0.  For the failure return, see NOTES."
msgstr ""

#. type: Plain text
#: man-pages/man2/io_setup.2:43
msgid ""
"The specified I<nr_events> exceeds the user's limit of available events, as "
"defined in I</proc/sys/fs/aio-max-nr>."
msgstr ""

#. type: Plain text
#: man-pages/man2/io_setup.2:46
msgid "An invalid pointer is passed for I<ctx_idp>."
msgstr ""

#. type: Plain text
#: man-pages/man2/io_setup.2:51
msgid ""
"I<ctx_idp> is not initialized, or the specified I<nr_events> exceeds "
"internal limits.  I<nr_events> should be greater than 0."
msgstr ""

#. type: Plain text
#: man-pages/man2/io_setup.2:54
msgid "Insufficient kernel resources are available."
msgstr ""

#. type: Plain text
#: man-pages/man2/io_setup.2:58
msgid "B<io_setup>()  is not implemented on this architecture."
msgstr ""

#. type: Plain text
#: man-pages/man2/io_setup.2:61 man-pages/man2/io_submit.2:237
#: man-pages/man2/io_cancel.2:59 man-pages/man2/io_getevents.2:85
#: man-pages/man2/io_destroy.2:48
msgid "The asynchronous I/O system calls first appeared in Linux 2.5."
msgstr ""

#. type: Plain text
#: man-pages/man2/io_setup.2:66
msgid ""
"B<io_setup>()  is Linux-specific and should not be used in programs that are "
"intended to be portable."
msgstr ""

#.  http://git.fedorahosted.org/git/?p=libaio.git
#. type: Plain text
#: man-pages/man2/io_setup.2:75
msgid ""
"Glibc does not provide a wrapper function for this system call.  You could "
"invoke it using B<syscall>(2).  But instead, you probably want to use the "
"B<io_setup>()  wrapper function provided by I<libaio>."
msgstr ""

#.  But glibc is confused, since <libaio.h> uses 'io_context_t' to declare
#.  the system call.
#. type: Plain text
#: man-pages/man2/io_setup.2:96
msgid ""
"Note that the I<libaio> wrapper function uses a different type "
"(I<io_context_t\\ *>)  for the I<ctx_idp> argument.  Note also that the "
"I<libaio> wrapper does not follow the usual C library conventions for "
"indicating errors: on error it returns a negated error number (the negative "
"of one of the values listed in ERRORS).  If the system call is invoked via "
"B<syscall>(2), then the return value follows the usual conventions for "
"indicating an error: -1, with I<errno> set to a (positive) value that "
"indicates the error."
msgstr ""

#. type: Plain text
#: man-pages/man2/io_setup.2:101
msgid ""
"B<io_cancel>(2), B<io_destroy>(2), B<io_getevents>(2), B<io_submit>(2), "
"B<aio>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/request_key.2:12
#, no-wrap
msgid "REQUEST_KEY"
msgstr ""

#. type: TH
#: man-pages/man2/request_key.2:12 man-pages/man2/keyctl.2:28
#: man-pages/man2/add_key.2:12
#, no-wrap
msgid "Linux Key Management Calls"
msgstr ""

#. type: Plain text
#: man-pages/man2/request_key.2:15
msgid "request_key - request a key from the kernel's key management facility"
msgstr ""

#. type: Plain text
#: man-pages/man2/request_key.2:19 man-pages/man2/keyctl.2:35
#: man-pages/man2/add_key.2:19
#, no-wrap
msgid ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>keyutils.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/request_key.2:23
#, no-wrap
msgid ""
"B<key_serial_t request_key(const char *>I<type>B<, const char "
"*>I<description>B<,>\n"
"B<                         const char *>I<callout_info>B<,>\n"
"B<                         key_serial_t >I<dest_keyring>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/request_key.2:26 man-pages/man2/keyctl.2:49
#: man-pages/man2/add_key.2:26
msgid "No glibc wrapper is provided for this system call; see NOTES."
msgstr ""

#. type: Plain text
#: man-pages/man2/request_key.2:38
msgid ""
"B<request_key>()  attempts to find a key of the given I<type> with a "
"description (name) that matches the specified I<description>.  If such a key "
"could not be found, then the key is optionally created.  If the key is found "
"or created, B<request_key>()  attaches it to the keyring whose ID is "
"specified in I<dest_keyring> and returns the key's serial number."
msgstr ""

#. type: Plain text
#: man-pages/man2/request_key.2:44
msgid ""
"B<request_key>()  first recursively searches for a matching key in all of "
"the keyrings attached to the calling process.  The keyrings are searched in "
"the order: thread-specific keyring, process-specific keyring, and then "
"session keyring."
msgstr ""

#.  David Howells: we can then have an arbitrarily long sequence
#.  of "recursive" request-key upcalls. There is no limit, other
#.  than number of PIDs, etc.
#. type: Plain text
#: man-pages/man2/request_key.2:56
msgid ""
"If B<request_key>()  is called from a program invoked by B<request_key>()  "
"on behalf of some other process to generate a key, then the keyrings of that "
"other process will be searched next, using that other process's user ID, "
"group ID, supplementary group IDs, and security context to determine access."
msgstr ""

#. type: Plain text
#: man-pages/man2/request_key.2:65
msgid ""
"The search of the keyring tree is breadth-first: the keys in each keyring "
"searched are checked for a match before any child keyrings are recursed "
"into.  Only keys for which the caller has I<search> permission be found, and "
"only keyrings for which the caller has I<search> permission may be searched."
msgstr ""

#. type: Plain text
#: man-pages/man2/request_key.2:70
msgid ""
"If the key is not found and I<callout> is NULL, then the call fails with the "
"error B<ENOKEY>."
msgstr ""

#. type: Plain text
#: man-pages/man2/request_key.2:76
msgid ""
"If the key is not found and I<callout> is not NULL, then the kernel attempts "
"to invoke a user-space program to instantiate the key.  The details are "
"given below."
msgstr ""

#. type: Plain text
#: man-pages/man2/request_key.2:82
msgid ""
"The I<dest_keyring> serial number may be that of a valid keyring for which "
"the caller has I<write> permission, or it may be one of the following "
"special keyring IDs:"
msgstr ""

#. type: TP
#: man-pages/man2/request_key.2:82 man-pages/man2/keyctl.2:81
#: man-pages/man2/add_key.2:68
#, no-wrap
msgid "B<KEY_SPEC_THREAD_KEYRING>"
msgstr ""

#. type: Plain text
#: man-pages/man2/request_key.2:86
msgid ""
"This specifies the caller's thread-specific keyring (see "
"B<thread-keyring>(7))."
msgstr ""

#. type: TP
#: man-pages/man2/request_key.2:86 man-pages/man2/keyctl.2:86
#: man-pages/man2/add_key.2:72
#, no-wrap
msgid "B<KEY_SPEC_PROCESS_KEYRING>"
msgstr ""

#. type: Plain text
#: man-pages/man2/request_key.2:90
msgid ""
"This specifies the caller's process-specific keyring (see "
"B<process-keyring>(7))."
msgstr ""

#. type: TP
#: man-pages/man2/request_key.2:90 man-pages/man2/keyctl.2:91
#: man-pages/man2/add_key.2:76
#, no-wrap
msgid "B<KEY_SPEC_SESSION_KEYRING>"
msgstr ""

#. type: Plain text
#: man-pages/man2/request_key.2:94
msgid ""
"This specifies the caller's session-specific keyring (see "
"B<session-keyring>(7))."
msgstr ""

#. type: TP
#: man-pages/man2/request_key.2:94 man-pages/man2/keyctl.2:96
#: man-pages/man2/add_key.2:80
#, no-wrap
msgid "B<KEY_SPEC_USER_KEYRING>"
msgstr ""

#. type: Plain text
#: man-pages/man2/request_key.2:98
msgid "This specifies the caller's UID-specific keyring (see B<user-keyring>(7))."
msgstr ""

#. type: TP
#: man-pages/man2/request_key.2:98 man-pages/man2/keyctl.2:101
#: man-pages/man2/add_key.2:84
#, no-wrap
msgid "B<KEY_SPEC_USER_SESSION_KEYRING>"
msgstr ""

#. type: Plain text
#: man-pages/man2/request_key.2:102
msgid ""
"This specifies the caller's UID-session keyring (see "
"B<user-session-keyring>(7))."
msgstr ""

#. type: Plain text
#: man-pages/man2/request_key.2:108
msgid ""
"When the I<dest_keyring> is specified as 0 and no key construction has been "
"performed, then no additional linking is done."
msgstr ""

#. type: Plain text
#: man-pages/man2/request_key.2:121
msgid ""
"Otherwise, if I<dest_keyring> is 0 and a new key is constructed, the new key "
"will be linked to the \"default\" keyring.  More precisely, when the kernel "
"tries to determine to which keyring the newly constructed key should be "
"linked, it tries the following keyrings, beginning with the keyring set via "
"the B<keyctl>(2)  B<KEYCTL_SET_REQKEY_KEYRING> operation and continuing in "
"the order shown below until it finds the first keyring that exists:"
msgstr ""

#.  8bbf4976b59fc9fc2861e79cab7beb3f6d647640
#.  FIXME
#.  Actually, is the preceding point correct?
#.  If I understand correctly, we'll only get here if
#.  'dest_keyring' is zero, in which case KEY_REQKEY_DEFL_REQUESTOR_KEYRING
#.  won't refer to a keyring. Have I misunderstood?
#. type: Plain text
#: man-pages/man2/request_key.2:131
msgid ""
"The requestor keyring (B<KEY_REQKEY_DEFL_REQUESTOR_KEYRING>, since Linux "
"2.6.29)."
msgstr ""

#. type: Plain text
#: man-pages/man2/request_key.2:136
msgid ""
"The thread-specific keyring (B<KEY_REQKEY_DEFL_THREAD_KEYRING>; see "
"B<thread-keyring>(7))."
msgstr ""

#. type: Plain text
#: man-pages/man2/request_key.2:141
msgid ""
"The process-specific keyring (B<KEY_REQKEY_DEFL_PROCESS_KEYRING>; see "
"B<process-keyring>(7))."
msgstr ""

#. type: Plain text
#: man-pages/man2/request_key.2:146
msgid ""
"The session-specific keyring (B<KEY_REQKEY_DEFL_SESSION_KEYRING>; see "
"B<session-keyring>(7))."
msgstr ""

#. type: Plain text
#: man-pages/man2/request_key.2:152
msgid ""
"The session keyring for the process's user ID "
"(B<KEY_REQKEY_DEFL_USER_SESSION_KEYRING>; see B<user-session-keyring>(7)).  "
"This keyring is expected to always exist."
msgstr ""

#.  mtk: Are there circumstances where the user sessions and UID-specific
#.  keyrings do not exist?
#
#.  David Howells:
#.      The uid keyrings don't exist until someone tries to access them -
#.      at which point they're both created.  When you log in, pam_keyinit
#.      creates a link to your user keyring in the session keyring it just
#.      created, thereby creating the user and user-session keyrings.
#
#.  and David elaborated that "access" means:
#
#.      It means lookup_user_key() was passed KEY_LOOKUP_CREATE.  So:
#
#.          add_key() - destination keyring
#.          request_key() - destination keyring
#.          KEYCTL_GET_KEYRING_ID - if create arg is true
#.          KEYCTL_CLEAR
#.          KEYCTL_LINK - both args
#.          KEYCTL_SEARCH - destination keyring
#.          KEYCTL_CHOWN
#.          KEYCTL_SETPERM
#.          KEYCTL_SET_TIMEOUT
#.          KEYCTL_INSTANTIATE - destination keyring
#.          KEYCTL_INSTANTIATE_IOV - destination keyring
#.          KEYCTL_NEGATE - destination keyring
#.          KEYCTL_REJECT - destination keyring
#.          KEYCTL_GET_PERSISTENT - destination keyring
#
#.      will all create a keyring under some circumstances.  Whereas the rest,
#.      such as KEYCTL_GET_SECURITY, KEYCTL_READ and KEYCTL_REVOKE, won't.
#. type: Plain text
#: man-pages/man2/request_key.2:188
msgid ""
"The UID-specific keyring (B<KEY_REQKEY_DEFL_USER_KEYRING>; see "
"B<user-keyring>(7)).  This keyring is also expected to always exist."
msgstr ""

#. type: Plain text
#: man-pages/man2/request_key.2:200
msgid ""
"If the B<keyctl>(2)  B<KEYCTL_SET_REQKEY_KEYRING> operation specifies "
"B<KEY_REQKEY_DEFL_DEFAULT> (or no B<KEYCTL_SET_REQKEY_KEYRING> operation is "
"performed), then the kernel looks for a keyring starting from the beginning "
"of the list."
msgstr ""

#. type: SS
#: man-pages/man2/request_key.2:200
#, no-wrap
msgid "Requesting user-space instantiation of a key"
msgstr ""

#. type: Plain text
#: man-pages/man2/request_key.2:213
msgid ""
"If the kernel cannot find a key matching I<type> and I<description>, and "
"I<callout> is not NULL, then the kernel attempts to invoke a user-space "
"program to instantiate a key with the given I<type> and I<description>.  In "
"this case, the following steps are performed:"
msgstr ""

#. type: IP
#: man-pages/man2/request_key.2:213 man-pages/man2/ptrace.2:2593
#, no-wrap
msgid "a)"
msgstr ""

#. type: Plain text
#: man-pages/man2/request_key.2:218
msgid ""
"The kernel creates an uninstantiated key, U, with the requested I<type> and "
"I<description>."
msgstr ""

#. type: IP
#: man-pages/man2/request_key.2:218 man-pages/man2/ptrace.2:2605
#, no-wrap
msgid "b)"
msgstr ""

#.  struct request_key_auth, defined in security/keys/internal.h
#. type: Plain text
#: man-pages/man2/request_key.2:224
msgid ""
"The kernel creates an authorization key, V, that refers to the key U and "
"records the facts that the caller of B<request_key>()  is:"
msgstr ""

#. type: IP
#: man-pages/man2/request_key.2:225
#, no-wrap
msgid "(1)"
msgstr ""

#. type: Plain text
#: man-pages/man2/request_key.2:227
msgid "the context in which the key U should be instantiated and secured, and"
msgstr ""

#. type: IP
#: man-pages/man2/request_key.2:227
#, no-wrap
msgid "(2)"
msgstr ""

#. type: Plain text
#: man-pages/man2/request_key.2:229
msgid "the context from which associated key requests may be satisfied."
msgstr ""

#. type: Plain text
#: man-pages/man2/request_key.2:232
msgid "The authorization key is constructed as follows:"
msgstr ""

#. type: Plain text
#: man-pages/man2/request_key.2:236
msgid "The key type is I<\".request_key_auth\">."
msgstr ""

#. type: Plain text
#: man-pages/man2/request_key.2:239
msgid ""
"The key's UID and GID are the same as the corresponding filesystem IDs of "
"the requesting process."
msgstr ""

#. type: Plain text
#: man-pages/man2/request_key.2:248
msgid ""
"The key grants I<view>, I<read>, and I<search> permissions to the key "
"possessor as well as I<view> permission for the key user."
msgstr ""

#. type: Plain text
#: man-pages/man2/request_key.2:252
msgid ""
"The description (name) of the key is the hexadecimal string representing the "
"ID of the key that is to be instantiated in the requesting program."
msgstr ""

#. type: Plain text
#: man-pages/man2/request_key.2:255
msgid "The payload of the key is taken from the data specified in I<callout_info>."
msgstr ""

#. type: Plain text
#: man-pages/man2/request_key.2:258
msgid ""
"Internally, the kernel also records the PID of the process that called "
"B<request_key>()."
msgstr ""

#. type: IP
#: man-pages/man2/request_key.2:259
#, no-wrap
msgid "c)"
msgstr ""

#.  The request-key(8) program can be invoked in circumstances *other* than
#.  when triggered by request_key(2). For example, upcalls from places such
#.  as the DNS resolver.
#. type: Plain text
#: man-pages/man2/request_key.2:266
msgid ""
"The kernel creates a process that executes a user-space service such as "
"B<request-key>(8)  with a new session keyring that contains a link to the "
"authorization key, V."
msgstr ""

#. type: Plain text
#: man-pages/man2/request_key.2:268
msgid "This program is supplied with the following command-line arguments:"
msgstr ""

#. type: IP
#: man-pages/man2/request_key.2:269
#, no-wrap
msgid "[0]"
msgstr ""

#. type: Plain text
#: man-pages/man2/request_key.2:272
msgid "The string I<\"/sbin/request-key\">."
msgstr ""

#. type: Plain text
#: man-pages/man2/request_key.2:276
msgid "The string I<\"create\"> (indicating that a key is to be created)."
msgstr ""

#. type: Plain text
#: man-pages/man2/request_key.2:278
msgid "The ID of the key that is to be instantiated."
msgstr ""

#. type: IP
#: man-pages/man2/request_key.2:278 man-pages/man2/syscall.2:232
#, no-wrap
msgid "[3]"
msgstr ""

#. type: Plain text
#: man-pages/man2/request_key.2:281
msgid "The filesystem UID of the caller of B<request_key>()."
msgstr ""

#. type: IP
#: man-pages/man2/request_key.2:281 man-pages/man2/syscall.2:238
#, no-wrap
msgid "[4]"
msgstr ""

#. type: Plain text
#: man-pages/man2/request_key.2:284
msgid "The filesystem GID of the caller of B<request_key>()."
msgstr ""

#. type: IP
#: man-pages/man2/request_key.2:284 man-pages/man2/syscall.2:248
#, no-wrap
msgid "[5]"
msgstr ""

#. type: Plain text
#: man-pages/man2/request_key.2:288
msgid ""
"The ID of the thread keyring of the caller of B<request_key>().  This may be "
"zero if that keyring hasn't been created."
msgstr ""

#. type: IP
#: man-pages/man2/request_key.2:288 man-pages/man2/syscall.2:288
#, no-wrap
msgid "[6]"
msgstr ""

#. type: Plain text
#: man-pages/man2/request_key.2:292
msgid ""
"The ID of the process keyring of the caller of B<request_key>().  This may "
"be zero if that keyring hasn't been created."
msgstr ""

#. type: IP
#: man-pages/man2/request_key.2:292
#, no-wrap
msgid "[7]"
msgstr ""

#. type: Plain text
#: man-pages/man2/request_key.2:295
msgid "The ID of the session keyring of the caller of B<request_key>()."
msgstr ""

#. type: Plain text
#: man-pages/man2/request_key.2:303
msgid ""
"I<Note>: each of the command-line arguments that is a key ID is encoded in "
"I<decimal> (unlike the key IDs shown in I</proc/keys>, which are shown as "
"hexadecimal values)."
msgstr ""

#. type: IP
#: man-pages/man2/request_key.2:303
#, no-wrap
msgid "d)"
msgstr ""

#. type: Plain text
#: man-pages/man2/request_key.2:305
msgid "The program spawned in the previous step:"
msgstr ""

#. type: Plain text
#: man-pages/man2/request_key.2:313
msgid ""
"Assumes the authority to instantiate the key U using the B<keyctl>(2)  "
"B<KEYCTL_ASSUME_AUTHORITY> operation (typically via the "
"B<keyctl_assume_authority>(3)  function)."
msgstr ""

#. type: Plain text
#: man-pages/man2/request_key.2:322
msgid ""
"Obtains the callout data from the payload of the authorization key V (using "
"the B<keyctl>(2)  B<KEYCTL_READ> operation (or, more commonly, the "
"B<keyctl_read>(3)  function) with a key ID value of "
"B<KEY_SPEC_REQKEY_AUTH_KEY>)."
msgstr ""

#.  Should an instantiating program be using KEY_SPEC_REQUESTOR_KEYRING?
#.  I couldn't find a use in the keyutils git repo.
#.  According to David Howells:
#.  * This feature is provided, but not used at the moment.
#.  * A key added to that ring is then owned by the requester
#. type: Plain text
#: man-pages/man2/request_key.2:344
msgid ""
"Instantiates the key (or execs another program that performs that task), "
"specifying the payload and destination keyring.  (The destination keyring "
"that the requestor specified when calling B<request_key>()  can be accessed "
"using the special key ID B<KEY_SPEC_REQUESTOR_KEYRING>.)  Instantiation is "
"performed using the B<keyctl>(2)  B<KEYCTL_INSTANTIATE> operation (or, more "
"commonly, the B<keyctl_instantiate>(3)  function).  At this point, the "
"B<request_key>()  call completes, and the requesting program can continue "
"execution."
msgstr ""

#. type: Plain text
#: man-pages/man2/request_key.2:361
msgid ""
"If these steps are unsuccessful, then an B<ENOKEY> error will be returned to "
"the caller of B<request_key>()  and a temporary, negatively instantiated key "
"will be installed in the keyring specified by I<dest_keyring>.  This will "
"expire after a few seconds, but will cause subsequent calls to "
"B<request_key>()  to fail until it does.  The purpose of this negatively "
"instantiated key is to prevent (possibly different) processes making "
"repeated requests (that require expensive B<request-key>(8)  upcalls) for a "
"key that can't (at the moment) be positively instantiated."
msgstr ""

#. type: Plain text
#: man-pages/man2/request_key.2:369
msgid ""
"Once the key has been instantiated, the authorization key "
"(B<KEY_SPEC_REQKEY_AUTH_KEY>)  is revoked, and the destination keyring "
"(B<KEY_SPEC_REQUESTOR_KEYRING>)  is no longer accessible from the "
"B<request-key>(8)  program."
msgstr ""

#. type: Plain text
#: man-pages/man2/request_key.2:374
msgid ""
"If a key is created, then\\(emregardless of whether it is a valid key or a "
"negatively instantiated key\\(emit will displace any other key with the same "
"type and description from the keyring specified in I<dest_keyring>."
msgstr ""

#. type: Plain text
#: man-pages/man2/request_key.2:381
msgid ""
"On success, B<request_key>()  returns the serial number of the key it found "
"or caused to be created.  On error, -1 is returned and I<errno> is set to "
"indicate the cause of the error."
msgstr ""

#. type: Plain text
#: man-pages/man2/request_key.2:385 man-pages/man2/add_key.2:154
msgid "The keyring wasn't available for modification by the user."
msgstr ""

#. type: TP
#: man-pages/man2/request_key.2:385 man-pages/man2/mknod.2:169
#: man-pages/man2/rename.2:345 man-pages/man2/open.2:960
#: man-pages/man2/setxattr.2:115 man-pages/man2/symlink.2:156
#: man-pages/man2/keyctl.2:1685 man-pages/man2/write.2:164
#: man-pages/man2/add_key.2:154 man-pages/man2/link.2:204
#: man-pages/man2/mkdir.2:134
#, no-wrap
msgid "B<EDQUOT>"
msgstr ""

#. type: Plain text
#: man-pages/man2/request_key.2:389 man-pages/man2/add_key.2:158
msgid ""
"The key quota for this user would be exceeded by creating this key or "
"linking it to the keyring."
msgstr ""

#. type: Plain text
#: man-pages/man2/request_key.2:397
msgid ""
"One of I<type>, I<description>, or I<callout_info> points outside the "
"process's accessible address space."
msgstr ""

#. type: Plain text
#: man-pages/man2/request_key.2:401
msgid "The request was interrupted by a signal; see B<signal>(7)."
msgstr ""

#. type: Plain text
#: man-pages/man2/request_key.2:408 man-pages/man2/add_key.2:173
msgid ""
"The size of the string (including the terminating null byte) specified in "
"I<type> or I<description> exceeded the limit (32 bytes and 4096 bytes "
"respectively)."
msgstr ""

#. type: Plain text
#: man-pages/man2/request_key.2:413
msgid ""
"The size of the string (including the terminating null byte) specified in "
"I<callout_info> exceeded the system page size."
msgstr ""

#. type: TP
#: man-pages/man2/request_key.2:413 man-pages/man2/keyctl.2:1803
#: man-pages/man2/add_key.2:185
#, no-wrap
msgid "B<EKEYEXPIRED>"
msgstr ""

#. type: Plain text
#: man-pages/man2/request_key.2:416
msgid "An expired key was found, but no replacement could be obtained."
msgstr ""

#. type: TP
#: man-pages/man2/request_key.2:416 man-pages/man2/keyctl.2:1806
#, no-wrap
msgid "B<EKEYREJECTED>"
msgstr ""

#. type: Plain text
#: man-pages/man2/request_key.2:419
msgid "The attempt to generate a new key was rejected."
msgstr ""

#. type: TP
#: man-pages/man2/request_key.2:419 man-pages/man2/keyctl.2:1809
#: man-pages/man2/add_key.2:188
#, no-wrap
msgid "B<EKEYREVOKED>"
msgstr ""

#. type: Plain text
#: man-pages/man2/request_key.2:422
msgid "A revoked key was found, but no replacement could be obtained."
msgstr ""

#. type: TP
#: man-pages/man2/request_key.2:422 man-pages/man2/keyctl.2:1872
#: man-pages/man2/keyctl.2:1875 man-pages/man2/add_key.2:191
#, no-wrap
msgid "B<ENOKEY>"
msgstr ""

#. type: Plain text
#: man-pages/man2/request_key.2:425
msgid "No matching key was found."
msgstr ""

#. type: Plain text
#: man-pages/man2/request_key.2:428 man-pages/man2/add_key.2:197
msgid "Insufficient memory to create a key."
msgstr ""

#. type: Plain text
#: man-pages/man2/request_key.2:433
msgid "The I<type> argument started with a period (\\(aq.\\(aq)."
msgstr ""

#.  commit 3e30148c3d524a9c1c63ca28261bc24c457eb07a
#. type: Plain text
#: man-pages/man2/request_key.2:438
msgid ""
"This system call first appeared in Linux 2.6.10.  The ability to instantiate "
"keys upon request was added in Linux 2.6.13."
msgstr ""

#. type: Plain text
#: man-pages/man2/request_key.2:440 man-pages/man2/keyctl.2:1954
#: man-pages/man2/add_key.2:217
msgid "This system call is a nonstandard Linux extension."
msgstr ""

#. type: Plain text
#: man-pages/man2/request_key.2:447 man-pages/man2/add_key.2:224
msgid ""
"No wrapper for this system call is provided in glibc.  A wrapper is provided "
"in the I<libkeyutils> package.  When employing the wrapper in that library, "
"link with I<-lkeyutils>."
msgstr ""

#. type: Plain text
#: man-pages/man2/request_key.2:458
msgid ""
"The program below demonstrates the use of B<request_key>().  The I<type>, "
"I<description>, and I<callout_info> arguments for the system call are taken "
"from the values supplied in the command-line arguments.  The call specifies "
"the session keyring as the target keyring."
msgstr ""

#. type: Plain text
#: man-pages/man2/request_key.2:462
msgid ""
"In order to demonstrate this program, we first create a suitable entry in "
"the file I</etc/request-key.conf>."
msgstr ""

#. type: Plain text
#: man-pages/man2/request_key.2:469
#, no-wrap
msgid ""
"$ sudo sh\n"
"# B<echo 'create user mtk:* *   /bin/keyctl instantiate %k %c %S' \\e>\n"
"          B<E<gt> /etc/request-key.conf>\n"
"# B<exit>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/request_key.2:496
msgid ""
"This entry specifies that when a new \"user\" key with the prefix \"mtk:\" "
"must be instantiated, that task should be performed via the B<keyctl>(1)  "
"command's B<instantiate> operation.  The arguments supplied to the "
"B<instantiate> operation are: the ID of the uninstantiated key (I<%k>); the "
"callout data supplied to the B<request_key>()  call (I<%c>); and the session "
"keyring (I<%S>)  of the requestor (i.e., the caller of B<request_key>()).  "
"See B<request-key.conf>(5)  for details of these I<%> specifiers."
msgstr ""

#. type: Plain text
#: man-pages/man2/request_key.2:500
msgid ""
"Then we run the program and check the contents of I</proc/keys> to verify "
"that the requested key has been instantiated:"
msgstr ""

#. type: Plain text
#: man-pages/man2/request_key.2:506
#, no-wrap
msgid ""
"$ B<./t_request_key user mtk:key1 \"Payload data\">\n"
"$ B<grep \\(aq2dddaf50\\(aq /proc/keys>\n"
"2dddaf50 I--Q---  1 perm 3f010000  1000  1000 user  mtk:key1: 12\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/request_key.2:511
msgid "For another example of the use of this program, see B<keyctl>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/request_key.2:515
#, no-wrap
msgid "/* t_request_key.c */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/request_key.2:521 man-pages/man2/add_key.2:246
#, no-wrap
msgid ""
"#include E<lt>sys/types.hE<gt>\n"
"#include E<lt>keyutils.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/request_key.2:526 man-pages/man2/add_key.2:251
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    key_serial_t key;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/request_key.2:532
#, no-wrap
msgid ""
"    if (argc != 4) {\n"
"        fprintf(stderr, \"Usage: %s type description callout-data\\en\",\n"
"                argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/request_key.2:539
#, no-wrap
msgid ""
"    key = request_key(argv[1], argv[2], argv[3],\n"
"                      KEY_SPEC_SESSION_KEYRING);\n"
"    if (key == -1) {\n"
"        perror(\"request_key\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/request_key.2:541 man-pages/man2/add_key.2:266
#, no-wrap
msgid "    printf(\"Key ID is %lx\\en\", (long) key);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/request_key.2:562
msgid ""
"B<keyctl>(1), B<add_key>(2), B<keyctl>(2), B<keyctl>(3), B<capabilities>(7), "
"B<keyrings>(7), B<keyutils>(7), B<persistent-keyring>(7), "
"B<process-keyring>(7), B<session-keyring>(7), B<thread-keyring>(7), "
"B<user-keyring>(7), B<user-session-keyring>(7), B<request-key>(8)"
msgstr ""

#.  commit b68101a1e8f0263dbc7b8375d2a7c57c6216fb76
#.  commit 3db38ed76890565772fcca3279cc8d454ea6176b
#. type: Plain text
#: man-pages/man2/request_key.2:572 man-pages/man2/add_key.2:295
msgid ""
"The kernel source files I<Documentation/security/keys/core.rst> and "
"I<Documentation/keys/request-key.rst> (or, before Linux 4.13, in the files "
"I<Documentation/security/keys.txt> and "
"I<Documentation/security/keys-request-key.txt>)."
msgstr ""

#. type: TH
#: man-pages/man2/set_mempolicy.2:27
#, no-wrap
msgid "SET_MEMPOLICY"
msgstr ""

#. type: Plain text
#: man-pages/man2/set_mempolicy.2:30
msgid "set_mempolicy - set default NUMA memory policy for a thread and its children"
msgstr ""

#. type: Plain text
#: man-pages/man2/set_mempolicy.2:33 man-pages/man2/move_pages.2:26
#: man-pages/man2/mbind.2:41 man-pages/man2/migrate_pages.2:24
#, no-wrap
msgid "B<#include E<lt>numaif.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/set_mempolicy.2:36
#, no-wrap
msgid ""
"B<long set_mempolicy(int >I<mode>B<, const unsigned long *>I<nodemask>B<,>\n"
"B<                   unsigned long >I<maxnode>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/set_mempolicy.2:38 man-pages/man2/mbind.2:47
#: man-pages/man2/get_mempolicy.2:39
#, no-wrap
msgid "Link with I<-lnuma>.\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/set_mempolicy.2:49
msgid ""
"B<set_mempolicy>()  sets the NUMA memory policy of the calling thread, which "
"consists of a policy mode and zero or more nodes, to the values specified by "
"the I<mode>, I<nodemask> and I<maxnode> arguments."
msgstr ""

#. type: Plain text
#: man-pages/man2/set_mempolicy.2:54 man-pages/man2/get_mempolicy.2:50
msgid ""
"A NUMA machine has different memory controllers with different distances to "
"specific CPUs.  The memory policy defines from which node memory is "
"allocated for the thread."
msgstr ""

#. type: Plain text
#: man-pages/man2/set_mempolicy.2:75
msgid ""
"This system call defines the default policy for the thread.  The thread "
"policy governs allocation of pages in the process's address space outside of "
"memory ranges controlled by a more specific policy set by B<mbind>(2).  The "
"thread default policy also controls allocation of any pages for "
"memory-mapped files mapped using the B<mmap>(2)  call with the "
"B<MAP_PRIVATE> flag and that are only read (loaded) from by the thread and "
"of memory-mapped files mapped using the B<mmap>(2)  call with the "
"B<MAP_SHARED> flag, regardless of the access type.  The policy is applied "
"only when a new page is allocated for the thread.  For anonymous memory this "
"is when the page is first touched by the thread."
msgstr ""

#. type: Plain text
#: man-pages/man2/set_mempolicy.2:92
msgid ""
"The I<mode> argument must specify one of B<MPOL_DEFAULT>, B<MPOL_BIND>, "
"B<MPOL_INTERLEAVE>, B<MPOL_PREFERRED>, or B<MPOL_LOCAL> (which are described "
"in detail below).  All modes except B<MPOL_DEFAULT> require the caller to "
"specify the node or nodes to which the mode applies, via the I<nodemask> "
"argument."
msgstr ""

#. type: Plain text
#: man-pages/man2/set_mempolicy.2:100 man-pages/man2/mbind.2:141
msgid ""
"The I<mode> argument may also include an optional I<mode flag>.  The "
"supported I<mode flags> are:"
msgstr ""

#. type: TP
#: man-pages/man2/set_mempolicy.2:100
#, no-wrap
msgid "B<MPOL_F_STATIC_NODES> (since Linux 2.6.26)"
msgstr ""

#. type: Plain text
#: man-pages/man2/set_mempolicy.2:110
msgid ""
"A nonempty I<nodemask> specifies physical node IDs.  Linux will not remap "
"the I<nodemask> when the process moves to a different cpuset context, nor "
"when the set of nodes allowed by the process's current cpuset context "
"changes."
msgstr ""

#. type: TP
#: man-pages/man2/set_mempolicy.2:110
#, no-wrap
msgid "B<MPOL_F_RELATIVE_NODES> (since Linux 2.6.26)"
msgstr ""

#. type: Plain text
#: man-pages/man2/set_mempolicy.2:116
msgid ""
"A nonempty I<nodemask> specifies node IDs that are relative to the set of "
"node IDs allowed by the process's current cpuset."
msgstr ""

#. type: Plain text
#: man-pages/man2/set_mempolicy.2:136
msgid ""
"I<nodemask> points to a bit mask of node IDs that contains up to I<maxnode> "
"bits.  The bit mask size is rounded to the next multiple of "
"I<sizeof(unsigned long)>, but the kernel will use bits only up to "
"I<maxnode>.  A NULL value of I<nodemask> or a I<maxnode> value of zero "
"specifies the empty set of nodes.  If the value of I<maxnode> is zero, the "
"I<nodemask> argument is ignored."
msgstr ""

#. type: Plain text
#: man-pages/man2/set_mempolicy.2:157
msgid ""
"Where a I<nodemask> is required, it must contain at least one node that is "
"on-line, allowed by the process's current cpuset context, (unless the "
"B<MPOL_F_STATIC_NODES> mode flag is specified), and contains memory.  If the "
"B<MPOL_F_STATIC_NODES> is set in I<mode> and a required I<nodemask> contains "
"no nodes that are allowed by the process's current cpuset context, the "
"memory policy reverts to I<local allocation>.  This effectively overrides "
"the specified policy until the process's cpuset context includes one or more "
"of the nodes specified by I<nodemask>."
msgstr ""

#. type: Plain text
#: man-pages/man2/set_mempolicy.2:161 man-pages/man2/mbind.2:189
msgid "The I<mode> argument must include one of the following values:"
msgstr ""

#. type: TP
#: man-pages/man2/set_mempolicy.2:161 man-pages/man2/mbind.2:189
#, no-wrap
msgid "B<MPOL_DEFAULT>"
msgstr ""

#. type: Plain text
#: man-pages/man2/set_mempolicy.2:171
msgid ""
"This mode specifies that any nondefault thread memory policy be removed, so "
"that the memory policy \"falls back\" to the system default policy.  The "
"system default policy is \"local allocation\"\\(emthat is, allocate memory "
"on the node of the CPU that triggered the allocation.  I<nodemask> must be "
"specified as NULL.  If the \"local node\" contains no free memory, the "
"system will attempt to allocate memory from a \"near by\" node."
msgstr ""

#. type: TP
#: man-pages/man2/set_mempolicy.2:171 man-pages/man2/mbind.2:210
#, no-wrap
msgid "B<MPOL_BIND>"
msgstr ""

#. type: Plain text
#: man-pages/man2/set_mempolicy.2:187
msgid ""
"This mode defines a strict policy that restricts memory allocation to the "
"nodes specified in I<nodemask>.  If I<nodemask> specifies more than one "
"node, page allocations will come from the node with the lowest numeric node "
"ID first, until that node contains no free memory.  Allocations will then "
"come from the node with the next highest node ID specified in I<nodemask> "
"and so forth, until none of the specified nodes contain free memory.  Pages "
"will not be allocated from any node not specified in the I<nodemask>."
msgstr ""

#. type: TP
#: man-pages/man2/set_mempolicy.2:188 man-pages/man2/mbind.2:231
#, no-wrap
msgid "B<MPOL_INTERLEAVE>"
msgstr ""

#.  NOTE:  the following sentence doesn't make sense in the context
#.  of set_mempolicy() -- no memory area specified.
#.  To be effective the memory area should be fairly large,
#.  at least 1 MB or bigger.
#. type: Plain text
#: man-pages/man2/set_mempolicy.2:202
msgid ""
"This mode interleaves page allocations across the nodes specified in "
"I<nodemask> in numeric node ID order.  This optimizes for bandwidth instead "
"of latency by spreading out pages and memory accesses to those pages across "
"multiple nodes.  However, accesses to a single page will still be limited to "
"the memory bandwidth of a single node."
msgstr ""

#. type: TP
#: man-pages/man2/set_mempolicy.2:202 man-pages/man2/mbind.2:243
#, no-wrap
msgid "B<MPOL_PREFERRED>"
msgstr ""

#. type: Plain text
#: man-pages/man2/set_mempolicy.2:219
msgid ""
"This mode sets the preferred node for allocation.  The kernel will try to "
"allocate pages from this node first and fall back to \"near by\" nodes if "
"the preferred node is low on free memory.  If I<nodemask> specifies more "
"than one node ID, the first node in the mask will be selected as the "
"preferred node.  If the I<nodemask> and I<maxnode> arguments specify the "
"empty set, then the policy specifies \"local allocation\" (like the system "
"default policy discussed above)."
msgstr ""

#. type: TP
#: man-pages/man2/set_mempolicy.2:219 man-pages/man2/mbind.2:259
#, no-wrap
msgid "B<MPOL_LOCAL> (since Linux 3.8)"
msgstr ""

#.  commit 479e2802d09f1e18a97262c4c6f8f17ae5884bd8
#.  commit f2a07f40dbc603c15f8b06e6ec7f768af67b424f
#. type: Plain text
#: man-pages/man2/set_mempolicy.2:238
msgid ""
"This mode specifies \"local allocation\"; the memory is allocated on the "
"node of the CPU that triggered the allocation (the \"local node\").  The "
"I<nodemask> and I<maxnode> arguments must specify the empty set.  If the "
"\"local node\" is low on free memory, the kernel will try to allocate memory "
"from other nodes.  The kernel will allocate memory from the \"local node\" "
"whenever memory for this node is available.  If the \"local node\" is not "
"allowed by the process's current cpuset context, the kernel will try to "
"allocate memory from other nodes.  The kernel will allocate memory from the "
"\"local node\" whenever it becomes allowed by the process's current cpuset "
"context."
msgstr ""

#. type: Plain text
#: man-pages/man2/set_mempolicy.2:245
msgid ""
"The thread memory policy is preserved across an B<execve>(2), and is "
"inherited by child threads created using B<fork>(2)  or B<clone>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/set_mempolicy.2:252
msgid ""
"On success, B<set_mempolicy>()  returns 0; on error, -1 is returned and "
"I<errno> is set to indicate the error."
msgstr ""

#. type: Plain text
#: man-pages/man2/set_mempolicy.2:260 man-pages/man2/get_mempolicy.2:191
msgid ""
"Part of all of the memory range specified by I<nodemask> and I<maxnode> "
"points outside your accessible address space."
msgstr ""

#. type: Plain text
#: man-pages/man2/set_mempolicy.2:297
msgid ""
"I<mode> is invalid.  Or, I<mode> is B<MPOL_DEFAULT> and I<nodemask> is "
"nonempty, or I<mode> is B<MPOL_BIND> or B<MPOL_INTERLEAVE> and I<nodemask> "
"is empty.  Or, I<maxnode> specifies more than a page worth of bits.  Or, "
"I<nodemask> specifies one or more node IDs that are greater than the maximum "
"supported node ID.  Or, none of the node IDs specified by I<nodemask> are "
"on-line and allowed by the process's current cpuset context, or none of the "
"specified nodes contain memory.  Or, the I<mode> argument specified both "
"B<MPOL_F_STATIC_NODES> and B<MPOL_F_RELATIVE_NODES>."
msgstr ""

#. type: Plain text
#: man-pages/man2/set_mempolicy.2:304
msgid ""
"The B<set_mempolicy>()  system call was added to the Linux kernel in version "
"2.6.7."
msgstr ""

#. type: Plain text
#: man-pages/man2/set_mempolicy.2:311
msgid ""
"Memory policy is not remembered if the page is swapped out.  When such a "
"page is paged back in, it will use the policy of the thread or memory range "
"that is in effect at the time the page is allocated."
msgstr ""

#. type: Plain text
#: man-pages/man2/set_mempolicy.2:314 man-pages/man2/move_pages.2:219
#: man-pages/man2/mbind.2:430 man-pages/man2/get_mempolicy.2:244
#: man-pages/man2/migrate_pages.2:145
msgid "For information on library support, see B<numa>(7)."
msgstr ""

#. type: Plain text
#: man-pages/man2/set_mempolicy.2:322
msgid ""
"B<get_mempolicy>(2), B<getcpu>(2), B<mbind>(2), B<mmap>(2), B<numa>(3), "
"B<cpuset>(7), B<numa>(7), B<numactl>(8)"
msgstr ""

#. type: TH
#: man-pages/man2/statx.2:31
#, no-wrap
msgid "STATX"
msgstr ""

#. type: Plain text
#: man-pages/man2/statx.2:34
msgid "statx - get file status (extended)"
msgstr ""

#. type: Plain text
#: man-pages/man2/statx.2:40
#, no-wrap
msgid ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>sys/stat.hE<gt>>\n"
"B<#include E<lt>unistd.hE<gt>>\n"
"B<#include E<lt>fcntl.hE<gt>           >/* Definition of AT_* constants */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/statx.2:43
#, no-wrap
msgid ""
"B<int statx(int >I<dirfd>B<, const char *>I<pathname>B<, int >I<flags>B<,>\n"
"B<          unsigned int >I<mask>B<, struct statx *>I<statxbuf>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/statx.2:51
msgid ""
"This function returns information about a file, storing it in the buffer "
"pointed to by I<statxbuf>.  The returned buffer is a structure of the "
"following type:"
msgstr ""

#. type: Plain text
#: man-pages/man2/statx.2:69
#, no-wrap
msgid ""
"struct statx {\n"
"    __u32 stx_mask;        /* Mask of bits indicating\n"
"                              filled fields */\n"
"    __u32 stx_blksize;     /* Block size for filesystem I/O */\n"
"    __u64 stx_attributes;  /* Extra file attribute indicators */\n"
"    __u32 stx_nlink;       /* Number of hard links */\n"
"    __u32 stx_uid;         /* User ID of owner */\n"
"    __u32 stx_gid;         /* Group ID of owner */\n"
"    __u16 stx_mode;        /* File type and mode */\n"
"    __u64 stx_ino;         /* Inode number */\n"
"    __u64 stx_size;        /* Total size in bytes */\n"
"    __u64 stx_blocks;      /* Number of 512B blocks allocated */\n"
"    __u64 stx_attributes_mask;\n"
"                           /* Mask to show what's supported\n"
"                              in stx_attributes */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/statx.2:75
#, no-wrap
msgid ""
"    /* The following fields are file timestamps */\n"
"    struct statx_timestamp stx_atime;  /* Last access */\n"
"    struct statx_timestamp stx_btime;  /* Creation */\n"
"    struct statx_timestamp stx_ctime;  /* Last status change */\n"
"    struct statx_timestamp stx_mtime;  /* Last modification */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/statx.2:80
#, no-wrap
msgid ""
"    /* If this file represents a device, then the next two\n"
"       fields contain the ID of the device */\n"
"    __u32 stx_rdev_major;  /* Major ID */\n"
"    __u32 stx_rdev_minor;  /* Minor ID */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/statx.2:86
#, no-wrap
msgid ""
"    /* The next two fields contain the ID of the device\n"
"       containing the filesystem where the file resides */\n"
"    __u32 stx_dev_major;   /* Major ID */\n"
"    __u32 stx_dev_minor;   /* Minor ID */\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/statx.2:90
msgid "The file timestamps are structures of the following type:"
msgstr ""

#. type: Plain text
#: man-pages/man2/statx.2:97
#, no-wrap
msgid ""
"struct statx_timestamp {\n"
"    __s64 tv_sec;    /* Seconds since the Epoch (UNIX time) */\n"
"    __u32 tv_nsec;   /* Nanoseconds since tv_sec */\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/statx.2:101
msgid "(Note that reserved space and padding is omitted.)"
msgstr ""

#. type: SS
#: man-pages/man2/statx.2:101
#, no-wrap
msgid "Invoking statxR<():>"
msgstr ""

#. type: Plain text
#: man-pages/man2/statx.2:111
msgid ""
"To access a file's status, no permissions are required on the file itself, "
"but in the case of B<statx>()  with a pathname, execute (search) permission "
"is required on all of the directories in I<pathname> that lead to the file."
msgstr ""

#. type: Plain text
#: man-pages/man2/statx.2:119
msgid ""
"B<statx>()  uses I<pathname>, I<dirfd>, and I<flags> to identify the target "
"file in one of the following ways:"
msgstr ""

#. type: TP
#: man-pages/man2/statx.2:119
#, no-wrap
msgid "An absolute pathname"
msgstr ""

#. type: Plain text
#: man-pages/man2/statx.2:128
msgid ""
"If I<pathname> begins with a slash, then it is an absolute pathname that "
"identifies the target file.  In this case, I<dirfd> is ignored."
msgstr ""

#. type: TP
#: man-pages/man2/statx.2:128
#, no-wrap
msgid "A relative pathname"
msgstr ""

#. type: Plain text
#: man-pages/man2/statx.2:140
msgid ""
"If I<pathname> is a string that begins with a character other than a slash "
"and I<dirfd> is B<AT_FDCWD>, then I<pathname> is a relative pathname that is "
"interpreted relative to the process's current working directory."
msgstr ""

#. type: TP
#: man-pages/man2/statx.2:140
#, no-wrap
msgid "A directory-relative pathname"
msgstr ""

#. type: Plain text
#: man-pages/man2/statx.2:151
msgid ""
"If I<pathname> is a string that begins with a character other than a slash "
"and I<dirfd> is a file descriptor that refers to a directory, then "
"I<pathname> is a relative pathname that is interpreted relative to the "
"directory referred to by I<dirfd>."
msgstr ""

#. type: TP
#: man-pages/man2/statx.2:151
#, no-wrap
msgid "By file descriptor"
msgstr ""

#. type: Plain text
#: man-pages/man2/statx.2:162
msgid ""
"If I<pathname> is an empty string and the B<AT_EMPTY_PATH> flag is specified "
"in I<flags> (see below), then the target file is the one referred to by the "
"file descriptor I<dirfd>."
msgstr ""

#. type: Plain text
#: man-pages/man2/statx.2:168
msgid ""
"I<flags> can be used to influence a pathname-based lookup.  A value for "
"I<flags> is constructed by ORing together zero or more of the following "
"constants:"
msgstr ""

#.  commit 65cfc6722361570bfe255698d9cd4dccaf47570d
#. type: Plain text
#: man-pages/man2/statx.2:182
msgid ""
"If I<pathname> is an empty string, operate on the file referred to by "
"I<dirfd> (which may have been obtained using the B<open>(2)  B<O_PATH> "
"flag).  In this case, I<dirfd> can refer to any type of file, not just a "
"directory."
msgstr ""

#. type: Plain text
#: man-pages/man2/statx.2:188
msgid ""
"If I<dirfd> is B<AT_FDCWD>, the call operates on the current working "
"directory."
msgstr ""

#.  Before glibc 2.16, defining _ATFILE_SOURCE sufficed
#. type: Plain text
#: man-pages/man2/statx.2:193
msgid "This flag is Linux-specific; define B<_GNU_SOURCE> to obtain its definition."
msgstr ""

#. type: TP
#: man-pages/man2/statx.2:193
#, no-wrap
msgid "B<AT_NO_AUTOMOUNT>"
msgstr ""

#.  Before glibc 2.16, defining _ATFILE_SOURCE sufficed
#. type: Plain text
#: man-pages/man2/statx.2:209
msgid ""
"Don't automount the terminal (\"basename\") component of I<pathname> if it "
"is a directory that is an automount point.  This allows the caller to gather "
"attributes of an automount point (rather than the location it would mount).  "
"This flag can be used in tools that scan directories to prevent "
"mass-automounting of a directory of automount points.  The "
"B<AT_NO_AUTOMOUNT> flag has no effect if the mount point has already been "
"mounted over.  This flag is Linux-specific; define B<_GNU_SOURCE> to obtain "
"its definition."
msgstr ""

#. type: Plain text
#: man-pages/man2/statx.2:216
msgid ""
"If I<pathname> is a symbolic link, do not dereference it: instead return "
"information about the link itself, like B<lstat>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/statx.2:221
msgid ""
"I<flags> can also be used to control what sort of synchronization the kernel "
"will do when querying a file on a remote filesystem.  This is done by ORing "
"in one of the following values:"
msgstr ""

#. type: TP
#: man-pages/man2/statx.2:221
#, no-wrap
msgid "B<AT_STATX_SYNC_AS_STAT>"
msgstr ""

#. type: Plain text
#: man-pages/man2/statx.2:227
msgid ""
"Do whatever B<stat>(2)  does.  This is the default and is very much "
"filesystem-specific."
msgstr ""

#. type: TP
#: man-pages/man2/statx.2:227
#, no-wrap
msgid "B<AT_STATX_FORCE_SYNC>"
msgstr ""

#. type: Plain text
#: man-pages/man2/statx.2:232
msgid ""
"Force the attributes to be synchronized with the server.  This may require "
"that a network filesystem perform a data writeback to get the timestamps "
"correct."
msgstr ""

#. type: TP
#: man-pages/man2/statx.2:232
#, no-wrap
msgid "B<AT_STATX_DONT_SYNC>"
msgstr ""

#. type: Plain text
#: man-pages/man2/statx.2:239
msgid ""
"Don't synchronize anything, but rather just take whatever the system has "
"cached if possible.  This may mean that the information returned is "
"approximate, but, on a network filesystem, it may not involve a round trip "
"to the server - even if no lease is held."
msgstr ""

#. type: Plain text
#: man-pages/man2/statx.2:247
msgid ""
"The I<mask> argument to B<statx>()  is used to tell the kernel which fields "
"the caller is interested in.  I<mask> is an ORed combination of the "
"following constants:"
msgstr ""

#. type: tbl table
#: man-pages/man2/statx.2:251
#, no-wrap
msgid "STATX_TYPE"
msgstr ""

#. type: tbl table
#: man-pages/man2/statx.2:251
#, no-wrap
msgid "Want stx_mode & S_IFMT"
msgstr ""

#. type: tbl table
#: man-pages/man2/statx.2:252
#, no-wrap
msgid "STATX_MODE"
msgstr ""

#. type: tbl table
#: man-pages/man2/statx.2:252
#, no-wrap
msgid "Want stx_mode & ~S_IFMT"
msgstr ""

#. type: tbl table
#: man-pages/man2/statx.2:253
#, no-wrap
msgid "STATX_NLINK"
msgstr ""

#. type: tbl table
#: man-pages/man2/statx.2:253
#, no-wrap
msgid "Want stx_nlink"
msgstr ""

#. type: tbl table
#: man-pages/man2/statx.2:254
#, no-wrap
msgid "STATX_UID"
msgstr ""

#. type: tbl table
#: man-pages/man2/statx.2:254
#, no-wrap
msgid "Want stx_uid"
msgstr ""

#. type: tbl table
#: man-pages/man2/statx.2:255
#, no-wrap
msgid "STATX_GID"
msgstr ""

#. type: tbl table
#: man-pages/man2/statx.2:255
#, no-wrap
msgid "Want stx_gid"
msgstr ""

#. type: tbl table
#: man-pages/man2/statx.2:256
#, no-wrap
msgid "STATX_ATIME"
msgstr ""

#. type: tbl table
#: man-pages/man2/statx.2:256
#, no-wrap
msgid "Want stx_atime"
msgstr ""

#. type: tbl table
#: man-pages/man2/statx.2:257
#, no-wrap
msgid "STATX_MTIME"
msgstr ""

#. type: tbl table
#: man-pages/man2/statx.2:257
#, no-wrap
msgid "Want stx_mtime"
msgstr ""

#. type: tbl table
#: man-pages/man2/statx.2:258
#, no-wrap
msgid "STATX_CTIME"
msgstr ""

#. type: tbl table
#: man-pages/man2/statx.2:258
#, no-wrap
msgid "Want stx_ctime"
msgstr ""

#. type: tbl table
#: man-pages/man2/statx.2:259
#, no-wrap
msgid "STATX_INO"
msgstr ""

#. type: tbl table
#: man-pages/man2/statx.2:259
#, no-wrap
msgid "Want stx_ino"
msgstr ""

#. type: tbl table
#: man-pages/man2/statx.2:260
#, no-wrap
msgid "STATX_SIZE"
msgstr ""

#. type: tbl table
#: man-pages/man2/statx.2:260
#, no-wrap
msgid "Want stx_size"
msgstr ""

#. type: tbl table
#: man-pages/man2/statx.2:261
#, no-wrap
msgid "STATX_BLOCKS"
msgstr ""

#. type: tbl table
#: man-pages/man2/statx.2:261
#, no-wrap
msgid "Want stx_blocks"
msgstr ""

#. type: tbl table
#: man-pages/man2/statx.2:262
#, no-wrap
msgid "STATX_BASIC_STATS"
msgstr ""

#. type: tbl table
#: man-pages/man2/statx.2:262
#, no-wrap
msgid "[All of the above]"
msgstr ""

#. type: tbl table
#: man-pages/man2/statx.2:263
#, no-wrap
msgid "STATX_BTIME"
msgstr ""

#. type: tbl table
#: man-pages/man2/statx.2:263
#, no-wrap
msgid "Want stx_btime"
msgstr ""

#. type: tbl table
#: man-pages/man2/statx.2:264
#, no-wrap
msgid "STATX_ALL"
msgstr ""

#. type: tbl table
#: man-pages/man2/statx.2:264
#, no-wrap
msgid "[All currently available fields]"
msgstr ""

#. type: Plain text
#: man-pages/man2/statx.2:289
msgid ""
"Note that, in general, the kernel does I<not> reject values in I<mask> other "
"than the above.  (For an exception, see B<EINVAL> in errors.)  Instead, it "
"simply informs the caller which values are supported by this kernel and "
"filesystem via the I<statx.stx_mask> field.  Therefore, I<do not> simply set "
"I<mask> to B<UINT_MAX> (all bits set), as one or more bits may, in the "
"future, be used to specify an extension to the buffer."
msgstr ""

#. type: SS
#: man-pages/man2/statx.2:289
#, no-wrap
msgid "The returned information"
msgstr ""

#. type: Plain text
#: man-pages/man2/statx.2:304
msgid ""
"The status information for the target file is returned in the I<statx> "
"structure pointed to by I<statxbuf>.  Included in this is I<stx_mask> which "
"indicates what other information has been returned.  I<stx_mask> has the "
"same format as the I<mask> argument and bits are set in it to indicate which "
"fields have been filled in."
msgstr ""

#. type: Plain text
#: man-pages/man2/statx.2:313
msgid ""
"It should be noted that the kernel may return fields that weren't requested "
"and may fail to return fields that were requested, depending on what the "
"backing filesystem supports.  (Fields that are given values despite being "
"unrequested can just be ignored.)  In either case, I<stx_mask> will not be "
"equal I<mask>."
msgstr ""

#. type: Plain text
#: man-pages/man2/statx.2:321
msgid ""
"If a filesystem does not support a field or if it has an unrepresentable "
"value (for instance, a file with an exotic type), then the mask bit "
"corresponding to that field will be cleared in I<stx_mask> even if the user "
"asked for it and a dummy value will be filled in for compatibility purposes "
"if one is available (e.g., a dummy UID and GID may be specified to mount "
"under some circumstances)."
msgstr ""

#. type: Plain text
#: man-pages/man2/statx.2:326
msgid ""
"A filesystem may also fill in fields that the caller didn't ask for if it "
"has values for them available and the information is available at no extra "
"cost.  If this happens, the corresponding bits will be set in I<stx_mask>."
msgstr ""

#.  Background: inode attributes are modified with i_mutex held, but
#.  read by stat() without taking the mutex.
#. type: Plain text
#: man-pages/man2/statx.2:351
msgid ""
"I<Note>: for performance and simplicity reasons, different fields in the "
"I<statx> structure may contain state information from different moments "
"during the execution of the system call.  For example, if I<stx_mode> or "
"I<stx_uid> is changed by another process by calling B<chmod>(2)  or "
"B<chown>(2), B<stat>()  might return the old I<stx_mode> together with the "
"new I<stx_uid>, or the old I<stx_uid> together with the new I<stx_mode>."
msgstr ""

#. type: Plain text
#: man-pages/man2/statx.2:357
msgid ""
"Apart from I<stx_mask> (which is described above), the fields in the "
"I<statx> structure are:"
msgstr ""

#. type: TP
#: man-pages/man2/statx.2:357
#, no-wrap
msgid "I<stx_blksize>"
msgstr ""

#. type: Plain text
#: man-pages/man2/statx.2:362
msgid ""
"The \"preferred\" block size for efficient filesystem I/O.  (Writing to a "
"file in smaller chunks may cause an inefficient read-modify-rewrite.)"
msgstr ""

#. type: TP
#: man-pages/man2/statx.2:362
#, no-wrap
msgid "I<stx_attributes>"
msgstr ""

#. type: Plain text
#: man-pages/man2/statx.2:365
msgid "Further status information about the file (see below for more information)."
msgstr ""

#. type: TP
#: man-pages/man2/statx.2:365
#, no-wrap
msgid "I<stx_nlink>"
msgstr ""

#. type: Plain text
#: man-pages/man2/statx.2:368
msgid "The number of hard links on a file."
msgstr ""

#. type: TP
#: man-pages/man2/statx.2:368
#, no-wrap
msgid "I<stx_uid>"
msgstr ""

#. type: Plain text
#: man-pages/man2/statx.2:371 man-pages/man2/stat.2:225
msgid "This field contains the user ID of the owner of the file."
msgstr ""

#. type: TP
#: man-pages/man2/statx.2:371
#, no-wrap
msgid "I<stx_gid>"
msgstr ""

#. type: Plain text
#: man-pages/man2/statx.2:374 man-pages/man2/stat.2:228
msgid "This field contains the ID of the group owner of the file."
msgstr ""

#. type: TP
#: man-pages/man2/statx.2:374
#, no-wrap
msgid "I<stx_mode>"
msgstr ""

#. type: Plain text
#: man-pages/man2/statx.2:380
msgid "The file type and mode.  See B<inode>(7)  for details."
msgstr ""

#. type: TP
#: man-pages/man2/statx.2:380
#, no-wrap
msgid "I<stx_ino>"
msgstr ""

#. type: Plain text
#: man-pages/man2/statx.2:383
msgid "The inode number of the file."
msgstr ""

#. type: TP
#: man-pages/man2/statx.2:383
#, no-wrap
msgid "I<stx_size>"
msgstr ""

#. type: Plain text
#: man-pages/man2/statx.2:388
msgid ""
"The size of the file (if it is a regular file or a symbolic link) in bytes.  "
"The size of a symbolic link is the length of the pathname it contains, "
"without a terminating null byte."
msgstr ""

#. type: TP
#: man-pages/man2/statx.2:388
#, no-wrap
msgid "I<stx_blocks>"
msgstr ""

#. type: Plain text
#: man-pages/man2/statx.2:394
msgid ""
"The number of blocks allocated to the file on the medium, in 512-byte "
"units.  (This may be smaller than I<stx_size>/512 when the file has holes.)"
msgstr ""

#. type: TP
#: man-pages/man2/statx.2:394
#, no-wrap
msgid "I<stx_attributes_mask>"
msgstr ""

#. type: Plain text
#: man-pages/man2/statx.2:399
msgid ""
"A mask indicating which bits in I<stx_attributes> are supported by the VFS "
"and the filesystem."
msgstr ""

#. type: TP
#: man-pages/man2/statx.2:399
#, no-wrap
msgid "I<stx_atime>"
msgstr ""

#. type: Plain text
#: man-pages/man2/statx.2:402
msgid "The file's last access timestamp."
msgstr ""

#. type: TP
#: man-pages/man2/statx.2:402
#, no-wrap
msgid "I<stx_btime>"
msgstr ""

#. type: Plain text
#: man-pages/man2/statx.2:405
msgid "The file's creation timestamp."
msgstr ""

#. type: TP
#: man-pages/man2/statx.2:405
#, no-wrap
msgid "I<stx_ctime>"
msgstr ""

#. type: Plain text
#: man-pages/man2/statx.2:408
msgid "The file's last status change timestamp."
msgstr ""

#. type: TP
#: man-pages/man2/statx.2:408
#, no-wrap
msgid "I<stx_mtime>"
msgstr ""

#. type: Plain text
#: man-pages/man2/statx.2:411
msgid "The file's last modification timestamp."
msgstr ""

#. type: TP
#: man-pages/man2/statx.2:411
#, no-wrap
msgid "I<stx_dev_major> and I<stx_dev_minor>"
msgstr ""

#. type: Plain text
#: man-pages/man2/statx.2:414
msgid "The device on which this file (inode) resides."
msgstr ""

#. type: TP
#: man-pages/man2/statx.2:414
#, no-wrap
msgid "I<stx_rdev_major> and I<stx_rdev_minor>"
msgstr ""

#. type: Plain text
#: man-pages/man2/statx.2:418
msgid ""
"The device that this file (inode) represents if the file is of block or "
"character device type."
msgstr ""

#. type: Plain text
#: man-pages/man2/statx.2:422 man-pages/man2/stat.2:260
msgid "For further information on the above fields, see B<inode>(7)."
msgstr ""

#. type: SS
#: man-pages/man2/statx.2:422
#, no-wrap
msgid "File attributes"
msgstr ""

#. type: Plain text
#: man-pages/man2/statx.2:435
msgid ""
"The I<stx_attributes> field contains a set of ORed flags that indicate "
"additional attributes of the file.  Note that any attribute that is not "
"indicated as supported by I<stx_attributes_mask> has no usable value here.  "
"The bits in I<stx_attributes_mask> correspond bit-by-bit to "
"I<stx_attributes>."
msgstr ""

#. type: Plain text
#: man-pages/man2/statx.2:437
msgid "The flags are as follows:"
msgstr ""

#. type: TP
#: man-pages/man2/statx.2:437
#, no-wrap
msgid "B<STATX_ATTR_COMPRESSED>"
msgstr ""

#. type: Plain text
#: man-pages/man2/statx.2:441
msgid ""
"The file is compressed by the filesystem and may take extra resources to "
"access."
msgstr ""

#. type: TP
#: man-pages/man2/statx.2:441
#, no-wrap
msgid "B<STATX_ATTR_IMMUTABLE>"
msgstr ""

#. type: Plain text
#: man-pages/man2/statx.2:447
msgid ""
"The file cannot be modified: it cannot be deleted or renamed, no hard links "
"can be created to this file and no data can be written to it.  See "
"B<chattr>(1)."
msgstr ""

#. type: TP
#: man-pages/man2/statx.2:447
#, no-wrap
msgid "B<STATX_ATTR_APPEND>"
msgstr ""

#. type: Plain text
#: man-pages/man2/statx.2:454
msgid ""
"The file can only be opened in append mode for writing.  Random access "
"writing is not permitted.  See B<chattr>(1)."
msgstr ""

#. type: TP
#: man-pages/man2/statx.2:454
#, no-wrap
msgid "B<STATX_ATTR_NODUMP>"
msgstr ""

#. type: Plain text
#: man-pages/man2/statx.2:461
msgid ""
"File is not a candidate for backup when a backup program such as B<dump>(8)  "
"is run.  See B<chattr>(1)."
msgstr ""

#. type: TP
#: man-pages/man2/statx.2:461
#, no-wrap
msgid "B<STATX_ATTR_ENCRYPTED>"
msgstr ""

#. type: Plain text
#: man-pages/man2/statx.2:464
msgid "A key is required for the file to be encrypted by the filesystem."
msgstr ""

#. type: Plain text
#: man-pages/man2/statx.2:477 man-pages/man2/stat.2:387
msgid ""
"Search permission is denied for one of the directories in the path prefix of "
"I<pathname>.  (See also B<path_resolution>(7).)"
msgstr ""

#. type: Plain text
#: man-pages/man2/statx.2:481
msgid "I<dirfd> is not a valid open file descriptor."
msgstr ""

#. type: Plain text
#: man-pages/man2/statx.2:488
msgid ""
"I<pathname> or I<statxbuf> is NULL or points to a location outside the "
"process's accessible address space."
msgstr ""

#. type: Plain text
#: man-pages/man2/statx.2:499
msgid ""
"Reserved flag specified in I<mask>.  (Currently, there is one such flag, "
"designated by the constant B<STATX__RESERVED>, with the value 0x80000000U.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/statx.2:502
msgid "Too many symbolic links encountered while traversing the pathname."
msgstr ""

#. type: Plain text
#: man-pages/man2/statx.2:506 man-pages/man2/spu_create.2:203
#: man-pages/man2/access.2:219 man-pages/man2/chmod.2:277
#: man-pages/man2/inotify_add_watch.2:119 man-pages/man2/chown.2:254
#: man-pages/man2/stat.2:401 man-pages/man2/execve.2:500
msgid "I<pathname> is too long."
msgstr ""

#. type: Plain text
#: man-pages/man2/statx.2:516
msgid ""
"A component of I<pathname> does not exist, or I<pathname> is an empty string "
"and B<AT_EMPTY_PATH> was not specified in I<flags>."
msgstr ""

#. type: Plain text
#: man-pages/man2/statx.2:519 man-pages/man2/stat.2:416
msgid "Out of memory (i.e., kernel memory)."
msgstr ""

#. type: Plain text
#: man-pages/man2/statx.2:528
msgid ""
"A component of the path prefix of I<pathname> is not a directory or "
"I<pathname> is relative and I<dirfd> is a file descriptor referring to a "
"file other than a directory."
msgstr ""

#. type: Plain text
#: man-pages/man2/statx.2:531
msgid ""
"B<statx>()  was added to Linux in kernel 4.11; library support was added in "
"glibc 2.28."
msgstr ""

#. type: Plain text
#: man-pages/man2/statx.2:534
msgid "B<statx>()  is Linux-specific."
msgstr ""

#. type: Plain text
#: man-pages/man2/statx.2:545
msgid ""
"B<ls>(1), B<stat>(1), B<access>(2), B<chmod>(2), B<chown>(2), "
"B<readlink>(2), B<stat>(2), B<utime>(2), B<capabilities>(7), B<inode>(7), "
"B<symlink>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/rmdir.2:30
#, no-wrap
msgid "RMDIR"
msgstr ""

#. type: TH
#: man-pages/man2/rmdir.2:30 man-pages/man2/timer_delete.2:26
#: man-pages/man2/pause.2:30
#, no-wrap
msgid "2015-08-08"
msgstr ""

#. type: Plain text
#: man-pages/man2/rmdir.2:33
msgid "rmdir - delete a directory"
msgstr ""

#. type: Plain text
#: man-pages/man2/rmdir.2:37
msgid "B<int rmdir(const char *>I<pathname>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/rmdir.2:40
msgid "B<rmdir>()  deletes a directory, which must be empty."
msgstr ""

#. type: Plain text
#: man-pages/man2/rmdir.2:55
msgid ""
"Write access to the directory containing I<pathname> was not allowed, or one "
"of the directories in the path prefix of I<pathname> did not allow search "
"permission.  (See also B<path_resolution>(7)."
msgstr ""

#. type: TP
#: man-pages/man2/rmdir.2:55 man-pages/man2/ioctl_userfaultfd.2:340
#: man-pages/man2/rename.2:328 man-pages/man2/swapon.2:119
#: man-pages/man2/pivot_root.2:103 man-pages/man2/delete_module.2:130
#: man-pages/man2/prctl.2:1445 man-pages/man2/kexec_load.2:275
#: man-pages/man2/mount.2:657 man-pages/man2/mount.2:665
#: man-pages/man2/unlink.2:169 man-pages/man2/msync.2:77
#: man-pages/man2/sched_setattr.2:355 man-pages/man2/quotactl.2:693
#: man-pages/man2/init_module.2:163 man-pages/man2/dup.2:168
#: man-pages/man2/fcntl.2:1669 man-pages/man2/fcntl.2:1678
#: man-pages/man2/ptrace.2:2321 man-pages/man2/umount.2:131
#: man-pages/man2/bdflush.2:98
#, no-wrap
msgid "B<EBUSY>"
msgstr ""

#. type: Plain text
#: man-pages/man2/rmdir.2:64
msgid ""
"I<pathname> is currently in use by the system or some process that prevents "
"its removal.  On Linux, this means I<pathname> is currently used as a mount "
"point or is the root directory of the calling process."
msgstr ""

#. type: Plain text
#: man-pages/man2/rmdir.2:67 man-pages/man2/mknod.2:183
#: man-pages/man2/open.2:976 man-pages/man2/access.2:241
#: man-pages/man2/chmod.2:266 man-pages/man2/unlink.2:182
#: man-pages/man2/chown.2:246 man-pages/man2/mkdir.2:148
msgid "I<pathname> points outside your accessible address space."
msgstr ""

#. type: Plain text
#: man-pages/man2/rmdir.2:73
msgid "I<pathname> has I<.> as last component."
msgstr ""

#. type: Plain text
#: man-pages/man2/rmdir.2:77 man-pages/man2/mknod.2:192
#: man-pages/man2/open.2:1046 man-pages/man2/access.2:215
#: man-pages/man2/chmod.2:273 man-pages/man2/chown.2:250
#: man-pages/man2/mkdir.2:158
msgid "Too many symbolic links were encountered in resolving I<pathname>."
msgstr ""

#. type: Plain text
#: man-pages/man2/rmdir.2:80 man-pages/man2/mknod.2:195
#: man-pages/man2/open.2:1066 man-pages/man2/unlink.2:197
#: man-pages/man2/mkdir.2:165
msgid "I<pathname> was too long."
msgstr ""

#. type: Plain text
#: man-pages/man2/rmdir.2:85 man-pages/man2/mknod.2:200
#: man-pages/man2/open.2:1085 man-pages/man2/inotify_add_watch.2:124
#: man-pages/man2/mkdir.2:170
msgid ""
"A directory component in I<pathname> does not exist or is a dangling "
"symbolic link."
msgstr ""

#. type: Plain text
#: man-pages/man2/rmdir.2:94
msgid ""
"I<pathname>, or a component used as a directory in I<pathname>, is not, in "
"fact, a directory."
msgstr ""

#. type: TP
#: man-pages/man2/rmdir.2:94
#, no-wrap
msgid "B<ENOTEMPTY>"
msgstr ""

#.  POSIX.1-2001, POSIX.1-2008
#. type: Plain text
#: man-pages/man2/rmdir.2:108
msgid ""
"I<pathname> contains entries other than I<.> and I<..> ; or, I<pathname> has "
"I<..> as its final component.  POSIX.1 also allows B<EEXIST> for this "
"condition."
msgstr ""

#. type: Plain text
#: man-pages/man2/rmdir.2:119
msgid ""
"The directory containing I<pathname> has the sticky bit (B<S_ISVTX>)  set "
"and the process's effective user ID is neither the user ID of the file to be "
"deleted nor that of the directory containing it, and the process is not "
"privileged (Linux: does not have the B<CAP_FOWNER> capability)."
msgstr ""

#. type: Plain text
#: man-pages/man2/rmdir.2:124
msgid ""
"The filesystem containing I<pathname> does not support the removal of "
"directories."
msgstr ""

#. type: Plain text
#: man-pages/man2/rmdir.2:128
msgid "I<pathname> refers to a directory on a read-only filesystem."
msgstr ""

#.  SVr4 documents an additional ENOLINK error condition.
#. type: Plain text
#: man-pages/man2/rmdir.2:130 man-pages/man2/kill.2:122
#: man-pages/man2/umask.2:117 man-pages/man2/alarm.2:61
#: man-pages/man2/fork.2:281 man-pages/man2/lseek.2:225
#: man-pages/man2/times.2:118 man-pages/man2/pause.2:59
#: man-pages/man2/close.2:103
msgid "POSIX.1-2001, POSIX.1-2008, SVr4, 4.3BSD."
msgstr ""

#. type: Plain text
#: man-pages/man2/rmdir.2:133
msgid ""
"Infelicities in the protocol underlying NFS can cause the unexpected "
"disappearance of directories which are still being used."
msgstr ""

#. type: Plain text
#: man-pages/man2/rmdir.2:141
msgid ""
"B<rm>(1), B<rmdir>(1), B<chdir>(2), B<chmod>(2), B<mkdir>(2), B<rename>(2), "
"B<unlink>(2), B<unlinkat>(2)"
msgstr ""

#. type: TH
#: man-pages/man2/kill.2:44
#, no-wrap
msgid "KILL"
msgstr ""

#. type: Plain text
#: man-pages/man2/kill.2:47
msgid "kill - send signal to a process"
msgstr ""

#. type: Plain text
#: man-pages/man2/kill.2:51
#, no-wrap
msgid ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>signal.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/kill.2:53
#, no-wrap
msgid "B<int kill(pid_t >I<pid>B<, int >I<sig>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/kill.2:63
msgid "B<kill>(): _POSIX_C_SOURCE"
msgstr ""

#. type: Plain text
#: man-pages/man2/kill.2:69
msgid ""
"The B<kill>()  system call can be used to send any signal to any process "
"group or process."
msgstr ""

#. type: Plain text
#: man-pages/man2/kill.2:72
msgid ""
"If I<pid> is positive, then signal I<sig> is sent to the process with the ID "
"specified by I<pid>."
msgstr ""

#. type: Plain text
#: man-pages/man2/kill.2:75
msgid ""
"If I<pid> equals 0, then I<sig> is sent to every process in the process "
"group of the calling process."
msgstr ""

#. type: Plain text
#: man-pages/man2/kill.2:79
msgid ""
"If I<pid> equals -1, then I<sig> is sent to every process for which the "
"calling process has permission to send signals, except for process 1 "
"(I<init>), but see below."
msgstr ""

#. type: Plain text
#: man-pages/man2/kill.2:82
msgid ""
"If I<pid> is less than -1, then I<sig> is sent to every process in the "
"process group whose ID is I<-pid>."
msgstr ""

#. type: Plain text
#: man-pages/man2/kill.2:87
msgid ""
"If I<sig> is 0, then no signal is sent, but existence and permission checks "
"are still performed; this can be used to check for the existence of a "
"process ID or process group ID that the caller is permitted to signal."
msgstr ""

#. type: Plain text
#: man-pages/man2/kill.2:99
msgid ""
"For a process to have permission to send a signal, it must either be "
"privileged (under Linux: have the B<CAP_KILL> capability in the user "
"namespace of the target process), or the real or effective user ID of the "
"sending process must equal the real or saved set-user-ID of the target "
"process.  In the case of B<SIGCONT>, it suffices when the sending and "
"receiving processes belong to the same session.  (Historically, the rules "
"were different; see NOTES.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/kill.2:104
msgid ""
"On success (at least one signal was sent), zero is returned.  On error, -1 "
"is returned, and I<errno> is set appropriately."
msgstr ""

#. type: Plain text
#: man-pages/man2/kill.2:108
msgid "An invalid signal was specified."
msgstr ""

#. type: Plain text
#: man-pages/man2/kill.2:112
msgid ""
"The calling process does not have permission to send the signal to any of "
"the target processes."
msgstr ""

#. type: Plain text
#: man-pages/man2/kill.2:120
msgid ""
"The target process or process group does not exist.  Note that an existing "
"process might be a zombie, a process that has terminated execution, but has "
"not yet been B<wait>(2)ed for."
msgstr ""

#. type: Plain text
#: man-pages/man2/kill.2:130
msgid ""
"The only signals that can be sent to process ID 1, the I<init> process, are "
"those for which I<init> has explicitly installed signal handlers.  This is "
"done to assure the system is not brought down accidentally."
msgstr ""

#. type: Plain text
#: man-pages/man2/kill.2:136
msgid ""
"POSIX.1 requires that I<kill(-1,sig)> send I<sig> to all processes that the "
"calling process may send signals to, except possibly for some "
"implementation-defined system processes.  Linux allows a process to signal "
"itself, but on Linux the call I<kill(-1,sig)> does not signal the calling "
"process."
msgstr ""

#. type: Plain text
#: man-pages/man2/kill.2:146
msgid ""
"POSIX.1 requires that if a process sends a signal to itself, and the sending "
"thread does not have the signal blocked, and no other thread has it "
"unblocked or is waiting for it in B<sigwait>(3), at least one unblocked "
"signal must be delivered to the sending thread before the B<kill>()  "
"returns."
msgstr ""

#. type: SS
#: man-pages/man2/kill.2:146 man-pages/man2/msgget.2:230
#: man-pages/man2/shmget.2:402 man-pages/man2/madvise.2:553
#: man-pages/man2/wait.2:513 man-pages/man2/mlock.2:401
#: man-pages/man2/vfork.2:271 man-pages/man2/sched_rr_get_interval.2:103
#, no-wrap
msgid "Linux notes"
msgstr ""

#.  In the 0.* kernels things chopped and changed quite
#.  a bit - MTK, 24 Jul 02
#. type: Plain text
#: man-pages/man2/kill.2:160
msgid ""
"Across different kernel versions, Linux has enforced different rules for the "
"permissions required for an unprivileged process to send a signal to another "
"process.  In kernels 1.0 to 1.2.2, a signal could be sent if the effective "
"user ID of the sender matched effective user ID of the target, or the real "
"user ID of the sender matched the real user ID of the target.  From kernel "
"1.2.3 until 1.3.77, a signal could be sent if the effective user ID of the "
"sender matched either the real or effective user ID of the target.  The "
"current rules, which conform to POSIX.1, were adopted in kernel 1.3.78."
msgstr ""

#. type: Plain text
#: man-pages/man2/kill.2:170
msgid ""
"In 2.6 kernels up to and including 2.6.7, there was a bug that meant that "
"when sending signals to a process group, B<kill>()  failed with the error "
"B<EPERM> if the caller did not have permission to send the signal to I<any> "
"(rather than I<all>) of the members of the process group.  Notwithstanding "
"this error return, the signal was still delivered to all of the processes "
"for which the caller had permission to signal."
msgstr ""

#. type: Plain text
#: man-pages/man2/kill.2:181
msgid ""
"B<kill>(1), B<_exit>(2), B<pidfd_send_signal>(2), B<signal>(2), B<tkill>(2), "
"B<exit>(3), B<killpg>(3), B<sigqueue>(3), B<capabilities>(7), "
"B<credentials>(7), B<signal>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/readdir.2:30
#, no-wrap
msgid "READDIR"
msgstr ""

#. type: Plain text
#: man-pages/man2/readdir.2:33
msgid "readdir - read directory entry"
msgstr ""

#. type: Plain text
#: man-pages/man2/readdir.2:38
#, no-wrap
msgid ""
"B<int readdir(unsigned int >I<fd>B<, struct old_linux_dirent *>I<dirp>B<,>\n"
"B<            unsigned int >I<count>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/readdir.2:50
msgid ""
"This is not the function you are interested in.  Look at B<readdir>(3)  for "
"the POSIX conforming C library interface.  This page documents the bare "
"kernel system call interface, which is superseded by B<getdents>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/readdir.2:64
msgid ""
"B<readdir>()  reads one I<old_linux_dirent> structure from the directory "
"referred to by the file descriptor I<fd> into the buffer pointed to by "
"I<dirp>.  The argument I<count> is ignored; at most one I<old_linux_dirent> "
"structure is read."
msgstr ""

#. type: Plain text
#: man-pages/man2/readdir.2:70
msgid ""
"The I<old_linux_dirent> structure is declared (privately in Linux kernel "
"file B<fs/readdir.c>)  as follows:"
msgstr ""

#. type: Plain text
#: man-pages/man2/readdir.2:79
#, no-wrap
msgid ""
"struct old_linux_dirent {\n"
"    unsigned long d_ino;     /* inode number */\n"
"    unsigned long d_offset;  /* offset to this I<old_linux_dirent> */\n"
"    unsigned short d_namlen; /* length of this I<d_name> */\n"
"    char  d_name[1];         /* filename (null-terminated) */\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/readdir.2:93
msgid ""
"I<d_ino> is an inode number.  I<d_offset> is the distance from the start of "
"the directory to this I<old_linux_dirent>.  I<d_reclen> is the size of "
"I<d_name>, not counting the terminating null byte (\\(aq\\e0\\(aq).  "
"I<d_name> is a null-terminated filename."
msgstr ""

#. type: Plain text
#: man-pages/man2/readdir.2:99
msgid ""
"On success, 1 is returned.  On end of directory, 0 is returned.  On error, "
"-1 is returned, and I<errno> is set appropriately."
msgstr ""

#. type: Plain text
#: man-pages/man2/readdir.2:104 man-pages/man2/getdents.2:190
msgid "Invalid file descriptor I<fd>."
msgstr ""

#. type: Plain text
#: man-pages/man2/readdir.2:107 man-pages/man2/getdents.2:193
msgid "Argument points outside the calling process's address space."
msgstr ""

#. type: Plain text
#: man-pages/man2/readdir.2:110 man-pages/man2/getdents.2:196
msgid "Result buffer is too small."
msgstr ""

#. type: Plain text
#: man-pages/man2/readdir.2:113 man-pages/man2/getdents.2:199
msgid "No such directory."
msgstr ""

#. type: Plain text
#: man-pages/man2/readdir.2:116 man-pages/man2/getdents.2:202
msgid "File descriptor does not refer to a directory."
msgstr ""

#. type: Plain text
#: man-pages/man2/readdir.2:127
msgid ""
"Glibc does not provide a wrapper for this system call; call it using "
"B<syscall>(2).  You will need to define the I<old_linux_dirent> structure "
"yourself.  However, probably you should use B<readdir>(3)  instead."
msgstr ""

#. type: Plain text
#: man-pages/man2/readdir.2:129 man-pages/man2/mmap2.2:88
msgid "This system call does not exist on x86-64."
msgstr ""

#. type: Plain text
#: man-pages/man2/readdir.2:131
msgid "B<getdents>(2), B<readdir>(3)"
msgstr ""

#. type: TH
#: man-pages/man2/ioctl_userfaultfd.2:28
#, no-wrap
msgid "IOCTL_USERFAULTFD"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_userfaultfd.2:32
msgid ""
"ioctl_userfaultfd - create a file descriptor for handling page faults in "
"user space"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_userfaultfd.2:35
#, no-wrap
msgid "B<#include E<lt>sys/ioctl.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_userfaultfd.2:37
#, no-wrap
msgid "B<int ioctl(int >I<fd>B<, int >I<cmd>B<, ...);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_userfaultfd.2:44
msgid ""
"Various B<ioctl>(2)  operations can be performed on a userfaultfd object "
"(created by a call to B<userfaultfd>(2))  using calls of the form:"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_userfaultfd.2:48
#, no-wrap
msgid "ioctl(fd, cmd, argp);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_userfaultfd.2:58
msgid ""
"In the above, I<fd> is a file descriptor referring to a userfaultfd object, "
"I<cmd> is one of the commands listed below, and I<argp> is a pointer to a "
"data structure that is specific to I<cmd>."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_userfaultfd.2:78
msgid ""
"The various B<ioctl>(2)  operations are described below.  The B<UFFDIO_API>, "
"B<UFFDIO_REGISTER>, and B<UFFDIO_UNREGISTER> operations are used to "
"I<configure> userfaultfd behavior.  These operations allow the caller to "
"choose what features will be enabled and what kinds of events will be "
"delivered to the application.  The remaining operations are I<range> "
"operations.  These operations enable the calling application to resolve "
"page-fault events."
msgstr ""

#. type: SS
#: man-pages/man2/ioctl_userfaultfd.2:78
#, no-wrap
msgid "UFFDIO_API"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_userfaultfd.2:81
msgid ""
"(Since Linux 4.3.)  Enable operation of the userfaultfd and perform API "
"handshake."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_userfaultfd.2:87
msgid "The I<argp> argument is a pointer to a I<uffdio_api> structure, defined as:"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_userfaultfd.2:95
#, no-wrap
msgid ""
"struct uffdio_api {\n"
"    __u64 api;        /* Requested API version (input) */\n"
"    __u64 features;   /* Requested features (input/output) */\n"
"    __u64 ioctls;     /* Available ioctl() operations (output) */\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_userfaultfd.2:101
msgid "The I<api> field denotes the API version requested by the application."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_userfaultfd.2:110
msgid ""
"The kernel verifies that it can support the requested API version, and sets "
"the I<features> and I<ioctls> fields to bit masks representing all the "
"available features and the generic B<ioctl>(2)  operations available."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_userfaultfd.2:119
msgid ""
"For Linux kernel versions before 4.11, the I<features> field must be "
"initialized to zero before the call to I<UFFDIO_API>, and zero (i.e., no "
"feature bits) is placed in the I<features> field by the kernel upon return "
"from B<ioctl>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_userfaultfd.2:127
msgid ""
"Starting from Linux 4.11, the I<features> field can be used to ask whether "
"particular features are supported and explicitly enable userfaultfd features "
"that are disabled by default.  The kernel always reports all the available "
"features in the I<features> field."
msgstr ""

#.  FIXME add more details about feature negotiation and enablement
#. type: Plain text
#: man-pages/man2/ioctl_userfaultfd.2:138
msgid ""
"To enable userfaultfd features the application should set a bit "
"corresponding to each feature it wants to enable in the I<features> field.  "
"If the kernel supports all the requested features it will enable them.  "
"Otherwise it will zero out the returned I<uffdio_api> structure and return "
"B<EINVAL>."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_userfaultfd.2:140
msgid "The following feature bits may be set:"
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_userfaultfd.2:140
#, no-wrap
msgid "B<UFFD_FEATURE_EVENT_FORK> (since Linux 4.11)"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_userfaultfd.2:149
msgid ""
"When this feature is enabled, the userfaultfd objects associated with a "
"parent process are duplicated into the child process during B<fork>(2)  and "
"a B<UFFD_EVENT_FORK> event is delivered to the userfaultfd monitor"
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_userfaultfd.2:149
#, no-wrap
msgid "B<UFFD_FEATURE_EVENT_REMAP> (since Linux 4.11)"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_userfaultfd.2:156
msgid ""
"If this feature is enabled, when the faulting process invokes B<mremap>(2), "
"the userfaultfd monitor will receive an event of type B<UFFD_EVENT_REMAP>."
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_userfaultfd.2:156
#, no-wrap
msgid "B<UFFD_FEATURE_EVENT_REMOVE> (since Linux 4.11)"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_userfaultfd.2:168
msgid ""
"If this feature is enabled, when the faulting process calls B<madvise>(2)  "
"with the B<MADV_DONTNEED> or B<MADV_REMOVE> advice value to free a virtual "
"memory area the userfaultfd monitor will receive an event of type "
"B<UFFD_EVENT_REMOVE>."
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_userfaultfd.2:168
#, no-wrap
msgid "B<UFFD_FEATURE_EVENT_UNMAP> (since Linux 4.11)"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_userfaultfd.2:179
msgid ""
"If this feature is enabled, when the faulting process unmaps virtual memory "
"either explicitly with B<munmap>(2), or implicitly during either B<mmap>(2)  "
"or B<mremap>(2).  the userfaultfd monitor will receive an event of type "
"B<UFFD_EVENT_UNMAP>."
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_userfaultfd.2:179
#, no-wrap
msgid "B<UFFD_FEATURE_MISSING_HUGETLBFS> (since Linux 4.11)"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_userfaultfd.2:184
msgid ""
"If this feature bit is set, the kernel supports registering userfaultfd "
"ranges on hugetlbfs virtual memory areas"
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_userfaultfd.2:184
#, no-wrap
msgid "B<UFFD_FEATURE_MISSING_SHMEM> (since Linux 4.11)"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_userfaultfd.2:199
msgid ""
"If this feature bit is set, the kernel supports registering userfaultfd "
"ranges on shared memory areas.  This includes all kernel shared memory APIs: "
"System V shared memory, B<tmpfs>(5), shared mappings of I</dev/zero>, "
"B<mmap>(2)  with the B<MAP_SHARED> flag set, B<memfd_create>(2), and so on."
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_userfaultfd.2:199
#, no-wrap
msgid "B<UFFD_FEATURE_SIGBUS> (since Linux 4.14)"
msgstr ""

#.  commit 2d6d6f5a09a96cc1fec7ed992b825e05f64cb50e
#. type: Plain text
#: man-pages/man2/ioctl_userfaultfd.2:211
msgid ""
"If this feature bit is set, no page-fault events (B<UFFD_EVENT_PAGEFAULT>)  "
"will be delivered.  Instead, a B<SIGBUS> signal will be sent to the faulting "
"process.  Applications using this feature will not require the use of a "
"userfaultfd monitor for processing memory accesses to the regions registered "
"with userfaultfd."
msgstr ""

#.  FIXME This user-space API seems not fully polished. Why are there
#.  not constants defined for each of the bit-mask values listed below?
#. type: Plain text
#: man-pages/man2/ioctl_userfaultfd.2:217
msgid "The returned I<ioctls> field can contain the following bits:"
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_userfaultfd.2:217
#, no-wrap
msgid "B<1 E<lt>E<lt> _UFFDIO_API>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_userfaultfd.2:222
msgid "The B<UFFDIO_API> operation is supported."
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_userfaultfd.2:222
#, no-wrap
msgid "B<1 E<lt>E<lt> _UFFDIO_REGISTER>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_userfaultfd.2:227
msgid "The B<UFFDIO_REGISTER> operation is supported."
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_userfaultfd.2:227
#, no-wrap
msgid "B<1 E<lt>E<lt> _UFFDIO_UNREGISTER>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_userfaultfd.2:232
msgid "The B<UFFDIO_UNREGISTER> operation is supported."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_userfaultfd.2:240
#: man-pages/man2/ioctl_userfaultfd.2:340
#: man-pages/man2/ioctl_userfaultfd.2:391
#: man-pages/man2/ioctl_userfaultfd.2:641
msgid ""
"This B<ioctl>(2)  operation returns 0 on success.  On error, -1 is returned "
"and I<errno> is set to indicate the cause of the error.  Possible errors "
"include:"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_userfaultfd.2:245
#: man-pages/man2/ioctl_userfaultfd.2:349
msgid ""
"I<argp> refers to an address that is outside the calling process's "
"accessible address space."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_userfaultfd.2:250
msgid ""
"The userfaultfd has already been enabled by a previous B<UFFDIO_API> "
"operation."
msgstr ""

#.  FIXME In the above error case, the returned 'uffdio_api' structure is
#.  zeroed out. Why is this done? This should be explained in the manual page.
#
#.  Mike Rapoport:
#.      In my understanding the uffdio_api
#.      structure is zeroed to allow the caller
#.      to distinguish the reasons for -EINVAL.
#. type: Plain text
#: man-pages/man2/ioctl_userfaultfd.2:266
msgid ""
"The API version requested in the I<api> field is not supported by this "
"kernel, or the I<features> field passed to the kernel includes feature bits "
"that are not supported by the current kernel version."
msgstr ""

#. type: SS
#: man-pages/man2/ioctl_userfaultfd.2:266
#, no-wrap
msgid "UFFDIO_REGISTER"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_userfaultfd.2:270
msgid ""
"(Since Linux 4.3.)  Register a memory address range with the userfaultfd "
"object.  The pages in the range must be \"compatible\"."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_userfaultfd.2:274
msgid ""
"Up to Linux kernel 4.11, only private anonymous ranges are compatible for "
"registering with B<UFFDIO_REGISTER>."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_userfaultfd.2:278
msgid ""
"Since Linux 4.11, hugetlbfs and shared memory ranges are also compatible "
"with B<UFFDIO_REGISTER>."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_userfaultfd.2:284
msgid ""
"The I<argp> argument is a pointer to a I<uffdio_register> structure, defined "
"as:"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_userfaultfd.2:291
#, no-wrap
msgid ""
"struct uffdio_range {\n"
"    __u64 start;    /* Start of range */\n"
"    __u64 len;      /* Length of range (bytes) */\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_userfaultfd.2:297
#, no-wrap
msgid ""
"struct uffdio_register {\n"
"    struct uffdio_range range;\n"
"    __u64 mode;     /* Desired mode of operation (input) */\n"
"    __u64 ioctls;   /* Available ioctl() operations (output) */\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_userfaultfd.2:307
msgid ""
"The I<range> field defines a memory range starting at I<start> and "
"continuing for I<len> bytes that should be handled by the userfaultfd."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_userfaultfd.2:313
msgid ""
"The I<mode> field defines the mode of operation desired for this memory "
"region.  The following values may be bitwise ORed to set the userfaultfd "
"mode for the specified range:"
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_userfaultfd.2:313
#, no-wrap
msgid "B<UFFDIO_REGISTER_MODE_MISSING>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_userfaultfd.2:316
msgid "Track page faults on missing pages."
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_userfaultfd.2:316
#, no-wrap
msgid "B<UFFDIO_REGISTER_MODE_WP>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_userfaultfd.2:319
msgid "Track page faults on write-protected pages."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_userfaultfd.2:322
msgid "Currently, the only supported mode is B<UFFDIO_REGISTER_MODE_MISSING>."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_userfaultfd.2:330
msgid ""
"If the operation is successful, the kernel modifies the I<ioctls> bit-mask "
"field to indicate which B<ioctl>(2)  operations are available for the "
"specified range.  This returned bit mask is as for B<UFFDIO_API>."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_userfaultfd.2:344
msgid ""
"A mapping in the specified range is registered with another userfaultfd "
"object."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_userfaultfd.2:356
msgid ""
"An invalid or unsupported bit was specified in the I<mode> field; or the "
"I<mode> field was zero."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_userfaultfd.2:359
msgid "There is no mapping in the specified address range."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_userfaultfd.2:367
msgid ""
"I<range.start> or I<range.len> is not a multiple of the system page size; "
"or, I<range.len> is zero; or these fields are otherwise invalid."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_userfaultfd.2:373
#: man-pages/man2/ioctl_userfaultfd.2:405
msgid "There as an incompatible mapping in the specified address range."
msgstr ""

#. type: SS
#: man-pages/man2/ioctl_userfaultfd.2:373
#, no-wrap
msgid "UFFDIO_UNREGISTER"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_userfaultfd.2:378
msgid ""
"(Since Linux 4.3.)  Unregister a memory address range from userfaultfd.  The "
"pages in the range must be \"compatible\" (see the description of "
"B<UFFDIO_REGISTER>.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_userfaultfd.2:383
msgid ""
"The address range to unregister is specified in the I<uffdio_range> "
"structure pointed to by I<argp>."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_userfaultfd.2:402
msgid ""
"Either the I<start> or the I<len> field of the I<ufdio_range> structure was "
"not a multiple of the system page size; or the I<len> field was zero; or "
"these fields were otherwise invalid."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_userfaultfd.2:409
msgid "There was no mapping in the specified address range."
msgstr ""

#. type: SS
#: man-pages/man2/ioctl_userfaultfd.2:409
#, no-wrap
msgid "UFFDIO_COPY"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_userfaultfd.2:420
msgid ""
"(Since Linux 4.3.)  Atomically copy a continuous memory chunk into the "
"userfault registered range and optionally wake up the blocked thread.  The "
"source and destination addresses and the number of bytes to copy are "
"specified by the I<src>, I<dst>, and I<len> fields of the I<uffdio_copy> "
"structure pointed to by I<argp>:"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_userfaultfd.2:430
#, no-wrap
msgid ""
"struct uffdio_copy {\n"
"    __u64 dst;    /* Source of copy */\n"
"    __u64 src;    /* Destination of copy */\n"
"    __u64 len;    /* Number of bytes to copy */\n"
"    __u64 mode;   /* Flags controlling behavior of copy */\n"
"    __s64 copy;   /* Number of bytes copied, or negated error */\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_userfaultfd.2:438
msgid ""
"The following value may be bitwise ORed in I<mode> to change the behavior of "
"the B<UFFDIO_COPY> operation:"
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_userfaultfd.2:438
#, no-wrap
msgid "B<UFFDIO_COPY_MODE_DONTWAKE>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_userfaultfd.2:441
msgid "Do not wake up the thread that waits for page-fault resolution"
msgstr ""

#.  FIXME Above: Why is the 'copy' field used to return error values?
#.  This should be explained in the manual page.
#. type: Plain text
#: man-pages/man2/ioctl_userfaultfd.2:462
msgid ""
"The I<copy> field is used by the kernel to return the number of bytes that "
"was actually copied, or an error (a negated I<errno>-style value).  If the "
"value returned in I<copy> doesn't match the value that was specified in "
"I<len>, the operation fails with the error B<EAGAIN>.  The I<copy> field is "
"output-only; it is not read by the B<UFFDIO_COPY> operation."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_userfaultfd.2:471
msgid ""
"This B<ioctl>(2)  operation returns 0 on success.  In this case, the entire "
"area was copied.  On error, -1 is returned and I<errno> is set to indicate "
"the cause of the error.  Possible errors include:"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_userfaultfd.2:479
msgid ""
"The number of bytes copied (i.e., the value returned in the I<copy> field)  "
"does not equal the value that was specified in the I<len> field."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_userfaultfd.2:494
msgid ""
"Either I<dst> or I<len> was not a multiple of the system page size, or the "
"range specified by I<src> and I<len> or I<dst> and I<len> was invalid."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_userfaultfd.2:499
#: man-pages/man2/ioctl_userfaultfd.2:597
msgid "An invalid bit was specified in the I<mode> field."
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_userfaultfd.2:499
#, no-wrap
msgid "B<ENOENT> (since Linux 4.11)"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_userfaultfd.2:505
msgid ""
"The faulting process has changed its virtual memory layout simultaneously "
"with an outstanding I<UFFDIO_COPY> operation."
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_userfaultfd.2:505
#, no-wrap
msgid "B<ENOSPC> (from Linux 4.11 until Linux 4.13)"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_userfaultfd.2:510
#: man-pages/man2/ioctl_userfaultfd.2:516
msgid "The faulting process has exited at the time of a I<UFFDIO_COPY> operation."
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_userfaultfd.2:510
#: man-pages/man2/ioctl_userfaultfd.2:597
#, no-wrap
msgid "B<ESRCH> (since Linux 4.13)"
msgstr ""

#. type: SS
#: man-pages/man2/ioctl_userfaultfd.2:516
#, no-wrap
msgid "UFFDIO_ZEROPAGE"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_userfaultfd.2:519
msgid "(Since Linux 4.3.)  Zero out a memory range registered with userfaultfd."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_userfaultfd.2:526
msgid ""
"The requested range is specified by the I<range> field of the "
"I<uffdio_zeropage> structure pointed to by I<argp>:"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_userfaultfd.2:534
#, no-wrap
msgid ""
"struct uffdio_zeropage {\n"
"    struct uffdio_range range;\n"
"    __u64 mode;     /* Flags controlling behavior of copy */\n"
"    __s64 zeropage; /* Number of bytes zeroed, or negated error */\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_userfaultfd.2:542
msgid ""
"The following value may be bitwise ORed in I<mode> to change the behavior of "
"the B<UFFDIO_ZEROPAGE> operation:"
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_userfaultfd.2:542
#, no-wrap
msgid "B<UFFDIO_ZEROPAGE_MODE_DONTWAKE>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_userfaultfd.2:545
msgid "Do not wake up the thread that waits for page-fault resolution."
msgstr ""

#.  FIXME Why is the 'zeropage' field used to return error values?
#.  This should be explained in the manual page.
#. type: Plain text
#: man-pages/man2/ioctl_userfaultfd.2:566
msgid ""
"The I<zeropage> field is used by the kernel to return the number of bytes "
"that was actually zeroed, or an error in the same manner as B<UFFDIO_COPY>.  "
"If the value returned in the I<zeropage> field doesn't match the value that "
"was specified in I<range.len>, the operation fails with the error "
"B<EAGAIN>.  The I<zeropage> field is output-only; it is not read by the "
"B<UFFDIO_ZEROPAGE> operation."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_userfaultfd.2:575
msgid ""
"This B<ioctl>(2)  operation returns 0 on success.  In this case, the entire "
"area was zeroed.  On error, -1 is returned and I<errno> is set to indicate "
"the cause of the error.  Possible errors include:"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_userfaultfd.2:583
msgid ""
"The number of bytes zeroed (i.e., the value returned in the I<zeropage> "
"field)  does not equal the value that was specified in the I<range.len> "
"field."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_userfaultfd.2:592
msgid ""
"Either I<range.start> or I<range.len> was not a multiple of the system page "
"size; or I<range.len> was zero; or the range specified was invalid."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_userfaultfd.2:603
msgid ""
"The faulting process has exited at the time of a I<UFFDIO_ZEROPAGE> "
"operation."
msgstr ""

#. type: SS
#: man-pages/man2/ioctl_userfaultfd.2:603
#, no-wrap
msgid "UFFDIO_WAKE"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_userfaultfd.2:607
msgid ""
"(Since Linux 4.3.)  Wake up the thread waiting for page-fault resolution on "
"a specified memory address range."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_userfaultfd.2:627
msgid ""
"The B<UFFDIO_WAKE> operation is used in conjunction with B<UFFDIO_COPY> and "
"B<UFFDIO_ZEROPAGE> operations that have the B<UFFDIO_COPY_MODE_DONTWAKE> or "
"B<UFFDIO_ZEROPAGE_MODE_DONTWAKE> bit set in the I<mode> field.  The "
"userfault monitor can perform several B<UFFDIO_COPY> and B<UFFDIO_ZEROPAGE> "
"operations in a batch and then explicitly wake up the faulting thread using "
"B<UFFDIO_WAKE>."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_userfaultfd.2:633
msgid ""
"The I<argp> argument is a pointer to a I<uffdio_range> structure (shown "
"above) that specifies the address range."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_userfaultfd.2:652
msgid ""
"The I<start> or the I<len> field of the I<ufdio_range> structure was not a "
"multiple of the system page size; or I<len> was zero; or the specified range "
"was otherwise invalid."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_userfaultfd.2:654
msgid "See descriptions of the individual operations, above."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_userfaultfd.2:658
msgid ""
"See descriptions of the individual operations, above.  In addition, the "
"following general errors can occur for all of the operations described "
"above:"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_userfaultfd.2:662
msgid "I<argp> does not point to a valid memory address."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_userfaultfd.2:669
msgid ""
"(For all operations except B<UFFDIO_API>.)  The userfaultfd object has not "
"yet been enabled (via the B<UFFDIO_API> operation)."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_userfaultfd.2:673
msgid "These B<ioctl>(2)  operations are Linux-specific."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_userfaultfd.2:682
msgid ""
"In order to detect available userfault features and enable some subset of "
"those features the userfaultfd file descriptor must be closed after the "
"first B<UFFDIO_API> operation that queries features availability and "
"reopened before the second B<UFFDIO_API> operation that actually enables the "
"desired features."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_userfaultfd.2:685
msgid "See B<userfaultfd>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_userfaultfd.2:689
msgid "B<ioctl>(2), B<mmap>(2), B<userfaultfd>(2)"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_userfaultfd.2:691 man-pages/man2/userfaultfd.2:761
msgid ""
"I<Documentation/admin-guide/mm/userfaultfd.rst> in the Linux kernel source "
"tree"
msgstr ""

#. type: TH
#: man-pages/man2/acct.2:31
#, no-wrap
msgid "ACCT"
msgstr ""

#. type: TH
#: man-pages/man2/acct.2:31 man-pages/man2/access.2:43
#: man-pages/man2/stime.2:30 man-pages/man2/brk.2:29
#: man-pages/man2/vhangup.2:28
#, no-wrap
msgid "2016-03-15"
msgstr ""

#. type: Plain text
#: man-pages/man2/acct.2:34
msgid "acct - switch process accounting on or off"
msgstr ""

#. type: Plain text
#: man-pages/man2/acct.2:38 man-pages/man2/pipe.2:42 man-pages/man2/access.2:49
#: man-pages/man2/unlink.2:39 man-pages/man2/symlink.2:39
#: man-pages/man2/alarm.2:36 man-pages/man2/chown.2:44 man-pages/man2/link.2:38
#: man-pages/man2/dup.2:43 man-pages/man2/readlink.2:50
#: man-pages/man2/read.2:41 man-pages/man2/close.2:42
#, no-wrap
msgid "B<#include E<lt>unistd.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/acct.2:40
#, no-wrap
msgid "B<int acct(const char *>I<filename>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/acct.2:49
msgid "B<acct>():"
msgstr ""

#. 		commit 266865c0e7b79d4196e2cc393693463f03c90bd8
#. type: Plain text
#: man-pages/man2/acct.2:57 man-pages/man2/getdomainname.2:55
#: man-pages/man2/gethostname.2:66 man-pages/man2/vhangup.2:51
#, no-wrap
msgid ""
"    Since glibc 2.21:\n"
"        _DEFAULT_SOURCE\n"
"    In glibc 2.19 and 2.20:\n"
"        _DEFAULT_SOURCE || (_XOPEN_SOURCE && _XOPEN_SOURCE\\ E<lt>\\ 500)\n"
"    Up to and including glibc 2.19:\n"
"        _BSD_SOURCE || (_XOPEN_SOURCE && _XOPEN_SOURCE\\ E<lt>\\ 500)\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/acct.2:68
msgid ""
"The B<acct>()  system call enables or disables process accounting.  If "
"called with the name of an existing file as its argument, accounting is "
"turned on, and records for each terminating process are appended to "
"I<filename> as it terminates.  An argument of NULL causes accounting to be "
"turned off."
msgstr ""

#. type: Plain text
#: man-pages/man2/acct.2:85
msgid ""
"Write permission is denied for the specified file, or search permission is "
"denied for one of the directories in the path prefix of I<filename> (see "
"also B<path_resolution>(7)), or I<filename> is not a regular file."
msgstr ""

#. type: Plain text
#: man-pages/man2/acct.2:89
msgid "I<filename> points outside your accessible address space."
msgstr ""

#. type: Plain text
#: man-pages/man2/acct.2:93
msgid "Error writing to the file I<filename>."
msgstr ""

#. type: TP
#: man-pages/man2/acct.2:93 man-pages/man2/rename.2:355
#: man-pages/man2/truncate.2:148 man-pages/man2/open.2:1019
#: man-pages/man2/open.2:1028 man-pages/man2/ioctl_fideduperange.2:171
#: man-pages/man2/copy_file_range.2:158 man-pages/man2/unlink.2:185
#: man-pages/man2/unlink.2:261 man-pages/man2/ioctl_ficlonerange.2:110
#: man-pages/man2/execve.2:474 man-pages/man2/read.2:175
#, no-wrap
msgid "B<EISDIR>"
msgstr ""

#. type: Plain text
#: man-pages/man2/acct.2:97
msgid "I<filename> is a directory."
msgstr ""

#. type: Plain text
#: man-pages/man2/acct.2:101
msgid "Too many symbolic links were encountered in resolving I<filename>."
msgstr ""

#. type: Plain text
#: man-pages/man2/acct.2:105
msgid "I<filename> was too long."
msgstr ""

#. type: Plain text
#: man-pages/man2/acct.2:111
msgid "The specified file does not exist."
msgstr ""

#. type: Plain text
#: man-pages/man2/acct.2:120
msgid ""
"BSD process accounting has not been enabled when the operating system kernel "
"was compiled.  The kernel configuration parameter controlling this feature "
"is B<CONFIG_BSD_PROCESS_ACCT>."
msgstr ""

#. type: Plain text
#: man-pages/man2/acct.2:125
msgid "A component used as a directory in I<filename> is not in fact a directory."
msgstr ""

#. type: Plain text
#: man-pages/man2/acct.2:131
msgid ""
"The calling process has insufficient privilege to enable process "
"accounting.  On Linux, the B<CAP_SYS_PACCT> capability is required."
msgstr ""

#. type: Plain text
#: man-pages/man2/acct.2:135
msgid "I<filename> refers to a file on a read-only filesystem."
msgstr ""

#. type: TP
#: man-pages/man2/acct.2:135
#, no-wrap
msgid "B<EUSERS>"
msgstr ""

#. type: Plain text
#: man-pages/man2/acct.2:138
msgid "There are no more free file structures or we ran out of memory."
msgstr ""

#.  SVr4 documents an EBUSY error condition, but no EISDIR or ENOSYS.
#.  Also AIX and HP-UX document EBUSY (attempt is made
#.  to enable accounting when it is already enabled), as does Solaris
#.  (attempt is made to enable accounting using the same file that is
#.  currently being used).
#. type: Plain text
#: man-pages/man2/acct.2:145
msgid "SVr4, 4.3BSD (but not POSIX)."
msgstr ""

#. type: Plain text
#: man-pages/man2/acct.2:148
msgid ""
"No accounting is produced for programs running when a system crash occurs.  "
"In particular, nonterminating processes are never accounted for."
msgstr ""

#. type: Plain text
#: man-pages/man2/acct.2:151
msgid ""
"The structure of the records written to the accounting file is described in "
"B<acct>(5)."
msgstr ""

#. type: Plain text
#: man-pages/man2/acct.2:152
msgid "B<acct>(5)"
msgstr ""

#. type: TH
#: man-pages/man2/epoll_create.2:24
#, no-wrap
msgid "EPOLL_CREATE"
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_create.2:27
msgid "epoll_create, epoll_create1 - open an epoll file descriptor"
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_create.2:30 man-pages/man2/epoll_wait.2:28
#, no-wrap
msgid "B<#include E<lt>sys/epoll.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_create.2:33
#, no-wrap
msgid ""
"B<int epoll_create(int >I<size>B<);>\n"
"B<int epoll_create1(int >I<flags>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_create.2:42
msgid ""
"B<epoll_create>()  creates a new B<epoll>(7)  instance.  Since Linux 2.6.8, "
"the I<size> argument is ignored, but must be greater than zero; see NOTES "
"below."
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_create.2:55
msgid ""
"B<epoll_create>()  returns a file descriptor referring to the new epoll "
"instance.  This file descriptor is used for all the subsequent calls to the "
"B<epoll> interface.  When no longer required, the file descriptor returned "
"by B<epoll_create>()  should be closed by using B<close>(2).  When all file "
"descriptors referring to an epoll instance have been closed, the kernel "
"destroys the instance and releases the associated resources for reuse."
msgstr ""

#. type: SS
#: man-pages/man2/epoll_create.2:55
#, no-wrap
msgid "epoll_create1()"
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_create.2:67
msgid ""
"If I<flags> is 0, then, other than the fact that the obsolete I<size> "
"argument is dropped, B<epoll_create1>()  is the same as B<epoll_create>().  "
"The following value can be included in I<flags> to obtain different "
"behavior:"
msgstr ""

#. type: TP
#: man-pages/man2/epoll_create.2:67
#, no-wrap
msgid "B<EPOLL_CLOEXEC>"
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_create.2:84
msgid ""
"On success, these system calls return a nonnegative file descriptor.  On "
"error, -1 is returned, and I<errno> is set to indicate the error."
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_create.2:89
msgid "I<size> is not positive."
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_create.2:94
msgid "(B<epoll_create1>())  Invalid value specified in I<flags>."
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_create.2:102
msgid ""
"The per-user limit on the number of epoll instances imposed by "
"I</proc/sys/fs/epoll/max_user_instances> was encountered.  See B<epoll>(7)  "
"for further details."
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_create.2:111
msgid "There was insufficient memory to create the kernel object."
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_create.2:115
msgid ""
"B<epoll_create>()  was added to the kernel in version 2.6.  Library support "
"is provided in glibc starting with version 2.3.2."
msgstr ""

#.  To be precise: kernel 2.5.44.
#.  The interface should be finalized by Linux kernel 2.5.66.
#. type: Plain text
#: man-pages/man2/epoll_create.2:121
msgid ""
"B<epoll_create1>()  was added to the kernel in version 2.6.27.  Library "
"support is provided in glibc starting with version 2.9."
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_create.2:124
msgid "B<epoll_create>()  is Linux-specific."
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_create.2:147
msgid ""
"In the initial B<epoll_create>()  implementation, the I<size> argument "
"informed the kernel of the number of file descriptors that the caller "
"expected to add to the B<epoll> instance.  The kernel used this information "
"as a hint for the amount of space to initially allocate in internal data "
"structures describing events.  (If necessary, the kernel would allocate more "
"space if the caller's usage exceeded the hint given in I<size>.)  Nowadays, "
"this hint is no longer required (the kernel dynamically sizes the required "
"data structures without needing the hint), but I<size> must still be greater "
"than zero, in order to ensure backward compatibility when new B<epoll> "
"applications are run on older kernels."
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_create.2:151
msgid "B<close>(2), B<epoll_ctl>(2), B<epoll_wait>(2), B<epoll>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/io_submit.2:8
#, no-wrap
msgid "IO_SUBMIT"
msgstr ""

#. type: Plain text
#: man-pages/man2/io_submit.2:11
msgid "io_submit - submit asynchronous I/O blocks for processing"
msgstr ""

#. type: Plain text
#: man-pages/man2/io_submit.2:17
#, no-wrap
msgid ""
"B<int io_submit(aio_context_t >I<ctx_id>B<, long >I<nr>B<, struct iocb "
"**>I<iocbpp>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/io_submit.2:32
msgid ""
"The B<io_submit>()  system call queues I<nr> I/O request blocks for "
"processing in the AIO context I<ctx_id>.  The I<iocbpp> argument should be "
"an array of I<nr> AIO control blocks, which will be submitted to context "
"I<ctx_id>."
msgstr ""

#. type: Plain text
#: man-pages/man2/io_submit.2:38
msgid ""
"The I<iocb> (I/O control block) structure defined in I<linux/aio_abi.h> "
"defines the parameters that control the I/O operation."
msgstr ""

#. type: Plain text
#: man-pages/man2/io_submit.2:42
#, no-wrap
msgid "#include E<lt>linux/aio_abi.hE<gt>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/io_submit.2:56
#, no-wrap
msgid ""
"struct iocb {\n"
"    __u64   aio_data;\n"
"    __u32   PADDED(aio_key, aio_rw_flags);\n"
"    __u16   aio_lio_opcode;\n"
"    __s16   aio_reqprio;\n"
"    __u32   aio_fildes;\n"
"    __u64   aio_buf;\n"
"    __u64   aio_nbytes;\n"
"    __s64   aio_offset;\n"
"    __u64   aio_reserved2;\n"
"    __u32   aio_flags;\n"
"    __u32   aio_resfd;\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/io_submit.2:60 man-pages/man2/sched_setattr.2:117
msgid "The fields of this structure are as follows:"
msgstr ""

#. type: TP
#: man-pages/man2/io_submit.2:60
#, no-wrap
msgid "I<aio_data>"
msgstr ""

#. type: Plain text
#: man-pages/man2/io_submit.2:68
msgid ""
"This data is copied into the I<data> field of the I<io_event> structure upon "
"I/O completion (see B<io_getevents>(2))."
msgstr ""

#. type: TP
#: man-pages/man2/io_submit.2:68
#, no-wrap
msgid "I<aio_key>"
msgstr ""

#. type: Plain text
#: man-pages/man2/io_submit.2:74
msgid ""
"This is an internal field used by the kernel.  Do not modify this field "
"after an B<io_submit>()  call."
msgstr ""

#. type: TP
#: man-pages/man2/io_submit.2:74
#, no-wrap
msgid "I<aio_rw_flags>"
msgstr ""

#. type: Plain text
#: man-pages/man2/io_submit.2:78
msgid "This defines the R/W flags passed with structure.  The valid values are:"
msgstr ""

#. type: TP
#: man-pages/man2/io_submit.2:79 man-pages/man2/readv.2:251
#, no-wrap
msgid "B<RWF_APPEND> (since Linux 4.16)"
msgstr ""

#.  commit e1fc742e14e01d84d9693c4aca4ab23da65811fb
#. type: Plain text
#: man-pages/man2/io_submit.2:93
msgid ""
"Append data to the end of the file.  See the description of the flag of the "
"same name in B<pwritev2>(2)  as well as the description of B<O_APPEND> in "
"B<open>(2).  The I<aio_offset> field is ignored.  The file offset is not "
"changed."
msgstr ""

#. type: TP
#: man-pages/man2/io_submit.2:93
#, no-wrap
msgid "B<RWF_DSYNC> (since Linux 4.13)"
msgstr ""

#. type: Plain text
#: man-pages/man2/io_submit.2:103
msgid ""
"Write operation complete according to requirement of synchronized I/O data "
"integrity.  See the description of the flag of the same name in "
"B<pwritev2>(2)  as well the description of B<O_DSYNC> in B<open>(2)."
msgstr ""

#. type: TP
#: man-pages/man2/io_submit.2:103
#, no-wrap
msgid "B<RWF_HIPRI> (since Linux 4.13)"
msgstr ""

#. type: Plain text
#: man-pages/man2/io_submit.2:106
msgid "High priority request, poll if possible"
msgstr ""

#. type: TP
#: man-pages/man2/io_submit.2:106 man-pages/man2/readv.2:235
#, no-wrap
msgid "B<RWF_NOWAIT> (since Linux 4.14)"
msgstr ""

#. type: Plain text
#: man-pages/man2/io_submit.2:120
msgid ""
"Don't wait if the I/O will block for operations such as file block "
"allocations, dirty page flush, mutex locks, or a congested block device "
"inside the kernel.  If any of these conditions are met, the control block is "
"returned immediately with a return value of B<-EAGAIN> in the I<res> field "
"of the I<io_event> structure (see B<io_getevents>(2))."
msgstr ""

#. type: TP
#: man-pages/man2/io_submit.2:120
#, no-wrap
msgid "B<RWF_SYNC> (since Linux 4.13)"
msgstr ""

#. type: Plain text
#: man-pages/man2/io_submit.2:130
msgid ""
"Write operation complete according to requirement of synchronized I/O file "
"integrity.  See the description of the flag of the same name in "
"B<pwritev2>(2)  as well the description of B<O_SYNC> in B<open>(2)."
msgstr ""

#. type: TP
#: man-pages/man2/io_submit.2:131
#, no-wrap
msgid "I<aio_lio_opcode>"
msgstr ""

#. type: Plain text
#: man-pages/man2/io_submit.2:139
msgid ""
"This defines the type of I/O to be performed by the I<iocb> structure.  The "
"valid values are defined by the enum defined in I<linux/aio_abi.h>:"
msgstr ""

#. type: Plain text
#: man-pages/man2/io_submit.2:151
#, no-wrap
msgid ""
"enum {\n"
"    IOCB_CMD_PREAD = 0,\n"
"    IOCB_CMD_PWRITE = 1,\n"
"    IOCB_CMD_FSYNC = 2,\n"
"    IOCB_CMD_FDSYNC = 3,\n"
"    IOCB_CMD_NOOP = 6,\n"
"    IOCB_CMD_PREADV = 7,\n"
"    IOCB_CMD_PWRITEV = 8,\n"
"};\n"
msgstr ""

#. type: TP
#: man-pages/man2/io_submit.2:153
#, no-wrap
msgid "I<aio_reqprio>"
msgstr ""

#. type: Plain text
#: man-pages/man2/io_submit.2:156
msgid "This defines the requests priority."
msgstr ""

#. type: TP
#: man-pages/man2/io_submit.2:156
#, no-wrap
msgid "I<aio_fildes>"
msgstr ""

#. type: Plain text
#: man-pages/man2/io_submit.2:159
msgid "The file descriptor on which the I/O operation is to be performed."
msgstr ""

#. type: TP
#: man-pages/man2/io_submit.2:159
#, no-wrap
msgid "I<aio_buf>"
msgstr ""

#. type: Plain text
#: man-pages/man2/io_submit.2:162
msgid "This is the buffer used to transfer data for a read or write operation."
msgstr ""

#. type: TP
#: man-pages/man2/io_submit.2:162
#, no-wrap
msgid "I<aio_nbytes>"
msgstr ""

#. type: Plain text
#: man-pages/man2/io_submit.2:166
msgid "This is the size of the buffer pointed to by I<aio_buf>."
msgstr ""

#. type: TP
#: man-pages/man2/io_submit.2:166
#, no-wrap
msgid "I<aio_offset>"
msgstr ""

#. type: Plain text
#: man-pages/man2/io_submit.2:169
msgid "This is the file offset at which the I/O operation is to be performed."
msgstr ""

#. type: TP
#: man-pages/man2/io_submit.2:169
#, no-wrap
msgid "I<aio_flags>"
msgstr ""

#. type: Plain text
#: man-pages/man2/io_submit.2:175
msgid ""
"This is the set of flags associated with the I<iocb> structure.  The valid "
"values are:"
msgstr ""

#. type: TP
#: man-pages/man2/io_submit.2:176
#, no-wrap
msgid "B<IOCB_FLAG_RESFD>"
msgstr ""

#. type: Plain text
#: man-pages/man2/io_submit.2:182
msgid ""
"Asynchronous I/O control must signal the file descriptor mentioned in "
"I<aio_resfd> upon completion."
msgstr ""

#. type: TP
#: man-pages/man2/io_submit.2:182
#, no-wrap
msgid "B<IOCB_FLAG_IOPRIO> (since Linux 4.18)"
msgstr ""

#.  commit d9a08a9e616beeccdbd0e7262b7225ffdfa49e92
#. type: Plain text
#: man-pages/man2/io_submit.2:191
msgid ""
"Interpret the I<aio_reqprio> field as an B<IOPRIO_VALUE> as defined by "
"I<linux/ioprio.h>."
msgstr ""

#. type: TP
#: man-pages/man2/io_submit.2:192
#, no-wrap
msgid "I<aio_resfd>"
msgstr ""

#. type: Plain text
#: man-pages/man2/io_submit.2:195
msgid "The file descriptor to signal in the event of asynchronous I/O completion."
msgstr ""

#. type: Plain text
#: man-pages/man2/io_submit.2:201
msgid ""
"On success, B<io_submit>()  returns the number of I<iocb>s submitted (which "
"may be less than I<nr>, or 0 if I<nr> is zero).  For the failure return, see "
"NOTES."
msgstr ""

#. type: Plain text
#: man-pages/man2/io_submit.2:205
msgid "Insufficient resources are available to queue any I<iocb>s."
msgstr ""

#. type: Plain text
#: man-pages/man2/io_submit.2:208
msgid "The file descriptor specified in the first I<iocb> is invalid."
msgstr ""

#. type: Plain text
#: man-pages/man2/io_submit.2:211 man-pages/man2/io_cancel.2:49
msgid "One of the data structures points to invalid data."
msgstr ""

#. type: Plain text
#: man-pages/man2/io_submit.2:221
msgid ""
"The AIO context specified by I<ctx_id> is invalid.  I<nr> is less than 0.  "
"The I<iocb> at I<*iocbpp[0]> is not properly initialized, the operation "
"specified is invalid for the file descriptor in the I<iocb>, or the value in "
"the I<aio_reqprio> field is invalid."
msgstr ""

#. type: Plain text
#: man-pages/man2/io_submit.2:225
msgid "B<io_submit>()  is not implemented on this architecture."
msgstr ""

#. type: Plain text
#: man-pages/man2/io_submit.2:234
msgid ""
"The I<aio_reqprio> field is set with the class B<IOPRIO_CLASS_RT>, but the "
"submitting context does not have the B<CAP_SYS_ADMIN> capability."
msgstr ""

#. type: Plain text
#: man-pages/man2/io_submit.2:242
msgid ""
"B<io_submit>()  is Linux-specific and should not be used in programs that "
"are intended to be portable."
msgstr ""

#.  http://git.fedorahosted.org/git/?p=libaio.git
#. type: Plain text
#: man-pages/man2/io_submit.2:251
msgid ""
"Glibc does not provide a wrapper function for this system call.  You could "
"invoke it using B<syscall>(2).  But instead, you probably want to use the "
"B<io_submit>()  wrapper function provided by I<libaio>."
msgstr ""

#.  But glibc is confused, since <libaio.h> uses 'io_context_t' to declare
#.  the system call.
#. type: Plain text
#: man-pages/man2/io_submit.2:272 man-pages/man2/io_cancel.2:94
#: man-pages/man2/io_getevents.2:120 man-pages/man2/io_destroy.2:83
msgid ""
"Note that the I<libaio> wrapper function uses a different type "
"(I<io_context_t>)  for the I<ctx_id> argument.  Note also that the I<libaio> "
"wrapper does not follow the usual C library conventions for indicating "
"errors: on error it returns a negated error number (the negative of one of "
"the values listed in ERRORS).  If the system call is invoked via "
"B<syscall>(2), then the return value follows the usual conventions for "
"indicating an error: -1, with I<errno> set to a (positive) value that "
"indicates the error."
msgstr ""

#. type: Plain text
#: man-pages/man2/io_submit.2:277
msgid ""
"B<io_cancel>(2), B<io_destroy>(2), B<io_getevents>(2), B<io_setup>(2), "
"B<aio>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/setsid.2:31
#, no-wrap
msgid "SETSID"
msgstr ""

#. type: Plain text
#: man-pages/man2/setsid.2:34
msgid "setsid - creates a session and sets the process group ID"
msgstr ""

#. type: Plain text
#: man-pages/man2/setsid.2:37 man-pages/man2/umask.2:39
#: man-pages/man2/getpid.2:30 man-pages/man2/truncate.2:50
#: man-pages/man2/setuid.2:36 man-pages/man2/seteuid.2:34
#: man-pages/man2/setreuid.2:51 man-pages/man2/getuid.2:33
#: man-pages/man2/fork.2:44 man-pages/man2/lseek.2:52
#: man-pages/man2/getgid.2:32 man-pages/man2/getgroups.2:37
#: man-pages/man2/wait.2:54 man-pages/man2/getsid.2:32
#: man-pages/man2/vfork.2:34 man-pages/man2/setgid.2:35
#: man-pages/man2/setpgid.2:53
msgid "B<#include E<lt>sys/types.hE<gt>>"
msgstr ""

#. type: Plain text
#: man-pages/man2/setsid.2:41
msgid "B<pid_t setsid(void);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/setsid.2:52
msgid ""
"B<setsid>()  creates a new session if the calling process is not a process "
"group leader.  The calling process is the leader of the new session (i.e., "
"its session ID is made the same as its process ID).  The calling process "
"also becomes the process group leader of a new process group in the session "
"(i.e., its process group ID is made the same as its process ID)."
msgstr ""

#. type: Plain text
#: man-pages/man2/setsid.2:55
msgid ""
"The calling process will be the only process in the new process group and in "
"the new session."
msgstr ""

#. type: Plain text
#: man-pages/man2/setsid.2:59
msgid ""
"Initially, the new session has no controlling terminal.  For details of how "
"a session acquires a controlling terminal, see B<credentials>(7)."
msgstr ""

#. type: Plain text
#: man-pages/man2/setsid.2:66
msgid ""
"On success, the (new) session ID of the calling process is returned.  On "
"error, I<(pid_t)\\ -1> is returned, and I<errno> is set to indicate the "
"error."
msgstr ""

#. type: Plain text
#: man-pages/man2/setsid.2:73
msgid ""
"The process group ID of any process equals the PID of the calling process.  "
"Thus, in particular, B<setsid>()  fails if the calling process is already a "
"process group leader."
msgstr ""

#. type: Plain text
#: man-pages/man2/setsid.2:81
msgid ""
"A child created via B<fork>(2)  inherits its parent's session ID.  The "
"session ID is preserved across an B<execve>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/setsid.2:98
msgid ""
"A process group leader is a process whose process group ID equals its PID.  "
"Disallowing a process group leader from calling B<setsid>()  prevents the "
"possibility that a process group leader places itself in a new session while "
"other processes in the process group remain in the original session; such a "
"scenario would break the strict two-level hierarchy of sessions and process "
"groups.  In order to be sure that B<setsid>()  will succeed, call B<fork>(2)  "
"and have the parent B<_exit>(2), while the child (which by definition can't "
"be a process group leader) calls B<setsid>()."
msgstr ""

#. type: Plain text
#: man-pages/man2/setsid.2:105
msgid ""
"If a session has a controlling terminal, and the B<CLOCAL> flag for that "
"terminal is not set, and a terminal hangup occurs, then the session leader "
"is sent a B<SIGHUP> signal."
msgstr ""

#. type: Plain text
#: man-pages/man2/setsid.2:110
msgid ""
"If a process that is a session leader terminates, then a B<SIGHUP> signal is "
"sent to each process in the foreground process group of the controlling "
"terminal."
msgstr ""

#. type: Plain text
#: man-pages/man2/setsid.2:117
msgid ""
"B<setsid>(1), B<getsid>(2), B<setpgid>(2), B<setpgrp>(2), B<tcgetsid>(3), "
"B<credentials>(7), B<sched>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/io_cancel.2:7
#, no-wrap
msgid "IO_CANCEL"
msgstr ""

#. type: Plain text
#: man-pages/man2/io_cancel.2:10
msgid "io_cancel - cancel an outstanding asynchronous I/O operation"
msgstr ""

#. type: Plain text
#: man-pages/man2/io_cancel.2:16
#, no-wrap
msgid ""
"B<int io_cancel(aio_context_t >I<ctx_id>B<, struct iocb *>I<iocb>B<,>\n"
"B<              struct io_event *>I<result>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/io_cancel.2:37
msgid ""
"The B<io_cancel>()  system call attempts to cancel an asynchronous I/O "
"operation previously submitted with B<io_submit>(2).  The I<iocb> argument "
"describes the operation to be canceled and the I<ctx_id> argument is the AIO "
"context to which the operation was submitted.  If the operation is "
"successfully canceled, the event will be copied into the memory pointed to "
"by I<result> without being placed into the completion queue."
msgstr ""

#. type: Plain text
#: man-pages/man2/io_cancel.2:42
msgid "On success, B<io_cancel>()  returns 0.  For the failure return, see NOTES."
msgstr ""

#. type: Plain text
#: man-pages/man2/io_cancel.2:46
msgid "The I<iocb> specified was not canceled."
msgstr ""

#. type: Plain text
#: man-pages/man2/io_cancel.2:52 man-pages/man2/io_destroy.2:41
msgid "The AIO context specified by I<ctx_id> is invalid."
msgstr ""

#. type: Plain text
#: man-pages/man2/io_cancel.2:56
msgid "B<io_cancel>()  is not implemented on this architecture."
msgstr ""

#. type: Plain text
#: man-pages/man2/io_cancel.2:64
msgid ""
"B<io_cancel>()  is Linux-specific and should not be used in programs that "
"are intended to be portable."
msgstr ""

#.  http://git.fedorahosted.org/git/?p=libaio.git
#. type: Plain text
#: man-pages/man2/io_cancel.2:73
msgid ""
"Glibc does not provide a wrapper function for this system call.  You could "
"invoke it using B<syscall>(2).  But instead, you probably want to use the "
"B<io_cancel>()  wrapper function provided by I<libaio>."
msgstr ""

#. type: Plain text
#: man-pages/man2/io_cancel.2:99
msgid ""
"B<io_destroy>(2), B<io_getevents>(2), B<io_setup>(2), B<io_submit>(2), "
"B<aio>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/mknod.2:15
#, no-wrap
msgid "MKNOD"
msgstr ""

#. type: Plain text
#: man-pages/man2/mknod.2:18
msgid "mknod, mknodat - create a special or ordinary file"
msgstr ""

#. type: Plain text
#: man-pages/man2/mknod.2:24
#, no-wrap
msgid ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>sys/stat.hE<gt>>\n"
"B<#include E<lt>fcntl.hE<gt>>\n"
"B<#include E<lt>unistd.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/mknod.2:26
#, no-wrap
msgid ""
"B<int mknod(const char *>I<pathname>B<, mode_t >I<mode>B<, dev_t "
">I<dev>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/mknod.2:29 man-pages/man2/stat.2:55 man-pages/man2/mkdir.2:24
#, no-wrap
msgid ""
"B<#include E<lt>fcntl.hE<gt>           >/* Definition of AT_* constants */\n"
"B<#include E<lt>sys/stat.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/mknod.2:32
#, no-wrap
msgid ""
"B<int mknodat(int >I<dirfd>B<, const char *>I<pathname>B<, mode_t "
">I<mode>B<, dev_t >I<dev>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/mknod.2:40
msgid "B<mknod>():"
msgstr ""

#.     || _XOPEN_SOURCE\ &&\ _XOPEN_SOURCE_EXTENDED
#. type: Plain text
#: man-pages/man2/mknod.2:46
#, no-wrap
msgid ""
"_XOPEN_SOURCE\\ E<gt>=\\ 500\n"
"    || /* Since glibc 2.19: */ _DEFAULT_SOURCE\n"
"    || /* Glibc versions E<lt>= 2.19: */ _BSD_SOURCE || _SVID_SOURCE\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/mknod.2:58
msgid ""
"The system call B<mknod>()  creates a filesystem node (file, device special "
"file, or named pipe) named I<pathname>, with attributes specified by I<mode> "
"and I<dev>."
msgstr ""

#. type: Plain text
#: man-pages/man2/mknod.2:66
msgid ""
"The I<mode> argument specifies both the file mode to use and the type of "
"node to be created.  It should be a combination (using bitwise OR) of one of "
"the file types listed below and zero or more of the file mode bits listed in "
"B<inode>(7)."
msgstr ""

#. type: Plain text
#: man-pages/man2/mknod.2:72
msgid ""
"The file mode is modified by the process's I<umask> in the usual way: in the "
"absence of a default ACL, the permissions of the created node are (I<mode> & "
"~I<umask>)."
msgstr ""

#.  (S_IFSOCK since Linux 1.2.4)
#. type: Plain text
#: man-pages/man2/mknod.2:86
msgid ""
"The file type must be one of B<S_IFREG>, B<S_IFCHR>, B<S_IFBLK>, B<S_IFIFO>, "
"or B<S_IFSOCK> to specify a regular file (which will be created empty), "
"character special file, block special file, FIFO (named pipe), or UNIX "
"domain socket, respectively.  (Zero file type is equivalent to type "
"B<S_IFREG>.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/mknod.2:99
msgid ""
"If the file type is B<S_IFCHR> or B<S_IFBLK>, then I<dev> specifies the "
"major and minor numbers of the newly created device special file "
"(B<makedev>(3)  may be useful to build the value for I<dev>); otherwise it "
"is ignored."
msgstr ""

#. type: Plain text
#: man-pages/man2/mknod.2:105
msgid ""
"If I<pathname> already exists, or is a symbolic link, this call fails with "
"an B<EEXIST> error."
msgstr ""

#. type: Plain text
#: man-pages/man2/mknod.2:114
msgid ""
"The newly created node will be owned by the effective user ID of the "
"process.  If the directory containing the node has the set-group-ID bit set, "
"or if the filesystem is mounted with BSD group semantics, the new node will "
"inherit the group ownership from its parent directory; otherwise it will be "
"owned by the effective group ID of the process."
msgstr ""

#. type: SS
#: man-pages/man2/mknod.2:114
#, no-wrap
msgid "mknodat()"
msgstr ""

#. type: Plain text
#: man-pages/man2/mknod.2:120
msgid ""
"The B<mknodat>()  system call operates in exactly the same way as "
"B<mknod>(), except for the differences described here."
msgstr ""

#. type: Plain text
#: man-pages/man2/mknod.2:130
msgid ""
"If the pathname given in I<pathname> is relative, then it is interpreted "
"relative to the directory referred to by the file descriptor I<dirfd> "
"(rather than relative to the current working directory of the calling "
"process, as is done by B<mknod>()  for a relative pathname)."
msgstr ""

#. type: Plain text
#: man-pages/man2/mknod.2:142
msgid ""
"If I<pathname> is relative and I<dirfd> is the special value B<AT_FDCWD>, "
"then I<pathname> is interpreted relative to the current working directory of "
"the calling process (like B<mknod>())."
msgstr ""

#. type: Plain text
#: man-pages/man2/mknod.2:153
msgid "See B<openat>(2)  for an explanation of the need for B<mknodat>()."
msgstr ""

#. type: Plain text
#: man-pages/man2/mknod.2:160
msgid ""
"B<mknod>()  and B<mknodat>()  return zero on success, or -1 if an error "
"occurred (in which case, I<errno> is set appropriately)."
msgstr ""

#. type: Plain text
#: man-pages/man2/mknod.2:169
msgid ""
"The parent directory does not allow write permission to the process, or one "
"of the directories in the path prefix of I<pathname> did not allow search "
"permission.  (See also B<path_resolution>(7).)"
msgstr ""

#. type: Plain text
#: man-pages/man2/mknod.2:173 man-pages/man2/mkdir.2:138
msgid ""
"The user's quota of disk blocks or inodes on the filesystem has been "
"exhausted."
msgstr ""

#. type: TP
#: man-pages/man2/mknod.2:173 man-pages/man2/rename.2:468
#: man-pages/man2/open.2:966 man-pages/man2/msgget.2:164
#: man-pages/man2/shmget.2:230 man-pages/man2/setxattr.2:119
#: man-pages/man2/spu_create.2:178 man-pages/man2/semget.2:174
#: man-pages/man2/inotify_add_watch.2:91 man-pages/man2/symlink.2:161
#: man-pages/man2/keyctl.2:1689 man-pages/man2/create_module.2:36
#: man-pages/man2/init_module.2:198 man-pages/man2/link.2:207
#: man-pages/man2/mmap.2:542 man-pages/man2/mkdir.2:138
#: man-pages/man2/epoll_ctl.2:275
#, no-wrap
msgid "B<EEXIST>"
msgstr ""

#. type: Plain text
#: man-pages/man2/mknod.2:180
msgid ""
"I<pathname> already exists.  This includes the case where I<pathname> is a "
"symbolic link, dangling or not."
msgstr ""

#. type: Plain text
#: man-pages/man2/mknod.2:188
msgid ""
"I<mode> requested creation of something other than a regular file, device "
"special file, FIFO or socket."
msgstr ""

#. type: Plain text
#: man-pages/man2/mknod.2:208
msgid "The device containing I<pathname> has no room for the new node."
msgstr ""

#. type: Plain text
#: man-pages/man2/mknod.2:213 man-pages/man2/access.2:229
#: man-pages/man2/unlink.2:212 man-pages/man2/mkdir.2:187
msgid "A component used as a directory in I<pathname> is not, in fact, a directory."
msgstr ""

#.  For UNIX domain sockets and regular files, EPERM is returned only in
#.  Linux 2.2 and earlier; in Linux 2.4 and later, unprivileged can
#.  use mknod() to make these files.
#. type: Plain text
#: man-pages/man2/mknod.2:227
msgid ""
"I<mode> requested creation of something other than a regular file, FIFO "
"(named pipe), or UNIX domain socket, and the caller is not privileged "
"(Linux: does not have the B<CAP_MKNOD> capability); also returned if the "
"filesystem containing I<pathname> does not support the type of node "
"requested."
msgstr ""

#. type: Plain text
#: man-pages/man2/mknod.2:231 man-pages/man2/unlink.2:244
#: man-pages/man2/mkdir.2:196
msgid "I<pathname> refers to a file on a read-only filesystem."
msgstr ""

#. type: Plain text
#: man-pages/man2/mknod.2:234
msgid "The following additional errors can occur for B<mknodat>():"
msgstr ""

#. type: Plain text
#: man-pages/man2/mknod.2:248
msgid ""
"B<mknodat>()  was added to Linux in kernel 2.6.16; library support was added "
"to glibc in version 2.4."
msgstr ""

#.  The Linux version differs from the SVr4 version in that it
#.  does not require root permission to create pipes, also in that no
#.  EMULTIHOP, ENOLINK, or EINTR error is documented.
#. type: Plain text
#: man-pages/man2/mknod.2:254
msgid "B<mknod>(): SVr4, 4.4BSD, POSIX.1-2001 (but see below), POSIX.1-2008."
msgstr ""

#. type: Plain text
#: man-pages/man2/mknod.2:257
msgid "B<mknodat>(): POSIX.1-2008."
msgstr ""

#. type: Plain text
#: man-pages/man2/mknod.2:275
msgid ""
"POSIX.1-2001 says: \"The only portable use of B<mknod>()  is to create a "
"FIFO-special file.  If I<mode> is not B<S_IFIFO> or I<dev> is not 0, the "
"behavior of B<mknod>()  is unspecified.\" However, nowadays one should never "
"use B<mknod>()  for this purpose; one should use B<mkfifo>(3), a function "
"especially defined for this purpose."
msgstr ""

#.  and one should make UNIX domain sockets with socket(2) and bind(2).
#. type: Plain text
#: man-pages/man2/mknod.2:282
msgid ""
"Under Linux, B<mknod>()  cannot be used to create directories.  One should "
"make directories with B<mkdir>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/mknod.2:288
msgid ""
"There are many infelicities in the protocol underlying NFS.  Some of these "
"affect B<mknod>()  and B<mknodat>()."
msgstr ""

#. type: Plain text
#: man-pages/man2/mknod.2:302
msgid ""
"B<mknod>(1), B<chmod>(2), B<chown>(2), B<fcntl>(2), B<mkdir>(2), "
"B<mount>(2), B<socket>(2), B<stat>(2), B<umask>(2), B<unlink>(2), "
"B<makedev>(3), B<mkfifo>(3), B<acl>(5)  B<path_resolution>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/getdents.2:31
#, no-wrap
msgid "GETDENTS"
msgstr ""

#. type: Plain text
#: man-pages/man2/getdents.2:34
msgid "getdents, getdents64 - get directory entries"
msgstr ""

#. type: Plain text
#: man-pages/man2/getdents.2:40
#, no-wrap
msgid ""
"B<int getdents(unsigned int >I<fd>B<, struct linux_dirent *>I<dirp>B<,>\n"
"B<             unsigned int >I<count>B<);>\n"
"B<int getdents64(unsigned int >I<fd>B<, struct linux_dirent64 "
"*>I<dirp>B<,>\n"
"B<             unsigned int >I<count>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/getdents.2:44 man-pages/man2/set_thread_area.2:36
#: man-pages/man2/kexec_load.2:46 man-pages/man2/rt_sigqueueinfo.2:38
#: man-pages/man2/ioprio_set.2:35 man-pages/man2/sgetmask.2:36
#: man-pages/man2/get_robust_list.2:46
msgid "I<Note>: There are no glibc wrappers for these system calls; see NOTES."
msgstr ""

#. type: Plain text
#: man-pages/man2/getdents.2:50
msgid ""
"These are not the interfaces you are interested in.  Look at B<readdir>(3)  "
"for the POSIX-conforming C library interface.  This page documents the bare "
"kernel system call interfaces."
msgstr ""

#. type: SS
#: man-pages/man2/getdents.2:50
#, no-wrap
msgid "getdents()"
msgstr ""

#. type: Plain text
#: man-pages/man2/getdents.2:63
msgid ""
"The system call B<getdents>()  reads several I<linux_dirent> structures from "
"the directory referred to by the open file descriptor I<fd> into the buffer "
"pointed to by I<dirp>.  The argument I<count> specifies the size of that "
"buffer."
msgstr ""

#. type: Plain text
#: man-pages/man2/getdents.2:67
msgid "The I<linux_dirent> structure is declared as follows:"
msgstr ""

#. type: Plain text
#: man-pages/man2/getdents.2:83
#, no-wrap
msgid ""
"struct linux_dirent {\n"
"    unsigned long  d_ino;     /* Inode number */\n"
"    unsigned long  d_off;     /* Offset to next I<linux_dirent> */\n"
"    unsigned short d_reclen;  /* Length of this I<linux_dirent> */\n"
"    char           d_name[];  /* Filename (null-terminated) */\n"
"                      /* length is actually (d_reclen - 2 -\n"
"                         offsetof(struct linux_dirent, d_name)) */\n"
"    /*\n"
"    char           pad;       // Zero padding byte\n"
"    char           d_type;    // File type (only since Linux\n"
"                              // 2.6.4); offset is (d_reclen - 1)\n"
"    */\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/getdents.2:96
msgid ""
"I<d_ino> is an inode number.  I<d_off> is the distance from the start of the "
"directory to the start of the next I<linux_dirent>.  I<d_reclen> is the size "
"of this entire I<linux_dirent>.  I<d_name> is a null-terminated filename."
msgstr ""

#. type: Plain text
#: man-pages/man2/getdents.2:101
msgid ""
"I<d_type> is a byte at the end of the structure that indicates the file "
"type.  It contains one of the following values (defined in "
"I<E<lt>dirent.hE<gt>>):"
msgstr ""

#. type: TP
#: man-pages/man2/getdents.2:101
#, no-wrap
msgid "B<DT_BLK>"
msgstr ""

#. type: Plain text
#: man-pages/man2/getdents.2:104
msgid "This is a block device."
msgstr ""

#. type: TP
#: man-pages/man2/getdents.2:104
#, no-wrap
msgid "B<DT_CHR>"
msgstr ""

#. type: Plain text
#: man-pages/man2/getdents.2:107
msgid "This is a character device."
msgstr ""

#. type: TP
#: man-pages/man2/getdents.2:107
#, no-wrap
msgid "B<DT_DIR>"
msgstr ""

#. type: Plain text
#: man-pages/man2/getdents.2:110
msgid "This is a directory."
msgstr ""

#. type: TP
#: man-pages/man2/getdents.2:110
#, no-wrap
msgid "B<DT_FIFO>"
msgstr ""

#. type: Plain text
#: man-pages/man2/getdents.2:113
msgid "This is a named pipe (FIFO)."
msgstr ""

#. type: TP
#: man-pages/man2/getdents.2:113
#, no-wrap
msgid "B<DT_LNK>"
msgstr ""

#. type: Plain text
#: man-pages/man2/getdents.2:116
msgid "This is a symbolic link."
msgstr ""

#. type: TP
#: man-pages/man2/getdents.2:116
#, no-wrap
msgid "B<DT_REG>"
msgstr ""

#. type: Plain text
#: man-pages/man2/getdents.2:119
msgid "This is a regular file."
msgstr ""

#. type: TP
#: man-pages/man2/getdents.2:119
#, no-wrap
msgid "B<DT_SOCK>"
msgstr ""

#. type: Plain text
#: man-pages/man2/getdents.2:122
msgid "This is a UNIX domain socket."
msgstr ""

#. type: TP
#: man-pages/man2/getdents.2:122
#, no-wrap
msgid "B<DT_UNKNOWN>"
msgstr ""

#. type: Plain text
#: man-pages/man2/getdents.2:125
msgid "The file type is unknown."
msgstr ""

#. type: Plain text
#: man-pages/man2/getdents.2:135
msgid ""
"The I<d_type> field is implemented since Linux 2.6.4.  It occupies a space "
"that was previously a zero-filled padding byte in the I<linux_dirent> "
"structure.  Thus, on kernels up to and including 2.6.3, attempting to access "
"this field always provides the value 0 (B<DT_UNKNOWN>)."
msgstr ""

#.  kernel 2.6.27
#.  The same sentence is in readdir.2
#. type: Plain text
#: man-pages/man2/getdents.2:144
msgid ""
"Currently, only some filesystems (among them: Btrfs, ext2, ext3, and ext4)  "
"have full support for returning the file type in I<d_type>.  All "
"applications must properly handle a return of B<DT_UNKNOWN>."
msgstr ""

#. type: SS
#: man-pages/man2/getdents.2:144
#, no-wrap
msgid "getdents64()"
msgstr ""

#. type: Plain text
#: man-pages/man2/getdents.2:160
msgid ""
"The original Linux B<getdents>()  system call did not handle large "
"filesystems and large file offsets.  Consequently, Linux 2.4 added "
"B<getdents64>(), with wider types for the I<d_ino> and I<d_off> fields.  In "
"addition, B<getdents64>()  supports an explicit I<d_type> field."
msgstr ""

#. type: Plain text
#: man-pages/man2/getdents.2:167
msgid ""
"The B<getdents64>()  system call is like B<getdents>(), except that its "
"second argument is a pointer to a buffer containing structures of the "
"following type:"
msgstr ""

#. type: Plain text
#: man-pages/man2/getdents.2:177
#, no-wrap
msgid ""
"struct linux_dirent64 {\n"
"    ino64_t        d_ino;    /* 64-bit inode number */\n"
"    off64_t        d_off;    /* 64-bit offset to next structure */\n"
"    unsigned short d_reclen; /* Size of this dirent */\n"
"    unsigned char  d_type;   /* File type */\n"
"    char           d_name[]; /* Filename (null-terminated) */\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/getdents.2:185
msgid ""
"On success, the number of bytes read is returned.  On end of directory, 0 is "
"returned.  On error, -1 is returned, and I<errno> is set appropriately."
msgstr ""

#. type: Plain text
#: man-pages/man2/getdents.2:205 man-pages/man2/stime.2:73
#: man-pages/man2/ustat.2:98 man-pages/man2/sysfs.2:103
msgid "SVr4."
msgstr ""

#. type: Plain text
#: man-pages/man2/getdents.2:216
msgid ""
"Glibc does not provide a wrapper for these system calls; call them using "
"B<syscall>(2).  You will need to define the I<linux_dirent> or "
"I<linux_dirent64> structure yourself.  However, you probably want to use "
"B<readdir>(3)  instead."
msgstr ""

#. type: Plain text
#: man-pages/man2/getdents.2:219
msgid "These calls supersede B<readdir>(2)."
msgstr ""

#.  FIXME The example program needs to be revised, since it uses the older
#.  getdents() system call and the structure with smaller field widths.
#. type: Plain text
#: man-pages/man2/getdents.2:226
msgid ""
"The program below demonstrates the use of B<getdents>().  The following "
"output shows an example of what we see when running this program on an ext2 "
"directory:"
msgstr ""

#. type: Plain text
#: man-pages/man2/getdents.2:239
#, no-wrap
msgid ""
"$B< ./a.out /testfs/>\n"
"--------------- nread=120 ---------------\n"
"inode#    file type  d_reclen  d_off   d_name\n"
"       2  directory    16         12  .\n"
"       2  directory    16         24  ..\n"
"      11  directory    24         44  lost+found\n"
"      12  regular      16         56  a\n"
"  228929  directory    16         68  sub\n"
"   16353  directory    16         80  sub2\n"
"  130817  directory    16       4096  sub3\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/getdents.2:252
#, no-wrap
msgid ""
"#define _GNU_SOURCE\n"
"#include E<lt>dirent.hE<gt>     /* Defines DT_* constants */\n"
"#include E<lt>fcntl.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>sys/stat.hE<gt>\n"
"#include E<lt>sys/syscall.hE<gt>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/getdents.2:255 man-pages/man2/timerfd_create.2:554
#, no-wrap
msgid ""
"#define handle_error(msg) \\e\n"
"        do { perror(msg); exit(EXIT_FAILURE); } while (0)\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/getdents.2:262
#, no-wrap
msgid ""
"struct linux_dirent {\n"
"    long           d_ino;\n"
"    off_t          d_off;\n"
"    unsigned short d_reclen;\n"
"    char           d_name[];\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/getdents.2:264 man-pages/man2/select_tut.2:635
#, no-wrap
msgid "#define BUF_SIZE 1024\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/getdents.2:273
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int fd, nread;\n"
"    char buf[BUF_SIZE];\n"
"    struct linux_dirent *d;\n"
"    int bpos;\n"
"    char d_type;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/getdents.2:277
#, no-wrap
msgid ""
"    fd = open(argc E<gt> 1 ? argv[1] : \".\", O_RDONLY | O_DIRECTORY);\n"
"    if (fd == -1)\n"
"        handle_error(\"open\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/getdents.2:282
#, no-wrap
msgid ""
"    for ( ; ; ) {\n"
"        nread = syscall(SYS_getdents, fd, buf, BUF_SIZE);\n"
"        if (nread == -1)\n"
"            handle_error(\"getdents\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/getdents.2:285
#, no-wrap
msgid ""
"        if (nread == 0)\n"
"            break;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/getdents.2:304
#, no-wrap
msgid ""
"        printf(\"--------------- nread=%d ---------------\\en\", nread);\n"
"        printf(\"inode#    file type  d_reclen  d_off   d_name\\en\");\n"
"        for (bpos = 0; bpos E<lt> nread;) {\n"
"            d = (struct linux_dirent *) (buf + bpos);\n"
"            printf(\"%8ld  \", d-E<gt>d_ino);\n"
"            d_type = *(buf + bpos + d-E<gt>d_reclen - 1);\n"
"            printf(\"%-10s \", (d_type == DT_REG) ?  \"regular\" :\n"
"                             (d_type == DT_DIR) ?  \"directory\" :\n"
"                             (d_type == DT_FIFO) ? \"FIFO\" :\n"
"                             (d_type == DT_SOCK) ? \"socket\" :\n"
"                             (d_type == DT_LNK) ?  \"symlink\" :\n"
"                             (d_type == DT_BLK) ?  \"block dev\" :\n"
"                             (d_type == DT_CHR) ?  \"char dev\" : "
"\"???\");\n"
"            printf(\"%4d %10lld  %s\\en\", d-E<gt>d_reclen,\n"
"                    (long long) d-E<gt>d_off, d-E<gt>d_name);\n"
"            bpos += d-E<gt>d_reclen;\n"
"        }\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/getdents.2:311
msgid "B<readdir>(2), B<readdir>(3), B<inode>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/umask.2:34
#, no-wrap
msgid "UMASK"
msgstr ""

#. type: Plain text
#: man-pages/man2/umask.2:37
msgid "umask - set file mode creation mask"
msgstr ""

#. type: Plain text
#: man-pages/man2/umask.2:41
msgid "B<#include E<lt>sys/stat.hE<gt>>"
msgstr ""

#. type: Plain text
#: man-pages/man2/umask.2:43
msgid "B<mode_t umask(mode_t >I<mask>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/umask.2:50
msgid ""
"B<umask>()  sets the calling process's file mode creation mask (umask) to "
"I<mask> & 0777 (i.e., only the file permission bits of I<mask> are used), "
"and returns the previous value of the mask."
msgstr ""

#.  e.g., mkfifo(), creat(), mknod(), sem_open(), mq_open(), shm_open()
#.  but NOT the System V IPC *get() calls
#. type: Plain text
#: man-pages/man2/umask.2:65
msgid ""
"The umask is used by B<open>(2), B<mkdir>(2), and other system calls that "
"create files to modify the permissions placed on newly created files or "
"directories.  Specifically, permissions in the umask are turned off from the "
"I<mode> argument to B<open>(2)  and B<mkdir>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/umask.2:74
msgid ""
"Alternatively, if the parent directory has a default ACL (see B<acl>(5)), "
"the umask is ignored, the default ACL is inherited, the permission bits are "
"set based on the inherited ACL, and permission bits absent in the I<mode> "
"argument are turned off.  For example, the following default ACL is "
"equivalent to a umask of 022:"
msgstr ""

#. type: Plain text
#: man-pages/man2/umask.2:76
#, no-wrap
msgid "    u::rwx,g::r-x,o::r-x\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/umask.2:81
msgid ""
"Combining the effect of this default ACL with a I<mode> argument of 0666 "
"(rw-rw-rw-), the resulting file permissions would be 0644 (rw-r--r--)."
msgstr ""

#. type: Plain text
#: man-pages/man2/umask.2:86
msgid ""
"The constants that should be used to specify I<mask> are described in "
"B<inode>(7)."
msgstr ""

#. type: Plain text
#: man-pages/man2/umask.2:95
msgid ""
"The typical default value for the process umask is I<S_IWGRP\\ |\\ S_IWOTH> "
"(octal 022).  In the usual case where the I<mode> argument to B<open>(2)  is "
"specified as:"
msgstr ""

#. type: Plain text
#: man-pages/man2/umask.2:99
#, no-wrap
msgid "S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/umask.2:104
msgid ""
"(octal 0666) when creating a new file, the permissions on the resulting file "
"will be:"
msgstr ""

#. type: Plain text
#: man-pages/man2/umask.2:108
#, no-wrap
msgid "S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/umask.2:112
msgid "(because 0666 & ~022 = 0644; i.e., rw-r--r--)."
msgstr ""

#. type: Plain text
#: man-pages/man2/umask.2:115
msgid ""
"This system call always succeeds and the previous value of the mask is "
"returned."
msgstr ""

#. type: Plain text
#: man-pages/man2/umask.2:123
msgid ""
"A child process created via B<fork>(2)  inherits its parent's umask.  The "
"umask is left unchanged by B<execve>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/umask.2:132
msgid ""
"It is impossible to use B<umask>()  to fetch a process's umask without at "
"the same time changing it.  A second call to B<umask>()  would then be "
"needed to restore the umask.  The nonatomicity of these two steps provides "
"the potential for races in multithreaded programs."
msgstr ""

#. type: Plain text
#: man-pages/man2/umask.2:140
msgid ""
"Since Linux 4.7, the umask of any process can be viewed via the I<Umask> "
"field of I</proc/[pid]/status>.  Inspecting this field in "
"I</proc/self/status> allows a process to retrieve its umask without at the "
"same time changing it."
msgstr ""

#. type: Plain text
#: man-pages/man2/umask.2:155
msgid ""
"The umask setting also affects the permissions assigned to POSIX IPC objects "
"(B<mq_open>(3), B<sem_open>(3), B<shm_open>(3)), FIFOs (B<mkfifo>(3)), and "
"UNIX domain sockets (B<unix>(7))  created by the process.  The umask does "
"not affect the permissions assigned to System\\ V IPC objects created by the "
"process (using B<msgget>(2), B<semget>(2), B<shmget>(2))."
msgstr ""

#. type: Plain text
#: man-pages/man2/umask.2:160
msgid "B<chmod>(2), B<mkdir>(2), B<open>(2), B<stat>(2), B<acl>(5)"
msgstr ""

#. type: TH
#: man-pages/man2/personality.2:33
#, no-wrap
msgid "PERSONALITY"
msgstr ""

#. type: Plain text
#: man-pages/man2/personality.2:36
msgid "personality - set the process execution domain"
msgstr ""

#. type: Plain text
#: man-pages/man2/personality.2:38
msgid "B<#include E<lt>sys/personality.hE<gt>>"
msgstr ""

#. type: Plain text
#: man-pages/man2/personality.2:40
msgid "B<int personality(unsigned long >I<persona>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/personality.2:48
msgid ""
"Linux supports different execution domains, or personalities, for each "
"process.  Among other things, execution domains tell Linux how to map signal "
"numbers into signal actions.  The execution domain system allows Linux to "
"provide limited support for binaries compiled under other UNIX-like "
"operating systems."
msgstr ""

#. type: Plain text
#: man-pages/man2/personality.2:60
msgid ""
"If I<persona> is not 0xffffffff, then B<personality>()  sets the caller's "
"execution domain to the value specified by I<persona>.  Specifying "
"I<persona> as 0xffffffff provides a way of retrieving the current persona "
"without changing it."
msgstr ""

#. type: Plain text
#: man-pages/man2/personality.2:70
msgid ""
"A list of the available execution domains can be found in "
"I<E<lt>sys/personality.hE<gt>>.  The execution domain is a 32-bit value in "
"which the top three bytes are set aside for flags that cause the kernel to "
"modify the behavior of certain system calls so as to emulate historical or "
"architectural quirks.  The least significant byte is value defining the "
"personality the kernel should assume.  The flag values are as follows:"
msgstr ""

#. type: TP
#: man-pages/man2/personality.2:70
#, no-wrap
msgid "B<ADDR_COMPAT_LAYOUT> (since Linux 2.6.9)"
msgstr ""

#. type: Plain text
#: man-pages/man2/personality.2:73
msgid "With this flag set, provide legacy virtual address space layout."
msgstr ""

#. type: TP
#: man-pages/man2/personality.2:73
#, no-wrap
msgid "B<ADDR_NO_RANDOMIZE> (since Linux 2.6.12)"
msgstr ""

#. type: Plain text
#: man-pages/man2/personality.2:76
msgid "With this flag set, disable address-space-layout randomization."
msgstr ""

#. type: TP
#: man-pages/man2/personality.2:76
#, no-wrap
msgid "B<ADDR_LIMIT_32BIT> (since Linux 2.2)"
msgstr ""

#. type: Plain text
#: man-pages/man2/personality.2:79
msgid "Limit the address space to 32 bits."
msgstr ""

#. type: TP
#: man-pages/man2/personality.2:79
#, no-wrap
msgid "B<ADDR_LIMIT_3GB> (since Linux 2.4.0)"
msgstr ""

#. type: Plain text
#: man-pages/man2/personality.2:85
msgid ""
"With this flag set, use 0xc0000000 as the offset at which to search a "
"virtual memory chunk on B<mmap>(2); otherwise use 0xffffe000."
msgstr ""

#. type: TP
#: man-pages/man2/personality.2:85
#, no-wrap
msgid "B<FDPIC_FUNCPTRS> (since Linux 2.6.11)"
msgstr ""

#. type: Plain text
#: man-pages/man2/personality.2:89
msgid ""
"User-space function pointers to signal handlers point (on certain "
"architectures) to descriptors."
msgstr ""

#. type: TP
#: man-pages/man2/personality.2:89
#, no-wrap
msgid "B<MMAP_PAGE_ZERO> (since Linux 2.4.0)"
msgstr ""

#. type: Plain text
#: man-pages/man2/personality.2:93
msgid ""
"Map page 0 as read-only (to support binaries that depend on this SVr4 "
"behavior)."
msgstr ""

#. type: TP
#: man-pages/man2/personality.2:93
#, no-wrap
msgid "B<READ_IMPLIES_EXEC> (since Linux 2.6.8)"
msgstr ""

#. type: Plain text
#: man-pages/man2/personality.2:101
msgid "With this flag set, B<PROT_READ> implies B<PROT_EXEC> for B<mmap>(2)."
msgstr ""

#. type: TP
#: man-pages/man2/personality.2:101
#, no-wrap
msgid "B<SHORT_INODE> (since Linux 2.4.0)"
msgstr ""

#. type: Plain text
#: man-pages/man2/personality.2:104 man-pages/man2/personality.2:123
msgid "No effects(?)."
msgstr ""

#. type: TP
#: man-pages/man2/personality.2:104
#, no-wrap
msgid "B<STICKY_TIMEOUTS> (since Linux 1.2.0)"
msgstr ""

#. type: Plain text
#: man-pages/man2/personality.2:113
msgid ""
"With this flag set, B<select>(2), B<pselect>(2), and B<ppoll>(2)  do not "
"modify the returned timeout argument when interrupted by a signal handler."
msgstr ""

#. type: TP
#: man-pages/man2/personality.2:113
#, no-wrap
msgid "B<UNAME26> (since Linux 3.1)"
msgstr ""

#. type: Plain text
#: man-pages/man2/personality.2:120
msgid ""
"Have B<uname>(2)  report a 2.6.40+ version number rather than a 3.x version "
"number.  Added as a stopgap measure to support broken applications that "
"could not handle the kernel version-numbering switch from 2.6.x to 3.x."
msgstr ""

#. type: TP
#: man-pages/man2/personality.2:120
#, no-wrap
msgid "B<WHOLE_SECONDS> (since Linux 1.2.0)"
msgstr ""

#. type: Plain text
#: man-pages/man2/personality.2:125
msgid "The available execution domains are:"
msgstr ""

#. type: TP
#: man-pages/man2/personality.2:125
#, no-wrap
msgid "B<PER_BSD> (since Linux 1.2.0)"
msgstr ""

#. type: Plain text
#: man-pages/man2/personality.2:128
msgid "BSD. (No effects.)"
msgstr ""

#. type: TP
#: man-pages/man2/personality.2:128
#, no-wrap
msgid "B<PER_HPUX> (since Linux 2.4)"
msgstr ""

#. type: Plain text
#: man-pages/man2/personality.2:133
msgid ""
"Support for 32-bit HP/UX.  This support was never complete, and was dropped "
"so that since Linux 4.0, this value has no effect."
msgstr ""

#. type: TP
#: man-pages/man2/personality.2:133
#, no-wrap
msgid "B<PER_IRIX32> (since Linux 2.2)"
msgstr ""

#. type: Plain text
#: man-pages/man2/personality.2:139
msgid ""
"IRIX 5 32-bit.  Never fully functional; support dropped in Linux 2.6.27.  "
"Implies B<STICKY_TIMEOUTS>."
msgstr ""

#. type: TP
#: man-pages/man2/personality.2:139
#, no-wrap
msgid "B<PER_IRIX64> (since Linux 2.2)"
msgstr ""

#. type: Plain text
#: man-pages/man2/personality.2:145
msgid "IRIX 6 64-bit.  Implies B<STICKY_TIMEOUTS>; otherwise no effects."
msgstr ""

#. type: TP
#: man-pages/man2/personality.2:145
#, no-wrap
msgid "B<PER_IRIXN32> (since Linux 2.2)"
msgstr ""

#. type: Plain text
#: man-pages/man2/personality.2:151
msgid "IRIX 6 new 32-bit.  Implies B<STICKY_TIMEOUTS>; otherwise no effects."
msgstr ""

#. type: TP
#: man-pages/man2/personality.2:151
#, no-wrap
msgid "B<PER_ISCR4> (since Linux 1.2.0)"
msgstr ""

#. type: Plain text
#: man-pages/man2/personality.2:156 man-pages/man2/personality.2:206
msgid "Implies B<STICKY_TIMEOUTS>; otherwise no effects."
msgstr ""

#. type: TP
#: man-pages/man2/personality.2:156
#, no-wrap
msgid "B<PER_LINUX> (since Linux 1.2.0)"
msgstr ""

#. type: Plain text
#: man-pages/man2/personality.2:159
msgid "Linux."
msgstr ""

#. type: TP
#: man-pages/man2/personality.2:159
#, no-wrap
msgid "B<PER_LINUX32> (since Linux 2.2)"
msgstr ""

#. type: Plain text
#: man-pages/man2/personality.2:162 man-pages/man2/personality.2:193
msgid "[To be documented.]"
msgstr ""

#. type: TP
#: man-pages/man2/personality.2:162
#, no-wrap
msgid "B<PER_LINUX32_3GB> (since Linux 2.4)"
msgstr ""

#. type: Plain text
#: man-pages/man2/personality.2:166
msgid "Implies B<ADDR_LIMIT_3GB>."
msgstr ""

#. type: TP
#: man-pages/man2/personality.2:166
#, no-wrap
msgid "B<PER_LINUX_32BIT> (since Linux 2.0)"
msgstr ""

#. type: Plain text
#: man-pages/man2/personality.2:170
msgid "Implies B<ADDR_LIMIT_32BIT>."
msgstr ""

#. type: TP
#: man-pages/man2/personality.2:170
#, no-wrap
msgid "B<PER_LINUX_FDPIC> (since Linux 2.6.11)"
msgstr ""

#. type: Plain text
#: man-pages/man2/personality.2:174
msgid "Implies B<FDPIC_FUNCPTRS>."
msgstr ""

#. type: TP
#: man-pages/man2/personality.2:174
#, no-wrap
msgid "B<PER_OSF4> (since Linux 2.4)"
msgstr ""

#.  Following is from a comment in arch/alpha/kernel/osf_sys.c
#. type: Plain text
#: man-pages/man2/personality.2:183
msgid ""
"OSF/1 v4.  On alpha, clear top 32 bits of iov_len in the user's buffer for "
"compatibility with old versions of OSF/1 where iov_len was defined as.  "
"I<int>."
msgstr ""

#. type: TP
#: man-pages/man2/personality.2:183
#, no-wrap
msgid "B<PER_OSR5> (since Linux 2.4)"
msgstr ""

#. type: Plain text
#: man-pages/man2/personality.2:190
msgid "Implies B<STICKY_TIMEOUTS> and B<WHOLE_SECONDS>; otherwise no effects."
msgstr ""

#. type: TP
#: man-pages/man2/personality.2:190
#, no-wrap
msgid "B<PER_RISCOS> (since Linux 2.2)"
msgstr ""

#. type: TP
#: man-pages/man2/personality.2:193
#, no-wrap
msgid "B<PER_SCOSVR3> (since Linux 1.2.0)"
msgstr ""

#. type: Plain text
#: man-pages/man2/personality.2:201
msgid ""
"Implies B<STICKY_TIMEOUTS>, B<WHOLE_SECONDS>, and B<SHORT_INODE>; otherwise "
"no effects."
msgstr ""

#. type: TP
#: man-pages/man2/personality.2:201
#, no-wrap
msgid "B<PER_SOLARIS> (since Linux 2.4)"
msgstr ""

#. type: TP
#: man-pages/man2/personality.2:206
#, no-wrap
msgid "B<PER_SUNOS> (since Linux 2.4.0)"
msgstr ""

#. type: Plain text
#: man-pages/man2/personality.2:214
msgid ""
"Implies B<STICKY_TIMEOUTS>.  Divert library and dynamic linker searches to "
"I</usr/gnemul>.  Buggy, largely unmaintained, and almost entirely unused; "
"support was removed in Linux 2.6.26."
msgstr ""

#. type: TP
#: man-pages/man2/personality.2:214
#, no-wrap
msgid "B<PER_SVR3> (since Linux 1.2.0)"
msgstr ""

#. type: Plain text
#: man-pages/man2/personality.2:221 man-pages/man2/personality.2:242
#: man-pages/man2/personality.2:249
msgid "Implies B<STICKY_TIMEOUTS> and B<SHORT_INODE>; otherwise no effects."
msgstr ""

#. type: TP
#: man-pages/man2/personality.2:221
#, no-wrap
msgid "B<PER_SVR4> (since Linux 1.2.0)"
msgstr ""

#. type: Plain text
#: man-pages/man2/personality.2:228 man-pages/man2/personality.2:235
msgid "Implies B<STICKY_TIMEOUTS> and B<MMAP_PAGE_ZERO>; otherwise no effects."
msgstr ""

#. type: TP
#: man-pages/man2/personality.2:228
#, no-wrap
msgid "B<PER_UW7> (since Linux 2.4)"
msgstr ""

#. type: TP
#: man-pages/man2/personality.2:235
#, no-wrap
msgid "B<PER_WYSEV386> (since Linux 1.2.0)"
msgstr ""

#. type: TP
#: man-pages/man2/personality.2:242
#, no-wrap
msgid "B<PER_XENIX> (since Linux 1.2.0)"
msgstr ""

#. type: Plain text
#: man-pages/man2/personality.2:256
msgid ""
"On success, the previous I<persona> is returned.  On error, -1 is returned, "
"and I<errno> is set appropriately."
msgstr ""

#. type: Plain text
#: man-pages/man2/personality.2:260
msgid "The kernel was unable to change the personality."
msgstr ""

#.  personality wrapper first appeared in glibc 1.90,
#.  <sys/personality.h> was added later in 2.2.91.
#. type: Plain text
#: man-pages/man2/personality.2:266
msgid ""
"This system call first appeared in Linux 1.1.20 (and thus first in a stable "
"kernel release with Linux 1.2.0); library support was added in glibc 2.3."
msgstr ""

#. type: Plain text
#: man-pages/man2/personality.2:270
msgid ""
"B<personality>()  is Linux-specific and should not be used in programs "
"intended to be portable."
msgstr ""

#. type: Plain text
#: man-pages/man2/personality.2:271
msgid "B<setarch>(8)"
msgstr ""

#. type: TH
#: man-pages/man2/timer_settime.2:26
#, no-wrap
msgid "TIMER_SETTIME"
msgstr ""

#. type: Plain text
#: man-pages/man2/timer_settime.2:30
msgid ""
"timer_settime, timer_gettime - arm/disarm and fetch state of POSIX "
"per-process timer"
msgstr ""

#. type: Plain text
#: man-pages/man2/timer_settime.2:33 man-pages/man2/timer_delete.2:32
#: man-pages/man2/timer_getoverrun.2:32
#, no-wrap
msgid "B<#include E<lt>time.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/timer_settime.2:38
#, no-wrap
msgid ""
"B<int timer_settime(timer_t >I<timerid>B<, int >I<flags>B<,>\n"
"B<                  const struct itimerspec *>I<new_value>B<,>\n"
"B<                  struct itimerspec *>I<old_value>B<);>\n"
"B<int timer_gettime(timer_t >I<timerid>B<, struct itimerspec "
"*>I<curr_value>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/timer_settime.2:41 man-pages/man2/timer_delete.2:37
#: man-pages/man2/timer_getoverrun.2:37 man-pages/man2/timer_create.2:39
msgid "Link with I<-lrt>."
msgstr ""

#. type: Plain text
#: man-pages/man2/timer_settime.2:50
msgid "B<timer_settime>(), B<timer_gettime>(): _POSIX_C_SOURCE\\ E<gt>=\\ 199309L"
msgstr ""

#. type: Plain text
#: man-pages/man2/timer_settime.2:63
msgid ""
"B<timer_settime>()  arms or disarms the timer identified by I<timerid>.  The "
"I<new_value> argument is pointer to an I<itimerspec> structure that "
"specifies the new initial value and the new interval for the timer.  The "
"I<itimerspec> structure is defined as follows:"
msgstr ""

#. type: Plain text
#: man-pages/man2/timer_settime.2:70 man-pages/man2/timerfd_create.2:164
#, no-wrap
msgid ""
"struct timespec {\n"
"    time_t tv_sec;                /* Seconds */\n"
"    long   tv_nsec;               /* Nanoseconds */\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/timer_settime.2:75
#, no-wrap
msgid ""
"struct itimerspec {\n"
"    struct timespec it_interval;  /* Timer interval */\n"
"    struct timespec it_value;     /* Initial expiration */\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/timer_settime.2:87
msgid ""
"Each of the substructures of the I<itimerspec> structure is a I<timespec> "
"structure that allows a time value to be specified in seconds and "
"nanoseconds.  These time values are measured according to the clock that was "
"specified when the timer was created by B<timer_create>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/timer_settime.2:101
msgid ""
"If I<new_value-E<gt>it_value> specifies a nonzero value (i.e., either "
"subfield is nonzero), then B<timer_settime>()  arms (starts) the timer, "
"setting it to initially expire at the given time.  (If the timer was already "
"armed, then the previous settings are overwritten.)  If "
"I<new_value-E<gt>it_value> specifies a zero value (i.e., both subfields are "
"zero), then the timer is disarmed."
msgstr ""

#. type: Plain text
#: man-pages/man2/timer_settime.2:113
msgid ""
"The I<new_value-E<gt>it_interval> field specifies the period of the timer, "
"in seconds and nanoseconds.  If this field is nonzero, then each time that "
"an armed timer expires, the timer is reloaded from the value specified in "
"I<new_value-E<gt>it_interval>.  If I<new_value-E<gt>it_interval> specifies a "
"zero value, then the timer expires just once, at the time specified by "
"I<it_value>."
msgstr ""

#.  By experiment: the overrun count is set correctly, for CLOCK_REALTIME.
#. type: Plain text
#: man-pages/man2/timer_settime.2:134
msgid ""
"By default, the initial expiration time specified in "
"I<new_value-E<gt>it_value> is interpreted relative to the current time on "
"the timer's clock at the time of the call.  This can be modified by "
"specifying B<TIMER_ABSTIME> in I<flags>, in which case "
"I<new_value-E<gt>it_value> is interpreted as an absolute value as measured "
"on the timer's clock; that is, the timer will expire when the clock value "
"reaches the value specified by I<new_value-E<gt>it_value>.  If the specified "
"absolute time has already passed, then the timer expires immediately, and "
"the overrun count (see B<timer_getoverrun>(2))  will be set correctly."
msgstr ""

#.  Similar remarks might apply with respect to process and thread CPU time
#.  clocks, but these clocks are not currently (2.6.28) settable on Linux.
#. type: Plain text
#: man-pages/man2/timer_settime.2:144
msgid ""
"If the value of the B<CLOCK_REALTIME> clock is adjusted while an absolute "
"timer based on that clock is armed, then the expiration of the timer will be "
"appropriately adjusted.  Adjustments to the B<CLOCK_REALTIME> clock have no "
"effect on relative timers based on that clock."
msgstr ""

#. type: Plain text
#: man-pages/man2/timer_settime.2:153
msgid ""
"If I<old_value> is not NULL, then it points to a buffer that is used to "
"return the previous interval of the timer (in I<old_value-E<gt>it_interval>)  "
"and the amount of time until the timer would previously have next expired "
"(in I<old_value-E<gt>it_value>)."
msgstr ""

#. type: Plain text
#: man-pages/man2/timer_settime.2:173
msgid ""
"B<timer_gettime>()  returns the time until next expiration, and the "
"interval, for the timer specified by I<timerid>, in the buffer pointed to by "
"I<curr_value>.  The time remaining until the next timer expiration is "
"returned in I<curr_value-E<gt>it_value>; this is always a relative value, "
"regardless of whether the B<TIMER_ABSTIME> flag was used when arming the "
"timer.  If the value returned in I<curr_value-E<gt>it_value> is zero, then "
"the timer is currently disarmed.  The timer interval is returned in "
"I<curr_value-E<gt>it_interval>.  If the value returned in "
"I<curr_value-E<gt>it_interval> is zero, then this is a \"one-shot\" timer."
msgstr ""

#. type: Plain text
#: man-pages/man2/timer_settime.2:182
msgid ""
"On success, B<timer_settime>()  and B<timer_gettime>()  return 0.  On error, "
"-1 is returned, and I<errno> is set to indicate the error."
msgstr ""

#. type: Plain text
#: man-pages/man2/timer_settime.2:184
msgid "These functions may fail with the following errors:"
msgstr ""

#. type: Plain text
#: man-pages/man2/timer_settime.2:191
msgid "I<new_value>, I<old_value>, or I<curr_value> is not a valid pointer."
msgstr ""

#.  FIXME . eventually: invalid value in flags
#. type: Plain text
#: man-pages/man2/timer_settime.2:196
msgid "I<timerid> is invalid."
msgstr ""

#. type: Plain text
#: man-pages/man2/timer_settime.2:199
msgid "B<timer_settime>()  may fail with the following errors:"
msgstr ""

#. type: Plain text
#: man-pages/man2/timer_settime.2:205
msgid ""
"I<new_value.it_value> is negative; or I<new_value.it_value.tv_nsec> is "
"negative or greater than 999,999,999."
msgstr ""

#. type: Plain text
#: man-pages/man2/timer_settime.2:207
msgid "These system calls are available since Linux 2.6."
msgstr ""

#. type: Plain text
#: man-pages/man2/timer_settime.2:209
#: man-pages/man2/sched_get_priority_max.2:116
#: man-pages/man2/clock_nanosleep.2:190 man-pages/man2/sched_setparam.2:121
#: man-pages/man2/sched_yield.2:54 man-pages/man2/msync.2:101
#: man-pages/man2/nanosleep.2:134 man-pages/man2/sigwaitinfo.2:136
#: man-pages/man2/timer_delete.2:69 man-pages/man2/sigprocmask.2:130
#: man-pages/man2/timer_getoverrun.2:99 man-pages/man2/sigsuspend.2:87
#: man-pages/man2/timer_create.2:223 man-pages/man2/pread.2:125
#: man-pages/man2/sigpending.2:66 man-pages/man2/sched_rr_get_interval.2:96
msgid "POSIX.1-2001, POSIX.1-2008."
msgstr ""

#. type: Plain text
#: man-pages/man2/timer_settime.2:212 man-pages/man2/timer_getoverrun.2:131
msgid "See B<timer_create>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/timer_settime.2:215
msgid "B<timer_create>(2), B<timer_getoverrun>(2), B<time>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/sigaction.2:49
#, no-wrap
msgid "SIGACTION"
msgstr ""

#. type: Plain text
#: man-pages/man2/sigaction.2:52
msgid "sigaction, rt_sigaction - examine and change a signal action"
msgstr ""

#. type: Plain text
#: man-pages/man2/sigaction.2:55 man-pages/man2/sigwaitinfo.2:32
#, no-wrap
msgid "B<#include E<lt>signal.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/sigaction.2:58
#, no-wrap
msgid ""
"B<int sigaction(int >I<signum>B<, const struct sigaction *>I<act>B<,>\n"
"B<              struct sigaction *>I<oldact>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/sigaction.2:68
msgid "B<sigaction>(): _POSIX_C_SOURCE"
msgstr ""

#. type: Plain text
#: man-pages/man2/sigaction.2:71
msgid "I<siginfo_t>: _POSIX_C_SOURCE E<gt>= 199309L"
msgstr ""

#. type: Plain text
#: man-pages/man2/sigaction.2:80
msgid ""
"The B<sigaction>()  system call is used to change the action taken by a "
"process on receipt of a specific signal.  (See B<signal>(7)  for an overview "
"of signals.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/sigaction.2:86
msgid ""
"I<signum> specifies the signal and can be any valid signal except B<SIGKILL> "
"and B<SIGSTOP>."
msgstr ""

#. type: Plain text
#: man-pages/man2/sigaction.2:97
msgid ""
"If I<act> is non-NULL, the new action for signal I<signum> is installed from "
"I<act>.  If I<oldact> is non-NULL, the previous action is saved in "
"I<oldact>."
msgstr ""

#. type: Plain text
#: man-pages/man2/sigaction.2:101
msgid "The I<sigaction> structure is defined as something like:"
msgstr ""

#. type: Plain text
#: man-pages/man2/sigaction.2:111
#, no-wrap
msgid ""
"struct sigaction {\n"
"    void     (*sa_handler)(int);\n"
"    void     (*sa_sigaction)(int, siginfo_t *, void *);\n"
"    sigset_t   sa_mask;\n"
"    int        sa_flags;\n"
"    void     (*sa_restorer)(void);\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/sigaction.2:118
msgid ""
"On some architectures a union is involved: do not assign to both "
"I<sa_handler> and I<sa_sigaction>."
msgstr ""

#. type: Plain text
#: man-pages/man2/sigaction.2:127
msgid ""
"The I<sa_restorer> field is not intended for application use.  (POSIX does "
"not specify a I<sa_restorer> field.)  Some further details of the purpose of "
"this field can be found in B<sigreturn>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/sigaction.2:137
msgid ""
"I<sa_handler> specifies the action to be associated with I<signum> and may "
"be B<SIG_DFL> for the default action, B<SIG_IGN> to ignore this signal, or a "
"pointer to a signal handling function.  This function receives the signal "
"number as its only argument."
msgstr ""

#. type: Plain text
#: man-pages/man2/sigaction.2:149
msgid ""
"If B<SA_SIGINFO> is specified in I<sa_flags>, then I<sa_sigaction> (instead "
"of I<sa_handler>)  specifies the signal-handling function for I<signum>.  "
"This function receives three arguments, as described below."
msgstr ""

#. type: Plain text
#: man-pages/man2/sigaction.2:159
msgid ""
"I<sa_mask> specifies a mask of signals which should be blocked (i.e., added "
"to the signal mask of the thread in which the signal handler is invoked)  "
"during execution of the signal handler.  In addition, the signal which "
"triggered the handler will be blocked, unless the B<SA_NODEFER> flag is "
"used."
msgstr ""

#. type: Plain text
#: man-pages/man2/sigaction.2:163
msgid ""
"I<sa_flags> specifies a set of flags which modify the behavior of the "
"signal.  It is formed by the bitwise OR of zero or more of the following:"
msgstr ""

#. type: TP
#: man-pages/man2/sigaction.2:164
#, no-wrap
msgid "B<SA_NOCLDSTOP>"
msgstr ""

#. type: Plain text
#: man-pages/man2/sigaction.2:181
msgid ""
"If I<signum> is B<SIGCHLD>, do not receive notification when child processes "
"stop (i.e., when they receive one of B<SIGSTOP>, B<SIGTSTP>, B<SIGTTIN>, or "
"B<SIGTTOU>)  or resume (i.e., they receive B<SIGCONT>)  (see B<wait>(2)).  "
"This flag is meaningful only when establishing a handler for B<SIGCHLD>."
msgstr ""

#. type: TP
#: man-pages/man2/sigaction.2:181
#, no-wrap
msgid "B<SA_NOCLDWAIT> (since Linux 2.6)"
msgstr ""

#.  To be precise: Linux 2.5.60 -- MTK
#. type: Plain text
#: man-pages/man2/sigaction.2:195
msgid ""
"If I<signum> is B<SIGCHLD>, do not transform children into zombies when they "
"terminate.  See also B<waitpid>(2).  This flag is meaningful only when "
"establishing a handler for B<SIGCHLD>, or when setting that signal's "
"disposition to B<SIG_DFL>."
msgstr ""

#. type: Plain text
#: man-pages/man2/sigaction.2:207
msgid ""
"If the B<SA_NOCLDWAIT> flag is set when establishing a handler for "
"B<SIGCHLD>, POSIX.1 leaves it unspecified whether a B<SIGCHLD> signal is "
"generated when a child process terminates.  On Linux, a B<SIGCHLD> signal is "
"generated in this case; on some other implementations, it is not."
msgstr ""

#. type: TP
#: man-pages/man2/sigaction.2:207
#, no-wrap
msgid "B<SA_NODEFER>"
msgstr ""

#. type: Plain text
#: man-pages/man2/sigaction.2:214
msgid ""
"Do not prevent the signal from being received from within its own signal "
"handler.  This flag is meaningful only when establishing a signal handler.  "
"B<SA_NOMASK> is an obsolete, nonstandard synonym for this flag."
msgstr ""

#. type: TP
#: man-pages/man2/sigaction.2:214
#, no-wrap
msgid "B<SA_ONSTACK>"
msgstr ""

#. type: Plain text
#: man-pages/man2/sigaction.2:220
msgid ""
"Call the signal handler on an alternate signal stack provided by "
"B<sigaltstack>(2).  If an alternate stack is not available, the default "
"stack will be used.  This flag is meaningful only when establishing a signal "
"handler."
msgstr ""

#. type: TP
#: man-pages/man2/sigaction.2:220
#, no-wrap
msgid "B<SA_RESETHAND>"
msgstr ""

#. type: Plain text
#: man-pages/man2/sigaction.2:226
msgid ""
"Restore the signal action to the default upon entry to the signal handler.  "
"This flag is meaningful only when establishing a signal handler.  "
"B<SA_ONESHOT> is an obsolete, nonstandard synonym for this flag."
msgstr ""

#. type: TP
#: man-pages/man2/sigaction.2:226
#, no-wrap
msgid "B<SA_RESTART>"
msgstr ""

#. type: Plain text
#: man-pages/man2/sigaction.2:234
msgid ""
"Provide behavior compatible with BSD signal semantics by making certain "
"system calls restartable across signals.  This flag is meaningful only when "
"establishing a signal handler.  See B<signal>(7)  for a discussion of system "
"call restarting."
msgstr ""

#. type: TP
#: man-pages/man2/sigaction.2:234
#, no-wrap
msgid "B<SA_RESTORER>"
msgstr ""

#. type: Plain text
#: man-pages/man2/sigaction.2:243
msgid ""
"I<Not intended for application use>.  This flag is used by C libraries to "
"indicate that the I<sa_restorer> field contains the address of a \"signal "
"trampoline\".  See B<sigreturn>(2)  for more details."
msgstr ""

#. type: TP
#: man-pages/man2/sigaction.2:243
#, no-wrap
msgid "B<SA_SIGINFO> (since Linux 2.2)"
msgstr ""

#.  (The
#.  .I sa_sigaction
#.  field was added in Linux 2.1.86.)
#. type: Plain text
#: man-pages/man2/sigaction.2:254
msgid ""
"The signal handler takes three arguments, not one.  In this case, "
"I<sa_sigaction> should be set instead of I<sa_handler>.  This flag is "
"meaningful only when establishing a signal handler."
msgstr ""

#. type: SS
#: man-pages/man2/sigaction.2:255
#, no-wrap
msgid "The siginfo_t argument to a SA_SIGINFO handler"
msgstr ""

#. type: Plain text
#: man-pages/man2/sigaction.2:264
msgid ""
"When the B<SA_SIGINFO> flag is specified in I<act.sa_flags>, the signal "
"handler address is passed via the I<act.sa_sigaction> field.  This handler "
"takes three arguments, as follows:"
msgstr ""

#. type: Plain text
#: man-pages/man2/sigaction.2:272
#, no-wrap
msgid ""
"void\n"
"handler(int sig, siginfo_t *info, void *ucontext)\n"
"{\n"
"    ...\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/sigaction.2:276
msgid "These three arguments are as follows"
msgstr ""

#. type: TP
#: man-pages/man2/sigaction.2:276
#, no-wrap
msgid "I<sig>"
msgstr ""

#. type: Plain text
#: man-pages/man2/sigaction.2:279
msgid "The number of the signal that caused invocation of the handler."
msgstr ""

#. type: TP
#: man-pages/man2/sigaction.2:279
#, no-wrap
msgid "I<info>"
msgstr ""

#. type: Plain text
#: man-pages/man2/sigaction.2:285
msgid ""
"A pointer to a I<siginfo_t>, which is a structure containing further "
"information about the signal, as described below."
msgstr ""

#. type: TP
#: man-pages/man2/sigaction.2:285
#, no-wrap
msgid "I<ucontext>"
msgstr ""

#. type: Plain text
#: man-pages/man2/sigaction.2:299
msgid ""
"This is a pointer to a I<ucontext_t> structure, cast to I<void\\ *>.  The "
"structure pointed to by this field contains signal context information that "
"was saved on the user-space stack by the kernel; for details, see "
"B<sigreturn>(2).  Further information about the I<ucontext_t> structure can "
"be found in B<getcontext>(3).  Commonly, the handler function doesn't make "
"any use of the third argument."
msgstr ""

#. type: Plain text
#: man-pages/man2/sigaction.2:303
msgid "The I<siginfo_t> data type is a structure with the following fields:"
msgstr ""

#.  FIXME
#.  The siginfo_t 'si_trapno' field seems to be used
#.  only on SPARC and Alpha; this page could use
#.  a little more detail on its purpose there.
#.  In the kernel: si_tid
#. type: Plain text
#: man-pages/man2/sigaction.2:348
#, no-wrap
msgid ""
"siginfo_t {\n"
"    int      si_signo;     /* Signal number */\n"
"    int      si_errno;     /* An errno value */\n"
"    int      si_code;      /* Signal code */\n"
"    int      si_trapno;    /* Trap number that caused\n"
"                              hardware-generated signal\n"
"                              (unused on most architectures) */\n"
"    pid_t    si_pid;       /* Sending process ID */\n"
"    uid_t    si_uid;       /* Real user ID of sending process */\n"
"    int      si_status;    /* Exit value or signal */\n"
"    clock_t  si_utime;     /* User time consumed */\n"
"    clock_t  si_stime;     /* System time consumed */\n"
"    sigval_t si_value;     /* Signal value */\n"
"    int      si_int;       /* POSIX.1b signal */\n"
"    void    *si_ptr;       /* POSIX.1b signal */\n"
"    int      si_overrun;   /* Timer overrun count;\n"
"                              POSIX.1b timers */\n"
"    int      si_timerid;   /* Timer ID; POSIX.1b timers */\n"
"    void    *si_addr;      /* Memory location which caused fault */\n"
"    long     si_band;      /* Band event (was I<int> in\n"
"                              glibc 2.3.2 and earlier) */\n"
"    int      si_fd;        /* File descriptor */\n"
"    short    si_addr_lsb;  /* Least significant bit of address\n"
"                              (since Linux 2.6.32) */\n"
"    void    *si_lower;     /* Lower bound when address violation\n"
"                              occurred (since Linux 3.19) */\n"
"    void    *si_upper;     /* Upper bound when address violation\n"
"                              occurred (since Linux 3.19) */\n"
"    int      si_pkey;      /* Protection key on PTE that caused\n"
"                              fault (since Linux 4.6) */\n"
"    void    *si_call_addr; /* Address of system call instruction\n"
"                              (since Linux 3.5) */\n"
"    int      si_syscall;   /* Number of attempted system call\n"
"                              (since Linux 3.5) */\n"
"    unsigned int si_arch;  /* Architecture of attempted system call\n"
"                              (since Linux 3.5) */\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/sigaction.2:357
msgid ""
"I<si_signo>, I<si_errno> and I<si_code> are defined for all signals.  "
"(I<si_errno> is generally unused on Linux.)  The rest of the struct may be a "
"union, so that one should read only the fields that are meaningful for the "
"given signal:"
msgstr ""

#. type: Plain text
#: man-pages/man2/sigaction.2:372
msgid ""
"Signals sent with B<kill>(2)  and B<sigqueue>(3)  fill in I<si_pid> and "
"I<si_uid>.  In addition, signals sent with B<sigqueue>(3)  fill in I<si_int> "
"and I<si_ptr> with the values specified by the sender of the signal; see "
"B<sigqueue>(3)  for more details."
msgstr ""

#. type: Plain text
#: man-pages/man2/sigaction.2:388
msgid ""
"Signals sent by POSIX.1b timers (since Linux 2.6) fill in I<si_overrun> and "
"I<si_timerid>.  The I<si_timerid> field is an internal ID used by the kernel "
"to identify the timer; it is not the same as the timer ID returned by "
"B<timer_create>(2).  The I<si_overrun> field is the timer overrun count; "
"this is the same information as is obtained by a call to "
"B<timer_getoverrun>(2).  These fields are nonstandard Linux extensions."
msgstr ""

#. type: Plain text
#: man-pages/man2/sigaction.2:403
msgid ""
"Signals sent for message queue notification (see the description of "
"B<SIGEV_SIGNAL> in B<mq_notify>(3))  fill in I<si_int>/I<si_ptr>, with the "
"I<sigev_value> supplied to B<mq_notify>(3); I<si_pid>, with the process ID "
"of the message sender; and I<si_uid>, with the real user ID of the message "
"sender."
msgstr ""

#.  FIXME .
#.  When si_utime and si_stime where originally implemented, the
#.  measurement unit was HZ, which was the same as clock ticks
#.  (sysconf(_SC_CLK_TCK)).  In 2.6, HZ became configurable, and
#.  was *still* used as the unit to return the info these fields,
#.  with the result that the field values depended on the
#.  configured HZ.  Of course, the should have been measured in
#.  USER_HZ instead, so that sysconf(_SC_CLK_TCK) could be used to
#.  convert to seconds.  I have a queued patch to fix this:
#.  http://thread.gmane.org/gmane.linux.kernel/698061/ .
#.  This patch made it into 2.6.27.
#.  But note that these fields still don't return the times of
#.  waited-for children (as is done by getrusage() and times()
#.  and wait4()).  Solaris 8 does include child times.
#. type: Plain text
#: man-pages/man2/sigaction.2:450
msgid ""
"B<SIGCHLD> fills in I<si_pid>, I<si_uid>, I<si_status>, I<si_utime>, and "
"I<si_stime>, providing information about the child.  The I<si_pid> field is "
"the process ID of the child; I<si_uid> is the child's real user ID.  The "
"I<si_status> field contains the exit status of the child (if I<si_code> is "
"B<CLD_EXITED>), or the signal number that caused the process to change "
"state.  The I<si_utime> and I<si_stime> contain the user and system CPU time "
"used by the child process; these fields do not include the times used by "
"waited-for children (unlike B<getrusage>(2)  and B<times>(2)).  In kernels "
"up to 2.6, and since 2.6.27, these fields report CPU time in units of "
"I<sysconf(_SC_CLK_TCK)>.  In 2.6 kernels before 2.6.27, a bug meant that "
"these fields reported time in units of the (configurable) system jiffy (see "
"B<time>(7))."
msgstr ""

#. type: Plain text
#: man-pages/man2/sigaction.2:464
msgid ""
"B<SIGILL>, B<SIGFPE>, B<SIGSEGV>, B<SIGBUS>, and B<SIGTRAP> fill in "
"I<si_addr> with the address of the fault.  On some architectures, these "
"signals also fill in the I<si_trapno> field."
msgstr ""

#. type: Plain text
#: man-pages/man2/sigaction.2:498
msgid ""
"Some suberrors of B<SIGBUS>, in particular B<BUS_MCEERR_AO> and "
"B<BUS_MCEERR_AR>, also fill in I<si_addr_lsb>.  This field indicates the "
"least significant bit of the reported address and therefore the extent of "
"the corruption.  For example, if a full page was corrupted, I<si_addr_lsb> "
"contains I<log2(sysconf(_SC_PAGESIZE))>.  When B<SIGTRAP> is delivered in "
"response to a B<ptrace>(2)  event (PTRACE_EVENT_foo), I<si_addr> is not "
"populated, but I<si_pid> and I<si_uid> are populated with the respective "
"process ID and user ID responsible for delivering the trap.  In the case of "
"B<seccomp>(2), the tracee will be shown as delivering the event.  "
"B<BUS_MCEERR_*> and I<si_addr_lsb> are Linux-specific extensions."
msgstr ""

#. type: Plain text
#: man-pages/man2/sigaction.2:507
msgid ""
"The B<SEGV_BNDERR> suberror of B<SIGSEGV> populates I<si_lower> and "
"I<si_upper>."
msgstr ""

#. type: Plain text
#: man-pages/man2/sigaction.2:514
msgid "The B<SEGV_PKUERR> suberror of B<SIGSEGV> populates I<si_pkey>."
msgstr ""

#. type: Plain text
#: man-pages/man2/sigaction.2:532
msgid ""
"B<SIGIO>/B<SIGPOLL> (the two names are synonyms on Linux)  fills in "
"I<si_band> and I<si_fd>.  The I<si_band> event is a bit mask containing the "
"same values as are filled in the I<revents> field by B<poll>(2).  The "
"I<si_fd> field indicates the file descriptor for which the I/O event "
"occurred; for further details, see the description of B<F_SETSIG> in "
"B<fcntl>(2)."
msgstr ""

#.  commit a0727e8ce513fe6890416da960181ceb10fbfae6
#. type: Plain text
#: man-pages/man2/sigaction.2:546
msgid ""
"B<SIGSYS>, generated (since Linux 3.5)  when a seccomp filter returns "
"B<SECCOMP_RET_TRAP>, fills in I<si_call_addr>, I<si_syscall>, I<si_arch>, "
"I<si_errno>, and other fields as described in B<seccomp>(2)."
msgstr ""

#. type: SS
#: man-pages/man2/sigaction.2:546
#, no-wrap
msgid "The si_code field"
msgstr ""

#. type: Plain text
#: man-pages/man2/sigaction.2:563
msgid ""
"The I<si_code> field inside the I<siginfo_t> argument that is passed to a "
"B<SA_SIGINFO> signal handler is a value (not a bit mask)  indicating why "
"this signal was sent.  For a B<ptrace>(2)  event, I<si_code> will contain "
"B<SIGTRAP> and have the ptrace event in the high byte:"
msgstr ""

#. type: Plain text
#: man-pages/man2/sigaction.2:567
#, no-wrap
msgid "(SIGTRAP | PTRACE_EVENT_foo E<lt>E<lt> 8).\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/sigaction.2:581
msgid ""
"For a non-B<ptrace>(2)  event, the values that can appear in I<si_code> are "
"described in the remainder of this section.  Since glibc 2.20, the "
"definitions of most of these symbols are obtained from I<E<lt>signal.hE<gt>> "
"by defining feature test macros (before including I<any> header file) as "
"follows:"
msgstr ""

#. type: Plain text
#: man-pages/man2/sigaction.2:584
msgid "B<_XOPEN_SOURCE> with the value 500 or greater;"
msgstr ""

#. type: Plain text
#: man-pages/man2/sigaction.2:589
msgid "B<_XOPEN_SOURCE> and B<_XOPEN_SOURCE_EXTENDED>; or"
msgstr ""

#. type: Plain text
#: man-pages/man2/sigaction.2:592
msgid "B<_POSIX_C_SOURCE> with the value 200809L or greater."
msgstr ""

#. type: Plain text
#: man-pages/man2/sigaction.2:597
msgid ""
"For the B<TRAP_*> constants, the symbol definitions are provided only in the "
"first two cases.  Before glibc 2.20, no feature test macros were required to "
"obtain these symbols."
msgstr ""

#. type: Plain text
#: man-pages/man2/sigaction.2:602
msgid ""
"For a regular signal, the following list shows the values which can be "
"placed in I<si_code> for any signal, along with the reason that the signal "
"was generated."
msgstr ""

#. type: TP
#: man-pages/man2/sigaction.2:603
#, no-wrap
msgid "B<SI_USER>"
msgstr ""

#. type: Plain text
#: man-pages/man2/sigaction.2:606
msgid "B<kill>(2)."
msgstr ""

#. type: TP
#: man-pages/man2/sigaction.2:606
#, no-wrap
msgid "B<SI_KERNEL>"
msgstr ""

#. type: Plain text
#: man-pages/man2/sigaction.2:609
msgid "Sent by the kernel."
msgstr ""

#. type: TP
#: man-pages/man2/sigaction.2:609
#, no-wrap
msgid "B<SI_QUEUE>"
msgstr ""

#. type: Plain text
#: man-pages/man2/sigaction.2:612
msgid "B<sigqueue>(3)."
msgstr ""

#. type: TP
#: man-pages/man2/sigaction.2:612
#, no-wrap
msgid "B<SI_TIMER>"
msgstr ""

#. type: Plain text
#: man-pages/man2/sigaction.2:615
msgid "POSIX timer expired."
msgstr ""

#. type: TP
#: man-pages/man2/sigaction.2:615
#, no-wrap
msgid "B<SI_MESGQ> (since Linux 2.6.6)"
msgstr ""

#. type: Plain text
#: man-pages/man2/sigaction.2:619
msgid "POSIX message queue state changed; see B<mq_notify>(3)."
msgstr ""

#. type: TP
#: man-pages/man2/sigaction.2:619
#, no-wrap
msgid "B<SI_ASYNCIO>"
msgstr ""

#. type: Plain text
#: man-pages/man2/sigaction.2:622
msgid "AIO completed."
msgstr ""

#. type: TP
#: man-pages/man2/sigaction.2:622
#, no-wrap
msgid "B<SI_SIGIO>"
msgstr ""

#. type: Plain text
#: man-pages/man2/sigaction.2:631
msgid ""
"Queued B<SIGIO> (only in kernels up to Linux 2.2; from Linux 2.4 onward "
"B<SIGIO>/B<SIGPOLL> fills in I<si_code> as described below)."
msgstr ""

#. type: TP
#: man-pages/man2/sigaction.2:631
#, no-wrap
msgid "B<SI_TKILL> (since Linux 2.4.19)"
msgstr ""

#.  SI_DETHREAD is defined in 2.6.9 sources, but isn't implemented
#.  It appears to have been an idea that was tried during 2.5.6
#.  through to 2.5.24 and then was backed out.
#. type: Plain text
#: man-pages/man2/sigaction.2:639
msgid "B<tkill>(2)  or B<tgkill>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/sigaction.2:646
msgid "The following values can be placed in I<si_code> for a B<SIGILL> signal:"
msgstr ""

#. type: TP
#: man-pages/man2/sigaction.2:647
#, no-wrap
msgid "B<ILL_ILLOPC>"
msgstr ""

#. type: Plain text
#: man-pages/man2/sigaction.2:650
msgid "Illegal opcode."
msgstr ""

#. type: TP
#: man-pages/man2/sigaction.2:650
#, no-wrap
msgid "B<ILL_ILLOPN>"
msgstr ""

#. type: Plain text
#: man-pages/man2/sigaction.2:653
msgid "Illegal operand."
msgstr ""

#. type: TP
#: man-pages/man2/sigaction.2:653
#, no-wrap
msgid "B<ILL_ILLADR>"
msgstr ""

#. type: Plain text
#: man-pages/man2/sigaction.2:656
msgid "Illegal addressing mode."
msgstr ""

#. type: TP
#: man-pages/man2/sigaction.2:656
#, no-wrap
msgid "B<ILL_ILLTRP>"
msgstr ""

#. type: Plain text
#: man-pages/man2/sigaction.2:659
msgid "Illegal trap."
msgstr ""

#. type: TP
#: man-pages/man2/sigaction.2:659
#, no-wrap
msgid "B<ILL_PRVOPC>"
msgstr ""

#. type: Plain text
#: man-pages/man2/sigaction.2:662
msgid "Privileged opcode."
msgstr ""

#. type: TP
#: man-pages/man2/sigaction.2:662
#, no-wrap
msgid "B<ILL_PRVREG>"
msgstr ""

#. type: Plain text
#: man-pages/man2/sigaction.2:665
msgid "Privileged register."
msgstr ""

#. type: TP
#: man-pages/man2/sigaction.2:665
#, no-wrap
msgid "B<ILL_COPROC>"
msgstr ""

#. type: Plain text
#: man-pages/man2/sigaction.2:668
msgid "Coprocessor error."
msgstr ""

#. type: TP
#: man-pages/man2/sigaction.2:668
#, no-wrap
msgid "B<ILL_BADSTK>"
msgstr ""

#. type: Plain text
#: man-pages/man2/sigaction.2:671
msgid "Internal stack error."
msgstr ""

#. type: Plain text
#: man-pages/man2/sigaction.2:678
msgid "The following values can be placed in I<si_code> for a B<SIGFPE> signal:"
msgstr ""

#. type: TP
#: man-pages/man2/sigaction.2:679
#, no-wrap
msgid "B<FPE_INTDIV>"
msgstr ""

#. type: Plain text
#: man-pages/man2/sigaction.2:682
msgid "Integer divide by zero."
msgstr ""

#. type: TP
#: man-pages/man2/sigaction.2:682
#, no-wrap
msgid "B<FPE_INTOVF>"
msgstr ""

#. type: Plain text
#: man-pages/man2/sigaction.2:685
msgid "Integer overflow."
msgstr ""

#. type: TP
#: man-pages/man2/sigaction.2:685
#, no-wrap
msgid "B<FPE_FLTDIV>"
msgstr ""

#. type: Plain text
#: man-pages/man2/sigaction.2:688
msgid "Floating-point divide by zero."
msgstr ""

#. type: TP
#: man-pages/man2/sigaction.2:688
#, no-wrap
msgid "B<FPE_FLTOVF>"
msgstr ""

#. type: Plain text
#: man-pages/man2/sigaction.2:691
msgid "Floating-point overflow."
msgstr ""

#. type: TP
#: man-pages/man2/sigaction.2:691
#, no-wrap
msgid "B<FPE_FLTUND>"
msgstr ""

#. type: Plain text
#: man-pages/man2/sigaction.2:694
msgid "Floating-point underflow."
msgstr ""

#. type: TP
#: man-pages/man2/sigaction.2:694
#, no-wrap
msgid "B<FPE_FLTRES>"
msgstr ""

#. type: Plain text
#: man-pages/man2/sigaction.2:697
msgid "Floating-point inexact result."
msgstr ""

#. type: TP
#: man-pages/man2/sigaction.2:697
#, no-wrap
msgid "B<FPE_FLTINV>"
msgstr ""

#. type: Plain text
#: man-pages/man2/sigaction.2:700
msgid "Floating-point invalid operation."
msgstr ""

#. type: TP
#: man-pages/man2/sigaction.2:700
#, no-wrap
msgid "B<FPE_FLTSUB>"
msgstr ""

#. type: Plain text
#: man-pages/man2/sigaction.2:703
msgid "Subscript out of range."
msgstr ""

#. type: Plain text
#: man-pages/man2/sigaction.2:710
msgid "The following values can be placed in I<si_code> for a B<SIGSEGV> signal:"
msgstr ""

#. type: TP
#: man-pages/man2/sigaction.2:711
#, no-wrap
msgid "B<SEGV_MAPERR>"
msgstr ""

#. type: Plain text
#: man-pages/man2/sigaction.2:714
msgid "Address not mapped to object."
msgstr ""

#. type: TP
#: man-pages/man2/sigaction.2:714
#, no-wrap
msgid "B<SEGV_ACCERR>"
msgstr ""

#. type: Plain text
#: man-pages/man2/sigaction.2:717
msgid "Invalid permissions for mapped object."
msgstr ""

#. type: TP
#: man-pages/man2/sigaction.2:717
#, no-wrap
msgid "B<SEGV_BNDERR> (since Linux 3.19)"
msgstr ""

#.  commit ee1b58d36aa1b5a79eaba11f5c3633c88231da83
#. type: Plain text
#: man-pages/man2/sigaction.2:721
msgid "Failed address bound checks."
msgstr ""

#. type: TP
#: man-pages/man2/sigaction.2:721
#, no-wrap
msgid "B<SEGV_PKUERR> (since Linux 4.6)"
msgstr ""

#.  commit cd0ea35ff5511cde299a61c21a95889b4a71464e
#. type: Plain text
#: man-pages/man2/sigaction.2:729
msgid ""
"Access was denied by memory protection keys.  See B<pkeys>(7).  The "
"protection key which applied to this access is available via I<si_pkey>."
msgstr ""

#. type: Plain text
#: man-pages/man2/sigaction.2:736
msgid "The following values can be placed in I<si_code> for a B<SIGBUS> signal:"
msgstr ""

#. type: TP
#: man-pages/man2/sigaction.2:737
#, no-wrap
msgid "B<BUS_ADRALN>"
msgstr ""

#. type: Plain text
#: man-pages/man2/sigaction.2:740
msgid "Invalid address alignment."
msgstr ""

#. type: TP
#: man-pages/man2/sigaction.2:740
#, no-wrap
msgid "B<BUS_ADRERR>"
msgstr ""

#. type: Plain text
#: man-pages/man2/sigaction.2:743
msgid "Nonexistent physical address."
msgstr ""

#. type: TP
#: man-pages/man2/sigaction.2:743
#, no-wrap
msgid "B<BUS_OBJERR>"
msgstr ""

#. type: Plain text
#: man-pages/man2/sigaction.2:746
msgid "Object-specific hardware error."
msgstr ""

#. type: TP
#: man-pages/man2/sigaction.2:746
#, no-wrap
msgid "B<BUS_MCEERR_AR> (since Linux 2.6.32)"
msgstr ""

#. type: Plain text
#: man-pages/man2/sigaction.2:749
msgid "Hardware memory error consumed on a machine check; action required."
msgstr ""

#. type: TP
#: man-pages/man2/sigaction.2:749
#, no-wrap
msgid "B<BUS_MCEERR_AO> (since Linux 2.6.32)"
msgstr ""

#. type: Plain text
#: man-pages/man2/sigaction.2:752
msgid "Hardware memory error detected in process but not consumed; action optional."
msgstr ""

#. type: Plain text
#: man-pages/man2/sigaction.2:759
msgid "The following values can be placed in I<si_code> for a B<SIGTRAP> signal:"
msgstr ""

#. type: TP
#: man-pages/man2/sigaction.2:760
#, no-wrap
msgid "B<TRAP_BRKPT>"
msgstr ""

#. type: Plain text
#: man-pages/man2/sigaction.2:763
msgid "Process breakpoint."
msgstr ""

#. type: TP
#: man-pages/man2/sigaction.2:763
#, no-wrap
msgid "B<TRAP_TRACE>"
msgstr ""

#. type: Plain text
#: man-pages/man2/sigaction.2:766
msgid "Process trace trap."
msgstr ""

#. type: TP
#: man-pages/man2/sigaction.2:766
#, no-wrap
msgid "B<TRAP_BRANCH> (since Linux 2.4, IA64 only))"
msgstr ""

#. type: Plain text
#: man-pages/man2/sigaction.2:769
msgid "Process taken branch trap."
msgstr ""

#. type: TP
#: man-pages/man2/sigaction.2:769
#, no-wrap
msgid "B<TRAP_HWBKPT> (since Linux 2.4, IA64 only))"
msgstr ""

#. type: Plain text
#: man-pages/man2/sigaction.2:772
msgid "Hardware breakpoint/watchpoint."
msgstr ""

#. type: Plain text
#: man-pages/man2/sigaction.2:779
msgid "The following values can be placed in I<si_code> for a B<SIGCHLD> signal:"
msgstr ""

#. type: TP
#: man-pages/man2/sigaction.2:780
#, no-wrap
msgid "B<CLD_EXITED>"
msgstr ""

#. type: Plain text
#: man-pages/man2/sigaction.2:783
msgid "Child has exited."
msgstr ""

#. type: TP
#: man-pages/man2/sigaction.2:783
#, no-wrap
msgid "B<CLD_KILLED>"
msgstr ""

#. type: Plain text
#: man-pages/man2/sigaction.2:786
msgid "Child was killed."
msgstr ""

#. type: TP
#: man-pages/man2/sigaction.2:786
#, no-wrap
msgid "B<CLD_DUMPED>"
msgstr ""

#. type: Plain text
#: man-pages/man2/sigaction.2:789
msgid "Child terminated abnormally."
msgstr ""

#. type: TP
#: man-pages/man2/sigaction.2:789
#, no-wrap
msgid "B<CLD_TRAPPED>"
msgstr ""

#. type: Plain text
#: man-pages/man2/sigaction.2:792
msgid "Traced child has trapped."
msgstr ""

#. type: TP
#: man-pages/man2/sigaction.2:792
#, no-wrap
msgid "B<CLD_STOPPED>"
msgstr ""

#. type: Plain text
#: man-pages/man2/sigaction.2:795
msgid "Child has stopped."
msgstr ""

#. type: TP
#: man-pages/man2/sigaction.2:795
#, no-wrap
msgid "B<CLD_CONTINUED> (since Linux 2.6.9)"
msgstr ""

#. type: Plain text
#: man-pages/man2/sigaction.2:798
msgid "Stopped child has continued."
msgstr ""

#. type: Plain text
#: man-pages/man2/sigaction.2:805
msgid ""
"The following values can be placed in I<si_code> for a B<SIGIO>/B<SIGPOLL> "
"signal:"
msgstr ""

#. type: TP
#: man-pages/man2/sigaction.2:806
#, no-wrap
msgid "B<POLL_IN>"
msgstr ""

#. type: Plain text
#: man-pages/man2/sigaction.2:809
msgid "Data input available."
msgstr ""

#. type: TP
#: man-pages/man2/sigaction.2:809
#, no-wrap
msgid "B<POLL_OUT>"
msgstr ""

#. type: Plain text
#: man-pages/man2/sigaction.2:812
msgid "Output buffers available."
msgstr ""

#. type: TP
#: man-pages/man2/sigaction.2:812
#, no-wrap
msgid "B<POLL_MSG>"
msgstr ""

#. type: Plain text
#: man-pages/man2/sigaction.2:815
msgid "Input message available."
msgstr ""

#. type: TP
#: man-pages/man2/sigaction.2:815
#, no-wrap
msgid "B<POLL_ERR>"
msgstr ""

#. type: Plain text
#: man-pages/man2/sigaction.2:818 man-pages/man2/sync_file_range.2:163
#: man-pages/man2/pciconfig_read.2:87
msgid "I/O error."
msgstr ""

#. type: TP
#: man-pages/man2/sigaction.2:818
#, no-wrap
msgid "B<POLL_PRI>"
msgstr ""

#. type: Plain text
#: man-pages/man2/sigaction.2:821
msgid "High priority input available."
msgstr ""

#. type: TP
#: man-pages/man2/sigaction.2:821
#, no-wrap
msgid "B<POLL_HUP>"
msgstr ""

#. type: Plain text
#: man-pages/man2/sigaction.2:824
msgid "Device disconnected."
msgstr ""

#. type: Plain text
#: man-pages/man2/sigaction.2:831
msgid "The following value can be placed in I<si_code> for a B<SIGSYS> signal:"
msgstr ""

#. type: TP
#: man-pages/man2/sigaction.2:832
#, no-wrap
msgid "B<SYS_SECCOMP> (since Linux 3.5)"
msgstr ""

#. type: Plain text
#: man-pages/man2/sigaction.2:837
msgid "Triggered by a B<seccomp>(2)  filter rule."
msgstr ""

#. type: Plain text
#: man-pages/man2/sigaction.2:843
msgid ""
"B<sigaction>()  returns 0 on success; on error, -1 is returned, and I<errno> "
"is set to indicate the error."
msgstr ""

#. type: Plain text
#: man-pages/man2/sigaction.2:848
msgid ""
"I<act> or I<oldact> points to memory which is not a valid part of the "
"process address space."
msgstr ""

#. type: Plain text
#: man-pages/man2/sigaction.2:855
msgid ""
"An invalid signal was specified.  This will also be generated if an attempt "
"is made to change the action for B<SIGKILL> or B<SIGSTOP>, which cannot be "
"caught or ignored."
msgstr ""

#. type: Plain text
#: man-pages/man2/sigaction.2:866
msgid ""
"A child created via B<fork>(2)  inherits a copy of its parent's signal "
"dispositions.  During an B<execve>(2), the dispositions of handled signals "
"are reset to the default; the dispositions of ignored signals are left "
"unchanged."
msgstr ""

#. type: Plain text
#: man-pages/man2/sigaction.2:884 man-pages/man2/signal.2:134
msgid ""
"According to POSIX, the behavior of a process is undefined after it ignores "
"a B<SIGFPE>, B<SIGILL>, or B<SIGSEGV> signal that was not generated by "
"B<kill>(2)  or B<raise>(3).  Integer division by zero has undefined result.  "
"On some architectures it will generate a B<SIGFPE> signal.  (Also dividing "
"the most negative integer by -1 may generate B<SIGFPE>.)  Ignoring this "
"signal might lead to an endless loop."
msgstr ""

#. type: Plain text
#: man-pages/man2/sigaction.2:901
msgid ""
"POSIX.1-1990 disallowed setting the action for B<SIGCHLD> to B<SIG_IGN>.  "
"POSIX.1-2001 and later allow this possibility, so that ignoring B<SIGCHLD> "
"can be used to prevent the creation of zombies (see B<wait>(2)).  "
"Nevertheless, the historical BSD and System\\ V behaviors for ignoring "
"B<SIGCHLD> differ, so that the only completely portable method of ensuring "
"that terminated children do not become zombies is to catch the B<SIGCHLD> "
"signal and perform a B<wait>(2)  or similar."
msgstr ""

#. type: Plain text
#: man-pages/man2/sigaction.2:917
msgid ""
"POSIX.1-1990 specified only B<SA_NOCLDSTOP>.  POSIX.1-2001 added "
"B<SA_NOCLDSTOP>, B<SA_NOCLDWAIT>, B<SA_NODEFER>, B<SA_ONSTACK>, "
"B<SA_RESETHAND>, B<SA_RESTART>, and B<SA_SIGINFO>.  Use of these latter "
"values in I<sa_flags> may be less portable in applications intended for "
"older UNIX implementations."
msgstr ""

#. type: Plain text
#: man-pages/man2/sigaction.2:921
msgid "The B<SA_RESETHAND> flag is compatible with the SVr4 flag of the same name."
msgstr ""

#. type: Plain text
#: man-pages/man2/sigaction.2:931
msgid ""
"The B<SA_NODEFER> flag is compatible with the SVr4 flag of the same name "
"under kernels 1.3.9 and newer.  On older kernels the Linux implementation "
"allowed the receipt of any signal, not just the one we are installing "
"(effectively overriding any I<sa_mask> settings)."
msgstr ""

#. type: Plain text
#: man-pages/man2/sigaction.2:937
msgid ""
"B<sigaction>()  can be called with a NULL second argument to query the "
"current signal handler.  It can also be used to check whether a given signal "
"is valid for the current machine by calling it with NULL second and third "
"arguments."
msgstr ""

#. type: Plain text
#: man-pages/man2/sigaction.2:943
msgid ""
"It is not possible to block B<SIGKILL> or B<SIGSTOP> (by specifying them in "
"I<sa_mask>).  Attempts to do so are silently ignored."
msgstr ""

#. type: Plain text
#: man-pages/man2/sigaction.2:947 man-pages/man2/sigprocmask.2:160
#: man-pages/man2/sigsuspend.2:110 man-pages/man2/sigpending.2:70
msgid "See B<sigsetops>(3)  for details on manipulating signal sets."
msgstr ""

#. type: Plain text
#: man-pages/man2/sigaction.2:953
msgid ""
"See B<signal-safety>(7)  for a list of the async-signal-safe functions that "
"can be safely called inside from inside a signal handler."
msgstr ""

#. type: Plain text
#: man-pages/man2/sigaction.2:963
msgid ""
"The glibc wrapper function for B<sigaction>()  gives an error (B<EINVAL>)  "
"on attempts to change the disposition of the two real-time signals used "
"internally by the NPTL threading implementation.  See B<nptl>(7)  for "
"details."
msgstr ""

#. type: Plain text
#: man-pages/man2/sigaction.2:976
msgid ""
"On architectures where the signal trampoline resides in the C library, the "
"glibc wrapper function for B<sigaction>()  places the address of the "
"trampoline code in the I<act.sa_restorer> field and sets the B<SA_RESTORER> "
"flag in the I<act.sa_flags> field.  See B<sigreturn>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/sigaction.2:1005
msgid ""
"The original Linux system call was named B<sigaction>().  However, with the "
"addition of real-time signals in Linux 2.2, the fixed-size, 32-bit "
"I<sigset_t> type supported by that system call was no longer fit for "
"purpose.  Consequently, a new system call, B<rt_sigaction>(), was added to "
"support an enlarged I<sigset_t> type.  The new system call takes a fourth "
"argument, I<size_t sigsetsize>, which specifies the size in bytes of the "
"signal sets in I<act.sa_mask> and I<oldact.sa_mask>.  This argument is "
"currently required to have the value I<sizeof(sigset_t)> (or the error "
"B<EINVAL> results).  The glibc B<sigaction>()  wrapper function hides these "
"details from us, transparently calling B<rt_sigaction>()  when the kernel "
"provides it."
msgstr ""

#. type: SS
#: man-pages/man2/sigaction.2:1005
#, no-wrap
msgid "Undocumented"
msgstr ""

#. type: Plain text
#: man-pages/man2/sigaction.2:1022
msgid ""
"Before the introduction of B<SA_SIGINFO>, it was also possible to get some "
"additional information about the signal.  This was done by providing an "
"I<sa_handler> signal handler with a second argument of type I<struct "
"sigcontext>, which is the same structure as the one that is passed in the "
"I<uc_mcontext> field of the I<ucontext> structure that is passed (via a "
"pointer) in the third argument of the I<sa_sigaction> handler.  See the "
"relevant Linux kernel sources for details.  This use is obsolete now."
msgstr ""

#. type: Plain text
#: man-pages/man2/sigaction.2:1031
msgid ""
"In kernels up to and including 2.6.13, specifying B<SA_NODEFER> in "
"I<sa_flags> prevents not only the delivered signal from being masked during "
"execution of the handler, but also the signals specified in I<sa_mask>.  "
"This bug was fixed in kernel 2.6.14."
msgstr ""

#. type: Plain text
#: man-pages/man2/sigaction.2:1034
msgid "See B<mprotect>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/sigaction.2:1056
msgid ""
"B<kill>(1), B<kill>(2), B<pause>(2), B<pidfd_send_signal>(2)  "
"B<restart_syscall>(2), B<seccomp>(2)  B<sigaltstack>(2), B<signal>(2), "
"B<signalfd>(2), B<sigpending>(2), B<sigprocmask>(2), B<sigreturn>(2), "
"B<sigsuspend>(2), B<wait>(2), B<killpg>(3), B<raise>(3), B<siginterrupt>(3), "
"B<sigqueue>(3), B<sigsetops>(3), B<sigvec>(3), B<core>(5), B<signal>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/getsockname.2:40
#, no-wrap
msgid "GETSOCKNAME"
msgstr ""

#. type: Plain text
#: man-pages/man2/getsockname.2:43
msgid "getsockname - get socket name"
msgstr ""

#. type: Plain text
#: man-pages/man2/getsockname.2:46 man-pages/man2/connect.2:75
#: man-pages/man2/recv.2:51
#, no-wrap
msgid "B<#include E<lt>sys/socket.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/getsockname.2:49
#, no-wrap
msgid ""
"B<int getsockname(int >I<sockfd>B<, struct sockaddr *>I<addr>B<, socklen_t "
"*>I<addrlen>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/getsockname.2:62
msgid ""
"B<getsockname>()  returns the current address to which the socket I<sockfd> "
"is bound, in the buffer pointed to by I<addr>.  The I<addrlen> argument "
"should be initialized to indicate the amount of space (in bytes) pointed to "
"by I<addr>.  On return it contains the actual size of the socket address."
msgstr ""

#. type: Plain text
#: man-pages/man2/getsockname.2:67 man-pages/man2/getpeername.2:68
#: man-pages/man2/accept.2:112
msgid ""
"The returned address is truncated if the buffer provided is too small; in "
"this case, I<addrlen> will return a value greater than was supplied to the "
"call."
msgstr ""

#. type: Plain text
#: man-pages/man2/getsockname.2:78 man-pages/man2/getpeername.2:79
#: man-pages/man2/listen.2:108 man-pages/man2/getsockopt.2:145
msgid "The argument I<sockfd> is not a valid file descriptor."
msgstr ""

#. type: Plain text
#: man-pages/man2/getsockname.2:84 man-pages/man2/getpeername.2:85
msgid ""
"The I<addr> argument points to memory not in a valid part of the process "
"address space."
msgstr ""

#. type: Plain text
#: man-pages/man2/getsockname.2:88 man-pages/man2/getpeername.2:89
msgid "I<addrlen> is invalid (e.g., is negative)."
msgstr ""

#. type: TP
#: man-pages/man2/getsockname.2:88 man-pages/man2/send.2:390
#: man-pages/man2/getpeername.2:89
#, no-wrap
msgid "B<ENOBUFS>"
msgstr ""

#. type: Plain text
#: man-pages/man2/getsockname.2:92 man-pages/man2/getpeername.2:93
msgid ""
"Insufficient resources were available in the system to perform the "
"operation."
msgstr ""

#.  SVr4 documents additional ENOMEM
#.  and ENOSR error codes.
#. type: Plain text
#: man-pages/man2/getsockname.2:103
msgid ""
"POSIX.1-2001, POSIX.1-2008, SVr4, 4.4BSD (B<getsockname>()  first appeared "
"in 4.2BSD)."
msgstr ""

#. type: Plain text
#: man-pages/man2/getsockname.2:114
msgid ""
"B<bind>(2), B<socket>(2), B<getifaddrs>(3), B<ip>(7), B<socket>(7), "
"B<unix>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/getpid.2:25
#, no-wrap
msgid "GETPID"
msgstr ""

#. type: Plain text
#: man-pages/man2/getpid.2:28
msgid "getpid, getppid - get process identification"
msgstr ""

#. type: Plain text
#: man-pages/man2/getpid.2:34
msgid "B<pid_t getpid(void);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/getpid.2:36
msgid "B<pid_t getppid(void);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/getpid.2:41
msgid ""
"B<getpid>()  returns the process ID (PID) of the calling process.  (This is "
"often used by routines that generate unique temporary filenames.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/getpid.2:53
msgid ""
"B<getppid>()  returns the process ID of the parent of the calling process.  "
"This will be either the ID of the process that created this process using "
"B<fork>(), or, if that process has already terminated, the ID of the process "
"to which this process has been reparented (either B<init>(1)  or a "
"\"subreaper\" process defined via the B<prctl>(2)  B<PR_SET_CHILD_SUBREAPER> "
"operation)."
msgstr ""

#. type: Plain text
#: man-pages/man2/getpid.2:55 man-pages/man2/getuid.2:45
#: man-pages/man2/getgid.2:44
msgid "These functions are always successful."
msgstr ""

#. type: Plain text
#: man-pages/man2/getpid.2:57
msgid "POSIX.1-2001, POSIX.1-2008, 4.3BSD, SVr4."
msgstr ""

#. type: Plain text
#: man-pages/man2/getpid.2:62
msgid ""
"If the caller's parent is in a different PID namespace (see "
"B<pid_namespaces>(7)), B<getppid>()  returns 0."
msgstr ""

#. type: Plain text
#: man-pages/man2/getpid.2:75
msgid ""
"From a kernel perspective, the PID (which is shared by all of the threads in "
"a multithreaded process)  is sometimes also known as the thread group ID "
"(TGID).  This contrasts with the kernel thread ID (TID), which is unique for "
"each thread.  For further details, see B<gettid>(2)  and the discussion of "
"the B<CLONE_THREAD> flag in B<clone>(2)."
msgstr ""

#.  The following program demonstrates this "feature":
#
#.  #define _GNU_SOURCE
#.  #include <sys/syscall.h>
#.  #include <sys/wait.h>
#.  #include <stdio.h>
#.  #include <stdlib.h>
#.  #include <unistd.h>
#
#.  int
#.  main(int argc, char *argv[])
#.  {
#.     /* The following statement fills the getpid() cache */
#
#.     printf("parent PID = %ld
#. ", (long) getpid());
#
#.     if (syscall(SYS_fork) == 0) {
#.         if (getpid() != syscall(SYS_getpid))
#.             printf("child getpid() mismatch: getpid()=%ld; "
#.                     "syscall(SYS_getpid)=%ld
#. ",
#.                     (long) getpid(), (long) syscall(SYS_getpid));
#.         exit(EXIT_SUCCESS);
#.     }
#.     wait(NULL);
#. }
#. type: Plain text
#: man-pages/man2/getpid.2:129
msgid ""
"From glibc version 2.3.4 up to and including version 2.24, the glibc wrapper "
"function for B<getpid>()  cached PIDs, with the goal of avoiding additional "
"system calls when a process calls B<getpid>()  repeatedly.  Normally this "
"caching was invisible, but its correct operation relied on support in the "
"wrapper functions for B<fork>(2), B<vfork>(2), and B<clone>(2): if an "
"application bypassed the glibc wrappers for these system calls by using "
"B<syscall>(2), then a call to B<getpid>()  in the child would return the "
"wrong value (to be precise: it would return the PID of the parent process).  "
"In addition, there were cases where B<getpid>()  could return the wrong "
"value even when invoking B<clone>(2)  via the glibc wrapper function.  (For "
"a discussion of one such case, see BUGS in B<clone>(2).)  Furthermore, the "
"complexity of the caching code had been the source of a few bugs within "
"glibc over the years."
msgstr ""

#.  commit c579f48edba88380635ab98cb612030e3ed8691e
#.  https://sourceware.org/glibc/wiki/Release/2.25#pid_cache_removal
#.  FIXME .
#.  Review progress of https://bugzilla.redhat.com/show_bug.cgi?id=1469757
#. type: Plain text
#: man-pages/man2/getpid.2:139
msgid ""
"Because of the aforementioned problems, since glibc version 2.25, the PID "
"cache is removed: calls to B<getpid>()  always invoke the actual system "
"call, rather than returning a cached value."
msgstr ""

#. type: Plain text
#: man-pages/man2/getpid.2:155
msgid ""
"On Alpha, instead of a pair of B<getpid>()  and B<getppid>()  system calls, "
"a single B<getxpid>()  system call is provided, which returns a pair of PID "
"and parent PID.  The glibc B<getpid>()  and B<getppid>()  wrapper functions "
"transparently deal with this.  See B<syscall>(2)  for details regarding "
"register mapping."
msgstr ""

#. type: Plain text
#: man-pages/man2/getpid.2:166
msgid ""
"B<clone>(2), B<fork>(2), B<gettid>(2), B<kill>(2), B<exec>(3), "
"B<mkstemp>(3), B<tempnam>(3), B<tmpfile>(3), B<tmpnam>(3), "
"B<credentials>(7), B<pid_namespaces>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/poll.2:31
#, no-wrap
msgid "POLL"
msgstr ""

#. type: Plain text
#: man-pages/man2/poll.2:34
msgid "poll, ppoll - wait for some event on a file descriptor"
msgstr ""

#. type: Plain text
#: man-pages/man2/poll.2:37
#, no-wrap
msgid "B<#include E<lt>poll.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/poll.2:39
#, no-wrap
msgid ""
"B<int poll(struct pollfd *>I<fds>B<, nfds_t >I<nfds>B<, int "
">I<timeout>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/poll.2:43
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>         /* See feature_test_macros(7) */\n"
"B<#include E<lt>signal.hE<gt>>\n"
"B<#include E<lt>poll.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/poll.2:46
#, no-wrap
msgid ""
"B<int ppoll(struct pollfd *>I<fds>B<, nfds_t >I<nfds>B<, >\n"
"B<        const struct timespec *>I<tmo_p>B<, const sigset_t "
"*>I<sigmask>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/poll.2:53
msgid ""
"B<poll>()  performs a similar task to B<select>(2): it waits for one of a "
"set of file descriptors to become ready to perform I/O."
msgstr ""

#. type: Plain text
#: man-pages/man2/poll.2:57
msgid ""
"The set of file descriptors to be monitored is specified in the I<fds> "
"argument, which is an array of structures of the following form:"
msgstr ""

#. type: Plain text
#: man-pages/man2/poll.2:65
#, no-wrap
msgid ""
"struct pollfd {\n"
"    int   fd;         /* file descriptor */\n"
"    short events;     /* requested events */\n"
"    short revents;    /* returned events */\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/poll.2:72
msgid ""
"The caller should specify the number of items in the I<fds> array in "
"I<nfds>."
msgstr ""

#. type: Plain text
#: man-pages/man2/poll.2:88
msgid ""
"The field I<fd> contains a file descriptor for an open file.  If this field "
"is negative, then the corresponding I<events> field is ignored and the "
"I<revents> field returns zero.  (This provides an easy way of ignoring a "
"file descriptor for a single B<poll>()  call: simply negate the I<fd> "
"field.  Note, however, that this technique can't be used to ignore file "
"descriptor 0.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/poll.2:103
msgid ""
"The field I<events> is an input parameter, a bit mask specifying the events "
"the application is interested in for the file descriptor I<fd>.  This field "
"may be specified as zero, in which case the only events that can be returned "
"in I<revents> are B<POLLHUP>, B<POLLERR>, and B<POLLNVAL> (see below)."
msgstr ""

#. type: Plain text
#: man-pages/man2/poll.2:122
msgid ""
"The field I<revents> is an output parameter, filled by the kernel with the "
"events that actually occurred.  The bits returned in I<revents> can include "
"any of those specified in I<events>, or one of the values B<POLLERR>, "
"B<POLLHUP>, or B<POLLNVAL>.  (These three bits are meaningless in the "
"I<events> field, and will be set in the I<revents> field whenever the "
"corresponding condition is true.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/poll.2:127
msgid ""
"If none of the events requested (and no error) has occurred for any of the "
"file descriptors, then B<poll>()  blocks until one of the events occurs."
msgstr ""

#. type: Plain text
#: man-pages/man2/poll.2:134
msgid ""
"The I<timeout> argument specifies the number of milliseconds that B<poll>()  "
"should block waiting for a file descriptor to become ready.  The call will "
"block until either:"
msgstr ""

#. type: Plain text
#: man-pages/man2/poll.2:136 man-pages/man2/select.2:183
msgid "a file descriptor becomes ready;"
msgstr ""

#. type: Plain text
#: man-pages/man2/poll.2:138 man-pages/man2/epoll_wait.2:66
#: man-pages/man2/select.2:185
msgid "the call is interrupted by a signal handler; or"
msgstr ""

#. type: Plain text
#: man-pages/man2/poll.2:140 man-pages/man2/epoll_wait.2:68
#: man-pages/man2/select.2:187
msgid "the timeout expires."
msgstr ""

#. type: Plain text
#: man-pages/man2/poll.2:154
msgid ""
"Note that the I<timeout> interval will be rounded up to the system clock "
"granularity, and kernel scheduling delays mean that the blocking interval "
"may overrun by a small amount.  Specifying a negative value in I<timeout> "
"means an infinite timeout.  Specifying a I<timeout> of zero causes B<poll>()  "
"to return immediately, even if no file descriptors are ready."
msgstr ""

#. type: Plain text
#: man-pages/man2/poll.2:160
msgid ""
"The bits that may be set/returned in I<events> and I<revents> are defined in "
"I<E<lt>poll.hE<gt>>:"
msgstr ""

#. type: TP
#: man-pages/man2/poll.2:160
#, no-wrap
msgid "B<POLLIN>"
msgstr ""

#. type: Plain text
#: man-pages/man2/poll.2:163
msgid "There is data to read."
msgstr ""

#. type: TP
#: man-pages/man2/poll.2:163
#, no-wrap
msgid "B<POLLPRI>"
msgstr ""

#. type: Plain text
#: man-pages/man2/poll.2:167
msgid ""
"There is some exceptional condition on the file descriptor.  Possibilities "
"include:"
msgstr ""

#. type: Plain text
#: man-pages/man2/poll.2:171
msgid "There is out-of-band data on a TCP socket (see B<tcp>(7))."
msgstr ""

#. type: Plain text
#: man-pages/man2/poll.2:175
msgid ""
"A pseudoterminal master in packet mode has seen a state change on the slave "
"(see B<ioctl_tty>(2))."
msgstr ""

#. type: Plain text
#: man-pages/man2/poll.2:180
msgid "A I<cgroup.events> file has been modified (see B<cgroups>(7))."
msgstr ""

#. type: TP
#: man-pages/man2/poll.2:181
#, no-wrap
msgid "B<POLLOUT>"
msgstr ""

#. type: Plain text
#: man-pages/man2/poll.2:187
msgid ""
"Writing is now possible, though a write larger that the available space in a "
"socket or pipe will still block (unless B<O_NONBLOCK> is set)."
msgstr ""

#. type: TP
#: man-pages/man2/poll.2:187
#, no-wrap
msgid "B<POLLRDHUP> (since Linux 2.6.17)"
msgstr ""

#. type: Plain text
#: man-pages/man2/poll.2:198
msgid ""
"Stream socket peer closed connection, or shut down writing half of "
"connection.  The B<_GNU_SOURCE> feature test macro must be defined (before "
"including I<any> header files)  in order to obtain this definition."
msgstr ""

#. type: TP
#: man-pages/man2/poll.2:198
#, no-wrap
msgid "B<POLLERR>"
msgstr ""

#. type: Plain text
#: man-pages/man2/poll.2:206
msgid ""
"Error condition (only returned in I<revents>; ignored in I<events>).  This "
"bit is also set for a file descriptor referring to the write end of a pipe "
"when the read end has been closed."
msgstr ""

#. type: TP
#: man-pages/man2/poll.2:206
#, no-wrap
msgid "B<POLLHUP>"
msgstr ""

#. type: Plain text
#: man-pages/man2/poll.2:216
msgid ""
"Hang up (only returned in I<revents>; ignored in I<events>).  Note that when "
"reading from a channel such as a pipe or a stream socket, this event merely "
"indicates that the peer closed its end of the channel.  Subsequent reads "
"from the channel will return 0 (end of file)  only after all outstanding "
"data in the channel has been consumed."
msgstr ""

#. type: TP
#: man-pages/man2/poll.2:216
#, no-wrap
msgid "B<POLLNVAL>"
msgstr ""

#. type: Plain text
#: man-pages/man2/poll.2:224
msgid ""
"Invalid request: I<fd> not open (only returned in I<revents>; ignored in "
"I<events>)."
msgstr ""

#. type: Plain text
#: man-pages/man2/poll.2:229
msgid ""
"When compiling with B<_XOPEN_SOURCE> defined, one also has the following, "
"which convey no further information beyond the bits listed above:"
msgstr ""

#. type: TP
#: man-pages/man2/poll.2:229
#, no-wrap
msgid "B<POLLRDNORM>"
msgstr ""

#. type: Plain text
#: man-pages/man2/poll.2:233
msgid "Equivalent to B<POLLIN>."
msgstr ""

#. type: TP
#: man-pages/man2/poll.2:233
#, no-wrap
msgid "B<POLLRDBAND>"
msgstr ""

#.  POLLRDBAND is used in the DECnet protocol.
#. type: Plain text
#: man-pages/man2/poll.2:237
msgid "Priority band data can be read (generally unused on Linux)."
msgstr ""

#. type: TP
#: man-pages/man2/poll.2:237
#, no-wrap
msgid "B<POLLWRNORM>"
msgstr ""

#. type: Plain text
#: man-pages/man2/poll.2:241
msgid "Equivalent to B<POLLOUT>."
msgstr ""

#. type: TP
#: man-pages/man2/poll.2:241
#, no-wrap
msgid "B<POLLWRBAND>"
msgstr ""

#. type: Plain text
#: man-pages/man2/poll.2:244
msgid "Priority data may be written."
msgstr ""

#. type: Plain text
#: man-pages/man2/poll.2:247
msgid "Linux also knows about, but does not use B<POLLMSG>."
msgstr ""

#. type: SS
#: man-pages/man2/poll.2:247
#, no-wrap
msgid "ppoll()"
msgstr ""

#. type: Plain text
#: man-pages/man2/poll.2:261
msgid ""
"The relationship between B<poll>()  and B<ppoll>()  is analogous to the "
"relationship between B<select>(2)  and B<pselect>(2): like B<pselect>(2), "
"B<ppoll>()  allows an application to safely wait until either a file "
"descriptor becomes ready or until a signal is caught."
msgstr ""

#. type: Plain text
#: man-pages/man2/poll.2:267
msgid ""
"Other than the difference in the precision of the I<timeout> argument, the "
"following B<ppoll>()  call:"
msgstr ""

#. type: Plain text
#: man-pages/man2/poll.2:271
#, no-wrap
msgid "ready = ppoll(&fds, nfds, tmo_p, &sigmask);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/poll.2:277
msgid "is nearly equivalent to I<atomically> executing the following calls:"
msgstr ""

#. type: Plain text
#: man-pages/man2/poll.2:282
#, no-wrap
msgid ""
"sigset_t origmask;\n"
"int timeout;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/poll.2:288
#, no-wrap
msgid ""
"timeout = (tmo_p == NULL) ? -1 :\n"
"          (tmo_p-E<gt>tv_sec * 1000 + tmo_p-E<gt>tv_nsec / 1000000);\n"
"pthread_sigmask(SIG_SETMASK, &sigmask, &origmask);\n"
"ready = poll(&fds, nfds, timeout);\n"
"pthread_sigmask(SIG_SETMASK, &origmask, NULL);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/poll.2:301
msgid ""
"The above code segment is described as I<nearly> equivalent because whereas "
"a negative I<timeout> value for B<poll>()  is interpreted as an infinite "
"timeout, a negative value expressed in I<*tmo_p> results in an error from "
"B<ppoll>()."
msgstr ""

#. type: Plain text
#: man-pages/man2/poll.2:307
msgid ""
"See the description of B<pselect>(2)  for an explanation of why B<ppoll>()  "
"is necessary."
msgstr ""

#. type: Plain text
#: man-pages/man2/poll.2:319
msgid ""
"If the I<sigmask> argument is specified as NULL, then no signal mask "
"manipulation is performed (and thus B<ppoll>()  differs from B<poll>()  only "
"in the precision of the I<timeout> argument)."
msgstr ""

#. type: Plain text
#: man-pages/man2/poll.2:326
msgid ""
"The I<tmo_p> argument specifies an upper limit on the amount of time that "
"B<ppoll>()  will block.  This argument is a pointer to a structure of the "
"following form:"
msgstr ""

#. type: Plain text
#: man-pages/man2/poll.2:333 man-pages/man2/select.2:284
#, no-wrap
msgid ""
"struct timespec {\n"
"    long    tv_sec;         /* seconds */\n"
"    long    tv_nsec;        /* nanoseconds */\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/poll.2:341
msgid "If I<tmo_p> is specified as NULL, then B<ppoll>()  can block indefinitely."
msgstr ""

#. type: Plain text
#: man-pages/man2/poll.2:351
msgid ""
"On success, a positive number is returned; this is the number of structures "
"which have nonzero I<revents> fields (in other words, those descriptors with "
"events or errors reported).  A value of 0 indicates that the call timed out "
"and no file descriptors were ready.  On error, -1 is returned, and I<errno> "
"is set appropriately."
msgstr ""

#. type: Plain text
#: man-pages/man2/poll.2:356
msgid ""
"The array given as argument was not contained in the calling program's "
"address space."
msgstr ""

#. type: Plain text
#: man-pages/man2/poll.2:360
msgid "A signal occurred before any requested event; see B<signal>(7)."
msgstr ""

#. type: Plain text
#: man-pages/man2/poll.2:367
msgid "The I<nfds> value exceeds the B<RLIMIT_NOFILE> value."
msgstr ""

#. type: Plain text
#: man-pages/man2/poll.2:373
msgid "(B<ppoll>())  The timeout value expressed in I<*ip> is invalid (negative)."
msgstr ""

#. type: Plain text
#: man-pages/man2/poll.2:376
msgid "There was no space to allocate file descriptor tables."
msgstr ""

#.  library call was introduced in libc 5.4.28
#. type: Plain text
#: man-pages/man2/poll.2:386
msgid ""
"The B<poll>()  system call was introduced in Linux 2.1.23.  On older kernels "
"that lack this system call, the glibc (and the old Linux libc)  B<poll>()  "
"wrapper function provides emulation using B<select>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/poll.2:393
msgid ""
"The B<ppoll>()  system call was added to Linux in kernel 2.6.16.  The "
"B<ppoll>()  library call was added in glibc 2.4."
msgstr ""

#.  NetBSD 3.0 has a pollts() which is like Linux ppoll().
#. type: Plain text
#: man-pages/man2/poll.2:399
msgid ""
"B<poll>()  conforms to POSIX.1-2001 and POSIX.1-2008.  B<ppoll>()  is "
"Linux-specific."
msgstr ""

#. type: Plain text
#: man-pages/man2/poll.2:407
msgid ""
"The operation of B<poll>()  and B<ppoll>()  is not affected by the "
"B<O_NONBLOCK> flag."
msgstr ""

#.  Darwin, according to a report by Jeremy Sequoia, relayed by Josh Triplett
#. type: Plain text
#: man-pages/man2/poll.2:421
msgid ""
"On some other UNIX systems, B<poll>()  can fail with the error B<EAGAIN> if "
"the system fails to allocate kernel-internal resources, rather than "
"B<ENOMEM> as Linux does.  POSIX permits this behavior.  Portable programs "
"may wish to check for B<EAGAIN> and loop, just as with B<EINTR>."
msgstr ""

#. type: Plain text
#: man-pages/man2/poll.2:429
msgid ""
"Some implementations define the nonstandard constant B<INFTIM> with the "
"value -1 for use as a I<timeout> for B<poll>().  This constant is not "
"provided in glibc."
msgstr ""

#. type: Plain text
#: man-pages/man2/poll.2:434
msgid ""
"For a discussion of what may happen if a file descriptor being monitored by "
"B<poll>()  is closed in another thread, see B<select>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/poll.2:448
msgid ""
"The Linux B<ppoll>()  system call modifies its I<tmo_p> argument.  However, "
"the glibc wrapper function hides this behavior by using a local variable for "
"the timeout argument that is passed to the system call.  Thus, the glibc "
"B<ppoll>()  function does not modify its I<tmo_p> argument."
msgstr ""

#. type: Plain text
#: man-pages/man2/poll.2:465
msgid ""
"The raw B<ppoll>()  system call has a fifth argument, I<size_t sigsetsize>, "
"which specifies the size in bytes of the I<sigmask> argument.  The glibc "
"B<ppoll>()  wrapper function specifies this argument as a fixed value (equal "
"to I<sizeof(kernel_sigset_t)>).  See B<sigprocmask>(2)  for a discussion on "
"the differences between the kernel and the libc notion of the sigset."
msgstr ""

#. type: Plain text
#: man-pages/man2/poll.2:469
msgid ""
"See the discussion of spurious readiness notifications under the BUGS "
"section of B<select>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/poll.2:474
msgid ""
"B<restart_syscall>(2), B<select>(2), B<select_tut>(2), B<epoll>(7), "
"B<time>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/ioctl_getfsmap.2:23
#, no-wrap
msgid "IOCTL_GETFSMAP"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_getfsmap.2:26
msgid "ioctl_getfsmap - retrieve the physical layout of the filesystem"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_getfsmap.2:29 man-pages/man2/ioctl_fideduperange.2:29
#: man-pages/man2/ioctl.2:46 man-pages/man2/ioctl_ficlonerange.2:29
msgid "B<#include E<lt>sys/ioctl.hE<gt>>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_getfsmap.2:31 man-pages/man2/ioctl_fideduperange.2:31
#: man-pages/man2/ioctl_ficlonerange.2:31
msgid "B<#include E<lt>linux/fs.hE<gt>>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_getfsmap.2:33
msgid "B<#include E<lt>linux/fsmap.hE<gt>>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_getfsmap.2:35
msgid "B<int ioctl(int >I<fd>B<, FS_IOC_GETFSMAP, struct fsmap_head * >I<arg>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_getfsmap.2:41
msgid ""
"This B<ioctl>(2)  operation retrieves physical extent mappings for a "
"filesystem.  This information can be used to discover which files are mapped "
"to a physical block, examine free space, or find known bad blocks, among "
"other things."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_getfsmap.2:44
msgid ""
"The sole argument to this operation should be a pointer to a single I<struct "
"fsmap_head>:"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_getfsmap.2:56
#, no-wrap
msgid ""
"struct fsmap {\n"
"    __u32 fmr_device;      /* Device ID */\n"
"    __u32 fmr_flags;       /* Mapping flags */\n"
"    __u64 fmr_physical;    /* Device offset of segment */\n"
"    __u64 fmr_owner;       /* Owner ID */\n"
"    __u64 fmr_offset;      /* File offset of segment */\n"
"    __u64 fmr_length;      /* Length of segment */\n"
"    __u64 fmr_reserved[3]; /* Must be zero */\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_getfsmap.2:63
#, no-wrap
msgid ""
"struct fsmap_head {\n"
"    __u32 fmh_iflags;       /* Control flags */\n"
"    __u32 fmh_oflags;       /* Output flags */\n"
"    __u32 fmh_count;        /* # of entries in array incl. input */\n"
"    __u32 fmh_entries;      /* # of entries filled in (output) */\n"
"    __u64 fmh_reserved[6];  /* Must be zero */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_getfsmap.2:68
#, no-wrap
msgid ""
"    struct fsmap fmh_keys[2];  /* Low and high keys for\n"
"                                  the mapping search */\n"
"    struct fsmap fmh_recs[];   /* Returned records */\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_getfsmap.2:80
msgid ""
"The two I<fmh_keys> array elements specify the lowest and highest "
"reverse-mapping key for which the application would like physical mapping "
"information.  A reverse mapping key consists of the tuple (device, block, "
"owner, offset).  The owner and offset fields are part of the key because "
"some filesystems support sharing physical blocks between multiple files and "
"therefore may return multiple mappings for a given physical block."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_getfsmap.2:85
msgid ""
"Filesystem mappings are copied into the I<fmh_recs> array, which immediately "
"follows the header data."
msgstr ""

#. type: SS
#: man-pages/man2/ioctl_getfsmap.2:85
#, no-wrap
msgid "Fields of struct fsmap_head"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_getfsmap.2:91
msgid ""
"The I<fmh_iflags> field is a bit mask passed to the kernel to alter the "
"output.  No flags are currently defined, so the caller must set this value "
"to zero."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_getfsmap.2:102
msgid ""
"The I<fmh_oflags> field is a bit mask of flags set by the kernel concerning "
"the returned mappings.  If B<FMH_OF_DEV_T> is set, then the I<fmr_device> "
"field represents a I<dev_t> structure containing the major and minor numbers "
"of the block device."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_getfsmap.2:112
msgid ""
"The I<fmh_count> field contains the number of elements in the array being "
"passed to the kernel.  If this value is 0, I<fmh_entries> will be set to the "
"number of records that would have been returned had the array been large "
"enough; no mapping information will be returned."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_getfsmap.2:118
msgid ""
"The I<fmh_entries> field contains the number of elements in the I<fmh_recs> "
"array that contain useful information."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_getfsmap.2:123
msgid "The I<fmh_reserved> fields must be set to zero."
msgstr ""

#. type: SS
#: man-pages/man2/ioctl_getfsmap.2:123
#, no-wrap
msgid "Keys"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_getfsmap.2:147
msgid ""
"The two key records in I<fsmap_head.fmh_keys> specify the lowest and highest "
"extent records in the keyspace that the caller wants returned.  A filesystem "
"that can share blocks between files likely requires the tuple (I<device>, "
"I<physical>, I<owner>, I<offset>, I<flags>)  to uniquely index any "
"filesystem mapping record.  Classic non-sharing filesystems might be able to "
"identify any record with only (I<device>, I<physical>, I<flags>).  For "
"example, if the low key is set to (8:0, 36864, 0, 0, 0), the filesystem will "
"only return records for extents starting at or above 36\\ KiB on disk.  If "
"the high key is set to (8:0, 1048576, 0, 0, 0), only records below 1\\ MiB "
"will be returned.  The format of I<fmr_device> in the keys must match the "
"format of the same field in the output records, as defined below.  By "
"convention, the field I<fsmap_head.fmh_keys[0]> must contain the low key and "
"I<fsmap_head.fmh_keys[1]> must contain the high key for the request."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_getfsmap.2:163
msgid ""
"For convenience, if I<fmr_length> is set in the low key, it will be added to "
"I<fmr_block> or I<fmr_offset> as appropriate.  The caller can take advantage "
"of this subtlety to set up subsequent calls by copying "
"I<fsmap_head.fmh_recs[fsmap_head.fmh_entries - 1]> into the low key.  The "
"function I<fsmap_advance> (defined in I<linux/fsmap.h>)  provides this "
"functionality."
msgstr ""

#. type: SS
#: man-pages/man2/ioctl_getfsmap.2:163
#, no-wrap
msgid "Fields of struct fsmap"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_getfsmap.2:177
msgid ""
"The I<fmr_device> field uniquely identifies the underlying storage device.  "
"If the B<FMH_OF_DEV_T> flag is set in the header's I<fmh_oflags> field, this "
"field contains a I<dev_t> from which major and minor numbers can be "
"extracted.  If the flag is not set, this field contains a value that must be "
"unique for each unique storage device."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_getfsmap.2:181
msgid "The I<fmr_physical> field contains the disk address of the extent in bytes."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_getfsmap.2:191
msgid ""
"The I<fmr_owner> field contains the owner of the extent.  This is an inode "
"number unless B<FMR_OF_SPECIAL_OWNER> is set in the I<fmr_flags> field, in "
"which case the value is determined by the filesystem.  See the section below "
"about owner values for more details."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_getfsmap.2:199
msgid ""
"The I<fmr_offset> field contains the logical address in the mapping record "
"in bytes.  This field has no meaning if the B<FMR_OF_SPECIAL_OWNER> or "
"B<FMR_OF_EXTENT_MAP> flags are set in I<fmr_flags>."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_getfsmap.2:203
msgid "The I<fmr_length> field contains the length of the extent in bytes."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_getfsmap.2:208
msgid "The I<fmr_flags> field is a bit mask of extent state flags.  The bits are:"
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_getfsmap.2:209
#, no-wrap
msgid "B<FMR_OF_PREALLOC>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_getfsmap.2:212
msgid "The extent is allocated but not yet written."
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_getfsmap.2:212
#, no-wrap
msgid "B<FMR_OF_ATTR_FORK>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_getfsmap.2:215
msgid "This extent contains extended attribute data."
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_getfsmap.2:215
#, no-wrap
msgid "B<FMR_OF_EXTENT_MAP>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_getfsmap.2:218
msgid "This extent contains extent map information for the owner."
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_getfsmap.2:218
#, no-wrap
msgid "B<FMR_OF_SHARED>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_getfsmap.2:221
msgid "Parts of this extent may be shared."
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_getfsmap.2:221
#, no-wrap
msgid "B<FMR_OF_SPECIAL_OWNER>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_getfsmap.2:226
msgid "The I<fmr_owner> field contains a special value instead of an inode number."
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_getfsmap.2:226
#, no-wrap
msgid "B<FMR_OF_LAST>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_getfsmap.2:229
msgid "This is the last record in the data set."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_getfsmap.2:235
msgid "The I<fmr_reserved> field will be set to zero."
msgstr ""

#. type: SS
#: man-pages/man2/ioctl_getfsmap.2:235
#, no-wrap
msgid "Owner values"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_getfsmap.2:249
msgid ""
"Generally, the value of the I<fmr_owner> field for non-metadata extents "
"should be an inode number.  However, filesystems are under no obligation to "
"report inode numbers; they may instead report B<FMR_OWN_UNKNOWN> if the "
"inode number cannot easily be retrieved, if the caller lacks sufficient "
"privilege, if the filesystem does not support stable inode numbers, or for "
"any other reason.  If a filesystem wishes to condition the reporting of "
"inode numbers based on process capabilities, it is strongly urged that the "
"B<CAP_SYS_ADMIN> capability be used for this purpose."
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_getfsmap.2:249
#, no-wrap
msgid "The following special owner values are generic to all filesystems:"
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_getfsmap.2:252
#, no-wrap
msgid "B<FMR_OWN_FREE>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_getfsmap.2:255 man-pages/man2/ioctl_getfsmap.2:268
#: man-pages/man2/ioctl_getfsmap.2:305
msgid "Free space."
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_getfsmap.2:255
#, no-wrap
msgid "B<FMR_OWN_UNKNOWN>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_getfsmap.2:258 man-pages/man2/ioctl_getfsmap.2:271
#: man-pages/man2/ioctl_getfsmap.2:308
msgid "This extent is in use but its owner is not known or not easily retrieved."
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_getfsmap.2:258
#, no-wrap
msgid "B<FMR_OWN_METADATA>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_getfsmap.2:261
msgid "This extent is filesystem metadata."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_getfsmap.2:264
msgid "XFS can return the following special owner values:"
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_getfsmap.2:265
#, no-wrap
msgid "B<XFS_FMR_OWN_FREE>"
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_getfsmap.2:268
#, no-wrap
msgid "B<XFS_FMR_OWN_UNKNOWN>"
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_getfsmap.2:271
#, no-wrap
msgid "B<XFS_FMR_OWN_FS>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_getfsmap.2:275
msgid ""
"Static filesystem metadata which exists at a fixed address.  These are the "
"AG superblock, the AGF, the AGFL, and the AGI headers."
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_getfsmap.2:275
#, no-wrap
msgid "B<XFS_FMR_OWN_LOG>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_getfsmap.2:278 man-pages/man2/ioctl_getfsmap.2:315
msgid "The filesystem journal."
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_getfsmap.2:278
#, no-wrap
msgid "B<XFS_FMR_OWN_AG>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_getfsmap.2:282
msgid ""
"Allocation group metadata, such as the free space btrees and the reverse "
"mapping btrees."
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_getfsmap.2:282
#, no-wrap
msgid "B<XFS_FMR_OWN_INOBT>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_getfsmap.2:285
msgid "The inode and free inode btrees."
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_getfsmap.2:285
#, no-wrap
msgid "B<XFS_FMR_OWN_INODES>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_getfsmap.2:288 man-pages/man2/ioctl_getfsmap.2:318
msgid "Inode records."
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_getfsmap.2:288
#, no-wrap
msgid "B<XFS_FMR_OWN_REFC>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_getfsmap.2:291
msgid "Reference count information."
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_getfsmap.2:291
#, no-wrap
msgid "B<XFS_FMR_OWN_COW>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_getfsmap.2:294
msgid "This extent is being used to stage a copy-on-write."
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_getfsmap.2:294
#, no-wrap
msgid "B<XFS_FMR_OWN_DEFECTIVE:>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_getfsmap.2:298
msgid ""
"This extent has been marked defective either by the filesystem or the "
"underlying device."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_getfsmap.2:301
msgid "ext4 can return the following special owner values:"
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_getfsmap.2:302
#, no-wrap
msgid "B<EXT4_FMR_OWN_FREE>"
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_getfsmap.2:305
#, no-wrap
msgid "B<EXT4_FMR_OWN_UNKNOWN>"
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_getfsmap.2:308
#, no-wrap
msgid "B<EXT4_FMR_OWN_FS>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_getfsmap.2:312
msgid ""
"Static filesystem metadata which exists at a fixed address.  This is the "
"superblock and the group descriptors."
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_getfsmap.2:312
#, no-wrap
msgid "B<EXT4_FMR_OWN_LOG>"
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_getfsmap.2:315
#, no-wrap
msgid "B<EXT4_FMR_OWN_INODES>"
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_getfsmap.2:318
#, no-wrap
msgid "B<EXT4_FMR_OWN_BLKBM>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_getfsmap.2:321
msgid "Block bit map."
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_getfsmap.2:321
#, no-wrap
msgid "B<EXT4_FMR_OWN_INOBM>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_getfsmap.2:324
msgid "Inode bit map."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_getfsmap.2:329 man-pages/man2/ioctl_fideduperange.2:150
#: man-pages/man2/ioctl_ficlonerange.2:89 man-pages/man2/ioctl_fat.2:193
#: man-pages/man2/sendmmsg.2:133
msgid "On error, -1 is returned, and I<errno> is set to indicate the error."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_getfsmap.2:334
msgid ""
"The error placed in I<errno> can be one of, but is not limited to, the "
"following:"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_getfsmap.2:338
msgid "I<fd> is not open for reading."
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_getfsmap.2:338
#, no-wrap
msgid "B<EBADMSG>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_getfsmap.2:341
msgid "The filesystem has detected a checksum error in the metadata."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_getfsmap.2:344
msgid "The pointer passed in was not mapped to a valid memory address."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_getfsmap.2:350
msgid ""
"The array is not long enough, the keys do not point to a valid part of the "
"filesystem, the low key points to a higher point in the filesystem's "
"physical storage address space than the high key, or a nonzero value was "
"passed in one of the fields that must be zero."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_getfsmap.2:353
msgid "Insufficient memory to process the request."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_getfsmap.2:356
msgid "The filesystem does not support this command."
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_getfsmap.2:356
#, no-wrap
msgid "B<EUCLEAN>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_getfsmap.2:359
msgid "The filesystem metadata is corrupt and needs repair."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_getfsmap.2:363
msgid "The B<FS_IOC_GETFSMAP> operation first appeared in Linux 4.12."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_getfsmap.2:366
msgid "This API is Linux-specific.  Not all filesystems support it."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_getfsmap.2:372
msgid "See I<io/fsmap.c> in the I<xfsprogs> distribution for a sample program."
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_getfsmap.2:373 man-pages/man2/ioctl_fideduperange.2:214
#: man-pages/man2/syscalls.2:396 man-pages/man2/ioctl_ficlonerange.2:145
#: man-pages/man2/ioctl_fat.2:502 man-pages/man2/timerfd_create.2:341
#, no-wrap
msgid "B<ioctl>(2)"
msgstr ""

#. type: TH
#: man-pages/man2/signal.2:36
#, no-wrap
msgid "SIGNAL"
msgstr ""

#. type: Plain text
#: man-pages/man2/signal.2:39
msgid "signal - ANSI C signal handling"
msgstr ""

#. type: Plain text
#: man-pages/man2/signal.2:41 man-pages/man2/sigprocmask.2:34
#: man-pages/man2/sigaltstack.2:32 man-pages/man2/sigsuspend.2:34
#: man-pages/man2/sigpending.2:34
msgid "B<#include E<lt>signal.hE<gt>>"
msgstr ""

#. type: Plain text
#: man-pages/man2/signal.2:43
msgid "B<typedef void (*sighandler_t)(int);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/signal.2:45
msgid "B<sighandler_t signal(int >I<signum>B<, sighandler_t >I<handler>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/signal.2:54
msgid ""
"The behavior of B<signal>()  varies across UNIX versions, and has also "
"varied historically across different versions of Linux.  B<Avoid its use>: "
"use B<sigaction>(2)  instead.  See I<Portability> below."
msgstr ""

#. type: Plain text
#: man-pages/man2/signal.2:64
msgid ""
"B<signal>()  sets the disposition of the signal I<signum> to I<handler>, "
"which is either B<SIG_IGN>, B<SIG_DFL>, or the address of a "
"programmer-defined function (a \"signal handler\")."
msgstr ""

#. type: Plain text
#: man-pages/man2/signal.2:68
msgid ""
"If the signal I<signum> is delivered to the process, then one of the "
"following happens:"
msgstr ""

#. type: Plain text
#: man-pages/man2/signal.2:73
msgid "If the disposition is set to B<SIG_IGN>, then the signal is ignored."
msgstr ""

#. type: Plain text
#: man-pages/man2/signal.2:80
msgid ""
"If the disposition is set to B<SIG_DFL>, then the default action associated "
"with the signal (see B<signal>(7))  occurs."
msgstr ""

#. type: Plain text
#: man-pages/man2/signal.2:91
msgid ""
"If the disposition is set to a function, then first either the disposition "
"is reset to B<SIG_DFL>, or the signal is blocked (see I<Portability> below), "
"and then I<handler> is called with argument I<signum>.  If invocation of the "
"handler caused the signal to be blocked, then the signal is unblocked upon "
"return from the handler."
msgstr ""

#. type: Plain text
#: man-pages/man2/signal.2:97
msgid "The signals B<SIGKILL> and B<SIGSTOP> cannot be caught or ignored."
msgstr ""

#. type: Plain text
#: man-pages/man2/signal.2:105
msgid ""
"B<signal>()  returns the previous value of the signal handler, or B<SIG_ERR> "
"on error.  In the event of an error, I<errno> is set to indicate the cause."
msgstr ""

#. type: Plain text
#: man-pages/man2/signal.2:110
msgid "I<signum> is invalid."
msgstr ""

#. type: Plain text
#: man-pages/man2/signal.2:112
msgid "POSIX.1-2001, POSIX.1-2008, C89, C99."
msgstr ""

#. type: Plain text
#: man-pages/man2/signal.2:116
msgid "The effects of B<signal>()  in a multithreaded process are unspecified."
msgstr ""

#. type: Plain text
#: man-pages/man2/signal.2:141
msgid ""
"See B<sigaction>(2)  for details on what happens when the disposition "
"B<SIGCHLD> is set to B<SIG_IGN>."
msgstr ""

#. type: Plain text
#: man-pages/man2/signal.2:146
msgid ""
"See B<signal-safety>(7)  for a list of the async-signal-safe functions that "
"can be safely called from inside a signal handler."
msgstr ""

#.  libc4 and libc5 define
#.  .IR SignalHandler ;
#. type: Plain text
#: man-pages/man2/signal.2:166
msgid ""
"The use of I<sighandler_t> is a GNU extension, exposed if B<_GNU_SOURCE> is "
"defined; glibc also defines (the BSD-derived)  I<sig_t> if B<_BSD_SOURCE> "
"(glibc 2.19 and earlier)  or B<_DEFAULT_SOURCE> (glibc 2.19 and later)  is "
"defined.  Without use of such a type, the declaration of B<signal>()  is the "
"somewhat harder to read:"
msgstr ""

#. type: Plain text
#: man-pages/man2/signal.2:170
#, no-wrap
msgid ""
"B<void ( *>I<signal>B<(int >I<signum>B<, void (*>I<handler>B<)(int)) ) "
"(int);>\n"
msgstr ""

#. type: SS
#: man-pages/man2/signal.2:172
#, no-wrap
msgid "Portability"
msgstr ""

#. type: Plain text
#: man-pages/man2/signal.2:184
msgid ""
"The only portable use of B<signal>()  is to set a signal's disposition to "
"B<SIG_DFL> or B<SIG_IGN>.  The semantics when using B<signal>()  to "
"establish a signal handler vary across systems (and POSIX.1 explicitly "
"permits this variation); B<do not use it for this purpose.>"
msgstr ""

#. type: Plain text
#: man-pages/man2/signal.2:190
msgid ""
"POSIX.1 solved the portability mess by specifying B<sigaction>(2), which "
"provides explicit control of the semantics when a signal handler is invoked; "
"use that interface instead of B<signal>()."
msgstr ""

#. type: Plain text
#: man-pages/man2/signal.2:200
msgid ""
"In the original UNIX systems, when a handler that was established using "
"B<signal>()  was invoked by the delivery of a signal, the disposition of the "
"signal would be reset to B<SIG_DFL>, and the system did not block delivery "
"of further instances of the signal.  This is equivalent to calling "
"B<sigaction>(2)  with the following flags:"
msgstr ""

#. type: Plain text
#: man-pages/man2/signal.2:203
#, no-wrap
msgid "    sa.sa_flags = SA_RESETHAND | SA_NODEFER;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/signal.2:211
msgid ""
"System\\ V also provides these semantics for B<signal>().  This was bad "
"because the signal might be delivered again before the handler had a chance "
"to reestablish itself.  Furthermore, rapid deliveries of the same signal "
"could result in recursive invocations of the handler."
msgstr ""

#. type: Plain text
#: man-pages/man2/signal.2:226
msgid ""
"BSD improved on this situation, but unfortunately also changed the semantics "
"of the existing B<signal>()  interface while doing so.  On BSD, when a "
"signal handler is invoked, the signal disposition is not reset, and further "
"instances of the signal are blocked from being delivered while the handler "
"is executing.  Furthermore, certain blocking system calls are automatically "
"restarted if interrupted by a signal handler (see B<signal>(7)).  The BSD "
"semantics are equivalent to calling B<sigaction>(2)  with the following "
"flags:"
msgstr ""

#. type: Plain text
#: man-pages/man2/signal.2:229
#, no-wrap
msgid "    sa.sa_flags = SA_RESTART;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/signal.2:232
msgid "The situation on Linux is as follows:"
msgstr ""

#. type: Plain text
#: man-pages/man2/signal.2:236
msgid "The kernel's B<signal>()  system call provides System\\ V semantics."
msgstr ""

#
#.  System V semantics are also provided if one uses the separate
#.  .BR sysv_signal (3)
#.  function.
#.  .IP *
#.  The
#.  .BR signal ()
#.  function in Linux libc4 and libc5 provide System\ V semantics.
#.  If one on a libc5 system includes
#.  .I <bsd/signal.h>
#.  instead of
#.  .IR <signal.h> ,
#.  then
#.  .BR signal ()
#.  provides BSD semantics.
#. type: Plain text
#: man-pages/man2/signal.2:270
msgid ""
"By default, in glibc 2 and later, the B<signal>()  wrapper function does not "
"invoke the kernel system call.  Instead, it calls B<sigaction>(2)  using "
"flags that supply BSD semantics.  This default behavior is provided as long "
"as a suitable feature test macro is defined: B<_BSD_SOURCE> on glibc 2.19 "
"and earlier or B<_DEFAULT_SOURCE> in glibc 2.19 and later.  (By default, "
"these macros are defined; see B<feature_test_macros>(7)  for details.)  If "
"such a feature test macro is not defined, then B<signal>()  provides "
"System\\ V semantics."
msgstr ""

#. type: Plain text
#: man-pages/man2/signal.2:288
msgid ""
"B<kill>(1), B<alarm>(2), B<kill>(2), B<pause>(2), B<sigaction>(2), "
"B<signalfd>(2), B<sigpending>(2), B<sigprocmask>(2), B<sigsuspend>(2), "
"B<bsd_signal>(3), B<killpg>(3), B<raise>(3), B<siginterrupt>(3), "
"B<sigqueue>(3), B<sigsetops>(3), B<sigvec>(3), B<sysv_signal>(3), "
"B<signal>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/rename.2:33
#, no-wrap
msgid "RENAME"
msgstr ""

#. type: Plain text
#: man-pages/man2/rename.2:36
msgid "rename, renameat, renameat2 - change the name or location of a file"
msgstr ""

#. type: Plain text
#: man-pages/man2/rename.2:39
#, no-wrap
msgid "B<#include E<lt>stdio.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/rename.2:41
#, no-wrap
msgid "B<int rename(const char *>I<oldpath>B<, const char *>I<newpath>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/rename.2:44
#, no-wrap
msgid ""
"B<#include E<lt>fcntl.hE<gt>           >/* Definition of AT_* constants */\n"
"B<#include E<lt>stdio.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/rename.2:47
#, no-wrap
msgid ""
"B<int renameat(int >I<olddirfd>B<, const char *>I<oldpath>B<,>\n"
"B<             int >I<newdirfd>B<, const char *>I<newpath>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/rename.2:51
#, no-wrap
msgid ""
"B<int renameat2(int >I<olddirfd>B<, const char *>I<oldpath>B<,>\n"
"B<              int >I<newdirfd>B<, const char *>I<newpath>B<, unsigned int "
">I<flags>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/rename.2:59
msgid "B<renameat>():"
msgstr ""

#. type: TP
#: man-pages/man2/rename.2:62 man-pages/man2/open.2:79
#: man-pages/man2/access.2:68 man-pages/man2/chmod.2:83
#: man-pages/man2/unlink.2:57 man-pages/man2/symlink.2:66
#: man-pages/man2/utimensat.2:49 man-pages/man2/utimensat.2:59
#: man-pages/man2/chown.2:76 man-pages/man2/stat.2:83 man-pages/man2/link.2:57
#: man-pages/man2/readlink.2:78 man-pages/man2/mkdir.2:37
#, no-wrap
msgid "Since glibc 2.10:"
msgstr ""

#. type: Plain text
#: man-pages/man2/rename.2:65 man-pages/man2/open.2:82
#: man-pages/man2/access.2:71 man-pages/man2/chmod.2:86
#: man-pages/man2/unlink.2:60 man-pages/man2/symlink.2:69
#: man-pages/man2/utimensat.2:52 man-pages/man2/utimensat.2:62
#: man-pages/man2/chown.2:79 man-pages/man2/stat.2:86 man-pages/man2/link.2:60
#: man-pages/man2/readlink.2:81 man-pages/man2/mkdir.2:40
msgid "_POSIX_C_SOURCE\\ E<gt>=\\ 200809L"
msgstr ""

#. type: TP
#: man-pages/man2/rename.2:65 man-pages/man2/open.2:82
#: man-pages/man2/access.2:71 man-pages/man2/chmod.2:86
#: man-pages/man2/unlink.2:60 man-pages/man2/symlink.2:69
#: man-pages/man2/utimensat.2:52 man-pages/man2/utimensat.2:62
#: man-pages/man2/chown.2:79 man-pages/man2/stat.2:86 man-pages/man2/link.2:60
#: man-pages/man2/readlink.2:81 man-pages/man2/mkdir.2:40
#, no-wrap
msgid "Before glibc 2.10:"
msgstr ""

#. type: Plain text
#: man-pages/man2/rename.2:68 man-pages/man2/open.2:85
#: man-pages/man2/access.2:74 man-pages/man2/chmod.2:89
#: man-pages/man2/unlink.2:63 man-pages/man2/symlink.2:72
#: man-pages/man2/utimensat.2:55 man-pages/man2/chown.2:82
#: man-pages/man2/stat.2:89 man-pages/man2/link.2:63
#: man-pages/man2/readlink.2:84 man-pages/man2/mkdir.2:43
msgid "_ATFILE_SOURCE"
msgstr ""

#. type: Plain text
#: man-pages/man2/rename.2:71
msgid "B<renameat2>():"
msgstr ""

#. type: Plain text
#: man-pages/man2/rename.2:72 man-pages/man2/utimensat.2:65
#: man-pages/man2/sync.2:65
#, no-wrap
msgid "_GNU_SOURCE"
msgstr ""

#. type: Plain text
#: man-pages/man2/rename.2:86
msgid ""
"B<rename>()  renames a file, moving it between directories if required.  Any "
"other hard links to the file (as created using B<link>(2))  are unaffected.  "
"Open file descriptors for I<oldpath> are also unaffected."
msgstr ""

#. type: Plain text
#: man-pages/man2/rename.2:89
msgid ""
"Various restrictions determine whether or not the rename operation succeeds: "
"see ERRORS below."
msgstr ""

#. type: Plain text
#: man-pages/man2/rename.2:101
msgid ""
"If I<newpath> already exists, it will be atomically replaced, so that there "
"is no point at which another process attempting to access I<newpath> will "
"find it missing.  However, there will probably be a window in which both "
"I<oldpath> and I<newpath> refer to the file being renamed."
msgstr ""

#. type: Plain text
#: man-pages/man2/rename.2:109
msgid ""
"If I<oldpath> and I<newpath> are existing hard links referring to the same "
"file, then B<rename>()  does nothing, and returns a success status."
msgstr ""

#. type: Plain text
#: man-pages/man2/rename.2:117
msgid ""
"If I<newpath> exists but the operation fails for some reason, B<rename>()  "
"guarantees to leave an instance of I<newpath> in place."
msgstr ""

#. type: Plain text
#: man-pages/man2/rename.2:123
msgid ""
"I<oldpath> can specify a directory.  In this case, I<newpath> must either "
"not exist, or it must specify an empty directory."
msgstr ""

#. type: Plain text
#: man-pages/man2/rename.2:129
msgid ""
"If I<oldpath> refers to a symbolic link, the link is renamed; if I<newpath> "
"refers to a symbolic link, the link will be overwritten."
msgstr ""

#. type: SS
#: man-pages/man2/rename.2:129
#, no-wrap
msgid "renameat()"
msgstr ""

#. type: Plain text
#: man-pages/man2/rename.2:135
msgid ""
"The B<renameat>()  system call operates in exactly the same way as "
"B<rename>(), except for the differences described here."
msgstr ""

#. type: Plain text
#: man-pages/man2/rename.2:145
msgid ""
"If the pathname given in I<oldpath> is relative, then it is interpreted "
"relative to the directory referred to by the file descriptor I<olddirfd> "
"(rather than relative to the current working directory of the calling "
"process, as is done by B<rename>()  for a relative pathname)."
msgstr ""

#. type: Plain text
#: man-pages/man2/rename.2:157
msgid ""
"If I<oldpath> is relative and I<olddirfd> is the special value B<AT_FDCWD>, "
"then I<oldpath> is interpreted relative to the current working directory of "
"the calling process (like B<rename>())."
msgstr ""

#. type: Plain text
#: man-pages/man2/rename.2:163 man-pages/man2/link.2:114
msgid "If I<oldpath> is absolute, then I<olddirfd> is ignored."
msgstr ""

#. type: Plain text
#: man-pages/man2/rename.2:171 man-pages/man2/link.2:122
msgid ""
"The interpretation of I<newpath> is as for I<oldpath>, except that a "
"relative pathname is interpreted relative to the directory referred to by "
"the file descriptor I<newdirfd>."
msgstr ""

#. type: Plain text
#: man-pages/man2/rename.2:176
msgid "See B<openat>(2)  for an explanation of the need for B<renameat>()."
msgstr ""

#. type: SS
#: man-pages/man2/rename.2:176
#, no-wrap
msgid "renameat2()"
msgstr ""

#. type: Plain text
#: man-pages/man2/rename.2:187
msgid ""
"B<renameat2>()  has an additional I<flags> argument.  A B<renameat2>()  call "
"with a zero I<flags> argument is equivalent to B<renameat>()."
msgstr ""

#. type: Plain text
#: man-pages/man2/rename.2:191
msgid ""
"The I<flags> argument is a bit mask consisting of zero or more of the "
"following flags:"
msgstr ""

#. type: TP
#: man-pages/man2/rename.2:191
#, no-wrap
msgid "B<RENAME_EXCHANGE>"
msgstr ""

#. type: Plain text
#: man-pages/man2/rename.2:200
msgid ""
"Atomically exchange I<oldpath> and I<newpath>.  Both pathnames must exist "
"but may be of different types (e.g., one could be a non-empty directory and "
"the other a symbolic link)."
msgstr ""

#. type: TP
#: man-pages/man2/rename.2:200
#, no-wrap
msgid "B<RENAME_NOREPLACE>"
msgstr ""

#. type: Plain text
#: man-pages/man2/rename.2:208
msgid ""
"Don't overwrite I<newpath> of the rename.  Return an error if I<newpath> "
"already exists."
msgstr ""

#. type: Plain text
#: man-pages/man2/rename.2:212
msgid "B<RENAME_NOREPLACE> can't be employed together with B<RENAME_EXCHANGE>."
msgstr ""

#. type: Plain text
#: man-pages/man2/rename.2:216
msgid ""
"B<RENAME_NOREPLACE> requires support from the underlying filesystem.  "
"Support for various filesystems was added as follows:"
msgstr ""

#.  ext4: commit 0a7c3937a1f23f8cb5fc77ae01661e9968a51d0c
#. type: Plain text
#: man-pages/man2/rename.2:220
msgid "ext4 (Linux 3.15);"
msgstr ""

#. type: Plain text
#: man-pages/man2/rename.2:222
msgid "btrfs, shmem, and cifs (Linux 3.17);"
msgstr ""

#.  btrfs: commit 80ace85c915d0f41016f82917218997b72431258
#.  shmem: commit 3b69ff51d087d265aa4af3a532fc4f20bf33e718
#.  cifs: commit 7c33d5972ce382bcc506d16235f1e9b7d22cbef8
#
#.  gfs2 in 4.2?
#. type: Plain text
#: man-pages/man2/rename.2:229
msgid "xfs (Linux 4.0);"
msgstr ""

#.  Also affs, bfs, exofs, hfs, hfsplus, jffs2, logfs, msdos,
#.  nilfs2, omfs, sysvfs, ubifs, udf, ufs
#.  hugetlbfs, ramfs
#.  local filesystems: commit f03b8ad8d38634d13e802165cc15917481b47835
#.  libfs: commit e0e0be8a835520e2f7c89f214dfda570922a1b90
#. type: Plain text
#: man-pages/man2/rename.2:237
msgid ""
"Support for many other filesystems was added in Linux 4.9, including etx2, "
"minix, reiserfs, jfs, vfat, and bpf."
msgstr ""

#. type: TP
#: man-pages/man2/rename.2:238
#, no-wrap
msgid "B<RENAME_WHITEOUT> (since Linux 3.18)"
msgstr ""

#.  commit 0d7a855526dd672e114aff2ac22b60fc6f155b08
#.  commit 787fb6bc9682ec7c05fb5d9561b57100fbc1cc41
#. type: Plain text
#: man-pages/man2/rename.2:244
msgid ""
"This operation makes sense only for overlay/union filesystem "
"implementations."
msgstr ""

#. type: Plain text
#: man-pages/man2/rename.2:251
msgid ""
"Specifying B<RENAME_WHITEOUT> creates a \"whiteout\" object at the source of "
"the rename at the same time as performing the rename.  The whole operation "
"is atomic, so that if the rename succeeds then the whiteout will also have "
"been created."
msgstr ""

#. type: Plain text
#: man-pages/man2/rename.2:259
msgid ""
"A \"whiteout\" is an object that has special meaning in union/overlay "
"filesystem constructs.  In these constructs, multiple layers exist and only "
"the top one is ever modified.  A whiteout on an upper layer will effectively "
"hide a matching file in the lower layer, making it appear as if the file "
"didn't exist."
msgstr ""

#. type: Plain text
#: man-pages/man2/rename.2:267
msgid ""
"When a file that exists on the lower layer is renamed, the file is first "
"copied up (if not already on the upper layer)  and then renamed on the "
"upper, read-write layer.  At the same time, the source file needs to be "
"\"whiteouted\" (so that the version of the source file in the lower layer is "
"rendered invisible).  The whole operation needs to be done atomically."
msgstr ""

#.  https://www.freebsd.org/cgi/man.cgi?query=mount_unionfs&manpath=FreeBSD+11.0-RELEASE
#. type: Plain text
#: man-pages/man2/rename.2:278
msgid ""
"When not part of a union/overlay, the whiteout appears as a character device "
"with a {0,0} device number.  (Note that other union/overlay implementations "
"may employ different methods for storing whiteout entries; specifically, BSD "
"union mount employs a separate inode type, B<DT_WHT>, which, while supported "
"by some filesystems available in Linux, such as CODA and XFS, is ignored by "
"the kernel's whiteout support code, as of Linux 4.19, at least.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/rename.2:283
msgid ""
"B<RENAME_WHITEOUT> requires the same privileges as creating a device node "
"(i.e., the B<CAP_MKNOD> capability)."
msgstr ""

#. type: Plain text
#: man-pages/man2/rename.2:287
msgid "B<RENAME_WHITEOUT> can't be employed together with B<RENAME_EXCHANGE>."
msgstr ""

#.  tmpfs: commit 46fdb794e3f52ef18b859ebc92f0a9d7db21c5df
#.  ext4: commit cd808deced431b66b5fa4e5c193cb7ec0059eaff
#.  XFS: commit 7dcf5c3e4527cfa2807567b00387cf2ed5e07f00
#.  f2fs: commit 7e01e7ad746bc8198a8b46163ddc73a1c7d22339
#.  btrfs: commit cdd1fedf8261cd7a73c0596298902ff4f0f04492
#.  ubifs: commit 9e0a1fff8db56eaaebb74b4a3ef65f86811c4798
#. type: Plain text
#: man-pages/man2/rename.2:303
msgid ""
"B<RENAME_WHITEOUT> requires support from the underlying filesystem.  Among "
"the filesystems that provide that support are tmpfs (since Linux 3.18), ext4 "
"(since Linux 3.18), XFS (since Linux 4.1), f2fs (since Linux 4.2).  btrfs "
"(since Linux 4.7), and ubifs (since Linux 4.9)."
msgstr ""

#. type: Plain text
#: man-pages/man2/rename.2:328
msgid ""
"Write permission is denied for the directory containing I<oldpath> or "
"I<newpath>, or, search permission is denied for one of the directories in "
"the path prefix of I<oldpath> or I<newpath>, or I<oldpath> is a directory "
"and does not allow write permission (needed to update the I<..> entry).  "
"(See also B<path_resolution>(7).)"
msgstr ""

#. type: Plain text
#: man-pages/man2/rename.2:345
msgid ""
"The rename fails because I<oldpath> or I<newpath> is a directory that is in "
"use by some process (perhaps as current working directory, or as root "
"directory, or because it was open for reading) or is in use by the system "
"(for example as mount point), while the system considers this an error.  "
"(Note that there is no requirement to return B<EBUSY> in such "
"cases\\(emthere is nothing wrong with doing the rename anyway\\(embut it is "
"allowed to return B<EBUSY> if the system cannot otherwise handle such "
"situations.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/rename.2:348 man-pages/man2/link.2:207
msgid "The user's quota of disk blocks on the filesystem has been exhausted."
msgstr ""

#. type: Plain text
#: man-pages/man2/rename.2:351 man-pages/man2/link.2:214
msgid "I<oldpath> or I<newpath> points outside your accessible address space."
msgstr ""

#. type: Plain text
#: man-pages/man2/rename.2:355
msgid ""
"The new pathname contained a path prefix of the old, or, more generally, an "
"attempt was made to make a directory a subdirectory of itself."
msgstr ""

#. type: Plain text
#: man-pages/man2/rename.2:361
msgid "I<newpath> is an existing directory, but I<oldpath> is not a directory."
msgstr ""

#. type: Plain text
#: man-pages/man2/rename.2:365 man-pages/man2/link.2:221
msgid ""
"Too many symbolic links were encountered in resolving I<oldpath> or "
"I<newpath>."
msgstr ""

#. type: TP
#: man-pages/man2/rename.2:365 man-pages/man2/link.2:221
#: man-pages/man2/mkdir.2:158
#, no-wrap
msgid "B<EMLINK>"
msgstr ""

#. type: Plain text
#: man-pages/man2/rename.2:372
msgid ""
"I<oldpath> already has the maximum number of links to it, or it was a "
"directory and the directory containing I<newpath> has the maximum number of "
"links."
msgstr ""

#. type: Plain text
#: man-pages/man2/rename.2:375 man-pages/man2/link.2:236
msgid "I<oldpath> or I<newpath> was too long."
msgstr ""

#. type: Plain text
#: man-pages/man2/rename.2:388
msgid ""
"The link named by I<oldpath> does not exist; or, a directory component in "
"I<newpath> does not exist; or, I<oldpath> or I<newpath> is an empty string."
msgstr ""

#. type: Plain text
#: man-pages/man2/rename.2:395 man-pages/man2/symlink.2:194
#: man-pages/man2/link.2:248
msgid "The device containing the file has no room for the new directory entry."
msgstr ""

#. type: Plain text
#: man-pages/man2/rename.2:405
msgid ""
"A component used as a directory in I<oldpath> or I<newpath> is not, in fact, "
"a directory.  Or, I<oldpath> is a directory, and I<newpath> exists but is "
"not a directory."
msgstr ""

#. type: TP
#: man-pages/man2/rename.2:405
#, no-wrap
msgid "B<ENOTEMPTY> or B<EEXIST>"
msgstr ""

#. type: Plain text
#: man-pages/man2/rename.2:409
msgid ""
"I<newpath> is a nonempty directory, that is, contains entries other than "
"\".\" and \"..\"."
msgstr ""

#. type: TP
#: man-pages/man2/rename.2:409 man-pages/man2/unlink.2:224
#, no-wrap
msgid "B<EPERM> or B<EACCES>"
msgstr ""

#. type: Plain text
#: man-pages/man2/rename.2:433
msgid ""
"The directory containing I<oldpath> has the sticky bit (B<S_ISVTX>)  set and "
"the process's effective user ID is neither the user ID of the file to be "
"deleted nor that of the directory containing it, and the process is not "
"privileged (Linux: does not have the B<CAP_FOWNER> capability); or "
"I<newpath> is an existing file and the directory containing it has the "
"sticky bit set and the process's effective user ID is neither the user ID of "
"the file to be replaced nor that of the directory containing it, and the "
"process is not privileged (Linux: does not have the B<CAP_FOWNER> "
"capability); or the filesystem containing I<pathname> does not support "
"renaming of the type requested."
msgstr ""

#. type: Plain text
#: man-pages/man2/rename.2:436 man-pages/man2/utimensat.2:402
#: man-pages/man2/link.2:278
msgid "The file is on a read-only filesystem."
msgstr ""

#. type: TP
#: man-pages/man2/rename.2:436 man-pages/man2/ioctl_fideduperange.2:194
#: man-pages/man2/copy_file_range.2:186 man-pages/man2/ioctl_ficlonerange.2:126
#: man-pages/man2/fanotify_mark.2:433 man-pages/man2/link.2:278
#, no-wrap
msgid "B<EXDEV>"
msgstr ""

#. type: Plain text
#: man-pages/man2/rename.2:444
msgid ""
"I<oldpath> and I<newpath> are not on the same mounted filesystem.  (Linux "
"permits a filesystem to be mounted at multiple points, but B<rename>()  does "
"not work across different mount points, even if the same filesystem is "
"mounted on both.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/rename.2:449
msgid ""
"The following additional errors can occur for B<renameat>()  and "
"B<renameat2>():"
msgstr ""

#. type: Plain text
#: man-pages/man2/rename.2:455 man-pages/man2/link.2:295
msgid "I<olddirfd> or I<newdirfd> is not a valid file descriptor."
msgstr ""

#. type: Plain text
#: man-pages/man2/rename.2:465 man-pages/man2/link.2:338
msgid ""
"I<oldpath> is relative and I<olddirfd> is a file descriptor referring to a "
"file other than a directory; or similar for I<newpath> and I<newdirfd>"
msgstr ""

#. type: Plain text
#: man-pages/man2/rename.2:468
msgid "The following additional errors can occur for B<renameat2>():"
msgstr ""

#. type: Plain text
#: man-pages/man2/rename.2:476
msgid "I<flags> contains B<RENAME_NOREPLACE> and I<newpath> already exists."
msgstr ""

#. type: Plain text
#: man-pages/man2/rename.2:480 man-pages/man2/getrandom.2:167
msgid "An invalid flag was specified in I<flags>."
msgstr ""

#. type: Plain text
#: man-pages/man2/rename.2:488
msgid "Both B<RENAME_NOREPLACE> and B<RENAME_EXCHANGE> were specified in I<flags>."
msgstr ""

#. type: Plain text
#: man-pages/man2/rename.2:496
msgid "Both B<RENAME_WHITEOUT> and B<RENAME_EXCHANGE> were specified in I<flags>."
msgstr ""

#. type: Plain text
#: man-pages/man2/rename.2:500
msgid "The filesystem does not support one of the flags in I<flags>."
msgstr ""

#. type: Plain text
#: man-pages/man2/rename.2:508
msgid "I<flags> contains B<RENAME_EXCHANGE> and I<newpath> does not exist."
msgstr ""

#. type: Plain text
#: man-pages/man2/rename.2:516
msgid ""
"B<RENAME_WHITEOUT> was specified in I<flags>, but the caller does not have "
"the B<CAP_MKNOD> capability."
msgstr ""

#. type: Plain text
#: man-pages/man2/rename.2:520
msgid ""
"B<renameat>()  was added to Linux in kernel 2.6.16; library support was "
"added to glibc in version 2.4."
msgstr ""

#. type: Plain text
#: man-pages/man2/rename.2:523
msgid ""
"B<renameat2>()  was added to Linux in kernel 3.15; library support was added "
"in glibc 2.28."
msgstr ""

#. type: Plain text
#: man-pages/man2/rename.2:526
msgid "B<rename>(): 4.3BSD, C89, C99, POSIX.1-2001, POSIX.1-2008."
msgstr ""

#. type: Plain text
#: man-pages/man2/rename.2:529
msgid "B<renameat>(): POSIX.1-2008."
msgstr ""

#. type: Plain text
#: man-pages/man2/rename.2:532
msgid "B<renameat2>()  is Linux-specific."
msgstr ""

#. type: SS
#: man-pages/man2/rename.2:534 man-pages/man2/access.2:353
#: man-pages/man2/chmod.2:367 man-pages/man2/unlink.2:287
#: man-pages/man2/symlink.2:250 man-pages/man2/chown.2:387
#: man-pages/man2/futimesat.2:120 man-pages/man2/link.2:398
#: man-pages/man2/readlink.2:262 man-pages/man2/mkdir.2:229
#, no-wrap
msgid "Glibc notes"
msgstr ""

#. type: Plain text
#: man-pages/man2/rename.2:551
msgid ""
"On older kernels where B<renameat>()  is unavailable, the glibc wrapper "
"function falls back to the use of B<rename>().  When I<oldpath> and "
"I<newpath> are relative pathnames, glibc constructs pathnames based on the "
"symbolic links in I</proc/self/fd> that correspond to the I<olddirfd> and "
"I<newdirfd> arguments."
msgstr ""

#. type: Plain text
#: man-pages/man2/rename.2:562
msgid ""
"On NFS filesystems, you can not assume that if the operation failed, the "
"file was not renamed.  If the server does the rename operation and then "
"crashes, the retransmitted RPC which will be processed when the server is up "
"again causes a failure.  The application is expected to deal with this.  See "
"B<link>(2)  for a similar problem."
msgstr ""

#. type: Plain text
#: man-pages/man2/rename.2:569
msgid ""
"B<mv>(1), B<chmod>(2), B<link>(2), B<symlink>(2), B<unlink>(2), "
"B<path_resolution>(7), B<symlink>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/outb.2:26
#, no-wrap
msgid "OUTB"
msgstr ""

#. type: Plain text
#: man-pages/man2/outb.2:31
msgid ""
"outb, outw, outl, outsb, outsw, outsl, inb, inw, inl, insb, insw, insl, "
"outb_p, outw_p, outl_p, inb_p, inw_p, inl_p - port I/O"
msgstr ""

#. type: Plain text
#: man-pages/man2/outb.2:34
#, no-wrap
msgid "B<#include E<lt>sys/io.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/outb.2:41
#, no-wrap
msgid ""
"B<unsigned char inb(unsigned short int >I<port>B<);>\n"
"B<unsigned char inb_p(unsigned short int >I<port>B<);>\n"
"B<unsigned short int inw(unsigned short int >I<port>B<);>\n"
"B<unsigned short int inw_p(unsigned short int >I<port>B<);>\n"
"B<unsigned int inl(unsigned short int >I<port>B<);>\n"
"B<unsigned int inl_p(unsigned short int >I<port>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/outb.2:48
#, no-wrap
msgid ""
"B<void outb(unsigned char >I<value>B<, unsigned short int >I<port>B<);>\n"
"B<void outb_p(unsigned char >I<value>B<, unsigned short int >I<port>B<);>\n"
"B<void outw(unsigned short int >I<value>B<, unsigned short int "
">I<port>B<);>\n"
"B<void outw_p(unsigned short int >I<value>B<, unsigned short int "
">I<port>B<);>\n"
"B<void outl(unsigned int >I<value>B<, unsigned short int >I<port>B<);>\n"
"B<void outl_p(unsigned int >I<value>B<, unsigned short int >I<port>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/outb.2:61
#, no-wrap
msgid ""
"B<void insb(unsigned short int >I<port>B<, void *>I<addr>B<,>\n"
"B<           unsigned long int >I<count>B<);>\n"
"B<void insw(unsigned short int >I<port>B<, void *>I<addr>B<,>\n"
"B<           unsigned long int >I<count>B<);>\n"
"B<void insl(unsigned short int >I<port>B<, void *>I<addr>B<,>\n"
"B<           unsigned long int >I<count>B<);>\n"
"B<void outsb(unsigned short int >I<port>B<, const void *>I<addr>B<,>\n"
"B<           unsigned long int >I<count>B<);>\n"
"B<void outsw(unsigned short int >I<port>B<, const void *>I<addr>B<,>\n"
"B<           unsigned long int >I<count>B<);>\n"
"B<void outsl(unsigned short int >I<port>B<, const void *>I<addr>B<,>\n"
"B<           unsigned long int >I<count>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/outb.2:67
msgid ""
"This family of functions is used to do low-level port input and output.  The "
"out* functions do port output, the in* functions do port input; the b-suffix "
"functions are byte-width and the w-suffix functions word-width; the "
"_p-suffix functions pause until the I/O completes."
msgstr ""

#.  , given the following information
#.  in addition to that given in
#.  .BR outb (9).
#. type: Plain text
#: man-pages/man2/outb.2:73
msgid ""
"They are primarily designed for internal kernel use, but can be used from "
"user space."
msgstr ""

#. type: Plain text
#: man-pages/man2/outb.2:78
msgid ""
"You must compile with B<-O> or B<-O2> or similar.  The functions are defined "
"as inline macros, and will not be substituted in without optimization "
"enabled, causing unresolved references at link time."
msgstr ""

#. type: Plain text
#: man-pages/man2/outb.2:87
msgid ""
"You use B<ioperm>(2)  or alternatively B<iopl>(2)  to tell the kernel to "
"allow the user space application to access the I/O ports in question.  "
"Failure to do this will cause the application to receive a segmentation "
"fault."
msgstr ""

#. type: Plain text
#: man-pages/man2/outb.2:96
msgid ""
"B<outb>()  and friends are hardware-specific.  The I<value> argument is "
"passed first and the I<port> argument is passed second, which is the "
"opposite order from most DOS implementations."
msgstr ""

#. type: Plain text
#: man-pages/man2/outb.2:98
msgid "B<ioperm>(2), B<iopl>(2)"
msgstr ""

#. type: TH
#: man-pages/man2/shutdown.2:40
#, no-wrap
msgid "SHUTDOWN"
msgstr ""

#. type: Plain text
#: man-pages/man2/shutdown.2:43
msgid "shutdown - shut down part of a full-duplex connection"
msgstr ""

#. type: Plain text
#: man-pages/man2/shutdown.2:47
msgid "B<int shutdown(int >I<sockfd>B<, int >I<how>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/shutdown.2:69
msgid ""
"The B<shutdown>()  call causes all or part of a full-duplex connection on "
"the socket associated with I<sockfd> to be shut down.  If I<how> is "
"B<SHUT_RD>, further receptions will be disallowed.  If I<how> is B<SHUT_WR>, "
"further transmissions will be disallowed.  If I<how> is B<SHUT_RDWR>, "
"further receptions and transmissions will be disallowed."
msgstr ""

#. type: Plain text
#: man-pages/man2/shutdown.2:84
msgid "An invalid value was specified in I<how> (but see BUGS)."
msgstr ""

#. type: TP
#: man-pages/man2/shutdown.2:84 man-pages/man2/send.2:401
#: man-pages/man2/getpeername.2:93 man-pages/man2/recv.2:486
#, no-wrap
msgid "B<ENOTCONN>"
msgstr ""

#. type: Plain text
#: man-pages/man2/shutdown.2:87
msgid "The specified socket is not connected."
msgstr ""

#. type: Plain text
#: man-pages/man2/shutdown.2:96
msgid ""
"POSIX.1-2001, POSIX.1-2008, 4.4BSD (B<shutdown>()  first appeared in "
"4.2BSD)."
msgstr ""

#. type: Plain text
#: man-pages/man2/shutdown.2:105
msgid ""
"The constants B<SHUT_RD>, B<SHUT_WR>, B<SHUT_RDWR> have the value 0, 1, 2, "
"respectively, and are defined in I<E<lt>sys/socket.hE<gt>> since "
"glibc-2.1.91."
msgstr ""

#.  https://bugzilla.kernel.org/show_bug.cgi?id=47111
#.  commit fc61b928dc4d72176cf4bd4d30bf1d22e599aefc
#.  and for DECnet sockets in commit 46b66d7077b89fb4917ceef19b3f7dd86055c94a
#. type: Plain text
#: man-pages/man2/shutdown.2:116
msgid ""
"Checks for the validity of I<how> are done in domain-specific code, and "
"before Linux 3.7 not all domains performed these checks.  Most notably, UNIX "
"domain sockets simply ignored invalid values.  This problem was fixed for "
"UNIX domain sockets in Linux 3.7."
msgstr ""

#. type: Plain text
#: man-pages/man2/shutdown.2:120
msgid "B<close>(2), B<connect>(2), B<socket>(2), B<socket>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/recvmmsg.2:31
#, no-wrap
msgid "RECVMMSG"
msgstr ""

#. type: Plain text
#: man-pages/man2/recvmmsg.2:34
msgid "recvmmsg - receive multiple messages on a socket"
msgstr ""

#. type: Plain text
#: man-pages/man2/recvmmsg.2:38 man-pages/man2/sendmmsg.2:35
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>         /* See feature_test_macros(7) */\n"
"B<#include E<lt>sys/socket.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/recvmmsg.2:42
#, no-wrap
msgid ""
"B<int recvmmsg(int >I<sockfd>B<, struct mmsghdr *>I<msgvec>B<, unsigned int "
">I<vlen>B<,>\n"
"B<             int >I<flags>B<, struct timespec *>I<timeout>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/recvmmsg.2:54
msgid ""
"The B<recvmmsg>()  system call is an extension of B<recvmsg>(2)  that allows "
"the caller to receive multiple messages from a socket using a single system "
"call.  (This has performance benefits for some applications.)  A further "
"extension over B<recvmsg>(2)  is support for a timeout on the receive "
"operation."
msgstr ""

#. type: Plain text
#: man-pages/man2/recvmmsg.2:58
msgid ""
"The I<sockfd> argument is the file descriptor of the socket to receive data "
"from."
msgstr ""

#. type: Plain text
#: man-pages/man2/recvmmsg.2:66 man-pages/man2/sendmmsg.2:62
msgid ""
"The I<msgvec> argument is a pointer to an array of I<mmsghdr> structures.  "
"The size of this array is specified in I<vlen>."
msgstr ""

#. type: Plain text
#: man-pages/man2/recvmmsg.2:72 man-pages/man2/sendmmsg.2:68
msgid "The I<mmsghdr> structure is defined in I<E<lt>sys/socket.hE<gt>> as:"
msgstr ""

#. type: Plain text
#: man-pages/man2/recvmmsg.2:79
#, no-wrap
msgid ""
"struct mmsghdr {\n"
"    struct msghdr msg_hdr;  /* Message header */\n"
"    unsigned int  msg_len;  /* Number of received bytes for header */\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/recvmmsg.2:94
msgid ""
"The I<msg_hdr> field is a I<msghdr> structure, as described in "
"B<recvmsg>(2).  The I<msg_len> field is the number of bytes returned for the "
"message in the entry.  This field has the same value as the return value of "
"a single B<recvmsg>(2)  on the header."
msgstr ""

#. type: Plain text
#: man-pages/man2/recvmmsg.2:101
msgid ""
"The I<flags> argument contains flags ORed together.  The flags are the same "
"as documented for B<recvmsg>(2), with the following addition:"
msgstr ""

#. type: TP
#: man-pages/man2/recvmmsg.2:101
#, no-wrap
msgid "B<MSG_WAITFORONE> (since Linux 2.6.34)"
msgstr ""

#. type: Plain text
#: man-pages/man2/recvmmsg.2:106
msgid "Turns on B<MSG_DONTWAIT> after the first message has been received."
msgstr ""

#. type: Plain text
#: man-pages/man2/recvmmsg.2:121
msgid ""
"The I<timeout> argument points to a I<struct timespec> (see "
"B<clock_gettime>(2))  defining a timeout (seconds plus nanoseconds) for the "
"receive operation (I<but see BUGS!>).  (This interval will be rounded up to "
"the system clock granularity, and kernel scheduling delays mean that the "
"blocking interval may overrun by a small amount.)  If I<timeout> is NULL, "
"then the operation blocks indefinitely."
msgstr ""

#. type: Plain text
#: man-pages/man2/recvmmsg.2:132
msgid ""
"A blocking B<recvmmsg>()  call blocks until I<vlen> messages have been "
"received or until the timeout expires.  A nonblocking call reads as many "
"messages as are available (up to the limit specified by I<vlen>)  and "
"returns immediately."
msgstr ""

#. type: Plain text
#: man-pages/man2/recvmmsg.2:147
msgid ""
"On return from B<recvmmsg>(), successive elements of I<msgvec> are updated "
"to contain information about each received message: I<msg_len> contains the "
"size of the received message; the subfields of I<msg_hdr> are updated as "
"described in B<recvmsg>(2).  The return value of the call indicates the "
"number of elements of I<msgvec> that have been updated."
msgstr ""

#. type: Plain text
#: man-pages/man2/recvmmsg.2:155
msgid ""
"On success, B<recvmmsg>()  returns the number of messages received in "
"I<msgvec>; on error, -1 is returned, and I<errno> is set to indicate the "
"error."
msgstr ""

#. type: Plain text
#: man-pages/man2/recvmmsg.2:159
msgid ""
"Errors are as for B<recvmsg>(2).  In addition, the following error can "
"occur:"
msgstr ""

#. type: Plain text
#: man-pages/man2/recvmmsg.2:163
msgid "I<timeout> is invalid."
msgstr ""

#. type: Plain text
#: man-pages/man2/recvmmsg.2:165
msgid "See also BUGS."
msgstr ""

#. type: Plain text
#: man-pages/man2/recvmmsg.2:170
msgid ""
"The B<recvmmsg>()  system call was added in Linux 2.6.33.  Support in glibc "
"was added in version 2.12."
msgstr ""

#. type: Plain text
#: man-pages/man2/recvmmsg.2:173
msgid "B<recvmmsg>()  is Linux-specific."
msgstr ""

#.  FIXME . https://bugzilla.kernel.org/show_bug.cgi?id=75371
#.  http://thread.gmane.org/gmane.linux.man/5677
#. type: Plain text
#: man-pages/man2/recvmmsg.2:184
msgid ""
"The I<timeout> argument does not work as intended.  The timeout is checked "
"only after the receipt of each datagram, so that if up to I<vlen-1> "
"datagrams are received before the timeout expires, but then no further "
"datagrams are received, the call will block forever."
msgstr ""

#. type: Plain text
#: man-pages/man2/recvmmsg.2:192
msgid ""
"If an error occurs after at least one message has been received, the call "
"succeeds, and returns the number of messages received.  The error code is "
"expected to be returned on a subsequent call to B<recvmmsg>().  In the "
"current implementation, however, the error code can be overwritten in the "
"meantime by an unrelated network event on a socket, for example an incoming "
"ICMP packet."
msgstr ""

#. type: Plain text
#: man-pages/man2/recvmmsg.2:200
msgid ""
"The following program uses B<recvmmsg>()  to receive multiple messages on a "
"socket and stores them in multiple buffers.  The call returns if all buffers "
"are filled or if the timeout specified has expired."
msgstr ""

#. type: Plain text
#: man-pages/man2/recvmmsg.2:203
msgid ""
"The following snippet periodically generates UDP datagrams containing a "
"random number:"
msgstr ""

#. type: Plain text
#: man-pages/man2/recvmmsg.2:208
#, no-wrap
msgid ""
"$B< while true; do echo $RANDOM E<gt> /dev/udp/127.0.0.1/1234; >\n"
"B<sleep 0.25; done>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/recvmmsg.2:213
msgid ""
"These datagrams are read by the example application, which can give the "
"following output:"
msgstr ""

#. type: Plain text
#: man-pages/man2/recvmmsg.2:223
#, no-wrap
msgid ""
"$B< ./a.out>\n"
"5 messages received\n"
"1 11782\n"
"2 11345\n"
"3 304\n"
"4 13514\n"
"5 28421\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/recvmmsg.2:234
#, no-wrap
msgid ""
"#define _GNU_SOURCE\n"
"#include E<lt>netinet/ip.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>sys/socket.hE<gt>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/recvmmsg.2:247
#, no-wrap
msgid ""
"int\n"
"main(void)\n"
"{\n"
"#define VLEN 10\n"
"#define BUFSIZE 200\n"
"#define TIMEOUT 1\n"
"    int sockfd, retval, i;\n"
"    struct sockaddr_in addr;\n"
"    struct mmsghdr msgs[VLEN];\n"
"    struct iovec iovecs[VLEN];\n"
"    char bufs[VLEN][BUFSIZE+1];\n"
"    struct timespec timeout;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/recvmmsg.2:253 man-pages/man2/sendmmsg.2:210
#, no-wrap
msgid ""
"    sockfd = socket(AF_INET, SOCK_DGRAM, 0);\n"
"    if (sockfd == -1) {\n"
"        perror(\"socket()\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/recvmmsg.2:261
#, no-wrap
msgid ""
"    addr.sin_family = AF_INET;\n"
"    addr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);\n"
"    addr.sin_port = htons(1234);\n"
"    if (bind(sockfd, (struct sockaddr *) &addr, sizeof(addr)) == -1) {\n"
"        perror(\"bind()\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/recvmmsg.2:269
#, no-wrap
msgid ""
"    memset(msgs, 0, sizeof(msgs));\n"
"    for (i = 0; i E<lt> VLEN; i++) {\n"
"        iovecs[i].iov_base         = bufs[i];\n"
"        iovecs[i].iov_len          = BUFSIZE;\n"
"        msgs[i].msg_hdr.msg_iov    = &iovecs[i];\n"
"        msgs[i].msg_hdr.msg_iovlen = 1;\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/recvmmsg.2:272
#, no-wrap
msgid ""
"    timeout.tv_sec = TIMEOUT;\n"
"    timeout.tv_nsec = 0;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/recvmmsg.2:278
#, no-wrap
msgid ""
"    retval = recvmmsg(sockfd, msgs, VLEN, 0, &timeout);\n"
"    if (retval == -1) {\n"
"        perror(\"recvmmsg()\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/recvmmsg.2:286
#, no-wrap
msgid ""
"    printf(\"%d messages received\\en\", retval);\n"
"    for (i = 0; i E<lt> retval; i++) {\n"
"        bufs[i][msgs[i].msg_len] = 0;\n"
"        printf(\"%d %s\", i+1, bufs[i]);\n"
"    }\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/recvmmsg.2:293
msgid ""
"B<clock_gettime>(2), B<recvmsg>(2), B<sendmmsg>(2), B<sendmsg>(2), "
"B<socket>(2), B<socket>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/io_getevents.2:7
#, no-wrap
msgid "IO_GETEVENTS"
msgstr ""

#. type: Plain text
#: man-pages/man2/io_getevents.2:10
msgid "io_getevents - read asynchronous I/O events from the completion queue"
msgstr ""

#. type: Plain text
#: man-pages/man2/io_getevents.2:14
#, no-wrap
msgid ""
"B<#include E<lt>linux/aio_abi.hE<gt>>         /* Defines needed types */\n"
"B<#include E<lt>linux/time.hE<gt>>            /* Defines 'struct timespec' "
"*/\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/io_getevents.2:18
#, no-wrap
msgid ""
"B<int io_getevents(aio_context_t >I<ctx_id>B<, long >I<min_nr>B<, long "
">I<nr>B<,>\n"
"B<                 struct io_event *>I<events>B<, struct timespec "
"*>I<timeout>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/io_getevents.2:30
msgid ""
"The B<io_getevents>()  system call attempts to read at least I<min_nr> "
"events and up to I<nr> events from the completion queue of the AIO context "
"specified by I<ctx_id>."
msgstr ""

#. type: Plain text
#: man-pages/man2/io_getevents.2:33
msgid ""
"The I<timeout> argument specifies the amount of time to wait for events, and "
"is specified as a relative timeout in a structure of the following form:"
msgstr ""

#. type: Plain text
#: man-pages/man2/io_getevents.2:40
#, no-wrap
msgid ""
"struct timespec {\n"
"    time_t tv_sec;      /* seconds */\n"
"    long   tv_nsec;     /* nanoseconds [0 .. 999999999] */\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/io_getevents.2:45
msgid ""
"The specified time will be rounded up to the system clock granularity and is "
"guaranteed not to expire early."
msgstr ""

#. type: Plain text
#: man-pages/man2/io_getevents.2:51
msgid ""
"Specifying I<timeout> as NULL means block indefinitely until at least "
"I<min_nr> events have been obtained."
msgstr ""

#. type: Plain text
#: man-pages/man2/io_getevents.2:63
msgid ""
"On success, B<io_getevents>()  returns the number of events read.  This may "
"be 0, or a value less than I<min_nr>, if the I<timeout> expired.  It may "
"also be a nonzero value less than I<min_nr>, if the call was interrupted by "
"a signal handler."
msgstr ""

#. type: Plain text
#: man-pages/man2/io_getevents.2:65
msgid "For the failure return, see NOTES."
msgstr ""

#. type: Plain text
#: man-pages/man2/io_getevents.2:69
msgid "Either I<events> or I<timeout> is an invalid pointer."
msgstr ""

#. type: Plain text
#: man-pages/man2/io_getevents.2:73
msgid "Interrupted by a signal handler; see B<signal>(7)."
msgstr ""

#. type: Plain text
#: man-pages/man2/io_getevents.2:78
msgid "I<ctx_id> is invalid.  I<min_nr> is out of range or I<nr> is out of range."
msgstr ""

#. type: Plain text
#: man-pages/man2/io_getevents.2:82
msgid "B<io_getevents>()  is not implemented on this architecture."
msgstr ""

#. type: Plain text
#: man-pages/man2/io_getevents.2:90
msgid ""
"B<io_getevents>()  is Linux-specific and should not be used in programs that "
"are intended to be portable."
msgstr ""

#.  http://git.fedorahosted.org/git/?p=libaio.git
#. type: Plain text
#: man-pages/man2/io_getevents.2:99
msgid ""
"Glibc does not provide a wrapper function for this system call.  You could "
"invoke it using B<syscall>(2).  But instead, you probably want to use the "
"B<io_getevents>()  wrapper function provided by I<libaio>."
msgstr ""

#. type: Plain text
#: man-pages/man2/io_getevents.2:125
msgid ""
"An invalid I<ctx_id> may cause a segmentation fault instead of generating "
"the error B<EINVAL>."
msgstr ""

#. type: Plain text
#: man-pages/man2/io_getevents.2:132
msgid ""
"B<io_cancel>(2), B<io_destroy>(2), B<io_setup>(2), B<io_submit>(2), "
"B<aio>(7), B<time>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/truncate.2:43
#, no-wrap
msgid "TRUNCATE"
msgstr ""

#. type: Plain text
#: man-pages/man2/truncate.2:46
msgid "truncate, ftruncate - truncate a file to a specified length"
msgstr ""

#. type: Plain text
#: man-pages/man2/truncate.2:52
msgid "B<int truncate(const char *>I<path>B<, off_t >I<length>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/truncate.2:54
msgid "B<int ftruncate(int >I<fd>B<, off_t >I<length>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/truncate.2:62
msgid "B<truncate>():"
msgstr ""

#. type: Plain text
#: man-pages/man2/truncate.2:65 man-pages/man2/getsid.2:48
#: man-pages/man2/setpgid.2:80 man-pages/man2/pread.2:48
msgid "_XOPEN_SOURCE\\ E<gt>=\\ 500"
msgstr ""

#. type: Plain text
#: man-pages/man2/truncate.2:68
#, no-wrap
msgid ""
"    || /* Since glibc 2.12: */ _POSIX_C_SOURCE\\ E<gt>=\\ 200809L\n"
"    || /* Glibc versions E<lt>= 2.19: */ _BSD_SOURCE\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/truncate.2:71
msgid "B<ftruncate>():"
msgstr ""

#.     || _XOPEN_SOURCE\ &&\ _XOPEN_SOURCE_EXTENDED
#. type: Plain text
#: man-pages/man2/truncate.2:76
#, no-wrap
msgid ""
"_XOPEN_SOURCE\\ E<gt>=\\ 500\n"
"    || /* Since glibc 2.3.5: */ _POSIX_C_SOURCE\\ E<gt>=\\ 200112L\n"
"    || /* Glibc versions E<lt>= 2.19: */ _BSD_SOURCE\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/truncate.2:90
msgid ""
"The B<truncate>()  and B<ftruncate>()  functions cause the regular file "
"named by I<path> or referenced by I<fd> to be truncated to a size of "
"precisely I<length> bytes."
msgstr ""

#. type: Plain text
#: man-pages/man2/truncate.2:94
msgid ""
"If the file previously was larger than this size, the extra data is lost.  "
"If the file previously was shorter, it is extended, and the extended part "
"reads as null bytes (\\(aq\\e0\\(aq)."
msgstr ""

#. type: Plain text
#: man-pages/man2/truncate.2:96
msgid "The file offset is not changed."
msgstr ""

#. type: Plain text
#: man-pages/man2/truncate.2:103
msgid ""
"If the size changed, then the st_ctime and st_mtime fields (respectively, "
"time of last status change and time of last modification; see B<inode>(7))  "
"for the file are updated, and the set-user-ID and set-group-ID mode bits may "
"be cleared."
msgstr ""

#. type: Plain text
#: man-pages/man2/truncate.2:109
msgid ""
"With B<ftruncate>(), the file must be open for writing; with B<truncate>(), "
"the file must be writable."
msgstr ""

#. type: Plain text
#: man-pages/man2/truncate.2:117
msgid "For B<truncate>():"
msgstr ""

#. type: Plain text
#: man-pages/man2/truncate.2:123
msgid ""
"Search permission is denied for a component of the path prefix, or the named "
"file is not writable by the user.  (See also B<path_resolution>(7).)"
msgstr ""

#. type: Plain text
#: man-pages/man2/truncate.2:128
msgid "The argument I<path> points outside the process's allocated address space."
msgstr ""

#. type: Plain text
#: man-pages/man2/truncate.2:133
msgid "The argument I<length> is larger than the maximum file size. (XSI)"
msgstr ""

#. type: Plain text
#: man-pages/man2/truncate.2:140
msgid ""
"While blocked waiting to complete, the call was interrupted by a signal "
"handler; see B<fcntl>(2)  and B<signal>(7)."
msgstr ""

#. type: Plain text
#: man-pages/man2/truncate.2:145
msgid "The argument I<length> is negative or larger than the maximum file size."
msgstr ""

#. type: Plain text
#: man-pages/man2/truncate.2:148
msgid "An I/O error occurred updating the inode."
msgstr ""

#. type: Plain text
#: man-pages/man2/truncate.2:151
msgid "The named file is a directory."
msgstr ""

#. type: Plain text
#: man-pages/man2/truncate.2:154 man-pages/man2/readlink.2:193
msgid "Too many symbolic links were encountered in translating the pathname."
msgstr ""

#. type: Plain text
#: man-pages/man2/truncate.2:158
msgid ""
"A component of a pathname exceeded 255 characters, or an entire pathname "
"exceeded 1023 characters."
msgstr ""

#. type: Plain text
#: man-pages/man2/truncate.2:161 man-pages/man2/readlink.2:199
msgid "The named file does not exist."
msgstr ""

#.  This happens for at least MSDOS and VFAT filesystems
#.  on kernel 2.6.13
#. type: Plain text
#: man-pages/man2/truncate.2:170
msgid ""
"The underlying filesystem does not support extending a file beyond its "
"current size."
msgstr ""

#. type: Plain text
#: man-pages/man2/truncate.2:177 man-pages/man2/chmod.2:300
#: man-pages/man2/chown.2:275
msgid "The named file resides on a read-only filesystem."
msgstr ""

#. type: Plain text
#: man-pages/man2/truncate.2:180
msgid "The file is an executable file that is being executed."
msgstr ""

#. type: Plain text
#: man-pages/man2/truncate.2:187
msgid ""
"For B<ftruncate>()  the same errors apply, but instead of things that can be "
"wrong with I<path>, we now have things that can be wrong with the file "
"descriptor, I<fd>:"
msgstr ""

#. type: Plain text
#: man-pages/man2/truncate.2:191 man-pages/man2/inotify_rm_watch.2:60
#: man-pages/man2/ioctl.2:99 man-pages/man2/chdir.2:127
#: man-pages/man2/sync_file_range.2:152 man-pages/man2/spu_run.2:158
#: man-pages/man2/timerfd_create.2:439 man-pages/man2/setns.2:201
#: man-pages/man2/sync.2:94
msgid "I<fd> is not a valid file descriptor."
msgstr ""

#. type: TP
#: man-pages/man2/truncate.2:191
#, no-wrap
msgid "B<EBADF> or B<EINVAL>"
msgstr ""

#. type: Plain text
#: man-pages/man2/truncate.2:195
msgid "I<fd> is not open for writing."
msgstr ""

#. type: Plain text
#: man-pages/man2/truncate.2:199
msgid "I<fd> does not reference a regular file or a POSIX shared memory object."
msgstr ""

#. type: TP
#: man-pages/man2/truncate.2:199
#, no-wrap
msgid "B<EINVAL> or B<EBADF>"
msgstr ""

#. type: Plain text
#: man-pages/man2/truncate.2:208
msgid ""
"The file descriptor I<fd> is not open for writing.  POSIX permits, and "
"portable applications should handle, either error for this case.  (Linux "
"produces B<EINVAL>.)"
msgstr ""

#.  POSIX.1-1996 has
#.  .BR ftruncate ().
#.  POSIX.1-2001 also has
#.  .BR truncate (),
#.  as an XSI extension.
#.  .LP
#.  SVr4 documents additional
#.  .BR truncate ()
#.  error conditions EMFILE, EMULTIHP, ENFILE, ENOLINK.  SVr4 documents for
#.  .BR ftruncate ()
#.  an additional EAGAIN error condition.
#. type: Plain text
#: man-pages/man2/truncate.2:222
msgid ""
"POSIX.1-2001, POSIX.1-2008, 4.4BSD, SVr4 (these calls first appeared in "
"4.2BSD)."
msgstr ""

#. type: Plain text
#: man-pages/man2/truncate.2:226
msgid ""
"B<ftruncate>()  can also be used to set the size of a POSIX shared memory "
"object; see B<shm_open>(7)."
msgstr ""

#.  At the very least: OSF/1, Solaris 7, and FreeBSD conform, mtk, Jan 2002
#. type: Plain text
#: man-pages/man2/truncate.2:247
msgid ""
"The details in DESCRIPTION are for XSI-compliant systems.  For "
"non-XSI-compliant systems, the POSIX standard allows two behaviors for "
"B<ftruncate>()  when I<length> exceeds the file length (note that "
"B<truncate>()  is not specified at all in such an environment): either "
"returning an error, or extending the file.  Like most UNIX implementations, "
"Linux follows the XSI requirement when dealing with native filesystems.  "
"However, some nonnative filesystems do not permit B<truncate>()  and "
"B<ftruncate>()  to be used to extend a file beyond its current length: a "
"notable example on Linux is VFAT."
msgstr ""

#. type: Plain text
#: man-pages/man2/truncate.2:261
msgid ""
"The original Linux B<truncate>()  and B<ftruncate>()  system calls were not "
"designed to handle large file offsets.  Consequently, Linux 2.4 added "
"B<truncate64>()  and B<ftruncate64>()  system calls that handle large "
"files.  However, these details can be ignored by applications using glibc, "
"whose wrapper functions transparently employ the more recent system calls "
"where they are available."
msgstr ""

#. type: Plain text
#: man-pages/man2/truncate.2:266 man-pages/man2/pread.2:155
msgid ""
"On some 32-bit architectures, the calling signature for these system calls "
"differ, for the reasons described in B<syscall>(2)."
msgstr ""

#.  http://sourceware.org/bugzilla/show_bug.cgi?id=12037
#. type: Plain text
#: man-pages/man2/truncate.2:274
msgid ""
"A header file bug in glibc 2.12 meant that the minimum value of "
"B<_POSIX_C_SOURCE> required to expose the declaration of B<ftruncate>()  was "
"200809L instead of 200112L.  This has been fixed in later glibc versions."
msgstr ""

#. type: Plain text
#: man-pages/man2/truncate.2:278
msgid "B<truncate>(1), B<open>(2), B<stat>(2), B<path_resolution>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/set_tid_address.2:25
#, no-wrap
msgid "SET_TID_ADDRESS"
msgstr ""

#. type: Plain text
#: man-pages/man2/set_tid_address.2:28
msgid "set_tid_address - set pointer to thread ID"
msgstr ""

#. type: Plain text
#: man-pages/man2/set_tid_address.2:31 man-pages/man2/set_thread_area.2:15
#: man-pages/man2/exit_group.2:31
#, no-wrap
msgid "B<#include E<lt>linux/unistd.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/set_tid_address.2:33
#, no-wrap
msgid "B<long set_tid_address(int *>I<tidptr>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/set_tid_address.2:43
msgid ""
"For each thread, the kernel maintains two attributes (addresses) called "
"I<set_child_tid> and I<clear_child_tid>.  These two attributes contain the "
"value NULL by default."
msgstr ""

#. type: TP
#: man-pages/man2/set_tid_address.2:43
#, no-wrap
msgid "I<set_child_tid>"
msgstr ""

#. type: Plain text
#: man-pages/man2/set_tid_address.2:54
msgid ""
"If a thread is started using B<clone>(2)  with the B<CLONE_CHILD_SETTID> "
"flag, I<set_child_tid> is set to the value passed in the I<ctid> argument of "
"that system call."
msgstr ""

#. type: Plain text
#: man-pages/man2/set_tid_address.2:59
msgid ""
"When I<set_child_tid> is set, the very first thing the new thread does is to "
"write its thread ID at this address."
msgstr ""

#. type: TP
#: man-pages/man2/set_tid_address.2:59
#, no-wrap
msgid "I<clear_child_tid>"
msgstr ""

#. type: Plain text
#: man-pages/man2/set_tid_address.2:70
msgid ""
"If a thread is started using B<clone>(2)  with the B<CLONE_CHILD_CLEARTID> "
"flag, I<clear_child_tid> is set to the value passed in the I<ctid> argument "
"of that system call."
msgstr ""

#. type: Plain text
#: man-pages/man2/set_tid_address.2:77
msgid ""
"The system call B<set_tid_address>()  sets the I<clear_child_tid> value for "
"the calling thread to I<tidptr>."
msgstr ""

#. type: Plain text
#: man-pages/man2/set_tid_address.2:85
msgid ""
"When a thread whose I<clear_child_tid> is not NULL terminates, then, if the "
"thread is sharing memory with other threads, then 0 is written at the "
"address specified in I<clear_child_tid> and the kernel performs the "
"following operation:"
msgstr ""

#. type: Plain text
#: man-pages/man2/set_tid_address.2:87
#, no-wrap
msgid "    futex(clear_child_tid, FUTEX_WAKE, 1, NULL, NULL, 0);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/set_tid_address.2:91
msgid ""
"The effect of this operation is to wake a single thread that is performing a "
"futex wait on the memory location.  Errors from the futex wake operation are "
"ignored."
msgstr ""

#. type: Plain text
#: man-pages/man2/set_tid_address.2:94
msgid "B<set_tid_address>()  always returns the caller's thread ID."
msgstr ""

#. type: Plain text
#: man-pages/man2/set_tid_address.2:97
msgid "B<set_tid_address>()  always succeeds."
msgstr ""

#. type: Plain text
#: man-pages/man2/set_tid_address.2:100
msgid ""
"This call is present since Linux 2.5.48.  Details as given here are valid "
"since Linux 2.5.49."
msgstr ""

#. type: Plain text
#: man-pages/man2/set_tid_address.2:105 man-pages/man2/pivot_root.2:171
#: man-pages/man2/kcmp.2:308 man-pages/man2/modify_ldt.2:175
#: man-pages/man2/subpage_prot.2:101 man-pages/man2/userfaultfd.2:457
#: man-pages/man2/perfmonctl.2:205 man-pages/man2/futex.2:1703
msgid ""
"Glibc does not provide a wrapper for this system call; call it using "
"B<syscall>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/set_tid_address.2:108
msgid "B<clone>(2), B<futex>(2), B<gettid>(2)"
msgstr ""

#. type: TH
#: man-pages/man2/swapon.2:42
#, no-wrap
msgid "SWAPON"
msgstr ""

#. type: Plain text
#: man-pages/man2/swapon.2:45
msgid "swapon, swapoff - start/stop swapping to file/device"
msgstr ""

#. type: Plain text
#: man-pages/man2/swapon.2:49
msgid "B<#include E<lt>sys/swap.hE<gt>>"
msgstr ""

#. type: Plain text
#: man-pages/man2/swapon.2:51
msgid "B<int swapon(const char *>I<path>B<, int >I<swapflags>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/swapon.2:53
msgid "B<int swapoff(const char *>I<path>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/swapon.2:60
msgid ""
"B<swapon>()  sets the swap area to the file or block device specified by "
"I<path>.  B<swapoff>()  stops swapping to the file or block device specified "
"by I<path>."
msgstr ""

#. type: Plain text
#: man-pages/man2/swapon.2:70
msgid ""
"If the B<SWAP_FLAG_PREFER> flag is specified in the B<swapon>()  "
"I<swapflags> argument, the new swap area will have a higher priority than "
"default.  The priority is encoded within I<swapflags> as:"
msgstr ""

#. type: Plain text
#: man-pages/man2/swapon.2:74
#, no-wrap
msgid "I<(prio E<lt>E<lt> SWAP_FLAG_PRIO_SHIFT) & SWAP_FLAG_PRIO_MASK>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/swapon.2:87
msgid ""
"If the B<SWAP_FLAG_DISCARD> flag is specified in the B<swapon>()  "
"I<swapflags> argument, freed swap pages will be discarded before they are "
"reused, if the swap device supports the discard or trim operation.  (This "
"may improve performance on some Solid State Devices, but often it does not.)  "
"See also NOTES."
msgstr ""

#. type: Plain text
#: man-pages/man2/swapon.2:91
msgid ""
"These functions may be used only by a privileged process (one having the "
"B<CAP_SYS_ADMIN> capability)."
msgstr ""

#. type: SS
#: man-pages/man2/swapon.2:91
#, no-wrap
msgid "Priority"
msgstr ""

#. type: Plain text
#: man-pages/man2/swapon.2:96
msgid ""
"Each swap area has a priority, either high or low.  The default priority is "
"low.  Within the low-priority areas, newer areas are even lower priority "
"than older areas."
msgstr ""

#. type: Plain text
#: man-pages/man2/swapon.2:102
msgid ""
"All priorities set with I<swapflags> are high-priority, higher than "
"default.  They may have any nonnegative value chosen by the caller.  Higher "
"numbers mean higher priority."
msgstr ""

#. type: Plain text
#: man-pages/man2/swapon.2:110
msgid ""
"Swap pages are allocated from areas in priority order, highest priority "
"first.  For areas with different priorities, a higher-priority area is "
"exhausted before using a lower-priority area.  If two or more areas have the "
"same priority, and it is the highest priority available, pages are allocated "
"on a round-robin basis between them."
msgstr ""

#. type: Plain text
#: man-pages/man2/swapon.2:113
msgid ""
"As of Linux 1.3.6, the kernel usually follows these rules, but there are "
"exceptions."
msgstr ""

#. type: Plain text
#: man-pages/man2/swapon.2:126
msgid ""
"(for B<swapon>())  The specified I<path> is already being used as a swap "
"area."
msgstr ""

#. type: Plain text
#: man-pages/man2/swapon.2:131
msgid ""
"The file I<path> exists, but refers neither to a regular file nor to a block "
"device;"
msgstr ""

#. type: Plain text
#: man-pages/man2/swapon.2:137
msgid ""
"(B<swapon>())  The indicated path does not contain a valid swap signature or "
"resides on an in-memory filesystem such as B<tmpfs>(5)."
msgstr ""

#. type: TP
#: man-pages/man2/swapon.2:137
#, no-wrap
msgid "B<EINVAL> (since Linux 3.4)"
msgstr ""

#. type: Plain text
#: man-pages/man2/swapon.2:142
msgid "(B<swapon>())  An invalid flag value was specified in I<flags>."
msgstr ""

#. type: Plain text
#: man-pages/man2/swapon.2:147
msgid "(B<swapoff>())  I<path> is not currently a swap area."
msgstr ""

#. type: Plain text
#: man-pages/man2/swapon.2:155
msgid "The file I<path> does not exist."
msgstr ""

#. type: Plain text
#: man-pages/man2/swapon.2:158
msgid "The system has insufficient memory to start swapping."
msgstr ""

#. type: Plain text
#: man-pages/man2/swapon.2:165
msgid ""
"The caller does not have the B<CAP_SYS_ADMIN> capability.  Alternatively, "
"the maximum number of swap files are already in use; see NOTES below."
msgstr ""

#. type: Plain text
#: man-pages/man2/swapon.2:171
msgid ""
"These functions are Linux-specific and should not be used in programs "
"intended to be portable.  The second I<swapflags> argument was introduced in "
"Linux 1.3.2."
msgstr ""

#. type: Plain text
#: man-pages/man2/swapon.2:174
msgid "The partition or path must be prepared with B<mkswap>(8)."
msgstr ""

#. type: Plain text
#: man-pages/man2/swapon.2:194
msgid ""
"There is an upper limit on the number of swap files that may be used, "
"defined by the kernel constant B<MAX_SWAPFILES>.  Before kernel 2.4.10, "
"B<MAX_SWAPFILES> has the value 8; since kernel 2.4.10, it has the value 32.  "
"Since kernel 2.6.18, the limit is decreased by 2 (thus: 30)  if the kernel "
"is built with the B<CONFIG_MIGRATION> option (which reserves two swap table "
"entries for the page migration features of B<mbind>(2)  and "
"B<migrate_pages>(2)).  Since kernel 2.6.32, the limit is further decreased "
"by 1 if the kernel is built with the B<CONFIG_MEMORY_FAILURE> option."
msgstr ""

#.  To be precise: 2.6.35.5
#. type: Plain text
#: man-pages/man2/swapon.2:205
msgid ""
"Discard of swap pages was introduced in kernel 2.6.29, then made conditional "
"on the B<SWAP_FLAG_DISCARD> flag in kernel 2.6.36, which still discards the "
"entire swap area when B<swapon>()  is called, even if that flag bit is not "
"set."
msgstr ""

#. type: Plain text
#: man-pages/man2/swapon.2:208
msgid "B<mkswap>(8), B<swapoff>(8), B<swapon>(8)"
msgstr ""

#. type: TH
#: man-pages/man2/open.2:51
#, no-wrap
msgid "OPEN"
msgstr ""

#. type: Plain text
#: man-pages/man2/open.2:54
msgid "open, openat, creat - open and possibly create a file"
msgstr ""

#. type: Plain text
#: man-pages/man2/open.2:59
#, no-wrap
msgid ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>sys/stat.hE<gt>>\n"
"B<#include E<lt>fcntl.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/open.2:62
#, no-wrap
msgid ""
"B<int open(const char *>I<pathname>B<, int >I<flags>B<);>\n"
"B<int open(const char *>I<pathname>B<, int >I<flags>B<, mode_t "
">I<mode>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/open.2:64
#, no-wrap
msgid "B<int creat(const char *>I<pathname>B<, mode_t >I<mode>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/open.2:68
#, no-wrap
msgid ""
"B<int openat(int >I<dirfd>B<, const char *>I<pathname>B<, int "
">I<flags>B<);>\n"
"B<int openat(int >I<dirfd>B<, const char *>I<pathname>B<, int >I<flags>B<, "
"mode_t >I<mode>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/open.2:76
msgid "B<openat>():"
msgstr ""

#. type: Plain text
#: man-pages/man2/open.2:100
msgid ""
"The B<open>()  system call opens the file specified by I<pathname>.  If the "
"specified file does not exist, it may optionally (if B<O_CREAT> is specified "
"in I<flags>)  be created by B<open>()."
msgstr ""

#. type: Plain text
#: man-pages/man2/open.2:109
msgid ""
"The return value of B<open>()  is a file descriptor, a small, nonnegative "
"integer that is used in subsequent system calls (B<read>(2), B<write>(2), "
"B<lseek>(2), B<fcntl>(2), etc.) to refer to the open file.  The file "
"descriptor returned by a successful call will be the lowest-numbered file "
"descriptor not currently open for the process."
msgstr ""

#. type: Plain text
#: man-pages/man2/open.2:121
msgid ""
"By default, the new file descriptor is set to remain open across an "
"B<execve>(2)  (i.e., the B<FD_CLOEXEC> file descriptor flag described in "
"B<fcntl>(2)  is initially disabled); the B<O_CLOEXEC> flag, described below, "
"can be used to change this default.  The file offset is set to the beginning "
"of the file (see B<lseek>(2))."
msgstr ""

#. type: Plain text
#: man-pages/man2/open.2:134
msgid ""
"A call to B<open>()  creates a new I<open file description>, an entry in the "
"system-wide table of open files.  The open file description records the file "
"offset and the file status flags (see below).  A file descriptor is a "
"reference to an open file description; this reference is unaffected if "
"I<pathname> is subsequently removed or modified to refer to a different "
"file.  For further details on open file descriptions, see NOTES."
msgstr ""

#. type: Plain text
#: man-pages/man2/open.2:142
msgid ""
"The argument I<flags> must include one of the following I<access modes>: "
"B<O_RDONLY>, B<O_WRONLY>, or B<O_RDWR>.  These request opening the file "
"read-only, write-only, or read/write, respectively."
msgstr ""

#.  SUSv4 divides the flags into:
#.  * Access mode
#.  * File creation
#.  * File status
#.  * Other (O_CLOEXEC, O_DIRECTORY, O_NOFOLLOW)
#.  though it's not clear what the difference between "other" and
#.  "File creation" flags is.  I raised an Aardvark to see if this
#.  can be clarified in SUSv4; 10 Oct 2008.
#.  http://thread.gmane.org/gmane.comp.standards.posix.austin.general/64/focus=67
#.  TC1 (balloted in 2013), resolved this, so that those three constants
#.  are also categorized" as file status flags.
#. type: Plain text
#: man-pages/man2/open.2:182
msgid ""
"In addition, zero or more file creation flags and file status flags can be "
"bitwise-I<or>'d in I<flags>.  The I<file creation flags> are B<O_CLOEXEC>, "
"B<O_CREAT>, B<O_DIRECTORY>, B<O_EXCL>, B<O_NOCTTY>, B<O_NOFOLLOW>, "
"B<O_TMPFILE>, and B<O_TRUNC>.  The I<file status flags> are all of the "
"remaining flags listed below.  The distinction between these two groups of "
"flags is that the file creation flags affect the semantics of the open "
"operation itself, while the file status flags affect the semantics of "
"subsequent I/O operations.  The file status flags can be retrieved and (in "
"some cases)  modified; see B<fcntl>(2)  for details."
msgstr ""

#. type: Plain text
#: man-pages/man2/open.2:184
msgid "The full list of file creation flags and file status flags is as follows:"
msgstr ""

#. type: TP
#: man-pages/man2/open.2:184
#, no-wrap
msgid "B<O_APPEND>"
msgstr ""

#. type: Plain text
#: man-pages/man2/open.2:194
msgid ""
"The file is opened in append mode.  Before each B<write>(2), the file offset "
"is positioned at the end of the file, as if with B<lseek>(2).  The "
"modification of the file offset and the write operation are performed as a "
"single atomic step."
msgstr ""

#.  For more background, see
#.  http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=453946
#.  http://nfs.sourceforge.net/
#. type: Plain text
#: man-pages/man2/open.2:204
msgid ""
"B<O_APPEND> may lead to corrupted files on NFS filesystems if more than one "
"process appends data to a file at once.  This is because NFS does not "
"support appending to a file, so the client kernel has to simulate it, which "
"can't be done without a race condition."
msgstr ""

#. type: TP
#: man-pages/man2/open.2:204
#, no-wrap
msgid "B<O_ASYNC>"
msgstr ""

#. type: Plain text
#: man-pages/man2/open.2:218
msgid ""
"Enable signal-driven I/O: generate a signal (B<SIGIO> by default, but this "
"can be changed via B<fcntl>(2))  when input or output becomes possible on "
"this file descriptor.  This feature is available only for terminals, "
"pseudoterminals, sockets, and (since Linux 2.6) pipes and FIFOs.  See "
"B<fcntl>(2)  for further details.  See also BUGS, below."
msgstr ""

#. type: TP
#: man-pages/man2/open.2:218
#, no-wrap
msgid "B<O_CLOEXEC> (since Linux 2.6.23)"
msgstr ""

#.  NOTE! several other man pages refer to this text
#.  FIXME . for later review when Issue 8 is one day released...
#.  POSIX proposes to fix many APIs that provide hidden FDs
#.  http://austingroupbugs.net/tag_view_page.php?tag_id=8
#.  http://austingroupbugs.net/view.php?id=368
#. type: Plain text
#: man-pages/man2/open.2:232
msgid ""
"Enable the close-on-exec flag for the new file descriptor.  Specifying this "
"flag permits a program to avoid additional B<fcntl>(2)  B<F_SETFD> "
"operations to set the B<FD_CLOEXEC> flag."
msgstr ""

#.  This flag fixes only one form of the race condition;
#.  The race can also occur with, for example, file descriptors
#.  returned by accept(), pipe(), etc.
#. type: Plain text
#: man-pages/man2/open.2:261
msgid ""
"Note that the use of this flag is essential in some multithreaded programs, "
"because using a separate B<fcntl>(2)  B<F_SETFD> operation to set the "
"B<FD_CLOEXEC> flag does not suffice to avoid race conditions where one "
"thread opens a file descriptor and attempts to set its close-on-exec flag "
"using B<fcntl>(2)  at the same time as another thread does a B<fork>(2)  "
"plus B<execve>(2).  Depending on the order of execution, the race may lead "
"to the file descriptor returned by B<open>()  being unintentionally leaked "
"to the program executed by the child process created by B<fork>(2).  (This "
"kind of race is in principle possible for any system call that creates a "
"file descriptor whose close-on-exec flag should be set, and various other "
"Linux system calls provide an equivalent of the B<O_CLOEXEC> flag to deal "
"with this problem.)"
msgstr ""

#. type: TP
#: man-pages/man2/open.2:261
#, no-wrap
msgid "B<O_CREAT>"
msgstr ""

#. type: Plain text
#: man-pages/man2/open.2:266
msgid "If I<pathname> does not exist, create it as a regular file."
msgstr ""

#. type: Plain text
#: man-pages/man2/open.2:269
msgid ""
"The owner (user ID) of the new file is set to the effective user ID of the "
"process."
msgstr ""

#.  As at 2.6.25, bsdgroups is supported by ext2, ext3, ext4, and
#.  XFS (since 2.6.14).
#. type: Plain text
#: man-pages/man2/open.2:285
msgid ""
"The group ownership (group ID) of the new file is set either to the "
"effective group ID of the process (System V semantics)  or to the group ID "
"of the parent directory (BSD semantics).  On Linux, the behavior depends on "
"whether the set-group-ID mode bit is set on the parent directory: if that "
"bit is set, then BSD semantics apply; otherwise, System V semantics apply.  "
"For some filesystems, the behavior also depends on the I<bsdgroups> and "
"I<sysvgroups> mount options described in B<mount>(8))."
msgstr ""

#. type: Plain text
#: man-pages/man2/open.2:313
msgid ""
"The I<mode> argument specifies the file mode bits be applied when a new file "
"is created.  This argument must be supplied when B<O_CREAT> or B<O_TMPFILE> "
"is specified in I<flags>; if neither B<O_CREAT> nor B<O_TMPFILE> is "
"specified, then I<mode> is ignored.  The effective mode is modified by the "
"process's I<umask> in the usual way: in the absence of a default ACL, the "
"mode of the created file is I<(mode\\ &\\ ~umask)>.  Note that this mode "
"applies only to future accesses of the newly created file; the B<open>()  "
"call that creates a read-only file may well return a read/write file "
"descriptor."
msgstr ""

#. type: Plain text
#: man-pages/man2/open.2:316
msgid "The following symbolic constants are provided for I<mode>:"
msgstr ""

#. type: TP
#: man-pages/man2/open.2:316
#, no-wrap
msgid "B<S_IRWXU>"
msgstr ""

#. type: Plain text
#: man-pages/man2/open.2:319
msgid "00700 user (file owner) has read, write, and execute permission"
msgstr ""

#. type: TP
#: man-pages/man2/open.2:319
#, no-wrap
msgid "B<S_IRUSR>"
msgstr ""

#. type: Plain text
#: man-pages/man2/open.2:322
msgid "00400 user has read permission"
msgstr ""

#. type: TP
#: man-pages/man2/open.2:322
#, no-wrap
msgid "B<S_IWUSR>"
msgstr ""

#. type: Plain text
#: man-pages/man2/open.2:325
msgid "00200 user has write permission"
msgstr ""

#. type: TP
#: man-pages/man2/open.2:325
#, no-wrap
msgid "B<S_IXUSR>"
msgstr ""

#. type: Plain text
#: man-pages/man2/open.2:328
msgid "00100 user has execute permission"
msgstr ""

#. type: TP
#: man-pages/man2/open.2:328
#, no-wrap
msgid "B<S_IRWXG>"
msgstr ""

#. type: Plain text
#: man-pages/man2/open.2:331
msgid "00070 group has read, write, and execute permission"
msgstr ""

#. type: TP
#: man-pages/man2/open.2:331
#, no-wrap
msgid "B<S_IRGRP>"
msgstr ""

#. type: Plain text
#: man-pages/man2/open.2:334
msgid "00040 group has read permission"
msgstr ""

#. type: TP
#: man-pages/man2/open.2:334
#, no-wrap
msgid "B<S_IWGRP>"
msgstr ""

#. type: Plain text
#: man-pages/man2/open.2:337
msgid "00020 group has write permission"
msgstr ""

#. type: TP
#: man-pages/man2/open.2:337
#, no-wrap
msgid "B<S_IXGRP>"
msgstr ""

#. type: Plain text
#: man-pages/man2/open.2:340
msgid "00010 group has execute permission"
msgstr ""

#. type: TP
#: man-pages/man2/open.2:340
#, no-wrap
msgid "B<S_IRWXO>"
msgstr ""

#. type: Plain text
#: man-pages/man2/open.2:343
msgid "00007 others have read, write, and execute permission"
msgstr ""

#. type: TP
#: man-pages/man2/open.2:343
#, no-wrap
msgid "B<S_IROTH>"
msgstr ""

#. type: Plain text
#: man-pages/man2/open.2:346
msgid "00004 others have read permission"
msgstr ""

#. type: TP
#: man-pages/man2/open.2:346
#, no-wrap
msgid "B<S_IWOTH>"
msgstr ""

#. type: Plain text
#: man-pages/man2/open.2:349
msgid "00002 others have write permission"
msgstr ""

#. type: TP
#: man-pages/man2/open.2:349
#, no-wrap
msgid "B<S_IXOTH>"
msgstr ""

#. type: Plain text
#: man-pages/man2/open.2:352
msgid "00001 others have execute permission"
msgstr ""

#. type: Plain text
#: man-pages/man2/open.2:359
msgid ""
"According to POSIX, the effect when other bits are set in I<mode> is "
"unspecified.  On Linux, the following bits are also honored in I<mode>:"
msgstr ""

#. type: TP
#: man-pages/man2/open.2:360
#, no-wrap
msgid "B<S_ISUID>"
msgstr ""

#. type: Plain text
#: man-pages/man2/open.2:363
msgid "0004000 set-user-ID bit"
msgstr ""

#. type: TP
#: man-pages/man2/open.2:363
#, no-wrap
msgid "B<S_ISGID>"
msgstr ""

#. type: Plain text
#: man-pages/man2/open.2:367
msgid "0002000 set-group-ID bit (see B<inode>(7))."
msgstr ""

#. type: TP
#: man-pages/man2/open.2:367
#, no-wrap
msgid "B<S_ISVTX>"
msgstr ""

#. type: Plain text
#: man-pages/man2/open.2:371
msgid "0001000 sticky bit (see B<inode>(7))."
msgstr ""

#. type: TP
#: man-pages/man2/open.2:372
#, no-wrap
msgid "B<O_DIRECT> (since Linux 2.4.10)"
msgstr ""

#. type: Plain text
#: man-pages/man2/open.2:389
msgid ""
"Try to minimize cache effects of the I/O to and from this file.  In general "
"this will degrade performance, but it is useful in special situations, such "
"as when applications do their own caching.  File I/O is done directly "
"to/from user-space buffers.  The B<O_DIRECT> flag on its own makes an effort "
"to transfer data synchronously, but does not give the guarantees of the "
"B<O_SYNC> flag that data and necessary metadata are transferred.  To "
"guarantee synchronous I/O, B<O_SYNC> must be used in addition to "
"B<O_DIRECT>.  See NOTES below for further discussion."
msgstr ""

#. type: Plain text
#: man-pages/man2/open.2:393
msgid ""
"A semantically similar (but deprecated) interface for block devices is "
"described in B<raw>(8)."
msgstr ""

#. type: TP
#: man-pages/man2/open.2:393
#, no-wrap
msgid "B<O_DIRECTORY>"
msgstr ""

#.  But see the following and its replies:
#.  http://marc.theaimsgroup.com/?t=112748702800001&r=1&w=2
#.  [PATCH] open: O_DIRECTORY and O_CREAT together should fail
#.  O_DIRECTORY | O_CREAT causes O_DIRECTORY to be ignored.
#. type: Plain text
#: man-pages/man2/open.2:405
msgid ""
"If I<pathname> is not a directory, cause the open to fail.  This flag was "
"added in kernel version 2.1.126, to avoid denial-of-service problems if "
"B<opendir>(3)  is called on a FIFO or tape device."
msgstr ""

#. type: TP
#: man-pages/man2/open.2:405
#, no-wrap
msgid "B<O_DSYNC>"
msgstr ""

#. type: Plain text
#: man-pages/man2/open.2:411
msgid ""
"Write operations on the file will complete according to the requirements of "
"synchronized I/O I<data> integrity completion."
msgstr ""

#. type: Plain text
#: man-pages/man2/open.2:423
msgid ""
"By the time B<write>(2)  (and similar)  return, the output data has been "
"transferred to the underlying hardware, along with any file metadata that "
"would be required to retrieve that data (i.e., as though each B<write>(2)  "
"was followed by a call to B<fdatasync>(2)).  I<See NOTES below>."
msgstr ""

#. type: TP
#: man-pages/man2/open.2:423
#, no-wrap
msgid "B<O_EXCL>"
msgstr ""

#. type: Plain text
#: man-pages/man2/open.2:434
msgid ""
"Ensure that this call creates the file: if this flag is specified in "
"conjunction with B<O_CREAT>, and I<pathname> already exists, then B<open>()  "
"fails with the error B<EEXIST>."
msgstr ""

#.  POSIX.1-2001 explicitly requires this behavior.
#. type: Plain text
#: man-pages/man2/open.2:442
msgid ""
"When these two flags are specified, symbolic links are not followed: if "
"I<pathname> is a symbolic link, then B<open>()  fails regardless of where "
"the symbolic link points."
msgstr ""

#. type: Plain text
#: man-pages/man2/open.2:458
msgid ""
"In general, the behavior of B<O_EXCL> is undefined if it is used without "
"B<O_CREAT>.  There is one exception: on Linux 2.6 and later, B<O_EXCL> can "
"be used without B<O_CREAT> if I<pathname> refers to a block device.  If the "
"block device is in use by the system (e.g., mounted), B<open>()  fails with "
"the error B<EBUSY>."
msgstr ""

#. type: Plain text
#: man-pages/man2/open.2:480
msgid ""
"On NFS, B<O_EXCL> is supported only when using NFSv3 or later on kernel 2.6 "
"or later.  In NFS environments where B<O_EXCL> support is not provided, "
"programs that rely on it for performing locking tasks will contain a race "
"condition.  Portable programs that want to perform atomic file locking using "
"a lockfile, and need to avoid reliance on NFS support for B<O_EXCL>, can "
"create a unique file on the same filesystem (e.g., incorporating hostname "
"and PID), and use B<link>(2)  to make a link to the lockfile.  If B<link>(2)  "
"returns 0, the lock is successful.  Otherwise, use B<stat>(2)  on the unique "
"file to check if its link count has increased to 2, in which case the lock "
"is also successful."
msgstr ""

#. type: TP
#: man-pages/man2/open.2:480 man-pages/man2/fanotify_init.2:213
#, no-wrap
msgid "B<O_LARGEFILE>"
msgstr ""

#. type: Plain text
#: man-pages/man2/open.2:502
msgid ""
"(LFS)  Allow files whose sizes cannot be represented in an I<off_t> (but can "
"be represented in an I<off64_t>)  to be opened.  The B<_LARGEFILE64_SOURCE> "
"macro must be defined (before including I<any> header files)  in order to "
"obtain this definition.  Setting the B<_FILE_OFFSET_BITS> feature test macro "
"to 64 (rather than using B<O_LARGEFILE>)  is the preferred method of "
"accessing large files on 32-bit systems (see B<feature_test_macros>(7))."
msgstr ""

#. type: TP
#: man-pages/man2/open.2:502
#, no-wrap
msgid "B<O_NOATIME> (since Linux 2.6.8)"
msgstr ""

#. type: Plain text
#: man-pages/man2/open.2:509
msgid ""
"Do not update the file last access time (I<st_atime> in the inode)  when the "
"file is B<read>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/open.2:511
msgid "This flag can be employed only if one of the following conditions is true:"
msgstr ""

#.  Strictly speaking: the filesystem UID
#. type: Plain text
#: man-pages/man2/open.2:516
msgid "The effective UID of the process matches the owner UID of the file."
msgstr ""

#. type: Plain text
#: man-pages/man2/open.2:521
msgid ""
"The calling process has the B<CAP_FOWNER> capability in its user namespace "
"and the owner UID of the file has a mapping in the namespace."
msgstr ""

#.  The O_NOATIME flag also affects the treatment of st_atime
#.  by mmap() and readdir(2), MTK, Dec 04.
#. type: Plain text
#: man-pages/man2/open.2:529
msgid ""
"This flag is intended for use by indexing or backup programs, where its use "
"can significantly reduce the amount of disk activity.  This flag may not be "
"effective on all filesystems.  One example is NFS, where the server "
"maintains the access time."
msgstr ""

#. type: TP
#: man-pages/man2/open.2:529
#, no-wrap
msgid "B<O_NOCTTY>"
msgstr ""

#. type: Plain text
#: man-pages/man2/open.2:537
msgid ""
"If I<pathname> refers to a terminal device\\(emsee B<tty>(4)\\(emit will not "
"become the process's controlling terminal even if the process does not have "
"one."
msgstr ""

#. type: TP
#: man-pages/man2/open.2:537
#, no-wrap
msgid "B<O_NOFOLLOW>"
msgstr ""

#. type: Plain text
#: man-pages/man2/open.2:548
msgid ""
"If I<pathname> is a symbolic link, then the open fails, with the error "
"B<ELOOP>.  Symbolic links in earlier components of the pathname will still "
"be followed.  (Note that the B<ELOOP> error that can occur in this case is "
"indistinguishable from the case where an open fails because there are too "
"many symbolic links found while resolving components in the prefix part of "
"the pathname.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/open.2:551
msgid ""
"This flag is a FreeBSD extension, which was added to Linux in version "
"2.1.126, and has subsequently been standardized in POSIX.1-2008."
msgstr ""

#.  The headers from glibc 2.0.100 and later include a
#.  definition of this flag; \fIkernels before 2.1.126 will ignore it if
#.  used\fP.
#. type: Plain text
#: man-pages/man2/open.2:558
msgid "See also B<O_PATH> below."
msgstr ""

#. type: TP
#: man-pages/man2/open.2:558
#, no-wrap
msgid "B<O_NONBLOCK> or B<O_NDELAY>"
msgstr ""

#. type: Plain text
#: man-pages/man2/open.2:565
msgid ""
"When possible, the file is opened in nonblocking mode.  Neither the "
"B<open>()  nor any subsequent I/O operations on the file descriptor which is "
"returned will cause the calling process to wait."
msgstr ""

#. type: Plain text
#: man-pages/man2/open.2:579
msgid ""
"Note that the setting of this flag has no effect on the operation of "
"B<poll>(2), B<select>(2), B<epoll>(7), and similar, since those interfaces "
"merely inform the caller about whether a file descriptor is \"ready\", "
"meaning that an I/O operation performed on the file descriptor with the "
"B<O_NONBLOCK> flag I<clear> would not block."
msgstr ""

#. type: Plain text
#: man-pages/man2/open.2:590
msgid ""
"Note that this flag has no effect for regular files and block devices; that "
"is, I/O operations will (briefly) block when device activity is required, "
"regardless of whether B<O_NONBLOCK> is set.  Since B<O_NONBLOCK> semantics "
"might eventually be implemented, applications should not depend upon "
"blocking behavior when specifying this flag for regular files and block "
"devices."
msgstr ""

#. type: Plain text
#: man-pages/man2/open.2:597
msgid ""
"For the handling of FIFOs (named pipes), see also B<fifo>(7).  For a "
"discussion of the effect of B<O_NONBLOCK> in conjunction with mandatory file "
"locks and with file leases, see B<fcntl>(2)."
msgstr ""

#. type: TP
#: man-pages/man2/open.2:597
#, no-wrap
msgid "B<O_PATH> (since Linux 2.6.39)"
msgstr ""

#.  commit 1abf0c718f15a56a0a435588d1b104c7a37dc9bd
#.  commit 326be7b484843988afe57566b627fb7a70beac56
#.  commit 65cfc6722361570bfe255698d9cd4dccaf47570d
#
#.  http://thread.gmane.org/gmane.linux.man/2790/focus=3496
#. 	Subject: Re: [PATCH] open(2): document O_PATH
#. 	Newsgroups: gmane.linux.man, gmane.linux.kernel
#. type: Plain text
#: man-pages/man2/open.2:620
msgid ""
"Obtain a file descriptor that can be used for two purposes: to indicate a "
"location in the filesystem tree and to perform operations that act purely at "
"the file descriptor level.  The file itself is not opened, and other file "
"operations (e.g., B<read>(2), B<write>(2), B<fchmod>(2), B<fchown>(2), "
"B<fgetxattr>(2), B<ioctl>(2), B<mmap>(2))  fail with the error B<EBADF>."
msgstr ""

#. type: Plain text
#: man-pages/man2/open.2:624
msgid ""
"The following operations I<can> be performed on the resulting file "
"descriptor:"
msgstr ""

#. type: Plain text
#: man-pages/man2/open.2:627
msgid "B<close>(2)."
msgstr ""

#.  commit 332a2e1244bd08b9e3ecd378028513396a004a24
#. type: Plain text
#: man-pages/man2/open.2:632
msgid ""
"B<fchdir>(2), if the file descriptor refers to a directory (since Linux "
"3.5)."
msgstr ""

#. type: Plain text
#: man-pages/man2/open.2:635
msgid "B<fstat>(2)  (since Linux 3.6)."
msgstr ""

#.  fstat(): commit 55815f70147dcfa3ead5738fd56d3574e2e3c1c2
#.  fstatfs(): commit 9d05746e7b16d8565dddbe3200faa1e669d23bbf
#. type: Plain text
#: man-pages/man2/open.2:640
msgid "B<fstatfs>(2)  (since Linux 3.12)."
msgstr ""

#. type: Plain text
#: man-pages/man2/open.2:646
msgid "Duplicating the file descriptor (B<dup>(2), B<fcntl>(2)  B<F_DUPFD>, etc.)."
msgstr ""

#. type: Plain text
#: man-pages/man2/open.2:652
msgid ""
"Getting and setting file descriptor flags (B<fcntl>(2)  B<F_GETFD> and "
"B<F_SETFD>)."
msgstr ""

#. type: Plain text
#: man-pages/man2/open.2:658
msgid ""
"Retrieving open file status flags using the B<fcntl>(2)  B<F_GETFL> "
"operation: the returned flags will include the bit B<O_PATH>."
msgstr ""

#. type: Plain text
#: man-pages/man2/open.2:671
msgid ""
"Passing the file descriptor as the I<dirfd> argument of B<openat>()  and the "
"other \"*at()\" system calls.  This includes B<linkat>(2)  with "
"B<AT_EMPTY_PATH> (or via procfs using B<AT_SYMLINK_FOLLOW>)  even if the "
"file is not a directory."
msgstr ""

#. type: Plain text
#: man-pages/man2/open.2:677
msgid ""
"Passing the file descriptor to another process via a UNIX domain socket (see "
"B<SCM_RIGHTS> in B<unix>(7))."
msgstr ""

#. type: Plain text
#: man-pages/man2/open.2:689
msgid ""
"When B<O_PATH> is specified in I<flags>, flag bits other than B<O_CLOEXEC>, "
"B<O_DIRECTORY>, and B<O_NOFOLLOW> are ignored."
msgstr ""

#. type: Plain text
#: man-pages/man2/open.2:707
msgid ""
"Opening a file or directory with the B<O_PATH> flag requires no permissions "
"on the object itself (but does require execute permission on the directories "
"in the path prefix).  Depending on the subsequent operation, a check for "
"suitable file permissions may be performed (e.g., B<fchdir>(2)  requires "
"execute permission on the directory referred to by its file descriptor "
"argument).  By contrast, obtaining a reference to a filesystem object by "
"opening it with the B<O_RDONLY> flag requires that the caller have read "
"permission on the object, even when the subsequent operation (e.g., "
"B<fchdir>(2), B<fstat>(2))  does not require read permission on the object."
msgstr ""

#. type: Plain text
#: man-pages/man2/open.2:723
msgid ""
"If I<pathname> is a symbolic link and the B<O_NOFOLLOW> flag is also "
"specified, then the call returns a file descriptor referring to the symbolic "
"link.  This file descriptor can be used as the I<dirfd> argument in calls to "
"B<fchownat>(2), B<fstatat>(2), B<linkat>(2), and B<readlinkat>(2)  with an "
"empty pathname to have the calls operate on the symbolic link."
msgstr ""

#. type: Plain text
#: man-pages/man2/open.2:733
msgid ""
"If I<pathname> refers to an automount point that has not yet been triggered, "
"so no other filesystem is mounted on it, then the call returns a file "
"descriptor referring to the automount directory without triggering a mount.  "
"B<fstatfs>(2)  can then be used to determine if it is, in fact, an "
"untriggered automount point (B<.f_type == AUTOFS_SUPER_MAGIC>)."
msgstr ""

#. type: Plain text
#: man-pages/man2/open.2:742
msgid ""
"One use of B<O_PATH> for regular files is to provide the equivalent of "
"POSIX.1's B<O_EXEC> functionality.  This permits us to open a file for which "
"we have execute permission but not read permission, and then execute that "
"file, with steps something like the following:"
msgstr ""

#. type: Plain text
#: man-pages/man2/open.2:749
#, no-wrap
msgid ""
"char buf[PATH_MAX];\n"
"fd = open(\"some_prog\", O_PATH);\n"
"snprintf(buf, PATH_MAX, \"/proc/self/fd/%d\", fd);\n"
"execl(buf, \"some_prog\", (char *) NULL);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/open.2:756
msgid ""
"An B<O_PATH> file descriptor can also be passed as the argument of "
"B<fexecve>(3)."
msgstr ""

#. type: TP
#: man-pages/man2/open.2:756
#, no-wrap
msgid "B<O_SYNC>"
msgstr ""

#. type: Plain text
#: man-pages/man2/open.2:768
msgid ""
"Write operations on the file will complete according to the requirements of "
"synchronized I/O I<file> integrity completion (by contrast with the "
"synchronized I/O I<data> integrity completion provided by B<O_DSYNC>.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/open.2:779
msgid ""
"By the time B<write>(2)  (or similar)  returns, the output data and "
"associated file metadata have been transferred to the underlying hardware "
"(i.e., as though each B<write>(2)  was followed by a call to B<fsync>(2)).  "
"I<See NOTES below>."
msgstr ""

#. type: TP
#: man-pages/man2/open.2:779
#, no-wrap
msgid "B<O_TMPFILE> (since Linux 3.11)"
msgstr ""

#.  commit 60545d0d4610b02e55f65d141c95b18ccf855b6e
#.  commit f4e0c30c191f87851c4a53454abb55ee276f4a7e
#.  commit bb458c644a59dbba3a1fe59b27106c5e68e1c4bd
#. type: Plain text
#: man-pages/man2/open.2:791
msgid ""
"Create an unnamed temporary regular file.  The I<pathname> argument "
"specifies a directory; an unnamed inode will be created in that directory's "
"filesystem.  Anything written to the resulting file will be lost when the "
"last file descriptor is closed, unless the file is given a name."
msgstr ""

#. type: Plain text
#: man-pages/man2/open.2:805
msgid ""
"B<O_TMPFILE> must be specified with one of B<O_RDWR> or B<O_WRONLY> and, "
"optionally, B<O_EXCL>.  If B<O_EXCL> is not specified, then B<linkat>(2)  "
"can be used to link the temporary file into the filesystem, making it "
"permanent, using code like the following:"
msgstr ""

#. type: Plain text
#: man-pages/man2/open.2:811
#, no-wrap
msgid ""
"char path[PATH_MAX];\n"
"fd = open(\"/path/to/dir\", O_TMPFILE | O_RDWR,\n"
"                        S_IRUSR | S_IWUSR);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/open.2:813
#, no-wrap
msgid "/* File I/O on 'fd'... */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/open.2:817
#, no-wrap
msgid ""
"snprintf(path, PATH_MAX,  \"/proc/self/fd/%d\", fd);\n"
"linkat(AT_FDCWD, path, AT_FDCWD, \"/path/for/file\",\n"
"                        AT_SYMLINK_FOLLOW);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/open.2:826
msgid ""
"In this case, the B<open>()  I<mode> argument determines the file permission "
"mode, as with B<O_CREAT>."
msgstr ""

#. type: Plain text
#: man-pages/man2/open.2:838
msgid ""
"Specifying B<O_EXCL> in conjunction with B<O_TMPFILE> prevents a temporary "
"file from being linked into the filesystem in the above manner.  (Note that "
"the meaning of B<O_EXCL> in this case is different from the meaning of "
"B<O_EXCL> otherwise.)"
msgstr ""

#.  Inspired by http://lwn.net/Articles/559147/
#. type: Plain text
#: man-pages/man2/open.2:842
msgid "There are two main use cases for B<O_TMPFILE>:"
msgstr ""

#. type: Plain text
#: man-pages/man2/open.2:851
msgid ""
"Improved B<tmpfile>(3)  functionality: race-free creation of temporary files "
"that (1) are automatically deleted when closed; (2) can never be reached via "
"any pathname; (3) are not subject to symlink attacks; and (4) do not require "
"the caller to devise unique names."
msgstr ""

#. type: Plain text
#: man-pages/man2/open.2:862
msgid ""
"Creating a file that is initially invisible, which is then populated with "
"data and adjusted to have appropriate filesystem attributes (B<fchown>(2), "
"B<fchmod>(2), B<fsetxattr>(2), etc.)  before being atomically linked into "
"the filesystem in a fully formed state (using B<linkat>(2)  as described "
"above)."
msgstr ""

#.  To check for support, grep for "tmpfile" in kernel sources
#.  commit 99b6436bc29e4f10e4388c27a3e4810191cc4788
#.  commit ab29743117f9f4c22ac44c13c1647fb24fb2bafe
#.  commit ef3b9af50bfa6a1f02cd7b3f5124b712b1ba3e3c
#.  commit 50732df02eefb39ab414ef655979c2c9b64ad21c
#. type: Plain text
#: man-pages/man2/open.2:879
msgid ""
"B<O_TMPFILE> requires support by the underlying filesystem; only a subset of "
"Linux filesystems provide that support.  In the initial implementation, "
"support was provided in the ext2, ext3, ext4, UDF, Minix, and shmem "
"filesystems.  Support for other filesystems has subsequently been added as "
"follows: XFS (Linux 3.15); Btrfs (Linux 3.16); F2FS (Linux 3.16); and ubifs "
"(Linux 4.9)"
msgstr ""

#. type: TP
#: man-pages/man2/open.2:879
#, no-wrap
msgid "B<O_TRUNC>"
msgstr ""

#. type: Plain text
#: man-pages/man2/open.2:893
msgid ""
"If the file already exists and is a regular file and the access mode allows "
"writing (i.e., is B<O_RDWR> or B<O_WRONLY>)  it will be truncated to length "
"0.  If the file is a FIFO or terminal device file, the B<O_TRUNC> flag is "
"ignored.  Otherwise, the effect of B<O_TRUNC> is unspecified."
msgstr ""

#. type: SS
#: man-pages/man2/open.2:893
#, no-wrap
msgid "creat()"
msgstr ""

#. type: Plain text
#: man-pages/man2/open.2:902
msgid ""
"A call to B<creat>()  is equivalent to calling B<open>()  with I<flags> "
"equal to B<O_CREAT|O_WRONLY|O_TRUNC>."
msgstr ""

#. type: SS
#: man-pages/man2/open.2:902
#, no-wrap
msgid "openat()"
msgstr ""

#. type: Plain text
#: man-pages/man2/open.2:908
msgid ""
"The B<openat>()  system call operates in exactly the same way as B<open>(), "
"except for the differences described here."
msgstr ""

#. type: Plain text
#: man-pages/man2/open.2:918
msgid ""
"If the pathname given in I<pathname> is relative, then it is interpreted "
"relative to the directory referred to by the file descriptor I<dirfd> "
"(rather than relative to the current working directory of the calling "
"process, as is done by B<open>()  for a relative pathname)."
msgstr ""

#. type: Plain text
#: man-pages/man2/open.2:930
msgid ""
"If I<pathname> is relative and I<dirfd> is the special value B<AT_FDCWD>, "
"then I<pathname> is interpreted relative to the current working directory of "
"the calling process (like B<open>())."
msgstr ""

#. type: Plain text
#: man-pages/man2/open.2:945
msgid ""
"B<open>(), B<openat>(), and B<creat>()  return the new file descriptor, or "
"-1 if an error occurred (in which case, I<errno> is set appropriately)."
msgstr ""

#. type: Plain text
#: man-pages/man2/open.2:951
msgid "B<open>(), B<openat>(), and B<creat>()  can fail with the following errors:"
msgstr ""

#. type: Plain text
#: man-pages/man2/open.2:960
msgid ""
"The requested access to the file is not allowed, or search permission is "
"denied for one of the directories in the path prefix of I<pathname>, or the "
"file did not exist yet and write access to the parent directory is not "
"allowed.  (See also B<path_resolution>(7).)"
msgstr ""

#. type: Plain text
#: man-pages/man2/open.2:966
msgid ""
"Where B<O_CREAT> is specified, the file does not exist, and the user's quota "
"of disk blocks or inodes on the filesystem has been exhausted."
msgstr ""

#. type: Plain text
#: man-pages/man2/open.2:972
msgid "I<pathname> already exists and B<O_CREAT> and B<O_EXCL> were used."
msgstr ""

#. type: Plain text
#: man-pages/man2/open.2:980
msgid "See B<EOVERFLOW>."
msgstr ""

#. type: Plain text
#: man-pages/man2/open.2:987
msgid ""
"While blocked waiting to complete an open of a slow device (e.g., a FIFO; "
"see B<fifo>(7)), the call was interrupted by a signal handler; see "
"B<signal>(7)."
msgstr ""

#. type: Plain text
#: man-pages/man2/open.2:995
msgid ""
"The filesystem does not support the B<O_DIRECT> flag.  See B<NOTES> for more "
"information."
msgstr ""

#. type: Plain text
#: man-pages/man2/open.2:1000 man-pages/man2/utimensat.2:307
msgid "Invalid value in I<flags>."
msgstr ""

#. type: Plain text
#: man-pages/man2/open.2:1010
msgid ""
"B<O_TMPFILE> was specified in I<flags>, but neither B<O_WRONLY> nor "
"B<O_RDWR> was specified."
msgstr ""

#. type: Plain text
#: man-pages/man2/open.2:1019
msgid ""
"B<O_CREAT> was specified in I<flags> and the final component (\"basename\") "
"of the new file's I<pathname> is invalid (e.g., it contains characters not "
"permitted by the underlying filesystem)."
msgstr ""

#. type: Plain text
#: man-pages/man2/open.2:1028
msgid ""
"I<pathname> refers to a directory and the access requested involved writing "
"(that is, B<O_WRONLY> or B<O_RDWR> is set)."
msgstr ""

#. type: Plain text
#: man-pages/man2/open.2:1042
msgid ""
"I<pathname> refers to an existing directory, B<O_TMPFILE> and one of "
"B<O_WRONLY> or B<O_RDWR> were specified in I<flags>, but this kernel version "
"does not provide the B<O_TMPFILE> functionality."
msgstr ""

#. type: Plain text
#: man-pages/man2/open.2:1055
msgid ""
"I<pathname> was a symbolic link, and I<flags> specified B<O_NOFOLLOW> but "
"not B<O_PATH>."
msgstr ""

#. type: Plain text
#: man-pages/man2/open.2:1062
msgid ""
"The per-process limit on the number of open file descriptors has been "
"reached (see the description of B<RLIMIT_NOFILE> in B<getrlimit>(2))."
msgstr ""

#. type: Plain text
#: man-pages/man2/open.2:1076
msgid ""
"I<pathname> refers to a device special file and no corresponding device "
"exists.  (This is a Linux kernel bug; in this situation B<ENXIO> must be "
"returned.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/open.2:1080
msgid "B<O_CREAT> is not set and the named file does not exist."
msgstr ""

#. type: Plain text
#: man-pages/man2/open.2:1099
msgid ""
"I<pathname> refers to a nonexistent directory, B<O_TMPFILE> and one of "
"B<O_WRONLY> or B<O_RDWR> were specified in I<flags>, but this kernel version "
"does not provide the B<O_TMPFILE> functionality."
msgstr ""

#. type: Plain text
#: man-pages/man2/open.2:1106
msgid ""
"The named file is a FIFO, but memory for the FIFO buffer can't be allocated "
"because the per-user hard limit on memory allocation for pipes has been "
"reached and the caller is not privileged; see B<pipe>(7)."
msgstr ""

#. type: Plain text
#: man-pages/man2/open.2:1115
msgid ""
"I<pathname> was to be created but the device containing I<pathname> has no "
"room for the new file."
msgstr ""

#. type: Plain text
#: man-pages/man2/open.2:1122
msgid ""
"A component used as a directory in I<pathname> is not, in fact, a directory, "
"or B<O_DIRECTORY> was specified and I<pathname> was not a directory."
msgstr ""

#. type: TP
#: man-pages/man2/open.2:1122 man-pages/man2/open.2:1127
#: man-pages/man2/open.2:1130 man-pages/man2/prctl.2:1682
#: man-pages/man2/prctl.2:1691 man-pages/man2/mount.2:783
#: man-pages/man2/lseek.2:206
#, no-wrap
msgid "B<ENXIO>"
msgstr ""

#. type: Plain text
#: man-pages/man2/open.2:1127
msgid ""
"B<O_NONBLOCK> | B<O_WRONLY> is set, the named file is a FIFO, and no process "
"has the FIFO open for reading."
msgstr ""

#. type: Plain text
#: man-pages/man2/open.2:1130
msgid "The file is a device special file and no corresponding device exists."
msgstr ""

#. type: Plain text
#: man-pages/man2/open.2:1133
msgid "The file is a UNIX domain socket."
msgstr ""

#. type: Plain text
#: man-pages/man2/open.2:1139
msgid "The filesystem containing I<pathname> does not support B<O_TMPFILE>."
msgstr ""

#. type: TP
#: man-pages/man2/open.2:1139 man-pages/man2/copy_file_range.2:171
#: man-pages/man2/sendfile.2:159 man-pages/man2/shmctl.2:364
#: man-pages/man2/stat.2:421 man-pages/man2/lseek.2:214
#: man-pages/man2/mmap.2:604 man-pages/man2/open_by_handle_at.2:335
#: man-pages/man2/statfs.2:277
#, no-wrap
msgid "B<EOVERFLOW>"
msgstr ""

#.  See http://bugzilla.kernel.org/show_bug.cgi?id=7253
#.  "Open of a large file on 32-bit fails with EFBIG, should be EOVERFLOW"
#.  Reported 2006-10-03
#. type: Plain text
#: man-pages/man2/open.2:1159
msgid ""
"I<pathname> refers to a regular file that is too large to be opened.  The "
"usual scenario here is that an application compiled on a 32-bit platform "
"without I<-D_FILE_OFFSET_BITS=64> tried to open a file whose size exceeds "
"I<(1E<lt>E<lt>31)-1> bytes; see also B<O_LARGEFILE> above.  This is the "
"error specified by POSIX.1; in kernels before 2.6.24, Linux gave the error "
"B<EFBIG> for this case."
msgstr ""

#.  Strictly speaking, it's the filesystem UID... (MTK)
#. type: Plain text
#: man-pages/man2/open.2:1166
msgid ""
"The B<O_NOATIME> flag was specified, but the effective user ID of the caller "
"did not match the owner of the file and the caller was not privileged."
msgstr ""

#. type: Plain text
#: man-pages/man2/open.2:1175
msgid ""
"I<pathname> refers to a file on a read-only filesystem and write access was "
"requested."
msgstr ""

#. type: Plain text
#: man-pages/man2/open.2:1180
msgid ""
"I<pathname> refers to an executable image which is currently being executed "
"and write access was requested."
msgstr ""

#. type: Plain text
#: man-pages/man2/open.2:1186
msgid ""
"I<pathname> refers to a file that is currently in use as a swap file, and "
"the B<O_TRUNC> flag was specified."
msgstr ""

#. type: Plain text
#: man-pages/man2/open.2:1191
msgid ""
"I<pathname> refers to a file that is currently being read by the kernel "
"(e.g. for module/firmware loading), and write access was requested."
msgstr ""

#. type: TP
#: man-pages/man2/open.2:1191 man-pages/man2/delete_module.2:161
#: man-pages/man2/flock.2:134
#, no-wrap
msgid "B<EWOULDBLOCK>"
msgstr ""

#. type: Plain text
#: man-pages/man2/open.2:1198
msgid ""
"The B<O_NONBLOCK> flag was specified, and an incompatible lease was held on "
"the file (see B<fcntl>(2))."
msgstr ""

#. type: Plain text
#: man-pages/man2/open.2:1201
msgid "The following additional errors can occur for B<openat>():"
msgstr ""

#. type: Plain text
#: man-pages/man2/open.2:1211
msgid ""
"I<pathname> is a relative pathname and I<dirfd> is a file descriptor "
"referring to a file other than a directory."
msgstr ""

#. type: Plain text
#: man-pages/man2/open.2:1215
msgid ""
"B<openat>()  was added to Linux in kernel 2.6.16; library support was added "
"to glibc in version 2.4."
msgstr ""

#. type: Plain text
#: man-pages/man2/open.2:1219
msgid "B<open>(), B<creat>()  SVr4, 4.3BSD, POSIX.1-2001, POSIX.1-2008."
msgstr ""

#. type: Plain text
#: man-pages/man2/open.2:1222
msgid "B<openat>(): POSIX.1-2008."
msgstr ""

#. type: Plain text
#: man-pages/man2/open.2:1233
msgid ""
"The B<O_DIRECT>, B<O_NOATIME>, B<O_PATH>, and B<O_TMPFILE> flags are "
"Linux-specific.  One must define B<_GNU_SOURCE> to obtain their definitions."
msgstr ""

#. type: Plain text
#: man-pages/man2/open.2:1248
msgid ""
"The B<O_CLOEXEC>, B<O_DIRECTORY>, and B<O_NOFOLLOW> flags are not specified "
"in POSIX.1-2001, but are specified in POSIX.1-2008.  Since glibc 2.12, one "
"can obtain their definitions by defining either B<_POSIX_C_SOURCE> with a "
"value greater than or equal to 200809L or B<_XOPEN_SOURCE> with a value "
"greater than or equal to 700.  In glibc 2.11 and earlier, one obtains the "
"definitions by defining B<_GNU_SOURCE>."
msgstr ""

#. type: Plain text
#: man-pages/man2/open.2:1259
msgid ""
"As noted in B<feature_test_macros>(7), feature test macros such as "
"B<_POSIX_C_SOURCE>, B<_XOPEN_SOURCE>, and B<_GNU_SOURCE> must be defined "
"before including I<any> header files."
msgstr ""

#. type: Plain text
#: man-pages/man2/open.2:1268
msgid ""
"Under Linux, the B<O_NONBLOCK> flag is sometimes used in cases where one "
"wants to open but does not necessarily have the intention to read or write.  "
"For example, this may be used to open a device in order to get a file "
"descriptor for use with B<ioctl>(2)."
msgstr ""

#.  Linux 2.0, 2.5: truncate
#.  Solaris 5.7, 5.8: truncate
#.  Irix 6.5: truncate
#.  Tru64 5.1B: truncate
#.  HP-UX 11.22: truncate
#.  FreeBSD 4.7: truncate
#. type: Plain text
#: man-pages/man2/open.2:1279
msgid ""
"The (undefined) effect of B<O_RDONLY | O_TRUNC> varies among "
"implementations.  On many systems the file is actually truncated."
msgstr ""

#. type: Plain text
#: man-pages/man2/open.2:1287
msgid ""
"Note that B<open>()  can open device special files, but B<creat>()  cannot "
"create them; use B<mknod>(2)  instead."
msgstr ""

#. type: Plain text
#: man-pages/man2/open.2:1310
msgid ""
"If the file is newly created, its I<st_atime>, I<st_ctime>, I<st_mtime> "
"fields (respectively, time of last access, time of last status change, and "
"time of last modification; see B<stat>(2))  are set to the current time, and "
"so are the I<st_ctime> and I<st_mtime> fields of the parent directory.  "
"Otherwise, if the file is modified because of the B<O_TRUNC> flag, its "
"I<st_ctime> and I<st_mtime> fields are set to the current time."
msgstr ""

#. type: Plain text
#: man-pages/man2/open.2:1321
msgid ""
"The files in the I</proc/[pid]/fd> directory show the open file descriptors "
"of the process with the PID I<pid>.  The files in the I</proc/[pid]/fdinfo> "
"directory show even more information about these file descriptors.  See "
"B<proc>(5)  for further details of both of these directories."
msgstr ""

#. type: Plain text
#: man-pages/man2/open.2:1331
msgid ""
"The Linux header file B<E<lt>asm/fcntl.hE<gt>> doesn't define B<O_ASYNC>; "
"the (BSD-derived)  B<FASYNC> synonym is defined instead."
msgstr ""

#. type: SS
#: man-pages/man2/open.2:1331
#, no-wrap
msgid "Open file descriptions"
msgstr ""

#. type: Plain text
#: man-pages/man2/open.2:1339
msgid ""
"The term open file description is the one used by POSIX to refer to the "
"entries in the system-wide table of open files.  In other contexts, this "
"object is variously also called an \"open file object\", a \"file handle\", "
"an \"open file table entry\", or\\(emin kernel-developer parlance\\(ema "
"I<struct file>."
msgstr ""

#. type: Plain text
#: man-pages/man2/open.2:1352
msgid ""
"When a file descriptor is duplicated (using B<dup>(2)  or similar), the "
"duplicate refers to the same open file description as the original file "
"descriptor, and the two file descriptors consequently share the file offset "
"and file status flags.  Such sharing can also occur between processes: a "
"child process created via B<fork>(2)  inherits duplicates of its parent's "
"file descriptors, and those duplicates refer to the same open file "
"descriptions."
msgstr ""

#. type: Plain text
#: man-pages/man2/open.2:1358
msgid ""
"Each B<open>()  of a file creates a new open file description; thus, there "
"may be multiple open file descriptions corresponding to a file inode."
msgstr ""

#. type: Plain text
#: man-pages/man2/open.2:1367
msgid ""
"On Linux, one can use the B<kcmp>(2)  B<KCMP_FILE> operation to test whether "
"two file descriptors (in the same process or in two different processes)  "
"refer to the same open file description."
msgstr ""

#. type: SS
#: man-pages/man2/open.2:1367
#, no-wrap
msgid "Synchronized I/O"
msgstr ""

#. type: Plain text
#: man-pages/man2/open.2:1382
msgid ""
"The POSIX.1-2008 \"synchronized I/O\" option specifies different variants of "
"synchronized I/O, and specifies the B<open>()  flags B<O_SYNC>, B<O_DSYNC>, "
"and B<O_RSYNC> for controlling the behavior.  Regardless of whether an "
"implementation supports this option, it must at least support the use of "
"B<O_SYNC> for regular files."
msgstr ""

#. type: Plain text
#: man-pages/man2/open.2:1397
msgid ""
"Linux implements B<O_SYNC> and B<O_DSYNC>, but not B<O_RSYNC>.  Somewhat "
"incorrectly, glibc defines B<O_RSYNC> to have the same value as B<O_SYNC>.  "
"(B<O_RSYNC> is defined in the Linux header file I<E<lt>asm/fcntl.hE<gt>> on "
"HP PA-RISC, but it is not used.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/open.2:1415
msgid ""
"B<O_SYNC> provides synchronized I/O I<file> integrity completion, meaning "
"write operations will flush data and all associated metadata to the "
"underlying hardware.  B<O_DSYNC> provides synchronized I/O I<data> integrity "
"completion, meaning write operations will flush data to the underlying "
"hardware, but will only flush metadata updates that are required to allow a "
"subsequent read operation to complete successfully.  Data integrity "
"completion can reduce the number of disk operations that are required for "
"applications that don't need the guarantees of file integrity completion."
msgstr ""

#. type: Plain text
#: man-pages/man2/open.2:1432
msgid ""
"To understand the difference between the two types of completion, consider "
"two pieces of file metadata: the file last modification timestamp "
"(I<st_mtime>)  and the file length.  All write operations will update the "
"last file modification timestamp, but only writes that add data to the end "
"of the file will change the file length.  The last modification timestamp is "
"not needed to ensure that a read completes successfully, but the file length "
"is.  Thus, B<O_DSYNC> would only guarantee to flush updates to the file "
"length metadata (whereas B<O_SYNC> would also always flush the last "
"modification timestamp metadata)."
msgstr ""

#. type: Plain text
#: man-pages/man2/open.2:1444
msgid ""
"Before Linux 2.6.33, Linux implemented only the B<O_SYNC> flag for "
"B<open>().  However, when that flag was specified, most filesystems actually "
"provided the equivalent of synchronized I/O I<data> integrity completion "
"(i.e., B<O_SYNC> was actually implemented as the equivalent of B<O_DSYNC>)."
msgstr ""

#. type: Plain text
#: man-pages/man2/open.2:1462
msgid ""
"Since Linux 2.6.33, proper B<O_SYNC> support is provided.  However, to "
"ensure backward binary compatibility, B<O_DSYNC> was defined with the same "
"value as the historical B<O_SYNC>, and B<O_SYNC> was defined as a new "
"(two-bit) flag value that includes the B<O_DSYNC> flag value.  This ensures "
"that applications compiled against new headers get at least B<O_DSYNC> "
"semantics on pre-2.6.33 kernels."
msgstr ""

#. type: Plain text
#: man-pages/man2/open.2:1473
msgid ""
"Since version 2.26, the glibc wrapper function for B<open>()  employs the "
"B<openat>()  system call, rather than the kernel's B<open>()  system call.  "
"For certain architectures, this is also true in glibc versions before 2.26."
msgstr ""

#. type: SS
#: man-pages/man2/open.2:1473 man-pages/man2/chown.2:402
#, no-wrap
msgid "NFS"
msgstr ""

#. type: Plain text
#: man-pages/man2/open.2:1477
msgid ""
"There are many infelicities in the protocol underlying NFS, affecting "
"amongst others B<O_SYNC> and B<O_NDELAY>."
msgstr ""

#. type: Plain text
#: man-pages/man2/open.2:1492
msgid ""
"On NFS filesystems with UID mapping enabled, B<open>()  may return a file "
"descriptor but, for example, B<read>(2)  requests are denied with "
"B<EACCES>.  This is because the client performs B<open>()  by checking the "
"permissions, but UID mapping is performed by the server upon read and write "
"requests."
msgstr ""

#. type: SS
#: man-pages/man2/open.2:1492
#, no-wrap
msgid "FIFOs"
msgstr ""

#. type: Plain text
#: man-pages/man2/open.2:1500
msgid ""
"Opening the read or write end of a FIFO blocks until the other end is also "
"opened (by another process or thread).  See B<fifo>(7)  for further details."
msgstr ""

#. type: SS
#: man-pages/man2/open.2:1500
#, no-wrap
msgid "File access mode"
msgstr ""

#. type: Plain text
#: man-pages/man2/open.2:1515
msgid ""
"Unlike the other values that can be specified in I<flags>, the I<access "
"mode> values B<O_RDONLY>, B<O_WRONLY>, and B<O_RDWR> do not specify "
"individual bits.  Rather, they define the low order two bits of I<flags>, "
"and are defined respectively as 0, 1, and 2.  In other words, the "
"combination B<O_RDONLY | O_WRONLY> is a logical error, and certainly does "
"not have the same meaning as B<O_RDWR>."
msgstr ""

#.  See for example util-linux's disk-utils/setfdprm.c
#.  For some background on access mode 3, see
#.  http://thread.gmane.org/gmane.linux.kernel/653123
#.  "[RFC] correct flags to f_mode conversion in __dentry_open"
#.  LKML, 12 Mar 2008
#. type: Plain text
#: man-pages/man2/open.2:1532
msgid ""
"Linux reserves the special, nonstandard access mode 3 (binary 11) in "
"I<flags> to mean: check for read and write permission on the file and return "
"a file descriptor that can't be used for reading or writing.  This "
"nonstandard access mode is used by some Linux drivers to return a file "
"descriptor that is to be used only for device-specific B<ioctl>(2)  "
"operations."
msgstr ""

#. type: SS
#: man-pages/man2/open.2:1532
#, no-wrap
msgid "Rationale for openat() and other directory file descriptor APIs"
msgstr ""

#. type: Plain text
#: man-pages/man2/open.2:1561
msgid ""
"B<openat>()  and the other system calls and library functions that take a "
"directory file descriptor argument (i.e., B<execveat>(2), B<faccessat>(2), "
"B<fanotify_mark>(2), B<fchmodat>(2), B<fchownat>(2), B<fstatat>(2), "
"B<futimesat>(2), B<linkat>(2), B<mkdirat>(2), B<mknodat>(2), "
"B<name_to_handle_at>(2), B<readlinkat>(2), B<renameat>(2), B<statx>(2), "
"B<symlinkat>(2), B<unlinkat>(2), B<utimensat>(2), B<mkfifoat>(3), and "
"B<scandirat>(3))  address two problems with the older interfaces that "
"preceded them.  Here, the explanation is in terms of the B<openat>()  call, "
"but the rationale is analogous for the other interfaces."
msgstr ""

#. type: Plain text
#: man-pages/man2/open.2:1595
msgid ""
"First, B<openat>()  allows an application to avoid race conditions that "
"could occur when using B<open>()  to open files in directories other than "
"the current working directory.  These race conditions result from the fact "
"that some component of the directory prefix given to B<open>()  could be "
"changed in parallel with the call to B<open>().  Suppose, for example, that "
"we wish to create the file I<dir1/dir2/xxx.dep> if the file I<dir1/dir2/xxx> "
"exists.  The problem is that between the existence check and the "
"file-creation step, I<dir1> or I<dir2> (which might be symbolic links)  "
"could be modified to point to a different location.  Such races can be "
"avoided by opening a file descriptor for the target directory, and then "
"specifying that file descriptor as the I<dirfd> argument of (say)  "
"B<fstatat>(2)  and B<openat>().  The use of the I<dirfd> file descriptor "
"also has other benefits:"
msgstr ""

#. type: Plain text
#: man-pages/man2/open.2:1598
msgid ""
"the file descriptor is a stable reference to the directory, even if the "
"directory is renamed; and"
msgstr ""

#. type: Plain text
#: man-pages/man2/open.2:1602
msgid ""
"the open file descriptor prevents the underlying filesystem from being "
"dismounted, just as when a process has a current working directory on a "
"filesystem."
msgstr ""

#. type: Plain text
#: man-pages/man2/open.2:1613
msgid ""
"Second, B<openat>()  allows the implementation of a per-thread \"current "
"working directory\", via file descriptor(s) maintained by the application.  "
"(This functionality can also be obtained by tricks based on the use of "
"I</proc/self/fd/>dirfd, but less efficiently.)"
msgstr ""

#. type: SS
#: man-pages/man2/open.2:1613
#, no-wrap
msgid "O_DIRECT"
msgstr ""

#. type: Plain text
#: man-pages/man2/open.2:1630
msgid ""
"The B<O_DIRECT> flag may impose alignment restrictions on the length and "
"address of user-space buffers and the file offset of I/Os.  In Linux "
"alignment restrictions vary by filesystem and kernel version and might be "
"absent entirely.  However there is currently no filesystem-independent "
"interface for an application to discover these restrictions for a given file "
"or filesystem.  Some filesystems provide their own interfaces for doing so, "
"for example the B<XFS_IOC_DIOINFO> operation in B<xfsctl>(3)."
msgstr ""

#. type: Plain text
#: man-pages/man2/open.2:1640
msgid ""
"Under Linux 2.4, transfer sizes, and the alignment of the user buffer and "
"the file offset must all be multiples of the logical block size of the "
"filesystem.  Since Linux 2.6.0, alignment to the logical block size of the "
"underlying storage (typically 512 bytes) suffices.  The logical block size "
"can be determined using the B<ioctl>(2)  B<BLKSSZGET> operation or from the "
"shell using the command:"
msgstr ""

#. type: Plain text
#: man-pages/man2/open.2:1643
#, no-wrap
msgid "    blockdev --getss\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/open.2:1678
msgid ""
"B<O_DIRECT> I/Os should never be run concurrently with the B<fork>(2)  "
"system call, if the memory buffer is a private mapping (i.e., any mapping "
"created with the B<mmap>(2)  B<MAP_PRIVATE> flag; this includes memory "
"allocated on the heap and statically allocated buffers).  Any such I/Os, "
"whether submitted via an asynchronous I/O interface or from another thread "
"in the process, should be completed before B<fork>(2)  is called.  Failure "
"to do so can result in data corruption and undefined behavior in parent and "
"child processes.  This restriction does not apply when the memory buffer for "
"the B<O_DIRECT> I/Os was created using B<shmat>(2)  or B<mmap>(2)  with the "
"B<MAP_SHARED> flag.  Nor does this restriction apply when the memory buffer "
"has been advised as B<MADV_DONTFORK> with B<madvise>(2), ensuring that it "
"will not be available to the child after B<fork>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/open.2:1688
msgid ""
"The B<O_DIRECT> flag was introduced in SGI IRIX, where it has alignment "
"restrictions similar to those of Linux 2.4.  IRIX has also a B<fcntl>(2)  "
"call to query appropriate alignments, and sizes.  FreeBSD 4.x introduced a "
"flag of the same name, but without alignment restrictions."
msgstr ""

#. type: Plain text
#: man-pages/man2/open.2:1697
msgid ""
"B<O_DIRECT> support was added under Linux in kernel version 2.4.10.  Older "
"Linux kernels simply ignore this flag.  Some filesystems may not implement "
"the flag, in which case B<open>()  fails with the error B<EINVAL> if it is "
"used."
msgstr ""

#. type: Plain text
#: man-pages/man2/open.2:1708
msgid ""
"Applications should avoid mixing B<O_DIRECT> and normal I/O to the same "
"file, and especially to overlapping byte regions in the same file.  Even "
"when the filesystem correctly handles the coherency issues in this "
"situation, overall I/O throughput is likely to be slower than using either "
"mode alone.  Likewise, applications should avoid mixing B<mmap>(2)  of files "
"with direct I/O to the same files."
msgstr ""

#. type: Plain text
#: man-pages/man2/open.2:1730
msgid ""
"The behavior of B<O_DIRECT> with NFS will differ from local filesystems.  "
"Older kernels, or kernels configured in certain ways, may not support this "
"combination.  The NFS protocol does not support passing the flag to the "
"server, so B<O_DIRECT> I/O will bypass the page cache only on the client; "
"the server may still cache the I/O.  The client asks the server to make the "
"I/O synchronous to preserve the synchronous semantics of B<O_DIRECT>.  Some "
"servers will perform poorly under these circumstances, especially if the I/O "
"size is small.  Some servers may also be configured to lie to clients about "
"the I/O having reached stable storage; this will avoid the performance "
"penalty at some risk to data integrity in the event of server power "
"failure.  The Linux NFS client places no alignment restrictions on "
"B<O_DIRECT> I/O."
msgstr ""

#. type: Plain text
#: man-pages/man2/open.2:1737
msgid ""
"In summary, B<O_DIRECT> is a potentially powerful tool that should be used "
"with caution.  It is recommended that applications treat use of B<O_DIRECT> "
"as a performance option which is disabled by default."
msgstr ""

#.  FIXME . Check bugzilla report on open(O_ASYNC)
#.  See http://bugzilla.kernel.org/show_bug.cgi?id=5993
#. type: Plain text
#: man-pages/man2/open.2:1748
msgid ""
"Currently, it is not possible to enable signal-driven I/O by specifying "
"B<O_ASYNC> when calling B<open>(); use B<fcntl>(2)  to enable this flag."
msgstr ""

#. type: Plain text
#: man-pages/man2/open.2:1756
msgid ""
"One must check for two different error codes, B<EISDIR> and B<ENOENT>, when "
"trying to determine whether the kernel supports B<O_TMPFILE> functionality."
msgstr ""

#. type: Plain text
#: man-pages/man2/open.2:1770
msgid ""
"When both B<O_CREAT> and B<O_DIRECTORY> are specified in I<flags> and the "
"file specified by I<pathname> does not exist, B<open>()  will create a "
"regular file (i.e., B<O_DIRECTORY> is ignored)."
msgstr ""

#. type: Plain text
#: man-pages/man2/open.2:1793
msgid ""
"B<chmod>(2), B<chown>(2), B<close>(2), B<dup>(2), B<fcntl>(2), B<link>(2), "
"B<lseek>(2), B<mknod>(2), B<mmap>(2), B<mount>(2), B<open_by_handle_at>(2), "
"B<read>(2), B<socket>(2), B<stat>(2), B<umask>(2), B<unlink>(2), "
"B<write>(2), B<fopen>(3), B<acl>(5), B<fifo>(7), B<inode>(7), "
"B<path_resolution>(7), B<symlink>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/msgget.2:35
#, no-wrap
msgid "MSGGET"
msgstr ""

#. type: Plain text
#: man-pages/man2/msgget.2:38
msgid "msgget - get a System V message queue identifier"
msgstr ""

#. type: Plain text
#: man-pages/man2/msgget.2:45
#, no-wrap
msgid "B<int msgget(key_t >I<key>B<, int >I<msgflg>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/msgget.2:61
msgid ""
"The B<msgget>()  system call returns the System\\ V message queue identifier "
"associated with the value of the I<key> argument.  It may be used either to "
"obtain the identifier of a previously created message queue (when I<msgflg> "
"is zero and I<key> does not have the value B<IPC_PRIVATE>), or to create a "
"new set."
msgstr ""

#. type: Plain text
#: man-pages/man2/msgget.2:76
msgid ""
"A new message queue is created if I<key> has the value B<IPC_PRIVATE> or "
"I<key> isn't B<IPC_PRIVATE>, no message queue with the given key I<key> "
"exists, and B<IPC_CREAT> is specified in I<msgflg>."
msgstr ""

#. type: Plain text
#: man-pages/man2/msgget.2:95
msgid ""
"If I<msgflg> specifies both B<IPC_CREAT> and B<IPC_EXCL> and a message queue "
"already exists for I<key>, then B<msgget>()  fails with I<errno> set to "
"B<EEXIST>.  (This is analogous to the effect of the combination B<O_CREAT | "
"O_EXCL> for B<open>(2).)"
msgstr ""

#. type: Plain text
#: man-pages/man2/msgget.2:105
msgid ""
"Upon creation, the least significant bits of the argument I<msgflg> define "
"the permissions of the message queue.  These permission bits have the same "
"format and semantics as the permissions specified for the I<mode> argument "
"of B<open>(2).  (The execute permissions are not used.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/msgget.2:112
msgid ""
"If a new message queue is created, then its associated data structure "
"I<msqid_ds> (see B<msgctl>(2))  is initialized as follows:"
msgstr ""

#. type: Plain text
#: man-pages/man2/msgget.2:117
msgid ""
"I<msg_perm.cuid> and I<msg_perm.uid> are set to the effective user ID of the "
"calling process."
msgstr ""

#. type: Plain text
#: man-pages/man2/msgget.2:122
msgid ""
"I<msg_perm.cgid> and I<msg_perm.gid> are set to the effective group ID of "
"the calling process."
msgstr ""

#. type: Plain text
#: man-pages/man2/msgget.2:127
msgid ""
"The least significant 9 bits of I<msg_perm.mode> are set to the least "
"significant 9 bits of I<msgflg>."
msgstr ""

#. type: Plain text
#: man-pages/man2/msgget.2:135
msgid ""
"I<msg_qnum>, I<msg_lspid>, I<msg_lrpid>, I<msg_stime>, and I<msg_rtime> are "
"set to 0."
msgstr ""

#. type: Plain text
#: man-pages/man2/msgget.2:138
msgid "I<msg_ctime> is set to the current time."
msgstr ""

#. type: Plain text
#: man-pages/man2/msgget.2:142
msgid "I<msg_qbytes> is set to the system limit B<MSGMNB>."
msgstr ""

#. type: Plain text
#: man-pages/man2/msgget.2:146
msgid ""
"If the message queue already exists the permissions are verified, and a "
"check is made to see if it is marked for destruction."
msgstr ""

#. type: Plain text
#: man-pages/man2/msgget.2:152
msgid ""
"If successful, the return value will be the message queue identifier (a "
"nonnegative integer), otherwise -1 with I<errno> indicating the error."
msgstr ""

#. type: Plain text
#: man-pages/man2/msgget.2:156
msgid "On failure, I<errno> is set to one of the following values:"
msgstr ""

#. type: Plain text
#: man-pages/man2/msgget.2:164
msgid ""
"A message queue exists for I<key>, but the calling process does not have "
"permission to access the queue, and does not have the B<CAP_IPC_OWNER> "
"capability in the user namespace that governs its IPC namespace."
msgstr ""

#. type: Plain text
#: man-pages/man2/msgget.2:173
msgid ""
"B<IPC_CREAT> and B<IPC_EXCL> were specified in I<msgflg>, but a message "
"queue already exists for I<key>."
msgstr ""

#. type: Plain text
#: man-pages/man2/msgget.2:181
msgid ""
"No message queue exists for I<key> and I<msgflg> did not specify "
"B<IPC_CREAT>."
msgstr ""

#. type: Plain text
#: man-pages/man2/msgget.2:185
msgid ""
"A message queue has to be created but the system does not have enough memory "
"for the new data structure."
msgstr ""

#. type: Plain text
#: man-pages/man2/msgget.2:191
msgid ""
"A message queue has to be created but the system limit for the maximum "
"number of message queues (B<MSGMNI>)  would be exceeded."
msgstr ""

#. type: Plain text
#: man-pages/man2/msgget.2:216
msgid ""
"B<IPC_PRIVATE> isn't a flag field but a I<key_t> type.  If this special "
"value is used for I<key>, the system call ignores everything but the least "
"significant 9 bits of I<msgflg> and creates a new message queue (on "
"success)."
msgstr ""

#. type: Plain text
#: man-pages/man2/msgget.2:220
msgid ""
"The following is a system limit on message queue resources affecting a "
"B<msgget>()  call:"
msgstr ""

#. type: TP
#: man-pages/man2/msgget.2:220
#, no-wrap
msgid "B<MSGMNI>"
msgstr ""

#.  commit 0050ee059f7fc86b1df2527aaa14ed5dc72f9973
#. type: Plain text
#: man-pages/man2/msgget.2:230
msgid ""
"System-wide limit on the number of message queues.  Before Linux 3.19, the "
"default value for this limit was calculated using a formula based on "
"available system memory.  Since Linux 3.19, the default value is 32,000.  On "
"Linux, this limit can be read and modified via I</proc/sys/kernel/msgmni>."
msgstr ""

#. type: Plain text
#: man-pages/man2/msgget.2:236
msgid ""
"Until version 2.3.20, Linux would return B<EIDRM> for a B<msgget>()  on a "
"message queue scheduled for deletion."
msgstr ""

#. type: Plain text
#: man-pages/man2/msgget.2:242 man-pages/man2/shmget.2:414
#: man-pages/man2/semget.2:315
msgid ""
"The name choice B<IPC_PRIVATE> was perhaps unfortunate, B<IPC_NEW> would "
"more clearly show its function."
msgstr ""

#. type: Plain text
#: man-pages/man2/msgget.2:249
msgid ""
"B<msgctl>(2), B<msgrcv>(2), B<msgsnd>(2), B<ftok>(3), B<capabilities>(7), "
"B<mq_overview>(7), B<sysvipc>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/socket.2:43
#, no-wrap
msgid "SOCKET"
msgstr ""

#. type: Plain text
#: man-pages/man2/socket.2:46
msgid "socket - create an endpoint for communication"
msgstr ""

#. type: Plain text
#: man-pages/man2/socket.2:52
msgid "B<int socket(int >I<domain>B<, int >I<type>B<, int >I<protocol>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/socket.2:58
msgid ""
"B<socket>()  creates an endpoint for communication and returns a file "
"descriptor that refers to that endpoint.  The file descriptor returned by a "
"successful call will be the lowest-numbered file descriptor not currently "
"open for the process."
msgstr ""

#. type: Plain text
#: man-pages/man2/socket.2:66
msgid ""
"The I<domain> argument specifies a communication domain; this selects the "
"protocol family which will be used for communication.  These families are "
"defined in I<E<lt>sys/socket.hE<gt>>.  The formats currently understood by "
"the Linux kernel include:"
msgstr ""

#. type: tbl table
#: man-pages/man2/socket.2:69
#, no-wrap
msgid "Name"
msgstr ""

#. type: tbl table
#: man-pages/man2/socket.2:69
#, no-wrap
msgid "Purpose"
msgstr ""

#. type: tbl table
#: man-pages/man2/socket.2:69 man-pages/man2/socketcall.2:48
#, no-wrap
msgid "Man page"
msgstr ""

#. type: tbl table
#: man-pages/man2/socket.2:72
#, no-wrap
msgid "B<AF_UNIX>"
msgstr ""

#. type: tbl table
#: man-pages/man2/socket.2:74
#, no-wrap
msgid "Local communication"
msgstr ""

#. type: tbl table
#: man-pages/man2/socket.2:76
#, no-wrap
msgid "B<unix>(7)"
msgstr ""

#. type: tbl table
#: man-pages/man2/socket.2:79
#, no-wrap
msgid "B<AF_LOCAL>"
msgstr ""

#. type: tbl table
#: man-pages/man2/socket.2:82
#, no-wrap
msgid ""
"Synonym for\n"
"B<AF_UNIX>"
msgstr ""

#. type: tbl table
#: man-pages/man2/socket.2:86
#, no-wrap
msgid "B<AF_INET>"
msgstr ""

#. type: tbl table
#: man-pages/man2/socket.2:86
#, no-wrap
msgid "IPv4 Internet protocols"
msgstr ""

#. type: tbl table
#: man-pages/man2/socket.2:88
#, no-wrap
msgid "B<ip>(7)"
msgstr ""

#. type: tbl table
#: man-pages/man2/socket.2:91
#, no-wrap
msgid "B<AF_AX25>"
msgstr ""

#. type: tbl table
#: man-pages/man2/socket.2:93
#, no-wrap
msgid "Amateur radio AX.25 protocol"
msgstr ""

#.  Part of ax25-tools
#. type: tbl table
#: man-pages/man2/socket.2:96
#, no-wrap
msgid "B<ax25>(4)"
msgstr ""

#. type: tbl table
#: man-pages/man2/socket.2:99
#, no-wrap
msgid "B<AF_IPX>"
msgstr ""

#. type: tbl table
#: man-pages/man2/socket.2:99
#, no-wrap
msgid "IPX - Novell protocols"
msgstr ""

#. type: tbl table
#: man-pages/man2/socket.2:102
#, no-wrap
msgid "B<AF_APPLETALK>"
msgstr ""

#. type: tbl table
#: man-pages/man2/socket.2:102
#, no-wrap
msgid "AppleTalk"
msgstr ""

#. type: tbl table
#: man-pages/man2/socket.2:104
#, no-wrap
msgid "B<ddp>(7)"
msgstr ""

#. type: tbl table
#: man-pages/man2/socket.2:107
#, no-wrap
msgid "B<AF_X25>"
msgstr ""

#. type: tbl table
#: man-pages/man2/socket.2:107
#, no-wrap
msgid "ITU-T X.25 / ISO-8208 protocol"
msgstr ""

#. type: tbl table
#: man-pages/man2/socket.2:109
#, no-wrap
msgid "B<x25>(7)"
msgstr ""

#. type: tbl table
#: man-pages/man2/socket.2:112
#, no-wrap
msgid "B<AF_INET6>"
msgstr ""

#. type: tbl table
#: man-pages/man2/socket.2:112
#, no-wrap
msgid "IPv6 Internet protocols"
msgstr ""

#. type: tbl table
#: man-pages/man2/socket.2:114
#, no-wrap
msgid "B<ipv6>(7)"
msgstr ""

#. type: tbl table
#: man-pages/man2/socket.2:117
#, no-wrap
msgid "B<AF_DECnet>"
msgstr ""

#. type: tbl table
#: man-pages/man2/socket.2:119
#, no-wrap
msgid "DECet protocol sockets"
msgstr ""

#. type: tbl table
#: man-pages/man2/socket.2:122
#, no-wrap
msgid "B<AF_KEY>"
msgstr ""

#. type: tbl table
#: man-pages/man2/socket.2:124
#, no-wrap
msgid "Key management protocol, originally developed for usage with IPsec"
msgstr ""

#. type: tbl table
#: man-pages/man2/socket.2:127
#, no-wrap
msgid "B<AF_NETLINK>"
msgstr ""

#. type: tbl table
#: man-pages/man2/socket.2:129
#, no-wrap
msgid "Kernel user interface device"
msgstr ""

#. type: tbl table
#: man-pages/man2/socket.2:131
#, no-wrap
msgid "B<netlink>(7)"
msgstr ""

#. type: tbl table
#: man-pages/man2/socket.2:134
#, no-wrap
msgid "B<AF_PACKET>"
msgstr ""

#. type: tbl table
#: man-pages/man2/socket.2:136
#, no-wrap
msgid "Low-level packet interface"
msgstr ""

#. type: tbl table
#: man-pages/man2/socket.2:138
#, no-wrap
msgid "B<packet>(7)"
msgstr ""

#. type: tbl table
#: man-pages/man2/socket.2:141
#, no-wrap
msgid "B<AF_RDS>"
msgstr ""

#.  commit: 639b321b4d8f4e412bfbb2a4a19bfebc1e68ace4
#. type: tbl table
#: man-pages/man2/socket.2:144
#, no-wrap
msgid "Reliable Datagram Sockets (RDS) protocol"
msgstr ""

#.  rds-tools: https://github.com/oracle/rds-tools/blob/master/rds.7
#.  rds-tools: https://github.com/oracle/rds-tools/blob/master/rds-rdma.7
#. type: tbl table
#: man-pages/man2/socket.2:148
#, no-wrap
msgid "B<rds>(7)\n"
msgstr ""

#. type: tbl table
#: man-pages/man2/socket.2:148 man-pages/man2/syscalls.2:185
#: man-pages/man2/syscalls.2:190 man-pages/man2/syscalls.2:198
#: man-pages/man2/syscalls.2:208 man-pages/man2/syscalls.2:238
#: man-pages/man2/syscalls.2:250 man-pages/man2/syscalls.2:265
#: man-pages/man2/syscalls.2:319 man-pages/man2/syscalls.2:329
#: man-pages/man2/syscalls.2:331 man-pages/man2/syscalls.2:337
#: man-pages/man2/syscalls.2:352 man-pages/man2/syscalls.2:415
#: man-pages/man2/syscalls.2:438 man-pages/man2/syscalls.2:443
#: man-pages/man2/syscalls.2:448 man-pages/man2/syscalls.2:453
#: man-pages/man2/syscalls.2:501 man-pages/man2/syscalls.2:503
#: man-pages/man2/syscalls.2:512 man-pages/man2/syscalls.2:531
#: man-pages/man2/syscalls.2:551 man-pages/man2/syscalls.2:553
#: man-pages/man2/syscalls.2:555 man-pages/man2/syscalls.2:560
#: man-pages/man2/syscalls.2:579 man-pages/man2/syscalls.2:625
#: man-pages/man2/syscalls.2:637 man-pages/man2/syscalls.2:663
#: man-pages/man2/syscalls.2:692 man-pages/man2/syscalls.2:738
#: man-pages/man2/syscalls.2:743 man-pages/man2/syscalls.2:772
#, no-wrap
msgid ".br\n"
msgstr ""

#. type: tbl table
#: man-pages/man2/socket.2:150
#, no-wrap
msgid "B<rds-rdma>(7)"
msgstr ""

#. type: tbl table
#: man-pages/man2/socket.2:153
#, no-wrap
msgid "B<AF_PPPOX>"
msgstr ""

#. type: tbl table
#: man-pages/man2/socket.2:156
#, no-wrap
msgid ""
"Generic PPP transport layer, for setting up L2 tunnels\n"
"(L2TP and PPPoE)"
msgstr ""

#. type: tbl table
#: man-pages/man2/socket.2:159
#, no-wrap
msgid "B<AF_LLC>"
msgstr ""

#.  linux-history commit: 34beb106cde7da233d4df35dd3d6cf4fee937caa
#. type: tbl table
#: man-pages/man2/socket.2:162
#, no-wrap
msgid "Logical link control (IEEE 802.2 LLC) protocol"
msgstr ""

#. type: tbl table
#: man-pages/man2/socket.2:165
#, no-wrap
msgid "B<AF_IB>"
msgstr ""

#.  commits: 8d36eb01da5d371f..ce117ffac2e93334
#. type: tbl table
#: man-pages/man2/socket.2:168
#, no-wrap
msgid "InfiniBand native addressing"
msgstr ""

#. type: tbl table
#: man-pages/man2/socket.2:171
#, no-wrap
msgid "B<AF_MPLS>"
msgstr ""

#.  commits: 0189197f441602acdca3f97750d392a895b778fd
#. type: tbl table
#: man-pages/man2/socket.2:174
#, no-wrap
msgid "Multiprotocol Label Switching"
msgstr ""

#. type: tbl table
#: man-pages/man2/socket.2:177
#, no-wrap
msgid "B<AF_CAN>"
msgstr ""

#.  commits: 8dbde28d9711475a..5423dd67bd0108a1
#. type: tbl table
#: man-pages/man2/socket.2:180
#, no-wrap
msgid "Controller Area Network automotive bus protocol"
msgstr ""

#. type: tbl table
#: man-pages/man2/socket.2:183
#, no-wrap
msgid "B<AF_TIPC>"
msgstr ""

#.  commits: b97bf3fd8f6a16966d4f18983b2c40993ff937d4
#. type: tbl table
#: man-pages/man2/socket.2:186
#, no-wrap
msgid "TIPC, \"cluster domain sockets\" protocol"
msgstr ""

#. type: tbl table
#: man-pages/man2/socket.2:189
#, no-wrap
msgid "B<AF_BLUETOOTH>"
msgstr ""

#.  commits: 8d36eb01da5d371f..ce117ffac2e93334
#. type: tbl table
#: man-pages/man2/socket.2:192
#, no-wrap
msgid "Bluetooth low-level socket protocol"
msgstr ""

#. type: tbl table
#: man-pages/man2/socket.2:195
#, no-wrap
msgid "B<AF_ALG>"
msgstr ""

#.  commit: 03c8efc1ffeb6b82a22c1af8dd908af349563314
#. type: tbl table
#: man-pages/man2/socket.2:198
#, no-wrap
msgid "Interface to kernel crypto API"
msgstr ""

#. type: tbl table
#: man-pages/man2/socket.2:201
#, no-wrap
msgid "B<AF_VSOCK>"
msgstr ""

#.  commit: d021c344051af91f42c5ba9fdedc176740cbd238
#. type: tbl table
#: man-pages/man2/socket.2:205
#, no-wrap
msgid ""
"VSOCK (originally \"VMWare VSockets\") protocol\n"
"for hypervisor-guest communication"
msgstr ""

#. type: tbl table
#: man-pages/man2/socket.2:207
#, no-wrap
msgid "B<vsock>(7)"
msgstr ""

#. type: tbl table
#: man-pages/man2/socket.2:210
#, no-wrap
msgid "B<AF_KCM>"
msgstr ""

#.  commit: 03c8efc1ffeb6b82a22c1af8dd908af349563314
#. type: tbl table
#: man-pages/man2/socket.2:213
#, no-wrap
msgid "KCM (kernel connection multiplexor) interface"
msgstr ""

#. type: tbl table
#: man-pages/man2/socket.2:216
#, no-wrap
msgid "B<AF_XDP>"
msgstr ""

#.  commit: c0c77d8fb787cfe0c3fca689c2a30d1dad4eaba7
#. type: tbl table
#: man-pages/man2/socket.2:219
#, no-wrap
msgid "XDP (express data path) interface"
msgstr ""

#. type: Plain text
#: man-pages/man2/socket.2:225
msgid ""
"Further details of the above address families, as well as information on "
"several other address families, can be found in B<address_families>(7)."
msgstr ""

#. type: Plain text
#: man-pages/man2/socket.2:231
msgid ""
"The socket has the indicated I<type>, which specifies the communication "
"semantics.  Currently defined types are:"
msgstr ""

#. type: TP
#: man-pages/man2/socket.2:231
#, no-wrap
msgid "B<SOCK_STREAM>"
msgstr ""

#. type: Plain text
#: man-pages/man2/socket.2:235
msgid ""
"Provides sequenced, reliable, two-way, connection-based byte streams.  An "
"out-of-band data transmission mechanism may be supported."
msgstr ""

#. type: TP
#: man-pages/man2/socket.2:235
#, no-wrap
msgid "B<SOCK_DGRAM>"
msgstr ""

#. type: Plain text
#: man-pages/man2/socket.2:239
msgid ""
"Supports datagrams (connectionless, unreliable messages of a fixed maximum "
"length)."
msgstr ""

#. type: TP
#: man-pages/man2/socket.2:239
#, no-wrap
msgid "B<SOCK_SEQPACKET>"
msgstr ""

#. type: Plain text
#: man-pages/man2/socket.2:244
msgid ""
"Provides a sequenced, reliable, two-way connection-based data transmission "
"path for datagrams of fixed maximum length; a consumer is required to read "
"an entire packet with each input system call."
msgstr ""

#. type: TP
#: man-pages/man2/socket.2:244
#, no-wrap
msgid "B<SOCK_RAW>"
msgstr ""

#. type: Plain text
#: man-pages/man2/socket.2:247
msgid "Provides raw network protocol access."
msgstr ""

#. type: TP
#: man-pages/man2/socket.2:247
#, no-wrap
msgid "B<SOCK_RDM>"
msgstr ""

#. type: Plain text
#: man-pages/man2/socket.2:250
msgid "Provides a reliable datagram layer that does not guarantee ordering."
msgstr ""

#. type: TP
#: man-pages/man2/socket.2:250
#, no-wrap
msgid "B<SOCK_PACKET>"
msgstr ""

#. type: Plain text
#: man-pages/man2/socket.2:255
msgid "Obsolete and should not be used in new programs; see B<packet>(7)."
msgstr ""

#. type: Plain text
#: man-pages/man2/socket.2:257
msgid "Some socket types may not be implemented by all protocol families."
msgstr ""

#. type: Plain text
#: man-pages/man2/socket.2:265
msgid ""
"Since Linux 2.6.27, the I<type> argument serves a second purpose: in "
"addition to specifying a socket type, it may include the bitwise OR of any "
"of the following values, to modify the behavior of B<socket>():"
msgstr ""

#. type: TP
#: man-pages/man2/socket.2:265 man-pages/man2/accept.2:150
#, no-wrap
msgid "B<SOCK_NONBLOCK>"
msgstr ""

#. type: TP
#: man-pages/man2/socket.2:275 man-pages/man2/accept.2:160
#, no-wrap
msgid "B<SOCK_CLOEXEC>"
msgstr ""

#. type: Plain text
#: man-pages/man2/socket.2:301
msgid ""
"The I<protocol> specifies a particular protocol to be used with the socket.  "
"Normally only a single protocol exists to support a particular socket type "
"within a given protocol family, in which case I<protocol> can be specified "
"as 0.  However, it is possible that many protocols may exist, in which case "
"a particular protocol must be specified in this manner.  The protocol number "
"to use is specific to the ``communication domain'' in which communication is "
"to take place; see B<protocols>(5).  See B<getprotoent>(3)  on how to map "
"protocol name strings to protocol numbers."
msgstr ""

#. type: Plain text
#: man-pages/man2/socket.2:331
msgid ""
"Sockets of type B<SOCK_STREAM> are full-duplex byte streams.  They do not "
"preserve record boundaries.  A stream socket must be in a I<connected> state "
"before any data may be sent or received on it.  A connection to another "
"socket is created with a B<connect>(2)  call.  Once connected, data may be "
"transferred using B<read>(2)  and B<write>(2)  calls or some variant of the "
"B<send>(2)  and B<recv>(2)  calls.  When a session has been completed a "
"B<close>(2)  may be performed.  Out-of-band data may also be transmitted as "
"described in B<send>(2)  and received as described in B<recv>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/socket.2:357
msgid ""
"The communications protocols which implement a B<SOCK_STREAM> ensure that "
"data is not lost or duplicated.  If a piece of data for which the peer "
"protocol has buffer space cannot be successfully transmitted within a "
"reasonable length of time, then the connection is considered to be dead.  "
"When B<SO_KEEPALIVE> is enabled on the socket the protocol checks in a "
"protocol-specific manner if the other end is still alive.  A B<SIGPIPE> "
"signal is raised if a process sends or receives on a broken stream; this "
"causes naive processes, which do not handle the signal, to exit.  "
"B<SOCK_SEQPACKET> sockets employ the same system calls as B<SOCK_STREAM> "
"sockets.  The only difference is that B<read>(2)  calls will return only the "
"amount of data requested, and any data remaining in the arriving packet will "
"be discarded.  Also all message boundaries in incoming datagrams are "
"preserved."
msgstr ""

#. type: Plain text
#: man-pages/man2/socket.2:367
msgid ""
"B<SOCK_DGRAM> and B<SOCK_RAW> sockets allow sending of datagrams to "
"correspondents named in B<sendto>(2)  calls.  Datagrams are generally "
"received with B<recvfrom>(2), which returns the next datagram along with the "
"address of its sender."
msgstr ""

#. type: Plain text
#: man-pages/man2/socket.2:374
msgid ""
"B<SOCK_PACKET> is an obsolete socket type to receive raw packets directly "
"from the device driver.  Use B<packet>(7)  instead."
msgstr ""

#. type: Plain text
#: man-pages/man2/socket.2:397
msgid ""
"An B<fcntl>(2)  B<F_SETOWN> operation can be used to specify a process or "
"process group to receive a B<SIGURG> signal when the out-of-band data "
"arrives or B<SIGPIPE> signal when a B<SOCK_STREAM> connection breaks "
"unexpectedly.  This operation may also be used to set the process or process "
"group that receives the I/O and asynchronous notification of I/O events via "
"B<SIGIO>.  Using B<F_SETOWN> is equivalent to an B<ioctl>(2)  call with the "
"B<FIOSETOWN> or B<SIOCSPGRP> argument."
msgstr ""

#. type: Plain text
#: man-pages/man2/socket.2:407
msgid ""
"When the network signals an error condition to the protocol module (e.g., "
"using an ICMP message for IP) the pending error flag is set for the socket.  "
"The next operation on this socket will return the error code of the pending "
"error.  For some protocols it is possible to enable a per-socket error queue "
"to retrieve detailed information about the error; see B<IP_RECVERR> in "
"B<ip>(7)."
msgstr ""

#. type: Plain text
#: man-pages/man2/socket.2:417
msgid ""
"The operation of sockets is controlled by socket level I<options>.  These "
"options are defined in I<E<lt>sys/socket.hE<gt>>.  The functions "
"B<setsockopt>(2)  and B<getsockopt>(2)  are used to set and get options."
msgstr ""

#. type: Plain text
#: man-pages/man2/socket.2:422
msgid ""
"On success, a file descriptor for the new socket is returned.  On error, -1 "
"is returned, and I<errno> is set appropriately."
msgstr ""

#. type: Plain text
#: man-pages/man2/socket.2:427
msgid ""
"Permission to create a socket of the specified type and/or protocol is "
"denied."
msgstr ""

#. type: Plain text
#: man-pages/man2/socket.2:430
msgid "The implementation does not support the specified address family."
msgstr ""

#. type: Plain text
#: man-pages/man2/socket.2:433
msgid "Unknown protocol, or protocol family not available."
msgstr ""

#.  Since Linux 2.6.27
#. type: Plain text
#: man-pages/man2/socket.2:438
msgid "Invalid flags in I<type>."
msgstr ""

#. type: TP
#: man-pages/man2/socket.2:444
#, no-wrap
msgid "B<ENOBUFS> or B<ENOMEM>"
msgstr ""

#. type: Plain text
#: man-pages/man2/socket.2:449
msgid ""
"Insufficient memory is available.  The socket cannot be created until "
"sufficient resources are freed."
msgstr ""

#. type: Plain text
#: man-pages/man2/socket.2:453
msgid ""
"The protocol type or the specified protocol is not supported within this "
"domain."
msgstr ""

#. type: Plain text
#: man-pages/man2/socket.2:455
msgid "Other errors may be generated by the underlying protocol modules."
msgstr ""

#. type: Plain text
#: man-pages/man2/socket.2:457
msgid "POSIX.1-2001, POSIX.1-2008, 4.4BSD."
msgstr ""

#. type: Plain text
#: man-pages/man2/socket.2:463
msgid "The B<SOCK_NONBLOCK> and B<SOCK_CLOEXEC> flags are Linux-specific."
msgstr ""

#. type: Plain text
#: man-pages/man2/socket.2:469
msgid ""
"B<socket>()  appeared in 4.2BSD.  It is generally portable to/from non-BSD "
"systems supporting clones of the BSD socket layer (including System\\ V "
"variants)."
msgstr ""

#. type: Plain text
#: man-pages/man2/socket.2:488
msgid ""
"The manifest constants used under 4.x BSD for protocol families are "
"B<PF_UNIX>, B<PF_INET>, and so on, while B<AF_UNIX>, B<AF_INET>, and so on "
"are used for address families.  However, already the BSD man page promises: "
"\"The protocol family generally is the same as the address family\", and "
"subsequent standards use AF_* everywhere."
msgstr ""

#. type: Plain text
#: man-pages/man2/socket.2:493
msgid "An example of the use of B<socket>()  is shown in B<getaddrinfo>(3)."
msgstr ""

#. type: Plain text
#: man-pages/man2/socket.2:518
msgid ""
"B<accept>(2), B<bind>(2), B<close>(2), B<connect>(2), B<fcntl>(2), "
"B<getpeername>(2), B<getsockname>(2), B<getsockopt>(2), B<ioctl>(2), "
"B<listen>(2), B<read>(2), B<recv>(2), B<select>(2), B<send>(2), "
"B<shutdown>(2), B<socketpair>(2), B<write>(2), B<getprotoent>(3), "
"B<address_families>(7), B<ip>(7), B<socket>(7), B<tcp>(7), B<udp>(7), "
"B<unix>(7)"
msgstr ""

#. type: Plain text
#: man-pages/man2/socket.2:523
msgid ""
"\\(lqAn Introductory 4.3BSD Interprocess Communication Tutorial\\(rq and "
"\\(lqBSD Interprocess Communication Tutorial\\(rq, reprinted in I<UNIX "
"Programmer's Supplementary Documents Volume 1.>"
msgstr ""

#. type: TH
#: man-pages/man2/select_tut.2:32
#, no-wrap
msgid "SELECT_TUT"
msgstr ""

#. type: Plain text
#: man-pages/man2/select_tut.2:36 man-pages/man2/select.2:42
msgid ""
"select, pselect, FD_CLR, FD_ISSET, FD_SET, FD_ZERO - synchronous I/O "
"multiplexing"
msgstr ""

#. type: Plain text
#: man-pages/man2/select_tut.2:40 man-pages/man2/select.2:46
#, no-wrap
msgid ""
"/* According to POSIX.1-2001, POSIX.1-2008 */\n"
"B<#include E<lt>sys/select.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/select_tut.2:45 man-pages/man2/select.2:51
#, no-wrap
msgid ""
"/* According to earlier standards */\n"
"B<#include E<lt>sys/time.hE<gt>>\n"
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>unistd.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/select_tut.2:48
#, no-wrap
msgid ""
"B<int select(int >I<nfds>B<, fd_set *>I<readfds>B<, fd_set "
"*>I<writefds>B<,>\n"
"B<           fd_set *>I<exceptfds>B<, struct timeval *>I<utimeout>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/select_tut.2:53 man-pages/man2/select.2:59
#, no-wrap
msgid ""
"B<void FD_CLR(int >I<fd>B<, fd_set *>I<set>B<);>\n"
"B<int  FD_ISSET(int >I<fd>B<, fd_set *>I<set>B<);>\n"
"B<void FD_SET(int >I<fd>B<, fd_set *>I<set>B<);>\n"
"B<void FD_ZERO(fd_set *>I<set>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/select_tut.2:55 man-pages/man2/select.2:61
#, no-wrap
msgid "B<#include E<lt>sys/select.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/select_tut.2:59
#, no-wrap
msgid ""
"B<int pselect(int >I<nfds>B<, fd_set *>I<readfds>B<, fd_set "
"*>I<writefds>B<,>\n"
"B<            fd_set *>I<exceptfds>B<, const struct timespec "
"*>I<ntimeout>B<,>\n"
"B<            const sigset_t *>I<sigmask>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/select_tut.2:68 man-pages/man2/select.2:74
msgid "B<pselect>(): _POSIX_C_SOURCE\\ E<gt>=\\ 200112L"
msgstr ""

#. type: Plain text
#: man-pages/man2/select_tut.2:76
msgid ""
"B<select>()  (or B<pselect>())  is used to efficiently monitor multiple file "
"descriptors, to see if any of them is, or becomes, \"ready\"; that is, to "
"see whether I/O becomes possible, or an \"exceptional condition\" has "
"occurred on any of the file descriptors."
msgstr ""

#. type: Plain text
#: man-pages/man2/select_tut.2:101
msgid ""
"Its principal arguments are three \"sets\" of file descriptors: I<readfds>, "
"I<writefds>, and I<exceptfds>.  Each set is declared as type I<fd_set>, and "
"its contents can be manipulated with the macros B<FD_CLR>(), B<FD_ISSET>(), "
"B<FD_SET>(), and B<FD_ZERO>().  A newly declared set should first be cleared "
"using B<FD_ZERO>().  B<select>()  modifies the contents of the sets "
"according to the rules described below; after calling B<select>()  you can "
"test if a file descriptor is still present in a set with the B<FD_ISSET>()  "
"macro.  B<FD_ISSET>()  returns nonzero if a specified file descriptor is "
"present in a set and zero if it is not.  B<FD_CLR>()  removes a file "
"descriptor from a set."
msgstr ""

#. type: SS
#: man-pages/man2/select_tut.2:101 man-pages/man2/perf_event_open.2:76
#: man-pages/man2/bpf.2:134 man-pages/man2/futex.2:148
#, no-wrap
msgid "Arguments"
msgstr ""

#. type: TP
#: man-pages/man2/select_tut.2:102
#, no-wrap
msgid "I<readfds>"
msgstr ""

#. type: Plain text
#: man-pages/man2/select_tut.2:111
msgid ""
"This set is watched to see if data is available for reading from any of its "
"file descriptors.  After B<select>()  has returned, I<readfds> will be "
"cleared of all file descriptors except for those that are immediately "
"available for reading."
msgstr ""

#. type: TP
#: man-pages/man2/select_tut.2:111
#, no-wrap
msgid "I<writefds>"
msgstr ""

#. type: Plain text
#: man-pages/man2/select_tut.2:120
msgid ""
"This set is watched to see if there is space to write data to any of its "
"file descriptors.  After B<select>()  has returned, I<writefds> will be "
"cleared of all file descriptors except for those that are immediately "
"available for writing."
msgstr ""

#. type: TP
#: man-pages/man2/select_tut.2:120
#, no-wrap
msgid "I<exceptfds>"
msgstr ""

#. type: Plain text
#: man-pages/man2/select_tut.2:142
msgid ""
"This set is watched for \"exceptional conditions\".  In practice, only one "
"such exceptional condition is common: the availability of I<out-of-band> "
"(OOB) data for reading from a TCP socket.  See B<recv>(2), B<send>(2), and "
"B<tcp>(7)  for more details about OOB data.  (One other less common case "
"where B<select>(2)  indicates an exceptional condition occurs with "
"pseudoterminals in packet mode; see B<ioctl_tty>(2).)  After B<select>()  "
"has returned, I<exceptfds> will be cleared of all file descriptors except "
"for those for which an exceptional condition has occurred."
msgstr ""

#. type: TP
#: man-pages/man2/select_tut.2:142
#, no-wrap
msgid "I<nfds>"
msgstr ""

#. type: Plain text
#: man-pages/man2/select_tut.2:149
msgid ""
"This is an integer one more than the maximum of any file descriptor in any "
"of the sets.  In other words, while adding file descriptors to each of the "
"sets, you must calculate the maximum integer value of all of them, then "
"increment this value by one, and then pass this as I<nfds>."
msgstr ""

#. type: TP
#: man-pages/man2/select_tut.2:149
#, no-wrap
msgid "I<utimeout>"
msgstr ""

#. type: Plain text
#: man-pages/man2/select_tut.2:162
msgid ""
"This is the longest time B<select>()  may wait before returning, even if "
"nothing interesting happened.  If this value is passed as NULL, then "
"B<select>()  blocks indefinitely waiting for a file descriptor to become "
"ready.  I<utimeout> can be set to zero seconds, which causes B<select>()  to "
"return immediately, with information about the readiness of file descriptors "
"at the time of the call.  The structure I<struct timeval> is defined as:"
msgstr ""

#. type: Plain text
#: man-pages/man2/select_tut.2:169
#, no-wrap
msgid ""
"struct timeval {\n"
"    time_t tv_sec;    /* seconds */\n"
"    long tv_usec;     /* microseconds */\n"
"};\n"
msgstr ""

#. type: TP
#: man-pages/man2/select_tut.2:171
#, no-wrap
msgid "I<ntimeout>"
msgstr ""

#. type: Plain text
#: man-pages/man2/select_tut.2:180
msgid ""
"This argument for B<pselect>()  has the same meaning as I<utimeout>, but "
"I<struct timespec> has nanosecond precision as follows:"
msgstr ""

#. type: Plain text
#: man-pages/man2/select_tut.2:187
#, no-wrap
msgid ""
"struct timespec {\n"
"    long tv_sec;    /* seconds */\n"
"    long tv_nsec;   /* nanoseconds */\n"
"};\n"
msgstr ""

#. type: TP
#: man-pages/man2/select_tut.2:189
#, no-wrap
msgid "I<sigmask>"
msgstr ""

#. type: Plain text
#: man-pages/man2/select_tut.2:206
msgid ""
"This argument holds a set of signals that the kernel should unblock (i.e., "
"remove from the signal mask of the calling thread), while the caller is "
"blocked inside the B<pselect>()  call (see B<sigaddset>(3)  and "
"B<sigprocmask>(2)).  It may be NULL, in which case the call does not modify "
"the signal mask on entry and exit to the function.  In this case, "
"B<pselect>()  will then behave just like B<select>()."
msgstr ""

#. type: SS
#: man-pages/man2/select_tut.2:206
#, no-wrap
msgid "Combining signal and data events"
msgstr ""

#. type: Plain text
#: man-pages/man2/select_tut.2:250
msgid ""
"B<pselect>()  is useful if you are waiting for a signal as well as for file "
"descriptor(s) to become ready for I/O.  Programs that receive signals "
"normally use the signal handler only to raise a global flag.  The global "
"flag will indicate that the event must be processed in the main loop of the "
"program.  A signal will cause the B<select>()  (or B<pselect>())  call to "
"return with I<errno> set to B<EINTR>.  This behavior is essential so that "
"signals can be processed in the main loop of the program, otherwise "
"B<select>()  would block indefinitely.  Now, somewhere in the main loop will "
"be a conditional to check the global flag.  So we must ask: what if a signal "
"arrives after the conditional, but before the B<select>()  call? The answer "
"is that B<select>()  would block indefinitely, even though an event is "
"actually pending.  This race condition is solved by the B<pselect>()  call.  "
"This call can be used to set the signal mask to a set of signals that are to "
"be received only within the B<pselect>()  call.  For instance, let us say "
"that the event in question was the exit of a child process.  Before the "
"start of the main loop, we would block B<SIGCHLD> using B<sigprocmask>(2).  "
"Our B<pselect>()  call would enable B<SIGCHLD> by using an empty signal "
"mask.  Our program would look like:"
msgstr ""

#. type: Plain text
#: man-pages/man2/select_tut.2:253
#, no-wrap
msgid "static volatile sig_atomic_t got_SIGCHLD = 0;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/select_tut.2:259
#, no-wrap
msgid ""
"static void\n"
"child_sig_handler(int sig)\n"
"{\n"
"    got_SIGCHLD = 1;\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/select_tut.2:267
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    sigset_t sigmask, empty_mask;\n"
"    struct sigaction sa;\n"
"    fd_set readfds, writefds, exceptfds;\n"
"    int r;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/select_tut.2:274
#, no-wrap
msgid ""
"    sigemptyset(&sigmask);\n"
"    sigaddset(&sigmask, SIGCHLD);\n"
"    if (sigprocmask(SIG_BLOCK, &sigmask, NULL) == -1) {\n"
"        perror(\"sigprocmask\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/select_tut.2:282
#, no-wrap
msgid ""
"    sa.sa_flags = 0;\n"
"    sa.sa_handler = child_sig_handler;\n"
"    sigemptyset(&sa.sa_mask);\n"
"    if (sigaction(SIGCHLD, &sa, NULL) == -1) {\n"
"        perror(\"sigaction\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/select_tut.2:284
#, no-wrap
msgid "    sigemptyset(&empty_mask);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/select_tut.2:288
#, no-wrap
msgid ""
"    for (;;) {          /* main loop */\n"
"        /* Initialize readfds, writefds, and exceptfds\n"
"           before the pselect() call. (Code omitted.) */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/select_tut.2:294
#, no-wrap
msgid ""
"        r = pselect(nfds, &readfds, &writefds, &exceptfds,\n"
"                    NULL, &empty_mask);\n"
"        if (r == -1 && errno != EINTR) {\n"
"            /* Handle error */\n"
"        }\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/select_tut.2:297
#, no-wrap
msgid ""
"        if (got_SIGCHLD) {\n"
"            got_SIGCHLD = 0;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/select_tut.2:301
#, no-wrap
msgid ""
"            /* Handle signalled event here; e.g., wait() for all\n"
"               terminated children. (Code omitted.) */\n"
"        }\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/select_tut.2:305
#, no-wrap
msgid ""
"        /* main body of program */\n"
"    }\n"
"}\n"
msgstr ""

#. type: SS
#: man-pages/man2/select_tut.2:306
#, no-wrap
msgid "Practical"
msgstr ""

#. type: Plain text
#: man-pages/man2/select_tut.2:327
msgid ""
"So what is the point of B<select>()? Can't I just read and write to my file "
"descriptors whenever I want? The point of B<select>()  is that it watches "
"multiple descriptors at the same time and properly puts the process to sleep "
"if there is no activity.  UNIX programmers often find themselves in a "
"position where they have to handle I/O from more than one file descriptor "
"where the data flow may be intermittent.  If you were to merely create a "
"sequence of B<read>(2)  and B<write>(2)  calls, you would find that one of "
"your calls may block waiting for data from/to a file descriptor, while "
"another file descriptor is unused though ready for I/O.  B<select>()  "
"efficiently copes with this situation."
msgstr ""

#. type: SS
#: man-pages/man2/select_tut.2:327
#, no-wrap
msgid "Select law"
msgstr ""

#. type: Plain text
#: man-pages/man2/select_tut.2:340
msgid ""
"Many people who try to use B<select>()  come across behavior that is "
"difficult to understand and produces nonportable or borderline results.  For "
"instance, the above program is carefully written not to block at any point, "
"even though it does not set its file descriptors to nonblocking mode.  It is "
"easy to introduce subtle errors that will remove the advantage of using "
"B<select>(), so here is a list of essentials to watch for when using "
"B<select>()."
msgstr ""

#. type: Plain text
#: man-pages/man2/select_tut.2:349
msgid ""
"You should always try to use B<select>()  without a timeout.  Your program "
"should have nothing to do if there is no data available.  Code that depends "
"on timeouts is not usually portable and is difficult to debug."
msgstr ""

#. type: Plain text
#: man-pages/man2/select_tut.2:353
msgid ""
"The value I<nfds> must be properly calculated for efficiency as explained "
"above."
msgstr ""

#. type: Plain text
#: man-pages/man2/select_tut.2:360
msgid ""
"No file descriptor must be added to any set if you do not intend to check "
"its result after the B<select>()  call, and respond appropriately.  See next "
"rule."
msgstr ""

#. type: Plain text
#: man-pages/man2/select_tut.2:366
msgid ""
"After B<select>()  returns, all file descriptors in all sets should be "
"checked to see if they are ready."
msgstr ""

#. type: Plain text
#: man-pages/man2/select_tut.2:381
msgid ""
"The functions B<read>(2), B<recv>(2), B<write>(2), and B<send>(2)  do I<not> "
"necessarily read/write the full amount of data that you have requested.  If "
"they do read/write the full amount, it's because you have a low traffic load "
"and a fast stream.  This is not always going to be the case.  You should "
"cope with the case of your functions managing to send or receive only a "
"single byte."
msgstr ""

#. type: IP
#: man-pages/man2/select_tut.2:381 man-pages/man2/ptrace.2:2626
#, no-wrap
msgid "6."
msgstr ""

#. type: Plain text
#: man-pages/man2/select_tut.2:389
msgid ""
"Never read/write only in single bytes at a time unless you are really sure "
"that you have a small amount of data to process.  It is extremely "
"inefficient not to read/write as much data as you can buffer each time.  The "
"buffers in the example below are 1024 bytes although they could easily be "
"made larger."
msgstr ""

#. type: TP
#: man-pages/man2/select_tut.2:389
#, no-wrap
msgid "7."
msgstr ""

#.  Nonetheless, you should still cope with these errors for completeness.
#. type: Plain text
#: man-pages/man2/select_tut.2:415
msgid ""
"Calls to B<read>(2), B<recv>(2), B<write>(2), B<send>(2), and B<select>()  "
"can fail with the error B<EINTR>, and calls to B<read>(2), B<recv>(2)  "
"B<write>(2), and B<send>(2)  can fail with I<errno> set to B<EAGAIN> "
"(B<EWOULDBLOCK>).  These results must be properly managed (not done properly "
"above).  If your program is not going to receive any signals, then it is "
"unlikely you will get B<EINTR>.  If your program does not set nonblocking "
"I/O, you will not get B<EAGAIN>."
msgstr ""

#. type: TP
#: man-pages/man2/select_tut.2:415
#, no-wrap
msgid "8."
msgstr ""

#. type: Plain text
#: man-pages/man2/select_tut.2:424
msgid ""
"Never call B<read>(2), B<recv>(2), B<write>(2), or B<send>(2)  with a buffer "
"length of zero."
msgstr ""

#. type: TP
#: man-pages/man2/select_tut.2:424
#, no-wrap
msgid "9."
msgstr ""

#. type: Plain text
#: man-pages/man2/select_tut.2:440
msgid ""
"If the functions B<read>(2), B<recv>(2), B<write>(2), and B<send>(2)  fail "
"with errors other than those listed in B<7.>, or one of the input functions "
"returns 0, indicating end of file, then you should I<not> pass that file "
"descriptor to B<select>()  again.  In the example below, I close the file "
"descriptor immediately, and then set it to -1 to prevent it being included "
"in a set."
msgstr ""

#. type: TP
#: man-pages/man2/select_tut.2:440
#, no-wrap
msgid "10."
msgstr ""

#. type: Plain text
#: man-pages/man2/select_tut.2:447
msgid ""
"The timeout value must be initialized with each new call to B<select>(), "
"since some operating systems modify the structure.  B<pselect>()  however "
"does not modify its timeout structure."
msgstr ""

#. type: TP
#: man-pages/man2/select_tut.2:447
#, no-wrap
msgid "11."
msgstr ""

#.  "I have heard" does not fill me with confidence, and doesn't
#.  belong in a man page, so I've commented this point out.
#.  .TP
#.  11.
#.  I have heard that the Windows socket layer does not cope with OOB data
#.  properly.
#.  It also does not cope with
#.  .BR select ()
#.  calls when no file descriptors are set at all.
#.  Having no file descriptors set is a useful
#.  way to sleep the process with subsecond precision by using the timeout.
#.  (See further on.)
#. type: Plain text
#: man-pages/man2/select_tut.2:466
msgid ""
"Since B<select>()  modifies its file descriptor sets, if the call is being "
"used in a loop, then the sets must be reinitialized before each call."
msgstr ""

#. type: SS
#: man-pages/man2/select_tut.2:466
#, no-wrap
msgid "Usleep emulation"
msgstr ""

#. type: Plain text
#: man-pages/man2/select_tut.2:473
msgid ""
"On systems that do not have a B<usleep>(3)  function, you can call "
"B<select>()  with a finite timeout and no file descriptors as follows:"
msgstr ""

#. type: Plain text
#: man-pages/man2/select_tut.2:480
#, no-wrap
msgid ""
"struct timeval tv;\n"
"tv.tv_sec = 0;\n"
"tv.tv_usec = 200000;  /* 0.2 seconds */\n"
"select(0, NULL, NULL, NULL, &tv);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/select_tut.2:484
msgid "This is guaranteed to work only on UNIX systems, however."
msgstr ""

#. type: Plain text
#: man-pages/man2/select_tut.2:489
msgid ""
"On success, B<select>()  returns the total number of file descriptors still "
"present in the file descriptor sets."
msgstr ""

#. type: Plain text
#: man-pages/man2/select_tut.2:495
msgid ""
"If B<select>()  timed out, then the return value will be zero.  The file "
"descriptors set should be all empty (but may not be on some systems)."
msgstr ""

#. type: Plain text
#: man-pages/man2/select_tut.2:502
msgid ""
"A return value of -1 indicates an error, with I<errno> being set "
"appropriately.  In the case of an error, the contents of the returned sets "
"and the I<struct timeout> contents are undefined and should not be used.  "
"B<pselect>()  however never modifies I<ntimeout>."
msgstr ""

#. type: Plain text
#: man-pages/man2/select_tut.2:511
msgid ""
"Generally speaking, all operating systems that support sockets also support "
"B<select>().  B<select>()  can be used to solve many problems in a portable "
"and efficient way that naive programmers try to solve in a more complicated "
"manner using threads, forking, IPCs, signals, memory sharing, and so on."
msgstr ""

#. type: Plain text
#: man-pages/man2/select_tut.2:520
msgid ""
"The B<poll>(2)  system call has the same functionality as B<select>(), and "
"is somewhat more efficient when monitoring sparse file descriptor sets.  It "
"is nowadays widely available, but historically was less portable than "
"B<select>()."
msgstr ""

#. type: Plain text
#: man-pages/man2/select_tut.2:528
msgid ""
"The Linux-specific B<epoll>(7)  API provides an interface that is more "
"efficient than B<select>(2)  and B<poll>(2)  when monitoring large numbers "
"of file descriptors."
msgstr ""

#. type: Plain text
#: man-pages/man2/select_tut.2:533
msgid ""
"Here is an example that better demonstrates the true utility of "
"B<select>().  The listing below is a TCP forwarding program that forwards "
"from one TCP port to another."
msgstr ""

#. type: Plain text
#: man-pages/man2/select_tut.2:546
#, no-wrap
msgid ""
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>sys/time.hE<gt>\n"
"#include E<lt>sys/types.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>signal.hE<gt>\n"
"#include E<lt>sys/socket.hE<gt>\n"
"#include E<lt>netinet/in.hE<gt>\n"
"#include E<lt>arpa/inet.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/select_tut.2:548
#, no-wrap
msgid "static int forward_port;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/select_tut.2:551
#, no-wrap
msgid ""
"#undef max\n"
"#define max(x,y) ((x) E<gt> (y) ? (x) : (y))\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/select_tut.2:558
#, no-wrap
msgid ""
"static int\n"
"listen_socket(int listen_port)\n"
"{\n"
"    struct sockaddr_in addr;\n"
"    int lfd;\n"
"    int yes;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/select_tut.2:564
#, no-wrap
msgid ""
"    lfd = socket(AF_INET, SOCK_STREAM, 0);\n"
"    if (lfd == -1) {\n"
"        perror(\"socket\");\n"
"        return -1;\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/select_tut.2:572
#, no-wrap
msgid ""
"    yes = 1;\n"
"    if (setsockopt(lfd, SOL_SOCKET, SO_REUSEADDR,\n"
"            &yes, sizeof(yes)) == -1) {\n"
"        perror(\"setsockopt\");\n"
"        close(lfd);\n"
"        return -1;\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/select_tut.2:581
#, no-wrap
msgid ""
"    memset(&addr, 0, sizeof(addr));\n"
"    addr.sin_port = htons(listen_port);\n"
"    addr.sin_family = AF_INET;\n"
"    if (bind(lfd, (struct sockaddr *) &addr, sizeof(addr)) == -1) {\n"
"        perror(\"bind\");\n"
"        close(lfd);\n"
"        return -1;\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/select_tut.2:586
#, no-wrap
msgid ""
"    printf(\"accepting connections on port %d\\en\", listen_port);\n"
"    listen(lfd, 10);\n"
"    return lfd;\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/select_tut.2:592
#, no-wrap
msgid ""
"static int\n"
"connect_socket(int connect_port, char *address)\n"
"{\n"
"    struct sockaddr_in addr;\n"
"    int cfd;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/select_tut.2:598
#, no-wrap
msgid ""
"    cfd = socket(AF_INET, SOCK_STREAM, 0);\n"
"    if (cfd == -1) {\n"
"        perror(\"socket\");\n"
"        return -1;\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/select_tut.2:602
#, no-wrap
msgid ""
"    memset(&addr, 0, sizeof(addr));\n"
"    addr.sin_port = htons(connect_port);\n"
"    addr.sin_family = AF_INET;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/select_tut.2:608
#, no-wrap
msgid ""
"    if (!inet_aton(address, (struct in_addr *) &addr.sin_addr.s_addr)) {\n"
"        fprintf(stderr, \"inet_aton(): bad IP address format\\en\");\n"
"        close(cfd);\n"
"        return -1;\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/select_tut.2:617
#, no-wrap
msgid ""
"    if (connect(cfd, (struct sockaddr *) &addr, sizeof(addr)) == -1) {\n"
"        perror(\"connect()\");\n"
"        shutdown(cfd, SHUT_RDWR);\n"
"        close(cfd);\n"
"        return -1;\n"
"    }\n"
"    return cfd;\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/select_tut.2:625
#, no-wrap
msgid ""
"#define SHUT_FD1 do {                                \\e\n"
"                     if (fd1 E<gt>= 0) {                 \\e\n"
"                         shutdown(fd1, SHUT_RDWR);   \\e\n"
"                         close(fd1);                 \\e\n"
"                         fd1 = -1;                   \\e\n"
"                     }                               \\e\n"
"                 } while (0)\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/select_tut.2:633
#, no-wrap
msgid ""
"#define SHUT_FD2 do {                                \\e\n"
"                     if (fd2 E<gt>= 0) {                 \\e\n"
"                         shutdown(fd2, SHUT_RDWR);   \\e\n"
"                         close(fd2);                 \\e\n"
"                         fd2 = -1;                   \\e\n"
"                     }                               \\e\n"
"                 } while (0)\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/select_tut.2:644
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int h;\n"
"    int fd1 = -1, fd2 = -1;\n"
"    char buf1[BUF_SIZE], buf2[BUF_SIZE];\n"
"    int buf1_avail = 0, buf1_written = 0;\n"
"    int buf2_avail = 0, buf2_written = 0;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/select_tut.2:650
#, no-wrap
msgid ""
"    if (argc != 4) {\n"
"        fprintf(stderr, \"Usage\\en\\etfwd E<lt>listen-portE<gt> \"\n"
"                 \"E<lt>forward-to-portE<gt> "
"E<lt>forward-to-ip-addressE<gt>\\en\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/select_tut.2:652
#, no-wrap
msgid "    signal(SIGPIPE, SIG_IGN);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/select_tut.2:654
#, no-wrap
msgid "    forward_port = atoi(argv[2]);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/select_tut.2:658
#, no-wrap
msgid ""
"    h = listen_socket(atoi(argv[1]));\n"
"    if (h == -1)\n"
"        exit(EXIT_FAILURE);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/select_tut.2:663
#, no-wrap
msgid ""
"    for (;;) {\n"
"        int ready, nfds = 0;\n"
"        ssize_t nbytes;\n"
"        fd_set readfds, writefds, exceptfds;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/select_tut.2:669
#, no-wrap
msgid ""
"        FD_ZERO(&readfds);\n"
"        FD_ZERO(&writefds);\n"
"        FD_ZERO(&exceptfds);\n"
"        FD_SET(h, &readfds);\n"
"        nfds = max(nfds, h);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/select_tut.2:676
#, no-wrap
msgid ""
"        if (fd1 E<gt> 0 && buf1_avail E<lt> BUF_SIZE)\n"
"            FD_SET(fd1, &readfds);\n"
"            /* Note: nfds is updated below, when fd1 is added to\n"
"               exceptfds. */\n"
"        if (fd2 E<gt> 0 && buf2_avail E<lt> BUF_SIZE)\n"
"            FD_SET(fd2, &readfds);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/select_tut.2:681
#, no-wrap
msgid ""
"        if (fd1 E<gt> 0 && buf2_avail - buf2_written E<gt> 0)\n"
"            FD_SET(fd1, &writefds);\n"
"        if (fd2 E<gt> 0 && buf1_avail - buf1_written E<gt> 0)\n"
"            FD_SET(fd2, &writefds);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/select_tut.2:690
#, no-wrap
msgid ""
"        if (fd1 E<gt> 0) {\n"
"            FD_SET(fd1, &exceptfds);\n"
"            nfds = max(nfds, fd1);\n"
"        }\n"
"        if (fd2 E<gt> 0) {\n"
"            FD_SET(fd2, &exceptfds);\n"
"            nfds = max(nfds, fd2);\n"
"        }\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/select_tut.2:692
#, no-wrap
msgid "        ready = select(nfds + 1, &readfds, &writefds, &exceptfds, NULL);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/select_tut.2:695
#, no-wrap
msgid ""
"        if (ready == -1 && errno == EINTR)\n"
"            continue;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/select_tut.2:700
#, no-wrap
msgid ""
"        if (ready == -1) {\n"
"            perror(\"select()\");\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/select_tut.2:705
#, no-wrap
msgid ""
"        if (FD_ISSET(h, &readfds)) {\n"
"            socklen_t addrlen;\n"
"            struct sockaddr_in client_addr;\n"
"            int fd;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/select_tut.2:723
#, no-wrap
msgid ""
"            addrlen = sizeof(client_addr);\n"
"            memset(&client_addr, 0, addrlen);\n"
"            fd = accept(h, (struct sockaddr *) &client_addr, &addrlen);\n"
"            if (fd == -1) {\n"
"                perror(\"accept()\");\n"
"            } else {\n"
"                SHUT_FD1;\n"
"                SHUT_FD2;\n"
"                buf1_avail = buf1_written = 0;\n"
"                buf2_avail = buf2_written = 0;\n"
"                fd1 = fd;\n"
"                fd2 = connect_socket(forward_port, argv[3]);\n"
"                if (fd2 == -1)\n"
"                    SHUT_FD1;\n"
"                else\n"
"                    printf(\"connect from %s\\en\",\n"
"                            inet_ntoa(client_addr.sin_addr));\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/select_tut.2:728
#, no-wrap
msgid ""
"                /* Skip any events on the old, closed file descriptors. */\n"
"                continue;\n"
"            }\n"
"        }\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/select_tut.2:730
#, no-wrap
msgid "        /* NB: read OOB data before normal reads */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/select_tut.2:733
#, no-wrap
msgid ""
"        if (fd1 E<gt> 0 && FD_ISSET(fd1, &exceptfds)) {\n"
"            char c;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/select_tut.2:742
#, no-wrap
msgid ""
"            nbytes = recv(fd1, &c, 1, MSG_OOB);\n"
"            if (nbytes E<lt> 1)\n"
"                SHUT_FD1;\n"
"            else\n"
"                send(fd2, &c, 1, MSG_OOB);\n"
"        }\n"
"        if (fd2 E<gt> 0 && FD_ISSET(fd2, &exceptfds)) {\n"
"            char c;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/select_tut.2:781
#, no-wrap
msgid ""
"            nbytes = recv(fd2, &c, 1, MSG_OOB);\n"
"            if (nbytes E<lt> 1)\n"
"                SHUT_FD2;\n"
"            else\n"
"                send(fd1, &c, 1, MSG_OOB);\n"
"        }\n"
"        if (fd1 E<gt> 0 && FD_ISSET(fd1, &readfds)) {\n"
"            nbytes = read(fd1, buf1 + buf1_avail,\n"
"                      BUF_SIZE - buf1_avail);\n"
"            if (nbytes E<lt> 1)\n"
"                SHUT_FD1;\n"
"            else\n"
"                buf1_avail += nbytes;\n"
"        }\n"
"        if (fd2 E<gt> 0 && FD_ISSET(fd2, &readfds)) {\n"
"            nbytes = read(fd2, buf2 + buf2_avail,\n"
"                      BUF_SIZE - buf2_avail);\n"
"            if (nbytes E<lt> 1)\n"
"                SHUT_FD2;\n"
"            else\n"
"                buf2_avail += nbytes;\n"
"        }\n"
"        if (fd1 E<gt> 0 && FD_ISSET(fd1, &writefds) && buf2_avail E<gt> 0) "
"{\n"
"            nbytes = write(fd1, buf2 + buf2_written,\n"
"                       buf2_avail - buf2_written);\n"
"            if (nbytes E<lt> 1)\n"
"                SHUT_FD1;\n"
"            else\n"
"                buf2_written += nbytes;\n"
"        }\n"
"        if (fd2 E<gt> 0 && FD_ISSET(fd2, &writefds) && buf1_avail E<gt> 0) "
"{\n"
"            nbytes = write(fd2, buf1 + buf1_written,\n"
"                       buf1_avail - buf1_written);\n"
"            if (nbytes E<lt> 1)\n"
"                SHUT_FD2;\n"
"            else\n"
"                buf1_written += nbytes;\n"
"        }\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/select_tut.2:783
#, no-wrap
msgid "        /* Check if write data has caught read data */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/select_tut.2:788
#, no-wrap
msgid ""
"        if (buf1_written == buf1_avail)\n"
"            buf1_written = buf1_avail = 0;\n"
"        if (buf2_written == buf2_avail)\n"
"            buf2_written = buf2_avail = 0;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/select_tut.2:791
#, no-wrap
msgid ""
"        /* One side has closed the connection, keep\n"
"           writing to the other side until empty */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/select_tut.2:799
#, no-wrap
msgid ""
"        if (fd1 E<lt> 0 && buf1_avail - buf1_written == 0)\n"
"            SHUT_FD2;\n"
"        if (fd2 E<lt> 0 && buf2_avail - buf2_written == 0)\n"
"            SHUT_FD1;\n"
"    }\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/select_tut.2:813
msgid ""
"The above program properly forwards most kinds of TCP connections including "
"OOB signal data transmitted by B<telnet> servers.  It handles the tricky "
"problem of having data flow in both directions simultaneously.  You might "
"think it more efficient to use a B<fork>(2)  call and devote a thread to "
"each stream.  This becomes more tricky than you might suspect.  Another idea "
"is to set nonblocking I/O using B<fcntl>(2).  This also has its problems "
"because you end up using inefficient timeouts."
msgstr ""

#. type: Plain text
#: man-pages/man2/select_tut.2:819
msgid ""
"The program does not handle more than one simultaneous connection at a time, "
"although it could easily be extended to do this with a linked list of "
"buffers\\(emone for each connection.  At the moment, new connections cause "
"the current connection to be dropped."
msgstr ""

#. type: Plain text
#: man-pages/man2/select_tut.2:835
msgid ""
"B<accept>(2), B<connect>(2), B<ioctl>(2), B<poll>(2), B<read>(2), "
"B<recv>(2), B<select>(2), B<send>(2), B<sigprocmask>(2), B<write>(2), "
"B<sigaddset>(3), B<sigdelset>(3), B<sigemptyset>(3), B<sigfillset>(3), "
"B<sigismember>(3), B<epoll>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/chroot.2:33
#, no-wrap
msgid "CHROOT"
msgstr ""

#. type: Plain text
#: man-pages/man2/chroot.2:36
msgid "chroot - change root directory"
msgstr ""

#. type: Plain text
#: man-pages/man2/chroot.2:40
msgid "B<int chroot(const char *>I<path>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/chroot.2:47
msgid "B<chroot>():"
msgstr ""

#. type: TP
#: man-pages/man2/chroot.2:50
#, no-wrap
msgid "Since glibc 2.2.2:"
msgstr ""

#. type: Plain text
#: man-pages/man2/chroot.2:56
#, no-wrap
msgid ""
"_XOPEN_SOURCE && ! (_POSIX_C_SOURCE\\ E<gt>=\\ 200112L)\n"
"    || /* Since glibc 2.20: */ _DEFAULT_SOURCE\n"
"    || /* Glibc versions E<lt>= 2.19: */ _BSD_SOURCE\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/chroot.2:59
msgid "Before glibc 2.2.2: none"
msgstr ""

#. type: Plain text
#: man-pages/man2/chroot.2:68
msgid ""
"B<chroot>()  changes the root directory of the calling process to that "
"specified in I<path>.  This directory will be used for pathnames beginning "
"with I</>.  The root directory is inherited by all children of the calling "
"process."
msgstr ""

#. type: Plain text
#: man-pages/man2/chroot.2:73
msgid ""
"Only a privileged process (Linux: one with the B<CAP_SYS_CHROOT> capability "
"in its user namespace) may call B<chroot>()."
msgstr ""

#. type: Plain text
#: man-pages/man2/chroot.2:90
msgid ""
"This call changes an ingredient in the pathname resolution process and does "
"nothing else.  In particular, it is not intended to be used for any kind of "
"security purpose, neither to fully sandbox a process nor to restrict "
"filesystem system calls.  In the past, B<chroot>()  has been used by daemons "
"to restrict themselves prior to passing paths supplied by untrusted users to "
"system calls such as B<open>(2).  However, if a folder is moved out of the "
"chroot directory, an attacker can exploit that to get out of the chroot "
"directory as well.  The easiest way to do that is to B<chdir>(2)  to the "
"to-be-moved directory, wait for it to be moved out, then open a path like "
"../../../etc/passwd."
msgstr ""

#.  This is how the "slightly trickier variation" works:
#.  https://github.com/QubesOS/qubes-secpack/blob/master/QSBs/qsb-014-2015.txt#L142
#. type: Plain text
#: man-pages/man2/chroot.2:101
msgid ""
"A slightly trickier variation also works under some circumstances if "
"B<chdir>(2)  is not permitted.  If a daemon allows a \"chroot directory\" to "
"be specified, that usually means that if you want to prevent remote users "
"from accessing files outside the chroot directory, you must ensure that "
"folders are never moved out of it."
msgstr ""

#. type: Plain text
#: man-pages/man2/chroot.2:107
msgid ""
"This call does not change the current working directory, so that after the "
"call \\(aqI<.>\\(aq can be outside the tree rooted at \\(aqI</>\\(aq.  In "
"particular, the superuser can escape from a \"chroot jail\" by doing:"
msgstr ""

#. type: Plain text
#: man-pages/man2/chroot.2:111
#, no-wrap
msgid "mkdir foo; chroot foo; cd ..\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/chroot.2:116
msgid ""
"This call does not close open file descriptors, and such file descriptors "
"may allow access to files outside the chroot tree."
msgstr ""

#. type: Plain text
#: man-pages/man2/chroot.2:124
msgid ""
"Depending on the filesystem, other errors can be returned.  The more general "
"errors are listed below:"
msgstr ""

#. type: Plain text
#: man-pages/man2/chroot.2:135 man-pages/man2/chdir.2:91
msgid "I<path> points outside your accessible address space."
msgstr ""

#. type: Plain text
#: man-pages/man2/chroot.2:138 man-pages/man2/access.2:248
#: man-pages/man2/chmod.2:269 man-pages/man2/chdir.2:94
#: man-pages/man2/unlink.2:185 man-pages/man2/symlink.2:171
#: man-pages/man2/link.2:217 man-pages/man2/execve.2:474
#: man-pages/man2/close.2:87
msgid "An I/O error occurred."
msgstr ""

#. type: Plain text
#: man-pages/man2/chroot.2:142 man-pages/man2/chdir.2:98
msgid "Too many symbolic links were encountered in resolving I<path>."
msgstr ""

#. type: Plain text
#: man-pages/man2/chroot.2:146 man-pages/man2/chdir.2:102
msgid "I<path> is too long."
msgstr ""

#. type: Plain text
#: man-pages/man2/chroot.2:149 man-pages/man2/chmod.2:280
#: man-pages/man2/chown.2:257
msgid "The file does not exist."
msgstr ""

#. type: Plain text
#: man-pages/man2/chroot.2:157 man-pages/man2/chdir.2:115
msgid "A component of I<path> is not a directory."
msgstr ""

#. type: Plain text
#: man-pages/man2/chroot.2:160
msgid "The caller has insufficient privilege."
msgstr ""

#.  SVr4 documents additional EINTR, ENOLINK and EMULTIHOP error conditions.
#.  X/OPEN does not document EIO, ENOMEM or EFAULT error conditions.
#. type: Plain text
#: man-pages/man2/chroot.2:165
msgid ""
"SVr4, 4.4BSD, SUSv2 (marked LEGACY).  This function is not part of "
"POSIX.1-2001."
msgstr ""

#. type: Plain text
#: man-pages/man2/chroot.2:171
msgid ""
"A child process created via B<fork>(2)  inherits its parent's root "
"directory.  The root directory is left unchanged by B<execve>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/chroot.2:177
msgid ""
"The magic symbolic link, I</proc/[pid]/root>, can be used to discover a "
"process's root directory; see B<proc>(5)  for details."
msgstr ""

#. type: Plain text
#: man-pages/man2/chroot.2:181
msgid "FreeBSD has a stronger B<jail>()  system call."
msgstr ""

#. type: Plain text
#: man-pages/man2/chroot.2:186
msgid ""
"B<chroot>(1), B<chdir>(2), B<pivot_root>(2), B<path_resolution>(7), "
"B<switch_root>(8)"
msgstr ""

#. type: TH
#: man-pages/man2/shmget.2:38
#, no-wrap
msgid "SHMGET"
msgstr ""

#. type: Plain text
#: man-pages/man2/shmget.2:41
msgid "shmget - allocates a System V shared memory segment"
msgstr ""

#. type: Plain text
#: man-pages/man2/shmget.2:44 man-pages/man2/shmctl.2:52
msgid "B<#include E<lt>sys/ipc.hE<gt>>"
msgstr ""

#. type: Plain text
#: man-pages/man2/shmget.2:46 man-pages/man2/shmctl.2:54
msgid "B<#include E<lt>sys/shm.hE<gt>>"
msgstr ""

#. type: Plain text
#: man-pages/man2/shmget.2:48
msgid "B<int shmget(key_t >I<key>B<, size_t >I<size>B<, int >I<shmflg>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/shmget.2:62
msgid ""
"B<shmget>()  returns the identifier of the System\\ V shared memory segment "
"associated with the value of the argument I<key>.  It may be used either to "
"obtain the identifier of a previously created shared memory segment (when "
"I<shmflg> is zero and I<key> does not have the value B<IPC_PRIVATE>), or to "
"create a new set."
msgstr ""

#. type: Plain text
#: man-pages/man2/shmget.2:81
msgid ""
"A new shared memory segment, with size equal to the value of I<size> rounded "
"up to a multiple of B<PAGE_SIZE>, is created if I<key> has the value "
"B<IPC_PRIVATE> or I<key> isn't B<IPC_PRIVATE>, no shared memory segment "
"corresponding to I<key> exists, and B<IPC_CREAT> is specified in I<shmflg>."
msgstr ""

#. type: Plain text
#: man-pages/man2/shmget.2:100
msgid ""
"If I<shmflg> specifies both B<IPC_CREAT> and B<IPC_EXCL> and a shared memory "
"segment already exists for I<key>, then B<shmget>()  fails with I<errno> set "
"to B<EEXIST>.  (This is analogous to the effect of the combination B<O_CREAT "
"| O_EXCL> for B<open>(2).)"
msgstr ""

#. type: Plain text
#: man-pages/man2/shmget.2:104
msgid "The value I<shmflg> is composed of:"
msgstr ""

#. type: TP
#: man-pages/man2/shmget.2:104
#, no-wrap
msgid "B<IPC_CREAT>"
msgstr ""

#. type: Plain text
#: man-pages/man2/shmget.2:111
msgid ""
"Create a new segment.  If this flag is not used, then B<shmget>()  will find "
"the segment associated with I<key> and check to see if the user has "
"permission to access the segment."
msgstr ""

#. type: TP
#: man-pages/man2/shmget.2:111
#, no-wrap
msgid "B<IPC_EXCL>"
msgstr ""

#. type: Plain text
#: man-pages/man2/shmget.2:117
msgid ""
"This flag is used with B<IPC_CREAT> to ensure that this call creates the "
"segment.  If the segment already exists, the call fails."
msgstr ""

#. type: TP
#: man-pages/man2/shmget.2:117
#, no-wrap
msgid "B<SHM_HUGETLB> (since Linux 2.6)"
msgstr ""

#. type: Plain text
#: man-pages/man2/shmget.2:123
msgid ""
"Allocate the segment using \"huge pages.\" See the Linux kernel source file "
"I<Documentation/admin-guide/mm/hugetlbpage.rst> for further information."
msgstr ""

#. type: TP
#: man-pages/man2/shmget.2:123
#, no-wrap
msgid "B<SHM_HUGE_2MB>, B<SHM_HUGE_1GB> (since Linux 3.8)"
msgstr ""

#.  See https://lwn.net/Articles/533499/
#. type: Plain text
#: man-pages/man2/shmget.2:130
msgid ""
"Used in conjunction with B<SHM_HUGETLB> to select alternative hugetlb page "
"sizes (respectively, 2\\ MB and 1\\ GB)  on systems that support multiple "
"hugetlb page sizes."
msgstr ""

#. type: Plain text
#: man-pages/man2/shmget.2:135
msgid ""
"More generally, the desired huge page size can be configured by encoding the "
"base-2 logarithm of the desired page size in the six bits at the offset "
"B<SHM_HUGE_SHIFT>.  Thus, the above two constants are defined as:"
msgstr ""

#. type: Plain text
#: man-pages/man2/shmget.2:140
#, no-wrap
msgid ""
"#define SHM_HUGE_2MB    (21 E<lt>E<lt> SHM_HUGE_SHIFT)\n"
"#define SHM_HUGE_1GB    (30 E<lt>E<lt> SHM_HUGE_SHIFT)\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/shmget.2:146
msgid ""
"For some additional details, see the discussion of the similarly named "
"constants in B<mmap>(2)."
msgstr ""

#. type: TP
#: man-pages/man2/shmget.2:146
#, no-wrap
msgid "B<SHM_NORESERVE> (since Linux 2.6.15)"
msgstr ""

#.  As at 2.6.17-rc2, this flag has no effect if SHM_HUGETLB was also
#.  specified.
#. type: Plain text
#: man-pages/man2/shmget.2:165
msgid ""
"This flag serves the same purpose as the B<mmap>(2)  B<MAP_NORESERVE> flag.  "
"Do not reserve swap space for this segment.  When swap space is reserved, "
"one has the guarantee that it is possible to modify the segment.  When swap "
"space is not reserved one might get B<SIGSEGV> upon a write if no physical "
"memory is available.  See also the discussion of the file "
"I</proc/sys/vm/overcommit_memory> in B<proc>(5)."
msgstr ""

#. type: Plain text
#: man-pages/man2/shmget.2:175
msgid ""
"In addition to the above flags, the least significant 9 bits of I<shmflg> "
"specify the permissions granted to the owner, group, and others.  These bits "
"have the same format, and the same meaning, as the I<mode> argument of "
"B<open>(2).  Presently, execute permissions are not used by the system."
msgstr ""

#. type: Plain text
#: man-pages/man2/shmget.2:183
msgid ""
"When a new shared memory segment is created, its contents are initialized to "
"zero values, and its associated data structure, I<shmid_ds> (see "
"B<shmctl>(2)), is initialized as follows:"
msgstr ""

#. type: Plain text
#: man-pages/man2/shmget.2:188
msgid ""
"I<shm_perm.cuid> and I<shm_perm.uid> are set to the effective user ID of the "
"calling process."
msgstr ""

#. type: Plain text
#: man-pages/man2/shmget.2:193
msgid ""
"I<shm_perm.cgid> and I<shm_perm.gid> are set to the effective group ID of "
"the calling process."
msgstr ""

#. type: Plain text
#: man-pages/man2/shmget.2:198
msgid ""
"The least significant 9 bits of I<shm_perm.mode> are set to the least "
"significant 9 bit of I<shmflg>."
msgstr ""

#. type: Plain text
#: man-pages/man2/shmget.2:202
msgid "I<shm_segsz> is set to the value of I<size>."
msgstr ""

#. type: Plain text
#: man-pages/man2/shmget.2:209
msgid "I<shm_lpid>, I<shm_nattch>, I<shm_atime>, and I<shm_dtime> are set to 0."
msgstr ""

#. type: Plain text
#: man-pages/man2/shmget.2:212
msgid "I<shm_ctime> is set to the current time."
msgstr ""

#. type: Plain text
#: man-pages/man2/shmget.2:215
msgid ""
"If the shared memory segment already exists, the permissions are verified, "
"and a check is made to see if it is marked for destruction."
msgstr ""

#. type: Plain text
#: man-pages/man2/shmget.2:220
msgid ""
"On success, a valid shared memory identifier is returned.  On error, -1 is "
"returned, and I<errno> is set to indicate the error."
msgstr ""

#. type: Plain text
#: man-pages/man2/shmget.2:224 man-pages/man2/msgctl.2:276
#: man-pages/man2/semop.2:312
msgid "On failure, I<errno> is set to one of the following:"
msgstr ""

#. type: Plain text
#: man-pages/man2/shmget.2:230
msgid ""
"The user does not have permission to access the shared memory segment, and "
"does not have the B<CAP_IPC_OWNER> capability in the user namespace that "
"governs its IPC namespace."
msgstr ""

#. type: Plain text
#: man-pages/man2/shmget.2:239
msgid ""
"B<IPC_CREAT> and B<IPC_EXCL> were specified in I<shmflg>, but a shared "
"memory segment already exists for I<key>."
msgstr ""

#. type: Plain text
#: man-pages/man2/shmget.2:247
msgid ""
"A new segment was to be created and I<size> is less than B<SHMMIN> or "
"greater than B<SHMMAX>."
msgstr ""

#. type: Plain text
#: man-pages/man2/shmget.2:253
msgid ""
"A segment for the given I<key> exists, but I<size> is greater than the size "
"of that segment."
msgstr ""

#. type: Plain text
#: man-pages/man2/shmget.2:262
msgid "No segment exists for the given I<key>, and B<IPC_CREAT> was not specified."
msgstr ""

#. type: Plain text
#: man-pages/man2/shmget.2:265
msgid "No memory could be allocated for segment overhead."
msgstr ""

#. type: Plain text
#: man-pages/man2/shmget.2:273
msgid ""
"All possible shared memory IDs have been taken (B<SHMMNI>), or allocating a "
"segment of the requested I<size> would cause the system to exceed the "
"system-wide limit on shared memory (B<SHMALL>)."
msgstr ""

#. type: Plain text
#: man-pages/man2/shmget.2:280
msgid ""
"The B<SHM_HUGETLB> flag was specified, but the caller was not privileged "
"(did not have the B<CAP_IPC_LOCK> capability)."
msgstr ""

#. type: Plain text
#: man-pages/man2/shmget.2:288
msgid "B<SHM_HUGETLB> and B<SHM_NORESERVE> are Linux extensions."
msgstr ""

#. type: Plain text
#: man-pages/man2/shmget.2:312
msgid ""
"B<IPC_PRIVATE> isn't a flag field but a I<key_t> type.  If this special "
"value is used for I<key>, the system call ignores all but the least "
"significant 9 bits of I<shmflg> and creates a new shared memory segment."
msgstr ""

#. type: SS
#: man-pages/man2/shmget.2:312
#, no-wrap
msgid "Shared memory limits"
msgstr ""

#. type: Plain text
#: man-pages/man2/shmget.2:316
msgid ""
"The following limits on shared memory segment resources affect the "
"B<shmget>()  call:"
msgstr ""

#. type: TP
#: man-pages/man2/shmget.2:316
#, no-wrap
msgid "B<SHMALL>"
msgstr ""

#. type: Plain text
#: man-pages/man2/shmget.2:320
msgid ""
"System-wide limit on the total amount of shared memory, measured in units of "
"the system page size."
msgstr ""

#.  commit 060028bac94bf60a65415d1d55a359c3a17d5c31
#. type: Plain text
#: man-pages/man2/shmget.2:326
msgid ""
"On Linux, this limit can be read and modified via "
"I</proc/sys/kernel/shmall>.  Since Linux 3.16, the default value for this "
"limit is:"
msgstr ""

#. type: Plain text
#: man-pages/man2/shmget.2:328 man-pages/man2/shmget.2:363
#, no-wrap
msgid "    ULONG_MAX - 2^24\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/shmget.2:339
msgid ""
"The effect of this value (which is suitable for both 32-bit and 64-bit "
"systems)  is to impose no limitation on allocations.  This value, rather "
"than B<ULONG_MAX>, was chosen as the default to prevent some cases where "
"historical applications simply raised the existing limit without first "
"checking its current value.  Such applications would cause the value to "
"overflow if the limit was set at B<ULONG_MAX>."
msgstr ""

#. type: Plain text
#: man-pages/man2/shmget.2:342
msgid "From Linux 2.4 up to Linux 3.15, the default value for this limit was:"
msgstr ""

#. type: Plain text
#: man-pages/man2/shmget.2:344
#, no-wrap
msgid "    SHMMAX / PAGE_SIZE * (SHMMNI / 16)\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/shmget.2:352
msgid ""
"If B<SHMMAX> and B<SHMMNI> were not modified, then multiplying the result of "
"this formula by the page size (to get a value in bytes) yielded a value of "
"8\\ GB as the limit on the total memory used by all shared memory segments."
msgstr ""

#. type: TP
#: man-pages/man2/shmget.2:352
#, no-wrap
msgid "B<SHMMAX>"
msgstr ""

#. type: Plain text
#: man-pages/man2/shmget.2:355
msgid "Maximum size in bytes for a shared memory segment."
msgstr ""

#.  commit 060028bac94bf60a65415d1d55a359c3a17d5c31
#. type: Plain text
#: man-pages/man2/shmget.2:361
msgid ""
"On Linux, this limit can be read and modified via "
"I</proc/sys/kernel/shmmax>.  Since Linux 3.16, the default value for this "
"limit is:"
msgstr ""

#. type: Plain text
#: man-pages/man2/shmget.2:372
msgid ""
"The effect of this value (which is suitable for both 32-bit and 64-bit "
"systems)  is to impose no limitation on allocations.  See the description of "
"B<SHMALL> for a discussion of why this default value (rather than "
"B<ULONG_MAX>)  is used."
msgstr ""

#. type: Plain text
#: man-pages/man2/shmget.2:375
msgid ""
"From Linux 2.2 up to Linux 3.15, the default value of this limit was "
"0x2000000 (32\\ MB)."
msgstr ""

#. type: Plain text
#: man-pages/man2/shmget.2:381
msgid ""
"Because it is not possible to map just part of a shared memory segment, the "
"amount of virtual memory places another limit on the maximum size of a "
"usable segment: for example, on i386 the largest segments that can be mapped "
"have a size of around 2.8\\ GB, and on x86-64 the limit is around 127 TB."
msgstr ""

#. type: TP
#: man-pages/man2/shmget.2:381
#, no-wrap
msgid "B<SHMMIN>"
msgstr ""

#. type: Plain text
#: man-pages/man2/shmget.2:387
msgid ""
"Minimum size in bytes for a shared memory segment: implementation dependent "
"(currently 1 byte, though B<PAGE_SIZE> is the effective minimum size)."
msgstr ""

#. type: TP
#: man-pages/man2/shmget.2:387
#, no-wrap
msgid "B<SHMMNI>"
msgstr ""

#. type: Plain text
#: man-pages/man2/shmget.2:392
msgid ""
"System-wide limit on the number of shared memory segments.  In Linux 2.2, "
"the default value for this limit was 128; since Linux 2.4, the default value "
"is 4096."
msgstr ""

#.  Kernels between 2.4.x and 2.6.8 had an off-by-one error that meant
#.  that we could create one more segment than SHMMNI -- MTK
#.  This /proc file is not available in Linux 2.2 and earlier -- MTK
#. type: Plain text
#: man-pages/man2/shmget.2:398
msgid ""
"On Linux, this limit can be read and modified via "
"I</proc/sys/kernel/shmmni>."
msgstr ""

#. type: Plain text
#: man-pages/man2/shmget.2:402
msgid ""
"The implementation has no specific limits for the per-process maximum number "
"of shared memory segments (B<SHMSEG>)."
msgstr ""

#. type: Plain text
#: man-pages/man2/shmget.2:408
msgid ""
"Until version 2.3.30, Linux would return B<EIDRM> for a B<shmget>()  on a "
"shared memory segment scheduled for deletion."
msgstr ""

#. type: Plain text
#: man-pages/man2/shmget.2:422
msgid ""
"B<memfd_create>(2), B<shmat>(2), B<shmctl>(2), B<shmdt>(2), B<ftok>(3), "
"B<capabilities>(7), B<shm_overview>(7), B<sysvipc>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/getxattr.2:25
#, no-wrap
msgid "GETXATTR"
msgstr ""

#. type: Plain text
#: man-pages/man2/getxattr.2:28
msgid "getxattr, lgetxattr, fgetxattr - retrieve an extended attribute value"
msgstr ""

#. type: Plain text
#: man-pages/man2/getxattr.2:33 man-pages/man2/setxattr.2:33
#: man-pages/man2/removexattr.2:33 man-pages/man2/listxattr.2:34
#, no-wrap
msgid ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>sys/xattr.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/getxattr.2:40
#, no-wrap
msgid ""
"B<ssize_t getxattr(const char\\ *>I<path>B<, const char\\ *>I<name>B<,>\n"
"B<                 void\\ *>I<value>B<, size_t >I<size>B<);>\n"
"B<ssize_t lgetxattr(const char\\ *>I<path>B<, const char\\ *>I<name>B<,>\n"
"B<                 void\\ *>I<value>B<, size_t >I<size>B<);>\n"
"B<ssize_t fgetxattr(int >I<fd>B<, const char\\ *>I<name>B<,>\n"
"B<                 void\\ *>I<value>B<, size_t >I<size>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/getxattr.2:53 man-pages/man2/setxattr.2:53
#: man-pages/man2/removexattr.2:49 man-pages/man2/listxattr.2:52
msgid ""
"Extended attributes are I<name>:I<value> pairs associated with inodes "
"(files, directories, symbolic links, etc.).  They are extensions to the "
"normal attributes which are associated with all inodes in the system (i.e., "
"the B<stat>(2)  data).  A complete overview of extended attributes concepts "
"can be found in B<xattr>(7)."
msgstr ""

#. type: Plain text
#: man-pages/man2/getxattr.2:66
msgid ""
"B<getxattr>()  retrieves the value of the extended attribute identified by "
"I<name> and associated with the given I<path> in the filesystem.  The "
"attribute value is placed in the buffer pointed to by I<value>; I<size> "
"specifies the size of that buffer.  The return value of the call is the "
"number of bytes placed in I<value>."
msgstr ""

#. type: Plain text
#: man-pages/man2/getxattr.2:72
msgid ""
"B<lgetxattr>()  is identical to B<getxattr>(), except in the case of a "
"symbolic link, where the link itself is interrogated, not the file that it "
"refers to."
msgstr ""

#. type: Plain text
#: man-pages/man2/getxattr.2:82
msgid ""
"B<fgetxattr>()  is identical to B<getxattr>(), only the open file referred "
"to by I<fd> (as returned by B<open>(2))  is interrogated in place of "
"I<path>."
msgstr ""

#. type: Plain text
#: man-pages/man2/getxattr.2:91
msgid ""
"An extended attribute I<name> is a null-terminated string.  The name "
"includes a namespace prefix; there may be several, disjoint namespaces "
"associated with an individual inode.  The value of an extended attribute is "
"a chunk of arbitrary textual or binary data that was assigned using "
"B<setxattr>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/getxattr.2:104
msgid ""
"If I<size> is specified as zero, these calls return the current size of the "
"named extended attribute (and leave I<value> unchanged).  This can be used "
"to determine the size of the buffer that should be supplied in a subsequent "
"call.  (But, bear in mind that there is a possibility that the attribute "
"value may change between the two calls, so that it is still necessary to "
"check the return status from the second call.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/getxattr.2:110
msgid ""
"On success, these calls return a nonnegative value which is the size (in "
"bytes) of the extended attribute value.  On failure, -1 is returned and "
"I<errno> is set appropriately."
msgstr ""

#. type: Plain text
#: man-pages/man2/getxattr.2:117
msgid ""
"The size of the attribute value is larger than the maximum size allowed; the "
"attribute cannot be retrieved.  This can happen on filesystems that support "
"very large attribute values such as NFSv4, for example."
msgstr ""

#. type: TP
#: man-pages/man2/getxattr.2:117 man-pages/man2/setxattr.2:123
#: man-pages/man2/removexattr.2:84
#, no-wrap
msgid "B<ENODATA>"
msgstr ""

#.  .RB ( ENOATTR
#.  is defined to be a synonym for
#.  .BR ENODATA
#.  in
#.  .IR <attr/attributes.h> .)
#. type: Plain text
#: man-pages/man2/getxattr.2:126
msgid ""
"The named attribute does not exist, or the process has no access to this "
"attribute."
msgstr ""

#. type: TP
#: man-pages/man2/getxattr.2:126 man-pages/man2/setxattr.2:135
#: man-pages/man2/setxattr.2:140 man-pages/man2/removexattr.2:92
#: man-pages/man2/chmod.2:339 man-pages/man2/listxattr.2:140
#, no-wrap
msgid "B<ENOTSUP>"
msgstr ""

#. type: Plain text
#: man-pages/man2/getxattr.2:129 man-pages/man2/removexattr.2:95
#: man-pages/man2/listxattr.2:143
msgid "Extended attributes are not supported by the filesystem, or are disabled."
msgstr ""

#. type: TP
#: man-pages/man2/getxattr.2:129 man-pages/man2/setxattr.2:152
#: man-pages/man2/prctl.2:1769 man-pages/man2/listxattr.2:143
#: man-pages/man2/quotactl.2:740 man-pages/man2/lookup_dcookie.2:70
#: man-pages/man2/semctl.2:467 man-pages/man2/semop.2:371
#, no-wrap
msgid "B<ERANGE>"
msgstr ""

#. type: Plain text
#: man-pages/man2/getxattr.2:136
msgid "The I<size> of the I<value> buffer is too small to hold the result."
msgstr ""

#. type: Plain text
#: man-pages/man2/getxattr.2:140 man-pages/man2/setxattr.2:152
#: man-pages/man2/removexattr.2:99 man-pages/man2/listxattr.2:154
msgid "In addition, the errors documented in B<stat>(2)  can also occur."
msgstr ""

#. type: Plain text
#: man-pages/man2/getxattr.2:143 man-pages/man2/setxattr.2:162
#: man-pages/man2/removexattr.2:102 man-pages/man2/listxattr.2:157
msgid ""
"These system calls have been available on Linux since kernel 2.4; glibc "
"support is provided since version 2.3."
msgstr ""

#. type: Plain text
#: man-pages/man2/getxattr.2:151 man-pages/man2/setxattr.2:170
#: man-pages/man2/removexattr.2:110 man-pages/man2/kexec_load.2:337
#: man-pages/man2/rt_sigqueueinfo.2:190 man-pages/man2/ioprio_set.2:201
#: man-pages/man2/listxattr.2:165 man-pages/man2/capget.2:224
#: man-pages/man2/sgetmask.2:75 man-pages/man2/timerfd_create.2:470
#: man-pages/man2/inotify_init.2:108 man-pages/man2/sched_setaffinity.2:167
msgid "These system calls are Linux-specific."
msgstr ""

#. type: Plain text
#: man-pages/man2/getxattr.2:154
msgid "See B<listxattr>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/getxattr.2:163
msgid ""
"B<getfattr>(1), B<setfattr>(1), B<listxattr>(2), B<open>(2), "
"B<removexattr>(2), B<setxattr>(2), B<stat>(2), B<symlink>(7), B<xattr>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/io_destroy.2:7
#, no-wrap
msgid "IO_DESTROY"
msgstr ""

#. type: Plain text
#: man-pages/man2/io_destroy.2:10
msgid "io_destroy - destroy an asynchronous I/O context"
msgstr ""

#. type: Plain text
#: man-pages/man2/io_destroy.2:15
#, no-wrap
msgid "B<int io_destroy(aio_context_t >I<ctx_id>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/io_destroy.2:29
msgid ""
"The B<io_destroy>()  system call will attempt to cancel all outstanding "
"asynchronous I/O operations against I<ctx_id>, will block on the completion "
"of all operations that could not be canceled, and will destroy the "
"I<ctx_id>."
msgstr ""

#. type: Plain text
#: man-pages/man2/io_destroy.2:34
msgid "On success, B<io_destroy>()  returns 0.  For the failure return, see NOTES."
msgstr ""

#. type: Plain text
#: man-pages/man2/io_destroy.2:38
msgid "The context pointed to is invalid."
msgstr ""

#. type: Plain text
#: man-pages/man2/io_destroy.2:45
msgid "B<io_destroy>()  is not implemented on this architecture."
msgstr ""

#. type: Plain text
#: man-pages/man2/io_destroy.2:53
msgid ""
"B<io_destroy>()  is Linux-specific and should not be used in programs that "
"are intended to be portable."
msgstr ""

#.  http://git.fedorahosted.org/git/?p=libaio.git
#. type: Plain text
#: man-pages/man2/io_destroy.2:62
msgid ""
"Glibc does not provide a wrapper function for this system call.  You could "
"invoke it using B<syscall>(2).  But instead, you probably want to use the "
"B<io_destroy>()  wrapper function provided by I<libaio>."
msgstr ""

#. type: Plain text
#: man-pages/man2/io_destroy.2:88
msgid ""
"B<io_cancel>(2), B<io_getevents>(2), B<io_setup>(2), B<io_submit>(2), "
"B<aio>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/setxattr.2:25
#, no-wrap
msgid "SETXATTR"
msgstr ""

#. type: Plain text
#: man-pages/man2/setxattr.2:28
msgid "setxattr, lsetxattr, fsetxattr - set an extended attribute value"
msgstr ""

#. type: Plain text
#: man-pages/man2/setxattr.2:40
#, no-wrap
msgid ""
"B<int setxattr(const char\\ *>I<path>B<, const char\\ *>I<name>B<,>\n"
"B<              const void\\ *>I<value>B<, size_t >I<size>B<, int "
">I<flags>B<);>\n"
"B<int lsetxattr(const char\\ *>I<path>B<, const char\\ *>I<name>B<,>\n"
"B<              const void\\ *>I<value>B<, size_t >I<size>B<, int "
">I<flags>B<);>\n"
"B<int fsetxattr(int >I<fd>B<, const char\\ *>I<name>B<,>\n"
"B<              const void\\ *>I<value>B<, size_t >I<size>B<, int "
">I<flags>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/setxattr.2:67
msgid ""
"B<setxattr>()  sets the I<value> of the extended attribute identified by "
"I<name> and associated with the given I<path> in the filesystem.  The "
"I<size> argument specifies the size (in bytes) of I<value>; a zero-length "
"value is permitted."
msgstr ""

#. type: Plain text
#: man-pages/man2/setxattr.2:73
msgid ""
"B<lsetxattr>()  is identical to B<setxattr>(), except in the case of a "
"symbolic link, where the extended attribute is set on the link itself, not "
"the file that it refers to."
msgstr ""

#. type: Plain text
#: man-pages/man2/setxattr.2:83
msgid ""
"B<fsetxattr>()  is identical to B<setxattr>(), only the extended attribute "
"is set on the open file referred to by I<fd> (as returned by B<open>(2))  in "
"place of I<path>."
msgstr ""

#. type: Plain text
#: man-pages/man2/setxattr.2:93
msgid ""
"An extended attribute name is a null-terminated string.  The I<name> "
"includes a namespace prefix; there may be several, disjoint namespaces "
"associated with an individual inode.  The I<value> of an extended attribute "
"is a chunk of arbitrary textual or binary data of specified length."
msgstr ""

#. type: Plain text
#: man-pages/man2/setxattr.2:102
msgid ""
"By default (i.e., I<flags> is zero), the extended attribute will be created "
"if it does not exist, or the value will be replaced if the attribute already "
"exists.  To modify these semantics, one of the following values can be "
"specified in I<flags>:"
msgstr ""

#. type: TP
#: man-pages/man2/setxattr.2:102
#, no-wrap
msgid "B<XATTR_CREATE>"
msgstr ""

#. type: Plain text
#: man-pages/man2/setxattr.2:105
msgid "Perform a pure create, which fails if the named attribute exists already."
msgstr ""

#. type: TP
#: man-pages/man2/setxattr.2:105
#, no-wrap
msgid "B<XATTR_REPLACE>"
msgstr ""

#. type: Plain text
#: man-pages/man2/setxattr.2:109
msgid ""
"Perform a pure replace operation, which fails if the named attribute does "
"not already exist."
msgstr ""

#. type: Plain text
#: man-pages/man2/setxattr.2:114 man-pages/man2/removexattr.2:83
msgid ""
"On success, zero is returned.  On failure, -1 is returned and I<errno> is "
"set appropriately."
msgstr ""

#. type: Plain text
#: man-pages/man2/setxattr.2:119
msgid ""
"Disk quota limits meant that there is insufficient space remaining to store "
"the extended attribute."
msgstr ""

#. type: Plain text
#: man-pages/man2/setxattr.2:123
msgid "B<XATTR_CREATE> was specified, and the attribute exists already."
msgstr ""

#.  .RB ( ENOATTR
#.  is defined to be a synonym for
#.  .BR ENODATA
#.  in
#.  .IR <attr/attributes.h> .)
#. type: Plain text
#: man-pages/man2/setxattr.2:132
msgid "B<XATTR_REPLACE> was specified, and the attribute does not exist."
msgstr ""

#. type: Plain text
#: man-pages/man2/setxattr.2:135
msgid "There is insufficient space remaining to store the extended attribute."
msgstr ""

#. type: Plain text
#: man-pages/man2/setxattr.2:140
msgid "The namespace prefix of I<name> is not valid."
msgstr ""

#. type: Plain text
#: man-pages/man2/setxattr.2:143
msgid "Extended attributes are not supported by the filesystem, or are disabled,"
msgstr ""

#. type: Plain text
#: man-pages/man2/setxattr.2:148 man-pages/man2/chmod.2:297
#: man-pages/man2/chown.2:272
msgid "The file is marked immutable or append-only.  (See B<ioctl_iflags>(2).)"
msgstr ""

#. type: Plain text
#: man-pages/man2/setxattr.2:159
msgid "The size of I<name> or I<value> exceeds a filesystem-specific limit."
msgstr ""

#. type: Plain text
#: man-pages/man2/setxattr.2:179
msgid ""
"B<getfattr>(1), B<setfattr>(1), B<getxattr>(2), B<listxattr>(2), B<open>(2), "
"B<removexattr>(2), B<stat>(2), B<symlink>(7), B<xattr>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/removexattr.2:25
#, no-wrap
msgid "REMOVEXATTR"
msgstr ""

#. type: Plain text
#: man-pages/man2/removexattr.2:28
msgid "removexattr, lremovexattr, fremovexattr - remove an extended attribute"
msgstr ""

#. type: Plain text
#: man-pages/man2/removexattr.2:37
#, no-wrap
msgid ""
"B<int removexattr(const char\\ *>I<path>B<, const char\\ *>I<name>B<);>\n"
"B<int lremovexattr(const char\\ *>I<path>B<, const char\\ *>I<name>B<);>\n"
"B<int fremovexattr(int >I<fd>B<, const char\\ *>I<name>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/removexattr.2:56
msgid ""
"B<removexattr>()  removes the extended attribute identified by I<name> and "
"associated with the given I<path> in the filesystem."
msgstr ""

#. type: Plain text
#: man-pages/man2/removexattr.2:62
msgid ""
"B<lremovexattr>()  is identical to B<removexattr>(), except in the case of a "
"symbolic link, where the extended attribute is removed from the link itself, "
"not the file that it refers to."
msgstr ""

#. type: Plain text
#: man-pages/man2/removexattr.2:72
msgid ""
"B<fremovexattr>()  is identical to B<removexattr>(), only the extended "
"attribute is removed from the open file referred to by I<fd> (as returned by "
"B<open>(2))  in place of I<path>."
msgstr ""

#. type: Plain text
#: man-pages/man2/removexattr.2:78
msgid ""
"An extended attribute name is a null-terminated string.  The I<name> "
"includes a namespace prefix; there may be several, disjoint namespaces "
"associated with an individual inode."
msgstr ""

#.  .RB ( ENOATTR
#.  is defined to be a synonym for
#.  .BR ENODATA
#.  in
#.  .IR <attr/attributes.h> .)
#. type: Plain text
#: man-pages/man2/removexattr.2:92
msgid "The named attribute does not exist."
msgstr ""

#. type: Plain text
#: man-pages/man2/removexattr.2:119
msgid ""
"B<getfattr>(1), B<setfattr>(1), B<getxattr>(2), B<listxattr>(2), B<open>(2), "
"B<setxattr>(2), B<stat>(2), B<symlink>(7), B<xattr>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/ioctl_tty.2:8
#, no-wrap
msgid "IOCTL_TTY"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_tty.2:11
msgid "ioctl_tty - ioctls for terminals and serial lines"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_tty.2:13
msgid "B<#include E<lt>termios.hE<gt>>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_tty.2:15
msgid "B<int ioctl(int >I<fd>B<, int >I<cmd>B<, ...);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_tty.2:23
msgid ""
"The B<ioctl>(2)  call for terminals and serial ports accepts many possible "
"command arguments.  Most require a third argument, of varying type, here "
"called I<argp> or I<arg>."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_tty.2:30
msgid ""
"Use of I<ioctl> makes for nonportable programs.  Use the POSIX interface "
"described in B<termios>(3)  whenever possible."
msgstr ""

#. type: SS
#: man-pages/man2/ioctl_tty.2:30
#, no-wrap
msgid "Get and set terminal attributes"
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_tty.2:31
#, no-wrap
msgid "B<TCGETS\tstruct termios *>I<argp>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_tty.2:35
msgid "Equivalent to I<tcgetattr(fd, argp)>."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_tty.2:37
msgid "Get the current serial port settings."
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_tty.2:37
#, no-wrap
msgid "B<TCSETS\tconst struct termios *>I<argp>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_tty.2:41
msgid "Equivalent to I<tcsetattr(fd, TCSANOW, argp)>."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_tty.2:43
msgid "Set the current serial port settings."
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_tty.2:43
#, no-wrap
msgid "B<TCSETSW\tconst struct termios *>I<argp>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_tty.2:47
msgid "Equivalent to I<tcsetattr(fd, TCSADRAIN, argp)>."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_tty.2:50
msgid "Allow the output buffer to drain, and set the current serial port settings."
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_tty.2:50
#, no-wrap
msgid "B<TCSETSF\tconst struct termios *>I<argp>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_tty.2:54
msgid "Equivalent to I<tcsetattr(fd, TCSAFLUSH, argp)>."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_tty.2:57
msgid ""
"Allow the output buffer to drain, discard pending input, and set the current "
"serial port settings."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_tty.2:67
msgid ""
"The following four ioctls are just like B<TCGETS>, B<TCSETS>, B<TCSETSW>, "
"B<TCSETSF>, except that they take a I<struct termio\\ *> instead of a "
"I<struct termios\\ *>."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_tty.2:69
msgid "B<TCGETA\tstruct termio *>I<argp>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_tty.2:71
msgid "B<TCSETA\tconst struct termio *>I<argp>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_tty.2:73
msgid "B<TCSETAW\tconst struct termio *>I<argp>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_tty.2:75
msgid "B<TCSETAF\tconst struct termio *>I<argp>"
msgstr ""

#. type: SS
#: man-pages/man2/ioctl_tty.2:75
#, no-wrap
msgid "Locking the termios structure"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_tty.2:83
msgid ""
"The I<termios> structure of a terminal can be locked.  The lock is itself a "
"I<termios> structure, with nonzero bits or fields indicating a locked value."
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_tty.2:83
#, no-wrap
msgid "B<TIOCGLCKTRMIOS\tstruct termios *>I<argp>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_tty.2:88
msgid "Gets the locking status of the I<termios> structure of the terminal."
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_tty.2:88
#, no-wrap
msgid "B<TIOCSLCKTRMIOS\tconst struct termios *>I<argp>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_tty.2:96
msgid ""
"Sets the locking status of the I<termios> structure of the terminal.  Only a "
"process with the B<CAP_SYS_ADMIN> capability can do this."
msgstr ""

#. type: SS
#: man-pages/man2/ioctl_tty.2:96
#, no-wrap
msgid "Get and set window size"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_tty.2:101
msgid ""
"Window sizes are kept in the kernel, but not used by the kernel (except in "
"the case of virtual consoles, where the kernel will update the window size "
"when the size of the virtual console changes, for example, by loading a new "
"font)."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_tty.2:104
msgid ""
"The following constants and structure are defined in "
"I<E<lt>sys/ioctl.hE<gt>>."
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_tty.2:104
#, no-wrap
msgid "B<TIOCGWINSZ\tstruct winsize *>I<argp>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_tty.2:107
msgid "Get window size."
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_tty.2:107
#, no-wrap
msgid "B<TIOCSWINSZ\tconst struct winsize *>I<argp>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_tty.2:110
msgid "Set window size."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_tty.2:112
msgid "The struct used by these ioctls is defined as"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_tty.2:121
#, no-wrap
msgid ""
"struct winsize {\n"
"    unsigned short ws_row;\n"
"    unsigned short ws_col;\n"
"    unsigned short ws_xpixel;   /* unused */\n"
"    unsigned short ws_ypixel;   /* unused */\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_tty.2:128
msgid ""
"When the window size changes, a B<SIGWINCH> signal is sent to the foreground "
"process group."
msgstr ""

#. type: SS
#: man-pages/man2/ioctl_tty.2:128
#, no-wrap
msgid "Sending a break"
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_tty.2:129
#, no-wrap
msgid "B<TCSBRK\tint >I<arg>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_tty.2:133
msgid "Equivalent to I<tcsendbreak(fd, arg)>."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_tty.2:144
msgid ""
"If the terminal is using asynchronous serial data transmission, and I<arg> "
"is zero, then send a break (a stream of zero bits) for between 0.25 and 0.5 "
"seconds.  If the terminal is not using asynchronous serial data "
"transmission, then either a break is sent, or the function returns without "
"doing anything.  When I<arg> is nonzero, nobody knows what will happen."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_tty.2:162
msgid ""
"(SVr4, UnixWare, Solaris, Linux treat I<tcsendbreak(fd,arg)> with nonzero "
"I<arg> like I<tcdrain(fd)>.  SunOS treats I<arg> as a multiplier, and sends "
"a stream of bits I<arg> times as long as done for zero I<arg>.  DG/UX and "
"AIX treat I<arg> (when nonzero) as a time interval measured in "
"milliseconds.  HP-UX ignores I<arg>.)"
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_tty.2:162
#, no-wrap
msgid "B<TCSBRKP\tint >I<arg>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_tty.2:170
msgid ""
"So-called \"POSIX version\" of B<TCSBRK>.  It treats nonzero I<arg> as a "
"timeinterval measured in deciseconds, and does nothing when the driver does "
"not support breaks."
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_tty.2:170
#, no-wrap
msgid "B<TIOCSBRK\tvoid>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_tty.2:173
msgid "Turn break on, that is, start sending zero bits."
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_tty.2:173
#, no-wrap
msgid "B<TIOCCBRK\tvoid>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_tty.2:176
msgid "Turn break off, that is, stop sending zero bits."
msgstr ""

#. type: SS
#: man-pages/man2/ioctl_tty.2:176
#, no-wrap
msgid "Software flow control"
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_tty.2:177
#, no-wrap
msgid "B<TCXONC\tint >I<arg>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_tty.2:181
msgid "Equivalent to I<tcflow(fd, arg)>."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_tty.2:189
msgid ""
"See B<tcflow>(3)  for the argument values B<TCOOFF>, B<TCOON>, B<TCIOFF>, "
"B<TCION>."
msgstr ""

#. type: SS
#: man-pages/man2/ioctl_tty.2:189
#, no-wrap
msgid "Buffer count and flushing"
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_tty.2:190
#, no-wrap
msgid "B<FIONREAD\tint *>I<argp>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_tty.2:193
msgid "Get the number of bytes in the input buffer."
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_tty.2:193
#, no-wrap
msgid "B<TIOCINQ\tint *>I<argp>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_tty.2:197
msgid "Same as B<FIONREAD>."
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_tty.2:197
#, no-wrap
msgid "B<TIOCOUTQ\tint *>I<argp>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_tty.2:200
msgid "Get the number of bytes in the output buffer."
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_tty.2:200
#, no-wrap
msgid "B<TCFLSH\tint >I<arg>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_tty.2:204
msgid "Equivalent to I<tcflush(fd, arg)>."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_tty.2:211
msgid ""
"See B<tcflush>(3)  for the argument values B<TCIFLUSH>, B<TCOFLUSH>, "
"B<TCIOFLUSH>."
msgstr ""

#. type: SS
#: man-pages/man2/ioctl_tty.2:211
#, no-wrap
msgid "Faking input"
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_tty.2:212
#, no-wrap
msgid "B<TIOCSTI\tconst char *>I<argp>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_tty.2:215
msgid "Insert the given byte in the input queue."
msgstr ""

#. type: SS
#: man-pages/man2/ioctl_tty.2:215
#, no-wrap
msgid "Redirecting console output"
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_tty.2:216
#, no-wrap
msgid "B<TIOCCONS\tvoid>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_tty.2:238
msgid ""
"Redirect output that would have gone to I</dev/console> or I</dev/tty0> to "
"the given terminal.  If that was a pseudoterminal master, send it to the "
"slave.  In Linux before version 2.6.10, anybody can do this as long as the "
"output was not redirected yet; since version 2.6.10, only a process with the "
"B<CAP_SYS_ADMIN> capability may do this.  If output was redirected already "
"B<EBUSY> is returned, but redirection can be stopped by using this ioctl "
"with I<fd> pointing at I</dev/console> or I</dev/tty0>."
msgstr ""

#. type: SS
#: man-pages/man2/ioctl_tty.2:238
#, no-wrap
msgid "Controlling terminal"
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_tty.2:239
#, no-wrap
msgid "B<TIOCSCTTY\tint >I<arg>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_tty.2:247
msgid ""
"Make the given terminal the controlling terminal of the calling process.  "
"The calling process must be a session leader and not have a controlling "
"terminal already.  For this case, I<arg> should be specified as zero."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_tty.2:257
msgid ""
"If this terminal is already the controlling terminal of a different session "
"group, then the ioctl fails with B<EPERM>, unless the caller has the "
"B<CAP_SYS_ADMIN> capability and I<arg> equals 1, in which case the terminal "
"is stolen, and all processes that had it as controlling terminal lose it."
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_tty.2:257
#, no-wrap
msgid "B<TIOCNOTTY\tvoid>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_tty.2:268
msgid ""
"If the given terminal was the controlling terminal of the calling process, "
"give up this controlling terminal.  If the process was session leader, then "
"send B<SIGHUP> and B<SIGCONT> to the foreground process group and all "
"processes in the current session lose their controlling terminal."
msgstr ""

#. type: SS
#: man-pages/man2/ioctl_tty.2:268
#, no-wrap
msgid "Process group and session ID"
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_tty.2:269
#, no-wrap
msgid "B<TIOCGPGRP\tpid_t *>I<argp>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_tty.2:273
msgid "When successful, equivalent to I<*argp = tcgetpgrp(fd)>."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_tty.2:275
msgid "Get the process group ID of the foreground process group on this terminal."
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_tty.2:275
#, no-wrap
msgid "B<TIOCSPGRP\tconst pid_t *>I<argp>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_tty.2:279
msgid "Equivalent to I<tcsetpgrp(fd, *argp)>."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_tty.2:281
msgid "Set the foreground process group ID of this terminal."
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_tty.2:281
#, no-wrap
msgid "B<TIOCGSID\tpid_t *>I<argp>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_tty.2:289
msgid ""
"Get the session ID of the given terminal.  This fails with the error "
"B<ENOTTY> if the terminal is not a master pseudoterminal and not our "
"controlling terminal.  Strange."
msgstr ""

#. type: SS
#: man-pages/man2/ioctl_tty.2:289
#, no-wrap
msgid "Exclusive mode"
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_tty.2:290
#, no-wrap
msgid "B<TIOCEXCL\tvoid>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_tty.2:301
msgid ""
"Put the terminal into exclusive mode.  No further B<open>(2)  operations on "
"the terminal are permitted.  (They fail with B<EBUSY>, except for a process "
"with the B<CAP_SYS_ADMIN> capability.)"
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_tty.2:301
#, no-wrap
msgid "B<TIOCGEXCL\tint *>I<argp>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_tty.2:309
msgid ""
"(since Linux 3.8)  If the terminal is currently in exclusive mode, place a "
"nonzero value in the location pointed to by I<argp>; otherwise, place zero "
"in I<*argp>."
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_tty.2:309
#, no-wrap
msgid "B<TIOCNXCL\tvoid>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_tty.2:312
msgid "Disable exclusive mode."
msgstr ""

#. type: SS
#: man-pages/man2/ioctl_tty.2:312
#, no-wrap
msgid "Line discipline"
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_tty.2:313
#, no-wrap
msgid "B<TIOCGETD\tint *>I<argp>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_tty.2:316
msgid "Get the line discipline of the terminal."
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_tty.2:316
#, no-wrap
msgid "B<TIOCSETD\tconst int *>I<argp>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_tty.2:319
msgid "Set the line discipline of the terminal."
msgstr ""

#. type: SS
#: man-pages/man2/ioctl_tty.2:319
#, no-wrap
msgid "Pseudoterminal ioctls"
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_tty.2:320
#, no-wrap
msgid "B<TIOCPKT\tconst int *>I<argp>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_tty.2:337
msgid ""
"Enable (when *I<argp> is nonzero) or disable packet mode.  Can be applied to "
"the master side of a pseudoterminal only (and will return B<ENOTTY> "
"otherwise).  In packet mode, each subsequent B<read>(2)  will return a "
"packet that either contains a single nonzero control byte, or has a single "
"byte containing zero (\\(aq\\0\\(aq) followed by data written on the slave "
"side of the pseudoterminal.  If the first byte is not B<TIOCPKT_DATA> (0), "
"it is an OR of one or more of the following bits:"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_tty.2:345
#, no-wrap
msgid ""
"TIOCPKT_FLUSHREAD   The read queue for the terminal is flushed.\n"
"TIOCPKT_FLUSHWRITE  The write queue for the terminal is flushed.\n"
"TIOCPKT_STOP        Output to the terminal is stopped.\n"
"TIOCPKT_START       Output to the terminal is restarted.\n"
"TIOCPKT_DOSTOP      The start and stop characters are B<^S>/B<^Q>.\n"
"TIOCPKT_NOSTOP      The start and stop characters are not B<^S>/B<^Q>.\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_tty.2:356
msgid ""
"While this mode is in use, the presence of control status information to be "
"read from the master side may be detected by a B<select>(2)  for exceptional "
"conditions or a B<poll>(2)  for the I<POLLPRI> event."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_tty.2:363
msgid ""
"This mode is used by B<rlogin>(1)  and B<rlogind>(8)  to implement a "
"remote-echoed, locally B<^S>/B<^Q> flow-controlled remote login."
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_tty.2:363
#, no-wrap
msgid "B<TIOCGPKT\tconst int *>I<argp>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_tty.2:368
msgid ""
"(since Linux 3.8)  Return the current packet mode setting in the integer "
"pointed to by I<argp>."
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_tty.2:368
#, no-wrap
msgid "B<TIOCSPTLCK\tint *>I<argp>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_tty.2:377
msgid ""
"Set (if I<*argp> is nonzero) or remove (if I<*argp> is zero) the "
"pseudoterminal slave device.  (See also B<unlockpt>(3).)"
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_tty.2:377
#, no-wrap
msgid "B<TIOCGPTLCK\tint *>I<argp>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_tty.2:383
msgid ""
"(since Linux 3.8)  Place the current lock state of the pseudoterminal slave "
"device in the location pointed to by I<argp>."
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_tty.2:383
#, no-wrap
msgid "B<TIOCGPTPEER\tint >I<flags>"
msgstr ""

#.  commit 54ebbfb1603415d9953c150535850d30609ef077
#. type: Plain text
#: man-pages/man2/ioctl_tty.2:398
msgid ""
"(since Linux 4.13)  Given a file descriptor in I<fd> that refers to a "
"pseudoterminal master, open (with the given B<open>(2)-style I<flags>)  and "
"return a new file descriptor that refers to the peer pseudoterminal slave "
"device.  This operation can be performed regardless of whether the pathname "
"of the slave device is accessible through the calling process's mount "
"namespace."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_tty.2:409
msgid ""
"Security-conscious programs interacting with namespaces may wish to use this "
"operation rather than B<open>(2)  with the pathname returned by "
"B<ptsname>(3), and similar library functions that have insecure APIs.  (For "
"example, confusion can occur in some cases using B<ptsname>(3)  with a "
"pathname where a devpts filesystem has been mounted in a different mount "
"namespace.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_tty.2:416
msgid ""
"The BSD ioctls B<TIOCSTOP>, B<TIOCSTART>, B<TIOCUCNTL>, B<TIOCREMOTE> have "
"not been implemented under Linux."
msgstr ""

#. type: SS
#: man-pages/man2/ioctl_tty.2:416
#, no-wrap
msgid "Modem control"
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_tty.2:417
#, no-wrap
msgid "B<TIOCMGET\tint *>I<argp>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_tty.2:420
msgid "Get the status of modem bits."
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_tty.2:420
#, no-wrap
msgid "B<TIOCMSET\tconst int *>I<argp>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_tty.2:423
msgid "Set the status of modem bits."
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_tty.2:423
#, no-wrap
msgid "B<TIOCMBIC\tconst int *>I<argp>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_tty.2:426
msgid "Clear the indicated modem bits."
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_tty.2:426
#, no-wrap
msgid "B<TIOCMBIS\tconst int *>I<argp>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_tty.2:429
msgid "Set the indicated modem bits."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_tty.2:431
msgid "The following bits are used by the above ioctls:"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_tty.2:444
#, no-wrap
msgid ""
"TIOCM_LE        DSR (data set ready/line enable)\n"
"TIOCM_DTR       DTR (data terminal ready)\n"
"TIOCM_RTS       RTS (request to send)\n"
"TIOCM_ST        Secondary TXD (transmit)\n"
"TIOCM_SR        Secondary RXD (receive)\n"
"TIOCM_CTS       CTS (clear to send)\n"
"TIOCM_CAR       DCD (data carrier detect)\n"
"TIOCM_CD         see TIOCM_CAR\n"
"TIOCM_RNG       RNG (ring)\n"
"TIOCM_RI         see TIOCM_RNG\n"
"TIOCM_DSR       DSR (data set ready)\n"
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_tty.2:445
#, no-wrap
msgid "B<TIOCMIWAIT\tint >I<arg>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_tty.2:459
msgid ""
"Wait for any of the 4 modem bits (DCD, RI, DSR, CTS) to change.  The bits of "
"interest are specified as a bit mask in I<arg>, by ORing together any of the "
"bit values, B<TIOCM_RNG>, B<TIOCM_DSR>, B<TIOCM_CD>, and B<TIOCM_CTS>.  The "
"caller should use B<TIOCGICOUNT> to see which bit has changed."
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_tty.2:459
#, no-wrap
msgid "B<TIOCGICOUNT\tstruct serial_icounter_struct *>I<argp>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_tty.2:466
msgid ""
"Get counts of input serial line interrupts (DCD, RI, DSR, CTS).  The counts "
"are written to the I<serial_icounter_struct> structure pointed to by "
"I<argp>."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_tty.2:469
msgid ""
"Note: both 1-E<gt>0 and 0-E<gt>1 transitions are counted, except for RI, "
"where only 0-E<gt>1 transitions are counted."
msgstr ""

#. type: SS
#: man-pages/man2/ioctl_tty.2:469
#, no-wrap
msgid "Marking a line as local"
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_tty.2:470
#, no-wrap
msgid "B<TIOCGSOFTCAR\tint *>I<argp>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_tty.2:476
msgid ""
"(\"Get software carrier flag\")  Get the status of the CLOCAL flag in the "
"c_cflag field of the I<termios> structure."
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_tty.2:476
#, no-wrap
msgid "B<TIOCSSOFTCAR\tconst int *>I<argp>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_tty.2:484
msgid ""
"(\"Set software carrier flag\")  Set the CLOCAL flag in the I<termios> "
"structure when *I<argp> is nonzero, and clear it otherwise."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_tty.2:499
msgid ""
"If the B<CLOCAL> flag for a line is off, the hardware carrier detect (DCD)  "
"signal is significant, and an B<open>(2)  of the corresponding terminal will "
"block until DCD is asserted, unless the B<O_NONBLOCK> flag is given.  If "
"B<CLOCAL> is set, the line behaves as if DCD is always asserted.  The "
"software carrier flag is usually turned on for local devices, and is off for "
"lines with modems."
msgstr ""

#. type: SS
#: man-pages/man2/ioctl_tty.2:499
#, no-wrap
msgid "Linux-specific"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_tty.2:504
msgid "For the B<TIOCLINUX> ioctl, see B<ioctl_console>(2)."
msgstr ""

#. type: SS
#: man-pages/man2/ioctl_tty.2:504
#, no-wrap
msgid "Kernel debugging"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_tty.2:506
msgid "B<#include E<lt>linux/tty.hE<gt>>"
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_tty.2:506
#, no-wrap
msgid "B<TIOCTTYGSTRUCT\tstruct tty_struct *>I<argp>"
msgstr ""

#.      commit b3506a09d15dc5aee6d4bb88d759b157016e1864
#.      Author: Andries E. Brouwer <andries.brouwer@cwi.nl>
#.      Date:   Tue Apr 1 04:42:46 2003 -0800
#
#.      [PATCH] kill TIOCTTYGSTRUCT
#
#.      Only used for (dubious) debugging purposes, and exposes
#.      internal kernel state.
#
#.  .SS Serial info
#.  .BR "#include <linux/serial.h>"
#.  .PP
#.  .TP
#.  .BI "TIOCGSERIAL	struct serial_struct *" argp
#.  Get serial info.
#.  .TP
#.  .BI "TIOCSSERIAL	const struct serial_struct *" argp
#.  Set serial info.
#. type: Plain text
#: man-pages/man2/ioctl_tty.2:531
msgid ""
"Get the I<tty_struct> corresponding to I<fd>.  This command was removed in "
"Linux 2.5.67."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_tty.2:538
msgid ""
"The B<ioctl>(2)  system call returns 0 on success.  On error, it returns -1 "
"and sets I<errno> appropriately."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_tty.2:542
msgid "Invalid command parameter."
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_tty.2:542
#, no-wrap
msgid "B<ENOIOCTLCMD>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_tty.2:545
msgid "Unknown command."
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_tty.2:545 man-pages/man2/ioctl_ns.2:104
#: man-pages/man2/ioctl_ns.2:181 man-pages/man2/ioctl.2:109
#: man-pages/man2/ioctl.2:113 man-pages/man2/ioctl_fat.2:219
#: man-pages/man2/ioctl_console.2:819
#, no-wrap
msgid "B<ENOTTY>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_tty.2:549
msgid "Inappropriate I<fd>."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_tty.2:552 man-pages/man2/ioctl_console.2:826
msgid "Insufficient permission."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_tty.2:554
msgid "Check the condition of DTR on the serial port."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_tty.2:559
#, no-wrap
msgid ""
"#include E<lt>termios.hE<gt>\n"
"#include E<lt>fcntl.hE<gt>\n"
"#include E<lt>sys/ioctl.hE<gt>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_tty.2:564
#, no-wrap
msgid ""
"int\n"
"main(void)\n"
"{\n"
"    int fd, serial;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_tty.2:573
#, no-wrap
msgid ""
"    fd = open(\"/dev/ttyS0\", O_RDONLY);\n"
"    ioctl(fd, TIOCMGET, &serial);\n"
"    if (serial & TIOCM_DTR)\n"
"        puts(\"TIOCM_DTR is set\");\n"
"    else\n"
"        puts(\"TIOCM_DTR is not set\");\n"
"    close(fd);\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_tty.2:579
msgid "B<ldattach>(1), B<ioctl>(2), B<ioctl_console>(2), B<termios>(3), B<pty>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/ioctl_fideduperange.2:23
#, no-wrap
msgid "IOCTL-FIDEDUPERANGE"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_fideduperange.2:26
msgid "ioctl_fideduperange - share some the data of one file with another file"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_fideduperange.2:33
msgid ""
"B<int ioctl(int >I<src_fd>B<, FIDEDUPERANGE, struct file_dedupe_range "
"*>I<arg>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_fideduperange.2:50
msgid ""
"If a filesystem supports files sharing physical storage between multiple "
"files, this B<ioctl>(2)  operation can be used to make some of the data in "
"the B<src_fd> file appear in the B<dest_fd> file by sharing the underlying "
"storage if the file data is identical (\"deduplication\").  Both files must "
"reside within the same filesystem.  This reduces storage consumption by "
"allowing the filesystem to store one shared copy of the data.  If a file "
"write should occur to a shared region, the filesystem must ensure that the "
"changes remain private to the file being written.  This behavior is commonly "
"referred to as \"copy on write\"."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_fideduperange.2:58
msgid ""
"This ioctl performs the \"compare and share if identical\" operation on up "
"to I<src_length> bytes from file descriptor I<src_fd> at offset "
"I<src_offset>.  This information is conveyed in a structure of the following "
"form:"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_fideduperange.2:69
#, no-wrap
msgid ""
"struct file_dedupe_range {\n"
"    __u64 src_offset;\n"
"    __u64 src_length;\n"
"    __u16 dest_count;\n"
"    __u16 reserved1;\n"
"    __u32 reserved2;\n"
"    struct file_dedupe_range_info info[0];\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_fideduperange.2:74
msgid ""
"Deduplication is atomic with regards to concurrent writes, so no locks need "
"to be taken to obtain a consistent deduplicated copy."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_fideduperange.2:78
msgid "The fields I<reserved1> and I<reserved2> must be zero."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_fideduperange.2:84
msgid ""
"Destinations for the deduplication operation are conveyed in the array at "
"the end of the structure.  The number of destinations is given in "
"I<dest_count>, and the destination information is conveyed in the following "
"form:"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_fideduperange.2:94
#, no-wrap
msgid ""
"struct file_dedupe_range_info {\n"
"    __s64 dest_fd;\n"
"    __u64 dest_offset;\n"
"    __u64 bytes_deduped;\n"
"    __s32 status;\n"
"    __u32 reserved;\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_fideduperange.2:127
msgid ""
"Each deduplication operation targets I<src_length> bytes in file descriptor "
"I<dest_fd> at offset I<dest_offset>.  The field I<reserved> must be zero.  "
"During the call, I<src_fd> must be open for reading and I<dest_fd> must be "
"open for writing.  The combined size of the struct I<file_dedupe_range> and "
"the struct I<file_dedupe_range_info> array must not exceed the system page "
"size.  The maximum size of I<src_length> is filesystem dependent and is "
"typically 16\\ MiB.  This limit will be enforced silently by the "
"filesystem.  By convention, the storage used by I<src_fd> is mapped into "
"I<dest_fd> and the previous contents in I<dest_fd> are freed."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_fideduperange.2:145
msgid ""
"Upon successful completion of this ioctl, the number of bytes successfully "
"deduplicated is returned in I<bytes_deduped> and a status code for the "
"deduplication operation is returned in I<status>.  If even a single byte in "
"the range does not match, the deduplication request will be ignored and "
"I<status> set to B<FILE_DEDUPE_RANGE_DIFFERS>.  The I<status> code is set to "
"B<FILE_DEDUPE_RANGE_SAME> for success, a negative error code in case of "
"error, or B<FILE_DEDUPE_RANGE_DIFFERS> if the data did not match."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_fideduperange.2:153
#: man-pages/man2/ioctl_ficlonerange.2:92
msgid "Error codes can be one of, but are not limited to, the following:"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_fideduperange.2:162
msgid ""
"I<src_fd> is not open for reading; I<dest_fd> is not open for writing or is "
"open for append-only writes; or the filesystem which I<src_fd> resides on "
"does not support deduplication."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_fideduperange.2:171
msgid ""
"The filesystem does not support deduplicating the ranges of the given "
"files.  This error can also appear if either file descriptor represents a "
"device, FIFO, or socket.  Disk filesystems generally require the offset and "
"length arguments to be aligned to the fundamental block size.  Neither Btrfs "
"nor XFS support overlapping deduplication ranges in the same file."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_fideduperange.2:175
#: man-pages/man2/ioctl_ficlonerange.2:114
msgid ""
"One of the files is a directory and the filesystem does not support shared "
"regions in directories."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_fideduperange.2:182
msgid ""
"The kernel was unable to allocate sufficient memory to perform the operation "
"or I<dest_count> is so large that the input argument description spans more "
"than a single page of memory."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_fideduperange.2:186
msgid ""
"This can appear if the filesystem does not support deduplicating either file "
"descriptor, or if either file descriptor refers to special inodes."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_fideduperange.2:190
#: man-pages/man2/ioctl_ficlonerange.2:122
msgid "I<dest_fd> is immutable."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_fideduperange.2:194
#: man-pages/man2/ioctl_ficlonerange.2:126
msgid "One of the files is a swap file.  Swap files cannot share storage."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_fideduperange.2:198
#: man-pages/man2/ioctl_ficlonerange.2:130
msgid "I<dest_fd> and I<src_fd> are not on the same mounted filesystem."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_fideduperange.2:203
msgid ""
"This ioctl operation first appeared in Linux 4.5.  It was previously known "
"as B<BTRFS_IOC_FILE_EXTENT_SAME> and was private to Btrfs."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_fideduperange.2:205
#: man-pages/man2/ioctl_ficlonerange.2:139 man-pages/man2/ioctl_fat.2:246
msgid "This API is Linux-specific."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_fideduperange.2:210
#: man-pages/man2/ioctl_ficlonerange.2:144
msgid ""
"Because a copy-on-write operation requires the allocation of new storage, "
"the B<fallocate>(2)  operation may unshare shared blocks to guarantee that "
"subsequent writes will not fail because of lack of disk space."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_fideduperange.2:213
msgid ""
"Some filesystems may limit the amount of data that can be deduplicated in a "
"single call."
msgstr ""

#. type: TH
#: man-pages/man2/pivot_root.2:27
#, no-wrap
msgid "PIVOT_ROOT"
msgstr ""

#. type: Plain text
#: man-pages/man2/pivot_root.2:30
msgid "pivot_root - change the root mount"
msgstr ""

#. type: Plain text
#: man-pages/man2/pivot_root.2:32
msgid "B<int pivot_root(const char *>I<new_root>B<, const char *>I<put_old>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/pivot_root.2:43
msgid ""
"B<pivot_root>()  changes the root mount in the mount namespace of the "
"calling process.  More precisely, it moves the root mount to the directory "
"I<put_old> and makes I<new_root> the new root mount.  The calling process "
"must have the B<CAP_SYS_ADMIN> capability in the user namespace that owns "
"the caller's mount namespace."
msgstr ""

#. type: Plain text
#: man-pages/man2/pivot_root.2:56
msgid ""
"B<pivot_root>()  changes the root directory and the current working "
"directory of each process or thread in the same mount namespace to "
"I<new_root> if they point to the old root directory.  (See also NOTES.)  On "
"the other hand, B<pivot_root>()  does not change the caller's current "
"working directory (unless it is on the old root directory), and thus it "
"should be followed by a B<chdir(\"/\")> call."
msgstr ""

#. type: Plain text
#: man-pages/man2/pivot_root.2:58
msgid "The following restrictions apply:"
msgstr ""

#. type: tbl table
#: man-pages/man2/pivot_root.2:58 man-pages/man2/pivot_root.2:63
#: man-pages/man2/pivot_root.2:68 man-pages/man2/pivot_root.2:74
#: man-pages/man2/pivot_root.2:80 man-pages/man2/pivot_root.2:92
#: man-pages/man2/syscall.2:186 man-pages/man2/syscall.2:187
#: man-pages/man2/syscall.2:188 man-pages/man2/syscall.2:189
#: man-pages/man2/syscall.2:190 man-pages/man2/syscall.2:191
#: man-pages/man2/syscall.2:193 man-pages/man2/syscall.2:194
#: man-pages/man2/syscall.2:196 man-pages/man2/syscall.2:197
#: man-pages/man2/syscall.2:198 man-pages/man2/syscall.2:199
#: man-pages/man2/syscall.2:200 man-pages/man2/syscall.2:201
#: man-pages/man2/syscall.2:202 man-pages/man2/syscall.2:203
#: man-pages/man2/syscall.2:206 man-pages/man2/syscall.2:207
#: man-pages/man2/syscall.2:208 man-pages/man2/syscall.2:209
#: man-pages/man2/syscall.2:316 man-pages/man2/syscall.2:317
#: man-pages/man2/syscall.2:320 man-pages/man2/syscall.2:321
#: man-pages/man2/syscall.2:322 man-pages/man2/syscall.2:323
#: man-pages/man2/syscall.2:324 man-pages/man2/syscall.2:325
#: man-pages/man2/syscall.2:326 man-pages/man2/syscall.2:327
#: man-pages/man2/syscall.2:328 man-pages/man2/syscall.2:329
#: man-pages/man2/syscall.2:331 man-pages/man2/syscall.2:332
#: man-pages/man2/syscall.2:333 man-pages/man2/syscall.2:334
#: man-pages/man2/syscall.2:336 man-pages/man2/syscall.2:337
#: man-pages/man2/syscall.2:338 man-pages/man2/syscall.2:339
#: man-pages/man2/syscall.2:340 man-pages/man2/syscall.2:341
#, no-wrap
msgid "-"
msgstr ""

#. type: Plain text
#: man-pages/man2/pivot_root.2:63
msgid "I<new_root> and I<put_old> must be directories."
msgstr ""

#. type: Plain text
#: man-pages/man2/pivot_root.2:68
msgid ""
"I<new_root> and I<put_old> must not be on the same mount as the current "
"root."
msgstr ""

#. type: Plain text
#: man-pages/man2/pivot_root.2:74
msgid ""
"I<put_old> must be at or underneath I<new_root>; that is, adding some "
"nonnegative number of \"I</..>\" prefixes to the pathname pointed to by "
"I<put_old> must yield the same directory as I<new_root>."
msgstr ""

#. type: Plain text
#: man-pages/man2/pivot_root.2:80
msgid ""
"I<new_root> must be a path to a mount point, but can't be I<\"/\">.  A path "
"that is not already a mount point can be converted into one by bind mounting "
"the path onto itself."
msgstr ""

#. type: Plain text
#: man-pages/man2/pivot_root.2:92
msgid ""
"The propagation type of the parent mount of I<new_root> and the parent mount "
"of the current root directory must not be B<MS_SHARED>; similarly, if "
"I<put_old> is an existing mount point, its propagation type must not be "
"B<MS_SHARED>.  These restrictions ensure that B<pivot_root>()  never "
"propagates any changes to another mount namespace."
msgstr ""

#. type: Plain text
#: man-pages/man2/pivot_root.2:94
msgid "The current root directory must be a mount point."
msgstr ""

#. type: Plain text
#: man-pages/man2/pivot_root.2:103
msgid ""
"B<pivot_root>()  may fail with any of the same errors as B<stat>(2).  "
"Additionally, it may fail with the following errors:"
msgstr ""

#.  Reconfirmed that the following error occurs on Linux 5.0 by
#.  specifying 'new_root' as "/rootfs" and 'put_old' as
#.  "/rootfs/oldrootfs", and *not* bind mounting "/rootfs" on top of
#.  itself. Of course, this is an odd situation, since a later check
#.  in the kernel code will in any case yield EINVAL if 'new_root' is
#.  not a mount point. However, when the system call was first added,
#.  'new_root' was not required to be a mount point. So, this
#.  error is nowadays probably just the result of crufty accumulation.
#.  This error can also occur if we bind mount "/" on top of itself
#.  and try to specify "/" as the 'new' (again, an odd situation). So,
#.  the EBUSY check in the kernel does still seem necessary to prevent
#.  that case.  Furthermore, the "or put_old" piece is probably
#.  redundant text (although the check is in the kernel), since,
#.  in another check, 'put_old' is required to be under 'new_root'.
#. type: Plain text
#: man-pages/man2/pivot_root.2:127
msgid ""
"I<new_root> or I<put_old> is on the current root mount.  (This error covers "
"the pathological case where I<new_root> is I<\"/\">.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/pivot_root.2:131
msgid "I<new_root> is not a mount point."
msgstr ""

#. type: Plain text
#: man-pages/man2/pivot_root.2:134
msgid "I<put_old> is not at or underneath I<new_root>."
msgstr ""

#. type: Plain text
#: man-pages/man2/pivot_root.2:139
msgid ""
"The current root directory is not a mount point (because of an earlier "
"B<chroot>(2))."
msgstr ""

#. type: Plain text
#: man-pages/man2/pivot_root.2:142
msgid "The current root is on the rootfs (initial ramfs) mount; see NOTES."
msgstr ""

#. type: Plain text
#: man-pages/man2/pivot_root.2:149
msgid ""
"Either the mount point at I<new_root>, or the parent mount of that mount "
"point, has propagation type B<MS_SHARED>."
msgstr ""

#. type: Plain text
#: man-pages/man2/pivot_root.2:154
msgid "I<put_old> is a mount point and has the propagation type B<MS_SHARED>."
msgstr ""

#. type: Plain text
#: man-pages/man2/pivot_root.2:157
msgid "I<new_root> or I<put_old> is not a directory."
msgstr ""

#. type: Plain text
#: man-pages/man2/pivot_root.2:162
msgid "The calling process does not have the B<CAP_SYS_ADMIN> capability."
msgstr ""

#. type: Plain text
#: man-pages/man2/pivot_root.2:165
msgid "B<pivot_root>()  was introduced in Linux 2.3.41."
msgstr ""

#. type: Plain text
#: man-pages/man2/pivot_root.2:168
msgid "B<pivot_root>()  is Linux-specific and hence is not portable."
msgstr ""

#. type: Plain text
#: man-pages/man2/pivot_root.2:174
msgid ""
"A command-line interface for this system call is provided by "
"B<pivot_root>(8)."
msgstr ""

#. type: Plain text
#: man-pages/man2/pivot_root.2:184
msgid ""
"B<pivot_root>()  allows the caller to switch to a new root filesystem while "
"at the same time placing the old root mount at a location under I<new_root> "
"from where it can subsequently be unmounted.  (The fact that it moves all "
"processes that have a root directory or current working directory on the old "
"root directory to the new root frees the old root directory of users, "
"allowing the old root mount to be unmounted more easily.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/pivot_root.2:194
msgid ""
"One use of B<pivot_root>()  is during system startup, when the system mounts "
"a temporary root filesystem (e.g., an B<initrd>(4)), then mounts the real "
"root filesystem, and eventually turns the latter into the root directory of "
"all relevant processes and threads.  A modern use is to set up a root "
"filesystem during the creation of a container."
msgstr ""

#. type: Plain text
#: man-pages/man2/pivot_root.2:203
msgid ""
"The fact that B<pivot_root>()  modifies process root and current working "
"directories in the manner noted in DESCRIPTION is necessary in order to "
"prevent kernel threads from keeping the old root mount busy with their root "
"and current working directories, even if they never access the filesystem in "
"any way."
msgstr ""

#. type: Plain text
#: man-pages/man2/pivot_root.2:216
msgid ""
"The rootfs (initial ramfs) cannot be B<pivot_root>()ed.  The recommended "
"method of changing the root filesystem in this case is to delete everything "
"in rootfs, overmount rootfs with the new root, attach "
"I<stdin>/I<stdout>/I<stderr> to the new I</dev/console>, and exec the new "
"B<init>(1).  Helper programs for this process exist; see B<switch_root>(8)."
msgstr ""

#. type: SS
#: man-pages/man2/pivot_root.2:216
#, no-wrap
msgid "pivot_root(\".\", \".\")"
msgstr ""

#. type: Plain text
#: man-pages/man2/pivot_root.2:224
msgid ""
"I<new_root> and I<put_old> may be the same directory.  In particular, the "
"following sequence allows a pivot-root operation without needing to create "
"and remove a temporary directory:"
msgstr ""

#. type: Plain text
#: man-pages/man2/pivot_root.2:230
#, no-wrap
msgid ""
"chdir(new_root);\n"
"pivot_root(\".\", \".\");\n"
"umount2(\".\", MNT_DETACH);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/pivot_root.2:251
msgid ""
"This sequence succeeds because the B<pivot_root>()  call stacks the old root "
"mount point on top of the new root mount point at I</>.  At that point, the "
"calling process's root directory and current working directory refer to the "
"new root mount point (I<new_root>).  During the subsequent B<umount>()  "
"call, resolution of I<\".\"> starts with I<new_root> and then moves up the "
"list of mounts stacked at I</>, with the result that old root mount point is "
"unmounted."
msgstr ""

#. type: SS
#: man-pages/man2/pivot_root.2:251
#, no-wrap
msgid "Historical notes"
msgstr ""

#. type: Plain text
#: man-pages/man2/pivot_root.2:253
msgid "For many years, this manual page carried the following text:"
msgstr ""

#. type: Plain text
#: man-pages/man2/pivot_root.2:266
msgid ""
"B<pivot_root>()  may or may not change the current root and the current "
"working directory of any processes or threads which use the old root "
"directory.  The caller of B<pivot_root>()  must ensure that processes with "
"root or current working directory at the old root operate correctly in "
"either case.  An easy way to ensure this is to change their root and current "
"working directory to I<new_root> before invoking B<pivot_root>()."
msgstr ""

#. type: Plain text
#: man-pages/man2/pivot_root.2:274
msgid ""
"This text, written before the system call implementation was even finalized "
"in the kernel, was probably intended to warn users at that time that the "
"implementation might change before final release.  However, the behavior "
"stated in DESCRIPTION has remained consistent since this system call was "
"first implemented and will not change now."
msgstr ""

#. type: Plain text
#: man-pages/man2/pivot_root.2:287
msgid ""
"The program below demonstrates the use of B<pivot_root>()  inside a mount "
"namespace that is created using B<clone>(2).  After pivoting to the root "
"directory named in the program's first command-line argument, the child "
"created by B<clone>(2)  then executes the program named in the remaining "
"command-line arguments."
msgstr ""

#. type: Plain text
#: man-pages/man2/pivot_root.2:292
msgid ""
"We demonstrate the program by creating a directory that will serve as the "
"new root filesystem and placing a copy of the (statically linked)  "
"B<busybox>(1)  executable in that directory."
msgstr ""

#. type: Plain text
#: man-pages/man2/pivot_root.2:310
#, no-wrap
msgid ""
"$ B<mkdir /tmp/rootfs>\n"
"$ B<ls -id /tmp/rootfs>    # Show inode number of new root directory\n"
"319459 /tmp/rootfs\n"
"$ B<cp $(which busybox) /tmp/rootfs>\n"
"$ B<PS1='bbsh$ ' sudo ./pivot_root_demo /tmp/rootfs /busybox sh>\n"
"bbsh$ B<PATH=/>\n"
"bbsh$ B<busybox ln busybox ln>\n"
"bbsh$ B<ln busybox echo>\n"
"bbsh$ B<ln busybox ls>\n"
"bbsh$ B<ls>\n"
"busybox  echo     ln       ls\n"
"bbsh$ B<ls -id />          # Compare with inode number above\n"
"319459 /\n"
"bbsh$ B<echo \\(aqhello world\\(aq>\n"
"hello world\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/pivot_root.2:317
#, no-wrap
msgid "/* pivot_root_demo.c */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/pivot_root.2:328
#, no-wrap
msgid ""
"#define _GNU_SOURCE\n"
"#include E<lt>sched.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>sys/wait.hE<gt>\n"
"#include E<lt>sys/syscall.hE<gt>\n"
"#include E<lt>sys/mount.hE<gt>\n"
"#include E<lt>sys/stat.hE<gt>\n"
"#include E<lt>limits.hE<gt>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/pivot_root.2:337
#, no-wrap
msgid ""
"static int\n"
"pivot_root(const char *new_root, const char *put_old)\n"
"{\n"
"    return syscall(SYS_pivot_root, new_root, put_old);\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/pivot_root.2:339
#, no-wrap
msgid "#define STACK_SIZE (1024 * 1024)\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/pivot_root.2:347
#, no-wrap
msgid ""
"static int              /* Startup function for cloned child */\n"
"child(void *arg)\n"
"{\n"
"    char **args = arg;\n"
"    char *new_root = args[0];\n"
"    const char *put_old = \"/oldrootfs\";\n"
"    char path[PATH_MAX];\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/pivot_root.2:352
#, no-wrap
msgid ""
"    /* Ensure that \\(aqnew_root\\(aq and its parent mount don\\(aqt have\n"
"       shared propagation (which would cause pivot_root() to\n"
"       return an error), and prevent propagation of mount\n"
"       events to the initial mount namespace */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/pivot_root.2:355
#, no-wrap
msgid ""
"    if (mount(NULL, \"/\", NULL, MS_REC | MS_PRIVATE, NULL) == 1)\n"
"        errExit(\"mount-MS_PRIVATE\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/pivot_root.2:357
#, no-wrap
msgid "    /* Ensure that \\(aqnew_root\\(aq is a mount point */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/pivot_root.2:360
#, no-wrap
msgid ""
"    if (mount(new_root, new_root, NULL, MS_BIND, NULL) == -1)\n"
"        errExit(\"mount-MS_BIND\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/pivot_root.2:362
#, no-wrap
msgid "    /* Create directory to which old root will be pivoted */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/pivot_root.2:366
#, no-wrap
msgid ""
"    snprintf(path, sizeof(path), \"%s/%s\", new_root, put_old);\n"
"    if (mkdir(path, 0777) == -1)\n"
"        errExit(\"mkdir\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/pivot_root.2:368
#, no-wrap
msgid "    /* And pivot the root filesystem */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/pivot_root.2:371
#, no-wrap
msgid ""
"    if (pivot_root(new_root, path) == -1)\n"
"        errExit(\"pivot_root\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/pivot_root.2:373
#, no-wrap
msgid "    /* Switch the current working directory to \"/\" */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/pivot_root.2:376
#, no-wrap
msgid ""
"    if (chdir(\"/\") == -1)\n"
"        errExit(\"chdir\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/pivot_root.2:378
#, no-wrap
msgid "    /* Unmount old root and remove mount point */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/pivot_root.2:383
#, no-wrap
msgid ""
"    if (umount2(put_old, MNT_DETACH) == -1)\n"
"        perror(\"umount2\");\n"
"    if (rmdir(put_old) == -1)\n"
"        perror(\"rmdir\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/pivot_root.2:385
#, no-wrap
msgid "    /* Execute the command specified in argv[1]... */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/pivot_root.2:389
#, no-wrap
msgid ""
"    execv(args[1], &args[1]);\n"
"    errExit(\"execv\");\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/pivot_root.2:394
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    /* Create a child process in a new mount namespace */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/pivot_root.2:398
#, no-wrap
msgid ""
"    char *stack = malloc(STACK_SIZE);\n"
"    if (stack == NULL)\n"
"        errExit(\"malloc\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/pivot_root.2:402
#, no-wrap
msgid ""
"    if (clone(child, stack + STACK_SIZE,\n"
"                CLONE_NEWNS | SIGCHLD, &argv[1]) == -1)\n"
"        errExit(\"clone\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/pivot_root.2:404
#, no-wrap
msgid "    /* Parent falls through to here; wait for child */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/pivot_root.2:407
#, no-wrap
msgid ""
"    if (wait(NULL) == -1)\n"
"        errExit(\"wait\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/pivot_root.2:419
msgid ""
"B<chdir>(2), B<chroot>(2), B<mount>(2), B<stat>(2), B<initrd>(4), "
"B<mount_namespaces>(7), B<pivot_root>(8), B<switch_root>(8)"
msgstr ""

#. type: TH
#: man-pages/man2/setfsuid.2:32
#, no-wrap
msgid "SETFSUID"
msgstr ""

#. type: Plain text
#: man-pages/man2/setfsuid.2:35
msgid "setfsuid - set user identity used for filesystem checks"
msgstr ""

#. type: Plain text
#: man-pages/man2/setfsuid.2:37 man-pages/man2/setfsgid.2:37
msgid "B<#include E<lt>sys/fsuid.hE<gt>>"
msgstr ""

#. type: Plain text
#: man-pages/man2/setfsuid.2:39
msgid "B<int setfsuid(uid_t >I<fsuid>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/setfsuid.2:46
msgid ""
"On Linux, a process has both a filesystem user ID and an effective user ID.  "
"The (Linux-specific) filesystem user ID is used for permissions checking "
"when accessing filesystem objects, while the effective user ID is used for "
"various other kinds of permissions checks (see B<credentials>(7))."
msgstr ""

#. type: Plain text
#: man-pages/man2/setfsuid.2:57
msgid ""
"Normally, the value of the process's filesystem user ID is the same as the "
"value of its effective user ID.  This is so, because whenever a process's "
"effective user ID is changed, the kernel also changes the filesystem user ID "
"to be the same as the new value of the effective user ID.  A process can "
"cause the value of its filesystem user ID to diverge from its effective user "
"ID by using B<setfsuid>()  to change its filesystem user ID to the value "
"given in I<fsuid>."
msgstr ""

#. type: Plain text
#: man-pages/man2/setfsuid.2:68
msgid ""
"Explicit calls to B<setfsuid>()  and B<setfsgid>(2)  are (were) usually used "
"only by programs such as the Linux NFS server that need to change what user "
"and group ID is used for file access without a corresponding change in the "
"real and effective user and group IDs.  A change in the normal user IDs for "
"a program such as the NFS server is (was) a security hole that can expose it "
"to unwanted signals.  (However, this issue is historical; see below.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/setfsuid.2:74
msgid ""
"B<setfsuid>()  will succeed only if the caller is the superuser or if "
"I<fsuid> matches either the caller's real user ID, effective user ID, saved "
"set-user-ID, or current filesystem user ID."
msgstr ""

#. type: Plain text
#: man-pages/man2/setfsuid.2:77
msgid ""
"On both success and failure, this call returns the previous filesystem user "
"ID of the caller."
msgstr ""

#.  This system call is present since Linux 1.1.44
#.  and in libc since libc 4.7.6.
#. type: Plain text
#: man-pages/man2/setfsuid.2:81 man-pages/man2/setfsgid.2:70
msgid "This system call is present in Linux since version 1.2."
msgstr ""

#. type: Plain text
#: man-pages/man2/setfsuid.2:85
msgid ""
"B<setfsuid>()  is Linux-specific and should not be used in programs intended "
"to be portable."
msgstr ""

#. type: Plain text
#: man-pages/man2/setfsuid.2:104
msgid ""
"At the time when this system call was introduced, one process could send a "
"signal to another process with the same effective user ID.  This meant that "
"if a privileged process changed its effective user ID for the purpose of "
"file permission checking, then it could become vulnerable to receiving "
"signals sent by another (unprivileged) process with the same user ID.  The "
"filesystem user ID attribute was thus added to allow a process to change its "
"user ID for the purposes of file permission checking without at the same "
"time becoming vulnerable to receiving unwanted signals.  Since Linux 2.0, "
"signal permission handling is different (see B<kill>(2)), with the result "
"that a process can change its effective user ID without being vulnerable to "
"receiving signals from unwanted processes.  Thus, B<setfsuid>()  is nowadays "
"unneeded and should be avoided in new applications (likewise for "
"B<setfsgid>(2))."
msgstr ""

#. type: Plain text
#: man-pages/man2/setfsuid.2:114
msgid ""
"The original Linux B<setfsuid>()  system call supported only 16-bit user "
"IDs.  Subsequently, Linux 2.4 added B<setfsuid32>()  supporting 32-bit IDs.  "
"The glibc B<setfsuid>()  wrapper function transparently deals with the "
"variation across kernel versions."
msgstr ""

#. type: Plain text
#: man-pages/man2/setfsuid.2:123
msgid ""
"In glibc 2.15 and earlier, when the wrapper for this system call determines "
"that the argument can't be passed to the kernel without integer truncation "
"(because the kernel is old and does not support 32-bit user IDs), it will "
"return -1 and set I<errno> to B<EINVAL> without attempting the system call."
msgstr ""

#. type: Plain text
#: man-pages/man2/setfsuid.2:140
msgid ""
"No error indications of any kind are returned to the caller, and the fact "
"that both successful and unsuccessful calls return the same value makes it "
"impossible to directly determine whether the call succeeded or failed.  "
"Instead, the caller must resort to looking at the return value from a "
"further call such as I<setfsuid(-1)> (which will always fail), in order to "
"determine if a preceding call to B<setfsuid>()  changed the filesystem user "
"ID.  At the very least, B<EPERM> should be returned when the call fails "
"(because the caller lacks the B<CAP_SETUID> capability)."
msgstr ""

#. type: Plain text
#: man-pages/man2/setfsuid.2:144
msgid "B<kill>(2), B<setfsgid>(2), B<capabilities>(7), B<credentials>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/ioctl_ns.2:26
#, no-wrap
msgid "IOCTL_NS"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_ns.2:29
msgid "ioctl_ns - ioctl() operations for Linux namespaces"
msgstr ""

#.  ============================================================
#. type: SS
#: man-pages/man2/ioctl_ns.2:32
#, no-wrap
msgid "Discovering namespace relationships"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_ns.2:40
msgid ""
"The following B<ioctl>(2)  operations are provided to allow discovery of "
"namespace relationships (see B<user_namespaces>(7)  and "
"B<pid_namespaces>(7)).  The form of the calls is:"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_ns.2:44
#, no-wrap
msgid "new_fd = ioctl(fd, request);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_ns.2:53
msgid ""
"In each case, I<fd> refers to a I</proc/[pid]/ns/*> file.  Both operations "
"return a new file descriptor on success."
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_ns.2:53
#, no-wrap
msgid "B<NS_GET_USERNS> (since Linux 4.9)"
msgstr ""

#.  commit bcac25a58bfc6bd79191ac5d7afb49bea96da8c9
#.  commit 6786741dbf99e44fb0c0ed85a37582b8a26f1c3b
#. type: Plain text
#: man-pages/man2/ioctl_ns.2:60
msgid ""
"Returns a file descriptor that refers to the owning user namespace for the "
"namespace referred to by I<fd>."
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_ns.2:60
#, no-wrap
msgid "B<NS_GET_PARENT> (since Linux 4.9)"
msgstr ""

#.  commit a7306ed8d94af729ecef8b6e37506a1c6fc14788
#. type: Plain text
#: man-pages/man2/ioctl_ns.2:72
msgid ""
"Returns a file descriptor that refers to the parent namespace of the "
"namespace referred to by I<fd>.  This operation is valid only for "
"hierarchical namespaces (i.e., PID and user namespaces).  For user "
"namespaces, B<NS_GET_PARENT> is synonymous with B<NS_GET_USERNS>."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_ns.2:80
msgid ""
"The new file descriptor returned by these operations is opened with the "
"B<O_RDONLY> and B<O_CLOEXEC> (close-on-exec; see B<fcntl>(2))  flags."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_ns.2:93
msgid ""
"By applying B<fstat>(2)  to the returned file descriptor, one obtains a "
"I<stat> structure whose I<st_dev> (resident device) and I<st_ino> (inode "
"number) fields together identify the owning/parent namespace.  This inode "
"number can be matched with the inode number of another "
"I</proc/[pid]/ns/{pid,user}> file to determine whether that is the "
"owning/parent namespace."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_ns.2:97
msgid "Either of these B<ioctl>(2)  operations can fail with the following errors:"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_ns.2:104
msgid ""
"The requested namespace is outside of the caller's namespace scope.  This "
"error can occur if, for example, the owning user namespace is an ancestor of "
"the caller's current user namespace.  It can also occur on attempts to "
"obtain the parent of the initial user or PID namespace."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_ns.2:107
msgid "The operation is not supported by this kernel version."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_ns.2:111
msgid ""
"Additionally, the B<NS_GET_PARENT> operation can fail with the following "
"error:"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_ns.2:115
msgid "I<fd> refers to a nonhierarchical namespace."
msgstr ""

#.  ============================================================
#. type: Plain text
#: man-pages/man2/ioctl_ns.2:119
msgid "See the EXAMPLE section for an example of the use of these operations."
msgstr ""

#. type: SS
#: man-pages/man2/ioctl_ns.2:119
#, no-wrap
msgid "Discovering the namespace type"
msgstr ""

#.  commit e5ff5ce6e20ee22511398bb31fb912466cf82a36
#. type: Plain text
#: man-pages/man2/ioctl_ns.2:126
msgid ""
"The B<NS_GET_NSTYPE> operation (available since Linux 4.11) can be used to "
"discover the type of namespace referred to by the file descriptor I<fd>:"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_ns.2:130
#, no-wrap
msgid "nstype = ioctl(fd, NS_GET_NSTYPE);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_ns.2:137
msgid "I<fd> refers to a I</proc/[pid]/ns/*> file."
msgstr ""

#.  ============================================================
#. type: Plain text
#: man-pages/man2/ioctl_ns.2:147
msgid ""
"The return value is one of the B<CLONE_NEW*> values that can be specified to "
"B<clone>(2)  or B<unshare>(2)  in order to create a namespace."
msgstr ""

#. type: SS
#: man-pages/man2/ioctl_ns.2:147
#, no-wrap
msgid "Discovering the owner of a user namespace"
msgstr ""

#.  commit 015bb305b8ebe8d601a238ab70ebdc394c7a19ba
#. type: Plain text
#: man-pages/man2/ioctl_ns.2:155
msgid ""
"The B<NS_GET_OWNER_UID> operation (available since Linux 4.11) can be used "
"to discover the owner user ID of a user namespace (i.e., the effective user "
"ID of the process that created the user namespace).  The form of the call "
"is:"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_ns.2:160
#, no-wrap
msgid ""
"uid_t uid;\n"
"ioctl(fd, NS_GET_OWNER_UID, &uid);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_ns.2:167
msgid "I<fd> refers to a I</proc/[pid]/ns/user> file."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_ns.2:171
msgid ""
"The owner user ID is returned in the I<uid_t> pointed to by the third "
"argument."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_ns.2:173
msgid "This operation can fail with the following error:"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_ns.2:177
msgid "I<fd> does not refer to a user namespace."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_ns.2:181
msgid "Any of the above B<ioctl>()  operations can return the following errors:"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_ns.2:187
msgid "I<fd> does not refer to a I</proc/[pid]/ns/*> file."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_ns.2:189
msgid "Namespaces and the operations described on this page are a Linux-specific."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_ns.2:196
msgid ""
"The example shown below uses the B<ioctl>(2)  operations described above to "
"perform simple discovery of namespace relationships.  The following shell "
"sessions show various examples of the use of this program."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_ns.2:199
msgid ""
"Trying to get the parent of the initial user namespace fails, since it has "
"no parent:"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_ns.2:204
#, no-wrap
msgid ""
"$ B<./ns_show /proc/self/ns/user p>\n"
"The parent namespace is outside your namespace scope\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_ns.2:211
msgid ""
"Create a process running B<sleep>(1)  that resides in new user and UTS "
"namespaces, and show that the new UTS namespace is associated with the new "
"user namespace:"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_ns.2:220
#, no-wrap
msgid ""
"$ B<unshare -Uu sleep 1000 &>\n"
"[1] 23235\n"
"$ B<./ns_show /proc/23235/ns/uts u>\n"
"Device/Inode of owning user namespace is: [0,3] / 4026532448\n"
"$ B<readlink /proc/23235/ns/user >\n"
"user:[4026532448]\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_ns.2:225
msgid ""
"Then show that the parent of the new user namespace in the preceding example "
"is the initial user namespace:"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_ns.2:232
#, no-wrap
msgid ""
"$ B<readlink /proc/self/ns/user>\n"
"user:[4026531837]\n"
"$ B<./ns_show /proc/23235/ns/user p>\n"
"Device/Inode of parent namespace is: [0,3] / 4026531837\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_ns.2:240
msgid ""
"Start a shell in a new user namespace, and show that from within this shell, "
"the parent user namespace can't be discovered.  Similarly, the UTS namespace "
"(which is associated with the initial user namespace)  can't be discovered."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_ns.2:248
#, no-wrap
msgid ""
"$ B<PS1=\"sh2$ \" unshare -U bash>\n"
"sh2$ B<./ns_show /proc/self/ns/user p>\n"
"The parent namespace is outside your namespace scope\n"
"sh2$ B<./ns_show /proc/self/ns/uts u>\n"
"The owning user namespace is outside your namespace scope\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_ns.2:254
#, no-wrap
msgid "/* ns_show.c\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_ns.2:266
#, no-wrap
msgid ""
"   Licensed under the GNU General Public License v2 or later.\n"
"*/\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>fcntl.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>sys/stat.hE<gt>\n"
"#include E<lt>sys/ioctl.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"
"#include E<lt>sys/sysmacros.hE<gt>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_ns.2:272
#, no-wrap
msgid ""
"#ifndef NS_GET_USERNS\n"
"#define NSIO    0xb7\n"
"#define NS_GET_USERNS   _IO(NSIO, 0x1)\n"
"#define NS_GET_PARENT   _IO(NSIO, 0x2)\n"
"#endif\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_ns.2:278
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int fd, userns_fd, parent_fd;\n"
"    struct stat sb;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_ns.2:289
#, no-wrap
msgid ""
"    if (argc E<lt> 2) {\n"
"        fprintf(stderr, \"Usage: %s /proc/[pid]/ns/[file] [p|u]\\en\",\n"
"                argv[0]);\n"
"        fprintf(stderr, \"\\enDisplay the result of one or both \"\n"
"                \"of NS_GET_USERNS (u) or NS_GET_PARENT (p)\\en\"\n"
"                \"for the specified /proc/[pid]/ns/[file]. If neither \"\n"
"                \"\\(aqp\\(aq nor \\(aqu\\(aq is specified,\\en\"\n"
"                \"NS_GET_USERNS is the default.\\en\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_ns.2:292
#, no-wrap
msgid ""
"    /* Obtain a file descriptor for the \\(aqns\\(aq file specified\n"
"       in argv[1] */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_ns.2:298 man-pages/man2/ioctl_fat.2:318
#: man-pages/man2/ioctl_fat.2:393
#, no-wrap
msgid ""
"    fd = open(argv[1], O_RDONLY);\n"
"    if (fd == -1) {\n"
"        perror(\"open\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_ns.2:301
#, no-wrap
msgid ""
"    /* Obtain a file descriptor for the owning user namespace and\n"
"       then obtain and display the inode number of that namespace */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_ns.2:304
#, no-wrap
msgid ""
"    if (argc E<lt> 3 || strchr(argv[2], \\(aqu\\(aq)) {\n"
"        userns_fd = ioctl(fd, NS_GET_USERNS);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_ns.2:313
#, no-wrap
msgid ""
"        if (userns_fd == -1) {\n"
"            if (errno == EPERM)\n"
"                printf(\"The owning user namespace is outside \"\n"
"                        \"your namespace scope\\en\");\n"
"            else\n"
"               perror(\"ioctl-NS_GET_USERNS\");\n"
"            exit(EXIT_FAILURE);\n"
"         }\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_ns.2:322
#, no-wrap
msgid ""
"        if (fstat(userns_fd, &sb) == -1) {\n"
"            perror(\"fstat-userns\");\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"
"        printf(\"Device/Inode of owning user namespace is: \"\n"
"                \"[%lx,%lx] / %ld\\en\",\n"
"                (long) major(sb.st_dev), (long) minor(sb.st_dev),\n"
"                (long) sb.st_ino);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_ns.2:325
#, no-wrap
msgid ""
"        close(userns_fd);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_ns.2:328
#, no-wrap
msgid ""
"    /* Obtain a file descriptor for the parent namespace and\n"
"       then obtain and display the inode number of that namespace */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_ns.2:331
#, no-wrap
msgid ""
"    if (argc E<gt> 2 && strchr(argv[2], \\(aqp\\(aq)) {\n"
"        parent_fd = ioctl(fd, NS_GET_PARENT);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_ns.2:343
#, no-wrap
msgid ""
"        if (parent_fd == -1) {\n"
"            if (errno == EINVAL)\n"
"                printf(\"Can\\(aq get parent namespace of a \"\n"
"                        \"nonhierarchical namespace\\en\");\n"
"            else if (errno == EPERM)\n"
"                printf(\"The parent namespace is outside \"\n"
"                        \"your namespace scope\\en\");\n"
"            else\n"
"                perror(\"ioctl-NS_GET_PARENT\");\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_ns.2:351
#, no-wrap
msgid ""
"        if (fstat(parent_fd, &sb) == -1) {\n"
"            perror(\"fstat-parentns\");\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"
"        printf(\"Device/Inode of parent namespace is: [%lx,%lx] / "
"%ld\\en\",\n"
"                (long) major(sb.st_dev), (long) minor(sb.st_dev),\n"
"                (long) sb.st_ino);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_ns.2:354
#, no-wrap
msgid ""
"        close(parent_fd);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_ns.2:362
msgid "B<fstat>(2), B<ioctl>(2), B<proc>(5), B<namespaces>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/send.2:40
#, no-wrap
msgid "SEND"
msgstr ""

#. type: Plain text
#: man-pages/man2/send.2:43
msgid "send, sendto, sendmsg - send a message on a socket"
msgstr ""

#. type: Plain text
#: man-pages/man2/send.2:47
#, no-wrap
msgid ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>sys/socket.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/send.2:50
#, no-wrap
msgid ""
"B<ssize_t send(int >I<sockfd>B<, const void *>I<buf>B<, size_t >I<len>B<, "
"int >I<flags>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/send.2:54
#, no-wrap
msgid ""
"B<ssize_t sendto(int >I<sockfd>B<, const void *>I<buf>B<, size_t >I<len>B<, "
"int >I<flags>B<,>\n"
"B<               const struct sockaddr *>I<dest_addr>B<, socklen_t "
">I<addrlen>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/send.2:57
#, no-wrap
msgid ""
"B<ssize_t sendmsg(int >I<sockfd>B<, const struct msghdr *>I<msg>B<, int "
">I<flags>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/send.2:65
msgid ""
"The system calls B<send>(), B<sendto>(), and B<sendmsg>()  are used to "
"transmit a message to another socket."
msgstr ""

#. type: Plain text
#: man-pages/man2/send.2:84
msgid ""
"The B<send>()  call may be used only when the socket is in a I<connected> "
"state (so that the intended recipient is known).  The only difference "
"between B<send>()  and B<write>(2)  is the presence of I<flags>.  With a "
"zero I<flags> argument, B<send>()  is equivalent to B<write>(2).  Also, the "
"following call"
msgstr ""

#. type: Plain text
#: man-pages/man2/send.2:86
#, no-wrap
msgid "    send(sockfd, buf, len, flags);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/send.2:88 man-pages/man2/recv.2:89
msgid "is equivalent to"
msgstr ""

#. type: Plain text
#: man-pages/man2/send.2:90
#, no-wrap
msgid "    sendto(sockfd, buf, len, flags, NULL, 0);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/send.2:94
msgid "The argument I<sockfd> is the file descriptor of the sending socket."
msgstr ""

#. type: Plain text
#: man-pages/man2/send.2:122
msgid ""
"If B<sendto>()  is used on a connection-mode (B<SOCK_STREAM>, "
"B<SOCK_SEQPACKET>)  socket, the arguments I<dest_addr> and I<addrlen> are "
"ignored (and the error B<EISCONN> may be returned when they are not NULL and "
"0), and the error B<ENOTCONN> is returned when the socket was not actually "
"connected.  Otherwise, the address of the target is given by I<dest_addr> "
"with I<addrlen> specifying its size.  For B<sendmsg>(), the address of the "
"target is given by I<msg.msg_name>, with I<msg.msg_namelen> specifying its "
"size."
msgstr ""

#. type: Plain text
#: man-pages/man2/send.2:138
msgid ""
"For B<send>()  and B<sendto>(), the message is found in I<buf> and has "
"length I<len>.  For B<sendmsg>(), the message is pointed to by the elements "
"of the array I<msg.msg_iov>.  The B<sendmsg>()  call also allows sending "
"ancillary data (also known as control information)."
msgstr ""

#. type: Plain text
#: man-pages/man2/send.2:143
msgid ""
"If the message is too long to pass atomically through the underlying "
"protocol, the error B<EMSGSIZE> is returned, and the message is not "
"transmitted."
msgstr ""

#. type: Plain text
#: man-pages/man2/send.2:147
msgid ""
"No indication of failure to deliver is implicit in a B<send>().  Locally "
"detected errors are indicated by a return value of -1."
msgstr ""

#. type: Plain text
#: man-pages/man2/send.2:160
msgid ""
"When the message does not fit into the send buffer of the socket, B<send>()  "
"normally blocks, unless the socket has been placed in nonblocking I/O mode.  "
"In nonblocking mode it would fail with the error B<EAGAIN> or B<EWOULDBLOCK> "
"in this case.  The B<select>(2)  call may be used to determine when it is "
"possible to send more data."
msgstr ""

#. type: SS
#: man-pages/man2/send.2:160 man-pages/man2/recv.2:114
#, no-wrap
msgid "The flags argument"
msgstr ""

#.  FIXME . ? document MSG_PROXY (which went away in 2.3.15)
#. type: Plain text
#: man-pages/man2/send.2:166
msgid ""
"The I<flags> argument is the bitwise OR of zero or more of the following "
"flags."
msgstr ""

#. type: TP
#: man-pages/man2/send.2:166
#, no-wrap
msgid "B<MSG_CONFIRM> (since Linux 2.3.15)"
msgstr ""

#. type: Plain text
#: man-pages/man2/send.2:180
msgid ""
"Tell the link layer that forward progress happened: you got a successful "
"reply from the other side.  If the link layer doesn't get this it will "
"regularly reprobe the neighbor (e.g., via a unicast ARP).  Valid only on "
"B<SOCK_DGRAM> and B<SOCK_RAW> sockets and currently implemented only for "
"IPv4 and IPv6.  See B<arp>(7)  for details."
msgstr ""

#. type: TP
#: man-pages/man2/send.2:180
#, no-wrap
msgid "B<MSG_DONTROUTE>"
msgstr ""

#. type: Plain text
#: man-pages/man2/send.2:188
msgid ""
"Don't use a gateway to send out the packet, send to hosts only on directly "
"connected networks.  This is usually used only by diagnostic or routing "
"programs.  This is defined only for protocol families that route; packet "
"sockets don't."
msgstr ""

#. type: TP
#: man-pages/man2/send.2:188 man-pages/man2/recv.2:129
#, no-wrap
msgid "B<MSG_DONTWAIT> (since Linux 2.2)"
msgstr ""

#. type: Plain text
#: man-pages/man2/send.2:209
msgid ""
"Enables nonblocking operation; if the operation would block, B<EAGAIN> or "
"B<EWOULDBLOCK> is returned.  This provides similar behavior to setting the "
"B<O_NONBLOCK> flag (via the B<fcntl>(2)  B<F_SETFL> operation), but differs "
"in that B<MSG_DONTWAIT> is a per-call option, whereas B<O_NONBLOCK> is a "
"setting on the open file description (see B<open>(2)), which will affect all "
"threads in the calling process and as well as other processes that hold file "
"descriptors referring to the same open file description."
msgstr ""

#. type: TP
#: man-pages/man2/send.2:209
#, no-wrap
msgid "B<MSG_EOR> (since Linux 2.2)"
msgstr ""

#. type: Plain text
#: man-pages/man2/send.2:213
msgid ""
"Terminates a record (when this notion is supported, as for sockets of type "
"B<SOCK_SEQPACKET>)."
msgstr ""

#. type: TP
#: man-pages/man2/send.2:213
#, no-wrap
msgid "B<MSG_MORE> (since Linux 2.4.4)"
msgstr ""

#. type: Plain text
#: man-pages/man2/send.2:222
msgid ""
"The caller has more data to send.  This flag is used with TCP sockets to "
"obtain the same effect as the B<TCP_CORK> socket option (see B<tcp>(7)), "
"with the difference that this flag can be set on a per-call basis."
msgstr ""

#. type: Plain text
#: man-pages/man2/send.2:231
msgid ""
"Since Linux 2.6, this flag is also supported for UDP sockets, and informs "
"the kernel to package all of the data sent in calls with this flag set into "
"a single datagram which is transmitted only when a call is performed that "
"does not specify this flag.  (See also the B<UDP_CORK> socket option "
"described in B<udp>(7).)"
msgstr ""

#. type: TP
#: man-pages/man2/send.2:231
#, no-wrap
msgid "B<MSG_NOSIGNAL> (since Linux 2.2)"
msgstr ""

#. type: Plain text
#: man-pages/man2/send.2:249
msgid ""
"Don't generate a B<SIGPIPE> signal if the peer on a stream-oriented socket "
"has closed the connection.  The B<EPIPE> error is still returned.  This "
"provides similar behavior to using B<sigaction>(2)  to ignore B<SIGPIPE>, "
"but, whereas B<MSG_NOSIGNAL> is a per-call feature, ignoring B<SIGPIPE> sets "
"a process attribute that affects all threads in the process."
msgstr ""

#. type: TP
#: man-pages/man2/send.2:249 man-pages/man2/recv.2:230
#: man-pages/man2/recv.2:423
#, no-wrap
msgid "B<MSG_OOB>"
msgstr ""

#. type: Plain text
#: man-pages/man2/send.2:258
msgid ""
"Sends I<out-of-band> data on sockets that support this notion (e.g., of type "
"B<SOCK_STREAM>); the underlying protocol must also support I<out-of-band> "
"data."
msgstr ""

#. type: SS
#: man-pages/man2/send.2:258
#, no-wrap
msgid "sendmsg()"
msgstr ""

#. type: Plain text
#: man-pages/man2/send.2:264
msgid ""
"The definition of the I<msghdr> structure employed by B<sendmsg>()  is as "
"follows:"
msgstr ""

#. type: Plain text
#: man-pages/man2/send.2:276
#, no-wrap
msgid ""
"struct msghdr {\n"
"    void         *msg_name;       /* Optional address */\n"
"    socklen_t     msg_namelen;    /* Size of address */\n"
"    struct iovec *msg_iov;        /* Scatter/gather array */\n"
"    size_t        msg_iovlen;     /* # elements in msg_iov */\n"
"    void         *msg_control;    /* Ancillary data, see below */\n"
"    size_t        msg_controllen; /* Ancillary data buffer len */\n"
"    int           msg_flags;      /* Flags (unused) */\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/send.2:288
msgid ""
"The I<msg_name> field is used on an unconnected socket to specify the target "
"address for a datagram.  It points to a buffer containing the address; the "
"I<msg_namelen> field should be set to the size of the address.  For a "
"connected socket, these fields should be specified as NULL and 0, "
"respectively."
msgstr ""

#. type: Plain text
#: man-pages/man2/send.2:295
msgid ""
"The I<msg_iov> and I<msg_iovlen> fields specify scatter-gather locations, as "
"for B<writev>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/send.2:306
msgid ""
"You may send control information using the I<msg_control> and "
"I<msg_controllen> members.  The maximum control buffer length the kernel can "
"process is limited per socket by the value in "
"I</proc/sys/net/core/optmem_max>; see B<socket>(7)."
msgstr ""

#.  Still to be documented:
#.   Send file descriptors and user credentials using the
#.   msg_control* fields.
#. type: Plain text
#: man-pages/man2/send.2:313
msgid "The I<msg_flags> field is ignored."
msgstr ""

#. type: Plain text
#: man-pages/man2/send.2:318
msgid ""
"On success, these calls return the number of bytes sent.  On error, -1 is "
"returned, and I<errno> is set appropriately."
msgstr ""

#. type: Plain text
#: man-pages/man2/send.2:323
msgid ""
"These are some standard errors generated by the socket layer.  Additional "
"errors may be generated and returned from the underlying protocol modules; "
"see their respective manual pages."
msgstr ""

#. type: Plain text
#: man-pages/man2/send.2:331
msgid ""
"(For UNIX domain sockets, which are identified by pathname)  Write "
"permission is denied on the destination socket file, or search permission is "
"denied for one of the directories the path prefix.  (See "
"B<path_resolution>(7).)"
msgstr ""

#. type: Plain text
#: man-pages/man2/send.2:334
msgid ""
"(For UDP sockets) An attempt was made to send to a network/broadcast address "
"as though it was a unicast address."
msgstr ""

#. type: TP
#: man-pages/man2/send.2:334 man-pages/man2/write.2:144
#: man-pages/man2/recv.2:451 man-pages/man2/accept.2:207
#: man-pages/man2/read.2:111
#, no-wrap
msgid "B<EAGAIN> or B<EWOULDBLOCK>"
msgstr ""

#.  Actually EAGAIN on Linux
#. type: Plain text
#: man-pages/man2/send.2:342
msgid ""
"The socket is marked nonblocking and the requested operation would block.  "
"POSIX.1-2001 allows either error to be returned for this case, and does not "
"require these constants to have the same value, so a portable application "
"should check for both possibilities."
msgstr ""

#. type: Plain text
#: man-pages/man2/send.2:355
msgid ""
"(Internet domain datagram sockets)  The socket referred to by I<sockfd> had "
"not previously been bound to an address and, upon attempting to bind it to "
"an ephemeral port, it was determined that all port numbers in the ephemeral "
"port range are currently in use.  See the discussion of "
"I</proc/sys/net/ipv4/ip_local_port_range> in B<ip>(7)."
msgstr ""

#. type: TP
#: man-pages/man2/send.2:355 man-pages/man2/connect.2:174
#, no-wrap
msgid "B<EALREADY>"
msgstr ""

#. type: Plain text
#: man-pages/man2/send.2:358
msgid "Another Fast Open is in progress."
msgstr ""

#. type: Plain text
#: man-pages/man2/send.2:362 man-pages/man2/connect.2:182
msgid "I<sockfd> is not a valid open file descriptor."
msgstr ""

#. type: TP
#: man-pages/man2/send.2:362
#, no-wrap
msgid "B<ECONNRESET>"
msgstr ""

#. type: Plain text
#: man-pages/man2/send.2:365
msgid "Connection reset by peer."
msgstr ""

#. type: TP
#: man-pages/man2/send.2:365 man-pages/man2/write.2:159
#, no-wrap
msgid "B<EDESTADDRREQ>"
msgstr ""

#. type: Plain text
#: man-pages/man2/send.2:368
msgid "The socket is not connection-mode, and no peer address is set."
msgstr ""

#. type: Plain text
#: man-pages/man2/send.2:371
msgid "An invalid user space address was specified for an argument."
msgstr ""

#. type: Plain text
#: man-pages/man2/send.2:375
msgid "A signal occurred before any data was transmitted; see B<signal>(7)."
msgstr ""

#.  e.g., msg_namelen < 0 for recvmsg() or addrlen < 0 for recvfrom()
#. type: Plain text
#: man-pages/man2/send.2:378 man-pages/man2/recv.2:482
msgid "Invalid argument passed."
msgstr ""

#. type: TP
#: man-pages/man2/send.2:378 man-pages/man2/connect.2:223
#, no-wrap
msgid "B<EISCONN>"
msgstr ""

#. type: Plain text
#: man-pages/man2/send.2:384
msgid ""
"The connection-mode socket was connected already but a recipient was "
"specified.  (Now either this error is returned, or the recipient "
"specification is ignored.)"
msgstr ""

#. type: TP
#: man-pages/man2/send.2:384 man-pages/man2/keyctl.2:1819
#, no-wrap
msgid "B<EMSGSIZE>"
msgstr ""

#.  (e.g., SOCK_DGRAM )
#. type: Plain text
#: man-pages/man2/send.2:390
msgid ""
"The socket type requires that message be sent atomically, and the size of "
"the message to be sent made this impossible."
msgstr ""

#. type: Plain text
#: man-pages/man2/send.2:398
msgid ""
"The output queue for a network interface was full.  This generally indicates "
"that the interface has stopped sending, but may be caused by transient "
"congestion.  (Normally, this does not occur in Linux.  Packets are just "
"silently dropped when a device queue overflows.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/send.2:401
msgid "No memory available."
msgstr ""

#. type: Plain text
#: man-pages/man2/send.2:404
msgid "The socket is not connected, and no target has been given."
msgstr ""

#. type: Plain text
#: man-pages/man2/send.2:414
msgid "Some bit in the I<flags> argument is inappropriate for the socket type."
msgstr ""

#. type: TP
#: man-pages/man2/send.2:414 man-pages/man2/write.2:231
#, no-wrap
msgid "B<EPIPE>"
msgstr ""

#. type: Plain text
#: man-pages/man2/send.2:423
msgid ""
"The local end has been shut down on a connection oriented socket.  In this "
"case, the process will also receive a B<SIGPIPE> unless B<MSG_NOSIGNAL> is "
"set."
msgstr ""

#. type: Plain text
#: man-pages/man2/send.2:426
msgid "4.4BSD, SVr4, POSIX.1-2001.  These interfaces first appeared in 4.2BSD."
msgstr ""

#. type: Plain text
#: man-pages/man2/send.2:437
msgid ""
"POSIX.1-2001 describes only the B<MSG_OOB> and B<MSG_EOR> flags.  "
"POSIX.1-2008 adds a specification of B<MSG_NOSIGNAL>.  The B<MSG_CONFIRM> "
"flag is a Linux extension."
msgstr ""

#.  glibc bug raised 12 Mar 2006
#.  http://sourceware.org/bugzilla/show_bug.cgi?id=2448
#.  The problem is an underlying kernel issue: the size of the
#.  __kernel_size_t type used to type this field varies
#.  across architectures, but socklen_t is always 32 bits.
#. type: Plain text
#: man-pages/man2/send.2:451
msgid ""
"According to POSIX.1-2001, the I<msg_controllen> field of the I<msghdr> "
"structure should be typed as I<socklen_t>, but glibc currently types it as "
"I<size_t>."
msgstr ""

#. type: Plain text
#: man-pages/man2/send.2:456
msgid ""
"See B<sendmmsg>(2)  for information about a Linux-specific system call that "
"can be used to transmit multiple datagrams in a single call."
msgstr ""

#. type: Plain text
#: man-pages/man2/send.2:461
msgid "Linux may return B<EPIPE> instead of B<ENOTCONN>."
msgstr ""

#. type: Plain text
#: man-pages/man2/send.2:466
msgid "An example of the use of B<sendto>()  is shown in B<getaddrinfo>(3)."
msgstr ""

#. type: Plain text
#: man-pages/man2/send.2:482
msgid ""
"B<fcntl>(2), B<getsockopt>(2), B<recv>(2), B<select>(2), B<sendfile>(2), "
"B<sendmmsg>(2), B<shutdown>(2), B<socket>(2), B<write>(2), B<cmsg>(3), "
"B<ip>(7), B<ipv6>(7), B<socket>(7), B<tcp>(7), B<udp>(7), B<unix>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/msgctl.2:38
#, no-wrap
msgid "MSGCTL"
msgstr ""

#. type: Plain text
#: man-pages/man2/msgctl.2:41
msgid "msgctl - System V message control operations"
msgstr ""

#. type: Plain text
#: man-pages/man2/msgctl.2:48
#, no-wrap
msgid "B<int msgctl(int >I<msqid>B<, int >I<cmd>B<, struct msqid_ds *>I<buf>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/msgctl.2:55
msgid ""
"B<msgctl>()  performs the control operation specified by I<cmd> on the "
"System\\ V message queue with identifier I<msqid>."
msgstr ""

#. type: Plain text
#: man-pages/man2/msgctl.2:59
msgid ""
"The I<msqid_ds> data structure is defined in I<E<lt>sys/msg.hE<gt>> as "
"follows:"
msgstr ""

#. type: Plain text
#: man-pages/man2/msgctl.2:76
#, no-wrap
msgid ""
"struct msqid_ds {\n"
"    struct ipc_perm msg_perm;     /* Ownership and permissions */\n"
"    time_t          msg_stime;    /* Time of last msgsnd(2) */\n"
"    time_t          msg_rtime;    /* Time of last msgrcv(2) */\n"
"    time_t          msg_ctime;    /* Time of last change */\n"
"    unsigned long   __msg_cbytes; /* Current number of bytes in\n"
"                                     queue (nonstandard) */\n"
"    msgqnum_t       msg_qnum;     /* Current number of messages\n"
"                                     in queue */\n"
"    msglen_t        msg_qbytes;   /* Maximum number of bytes\n"
"                                     allowed in queue */\n"
"    pid_t           msg_lspid;    /* PID of last msgsnd(2) */\n"
"    pid_t           msg_lrpid;    /* PID of last msgrcv(2) */\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/msgctl.2:84 man-pages/man2/shmctl.2:90
#: man-pages/man2/semctl.2:102
msgid ""
"The I<ipc_perm> structure is defined as follows (the highlighted fields are "
"settable using B<IPC_SET>):"
msgstr ""

#. type: Plain text
#: man-pages/man2/msgctl.2:96
#, no-wrap
msgid ""
"struct ipc_perm {\n"
"    key_t          __key;       /* Key supplied to msgget(2) */\n"
"    uid_t          B<uid>;         /* Effective UID of owner */\n"
"    gid_t          B<gid>;         /* Effective GID of owner */\n"
"    uid_t          cuid;        /* Effective UID of creator */\n"
"    gid_t          cgid;        /* Effective GID of creator */\n"
"    unsigned short B<mode>;        /* Permissions */\n"
"    unsigned short __seq;       /* Sequence number */\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/msgctl.2:102 man-pages/man2/shmctl.2:109
#: man-pages/man2/semctl.2:120
msgid "Valid values for I<cmd> are:"
msgstr ""

#. type: TP
#: man-pages/man2/msgctl.2:102 man-pages/man2/shmctl.2:109
#: man-pages/man2/semctl.2:120
#, no-wrap
msgid "B<IPC_STAT>"
msgstr ""

#. type: Plain text
#: man-pages/man2/msgctl.2:111
msgid ""
"Copy information from the kernel data structure associated with I<msqid> "
"into the I<msqid_ds> structure pointed to by I<buf>.  The caller must have "
"read permission on the message queue."
msgstr ""

#. type: TP
#: man-pages/man2/msgctl.2:111 man-pages/man2/shmctl.2:118
#: man-pages/man2/semctl.2:132
#, no-wrap
msgid "B<IPC_SET>"
msgstr ""

#. type: Plain text
#: man-pages/man2/msgctl.2:138
msgid ""
"Write the values of some members of the I<msqid_ds> structure pointed to by "
"I<buf> to the kernel data structure associated with this message queue, "
"updating also its I<msg_ctime> member.  The following members of the "
"structure are updated: I<msg_qbytes>, I<msg_perm.uid>, I<msg_perm.gid>, and "
"(the least significant 9 bits of)  I<msg_perm.mode>.  The effective UID of "
"the calling process must match the owner (I<msg_perm.uid>)  or creator "
"(I<msg_perm.cuid>)  of the message queue, or the caller must be privileged.  "
"Appropriate privilege (Linux: the B<CAP_SYS_RESOURCE> capability) is "
"required to raise the I<msg_qbytes> value beyond the system parameter "
"B<MSGMNB>."
msgstr ""

#. type: TP
#: man-pages/man2/msgctl.2:138 man-pages/man2/shmctl.2:136
#: man-pages/man2/semctl.2:155
#, no-wrap
msgid "B<IPC_RMID>"
msgstr ""

#. type: Plain text
#: man-pages/man2/msgctl.2:152
msgid ""
"Immediately remove the message queue, awakening all waiting reader and "
"writer processes (with an error return and I<errno> set to B<EIDRM>).  The "
"calling process must have appropriate privileges or its effective user ID "
"must be either that of the creator or owner of the message queue.  The third "
"argument to B<msgctl>()  is ignored in this case."
msgstr ""

#. type: TP
#: man-pages/man2/msgctl.2:152 man-pages/man2/shmctl.2:165
#: man-pages/man2/semctl.2:170
#, no-wrap
msgid "B<IPC_INFO> (Linux-specific)"
msgstr ""

#. type: Plain text
#: man-pages/man2/msgctl.2:165
msgid ""
"Return information about system-wide message queue limits and parameters in "
"the structure pointed to by I<buf>.  This structure is of type I<msginfo> "
"(thus, a cast is required), defined in I<E<lt>sys/msg.hE<gt>> if the "
"B<_GNU_SOURCE> feature test macro is defined:"
msgstr ""

#. type: Plain text
#: man-pages/man2/msgctl.2:189
#, no-wrap
msgid ""
"struct msginfo {\n"
"    int msgpool; /* Size in kibibytes of buffer pool\n"
"                    used to hold message data;\n"
"                    unused within kernel */\n"
"    int msgmap;  /* Maximum number of entries in message\n"
"                    map; unused within kernel */\n"
"    int msgmax;  /* Maximum number of bytes that can be\n"
"                    written in a single message */\n"
"    int msgmnb;  /* Maximum number of bytes that can be\n"
"                    written to queue; used to initialize\n"
"                    msg_qbytes during queue creation\n"
"                    (msgget(2)) */\n"
"    int msgmni;  /* Maximum number of message queues */\n"
"    int msgssz;  /* Message segment size;\n"
"                    unused within kernel */\n"
"    int msgtql;  /* Maximum number of messages on all queues\n"
"                    in system; unused within kernel */\n"
"    unsigned short int msgseg;\n"
"                 /* Maximum number of segments;\n"
"                    unused within kernel */\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/msgctl.2:202
msgid ""
"The I<msgmni>, I<msgmax>, and I<msgmnb> settings can be changed via I</proc> "
"files of the same name; see B<proc>(5)  for details."
msgstr ""

#. type: TP
#: man-pages/man2/msgctl.2:202
#, no-wrap
msgid "B<MSG_INFO> (Linux-specific)"
msgstr ""

#. type: Plain text
#: man-pages/man2/msgctl.2:219
msgid ""
"Return a I<msginfo> structure containing the same information as for "
"B<IPC_INFO>, except that the following fields are returned with information "
"about system resources consumed by message queues: the I<msgpool> field "
"returns the number of message queues that currently exist on the system; the "
"I<msgmap> field returns the total number of messages in all queues on the "
"system; and the I<msgtql> field returns the total number of bytes in all "
"messages in all queues on the system."
msgstr ""

#. type: TP
#: man-pages/man2/msgctl.2:219
#, no-wrap
msgid "B<MSG_STAT> (Linux-specific)"
msgstr ""

#. type: Plain text
#: man-pages/man2/msgctl.2:230
msgid ""
"Return a I<msqid_ds> structure as for B<IPC_STAT>.  However, the I<msqid> "
"argument is not a queue identifier, but instead an index into the kernel's "
"internal array that maintains information about all message queues on the "
"system."
msgstr ""

#. type: TP
#: man-pages/man2/msgctl.2:230
#, no-wrap
msgid "B<MSG_STAT_ANY> (Linux-specific, since Linux 4.17)"
msgstr ""

#. type: Plain text
#: man-pages/man2/msgctl.2:243
msgid ""
"Return a I<msqid_ds> structure as for B<MSG_STAT>.  However, "
"I<msg_perm.mode> is not checked for read access for I<msqid> meaning that "
"any user can employ this operation (just as any user may read "
"I</proc/sysvipc/msg> to obtain the same information)."
msgstr ""

#. type: Plain text
#: man-pages/man2/msgctl.2:268
msgid ""
"On success, B<IPC_STAT>, B<IPC_SET>, and B<IPC_RMID> return 0.  A successful "
"B<IPC_INFO> or B<MSG_INFO> operation returns the index of the highest used "
"entry in the kernel's internal array recording information about all message "
"queues.  (This information can be used with repeated B<MSG_STAT> or "
"B<MSG_STAT_ANY> operations to obtain information about all queues on the "
"system.)  A successful B<MSG_STAT> or B<MSG_STAT_ANY> operation returns the "
"identifier of the queue whose index was given in I<msqid>."
msgstr ""

#. type: Plain text
#: man-pages/man2/msgctl.2:272
msgid "On error, -1 is returned with I<errno> indicating the error."
msgstr ""

#. type: Plain text
#: man-pages/man2/msgctl.2:289
msgid ""
"The argument I<cmd> is equal to B<IPC_STAT> or B<MSG_STAT>, but the calling "
"process does not have read permission on the message queue I<msqid>, and "
"does not have the B<CAP_IPC_OWNER> capability in the user namespace that "
"governs its IPC namespace."
msgstr ""

#. type: Plain text
#: man-pages/man2/msgctl.2:300
msgid ""
"The argument I<cmd> has the value B<IPC_SET> or B<IPC_STAT>, but the address "
"pointed to by I<buf> isn't accessible."
msgstr ""

#. type: Plain text
#: man-pages/man2/msgctl.2:314
msgid ""
"Invalid value for I<cmd> or I<msqid>.  Or: for a B<MSG_STAT> operation, the "
"index value specified in I<msqid> referred to an array slot that is "
"currently unused."
msgstr ""

#. type: Plain text
#: man-pages/man2/msgctl.2:332
msgid ""
"The argument I<cmd> has the value B<IPC_SET> or B<IPC_RMID>, but the "
"effective user ID of the calling process is not the creator (as found in "
"I<msg_perm.cuid>)  or the owner (as found in I<msg_perm.uid>)  of the "
"message queue, and the caller is not privileged (Linux: does not have the "
"B<CAP_SYS_ADMIN> capability)."
msgstr ""

#. type: Plain text
#: man-pages/man2/msgctl.2:343
msgid ""
"An attempt (B<IPC_SET>)  was made to increase I<msg_qbytes> beyond the "
"system parameter B<MSGMNB>, but the caller is not privileged (Linux: does "
"not have the B<CAP_SYS_RESOURCE> capability)."
msgstr ""

#. type: Plain text
#: man-pages/man2/msgctl.2:371
msgid ""
"The B<IPC_INFO>, B<MSG_STAT> and B<MSG_INFO> operations are used by the "
"B<ipcs>(1)  program to provide information on allocated resources.  In the "
"future these may modified or moved to a I</proc> filesystem interface."
msgstr ""

#. type: Plain text
#: man-pages/man2/msgctl.2:385
msgid ""
"Various fields in the I<struct msqid_ds> were typed as I<short> under Linux "
"2.2 and have become I<long> under Linux 2.4.  To take advantage of this, a "
"recompilation under glibc-2.1.91 or later should suffice.  (The kernel "
"distinguishes old and new calls by an B<IPC_64> flag in I<cmd>.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/msgctl.2:391
msgid ""
"B<msgget>(2), B<msgrcv>(2), B<msgsnd>(2), B<capabilities>(7), "
"B<mq_overview>(7), B<sysvipc>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/sigreturn.2:30
#, no-wrap
msgid "SIGRETURN"
msgstr ""

#. type: Plain text
#: man-pages/man2/sigreturn.2:33
msgid "sigreturn, rt_sigreturn - return from signal handler and cleanup stack frame"
msgstr ""

#. type: Plain text
#: man-pages/man2/sigreturn.2:35
msgid "B<int sigreturn(...);>"
msgstr ""

#.  See arch/x86/kernel/signal.c::__setup_frame() [in 3.17 source code]
#. type: Plain text
#: man-pages/man2/sigreturn.2:45
msgid ""
"If the Linux kernel determines that an unblocked signal is pending for a "
"process, then, at the next transition back to user mode in that process "
"(e.g., upon return from a system call or when the process is rescheduled "
"onto the CPU), it creates a new frame on the user-space stack where it saves "
"various pieces of process context (processor status word, registers, signal "
"mask, and signal stack settings)."
msgstr ""

#. type: Plain text
#: man-pages/man2/sigreturn.2:52
msgid ""
"The kernel also arranges that, during the transition back to user mode, the "
"signal handler is called, and that, upon return from the handler, control "
"passes to a piece of user-space code commonly called the \"signal "
"trampoline\".  The signal trampoline code in turn calls B<sigreturn>()."
msgstr ""

#. type: Plain text
#: man-pages/man2/sigreturn.2:67
msgid ""
"This B<sigreturn>()  call undoes everything that was done\\(emchanging the "
"process's signal mask, switching signal stacks (see "
"B<sigaltstack>(2))\\(emin order to invoke the signal handler.  Using the "
"information that was earlier saved on the user-space stack B<sigreturn>()  "
"restores the process's signal mask, switches stacks, and restores the "
"process's context (processor flags and registers, including the stack "
"pointer and instruction pointer), so that the process resumes execution at "
"the point where it was interrupted by the signal."
msgstr ""

#. type: Plain text
#: man-pages/man2/sigreturn.2:70
msgid "B<sigreturn>()  never returns."
msgstr ""

#. type: Plain text
#: man-pages/man2/sigreturn.2:76
msgid ""
"Many UNIX-type systems have a B<sigreturn>()  system call or near "
"equivalent.  However, this call is not specified in POSIX, and details of "
"its behavior vary across systems."
msgstr ""

#.  See sysdeps/unix/sysv/linux/sigreturn.c and
#.  signal/sigreturn.c in the glibc source
#. type: Plain text
#: man-pages/man2/sigreturn.2:98
msgid ""
"B<sigreturn>()  exists only to allow the implementation of signal handlers.  "
"It should B<never> be called directly.  (Indeed, a simple B<sigreturn>()  "
"wrapper in the GNU C library simply returns -1, with I<errno> set to "
"B<ENOSYS>.)  Details of the arguments (if any) passed to B<sigreturn>()  "
"vary depending on the architecture.  (On some architectures, such as x86-64, "
"B<sigreturn>()  takes no arguments, since all of the information that it "
"requires is available in the stack frame that was previously created by the "
"kernel on the user-space stack.)"
msgstr ""

#.  See, for example, sysdeps/unix/sysv/linux/i386/sigaction.c and
#.  sysdeps/unix/sysv/linux/x86_64/sigaction.c in the glibc (2.20) source.
#. type: Plain text
#: man-pages/man2/sigreturn.2:123
msgid ""
"Once upon a time, UNIX systems placed the signal trampoline code onto the "
"user stack.  Nowadays, pages of the user stack are protected so as to "
"disallow code execution.  Thus, on contemporary Linux systems, depending on "
"the architecture, the signal trampoline code lives either in the B<vdso>(7)  "
"or in the C library.  In the latter case, the C library's B<sigaction>(2)  "
"wrapper function informs the kernel of the location of the trampoline code "
"by placing its address in the I<sa_restorer> field of the I<sigaction> "
"structure, and sets the B<SA_RESTORER> flag in the I<sa_flags> field."
msgstr ""

#. type: Plain text
#: man-pages/man2/sigreturn.2:134
msgid ""
"The saved process context information is placed in a I<ucontext_t> structure "
"(see I<E<lt>sys/ucontext.hE<gt>>).  That structure is visible within the "
"signal handler as the third argument of a handler established via "
"B<sigaction>(2)  with the B<SA_SIGINFO> flag."
msgstr ""

#. type: Plain text
#: man-pages/man2/sigreturn.2:143
msgid ""
"On some other UNIX systems, the operation of the signal trampoline differs a "
"little.  In particular, on some systems, upon transitioning back to user "
"mode, the kernel passes control to the trampoline (rather than the signal "
"handler), and the trampoline code calls the signal handler (and then calls "
"B<sigreturn>()  once the handler returns)."
msgstr ""

#. type: Plain text
#: man-pages/man2/sigreturn.2:157
msgid ""
"The original Linux system call was named B<sigreturn>().  However, with the "
"addition of real-time signals in Linux 2.2, a new system call, "
"B<rt_sigreturn>()  was added to support an enlarged I<sigset_t> type.  The "
"GNU C library hides these details from us, transparently employing "
"B<rt_sigreturn>()  when the kernel provides it."
msgstr ""

#. type: Plain text
#: man-pages/man2/sigreturn.2:164
msgid ""
"B<kill>(2), B<restart_syscall>(2), B<sigaltstack>(2), B<signal>(2), "
"B<getcontext>(3), B<signal>(7), B<vdso>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/setuid.2:31
#, no-wrap
msgid "SETUID"
msgstr ""

#. type: Plain text
#: man-pages/man2/setuid.2:34
msgid "setuid - set user identity"
msgstr ""

#. type: Plain text
#: man-pages/man2/setuid.2:40
msgid "B<int setuid(uid_t >I<uid>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/setuid.2:48
msgid ""
"B<setuid>()  sets the effective user ID of the calling process.  If the "
"calling process is privileged (more precisely: if the process has the "
"B<CAP_SETUID> capability in its user namespace), the real UID and saved "
"set-user-ID are also set."
msgstr ""

#. type: Plain text
#: man-pages/man2/setuid.2:57
msgid ""
"Under Linux, B<setuid>()  is implemented like the POSIX version with the "
"B<_POSIX_SAVED_IDS> feature.  This allows a set-user-ID (other than root) "
"program to drop all of its user privileges, do some un-privileged work, and "
"then reengage the original effective user ID in a secure manner."
msgstr ""

#. type: Plain text
#: man-pages/man2/setuid.2:66
msgid ""
"If the user is root or the program is set-user-ID-root, special care must be "
"taken: B<setuid>()  checks the effective user ID of the caller and if it is "
"the superuser, all process-related user ID's are set to I<uid>.  After this "
"has occurred, it is impossible for the program to regain root privileges."
msgstr ""

#. type: Plain text
#: man-pages/man2/setuid.2:73
msgid ""
"Thus, a set-user-ID-root program wishing to temporarily drop root "
"privileges, assume the identity of an unprivileged user, and then regain "
"root privileges afterward cannot use B<setuid>().  You can accomplish this "
"with B<seteuid>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/setuid.2:85
msgid ""
"I<Note>: there are cases where B<setuid>()  can fail even when the caller is "
"UID 0; it is a grave security error to omit checking for a failure return "
"from B<setuid>()."
msgstr ""

#. type: Plain text
#: man-pages/man2/setuid.2:93
msgid ""
"The call would change the caller's real UID (i.e., I<uid> does not match the "
"caller's real UID), but there was a temporary failure allocating the "
"necessary kernel data structures."
msgstr ""

#. type: Plain text
#: man-pages/man2/setuid.2:108
msgid ""
"I<uid> does not match the real user ID of the caller and this call would "
"bring the number of processes belonging to the real user ID I<uid> over the "
"caller's B<RLIMIT_NPROC> resource limit.  Since Linux 3.1, this error case "
"no longer occurs (but robust applications should check for this error); see "
"the description of B<EAGAIN> in B<execve>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/setuid.2:113
msgid "The user ID specified in I<uid> is not valid in this user namespace."
msgstr ""

#. type: Plain text
#: man-pages/man2/setuid.2:120
msgid ""
"The user is not privileged (Linux: does not have the B<CAP_SETUID> "
"capability in its user namespace) and I<uid> does not match the real UID or "
"saved set-user-ID of the calling process."
msgstr ""

#.  SVr4 documents an additional EINVAL error condition.
#. type: Plain text
#: man-pages/man2/setuid.2:125
msgid ""
"POSIX.1-2001, POSIX.1-2008, SVr4.  Not quite compatible with the 4.4BSD "
"call, which sets all of the real, saved, and effective user IDs."
msgstr ""

#. type: Plain text
#: man-pages/man2/setuid.2:133
msgid ""
"Linux has the concept of the filesystem user ID, normally equal to the "
"effective user ID.  The B<setuid>()  call also sets the filesystem user ID "
"of the calling process.  See B<setfsuid>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/setuid.2:138
msgid ""
"If I<uid> is different from the old effective UID, the process will be "
"forbidden from leaving core dumps."
msgstr ""

#. type: Plain text
#: man-pages/man2/setuid.2:149
msgid ""
"The original Linux B<setuid>()  system call supported only 16-bit user IDs.  "
"Subsequently, Linux 2.4 added B<setuid32>()  supporting 32-bit IDs.  The "
"glibc B<setuid>()  wrapper function transparently deals with the variation "
"across kernel versions."
msgstr ""

#. type: Plain text
#: man-pages/man2/setuid.2:163
msgid ""
"At the kernel level, user IDs and group IDs are a per-thread attribute.  "
"However, POSIX requires that all threads in a process share the same "
"credentials.  The NPTL threading implementation handles the POSIX "
"requirements by providing wrapper functions for the various system calls "
"that change process UIDs and GIDs.  These wrapper functions (including the "
"one for B<setuid>())  employ a signal-based technique to ensure that when "
"one thread changes credentials, all of the other threads in the process also "
"change their credentials.  For details, see B<nptl>(7)."
msgstr ""

#. type: Plain text
#: man-pages/man2/setuid.2:170
msgid ""
"B<getuid>(2), B<seteuid>(2), B<setfsuid>(2), B<setreuid>(2), "
"B<capabilities>(7), B<credentials>(7), B<user_namespaces>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/spu_create.2:25
#, no-wrap
msgid "SPU_CREATE"
msgstr ""

#. type: Plain text
#: man-pages/man2/spu_create.2:28
msgid "spu_create - create a new spu context"
msgstr ""

#. type: Plain text
#: man-pages/man2/spu_create.2:32
#, no-wrap
msgid ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>sys/spu.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/spu_create.2:36
#, no-wrap
msgid ""
"B<int spu_create(const char *>I<pathname>B<, int >I<flags>B<, mode_t "
">I<mode>B<);>\n"
"B<int spu_create(const char *>I<pathname>B<, int >I<flags>B<, mode_t "
">I<mode>B<,>\n"
"B<               int >I<neighbor_fd>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/spu_create.2:59
msgid ""
"The B<spu_create>()  system call is used on PowerPC machines that implement "
"the Cell Broadband Engine Architecture in order to access Synergistic "
"Processor Units (SPUs).  It creates a new logical context for an SPU in "
"I<pathname> and returns a file descriptor associated with it.  I<pathname> "
"must refer to a nonexistent directory in the mount point of the SPU "
"filesystem (B<spufs>).  If B<spu_create>()  is successful, a directory is "
"created at I<pathname> and it is populated with the files described in "
"B<spufs>(7)."
msgstr ""

#. type: Plain text
#: man-pages/man2/spu_create.2:78
msgid ""
"When a context is created, the returned file descriptor can only be passed "
"to B<spu_run>(2), used as the I<dirfd> argument to the B<*at> family of "
"system calls (e.g., B<openat>(2)), or closed; other operations are not "
"defined.  A logical SPU context is destroyed (along with all files created "
"within the context's I<pathname> directory) once the last reference to the "
"context has gone; this usually occurs when the file descriptor returned by "
"B<spu_create>()  is closed."
msgstr ""

#. type: Plain text
#: man-pages/man2/spu_create.2:83
msgid ""
"The I<flags> argument can be zero or any bitwise OR-ed combination of the "
"following constants:"
msgstr ""

#. type: TP
#: man-pages/man2/spu_create.2:83
#, no-wrap
msgid "B<SPU_CREATE_EVENTS_ENABLED>"
msgstr ""

#. type: Plain text
#: man-pages/man2/spu_create.2:89
msgid ""
"Rather than using signals for reporting DMA errors, use the I<event> "
"argument to B<spu_run>(2)."
msgstr ""

#. type: TP
#: man-pages/man2/spu_create.2:89
#, no-wrap
msgid "B<SPU_CREATE_GANG>"
msgstr ""

#. type: Plain text
#: man-pages/man2/spu_create.2:97
msgid ""
"Create an SPU gang instead of a context.  (A gang is a group of SPU contexts "
"that are functionally related to each other and which share common "
"scheduling parameters\\(empriority and policy.  In the future, gang "
"scheduling may be implemented causing the group to be switched in and out as "
"a single unit.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/spu_create.2:104
msgid ""
"A new directory will be created at the location specified by the I<pathname> "
"argument.  This gang may be used to hold other SPU contexts, by providing a "
"pathname that is within the gang directory to further calls to "
"B<spu_create>()."
msgstr ""

#. type: TP
#: man-pages/man2/spu_create.2:104
#, no-wrap
msgid "B<SPU_CREATE_NOSCHED>"
msgstr ""

#. type: Plain text
#: man-pages/man2/spu_create.2:110
msgid ""
"Create a context that is not affected by the SPU scheduler.  Once the "
"context is run, it will not be scheduled out until it is destroyed by the "
"creating process."
msgstr ""

#. type: Plain text
#: man-pages/man2/spu_create.2:121
msgid ""
"Because the context cannot be removed from the SPU, some functionality is "
"disabled for B<SPU_CREATE_NOSCHED> contexts.  Only a subset of the files "
"will be available in this context directory in B<spufs>.  Additionally, "
"B<SPU_CREATE_NOSCHED> contexts cannot dump a core file when crashing."
msgstr ""

#. type: Plain text
#: man-pages/man2/spu_create.2:127
msgid ""
"Creating B<SPU_CREATE_NOSCHED> contexts requires the B<CAP_SYS_NICE> "
"capability."
msgstr ""

#. type: TP
#: man-pages/man2/spu_create.2:127
#, no-wrap
msgid "B<SPU_CREATE_ISOLATE>"
msgstr ""

#. type: Plain text
#: man-pages/man2/spu_create.2:134
msgid ""
"Create an isolated SPU context.  Isolated contexts are protected from some "
"PPE (PowerPC Processing Element)  operations, such as access to the SPU "
"local store and the NPC register."
msgstr ""

#. type: Plain text
#: man-pages/man2/spu_create.2:140
msgid ""
"Creating B<SPU_CREATE_ISOLATE> contexts also requires the "
"B<SPU_CREATE_NOSCHED> flag."
msgstr ""

#. type: TP
#: man-pages/man2/spu_create.2:140
#, no-wrap
msgid "B<SPU_CREATE_AFFINITY_SPU>"
msgstr ""

#. type: Plain text
#: man-pages/man2/spu_create.2:148
msgid ""
"Create a context with affinity to another SPU context.  This affinity "
"information is used within the SPU scheduling algorithm.  Using this flag "
"requires that a file descriptor referring to the other SPU context be passed "
"in the I<neighbor_fd> argument."
msgstr ""

#. type: TP
#: man-pages/man2/spu_create.2:148
#, no-wrap
msgid "B<SPU_CREATE_AFFINITY_MEM>"
msgstr ""

#. type: Plain text
#: man-pages/man2/spu_create.2:153
msgid ""
"Create a context with affinity to system memory.  This affinity information "
"is used within the SPU scheduling algorithm."
msgstr ""

#. type: Plain text
#: man-pages/man2/spu_create.2:165
msgid ""
"The I<mode> argument (minus any bits set in the process's B<umask>(2))  "
"specifies the permissions used for creating the new directory in B<spufs>.  "
"See B<stat>(2)  for a full list of the possible I<mode> values."
msgstr ""

#. type: Plain text
#: man-pages/man2/spu_create.2:172
msgid ""
"On success, B<spu_create>()  returns a new file descriptor.  On error, -1 is "
"returned, and I<errno> is set to one of the error codes listed below."
msgstr ""

#. type: Plain text
#: man-pages/man2/spu_create.2:178
msgid "The current user does not have write access to the B<spufs>(7)  mount point."
msgstr ""

#. type: Plain text
#: man-pages/man2/spu_create.2:181
msgid "An SPU context already exists at the given pathname."
msgstr ""

#. type: Plain text
#: man-pages/man2/spu_create.2:186
msgid ""
"I<pathname> is not a valid string pointer in the calling process's address "
"space."
msgstr ""

#. type: Plain text
#: man-pages/man2/spu_create.2:192
msgid ""
"I<pathname> is not a directory in the B<spufs>(7)  mount point, or invalid "
"flags have been provided."
msgstr ""

#. type: Plain text
#: man-pages/man2/spu_create.2:196
msgid "Too many symbolic links were found while resolving I<pathname>."
msgstr ""

#. type: Plain text
#: man-pages/man2/spu_create.2:210
msgid ""
"An isolated context was requested, but the hardware does not support SPU "
"isolation."
msgstr ""

#. type: Plain text
#: man-pages/man2/spu_create.2:215
msgid "Part of I<pathname> could not be resolved."
msgstr ""

#. type: Plain text
#: man-pages/man2/spu_create.2:218
msgid "The kernel could not allocate all resources required."
msgstr ""

#. type: Plain text
#: man-pages/man2/spu_create.2:223
msgid ""
"There are not enough SPU resources available to create a new context or the "
"user-specific limit for the number of SPU contexts has been reached."
msgstr ""

#. type: Plain text
#: man-pages/man2/spu_create.2:228 man-pages/man2/spu_run.2:188
msgid ""
"The functionality is not provided by the current system, because either the "
"hardware does not provide SPUs or the spufs module is not loaded."
msgstr ""

#. type: Plain text
#: man-pages/man2/spu_create.2:233
msgid "A part of I<pathname> is not a directory."
msgstr ""

#. type: Plain text
#: man-pages/man2/spu_create.2:240
msgid ""
"The I<SPU_CREATE_NOSCHED> flag has been given, but the user does not have "
"the B<CAP_SYS_NICE> capability."
msgstr ""

#. type: SH
#: man-pages/man2/spu_create.2:240 man-pages/man2/alloc_hugepages.2:122
#: man-pages/man2/_syscall.2:85
#, no-wrap
msgid "FILES"
msgstr ""

#. type: Plain text
#: man-pages/man2/spu_create.2:246
msgid ""
"I<pathname> must point to a location beneath the mount point of B<spufs>.  "
"By convention, it gets mounted in I</spu>."
msgstr ""

#. type: Plain text
#: man-pages/man2/spu_create.2:250
msgid "The B<spu_create>()  system call was added to Linux in kernel 2.6.16."
msgstr ""

#. type: Plain text
#: man-pages/man2/spu_create.2:254
msgid ""
"This call is Linux-specific and implemented only on the PowerPC "
"architecture.  Programs using this system call are not portable."
msgstr ""

#. type: Plain text
#: man-pages/man2/spu_create.2:265
msgid ""
"Glibc does not provide a wrapper for this system call; call it using "
"B<syscall>(2).  Note however, that B<spu_create>()  is meant to be used from "
"libraries that implement a more abstract interface to SPUs, not to be used "
"from regular applications.  See E<.UR "
"http://www.bsc.es\\:/projects\\:/deepcomputing\\:/linuxoncell/> E<.UE> for "
"the recommended libraries."
msgstr ""

#. type: Plain text
#: man-pages/man2/spu_create.2:270
msgid "See B<spu_run>(2)  for an example of the use of B<spu_create>()"
msgstr ""

#. type: Plain text
#: man-pages/man2/spu_create.2:274
msgid "B<close>(2), B<spu_run>(2), B<capabilities>(7), B<spufs>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/membarrier.2:25
#, no-wrap
msgid "MEMBARRIER"
msgstr ""

#. type: Plain text
#: man-pages/man2/membarrier.2:28
msgid "membarrier - issue memory barriers on a set of threads"
msgstr ""

#. type: Plain text
#: man-pages/man2/membarrier.2:30
msgid "B<#include E<lt>linux/membarrier.hE<gt>>"
msgstr ""

#. type: Plain text
#: man-pages/man2/membarrier.2:32
msgid "B<int membarrier(int >I<cmd>B<, int >I<flags>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/membarrier.2:42
msgid ""
"The B<membarrier>()  system call helps reducing the overhead of the memory "
"barrier instructions required to order memory accesses on multi-core "
"systems.  However, this system call is heavier than a memory barrier, so "
"using it effectively is I<not> as simple as replacing memory barriers with "
"this system call, but requires understanding of the details below."
msgstr ""

#. type: Plain text
#: man-pages/man2/membarrier.2:47
msgid ""
"Use of memory barriers needs to be done taking into account that a memory "
"barrier always needs to be either matched with its memory barrier "
"counterparts, or that the architecture's memory model doesn't require the "
"matching barriers."
msgstr ""

#. type: Plain text
#: man-pages/man2/membarrier.2:56
msgid ""
"There are cases where one side of the matching barriers (which we will refer "
"to as \"fast side\") is executed much more often than the other (which we "
"will refer to as \"slow side\").  This is a prime target for the use of "
"B<membarrier>().  The key idea is to replace, for these matching barriers, "
"the fast-side memory barriers by simple compiler barriers, for example:"
msgstr ""

#. type: Plain text
#: man-pages/man2/membarrier.2:60
#, no-wrap
msgid "asm volatile (\"\" : : : \"memory\")\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/membarrier.2:65
msgid "and replace the slow-side memory barriers by calls to B<membarrier>()."
msgstr ""

#. type: Plain text
#: man-pages/man2/membarrier.2:71
msgid ""
"This will add overhead to the slow side, and remove overhead from the fast "
"side, thus resulting in an overall performance increase as long as the slow "
"side is infrequent enough that the overhead of the B<membarrier>()  calls "
"does not outweigh the performance gain on the fast side."
msgstr ""

#. type: Plain text
#: man-pages/man2/membarrier.2:75
msgid "The I<cmd> argument is one of the following:"
msgstr ""

#. type: TP
#: man-pages/man2/membarrier.2:75
#, no-wrap
msgid "B<MEMBARRIER_CMD_QUERY> (since Linux 4.3)"
msgstr ""

#. type: Plain text
#: man-pages/man2/membarrier.2:86
msgid ""
"Query the set of supported commands.  The return value of the call is a bit "
"mask of supported commands.  B<MEMBARRIER_CMD_QUERY>, which has the value 0, "
"is not itself included in this bit mask.  This command is always supported "
"(on kernels where B<membarrier>()  is provided)."
msgstr ""

#. type: TP
#: man-pages/man2/membarrier.2:86
#, no-wrap
msgid "B<MEMBARRIER_CMD_GLOBAL> (since Linux 4.16)"
msgstr ""

#. type: Plain text
#: man-pages/man2/membarrier.2:94
msgid ""
"Ensure that all threads from all processes on the system pass through a "
"state where all memory accesses to user-space addresses match program order "
"between entry to and return from the B<membarrier>()  system call.  All "
"threads on the system are targeted by this command."
msgstr ""

#. type: TP
#: man-pages/man2/membarrier.2:94
#, no-wrap
msgid "B<MEMBARRIER_CMD_GLOBAL_EXPEDITED> (since Linux 4.16)"
msgstr ""

#. type: Plain text
#: man-pages/man2/membarrier.2:99
msgid ""
"Execute a memory barrier on all running threads of all processes that "
"previously registered with B<MEMBARRIER_CMD_REGISTER_GLOBAL_EXPEDITED>."
msgstr ""

#. type: Plain text
#: man-pages/man2/membarrier.2:107
msgid ""
"Upon return from the system call, the calling thread has a guarantee that "
"all running threads have passed through a state where all memory accesses to "
"user-space addresses match program order between entry to and return from "
"the system call (non-running threads are de facto in such a state).  This "
"guarantee is provided only for the threads of processes that previously "
"registered with B<MEMBARRIER_CMD_REGISTER_GLOBAL_EXPEDITED>."
msgstr ""

#. type: Plain text
#: man-pages/man2/membarrier.2:113
msgid ""
"Given that registration is about the intent to receive the barriers, it is "
"valid to invoke B<MEMBARRIER_CMD_GLOBAL_EXPEDITED> from a process that has "
"not employed B<MEMBARRIER_CMD_REGISTER_GLOBAL_EXPEDITED>."
msgstr ""

#. type: Plain text
#: man-pages/man2/membarrier.2:116 man-pages/man2/membarrier.2:136
msgid ""
"The \"expedited\" commands complete faster than the non-expedited ones; they "
"never block, but have the downside of causing extra overhead."
msgstr ""

#. type: TP
#: man-pages/man2/membarrier.2:116
#, no-wrap
msgid "B<MEMBARRIER_CMD_REGISTER_GLOBAL_EXPEDITED> (since Linux 4.16)"
msgstr ""

#. type: Plain text
#: man-pages/man2/membarrier.2:121
msgid ""
"Register the process's intent to receive B<MEMBARRIER_CMD_GLOBAL_EXPEDITED> "
"memory barriers."
msgstr ""

#. type: TP
#: man-pages/man2/membarrier.2:121
#, no-wrap
msgid "B<MEMBARRIER_CMD_PRIVATE_EXPEDITED> (since Linux 4.14)"
msgstr ""

#. type: Plain text
#: man-pages/man2/membarrier.2:125
msgid ""
"Execute a memory barrier on each running thread belonging to the same "
"process as the calling thread."
msgstr ""

#. type: Plain text
#: man-pages/man2/membarrier.2:133
msgid ""
"Upon return from the system call, the calling thread has a guarantee that "
"all its running thread siblings have passed through a state where all memory "
"accesses to user-space addresses match program order between entry to and "
"return from the system call (non-running threads are de facto in such a "
"state).  This guarantee is provided only for threads in the same process as "
"the calling thread."
msgstr ""

#. type: Plain text
#: man-pages/man2/membarrier.2:139
msgid ""
"A process must register its intent to use the private expedited command "
"prior to using it."
msgstr ""

#. type: TP
#: man-pages/man2/membarrier.2:139
#, no-wrap
msgid "B<MEMBARRIER_CMD_REGISTER_PRIVATE_EXPEDITED> (since Linux 4.14)"
msgstr ""

#. type: Plain text
#: man-pages/man2/membarrier.2:143
msgid "Register the process's intent to use B<MEMBARRIER_CMD_PRIVATE_EXPEDITED>."
msgstr ""

#. type: TP
#: man-pages/man2/membarrier.2:143
#, no-wrap
msgid "B<MEMBARRIER_CMD_PRIVATE_EXPEDITED_SYNC_CORE> (since Linux 4.16)"
msgstr ""

#. type: Plain text
#: man-pages/man2/membarrier.2:151
msgid ""
"In addition to providing the memory ordering guarantees described in "
"B<MEMBARRIER_CMD_PRIVATE_EXPEDITED>, upon return from system call the "
"calling thread has a guarantee that all its running thread siblings have "
"executed a core serializing instruction.  This guarantee is provided only "
"for threads in the same process as the calling thread."
msgstr ""

#. type: Plain text
#: man-pages/man2/membarrier.2:154
msgid ""
"The \"expedited\" commands complete faster than the non-expedited ones, they "
"never block, but have the downside of causing extra overhead."
msgstr ""

#. type: Plain text
#: man-pages/man2/membarrier.2:157
msgid ""
"A process must register its intent to use the private expedited sync core "
"command prior to using it."
msgstr ""

#. type: TP
#: man-pages/man2/membarrier.2:157
#, no-wrap
msgid "B<MEMBARRIER_CMD_REGISTER_PRIVATE_EXPEDITED_SYNC_CORE> (since Linux 4.16)"
msgstr ""

#. type: Plain text
#: man-pages/man2/membarrier.2:161
msgid ""
"Register the process's intent to use "
"B<MEMBARRIER_CMD_PRIVATE_EXPEDITED_SYNC_CORE>."
msgstr ""

#. type: TP
#: man-pages/man2/membarrier.2:161
#, no-wrap
msgid "B<MEMBARRIER_CMD_SHARED> (since Linux 4.3)"
msgstr ""

#. type: Plain text
#: man-pages/man2/membarrier.2:166
msgid ""
"This is an alias for B<MEMBARRIER_CMD_GLOBAL> that exists for header "
"backward compatibility."
msgstr ""

#. type: Plain text
#: man-pages/man2/membarrier.2:170
msgid "The I<flags> argument is currently unused and must be specified as 0."
msgstr ""

#. type: Plain text
#: man-pages/man2/membarrier.2:174
msgid ""
"All memory accesses performed in program order from each targeted thread are "
"guaranteed to be ordered with respect to B<membarrier>()."
msgstr ""

#. type: Plain text
#: man-pages/man2/membarrier.2:188
msgid ""
"If we use the semantic I<barrier()> to represent a compiler barrier forcing "
"memory accesses to be performed in program order across the barrier, and "
"I<smp_mb()> to represent explicit memory barriers forcing full memory "
"ordering across the barrier, we have the following ordering table for each "
"pairing of I<barrier()>, B<membarrier>()  and I<smp_mb()>.  The pair "
"ordering is detailed as (O: ordered, X: not ordered):"
msgstr ""

#. type: Plain text
#: man-pages/man2/membarrier.2:193
#, no-wrap
msgid ""
"                       barrier()  smp_mb()  membarrier()\n"
"       barrier()          X          X          O\n"
"       smp_mb()           X          O          O\n"
"       membarrier()       O          O          O\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/membarrier.2:210
msgid ""
"On success, the B<MEMBARRIER_CMD_QUERY> operation returns a bit mask of "
"supported commands, and the B<MEMBARRIER_CMD_GLOBAL>, "
"B<MEMBARRIER_CMD_GLOBAL_EXPEDITED>, "
"B<MEMBARRIER_CMD_REGISTER_GLOBAL_EXPEDITED>, "
"B<MEMBARRIER_CMD_PRIVATE_EXPEDITED>, "
"B<MEMBARRIER_CMD_REGISTER_PRIVATE_EXPEDITED>, "
"B<MEMBARRIER_CMD_PRIVATE_EXPEDITED_SYNC_CORE>, and "
"B<MEMBARRIER_CMD_REGISTER_PRIVATE_EXPEDITED_SYNC_CORE> operations return "
"zero.  On error, -1 is returned, and I<errno> is set appropriately."
msgstr ""

#. type: Plain text
#: man-pages/man2/membarrier.2:220
msgid ""
"For a given command, with I<flags> set to 0, this system call is guaranteed "
"to always return the same value until reboot.  Further calls with the same "
"arguments will lead to the same result.  Therefore, with I<flags> set to 0, "
"error handling is required only for the first call to B<membarrier>()."
msgstr ""

#. type: Plain text
#: man-pages/man2/membarrier.2:235
msgid ""
"I<cmd> is invalid, or I<flags> is nonzero, or the B<MEMBARRIER_CMD_GLOBAL> "
"command is disabled because the I<nohz_full> CPU parameter has been set, or "
"the B<MEMBARRIER_CMD_PRIVATE_EXPEDITED_SYNC_CORE> and "
"B<MEMBARRIER_CMD_REGISTER_PRIVATE_EXPEDITED_SYNC_CORE> commands are not "
"implemented by the architecture."
msgstr ""

#. type: Plain text
#: man-pages/man2/membarrier.2:240
msgid "The B<membarrier>()  system call is not implemented by this kernel."
msgstr ""

#. type: Plain text
#: man-pages/man2/membarrier.2:244
msgid ""
"The current process was not registered prior to using private expedited "
"commands."
msgstr ""

#. type: Plain text
#: man-pages/man2/membarrier.2:249
msgid "The B<membarrier>()  system call was added in Linux 4.3."
msgstr ""

#.  .SH SEE ALSO
#.  FIXME See if the following syscalls make it into Linux 4.15 or later
#.  .BR cpu_opv (2),
#.  .BR rseq (2)
#. type: Plain text
#: man-pages/man2/membarrier.2:256
msgid "B<membarrier>()  is Linux-specific."
msgstr ""

#. type: Plain text
#: man-pages/man2/membarrier.2:265
msgid ""
"A memory barrier instruction is part of the instruction set of architectures "
"with weakly-ordered memory models.  It orders memory accesses prior to the "
"barrier and after the barrier with respect to matching barriers on other "
"cores.  For instance, a load fence can order loads prior to and following "
"that fence with respect to stores ordered by store fences."
msgstr ""

#. type: Plain text
#: man-pages/man2/membarrier.2:268
msgid ""
"Program order is the order in which instructions are ordered in the program "
"assembly code."
msgstr ""

#. type: Plain text
#: man-pages/man2/membarrier.2:273
msgid ""
"Examples where B<membarrier>()  can be useful include implementations of "
"Read-Copy-Update libraries and garbage collectors."
msgstr ""

#. type: Plain text
#: man-pages/man2/membarrier.2:278
msgid ""
"Assuming a multithreaded application where \"fast_path()\" is executed very "
"frequently, and where \"slow_path()\" is executed infrequently, the "
"following code (x86) can be transformed using B<membarrier>():"
msgstr ""

#. type: Plain text
#: man-pages/man2/membarrier.2:282
#, no-wrap
msgid "#include E<lt>stdlib.hE<gt>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/membarrier.2:284 man-pages/man2/membarrier.2:342
#, no-wrap
msgid "static volatile int a, b;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/membarrier.2:292
#, no-wrap
msgid ""
"static void\n"
"fast_path(int *read_b)\n"
"{\n"
"    a = 1;\n"
"    asm volatile (\"mfence\" : : : \"memory\");\n"
"    *read_b = b;\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/membarrier.2:300
#, no-wrap
msgid ""
"static void\n"
"slow_path(int *read_a)\n"
"{\n"
"    b = 1;\n"
"    asm volatile (\"mfence\" : : : \"memory\");\n"
"    *read_a = a;\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/membarrier.2:305 man-pages/man2/membarrier.2:391
#, no-wrap
msgid ""
"int\n"
"main(int argc, char **argv)\n"
"{\n"
"    int read_a, read_b;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/membarrier.2:311 man-pages/man2/membarrier.2:400
#, no-wrap
msgid ""
"    /*\n"
"     * Real applications would call fast_path() and slow_path()\n"
"     * from different threads. Call those from main() to keep\n"
"     * this example short.\n"
"     */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/membarrier.2:314 man-pages/man2/membarrier.2:403
#, no-wrap
msgid ""
"    slow_path(&read_a);\n"
"    fast_path(&read_b);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/membarrier.2:319 man-pages/man2/membarrier.2:408
#, no-wrap
msgid ""
"    /*\n"
"     * read_b == 0 implies read_a == 1 and\n"
"     * read_a == 0 implies read_b == 1.\n"
"     */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/membarrier.2:322 man-pages/man2/membarrier.2:411
#, no-wrap
msgid ""
"    if (read_b == 0 && read_a == 0)\n"
"        abort();\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/membarrier.2:331
msgid "The code above transformed to use B<membarrier>()  becomes:"
msgstr ""

#. type: Plain text
#: man-pages/man2/membarrier.2:340
#, no-wrap
msgid ""
"#define _GNU_SOURCE\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>sys/syscall.hE<gt>\n"
"#include E<lt>linux/membarrier.hE<gt>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/membarrier.2:348
#, no-wrap
msgid ""
"static int\n"
"membarrier(int cmd, int flags)\n"
"{\n"
"    return syscall(__NR_membarrier, cmd, flags);\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/membarrier.2:353
#, no-wrap
msgid ""
"static int\n"
"init_membarrier(void)\n"
"{\n"
"    int ret;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/membarrier.2:355
#, no-wrap
msgid "    /* Check that membarrier() is supported. */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/membarrier.2:361
#, no-wrap
msgid ""
"    ret = membarrier(MEMBARRIER_CMD_QUERY, 0);\n"
"    if (ret E<lt> 0) {\n"
"        perror(\"membarrier\");\n"
"        return -1;\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/membarrier.2:367
#, no-wrap
msgid ""
"    if (!(ret & MEMBARRIER_CMD_GLOBAL)) {\n"
"        fprintf(stderr,\n"
"            \"membarrier does not support MEMBARRIER_CMD_GLOBAL\\en\");\n"
"        return -1;\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/membarrier.2:378
#, no-wrap
msgid ""
"static void\n"
"fast_path(int *read_b)\n"
"{\n"
"    a = 1;\n"
"    asm volatile (\"\" : : : \"memory\");\n"
"    *read_b = b;\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/membarrier.2:386
#, no-wrap
msgid ""
"static void\n"
"slow_path(int *read_a)\n"
"{\n"
"    b = 1;\n"
"    membarrier(MEMBARRIER_CMD_GLOBAL, 0);\n"
"    *read_a = a;\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/membarrier.2:394
#, no-wrap
msgid ""
"    if (init_membarrier())\n"
"        exit(EXIT_FAILURE);\n"
msgstr ""

#. type: TH
#: man-pages/man2/s390_guarded_storage.2:25
#, no-wrap
msgid "S390_GUARDED_STORAGE"
msgstr ""

#. type: Plain text
#: man-pages/man2/s390_guarded_storage.2:28
msgid ""
"s390_guarded_storage - operations with z/Architecture guarded storage "
"facility"
msgstr ""

#. type: Plain text
#: man-pages/man2/s390_guarded_storage.2:31
#, no-wrap
msgid "B<#include E<lt>asm/guarded_storage.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/s390_guarded_storage.2:33
#, no-wrap
msgid "B<int s390_guarded_storage(int >I<command>B<, struct gs_cb *>I<gs_cb>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/s390_guarded_storage.2:39
msgid ""
"The B<s390_guarded_storage>()  system call enables the use of the Guarded "
"Storage Facility (a z/Architecture-specific feature) for user-space "
"processes."
msgstr ""

#.  The description is based on
#.  http://www-05.ibm.com/de/linux-on-z-ws-us/agenda/pdfs/8_-_Linux_Whats_New_-_Stefan_Raspl.pdf
#.  and "z/Architecture Principles of Operation" obtained from
#.  http://publibfi.boulder.ibm.com/epubs/pdf/dz9zr011.pdf
#. type: Plain text
#: man-pages/man2/s390_guarded_storage.2:50
msgid ""
"The guarded storage facility is a hardware feature that allows marking up to "
"64 memory regions (as of z14) as guarded; reading a pointer with a newly "
"introduced \"Load Guarded\" (LGG)  or \"Load Logical and Shift Guarded\" "
"(LLGFSG) instructions will cause a range check on the loaded value and "
"invoke a (previously set up)  user-space handler if one of the guarded "
"regions is affected."
msgstr ""

#.  The command description is copied from v4.12-rc1~139^2~56^2 commit message
#. type: Plain text
#: man-pages/man2/s390_guarded_storage.2:56
msgid ""
"The I<command> argument indicates which function to perform.  The following "
"commands are supported:"
msgstr ""

#. type: TP
#: man-pages/man2/s390_guarded_storage.2:56
#, no-wrap
msgid "B<GS_ENABLE>"
msgstr ""

#. type: Plain text
#: man-pages/man2/s390_guarded_storage.2:68
msgid ""
"Enable the guarded storage facility for the calling task.  The initial "
"content of the guarded storage control block will be all zeros.  After "
"enablement, user-space code can use the \"Load Guarded Storage Controls\" "
"(LGSC) instruction (or the B<load_gs_cb>()  function wrapper provided in the "
"I<asm/guarded_storage.h> header) to load an arbitrary control block.  While "
"a task is enabled, the kernel will save and restore the calling content of "
"the guarded storage registers on context switch."
msgstr ""

#. type: TP
#: man-pages/man2/s390_guarded_storage.2:68
#, no-wrap
msgid "B<GS_DISABLE>"
msgstr ""

#. type: Plain text
#: man-pages/man2/s390_guarded_storage.2:73
msgid ""
"Disables the use of the guarded storage facility for the calling task.  The "
"kernel will cease to save and restore the content of the guarded storage "
"registers, the task-specific content of these registers is lost."
msgstr ""

#. type: TP
#: man-pages/man2/s390_guarded_storage.2:73
#, no-wrap
msgid "B<GS_SET_BC_CB>"
msgstr ""

#. type: Plain text
#: man-pages/man2/s390_guarded_storage.2:82
msgid ""
"Set a broadcast guarded storage control block to the one provided in the "
"I<gs_cb> argument.  This is called per thread and associates a specific "
"guarded storage control block with the calling task.  This control block "
"will be used in the broadcast command B<GS_BROADCAST>."
msgstr ""

#. type: TP
#: man-pages/man2/s390_guarded_storage.2:82
#, no-wrap
msgid "B<GS_CLEAR_BC_CB>"
msgstr ""

#. type: Plain text
#: man-pages/man2/s390_guarded_storage.2:89
msgid ""
"Clears the broadcast guarded storage control block.  The guarded storage "
"control block will no longer have the association established by the "
"B<GS_SET_BC_CB> command."
msgstr ""

#. type: TP
#: man-pages/man2/s390_guarded_storage.2:89
#, no-wrap
msgid "B<GS_BROADCAST>"
msgstr ""

#. type: Plain text
#: man-pages/man2/s390_guarded_storage.2:98
msgid ""
"Sends a broadcast to all thread siblings of the calling task.  Every sibling "
"that has established a broadcast guarded storage control block will load "
"this control block and will be enabled for guarded storage.  The broadcast "
"guarded storage control block is consumed; a second broadcast without a "
"refresh of the stored control block with B<GS_SET_BC_CB> will not have any "
"effect."
msgstr ""

#. type: Plain text
#: man-pages/man2/s390_guarded_storage.2:105
msgid ""
"The I<gs_cb> argument specifies the address of a guarded storage control "
"block structure and is currently used only by the B<GS_SET_BC_CB> command; "
"all other aforementioned commands ignore this argument."
msgstr ""

#. type: Plain text
#: man-pages/man2/s390_guarded_storage.2:109
msgid "On success, the return value of B<s390_guarded_storage>()  is 0."
msgstr ""

#. type: Plain text
#: man-pages/man2/s390_guarded_storage.2:113 man-pages/man2/readv.2:288
#: man-pages/man2/kcmp.2:246 man-pages/man2/sendfile.2:121
#: man-pages/man2/shmctl.2:319 man-pages/man2/bpf.2:1029
#: man-pages/man2/fcntl.2:1648 man-pages/man2/getrandom.2:140
#: man-pages/man2/s390_sthyi.2:100
msgid "On error, -1 is returned, and I<errno> is set appropriately."
msgstr ""

#. type: Plain text
#: man-pages/man2/s390_guarded_storage.2:122
msgid ""
"I<command> was B<GS_SET_BC_CB> and the copying of the guarded storage "
"control block structure pointed by the I<gs_cb> argument has failed."
msgstr ""

#. type: Plain text
#: man-pages/man2/s390_guarded_storage.2:127
msgid "The value provided in the I<command> argument was not valid."
msgstr ""

#. type: Plain text
#: man-pages/man2/s390_guarded_storage.2:133
msgid ""
"I<command> was one of B<GS_ENABLE> or B<GS_SET_BC_CB>, and the allocation of "
"a new guarded storage control block has failed."
msgstr ""

#. type: Plain text
#: man-pages/man2/s390_guarded_storage.2:136
msgid "The guarded storage facility is not supported by the hardware."
msgstr ""

#.  916cda1aa1b412d7cf2991c3af7479544942d121, v4.12-rc1~139^2~56^2
#. type: Plain text
#: man-pages/man2/s390_guarded_storage.2:139
msgid "This system call is available since Linux 4.12."
msgstr ""

#. type: Plain text
#: man-pages/man2/s390_guarded_storage.2:141 man-pages/man2/s390_sthyi.2:125
msgid "This Linux-specific system call is available only on the s390 architecture."
msgstr ""

#. type: Plain text
#: man-pages/man2/s390_guarded_storage.2:143
msgid "The guarded storage facility is available beginning with System z14."
msgstr ""

#. type: Plain text
#: man-pages/man2/s390_guarded_storage.2:147
#: man-pages/man2/s390_pci_mmio_write.2:106
#: man-pages/man2/s390_runtime_instr.2:88 man-pages/man2/s390_sthyi.2:129
msgid ""
"Glibc does not provide a wrapper for this system call, use B<syscall>(2)  to "
"call it."
msgstr ""

#. type: Plain text
#: man-pages/man2/s390_guarded_storage.2:153
msgid ""
"The description of the guarded storage facility along with related "
"instructions and Guarded Storage Control Block and Guarded Storage Event "
"Parameter List structure layouts is available in \"z/Architecture Principles "
"of Operations\" beginning from the twelfth edition."
msgstr ""

#.  .PP
#.  For the example of using the guarded storage facility, see
#.  .UR https://developer.ibm.com/javasdk/2017/09/25/concurrent-scavenge-using-guarded-storage-facility-works/
#.  the article with the description of its usage in the Java Garbage Collection
#.  .UE
#. type: Plain text
#: man-pages/man2/s390_guarded_storage.2:173
msgid ""
"The I<gs_cb> structure has a field I<gsepla> (Guarded Storage Event "
"Parameter List Address), which is a user-space pointer to a Guarded Storage "
"Event Parameter List structure (that contains the address of the "
"aforementioned event handler in the I<gseha> field), and its layout is "
"available as a B<gs_epl> structure type definition in the "
"I<asm/guarded_storage.h> header."
msgstr ""

#. type: Plain text
#: man-pages/man2/s390_guarded_storage.2:175 man-pages/man2/syscalls.2:770
#: man-pages/man2/s390_pci_mmio_write.2:107 man-pages/man2/s390_sthyi.2:142
#, no-wrap
msgid "B<syscall>(2)"
msgstr ""

#. type: TH
#: man-pages/man2/delete_module.2:25
#, no-wrap
msgid "DELETE_MODULE"
msgstr ""

#. type: Plain text
#: man-pages/man2/delete_module.2:28
msgid "delete_module - unload a kernel module"
msgstr ""

#. type: Plain text
#: man-pages/man2/delete_module.2:31
#, no-wrap
msgid "B<int delete_module(const char *>I<name>B<, int >I<flags>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/delete_module.2:35 man-pages/man2/uselib.2:41
#: man-pages/man2/query_module.2:23 man-pages/man2/get_kernel_syms.2:22
#: man-pages/man2/create_module.2:22
msgid ""
"I<Note>: No declaration of this system call is provided in glibc headers; "
"see NOTES."
msgstr ""

#. type: Plain text
#: man-pages/man2/delete_module.2:49
msgid ""
"The B<delete_module>()  system call attempts to remove the unused loadable "
"module entry identified by I<name>.  If the module has an I<exit> function, "
"then that function is executed before unloading the module.  The I<flags> "
"argument is used to modify the behavior of the system call, as described "
"below.  This system call requires privilege."
msgstr ""

#. type: Plain text
#: man-pages/man2/delete_module.2:51
msgid "Module removal is attempted according to the following rules:"
msgstr ""

#. type: Plain text
#: man-pages/man2/delete_module.2:55
msgid ""
"If there are other loaded modules that depend on (i.e., refer to symbols "
"defined in) this module, then the call fails."
msgstr ""

#. type: Plain text
#: man-pages/man2/delete_module.2:59
msgid ""
"Otherwise, if the reference count for the module (i.e., the number of "
"processes currently using the module)  is zero, then the module is "
"immediately unloaded."
msgstr ""

#.   	O_TRUNC == KMOD_REMOVE_FORCE in kmod library
#.   	O_NONBLOCK == KMOD_REMOVE_NOWAIT in kmod library
#. type: Plain text
#: man-pages/man2/delete_module.2:70
msgid ""
"If a module has a nonzero reference count, then the behavior depends on the "
"bits set in I<flags>.  In normal usage (see NOTES), the B<O_NONBLOCK> flag "
"is always specified, and the B<O_TRUNC> flag may additionally be specified."
msgstr ""

#. type: Plain text
#: man-pages/man2/delete_module.2:74
msgid "The various combinations for I<flags> have the following effect:"
msgstr ""

#. type: TP
#: man-pages/man2/delete_module.2:75
#, no-wrap
msgid "B<flags == O_NONBLOCK>"
msgstr ""

#. type: Plain text
#: man-pages/man2/delete_module.2:78
msgid "The call returns immediately, with an error."
msgstr ""

#. type: TP
#: man-pages/man2/delete_module.2:78
#, no-wrap
msgid "B<flags == (O_NONBLOCK | O_TRUNC)>"
msgstr ""

#. type: Plain text
#: man-pages/man2/delete_module.2:82
msgid ""
"The module is unloaded immediately, regardless of whether it has a nonzero "
"reference count."
msgstr ""

#. type: TP
#: man-pages/man2/delete_module.2:82
#, no-wrap
msgid "B<(flags & O_NONBLOCK) == 0>"
msgstr ""

#. type: Plain text
#: man-pages/man2/delete_module.2:89
msgid "If I<flags> does not specify B<O_NONBLOCK>, the following steps occur:"
msgstr ""

#. type: Plain text
#: man-pages/man2/delete_module.2:92
msgid "The module is marked so that no new references are permitted."
msgstr ""

#. type: Plain text
#: man-pages/man2/delete_module.2:97
msgid ""
"If the module's reference count is nonzero, the caller is placed in an "
"uninterruptible sleep state (B<TASK_UNINTERRUPTIBLE>)  until the reference "
"count is zero, at which point the call unblocks."
msgstr ""

#. type: Plain text
#: man-pages/man2/delete_module.2:99
msgid "The module is unloaded in the usual way."
msgstr ""

#. type: Plain text
#: man-pages/man2/delete_module.2:113
msgid ""
"The B<O_TRUNC> flag has one further effect on the rules described above.  By "
"default, if a module has an I<init> function but no I<exit> function, then "
"an attempt to remove the module fails.  However, if B<O_TRUNC> was "
"specified, this requirement is bypassed."
msgstr ""

#. type: Plain text
#: man-pages/man2/delete_module.2:124
msgid ""
"Using the B<O_TRUNC> flag is dangerous! If the kernel was not built with "
"B<CONFIG_MODULE_FORCE_UNLOAD>, this flag is silently ignored.  (Normally, "
"B<CONFIG_MODULE_FORCE_UNLOAD> is enabled.)  Using this flag taints the "
"kernel (TAINT_FORCED_RMMOD)."
msgstr ""

#. type: Plain text
#: man-pages/man2/delete_module.2:129 man-pages/man2/query_module.2:134
#: man-pages/man2/pciconfig_read.2:57 man-pages/man2/pciconfig_read.2:63
msgid ""
"On success, zero is returned.  On error, -1 is returned and I<errno> is set "
"appropriately."
msgstr ""

#. type: Plain text
#: man-pages/man2/delete_module.2:143
msgid ""
"The module is not \"live\" (i.e., it is still being initialized or is "
"already marked for removal); or, the module has an I<init> function but has "
"no I<exit> function, and B<O_TRUNC> was not specified in I<flags>."
msgstr ""

#. type: Plain text
#: man-pages/man2/delete_module.2:147
msgid "I<name> refers to a location outside the process's accessible address space."
msgstr ""

#. type: Plain text
#: man-pages/man2/delete_module.2:150
msgid "No module by that name exists."
msgstr ""

#. type: Plain text
#: man-pages/man2/delete_module.2:161
msgid ""
"The caller was not privileged (did not have the B<CAP_SYS_MODULE> "
"capability), or module unloading is disabled (see "
"I</proc/sys/kernel/modules_disabled> in B<proc>(5))."
msgstr ""

#. type: Plain text
#: man-pages/man2/delete_module.2:172
msgid ""
"Other modules depend on this module; or, B<O_NONBLOCK> was specified in "
"I<flags>, but the reference count of this module is nonzero and B<O_TRUNC> "
"was not specified in I<flags>."
msgstr ""

#. type: Plain text
#: man-pages/man2/delete_module.2:175
msgid "B<delete_module>()  is Linux-specific."
msgstr ""

#. type: Plain text
#: man-pages/man2/delete_module.2:186
msgid ""
"The B<delete_module>()  system call is not supported by glibc.  No "
"declaration is provided in glibc headers, but, through a quirk of history, "
"glibc versions before 2.23 did export an ABI for this system call.  "
"Therefore, in order to employ this system call, it is (before glibc 2.23) "
"sufficient to manually declare the interface in your code; alternatively, "
"you can invoke the system call using B<syscall>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/delete_module.2:196
msgid ""
"The uninterruptible sleep that may occur if B<O_NONBLOCK> is omitted from "
"I<flags> is considered undesirable, because the sleeping process is left in "
"an unkillable state.  As at Linux 3.7, specifying B<O_NONBLOCK> is optional, "
"but in future kernels it is likely to become mandatory."
msgstr ""

#. type: SS
#: man-pages/man2/delete_module.2:196 man-pages/man2/clone.2:1010
#: man-pages/man2/init_module.2:289
#, no-wrap
msgid "Linux 2.4 and earlier"
msgstr ""

#. type: Plain text
#: man-pages/man2/delete_module.2:198
msgid "In Linux 2.4 and earlier, the system call took only one argument:"
msgstr ""

#. type: Plain text
#: man-pages/man2/delete_module.2:200
msgid "B< int delete_module(const char *>I<name>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/delete_module.2:204
msgid "If I<name> is NULL, all unused modules marked auto-clean are removed."
msgstr ""

#. type: Plain text
#: man-pages/man2/delete_module.2:210
msgid ""
"Some further details of differences in the behavior of B<delete_module>()  "
"in Linux 2.4 and earlier are I<not> currently explained in this manual page."
msgstr ""

#. type: Plain text
#: man-pages/man2/delete_module.2:216
msgid ""
"B<create_module>(2), B<init_module>(2), B<query_module>(2), B<lsmod>(8), "
"B<modprobe>(8), B<rmmod>(8)"
msgstr ""

#. type: TH
#: man-pages/man2/prctl.2:54
#, no-wrap
msgid "PRCTL"
msgstr ""

#. type: Plain text
#: man-pages/man2/prctl.2:57
msgid "prctl - operations on a process"
msgstr ""

#. type: Plain text
#: man-pages/man2/prctl.2:60
#, no-wrap
msgid "B<#include E<lt>sys/prctl.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/prctl.2:63
#, no-wrap
msgid ""
"B<int prctl(int >I<option>B<, unsigned long >I<arg2>B<, unsigned long "
">I<arg3>B<,>\n"
"B<          unsigned long >I<arg4>B<, unsigned long >I<arg5>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/prctl.2:71
msgid ""
"B<prctl>()  is called with a first argument describing what to do (with "
"values defined in I<E<lt>linux/prctl.hE<gt>>), and further arguments with a "
"significance depending on the first one.  The first argument can be:"
msgstr ""

#. type: TP
#: man-pages/man2/prctl.2:71
#, no-wrap
msgid "B<PR_CAP_AMBIENT> (since Linux 4.3)"
msgstr ""

#.  commit 58319057b7847667f0c9585b9de0e8932b0fdb08
#. type: Plain text
#: man-pages/man2/prctl.2:78
msgid ""
"Reads or changes the ambient capability set of the calling thread, according "
"to the value of I<arg2>, which must be one of the following:"
msgstr ""

#. type: TP
#: man-pages/man2/prctl.2:80
#, no-wrap
msgid "B<PR_CAP_AMBIENT_RAISE>"
msgstr ""

#. type: Plain text
#: man-pages/man2/prctl.2:90
msgid ""
"The capability specified in I<arg3> is added to the ambient set.  The "
"specified capability must already be present in both the permitted and the "
"inheritable sets of the process.  This operation is not permitted if the "
"B<SECBIT_NO_CAP_AMBIENT_RAISE> securebit is set."
msgstr ""

#. type: TP
#: man-pages/man2/prctl.2:90
#, no-wrap
msgid "B<PR_CAP_AMBIENT_LOWER>"
msgstr ""

#. type: Plain text
#: man-pages/man2/prctl.2:95
msgid "The capability specified in I<arg3> is removed from the ambient set."
msgstr ""

#. type: TP
#: man-pages/man2/prctl.2:95
#, no-wrap
msgid "B<PR_CAP_AMBIENT_IS_SET>"
msgstr ""

#. type: Plain text
#: man-pages/man2/prctl.2:102
msgid ""
"The B<prctl>()  call returns 1 if the capability in I<arg3> is in the "
"ambient set and 0 if it is not."
msgstr ""

#. type: TP
#: man-pages/man2/prctl.2:102
#, no-wrap
msgid "B<PR_CAP_AMBIENT_CLEAR_ALL>"
msgstr ""

#. type: Plain text
#: man-pages/man2/prctl.2:108
msgid ""
"All capabilities will be removed from the ambient set.  This operation "
"requires setting I<arg3> to zero."
msgstr ""

#. type: Plain text
#: man-pages/man2/prctl.2:115
msgid "In all of the above operations, I<arg4> and I<arg5> must be specified as 0."
msgstr ""

#. type: Plain text
#: man-pages/man2/prctl.2:124
msgid ""
"Higher-level interfaces layered on top of the above operations are provided "
"in the B<libcap>(3)  library in the form of B<cap_get_ambient>(3), "
"B<cap_set_ambient>(3), and B<cap_reset_ambient>(3)."
msgstr ""

#. type: TP
#: man-pages/man2/prctl.2:124
#, no-wrap
msgid "B<PR_CAPBSET_READ> (since Linux 2.6.25)"
msgstr ""

#. type: Plain text
#: man-pages/man2/prctl.2:136
msgid ""
"Return (as the function result) 1 if the capability specified in I<arg2> is "
"in the calling thread's capability bounding set, or 0 if it is not.  (The "
"capability constants are defined in I<E<lt>linux/capability.hE<gt>>.)  The "
"capability bounding set dictates whether the process can receive the "
"capability through a file's permitted capability set on a subsequent call to "
"B<execve>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/prctl.2:141
msgid ""
"If the capability specified in I<arg2> is not valid, then the call fails "
"with the error B<EINVAL>."
msgstr ""

#. type: Plain text
#: man-pages/man2/prctl.2:146
msgid ""
"A higher-level interface layered on top of this operation is provided in the "
"B<libcap>(3)  library in the form of B<cap_get_bound>(3)."
msgstr ""

#. type: TP
#: man-pages/man2/prctl.2:146
#, no-wrap
msgid "B<PR_CAPBSET_DROP> (since Linux 2.6.25)"
msgstr ""

#. type: Plain text
#: man-pages/man2/prctl.2:155
msgid ""
"If the calling thread has the B<CAP_SETPCAP> capability within its user "
"namespace, then drop the capability specified by I<arg2> from the calling "
"thread's capability bounding set.  Any children of the calling thread will "
"inherit the newly reduced bounding set."
msgstr ""

#. type: Plain text
#: man-pages/man2/prctl.2:167
msgid ""
"The call fails with the error: B<EPERM> if the calling thread does not have "
"the B<CAP_SETPCAP>; B<EINVAL> if I<arg2> does not represent a valid "
"capability; or B<EINVAL> if file capabilities are not enabled in the kernel, "
"in which case bounding sets are not supported."
msgstr ""

#. type: Plain text
#: man-pages/man2/prctl.2:172
msgid ""
"A higher-level interface layered on top of this operation is provided in the "
"B<libcap>(3)  library in the form of B<cap_drop_bound>(3)."
msgstr ""

#. type: TP
#: man-pages/man2/prctl.2:172
#, no-wrap
msgid "B<PR_SET_CHILD_SUBREAPER> (since Linux 3.4)"
msgstr ""

#.  commit ebec18a6d3aa1e7d84aab16225e87fd25170ec2b
#. type: Plain text
#: man-pages/man2/prctl.2:182
msgid ""
"If I<arg2> is nonzero, set the \"child subreaper\" attribute of the calling "
"process; if I<arg2> is zero, unset the attribute."
msgstr ""

#. type: Plain text
#: man-pages/man2/prctl.2:199
msgid ""
"A subreaper fulfills the role of B<init>(1)  for its descendant processes.  "
"When a process becomes orphaned (i.e., its immediate parent terminates), "
"then that process will be reparented to the nearest still living ancestor "
"subreaper.  Subsequently, calls to B<getppid>()  in the orphaned process "
"will now return the PID of the subreaper process, and when the orphan "
"terminates, it is the subreaper process that will receive a B<SIGCHLD> "
"signal and will be able to B<wait>(2)  on the process to discover its "
"termination status."
msgstr ""

#. type: Plain text
#: man-pages/man2/prctl.2:207
msgid ""
"The setting of the \"child subreaper\" attribute is not inherited by "
"children created by B<fork>(2)  and B<clone>(2).  The setting is preserved "
"across B<execve>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/prctl.2:218
msgid ""
"Establishing a subreaper process is useful in session management frameworks "
"where a hierarchical group of processes is managed by a subreaper process "
"that needs to be informed when one of the processes\\(emfor example, a "
"double-forked daemon\\(emterminates (perhaps so that it can restart that "
"process).  Some B<init>(1)  frameworks (e.g., B<systemd>(1))  employ a "
"subreaper process for similar reasons."
msgstr ""

#. type: TP
#: man-pages/man2/prctl.2:218
#, no-wrap
msgid "B<PR_GET_CHILD_SUBREAPER> (since Linux 3.4)"
msgstr ""

#. type: Plain text
#: man-pages/man2/prctl.2:223
msgid ""
"Return the \"child subreaper\" setting of the caller, in the location "
"pointed to by I<(int\\ *) arg2>."
msgstr ""

#. type: TP
#: man-pages/man2/prctl.2:223
#, no-wrap
msgid "B<PR_SET_DUMPABLE> (since Linux 2.3.20)"
msgstr ""

#. type: Plain text
#: man-pages/man2/prctl.2:228
msgid ""
"Set the state of the \"dumpable\" flag, which determines whether core dumps "
"are produced for the calling process upon delivery of a signal whose default "
"behavior is to produce a core dump."
msgstr ""

#.  commit abf75a5033d4da7b8a7e92321d74021d1fcfb502
#.  See http://marc.theaimsgroup.com/?l=linux-kernel&m=115270289030630&w=2
#.  Subject:    Fix prctl privilege escalation (CVE-2006-2451)
#.  From:       Marcel Holtmann <marcel () holtmann ! org>
#.  Date:       2006-07-12 11:12:00
#. type: Plain text
#: man-pages/man2/prctl.2:250
msgid ""
"In kernels up to and including 2.6.12, I<arg2> must be either 0 "
"(B<SUID_DUMP_DISABLE>, process is not dumpable) or 1 (B<SUID_DUMP_USER>, "
"process is dumpable).  Between kernels 2.6.13 and 2.6.17, the value 2 was "
"also permitted, which caused any binary which normally would not be dumped "
"to be dumped readable by root only; for security reasons, this feature has "
"been removed.  (See also the description of I</proc/sys/fs/\\:suid_dumpable> "
"in B<proc>(5).)"
msgstr ""

#.  See kernel/cred.c::commit_creds() (Linux 3.18 sources)
#. type: Plain text
#: man-pages/man2/prctl.2:257
msgid ""
"Normally, this flag is set to 1.  However, it is reset to the current value "
"contained in the file I</proc/sys/fs/\\:suid_dumpable> (which by default has "
"the value 0), in the following circumstances:"
msgstr ""

#. type: Plain text
#: man-pages/man2/prctl.2:260
msgid "The process's effective user or group ID is changed."
msgstr ""

#. type: Plain text
#: man-pages/man2/prctl.2:263
msgid ""
"The process's filesystem user or group ID is changed (see "
"B<credentials>(7))."
msgstr ""

#. type: Plain text
#: man-pages/man2/prctl.2:268
msgid ""
"The process executes (B<execve>(2))  a set-user-ID or set-group-ID program, "
"resulting in a change of either the effective user ID or the effective group "
"ID."
msgstr ""

#.  See kernel/cred.c::commit_creds()
#.  Also certain namespace operations;
#. type: Plain text
#: man-pages/man2/prctl.2:277
msgid ""
"The process executes (B<execve>(2))  a program that has file capabilities "
"(see B<capabilities>(7)), but only if the permitted capabilities gained "
"exceed those already permitted for the process."
msgstr ""

#. type: Plain text
#: man-pages/man2/prctl.2:285
msgid ""
"Processes that are not dumpable can not be attached via B<ptrace>(2)  "
"B<PTRACE_ATTACH>; see B<ptrace>(2)  for further details."
msgstr ""

#. type: Plain text
#: man-pages/man2/prctl.2:291
msgid ""
"If a process is not dumpable, the ownership of files in the process's "
"I</proc/[pid]> directory is affected as described in B<proc>(5)."
msgstr ""

#. type: TP
#: man-pages/man2/prctl.2:291
#, no-wrap
msgid "B<PR_GET_DUMPABLE> (since Linux 2.3.20)"
msgstr ""

#.  Since Linux 2.6.13, the dumpable flag can have the value 2,
#.  but in 2.6.13 PR_GET_DUMPABLE simply returns 1 if the dumpable
#.  flags has a nonzero value.  This was fixed in 2.6.14.
#. type: Plain text
#: man-pages/man2/prctl.2:298
msgid ""
"Return (as the function result) the current state of the calling process's "
"dumpable flag."
msgstr ""

#. type: TP
#: man-pages/man2/prctl.2:298
#, no-wrap
msgid "B<PR_SET_ENDIAN> (since Linux 2.6.18, PowerPC only)"
msgstr ""

#.  Respectively 0, 1, 2
#. type: Plain text
#: man-pages/man2/prctl.2:308
msgid ""
"Set the endian-ness of the calling process to the value given in I<arg2>, "
"which should be one of the following: B<PR_ENDIAN_BIG>, B<PR_ENDIAN_LITTLE>, "
"or B<PR_ENDIAN_PPC_LITTLE> (PowerPC pseudo little endian)."
msgstr ""

#. type: TP
#: man-pages/man2/prctl.2:308
#, no-wrap
msgid "B<PR_GET_ENDIAN> (since Linux 2.6.18, PowerPC only)"
msgstr ""

#. type: Plain text
#: man-pages/man2/prctl.2:313
msgid ""
"Return the endian-ness of the calling process, in the location pointed to by "
"I<(int\\ *) arg2>."
msgstr ""

#. type: TP
#: man-pages/man2/prctl.2:313
#, no-wrap
msgid "B<PR_SET_FP_MODE> (since Linux 4.0, only on MIPS)"
msgstr ""

#.  commit 9791554b45a2acc28247f66a5fd5bbc212a6b8c8
#. type: Plain text
#: man-pages/man2/prctl.2:325
msgid ""
"On the MIPS architecture, user-space code can be built using an ABI which "
"permits linking with code that has more restrictive floating-point (FP) "
"requirements.  For example, user-space code may be built to target the O32 "
"FPXX ABI and linked with code built for either one of the more restrictive "
"FP32 or FP64 ABIs.  When more restrictive code is linked in, the overall "
"requirement for the process is to use the more restrictive floating-point "
"mode."
msgstr ""

#. type: Plain text
#: man-pages/man2/prctl.2:333
msgid ""
"Because the kernel has no means of knowing in advance which mode the process "
"should be executed in, and because these restrictions can change over the "
"lifetime of the process, the B<PR_SET_FP_MODE> operation is provided to "
"allow control of the floating-point mode from user space."
msgstr ""

#.  https://dmz-portal.mips.com/wiki/MIPS_O32_ABI_-_FR0_and_FR1_Interlinking
#. type: Plain text
#: man-pages/man2/prctl.2:338
msgid ""
"The I<(unsigned int) arg2> argument is a bit mask describing the "
"floating-point mode used:"
msgstr ""

#. type: TP
#: man-pages/man2/prctl.2:339
#, no-wrap
msgid "B<PR_FP_MODE_FR>"
msgstr ""

#. type: Plain text
#: man-pages/man2/prctl.2:350
msgid ""
"When this bit is I<unset> (so called B<FR=0> or B<FR0> mode), the 32 "
"floating-point registers are 32 bits wide, and 64-bit registers are "
"represented as a pair of registers (even- and odd- numbered, with the "
"even-numbered register containing the lower 32 bits, and the odd-numbered "
"register containing the higher 32 bits)."
msgstr ""

#. type: Plain text
#: man-pages/man2/prctl.2:360
msgid ""
"When this bit is I<set> (on supported hardware), the 32 floating-point "
"registers are 64 bits wide (so called B<FR=1> or B<FR1> mode).  Note that "
"modern MIPS implementations (MIPS R6 and newer) support B<FR=1> mode only."
msgstr ""

#. type: Plain text
#: man-pages/man2/prctl.2:376
msgid ""
"Applications that use the O32 FP32 ABI can operate only when this bit is "
"I<unset> (B<FR=0>; or they can be used with FRE enabled, see below).  "
"Applications that use the O32 FP64 ABI (and the O32 FP64A ABI, which exists "
"to provide the ability to operate with existing FP32 code; see below)  can "
"operate only when this bit is I<set> (B<FR=1>).  Applications that use the "
"O32 FPXX ABI can operate with either B<FR=0> or B<FR=1>."
msgstr ""

#. type: TP
#: man-pages/man2/prctl.2:376
#, no-wrap
msgid "B<PR_FP_MODE_FRE>"
msgstr ""

#. type: Plain text
#: man-pages/man2/prctl.2:397
msgid ""
"Enable emulation of 32-bit floating-point mode.  When this mode is enabled, "
"it emulates 32-bit floating-point operations by raising a "
"reserved-instruction exception on every instruction that uses 32-bit formats "
"and the kernel then handles the instruction in software.  (The problem lies "
"in the discrepancy of handling odd-numbered registers which are the high 32 "
"bits of 64-bit registers with even numbers in B<FR=0> mode and the lower "
"32-bit parts of odd-numbered 64-bit registers in B<FR=1> mode.)  Enabling "
"this bit is necessary when code with the O32 FP32 ABI should operate with "
"code with compatible the O32 FPXX or O32 FP64A ABIs (which require B<FR=1> "
"FPU mode) or when it is executed on newer hardware (MIPS R6 onwards)  which "
"lacks B<FR=0> mode support when a binary with the FP32 ABI is used."
msgstr ""

#. type: Plain text
#: man-pages/man2/prctl.2:400
msgid ""
"Note that this mode makes sense only when the FPU is in 64-bit mode "
"(B<FR=1>)."
msgstr ""

#. type: Plain text
#: man-pages/man2/prctl.2:403
msgid ""
"Note that the use of emulation inherently has a significant performance hit "
"and should be avoided if possible."
msgstr ""

#. type: Plain text
#: man-pages/man2/prctl.2:409
msgid ""
"In the N32/N64 ABI, 64-bit floating-point mode is always used, so FPU "
"emulation is not required and the FPU always operates in B<FR=1> mode."
msgstr ""

#. type: Plain text
#: man-pages/man2/prctl.2:412
msgid "This option is mainly intended for use by the dynamic linker (B<ld.so>(8))."
msgstr ""

#. type: Plain text
#: man-pages/man2/prctl.2:419 man-pages/man2/keyctl.2:212
#: man-pages/man2/keyctl.2:279 man-pages/man2/keyctl.2:636
#: man-pages/man2/keyctl.2:986 man-pages/man2/keyctl.2:1111
#: man-pages/man2/keyctl.2:1350
msgid "The arguments I<arg3>, I<arg4>, and I<arg5> are ignored."
msgstr ""

#. type: TP
#: man-pages/man2/prctl.2:419
#, no-wrap
msgid "B<PR_GET_FP_MODE> (since Linux 4.0, only on MIPS)"
msgstr ""

#. type: Plain text
#: man-pages/man2/prctl.2:425
msgid ""
"Return (as the function result)  the current floating-point mode (see the "
"description of B<PR_SET_FP_MODE> for details)."
msgstr ""

#. type: Plain text
#: man-pages/man2/prctl.2:428
msgid ""
"On success, the call returns a bit mask which represents the current "
"floating-point mode."
msgstr ""

#. type: Plain text
#: man-pages/man2/prctl.2:436 man-pages/man2/keyctl.2:1206
msgid "The arguments I<arg2>, I<arg3>, I<arg4>, and I<arg5> are ignored."
msgstr ""

#. type: TP
#: man-pages/man2/prctl.2:436
#, no-wrap
msgid "B<PR_SET_FPEMU> (since Linux 2.4.18, 2.5.9, only on ia64)"
msgstr ""

#. type: Plain text
#: man-pages/man2/prctl.2:446
msgid ""
"Set floating-point emulation control bits to I<arg2>.  Pass "
"B<PR_FPEMU_NOPRINT> to silently emulate floating-point operation accesses, "
"or B<PR_FPEMU_SIGFPE> to not emulate floating-point operations and send "
"B<SIGFPE> instead."
msgstr ""

#. type: TP
#: man-pages/man2/prctl.2:446
#, no-wrap
msgid "B<PR_GET_FPEMU> (since Linux 2.4.18, 2.5.9, only on ia64)"
msgstr ""

#. type: Plain text
#: man-pages/man2/prctl.2:451
msgid ""
"Return floating-point emulation control bits, in the location pointed to by "
"I<(int\\ *) arg2>."
msgstr ""

#. type: TP
#: man-pages/man2/prctl.2:451
#, no-wrap
msgid "B<PR_SET_FPEXC> (since Linux 2.4.21, 2.5.32, only on PowerPC)"
msgstr ""

#. type: Plain text
#: man-pages/man2/prctl.2:464
msgid ""
"Set floating-point exception mode to I<arg2>.  Pass B<PR_FP_EXC_SW_ENABLE> "
"to use FPEXC for FP exception enables, B<PR_FP_EXC_DIV> for floating-point "
"divide by zero, B<PR_FP_EXC_OVF> for floating-point overflow, "
"B<PR_FP_EXC_UND> for floating-point underflow, B<PR_FP_EXC_RES> for "
"floating-point inexact result, B<PR_FP_EXC_INV> for floating-point invalid "
"operation, B<PR_FP_EXC_DISABLED> for FP exceptions disabled, "
"B<PR_FP_EXC_NONRECOV> for async nonrecoverable exception mode, "
"B<PR_FP_EXC_ASYNC> for async recoverable exception mode, "
"B<PR_FP_EXC_PRECISE> for precise exception mode."
msgstr ""

#. type: TP
#: man-pages/man2/prctl.2:464
#, no-wrap
msgid "B<PR_GET_FPEXC> (since Linux 2.4.21, 2.5.32, only on PowerPC)"
msgstr ""

#. type: Plain text
#: man-pages/man2/prctl.2:469
msgid ""
"Return floating-point exception mode, in the location pointed to by I<(int\\ "
"*) arg2>."
msgstr ""

#. type: TP
#: man-pages/man2/prctl.2:469
#, no-wrap
msgid "B<PR_SET_KEEPCAPS> (since Linux 2.2.18)"
msgstr ""

#. type: Plain text
#: man-pages/man2/prctl.2:479
msgid ""
"Set the state of the calling thread's \"keep capabilities\" flag.  The "
"effect of this flag is described in B<capabilities>(7).  I<arg2> must be "
"either 0 (clear the flag)  or 1 (set the flag).  The \"keep capabilities\" "
"value will be reset to 0 on subsequent calls to B<execve>(2)."
msgstr ""

#. type: TP
#: man-pages/man2/prctl.2:479
#, no-wrap
msgid "B<PR_GET_KEEPCAPS> (since Linux 2.2.18)"
msgstr ""

#. type: Plain text
#: man-pages/man2/prctl.2:486
msgid ""
"Return (as the function result) the current state of the calling thread's "
"\"keep capabilities\" flag.  See B<capabilities>(7)  for a description of "
"this flag."
msgstr ""

#. type: TP
#: man-pages/man2/prctl.2:486
#, no-wrap
msgid "B<PR_MCE_KILL> (since Linux 2.6.32)"
msgstr ""

#. type: Plain text
#: man-pages/man2/prctl.2:526
msgid ""
"Set the machine check memory corruption kill policy for the calling thread.  "
"If I<arg2> is B<PR_MCE_KILL_CLEAR>, clear the thread memory corruption kill "
"policy and use the system-wide default.  (The system-wide default is defined "
"by I</proc/sys/vm/memory_failure_early_kill>; see B<proc>(5).)  If I<arg2> "
"is B<PR_MCE_KILL_SET>, use a thread-specific memory corruption kill policy.  "
"In this case, I<arg3> defines whether the policy is I<early kill> "
"(B<PR_MCE_KILL_EARLY>), I<late kill> (B<PR_MCE_KILL_LATE>), or the "
"system-wide default (B<PR_MCE_KILL_DEFAULT>).  Early kill means that the "
"thread receives a B<SIGBUS> signal as soon as hardware memory corruption is "
"detected inside its address space.  In late kill mode, the process is killed "
"only when it accesses a corrupted page.  See B<sigaction>(2)  for more "
"information on the B<SIGBUS> signal.  The policy is inherited by children.  "
"The remaining unused B<prctl>()  arguments must be zero for future "
"compatibility."
msgstr ""

#. type: TP
#: man-pages/man2/prctl.2:526
#, no-wrap
msgid "B<PR_MCE_KILL_GET> (since Linux 2.6.32)"
msgstr ""

#. type: Plain text
#: man-pages/man2/prctl.2:533
msgid ""
"Return (as the function result)  the current per-process machine check kill "
"policy.  All unused B<prctl>()  arguments must be zero."
msgstr ""

#. type: TP
#: man-pages/man2/prctl.2:533
#, no-wrap
msgid "B<PR_SET_MM> (since Linux 3.3)"
msgstr ""

#.  commit 028ee4be34a09a6d48bdf30ab991ae933a7bc036
#. type: Plain text
#: man-pages/man2/prctl.2:543
msgid ""
"Modify certain kernel memory map descriptor fields of the calling process.  "
"Usually these fields are set by the kernel and dynamic loader (see "
"B<ld.so>(8)  for more information) and a regular application should not use "
"this feature.  However, there are cases, such as self-modifying programs, "
"where a program might find it useful to change its own memory map."
msgstr ""

#. type: Plain text
#: man-pages/man2/prctl.2:557
msgid ""
"The calling process must have the B<CAP_SYS_RESOURCE> capability.  The value "
"in I<arg2> is one of the options below, while I<arg3> provides a new value "
"for the option.  The I<arg4> and I<arg5> arguments must be zero if unused."
msgstr ""

#.  commit 52b3694157e3aa6df871e283115652ec6f2d31e0
#. type: Plain text
#: man-pages/man2/prctl.2:563
msgid ""
"Before Linux 3.10, this feature is available only if the kernel is built "
"with the B<CONFIG_CHECKPOINT_RESTORE> option enabled."
msgstr ""

#. type: TP
#: man-pages/man2/prctl.2:564
#, no-wrap
msgid "B<PR_SET_MM_START_CODE>"
msgstr ""

#. type: Plain text
#: man-pages/man2/prctl.2:573
msgid ""
"Set the address above which the program text can run.  The corresponding "
"memory area must be readable and executable, but not writable or shareable "
"(see B<mprotect>(2)  and B<mmap>(2)  for more information)."
msgstr ""

#. type: TP
#: man-pages/man2/prctl.2:573
#, no-wrap
msgid "B<PR_SET_MM_END_CODE>"
msgstr ""

#. type: Plain text
#: man-pages/man2/prctl.2:578
msgid ""
"Set the address below which the program text can run.  The corresponding "
"memory area must be readable and executable, but not writable or shareable."
msgstr ""

#. type: TP
#: man-pages/man2/prctl.2:578
#, no-wrap
msgid "B<PR_SET_MM_START_DATA>"
msgstr ""

#. type: Plain text
#: man-pages/man2/prctl.2:584
msgid ""
"Set the address above which initialized and uninitialized (bss) data are "
"placed.  The corresponding memory area must be readable and writable, but "
"not executable or shareable."
msgstr ""

#. type: TP
#: man-pages/man2/prctl.2:584
#, no-wrap
msgid "B<PR_SET_MM_END_DATA>"
msgstr ""

#. type: Plain text
#: man-pages/man2/prctl.2:590
msgid ""
"Set the address below which initialized and uninitialized (bss) data are "
"placed.  The corresponding memory area must be readable and writable, but "
"not executable or shareable."
msgstr ""

#. type: TP
#: man-pages/man2/prctl.2:590
#, no-wrap
msgid "B<PR_SET_MM_START_STACK>"
msgstr ""

#. type: Plain text
#: man-pages/man2/prctl.2:594
msgid ""
"Set the start address of the stack.  The corresponding memory area must be "
"readable and writable."
msgstr ""

#. type: TP
#: man-pages/man2/prctl.2:594
#, no-wrap
msgid "B<PR_SET_MM_START_BRK>"
msgstr ""

#. type: Plain text
#: man-pages/man2/prctl.2:606
msgid ""
"Set the address above which the program heap can be expanded with B<brk>(2)  "
"call.  The address must be greater than the ending address of the current "
"program data segment.  In addition, the combined size of the resulting heap "
"and the size of the data segment can't exceed the B<RLIMIT_DATA> resource "
"limit (see B<setrlimit>(2))."
msgstr ""

#. type: TP
#: man-pages/man2/prctl.2:606
#, no-wrap
msgid "B<PR_SET_MM_BRK>"
msgstr ""

#. type: Plain text
#: man-pages/man2/prctl.2:614
msgid ""
"Set the current B<brk>(2)  value.  The requirements for the address are the "
"same as for the B<PR_SET_MM_START_BRK> option."
msgstr ""

#.  commit fe8c7f5cbf91124987106faa3bdf0c8b955c4cf7
#. type: Plain text
#: man-pages/man2/prctl.2:617
msgid "The following options are available since Linux 3.5."
msgstr ""

#. type: TP
#: man-pages/man2/prctl.2:617
#, no-wrap
msgid "B<PR_SET_MM_ARG_START>"
msgstr ""

#. type: Plain text
#: man-pages/man2/prctl.2:620
msgid "Set the address above which the program command line is placed."
msgstr ""

#. type: TP
#: man-pages/man2/prctl.2:620
#, no-wrap
msgid "B<PR_SET_MM_ARG_END>"
msgstr ""

#. type: Plain text
#: man-pages/man2/prctl.2:623
msgid "Set the address below which the program command line is placed."
msgstr ""

#. type: TP
#: man-pages/man2/prctl.2:623
#, no-wrap
msgid "B<PR_SET_MM_ENV_START>"
msgstr ""

#. type: Plain text
#: man-pages/man2/prctl.2:626
msgid "Set the address above which the program environment is placed."
msgstr ""

#. type: TP
#: man-pages/man2/prctl.2:626
#, no-wrap
msgid "B<PR_SET_MM_ENV_END>"
msgstr ""

#. type: Plain text
#: man-pages/man2/prctl.2:629
msgid "Set the address below which the program environment is placed."
msgstr ""

#. type: Plain text
#: man-pages/man2/prctl.2:642
msgid ""
"The address passed with B<PR_SET_MM_ARG_START>, B<PR_SET_MM_ARG_END>, "
"B<PR_SET_MM_ENV_START>, and B<PR_SET_MM_ENV_END> should belong to a process "
"stack area.  Thus, the corresponding memory area must be readable, writable, "
"and (depending on the kernel configuration) have the B<MAP_GROWSDOWN> "
"attribute set (see B<mmap>(2))."
msgstr ""

#. type: TP
#: man-pages/man2/prctl.2:642
#, no-wrap
msgid "B<PR_SET_MM_AUXV>"
msgstr ""

#. type: Plain text
#: man-pages/man2/prctl.2:651
msgid ""
"Set a new auxiliary vector.  The I<arg3> argument should provide the address "
"of the vector.  The I<arg4> is the size of the vector."
msgstr ""

#. type: TP
#: man-pages/man2/prctl.2:651
#, no-wrap
msgid "B<PR_SET_MM_EXE_FILE>"
msgstr ""

#.  commit b32dfe377102ce668775f8b6b1461f7ad428f8b6
#. type: Plain text
#: man-pages/man2/prctl.2:663
msgid ""
"Supersede the I</proc/pid/exe> symbolic link with a new one pointing to a "
"new executable file identified by the file descriptor provided in I<arg3> "
"argument.  The file descriptor should be obtained with a regular B<open>(2)  "
"call."
msgstr ""

#. type: Plain text
#: man-pages/man2/prctl.2:670
msgid ""
"To change the symbolic link, one needs to unmap all existing executable "
"memory areas, including those created by the kernel itself (for example the "
"kernel usually creates at least one executable memory area for the ELF "
"I<.text> section)."
msgstr ""

#.  commit 3fb4afd9a504c2386b8435028d43283216bf588e
#. type: Plain text
#: man-pages/man2/prctl.2:681
msgid ""
"In Linux 4.9 and earlier, the B<PR_SET_MM_EXE_FILE> operation can be "
"performed only once in a process's lifetime; attempting to perform the "
"operation a second time results in the error B<EPERM>.  This restriction was "
"enforced for security reasons that were subsequently deemed specious, and "
"the restriction was removed in Linux 4.10 because some user-space "
"applications needed to perform this operation more than once."
msgstr ""

#.  commit f606b77f1a9e362451aca8f81d8f36a3a112139e
#. type: Plain text
#: man-pages/man2/prctl.2:684
msgid "The following options are available since Linux 3.18."
msgstr ""

#. type: TP
#: man-pages/man2/prctl.2:684
#, no-wrap
msgid "B<PR_SET_MM_MAP>"
msgstr ""

#. type: Plain text
#: man-pages/man2/prctl.2:692
msgid ""
"Provides one-shot access to all the addresses by passing in a I<struct "
"prctl_mm_map> (as defined in I<E<lt>linux/prctl.hE<gt>>).  The I<arg4> "
"argument should provide the size of the struct."
msgstr ""

#. type: Plain text
#: man-pages/man2/prctl.2:696 man-pages/man2/prctl.2:709
msgid ""
"This feature is available only if the kernel is built with the "
"B<CONFIG_CHECKPOINT_RESTORE> option enabled."
msgstr ""

#. type: TP
#: man-pages/man2/prctl.2:696
#, no-wrap
msgid "B<PR_SET_MM_MAP_SIZE>"
msgstr ""

#. type: Plain text
#: man-pages/man2/prctl.2:705
msgid ""
"Returns the size of the I<struct prctl_mm_map> the kernel expects.  This "
"allows user space to find a compatible struct.  The I<arg4> argument should "
"be a pointer to an unsigned int."
msgstr ""

#. type: TP
#: man-pages/man2/prctl.2:710
#, no-wrap
msgid "B<PR_MPX_ENABLE_MANAGEMENT>, B<PR_MPX_DISABLE_MANAGEMENT> (since Linux 3.19) "
msgstr ""

#.  commit fe3d197f84319d3bce379a9c0dc17b1f48ad358c
#.  See also http://lwn.net/Articles/582712/
#.  See also https://gcc.gnu.org/wiki/Intel%20MPX%20support%20in%20the%20GCC%20compiler
#.  commit e9d1b4f3c60997fe197bf0243cb4a41a44387a88
#. type: Plain text
#: man-pages/man2/prctl.2:725
msgid ""
"Enable or disable kernel management of Memory Protection eXtensions (MPX)  "
"bounds tables.  The I<arg2>, I<arg3>, I<arg4>, and I<arg5> arguments must be "
"zero."
msgstr ""

#. type: Plain text
#: man-pages/man2/prctl.2:738
msgid ""
"MPX is a hardware-assisted mechanism for performing bounds checking on "
"pointers.  It consists of a set of registers storing bounds information and "
"a set of special instruction prefixes that tell the CPU on which "
"instructions it should do bounds enforcement.  There is a limited number of "
"these registers and when there are more pointers than registers, their "
"contents must be \"spilled\" into a set of tables.  These tables are called "
"\"bounds tables\" and the MPX B<prctl>()  operations control whether the "
"kernel manages their allocation and freeing."
msgstr ""

#. type: Plain text
#: man-pages/man2/prctl.2:748
msgid ""
"When management is enabled, the kernel will take over allocation and freeing "
"of the bounds tables.  It does this by trapping the #BR exceptions that "
"result at first use of missing bounds tables and instead of delivering the "
"exception to user space, it allocates the table and populates the bounds "
"directory with the location of the new table.  For freeing, the kernel "
"checks to see if bounds tables are present for memory which is not "
"allocated, and frees them if so."
msgstr ""

#. type: Plain text
#: man-pages/man2/prctl.2:755
msgid ""
"Before enabling MPX management using B<PR_MPX_ENABLE_MANAGEMENT>, the "
"application must first have allocated a user-space buffer for the bounds "
"directory and placed the location of that directory in the I<bndcfgu> "
"register."
msgstr ""

#. type: Plain text
#: man-pages/man2/prctl.2:762
msgid ""
"These calls fail if the CPU or kernel does not support MPX.  Kernel support "
"for MPX is enabled via the B<CONFIG_X86_INTEL_MPX> configuration option.  "
"You can check whether the CPU supports MPX by looking for the 'mpx' CPUID "
"bit, like with the following command:"
msgstr ""

#. type: Plain text
#: man-pages/man2/prctl.2:766
#, no-wrap
msgid "cat /proc/cpuinfo | grep ' mpx '\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/prctl.2:771
msgid ""
"A thread may not switch in or out of long (64-bit) mode while MPX is "
"enabled."
msgstr ""

#. type: Plain text
#: man-pages/man2/prctl.2:773
msgid "All threads in a process are affected by these calls."
msgstr ""

#. type: Plain text
#: man-pages/man2/prctl.2:782
msgid ""
"The child of a B<fork>(2)  inherits the state of MPX management.  During "
"B<execve>(2), MPX management is reset to a state as if "
"B<PR_MPX_DISABLE_MANAGEMENT> had been called."
msgstr ""

#. type: Plain text
#: man-pages/man2/prctl.2:785
msgid ""
"For further information on Intel MPX, see the kernel source file "
"I<Documentation/x86/intel_mpx.txt>."
msgstr ""

#. type: TP
#: man-pages/man2/prctl.2:785
#, no-wrap
msgid "B<PR_SET_NAME> (since Linux 2.6.9)"
msgstr ""

#.  TASK_COMM_LEN in include/linux/sched.h
#. type: Plain text
#: man-pages/man2/prctl.2:804
msgid ""
"Set the name of the calling thread, using the value in the location pointed "
"to by I<(char\\ *) arg2>.  The name can be up to 16 bytes long, including "
"the terminating null byte.  (If the length of the string, including the "
"terminating null byte, exceeds 16 bytes, the string is silently truncated.)  "
"This is the same attribute that can be set via B<pthread_setname_np>(3)  and "
"retrieved using B<pthread_getname_np>(3).  The attribute is likewise "
"accessible via I</proc/self/task/[tid]/comm>, where I<tid> is the name of "
"the calling thread."
msgstr ""

#. type: TP
#: man-pages/man2/prctl.2:804
#, no-wrap
msgid "B<PR_GET_NAME> (since Linux 2.6.11)"
msgstr ""

#. type: Plain text
#: man-pages/man2/prctl.2:811
msgid ""
"Return the name of the calling thread, in the buffer pointed to by I<(char\\ "
"*) arg2>.  The buffer should allow space for up to 16 bytes; the returned "
"string will be null-terminated."
msgstr ""

#. type: TP
#: man-pages/man2/prctl.2:811
#, no-wrap
msgid "B<PR_SET_NO_NEW_PRIVS> (since Linux 3.5)"
msgstr ""

#. type: Plain text
#: man-pages/man2/prctl.2:836
msgid ""
"Set the calling thread's I<no_new_privs> attribute to the value in I<arg2>.  "
"With I<no_new_privs> set to 1, B<execve>(2)  promises not to grant "
"privileges to do anything that could not have been done without the "
"B<execve>(2)  call (for example, rendering the set-user-ID and set-group-ID "
"mode bits, and file capabilities non-functional).  Once set, this the "
"I<no_new_privs> attribute cannot be unset.  The setting of this attribute is "
"inherited by children created by B<fork>(2)  and B<clone>(2), and preserved "
"across B<execve>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/prctl.2:845
msgid ""
"Since Linux 4.10, the value of a thread's I<no_new_privs> attribute can be "
"viewed via the I<NoNewPrivs> field in the I</proc/[pid]/status> file."
msgstr ""

#.  commit 40fde647ccb0ae8c11d256d271e24d385eed595b
#. type: Plain text
#: man-pages/man2/prctl.2:854
msgid ""
"For more information, see the kernel source file "
"I<Documentation/userspace-api/no_new_privs.rst> (or "
"I<Documentation/prctl/no_new_privs.txt> before Linux 4.13).  See also "
"B<seccomp>(2)."
msgstr ""

#. type: TP
#: man-pages/man2/prctl.2:854
#, no-wrap
msgid "B<PR_GET_NO_NEW_PRIVS> (since Linux 3.5)"
msgstr ""

#. type: Plain text
#: man-pages/man2/prctl.2:865
msgid ""
"Return (as the function result) the value of the I<no_new_privs> attribute "
"for the calling thread.  A value of 0 indicates the regular B<execve>(2)  "
"behavior.  A value of 1 indicates B<execve>(2)  will operate in the "
"privilege-restricting mode described above."
msgstr ""

#. type: TP
#: man-pages/man2/prctl.2:865
#, no-wrap
msgid "B<PR_SET_PDEATHSIG> (since Linux 2.1.57)"
msgstr ""

#. type: Plain text
#: man-pages/man2/prctl.2:872
msgid ""
"Set the parent-death signal of the calling process to I<arg2> (either a "
"signal value in the range 1..maxsig, or 0 to clear).  This is the signal "
"that the calling process will get when its parent dies."
msgstr ""

#.  https://bugzilla.kernel.org/show_bug.cgi?id=43300
#. type: Plain text
#: man-pages/man2/prctl.2:882
msgid ""
"I<Warning>: the \"parent\" in this case is considered to be the I<thread> "
"that created this process.  In other words, the signal will be sent when "
"that thread terminates (via, for example, B<pthread_exit>(3)), rather than "
"after all of the threads in the parent process terminate."
msgstr ""

#. type: Plain text
#: man-pages/man2/prctl.2:892
msgid ""
"The parent-death signal is sent upon subsequent termination of the parent "
"thread and also upon termination of each subreaper process (see the "
"description of B<PR_SET_CHILD_SUBREAPER> above) to which the caller is "
"subsequently reparented.  If the parent thread and all ancestor subreapers "
"have already terminated by the time of the B<PR_SET_PDEATHSIG> operation, "
"then no parent-death signal is sent to the caller."
msgstr ""

#. type: Plain text
#: man-pages/man2/prctl.2:903
msgid ""
"The parent-death signal is process-directed (see B<signal>(7))  and, if the "
"child installs a handler using the B<sigaction>(2)  B<SA_SIGINFO> flag, the "
"I<si_pid> field of the I<siginfo_t> argument of the handler contains the PID "
"of the terminating parent process."
msgstr ""

#.  commit d2d56c5f51028cb9f3d800882eb6f4cbd3f9099f
#. type: Plain text
#: man-pages/man2/prctl.2:914
msgid ""
"The parent-death signal setting is cleared for the child of a B<fork>(2).  "
"It is also (since Linux 2.4.36 / 2.6.23)  cleared when executing a "
"set-user-ID or set-group-ID binary, or a binary that has associated "
"capabilities (see B<capabilities>(7)); otherwise, this value is preserved "
"across B<execve>(2)."
msgstr ""

#. type: TP
#: man-pages/man2/prctl.2:914
#, no-wrap
msgid "B<PR_GET_PDEATHSIG> (since Linux 2.3.15)"
msgstr ""

#. type: Plain text
#: man-pages/man2/prctl.2:919
msgid ""
"Return the current value of the parent process death signal, in the location "
"pointed to by I<(int\\ *) arg2>."
msgstr ""

#. type: TP
#: man-pages/man2/prctl.2:919
#, no-wrap
msgid "B<PR_SET_PTRACER> (since Linux 3.4)"
msgstr ""

#.  commit 2d514487faf188938a4ee4fb3464eeecfbdcf8eb
#.  commit bf06189e4d14641c0148bea16e9dd24943862215
#. type: Plain text
#: man-pages/man2/prctl.2:944
msgid ""
"This is meaningful only when the Yama LSM is enabled and in mode 1 "
"(\"restricted ptrace\", visible via I</proc/sys/kernel/yama/ptrace_scope>).  "
"When a \"ptracer process ID\" is passed in I<arg2>, the caller is declaring "
"that the ptracer process can B<ptrace>(2)  the calling process as if it were "
"a direct process ancestor.  Each B<PR_SET_PTRACER> operation replaces the "
"previous \"ptracer process ID\".  Employing B<PR_SET_PTRACER> with I<arg2> "
"set to 0 clears the caller's \"ptracer process ID\".  If I<arg2> is "
"B<PR_SET_PTRACER_ANY>, the ptrace restrictions introduced by Yama are "
"effectively disabled for the calling process."
msgstr ""

#.  commit 90bb766440f2147486a2acc3e793d7b8348b0c22
#. type: Plain text
#: man-pages/man2/prctl.2:951
msgid ""
"For further information, see the kernel source file "
"I<Documentation/admin-guide/LSM/Yama.rst> (or "
"I<Documentation/security/Yama.txt> before Linux 4.13)."
msgstr ""

#. type: TP
#: man-pages/man2/prctl.2:951
#, no-wrap
msgid "B<PR_SET_SECCOMP> (since Linux 2.6.23)"
msgstr ""

#.  See http://thread.gmane.org/gmane.linux.kernel/542632
#.  [PATCH 0 of 2] seccomp updates
#.  andrea@cpushare.com
#. type: Plain text
#: man-pages/man2/prctl.2:962
msgid ""
"Set the secure computing (seccomp) mode for the calling thread, to limit the "
"available system calls.  The more recent B<seccomp>(2)  system call provides "
"a superset of the functionality of B<PR_SET_SECCOMP>."
msgstr ""

#. type: Plain text
#: man-pages/man2/prctl.2:967
msgid ""
"The seccomp mode is selected via I<arg2>.  (The seccomp constants are "
"defined in I<E<lt>linux/seccomp.hE<gt>>.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/prctl.2:990
msgid ""
"With I<arg2> set to B<SECCOMP_MODE_STRICT>, the only system calls that the "
"thread is permitted to make are B<read>(2), B<write>(2), B<_exit>(2)  (but "
"not B<exit_group>(2)), and B<sigreturn>(2).  Other system calls result in "
"the delivery of a B<SIGKILL> signal.  Strict secure computing mode is useful "
"for number-crunching applications that may need to execute untrusted byte "
"code, perhaps obtained by reading from a pipe or socket.  This operation is "
"available only if the kernel is configured with B<CONFIG_SECCOMP> enabled."
msgstr ""

#. type: Plain text
#: man-pages/man2/prctl.2:1005
msgid ""
"With I<arg2> set to B<SECCOMP_MODE_FILTER> (since Linux 3.5), the system "
"calls allowed are defined by a pointer to a Berkeley Packet Filter passed in "
"I<arg3>.  This argument is a pointer to I<struct sock_fprog>; it can be "
"designed to filter arbitrary system calls and system call arguments.  This "
"mode is available only if the kernel is configured with "
"B<CONFIG_SECCOMP_FILTER> enabled."
msgstr ""

#. type: Plain text
#: man-pages/man2/prctl.2:1020
msgid ""
"If B<SECCOMP_MODE_FILTER> filters permit B<fork>(2), then the seccomp mode "
"is inherited by children created by B<fork>(2); if B<execve>(2)  is "
"permitted, then the seccomp mode is preserved across B<execve>(2).  If the "
"filters permit B<prctl>()  calls, then additional filters can be added; they "
"are run in order until the first non-allow result is seen."
msgstr ""

#.  commit c061f33f35be0ccc80f4b8e0aea5dfd2ed7e01a3
#. type: Plain text
#: man-pages/man2/prctl.2:1027
msgid ""
"For further information, see the kernel source file "
"I<Documentation/userspace-api/seccomp_filter.rst> (or "
"I<Documentation/prctl/seccomp_filter.txt> before Linux 4.13)."
msgstr ""

#. type: TP
#: man-pages/man2/prctl.2:1027
#, no-wrap
msgid "B<PR_GET_SECCOMP> (since Linux 2.6.23)"
msgstr ""

#. type: Plain text
#: man-pages/man2/prctl.2:1045
msgid ""
"Return (as the function result)  the secure computing mode of the calling "
"thread.  If the caller is not in secure computing mode, this operation "
"returns 0; if the caller is in strict secure computing mode, then the "
"B<prctl>()  call will cause a B<SIGKILL> signal to be sent to the process.  "
"If the caller is in filter mode, and this system call is allowed by the "
"seccomp filters, it returns 2; otherwise, the process is killed with a "
"B<SIGKILL> signal.  This operation is available only if the kernel is "
"configured with B<CONFIG_SECCOMP> enabled."
msgstr ""

#. type: Plain text
#: man-pages/man2/prctl.2:1053
msgid ""
"Since Linux 3.8, the I<Seccomp> field of the I</proc/[pid]/status> file "
"provides a method of obtaining the same information, without the risk that "
"the process is killed; see B<proc>(5)."
msgstr ""

#. type: TP
#: man-pages/man2/prctl.2:1053
#, no-wrap
msgid "B<PR_SET_SECUREBITS> (since Linux 2.6.26)"
msgstr ""

#. type: Plain text
#: man-pages/man2/prctl.2:1059
msgid ""
"Set the \"securebits\" flags of the calling thread to the value supplied in "
"I<arg2>.  See B<capabilities>(7)."
msgstr ""

#. type: TP
#: man-pages/man2/prctl.2:1059
#, no-wrap
msgid "B<PR_GET_SECUREBITS> (since Linux 2.6.26)"
msgstr ""

#. type: Plain text
#: man-pages/man2/prctl.2:1065
msgid ""
"Return (as the function result)  the \"securebits\" flags of the calling "
"thread.  See B<capabilities>(7)."
msgstr ""

#. type: TP
#: man-pages/man2/prctl.2:1065
#, no-wrap
msgid "B<PR_GET_SPECULATION_CTRL> (since Linux 4.17)"
msgstr ""

#. type: Plain text
#: man-pages/man2/prctl.2:1074
msgid ""
"Return (as the function result)  the state of the speculation misfeature "
"specified in I<arg2>.  Currently, the only permitted value for this argument "
"is B<PR_SPEC_STORE_BYPASS> (otherwise the call fails with the error "
"B<ENODEV>)."
msgstr ""

#. type: Plain text
#: man-pages/man2/prctl.2:1076
msgid "The return value uses bits 0-3 with the following meaning:"
msgstr ""

#. type: TP
#: man-pages/man2/prctl.2:1077
#, no-wrap
msgid "B<PR_SPEC_PRCTL>"
msgstr ""

#. type: Plain text
#: man-pages/man2/prctl.2:1081
msgid "Mitigation can be controlled per thread by B<PR_SET_SPECULATION_CTRL>"
msgstr ""

#. type: TP
#: man-pages/man2/prctl.2:1081 man-pages/man2/prctl.2:1127
#, no-wrap
msgid "B<PR_SPEC_ENABLE>"
msgstr ""

#. type: Plain text
#: man-pages/man2/prctl.2:1084 man-pages/man2/prctl.2:1130
msgid "The speculation feature is enabled, mitigation is disabled."
msgstr ""

#. type: TP
#: man-pages/man2/prctl.2:1084 man-pages/man2/prctl.2:1130
#, no-wrap
msgid "B<PR_SPEC_DISABLE>"
msgstr ""

#. type: Plain text
#: man-pages/man2/prctl.2:1087 man-pages/man2/prctl.2:1133
msgid "The speculation feature is disabled, mitigation is enabled"
msgstr ""

#. type: TP
#: man-pages/man2/prctl.2:1087 man-pages/man2/prctl.2:1133
#, no-wrap
msgid "B<PR_SPEC_FORCE_DISABLE>"
msgstr ""

#. type: Plain text
#: man-pages/man2/prctl.2:1092
msgid "Same as B<PR_SPEC_DISABLE> but cannot be undone."
msgstr ""

#. type: Plain text
#: man-pages/man2/prctl.2:1096
msgid ""
"If all bits are 0, then the CPU is not affected by the speculation "
"misfeature."
msgstr ""

#. type: Plain text
#: man-pages/man2/prctl.2:1103
msgid ""
"If B<PR_SPEC_PRCTL> is set, then per-thread control of the mitigation is "
"available.  If not set, B<prctl>()  for the speculation misfeature will "
"fail."
msgstr ""

#. type: Plain text
#: man-pages/man2/prctl.2:1111
msgid ""
"The I<arg3>, I<arg4>, and I<arg5> arguments must be specified as 0; "
"otherwise the call fails with the error B<EINVAL>."
msgstr ""

#. type: TP
#: man-pages/man2/prctl.2:1111
#, no-wrap
msgid "B<PR_SET_SPECULATION_CTRL> (since Linux 4.17)"
msgstr ""

#.  commit b617cfc858161140d69cc0b5cc211996b557a1c7
#.  commit 356e4bfff2c5489e016fdb925adbf12a1e3950ee
#. type: Plain text
#: man-pages/man2/prctl.2:1126
msgid ""
"Sets the state of the speculation misfeature specified in I<arg2>.  "
"Currently, the only permitted value for this argument is "
"B<PR_SPEC_STORE_BYPASS> (otherwise the call fails with the error "
"B<ENODEV>).  This setting is a per-thread attribute.  The I<arg3> argument "
"is used to hand in the control value, which is one of the following:"
msgstr ""

#. type: Plain text
#: man-pages/man2/prctl.2:1143
msgid ""
"Same as B<PR_SPEC_DISABLE> but cannot be undone.  A subsequent B<prctl(..., "
"PR_SPEC_ENABLE)> will fail with the error B<EPERM>."
msgstr ""

#. type: Plain text
#: man-pages/man2/prctl.2:1149
msgid ""
"Any other value in I<arg3> will result in the call failing with the error "
"B<ERANGE>."
msgstr ""

#. type: Plain text
#: man-pages/man2/prctl.2:1156
msgid ""
"The I<arg4> and I<arg5> arguments must be specified as 0; otherwise the call "
"fails with the error B<EINVAL>."
msgstr ""

#. type: Plain text
#: man-pages/man2/prctl.2:1166
msgid ""
"The speculation feature can also be controlled by the "
"B<spec_store_bypass_disable> boot parameter.  This parameter may enforce a "
"read-only policy which will result in the B<prctl>()  call failing with the "
"error B<ENXIO>.  For further details, see the kernel source file "
"I<Documentation/admin-guide/kernel-parameters.txt>."
msgstr ""

#. type: TP
#: man-pages/man2/prctl.2:1166
#, no-wrap
msgid "B<PR_SET_THP_DISABLE> (since Linux 3.15)"
msgstr ""

#.  commit a0715cc22601e8830ace98366c0c2bd8da52af52
#. type: Plain text
#: man-pages/man2/prctl.2:1183
msgid ""
"Set the state of the \"THP disable\" flag for the calling thread.  If "
"I<arg2> has a nonzero value, the flag is set, otherwise it is cleared.  "
"Setting this flag provides a method for disabling transparent huge pages for "
"jobs where the code cannot be modified, and using a malloc hook with "
"B<madvise>(2)  is not an option (i.e., statically allocated data).  The "
"setting of the \"THP disable\" flag is inherited by a child created via "
"B<fork>(2)  and is preserved across B<execve>(2)."
msgstr ""

#. type: TP
#: man-pages/man2/prctl.2:1183
#, no-wrap
msgid "B<PR_TASK_PERF_EVENTS_DISABLE> (since Linux 2.6.31)"
msgstr ""

#. type: Plain text
#: man-pages/man2/prctl.2:1192
msgid ""
"Disable all performance counters attached to the calling process, regardless "
"of whether the counters were created by this process or another process.  "
"Performance counters created by the calling process for other processes are "
"unaffected.  For more information on performance counters, see the Linux "
"kernel source file I<tools/perf/design.txt>."
msgstr ""

#.  commit 1d1c7ddbfab358445a542715551301b7fc363e28
#. type: Plain text
#: man-pages/man2/prctl.2:1199
msgid ""
"Originally called B<PR_TASK_PERF_COUNTERS_DISABLE>; renamed (retaining the "
"same numerical value)  in Linux 2.6.32."
msgstr ""

#. type: TP
#: man-pages/man2/prctl.2:1199
#, no-wrap
msgid "B<PR_TASK_PERF_EVENTS_ENABLE> (since Linux 2.6.31)"
msgstr ""

#. type: Plain text
#: man-pages/man2/prctl.2:1204
msgid ""
"The converse of B<PR_TASK_PERF_EVENTS_DISABLE>; enable performance counters "
"attached to the calling process."
msgstr ""

#.  commit 1d1c7ddbfab358445a542715551301b7fc363e28
#.  commit cdd6c482c9ff9c55475ee7392ec8f672eddb7be6
#. type: Plain text
#: man-pages/man2/prctl.2:1212
msgid "Originally called B<PR_TASK_PERF_COUNTERS_ENABLE>; renamed in Linux 2.6.32."
msgstr ""

#. type: TP
#: man-pages/man2/prctl.2:1212
#, no-wrap
msgid "B<PR_GET_THP_DISABLE> (since Linux 3.15)"
msgstr ""

#. type: Plain text
#: man-pages/man2/prctl.2:1217
msgid ""
"Return (as the function result) the current setting of the \"THP disable\" "
"flag for the calling thread: either 1, if the flag is set, or 0, if it is "
"not."
msgstr ""

#. type: TP
#: man-pages/man2/prctl.2:1217
#, no-wrap
msgid "B<PR_GET_TID_ADDRESS> (since Linux 3.5)"
msgstr ""

#.  commit 300f786b2683f8bb1ec0afb6e1851183a479c86d
#. type: Plain text
#: man-pages/man2/prctl.2:1238
msgid ""
"Return the I<clear_child_tid> address set by B<set_tid_address>(2)  and the "
"B<clone>(2)  B<CLONE_CHILD_CLEARTID> flag, in the location pointed to by "
"I<(int\\ **)\\ arg2>.  This feature is available only if the kernel is built "
"with the B<CONFIG_CHECKPOINT_RESTORE> option enabled.  Note that since the "
"B<prctl>()  system call does not have a compat implementation for the AMD64 "
"x32 and MIPS n32 ABIs, and the kernel writes out a pointer using the "
"kernel's pointer size, this operation expects a user-space buffer of 8 (not "
"4) bytes on these ABIs."
msgstr ""

#. type: TP
#: man-pages/man2/prctl.2:1238
#, no-wrap
msgid "B<PR_SET_TIMERSLACK> (since Linux 2.6.28)"
msgstr ""

#.  See https://lwn.net/Articles/369549/
#.  commit 6976675d94042fbd446231d1bd8b7de71a980ada
#. type: Plain text
#: man-pages/man2/prctl.2:1256
msgid ""
"Each thread has two associated timer slack values: a \"default\" value, and "
"a \"current\" value.  This operation sets the \"current\" timer slack value "
"for the calling thread.  I<arg2> is an unsigned long value, then maximum "
"\"current\" value is ULONG_MAX and the minimum \"current\" value is 1.  If "
"the nanosecond value supplied in I<arg2> is greater than zero, then the "
"\"current\" value is set to this value.  If I<arg2> is equal to zero, the "
"\"current\" timer slack is reset to the thread's \"default\" timer slack "
"value."
msgstr ""

#. type: Plain text
#: man-pages/man2/prctl.2:1263
msgid ""
"The \"current\" timer slack is used by the kernel to group timer expirations "
"for the calling thread that are close to one another; as a consequence, "
"timer expirations for the thread may be up to the specified number of "
"nanoseconds late (but will never expire early).  Grouping timer expirations "
"can help reduce system power consumption by minimizing CPU wake-ups."
msgstr ""

#.  List obtained by grepping for futex usage in glibc source
#. type: Plain text
#: man-pages/man2/prctl.2:1283
msgid ""
"The timer expirations affected by timer slack are those set by B<select>(2), "
"B<pselect>(2), B<poll>(2), B<ppoll>(2), B<epoll_wait>(2), B<epoll_pwait>(2), "
"B<clock_nanosleep>(2), B<nanosleep>(2), and B<futex>(2)  (and thus the "
"library functions implemented via futexes, including "
"B<pthread_cond_timedwait>(3), B<pthread_mutex_timedlock>(3), "
"B<pthread_rwlock_timedrdlock>(3), B<pthread_rwlock_timedwrlock>(3), and "
"B<sem_timedwait>(3))."
msgstr ""

#. type: Plain text
#: man-pages/man2/prctl.2:1287
msgid ""
"Timer slack is not applied to threads that are scheduled under a real-time "
"scheduling policy (see B<sched_setscheduler>(2))."
msgstr ""

#. type: Plain text
#: man-pages/man2/prctl.2:1302
msgid ""
"When a new thread is created, the two timer slack values are made the same "
"as the \"current\" value of the creating thread.  Thereafter, a thread can "
"adjust its \"current\" timer slack value via B<PR_SET_TIMERSLACK>.  The "
"\"default\" value can't be changed.  The timer slack values of I<init> (PID "
"1), the ancestor of all processes, are 50,000 nanoseconds (50 "
"microseconds).  The timer slack value is inherited by a child created via "
"B<fork>(2), and is preserved across B<execve>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/prctl.2:1308
msgid ""
"Since Linux 4.6, the \"current\" timer slack value of any process can be "
"examined and changed via the file I</proc/[pid]/timerslack_ns>.  See "
"B<proc>(5)."
msgstr ""

#. type: TP
#: man-pages/man2/prctl.2:1308
#, no-wrap
msgid "B<PR_GET_TIMERSLACK> (since Linux 2.6.28)"
msgstr ""

#. type: Plain text
#: man-pages/man2/prctl.2:1312
msgid ""
"Return (as the function result)  the \"current\" timer slack value of the "
"calling thread."
msgstr ""

#. type: TP
#: man-pages/man2/prctl.2:1312
#, no-wrap
msgid "B<PR_SET_TIMING> (since Linux 2.6.0)"
msgstr ""

#.  Precisely: Linux 2.6.0-test4
#.  0
#.  1
#.  PR_TIMING_TIMESTAMP doesn't do anything in 2.6.26-rc8,
#.  and looking at the patch history, it appears
#.  that it never did anything.
#. type: Plain text
#: man-pages/man2/prctl.2:1330
msgid ""
"Set whether to use (normal, traditional) statistical process timing or "
"accurate timestamp-based process timing, by passing B<PR_TIMING_STATISTICAL> "
"or B<PR_TIMING_TIMESTAMP> to I<arg2>.  B<PR_TIMING_TIMESTAMP> is not "
"currently implemented (attempting to set this mode will yield the error "
"B<EINVAL>)."
msgstr ""

#. type: TP
#: man-pages/man2/prctl.2:1330
#, no-wrap
msgid "B<PR_GET_TIMING> (since Linux 2.6.0)"
msgstr ""

#.  Precisely: Linux 2.6.0-test4
#. type: Plain text
#: man-pages/man2/prctl.2:1335
msgid ""
"Return (as the function result) which process timing method is currently in "
"use."
msgstr ""

#. type: TP
#: man-pages/man2/prctl.2:1335
#, no-wrap
msgid "B<PR_SET_TSC> (since Linux 2.6.26, x86 only)"
msgstr ""

#. type: Plain text
#: man-pages/man2/prctl.2:1348
msgid ""
"Set the state of the flag determining whether the timestamp counter can be "
"read by the process.  Pass B<PR_TSC_ENABLE> to I<arg2> to allow it to be "
"read, or B<PR_TSC_SIGSEGV> to generate a B<SIGSEGV> when the process tries "
"to read the timestamp counter."
msgstr ""

#. type: TP
#: man-pages/man2/prctl.2:1348
#, no-wrap
msgid "B<PR_GET_TSC> (since Linux 2.6.26, x86 only)"
msgstr ""

#. type: Plain text
#: man-pages/man2/prctl.2:1354
msgid ""
"Return the state of the flag determining whether the timestamp counter can "
"be read, in the location pointed to by I<(int\\ *) arg2>."
msgstr ""

#. type: TP
#: man-pages/man2/prctl.2:1354
#, no-wrap
msgid "B<PR_SET_UNALIGN>"
msgstr ""

#.  sh: 94ea5e449ae834af058ef005d16a8ad44fcf13d6
#.  tile: 2f9ac29eec71a696cb0dcc5fb82c0f8d4dac28c9
#. type: Plain text
#: man-pages/man2/prctl.2:1377
msgid ""
"(Only on: ia64, since Linux 2.3.48; parisc, since Linux 2.6.15; PowerPC, "
"since Linux 2.6.18; Alpha, since Linux 2.6.22; sh, since Linux 2.6.34; tile, "
"since Linux 3.12)  Set unaligned access control bits to I<arg2>.  Pass "
"B<PR_UNALIGN_NOPRINT> to silently fix up unaligned user accesses, or "
"B<PR_UNALIGN_SIGBUS> to generate B<SIGBUS> on unaligned user access.  Alpha "
"also supports an additional flag with the value of 4 and no corresponding "
"named constant, which instructs kernel to not fix up unaligned accesses (it "
"is analogous to providing the B<UAC_NOFIX> flag in B<SSI_NVPAIRS> operation "
"of the B<setsysinfo>()  system call on Tru64)."
msgstr ""

#. type: TP
#: man-pages/man2/prctl.2:1377
#, no-wrap
msgid "B<PR_GET_UNALIGN>"
msgstr ""

#. type: Plain text
#: man-pages/man2/prctl.2:1384
msgid ""
"(See B<PR_SET_UNALIGN> for information on versions and architectures.)  "
"Return unaligned access control bits, in the location pointed to by "
"I<(unsigned int\\ *) arg2>."
msgstr ""

#. type: Plain text
#: man-pages/man2/prctl.2:1407
msgid ""
"On success, B<PR_GET_DUMPABLE>, B<PR_GET_FP_MODE>, B<PR_GET_KEEPCAPS>, "
"B<PR_GET_NO_NEW_PRIVS>, B<PR_GET_THP_DISABLE>, B<PR_CAPBSET_READ>, "
"B<PR_GET_TIMING>, B<PR_GET_TIMERSLACK>, B<PR_GET_SECUREBITS>, "
"B<PR_GET_SPECULATION_CTRL>, B<PR_MCE_KILL_GET>, "
"B<PR_CAP_AMBIENT>+B<PR_CAP_AMBIENT_IS_SET>, and (if it returns)  "
"B<PR_GET_SECCOMP> return the nonnegative values described above.  All other "
"I<option> values return 0 on success.  On error, -1 is returned, and "
"I<errno> is set appropriately."
msgstr ""

#. type: Plain text
#: man-pages/man2/prctl.2:1424
msgid ""
"I<option> is B<PR_SET_SECCOMP> and I<arg2> is B<SECCOMP_MODE_FILTER>, but "
"the process does not have the B<CAP_SYS_ADMIN> capability or has not set the "
"I<no_new_privs> attribute (see the discussion of B<PR_SET_NO_NEW_PRIVS> "
"above)."
msgstr ""

#. type: Plain text
#: man-pages/man2/prctl.2:1434
msgid ""
"I<option> is B<PR_SET_MM>, and I<arg3> is B<PR_SET_MM_EXE_FILE>, the file is "
"not executable."
msgstr ""

#. type: Plain text
#: man-pages/man2/prctl.2:1445
msgid ""
"I<option> is B<PR_SET_MM>, I<arg3> is B<PR_SET_MM_EXE_FILE>, and the file "
"descriptor passed in I<arg4> is not valid."
msgstr ""

#. type: Plain text
#: man-pages/man2/prctl.2:1456
msgid ""
"I<option> is B<PR_SET_MM>, I<arg3> is B<PR_SET_MM_EXE_FILE>, and this the "
"second attempt to change the I</proc/pid/exe> symbolic link, which is "
"prohibited."
msgstr ""

#. type: Plain text
#: man-pages/man2/prctl.2:1460
msgid "I<arg2> is an invalid address."
msgstr ""

#. type: Plain text
#: man-pages/man2/prctl.2:1473
msgid ""
"I<option> is B<PR_SET_SECCOMP>, I<arg2> is B<SECCOMP_MODE_FILTER>, the "
"system was built with B<CONFIG_SECCOMP_FILTER>, and I<arg3> is an invalid "
"address."
msgstr ""

#. type: Plain text
#: man-pages/man2/prctl.2:1478
msgid "The value of I<option> is not recognized."
msgstr ""

#. type: Plain text
#: man-pages/man2/prctl.2:1490
msgid ""
"I<option> is B<PR_MCE_KILL> or B<PR_MCE_KILL_GET> or B<PR_SET_MM>, and "
"unused B<prctl>()  arguments were not specified as zero."
msgstr ""

#. type: Plain text
#: man-pages/man2/prctl.2:1495
msgid "I<arg2> is not valid value for this I<option>."
msgstr ""

#. type: Plain text
#: man-pages/man2/prctl.2:1504
msgid ""
"I<option> is B<PR_SET_SECCOMP> or B<PR_GET_SECCOMP>, and the kernel was not "
"configured with B<CONFIG_SECCOMP>."
msgstr ""

#. type: Plain text
#: man-pages/man2/prctl.2:1514
msgid ""
"I<option> is B<PR_SET_SECCOMP>, I<arg2> is B<SECCOMP_MODE_FILTER>, and the "
"kernel was not configured with B<CONFIG_SECCOMP_FILTER>."
msgstr ""

#. type: Plain text
#: man-pages/man2/prctl.2:1520
msgid "I<option> is B<PR_SET_MM>, and one of the following is true"
msgstr ""

#. type: Plain text
#: man-pages/man2/prctl.2:1526
msgid "I<arg4> or I<arg5> is nonzero;"
msgstr ""

#. type: Plain text
#: man-pages/man2/prctl.2:1531
msgid ""
"I<arg3> is greater than B<TASK_SIZE> (the limit on the size of the user "
"address space for this architecture);"
msgstr ""

#. type: Plain text
#: man-pages/man2/prctl.2:1541
msgid ""
"I<arg2> is B<PR_SET_MM_START_CODE>, B<PR_SET_MM_END_CODE>, "
"B<PR_SET_MM_START_DATA>, B<PR_SET_MM_END_DATA>, or B<PR_SET_MM_START_STACK>, "
"and the permissions of the corresponding memory area are not as required;"
msgstr ""

#. type: Plain text
#: man-pages/man2/prctl.2:1553
msgid ""
"I<arg2> is B<PR_SET_MM_START_BRK> or B<PR_SET_MM_BRK>, and I<arg3> is less "
"than or equal to the end of the data segment or specifies a value that would "
"cause the B<RLIMIT_DATA> resource limit to be exceeded."
msgstr ""

#. type: Plain text
#: man-pages/man2/prctl.2:1564
msgid ""
"I<option> is B<PR_SET_PTRACER> and I<arg2> is not 0, B<PR_SET_PTRACER_ANY>, "
"or the PID of an existing process."
msgstr ""

#. type: Plain text
#: man-pages/man2/prctl.2:1572
msgid "I<option> is B<PR_SET_PDEATHSIG> and I<arg2> is not a valid signal number."
msgstr ""

#. type: Plain text
#: man-pages/man2/prctl.2:1583
msgid ""
"I<option> is B<PR_SET_DUMPABLE> and I<arg2> is neither B<SUID_DUMP_DISABLE> "
"nor B<SUID_DUMP_USER>."
msgstr ""

#. type: Plain text
#: man-pages/man2/prctl.2:1592
msgid "I<option> is B<PR_SET_TIMING> and I<arg2> is not B<PR_TIMING_STATISTICAL>."
msgstr ""

#. type: Plain text
#: man-pages/man2/prctl.2:1606
msgid ""
"I<option> is B<PR_SET_NO_NEW_PRIVS> and I<arg2> is not equal to 1 or "
"I<arg3>, I<arg4>, or I<arg5> is nonzero."
msgstr ""

#. type: Plain text
#: man-pages/man2/prctl.2:1618
msgid ""
"I<option> is B<PR_GET_NO_NEW_PRIVS> and I<arg2>, I<arg3>, I<arg4>, or "
"I<arg5> is nonzero."
msgstr ""

#. type: Plain text
#: man-pages/man2/prctl.2:1629
msgid ""
"I<option> is B<PR_SET_THP_DISABLE> and I<arg3>, I<arg4>, or I<arg5> is "
"nonzero."
msgstr ""

#. type: Plain text
#: man-pages/man2/prctl.2:1641
msgid ""
"I<option> is B<PR_GET_THP_DISABLE> and I<arg2>, I<arg3>, I<arg4>, or I<arg5> "
"is nonzero."
msgstr ""

#. type: Plain text
#: man-pages/man2/prctl.2:1666
msgid ""
"I<option> is B<PR_CAP_AMBIENT> and an unused argument (I<arg4>, I<arg5>, or, "
"in the case of B<PR_CAP_AMBIENT_CLEAR_ALL>, I<arg3>)  is nonzero; or I<arg2> "
"has an invalid value; or I<arg2> is B<PR_CAP_AMBIENT_LOWER>, "
"B<PR_CAP_AMBIENT_RAISE>, or B<PR_CAP_AMBIENT_IS_SET> and I<arg3> does not "
"specify a valid capability."
msgstr ""

#. type: Plain text
#: man-pages/man2/prctl.2:1676
msgid ""
"I<option> was B<PR_GET_SPECULATION_CTRL> or B<PR_SET_SPECULATION_CTRL> and "
"unused arguments to B<prctl>()  are not 0."
msgstr ""

#. type: Plain text
#: man-pages/man2/prctl.2:1682
msgid ""
"I<option> was B<PR_SET_SPECULATION_CTRL> the kernel or CPU does not support "
"the requested speculation misfeature."
msgstr ""

#. type: Plain text
#: man-pages/man2/prctl.2:1691
msgid ""
"I<option> was B<PR_MPX_ENABLE_MANAGEMENT> or B<PR_MPX_DISABLE_MANAGEMENT> "
"and the kernel or the CPU does not support MPX management.  Check that the "
"kernel and processor have MPX support."
msgstr ""

#. type: Plain text
#: man-pages/man2/prctl.2:1700
msgid ""
"I<option> was B<PR_SET_SPECULATION_CTRL> implies that the control of the "
"selected speculation misfeature is not possible.  See "
"B<PR_GET_SPECULATION_CTRL> for the bit fields to determine which option is "
"available."
msgstr ""

#. type: Plain text
#: man-pages/man2/prctl.2:1708
msgid ""
"I<option> is B<PR_SET_FP_MODE> and I<arg2> has an invalid or unsupported "
"value."
msgstr ""

#. type: Plain text
#: man-pages/man2/prctl.2:1720
msgid ""
"I<option> is B<PR_SET_SECUREBITS>, and the caller does not have the "
"B<CAP_SETPCAP> capability, or tried to unset a \"locked\" flag, or tried to "
"set a flag whose corresponding locked flag was set (see B<capabilities>(7))."
msgstr ""

#. type: Plain text
#: man-pages/man2/prctl.2:1728
msgid ""
"I<option> is B<PR_SET_SPECULATION_CTRL> wherein the speculation was disabled "
"with B<PR_SPEC_FORCE_DISABLE> and caller tried to enable it again."
msgstr ""

#. type: Plain text
#: man-pages/man2/prctl.2:1738
msgid ""
"I<option> is B<PR_SET_KEEPCAPS>, and the caller's B<SECBIT_KEEP_CAPS_LOCKED> "
"flag is set (see B<capabilities>(7))."
msgstr ""

#. type: Plain text
#: man-pages/man2/prctl.2:1746
msgid ""
"I<option> is B<PR_CAPBSET_DROP>, and the caller does not have the "
"B<CAP_SETPCAP> capability."
msgstr ""

#. type: Plain text
#: man-pages/man2/prctl.2:1754
msgid ""
"I<option> is B<PR_SET_MM>, and the caller does not have the "
"B<CAP_SYS_RESOURCE> capability."
msgstr ""

#. type: Plain text
#: man-pages/man2/prctl.2:1769
msgid ""
"I<option> is B<PR_CAP_AMBIENT> and I<arg2> is B<PR_CAP_AMBIENT_RAISE>, but "
"either the capability specified in I<arg3> is not present in the process's "
"permitted and inheritable capability sets, or the B<PR_CAP_AMBIENT_LOWER> "
"securebit has been set."
msgstr ""

#. type: Plain text
#: man-pages/man2/prctl.2:1781
msgid ""
"I<option> was B<PR_SET_SPECULATION_CTRL> and I<arg3> is neither "
"B<PR_SPEC_ENABLE>, B<PR_SPEC_DISABLE>, nor B<PR_SPEC_FORCE_DISABLE>."
msgstr ""

#.  The library interface was added in glibc 2.0.6
#. type: Plain text
#: man-pages/man2/prctl.2:1786
msgid "The B<prctl>()  system call was introduced in Linux 2.1.57."
msgstr ""

#. type: Plain text
#: man-pages/man2/prctl.2:1793
msgid ""
"This call is Linux-specific.  IRIX has a B<prctl>()  system call (also "
"introduced in Linux 2.1.44 as irix_prctl on the MIPS architecture), with "
"prototype"
msgstr ""

#. type: Plain text
#: man-pages/man2/prctl.2:1797
#, no-wrap
msgid "B<ptrdiff_t prctl(int >I<option>B<, int >I<arg2>B<, int >I<arg3>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/prctl.2:1804
msgid ""
"and options to get the maximum number of processes per user, get the maximum "
"number of processors the calling process can use, find out whether a "
"specified process is currently blocked, get or set the maximum stack size, "
"and so on."
msgstr ""

#. type: Plain text
#: man-pages/man2/prctl.2:1806
msgid "B<signal>(2), B<core>(5)"
msgstr ""

#. type: TH
#: man-pages/man2/getrusage.2:39
#, no-wrap
msgid "GETRUSAGE"
msgstr ""

#. type: Plain text
#: man-pages/man2/getrusage.2:42
msgid "getrusage - get resource usage"
msgstr ""

#. type: Plain text
#: man-pages/man2/getrusage.2:48
msgid "B<int getrusage(int >I<who>B<, struct rusage *>I<usage>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/getrusage.2:54
msgid ""
"B<getrusage>()  returns resource usage measures for I<who>, which can be one "
"of the following:"
msgstr ""

#. type: TP
#: man-pages/man2/getrusage.2:54
#, no-wrap
msgid "B<RUSAGE_SELF>"
msgstr ""

#. type: Plain text
#: man-pages/man2/getrusage.2:58
msgid ""
"Return resource usage statistics for the calling process, which is the sum "
"of resources used by all threads in the process."
msgstr ""

#. type: TP
#: man-pages/man2/getrusage.2:58
#, no-wrap
msgid "B<RUSAGE_CHILDREN>"
msgstr ""

#. type: Plain text
#: man-pages/man2/getrusage.2:65
msgid ""
"Return resource usage statistics for all children of the calling process "
"that have terminated and been waited for.  These statistics will include the "
"resources used by grandchildren, and further removed descendants, if all of "
"the intervening descendants waited on their terminated children."
msgstr ""

#. type: TP
#: man-pages/man2/getrusage.2:65
#, no-wrap
msgid "B<RUSAGE_THREAD> (since Linux 2.6.26)"
msgstr ""

#. type: Plain text
#: man-pages/man2/getrusage.2:75
msgid ""
"Return resource usage statistics for the calling thread.  The B<_GNU_SOURCE> "
"feature test macro must be defined (before including I<any> header file)  in "
"order to obtain the definition of this constant from "
"I<E<lt>sys/resource.hE<gt>>."
msgstr ""

#. type: Plain text
#: man-pages/man2/getrusage.2:79
msgid ""
"The resource usages are returned in the structure pointed to by I<usage>, "
"which has the following form:"
msgstr ""

#. type: Plain text
#: man-pages/man2/getrusage.2:100
#, no-wrap
msgid ""
"struct rusage {\n"
"    struct timeval ru_utime; /* user CPU time used */\n"
"    struct timeval ru_stime; /* system CPU time used */\n"
"    long   ru_maxrss;        /* maximum resident set size */\n"
"    long   ru_ixrss;         /* integral shared memory size */\n"
"    long   ru_idrss;         /* integral unshared data size */\n"
"    long   ru_isrss;         /* integral unshared stack size */\n"
"    long   ru_minflt;        /* page reclaims (soft page faults) */\n"
"    long   ru_majflt;        /* page faults (hard page faults) */\n"
"    long   ru_nswap;         /* swaps */\n"
"    long   ru_inblock;       /* block input operations */\n"
"    long   ru_oublock;       /* block output operations */\n"
"    long   ru_msgsnd;        /* IPC messages sent */\n"
"    long   ru_msgrcv;        /* IPC messages received */\n"
"    long   ru_nsignals;      /* signals received */\n"
"    long   ru_nvcsw;         /* voluntary context switches */\n"
"    long   ru_nivcsw;        /* involuntary context switches */\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/getrusage.2:108
msgid ""
"Not all fields are completed; unmaintained fields are set to zero by the "
"kernel.  (The unmaintained fields are provided for compatibility with other "
"systems, and because they may one day be supported on Linux.)  The fields "
"are interpreted as follows:"
msgstr ""

#. type: TP
#: man-pages/man2/getrusage.2:108
#, no-wrap
msgid "I<ru_utime>"
msgstr ""

#. type: Plain text
#: man-pages/man2/getrusage.2:114
msgid ""
"This is the total amount of time spent executing in user mode, expressed in "
"a I<timeval> structure (seconds plus microseconds)."
msgstr ""

#. type: TP
#: man-pages/man2/getrusage.2:114
#, no-wrap
msgid "I<ru_stime>"
msgstr ""

#. type: Plain text
#: man-pages/man2/getrusage.2:120
msgid ""
"This is the total amount of time spent executing in kernel mode, expressed "
"in a I<timeval> structure (seconds plus microseconds)."
msgstr ""

#. type: TP
#: man-pages/man2/getrusage.2:120
#, no-wrap
msgid "I<ru_maxrss> (since Linux 2.6.32)"
msgstr ""

#. type: Plain text
#: man-pages/man2/getrusage.2:127
msgid ""
"This is the maximum resident set size used (in kilobytes).  For "
"B<RUSAGE_CHILDREN>, this is the resident set size of the largest child, not "
"the maximum resident set size of the process tree."
msgstr ""

#. type: TP
#: man-pages/man2/getrusage.2:127
#, no-wrap
msgid "I<ru_ixrss> (unmaintained)"
msgstr ""

#.  On some systems, this field records the number of signals received.
#. type: Plain text
#: man-pages/man2/getrusage.2:133 man-pages/man2/getrusage.2:138
#: man-pages/man2/getrusage.2:143 man-pages/man2/getrusage.2:155
#: man-pages/man2/getrusage.2:167 man-pages/man2/getrusage.2:173
#: man-pages/man2/getrusage.2:177
msgid "This field is currently unused on Linux."
msgstr ""

#. type: TP
#: man-pages/man2/getrusage.2:133
#, no-wrap
msgid "I<ru_idrss> (unmaintained)"
msgstr ""

#. type: TP
#: man-pages/man2/getrusage.2:138
#, no-wrap
msgid "I<ru_isrss> (unmaintained)"
msgstr ""

#. type: TP
#: man-pages/man2/getrusage.2:143
#, no-wrap
msgid "I<ru_minflt>"
msgstr ""

#. type: Plain text
#: man-pages/man2/getrusage.2:148
msgid ""
"The number of page faults serviced without any I/O activity; here I/O "
"activity is avoided by ``reclaiming'' a page frame from the list of pages "
"awaiting reallocation."
msgstr ""

#. type: TP
#: man-pages/man2/getrusage.2:148
#, no-wrap
msgid "I<ru_majflt>"
msgstr ""

#. type: Plain text
#: man-pages/man2/getrusage.2:151
msgid "The number of page faults serviced that required I/O activity."
msgstr ""

#. type: TP
#: man-pages/man2/getrusage.2:151
#, no-wrap
msgid "I<ru_nswap> (unmaintained)"
msgstr ""

#. type: TP
#: man-pages/man2/getrusage.2:155
#, no-wrap
msgid "I<ru_inblock> (since Linux 2.6.22)"
msgstr ""

#. type: Plain text
#: man-pages/man2/getrusage.2:158
msgid "The number of times the filesystem had to perform input."
msgstr ""

#. type: TP
#: man-pages/man2/getrusage.2:158
#, no-wrap
msgid "I<ru_oublock> (since Linux 2.6.22)"
msgstr ""

#. type: Plain text
#: man-pages/man2/getrusage.2:161
msgid "The number of times the filesystem had to perform output."
msgstr ""

#. type: TP
#: man-pages/man2/getrusage.2:161
#, no-wrap
msgid "I<ru_msgsnd> (unmaintained)"
msgstr ""

#. type: TP
#: man-pages/man2/getrusage.2:167
#, no-wrap
msgid "I<ru_msgrcv> (unmaintained)"
msgstr ""

#. type: TP
#: man-pages/man2/getrusage.2:173
#, no-wrap
msgid "I<ru_nsignals> (unmaintained)"
msgstr ""

#. type: TP
#: man-pages/man2/getrusage.2:177
#, no-wrap
msgid "I<ru_nvcsw> (since Linux 2.6)"
msgstr ""

#. type: Plain text
#: man-pages/man2/getrusage.2:182
msgid ""
"The number of times a context switch resulted due to a process voluntarily "
"giving up the processor before its time slice was completed (usually to "
"await availability of a resource)."
msgstr ""

#. type: TP
#: man-pages/man2/getrusage.2:182
#, no-wrap
msgid "I<ru_nivcsw> (since Linux 2.6)"
msgstr ""

#. type: Plain text
#: man-pages/man2/getrusage.2:187
msgid ""
"The number of times a context switch resulted due to a higher priority "
"process becoming runnable or because the current process exceeded its time "
"slice."
msgstr ""

#. type: Plain text
#: man-pages/man2/getrusage.2:198
msgid "I<usage> points outside the accessible address space."
msgstr ""

#. type: Plain text
#: man-pages/man2/getrusage.2:202
msgid "I<who> is invalid."
msgstr ""

#. type: tbl table
#: man-pages/man2/getrusage.2:212
#, no-wrap
msgid "B<getrusage>()"
msgstr ""

#. type: Plain text
#: man-pages/man2/getrusage.2:223
msgid ""
"POSIX.1-2001, POSIX.1-2008, SVr4, 4.3BSD.  POSIX.1 specifies B<getrusage>(), "
"but specifies only the fields I<ru_utime> and I<ru_stime>."
msgstr ""

#. type: Plain text
#: man-pages/man2/getrusage.2:226
msgid "B<RUSAGE_THREAD> is Linux-specific."
msgstr ""

#. type: Plain text
#: man-pages/man2/getrusage.2:229
msgid "Resource usage metrics are preserved across an B<execve>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/getrusage.2:237
msgid ""
"Including I<E<lt>sys/time.hE<gt>> is not required these days, but increases "
"portability.  (Indeed, I<struct timeval> is defined in "
"I<E<lt>sys/time.hE<gt>>.)"
msgstr ""

#.  See the description of getrusage() in XSH.
#.  A similar statement was also in SUSv2.
#. type: Plain text
#: man-pages/man2/getrusage.2:249
msgid ""
"In Linux kernel versions before 2.6.9, if the disposition of B<SIGCHLD> is "
"set to B<SIG_IGN> then the resource usages of child processes are "
"automatically included in the value returned by B<RUSAGE_CHILDREN>, although "
"POSIX.1-2001 explicitly prohibits this.  This nonconformance is rectified in "
"Linux 2.6.9 and later."
msgstr ""

#. type: Plain text
#: man-pages/man2/getrusage.2:252
msgid ""
"The structure definition shown at the start of this page was taken from "
"4.3BSD Reno."
msgstr ""

#. type: Plain text
#: man-pages/man2/getrusage.2:261
msgid ""
"Ancient systems provided a B<vtimes>()  function with a similar purpose to "
"B<getrusage>().  For backward compatibility, glibc also provides "
"B<vtimes>().  All new applications should be written using B<getrusage>()."
msgstr ""

#. type: Plain text
#: man-pages/man2/getrusage.2:266
msgid "See also the description of I</proc/[pid]/stat> in B<proc>(5)."
msgstr ""

#. type: Plain text
#: man-pages/man2/getrusage.2:272
msgid ""
"B<clock_gettime>(2), B<getrlimit>(2), B<times>(2), B<wait>(2), B<wait4>(2), "
"B<clock>(3)"
msgstr ""

#. type: TH
#: man-pages/man2/inotify_rm_watch.2:27
#, no-wrap
msgid "INOTIFY_RM_WATCH"
msgstr ""

#. type: Plain text
#: man-pages/man2/inotify_rm_watch.2:30
msgid "inotify_rm_watch - remove an existing watch from an inotify instance"
msgstr ""

#. type: Plain text
#: man-pages/man2/inotify_rm_watch.2:32 man-pages/man2/inotify_add_watch.2:33
msgid "B<#include E<lt>sys/inotify.hE<gt>>"
msgstr ""

#.  Before glibc 2.10, the second argument was types as uint32_t.
#.  http://sources.redhat.com/bugzilla/show_bug.cgi?id=7040
#. type: Plain text
#: man-pages/man2/inotify_rm_watch.2:36
msgid "B<int inotify_rm_watch(int >I<fd>B<, int >I<wd>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/inotify_rm_watch.2:42
msgid ""
"B<inotify_rm_watch>()  removes the watch associated with the watch "
"descriptor I<wd> from the inotify instance associated with the file "
"descriptor I<fd>."
msgstr ""

#. type: Plain text
#: man-pages/man2/inotify_rm_watch.2:48
msgid ""
"Removing a watch causes an B<IN_IGNORED> event to be generated for this "
"watch descriptor.  (See B<inotify>(7).)"
msgstr ""

#. type: Plain text
#: man-pages/man2/inotify_rm_watch.2:55
msgid ""
"On success, B<inotify_rm_watch>()  returns zero.  On error, -1 is returned "
"and I<errno> is set to indicate the cause of the error."
msgstr ""

#. type: Plain text
#: man-pages/man2/inotify_rm_watch.2:67
msgid ""
"The watch descriptor I<wd> is not valid; or I<fd> is not an inotify file "
"descriptor."
msgstr ""

#. type: Plain text
#: man-pages/man2/inotify_rm_watch.2:69 man-pages/man2/inotify_add_watch.2:141
msgid "Inotify was merged into the 2.6.13 Linux kernel."
msgstr ""

#. type: Plain text
#: man-pages/man2/inotify_rm_watch.2:74
msgid "B<inotify_add_watch>(2), B<inotify_init>(2), B<inotify>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/seteuid.2:29
#, no-wrap
msgid "SETEUID"
msgstr ""

#. type: Plain text
#: man-pages/man2/seteuid.2:32
msgid "seteuid, setegid - set effective user or group ID"
msgstr ""

#. type: Plain text
#: man-pages/man2/seteuid.2:38
msgid "B<int seteuid(uid_t >I<euid>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/seteuid.2:40
msgid "B<int setegid(gid_t >I<egid>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/seteuid.2:49
msgid "B<seteuid>(), B<setegid>():"
msgstr ""

#. type: Plain text
#: man-pages/man2/seteuid.2:52
#, no-wrap
msgid ""
"_POSIX_C_SOURCE\\ E<gt>=\\ 200112L\n"
"    || /* Glibc versions E<lt>= 2.19: */ _BSD_SOURCE\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/seteuid.2:59
msgid ""
"B<seteuid>()  sets the effective user ID of the calling process.  "
"Unprivileged processes may only set the effective user ID to the real user "
"ID, the effective user ID or the saved set-user-ID."
msgstr ""

#.  When
#.  .I euid
#.  equals \-1, nothing is changed.
#.  (This is an artifact of the implementation in glibc of seteuid()
#.  using setresuid(2).)
#. type: Plain text
#: man-pages/man2/seteuid.2:68
msgid ""
"Precisely the same holds for B<setegid>()  with \"group\" instead of "
"\"user\"."
msgstr ""

#. type: Plain text
#: man-pages/man2/seteuid.2:80
msgid ""
"I<Note>: there are cases where B<seteuid>()  can fail even when the caller "
"is UID 0; it is a grave security error to omit checking for a failure return "
"from B<seteuid>()."
msgstr ""

#. type: Plain text
#: man-pages/man2/seteuid.2:84
msgid "The target user or group ID is not valid in this user namespace."
msgstr ""

#. type: Plain text
#: man-pages/man2/seteuid.2:94
msgid ""
"In the case of B<seteuid>(): the calling process is not privileged (does not "
"have the B<CAP_SETUID> capability in its user namespace) and I<euid> does "
"not match the current real user ID, current effective user ID, or current "
"saved set-user-ID."
msgstr ""

#. type: Plain text
#: man-pages/man2/seteuid.2:103
msgid ""
"In the case of B<setegid>(): the calling process is not privileged (does not "
"have the B<CAP_SETGID> capability in its user namespace) and I<egid> does "
"not match the current real group ID, current effective group ID, or current "
"saved set-group-ID."
msgstr ""

#. type: Plain text
#: man-pages/man2/seteuid.2:105 man-pages/man2/getuid.2:47
#: man-pages/man2/getgid.2:46 man-pages/man2/fsync.2:154
msgid "POSIX.1-2001, POSIX.1-2008, 4.3BSD."
msgstr ""

#. type: Plain text
#: man-pages/man2/seteuid.2:111
msgid ""
"Setting the effective user (group) ID to the saved set-user-ID (saved "
"set-group-ID) is possible since Linux 1.1.37 (1.1.38).  On an arbitrary "
"system one should check B<_POSIX_SAVED_IDS>."
msgstr ""

#. type: Plain text
#: man-pages/man2/seteuid.2:127
msgid ""
"Under glibc 2.0, B<seteuid(>I<euid>B<)> is equivalent to B<setreuid(-1,>I< "
"euid>B<)> and hence may change the saved set-user-ID.  Under glibc 2.1 and "
"later, it is equivalent to B<setresuid(-1,>I< euid>B<, -1)> and hence does "
"not change the saved set-user-ID.  Analogous remarks hold for B<setegid>(), "
"with the difference that the change in implementation from B<setregid(-1,>I< "
"egid>B<)> to B<setresgid(-1,>I< egid>B<, -1)> occurred in glibc 2.2 or 2.3 "
"(depending on the hardware architecture)."
msgstr ""

#. type: Plain text
#: man-pages/man2/seteuid.2:136
msgid ""
"According to POSIX.1, B<seteuid>()  (B<setegid>())  need not permit I<euid> "
"(I<egid>)  to be the same value as the current effective user (group) ID, "
"and some implementations do not permit this."
msgstr ""

#. type: Plain text
#: man-pages/man2/seteuid.2:145
msgid ""
"On Linux, B<seteuid>()  and B<setegid>()  are implemented as library "
"functions that call, respectively, B<setreuid>(2)  and B<setregid>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/seteuid.2:152
msgid ""
"B<geteuid>(2), B<setresuid>(2), B<setreuid>(2), B<setuid>(2), "
"B<capabilities>(7), B<credentials>(7), B<user_namespaces>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/set_thread_area.2:9
#, no-wrap
msgid "SET_THREAD_AREA"
msgstr ""

#. type: Plain text
#: man-pages/man2/set_thread_area.2:12
msgid ""
"get_thread_area, set_thread_area - manipulate thread-local storage "
"information"
msgstr ""

#. type: Plain text
#: man-pages/man2/set_thread_area.2:18
#, no-wrap
msgid ""
"B<#if defined __i386__ || defined __x86_64__>\n"
"B<# include E<lt>asm/ldt.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/set_thread_area.2:21
#, no-wrap
msgid ""
"B<int get_thread_area(struct user_desc *>I<u_info>B<);>\n"
"B<int set_thread_area(struct user_desc *>I<u_info>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/set_thread_area.2:23
#, no-wrap
msgid "B<#elif defined __m68k__>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/set_thread_area.2:26
#, no-wrap
msgid ""
"B<int get_thread_area(void);>\n"
"B<int set_thread_area(unsigned long >I<tp>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/set_thread_area.2:28
#, no-wrap
msgid "B<#elif defined __mips__>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/set_thread_area.2:30
#, no-wrap
msgid "B<int set_thread_area(unsigned long >I<addr>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/set_thread_area.2:32
#, no-wrap
msgid "B<#endif>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/set_thread_area.2:44
msgid ""
"These calls provide architecture-specific support for a thread-local storage "
"implementation.  At the moment, B<set_thread_area>()  is available on m68k, "
"MIPS, and x86 (both 32-bit and 64-bit variants); B<get_thread_area>()  is "
"available on m68k and x86."
msgstr ""

#. type: Plain text
#: man-pages/man2/set_thread_area.2:57
msgid ""
"On m68k and MIPS, B<set_thread_area>()  allows storing an arbitrary pointer "
"(provided in the B<tp> argument on m68k and in the B<addr> argument on MIPS)  "
"in the kernel data structure associated with the calling thread; this "
"pointer can later be retrieved using B<get_thread_area>()  (see also NOTES "
"for information regarding obtaining the thread pointer on MIPS)."
msgstr ""

#. type: Plain text
#: man-pages/man2/set_thread_area.2:62
msgid ""
"On x86, Linux dedicates three global descriptor table (GDT) entries for "
"thread-local storage.  For more information about the GDT, see the Intel "
"Software Developer's Manual or the AMD Architecture Programming Manual."
msgstr ""

#. type: Plain text
#: man-pages/man2/set_thread_area.2:65
msgid ""
"Both of these system calls take an argument that is a pointer to a structure "
"of the following type:"
msgstr ""

#. type: Plain text
#: man-pages/man2/set_thread_area.2:82
#, no-wrap
msgid ""
"struct user_desc {\n"
"    unsigned int  entry_number;\n"
"    unsigned long base_addr;\n"
"    unsigned int  limit;\n"
"    unsigned int  seg_32bit:1;\n"
"    unsigned int  contents:2;\n"
"    unsigned int  read_exec_only:1;\n"
"    unsigned int  limit_in_pages:1;\n"
"    unsigned int  seg_not_present:1;\n"
"    unsigned int  useable:1;\n"
"#ifdef __x86_64__\n"
"    unsigned int  lm:1;\n"
"#endif\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/set_thread_area.2:90
msgid ""
"B<get_thread_area>()  reads the GDT entry indicated by "
"I<u_info-E<gt>entry_number> and fills in the rest of the fields in "
"I<u_info>."
msgstr ""

#. type: Plain text
#: man-pages/man2/set_thread_area.2:93
msgid "B<set_thread_area>()  sets a TLS entry in the GDT."
msgstr ""

#. type: Plain text
#: man-pages/man2/set_thread_area.2:104
msgid ""
"The TLS array entry set by B<set_thread_area>()  corresponds to the value of "
"I<u_info-E<gt>entry_number> passed in by the user.  If this value is in "
"bounds, B<set_thread_area>()  writes the TLS descriptor pointed to by "
"I<u_info> into the thread's TLS array."
msgstr ""

#. type: Plain text
#: man-pages/man2/set_thread_area.2:115
msgid ""
"When B<set_thread_area>()  is passed an I<entry_number> of -1, it searches "
"for a free TLS entry.  If B<set_thread_area>()  finds a free TLS entry, the "
"value of I<u_info-E<gt>entry_number> is set upon return to show which entry "
"was changed."
msgstr ""

#. type: Plain text
#: man-pages/man2/set_thread_area.2:127
msgid ""
"A I<user_desc> is considered \"empty\" if I<read_exec_only> and "
"I<seg_not_present> are set to 1 and all of the other fields are 0.  If an "
"\"empty\" descriptor is passed to B<set_thread_area>(), the corresponding "
"TLS entry will be cleared.  See BUGS for additional details."
msgstr ""

#. type: Plain text
#: man-pages/man2/set_thread_area.2:132
msgid ""
"Since Linux 3.19, B<set_thread_area>()  cannot be used to write non-present "
"segments, 16-bit segments, or code segments, although clearing a segment is "
"still acceptable."
msgstr ""

#. type: Plain text
#: man-pages/man2/set_thread_area.2:137
msgid ""
"On x86, these system calls return 0 on success, and -1 on failure, with "
"I<errno> set appropriately."
msgstr ""

#. type: Plain text
#: man-pages/man2/set_thread_area.2:146
msgid ""
"On MIPS and m68k, B<set_thread_area>()  always returns 0.  On m68k, "
"B<get_thread_area>()  returns the thread area pointer value (previously set "
"via B<set_thread_area>())."
msgstr ""

#. type: Plain text
#: man-pages/man2/set_thread_area.2:150
msgid "I<u_info> is an invalid pointer."
msgstr ""

#. type: Plain text
#: man-pages/man2/set_thread_area.2:153
msgid "I<u_info-E<gt>entry_number> is out of bounds."
msgstr ""

#. type: Plain text
#: man-pages/man2/set_thread_area.2:159
msgid ""
"B<get_thread_area>()  or B<set_thread_area>()  was invoked as a 64-bit "
"system call."
msgstr ""

#. type: Plain text
#: man-pages/man2/set_thread_area.2:163
msgid "(B<set_thread_area>())  A free TLS entry could not be located."
msgstr ""

#. type: Plain text
#: man-pages/man2/set_thread_area.2:168
msgid ""
"B<set_thread_area>()  first appeared in Linux 2.5.29.  B<get_thread_area>()  "
"first appeared in Linux 2.5.32."
msgstr ""

#. type: Plain text
#: man-pages/man2/set_thread_area.2:174
msgid ""
"B<set_thread_area>()  and B<get_thread_area>()  are Linux-specific and "
"should not be used in programs that are intended to be portable."
msgstr ""

#. type: Plain text
#: man-pages/man2/set_thread_area.2:179
msgid ""
"Glibc does not provide wrappers for these system calls, since they are "
"generally intended for use only by threading libraries.  In the unlikely "
"event that you want to call them directly, use B<syscall>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/set_thread_area.2:190
msgid ""
"B<arch_prctl>(2)  can interfere with B<set_thread_area>()  on x86.  See "
"B<arch_prctl>(2)  for more details.  This is not normally a problem, as "
"B<arch_prctl>(2)  is normally used only by 64-bit programs."
msgstr ""

#. type: Plain text
#: man-pages/man2/set_thread_area.2:193
msgid ""
"On MIPS, the current value of the thread area pointer can be obtained using "
"the instruction:"
msgstr ""

#. type: Plain text
#: man-pages/man2/set_thread_area.2:197
#, no-wrap
msgid "rdhwr dest, $29\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/set_thread_area.2:201
msgid "This instruction traps and is handled by kernel."
msgstr ""

#.  commit e30ab185c490e9a9381385529e0fd32f0a399495
#. type: Plain text
#: man-pages/man2/set_thread_area.2:223
msgid ""
"On 64-bit kernels before Linux 3.19, one of the padding bits in "
"I<user_desc>, if set, would prevent the descriptor from being considered "
"empty (see B<modify_ldt>(2)).  As a result, the only reliable way to clear a "
"TLS entry is to use B<memset>(3)  to zero the entire I<user_desc> structure, "
"including padding bits, and then to set the I<read_exec_only> and "
"I<seg_not_present> bits.  On Linux 3.19, a I<user_desc> consisting entirely "
"of zeros except for I<entry_number> will also be interpreted as a request to "
"clear a TLS entry, but this behaved differently on older kernels."
msgstr ""

#. type: Plain text
#: man-pages/man2/set_thread_area.2:226
msgid ""
"Prior to Linux 3.19, the DS and ES segment registers must not reference TLS "
"entries."
msgstr ""

#. type: Plain text
#: man-pages/man2/set_thread_area.2:230
msgid ""
"B<arch_prctl>(2), B<modify_ldt>(2), B<ptrace>(2)  (B<PTRACE_GET_THREAD_AREA> "
"and B<PTRACE_SET_THREAD_AREA>)"
msgstr ""

#. type: TH
#: man-pages/man2/semget.2:36
#, no-wrap
msgid "SEMGET"
msgstr ""

#. type: Plain text
#: man-pages/man2/semget.2:39
msgid "semget - get a System V semaphore set identifier"
msgstr ""

#. type: Plain text
#: man-pages/man2/semget.2:44 man-pages/man2/semctl.2:50
#: man-pages/man2/semop.2:43
#, no-wrap
msgid ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>sys/ipc.hE<gt>>\n"
"B<#include E<lt>sys/sem.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/semget.2:49
msgid "B<int semget(key_t >I<key>B<,> B<int >I<nsems>B<,> B<int >I<semflg>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/semget.2:63
msgid ""
"The B<semget>()  system call returns the System\\ V semaphore set identifier "
"associated with the argument I<key>.  It may be used either to obtain the "
"identifier of a previously created semaphore set (when I<semflg> is zero and "
"I<key> does not have the value B<IPC_PRIVATE>), or to create a new set."
msgstr ""

#. type: Plain text
#: man-pages/man2/semget.2:76
msgid ""
"A new set of I<nsems> semaphores is created if I<key> has the value "
"B<IPC_PRIVATE> or if no existing semaphore set is associated with I<key> and "
"B<IPC_CREAT> is specified in I<semflg>."
msgstr ""

#. type: Plain text
#: man-pages/man2/semget.2:95
msgid ""
"If I<semflg> specifies both B<IPC_CREAT> and B<IPC_EXCL> and a semaphore set "
"already exists for I<key>, then B<semget>()  fails with I<errno> set to "
"B<EEXIST>.  (This is analogous to the effect of the combination B<O_CREAT | "
"O_EXCL> for B<open>(2).)"
msgstr ""

#. type: Plain text
#: man-pages/man2/semget.2:108
msgid ""
"Upon creation, the least significant 9 bits of the argument I<semflg> define "
"the permissions (for owner, group and others)  for the semaphore set.  These "
"bits have the same format, and the same meaning, as the I<mode> argument of "
"B<open>(2)  (though the execute permissions are not meaningful for "
"semaphores, and write permissions mean permission to alter semaphore "
"values)."
msgstr ""

#. type: Plain text
#: man-pages/man2/semget.2:116
msgid ""
"When creating a new semaphore set, B<semget>()  initializes the set's "
"associated data structure, I<semid_ds> (see B<semctl>(2)), as follows:"
msgstr ""

#. type: Plain text
#: man-pages/man2/semget.2:121
msgid ""
"I<sem_perm.cuid> and I<sem_perm.uid> are set to the effective user ID of the "
"calling process."
msgstr ""

#. type: Plain text
#: man-pages/man2/semget.2:126
msgid ""
"I<sem_perm.cgid> and I<sem_perm.gid> are set to the effective group ID of "
"the calling process."
msgstr ""

#. type: Plain text
#: man-pages/man2/semget.2:131
msgid ""
"The least significant 9 bits of I<sem_perm.mode> are set to the least "
"significant 9 bits of I<semflg>."
msgstr ""

#. type: Plain text
#: man-pages/man2/semget.2:135
msgid "I<sem_nsems> is set to the value of I<nsems>."
msgstr ""

#. type: Plain text
#: man-pages/man2/semget.2:138
msgid "I<sem_otime> is set to 0."
msgstr ""

#. type: Plain text
#: man-pages/man2/semget.2:141
msgid "I<sem_ctime> is set to the current time."
msgstr ""

#. type: Plain text
#: man-pages/man2/semget.2:152
msgid ""
"The argument I<nsems> can be 0 (a don't care)  when a semaphore set is not "
"being created.  Otherwise, I<nsems> must be greater than 0 and less than or "
"equal to the maximum number of semaphores per semaphore set (B<SEMMSL>)."
msgstr ""

#.  and a check is made to see if it is marked for destruction.
#. type: Plain text
#: man-pages/man2/semget.2:156
msgid "If the semaphore set already exists, the permissions are verified."
msgstr ""

#. type: Plain text
#: man-pages/man2/semget.2:162
msgid ""
"If successful, the return value will be the semaphore set identifier (a "
"nonnegative integer), otherwise, -1 is returned, with I<errno> indicating "
"the error."
msgstr ""

#. type: Plain text
#: man-pages/man2/semget.2:166 man-pages/man2/semctl.2:408
msgid "On failure, I<errno> will be set to one of the following:"
msgstr ""

#. type: Plain text
#: man-pages/man2/semget.2:174
msgid ""
"A semaphore set exists for I<key>, but the calling process does not have "
"permission to access the set, and does not have the B<CAP_IPC_OWNER> "
"capability in the user namespace that governs its IPC namespace."
msgstr ""

#.  .TP
#.  .B EIDRM
#.  The semaphore set is marked to be deleted.
#. type: Plain text
#: man-pages/man2/semget.2:186
msgid ""
"B<IPC_CREAT> and B<IPC_EXCL> were specified in I<semflg>, but a semaphore "
"set already exists for I<key>."
msgstr ""

#. type: Plain text
#: man-pages/man2/semget.2:192
msgid ""
"I<nsems> is less than 0 or greater than the limit on the number of "
"semaphores per semaphore set (B<SEMMSL>)."
msgstr ""

#. type: Plain text
#: man-pages/man2/semget.2:199
msgid ""
"A semaphore set corresponding to I<key> already exists, but I<nsems> is "
"larger than the number of semaphores in that set."
msgstr ""

#. type: Plain text
#: man-pages/man2/semget.2:207
msgid ""
"No semaphore set exists for I<key> and I<semflg> did not specify "
"B<IPC_CREAT>."
msgstr ""

#. type: Plain text
#: man-pages/man2/semget.2:211
msgid ""
"A semaphore set has to be created but the system does not have enough memory "
"for the new data structure."
msgstr ""

#. type: Plain text
#: man-pages/man2/semget.2:219
msgid ""
"A semaphore set has to be created but the system limit for the maximum "
"number of semaphore sets (B<SEMMNI>), or the system wide maximum number of "
"semaphores (B<SEMMNS>), would be exceeded."
msgstr ""

#.  SVr4 documents additional error conditions EFBIG, E2BIG, EAGAIN,
#.  ERANGE, EFAULT.
#. type: Plain text
#: man-pages/man2/semget.2:223
msgid "SVr4, POSIX.1-2001."
msgstr ""

#. type: Plain text
#: man-pages/man2/semget.2:247
msgid ""
"B<IPC_PRIVATE> isn't a flag field but a I<key_t> type.  If this special "
"value is used for I<key>, the system call ignores all but the least "
"significant 9 bits of I<semflg> and creates a new semaphore set (on "
"success)."
msgstr ""

#. type: SS
#: man-pages/man2/semget.2:247
#, no-wrap
msgid "Semaphore initialization"
msgstr ""

#.  In truth, every one of the many implementations that I've tested sets
#.  the values to zero, but I suppose there is/was some obscure
#.  implementation out there that does not.
#. type: Plain text
#: man-pages/man2/semget.2:259
msgid ""
"The values of the semaphores in a newly created set are indeterminate.  "
"(POSIX.1-2001 and POSIX.1-2008 are explicit on this point, although "
"POSIX.1-2008 notes that a future version of the standard may require an "
"implementation to initialize the semaphores to 0.)  Although Linux, like "
"many other implementations, initializes the semaphore values to 0, a "
"portable application cannot rely on this: it should explicitly initialize "
"the semaphores to the desired values."
msgstr ""

#. type: Plain text
#: man-pages/man2/semget.2:274
msgid ""
"Initialization can be done using B<semctl>(2)  B<SETVAL> or B<SETALL> "
"operation.  Where multiple peers do not know who will be the first to "
"initialize the set, checking for a nonzero I<sem_otime> in the associated "
"data structure retrieved by a B<semctl>(2)  B<IPC_STAT> operation can be "
"used to avoid races."
msgstr ""

#. type: SS
#: man-pages/man2/semget.2:274 man-pages/man2/semop.2:454
#, no-wrap
msgid "Semaphore limits"
msgstr ""

#. type: Plain text
#: man-pages/man2/semget.2:278
msgid ""
"The following limits on semaphore set resources affect the B<semget>()  "
"call:"
msgstr ""

#. type: TP
#: man-pages/man2/semget.2:278
#, no-wrap
msgid "B<SEMMNI>"
msgstr ""

#.  commit e843e7d2c88b7db107a86bd2c7145dc715c058f4
#.  This /proc file is not available in Linux 2.2 and earlier -- MTK
#. type: Plain text
#: man-pages/man2/semget.2:289
msgid ""
"System-wide limit on the number of semaphore sets.  On Linux systems before "
"version 3.19, the default value for this limit was 128.  Since Linux 3.19, "
"the default value is 32,000.  On Linux, this limit can be read and modified "
"via the fourth field of I</proc/sys/kernel/sem>."
msgstr ""

#. type: TP
#: man-pages/man2/semget.2:289
#, no-wrap
msgid "B<SEMMSL>"
msgstr ""

#.  commit e843e7d2c88b7db107a86bd2c7145dc715c058f4
#. type: Plain text
#: man-pages/man2/semget.2:299
msgid ""
"Maximum number of semaphores per semaphore ID.  On Linux systems before "
"version 3.19, the default value for this limit was 250.  Since Linux 3.19, "
"the default value is 32,000.  On Linux, this limit can be read and modified "
"via the first field of I</proc/sys/kernel/sem>."
msgstr ""

#. type: TP
#: man-pages/man2/semget.2:299
#, no-wrap
msgid "B<SEMMNS>"
msgstr ""

#. type: Plain text
#: man-pages/man2/semget.2:309
msgid ""
"System-wide limit on the number of semaphores: policy dependent (on Linux, "
"this limit can be read and modified via the second field of "
"I</proc/sys/kernel/sem>).  Note that the number of semaphores system-wide is "
"also limited by the product of B<SEMMSL> and B<SEMMNI>."
msgstr ""

#. type: Plain text
#: man-pages/man2/semget.2:321
msgid ""
"B<semctl>(2), B<semop>(2), B<ftok>(3), B<capabilities>(7), "
"B<sem_overview>(7), B<sysvipc>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/pipe.2:36
#, no-wrap
msgid "PIPE"
msgstr ""

#. type: Plain text
#: man-pages/man2/pipe.2:39
msgid "pipe, pipe2 - create pipe"
msgstr ""

#. type: Plain text
#: man-pages/man2/pipe.2:48
#, no-wrap
msgid ""
"/* On Alpha, IA-64, MIPS, SuperH, and SPARC/SPARC64; see NOTES */\n"
"B<struct fd_pair {>\n"
"B<long fd[2];>\n"
"B<};>\n"
"B<struct fd_pair pipe();>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/pipe.2:51
#, no-wrap
msgid ""
"/* On all other architectures */\n"
"B<int pipe(int >I<pipefd>B<[2]);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/pipe.2:55 man-pages/man2/dup.2:50
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>             /* See feature_test_macros(7) */\n"
"B<#include E<lt>fcntl.hE<gt>>              /* Obtain O_* constant "
"definitions */\n"
"B<#include E<lt>unistd.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/pipe.2:57
#, no-wrap
msgid "B<int pipe2(int >I<pipefd>B<[2], int >I<flags>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/pipe.2:73
msgid ""
"B<pipe>()  creates a pipe, a unidirectional data channel that can be used "
"for interprocess communication.  The array I<pipefd> is used to return two "
"file descriptors referring to the ends of the pipe.  I<pipefd[0]> refers to "
"the read end of the pipe.  I<pipefd[1]> refers to the write end of the "
"pipe.  Data written to the write end of the pipe is buffered by the kernel "
"until it is read from the read end of the pipe.  For further details, see "
"B<pipe>(7)."
msgstr ""

#. type: Plain text
#: man-pages/man2/pipe.2:83
msgid ""
"If I<flags> is 0, then B<pipe2>()  is the same as B<pipe>().  The following "
"values can be bitwise ORed in I<flags> to obtain different behavior:"
msgstr ""

#. type: TP
#: man-pages/man2/pipe.2:83 man-pages/man2/userfaultfd.2:61
#, no-wrap
msgid "B<O_CLOEXEC>"
msgstr ""

#. type: Plain text
#: man-pages/man2/pipe.2:91
msgid ""
"Set the close-on-exec (B<FD_CLOEXEC>)  flag on the two new file "
"descriptors.  See the description of the same flag in B<open>(2)  for "
"reasons why this may be useful."
msgstr ""

#. type: TP
#: man-pages/man2/pipe.2:91
#, no-wrap
msgid "B<O_DIRECT> (since Linux 3.4)"
msgstr ""

#.  commit 9883035ae7edef3ec62ad215611cb8e17d6a1a5d
#. type: Plain text
#: man-pages/man2/pipe.2:101
msgid ""
"Create a pipe that performs I/O in \"packet\" mode.  Each B<write>(2)  to "
"the pipe is dealt with as a separate packet, and B<read>(2)s from the pipe "
"will read one packet at a time.  Note the following points:"
msgstr ""

#. type: Plain text
#: man-pages/man2/pipe.2:112
msgid ""
"Writes of greater than B<PIPE_BUF> bytes (see B<pipe>(7))  will be split "
"into multiple packets.  The constant B<PIPE_BUF> is defined in "
"I<E<lt>limits.hE<gt>>."
msgstr ""

#. type: Plain text
#: man-pages/man2/pipe.2:122
msgid ""
"If a B<read>(2)  specifies a buffer size that is smaller than the next "
"packet, then the requested number of bytes are read, and the excess bytes in "
"the packet are discarded.  Specifying a buffer size of B<PIPE_BUF> will be "
"sufficient to read the largest possible packets (see the previous point)."
msgstr ""

#. type: Plain text
#: man-pages/man2/pipe.2:127
msgid ""
"Zero-length packets are not supported.  (A B<read>(2)  that specifies a "
"buffer size of zero is a no-op, and returns 0.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/pipe.2:132
msgid ""
"Older kernels that do not support this flag will indicate this via an "
"B<EINVAL> error."
msgstr ""

#.  commit 0dbf5f20652108106cb822ad7662c786baaa03ff
#.  FIXME . But, it is not possible to specify O_DIRECT when opening a FIFO
#. type: Plain text
#: man-pages/man2/pipe.2:140
msgid ""
"Since Linux 4.5, it is possible to change the B<O_DIRECT> setting of a pipe "
"file descriptor using B<fcntl>(2)."
msgstr ""

#. type: TP
#: man-pages/man2/pipe.2:140 man-pages/man2/userfaultfd.2:68
#, no-wrap
msgid "B<O_NONBLOCK>"
msgstr ""

#. type: Plain text
#: man-pages/man2/pipe.2:149
msgid ""
"Set the B<O_NONBLOCK> file status flag on the open file descriptions "
"referred to by the new file descriptors.  Using this flag saves extra calls "
"to B<fcntl>(2)  to achieve the same result."
msgstr ""

#. type: Plain text
#: man-pages/man2/pipe.2:156
msgid ""
"On success, zero is returned.  On error, -1 is returned, I<errno> is set "
"appropriately, and I<pipefd> is left unchanged."
msgstr ""

#.  http://austingroupbugs.net/view.php?id=467
#. type: Plain text
#: man-pages/man2/pipe.2:170
msgid ""
"On Linux (and other systems), B<pipe>()  does not modify I<pipefd> on "
"failure.  A requirement standardizing this behavior was added in "
"POSIX.1-2016.  The Linux-specific B<pipe2>()  system call likewise does not "
"modify I<pipefd> on failure."
msgstr ""

#. type: Plain text
#: man-pages/man2/pipe.2:175
msgid "I<pipefd> is not valid."
msgstr ""

#. type: Plain text
#: man-pages/man2/pipe.2:180
msgid "(B<pipe2>())  Invalid value in I<flags>."
msgstr ""

#. type: Plain text
#: man-pages/man2/pipe.2:191
msgid ""
"The user hard limit on memory that can be allocated for pipes has been "
"reached and the caller is not privileged; see B<pipe>(7)."
msgstr ""

#. type: Plain text
#: man-pages/man2/pipe.2:196
msgid ""
"B<pipe2>()  was added to Linux in version 2.6.27; glibc support is available "
"starting with version 2.9."
msgstr ""

#.  See http://math-atlas.sourceforge.net/devel/assembly/64.psabi.1.33.ps.Z
#.  for example, section 3.2.1 "Registers and the Stack Frame".
#. type: Plain text
#: man-pages/man2/pipe.2:213
msgid ""
"The SystemV ABI on some architectures allows the use of more than one "
"register for returning multiple values; several architectures (namely, "
"Alpha, IA-64, MIPS, SuperH, and SPARC/SPARC64)  (ab)use this feature in "
"order to implement the B<pipe>()  system call in a functional manner: the "
"call doesn't take any arguments and returns a pair of file descriptors as "
"the return value on success.  The glibc B<pipe>()  wrapper function "
"transparently deals with this.  See B<syscall>(2)  for information regarding "
"registers used for storing second file descriptor."
msgstr ""

#. type: Plain text
#: man-pages/man2/pipe.2:216
msgid "B<pipe>(): POSIX.1-2001, POSIX.1-2008."
msgstr ""

#. type: Plain text
#: man-pages/man2/pipe.2:219
msgid "B<pipe2>()  is Linux-specific."
msgstr ""

#.  fork.2 refers to this example program.
#. type: Plain text
#: man-pages/man2/pipe.2:235
msgid ""
"The following program creates a pipe, and then B<fork>(2)s to create a child "
"process; the child inherits a duplicate set of file descriptors that refer "
"to the same pipe.  After the B<fork>(2), each process closes the file "
"descriptors that it doesn't need for the pipe (see B<pipe>(7)).  The parent "
"then writes the string contained in the program's command-line argument to "
"the pipe, and the child reads this string a byte at a time from the pipe and "
"echoes it on standard output."
msgstr ""

#. type: Plain text
#: man-pages/man2/pipe.2:243
#, no-wrap
msgid ""
"#include E<lt>sys/types.hE<gt>\n"
"#include E<lt>sys/wait.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/pipe.2:250
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int pipefd[2];\n"
"    pid_t cpid;\n"
"    char buf;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/pipe.2:255
#, no-wrap
msgid ""
"    if (argc != 2) {\n"
"        fprintf(stderr, \"Usage: %s E<lt>stringE<gt>\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/pipe.2:260
#, no-wrap
msgid ""
"    if (pipe(pipefd) == -1) {\n"
"        perror(\"pipe\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/pipe.2:266 man-pages/man2/wait.2:661
#, no-wrap
msgid ""
"    cpid = fork();\n"
"    if (cpid == -1) {\n"
"        perror(\"fork\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/pipe.2:269
#, no-wrap
msgid ""
"    if (cpid == 0) {    /* Child reads from pipe */\n"
"        close(pipefd[1]);          /* Close unused write end */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/pipe.2:272
#, no-wrap
msgid ""
"        while (read(pipefd[0], &buf, 1) E<gt> 0)\n"
"            write(STDOUT_FILENO, &buf, 1);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/pipe.2:276
#, no-wrap
msgid ""
"        write(STDOUT_FILENO, \"\\en\", 1);\n"
"        close(pipefd[0]);\n"
"        _exit(EXIT_SUCCESS);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/pipe.2:285
#, no-wrap
msgid ""
"    } else {            /* Parent writes argv[1] to pipe */\n"
"        close(pipefd[0]);          /* Close unused read end */\n"
"        write(pipefd[1], argv[1], strlen(argv[1]));\n"
"        close(pipefd[1]);          /* Reader will see EOF */\n"
"        wait(NULL);                /* Wait for child */\n"
"        exit(EXIT_SUCCESS);\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/pipe.2:295
msgid ""
"B<fork>(2), B<read>(2), B<socketpair>(2), B<splice>(2), B<tee>(2), "
"B<vmsplice>(2), B<write>(2), B<popen>(3), B<pipe>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/setreuid.2:46
#, no-wrap
msgid "SETREUID"
msgstr ""

#. type: Plain text
#: man-pages/man2/setreuid.2:49
msgid "setreuid, setregid - set real and/or effective user or group ID"
msgstr ""

#. type: Plain text
#: man-pages/man2/setreuid.2:55
msgid "B<int setreuid(uid_t >I<ruid>B<, uid_t >I<euid>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/setreuid.2:57
msgid "B<int setregid(gid_t >I<rgid>B<, gid_t >I<egid>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/setreuid.2:65
msgid "B<setreuid>(), B<setregid>():"
msgstr ""

#.     || _XOPEN_SOURCE\ &&\ _XOPEN_SOURCE_EXTENDED
#. type: Plain text
#: man-pages/man2/setreuid.2:71 man-pages/man2/sync.2:58
#, no-wrap
msgid ""
"_XOPEN_SOURCE\\ E<gt>=\\ 500\n"
"    || /* Since glibc 2.19: */ _DEFAULT_SOURCE\n"
"    || /* Glibc versions E<lt>= 2.19: */ _BSD_SOURCE\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/setreuid.2:76
msgid "B<setreuid>()  sets real and effective user IDs of the calling process."
msgstr ""

#. type: Plain text
#: man-pages/man2/setreuid.2:79
msgid ""
"Supplying a value of -1 for either the real or effective user ID forces the "
"system to leave that ID unchanged."
msgstr ""

#. type: Plain text
#: man-pages/man2/setreuid.2:82
msgid ""
"Unprivileged processes may only set the effective user ID to the real user "
"ID, the effective user ID, or the saved set-user-ID."
msgstr ""

#. type: Plain text
#: man-pages/man2/setreuid.2:85
msgid ""
"Unprivileged users may only set the real user ID to the real user ID or the "
"effective user ID."
msgstr ""

#. type: Plain text
#: man-pages/man2/setreuid.2:91
msgid ""
"If the real user ID is set (i.e., I<ruid> is not -1) or the effective user "
"ID is set to a value not equal to the previous real user ID, the saved "
"set-user-ID will be set to the new effective user ID."
msgstr ""

#. type: Plain text
#: man-pages/man2/setreuid.2:96
msgid ""
"Completely analogously, B<setregid>()  sets real and effective group ID's of "
"the calling process, and all of the above holds with \"group\" instead of "
"\"user\"."
msgstr ""

#. type: Plain text
#: man-pages/man2/setreuid.2:108
msgid ""
"I<Note>: there are cases where B<setreuid>()  can fail even when the caller "
"is UID 0; it is a grave security error to omit checking for a failure return "
"from B<setreuid>()."
msgstr ""

#. type: Plain text
#: man-pages/man2/setreuid.2:151
msgid ""
"The calling process is not privileged (on Linux, does not have the necessary "
"capability in its user namespace: B<CAP_SETUID> in the case of "
"B<setreuid>(), or B<CAP_SETGID> in the case of B<setregid>())  and a change "
"other than (i)  swapping the effective user (group) ID with the real user "
"(group) ID, or (ii) setting one to the value of the other or (iii) setting "
"the effective user (group) ID to the value of the saved set-user-ID (saved "
"set-group-ID) was specified."
msgstr ""

#. type: Plain text
#: man-pages/man2/setreuid.2:157
msgid ""
"POSIX.1-2001, POSIX.1-2008, 4.3BSD (B<setreuid>()  and B<setregid>()  first "
"appeared in 4.2BSD)."
msgstr ""

#. type: Plain text
#: man-pages/man2/setreuid.2:161
msgid ""
"Setting the effective user (group) ID to the saved set-user-ID (saved "
"set-group-ID) is possible since Linux 1.1.37 (1.1.38)."
msgstr ""

#. type: Plain text
#: man-pages/man2/setreuid.2:178
msgid ""
"POSIX.1 does not specify all of the UID changes that Linux permits for an "
"unprivileged process.  For B<setreuid>(), the effective user ID can be made "
"the same as the real user ID or the saved set-user-ID, and it is unspecified "
"whether unprivileged processes may set the real user ID to the real user ID, "
"the effective user ID, or the saved set-user-ID.  For B<setregid>(), the "
"real group ID can be changed to the value of the saved set-group-ID, and the "
"effective group ID can be changed to the value of the real group ID or the "
"saved set-group-ID.  The precise details of what ID changes are permitted "
"vary across implementations."
msgstr ""

#. type: Plain text
#: man-pages/man2/setreuid.2:181
msgid ""
"POSIX.1 makes no specification about the effect of these calls on the saved "
"set-user-ID and saved set-group-ID."
msgstr ""

#. type: Plain text
#: man-pages/man2/setreuid.2:198
msgid ""
"The original Linux B<setreuid>()  and B<setregid>()  system calls supported "
"only 16-bit user and group IDs.  Subsequently, Linux 2.4 added "
"B<setreuid32>()  and B<setregid32>(), supporting 32-bit IDs.  The glibc "
"B<setreuid>()  and B<setregid>()  wrapper functions transparently deal with "
"the variations across kernel versions."
msgstr ""

#. type: Plain text
#: man-pages/man2/setreuid.2:214
msgid ""
"At the kernel level, user IDs and group IDs are a per-thread attribute.  "
"However, POSIX requires that all threads in a process share the same "
"credentials.  The NPTL threading implementation handles the POSIX "
"requirements by providing wrapper functions for the various system calls "
"that change process UIDs and GIDs.  These wrapper functions (including those "
"for B<setreuid>()  and B<setregid>())  employ a signal-based technique to "
"ensure that when one thread changes credentials, all of the other threads in "
"the process also change their credentials.  For details, see B<nptl>(7)."
msgstr ""

#. type: Plain text
#: man-pages/man2/setreuid.2:223
msgid ""
"B<getgid>(2), B<getuid>(2), B<seteuid>(2), B<setgid>(2), B<setresuid>(2), "
"B<setuid>(2), B<capabilities>(7), B<credentials>(7), B<user_namespaces>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/unshare.2:20
#, no-wrap
msgid "UNSHARE"
msgstr ""

#. type: Plain text
#: man-pages/man2/unshare.2:23
msgid "unshare - disassociate parts of the process execution context"
msgstr ""

#. type: Plain text
#: man-pages/man2/unshare.2:27 man-pages/man2/clone.2:51
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>\n"
"B<#include E<lt>sched.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/unshare.2:29
#, no-wrap
msgid "B<int unshare(int >I<flags>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/unshare.2:42
msgid ""
"B<unshare>()  allows a process (or thread) to disassociate parts of its "
"execution context that are currently being shared with other processes (or "
"threads).  Part of the execution context, such as the mount namespace, is "
"shared implicitly when a new process is created using B<fork>(2)  or "
"B<vfork>(2), while other parts, such as virtual memory, may be shared by "
"explicit request when creating a process or thread using B<clone>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/unshare.2:47
msgid ""
"The main use of B<unshare>()  is to allow a process to control its shared "
"execution context without creating a new process."
msgstr ""

#. type: Plain text
#: man-pages/man2/unshare.2:54
msgid ""
"The I<flags> argument is a bit mask that specifies which parts of the "
"execution context should be unshared.  This argument is specified by ORing "
"together zero or more of the following constants:"
msgstr ""

#. type: TP
#: man-pages/man2/unshare.2:54
#, no-wrap
msgid "B<CLONE_FILES>"
msgstr ""

#. type: Plain text
#: man-pages/man2/unshare.2:62
msgid ""
"Reverse the effect of the B<clone>(2)  B<CLONE_FILES> flag.  Unshare the "
"file descriptor table, so that the calling process no longer shares its file "
"descriptors with any other process."
msgstr ""

#. type: TP
#: man-pages/man2/unshare.2:62
#, no-wrap
msgid "B<CLONE_FS>"
msgstr ""

#. type: Plain text
#: man-pages/man2/unshare.2:76
msgid ""
"Reverse the effect of the B<clone>(2)  B<CLONE_FS> flag.  Unshare filesystem "
"attributes, so that the calling process no longer shares its root directory "
"(B<chroot>(2)), current directory (B<chdir>(2)), or umask (B<umask>(2))  "
"attributes with any other process."
msgstr ""

#. type: TP
#: man-pages/man2/unshare.2:76 man-pages/man2/clone.2:262
#: man-pages/man2/setns.2:43
#, no-wrap
msgid "B<CLONE_NEWCGROUP> (since Linux 4.6)"
msgstr ""

#. type: Plain text
#: man-pages/man2/unshare.2:88
msgid ""
"This flag has the same effect as the B<clone>(2)  B<CLONE_NEWCGROUP> flag.  "
"Unshare the cgroup namespace.  Use of B<CLONE_NEWCGROUP> requires the "
"B<CAP_SYS_ADMIN> capability."
msgstr ""

#. type: TP
#: man-pages/man2/unshare.2:88 man-pages/man2/clone.2:278
#, no-wrap
msgid "B<CLONE_NEWIPC> (since Linux 2.6.19)"
msgstr ""

#. type: Plain text
#: man-pages/man2/unshare.2:105
msgid ""
"This flag has the same effect as the B<clone>(2)  B<CLONE_NEWIPC> flag.  "
"Unshare the IPC namespace, so that the calling process has a private copy of "
"the IPC namespace which is not shared with any other process.  Specifying "
"this flag automatically implies B<CLONE_SYSVSEM> as well.  Use of "
"B<CLONE_NEWIPC> requires the B<CAP_SYS_ADMIN> capability."
msgstr ""

#. type: TP
#: man-pages/man2/unshare.2:105 man-pages/man2/clone.2:318
#, no-wrap
msgid "B<CLONE_NEWNET> (since Linux 2.6.24)"
msgstr ""

#. type: Plain text
#: man-pages/man2/unshare.2:120
msgid ""
"This flag has the same effect as the B<clone>(2)  B<CLONE_NEWNET> flag.  "
"Unshare the network namespace, so that the calling process is moved into a "
"new network namespace which is not shared with any previously existing "
"process.  Use of B<CLONE_NEWNET> requires the B<CAP_SYS_ADMIN> capability."
msgstr ""

#. type: TP
#: man-pages/man2/unshare.2:120
#, no-wrap
msgid "B<CLONE_NEWNS>"
msgstr ""

#.  These flag name are inconsistent:
#.  CLONE_NEWNS does the same thing in clone(), but CLONE_VM,
#.  CLONE_FS, and CLONE_FILES reverse the action of the clone()
#.  flags of the same name.
#. type: Plain text
#: man-pages/man2/unshare.2:143
msgid ""
"This flag has the same effect as the B<clone>(2)  B<CLONE_NEWNS> flag.  "
"Unshare the mount namespace, so that the calling process has a private copy "
"of its namespace which is not shared with any other process.  Specifying "
"this flag automatically implies B<CLONE_FS> as well.  Use of B<CLONE_NEWNS> "
"requires the B<CAP_SYS_ADMIN> capability.  For further information, see "
"B<mount_namespaces>(7)."
msgstr ""

#. type: TP
#: man-pages/man2/unshare.2:143 man-pages/man2/setns.2:59
#, no-wrap
msgid "B<CLONE_NEWPID> (since Linux 3.8)"
msgstr ""

#. type: Plain text
#: man-pages/man2/unshare.2:170
msgid ""
"This flag has the same effect as the B<clone>(2)  B<CLONE_NEWPID> flag.  "
"Unshare the PID namespace, so that the calling process has a new PID "
"namespace for its children which is not shared with any previously existing "
"process.  The calling process is I<not> moved into the new namespace.  The "
"first child created by the calling process will have the process ID 1 and "
"will assume the role of B<init>(1)  in the new namespace.  B<CLONE_NEWPID> "
"automatically implies B<CLONE_THREAD> as well.  Use of B<CLONE_NEWPID> "
"requires the B<CAP_SYS_ADMIN> capability.  For further information, see "
"B<pid_namespaces>(7)."
msgstr ""

#. type: TP
#: man-pages/man2/unshare.2:170 man-pages/man2/setns.2:63
#, no-wrap
msgid "B<CLONE_NEWUSER> (since Linux 3.8)"
msgstr ""

#. type: Plain text
#: man-pages/man2/unshare.2:184
msgid ""
"This flag has the same effect as the B<clone>(2)  B<CLONE_NEWUSER> flag.  "
"Unshare the user namespace, so that the calling process is moved into a new "
"user namespace which is not shared with any previously existing process.  As "
"with the child process created by B<clone>(2)  with the B<CLONE_NEWUSER> "
"flag, the caller obtains a full set of capabilities in the new namespace."
msgstr ""

#.  commit e66eded8309ebf679d3d3c1f5820d1f2ca332c71
#.  https://lwn.net/Articles/543273/
#. type: Plain text
#: man-pages/man2/unshare.2:200
msgid ""
"B<CLONE_NEWUSER> requires that the calling process is not threaded; "
"specifying B<CLONE_NEWUSER> automatically implies B<CLONE_THREAD>.  Since "
"Linux 3.9, B<CLONE_NEWUSER> also automatically implies B<CLONE_FS>.  "
"B<CLONE_NEWUSER> requires that the user ID and group ID of the calling "
"process are mapped to user IDs and group IDs in the user namespace of the "
"calling process at the time of the call."
msgstr ""

#. type: Plain text
#: man-pages/man2/unshare.2:203
msgid "For further information on user namespaces, see B<user_namespaces>(7)."
msgstr ""

#. type: TP
#: man-pages/man2/unshare.2:203 man-pages/man2/clone.2:465
#, no-wrap
msgid "B<CLONE_NEWUTS> (since Linux 2.6.19)"
msgstr ""

#. type: Plain text
#: man-pages/man2/unshare.2:217
msgid ""
"This flag has the same effect as the B<clone>(2)  B<CLONE_NEWUTS> flag.  "
"Unshare the UTS IPC namespace, so that the calling process has a private "
"copy of the UTS namespace which is not shared with any other process.  Use "
"of B<CLONE_NEWUTS> requires the B<CAP_SYS_ADMIN> capability."
msgstr ""

#. type: TP
#: man-pages/man2/unshare.2:217
#, no-wrap
msgid "B<CLONE_SYSVSEM> (since Linux 2.6.26)"
msgstr ""

#.  commit 9edff4ab1f8d82675277a04e359d0ed8bf14a7b7
#.  CLONE_NEWNS If CLONE_SIGHAND is set and signals are also being shared
#.  (i.e., current->signal->count > 1), force CLONE_THREAD.
#. type: Plain text
#: man-pages/man2/unshare.2:237
msgid ""
"This flag reverses the effect of the B<clone>(2)  B<CLONE_SYSVSEM> flag.  "
"Unshare System\\ V semaphore adjustment (I<semadj>)  values, so that the "
"calling process has a new empty I<semadj> list that is not shared with any "
"other process.  If this is the last process that has a reference to the "
"process's current I<semadj> list, then the adjustments in that list are "
"applied to the corresponding semaphores, as described in B<semop>(2)."
msgstr ""

#.  As at 3.9, the following forced implications also apply,
#.  although the relevant flags are not yet implemented.
#.  If CLONE_THREAD is set force CLONE_VM.
#.  If CLONE_VM is set, force CLONE_SIGHAND.
#
#.  See kernel/fork.c::check_unshare_flags()
#. type: Plain text
#: man-pages/man2/unshare.2:264
msgid ""
"In addition, B<CLONE_THREAD>, B<CLONE_SIGHAND>, and B<CLONE_VM> can be "
"specified in I<flags> if the caller is single threaded (i.e., it is not "
"sharing its address space with another process or thread).  In this case, "
"these flags have no effect.  (Note also that specifying B<CLONE_THREAD> "
"automatically implies B<CLONE_VM>, and specifying B<CLONE_VM> automatically "
"implies B<CLONE_SIGHAND>.)  If the process is multithreaded, then the use of "
"these flags results in an error."
msgstr ""

#. type: Plain text
#: man-pages/man2/unshare.2:271
msgid ""
"If I<flags> is specified as zero, then B<unshare>()  is a no-op; no changes "
"are made to the calling process's execution context."
msgstr ""

#. type: Plain text
#: man-pages/man2/unshare.2:276
msgid ""
"On success, zero returned.  On failure, -1 is returned and I<errno> is set "
"to indicate the error."
msgstr ""

#. type: Plain text
#: man-pages/man2/unshare.2:281
msgid "An invalid bit was specified in I<flags>."
msgstr ""

#. type: Plain text
#: man-pages/man2/unshare.2:290
msgid ""
"B<CLONE_THREAD>, B<CLONE_SIGHAND>, or B<CLONE_VM> was specified in I<flags>, "
"and the caller is multithreaded."
msgstr ""

#. type: Plain text
#: man-pages/man2/unshare.2:300 man-pages/man2/clone.2:1121
msgid ""
"B<CLONE_NEWIPC> was specified in I<flags>, but the kernel was not configured "
"with the B<CONFIG_SYSVIPC> and B<CONFIG_IPC_NS> options."
msgstr ""

#. type: Plain text
#: man-pages/man2/unshare.2:308 man-pages/man2/clone.2:1129
msgid ""
"B<CLONE_NEWNET> was specified in I<flags>, but the kernel was not configured "
"with the B<CONFIG_NET_NS> option."
msgstr ""

#. type: Plain text
#: man-pages/man2/unshare.2:316 man-pages/man2/clone.2:1137
msgid ""
"B<CLONE_NEWPID> was specified in I<flags>, but the kernel was not configured "
"with the B<CONFIG_PID_NS> option."
msgstr ""

#. type: Plain text
#: man-pages/man2/unshare.2:324 man-pages/man2/clone.2:1145
msgid ""
"B<CLONE_NEWUSER> was specified in I<flags>, but the kernel was not "
"configured with the B<CONFIG_USER_NS> option."
msgstr ""

#. type: Plain text
#: man-pages/man2/unshare.2:332 man-pages/man2/clone.2:1153
msgid ""
"B<CLONE_NEWUTS> was specified in I<flags>, but the kernel was not configured "
"with the B<CONFIG_UTS_NS> option."
msgstr ""

#. type: Plain text
#: man-pages/man2/unshare.2:342
msgid ""
"B<CLONE_NEWPID> was specified in I<flags>, but the process has previously "
"called B<unshare>()  with the B<CLONE_NEWPID> flag."
msgstr ""

#. type: Plain text
#: man-pages/man2/unshare.2:346
msgid ""
"Cannot allocate sufficient memory to copy parts of caller's context that "
"need to be unshared."
msgstr ""

#. type: TP
#: man-pages/man2/unshare.2:346 man-pages/man2/clone.2:1180
#, no-wrap
msgid "B<ENOSPC> (since Linux 3.7)"
msgstr ""

#.  commit f2302505775fd13ba93f034206f1e2a587017929
#. type: Plain text
#: man-pages/man2/unshare.2:354 man-pages/man2/clone.2:1188
msgid ""
"B<CLONE_NEWPID> was specified in flags, but the limit on the nesting depth "
"of PID namespaces would have been exceeded; see B<pid_namespaces>(7)."
msgstr ""

#. type: TP
#: man-pages/man2/unshare.2:354 man-pages/man2/clone.2:1188
#, no-wrap
msgid "B<ENOSPC> (since Linux 4.9; beforehand B<EUSERS>)"
msgstr ""

#. type: Plain text
#: man-pages/man2/unshare.2:363 man-pages/man2/clone.2:1197
msgid ""
"B<CLONE_NEWUSER> was specified in I<flags>, and the call would cause the "
"limit on the number of nested user namespaces to be exceeded.  See "
"B<user_namespaces>(7)."
msgstr ""

#. type: Plain text
#: man-pages/man2/unshare.2:366 man-pages/man2/clone.2:1200
msgid ""
"From Linux 3.11 to Linux 4.8, the error diagnosed in this case was "
"B<EUSERS>."
msgstr ""

#. type: TP
#: man-pages/man2/unshare.2:366 man-pages/man2/clone.2:1200
#, no-wrap
msgid "B<ENOSPC> (since Linux 4.9)"
msgstr ""

#. type: Plain text
#: man-pages/man2/unshare.2:376 man-pages/man2/clone.2:1210
msgid ""
"One of the values in I<flags> specified the creation of a new user "
"namespace, but doing so would have caused the limit defined by the "
"corresponding file in I</proc/sys/user> to be exceeded.  For further "
"details, see B<namespaces>(7)."
msgstr ""

#. type: Plain text
#: man-pages/man2/unshare.2:379
msgid "The calling process did not have the required privileges for this operation."
msgstr ""

#. type: Plain text
#: man-pages/man2/unshare.2:387 man-pages/man2/clone.2:1233
msgid ""
"B<CLONE_NEWUSER> was specified in I<flags>, but either the effective user ID "
"or the effective group ID of the caller does not have a mapping in the "
"parent namespace (see B<user_namespaces>(7))."
msgstr ""

#. type: TP
#: man-pages/man2/unshare.2:387 man-pages/man2/clone.2:1233
#, no-wrap
msgid "B<EPERM> (since Linux 3.9)"
msgstr ""

#.  commit 3151527ee007b73a0ebd296010f1c0454a919c7d
#.  FIXME What is the rationale for this restriction?
#. type: Plain text
#: man-pages/man2/unshare.2:397 man-pages/man2/clone.2:1243
msgid ""
"B<CLONE_NEWUSER> was specified in I<flags> and the caller is in a chroot "
"environment (i.e., the caller's root directory does not match the root "
"directory of the mount namespace in which it resides)."
msgstr ""

#. type: TP
#: man-pages/man2/unshare.2:397
#, no-wrap
msgid "B<EUSERS> (from Linux 3.11 to Linux 4.8)"
msgstr ""

#.  .SH VERSIONS
#.  There is no entry for
#.  .BR clone ()
#.  in libc5.
#.  glibc2 provides
#.  .BR clone ()
#.  as described in this manual page.
#. type: Plain text
#: man-pages/man2/unshare.2:406 man-pages/man2/clone.2:1264
msgid ""
"B<CLONE_NEWUSER> was specified in I<flags>, and the limit on the number of "
"nested user namespaces would be exceeded.  See the discussion of the "
"B<ENOSPC> error above."
msgstr ""

#. type: Plain text
#: man-pages/man2/unshare.2:410
msgid "The B<unshare>()  system call was added to Linux in kernel 2.6.16."
msgstr ""

#. type: Plain text
#: man-pages/man2/unshare.2:414
msgid "The B<unshare>()  system call is Linux-specific."
msgstr ""

#.  FIXME all of the following needs to be reviewed for the current kernel
#.  However, we can do unshare(CLONE_SIGHAND) if CLONE_SIGHAND
#.  was not specified when doing clone(); i.e., unsharing
#.  signal handlers is permitted if we are not actually
#.  sharing signal handlers.   mtk
#.  However, we can do unshare(CLONE_VM) if CLONE_VM
#.  was not specified when doing clone(); i.e., unsharing
#.  virtual memory is permitted if we are not actually
#.  sharing virtual memory.   mtk
#
#. 9) Future Work
#. --------------
#. The current implementation of unshare does not allow unsharing of
#. signals and signal handlers. Signals are complex to begin with and
#. to unshare signals and/or signal handlers of a currently running
#. process is even more complex. If in the future there is a specific
#. need to allow unsharing of signals and/or signal handlers, it can
#. be incrementally added to unshare without affecting legacy
#. applications using unshare.
#. type: Plain text
#: man-pages/man2/unshare.2:448
msgid ""
"Not all of the process attributes that can be shared when a new process is "
"created using B<clone>(2)  can be unshared using B<unshare>().  In "
"particular, as at kernel 3.8, B<unshare>()  does not implement flags that "
"reverse the effects of B<CLONE_SIGHAND>, B<CLONE_THREAD>, or B<CLONE_VM>.  "
"Such functionality may be added in the future, if required."
msgstr ""

#. type: Plain text
#: man-pages/man2/unshare.2:457
msgid ""
"The program below provides a simple implementation of the B<unshare>(1)  "
"command, which unshares one or more namespaces and executes the command "
"supplied in its command-line arguments.  Here's an example of the use of "
"this program, running a shell in a new mount namespace, and verifying that "
"the original shell and the new shell are in separate mount namespaces:"
msgstr ""

#. type: Plain text
#: man-pages/man2/unshare.2:465
#, no-wrap
msgid ""
"$ B<readlink /proc/$$/ns/mnt>\n"
"mnt:[4026531840]\n"
"$ B<sudo ./unshare -m /bin/bash>\n"
"# B<readlink /proc/$$/ns/mnt>\n"
"mnt:[4026532325]\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/unshare.2:471
msgid ""
"The differing output of the two B<readlink>(1)  commands shows that the two "
"shells are in different mount namespaces."
msgstr ""

#. type: Plain text
#: man-pages/man2/unshare.2:475
#, no-wrap
msgid "/* unshare.c\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/unshare.2:484
#, no-wrap
msgid ""
"   A simple implementation of the unshare(1) command: unshare\n"
"   namespaces and execute a command.\n"
"*/\n"
"#define _GNU_SOURCE\n"
"#include E<lt>sched.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/unshare.2:487
#, no-wrap
msgid ""
"/* A simple error-handling function: print an error message based\n"
"   on the value in \\(aqerrno\\(aq and terminate the calling process */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/unshare.2:504
#, no-wrap
msgid ""
"static void\n"
"usage(char *pname)\n"
"{\n"
"    fprintf(stderr, \"Usage: %s [options] program [arg...]\\en\", pname);\n"
"    fprintf(stderr, \"Options can be:\\en\");\n"
"    fprintf(stderr, \"    -i   unshare IPC namespace\\en\");\n"
"    fprintf(stderr, \"    -m   unshare mount namespace\\en\");\n"
"    fprintf(stderr, \"    -n   unshare network namespace\\en\");\n"
"    fprintf(stderr, \"    -p   unshare PID namespace\\en\");\n"
"    fprintf(stderr, \"    -u   unshare UTS namespace\\en\");\n"
"    fprintf(stderr, \"    -U   unshare user namespace\\en\");\n"
"    exit(EXIT_FAILURE);\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/unshare.2:509
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int flags, opt;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/unshare.2:511
#, no-wrap
msgid "    flags = 0;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/unshare.2:523
#, no-wrap
msgid ""
"    while ((opt = getopt(argc, argv, \"imnpuU\")) != -1) {\n"
"        switch (opt) {\n"
"        case \\(aqi\\(aq: flags |= CLONE_NEWIPC;        break;\n"
"        case \\(aqm\\(aq: flags |= CLONE_NEWNS;         break;\n"
"        case \\(aqn\\(aq: flags |= CLONE_NEWNET;        break;\n"
"        case \\(aqp\\(aq: flags |= CLONE_NEWPID;        break;\n"
"        case \\(aqu\\(aq: flags |= CLONE_NEWUTS;        break;\n"
"        case \\(aqU\\(aq: flags |= CLONE_NEWUSER;       break;\n"
"        default:  usage(argv[0]);\n"
"        }\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/unshare.2:526
#, no-wrap
msgid ""
"    if (optind E<gt>= argc)\n"
"        usage(argv[0]);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/unshare.2:529
#, no-wrap
msgid ""
"    if (unshare(flags) == -1)\n"
"        errExit(\"unshare\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/unshare.2:533
#, no-wrap
msgid ""
"    execvp(argv[optind], &argv[optind]);\n"
"    errExit(\"execvp\");\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/unshare.2:542
msgid ""
"B<unshare>(1), B<clone>(2), B<fork>(2), B<kcmp>(2), B<setns>(2), "
"B<vfork>(2), B<namespaces>(7)"
msgstr ""

#.  commit f504d47be5e8fa7ecf2bf660b18b42e6960c0eb2
#. type: Plain text
#: man-pages/man2/unshare.2:548
msgid ""
"I<Documentation/userspace-api/unshare.rst> in the Linux kernel source tree "
"(or I<Documentation/unshare.txt> before Linux 4.12)"
msgstr ""

#. type: TH
#: man-pages/man2/setfsgid.2:32
#, no-wrap
msgid "SETFSGID"
msgstr ""

#. type: Plain text
#: man-pages/man2/setfsgid.2:35
msgid "setfsgid - set group identity used for filesystem checks"
msgstr ""

#. type: Plain text
#: man-pages/man2/setfsgid.2:39
msgid "B<int setfsgid(uid_t >I<fsgid>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/setfsgid.2:46
msgid ""
"On Linux, a process has both a filesystem group ID and an effective group "
"ID.  The (Linux-specific) filesystem group ID is used for permissions "
"checking when accessing filesystem objects, while the effective group ID is "
"used for some other kinds of permissions checks (see B<credentials>(7))."
msgstr ""

#. type: Plain text
#: man-pages/man2/setfsgid.2:57
msgid ""
"Normally, the value of the process's filesystem group ID is the same as the "
"value of its effective group ID.  This is so, because whenever a process's "
"effective group ID is changed, the kernel also changes the filesystem group "
"ID to be the same as the new value of the effective group ID.  A process can "
"cause the value of its filesystem group ID to diverge from its effective "
"group ID by using B<setfsgid>()  to change its filesystem group ID to the "
"value given in I<fsgid>."
msgstr ""

#. type: Plain text
#: man-pages/man2/setfsgid.2:63
msgid ""
"B<setfsgid>()  will succeed only if the caller is the superuser or if "
"I<fsgid> matches either the caller's real group ID, effective group ID, "
"saved set-group-ID, or current the filesystem user ID."
msgstr ""

#. type: Plain text
#: man-pages/man2/setfsgid.2:66
msgid ""
"On both success and failure, this call returns the previous filesystem group "
"ID of the caller."
msgstr ""

#. type: Plain text
#: man-pages/man2/setfsgid.2:74
msgid ""
"B<setfsgid>()  is Linux-specific and should not be used in programs intended "
"to be portable."
msgstr ""

#. type: Plain text
#: man-pages/man2/setfsgid.2:86
msgid ""
"The filesystem group ID concept and the B<setfsgid>()  system call were "
"invented for historical reasons that are no longer applicable on modern "
"Linux kernels.  See B<setfsuid>(2)  for a discussion of why the use of both "
"B<setfsuid>(2)  and B<setfsgid>()  is nowadays unneeded."
msgstr ""

#. type: Plain text
#: man-pages/man2/setfsgid.2:96
msgid ""
"The original Linux B<setfsgid>()  system call supported only 16-bit group "
"IDs.  Subsequently, Linux 2.4 added B<setfsgid32>()  supporting 32-bit IDs.  "
"The glibc B<setfsgid>()  wrapper function transparently deals with the "
"variation across kernel versions."
msgstr ""

#. type: Plain text
#: man-pages/man2/setfsgid.2:105
msgid ""
"In glibc 2.15 and earlier, when the wrapper for this system call determines "
"that the argument can't be passed to the kernel without integer truncation "
"(because the kernel is old and does not support 32-bit group IDs), it will "
"return -1 and set I<errno> to B<EINVAL> without attempting the system call."
msgstr ""

#. type: Plain text
#: man-pages/man2/setfsgid.2:122
msgid ""
"No error indications of any kind are returned to the caller, and the fact "
"that both successful and unsuccessful calls return the same value makes it "
"impossible to directly determine whether the call succeeded or failed.  "
"Instead, the caller must resort to looking at the return value from a "
"further call such as I<setfsgid(-1)> (which will always fail), in order to "
"determine if a preceding call to B<setfsgid>()  changed the filesystem group "
"ID.  At the very least, B<EPERM> should be returned when the call fails "
"(because the caller lacks the B<CAP_SETGID> capability)."
msgstr ""

#. type: Plain text
#: man-pages/man2/setfsgid.2:126
msgid "B<kill>(2), B<setfsuid>(2), B<capabilities>(7), B<credentials>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/sched_get_priority_max.2:29
#, no-wrap
msgid "SCHED_GET_PRIORITY_MAX"
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_get_priority_max.2:32
msgid "sched_get_priority_max, sched_get_priority_min - get static priority range"
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_get_priority_max.2:34 man-pages/man2/sched_yield.2:34
#: man-pages/man2/sched_rr_get_interval.2:34
msgid "B<#include E<lt>sched.hE<gt>>"
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_get_priority_max.2:36
msgid "B<int sched_get_priority_max(int >I<policy>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_get_priority_max.2:38
msgid "B<int sched_get_priority_min(int >I<policy>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_get_priority_max.2:59
msgid ""
"B<sched_get_priority_max>()  returns the maximum priority value that can be "
"used with the scheduling algorithm identified by I<policy>.  "
"B<sched_get_priority_min>()  returns the minimum priority value that can be "
"used with the scheduling algorithm identified by I<policy>.  Supported "
"I<policy> values are B<SCHED_FIFO>, B<SCHED_RR>, B<SCHED_OTHER>, "
"B<SCHED_BATCH>, B<SCHED_IDLE>, and B<SCHED_DEADLINE>.  Further details about "
"these policies can be found in B<sched>(7)."
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_get_priority_max.2:68
msgid ""
"Processes with numerically higher priority values are scheduled before "
"processes with numerically lower priority values.  Thus, the value returned "
"by B<sched_get_priority_max>()  will be greater than the value returned by "
"B<sched_get_priority_min>()."
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_get_priority_max.2:76
msgid ""
"Linux allows the static priority range 1 to 99 for the B<SCHED_FIFO> and "
"B<SCHED_RR> policies, and the priority 0 for the remaining policies.  "
"Scheduling priority ranges for the various policies are not alterable."
msgstr ""

#.  POSIX.1-2001, POSIX.1-2008 (XBD 2.8.4)
#. type: Plain text
#: man-pages/man2/sched_get_priority_max.2:89
msgid ""
"The range of scheduling priorities may vary on other POSIX systems, thus it "
"is a good idea for portable applications to use a virtual priority range and "
"map it to the interval given by B<sched_get_priority_max>()  and "
"B<sched_get_priority_min> POSIX.1 requires a spread of at least 32 between "
"the maximum and the minimum values for B<SCHED_FIFO> and B<SCHED_RR>."
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_get_priority_max.2:98
msgid ""
"POSIX systems on which B<sched_get_priority_max>()  and "
"B<sched_get_priority_min>()  are available define "
"B<_POSIX_PRIORITY_SCHEDULING> in I<E<lt>unistd.hE<gt>>."
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_get_priority_max.2:108
msgid ""
"On success, B<sched_get_priority_max>()  and B<sched_get_priority_min>()  "
"return the maximum/minimum priority value for the named scheduling policy.  "
"On error, -1 is returned, and I<errno> is set appropriately."
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_get_priority_max.2:114
msgid "The argument I<policy> does not identify a defined scheduling policy."
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_get_priority_max.2:125
msgid ""
"B<sched_getaffinity>(2), B<sched_getparam>(2), B<sched_getscheduler>(2), "
"B<sched_setaffinity>(2), B<sched_setparam>(2), B<sched_setscheduler>(2), "
"B<sched>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/utime.2:31
#, no-wrap
msgid "UTIME"
msgstr ""

#. type: Plain text
#: man-pages/man2/utime.2:34
msgid "utime, utimes - change file last access and modification times"
msgstr ""

#. type: Plain text
#: man-pages/man2/utime.2:38
#, no-wrap
msgid ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>utime.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/utime.2:40
#, no-wrap
msgid ""
"B<int utime(const char *>I<filename>B<, const struct utimbuf "
"*>I<times>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/utime.2:42 man-pages/man2/gettimeofday.2:46
#: man-pages/man2/getitimer.2:19
#, no-wrap
msgid "B<#include E<lt>sys/time.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/utime.2:44
#, no-wrap
msgid ""
"B<int utimes(const char *>I<filename>B<, const struct timeval "
">I<times>B<[2]);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/utime.2:49
msgid ""
"B<Note:> modern applications may prefer to use the interfaces described in "
"B<utimensat>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/utime.2:60
msgid ""
"The B<utime>()  system call changes the access and modification times of the "
"inode specified by I<filename> to the I<actime> and I<modtime> fields of "
"I<times> respectively."
msgstr ""

#. type: Plain text
#: man-pages/man2/utime.2:65
msgid ""
"If I<times> is NULL, then the access and modification times of the file are "
"set to the current time."
msgstr ""

#. type: Plain text
#: man-pages/man2/utime.2:72
msgid ""
"Changing timestamps is permitted when: either the process has appropriate "
"privileges, or the effective user ID equals the user ID of the file, or "
"I<times> is NULL and the process has write permission for the file."
msgstr ""

#. type: Plain text
#: man-pages/man2/utime.2:76
msgid "The I<utimbuf> structure is:"
msgstr ""

#. type: Plain text
#: man-pages/man2/utime.2:83
#, no-wrap
msgid ""
"struct utimbuf {\n"
"    time_t actime;       /* access time */\n"
"    time_t modtime;      /* modification time */\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/utime.2:90
msgid ""
"The B<utime>()  system call allows specification of timestamps with a "
"resolution of 1 second."
msgstr ""

#. type: Plain text
#: man-pages/man2/utime.2:103
msgid ""
"The B<utimes>()  system call is similar, but the I<times> argument refers to "
"an array rather than a structure.  The elements of this array are I<timeval> "
"structures, which allow a precision of 1 microsecond for specifying "
"timestamps.  The I<timeval> structure is:"
msgstr ""

#. type: Plain text
#: man-pages/man2/utime.2:110
#, no-wrap
msgid ""
"struct timeval {\n"
"    long tv_sec;        /* seconds */\n"
"    long tv_usec;       /* microseconds */\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/utime.2:123
msgid ""
"I<times>[0] specifies the new access time, and I<times>[1] specifies the new "
"modification time.  If I<times> is NULL, then analogously to B<utime>(), the "
"access and modification times of the file are set to the current time."
msgstr ""

#. type: Plain text
#: man-pages/man2/utime.2:136
msgid ""
"Search permission is denied for one of the directories in the path prefix of "
"I<path> (see also B<path_resolution>(7))."
msgstr ""

#. type: Plain text
#: man-pages/man2/utime.2:148
msgid ""
"I<times> is NULL, the caller's effective user ID does not match the owner of "
"the file, the caller does not have write access to the file, and the caller "
"is not privileged (Linux: does not have either the B<CAP_DAC_OVERRIDE> or "
"the B<CAP_FOWNER> capability)."
msgstr ""

#. type: Plain text
#: man-pages/man2/utime.2:152
msgid "I<filename> does not exist."
msgstr ""

#. type: Plain text
#: man-pages/man2/utime.2:161
msgid ""
"I<times> is not NULL, the caller's effective UID does not match the owner of "
"the file, and the caller is not privileged (Linux: does not have the "
"B<CAP_FOWNER> capability)."
msgstr ""

#. type: Plain text
#: man-pages/man2/utime.2:165
msgid "I<path> resides on a read-only filesystem."
msgstr ""

#. type: Plain text
#: man-pages/man2/utime.2:171
msgid "B<utime>(): SVr4, POSIX.1-2001.  POSIX.1-2008 marks B<utime>()  as obsolete."
msgstr ""

#. type: Plain text
#: man-pages/man2/utime.2:174
msgid "B<utimes>(): 4.3BSD, POSIX.1-2001."
msgstr ""

#
#.  In libc4 and libc5,
#.  .BR utimes ()
#.  is just a wrapper for
#.  .BR utime ()
#.  and hence does not allow a subsecond resolution.
#. type: Plain text
#: man-pages/man2/utime.2:184
msgid ""
"Linux does not allow changing the timestamps on an immutable file, or "
"setting the timestamps to something other than the current time on an "
"append-only file."
msgstr ""

#. type: Plain text
#: man-pages/man2/utime.2:192
msgid ""
"B<chattr>(1), B<touch>(1), B<futimesat>(2), B<stat>(2), B<utimensat>(2), "
"B<futimens>(3), B<futimes>(3), B<inode>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/clock_nanosleep.2:26
#, no-wrap
msgid "CLOCK_NANOSLEEP"
msgstr ""

#. type: Plain text
#: man-pages/man2/clock_nanosleep.2:29
msgid "clock_nanosleep - high-resolution sleep with specifiable clock"
msgstr ""

#. type: Plain text
#: man-pages/man2/clock_nanosleep.2:31 man-pages/man2/stime.2:35
#: man-pages/man2/nanosleep.2:39 man-pages/man2/time.2:34
#: man-pages/man2/clock_getres.2:35
msgid "B<#include E<lt>time.hE<gt>>"
msgstr ""

#. type: Plain text
#: man-pages/man2/clock_nanosleep.2:36
#, no-wrap
msgid ""
"B<int clock_nanosleep(clockid_t >I<clock_id>B<, int >I<flags>B<,>\n"
"B<                    const struct timespec *>I<request>B<,>\n"
"B<                    struct timespec *>I<remain>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/clock_nanosleep.2:39 man-pages/man2/clock_getres.2:43
msgid "Link with I<-lrt> (only for glibc versions before 2.17)."
msgstr ""

#. type: Plain text
#: man-pages/man2/clock_nanosleep.2:47
msgid "B<clock_nanosleep>():"
msgstr ""

#. type: Plain text
#: man-pages/man2/clock_nanosleep.2:49 man-pages/man2/posix_fadvise.2:49
msgid "_POSIX_C_SOURCE\\ E<gt>=\\ 200112L"
msgstr ""

#. type: Plain text
#: man-pages/man2/clock_nanosleep.2:61
msgid ""
"Like B<nanosleep>(2), B<clock_nanosleep>()  allows the calling thread to "
"sleep for an interval specified with nanosecond precision.  It differs in "
"allowing the caller to select the clock against which the sleep interval is "
"to be measured, and in allowing the sleep interval to be specified as either "
"an absolute or a relative value."
msgstr ""

#. type: Plain text
#: man-pages/man2/clock_nanosleep.2:65
msgid ""
"The time values passed to and returned by this call are specified using "
"I<timespec> structures, defined as follows:"
msgstr ""

#. type: Plain text
#: man-pages/man2/clock_nanosleep.2:72
#, no-wrap
msgid ""
"struct timespec {\n"
"    time_t tv_sec;        /* seconds */\n"
"    long   tv_nsec;       /* nanoseconds [0 .. 999999999] */\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/clock_nanosleep.2:80
msgid ""
"The I<clock_id> argument specifies the clock against which the sleep "
"interval is to be measured.  This argument can have one of the following "
"values:"
msgstr ""

#. type: TP
#: man-pages/man2/clock_nanosleep.2:80 man-pages/man2/timerfd_create.2:70
#: man-pages/man2/clock_getres.2:121 man-pages/man2/timer_create.2:60
#, no-wrap
msgid "B<CLOCK_REALTIME>"
msgstr ""

#. type: Plain text
#: man-pages/man2/clock_nanosleep.2:83 man-pages/man2/timerfd_create.2:73
#: man-pages/man2/timer_create.2:63
msgid "A settable system-wide real-time clock."
msgstr ""

#. type: TP
#: man-pages/man2/clock_nanosleep.2:83 man-pages/man2/timerfd_create.2:73
#: man-pages/man2/clock_getres.2:139 man-pages/man2/timer_create.2:63
#, no-wrap
msgid "B<CLOCK_MONOTONIC>"
msgstr ""

#.  On Linux this clock measures time since boot.
#. type: Plain text
#: man-pages/man2/clock_nanosleep.2:89
msgid ""
"A nonsettable, monotonically increasing clock that measures time since some "
"unspecified point in the past that does not change after system startup."
msgstr ""

#. type: TP
#: man-pages/man2/clock_nanosleep.2:89
#, no-wrap
msgid "B<CLOCK_PROCESS_CPUTIME_ID>"
msgstr ""

#.  There is some trickery between glibc and the kernel
#.  to deal with the CLOCK_PROCESS_CPUTIME_ID case.
#. type: Plain text
#: man-pages/man2/clock_nanosleep.2:95
msgid ""
"A settable per-process clock that measures CPU time consumed by all threads "
"in the process."
msgstr ""

#. type: Plain text
#: man-pages/man2/clock_nanosleep.2:105
msgid ""
"See B<clock_getres>(2)  for further details on these clocks.  In addition, "
"the CPU clock IDs returned by B<clock_getcpuclockid>(3)  and "
"B<pthread_getcpuclockid>(3)  can also be passed in I<clock_id>."
msgstr ""

#. type: Plain text
#: man-pages/man2/clock_nanosleep.2:113
msgid ""
"If I<flags> is 0, then the value specified in I<request> is interpreted as "
"an interval relative to the current value of the clock specified by "
"I<clock_id>."
msgstr ""

#. type: Plain text
#: man-pages/man2/clock_nanosleep.2:128
msgid ""
"If I<flags> is B<TIMER_ABSTIME>, then I<request> is interpreted as an "
"absolute time as measured by the clock, I<clock_id>.  If I<request> is less "
"than or equal to the current value of the clock, then B<clock_nanosleep>()  "
"returns immediately without suspending the calling thread."
msgstr ""

#. type: Plain text
#: man-pages/man2/clock_nanosleep.2:136
msgid ""
"B<clock_nanosleep>()  suspends the execution of the calling thread until "
"either at least the time specified by I<request> has elapsed, or a signal is "
"delivered that causes a signal handler to be called or that terminates the "
"process."
msgstr ""

#. type: Plain text
#: man-pages/man2/clock_nanosleep.2:152
msgid ""
"If the call is interrupted by a signal handler, B<clock_nanosleep>()  fails "
"with the error B<EINTR>.  In addition, if I<remain> is not NULL, and "
"I<flags> was not B<TIMER_ABSTIME>, it returns the remaining unslept time in "
"I<remain>.  This value can then be used to call B<clock_nanosleep>()  again "
"and complete a (relative) sleep."
msgstr ""

#. type: Plain text
#: man-pages/man2/clock_nanosleep.2:158
msgid ""
"On successfully sleeping for the requested interval, B<clock_nanosleep>()  "
"returns 0.  If the call is interrupted by a signal handler or encounters an "
"error, then it returns one of the positive error number listed in ERRORS."
msgstr ""

#. type: Plain text
#: man-pages/man2/clock_nanosleep.2:165
msgid "I<request> or I<remain> specified an invalid address."
msgstr ""

#. type: Plain text
#: man-pages/man2/clock_nanosleep.2:169
msgid "The sleep was interrupted by a signal handler; see B<signal>(7)."
msgstr ""

#. type: Plain text
#: man-pages/man2/clock_nanosleep.2:176 man-pages/man2/nanosleep.2:132
msgid ""
"The value in the I<tv_nsec> field was not in the range 0 to 999999999 or "
"I<tv_sec> was negative."
msgstr ""

#. type: Plain text
#: man-pages/man2/clock_nanosleep.2:183
msgid ""
"I<clock_id> was invalid.  (B<CLOCK_THREAD_CPUTIME_ID> is not a permitted "
"value for I<clock_id>.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/clock_nanosleep.2:188
msgid ""
"The B<clock_nanosleep>()  system call first appeared in Linux 2.6.  Support "
"is available in glibc since version 2.1."
msgstr ""

#. type: Plain text
#: man-pages/man2/clock_nanosleep.2:198
msgid ""
"If the interval specified in I<request> is not an exact multiple of the "
"granularity underlying clock (see B<time>(7)), then the interval will be "
"rounded up to the next multiple.  Furthermore, after the sleep completes, "
"there may still be a delay before the CPU becomes free to once again execute "
"the calling thread."
msgstr ""

#. type: Plain text
#: man-pages/man2/clock_nanosleep.2:213
msgid ""
"Using an absolute timer is useful for preventing timer drift problems of the "
"type described in B<nanosleep>(2).  (Such problems are exacerbated in "
"programs that try to restart a relative sleep that is repeatedly interrupted "
"by signals.)  To perform a relative sleep that avoids these problems, call "
"B<clock_gettime>(2)  for the desired clock, add the desired interval to the "
"returned time value, and then call B<clock_nanosleep>()  with the "
"B<TIMER_ABSTIME> flag."
msgstr ""

#. type: Plain text
#: man-pages/man2/clock_nanosleep.2:220
msgid ""
"B<clock_nanosleep>()  is never restarted after being interrupted by a signal "
"handler, regardless of the use of the B<sigaction>(2)  B<SA_RESTART> flag."
msgstr ""

#. type: Plain text
#: man-pages/man2/clock_nanosleep.2:230
msgid ""
"The I<remain> argument is unused, and unnecessary, when I<flags> is "
"B<TIMER_ABSTIME>.  (An absolute sleep can be restarted using the same "
"I<request> argument.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/clock_nanosleep.2:234
msgid ""
"POSIX.1 specifies that B<clock_nanosleep>()  has no effect on signals "
"dispositions or the signal mask."
msgstr ""

#. type: Plain text
#: man-pages/man2/clock_nanosleep.2:246
msgid ""
"POSIX.1 specifies that after changing the value of the B<CLOCK_REALTIME> "
"clock via B<clock_settime>(2), the new clock value shall be used to "
"determine the time at which a thread blocked on an absolute "
"B<clock_nanosleep>()  will wake up; if the new clock value falls past the "
"end of the sleep interval, then the B<clock_nanosleep>()  call will return "
"immediately."
msgstr ""

#. type: Plain text
#: man-pages/man2/clock_nanosleep.2:254
msgid ""
"POSIX.1 specifies that changing the value of the B<CLOCK_REALTIME> clock via "
"B<clock_settime>(2)  shall have no effect on a thread that is blocked on a "
"relative B<clock_nanosleep>()."
msgstr ""

#. type: Plain text
#: man-pages/man2/clock_nanosleep.2:261
msgid ""
"B<clock_getres>(2), B<nanosleep>(2), B<restart_syscall>(2), "
"B<timer_create>(2), B<sleep>(3), B<usleep>(3), B<time>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/copy_file_range.2:25
#, no-wrap
msgid "COPY_FILE_RANGE"
msgstr ""

#. type: Plain text
#: man-pages/man2/copy_file_range.2:28
msgid "copy_file_range - Copy a range of data from one file to another"
msgstr ""

#. type: Plain text
#: man-pages/man2/copy_file_range.2:32
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>\n"
"B<#include E<lt>unistd.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/copy_file_range.2:36
#, no-wrap
msgid ""
"B<ssize_t copy_file_range(int >I<fd_in>B<, loff_t *>I<off_in>B<,>\n"
"B<                        int >I<fd_out>B<, loff_t *>I<off_out>B<,>\n"
"B<                        size_t >I<len>B<, unsigned int >I<flags>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/copy_file_range.2:50
msgid ""
"The B<copy_file_range>()  system call performs an in-kernel copy between two "
"file descriptors without the additional cost of transferring data from the "
"kernel to user space and then back into the kernel.  It copies up to I<len> "
"bytes of data from the source file descriptor I<fd_in> to the target file "
"descriptor I<fd_out>, overwriting any data that exists within the requested "
"range of the target file."
msgstr ""

#. type: Plain text
#: man-pages/man2/copy_file_range.2:55
msgid ""
"The following semantics apply for I<off_in>, and similar statements apply to "
"I<off_out>:"
msgstr ""

#. type: Plain text
#: man-pages/man2/copy_file_range.2:62
msgid ""
"If I<off_in> is NULL, then bytes are read from I<fd_in> starting from the "
"file offset, and the file offset is adjusted by the number of bytes copied."
msgstr ""

#. type: Plain text
#: man-pages/man2/copy_file_range.2:76
msgid ""
"If I<off_in> is not NULL, then I<off_in> must point to a buffer that "
"specifies the starting offset where bytes from I<fd_in> will be read.  The "
"file offset of I<fd_in> is not changed, but I<off_in> is adjusted "
"appropriately."
msgstr ""

#. type: Plain text
#: man-pages/man2/copy_file_range.2:83
msgid ""
"I<fd_in> and I<fd_out> can refer to the same file.  If they refer to the "
"same file, then the source and target ranges are not allowed to overlap."
msgstr ""

#. type: Plain text
#: man-pages/man2/copy_file_range.2:88
msgid ""
"The I<flags> argument is provided to allow for future extensions and "
"currently must be to 0."
msgstr ""

#. type: Plain text
#: man-pages/man2/copy_file_range.2:98
msgid ""
"Upon successful completion, B<copy_file_range>()  will return the number of "
"bytes copied between files.  This could be less than the length originally "
"requested.  If the file offset of I<fd_in> is at or past the end of file, no "
"bytes are copied, and B<copy_file_range>()  returns zero."
msgstr ""

#. type: Plain text
#: man-pages/man2/copy_file_range.2:104
msgid ""
"On error, B<copy_file_range>()  returns -1 and I<errno> is set to indicate "
"the error."
msgstr ""

#. type: Plain text
#: man-pages/man2/copy_file_range.2:108
msgid "One or more file descriptors are not valid."
msgstr ""

#. type: Plain text
#: man-pages/man2/copy_file_range.2:114
msgid "I<fd_in> is not open for reading; or I<fd_out> is not open for writing."
msgstr ""

#. type: Plain text
#: man-pages/man2/copy_file_range.2:122
msgid ""
"The B<O_APPEND> flag is set for the open file description (see B<open>(2))  "
"referred to by the file descriptor I<fd_out>."
msgstr ""

#. type: Plain text
#: man-pages/man2/copy_file_range.2:126
msgid ""
"An attempt was made to write at a position past the maximum file offset the "
"kernel supports."
msgstr ""

#. type: Plain text
#: man-pages/man2/copy_file_range.2:131
msgid ""
"An attempt was made to write a range that exceeds the allowed maximum file "
"size.  The maximum file size differs between filesystem implementations and "
"can be different from the maximum allowed file offset."
msgstr ""

#. type: Plain text
#: man-pages/man2/copy_file_range.2:137
msgid ""
"An attempt was made to write beyond the process's file size resource limit.  "
"This may also result in the process receiving a I<SIGXFSZ> signal."
msgstr ""

#. type: Plain text
#: man-pages/man2/copy_file_range.2:142
msgid "The I<flags> argument is not 0."
msgstr ""

#. type: Plain text
#: man-pages/man2/copy_file_range.2:148
msgid ""
"I<fd_in> and I<fd_out> refer to the same file and the source and target "
"ranges overlap."
msgstr ""

#. type: Plain text
#: man-pages/man2/copy_file_range.2:155
msgid "Either I<fd_in> or I<fd_out> is not a regular file."
msgstr ""

#. type: Plain text
#: man-pages/man2/copy_file_range.2:158
msgid "A low-level I/O error occurred while copying."
msgstr ""

#. type: Plain text
#: man-pages/man2/copy_file_range.2:165
msgid "Either I<fd_in> or I<fd_out> refers to a directory."
msgstr ""

#. type: Plain text
#: man-pages/man2/copy_file_range.2:171
msgid "There is not enough space on the target filesystem to complete the copy."
msgstr ""

#. type: Plain text
#: man-pages/man2/copy_file_range.2:175
msgid ""
"The requested source or destination range is too large to represent in the "
"specified data types."
msgstr ""

#. type: Plain text
#: man-pages/man2/copy_file_range.2:179
msgid "I<fd_out> refers to an immutable file."
msgstr ""

#. type: TP
#: man-pages/man2/copy_file_range.2:179
#, no-wrap
msgid "B<TXTBSY>"
msgstr ""

#. type: Plain text
#: man-pages/man2/copy_file_range.2:186
msgid "Either I<fd_in> or I<fd_out> refers to an active swap file."
msgstr ""

#. type: Plain text
#: man-pages/man2/copy_file_range.2:191
msgid ""
"The files referred to by I<file_in> and I<file_out> are not on the same "
"mounted filesystem (pre Linux 5.3)."
msgstr ""

#.  https://sourceware.org/git/?p=glibc.git;a=commit;f=posix/unistd.h;h=bad7a0c81f501fbbcc79af9eaa4b8254441c4a1f
#. type: Plain text
#: man-pages/man2/copy_file_range.2:197
msgid ""
"The B<copy_file_range>()  system call first appeared in Linux 4.5, but glibc "
"2.27 provides a user-space emulation when it is not available."
msgstr ""

#. type: Plain text
#: man-pages/man2/copy_file_range.2:202
msgid ""
"A major rework of the kernel implementation occurred in 5.3.  Areas of the "
"API that weren't clearly defined were clarified and the API bounds are much "
"more strictly checked than on earlier kernels.  Applications should target "
"the behaviour and requirements of 5.3 kernels."
msgstr ""

#. type: Plain text
#: man-pages/man2/copy_file_range.2:205
msgid ""
"First support for cross-filesystem copies was introduced in Linux 5.3.  "
"Older kernels will return -EXDEV when cross-filesystem copies are attempted."
msgstr ""

#. type: Plain text
#: man-pages/man2/copy_file_range.2:209
msgid ""
"The B<copy_file_range>()  system call is a nonstandard Linux and GNU "
"extension."
msgstr ""

#. type: Plain text
#: man-pages/man2/copy_file_range.2:223
msgid ""
"If I<file_in> is a sparse file, then B<copy_file_range>()  may expand any "
"holes existing in the requested range.  Users may benefit from calling "
"B<copy_file_range>()  in a loop, and using the B<lseek>(2)  B<SEEK_DATA> and "
"B<SEEK_HOLE> operations to find the locations of data segments."
msgstr ""

#. type: Plain text
#: man-pages/man2/copy_file_range.2:229
msgid ""
"B<copy_file_range>()  gives filesystems an opportunity to implement \"copy "
"acceleration\" techniques, such as the use of reflinks (i.e., two or more "
"inodes that share pointers to the same copy-on-write disk blocks)  or "
"server-side-copy (in the case of NFS)."
msgstr ""

#. type: Plain text
#: man-pages/man2/copy_file_range.2:238
#, no-wrap
msgid ""
"#define _GNU_SOURCE\n"
"#include E<lt>fcntl.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>sys/stat.hE<gt>\n"
"#include E<lt>sys/syscall.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/copy_file_range.2:241
#, no-wrap
msgid ""
"/* On versions of glibc before 2.27, we must invoke copy_file_range()\n"
"   using syscall(2) */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/copy_file_range.2:249
#, no-wrap
msgid ""
"static loff_t\n"
"copy_file_range(int fd_in, loff_t *off_in, int fd_out,\n"
"                loff_t *off_out, size_t len, unsigned int flags)\n"
"{\n"
"    return syscall(__NR_copy_file_range, fd_in, off_in, fd_out,\n"
"                   off_out, len, flags);\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/copy_file_range.2:256
#, no-wrap
msgid ""
"int\n"
"main(int argc, char **argv)\n"
"{\n"
"    int fd_in, fd_out;\n"
"    struct stat stat;\n"
"    loff_t len, ret;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/copy_file_range.2:261
#, no-wrap
msgid ""
"    if (argc != 3) {\n"
"        fprintf(stderr, \"Usage: %s E<lt>sourceE<gt> "
"E<lt>destinationE<gt>\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/copy_file_range.2:267
#, no-wrap
msgid ""
"    fd_in = open(argv[1], O_RDONLY);\n"
"    if (fd_in == -1) {\n"
"        perror(\"open (argv[1])\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/copy_file_range.2:272
#, no-wrap
msgid ""
"    if (fstat(fd_in, &stat) == -1) {\n"
"        perror(\"fstat\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/copy_file_range.2:274
#, no-wrap
msgid "    len = stat.st_size;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/copy_file_range.2:280
#, no-wrap
msgid ""
"    fd_out = open(argv[2], O_CREAT | O_WRONLY | O_TRUNC, 0644);\n"
"    if (fd_out == -1) {\n"
"        perror(\"open (argv[2])\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/copy_file_range.2:287
#, no-wrap
msgid ""
"    do {\n"
"        ret = copy_file_range(fd_in, NULL, fd_out, NULL, len, 0);\n"
"        if (ret == -1) {\n"
"            perror(\"copy_file_range\");\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/copy_file_range.2:290
#, no-wrap
msgid ""
"        len -= ret;\n"
"    } while (len E<gt> 0 && ret E<gt> 0);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/copy_file_range.2:295
#, no-wrap
msgid ""
"    close(fd_in);\n"
"    close(fd_out);\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/copy_file_range.2:299
msgid "B<lseek>(2), B<sendfile>(2), B<splice>(2)"
msgstr ""

#. type: TH
#: man-pages/man2/sched_setparam.2:30
#, no-wrap
msgid "SCHED_SETPARAM"
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_setparam.2:33
msgid "sched_setparam, sched_getparam - set and get scheduling parameters"
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_setparam.2:36 man-pages/man2/sched_setscheduler.2:33
#: man-pages/man2/sched_setattr.2:33
#, no-wrap
msgid "B<#include E<lt>sched.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_setparam.2:38
#, no-wrap
msgid ""
"B<int sched_setparam(pid_t >I<pid>B<, const struct sched_param "
"*>I<param>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_setparam.2:40
#, no-wrap
msgid "B<int sched_getparam(pid_t >I<pid>B<, struct sched_param *>I<param>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_setparam.2:46
#, no-wrap
msgid ""
"B<struct sched_param {\n"
"    ...\n"
"    int >I<sched_priority>B<;\n"
"    ...\n"
"};>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_setparam.2:60
msgid ""
"B<sched_setparam>()  sets the scheduling parameters associated with the "
"scheduling policy for the thread whose thread ID is specified in I<pid>.  If "
"I<pid> is zero, then the parameters of the calling thread are set.  The "
"interpretation of the argument I<param> depends on the scheduling policy of "
"the thread identified by I<pid>.  See B<sched>(7)  for a description of the "
"scheduling policies supported under Linux."
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_setparam.2:66
msgid ""
"B<sched_getparam>()  retrieves the scheduling parameters for the thread "
"identified by I<pid>.  If I<pid> is zero, then the parameters of the calling "
"thread are retrieved."
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_setparam.2:75
msgid ""
"B<sched_setparam>()  checks the validity of I<param> for the scheduling "
"policy of the thread.  The value I<param-E<gt>sched_priority> must lie "
"within the range given by B<sched_get_priority_min>(2)  and "
"B<sched_get_priority_max>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_setparam.2:79
msgid ""
"For a discussion of the privileges and resource limits related to scheduling "
"priority and policy, see B<sched>(7)."
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_setparam.2:87
msgid ""
"POSIX systems on which B<sched_setparam>()  and B<sched_getparam>()  are "
"available define B<_POSIX_PRIORITY_SCHEDULING> in I<E<lt>unistd.hE<gt>>."
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_setparam.2:96
msgid ""
"On success, B<sched_setparam>()  and B<sched_getparam>()  return 0.  On "
"error, -1 is returned, and I<errno> is set appropriately."
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_setparam.2:104
msgid "Invalid arguments: I<param> is NULL or I<pid> is negative"
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_setparam.2:109
msgid ""
"(B<sched_setparam>())  The argument I<param> does not make sense for the "
"current scheduling policy."
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_setparam.2:116
msgid ""
"(B<sched_setparam>())  The caller does not have appropriate privileges "
"(Linux: does not have the B<CAP_SYS_NICE> capability)."
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_setparam.2:119 man-pages/man2/sched_setscheduler.2:168
#: man-pages/man2/sched_setattr.2:326 man-pages/man2/sched_setaffinity.2:154
msgid "The thread whose ID is I<pid> could not be found."
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_setparam.2:136
msgid ""
"B<getpriority>(2), B<gettid>(2), B<nice>(2), B<sched_get_priority_max>(2), "
"B<sched_get_priority_min>(2), B<sched_getaffinity>(2), "
"B<sched_getscheduler>(2), B<sched_setaffinity>(2), B<sched_setattr>(2), "
"B<sched_setscheduler>(2), B<setpriority>(2), B<capabilities>(7), B<sched>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/sched_yield.2:29
#, no-wrap
msgid "SCHED_YIELD"
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_yield.2:32
msgid "sched_yield - yield the processor"
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_yield.2:36
msgid "B<int sched_yield(void);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_yield.2:41
msgid ""
"B<sched_yield>()  causes the calling thread to relinquish the CPU.  The "
"thread is moved to the end of the queue for its static priority and a new "
"thread gets to run."
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_yield.2:48
msgid ""
"On success, B<sched_yield>()  returns 0.  On error, -1 is returned, and "
"I<errno> is set appropriately."
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_yield.2:52
msgid "In the Linux implementation, B<sched_yield>()  always succeeds."
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_yield.2:59
msgid ""
"If the calling thread is the only thread in the highest priority list at "
"that time, it will continue to run after a call to B<sched_yield>()."
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_yield.2:66
msgid ""
"POSIX systems on which B<sched_yield>()  is available define "
"B<_POSIX_PRIORITY_SCHEDULING> in I<E<lt>unistd.hE<gt>>."
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_yield.2:79
msgid ""
"Strategic calls to B<sched_yield>()  can improve performance by giving other "
"threads or processes a chance to run when (heavily) contended resources "
"(e.g., mutexes)  have been released by the caller.  Avoid calling "
"B<sched_yield>()  unnecessarily or inappropriately (e.g., when resources "
"needed by other schedulable threads are still held by the caller), since "
"doing so will result in unnecessary context switches, which will degrade "
"system performance."
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_yield.2:90
msgid ""
"B<sched_yield>()  is intended for use with real-time scheduling policies "
"(i.e., B<SCHED_FIFO> or B<SCHED_RR>).  Use of B<sched_yield>()  with "
"nondeterministic scheduling policies such as B<SCHED_OTHER> is unspecified "
"and very likely means your application design is broken."
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_yield.2:91 man-pages/man2/sched_rr_get_interval.2:133
msgid "B<sched>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/access.2:43
#, no-wrap
msgid "ACCESS"
msgstr ""

#. type: Plain text
#: man-pages/man2/access.2:46
msgid "access, faccessat - check user's permissions for a file"
msgstr ""

#. type: Plain text
#: man-pages/man2/access.2:51
#, no-wrap
msgid "B<int access(const char *>I<pathname>B<, int >I<mode>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/access.2:54 man-pages/man2/unlink.2:44
#: man-pages/man2/symlink.2:44 man-pages/man2/chown.2:51
#: man-pages/man2/link.2:43 man-pages/man2/readlink.2:56
#, no-wrap
msgid ""
"B<#include E<lt>fcntl.hE<gt>           >/* Definition of AT_* constants */\n"
"B<#include E<lt>unistd.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/access.2:57
#, no-wrap
msgid ""
"B<int faccessat(int >I<dirfd>B<, const char *>I<pathname>B<, int >I<mode>B<, "
"int >I<flags>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/access.2:65
msgid "B<faccessat>():"
msgstr ""

#. type: Plain text
#: man-pages/man2/access.2:84
msgid ""
"B<access>()  checks whether the calling process can access the file "
"I<pathname>.  If I<pathname> is a symbolic link, it is dereferenced."
msgstr ""

#.  F_OK is defined as 0 on every system that I know of.
#. type: Plain text
#: man-pages/man2/access.2:98
msgid ""
"The I<mode> specifies the accessibility check(s) to be performed, and is "
"either the value B<F_OK>, or a mask consisting of the bitwise OR of one or "
"more of B<R_OK>, B<W_OK>, and B<X_OK>.  B<F_OK> tests for the existence of "
"the file.  B<R_OK>, B<W_OK>, and B<X_OK> test whether the file exists and "
"grants read, write, and execute permissions, respectively."
msgstr ""

#. type: Plain text
#: man-pages/man2/access.2:109
msgid ""
"The check is done using the calling process's I<real> UID and GID, rather "
"than the effective IDs as is done when actually attempting an operation "
"(e.g., B<open>(2))  on the file.  Similarly, for the root user, the check "
"uses the set of permitted capabilities rather than the set of effective "
"capabilities; and for non-root users, the check uses an empty set of "
"capabilities."
msgstr ""

#. type: Plain text
#: man-pages/man2/access.2:122
msgid ""
"This allows set-user-ID programs and capability-endowed programs to easily "
"determine the invoking user's authority.  In other words, B<access>()  does "
"not answer the \"can I read/write/execute this file?\" question.  It answers "
"a slightly different question: \"(assuming I'm a setuid binary) can I<the "
"user who invoked me> read/write/execute this file?\", which gives "
"set-user-ID programs the possibility to prevent malicious users from causing "
"them to read files which users shouldn't be able to read."
msgstr ""

#. type: Plain text
#: man-pages/man2/access.2:128
msgid ""
"If the calling process is privileged (i.e., its real UID is zero), then an "
"B<X_OK> check is successful for a regular file if execute permission is "
"enabled for any of the file owner, group, or other."
msgstr ""

#. type: SS
#: man-pages/man2/access.2:128
#, no-wrap
msgid "faccessat()"
msgstr ""

#. type: Plain text
#: man-pages/man2/access.2:134
msgid ""
"The B<faccessat>()  system call operates in exactly the same way as "
"B<access>(), except for the differences described here."
msgstr ""

#. type: Plain text
#: man-pages/man2/access.2:144
msgid ""
"If the pathname given in I<pathname> is relative, then it is interpreted "
"relative to the directory referred to by the file descriptor I<dirfd> "
"(rather than relative to the current working directory of the calling "
"process, as is done by B<access>()  for a relative pathname)."
msgstr ""

#. type: Plain text
#: man-pages/man2/access.2:156
msgid ""
"If I<pathname> is relative and I<dirfd> is the special value B<AT_FDCWD>, "
"then I<pathname> is interpreted relative to the current working directory of "
"the calling process (like B<access>())."
msgstr ""

#. type: Plain text
#: man-pages/man2/access.2:165
msgid ""
"I<flags> is constructed by ORing together zero or more of the following "
"values:"
msgstr ""

#. type: TP
#: man-pages/man2/access.2:165
#, no-wrap
msgid "B<AT_EACCESS>"
msgstr ""

#. type: Plain text
#: man-pages/man2/access.2:172
msgid ""
"Perform access checks using the effective user and group IDs.  By default, "
"B<faccessat>()  uses the real IDs (like B<access>())."
msgstr ""

#. type: Plain text
#: man-pages/man2/access.2:178
msgid ""
"If I<pathname> is a symbolic link, do not dereference it: instead return "
"information about the link itself."
msgstr ""

#. type: Plain text
#: man-pages/man2/access.2:183
msgid "See B<openat>(2)  for an explanation of the need for B<faccessat>()."
msgstr ""

#. type: Plain text
#: man-pages/man2/access.2:199
msgid ""
"On success (all requested permissions granted, or I<mode> is B<F_OK> and the "
"file exists), zero is returned.  On error (at least one bit in I<mode> asked "
"for a permission that is denied, or I<mode> is B<F_OK> and the file does not "
"exist, or some other error occurred), -1 is returned, and I<errno> is set "
"appropriately."
msgstr ""

#. type: Plain text
#: man-pages/man2/access.2:204
msgid "B<access>()  and B<faccessat>()  shall fail if:"
msgstr ""

#. type: Plain text
#: man-pages/man2/access.2:211
msgid ""
"The requested access would be denied to the file, or search permission is "
"denied for one of the directories in the path prefix of I<pathname>.  (See "
"also B<path_resolution>(7).)"
msgstr ""

#. type: Plain text
#: man-pages/man2/access.2:224 man-pages/man2/stat.2:406
msgid "A component of I<pathname> does not exist or is a dangling symbolic link."
msgstr ""

#. type: Plain text
#: man-pages/man2/access.2:232
msgid "Write permission was requested for a file on a read-only filesystem."
msgstr ""

#. type: Plain text
#: man-pages/man2/access.2:237
msgid "B<access>()  and B<faccessat>()  may fail if:"
msgstr ""

#. type: Plain text
#: man-pages/man2/access.2:245
msgid "I<mode> was incorrectly specified."
msgstr ""

#. type: Plain text
#: man-pages/man2/access.2:255
msgid "Write access was requested to an executable which is being executed."
msgstr ""

#. type: Plain text
#: man-pages/man2/access.2:258
msgid "The following additional errors can occur for B<faccessat>():"
msgstr ""

#. type: Plain text
#: man-pages/man2/access.2:276
msgid ""
"B<faccessat>()  was added to Linux in kernel 2.6.16; library support was "
"added to glibc in version 2.4."
msgstr ""

#. type: Plain text
#: man-pages/man2/access.2:279
msgid "B<access>(): SVr4, 4.3BSD, POSIX.1-2001, POSIX.1-2008."
msgstr ""

#. type: Plain text
#: man-pages/man2/access.2:282
msgid "B<faccessat>(): POSIX.1-2008."
msgstr ""

#. type: Plain text
#: man-pages/man2/access.2:295
msgid ""
"B<Warning>: Using these calls to check if a user is authorized to, for "
"example, open a file before actually doing so using B<open>(2)  creates a "
"security hole, because the user might exploit the short time interval "
"between checking and opening the file to manipulate it.  B<For this reason, "
"the use of this system call should be avoided>.  (In the example just "
"described, a safer alternative would be to temporarily switch the process's "
"effective user ID to the real ID and then call B<open>(2).)"
msgstr ""

#. type: Plain text
#: man-pages/man2/access.2:302
msgid ""
"B<access>()  always dereferences symbolic links.  If you need to check the "
"permissions on a symbolic link, use B<faccessat>()  with the flag "
"B<AT_SYMLINK_NOFOLLOW>."
msgstr ""

#. type: Plain text
#: man-pages/man2/access.2:308
msgid ""
"These calls return an error if any of the access types in I<mode> is denied, "
"even if some of the other access types in I<mode> are permitted."
msgstr ""

#.  HPU-UX 11 and Tru64 5.1 do this.
#. type: Plain text
#: man-pages/man2/access.2:315
msgid ""
"If the calling process has appropriate privileges (i.e., is superuser), "
"POSIX.1-2001 permits an implementation to indicate success for an B<X_OK> "
"check even if none of the execute file permission bits are set.  Linux does "
"not do this."
msgstr ""

#. type: Plain text
#: man-pages/man2/access.2:323
msgid ""
"A file is accessible only if the permissions on each of the directories in "
"the path prefix of I<pathname> grant search (i.e., execute) access.  If any "
"directory is inaccessible, then the B<access>()  call fails, regardless of "
"the permissions on the file itself."
msgstr ""

#. type: Plain text
#: man-pages/man2/access.2:331
msgid ""
"Only access bits are checked, not the file type or contents.  Therefore, if "
"a directory is found to be writable, it probably means that files can be "
"created in the directory, and not that the directory can be written as a "
"file.  Similarly, a DOS file may be found to be \"executable,\" but the "
"B<execve>(2)  call will still fail."
msgstr ""

#. type: Plain text
#: man-pages/man2/access.2:340
msgid ""
"These calls may not work correctly on NFSv2 filesystems with UID mapping "
"enabled, because UID mapping is done on the server and hidden from the "
"client, which checks permissions.  (NFS versions 3 and higher perform the "
"check on the server.)  Similar problems can occur to FUSE mounts."
msgstr ""

#. type: Plain text
#: man-pages/man2/access.2:353
msgid ""
"The raw B<faccessat>()  system call takes only the first three arguments.  "
"The B<AT_EACCESS> and B<AT_SYMLINK_NOFOLLOW> flags are actually implemented "
"within the glibc wrapper function for B<faccessat>().  If either of these "
"flags is specified, then the wrapper function employs B<fstatat>(2)  to "
"determine access permissions."
msgstr ""

#. type: Plain text
#: man-pages/man2/access.2:371
msgid ""
"On older kernels where B<faccessat>()  is unavailable (and when the "
"B<AT_EACCESS> and B<AT_SYMLINK_NOFOLLOW> flags are not specified), the glibc "
"wrapper function falls back to the use of B<access>().  When I<pathname> is "
"a relative pathname, glibc constructs a pathname based on the symbolic link "
"in I</proc/self/fd> that corresponds to the I<dirfd> argument."
msgstr ""

#.  This behavior appears to have been an implementation accident.
#. type: Plain text
#: man-pages/man2/access.2:394
msgid ""
"In kernel 2.4 (and earlier) there is some strangeness in the handling of "
"B<X_OK> tests for superuser.  If all categories of execute permission are "
"disabled for a nondirectory file, then the only B<access>()  test that "
"returns -1 is when I<mode> is specified as just B<X_OK>; if B<R_OK> or "
"B<W_OK> is also specified in I<mode>, then B<access>()  returns 0 for such "
"files.  Early 2.6 kernels (up to and including 2.6.3)  also behaved in the "
"same way as kernel 2.4."
msgstr ""

#. type: Plain text
#: man-pages/man2/access.2:404
msgid ""
"In kernels before 2.6.20, these calls ignored the effect of the B<MS_NOEXEC> "
"flag if it was used to B<mount>(2)  the underlying filesystem.  Since kernel "
"2.6.20, the B<MS_NOEXEC> flag is honored."
msgstr ""

#. type: Plain text
#: man-pages/man2/access.2:414
msgid ""
"B<chmod>(2), B<chown>(2), B<open>(2), B<setgid>(2), B<setuid>(2), "
"B<stat>(2), B<euidaccess>(3), B<credentials>(7), B<path_resolution>(7), "
"B<symlink>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/intro.2:29
#, no-wrap
msgid "INTRO"
msgstr ""

#. type: Plain text
#: man-pages/man2/intro.2:32
msgid "intro - introduction to system calls"
msgstr ""

#. type: Plain text
#: man-pages/man2/intro.2:42
msgid ""
"Section 2 of the manual describes the Linux system calls.  A system call is "
"an entry point into the Linux kernel.  Usually, system calls are not invoked "
"directly: instead, most system calls have corresponding C library wrapper "
"functions which perform the steps required (e.g., trapping to kernel mode) "
"in order to invoke the system call.  Thus, making a system call looks the "
"same as invoking a normal library function."
msgstr ""

#. type: Plain text
#: man-pages/man2/intro.2:44
msgid "In many cases, the C library wrapper function does nothing more than:"
msgstr ""

#. type: Plain text
#: man-pages/man2/intro.2:47
msgid ""
"copying arguments and the unique system call number to the registers where "
"the kernel expects them;"
msgstr ""

#. type: Plain text
#: man-pages/man2/intro.2:50
msgid ""
"trapping to kernel mode, at which point the kernel does the real work of the "
"system call;"
msgstr ""

#. type: Plain text
#: man-pages/man2/intro.2:55
msgid ""
"setting I<errno> if the system call returns an error number when the kernel "
"returns the CPU to user mode."
msgstr ""

#. type: Plain text
#: man-pages/man2/intro.2:65
msgid ""
"However, in a few cases, a wrapper function may do rather more than this, "
"for example, performing some preprocessing of the arguments before trapping "
"to kernel mode, or postprocessing of values returned by the system call.  "
"Where this is the case, the manual pages in Section 2 generally try to note "
"the details of both the (usually GNU) C library API interface and the raw "
"system call.  Most commonly, the main DESCRIPTION will focus on the C "
"library interface, and differences for the system call are covered in the "
"NOTES section."
msgstr ""

#. type: Plain text
#: man-pages/man2/intro.2:68
msgid "For a list of the Linux system calls, see B<syscalls>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/intro.2:77
msgid ""
"On error, most system calls return a negative error number (i.e., the "
"negated value of one of the constants described in B<errno>(3)).  The C "
"library wrapper hides this detail from the caller: when a system call "
"returns a negative value, the wrapper copies the absolute value into the "
"I<errno> variable, and returns -1 as the return value of the wrapper."
msgstr ""

#. type: Plain text
#: man-pages/man2/intro.2:82
msgid ""
"The value returned by a successful system call depends on the call.  Many "
"system calls return 0 on success, but some can return nonzero values from a "
"successful call.  The details are described in the individual manual pages."
msgstr ""

#. type: Plain text
#: man-pages/man2/intro.2:93
msgid ""
"In some cases, the programmer must define a feature test macro in order to "
"obtain the declaration of a system call from the header file specified in "
"the man page SYNOPSIS section.  (Where required, these feature test macros "
"must be defined before including I<any> header files.)  In such cases, the "
"required macro is described in the man page.  For further information on "
"feature test macros, see B<feature_test_macros>(7)."
msgstr ""

#. type: Plain text
#: man-pages/man2/intro.2:98
msgid ""
"Certain terms and abbreviations are used to indicate UNIX variants and "
"standards to which calls in this section conform.  See B<standards>(7)."
msgstr ""

#. type: SS
#: man-pages/man2/intro.2:99
#, no-wrap
msgid "Calling directly"
msgstr ""

#. type: Plain text
#: man-pages/man2/intro.2:108
msgid ""
"In most cases, it is unnecessary to invoke a system call directly, but there "
"are times when the Standard C library does not implement a nice wrapper "
"function for you.  In this case, the programmer must manually invoke the "
"system call using B<syscall>(2).  Historically, this was also possible using "
"one of the _syscall macros described in B<_syscall>(2)."
msgstr ""

#. type: SS
#: man-pages/man2/intro.2:108
#, no-wrap
msgid "Authors and copyright conditions"
msgstr ""

#. type: Plain text
#: man-pages/man2/intro.2:112
msgid ""
"Look at the header of the manual page source for the author(s) and copyright "
"conditions.  Note that these can be different from page to page!"
msgstr ""

#. type: Plain text
#: man-pages/man2/intro.2:134
msgid ""
"B<_syscall>(2), B<syscall>(2), B<syscalls>(2), B<errno>(3), B<intro>(3), "
"B<capabilities>(7), B<credentials>(7), B<feature_test_macros>(7), "
"B<mq_overview>(7), B<path_resolution>(7), B<pipe>(7), B<pty>(7), "
"B<sem_overview>(7), B<shm_overview>(7), B<signal>(7), B<socket>(7), "
"B<standards>(7), B<symlink>(7), B<sysvipc>(7), B<time>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/uselib.2:31
#, no-wrap
msgid "USELIB"
msgstr ""

#. type: Plain text
#: man-pages/man2/uselib.2:34
msgid "uselib - load shared library"
msgstr ""

#. type: Plain text
#: man-pages/man2/uselib.2:38
msgid "B<int uselib(const char *>I<library>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/uselib.2:51
msgid ""
"The system call B<uselib>()  serves to load a shared library to be used by "
"the calling process.  It is given a pathname.  The address where to load is "
"found in the library itself.  The library can have any recognized binary "
"format."
msgstr ""

#. type: Plain text
#: man-pages/man2/uselib.2:62
msgid ""
"In addition to all of the error codes returned by B<open>(2)  and "
"B<mmap>(2), the following may also be returned:"
msgstr ""

#. type: Plain text
#: man-pages/man2/uselib.2:70
msgid ""
"The library specified by I<library> does not have read or execute "
"permission, or the caller does not have search permission for one of the "
"directories in the path prefix.  (See also B<path_resolution>(7).)"
msgstr ""

#. type: TP
#: man-pages/man2/uselib.2:73 man-pages/man2/kexec_load.2:313
#: man-pages/man2/init_module.2:217 man-pages/man2/init_module.2:240
#: man-pages/man2/execve.2:510
#, no-wrap
msgid "B<ENOEXEC>"
msgstr ""

#. type: Plain text
#: man-pages/man2/uselib.2:79
msgid ""
"The file specified by I<library> is not an executable of a known type; for "
"example, it does not have the correct magic numbers."
msgstr ""

#. type: Plain text
#: man-pages/man2/uselib.2:83
msgid ""
"B<uselib>()  is Linux-specific, and should not be used in programs intended "
"to be portable."
msgstr ""

#. type: Plain text
#: man-pages/man2/uselib.2:91 man-pages/man2/get_kernel_syms.2:78
#: man-pages/man2/create_module.2:76
msgid ""
"This obsolete system call is not supported by glibc.  No declaration is "
"provided in glibc headers, but, through a quirk of history, glibc versions "
"before 2.23 did export an ABI for this system call.  Therefore, in order to "
"employ this system call, it was sufficient to manually declare the interface "
"in your code; alternatively, you could invoke the system call using "
"B<syscall>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/uselib.2:97
msgid ""
"In ancient libc versions, B<uselib>()  was used to load the shared libraries "
"with names found in an array of names in the binary."
msgstr ""

#.  libc 4.3.1f - changelog 1993-03-02
#.  libc 4.3.4 - changelog 1993-04-21
#. type: Plain text
#: man-pages/man2/uselib.2:107
msgid ""
"Since libc 4.3.2, startup code tries to prefix these names with "
"\"/usr/lib\", \"/lib\" and \"\" before giving up.  In libc 4.3.4 and later "
"these names are looked for in the directories found in B<LD_LIBRARY_PATH>, "
"and if not found there, prefixes \"/usr/lib\", \"/lib\" and \"/\" are tried."
msgstr ""

#. type: Plain text
#: man-pages/man2/uselib.2:112
msgid ""
"From libc 4.4.4 on only the library \"/lib/ld.so\" is loaded, so that this "
"dynamic library can load the remaining libraries needed (again using this "
"call).  This is also the state of affairs in libc5."
msgstr ""

#. type: Plain text
#: man-pages/man2/uselib.2:114
msgid "glibc2 does not use this call."
msgstr ""

#.  commit 69369a7003735d0d8ef22097e27a55a8bad9557a
#. type: Plain text
#: man-pages/man2/uselib.2:120
msgid ""
"Since Linux 3.15, this system call is available only when the kernel is "
"configured with the B<CONFIG_USELIB> option."
msgstr ""

#. type: Plain text
#: man-pages/man2/uselib.2:129
msgid ""
"B<ar>(1), B<gcc>(1), B<ld>(1), B<ldd>(1), B<mmap>(2), B<open>(2), "
"B<dlopen>(3), B<capabilities>(7), B<ld.so>(8)"
msgstr ""

#. type: TH
#: man-pages/man2/kexec_load.2:27
#, no-wrap
msgid "KEXEC_LOAD"
msgstr ""

#. type: Plain text
#: man-pages/man2/kexec_load.2:30
msgid "kexec_load, kexec_file_load - load a new kernel for later execution"
msgstr ""

#. type: Plain text
#: man-pages/man2/kexec_load.2:33
#, no-wrap
msgid "B<#include E<lt>linux/kexec.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/kexec_load.2:37
#, no-wrap
msgid ""
"B<long kexec_load(unsigned long >I<entry>B<, unsigned long "
">I<nr_segments>B<,>\n"
"B<                struct kexec_segment *>I<segments>B<, unsigned long "
">I<flags>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/kexec_load.2:42
#, no-wrap
msgid ""
"B<long kexec_file_load(int >I<kernel_fd>B<, int >I<initrd_fd>B<,>\n"
"B<                    unsigned long >I<cmdline_len>B<, const char "
"*>I<cmdline>B<,>\n"
"B<                    unsigned long >I<flags>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/kexec_load.2:51
msgid ""
"The B<kexec_load>()  system call loads a new kernel that can be executed "
"later by B<reboot>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/kexec_load.2:57
msgid ""
"The I<flags> argument is a bit mask that controls the operation of the "
"call.  The following values can be specified in I<flags>:"
msgstr ""

#. type: TP
#: man-pages/man2/kexec_load.2:57
#, no-wrap
msgid "B<KEXEC_ON_CRASH> (since Linux 2.6.13)"
msgstr ""

#. type: Plain text
#: man-pages/man2/kexec_load.2:73
msgid ""
"Execute the new kernel automatically on a system crash.  This \"crash "
"kernel\" is loaded into an area of reserved memory that is determined at "
"boot time using the I<crashkernel> kernel command-line parameter.  The "
"location of this reserved memory is exported to user space via the "
"I</proc/iomem> file, in an entry labeled \"Crash kernel\".  A user-space "
"application can parse this file and prepare a list of segments (see below) "
"that specify this reserved memory as destination.  If this flag is "
"specified, the kernel checks that the target segments specified in "
"I<segments> fall within the reserved region."
msgstr ""

#. type: TP
#: man-pages/man2/kexec_load.2:73
#, no-wrap
msgid "B<KEXEC_PRESERVE_CONTEXT> (since Linux 2.6.27)"
msgstr ""

#. type: Plain text
#: man-pages/man2/kexec_load.2:83
msgid ""
"Preserve the system hardware and software states before executing the new "
"kernel.  This could be used for system suspend.  This flag is available only "
"if the kernel was configured with B<CONFIG_KEXEC_JUMP>, and is effective "
"only if I<nr_segments> is greater than 0."
msgstr ""

#. type: Plain text
#: man-pages/man2/kexec_load.2:104
msgid ""
"The high-order bits (corresponding to the mask 0xffff0000) of I<flags> "
"contain the architecture of the to-be-executed kernel.  Specify (OR) the "
"constant B<KEXEC_ARCH_DEFAULT> to use the current architecture, or one of "
"the following architecture constants B<KEXEC_ARCH_386>, B<KEXEC_ARCH_68K>, "
"B<KEXEC_ARCH_X86_64>, B<KEXEC_ARCH_PPC>, B<KEXEC_ARCH_PPC64>, "
"B<KEXEC_ARCH_IA_64>, B<KEXEC_ARCH_ARM>, B<KEXEC_ARCH_S390>, "
"B<KEXEC_ARCH_SH>, B<KEXEC_ARCH_MIPS>, and B<KEXEC_ARCH_MIPS_LE>.  The "
"architecture must be executable on the CPU of the system."
msgstr ""

#. type: Plain text
#: man-pages/man2/kexec_load.2:119
msgid ""
"The I<entry> argument is the physical entry address in the kernel image.  "
"The I<nr_segments> argument is the number of segments pointed to by the "
"I<segments> pointer; the kernel imposes an (arbitrary) limit of 16 on the "
"number of segments.  The I<segments> argument is an array of "
"I<kexec_segment> structures which define the kernel layout:"
msgstr ""

#. type: Plain text
#: man-pages/man2/kexec_load.2:128
#, no-wrap
msgid ""
"struct kexec_segment {\n"
"    void   *buf;        /* Buffer in user space */\n"
"    size_t  bufsz;      /* Buffer length in user space */\n"
"    void   *mem;        /* Physical address of kernel */\n"
"    size_t  memsz;      /* Physical address length */\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/kexec_load.2:145
msgid ""
"The kernel image defined by I<segments> is copied from the calling process "
"into the kernel either in regular memory or in reserved memory (if "
"B<KEXEC_ON_CRASH> is set).  The kernel first performs various sanity checks "
"on the information passed in I<segments>.  If these checks pass, the kernel "
"copies the segment data to kernel memory.  Each segment specified in "
"I<segments> is copied as follows:"
msgstr ""

#. type: Plain text
#: man-pages/man2/kexec_load.2:156
msgid ""
"I<buf> and I<bufsz> identify a memory region in the caller's virtual address "
"space that is the source of the copy.  The value in I<bufsz> may not exceed "
"the value in the I<memsz> field."
msgstr ""

#. type: Plain text
#: man-pages/man2/kexec_load.2:163
msgid ""
"I<mem> and I<memsz> specify a physical address range that is the target of "
"the copy.  The values specified in both fields must be multiples of the "
"system page size."
msgstr ""

#. type: Plain text
#: man-pages/man2/kexec_load.2:171
msgid ""
"I<bufsz> bytes are copied from the source buffer to the target kernel "
"buffer.  If I<bufsz> is less than I<memsz>, then the excess bytes in the "
"kernel buffer are zeroed out."
msgstr ""

#. type: Plain text
#: man-pages/man2/kexec_load.2:180
msgid ""
"In case of a normal kexec (i.e., the B<KEXEC_ON_CRASH> flag is not set), the "
"segment data is loaded in any available memory and is moved to the final "
"destination at kexec reboot time (e.g., when the B<kexec>(8)  command is "
"executed with the I<-e> option)."
msgstr ""

#. type: Plain text
#: man-pages/man2/kexec_load.2:186
msgid ""
"In case of kexec on panic (i.e., the B<KEXEC_ON_CRASH> flag is set), the "
"segment data is loaded to reserved memory at the time of the call, and, "
"after a crash, the kexec mechanism simply passes control to that kernel."
msgstr ""

#. type: Plain text
#: man-pages/man2/kexec_load.2:191
msgid ""
"The B<kexec_load>()  system call is available only if the kernel was "
"configured with B<CONFIG_KEXEC>."
msgstr ""

#. type: SS
#: man-pages/man2/kexec_load.2:191
#, no-wrap
msgid "kexec_file_load()"
msgstr ""

#. type: Plain text
#: man-pages/man2/kexec_load.2:211
msgid ""
"The B<kexec_file_load>()  system call is similar to B<kexec_load>(), but it "
"takes a different set of arguments.  It reads the kernel to be loaded from "
"the file referred to by the file descriptor I<kernel_fd>, and the initrd "
"(initial RAM disk)  to be loaded from file referred to by the file "
"descriptor I<initrd_fd>.  The I<cmdline> argument is a pointer to a buffer "
"containing the command line for the new kernel.  The I<cmdline_len> argument "
"specifies size of the buffer.  The last byte in the buffer must be a null "
"byte (\\(aq\\e0\\(aq)."
msgstr ""

#. type: Plain text
#: man-pages/man2/kexec_load.2:217
msgid ""
"The I<flags> argument is a bit mask which modifies the behavior of the "
"call.  The following values can be specified in I<flags>:"
msgstr ""

#. type: TP
#: man-pages/man2/kexec_load.2:217
#, no-wrap
msgid "B<KEXEC_FILE_UNLOAD>"
msgstr ""

#. type: Plain text
#: man-pages/man2/kexec_load.2:220
msgid "Unload the currently loaded kernel."
msgstr ""

#. type: TP
#: man-pages/man2/kexec_load.2:220
#, no-wrap
msgid "B<KEXEC_FILE_ON_CRASH>"
msgstr ""

#. type: Plain text
#: man-pages/man2/kexec_load.2:226
msgid ""
"Load the new kernel in the memory region reserved for the crash kernel (as "
"for B<KEXEC_ON_CRASH>).  This kernel is booted if the currently running "
"kernel crashes."
msgstr ""

#. type: TP
#: man-pages/man2/kexec_load.2:226
#, no-wrap
msgid "B<KEXEC_FILE_NO_INITRAMFS>"
msgstr ""

#. type: Plain text
#: man-pages/man2/kexec_load.2:233
msgid ""
"Loading initrd/initramfs is optional.  Specify this flag if no initramfs is "
"being loaded.  If this flag is set, the value passed in I<initrd_fd> is "
"ignored."
msgstr ""

#.  See also http://lwn.net/Articles/603116/
#. type: Plain text
#: man-pages/man2/kexec_load.2:242
msgid ""
"The B<kexec_file_load>()  system call was added to provide support for "
"systems where \"kexec\" loading should be restricted to only kernels that "
"are signed.  This system call is available only if the kernel was configured "
"with B<CONFIG_KEXEC_FILE>."
msgstr ""

#. type: Plain text
#: man-pages/man2/kexec_load.2:247
msgid ""
"On success, these system calls returns 0.  On error, -1 is returned and "
"I<errno> is set to indicate the error."
msgstr ""

#.  See kernel/kexec.::sanity_check_segment_list in the 3.19 kernel source
#. type: Plain text
#: man-pages/man2/kexec_load.2:260
msgid ""
"The B<KEXEC_ON_CRASH> flags was specified, but the region specified by the "
"I<mem> and I<memsz> fields of one of the I<segments> entries lies outside "
"the range of memory reserved for the crash kernel."
msgstr ""

#. type: Plain text
#: man-pages/man2/kexec_load.2:269
msgid ""
"The value in a I<mem> or I<memsz> field in one of the I<segments> entries is "
"not a multiple of the system page size."
msgstr ""

#. type: Plain text
#: man-pages/man2/kexec_load.2:275
msgid "I<kernel_fd> or I<initrd_fd> is not a valid file descriptor."
msgstr ""

#. type: Plain text
#: man-pages/man2/kexec_load.2:279
msgid ""
"Another crash kernel is already being loaded or a crash kernel is already in "
"use."
msgstr ""

#. type: Plain text
#: man-pages/man2/kexec_load.2:283 man-pages/man2/timerfd_create.2:465
#: man-pages/man2/init_module.2:240
msgid "I<flags> is invalid."
msgstr ""

#. type: Plain text
#: man-pages/man2/kexec_load.2:292
msgid ""
"The value of a I<bufsz> field in one of the I<segments> entries exceeds the "
"value in the corresponding I<memsz> field."
msgstr ""

#. type: Plain text
#: man-pages/man2/kexec_load.2:298
msgid "I<nr_segments> exceeds B<KEXEC_SEGMENT_MAX> (16)."
msgstr ""

#. type: Plain text
#: man-pages/man2/kexec_load.2:301
msgid "Two or more of the kernel target buffers overlap."
msgstr ""

#. type: Plain text
#: man-pages/man2/kexec_load.2:306
msgid "The value in I<cmdline[cmdline_len-1]> is not \\(aq\\e0\\(aq."
msgstr ""

#. type: Plain text
#: man-pages/man2/kexec_load.2:313
msgid "The file referred to by I<kernel_fd> or I<initrd_fd> is empty (length zero)."
msgstr ""

#. type: Plain text
#: man-pages/man2/kexec_load.2:320
msgid ""
"I<kernel_fd> does not refer to an open file, or the kernel can't load this "
"file.  Currently, the file must be a bzImage and contain an x86 kernel that "
"is loadable above 4\\ GiB in memory (see the kernel source file "
"I<Documentation/x86/boot.txt>)."
msgstr ""

#.  glibc layer: malloc()
#. type: Plain text
#: man-pages/man2/kexec_load.2:323 man-pages/man2/timer_create.2:219
msgid "Could not allocate memory."
msgstr ""

#. type: Plain text
#: man-pages/man2/kexec_load.2:328
msgid "The caller does not have the B<CAP_SYS_BOOT> capability."
msgstr ""

#. type: Plain text
#: man-pages/man2/kexec_load.2:335
msgid ""
"The B<kexec_load>()  system call first appeared in Linux 2.6.13.  The "
"B<kexec_file_load>()  system call first appeared in Linux 3.17."
msgstr ""

#. type: Plain text
#: man-pages/man2/kexec_load.2:341
msgid ""
"Currently, there is no glibc support for these system calls.  Call them "
"using B<syscall>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/kexec_load.2:345
msgid "B<reboot>(2), B<syscall>(2), B<kexec>(8)"
msgstr ""

#. type: Plain text
#: man-pages/man2/kexec_load.2:349
msgid ""
"The kernel source files I<Documentation/kdump/kdump.txt> and "
"I<Documentation/admin-guide/kernel-parameters.txt>"
msgstr ""

#. type: TH
#: man-pages/man2/arch_prctl.2:25
#, no-wrap
msgid "ARCH_PRCTL"
msgstr ""

#. type: Plain text
#: man-pages/man2/arch_prctl.2:28
msgid "arch_prctl - set architecture-specific thread state"
msgstr ""

#. type: Plain text
#: man-pages/man2/arch_prctl.2:32
#, no-wrap
msgid ""
"B<#include E<lt>asm/prctl.hE<gt>>\n"
"B<#include E<lt>sys/prctl.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/arch_prctl.2:35
#, no-wrap
msgid ""
"B<int arch_prctl(int >I<code>B<, unsigned long >I<addr>B<);>\n"
"B<int arch_prctl(int >I<code>B<, unsigned long *>I<addr>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/arch_prctl.2:50
msgid ""
"B<arch_prctl>()  sets architecture-specific process or thread state.  "
"I<code> selects a subfunction and passes argument I<addr> to it; I<addr> is "
"interpreted as either an I<unsigned long> for the \"set\" operations, or as "
"an I<unsigned long\\ *>, for the \"get\" operations."
msgstr ""

#. type: Plain text
#: man-pages/man2/arch_prctl.2:52
msgid "Subfunctions for x86-64 are:"
msgstr ""

#. type: TP
#: man-pages/man2/arch_prctl.2:52
#, no-wrap
msgid "B<ARCH_SET_FS>"
msgstr ""

#. type: Plain text
#: man-pages/man2/arch_prctl.2:58
msgid "Set the 64-bit base for the I<FS> register to I<addr>."
msgstr ""

#. type: TP
#: man-pages/man2/arch_prctl.2:58
#, no-wrap
msgid "B<ARCH_GET_FS>"
msgstr ""

#. type: Plain text
#: man-pages/man2/arch_prctl.2:66
msgid ""
"Return the 64-bit base value for the I<FS> register of the current thread in "
"the I<unsigned long> pointed to by I<addr>."
msgstr ""

#. type: TP
#: man-pages/man2/arch_prctl.2:66
#, no-wrap
msgid "B<ARCH_SET_GS>"
msgstr ""

#. type: Plain text
#: man-pages/man2/arch_prctl.2:72
msgid "Set the 64-bit base for the I<GS> register to I<addr>."
msgstr ""

#. type: TP
#: man-pages/man2/arch_prctl.2:72
#, no-wrap
msgid "B<ARCH_GET_GS>"
msgstr ""

#. type: Plain text
#: man-pages/man2/arch_prctl.2:80
msgid ""
"Return the 64-bit base value for the I<GS> register of the current thread in "
"the I<unsigned long> pointed to by I<addr>."
msgstr ""

#. type: Plain text
#: man-pages/man2/arch_prctl.2:86
msgid ""
"On success, B<arch_prctl>()  returns 0; on error, -1 is returned, and "
"I<errno> is set to indicate the error."
msgstr ""

#. type: Plain text
#: man-pages/man2/arch_prctl.2:91
msgid ""
"I<addr> points to an unmapped address or is outside the process address "
"space."
msgstr ""

#. type: Plain text
#: man-pages/man2/arch_prctl.2:95
msgid "I<code> is not a valid subcommand."
msgstr ""

#.  .SH AUTHOR
#.  Man page written by Andi Kleen.
#. type: Plain text
#: man-pages/man2/arch_prctl.2:101
msgid "I<addr> is outside the process address space."
msgstr ""

#. type: Plain text
#: man-pages/man2/arch_prctl.2:105
msgid ""
"B<arch_prctl>()  is a Linux/x86-64 extension and should not be used in "
"programs intended to be portable."
msgstr ""

#. type: Plain text
#: man-pages/man2/arch_prctl.2:108
msgid ""
"B<arch_prctl>()  is supported only on Linux/x86-64 for 64-bit programs "
"currently."
msgstr ""

#. type: Plain text
#: man-pages/man2/arch_prctl.2:110
msgid "The 64-bit base changes when a new 32-bit segment selector is loaded."
msgstr ""

#. type: Plain text
#: man-pages/man2/arch_prctl.2:113
msgid "B<ARCH_SET_GS> is disabled in some kernels."
msgstr ""

#. type: Plain text
#: man-pages/man2/arch_prctl.2:125
msgid ""
"Context switches for 64-bit segment bases are rather expensive.  As an "
"optimization, if a 32-bit TLS base address is used, B<arch_prctl>()  may use "
"a real TLS entry as if B<set_thread_area>(2)  had been called, instead of "
"manipulating the segment base register directly.  Memory in the first 2\\ GB "
"of address space can be allocated by using B<mmap>(2)  with the B<MAP_32BIT> "
"flag."
msgstr ""

#. type: Plain text
#: man-pages/man2/arch_prctl.2:132
msgid ""
"Because of the aforementioned optimization, using B<arch_prctl>()  and "
"B<set_thread_area>(2)  in the same thread is dangerous, as they may "
"overwrite each other's TLS entries."
msgstr ""

#. type: Plain text
#: man-pages/man2/arch_prctl.2:137
msgid ""
"As of version 2.7, glibc provides no prototype for B<arch_prctl>().  You "
"have to declare it yourself for now.  This may be fixed in future glibc "
"versions."
msgstr ""

#. type: Plain text
#: man-pages/man2/arch_prctl.2:143
msgid ""
"I<FS> may be already used by the threading library.  Programs that use "
"B<ARCH_SET_FS> directly are very likely to crash."
msgstr ""

#. type: Plain text
#: man-pages/man2/arch_prctl.2:148
msgid "B<mmap>(2), B<modify_ldt>(2), B<prctl>(2), B<set_thread_area>(2)"
msgstr ""

#. type: Plain text
#: man-pages/man2/arch_prctl.2:149
msgid "AMD X86-64 Programmer's manual"
msgstr ""

#. type: TH
#: man-pages/man2/mount.2:40
#, no-wrap
msgid "MOUNT"
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:43
msgid "mount - mount filesystem"
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:46 man-pages/man2/umount.2:36
#, no-wrap
msgid "B<#include E<lt>sys/mount.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:50
#, no-wrap
msgid ""
"B<int mount(const char *>I<source>B<, const char *>I<target>B<,>\n"
"B<          const char *>I<filesystemtype>B<, unsigned long "
">I<mountflags>B<,>\n"
"B<          const void *>I<data>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:60
msgid ""
"B<mount>()  attaches the filesystem specified by I<source> (which is often a "
"pathname referring to a device, but can also be the pathname of a directory "
"or file, or a dummy string) to the location (a directory or file)  specified "
"by the pathname in I<target>."
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:64
msgid ""
"Appropriate privilege (Linux: the B<CAP_SYS_ADMIN> capability) is required "
"to mount filesystems."
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:73
msgid ""
"Values for the I<filesystemtype> argument supported by the kernel are listed "
"in I</proc/filesystems> (e.g., \"btrfs\", \"ext4\", \"jfs\", \"xfs\", "
"\"vfat\", \"fuse\", \"tmpfs\", \"cgroup\", \"proc\", \"mqueue\", \"nfs\", "
"\"cifs\", \"iso9660\").  Further types may become available when the "
"appropriate modules are loaded."
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:82
msgid ""
"The I<data> argument is interpreted by the different filesystems.  Typically "
"it is a string of comma-separated options understood by this filesystem.  "
"See B<mount>(8)  for details of the options available for each filesystem "
"type."
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:92
msgid ""
"A call to B<mount>()  performs one of a number of general types of "
"operation, depending on the bits specified in I<mountflags>.  The choice of "
"which operation to perform is determined by testing the bits set in "
"I<mountflags>, with the tests being conducted in the order listed here:"
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:97
msgid "Remount an existing mount: I<mountflags> includes B<MS_REMOUNT>."
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:102
msgid "Create a bind mount: I<mountflags> includes B<MS_BIND>."
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:111
msgid ""
"Change the propagation type of an existing mount: I<mountflags> includes one "
"of B<MS_SHARED>, B<MS_PRIVATE>, B<MS_SLAVE>, or B<MS_UNBINDABLE>."
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:116
msgid "Move an existing mount to a new location: I<mountflags> includes B<MS_MOVE>."
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:120
msgid "Create a new mount: I<mountflags> includes none of the above flags."
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:128
msgid ""
"Each of these operations is detailed later in this page.  Further flags may "
"be specified in I<mountflags> to modify the behavior of B<mount>(), as "
"described below."
msgstr ""

#. type: SS
#: man-pages/man2/mount.2:128
#, no-wrap
msgid "Additional mount flags"
msgstr ""

#
#.  FIXME 2.6.25 Added MS_I_VERSION, which needs to be documented.
#.  commit 7a224228ed79d587ece2304869000aad1b8e97dd
#.  (This is a per-superblock flag)
#. type: Plain text
#: man-pages/man2/mount.2:138
msgid ""
"The list below describes the additional flags that can be specified in "
"I<mountflags>.  Note that some operation types ignore some or all of these "
"flags, as described later in this page."
msgstr ""

#. type: TP
#: man-pages/man2/mount.2:138
#, no-wrap
msgid "B<MS_DIRSYNC> (since Linux 2.5.19)"
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:144
msgid ""
"Make directory changes on this filesystem synchronous.  (This property can "
"be obtained for individual directories or subtrees using B<chattr>(1).)"
msgstr ""

#. type: TP
#: man-pages/man2/mount.2:144
#, no-wrap
msgid "B<MS_LAZYTIME> (since Linux 4.0)"
msgstr ""

#.  commit 0ae45f63d4ef8d8eeec49c7d8b44a1775fff13e8
#.  commit fe032c422c5ba562ba9c2d316f55e258e03259c6
#.  commit a26f49926da938f47561f386be56a83dd37a496d
#. type: Plain text
#: man-pages/man2/mount.2:152
msgid ""
"Reduce on-disk updates of inode timestamps (atime, mtime, ctime)  by "
"maintaining these changes only in memory.  The on-disk timestamps are "
"updated only when:"
msgstr ""

#. type: IP
#: man-pages/man2/mount.2:153
#, no-wrap
msgid "(a)"
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:155
msgid "the inode needs to be updated for some change unrelated to file timestamps;"
msgstr ""

#. type: IP
#: man-pages/man2/mount.2:155
#, no-wrap
msgid "(b)"
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:161
msgid "the application employs B<fsync>(2), B<syncfs>(2), or B<sync>(2);"
msgstr ""

#. type: IP
#: man-pages/man2/mount.2:161
#, no-wrap
msgid "(c)"
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:163
msgid "an undeleted inode is evicted from memory; or"
msgstr ""

#. type: IP
#: man-pages/man2/mount.2:163
#, no-wrap
msgid "(d)"
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:165
msgid "more than 24 hours have passed since the inode was written to disk."
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:171
msgid ""
"This mount option significantly reduces writes needed to update the inode's "
"timestamps, especially mtime and atime.  However, in the event of a system "
"crash, the atime and mtime fields on disk might be out of date by up to 24 "
"hours."
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:185
msgid ""
"Examples of workloads where this option could be of significant benefit "
"include frequent random writes to preallocated files, as well as cases where "
"the B<MS_STRICTATIME> mount option is also enabled.  (The advantage of "
"combining B<MS_STRICTATIME> and B<MS_LAZYTIME> is that B<stat>(2)  will "
"return the correctly updated atime, but the atime updates will be flushed to "
"disk only in the cases listed above.)"
msgstr ""

#. type: TP
#: man-pages/man2/mount.2:185
#, no-wrap
msgid "B<MS_MANDLOCK>"
msgstr ""

#.  commit 95ace75414f312f9a7b93d873f386987b92a5301
#. type: Plain text
#: man-pages/man2/mount.2:198
msgid ""
"Permit mandatory locking on files in this filesystem.  (Mandatory locking "
"must still be enabled on a per-file basis, as described in B<fcntl>(2).)  "
"Since Linux 4.5, this mount option requires the B<CAP_SYS_ADMIN> capability "
"and a kernel configured with the B<CONFIG_MANDATORY_FILE_LOCKING> option."
msgstr ""

#. type: TP
#: man-pages/man2/mount.2:198
#, no-wrap
msgid "B<MS_NOATIME>"
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:201
msgid "Do not update access times for (all types of) files on this filesystem."
msgstr ""

#. type: TP
#: man-pages/man2/mount.2:201
#, no-wrap
msgid "B<MS_NODEV>"
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:204
msgid "Do not allow access to devices (special files) on this filesystem."
msgstr ""

#. type: TP
#: man-pages/man2/mount.2:204
#, no-wrap
msgid "B<MS_NODIRATIME>"
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:213
msgid ""
"Do not update access times for directories on this filesystem.  This flag "
"provides a subset of the functionality provided by B<MS_NOATIME>; that is, "
"B<MS_NOATIME> implies B<MS_NODIRATIME>."
msgstr ""

#. type: TP
#: man-pages/man2/mount.2:213
#, no-wrap
msgid "B<MS_NOEXEC>"
msgstr ""

#.  (Possibly useful for a filesystem that contains non-Linux executables.
#.  Often used as a security feature, e.g., to make sure that restricted
#.  users cannot execute files uploaded using ftp or so.)
#. type: Plain text
#: man-pages/man2/mount.2:219
msgid "Do not allow programs to be executed from this filesystem."
msgstr ""

#. type: TP
#: man-pages/man2/mount.2:219
#, no-wrap
msgid "B<MS_NOSUID>"
msgstr ""

#.  (This is a security feature to prevent users executing set-user-ID and
#.  set-group-ID programs from removable disk devices.)
#. type: Plain text
#: man-pages/man2/mount.2:225
msgid ""
"Do not honor set-user-ID and set-group-ID bits or file capabilities when "
"executing programs from this filesystem."
msgstr ""

#. type: TP
#: man-pages/man2/mount.2:225
#, no-wrap
msgid "B<MS_RDONLY>"
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:228
msgid "Mount filesystem read-only."
msgstr ""

#. type: TP
#: man-pages/man2/mount.2:228
#, no-wrap
msgid "B<MS_REC> (since Linux 2.4.11)"
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:236
msgid ""
"Used in conjunction with B<MS_BIND> to create a recursive bind mount, and in "
"conjunction with the propagation type flags to recursively change the "
"propagation type of all of the mounts in a subtree.  See below for further "
"details."
msgstr ""

#. type: TP
#: man-pages/man2/mount.2:236
#, no-wrap
msgid "B<MS_RELATIME> (since Linux 2.6.20)"
msgstr ""

#.  Matthew Garrett notes in the patch that added this behavior
#.  that this lets utilities such as tmpreaper (which deletes
#.  files based on last access time) work correctly.
#. type: Plain text
#: man-pages/man2/mount.2:257
msgid ""
"When a file on this filesystem is accessed, update the file's last access "
"time (atime) only if the current value of atime is less than or equal to the "
"file's last modification time (mtime)  or last status change time (ctime).  "
"This option is useful for programs, such as B<mutt>(1), that need to know "
"when a file has been read since it was last modified.  Since Linux 2.6.30, "
"the kernel defaults to the behavior provided by this flag (unless "
"B<MS_NOATIME> was specified), and the B<MS_STRICTATIME> flag is required to "
"obtain traditional semantics.  In addition, since Linux 2.6.30, the file's "
"last access time is always updated if it is more than 1 day old."
msgstr ""

#. type: TP
#: man-pages/man2/mount.2:257
#, no-wrap
msgid "B<MS_SILENT> (since Linux 2.6.17)"
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:265
msgid ""
"Suppress the display of certain (I<printk>())  warning messages in the "
"kernel log.  This flag supersedes the misnamed and obsolete B<MS_VERBOSE> "
"flag (available since Linux 2.4.12), which has the same meaning."
msgstr ""

#. type: TP
#: man-pages/man2/mount.2:265
#, no-wrap
msgid "B<MS_STRICTATIME> (since Linux 2.6.30)"
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:275
msgid ""
"Always update the last access time (atime) when files on this filesystem are "
"accessed.  (This was the default behavior before Linux 2.6.30.)  Specifying "
"this flag overrides the effect of setting the B<MS_NOATIME> and "
"B<MS_RELATIME> flags."
msgstr ""

#. type: TP
#: man-pages/man2/mount.2:275
#, no-wrap
msgid "B<MS_SYNCHRONOUS>"
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:283
msgid ""
"Make writes on this filesystem synchronous (as though the B<O_SYNC> flag to "
"B<open>(2)  was specified for all file opens to this filesystem)."
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:289
msgid ""
"From Linux 2.4 onward, some of the above flags are settable on a per-mount "
"basis, while others apply to the superblock of the mounted filesystem, "
"meaning that all mounts of the same filesystem share those flags.  "
"(Previously, all of the flags were per-superblock.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:291
msgid "The per-mount-point flags are as follows:"
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:295
msgid ""
"Since Linux 2.4: B<MS_NODEV>, B<MS_NOEXEC>, and B<MS_NOSUID> flags are "
"settable on a per-mount-point basis."
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:300
msgid "Since Linux 2.6.16: B<MS_NOATIME> and B<MS_NODIRATIME>."
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:303
msgid "Since Linux 2.6.20: B<MS_RELATIME>."
msgstr ""

#.  And MS_I_VERSION?
#. type: Plain text
#: man-pages/man2/mount.2:319
msgid ""
"The following flags are per-superblock: B<MS_DIRSYNC>, B<MS_LAZYTIME>, "
"B<MS_MANDLOCK>, B<MS_SILENT>, and B<MS_SYNCHRONOUS>.  The initial settings "
"of these flags are determined on the first mount of the filesystem, and will "
"be shared by all subsequent mounts of the same filesystem.  Subsequently, "
"the settings of the flags can be changed via a remount operation (see "
"below).  Such changes will be visible via all mount points associated with "
"the filesystem."
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:327
msgid ""
"Since Linux 2.6.16, B<MS_RDONLY> can be set or cleared on a per-mount-point "
"basis as well as on the underlying filesystem superblock.  The mounted "
"filesystem will be writable only if neither the filesystem nor the "
"mountpoint are flagged as read-only."
msgstr ""

#. type: SS
#: man-pages/man2/mount.2:327
#, no-wrap
msgid "Remounting an existing mount"
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:341
msgid ""
"An existing mount may be remounted by specifying B<MS_REMOUNT> in "
"I<mountflags>.  This allows you to change the I<mountflags> and I<data> of "
"an existing mount without having to unmount and remount the filesystem.  "
"I<target> should be the same value specified in the initial B<mount>()  "
"call."
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:347
msgid "The I<source> and I<filesystemtype> arguments are ignored."
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:355
msgid ""
"The I<mountflags> and I<data> arguments should match the values used in the "
"original B<mount>()  call, except for those parameters that are being "
"deliberately changed."
msgstr ""

#.  FIXME
#.  MS_LAZYTIME seems to be available only on a few filesystems,
#.  and on ext4, it seems (from experiment that this flag
#.  can only be enabled (but not disabled) on a remount.
#.  The following code in ext4_remount() (kernel 4.17) seems to
#.  confirm this:
#
#.         if (*flags & SB_LAZYTIME)
#.                 sb->s_flags |= SB_LAZYTIME;
#.  See the definition of MS_RMT_MASK in include/uapi/linux/fs.h,
#.  which excludes MS_DIRSYNC and MS_SILENT, although SB_DIRSYNC
#.  and SB_SILENT are split out as per-superblock flags in do_mount()
#.  (Linux 4.17 source code)
#. type: Plain text
#: man-pages/man2/mount.2:397
msgid ""
"The following I<mountflags> can be changed: B<MS_LAZYTIME>, B<MS_MANDLOCK>, "
"B<MS_NOATIME>, B<MS_NODEV>, B<MS_NODIRATIME>, B<MS_NOEXEC>, B<MS_NOSUID>, "
"B<MS_RELATIME>, B<MS_RDONLY>, B<MS_STRICTATIME> (whose effect is to clear "
"the B<MS_NOATIME> and B<MS_RELATIME> flags), and B<MS_SYNCHRONOUS>.  "
"Attempts to change the setting of the B<MS_DIRSYNC> and B<MS_SILENT> flags "
"during a remount are silently ignored.  Note that changes to per-superblock "
"flags are visible via all mount points of the associated filesystem (because "
"the per-superblock flags are shared by all mount points)."
msgstr ""

#.  commit ffbc6f0ead47fa5a1dc9642b0331cb75c20a640e
#. type: Plain text
#: man-pages/man2/mount.2:411
msgid ""
"Since Linux 3.17, if none of B<MS_NOATIME>, B<MS_NODIRATIME>, "
"B<MS_RELATIME>, or B<MS_STRICTATIME> is specified in I<mountflags>, then the "
"remount operation preserves the existing values of these flags (rather than "
"defaulting to B<MS_RELATIME>)."
msgstr ""

#.  See https://lwn.net/Articles/281157/
#. type: Plain text
#: man-pages/man2/mount.2:423
msgid ""
"Since Linux 2.6.26, the B<MS_REMOUNT> flag can be used with B<MS_BIND> to "
"modify only the per-mount-point flags.  This is particularly useful for "
"setting or clearing the \"read-only\" flag on a mount point without changing "
"the underlying filesystem.  Specifying I<mountflags> as:"
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:427
#, no-wrap
msgid "MS_REMOUNT | MS_BIND | MS_RDONLY\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:433
msgid ""
"will make access through this mountpoint read-only, without affecting other "
"mount points."
msgstr ""

#. type: SS
#: man-pages/man2/mount.2:433
#, no-wrap
msgid "Creating a bind mount"
msgstr ""

#.  since 2.4.0-test9
#. type: Plain text
#: man-pages/man2/mount.2:446
msgid ""
"If I<mountflags> includes B<MS_BIND> (available since Linux 2.4), then "
"perform a bind mount.  A bind mount makes a file or a directory subtree "
"visible at another point within the single directory hierarchy.  Bind mounts "
"may cross filesystem boundaries and span B<chroot>(2)  jails."
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:452
msgid "The I<filesystemtype> and I<data> arguments are ignored."
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:462
msgid ""
"The remaining bits (other than B<MS_REC>, described below) in the "
"I<mountflags> argument are also ignored.  (The bind mount has the same mount "
"options as the underlying mount point.)  However, see the discussion of "
"remounting above, for a method of making an existing bind mount read-only."
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:477
msgid ""
"By default, when a directory is bind mounted, only that directory is "
"mounted; if there are any submounts under the directory tree, they are not "
"bind mounted.  If the B<MS_REC> flag is also specified, then a recursive "
"bind mount operation is performed: all submounts under the I<source> subtree "
"(other than unbindable mounts)  are also bind mounted at the corresponding "
"location in the I<target> subtree."
msgstr ""

#. type: SS
#: man-pages/man2/mount.2:477
#, no-wrap
msgid "Changing the propagation type of an existing mount"
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:489
msgid ""
"If I<mountflags> includes one of B<MS_SHARED>, B<MS_PRIVATE>, B<MS_SLAVE>, "
"or B<MS_UNBINDABLE> (all available since Linux 2.6.15), then the propagation "
"type of an existing mount is changed.  If more than one of these flags is "
"specified, an error results."
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:496
msgid ""
"The only other flags that can be specified while changing the propagation "
"type are B<MS_REC> (described below) and B<MS_SILENT> (which is ignored)."
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:503
msgid "The I<source>, I<filesystemtype>, and I<data> arguments are ignored."
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:505
msgid "The meanings of the propagation type flags are as follows:"
msgstr ""

#. type: TP
#: man-pages/man2/mount.2:505
#, no-wrap
msgid "B<MS_SHARED>"
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:514
msgid ""
"Make this mount point shared.  Mount and unmount events immediately under "
"this mount point will propagate to the other mount points that are members "
"of this mount's peer group.  Propagation here means that the same mount or "
"unmount will automatically occur under all of the other mount points in the "
"peer group.  Conversely, mount and unmount events that take place under peer "
"mount points will propagate to this mount point."
msgstr ""

#. type: TP
#: man-pages/man2/mount.2:514
#, no-wrap
msgid "B<MS_PRIVATE>"
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:518
msgid ""
"Make this mount point private.  Mount and unmount events do not propagate "
"into or out of this mount point."
msgstr ""

#. type: TP
#: man-pages/man2/mount.2:518
#, no-wrap
msgid "B<MS_SLAVE>"
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:525
msgid ""
"If this is a shared mount point that is a member of a peer group that "
"contains other members, convert it to a slave mount.  If this is a shared "
"mount point that is a member of a peer group that contains no other members, "
"convert it to a private mount.  Otherwise, the propagation type of the mount "
"point is left unchanged."
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:530
msgid ""
"When a mount point is a slave, mount and unmount events propagate into this "
"mount point from the (master) shared peer group of which it was formerly a "
"member.  Mount and unmount events under this mount point do not propagate to "
"any peer."
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:534
msgid ""
"A mount point can be the slave of another peer group while at the same time "
"sharing mount and unmount events with a peer group of which it is a member."
msgstr ""

#. type: TP
#: man-pages/man2/mount.2:534
#, no-wrap
msgid "B<MS_UNBINDABLE>"
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:549
msgid ""
"Make this mount unbindable.  This is like a private mount, and in addition "
"this mount can't be bind mounted.  When a recursive bind mount (B<mount>()  "
"with the B<MS_BIND> and B<MS_REC> flags) is performed on a directory "
"subtree, any unbindable mounts within the subtree are automatically pruned "
"(i.e., not replicated)  when replicating that subtree to produce the target "
"subtree."
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:560
msgid ""
"By default, changing the propagation type affects only the I<target> mount "
"point.  If the B<MS_REC> flag is also specified in I<mountflags>, then the "
"propagation type of all mount points under I<target> is also changed."
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:565
msgid ""
"For further details regarding mount propagation types (including the default "
"propagation type assigned to new mounts), see B<mount_namespaces>(7)."
msgstr ""

#. type: SS
#: man-pages/man2/mount.2:565
#, no-wrap
msgid "Moving a mount"
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:577
msgid ""
"If I<mountflags> contains the flag B<MS_MOVE> (available since Linux "
"2.4.18), then move a subtree: I<source> specifies an existing mount point "
"and I<target> specifies the new location to which that mount point is to be "
"relocated.  The move is atomic: at no point is the subtree unmounted."
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:586
msgid ""
"The remaining bits in the I<mountflags> argument are ignored, as are the "
"I<filesystemtype> and I<data> arguments."
msgstr ""

#. type: SS
#: man-pages/man2/mount.2:586
#, no-wrap
msgid "Creating a new mount point"
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:605
msgid ""
"If none of B<MS_REMOUNT>, B<MS_BIND>, B<MS_MOVE>, B<MS_SHARED>, "
"B<MS_PRIVATE>, B<MS_SLAVE>, or B<MS_UNBINDABLE> is specified in "
"I<mountflags>, then B<mount>()  performs its default action: creating a new "
"mount point.  I<source> specifies the source for the new mount point, and "
"I<target> specifies the directory at which to create the mount point."
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:614
msgid ""
"The I<filesystemtype> and I<data> arguments are employed, and further bits "
"may be specified in I<mountflags> to modify the behavior of the call."
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:625 man-pages/man2/umount.2:124
msgid ""
"The error values given below result from filesystem type independent "
"errors.  Each filesystem type may have its own special errors and its own "
"special behavior.  See the Linux kernel source code for details."
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:630
msgid "A component of a path was not searchable.  (See also B<path_resolution>(7).)"
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:635
msgid ""
"Mounting a read-only filesystem was attempted without giving the "
"B<MS_RDONLY> flag."
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:644
msgid ""
"The file system may be read-only for various reasons, including: it resides "
"on a read-only optical disk; it is resides on a device with a physical "
"switch that has been set to mark the device read-only; the filesystem "
"implementation was compiled with read-only support; or errors were detected "
"when initially mounting the filesystem, so that it was marked read-only and "
"can't be remounted as read-write (until the errors are fixed)."
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:648
msgid ""
"Some filesystems instead return the error B<EROFS> on an attempt to mount a "
"read-only filesystem."
msgstr ""

#.  mtk: Probably: write permission is required for MS_BIND, with
#.  the error EPERM if not present; CAP_DAC_OVERRIDE is required.
#. type: Plain text
#: man-pages/man2/mount.2:657
msgid ""
"The block device I<source> is located on a filesystem mounted with the "
"B<MS_NODEV> option."
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:665
msgid ""
"An attempt was made to stack a new mount directly on top of an existing "
"mount point that was created in this mount namespace with the same I<source> "
"and I<target>."
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:670
msgid ""
"I<source> cannot be remounted read-only, because it still holds files open "
"for writing."
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:673
msgid "One of the pointer arguments points outside the user address space."
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:677
msgid "I<source> had an invalid superblock."
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:685
msgid ""
"A remount operation (B<MS_REMOUNT>)  was attempted, but I<source> was not "
"already mounted on I<target>."
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:695
msgid ""
"A move operation (B<MS_MOVE>)  was attempted, but the mount tree under "
"I<source> includes unbindable mounts and I<target> is a mount point that has "
"propagation type B<MS_SHARED>."
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:703
msgid ""
"A move operation (B<MS_MOVE>)  was attempted, but the parent mount of "
"I<source> mount has propagation type B<MS_SHARED>."
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:710
msgid ""
"A move operation (B<MS_MOVE>)  was attempted, but I<source> was not a mount "
"point, or was \\(aq/\\(aq."
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:719
msgid ""
"I<mountflags> includes more than one of B<MS_SHARED>, B<MS_PRIVATE>, "
"B<MS_SLAVE>, or B<MS_UNBINDABLE>."
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:732
msgid ""
"I<mountflags> includes B<MS_SHARED>, B<MS_PRIVATE>, B<MS_SLAVE>, or "
"B<MS_UNBINDABLE> and also includes a flag other than B<MS_REC> or "
"B<MS_SILENT>."
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:735
msgid "An attempt was made to bind mount an unbindable mount."
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:746
msgid ""
"In an unprivileged mount namespace (i.e., a mount namespace owned by a user "
"namespace that was created by an unprivileged user), a bind mount operation "
"(B<MS_BIND>)  was attempted without specifying (B<MS_REC>), which would have "
"revealed the filesystem tree underneath one of the submounts of the "
"directory being bound."
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:749
msgid "Too many links encountered during pathname resolution."
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:755
msgid "A move operation was attempted, and I<target> is a descendant of I<source>."
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:759
msgid "(In case no block device is required:)  Table of dummy devices is full."
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:763 man-pages/man2/umount.2:161
msgid "A pathname was longer than B<MAXPATHLEN>."
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:767
msgid "I<filesystemtype> not configured in the kernel."
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:770 man-pages/man2/umount.2:164
msgid "A pathname was empty or had a nonexistent component."
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:773 man-pages/man2/umount.2:167
msgid "The kernel could not allocate a free page to copy filenames or data into."
msgstr ""

#. type: TP
#: man-pages/man2/mount.2:773 man-pages/man2/quotactl.2:731
#, no-wrap
msgid "B<ENOTBLK>"
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:777
msgid "I<source> is not a block device (and a device was required)."
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:783
msgid "I<target>, or a prefix of I<source>, is not a directory."
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:788
msgid "The major number of the block device I<source> is out of range."
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:791 man-pages/man2/umount.2:170
msgid "The caller does not have the required privileges."
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:799
msgid ""
"Mounting a read-only filesystem was attempted without giving the "
"B<MS_RDONLY> flag.  See B<EACCES>, above."
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:813
msgid ""
"The definitions of B<MS_DIRSYNC>, B<MS_MOVE>, B<MS_PRIVATE>, B<MS_REC>, "
"B<MS_RELATIME>, B<MS_SHARED>, B<MS_SLAVE>, B<MS_STRICTATIME>, and "
"B<MS_UNBINDABLE> were added to glibc headers in version 2.12."
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:816
msgid ""
"This function is Linux-specific and should not be used in programs intended "
"to be portable."
msgstr ""

#.  Multiple mounts on same mount point: since 2.3.99pre7.
#. type: Plain text
#: man-pages/man2/mount.2:821
msgid ""
"Since Linux 2.4 a single filesystem can be mounted at multiple mount points, "
"and multiple mounts can be stacked on the same mount point."
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:833
msgid ""
"The I<mountflags> argument may have the magic number 0xC0ED (B<MS_MGC_VAL>)  "
"in the top 16 bits.  (All of the other flags discussed in DESCRIPTION occupy "
"the low order 16 bits of I<mountflags>.)  Specifying B<MS_MGC_VAL> was "
"required in kernel versions prior to 2.4, but since Linux 2.4 is no longer "
"required and is ignored if specified."
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:842
msgid ""
"The original B<MS_SYNC> flag was renamed B<MS_SYNCHRONOUS> in 1.1.69 when a "
"different B<MS_SYNC> was added to I<E<lt>mman.hE<gt>>."
msgstr ""

#.  The change is in patch-2.4.0-prerelease.
#. type: Plain text
#: man-pages/man2/mount.2:852
msgid ""
"Before Linux 2.4 an attempt to execute a set-user-ID or set-group-ID program "
"on a filesystem mounted with B<MS_NOSUID> would fail with B<EPERM>.  Since "
"Linux 2.4 the set-user-ID and set-group-ID bits are just silently ignored in "
"this case."
msgstr ""

#. type: TP
#: man-pages/man2/mount.2:852 man-pages/man2/setns.2:124
#, no-wrap
msgid "Mount namespaces"
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:862
msgid ""
"Starting with kernel 2.4.19, Linux provides mount namespaces.  A mount "
"namespace is the set of filesystem mounts that are visible to a process.  "
"Mount namespaces can be (and usually are)  shared between multiple "
"processes, and changes to the namespace (i.e., mounts and unmounts) by one "
"process are visible to all other processes sharing the same namespace.  (The "
"pre-2.4.19 Linux situation can be considered as one in which a single "
"namespace was shared by every process on the system.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:868
msgid ""
"A child process created by B<fork>(2)  shares its parent's mount namespace; "
"the mount namespace is preserved across an B<execve>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:888
msgid ""
"A process can obtain a private mount namespace if: it was created using the "
"B<clone>(2)  B<CLONE_NEWNS> flag, in which case its new namespace is "
"initialized to be a I<copy> of the namespace of the process that called "
"B<clone>(2); or it calls B<unshare>(2)  with the B<CLONE_NEWNS> flag, which "
"causes the caller's mount namespace to obtain a private copy of the "
"namespace that it was previously sharing with other processes, so that "
"future mounts and unmounts by the caller are invisible to other processes "
"(except child processes that the caller subsequently creates) and vice "
"versa."
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:892
msgid "For further details on mount namespaces, see B<mount_namespaces>(7)."
msgstr ""

#. type: SS
#: man-pages/man2/mount.2:892
#, no-wrap
msgid "Parental relationship between mount points"
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:896
msgid ""
"Each mount point has a parent mount point.  The overall parental "
"relationship of all mount points defines the single directory hierarchy seen "
"by the processes within a mount namespace."
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:904
msgid ""
"The parent of a new mount point is defined when the mount point is created.  "
"In the usual case, the parent of a new mount is the mount point of the "
"filesystem containing the directory or file at which the new mount is "
"attached.  In the case where a new mount is stacked on top of an existing "
"mount, the parent of the new mount is the previous mount that was stacked at "
"that location."
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:909
msgid ""
"The parental relationship between mount points can be discovered via the "
"I</proc/[pid]/mountinfo> file (see below)."
msgstr ""

#. type: SS
#: man-pages/man2/mount.2:909
#, no-wrap
msgid "/proc/[pid]/mounts and /proc/[pid]/mountinfo"
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:924
msgid ""
"The Linux-specific I</proc/[pid]/mounts> file exposes the list of mount "
"points in the mount namespace of the process with the specified ID.  The "
"I</proc/[pid]/mountinfo> file exposes even more information about mount "
"points, including the propagation type and mount ID information that makes "
"it possible to discover the parental relationship between mount points.  See "
"B<proc>(5)  and B<mount_namespaces>(7)  for details of this file."
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:935
msgid ""
"B<mountpoint>(1), B<chroot>(2), B<ioctl_iflags>(2), B<pivot_root>(2), "
"B<umount>(2), B<mount_namespaces>(7), B<path_resolution>(7), B<findmnt>(8), "
"B<lsblk>(8), B<mount>(8), B<umount>(8)"
msgstr ""

#. type: TH
#: man-pages/man2/fanotify_init.2:24
#, no-wrap
msgid "FANOTIFY_INIT"
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_init.2:27
msgid "fanotify_init - create and initialize fanotify group"
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_init.2:29
msgid "B<#include E<lt>fcntl.hE<gt>>"
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_init.2:31
msgid "B<#include E<lt>sys/fanotify.hE<gt>>"
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_init.2:33
msgid ""
"B<int fanotify_init(unsigned int >I<flags>B<, unsigned int "
">I<event_f_flags>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_init.2:36 man-pages/man2/fanotify_mark.2:39
msgid "For an overview of the fanotify API, see B<fanotify>(7)."
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_init.2:40
msgid ""
"B<fanotify_init>()  initializes a new fanotify group and returns a file "
"descriptor for the event queue associated with the group."
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_init.2:51
msgid ""
"The file descriptor is used in calls to B<fanotify_mark>(2)  to specify the "
"files, directories, mounts or filesystems for which fanotify events shall be "
"created.  These events are received by reading from the file descriptor.  "
"Some events are only informative, indicating that a file has been accessed.  "
"Other events can be used to determine whether another application is "
"permitted to access a file or directory.  Permission to access filesystem "
"objects is granted by writing to the file descriptor."
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_init.2:54
msgid ""
"Multiple programs may be using the fanotify interface at the same time to "
"monitor the same files."
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_init.2:58
msgid ""
"In the current implementation, the number of fanotify groups per user is "
"limited to 128.  This limit cannot be overridden."
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_init.2:67
msgid ""
"Calling B<fanotify_init>()  requires the B<CAP_SYS_ADMIN> capability.  This "
"constraint might be relaxed in future versions of the API.  Therefore, "
"certain additional capability checks have been implemented as indicated "
"below."
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_init.2:73
msgid ""
"The I<flags> argument contains a multi-bit field defining the notification "
"class of the listening application and further single bit fields specifying "
"the behavior of the file descriptor."
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_init.2:77
msgid ""
"If multiple listeners for permission events exist, the notification class is "
"used to establish the sequence in which the listeners receive the events."
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_init.2:80
msgid "Only one of the following notification classes may be specified in I<flags>:"
msgstr ""

#. type: TP
#: man-pages/man2/fanotify_init.2:80
#, no-wrap
msgid "B<FAN_CLASS_PRE_CONTENT>"
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_init.2:88
msgid ""
"This value allows the receipt of events notifying that a file has been "
"accessed and events for permission decisions if a file may be accessed.  It "
"is intended for event listeners that need to access files before they "
"contain their final data.  This notification class might be used by "
"hierarchical storage managers, for example."
msgstr ""

#. type: TP
#: man-pages/man2/fanotify_init.2:88
#, no-wrap
msgid "B<FAN_CLASS_CONTENT>"
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_init.2:96
msgid ""
"This value allows the receipt of events notifying that a file has been "
"accessed and events for permission decisions if a file may be accessed.  It "
"is intended for event listeners that need to access files when they already "
"contain their final content.  This notification class might be used by "
"malware detection programs, for example."
msgstr ""

#. type: TP
#: man-pages/man2/fanotify_init.2:96
#, no-wrap
msgid "B<FAN_REPORT_FID> (since Linux 5.1)"
msgstr ""

#.  commit a8b13aa20afb69161b5123b4f1acc7ea0a03d360
#. type: Plain text
#: man-pages/man2/fanotify_init.2:126
msgid ""
"This value allows the receipt of events which contain additional information "
"about the underlying filesystem object correlated to an event.  An "
"additional structure encapsulates the information about the object and is "
"included alongside the generic event metadata structure.  The file "
"descriptor that is used to represent the object correlated to an event is "
"instead substituted with a file handle.  It is intended for applications "
"that may find the use of a file handle to identify an object more suitable "
"than a file descriptor.  Additionally, it may be used for applications that "
"are interested in directory entry events, such as B<FAN_CREATE>, "
"B<FAN_ATTRIB>, B<FAN_MOVE>, and B<FAN_DELETE> for example.  Note that the "
"use of directory modification events are not supported when monitoring a "
"mount point.  The use of B<FAN_CLASS_CONTENT> or B<FAN_CLASS_PRE_CONTENT> is "
"not permitted with this flag and will result in the error B<EINVAL>.  See "
"B<fanotify>(7)  for additional information."
msgstr ""

#. type: TP
#: man-pages/man2/fanotify_init.2:126
#, no-wrap
msgid "B<FAN_CLASS_NOTIF>"
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_init.2:133
msgid ""
"This is the default value.  It does not need to be specified.  This value "
"only allows the receipt of events notifying that a file has been accessed.  "
"Permission decisions before the file is accessed are not possible."
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_init.2:141
msgid ""
"Listeners with different notification classes will receive events in the "
"order B<FAN_CLASS_PRE_CONTENT>, B<FAN_CLASS_CONTENT>, B<FAN_CLASS_NOTIF>.  "
"The order of notification for listeners in the same notification class is "
"undefined."
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_init.2:144
msgid "The following bits can additionally be set in I<flags>:"
msgstr ""

#. type: TP
#: man-pages/man2/fanotify_init.2:144
#, no-wrap
msgid "B<FAN_CLOEXEC>"
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_init.2:153
msgid ""
"Set the close-on-exec flag (B<FD_CLOEXEC>)  on the new file descriptor.  See "
"the description of the B<O_CLOEXEC> flag in B<open>(2)."
msgstr ""

#. type: TP
#: man-pages/man2/fanotify_init.2:153
#, no-wrap
msgid "B<FAN_NONBLOCK>"
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_init.2:163
msgid ""
"Enable the nonblocking flag (B<O_NONBLOCK>)  for the file descriptor.  "
"Reading from the file descriptor will not block.  Instead, if no data is "
"available, B<read>(2)  fails with the error B<EAGAIN>."
msgstr ""

#. type: TP
#: man-pages/man2/fanotify_init.2:163
#, no-wrap
msgid "B<FAN_UNLIMITED_QUEUE>"
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_init.2:169
msgid ""
"Remove the limit of 16384 events for the event queue.  Use of this flag "
"requires the B<CAP_SYS_ADMIN> capability."
msgstr ""

#. type: TP
#: man-pages/man2/fanotify_init.2:169
#, no-wrap
msgid "B<FAN_UNLIMITED_MARKS>"
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_init.2:175
msgid ""
"Remove the limit of 8192 marks.  Use of this flag requires the "
"B<CAP_SYS_ADMIN> capability."
msgstr ""

#. type: TP
#: man-pages/man2/fanotify_init.2:175
#, no-wrap
msgid "B<FAN_REPORT_TID> (since Linux 4.20)"
msgstr ""

#.  commit d0a6a87e40da49cfc7954c491d3065a25a641b29
#. type: Plain text
#: man-pages/man2/fanotify_init.2:187
msgid ""
"Report thread ID (TID) instead of process ID (PID)  in the I<pid> field of "
"the I<struct fanotify_event_metadata> supplied to B<read>(2)  (see "
"B<fanotify>(7))."
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_init.2:200
msgid ""
"The I<event_f_flags> argument defines the file status flags that will be set "
"on the open file descriptions that are created for fanotify events.  For "
"details of these flags, see the description of the I<flags> values in "
"B<open>(2).  I<event_f_flags> includes a multi-bit field for the access "
"mode.  This field can take the following values:"
msgstr ""

#. type: TP
#: man-pages/man2/fanotify_init.2:200
#, no-wrap
msgid "B<O_RDONLY>"
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_init.2:203
msgid "This value allows only read access."
msgstr ""

#. type: TP
#: man-pages/man2/fanotify_init.2:203
#, no-wrap
msgid "B<O_WRONLY>"
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_init.2:206
msgid "This value allows only write access."
msgstr ""

#. type: TP
#: man-pages/man2/fanotify_init.2:206
#, no-wrap
msgid "B<O_RDWR>"
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_init.2:209
msgid "This value allows read and write access."
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_init.2:213
msgid "Additional bits can be set in I<event_f_flags>.  The most useful values are:"
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_init.2:220
msgid ""
"Enable support for files exceeding 2\\ GB.  Failing to set this flag will "
"result in an B<EOVERFLOW> error when trying to open a large file which is "
"monitored by an fanotify group on a 32-bit system."
msgstr ""

#. type: TP
#: man-pages/man2/fanotify_init.2:220
#, no-wrap
msgid "B<O_CLOEXEC> (since Linux 3.18)"
msgstr ""

#.  commit 0b37e097a648aa71d4db1ad108001e95b69a2da4
#. type: Plain text
#: man-pages/man2/fanotify_init.2:229
msgid ""
"Enable the close-on-exec flag for the file descriptor.  See the description "
"of the B<O_CLOEXEC> flag in B<open>(2)  for reasons why this may be useful."
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_init.2:242
msgid ""
"The following are also allowable: B<O_APPEND>, B<O_DSYNC>, B<O_NOATIME>, "
"B<O_NONBLOCK>, and B<O_SYNC>.  Specifying any other flag in I<event_f_flags> "
"yields the error B<EINVAL> (but see BUGS)."
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_init.2:249
msgid ""
"On success, B<fanotify_init>()  returns a new file descriptor.  On error, -1 "
"is returned, and I<errno> is set to indicate the error."
msgstr ""

#.  commit 23c9deeb3285d34fd243abb3d6b9f07db60c3cf4
#. type: Plain text
#: man-pages/man2/fanotify_init.2:261
msgid ""
"An invalid value was passed in I<flags> or I<event_f_flags>.  "
"B<FAN_ALL_INIT_FLAGS> (deprecated since Linux kernel version 4.20)  defines "
"all allowable bits for I<flags>."
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_init.2:264
msgid "The number of fanotify groups for this user exceeds 128."
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_init.2:270
msgid "The allocation of memory for the notification group failed."
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_init.2:276
msgid ""
"This kernel does not implement B<fanotify_init>().  The fanotify API is "
"available only if the kernel was configured with B<CONFIG_FANOTIFY>."
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_init.2:281
msgid ""
"The operation is not permitted because the caller lacks the B<CAP_SYS_ADMIN> "
"capability."
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_init.2:285
msgid ""
"B<fanotify_init>()  was introduced in version 2.6.36 of the Linux kernel and "
"enabled in version 2.6.37."
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_init.2:289
msgid "The following bug was present in Linux kernels before version 3.18:"
msgstr ""

#.  Fixed by commit 0b37e097a648aa71d4db1ad108001e95b69a2da4
#. type: Plain text
#: man-pages/man2/fanotify_init.2:295
msgid "The B<O_CLOEXEC> is ignored when passed in I<event_f_flags>."
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_init.2:297
msgid "The following bug was present in Linux kernels before version 3.14:"
msgstr ""

#.  Fixed by commit 48149e9d3a7e924010a0daab30a6197b7d7b6580
#. type: Plain text
#: man-pages/man2/fanotify_init.2:307
msgid ""
"The I<event_f_flags> argument is not checked for invalid flags.  Flags that "
"are intended only for internal use, such as B<FMODE_EXEC>, can be set, and "
"will consequently be set for the file descriptors returned when reading from "
"the fanotify file descriptor."
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_init.2:309
msgid "B<fanotify_mark>(2), B<fanotify>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/ioctl.2:41
#, no-wrap
msgid "IOCTL"
msgstr ""

#. type: TH
#: man-pages/man2/ioctl.2:41 man-pages/man2/alarm.2:30
#: man-pages/man2/_exit.2:29
#, no-wrap
msgid "2017-05-03"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl.2:44
msgid "ioctl - control device"
msgstr ""

#.  POSIX says 'request' is int, but glibc has the above
#.  See https://bugzilla.kernel.org/show_bug.cgi?id=42705
#. type: Plain text
#: man-pages/man2/ioctl.2:50
msgid "B<int ioctl(int >I<fd>B<, unsigned long >I<request>B<, ...);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl.2:61
msgid ""
"The B<ioctl>()  system call manipulates the underlying device parameters of "
"special files.  In particular, many operating characteristics of character "
"special files (e.g., terminals) may be controlled with B<ioctl>()  "
"requests.  The argument I<fd> must be an open file descriptor."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl.2:69
msgid ""
"The second argument is a device-dependent request code.  The third argument "
"is an untyped pointer to memory.  It's traditionally B<char *>I<argp> (from "
"the days before B<void *> was valid C), and will be so named for this "
"discussion."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl.2:85
msgid ""
"An B<ioctl>()  I<request> has encoded in it whether the argument is an I<in> "
"parameter or I<out> parameter, and the size of the argument I<argp> in "
"bytes.  Macros and defines used in specifying an B<ioctl>()  I<request> are "
"located in the file I<E<lt>sys/ioctl.hE<gt>>."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl.2:94
msgid ""
"Usually, on success zero is returned.  A few B<ioctl>()  requests use the "
"return value as an output parameter and return a nonnegative value on "
"success.  On error, -1 is returned, and I<errno> is set appropriately."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl.2:103
msgid "I<argp> references an inaccessible memory area."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl.2:109
msgid "I<request> or I<argp> is not valid."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl.2:113
msgid "I<fd> is not associated with a character special device."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl.2:119
msgid ""
"The specified request does not apply to the kind of object that the file "
"descriptor I<fd> references."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl.2:134
msgid ""
"No single standard.  Arguments, returns, and semantics of B<ioctl>()  vary "
"according to the device driver in question (the call is used as a catch-all "
"for operations that don't cleanly fit the UNIX stream I/O model).  See "
"B<ioctl_list>(2)  for a list of many of the known B<ioctl>()  calls.  The "
"B<ioctl>()  system call appeared in Version 7 AT&T UNIX."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl.2:142
msgid ""
"In order to use this call, one needs an open file descriptor.  Often the "
"B<open>(2)  call has unwanted side effects, that can be avoided under Linux "
"by giving it the B<O_NONBLOCK> flag."
msgstr ""

#.  .BR mt (4),
#. type: Plain text
#: man-pages/man2/ioctl.2:158
msgid ""
"B<execve>(2), B<fcntl>(2), B<ioctl_console>(2), B<ioctl_fat>(2), "
"B<ioctl_ficlonerange>(2), B<ioctl_fideduperange>(2), B<ioctl_getfsmap>(2), "
"B<ioctl_iflags>(2), B<ioctl_list>(2), B<ioctl_ns>(2), B<ioctl_tty>(2), "
"B<ioctl_userfaultfd>(2), B<open>(2), B<sd>(4), B<tty>(4)"
msgstr ""

#. type: TH
#: man-pages/man2/tee.2:26
#, no-wrap
msgid "TEE"
msgstr ""

#. type: Plain text
#: man-pages/man2/tee.2:29
msgid "tee - duplicating pipe content"
msgstr ""

#. type: Plain text
#: man-pages/man2/tee.2:36
#, no-wrap
msgid ""
"B<ssize_t tee(int >I<fd_in>B<, int >I<fd_out>B<, size_t >I<len>B<, unsigned "
"int >I<flags>B<);>\n"
msgstr ""

#.  Example programs http://brick.kernel.dk/snaps
#
#
#.  add a "tee(in, out1, out2)" system call that duplicates the pages
#.  (again, incrementing their reference count, not copying the data) from
#.  one pipe to two other pipes.
#. type: Plain text
#: man-pages/man2/tee.2:56
msgid ""
"B<tee>()  duplicates up to I<len> bytes of data from the pipe referred to by "
"the file descriptor I<fd_in> to the pipe referred to by the file descriptor "
"I<fd_out>.  It does not consume the data that is duplicated from I<fd_in>; "
"therefore, that data can be copied by a subsequent B<splice>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/tee.2:60
msgid ""
"I<flags> is a bit mask that is composed by ORing together zero or more of "
"the following values:"
msgstr ""

#. type: Plain text
#: man-pages/man2/tee.2:66
msgid "Currently has no effect for B<tee>(); see B<splice>(2)."
msgstr ""

#.  Not used for vmsplice
#.  May be in the future -- therefore EAGAIN
#. type: Plain text
#: man-pages/man2/tee.2:71 man-pages/man2/vmsplice.2:105
msgid "Do not block on I/O; see B<splice>(2)  for further details."
msgstr ""

#. type: Plain text
#: man-pages/man2/tee.2:77
msgid ""
"Currently has no effect for B<tee>(), but may be implemented in the future; "
"see B<splice>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/tee.2:83
msgid "Unused for B<tee>(); see B<vmsplice>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/tee.2:92
msgid ""
"Upon successful completion, B<tee>()  returns the number of bytes that were "
"duplicated between the input and output.  A return value of 0 means that "
"there was no data to transfer, and it would not make sense to block, because "
"there are no writers connected to the write end of the pipe referred to by "
"I<fd_in>."
msgstr ""

#. type: Plain text
#: man-pages/man2/tee.2:98
msgid "On error, B<tee>()  returns -1 and I<errno> is set to indicate the error."
msgstr ""

#. type: Plain text
#: man-pages/man2/tee.2:117
msgid ""
"I<fd_in> or I<fd_out> does not refer to a pipe; or I<fd_in> and I<fd_out> "
"refer to the same pipe."
msgstr ""

#. type: Plain text
#: man-pages/man2/tee.2:125
msgid ""
"The B<tee>()  system call first appeared in Linux 2.6.17; library support "
"was added to glibc in version 2.5."
msgstr ""

#. type: Plain text
#: man-pages/man2/tee.2:136
msgid ""
"Conceptually, B<tee>()  copies the data between the two pipes.  In reality "
"no real data copying takes place though: under the covers, B<tee>()  assigns "
"data to the output by merely grabbing a reference to the input."
msgstr ""

#. type: Plain text
#: man-pages/man2/tee.2:143
msgid ""
"The example below implements a basic B<tee>(1)  program using the B<tee>()  "
"system call.  Here is an example of its use:"
msgstr ""

#. type: Plain text
#: man-pages/man2/tee.2:150
#, no-wrap
msgid ""
"$ B<date |./a.out out.log | cat>\n"
"Tue Oct 28 10:06:00 CET 2014\n"
"$ B<cat out.log>\n"
"Tue Oct 28 10:06:00 CET 2014\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/tee.2:162
#, no-wrap
msgid ""
"#define _GNU_SOURCE\n"
"#include E<lt>fcntl.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"
"#include E<lt>limits.hE<gt>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/tee.2:168
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int fd;\n"
"    int len, slen;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/tee.2:173
#, no-wrap
msgid ""
"    if (argc != 2) {\n"
"        fprintf(stderr, \"Usage: %s E<lt>fileE<gt>\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/tee.2:179
#, no-wrap
msgid ""
"    fd = open(argv[1], O_WRONLY | O_CREAT | O_TRUNC, 0644);\n"
"    if (fd == -1) {\n"
"        perror(\"open\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/tee.2:186
#, no-wrap
msgid ""
"    do {\n"
"        /*\n"
"         * tee stdin to stdout.\n"
"         */\n"
"        len = tee(STDIN_FILENO, STDOUT_FILENO,\n"
"                  INT_MAX, SPLICE_F_NONBLOCK);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/tee.2:195
#, no-wrap
msgid ""
"        if (len E<lt> 0) {\n"
"            if (errno == EAGAIN)\n"
"                continue;\n"
"            perror(\"tee\");\n"
"            exit(EXIT_FAILURE);\n"
"        } else\n"
"            if (len == 0)\n"
"                break;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/tee.2:209
#, no-wrap
msgid ""
"        /*\n"
"         * Consume stdin by splicing it to a file.\n"
"         */\n"
"        while (len E<gt> 0) {\n"
"            slen = splice(STDIN_FILENO, NULL, fd, NULL,\n"
"                          len, SPLICE_F_MOVE);\n"
"            if (slen E<lt> 0) {\n"
"                perror(\"splice\");\n"
"                break;\n"
"            }\n"
"            len -= slen;\n"
"        }\n"
"    } while (1);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/tee.2:213
#, no-wrap
msgid ""
"    close(fd);\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/tee.2:217
msgid "B<splice>(2), B<vmsplice>(2), B<pipe>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/chmod.2:32
#, no-wrap
msgid "CHMOD"
msgstr ""

#. type: Plain text
#: man-pages/man2/chmod.2:35
msgid "chmod, fchmod, fchmodat - change permissions of a file"
msgstr ""

#. type: Plain text
#: man-pages/man2/chmod.2:38
#, no-wrap
msgid "B<#include E<lt>sys/stat.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/chmod.2:40
#, no-wrap
msgid "B<int chmod(const char *>I<pathname>B<, mode_t >I<mode>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/chmod.2:42
#, no-wrap
msgid "B<int fchmod(int >I<fd>B<, mode_t >I<mode>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/chmod.2:45
#, no-wrap
msgid ""
"B<#include E<lt>fcntl.hE<gt>>           /* Definition of AT_* constants */\n"
"B<#include E<lt>sys/stat.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/chmod.2:48
#, no-wrap
msgid ""
"B<int fchmodat(int >I<dirfd>B<, const char *>I<pathname>B<, mode_t "
">I<mode>B<, int >I<flags>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/chmod.2:58
msgid "B<fchmod>():"
msgstr ""

#.         || (_XOPEN_SOURCE && _XOPEN_SOURCE_EXTENDED)
#. type: Plain text
#: man-pages/man2/chmod.2:62
#, no-wrap
msgid ""
"Since glibc 2.24:\n"
"    _POSIX_C_SOURCE\\ E<gt>=\\ 199309L\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/chmod.2:65
#, no-wrap
msgid ""
"Glibc 2.19 to 2.23\n"
"    _POSIX_C_SOURCE\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/chmod.2:68
#, no-wrap
msgid ""
"Glibc 2.16 to 2.19:\n"
"    _BSD_SOURCE || _POSIX_C_SOURCE\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/chmod.2:72
#, no-wrap
msgid ""
"Glibc 2.12 to 2.16:\n"
"    _BSD_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 500 ||\n"
"        _POSIX_C_SOURCE E<gt>= 200809L\n"
msgstr ""

#.         || (_XOPEN_SOURCE && _XOPEN_SOURCE_EXTENDED)
#. type: Plain text
#: man-pages/man2/chmod.2:76
#, no-wrap
msgid ""
"Glibc 2.11 and earlier:\n"
"    _BSD_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 500\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/chmod.2:80
msgid "B<fchmodat>():"
msgstr ""

#. type: Plain text
#: man-pages/man2/chmod.2:102
msgid ""
"The B<chmod>()  and B<fchmod>()  system calls change a files mode bits.  "
"(The file mode consists of the file permission bits plus the set-user-ID, "
"set-group-ID, and sticky bits.)  These system calls differ only in how the "
"file is specified:"
msgstr ""

#. type: Plain text
#: man-pages/man2/chmod.2:107
msgid ""
"B<chmod>()  changes the mode of the file specified whose pathname is given "
"in I<pathname>, which is dereferenced if it is a symbolic link."
msgstr ""

#. type: Plain text
#: man-pages/man2/chmod.2:111
msgid ""
"B<fchmod>()  changes the mode of the file referred to by the open file "
"descriptor I<fd>."
msgstr ""

#. type: Plain text
#: man-pages/man2/chmod.2:116
msgid ""
"The new file mode is specified in I<mode>, which is a bit mask created by "
"ORing together zero or more of the following:"
msgstr ""

#. type: TP
#: man-pages/man2/chmod.2:116
#, no-wrap
msgid "B<S_ISUID>  (04000)"
msgstr ""

#. type: Plain text
#: man-pages/man2/chmod.2:120
msgid "set-user-ID (set process effective user ID on B<execve>(2))"
msgstr ""

#. type: TP
#: man-pages/man2/chmod.2:120
#, no-wrap
msgid "B<S_ISGID>  (02000)"
msgstr ""

#. type: Plain text
#: man-pages/man2/chmod.2:130
msgid ""
"set-group-ID (set process effective group ID on B<execve>(2); mandatory "
"locking, as described in B<fcntl>(2); take a new file's group from parent "
"directory, as described in B<chown>(2)  and B<mkdir>(2))"
msgstr ""

#. type: TP
#: man-pages/man2/chmod.2:130
#, no-wrap
msgid "B<S_ISVTX>  (01000)"
msgstr ""

#. type: Plain text
#: man-pages/man2/chmod.2:134
msgid "sticky bit (restricted deletion flag, as described in B<unlink>(2))"
msgstr ""

#. type: TP
#: man-pages/man2/chmod.2:134
#, no-wrap
msgid "B<S_IRUSR>  (00400)"
msgstr ""

#. type: Plain text
#: man-pages/man2/chmod.2:137
msgid "read by owner"
msgstr ""

#. type: TP
#: man-pages/man2/chmod.2:137
#, no-wrap
msgid "B<S_IWUSR>  (00200)"
msgstr ""

#. type: Plain text
#: man-pages/man2/chmod.2:140
msgid "write by owner"
msgstr ""

#. type: TP
#: man-pages/man2/chmod.2:140
#, no-wrap
msgid "B<S_IXUSR>  (00100)"
msgstr ""

#. type: Plain text
#: man-pages/man2/chmod.2:144
msgid ""
"execute/search by owner (\"search\" applies for directories, and means that "
"entries within the directory can be accessed)"
msgstr ""

#. type: TP
#: man-pages/man2/chmod.2:144
#, no-wrap
msgid "B<S_IRGRP>  (00040)"
msgstr ""

#. type: Plain text
#: man-pages/man2/chmod.2:147
msgid "read by group"
msgstr ""

#. type: TP
#: man-pages/man2/chmod.2:147
#, no-wrap
msgid "B<S_IWGRP>  (00020)"
msgstr ""

#. type: Plain text
#: man-pages/man2/chmod.2:150
msgid "write by group"
msgstr ""

#. type: TP
#: man-pages/man2/chmod.2:150
#, no-wrap
msgid "B<S_IXGRP>  (00010)"
msgstr ""

#. type: Plain text
#: man-pages/man2/chmod.2:153
msgid "execute/search by group"
msgstr ""

#. type: TP
#: man-pages/man2/chmod.2:153
#, no-wrap
msgid "B<S_IROTH>  (00004)"
msgstr ""

#. type: Plain text
#: man-pages/man2/chmod.2:156
msgid "read by others"
msgstr ""

#. type: TP
#: man-pages/man2/chmod.2:156
#, no-wrap
msgid "B<S_IWOTH>  (00002)"
msgstr ""

#. type: Plain text
#: man-pages/man2/chmod.2:159
msgid "write by others"
msgstr ""

#. type: TP
#: man-pages/man2/chmod.2:159
#, no-wrap
msgid "B<S_IXOTH>  (00001)"
msgstr ""

#. type: Plain text
#: man-pages/man2/chmod.2:162
msgid "execute/search by others"
msgstr ""

#. type: Plain text
#: man-pages/man2/chmod.2:167
msgid ""
"The effective UID of the calling process must match the owner of the file, "
"or the process must be privileged (Linux: it must have the B<CAP_FOWNER> "
"capability)."
msgstr ""

#. type: Plain text
#: man-pages/man2/chmod.2:176
msgid ""
"If the calling process is not privileged (Linux: does not have the "
"B<CAP_FSETID> capability), and the group of the file does not match the "
"effective group ID of the process or one of its supplementary group IDs, the "
"B<S_ISGID> bit will be turned off, but this will not cause an error to be "
"returned."
msgstr ""

#. type: Plain text
#: man-pages/man2/chmod.2:188
msgid ""
"As a security measure, depending on the filesystem, the set-user-ID and "
"set-group-ID execution bits may be turned off if a file is written.  (On "
"Linux, this occurs if the writing process does not have the B<CAP_FSETID> "
"capability.)  On some filesystems, only the superuser can set the sticky "
"bit, which may have a special meaning.  For the sticky bit, and for "
"set-user-ID and set-group-ID bits on directories, see B<inode>(7)."
msgstr ""

#. type: Plain text
#: man-pages/man2/chmod.2:196
msgid ""
"On NFS filesystems, restricting the permissions will immediately influence "
"already open files, because the access control is done on the server, but "
"open files are maintained by the client.  Widening the permissions may be "
"delayed for other clients if attribute caching is enabled on them."
msgstr ""

#. type: SS
#: man-pages/man2/chmod.2:196
#, no-wrap
msgid "fchmodat()"
msgstr ""

#. type: Plain text
#: man-pages/man2/chmod.2:202
msgid ""
"The B<fchmodat>()  system call operates in exactly the same way as "
"B<chmod>(), except for the differences described here."
msgstr ""

#. type: Plain text
#: man-pages/man2/chmod.2:212
msgid ""
"If the pathname given in I<pathname> is relative, then it is interpreted "
"relative to the directory referred to by the file descriptor I<dirfd> "
"(rather than relative to the current working directory of the calling "
"process, as is done by B<chmod>()  for a relative pathname)."
msgstr ""

#. type: Plain text
#: man-pages/man2/chmod.2:224
msgid ""
"If I<pathname> is relative and I<dirfd> is the special value B<AT_FDCWD>, "
"then I<pathname> is interpreted relative to the current working directory of "
"the calling process (like B<chmod>())."
msgstr ""

#. type: Plain text
#: man-pages/man2/chmod.2:233
msgid "I<flags> can either be 0, or include the following flag:"
msgstr ""

#. type: Plain text
#: man-pages/man2/chmod.2:240
msgid ""
"If I<pathname> is a symbolic link, do not dereference it: instead operate on "
"the link itself.  This flag is not currently implemented."
msgstr ""

#. type: Plain text
#: man-pages/man2/chmod.2:245
msgid "See B<openat>(2)  for an explanation of the need for B<fchmodat>()."
msgstr ""

#. type: Plain text
#: man-pages/man2/chmod.2:253 man-pages/man2/chown.2:233
msgid ""
"Depending on the filesystem, errors other than those listed below can be "
"returned."
msgstr ""

#. type: Plain text
#: man-pages/man2/chmod.2:257
msgid "The more general errors for B<chmod>()  are listed below:"
msgstr ""

#. type: Plain text
#: man-pages/man2/chmod.2:292
msgid ""
"The effective UID does not match the owner of the file, and the process is "
"not privileged (Linux: it does not have the B<CAP_FOWNER> capability)."
msgstr ""

#. type: Plain text
#: man-pages/man2/chmod.2:304
msgid "The general errors for B<fchmod>()  are listed below:"
msgstr ""

#. type: Plain text
#: man-pages/man2/chmod.2:309
msgid "The file descriptor I<fd> is not valid."
msgstr ""

#. type: Plain text
#: man-pages/man2/chmod.2:312 man-pages/man2/chmod.2:315
#: man-pages/man2/chmod.2:318 man-pages/man2/chown.2:289
#: man-pages/man2/chown.2:292 man-pages/man2/chown.2:295
msgid "See above."
msgstr ""

#. type: Plain text
#: man-pages/man2/chmod.2:325
msgid ""
"The same errors that occur for B<chmod>()  can also occur for "
"B<fchmodat>().  The following additional errors can occur for B<fchmodat>():"
msgstr ""

#. type: Plain text
#: man-pages/man2/chmod.2:345
msgid "I<flags> specified B<AT_SYMLINK_NOFOLLOW>, which is not supported."
msgstr ""

#. type: Plain text
#: man-pages/man2/chmod.2:349
msgid ""
"B<fchmodat>()  was added to Linux in kernel 2.6.16; library support was "
"added to glibc in version 2.4."
msgstr ""

#. type: Plain text
#: man-pages/man2/chmod.2:353
msgid "B<chmod>(), B<fchmod>(): 4.4BSD, SVr4, POSIX.1-2001i, POSIX.1-2008."
msgstr ""

#. type: Plain text
#: man-pages/man2/chmod.2:356
msgid "B<fchmodat>(): POSIX.1-2008."
msgstr ""

#. type: Plain text
#: man-pages/man2/chmod.2:367
msgid ""
"The GNU C library B<fchmodat>()  wrapper function implements the "
"POSIX-specified interface described in this page.  This interface differs "
"from the underlying Linux system call, which does I<not> have a I<flags> "
"argument."
msgstr ""

#. type: Plain text
#: man-pages/man2/chmod.2:380
msgid ""
"On older kernels where B<fchmodat>()  is unavailable, the glibc wrapper "
"function falls back to the use of B<chmod>().  When I<pathname> is a "
"relative pathname, glibc constructs a pathname based on the symbolic link in "
"I</proc/self/fd> that corresponds to the I<dirfd> argument."
msgstr ""

#. type: Plain text
#: man-pages/man2/chmod.2:388
msgid ""
"B<chmod>(1), B<chown>(2), B<execve>(2), B<open>(2), B<stat>(2), B<inode>(7), "
"B<path_resolution>(7), B<symlink>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/move_pages.2:20
#, no-wrap
msgid "MOVE_PAGES"
msgstr ""

#. type: Plain text
#: man-pages/man2/move_pages.2:23
msgid "move_pages - move individual pages of a process to another node"
msgstr ""

#. type: Plain text
#: man-pages/man2/move_pages.2:29
#, no-wrap
msgid ""
"B<long move_pages(int >I<pid>B<, unsigned long count, void **>I<pages>B<,>\n"
"B<                const int *>I<nodes>B<, int *>I<status>B<, int "
">I<flags>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/move_pages.2:32 man-pages/man2/migrate_pages.2:31
msgid "Link with I<-lnuma>."
msgstr ""

#. type: Plain text
#: man-pages/man2/move_pages.2:45
msgid ""
"B<move_pages>()  moves the specified I<pages> of the process I<pid> to the "
"memory nodes specified by I<nodes>.  The result of the move is reflected in "
"I<status>.  The I<flags> indicate constraints on the pages to be moved."
msgstr ""

#. type: Plain text
#: man-pages/man2/move_pages.2:53
msgid ""
"I<pid> is the ID of the process in which pages are to be moved.  If I<pid> "
"is 0, then B<move_pages>()  moves pages of the calling process."
msgstr ""

#. type: Plain text
#: man-pages/man2/move_pages.2:55
msgid "To move pages in another process requires the following privileges:"
msgstr ""

#. type: Plain text
#: man-pages/man2/move_pages.2:61
msgid ""
"In kernels up to and including Linux 4.12: the caller must be privileged "
"(B<CAP_SYS_NICE>)  or the real or effective user ID of the calling process "
"must match the real or saved-set user ID of the target process."
msgstr ""

#.  commit 197e7e521384a23b9e585178f3f11c9fa08274b9
#. type: Plain text
#: man-pages/man2/move_pages.2:73
msgid ""
"The older rules allowed the caller to discover various virtual address "
"choices made by the kernel that could lead to the defeat of "
"address-space-layout randomization for a process owned by the same UID as "
"the caller, the rules were changed starting with Linux 4.13.  Since Linux "
"4.13, permission is governed by a ptrace access mode "
"B<PTRACE_MODE_READ_REALCREDS> check with respect to the target process; see "
"B<ptrace>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/move_pages.2:81
msgid ""
"I<count> is the number of pages to move.  It defines the size of the three "
"arrays I<pages>, I<nodes>, and I<status>."
msgstr ""

#.  FIXME Describe the result if pointers in the 'pages' array are
#.  not aligned to page boundaries
#. type: Plain text
#: man-pages/man2/move_pages.2:89
msgid ""
"I<pages> is an array of pointers to the pages that should be moved.  These "
"are pointers that should be aligned to page boundaries.  Addresses are "
"specified as seen by the process specified by I<pid>."
msgstr ""

#. type: Plain text
#: man-pages/man2/move_pages.2:102
msgid ""
"I<nodes> is an array of integers that specify the desired location for each "
"page.  Each element in the array is a node number.  I<nodes> can also be "
"NULL, in which case B<move_pages>()  does not move any pages but instead "
"will return the node where each page currently resides, in the I<status> "
"array.  Obtaining the status of each page may be necessary to determine "
"pages that need to be moved."
msgstr ""

#. type: Plain text
#: man-pages/man2/move_pages.2:108
msgid ""
"I<status> is an array of integers that return the status of each page.  The "
"array contains valid values only if B<move_pages>()  did not return an "
"error."
msgstr ""

#. type: Plain text
#: man-pages/man2/move_pages.2:120
msgid ""
"I<flags> specify what types of pages to move.  B<MPOL_MF_MOVE> means that "
"only pages that are in exclusive use by the process are to be moved.  "
"B<MPOL_MF_MOVE_ALL> means that pages shared between multiple processes can "
"also be moved.  The process must be privileged (B<CAP_SYS_NICE>)  to use "
"B<MPOL_MF_MOVE_ALL>."
msgstr ""

#. type: SS
#: man-pages/man2/move_pages.2:120
#, no-wrap
msgid "Page states in the status array"
msgstr ""

#. type: Plain text
#: man-pages/man2/move_pages.2:124
msgid "The following values can be returned in each element of the I<status> array."
msgstr ""

#. type: TP
#: man-pages/man2/move_pages.2:124
#, no-wrap
msgid "B<0..MAX_NUMNODES>"
msgstr ""

#. type: Plain text
#: man-pages/man2/move_pages.2:127
msgid "Identifies the node on which the page resides."
msgstr ""

#. type: TP
#: man-pages/man2/move_pages.2:127
#, no-wrap
msgid "B<-EACCES>"
msgstr ""

#. type: Plain text
#: man-pages/man2/move_pages.2:132
msgid ""
"The page is mapped by multiple processes and can be moved only if "
"B<MPOL_MF_MOVE_ALL> is specified."
msgstr ""

#. type: TP
#: man-pages/man2/move_pages.2:132
#, no-wrap
msgid "B<-EBUSY>"
msgstr ""

#. type: Plain text
#: man-pages/man2/move_pages.2:138
msgid ""
"The page is currently busy and cannot be moved.  Try again later.  This "
"occurs if a page is undergoing I/O or another kernel subsystem is holding a "
"reference to the page."
msgstr ""

#. type: TP
#: man-pages/man2/move_pages.2:138
#, no-wrap
msgid "B<-EFAULT>"
msgstr ""

#. type: Plain text
#: man-pages/man2/move_pages.2:141
msgid "This is a zero page or the memory area is not mapped by the process."
msgstr ""

#. type: TP
#: man-pages/man2/move_pages.2:141
#, no-wrap
msgid "B<-EIO>"
msgstr ""

#. type: Plain text
#: man-pages/man2/move_pages.2:148
msgid ""
"Unable to write back a page.  The page has to be written back in order to "
"move it since the page is dirty and the filesystem does not provide a "
"migration function that would allow the move of dirty pages."
msgstr ""

#. type: TP
#: man-pages/man2/move_pages.2:148
#, no-wrap
msgid "B<-EINVAL>"
msgstr ""

#. type: Plain text
#: man-pages/man2/move_pages.2:153
msgid ""
"A dirty page cannot be moved.  The filesystem does not provide a migration "
"function and has no ability to write back pages."
msgstr ""

#. type: TP
#: man-pages/man2/move_pages.2:153
#, no-wrap
msgid "B<-ENOENT>"
msgstr ""

#. type: Plain text
#: man-pages/man2/move_pages.2:156
msgid "The page is not present."
msgstr ""

#. type: TP
#: man-pages/man2/move_pages.2:156
#, no-wrap
msgid "B<-ENOMEM>"
msgstr ""

#. type: Plain text
#: man-pages/man2/move_pages.2:159
msgid "Unable to allocate memory on target node."
msgstr ""

#.  FIXME . Is the following quite true: does the wrapper in numactl
#.  do the right thing?
#. type: Plain text
#: man-pages/man2/move_pages.2:168
msgid ""
"On success B<move_pages>()  returns zero.  On error, it returns -1, and sets "
"I<errno> to indicate the error."
msgstr ""

#.  commit 3140a2273009c01c27d316f35ab76a37e105fdd8
#. type: Plain text
#: man-pages/man2/move_pages.2:175
msgid ""
"Too many pages to move.  Since Linux 2.6.29, the kernel no longer generates "
"this error."
msgstr ""

#.  FIXME Clarify "current cpuset" in the description of the EACCES error.
#.  Is that the cpuset of the caller or the target?
#. type: Plain text
#: man-pages/man2/move_pages.2:180
msgid "One of the target nodes is not allowed by the current cpuset."
msgstr ""

#. type: Plain text
#: man-pages/man2/move_pages.2:183
msgid "Parameter array could not be accessed."
msgstr ""

#. type: Plain text
#: man-pages/man2/move_pages.2:190
msgid ""
"Flags other than B<MPOL_MF_MOVE> and B<MPOL_MF_MOVE_ALL> was specified or an "
"attempt was made to migrate pages of a kernel thread."
msgstr ""

#. type: Plain text
#: man-pages/man2/move_pages.2:193
msgid "One of the target nodes is not online."
msgstr ""

#. type: Plain text
#: man-pages/man2/move_pages.2:199
msgid ""
"No pages were found that require moving.  All pages are either already on "
"the target node, not present, had an invalid address or could not be moved "
"because they were mapped by multiple processes."
msgstr ""

#. type: Plain text
#: man-pages/man2/move_pages.2:208
msgid ""
"The caller specified B<MPOL_MF_MOVE_ALL> without sufficient privileges "
"(B<CAP_SYS_NICE>).  Or, the caller attempted to move pages of a process "
"belonging to another user but did not have privilege to do so "
"(B<CAP_SYS_NICE>)."
msgstr ""

#. type: Plain text
#: man-pages/man2/move_pages.2:211
msgid "Process does not exist."
msgstr ""

#. type: Plain text
#: man-pages/man2/move_pages.2:214
msgid "B<move_pages>()  first appeared on Linux in version 2.6.18."
msgstr ""

#.  FIXME Clarify "current cpuset".  Is that the cpuset of the caller
#.  or the target?
#. type: Plain text
#: man-pages/man2/move_pages.2:230
msgid ""
"Use B<get_mempolicy>(2)  with the B<MPOL_F_MEMS_ALLOWED> flag to obtain the "
"set of nodes that are allowed by the current cpuset.  Note that this "
"information is subject to change at any time by manual or automatic "
"reconfiguration of the cpuset."
msgstr ""

#. type: Plain text
#: man-pages/man2/move_pages.2:240
msgid ""
"Use of this function may result in pages whose location (node) violates the "
"memory policy established for the specified addresses (See B<mbind>(2))  "
"and/or the specified process (See B<set_mempolicy>(2)).  That is, memory "
"policy does not constrain the destination nodes used by B<move_pages>()."
msgstr ""

#. type: Plain text
#: man-pages/man2/move_pages.2:246 man-pages/man2/migrate_pages.2:172
msgid ""
"The I<E<lt>numaif.hE<gt>> header is not included with glibc, but requires "
"installing I<libnuma-devel> or a similar package."
msgstr ""

#. type: Plain text
#: man-pages/man2/move_pages.2:255 man-pages/man2/migrate_pages.2:182
msgid ""
"B<get_mempolicy>(2), B<mbind>(2), B<set_mempolicy>(2), B<numa>(3), "
"B<numa_maps>(5), B<cpuset>(7), B<numa>(7), B<migratepages>(8), "
"B<numastat>(8)"
msgstr ""

#. type: TH
#: man-pages/man2/inotify_add_watch.2:28
#, no-wrap
msgid "INOTIFY_ADD_WATCH"
msgstr ""

#. type: Plain text
#: man-pages/man2/inotify_add_watch.2:31
msgid "inotify_add_watch - add a watch to an initialized inotify instance"
msgstr ""

#. type: Plain text
#: man-pages/man2/inotify_add_watch.2:35
msgid ""
"B<int inotify_add_watch(int >I<fd>B<, const char *>I<pathname>B<, uint32_t "
">I<mask>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/inotify_add_watch.2:54
msgid ""
"B<inotify_add_watch>()  adds a new watch, or modifies an existing watch, for "
"the file whose location is specified in I<pathname>; the caller must have "
"read permission for this file.  The I<fd> argument is a file descriptor "
"referring to the inotify instance whose watch list is to be modified.  The "
"events to be monitored for I<pathname> are specified in the I<mask> bit-mask "
"argument.  See B<inotify>(7)  for a description of the bits that can be set "
"in I<mask>."
msgstr ""

#. type: Plain text
#: man-pages/man2/inotify_add_watch.2:66
msgid ""
"A successful call to B<inotify_add_watch>()  returns a unique watch "
"descriptor for this inotify instance, for the filesystem object (inode) that "
"corresponds to I<pathname>.  If the filesystem object was not previously "
"being watched by this inotify instance, then the watch descriptor is newly "
"allocated.  If the filesystem object was already being watched (perhaps via "
"a different link to the same object), then the descriptor for the existing "
"watch is returned."
msgstr ""

#. type: Plain text
#: man-pages/man2/inotify_add_watch.2:77
msgid ""
"The watch descriptor is returned by later B<read>(2)s from the inotify file "
"descriptor.  These reads fetch I<inotify_event> structures (see "
"B<inotify>(7))  indicating filesystem events; the watch descriptor inside "
"this structure identifies the object for which the event occurred."
msgstr ""

#. type: Plain text
#: man-pages/man2/inotify_add_watch.2:84
msgid ""
"On success, B<inotify_add_watch>()  returns a nonnegative watch descriptor.  "
"On error, -1 is returned and I<errno> is set appropriately."
msgstr ""

#. type: Plain text
#: man-pages/man2/inotify_add_watch.2:88
msgid "Read access to the given file is not permitted."
msgstr ""

#. type: Plain text
#: man-pages/man2/inotify_add_watch.2:91
msgid "The given file descriptor is not valid."
msgstr ""

#. type: Plain text
#: man-pages/man2/inotify_add_watch.2:100
msgid ""
"I<mask> contains B<IN_MASK_CREATE> and I<pathname> refers to a file already "
"being watched by the same I<fd>."
msgstr ""

#. type: Plain text
#: man-pages/man2/inotify_add_watch.2:104
msgid "I<pathname> points outside of the process's accessible address space."
msgstr ""

#. type: Plain text
#: man-pages/man2/inotify_add_watch.2:115
msgid ""
"The given event mask contains no valid events; or I<mask> contains both "
"B<IN_MASK_ADD> and B<IN_MASK_CREATE>; or I<fd> is not an inotify file "
"descriptor."
msgstr ""

#. type: Plain text
#: man-pages/man2/inotify_add_watch.2:131
msgid ""
"The user limit on the total number of inotify watches was reached or the "
"kernel failed to allocate a needed resource."
msgstr ""

#. type: Plain text
#: man-pages/man2/inotify_add_watch.2:139
msgid "I<mask> contains B<IN_ONLYDIR> and I<pathname> is not a directory."
msgstr ""

#. type: Plain text
#: man-pages/man2/inotify_add_watch.2:146
msgid "B<inotify_init>(2), B<inotify_rm_watch>(2), B<inotify>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/chdir.2:33
#, no-wrap
msgid "CHDIR"
msgstr ""

#. type: Plain text
#: man-pages/man2/chdir.2:36
msgid "chdir, fchdir - change working directory"
msgstr ""

#. type: Plain text
#: man-pages/man2/chdir.2:40
msgid "B<int chdir(const char *>I<path>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/chdir.2:42
msgid "B<int fchdir(int >I<fd>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/chdir.2:49
msgid "B<fchdir>():"
msgstr ""

#.     || _XOPEN_SOURCE\ &&\ _XOPEN_SOURCE_EXTENDED
#. type: Plain text
#: man-pages/man2/chdir.2:56
#, no-wrap
msgid ""
"_XOPEN_SOURCE\\ E<gt>=\\ 500\n"
"    || /* Since glibc 2.12: */ _POSIX_C_SOURCE\\ E<gt>=\\ 200809L\n"
"    || /* Glibc up to and including 2.19: */ _BSD_SOURCE\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/chdir.2:64
msgid ""
"B<chdir>()  changes the current working directory of the calling process to "
"the directory specified in I<path>."
msgstr ""

#. type: Plain text
#: man-pages/man2/chdir.2:70
msgid ""
"B<fchdir>()  is identical to B<chdir>(); the only difference is that the "
"directory is given as an open file descriptor."
msgstr ""

#. type: Plain text
#: man-pages/man2/chdir.2:81
msgid ""
"Depending on the filesystem, other errors can be returned.  The more general "
"errors for B<chdir>()  are listed below:"
msgstr ""

#. type: Plain text
#: man-pages/man2/chdir.2:87
msgid ""
"Search permission is denied for one of the components of I<path>.  (See also "
"B<path_resolution>(7).)"
msgstr ""

#. type: Plain text
#: man-pages/man2/chdir.2:107
msgid "The directory specified in I<path> does not exist."
msgstr ""

#. type: Plain text
#: man-pages/man2/chdir.2:119
msgid "The general errors for B<fchdir>()  are listed below:"
msgstr ""

#. type: Plain text
#: man-pages/man2/chdir.2:123
msgid "Search permission was denied on the directory open on I<fd>."
msgstr ""

#. type: Plain text
#: man-pages/man2/chdir.2:131
msgid "I<fd> does not refer to a directory."
msgstr ""

#.  SVr4 documents additional error codes ENXIO and ENODEV.
#.  SUSv2 documents additional error codes EMFILE and EOVERFLOW.
#. type: Plain text
#: man-pages/man2/chdir.2:133 man-pages/man2/mmap.2:662
msgid "POSIX.1-2001, POSIX.1-2008, SVr4, 4.4BSD."
msgstr ""

#. type: Plain text
#: man-pages/man2/chdir.2:136
msgid ""
"The current working directory is the starting point for interpreting "
"relative pathnames (those not starting with \\(aq/\\(aq)."
msgstr ""

#. type: Plain text
#: man-pages/man2/chdir.2:142
msgid ""
"A child process created via B<fork>(2)  inherits its parent's current "
"working directory.  The current working directory is left unchanged by "
"B<execve>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/chdir.2:145
msgid "B<chroot>(2), B<getcwd>(3), B<path_resolution>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/stime.2:30
#, no-wrap
msgid "STIME"
msgstr ""

#. type: Plain text
#: man-pages/man2/stime.2:33
msgid "stime - set time"
msgstr ""

#. type: Plain text
#: man-pages/man2/stime.2:37
msgid "B<int stime(const time_t *>I<t>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/stime.2:48
#, no-wrap
msgid ""
"B<stime>():\n"
"    Since glibc 2.19:\n"
"        _DEFAULT_SOURCE\n"
"    Glibc 2.19 and earlier:\n"
"        _SVID_SOURCE\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/stime.2:56
msgid ""
"B<stime>()  sets the system's idea of the time and date.  The time, pointed "
"to by I<t>, is measured in seconds since the Epoch, 1970-01-01 00:00:00 "
"+0000 (UTC).  B<stime>()  may be executed only by the superuser."
msgstr ""

#. type: Plain text
#: man-pages/man2/stime.2:65
msgid "Error in getting information from user space."
msgstr ""

#. type: Plain text
#: man-pages/man2/stime.2:71
msgid ""
"The calling process has insufficient privilege.  Under Linux, the "
"B<CAP_SYS_TIME> privilege is required."
msgstr ""

#. type: Plain text
#: man-pages/man2/stime.2:76
msgid "B<date>(1), B<settimeofday>(2), B<capabilities>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/readv.2:32
#, no-wrap
msgid "READV"
msgstr ""

#. type: Plain text
#: man-pages/man2/readv.2:35
msgid ""
"readv, writev, preadv, pwritev, preadv2, pwritev2 - read or write data into "
"multiple buffers"
msgstr ""

#. type: Plain text
#: man-pages/man2/readv.2:38 man-pages/man2/process_vm_readv.2:35
#, no-wrap
msgid "B<#include E<lt>sys/uio.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/readv.2:40
#, no-wrap
msgid ""
"B<ssize_t readv(int >I<fd>B<, const struct iovec *>I<iov>B<, int "
">I<iovcnt>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/readv.2:42
#, no-wrap
msgid ""
"B<ssize_t writev(int >I<fd>B<, const struct iovec *>I<iov>B<, int "
">I<iovcnt>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/readv.2:45
#, no-wrap
msgid ""
"B<ssize_t preadv(int >I<fd>B<, const struct iovec *>I<iov>B<, int "
">I<iovcnt>B<,>\n"
"B<               off_t >I<offset>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/readv.2:48
#, no-wrap
msgid ""
"B<ssize_t pwritev(int >I<fd>B<, const struct iovec *>I<iov>B<, int "
">I<iovcnt>B<,>\n"
"B<                off_t >I<offset>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/readv.2:51
#, no-wrap
msgid ""
"B<ssize_t preadv2(int >I<fd>B<, const struct iovec *>I<iov>B<, int "
">I<iovcnt>B<,>\n"
"B<                off_t >I<offset>B<, int >I<flags>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/readv.2:54
#, no-wrap
msgid ""
"B<ssize_t pwritev2(int >I<fd>B<, const struct iovec *>I<iov>B<, int "
">I<iovcnt>B<,>\n"
"B<                 off_t >I<offset>B<, int >I<flags>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/readv.2:67
#, no-wrap
msgid ""
"B<preadv>(),\n"
"B<pwritev>():\n"
"    Since glibc 2.19:\n"
"        _DEFAULT_SOURCE\n"
"    Glibc 2.19 and earlier:\n"
"        _BSD_SOURCE\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/readv.2:77
msgid ""
"The B<readv>()  system call reads I<iovcnt> buffers from the file associated "
"with the file descriptor I<fd> into the buffers described by I<iov> "
"(\"scatter input\")."
msgstr ""

#. type: Plain text
#: man-pages/man2/readv.2:87
msgid ""
"The B<writev>()  system call writes I<iovcnt> buffers of data described by "
"I<iov> to the file associated with the file descriptor I<fd> (\"gather "
"output\")."
msgstr ""

#. type: Plain text
#: man-pages/man2/readv.2:96
msgid ""
"The pointer I<iov> points to an array of I<iovec> structures, defined in "
"I<E<lt>sys/uio.hE<gt>> as:"
msgstr ""

#. type: Plain text
#: man-pages/man2/readv.2:103 man-pages/man2/process_vm_readv.2:128
#, no-wrap
msgid ""
"struct iovec {\n"
"    void  *iov_base;    /* Starting address */\n"
"    size_t iov_len;     /* Number of bytes to transfer */\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/readv.2:111
msgid ""
"The B<readv>()  system call works just like B<read>(2)  except that multiple "
"buffers are filled."
msgstr ""

#. type: Plain text
#: man-pages/man2/readv.2:117
msgid ""
"The B<writev>()  system call works just like B<write>(2)  except that "
"multiple buffers are written out."
msgstr ""

#. type: Plain text
#: man-pages/man2/readv.2:136
msgid ""
"Buffers are processed in array order.  This means that B<readv>()  "
"completely fills I<iov>[0] before proceeding to I<iov>[1], and so on.  (If "
"there is insufficient data, then not all buffers pointed to by I<iov> may be "
"filled.)  Similarly, B<writev>()  writes out the entire contents of "
"I<iov>[0] before proceeding to I<iov>[1], and so on."
msgstr ""

#.  Regarding atomicity, see https://bugzilla.kernel.org/show_bug.cgi?id=10596
#. type: Plain text
#: man-pages/man2/readv.2:155
msgid ""
"The data transfers performed by B<readv>()  and B<writev>()  are atomic: the "
"data written by B<writev>()  is written as a single block that is not "
"intermingled with output from writes in other processes (but see B<pipe>(7)  "
"for an exception); analogously, B<readv>()  is guaranteed to read a "
"contiguous block of data from the file, regardless of read operations "
"performed in other threads or processes that have file descriptors referring "
"to the same open file description (see B<open>(2))."
msgstr ""

#. type: SS
#: man-pages/man2/readv.2:155
#, no-wrap
msgid "preadv() and pwritev()"
msgstr ""

#. type: Plain text
#: man-pages/man2/readv.2:168
msgid ""
"The B<preadv>()  system call combines the functionality of B<readv>()  and "
"B<pread>(2).  It performs the same task as B<readv>(), but adds a fourth "
"argument, I<offset>, which specifies the file offset at which the input "
"operation is to be performed."
msgstr ""

#. type: Plain text
#: man-pages/man2/readv.2:181
msgid ""
"The B<pwritev>()  system call combines the functionality of B<writev>()  and "
"B<pwrite>(2).  It performs the same task as B<writev>(), but adds a fourth "
"argument, I<offset>, which specifies the file offset at which the output "
"operation is to be performed."
msgstr ""

#. type: Plain text
#: man-pages/man2/readv.2:186
msgid ""
"The file offset is not changed by these system calls.  The file referred to "
"by I<fd> must be capable of seeking."
msgstr ""

#. type: SS
#: man-pages/man2/readv.2:186
#, no-wrap
msgid "preadv2() and pwritev2()"
msgstr ""

#. type: Plain text
#: man-pages/man2/readv.2:195
msgid ""
"These system calls are similar to B<preadv>()  and B<pwritev>()  calls, but "
"add a fifth argument, I<flags>, which modifies the behavior on a per-call "
"basis."
msgstr ""

#. type: Plain text
#: man-pages/man2/readv.2:203
msgid ""
"Unlike B<preadv>()  and B<pwritev>(), if the I<offset> argument is -1, then "
"the current file offset is used and updated."
msgstr ""

#. type: Plain text
#: man-pages/man2/readv.2:207
msgid ""
"The I<flags> argument contains a bitwise OR of zero or more of the following "
"flags:"
msgstr ""

#. type: TP
#: man-pages/man2/readv.2:207
#, no-wrap
msgid "B<RWF_DSYNC> (since Linux 4.7)"
msgstr ""

#.  commit e864f39569f4092c2b2bc72c773b6e486c7e3bd9
#. type: Plain text
#: man-pages/man2/readv.2:217
msgid ""
"Provide a per-write equivalent of the B<O_DSYNC> B<open>(2)  flag.  This "
"flag is meaningful only for B<pwritev2>(), and its effect applies only to "
"the data range written by the system call."
msgstr ""

#. type: TP
#: man-pages/man2/readv.2:217
#, no-wrap
msgid "B<RWF_HIPRI> (since Linux 4.6)"
msgstr ""

#. type: Plain text
#: man-pages/man2/readv.2:225
msgid ""
"High priority read/write.  Allows block-based filesystems to use polling of "
"the device, which provides lower latency, but may use additional resources.  "
"(Currently, this feature is usable only on a file descriptor opened using "
"the B<O_DIRECT> flag.)"
msgstr ""

#. type: TP
#: man-pages/man2/readv.2:225
#, no-wrap
msgid "B<RWF_SYNC> (since Linux 4.7)"
msgstr ""

#.  commit e864f39569f4092c2b2bc72c773b6e486c7e3bd9
#. type: Plain text
#: man-pages/man2/readv.2:235
msgid ""
"Provide a per-write equivalent of the B<O_SYNC> B<open>(2)  flag.  This flag "
"is meaningful only for B<pwritev2>(), and its effect applies only to the "
"data range written by the system call."
msgstr ""

#.  commit 3239d834847627b6634a4139cf1dc58f6f137a46
#.  commit 91f9943e1c7b6638f27312d03fe71fcc67b23571
#. type: Plain text
#: man-pages/man2/readv.2:251
msgid ""
"Do not wait for data which is not immediately available.  If this flag is "
"specified, the B<preadv2>()  system call will return instantly if it would "
"have to read data from the backing storage or wait for a lock.  If some data "
"was successfully read, it will return the number of bytes read.  If no bytes "
"were read, it will return -1 and set I<errno> to B<EAGAIN>.  Currently, this "
"flag is meaningful only for B<preadv2>()."
msgstr ""

#.  commit e1fc742e14e01d84d9693c4aca4ab23da65811fb
#. type: Plain text
#: man-pages/man2/readv.2:268
msgid ""
"Provide a per-write equivalent of the B<O_APPEND> B<open>(2)  flag.  This "
"flag is meaningful only for B<pwritev2>(), and its effect applies only to "
"the data range written by the system call.  The I<offset> argument does not "
"affect the write operation; the data is always appended to the end of the "
"file.  However, if the I<offset> argument is -1, the current file offset is "
"updated."
msgstr ""

#. type: Plain text
#: man-pages/man2/readv.2:280
msgid ""
"On success, B<readv>(), B<preadv>()  and B<preadv2>()  return the number of "
"bytes read; B<writev>(), B<pwritev>()  and B<pwritev2>()  return the number "
"of bytes written."
msgstr ""

#. type: Plain text
#: man-pages/man2/readv.2:286 man-pages/man2/pread.2:93
msgid ""
"Note that it is not an error for a successful call to transfer fewer bytes "
"than requested (see B<read>(2)  and B<write>(2))."
msgstr ""

#. type: Plain text
#: man-pages/man2/readv.2:302
msgid ""
"The errors are as given for B<read>(2)  and B<write>(2).  Furthermore, "
"B<preadv>(), B<preadv2>(), B<pwritev>(), and B<pwritev2>()  can also fail "
"for the same reasons as B<lseek>(2).  Additionally, the following errors are "
"defined:"
msgstr ""

#. type: Plain text
#: man-pages/man2/readv.2:309
msgid "The sum of the I<iov_len> values overflows an I<ssize_t> value."
msgstr ""

#. type: Plain text
#: man-pages/man2/readv.2:314
msgid ""
"The vector count, I<iovcnt>, is less than zero or greater than the permitted "
"maximum."
msgstr ""

#. type: Plain text
#: man-pages/man2/readv.2:317
msgid "An unknown flag is specified in I<flags>."
msgstr ""

#. type: Plain text
#: man-pages/man2/readv.2:322
msgid ""
"B<preadv>()  and B<pwritev>()  first appeared in Linux 2.6.30; library "
"support was added in glibc 2.10."
msgstr ""

#. type: Plain text
#: man-pages/man2/readv.2:328
msgid ""
"B<preadv2>()  and B<pwritev2>()  first appeared in Linux 4.6.  Library "
"support was added in glibc 2.26."
msgstr ""

#.  Linux libc5 used \fIsize_t\fP as the type of the \fIiovcnt\fP argument,
#.  and \fIint\fP as the return type.
#.  The readv/writev system calls were buggy before Linux 1.3.40.
#.  (Says release.libc.)
#. type: Plain text
#: man-pages/man2/readv.2:337
msgid ""
"B<readv>(), B<writev>(): POSIX.1-2001, POSIX.1-2008, 4.4BSD (these system "
"calls first appeared in 4.2BSD)."
msgstr ""

#. type: Plain text
#: man-pages/man2/readv.2:341
msgid "B<preadv>(), B<pwritev>(): nonstandard, but present also on the modern BSDs."
msgstr ""

#. type: Plain text
#: man-pages/man2/readv.2:345
msgid "B<preadv2>(), B<pwritev2>(): nonstandard Linux extension."
msgstr ""

#. type: Plain text
#: man-pages/man2/readv.2:359
msgid ""
"POSIX.1 allows an implementation to place a limit on the number of items "
"that can be passed in I<iov>.  An implementation can advertise its limit by "
"defining B<IOV_MAX> in I<E<lt>limits.hE<gt>> or at run time via the return "
"value from I<sysconf(_SC_IOV_MAX)>.  On modern Linux systems, the limit is "
"1024.  Back in Linux 2.0 days, this limit was 16."
msgstr ""

#. type: Plain text
#: man-pages/man2/readv.2:369
msgid ""
"The raw B<preadv>()  and B<pwritev>()  system calls have call signatures "
"that differ slightly from that of the corresponding GNU C library wrapper "
"functions shown in the SYNOPSIS.  The final argument, I<offset>, is unpacked "
"by the wrapper functions into two arguments in the system calls:"
msgstr ""

#. type: Plain text
#: man-pages/man2/readv.2:371
msgid "B< unsigned long >I<pos_l>B<, unsigned long >I<pos>"
msgstr ""

#. type: Plain text
#: man-pages/man2/readv.2:374
msgid ""
"These arguments contain, respectively, the low order and high order 32 bits "
"of I<offset>."
msgstr ""

#. type: SS
#: man-pages/man2/readv.2:374
#, no-wrap
msgid "Historical C library/kernel differences"
msgstr ""

#. type: Plain text
#: man-pages/man2/readv.2:400
msgid ""
"To deal with the fact that B<IOV_MAX> was so low on early versions of Linux, "
"the glibc wrapper functions for B<readv>()  and B<writev>()  did some extra "
"work if they detected that the underlying kernel system call failed because "
"this limit was exceeded.  In the case of B<readv>(), the wrapper function "
"allocated a temporary buffer large enough for all of the items specified by "
"I<iov>, passed that buffer in a call to B<read>(2), copied data from the "
"buffer to the locations specified by the I<iov_base> fields of the elements "
"of I<iov>, and then freed the buffer.  The wrapper function for B<writev>()  "
"performed the analogous task using a temporary buffer and a call to "
"B<write>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/readv.2:411
msgid ""
"The need for this extra effort in the glibc wrapper functions went away with "
"Linux 2.2 and later.  However, glibc continued to provide this behavior "
"until version 2.10.  Starting with glibc version 2.9, the wrapper functions "
"provide this behavior only if the library detects that the system is running "
"a Linux kernel older than version 2.6.18 (an arbitrarily selected kernel "
"version).  And since glibc 2.20 (which requires a minimum Linux kernel "
"version of 2.6.32), the glibc wrapper functions always just directly invoke "
"the system calls."
msgstr ""

#. type: Plain text
#: man-pages/man2/readv.2:414
msgid "The following code sample demonstrates the use of B<writev>():"
msgstr ""

#. type: Plain text
#: man-pages/man2/readv.2:421
#, no-wrap
msgid ""
"char *str0 = \"hello \";\n"
"char *str1 = \"world\\en\";\n"
"struct iovec iov[2];\n"
"ssize_t nwritten;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/readv.2:426
#, no-wrap
msgid ""
"iov[0].iov_base = str0;\n"
"iov[0].iov_len = strlen(str0);\n"
"iov[1].iov_base = str1;\n"
"iov[1].iov_len = strlen(str1);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/readv.2:428
#, no-wrap
msgid "nwritten = writev(STDOUT_FILENO, iov, 2);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/readv.2:433
msgid "B<pread>(2), B<read>(2), B<write>(2)"
msgstr ""

#. type: TH
#: man-pages/man2/mremap.2:30
#, no-wrap
msgid "MREMAP"
msgstr ""

#. type: Plain text
#: man-pages/man2/mremap.2:33
msgid "mremap - remap a virtual memory address"
msgstr ""

#. type: Plain text
#: man-pages/man2/mremap.2:40
#, no-wrap
msgid ""
"B<void *mremap(void *>I<old_address>B<, size_t >I<old_size>B<,>\n"
"B<             size_t >I<new_size>B<, int >I<flags>B<, ... /* void "
"*>I<new_address>B< */);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/mremap.2:46
msgid ""
"B<mremap>()  expands (or shrinks) an existing memory mapping, potentially "
"moving it at the same time (controlled by the I<flags> argument and the "
"available virtual address space)."
msgstr ""

#. type: Plain text
#: man-pages/man2/mremap.2:60
msgid ""
"I<old_address> is the old address of the virtual memory block that you want "
"to expand (or shrink).  Note that I<old_address> has to be page aligned.  "
"I<old_size> is the old size of the virtual memory block.  I<new_size> is the "
"requested size of the virtual memory block after the resize.  An optional "
"fifth argument, I<new_address>, may be provided; see the description of "
"B<MREMAP_FIXED> below."
msgstr ""

#. type: Plain text
#: man-pages/man2/mremap.2:76
msgid ""
"If the value of I<old_size> is zero, and I<old_address> refers to a "
"shareable mapping (see B<mmap>(2)  B<MAP_SHARED>), then B<mremap>()  will "
"create a new mapping of the same pages.  I<new_size> will be the size of the "
"new mapping and the location of the new mapping may be specified with "
"I<new_address>; see the description of B<MREMAP_FIXED> below.  If a new "
"mapping is requested via this method, then the B<MREMAP_MAYMOVE> flag must "
"also be specified."
msgstr ""

#. type: Plain text
#: man-pages/man2/mremap.2:88
msgid ""
"In Linux the memory is divided into pages.  A user process has (one or)  "
"several linear virtual memory segments.  Each virtual memory segment has one "
"or more mappings to real memory pages (in the page table).  Each virtual "
"memory segment has its own protection (access rights), which may cause a "
"segmentation violation if the memory is accessed incorrectly (e.g., writing "
"to a read-only segment).  Accessing virtual memory outside of the segments "
"will also cause a segmentation violation."
msgstr ""

#. type: Plain text
#: man-pages/man2/mremap.2:96
msgid ""
"B<mremap>()  uses the Linux page table scheme.  B<mremap>()  changes the "
"mapping between virtual addresses and memory pages.  This can be used to "
"implement a very efficient B<realloc>(3)."
msgstr ""

#. type: Plain text
#: man-pages/man2/mremap.2:98
msgid "The I<flags> bit-mask argument may be 0, or include the following flag:"
msgstr ""

#. type: TP
#: man-pages/man2/mremap.2:98
#, no-wrap
msgid "B<MREMAP_MAYMOVE>"
msgstr ""

#. type: Plain text
#: man-pages/man2/mremap.2:110
msgid ""
"By default, if there is not sufficient space to expand a mapping at its "
"current location, then B<mremap>()  fails.  If this flag is specified, then "
"the kernel is permitted to relocate the mapping to a new virtual address, if "
"necessary.  If the mapping is relocated, then absolute pointers into the old "
"mapping location become invalid (offsets relative to the starting address of "
"the mapping should be employed)."
msgstr ""

#. type: TP
#: man-pages/man2/mremap.2:110
#, no-wrap
msgid "B<MREMAP_FIXED> (since Linux 2.3.31)"
msgstr ""

#. type: Plain text
#: man-pages/man2/mremap.2:132
msgid ""
"This flag serves a similar purpose to the B<MAP_FIXED> flag of B<mmap>(2).  "
"If this flag is specified, then B<mremap>()  accepts a fifth argument, "
"I<void\\ *new_address>, which specifies a page-aligned address to which the "
"mapping must be moved.  Any previous mapping at the address range specified "
"by I<new_address> and I<new_size> is unmapped.  If B<MREMAP_FIXED> is "
"specified, then B<MREMAP_MAYMOVE> must also be specified."
msgstr ""

#. type: Plain text
#: man-pages/man2/mremap.2:142
msgid ""
"If the memory segment specified by I<old_address> and I<old_size> is locked "
"(using B<mlock>(2)  or similar), then this lock is maintained when the "
"segment is resized and/or relocated.  As a consequence, the amount of memory "
"locked by the process may change."
msgstr ""

#. type: Plain text
#: man-pages/man2/mremap.2:150
msgid ""
"On success B<mremap>()  returns a pointer to the new virtual memory area.  "
"On error, the value B<MAP_FAILED> (that is, I<(void\\ *)\\ -1>) is returned, "
"and I<errno> is set appropriately."
msgstr ""

#. type: Plain text
#: man-pages/man2/mremap.2:157
msgid ""
"The caller tried to expand a memory segment that is locked, but this was not "
"possible without exceeding the B<RLIMIT_MEMLOCK> resource limit."
msgstr ""

#. type: Plain text
#: man-pages/man2/mremap.2:166
msgid ""
"\"Segmentation fault.\" Some address in the range I<old_address> to "
"I<old_address>+I<old_size> is an invalid virtual memory address for this "
"process.  You can also get B<EFAULT> even if there exist mappings that cover "
"the whole address space requested, but those mappings are of different "
"types."
msgstr ""

#. type: Plain text
#: man-pages/man2/mremap.2:170
msgid "An invalid argument was given.  Possible causes are:"
msgstr ""

#. type: Plain text
#: man-pages/man2/mremap.2:174
msgid "I<old_address> was not page aligned;"
msgstr ""

#. type: Plain text
#: man-pages/man2/mremap.2:181
msgid ""
"a value other than B<MREMAP_MAYMOVE> or B<MREMAP_FIXED> was specified in "
"I<flags>;"
msgstr ""

#. type: Plain text
#: man-pages/man2/mremap.2:184
msgid "I<new_size> was zero;"
msgstr ""

#. type: Plain text
#: man-pages/man2/mremap.2:189
msgid "I<new_size> or I<new_address> was invalid;"
msgstr ""

#. type: Plain text
#: man-pages/man2/mremap.2:198
msgid ""
"the new address range specified by I<new_address> and I<new_size> overlapped "
"the old address range specified by I<old_address> and I<old_size>;"
msgstr ""

#. type: Plain text
#: man-pages/man2/mremap.2:202
msgid "B<MREMAP_FIXED> was specified without also specifying B<MREMAP_MAYMOVE>;"
msgstr ""

#. type: Plain text
#: man-pages/man2/mremap.2:205
msgid ""
"I<old_size> was zero and I<old_address> does not refer to a shareable "
"mapping (but see BUGS);"
msgstr ""

#. type: Plain text
#: man-pages/man2/mremap.2:209
msgid "I<old_size> was zero and the B<MREMAP_MAYMOVE> flag was not specified."
msgstr ""

#. type: Plain text
#: man-pages/man2/mremap.2:216
msgid ""
"The memory area cannot be expanded at the current virtual address, and the "
"B<MREMAP_MAYMOVE> flag is not set in I<flags>.  Or, there is not enough "
"(virtual) memory available."
msgstr ""

#. type: Plain text
#: man-pages/man2/mremap.2:222 man-pages/man2/vhangup.2:74
msgid ""
"This call is Linux-specific, and should not be used in programs intended to "
"be portable."
msgstr ""

#. type: Plain text
#: man-pages/man2/mremap.2:230
msgid ""
"Prior to version 2.4, glibc did not expose the definition of "
"B<MREMAP_FIXED>, and the prototype for B<mremap>()  did not allow for the "
"I<new_address> argument."
msgstr ""

#. type: Plain text
#: man-pages/man2/mremap.2:241
msgid ""
"If B<mremap>()  is used to move or expand an area locked with B<mlock>(2)  "
"or equivalent, the B<mremap>()  call will make a best effort to populate the "
"new area but will not fail with B<ENOMEM> if the area cannot be populated."
msgstr ""

#.  commit dba58d3b8c5045ad89c1c95d33d01451e3964db7
#. type: Plain text
#: man-pages/man2/mremap.2:262
msgid ""
"Before Linux 4.14, if I<old_size> was zero and the mapping referred to by "
"I<old_address> was a private mapping (B<mmap>(2) B<MAP_PRIVATE>), "
"B<mremap>()  created a new private mapping unrelated to the original "
"mapping.  This behavior was unintended and probably unexpected in user-space "
"applications (since the intention of B<mremap>()  is to create a new mapping "
"based on the original mapping).  Since Linux 4.14, B<mremap>()  fails with "
"the error B<EINVAL> in this scenario."
msgstr ""

#. type: Plain text
#: man-pages/man2/mremap.2:271
msgid ""
"B<brk>(2), B<getpagesize>(2), B<getrlimit>(2), B<mlock>(2), B<mmap>(2), "
"B<sbrk>(2), B<malloc>(3), B<realloc>(3)"
msgstr ""

#. type: Plain text
#: man-pages/man2/mremap.2:276
msgid ""
"Your favorite text book on operating systems for more information on paged "
"memory (e.g., I<Modern Operating Systems> by Andrew S.\\& Tanenbaum, "
"I<Inside Linux> by Randolf Bentson, I<The Design of the UNIX Operating "
"System> by Maurice J.\\& Bach)"
msgstr ""

#. type: TH
#: man-pages/man2/llseek.2:28
#, no-wrap
msgid "LLSEEK"
msgstr ""

#. type: Plain text
#: man-pages/man2/llseek.2:31
msgid "_llseek - reposition read/write file offset"
msgstr ""

#. type: Plain text
#: man-pages/man2/llseek.2:35
#, no-wrap
msgid ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>unistd.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/llseek.2:39
#, no-wrap
msgid ""
"B<int _llseek(unsigned int >I<fd>B<, unsigned long >I<offset_high>B<,>\n"
"B<            unsigned long >I<offset_low>B<, loff_t *>I<result>B<,>\n"
"B<            unsigned int >I<whence>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/llseek.2:62
msgid ""
"The B<_llseek>()  system call repositions the offset of the open file "
"description associated with the file descriptor I<fd> to "
"I<(offset_highE<lt>E<lt>32) | offset_low> bytes relative to the beginning of "
"the file, the current file offset, or the end of the file, depending on "
"whether I<whence> is B<SEEK_SET>, B<SEEK_CUR>, or B<SEEK_END>, "
"respectively.  It returns the resulting file position in the argument "
"I<result>."
msgstr ""

#. type: Plain text
#: man-pages/man2/llseek.2:65
msgid ""
"This system call exists on various 32-bit platforms to support seeking to "
"large file offsets."
msgstr ""

#. type: Plain text
#: man-pages/man2/llseek.2:72
msgid ""
"Upon successful completion, B<_llseek>()  returns 0.  Otherwise, a value of "
"-1 is returned and I<errno> is set to indicate the error."
msgstr ""

#. type: Plain text
#: man-pages/man2/llseek.2:77 man-pages/man2/flock.2:122
#: man-pages/man2/lseek.2:198 man-pages/man2/bpf.2:1056
msgid "I<fd> is not an open file descriptor."
msgstr ""

#. type: Plain text
#: man-pages/man2/llseek.2:80
msgid "Problem with copying results to user space."
msgstr ""

#. type: Plain text
#: man-pages/man2/llseek.2:84
msgid "I<whence> is invalid."
msgstr ""

#. type: Plain text
#: man-pages/man2/llseek.2:87 man-pages/man2/sysinfo.2:117
#: man-pages/man2/idle.2:63
msgid ""
"This function is Linux-specific, and should not be used in programs intended "
"to be portable."
msgstr ""

#. type: Plain text
#: man-pages/man2/llseek.2:94
msgid ""
"Glibc does not provide a wrapper for this system call.  To invoke it "
"directly, use B<syscall>(2).  However, you probably want to use the "
"B<lseek>(2)  wrapper function instead."
msgstr ""

#. type: Plain text
#: man-pages/man2/llseek.2:97
msgid "B<lseek>(2), B<open>(2), B<lseek64>(3)"
msgstr ""

#. type: TH
#: man-pages/man2/remap_file_pages.2:28
#, no-wrap
msgid "REMAP_FILE_PAGES"
msgstr ""

#. type: Plain text
#: man-pages/man2/remap_file_pages.2:31
msgid "remap_file_pages - create a nonlinear file mapping"
msgstr ""

#. type: Plain text
#: man-pages/man2/remap_file_pages.2:38
#, no-wrap
msgid ""
"B<int remap_file_pages(void *>I<addr>B<, size_t >I<size>B<, int "
">I<prot>B<,>\n"
"B<                     size_t >I<pgoff>B<, int >I<flags>B<);>\n"
msgstr ""

#.  commit 33041a0d76d3c3e0aff28ac95a2ffdedf1282dbc
#.  http://lwn.net/Articles/597632/
#.  commit c8d78c1823f46519473949d33f0d1d33fe21ea16
#. type: Plain text
#: man-pages/man2/remap_file_pages.2:53
msgid ""
"B<Note>: this system call was marked as deprecated starting with Linux "
"3.16.  In Linux 4.0, the implementation was replaced by a slower in-kernel "
"emulation.  Those few applications that use this system call should consider "
"migrating to alternatives.  This change was made because the kernel code for "
"this system call was complex, and it is believed to be little used or "
"perhaps even completely unused.  While it had some use cases in database "
"applications on 32-bit systems, those use cases don't exist on 64-bit "
"systems."
msgstr ""

#. type: Plain text
#: man-pages/man2/remap_file_pages.2:65
msgid ""
"The B<remap_file_pages>()  system call is used to create a nonlinear "
"mapping, that is, a mapping in which the pages of the file are mapped into a "
"nonsequential order in memory.  The advantage of using B<remap_file_pages>()  "
"over using repeated calls to B<mmap>(2)  is that the former approach does "
"not require the kernel to create additional VMA (Virtual Memory Area) data "
"structures."
msgstr ""

#. type: Plain text
#: man-pages/man2/remap_file_pages.2:67
msgid "To create a nonlinear mapping we perform the following steps:"
msgstr ""

#. type: Plain text
#: man-pages/man2/remap_file_pages.2:75
msgid ""
"Use B<mmap>(2)  to create a mapping (which is initially linear).  This "
"mapping must be created with the B<MAP_SHARED> flag."
msgstr ""

#. type: Plain text
#: man-pages/man2/remap_file_pages.2:83
msgid ""
"Use one or more calls to B<remap_file_pages>()  to rearrange the "
"correspondence between the pages of the mapping and the pages of the file.  "
"It is possible to map the same page of a file into multiple locations within "
"the mapped region."
msgstr ""

#. type: Plain text
#: man-pages/man2/remap_file_pages.2:94
msgid ""
"The I<pgoff> and I<size> arguments specify the region of the file that is to "
"be relocated within the mapping: I<pgoff> is a file offset in units of the "
"system page size; I<size> is the length of the region in bytes."
msgstr ""

#. type: Plain text
#: man-pages/man2/remap_file_pages.2:112
msgid ""
"The I<addr> argument serves two purposes.  First, it identifies the mapping "
"whose pages we want to rearrange.  Thus, I<addr> must be an address that "
"falls within a region previously mapped by a call to B<mmap>(2).  Second, "
"I<addr> specifies the address at which the file pages identified by I<pgoff> "
"and I<size> will be placed."
msgstr ""

#.  This rounding is weird, and not consistent with the treatment of
#.  the analogous arguments for munmap()/mprotect() and for mlock().
#.  MTK, 14 Sep 2005
#. type: Plain text
#: man-pages/man2/remap_file_pages.2:126
msgid ""
"The values specified in I<addr> and I<size> should be multiples of the "
"system page size.  If they are not, then the kernel rounds I<both> values "
"I<down> to the nearest multiple of the page size."
msgstr ""

#. type: Plain text
#: man-pages/man2/remap_file_pages.2:130
msgid "The I<prot> argument must be specified as 0."
msgstr ""

#. type: Plain text
#: man-pages/man2/remap_file_pages.2:138
msgid ""
"The I<flags> argument has the same meaning as for B<mmap>(2), but all flags "
"other than B<MAP_NONBLOCK> are ignored."
msgstr ""

#. type: Plain text
#: man-pages/man2/remap_file_pages.2:145
msgid ""
"On success, B<remap_file_pages>()  returns 0.  On error, -1 is returned, and "
"I<errno> is set appropriately."
msgstr ""

#. type: Plain text
#: man-pages/man2/remap_file_pages.2:153
msgid ""
"I<addr> does not refer to a valid mapping created with the B<MAP_SHARED> "
"flag."
msgstr ""

#.  And possibly others from vma->vm_ops->populate()
#. type: Plain text
#: man-pages/man2/remap_file_pages.2:162
msgid "I<addr>, I<size>, I<prot>, or I<pgoff> is invalid."
msgstr ""

#. type: Plain text
#: man-pages/man2/remap_file_pages.2:167
msgid ""
"The B<remap_file_pages>()  system call appeared in Linux 2.5.46; glibc "
"support was added in version 2.3.3."
msgstr ""

#. type: Plain text
#: man-pages/man2/remap_file_pages.2:171
msgid "The B<remap_file_pages>()  system call is Linux-specific."
msgstr ""

#.  commit 3ee6dafc677a68e461a7ddafc94a580ebab80735
#. type: Plain text
#: man-pages/man2/remap_file_pages.2:184
msgid ""
"Since Linux 2.6.23, B<remap_file_pages>()  creates non-linear mappings only "
"on in-memory filesystems such as B<tmpfs>(5), hugetlbfs or ramfs.  On "
"filesystems with a backing store, B<remap_file_pages>()  is not much more "
"efficient than using B<mmap>(2)  to adjust which parts of the file are "
"mapped to which addresses."
msgstr ""

#. type: Plain text
#: man-pages/man2/remap_file_pages.2:190
msgid ""
"B<getpagesize>(2), B<mmap>(2), B<mmap2>(2), B<mprotect>(2), B<mremap>(2), "
"B<msync>(2)"
msgstr ""

#. type: TH
#: man-pages/man2/rt_sigqueueinfo.2:25
#, no-wrap
msgid "RT_SIGQUEUEINFO"
msgstr ""

#. type: Plain text
#: man-pages/man2/rt_sigqueueinfo.2:28
msgid "rt_sigqueueinfo, rt_tgsigqueueinfo - queue a signal and data"
msgstr ""

#. type: Plain text
#: man-pages/man2/rt_sigqueueinfo.2:31
#, no-wrap
msgid ""
"B<int rt_sigqueueinfo(pid_t >I<tgid>B<, int >I<sig>B<, siginfo_t "
"*>I<info>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/rt_sigqueueinfo.2:34
#, no-wrap
msgid ""
"B<int rt_tgsigqueueinfo(pid_t >I<tgid>B<, pid_t >I<tid>B<, int >I<sig>B<,>\n"
"B<                      siginfo_t *>I<info>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/rt_sigqueueinfo.2:50
msgid ""
"The B<rt_sigqueueinfo>()  and B<rt_tgsigqueueinfo>()  system calls are the "
"low-level interfaces used to send a signal plus data to a process or "
"thread.  The receiver of the signal can obtain the accompanying data by "
"establishing a signal handler with the B<sigaction>(2)  B<SA_SIGINFO> flag."
msgstr ""

#. type: Plain text
#: man-pages/man2/rt_sigqueueinfo.2:56
msgid ""
"These system calls are not intended for direct application use; they are "
"provided to allow the implementation of B<sigqueue>(3)  and "
"B<pthread_sigqueue>(3)."
msgstr ""

#. type: Plain text
#: man-pages/man2/rt_sigqueueinfo.2:68
msgid ""
"The B<rt_sigqueueinfo>()  system call sends the signal I<sig> to the thread "
"group with the ID I<tgid>.  (The term \"thread group\" is synonymous with "
"\"process\", and I<tid> corresponds to the traditional UNIX process ID.)  "
"The signal will be delivered to an arbitrary member of the thread group "
"(i.e., one of the threads that is not currently blocking the signal)."
msgstr ""

#. type: Plain text
#: man-pages/man2/rt_sigqueueinfo.2:79
msgid ""
"The I<info> argument specifies the data to accompany the signal.  This "
"argument is a pointer to a structure of type I<siginfo_t>, described in "
"B<sigaction>(2)  (and defined by including I<E<lt>sigaction.hE<gt>>).  The "
"caller should set the following fields in this structure:"
msgstr ""

#. type: TP
#: man-pages/man2/rt_sigqueueinfo.2:79 man-pages/man2/wait.2:325
#, no-wrap
msgid "I<si_code>"
msgstr ""

#. type: Plain text
#: man-pages/man2/rt_sigqueueinfo.2:87
msgid ""
"This should be one of the B<SI_*> codes in the Linux kernel source file "
"I<include/asm-generic/siginfo.h>.  If the signal is being sent to any "
"process other than the caller itself, the following restrictions apply:"
msgstr ""

#. type: Plain text
#: man-pages/man2/rt_sigqueueinfo.2:97
msgid ""
"The code can't be a value greater than or equal to zero.  In particular, it "
"can't be B<SI_USER>, which is used by the kernel to indicate a signal sent "
"by B<kill>(2), and nor can it be B<SI_KERNEL>, which is used to indicate a "
"signal generated by the kernel."
msgstr ""

#.  tkill(2) or
#. type: Plain text
#: man-pages/man2/rt_sigqueueinfo.2:103
msgid ""
"The code can't (since Linux 2.6.39) be B<SI_TKILL>, which is used by the "
"kernel to indicate a signal sent using B<tgkill>(2)."
msgstr ""

#. type: TP
#: man-pages/man2/rt_sigqueueinfo.2:104 man-pages/man2/wait.2:304
#, no-wrap
msgid "I<si_pid>"
msgstr ""

#. type: Plain text
#: man-pages/man2/rt_sigqueueinfo.2:108
msgid "This should be set to a process ID, typically the process ID of the sender."
msgstr ""

#. type: TP
#: man-pages/man2/rt_sigqueueinfo.2:108 man-pages/man2/wait.2:307
#, no-wrap
msgid "I<si_uid>"
msgstr ""

#. type: Plain text
#: man-pages/man2/rt_sigqueueinfo.2:112
msgid "This should be set to a user ID, typically the real user ID of the sender."
msgstr ""

#. type: TP
#: man-pages/man2/rt_sigqueueinfo.2:112
#, no-wrap
msgid "I<si_value>"
msgstr ""

#. type: Plain text
#: man-pages/man2/rt_sigqueueinfo.2:119
msgid ""
"This field contains the user data to accompany the signal.  For more "
"information, see the description of the last (I<union sigval>)  argument of "
"B<sigqueue>(3)."
msgstr ""

#. type: Plain text
#: man-pages/man2/rt_sigqueueinfo.2:126
msgid ""
"Internally, the kernel sets the I<si_signo> field to the value specified in "
"I<sig>, so that the receiver of the signal can also obtain the signal number "
"via that field."
msgstr ""

#. type: Plain text
#: man-pages/man2/rt_sigqueueinfo.2:138
msgid ""
"The B<rt_tgsigqueueinfo>()  system call is like B<rt_sigqueueinfo>(), but "
"sends the signal and data to the single thread specified by the combination "
"of I<tgid>, a thread group ID, and I<tid>, a thread in that thread group."
msgstr ""

#. type: Plain text
#: man-pages/man2/rt_sigqueueinfo.2:143
msgid ""
"On success, these system calls return 0.  On error, they return -1 and "
"I<errno> is set to indicate the error."
msgstr ""

#. type: Plain text
#: man-pages/man2/rt_sigqueueinfo.2:150
msgid ""
"The limit of signals which may be queued has been reached.  (See "
"B<signal>(7)  for further information.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/rt_sigqueueinfo.2:157
msgid "I<sig>, I<tgid>, or I<tid> was invalid."
msgstr ""

#. type: Plain text
#: man-pages/man2/rt_sigqueueinfo.2:162
msgid ""
"The caller does not have permission to send the signal to the target.  For "
"the required permissions, see B<kill>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/rt_sigqueueinfo.2:168
msgid ""
"I<tgid> specifies a process other than the caller and I<info-E<gt>si_code> "
"is invalid."
msgstr ""

#. type: Plain text
#: man-pages/man2/rt_sigqueueinfo.2:174
msgid "B<rt_sigqueueinfo>(): No thread group matching I<tgid> was found."
msgstr ""

#. type: Plain text
#: man-pages/man2/rt_sigqueueinfo.2:181
msgid "B<rt_tgsigqueinfo>(): No thread matching I<tgid> and I<tid> was found."
msgstr ""

#. type: Plain text
#: man-pages/man2/rt_sigqueueinfo.2:188
msgid ""
"The B<rt_sigqueueinfo>()  system call was added to Linux in version 2.2.  "
"The B<rt_tgsigqueueinfo>()  system call was added to Linux in version "
"2.6.31."
msgstr ""

#. type: Plain text
#: man-pages/man2/rt_sigqueueinfo.2:195
msgid ""
"Since these system calls are not intended for application use, there are no "
"glibc wrapper functions; use B<syscall>(2)  in the unlikely case that you "
"want to call them directly."
msgstr ""

#. type: Plain text
#: man-pages/man2/rt_sigqueueinfo.2:200
msgid ""
"As with B<kill>(2), the null signal (0) can be used to check if the "
"specified process or thread exists."
msgstr ""

#. type: Plain text
#: man-pages/man2/rt_sigqueueinfo.2:208
msgid ""
"B<kill>(2), B<pidfd_send_signal>(2), B<sigaction>(2), B<sigprocmask>(2), "
"B<tgkill>(2), B<pthread_sigqueue>(3), B<sigqueue>(3), B<signal>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/mmap2.2:29
#, no-wrap
msgid "MMAP2"
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap2.2:32
msgid "mmap2 - map files or devices into memory"
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap2.2:35 man-pages/man2/mprotect.2:39
#: man-pages/man2/mmap.2:46 man-pages/man2/mlock.2:32
#, no-wrap
msgid "B<#include E<lt>sys/mman.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap2.2:38
#, no-wrap
msgid ""
"B<void *mmap2(void *>I<addr>B<, size_t >I<length>B<, int >I<prot>B<,>\n"
"B<             int >I<flags>B<, int >I<fd>B<, off_t >I<pgoffset>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap2.2:43
msgid ""
"This is probably not the system call that you are interested in; instead, "
"see B<mmap>(2), which describes the glibc wrapper function that invokes this "
"system call."
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap2.2:54
msgid ""
"The B<mmap2>()  system call provides the same interface as B<mmap>(2), "
"except that the final argument specifies the offset into the file in "
"4096-byte units (instead of bytes, as is done by B<mmap>(2)).  This enables "
"applications that use a 32-bit I<off_t> to map large files (up to 2^44 "
"bytes)."
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap2.2:61
msgid ""
"On success, B<mmap2>()  returns a pointer to the mapped area.  On error, -1 "
"is returned and I<errno> is set appropriately."
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap2.2:65
msgid "Problem with getting the data from user space."
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap2.2:70
msgid ""
"(Various platforms where the page size is not 4096 bytes.)  I<offset\\ *\\ "
"4096> is not a multiple of the system page size."
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap2.2:74
msgid "B<mmap2>()  can also return any of the errors described in B<mmap>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap2.2:77
msgid "B<mmap2>()  is available since Linux 2.3.31."
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap2.2:86
msgid ""
"On architectures where this system call is present, the glibc B<mmap>()  "
"wrapper function invokes this system call rather than the B<mmap>(2)  system "
"call."
msgstr ""

#.  ia64 can have page sizes ranging from 4 kB to 64 kB.
#.  On cris, it looks like the unit might also be the page size,
#.  which is 8192 bytes. -- mtk, June 2007
#. type: Plain text
#: man-pages/man2/mmap2.2:95
msgid ""
"On ia64, the unit for I<offset> is actually the system page size, rather "
"than 4096 bytes."
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap2.2:100
msgid "B<getpagesize>(2), B<mmap>(2), B<mremap>(2), B<msync>(2), B<shm_open>(3)"
msgstr ""

#. type: TH
#: man-pages/man2/query_module.2:10
#, no-wrap
msgid "QUERY_MODULE"
msgstr ""

#. type: Plain text
#: man-pages/man2/query_module.2:13
msgid "query_module - query the kernel for various bits pertaining to modules"
msgstr ""

#. type: Plain text
#: man-pages/man2/query_module.2:16 man-pages/man2/get_kernel_syms.2:16
#: man-pages/man2/create_module.2:16
#, no-wrap
msgid "B<#include E<lt>linux/module.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/query_module.2:19
#, no-wrap
msgid ""
"B<int query_module(const char *>I<name>B<, int >I<which>B<, void "
"*>I<buf>B<,>\n"
"B<                 size_t >I<bufsize>B<, size_t *>I<ret>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/query_module.2:26 man-pages/man2/create_module.2:25
msgid "I<Note>: This system call is present only in kernels before Linux 2.6."
msgstr ""

#. type: Plain text
#: man-pages/man2/query_module.2:43
msgid ""
"B<query_module>()  requests information from the kernel about loadable "
"modules.  The returned information is placed in the buffer pointed to by "
"I<buf>.  The caller must specify the size of I<buf> in I<bufsize>.  The "
"precise nature and format of the returned information depend on the "
"operation specified by I<which>.  Some operations require I<name> to "
"identify a currently loaded module, some allow I<name> to be NULL, "
"indicating the kernel proper."
msgstr ""

#. type: Plain text
#: man-pages/man2/query_module.2:46
msgid "The following values can be specified for I<which>:"
msgstr ""

#. type: TP
#: man-pages/man2/query_module.2:46 man-pages/man2/setns.2:40
#, no-wrap
msgid "B<0>"
msgstr ""

#. type: Plain text
#: man-pages/man2/query_module.2:51
msgid ""
"Returns success, if the kernel supports B<query_module>().  Used to probe "
"for availability of the system call."
msgstr ""

#. type: TP
#: man-pages/man2/query_module.2:51
#, no-wrap
msgid "B<QM_MODULES>"
msgstr ""

#.  ret is set on ENOSPC
#. type: Plain text
#: man-pages/man2/query_module.2:59
msgid ""
"Returns the names of all loaded modules.  The returned buffer consists of a "
"sequence of null-terminated strings; I<ret> is set to the number of modules."
msgstr ""

#. type: TP
#: man-pages/man2/query_module.2:59
#, no-wrap
msgid "B<QM_DEPS>"
msgstr ""

#.  ret is set on ENOSPC
#. type: Plain text
#: man-pages/man2/query_module.2:66
msgid ""
"Returns the names of all modules used by the indicated module.  The returned "
"buffer consists of a sequence of null-terminated strings; I<ret> is set to "
"the number of modules."
msgstr ""

#. type: TP
#: man-pages/man2/query_module.2:66
#, no-wrap
msgid "B<QM_REFS>"
msgstr ""

#.  ret is set on ENOSPC
#. type: Plain text
#: man-pages/man2/query_module.2:75
msgid ""
"Returns the names of all modules using the indicated module.  This is the "
"inverse of B<QM_DEPS>.  The returned buffer consists of a sequence of "
"null-terminated strings; I<ret> is set to the number of modules."
msgstr ""

#. type: TP
#: man-pages/man2/query_module.2:75
#, no-wrap
msgid "B<QM_SYMBOLS>"
msgstr ""

#.  ret is set on ENOSPC
#. type: Plain text
#: man-pages/man2/query_module.2:81
msgid ""
"Returns the symbols and values exported by the kernel or the indicated "
"module.  The returned buffer is an array of structures of the following form"
msgstr ""

#. type: Plain text
#: man-pages/man2/query_module.2:88
#, no-wrap
msgid ""
"struct module_symbol {\n"
"    unsigned long value;\n"
"    unsigned long name;\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/query_module.2:98
msgid ""
"followed by null-terminated strings.  The value of I<name> is the character "
"offset of the string relative to the start of I<buf>; I<ret> is set to the "
"number of symbols."
msgstr ""

#. type: TP
#: man-pages/man2/query_module.2:98
#, no-wrap
msgid "B<QM_INFO>"
msgstr ""

#. type: Plain text
#: man-pages/man2/query_module.2:102
msgid ""
"Returns miscellaneous information about the indicated module.  The output "
"buffer format is:"
msgstr ""

#. type: Plain text
#: man-pages/man2/query_module.2:110
#, no-wrap
msgid ""
"struct module_info {\n"
"    unsigned long address;\n"
"    unsigned long size;\n"
"    unsigned long flags;\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/query_module.2:129
msgid ""
"where I<address> is the kernel address at which the module resides, I<size> "
"is the size of the module in bytes, and I<flags> is a mask of "
"B<MOD_RUNNING>, B<MOD_AUTOCLEAN>, and so on, that indicates the current "
"status of the module (see the Linux kernel source file "
"I<include/linux/module.h>).  I<ret> is set to the size of the I<module_info> "
"structure."
msgstr ""

#. type: Plain text
#: man-pages/man2/query_module.2:143
msgid ""
"At least one of I<name>, I<buf>, or I<ret> was outside the program's "
"accessible address space."
msgstr ""

#.  Not permitted with QM_DEPS, QM_REFS, or QM_INFO.
#. type: Plain text
#: man-pages/man2/query_module.2:153
msgid ""
"Invalid I<which>; or I<name> is NULL (indicating \"the kernel\"), but this "
"is not permitted with the specified value of I<which>."
msgstr ""

#. type: Plain text
#: man-pages/man2/query_module.2:158
msgid "No module by that I<name> exists."
msgstr ""

#. type: Plain text
#: man-pages/man2/query_module.2:163
msgid ""
"The buffer size provided was too small.  I<ret> is set to the minimum size "
"needed."
msgstr ""

#. type: Plain text
#: man-pages/man2/query_module.2:168
msgid ""
"B<query_module>()  is not supported in this version of the kernel (e.g., the "
"kernel is version 2.6 or later)."
msgstr ""

#.  Removed in Linux 2.5.48
#. type: Plain text
#: man-pages/man2/query_module.2:172 man-pages/man2/get_kernel_syms.2:67
#: man-pages/man2/create_module.2:65
msgid ""
"This system call is present on Linux only up until kernel 2.4; it was "
"removed in Linux 2.6."
msgstr ""

#. type: Plain text
#: man-pages/man2/query_module.2:175
msgid "B<query_module>()  is Linux-specific."
msgstr ""

#. type: Plain text
#: man-pages/man2/query_module.2:183
msgid ""
"Some of the information that was formerly available via B<query_module>()  "
"can be obtained from I</proc/modules>, I</proc/kallsyms>, and the files "
"under the directory I</sys/module>."
msgstr ""

#. type: Plain text
#: man-pages/man2/query_module.2:193
msgid ""
"The B<query_module>()  system call is not supported by glibc.  No "
"declaration is provided in glibc headers, but, through a quirk of history, "
"glibc does export an ABI for this system call.  Therefore, in order to "
"employ this system call, it is sufficient to manually declare the interface "
"in your code; alternatively, you can invoke the system call using "
"B<syscall>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/query_module.2:199
msgid ""
"B<create_module>(2), B<delete_module>(2), B<get_kernel_syms>(2), "
"B<init_module>(2), B<lsmod>(8), B<modinfo>(8)"
msgstr ""

#. type: TH
#: man-pages/man2/unlink.2:33
#, no-wrap
msgid "UNLINK"
msgstr ""

#. type: Plain text
#: man-pages/man2/unlink.2:36
msgid "unlink, unlinkat - delete a name and possibly the file it refers to"
msgstr ""

#. type: Plain text
#: man-pages/man2/unlink.2:41
#, no-wrap
msgid "B<int unlink(const char *>I<pathname>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/unlink.2:46
#, no-wrap
msgid ""
"B<int unlinkat(int >I<dirfd>B<, const char *>I<pathname>B<, int "
">I<flags>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/unlink.2:54
msgid "B<unlinkat>():"
msgstr ""

#. type: Plain text
#: man-pages/man2/unlink.2:72
msgid ""
"B<unlink>()  deletes a name from the filesystem.  If that name was the last "
"link to a file and no processes have the file open, the file is deleted and "
"the space it was using is made available for reuse."
msgstr ""

#. type: Plain text
#: man-pages/man2/unlink.2:76
msgid ""
"If the name was the last link to a file but any processes still have the "
"file open, the file will remain in existence until the last file descriptor "
"referring to it is closed."
msgstr ""

#. type: Plain text
#: man-pages/man2/unlink.2:78
msgid "If the name referred to a symbolic link, the link is removed."
msgstr ""

#. type: Plain text
#: man-pages/man2/unlink.2:82
msgid ""
"If the name referred to a socket, FIFO, or device, the name for it is "
"removed but processes which have the object open may continue to use it."
msgstr ""

#. type: SS
#: man-pages/man2/unlink.2:82
#, no-wrap
msgid "unlinkat()"
msgstr ""

#. type: Plain text
#: man-pages/man2/unlink.2:95
msgid ""
"The B<unlinkat>()  system call operates in exactly the same way as either "
"B<unlink>()  or B<rmdir>(2)  (depending on whether or not I<flags> includes "
"the B<AT_REMOVEDIR> flag)  except for the differences described here."
msgstr ""

#. type: Plain text
#: man-pages/man2/unlink.2:107
msgid ""
"If the pathname given in I<pathname> is relative, then it is interpreted "
"relative to the directory referred to by the file descriptor I<dirfd> "
"(rather than relative to the current working directory of the calling "
"process, as is done by B<unlink>()  and B<rmdir>(2)  for a relative "
"pathname)."
msgstr ""

#. type: Plain text
#: man-pages/man2/unlink.2:121
msgid ""
"If the pathname given in I<pathname> is relative and I<dirfd> is the special "
"value B<AT_FDCWD>, then I<pathname> is interpreted relative to the current "
"working directory of the calling process (like B<unlink>()  and "
"B<rmdir>(2))."
msgstr ""

#. type: Plain text
#: man-pages/man2/unlink.2:127
msgid "If the pathname given in I<pathname> is absolute, then I<dirfd> is ignored."
msgstr ""

#. type: Plain text
#: man-pages/man2/unlink.2:133
msgid ""
"I<flags> is a bit mask that can either be specified as 0, or by ORing "
"together flag values that control the operation of B<unlinkat>().  "
"Currently, only one such flag is defined:"
msgstr ""

#. type: TP
#: man-pages/man2/unlink.2:133
#, no-wrap
msgid "B<AT_REMOVEDIR>"
msgstr ""

#. type: Plain text
#: man-pages/man2/unlink.2:148
msgid ""
"By default, B<unlinkat>()  performs the equivalent of B<unlink>()  on "
"I<pathname>.  If the B<AT_REMOVEDIR> flag is specified, then performs the "
"equivalent of B<rmdir>(2)  on I<pathname>."
msgstr ""

#. type: Plain text
#: man-pages/man2/unlink.2:153
msgid "See B<openat>(2)  for an explanation of the need for B<unlinkat>()."
msgstr ""

#. type: Plain text
#: man-pages/man2/unlink.2:169
msgid ""
"Write access to the directory containing I<pathname> is not allowed for the "
"process's effective UID, or one of the directories in I<pathname> did not "
"allow search permission.  (See also B<path_resolution>(7).)"
msgstr ""

#. type: Plain text
#: man-pages/man2/unlink.2:178
msgid ""
"The file I<pathname> cannot be unlinked because it is being used by the "
"system or another process; for example, it is a mount point or the NFS "
"client software created it to represent an active but otherwise nameless "
"inode (\"NFS silly renamed\")."
msgstr ""

#. type: Plain text
#: man-pages/man2/unlink.2:190
msgid ""
"I<pathname> refers to a directory.  (This is the non-POSIX value returned by "
"Linux since 2.1.132.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/unlink.2:194
msgid "Too many symbolic links were encountered in translating I<pathname>."
msgstr ""

#. type: Plain text
#: man-pages/man2/unlink.2:204
msgid ""
"A component in I<pathname> does not exist or is a dangling symbolic link, or "
"I<pathname> is empty."
msgstr ""

#. type: Plain text
#: man-pages/man2/unlink.2:221
msgid ""
"The system does not allow unlinking of directories, or unlinking of "
"directories requires privileges that the calling process doesn't have.  "
"(This is the POSIX prescribed error return; as noted above, Linux returns "
"B<EISDIR> for this case.)"
msgstr ""

#. type: TP
#: man-pages/man2/unlink.2:221
#, no-wrap
msgid "B<EPERM> (Linux only)"
msgstr ""

#. type: Plain text
#: man-pages/man2/unlink.2:224
msgid "The filesystem does not allow unlinking of files."
msgstr ""

#. type: Plain text
#: man-pages/man2/unlink.2:235
msgid ""
"The directory containing I<pathname> has the sticky bit (B<S_ISVTX>)  set "
"and the process's effective UID is neither the UID of the file to be deleted "
"nor that of the directory containing it, and the process is not privileged "
"(Linux: does not have the B<CAP_FOWNER> capability)."
msgstr ""

#. type: Plain text
#: man-pages/man2/unlink.2:240
msgid ""
"The file to be unlinked is marked immutable or append-only.  (See "
"B<ioctl_iflags>(2).)"
msgstr ""

#. type: Plain text
#: man-pages/man2/unlink.2:253
msgid ""
"The same errors that occur for B<unlink>()  and B<rmdir>(2)  can also occur "
"for B<unlinkat>().  The following additional errors can occur for "
"B<unlinkat>():"
msgstr ""

#. type: Plain text
#: man-pages/man2/unlink.2:261 man-pages/man2/link.2:299
msgid "An invalid flag value was specified in I<flags>."
msgstr ""

#. type: Plain text
#: man-pages/man2/unlink.2:268
msgid ""
"I<pathname> refers to a directory, and B<AT_REMOVEDIR> was not specified in "
"I<flags>."
msgstr ""

#. type: Plain text
#: man-pages/man2/unlink.2:278
msgid ""
"B<unlinkat>()  was added to Linux in kernel 2.6.16; library support was "
"added to glibc in version 2.4."
msgstr ""

#.  SVr4 documents additional error
#.  conditions EINTR, EMULTIHOP, ETXTBSY, ENOLINK.
#. type: Plain text
#: man-pages/man2/unlink.2:283
msgid "B<unlink>(): SVr4, 4.3BSD, POSIX.1-2001, POSIX.1-2008."
msgstr ""

#. type: Plain text
#: man-pages/man2/unlink.2:286
msgid "B<unlinkat>(): POSIX.1-2008."
msgstr ""

#. type: Plain text
#: man-pages/man2/unlink.2:302
msgid ""
"On older kernels where B<unlinkat>()  is unavailable, the glibc wrapper "
"function falls back to the use of B<unlink>()  or B<rmdir>(2).  When "
"I<pathname> is a relative pathname, glibc constructs a pathname based on the "
"symbolic link in I</proc/self/fd> that corresponds to the I<dirfd> argument."
msgstr ""

#. type: Plain text
#: man-pages/man2/unlink.2:305
msgid ""
"Infelicities in the protocol underlying NFS can cause the unexpected "
"disappearance of files which are still being used."
msgstr ""

#. type: Plain text
#: man-pages/man2/unlink.2:317
msgid ""
"B<rm>(1), B<unlink>(1), B<chmod>(2), B<link>(2), B<mknod>(2), B<open>(2), "
"B<rename>(2), B<rmdir>(2), B<mkfifo>(3), B<remove>(3), "
"B<path_resolution>(7), B<symlink>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/syscalls.2:31
#, no-wrap
msgid "SYSCALLS"
msgstr ""

#. type: Plain text
#: man-pages/man2/syscalls.2:34
msgid "syscalls - Linux system calls"
msgstr ""

#. type: Plain text
#: man-pages/man2/syscalls.2:36
msgid "Linux system calls."
msgstr ""

#. type: Plain text
#: man-pages/man2/syscalls.2:39
msgid ""
"The system call is the fundamental interface between an application and the "
"Linux kernel."
msgstr ""

#. type: SS
#: man-pages/man2/syscalls.2:39
#, no-wrap
msgid "System calls and library wrapper functions"
msgstr ""

#. type: Plain text
#: man-pages/man2/syscalls.2:49
msgid ""
"System calls are generally not invoked directly, but rather via wrapper "
"functions in glibc (or perhaps some other library).  For details of direct "
"invocation of a system call, see B<intro>(2).  Often, but not always, the "
"name of the wrapper function is the same as the name of the system call that "
"it invokes.  For example, glibc contains a function B<chdir>()  which "
"invokes the underlying \"chdir\" system call."
msgstr ""

#. type: Plain text
#: man-pages/man2/syscalls.2:69
msgid ""
"Often the glibc wrapper function is quite thin, doing little work other than "
"copying arguments to the right registers before invoking the system call, "
"and then setting I<errno> appropriately after the system call has returned.  "
"(These are the same steps that are performed by B<syscall>(2), which can be "
"used to invoke system calls for which no wrapper function is provided.)  "
"Note: system calls indicate a failure by returning a negative error number "
"to the caller on architectures without a separate error register/flag, as "
"noted in B<syscall>(2); when this happens, the wrapper function negates the "
"returned error number (to make it positive), copies it to I<errno>, and "
"returns -1 to the caller of the wrapper."
msgstr ""

#. type: Plain text
#: man-pages/man2/syscalls.2:81
msgid ""
"Sometimes, however, the wrapper function does some extra work before "
"invoking the system call.  For example, nowadays there are (for reasons "
"described below) two related system calls, B<truncate>(2)  and "
"B<truncate64>(2), and the glibc B<truncate>()  wrapper function checks which "
"of those system calls are provided by the kernel and determines which should "
"be employed."
msgstr ""

#. type: SS
#: man-pages/man2/syscalls.2:81
#, no-wrap
msgid "System call list"
msgstr ""

#. type: Plain text
#: man-pages/man2/syscalls.2:89
msgid ""
"Below is a list of the Linux system calls.  In the list, the I<Kernel> "
"column indicates the kernel version for those system calls that were new in "
"Linux 2.2, or have appeared since that kernel version.  Note the following "
"points:"
msgstr ""

#. type: Plain text
#: man-pages/man2/syscalls.2:92
msgid ""
"Where no kernel version is indicated, the system call appeared in kernel 1.0 "
"or earlier."
msgstr ""

#. type: Plain text
#: man-pages/man2/syscalls.2:98
msgid ""
"Where a system call is marked \"1.2\" this means the system call probably "
"appeared in a 1.1.x kernel version, and first appeared in a stable kernel "
"with 1.2.  (Development of the 1.2 kernel was initiated from a branch of "
"kernel 1.0.6 via the 1.1.x unstable kernel series.)"
msgstr ""

#.  Was kernel 2.0 started from a branch of 1.2.10?
#.  At least from the timestamps of the tarballs of
#.  of 1.2.10 and 1.3.0, that's how it looks, but in
#.  fact the diff doesn't seem very clear, the
#.  1.3.0 .tar.bz is much bigger (2.0 MB) than the
#.  1.2.10 .tar.bz2 (1.8 MB), and AEB points out the
#.  timestamps of some files in 1.3.0 seem to be older
#.  than those in 1.2.10.  All of this suggests
#.  that there might not have been a clean branch point.
#. type: Plain text
#: man-pages/man2/syscalls.2:114
msgid ""
"Where a system call is marked \"2.0\" this means the system call probably "
"appeared in a 1.3.x kernel version, and first appeared in a stable kernel "
"with 2.0.  (Development of the 2.0 kernel was initiated from a branch of "
"kernel 1.2.x, somewhere around 1.2.10, via the 1.3.x unstable kernel "
"series.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/syscalls.2:120
msgid ""
"Where a system call is marked \"2.2\" this means the system call probably "
"appeared in a 2.1.x kernel version, and first appeared in a stable kernel "
"with 2.2.0.  (Development of the 2.2 kernel was initiated from a branch of "
"kernel 2.0.21 via the 2.1.x unstable kernel series.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/syscalls.2:126
msgid ""
"Where a system call is marked \"2.4\" this means the system call probably "
"appeared in a 2.3.x kernel version, and first appeared in a stable kernel "
"with 2.4.0.  (Development of the 2.4 kernel was initiated from a branch of "
"kernel 2.2.8 via the 2.3.x unstable kernel series.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/syscalls.2:132
msgid ""
"Where a system call is marked \"2.6\" this means the system call probably "
"appeared in a 2.5.x kernel version, and first appeared in a stable kernel "
"with 2.6.0.  (Development of kernel 2.6 was initiated from a branch of "
"kernel 2.4.15 via the 2.5.x unstable kernel series.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/syscalls.2:140
msgid ""
"Starting with kernel 2.6.0, the development model changed, and new system "
"calls may appear in each 2.6.x release.  In this case, the exact version "
"number where the system call appeared is shown.  This convention continues "
"with the 3.x kernel series, which followed on from kernel 2.6.39, and the "
"4.x kernel series, which followed on from kernel 3.19."
msgstr ""

#. type: Plain text
#: man-pages/man2/syscalls.2:148
msgid ""
"In some cases, a system call was added to a stable kernel series after it "
"branched from the previous stable kernel series, and then backported into "
"the earlier stable kernel series.  For example some system calls that "
"appeared in 2.6.x were also backported into a 2.4.x release after 2.4.15.  "
"When this is so, the version where the system call appeared in both of the "
"major kernel series is listed."
msgstr ""

#
#.  Looking at scripts/checksyscalls.sh in the kernel source is
#.  instructive about x86 specifics.
#. type: Plain text
#: man-pages/man2/syscalls.2:155
msgid ""
"The list of system calls that are available as at kernel 4.19 (or in a few "
"cases only on older kernels) is as follows:"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:160
#, no-wrap
msgid "B<System call>"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:160
#, no-wrap
msgid "B<Kernel>"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:160
#, no-wrap
msgid "B<Notes>"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:162
#, no-wrap
msgid "B<_llseek>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:162 man-pages/man2/syscalls.2:183
#: man-pages/man2/syscalls.2:201 man-pages/man2/syscalls.2:534
#: man-pages/man2/syscalls.2:676 man-pages/man2/syscalls.2:678
#: man-pages/man2/syscalls.2:775
#, no-wrap
msgid "1.2"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:163
#, no-wrap
msgid "B<_newselect>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:163 man-pages/man2/syscalls.2:164
#: man-pages/man2/syscalls.2:165 man-pages/man2/syscalls.2:193
#: man-pages/man2/syscalls.2:241 man-pages/man2/syscalls.2:263
#: man-pages/man2/syscalls.2:289 man-pages/man2/syscalls.2:293
#: man-pages/man2/syscalls.2:324 man-pages/man2/syscalls.2:335
#: man-pages/man2/syscalls.2:350 man-pages/man2/syscalls.2:356
#: man-pages/man2/syscalls.2:357 man-pages/man2/syscalls.2:370
#: man-pages/man2/syscalls.2:371 man-pages/man2/syscalls.2:372
#: man-pages/man2/syscalls.2:379 man-pages/man2/syscalls.2:380
#: man-pages/man2/syscalls.2:381 man-pages/man2/syscalls.2:422
#: man-pages/man2/syscalls.2:464 man-pages/man2/syscalls.2:466
#: man-pages/man2/syscalls.2:481 man-pages/man2/syscalls.2:482
#: man-pages/man2/syscalls.2:483 man-pages/man2/syscalls.2:484
#: man-pages/man2/syscalls.2:485 man-pages/man2/syscalls.2:486
#: man-pages/man2/syscalls.2:489 man-pages/man2/syscalls.2:490
#: man-pages/man2/syscalls.2:493 man-pages/man2/syscalls.2:498
#: man-pages/man2/syscalls.2:592 man-pages/man2/syscalls.2:594
#: man-pages/man2/syscalls.2:595 man-pages/man2/syscalls.2:596
#: man-pages/man2/syscalls.2:628 man-pages/man2/syscalls.2:629
#: man-pages/man2/syscalls.2:632 man-pages/man2/syscalls.2:633
#: man-pages/man2/syscalls.2:634 man-pages/man2/syscalls.2:642
#: man-pages/man2/syscalls.2:643 man-pages/man2/syscalls.2:644
#: man-pages/man2/syscalls.2:647 man-pages/man2/syscalls.2:648
#: man-pages/man2/syscalls.2:649 man-pages/man2/syscalls.2:651
#: man-pages/man2/syscalls.2:655 man-pages/man2/syscalls.2:656
#: man-pages/man2/syscalls.2:685 man-pages/man2/syscalls.2:690
#: man-pages/man2/syscalls.2:706 man-pages/man2/syscalls.2:713
#: man-pages/man2/syscalls.2:714 man-pages/man2/syscalls.2:715
#: man-pages/man2/syscalls.2:716 man-pages/man2/syscalls.2:717
#: man-pages/man2/syscalls.2:727 man-pages/man2/syscalls.2:730
#: man-pages/man2/syscalls.2:834
#, no-wrap
msgid "2.0"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:164
#, no-wrap
msgid "B<_sysctl>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:165 man-pages/man2/socketcall.2:73
#, no-wrap
msgid "B<accept>(2)"
msgstr ""

#.  Implements BSD socket calls
#. type: tbl table
#: man-pages/man2/syscalls.2:165 man-pages/man2/syscalls.2:193
#: man-pages/man2/syscalls.2:241 man-pages/man2/syscalls.2:356
#: man-pages/man2/syscalls.2:371 man-pages/man2/syscalls.2:372
#: man-pages/man2/syscalls.2:422 man-pages/man2/syscalls.2:594
#: man-pages/man2/syscalls.2:595 man-pages/man2/syscalls.2:596
#: man-pages/man2/syscalls.2:651 man-pages/man2/syscalls.2:655
#: man-pages/man2/syscalls.2:656 man-pages/man2/syscalls.2:706
#: man-pages/man2/syscalls.2:717 man-pages/man2/syscalls.2:727
#: man-pages/man2/syscalls.2:730
#, no-wrap
msgid "See notes on B<socketcall>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:166 man-pages/man2/socketcall.2:138
#, no-wrap
msgid "B<accept4>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:166
#, no-wrap
msgid "2.6.28"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:167
#, no-wrap
msgid "B<access>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:167 man-pages/man2/syscalls.2:168
#: man-pages/man2/syscalls.2:170 man-pages/man2/syscalls.2:171
#: man-pages/man2/syscalls.2:195 man-pages/man2/syscalls.2:204
#: man-pages/man2/syscalls.2:205 man-pages/man2/syscalls.2:212
#: man-pages/man2/syscalls.2:219 man-pages/man2/syscalls.2:221
#: man-pages/man2/syscalls.2:243 man-pages/man2/syscalls.2:244
#: man-pages/man2/syscalls.2:245 man-pages/man2/syscalls.2:253
#: man-pages/man2/syscalls.2:254 man-pages/man2/syscalls.2:268
#: man-pages/man2/syscalls.2:270 man-pages/man2/syscalls.2:281
#: man-pages/man2/syscalls.2:282 man-pages/man2/syscalls.2:284
#: man-pages/man2/syscalls.2:287 man-pages/man2/syscalls.2:294
#: man-pages/man2/syscalls.2:302 man-pages/man2/syscalls.2:305
#: man-pages/man2/syscalls.2:307 man-pages/man2/syscalls.2:308
#: man-pages/man2/syscalls.2:312 man-pages/man2/syscalls.2:341
#: man-pages/man2/syscalls.2:343 man-pages/man2/syscalls.2:345
#: man-pages/man2/syscalls.2:347 man-pages/man2/syscalls.2:355
#: man-pages/man2/syscalls.2:358 man-pages/man2/syscalls.2:359
#: man-pages/man2/syscalls.2:360 man-pages/man2/syscalls.2:361
#: man-pages/man2/syscalls.2:362 man-pages/man2/syscalls.2:368
#: man-pages/man2/syscalls.2:369 man-pages/man2/syscalls.2:374
#: man-pages/man2/syscalls.2:375 man-pages/man2/syscalls.2:382
#: man-pages/man2/syscalls.2:396 man-pages/man2/syscalls.2:397
#: man-pages/man2/syscalls.2:398 man-pages/man2/syscalls.2:401
#: man-pages/man2/syscalls.2:412 man-pages/man2/syscalls.2:413
#: man-pages/man2/syscalls.2:420 man-pages/man2/syscalls.2:427
#: man-pages/man2/syscalls.2:429 man-pages/man2/syscalls.2:460
#: man-pages/man2/syscalls.2:462 man-pages/man2/syscalls.2:467
#: man-pages/man2/syscalls.2:469 man-pages/man2/syscalls.2:470
#: man-pages/man2/syscalls.2:473 man-pages/man2/syscalls.2:491
#: man-pages/man2/syscalls.2:497 man-pages/man2/syscalls.2:506
#: man-pages/man2/syscalls.2:507 man-pages/man2/syscalls.2:508
#: man-pages/man2/syscalls.2:509 man-pages/man2/syscalls.2:515
#: man-pages/man2/syscalls.2:516 man-pages/man2/syscalls.2:522
#: man-pages/man2/syscalls.2:540 man-pages/man2/syscalls.2:570
#: man-pages/man2/syscalls.2:585 man-pages/man2/syscalls.2:586
#: man-pages/man2/syscalls.2:588 man-pages/man2/syscalls.2:590
#: man-pages/man2/syscalls.2:593 man-pages/man2/syscalls.2:600
#: man-pages/man2/syscalls.2:607 man-pages/man2/syscalls.2:646
#: man-pages/man2/syscalls.2:675 man-pages/man2/syscalls.2:680
#: man-pages/man2/syscalls.2:682 man-pages/man2/syscalls.2:686
#: man-pages/man2/syscalls.2:687 man-pages/man2/syscalls.2:689
#: man-pages/man2/syscalls.2:695 man-pages/man2/syscalls.2:696
#: man-pages/man2/syscalls.2:702 man-pages/man2/syscalls.2:704
#: man-pages/man2/syscalls.2:705 man-pages/man2/syscalls.2:707
#: man-pages/man2/syscalls.2:708 man-pages/man2/syscalls.2:710
#: man-pages/man2/syscalls.2:712 man-pages/man2/syscalls.2:718
#: man-pages/man2/syscalls.2:720 man-pages/man2/syscalls.2:723
#: man-pages/man2/syscalls.2:724 man-pages/man2/syscalls.2:725
#: man-pages/man2/syscalls.2:726 man-pages/man2/syscalls.2:728
#: man-pages/man2/syscalls.2:746 man-pages/man2/syscalls.2:747
#: man-pages/man2/syscalls.2:749 man-pages/man2/syscalls.2:752
#: man-pages/man2/syscalls.2:758 man-pages/man2/syscalls.2:759
#: man-pages/man2/syscalls.2:760 man-pages/man2/syscalls.2:762
#: man-pages/man2/syscalls.2:770 man-pages/man2/syscalls.2:776
#: man-pages/man2/syscalls.2:777 man-pages/man2/syscalls.2:782
#: man-pages/man2/syscalls.2:797 man-pages/man2/syscalls.2:799
#: man-pages/man2/syscalls.2:802 man-pages/man2/syscalls.2:803
#: man-pages/man2/syscalls.2:807 man-pages/man2/syscalls.2:808
#: man-pages/man2/syscalls.2:811 man-pages/man2/syscalls.2:812
#: man-pages/man2/syscalls.2:816 man-pages/man2/syscalls.2:823
#: man-pages/man2/syscalls.2:824 man-pages/man2/syscalls.2:830
#: man-pages/man2/syscalls.2:832 man-pages/man2/syscalls.2:833
#, no-wrap
msgid "1.0"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:168
#, no-wrap
msgid "B<acct>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:169
#, no-wrap
msgid "B<add_key>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:169 man-pages/man2/syscalls.2:411
#: man-pages/man2/syscalls.2:603 man-pages/man2/syscalls.2:831
#, no-wrap
msgid "2.6.10"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:170
#, no-wrap
msgid "B<adjtimex>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:171
#, no-wrap
msgid "B<alarm>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:172
#, no-wrap
msgid "B<alloc_hugepages>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:172 man-pages/man2/syscalls.2:295
#, no-wrap
msgid "2.5.36"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:172 man-pages/man2/syscalls.2:295
#, no-wrap
msgid "Removed in 2.5.44"
msgstr ""

#.  4adeefe161a74369e44cc8e663f240ece0470dc3
#. type: tbl table
#: man-pages/man2/syscalls.2:174
#, no-wrap
msgid "B<arc_gettls>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:174 man-pages/man2/syscalls.2:175
#: man-pages/man2/syscalls.2:436 man-pages/man2/syscalls.2:441
#: man-pages/man2/syscalls.2:446 man-pages/man2/syscalls.2:451
#, no-wrap
msgid "3.9"
msgstr ""

#.  91e040a79df73d371f70792f30380d4e44805250
#. type: tbl table
#: man-pages/man2/syscalls.2:174 man-pages/man2/syscalls.2:175
#: man-pages/man2/syscalls.2:177
#, no-wrap
msgid "ARC only"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:175
#, no-wrap
msgid "B<arc_settls>(2)"
msgstr ""

#.  91e040a79df73d371f70792f30380d4e44805250
#. type: tbl table
#: man-pages/man2/syscalls.2:177
#, no-wrap
msgid "B<arc_usr_cmpxchg>(2)"
msgstr ""

#.  91e040a79df73d371f70792f30380d4e44805250
#. type: tbl table
#: man-pages/man2/syscalls.2:177
#, no-wrap
msgid "4.9"
msgstr ""

#.  x86: 79170fda313ed5be2394f87aa2a00d597f8ed4a1
#. type: tbl table
#: man-pages/man2/syscalls.2:179
#, no-wrap
msgid "B<arch_prctl>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:179 man-pages/man2/syscalls.2:214
#: man-pages/man2/syscalls.2:215 man-pages/man2/syscalls.2:216
#: man-pages/man2/syscalls.2:217 man-pages/man2/syscalls.2:256
#: man-pages/man2/syscalls.2:258 man-pages/man2/syscalls.2:260
#: man-pages/man2/syscalls.2:271 man-pages/man2/syscalls.2:273
#: man-pages/man2/syscalls.2:275 man-pages/man2/syscalls.2:306
#: man-pages/man2/syscalls.2:310 man-pages/man2/syscalls.2:315
#: man-pages/man2/syscalls.2:387 man-pages/man2/syscalls.2:388
#: man-pages/man2/syscalls.2:389 man-pages/man2/syscalls.2:391
#: man-pages/man2/syscalls.2:392 man-pages/man2/syscalls.2:425
#: man-pages/man2/syscalls.2:598 man-pages/man2/syscalls.2:604
#: man-pages/man2/syscalls.2:623 man-pages/man2/syscalls.2:630
#: man-pages/man2/syscalls.2:635 man-pages/man2/syscalls.2:640
#: man-pages/man2/syscalls.2:659 man-pages/man2/syscalls.2:660
#: man-pages/man2/syscalls.2:750 man-pages/man2/syscalls.2:781
#: man-pages/man2/syscalls.2:783 man-pages/man2/syscalls.2:784
#: man-pages/man2/syscalls.2:785 man-pages/man2/syscalls.2:786
#: man-pages/man2/syscalls.2:787
#, no-wrap
msgid "2.6"
msgstr ""

#.  x86: 79170fda313ed5be2394f87aa2a00d597f8ed4a1
#. type: tbl table
#: man-pages/man2/syscalls.2:179
#, no-wrap
msgid "x86_64, x86 since 4.12"
msgstr ""

#.  9674cdc74d63f346870943ef966a034f8c71ee57
#. type: tbl table
#: man-pages/man2/syscalls.2:181
#, no-wrap
msgid "B<atomic_barrier>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:181 man-pages/man2/syscalls.2:182
#, no-wrap
msgid "2.6.34"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:181 man-pages/man2/syscalls.2:182
#, no-wrap
msgid "m68k only"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:182
#, no-wrap
msgid "B<atomic_cmpxchg_32>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:183
#, no-wrap
msgid "B<bdflush>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:185
#, no-wrap
msgid "Deprecated (does nothing)\n"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:187
#, no-wrap
msgid "since 2.6"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:188
#, no-wrap
msgid "B<bfin_spinlock>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:188 man-pages/man2/syscalls.2:248
#: man-pages/man2/syscalls.2:261 man-pages/man2/syscalls.2:721
#: man-pages/man2/syscalls.2:736 man-pages/man2/syscalls.2:741
#: man-pages/man2/syscalls.2:764 man-pages/man2/syscalls.2:817
#, no-wrap
msgid "2.6.22"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:190 man-pages/man2/syscalls.2:250
#, no-wrap
msgid "Blackfin only (port removed\n"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:192 man-pages/man2/syscalls.2:240
#: man-pages/man2/syscalls.2:252 man-pages/man2/syscalls.2:440
#: man-pages/man2/syscalls.2:445 man-pages/man2/syscalls.2:450
#: man-pages/man2/syscalls.2:455 man-pages/man2/syscalls.2:557
#: man-pages/man2/syscalls.2:740 man-pages/man2/syscalls.2:745
#, no-wrap
msgid "in Linux 4.17)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:193 man-pages/man2/socketcall.2:58
#, no-wrap
msgid "B<bind>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:194
#, no-wrap
msgid "B<bpf>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:194
#, no-wrap
msgid "3.18"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:195
#, no-wrap
msgid "B<brk>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:196
#, no-wrap
msgid "B<breakpoint>(2)"
msgstr ""

#.  FIXME . document utrap_install()
#.  There's a man page for Solaris 5.11
#. type: tbl table
#: man-pages/man2/syscalls.2:196 man-pages/man2/syscalls.2:202
#: man-pages/man2/syscalls.2:203 man-pages/man2/syscalls.2:206
#: man-pages/man2/syscalls.2:323 man-pages/man2/syscalls.2:327
#: man-pages/man2/syscalls.2:364 man-pages/man2/syscalls.2:366
#: man-pages/man2/syscalls.2:433 man-pages/man2/syscalls.2:496
#: man-pages/man2/syscalls.2:535 man-pages/man2/syscalls.2:548
#: man-pages/man2/syscalls.2:584 man-pages/man2/syscalls.2:609
#: man-pages/man2/syscalls.2:610 man-pages/man2/syscalls.2:611
#: man-pages/man2/syscalls.2:612 man-pages/man2/syscalls.2:613
#: man-pages/man2/syscalls.2:614 man-pages/man2/syscalls.2:615
#: man-pages/man2/syscalls.2:652 man-pages/man2/syscalls.2:698
#: man-pages/man2/syscalls.2:700 man-pages/man2/syscalls.2:719
#: man-pages/man2/syscalls.2:805 man-pages/man2/syscalls.2:818
#: man-pages/man2/syscalls.2:819 man-pages/man2/syscalls.2:822
#, no-wrap
msgid "2.2"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:198
#, no-wrap
msgid "ARM OABI only, defined with\n"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:200 man-pages/man2/syscalls.2:321
#, no-wrap
msgid "B<__ARM_NR> prefix"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:201
#, no-wrap
msgid "B<cacheflush>(2)"
msgstr ""

#.  , PowerPC, ARM; not x86
#. type: tbl table
#: man-pages/man2/syscalls.2:201 man-pages/man2/syscalls.2:357
#: man-pages/man2/syscalls.2:523 man-pages/man2/syscalls.2:525
#: man-pages/man2/syscalls.2:527
#, no-wrap
msgid "Not on x86"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:202
#, no-wrap
msgid "B<capget>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:203
#, no-wrap
msgid "B<capset>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:204
#, no-wrap
msgid "B<chdir>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:205
#, no-wrap
msgid "B<chmod>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:206
#, no-wrap
msgid "B<chown>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:208 man-pages/man2/syscalls.2:415
#, no-wrap
msgid "See B<chown>(2) for\n"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:210 man-pages/man2/syscalls.2:417
#, no-wrap
msgid "version details"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:211
#, no-wrap
msgid "B<chown32>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:211 man-pages/man2/syscalls.2:218
#: man-pages/man2/syscalls.2:285 man-pages/man2/syscalls.2:288
#: man-pages/man2/syscalls.2:303 man-pages/man2/syscalls.2:309
#: man-pages/man2/syscalls.2:325 man-pages/man2/syscalls.2:342
#: man-pages/man2/syscalls.2:344 man-pages/man2/syscalls.2:346
#: man-pages/man2/syscalls.2:348 man-pages/man2/syscalls.2:365
#: man-pages/man2/syscalls.2:367 man-pages/man2/syscalls.2:376
#: man-pages/man2/syscalls.2:418 man-pages/man2/syscalls.2:430
#: man-pages/man2/syscalls.2:431 man-pages/man2/syscalls.2:459
#: man-pages/man2/syscalls.2:468 man-pages/man2/syscalls.2:499
#: man-pages/man2/syscalls.2:537 man-pages/man2/syscalls.2:542
#: man-pages/man2/syscalls.2:677 man-pages/man2/syscalls.2:679
#: man-pages/man2/syscalls.2:681 man-pages/man2/syscalls.2:683
#: man-pages/man2/syscalls.2:697 man-pages/man2/syscalls.2:699
#: man-pages/man2/syscalls.2:701 man-pages/man2/syscalls.2:703
#: man-pages/man2/syscalls.2:709 man-pages/man2/syscalls.2:748
#: man-pages/man2/syscalls.2:800 man-pages/man2/syscalls.2:801
#, no-wrap
msgid "2.4"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:212
#, no-wrap
msgid "B<chroot>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:213
#, no-wrap
msgid "B<clock_adjtime>(2)"
msgstr ""

#.  PowerPC, ARM, tile
#.  First appeared on ARM, as arm_sync_file_range(), but later renamed
#.  \fBsys_debug_setcontext\fP(2)	???	PowerPC if CONFIG_PPC32
#. type: tbl table
#: man-pages/man2/syscalls.2:213 man-pages/man2/syscalls.2:492
#: man-pages/man2/syscalls.2:517 man-pages/man2/syscalls.2:768
#, no-wrap
msgid "2.6.39"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:214
#, no-wrap
msgid "B<clock_getres>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:215
#, no-wrap
msgid "B<clock_gettime>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:216
#, no-wrap
msgid "B<clock_nanosleep>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:217
#, no-wrap
msgid "B<clock_settime>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:218
#, no-wrap
msgid "B<clone2>(2)"
msgstr ""

#. 	commit c7d5a0050773e98d1094eaa9f2a1a793fafac300 removed perfctr()
#. type: tbl table
#: man-pages/man2/syscalls.2:218 man-pages/man2/syscalls.2:537
#, no-wrap
msgid "IA-64 only"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:219
#, no-wrap
msgid "B<clone>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:220
#, no-wrap
msgid "B<clone3>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:220 man-pages/man2/syscalls.2:539
#, no-wrap
msgid "5.3"
msgstr ""

#.  .\" dcef1f634657dabe7905af3ccda12cf7f0b6fcc1
#.  .\" cc20d42986d5807cbe4f5c7c8e3dab2e59ea0db3
#.  .\" db695c0509d6ec9046ee5e4c520a19fa17d9fce2
#.  \fBcmpxchg\fP(2)	2.6.12	T{
#.  ARM, syscall constant never was
#.  .br
#.  exposed to userspace, in-kernel
#.  .br
#.  definition had \fB__ARM_NR\fP prefix,
#.  .br
#.  removed in 4.4
#.  T}
#.  867e359b97c970a60626d5d76bbe2a8fadbf38fb
#.  bb9d812643d8a121df7d614a2b9c60193a92deb0
#. type: tbl table
#: man-pages/man2/syscalls.2:236
#, no-wrap
msgid "B<cmpxchg_badaddr>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:236 man-pages/man2/syscalls.2:565
#, no-wrap
msgid "2.6.36"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:238
#, no-wrap
msgid "Tile only (port removed\n"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:241 man-pages/man2/socketcall.2:63
#, no-wrap
msgid "B<connect>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:242
#, no-wrap
msgid "B<copy_file_range>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:242
#, no-wrap
msgid "4.5"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:243
#, no-wrap
msgid "B<creat>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:244
#, no-wrap
msgid "B<create_module>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:244 man-pages/man2/syscalls.2:312
#: man-pages/man2/syscalls.2:584
#, no-wrap
msgid "Removed in 2.6"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:245
#, no-wrap
msgid "B<delete_module>(2)"
msgstr ""

#.  1394f03221790a988afc3e4b3cb79f2e477246a9
#.  4ba66a9760722ccbb691b8f7116cad2f791cca7b
#. type: tbl table
#: man-pages/man2/syscalls.2:248
#, no-wrap
msgid "B<dma_memcpy>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:253
#, no-wrap
msgid "B<dup>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:254
#, no-wrap
msgid "B<dup2>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:255
#, no-wrap
msgid "B<dup3>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:255 man-pages/man2/syscalls.2:257
#: man-pages/man2/syscalls.2:262 man-pages/man2/syscalls.2:385
#: man-pages/man2/syscalls.2:541 man-pages/man2/syscalls.2:722
#, no-wrap
msgid "2.6.27"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:256
#, no-wrap
msgid "B<epoll_create>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:257
#, no-wrap
msgid "B<epoll_create1>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:258
#, no-wrap
msgid "B<epoll_ctl>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:259
#, no-wrap
msgid "B<epoll_pwait>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:259 man-pages/man2/syscalls.2:322
#, no-wrap
msgid "2.6.19"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:260
#, no-wrap
msgid "B<epoll_wait>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:261
#, no-wrap
msgid "B<eventfd>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:262
#, no-wrap
msgid "B<eventfd2>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:263
#, no-wrap
msgid "B<execv>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:265
#, no-wrap
msgid "SPARC/SPARC64 only, for\n"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:267
#, no-wrap
msgid "compatibility with SunOS"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:268
#, no-wrap
msgid "B<execve>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:269
#, no-wrap
msgid "B<execveat>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:269 man-pages/man2/syscalls.2:619
#: man-pages/man2/syscalls.2:620
#, no-wrap
msgid "3.19"
msgstr ""

#. type: Plain text
#: man-pages/man2/syscalls.2:270 man-pages/man2/exit_group.2:50
#, no-wrap
msgid "B<exit>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:271
#, no-wrap
msgid "B<exit_group>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:272
#, no-wrap
msgid "B<faccessat>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:272 man-pages/man2/syscalls.2:283
#: man-pages/man2/syscalls.2:286 man-pages/man2/syscalls.2:304
#: man-pages/man2/syscalls.2:311 man-pages/man2/syscalls.2:421
#: man-pages/man2/syscalls.2:458 man-pages/man2/syscalls.2:461
#: man-pages/man2/syscalls.2:463 man-pages/man2/syscalls.2:495
#: man-pages/man2/syscalls.2:519 man-pages/man2/syscalls.2:547
#: man-pages/man2/syscalls.2:568 man-pages/man2/syscalls.2:591
#: man-pages/man2/syscalls.2:601 man-pages/man2/syscalls.2:734
#: man-pages/man2/syscalls.2:735 man-pages/man2/syscalls.2:761
#: man-pages/man2/syscalls.2:809 man-pages/man2/syscalls.2:810
#, no-wrap
msgid "2.6.16"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:273
#, no-wrap
msgid "B<fadvise64>(2)"
msgstr ""

#.  Implements \fBposix_fadvise\fP(2)
#. type: tbl table
#: man-pages/man2/syscalls.2:275
#, no-wrap
msgid "B<fadvise64_64>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:276
#, no-wrap
msgid "B<fallocate>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:276
#, no-wrap
msgid "2.6.23"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:277
#, no-wrap
msgid "B<fanotify_init>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:277 man-pages/man2/syscalls.2:278
#, no-wrap
msgid "2.6.37"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:278
#, no-wrap
msgid "B<fanotify_mark>(2)"
msgstr ""

#.  The fanotify calls were added in Linux 2.6.36,
#.  but disabled while the API was finalized.
#. type: tbl table
#: man-pages/man2/syscalls.2:281
#, no-wrap
msgid "B<fchdir>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:282
#, no-wrap
msgid "B<fchmod>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:283
#, no-wrap
msgid "B<fchmodat>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:284
#, no-wrap
msgid "B<fchown>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:285
#, no-wrap
msgid "B<fchown32>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:286
#, no-wrap
msgid "B<fchownat>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:287
#, no-wrap
msgid "B<fcntl>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:288
#, no-wrap
msgid "B<fcntl64>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:289
#, no-wrap
msgid "B<fdatasync>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:290
#, no-wrap
msgid "B<fgetxattr>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:290 man-pages/man2/syscalls.2:292
#: man-pages/man2/syscalls.2:296 man-pages/man2/syscalls.2:298
#: man-pages/man2/syscalls.2:378 man-pages/man2/syscalls.2:419
#: man-pages/man2/syscalls.2:423 man-pages/man2/syscalls.2:424
#: man-pages/man2/syscalls.2:426 man-pages/man2/syscalls.2:428
#: man-pages/man2/syscalls.2:599 man-pages/man2/syscalls.2:711
#, no-wrap
msgid "2.6; 2.4.18"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:291
#, no-wrap
msgid "B<finit_module>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:291
#, no-wrap
msgid "3.8"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:292
#, no-wrap
msgid "B<flistxattr>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:293
#, no-wrap
msgid "B<flock>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:294
#, no-wrap
msgid "B<fork>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:295
#, no-wrap
msgid "B<free_hugepages>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:296
#, no-wrap
msgid "B<fremovexattr>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:297
#, no-wrap
msgid "B<fsconfig>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:297 man-pages/man2/syscalls.2:299
#: man-pages/man2/syscalls.2:300 man-pages/man2/syscalls.2:301
#: man-pages/man2/syscalls.2:471 man-pages/man2/syscalls.2:518
#, no-wrap
msgid "5.2"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:298
#, no-wrap
msgid "B<fsetxattr>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:299
#, no-wrap
msgid "B<fsmount>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:300
#, no-wrap
msgid "B<fsopen>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:301
#, no-wrap
msgid "B<fspick>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:302
#, no-wrap
msgid "B<fstat>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:303
#, no-wrap
msgid "B<fstat64>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:304
#, no-wrap
msgid "B<fstatat64>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:305
#, no-wrap
msgid "B<fstatfs>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:306
#, no-wrap
msgid "B<fstatfs64>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:307
#, no-wrap
msgid "B<fsync>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:308
#, no-wrap
msgid "B<ftruncate>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:309
#, no-wrap
msgid "B<ftruncate64>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:310
#, no-wrap
msgid "B<futex>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:311
#, no-wrap
msgid "B<futimesat>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:312
#, no-wrap
msgid "B<get_kernel_syms>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:313
#, no-wrap
msgid "B<get_mempolicy>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:313 man-pages/man2/syscalls.2:432
#: man-pages/man2/syscalls.2:474 man-pages/man2/syscalls.2:476
#: man-pages/man2/syscalls.2:477 man-pages/man2/syscalls.2:478
#: man-pages/man2/syscalls.2:479 man-pages/man2/syscalls.2:480
#: man-pages/man2/syscalls.2:657
#, no-wrap
msgid "2.6.6"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:314
#, no-wrap
msgid "B<get_robust_list>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:314 man-pages/man2/syscalls.2:658
#: man-pages/man2/syscalls.2:733 man-pages/man2/syscalls.2:763
#: man-pages/man2/syscalls.2:780 man-pages/man2/syscalls.2:829
#, no-wrap
msgid "2.6.17"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:315
#, no-wrap
msgid "B<get_thread_area>(2)"
msgstr ""

#.  8fcd6c45f5a65621ec809b7866a3623e9a01d4ed
#. type: tbl table
#: man-pages/man2/syscalls.2:317
#, no-wrap
msgid "B<get_tls>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:317 man-pages/man2/syscalls.2:606
#: man-pages/man2/syscalls.2:621
#, no-wrap
msgid "4.15"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:319
#, no-wrap
msgid "ARM OABI only, has\n"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:322
#, no-wrap
msgid "B<getcpu>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:323
#, no-wrap
msgid "B<getcwd>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:324
#, no-wrap
msgid "B<getdents>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:325
#, no-wrap
msgid "B<getdents64>(2)"
msgstr ""

#.  parisc: 863722e856e64dae0e252b6bb546737c6c5626ce
#. type: tbl table
#: man-pages/man2/syscalls.2:327
#, no-wrap
msgid "B<getdomainname>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:329
#, no-wrap
msgid "SPARC, SPARC64; available\n"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:331
#, no-wrap
msgid "as B<osf_getdomainname>(2)\n"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:333
#, no-wrap
msgid "on Alpha since Linux 2.0"
msgstr ""

#.  ec98c6b9b47df6df1c1fa6cf3d427414f8c2cf16
#. type: tbl table
#: man-pages/man2/syscalls.2:335
#, no-wrap
msgid "B<getdtablesize>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:337
#, no-wrap
msgid "SPARC (removed in 2.6.26),\n"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:340
#, no-wrap
msgid ""
"available since Linux 2.0 on Alpha as\n"
"B<osf_getdtablesize>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:341
#, no-wrap
msgid "B<getegid>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:342
#, no-wrap
msgid "B<getegid32>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:343
#, no-wrap
msgid "B<geteuid>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:344
#, no-wrap
msgid "B<geteuid32>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:345
#, no-wrap
msgid "B<getgid>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:346
#, no-wrap
msgid "B<getgid32>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:347
#, no-wrap
msgid "B<getgroups>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:348
#, no-wrap
msgid "B<getgroups32>(2)"
msgstr ""

#.  SPARC removal: ec98c6b9b47df6df1c1fa6cf3d427414f8c2cf16
#. type: tbl table
#: man-pages/man2/syscalls.2:350
#, no-wrap
msgid "B<gethostname>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:352
#, no-wrap
msgid "Alpha, was available on\n"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:354
#, no-wrap
msgid "SPARC up to Linux 2.6.26"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:355
#, no-wrap
msgid "B<getitimer>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:356 man-pages/man2/socketcall.2:83
#, no-wrap
msgid "B<getpeername>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:357
#, no-wrap
msgid "B<getpagesize>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:358
#, no-wrap
msgid "B<getpgid>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:359
#, no-wrap
msgid "B<getpgrp>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:360
#, no-wrap
msgid "B<getpid>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:361
#, no-wrap
msgid "B<getppid>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:362
#, no-wrap
msgid "B<getpriority>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:363
#, no-wrap
msgid "B<getrandom>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:363 man-pages/man2/syscalls.2:407
#: man-pages/man2/syscalls.2:456 man-pages/man2/syscalls.2:457
#: man-pages/man2/syscalls.2:645
#, no-wrap
msgid "3.17"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:364
#, no-wrap
msgid "B<getresgid>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:365
#, no-wrap
msgid "B<getresgid32>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:366
#, no-wrap
msgid "B<getresuid>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:367
#, no-wrap
msgid "B<getresuid32>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:368
#, no-wrap
msgid "B<getrlimit>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:369
#, no-wrap
msgid "B<getrusage>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:370
#, no-wrap
msgid "B<getsid>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:371 man-pages/man2/socketcall.2:78
#, no-wrap
msgid "B<getsockname>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:372 man-pages/man2/socketcall.2:123
#, no-wrap
msgid "B<getsockopt>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:373
#, no-wrap
msgid "B<gettid>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:373
#, no-wrap
msgid "2.4.11"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:374
#, no-wrap
msgid "B<gettimeofday>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:375
#, no-wrap
msgid "B<getuid>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:376
#, no-wrap
msgid "B<getuid32>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:377
#, no-wrap
msgid "B<getunwind>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:377
#, no-wrap
msgid "2.4.8"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:377
#, no-wrap
msgid "IA-64 only; deprecated"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:378
#, no-wrap
msgid "B<getxattr>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:379
#, no-wrap
msgid "B<getxgid>(2)"
msgstr ""

#.  arch/alpha/include/asm/core_lca.h
#. type: tbl table
#: man-pages/man2/syscalls.2:379 man-pages/man2/syscalls.2:380
#: man-pages/man2/syscalls.2:381 man-pages/man2/syscalls.2:498
#: man-pages/man2/syscalls.2:685
#, no-wrap
msgid "Alpha only; see NOTES"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:380
#, no-wrap
msgid "B<getxpid>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:381
#, no-wrap
msgid "B<getxuid>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:382
#, no-wrap
msgid "B<init_module>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:383
#, no-wrap
msgid "B<inotify_add_watch>(2)"
msgstr ""

#.  5a0015d62668e64c8b6e02e360fbbea121bfd5e6
#. type: tbl table
#: man-pages/man2/syscalls.2:383 man-pages/man2/syscalls.2:384
#: man-pages/man2/syscalls.2:386 man-pages/man2/syscalls.2:399
#: man-pages/man2/syscalls.2:400 man-pages/man2/syscalls.2:408
#: man-pages/man2/syscalls.2:732 man-pages/man2/syscalls.2:836
#, no-wrap
msgid "2.6.13"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:384
#, no-wrap
msgid "B<inotify_init>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:385
#, no-wrap
msgid "B<inotify_init1>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:386
#, no-wrap
msgid "B<inotify_rm_watch>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:387
#, no-wrap
msgid "B<io_cancel>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:388
#, no-wrap
msgid "B<io_destroy>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:389
#, no-wrap
msgid "B<io_getevents>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:390
#, no-wrap
msgid "B<io_pgetevents>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:390 man-pages/man2/syscalls.2:608
#, no-wrap
msgid "4.18"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:391
#, no-wrap
msgid "B<io_setup>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:392
#, no-wrap
msgid "B<io_submit>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:393
#, no-wrap
msgid "B<io_uring_enter>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:393 man-pages/man2/syscalls.2:394
#: man-pages/man2/syscalls.2:395 man-pages/man2/syscalls.2:538
#, no-wrap
msgid "5.1"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:394
#, no-wrap
msgid "B<io_uring_register>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:395
#, no-wrap
msgid "B<io_uring_setup>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:397
#, no-wrap
msgid "B<ioperm>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:398
#, no-wrap
msgid "B<iopl>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:399
#, no-wrap
msgid "B<ioprio_get>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:400
#, no-wrap
msgid "B<ioprio_set>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:401
#, no-wrap
msgid "B<ipc>(2)"
msgstr ""

#.  Implements System V IPC calls
#. type: tbl table
#: man-pages/man2/syscalls.2:403
#, no-wrap
msgid "B<kcmp>(2)"
msgstr ""

#.  Implements System V IPC calls
#. type: tbl table
#: man-pages/man2/syscalls.2:403
#, no-wrap
msgid "3.5"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:404
#, no-wrap
msgid "B<kern_features>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:404 man-pages/man2/syscalls.2:618
#, no-wrap
msgid "3.7"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:404 man-pages/man2/syscalls.2:433
#: man-pages/man2/syscalls.2:819
#, no-wrap
msgid "SPARC64 only"
msgstr ""

#.  FIXME . document kern_features():
#.  commit 517ffce4e1a03aea979fe3a18a3dd1761a24fafb
#. type: tbl table
#: man-pages/man2/syscalls.2:407
#, no-wrap
msgid "B<kexec_file_load>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:408
#, no-wrap
msgid "B<kexec_load>(2)"
msgstr ""

#.  The entry in the syscall table was reserved starting in 2.6.7
#.  Was named sys_kexec_load() from 2.6.7 to 2.6.16
#. type: tbl table
#: man-pages/man2/syscalls.2:411
#, no-wrap
msgid "B<keyctl>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:412
#, no-wrap
msgid "B<kill>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:413
#, no-wrap
msgid "B<lchown>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:418
#, no-wrap
msgid "B<lchown32>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:419
#, no-wrap
msgid "B<lgetxattr>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:420
#, no-wrap
msgid "B<link>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:421
#, no-wrap
msgid "B<linkat>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:422 man-pages/man2/socketcall.2:68
#, no-wrap
msgid "B<listen>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:423
#, no-wrap
msgid "B<listxattr>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:424
#, no-wrap
msgid "B<llistxattr>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:425
#, no-wrap
msgid "B<lookup_dcookie>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:426
#, no-wrap
msgid "B<lremovexattr>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:427
#, no-wrap
msgid "B<lseek>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:428
#, no-wrap
msgid "B<lsetxattr>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:429
#, no-wrap
msgid "B<lstat>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:430
#, no-wrap
msgid "B<lstat64>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:431
#, no-wrap
msgid "B<madvise>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:432
#, no-wrap
msgid "B<mbind>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:433
#, no-wrap
msgid "B<memory_ordering>(2)"
msgstr ""

#.  26025bbfbba33a9425be1b89eccb4664ea4c17b6
#.  bb6fb6dfcc17cddac11ac295861f7608194447a7
#. type: tbl table
#: man-pages/man2/syscalls.2:436
#, no-wrap
msgid "B<metag_get_tls>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:438 man-pages/man2/syscalls.2:443
#: man-pages/man2/syscalls.2:448 man-pages/man2/syscalls.2:453
#, no-wrap
msgid "Metag only (port removed\n"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:441
#, no-wrap
msgid "B<metag_set_fpu_flags>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:446
#, no-wrap
msgid "B<metag_set_tls>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:451
#, no-wrap
msgid "B<metag_setglobalbit>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:456
#, no-wrap
msgid "B<membarrier>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:457
#, no-wrap
msgid "B<memfd_create>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:458
#, no-wrap
msgid "B<migrate_pages>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:459
#, no-wrap
msgid "B<mincore>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:460
#, no-wrap
msgid "B<mkdir>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:461
#, no-wrap
msgid "B<mkdirat>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:462
#, no-wrap
msgid "B<mknod>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:463
#, no-wrap
msgid "B<mknodat>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:464
#, no-wrap
msgid "B<mlock>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:465
#, no-wrap
msgid "B<mlock2>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:465
#, no-wrap
msgid "4.4"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:466
#, no-wrap
msgid "B<mlockall>(2)"
msgstr ""

#. type: Plain text
#: man-pages/man2/syscalls.2:467 man-pages/man2/msync.2:152
#, no-wrap
msgid "B<mmap>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:468
#, no-wrap
msgid "B<mmap2>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:469
#, no-wrap
msgid "B<modify_ldt>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:470
#, no-wrap
msgid "B<mount>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:471
#, no-wrap
msgid "B<move_mount>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:472
#, no-wrap
msgid "B<move_pages>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:472
#, no-wrap
msgid "2.6.18"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:473
#, no-wrap
msgid "B<mprotect>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:474
#, no-wrap
msgid "B<mq_getsetattr>(2)"
msgstr ""

#.  Implements \fBmq_getattr\fP(3) and \fBmq_setattr\fP(3)
#. type: tbl table
#: man-pages/man2/syscalls.2:476
#, no-wrap
msgid "B<mq_notify>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:477
#, no-wrap
msgid "B<mq_open>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:478
#, no-wrap
msgid "B<mq_timedreceive>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:479
#, no-wrap
msgid "B<mq_timedsend>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:480
#, no-wrap
msgid "B<mq_unlink>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:481
#, no-wrap
msgid "B<mremap>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:482
#, no-wrap
msgid "B<msgctl>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:482 man-pages/man2/syscalls.2:483
#: man-pages/man2/syscalls.2:484 man-pages/man2/syscalls.2:485
#: man-pages/man2/syscalls.2:647 man-pages/man2/syscalls.2:648
#: man-pages/man2/syscalls.2:649 man-pages/man2/syscalls.2:713
#: man-pages/man2/syscalls.2:714 man-pages/man2/syscalls.2:715
#: man-pages/man2/syscalls.2:716
#, no-wrap
msgid "See notes on B<ipc>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:483
#, no-wrap
msgid "B<msgget>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:484
#, no-wrap
msgid "B<msgrcv>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:485
#, no-wrap
msgid "B<msgsnd>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:486
#, no-wrap
msgid "B<msync>(2)"
msgstr ""

#.  \fBmultiplexer\fP(2)	??	__NR_multiplexer reserved on
#. 		PowerPC, but unimplemented?
#. type: tbl table
#: man-pages/man2/syscalls.2:489
#, no-wrap
msgid "B<munlock>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:490
#, no-wrap
msgid "B<munlockall>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:491
#, no-wrap
msgid "B<munmap>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:492
#, no-wrap
msgid "B<name_to_handle_at>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:493
#, no-wrap
msgid "B<nanosleep>(2)"
msgstr ""

#.  5590ff0d5528b60153c0b4e7b771472b5a95e297
#. type: tbl table
#: man-pages/man2/syscalls.2:495
#, no-wrap
msgid "B<newfstatat>(2)"
msgstr ""

#.  5590ff0d5528b60153c0b4e7b771472b5a95e297
#. type: tbl table
#: man-pages/man2/syscalls.2:495
#, no-wrap
msgid "See B<stat>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:496
#, no-wrap
msgid "B<nfsservctl>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:496
#, no-wrap
msgid "Removed in 3.1"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:497
#, no-wrap
msgid "B<nice>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:498
#, no-wrap
msgid "B<old_adjtimex>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:499
#, no-wrap
msgid "B<old_getrlimit>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:501
#, no-wrap
msgid "Old variant of B<getrlimit>(2)\n"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:503
#, no-wrap
msgid "that used a different value\n"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:505
#, no-wrap
msgid "for B<RLIM_INFINITY>"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:506
#, no-wrap
msgid "B<oldfstat>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:507
#, no-wrap
msgid "B<oldlstat>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:508
#, no-wrap
msgid "B<oldolduname>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:509
#, no-wrap
msgid "B<oldstat>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:510
#, no-wrap
msgid "B<oldumount>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:510
#, no-wrap
msgid "2.4.116"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:512
#, no-wrap
msgid "Name of the old B<umount>(2)\n"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:514
#, no-wrap
msgid "syscall on Alpha"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:515
#, no-wrap
msgid "B<olduname>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:516
#, no-wrap
msgid "B<open>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:517
#, no-wrap
msgid "B<open_by_handle_at>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:518
#, no-wrap
msgid "B<open_tree>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:519
#, no-wrap
msgid "B<openat>(2)"
msgstr ""

#.  9d02a4283e9ce4e9ca11ff00615bdacdb0515a1a
#. type: tbl table
#: man-pages/man2/syscalls.2:521
#, no-wrap
msgid "B<or1k_atomic>(2)"
msgstr ""

#.  9d02a4283e9ce4e9ca11ff00615bdacdb0515a1a
#. type: tbl table
#: man-pages/man2/syscalls.2:521
#, no-wrap
msgid "3.1"
msgstr ""

#.  9d02a4283e9ce4e9ca11ff00615bdacdb0515a1a
#. type: tbl table
#: man-pages/man2/syscalls.2:521
#, no-wrap
msgid "OpenRISC 1000 only"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:522
#, no-wrap
msgid "B<pause>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:523
#, no-wrap
msgid "B<pciconfig_iobase>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:523
#, no-wrap
msgid "2.2.15; 2.4"
msgstr ""

#.  Alpha, PowerPC, ARM; not x86
#. type: tbl table
#: man-pages/man2/syscalls.2:525
#, no-wrap
msgid "B<pciconfig_read>(2)"
msgstr ""

#.  , PowerPC, ARM; not x86
#. type: tbl table
#: man-pages/man2/syscalls.2:525 man-pages/man2/syscalls.2:527
#, no-wrap
msgid "2.0.26; 2.2"
msgstr ""

#.  , PowerPC, ARM; not x86
#. type: tbl table
#: man-pages/man2/syscalls.2:527
#, no-wrap
msgid "B<pciconfig_write>(2)"
msgstr ""

#.  , PowerPC, ARM; not x86
#. type: tbl table
#: man-pages/man2/syscalls.2:529
#, no-wrap
msgid "B<perf_event_open>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:529 man-pages/man2/syscalls.2:616
#, no-wrap
msgid "2.6.31"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:531
#, no-wrap
msgid "Was perf_counter_open() in\n"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:533
#, no-wrap
msgid "2.6.31; renamed in 2.6.32"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:534
#, no-wrap
msgid "B<personality>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:535
#, no-wrap
msgid "B<perfctr>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:535
#, no-wrap
msgid "SPARC only; removed in 2.6.34"
msgstr ""

#. 	commit c7d5a0050773e98d1094eaa9f2a1a793fafac300 removed perfctr()
#. type: tbl table
#: man-pages/man2/syscalls.2:537
#, no-wrap
msgid "B<perfmonctl>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:538
#, no-wrap
msgid "B<pidfd_send_signal>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:539
#, no-wrap
msgid "B<pidfd_open>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:540
#, no-wrap
msgid "B<pipe>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:541
#, no-wrap
msgid "B<pipe2>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:542
#, no-wrap
msgid "B<pivot_root>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:543
#, no-wrap
msgid "B<pkey_alloc>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:543 man-pages/man2/syscalls.2:544
#: man-pages/man2/syscalls.2:545
#, no-wrap
msgid "4.8"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:544
#, no-wrap
msgid "B<pkey_free>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:545
#, no-wrap
msgid "B<pkey_mprotect>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:546
#, no-wrap
msgid "B<poll>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:546
#, no-wrap
msgid "2.0.36; 2.2"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:547
#, no-wrap
msgid "B<ppoll>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:548
#, no-wrap
msgid "B<prctl>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:549
#, no-wrap
msgid "B<pread>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:551
#, no-wrap
msgid "Used for B<pread64>(2) on AVR32\n"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:553
#, no-wrap
msgid "(port removed in Linux 4.12)\n"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:555
#, no-wrap
msgid "and Blackfin (port removed\n"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:558
#, no-wrap
msgid "B<pread64>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:560
#, no-wrap
msgid "Added as \"pread\" in 2.2;\n"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:562
#, no-wrap
msgid "renamed \"pread64\" in 2.6"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:563
#, no-wrap
msgid "B<preadv>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:563 man-pages/man2/syscalls.2:582
#, no-wrap
msgid "2.6.30"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:564
#, no-wrap
msgid "B<preadv2>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:564 man-pages/man2/syscalls.2:583
#, no-wrap
msgid "4.6"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:565
#, no-wrap
msgid "B<prlimit64>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:566
#, no-wrap
msgid "B<process_vm_readv>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:566 man-pages/man2/syscalls.2:567
#, no-wrap
msgid "3.2"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:567
#, no-wrap
msgid "B<process_vm_writev>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:568
#, no-wrap
msgid "B<pselect6>(2)"
msgstr ""

#.  Implements \fBpselect\fP(2)
#. type: tbl table
#: man-pages/man2/syscalls.2:570
#, no-wrap
msgid "B<ptrace>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:571
#, no-wrap
msgid "B<pwrite>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:576
#, no-wrap
msgid ""
"Used for B<pwrite64>(2) on AVR32\n"
"(port removed in Linux 4.12)\n"
"and Blackfin (port removed\n"
"in Linux 4.17)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:577
#, no-wrap
msgid "B<pwrite64>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:579
#, no-wrap
msgid "Added as \"pwrite\" in 2.2;\n"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:581
#, no-wrap
msgid "renamed \"pwrite64\" in 2.6"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:582
#, no-wrap
msgid "B<pwritev>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:583
#, no-wrap
msgid "B<pwritev2>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:584
#, no-wrap
msgid "B<query_module>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:585
#, no-wrap
msgid "B<quotactl>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:587
#, no-wrap
msgid "B<readahead>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:587
#, no-wrap
msgid "2.4.13"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:588
#, no-wrap
msgid "B<readdir>(2)"
msgstr ""

#.  Supersedes \fBgetdents\fP(2)
#. type: tbl table
#: man-pages/man2/syscalls.2:590
#, no-wrap
msgid "B<readlink>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:591
#, no-wrap
msgid "B<readlinkat>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:592
#, no-wrap
msgid "B<readv>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:593
#, no-wrap
msgid "B<reboot>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:594 man-pages/man2/socketcall.2:98
#, no-wrap
msgid "B<recv>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:595 man-pages/man2/socketcall.2:108
#, no-wrap
msgid "B<recvfrom>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:596 man-pages/man2/socketcall.2:133
#, no-wrap
msgid "B<recvmsg>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:597 man-pages/man2/socketcall.2:143
#, no-wrap
msgid "B<recvmmsg>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:597
#, no-wrap
msgid "2.6.33"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:598
#, no-wrap
msgid "B<remap_file_pages>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:598
#, no-wrap
msgid "Deprecated since 3.16"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:599
#, no-wrap
msgid "B<removexattr>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:600
#, no-wrap
msgid "B<rename>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:601
#, no-wrap
msgid "B<renameat>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:602
#, no-wrap
msgid "B<renameat2>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:602
#, no-wrap
msgid "3.15"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:603
#, no-wrap
msgid "B<request_key>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:604
#, no-wrap
msgid "B<restart_syscall>(2)"
msgstr ""

#.  921ebd8f2c081b3cf6c3b29ef4103eef3ff26054
#. type: tbl table
#: man-pages/man2/syscalls.2:606
#, no-wrap
msgid "B<riscv_flush_icache>(2)"
msgstr ""

#.  921ebd8f2c081b3cf6c3b29ef4103eef3ff26054
#. type: tbl table
#: man-pages/man2/syscalls.2:606
#, no-wrap
msgid "RISC-V only"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:607
#, no-wrap
msgid "B<rmdir>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:608
#, no-wrap
msgid "B<rseq>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:609
#, no-wrap
msgid "B<rt_sigaction>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:610
#, no-wrap
msgid "B<rt_sigpending>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:611
#, no-wrap
msgid "B<rt_sigprocmask>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:612
#, no-wrap
msgid "B<rt_sigqueueinfo>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:613
#, no-wrap
msgid "B<rt_sigreturn>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:614
#, no-wrap
msgid "B<rt_sigsuspend>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:615
#, no-wrap
msgid "B<rt_sigtimedwait>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:616
#, no-wrap
msgid "B<rt_tgsigqueueinfo>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:617
#, no-wrap
msgid "B<rtas>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:617
#, no-wrap
msgid "2.6.2"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:617 man-pages/man2/syscalls.2:734
#: man-pages/man2/syscalls.2:735 man-pages/man2/syscalls.2:753
#: man-pages/man2/syscalls.2:754
#, no-wrap
msgid "PowerPC/PowerPC64 only"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:618
#, no-wrap
msgid "B<s390_runtime_instr>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:618 man-pages/man2/syscalls.2:619
#: man-pages/man2/syscalls.2:620 man-pages/man2/syscalls.2:621
#: man-pages/man2/syscalls.2:622
#, no-wrap
msgid "s390 only"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:619
#, no-wrap
msgid "B<s390_pci_mmio_read>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:620
#, no-wrap
msgid "B<s390_pci_mmio_write>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:621
#, no-wrap
msgid "B<s390_sthyi>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:622
#, no-wrap
msgid "B<s390_guarded_storage>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:622
#, no-wrap
msgid "4.12"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:623
#, no-wrap
msgid "B<sched_get_affinity>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:625
#, no-wrap
msgid "Name of B<sched_getaffinity>(2)\n"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:627 man-pages/man2/syscalls.2:639
#, no-wrap
msgid "on SPARC and SPARC64"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:628
#, no-wrap
msgid "B<sched_get_priority_max>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:629
#, no-wrap
msgid "B<sched_get_priority_min>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:630
#, no-wrap
msgid "B<sched_getaffinity>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:631
#, no-wrap
msgid "B<sched_getattr>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:631 man-pages/man2/syscalls.2:641
#, no-wrap
msgid "3.14"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:632
#, no-wrap
msgid "B<sched_getparam>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:633
#, no-wrap
msgid "B<sched_getscheduler>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:634
#, no-wrap
msgid "B<sched_rr_get_interval>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:635
#, no-wrap
msgid "B<sched_set_affinity>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:637
#, no-wrap
msgid "Name of B<sched_setaffinity>(2)\n"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:640
#, no-wrap
msgid "B<sched_setaffinity>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:641
#, no-wrap
msgid "B<sched_setattr>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:642
#, no-wrap
msgid "B<sched_setparam>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:643
#, no-wrap
msgid "B<sched_setscheduler>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:644
#, no-wrap
msgid "B<sched_yield>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:645
#, no-wrap
msgid "B<seccomp>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:646
#, no-wrap
msgid "B<select>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:647
#, no-wrap
msgid "B<semctl>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:648
#, no-wrap
msgid "B<semget>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:649
#, no-wrap
msgid "B<semop>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:650
#, no-wrap
msgid "B<semtimedop>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:650 man-pages/man2/syscalls.2:798
#, no-wrap
msgid "2.6; 2.4.22"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:651 man-pages/man2/socketcall.2:93
#, no-wrap
msgid "B<send>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:652
#, no-wrap
msgid "B<sendfile>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:653
#, no-wrap
msgid "B<sendfile64>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:653
#, no-wrap
msgid "2.6; 2.4.19"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:654 man-pages/man2/socketcall.2:148
#, no-wrap
msgid "B<sendmmsg>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:654 man-pages/man2/syscalls.2:688
#, no-wrap
msgid "3.0"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:655 man-pages/man2/socketcall.2:128
#, no-wrap
msgid "B<sendmsg>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:656 man-pages/man2/socketcall.2:103
#, no-wrap
msgid "B<sendto>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:657
#, no-wrap
msgid "B<set_mempolicy>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:658
#, no-wrap
msgid "B<set_robust_list>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:659
#, no-wrap
msgid "B<set_thread_area>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:660
#, no-wrap
msgid "B<set_tid_address>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:661
#, no-wrap
msgid "B<set_tls>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:661 man-pages/man2/syscalls.2:769
#, no-wrap
msgid "2.6.11"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:663
#, no-wrap
msgid "ARM OABI/EABI only (constant\n"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:665
#, no-wrap
msgid "has B<__ARM_NR> prefix)"
msgstr ""

#.  \fBsetaltroot\fP(2)	2.6.10	T{
#.  Removed in 2.6.11, exposed one
#.  of implementation details of
#.  \fBpersonality\fP(2) (creating an
#.  alternative root, precursor of
#.  mount namespaces) to user space.
#.  T}
#.  See http://lkml.org/lkml/2005/8/1/83
#.  "[PATCH] remove sys_set_zone_reclaim()"
#. type: tbl table
#: man-pages/man2/syscalls.2:675
#, no-wrap
msgid "B<setdomainname>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:676
#, no-wrap
msgid "B<setfsgid>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:677
#, no-wrap
msgid "B<setfsgid32>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:678
#, no-wrap
msgid "B<setfsuid>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:679
#, no-wrap
msgid "B<setfsuid32>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:680
#, no-wrap
msgid "B<setgid>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:681
#, no-wrap
msgid "B<setgid32>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:682
#, no-wrap
msgid "B<setgroups>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:683
#, no-wrap
msgid "B<setgroups32>(2)"
msgstr ""

#.  arch/alpha/include/asm/core_lca.h
#. type: tbl table
#: man-pages/man2/syscalls.2:685
#, no-wrap
msgid "B<sethae>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:686
#, no-wrap
msgid "B<sethostname>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:687
#, no-wrap
msgid "B<setitimer>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:688
#, no-wrap
msgid "B<setns>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:689
#, no-wrap
msgid "B<setpgid>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:690
#, no-wrap
msgid "B<setpgrp>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:692
#, no-wrap
msgid "Alternative name for\n"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:694
#, no-wrap
msgid "B<setpgid>(2) on Alpha"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:695
#, no-wrap
msgid "B<setpriority>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:696
#, no-wrap
msgid "B<setregid>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:697
#, no-wrap
msgid "B<setregid32>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:698
#, no-wrap
msgid "B<setresgid>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:699
#, no-wrap
msgid "B<setresgid32>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:700
#, no-wrap
msgid "B<setresuid>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:701
#, no-wrap
msgid "B<setresuid32>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:702
#, no-wrap
msgid "B<setreuid>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:703
#, no-wrap
msgid "B<setreuid32>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:704
#, no-wrap
msgid "B<setrlimit>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:705
#, no-wrap
msgid "B<setsid>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:706 man-pages/man2/socketcall.2:118
#, no-wrap
msgid "B<setsockopt>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:707
#, no-wrap
msgid "B<settimeofday>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:708
#, no-wrap
msgid "B<setuid>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:709
#, no-wrap
msgid "B<setuid32>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:710
#, no-wrap
msgid "B<setup>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:710
#, no-wrap
msgid "Removed in 2.2"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:711
#, no-wrap
msgid "B<setxattr>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:712
#, no-wrap
msgid "B<sgetmask>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:713
#, no-wrap
msgid "B<shmat>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:714
#, no-wrap
msgid "B<shmctl>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:715
#, no-wrap
msgid "B<shmdt>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:716
#, no-wrap
msgid "B<shmget>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:717 man-pages/man2/socketcall.2:113
#, no-wrap
msgid "B<shutdown>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:718
#, no-wrap
msgid "B<sigaction>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:719
#, no-wrap
msgid "B<sigaltstack>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:720
#, no-wrap
msgid "B<signal>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:721
#, no-wrap
msgid "B<signalfd>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:722
#, no-wrap
msgid "B<signalfd4>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:723
#, no-wrap
msgid "B<sigpending>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:724
#, no-wrap
msgid "B<sigprocmask>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:725
#, no-wrap
msgid "B<sigreturn>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:726
#, no-wrap
msgid "B<sigsuspend>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:727 man-pages/man2/socketcall.2:53
#, no-wrap
msgid "B<socket>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:728
#, no-wrap
msgid "B<socketcall>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:730 man-pages/man2/socketcall.2:88
#, no-wrap
msgid "B<socketpair>(2)"
msgstr ""

#.  5a0015d62668e64c8b6e02e360fbbea121bfd5e6
#. type: tbl table
#: man-pages/man2/syscalls.2:732
#, no-wrap
msgid "B<spill>(2)"
msgstr ""

#.  5a0015d62668e64c8b6e02e360fbbea121bfd5e6
#. type: tbl table
#: man-pages/man2/syscalls.2:732 man-pages/man2/syscalls.2:836
#, no-wrap
msgid "Xtensa only"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:733
#, no-wrap
msgid "B<splice>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:734
#, no-wrap
msgid "B<spu_create>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:735
#, no-wrap
msgid "B<spu_run>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:736
#, no-wrap
msgid "B<sram_alloc>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:738 man-pages/man2/syscalls.2:743
#, no-wrap
msgid "Blackfin (port removed\n"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:741
#, no-wrap
msgid "B<sram_free>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:746
#, no-wrap
msgid "B<ssetmask>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:747
#, no-wrap
msgid "B<stat>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:748
#, no-wrap
msgid "B<stat64>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:749
#, no-wrap
msgid "B<statfs>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:750
#, no-wrap
msgid "B<statfs64>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:751
#, no-wrap
msgid "B<statx>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:751
#, no-wrap
msgid "4.11"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:752
#, no-wrap
msgid "B<stime>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:753
#, no-wrap
msgid "B<subpage_prot>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:753 man-pages/man2/syscalls.2:794
#: man-pages/man2/syscalls.2:795 man-pages/man2/syscalls.2:796
#, no-wrap
msgid "2.6.25"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:754 man-pages/man2/syscalls.2:757
#, no-wrap
msgid "B<swapcontext>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:754 man-pages/man2/syscalls.2:757
#, no-wrap
msgid "2.6.3"
msgstr ""

#.  529d235a0e190ded1d21ccc80a73e625ebcad09b
#. type: tbl table
#: man-pages/man2/syscalls.2:756
#, no-wrap
msgid "B<switch_endian>(2)"
msgstr ""

#.  529d235a0e190ded1d21ccc80a73e625ebcad09b
#. type: tbl table
#: man-pages/man2/syscalls.2:756
#, no-wrap
msgid "4.1"
msgstr ""

#.  529d235a0e190ded1d21ccc80a73e625ebcad09b
#. type: tbl table
#: man-pages/man2/syscalls.2:756
#, no-wrap
msgid "PowerPC64 only"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:757 man-pages/man2/syscalls.2:769
#, no-wrap
msgid "PowerPC only"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:758
#, no-wrap
msgid "B<swapoff>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:759
#, no-wrap
msgid "B<swapon>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:760
#, no-wrap
msgid "B<symlink>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:761
#, no-wrap
msgid "B<symlinkat>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:762
#, no-wrap
msgid "B<sync>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:763
#, no-wrap
msgid "B<sync_file_range>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:764
#, no-wrap
msgid "B<sync_file_range2>(2)"
msgstr ""

#.  PowerPC, ARM, tile
#.  First appeared on ARM, as arm_sync_file_range(), but later renamed
#.  \fBsys_debug_setcontext\fP(2)	???	PowerPC if CONFIG_PPC32
#. type: tbl table
#: man-pages/man2/syscalls.2:768
#, no-wrap
msgid "B<syncfs>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:769
#, no-wrap
msgid "B<sys_debug_setcontext>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:772
#, no-wrap
msgid "Still available on ARM OABI\n"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:774
#, no-wrap
msgid "and MIPS O32 ABI"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:775
#, no-wrap
msgid "B<sysfs>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:776
#, no-wrap
msgid "B<sysinfo>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:777
#, no-wrap
msgid "B<syslog>(2)"
msgstr ""

#.  glibc interface is \fBklogctl\fP(3)
#. type: tbl table
#: man-pages/man2/syscalls.2:779
#, no-wrap
msgid "B<sysmips>(2)"
msgstr ""

#.  glibc interface is \fBklogctl\fP(3)
#. type: tbl table
#: man-pages/man2/syscalls.2:779
#, no-wrap
msgid "2.6.0"
msgstr ""

#.  glibc interface is \fBklogctl\fP(3)
#. type: tbl table
#: man-pages/man2/syscalls.2:779
#, no-wrap
msgid "MIPS only"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:781
#, no-wrap
msgid "B<tgkill>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:782
#, no-wrap
msgid "B<time>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:783
#, no-wrap
msgid "B<timer_create>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:784
#, no-wrap
msgid "B<timer_delete>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:785
#, no-wrap
msgid "B<timer_getoverrun>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:786
#, no-wrap
msgid "B<timer_gettime>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:787
#, no-wrap
msgid "B<timer_settime>(2)"
msgstr ""

#.  .\" b215e283992899650c4271e7385c79e26fb9a88e
#.  .\" 4d672e7ac79b5ec5cdc90e450823441e20464691
#.  \fBtimerfd\fP(2)	2.6.22	T{
#.  Old timerfd interface,
#.  removed in 2.6.25
#.  T}
#. type: tbl table
#: man-pages/man2/syscalls.2:794
#, no-wrap
msgid "B<timerfd_create>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:795
#, no-wrap
msgid "B<timerfd_gettime>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:796
#, no-wrap
msgid "B<timerfd_settime>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:797
#, no-wrap
msgid "B<times>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:798
#, no-wrap
msgid "B<tkill>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:799
#, no-wrap
msgid "B<truncate>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:800
#, no-wrap
msgid "B<truncate64>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:801
#, no-wrap
msgid "B<ugetrlimit>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:802
#, no-wrap
msgid "B<umask>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:803
#, no-wrap
msgid "B<umount>(2)"
msgstr ""

#.  sys_oldumount() -- __NR_umount
#. type: tbl table
#: man-pages/man2/syscalls.2:805
#, no-wrap
msgid "B<umount2>(2)"
msgstr ""

#.  sys_umount() -- __NR_umount2
#. type: tbl table
#: man-pages/man2/syscalls.2:807
#, no-wrap
msgid "B<uname>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:808
#, no-wrap
msgid "B<unlink>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:809
#, no-wrap
msgid "B<unlinkat>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:810
#, no-wrap
msgid "B<unshare>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:811
#, no-wrap
msgid "B<uselib>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:812
#, no-wrap
msgid "B<ustat>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:813
#, no-wrap
msgid "B<userfaultfd>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:813
#, no-wrap
msgid "4.3"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:814
#, no-wrap
msgid "B<usr26>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:814 man-pages/man2/syscalls.2:815
#, no-wrap
msgid "2.4.8.1"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:814 man-pages/man2/syscalls.2:815
#, no-wrap
msgid "ARM OABI only"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:815
#, no-wrap
msgid "B<usr32>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:816
#, no-wrap
msgid "B<utime>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:817
#, no-wrap
msgid "B<utimensat>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:818
#, no-wrap
msgid "B<utimes>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:819
#, no-wrap
msgid "B<utrap_install>(2)"
msgstr ""

#.  FIXME . document utrap_install()
#.  There's a man page for Solaris 5.11
#. type: tbl table
#: man-pages/man2/syscalls.2:822
#, no-wrap
msgid "B<vfork>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:823
#, no-wrap
msgid "B<vhangup>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:824
#, no-wrap
msgid "B<vm86old>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:827
#, no-wrap
msgid ""
"Was \"vm86\"; renamed in\n"
"2.0.28/2.2"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:828
#, no-wrap
msgid "B<vm86>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:828
#, no-wrap
msgid "2.0.28; 2.2"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:830
#, no-wrap
msgid "B<wait4>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:831
#, no-wrap
msgid "B<waitid>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:832
#, no-wrap
msgid "B<waitpid>(2)"
msgstr ""

#. type: TP
#: man-pages/man2/syscalls.2:833 man-pages/man2/eventfd.2:128
#, no-wrap
msgid "B<write>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:834
#, no-wrap
msgid "B<writev>(2)"
msgstr ""

#.  5a0015d62668e64c8b6e02e360fbbea121bfd5e6
#. type: tbl table
#: man-pages/man2/syscalls.2:836
#, no-wrap
msgid "B<xtensa>(2)"
msgstr ""

#. type: Plain text
#: man-pages/man2/syscalls.2:845
msgid ""
"On many platforms, including x86-32, socket calls are all multiplexed (via "
"glibc wrapper functions) through B<socketcall>(2)  and similarly System\\ V "
"IPC calls are multiplexed through B<ipc>(2)."
msgstr ""

#.  __NR_afs_syscall is 53 on Linux 2.6.22/i386
#.  __NR_break is 17 on Linux 2.6.22/i386
#.  __NR_ftime is 35 on Linux 2.6.22/i386
#.  __NR_getpmsg is 188 on Linux 2.6.22/i386
#.  __NR_gtty is 32 on Linux 2.6.22/i386
#.  __NR_idle is 112 on Linux 2.6.22/i386
#.  __NR_lock is 53 on Linux 2.6.22/i386
#.  __NR_madvise1 is 219 on Linux 2.6.22/i386
#.  __NR_mpx is 66 on Linux 2.6.22/i386
#.  Slot has been reused
#.  __NR_prof is 44 on Linux 2.6.22/i386
#.  __NR_profil is 98 on Linux 2.6.22/i386
#.  __NR_putpmsg is 189 on Linux 2.6.22/i386
#.  __NR_security is 223 on Linux 2.4/i386
#.  __NR_security is 223 on Linux 2.4/i386; absent on 2.6/i386, present
#.  on a couple of 2.6 architectures
#.  __NR_stty is 31 on Linux 2.6.22/i386
#.  The security call is for future use.
#.  __NR_tuxcall is 184 on x86_64, also on PPC and alpha
#.  __NR_ulimit is 58 on Linux 2.6.22/i386
#.  __NR_vserver is 273 on Linux 2.6.22/i386
#. type: Plain text
#: man-pages/man2/syscalls.2:890
msgid ""
"Although slots are reserved for them in the system call table, the following "
"system calls are not implemented in the standard kernel: B<afs_syscall>(2), "
"B<break>(2), B<ftime>(2), B<getpmsg>(2), B<gtty>(2), B<idle>(2), B<lock>(2), "
"B<madvise1>(2), B<mpx>(2), B<phys>(2), B<prof>(2), B<profil>(2), "
"B<putpmsg>(2), B<security>(2), B<stty>(2), B<tuxcall>(2), B<ulimit>(2), and "
"B<vserver>(2)  (see also B<unimplemented>(2)).  However, B<ftime>(3), "
"B<profil>(3), and B<ulimit>(3)  exist as library routines.  The slot for "
"B<phys>(2)  is in use since kernel 2.1.116 for B<umount>(2); B<phys>(2)  "
"will never be implemented.  The B<getpmsg>(2)  and B<putpmsg>(2)  calls are "
"for kernels patched to support STREAMS, and may never be in the standard "
"kernel."
msgstr ""

#. type: Plain text
#: man-pages/man2/syscalls.2:895
msgid ""
"There was briefly B<set_zone_reclaim>(2), added in Linux 2.6.13, and removed "
"in 2.6.16; this system call was never available to user space."
msgstr ""

#. type: Plain text
#: man-pages/man2/syscalls.2:910
msgid ""
"Roughly speaking, the code belonging to the system call with number __NR_xxx "
"defined in I</usr/include/asm/unistd.h> can be found in the Linux kernel "
"source in the routine I<sys_xxx>().  There are many exceptions, however, "
"mostly because older system calls were superseded by newer ones, and this "
"has been treated somewhat unsystematically.  On platforms with proprietary "
"operating-system emulation, such as sparc, sparc64, and alpha, there are "
"many additional system calls; mips64 also contains a full set of 32-bit "
"system calls."
msgstr ""

#. type: Plain text
#: man-pages/man2/syscalls.2:929
msgid ""
"Over time, changes to the interfaces of some system calls have been "
"necessary.  One reason for such changes was the need to increase the size of "
"structures or scalar values passed to the system call.  Because of these "
"changes, certain architectures (notably, longstanding 32-bit architectures "
"such as i386)  now have various groups of related system calls (e.g., "
"B<truncate>(2)  and B<truncate64>(2))  which perform similar tasks, but "
"which vary in details such as the size of their arguments.  (As noted "
"earlier, applications are generally unaware of this: the glibc wrapper "
"functions do some work to ensure that the right system call is invoked, and "
"that ABI compatibility is preserved for old binaries.)  Examples of systems "
"calls that exist in multiple versions are the following:"
msgstr ""

#.  e.g., on 2.6.22/i386: __NR_oldstat 18, __NR_stat 106, __NR_stat64 195
#.  The stat system calls deal with three different data structures,
#.  defined in include/asm-i386/stat.h: __old_kernel_stat, stat, stat64
#. type: Plain text
#: man-pages/man2/syscalls.2:950
msgid ""
"By now there are three different versions of B<stat>(2): I<sys_stat>()  "
"(slot I<__NR_oldstat>), I<sys_newstat>()  (slot I<__NR_stat>), and "
"I<sys_stat64>()  (slot I<__NR_stat64>), with the last being the most "
"current.  A similar story applies for B<lstat>(2)  and B<fstat>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/syscalls.2:961
msgid ""
"Similarly, the defines I<__NR_oldolduname>, I<__NR_olduname>, and "
"I<__NR_uname> refer to the routines I<sys_olduname>(), I<sys_uname>()  and "
"I<sys_newuname>()."
msgstr ""

#. type: Plain text
#: man-pages/man2/syscalls.2:968
msgid ""
"In Linux 2.0, a new version of B<vm86>(2)  appeared, with the old and the "
"new kernel routines being named I<sys_vm86old>()  and I<sys_vm86>()."
msgstr ""

#. type: Plain text
#: man-pages/man2/syscalls.2:979
msgid ""
"In Linux 2.4, a new version of B<getrlimit>(2)  appeared, with the old and "
"the new kernel routines being named I<sys_old_getrlimit>()  (slot "
"I<__NR_getrlimit>)  and I<sys_getrlimit>()  (slot I<__NR_ugetrlimit>)."
msgstr ""

#.  64-bit off_t changes: ftruncate64, *stat64,
#.  fcntl64 (because of the flock structure), getdents64, *statfs64
#. type: Plain text
#: man-pages/man2/syscalls.2:991
msgid ""
"Linux 2.4 increased the size of user and group IDs from 16 to 32 bits.  To "
"support this change, a range of system calls were added (e.g., "
"B<chown32>(2), B<getuid32>(2), B<getgroups32>(2), B<setresuid32>(2)), "
"superseding earlier calls of the same name without the \"32\" suffix."
msgstr ""

#. type: Plain text
#: man-pages/man2/syscalls.2:1008
msgid ""
"Linux 2.4 added support for applications on 32-bit architectures to access "
"large files (i.e., files for which the sizes and file offsets can't be "
"represented in 32 bits.)  To support this change, replacements were required "
"for system calls that deal with file offsets and sizes.  Thus the following "
"system calls were added: B<fcntl64>(2), B<getdents64>(2), B<stat64>(2), "
"B<statfs64>(2), B<truncate64>(2), and their analogs that work with file "
"descriptors or symbolic links.  These system calls supersede the older "
"system calls which, except in the case of the \"stat\" calls, have the same "
"name without the \"64\" suffix."
msgstr ""

#. type: Plain text
#: man-pages/man2/syscalls.2:1014
msgid ""
"On newer platforms that only have 64-bit file access and 32-bit UIDs/GIDs "
"(e.g., alpha, ia64, s390x, x86-64), there is just a single version of the "
"UID/GID and file access system calls.  On platforms (typically, 32-bit "
"platforms) where the *64 and *32 calls exist, the other versions are "
"obsolete."
msgstr ""

#. type: Plain text
#: man-pages/man2/syscalls.2:1022
msgid ""
"The I<rt_sig*> calls were added in kernel 2.2 to support the addition of "
"real-time signals (see B<signal>(7)).  These system calls supersede the "
"older system calls of the same name without the \"rt_\" prefix."
msgstr ""

#.  (used by libc 6)
#.  .PP
#.  Two system call numbers,
#.  .IR __NR__llseek
#.  and
#.  .IR __NR__sysctl
#.  have an additional underscore absent in
#.  .IR sys_llseek ()
#.  and
#.  .IR sys_sysctl ().
#
#.  In kernel 2.1.81,
#.  .BR lchown (2)
#.  and
#.  .BR chown (2)
#.  were swapped; that is,
#.  .BR lchown (2)
#.  was added with the semantics that were then current for
#.  .BR chown (2),
#.  and the semantics of the latter call were changed to what
#.  they are today.
#. type: Plain text
#: man-pages/man2/syscalls.2:1076
msgid ""
"The B<select>(2)  and B<mmap>(2)  system calls use five or more arguments, "
"which caused problems in the way argument passing on the i386 used to be set "
"up.  Thus, while other architectures have I<sys_select>()  and I<sys_mmap>()  "
"corresponding to I<__NR_select> and I<__NR_mmap>, on i386 one finds "
"I<old_select>()  and I<old_mmap>()  (routines that use a pointer to an "
"argument block) instead.  These days passing five arguments is not a problem "
"any more, and there is a I<__NR__newselect> that corresponds directly to "
"I<sys_select>()  and similarly I<__NR_mmap2>.  s390x is the only 64-bit "
"architecture that has I<old_mmap>()."
msgstr ""

#. type: SS
#: man-pages/man2/syscalls.2:1076
#, no-wrap
msgid "Architecture-specific details: Alpha"
msgstr ""

#. type: Plain text
#: man-pages/man2/syscalls.2:1083
msgid ""
"B<getxgid>(2)  returns a pair of GID and effective GID via registers B<r0> "
"and B<r20>; it is provided instead of B<getgid>(2) and B<getegid>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/syscalls.2:1088
msgid ""
"B<getxpid>(2)  returns a pair of PID and parent PID via registers B<r0> and "
"B<r20>; it is provided instead of B<getpid>(2) and B<getppid>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/syscalls.2:1092
msgid ""
"B<old_adjtimex>(2)  is a variant of B<adjtimex>(2) that uses I<struct "
"timeval32>, for compatibility with OSF/1."
msgstr ""

#. type: Plain text
#: man-pages/man2/syscalls.2:1097
msgid ""
"B<getxuid>(2)  returns a pair of GID and effective GID via registers B<r0> "
"and B<r20>; it is provided instead of B<getuid>(2) and B<geteuid>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/syscalls.2:1101
msgid ""
"B<sethae>(2)  is used for configuring the Host Address Extension register on "
"low-cost Alphas in order to access address space beyond first 27 bits."
msgstr ""

#. type: Plain text
#: man-pages/man2/syscalls.2:1107
msgid ""
"B<intro>(2), B<syscall>(2), B<unimplemented>(2), B<errno>(3), B<libc>(7), "
"B<vdso>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/syslog.2:33
#, no-wrap
msgid "SYSLOG"
msgstr ""

#. type: Plain text
#: man-pages/man2/syslog.2:37
msgid ""
"syslog, klogctl - read and/or clear kernel message ring buffer; set "
"console_loglevel"
msgstr ""

#. type: Plain text
#: man-pages/man2/syslog.2:41
#, no-wrap
msgid ""
"B<int syslog(int >I<type>B<, char *>I<bufp>B<, int >I<len>B<);>\n"
"B</* No wrapper provided in glibc */>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/syslog.2:44
#, no-wrap
msgid ""
"/* The glibc interface */\n"
"B<#include E<lt>sys/klog.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/syslog.2:46
#, no-wrap
msgid "B<int klogctl(int >I<type>B<, char *>I<bufp>B<, int >I<len>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/syslog.2:56
msgid ""
"I<Note>: Probably, you are looking for the C library function B<syslog>(), "
"which talks to B<syslogd>(8); see B<syslog>(3)  for details."
msgstr ""

#. type: Plain text
#: man-pages/man2/syslog.2:63
msgid ""
"This page describes the kernel B<syslog>()  system call, which is used to "
"control the kernel I<printk>()  buffer; the glibc wrapper function for the "
"system call is called B<klogctl>()."
msgstr ""

#. type: SS
#: man-pages/man2/syslog.2:63
#, no-wrap
msgid "The kernel log buffer"
msgstr ""

#.  Under "General setup" ==> "Kernel log buffer size"
#.  For 2.6, precisely the option seems to have appeared in 2.5.55.
#. type: Plain text
#: man-pages/man2/syslog.2:80
msgid ""
"The kernel has a cyclic buffer of length B<LOG_BUF_LEN> in which messages "
"given as arguments to the kernel function B<printk>()  are stored "
"(regardless of their log level).  In early kernels, B<LOG_BUF_LEN> had the "
"value 4096; from kernel 1.3.54, it was 8192; from kernel 2.1.113, it was "
"16384; since kernel 2.4.23/2.6, the value is a kernel configuration option "
"(B<CONFIG_LOG_BUF_SHIFT>, default value dependent on the architecture).  "
"Since Linux 2.6.6, the size can be queried with command type 10 (see below)."
msgstr ""

#. type: SS
#: man-pages/man2/syslog.2:80
#, no-wrap
msgid "Commands"
msgstr ""

#. type: Plain text
#: man-pages/man2/syslog.2:87
msgid ""
"The I<type> argument determines the action taken by this function.  The list "
"below specifies the values for I<type>.  The symbolic names are defined in "
"the kernel source, but are not exported to user space; you will either need "
"to use the numbers, or define the names yourself."
msgstr ""

#. type: TP
#: man-pages/man2/syslog.2:87
#, no-wrap
msgid "B<SYSLOG_ACTION_CLOSE> (0)"
msgstr ""

#. type: Plain text
#: man-pages/man2/syslog.2:91
msgid "Close the log.  Currently a NOP."
msgstr ""

#. type: TP
#: man-pages/man2/syslog.2:91
#, no-wrap
msgid "B<SYSLOG_ACTION_OPEN> (1)"
msgstr ""

#. type: Plain text
#: man-pages/man2/syslog.2:95
msgid "Open the log.  Currently a NOP."
msgstr ""

#. type: TP
#: man-pages/man2/syslog.2:95
#, no-wrap
msgid "B<SYSLOG_ACTION_READ> (2)"
msgstr ""

#. type: Plain text
#: man-pages/man2/syslog.2:107
msgid ""
"Read from the log.  The call waits until the kernel log buffer is nonempty, "
"and then reads at most I<len> bytes into the buffer pointed to by I<bufp>.  "
"The call returns the number of bytes read.  Bytes read from the log "
"disappear from the log buffer: the information can be read only once.  This "
"is the function executed by the kernel when a user program reads "
"I</proc/kmsg>."
msgstr ""

#. type: TP
#: man-pages/man2/syslog.2:107
#, no-wrap
msgid "B<SYSLOG_ACTION_READ_ALL> (3)"
msgstr ""

#. type: Plain text
#: man-pages/man2/syslog.2:117
msgid ""
"Read all messages remaining in the ring buffer, placing them in the buffer "
"pointed to by I<bufp>.  The call reads the last I<len> bytes from the log "
"buffer (nondestructively), but will not read more than was written into the "
"buffer since the last \"clear ring buffer\" command (see command 5 below)).  "
"The call returns the number of bytes read."
msgstr ""

#. type: TP
#: man-pages/man2/syslog.2:117
#, no-wrap
msgid "B<SYSLOG_ACTION_READ_CLEAR> (4)"
msgstr ""

#. type: Plain text
#: man-pages/man2/syslog.2:123
msgid ""
"Read and clear all messages remaining in the ring buffer.  The call does "
"precisely the same as for a I<type> of 3, but also executes the \"clear ring "
"buffer\" command."
msgstr ""

#. type: TP
#: man-pages/man2/syslog.2:123
#, no-wrap
msgid "B<SYSLOG_ACTION_CLEAR> (5)"
msgstr ""

#. type: Plain text
#: man-pages/man2/syslog.2:131
msgid ""
"The call executes just the \"clear ring buffer\" command.  The I<bufp> and "
"I<len> arguments are ignored."
msgstr ""

#. type: Plain text
#: man-pages/man2/syslog.2:142
msgid ""
"This command does not really clear the ring buffer.  Rather, it sets a "
"kernel bookkeeping variable that determines the results returned by commands "
"3 (B<SYSLOG_ACTION_READ_ALL>)  and 4 (B<SYSLOG_ACTION_READ_CLEAR>).  This "
"command has no effect on commands 2 (B<SYSLOG_ACTION_READ>)  and 9 "
"(B<SYSLOG_ACTION_SIZE_UNREAD>)."
msgstr ""

#. type: TP
#: man-pages/man2/syslog.2:142
#, no-wrap
msgid "B<SYSLOG_ACTION_CONSOLE_OFF> (6)"
msgstr ""

#.  commit 1aaad49e856ce41adc07d8ae0c8ef35fc4483245
#. type: Plain text
#: man-pages/man2/syslog.2:160
msgid ""
"The command saves the current value of I<console_loglevel> and then sets "
"I<console_loglevel> to I<minimum_console_loglevel>, so that no messages are "
"printed to the console.  Before Linux 2.6.32, the command simply sets "
"I<console_loglevel> to I<minimum_console_loglevel>.  See the discussion of "
"I</proc/sys/kernel/printk>, below."
msgstr ""

#. type: Plain text
#: man-pages/man2/syslog.2:166 man-pages/man2/syslog.2:189
msgid "The I<bufp> and I<len> arguments are ignored."
msgstr ""

#. type: TP
#: man-pages/man2/syslog.2:166
#, no-wrap
msgid "B<SYSLOG_ACTION_CONSOLE_ON> (7)"
msgstr ""

#.  commit 1aaad49e856ce41adc07d8ae0c8ef35fc4483245
#. type: Plain text
#: man-pages/man2/syslog.2:183
msgid ""
"If a previous B<SYSLOG_ACTION_CONSOLE_OFF> command has been performed, this "
"command restores I<console_loglevel> to the value that was saved by that "
"command.  Before Linux 2.6.32, this command simply sets I<console_loglevel> "
"to I<default_console_loglevel>.  See the discussion of "
"I</proc/sys/kernel/printk>, below."
msgstr ""

#. type: TP
#: man-pages/man2/syslog.2:189
#, no-wrap
msgid "B<SYSLOG_ACTION_CONSOLE_LEVEL> (8)"
msgstr ""

#. type: Plain text
#: man-pages/man2/syslog.2:206
msgid ""
"The call sets I<console_loglevel> to the value given in I<len>, which must "
"be an integer between 1 and 8 (inclusive).  The kernel silently enforces a "
"minimum value of I<minimum_console_loglevel> for I<len>.  See the I<log "
"level> section for details.  The I<bufp> argument is ignored."
msgstr ""

#. type: TP
#: man-pages/man2/syslog.2:206
#, no-wrap
msgid "B<SYSLOG_ACTION_SIZE_UNREAD> (9) (since Linux 2.4.10)"
msgstr ""

#. type: Plain text
#: man-pages/man2/syslog.2:217
msgid ""
"The call returns the number of bytes currently available to be read from the "
"kernel log buffer via command 2 (B<SYSLOG_ACTION_READ>).  The I<bufp> and "
"I<len> arguments are ignored."
msgstr ""

#. type: TP
#: man-pages/man2/syslog.2:217
#, no-wrap
msgid "B<SYSLOG_ACTION_SIZE_BUFFER> (10) (since Linux 2.6.6)"
msgstr ""

#. type: Plain text
#: man-pages/man2/syslog.2:225
msgid ""
"This command returns the total size of the kernel log buffer.  The I<bufp> "
"and I<len> arguments are ignored."
msgstr ""

#. type: Plain text
#: man-pages/man2/syslog.2:244
msgid ""
"All commands except 3 and 10 require privilege.  In Linux kernels before "
"2.6.37, command types 3 and 10 are allowed to unprivileged processes; since "
"Linux 2.6.37, these commands are allowed to unprivileged processes only if "
"I</proc/sys/kernel/dmesg_restrict> has the value 0.  Before Linux 2.6.37, "
"\"privileged\" means that the caller has the B<CAP_SYS_ADMIN> capability.  "
"Since Linux 2.6.37, \"privileged\" means that the caller has either the "
"B<CAP_SYS_ADMIN> capability (now deprecated for this purpose) or the (new)  "
"B<CAP_SYSLOG> capability."
msgstr ""

#. type: SS
#: man-pages/man2/syslog.2:244
#, no-wrap
msgid "/proc/sys/kernel/printk"
msgstr ""

#. type: Plain text
#: man-pages/man2/syslog.2:250
msgid ""
"I</proc/sys/kernel/printk> is a writable file containing four integer values "
"that influence kernel I<printk()> behavior when printing or logging error "
"messages.  The four values are:"
msgstr ""

#. type: TP
#: man-pages/man2/syslog.2:250
#, no-wrap
msgid "I<console_loglevel>"
msgstr ""

#.  since Linux 2.4
#. type: Plain text
#: man-pages/man2/syslog.2:268
msgid ""
"Only messages with a log level lower than this value will be printed to the "
"console.  The default value for this field is B<DEFAULT_CONSOLE_LOGLEVEL> "
"(7), but it is set to 4 if the kernel command line contains the word "
"\"quiet\", 10 if the kernel command line contains the word \"debug\", and to "
"15 in case of a kernel fault (the 10 and 15 are just silly, and equivalent "
"to 8).  The value of I<console_loglevel> can be set (to a value in the range "
"1\\(en8) by a B<syslog>()  call with a I<type> of 8."
msgstr ""

#. type: TP
#: man-pages/man2/syslog.2:268
#, no-wrap
msgid "I<default_message_loglevel>"
msgstr ""

#.  commit 5af5bcb8d37f99ba415a1adc6da71051b84f93a5
#. type: Plain text
#: man-pages/man2/syslog.2:281
msgid ""
"This value will be used as the log level for I<printk()> messages that do "
"not have an explicit level.  Up to and including Linux 2.6.38, the "
"hard-coded default value for this field was 4 (B<KERN_WARNING>); since Linux "
"2.6.39, the default value is a defined by the kernel configuration option "
"B<CONFIG_DEFAULT_MESSAGE_LOGLEVEL>, which defaults to 4."
msgstr ""

#. type: TP
#: man-pages/man2/syslog.2:281
#, no-wrap
msgid "I<minimum_console_loglevel>"
msgstr ""

#. type: Plain text
#: man-pages/man2/syslog.2:286
msgid ""
"The value in this field is the minimum value to which I<console_loglevel> "
"can be set."
msgstr ""

#. type: TP
#: man-pages/man2/syslog.2:286
#, no-wrap
msgid "I<default_console_loglevel>"
msgstr ""

#. type: Plain text
#: man-pages/man2/syslog.2:292
msgid "This is the default value for I<console_loglevel>."
msgstr ""

#. type: SS
#: man-pages/man2/syslog.2:292
#, no-wrap
msgid "The log level"
msgstr ""

#. type: Plain text
#: man-pages/man2/syslog.2:300
msgid ""
"Every I<printk>()  message has its own log level.  If the log level is not "
"explicitly specified as part of the message, it defaults to "
"I<default_message_loglevel>.  The conventional meaning of the log level is "
"as follows:"
msgstr ""

#. type: tbl table
#: man-pages/man2/syslog.2:303
#, no-wrap
msgid "Kernel constant"
msgstr ""

#. type: tbl table
#: man-pages/man2/syslog.2:303
#, no-wrap
msgid "Level value"
msgstr ""

#. type: tbl table
#: man-pages/man2/syslog.2:303
#, no-wrap
msgid "Meaning"
msgstr ""

#. type: tbl table
#: man-pages/man2/syslog.2:304
#, no-wrap
msgid "KERN_EMERG"
msgstr ""

#. type: TP
#: man-pages/man2/syslog.2:304 man-pages/man2/perf_event_open.2:1045
#: man-pages/man2/perf_event_open.2:3028 man-pages/man2/kcmp.2:223
#: man-pages/man2/bpf.2:1161 man-pages/man2/wait.2:146
#: man-pages/man2/s390_sthyi.2:48 man-pages/man2/s390_sthyi.2:67
#, no-wrap
msgid "0"
msgstr ""

#. type: tbl table
#: man-pages/man2/syslog.2:304
#, no-wrap
msgid "System is unusable"
msgstr ""

#. type: tbl table
#: man-pages/man2/syslog.2:305
#, no-wrap
msgid "KERN_ALERT"
msgstr ""

#. type: tbl table
#: man-pages/man2/syslog.2:305 man-pages/man2/perf_event_open.2:1048
#: man-pages/man2/perf_event_open.2:3026 man-pages/man2/kcmp.2:228
#: man-pages/man2/bpf.2:1163 man-pages/man2/syscall.2:198
#: man-pages/man2/syscall.2:199 man-pages/man2/syscall.2:206
#: man-pages/man2/syscall.2:326
#, no-wrap
msgid "1"
msgstr ""

#. type: tbl table
#: man-pages/man2/syslog.2:305
#, no-wrap
msgid "Action must be taken immediately"
msgstr ""

#. type: tbl table
#: man-pages/man2/syslog.2:306
#, no-wrap
msgid "KERN_CRIT"
msgstr ""

#. type: tbl table
#: man-pages/man2/syslog.2:306 man-pages/man2/perf_event_open.2:1051
#: man-pages/man2/perf_event_open.2:3023 man-pages/man2/kcmp.2:232
#: man-pages/man2/bpf.2:1165 man-pages/man2/syscall.2:187
#, no-wrap
msgid "2"
msgstr ""

#. type: tbl table
#: man-pages/man2/syslog.2:306
#, no-wrap
msgid "Critical conditions"
msgstr ""

#. type: tbl table
#: man-pages/man2/syslog.2:307
#, no-wrap
msgid "KERN_ERR"
msgstr ""

#. type: tbl table
#: man-pages/man2/syslog.2:307 man-pages/man2/perf_event_open.2:1054
#: man-pages/man2/kcmp.2:236 man-pages/man2/syscall.2:201
#: man-pages/man2/syscall.2:202
#, no-wrap
msgid "3"
msgstr ""

#. type: tbl table
#: man-pages/man2/syslog.2:307
#, no-wrap
msgid "Error conditions"
msgstr ""

#. type: tbl table
#: man-pages/man2/syslog.2:308
#, no-wrap
msgid "KERN_WARNING"
msgstr ""

#. type: TP
#: man-pages/man2/syslog.2:308 man-pages/man2/s390_sthyi.2:70
#, no-wrap
msgid "4"
msgstr ""

#. type: tbl table
#: man-pages/man2/syslog.2:308
#, no-wrap
msgid "Warning conditions"
msgstr ""

#. type: tbl table
#: man-pages/man2/syslog.2:309
#, no-wrap
msgid "KERN_NOTICE"
msgstr ""

#. type: tbl table
#: man-pages/man2/syslog.2:309 man-pages/man2/syscall.2:207
#: man-pages/man2/syscall.2:208
#, no-wrap
msgid "5"
msgstr ""

#. type: tbl table
#: man-pages/man2/syslog.2:309
#, no-wrap
msgid "Normal but significant condition"
msgstr ""

#. type: tbl table
#: man-pages/man2/syslog.2:310
#, no-wrap
msgid "KERN_INFO"
msgstr ""

#. type: tbl table
#: man-pages/man2/syslog.2:310
#, no-wrap
msgid "6"
msgstr ""

#. type: tbl table
#: man-pages/man2/syslog.2:310
#, no-wrap
msgid "Informational"
msgstr ""

#. type: tbl table
#: man-pages/man2/syslog.2:311
#, no-wrap
msgid "KERN_DEBUG"
msgstr ""

#. type: tbl table
#: man-pages/man2/syslog.2:311
#, no-wrap
msgid "7"
msgstr ""

#. type: tbl table
#: man-pages/man2/syslog.2:311
#, no-wrap
msgid "Debug-level messages"
msgstr ""

#. type: Plain text
#: man-pages/man2/syslog.2:319
msgid ""
"The kernel I<printk()> routine will print a message on the console only if "
"it has a log level less than the value of I<console_loglevel>."
msgstr ""

#. type: Plain text
#: man-pages/man2/syslog.2:332
msgid ""
"For I<type> equal to 2, 3, or 4, a successful call to B<syslog>()  returns "
"the number of bytes read.  For I<type> 9, B<syslog>()  returns the number of "
"bytes currently available to be read on the kernel log buffer.  For I<type> "
"10, B<syslog>()  returns the total size of the kernel log buffer.  For other "
"values of I<type>, 0 is returned on success."
msgstr ""

#. type: Plain text
#: man-pages/man2/syslog.2:335
msgid "In case of error, -1 is returned, and I<errno> is set to indicate the error."
msgstr ""

#. type: Plain text
#: man-pages/man2/syslog.2:353
msgid ""
"Bad arguments (e.g., bad I<type>; or for I<type> 2, 3, or 4, I<buf> is NULL, "
"or I<len> is less than zero; or for I<type> 8, the I<level> is outside the "
"range 1 to 8)."
msgstr ""

#. type: Plain text
#: man-pages/man2/syslog.2:360
msgid ""
"This B<syslog>()  system call is not available, because the kernel was "
"compiled with the B<CONFIG_PRINTK> kernel-configuration option disabled."
msgstr ""

#. type: Plain text
#: man-pages/man2/syslog.2:371
msgid ""
"An attempt was made to change I<console_loglevel> or clear the kernel "
"message ring buffer by a process without sufficient privilege (more "
"precisely: without the B<CAP_SYS_ADMIN> or B<CAP_SYSLOG> capability)."
msgstr ""

#. type: TP
#: man-pages/man2/syslog.2:371
#, no-wrap
msgid "B<ERESTARTSYS>"
msgstr ""

#. type: Plain text
#: man-pages/man2/syslog.2:375
msgid ""
"System call was interrupted by a signal; nothing was read.  (This can be "
"seen only during a trace.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/syslog.2:378
msgid ""
"This system call is Linux-specific and should not be used in programs "
"intended to be portable."
msgstr ""

#.  In libc4 and libc5 the number of this call was defined by
#.  .BR SYS_klog .
#.  In glibc 2.0 the syscall is baptized
#.  .BR klogctl ().
#. type: Plain text
#: man-pages/man2/syslog.2:386
msgid ""
"From the very start, people noted that it is unfortunate that a system call "
"and a library routine of the same name are entirely different animals."
msgstr ""

#. type: Plain text
#: man-pages/man2/syslog.2:389
msgid "B<dmesg>(1), B<syslog>(3), B<capabilities>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/symlink.2:33
#, no-wrap
msgid "SYMLINK"
msgstr ""

#. type: Plain text
#: man-pages/man2/symlink.2:36
msgid "symlink, symlinkat - make a new name for a file"
msgstr ""

#. type: Plain text
#: man-pages/man2/symlink.2:41
#, no-wrap
msgid "B<int symlink(const char *>I<target>B<, const char *>I<linkpath>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/symlink.2:47
#, no-wrap
msgid ""
"B<int symlinkat(const char *>I<target>B<, int >I<newdirfd>B<, const char "
"*>I<linkpath>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/symlink.2:56
msgid "B<symlink>():"
msgstr ""

#.     || _XOPEN_SOURCE\ &&\ _XOPEN_SOURCE_EXTENDED
#. type: Plain text
#: man-pages/man2/symlink.2:60 man-pages/man2/readlink.2:72
#, no-wrap
msgid ""
"_XOPEN_SOURCE\\ E<gt>=\\ 500 || _POSIX_C_SOURCE\\ E<gt>=\\ 200112L\n"
"    || /* Glibc versions E<lt>= 2.19: */ _BSD_SOURCE\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/symlink.2:63
msgid "B<symlinkat>():"
msgstr ""

#. type: Plain text
#: man-pages/man2/symlink.2:81
msgid ""
"B<symlink>()  creates a symbolic link named I<linkpath> which contains the "
"string I<target>."
msgstr ""

#. type: Plain text
#: man-pages/man2/symlink.2:85
msgid ""
"Symbolic links are interpreted at run time as if the contents of the link "
"had been substituted into the path being followed to find a file or "
"directory."
msgstr ""

#. type: Plain text
#: man-pages/man2/symlink.2:90
msgid ""
"Symbolic links may contain I<..> path components, which (if used at the "
"start of the link) refer to the parent directories of that in which the link "
"resides."
msgstr ""

#. type: Plain text
#: man-pages/man2/symlink.2:94
msgid ""
"A symbolic link (also known as a soft link) may point to an existing file or "
"to a nonexistent one; the latter case is known as a dangling link."
msgstr ""

#. type: Plain text
#: man-pages/man2/symlink.2:101
msgid ""
"The permissions of a symbolic link are irrelevant; the ownership is ignored "
"when following the link, but is checked when removal or renaming of the link "
"is requested and the link is in a directory with the sticky bit (B<S_ISVTX>)  "
"set."
msgstr ""

#. type: Plain text
#: man-pages/man2/symlink.2:107
msgid "If I<linkpath> exists, it will I<not> be overwritten."
msgstr ""

#. type: SS
#: man-pages/man2/symlink.2:107
#, no-wrap
msgid "symlinkat()"
msgstr ""

#. type: Plain text
#: man-pages/man2/symlink.2:113
msgid ""
"The B<symlinkat>()  system call operates in exactly the same way as "
"B<symlink>(), except for the differences described here."
msgstr ""

#. type: Plain text
#: man-pages/man2/symlink.2:123
msgid ""
"If the pathname given in I<linkpath> is relative, then it is interpreted "
"relative to the directory referred to by the file descriptor I<newdirfd> "
"(rather than relative to the current working directory of the calling "
"process, as is done by B<symlink>()  for a relative pathname)."
msgstr ""

#. type: Plain text
#: man-pages/man2/symlink.2:135
msgid ""
"If I<linkpath> is relative and I<newdirfd> is the special value B<AT_FDCWD>, "
"then I<linkpath> is interpreted relative to the current working directory of "
"the calling process (like B<symlink>())."
msgstr ""

#. type: Plain text
#: man-pages/man2/symlink.2:141
msgid "If I<linkpath> is absolute, then I<newdirfd> is ignored."
msgstr ""

#. type: Plain text
#: man-pages/man2/symlink.2:156
msgid ""
"Write access to the directory containing I<linkpath> is denied, or one of "
"the directories in the path prefix of I<linkpath> did not allow search "
"permission.  (See also B<path_resolution>(7).)"
msgstr ""

#. type: Plain text
#: man-pages/man2/symlink.2:161
msgid ""
"The user's quota of resources on the filesystem has been exhausted.  The "
"resources could be inodes or disk blocks, depending on the filesystem "
"implementation."
msgstr ""

#. type: Plain text
#: man-pages/man2/symlink.2:165
msgid "I<linkpath> already exists."
msgstr ""

#. type: Plain text
#: man-pages/man2/symlink.2:168
msgid "I<target> or I<linkpath> points outside your accessible address space."
msgstr ""

#. type: Plain text
#: man-pages/man2/symlink.2:175
msgid "Too many symbolic links were encountered in resolving I<linkpath>."
msgstr ""

#. type: Plain text
#: man-pages/man2/symlink.2:178
msgid "I<target> or I<linkpath> was too long."
msgstr ""

#. type: Plain text
#: man-pages/man2/symlink.2:187
msgid ""
"A directory component in I<linkpath> does not exist or is a dangling "
"symbolic link, or I<target> or I<linkpath> is an empty string."
msgstr ""

#. type: Plain text
#: man-pages/man2/symlink.2:199
msgid "A component used as a directory in I<linkpath> is not, in fact, a directory."
msgstr ""

#. type: Plain text
#: man-pages/man2/symlink.2:204
msgid ""
"The filesystem containing I<linkpath> does not support the creation of "
"symbolic links."
msgstr ""

#. type: Plain text
#: man-pages/man2/symlink.2:208
msgid "I<linkpath> is on a read-only filesystem."
msgstr ""

#. type: Plain text
#: man-pages/man2/symlink.2:211
msgid "The following additional errors can occur for B<symlinkat>():"
msgstr ""

#. type: Plain text
#: man-pages/man2/symlink.2:215
msgid "I<newdirfd> is not a valid file descriptor."
msgstr ""

#. type: Plain text
#: man-pages/man2/symlink.2:221
msgid ""
"I<linkpath> is a relative pathname and I<newdirfd> refers to a directory "
"that has been deleted."
msgstr ""

#. type: Plain text
#: man-pages/man2/symlink.2:227
msgid ""
"I<linkpath> is relative and I<newdirfd> is a file descriptor referring to a "
"file other than a directory."
msgstr ""

#. type: Plain text
#: man-pages/man2/symlink.2:231
msgid ""
"B<symlinkat>()  was added to Linux in kernel 2.6.16; library support was "
"added to glibc in version 2.4."
msgstr ""

#.  SVr4 documents additional error codes EDQUOT and ENOSYS.
#.  See
#.  .BR open (2)
#.  re multiple files with the same name, and NFS.
#. type: Plain text
#: man-pages/man2/symlink.2:238
msgid "B<symlink>(): SVr4, 4.3BSD, POSIX.1-2001, POSIX.1-2008."
msgstr ""

#. type: Plain text
#: man-pages/man2/symlink.2:241
msgid "B<symlinkat>(): POSIX.1-2008."
msgstr ""

#. type: Plain text
#: man-pages/man2/symlink.2:245
msgid "No checking of I<target> is done."
msgstr ""

#. type: Plain text
#: man-pages/man2/symlink.2:250
msgid ""
"Deleting the name referred to by a symbolic link will actually delete the "
"file (unless it also has other hard links).  If this behavior is not "
"desired, use B<link>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/symlink.2:263
msgid ""
"On older kernels where B<symlinkat>()  is unavailable, the glibc wrapper "
"function falls back to the use of B<symlink>().  When I<linkpath> is a "
"relative pathname, glibc constructs a pathname based on the symbolic link in "
"I</proc/self/fd> that corresponds to the I<newdirfd> argument."
msgstr ""

#. type: Plain text
#: man-pages/man2/symlink.2:274
msgid ""
"B<ln>(1), B<namei>(1), B<lchown>(2), B<link>(2), B<lstat>(2), B<open>(2), "
"B<readlink>(2), B<rename>(2), B<unlink>(2), B<path_resolution>(7), "
"B<symlink>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/gettid.2:26
#, no-wrap
msgid "GETTID"
msgstr ""

#. type: Plain text
#: man-pages/man2/gettid.2:29
msgid "gettid - get thread identification"
msgstr ""

#. type: Plain text
#: man-pages/man2/gettid.2:32 man-pages/man2/modify_ldt.2:31
#: man-pages/man2/recv.2:49
#, no-wrap
msgid "B<#include E<lt>sys/types.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/gettid.2:34
#, no-wrap
msgid "B<pid_t gettid(void);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/gettid.2:47
msgid ""
"B<gettid>()  returns the caller's thread ID (TID).  In a single-threaded "
"process, the thread ID is equal to the process ID (PID, as returned by "
"B<getpid>(2)).  In a multithreaded process, all threads have the same PID, "
"but each one has a unique TID.  For further details, see the discussion of "
"B<CLONE_THREAD> in B<clone>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/gettid.2:49
msgid "On success, returns the thread ID of the calling thread."
msgstr ""

#. type: Plain text
#: man-pages/man2/gettid.2:51
msgid "This call is always successful."
msgstr ""

#.  FIXME . See http://sourceware.org/bugzilla/show_bug.cgi?id=6399
#.  "gettid() should have a wrapper"
#. type: Plain text
#: man-pages/man2/gettid.2:61
msgid ""
"The B<gettid>()  system call first appeared on Linux in kernel 2.4.11.  "
"Library support was added in glibc 2.30.  (Earlier glibc versions did not "
"provide a wrapper for this system call, necessitating the use of "
"B<syscall>(2).)"
msgstr ""

#. type: Plain text
#: man-pages/man2/gettid.2:65
msgid ""
"B<gettid>()  is Linux-specific and should not be used in programs that are "
"intended to be portable."
msgstr ""

#. type: Plain text
#: man-pages/man2/gettid.2:69
msgid ""
"The thread ID returned by this call is not the same thing as a POSIX thread "
"ID (i.e., the opaque value returned by B<pthread_self>(3))."
msgstr ""

#. type: Plain text
#: man-pages/man2/gettid.2:81
msgid ""
"In a new thread group created by a B<clone>(2)  call that does not specify "
"the B<CLONE_THREAD> flag (or, equivalently, a new process created by "
"B<fork>(2)), the new process is a thread group leader, and its thread group "
"ID (the value returned by B<getpid>(2))  is the same as its thread ID (the "
"value returned by B<gettid>())."
msgstr ""

#.  .BR kcmp (2),
#.  .BR move_pages (2),
#.  .BR migrate_pages (2),
#.  .BR process_vm_readv (2),
#.  .BR ptrace (2),
#. type: Plain text
#: man-pages/man2/gettid.2:99
msgid ""
"B<capget>(2), B<clone>(2), B<fcntl>(2), B<fork>(2), B<getpid>(2), "
"B<get_robust_list>(2), B<ioprio_set>(2), B<perf_event_open>(2), "
"B<sched_setaffinity>(2), B<sched_setparam>(2), B<sched_setscheduler>(2), "
"B<tgkill>(2), B<timer_create>(2)"
msgstr ""

#. type: TH
#: man-pages/man2/socketcall.2:25
#, no-wrap
msgid "SOCKETCALL"
msgstr ""

#. type: Plain text
#: man-pages/man2/socketcall.2:28
msgid "socketcall - socket system calls"
msgstr ""

#. type: Plain text
#: man-pages/man2/socketcall.2:30
msgid "B<#include E<lt>linux/net.hE<gt>>"
msgstr ""

#. type: Plain text
#: man-pages/man2/socketcall.2:32
msgid "B<int socketcall(int >I<call>B<, unsigned long *>I<args>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/socketcall.2:40
msgid ""
"B<socketcall>()  is a common kernel entry point for the socket system "
"calls.  I<call> determines which socket function to invoke.  I<args> points "
"to a block containing the actual arguments, which are passed through to the "
"appropriate call."
msgstr ""

#. type: Plain text
#: man-pages/man2/socketcall.2:44
msgid ""
"User programs should call the appropriate functions by their usual names.  "
"Only standard library implementors and kernel hackers need to know about "
"B<socketcall>()."
msgstr ""

#. type: tbl table
#: man-pages/man2/socketcall.2:48
#, no-wrap
msgid "I<call>"
msgstr ""

#. type: tbl table
#: man-pages/man2/socketcall.2:51
#, no-wrap
msgid "B<SYS_SOCKET>"
msgstr ""

#. type: tbl table
#: man-pages/man2/socketcall.2:56
#, no-wrap
msgid "B<SYS_BIND>"
msgstr ""

#. type: tbl table
#: man-pages/man2/socketcall.2:61
#, no-wrap
msgid "B<SYS_CONNECT>"
msgstr ""

#. type: tbl table
#: man-pages/man2/socketcall.2:66
#, no-wrap
msgid "B<SYS_LISTEN>"
msgstr ""

#. type: tbl table
#: man-pages/man2/socketcall.2:71
#, no-wrap
msgid "B<SYS_ACCEPT>"
msgstr ""

#. type: tbl table
#: man-pages/man2/socketcall.2:76
#, no-wrap
msgid "B<SYS_GETSOCKNAME>"
msgstr ""

#. type: tbl table
#: man-pages/man2/socketcall.2:81
#, no-wrap
msgid "B<SYS_GETPEERNAME>"
msgstr ""

#. type: tbl table
#: man-pages/man2/socketcall.2:86
#, no-wrap
msgid "B<SYS_SOCKETPAIR>"
msgstr ""

#. type: tbl table
#: man-pages/man2/socketcall.2:91
#, no-wrap
msgid "B<SYS_SEND>"
msgstr ""

#. type: tbl table
#: man-pages/man2/socketcall.2:96
#, no-wrap
msgid "B<SYS_RECV>"
msgstr ""

#. type: tbl table
#: man-pages/man2/socketcall.2:101
#, no-wrap
msgid "B<SYS_SENDTO>"
msgstr ""

#. type: tbl table
#: man-pages/man2/socketcall.2:106
#, no-wrap
msgid "B<SYS_RECVFROM>"
msgstr ""

#. type: tbl table
#: man-pages/man2/socketcall.2:111
#, no-wrap
msgid "B<SYS_SHUTDOWN>"
msgstr ""

#. type: tbl table
#: man-pages/man2/socketcall.2:116
#, no-wrap
msgid "B<SYS_SETSOCKOPT>"
msgstr ""

#. type: tbl table
#: man-pages/man2/socketcall.2:121
#, no-wrap
msgid "B<SYS_GETSOCKOPT>"
msgstr ""

#. type: tbl table
#: man-pages/man2/socketcall.2:126
#, no-wrap
msgid "B<SYS_SENDMSG>"
msgstr ""

#. type: tbl table
#: man-pages/man2/socketcall.2:131
#, no-wrap
msgid "B<SYS_RECVMSG>"
msgstr ""

#. type: tbl table
#: man-pages/man2/socketcall.2:136
#, no-wrap
msgid "B<SYS_ACCEPT4>"
msgstr ""

#. type: tbl table
#: man-pages/man2/socketcall.2:141
#, no-wrap
msgid "B<SYS_RECVMMSG>"
msgstr ""

#. type: tbl table
#: man-pages/man2/socketcall.2:146
#, no-wrap
msgid "B<SYS_SENDMMSG>"
msgstr ""

#. type: Plain text
#: man-pages/man2/socketcall.2:153
msgid ""
"This call is specific to Linux, and should not be used in programs intended "
"to be portable."
msgstr ""

#. type: Plain text
#: man-pages/man2/socketcall.2:161
msgid ""
"On a some architectures\\(emfor example, x86-64 and ARM\\(emthere is no "
"B<socketcall>()  system call; instead B<socket>(2), B<accept>(2), "
"B<bind>(2), and so on really are implemented as separate system calls."
msgstr ""

#.  commit 9dea5dc921b5f4045a18c63eb92e84dc274d17eb
#. type: Plain text
#: man-pages/man2/socketcall.2:174
msgid ""
"On x86-32, B<socketcall>()  was historically the only entry point for the "
"sockets API.  However, starting in Linux 4.3, direct system calls are "
"provided on x86-32 for the sockets API.  This facilitates the creation of "
"B<seccomp>(2)  filters that filter sockets system calls (for new user-space "
"binaries that are compiled to use the new entry points)  and also provides a "
"(very) small performance improvement."
msgstr ""

#. type: Plain text
#: man-pages/man2/socketcall.2:191
msgid ""
"B<accept>(2), B<bind>(2), B<connect>(2), B<getpeername>(2), "
"B<getsockname>(2), B<getsockopt>(2), B<listen>(2), B<recv>(2), "
"B<recvfrom>(2), B<recvmsg>(2), B<send>(2), B<sendmsg>(2), B<sendto>(2), "
"B<setsockopt>(2), B<shutdown>(2), B<socket>(2), B<socketpair>(2)"
msgstr ""

#. type: TH
#: man-pages/man2/perf_event_open.2:27
#, no-wrap
msgid "PERF_EVENT_OPEN"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:30
msgid "perf_event_open - set up performance monitoring"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:34
#, no-wrap
msgid ""
"B<#include E<lt>linux/perf_event.hE<gt>>\n"
"B<#include E<lt>linux/hw_breakpoint.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:38
#, no-wrap
msgid ""
"B<int perf_event_open(struct perf_event_attr *>I<attr>B<,>\n"
"B<                    pid_t >I<pid>B<, int >I<cpu>B<, int >I<group_fd>B<,>\n"
"B<                    unsigned long >I<flags>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:47
msgid ""
"Given a list of parameters, B<perf_event_open>()  returns a file descriptor, "
"for use in subsequent system calls (B<read>(2), B<mmap>(2), B<prctl>(2), "
"B<fcntl>(2), etc.)."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:55
msgid ""
"A call to B<perf_event_open>()  creates a file descriptor that allows "
"measuring performance information.  Each file descriptor corresponds to one "
"event that is measured; these can be grouped together to measure multiple "
"events simultaneously."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:62
msgid ""
"Events can be enabled and disabled in two ways: via B<ioctl>(2)  and via "
"B<prctl>(2).  When an event is disabled it does not count or generate "
"overflows but does continue to exist and maintain its count value."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:76
msgid ""
"Events come in two flavors: counting and sampled.  A I<counting> event is "
"one that is used for counting the aggregate number of events that occur.  In "
"general, counting event results are gathered with a B<read>(2)  call.  A "
"I<sampling> event periodically writes measurements to a buffer that can then "
"be accessed via B<mmap>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:83
msgid ""
"The I<pid> and I<cpu> arguments allow specifying which process and CPU to "
"monitor:"
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:83
#, no-wrap
msgid "B<pid == 0> and B<cpu == -1>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:86
msgid "This measures the calling process/thread on any CPU."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:86
#, no-wrap
msgid "B<pid == 0> and B<cpu E<gt>= 0>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:90
msgid ""
"This measures the calling process/thread only when running on the specified "
"CPU."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:90
#, no-wrap
msgid "B<pid E<gt> 0> and B<cpu == -1>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:93
msgid "This measures the specified process/thread on any CPU."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:93
#, no-wrap
msgid "B<pid E<gt> 0> and B<cpu E<gt>= 0>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:97
msgid ""
"This measures the specified process/thread only when running on the "
"specified CPU."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:97
#, no-wrap
msgid "B<pid == -1> and B<cpu E<gt>= 0>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:105
msgid ""
"This measures all processes/threads on the specified CPU.  This requires "
"B<CAP_SYS_ADMIN> capability or a I</proc/sys/kernel/perf_event_paranoid> "
"value of less than 1."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:105
#, no-wrap
msgid "B<pid == -1> and B<cpu == -1>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:108
msgid "This setting is invalid and will return an error."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:116
msgid ""
"When I<pid> is greater than zero, permission to perform this system call is "
"governed by a ptrace access mode B<PTRACE_MODE_READ_REALCREDS> check; see "
"B<ptrace>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:138
msgid ""
"The I<group_fd> argument allows event groups to be created.  An event group "
"has one event which is the group leader.  The leader is created first, with "
"I<group_fd> = -1.  The rest of the group members are created with subsequent "
"B<perf_event_open>()  calls with I<group_fd> being set to the file "
"descriptor of the group leader.  (A single event on its own is created with "
"I<group_fd> = -1 and is considered to be a group with only 1 member.)  An "
"event group is scheduled onto the CPU as a unit: it will be put onto the CPU "
"only if all of the events in the group can be put onto the CPU.  This means "
"that the values of the member events can be meaningfully compared\\(emadded, "
"divided (to get ratios), and so on\\(emwith each other, since they have "
"counted events for the same set of executed instructions."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:142
msgid ""
"The I<flags> argument is formed by ORing together zero or more of the "
"following values:"
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:142
#, no-wrap
msgid "B<PERF_FLAG_FD_CLOEXEC> (since Linux 3.14)"
msgstr ""

#.  commit a21b0b354d4ac39be691f51c53562e2c24443d9e
#. type: Plain text
#: man-pages/man2/perf_event_open.2:159
msgid ""
"This flag enables the close-on-exec flag for the created event file "
"descriptor, so that the file descriptor is automatically closed on "
"B<execve>(2).  Setting the close-on-exec flags at creation time, rather than "
"later with B<fcntl>(2), avoids potential race conditions where the calling "
"thread invokes B<perf_event_open>()  and B<fcntl>(2)  at the same time as "
"another thread calls B<fork>(2)  then B<execve>(2)."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:159
#, no-wrap
msgid "B<PERF_FLAG_FD_NO_GROUP>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:167
msgid ""
"This flag tells the event to ignore the I<group_fd> parameter except for the "
"purpose of setting up output redirection using the B<PERF_FLAG_FD_OUTPUT> "
"flag."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:167
#, no-wrap
msgid "B<PERF_FLAG_FD_OUTPUT> (broken since Linux 2.6.35)"
msgstr ""

#.  commit ac9721f3f54b27a16c7e1afb2481e7ee95a70318
#. type: Plain text
#: man-pages/man2/perf_event_open.2:173
msgid ""
"This flag re-routes the event's sampled output to instead be included in the "
"mmap buffer of the event specified by I<group_fd>."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:173
#, no-wrap
msgid "B<PERF_FLAG_PID_CGROUP> (since Linux 2.6.39)"
msgstr ""

#.  commit e5d1367f17ba6a6fed5fd8b74e4d5720923e0c25
#. type: Plain text
#: man-pages/man2/perf_event_open.2:197
msgid ""
"This flag activates per-container system-wide monitoring.  A container is an "
"abstraction that isolates a set of resources for finer-grained control "
"(CPUs, memory, etc.).  In this mode, the event is measured only if the "
"thread running on the monitored CPU belongs to the designated container "
"(cgroup).  The cgroup is identified by passing a file descriptor opened on "
"its directory in the cgroupfs filesystem.  For instance, if the cgroup to "
"monitor is called I<test>, then a file descriptor opened on "
"I</dev/cgroup/test> (assuming cgroupfs is mounted on I</dev/cgroup>)  must "
"be passed as the I<pid> parameter.  cgroup monitoring is available only for "
"system-wide events and may therefore require extra permissions."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:202
msgid ""
"The I<perf_event_attr> structure provides detailed configuration information "
"for the event being created."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:209
#, no-wrap
msgid ""
"struct perf_event_attr {\n"
"    __u32 type;                 /* Type of event */\n"
"    __u32 size;                 /* Size of attribute structure */\n"
"    __u64 config;               /* Type-specific configuration */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:214
#, no-wrap
msgid ""
"    union {\n"
"        __u64 sample_period;    /* Period of sampling */\n"
"        __u64 sample_freq;      /* Frequency of sampling */\n"
"    };\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:217
#, no-wrap
msgid ""
"    __u64 sample_type;  /* Specifies values included in sample */\n"
"    __u64 read_format;  /* Specifies values returned in read */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:247
#, no-wrap
msgid ""
"    __u64 disabled       : 1,   /* off by default */\n"
"          inherit        : 1,   /* children inherit it */\n"
"          pinned         : 1,   /* must always be on PMU */\n"
"          exclusive      : 1,   /* only group on PMU */\n"
"          exclude_user   : 1,   /* don't count user */\n"
"          exclude_kernel : 1,   /* don't count kernel */\n"
"          exclude_hv     : 1,   /* don't count hypervisor */\n"
"          exclude_idle   : 1,   /* don't count when idle */\n"
"          mmap           : 1,   /* include mmap data */\n"
"          comm           : 1,   /* include comm data */\n"
"          freq           : 1,   /* use freq, not period */\n"
"          inherit_stat   : 1,   /* per task counts */\n"
"          enable_on_exec : 1,   /* next exec enables */\n"
"          task           : 1,   /* trace fork/exit */\n"
"          watermark      : 1,   /* wakeup_watermark */\n"
"          precise_ip     : 2,   /* skid constraint */\n"
"          mmap_data      : 1,   /* non-exec mmap data */\n"
"          sample_id_all  : 1,   /* sample_type all events */\n"
"          exclude_host   : 1,   /* don't count in host */\n"
"          exclude_guest  : 1,   /* don't count in guest */\n"
"          exclude_callchain_kernel : 1,\n"
"                                /* exclude kernel callchains */\n"
"          exclude_callchain_user   : 1,\n"
"                                /* exclude user callchains */\n"
"          mmap2          :  1,  /* include mmap with inode data */\n"
"          comm_exec      :  1,  /* flag comm events that are\n"
"                                   due to exec */\n"
"          use_clockid    :  1,  /* use clockid for time fields */\n"
"          context_switch :  1,  /* context switch data */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:249
#, no-wrap
msgid "          __reserved_1   : 37;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:254
#, no-wrap
msgid ""
"    union {\n"
"        __u32 wakeup_events;    /* wakeup every n events */\n"
"        __u32 wakeup_watermark; /* bytes before wakeup */\n"
"    };\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:256
#, no-wrap
msgid "    __u32     bp_type;          /* breakpoint type */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:263
#, no-wrap
msgid ""
"    union {\n"
"        __u64 bp_addr;          /* breakpoint address */\n"
"        __u64 kprobe_func;      /* for perf_kprobe */\n"
"        __u64 uprobe_path;      /* for perf_uprobe */\n"
"        __u64 config1;          /* extension of config */\n"
"    };\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:279
#, no-wrap
msgid ""
"    union {\n"
"        __u64 bp_len;           /* breakpoint length */\n"
"        __u64 kprobe_addr;      /* with kprobe_func == NULL */\n"
"        __u64 probe_offset;     /* for perf_[k,u]probe */\n"
"        __u64 config2;          /* extension of config1 */\n"
"    };\n"
"    __u64 branch_sample_type;   /* enum perf_branch_sample_type */\n"
"    __u64 sample_regs_user;     /* user regs to dump on samples */\n"
"    __u32 sample_stack_user;    /* size of stack to dump on\n"
"                                   samples */\n"
"    __s32 clockid;              /* clock to use for time fields */\n"
"    __u64 sample_regs_intr;     /* regs to dump on samples */\n"
"    __u32 aux_watermark;        /* aux bytes before wakeup */\n"
"    __u16 sample_max_stack;     /* max frames in callchain */\n"
"    __u16 __reserved_2;         /* align to u64 */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:281
#, no-wrap
msgid "};\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:287
msgid ""
"The fields of the I<perf_event_attr> structure are described in more detail "
"below:"
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:287 man-pages/man2/perf_event_open.2:1923
#, no-wrap
msgid "I<type>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:291
msgid ""
"This field specifies the overall event type.  It has one of the following "
"values:"
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:292
#, no-wrap
msgid "B<PERF_TYPE_HARDWARE>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:299
msgid ""
"This indicates one of the \"generalized\" hardware events provided by the "
"kernel.  See the I<config> field definition for more details."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:299
#, no-wrap
msgid "B<PERF_TYPE_SOFTWARE>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:303
msgid ""
"This indicates one of the software-defined events provided by the kernel "
"(even if no hardware support is available)."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:303
#, no-wrap
msgid "B<PERF_TYPE_TRACEPOINT>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:307
msgid ""
"This indicates a tracepoint provided by the kernel tracepoint "
"infrastructure."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:307
#, no-wrap
msgid "B<PERF_TYPE_HW_CACHE>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:313
msgid ""
"This indicates a hardware cache event.  This has a special encoding, "
"described in the I<config> field definition."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:313
#, no-wrap
msgid "B<PERF_TYPE_RAW>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:317
msgid ""
"This indicates a \"raw\" implementation-specific event in the I<config> "
"field."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:317
#, no-wrap
msgid "B<PERF_TYPE_BREAKPOINT> (since Linux 2.6.33)"
msgstr ""

#.  commit 24f1e32c60c45c89a997c73395b69c8af6f0a84e
#. type: Plain text
#: man-pages/man2/perf_event_open.2:323
msgid ""
"This indicates a hardware breakpoint as provided by the CPU.  Breakpoints "
"can be read/write accesses to an address as well as execution of an "
"instruction address."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:323
#, no-wrap
msgid "dynamic PMU"
msgstr ""

#.  commit 2e80a82a49c4c7eca4e35734380f28298ba5db19
#. type: Plain text
#: man-pages/man2/perf_event_open.2:343
msgid ""
"Since Linux 2.6.38, B<perf_event_open>()  can support multiple PMUs.  To "
"enable this, a value exported by the kernel can be used in the I<type> field "
"to indicate which PMU to use.  The value to use can be found in the sysfs "
"filesystem: there is a subdirectory per PMU instance under "
"I</sys/bus/event_source/devices>.  In each subdirectory there is a I<type> "
"file whose content is an integer that can be used in the I<type> field.  For "
"instance, I</sys/bus/event_source/devices/cpu/type> contains the value for "
"the core CPU PMU, which is usually 4."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:343
#, no-wrap
msgid "B<kprobe> and B<uprobe> (since Linux 4.17)"
msgstr ""

#.  commit 65074d43fc77bcae32776724b7fa2696923c78e4
#.  commit e12f03d7031a977356e3d7b75a68c2185ff8d155
#.  commit 33ea4b24277b06dbc55d7f5772a46f029600255e
#. type: Plain text
#: man-pages/man2/perf_event_open.2:354
msgid ""
"These two dynamic PMUs create a kprobe/uprobe and attach it to the file "
"descriptor generated by perf_event_open.  The kprobe/uprobe will be "
"destroyed on the destruction of the file descriptor.  See fields "
"I<kprobe_func>, I<uprobe_path>, I<kprobe_addr>, and I<probe_offset> for more "
"details."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:355 man-pages/man2/perf_event_open.2:1835
#, no-wrap
msgid "I<size>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:364
msgid ""
"The size of the I<perf_event_attr> structure for forward/backward "
"compatibility.  Set this using I<sizeof(struct perf_event_attr)> to allow "
"the kernel to see the struct size at the time of compilation."
msgstr ""

#.  commit cb5d76999029ae7a517cb07dfa732c1b5a934fc2
#.  this was added much later when PERF_ATTR_SIZE_VER2 happened
#.  but the actual attr_size had increased in 2.6.33
#.  commit cb5d76999029ae7a517cb07dfa732c1b5a934fc2
#.  commit 1659d129ed014b715b0b2120e6fd929bdd33ed03
#.  commit 60e2364e60e86e81bc6377f49779779e6120977f
#.  commit 1a5941312414c71dece6717da9a0fa1303127afa
#. type: Plain text
#: man-pages/man2/perf_event_open.2:394
msgid ""
"The related define B<PERF_ATTR_SIZE_VER0> is set to 64; this was the size of "
"the first published struct.  B<PERF_ATTR_SIZE_VER1> is 72, corresponding to "
"the addition of breakpoints in Linux 2.6.33.  B<PERF_ATTR_SIZE_VER2> is 80 "
"corresponding to the addition of branch sampling in Linux 3.4.  "
"B<PERF_ATTR_SIZE_VER3> is 96 corresponding to the addition of "
"I<sample_regs_user> and I<sample_stack_user> in Linux 3.7.  "
"B<PERF_ATTR_SIZE_VER4> is 104 corresponding to the addition of "
"I<sample_regs_intr> in Linux 3.19.  B<PERF_ATTR_SIZE_VER5> is 112 "
"corresponding to the addition of I<aux_watermark> in Linux 4.1."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:394
#, no-wrap
msgid "I<config>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:405
msgid ""
"This specifies which event you want, in conjunction with the I<type> field.  "
"The I<config1> and I<config2> fields are also taken into account in cases "
"where 64 bits is not enough to fully specify the event.  The encoding of "
"these fields are event dependent."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:416
msgid ""
"There are various ways to set the I<config> field that are dependent on the "
"value of the previously described I<type> field.  What follows are various "
"possible settings for I<config> separated out by I<type>."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:426
msgid ""
"If I<type> is B<PERF_TYPE_HARDWARE>, we are measuring one of the generalized "
"hardware CPU events.  Not all of these are available on all platforms.  Set "
"I<config> to one of the following:"
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:427
#, no-wrap
msgid "B<PERF_COUNT_HW_CPU_CYCLES>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:431
msgid "Total cycles.  Be wary of what happens during CPU frequency scaling."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:431
#, no-wrap
msgid "B<PERF_COUNT_HW_INSTRUCTIONS>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:436
msgid ""
"Retired instructions.  Be careful, these can be affected by various issues, "
"most notably hardware interrupt counts."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:436
#, no-wrap
msgid "B<PERF_COUNT_HW_CACHE_REFERENCES>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:443
msgid ""
"Cache accesses.  Usually this indicates Last Level Cache accesses but this "
"may vary depending on your CPU.  This may include prefetches and coherency "
"messages; again this depends on the design of your CPU."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:443
#, no-wrap
msgid "B<PERF_COUNT_HW_CACHE_MISSES>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:450
msgid ""
"Cache misses.  Usually this indicates Last Level Cache misses; this is "
"intended to be used in conjunction with the "
"B<PERF_COUNT_HW_CACHE_REFERENCES> event to calculate cache miss rates."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:450
#, no-wrap
msgid "B<PERF_COUNT_HW_BRANCH_INSTRUCTIONS>"
msgstr ""

#.  commit f287d332ce835f77a4f5077d2c0ef1e3f9ea42d2
#. type: Plain text
#: man-pages/man2/perf_event_open.2:456
msgid ""
"Retired branch instructions.  Prior to Linux 2.6.35, this used the wrong "
"event on AMD processors."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:456
#, no-wrap
msgid "B<PERF_COUNT_HW_BRANCH_MISSES>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:459
msgid "Mispredicted branch instructions."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:459
#, no-wrap
msgid "B<PERF_COUNT_HW_BUS_CYCLES>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:462
msgid "Bus cycles, which can be different from total cycles."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:462
#, no-wrap
msgid "B<PERF_COUNT_HW_STALLED_CYCLES_FRONTEND> (since Linux 3.0)"
msgstr ""

#.  commit 8f62242246351b5a4bc0c1f00c0c7003edea128a
#. type: Plain text
#: man-pages/man2/perf_event_open.2:466
msgid "Stalled cycles during issue."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:466
#, no-wrap
msgid "B<PERF_COUNT_HW_STALLED_CYCLES_BACKEND> (since Linux 3.0)"
msgstr ""

#.  commit 8f62242246351b5a4bc0c1f00c0c7003edea128a
#. type: Plain text
#: man-pages/man2/perf_event_open.2:470
msgid "Stalled cycles during retirement."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:470
#, no-wrap
msgid "B<PERF_COUNT_HW_REF_CPU_CYCLES> (since Linux 3.3)"
msgstr ""

#.  commit c37e17497e01fc0f5d2d6feb5723b210b3ab8890
#. type: Plain text
#: man-pages/man2/perf_event_open.2:474
msgid "Total cycles; not affected by CPU frequency scaling."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:484
msgid ""
"If I<type> is B<PERF_TYPE_SOFTWARE>, we are measuring software events "
"provided by the kernel.  Set I<config> to one of the following:"
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:485
#, no-wrap
msgid "B<PERF_COUNT_SW_CPU_CLOCK>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:488
msgid "This reports the CPU clock, a high-resolution per-CPU timer."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:488
#, no-wrap
msgid "B<PERF_COUNT_SW_TASK_CLOCK>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:491
msgid "This reports a clock count specific to the task that is running."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:491
#, no-wrap
msgid "B<PERF_COUNT_SW_PAGE_FAULTS>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:494
msgid "This reports the number of page faults."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:494
#, no-wrap
msgid "B<PERF_COUNT_SW_CONTEXT_SWITCHES>"
msgstr ""

#.  commit e49a5bd38159dfb1928fd25b173bc9de4bbadb21
#. type: Plain text
#: man-pages/man2/perf_event_open.2:500
msgid ""
"This counts context switches.  Until Linux 2.6.34, these were all reported "
"as user-space events, after that they are reported as happening in the "
"kernel."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:500
#, no-wrap
msgid "B<PERF_COUNT_SW_CPU_MIGRATIONS>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:504
msgid "This reports the number of times the process has migrated to a new CPU."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:504
#, no-wrap
msgid "B<PERF_COUNT_SW_PAGE_FAULTS_MIN>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:508
msgid ""
"This counts the number of minor page faults.  These did not require disk I/O "
"to handle."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:508
#, no-wrap
msgid "B<PERF_COUNT_SW_PAGE_FAULTS_MAJ>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:512
msgid ""
"This counts the number of major page faults.  These required disk I/O to "
"handle."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:512
#, no-wrap
msgid "B<PERF_COUNT_SW_ALIGNMENT_FAULTS> (since Linux 2.6.33)"
msgstr ""

#.  commit f7d7986060b2890fc26db6ab5203efbd33aa2497
#. type: Plain text
#: man-pages/man2/perf_event_open.2:519
msgid ""
"This counts the number of alignment faults.  These happen when unaligned "
"memory accesses happen; the kernel can handle these but it reduces "
"performance.  This happens only on some architectures (never on x86)."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:519
#, no-wrap
msgid "B<PERF_COUNT_SW_EMULATION_FAULTS> (since Linux 2.6.33)"
msgstr ""

#.  commit f7d7986060b2890fc26db6ab5203efbd33aa2497
#. type: Plain text
#: man-pages/man2/perf_event_open.2:526
msgid ""
"This counts the number of emulation faults.  The kernel sometimes traps on "
"unimplemented instructions and emulates them for user space.  This can "
"negatively impact performance."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:526
#, no-wrap
msgid "B<PERF_COUNT_SW_DUMMY> (since Linux 3.12)"
msgstr ""

#.  commit fa0097ee690693006ab1aea6c01ad3c851b65c77
#. type: Plain text
#: man-pages/man2/perf_event_open.2:534
msgid ""
"This is a placeholder event that counts nothing.  Informational sample "
"record types such as mmap or comm must be associated with an active event.  "
"This dummy event allows gathering such records without requiring a counting "
"event."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:547
msgid ""
"If I<type> is B<PERF_TYPE_TRACEPOINT>, then we are measuring kernel "
"tracepoints.  The value to use in I<config> can be obtained from under "
"debugfs I<tracing/events/*/*/id> if ftrace is enabled in the kernel."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:558
msgid ""
"If I<type> is B<PERF_TYPE_HW_CACHE>, then we are measuring a hardware CPU "
"cache event.  To calculate the appropriate I<config> value use the following "
"equation:"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:563
#, no-wrap
msgid ""
"    (perf_hw_cache_id) | (perf_hw_cache_op_id E<lt>E<lt> 8) |\n"
"    (perf_hw_cache_op_result_id E<lt>E<lt> 16)\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:568
msgid "where I<perf_hw_cache_id> is one of:"
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:569
#, no-wrap
msgid "B<PERF_COUNT_HW_CACHE_L1D>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:572
msgid "for measuring Level 1 Data Cache"
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:572
#, no-wrap
msgid "B<PERF_COUNT_HW_CACHE_L1I>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:575
msgid "for measuring Level 1 Instruction Cache"
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:575
#, no-wrap
msgid "B<PERF_COUNT_HW_CACHE_LL>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:578
msgid "for measuring Last-Level Cache"
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:578
#, no-wrap
msgid "B<PERF_COUNT_HW_CACHE_DTLB>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:581
msgid "for measuring the Data TLB"
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:581
#, no-wrap
msgid "B<PERF_COUNT_HW_CACHE_ITLB>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:584
msgid "for measuring the Instruction TLB"
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:584
#, no-wrap
msgid "B<PERF_COUNT_HW_CACHE_BPU>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:587
msgid "for measuring the branch prediction unit"
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:587
#, no-wrap
msgid "B<PERF_COUNT_HW_CACHE_NODE> (since Linux 3.1)"
msgstr ""

#.  commit 89d6c0b5bdbb1927775584dcf532d98b3efe1477
#. type: Plain text
#: man-pages/man2/perf_event_open.2:591
msgid "for measuring local memory accesses"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:596
msgid "and I<perf_hw_cache_op_id> is one of:"
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:597
#, no-wrap
msgid "B<PERF_COUNT_HW_CACHE_OP_READ>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:600
msgid "for read accesses"
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:600
#, no-wrap
msgid "B<PERF_COUNT_HW_CACHE_OP_WRITE>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:603
msgid "for write accesses"
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:603
#, no-wrap
msgid "B<PERF_COUNT_HW_CACHE_OP_PREFETCH>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:606
msgid "for prefetch accesses"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:611
msgid "and I<perf_hw_cache_op_result_id> is one of:"
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:612
#, no-wrap
msgid "B<PERF_COUNT_HW_CACHE_RESULT_ACCESS>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:615
msgid "to measure accesses"
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:615
#, no-wrap
msgid "B<PERF_COUNT_HW_CACHE_RESULT_MISS>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:618
msgid "to measure misses"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:636
msgid ""
"If I<type> is B<PERF_TYPE_RAW>, then a custom \"raw\" I<config> value is "
"needed.  Most CPUs support events that are not covered by the "
"\"generalized\" events.  These are implementation defined; see your CPU "
"manual (for example the Intel Volume 3B documentation or the AMD BIOS and "
"Kernel Developer Guide).  The libpfm4 library can be used to translate from "
"the name in the architectural manuals to the raw hex value "
"B<perf_event_open>()  expects in this field."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:645
msgid ""
"If I<type> is B<PERF_TYPE_BREAKPOINT>, then leave I<config> set to zero.  "
"Its parameters are set in other places."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:662
msgid ""
"If I<type> is B<kprobe> or B<uprobe>, set I<retprobe> (bit 0 of I<config>, "
"see I</sys/bus/event_source/devices/[k,u]probe/format/retprobe>)  for "
"kretprobe/uretprobe.  See fields I<kprobe_func>, I<uprobe_path>, "
"I<kprobe_addr>, and I<probe_offset> for more details."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:663
#, no-wrap
msgid "I<kprobe_func>, I<uprobe_path>, I<kprobe_addr>, and I<probe_offset>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:686
msgid ""
"These fields describe the kprobe/uprobe for dynamic PMUs B<kprobe> and "
"B<uprobe>.  For B<kprobe>: use I<kprobe_func> and I<probe_offset>, or use "
"I<kprobe_addr> and leave I<kprobe_func> as NULL.  For B<uprobe>: use "
"I<uprobe_path> and I<probe_offset>."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:686
#, no-wrap
msgid "I<sample_period>, I<sample_freq>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:698
msgid ""
"A \"sampling\" event is one that generates an overflow notification every N "
"events, where N is given by I<sample_period>.  A sampling event has "
"I<sample_period> E<gt> 0.  When an overflow occurs, requested data is "
"recorded in the mmap buffer.  The I<sample_type> field controls what data is "
"recorded on each overflow."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:708
msgid ""
"I<sample_freq> can be used if you wish to use frequency rather than period.  "
"In this case, you set the I<freq> flag.  The kernel will adjust the sampling "
"period to try and achieve the desired rate.  The rate of adjustment is a "
"timer tick."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:708
#, no-wrap
msgid "I<sample_type>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:720
msgid ""
"The various bits in this field specify which values to include in the "
"sample.  They will be recorded in a ring-buffer, which is available to user "
"space using B<mmap>(2).  The order in which the values are saved in the "
"sample are documented in the MMAP Layout subsection below; it is not the "
"I<enum perf_event_sample_format> order."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:721
#, no-wrap
msgid "B<PERF_SAMPLE_IP>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:724
msgid "Records instruction pointer."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:724
#, no-wrap
msgid "B<PERF_SAMPLE_TID>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:727
msgid "Records the process and thread IDs."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:727
#, no-wrap
msgid "B<PERF_SAMPLE_TIME>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:730
msgid "Records a timestamp."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:730
#, no-wrap
msgid "B<PERF_SAMPLE_ADDR>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:733
msgid "Records an address, if applicable."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:733
#, no-wrap
msgid "B<PERF_SAMPLE_READ>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:736
msgid "Record counter values for all events in a group, not just the group leader."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:736
#, no-wrap
msgid "B<PERF_SAMPLE_CALLCHAIN>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:739
msgid "Records the callchain (stack backtrace)."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:739
#, no-wrap
msgid "B<PERF_SAMPLE_ID>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:742
msgid "Records a unique ID for the opened event's group leader."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:742
#, no-wrap
msgid "B<PERF_SAMPLE_CPU>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:745
msgid "Records CPU number."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:745
#, no-wrap
msgid "B<PERF_SAMPLE_PERIOD>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:748
msgid "Records the current sampling period."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:748
#, no-wrap
msgid "B<PERF_SAMPLE_STREAM_ID>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:756
msgid ""
"Records a unique ID for the opened event.  Unlike B<PERF_SAMPLE_ID> the "
"actual ID is returned, not the group leader.  This ID is the same as the one "
"returned by B<PERF_FORMAT_ID>."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:756
#, no-wrap
msgid "B<PERF_SAMPLE_RAW>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:760
msgid ""
"Records additional data, if applicable.  Usually returned by tracepoint "
"events."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:760
#, no-wrap
msgid "B<PERF_SAMPLE_BRANCH_STACK> (since Linux 3.4)"
msgstr ""

#.  commit bce38cd53e5ddba9cb6d708c4ef3d04a4016ec7e
#. type: Plain text
#: man-pages/man2/perf_event_open.2:766
msgid ""
"This provides a record of recent branches, as provided by CPU branch "
"sampling hardware (such as Intel Last Branch Record).  Not all hardware "
"supports this feature."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:770
msgid ""
"See the I<branch_sample_type> field for how to filter which branches are "
"reported."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:770
#, no-wrap
msgid "B<PERF_SAMPLE_REGS_USER> (since Linux 3.7)"
msgstr ""

#.  commit 4018994f3d8785275ef0e7391b75c3462c029e56
#. type: Plain text
#: man-pages/man2/perf_event_open.2:775
msgid ""
"Records the current user-level CPU register state (the values in the process "
"before the kernel was called)."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:775
#, no-wrap
msgid "B<PERF_SAMPLE_STACK_USER> (since Linux 3.7)"
msgstr ""

#.  commit c5ebcedb566ef17bda7b02686e0d658a7bb42ee7
#. type: Plain text
#: man-pages/man2/perf_event_open.2:779
msgid "Records the user level stack, allowing stack unwinding."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:779
#, no-wrap
msgid "B<PERF_SAMPLE_WEIGHT> (since Linux 3.10)"
msgstr ""

#.  commit c3feedf2aaf9ac8bad6f19f5d21e4ee0b4b87e9c
#. type: Plain text
#: man-pages/man2/perf_event_open.2:786
msgid ""
"Records a hardware provided weight value that expresses how costly the "
"sampled event was.  This allows the hardware to highlight expensive events "
"in a profile."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:786
#, no-wrap
msgid "B<PERF_SAMPLE_DATA_SRC> (since Linux 3.10)"
msgstr ""

#.  commit d6be9ad6c960f43800a6f118932bc8a5a4eadcd1
#. type: Plain text
#: man-pages/man2/perf_event_open.2:793
msgid ""
"Records the data source: where in the memory hierarchy the data associated "
"with the sampled instruction came from.  This is available only if the "
"underlying hardware supports this feature."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:793
#, no-wrap
msgid "B<PERF_SAMPLE_IDENTIFIER> (since Linux 3.12)"
msgstr ""

#.  commit ff3d527cebc1fa3707c617bfe9e74f53fcfb0955
#. type: Plain text
#: man-pages/man2/perf_event_open.2:801
msgid ""
"Places the B<SAMPLE_ID> value in a fixed position in the record, either at "
"the beginning (for sample events) or at the end (if a non-sample event)."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:813
msgid ""
"This was necessary because a sample stream may have records from various "
"different event sources with different I<sample_type> settings.  Parsing the "
"event stream properly was not possible because the format of the record was "
"needed to find B<SAMPLE_ID>, but the format could not be found without "
"knowing what event the sample belonged to (causing a circular dependency)."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:823
msgid ""
"The B<PERF_SAMPLE_IDENTIFIER> setting makes the event stream always parsable "
"by putting B<SAMPLE_ID> in a fixed location, even though it means having "
"duplicate B<SAMPLE_ID> values in records."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:823
#, no-wrap
msgid "B<PERF_SAMPLE_TRANSACTION> (since Linux 3.13)"
msgstr ""

#.  commit fdfbbd07e91f8fe387140776f3fd94605f0c89e5
#. type: Plain text
#: man-pages/man2/perf_event_open.2:828
msgid ""
"Records reasons for transactional memory abort events (for example, from "
"Intel TSX transactional memory support)."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:836
msgid ""
"The I<precise_ip> setting must be greater than 0 and a transactional memory "
"abort event must be measured or no values will be recorded.  Also note that "
"some perf_event measurements, such as sampled cycle counting, may cause "
"extraneous aborts (by causing an interrupt during a transaction)."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:836
#, no-wrap
msgid "B<PERF_SAMPLE_REGS_INTR> (since Linux 3.19)"
msgstr ""

#.  commit 60e2364e60e86e81bc6377f49779779e6120977f
#. type: Plain text
#: man-pages/man2/perf_event_open.2:854
msgid ""
"Records a subset of the current CPU register state as specified by "
"I<sample_regs_intr>.  Unlike B<PERF_SAMPLE_REGS_USER> the register values "
"will return kernel register state if the overflow happened while kernel code "
"is running.  If the CPU supports hardware sampling of register state (i.e., "
"PEBS on Intel x86) and I<precise_ip> is set higher than zero then the "
"register values returned are those captured by hardware at the time of the "
"sampled instruction's retirement."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:855
#, no-wrap
msgid "I<read_format>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:862
msgid ""
"This field specifies the format of the data returned by B<read>(2)  on a "
"B<perf_event_open>()  file descriptor."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:863
#, no-wrap
msgid "B<PERF_FORMAT_TOTAL_TIME_ENABLED>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:870
msgid ""
"Adds the 64-bit I<time_enabled> field.  This can be used to calculate "
"estimated totals if the PMU is overcommitted and multiplexing is happening."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:870
#, no-wrap
msgid "B<PERF_FORMAT_TOTAL_TIME_RUNNING>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:877
msgid ""
"Adds the 64-bit I<time_running> field.  This can be used to calculate "
"estimated totals if the PMU is overcommitted and multiplexing is happening."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:877
#, no-wrap
msgid "B<PERF_FORMAT_ID>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:880
msgid "Adds a 64-bit unique value that corresponds to the event group."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:880
#, no-wrap
msgid "B<PERF_FORMAT_GROUP>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:883
msgid "Allows all counter values in an event group to be read with one read."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:884
#, no-wrap
msgid "I<disabled>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:894
msgid ""
"The I<disabled> bit specifies whether the counter starts out disabled or "
"enabled.  If disabled, the event can later be enabled by B<ioctl>(2), "
"B<prctl>(2), or I<enable_on_exec>."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:905
msgid ""
"When creating an event group, typically the group leader is initialized with "
"I<disabled> set to 1 and any child events are initialized with I<disabled> "
"set to 0.  Despite I<disabled> being 0, the child events will not start "
"until the group leader is enabled."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:905
#, no-wrap
msgid "I<inherit>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:914
msgid ""
"The I<inherit> bit specifies that this counter should count events of child "
"tasks as well as the task specified.  This applies only to new children, not "
"to any existing children at the time the counter is created (nor to any new "
"children of existing children)."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:919
msgid ""
"Inherit does not work for some combinations of I<read_format> values, such "
"as B<PERF_FORMAT_GROUP>."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:919
#, no-wrap
msgid "I<pinned>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:932
msgid ""
"The I<pinned> bit specifies that the counter should always be on the CPU if "
"at all possible.  It applies only to hardware counters and only to group "
"leaders.  If a pinned counter cannot be put onto the CPU (e.g., because "
"there are not enough hardware counters or because of a conflict with some "
"other event), then the counter goes into an 'error' state, where reads "
"return end-of-file (i.e., B<read>(2)  returns 0) until the counter is "
"subsequently enabled or disabled."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:932
#, no-wrap
msgid "I<exclusive>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:941
msgid ""
"The I<exclusive> bit specifies that when this counter's group is on the CPU, "
"it should be the only group using the CPU's counters.  In the future this "
"may allow monitoring programs to support PMU features that need to run alone "
"so that they do not disrupt other hardware counters."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:948
msgid ""
"Note that many unexpected situations may prevent events with the "
"I<exclusive> bit set from ever running.  This includes any users running a "
"system-wide measurement as well as any kernel use of the performance "
"counters (including the commonly enabled NMI Watchdog Timer interface)."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:948
#, no-wrap
msgid "I<exclude_user>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:951
msgid "If this bit is set, the count excludes events that happen in user space."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:951
#, no-wrap
msgid "I<exclude_kernel>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:954
msgid "If this bit is set, the count excludes events that happen in kernel space."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:954
#, no-wrap
msgid "I<exclude_hv>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:962
msgid ""
"If this bit is set, the count excludes events that happen in the "
"hypervisor.  This is mainly for PMUs that have built-in support for handling "
"this (such as POWER).  Extra support is needed for handling hypervisor "
"measurements on most machines."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:962
#, no-wrap
msgid "I<exclude_idle>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:967
msgid ""
"If set, don't count when the CPU is running the idle task.  While you can "
"currently enable this for any event type, it is ignored for all but software "
"events."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:967
#, no-wrap
msgid "I<mmap>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:981
msgid ""
"The I<mmap> bit enables generation of B<PERF_RECORD_MMAP> samples for every "
"B<mmap>(2)  call that has B<PROT_EXEC> set.  This allows tools to notice new "
"executable code being mapped into a program (dynamic shared libraries for "
"example)  so that addresses can be mapped back to the original code."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:981 man-pages/man2/perf_event_open.2:2014
#, no-wrap
msgid "I<comm>"
msgstr ""

#.  commit 82b897782d10fcc4930c9d4a15b175348fdd2871
#. type: Plain text
#: man-pages/man2/perf_event_open.2:1000
msgid ""
"The I<comm> bit enables tracking of process command name as modified by the "
"B<exec>(2)  and B<prctl>(PR_SET_NAME)  system calls as well as writing to "
"I</proc/self/comm>.  If the I<comm_exec> flag is also successfully set "
"(possible since Linux 3.16), then the misc flag "
"B<PERF_RECORD_MISC_COMM_EXEC> can be used to differentiate the B<exec>(2)  "
"case from the others."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1000
#, no-wrap
msgid "I<freq>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1007
msgid ""
"If this bit is set, then I<sample_frequency> not I<sample_period> is used "
"when setting up the sampling interval."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1007
#, no-wrap
msgid "I<inherit_stat>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1014
msgid ""
"This bit enables saving of event counts on context switch for inherited "
"tasks.  This is meaningful only if the I<inherit> field is set."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1014
#, no-wrap
msgid "I<enable_on_exec>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1019
msgid ""
"If this bit is set, a counter is automatically enabled after a call to "
"B<exec>(2)."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1019
#, no-wrap
msgid "I<task>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1023
msgid ""
"If this bit is set, then fork/exit notifications are included in the ring "
"buffer."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1023
#, no-wrap
msgid "I<watermark>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1031
msgid ""
"If set, have an overflow notification happen when we cross the "
"I<wakeup_watermark> boundary.  Otherwise, overflow notifications happen "
"after I<wakeup_events> samples."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1031
#, no-wrap
msgid "I<precise_ip> (since Linux 2.6.35)"
msgstr ""

#.  commit ab608344bcbde4f55ec4cd911b686b0ce3eae076
#. type: Plain text
#: man-pages/man2/perf_event_open.2:1042
msgid ""
"This controls the amount of skid.  Skid is how many instructions execute "
"between an event of interest happening and the kernel being able to stop and "
"record the event.  Smaller skid is better and allows more accurate reporting "
"of which events correspond to which instructions, but hardware is often "
"limited with how small this can be."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1044
msgid "The possible values of this field are the following:"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1048
msgid "B<SAMPLE_IP> can have arbitrary skid."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1051
msgid "B<SAMPLE_IP> must have constant skid."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1054
msgid "B<SAMPLE_IP> requested to have 0 skid."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1059
msgid ""
"B<SAMPLE_IP> must have 0 skid.  See also the description of "
"B<PERF_RECORD_MISC_EXACT_IP>."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1060
#, no-wrap
msgid "I<mmap_data> (since Linux 2.6.36)"
msgstr ""

#.  commit 3af9e859281bda7eb7c20b51879cf43aa788ac2e
#. type: Plain text
#: man-pages/man2/perf_event_open.2:1073
msgid ""
"This is the counterpart of the I<mmap> field.  This enables generation of "
"B<PERF_RECORD_MMAP> samples for B<mmap>(2)  calls that do not have "
"B<PROT_EXEC> set (for example data and SysV shared memory)."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1073
#, no-wrap
msgid "I<sample_id_all> (since Linux 2.6.38)"
msgstr ""

#.  commit c980d1091810df13f21aabbce545fd98f545bbf7
#. type: Plain text
#: man-pages/man2/perf_event_open.2:1082
msgid ""
"If set, then TID, TIME, ID, STREAM_ID, and CPU can additionally be included "
"in non-B<PERF_RECORD_SAMPLE>s if the corresponding I<sample_type> is "
"selected."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1090
msgid ""
"If B<PERF_SAMPLE_IDENTIFIER> is specified, then an additional ID value is "
"included as the last value to ease parsing the record stream.  This may lead "
"to the I<id> value appearing twice."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1092
msgid "The layout is described by this pseudo-structure:"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1103
#, no-wrap
msgid ""
"struct sample_id {\n"
"    { u32 pid, tid; }   /* if PERF_SAMPLE_TID set */\n"
"    { u64 time;     }   /* if PERF_SAMPLE_TIME set */\n"
"    { u64 id;       }   /* if PERF_SAMPLE_ID set */\n"
"    { u64 stream_id;}   /* if PERF_SAMPLE_STREAM_ID set  */\n"
"    { u32 cpu, res; }   /* if PERF_SAMPLE_CPU set */\n"
"    { u64 id;       }   /* if PERF_SAMPLE_IDENTIFIER set */\n"
"};\n"
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1105
#, no-wrap
msgid "I<exclude_host> (since Linux 3.2)"
msgstr ""

#.  commit a240f76165e6255384d4bdb8139895fac7988799
#. type: Plain text
#: man-pages/man2/perf_event_open.2:1116
msgid ""
"When conducting measurements that include processes running VM instances "
"(i.e., have executed a B<KVM_RUN> B<ioctl>(2)), only measure events "
"happening inside a guest instance.  This is only meaningful outside the "
"guests; this setting does not change counts gathered inside of a guest.  "
"Currently, this functionality is x86 only."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1116
#, no-wrap
msgid "I<exclude_guest> (since Linux 3.2)"
msgstr ""

#.  commit a240f76165e6255384d4bdb8139895fac7988799
#. type: Plain text
#: man-pages/man2/perf_event_open.2:1127
msgid ""
"When conducting measurements that include processes running VM instances "
"(i.e., have executed a B<KVM_RUN> B<ioctl>(2)), do not measure events "
"happening inside guest instances.  This is only meaningful outside the "
"guests; this setting does not change counts gathered inside of a guest.  "
"Currently, this functionality is x86 only."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1127
#, no-wrap
msgid "I<exclude_callchain_kernel> (since Linux 3.7)"
msgstr ""

#.  commit d077526485d5c9b12fe85d0b2b3b7041e6bc5f91
#. type: Plain text
#: man-pages/man2/perf_event_open.2:1131
msgid "Do not include kernel callchains."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1131
#, no-wrap
msgid "I<exclude_callchain_user> (since Linux 3.7)"
msgstr ""

#.  commit d077526485d5c9b12fe85d0b2b3b7041e6bc5f91
#. type: Plain text
#: man-pages/man2/perf_event_open.2:1135
msgid "Do not include user callchains."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1135
#, no-wrap
msgid "I<mmap2> (since Linux 3.16)"
msgstr ""

#.  commit 13d7a2410fa637f450a29ecb515ac318ee40c741
#.  This is tricky; was committed during 3.12 development
#.  but right before release was disabled.
#.  So while you could select mmap2 starting with 3.12
#.  it did not work until 3.16
#.  commit a5a5ba72843dd05f991184d6cb9a4471acce1005
#. type: Plain text
#: man-pages/man2/perf_event_open.2:1148
msgid ""
"Generate an extended executable mmap record that contains enough additional "
"information to uniquely identify shared mappings.  The I<mmap> flag must "
"also be set for this to work."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1148
#, no-wrap
msgid "I<comm_exec> (since Linux 3.16)"
msgstr ""

#.  commit 82b897782d10fcc4930c9d4a15b175348fdd2871
#. type: Plain text
#: man-pages/man2/perf_event_open.2:1164
msgid ""
"This is purely a feature-detection flag, it does not change kernel "
"behavior.  If this flag can successfully be set, then, when I<comm> is "
"enabled, the B<PERF_RECORD_MISC_COMM_EXEC> flag will be set in the I<misc> "
"field of a comm record header if the rename event being reported was caused "
"by a call to B<exec>(2).  This allows tools to distinguish between the "
"various types of process renaming."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1164
#, no-wrap
msgid "I<use_clockid> (since Linux 4.1)"
msgstr ""

#.  commit 34f439278cef7b1177f8ce24f9fc81dfc6221d3b
#. type: Plain text
#: man-pages/man2/perf_event_open.2:1173
msgid ""
"This allows selecting which internal Linux clock to use when generating "
"timestamps via the I<clockid> field.  This can make it easier to correlate "
"perf sample times with timestamps generated by other tools."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1173
#, no-wrap
msgid "I<context_switch> (since Linux 4.3)"
msgstr ""

#.  commit 45ac1403f564f411c6a383a2448688ba8dd705a4
#. type: Plain text
#: man-pages/man2/perf_event_open.2:1188
msgid ""
"This enables the generation of B<PERF_RECORD_SWITCH> records when a context "
"switch occurs.  It also enables the generation of "
"B<PERF_RECORD_SWITCH_CPU_WIDE> records when sampling in CPU-wide mode.  This "
"functionality is in addition to existing tracepoint and software events for "
"measuring context switches.  The advantage of this method is that it will "
"give full information even with strict I<perf_event_paranoid> settings."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1188
#, no-wrap
msgid "I<wakeup_events>, I<wakeup_watermark>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1198
msgid ""
"This union sets how many samples (I<wakeup_events>)  or bytes "
"(I<wakeup_watermark>)  happen before an overflow notification happens.  "
"Which one is used is selected by the I<watermark> bit flag."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1208
msgid ""
"I<wakeup_events> counts only B<PERF_RECORD_SAMPLE> record types.  To receive "
"overflow notification for all B<PERF_RECORD> types choose watermark and set "
"I<wakeup_watermark> to 1."
msgstr ""

#.  commit f506b3dc0ec454a16d40cab9ee5d75435b39dc50
#. type: Plain text
#: man-pages/man2/perf_event_open.2:1214
msgid ""
"Prior to Linux 3.0, setting I<wakeup_events> to 0 resulted in no overflow "
"notifications; more recent kernels treat 0 the same as 1."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1214
#, no-wrap
msgid "I<bp_type> (since Linux 2.6.33)"
msgstr ""

#.  commit 24f1e32c60c45c89a997c73395b69c8af6f0a84e
#. type: Plain text
#: man-pages/man2/perf_event_open.2:1219
msgid "This chooses the breakpoint type.  It is one of:"
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1220
#, no-wrap
msgid "B<HW_BREAKPOINT_EMPTY>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1223
msgid "No breakpoint."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1223
#, no-wrap
msgid "B<HW_BREAKPOINT_R>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1226
msgid "Count when we read the memory location."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1226
#, no-wrap
msgid "B<HW_BREAKPOINT_W>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1229
msgid "Count when we write the memory location."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1229
#, no-wrap
msgid "B<HW_BREAKPOINT_RW>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1232
msgid "Count when we read or write the memory location."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1232
#, no-wrap
msgid "B<HW_BREAKPOINT_X>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1235
msgid "Count when we execute code at the memory location."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1244
msgid ""
"The values can be combined via a bitwise or, but the combination of "
"B<HW_BREAKPOINT_R> or B<HW_BREAKPOINT_W> with B<HW_BREAKPOINT_X> is not "
"allowed."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1245
#, no-wrap
msgid "I<bp_addr> (since Linux 2.6.33)"
msgstr ""

#.  commit 24f1e32c60c45c89a997c73395b69c8af6f0a84e
#. type: Plain text
#: man-pages/man2/perf_event_open.2:1252
msgid ""
"This is the address of the breakpoint.  For execution breakpoints, this is "
"the memory address of the instruction of interest; for read and write "
"breakpoints, it is the memory address of the memory location of interest."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1252
#, no-wrap
msgid "I<config1> (since Linux 2.6.39)"
msgstr ""

#.  commit a7e3ed1e470116c9d12c2f778431a481a6be8ab6
#. type: Plain text
#: man-pages/man2/perf_event_open.2:1260
msgid ""
"I<config1> is used for setting events that need an extra register or "
"otherwise do not fit in the regular config field.  Raw OFFCORE_EVENTS on "
"Nehalem/Westmere/SandyBridge use this field on Linux 3.3 and later kernels."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1260
#, no-wrap
msgid "I<bp_len> (since Linux 2.6.33)"
msgstr ""

#.  commit 24f1e32c60c45c89a997c73395b69c8af6f0a84e
#. type: Plain text
#: man-pages/man2/perf_event_open.2:1276
msgid ""
"I<bp_len> is the length of the breakpoint being measured if I<type> is "
"B<PERF_TYPE_BREAKPOINT>.  Options are B<HW_BREAKPOINT_LEN_1>, "
"B<HW_BREAKPOINT_LEN_2>, B<HW_BREAKPOINT_LEN_4>, and B<HW_BREAKPOINT_LEN_8>.  "
"For an execution breakpoint, set this to I<sizeof(long)>."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1276
#, no-wrap
msgid "I<config2> (since Linux 2.6.39)"
msgstr ""

#.  commit a7e3ed1e470116c9d12c2f778431a481a6be8ab6
#. type: Plain text
#: man-pages/man2/perf_event_open.2:1283
msgid "I<config2> is a further extension of the I<config1> field."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1283
#, no-wrap
msgid "I<branch_sample_type> (since Linux 3.4)"
msgstr ""

#.  commit bce38cd53e5ddba9cb6d708c4ef3d04a4016ec7e
#. type: Plain text
#: man-pages/man2/perf_event_open.2:1290
msgid ""
"If B<PERF_SAMPLE_BRANCH_STACK> is enabled, then this specifies what branches "
"to include in the branch record."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1296
msgid ""
"The first part of the value is the privilege level, which is a combination "
"of one of the values listed below.  If the user does not set privilege level "
"explicitly, the kernel will use the event's privilege level.  Event and "
"branch privilege levels do not have to match."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1297
#, no-wrap
msgid "B<PERF_SAMPLE_BRANCH_USER>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1300
msgid "Branch target is in user space."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1300
#, no-wrap
msgid "B<PERF_SAMPLE_BRANCH_KERNEL>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1303
msgid "Branch target is in kernel space."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1303
#, no-wrap
msgid "B<PERF_SAMPLE_BRANCH_HV>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1306
msgid "Branch target is in hypervisor."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1306
#, no-wrap
msgid "B<PERF_SAMPLE_BRANCH_PLM_ALL>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1309
msgid "A convenience value that is the three preceding values ORed together."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1312
msgid ""
"In addition to the privilege value, at least one or more of the following "
"bits must be set."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1312
#, no-wrap
msgid "B<PERF_SAMPLE_BRANCH_ANY>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1315
msgid "Any branch type."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1315
#, no-wrap
msgid "B<PERF_SAMPLE_BRANCH_ANY_CALL>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1318
msgid "Any call branch (includes direct calls, indirect calls, and far jumps)."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1318
#, no-wrap
msgid "B<PERF_SAMPLE_BRANCH_IND_CALL>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1321
msgid "Indirect calls."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1321
#, no-wrap
msgid "B<PERF_SAMPLE_BRANCH_CALL> (since Linux 4.4)"
msgstr ""

#.  commit c229bf9dc179d2023e185c0f705bdf68484c1e73
#. type: Plain text
#: man-pages/man2/perf_event_open.2:1325
msgid "Direct calls."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1325
#, no-wrap
msgid "B<PERF_SAMPLE_BRANCH_ANY_RETURN>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1328
msgid "Any return branch."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1328
#, no-wrap
msgid "B<PERF_SAMPLE_BRANCH_IND_JUMP> (since Linux 4.2)"
msgstr ""

#.  commit c9fdfa14c3792c0160849c484e83aa57afd80ccc
#. type: Plain text
#: man-pages/man2/perf_event_open.2:1332
msgid "Indirect jumps."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1332
#, no-wrap
msgid "B<PERF_SAMPLE_BRANCH_COND> (since Linux 3.16)"
msgstr ""

#.  commit bac52139f0b7ab31330e98fd87fc5a2664951050
#. type: Plain text
#: man-pages/man2/perf_event_open.2:1336
msgid "Conditional branches."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1336
#, no-wrap
msgid "B<PERF_SAMPLE_BRANCH_ABORT_TX> (since Linux 3.11)"
msgstr ""

#.  commit 135c5612c460f89657c4698fe2ea753f6f667963
#. type: Plain text
#: man-pages/man2/perf_event_open.2:1340
msgid "Transactional memory aborts."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1340
#, no-wrap
msgid "B<PERF_SAMPLE_BRANCH_IN_TX> (since Linux 3.11)"
msgstr ""

#.  commit 135c5612c460f89657c4698fe2ea753f6f667963
#. type: Plain text
#: man-pages/man2/perf_event_open.2:1344
msgid "Branch in transactional memory transaction."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1344
#, no-wrap
msgid "B<PERF_SAMPLE_BRANCH_NO_TX> (since Linux 3.11)"
msgstr ""

#.  commit 135c5612c460f89657c4698fe2ea753f6f667963
#.  commit 2c44b1936bb3b135a3fac8b3493394d42e51cf70
#. type: Plain text
#: man-pages/man2/perf_event_open.2:1353
msgid ""
"Branch not in transactional memory transaction.  "
"B<PERF_SAMPLE_BRANCH_CALL_STACK> (since Linux 4.1)  Branch is part of a "
"hardware-generated call stack.  This requires hardware support, currently "
"only found on Intel x86 Haswell or newer."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1354
#, no-wrap
msgid "I<sample_regs_user> (since Linux 3.7)"
msgstr ""

#.  commit 4018994f3d8785275ef0e7391b75c3462c029e56
#. type: Plain text
#: man-pages/man2/perf_event_open.2:1361
msgid ""
"This bit mask defines the set of user CPU registers to dump on samples.  The "
"layout of the register mask is architecture-specific and is described in the "
"kernel header file I<arch/ARCH/include/uapi/asm/perf_regs.h>."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1361
#, no-wrap
msgid "I<sample_stack_user> (since Linux 3.7)"
msgstr ""

#.  commit c5ebcedb566ef17bda7b02686e0d658a7bb42ee7
#. type: Plain text
#: man-pages/man2/perf_event_open.2:1367
msgid ""
"This defines the size of the user stack to dump if B<PERF_SAMPLE_STACK_USER> "
"is specified."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1367
#, no-wrap
msgid "I<clockid> (since Linux 4.1)"
msgstr ""

#.  commit 34f439278cef7b1177f8ce24f9fc81dfc6221d3b
#. type: Plain text
#: man-pages/man2/perf_event_open.2:1384
msgid ""
"If I<use_clockid> is set, then this field selects which internal Linux timer "
"to use for timestamps.  The available timers are defined in I<linux/time.h>, "
"with B<CLOCK_MONOTONIC>, B<CLOCK_MONOTONIC_RAW>, B<CLOCK_REALTIME>, "
"B<CLOCK_BOOTTIME>, and B<CLOCK_TAI> currently supported."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1384
#, no-wrap
msgid "I<aux_watermark> (since Linux 4.1)"
msgstr ""

#.  commit 1a5941312414c71dece6717da9a0fa1303127afa
#. type: Plain text
#: man-pages/man2/perf_event_open.2:1390
msgid ""
"This specifies how much data is required to trigger a B<PERF_RECORD_AUX> "
"sample."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1390
#, no-wrap
msgid "I<sample_max_stack> (since Linux 4.8)"
msgstr ""

#.  commit 97c79a38cd454602645f0470ffb444b3b75ce574
#. type: Plain text
#: man-pages/man2/perf_event_open.2:1399
msgid ""
"When I<sample_type> includes B<PERF_SAMPLE_CALLCHAIN>, this field specifies "
"how many stack frames to report when generating the callchain."
msgstr ""

#. type: SS
#: man-pages/man2/perf_event_open.2:1399
#, no-wrap
msgid "Reading results"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1409
msgid ""
"Once a B<perf_event_open>()  file descriptor has been opened, the values of "
"the events can be read from the file descriptor.  The values that are there "
"are specified by the I<read_format> field in the I<attr> structure at open "
"time."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1414
msgid ""
"If you attempt to read into a buffer that is not big enough to hold the "
"data, the error B<ENOSPC> results."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1416
msgid "Here is the layout of the data returned by a read:"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1420
msgid ""
"If B<PERF_FORMAT_GROUP> was specified to allow reading all events in a group "
"at once:"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1432
#, no-wrap
msgid ""
"struct read_format {\n"
"    u64 nr;            /* The number of events */\n"
"    u64 time_enabled;  /* if PERF_FORMAT_TOTAL_TIME_ENABLED */\n"
"    u64 time_running;  /* if PERF_FORMAT_TOTAL_TIME_RUNNING */\n"
"    struct {\n"
"        u64 value;     /* The value of the event */\n"
"        u64 id;        /* if PERF_FORMAT_ID */\n"
"    } values[nr];\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1440
msgid "If B<PERF_FORMAT_GROUP> was I<not> specified:"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1449
#, no-wrap
msgid ""
"struct read_format {\n"
"    u64 value;         /* The value of the event */\n"
"    u64 time_enabled;  /* if PERF_FORMAT_TOTAL_TIME_ENABLED */\n"
"    u64 time_running;  /* if PERF_FORMAT_TOTAL_TIME_RUNNING */\n"
"    u64 id;            /* if PERF_FORMAT_ID */\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1453
msgid "The values read are as follows:"
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1453
#, no-wrap
msgid "I<nr>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1459
msgid ""
"The number of events in this file descriptor.  Available only if "
"B<PERF_FORMAT_GROUP> was specified."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1459
#, no-wrap
msgid "I<time_enabled>, I<time_running>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1470
msgid ""
"Total time the event was enabled and running.  Normally these values are the "
"same.  Multiplexing happens if the number of events is more than the number "
"of available PMU counter slots.  In that case the events run only part of "
"the time and the I<time_enabled> and I<time running> values can be used to "
"scale an estimated value for the count."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1470
#, no-wrap
msgid "I<value>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1473
msgid "An unsigned 64-bit value containing the counter result."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1473 man-pages/man2/perf_event_open.2:1985
#: man-pages/man2/perf_event_open.2:2156
#, no-wrap
msgid "I<id>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1479
msgid ""
"A globally unique value for this particular event; only present if "
"B<PERF_FORMAT_ID> was specified in I<read_format>."
msgstr ""

#. type: SS
#: man-pages/man2/perf_event_open.2:1479
#, no-wrap
msgid "MMAP layout"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1489
msgid ""
"When using B<perf_event_open>()  in sampled mode, asynchronous events (like "
"counter overflow or B<PROT_EXEC> mmap tracking)  are logged into a "
"ring-buffer.  This ring-buffer is created and accessed through B<mmap>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1495
msgid ""
"The mmap size should be 1+2^n pages, where the first page is a metadata page "
"(I<struct perf_event_mmap_page>)  that contains various bits of information "
"such as where the ring-buffer head is."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1498
msgid ""
"Before kernel 2.6.39, there is a bug that means you must allocate an mmap "
"ring buffer when sampling even if you do not plan to access it."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1500
msgid "The structure of the first metadata mmap page is as follows:"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1534
#, no-wrap
msgid ""
"struct perf_event_mmap_page {\n"
"    __u32 version;        /* version number of this structure */\n"
"    __u32 compat_version; /* lowest version this is compat with */\n"
"    __u32 lock;           /* seqlock for synchronization */\n"
"    __u32 index;          /* hardware counter identifier */\n"
"    __s64 offset;         /* add to hardware counter value */\n"
"    __u64 time_enabled;   /* time event active */\n"
"    __u64 time_running;   /* time event on CPU */\n"
"    union {\n"
"        __u64   capabilities;\n"
"        struct {\n"
"            __u64 cap_usr_time / cap_usr_rdpmc / cap_bit0 : 1,\n"
"                  cap_bit0_is_deprecated : 1,\n"
"                  cap_user_rdpmc         : 1,\n"
"                  cap_user_time          : 1,\n"
"                  cap_user_time_zero     : 1,\n"
"        };\n"
"    };\n"
"    __u16 pmc_width;\n"
"    __u16 time_shift;\n"
"    __u32 time_mult;\n"
"    __u64 time_offset;\n"
"    __u64 __reserved[120];   /* Pad to 1 k */\n"
"    __u64 data_head;         /* head in the data section */\n"
"    __u64 data_tail;         /* user-space written tail */\n"
"    __u64 data_offset;       /* where the buffer starts */\n"
"    __u64 data_size;         /* data buffer size */\n"
"    __u64 aux_head;\n"
"    __u64 aux_tail;\n"
"    __u64 aux_offset;\n"
"    __u64 aux_size;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1536
#, no-wrap
msgid "}\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1542
msgid ""
"The following list describes the fields in the I<perf_event_mmap_page> "
"structure in more detail:"
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1542
#, no-wrap
msgid "I<version>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1545
msgid "Version number of this structure."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1545
#, no-wrap
msgid "I<compat_version>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1548
msgid "The lowest version this is compatible with."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1548
#, no-wrap
msgid "I<lock>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1551
msgid "A seqlock for synchronization."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1551
#, no-wrap
msgid "I<index>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1554
msgid "A unique hardware counter identifier."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1554
#, no-wrap
msgid "I<offset>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1559
msgid ""
"When using rdpmc for reads this offset value must be added to the one "
"returned by rdpmc to get the current total event count."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1559
#, no-wrap
msgid "I<time_enabled>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1562
msgid "Time the event was active."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1562
#, no-wrap
msgid "I<time_running>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1565
msgid "Time the event was running."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1565
#, no-wrap
msgid "I<cap_usr_time> / I<cap_usr_rdpmc> / I<cap_bit0> (since Linux 3.4)"
msgstr ""

#.  commit c7206205d00ab375839bd6c7ddb247d600693c09
#. type: Plain text
#: man-pages/man2/perf_event_open.2:1579
msgid ""
"There was a bug in the definition of I<cap_usr_time> and I<cap_usr_rdpmc> "
"from Linux 3.4 until Linux 3.11.  Both bits were defined to point to the "
"same location, so it was impossible to know if I<cap_usr_time> or "
"I<cap_usr_rdpmc> were actually set."
msgstr ""

#.  commit fa7315871046b9a4c48627905691dbde57e51033
#. type: Plain text
#: man-pages/man2/perf_event_open.2:1588
msgid ""
"Starting with Linux 3.12, these are renamed to I<cap_bit0> and you should "
"use the I<cap_user_time> and I<cap_user_rdpmc> fields instead."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1588
#, no-wrap
msgid "I<cap_bit0_is_deprecated> (since Linux 3.12)"
msgstr ""

#.  commit fa7315871046b9a4c48627905691dbde57e51033
#. type: Plain text
#: man-pages/man2/perf_event_open.2:1597
msgid ""
"If set, this bit indicates that the kernel supports the properly separated "
"I<cap_user_time> and I<cap_user_rdpmc> bits."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1604
msgid ""
"If not-set, it indicates an older kernel where I<cap_usr_time> and "
"I<cap_usr_rdpmc> map to the same bit and thus both features should be used "
"with caution."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1604
#, no-wrap
msgid "I<cap_user_rdpmc> (since Linux 3.12)"
msgstr ""

#.  commit fa7315871046b9a4c48627905691dbde57e51033
#. type: Plain text
#: man-pages/man2/perf_event_open.2:1610
msgid ""
"If the hardware supports user-space read of performance counters without "
"syscall (this is the \"rdpmc\" instruction on x86), then the following code "
"can be used to do a read:"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1616
#, no-wrap
msgid ""
"u32 seq, time_mult, time_shift, idx, width;\n"
"u64 count, enabled, running;\n"
"u64 cyc, time_offset;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1622
#, no-wrap
msgid ""
"do {\n"
"    seq = pc-E<gt>lock;\n"
"    barrier();\n"
"    enabled = pc-E<gt>time_enabled;\n"
"    running = pc-E<gt>time_running;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1629
#, no-wrap
msgid ""
"    if (pc-E<gt>cap_usr_time && enabled != running) {\n"
"        cyc = rdtsc();\n"
"        time_offset = pc-E<gt>time_offset;\n"
"        time_mult   = pc-E<gt>time_mult;\n"
"        time_shift  = pc-E<gt>time_shift;\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1632
#, no-wrap
msgid ""
"    idx = pc-E<gt>index;\n"
"    count = pc-E<gt>offset;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1637
#, no-wrap
msgid ""
"    if (pc-E<gt>cap_usr_rdpmc && idx) {\n"
"        width = pc-E<gt>pmc_width;\n"
"        count += rdpmc(idx - 1);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1640
#, no-wrap
msgid ""
"    barrier();\n"
"} while (pc-E<gt>lock != seq);\n"
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1642
#, no-wrap
msgid "I<cap_user_time> (since Linux 3.12)"
msgstr ""

#.  commit fa7315871046b9a4c48627905691dbde57e51033
#. type: Plain text
#: man-pages/man2/perf_event_open.2:1647
msgid ""
"This bit indicates the hardware has a constant, nonstop timestamp counter "
"(TSC on x86)."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1647
#, no-wrap
msgid "I<cap_user_time_zero> (since Linux 3.12)"
msgstr ""

#.  commit fa7315871046b9a4c48627905691dbde57e51033
#. type: Plain text
#: man-pages/man2/perf_event_open.2:1654
msgid ""
"Indicates the presence of I<time_zero> which allows mapping timestamp values "
"to the hardware clock."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1654
#, no-wrap
msgid "I<pmc_width>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1661
msgid ""
"If I<cap_usr_rdpmc>, this field provides the bit-width of the value read "
"using the rdpmc or equivalent instruction.  This can be used to sign extend "
"the result like:"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1667
#, no-wrap
msgid ""
"pmc E<lt>E<lt>= 64 - pmc_width;\n"
"pmc E<gt>E<gt>= 64 - pmc_width; // signed shift right\n"
"count += pmc;\n"
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1669
#, no-wrap
msgid "I<time_shift>, I<time_mult>, I<time_offset>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1678
msgid ""
"If I<cap_usr_time>, these fields can be used to compute the time delta since "
"I<time_enabled> (in nanoseconds) using rdtsc or similar."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1686
#, no-wrap
msgid ""
"    u64 quot, rem;\n"
"    u64 delta;\n"
"    quot = (cyc E<gt>E<gt> time_shift);\n"
"    rem = cyc & (((u64)1 E<lt>E<lt> time_shift) - 1);\n"
"    delta = time_offset + quot * time_mult +\n"
"            ((rem * time_mult) E<gt>E<gt> time_shift);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1698
msgid ""
"Where I<time_offset>, I<time_mult>, I<time_shift>, and I<cyc> are read in "
"the seqcount loop described above.  This delta can then be added to enabled "
"and possible running (if idx), improving the scaling:"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1706
#, no-wrap
msgid ""
"    enabled += delta;\n"
"    if (idx)\n"
"        running += delta;\n"
"    quot = count / running;\n"
"    rem  = count % running;\n"
"    count = quot * enabled + (rem * enabled) / running;\n"
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1707
#, no-wrap
msgid "I<time_zero> (since Linux 3.12)"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1716
msgid ""
"If I<cap_usr_time_zero> is set, then the hardware clock (the TSC timestamp "
"counter on x86)  can be calculated from the I<time_zero>, I<time_mult>, and "
"I<time_shift> values:"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1722
#, no-wrap
msgid ""
"    time = timestamp - time_zero;\n"
"    quot = time / time_mult;\n"
"    rem  = time % time_mult;\n"
"    cyc = (quot E<lt>E<lt> time_shift) + (rem E<lt>E<lt> time_shift) / "
"time_mult;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1725
msgid "And vice versa:"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1731
#, no-wrap
msgid ""
"    quot = cyc E<gt>E<gt> time_shift;\n"
"    rem  = cyc & (((u64)1 E<lt>E<lt> time_shift) - 1);\n"
"    timestamp = time_zero + quot * time_mult +\n"
"        ((rem * time_mult) E<gt>E<gt> time_shift);\n"
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1732
#, no-wrap
msgid "I<data_head>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1738
msgid ""
"This points to the head of the data section.  The value continuously "
"increases, it does not wrap.  The value needs to be manually wrapped by the "
"size of the mmap buffer before accessing the samples."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1743
msgid ""
"On SMP-capable platforms, after reading the I<data_head> value, user space "
"should issue an rmb()."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1743
#, no-wrap
msgid "I<data_tail>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1751
msgid ""
"When the mapping is B<PROT_WRITE>, the I<data_tail> value should be written "
"by user space to reflect the last read data.  In this case, the kernel will "
"not overwrite unread data."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1751
#, no-wrap
msgid "I<data_offset> (since Linux 4.1)"
msgstr ""

#.  commit e8c6deac69629c0cb97c3d3272f8631ef17f8f0f
#. type: Plain text
#: man-pages/man2/perf_event_open.2:1756
msgid ""
"Contains the offset of the location in the mmap buffer where perf sample "
"data begins."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1756
#, no-wrap
msgid "I<data_size> (since Linux 4.1)"
msgstr ""

#.  commit e8c6deac69629c0cb97c3d3272f8631ef17f8f0f
#. type: Plain text
#: man-pages/man2/perf_event_open.2:1761
msgid "Contains the size of the perf sample region within the mmap buffer."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1761
#, no-wrap
msgid "I<aux_head>, I<aux_tail>, I<aux_offset>, I<aux_size> (since Linux 4.1)"
msgstr ""

#.  commit 45bfb2e50471abbbfd83d40d28c986078b0d24ff
#. type: Plain text
#: man-pages/man2/perf_event_open.2:1768
msgid ""
"The AUX region allows mmaping a separate sample buffer for high-bandwidth "
"data streams (separate from the main perf sample buffer).  An example of a "
"high-bandwidth stream is instruction tracing support, as is found in newer "
"Intel processors."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1786
msgid ""
"To set up an AUX area, first I<aux_offset> needs to be set with an offset "
"greater than I<data_offset>+I<data_size> and I<aux_size> needs to be set to "
"the desired buffer size.  The desired offset and size must be page aligned, "
"and the size must be a power of two.  These values are then passed to mmap "
"in order to map the AUX buffer.  Pages in the AUX buffer are included as "
"part of the B<RLIMIT_MEMLOCK> resource limit (see B<setrlimit>(2)), and also "
"as part of the I<perf_event_mlock_kb> allowance."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1795
msgid ""
"By default, the AUX buffer will be truncated if it will not fit in the "
"available space in the ring buffer.  If the AUX buffer is mapped as a read "
"only buffer, then it will operate in ring buffer mode where old data will be "
"overwritten by new.  In overwrite mode, it might not be possible to infer "
"where the new data began, and it is the consumer's job to disable "
"measurement while reading to avoid possible data races."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1801
msgid ""
"The I<aux_head> and I<aux_tail> ring buffer pointers have the same behavior "
"and ordering rules as the previous described I<data_head> and I<data_tail>."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1803
msgid "The following 2^n ring-buffer pages have the layout described below."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1817
msgid ""
"If I<perf_event_attr.sample_id_all> is set, then all event types will have "
"the sample_type selected fields related to where/when (identity)  an event "
"took place (TID, TIME, ID, CPU, STREAM_ID) described in "
"B<PERF_RECORD_SAMPLE> below, it will be stashed just after the "
"I<perf_event_header> and the fields already present for the existing fields, "
"that is, at the end of the payload.  This allows a newer perf.data file to "
"be supported by older perf tools, with the new optional fields being "
"ignored."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1819
msgid "The mmap values start with a header:"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1827
#, no-wrap
msgid ""
"struct perf_event_header {\n"
"    __u32   type;\n"
"    __u16   misc;\n"
"    __u16   size;\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1835
msgid ""
"Below, we describe the I<perf_event_header> fields in more detail.  For ease "
"of reading, the fields with shorter descriptions are presented first."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1838
msgid "This indicates the size of the record."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1838
#, no-wrap
msgid "I<misc>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1843
msgid "The I<misc> field contains additional information about the sample."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1848
msgid ""
"The CPU mode can be determined from this value by masking with "
"B<PERF_RECORD_MISC_CPUMODE_MASK> and looking for one of the following (note "
"these are not bit masks, only one can be set at a time):"
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1849
#, no-wrap
msgid "B<PERF_RECORD_MISC_CPUMODE_UNKNOWN>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1852
msgid "Unknown CPU mode."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1852
#, no-wrap
msgid "B<PERF_RECORD_MISC_KERNEL>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1855
msgid "Sample happened in the kernel."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1855
#, no-wrap
msgid "B<PERF_RECORD_MISC_USER>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1858
msgid "Sample happened in user code."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1858
#, no-wrap
msgid "B<PERF_RECORD_MISC_HYPERVISOR>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1861
msgid "Sample happened in the hypervisor."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1861
#, no-wrap
msgid "B<PERF_RECORD_MISC_GUEST_KERNEL> (since Linux 2.6.35)"
msgstr ""

#.  commit 39447b386c846bbf1c56f6403c5282837486200f
#. type: Plain text
#: man-pages/man2/perf_event_open.2:1865
msgid "Sample happened in the guest kernel."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1865
#, no-wrap
msgid "B<PERF_RECORD_MISC_GUEST_USER  (since Linux 2.6.35)>"
msgstr ""

#.  commit 39447b386c846bbf1c56f6403c5282837486200f
#. type: Plain text
#: man-pages/man2/perf_event_open.2:1869
msgid "Sample happened in guest user code."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1874
msgid ""
"Since the following three statuses are generated by different record types, "
"they alias to the same bit:"
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1874
#, no-wrap
msgid "B<PERF_RECORD_MISC_MMAP_DATA> (since Linux 3.10)"
msgstr ""

#.  commit 2fe85427e3bf65d791700d065132772fc26e4d75
#. type: Plain text
#: man-pages/man2/perf_event_open.2:1879
msgid ""
"This is set when the mapping is not executable; otherwise the mapping is "
"executable."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1879
#, no-wrap
msgid "B<PERF_RECORD_MISC_COMM_EXEC> (since Linux 3.16)"
msgstr ""

#.  commit 82b897782d10fcc4930c9d4a15b175348fdd2871
#. type: Plain text
#: man-pages/man2/perf_event_open.2:1888
msgid ""
"This is set for a B<PERF_RECORD_COMM> record on kernels more recent than "
"Linux 3.16 if a process name change was caused by an B<exec>(2)  system "
"call."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1888
#, no-wrap
msgid "B<PERF_RECORD_MISC_SWITCH_OUT> (since Linux 4.3)"
msgstr ""

#.  commit 45ac1403f564f411c6a383a2448688ba8dd705a4
#. type: Plain text
#: man-pages/man2/perf_event_open.2:1898
msgid ""
"When a B<PERF_RECORD_SWITCH> or B<PERF_RECORD_SWITCH_CPU_WIDE> record is "
"generated, this bit indicates that the context switch is away from the "
"current process (instead of into the current process)."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1902
msgid "In addition, the following bits can be set:"
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1902
#, no-wrap
msgid "B<PERF_RECORD_MISC_EXACT_IP>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1910
msgid ""
"This indicates that the content of B<PERF_SAMPLE_IP> points to the actual "
"instruction that triggered the event.  See also "
"I<perf_event_attr.precise_ip>."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1910
#, no-wrap
msgid "B<PERF_RECORD_MISC_EXT_RESERVED> (since Linux 2.6.35)"
msgstr ""

#.  commit 1676b8a077c352085d52578fb4f29350b58b6e74
#. type: Plain text
#: man-pages/man2/perf_event_open.2:1914
msgid "This indicates there is extended data available (currently not used)."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1914
#, no-wrap
msgid "B<PERF_RECORD_MISC_PROC_MAP_PARSE_TIMEOUT>"
msgstr ""

#.  commit 930e6fcd2bcce9bcd9d4aa7e755678d33f3fe6f4
#. type: Plain text
#: man-pages/man2/perf_event_open.2:1922
msgid ""
"This bit is not set by the kernel.  It is reserved for the user-space perf "
"utility to indicate that I</proc/i[pid]/maps> parsing was taking too long "
"and was stopped, and thus the mmap records may be truncated."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1932
msgid ""
"The I<type> value is one of the below.  The values in the corresponding "
"record (that follows the header)  depend on the I<type> selected as shown."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1933
#, no-wrap
msgid "B<PERF_RECORD_MMAP>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1940
msgid ""
"The MMAP events record the B<PROT_EXEC> mappings so that we can correlate "
"user-space IPs to code.  They have the following structure:"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1951
#, no-wrap
msgid ""
"struct {\n"
"    struct perf_event_header header;\n"
"    u32    pid, tid;\n"
"    u64    addr;\n"
"    u64    len;\n"
"    u64    pgoff;\n"
"    char   filename[];\n"
"};\n"
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1954 man-pages/man2/perf_event_open.2:2008
#: man-pages/man2/perf_event_open.2:2566 man-pages/man2/perf_event_open.2:2656
#, no-wrap
msgid "I<pid>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1957 man-pages/man2/perf_event_open.2:2011
#: man-pages/man2/perf_event_open.2:2569
msgid "is the process ID."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1957 man-pages/man2/perf_event_open.2:2011
#: man-pages/man2/perf_event_open.2:2569 man-pages/man2/perf_event_open.2:2659
#, no-wrap
msgid "I<tid>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1960 man-pages/man2/perf_event_open.2:2014
#: man-pages/man2/perf_event_open.2:2572
msgid "is the thread ID."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1960 man-pages/man2/perf_event_open.2:2149
#: man-pages/man2/perf_event_open.2:2572
#, no-wrap
msgid "I<addr>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1969
msgid ""
"is the address of the allocated memory.  I<len> is the length of the "
"allocated memory.  I<pgoff> is the page offset of the allocated memory.  "
"I<filename> is a string describing the backing of the allocated memory."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1970
#, no-wrap
msgid "B<PERF_RECORD_LOST>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1973
msgid "This record indicates when events are lost."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1982
#, no-wrap
msgid ""
"struct {\n"
"    struct perf_event_header header;\n"
"    u64    id;\n"
"    u64    lost;\n"
"    struct sample_id sample_id;\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1988
msgid "is the unique event ID for the samples that were lost."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1988 man-pages/man2/perf_event_open.2:2678
#, no-wrap
msgid "I<lost>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1991
msgid "is the number of events that were lost."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:1992
#, no-wrap
msgid "B<PERF_RECORD_COMM>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:1995
msgid "This record indicates a change in the process name."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2005
#, no-wrap
msgid ""
"struct {\n"
"    struct perf_event_header header;\n"
"    u32    pid;\n"
"    u32    tid;\n"
"    char   comm[];\n"
"    struct sample_id sample_id;\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2017
msgid "is a string containing the new name of the process."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:2018
#, no-wrap
msgid "B<PERF_RECORD_EXIT>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2021
msgid "This record indicates a process exit event."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2031 man-pages/man2/perf_event_open.2:2061
#, no-wrap
msgid ""
"struct {\n"
"    struct perf_event_header header;\n"
"    u32    pid, ppid;\n"
"    u32    tid, ptid;\n"
"    u64    time;\n"
"    struct sample_id sample_id;\n"
"};\n"
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:2033
#, no-wrap
msgid "B<PERF_RECORD_THROTTLE>, B<PERF_RECORD_UNTHROTTLE>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2036
msgid "This record indicates a throttle/unthrottle event."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2046
#, no-wrap
msgid ""
"struct {\n"
"    struct perf_event_header header;\n"
"    u64    time;\n"
"    u64    id;\n"
"    u64    stream_id;\n"
"    struct sample_id sample_id;\n"
"};\n"
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:2048
#, no-wrap
msgid "B<PERF_RECORD_FORK>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2051
msgid "This record indicates a fork event."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:2063
#, no-wrap
msgid "B<PERF_RECORD_READ>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2066
msgid "This record indicates a read event."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2075
#, no-wrap
msgid ""
"struct {\n"
"    struct perf_event_header header;\n"
"    u32    pid, tid;\n"
"    struct read_format values;\n"
"    struct sample_id sample_id;\n"
"};\n"
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:2077
#, no-wrap
msgid "B<PERF_RECORD_SAMPLE>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2080
msgid "This record indicates a sample."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2117
#, no-wrap
msgid ""
"struct {\n"
"    struct perf_event_header header;\n"
"    u64    sample_id;   /* if PERF_SAMPLE_IDENTIFIER */\n"
"    u64    ip;          /* if PERF_SAMPLE_IP */\n"
"    u32    pid, tid;    /* if PERF_SAMPLE_TID */\n"
"    u64    time;        /* if PERF_SAMPLE_TIME */\n"
"    u64    addr;        /* if PERF_SAMPLE_ADDR */\n"
"    u64    id;          /* if PERF_SAMPLE_ID */\n"
"    u64    stream_id;   /* if PERF_SAMPLE_STREAM_ID */\n"
"    u32    cpu, res;    /* if PERF_SAMPLE_CPU */\n"
"    u64    period;      /* if PERF_SAMPLE_PERIOD */\n"
"    struct read_format v;\n"
"                        /* if PERF_SAMPLE_READ */\n"
"    u64    nr;          /* if PERF_SAMPLE_CALLCHAIN */\n"
"    u64    ips[nr];     /* if PERF_SAMPLE_CALLCHAIN */\n"
"    u32    size;        /* if PERF_SAMPLE_RAW */\n"
"    char  data[size];   /* if PERF_SAMPLE_RAW */\n"
"    u64    bnr;         /* if PERF_SAMPLE_BRANCH_STACK */\n"
"    struct perf_branch_entry lbr[bnr];\n"
"                        /* if PERF_SAMPLE_BRANCH_STACK */\n"
"    u64    abi;         /* if PERF_SAMPLE_REGS_USER */\n"
"    u64    regs[weight(mask)];\n"
"                        /* if PERF_SAMPLE_REGS_USER */\n"
"    u64    size;        /* if PERF_SAMPLE_STACK_USER */\n"
"    char   data[size];  /* if PERF_SAMPLE_STACK_USER */\n"
"    u64    dyn_size;    /* if PERF_SAMPLE_STACK_USER &&\n"
"                           size != 0 */\n"
"    u64    weight;      /* if PERF_SAMPLE_WEIGHT */\n"
"    u64    data_src;    /* if PERF_SAMPLE_DATA_SRC */\n"
"    u64    transaction; /* if PERF_SAMPLE_TRANSACTION */\n"
"    u64    abi;         /* if PERF_SAMPLE_REGS_INTR */\n"
"    u64    regs[weight(mask)];\n"
"                        /* if PERF_SAMPLE_REGS_INTR */\n"
"};\n"
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:2119
#, no-wrap
msgid "I<sample_id>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2129
msgid ""
"If B<PERF_SAMPLE_IDENTIFIER> is enabled, a 64-bit unique ID is included.  "
"This is a duplication of the B<PERF_SAMPLE_ID> I<id> value, but included at "
"the beginning of the sample so parsers can easily obtain the value."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:2129
#, no-wrap
msgid "I<ip>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2135
msgid ""
"If B<PERF_SAMPLE_IP> is enabled, then a 64-bit instruction pointer value is "
"included."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:2135
#, no-wrap
msgid "I<pid>, I<tid>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2141
msgid ""
"If B<PERF_SAMPLE_TID> is enabled, then a 32-bit process ID and 32-bit thread "
"ID are included."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:2141
#, no-wrap
msgid "I<time>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2149
msgid ""
"If B<PERF_SAMPLE_TIME> is enabled, then a 64-bit timestamp is included.  "
"This is obtained via local_clock() which is a hardware timestamp if "
"available and the jiffies value if not."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2156
msgid ""
"If B<PERF_SAMPLE_ADDR> is enabled, then a 64-bit address is included.  This "
"is usually the address of a tracepoint, breakpoint, or software event; "
"otherwise the value is 0."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2164
msgid ""
"If B<PERF_SAMPLE_ID> is enabled, a 64-bit unique ID is included.  If the "
"event is a member of an event group, the group leader ID is returned.  This "
"ID is the same as the one returned by B<PERF_FORMAT_ID>."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:2164
#, no-wrap
msgid "I<stream_id>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2174
msgid ""
"If B<PERF_SAMPLE_STREAM_ID> is enabled, a 64-bit unique ID is included.  "
"Unlike B<PERF_SAMPLE_ID> the actual ID is returned, not the group leader.  "
"This ID is the same as the one returned by B<PERF_FORMAT_ID>."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:2174
#, no-wrap
msgid "I<cpu>, I<res>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2181
msgid ""
"If B<PERF_SAMPLE_CPU> is enabled, this is a 32-bit value indicating which "
"CPU was being used, in addition to a reserved (unused)  32-bit value."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:2181
#, no-wrap
msgid "I<period>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2187
msgid ""
"If B<PERF_SAMPLE_PERIOD> is enabled, a 64-bit value indicating the current "
"sampling period is written."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:2187
#, no-wrap
msgid "I<v>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2198
msgid ""
"If B<PERF_SAMPLE_READ> is enabled, a structure of type read_format is "
"included which has values for all events in the event group.  The values "
"included depend on the I<read_format> value used at B<perf_event_open>()  "
"time."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:2198
#, no-wrap
msgid "I<nr>, I<ips[nr]>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2206
msgid ""
"If B<PERF_SAMPLE_CALLCHAIN> is enabled, then a 64-bit number is included "
"which indicates how many following 64-bit instruction pointers will follow.  "
"This is the current callchain."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:2206
#, no-wrap
msgid "I<size>, I<data[size]>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2213
msgid ""
"If B<PERF_SAMPLE_RAW> is enabled, then a 32-bit value indicating size is "
"included followed by an array of 8-bit values of length size.  The values "
"are padded with 0 to have 64-bit alignment."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2218
msgid ""
"This RAW record data is opaque with respect to the ABI.  The ABI doesn't "
"make any promises with respect to the stability of its content, it may vary "
"depending on event, hardware, and kernel version."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:2218
#, no-wrap
msgid "I<bnr>, I<lbr[bnr]>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2227
msgid ""
"If B<PERF_SAMPLE_BRANCH_STACK> is enabled, then a 64-bit value indicating "
"the number of records is included, followed by I<bnr> I<perf_branch_entry> "
"structures which each include the fields:"
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:2228
#, no-wrap
msgid "I<from>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2231
msgid "This indicates the source instruction (may not be a branch)."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:2231
#, no-wrap
msgid "I<to>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2234
msgid "The branch target."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:2234
#, no-wrap
msgid "I<mispred>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2237
msgid "The branch target was mispredicted."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:2237
#, no-wrap
msgid "I<predicted>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2240
msgid "The branch target was predicted."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:2240
#, no-wrap
msgid "I<in_tx> (since Linux 3.11)"
msgstr ""

#.  commit 135c5612c460f89657c4698fe2ea753f6f667963
#. type: Plain text
#: man-pages/man2/perf_event_open.2:2244
msgid "The branch was in a transactional memory transaction."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:2244
#, no-wrap
msgid "I<abort> (since Linux 3.11)"
msgstr ""

#.  commit 135c5612c460f89657c4698fe2ea753f6f667963
#. type: Plain text
#: man-pages/man2/perf_event_open.2:2248
msgid "The branch was in an aborted transactional memory transaction."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:2248
#, no-wrap
msgid "I<cycles> (since Linux 4.3)"
msgstr ""

#.  commit 71ef3c6b9d4665ee7afbbe4c208a98917dcfc32f
#. type: Plain text
#: man-pages/man2/perf_event_open.2:2253
msgid ""
"This reports the number of cycles elapsed since the previous branch stack "
"update."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2256
msgid ""
"The entries are from most to least recent, so the first entry has the most "
"recent branch."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2264
msgid ""
"Support for I<mispred>, I<predicted>, and I<cycles> is optional; if not "
"supported, those values will be 0."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2268
msgid ""
"The type of branches recorded is specified by the I<branch_sample_type> "
"field."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:2269 man-pages/man2/perf_event_open.2:2512
#, no-wrap
msgid "I<abi>, I<regs[weight(mask)]>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2274
msgid ""
"If B<PERF_SAMPLE_REGS_USER> is enabled, then the user CPU registers are "
"recorded."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2280
msgid ""
"The I<abi> field is one of B<PERF_SAMPLE_REGS_ABI_NONE>, "
"B<PERF_SAMPLE_REGS_ABI_32> or B<PERF_SAMPLE_REGS_ABI_64>."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2290
msgid ""
"The I<regs> field is an array of the CPU registers that were specified by "
"the I<sample_regs_user> attr field.  The number of values is the number of "
"bits set in the I<sample_regs_user> bit mask."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:2290
#, no-wrap
msgid "I<size>, I<data[size]>, I<dyn_size>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2311
msgid ""
"If B<PERF_SAMPLE_STACK_USER> is enabled, then the user stack is recorded.  "
"This can be used to generate stack backtraces.  I<size> is the size "
"requested by the user in I<sample_stack_user> or else the maximum record "
"size.  I<data> is the stack data (a raw dump of the memory pointed to by the "
"stack pointer at the time of sampling).  I<dyn_size> is the amount of data "
"actually dumped (can be less than I<size>).  Note that I<dyn_size> is "
"omitted if I<size> is 0."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:2311
#, no-wrap
msgid "I<weight>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2319
msgid ""
"If B<PERF_SAMPLE_WEIGHT> is enabled, then a 64-bit value provided by the "
"hardware is recorded that indicates how costly the event was.  This allows "
"expensive events to stand out more clearly in profiles."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:2319
#, no-wrap
msgid "I<data_src>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2325
msgid ""
"If B<PERF_SAMPLE_DATA_SRC> is enabled, then a 64-bit value is recorded that "
"is made up of the following fields:"
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:2326
#, no-wrap
msgid "I<mem_op>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2329
msgid "Type of opcode, a bitwise combination of:"
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:2332
#, no-wrap
msgid "B<PERF_MEM_OP_NA>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2335 man-pages/man2/perf_event_open.2:2360
#: man-pages/man2/perf_event_open.2:2411 man-pages/man2/perf_event_open.2:2435
#: man-pages/man2/perf_event_open.2:2451
msgid "Not available"
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:2335
#, no-wrap
msgid "B<PERF_MEM_OP_LOAD>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2338
msgid "Load instruction"
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:2338
#, no-wrap
msgid "B<PERF_MEM_OP_STORE>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2341
msgid "Store instruction"
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:2341
#, no-wrap
msgid "B<PERF_MEM_OP_PFETCH>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2344
msgid "Prefetch"
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:2344
#, no-wrap
msgid "B<PERF_MEM_OP_EXEC>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2347
msgid "Executable code"
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:2349
#, no-wrap
msgid "I<mem_lvl>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2354
msgid ""
"Memory hierarchy level hit or miss, a bitwise combination of the following, "
"shifted left by B<PERF_MEM_LVL_SHIFT>:"
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:2357
#, no-wrap
msgid "B<PERF_MEM_LVL_NA>"
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:2360
#, no-wrap
msgid "B<PERF_MEM_LVL_HIT>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2363 man-pages/man2/perf_event_open.2:2454
msgid "Hit"
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:2363
#, no-wrap
msgid "B<PERF_MEM_LVL_MISS>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2366 man-pages/man2/perf_event_open.2:2457
msgid "Miss"
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:2366
#, no-wrap
msgid "B<PERF_MEM_LVL_L1>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2369
msgid "Level 1 cache"
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:2369
#, no-wrap
msgid "B<PERF_MEM_LVL_LFB>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2372
msgid "Line fill buffer"
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:2372
#, no-wrap
msgid "B<PERF_MEM_LVL_L2>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2375
msgid "Level 2 cache"
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:2375
#, no-wrap
msgid "B<PERF_MEM_LVL_L3>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2378
msgid "Level 3 cache"
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:2378
#, no-wrap
msgid "B<PERF_MEM_LVL_LOC_RAM>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2381
msgid "Local DRAM"
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:2381
#, no-wrap
msgid "B<PERF_MEM_LVL_REM_RAM1>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2384
msgid "Remote DRAM 1 hop"
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:2384
#, no-wrap
msgid "B<PERF_MEM_LVL_REM_RAM2>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2387
msgid "Remote DRAM 2 hops"
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:2387
#, no-wrap
msgid "B<PERF_MEM_LVL_REM_CCE1>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2390
msgid "Remote cache 1 hop"
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:2390
#, no-wrap
msgid "B<PERF_MEM_LVL_REM_CCE2>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2393
msgid "Remote cache 2 hops"
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:2393
#, no-wrap
msgid "B<PERF_MEM_LVL_IO>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2396
msgid "I/O memory"
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:2396
#, no-wrap
msgid "B<PERF_MEM_LVL_UNC>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2399
msgid "Uncached memory"
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:2401
#, no-wrap
msgid "I<mem_snoop>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2405
msgid ""
"Snoop mode, a bitwise combination of the following, shifted left by "
"B<PERF_MEM_SNOOP_SHIFT>:"
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:2408
#, no-wrap
msgid "B<PERF_MEM_SNOOP_NA>"
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:2411
#, no-wrap
msgid "B<PERF_MEM_SNOOP_NONE>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2414
msgid "No snoop"
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:2414
#, no-wrap
msgid "B<PERF_MEM_SNOOP_HIT>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2417
msgid "Snoop hit"
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:2417
#, no-wrap
msgid "B<PERF_MEM_SNOOP_MISS>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2420
msgid "Snoop miss"
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:2420
#, no-wrap
msgid "B<PERF_MEM_SNOOP_HITM>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2423
msgid "Snoop hit modified"
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:2425
#, no-wrap
msgid "I<mem_lock>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2429
msgid ""
"Lock instruction, a bitwise combination of the following, shifted left by "
"B<PERF_MEM_LOCK_SHIFT>:"
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:2432
#, no-wrap
msgid "B<PERF_MEM_LOCK_NA>"
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:2435
#, no-wrap
msgid "B<PERF_MEM_LOCK_LOCKED>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2438
msgid "Locked transaction"
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:2440
#, no-wrap
msgid "I<mem_dtlb>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2445
msgid ""
"TLB access hit or miss, a bitwise combination of the following, shifted left "
"by B<PERF_MEM_TLB_SHIFT>:"
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:2448
#, no-wrap
msgid "B<PERF_MEM_TLB_NA>"
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:2451
#, no-wrap
msgid "B<PERF_MEM_TLB_HIT>"
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:2454
#, no-wrap
msgid "B<PERF_MEM_TLB_MISS>"
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:2457
#, no-wrap
msgid "B<PERF_MEM_TLB_L1>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2460
msgid "Level 1 TLB"
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:2460
#, no-wrap
msgid "B<PERF_MEM_TLB_L2>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2463
msgid "Level 2 TLB"
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:2463
#, no-wrap
msgid "B<PERF_MEM_TLB_WK>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2466
msgid "Hardware walker"
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:2466
#, no-wrap
msgid "B<PERF_MEM_TLB_OS>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2469
msgid "OS fault handler"
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:2472
#, no-wrap
msgid "I<transaction>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2478
msgid ""
"If the B<PERF_SAMPLE_TRANSACTION> flag is set, then a 64-bit field is "
"recorded describing the sources of any transactional memory aborts."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2480
msgid "The field is a bitwise combination of the following values:"
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:2481
#, no-wrap
msgid "B<PERF_TXN_ELISION>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2484
msgid "Abort from an elision type transaction (Intel-CPU-specific)."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:2484
#, no-wrap
msgid "B<PERF_TXN_TRANSACTION>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2487
msgid "Abort from a generic transaction."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:2487
#, no-wrap
msgid "B<PERF_TXN_SYNC>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2490
msgid "Synchronous abort (related to the reported instruction)."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:2490
#, no-wrap
msgid "B<PERF_TXN_ASYNC>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2493
msgid "Asynchronous abort (not related to the reported instruction)."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:2493
#, no-wrap
msgid "B<PERF_TXN_RETRY>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2496
msgid "Retryable abort (retrying the transaction may have succeeded)."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:2496
#, no-wrap
msgid "B<PERF_TXN_CONFLICT>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2499
msgid "Abort due to memory conflicts with other threads."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:2499
#, no-wrap
msgid "B<PERF_TXN_CAPACITY_WRITE>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2502
msgid "Abort due to write capacity overflow."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:2502
#, no-wrap
msgid "B<PERF_TXN_CAPACITY_READ>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2505
msgid "Abort due to read capacity overflow."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2512
msgid ""
"In addition, a user-specified abort code can be obtained from the high 32 "
"bits of the field by shifting right by B<PERF_TXN_ABORT_SHIFT> and masking "
"with the value B<PERF_TXN_ABORT_MASK>."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2517
msgid ""
"If B<PERF_SAMPLE_REGS_INTR> is enabled, then the user CPU registers are "
"recorded."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2525
msgid ""
"The I<abi> field is one of B<PERF_SAMPLE_REGS_ABI_NONE>, "
"B<PERF_SAMPLE_REGS_ABI_32>, or B<PERF_SAMPLE_REGS_ABI_64>."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2535
msgid ""
"The I<regs> field is an array of the CPU registers that were specified by "
"the I<sample_regs_intr> attr field.  The number of values is the number of "
"bits set in the I<sample_regs_intr> bit mask."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:2536
#, no-wrap
msgid "B<PERF_RECORD_MMAP2>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2545
msgid ""
"This record includes extended information on B<mmap>(2)  calls returning "
"executable mappings.  The format is similar to that of the "
"B<PERF_RECORD_MMAP> record, but includes extra values that allow uniquely "
"identifying shared mappings."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2564
#, no-wrap
msgid ""
"struct {\n"
"    struct perf_event_header header;\n"
"    u32    pid;\n"
"    u32    tid;\n"
"    u64    addr;\n"
"    u64    len;\n"
"    u64    pgoff;\n"
"    u32    maj;\n"
"    u32    min;\n"
"    u64    ino;\n"
"    u64    ino_generation;\n"
"    u32    prot;\n"
"    u32    flags;\n"
"    char   filename[];\n"
"    struct sample_id sample_id;\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2575
msgid "is the address of the allocated memory."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:2575
#, no-wrap
msgid "I<len>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2578
msgid "is the length of the allocated memory."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:2578
#, no-wrap
msgid "I<pgoff>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2581
msgid "is the page offset of the allocated memory."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:2581
#, no-wrap
msgid "I<maj>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2584
msgid "is the major ID of the underlying device."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:2584
#, no-wrap
msgid "I<min>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2587
msgid "is the minor ID of the underlying device."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:2587
#, no-wrap
msgid "I<ino>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2590
msgid "is the inode number."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:2590
#, no-wrap
msgid "I<ino_generation>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2593
msgid "is the inode generation."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:2593
#, no-wrap
msgid "I<prot>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2596
msgid "is the protection information."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:2596 man-pages/man2/perf_event_open.2:2626
#, no-wrap
msgid "I<flags>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2599
msgid "is the flags information."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:2599
#, no-wrap
msgid "I<filename>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2602
msgid "is a string describing the backing of the allocated memory."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:2603
#, no-wrap
msgid "B<PERF_RECORD_AUX> (since Linux 4.1)"
msgstr ""

#.  commit 68db7e98c3a6ebe7284b6cf14906ed7c55f3f7f0
#. type: Plain text
#: man-pages/man2/perf_event_open.2:2608
msgid ""
"This record reports that new data is available in the separate AUX buffer "
"region."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2618
#, no-wrap
msgid ""
"struct {\n"
"    struct perf_event_header header;\n"
"    u64    aux_offset;\n"
"    u64    aux_size;\n"
"    u64    flags;\n"
"    struct sample_id sample_id;\n"
"};\n"
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:2620
#, no-wrap
msgid "I<aux_offset>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2623
msgid "offset in the AUX mmap region where the new data begins."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:2623
#, no-wrap
msgid "I<aux_size>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2626
msgid "size of the data made available."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2629
msgid "describes the AUX update."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:2630
#, no-wrap
msgid "B<PERF_AUX_FLAG_TRUNCATED>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2634
msgid ""
"if set, then the data returned was truncated to fit the available buffer "
"size."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:2634
#, no-wrap
msgid "B<PERF_AUX_FLAG_OVERWRITE>"
msgstr ""

#.  commit 2023a0d2829e521fe6ad6b9907f3f90bfbf57142
#. type: Plain text
#: man-pages/man2/perf_event_open.2:2638
msgid "if set, then the data returned has overwritten previous data."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:2640
#, no-wrap
msgid "B<PERF_RECORD_ITRACE_START> (since Linux 4.1)"
msgstr ""

#.  ec0d7729bbaed4b9d2d3fada693278e13a3d1368
#. type: Plain text
#: man-pages/man2/perf_event_open.2:2646
msgid ""
"This record indicates which process has initiated an instruction trace "
"event, allowing tools to properly correlate the instruction addresses in the "
"AUX buffer with the proper executable."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2654
#, no-wrap
msgid ""
"struct {\n"
"    struct perf_event_header header;\n"
"    u32    pid;\n"
"    u32    tid;\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2659
msgid "process ID of the thread starting an instruction trace."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2662
msgid "thread ID of the thread starting an instruction trace."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:2663
#, no-wrap
msgid "B<PERF_RECORD_LOST_SAMPLES> (since Linux 4.2)"
msgstr ""

#.  f38b0dbb491a6987e198aa6b428db8692a6480f8
#. type: Plain text
#: man-pages/man2/perf_event_open.2:2668
msgid ""
"When using hardware sampling (such as Intel PEBS) this record indicates some "
"number of samples that may have been lost."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2676
#, no-wrap
msgid ""
"struct {\n"
"    struct perf_event_header header;\n"
"    u64    lost;\n"
"    struct sample_id sample_id;\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2681
msgid "the number of potentially lost samples."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:2682
#, no-wrap
msgid "B<PERF_RECORD_SWITCH> (since Linux 4.3)"
msgstr ""

#.  commit 45ac1403f564f411c6a383a2448688ba8dd705a4
#. type: Plain text
#: man-pages/man2/perf_event_open.2:2692
msgid ""
"This record indicates a context switch has happened.  The "
"B<PERF_RECORD_MISC_SWITCH_OUT> bit in the I<misc> field indicates whether it "
"was a context switch into or away from the current process."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2699
#, no-wrap
msgid ""
"struct {\n"
"    struct perf_event_header header;\n"
"    struct sample_id sample_id;\n"
"};\n"
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:2700
#, no-wrap
msgid "B<PERF_RECORD_SWITCH_CPU_WIDE> (since Linux 4.3)"
msgstr ""

#.  commit 45ac1403f564f411c6a383a2448688ba8dd705a4
#. type: Plain text
#: man-pages/man2/perf_event_open.2:2715
msgid ""
"As with B<PERF_RECORD_SWITCH> this record indicates a context switch has "
"happened, but it only occurs when sampling in CPU-wide mode and provides "
"additional information on the process being switched to/from.  The "
"B<PERF_RECORD_MISC_SWITCH_OUT> bit in the I<misc> field indicates whether it "
"was a context switch into or away from the current process."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2724
#, no-wrap
msgid ""
"struct {\n"
"    struct perf_event_header header;\n"
"    u32 next_prev_pid;\n"
"    u32 next_prev_tid;\n"
"    struct sample_id sample_id;\n"
"};\n"
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:2726
#, no-wrap
msgid "I<next_prev_pid>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2730
msgid ""
"The process ID of the previous (if switching in)  or next (if switching out) "
"process on the CPU."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:2730
#, no-wrap
msgid "I<next_prev_tid>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2734
msgid ""
"The thread ID of the previous (if switching in)  or next (if switching out) "
"thread on the CPU."
msgstr ""

#. type: SS
#: man-pages/man2/perf_event_open.2:2736
#, no-wrap
msgid "Overflow handling"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2752
msgid ""
"Events can be set to notify when a threshold is crossed, indicating an "
"overflow.  Overflow conditions can be captured by monitoring the event file "
"descriptor with B<poll>(2), B<select>(2), or B<epoll>(7).  Alternatively, "
"the overflow events can be captured via sa signal handler, by enabling I/O "
"signaling on the file descriptor; see the discussion of the B<F_SETOWN> and "
"B<F_SETSIG> operations in B<fcntl>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2756
msgid ""
"Overflows are generated only by sampling events (I<sample_period> must have "
"a nonzero value)."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2758
msgid "There are two ways to generate overflow notifications."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2768
msgid ""
"The first is to set a I<wakeup_events> or I<wakeup_watermark> value that "
"will trigger if a certain number of samples or bytes have been written to "
"the mmap ring buffer.  In this case, B<POLL_IN> is indicated."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2780
msgid ""
"The other way is by use of the B<PERF_EVENT_IOC_REFRESH> ioctl.  This ioctl "
"adds to a counter that decrements each time the event overflows.  When "
"nonzero, B<POLL_IN> is indicated, but once the counter reaches 0 B<POLL_HUP> "
"is indicated and the underlying event is disabled."
msgstr ""

#.  See https://lkml.org/lkml/2011/5/24/337
#. type: Plain text
#: man-pages/man2/perf_event_open.2:2786
msgid ""
"Refreshing an event group leader refreshes all siblings and refreshing with "
"a parameter of 0 currently enables infinite refreshes; these behaviors are "
"unsupported and should not be relied on."
msgstr ""

#.  commit 179033b3e064d2cd3f5f9945e76b0a0f0fbf4883
#. type: Plain text
#: man-pages/man2/perf_event_open.2:2792
msgid ""
"Starting with Linux 3.18, B<POLL_HUP> is indicated if the event being "
"monitored is attached to a different process and that process exits."
msgstr ""

#. type: SS
#: man-pages/man2/perf_event_open.2:2792
#, no-wrap
msgid "rdpmc instruction"
msgstr ""

#.  commit c7206205d00ab375839bd6c7ddb247d600693c09
#. type: Plain text
#: man-pages/man2/perf_event_open.2:2800
msgid ""
"Starting with Linux 3.4 on x86, you can use the I<rdpmc> instruction to get "
"low-latency reads without having to enter the kernel.  Note that using "
"I<rdpmc> is not necessarily faster than other methods for reading event "
"values."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2805
msgid ""
"Support for this can be detected with the I<cap_usr_rdpmc> field in the mmap "
"page; documentation on how to calculate event values can be found in that "
"section."
msgstr ""

#.  7911d3f7af14a614617e38245fedf98a724e46a9
#. type: Plain text
#: man-pages/man2/perf_event_open.2:2815
msgid ""
"Originally, when rdpmc support was enabled, any process (not just ones with "
"an active perf event) could use the rdpmc instruction to access the "
"counters.  Starting with Linux 4.0, rdpmc support is only allowed if an "
"event is currently enabled in a process's context.  To restore the old "
"behavior, write the value 2 to I</sys/devices/cpu/rdpmc>."
msgstr ""

#. type: SS
#: man-pages/man2/perf_event_open.2:2815
#, no-wrap
msgid "perf_event ioctl calls"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2820
msgid "Various ioctls act on B<perf_event_open>()  file descriptors:"
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:2820
#, no-wrap
msgid "B<PERF_EVENT_IOC_ENABLE>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2824
msgid ""
"This enables the individual event or event group specified by the file "
"descriptor argument."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2830
msgid ""
"If the B<PERF_IOC_FLAG_GROUP> bit is set in the ioctl argument, then all "
"events in a group are enabled, even if the event specified is not the group "
"leader (but see BUGS)."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:2830
#, no-wrap
msgid "B<PERF_EVENT_IOC_DISABLE>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2834
msgid ""
"This disables the individual counter or event group specified by the file "
"descriptor argument."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2841
msgid ""
"Enabling or disabling the leader of a group enables or disables the entire "
"group; that is, while the group leader is disabled, none of the counters in "
"the group will count.  Enabling or disabling a member of a group other than "
"the leader affects only that counter; disabling a non-leader stops that "
"counter from counting but doesn't affect any other counter."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2847
msgid ""
"If the B<PERF_IOC_FLAG_GROUP> bit is set in the ioctl argument, then all "
"events in a group are disabled, even if the event specified is not the group "
"leader (but see BUGS)."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:2847
#, no-wrap
msgid "B<PERF_EVENT_IOC_REFRESH>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2861
msgid ""
"Non-inherited overflow counters can use this to enable a counter for a "
"number of overflows specified by the argument, after which it is disabled.  "
"Subsequent calls of this ioctl add the argument value to the current count.  "
"An overflow notification with B<POLL_IN> set will happen on each overflow "
"until the count reaches 0; when that happens a notification with B<POLL_HUP> "
"set is sent and the event is disabled.  Using an argument of 0 is considered "
"undefined behavior."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:2861
#, no-wrap
msgid "B<PERF_EVENT_IOC_RESET>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2871
msgid ""
"Reset the event count specified by the file descriptor argument to zero.  "
"This resets only the counts; there is no way to reset the multiplexing "
"I<time_enabled> or I<time_running> values."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2877
msgid ""
"If the B<PERF_IOC_FLAG_GROUP> bit is set in the ioctl argument, then all "
"events in a group are reset, even if the event specified is not the group "
"leader (but see BUGS)."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:2877
#, no-wrap
msgid "B<PERF_EVENT_IOC_PERIOD>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2880
msgid "This updates the overflow period for the event."
msgstr ""

#.  commit 3581fe0ef37ce12ac7a4f74831168352ae848edc
#.  commit bad7192b842c83e580747ca57104dd51fe08c223
#. type: Plain text
#: man-pages/man2/perf_event_open.2:2888
msgid ""
"Since Linux 3.7 (on ARM)  and Linux 3.14 (all other architectures), the new "
"period takes effect immediately.  On older kernels, the new period did not "
"take effect until after the next overflow."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2891
msgid ""
"The argument is a pointer to a 64-bit value containing the desired new "
"period."
msgstr ""

#.  commit ad0cf3478de8677f720ee06393b3147819568d6a
#. type: Plain text
#: man-pages/man2/perf_event_open.2:2896
msgid "Prior to Linux 2.6.36, this ioctl always failed due to a bug in the kernel."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:2896
#, no-wrap
msgid "B<PERF_EVENT_IOC_SET_OUTPUT>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2901
msgid ""
"This tells the kernel to report event notifications to the specified file "
"descriptor rather than the default one.  The file descriptors must all be on "
"the same CPU."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2904
msgid ""
"The argument specifies the desired file descriptor, or -1 if output should "
"be ignored."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:2904
#, no-wrap
msgid "B<PERF_EVENT_IOC_SET_FILTER> (since Linux 2.6.33)"
msgstr ""

#.  commit 6fb2915df7f0747d9044da9dbff5b46dc2e20830
#. type: Plain text
#: man-pages/man2/perf_event_open.2:2908
msgid "This adds an ftrace filter to this event."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2910
msgid "The argument is a pointer to the desired ftrace filter."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:2910
#, no-wrap
msgid "B<PERF_EVENT_IOC_ID> (since Linux 3.12)"
msgstr ""

#.  commit cf4957f17f2a89984915ea808876d9c82225b862
#. type: Plain text
#: man-pages/man2/perf_event_open.2:2914
msgid "This returns the event ID value for the given event file descriptor."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2917
msgid "The argument is a pointer to a 64-bit unsigned integer to hold the result."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:2917
#, no-wrap
msgid "B<PERF_EVENT_IOC_SET_BPF> (since Linux 4.1)"
msgstr ""

#.  commit 2541517c32be2531e0da59dfd7efc1ce844644f5
#. type: Plain text
#: man-pages/man2/perf_event_open.2:2925
msgid ""
"This allows attaching a Berkeley Packet Filter (BPF)  program to an existing "
"kprobe tracepoint event.  You need B<CAP_SYS_ADMIN> privileges to use this "
"ioctl."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2930
msgid ""
"The argument is a BPF program file descriptor that was created by a previous "
"B<bpf>(2)  system call."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:2930
#, no-wrap
msgid "B<PERF_EVENT_IOC_PAUSE_OUTPUT> (since Linux 4.7)"
msgstr ""

#.  commit 86e7972f690c1017fd086cdfe53d8524e68c661c
#. type: Plain text
#: man-pages/man2/perf_event_open.2:2941
msgid ""
"This allows pausing and resuming the event's ring-buffer.  A paused "
"ring-buffer does not prevent generation of samples, but simply discards "
"them.  The discarded samples are considered lost, and cause a "
"B<PERF_RECORD_LOST> sample to be generated when possible.  An overflow "
"signal may still be triggered by the discarded sample even though the "
"ring-buffer remains empty."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2945
msgid ""
"The argument is an unsigned 32-bit integer.  A nonzero value pauses the "
"ring-buffer, while a zero value resumes the ring-buffer."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:2945
#, no-wrap
msgid "B<PERF_EVENT_MODIFY_ATTRIBUTES> (since Linux 4.17)"
msgstr ""

#.  commit 32ff77e8cc9e66cc4fb38098f64fd54cc8f54573
#. type: Plain text
#: man-pages/man2/perf_event_open.2:2951
msgid ""
"This allows modifying an existing event without the overhead of closing and "
"reopening a new event.  Currently this is supported only for breakpoint "
"events."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2955
msgid ""
"The argument is a pointer to a I<perf_event_attr> structure containing the "
"updated event settings."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:2955
#, no-wrap
msgid "B<PERF_EVENT_IOC_QUERY_BPF> (since Linux 4.16)"
msgstr ""

#.  commit f371b304f12e31fe30207c41ca7754564e0ea4dc
#. type: Plain text
#: man-pages/man2/perf_event_open.2:2967
msgid ""
"This allows querying which Berkeley Packet Filter (BPF)  programs are "
"attached to an existing kprobe tracepoint.  You can only attach one BPF "
"program per event, but you can have multiple events attached to a "
"tracepoint.  Querying this value on one tracepoint event returns the id of "
"all BPF programs in all events attached to the tracepoint.  You need "
"B<CAP_SYS_ADMIN> privileges to use this ioctl."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2969
msgid "The argument is a pointer to a structure"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2976
#, no-wrap
msgid ""
"struct perf_event_query_bpf {\n"
"    __u32    ids_len;\n"
"    __u32    prog_cnt;\n"
"    __u32    ids[0];\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:2997
msgid ""
"The I<ids_len> field indicates the number of ids that can fit in the "
"provided I<ids> array.  The I<prog_cnt> value is filled in by the kernel "
"with the number of attached BPF programs.  The I<ids> array is filled with "
"the id of each attached BPF program.  If there are more programs than will "
"fit in the array, then the kernel will return B<ENOSPC> and I<ids_len> will "
"indicate the number of program IDs that were successfully copied."
msgstr ""

#. type: SS
#: man-pages/man2/perf_event_open.2:2997
#, no-wrap
msgid "Using prctl(2)"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:3010
msgid ""
"A process can enable or disable all currently open event groups using the "
"B<prctl>(2)  B<PR_TASK_PERF_EVENTS_ENABLE> and "
"B<PR_TASK_PERF_EVENTS_DISABLE> operations.  This applies only to events "
"created locally by the calling process.  This does not apply to events "
"created by other processes attached to the calling process or inherited "
"events from a parent process.  Only group leaders are enabled and disabled, "
"not any other members of the groups."
msgstr ""

#. type: SS
#: man-pages/man2/perf_event_open.2:3010
#, no-wrap
msgid "perf_event related configuration files"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:3014
msgid "Files in I</proc/sys/kernel/>"
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:3015
#, no-wrap
msgid "I</proc/sys/kernel/perf_event_paranoid>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:3020
msgid ""
"The I<perf_event_paranoid> file can be set to restrict access to the "
"performance counters."
msgstr ""

#.  default changed in commit 0161028b7c8aebef64194d3d73e43bc3b53b5c66
#. type: Plain text
#: man-pages/man2/perf_event_open.2:3026
msgid "allow only user-space measurements (default since Linux 4.6)."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:3028
msgid "allow both kernel and user measurements (default before Linux 4.6)."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:3030
msgid "allow access to CPU-specific data but not raw tracepoint samples."
msgstr ""

#. type: IP
#: man-pages/man2/perf_event_open.2:3030 man-pages/man2/wait.2:144
#, no-wrap
msgid "-1"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:3032
msgid "no restrictions."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:3039
msgid ""
"The existence of the I<perf_event_paranoid> file is the official method for "
"determining if a kernel supports B<perf_event_open>()."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:3039
#, no-wrap
msgid "I</proc/sys/kernel/perf_event_max_sample_rate>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:3047
msgid ""
"This sets the maximum sample rate.  Setting this too high can allow users to "
"sample at a rate that impacts overall machine performance and potentially "
"lock up the machine.  The default value is 100000 (samples per second)."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:3047
#, no-wrap
msgid "I</proc/sys/kernel/perf_event_max_stack>"
msgstr ""

#.  Introduced in c5dfd78eb79851e278b7973031b9ca363da87a7e
#. type: Plain text
#: man-pages/man2/perf_event_open.2:3052
msgid ""
"This file sets the maximum depth of stack frame entries reported when "
"generating a call trace."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:3052
#, no-wrap
msgid "I</proc/sys/kernel/perf_event_mlock_kb>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:3057
msgid ""
"Maximum number of pages an unprivileged user can B<mlock>(2).  The default "
"is 516 (kB)."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:3061
msgid "Files in I</sys/bus/event_source/devices/>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:3068
msgid ""
"Since Linux 2.6.34, the kernel supports having multiple PMUs available for "
"monitoring.  Information on how to program these PMUs can be found under "
"I</sys/bus/event_source/devices/>.  Each subdirectory corresponds to a "
"different PMU."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:3068
#, no-wrap
msgid "I</sys/bus/event_source/devices/*/type> (since Linux 2.6.38)"
msgstr ""

#.  commit abe43400579d5de0078c2d3a760e6598e183f871
#. type: Plain text
#: man-pages/man2/perf_event_open.2:3076
msgid ""
"This contains an integer that can be used in the I<type> field of "
"I<perf_event_attr> to indicate that you wish to use this PMU."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:3076
#, no-wrap
msgid "I</sys/bus/event_source/devices/cpu/rdpmc> (since Linux 3.4)"
msgstr ""

#.  commit 0c9d42ed4cee2aa1dfc3a260b741baae8615744f
#. type: Plain text
#: man-pages/man2/perf_event_open.2:3082
msgid ""
"If this file is 1, then direct user-space access to the performance counter "
"registers is allowed via the rdpmc instruction.  This can be disabled by "
"echoing 0 to the file."
msgstr ""

#.  a66734297f78707ce39d756b656bfae861d53f62
#.  7911d3f7af14a614617e38245fedf98a724e46a9
#. type: Plain text
#: man-pages/man2/perf_event_open.2:3089
msgid ""
"As of Linux 4.0 the behavior has changed, so that 1 now means only allow "
"access to processes with active perf events, with 2 indicating the old "
"allow-anyone-access behavior."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:3089
#, no-wrap
msgid "I</sys/bus/event_source/devices/*/format/> (since Linux 3.4)"
msgstr ""

#.  commit 641cc938815dfd09f8fa1ec72deb814f0938ac33
#. type: Plain text
#: man-pages/man2/perf_event_open.2:3098
msgid ""
"This subdirectory contains information on the architecture-specific "
"subfields available for programming the various I<config> fields in the "
"I<perf_event_attr> struct."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:3109
msgid ""
"The content of each file is the name of the config field, followed by a "
"colon, followed by a series of integer bit ranges separated by commas.  For "
"example, the file I<event> may contain the value I<config1:1,6-10,44> which "
"indicates that event is an attribute that occupies bits 1,6\\(en10, and 44 "
"of I<perf_event_attr::config1>."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:3109
#, no-wrap
msgid "I</sys/bus/event_source/devices/*/events/> (since Linux 3.4)"
msgstr ""

#.  commit 641cc938815dfd09f8fa1ec72deb814f0938ac33
#. type: Plain text
#: man-pages/man2/perf_event_open.2:3119
msgid ""
"This subdirectory contains files with predefined events.  The contents are "
"strings describing the event settings expressed in terms of the fields found "
"in the previously mentioned I<./format/> directory.  These are not "
"necessarily complete lists of all events supported by a PMU, but usually a "
"subset of events deemed useful or interesting."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:3127
msgid ""
"The content of each file is a list of attribute names separated by commas.  "
"Each entry has an optional value (either hex or decimal).  If no value is "
"specified, then it is assumed to be a single-bit field with a value of 1.  "
"An example entry may look like this: I<event=0x2,inv,ldlat=3>."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:3127
#, no-wrap
msgid "I</sys/bus/event_source/devices/*/uevent>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:3131
msgid ""
"This file is the standard kernel device interface for injecting hotplug "
"events."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:3131
#, no-wrap
msgid "I</sys/bus/event_source/devices/*/cpumask> (since Linux 3.7)"
msgstr ""

#.  commit 314d9f63f385096580e9e2a06eaa0745d92fe4ac
#. type: Plain text
#: man-pages/man2/perf_event_open.2:3141
msgid ""
"The I<cpumask> file contains a comma-separated list of integers that "
"indicate a representative CPU number for each socket (package)  on the "
"motherboard.  This is needed when setting up uncore or northbridge events, "
"as those PMUs present socket-wide events."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:3148
msgid ""
"B<perf_event_open>()  returns the new file descriptor, or -1 if an error "
"occurred (in which case, I<errno> is set appropriately)."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:3153
msgid ""
"The errors returned by B<perf_event_open>()  can be inconsistent, and may "
"vary across processor architectures and performance monitoring units."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:3170
msgid ""
"Returned if the I<perf_event_attr> I<size> value is too small (smaller than "
"B<PERF_ATTR_SIZE_VER0>), too big (larger than the page size), or larger than "
"the kernel supports and the extra bytes are not zero.  When B<E2BIG> is "
"returned, the I<perf_event_attr> I<size> field is overwritten by the kernel "
"to be the size of the structure it was expecting."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:3184
msgid ""
"Returned when the requested event requires B<CAP_SYS_ADMIN> permissions (or "
"a more permissive perf_event paranoid setting).  Some common cases where an "
"unprivileged process may encounter this error: attaching to a process owned "
"by a different user; monitoring all processes on a given CPU (i.e., "
"specifying the I<pid> argument as -1); and not setting I<exclude_kernel> "
"when the paranoid setting requires it."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:3194
msgid ""
"Returned if the I<group_fd> file descriptor is not valid, or, if "
"B<PERF_FLAG_PID_CGROUP> is set, the cgroup file descriptor in I<pid> is not "
"valid."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:3194
#, no-wrap
msgid "B<EBUSY> (since Linux 4.1)"
msgstr ""

#.  bed5b25ad9c8a2f5d735ef0bc746ec870c01c1b0
#. type: Plain text
#: man-pages/man2/perf_event_open.2:3199
msgid "Returned if another event already has exclusive access to the PMU."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:3204
msgid "Returned if the I<attr> pointer points at an invalid memory address."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:3230
msgid ""
"Returned if the specified event is invalid.  There are many possible reasons "
"for this.  A not-exhaustive list: I<sample_freq> is higher than the maximum "
"setting; the I<cpu> to monitor does not exist; I<read_format> is out of "
"range; I<sample_type> is out of range; the I<flags> value is out of range; "
"I<exclusive> or I<pinned> set and the event is not a group leader; the event "
"I<config> values are out of range or set reserved bits; the generic event "
"selected is not supported; or there is not enough room to add the selected "
"event."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:3236
msgid ""
"Each opened event uses one file descriptor.  If a large number of events are "
"opened, the per-process limit on the number of open file descriptors will be "
"reached, and no more events can be created."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:3240
msgid "Returned when the event involves a feature not supported by the current CPU."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:3247
msgid ""
"Returned if the I<type> setting is not valid.  This error is also returned "
"for some unsupported generic events."
msgstr ""

#.  commit aa2bc1ade59003a379ffc485d6da2d92ea3370a6
#. type: Plain text
#: man-pages/man2/perf_event_open.2:3258
msgid ""
"Prior to Linux 3.3, if there was not enough room for the event, B<ENOSPC> "
"was returned.  In Linux 3.3, this was changed to B<EINVAL>.  B<ENOSPC> is "
"still returned if you try to add more breakpoint events than supported by "
"the hardware."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:3265
msgid ""
"Returned if B<PERF_SAMPLE_STACK_USER> is set in I<sample_type> and it is not "
"supported by hardware."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:3272
msgid ""
"Returned if an event requiring a specific hardware feature is requested but "
"there is no hardware support.  This includes requesting low-skid events if "
"not supported, branch tracing if it is not available, sampling if no PMU "
"interrupt is available, and branch stacks for software events."
msgstr ""

#. type: TP
#: man-pages/man2/perf_event_open.2:3272
#, no-wrap
msgid "B<EOVERFLOW> (since Linux 4.8)"
msgstr ""

#.  97c79a38cd454602645f0470ffb444b3b75ce574
#. type: Plain text
#: man-pages/man2/perf_event_open.2:3281
msgid ""
"Returned if B<PERF_SAMPLE_CALLCHAIN> is requested and I<sample_max_stack> is "
"larger than the maximum specified in "
"I</proc/sys/kernel/perf_event_max_stack>."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:3286
msgid ""
"Returned on many (but not all) architectures when an unsupported "
"I<exclude_hv>, I<exclude_idle>, I<exclude_user>, or I<exclude_kernel> "
"setting is specified."
msgstr ""

#.  commit a4e95fc2cbb31d70a65beffeaf8773f881328c34
#. type: Plain text
#: man-pages/man2/perf_event_open.2:3295
msgid ""
"It can also happen, as with B<EACCES>, when the requested event requires "
"B<CAP_SYS_ADMIN> permissions (or a more permissive perf_event paranoid "
"setting).  This includes setting a breakpoint on a kernel address, and "
"(since Linux 3.13) setting a kernel function-trace tracepoint."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:3298
msgid "Returned if attempting to attach to a process that does not exist."
msgstr ""

#. type: SH
#: man-pages/man2/perf_event_open.2:3298
#, no-wrap
msgid "VERSION"
msgstr ""

#.  commit 0793a61d4df8daeac6492dbf8d2f3e5713caae5e
#.  commit cdd6c482c9ff9c55475ee7392ec8f672eddb7be6
#. type: Plain text
#: man-pages/man2/perf_event_open.2:3305
msgid ""
"B<perf_event_open>()  was introduced in Linux 2.6.31 but was called "
"B<perf_counter_open>().  It was renamed in Linux 2.6.32."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:3310
msgid ""
"This B<perf_event_open>()  system call Linux-specific and should not be used "
"in programs intended to be portable."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:3314
msgid ""
"Glibc does not provide a wrapper for this system call; call it using "
"B<syscall>(2).  See the example below."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:3320
msgid ""
"The official way of knowing if B<perf_event_open>()  support is enabled is "
"checking for the existence of the file "
"I</proc/sys/kernel/perf_event_paranoid>."
msgstr ""

#.  commit ba0a6c9f6fceed11c6a99e8326f0477fe383e6b5
#. type: Plain text
#: man-pages/man2/perf_event_open.2:3328
msgid ""
"The B<F_SETOWN_EX> option to B<fcntl>(2)  is needed to properly get overflow "
"signals in threads.  This was introduced in Linux 2.6.32."
msgstr ""

#.  commit b690081d4d3f6a23541493f1682835c3cd5c54a1
#. type: Plain text
#: man-pages/man2/perf_event_open.2:3338
msgid ""
"Prior to Linux 2.6.33 (at least for x86), the kernel did not check if events "
"could be scheduled together until read time.  The same happens on all known "
"kernels if the NMI watchdog is enabled.  This means to see if a given set of "
"events works you have to B<perf_event_open>(), start, then read before you "
"know for sure you can get valid measurements."
msgstr ""

#.  FIXME . cannot find a kernel commit for this one
#. type: Plain text
#: man-pages/man2/perf_event_open.2:3344
msgid ""
"Prior to Linux 2.6.34, event constraints were not enforced by the kernel.  "
"In that case, some events would silently return \"0\" if the kernel "
"scheduled them in an improper counter slot."
msgstr ""

#.  commit 45e16a6834b6af098702e5ea6c9a40de42ff77d8
#. type: Plain text
#: man-pages/man2/perf_event_open.2:3348
msgid ""
"Prior to Linux 2.6.34, there was a bug when multiplexing where the wrong "
"results could be returned."
msgstr ""

#.  commit 38b435b16c36b0d863efcf3f07b34a6fac9873fd
#. type: Plain text
#: man-pages/man2/perf_event_open.2:3352
msgid ""
"Kernels from Linux 2.6.35 to Linux 2.6.39 can quickly crash the kernel if "
"\"inherit\" is enabled and many threads are started."
msgstr ""

#.  commit 050735b08ca8a016bbace4445fa025b88fee770b
#. type: Plain text
#: man-pages/man2/perf_event_open.2:3357
msgid ""
"Prior to Linux 2.6.35, B<PERF_FORMAT_GROUP> did not work with attached "
"processes."
msgstr ""

#.  commit 4ec8363dfc1451f8c8f86825731fe712798ada02
#. type: Plain text
#: man-pages/man2/perf_event_open.2:3364
msgid ""
"There is a bug in the kernel code between Linux 2.6.36 and Linux 3.0 that "
"ignores the \"watermark\" field and acts as if a wakeup_event was chosen if "
"the union has a nonzero value in it."
msgstr ""

#.  commit 724b6daa13e100067c30cfc4d1ad06629609dc4e
#. type: Plain text
#: man-pages/man2/perf_event_open.2:3371
msgid ""
"From Linux 2.6.31 to Linux 3.4, the B<PERF_IOC_FLAG_GROUP> ioctl argument "
"was broken and would repeatedly operate on the event specified rather than "
"iterating across all sibling events in a group."
msgstr ""

#.  commit fa7315871046b9a4c48627905691dbde57e51033
#. type: Plain text
#: man-pages/man2/perf_event_open.2:3383
msgid ""
"From Linux 3.4 to Linux 3.11, the mmap I<cap_usr_rdpmc> and I<cap_usr_time> "
"bits mapped to the same location.  Code should migrate to the new "
"I<cap_user_rdpmc> and I<cap_user_time> fields instead."
msgstr ""

#.  commit f287d332ce835f77a4f5077d2c0ef1e3f9ea42d2
#. type: Plain text
#: man-pages/man2/perf_event_open.2:3389
msgid ""
"Always double-check your results! Various generalized events have had wrong "
"values.  For example, retired branches measured the wrong thing on AMD "
"machines until Linux 2.6.35."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:3393
msgid ""
"The following is a short example that measures the total instruction count "
"of a call to B<printf>(3)."
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:3402
#, no-wrap
msgid ""
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>sys/ioctl.hE<gt>\n"
"#include E<lt>linux/perf_event.hE<gt>\n"
"#include E<lt>asm/unistd.hE<gt>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:3408
#, no-wrap
msgid ""
"static long\n"
"perf_event_open(struct perf_event_attr *hw_event, pid_t pid,\n"
"                int cpu, int group_fd, unsigned long flags)\n"
"{\n"
"    int ret;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:3413
#, no-wrap
msgid ""
"    ret = syscall(__NR_perf_event_open, hw_event, pid, cpu,\n"
"                   group_fd, flags);\n"
"    return ret;\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:3420
#, no-wrap
msgid ""
"int\n"
"main(int argc, char **argv)\n"
"{\n"
"    struct perf_event_attr pe;\n"
"    long long count;\n"
"    int fd;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:3428
#, no-wrap
msgid ""
"    memset(&pe, 0, sizeof(struct perf_event_attr));\n"
"    pe.type = PERF_TYPE_HARDWARE;\n"
"    pe.size = sizeof(struct perf_event_attr);\n"
"    pe.config = PERF_COUNT_HW_INSTRUCTIONS;\n"
"    pe.disabled = 1;\n"
"    pe.exclude_kernel = 1;\n"
"    pe.exclude_hv = 1;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:3434
#, no-wrap
msgid ""
"    fd = perf_event_open(&pe, 0, -1, -1, 0);\n"
"    if (fd == -1) {\n"
"       fprintf(stderr, \"Error opening leader %llx\\en\", pe.config);\n"
"       exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:3437
#, no-wrap
msgid ""
"    ioctl(fd, PERF_EVENT_IOC_RESET, 0);\n"
"    ioctl(fd, PERF_EVENT_IOC_ENABLE, 0);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:3439
#, no-wrap
msgid "    printf(\"Measuring instruction count for this printf\\en\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:3442
#, no-wrap
msgid ""
"    ioctl(fd, PERF_EVENT_IOC_DISABLE, 0);\n"
"    read(fd, &count, sizeof(long long));\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:3444
#, no-wrap
msgid "    printf(\"Used %lld instructions\\en\", count);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:3447
#, no-wrap
msgid ""
"    close(fd);\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:3455
msgid "B<perf>(1), B<fcntl>(2), B<mmap>(2), B<open>(2), B<prctl>(2), B<read>(2)"
msgstr ""

#. type: Plain text
#: man-pages/man2/perf_event_open.2:3457
msgid "I<Documentation/admin-guide/perf-security.rst> in the kernel source tree"
msgstr ""

#. type: TH
#: man-pages/man2/alloc_hugepages.2:25
#, no-wrap
msgid "ALLOC_HUGEPAGES"
msgstr ""

#. type: Plain text
#: man-pages/man2/alloc_hugepages.2:28
msgid "alloc_hugepages, free_hugepages - allocate or free huge pages"
msgstr ""

#.  asmlinkage unsigned long sys_alloc_hugepages(int key, unsigned long addr,
#.  unsigned long len, int prot, int flag);
#. type: Plain text
#: man-pages/man2/alloc_hugepages.2:34
#, no-wrap
msgid ""
"B<void *alloc_hugepages(int >I<key>B<, void *>I<addr>B<, size_t "
">I<len>B<,>\n"
"B<                      int >I<prot>B<, int >I<flag>B<);>\n"
msgstr ""

#.  asmlinkage int sys_free_hugepages(unsigned long addr);
#. type: Plain text
#: man-pages/man2/alloc_hugepages.2:37
#, no-wrap
msgid "B<int free_hugepages(void *>I<addr>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/alloc_hugepages.2:49
msgid ""
"The system calls B<alloc_hugepages>()  and B<free_hugepages>()  were "
"introduced in Linux 2.5.36 and removed again in 2.5.54.  They existed only "
"on i386 and ia64 (when built with B<CONFIG_HUGETLB_PAGE>).  In Linux 2.4.20, "
"the syscall numbers exist, but the calls fail with the error B<ENOSYS>."
msgstr ""

#. type: Plain text
#: man-pages/man2/alloc_hugepages.2:57
msgid ""
"On i386 the memory management hardware knows about ordinary pages (4\\ KiB)  "
"and huge pages (2 or 4\\ MiB).  Similarly ia64 knows about huge pages of "
"several sizes.  These system calls serve to map huge pages into the "
"process's memory or to free them again.  Huge pages are locked into memory, "
"and are not swapped."
msgstr ""

#. type: Plain text
#: man-pages/man2/alloc_hugepages.2:66
msgid ""
"The I<key> argument is an identifier.  When zero the pages are private, and "
"not inherited by children.  When positive the pages are shared with other "
"applications using the same I<key>, and inherited by child processes."
msgstr ""

#. type: Plain text
#: man-pages/man2/alloc_hugepages.2:81
msgid ""
"The I<addr> argument of B<free_hugepages>()  tells which page is being "
"freed: it was the return value of a call to B<alloc_hugepages>().  (The "
"memory is first actually freed when all users have released it.)  The "
"I<addr> argument of B<alloc_hugepages>()  is a hint, that the kernel may or "
"may not follow.  Addresses must be properly aligned."
msgstr ""

#. type: Plain text
#: man-pages/man2/alloc_hugepages.2:86
msgid ""
"The I<len> argument is the length of the required segment.  It must be a "
"multiple of the huge page size."
msgstr ""

#. type: Plain text
#: man-pages/man2/alloc_hugepages.2:94
msgid ""
"The I<prot> argument specifies the memory protection of the segment.  It is "
"one of B<PROT_READ>, B<PROT_WRITE>, B<PROT_EXEC>."
msgstr ""

#. type: Plain text
#: man-pages/man2/alloc_hugepages.2:109
msgid ""
"The I<flag> argument is ignored, unless I<key> is positive.  In that case, "
"if I<flag> is B<IPC_CREAT>, then a new huge page segment is created when "
"none with the given key existed.  If this flag is not set, then B<ENOENT> is "
"returned when no segment with the given key exists."
msgstr ""

#. type: Plain text
#: man-pages/man2/alloc_hugepages.2:118
msgid ""
"On success, B<alloc_hugepages>()  returns the allocated virtual address, and "
"B<free_hugepages>()  returns zero.  On error, -1 is returned, and I<errno> "
"is set appropriately."
msgstr ""

#. type: Plain text
#: man-pages/man2/alloc_hugepages.2:122
msgid "The system call is not supported on this kernel."
msgstr ""

#. type: TP
#: man-pages/man2/alloc_hugepages.2:123
#, no-wrap
msgid "I</proc/sys/vm/nr_hugepages>"
msgstr ""

#. type: Plain text
#: man-pages/man2/alloc_hugepages.2:127
msgid "Number of configured hugetlb pages.  This can be read and written."
msgstr ""

#. type: TP
#: man-pages/man2/alloc_hugepages.2:127
#, no-wrap
msgid "I</proc/meminfo>"
msgstr ""

#. type: Plain text
#: man-pages/man2/alloc_hugepages.2:131
msgid ""
"Gives info on the number of configured hugetlb pages and on their size in "
"the three variables HugePages_Total, HugePages_Free, Hugepagesize."
msgstr ""

#. type: Plain text
#: man-pages/man2/alloc_hugepages.2:134
msgid ""
"These calls are specific to Linux on Intel processors, and should not be "
"used in programs intended to be portable."
msgstr ""

#. type: Plain text
#: man-pages/man2/alloc_hugepages.2:142
msgid ""
"These system calls are gone; they existed only in Linux 2.5.36 through to "
"2.5.54.  Now the hugetlbfs filesystem can be used instead.  Memory backed by "
"huge pages (if the CPU supports them) is obtained by using B<mmap>(2)  to "
"map files in this virtual filesystem."
msgstr ""

#. type: Plain text
#: man-pages/man2/alloc_hugepages.2:146
msgid ""
"The maximal number of huge pages can be specified using the B<hugepages=> "
"boot parameter."
msgstr ""

#. type: TH
#: man-pages/man2/msync.2:25
#, no-wrap
msgid "MSYNC"
msgstr ""

#. type: Plain text
#: man-pages/man2/msync.2:28
msgid "msync - synchronize a file with a memory map"
msgstr ""

#. type: Plain text
#: man-pages/man2/msync.2:30 man-pages/man2/madvise.2:40
#: man-pages/man2/mincore.2:41
msgid "B<#include E<lt>sys/mman.hE<gt>>"
msgstr ""

#. type: Plain text
#: man-pages/man2/msync.2:32
msgid "B<int msync(void *>I<addr>B<, size_t >I<length>B<, int >I<flags>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/msync.2:48
msgid ""
"B<msync>()  flushes changes made to the in-core copy of a file that was "
"mapped into memory using B<mmap>(2)  back to the filesystem.  Without use of "
"this call, there is no guarantee that changes are written back before "
"B<munmap>(2)  is called.  To be more precise, the part of the file that "
"corresponds to the memory area starting at I<addr> and having length "
"I<length> is updated."
msgstr ""

#. type: Plain text
#: man-pages/man2/msync.2:59
msgid ""
"The I<flags> argument should specify exactly one of B<MS_ASYNC> and "
"B<MS_SYNC>, and may additionally include the B<MS_INVALIDATE> bit.  These "
"bits have the following meanings:"
msgstr ""

#. type: TP
#: man-pages/man2/msync.2:59
#, no-wrap
msgid "B<MS_ASYNC>"
msgstr ""

#. type: Plain text
#: man-pages/man2/msync.2:62
msgid "Specifies that an update be scheduled, but the call returns immediately."
msgstr ""

#. type: TP
#: man-pages/man2/msync.2:62
#, no-wrap
msgid "B<MS_SYNC>"
msgstr ""

#. type: Plain text
#: man-pages/man2/msync.2:65
msgid "Requests an update and waits for it to complete."
msgstr ""

#. type: TP
#: man-pages/man2/msync.2:65
#, no-wrap
msgid "B<MS_INVALIDATE>"
msgstr ""

#.  Since Linux 2.4, this seems to be a no-op (other than the
#.  EBUSY check for VM_LOCKED).
#. type: Plain text
#: man-pages/man2/msync.2:71
msgid ""
"Asks to invalidate other mappings of the same file (so that they can be "
"updated with the fresh values just written)."
msgstr ""

#. type: Plain text
#: man-pages/man2/msync.2:83
msgid ""
"B<MS_INVALIDATE> was specified in I<flags>, and a memory lock exists for the "
"specified address range."
msgstr ""

#. type: Plain text
#: man-pages/man2/msync.2:96
msgid ""
"I<addr> is not a multiple of PAGESIZE; or any bit other than B<MS_ASYNC> | "
"B<MS_INVALIDATE> | B<MS_SYNC> is set in I<flags>; or both B<MS_SYNC> and "
"B<MS_ASYNC> are set in I<flags>."
msgstr ""

#. type: Plain text
#: man-pages/man2/msync.2:99
msgid "The indicated memory (or part of it) was not mapped."
msgstr ""

#. type: Plain text
#: man-pages/man2/msync.2:108
msgid ""
"This call was introduced in Linux 1.3.21, and then used B<EFAULT> instead of "
"B<ENOMEM>.  In Linux 2.4.19, this was changed to the POSIX value B<ENOMEM>."
msgstr ""

#. type: SH
#: man-pages/man2/msync.2:108 man-pages/man2/mmap.2:662
#: man-pages/man2/fsync.2:154 man-pages/man2/mlock.2:278
#: man-pages/man2/clock_getres.2:257
#, no-wrap
msgid "AVAILABILITY"
msgstr ""

#.  POSIX.1-2001: It shall be defined to -1 or 0 or 200112L.
#.  -1: unavailable, 0: ask using sysconf().
#.  glibc defines them to 1.
#. type: Plain text
#: man-pages/man2/msync.2:123
msgid ""
"On POSIX systems on which B<msync>()  is available, both "
"B<_POSIX_MAPPED_FILES> and B<_POSIX_SYNCHRONIZED_IO> are defined in "
"I<E<lt>unistd.hE<gt>> to a value greater than 0.  (See also B<sysconf>(3).)"
msgstr ""

#.  commit 204ec841fbea3e5138168edbc3a76d46747cc987
#. type: Plain text
#: man-pages/man2/msync.2:150
msgid ""
"According to POSIX, either B<MS_SYNC> or B<MS_ASYNC> must be specified in "
"I<flags>, and indeed failure to include one of these flags will cause "
"B<msync>()  to fail on some systems.  However, Linux permits a call to "
"B<msync>()  that specifies neither of these flags, with semantics that are "
"(currently) equivalent to specifying B<MS_ASYNC>.  (Since Linux 2.6.19, "
"B<MS_ASYNC> is in fact a no-op, since the kernel properly tracks dirty pages "
"and flushes them to storage as necessary.)  Notwithstanding the Linux "
"behavior, portable, future-proof applications should ensure that they "
"specify either B<MS_SYNC> or B<MS_ASYNC> in I<flags>."
msgstr ""

#. type: Plain text
#: man-pages/man2/msync.2:153 man-pages/man2/mmap.2:1005
msgid "B.O. Gallmeister, POSIX.4, O'Reilly, pp. 128\\(en129 and 389\\(en391."
msgstr ""

#. type: TH
#: man-pages/man2/ioprio_set.2:24
#, no-wrap
msgid "IOPRIO_SET"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioprio_set.2:27
msgid "ioprio_get, ioprio_set - get/set I/O scheduling class and priority"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioprio_set.2:31
#, no-wrap
msgid ""
"B<int ioprio_get(int >I<which>B<, int >I<who>B<);>\n"
"B<int ioprio_set(int >I<which>B<, int >I<who>B<, int >I<ioprio>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioprio_set.2:42
msgid ""
"The B<ioprio_get>()  and B<ioprio_set>()  system calls get and set the I/O "
"scheduling class and priority of one or more threads."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioprio_set.2:54
msgid ""
"The I<which> and I<who> arguments identify the thread(s) on which the system "
"calls operate.  The I<which> argument determines how I<who> is interpreted, "
"and has one of the following values:"
msgstr ""

#. type: TP
#: man-pages/man2/ioprio_set.2:54
#, no-wrap
msgid "B<IOPRIO_WHO_PROCESS>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioprio_set.2:61
msgid ""
"I<who> is a process ID or thread ID identifying a single process or thread.  "
"If I<who> is 0, then operate on the calling thread."
msgstr ""

#. type: TP
#: man-pages/man2/ioprio_set.2:61
#, no-wrap
msgid "B<IOPRIO_WHO_PGRP>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioprio_set.2:68
msgid ""
"I<who> is a process group ID identifying all the members of a process "
"group.  If I<who> is 0, then operate on the process group of which the "
"caller is a member."
msgstr ""

#. type: TP
#: man-pages/man2/ioprio_set.2:68
#, no-wrap
msgid "B<IOPRIO_WHO_USER>"
msgstr ""

#.  FIXME . Need to document the behavior when 'who" is specified as 0
#.  See http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=652443
#. type: Plain text
#: man-pages/man2/ioprio_set.2:75
msgid ""
"I<who> is a user ID identifying all of the processes that have a matching "
"real UID."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioprio_set.2:98
msgid ""
"If I<which> is specified as B<IOPRIO_WHO_PGRP> or B<IOPRIO_WHO_USER> when "
"calling B<ioprio_get>(), and more than one process matches I<who>, then the "
"returned priority will be the highest one found among all of the matching "
"processes.  One priority is said to be higher than another one if it belongs "
"to a higher priority class (B<IOPRIO_CLASS_RT> is the highest priority "
"class; B<IOPRIO_CLASS_IDLE> is the lowest)  or if it belongs to the same "
"priority class as the other process but has a higher priority level (a lower "
"priority number means a higher priority level)."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioprio_set.2:108
msgid ""
"The I<ioprio> argument given to B<ioprio_set>()  is a bit mask that "
"specifies both the scheduling class and the priority to be assigned to the "
"target process(es).  The following macros are used for assembling and "
"dissecting I<ioprio> values:"
msgstr ""

#. type: TP
#: man-pages/man2/ioprio_set.2:108
#, no-wrap
msgid "B<IOPRIO_PRIO_VALUE(>I<class>B<, >I<data>B<)>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioprio_set.2:117
msgid ""
"Given a scheduling I<class> and priority (I<data>), this macro combines the "
"two values to produce an I<ioprio> value, which is returned as the result of "
"the macro."
msgstr ""

#. type: TP
#: man-pages/man2/ioprio_set.2:117
#, no-wrap
msgid "B<IOPRIO_PRIO_CLASS(>I<mask>B<)>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioprio_set.2:129
msgid ""
"Given I<mask> (an I<ioprio> value), this macro returns its I/O class "
"component, that is, one of the values B<IOPRIO_CLASS_RT>, "
"B<IOPRIO_CLASS_BE>, or B<IOPRIO_CLASS_IDLE>."
msgstr ""

#. type: TP
#: man-pages/man2/ioprio_set.2:129
#, no-wrap
msgid "B<IOPRIO_PRIO_DATA(>I<mask>B<)>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioprio_set.2:138
msgid ""
"Given I<mask> (an I<ioprio> value), this macro returns its priority "
"(I<data>)  component."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioprio_set.2:144
msgid ""
"See the NOTES section for more information on scheduling classes and "
"priorities, as well as the meaning of specifying I<ioprio> as 0."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioprio_set.2:152
msgid ""
"I/O priorities are supported for reads and for synchronous (B<O_DIRECT>, "
"B<O_SYNC>)  writes.  I/O priorities are not supported for asynchronous "
"writes because they are issued outside the context of the program dirtying "
"the memory, and thus program-specific priorities do not apply."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioprio_set.2:165
msgid ""
"On success, B<ioprio_get>()  returns the I<ioprio> value of the process with "
"highest I/O priority of any of the processes that match the criteria "
"specified in I<which> and I<who>.  On error, -1 is returned, and I<errno> is "
"set to indicate the error."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioprio_set.2:172
msgid ""
"On success, B<ioprio_set>()  returns 0.  On error, -1 is returned, and "
"I<errno> is set to indicate the error."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioprio_set.2:182
msgid ""
"Invalid value for I<which> or I<ioprio>.  Refer to the NOTES section for "
"available scheduler classes and priority levels for I<ioprio>."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioprio_set.2:190
msgid ""
"The calling process does not have the privilege needed to assign this "
"I<ioprio> to the specified process(es).  See the NOTES section for more "
"information on required privileges for B<ioprio_set>()."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioprio_set.2:196
msgid ""
"No process(es) could be found that matched the specification in I<which> and "
"I<who>."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioprio_set.2:199
msgid "These system calls have been available on Linux since kernel 2.6.13."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioprio_set.2:204
msgid ""
"Glibc does not provide a wrapper for these system calls; call them using "
"B<syscall>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioprio_set.2:223
msgid ""
"Two or more processes or threads can share an I/O context.  This will be the "
"case when B<clone>(2)  was called with the B<CLONE_IO> flag.  However, by "
"default, the distinct threads of a process will B<not> share the same I/O "
"context.  This means that if you want to change the I/O priority of all "
"threads in a process, you may need to call B<ioprio_set>()  on each of the "
"threads.  The thread ID that you would need for this operation is the one "
"that is returned by B<gettid>(2)  or B<clone>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioprio_set.2:228
msgid ""
"These system calls have an effect only when used in conjunction with an I/O "
"scheduler that supports I/O priorities.  As at kernel 2.6.17 the only such "
"scheduler is the Completely Fair Queuing (CFQ) I/O scheduler."
msgstr ""

#.  commit 8ec680e4c3ec818efd1652f15199ed1c216ab550
#. type: Plain text
#: man-pages/man2/ioprio_set.2:241
msgid ""
"If no I/O scheduler has been set for a thread, then by default the I/O "
"priority will follow the CPU nice value (B<setpriority>(2)).  In Linux "
"kernels before version 2.6.24, once an I/O priority had been set using "
"B<ioprio_set>(), there was no way to reset the I/O scheduling behavior to "
"the default.  Since Linux 2.6.24, specifying I<ioprio> as 0 can be used to "
"reset to the default I/O scheduling behavior."
msgstr ""

#. type: SS
#: man-pages/man2/ioprio_set.2:241
#, no-wrap
msgid "Selecting an I/O scheduler"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioprio_set.2:245
msgid ""
"I/O schedulers are selected on a per-device basis via the special file "
"I</sys/block/E<lt>deviceE<gt>/queue/scheduler>."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioprio_set.2:251
msgid ""
"One can view the current I/O scheduler via the I</sys> filesystem.  For "
"example, the following command displays a list of all schedulers currently "
"loaded in the kernel:"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioprio_set.2:256
#, no-wrap
msgid ""
"$B< cat /sys/block/sda/queue/scheduler>\n"
"noop anticipatory deadline [cfq]\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioprio_set.2:270
msgid ""
"The scheduler surrounded by brackets is the one actually in use for the "
"device (I<sda> in the example).  Setting another scheduler is done by "
"writing the name of the new scheduler to this file.  For example, the "
"following command will set the scheduler for the I<sda> device to I<cfq>:"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioprio_set.2:276
#, no-wrap
msgid ""
"$B< su>\n"
"Password:\n"
"#B< echo cfq E<gt> /sys/block/sda/queue/scheduler>\n"
msgstr ""

#. type: SS
#: man-pages/man2/ioprio_set.2:279
#, no-wrap
msgid "The Completely Fair Queuing (CFQ) I/O scheduler"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioprio_set.2:285
msgid ""
"Since version 3 (also known as CFQ Time Sliced), CFQ implements I/O nice "
"levels similar to those of CPU scheduling.  These nice levels are grouped "
"into three scheduling classes, each one containing one or more priority "
"levels:"
msgstr ""

#. type: TP
#: man-pages/man2/ioprio_set.2:285
#, no-wrap
msgid "B<IOPRIO_CLASS_RT> (1)"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioprio_set.2:300
msgid ""
"This is the real-time I/O class.  This scheduling class is given higher "
"priority than any other class: processes from this class are given first "
"access to the disk every time.  Thus, this I/O class needs to be used with "
"some care: one I/O real-time process can starve the entire system.  Within "
"the real-time class, there are 8 levels of class data (priority) that "
"determine exactly how much time this process needs the disk for on each "
"service.  The highest real-time priority level is 0; the lowest is 7.  In "
"the future, this might change to be more directly mappable to performance, "
"by passing in a desired data rate instead."
msgstr ""

#. type: TP
#: man-pages/man2/ioprio_set.2:300
#, no-wrap
msgid "B<IOPRIO_CLASS_BE> (2)"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioprio_set.2:313
msgid ""
"This is the best-effort scheduling class, which is the default for any "
"process that hasn't set a specific I/O priority.  The class data (priority) "
"determines how much I/O bandwidth the process will get.  Best-effort "
"priority levels are analogous to CPU nice values (see B<getpriority>(2)).  "
"The priority level determines a priority relative to other processes in the "
"best-effort scheduling class.  Priority levels range from 0 (highest) to 7 "
"(lowest)."
msgstr ""

#. type: TP
#: man-pages/man2/ioprio_set.2:313
#, no-wrap
msgid "B<IOPRIO_CLASS_IDLE> (3)"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioprio_set.2:322
msgid ""
"This is the idle scheduling class.  Processes running at this level get I/O "
"time only when no one else needs the disk.  The idle class has no class "
"data.  Attention is required when assigning this priority class to a "
"process, since it may become starved if higher priority processes are "
"constantly accessing the disk."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioprio_set.2:326
msgid ""
"Refer to the kernel source file I<Documentation/block/ioprio.txt> for more "
"information on the CFQ I/O Scheduler and an example program."
msgstr ""

#. type: SS
#: man-pages/man2/ioprio_set.2:326
#, no-wrap
msgid "Required permissions to set I/O priorities"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioprio_set.2:329
msgid ""
"Permission to change a process's priority is granted or denied based on two "
"criteria:"
msgstr ""

#. type: TP
#: man-pages/man2/ioprio_set.2:329
#, no-wrap
msgid "B<Process ownership>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioprio_set.2:337
msgid ""
"An unprivileged process may set the I/O priority only for a process whose "
"real UID matches the real or effective UID of the calling process.  A "
"process which has the B<CAP_SYS_NICE> capability can change the priority of "
"any process."
msgstr ""

#. type: TP
#: man-pages/man2/ioprio_set.2:337
#, no-wrap
msgid "B<What is the desired priority>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioprio_set.2:349
msgid ""
"Attempts to set very high priorities (B<IOPRIO_CLASS_RT>)  require the "
"B<CAP_SYS_ADMIN> capability.  Kernel versions up to 2.6.24 also required "
"B<CAP_SYS_ADMIN> to set a very low priority (B<IOPRIO_CLASS_IDLE>), but "
"since Linux 2.6.25, this is no longer required."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioprio_set.2:354
msgid ""
"A call to B<ioprio_set>()  must follow both rules, or the call will fail "
"with the error B<EPERM>."
msgstr ""

#.  6 May 07: Bug report raised:
#.  http://sources.redhat.com/bugzilla/show_bug.cgi?id=4464
#.  Ulrich Drepper replied that he wasn't going to add these
#.  to glibc.
#. type: Plain text
#: man-pages/man2/ioprio_set.2:363
msgid ""
"Glibc does not yet provide a suitable header file defining the function "
"prototypes and macros described on this page.  Suitable definitions can be "
"found in I<linux/ioprio.h>."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioprio_set.2:369
msgid ""
"B<ionice>(1), B<getpriority>(2), B<open>(2), B<capabilities>(7), "
"B<cgroups>(7)"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioprio_set.2:371
msgid "I<Documentation/block/ioprio.txt> in the Linux kernel source tree"
msgstr ""

#. type: TH
#: man-pages/man2/getdomainname.2:29
#, no-wrap
msgid "GETDOMAINNAME"
msgstr ""

#. type: Plain text
#: man-pages/man2/getdomainname.2:32
msgid "getdomainname, setdomainname - get/set NIS domain name"
msgstr ""

#. type: Plain text
#: man-pages/man2/getdomainname.2:36
msgid "B<int getdomainname(char *>I<name>B<, size_t >I<len>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/getdomainname.2:38
msgid "B<int setdomainname(const char *>I<name>B<, size_t >I<len>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/getdomainname.2:47
msgid "B<getdomainname>(), B<setdomainname>():"
msgstr ""

#. type: Plain text
#: man-pages/man2/getdomainname.2:62
msgid ""
"These functions are used to access or to change the NIS domain name of the "
"host system.  More precisely, they operate on the NIS domain name associated "
"with the calling process's UTS namespace."
msgstr ""

#. type: Plain text
#: man-pages/man2/getdomainname.2:73
msgid ""
"B<setdomainname>()  sets the domain name to the value given in the character "
"array I<name>.  The I<len> argument specifies the number of bytes in "
"I<name>.  (Thus, I<name> does not require a terminating null byte.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/getdomainname.2:83
msgid ""
"B<getdomainname>()  returns the null-terminated domain name in the character "
"array I<name>, which has a length of I<len> bytes.  If the null-terminated "
"domain name requires more than I<len> bytes, B<getdomainname>()  returns the "
"first I<len> bytes (glibc) or gives an error (libc)."
msgstr ""

#. type: Plain text
#: man-pages/man2/getdomainname.2:91
msgid "B<setdomainname>()  can fail with the following errors:"
msgstr ""

#. type: Plain text
#: man-pages/man2/getdomainname.2:95
msgid "I<name> pointed outside of user address space."
msgstr ""

#. type: Plain text
#: man-pages/man2/getdomainname.2:99
msgid "I<len> was negative or too large."
msgstr ""

#. type: Plain text
#: man-pages/man2/getdomainname.2:105
msgid ""
"The caller did not have the B<CAP_SYS_ADMIN> capability in the user "
"namespace associated with its UTS namespace (see B<namespaces>(7))."
msgstr ""

#. type: Plain text
#: man-pages/man2/getdomainname.2:108
msgid "B<getdomainname>()  can fail with the following errors:"
msgstr ""

#. type: Plain text
#: man-pages/man2/getdomainname.2:119
msgid ""
"For B<getdomainname>()  under libc: I<name> is NULL or I<name> is longer "
"than I<len> bytes."
msgstr ""

#.  But they appear on most systems...
#. type: Plain text
#: man-pages/man2/getdomainname.2:122
msgid "POSIX does not specify these calls."
msgstr ""

#. type: Plain text
#: man-pages/man2/getdomainname.2:126
msgid ""
"Since Linux 1.0, the limit on the length of a domain name, including the "
"terminating null byte, is 64 bytes.  In older kernels, it was 8 bytes."
msgstr ""

#. type: Plain text
#: man-pages/man2/getdomainname.2:136
msgid ""
"On most Linux architectures (including x86), there is no B<getdomainname>()  "
"system call; instead, glibc implements B<getdomainname>()  as a library "
"function that returns a copy of the I<domainname> field returned from a call "
"to B<uname>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/getdomainname.2:140
msgid "B<gethostname>(2), B<sethostname>(2), B<uname>(2), B<uts_namespaces>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/nanosleep.2:34
#, no-wrap
msgid "NANOSLEEP"
msgstr ""

#. type: Plain text
#: man-pages/man2/nanosleep.2:37
msgid "nanosleep - high-resolution sleep"
msgstr ""

#. type: Plain text
#: man-pages/man2/nanosleep.2:41
msgid ""
"B<int nanosleep(const struct timespec *>I<req>B<, struct timespec "
"*>I<rem>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/nanosleep.2:49
msgid "B<nanosleep>(): _POSIX_C_SOURCE\\ E<gt>=\\ 199309L"
msgstr ""

#. type: Plain text
#: man-pages/man2/nanosleep.2:57
msgid ""
"B<nanosleep>()  suspends the execution of the calling thread until either at "
"least the time specified in I<*req> has elapsed, or the delivery of a signal "
"that triggers the invocation of a handler in the calling thread or that "
"terminates the process."
msgstr ""

#. type: Plain text
#: man-pages/man2/nanosleep.2:74
msgid ""
"If the call is interrupted by a signal handler, B<nanosleep>()  returns -1, "
"sets I<errno> to B<EINTR>, and writes the remaining time into the structure "
"pointed to by I<rem> unless I<rem> is NULL.  The value of I<*rem> can then "
"be used to call B<nanosleep>()  again and complete the specified pause (but "
"see NOTES)."
msgstr ""

#. type: Plain text
#: man-pages/man2/nanosleep.2:79
msgid ""
"The structure I<timespec> is used to specify intervals of time with "
"nanosecond precision.  It is defined as follows:"
msgstr ""

#. type: Plain text
#: man-pages/man2/nanosleep.2:86 man-pages/man2/utimensat.2:108
#, no-wrap
msgid ""
"struct timespec {\n"
"    time_t tv_sec;        /* seconds */\n"
"    long   tv_nsec;       /* nanoseconds */\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/nanosleep.2:90
msgid "The value of the nanoseconds field must be in the range 0 to 999999999."
msgstr ""

#. type: Plain text
#: man-pages/man2/nanosleep.2:102
msgid ""
"Compared to B<sleep>(3)  and B<usleep>(3), B<nanosleep>()  has the following "
"advantages: it provides a higher resolution for specifying the sleep "
"interval; POSIX.1 explicitly specifies that it does not interact with "
"signals; and it makes the task of resuming a sleep that has been interrupted "
"by a signal handler easier."
msgstr ""

#. type: Plain text
#: man-pages/man2/nanosleep.2:110
msgid ""
"On successfully sleeping for the requested interval, B<nanosleep>()  returns "
"0.  If the call is interrupted by a signal handler or encounters an error, "
"then it returns -1, with I<errno> set to indicate the error."
msgstr ""

#. type: Plain text
#: man-pages/man2/nanosleep.2:114
msgid "Problem with copying information from user space."
msgstr ""

#. type: Plain text
#: man-pages/man2/nanosleep.2:125
msgid ""
"The pause has been interrupted by a signal that was delivered to the thread "
"(see B<signal>(7)).  The remaining sleep time has been written into I<*rem> "
"so that the thread can easily call B<nanosleep>()  again and continue with "
"the pause."
msgstr ""

#. type: Plain text
#: man-pages/man2/nanosleep.2:142
msgid ""
"If the interval specified in I<req> is not an exact multiple of the "
"granularity underlying clock (see B<time>(7)), then the interval will be "
"rounded up to the next multiple.  Furthermore, after the sleep completes, "
"there may still be a delay before the CPU becomes free to once again execute "
"the calling thread."
msgstr ""

#. type: Plain text
#: man-pages/man2/nanosleep.2:152
msgid ""
"The fact that B<nanosleep>()  sleeps for a relative interval can be "
"problematic if the call is repeatedly restarted after being interrupted by "
"signals, since the time between the interruptions and restarts of the call "
"will lead to drift in the time when the sleep finally completes.  This "
"problem can be avoided by using B<clock_nanosleep>(2)  with an absolute time "
"value."
msgstr ""

#.  See also http://thread.gmane.org/gmane.linux.kernel/696854/
#.  Subject: nanosleep() uses CLOCK_MONOTONIC, should be CLOCK_REALTIME?
#.  Date: 2008-06-22 07:35:41 GMT
#. type: Plain text
#: man-pages/man2/nanosleep.2:170
msgid ""
"POSIX.1 specifies that B<nanosleep>()  should measure time against the "
"B<CLOCK_REALTIME> clock.  However, Linux measures the time using the "
"B<CLOCK_MONOTONIC> clock.  This probably does not matter, since the POSIX.1 "
"specification for B<clock_settime>(2)  says that discontinuous changes in "
"B<CLOCK_REALTIME> should not affect B<nanosleep>():"
msgstr ""

#. type: Plain text
#: man-pages/man2/nanosleep.2:183
msgid ""
"Setting the value of the B<CLOCK_REALTIME> clock via B<clock_settime>(2)  "
"shall have no effect on threads that are blocked waiting for a relative time "
"service based upon this clock, including the B<nanosleep>()  function; ...  "
"Consequently, these time services shall expire when the requested relative "
"interval elapses, independently of the new or old value of the clock."
msgstr ""

#. type: SS
#: man-pages/man2/nanosleep.2:184
#, no-wrap
msgid "Old behavior"
msgstr ""

#. type: Plain text
#: man-pages/man2/nanosleep.2:196
msgid ""
"In order to support applications requiring much more precise pauses (e.g., "
"in order to control some time-critical hardware), B<nanosleep>()  would "
"handle pauses of up to 2 milliseconds by busy waiting with microsecond "
"precision when called from a thread scheduled under a real-time policy like "
"B<SCHED_FIFO> or B<SCHED_RR>.  This special extension was removed in kernel "
"2.5.39, and is thus not available in Linux 2.6.0 and later kernels."
msgstr ""

#. type: Plain text
#: man-pages/man2/nanosleep.2:215
msgid ""
"If a program that catches signals and uses B<nanosleep>()  receives signals "
"at a very high rate, then scheduling delays and rounding errors in the "
"kernel's calculation of the sleep interval and the returned I<remain> value "
"mean that the I<remain> value may steadily I<increase> on successive "
"restarts of the B<nanosleep>()  call.  To avoid such problems, use "
"B<clock_nanosleep>(2)  with the B<TIMER_ABSTIME> flag to sleep to an "
"absolute deadline."
msgstr ""

#. type: Plain text
#: man-pages/man2/nanosleep.2:230
msgid ""
"In Linux 2.4, if B<nanosleep>()  is stopped by a signal (e.g., B<SIGTSTP>), "
"then the call fails with the error B<EINTR> after the thread is resumed by a "
"B<SIGCONT> signal.  If the system call is subsequently restarted, then the "
"time that the thread spent in the stopped state is I<not> counted against "
"the sleep interval.  This problem is fixed in Linux 2.6.0 and later kernels."
msgstr ""

#. type: Plain text
#: man-pages/man2/nanosleep.2:237
msgid ""
"B<clock_nanosleep>(2), B<restart_syscall>(2), B<sched_setscheduler>(2), "
"B<timer_create>(2), B<sleep>(3), B<usleep>(3), B<time>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/keyctl.2:28
#, no-wrap
msgid "KEYCTL"
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:31
msgid "keyctl - manipulate the kernel's key management facility"
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:37
#, no-wrap
msgid "B<long keyctl(int >I<operation>B<, ...)>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:42
#, no-wrap
msgid ""
"B</* For direct call via syscall(2): */>\n"
"B<#include E<lt>asm/unistd.hE<gt>>\n"
"B<#include E<lt>linux/keyctl.hE<gt>>\n"
"B<#include E<lt>unistd.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:46
#, no-wrap
msgid ""
"B<long syscall(__NR_keyctl, int >I<operation>B<, __kernel_ulong_t "
">I<arg2>B<,>\n"
"B<             __kernel_ulong_t >I<arg3>B<, __kernel_ulong_t >I<arg4>B<,>\n"
"B<             __kernel_ulong_t >I<arg5>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:52
msgid "B<keyctl>()  allows user-space programs to perform key manipulation."
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:64
msgid ""
"The operation performed by B<keyctl>()  is determined by the value of the "
"I<operation> argument.  Each of these operations is wrapped by the "
"I<libkeyutils> library (provided by the I<keyutils> package) into individual "
"functions (noted below)  to permit the compiler to check types."
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:68
msgid "The permitted values for I<operation> are:"
msgstr ""

#. type: TP
#: man-pages/man2/keyctl.2:68
#, no-wrap
msgid "B<KEYCTL_GET_KEYRING_ID> (since Linux 2.6.10)"
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:71
msgid "Map a special key ID to a real key ID for this process."
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:80
msgid ""
"This operation looks up the special key whose ID is provided in I<arg2> "
"(cast to I<key_serial_t>).  If the special key is found, the ID of the "
"corresponding real key is returned as the function result.  The following "
"values may be specified in I<arg2>:"
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:86
msgid ""
"This specifies the calling thread's thread-specific keyring.  See "
"B<thread-keyring>(7)."
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:91
msgid ""
"This specifies the caller's process-specific keyring.  See "
"B<process-keyring>(7)."
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:96
msgid ""
"This specifies the caller's session-specific keyring.  See "
"B<session-keyring>(7)."
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:101
msgid "This specifies the caller's UID-specific keyring.  See B<user-keyring>(7)."
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:106
msgid ""
"This specifies the caller's UID-session keyring.  See "
"B<user-session-keyring>(7)."
msgstr ""

#. type: TP
#: man-pages/man2/keyctl.2:106
#, no-wrap
msgid "B<KEY_SPEC_REQKEY_AUTH_KEY> (since Linux 2.6.16)"
msgstr ""

#.             commit b5f545c880a2a47947ba2118b2509644ab7a2969
#. type: Plain text
#: man-pages/man2/keyctl.2:117
msgid ""
"This specifies the authorization key created by B<request_key>(2)  and "
"passed to the process it spawns to generate a key.  This key is available "
"only in a B<request-key>(8)-style program that was passed an authorization "
"key by the kernel and ceases to be available once the requested key has been "
"instantiated; see B<request_key>(2)."
msgstr ""

#. type: TP
#: man-pages/man2/keyctl.2:117
#, no-wrap
msgid "B<KEY_SPEC_REQUESTOR_KEYRING> (since Linux 2.6.29)"
msgstr ""

#.             commit 8bbf4976b59fc9fc2861e79cab7beb3f6d647640
#. type: Plain text
#: man-pages/man2/keyctl.2:128
msgid ""
"This specifies the key ID for the B<request_key>(2)  destination keyring.  "
"This keyring is available only in a B<request-key>(8)-style program that was "
"passed an authorization key by the kernel and ceases to be available once "
"the requested key has been instantiated; see B<request_key>(2)."
msgstr ""

#.  The keyctl_get_keyring_ID.3 page says that a new key
#.  "will be created *if it is appropriate to do so**. What is the
#.  determiner for appropriate?
#.  David Howells: Some special keys such as KEY_SPEC_REQKEY_AUTH_KEY
#.  wouldn't get created but user/user-session/session keyring would
#.  be created.
#. type: Plain text
#: man-pages/man2/keyctl.2:149
msgid ""
"The behavior if the key specified in I<arg2> does not exist depends on the "
"value of I<arg3> (cast to I<int>).  If I<arg3> contains a nonzero value, "
"then\\(emif it is appropriate to do so (e.g., when looking up the user, "
"user-session, or session key)\\(ema new key is created and its real key ID "
"returned as the function result.  Otherwise, the operation fails with the "
"error B<ENOKEY>."
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:155
msgid ""
"If a valid key ID is specified in I<arg2>, and the key exists, then this "
"operation simply returns the key ID.  If the key does not exist, the call "
"fails with error B<ENOKEY>."
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:159
msgid ""
"The caller must have I<search> permission on a keyring in order for it to be "
"found."
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:165 man-pages/man2/keyctl.2:677
#: man-pages/man2/keyctl.2:709 man-pages/man2/keyctl.2:1037
#: man-pages/man2/keyctl.2:1412
msgid "The arguments I<arg4> and I<arg5> are ignored."
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:170
msgid ""
"This operation is exposed by I<libkeyutils> via the function "
"B<keyctl_get_keyring_ID>(3)."
msgstr ""

#. type: TP
#: man-pages/man2/keyctl.2:170
#, no-wrap
msgid "B<KEYCTL_JOIN_SESSION_KEYRING> (since Linux 2.6.10)"
msgstr ""

#.  This may be useful in conjunction with some sort of
#.  session management framework that is employed by the application.
#. type: Plain text
#: man-pages/man2/keyctl.2:176
msgid ""
"Replace the session keyring this process subscribes to with a new session "
"keyring."
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:183
msgid ""
"If I<arg2> is NULL, an anonymous keyring with the description \"_ses\" is "
"created and the process is subscribed to that keyring as its session "
"keyring, displacing the previous session keyring."
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:190
msgid ""
"Otherwise, I<arg2> (cast to I<char\\ *>)  is treated as the description "
"(name) of a keyring, and the behavior is as follows:"
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:200
msgid ""
"If a keyring with a matching description exists, the process will attempt to "
"subscribe to that keyring as its session keyring if possible; if that is not "
"possible, an error is returned.  In order to subscribe to the keyring, the "
"caller must have I<search> permission on the keyring."
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:204
msgid ""
"If a keyring with a matching description does not exist, then a new keyring "
"with the specified description is created, and the process is subscribed to "
"that keyring as its session keyring."
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:217
msgid ""
"This operation is exposed by I<libkeyutils> via the function "
"B<keyctl_join_session_keyring>(3)."
msgstr ""

#. type: TP
#: man-pages/man2/keyctl.2:217
#, no-wrap
msgid "B<KEYCTL_UPDATE> (since Linux 2.6.10)"
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:220
msgid "Update a key's data payload."
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:235
msgid ""
"The I<arg2> argument (cast to I<key_serial_t>)  specifies the ID of the key "
"to be updated.  The I<arg3> argument (cast to I<void\\ *>)  points to the "
"new payload and I<arg4> (cast to I<size_t>)  contains the new payload size "
"in bytes."
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:239
msgid ""
"The caller must have I<write> permission on the key specified and the key "
"type must support updating."
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:243
msgid ""
"A negatively instantiated key (see the description of B<KEYCTL_REJECT>)  can "
"be positively instantiated with this operation."
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:247 man-pages/man2/keyctl.2:322
#: man-pages/man2/keyctl.2:605 man-pages/man2/keyctl.2:836
#: man-pages/man2/keyctl.2:899 man-pages/man2/keyctl.2:1160
msgid "The I<arg5> argument is ignored."
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:252
msgid ""
"This operation is exposed by I<libkeyutils> via the function "
"B<keyctl_update>(3)."
msgstr ""

#. type: TP
#: man-pages/man2/keyctl.2:252
#, no-wrap
msgid "B<KEYCTL_REVOKE> (since Linux 2.6.10)"
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:263
msgid ""
"Revoke the key with the ID provided in I<arg2> (cast to I<key_serial_t>).  "
"The key is scheduled for garbage collection; it will no longer be findable, "
"and will be unavailable for further operations.  Further attempts to use the "
"key will fail with the error B<EKEYREVOKED>."
msgstr ""

#.  Keys with the KEY_FLAG_KEEP bit set cause an EPERM
#.  error for KEYCTL_REVOKE. Does this need to be documented?
#.  David Howells: No significance for user space.
#. type: Plain text
#: man-pages/man2/keyctl.2:272
msgid "The caller must have I<write> or I<setattr> permission on the key."
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:284
msgid ""
"This operation is exposed by I<libkeyutils> via the function "
"B<keyctl_revoke>(3)."
msgstr ""

#. type: TP
#: man-pages/man2/keyctl.2:284
#, no-wrap
msgid "B<KEYCTL_CHOWN> (since Linux 2.6.10)"
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:287
msgid "Change the ownership (user and group ID) of a key."
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:303
msgid ""
"The I<arg2> argument (cast to I<key_serial_t>)  contains the key ID.  The "
"I<arg3> argument (cast to I<uid_t>)  contains the new user ID (or -1 in case "
"the user ID shouldn't be changed).  The I<arg4> argument (cast to I<gid_t>)  "
"contains the new group ID (or -1 in case the group ID shouldn't be changed)."
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:307
msgid "The key must grant the caller I<setattr> permission."
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:313
msgid ""
"For the UID to be changed, or for the GID to be changed to a group the "
"caller is not a member of, the caller must have the B<CAP_SYS_ADMIN> "
"capability (see B<capabilities>(7))."
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:318
msgid ""
"If the UID is to be changed, the new user must have sufficient quota to "
"accept the key.  The quota deduction will be removed from the old user to "
"the new user should the UID be changed."
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:327
msgid ""
"This operation is exposed by I<libkeyutils> via the function "
"B<keyctl_chown>(3)."
msgstr ""

#. type: TP
#: man-pages/man2/keyctl.2:327
#, no-wrap
msgid "B<KEYCTL_SETPERM> (since Linux 2.6.10)"
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:337
msgid ""
"Change the permissions of the key with the ID provided in the I<arg2> "
"argument (cast to I<key_serial_t>)  to the permissions provided in the "
"I<arg3> argument (cast to I<key_perm_t>)."
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:342
msgid ""
"If the caller doesn't have the B<CAP_SYS_ADMIN> capability, it can change "
"permissions only for the keys it owns.  (More precisely: the caller's "
"filesystem UID must match the UID of the key.)"
msgstr ""

#.  FIXME Above, is it really intended that a privileged process can't
#.  override the lack of the 'setattr' permission?
#. type: Plain text
#: man-pages/man2/keyctl.2:350
msgid ""
"The key must grant I<setattr> permission to the caller I<regardless> of the "
"caller's capabilities."
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:355
msgid ""
"The permissions in I<arg3> specify masks of available operations for each of "
"the following user categories:"
msgstr ""

#. type: TP
#: man-pages/man2/keyctl.2:356
#, no-wrap
msgid "I<possessor> (since Linux 2.6.14)"
msgstr ""

#.  commit 664cceb0093b755739e56572b836a99104ee8a75
#. type: Plain text
#: man-pages/man2/keyctl.2:363
msgid ""
"This is the permission granted to a process that possesses the key (has it "
"attached searchably to one of the process's keyrings); see B<keyrings>(7)."
msgstr ""

#. type: TP
#: man-pages/man2/keyctl.2:363
#, no-wrap
msgid "I<user>"
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:367
msgid ""
"This is the permission granted to a process whose filesystem UID matches the "
"UID of the key."
msgstr ""

#. type: TP
#: man-pages/man2/keyctl.2:367
#, no-wrap
msgid "I<group>"
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:372
msgid ""
"This is the permission granted to a process whose filesystem GID or any of "
"its supplementary GIDs matches the GID of the key."
msgstr ""

#. type: TP
#: man-pages/man2/keyctl.2:372
#, no-wrap
msgid "I<other>"
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:380
msgid ""
"This is the permission granted to other processes that do not match the "
"I<user> and I<group> categories."
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:398
msgid ""
"The I<user>, I<group>, and I<other> categories are exclusive: if a process "
"matches the I<user> category, it will not receive permissions granted in the "
"I<group> category; if a process matches the I<user> or I<group> category, "
"then it will not receive permissions granted in the I<other> category."
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:407
msgid ""
"The I<possessor> category grants permissions that are cumulative with the "
"grants from the I<user>, I<group>, or I<other> category."
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:411
msgid ""
"Each permission mask is eight bits in size, with only six bits currently "
"used.  The available permissions are:"
msgstr ""

#. type: TP
#: man-pages/man2/keyctl.2:412
#, no-wrap
msgid "I<view>"
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:415
msgid "This permission allows reading attributes of a key."
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:419
msgid "This permission is required for the B<KEYCTL_DESCRIBE> operation."
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:426
msgid ""
"The permission bits for each category are B<KEY_POS_VIEW>, B<KEY_USR_VIEW>, "
"B<KEY_GRP_VIEW>, and B<KEY_OTH_VIEW>."
msgstr ""

#. type: TP
#: man-pages/man2/keyctl.2:426
#, no-wrap
msgid "I<read>"
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:429
msgid "This permission allows reading a key's payload."
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:433
msgid "This permission is required for the B<KEYCTL_READ> operation."
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:440
msgid ""
"The permission bits for each category are B<KEY_POS_READ>, B<KEY_USR_READ>, "
"B<KEY_GRP_READ>, and B<KEY_OTH_READ>."
msgstr ""

#. type: TP
#: man-pages/man2/keyctl.2:440
#, no-wrap
msgid "I<write>"
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:444
msgid ""
"This permission allows update or instantiation of a key's payload.  For a "
"keyring, it allows keys to be linked and unlinked from the keyring,"
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:453
msgid ""
"This permission is required for the B<KEYCTL_UPDATE>, B<KEYCTL_REVOKE>, "
"B<KEYCTL_CLEAR>, B<KEYCTL_LINK>, and B<KEYCTL_UNLINK> operations."
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:460
msgid ""
"The permission bits for each category are B<KEY_POS_WRITE>, "
"B<KEY_USR_WRITE>, B<KEY_GRP_WRITE>, and B<KEY_OTH_WRITE>."
msgstr ""

#. type: TP
#: man-pages/man2/keyctl.2:460
#, no-wrap
msgid "I<search>"
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:466
msgid ""
"This permission allows keyrings to be searched and keys to be found.  "
"Searches can recurse only into nested keyrings that have I<search> "
"permission set."
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:474
msgid ""
"This permission is required for the B<KEYCTL_GET_KEYRING_ID>, "
"B<KEYCTL_JOIN_SESSION_KEYRING>, B<KEYCTL_SEARCH>, and B<KEYCTL_INVALIDATE> "
"operations."
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:481
msgid ""
"The permission bits for each category are B<KEY_POS_SEARCH>, "
"B<KEY_USR_SEARCH>, B<KEY_GRP_SEARCH>, and B<KEY_OTH_SEARCH>."
msgstr ""

#. type: TP
#: man-pages/man2/keyctl.2:481
#, no-wrap
msgid "I<link>"
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:484
msgid "This permission allows a key or keyring to be linked to."
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:490
msgid ""
"This permission is required for the B<KEYCTL_LINK> and "
"B<KEYCTL_SESSION_TO_PARENT> operations."
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:497
msgid ""
"The permission bits for each category are B<KEY_POS_LINK>, B<KEY_USR_LINK>, "
"B<KEY_GRP_LINK>, and B<KEY_OTH_LINK>."
msgstr ""

#. type: TP
#: man-pages/man2/keyctl.2:497
#, no-wrap
msgid "I<setattr> (since Linux 2.6.15)."
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:500
msgid "This permission allows a key's UID, GID, and permissions mask to be changed."
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:507
msgid ""
"This permission is required for the B<KEYCTL_REVOKE>, B<KEYCTL_CHOWN>, and "
"B<KEYCTL_SETPERM> operations."
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:514
msgid ""
"The permission bits for each category are B<KEY_POS_SETATTR>, "
"B<KEY_USR_SETATTR>, B<KEY_GRP_SETATTR>, and B<KEY_OTH_SETATTR>."
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:523
msgid ""
"As a convenience, the following macros are defined as masks for all of the "
"permission bits in each of the user categories: B<KEY_POS_ALL>, "
"B<KEY_USR_ALL>, B<KEY_GRP_ALL>, and B<KEY_OTH_ALL>."
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:527
msgid "The I<arg4> and I<arg5> arguments are ignored."
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:532
msgid ""
"This operation is exposed by I<libkeyutils> via the function "
"B<keyctl_setperm>(3)."
msgstr ""

#. type: TP
#: man-pages/man2/keyctl.2:532
#, no-wrap
msgid "B<KEYCTL_DESCRIBE> (since Linux 2.6.10)"
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:535
msgid "Obtain a string describing the attributes of a specified key."
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:548
msgid ""
"The ID of the key to be described is specified in I<arg2> (cast to "
"I<key_serial_t>).  The descriptive string is returned in the buffer pointed "
"to by I<arg3> (cast to I<char\\ *>); I<arg4> (cast to I<size_t>)  specifies "
"the size of that buffer in bytes."
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:552
msgid "The key must grant the caller I<view> permission."
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:555
msgid ""
"The returned string is null-terminated and contains the following "
"information about the key:"
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:558
msgid "I<type>;I<uid>;I<gid>;I<perm>;I<description>"
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:572
msgid ""
"In the above, I<type> and I<description> are strings, I<uid> and I<gid> are "
"decimal strings, and I<perm> is a hexadecimal permissions mask.  The "
"descriptive string is written with the following format:"
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:574
#, no-wrap
msgid "    %s;%d;%d;%08x;%s\n"
msgstr ""

#.  FIXME But, the kernel does not enforce the requirement
#.  that the key description contains no semicolons!
#.  So, user space has no guarantee here??
#.  Either something more needs to be said here,
#.  or a kernel fix is required.
#. type: Plain text
#: man-pages/man2/keyctl.2:589
msgid ""
"B<Note: the intention is that the descriptive string should> B<be extensible "
"in future kernel versions>.  In particular, the I<description> field will "
"not contain semicolons; it should be parsed by working backwards from the "
"end of the string to find the last semicolon.  This allows future "
"semicolon-delimited fields to be inserted in the descriptive string in the "
"future."
msgstr ""

#.  Function commentary says it copies up to buflen bytes, but see the
#.  (buffer && buflen >= ret) condition in keyctl_describe_key() in
#.  security/keyctl.c
#. type: Plain text
#: man-pages/man2/keyctl.2:601
msgid ""
"Writing to the buffer is attempted only when I<arg3> is non-NULL and the "
"specified buffer size is large enough to accept the descriptive string "
"(including the terminating null byte).  In order to determine whether the "
"buffer size was too small, check to see if the return value of the operation "
"is greater than I<arg4>."
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:610
msgid ""
"This operation is exposed by I<libkeyutils> via the function "
"B<keyctl_describe>(3)."
msgstr ""

#. type: TP
#: man-pages/man2/keyctl.2:610
#, no-wrap
msgid "B<KEYCTL_CLEAR>"
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:613
msgid "Clear the contents of (i.e., unlink all keys from) a keyring."
msgstr ""

#.  or the error ENOTDIR results
#.  According to Documentation/security/keys.txt:
#.      This function can also be used to clear special kernel keyrings if they
#.      are appropriately marked if the user has CAP_SYS_ADMIN capability.  The
#.      DNS resolver cache keyring is an example of this.
#. type: Plain text
#: man-pages/man2/keyctl.2:625
msgid ""
"The ID of the key (which must be of keyring type)  is provided in I<arg2> "
"(cast to I<key_serial_t>)."
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:629 man-pages/man2/keyctl.2:1386
msgid "The caller must have I<write> permission on the keyring."
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:641
msgid ""
"This operation is exposed by I<libkeyutils> via the function "
"B<keyctl_clear>(3)."
msgstr ""

#. type: TP
#: man-pages/man2/keyctl.2:641
#, no-wrap
msgid "B<KEYCTL_LINK> (since Linux 2.6.10)"
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:644
msgid "Create a link from a keyring to a key."
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:653
msgid ""
"The key to be linked is specified in I<arg2> (cast to I<key_serial_t>); the "
"keyring is specified in I<arg3> (cast to I<key_serial_t>)."
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:656
msgid ""
"If a key with the same type and description is already linked in the "
"keyring, then that key is displaced from the keyring."
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:665
msgid ""
"Before creating the link, the kernel checks the nesting of the keyrings and "
"returns appropriate errors if the link would produce a cycle or if the "
"nesting of keyrings would be too deep (The limit on the nesting of keyrings "
"is determined by the kernel constant B<KEYRING_SEARCH_MAX_DEPTH>, defined "
"with the value 6, and is necessary to prevent overflows on the kernel stack "
"when recursively searching keyrings)."
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:671
msgid ""
"The caller must have I<link> permission on the key being added and I<write> "
"permission on the keyring."
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:682
msgid ""
"This operation is exposed by I<libkeyutils> via the function "
"B<keyctl_link>(3)."
msgstr ""

#. type: TP
#: man-pages/man2/keyctl.2:682
#, no-wrap
msgid "B<KEYCTL_UNLINK> (since Linux 2.6.10)"
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:685
msgid "Unlink a key from a keyring."
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:694
msgid ""
"The ID of the key to be unlinked is specified in I<arg2> (cast to "
"I<key_serial_t>); the ID of the keyring from which it is to be unlinked is "
"specified in I<arg3> (cast to I<key_serial_t>)."
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:696
msgid "If the key is not currently linked into the keyring, an error results."
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:700
msgid ""
"The caller must have I<write> permission on the keyring from which the key "
"is being removed."
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:703
msgid ""
"If the last link to a key is removed, then that key will be scheduled for "
"destruction."
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:714
msgid ""
"This operation is exposed by I<libkeyutils> via the function "
"B<keyctl_unlink>(3)."
msgstr ""

#. type: TP
#: man-pages/man2/keyctl.2:714
#, no-wrap
msgid "B<KEYCTL_SEARCH> (since Linux 2.6.10)"
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:718
msgid ""
"Search for a key in a keyring tree, returning its ID and optionally linking "
"it to a specified keyring."
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:725
msgid ""
"The tree to be searched is specified by passing the ID of the head keyring "
"in I<arg2> (cast to I<key_serial_t>).  The search is performed breadth-first "
"and recursively."
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:743
msgid ""
"The I<arg3> and I<arg4> arguments specify the key to be searched for: "
"I<arg3> (cast as I<char\\ *>)  contains the key type (a null-terminated "
"character string up to 32 bytes in size, including the terminating null "
"byte), and I<arg4> (cast as I<char\\ *>)  contains the description of the "
"key (a null-terminated character string up to 4096 bytes in size, including "
"the terminating null byte)."
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:753
msgid ""
"The source keyring must grant I<search> permission to the caller.  When "
"performing the recursive search, only keyrings that grant the caller "
"I<search> permission will be searched.  Only keys with for which the caller "
"has I<search> permission can be found."
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:755
msgid "If the key is found, its ID is returned as the function result."
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:769
msgid ""
"If the key is found and I<arg5> (cast to I<key_serial_t>)  is nonzero, then, "
"subject to the same constraints and rules as B<KEYCTL_LINK>, the key is "
"linked into the keyring whose ID is specified in I<arg5>.  If the "
"destination keyring specified in I<arg5> already contains a link to a key "
"that has the same type and description, then that link will be displaced by "
"a link to the key found by this operation."
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:776
msgid ""
"Instead of valid existing keyring IDs, the source (I<arg2>)  and destination "
"(I<arg5>)  keyrings can be one of the special keyring IDs listed under "
"B<KEYCTL_GET_KEYRING_ID>."
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:781
msgid ""
"This operation is exposed by I<libkeyutils> via the function "
"B<keyctl_search>(3)."
msgstr ""

#. type: TP
#: man-pages/man2/keyctl.2:781
#, no-wrap
msgid "B<KEYCTL_READ> (since Linux 2.6.10)"
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:784
msgid "Read the payload data of a key."
msgstr ""

#.  including KEY_SPEC_REQKEY_AUTH_KEY
#. type: Plain text
#: man-pages/man2/keyctl.2:793
msgid ""
"The ID of the key whose payload is to be read is specified in I<arg2> (cast "
"to I<key_serial_t>).  This can be the ID of an existing key, or any of the "
"special key IDs listed for B<KEYCTL_GET_KEYRING_ID>."
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:802
msgid ""
"The payload is placed in the buffer pointed by I<arg3> (cast to I<char\\ "
"*>); the size of that buffer must be specified in I<arg4> (cast to "
"I<size_t>)."
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:814
msgid ""
"The returned data will be processed for presentation according to the key "
"type.  For example, a keyring will return an array of I<key_serial_t> "
"entries representing the IDs of all the keys that are linked to it.  The "
"I<user> key type will return its data as is.  If a key type does not "
"implement this function, the operation fails with the error B<EOPNOTSUPP>."
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:825
msgid ""
"If I<arg3> is not NULL, as much of the payload data as will fit is copied "
"into the buffer.  On a successful return, the return value is always the "
"total size of the payload data.  To determine whether the buffer was of "
"sufficient size, check to see that the return value is less than or equal to "
"the value supplied in I<arg4>."
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:832
msgid ""
"The key must either grant the caller I<read> permission, or grant the caller "
"I<search> permission when searched for from the process keyrings (i.e., the "
"key is possessed)."
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:841
msgid ""
"This operation is exposed by I<libkeyutils> via the function "
"B<keyctl_read>(3)."
msgstr ""

#. type: TP
#: man-pages/man2/keyctl.2:841
#, no-wrap
msgid "B<KEYCTL_INSTANTIATE> (since Linux 2.6.10)"
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:844
msgid "(Positively) instantiate an uninstantiated key with a specified payload."
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:849
msgid ""
"The ID of the key to be instantiated is provided in I<arg2> (cast to "
"I<key_serial_t>)."
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:858
msgid ""
"The key payload is specified in the buffer pointed to by I<arg3> (cast to "
"I<void\\ *>); the size of that buffer is specified in I<arg4> (cast to "
"I<size_t>)."
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:861
msgid ""
"The payload may be a NULL pointer and the buffer size may be 0 if this is "
"supported by the key type (e.g., it is a keyring)."
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:864
msgid ""
"The operation may be fail if the payload data is in the wrong format or is "
"otherwise invalid."
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:873
msgid ""
"If I<arg5> (cast to I<key_serial_t>)  is nonzero, then, subject to the same "
"constraints and rules as B<KEYCTL_LINK>, the instantiated key is linked into "
"the keyring whose ID specified in I<arg5>."
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:883 man-pages/man2/keyctl.2:1266
msgid ""
"The caller must have the appropriate authorization key, and once the "
"uninstantiated key has been instantiated, the authorization key is revoked.  "
"In other words, this operation is available only from a "
"B<request-key>(8)-style program.  See B<request_key>(2)  for an explanation "
"of uninstantiated keys and key instantiation."
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:888
msgid ""
"This operation is exposed by I<libkeyutils> via the function "
"B<keyctl_instantiate>(3)."
msgstr ""

#. type: TP
#: man-pages/man2/keyctl.2:888
#, no-wrap
msgid "B<KEYCTL_NEGATE> (since Linux 2.6.10)"
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:891
msgid "Negatively instantiate an uninstantiated key."
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:893
msgid "This operation is equivalent to the call:"
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:895
#, no-wrap
msgid "    keyctl(KEYCTL_REJECT, arg2, arg3, ENOKEY, arg4);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:904
msgid ""
"This operation is exposed by I<libkeyutils> via the function "
"B<keyctl_negate>(3)."
msgstr ""

#. type: TP
#: man-pages/man2/keyctl.2:904
#, no-wrap
msgid "B<KEYCTL_SET_REQKEY_KEYRING> (since Linux 2.6.13)"
msgstr ""

#.  I.e., calls to the kernel's internal request_key() interface,
#.  which is distinct from the request_key(2) system call (which
#.  ultimately employs the kernel-internal interface).
#. type: Plain text
#: man-pages/man2/keyctl.2:918
msgid ""
"Set the default keyring to which implicitly requested keys will be linked "
"for this thread, and return the previous setting.  Implicit key requests are "
"those made by internal kernel components, such as can occur when, for "
"example, opening files on an AFS or NFS filesystem.  Setting the default "
"keyring also has an effect when requesting a key from user space; see "
"B<request_key>(2)  for details."
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:925
msgid ""
"The I<arg2> argument (cast to I<int>)  should contain one of the following "
"values, to specify the new default keyring:"
msgstr ""

#. type: TP
#: man-pages/man2/keyctl.2:926
#, no-wrap
msgid "B<KEY_REQKEY_DEFL_NO_CHANGE>"
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:931
msgid ""
"Don't change the default keyring.  This can be used to discover the current "
"default keyring (without changing it)."
msgstr ""

#. type: TP
#: man-pages/man2/keyctl.2:931
#, no-wrap
msgid "B<KEY_REQKEY_DEFL_DEFAULT>"
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:939
msgid ""
"This selects the default behaviour, which is to use the thread-specific "
"keyring if there is one, otherwise the process-specific keyring if there is "
"one, otherwise the session keyring if there is one, otherwise the "
"UID-specific session keyring, otherwise the user-specific keyring."
msgstr ""

#. type: TP
#: man-pages/man2/keyctl.2:939
#, no-wrap
msgid "B<KEY_REQKEY_DEFL_THREAD_KEYRING>"
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:944
msgid ""
"Use the thread-specific keyring (B<thread-keyring>(7))  as the new default "
"keyring."
msgstr ""

#. type: TP
#: man-pages/man2/keyctl.2:944
#, no-wrap
msgid "B<KEY_REQKEY_DEFL_PROCESS_KEYRING>"
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:949
msgid ""
"Use the process-specific keyring (B<process-keyring>(7))  as the new default "
"keyring."
msgstr ""

#. type: TP
#: man-pages/man2/keyctl.2:949
#, no-wrap
msgid "B<KEY_REQKEY_DEFL_SESSION_KEYRING>"
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:954
msgid ""
"Use the session-specific keyring (B<session-keyring>(7))  as the new default "
"keyring."
msgstr ""

#. type: TP
#: man-pages/man2/keyctl.2:954
#, no-wrap
msgid "B<KEY_REQKEY_DEFL_USER_KEYRING>"
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:959
msgid ""
"Use the UID-specific keyring (B<user-keyring>(7))  as the new default "
"keyring."
msgstr ""

#. type: TP
#: man-pages/man2/keyctl.2:959
#, no-wrap
msgid "B<KEY_REQKEY_DEFL_USER_SESSION_KEYRING>"
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:964
msgid ""
"Use the UID-specific session keyring (B<user-session-keyring>(7))  as the "
"new default keyring."
msgstr ""

#. type: TP
#: man-pages/man2/keyctl.2:964
#, no-wrap
msgid "B<KEY_REQKEY_DEFL_REQUESTOR_KEYRING> (since Linux 2.6.29)"
msgstr ""

#.  8bbf4976b59fc9fc2861e79cab7beb3f6d647640
#.  FIXME The preceding explanation needs to be expanded.
#.  Is the following correct:
#
#. 	The requestor keyring is the dest_keyring that
#. 	was supplied to a call to request_key(2)?
#
#.  David Howells said: to be checked
#. type: Plain text
#: man-pages/man2/keyctl.2:975
msgid "Use the requestor keyring."
msgstr ""

#.  (including the still-unsupported KEY_REQKEY_DEFL_GROUP_KEYRING)
#. type: Plain text
#: man-pages/man2/keyctl.2:979
msgid "All other values are invalid."
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:991
msgid ""
"The setting controlled by this operation is inherited by the child of "
"B<fork>(2)  and preserved across B<execve>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:996
msgid ""
"This operation is exposed by I<libkeyutils> via the function "
"B<keyctl_set_reqkey_keyring>(3)."
msgstr ""

#. type: TP
#: man-pages/man2/keyctl.2:996
#, no-wrap
msgid "B<KEYCTL_SET_TIMEOUT> (since Linux 2.6.16)"
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:999
msgid "Set a timeout on a key."
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:1010
msgid ""
"The ID of the key is specified in I<arg2> (cast to I<key_serial_t>).  The "
"timeout value, in seconds from the current time, is specified in I<arg3> "
"(cast to I<unsigned int>).  The timeout is measured against the realtime "
"clock."
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:1012
msgid "Specifying the timeout value as 0 clears any existing timeout on the key."
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:1017
msgid ""
"The I</proc/keys> file displays the remaining time until each key will "
"expire.  (This is the only method of discovering the timeout on a key.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:1023
msgid ""
"The caller must either have the I<setattr> permission on the key or hold an "
"instantiation authorization token for the key (see B<request_key>(2))."
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:1028
msgid ""
"The key and any links to the key will be automatically garbage collected "
"after the timeout expires.  Subsequent attempts to access the key will then "
"fail with the error B<EKEYEXPIRED>."
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:1031
msgid ""
"This operation cannot be used to set timeouts on revoked, expired, or "
"negatively instantiated keys."
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:1042
msgid ""
"This operation is exposed by I<libkeyutils> via the function "
"B<keyctl_set_timeout>(3)."
msgstr ""

#. type: TP
#: man-pages/man2/keyctl.2:1042
#, no-wrap
msgid "B<KEYCTL_ASSUME_AUTHORITY> (since Linux 2.6.16)"
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:1046
msgid ""
"Assume (or divest) the authority for the calling thread to instantiate a "
"key."
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:1053
msgid ""
"The I<arg2> argument (cast to I<key_serial_t>)  specifies either a nonzero "
"key ID to assume authority, or the value 0 to divest authority."
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:1066
msgid ""
"If I<arg2> is nonzero, then it specifies the ID of an uninstantiated key for "
"which authority is to be assumed.  That key can then be instantiated using "
"one of B<KEYCTL_INSTANTIATE>, B<KEYCTL_INSTANTIATE_IOV>, B<KEYCTL_REJECT>, "
"or B<KEYCTL_NEGATE>.  Once the key has been instantiated, the thread is "
"automatically divested of authority to instantiate the key."
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:1080
msgid ""
"Authority over a key can be assumed only if the calling thread has present "
"in its keyrings the authorization key that is associated with the specified "
"key.  (In other words, the B<KEYCTL_ASSUME_AUTHORITY> operation is available "
"only from a B<request-key>(8)-style program; see B<request_key>(2)  for an "
"explanation of how this operation is used.)  The caller must have I<search> "
"permission on the authorization key."
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:1087
msgid ""
"If the specified key has a matching authorization key, then the ID of that "
"key is returned.  The authorization key can be read (B<KEYCTL_READ>)  to "
"obtain the callout information passed to B<request_key>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:1092
msgid ""
"If the ID given in I<arg2> is 0, then the currently assumed authority is "
"cleared (divested), and the value 0 is returned."
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:1104
msgid ""
"The B<KEYCTL_ASSUME_AUTHORITY> mechanism allows a program such as "
"B<request-key>(8)  to assume the necessary authority to instantiate a new "
"uninstantiated key that was created as a consequence of a call to "
"B<request_key>(2).  For further information, see B<request_key>(2)  and the "
"kernel source file I<Documentation/security/keys-request-key.txt>."
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:1116
msgid ""
"This operation is exposed by I<libkeyutils> via the function "
"B<keyctl_assume_authority>(3)."
msgstr ""

#. type: TP
#: man-pages/man2/keyctl.2:1116
#, no-wrap
msgid "B<KEYCTL_GET_SECURITY> (since Linux 2.6.26)"
msgstr ""

#.  commit 70a5bb72b55e82fbfbf1e22cae6975fac58a1e2d
#. type: Plain text
#: man-pages/man2/keyctl.2:1120
msgid "Get the LSM (Linux Security Module) security label of the specified key."
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:1134
msgid ""
"The ID of the key whose security label is to be fetched is specified in "
"I<arg2> (cast to I<key_serial_t>).  The security label (terminated by a null "
"byte)  will be placed in the buffer pointed to by I<arg3> argument (cast to "
"I<char\\ *>); the size of the buffer must be provided in I<arg4> (cast to "
"I<size_t>)."
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:1143
msgid ""
"If I<arg3> is specified as NULL or the buffer size specified in I<arg4> is "
"too small, the full size of the security label string (including the "
"terminating null byte)  is returned as the function result, and nothing is "
"copied to the buffer."
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:1147
msgid "The caller must have I<view> permission on the specified key."
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:1151
msgid ""
"The returned security label string will be rendered in a form appropriate to "
"the LSM in force.  For example, with SELinux, it may look like:"
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:1153
#, no-wrap
msgid "    unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:1156
msgid ""
"If no LSM is currently in force, then an empty string is placed in the "
"buffer."
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:1167
msgid ""
"This operation is exposed by I<libkeyutils> via the functions "
"B<keyctl_get_security>(3)  and B<keyctl_get_security_alloc>(3)."
msgstr ""

#. type: TP
#: man-pages/man2/keyctl.2:1167
#, no-wrap
msgid "B<KEYCTL_SESSION_TO_PARENT> (since Linux 2.6.32)"
msgstr ""

#.  commit ee18d64c1f632043a02e6f5ba5e045bb26a5465f
#.  What is the use case for KEYCTL_SESSION_TO_PARENT?
#.  David Howells: the Process Authentication Groups people requested this,
#.  but then didn't use it; maybe there are no users.
#. type: Plain text
#: man-pages/man2/keyctl.2:1177
msgid ""
"Replace the session keyring to which the I<parent> of the calling process "
"subscribes with the session keyring of the calling process."
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:1180
msgid ""
"The keyring will be replaced in the parent process at the point where the "
"parent next transitions from kernel space to user space."
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:1190
msgid ""
"The keyring must exist and must grant the caller I<link> permission.  The "
"parent process must be single-threaded and have the same effective ownership "
"as this process and must not be set-user-ID or set-group-ID.  The UID of the "
"parent process's existing session keyring (f it has one), as well as the UID "
"of the caller's session keyring much match the caller's effective UID."
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:1198
msgid ""
"The fact that it is the parent process that is affected by this operation "
"allows a program such as the shell to start a child process that uses this "
"operation to change the shell's session keyring.  (This is what the "
"B<keyctl>(1)  B<new_session> command does.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:1211
msgid ""
"This operation is exposed by I<libkeyutils> via the function "
"B<keyctl_session_to_parent>(3)."
msgstr ""

#. type: TP
#: man-pages/man2/keyctl.2:1211
#, no-wrap
msgid "B<KEYCTL_REJECT> (since Linux 2.6.39)"
msgstr ""

#.  commit fdd1b94581782a2ddf9124414e5b7a5f48ce2f9c
#. type: Plain text
#: man-pages/man2/keyctl.2:1219
msgid ""
"Mark a key as negatively instantiated and set an expiration timer on the "
"key.  This operation provides a superset of the functionality of the earlier "
"B<KEYCTL_NEGATE> operation."
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:1239
msgid ""
"The ID of the key that is to be negatively instantiated is specified in "
"I<arg2> (cast to I<key_serial_t>).  The I<arg3> (cast to I<unsigned int>)  "
"argument specifies the lifetime of the key, in seconds.  The I<arg4> "
"argument (cast to I<unsigned int>)  specifies the error to be returned when "
"a search hits this key; typically, this is one of B<EKEYREJECTED>, "
"B<EKEYREVOKED>, or B<EKEYEXPIRED>."
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:1249
msgid ""
"If I<arg5> (cast to I<key_serial_t>)  is nonzero, then, subject to the same "
"constraints and rules as B<KEYCTL_LINK>, the negatively instantiated key is "
"linked into the keyring whose ID is specified in I<arg5>."
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:1256
msgid ""
"The caller must have the appropriate authorization key.  In other words, "
"this operation is available only from a B<request-key>(8)-style program.  "
"See B<request_key>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:1271
msgid ""
"This operation is exposed by I<libkeyutils> via the function "
"B<keyctl_reject>(3)."
msgstr ""

#. type: TP
#: man-pages/man2/keyctl.2:1271
#, no-wrap
msgid "B<KEYCTL_INSTANTIATE_IOV> (since Linux 2.6.39)"
msgstr ""

#.  commit ee009e4a0d4555ed522a631bae9896399674f063
#. type: Plain text
#: man-pages/man2/keyctl.2:1276
msgid ""
"Instantiate an uninstantiated key with a payload specified via a vector of "
"buffers."
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:1282
msgid ""
"This operation is the same as B<KEYCTL_INSTANTIATE>, but the payload data is "
"specified as an array of I<iovec> structures:"
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:1289
#, no-wrap
msgid ""
"struct iovec {\n"
"    void  *iov_base;    /* Starting address of buffer */\n"
"    size_t iov_len;     /* Size of buffer (in bytes) */\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:1300
msgid ""
"The pointer to the payload vector is specified in I<arg3> (cast as I<const "
"struct iovec\\ *>).  The number of items in the vector is specified in "
"I<arg4> (cast as I<unsigned int>)."
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:1309
msgid ""
"The I<arg2> (key ID)  and I<arg5> (keyring ID)  are interpreted as for "
"B<KEYCTL_INSTANTIATE>."
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:1314
msgid ""
"This operation is exposed by I<libkeyutils> via the function "
"B<keyctl_instantiate_iov>(3)."
msgstr ""

#. type: TP
#: man-pages/man2/keyctl.2:1314
#, no-wrap
msgid "B<KEYCTL_INVALIDATE> (since Linux 3.5)"
msgstr ""

#.  commit fd75815f727f157a05f4c96b5294a4617c0557da
#. type: Plain text
#: man-pages/man2/keyctl.2:1318
msgid "Mark a key as invalid."
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:1323
msgid ""
"The ID of the key to be invalidated is specified in I<arg2> (cast to "
"I<key_serial_t>)."
msgstr ""

#.  CAP_SYS_ADMIN is permitted to invalidate certain special keys
#. type: Plain text
#: man-pages/man2/keyctl.2:1329
msgid "To invalidate a key, the caller must have I<search> permission on the key."
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:1337
msgid ""
"This operation marks the key as invalid and schedules immediate garbage "
"collection.  The garbage collector removes the invalidated key from all "
"keyrings and deletes the key when its reference count reaches zero.  After "
"this operation, the key will be ignored by all searches, even if it is not "
"yet deleted."
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:1343
msgid ""
"Keys that are marked invalid become invisible to normal key operations "
"immediately, though they are still visible in I</proc/keys> (marked with an "
"'i' flag)  until they are actually removed."
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:1355
msgid ""
"This operation is exposed by I<libkeyutils> via the function "
"B<keyctl_invalidate>(3)."
msgstr ""

#. type: TP
#: man-pages/man2/keyctl.2:1355
#, no-wrap
msgid "B<KEYCTL_GET_PERSISTENT> (since Linux 3.13)"
msgstr ""

#.  commit f36f8c75ae2e7d4da34f4c908cebdb4aa42c977e
#. type: Plain text
#: man-pages/man2/keyctl.2:1361
msgid ""
"Get the persistent keyring (B<persistent-keyring>(7))  for a specified user "
"and link it to a specified keyring."
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:1371
msgid ""
"The user ID is specified in I<arg2> (cast to I<uid_t>).  If the value -1 is "
"specified, the caller's real user ID is used.  The ID of the destination "
"keyring is specified in I<arg3> (cast to I<key_serial_t>)."
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:1377
msgid ""
"The caller must have the B<CAP_SETUID> capability in its user namespace in "
"order to fetch the persistent keyring for a user ID that does not match "
"either the real or effective user ID of the caller."
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:1382
msgid ""
"If the call is successful, a link to the persistent keyring is added to the "
"keyring whose ID was specified in I<arg3>."
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:1389
msgid ""
"The persistent keyring will be created by the kernel if it does not yet "
"exist."
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:1394
msgid ""
"Each time the B<KEYCTL_GET_PERSISTENT> operation is performed, the "
"persistent keyring will have its expiration timeout reset to the value in:"
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:1398
#, no-wrap
msgid "/proc/sys/kernel/keys/persistent_keyring_expiry\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:1404
msgid ""
"Should the timeout be reached, the persistent keyring will be removed and "
"everything it pins can then be garbage collected."
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:1406
msgid "Persistent keyrings were added to Linux in kernel version 3.13."
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:1417
msgid ""
"This operation is exposed by I<libkeyutils> via the function "
"B<keyctl_get_persistent>(3)."
msgstr ""

#. type: TP
#: man-pages/man2/keyctl.2:1417
#, no-wrap
msgid "B<KEYCTL_DH_COMPUTE> (since Linux 4.7)"
msgstr ""

#.  commit ddbb41148724367394d0880c516bfaeed127b52e
#. type: Plain text
#: man-pages/man2/keyctl.2:1422
msgid ""
"Compute a Diffie-Hellman shared secret or public key, optionally applying "
"key derivation function (KDF) to the result."
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:1430
msgid ""
"The I<arg2> argument is a pointer to a set of parameters containing serial "
"numbers for three I<\"user\"> keys used in the Diffie-Hellman calculation, "
"packaged in a structure of the following form:"
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:1439
#, no-wrap
msgid ""
"struct keyctl_dh_params {\n"
"    int32_t private; /* The local private key */\n"
"    int32_t prime; /* The prime, known to both parties */\n"
"    int32_t base;  /* The base integer: either a shared\n"
"                      generator or the remote public key */\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:1447
msgid ""
"Each of the three keys specified in this structure must grant the caller "
"I<read> permission.  The payloads of these keys are used to calculate the "
"Diffie-Hellman result as:"
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:1449
#, no-wrap
msgid "    base ^ private mod prime\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:1452
msgid ""
"If the base is the shared generator, the result is the local public key.  If "
"the base is the remote public key, the result is the shared secret."
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:1462
msgid ""
"The I<arg3> argument (cast to I<char\\ *>)  points to a buffer where the "
"result of the calculation is placed.  The size of that buffer is specified "
"in I<arg4> (cast to I<size_t>)."
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:1471
msgid ""
"The buffer must be large enough to accommodate the output data, otherwise an "
"error is returned.  If I<arg4> is specified zero, in which case the buffer "
"is not used and the operation returns the minimum required buffer size "
"(i.e., the length of the prime)."
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:1477
msgid ""
"Diffie-Hellman computations can be performed in user space, but require a "
"multiple-precision integer (MPI) library.  Moving the implementation into "
"the kernel gives access to the kernel MPI implementation, and allows access "
"to secure or acceleration hardware."
msgstr ""

#.  commit f1c316a3ab9d24df6022682422fe897492f2c0c8
#. type: Plain text
#: man-pages/man2/keyctl.2:1485
msgid ""
"Adding support for DH computation to the B<keyctl>()  system call was "
"considered a good fit due to the DH algorithm's use for deriving shared "
"keys; it also allows the type of the key to determine which DH "
"implementation (software or hardware) is appropriate."
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:1493
msgid ""
"If the I<arg5> argument is B<NULL>, then the DH result itself is returned.  "
"Otherwise (since Linux 4.12), it is a pointer to a structure which specifies "
"parameters of the KDF operation to be applied:"
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:1502
#, no-wrap
msgid ""
"struct keyctl_kdf_params {\n"
"    char *hashname;     /* Hash algorithm name */\n"
"    char *otherinfo;    /* SP800-56A OtherInfo */\n"
"    __u32 otherinfolen; /* Length of otherinfo data */\n"
"    __u32 __spare[8];   /* Reserved */\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:1519
msgid ""
"The I<hashname> field is a null-terminated string which specifies a hash "
"name (available in the kernel's crypto API; the list of the hashes available "
"is rather tricky to observe; please refer to the E<.UR "
"https://www.kernel.org\\:/doc\\:/html\\:/latest\\:/crypto\\:/architecture.html> "
"\"Kernel Crypto API Architecture\" E<.UE> documentation for the information "
"regarding how hash names are constructed and your kernel's source and "
"configuration regarding what ciphers and templates with type "
"B<CRYPTO_ALG_TYPE_SHASH> are available)  to be applied to DH result in KDF "
"operation."
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:1534
msgid ""
"The I<otherinfo> field is an I<OtherInfo> data as described in SP800-56A "
"section 5.8.1.2 and is algorithm-specific.  This data is concatenated with "
"the result of DH operation and is provided as an input to the KDF "
"operation.  Its size is provided in the I<otherinfolen> field and is limited "
"by B<KEYCTL_KDF_MAX_OI_LEN> constant that defined in "
"I<security/keys/internal.h> to a value of 64."
msgstr ""

#.  commit 4f9dabfaf8df971f8a3b6aa324f8f817be38d538
#. type: Plain text
#: man-pages/man2/keyctl.2:1542
msgid ""
"The B<__spare> field is currently unused.  It was ignored until Linux 4.13 "
"(but still should be user-addressable since it is copied to the kernel), and "
"should contain zeros since Linux 4.13."
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:1545
msgid ""
"The KDF implementation complies with SP800-56A as well as with SP800-108 "
"(the counter KDF)."
msgstr ""

#.  keyutils commit 742c9d7b94051d3b21f9f61a73ed6b5f3544cb82
#.  keyutils commit d68a981e5db41d059ac782071c35d1e8f3aaf61c
#. type: Plain text
#: man-pages/man2/keyctl.2:1554
msgid ""
"This operation is exposed by I<libkeyutils> (from version 1.5.10 onwards) "
"via the functions B<keyctl_dh_compute>(3)  and "
"B<keyctl_dh_compute_alloc>(3)."
msgstr ""

#. type: TP
#: man-pages/man2/keyctl.2:1554
#, no-wrap
msgid "B<KEYCTL_RESTRICT_KEYRING> (since Linux 4.12)"
msgstr ""

#.  commit 6563c91fd645556c7801748f15bc727c77fcd311
#.  commit 7228b66aaf723a623e578aa4db7d083bb39546c9
#. type: Plain text
#: man-pages/man2/keyctl.2:1572
msgid ""
"Apply a key-linking restriction to the keyring with the ID provided in "
"I<arg2> (cast to I<key_serial_t>).  The caller must have I<setattr> "
"permission on the key.  If I<arg3> is NULL, any attempt to add a key to the "
"keyring is blocked; otherwise it contains a pointer to a string with a key "
"type name and I<arg4> contains a pointer to string that describes the "
"type-specific restriction.  As of Linux 4.12, only the type \"asymmetric\" "
"has restrictions defined:"
msgstr ""

#. type: TP
#: man-pages/man2/keyctl.2:1573
#, no-wrap
msgid "B<builtin_trusted>"
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:1577
msgid ""
"Allows only keys that are signed by a key linked to the built-in keyring "
"(\".builtin_trusted_keys\")."
msgstr ""

#. type: TP
#: man-pages/man2/keyctl.2:1577
#, no-wrap
msgid "B<builtin_and_secondary_trusted>"
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:1582
msgid ""
"Allows only keys that are signed by a key linked to the secondary keyring "
"(\".secondary_trusted_keys\") or, by extension, a key in a built-in keyring, "
"as the latter is linked to the former."
msgstr ""

#. type: TP
#: man-pages/man2/keyctl.2:1582
#, no-wrap
msgid "B<key_or_keyring:>I<key>"
msgstr ""

#. type: TQ
#: man-pages/man2/keyctl.2:1584
#, no-wrap
msgid "B<key_or_keyring:>I<key>B<:chain>"
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:1590
msgid ""
"If I<key> specifies the ID of a key of type \"asymmetric\", then only keys "
"that are signed by this key are allowed."
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:1596
msgid ""
"If I<key> specifies the ID of a keyring, then only keys that are signed by a "
"key linked to this keyring are allowed."
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:1601
msgid ""
"If \":chain\" is specified, keys that are signed by a keys linked to the "
"destination keyring (that is, the keyring with the ID specified in the "
"I<arg2> argument) are also allowed."
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:1605
msgid ""
"Note that a restriction can be configured only once for the specified "
"keyring; once a restriction is set, it can't be overridden."
msgstr ""

#.  FIXME Document KEYCTL_RESTRICT_KEYRING, added in Linux 4.12
#.      commit 6563c91fd645556c7801748f15bc727c77fcd311
#.      Author: Mat Martineau <mathew.j.martineau@linux.intel.com>
#.  See Documentation/security/keys.txt
#. type: Plain text
#: man-pages/man2/keyctl.2:1613
msgid "The argument I<arg5> is ignored."
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:1615 man-pages/man2/bpf.2:1016
#: man-pages/man2/fcntl.2:1612
msgid "For a successful call, the return value depends on the operation:"
msgstr ""

#. type: TP
#: man-pages/man2/keyctl.2:1615
#, no-wrap
msgid "B<KEYCTL_GET_KEYRING_ID>"
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:1618
msgid "The ID of the requested keyring."
msgstr ""

#. type: TP
#: man-pages/man2/keyctl.2:1618
#, no-wrap
msgid "B<KEYCTL_JOIN_SESSION_KEYRING>"
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:1621
msgid "The ID of the joined session keyring."
msgstr ""

#. type: TP
#: man-pages/man2/keyctl.2:1621
#, no-wrap
msgid "B<KEYCTL_DESCRIBE>"
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:1625
msgid ""
"The size of the description (including the terminating null byte), "
"irrespective of the provided buffer size."
msgstr ""

#. type: TP
#: man-pages/man2/keyctl.2:1625
#, no-wrap
msgid "B<KEYCTL_SEARCH>"
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:1628
msgid "The ID of the key that was found."
msgstr ""

#. type: TP
#: man-pages/man2/keyctl.2:1628
#, no-wrap
msgid "B<KEYCTL_READ>"
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:1632
msgid ""
"The amount of data that is available in the key, irrespective of the "
"provided buffer size."
msgstr ""

#. type: TP
#: man-pages/man2/keyctl.2:1632
#, no-wrap
msgid "B<KEYCTL_SET_REQKEY_KEYRING>"
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:1638
msgid ""
"The ID of the previous default keyring to which implicitly requested keys "
"were linked (one of B<KEY_REQKEY_DEFL_USER_*>)."
msgstr ""

#. type: TP
#: man-pages/man2/keyctl.2:1638
#, no-wrap
msgid "B<KEYCTL_ASSUME_AUTHORITY>"
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:1643
msgid ""
"Either 0, if the ID given was 0, or the ID of the authorization key matching "
"the specified key, if a nonzero key ID was provided."
msgstr ""

#. type: TP
#: man-pages/man2/keyctl.2:1643
#, no-wrap
msgid "B<KEYCTL_GET_SECURITY>"
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:1648
msgid ""
"The size of the LSM security label string (including the terminating null "
"byte), irrespective of the provided buffer size."
msgstr ""

#. type: TP
#: man-pages/man2/keyctl.2:1648
#, no-wrap
msgid "B<KEYCTL_GET_PERSISTENT>"
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:1651
msgid "The ID of the persistent keyring."
msgstr ""

#. type: TP
#: man-pages/man2/keyctl.2:1651
#, no-wrap
msgid "B<KEYCTL_DH_COMPUTE>"
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:1656
msgid ""
"The number of bytes copied to the buffer, or, if I<arg4> is 0, the required "
"buffer size."
msgstr ""

#. type: TP
#: man-pages/man2/keyctl.2:1656
#, no-wrap
msgid "All other operations"
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:1659 man-pages/man2/bpf.2:1025
#: man-pages/man2/fcntl.2:1644
msgid "Zero."
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:1663
msgid ""
"On error, -1 is returned, and I<errno> is set appropriately to indicate the "
"error."
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:1667
msgid "The requested operation wasn't permitted."
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:1673
msgid ""
"I<operation> was B<KEYCTL_DH_COMPUTE> and there was an error during crypto "
"module initialization."
msgstr ""

#. type: TP
#: man-pages/man2/keyctl.2:1673 man-pages/man2/keyctl.2:1679
#: man-pages/man2/fcntl.2:1688 man-pages/man2/futex.2:1446
#: man-pages/man2/futex.2:1454
#, no-wrap
msgid "B<EDEADLK>"
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:1679
msgid ""
"I<operation> was B<KEYCTL_LINK> and the requested link would result in a "
"cycle."
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:1685
msgid ""
"I<operation> was B<KEYCTL_RESTRICT_KEYRING> and the requested keyring "
"restriction would result in a cycle."
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:1689
msgid ""
"The key quota for the caller's user would be exceeded by creating a key or "
"linking it to the keyring."
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:1697
msgid ""
"I<operation> was B<KEYCTL_RESTRICT_KEYRING> and keyring provided in I<arg2> "
"argument already has a restriction set."
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:1703
msgid "I<operation> was B<KEYCTL_DH_COMPUTE> and one of the following has failed:"
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:1710
msgid ""
"copying of the I<struct keyctl_dh_params>, provided in the I<arg2> argument, "
"from user space;"
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:1717
msgid ""
"copying of the I<struct keyctl_kdf_params>, provided in the non-NULL I<arg5> "
"argument, from user space (in case kernel supports performing KDF operation "
"on DH operation result);"
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:1723
msgid ""
"copying of data pointed by the I<hashname> field of the I<struct "
"keyctl_kdf_params> from user space;"
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:1731
msgid ""
"copying of data pointed by the I<otherinfo> field of the I<struct "
"keyctl_kdf_params> from user space if the I<otherinfolen> field was nonzero;"
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:1733
msgid "copying of the result to user space."
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:1741
msgid ""
"I<operation> was B<KEYCTL_SETPERM> and an invalid permission bit was "
"specified in I<arg3>."
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:1756
msgid ""
"I<operation> was B<KEYCTL_SEARCH> and the size of the description in I<arg4> "
"(including the terminating null byte) exceeded 4096 bytes.  size of the "
"string (including the terminating null byte) specified in I<arg3> (the key "
"type)  or I<arg4> (the key description)  exceeded the limit (32 bytes and "
"4096 bytes respectively)."
msgstr ""

#. type: TP
#: man-pages/man2/keyctl.2:1756
#, no-wrap
msgid "B<EINVAL> (Linux kernels before 4.12)"
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:1764
msgid "I<operation> was B<KEYCTL_DH_COMPUTE>, argument I<arg5> was non-NULL."
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:1770
msgid ""
"I<operation> was B<KEYCTL_DH_COMPUTE> And the digest size of the hashing "
"algorithm supplied is zero."
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:1777
msgid ""
"I<operation> was B<KEYCTL_DH_COMPUTE> and the buffer size provided is not "
"enough to hold the result.  Provide 0 as a buffer size in order to obtain "
"the minimum buffer size."
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:1790
msgid ""
"I<operation> was B<KEYCTL_DH_COMPUTE> and the hash name provided in the "
"I<hashname> field of the I<struct keyctl_kdf_params> pointed by I<arg5> "
"argument is too big (the limit is implementation-specific and varies between "
"kernel versions, but it is deemed big enough for all valid algorithm names)."
msgstr ""

#.  commit 4f9dabfaf8df971f8a3b6aa324f8f817be38d538
#. type: Plain text
#: man-pages/man2/keyctl.2:1803
msgid ""
"I<operation> was B<KEYCTL_DH_COMPUTE> and the I<__spare> field of the "
"I<struct keyctl_kdf_params> provided in the I<arg5> argument contains "
"nonzero values."
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:1806
msgid "An expired key was found or specified."
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:1809
msgid "A rejected key was found or specified."
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:1812
msgid "A revoked key was found or specified."
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:1819
msgid ""
"I<operation> was B<KEYCTL_LINK> and the requested link would cause the "
"maximum nesting depth for keyrings to be exceeded."
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:1836
msgid ""
"I<operation> was B<KEYCTL_DH_COMPUTE> and the buffer length exceeds "
"B<KEYCTL_KDF_MAX_OUTPUT_LEN> (which is 1024 currently)  or the "
"I<otherinfolen> field of the I<struct keyctl_kdf_parms> passed in I<arg5> "
"exceeds B<KEYCTL_KDF_MAX_OI_LEN> (which is 64 currently)."
msgstr ""

#. type: TP
#: man-pages/man2/keyctl.2:1836
#, no-wrap
msgid "B<ENFILE> (Linux kernels before 3.13)"
msgstr ""

#.  commit b2a4df200d570b2c33a57e1ebfa5896e4bc81b69
#. type: Plain text
#: man-pages/man2/keyctl.2:1846
msgid ""
"I<operation> was B<KEYCTL_LINK> and the keyring is full.  (Before Linux "
"3.13, the available space for storing keyring links was limited to a single "
"page of memory; since Linux 3.13, there is no fixed limit.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:1852
msgid ""
"I<operation> was B<KEYCTL_UNLINK> and the key to be unlinked isn't linked to "
"the keyring."
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:1864
msgid ""
"I<operation> was B<KEYCTL_DH_COMPUTE> and the hashing algorithm specified in "
"the I<hashname> field of the I<struct keyctl_kdf_params> pointed by I<arg5> "
"argument hasn't been found."
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:1872
msgid ""
"I<operation> was B<KEYCTL_RESTRICT_KEYRING> and the type provided in I<arg3> "
"argument doesn't support setting key linking restrictions."
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:1875
msgid "No matching key was found or an invalid key was specified."
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:1886
msgid ""
"The value B<KEYCTL_GET_KEYRING_ID> was specified in I<operation>, the key "
"specified in I<arg2> did not exist, and I<arg3> was zero (meaning don't "
"create the key if it didn't exist)."
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:1890
msgid ""
"One of kernel memory allocation routines failed during the execution of the "
"syscall."
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:1894
msgid ""
"A key of keyring type was expected but the ID of a key with a different type "
"was provided."
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:1902
msgid ""
"I<operation> was B<KEYCTL_READ> and the key type does not support reading "
"(e.g., the type is I<\"login\">)."
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:1908
msgid ""
"I<operation> was B<KEYCTL_UPDATE> and the key type does not support "
"updating."
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:1919
msgid ""
"I<operation> was B<KEYCTL_RESTRICT_KEYRING>, the type provided in I<arg3> "
"argument was \"asymmetric\", and the key specified in the restriction "
"specification provided in I<arg4> has type other than \"asymmetric\" or "
"\"keyring\"."
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:1929
msgid ""
"I<operation> was B<KEYCTL_GET_PERSISTENT>, I<arg2> specified a UID other "
"than the calling thread's real or effective UID, and the caller did not have "
"the B<CAP_SETUID> capability."
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:1944
msgid ""
"I<operation> was B<KEYCTL_SESSION_TO_PARENT> and either: all of the UIDs "
"(GIDs) of the parent process do not match the effective UID (GID) of the "
"calling process; the UID of the parent's existing session keyring or the UID "
"of the caller's session keyring did not match the effective UID of the "
"caller; the parent process is not single-thread; or the parent process is "
"B<init>(1)  or a kernel thread."
msgstr ""

#. type: TP
#: man-pages/man2/keyctl.2:1944 man-pages/man2/connect.2:239
#: man-pages/man2/futex.2:1677
#, no-wrap
msgid "B<ETIMEDOUT>"
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:1950
msgid ""
"I<operation> was B<KEYCTL_DH_COMPUTE> and the initialization of crypto "
"modules has timed out."
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:1952 man-pages/man2/add_key.2:215
msgid "This system call first appeared in Linux 2.6.10."
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:1964
msgid ""
"No wrapper for this system call is provided in glibc.  A wrapper is provided "
"in the I<libkeyutils> library.  When employing the wrapper in that library, "
"link with I<-lkeyutils>.  However, rather than using this system call "
"directly, you probably want to use the various library functions mentioned "
"in the descriptions of individual operations above."
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:1972
msgid ""
"The program below provide subset of the functionality of the "
"B<request-key>(8)  program provided by the I<keyutils> package.  For "
"informational purposes, the program records various information in a log "
"file."
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:1982
msgid ""
"As described in B<request_key>(2), the B<request-key>(8)  program is invoked "
"with command-line arguments that describe a key that is to be instantiated.  "
"The example program fetches and logs these arguments.  The program assumes "
"authority to instantiate the requested key, and then instantiates that key."
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:1995
msgid ""
"The following shell session demonstrates the use of this program.  In the "
"session, we compile the program and then use it to temporarily replace the "
"standard B<request-key>(8)  program.  (Note that temporarily disabling the "
"standard B<request-key>(8)  program may not be safe on some systems.)  While "
"our example program is installed, we use the example program shown in "
"B<request_key>(2)  to request a key."
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:2004
#, no-wrap
msgid ""
"$ B<cc -o key_instantiate key_instantiate.c -lkeyutils>\n"
"$ B<sudo mv /sbin/request-key /sbin/request-key.backup>\n"
"$ B<sudo cp key_instantiate /sbin/request-key>\n"
"$ B<./t_request_key user mykey somepayloaddata>\n"
"Key ID is 20d035bf\n"
"$ B<sudo mv /sbin/request-key.backup /sbin/request-key>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:2009
msgid ""
"Looking at the log file created by this program, we can see the command-line "
"arguments supplied to our example program:"
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:2014
#, no-wrap
msgid ""
"$ B<cat /tmp/key_instantiate.log >\n"
"Time: Mon Nov  7 13:06:47 2016\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:2024
#, no-wrap
msgid ""
"Command line arguments:\n"
"  argv[0]:            /sbin/request-key\n"
"  operation:          create\n"
"  key_to_instantiate: 20d035bf\n"
"  UID:                1000\n"
"  GID:                1000\n"
"  thread_keyring:     0\n"
"  process_keyring:    0\n"
"  session_keyring:    256e6a6\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:2029
#, no-wrap
msgid ""
"Key description:      user;1000;1000;3f010000;mykey\n"
"Auth key payload:     somepayloaddata\n"
"Destination keyring:  256e6a6\n"
"Auth key description: .request_key_auth;1000;1000;0b010000;20d035bf\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:2034
msgid ""
"The last few lines of the above output show that the example program was "
"able to fetch:"
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:2038
msgid ""
"the description of the key to be instantiated, which included the name of "
"the key (I<mykey>);"
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:2043
msgid ""
"the payload of the authorization key, which consisted of the data "
"(I<somepayloaddata>)  passed to B<request_key>(2);"
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:2047
msgid ""
"the destination keyring that was specified in the call to B<request_key>(2); "
"and"
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:2052
msgid ""
"the description of the authorization key, where we can see that the name of "
"the authorization key matches the ID of the key that is to be instantiated "
"(I<20d035bf>)."
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:2066
msgid ""
"The example program in B<request_key>(2)  specified the destination keyring "
"as B<KEY_SPEC_SESSION_KEYRING>.  By examining the contents of I</proc/keys>, "
"we can see that this was translated to the ID of the destination keyring "
"(I<0256e6a6>)  shown in the log output above; we can also see the newly "
"created key with the name I<mykey> and ID I<20d035bf>."
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:2072
#, no-wrap
msgid ""
"$ B<cat /proc/keys | egrep \\(aqmykey|256e6a6\\(aq>\n"
"0256e6a6 I--Q---  194 perm 3f030000  1000  1000 keyring  _ses: 3\n"
"20d035bf I--Q---    1 perm 3f010000  1000  1000 user     mykey: 16\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:2078
#, no-wrap
msgid "/* key_instantiate.c */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:2088
#, no-wrap
msgid ""
"#include E<lt>sys/types.hE<gt>\n"
"#include E<lt>keyutils.hE<gt>\n"
"#include E<lt>time.hE<gt>\n"
"#include E<lt>fcntl.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:2092
#, no-wrap
msgid ""
"#ifndef KEY_SPEC_REQUESTOR_KEYRING\n"
"#define KEY_SPEC_REQUESTOR_KEYRING      -8\n"
"#endif\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:2106
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    FILE *fp;\n"
"    time_t t;\n"
"    char *operation;\n"
"    key_serial_t key_to_instantiate, dest_keyring;\n"
"    key_serial_t thread_keyring, process_keyring, session_keyring;\n"
"    uid_t uid;\n"
"    gid_t gid;\n"
"    char dbuf[256];\n"
"    char auth_key_payload[256];\n"
"    int akp_size;       /* Size of auth_key_payload */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:2110
#, no-wrap
msgid ""
"    fp = fopen(\"/tmp/key_instantiate.log\", \"w\");\n"
"    if (fp == NULL)\n"
"        exit(EXIT_FAILURE);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:2112
#, no-wrap
msgid "    setbuf(fp, NULL);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:2115
#, no-wrap
msgid ""
"    t = time(NULL);\n"
"    fprintf(fp, \"Time: %s\\en\", ctime(&t));\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:2127
#, no-wrap
msgid ""
"    /*\n"
"     * The kernel passes a fixed set of arguments to the program\n"
"     * that it execs; fetch them.\n"
"     */\n"
"    operation = argv[1];\n"
"    key_to_instantiate = atoi(argv[2]);\n"
"    uid = atoi(argv[3]);\n"
"    gid = atoi(argv[4]);\n"
"    thread_keyring = atoi(argv[5]);\n"
"    process_keyring = atoi(argv[6]);\n"
"    session_keyring = atoi(argv[7]);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:2139
#, no-wrap
msgid ""
"    fprintf(fp, \"Command line arguments:\\en\");\n"
"    fprintf(fp, \"  argv[0]:            %s\\en\", argv[0]);\n"
"    fprintf(fp, \"  operation:          %s\\en\", operation);\n"
"    fprintf(fp, \"  key_to_instantiate: %lx\\en\",\n"
"            (long) key_to_instantiate);\n"
"    fprintf(fp, \"  UID:                %ld\\en\", (long) uid);\n"
"    fprintf(fp, \"  GID:                %ld\\en\", (long) gid);\n"
"    fprintf(fp, \"  thread_keyring:     %lx\\en\", (long) thread_keyring);\n"
"    fprintf(fp, \"  process_keyring:    %lx\\en\", (long) "
"process_keyring);\n"
"    fprintf(fp, \"  session_keyring:    %lx\\en\", (long) "
"session_keyring);\n"
"    fprintf(fp, \"\\en\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:2148
#, no-wrap
msgid ""
"    /*\n"
"     * Assume the authority to instantiate the key named in argv[2]\n"
"     */\n"
"    if (keyctl(KEYCTL_ASSUME_AUTHORITY, key_to_instantiate) == -1) {\n"
"        fprintf(fp, \"KEYCTL_ASSUME_AUTHORITY failed: %s\\en\",\n"
"                strerror(errno));\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:2157
#, no-wrap
msgid ""
"    /*\n"
"     * Fetch the description of the key that is to be instantiated\n"
"     */\n"
"    if (keyctl(KEYCTL_DESCRIBE, key_to_instantiate,\n"
"                dbuf, sizeof(dbuf)) == -1) {\n"
"        fprintf(fp, \"KEYCTL_DESCRIBE failed: %s\\en\", strerror(errno));\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:2159
#, no-wrap
msgid "    fprintf(fp, \"Key description:      %s\\en\", dbuf);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:2170
#, no-wrap
msgid ""
"    /*\n"
"     * Fetch the payload of the authorization key, which is\n"
"     * actually the callout data given to request_key()\n"
"     */\n"
"    akp_size = keyctl(KEYCTL_READ, KEY_SPEC_REQKEY_AUTH_KEY,\n"
"                      auth_key_payload, sizeof(auth_key_payload));\n"
"    if (akp_size == -1) {\n"
"        fprintf(fp, \"KEYCTL_READ failed: %s\\en\", strerror(errno));\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:2173
#, no-wrap
msgid ""
"    auth_key_payload[akp_size] = \\(aq\\e0\\(aq;\n"
"    fprintf(fp, \"Auth key payload:     %s\\en\", auth_key_payload);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:2185
#, no-wrap
msgid ""
"    /*\n"
"     * For interest, get the ID of the authorization key and\n"
"     * display it.\n"
"     */\n"
"    auth_key = keyctl(KEYCTL_GET_KEYRING_ID,\n"
"            KEY_SPEC_REQKEY_AUTH_KEY);\n"
"    if (auth_key == -1) {\n"
"        fprintf(fp, \"KEYCTL_GET_KEYRING_ID failed: %s\\en\",\n"
"                strerror(errno));\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:2187
#, no-wrap
msgid "    fprintf(fp, \"Auth key ID:          %lx\\en\", (long) auth_key);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:2198
#, no-wrap
msgid ""
"    /*\n"
"     * Fetch key ID for the request_key(2) destination keyring.\n"
"     */\n"
"    dest_keyring = keyctl(KEYCTL_GET_KEYRING_ID,\n"
"                          KEY_SPEC_REQUESTOR_KEYRING);\n"
"    if (dest_keyring == -1) {\n"
"        fprintf(fp, \"KEYCTL_GET_KEYRING_ID failed: %s\\en\",\n"
"                strerror(errno));\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:2200
#, no-wrap
msgid "    fprintf(fp, \"Destination keyring:  %lx\\en\", (long) dest_keyring);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:2213
#, no-wrap
msgid ""
"    /*\n"
"     * Fetch the description of the authorization key. This\n"
"     * allows us to see the key type, UID, GID, permissions,\n"
"     * and description (name) of the key. Among other things,\n"
"     * we will see that the name of the key is a hexadecimal\n"
"     * string representing the ID of the key to be instantiated.\n"
"     */\n"
"    if (keyctl(KEYCTL_DESCRIBE, KEY_SPEC_REQKEY_AUTH_KEY,\n"
"                dbuf, sizeof(dbuf)) == -1) {\n"
"        fprintf(fp, \"KEYCTL_DESCRIBE failed: %s\\en\", strerror(errno));\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:2215
#, no-wrap
msgid "    fprintf(fp, \"Auth key description: %s\\en\", dbuf);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:2226
#, no-wrap
msgid ""
"    /*\n"
"     * Instantiate the key using the callout data that was supplied\n"
"     * in the payload of the authorization key.\n"
"     */\n"
"    if (keyctl(KEYCTL_INSTANTIATE, key_to_instantiate,\n"
"               auth_key_payload, akp_size + 1, dest_keyring) == -1) {\n"
"        fprintf(fp, \"KEYCTL_INSTANTIATE failed: %s\\en\",\n"
"                strerror(errno));\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#.      .BR find_key_by_type_and_name (3)
#.      There is a man page, but this function seems not to exist
#. type: Plain text
#: man-pages/man2/keyctl.2:2281
msgid ""
"B<keyctl>(1), B<add_key>(2), B<request_key>(2), B<keyctl>(3), "
"B<keyctl_assume_authority>(3), B<keyctl_chown>(3), B<keyctl_clear>(3), "
"B<keyctl_describe>(3), B<keyctl_describe_alloc>(3), B<keyctl_dh_compute>(3), "
"B<keyctl_dh_compute_alloc>(3), B<keyctl_get_keyring_ID>(3), "
"B<keyctl_get_persistent>(3), B<keyctl_get_security>(3), "
"B<keyctl_get_security_alloc>(3), B<keyctl_instantiate>(3), "
"B<keyctl_instantiate_iov>(3), B<keyctl_invalidate>(3), "
"B<keyctl_join_session_keyring>(3), B<keyctl_link>(3), B<keyctl_negate>(3), "
"B<keyctl_read>(3), B<keyctl_read_alloc>(3), B<keyctl_reject>(3), "
"B<keyctl_revoke>(3), B<keyctl_search>(3), B<keyctl_session_to_parent>(3), "
"B<keyctl_set_reqkey_keyring>(3), B<keyctl_set_timeout>(3), "
"B<keyctl_setperm>(3), B<keyctl_unlink>(3), B<keyctl_update>(3), "
"B<recursive_key_scan>(3), B<recursive_session_key_scan>(3), "
"B<capabilities>(7), B<credentials>(7), B<keyrings>(7), B<keyutils>(7), "
"B<persistent-keyring>(7), B<process-keyring>(7), B<session-keyring>(7), "
"B<thread-keyring>(7), B<user-keyring>(7), B<user_namespaces>(7), "
"B<user-session-keyring>(7), B<request-key>(8)"
msgstr ""

#. type: Plain text
#: man-pages/man2/keyctl.2:2285
msgid ""
"The kernel source files under I<Documentation/security/keys/> (or, before "
"Linux 4.13, in the file I<Documentation/security/keys.txt>)."
msgstr ""

#. type: TH
#: man-pages/man2/sigwaitinfo.2:25
#, no-wrap
msgid "SIGWAITINFO"
msgstr ""

#. type: Plain text
#: man-pages/man2/sigwaitinfo.2:29
msgid ""
"sigwaitinfo, sigtimedwait, rt_sigtimedwait - synchronously wait for queued "
"signals"
msgstr ""

#. type: Plain text
#: man-pages/man2/sigwaitinfo.2:34
#, no-wrap
msgid "B<int sigwaitinfo(const sigset_t *>I<set>B<, siginfo_t *>I<info>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/sigwaitinfo.2:37
#, no-wrap
msgid ""
"B<int sigtimedwait(const sigset_t *>I<set>B<, siginfo_t *>I<info>B<, >\n"
"B<                 const struct timespec *>I<timeout>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/sigwaitinfo.2:47
msgid "B<sigwaitinfo>(), B<sigtimedwait>(): _POSIX_C_SOURCE\\ E<gt>=\\ 199309L"
msgstr ""

#. type: Plain text
#: man-pages/man2/sigwaitinfo.2:57
msgid ""
"B<sigwaitinfo>()  suspends execution of the calling thread until one of the "
"signals in I<set> is pending (If one of the signals in I<set> is already "
"pending for the calling thread, B<sigwaitinfo>()  will return immediately.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/sigwaitinfo.2:69
msgid ""
"B<sigwaitinfo>()  removes the signal from the set of pending signals and "
"returns the signal number as its function result.  If the I<info> argument "
"is not NULL, then the buffer that it points to is used to return a structure "
"of type I<siginfo_t> (see B<sigaction>(2))  containing information about the "
"signal."
msgstr ""

#. type: Plain text
#: man-pages/man2/sigwaitinfo.2:77
msgid ""
"If multiple signals in I<set> are pending for the caller, the signal that is "
"retrieved by B<sigwaitinfo>()  is determined according to the usual ordering "
"rules; see B<signal>(7)  for further details."
msgstr ""

#. type: Plain text
#: man-pages/man2/sigwaitinfo.2:89
msgid ""
"B<sigtimedwait>()  operates in exactly the same way as B<sigwaitinfo>()  "
"except that it has an additional argument, I<timeout>, which specifies the "
"interval for which the thread is suspended waiting for a signal.  (This "
"interval will be rounded up to the system clock granularity, and kernel "
"scheduling delays mean that the interval may overrun by a small amount.)  "
"This argument is of the following type:"
msgstr ""

#. type: Plain text
#: man-pages/man2/sigwaitinfo.2:96
#, no-wrap
msgid ""
"struct timespec {\n"
"    long    tv_sec;         /* seconds */\n"
"    long    tv_nsec;        /* nanoseconds */\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/sigwaitinfo.2:106
msgid ""
"If both fields of this structure are specified as 0, a poll is performed: "
"B<sigtimedwait>()  returns immediately, either with information about a "
"signal that was pending for the caller, or with an error if none of the "
"signals in I<set> was pending."
msgstr ""

#. type: Plain text
#: man-pages/man2/sigwaitinfo.2:115
msgid ""
"On success, both B<sigwaitinfo>()  and B<sigtimedwait>()  return a signal "
"number (i.e., a value greater than zero).  On failure both calls return -1, "
"with I<errno> set to indicate the error."
msgstr ""

#. type: Plain text
#: man-pages/man2/sigwaitinfo.2:124
msgid ""
"No signal in I<set> was became pending within the I<timeout> period "
"specified to B<sigtimedwait>()."
msgstr ""

#. type: Plain text
#: man-pages/man2/sigwaitinfo.2:130
msgid ""
"The wait was interrupted by a signal handler; see B<signal>(7).  (This "
"handler was for a signal other than one of those in I<set>.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/sigwaitinfo.2:134
msgid "I<timeout> was invalid."
msgstr ""

#. type: Plain text
#: man-pages/man2/sigwaitinfo.2:154
msgid ""
"In normal usage, the calling program blocks the signals in I<set> via a "
"prior call to B<sigprocmask>(2)  (so that the default disposition for these "
"signals does not occur if they become pending between successive calls to "
"B<sigwaitinfo>()  or B<sigtimedwait>())  and does not establish handlers for "
"these signals.  In a multithreaded program, the signal should be blocked in "
"all threads, in order to prevent the signal being treated according to its "
"default disposition in a thread other than the one calling B<sigwaitinfo>()  "
"or B<sigtimedwait>())."
msgstr ""

#. type: Plain text
#: man-pages/man2/sigwaitinfo.2:159
msgid ""
"The set of signals that is pending for a given thread is the union of the "
"set of signals that is pending specifically for that thread and the set of "
"signals that is pending for the process as a whole (see B<signal>(7))."
msgstr ""

#. type: Plain text
#: man-pages/man2/sigwaitinfo.2:165
msgid "Attempts to wait for B<SIGKILL> and B<SIGSTOP> are silently ignored."
msgstr ""

#. type: Plain text
#: man-pages/man2/sigwaitinfo.2:174
msgid ""
"If multiple threads of a process are blocked waiting for the same signal(s) "
"in B<sigwaitinfo>()  or B<sigtimedwait>(), then exactly one of the threads "
"will actually receive the signal if it becomes pending for the process as a "
"whole; which of the threads receives the signal is indeterminate."
msgstr ""

#. type: Plain text
#: man-pages/man2/sigwaitinfo.2:186
msgid ""
"B<sigwaitinfo>()  or B<sigtimedwait>(), can't be used to receive signals "
"that are synchronously generated, such as the B<SIGSEGV> signal that results "
"from accessing an invalid memory address or the B<SIGFPE> signal that "
"results from an arithmetic error.  Such signals can be caught only via "
"signal handler."
msgstr ""

#. type: Plain text
#: man-pages/man2/sigwaitinfo.2:196
msgid ""
"POSIX leaves the meaning of a NULL value for the I<timeout> argument of "
"B<sigtimedwait>()  unspecified, permitting the possibility that this has the "
"same meaning as a call to B<sigwaitinfo>(), and indeed this is what is done "
"on Linux."
msgstr ""

#. type: Plain text
#: man-pages/man2/sigwaitinfo.2:201
msgid ""
"On Linux, B<sigwaitinfo>()  is a library function implemented on top of "
"B<sigtimedwait>()."
msgstr ""

#. type: Plain text
#: man-pages/man2/sigwaitinfo.2:211
msgid ""
"The glibc wrapper functions for B<sigwaitinfo>()  and B<sigtimedwait>()  "
"silently ignore attempts to wait for the two real-time signals that are used "
"internally by the NPTL threading implementation.  See B<nptl>(7)  for "
"details."
msgstr ""

#. type: Plain text
#: man-pages/man2/sigwaitinfo.2:238
msgid ""
"The original Linux system call was named B<sigtimedwait>().  However, with "
"the addition of real-time signals in Linux 2.2, the fixed-size, 32-bit "
"I<sigset_t> type supported by that system call was no longer fit for "
"purpose.  Consequently, a new system call, B<rt_sigtimedwait>(), was added "
"to support an enlarged I<sigset_t> type.  The new system call takes a fourth "
"argument, I<size_t sigsetsize>, which specifies the size in bytes of the "
"signal set in I<set>.  This argument is currently required to have the value "
"I<sizeof(sigset_t)> (or the error B<EINVAL> results).  The glibc "
"B<sigtimedwait>()  wrapper function hides these details from us, "
"transparently calling B<rt_sigtimedwait>()  when the kernel provides it."
msgstr ""

#. type: Plain text
#: man-pages/man2/sigwaitinfo.2:249
msgid ""
"B<kill>(2), B<sigaction>(2), B<signal>(2), B<signalfd>(2), B<sigpending>(2), "
"B<sigprocmask>(2), B<sigqueue>(3), B<sigsetops>(3), B<sigwait>(3), "
"B<signal>(7), B<time>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/clone.2:42
#, no-wrap
msgid "CLONE"
msgstr ""

#. type: Plain text
#: man-pages/man2/clone.2:45
msgid "clone, __clone2 - create a child process"
msgstr ""

#. type: Plain text
#: man-pages/man2/clone.2:48
#, no-wrap
msgid "/* Prototype for the glibc wrapper function */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/clone.2:56
#, no-wrap
msgid ""
"B<int clone(int (*>I<fn>B<)(void *), void *>I<child_stack>B<,>\n"
"B<          int >I<flags>B<, void *>I<arg>B<, ... >\n"
"B<          /* pid_t *>I<ptid>B<, void *>I<newtls>B<, pid_t *>I<ctid>B< */ "
");>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/clone.2:58
#, no-wrap
msgid "/* For the prototype of the raw system call, see NOTES */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/clone.2:63
msgid "B<clone>()  creates a new process, in a manner similar to B<fork>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/clone.2:70
msgid ""
"This page describes both the glibc B<clone>()  wrapper function and the "
"underlying system call on which it is based.  The main text describes the "
"wrapper function; the differences for the raw system call are described "
"toward the end of this page."
msgstr ""

#. type: Plain text
#: man-pages/man2/clone.2:82
msgid ""
"Unlike B<fork>(2), B<clone>()  allows the child process to share parts of "
"its execution context with the calling process, such as the virtual address "
"space, the table of file descriptors, and the table of signal handlers.  "
"(Note that on this manual page, \"calling process\" normally corresponds to "
"\"parent process\".  But see the description of B<CLONE_PARENT> below.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/clone.2:87
msgid ""
"One use of B<clone>()  is to implement threads: multiple flows of control in "
"a program that run concurrently in a shared address space."
msgstr ""

#. type: Plain text
#: man-pages/man2/clone.2:102
msgid ""
"When the child process is created with B<clone>(), it commences execution by "
"calling the function pointed to by the argument I<fn>.  (This differs from "
"B<fork>(2), where execution continues in the child from the point of the "
"B<fork>(2)  call.)  The I<arg> argument is passed as the argument of the "
"function I<fn>."
msgstr ""

#. type: Plain text
#: man-pages/man2/clone.2:112
msgid ""
"When the I<fn>(I<arg>)  function returns, the child process terminates.  The "
"integer returned by I<fn> is the exit status for the child process.  The "
"child process may also terminate explicitly by calling B<exit>(2)  or after "
"receiving a fatal signal."
msgstr ""

#. type: Plain text
#: man-pages/man2/clone.2:128
msgid ""
"The I<child_stack> argument specifies the location of the stack used by the "
"child process.  Since the child and calling process may share memory, it is "
"not possible for the child process to execute in the same stack as the "
"calling process.  The calling process must therefore set up memory space for "
"the child stack and pass a pointer to this space to B<clone>().  Stacks grow "
"downward on all processors that run Linux (except the HP PA processors), so "
"I<child_stack> usually points to the topmost address of the memory space set "
"up for the child stack."
msgstr ""

#. type: Plain text
#: man-pages/man2/clone.2:144
msgid ""
"The low byte of I<flags> contains the number of the I<termination signal> "
"sent to the parent when the child dies.  If this signal is specified as "
"anything other than B<SIGCHLD>, then the parent process must specify the "
"B<__WALL> or B<__WCLONE> options when waiting for the child with "
"B<wait>(2).  If no signal is specified, then the parent process is not "
"signaled when the child terminates."
msgstr ""

#. type: Plain text
#: man-pages/man2/clone.2:149
msgid ""
"I<flags> may also be bitwise-ORed with zero or more of the following "
"constants, in order to specify what is shared between the calling process "
"and the child process:"
msgstr ""

#. type: TP
#: man-pages/man2/clone.2:149
#, no-wrap
msgid "B<CLONE_CHILD_CLEARTID> (since Linux 2.5.49)"
msgstr ""

#. type: Plain text
#: man-pages/man2/clone.2:159
msgid ""
"Clear (zero) the child thread ID at the location I<ctid> in child memory "
"when the child exits, and do a wakeup on the futex at that address.  The "
"address involved may be changed by the B<set_tid_address>(2)  system call.  "
"This is used by threading libraries."
msgstr ""

#. type: TP
#: man-pages/man2/clone.2:159
#, no-wrap
msgid "B<CLONE_CHILD_SETTID> (since Linux 2.5.49)"
msgstr ""

#. type: Plain text
#: man-pages/man2/clone.2:172
msgid ""
"Store the child thread ID at the location I<ctid> in the child's memory.  "
"The store operation completes before B<clone>()  returns control to user "
"space in the child process.  (Note that the store operation may not have "
"completed before B<clone>()  returns in the parent process, which will be "
"relevant if the B<CLONE_VM> flag is also employed.)"
msgstr ""

#. type: TP
#: man-pages/man2/clone.2:172
#, no-wrap
msgid "B<CLONE_FILES> (since Linux 2.0)"
msgstr ""

#. type: Plain text
#: man-pages/man2/clone.2:188
msgid ""
"If B<CLONE_FILES> is set, the calling process and the child process share "
"the same file descriptor table.  Any file descriptor created by the calling "
"process or by the child process is also valid in the other process.  "
"Similarly, if one of the processes closes a file descriptor, or changes its "
"associated flags (using the B<fcntl>(2)  B<F_SETFD> operation), the other "
"process is also affected.  If a process sharing a file descriptor table "
"calls B<execve>(2), its file descriptor table is duplicated (unshared)."
msgstr ""

#. type: Plain text
#: man-pages/man2/clone.2:204
msgid ""
"If B<CLONE_FILES> is not set, the child process inherits a copy of all file "
"descriptors opened in the calling process at the time of B<clone>().  "
"Subsequent operations that open or close file descriptors, or change file "
"descriptor flags, performed by either the calling process or the child "
"process do not affect the other process.  Note, however, that the duplicated "
"file descriptors in the child refer to the same open file descriptions as "
"the corresponding file descriptors in the calling process, and thus share "
"file offsets and file status flags (see B<open>(2))."
msgstr ""

#. type: TP
#: man-pages/man2/clone.2:204
#, no-wrap
msgid "B<CLONE_FS> (since Linux 2.0)"
msgstr ""

#. type: Plain text
#: man-pages/man2/clone.2:219
msgid ""
"If B<CLONE_FS> is set, the caller and the child process share the same "
"filesystem information.  This includes the root of the filesystem, the "
"current working directory, and the umask.  Any call to B<chroot>(2), "
"B<chdir>(2), or B<umask>(2)  performed by the calling process or the child "
"process also affects the other process."
msgstr ""

#. type: Plain text
#: man-pages/man2/clone.2:232
msgid ""
"If B<CLONE_FS> is not set, the child process works on a copy of the "
"filesystem information of the calling process at the time of the B<clone>()  "
"call.  Calls to B<chroot>(2), B<chdir>(2), or B<umask>(2)  performed later "
"by one of the processes do not affect the other process."
msgstr ""

#. type: TP
#: man-pages/man2/clone.2:232
#, no-wrap
msgid "B<CLONE_IO> (since Linux 2.6.25)"
msgstr ""

#. type: Plain text
#: man-pages/man2/clone.2:241
msgid ""
"If B<CLONE_IO> is set, then the new process shares an I/O context with the "
"calling process.  If this flag is not set, then (as with B<fork>(2))  the "
"new process has its own I/O context."
msgstr ""

#.  The following based on text from Jens Axboe
#.  the anticipatory and CFQ scheduler
#.  with CFQ and AS.
#. type: Plain text
#: man-pages/man2/clone.2:258
msgid ""
"The I/O context is the I/O scope of the disk scheduler (i.e., what the I/O "
"scheduler uses to model scheduling of a process's I/O).  If processes share "
"the same I/O context, they are treated as one by the I/O scheduler.  As a "
"consequence, they get to share disk time.  For some I/O schedulers, if two "
"processes share an I/O context, they will be allowed to interleave their "
"disk access.  If several threads are doing I/O on behalf of the same process "
"(B<aio_read>(3), for instance), they should employ B<CLONE_IO> to get better "
"I/O performance."
msgstr ""

#. type: Plain text
#: man-pages/man2/clone.2:262
msgid ""
"If the kernel is not configured with the B<CONFIG_BLOCK> option, this flag "
"is a no-op."
msgstr ""

#. type: Plain text
#: man-pages/man2/clone.2:269
msgid ""
"Create the process in a new cgroup namespace.  If this flag is not set, then "
"(as with B<fork>(2))  the process is created in the same cgroup namespaces "
"as the calling process.  This flag is intended for the implementation of "
"containers."
msgstr ""

#. type: Plain text
#: man-pages/man2/clone.2:272
msgid "For further information on cgroup namespaces, see B<cgroup_namespaces>(7)."
msgstr ""

#. type: Plain text
#: man-pages/man2/clone.2:278
msgid "Only a privileged process (B<CAP_SYS_ADMIN>)  can employ B<CLONE_NEWCGROUP>."
msgstr ""

#. type: Plain text
#: man-pages/man2/clone.2:288
msgid ""
"If B<CLONE_NEWIPC> is set, then create the process in a new IPC namespace.  "
"If this flag is not set, then (as with B<fork>(2)), the process is created "
"in the same IPC namespace as the calling process.  This flag is intended for "
"the implementation of containers."
msgstr ""

#.  commit 7eafd7c74c3f2e67c27621b987b28397110d643f
#.  https://lwn.net/Articles/312232/
#. type: Plain text
#: man-pages/man2/clone.2:300
msgid ""
"An IPC namespace provides an isolated view of System\\ V IPC objects (see "
"B<sysvipc>(7))  and (since Linux 2.6.30)  POSIX message queues (see "
"B<mq_overview>(7)).  The common characteristic of these IPC mechanisms is "
"that IPC objects are identified by mechanisms other than filesystem "
"pathnames."
msgstr ""

#. type: Plain text
#: man-pages/man2/clone.2:304
msgid ""
"Objects created in an IPC namespace are visible to all other processes that "
"are members of that namespace, but are not visible to processes in other IPC "
"namespaces."
msgstr ""

#. type: Plain text
#: man-pages/man2/clone.2:308
msgid ""
"When an IPC namespace is destroyed (i.e., when the last process that is a "
"member of the namespace terminates), all IPC objects in the namespace are "
"automatically destroyed."
msgstr ""

#. type: Plain text
#: man-pages/man2/clone.2:315
msgid ""
"Only a privileged process (B<CAP_SYS_ADMIN>)  can employ B<CLONE_NEWIPC>.  "
"This flag can't be specified in conjunction with B<CLONE_SYSVSEM>."
msgstr ""

#. type: Plain text
#: man-pages/man2/clone.2:318
msgid "For further information on IPC namespaces, see B<namespaces>(7)."
msgstr ""

#. type: Plain text
#: man-pages/man2/clone.2:322
msgid ""
"(The implementation of this flag was completed only by about kernel version "
"2.6.29.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/clone.2:331
msgid ""
"If B<CLONE_NEWNET> is set, then create the process in a new network "
"namespace.  If this flag is not set, then (as with B<fork>(2))  the process "
"is created in the same network namespace as the calling process.  This flag "
"is intended for the implementation of containers."
msgstr ""

#. type: Plain text
#: man-pages/man2/clone.2:347
msgid ""
"A network namespace provides an isolated view of the networking stack "
"(network device interfaces, IPv4 and IPv6 protocol stacks, IP routing "
"tables, firewall rules, the I</proc/net> and I</sys/class/net> directory "
"trees, sockets, etc.).  A physical network device can live in exactly one "
"network namespace.  A virtual network (B<veth>(4))  device pair provides a "
"pipe-like abstraction that can be used to create tunnels between network "
"namespaces, and can be used to create a bridge to a physical network device "
"in another namespace."
msgstr ""

#. type: Plain text
#: man-pages/man2/clone.2:354
msgid ""
"When a network namespace is freed (i.e., when the last process in the "
"namespace terminates), its physical network devices are moved back to the "
"initial network namespace (not to the parent of the process).  For further "
"information on network namespaces, see B<namespaces>(7)."
msgstr ""

#. type: Plain text
#: man-pages/man2/clone.2:359
msgid "Only a privileged process (B<CAP_SYS_ADMIN>)  can employ B<CLONE_NEWNET>."
msgstr ""

#. type: TP
#: man-pages/man2/clone.2:359
#, no-wrap
msgid "B<CLONE_NEWNS> (since Linux 2.4.19)"
msgstr ""

#. type: Plain text
#: man-pages/man2/clone.2:369
msgid ""
"If B<CLONE_NEWNS> is set, the cloned child is started in a new mount "
"namespace, initialized with a copy of the namespace of the parent.  If "
"B<CLONE_NEWNS> is not set, the child lives in the same mount namespace as "
"the parent."
msgstr ""

#.  See https://lwn.net/Articles/543273/
#. type: Plain text
#: man-pages/man2/clone.2:382
msgid ""
"Only a privileged process (B<CAP_SYS_ADMIN>)  can employ B<CLONE_NEWNS>.  It "
"is not permitted to specify both B<CLONE_NEWNS> and B<CLONE_FS> in the same "
"B<clone>()  call."
msgstr ""

#. type: Plain text
#: man-pages/man2/clone.2:387
msgid ""
"For further information on mount namespaces, see B<namespaces>(7)  and "
"B<mount_namespaces>(7)."
msgstr ""

#. type: TP
#: man-pages/man2/clone.2:387
#, no-wrap
msgid "B<CLONE_NEWPID> (since Linux 2.6.24)"
msgstr ""

#.  This explanation draws a lot of details from
#.  http://lwn.net/Articles/259217/
#.  Authors: Pavel Emelyanov <xemul@openvz.org>
#.  and Kir Kolyshkin <kir@openvz.org>
#
#.  The primary kernel commit is 30e49c263e36341b60b735cbef5ca37912549264
#.  Author: Pavel Emelyanov <xemul@openvz.org>
#. type: Plain text
#: man-pages/man2/clone.2:404
msgid ""
"If B<CLONE_NEWPID> is set, then create the process in a new PID namespace.  "
"If this flag is not set, then (as with B<fork>(2))  the process is created "
"in the same PID namespace as the calling process.  This flag is intended for "
"the implementation of containers."
msgstr ""

#. type: Plain text
#: man-pages/man2/clone.2:409
msgid ""
"For further information on PID namespaces, see B<namespaces>(7)  and "
"B<pid_namespaces>(7)."
msgstr ""

#. type: Plain text
#: man-pages/man2/clone.2:418
msgid ""
"Only a privileged process (B<CAP_SYS_ADMIN>)  can employ B<CLONE_NEWPID>.  "
"This flag can't be specified in conjunction with B<CLONE_THREAD> or "
"B<CLONE_PARENT>."
msgstr ""

#. type: TP
#: man-pages/man2/clone.2:418
#, no-wrap
msgid "B<CLONE_NEWUSER>"
msgstr ""

#. type: Plain text
#: man-pages/man2/clone.2:428
msgid ""
"(This flag first became meaningful for B<clone>()  in Linux 2.6.23, the "
"current B<clone>()  semantics were merged in Linux 3.5, and the final pieces "
"to make the user namespaces completely usable were merged in Linux 3.8.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/clone.2:435
msgid ""
"If B<CLONE_NEWUSER> is set, then create the process in a new user "
"namespace.  If this flag is not set, then (as with B<fork>(2))  the process "
"is created in the same user namespace as the calling process."
msgstr ""

#.  Before Linux 2.6.29, it appears that only CAP_SYS_ADMIN was needed
#. type: Plain text
#: man-pages/man2/clone.2:446
msgid ""
"Before Linux 3.8, use of B<CLONE_NEWUSER> required that the caller have "
"three capabilities: B<CAP_SYS_ADMIN>, B<CAP_SETUID>, and B<CAP_SETGID>.  "
"Starting with Linux 3.8, no privileges are needed to create a user "
"namespace."
msgstr ""

#.  commit e66eded8309ebf679d3d3c1f5820d1f2ca332c71
#.  https://lwn.net/Articles/543273/
#.  The fix actually went into 3.9 and into 3.8.3. However, user namespaces
#.  were, for practical purposes, unusable in earlier 3.8.x because of the
#.  various filesystems that didn't support userns.
#. type: Plain text
#: man-pages/man2/clone.2:460
msgid ""
"This flag can't be specified in conjunction with B<CLONE_THREAD> or "
"B<CLONE_PARENT>.  For security reasons, B<CLONE_NEWUSER> cannot be specified "
"in conjunction with B<CLONE_FS>."
msgstr ""

#. type: Plain text
#: man-pages/man2/clone.2:465
msgid ""
"For further information on user namespaces, see B<namespaces>(7)  and "
"B<user_namespaces>(7)."
msgstr ""

#. type: Plain text
#: man-pages/man2/clone.2:477
msgid ""
"If B<CLONE_NEWUTS> is set, then create the process in a new UTS namespace, "
"whose identifiers are initialized by duplicating the identifiers from the "
"UTS namespace of the calling process.  If this flag is not set, then (as "
"with B<fork>(2))  the process is created in the same UTS namespace as the "
"calling process.  This flag is intended for the implementation of "
"containers."
msgstr ""

#. type: Plain text
#: man-pages/man2/clone.2:488
msgid ""
"A UTS namespace is the set of identifiers returned by B<uname>(2); among "
"these, the domain name and the hostname can be modified by "
"B<setdomainname>(2)  and B<sethostname>(2), respectively.  Changes made to "
"the identifiers in a UTS namespace are visible to all other processes in the "
"same namespace, but are not visible to processes in other UTS namespaces."
msgstr ""

#. type: Plain text
#: man-pages/man2/clone.2:493
msgid "Only a privileged process (B<CAP_SYS_ADMIN>)  can employ B<CLONE_NEWUTS>."
msgstr ""

#. type: Plain text
#: man-pages/man2/clone.2:496
msgid "For further information on UTS namespaces, see B<namespaces>(7)."
msgstr ""

#. type: TP
#: man-pages/man2/clone.2:496
#, no-wrap
msgid "B<CLONE_PARENT> (since Linux 2.3.12)"
msgstr ""

#. type: Plain text
#: man-pages/man2/clone.2:503
msgid ""
"If B<CLONE_PARENT> is set, then the parent of the new child (as returned by "
"B<getppid>(2))  will be the same as that of the calling process."
msgstr ""

#. type: Plain text
#: man-pages/man2/clone.2:509
msgid ""
"If B<CLONE_PARENT> is not set, then (as with B<fork>(2))  the child's parent "
"is the calling process."
msgstr ""

#. type: Plain text
#: man-pages/man2/clone.2:517
msgid ""
"Note that it is the parent process, as returned by B<getppid>(2), which is "
"signaled when the child terminates, so that if B<CLONE_PARENT> is set, then "
"the parent of the calling process, rather than the calling process itself, "
"will be signaled."
msgstr ""

#. type: TP
#: man-pages/man2/clone.2:517
#, no-wrap
msgid "B<CLONE_PARENT_SETTID> (since Linux 2.5.49)"
msgstr ""

#. type: Plain text
#: man-pages/man2/clone.2:528
msgid ""
"Store the child thread ID at the location I<ptid> in the parent's memory.  "
"(In Linux 2.5.32-2.5.48 there was a flag B<CLONE_SETTID> that did this.)  "
"The store operation completes before B<clone>()  returns control to user "
"space."
msgstr ""

#. type: TP
#: man-pages/man2/clone.2:528
#, no-wrap
msgid "B<CLONE_PID> (Linux 2.0 to 2.5.15)"
msgstr ""

#. type: Plain text
#: man-pages/man2/clone.2:541
msgid ""
"If B<CLONE_PID> is set, the child process is created with the same process "
"ID as the calling process.  This is good for hacking the system, but "
"otherwise of not much use.  From Linux 2.3.21 onward, this flag could be "
"specified only by the system boot process (PID 0).  The flag disappeared "
"completely from the kernel sources in Linux 2.5.16.  Since then, the kernel "
"silently ignores this bit if it is specified in I<flags>."
msgstr ""

#. type: TP
#: man-pages/man2/clone.2:541
#, no-wrap
msgid "B<CLONE_PIDFD> (since Linux 5.2)"
msgstr ""

#.  commit b3e5838252665ee4cfa76b82bdf1198dca81e5be
#. type: Plain text
#: man-pages/man2/clone.2:555
msgid ""
"If B<CLONE_PIDFD> is set, B<clone>()  stores a PID file descriptor referring "
"to the child process at the location I<ptid> in the parent's memory.  The "
"close-on-exec flag is set on this new file descriptor.  PID file descriptors "
"can be used for the purposes described in B<pidfd_open>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/clone.2:562
msgid ""
"Since the I<ptid> argument is used to return the PID file descriptor, "
"B<CLONE_PIDFD> cannot be used with B<CLONE_PARENT_SETTID.>"
msgstr ""

#. type: Plain text
#: man-pages/man2/clone.2:567
msgid ""
"It is currently not possible to use this flag together with B<CLONE_THREAD.> "
"This means that the process identified by the PID file descriptor will "
"always be a thread-group leader."
msgstr ""

#. type: Plain text
#: man-pages/man2/clone.2:577
msgid ""
"For a while there was a B<CLONE_DETACHED> flag.  This flag is usually "
"ignored when passed along with other flags.  However, when passed alongside "
"B<CLONE_PIDFD>, an error is returned.  This ensures that this flag can be "
"reused for further PID file descriptor features in the future."
msgstr ""

#. type: TP
#: man-pages/man2/clone.2:577
#, no-wrap
msgid "B<CLONE_PTRACE> (since Linux 2.2)"
msgstr ""

#. type: Plain text
#: man-pages/man2/clone.2:584
msgid ""
"If B<CLONE_PTRACE> is specified, and the calling process is being traced, "
"then trace the child also (see B<ptrace>(2))."
msgstr ""

#. type: TP
#: man-pages/man2/clone.2:584
#, no-wrap
msgid "B<CLONE_SETTLS> (since Linux 2.5.32)"
msgstr ""

#. type: Plain text
#: man-pages/man2/clone.2:588
msgid "The TLS (Thread Local Storage) descriptor is set to I<newtls>."
msgstr ""

#. type: Plain text
#: man-pages/man2/clone.2:605
msgid ""
"The interpretation of I<newtls> and the resulting effect is architecture "
"dependent.  On x86, I<newtls> is interpreted as a I<struct user_desc\\ *> "
"(see B<set_thread_area>(2)).  On x86-64 it is the new value to be set for "
"the %fs base register (see the B<ARCH_SET_FS> argument to "
"B<arch_prctl>(2)).  On architectures with a dedicated TLS register, it is "
"the new value of that register."
msgstr ""

#. type: TP
#: man-pages/man2/clone.2:605
#, no-wrap
msgid "B<CLONE_SIGHAND> (since Linux 2.0)"
msgstr ""

#. type: Plain text
#: man-pages/man2/clone.2:621
msgid ""
"If B<CLONE_SIGHAND> is set, the calling process and the child process share "
"the same table of signal handlers.  If the calling process or child process "
"calls B<sigaction>(2)  to change the behavior associated with a signal, the "
"behavior is changed in the other process as well.  However, the calling "
"process and child processes still have distinct signal masks and sets of "
"pending signals.  So, one of them may block or unblock signals using "
"B<sigprocmask>(2)  without affecting the other process."
msgstr ""

#. type: Plain text
#: man-pages/man2/clone.2:632
msgid ""
"If B<CLONE_SIGHAND> is not set, the child process inherits a copy of the "
"signal handlers of the calling process at the time B<clone>()  is called.  "
"Calls to B<sigaction>(2)  performed later by one of the processes have no "
"effect on the other process."
msgstr ""

#.  Precisely: Linux 2.6.0-test6
#. type: Plain text
#: man-pages/man2/clone.2:641
msgid ""
"Since Linux 2.6.0, I<flags> must also include B<CLONE_VM> if "
"B<CLONE_SIGHAND> is specified"
msgstr ""

#. type: TP
#: man-pages/man2/clone.2:641
#, no-wrap
msgid "B<CLONE_STOPPED> (since Linux 2.6.0)"
msgstr ""

#.  Precisely: Linux 2.6.0-test2
#. type: Plain text
#: man-pages/man2/clone.2:651
msgid ""
"If B<CLONE_STOPPED> is set, then the child is initially stopped (as though "
"it was sent a B<SIGSTOP> signal), and must be resumed by sending it a "
"B<SIGCONT> signal."
msgstr ""

#.  glibc 2.8 removed this defn from bits/sched.h
#. type: Plain text
#: man-pages/man2/clone.2:663
msgid ""
"This flag was I<deprecated> from Linux 2.6.25 onward, and was I<removed> "
"altogether in Linux 2.6.38.  Since then, the kernel silently ignores it "
"without error.  Starting with Linux 4.6, the same bit was reused for the "
"B<CLONE_NEWCGROUP> flag."
msgstr ""

#. type: TP
#: man-pages/man2/clone.2:663
#, no-wrap
msgid "B<CLONE_SYSVSEM> (since Linux 2.5.10)"
msgstr ""

#. type: Plain text
#: man-pages/man2/clone.2:681
msgid ""
"If B<CLONE_SYSVSEM> is set, then the child and the calling process share a "
"single list of System V semaphore adjustment (I<semadj>)  values (see "
"B<semop>(2)).  In this case, the shared list accumulates I<semadj> values "
"across all processes sharing the list, and semaphore adjustments are "
"performed only when the last process that is sharing the list terminates (or "
"ceases sharing the list using B<unshare>(2)).  If this flag is not set, then "
"the child has a separate I<semadj> list that is initially empty."
msgstr ""

#. type: TP
#: man-pages/man2/clone.2:681
#, no-wrap
msgid "B<CLONE_THREAD> (since Linux 2.4.0)"
msgstr ""

#.  Precisely: Linux 2.6.0-test8
#. type: Plain text
#: man-pages/man2/clone.2:691
msgid ""
"If B<CLONE_THREAD> is set, the child is placed in the same thread group as "
"the calling process.  To make the remainder of the discussion of "
"B<CLONE_THREAD> more readable, the term \"thread\" is used to refer to the "
"processes within a thread group."
msgstr ""

#. type: Plain text
#: man-pages/man2/clone.2:699
msgid ""
"Thread groups were a feature added in Linux 2.4 to support the POSIX threads "
"notion of a set of threads that share a single PID.  Internally, this shared "
"PID is the so-called thread group identifier (TGID) for the thread group.  "
"Since Linux 2.4, calls to B<getpid>(2)  return the TGID of the caller."
msgstr ""

#. type: Plain text
#: man-pages/man2/clone.2:708
msgid ""
"The threads within a group can be distinguished by their (system-wide)  "
"unique thread IDs (TID).  A new thread's TID is available as the function "
"result returned to the caller of B<clone>(), and a thread can obtain its own "
"TID using B<gettid>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/clone.2:718
msgid ""
"When a call is made to B<clone>()  without specifying B<CLONE_THREAD>, then "
"the resulting thread is placed in a new thread group whose TGID is the same "
"as the thread's TID.  This thread is the I<leader> of the new thread group."
msgstr ""

#. type: Plain text
#: man-pages/man2/clone.2:740
msgid ""
"A new thread created with B<CLONE_THREAD> has the same parent process as the "
"caller of B<clone>()  (i.e., like B<CLONE_PARENT>), so that calls to "
"B<getppid>(2)  return the same value for all of the threads in a thread "
"group.  When a B<CLONE_THREAD> thread terminates, the thread that created it "
"using B<clone>()  is not sent a B<SIGCHLD> (or other termination) signal; "
"nor can the status of such a thread be obtained using B<wait>(2).  (The "
"thread is said to be I<detached>.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/clone.2:745
msgid ""
"After all of the threads in a thread group terminate the parent process of "
"the thread group is sent a B<SIGCHLD> (or other termination) signal."
msgstr ""

#. type: Plain text
#: man-pages/man2/clone.2:750
msgid ""
"If any of the threads in a thread group performs an B<execve>(2), then all "
"threads other than the thread group leader are terminated, and the new "
"program is executed in the thread group leader."
msgstr ""

#. type: Plain text
#: man-pages/man2/clone.2:756
msgid ""
"If one of the threads in a thread group creates a child using B<fork>(2), "
"then any thread in the group can B<wait>(2)  for that child."
msgstr ""

#.  Precisely: Linux 2.6.0-test6
#. type: Plain text
#: man-pages/man2/clone.2:770
msgid ""
"Since Linux 2.5.35, I<flags> must also include B<CLONE_SIGHAND> if "
"B<CLONE_THREAD> is specified (and note that, since Linux 2.6.0, "
"B<CLONE_SIGHAND> also requires B<CLONE_VM> to be included)."
msgstr ""

#. type: Plain text
#: man-pages/man2/clone.2:775
msgid ""
"Signal dispositions and actions are process-wide: if an unhandled signal is "
"delivered to a thread, then it will affect (terminate, stop, continue, be "
"ignored in)  all members of the thread group."
msgstr ""

#. type: Plain text
#: man-pages/man2/clone.2:778
msgid "Each thread has its own signal mask, as set by B<sigprocmask>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/clone.2:800
msgid ""
"A signal may be process-directed or thread-directed.  A process-directed "
"signal is targeted at a thread group (i.e., a TGID), and is delivered to an "
"arbitrarily selected thread from among those that are not blocking the "
"signal.  A signal may be process-directed because it was generated by the "
"kernel for reasons other than a hardware exception, or because it was sent "
"using B<kill>(2)  or B<sigqueue>(3).  A thread-directed signal is targeted "
"at (i.e., delivered to)  a specific thread.  A signal may be thread directed "
"because it was sent using B<tgkill>(2)  or B<pthread_sigqueue>(3), or "
"because the thread executed a machine language instruction that triggered a "
"hardware exception (e.g., invalid memory access triggering B<SIGSEGV> or a "
"floating-point exception triggering B<SIGFPE>)."
msgstr ""

#. type: Plain text
#: man-pages/man2/clone.2:805
msgid ""
"A call to B<sigpending>(2)  returns a signal set that is the union of the "
"pending process-directed signals and the signals that are pending for the "
"calling thread."
msgstr ""

#. type: Plain text
#: man-pages/man2/clone.2:814
msgid ""
"If a process-directed signal is delivered to a thread group, and the thread "
"group has installed a handler for the signal, then the handler will be "
"invoked in exactly one, arbitrarily selected member of the thread group that "
"has not blocked the signal.  If multiple threads in a group are waiting to "
"accept the same signal using B<sigwaitinfo>(2), the kernel will arbitrarily "
"select one of these threads to receive the signal."
msgstr ""

#. type: TP
#: man-pages/man2/clone.2:814
#, no-wrap
msgid "B<CLONE_UNTRACED> (since Linux 2.5.46)"
msgstr ""

#. type: Plain text
#: man-pages/man2/clone.2:821
msgid ""
"If B<CLONE_UNTRACED> is specified, then a tracing process cannot force "
"B<CLONE_PTRACE> on this child process."
msgstr ""

#. type: TP
#: man-pages/man2/clone.2:821
#, no-wrap
msgid "B<CLONE_VFORK> (since Linux 2.2)"
msgstr ""

#. type: Plain text
#: man-pages/man2/clone.2:833
msgid ""
"If B<CLONE_VFORK> is set, the execution of the calling process is suspended "
"until the child releases its virtual memory resources via a call to "
"B<execve>(2)  or B<_exit>(2)  (as with B<vfork>(2))."
msgstr ""

#. type: Plain text
#: man-pages/man2/clone.2:839
msgid ""
"If B<CLONE_VFORK> is not set, then both the calling process and the child "
"are schedulable after the call, and an application should not rely on "
"execution occurring in any particular order."
msgstr ""

#. type: TP
#: man-pages/man2/clone.2:839
#, no-wrap
msgid "B<CLONE_VM> (since Linux 2.0)"
msgstr ""

#. type: Plain text
#: man-pages/man2/clone.2:852
msgid ""
"If B<CLONE_VM> is set, the calling process and the child process run in the "
"same memory space.  In particular, memory writes performed by the calling "
"process or by the child process are also visible in the other process.  "
"Moreover, any memory mapping or unmapping performed with B<mmap>(2)  or "
"B<munmap>(2)  by the child or calling process also affects the other "
"process."
msgstr ""

#. type: Plain text
#: man-pages/man2/clone.2:861
msgid ""
"If B<CLONE_VM> is not set, the child process runs in a separate copy of the "
"memory space of the calling process at the time of B<clone>().  Memory "
"writes or file mappings/unmappings performed by one of the processes do not "
"affect the other, as with B<fork>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/clone.2:878
msgid ""
"Note that the glibc B<clone>()  wrapper function makes some changes in the "
"memory pointed to by I<child_stack> (changes required to set the stack up "
"correctly for the child)  I<before> invoking the B<clone>()  system call.  "
"So, in cases where B<clone>()  is used to recursively create children, do "
"not use the buffer employed for the parent's stack as the stack of the "
"child."
msgstr ""

#. type: Plain text
#: man-pages/man2/clone.2:892
msgid ""
"The raw B<clone>()  system call corresponds more closely to B<fork>(2)  in "
"that execution in the child continues from the point of the call.  As such, "
"the I<fn> and I<arg> arguments of the B<clone>()  wrapper function are "
"omitted."
msgstr ""

#. type: Plain text
#: man-pages/man2/clone.2:910
msgid ""
"Another difference for the raw B<clone>()  system call is that the "
"I<child_stack> argument may be NULL, in which case the child uses a "
"duplicate of the parent's stack.  (Copy-on-write semantics ensure that the "
"child gets separate copies of stack pages when either process modifies the "
"stack.)  In this case, for correct operation, the B<CLONE_VM> option should "
"not be specified.  (If the child I<shares> the parent's memory because of "
"the use of the B<CLONE_VM> flag, then no copy-on-write duplication occurs "
"and chaos is likely to result.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/clone.2:914
msgid ""
"The order of the arguments also differs in the raw system call, and there "
"are variations in the arguments across architectures, as detailed in the "
"following paragraphs."
msgstr ""

#. type: Plain text
#: man-pages/man2/clone.2:917
msgid ""
"The raw system call interface on x86-64 and some other architectures "
"(including sh, tile, ia-64, and alpha) is:"
msgstr ""

#. type: Plain text
#: man-pages/man2/clone.2:923
#, no-wrap
msgid ""
"B<long clone(unsigned long >I<flags>B<, void *>I<child_stack>B<,>\n"
"B<           int *>I<ptid>B<, int *>I<ctid>B<,>\n"
"B<           unsigned long >I<newtls>B<);>\n"
msgstr ""

#.  CONFIG_CLONE_BACKWARDS
#. type: Plain text
#: man-pages/man2/clone.2:931
msgid ""
"On x86-32, and several other common architectures (including score, ARM, ARM "
"64, PA-RISC, arc, Power PC, xtensa, and MIPS), the order of the last two "
"arguments is reversed:"
msgstr ""

#. type: Plain text
#: man-pages/man2/clone.2:937
#, no-wrap
msgid ""
"B<long clone(unsigned long >I<flags>B<, void *>I<child_stack>B<,>\n"
"B<          int *>I<ptid>B<, unsigned long >I<newtls>B<,>\n"
"B<          int *>I<ctid>B<);>\n"
msgstr ""

#.  CONFIG_CLONE_BACKWARDS2
#. type: Plain text
#: man-pages/man2/clone.2:943
msgid ""
"On the cris and s390 architectures, the order of the first two arguments is "
"reversed:"
msgstr ""

#. type: Plain text
#: man-pages/man2/clone.2:949
#, no-wrap
msgid ""
"B<long clone(void *>I<child_stack>B<, unsigned long >I<flags>B<,>\n"
"B<           int *>I<ptid>B<, int *>I<ctid>B<,>\n"
"B<           unsigned long >I<newtls>B<);>\n"
msgstr ""

#.  CONFIG_CLONE_BACKWARDS3
#. type: Plain text
#: man-pages/man2/clone.2:955
msgid "On the microblaze architecture, an additional argument is supplied:"
msgstr ""

#. type: Plain text
#: man-pages/man2/clone.2:962
#, no-wrap
msgid ""
"B<long clone(unsigned long >I<flags>B<, void *>I<child_stack>B<,>\n"
"B<           int >I<stack_size>B<,>         /* Size of stack */\n"
"B<           int *>I<ptid>B<, int *>I<ctid>B<,>\n"
"B<           unsigned long >I<newtls>B<);>\n"
msgstr ""

#. type: SS
#: man-pages/man2/clone.2:965
#, no-wrap
msgid "blackfin, m68k, and sparc"
msgstr ""

#.  Mike Frysinger noted in a 2013 mail:
#.      these arches don't define __ARCH_WANT_SYS_CLONE:
#.      blackfin ia64 m68k sparc
#. type: Plain text
#: man-pages/man2/clone.2:972
msgid ""
"The argument-passing conventions on blackfin, m68k, and sparc are different "
"from the descriptions above.  For details, see the kernel (and glibc) "
"source."
msgstr ""

#. type: tbl table
#: man-pages/man2/clone.2:972 man-pages/man2/syscall.2:192
#: man-pages/man2/syscall.2:323
#, no-wrap
msgid "ia64"
msgstr ""

#. type: Plain text
#: man-pages/man2/clone.2:974
msgid "On ia64, a different interface is used:"
msgstr ""

#. type: Plain text
#: man-pages/man2/clone.2:982
#, no-wrap
msgid ""
"B<int __clone2(int (*>I<fn>B<)(void *), >\n"
"B<             void *>I<child_stack_base>B<, size_t >I<stack_size>B<,>\n"
"B<             int >I<flags>B<, void *>I<arg>B<, ... >\n"
"B<          /* pid_t *>I<ptid>B<, struct user_desc *>I<tls>B<, pid_t "
"*>I<ctid>B< */ );>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/clone.2:990
msgid ""
"The prototype shown above is for the glibc wrapper function; for the system "
"call itself, the prototype can be described as follows (it is identical to "
"the B<clone>()  prototype on microblaze):"
msgstr ""

#. type: Plain text
#: man-pages/man2/clone.2:997
#, no-wrap
msgid ""
"B<long clone2(unsigned long >I<flags>B<, void *>I<child_stack_base>B<,>\n"
"B<            int >I<stack_size>B<,>         /* Size of stack */\n"
"B<            int *>I<ptid>B<, int *>I<ctid>B<,>\n"
"B<            unsigned long >I<tls>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/clone.2:1010
msgid ""
"B<__clone2>()  operates in the same way as B<clone>(), except that "
"I<child_stack_base> points to the lowest address of the child's stack area, "
"and I<stack_size> specifies the size of the stack pointed to by "
"I<child_stack_base>."
msgstr ""

#. type: Plain text
#: man-pages/man2/clone.2:1018
msgid ""
"In Linux 2.4 and earlier, B<clone>()  does not take arguments I<ptid>, "
"I<tls>, and I<ctid>."
msgstr ""

#.  gettid(2) returns current->pid;
#.  getpid(2) returns current->tgid;
#. type: Plain text
#: man-pages/man2/clone.2:1027
msgid ""
"On success, the thread ID of the child process is returned in the caller's "
"thread of execution.  On failure, -1 is returned in the caller's context, no "
"child process will be created, and I<errno> will be set appropriately."
msgstr ""

#. type: Plain text
#: man-pages/man2/clone.2:1032
msgid "Too many processes are already running; see B<fork>(2)."
msgstr ""

#.  Precisely: Linux 2.6.0-test6
#. type: Plain text
#: man-pages/man2/clone.2:1040
msgid ""
"B<CLONE_SIGHAND> was specified, but B<CLONE_VM> was not.  (Since Linux "
"2.6.0.)"
msgstr ""

#.  .TP
#.  .B EINVAL
#.  Precisely one of
#.  .B CLONE_DETACHED
#.  and
#.  .B CLONE_THREAD
#.  was specified.
#.  (Since Linux 2.6.0-test6.)
#. type: Plain text
#: man-pages/man2/clone.2:1055
msgid ""
"B<CLONE_THREAD> was specified, but B<CLONE_SIGHAND> was not.  (Since Linux "
"2.5.35.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/clone.2:1065
msgid ""
"B<CLONE_THREAD> was specified, but the current process previously called "
"B<unshare>(2)  with the B<CLONE_NEWPID> flag or used B<setns>(2)  to "
"reassociate itself with a PID namespace."
msgstr ""

#.  commit e66eded8309ebf679d3d3c1f5820d1f2ca332c71
#. type: Plain text
#: man-pages/man2/clone.2:1074
msgid "Both B<CLONE_FS> and B<CLONE_NEWNS> were specified in I<flags>."
msgstr ""

#. type: TP
#: man-pages/man2/clone.2:1074
#, no-wrap
msgid "B<EINVAL> (since Linux 3.9)"
msgstr ""

#. type: Plain text
#: man-pages/man2/clone.2:1082
msgid "Both B<CLONE_NEWUSER> and B<CLONE_FS> were specified in I<flags>."
msgstr ""

#. type: Plain text
#: man-pages/man2/clone.2:1090
msgid "Both B<CLONE_NEWIPC> and B<CLONE_SYSVSEM> were specified in I<flags>."
msgstr ""

#. type: Plain text
#: man-pages/man2/clone.2:1102
msgid ""
"One (or both) of B<CLONE_NEWPID> or B<CLONE_NEWUSER> and one (or both) of "
"B<CLONE_THREAD> or B<CLONE_PARENT> were specified in I<flags>."
msgstr ""

#. type: Plain text
#: man-pages/man2/clone.2:1111
msgid ""
"Returned by the glibc B<clone>()  wrapper function when I<fn> or "
"I<child_stack> is specified as NULL."
msgstr ""

#. type: Plain text
#: man-pages/man2/clone.2:1160
msgid ""
"I<child_stack> is not aligned to a suitable boundary for this architecture.  "
"For example, on aarch64, I<child_stack> must be a multiple of 16."
msgstr ""

#. type: Plain text
#: man-pages/man2/clone.2:1165
msgid "B<CLONE_PIDFD> was specified together with B<CLONE_DETACHED.>"
msgstr ""

#. type: Plain text
#: man-pages/man2/clone.2:1170
msgid "B<CLONE_PIDFD> was specified together with B<CLONE_PARENT_SETTID.>"
msgstr ""

#. type: Plain text
#: man-pages/man2/clone.2:1175
msgid "B<CLONE_PIDFD> was specified together with B<CLONE_THREAD.>"
msgstr ""

#. type: Plain text
#: man-pages/man2/clone.2:1180
msgid ""
"Cannot allocate sufficient memory to allocate a task structure for the "
"child, or to copy those parts of the caller's context that need to be "
"copied."
msgstr ""

#. type: Plain text
#: man-pages/man2/clone.2:1220
msgid ""
"B<CLONE_NEWCGROUP>, B<CLONE_NEWIPC>, B<CLONE_NEWNET>, B<CLONE_NEWNS>, "
"B<CLONE_NEWPID>, or B<CLONE_NEWUTS> was specified by an unprivileged process "
"(process without B<CAP_SYS_ADMIN>)."
msgstr ""

#. type: Plain text
#: man-pages/man2/clone.2:1225
msgid ""
"B<CLONE_PID> was specified by a process other than process 0.  (This error "
"occurs only on Linux 2.5.15 and earlier.)"
msgstr ""

#. type: TP
#: man-pages/man2/clone.2:1243 man-pages/man2/fork.2:274
#, no-wrap
msgid "B<ERESTARTNOINTR> (since Linux 2.6.17)"
msgstr ""

#.  commit 4a2c7a7837da1b91468e50426066d988050e4d56
#. type: Plain text
#: man-pages/man2/clone.2:1248 man-pages/man2/fork.2:279
msgid ""
"System call was interrupted by a signal and will be restarted.  (This can be "
"seen only during a trace.)"
msgstr ""

#. type: TP
#: man-pages/man2/clone.2:1248
#, no-wrap
msgid "B<EUSERS> (Linux 3.11 to Linux 4.8)"
msgstr ""

#. type: Plain text
#: man-pages/man2/clone.2:1268
msgid ""
"B<clone>()  is Linux-specific and should not be used in programs intended to "
"be portable."
msgstr ""

#. type: Plain text
#: man-pages/man2/clone.2:1274
msgid ""
"The B<kcmp>(2)  system call can be used to test whether two processes share "
"various resources such as a file descriptor table, System V semaphore undo "
"operations, or a virtual address space."
msgstr ""

#. type: Plain text
#: man-pages/man2/clone.2:1280
msgid ""
"Handlers registered using B<pthread_atfork>(3)  are not executed during a "
"call to B<clone>()."
msgstr ""

#. type: Plain text
#: man-pages/man2/clone.2:1290
msgid ""
"In the Linux 2.4.x series, B<CLONE_THREAD> generally does not make the "
"parent of the new thread the same as the parent of the calling process.  "
"However, for kernel versions 2.4.7 to 2.4.18 the B<CLONE_THREAD> flag "
"implied the B<CLONE_PARENT> flag (as in Linux 2.6.0 and later)."
msgstr ""

#. type: Plain text
#: man-pages/man2/clone.2:1299
msgid ""
"For a while there was B<CLONE_DETACHED> (introduced in 2.5.32): parent wants "
"no child-exit signal.  In Linux 2.6.2, the need to give this flag together "
"with B<CLONE_THREAD> disappeared.  This flag is still defined, but has no "
"effect."
msgstr ""

#. type: Plain text
#: man-pages/man2/clone.2:1304
msgid ""
"On i386, B<clone>()  should not be called through vsyscall, but directly "
"through I<int $0x80>."
msgstr ""

#. type: Plain text
#: man-pages/man2/clone.2:1335
msgid ""
"GNU C library versions 2.3.4 up to and including 2.24 contained a wrapper "
"function for B<getpid>(2)  that performed caching of PIDs.  This caching "
"relied on support in the glibc wrapper for B<clone>(), but limitations in "
"the implementation meant that the cache was not up to date in some "
"circumstances.  In particular, if a signal was delivered to the child "
"immediately after the B<clone>()  call, then a call to B<getpid>(2)  in a "
"handler for the signal could return the PID of the calling process (\"the "
"parent\"), if the clone wrapper had not yet had a chance to update the PID "
"cache in the child.  (This discussion ignores the case where the child was "
"created using B<CLONE_THREAD>, when B<getpid>(2)  I<should> return the same "
"value in the child and in the process that called B<clone>(), since the "
"caller and the child are in the same thread group.  The stale-cache problem "
"also does not occur if the I<flags> argument includes B<CLONE_VM>.)  To get "
"the truth, it was sometimes necessary to use code such as the following:"
msgstr ""

#. type: Plain text
#: man-pages/man2/clone.2:1339
#, no-wrap
msgid "#include E<lt>syscall.hE<gt>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/clone.2:1341
#, no-wrap
msgid "pid_t mypid;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/clone.2:1343
#, no-wrap
msgid "mypid = syscall(SYS_getpid);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/clone.2:1352
msgid ""
"Because of the stale-cache problem, as well as other problems noted in "
"B<getpid>(2), the PID caching feature was removed in glibc 2.25."
msgstr ""

#. type: Plain text
#: man-pages/man2/clone.2:1362
msgid ""
"The following program demonstrates the use of B<clone>()  to create a child "
"process that executes in a separate UTS namespace.  The child changes the "
"hostname in its UTS namespace.  Both parent and child then display the "
"system hostname, making it possible to see that the hostname differs in the "
"UTS namespaces of the parent and child.  For an example of the use of this "
"program, see B<setns>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/clone.2:1372
#, no-wrap
msgid ""
"#define _GNU_SOURCE\n"
"#include E<lt>sys/wait.hE<gt>\n"
"#include E<lt>sys/utsname.hE<gt>\n"
"#include E<lt>sched.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/clone.2:1380
#, no-wrap
msgid ""
"static int              /* Start function for cloned child */\n"
"childFunc(void *arg)\n"
"{\n"
"    struct utsname uts;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/clone.2:1382
#, no-wrap
msgid "    /* Change hostname in UTS namespace of child */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/clone.2:1385
#, no-wrap
msgid ""
"    if (sethostname(arg, strlen(arg)) == -1)\n"
"        errExit(\"sethostname\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/clone.2:1387
#, no-wrap
msgid "    /* Retrieve and display hostname */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/clone.2:1391
#, no-wrap
msgid ""
"    if (uname(&uts) == -1)\n"
"        errExit(\"uname\");\n"
"    printf(\"uts.nodename in child:  %s\\en\", uts.nodename);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/clone.2:1395
#, no-wrap
msgid ""
"    /* Keep the namespace open for a while, by sleeping.\n"
"       This allows some experimentation--for example, another\n"
"       process might join the namespace. */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/clone.2:1397
#, no-wrap
msgid "    sleep(200);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/clone.2:1400
#, no-wrap
msgid ""
"    return 0;           /* Child terminates now */\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/clone.2:1402
#, no-wrap
msgid "#define STACK_SIZE (1024 * 1024)    /* Stack size for cloned child */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/clone.2:1410
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    char *stack;                    /* Start of stack buffer */\n"
"    char *stackTop;                 /* End of stack buffer */\n"
"    pid_t pid;\n"
"    struct utsname uts;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/clone.2:1415
#, no-wrap
msgid ""
"    if (argc E<lt> 2) {\n"
"        fprintf(stderr, \"Usage: %s E<lt>child-hostnameE<gt>\\en\", "
"argv[0]);\n"
"        exit(EXIT_SUCCESS);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/clone.2:1417
#, no-wrap
msgid "    /* Allocate stack for child */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/clone.2:1422
#, no-wrap
msgid ""
"    stack = malloc(STACK_SIZE);\n"
"    if (stack == NULL)\n"
"        errExit(\"malloc\");\n"
"    stackTop = stack + STACK_SIZE;  /* Assume stack grows downward */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/clone.2:1425
#, no-wrap
msgid ""
"    /* Create child that has its own UTS namespace;\n"
"       child commences execution in childFunc() */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/clone.2:1430
#, no-wrap
msgid ""
"    pid = clone(childFunc, stackTop, CLONE_NEWUTS | SIGCHLD, argv[1]);\n"
"    if (pid == -1)\n"
"        errExit(\"clone\");\n"
"    printf(\"clone() returned %ld\\en\", (long) pid);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/clone.2:1432 man-pages/man2/futex.2:1875
#, no-wrap
msgid "    /* Parent falls through to here */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/clone.2:1434
#, no-wrap
msgid "    sleep(1);           /* Give child time to change its hostname */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/clone.2:1437
#, no-wrap
msgid ""
"    /* Display hostname in parent\\(aqs UTS namespace. This will be\n"
"       different from hostname in child\\(aqs UTS namespace. */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/clone.2:1441
#, no-wrap
msgid ""
"    if (uname(&uts) == -1)\n"
"        errExit(\"uname\");\n"
"    printf(\"uts.nodename in parent: %s\\en\", uts.nodename);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/clone.2:1445
#, no-wrap
msgid ""
"    if (waitpid(pid, NULL, 0) == -1)    /* Wait for child */\n"
"        errExit(\"waitpid\");\n"
"    printf(\"child has terminated\\en\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/clone.2:1464
msgid ""
"B<fork>(2), B<futex>(2), B<getpid>(2), B<gettid>(2), B<kcmp>(2), "
"B<pidfd_open>(2), B<set_thread_area>(2), B<set_tid_address>(2), B<setns>(2), "
"B<tkill>(2), B<unshare>(2), B<wait>(2), B<capabilities>(7), "
"B<namespaces>(7), B<pthreads>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/timer_delete.2:26
#, no-wrap
msgid "TIMER_DELETE"
msgstr ""

#. type: Plain text
#: man-pages/man2/timer_delete.2:29
msgid "timer_delete - delete a POSIX per-process timer"
msgstr ""

#. type: Plain text
#: man-pages/man2/timer_delete.2:34
#, no-wrap
msgid "B<int timer_delete(timer_t >I<timerid>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/timer_delete.2:45
msgid "B<timer_delete>(): _POSIX_C_SOURCE\\ E<gt>=\\ 199309L"
msgstr ""

#. type: Plain text
#: man-pages/man2/timer_delete.2:53
msgid ""
"B<timer_delete>()  deletes the timer whose ID is given in I<timerid>.  If "
"the timer was armed at the time of this call, it is disarmed before being "
"deleted.  The treatment of any pending signal generated by the deleted timer "
"is unspecified."
msgstr ""

#. type: Plain text
#: man-pages/man2/timer_delete.2:60
msgid ""
"On success, B<timer_delete>()  returns 0.  On failure, -1 is returned, and "
"I<errno> is set to indicate the error."
msgstr ""

#. type: Plain text
#: man-pages/man2/timer_delete.2:65 man-pages/man2/timer_getoverrun.2:95
msgid "I<timerid> is not a valid timer ID."
msgstr ""

#. type: Plain text
#: man-pages/man2/timer_delete.2:67 man-pages/man2/timer_getoverrun.2:97
#: man-pages/man2/timer_create.2:221
msgid "This system call is available since Linux 2.6."
msgstr ""

#. type: Plain text
#: man-pages/man2/timer_delete.2:74
msgid ""
"B<clock_gettime>(2), B<timer_create>(2), B<timer_getoverrun>(2), "
"B<timer_settime>(2), B<time>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/ioctl_ficlonerange.2:23
#, no-wrap
msgid "IOCTL-FICLONERANGE"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_ficlonerange.2:26
msgid ""
"ioctl_ficlonerange, ioctl_ficlone - share some the data of one file with "
"another file"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_ficlonerange.2:33
msgid ""
"B<int ioctl(int >I<dest_fd>B<, FICLONERANGE, struct file_clone_range "
"*>I<arg>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_ficlonerange.2:35
msgid "B<int ioctl(int >I<dest_fd>B<, FICLONE, int >I<src_fd>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_ficlonerange.2:50
msgid ""
"If a filesystem supports files sharing physical storage between multiple "
"files (\"reflink\"), this B<ioctl>(2)  operation can be used to make some of "
"the data in the I<src_fd> file appear in the I<dest_fd> file by sharing the "
"underlying storage, which is faster than making a separate physical copy of "
"the data.  Both files must reside within the same filesystem.  If a file "
"write should occur to a shared region, the filesystem must ensure that the "
"changes remain private to the file being written.  This behavior is commonly "
"referred to as \"copy on write\"."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_ficlonerange.2:67
msgid ""
"This ioctl reflinks up to I<src_length> bytes from file descriptor I<src_fd> "
"at offset I<src_offset> into the file I<dest_fd> at offset I<dest_offset>, "
"provided that both are files.  If I<src_length> is zero, the ioctl reflinks "
"to the end of the source file.  This information is conveyed in a structure "
"of the following form:"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_ficlonerange.2:76
#, no-wrap
msgid ""
"struct file_clone_range {\n"
"    __s64 src_fd;\n"
"    __u64 src_offset;\n"
"    __u64 src_length;\n"
"    __u64 dest_offset;\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_ficlonerange.2:81
msgid ""
"Clones are atomic with regards to concurrent writes, so no locks need to be "
"taken to obtain a consistent cloned copy."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_ficlonerange.2:85
msgid "The B<FICLONE> ioctl clones entire files."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_ficlonerange.2:101
msgid ""
"I<src_fd> is not open for reading; I<dest_fd> is not open for writing or is "
"open for append-only writes; or the filesystem which I<src_fd> resides on "
"does not support reflink."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_ficlonerange.2:110
msgid ""
"The filesystem does not support reflinking the ranges of the given files.  "
"This error can also appear if either file descriptor represents a device, "
"FIFO, or socket.  Disk filesystems generally require the offset and length "
"arguments to be aligned to the fundamental block size.  XFS and Btrfs do not "
"support overlapping reflink ranges in the same file."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_ficlonerange.2:118
msgid ""
"This can appear if the filesystem does not support reflinking either file "
"descriptor, or if either file descriptor refers to special inodes."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_ficlonerange.2:137
msgid ""
"These ioctl operations first appeared in Linux 4.5.  They were previously "
"known as B<BTRFS_IOC_CLONE> and B<BTRFS_IOC_CLONE_RANGE>, and were private "
"to Btrfs."
msgstr ""

#. type: TH
#: man-pages/man2/iopl.2:33
#, no-wrap
msgid "IOPL"
msgstr ""

#. type: Plain text
#: man-pages/man2/iopl.2:36
msgid "iopl - change I/O privilege level"
msgstr ""

#. type: Plain text
#: man-pages/man2/iopl.2:38
msgid "B<#include E<lt>sys/io.hE<gt>>"
msgstr ""

#. type: Plain text
#: man-pages/man2/iopl.2:40
msgid "B<int iopl(int >I<level>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/iopl.2:45
msgid ""
"B<iopl>()  changes the I/O privilege level of the calling process, as "
"specified by the two least significant bits in I<level>."
msgstr ""

#. type: Plain text
#: man-pages/man2/iopl.2:51
msgid ""
"This call is necessary to allow 8514-compatible X servers to run under "
"Linux.  Since these X servers require access to all 65536 I/O ports, the "
"B<ioperm>(2)  call is not sufficient."
msgstr ""

#. type: Plain text
#: man-pages/man2/iopl.2:55
msgid ""
"In addition to granting unrestricted I/O port access, running at a higher "
"I/O privilege level also allows the process to disable interrupts.  This "
"will probably crash the system, and is not recommended."
msgstr ""

#. type: Plain text
#: man-pages/man2/iopl.2:61
msgid ""
"Permissions are not inherited by the child process created by B<fork>(2)  "
"and are not preserved across B<execve>(2)  (but see NOTES)."
msgstr ""

#. type: Plain text
#: man-pages/man2/iopl.2:63
msgid "The I/O privilege level for a normal process is 0."
msgstr ""

#. type: Plain text
#: man-pages/man2/iopl.2:67 man-pages/man2/ioperm.2:77
msgid ""
"This call is mostly for the i386 architecture.  On many other architectures "
"it does not exist or will always return an error."
msgstr ""

#. type: Plain text
#: man-pages/man2/iopl.2:77
msgid "I<level> is greater than 3."
msgstr ""

#. type: Plain text
#: man-pages/man2/iopl.2:80
msgid "This call is unimplemented."
msgstr ""

#. type: Plain text
#: man-pages/man2/iopl.2:88
msgid ""
"The calling process has insufficient privilege to call B<iopl>(); the "
"B<CAP_SYS_RAWIO> capability is required to raise the I/O privilege level "
"above its current value."
msgstr ""

#. type: Plain text
#: man-pages/man2/iopl.2:92
msgid ""
"B<iopl>()  is Linux-specific and should not be used in programs that are "
"intended to be portable."
msgstr ""

#.  Libc5 treats it as a system call and has a prototype in
#.  .IR <unistd.h> .
#.  Glibc1 does not have a prototype.
#. type: Plain text
#: man-pages/man2/iopl.2:101
msgid ""
"Glibc2 has a prototype both in I<E<lt>sys/io.hE<gt>> and in "
"I<E<lt>sys/perm.hE<gt>>.  Avoid the latter, it is available on i386 only."
msgstr ""

#. type: Plain text
#: man-pages/man2/iopl.2:111
msgid ""
"Prior to Linux 3.7, on some architectures (such as i386), permissions "
"I<were> inherited by the child produced by B<fork>(2)  and were preserved "
"across B<execve>(2).  This behavior was inadvertently changed in Linux 3.7, "
"and won't be reinstated."
msgstr ""

#. type: Plain text
#: man-pages/man2/iopl.2:114
msgid "B<ioperm>(2), B<outb>(2), B<capabilities>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/cacheflush.2:25
#, no-wrap
msgid "CACHEFLUSH"
msgstr ""

#. type: Plain text
#: man-pages/man2/cacheflush.2:28
msgid "cacheflush - flush contents of instruction and/or data cache"
msgstr ""

#. type: Plain text
#: man-pages/man2/cacheflush.2:31
#, no-wrap
msgid "B<#include E<lt>asm/cachectl.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/cacheflush.2:33
#, no-wrap
msgid "B<int cacheflush(char *>I<addr>B<, int >I<nbytes>B<, int >I<cache>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/cacheflush.2:43
msgid ""
"B<cacheflush>()  flushes the contents of the indicated cache(s) for the user "
"addresses in the range I<addr> to I<(addr+nbytes-1)>.  I<cache> may be one "
"of:"
msgstr ""

#. type: TP
#: man-pages/man2/cacheflush.2:43
#, no-wrap
msgid "B<ICACHE>"
msgstr ""

#. type: Plain text
#: man-pages/man2/cacheflush.2:46
msgid "Flush the instruction cache."
msgstr ""

#. type: TP
#: man-pages/man2/cacheflush.2:46
#, no-wrap
msgid "B<DCACHE>"
msgstr ""

#. type: Plain text
#: man-pages/man2/cacheflush.2:49
msgid "Write back to memory and invalidate the affected valid cache lines."
msgstr ""

#. type: TP
#: man-pages/man2/cacheflush.2:49
#, no-wrap
msgid "B<BCACHE>"
msgstr ""

#. type: Plain text
#: man-pages/man2/cacheflush.2:53
msgid "Same as B<(ICACHE|DCACHE)>."
msgstr ""

#. type: Plain text
#: man-pages/man2/cacheflush.2:59
msgid ""
"B<cacheflush>()  returns 0 on success or -1 on error.  If errors are "
"detected, I<errno> will indicate the error."
msgstr ""

#. type: Plain text
#: man-pages/man2/cacheflush.2:67
msgid ""
"Some or all of the address range I<addr> to I<(addr+nbytes-1)> is not "
"accessible."
msgstr ""

#. type: Plain text
#: man-pages/man2/cacheflush.2:76
msgid "I<cache> is not one of B<ICACHE>, B<DCACHE>, or B<BCACHE> (but see BUGS)."
msgstr ""

#. type: Plain text
#: man-pages/man2/cacheflush.2:82
msgid ""
"Historically, this system call was available on all MIPS UNIX variants "
"including RISC/os, IRIX, Ultrix, NetBSD, OpenBSD, and FreeBSD (and also on "
"some non-UNIX MIPS operating systems), so that the existence of this call in "
"MIPS operating systems is a de-facto standard."
msgstr ""

#. type: SS
#: man-pages/man2/cacheflush.2:82
#, no-wrap
msgid "Caveat"
msgstr ""

#. type: Plain text
#: man-pages/man2/cacheflush.2:89
msgid ""
"B<cacheflush>()  should not be used in programs intended to be portable.  On "
"Linux, this call first appeared on the MIPS architecture, but nowadays, "
"Linux provides a B<cacheflush>()  system call on some other architectures, "
"but with different arguments."
msgstr ""

#. type: Plain text
#: man-pages/man2/cacheflush.2:96
msgid ""
"Linux kernels older than version 2.6.11 ignore the I<addr> and I<nbytes> "
"arguments, making this function fairly expensive.  Therefore, the whole "
"cache is always flushed."
msgstr ""

#. type: Plain text
#: man-pages/man2/cacheflush.2:103
msgid ""
"This function always behaves as if B<BCACHE> has been passed for the "
"I<cache> argument and does not do any error checking on the I<cache> "
"argument."
msgstr ""

#. type: TH
#: man-pages/man2/_syscall.2:38
#, no-wrap
msgid "_SYSCALL"
msgstr ""

#. type: Plain text
#: man-pages/man2/_syscall.2:41
msgid "_syscall - invoking a system call without library support (OBSOLETE)"
msgstr ""

#. type: Plain text
#: man-pages/man2/_syscall.2:43
msgid "B<#include E<lt>linux/unistd.hE<gt>>"
msgstr ""

#. type: Plain text
#: man-pages/man2/_syscall.2:45
msgid "A _syscall macro"
msgstr ""

#. type: Plain text
#: man-pages/man2/_syscall.2:47
msgid "desired system call"
msgstr ""

#. type: Plain text
#: man-pages/man2/_syscall.2:53
msgid ""
"The important thing to know about a system call is its prototype.  You need "
"to know how many arguments, their types, and the function return type.  "
"There are seven macros that make the actual call into the system easier.  "
"They have the form:"
msgstr ""

#. type: Plain text
#: man-pages/man2/_syscall.2:57
#, no-wrap
msgid "_syscallI<X>(I<type>,I<name>,I<type1>,I<arg1>,I<type2>,I<arg2>,...)\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/_syscall.2:61
msgid "where"
msgstr ""

#. type: Plain text
#: man-pages/man2/_syscall.2:65
msgid "I<X> is 0\\(en6, which are the number of arguments taken by the system call"
msgstr ""

#. type: Plain text
#: man-pages/man2/_syscall.2:68
msgid "I<type> is the return type of the system call"
msgstr ""

#. type: Plain text
#: man-pages/man2/_syscall.2:71
msgid "I<name> is the name of the system call"
msgstr ""

#. type: Plain text
#: man-pages/man2/_syscall.2:74
msgid "I<typeN> is the Nth argument's type"
msgstr ""

#. type: Plain text
#: man-pages/man2/_syscall.2:77
msgid "I<argN> is the name of the Nth argument"
msgstr ""

#. type: Plain text
#: man-pages/man2/_syscall.2:85
msgid ""
"These macros create a function called I<name> with the arguments you "
"specify.  Once you include the _syscall() in your source file, you call the "
"system call by I<name>."
msgstr ""

#. type: Plain text
#: man-pages/man2/_syscall.2:87
msgid "I</usr/include/linux/unistd.h>"
msgstr ""

#. type: Plain text
#: man-pages/man2/_syscall.2:89
msgid "The use of these macros is Linux-specific, and deprecated."
msgstr ""

#. type: Plain text
#: man-pages/man2/_syscall.2:99
msgid ""
"Starting around kernel 2.6.18, the _syscall macros were removed from header "
"files supplied to user space.  Use B<syscall>(2)  instead.  (Some "
"architectures, notably ia64, never provided the _syscall macros; on those "
"architectures, B<syscall>(2)  was always required.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/_syscall.2:105
msgid ""
"The _syscall() macros I<do not> produce a prototype.  You may have to create "
"one, especially for C++ users."
msgstr ""

#. type: Plain text
#: man-pages/man2/_syscall.2:126
msgid ""
"System calls are not required to return only positive or negative error "
"codes.  You need to read the source to be sure how it will return errors.  "
"Usually, it is the negative of a standard error code, for example, "
"-I<EPERM>.  The _syscall() macros will return the result I<r> of the system "
"call when I<r> is nonnegative, but will return -1 and set the variable "
"I<errno> to -I<r> when I<r> is negative.  For the error codes, see "
"B<errno>(3)."
msgstr ""

#.  The preferred way to invoke system calls that glibc does not know
#.  about yet is via
#.  .BR syscall (2).
#.  However, this mechanism can be used only if using a libc
#.  (such as glibc) that supports
#.  .BR syscall (2),
#.  and if the
#.  .I <sys/syscall.h>
#.  header file contains the required SYS_foo definition.
#.  Otherwise, the use of a _syscall macro is required.
#. type: Plain text
#: man-pages/man2/_syscall.2:142
msgid ""
"When defining a system call, the argument types I<must> be passed by-value "
"or by-pointer (for aggregates like structs)."
msgstr ""

#. type: Plain text
#: man-pages/man2/_syscall.2:149
#, no-wrap
msgid ""
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"
"#include E<lt>linux/unistd.hE<gt>       /* for _syscallX macros/related "
"stuff */\n"
"#include E<lt>linux/kernel.hE<gt>       /* for struct sysinfo */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/_syscall.2:151
#, no-wrap
msgid "_syscall1(int, sysinfo, struct sysinfo *, info);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/_syscall.2:157
#, no-wrap
msgid ""
"int\n"
"main(void)\n"
"{\n"
"    struct sysinfo s_info;\n"
"    int error;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/_syscall.2:172
#, no-wrap
msgid ""
"    error = sysinfo(&s_info);\n"
"    printf(\"code error = %d\\en\", error);\n"
"    printf(\"Uptime = %lds\\enLoad: 1 min %lu / 5 min %lu / 15 min "
"%lu\\en\"\n"
"           \"RAM: total %lu / free %lu / shared %lu\\en\"\n"
"           \"Memory in buffers = %lu\\enSwap: total %lu / free %lu\\en\"\n"
"           \"Number of processes = %d\\en\",\n"
"           s_info.uptime, s_info.loads[0],\n"
"           s_info.loads[1], s_info.loads[2],\n"
"           s_info.totalram, s_info.freeram,\n"
"           s_info.sharedram, s_info.bufferram,\n"
"           s_info.totalswap, s_info.freeswap,\n"
"           s_info.procs);\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""

#. type: SS
#: man-pages/man2/_syscall.2:173
#, no-wrap
msgid "Sample output"
msgstr ""

#. type: Plain text
#: man-pages/man2/_syscall.2:182
#, no-wrap
msgid ""
"code error = 0\n"
"uptime = 502034s\n"
"Load: 1 min 13376 / 5 min 5504 / 15 min 1152\n"
"RAM: total 15343616 / free 827392 / shared 8237056\n"
"Memory in buffers = 5066752\n"
"Swap: total 27881472 / free 24698880\n"
"Number of processes = 40\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/_syscall.2:186
msgid "B<intro>(2), B<syscall>(2), B<errno>(3)"
msgstr ""

#. type: TH
#: man-pages/man2/alarm.2:30
#, no-wrap
msgid "ALARM"
msgstr ""

#. type: Plain text
#: man-pages/man2/alarm.2:33
msgid "alarm - set an alarm clock for delivery of a signal"
msgstr ""

#. type: Plain text
#: man-pages/man2/alarm.2:38
#, no-wrap
msgid "B<unsigned int alarm(unsigned int >I<seconds>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/alarm.2:46
msgid ""
"B<alarm>()  arranges for a B<SIGALRM> signal to be delivered to the calling "
"process in I<seconds> seconds."
msgstr ""

#. type: Plain text
#: man-pages/man2/alarm.2:50
msgid "If I<seconds> is zero, any pending alarm is canceled."
msgstr ""

#. type: Plain text
#: man-pages/man2/alarm.2:54
msgid "In any event any previously set B<alarm>()  is canceled."
msgstr ""

#. type: Plain text
#: man-pages/man2/alarm.2:59
msgid ""
"B<alarm>()  returns the number of seconds remaining until any previously "
"scheduled alarm was due to be delivered, or zero if there was no previously "
"scheduled alarm."
msgstr ""

#. type: Plain text
#: man-pages/man2/alarm.2:67
msgid ""
"B<alarm>()  and B<setitimer>(2)  share the same timer; calls to one will "
"interfere with use of the other."
msgstr ""

#. type: Plain text
#: man-pages/man2/alarm.2:74
msgid ""
"Alarms created by B<alarm>()  are preserved across B<execve>(2)  and are not "
"inherited by children created via B<fork>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/alarm.2:83
msgid ""
"B<sleep>(3)  may be implemented using B<SIGALRM>; mixing calls to B<alarm>()  "
"and B<sleep>(3)  is a bad idea."
msgstr ""

#. type: Plain text
#: man-pages/man2/alarm.2:86
msgid ""
"Scheduling delays can, as ever, cause the execution of the process to be "
"delayed by an arbitrary amount of time."
msgstr ""

#. type: Plain text
#: man-pages/man2/alarm.2:96
msgid ""
"B<gettimeofday>(2), B<pause>(2), B<select>(2), B<setitimer>(2), "
"B<sigaction>(2), B<signal>(2), B<timer_create>(2), B<timerfd_create>(2), "
"B<sleep>(3), B<time>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/sysinfo.2:35
#, no-wrap
msgid "SYSINFO"
msgstr ""

#. type: Plain text
#: man-pages/man2/sysinfo.2:38
msgid "sysinfo - return system information"
msgstr ""

#. type: Plain text
#: man-pages/man2/sysinfo.2:40
msgid "B<#include E<lt>sys/sysinfo.hE<gt>>"
msgstr ""

#. type: Plain text
#: man-pages/man2/sysinfo.2:42
msgid "B<int sysinfo(struct sysinfo *>I<info>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/sysinfo.2:46
msgid ""
"B<sysinfo>()  returns certain statistics on memory and swap usage, as well "
"as the load average."
msgstr ""

#. type: Plain text
#: man-pages/man2/sysinfo.2:50
msgid ""
"Until Linux 2.3.16, B<sysinfo>()  returned information in the following "
"structure:"
msgstr ""

#. type: Plain text
#: man-pages/man2/sysinfo.2:65
#, no-wrap
msgid ""
"struct sysinfo {\n"
"    long uptime;             /* Seconds since boot */\n"
"    unsigned long loads[3];  /* 1, 5, and 15 minute load averages */\n"
"    unsigned long totalram;  /* Total usable main memory size */\n"
"    unsigned long freeram;   /* Available memory size */\n"
"    unsigned long sharedram; /* Amount of shared memory */\n"
"    unsigned long bufferram; /* Memory used by buffers */\n"
"    unsigned long totalswap; /* Total swap space size */\n"
"    unsigned long freeswap;  /* Swap space still available */\n"
"    unsigned short procs;    /* Number of current processes */\n"
"    char _f[22];             /* Pads structure to 64 bytes */\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/sysinfo.2:70
msgid ""
"In the above structure, the sizes of the memory and swap fields are given in "
"bytes."
msgstr ""

#. type: Plain text
#: man-pages/man2/sysinfo.2:73
msgid ""
"Since Linux 2.3.23 (i386) and Linux 2.3.48 (all architectures) the structure "
"is:"
msgstr ""

#. type: Plain text
#: man-pages/man2/sysinfo.2:92
#, no-wrap
msgid ""
"struct sysinfo {\n"
"    long uptime;             /* Seconds since boot */\n"
"    unsigned long loads[3];  /* 1, 5, and 15 minute load averages */\n"
"    unsigned long totalram;  /* Total usable main memory size */\n"
"    unsigned long freeram;   /* Available memory size */\n"
"    unsigned long sharedram; /* Amount of shared memory */\n"
"    unsigned long bufferram; /* Memory used by buffers */\n"
"    unsigned long totalswap; /* Total swap space size */\n"
"    unsigned long freeswap;  /* Swap space still available */\n"
"    unsigned short procs;    /* Number of current processes */\n"
"    unsigned long totalhigh; /* Total high memory size */\n"
"    unsigned long freehigh;  /* Available high memory size */\n"
"    unsigned int mem_unit;   /* Memory unit size in bytes */\n"
"    char _f[20-2*sizeof(long)-sizeof(int)];\n"
"                             /* Padding to 64 bytes */\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/sysinfo.2:99
msgid ""
"In the above structure, sizes of the memory and swap fields are given as "
"multiples of I<mem_unit> bytes."
msgstr ""

#. type: Plain text
#: man-pages/man2/sysinfo.2:106
msgid ""
"On success, B<sysinfo>()  returns zero.  On error, -1 is returned, and "
"I<errno> is set to indicate the cause of the error."
msgstr ""

#. type: Plain text
#: man-pages/man2/sysinfo.2:111
msgid "I<info> is not a valid address."
msgstr ""

#. type: Plain text
#: man-pages/man2/sysinfo.2:114
msgid "B<sysinfo>()  first appeared in Linux 0.98.pl6."
msgstr ""

#. type: Plain text
#: man-pages/man2/sysinfo.2:122
msgid ""
"All of the information provided by this system call is also available via "
"I</proc/meminfo> and I</proc/loadavg>."
msgstr ""

#. type: Plain text
#: man-pages/man2/sysinfo.2:123 man-pages/man2/sysctl.2:181
msgid "B<proc>(5)"
msgstr ""

#. type: TH
#: man-pages/man2/ioctl_fat.2:24
#, no-wrap
msgid "IOCTL-FAT"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_fat.2:27
msgid "ioctl_fat - manipulating the FAT filesystem"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_fat.2:31
#, no-wrap
msgid ""
"B<#include E<lt>linux/msdos_fs.hE<gt>>\n"
"B<#include E<lt>sys/ioctl.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_fat.2:39
#, no-wrap
msgid ""
"B<int ioctl(int >I<fd>B<, FAT_IOCTL_GET_ATTRIBUTES, uint32_t "
"*>I<attr>B<);>\n"
"B<int ioctl(int >I<fd>B<, FAT_IOCTL_SET_ATTRIBUTES, uint32_t "
"*>I<attr>B<);>\n"
"B<int ioctl(int >I<fd>B<, FAT_IOCTL_GET_VOLUME_ID, uint32_t *>I<id>B<);>\n"
"B<int ioctl(int >I<fd>B<, VFAT_IOCTL_READDIR_BOTH,>\n"
"B<          struct __fat_dirent[2] >I<entry>B<);>\n"
"B<int ioctl(int >I<fd>B<, VFAT_IOCTL_READDIR_SHORT,>\n"
"B<          struct __fat_dirent[2] >I<entry>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_fat.2:45
msgid ""
"The B<ioctl>(2)  system call can be used to read and write metadata of FAT "
"filesystems that are not accessible using other system calls."
msgstr ""

#. type: SS
#: man-pages/man2/ioctl_fat.2:45
#, no-wrap
msgid "Reading and setting file attributes"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_fat.2:51
msgid ""
"Files and directories in the FAT filesystem possess an attribute bit mask "
"that can be read with B<FAT_IOCTL_GET_ATTRIBUTES> and written with "
"B<FAT_IOCTL_SET_ATTRIBUTES>."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_fat.2:60
msgid ""
"The I<fd> argument contains a file descriptor for a file or directory.  It "
"is sufficient to create the file descriptor by calling B<open>(2)  with the "
"B<O_RDONLY> flag."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_fat.2:65
msgid ""
"The I<attr> argument contains a pointer to a bit mask.  The bits of the bit "
"mask are:"
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_fat.2:65
#, no-wrap
msgid "B<ATTR_RO>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_fat.2:68
msgid "This bit specifies that the file or directory is read-only."
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_fat.2:68
#, no-wrap
msgid "B<ATTR_HIDDEN>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_fat.2:71
msgid "This bit specifies that the file or directory is hidden."
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_fat.2:71
#, no-wrap
msgid "B<ATTR_SYS>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_fat.2:74
msgid "This bit specifies that the file is a system file."
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_fat.2:74
#, no-wrap
msgid "B<ATTR_VOLUME>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_fat.2:78
msgid ""
"This bit specifies that the file is a volume label.  This attribute is "
"read-only."
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_fat.2:78
#, no-wrap
msgid "B<ATTR_DIR>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_fat.2:82
msgid "This bit specifies that this is a directory.  This attribute is read-only."
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_fat.2:82
#, no-wrap
msgid "B<ATTR_ARCH>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_fat.2:87
msgid ""
"This bit indicates that this file or directory should be archived.  It is "
"set when a file is created or modified.  It is reset by an archiving system."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_fat.2:91
msgid ""
"The zero value B<ATTR_NONE> can be used to indicate that no attribute bit is "
"set."
msgstr ""

#. type: SS
#: man-pages/man2/ioctl_fat.2:91 man-pages/man2/ioctl_fat.2:350
#, no-wrap
msgid "Reading the volume ID"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_fat.2:95
msgid ""
"FAT filesystems are identified by a volume ID.  The volume ID can be read "
"with B<FAT_IOCTL_GET_VOLUME_ID>."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_fat.2:105
msgid ""
"The I<fd> argument can be a file descriptor for any file or directory of the "
"filesystem.  It is sufficient to create the file descriptor by calling "
"B<open>(2)  with the B<O_RDONLY> flag."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_fat.2:111
msgid ""
"The I<id> argument is a pointer to the field that will be filled with the "
"volume ID.  Typically the volume ID is displayed to the user as a group of "
"two 16-bit fields:"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_fat.2:115
#, no-wrap
msgid "printf(\"Volume ID %04x-%04x\\en\", id E<gt>E<gt> 16, id & 0xFFFF);\n"
msgstr ""

#. type: SS
#: man-pages/man2/ioctl_fat.2:117
#, no-wrap
msgid "Reading short file names of a directory"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_fat.2:123
msgid ""
"A file or directory on a FAT filesystem always has a short filename "
"consisting of up to 8 capital letters, optionally followed by a period and "
"up to 3 capital letters for the file extension.  If the actual filename does "
"not fit into this scheme, it is stored as a long filename of up to 255 "
"UTF-16 characters."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_fat.2:128
msgid ""
"The short filenames in a directory can be read with "
"B<VFAT_IOCTL_READDIR_SHORT>.  B<VFAT_IOCTL_READDIR_BOTH> reads both the "
"short and the long filenames."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_fat.2:141
msgid ""
"The I<fd> argument must be a file descriptor for a directory.  It is "
"sufficient to create the file descriptor by calling B<open>(2)  with the "
"B<O_RDONLY> flag.  The file descriptor can be used only once to iterate over "
"the directory entries by calling B<ioctl>(2)  repeatedly."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_fat.2:145
msgid "The I<entry> argument is a two-element array of the following structures:"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_fat.2:154
#, no-wrap
msgid ""
"struct __fat_dirent {\n"
"    long            d_ino;\n"
"    __kernel_off_t  d_off;\n"
"    uint32_t short  d_reclen;\n"
"    char            d_name[256];\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_fat.2:159
msgid ""
"The first entry in the array is for the short filename.  The second entry is "
"for the long filename."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_fat.2:173
msgid ""
"The I<d_ino> and I<d_off> fields are filled only for long filenames.  The "
"I<d_ino> field holds the inode number of the directory.  The I<d_off> field "
"holds the offset of the file entry in the directory.  As these values are "
"not available for short filenames, the user code should simply ignore them."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_fat.2:189
msgid ""
"The field I<d_reclen> contains the length of the filename in the field "
"I<d_name>.  To keep backward compatibility, a length of 0 for the short "
"filename signals that the end of the directory has been reached.  However, "
"the preferred method for detecting the end of the directory is to test the "
"B<ioctl>(2)  return value.  If no long filename exists, field I<d_reclen> is "
"set to 0 and I<d_name> is a character string of length 0 for the long "
"filename."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_fat.2:200
msgid ""
"For B<VFAT_IOCTL_READDIR_BOTH> and B<VFAT_IOCTL_READDIR_SHORT> a return "
"value of 1 signals that a new directory entry has been read and a return "
"value of 0 signals that the end of the directory has been reached."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_fat.2:210
msgid ""
"This error is returned by B<VFAT_IOCTL_READDIR_BOTH> and "
"B<VFAT_IOCTL_READDIR_SHORT> if the file descriptor I<fd> refers to a "
"removed, but still open directory."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_fat.2:219
msgid ""
"This error is returned by B<VFAT_IOCTL_READDIR_BOTH> and "
"B<VFAT_IOCTL_READDIR_SHORT> if the file descriptor I<fd> does not refer to a "
"directory."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_fat.2:224
msgid "The file descriptor I<fd> does not refer to an object in a FAT filesystem."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_fat.2:227
msgid "For further error values, see B<ioctl>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_fat.2:232
msgid ""
"B<VFAT_IOCTL_READDIR_BOTH> and B<VFAT_IOCTL_READDIR_SHORT> first appeared in "
"Linux 2.0."
msgstr ""

#.  just before we got Git history
#. type: Plain text
#: man-pages/man2/ioctl_fat.2:239
msgid ""
"B<FAT_IOCTL_GET_ATTRIBUTES> and B<FAT_IOCTL_SET_ATTRIBUTES> first appeared "
"in Linux 2.6.12."
msgstr ""

#.  commit 6e5b93ee55d401f1619092fb675b57c28c9ed7ec
#. type: Plain text
#: man-pages/man2/ioctl_fat.2:244
msgid ""
"B<FAT_IOCTL_GET_VOLUME_ID> was introduced in version 3.11 of the Linux "
"kernel."
msgstr ""

#. type: SS
#: man-pages/man2/ioctl_fat.2:247
#, no-wrap
msgid "Toggling the archive flag"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_fat.2:254
msgid ""
"The following program demonstrates the usage of B<ioctl>(2)  to manipulate "
"file attributes.  The program reads and displays the archive attribute of a "
"file.  After inverting the value of the attribute, the program reads and "
"displays the attribute again."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_fat.2:257
msgid ""
"The following was recorded when applying the program for the file "
"I</mnt/user/foo>:"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_fat.2:264
#, no-wrap
msgid ""
"# ./toggle_fat_archive_flag /mnt/user/foo\n"
"Archive flag is set\n"
"Toggling archive flag\n"
"Archive flag is not set\n"
msgstr ""

#. type: SS
#: man-pages/man2/ioctl_fat.2:266
#, no-wrap
msgid "Program source (toggle_fat_archive_flag.c)"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_fat.2:276 man-pages/man2/ioctl_fat.2:375
#, no-wrap
msgid ""
"#include E<lt>fcntl.hE<gt>\n"
"#include E<lt>linux/msdos_fs.hE<gt>\n"
"#include E<lt>stdint.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>sys/ioctl.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_fat.2:286
#, no-wrap
msgid ""
"/*\n"
" * Read file attributes of a file on a FAT filesystem.\n"
" * Output the state of the archive flag.\n"
" */\n"
"static uint32_t\n"
"readattr(int fd)\n"
"{\n"
"    uint32_t attr;\n"
"    int ret;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_fat.2:292
#, no-wrap
msgid ""
"    ret = ioctl(fd, FAT_IOCTL_GET_ATTRIBUTES, &attr);\n"
"    if (ret == -1) {\n"
"        perror(\"ioctl\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_fat.2:297
#, no-wrap
msgid ""
"    if (attr & ATTR_ARCH)\n"
"        printf(\"Archive flag is set\\en\");\n"
"    else\n"
"        printf(\"Archive flag is not set\\en\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_fat.2:300
#, no-wrap
msgid ""
"    return attr;\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_fat.2:307
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    uint32_t attr;\n"
"    int fd;\n"
"    int ret;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_fat.2:312 man-pages/man2/ioctl_fat.2:387
#, no-wrap
msgid ""
"    if (argc != 2) {\n"
"        printf(\"Usage: %s FILENAME\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_fat.2:323
#, no-wrap
msgid ""
"    /*\n"
"     * Read and display the FAT file attributes.\n"
"     */\n"
"    attr = readattr(fd);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_fat.2:329
#, no-wrap
msgid ""
"    /*\n"
"     * Invert archive attribute.\n"
"     */\n"
"    printf(\"Toggling archive flag\\en\");\n"
"    attr ^= ATTR_ARCH;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_fat.2:338
#, no-wrap
msgid ""
"    /*\n"
"     * Write the changed FAT file attributes.\n"
"     */\n"
"    ret = ioctl(fd, FAT_IOCTL_SET_ATTRIBUTES, &attr);\n"
"    if (ret == -1) {\n"
"        perror(\"ioctl\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_fat.2:343
#, no-wrap
msgid ""
"    /*\n"
"     * Read and display the FAT file attributes.\n"
"     */\n"
"    readattr(fd);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_fat.2:345 man-pages/man2/ioctl_fat.2:409
#, no-wrap
msgid "    close(fd);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_fat.2:354
msgid ""
"The following program demonstrates the use of B<ioctl>(2)  to display the "
"volume ID of a FAT filesystem."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_fat.2:358
msgid ""
"The following output was recorded when applying the program for directory "
"I</mnt/user>:"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_fat.2:363
#, no-wrap
msgid ""
"$ ./display_fat_volume_id /mnt/user\n"
"Volume ID 6443-6241\n"
msgstr ""

#. type: SS
#: man-pages/man2/ioctl_fat.2:365
#, no-wrap
msgid "Program source (display_fat_volume_id.c)"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_fat.2:382
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    uint32_t id;\n"
"    int fd;\n"
"    int ret;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_fat.2:402
#, no-wrap
msgid ""
"    /*\n"
"     * Read volume ID.\n"
"     */\n"
"    ret = ioctl(fd, FAT_IOCTL_GET_VOLUME_ID, &id);\n"
"    if (ret == -1) {\n"
"        perror(\"ioctl\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_fat.2:407
#, no-wrap
msgid ""
"    /*\n"
"     * Format the output as two groups of 16 bits each.\n"
"     */\n"
"    printf(\"Volume ID %04x-%04x\\en\", id E<gt>E<gt> 16, id & 0xFFFF);\n"
msgstr ""

#. type: SS
#: man-pages/man2/ioctl_fat.2:414
#, no-wrap
msgid "Listing a directory"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_fat.2:418
msgid ""
"The following program demonstrates the use of B<ioctl>(2)  to list a "
"directory."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_fat.2:421
msgid ""
"The following was recorded when applying the program to the directory "
"I</mnt/user>:"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_fat.2:430
#, no-wrap
msgid ""
"$ B<./fat_dir /mnt/user>\n"
"\\[char46] -E<gt> ''\n"
"\\[char46]. -E<gt> ''\n"
"ALONGF~1.TXT -E<gt> 'a long filename.txt'\n"
"UPPER.TXT -E<gt> ''\n"
"LOWER.TXT -E<gt> 'lower.txt'\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_fat.2:442
#, no-wrap
msgid ""
"#include E<lt>fcntl.hE<gt>\n"
"#include E<lt>linux/msdos_fs.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>sys/ioctl.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_fat.2:449
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    struct __fat_dirent entry[2];\n"
"    int fd;\n"
"    int ret;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_fat.2:454
#, no-wrap
msgid ""
"    if (argc != 2) {\n"
"        printf(\"Usage: %s DIRECTORY\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_fat.2:463
#, no-wrap
msgid ""
"    /*\n"
"     * Open file descriptor for the directory.\n"
"     */\n"
"    fd = open(argv[1], O_RDONLY | O_DIRECTORY);\n"
"    if (fd == -1) {\n"
"        perror(\"open\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_fat.2:465 man-pages/man2/userfaultfd.2:607
#, no-wrap
msgid "    for (;;) {\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_fat.2:470
#, no-wrap
msgid ""
"        /*\n"
"         * Read next directory entry.\n"
"         */\n"
"        ret = ioctl( fd, VFAT_IOCTL_READDIR_BOTH, entry);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_fat.2:480
#, no-wrap
msgid ""
"        /*\n"
"         * If an error occurs, the return value is -1.\n"
"         * If the end of the directory list has been reached,\n"
"         * the return value is 0.\n"
"         * For backward compatibility the end of the directory\n"
"         * list is also signaled by d_reclen == 0.\n"
"         */\n"
"        if (ret E<lt> 1)\n"
"            break;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_fat.2:486
#, no-wrap
msgid ""
"        /*\n"
"         * Write both the short name and the long name.\n"
"         */\n"
"        printf(\"%s -E<gt> '%s'\\en\", entry[0].d_name, entry[1].d_name);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_fat.2:491
#, no-wrap
msgid ""
"    if (ret == -1) {\n"
"        perror(\"VFAT_IOCTL_READDIR_BOTH\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_fat.2:496
#, no-wrap
msgid ""
"    /*\n"
"     * Close the file descriptor.\n"
"     */\n"
"    close(fd);\n"
msgstr ""

#. type: TH
#: man-pages/man2/kcmp.2:28
#, no-wrap
msgid "KCMP"
msgstr ""

#. type: Plain text
#: man-pages/man2/kcmp.2:31
msgid "kcmp - compare two processes to determine if they share a kernel resource"
msgstr ""

#. type: Plain text
#: man-pages/man2/kcmp.2:34
#, no-wrap
msgid "B<#include E<lt>linux/kcmp.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/kcmp.2:37
#, no-wrap
msgid ""
"B<int kcmp(pid_t >I<pid1>B<, pid_t >I<pid2>B<, int >I<type>B<,>\n"
"B<         unsigned long >I<idx1>B<, unsigned long >I<idx2>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/kcmp.2:50
msgid ""
"The B<kcmp>()  system call can be used to check whether the two processes "
"identified by I<pid1> and I<pid2> share a kernel resource such as virtual "
"memory, file descriptors, and so on."
msgstr ""

#. type: Plain text
#: man-pages/man2/kcmp.2:61
msgid ""
"Permission to employ B<kcmp>()  is governed by ptrace access mode "
"B<PTRACE_MODE_READ_REALCREDS> checks against both I<pid1> and I<pid2>; see "
"B<ptrace>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/kcmp.2:66
msgid ""
"The I<type> argument specifies which resource is to be compared in the two "
"processes.  It has one of the following values:"
msgstr ""

#. type: TP
#: man-pages/man2/kcmp.2:66
#, no-wrap
msgid "B<KCMP_FILE>"
msgstr ""

#. type: Plain text
#: man-pages/man2/kcmp.2:85
msgid ""
"Check whether a file descriptor I<idx1> in the process I<pid1> refers to the "
"same open file description (see B<open>(2))  as file descriptor I<idx2> in "
"the process I<pid2>.  The existence of two file descriptors that refer to "
"the same open file description can occur as a result of B<dup>(2)  (and "
"similar)  B<fork>(2), or passing file descriptors via a domain socket (see "
"B<unix>(7))."
msgstr ""

#. type: TP
#: man-pages/man2/kcmp.2:85
#, no-wrap
msgid "B<KCMP_FILES>"
msgstr ""

#. type: Plain text
#: man-pages/man2/kcmp.2:97
msgid ""
"Check whether the processes share the same set of open file descriptors.  "
"The arguments I<idx1> and I<idx2> are ignored.  See the discussion of the "
"B<CLONE_FILES> flag in B<clone>(2)."
msgstr ""

#. type: TP
#: man-pages/man2/kcmp.2:97
#, no-wrap
msgid "B<KCMP_FS>"
msgstr ""

#. type: Plain text
#: man-pages/man2/kcmp.2:110
msgid ""
"Check whether the processes share the same filesystem information (i.e., "
"file mode creation mask, working directory, and filesystem root).  The "
"arguments I<idx1> and I<idx2> are ignored.  See the discussion of the "
"B<CLONE_FS> flag in B<clone>(2)."
msgstr ""

#. type: TP
#: man-pages/man2/kcmp.2:110
#, no-wrap
msgid "B<KCMP_IO>"
msgstr ""

#. type: Plain text
#: man-pages/man2/kcmp.2:122
msgid ""
"Check whether the processes share I/O context.  The arguments I<idx1> and "
"I<idx2> are ignored.  See the discussion of the B<CLONE_IO> flag in "
"B<clone>(2)."
msgstr ""

#. type: TP
#: man-pages/man2/kcmp.2:122
#, no-wrap
msgid "B<KCMP_SIGHAND>"
msgstr ""

#. type: Plain text
#: man-pages/man2/kcmp.2:134
msgid ""
"Check whether the processes share the same table of signal dispositions.  "
"The arguments I<idx1> and I<idx2> are ignored.  See the discussion of the "
"B<CLONE_SIGHAND> flag in B<clone>(2)."
msgstr ""

#. type: TP
#: man-pages/man2/kcmp.2:134
#, no-wrap
msgid "B<KCMP_SYSVSEM>"
msgstr ""

#. type: Plain text
#: man-pages/man2/kcmp.2:147
msgid ""
"Check whether the processes share the same list of System\\ V semaphore undo "
"operations.  The arguments I<idx1> and I<idx2> are ignored.  See the "
"discussion of the B<CLONE_SYSVSEM> flag in B<clone>(2)."
msgstr ""

#. type: TP
#: man-pages/man2/kcmp.2:147
#, no-wrap
msgid "B<KCMP_VM>"
msgstr ""

#. type: Plain text
#: man-pages/man2/kcmp.2:159
msgid ""
"Check whether the processes share the same address space.  The arguments "
"I<idx1> and I<idx2> are ignored.  See the discussion of the B<CLONE_VM> flag "
"in B<clone>(2)."
msgstr ""

#. type: TP
#: man-pages/man2/kcmp.2:159
#, no-wrap
msgid "B<KCMP_EPOLL_TFD> (since Linux 4.13)"
msgstr ""

#.  commit 0791e3644e5ef21646fe565b9061788d05ec71d4
#. type: Plain text
#: man-pages/man2/kcmp.2:176
msgid ""
"Check whether the file descriptor I<idx1> of the process I<pid1> is present "
"in the B<epoll>(7)  instance described by I<idx2> of the process I<pid2>.  "
"The argument I<idx2> is a pointer to a structure where the target file is "
"described.  This structure has the form:"
msgstr ""

#. type: Plain text
#: man-pages/man2/kcmp.2:184
#, no-wrap
msgid ""
"struct kcmp_epoll_slot {\n"
"    __u32 efd;\n"
"    __u32 tfd;\n"
"    __u64 toff;\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/kcmp.2:198
msgid ""
"Within this structure, I<efd> is an epoll file descriptor returned from "
"B<epoll_create>(2), I<tfd> is a target file descriptor number, and I<toff> "
"is a target file offset counted from zero.  Several different targets may be "
"registered with the same file descriptor number and setting a specific "
"offset helps to investigate each of them."
msgstr ""

#. type: Plain text
#: man-pages/man2/kcmp.2:208
msgid ""
"Note the B<kcmp>()  is not protected against false positives which may occur "
"if the processes are currently running.  One should stop the processes by "
"sending B<SIGSTOP> (see B<signal>(7))  prior to inspection with this system "
"call to obtain meaningful results."
msgstr ""

#. type: Plain text
#: man-pages/man2/kcmp.2:214
msgid ""
"The return value of a successful call to B<kcmp>()  is simply the result of "
"arithmetic comparison of kernel pointers (when the kernel compares "
"resources, it uses their memory addresses)."
msgstr ""

#. type: Plain text
#: man-pages/man2/kcmp.2:222
msgid ""
"The easiest way to explain is to consider an example.  Suppose that I<v1> "
"and I<v2> are the addresses of appropriate resources, then the return value "
"is one of the following:"
msgstr ""

#. type: Plain text
#: man-pages/man2/kcmp.2:228
msgid ""
"I<v1> is equal to I<v2>; in other words, the two processes share the "
"resource."
msgstr ""

#. type: Plain text
#: man-pages/man2/kcmp.2:232
msgid "I<v1> is less than I<v2>."
msgstr ""

#. type: Plain text
#: man-pages/man2/kcmp.2:236
msgid "I<v1> is greater than I<v2>."
msgstr ""

#. type: Plain text
#: man-pages/man2/kcmp.2:241
msgid "I<v1> is not equal to I<v2>, but ordering information is unavailable."
msgstr ""

#. type: Plain text
#: man-pages/man2/kcmp.2:251
msgid ""
"B<kcmp>()  was designed to return values suitable for sorting.  This is "
"particularly handy if one needs to compare a large number of file "
"descriptors."
msgstr ""

#. type: Plain text
#: man-pages/man2/kcmp.2:262
msgid "I<type> is B<KCMP_FILE> and I<fd1> or I<fd2> is not an open file descriptor."
msgstr ""

#. type: Plain text
#: man-pages/man2/kcmp.2:267
msgid "The epoll slot addressed by I<idx2> is outside of the user's address space."
msgstr ""

#. type: Plain text
#: man-pages/man2/kcmp.2:271
msgid "I<type> is invalid."
msgstr ""

#. type: Plain text
#: man-pages/man2/kcmp.2:276
msgid "The target file is not present in B<epoll>(7)  instance."
msgstr ""

#. type: Plain text
#: man-pages/man2/kcmp.2:291
msgid ""
"Insufficient permission to inspect process resources.  The B<CAP_SYS_PTRACE> "
"capability is required to inspect processes that you do not own.  Other "
"ptrace limitations may also apply, such as B<CONFIG_SECURITY_YAMA>, which, "
"when I</proc/sys/kernel/yama/ptrace_scope> is 2, limits B<kcmp>()  to child "
"processes; see B<ptrace>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/kcmp.2:298
msgid "Process I<pid1> or I<pid2> does not exist."
msgstr ""

#. type: Plain text
#: man-pages/man2/kcmp.2:302
msgid "The B<kcmp>()  system call first appeared in Linux 3.5."
msgstr ""

#. type: Plain text
#: man-pages/man2/kcmp.2:305
msgid ""
"B<kcmp>()  is Linux-specific and should not be used in programs intended to "
"be portable."
msgstr ""

#. type: Plain text
#: man-pages/man2/kcmp.2:317
msgid ""
"This system call is available only if the kernel was configured with "
"B<CONFIG_CHECKPOINT_RESTORE>.  The main use of the system call is for the "
"checkpoint/restore in user space (CRIU) feature.  The alternative to this "
"system call would have been to expose suitable process information via the "
"B<proc>(5)  filesystem; this was deemed to be unsuitable for security "
"reasons."
msgstr ""

#. type: Plain text
#: man-pages/man2/kcmp.2:322
msgid ""
"See B<clone>(2)  for some background information on the shared resources "
"referred to on this page."
msgstr ""

#. type: Plain text
#: man-pages/man2/kcmp.2:330
msgid ""
"The program below uses B<kcmp>()  to test whether pairs of file descriptors "
"refer to the same open file description.  The program tests different cases "
"for the file descriptor pairs, as described in the program output.  An "
"example run of the program is as follows:"
msgstr ""

#. type: Plain text
#: man-pages/man2/kcmp.2:336
#, no-wrap
msgid ""
"$ B<./a.out>\n"
"Parent PID is 1144\n"
"Parent opened file on FD 3\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/kcmp.2:346
#, no-wrap
msgid ""
"PID of child of fork() is 1145\n"
"\tCompare duplicate FDs from different processes:\n"
"\t\tkcmp(1145, 1144, KCMP_FILE, 3, 3) ==E<gt> same\n"
"Child opened file on FD 4\n"
"\tCompare FDs from distinct open()s in same process:\n"
"\t\tkcmp(1145, 1145, KCMP_FILE, 3, 4) ==E<gt> different\n"
"Child duplicated FD 3 to create FD 5\n"
"\tCompare duplicated FDs in same process:\n"
"\t\tkcmp(1145, 1145, KCMP_FILE, 3, 5) ==E<gt> same\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/kcmp.2:360
#, no-wrap
msgid ""
"#define _GNU_SOURCE\n"
"#include E<lt>sys/syscall.hE<gt>\n"
"#include E<lt>sys/wait.hE<gt>\n"
"#include E<lt>sys/stat.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>fcntl.hE<gt>\n"
"#include E<lt>linux/kcmp.hE<gt>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/kcmp.2:370
#, no-wrap
msgid ""
"static int\n"
"kcmp(pid_t pid1, pid_t pid2, int type,\n"
"     unsigned long idx1, unsigned long idx2)\n"
"{\n"
"    return syscall(SYS_kcmp, pid1, pid2, type, idx1, idx2);\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/kcmp.2:380
#, no-wrap
msgid ""
"static void\n"
"test_kcmp(char *msg, id_t pid1, pid_t pid2, int fd_a, int fd_b)\n"
"{\n"
"    printf(\"\\et%s\\en\", msg);\n"
"    printf(\"\\et\\etkcmp(%ld, %ld, KCMP_FILE, %d, %d) ==E<gt> %s\\en\",\n"
"            (long) pid1, (long) pid2, fd_a, fd_b,\n"
"            (kcmp(pid1, pid2, KCMP_FILE, fd_a, fd_b) == 0) ?\n"
"                        \"same\" : \"different\");\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/kcmp.2:386
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int fd1, fd2, fd3;\n"
"    char pathname[] = \"/tmp/kcmp.test\";\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/kcmp.2:390
#, no-wrap
msgid ""
"    fd1 = open(pathname, O_CREAT | O_RDWR, S_IRUSR | S_IWUSR);\n"
"    if (fd1 == -1)\n"
"        errExit(\"open\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/kcmp.2:393
#, no-wrap
msgid ""
"    printf(\"Parent PID is %ld\\en\", (long) getpid());\n"
"    printf(\"Parent opened file on FD %d\\en\\en\", fd1);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/kcmp.2:397
#, no-wrap
msgid ""
"    switch (fork()) {\n"
"    case -1:\n"
"        errExit(\"fork\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/kcmp.2:400
#, no-wrap
msgid ""
"    case 0:\n"
"        printf(\"PID of child of fork() is %ld\\en\", (long) getpid());\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/kcmp.2:403
#, no-wrap
msgid ""
"        test_kcmp(\"Compare duplicate FDs from different processes:\",\n"
"                getpid(), getppid(), fd1, fd1);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/kcmp.2:408
#, no-wrap
msgid ""
"        fd2 = open(pathname, O_CREAT | O_RDWR, S_IRUSR | S_IWUSR);\n"
"        if (fd2 == -1)\n"
"            errExit(\"open\");\n"
"        printf(\"Child opened file on FD %d\\en\", fd2);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/kcmp.2:411
#, no-wrap
msgid ""
"        test_kcmp(\"Compare FDs from distinct open()s in same process:\",\n"
"                getpid(), getpid(), fd1, fd2);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/kcmp.2:416
#, no-wrap
msgid ""
"        fd3 = dup(fd1);\n"
"        if (fd3 == -1)\n"
"            errExit(\"dup\");\n"
"        printf(\"Child duplicated FD %d to create FD %d\\en\", fd1, fd3);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/kcmp.2:420
#, no-wrap
msgid ""
"        test_kcmp(\"Compare duplicated FDs in same process:\",\n"
"                getpid(), getpid(), fd1, fd3);\n"
"        break;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/kcmp.2:424
#, no-wrap
msgid ""
"    default:\n"
"        wait(NULL);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/kcmp.2:430
msgid "B<clone>(2), B<unshare>(2)"
msgstr ""

#. type: TH
#: man-pages/man2/sync_file_range.2:30
#, no-wrap
msgid "SYNC_FILE_RANGE"
msgstr ""

#. type: Plain text
#: man-pages/man2/sync_file_range.2:33
msgid "sync_file_range - sync a file segment with disk"
msgstr ""

#. type: Plain text
#: man-pages/man2/sync_file_range.2:40
#, no-wrap
msgid ""
"B<int sync_file_range(int >I<fd>B<, off64_t >I<offset>B<, off64_t "
">I<nbytes>B<,>\n"
"B<                    unsigned int >I<flags>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/sync_file_range.2:47
msgid ""
"B<sync_file_range>()  permits fine control when synchronizing the open file "
"referred to by the file descriptor I<fd> with disk."
msgstr ""

#. type: Plain text
#: man-pages/man2/sync_file_range.2:61
msgid ""
"I<offset> is the starting byte of the file range to be synchronized.  "
"I<nbytes> specifies the length of the range to be synchronized, in bytes; if "
"I<nbytes> is zero, then all bytes from I<offset> through to the end of file "
"are synchronized.  Synchronization is in units of the system page size: "
"I<offset> is rounded down to a page boundary; I<(offset+nbytes-1)> is "
"rounded up to a page boundary."
msgstr ""

#. type: Plain text
#: man-pages/man2/sync_file_range.2:65
msgid "The I<flags> bit-mask argument can include any of the following values:"
msgstr ""

#. type: TP
#: man-pages/man2/sync_file_range.2:65
#, no-wrap
msgid "B<SYNC_FILE_RANGE_WAIT_BEFORE>"
msgstr ""

#. type: Plain text
#: man-pages/man2/sync_file_range.2:70
msgid ""
"Wait upon write-out of all pages in the specified range that have already "
"been submitted to the device driver for write-out before performing any "
"write."
msgstr ""

#. type: TP
#: man-pages/man2/sync_file_range.2:70 man-pages/man2/sync_file_range.2:120
#, no-wrap
msgid "B<SYNC_FILE_RANGE_WRITE>"
msgstr ""

#. type: Plain text
#: man-pages/man2/sync_file_range.2:76
msgid ""
"Initiate write-out of all dirty pages in the specified range which are not "
"presently submitted write-out.  Note that even this may block if you attempt "
"to write more than request queue size."
msgstr ""

#. type: TP
#: man-pages/man2/sync_file_range.2:76
#, no-wrap
msgid "B<SYNC_FILE_RANGE_WAIT_AFTER>"
msgstr ""

#. type: Plain text
#: man-pages/man2/sync_file_range.2:80
msgid "Wait upon write-out of all pages in the range after performing any write."
msgstr ""

#. type: Plain text
#: man-pages/man2/sync_file_range.2:84
msgid "Specifying I<flags> as 0 is permitted, as a no-op."
msgstr ""

#. type: SS
#: man-pages/man2/sync_file_range.2:84
#, no-wrap
msgid "Warning"
msgstr ""

#. type: Plain text
#: man-pages/man2/sync_file_range.2:100
msgid ""
"This system call is extremely dangerous and should not be used in portable "
"programs.  None of these operations writes out the file's metadata.  "
"Therefore, unless the application is strictly performing overwrites of "
"already-instantiated disk blocks, there are no guarantees that the data will "
"be available after a crash.  There is no user interface to know if a write "
"is purely an overwrite.  On filesystems using copy-on-write semantics (e.g., "
"I<btrfs>)  an overwrite of existing allocated blocks is impossible.  When "
"writing into preallocated space, many filesystems also require calls into "
"the block allocator, which this system call does not sync out to disk.  This "
"system call does not flush disk write caches and thus does not provide any "
"data integrity on systems with volatile disk write caches."
msgstr ""

#. type: SS
#: man-pages/man2/sync_file_range.2:100
#, no-wrap
msgid "Some details"
msgstr ""

#. type: Plain text
#: man-pages/man2/sync_file_range.2:108
msgid ""
"B<SYNC_FILE_RANGE_WAIT_BEFORE> and B<SYNC_FILE_RANGE_WAIT_AFTER> will detect "
"any I/O errors or B<ENOSPC> conditions and will return these to the caller."
msgstr ""

#. type: Plain text
#: man-pages/man2/sync_file_range.2:112
msgid "Useful combinations of the I<flags> bits are:"
msgstr ""

#. type: TP
#: man-pages/man2/sync_file_range.2:112
#, no-wrap
msgid "B<SYNC_FILE_RANGE_WAIT_BEFORE | SYNC_FILE_RANGE_WRITE>"
msgstr ""

#. type: Plain text
#: man-pages/man2/sync_file_range.2:120
msgid ""
"Ensures that all pages in the specified range which were dirty when "
"B<sync_file_range>()  was called are placed under write-out.  This is a "
"start-write-for-data-integrity operation."
msgstr ""

#. type: Plain text
#: man-pages/man2/sync_file_range.2:127
msgid ""
"Start write-out of all dirty pages in the specified range which are not "
"presently under write-out.  This is an asynchronous flush-to-disk "
"operation.  This is not suitable for data integrity operations."
msgstr ""

#. type: TP
#: man-pages/man2/sync_file_range.2:127
#, no-wrap
msgid "B<SYNC_FILE_RANGE_WAIT_BEFORE> (or B<SYNC_FILE_RANGE_WAIT_AFTER>)"
msgstr ""

#. type: Plain text
#: man-pages/man2/sync_file_range.2:134
msgid ""
"Wait for completion of write-out of all pages in the specified range.  This "
"can be used after an earlier B<SYNC_FILE_RANGE_WAIT_BEFORE | "
"SYNC_FILE_RANGE_WRITE> operation to wait for completion of that operation, "
"and obtain its result."
msgstr ""

#. type: TP
#: man-pages/man2/sync_file_range.2:134
#, no-wrap
msgid ""
"B<SYNC_FILE_RANGE_WAIT_BEFORE | SYNC_FILE_RANGE_WRITE | "
"SYNC_FILE_RANGE_WAIT_AFTER>"
msgstr ""

#. type: Plain text
#: man-pages/man2/sync_file_range.2:141
msgid ""
"This is a write-for-data-integrity operation that will ensure that all pages "
"in the specified range which were dirty when B<sync_file_range>()  was "
"called are committed to disk."
msgstr ""

#. type: Plain text
#: man-pages/man2/sync_file_range.2:147
msgid ""
"On success, B<sync_file_range>()  returns 0; on failure -1 is returned and "
"I<errno> is set to indicate the error."
msgstr ""

#. type: Plain text
#: man-pages/man2/sync_file_range.2:160
msgid "I<flags> specifies an invalid bit; or I<offset> or I<nbytes> is invalid."
msgstr ""

#. type: Plain text
#: man-pages/man2/sync_file_range.2:169
msgid "Out of disk space."
msgstr ""

#. type: Plain text
#: man-pages/man2/sync_file_range.2:174
msgid ""
"I<fd> refers to something other than a regular file, a block device, or a "
"directory."
msgstr ""

#. type: Plain text
#: man-pages/man2/sync_file_range.2:177
msgid "B<sync_file_range>()  appeared on Linux in kernel 2.6.17."
msgstr ""

#. type: Plain text
#: man-pages/man2/sync_file_range.2:180
msgid ""
"This system call is Linux-specific, and should be avoided in portable "
"programs."
msgstr ""

#. type: SS
#: man-pages/man2/sync_file_range.2:181
#, no-wrap
msgid "sync_file_range2()"
msgstr ""

#.  See kernel commit edd5cd4a9424f22b0fa08bef5e299d41befd5622
#. type: Plain text
#: man-pages/man2/sync_file_range.2:198
msgid ""
"Some architectures (e.g., PowerPC, ARM)  need 64-bit arguments to be aligned "
"in a suitable pair of registers.  On such architectures, the call signature "
"of B<sync_file_range>()  shown in the SYNOPSIS would force a register to be "
"wasted as padding between the I<fd> and I<offset> arguments.  (See "
"B<syscall>(2)  for details.)  Therefore, these architectures define a "
"different system call that orders the arguments suitably:"
msgstr ""

#. type: Plain text
#: man-pages/man2/sync_file_range.2:203
#, no-wrap
msgid ""
"B<int sync_file_range2(int >I<fd>B<, unsigned int >I<flags>B<,>\n"
"B<                     off64_t >I<offset>B<, off64_t >I<nbytes>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/sync_file_range.2:208
msgid ""
"The behavior of this system call is otherwise exactly the same as "
"B<sync_file_range>()."
msgstr ""

#. type: Plain text
#: man-pages/man2/sync_file_range.2:219
msgid ""
"A system call with this signature first appeared on the ARM architecture in "
"Linux 2.6.20, with the name B<arm_sync_file_range>().  It was renamed in "
"Linux 2.6.22, when the analogous system call was added for PowerPC.  On "
"architectures where glibc support is provided, glibc transparently wraps "
"B<sync_file_range2>()  under the name B<sync_file_range>()."
msgstr ""

#. type: Plain text
#: man-pages/man2/sync_file_range.2:223
msgid "B<fdatasync>(2), B<fsync>(2), B<msync>(2), B<sync>(2)"
msgstr ""

#. type: TH
#: man-pages/man2/vmsplice.2:26
#, no-wrap
msgid "VMSPLICE"
msgstr ""

#. type: Plain text
#: man-pages/man2/vmsplice.2:29
msgid "vmsplice - splice user pages to/from a pipe"
msgstr ""

#. type: Plain text
#: man-pages/man2/vmsplice.2:34
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>         /* See feature_test_macros(7) */\n"
"B<#include E<lt>fcntl.hE<gt>>\n"
"B<#include E<lt>sys/uio.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/vmsplice.2:37
#, no-wrap
msgid ""
"B<ssize_t vmsplice(int >I<fd>B<, const struct iovec *>I<iov>B<,>\n"
"B<                 unsigned long >I<nr_segs>B<, unsigned int "
">I<flags>B<);>\n"
msgstr ""

#.  Linus: vmsplice() system call to basically do a "write to
#.  the buffer", but using the reference counting and VM traversal
#.  to actually fill the buffer. This means that the user needs to
#.  be careful not to reuse the user-space buffer it spliced into
#.  the kernel-space one (contrast this to "write()", which copies
#.  the actual data, and you can thus reuse the buffer immediately
#.  after a successful write), but that is often easy to do.
#.  Since Linux 2.6.23
#.  commit 6a14b90bb6bc7cd83e2a444bf457a2ea645cbfe7
#. type: Plain text
#: man-pages/man2/vmsplice.2:71
msgid ""
"If I<fd> is opened for writing, the B<vmsplice>()  system call maps "
"I<nr_segs> ranges of user memory described by I<iov> into a pipe.  If I<fd> "
"is opened for reading, the B<vmsplice>()  system call fills I<nr_segs> "
"ranges of user memory described by I<iov> from a pipe.  The file descriptor "
"I<fd> must refer to a pipe."
msgstr ""

#. type: Plain text
#: man-pages/man2/vmsplice.2:78
msgid ""
"The pointer I<iov> points to an array of I<iovec> structures as defined in "
"I<E<lt>sys/uio.hE<gt>>:"
msgstr ""

#. type: Plain text
#: man-pages/man2/vmsplice.2:85
#, no-wrap
msgid ""
"struct iovec {\n"
"    void  *iov_base;        /* Starting address */\n"
"    size_t iov_len;         /* Number of bytes */\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/vmsplice.2:98
msgid "Unused for B<vmsplice>(); see B<splice>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/vmsplice.2:111
msgid ""
"Currently has no effect for B<vmsplice>(), but may be implemented in the "
"future; see B<splice>(2)."
msgstr ""

#.  FIXME . Explain the following line in a little more detail:
#.  FIXME
#.  It looks like the page-alignment requirement went away with
#.  commit bd1a68b59c8e3bce45fb76632c64e1e063c3962d
#
#.  .... if we expect to later SPLICE_F_MOVE to the cache.
#. type: Plain text
#: man-pages/man2/vmsplice.2:131
msgid ""
"The user pages are a gift to the kernel.  The application may not modify "
"this memory ever, otherwise the page cache and on-disk data may differ.  "
"Gifting pages to the kernel means that a subsequent B<splice>(2)  "
"B<SPLICE_F_MOVE> can successfully move the pages; if this flag is not "
"specified, then a subsequent B<splice>(2)  B<SPLICE_F_MOVE> must copy the "
"pages.  Data must also be properly page aligned, both in memory and length."
msgstr ""

#. type: Plain text
#: man-pages/man2/vmsplice.2:140
msgid ""
"Upon successful completion, B<vmsplice>()  returns the number of bytes "
"transferred to the pipe.  On error, B<vmsplice>()  returns -1 and I<errno> "
"is set to indicate the error."
msgstr ""

#. type: Plain text
#: man-pages/man2/vmsplice.2:147
msgid ""
"B<SPLICE_F_NONBLOCK> was specified in I<flags>, and the operation would "
"block."
msgstr ""

#. type: Plain text
#: man-pages/man2/vmsplice.2:151
msgid "I<fd> either not valid, or doesn't refer to a pipe."
msgstr ""

#. type: Plain text
#: man-pages/man2/vmsplice.2:159
msgid ""
"I<nr_segs> is greater than B<IOV_MAX>; or memory not aligned if "
"B<SPLICE_F_GIFT> set."
msgstr ""

#. type: Plain text
#: man-pages/man2/vmsplice.2:167
msgid ""
"The B<vmsplice>()  system call first appeared in Linux 2.6.17; library "
"support was added to glibc in version 2.5."
msgstr ""

#.  UIO_MAXIOV in kernel source
#. type: Plain text
#: man-pages/man2/vmsplice.2:180
msgid ""
"B<vmsplice>()  follows the other vectorized read/write type functions when "
"it comes to limitations on the number of segments being passed in.  This "
"limit is B<IOV_MAX> as defined in I<E<lt>limits.hE<gt>>.  Currently, this "
"limit is 1024."
msgstr ""

#.  commit 6a14b90bb6bc7cd83e2a444bf457a2ea645cbfe7
#. type: Plain text
#: man-pages/man2/vmsplice.2:188
msgid ""
"B<vmsplice>()  really supports true splicing only from user memory to a "
"pipe.  In the opposite direction, it actually just copies the data to "
"userspace.  But this makes the interface nice and symmetric and enables "
"people to build on B<vmsplice>()  with room for future improvement in "
"performance."
msgstr ""

#. type: Plain text
#: man-pages/man2/vmsplice.2:191
msgid "B<splice>(2), B<tee>(2), B<pipe>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/listxattr.2:26
#, no-wrap
msgid "LISTXATTR"
msgstr ""

#. type: Plain text
#: man-pages/man2/listxattr.2:29
msgid "listxattr, llistxattr, flistxattr - list extended attribute names"
msgstr ""

#. type: Plain text
#: man-pages/man2/listxattr.2:40
#, no-wrap
msgid ""
"B<ssize_t listxattr(const char\\ *>I<path>B<, char\\ *>I<list>B<, size_t "
">I<size>B<);>\n"
"B<ssize_t llistxattr(const char\\ *>I<path>B<, char\\ *>I<list>B<, size_t "
">I<size>B<);>\n"
"B<ssize_t flistxattr(int >I<fd>B<, char\\ *>I<list>B<, size_t "
">I<size>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/listxattr.2:68
msgid ""
"B<listxattr>()  retrieves the list of extended attribute names associated "
"with the given I<path> in the filesystem.  The retrieved list is placed in "
"I<list>, a caller-allocated buffer whose size (in bytes) is specified in the "
"argument I<size>.  The list is the set of (null-terminated) names, one after "
"the other.  Names of extended attributes to which the calling process does "
"not have access may be omitted from the list.  The length of the attribute "
"name I<list> is returned."
msgstr ""

#. type: Plain text
#: man-pages/man2/listxattr.2:75
msgid ""
"B<llistxattr>()  is identical to B<listxattr>(), except in the case of a "
"symbolic link, where the list of names of extended attributes associated "
"with the link itself is retrieved, not the file that it refers to."
msgstr ""

#. type: Plain text
#: man-pages/man2/listxattr.2:85
msgid ""
"B<flistxattr>()  is identical to B<listxattr>(), only the open file referred "
"to by I<fd> (as returned by B<open>(2))  is interrogated in place of "
"I<path>."
msgstr ""

#. type: Plain text
#: man-pages/man2/listxattr.2:91
msgid ""
"A single extended attribute I<name> is a null-terminated string.  The name "
"includes a namespace prefix; there may be several, disjoint namespaces "
"associated with an individual inode."
msgstr ""

#. type: Plain text
#: man-pages/man2/listxattr.2:104
msgid ""
"If I<size> is specified as zero, these calls return the current size of the "
"list of extended attribute names (and leave I<list> unchanged).  This can be "
"used to determine the size of the buffer that should be supplied in a "
"subsequent call.  (But, bear in mind that there is a possibility that the "
"set of extended attributes may change between the two calls, so that it is "
"still necessary to check the return status from the second call.)"
msgstr ""

#. type: SS
#: man-pages/man2/listxattr.2:104
#, no-wrap
msgid "Example"
msgstr ""

#. type: Plain text
#: man-pages/man2/listxattr.2:109
msgid ""
"The I<list> of names is returned as an unordered array of null-terminated "
"character strings (attribute names are separated by null bytes "
"(\\(aq\\e0\\(aq)), like this:"
msgstr ""

#. type: Plain text
#: man-pages/man2/listxattr.2:113
#, no-wrap
msgid "user.name1\\e0system.name1\\e0user.name2\\e0\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/listxattr.2:120
msgid ""
"Filesystems that implement POSIX ACLs using extended attributes might return "
"a I<list> like this:"
msgstr ""

#. type: Plain text
#: man-pages/man2/listxattr.2:124
#, no-wrap
msgid "system.posix_acl_access\\e0system.posix_acl_default\\e0\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/listxattr.2:132
msgid ""
"On success, a nonnegative number is returned indicating the size of the "
"extended attribute name list.  On failure, -1 is returned and I<errno> is "
"set appropriately."
msgstr ""

#. type: Plain text
#: man-pages/man2/listxattr.2:140
msgid ""
"The size of the list of extended attribute names is larger than the maximum "
"size allowed; the list cannot be retrieved.  This can happen on filesystems "
"that support an unlimited number of extended attributes per file such as "
"XFS, for example.  See BUGS."
msgstr ""

#. type: Plain text
#: man-pages/man2/listxattr.2:150
msgid "The I<size> of the I<list> buffer is too small to hold the result."
msgstr ""

#.  The xattr(7) page refers to this text:
#. type: Plain text
#: man-pages/man2/listxattr.2:174
msgid ""
"As noted in B<xattr>(7), the VFS imposes a limit of 64\\ kB on the size of "
"the extended attribute name list returned by B<listxattr>(7).  If the total "
"size of attribute names attached to a file exceeds this limit, it is no "
"longer possible to retrieve the list of attribute names."
msgstr ""

#. type: Plain text
#: man-pages/man2/listxattr.2:181
msgid ""
"The following program demonstrates the usage of B<listxattr>()  and "
"B<getxattr>(2).  For the file whose pathname is provided as a command-line "
"argument, it lists all extended file attributes and their values."
msgstr ""

#. type: Plain text
#: man-pages/man2/listxattr.2:198
msgid ""
"To keep the code simple, the program assumes that attribute keys and values "
"are constant during the execution of the program.  A production program "
"should expect and handle changes during execution of the program.  For "
"example, the number of bytes required for attribute keys might increase "
"between the two calls to B<listxattr>().  An application could handle this "
"possibility using a loop that retries the call (perhaps up to a "
"predetermined maximum number of attempts)  with a larger buffer each time it "
"fails with the error B<ERANGE>.  Calls to B<getxattr>(2)  could be handled "
"similarly."
msgstr ""

#. type: Plain text
#: man-pages/man2/listxattr.2:202
msgid ""
"The following output was recorded by first creating a file, setting some "
"extended file attributes, and then listing the attributes with the example "
"program."
msgstr ""

#. type: SS
#: man-pages/man2/listxattr.2:202
#, no-wrap
msgid "Example output"
msgstr ""

#. type: Plain text
#: man-pages/man2/listxattr.2:213
#, no-wrap
msgid ""
"$ B<touch /tmp/foo>\n"
"$ B<setfattr -n user.fred -v chocolate /tmp/foo>\n"
"$ B<setfattr -n user.frieda -v bar /tmp/foo>\n"
"$ B<setfattr -n user.empty /tmp/foo>\n"
"$ B<./listxattr /tmp/foo>\n"
"user.fred: chocolate\n"
"user.frieda: bar\n"
"user.empty: E<lt>no valueE<gt>\n"
msgstr ""

#. type: SS
#: man-pages/man2/listxattr.2:215
#, no-wrap
msgid "Program source (listxattr.c)"
msgstr ""

#. type: Plain text
#: man-pages/man2/listxattr.2:223
#, no-wrap
msgid ""
"#include E<lt>malloc.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>sys/types.hE<gt>\n"
"#include E<lt>sys/xattr.hE<gt>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/listxattr.2:229
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    ssize_t buflen, keylen, vallen;\n"
"    char *buf, *key, *val;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/listxattr.2:234
#, no-wrap
msgid ""
"    if (argc != 2) {\n"
"        fprintf(stderr, \"Usage: %s path\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/listxattr.2:247
#, no-wrap
msgid ""
"    /*\n"
"     * Determine the length of the buffer needed.\n"
"     */\n"
"    buflen = listxattr(argv[1], NULL, 0);\n"
"    if (buflen == -1) {\n"
"        perror(\"listxattr\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
"    if (buflen == 0) {\n"
"        printf(\"%s has no attributes.\\en\", argv[1]);\n"
"        exit(EXIT_SUCCESS);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/listxattr.2:256
#, no-wrap
msgid ""
"    /*\n"
"     * Allocate the buffer.\n"
"     */\n"
"    buf = malloc(buflen);\n"
"    if (buf == NULL) {\n"
"        perror(\"malloc\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/listxattr.2:265
#, no-wrap
msgid ""
"    /*\n"
"     * Copy the list of attribute keys to the buffer.\n"
"     */\n"
"    buflen = listxattr(argv[1], buf, buflen);\n"
"    if (buflen == -1) {\n"
"        perror(\"listxattr\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/listxattr.2:273
#, no-wrap
msgid ""
"    /*\n"
"     * Loop over the list of zero terminated strings with the\n"
"     * attribute keys. Use the remaining buffer length to determine\n"
"     * the end of the list.\n"
"     */\n"
"    key = buf;\n"
"    while (buflen E<gt> 0) {\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/listxattr.2:278
#, no-wrap
msgid ""
"        /*\n"
"         * Output attribute key.\n"
"         */\n"
"        printf(\"%s: \", key);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/listxattr.2:285
#, no-wrap
msgid ""
"        /*\n"
"         * Determine length of the value.\n"
"         */\n"
"        vallen = getxattr(argv[1], key, NULL, 0);\n"
"        if (vallen == -1)\n"
"            perror(\"getxattr\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/listxattr.2:287
#, no-wrap
msgid "        if (vallen E<gt> 0) {\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/listxattr.2:297
#, no-wrap
msgid ""
"            /*\n"
"             * Allocate value buffer.\n"
"             * One extra byte is needed to append 0x00.\n"
"             */\n"
"            val = malloc(vallen + 1);\n"
"            if (val == NULL) {\n"
"                perror(\"malloc\");\n"
"                exit(EXIT_FAILURE);\n"
"            }\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/listxattr.2:311
#, no-wrap
msgid ""
"            /*\n"
"             * Copy value to buffer.\n"
"             */\n"
"            vallen = getxattr(argv[1], key, val, vallen);\n"
"            if (vallen == -1)\n"
"                perror(\"getxattr\");\n"
"            else {\n"
"                /*\n"
"                 * Output attribute value.\n"
"                 */\n"
"                val[vallen] = 0;\n"
"                printf(\"%s\", val);\n"
"            }\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/listxattr.2:315
#, no-wrap
msgid ""
"            free(val);\n"
"        } else if (vallen == 0)\n"
"            printf(\"E<lt>no valueE<gt>\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/listxattr.2:317
#, no-wrap
msgid "        printf(\"\\en\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/listxattr.2:325
#, no-wrap
msgid ""
"        /*\n"
"         * Forward to next attribute key.\n"
"         */\n"
"        keylen = strlen(key) + 1;\n"
"        buflen -= keylen;\n"
"        key += keylen;\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/listxattr.2:329 man-pages/man2/readlink.2:349
#, no-wrap
msgid ""
"    free(buf);\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/listxattr.2:339
msgid ""
"B<getfattr>(1), B<setfattr>(1), B<getxattr>(2), B<open>(2), "
"B<removexattr>(2), B<setxattr>(2), B<stat>(2), B<symlink>(7), B<xattr>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/write.2:39
#, no-wrap
msgid "WRITE"
msgstr ""

#. type: Plain text
#: man-pages/man2/write.2:42
msgid "write - write to a file descriptor"
msgstr ""

#. type: Plain text
#: man-pages/man2/write.2:46
msgid "B<ssize_t write(int >I<fd>B<, const void *>I<buf>B<, size_t >I<count>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/write.2:54
msgid ""
"B<write>()  writes up to I<count> bytes from the buffer starting at I<buf> "
"to the file referred to by the file descriptor I<fd>."
msgstr ""

#. type: Plain text
#: man-pages/man2/write.2:68
msgid ""
"The number of bytes written may be less than I<count> if, for example, there "
"is insufficient space on the underlying physical medium, or the "
"B<RLIMIT_FSIZE> resource limit is encountered (see B<setrlimit>(2)), or the "
"call was interrupted by a signal handler after having written less than "
"I<count> bytes.  (See also B<pipe>(7).)"
msgstr ""

#. type: Plain text
#: man-pages/man2/write.2:82
msgid ""
"For a seekable file (i.e., one to which B<lseek>(2)  may be applied, for "
"example, a regular file)  writing takes place at the file offset, and the "
"file offset is incremented by the number of bytes actually written.  If the "
"file was B<open>(2)ed with B<O_APPEND>, the file offset is first set to the "
"end of the file before writing.  The adjustment of the file offset and the "
"write operation are performed as an atomic step."
msgstr ""

#. type: Plain text
#: man-pages/man2/write.2:89
msgid ""
"POSIX requires that a B<read>(2)  that can be proved to occur after a "
"B<write>()  has returned will return the new data.  Note that not all "
"filesystems are POSIX conforming."
msgstr ""

#. type: Plain text
#: man-pages/man2/write.2:96 man-pages/man2/read.2:82
msgid ""
"According to POSIX.1, if I<count> is greater than B<SSIZE_MAX>, the result "
"is implementation-defined; see NOTES for the upper limit on Linux."
msgstr ""

#. type: Plain text
#: man-pages/man2/write.2:100
msgid ""
"On success, the number of bytes written is returned.  On error, -1 is "
"returned, and I<errno> is set to indicate the cause of the error."
msgstr ""

#. type: Plain text
#: man-pages/man2/write.2:118
msgid ""
"Note that a successful B<write>()  may transfer fewer than I<count> bytes.  "
"Such partial writes can occur for various reasons; for example, because "
"there was insufficient space on the disk device to write all of the "
"requested bytes, or because a blocked B<write>()  to a socket, pipe, or "
"similar was interrupted by a signal handler after it had transferred some, "
"but before it had transferred all of the requested bytes.  In the event of a "
"partial write, the caller can make another B<write>()  call to transfer the "
"remaining bytes.  The subsequent call will either transfer further bytes or "
"may result in an error (e.g., if the disk is now full)."
msgstr ""

#. type: Plain text
#: man-pages/man2/write.2:131
msgid ""
"If I<count> is zero and I<fd> refers to a regular file, then B<write>()  may "
"return a failure status if one of the errors below is detected.  If no "
"errors are detected, or error detection is not performed, 0 will be returned "
"without causing any other effect.  If I<count> is zero and I<fd> refers to a "
"file other than a regular file, the results are not specified."
msgstr ""

#. type: Plain text
#: man-pages/man2/write.2:144
msgid ""
"The file descriptor I<fd> refers to a file other than a socket and has been "
"marked nonblocking (B<O_NONBLOCK>), and the write would block.  See "
"B<open>(2)  for further details on the B<O_NONBLOCK> flag."
msgstr ""

#.  Actually EAGAIN on Linux
#. type: Plain text
#: man-pages/man2/write.2:155
msgid ""
"The file descriptor I<fd> refers to a socket and has been marked nonblocking "
"(B<O_NONBLOCK>), and the write would block.  POSIX.1-2001 allows either "
"error to be returned for this case, and does not require these constants to "
"have the same value, so a portable application should check for both "
"possibilities."
msgstr ""

#. type: Plain text
#: man-pages/man2/write.2:159
msgid "I<fd> is not a valid file descriptor or is not open for writing."
msgstr ""

#. type: Plain text
#: man-pages/man2/write.2:164
msgid ""
"I<fd> refers to a datagram socket for which a peer address has not been set "
"using B<connect>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/write.2:170
msgid ""
"The user's quota of disk blocks on the filesystem containing the file "
"referred to by I<fd> has been exhausted."
msgstr ""

#. type: Plain text
#: man-pages/man2/write.2:174 man-pages/man2/read.2:130
msgid "I<buf> is outside your accessible address space."
msgstr ""

#. type: Plain text
#: man-pages/man2/write.2:179
msgid ""
"An attempt was made to write a file that exceeds the implementation-defined "
"maximum file size or the process's file size limit, or to write at a "
"position past the maximum allowed offset."
msgstr ""

#. type: Plain text
#: man-pages/man2/write.2:183
msgid ""
"The call was interrupted by a signal before any data was written; see "
"B<signal>(7)."
msgstr ""

#. type: Plain text
#: man-pages/man2/write.2:194
msgid ""
"I<fd> is attached to an object which is unsuitable for writing; or the file "
"was opened with the B<O_DIRECT> flag, and either the address specified in "
"I<buf>, the value specified in I<count>, or the file offset is not suitably "
"aligned."
msgstr ""

#.  commit 088737f44bbf6378745f5b57b035e57ee3dc4750
#. type: Plain text
#: man-pages/man2/write.2:222
msgid ""
"A low-level I/O error occurred while modifying the inode.  This error may "
"relate to the write-back of data written by an earlier B<write>(), which may "
"have been issued to a different file descriptor on the same file.  Since "
"Linux 4.13, errors from write-back come with a promise that they I<may> be "
"reported by subsequent.  B<write>()  requests, and I<will> be reported by a "
"subsequent B<fsync>(2)  (whether or not they were also reported by "
"B<write>()).  An alternate cause of B<EIO> on networked filesystems is when "
"an advisory lock had been taken out on the file descriptor and this lock has "
"been lost.  See the I<Lost locks> section of B<fcntl>(2)  for further "
"details."
msgstr ""

#. type: Plain text
#: man-pages/man2/write.2:227
msgid ""
"The device containing the file referred to by I<fd> has no room for the "
"data."
msgstr ""

#. type: Plain text
#: man-pages/man2/write.2:240
msgid ""
"I<fd> is connected to a pipe or socket whose reading end is closed.  When "
"this happens the writing process will also receive a B<SIGPIPE> signal.  "
"(Thus, the write return value is seen only if the program catches, blocks or "
"ignores this signal.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/write.2:243 man-pages/man2/read.2:182
msgid "Other errors may occur, depending on the object connected to I<fd>."
msgstr ""

#. type: Plain text
#: man-pages/man2/write.2:247 man-pages/man2/wait.2:453
#: man-pages/man2/read.2:184
msgid "SVr4, 4.3BSD, POSIX.1-2001."
msgstr ""

#. type: Plain text
#: man-pages/man2/write.2:252
msgid ""
"Under SVr4 a write may be interrupted and return B<EINTR> at any point, not "
"just before any data is written."
msgstr ""

#. type: Plain text
#: man-pages/man2/write.2:259 man-pages/man2/read.2:191
msgid ""
"The types I<size_t> and I<ssize_t> are, respectively, unsigned and signed "
"integer data types specified by POSIX.1."
msgstr ""

#. type: Plain text
#: man-pages/man2/write.2:274
msgid ""
"A successful return from B<write>()  does not make any guarantee that data "
"has been committed to disk.  On some filesystems, including NFS, it does not "
"even guarantee that space has successfully been reserved for the data.  In "
"this case, some errors might be delayed until a future B<write>(), "
"B<fsync>(2), or even B<close>(2).  The only way to be sure is to call "
"B<fsync>(2)  after you are done writing all your data."
msgstr ""

#. type: Plain text
#: man-pages/man2/write.2:282
msgid ""
"If a B<write>()  is interrupted by a signal handler before any bytes are "
"written, then the call fails with the error B<EINTR>; if it is interrupted "
"after at least one byte has been written, the call succeeds, and returns the "
"number of bytes written."
msgstr ""

#.  commit e28cc71572da38a5a12c1cfe4d7032017adccf69
#. type: Plain text
#: man-pages/man2/write.2:290
msgid ""
"On Linux, B<write>()  (and similar system calls) will transfer at most "
"0x7ffff000 (2,147,479,552) bytes, returning the number of bytes actually "
"transferred.  (This is true on both 32-bit and 64-bit systems.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/write.2:298
msgid ""
"An error return value while performing B<write>()  using direct I/O does not "
"mean the entire write has failed. Partial data may be written and the data "
"at the file offset on which the B<write>()  was attempted should be "
"considered inconsistent."
msgstr ""

#. type: Plain text
#: man-pages/man2/write.2:301 man-pages/man2/read.2:218
msgid ""
"According to POSIX.1-2008/SUSv4 Section XSI 2.9.7 (\"Thread Interactions "
"with Regular File Operations\"):"
msgstr ""

#. type: Plain text
#: man-pages/man2/write.2:306 man-pages/man2/read.2:223
msgid ""
"All of the following functions shall be atomic with respect to each other in "
"the effects specified in POSIX.1-2008 when they operate on regular files or "
"symbolic links: ..."
msgstr ""

#.  http://thread.gmane.org/gmane.linux.kernel/1649458
#.     From: Michael Kerrisk (man-pages <mtk.manpages <at> gmail.com>
#.     Subject: Update of file offset on write() etc. is non-atomic with I/O
#.     Date: 2014-02-17 15:41:37 GMT
#.     Newsgroups: gmane.linux.kernel, gmane.linux.file-systems
#.  commit 9c225f2655e36a470c4f58dbbc99244c5fc7f2d4
#.     Author: Linus Torvalds <torvalds@linux-foundation.org>
#.     Date:   Mon Mar 3 09:36:58 2014 -0800
#
#.         vfs: atomic f_pos accesses as per POSIX
#. type: Plain text
#: man-pages/man2/write.2:337
msgid ""
"Among the APIs subsequently listed are B<write>()  and B<writev>(2).  And "
"among the effects that should be atomic across threads (and processes)  are "
"updates of the file offset.  However, on Linux before version 3.14, this was "
"not the case: if two processes that share an open file description (see "
"B<open>(2))  perform a B<write>()  (or B<writev>(2))  at the same time, then "
"the I/O operations were not atomic with respect updating the file offset, "
"with the result that the blocks of data output by the two processes might "
"(incorrectly) overlap.  This problem was fixed in Linux 3.14."
msgstr ""

#. type: Plain text
#: man-pages/man2/write.2:348
msgid ""
"B<close>(2), B<fcntl>(2), B<fsync>(2), B<ioctl>(2), B<lseek>(2), B<open>(2), "
"B<pwrite>(2), B<read>(2), B<select>(2), B<writev>(2), B<fwrite>(3)"
msgstr ""

#. type: TH
#: man-pages/man2/brk.2:29
#, no-wrap
msgid "BRK"
msgstr ""

#. type: Plain text
#: man-pages/man2/brk.2:32
msgid "brk, sbrk - change data segment size"
msgstr ""

#. type: Plain text
#: man-pages/man2/brk.2:36
msgid "B<int brk(void *>I<addr>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/brk.2:38
msgid "B<void *sbrk(intptr_t >I<increment>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/brk.2:46
msgid "B<brk>(), B<sbrk>():"
msgstr ""

#. type: TP
#: man-pages/man2/brk.2:49 man-pages/man2/madvise.2:51
#: man-pages/man2/getpagesize.2:42
#, no-wrap
msgid "Since glibc 2.19:"
msgstr ""

#.     (_XOPEN_SOURCE\ >=\ 500 ||
#.         _XOPEN_SOURCE\ &&\ _XOPEN_SOURCE_EXTENDED) &&
#. type: Plain text
#: man-pages/man2/brk.2:57
#, no-wrap
msgid ""
"_DEFAULT_SOURCE ||\n"
"    (_XOPEN_SOURCE\\ E<gt>=\\ 500) &&\n"
"    ! (_POSIX_C_SOURCE\\ E<gt>=\\ 200112L)\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/brk.2:58 man-pages/man2/getpagesize.2:49
#, no-wrap
msgid "From glibc 2.12 to 2.19:"
msgstr ""

#.     (_XOPEN_SOURCE\ >=\ 500 ||
#.         _XOPEN_SOURCE\ &&\ _XOPEN_SOURCE_EXTENDED) &&
#. type: Plain text
#: man-pages/man2/brk.2:66
#, no-wrap
msgid ""
"_BSD_SOURCE || _SVID_SOURCE ||\n"
"    (_XOPEN_SOURCE\\ E<gt>=\\ 500) &&\n"
"    ! (_POSIX_C_SOURCE\\ E<gt>=\\ 200112L)\n"
msgstr ""

#. type: TP
#: man-pages/man2/brk.2:67
#, no-wrap
msgid "Before glibc 2.12:"
msgstr ""

#.     || _XOPEN_SOURCE\ &&\ _XOPEN_SOURCE_EXTENDED
#. type: Plain text
#: man-pages/man2/brk.2:71
msgid "_BSD_SOURCE || _SVID_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 500"
msgstr ""

#. type: Plain text
#: man-pages/man2/brk.2:86
msgid ""
"B<brk>()  and B<sbrk>()  change the location of the I<program break>, which "
"defines the end of the process's data segment (i.e., the program break is "
"the first location after the end of the uninitialized data segment).  "
"Increasing the program break has the effect of allocating memory to the "
"process; decreasing the break deallocates memory."
msgstr ""

#. type: Plain text
#: man-pages/man2/brk.2:93
msgid ""
"B<brk>()  sets the end of the data segment to the value specified by "
"I<addr>, when that value is reasonable, the system has enough memory, and "
"the process does not exceed its maximum data size (see B<setrlimit>(2))."
msgstr ""

#. type: Plain text
#: man-pages/man2/brk.2:103
msgid ""
"B<sbrk>()  increments the program's data space by I<increment> bytes.  "
"Calling B<sbrk>()  with an I<increment> of 0 can be used to find the current "
"location of the program break."
msgstr ""

#. type: Plain text
#: man-pages/man2/brk.2:111
msgid ""
"On success, B<brk>()  returns zero.  On error, -1 is returned, and I<errno> "
"is set to B<ENOMEM>."
msgstr ""

#. type: Plain text
#: man-pages/man2/brk.2:123
msgid ""
"On success, B<sbrk>()  returns the previous program break.  (If the break "
"was increased, then this value is a pointer to the start of the newly "
"allocated memory).  On error, I<(void\\ *)\\ -1> is returned, and I<errno> "
"is set to B<ENOMEM>."
msgstr ""

#
#.  .BR brk ()
#.  and
#.  .BR sbrk ()
#.  are not defined in the C Standard and are deliberately excluded from the
#.  POSIX.1-1990 standard (see paragraphs B.1.1.1.3 and B.8.3.3).
#. type: Plain text
#: man-pages/man2/brk.2:131
msgid "4.3BSD; SUSv1, marked LEGACY in SUSv2, removed in POSIX.1-2001."
msgstr ""

#. type: Plain text
#: man-pages/man2/brk.2:140
msgid ""
"Avoid using B<brk>()  and B<sbrk>(): the B<malloc>(3)  memory allocation "
"package is the portable and comfortable way of allocating memory."
msgstr ""

#.  One sees
#.  \fIint\fP (e.g., XPGv4, DU 4.0, HP-UX 11, FreeBSD 4.0, OpenBSD 3.2),
#.  \fIssize_t\fP (OSF1 2.0, Irix 5.3, 6.5),
#.  \fIptrdiff_t\fP (libc4, libc5, ulibc, glibc 2.0, 2.1),
#.  \fIintptr_t\fP (e.g., XPGv5, AIX, SunOS 5.8, 5.9, FreeBSD 4.7, NetBSD 1.6,
#.  Tru64 5.1, glibc2.2).
#. type: Plain text
#: man-pages/man2/brk.2:150
msgid ""
"Various systems use various types for the argument of B<sbrk>().  Common are "
"I<int>, I<ssize_t>, I<ptrdiff_t>, I<intptr_t>."
msgstr ""

#. type: Plain text
#: man-pages/man2/brk.2:166
msgid ""
"The return value described above for B<brk>()  is the behavior provided by "
"the glibc wrapper function for the Linux B<brk>()  system call.  (On most "
"other implementations, the return value from B<brk>()  is the same; this "
"return value was also specified in SUSv2.)  However, the actual Linux system "
"call returns the new program break on success.  On failure, the system call "
"returns the current break.  The glibc wrapper function does some work (i.e., "
"checks whether the new break is less than I<addr>)  to provide the 0 and -1 "
"return values described above."
msgstr ""

#. type: Plain text
#: man-pages/man2/brk.2:173
msgid ""
"On Linux, B<sbrk>()  is implemented as a library function that uses the "
"B<brk>()  system call, and does some internal bookkeeping so that it can "
"return the old break value."
msgstr ""

#. type: Plain text
#: man-pages/man2/brk.2:177
msgid "B<execve>(2), B<getrlimit>(2), B<end>(3), B<malloc>(3)"
msgstr ""

#. type: TH
#: man-pages/man2/mbind.2:35
#, no-wrap
msgid "MBIND"
msgstr ""

#. type: Plain text
#: man-pages/man2/mbind.2:38
msgid "mbind - set memory policy for a memory range"
msgstr ""

#. type: Plain text
#: man-pages/man2/mbind.2:45
#, no-wrap
msgid ""
"B<long mbind(void *>I<addr>B<, unsigned long >I<len>B<, int >I<mode>B<,>\n"
"B<           const unsigned long *>I<nodemask>B<, unsigned long "
">I<maxnode>B<,>\n"
"B<           unsigned >I<flags>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/mbind.2:58
msgid ""
"B<mbind>()  sets the NUMA memory policy, which consists of a policy mode and "
"zero or more nodes, for the memory range starting with I<addr> and "
"continuing for I<len> bytes.  The memory policy defines from which node "
"memory is allocated."
msgstr ""

#. type: Plain text
#: man-pages/man2/mbind.2:80
msgid ""
"If the memory range specified by the I<addr> and I<len> arguments includes "
"an \"anonymous\" region of memory\\(emthat is a region of memory created "
"using the B<mmap>(2)  system call with the B<MAP_ANONYMOUS>\\(emor a "
"memory-mapped file, mapped using the B<mmap>(2)  system call with the "
"B<MAP_PRIVATE> flag, pages will be allocated only according to the specified "
"policy when the application writes (stores) to the page.  For anonymous "
"regions, an initial read access will use a shared page in the kernel "
"containing all zeros.  For a file mapped with B<MAP_PRIVATE>, an initial "
"read access will allocate pages according to the memory policy of the thread "
"that causes the page to be allocated.  This may not be the thread that "
"called B<mbind>()."
msgstr ""

#. type: Plain text
#: man-pages/man2/mbind.2:88
msgid ""
"The specified policy will be ignored for any B<MAP_SHARED> mappings in the "
"specified memory range.  Rather the pages will be allocated according to the "
"memory policy of the thread that caused the page to be allocated.  Again, "
"this may not be the thread that called B<mbind>()."
msgstr ""

#. type: Plain text
#: man-pages/man2/mbind.2:105
msgid ""
"If the specified memory range includes a shared memory region created using "
"the B<shmget>(2)  system call and attached using the B<shmat>(2)  system "
"call, pages allocated for the anonymous or shared memory region will be "
"allocated according to the policy specified, regardless of which process "
"attached to the shared memory segment causes the allocation.  If, however, "
"the shared memory region was created with the B<SHM_HUGETLB> flag, the huge "
"pages will be allocated according to the policy specified only if the page "
"allocation is caused by the process that calls B<mbind>()  for that region."
msgstr ""

#. type: Plain text
#: man-pages/man2/mbind.2:116
msgid ""
"By default, B<mbind>()  has an effect only for new allocations; if the pages "
"inside the range have been already touched before setting the policy, then "
"the policy has no effect.  This default behavior may be overridden by the "
"B<MPOL_MF_MOVE> and B<MPOL_MF_MOVE_ALL> flags described below."
msgstr ""

#. type: Plain text
#: man-pages/man2/mbind.2:133
msgid ""
"The I<mode> argument must specify one of B<MPOL_DEFAULT>, B<MPOL_BIND>, "
"B<MPOL_INTERLEAVE>, B<MPOL_PREFERRED>, or B<MPOL_LOCAL> (which are described "
"in detail below).  All policy modes except B<MPOL_DEFAULT> require the "
"caller to specify the node or nodes to which the mode applies, via the "
"I<nodemask> argument."
msgstr ""

#. type: TP
#: man-pages/man2/mbind.2:141
#, no-wrap
msgid "B<MPOL_F_STATIC_NODES> (since Linux-2.6.26)"
msgstr ""

#. type: Plain text
#: man-pages/man2/mbind.2:151
msgid ""
"A nonempty I<nodemask> specifies physical node IDs.  Linux does not remap "
"the I<nodemask> when the thread moves to a different cpuset context, nor "
"when the set of nodes allowed by the thread's current cpuset context "
"changes."
msgstr ""

#. type: TP
#: man-pages/man2/mbind.2:151
#, no-wrap
msgid "B<MPOL_F_RELATIVE_NODES> (since Linux-2.6.26)"
msgstr ""

#. type: Plain text
#: man-pages/man2/mbind.2:157
msgid ""
"A nonempty I<nodemask> specifies node IDs that are relative to the set of "
"node IDs allowed by the thread's current cpuset."
msgstr ""

#. type: Plain text
#: man-pages/man2/mbind.2:185
msgid ""
"I<nodemask> points to a bit mask of nodes containing up to I<maxnode> bits.  "
"The bit mask size is rounded to the next multiple of I<sizeof(unsigned "
"long)>, but the kernel will use bits only up to I<maxnode>.  A NULL value of "
"I<nodemask> or a I<maxnode> value of zero specifies the empty set of nodes.  "
"If the value of I<maxnode> is zero, the I<nodemask> argument is ignored.  "
"Where a I<nodemask> is required, it must contain at least one node that is "
"on-line, allowed by the thread's current cpuset context (unless the "
"B<MPOL_F_STATIC_NODES> mode flag is specified), and contains memory."
msgstr ""

#. type: Plain text
#: man-pages/man2/mbind.2:210
msgid ""
"This mode requests that any nondefault policy be removed, restoring default "
"behavior.  When applied to a range of memory via B<mbind>(), this means to "
"use the thread memory policy, which may have been set with "
"B<set_mempolicy>(2).  If the mode of the thread memory policy is also "
"B<MPOL_DEFAULT>, the system-wide default policy will be used.  The "
"system-wide default policy allocates pages on the node of the CPU that "
"triggers the allocation.  For B<MPOL_DEFAULT>, the I<nodemask> and "
"I<maxnode> arguments must be specify the empty set of nodes."
msgstr ""

#.  commit 19770b32609b6bf97a3dece2529089494cbfc549
#. type: Plain text
#: man-pages/man2/mbind.2:231
msgid ""
"This mode specifies a strict policy that restricts memory allocation to the "
"nodes specified in I<nodemask>.  If I<nodemask> specifies more than one "
"node, page allocations will come from the node with sufficient free memory "
"that is closest to the node where the allocation takes place.  Pages will "
"not be allocated from any node not specified in the IR nodemask .  (Before "
"Linux 2.6.26, page allocations came from the node with the lowest numeric "
"node ID first, until that node contained no free memory.  Allocations then "
"came from the node with the next highest node ID specified in I<nodemask> "
"and so forth, until none of the specified nodes contained free memory.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/mbind.2:243
msgid ""
"This mode specifies that page allocations be interleaved across the set of "
"nodes specified in I<nodemask>.  This optimizes for bandwidth instead of "
"latency by spreading out pages and memory accesses to those pages across "
"multiple nodes.  To be effective the memory area should be fairly large, at "
"least 1\\ MB or bigger with a fairly uniform access pattern.  Accesses to a "
"single page of the area will still be limited to the memory bandwidth of a "
"single node."
msgstr ""

#. type: Plain text
#: man-pages/man2/mbind.2:259
msgid ""
"This mode sets the preferred node for allocation.  The kernel will try to "
"allocate pages from this node first and fall back to other nodes if the "
"preferred nodes is low on free memory.  If I<nodemask> specifies more than "
"one node ID, the first node in the mask will be selected as the preferred "
"node.  If the I<nodemask> and I<maxnode> arguments specify the empty set, "
"then the memory is allocated on the node of the CPU that triggered the "
"allocation."
msgstr ""

#.  commit 479e2802d09f1e18a97262c4c6f8f17ae5884bd8
#.  commit f2a07f40dbc603c15f8b06e6ec7f768af67b424f
#. type: Plain text
#: man-pages/man2/mbind.2:283
msgid ""
"This mode specifies \"local allocation\"; the memory is allocated on the "
"node of the CPU that triggered the allocation (the \"local node\").  The "
"I<nodemask> and I<maxnode> arguments must specify the empty set.  If the "
"\"local node\" is low on free memory, the kernel will try to allocate memory "
"from other nodes.  The kernel will allocate memory from the \"local node\" "
"whenever memory for this node is available.  If the \"local node\" is not "
"allowed by the thread's current cpuset context, the kernel will try to "
"allocate memory from other nodes.  The kernel will allocate memory from the "
"\"local node\" whenever it becomes allowed by the thread's current cpuset "
"context.  By contrast, B<MPOL_DEFAULT> reverts to the memory policy of the "
"thread (which may be set via B<set_mempolicy>(2)); that policy may be "
"something other than \"local allocation\"."
msgstr ""

#.  According to the kernel code, the following is not true
#.  --Lee Schermerhorn
#.  In 2.6.16 or later the kernel will also try to move pages
#.  to the requested node with this flag.
#. type: Plain text
#: man-pages/man2/mbind.2:299
msgid ""
"If B<MPOL_MF_STRICT> is passed in I<flags> and I<mode> is not "
"B<MPOL_DEFAULT>, then the call fails with the error B<EIO> if the existing "
"pages in the memory range don't follow the policy."
msgstr ""

#. type: Plain text
#: man-pages/man2/mbind.2:312
msgid ""
"If B<MPOL_MF_MOVE> is specified in I<flags>, then the kernel will attempt to "
"move all the existing pages in the memory range so that they follow the "
"policy.  Pages that are shared with other processes will not be moved.  If "
"B<MPOL_MF_STRICT> is also specified, then the call fails with the error "
"B<EIO> if some pages could not be moved."
msgstr ""

#.  ---------------------------------------------------------------
#. type: Plain text
#: man-pages/man2/mbind.2:328
msgid ""
"If B<MPOL_MF_MOVE_ALL> is passed in I<flags>, then the kernel will attempt "
"to move all existing pages in the memory range regardless of whether other "
"processes use the pages.  The calling thread must be privileged "
"(B<CAP_SYS_NICE>)  to use this flag.  If B<MPOL_MF_STRICT> is also "
"specified, then the call fails with the error B<EIO> if some pages could not "
"be moved."
msgstr ""

#.  ---------------------------------------------------------------
#. type: Plain text
#: man-pages/man2/mbind.2:336
msgid ""
"On success, B<mbind>()  returns 0; on error, -1 is returned and I<errno> is "
"set to indicate the error."
msgstr ""

#. type: Plain text
#: man-pages/man2/mbind.2:349
msgid ""
"Part or all of the memory range specified by I<nodemask> and I<maxnode> "
"points outside your accessible address space.  Or, there was an unmapped "
"hole in the specified memory range specified by I<addr> and I<len>."
msgstr ""

#.  As at 2.6.23, this limit is "a page worth of bits", e.g.,
#.  8 * 4096 bits, assuming a 4kB page size.
#. type: Plain text
#: man-pages/man2/mbind.2:397
msgid ""
"An invalid value was specified for I<flags> or I<mode>; or I<addr + len> was "
"less than I<addr>; or I<addr> is not a multiple of the system page size.  "
"Or, I<mode> is B<MPOL_DEFAULT> and I<nodemask> specified a nonempty set; or "
"I<mode> is B<MPOL_BIND> or B<MPOL_INTERLEAVE> and I<nodemask> is empty.  Or, "
"I<maxnode> exceeds a kernel-imposed limit.  Or, I<nodemask> specifies one or "
"more node IDs that are greater than the maximum supported node ID.  Or, none "
"of the node IDs specified by I<nodemask> are on-line and allowed by the "
"thread's current cpuset context, or none of the specified nodes contain "
"memory.  Or, the I<mode> argument specified both B<MPOL_F_STATIC_NODES> and "
"B<MPOL_F_RELATIVE_NODES>."
msgstr ""

#. type: Plain text
#: man-pages/man2/mbind.2:408
msgid ""
"B<MPOL_MF_STRICT> was specified and an existing page was already on a node "
"that does not follow the policy; or B<MPOL_MF_MOVE> or B<MPOL_MF_MOVE_ALL> "
"was specified and the kernel was unable to move all existing pages in the "
"range."
msgstr ""

#.  ---------------------------------------------------------------
#. type: Plain text
#: man-pages/man2/mbind.2:421
msgid ""
"The I<flags> argument included the B<MPOL_MF_MOVE_ALL> flag and the caller "
"does not have the B<CAP_SYS_NICE> privilege."
msgstr ""

#. type: Plain text
#: man-pages/man2/mbind.2:425
msgid "The B<mbind>()  system call was added to the Linux kernel in version 2.6.7."
msgstr ""

#. type: Plain text
#: man-pages/man2/mbind.2:435
msgid ""
"NUMA policy is not supported on a memory-mapped file range that was mapped "
"with the B<MAP_SHARED> flag."
msgstr ""

#. type: Plain text
#: man-pages/man2/mbind.2:469
msgid ""
"The B<MPOL_DEFAULT> mode can have different effects for B<mbind>()  and "
"B<set_mempolicy>(2).  When B<MPOL_DEFAULT> is specified for "
"B<set_mempolicy>(2), the thread's memory policy reverts to the system "
"default policy or local allocation.  When B<MPOL_DEFAULT> is specified for a "
"range of memory using B<mbind>(), any pages subsequently allocated for that "
"range will use the thread's memory policy, as set by B<set_mempolicy>(2).  "
"This effectively removes the explicit policy from the specified range, "
"\"falling back\" to a possibly nondefault policy.  To select explicit "
"\"local allocation\" for a memory range, specify a I<mode> of B<MPOL_LOCAL> "
"or B<MPOL_PREFERRED> with an empty set of nodes.  This method will work for "
"B<set_mempolicy>(2), as well."
msgstr ""

#. type: Plain text
#: man-pages/man2/mbind.2:473
msgid ""
"Support for huge page policy was added with 2.6.16.  For interleave policy "
"to be effective on huge page mappings the policied memory needs to be tens "
"of megabytes or larger."
msgstr ""

#. type: Plain text
#: man-pages/man2/mbind.2:476
msgid "B<MPOL_MF_STRICT> is ignored on huge page mappings."
msgstr ""

#. type: Plain text
#: man-pages/man2/mbind.2:481
msgid ""
"B<MPOL_MF_MOVE> and B<MPOL_MF_MOVE_ALL> are available only on Linux 2.6.16 "
"and later."
msgstr ""

#. type: Plain text
#: man-pages/man2/mbind.2:491
msgid ""
"B<get_mempolicy>(2), B<getcpu>(2), B<mmap>(2), B<set_mempolicy>(2), "
"B<shmat>(2), B<shmget>(2), B<numa>(3), B<cpuset>(7), B<numa>(7), "
"B<numactl>(8)"
msgstr ""

#. type: TH
#: man-pages/man2/pkey_alloc.2:25
#, no-wrap
msgid "PKEY_ALLOC"
msgstr ""

#. type: Plain text
#: man-pages/man2/pkey_alloc.2:28
msgid "pkey_alloc, pkey_free - allocate or free a protection key"
msgstr ""

#. type: Plain text
#: man-pages/man2/pkey_alloc.2:32 man-pages/man2/mprotect.2:44
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>             /* See feature_test_macros(7) */\n"
"B<#include E<lt>sys/mman.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/pkey_alloc.2:35
#, no-wrap
msgid ""
"B<int pkey_alloc(unsigned int >I<flags>B<, unsigned int "
">I<access_rights>B<);>\n"
"B<int pkey_free(int >I<pkey>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/pkey_alloc.2:40
msgid ""
"B<pkey_alloc>()  allocates a protection key (pkey) and allows it to be "
"passed to B<pkey_mprotect>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/pkey_alloc.2:45
msgid ""
"The B<pkey_alloc>()  I<flags> is reserved for future use and currently must "
"always be specified as 0."
msgstr ""

#. type: Plain text
#: man-pages/man2/pkey_alloc.2:50
msgid ""
"The B<pkey_alloc>()  I<access_rights> argument may contain zero or more "
"disable operations:"
msgstr ""

#. type: TP
#: man-pages/man2/pkey_alloc.2:50
#, no-wrap
msgid "B<PKEY_DISABLE_ACCESS>"
msgstr ""

#. type: Plain text
#: man-pages/man2/pkey_alloc.2:53
msgid "Disable all data access to memory covered by the returned protection key."
msgstr ""

#. type: TP
#: man-pages/man2/pkey_alloc.2:53
#, no-wrap
msgid "B<PKEY_DISABLE_WRITE>"
msgstr ""

#. type: Plain text
#: man-pages/man2/pkey_alloc.2:56
msgid "Disable write access to memory covered by the returned protection key."
msgstr ""

#. type: Plain text
#: man-pages/man2/pkey_alloc.2:62
msgid ""
"B<pkey_free>()  frees a protection key and makes it available for later "
"allocations.  After a protection key has been freed, it may no longer be "
"used in any protection-key-related operations."
msgstr ""

#. type: Plain text
#: man-pages/man2/pkey_alloc.2:70
msgid ""
"An application should not call B<pkey_free>()  on any protection key which "
"has been assigned to an address range by B<pkey_mprotect>(2)  and which is "
"still in use.  The behavior in this case is undefined and may result in an "
"error."
msgstr ""

#. type: Plain text
#: man-pages/man2/pkey_alloc.2:80
msgid ""
"On success, B<pkey_alloc>()  returns a positive protection key value.  On "
"success, B<pkey_free>()  returns zero.  On error, -1 is returned, and "
"I<errno> is set appropriately."
msgstr ""

#. type: Plain text
#: man-pages/man2/pkey_alloc.2:88
msgid "I<pkey>, I<flags>, or I<access_rights> is invalid."
msgstr ""

#. type: Plain text
#: man-pages/man2/pkey_alloc.2:97
msgid ""
"(B<pkey_alloc>())  All protection keys available for the current process "
"have been allocated.  The number of keys available is architecture-specific "
"and implementation-specific and may be reduced by kernel-internal use of "
"certain keys.  There are currently 15 keys available to user programs on "
"x86."
msgstr ""

#. type: Plain text
#: man-pages/man2/pkey_alloc.2:103
msgid ""
"This error will also be returned if the processor or operating system does "
"not support protection keys.  Applications should always be prepared to "
"handle this error, since factors outside of the application's control can "
"reduce the number of available pkeys."
msgstr ""

#. type: Plain text
#: man-pages/man2/pkey_alloc.2:109
msgid ""
"B<pkey_alloc>()  and B<pkey_free>()  were added to Linux in kernel 4.9; "
"library support was added in glibc 2.27."
msgstr ""

#. type: Plain text
#: man-pages/man2/pkey_alloc.2:115
msgid "The B<pkey_alloc>()  and B<pkey_free>()  system calls are Linux-specific."
msgstr ""

#. type: Plain text
#: man-pages/man2/pkey_alloc.2:123
msgid ""
"B<pkey_alloc>()  is always safe to call regardless of whether or not the "
"operating system supports protection keys.  It can be used in lieu of any "
"other mechanism for detecting pkey support and will simply fail with the "
"error B<ENOSPC> if the operating system has no pkey support."
msgstr ""

#. type: Plain text
#: man-pages/man2/pkey_alloc.2:134
msgid ""
"The kernel guarantees that the contents of the hardware rights register "
"(PKRU) will be preserved only for allocated protection keys.  Any time a key "
"is unallocated (either before the first call returning that key from "
"B<pkey_alloc>()  or after it is freed via B<pkey_free>()), the kernel may "
"make arbitrary changes to the parts of the rights register affecting access "
"to that key."
msgstr ""

#. type: Plain text
#: man-pages/man2/pkey_alloc.2:137
msgid "See B<pkeys>(7)."
msgstr ""

#. type: Plain text
#: man-pages/man2/pkey_alloc.2:139
msgid "B<pkey_mprotect>(2), B<pkeys>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/idle.2:32
#, no-wrap
msgid "IDLE"
msgstr ""

#. type: TH
#: man-pages/man2/idle.2:32
#, no-wrap
msgid "2012-12-31"
msgstr ""

#. type: Plain text
#: man-pages/man2/idle.2:35
msgid "idle - make process 0 idle"
msgstr ""

#. type: Plain text
#: man-pages/man2/idle.2:39
msgid "B<int idle(void);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/idle.2:46
msgid ""
"B<idle>()  is an internal system call used during bootstrap.  It marks the "
"process's pages as swappable, lowers its priority, and enters the main "
"scheduling loop.  B<idle>()  never returns."
msgstr ""

#. type: Plain text
#: man-pages/man2/idle.2:52
msgid ""
"Only process 0 may call B<idle>().  Any user process, even a process with "
"superuser permission, will receive B<EPERM>."
msgstr ""

#. type: Plain text
#: man-pages/man2/idle.2:55
msgid ""
"B<idle>()  never returns for process 0, and always returns -1 for a user "
"process."
msgstr ""

#. type: Plain text
#: man-pages/man2/idle.2:59 man-pages/man2/setup.2:60
msgid "Always, for a user process."
msgstr ""

#. type: Plain text
#: man-pages/man2/idle.2:61
msgid "Since Linux 2.3.13, this system call does not exist anymore."
msgstr ""

#. type: TH
#: man-pages/man2/ioctl_iflags.2:26
#, no-wrap
msgid "IOCTL_IFLAGS"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_iflags.2:29
msgid "ioctl_iflags - ioctl() operations for inode flags"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_iflags.2:36
msgid ""
"Various Linux filesystems support the notion of I<inode "
"flags>\\(emattributes that modify the semantics of files and directories.  "
"These flags can be retrieved and modified using two B<ioctl>(2)  operations:"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_iflags.2:41
#, no-wrap
msgid ""
"int attr;\n"
"fd = open(\"pathname\", ...);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_iflags.2:47
#, no-wrap
msgid ""
"ioctl(fd, FS_IOC_GETFLAGS, &attr);  /* Place current flags\n"
"                                       in \\(aqattr\\(aq */\n"
"attr |= FS_NOATIME_FL;              /* Tweak returned bit mask */\n"
"ioctl(fd, FS_IOC_SETFLAGS, &attr);  /* Update flags for inode\n"
"                                       referred to by \\(aqfd\\(aq */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_iflags.2:56
msgid ""
"The B<lsattr>(1)  and B<chattr>(1)  shell commands provide interfaces to "
"these two operations, allowing a user to view and modify the inode flags "
"associated with a file."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_iflags.2:62
msgid ""
"The following flags are supported (shown along with the corresponding letter "
"used to indicate the flag by B<lsattr>(1)  and B<chattr>(1)):"
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_iflags.2:62
#, no-wrap
msgid "B<FS_APPEND_FL> \\(aqa\\(aq"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_iflags.2:71
msgid ""
"The file can be opened only with the B<O_APPEND> flag.  (This restriction "
"applies even to the superuser.)  Only a privileged process "
"(B<CAP_LINUX_IMMUTABLE>)  can set or clear this attribute."
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_iflags.2:71
#, no-wrap
msgid "B<FS_COMPR_FL> \\(aqc\\(aq"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_iflags.2:79
msgid ""
"Store the file in a compressed format on disk.  This flag is I<not> "
"supported by most of the mainstream filesystem implementations; one "
"exception is B<btrfs>(5)."
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_iflags.2:79
#, no-wrap
msgid "B<FS_DIRSYNC_FL> \\(aqD\\(aq (since Linux 2.6.0)"
msgstr ""

#.  .TP
#.  .BR FS_EXTENT_FL " \(aqe\(aq"
#.  FIXME Some support on ext4? (EXT4_EXTENTS_FL)
#. type: Plain text
#: man-pages/man2/ioctl_iflags.2:90
msgid ""
"Write directory changes synchronously to disk.  This flag provides semantics "
"equivalent to the B<mount>(2)  B<MS_DIRSYNC> option, but on a per-directory "
"basis.  This flag can be applied only to directories."
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_iflags.2:90
#, no-wrap
msgid "B<FS_IMMUTABLE_FL> \\(aqi\\(aq"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_iflags.2:99
msgid ""
"The file is immutable: no changes are permitted to the file contents or "
"metadata (permissions, timestamps, ownership, link count and so on).  (This "
"restriction applies even to the superuser.)  Only a privileged process "
"(B<CAP_LINUX_IMMUTABLE>)  can set or clear this attribute."
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_iflags.2:99
#, no-wrap
msgid "B<FS_JOURNAL_DATA_FL> \\(aqj\\(aq"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_iflags.2:114
msgid ""
"Enable journaling of file data on B<ext3>(5)  and B<ext4>(5)  filesystems.  "
"On a filesystem that is journaling in I<ordered> or I<writeback> mode, a "
"privileged (B<CAP_SYS_RESOURCE>)  process can set this flag to enable "
"journaling of data updates on a per-file basis."
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_iflags.2:114
#, no-wrap
msgid "B<FS_NOATIME_FL> \\(aqA\\(aq"
msgstr ""

#.  .TP
#.  .BR FS_NOCOMP_FL " \(aq\(aq"
#.  FIXME Support for FS_NOCOMP_FL on Btrfs?
#. type: Plain text
#: man-pages/man2/ioctl_iflags.2:126
msgid ""
"Don't update the file last access time when the file is accessed.  This can "
"provide I/O performance benefits for applications that do not care about the "
"accuracy of this timestamp.  This flag provides functionality similar to the "
"B<mount>(2)  B<MS_NOATIME> flag, but on a per-file basis."
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_iflags.2:126
#, no-wrap
msgid "B<FS_NOCOW_FL> \\(aqC\\(aq (since Linux 2.6.39)"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_iflags.2:135
msgid ""
"The file will not be subject to copy-on-write updates.  This flag has an "
"effect only on filesystems that support copy-on-write semantics, such as "
"Btrfs.  See B<chattr>(1)  and B<btrfs>(5)."
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_iflags.2:135
#, no-wrap
msgid "B<FS_NODUMP_FL> \\(aqd\\(aq"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_iflags.2:139
msgid "Don't include this file in backups made using B<dump>(8)."
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_iflags.2:139
#, no-wrap
msgid "B<FS_NOTAIL_FL> \\(aqt\\(aq"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_iflags.2:145
msgid ""
"This flag is supported only on Reiserfs.  It disables the Reiserfs "
"tail-packing feature, which tries to pack small files (and the final "
"fragment of larger files)  into the same disk block as the file metadata."
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_iflags.2:145
#, no-wrap
msgid "B<FS_PROJINHERIT_FL> \\(aqP\\(aq (since Linux 4.5)"
msgstr ""

#.  commit 040cb3786d9b25293b8b0b05b90da0f871e1eb9b
#.  Flag name was added in Linux 4.4
#.  FIXME Not currently supported because not in FS_FL_USER_MODIFIABLE?
#. type: Plain text
#: man-pages/man2/ioctl_iflags.2:153
msgid ""
"Inherit the quota project ID.  Files and subdirectories will inherit the "
"project ID of the directory.  This flag can be applied only to directories."
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_iflags.2:153
#, no-wrap
msgid "B<FS_SECRM_FL> \\(aqs\\(aq"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_iflags.2:159
msgid ""
"Mark the file for secure deletion.  This feature is not implemented by any "
"filesystem, since the task of securely erasing a file from a recording "
"medium is surprisingly difficult."
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_iflags.2:159
#, no-wrap
msgid "B<FS_SYNC_FL> \\(aqS\\(aq"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_iflags.2:169
msgid ""
"Make file updates synchronous.  For files, this makes all writes synchronous "
"(as though all opens of the file were with the B<O_SYNC> flag).  For "
"directories, this has the same effect as the B<FS_DIRSYNC_FL> flag."
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_iflags.2:169
#, no-wrap
msgid "B<FS_TOPDIR_FL> \\(aqT\\(aq"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_iflags.2:178
msgid ""
"Mark a directory for special treatment under the Orlov block-allocation "
"strategy.  See B<chattr>(1)  for details.  This flag can be applied only to "
"directories and has an effect only for ext2, ext3, and ext4."
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_iflags.2:178
#, no-wrap
msgid "B<FS_UNRM_FL> \\(aqu\\(aq"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_iflags.2:183
msgid ""
"Allow the file to be undeleted if it is deleted.  This feature is not "
"implemented by any filesystem, since it is possible to implement "
"file-recovery mechanisms outside the kernel."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_iflags.2:193
msgid ""
"In most cases, when any of the above flags is set on a directory, the flag "
"is inherited by files and subdirectories created inside that directory.  "
"Exceptions include B<FS_TOPDIR_FL>, which is not inheritable, and "
"B<FS_DIRSYNC_FL>, which is inherited only by subdirectories."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_iflags.2:195
msgid "Inode flags are a nonstandard Linux extension."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_iflags.2:203
msgid ""
"In order to change the inode flags of a file using the B<FS_IOC_SETFLAGS> "
"operation, the effective user ID of the caller must match the owner of the "
"file, or the caller must have the B<CAP_FOWNER> capability."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_iflags.2:211
msgid ""
"B<chattr>(1), B<lsattr>(1), B<mount>(2), B<btrfs>(5), B<ext4>(5), B<xfs>(5), "
"B<xattr>(7), B<mount>(8)"
msgstr ""

#. type: TH
#: man-pages/man2/utimensat.2:26
#, no-wrap
msgid "UTIMENSAT"
msgstr ""

#. type: Plain text
#: man-pages/man2/utimensat.2:29
msgid "utimensat, futimens - change file timestamps with nanosecond precision"
msgstr ""

#. type: Plain text
#: man-pages/man2/utimensat.2:33
#, no-wrap
msgid ""
"B<#include E<lt>fcntl.hE<gt> /* Definition of AT_* constants */>\n"
"B<#include E<lt>sys/stat.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/utimensat.2:36
#, no-wrap
msgid ""
"B<int utimensat(int >I<dirfd>B<, const char *>I<pathname>B<,>\n"
"B<              const struct timespec >I<times>B<[2], int >I<flags>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/utimensat.2:38
#, no-wrap
msgid "B<int futimens(int >I<fd>B<, const struct timespec >I<times>B<[2]);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/utimensat.2:48
msgid "B<utimensat>():"
msgstr ""

#. type: Plain text
#: man-pages/man2/utimensat.2:58
msgid "B<futimens>():"
msgstr ""

#. type: Plain text
#: man-pages/man2/utimensat.2:79
msgid ""
"B<utimensat>()  and B<futimens>()  update the timestamps of a file with "
"nanosecond precision.  This contrasts with the historical B<utime>(2)  and "
"B<utimes>(2), which permit only second and microsecond precision, "
"respectively, when setting file timestamps."
msgstr ""

#. type: Plain text
#: man-pages/man2/utimensat.2:89
msgid ""
"With B<utimensat>()  the file is specified via the pathname given in "
"I<pathname>.  With B<futimens>()  the file whose timestamps are to be "
"updated is specified via an open file descriptor, I<fd>."
msgstr ""

#. type: Plain text
#: man-pages/man2/utimensat.2:101
msgid ""
"For both calls, the new file timestamps are specified in the array I<times>: "
"I<times>[0] specifies the new \"last access time\" (I<atime>); I<times>[1] "
"specifies the new \"last modification time\" (I<mtime>).  Each of the "
"elements of I<times> specifies a time as the number of seconds and "
"nanoseconds since the Epoch, 1970-01-01 00:00:00 +0000 (UTC).  This "
"information is conveyed in a structure of the following form:"
msgstr ""

#. type: Plain text
#: man-pages/man2/utimensat.2:113
msgid ""
"Updated file timestamps are set to the greatest value supported by the "
"filesystem that is not greater than the specified time."
msgstr ""

#.  2.6.22 was broken: it is not ignored
#. type: Plain text
#: man-pages/man2/utimensat.2:132
msgid ""
"If the I<tv_nsec> field of one of the I<timespec> structures has the special "
"value B<UTIME_NOW>, then the corresponding file timestamp is set to the "
"current time.  If the I<tv_nsec> field of one of the I<timespec> structures "
"has the special value B<UTIME_OMIT>, then the corresponding file timestamp "
"is left unchanged.  In both of these cases, the value of the corresponding "
"I<tv_sec> field is ignored."
msgstr ""

#. type: Plain text
#: man-pages/man2/utimensat.2:137
msgid "If I<times> is NULL, then both timestamps are set to the current time."
msgstr ""

#. type: SS
#: man-pages/man2/utimensat.2:137
#, no-wrap
msgid "Permissions requirements"
msgstr ""

#. type: Plain text
#: man-pages/man2/utimensat.2:145
msgid ""
"To set both file timestamps to the current time (i.e., I<times> is NULL, or "
"both I<tv_nsec> fields specify B<UTIME_NOW>), either:"
msgstr ""

#.  2.6.22 was broken here -- for futimens() the check is
#.  based on whether or not the file descriptor is writable,
#.  not on whether the caller's effective UID has write
#.  permission for the file referred to by the descriptor.
#. type: Plain text
#: man-pages/man2/utimensat.2:151
msgid "the caller must have write access to the file;"
msgstr ""

#. type: Plain text
#: man-pages/man2/utimensat.2:153
msgid "the caller's effective user ID must match the owner of the file; or"
msgstr ""

#. type: Plain text
#: man-pages/man2/utimensat.2:155
msgid "the caller must have appropriate privileges."
msgstr ""

#.  2.6.22 was broken here:
#.  both must be something other than *either* UTIME_OMIT *or* UTIME_NOW.
#. type: Plain text
#: man-pages/man2/utimensat.2:170
msgid ""
"To make any change other than setting both timestamps to the current time "
"(i.e., I<times> is not NULL, and neither I<tv_nsec> field is B<UTIME_NOW> "
"and neither I<tv_nsec> field is B<UTIME_OMIT>), either condition 2 or 3 "
"above must apply."
msgstr ""

#. type: Plain text
#: man-pages/man2/utimensat.2:180
msgid ""
"If both I<tv_nsec> fields are specified as B<UTIME_OMIT>, then no file "
"ownership or permission checks are performed, and the file timestamps are "
"not modified, but other error conditions may still be detected."
msgstr ""

#. type: SS
#: man-pages/man2/utimensat.2:180
#, no-wrap
msgid "utimensat() specifics"
msgstr ""

#. type: Plain text
#: man-pages/man2/utimensat.2:193
msgid ""
"If I<pathname> is relative, then by default it is interpreted relative to "
"the directory referred to by the open file descriptor, I<dirfd> (rather than "
"relative to the current working directory of the calling process, as is done "
"by B<utimes>(2)  for a relative pathname).  See B<openat>(2)  for an "
"explanation of why this can be useful."
msgstr ""

#. type: Plain text
#: man-pages/man2/utimensat.2:205 man-pages/man2/futimesat.2:78
msgid ""
"If I<pathname> is relative and I<dirfd> is the special value B<AT_FDCWD>, "
"then I<pathname> is interpreted relative to the current working directory of "
"the calling process (like B<utimes>(2))."
msgstr ""

#. type: Plain text
#: man-pages/man2/utimensat.2:217
msgid ""
"The I<flags> field is a bit mask that may be 0, or include the following "
"constant, defined in I<E<lt>fcntl.hE<gt>>:"
msgstr ""

#. type: Plain text
#: man-pages/man2/utimensat.2:223
msgid ""
"If I<pathname> specifies a symbolic link, then update the timestamps of the "
"link, rather than the file to which it refers."
msgstr ""

#. type: Plain text
#: man-pages/man2/utimensat.2:232
msgid ""
"On success, B<utimensat>()  and B<futimens>()  return 0.  On error, -1 is "
"returned and I<errno> is set to indicate the error."
msgstr ""

#. type: Plain text
#: man-pages/man2/utimensat.2:242
msgid "I<times> is NULL, or both I<tv_nsec> values are B<UTIME_NOW>, and either:"
msgstr ""

#.  But Linux 2.6.22 was broken here.
#.  Traditionally, utime()/utimes() gives the error EACCES for the case
#.  where the timestamp pointer argument is NULL (i.e., set both timestamps
#.  to the current time), and the file is owned by a user other than the
#.  effective UID of the caller, and the file is not writable by the
#.  effective UID of the program.  utimensat() also gives this error in the
#.  same case.  However, in the same circumstances, when utimensat() is
#.  given a 'times' array in which both tv_nsec fields are UTIME_NOW, which
#.  provides equivalent functionality to specifying 'times' as NULL, the
#.  call succeeds.  It should fail with the error EACCES in this case.
#
#.  POSIX.1-2008 has the following:
#.  .TP
#.  .B EACCES
#.  .RB ( utimensat ())
#.  .I fd
#.  was not opened with
#.  .B O_SEARCH
#.  and the permissions of the directory to which
#.  .I fd
#.  refers do not allow searches.
#. type: Plain text
#: man-pages/man2/utimensat.2:274
msgid ""
"the effective user ID of the caller does not match the owner of the file, "
"the caller does not have write access to the file, and the caller is not "
"privileged (Linux: does not have either the B<CAP_FOWNER> or the "
"B<CAP_DAC_OVERRIDE> capability); or,"
msgstr ""

#.  EXT2_IMMUTABLE_FL and similar flags for other filesystems.
#. type: Plain text
#: man-pages/man2/utimensat.2:278
msgid "the file is marked immutable (see B<chattr>(1))."
msgstr ""

#. type: Plain text
#: man-pages/man2/utimensat.2:284
msgid "(B<futimens>())  I<fd> is not a valid file descriptor."
msgstr ""

#. type: Plain text
#: man-pages/man2/utimensat.2:293
msgid ""
"(B<utimensat>())  I<pathname> is a relative pathname, but I<dirfd> is "
"neither B<AT_FDCWD> nor a valid file descriptor."
msgstr ""

#. type: Plain text
#: man-pages/man2/utimensat.2:303
msgid ""
"I<times> pointed to an invalid address; or, I<dirfd> was B<AT_FDCWD>, and "
"I<pathname> is NULL or an invalid address."
msgstr ""

#. type: Plain text
#: man-pages/man2/utimensat.2:318
msgid ""
"Invalid value in one of the I<tv_nsec> fields (value outside range 0 to "
"999,999,999, and not B<UTIME_NOW> or B<UTIME_OMIT>); or an invalid value in "
"one of the I<tv_sec> fields."
msgstr ""

#.  SUSv4 does not specify this error.
#. type: Plain text
#: man-pages/man2/utimensat.2:330
msgid ""
"I<pathname> is NULL, I<dirfd> is not B<AT_FDCWD>, and I<flags> contains "
"B<AT_SYMLINK_NOFOLLOW>."
msgstr ""

#. type: Plain text
#: man-pages/man2/utimensat.2:335
msgid ""
"(B<utimensat>())  Too many symbolic links were encountered in resolving "
"I<pathname>."
msgstr ""

#. type: Plain text
#: man-pages/man2/utimensat.2:340
msgid "(B<utimensat>())  I<pathname> is too long."
msgstr ""

#. type: Plain text
#: man-pages/man2/utimensat.2:349
msgid ""
"(B<utimensat>())  A component of I<pathname> does not refer to an existing "
"directory or file, or I<pathname> is an empty string."
msgstr ""

#. type: Plain text
#: man-pages/man2/utimensat.2:361
msgid ""
"(B<utimensat>())  I<pathname> is a relative pathname, but I<dirfd> is "
"neither B<AT_FDCWD> nor a file descriptor referring to a directory; or, one "
"of the prefix components of I<pathname> is not a directory."
msgstr ""

#. type: Plain text
#: man-pages/man2/utimensat.2:378
msgid ""
"The caller attempted to change one or both timestamps to a value other than "
"the current time, or to change one of the timestamps to the current time "
"while leaving the other timestamp unchanged, (i.e., I<times> is not NULL, "
"neither I<tv_nsec> field is B<UTIME_NOW>, and neither I<tv_nsec> field is "
"B<UTIME_OMIT>)  and either:"
msgstr ""

#. type: Plain text
#: man-pages/man2/utimensat.2:385
msgid ""
"the caller's effective user ID does not match the owner of file, and the "
"caller is not privileged (Linux: does not have the B<CAP_FOWNER> "
"capability); or,"
msgstr ""

#.  Linux 2.6.22 was broken here:
#.  it was not consistent with the old utimes() implementation,
#.  since the case when both tv_nsec fields are UTIME_NOW, was not
#.  treated like the (times == NULL) case.
#.  EXT2_IMMUTABLE_FL EXT_APPPEND_FL and similar flags for
#.  other filesystems.
#
#.  Why the inconsistency (which is described under NOTES) between
#.  EACCES and EPERM, where only EPERM tests for append-only.
#.  (This was also so for the older utimes() implementation.)
#. type: Plain text
#: man-pages/man2/utimensat.2:398
msgid "the file is marked append-only or immutable (see B<chattr>(1))."
msgstr ""

#. type: Plain text
#: man-pages/man2/utimensat.2:407
msgid ""
"(B<utimensat>())  Search permission is denied for one of the prefix "
"components of I<pathname>."
msgstr ""

#. type: Plain text
#: man-pages/man2/utimensat.2:411
msgid ""
"B<utimensat>()  was added to Linux in kernel 2.6.22; glibc support was added "
"with version 2.6."
msgstr ""

#. type: Plain text
#: man-pages/man2/utimensat.2:415
msgid "Support for B<futimens>()  first appeared in glibc 2.6."
msgstr ""

#. type: tbl table
#: man-pages/man2/utimensat.2:426
#, no-wrap
msgid ""
"B<utimensat>(),\n"
"B<futimens>()"
msgstr ""

#. type: Plain text
#: man-pages/man2/utimensat.2:434
msgid "B<futimens>()  and B<utimensat>()  are specified in POSIX.1-2008."
msgstr ""

#. type: Plain text
#: man-pages/man2/utimensat.2:438
msgid "B<utimensat>()  obsoletes B<futimesat>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/utimensat.2:447
msgid ""
"On Linux, timestamps cannot be changed for a file marked immutable, and the "
"only change permitted for files marked append-only is to set the timestamps "
"to the current time.  (This is consistent with the historical behavior of "
"B<utime>(2)  and B<utimes>(2)  on Linux.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/utimensat.2:459
msgid ""
"If both I<tv_nsec> fields are specified as B<UTIME_OMIT>, then the Linux "
"implementation of B<utimensat>()  succeeds even if the file referred to by "
"I<dirfd> and I<pathname> does not exist."
msgstr ""

#. type: Plain text
#: man-pages/man2/utimensat.2:476
msgid ""
"On Linux, B<futimens>()  is a library function implemented on top of the "
"B<utimensat>()  system call.  To support this, the Linux B<utimensat>()  "
"system call implements a nonstandard feature: if I<pathname> is NULL, then "
"the call modifies the timestamps of the file referred to by the file "
"descriptor I<dirfd> (which may refer to any type of file).  Using this "
"feature, the call I<futimens(fd,\\ times)> is implemented as:"
msgstr ""

#. type: Plain text
#: man-pages/man2/utimensat.2:480
#, no-wrap
msgid "utimensat(fd, NULL, times, 0);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/utimensat.2:490
msgid ""
"Note, however, that the glibc wrapper for B<utimensat>()  disallows passing "
"NULL as the value for I<pathname>: the wrapper function returns the error "
"I<EINVAL> in this case."
msgstr ""

#. type: Plain text
#: man-pages/man2/utimensat.2:498
msgid ""
"Several bugs afflict B<utimensat>()  and B<futimens>()  on kernels before "
"2.6.26.  These bugs are either nonconformances with the POSIX.1 draft "
"specification or inconsistencies with historical Linux behavior."
msgstr ""

#. type: Plain text
#: man-pages/man2/utimensat.2:513
msgid ""
"POSIX.1 specifies that if one of the I<tv_nsec> fields has the value "
"B<UTIME_NOW> or B<UTIME_OMIT>, then the value of the corresponding I<tv_sec> "
"field should be ignored.  Instead, the value of the I<tv_sec> field is "
"required to be 0 (or the error B<EINVAL> results)."
msgstr ""

#.  Below, the long description of the errors from the previous bullet
#.  point (abridged because it's too much detail for a man page).
#.  .IP *
#.  If one of the
#.  .I tv_nsec
#.  fields is
#.  .BR UTIME_OMIT
#.  and the other is
#.  .BR UTIME_NOW ,
#.  then the error
#.  .B EPERM
#.  should occur if the process's effective user ID does not match
#.  the file owner and the process is not privileged.
#.  Instead, the call successfully changes one of the timestamps.
#.  .IP *
#.  If file is not writable by the effective user ID of the process and
#.  the process's effective user ID does not match the file owner and
#.  the process is not privileged,
#.  and
#.  .I times
#.  is NULL, then the error
#.  .B EACCES
#.  results.
#.  This error should also occur if
#.  .I times
#.  points to an array of structures in which both
#.  .I tv_nsec
#.  fields are
#.  .BR UTIME_NOW .
#.  Instead the call succeeds.
#.  .IP *
#.  If a file is marked as append-only (see
#.  .BR chattr (1)),
#.  then Linux traditionally
#.  (i.e.,
#.  .BR utime (2),
#.  .BR utimes (2)),
#.  permits a NULL
#.  .I times
#.  argument to be used in order to update both timestamps to the current time.
#.  For consistency,
#.  .BR utimensat ()
#.  and
#.  .BR futimens ()
#.  should also produce the same result when given a
#.  .I times
#.  argument that points to an array of structures in which both
#.  .I tv_nsec
#.  fields are
#.  .BR UTIME_NOW .
#.  Instead, the call fails with the error
#.  .BR EPERM .
#.  .IP *
#.  If a file is marked as immutable (see
#.  .BR chattr (1)),
#.  then Linux traditionally
#.  (i.e.,
#.  .BR utime (2),
#.  .BR utimes (2)),
#.  gives an
#.  .B EACCES
#.  error if
#.  .I times
#.  is NULL.
#.  For consistency,
#.  .BR utimensat ()
#.  and
#.  .BR futimens ()
#.  should also produce the same result when given a
#.  .I times
#.  that points to an array of structures in which both
#.  .I tv_nsec
#.  fields are
#.  .BR UTIME_NOW .
#.  Instead, the call fails with the error
#.  .BR EPERM .
#. type: Plain text
#: man-pages/man2/utimensat.2:615
msgid ""
"Various bugs mean that for the purposes of permission checking, the case "
"where both I<tv_nsec> fields are set to B<UTIME_NOW> isn't always treated "
"the same as specifying I<times> as NULL, and the case where one I<tv_nsec> "
"value is B<UTIME_NOW> and the other is B<UTIME_OMIT> isn't treated the same "
"as specifying I<times> as a pointer to an array of structures containing "
"arbitrary time values.  As a result, in some cases: a) file timestamps can "
"be updated by a process that shouldn't have permission to perform updates; "
"b) file timestamps can't be updated by a process that should have permission "
"to perform updates; and c) the wrong I<errno> value is returned in case of "
"an error."
msgstr ""

#.  This means that a process with a file descriptor that allows
#.  writing could change the timestamps of a file for which it
#.  does not have write permission;
#.  conversely, a process with a read-only file descriptor won't
#.  be able to update the timestamps of a file,
#.  even if it has write permission on the file.
#. type: Plain text
#: man-pages/man2/utimensat.2:636
msgid ""
"POSIX.1 says that a process that has I<write access to the file> can make a "
"call with I<times> as NULL, or with I<times> pointing to an array of "
"structures in which both I<tv_nsec> fields are B<UTIME_NOW>, in order to "
"update both timestamps to the current time.  However, B<futimens>()  instead "
"checks whether the I<access mode of the file descriptor allows writing>."
msgstr ""

#. type: Plain text
#: man-pages/man2/utimensat.2:646
msgid ""
"B<chattr>(1), B<touch>(1), B<futimesat>(2), B<openat>(2), B<stat>(2), "
"B<utimes>(2), B<futimes>(3), B<inode>(7), B<path_resolution>(7), "
"B<symlink>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/mq_getsetattr.2:26
#, no-wrap
msgid "MQ_GETSETATTR"
msgstr ""

#. type: Plain text
#: man-pages/man2/mq_getsetattr.2:29
msgid "mq_getsetattr - get/set message queue attributes"
msgstr ""

#. type: Plain text
#: man-pages/man2/mq_getsetattr.2:33
#, no-wrap
msgid ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>mqueue.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/mq_getsetattr.2:36
#, no-wrap
msgid ""
"B<int mq_getsetattr(mqd_t >I<mqdes>B<, struct mq_attr *>I<newattr>B<,>\n"
"B<                 struct mq_attr *>I<oldattr>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/mq_getsetattr.2:42
msgid "Do not use this system call."
msgstr ""

#. type: Plain text
#: man-pages/man2/mq_getsetattr.2:50
msgid ""
"This is the low-level system call used to implement B<mq_getattr>(3)  and "
"B<mq_setattr>(3).  For an explanation of how this system call operates, see "
"the description of B<mq_setattr>(3)."
msgstr ""

#. type: Plain text
#: man-pages/man2/mq_getsetattr.2:52
msgid "This interface is nonstandard; avoid its use."
msgstr ""

#. type: Plain text
#: man-pages/man2/mq_getsetattr.2:56
msgid ""
"Glibc does not provide a wrapper for this system call; call it using "
"B<syscall>(2).  (Actually, never call it unless you are writing a C "
"library!)"
msgstr ""

#. type: Plain text
#: man-pages/man2/mq_getsetattr.2:58
msgid "B<mq_getattr>(3), B<mq_overview>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/nice.2:31
#, no-wrap
msgid "NICE"
msgstr ""

#. type: Plain text
#: man-pages/man2/nice.2:34
msgid "nice - change process priority"
msgstr ""

#. type: Plain text
#: man-pages/man2/nice.2:38
msgid "B<int nice(int >I<inc>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/nice.2:48
#, no-wrap
msgid ""
"B<nice>():\n"
"_XOPEN_SOURCE\n"
"    || /* Since glibc 2.19: */ _DEFAULT_SOURCE\n"
"    || /* Glibc versions E<lt>= 2.19: */ _BSD_SOURCE || _SVID_SOURCE\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/nice.2:54
msgid ""
"B<nice>()  adds I<inc> to the nice value for the calling thread.  (A higher "
"nice value means a low priority.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/nice.2:57
msgid ""
"The range of the nice value is +19 (low priority) to -20 (high priority).  "
"Attempts to set a nice value outside the range are clamped to the range."
msgstr ""

#. type: Plain text
#: man-pages/man2/nice.2:66 man-pages/man2/getpriority.2:120
msgid ""
"Traditionally, only a privileged process could lower the nice value (i.e., "
"set a higher priority).  However, since Linux 2.6.12, an unprivileged "
"process can decrease the nice value of a target process that has a suitable "
"B<RLIMIT_NICE> soft limit; see B<getrlimit>(2)  for details."
msgstr ""

#. type: Plain text
#: man-pages/man2/nice.2:71
msgid ""
"On success, the new nice value is returned (but see NOTES below).  On error, "
"-1 is returned, and I<errno> is set appropriately."
msgstr ""

#. type: Plain text
#: man-pages/man2/nice.2:78
msgid ""
"A successful call can legitimately return -1.  To detect an error, set "
"I<errno> to 0 before the call, and check whether it is nonzero after "
"B<nice>()  returns -1."
msgstr ""

#. type: Plain text
#: man-pages/man2/nice.2:92
msgid ""
"The calling process attempted to increase its priority by supplying a "
"negative I<inc> but has insufficient privileges.  Under Linux, the "
"B<CAP_SYS_NICE> capability is required.  (But see the discussion of the "
"B<RLIMIT_NICE> resource limit in B<setrlimit>(2).)"
msgstr ""

#.  SVr4 documents an additional
#.  .B EINVAL
#.  error code.
#. type: Plain text
#: man-pages/man2/nice.2:99
msgid ""
"POSIX.1-2001, POSIX.1-2008, SVr4, 4.3BSD.  However, the raw system call and "
"(g)libc (earlier than glibc 2.2.4) return value is nonstandard, see below."
msgstr ""

#. type: Plain text
#: man-pages/man2/nice.2:102 man-pages/man2/getpriority.2:182
msgid "For further details on the nice value, see B<sched>(7)."
msgstr ""

#. type: Plain text
#: man-pages/man2/nice.2:109 man-pages/man2/getpriority.2:188
msgid ""
"I<Note>: the addition of the \"autogroup\" feature in Linux 2.6.38 means "
"that the nice value no longer has its traditional effect in many "
"circumstances.  For details, see B<sched>(7)."
msgstr ""

#. type: Plain text
#: man-pages/man2/nice.2:117
msgid ""
"POSIX.1 specifies that B<nice>()  should return the new nice value.  "
"However, the raw Linux system call returns 0 on success.  Likewise, the "
"B<nice>()  wrapper function provided in glibc 2.2.3 and earlier returns 0 on "
"success."
msgstr ""

#. type: Plain text
#: man-pages/man2/nice.2:123
msgid ""
"Since glibc 2.2.4, the B<nice>()  wrapper function provided by glibc "
"provides conformance to POSIX.1 by calling B<getpriority>(2)  to obtain the "
"new nice value, which is then returned to the caller."
msgstr ""

#. type: Plain text
#: man-pages/man2/nice.2:131
msgid ""
"B<nice>(1), B<renice>(1), B<fork>(2), B<getpriority>(2), B<getrlimit>(2), "
"B<setpriority>(2), B<capabilities>(7), B<sched>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/sched_setscheduler.2:26
#, no-wrap
msgid "SCHED_SETSCHEDULER"
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_setscheduler.2:30
msgid ""
"sched_setscheduler, sched_getscheduler - set and get scheduling "
"policy/parameters"
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_setscheduler.2:36
#, no-wrap
msgid ""
"B<int sched_setscheduler(pid_t >I<pid>B<, int >I<policy>B<,>\n"
"B<                       const struct sched_param *>I<param>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_setscheduler.2:38
#, no-wrap
msgid "B<int sched_getscheduler(pid_t >I<pid>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_setscheduler.2:47
msgid ""
"The B<sched_setscheduler>()  system call sets both the scheduling policy and "
"parameters for the thread whose ID is specified in I<pid>.  If I<pid> equals "
"zero, the scheduling policy and parameters of the calling thread will be "
"set."
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_setscheduler.2:51
msgid ""
"The scheduling parameters are specified in the I<param> argument, which is a "
"pointer to a structure of the following form:"
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_setscheduler.2:59
#, no-wrap
msgid ""
"struct sched_param {\n"
"    ...\n"
"    int sched_priority;\n"
"    ...\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_setscheduler.2:67
msgid ""
"In the current implementation, the structure contains only one field, "
"I<sched_priority>.  The interpretation of I<param> depends on the selected "
"policy."
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_setscheduler.2:71 man-pages/man2/sched_setattr.2:56
msgid ""
"Currently, Linux supports the following \"normal\" (i.e., non-real-time) "
"scheduling policies as values that may be specified in I<policy>:"
msgstr ""

#. type: TP
#: man-pages/man2/sched_setscheduler.2:71 man-pages/man2/sched_setattr.2:56
#, no-wrap
msgid "B<SCHED_OTHER>"
msgstr ""

#.  In the 2.6 kernel sources, SCHED_OTHER is actually called
#.  SCHED_NORMAL.
#. type: Plain text
#: man-pages/man2/sched_setscheduler.2:76 man-pages/man2/sched_setattr.2:61
msgid "the standard round-robin time-sharing policy;"
msgstr ""

#. type: TP
#: man-pages/man2/sched_setscheduler.2:76 man-pages/man2/sched_setattr.2:61
#, no-wrap
msgid "B<SCHED_BATCH>"
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_setscheduler.2:79 man-pages/man2/sched_setattr.2:64
msgid "for \"batch\" style execution of processes; and"
msgstr ""

#. type: TP
#: man-pages/man2/sched_setscheduler.2:79 man-pages/man2/sched_setattr.2:64
#, no-wrap
msgid "B<SCHED_IDLE>"
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_setscheduler.2:84 man-pages/man2/sched_setattr.2:69
msgid "for running I<very> low priority background jobs."
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_setscheduler.2:88
msgid "For each of the above policies, I<param-E<gt>sched_priority> must be 0."
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_setscheduler.2:97 man-pages/man2/sched_setattr.2:78
msgid ""
"Various \"real-time\" policies are also supported, for special time-critical "
"applications that need precise control over the way in which runnable "
"threads are selected for execution.  For the rules governing when a process "
"may use these policies, see B<sched>(7).  The real-time policies that may be "
"specified in I<policy> are:"
msgstr ""

#. type: TP
#: man-pages/man2/sched_setscheduler.2:97 man-pages/man2/sched_setattr.2:78
#, no-wrap
msgid "B<SCHED_FIFO>"
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_setscheduler.2:100 man-pages/man2/sched_setattr.2:81
msgid "a first-in, first-out policy; and"
msgstr ""

#. type: TP
#: man-pages/man2/sched_setscheduler.2:100 man-pages/man2/sched_setattr.2:81
#, no-wrap
msgid "B<SCHED_RR>"
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_setscheduler.2:103 man-pages/man2/sched_setattr.2:84
msgid "a round-robin policy."
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_setscheduler.2:114
msgid ""
"For each of the above policies, I<param-E<gt>sched_priority> specifies a "
"scheduling priority for the thread.  This is a number in the range returned "
"by calling B<sched_get_priority_min>(2)  and B<sched_get_priority_max>(2)  "
"with the specified I<policy>.  On Linux, these system calls return, "
"respectively, 1 and 99."
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_setscheduler.2:127
msgid ""
"Since Linux 2.6.32, the B<SCHED_RESET_ON_FORK> flag can be ORed in I<policy> "
"when calling B<sched_setscheduler>().  As a result of including this flag, "
"children created by B<fork>(2)  do not inherit privileged scheduling "
"policies.  See B<sched>(7)  for details."
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_setscheduler.2:133
msgid ""
"B<sched_getscheduler>()  returns the current scheduling policy of the thread "
"identified by I<pid>.  If I<pid> equals zero, the policy of the calling "
"thread will be retrieved."
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_setscheduler.2:143
msgid ""
"On success, B<sched_setscheduler>()  returns zero.  On success, "
"B<sched_getscheduler>()  returns the policy for the thread (a nonnegative "
"integer).  On error, both calls return -1, and I<errno> is set "
"appropriately."
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_setscheduler.2:151
msgid "Invalid arguments: I<pid> is negative or I<param> is NULL."
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_setscheduler.2:156
msgid "(B<sched_setscheduler>())  I<policy> is not one of the recognized policies."
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_setscheduler.2:162
msgid ""
"(B<sched_setscheduler>())  I<param> does not make sense for the specified "
"I<policy>."
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_setscheduler.2:165
msgid "The calling thread does not have appropriate privileges."
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_setscheduler.2:171
msgid ""
"POSIX.1-2001, POSIX.1-2008 (but see BUGS below).  The B<SCHED_BATCH> and "
"B<SCHED_IDLE> policies are Linux-specific."
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_setscheduler.2:180
msgid ""
"Further details of the semantics of all of the above \"normal\" and "
"\"real-time\" scheduling policies can be found in the B<sched>(7)  manual "
"page.  That page also describes an additional policy, B<SCHED_DEADLINE>, "
"which is settable only via B<sched_setattr>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_setscheduler.2:188
msgid ""
"POSIX systems on which B<sched_setscheduler>()  and B<sched_getscheduler>()  "
"are available define B<_POSIX_PRIORITY_SCHEDULING> in I<E<lt>unistd.hE<gt>>."
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_setscheduler.2:196
msgid ""
"POSIX.1 does not detail the permissions that an unprivileged thread requires "
"in order to call B<sched_setscheduler>(), and details vary across systems.  "
"For example, the Solaris 7 manual page says that the real or effective user "
"ID of the caller must match the real user ID or the save set-user-ID of the "
"target."
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_setscheduler.2:217
msgid ""
"The scheduling policy and parameters are in fact per-thread attributes on "
"Linux.  The value returned from a call to B<gettid>(2)  can be passed in the "
"argument I<pid>.  Specifying I<pid> as 0 will operate on the attributes of "
"the calling thread, and passing the value returned from a call to "
"B<getpid>(2)  will operate on the attributes of the main thread of the "
"thread group.  (If you are using the POSIX threads API, then use "
"B<pthread_setschedparam>(3), B<pthread_getschedparam>(3), and "
"B<pthread_setschedprio>(3), instead of the B<sched_*>(2)  system calls.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_setscheduler.2:225
msgid ""
"POSIX.1 says that on success, B<sched_setscheduler>()  should return the "
"previous scheduling policy.  Linux B<sched_setscheduler>()  does not conform "
"to this requirement, since it always returns 0 on success."
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_setscheduler.2:244
msgid ""
"B<chrt>(1), B<nice>(2), B<sched_get_priority_max>(2), "
"B<sched_get_priority_min>(2), B<sched_getaffinity>(2), B<sched_getattr>(2), "
"B<sched_getparam>(2), B<sched_rr_get_interval>(2), B<sched_setaffinity>(2), "
"B<sched_setattr>(2), B<sched_setparam>(2), B<sched_yield>(2), "
"B<setpriority>(2), B<capabilities>(7), B<cpuset>(7), B<sched>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/chown.2:38
#, no-wrap
msgid "CHOWN"
msgstr ""

#. type: Plain text
#: man-pages/man2/chown.2:41
msgid "chown, fchown, lchown, fchownat - change ownership of a file"
msgstr ""

#. type: Plain text
#: man-pages/man2/chown.2:48
#, no-wrap
msgid ""
"B<int chown(const char *>I<pathname>B<, uid_t >I<owner>B<, gid_t "
">I<group>B<);>\n"
"B<int fchown(int >I<fd>B<, uid_t >I<owner>B<, gid_t >I<group>B<);>\n"
"B<int lchown(const char *>I<pathname>B<, uid_t >I<owner>B<, gid_t "
">I<group>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/chown.2:54
#, no-wrap
msgid ""
"B<int fchownat(int >I<dirfd>B<, const char *>I<pathname>B<,>\n"
"B<             uid_t >I<owner>B<, gid_t >I<group>B<, int >I<flags>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/chown.2:63
msgid "B<fchown>(), B<lchown>():"
msgstr ""

#.     || _XOPEN_SOURCE\ &&\ _XOPEN_SOURCE_EXTENDED
#. type: Plain text
#: man-pages/man2/chown.2:70
#, no-wrap
msgid ""
"/* Since glibc 2.12: */ _POSIX_C_SOURCE\\ E<gt>=\\ 200809L\n"
"    || _XOPEN_SOURCE\\ E<gt>=\\ 500\n"
"    || /* Glibc versions E<lt>= 2.19: */ _BSD_SOURCE\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/chown.2:73
msgid "B<fchownat>():"
msgstr ""

#. type: Plain text
#: man-pages/man2/chown.2:93
msgid ""
"These system calls change the owner and group of a file.  The B<chown>(), "
"B<fchown>(), and B<lchown>()  system calls differ only in how the file is "
"specified:"
msgstr ""

#. type: Plain text
#: man-pages/man2/chown.2:98
msgid ""
"B<chown>()  changes the ownership of the file specified by I<pathname>, "
"which is dereferenced if it is a symbolic link."
msgstr ""

#. type: Plain text
#: man-pages/man2/chown.2:102
msgid ""
"B<fchown>()  changes the ownership of the file referred to by the open file "
"descriptor I<fd>."
msgstr ""

#. type: Plain text
#: man-pages/man2/chown.2:107
msgid "B<lchown>()  is like B<chown>(), but does not dereference symbolic links."
msgstr ""

#. type: Plain text
#: man-pages/man2/chown.2:116
msgid ""
"Only a privileged process (Linux: one with the B<CAP_CHOWN> capability) may "
"change the owner of a file.  The owner of a file may change the group of the "
"file to any group of which that owner is a member.  A privileged process "
"(Linux: with B<CAP_CHOWN>)  may change the group arbitrarily."
msgstr ""

#. type: Plain text
#: man-pages/man2/chown.2:122
msgid "If the I<owner> or I<group> is specified as -1, then that ID is not changed."
msgstr ""

#.  In Linux 2.0 kernels, superuser was like everyone else
#.  In 2.2, up to 2.2.12, these bits were not cleared for superuser.
#.  Since 2.2.13, superuser is once more like everyone else.
#. type: Plain text
#: man-pages/man2/chown.2:143
msgid ""
"When the owner or group of an executable file is changed by an unprivileged "
"user, the B<S_ISUID> and B<S_ISGID> mode bits are cleared.  POSIX does not "
"specify whether this also should happen when root does the B<chown>(); the "
"Linux behavior depends on the kernel version, and since Linux 2.2.13, root "
"is treated like other users.  In case of a non-group-executable file (i.e., "
"one for which the B<S_IXGRP> bit is not set) the B<S_ISGID> bit indicates "
"mandatory locking, and is not cleared by a B<chown>()."
msgstr ""

#. type: Plain text
#: man-pages/man2/chown.2:147
msgid ""
"When the owner or group of an executable file is changed (by any user), all "
"capability sets for the file are cleared."
msgstr ""

#. type: SS
#: man-pages/man2/chown.2:147
#, no-wrap
msgid "fchownat()"
msgstr ""

#. type: Plain text
#: man-pages/man2/chown.2:153
msgid ""
"The B<fchownat>()  system call operates in exactly the same way as "
"B<chown>(), except for the differences described here."
msgstr ""

#. type: Plain text
#: man-pages/man2/chown.2:163
msgid ""
"If the pathname given in I<pathname> is relative, then it is interpreted "
"relative to the directory referred to by the file descriptor I<dirfd> "
"(rather than relative to the current working directory of the calling "
"process, as is done by B<chown>()  for a relative pathname)."
msgstr ""

#. type: Plain text
#: man-pages/man2/chown.2:175
msgid ""
"If I<pathname> is relative and I<dirfd> is the special value B<AT_FDCWD>, "
"then I<pathname> is interpreted relative to the current working directory of "
"the calling process (like B<chown>())."
msgstr ""

#. type: Plain text
#: man-pages/man2/chown.2:186
msgid ""
"The I<flags> argument is a bit mask created by ORing together 0 or more of "
"the following values;"
msgstr ""

#. type: TP
#: man-pages/man2/chown.2:186 man-pages/man2/stat.2:304
#: man-pages/man2/link.2:125
#, no-wrap
msgid "B<AT_EMPTY_PATH> (since Linux 2.6.39)"
msgstr ""

#.  commit 65cfc6722361570bfe255698d9cd4dccaf47570d
#.  Before glibc 2.16, defining _ATFILE_SOURCE sufficed
#. type: Plain text
#: man-pages/man2/chown.2:209
msgid ""
"If I<pathname> is an empty string, operate on the file referred to by "
"I<dirfd> (which may have been obtained using the B<open>(2)  B<O_PATH> "
"flag).  In this case, I<dirfd> can refer to any type of file, not just a "
"directory.  If I<dirfd> is B<AT_FDCWD>, the call operates on the current "
"working directory.  This flag is Linux-specific; define B<_GNU_SOURCE> to "
"obtain its definition."
msgstr ""

#. type: Plain text
#: man-pages/man2/chown.2:220
msgid ""
"If I<pathname> is a symbolic link, do not dereference it: instead operate on "
"the link itself, like B<lchown>().  (By default, B<fchownat>()  dereferences "
"symbolic links, like B<chown>().)"
msgstr ""

#. type: Plain text
#: man-pages/man2/chown.2:225
msgid "See B<openat>(2)  for an explanation of the need for B<fchownat>()."
msgstr ""

#. type: Plain text
#: man-pages/man2/chown.2:237
msgid "The more general errors for B<chown>()  are listed below."
msgstr ""

#. type: Plain text
#: man-pages/man2/chown.2:267
msgid ""
"The calling process did not have the required permissions (see above) to "
"change owner and/or group."
msgstr ""

#. type: Plain text
#: man-pages/man2/chown.2:279
msgid "The general errors for B<fchown>()  are listed below:"
msgstr ""

#. type: Plain text
#: man-pages/man2/chown.2:283 man-pages/man2/stat.2:391
#: man-pages/man2/fsync.2:122
msgid "I<fd> is not a valid open file descriptor."
msgstr ""

#. type: Plain text
#: man-pages/man2/chown.2:286
msgid "A low-level I/O error occurred while modifying the inode."
msgstr ""

#. type: Plain text
#: man-pages/man2/chown.2:302
msgid ""
"The same errors that occur for B<chown>()  can also occur for "
"B<fchownat>().  The following additional errors can occur for B<fchownat>():"
msgstr ""

#. type: Plain text
#: man-pages/man2/chown.2:320
msgid ""
"B<fchownat>()  was added to Linux in kernel 2.6.16; library support was "
"added to glibc in version 2.4."
msgstr ""

#. type: Plain text
#: man-pages/man2/chown.2:325
msgid ""
"B<chown>(), B<fchown>(), B<lchown>(): 4.4BSD, SVr4, POSIX.1-2001, "
"POSIX.1-2008."
msgstr ""

#.  chown():
#.  SVr4 documents EINVAL, EINTR, ENOLINK and EMULTIHOP returns, but no
#.  ENOMEM.  POSIX.1 does not document ENOMEM or ELOOP error conditions.
#.  fchown():
#.  SVr4 documents additional EINVAL, EIO, EINTR, and ENOLINK
#.  error conditions.
#. type: Plain text
#: man-pages/man2/chown.2:334
msgid ""
"The 4.4BSD version can be used only by the superuser (that is, ordinary "
"users cannot give away files)."
msgstr ""

#. type: Plain text
#: man-pages/man2/chown.2:337
msgid "B<fchownat>(): POSIX.1-2008."
msgstr ""

#. type: SS
#: man-pages/man2/chown.2:338
#, no-wrap
msgid "Ownership of new files"
msgstr ""

#. type: Plain text
#: man-pages/man2/chown.2:360
msgid ""
"When a new file is created (by, for example, B<open>(2)  or B<mkdir>(2)), "
"its owner is made the same as the filesystem user ID of the creating "
"process.  The group of the file depends on a range of factors, including the "
"type of filesystem, the options used to mount the filesystem, and whether or "
"not the set-group-ID mode bit is enabled on the parent directory.  If the "
"filesystem supports the B<-o\\ grpid> (or, synonymously B<-o\\ bsdgroups>)  "
"and B<-o\\ nogrpid> (or, synonymously B<-o\\ sysvgroups>)  B<mount>(8)  "
"options, then the rules are as follows:"
msgstr ""

#. type: Plain text
#: man-pages/man2/chown.2:365
msgid ""
"If the filesystem is mounted with B<-o\\ grpid>, then the group of a new "
"file is made the same as that of the parent directory."
msgstr ""

#. type: Plain text
#: man-pages/man2/chown.2:371
msgid ""
"If the filesystem is mounted with B<-o\\ nogrpid> and the set-group-ID bit "
"is disabled on the parent directory, then the group of a new file is made "
"the same as the process's filesystem GID."
msgstr ""

#. type: Plain text
#: man-pages/man2/chown.2:377
msgid ""
"If the filesystem is mounted with B<-o\\ nogrpid> and the set-group-ID bit "
"is enabled on the parent directory, then the group of a new file is made the "
"same as that of the parent directory."
msgstr ""

#. type: Plain text
#: man-pages/man2/chown.2:387
msgid ""
"As at Linux 4.12, the B<-o\\ grpid> and B<-o\\ nogrpid> mount options are "
"supported by ext2, ext3, ext4, and XFS.  Filesystems that don't support "
"these mount options follow the B<-o\\ nogrpid> rules."
msgstr ""

#. type: Plain text
#: man-pages/man2/chown.2:402
msgid ""
"On older kernels where B<fchownat>()  is unavailable, the glibc wrapper "
"function falls back to the use of B<chown>()  and B<lchown>().  When "
"I<pathname> is a relative pathname, glibc constructs a pathname based on the "
"symbolic link in I</proc/self/fd> that corresponds to the I<dirfd> argument."
msgstr ""

#. type: Plain text
#: man-pages/man2/chown.2:415
msgid ""
"The B<chown>()  semantics are deliberately violated on NFS filesystems which "
"have UID mapping enabled.  Additionally, the semantics of all system calls "
"which access the file contents are violated, because B<chown>()  may cause "
"immediate access revocation on already open files.  Client side caching may "
"lead to a delay between the time where ownership have been changed to allow "
"access for a user and the time where the file can actually be accessed by "
"the user on other clients."
msgstr ""

#. type: SS
#: man-pages/man2/chown.2:415 man-pages/man2/umount.2:212
#, no-wrap
msgid "Historical details"
msgstr ""

#. type: Plain text
#: man-pages/man2/chown.2:434
msgid ""
"The original Linux B<chown>(), B<fchown>(), and B<lchown>()  system calls "
"supported only 16-bit user and group IDs.  Subsequently, Linux 2.4 added "
"B<chown32>(), B<fchown32>(), and B<lchown32>(), supporting 32-bit IDs.  The "
"glibc B<chown>(), B<fchown>(), and B<lchown>()  wrapper functions "
"transparently deal with the variations across kernel versions."
msgstr ""

#. type: Plain text
#: man-pages/man2/chown.2:449
msgid ""
"In versions of Linux prior to 2.1.81 (and distinct from 2.1.46), B<chown>()  "
"did not follow symbolic links.  Since Linux 2.1.81, B<chown>()  does follow "
"symbolic links, and there is a new system call B<lchown>()  that does not "
"follow symbolic links.  Since Linux 2.1.86, this new call (that has the same "
"semantics as the old B<chown>())  has got the same syscall number, and "
"B<chown>()  got the newly introduced number."
msgstr ""

#. type: Plain text
#: man-pages/man2/chown.2:458
msgid ""
"The following program changes the ownership of the file named in its second "
"command-line argument to the value specified in its first command-line "
"argument.  The new owner can be specified either as a numeric user ID, or as "
"a username (which is converted to a user ID by using B<getpwnam>(3)  to "
"perform a lookup in the system password file)."
msgstr ""

#. type: Plain text
#: man-pages/man2/chown.2:464
#, no-wrap
msgid ""
"#include E<lt>pwd.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/chown.2:471
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    uid_t uid;\n"
"    struct passwd *pwd;\n"
"    char *endptr;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/chown.2:476
#, no-wrap
msgid ""
"    if (argc != 3 || argv[1][0] == \\(aq\\e0\\(aq) {\n"
"        fprintf(stderr, \"%s E<lt>ownerE<gt> E<lt>fileE<gt>\\en\", "
"argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/chown.2:478
#, no-wrap
msgid "    uid = strtol(argv[1], &endptr, 10);  /* Allow a numeric string */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/chown.2:485
#, no-wrap
msgid ""
"    if (*endptr != \\(aq\\e0\\(aq) {         /* Was not pure numeric string "
"*/\n"
"        pwd = getpwnam(argv[1]);   /* Try getting UID for username */\n"
"        if (pwd == NULL) {\n"
"            perror(\"getpwnam\");\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/chown.2:488
#, no-wrap
msgid ""
"        uid = pwd-E<gt>pw_uid;\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/chown.2:493
#, no-wrap
msgid ""
"    if (chown(argv[2], uid, -1) == -1) {\n"
"        perror(\"chown\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/chown.2:503
msgid ""
"B<chgrp>(1), B<chown>(1), B<chmod>(2), B<flock>(2), B<path_resolution>(7), "
"B<symlink>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/madvise.2:35
#, no-wrap
msgid "MADVISE"
msgstr ""

#. type: Plain text
#: man-pages/man2/madvise.2:38
msgid "madvise - give advice about use of memory"
msgstr ""

#. type: Plain text
#: man-pages/man2/madvise.2:42
msgid "B<int madvise(void *>I<addr>B<, size_t >I<length>B<, int >I<advice>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/madvise.2:49
msgid "B<madvise>():"
msgstr ""

#. type: Plain text
#: man-pages/man2/madvise.2:54
msgid "_DEFAULT_SOURCE"
msgstr ""

#. type: TP
#: man-pages/man2/madvise.2:54
#, no-wrap
msgid "Up to and including glibc 2.19:"
msgstr ""

#. type: Plain text
#: man-pages/man2/madvise.2:57
msgid "_BSD_SOURCE"
msgstr ""

#. type: Plain text
#: man-pages/man2/madvise.2:70
msgid ""
"The B<madvise>()  system call is used to give advice or directions to the "
"kernel about the address range beginning at address I<addr> and with size "
"I<length> bytes In most cases, the goal of such advice is to improve system "
"or application performance."
msgstr ""

#
#.  ======================================================================
#. type: Plain text
#: man-pages/man2/madvise.2:83
msgid ""
"Initially, the system call supported a set of \"conventional\" I<advice> "
"values, which are also available on several other implementations.  (Note, "
"though, that B<madvise>()  is not specified in POSIX.)  Subsequently, a "
"number of Linux-specific I<advice> values have been added."
msgstr ""

#. type: SS
#: man-pages/man2/madvise.2:83
#, no-wrap
msgid "Conventional advice values"
msgstr ""

#. type: Plain text
#: man-pages/man2/madvise.2:102
msgid ""
"The I<advice> values listed below allow an application to tell the kernel "
"how it expects to use some mapped or shared memory areas, so that the kernel "
"can choose appropriate read-ahead and caching techniques.  These I<advice> "
"values do not influence the semantics of the application (except in the case "
"of B<MADV_DONTNEED>), but may influence its performance.  All of the "
"I<advice> values listed here have analogs in the POSIX-specified "
"B<posix_madvise>(3)  function, and the values have the same meanings, with "
"the exception of B<MADV_DONTNEED>."
msgstr ""

#. type: Plain text
#: man-pages/man2/madvise.2:106
msgid ""
"The advice is indicated in the I<advice> argument, which is one of the "
"following:"
msgstr ""

#. type: TP
#: man-pages/man2/madvise.2:106
#, no-wrap
msgid "B<MADV_NORMAL>"
msgstr ""

#. type: Plain text
#: man-pages/man2/madvise.2:110
msgid "No special treatment.  This is the default."
msgstr ""

#. type: TP
#: man-pages/man2/madvise.2:110
#, no-wrap
msgid "B<MADV_RANDOM>"
msgstr ""

#. type: Plain text
#: man-pages/man2/madvise.2:114
msgid ""
"Expect page references in random order.  (Hence, read ahead may be less "
"useful than normally.)"
msgstr ""

#. type: TP
#: man-pages/man2/madvise.2:114
#, no-wrap
msgid "B<MADV_SEQUENTIAL>"
msgstr ""

#. type: Plain text
#: man-pages/man2/madvise.2:119
msgid ""
"Expect page references in sequential order.  (Hence, pages in the given "
"range can be aggressively read ahead, and may be freed soon after they are "
"accessed.)"
msgstr ""

#. type: TP
#: man-pages/man2/madvise.2:119
#, no-wrap
msgid "B<MADV_WILLNEED>"
msgstr ""

#. type: Plain text
#: man-pages/man2/madvise.2:123
msgid ""
"Expect access in the near future.  (Hence, it might be a good idea to read "
"some pages ahead.)"
msgstr ""

#. type: TP
#: man-pages/man2/madvise.2:123
#, no-wrap
msgid "B<MADV_DONTNEED>"
msgstr ""

#. type: Plain text
#: man-pages/man2/madvise.2:128
msgid ""
"Do not expect access in the near future.  (For the time being, the "
"application is finished with the given range, so the kernel can free "
"resources associated with it.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/madvise.2:139
msgid ""
"After a successful B<MADV_DONTNEED> operation, the semantics of memory "
"access in the specified region are changed: subsequent accesses of pages in "
"the range will succeed, but will result in either repopulating the memory "
"contents from the up-to-date contents of the underlying mapped file (for "
"shared file mappings, shared anonymous mappings, and shmem-based techniques "
"such as System V shared memory segments)  or zero-fill-on-demand pages for "
"anonymous private mappings."
msgstr ""

#. type: Plain text
#: man-pages/man2/madvise.2:146
msgid ""
"Note that, when applied to shared mappings, B<MADV_DONTNEED> might not lead "
"to immediate freeing of the pages in the range.  The kernel is free to delay "
"freeing the pages until an appropriate moment.  The resident set size (RSS) "
"of the calling process will be immediately reduced however."
msgstr ""

#.  http://lwn.net/Articles/162860/
#
#.  ======================================================================
#. type: Plain text
#: man-pages/man2/madvise.2:161
msgid ""
"B<MADV_DONTNEED> cannot be applied to locked pages, Huge TLB pages, or "
"B<VM_PFNMAP> pages.  (Pages marked with the kernel-internal B<VM_PFNMAP> "
"flag are special memory areas that are not managed by the virtual memory "
"subsystem.  Such pages are typically created by device drivers that map the "
"pages into user space.)"
msgstr ""

#. type: SS
#: man-pages/man2/madvise.2:161
#, no-wrap
msgid "Linux-specific advice values"
msgstr ""

#. type: Plain text
#: man-pages/man2/madvise.2:170
msgid ""
"The following Linux-specific I<advice> values have no counterparts in the "
"POSIX-specified B<posix_madvise>(3), and may or may not have counterparts in "
"the B<madvise>()  interface available on other implementations.  Note that "
"some of these operations change the semantics of memory accesses."
msgstr ""

#. type: TP
#: man-pages/man2/madvise.2:170
#, no-wrap
msgid "B<MADV_REMOVE> (since Linux 2.6.16)"
msgstr ""

#.  commit f6b3ec238d12c8cc6cc71490c6e3127988460349
#.  Databases want to use this feature to drop a section of their
#.  bufferpool (shared memory segments) - without writing back to
#.  disk/swap space.  This feature is also useful for supporting
#.  hot-plug memory on UML.
#. type: Plain text
#: man-pages/man2/madvise.2:184
msgid ""
"Free up a given range of pages and its associated backing store.  This is "
"equivalent to punching a hole in the corresponding byte range of the backing "
"store (see B<fallocate>(2)).  Subsequent accesses in the specified address "
"range will see bytes containing zero."
msgstr ""

#. type: Plain text
#: man-pages/man2/madvise.2:189
msgid ""
"The specified address range must be mapped shared and writable.  This flag "
"cannot be applied to locked pages, Huge TLB pages, or B<VM_PFNMAP> pages."
msgstr ""

#.  commit 3f31d07571eeea18a7d34db9af21d2285b807a17
#. type: Plain text
#: man-pages/man2/madvise.2:205
msgid ""
"In the initial implementation, only B<tmpfs>(5)  was supported "
"B<MADV_REMOVE>; but since Linux 3.5, any filesystem which supports the "
"B<fallocate>(2)  B<FALLOC_FL_PUNCH_HOLE> mode also supports B<MADV_REMOVE>.  "
"Hugetlbfs fails with the error B<EINVAL> and other filesystems fail with the "
"error B<EOPNOTSUPP>."
msgstr ""

#. type: TP
#: man-pages/man2/madvise.2:205
#, no-wrap
msgid "B<MADV_DONTFORK> (since Linux 2.6.16)"
msgstr ""

#.  commit f822566165dd46ff5de9bf895cfa6c51f53bb0c4
#.  See http://lwn.net/Articles/171941/
#.  [PATCH] madvise MADV_DONTFORK/MADV_DOFORK
#.  Currently, copy-on-write may change the physical address of
#.  a page even if the user requested that the page is pinned in
#.  memory (either by mlock or by get_user_pages).  This happens
#.  if the process forks meanwhile, and the parent writes to that
#.  page.  As a result, the page is orphaned: in case of
#.  get_user_pages, the application will never see any data hardware
#.  DMA's into this page after the COW.  In case of mlock'd memory,
#.  the parent is not getting the realtime/security benefits of mlock.
#
#.  In particular, this affects the Infiniband modules which do DMA from
#.  and into user pages all the time.
#
#.  This patch adds madvise options to control whether memory range is
#.  inherited across fork. Useful e.g. for when hardware is doing DMA
#.  from/into these pages.  Could also be useful to an application
#.  wanting to speed up its forks by cutting large areas out of
#.  consideration.
#
#.  SEE ALSO: http://lwn.net/Articles/171941/
#.  "Tweaks to madvise() and posix_fadvise()", 14 Feb 2006
#. type: Plain text
#: man-pages/man2/madvise.2:237
msgid ""
"Do not make the pages in this range available to the child after a "
"B<fork>(2).  This is useful to prevent copy-on-write semantics from changing "
"the physical location of a page if the parent writes to it after a "
"B<fork>(2).  (Such page relocations cause problems for hardware that DMAs "
"into the page.)"
msgstr ""

#. type: TP
#: man-pages/man2/madvise.2:237
#, no-wrap
msgid "B<MADV_DOFORK> (since Linux 2.6.16)"
msgstr ""

#. type: Plain text
#: man-pages/man2/madvise.2:243
msgid ""
"Undo the effect of B<MADV_DONTFORK>, restoring the default behavior, whereby "
"a mapping is inherited across B<fork>(2)."
msgstr ""

#. type: TP
#: man-pages/man2/madvise.2:243
#, no-wrap
msgid "B<MADV_HWPOISON> (since Linux 2.6.32)"
msgstr ""

#.  commit 9893e49d64a4874ea67849ee2cfbf3f3d6817573
#. type: Plain text
#: man-pages/man2/madvise.2:258
msgid ""
"Poison the pages in the range specified by I<addr> and I<length> and handle "
"subsequent references to those pages like a hardware memory corruption.  "
"This operation is available only for privileged (B<CAP_SYS_ADMIN>)  "
"processes.  This operation may result in the calling process receiving a "
"B<SIGBUS> and the page being unmapped."
msgstr ""

#. type: Plain text
#: man-pages/man2/madvise.2:262 man-pages/man2/madvise.2:319
msgid ""
"This feature is intended for testing of memory error-handling code; it is "
"available only if the kernel was configured with B<CONFIG_MEMORY_FAILURE>."
msgstr ""

#. type: TP
#: man-pages/man2/madvise.2:262
#, no-wrap
msgid "B<MADV_MERGEABLE> (since Linux 2.6.32)"
msgstr ""

#.  commit f8af4da3b4c14e7267c4ffb952079af3912c51c5
#. type: Plain text
#: man-pages/man2/madvise.2:276
msgid ""
"Enable Kernel Samepage Merging (KSM) for the pages in the range specified by "
"I<addr> and I<length>.  The kernel regularly scans those areas of user "
"memory that have been marked as mergeable, looking for pages with identical "
"content.  These are replaced by a single write-protected page (which is "
"automatically copied if a process later wants to update the content of the "
"page).  KSM merges only private anonymous pages (see B<mmap>(2))."
msgstr ""

#. type: Plain text
#: man-pages/man2/madvise.2:283
msgid ""
"The KSM feature is intended for applications that generate many instances of "
"the same data (e.g., virtualization systems such as KVM).  It can consume a "
"lot of processing power; use with care.  See the Linux kernel source file "
"I<Documentation/admin-guide/mm/ksm.rst> for more details."
msgstr ""

#. type: Plain text
#: man-pages/man2/madvise.2:290
msgid ""
"The B<MADV_MERGEABLE> and B<MADV_UNMERGEABLE> operations are available only "
"if the kernel was configured with B<CONFIG_KSM>."
msgstr ""

#. type: TP
#: man-pages/man2/madvise.2:290
#, no-wrap
msgid "B<MADV_UNMERGEABLE> (since Linux 2.6.32)"
msgstr ""

#. type: Plain text
#: man-pages/man2/madvise.2:299
msgid ""
"Undo the effect of an earlier B<MADV_MERGEABLE> operation on the specified "
"address range; KSM unmerges whatever pages it had merged in the address "
"range specified by I<addr> and I<length>."
msgstr ""

#. type: TP
#: man-pages/man2/madvise.2:299
#, no-wrap
msgid "B<MADV_SOFT_OFFLINE> (since Linux 2.6.33)"
msgstr ""

#.  commit afcf938ee0aac4ef95b1a23bac704c6fbeb26de6
#. type: Plain text
#: man-pages/man2/madvise.2:315
msgid ""
"Soft offline the pages in the range specified by I<addr> and I<length>.  The "
"memory of each page in the specified range is preserved (i.e., when next "
"accessed, the same content will be visible, but in a new physical page "
"frame), and the original page is offlined (i.e., no longer used, and taken "
"out of normal memory management).  The effect of the B<MADV_SOFT_OFFLINE> "
"operation is invisible to (i.e., does not change the semantics of)  the "
"calling process."
msgstr ""

#. type: TP
#: man-pages/man2/madvise.2:319
#, no-wrap
msgid "B<MADV_HUGEPAGE> (since Linux 2.6.38)"
msgstr ""

#.  commit 0af4e98b6b095c74588af04872f83d333c958c32
#.  http://lwn.net/Articles/358904/
#.  https://lwn.net/Articles/423584/
#. type: Plain text
#: man-pages/man2/madvise.2:335
msgid ""
"Enable Transparent Huge Pages (THP) for pages in the range specified by "
"I<addr> and I<length>.  Currently, Transparent Huge Pages work only with "
"private anonymous pages (see B<mmap>(2)).  The kernel will regularly scan "
"the areas marked as huge page candidates to replace them with huge pages.  "
"The kernel will also allocate huge pages directly when the region is "
"naturally aligned to the huge page size (see B<posix_memalign>(2))."
msgstr ""

#. type: Plain text
#: man-pages/man2/madvise.2:344
msgid ""
"This feature is primarily aimed at applications that use large mappings of "
"data and access large regions of that memory at a time (e.g., virtualization "
"systems such as QEMU).  It can very easily waste memory (e.g., a 2\\ MB "
"mapping that only ever accesses 1 byte will result in 2\\ MB of wired memory "
"instead of one 4\\ KB page).  See the Linux kernel source file "
"I<Documentation/admin-guide/mm/transhuge.rst> for more details."
msgstr ""

#. type: Plain text
#: man-pages/man2/madvise.2:351
msgid ""
"The B<MADV_HUGEPAGE> and B<MADV_NOHUGEPAGE> operations are available only if "
"the kernel was configured with B<CONFIG_TRANSPARENT_HUGEPAGE>."
msgstr ""

#. type: TP
#: man-pages/man2/madvise.2:351
#, no-wrap
msgid "B<MADV_NOHUGEPAGE> (since Linux 2.6.38)"
msgstr ""

#. type: Plain text
#: man-pages/man2/madvise.2:358
msgid ""
"Ensures that memory in the address range specified by I<addr> and I<length> "
"will not be collapsed into huge pages."
msgstr ""

#. type: TP
#: man-pages/man2/madvise.2:358
#, no-wrap
msgid "B<MADV_DONTDUMP> (since Linux 3.4)"
msgstr ""

#.  commit 909af768e88867016f427264ae39d27a57b6a8ed
#.  commit accb61fe7bb0f5c2a4102239e4981650f9048519
#. type: Plain text
#: man-pages/man2/madvise.2:374
msgid ""
"Exclude from a core dump those pages in the range specified by I<addr> and "
"I<length>.  This is useful in applications that have large areas of memory "
"that are known not to be useful in a core dump.  The effect of "
"B<MADV_DONTDUMP> takes precedence over the bit mask that is set via the "
"I</proc/[pid]/coredump_filter> file (see B<core>(5))."
msgstr ""

#. type: TP
#: man-pages/man2/madvise.2:374
#, no-wrap
msgid "B<MADV_DODUMP> (since Linux 3.4)"
msgstr ""

#. type: Plain text
#: man-pages/man2/madvise.2:378
msgid "Undo the effect of an earlier B<MADV_DONTDUMP>."
msgstr ""

#. type: TP
#: man-pages/man2/madvise.2:378
#, no-wrap
msgid "B<MADV_FREE> (since Linux 4.5)"
msgstr ""

#. type: Plain text
#: man-pages/man2/madvise.2:400
msgid ""
"The application no longer requires the pages in the range specified by "
"I<addr> and I<len>.  The kernel can thus free these pages, but the freeing "
"could be delayed until memory pressure occurs.  For each of the pages that "
"has been marked to be freed but has not yet been freed, the free operation "
"will be canceled if the caller writes into the page.  After a successful "
"B<MADV_FREE> operation, any stale data (i.e., dirty, unwritten pages) will "
"be lost when the kernel frees the pages.  However, subsequent writes to "
"pages in the range will succeed and then kernel cannot free those dirtied "
"pages, so that the caller can always see just written data.  If there is no "
"subsequent write, the kernel can free the pages at any time.  Once pages in "
"the range have been freed, the caller will see zero-fill-on-demand pages "
"upon subsequent page references."
msgstr ""

#.  commit 93e06c7a645343d222c9a838834a51042eebbbf7
#. type: Plain text
#: man-pages/man2/madvise.2:411
msgid ""
"The B<MADV_FREE> operation can be applied only to private anonymous pages "
"(see B<mmap>(2)).  In Linux before version 4.12, when freeing pages on a "
"swapless system, the pages in the given range are freed instantly, "
"regardless of memory pressure."
msgstr ""

#. type: TP
#: man-pages/man2/madvise.2:411
#, no-wrap
msgid "B<MADV_WIPEONFORK> (since Linux 4.14)"
msgstr ""

#.  commit d2cd9ede6e193dd7d88b6d27399e96229a551b19
#. type: Plain text
#: man-pages/man2/madvise.2:420
msgid ""
"Present the child process with zero-filled memory in this range after a "
"B<fork>(2).  This is useful in forking servers in order to ensure that "
"sensitive per-process data (for example, PRNG seeds, cryptographic secrets, "
"and so on)  is not handed to child processes."
msgstr ""

#. type: Plain text
#: man-pages/man2/madvise.2:425
msgid ""
"The B<MADV_WIPEONFORK> operation can be applied only to private anonymous "
"pages (see B<mmap>(2))."
msgstr ""

#. type: Plain text
#: man-pages/man2/madvise.2:433
msgid ""
"Within the child created by B<fork>(2), the B<MADV_WIPEONFORK> setting "
"remains in place on the specified address range.  This setting is cleared "
"during B<execve>(2)."
msgstr ""

#. type: TP
#: man-pages/man2/madvise.2:433
#, no-wrap
msgid "B<MADV_KEEPONFORK> (since Linux 4.14)"
msgstr ""

#.  commit d2cd9ede6e193dd7d88b6d27399e96229a551b19
#. type: Plain text
#: man-pages/man2/madvise.2:438
msgid "Undo the effect of an earlier B<MADV_WIPEONFORK>."
msgstr ""

#. type: Plain text
#: man-pages/man2/madvise.2:445
msgid ""
"On success, B<madvise>()  returns zero.  On error, it returns -1 and "
"I<errno> is set appropriately."
msgstr ""

#. type: Plain text
#: man-pages/man2/madvise.2:452
msgid ""
"I<advice> is B<MADV_REMOVE>, but the specified address range is not a shared "
"writable mapping."
msgstr ""

#. type: Plain text
#: man-pages/man2/madvise.2:455
msgid "A kernel resource was temporarily unavailable."
msgstr ""

#. type: Plain text
#: man-pages/man2/madvise.2:458
msgid "The map exists, but the area maps something that isn't a file."
msgstr ""

#.  .I length
#.  is zero,
#. type: Plain text
#: man-pages/man2/madvise.2:466
msgid "I<addr> is not page-aligned or I<length> is negative."
msgstr ""

#. type: Plain text
#: man-pages/man2/madvise.2:470
msgid "I<advice> is not a valid."
msgstr ""

#. type: Plain text
#: man-pages/man2/madvise.2:480
msgid ""
"I<advice> is B<MADV_DONTNEED> or B<MADV_REMOVE> and the specified address "
"range includes locked, Huge TLB pages, or B<VM_PFNMAP> pages."
msgstr ""

#. type: Plain text
#: man-pages/man2/madvise.2:489
msgid ""
"I<advice> is B<MADV_MERGEABLE> or B<MADV_UNMERGEABLE>, but the kernel was "
"not configured with B<CONFIG_KSM>."
msgstr ""

#. type: Plain text
#: man-pages/man2/madvise.2:501
msgid ""
"I<advice> is B<MADV_FREE> or B<MADV_WIPEONFORK> but the specified address "
"range includes file, Huge TLB, B<MAP_SHARED>, or B<VM_PFNMAP> ranges."
msgstr ""

#. type: Plain text
#: man-pages/man2/madvise.2:507
msgid ""
"(for B<MADV_WILLNEED>)  Paging in this area would exceed the process's "
"maximum resident set size."
msgstr ""

#. type: Plain text
#: man-pages/man2/madvise.2:512
msgid "(for B<MADV_WILLNEED>)  Not enough memory: paging in failed."
msgstr ""

#. type: Plain text
#: man-pages/man2/madvise.2:516
msgid ""
"Addresses in the specified range are not currently mapped, or are outside "
"the address space of the process."
msgstr ""

#. type: Plain text
#: man-pages/man2/madvise.2:524
msgid ""
"I<advice> is B<MADV_HWPOISON>, but the caller does not have the "
"B<CAP_SYS_ADMIN> capability."
msgstr ""

#.  commit d3ac21cacc24790eb45d735769f35753f5b56ceb
#. type: Plain text
#: man-pages/man2/madvise.2:531
msgid ""
"Since Linux 3.18, support for this system call is optional, depending on the "
"setting of the B<CONFIG_ADVISE_SYSCALLS> configuration option."
msgstr ""

#. type: Plain text
#: man-pages/man2/madvise.2:541
msgid ""
"B<madvise>()  is not specified by any standards.  Versions of this system "
"call, implementing a wide variety of I<advice> values, exist on many other "
"implementations.  Other implementations typically implement at least the "
"flags listed above under I<Conventional advice flags>, albeit with some "
"variation in semantics."
msgstr ""

#. type: Plain text
#: man-pages/man2/madvise.2:552
msgid ""
"POSIX.1-2001 describes B<posix_madvise>(3)  with constants "
"B<POSIX_MADV_NORMAL>, B<POSIX_MADV_RANDOM>, B<POSIX_MADV_SEQUENTIAL>, "
"B<POSIX_MADV_WILLNEED>, and B<POSIX_MADV_DONTNEED>, and so on, with behavior "
"close to the similarly named flags listed above."
msgstr ""

#.  .SH HISTORY
#.  The
#.  .BR madvise ()
#.  function first appeared in 4.4BSD.
#. type: Plain text
#: man-pages/man2/madvise.2:569
msgid ""
"The Linux implementation requires that the address I<addr> be page-aligned, "
"and allows I<length> to be zero.  If there are some parts of the specified "
"address range that are not mapped, the Linux version of B<madvise>()  "
"ignores them and applies the call to the rest (but returns B<ENOMEM> from "
"the system call, as it should)."
msgstr ""

#. type: Plain text
#: man-pages/man2/madvise.2:578
msgid ""
"B<getrlimit>(2), B<mincore>(2), B<mmap>(2), B<mprotect>(2), B<msync>(2), "
"B<munmap>(2), B<prctl>(2), B<posix_madvise>(3), B<core>(5)"
msgstr ""

#. type: TH
#: man-pages/man2/sched_setattr.2:26
#, no-wrap
msgid "SCHED_SETATTR"
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_setattr.2:30
msgid "sched_setattr, sched_getattr - set and get scheduling policy and attributes"
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_setattr.2:36
#, no-wrap
msgid ""
"B<int sched_setattr(pid_t >I<pid>B<, struct sched_attr *>I<attr>B<,>\n"
"B<                  unsigned int >I<flags>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_setattr.2:39
#, no-wrap
msgid ""
"B<int sched_getattr(pid_t >I<pid>B<, struct sched_attr *>I<attr>B<,>\n"
"B<                  unsigned int >I<size>B<, unsigned int >I<flags>B<);>\n"
msgstr ""

#. type: SS
#: man-pages/man2/sched_setattr.2:42
#, no-wrap
msgid "sched_setattr()"
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_setattr.2:52
msgid ""
"The B<sched_setattr>()  system call sets the scheduling policy and "
"associated attributes for the thread whose ID is specified in I<pid>.  If "
"I<pid> equals zero, the scheduling policy and attributes of the calling "
"thread will be set."
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_setattr.2:86
msgid "Linux also provides the following policy:"
msgstr ""

#. type: TP
#: man-pages/man2/sched_setattr.2:86
#, no-wrap
msgid "B<SCHED_DEADLINE>"
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_setattr.2:91
msgid "a deadline scheduling policy; see B<sched>(7)  for details."
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_setattr.2:97
msgid ""
"The I<attr> argument is a pointer to a structure that defines the new "
"scheduling policy and attributes for the specified thread.  This structure "
"has the following form:"
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_setattr.2:113
#, no-wrap
msgid ""
"struct sched_attr {\n"
"    u32 size;              /* Size of this structure */\n"
"    u32 sched_policy;      /* Policy (SCHED_*) */\n"
"    u64 sched_flags;       /* Flags */\n"
"    s32 sched_nice;        /* Nice value (SCHED_OTHER,\n"
"                              SCHED_BATCH) */\n"
"    u32 sched_priority;    /* Static priority (SCHED_FIFO,\n"
"                              SCHED_RR) */\n"
"    /* Remaining fields are for SCHED_DEADLINE */\n"
"    u64 sched_runtime;\n"
"    u64 sched_deadline;\n"
"    u64 sched_period;\n"
"};\n"
msgstr ""

#. type: TP
#: man-pages/man2/sched_setattr.2:117
#, no-wrap
msgid "B<size>"
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_setattr.2:132
msgid ""
"This field should be set to the size of the structure in bytes, as in "
"I<sizeof(struct sched_attr)>.  If the provided structure is smaller than the "
"kernel structure, any additional fields are assumed to be '0'.  If the "
"provided structure is larger than the kernel structure, the kernel verifies "
"that all additional fields are 0; if they are not, B<sched_setattr>()  fails "
"with the error B<E2BIG> and updates I<size> to contain the size of the "
"kernel structure."
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_setattr.2:146
msgid ""
"The above behavior when the size of the user-space I<sched_attr> structure "
"does not match the size of the kernel structure allows for future "
"extensibility of the interface.  Malformed applications that pass oversize "
"structures won't break in the future if the size of the kernel I<sched_attr> "
"structure is increased.  In the future, it could also allow applications "
"that know about a larger user-space I<sched_attr> structure to determine "
"whether they are running on an older kernel that does not support the larger "
"structure."
msgstr ""

#. type: TP
#: man-pages/man2/sched_setattr.2:146
#, no-wrap
msgid "I<sched_policy>"
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_setattr.2:151
msgid ""
"This field specifies the scheduling policy, as one of the B<SCHED_*> values "
"listed above."
msgstr ""

#. type: TP
#: man-pages/man2/sched_setattr.2:151
#, no-wrap
msgid "I<sched_flags>"
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_setattr.2:155
msgid ""
"This field contains zero or more of the following flags that are ORed "
"together to control scheduling behavior:"
msgstr ""

#. type: TP
#: man-pages/man2/sched_setattr.2:156
#, no-wrap
msgid "B<SCHED_FLAG_RESET_ON_FORK>"
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_setattr.2:164
msgid ""
"Children created by B<fork>(2)  do not inherit privileged scheduling "
"policies.  See B<sched>(7)  for details."
msgstr ""

#. type: TP
#: man-pages/man2/sched_setattr.2:164
#, no-wrap
msgid "B<SCHED_FLAG_RECLAIM> (since Linux 4.13)"
msgstr ""

#.  2d4283e9d583a3ee8cfb1cbb9c1270614df4c29d
#.  Bandwidth reclaim is done via the GRUB algorithm; see
#.  Documentation/scheduler/sched-deadline.txt
#. type: Plain text
#: man-pages/man2/sched_setattr.2:172
msgid ""
"This flag allows a B<SCHED_DEADLINE> thread to reclaim bandwidth unused by "
"other real-time threads."
msgstr ""

#. type: TP
#: man-pages/man2/sched_setattr.2:172
#, no-wrap
msgid "B<SCHED_FLAG_DL_OVERRUN> (since Linux 4.16)"
msgstr ""

#.  commit 34be39305a77b8b1ec9f279163c7cdb6cc719b91
#. type: Plain text
#: man-pages/man2/sched_setattr.2:183
msgid ""
"This flag allows an application to get informed about run-time overruns in "
"B<SCHED_DEADLINE> threads.  Such overruns may be caused by (for example) "
"coarse execution time accounting or incorrect parameter assignment.  "
"Notification takes the form of a B<SIGXCPU> signal which is generated on "
"each overrun."
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_setattr.2:198
msgid ""
"This B<SIGXCPU> signal is I<process-directed> (see B<signal>(7))  rather "
"than thread-directed.  This is probably a bug.  On the one hand, "
"B<sched_setattr>()  is being used to set a per-thread attribute.  On the "
"other hand, if the process-directed signal is delivered to a thread inside "
"the process other than the one that had a run-time overrun, the application "
"has no way of knowing which thread overran."
msgstr ""

#. type: TP
#: man-pages/man2/sched_setattr.2:199
#, no-wrap
msgid "I<sched_nice>"
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_setattr.2:210
msgid ""
"This field specifies the nice value to be set when specifying "
"I<sched_policy> as B<SCHED_OTHER> or B<SCHED_BATCH>.  The nice value is a "
"number in the range -20 (high priority)  to +19 (low priority); see "
"B<sched>(7)."
msgstr ""

#. type: TP
#: man-pages/man2/sched_setattr.2:210
#, no-wrap
msgid "I<sched_priority>"
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_setattr.2:223
msgid ""
"This field specifies the static priority to be set when specifying "
"I<sched_policy> as B<SCHED_FIFO> or B<SCHED_RR>.  The allowed range of "
"priorities for these policies can be determined using "
"B<sched_get_priority_min>(2)  and B<sched_get_priority_max>(2).  For other "
"policies, this field must be specified as 0."
msgstr ""

#. type: TP
#: man-pages/man2/sched_setattr.2:223
#, no-wrap
msgid "I<sched_runtime>"
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_setattr.2:232
msgid ""
"This field specifies the \"Runtime\" parameter for deadline scheduling.  The "
"value is expressed in nanoseconds.  This field, and the next two fields, are "
"used only for B<SCHED_DEADLINE> scheduling; for further details, see "
"B<sched>(7)."
msgstr ""

#. type: TP
#: man-pages/man2/sched_setattr.2:232
#, no-wrap
msgid "I<sched_deadline>"
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_setattr.2:236
msgid ""
"This field specifies the \"Deadline\" parameter for deadline scheduling.  "
"The value is expressed in nanoseconds."
msgstr ""

#. type: TP
#: man-pages/man2/sched_setattr.2:236
#, no-wrap
msgid "I<sched_period>"
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_setattr.2:240
msgid ""
"This field specifies the \"Period\" parameter for deadline scheduling.  The "
"value is expressed in nanoseconds."
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_setattr.2:247 man-pages/man2/sched_setattr.2:299
msgid ""
"The I<flags> argument is provided to allow for future extensions to the "
"interface; in the current implementation it must be specified as 0."
msgstr ""

#. type: SS
#: man-pages/man2/sched_setattr.2:247
#, no-wrap
msgid "sched_getattr()"
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_setattr.2:258
msgid ""
"The B<sched_getattr>()  system call fetches the scheduling policy and the "
"associated attributes for the thread whose ID is specified in I<pid>.  If "
"I<pid> equals zero, the scheduling policy and attributes of the calling "
"thread will be retrieved."
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_setattr.2:268
msgid ""
"The I<size> argument should be set to the size of the I<sched_attr> "
"structure as known to user space.  The value must be at least as large as "
"the size of the initially published I<sched_attr> structure, or the call "
"fails with the error B<EINVAL>."
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_setattr.2:278
msgid ""
"The retrieved scheduling attributes are placed in the fields of the "
"I<sched_attr> structure pointed to by I<attr>.  The kernel sets I<attr.size> "
"to the size of its I<sched_attr> structure."
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_setattr.2:294
msgid ""
"If the caller-provided I<attr> buffer is larger than the kernel's "
"I<sched_attr> structure, the additional bytes in the user-space structure "
"are not touched.  If the caller-provided structure is smaller than the "
"kernel I<sched_attr> structure and the kernel needs to return values outside "
"the provided space, B<sched_getattr>()  fails with the error B<E2BIG>.  As "
"with B<sched_setattr>(), these semantics allow for future extensibility of "
"the interface."
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_setattr.2:308
msgid ""
"On success, B<sched_setattr>()  and B<sched_getattr>()  return 0.  On error, "
"-1 is returned, and I<errno> is set to indicate the cause of the error."
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_setattr.2:313
msgid ""
"B<sched_getattr>()  and B<sched_setattr>()  can both fail for the following "
"reasons:"
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_setattr.2:321
msgid "I<attr> is NULL; or I<pid> is negative; or I<flags> is not zero."
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_setattr.2:330
msgid "In addition, B<sched_getattr>()  can fail for the following reasons:"
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_setattr.2:337
msgid "The buffer specified by I<size> and I<attr> is too small."
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_setattr.2:343
msgid ""
"I<size> is invalid; that is, it is smaller than the initial version of the "
"I<sched_attr> structure (48 bytes) or larger than the system page size."
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_setattr.2:347
msgid "In addition, B<sched_setattr>()  can fail for the following reasons:"
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_setattr.2:355
msgid ""
"The buffer specified by I<size> and I<attr> is larger than the kernel "
"structure, and one or more of the excess bytes is nonzero."
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_setattr.2:360
msgid "B<SCHED_DEADLINE> admission control failure, see B<sched>(7)."
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_setattr.2:376
msgid ""
"I<attr.sched_policy> is not one of the recognized policies; "
"I<attr.sched_flags> contains a flag other than B<SCHED_FLAG_RESET_ON_FORK>; "
"or I<attr.sched_priority> is invalid; or I<attr.sched_policy> is "
"B<SCHED_DEADLINE> and the deadline scheduling parameters in I<attr> are "
"invalid."
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_setattr.2:379
msgid "The caller does not have appropriate privileges."
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_setattr.2:386
msgid ""
"The CPU affinity mask of the thread specified by I<pid> does not include all "
"CPUs in the system (see B<sched_setaffinity>(2))."
msgstr ""

#.  FIXME . Add glibc version
#. type: Plain text
#: man-pages/man2/sched_setattr.2:389
msgid "These system calls first appeared in Linux 3.14."
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_setattr.2:391 man-pages/man2/open_by_handle_at.2:385
#: man-pages/man2/process_vm_readv.2:288
msgid "These system calls are nonstandard Linux extensions."
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_setattr.2:407
msgid ""
"B<sched_setattr>()  provides a superset of the functionality of "
"B<sched_setscheduler>(2), B<sched_setparam>(2), B<nice>(2), and (other than "
"the ability to set the priority of all processes belonging to a specified "
"user or all processes in a specified group)  B<setpriority>(2).  "
"Analogously, B<sched_getattr>()  provides a superset of the functionality of "
"B<sched_getscheduler>(2), B<sched_getparam>(2), and (partially)  "
"B<getpriority>(2)."
msgstr ""

#.  FIXME . patch sent to Peter Zijlstra
#.  In Linux versions up to up 3.15,
#.  FIXME . patch from Peter Zijlstra pending
#.  .BR sched_setattr ()
#.  allowed a negative
#.  .I attr.sched_policy
#.  value.
#. type: Plain text
#: man-pages/man2/sched_setattr.2:423
msgid ""
"In Linux versions up to 3.15, B<sched_settattr>()  failed with the error "
"B<EFAULT> instead of B<E2BIG> for the case described in ERRORS."
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_setattr.2:445
msgid ""
"B<chrt>(1), B<nice>(2), B<sched_get_priority_max>(2), "
"B<sched_get_priority_min>(2), B<sched_getaffinity>(2), B<sched_getparam>(2), "
"B<sched_getscheduler>(2), B<sched_rr_get_interval>(2), "
"B<sched_setaffinity>(2), B<sched_setparam>(2), B<sched_setscheduler>(2), "
"B<sched_yield>(2), B<setpriority>(2), B<pthread_getschedparam>(3), "
"B<pthread_setschedparam>(3), B<pthread_setschedprio>(3), B<capabilities>(7), "
"B<cpuset>(7), B<sched>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/getresuid.2:28
#, no-wrap
msgid "GETRESUID"
msgstr ""

#. type: Plain text
#: man-pages/man2/getresuid.2:31
msgid "getresuid, getresgid - get real, effective and saved user/group IDs"
msgstr ""

#. type: Plain text
#: man-pages/man2/getresuid.2:37
msgid "B<int getresuid(uid_t *>I<ruid>B<, uid_t *>I<euid>B<, uid_t *>I<suid>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/getresuid.2:39
msgid "B<int getresgid(gid_t *>I<rgid>B<, gid_t *>I<egid>B<, gid_t *>I<sgid>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/getresuid.2:50
msgid ""
"B<getresuid>()  returns the real UID, the effective UID, and the saved "
"set-user-ID of the calling process, in the arguments I<ruid>, I<euid>, and "
"I<suid>, respectively.  B<getresgid>()  performs the analogous task for the "
"process's group IDs."
msgstr ""

#. type: Plain text
#: man-pages/man2/getresuid.2:60
msgid ""
"One of the arguments specified an address outside the calling program's "
"address space."
msgstr ""

#. type: Plain text
#: man-pages/man2/getresuid.2:62
msgid "These system calls appeared on Linux starting with kernel 2.1.44."
msgstr ""

#. type: Plain text
#: man-pages/man2/getresuid.2:67
msgid ""
"The prototypes are given by glibc since version 2.3.2, provided "
"B<_GNU_SOURCE> is defined."
msgstr ""

#. type: Plain text
#: man-pages/man2/getresuid.2:86
msgid ""
"The original Linux B<getresuid>()  and B<getresgid>()  system calls "
"supported only 16-bit user and group IDs.  Subsequently, Linux 2.4 added "
"B<getresuid32>()  and B<getresgid32>(), supporting 32-bit IDs.  The glibc "
"B<getresuid>()  and B<getresgid>()  wrapper functions transparently deal "
"with the variations across kernel versions."
msgstr ""

#. type: Plain text
#: man-pages/man2/getresuid.2:91
msgid ""
"B<getuid>(2), B<setresuid>(2), B<setreuid>(2), B<setuid>(2), "
"B<credentials>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/flock.2:35
#, no-wrap
msgid "FLOCK"
msgstr ""

#. type: Plain text
#: man-pages/man2/flock.2:38
msgid "flock - apply or remove an advisory lock on an open file"
msgstr ""

#. type: Plain text
#: man-pages/man2/flock.2:40
msgid "B<#include E<lt>sys/file.hE<gt>>"
msgstr ""

#. type: Plain text
#: man-pages/man2/flock.2:42
msgid "B<int flock(int >I<fd>B<, int >I<operation>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/flock.2:48
msgid ""
"Apply or remove an advisory lock on the open file specified by I<fd>.  The "
"argument I<operation> is one of the following:"
msgstr ""

#. type: TP
#: man-pages/man2/flock.2:49
#, no-wrap
msgid "B<LOCK_SH>"
msgstr ""

#. type: Plain text
#: man-pages/man2/flock.2:54
msgid ""
"Place a shared lock.  More than one process may hold a shared lock for a "
"given file at a given time."
msgstr ""

#. type: TP
#: man-pages/man2/flock.2:54
#, no-wrap
msgid "B<LOCK_EX>"
msgstr ""

#. type: Plain text
#: man-pages/man2/flock.2:59
msgid ""
"Place an exclusive lock.  Only one process may hold an exclusive lock for a "
"given file at a given time."
msgstr ""

#. type: TP
#: man-pages/man2/flock.2:59
#, no-wrap
msgid "B<LOCK_UN>"
msgstr ""

#. type: Plain text
#: man-pages/man2/flock.2:62
msgid "Remove an existing lock held by this process."
msgstr ""

#. type: Plain text
#: man-pages/man2/flock.2:71
msgid ""
"A call to B<flock>()  may block if an incompatible lock is held by another "
"process.  To make a nonblocking request, include B<LOCK_NB> (by ORing)  with "
"any of the above operations."
msgstr ""

#. type: Plain text
#: man-pages/man2/flock.2:73
msgid "A single file may not simultaneously have both shared and exclusive locks."
msgstr ""

#. type: Plain text
#: man-pages/man2/flock.2:88
msgid ""
"Locks created by B<flock>()  are associated with an open file description "
"(see B<open>(2)).  This means that duplicate file descriptors (created by, "
"for example, B<fork>(2)  or B<dup>(2))  refer to the same lock, and this "
"lock may be modified or released using any of these file descriptors.  "
"Furthermore, the lock is released either by an explicit B<LOCK_UN> operation "
"on any of these duplicate file descriptors, or when all such file "
"descriptors have been closed."
msgstr ""

#. type: Plain text
#: man-pages/man2/flock.2:97
msgid ""
"If a process uses B<open>(2)  (or similar) to obtain more than one file "
"descriptor for the same file, these file descriptors are treated "
"independently by B<flock>().  An attempt to lock the file using one of these "
"file descriptors may be denied by a lock that the calling process has "
"already placed via another file descriptor."
msgstr ""

#. type: Plain text
#: man-pages/man2/flock.2:104
msgid ""
"A process may hold only one type of lock (shared or exclusive)  on a file.  "
"Subsequent B<flock>()  calls on an already locked file will convert an "
"existing lock to the new lock mode."
msgstr ""

#. type: Plain text
#: man-pages/man2/flock.2:109
msgid "Locks created by B<flock>()  are preserved across an B<execve>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/flock.2:112
msgid ""
"A shared or exclusive lock can be placed on a file regardless of the mode in "
"which the file was opened."
msgstr ""

#. type: Plain text
#: man-pages/man2/flock.2:127
msgid ""
"While waiting to acquire a lock, the call was interrupted by delivery of a "
"signal caught by a handler; see B<signal>(7)."
msgstr ""

#. type: Plain text
#: man-pages/man2/flock.2:131
msgid "I<operation> is invalid."
msgstr ""

#. type: TP
#: man-pages/man2/flock.2:131 man-pages/man2/fcntl.2:1780
#, no-wrap
msgid "B<ENOLCK>"
msgstr ""

#. type: Plain text
#: man-pages/man2/flock.2:134
msgid "The kernel ran out of memory for allocating lock records."
msgstr ""

#. type: Plain text
#: man-pages/man2/flock.2:139
msgid "The file is locked and the B<LOCK_NB> flag was selected."
msgstr ""

#. type: Plain text
#: man-pages/man2/flock.2:148
msgid ""
"4.4BSD (the B<flock>()  call first appeared in 4.2BSD).  A version of "
"B<flock>(), possibly implemented in terms of B<fcntl>(2), appears on most "
"UNIX systems."
msgstr ""

#.  E.g., according to the flock(2) man page, FreeBSD since at least 5.3
#. type: Plain text
#: man-pages/man2/flock.2:171
msgid ""
"Since kernel 2.0, B<flock>()  is implemented as a system call in its own "
"right rather than being emulated in the GNU C library as a call to "
"B<fcntl>(2).  With this implementation, there is no interaction between the "
"types of lock placed by B<flock>()  and B<fcntl>(2), and B<flock>()  does "
"not detect deadlock.  (Note, however, that on some systems, such as the "
"modern BSDs, B<flock>()  and B<fcntl>(2)  locks I<do> interact with one "
"another.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/flock.2:177
msgid ""
"B<flock>()  places advisory locks only; given suitable permissions on a "
"file, a process is free to ignore the use of B<flock>()  and perform I/O on "
"the file."
msgstr ""

#. type: Plain text
#: man-pages/man2/flock.2:190
msgid ""
"B<flock>()  and B<fcntl>(2)  locks have different semantics with respect to "
"forked processes and B<dup>(2).  On systems that implement B<flock>()  using "
"B<fcntl>(2), the semantics of B<flock>()  will be different from those "
"described in this manual page."
msgstr ""

#.  Kernel 2.5.21 changed things a little: during lock conversion
#.  it is now the highest priority process that will get the lock -- mtk
#. type: Plain text
#: man-pages/man2/flock.2:203
msgid ""
"Converting a lock (shared to exclusive, or vice versa) is not guaranteed to "
"be atomic: the existing lock is first removed, and then a new lock is "
"established.  Between these two steps, a pending lock request by another "
"process may be granted, with the result that the conversion either blocks, "
"or fails if B<LOCK_NB> was specified.  (This is the original BSD behavior, "
"and occurs on many other implementations.)"
msgstr ""

#. type: SS
#: man-pages/man2/flock.2:203
#, no-wrap
msgid "NFS details"
msgstr ""

#. type: Plain text
#: man-pages/man2/flock.2:213
msgid ""
"In Linux kernels up to 2.6.11, B<flock>()  does not lock files over NFS "
"(i.e., the scope of locks was limited to the local system).  Instead, one "
"could use B<fcntl>(2)  byte-range locking, which does work over NFS, given a "
"sufficiently recent version of Linux and a server which supports locking."
msgstr ""

#. type: Plain text
#: man-pages/man2/flock.2:228
msgid ""
"Since Linux 2.6.12, NFS clients support B<flock>()  locks by emulating them "
"as B<fcntl>(2)  byte-range locks on the entire file.  This means that "
"B<fcntl>(2)  and B<flock>()  locks I<do> interact with one another over "
"NFS.  It also means that in order to place an exclusive lock, the file must "
"be opened for writing."
msgstr ""

#.  commit 5eebde23223aeb0ad2d9e3be6590ff8bbfab0fc2
#. type: Plain text
#: man-pages/man2/flock.2:240
msgid ""
"Since Linux 2.6.37, the kernel supports a compatibility mode that allows "
"B<flock>()  locks (and also B<fcntl>(2)  byte region locks) to be treated as "
"local; see the discussion of the I<local_lock> option in B<nfs>(5)."
msgstr ""

#. type: Plain text
#: man-pages/man2/flock.2:250
msgid ""
"B<flock>(1), B<close>(2), B<dup>(2), B<execve>(2), B<fcntl>(2), B<fork>(2), "
"B<open>(2), B<lockf>(3), B<lslocks>(8)"
msgstr ""

#. type: Plain text
#: man-pages/man2/flock.2:254
msgid ""
"I<Documentation/filesystems/locks.txt> in the Linux kernel source tree "
"(I<Documentation/locks.txt> in older kernels)"
msgstr ""

#. type: TH
#: man-pages/man2/ipc.2:25
#, no-wrap
msgid "IPC"
msgstr ""

#. type: Plain text
#: man-pages/man2/ipc.2:28
msgid "ipc - System V IPC system calls"
msgstr ""

#. type: Plain text
#: man-pages/man2/ipc.2:33
#, no-wrap
msgid ""
"B<int ipc(unsigned int >I<call>B<, int >I<first>B<, int >I<second>B<, int "
">I<third>B<,>\n"
"B<        void *>I<ptr>B<, long >I<fifth>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/ipc.2:41
msgid ""
"B<ipc>()  is a common kernel entry point for the System\\ V IPC calls for "
"messages, semaphores, and shared memory.  I<call> determines which IPC "
"function to invoke; the other arguments are passed through to the "
"appropriate call."
msgstr ""

#. type: Plain text
#: man-pages/man2/ipc.2:45
msgid ""
"User-space programs should call the appropriate functions by their usual "
"names.  Only standard library implementors and kernel hackers need to know "
"about B<ipc>()."
msgstr ""

#. type: Plain text
#: man-pages/man2/ipc.2:49
msgid ""
"B<ipc>()  is Linux-specific, and should not be used in programs intended to "
"be portable."
msgstr ""

#. type: Plain text
#: man-pages/man2/ipc.2:57
msgid ""
"On some architectures\\(emfor example x86-64 and ARM\\(emthere is no "
"B<ipc>()  system call; instead, B<msgctl>(2), B<semctl>(2), B<shmctl>(2), "
"and so on really are implemented as separate system calls."
msgstr ""

#. type: Plain text
#: man-pages/man2/ipc.2:70
msgid ""
"B<msgctl>(2), B<msgget>(2), B<msgrcv>(2), B<msgsnd>(2), B<semctl>(2), "
"B<semget>(2), B<semop>(2), B<semtimedop>(2), B<shmat>(2), B<shmctl>(2), "
"B<shmdt>(2), B<shmget>(2), B<sysvipc>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/getcpu.2:12
#, no-wrap
msgid "GETCPU"
msgstr ""

#. type: Plain text
#: man-pages/man2/getcpu.2:15
msgid "getcpu - determine CPU and NUMA node on which the calling thread is running"
msgstr ""

#. type: Plain text
#: man-pages/man2/getcpu.2:18
#, no-wrap
msgid "B<#include E<lt>linux/getcpu.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/getcpu.2:21
#, no-wrap
msgid ""
"B<int getcpu(unsigned *>I<cpu>B<, unsigned *>I<node>B<, struct getcpu_cache "
"*>I<tcache>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/getcpu.2:39
msgid ""
"The B<getcpu>()  system call identifies the processor and node on which the "
"calling thread or process is currently running and writes them into the "
"integers pointed to by the I<cpu> and I<node> arguments.  The processor is a "
"unique small integer identifying a CPU.  The node is a unique small "
"identifier identifying a NUMA node.  When either I<cpu> or I<node> is NULL "
"nothing is written to the respective pointer."
msgstr ""

#. type: Plain text
#: man-pages/man2/getcpu.2:43
msgid ""
"The third argument to this system call is nowadays unused, and should be "
"specified as NULL unless portability to Linux 2.6.23 or earlier is required "
"(see NOTES)."
msgstr ""

#. type: Plain text
#: man-pages/man2/getcpu.2:58
msgid ""
"The information placed in I<cpu> is guaranteed to be current only at the "
"time of the call: unless the CPU affinity has been fixed using "
"B<sched_setaffinity>(2), the kernel might change the CPU at any time.  "
"(Normally this does not happen because the scheduler tries to minimize "
"movements between CPUs to keep caches hot, but it is possible.)  The caller "
"must allow for the possibility that the information returned in I<cpu> and "
"I<node> is no longer current by the time the call returns."
msgstr ""

#. type: Plain text
#: man-pages/man2/getcpu.2:63
msgid ""
"On success, 0 is returned.  On error, -1 is returned, and I<errno> is set "
"appropriately."
msgstr ""

#. type: Plain text
#: man-pages/man2/getcpu.2:67
msgid "Arguments point outside the calling process's address space."
msgstr ""

#. type: Plain text
#: man-pages/man2/getcpu.2:74
msgid ""
"B<getcpu>()  was added in kernel 2.6.19 for x86-64 and i386.  Library "
"support was added in glibc 2.29 (Earlier glibc versions did not provide a "
"wrapper for this system call, necessitating the use of B<syscall>(2).)"
msgstr ""

#. type: Plain text
#: man-pages/man2/getcpu.2:77
msgid "B<getcpu>()  is Linux-specific."
msgstr ""

#. type: Plain text
#: man-pages/man2/getcpu.2:85
msgid ""
"Linux makes a best effort to make this call as fast as possible.  (On some "
"architectures, this is done via an implementation in the B<vdso>(7).)  The "
"intention of B<getcpu>()  is to allow programs to make optimizations with "
"per-CPU data or for NUMA optimization."
msgstr ""

#.  commit 4307d1e5ada595c87f9a4d16db16ba5edb70dcb1
#.  Author: Ingo Molnar <mingo@elte.hu>
#.  Date:   Wed Nov 7 18:37:48 2007 +0100
#.  x86: ignore the sys_getcpu() tcache parameter
#
#.  ===== Before kernel 2.6.24: =====
#.  .I tcache
#.  is a pointer to a
#.  .IR "struct getcpu_cache"
#.  that is used as a cache by
#.  .BR getcpu ().
#.  The caller should put the cache into a thread-local variable
#.  if the process is multithreaded,
#.  because the cache cannot be shared between different threads.
#.  .I tcache
#.  can be NULL.
#.  If it is not NULL
#.  .BR getcpu ()
#.  will use it to speed up operation.
#.  The information inside the cache is private to the system call
#.  and should not be accessed by the user program.
#.  The information placed in the cache can change between kernel releases.
#
#.  When no cache is specified
#.  .BR getcpu ()
#.  will be slower,
#.  but always retrieve the current CPU and node information.
#.  With a cache
#.  .BR getcpu ()
#.  is faster.
#.  However, the cached information is updated only once per jiffy (see
#.  .BR time (7)).
#.  This means that the information could theoretically be out of date,
#.  although in practice the scheduler's attempt to maintain
#.  soft CPU affinity means that the information is unlikely to change
#.  over the course of the caching interval.
#. type: Plain text
#: man-pages/man2/getcpu.2:136
msgid ""
"The I<tcache> argument is unused since Linux 2.6.24.  In earlier kernels, if "
"this argument was non-NULL, then it specified a pointer to a "
"caller-allocated buffer in thread-local storage that was used to provide a "
"caching mechanism for B<getcpu>().  Use of the cache could speed B<getcpu>()  "
"calls, at the cost that there was a very small chance that the returned "
"information would be out of date.  The caching mechanism was considered to "
"cause problems when migrating threads between CPUs, and so the argument is "
"now ignored."
msgstr ""

#. type: Plain text
#: man-pages/man2/getcpu.2:142
msgid ""
"B<mbind>(2), B<sched_setaffinity>(2), B<set_mempolicy>(2), "
"B<sched_getcpu>(3), B<cpuset>(7), B<vdso>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/capget.2:15
#, no-wrap
msgid "CAPGET"
msgstr ""

#. type: Plain text
#: man-pages/man2/capget.2:18
msgid "capget, capset - set/get capabilities of thread(s)"
msgstr ""

#. type: Plain text
#: man-pages/man2/capget.2:20
msgid "B<#include E<lt>sys/capability.hE<gt>>"
msgstr ""

#. type: Plain text
#: man-pages/man2/capget.2:22
msgid "B<int capget(cap_user_header_t >I<hdrp>B<, cap_user_data_t >I<datap>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/capget.2:24
msgid ""
"B<int capset(cap_user_header_t >I<hdrp>B<, const cap_user_data_t "
">I<datap>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/capget.2:33
msgid ""
"These two system calls are the raw kernel interface for getting and setting "
"thread capabilities.  Not only are these system calls specific to Linux, but "
"the kernel API is likely to change and use of these system calls (in "
"particular the format of the I<cap_user_*_t> types) is subject to extension "
"with each kernel revision, but old programs will keep working."
msgstr ""

#. type: Plain text
#: man-pages/man2/capget.2:40
msgid ""
"The portable interfaces are B<cap_set_proc>(3)  and B<cap_get_proc>(3); if "
"possible, you should use those interfaces in applications."
msgstr ""

#. type: SS
#: man-pages/man2/capget.2:40
#, no-wrap
msgid "Current details"
msgstr ""

#. type: Plain text
#: man-pages/man2/capget.2:43
msgid ""
"Now that you have been warned, some current kernel details.  The structures "
"are defined as follows."
msgstr ""

#. type: Plain text
#: man-pages/man2/capget.2:48
#, no-wrap
msgid ""
"#define _LINUX_CAPABILITY_VERSION_1  0x19980330\n"
"#define _LINUX_CAPABILITY_U32S_1     1\n"
msgstr ""

#.  commit e338d263a76af78fe8f38a72131188b58fceb591
#.  Added 64 bit capability support
#. type: Plain text
#: man-pages/man2/capget.2:54
#, no-wrap
msgid ""
"        /* V2 added in Linux 2.6.25; deprecated */\n"
"#define _LINUX_CAPABILITY_VERSION_2  0x20071026\n"
"#define _LINUX_CAPABILITY_U32S_2     2\n"
msgstr ""

#.  commit ca05a99a54db1db5bca72eccb5866d2a86f8517f
#. type: Plain text
#: man-pages/man2/capget.2:59
#, no-wrap
msgid ""
"        /* V3 added in Linux 2.6.26 */\n"
"#define _LINUX_CAPABILITY_VERSION_3  0x20080522\n"
"#define _LINUX_CAPABILITY_U32S_3     2\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/capget.2:64
#, no-wrap
msgid ""
"typedef struct __user_cap_header_struct {\n"
"   __u32 version;\n"
"   int pid;\n"
"} *cap_user_header_t;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/capget.2:70
#, no-wrap
msgid ""
"typedef struct __user_cap_data_struct {\n"
"   __u32 effective;\n"
"   __u32 permitted;\n"
"   __u32 inheritable;\n"
"} *cap_user_data_t;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/capget.2:89
msgid ""
"The I<effective>, I<permitted>, and I<inheritable> fields are bit masks of "
"the capabilities defined in B<capabilities>(7).  Note that the B<CAP_*> "
"values are bit indexes and need to be bit-shifted before ORing into the bit "
"fields.  To define the structures for passing to the system call, you have "
"to use the I<struct __user_cap_header_struct> and I<struct "
"__user_cap_data_struct> names because the typedefs are only pointers."
msgstr ""

#. type: Plain text
#: man-pages/man2/capget.2:98
msgid ""
"Kernels prior to 2.6.25 prefer 32-bit capabilities with version "
"B<_LINUX_CAPABILITY_VERSION_1>.  Linux 2.6.25 added 64-bit capability sets, "
"with version B<_LINUX_CAPABILITY_VERSION_2>.  There was, however, an API "
"glitch, and Linux 2.6.26 added B<_LINUX_CAPABILITY_VERSION_3> to fix the "
"problem."
msgstr ""

#. type: Plain text
#: man-pages/man2/capget.2:105
msgid ""
"Note that 64-bit capabilities use I<datap>[0] and I<datap>[1], whereas "
"32-bit capabilities use only I<datap>[0]."
msgstr ""

#. type: Plain text
#: man-pages/man2/capget.2:110
msgid ""
"On kernels that support file capabilities (VFS capabilities support), these "
"system calls behave slightly differently.  This support was added as an "
"option in Linux 2.6.24, and became fixed (nonoptional) in Linux 2.6.33."
msgstr ""

#. type: Plain text
#: man-pages/man2/capget.2:117
msgid ""
"For B<capget>()  calls, one can probe the capabilities of any process by "
"specifying its process ID with the I<hdrp-E<gt>pid> field value."
msgstr ""

#. type: Plain text
#: man-pages/man2/capget.2:121
msgid "For details on the data, see B<capabilities>(7)."
msgstr ""

#. type: SS
#: man-pages/man2/capget.2:121
#, no-wrap
msgid "With VFS capabilities support"
msgstr ""

#. type: Plain text
#: man-pages/man2/capget.2:134
msgid ""
"VFS capabilities employ a file extended attribute (see B<xattr>(7))  to "
"allow capabilities to be attached to executables.  This privilege model "
"obsoletes kernel support for one process asynchronously setting the "
"capabilities of another.  That is, on kernels that have VFS capabilities "
"support, when calling B<capset>(), the only permitted values for "
"I<hdrp-E<gt>pid> are 0 or, equivalently, the value returned by B<gettid>(2)."
msgstr ""

#. type: SS
#: man-pages/man2/capget.2:134
#, no-wrap
msgid "Without VFS capabilities support"
msgstr ""

#. type: Plain text
#: man-pages/man2/capget.2:164
msgid ""
"On older kernels that do not provide VFS capabilities support B<capset>()  "
"can, if the caller has the B<CAP_SETPCAP> capability, be used to change not "
"only the caller's own capabilities, but also the capabilities of other "
"threads.  The call operates on the capabilities of the thread specified by "
"the I<pid> field of I<hdrp> when that is nonzero, or on the capabilities of "
"the calling thread if I<pid> is 0.  If I<pid> refers to a single-threaded "
"process, then I<pid> can be specified as a traditional process ID; operating "
"on a thread of a multithreaded process requires a thread ID of the type "
"returned by B<gettid>(2).  For B<capset>(), I<pid> can also be: -1, meaning "
"perform the change on all threads except the caller and B<init>(1); or a "
"value less than -1, in which case the change is applied to all members of "
"the process group whose ID is -I<pid>."
msgstr ""

#. type: Plain text
#: man-pages/man2/capget.2:183
msgid ""
"The calls fail with the error B<EINVAL>, and set the I<version> field of "
"I<hdrp> to the kernel preferred value of B<_LINUX_CAPABILITY_VERSION_?> when "
"an unsupported I<version> value is specified.  In this way, one can probe "
"what the current preferred capability revision is."
msgstr ""

#. type: Plain text
#: man-pages/man2/capget.2:192
msgid ""
"Bad memory address.  I<hdrp> must not be NULL.  I<datap> may be NULL only "
"when the user is trying to determine the preferred capability version format "
"supported by the kernel."
msgstr ""

#. type: Plain text
#: man-pages/man2/capget.2:195
msgid "One of the arguments was invalid."
msgstr ""

#. type: Plain text
#: man-pages/man2/capget.2:200
msgid ""
"An attempt was made to add a capability to the Permitted set, or to set a "
"capability in the Effective or Inheritable sets that is not in the Permitted "
"set."
msgstr ""

#. type: Plain text
#: man-pages/man2/capget.2:219
msgid ""
"The caller attempted to use B<capset>()  to modify the capabilities of a "
"thread other than itself, but lacked sufficient privilege.  For kernels "
"supporting VFS capabilities, this is never permitted.  For kernels lacking "
"VFS support, the B<CAP_SETPCAP> capability is required.  (A bug in kernels "
"before 2.6.11 meant that this error could also occur if a thread without "
"this capability tried to change its own capabilities by specifying the "
"I<pid> field as a nonzero value (i.e., the value returned by B<getpid>(2))  "
"instead of 0.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/capget.2:222
msgid "No such thread."
msgstr ""

#. type: Plain text
#: man-pages/man2/capget.2:229
msgid ""
"The portable interface to the capability querying and setting functions is "
"provided by the I<libcap> library and is available here:"
msgstr ""

#. type: Plain text
#: man-pages/man2/capget.2:232
msgid ""
"E<.UR "
"http://git.kernel.org/cgit\\:/linux\\:/kernel\\:/git\\:/morgan\\:\\:/libcap.git> "
"E<.UE>"
msgstr ""

#. type: Plain text
#: man-pages/man2/capget.2:235
msgid "B<clone>(2), B<gettid>(2), B<capabilities>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/quotactl.2:27
#, no-wrap
msgid "QUOTACTL"
msgstr ""

#. type: Plain text
#: man-pages/man2/quotactl.2:30
msgid "quotactl - manipulate disk quotas"
msgstr ""

#. type: Plain text
#: man-pages/man2/quotactl.2:34
#, no-wrap
msgid ""
"B<#include E<lt>sys/quota.hE<gt>>\n"
"B<#include E<lt>xfs/xqm.hE<gt> /* for XFS quotas */>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/quotactl.2:37
#, no-wrap
msgid ""
"B<int quotactl(int >I<cmd>B<, const char *>I<special>B<, int >I<id>B<, "
"caddr_t >I<addr>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/quotactl.2:49
msgid ""
"The quota system can be used to set per-user, per-group, and per-project "
"limits on the amount of disk space used on a filesystem.  For each user "
"and/or group, a soft limit and a hard limit can be set for each filesystem.  "
"The hard limit can't be exceeded.  The soft limit can be exceeded, but "
"warnings will ensue.  Moreover, the user can't exceed the soft limit for "
"more than grace period duration (one week by default) at a time; after this, "
"the soft limit counts as a hard limit."
msgstr ""

#.  847aac644e92e5624f2c153bab409bf713d5ff9a
#. type: Plain text
#: man-pages/man2/quotactl.2:76
msgid ""
"The B<quotactl>()  call manipulates disk quotas.  The I<cmd> argument "
"indicates a command to be applied to the user or group ID specified in "
"I<id>.  To initialize the I<cmd> argument, use the I<QCMD(subcmd, type)> "
"macro.  The I<type> value is either B<USRQUOTA>, for user quotas, "
"B<GRPQUOTA>, for group quotas, or (since Linux 4.1)  B<PRJQUOTA>, for "
"project quotas.  The I<subcmd> value is described below."
msgstr ""

#. type: Plain text
#: man-pages/man2/quotactl.2:81
msgid ""
"The I<special> argument is a pointer to a null-terminated string containing "
"the pathname of the (mounted) block special device for the filesystem being "
"manipulated."
msgstr ""

#. type: Plain text
#: man-pages/man2/quotactl.2:89
msgid ""
"The I<addr> argument is the address of an optional, command-specific, data "
"structure that is copied in or out of the system.  The interpretation of "
"I<addr> is given with each command below."
msgstr ""

#. type: Plain text
#: man-pages/man2/quotactl.2:93
msgid "The I<subcmd> value is one of the following:"
msgstr ""

#. type: TP
#: man-pages/man2/quotactl.2:93
#, no-wrap
msgid "B<Q_QUOTAON>"
msgstr ""

#. type: Plain text
#: man-pages/man2/quotactl.2:100
msgid ""
"Turn on quotas for a filesystem.  The I<id> argument is the identification "
"number of the quota format to be used.  Currently, there are three supported "
"quota formats:"
msgstr ""

#. type: TP
#: man-pages/man2/quotactl.2:101
#, no-wrap
msgid "B<QFMT_VFS_OLD>"
msgstr ""

#. type: Plain text
#: man-pages/man2/quotactl.2:104
msgid "The original quota format."
msgstr ""

#. type: TP
#: man-pages/man2/quotactl.2:104
#, no-wrap
msgid "B<QFMT_VFS_V0>"
msgstr ""

#. type: Plain text
#: man-pages/man2/quotactl.2:108
msgid ""
"The standard VFS v0 quota format, which can handle 32-bit UIDs and GIDs and "
"quota limits up to 2^42 bytes and 2^32 inodes."
msgstr ""

#. type: TP
#: man-pages/man2/quotactl.2:108
#, no-wrap
msgid "B<QFMT_VFS_V1>"
msgstr ""

#. type: Plain text
#: man-pages/man2/quotactl.2:112
msgid ""
"A quota format that can handle 32-bit UIDs and GIDs and quota limits of 2^64 "
"bytes and 2^64 inodes."
msgstr ""

#. type: Plain text
#: man-pages/man2/quotactl.2:123
msgid ""
"The I<addr> argument points to the pathname of a file containing the quotas "
"for the filesystem.  The quota file must exist; it is normally created with "
"the B<quotacheck>(8)  program.  This operation requires privilege "
"(B<CAP_SYS_ADMIN>)."
msgstr ""

#. type: TP
#: man-pages/man2/quotactl.2:123
#, no-wrap
msgid "B<Q_QUOTAOFF>"
msgstr ""

#. type: Plain text
#: man-pages/man2/quotactl.2:133
msgid ""
"Turn off quotas for a filesystem.  The I<addr> and I<id> arguments are "
"ignored.  This operation requires privilege (B<CAP_SYS_ADMIN>)."
msgstr ""

#. type: TP
#: man-pages/man2/quotactl.2:133
#, no-wrap
msgid "B<Q_GETQUOTA>"
msgstr ""

#. type: Plain text
#: man-pages/man2/quotactl.2:144
msgid ""
"Get disk quota limits and current usage for user or group I<id>.  The "
"I<addr> argument is a pointer to a I<dqblk> structure defined in "
"I<E<lt>sys/quota.hE<gt>> as follows:"
msgstr ""

#. type: Plain text
#: man-pages/man2/quotactl.2:149 man-pages/man2/quotactl.2:272
#, no-wrap
msgid ""
"/* uint64_t is an unsigned 64-bit integer;\n"
"   uint32_t is an unsigned 32-bit integer */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/quotactl.2:169
#, no-wrap
msgid ""
"struct dqblk {      /* Definition since Linux 2.4.22 */\n"
"    uint64_t dqb_bhardlimit;  /* Absolute limit on disk\n"
"                                 quota blocks alloc */\n"
"    uint64_t dqb_bsoftlimit;  /* Preferred limit on\n"
"                                 disk quota blocks */\n"
"    uint64_t dqb_curspace;    /* Current occupied space\n"
"                                 (in bytes) */\n"
"    uint64_t dqb_ihardlimit;  /* Maximum number of\n"
"                                 allocated inodes */\n"
"    uint64_t dqb_isoftlimit;  /* Preferred inode limit */\n"
"    uint64_t dqb_curinodes;   /* Current number of\n"
"                                 allocated inodes */\n"
"    uint64_t dqb_btime;       /* Time limit for excessive\n"
"                                 disk use */\n"
"    uint64_t dqb_itime;       /* Time limit for excessive\n"
"                                 files */\n"
"    uint32_t dqb_valid;       /* Bit mask of QIF_*\n"
"                                 constants */\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/quotactl.2:172
#, no-wrap
msgid ""
"/* Flags in dqb_valid that indicate which fields in\n"
"   dqblk structure are valid. */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/quotactl.2:183
#, no-wrap
msgid ""
"#define QIF_BLIMITS   1\n"
"#define QIF_SPACE     2\n"
"#define QIF_ILIMITS   4\n"
"#define QIF_INODES    8\n"
"#define QIF_BTIME     16\n"
"#define QIF_ITIME     32\n"
"#define QIF_LIMITS    (QIF_BLIMITS | QIF_ILIMITS)\n"
"#define QIF_USAGE     (QIF_SPACE | QIF_INODES)\n"
"#define QIF_TIMES     (QIF_BTIME | QIF_ITIME)\n"
"#define QIF_ALL       (QIF_LIMITS | QIF_USAGE | QIF_TIMES)\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/quotactl.2:200
msgid ""
"The I<dqb_valid> field is a bit mask that is set to indicate the entries in "
"the I<dqblk> structure that are valid.  Currently, the kernel fills in all "
"entries of the I<dqblk> structure and marks them as valid in the "
"I<dqb_valid> field.  Unprivileged users may retrieve only their own quotas; "
"a privileged user (B<CAP_SYS_ADMIN>)  can retrieve the quotas of any user."
msgstr ""

#. type: TP
#: man-pages/man2/quotactl.2:200
#, no-wrap
msgid "B<Q_GETNEXTQUOTA> (since Linux 4.6)"
msgstr ""

#.  commit 926132c0257a5a8d149a6a395cc3405e55420566
#. type: Plain text
#: man-pages/man2/quotactl.2:208
msgid ""
"This operation is the same as B<Q_GETQUOTA>, but it returns quota "
"information for the next ID greater than or equal to I<id> that has a quota "
"set."
msgstr ""

#. type: Plain text
#: man-pages/man2/quotactl.2:219
msgid ""
"The I<addr> argument is a pointer to a I<nextdqblk> structure whose fields "
"are as for the I<dqblk>, except for the addition of a I<dqb_id> field that "
"is used to return the ID for which quota information is being returned:"
msgstr ""

#. type: Plain text
#: man-pages/man2/quotactl.2:234
#, no-wrap
msgid ""
"struct nextdqblk {\n"
"    uint64_t dqb_bhardlimit;\n"
"    uint64_t dqb_bsoftlimit;\n"
"    uint64_t dqb_curspace;\n"
"    uint64_t dqb_ihardlimit;\n"
"    uint64_t dqb_isoftlimit;\n"
"    uint64_t dqb_curinodes;\n"
"    uint64_t dqb_btime;\n"
"    uint64_t dqb_itime;\n"
"    uint32_t dqb_valid;\n"
"    uint32_t dqb_id;\n"
"};\n"
msgstr ""

#. type: TP
#: man-pages/man2/quotactl.2:236
#, no-wrap
msgid "B<Q_SETQUOTA>"
msgstr ""

#. type: Plain text
#: man-pages/man2/quotactl.2:256
msgid ""
"Set quota information for user or group I<id>, using the information "
"supplied in the I<dqblk> structure pointed to by I<addr>.  The I<dqb_valid> "
"field of the I<dqblk> structure indicates which entries in the structure "
"have been set by the caller.  This operation supersedes the B<Q_SETQLIM> and "
"B<Q_SETUSE> operations in the previous quota interfaces.  This operation "
"requires privilege (B<CAP_SYS_ADMIN>)."
msgstr ""

#. type: TP
#: man-pages/man2/quotactl.2:256
#, no-wrap
msgid "B<Q_GETINFO> (since Linux 2.4.22)"
msgstr ""

#. type: Plain text
#: man-pages/man2/quotactl.2:267
msgid ""
"Get information (like grace times) about quotafile.  The I<addr> argument "
"should be a pointer to a I<dqinfo> structure.  This structure is defined in "
"I<E<lt>sys/quota.hE<gt>> as follows:"
msgstr ""

#. type: Plain text
#: man-pages/man2/quotactl.2:282
#, no-wrap
msgid ""
"struct dqinfo {         /* Defined since kernel 2.4.22 */\n"
"    uint64_t dqi_bgrace;  /* Time before block soft limit\n"
"                             becomes hard limit */\n"
"    uint64_t dqi_igrace;  /* Time before inode soft limit\n"
"                             becomes hard limit */\n"
"    uint32_t dqi_flags;   /* Flags for quotafile\n"
"                             (DQF_*) */\n"
"    uint32_t dqi_valid;\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/quotactl.2:284
#, no-wrap
msgid "/* Bits for dqi_flags */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/quotactl.2:286
#, no-wrap
msgid "/* Quota format QFMT_VFS_OLD */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/quotactl.2:290
#, no-wrap
msgid ""
"#define DQF_ROOT_SQUASH (1 E<lt>E<lt> 0) /* Root squash enabled */\n"
"              /* Before Linux v4.0, this had been defined\n"
"                 privately as V1_DQF_RSQUASH */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/quotactl.2:292
#, no-wrap
msgid "/* Quota format QFMT_VFS_V0 / QFMT_VFS_V1 */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/quotactl.2:295
#, no-wrap
msgid ""
"#define DQF_SYS_FILE    (1 E<lt>E<lt> 16)   /* Quota stored in\n"
"                                       a system file */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/quotactl.2:298
#, no-wrap
msgid ""
"/* Flags in dqi_valid that indicate which fields in\n"
"   dqinfo structure are valid. */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/quotactl.2:303
#, no-wrap
msgid ""
"#define IIF_BGRACE  1\n"
"#define IIF_IGRACE  2\n"
"#define IIF_FLAGS   4\n"
"#define IIF_ALL     (IIF_BGRACE | IIF_IGRACE | IIF_FLAGS)\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/quotactl.2:319
msgid ""
"The I<dqi_valid> field in the I<dqinfo> structure indicates the entries in "
"the structure that are valid.  Currently, the kernel fills in all entries of "
"the I<dqinfo> structure and marks them all as valid in the I<dqi_valid> "
"field.  The I<id> argument is ignored."
msgstr ""

#. type: TP
#: man-pages/man2/quotactl.2:319
#, no-wrap
msgid "B<Q_SETINFO> (since Linux 2.4.22)"
msgstr ""

#. type: Plain text
#: man-pages/man2/quotactl.2:343
msgid ""
"Set information about quotafile.  The I<addr> argument should be a pointer "
"to a I<dqinfo> structure.  The I<dqi_valid> field of the I<dqinfo> structure "
"indicates the entries in the structure that have been set by the caller.  "
"This operation supersedes the B<Q_SETGRACE> and B<Q_SETFLAGS> operations in "
"the previous quota interfaces.  The I<id> argument is ignored.  This "
"operation requires privilege (B<CAP_SYS_ADMIN>)."
msgstr ""

#. type: TP
#: man-pages/man2/quotactl.2:343
#, no-wrap
msgid "B<Q_GETFMT> (since Linux 2.4.22)"
msgstr ""

#. type: Plain text
#: man-pages/man2/quotactl.2:350
msgid ""
"Get quota format used on the specified filesystem.  The I<addr> argument "
"should be a pointer to a 4-byte buffer where the format number will be "
"stored."
msgstr ""

#. type: TP
#: man-pages/man2/quotactl.2:350
#, no-wrap
msgid "B<Q_SYNC>"
msgstr ""

#. type: Plain text
#: man-pages/man2/quotactl.2:361
msgid ""
"Update the on-disk copy of quota usages for a filesystem.  If I<special> is "
"NULL, then all filesystems with active quotas are sync'ed.  The I<addr> and "
"I<id> arguments are ignored."
msgstr ""

#. type: TP
#: man-pages/man2/quotactl.2:361
#, no-wrap
msgid "B<Q_GETSTATS> (supported up to Linux 2.4.21)"
msgstr ""

#. type: Plain text
#: man-pages/man2/quotactl.2:376
msgid ""
"Get statistics and other generic information about the quota subsystem.  The "
"I<addr> argument should be a pointer to a I<dqstats> structure in which data "
"should be stored.  This structure is defined in I<E<lt>sys/quota.hE<gt>>.  "
"The I<special> and I<id> arguments are ignored."
msgstr ""

#. type: Plain text
#: man-pages/man2/quotactl.2:381
msgid ""
"This operation is obsolete and was removed in Linux 2.4.22.  Files in "
"I</proc/sys/fs/quota/> carry the information instead."
msgstr ""

#. type: Plain text
#: man-pages/man2/quotactl.2:384
msgid ""
"For XFS filesystems making use of the XFS Quota Manager (XQM), the above "
"commands are bypassed and the following commands are used:"
msgstr ""

#. type: TP
#: man-pages/man2/quotactl.2:384
#, no-wrap
msgid "B<Q_XQUOTAON>"
msgstr ""

#. type: Plain text
#: man-pages/man2/quotactl.2:395
msgid ""
"Turn on quotas for an XFS filesystem.  XFS provides the ability to turn "
"on/off quota limit enforcement with quota accounting.  Therefore, XFS "
"expects I<addr> to be a pointer to an I<unsigned int> that contains a "
"combination of the following flags (defined in I<E<lt>xfs/xqm.hE<gt>>):"
msgstr ""

#. type: Plain text
#: man-pages/man2/quotactl.2:410
#, no-wrap
msgid ""
"#define XFS_QUOTA_UDQ_ACCT (1E<lt>E<lt>0) /* User quota\n"
"                                     accounting */\n"
"#define XFS_QUOTA_UDQ_ENFD (1E<lt>E<lt>1) /* User quota limits\n"
"                                     enforcement */\n"
"#define XFS_QUOTA_GDQ_ACCT (1E<lt>E<lt>2) /* Group quota\n"
"                                     accounting */\n"
"#define XFS_QUOTA_GDQ_ENFD (1E<lt>E<lt>3) /* Group quota limits\n"
"                                     enforcement */\n"
"#define XFS_QUOTA_PDQ_ACCT (1E<lt>E<lt>4) /* Project quota\n"
"                                     accounting */\n"
"#define XFS_QUOTA_PDQ_ENFD (1E<lt>E<lt>5) /* Project quota limits\n"
"                                     enforcement */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/quotactl.2:418
msgid ""
"This operation requires privilege (B<CAP_SYS_ADMIN>).  The I<id> argument is "
"ignored."
msgstr ""

#. type: TP
#: man-pages/man2/quotactl.2:418
#, no-wrap
msgid "B<Q_XQUOTAOFF>"
msgstr ""

#. type: Plain text
#: man-pages/man2/quotactl.2:434
msgid ""
"Turn off quotas for an XFS filesystem.  As with B<Q_QUOTAON>, XFS "
"filesystems expect a pointer to an I<unsigned int> that specifies whether "
"quota accounting and/or limit enforcement need to be turned off (using the "
"same flags as for B<Q_XQUOTAON> subcommand).  This operation requires "
"privilege (B<CAP_SYS_ADMIN>).  The I<id> argument is ignored."
msgstr ""

#. type: TP
#: man-pages/man2/quotactl.2:434
#, no-wrap
msgid "B<Q_XGETQUOTA>"
msgstr ""

#. type: Plain text
#: man-pages/man2/quotactl.2:445
msgid ""
"Get disk quota limits and current usage for user I<id>.  The I<addr> "
"argument is a pointer to an I<fs_disk_quota> structure, which is defined in "
"I<E<lt>xfs/xqm.hE<gt>> as follows:"
msgstr ""

#. type: Plain text
#: man-pages/man2/quotactl.2:450
#, no-wrap
msgid ""
"/* All the blk units are in BBs (Basic Blocks) of\n"
"   512 bytes. */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/quotactl.2:452
#, no-wrap
msgid "#define FS_DQUOT_VERSION  1  /* fs_disk_quota.d_version */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/quotactl.2:456
#, no-wrap
msgid ""
"#define XFS_USER_QUOTA    (1E<lt>E<lt>0)  /* User quota type */\n"
"#define XFS_PROJ_QUOTA    (1E<lt>E<lt>1)  /* Project quota type */\n"
"#define XFS_GROUP_QUOTA   (1E<lt>E<lt>2)  /* Group quota type */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/quotactl.2:493
#, no-wrap
msgid ""
"struct fs_disk_quota {\n"
"    int8_t   d_version;   /* Version of this structure */\n"
"    int8_t   d_flags;     /* XFS_{USER,PROJ,GROUP}_QUOTA */\n"
"    uint16_t d_fieldmask; /* Field specifier */\n"
"    uint32_t d_id;        /* User, project, or group ID */\n"
"    uint64_t d_blk_hardlimit; /* Absolute limit on\n"
"                                 disk blocks */\n"
"    uint64_t d_blk_softlimit; /* Preferred limit on\n"
"                                 disk blocks */\n"
"    uint64_t d_ino_hardlimit; /* Maximum # allocated\n"
"                                 inodes */\n"
"    uint64_t d_ino_softlimit; /* Preferred inode limit */\n"
"    uint64_t d_bcount;    /* # disk blocks owned by\n"
"                             the user */\n"
"    uint64_t d_icount;    /* # inodes owned by the user */\n"
"    int32_t  d_itimer;    /* Zero if within inode limits */\n"
"                          /* If not, we refuse service */\n"
"    int32_t  d_btimer;    /* Similar to above; for\n"
"                             disk blocks */\n"
"    uint16_t d_iwarns;    /* # warnings issued with\n"
"                             respect to # of inodes */\n"
"    uint16_t d_bwarns;    /* # warnings issued with\n"
"                             respect to disk blocks */\n"
"    int32_t  d_padding2;  /* Padding - for future use */\n"
"    uint64_t d_rtb_hardlimit; /* Absolute limit on realtime\n"
"                                 (RT) disk blocks */\n"
"    uint64_t d_rtb_softlimit; /* Preferred limit on RT\n"
"                                 disk blocks */\n"
"    uint64_t d_rtbcount;  /* # realtime blocks owned */\n"
"    int32_t  d_rtbtimer;  /* Similar to above; for RT\n"
"                             disk blocks */\n"
"    uint16_t d_rtbwarns;  /* # warnings issued with\n"
"                             respect to RT disk blocks */\n"
"    int16_t  d_padding3;  /* Padding - for future use */\n"
"    char     d_padding4[8];   /* Yet more padding */\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/quotactl.2:500
msgid ""
"Unprivileged users may retrieve only their own quotas; a privileged user "
"(B<CAP_SYS_ADMIN>)  may retrieve the quotas of any user."
msgstr ""

#. type: TP
#: man-pages/man2/quotactl.2:500
#, no-wrap
msgid "B<Q_XGETNEXTQUOTA> (since Linux 4.6)"
msgstr ""

#.  commit 8b37524962b9c54423374717786198f5c0820a28
#. type: Plain text
#: man-pages/man2/quotactl.2:521
msgid ""
"This operation is the same as B<Q_XGETQUOTA>, but it returns (in the "
"I<fs_disk_quota> structure pointed by I<addr>)  quota information for the "
"next ID greater than or equal to I<id> that has a quota set.  Note that "
"since I<fs_disk_quota> already has I<q_id> field, no separate structure type "
"is needed (in contrast with B<Q_GETQUOTA> and B<Q_GETNEXTQUOTA> commands)"
msgstr ""

#. type: TP
#: man-pages/man2/quotactl.2:521
#, no-wrap
msgid "B<Q_XSETQLIM>"
msgstr ""

#. type: Plain text
#: man-pages/man2/quotactl.2:532
msgid ""
"Set disk quota limits for user I<id>.  The I<addr> argument is a pointer to "
"an I<fs_disk_quota> structure.  This operation requires privilege "
"(B<CAP_SYS_ADMIN>)."
msgstr ""

#. type: TP
#: man-pages/man2/quotactl.2:532
#, no-wrap
msgid "B<Q_XGETQSTAT>"
msgstr ""

#. type: Plain text
#: man-pages/man2/quotactl.2:544
msgid ""
"Returns XFS filesystem-specific quota information in the I<fs_quota_stat> "
"structure pointed by I<addr>.  This is useful for finding out how much space "
"is used to store quota information, and also to get the quota on/off status "
"of a given local XFS filesystem.  The I<fs_quota_stat> structure itself is "
"defined as follows:"
msgstr ""

#. type: Plain text
#: man-pages/man2/quotactl.2:548
#, no-wrap
msgid "#define FS_QSTAT_VERSION 1  /* fs_quota_stat.qs_version */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/quotactl.2:555
#, no-wrap
msgid ""
"struct fs_qfilestat {\n"
"    uint64_t qfs_ino;       /* Inode number */\n"
"    uint64_t qfs_nblks;     /* Number of BBs\n"
"                               512-byte-blocks */\n"
"    uint32_t qfs_nextents;  /* Number of extents */\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/quotactl.2:573
#, no-wrap
msgid ""
"struct fs_quota_stat {\n"
"    int8_t   qs_version; /* Version number for\n"
"                            future changes */\n"
"    uint16_t qs_flags; /* XFS_QUOTA_{U,P,G}DQ_{ACCT,ENFD} */\n"
"    int8_t   qs_pad;   /* Unused */\n"
"    struct fs_qfilestat qs_uquota;  /* User quota storage\n"
"                                       information */\n"
"    struct fs_qfilestat qs_gquota;  /* Group quota storage\n"
"                                       information */\n"
"    uint32_t qs_incoredqs;   /* Number of dquots in core */\n"
"    int32_t  qs_btimelimit;  /* Limit for blocks timer */\n"
"    int32_t  qs_itimelimit;  /* Limit for inodes timer */\n"
"    int32_t  qs_rtbtimelimit;/* Limit for RT\n"
"                                blocks timer */\n"
"    uint16_t qs_bwarnlimit;  /* Limit for # of warnings */\n"
"    uint16_t qs_iwarnlimit;  /* Limit for # of warnings */\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/quotactl.2:579
msgid "The I<id> argument is ignored."
msgstr ""

#. type: TP
#: man-pages/man2/quotactl.2:579
#, no-wrap
msgid "B<Q_XGETQSTATV>"
msgstr ""

#. type: Plain text
#: man-pages/man2/quotactl.2:593
msgid ""
"Returns XFS filesystem-specific quota information in the I<fs_quota_statv> "
"pointed to by I<addr>.  This version of the command uses a structure with "
"proper versioning support, along with appropriate layout (all fields are "
"naturally aligned) and padding to avoiding special compat handling; it also "
"provides the ability to get statistics regarding the project quota file.  "
"The I<fs_quota_statv> structure itself is defined as follows:"
msgstr ""

#. type: Plain text
#: man-pages/man2/quotactl.2:597
#, no-wrap
msgid "#define FS_QSTATV_VERSION1 1 /* fs_quota_statv.qs_version */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/quotactl.2:605
#, no-wrap
msgid ""
"struct fs_qfilestatv {\n"
"    uint64_t qfs_ino;       /* Inode number */\n"
"    uint64_t qfs_nblks;     /* Number of BBs\n"
"                               512-byte-blocks */\n"
"    uint32_t qfs_nextents;  /* Number of extents */\n"
"    uint32_t qfs_pad;       /* Pad for 8-byte alignment */\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/quotactl.2:626
#, no-wrap
msgid ""
"struct fs_quota_statv {\n"
"    int8_t   qs_version;    /* Version for future\n"
"                               changes */\n"
"    uint8_t  qs_pad1;       /* Pad for 16-bit alignment */\n"
"    uint16_t qs_flags;      /* XFS_QUOTA_.* flags */\n"
"    uint32_t qs_incoredqs;  /* Number of dquots incore */\n"
"    struct fs_qfilestatv qs_uquota;  /* User quota\n"
"                                        information */\n"
"    struct fs_qfilestatv qs_gquota;  /* Group quota\n"
"                                        information */\n"
"    struct fs_qfilestatv qs_pquota;  /* Project quota\n"
"                                        information */\n"
"    int32_t  qs_btimelimit;   /* Limit for blocks timer */\n"
"    int32_t  qs_itimelimit;   /* Limit for inodes timer */\n"
"    int32_t  qs_rtbtimelimit; /* Limit for RT blocks\n"
"                                 timer */\n"
"    uint16_t qs_bwarnlimit;   /* Limit for # of warnings */\n"
"    uint16_t qs_iwarnlimit;   /* Limit for # of warnings */\n"
"    uint64_t qs_pad2[8];      /* For future proofing */\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/quotactl.2:640
msgid ""
"The I<qs_version> field of the structure should be filled with the version "
"of the structure supported by the callee (for now, only I<FS_QSTAT_VERSION1> "
"is supported).  The kernel will fill the structure in accordance with "
"version provided.  The I<id> argument is ignored."
msgstr ""

#. type: TP
#: man-pages/man2/quotactl.2:640
#, no-wrap
msgid "B<Q_XQUOTARM>"
msgstr ""

#. type: Plain text
#: man-pages/man2/quotactl.2:655
msgid ""
"Free the disk space taken by disk quotas. The I<addr> argument should be a "
"pointer to an I<unsigned int> value containing flags (the same as in "
"I<d_flags> field of I<fs_disk_quota> structure) which identify what types of "
"quota should be removed (note that the quota type passed in the I<cmd> "
"argument is ignored, but should remain valid in order to pass preliminary "
"quotactl syscall handler checks)."
msgstr ""

#. type: Plain text
#: man-pages/man2/quotactl.2:660
msgid "Quotas must have already been turned off.  The I<id> argument is ignored."
msgstr ""

#. type: TP
#: man-pages/man2/quotactl.2:660
#, no-wrap
msgid "B<Q_XQUOTASYNC> (since Linux 2.6.15; no-op since Linux 3.4)"
msgstr ""

#.  Added in commit ee34807a65aa0c5911dc27682863afca780a003e
#.  4b217ed9e30f94b6e8e5e262020ef0ceab6113af
#. type: Plain text
#: man-pages/man2/quotactl.2:674
msgid ""
"This command was an XFS quota equivalent to I<Q_SYNC>, but it is no-op since "
"Linux 3.4, as B<sync>(1)  writes quota information to disk now (in addition "
"to the other filesystem metadata that it writes out).  The I<special>, I<id> "
"and I<addr> arguments are ignored."
msgstr ""

#. type: Plain text
#: man-pages/man2/quotactl.2:682
msgid ""
"On success, B<quotactl>()  returns 0; on error -1 is returned, and I<errno> "
"is set to indicate the error."
msgstr ""

#. type: Plain text
#: man-pages/man2/quotactl.2:693
msgid ""
"I<cmd> is B<Q_QUOTAON>, and the quota file pointed to by I<addr> exists, but "
"is not a regular file or is not on the filesystem pointed to by I<special>."
msgstr ""

#. type: Plain text
#: man-pages/man2/quotactl.2:701
msgid "I<cmd> is B<Q_QUOTAON>, but another B<Q_QUOTAON> had already been performed."
msgstr ""

#. type: Plain text
#: man-pages/man2/quotactl.2:707
msgid "I<addr> or I<special> is invalid."
msgstr ""

#. type: Plain text
#: man-pages/man2/quotactl.2:713
msgid "I<cmd> or I<type> is invalid."
msgstr ""

#. type: Plain text
#: man-pages/man2/quotactl.2:719
msgid "I<cmd> is B<Q_QUOTAON>, but the specified quota file is corrupted."
msgstr ""

#. type: Plain text
#: man-pages/man2/quotactl.2:726
msgid "The file specified by I<special> or I<addr> does not exist."
msgstr ""

#. type: Plain text
#: man-pages/man2/quotactl.2:731
msgid "The kernel has not been compiled with the B<CONFIG_QUOTA> option."
msgstr ""

#. type: Plain text
#: man-pages/man2/quotactl.2:735
msgid "I<special> is not a block device."
msgstr ""

#. type: Plain text
#: man-pages/man2/quotactl.2:740
msgid ""
"The caller lacked the required privilege (B<CAP_SYS_ADMIN>)  for the "
"specified operation."
msgstr ""

#. type: Plain text
#: man-pages/man2/quotactl.2:746
msgid ""
"I<cmd> is B<Q_SETQUOTA>, but the specified limits are out of the range "
"allowed by the quota format."
msgstr ""

#. type: Plain text
#: man-pages/man2/quotactl.2:750
msgid ""
"No disk quota is found for the indicated user.  Quotas have not been turned "
"on for this filesystem."
msgstr ""

#. type: Plain text
#: man-pages/man2/quotactl.2:756
msgid "I<cmd> is B<Q_QUOTAON>, but the specified quota format was not found."
msgstr ""

#. type: Plain text
#: man-pages/man2/quotactl.2:766
msgid ""
"I<cmd> is B<Q_GETNEXTQUOTA> or B<Q_XGETNEXTQUOTA>, but there is no ID "
"greater than or equal to I<id> that has an active quota."
msgstr ""

#. type: Plain text
#: man-pages/man2/quotactl.2:772
msgid ""
"Instead of I<E<lt>xfs/xqm.hE<gt>> one can use "
"I<E<lt>linux/dqblk_xfs.hE<gt>>, taking into account that there are several "
"naming discrepancies:"
msgstr ""

#. type: Plain text
#: man-pages/man2/quotactl.2:777
msgid ""
"Quota enabling flags (of format B<XFS_QUOTA_[UGP]DQ_{ACCT,ENFD}>)  are "
"defined without a leading \"X\", as B<FS_QUOTA_[UGP]DQ_{ACCT,ENFD}>."
msgstr ""

#. type: Plain text
#: man-pages/man2/quotactl.2:782
msgid ""
"The same is true for B<XFS_{USER,GROUP,PROJ}_QUOTA> quota type flags, which "
"are defined as B<FS_{USER,GROUP,PROJ}_QUOTA>."
msgstr ""

#. type: Plain text
#: man-pages/man2/quotactl.2:794
msgid ""
"The I<dqblk_xfs.h> header file defines its own B<XQM_USRQUOTA>, "
"B<XQM_GRPQUOTA>, and B<XQM_PRJQUOTA> constants for the available quota "
"types, but their values are the same as for constants without the B<XQM_> "
"prefix."
msgstr ""

#. type: Plain text
#: man-pages/man2/quotactl.2:798
msgid "B<quota>(1), B<getrlimit>(2), B<quotacheck>(8), B<quotaon>(8)"
msgstr ""

#. type: TH
#: man-pages/man2/modify_ldt.2:25
#, no-wrap
msgid "MODIFY_LDT"
msgstr ""

#. type: Plain text
#: man-pages/man2/modify_ldt.2:28
msgid "modify_ldt - get or set a per-process LDT entry"
msgstr ""

#. type: Plain text
#: man-pages/man2/modify_ldt.2:33
#, no-wrap
msgid ""
"B<int modify_ldt(int >I<func>B<, void *>I<ptr>B<, unsigned long "
">I<bytecount>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/modify_ldt.2:45
msgid ""
"B<modify_ldt>()  reads or writes the local descriptor table (LDT) for a "
"process.  The LDT is an array of segment descriptors that can be referenced "
"by user code.  Linux allows processes to configure a per-process (actually "
"per-mm) LDT.  For more information about the LDT, see the Intel Software "
"Developer's Manual or the AMD Architecture Programming Manual."
msgstr ""

#. type: Plain text
#: man-pages/man2/modify_ldt.2:59
msgid ""
"When I<func> is 0, B<modify_ldt>()  reads the LDT into the memory pointed to "
"by I<ptr>.  The number of bytes read is the smaller of I<bytecount> and the "
"actual size of the LDT, although the kernel may act as though the LDT is "
"padded with additional trailing zero bytes.  On success, B<modify_ldt>()  "
"will return the number of bytes read."
msgstr ""

#. type: Plain text
#: man-pages/man2/modify_ldt.2:73
msgid ""
"When I<func> is 1 or 0x11, B<modify_ldt>()  modifies the LDT entry indicated "
"by I<ptr-E<gt>entry_number>.  I<ptr> points to a I<user_desc> structure and "
"I<bytecount> must equal the size of this structure."
msgstr ""

#. type: Plain text
#: man-pages/man2/modify_ldt.2:77
msgid "The I<user_desc> structure is defined in I<E<lt>asm/ldt.hE<gt>> as:"
msgstr ""

#. type: Plain text
#: man-pages/man2/modify_ldt.2:91
#, no-wrap
msgid ""
"struct user_desc {\n"
"    unsigned int  entry_number;\n"
"    unsigned long base_addr;\n"
"    unsigned int  limit;\n"
"    unsigned int  seg_32bit:1;\n"
"    unsigned int  contents:2;\n"
"    unsigned int  read_exec_only:1;\n"
"    unsigned int  limit_in_pages:1;\n"
"    unsigned int  seg_not_present:1;\n"
"    unsigned int  useable:1;\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/modify_ldt.2:96
msgid "In Linux 2.4 and earlier, this structure was named I<modify_ldt_ldt_s>."
msgstr ""

#. type: Plain text
#: man-pages/man2/modify_ldt.2:104
msgid ""
"The I<contents> field is the segment type (data, expand-down data, "
"non-conforming code, or conforming code).  The other fields match their "
"descriptions in the CPU manual, although B<modify_ldt>()  cannot set the "
"hardware-defined \"accessed\" bit described in the CPU manual."
msgstr ""

#. type: Plain text
#: man-pages/man2/modify_ldt.2:121
msgid ""
"A I<user_desc> is considered \"empty\" if I<read_exec_only> and "
"I<seg_not_present> are set to 1 and all of the other fields are 0.  An LDT "
"entry can be cleared by setting it to an \"empty\" I<user_desc> or, if "
"I<func> is 1, by setting both I<base> and I<limit> to 0."
msgstr ""

#. type: Plain text
#: man-pages/man2/modify_ldt.2:130
msgid ""
"A conforming code segment (i.e., one with I<contents==3>)  will be rejected "
"if I<func> is 1 or if I<seg_not_present> is 0."
msgstr ""

#. type: Plain text
#: man-pages/man2/modify_ldt.2:137
msgid ""
"When I<func> is 2, B<modify_ldt>()  will read zeros.  This appears to be a "
"leftover from Linux 2.4."
msgstr ""

#. type: Plain text
#: man-pages/man2/modify_ldt.2:147
msgid ""
"On success, B<modify_ldt>()  returns either the actual number of bytes read "
"(for reading)  or 0 (for writing).  On failure, B<modify_ldt>()  returns -1 "
"and sets I<errno> to indicate the error."
msgstr ""

#. type: Plain text
#: man-pages/man2/modify_ldt.2:152
msgid "I<ptr> points outside the address space."
msgstr ""

#. type: Plain text
#: man-pages/man2/modify_ldt.2:165
msgid ""
"I<ptr> is 0, or I<func> is 1 and I<bytecount> is not equal to the size of "
"the structure I<user_desc>, or I<func> is 1 or 0x11 and the new LDT entry "
"has invalid values."
msgstr ""

#. type: Plain text
#: man-pages/man2/modify_ldt.2:169
msgid "I<func> is neither 0, 1, 2, nor 0x11."
msgstr ""

#. type: Plain text
#: man-pages/man2/modify_ldt.2:172
msgid ""
"This call is Linux-specific and should not be used in programs intended to "
"be portable."
msgstr ""

#. type: Plain text
#: man-pages/man2/modify_ldt.2:185
msgid ""
"B<modify_ldt>()  should not be used for thread-local storage, as it slows "
"down context switches and only supports a limited number of threads.  "
"Threading libraries should use B<set_thread_area>(2)  or B<arch_prctl>(2)  "
"instead, except on extremely old kernels that do not support those system "
"calls."
msgstr ""

#. type: Plain text
#: man-pages/man2/modify_ldt.2:190
msgid ""
"The normal use for B<modify_ldt>()  is to run legacy 16-bit or segmented "
"32-bit code.  Not all kernels allow 16-bit segments to be installed, "
"however."
msgstr ""

#. type: Plain text
#: man-pages/man2/modify_ldt.2:198
msgid ""
"Even on 64-bit kernels, B<modify_ldt>()  cannot be used to create a long "
"mode (i.e., 64-bit) code segment.  The undocumented field \"lm\" in "
"I<user_desc> is not useful, and, despite its name, does not result in a long "
"mode segment."
msgstr ""

#.  commit e30ab185c490e9a9381385529e0fd32f0a399495
#. type: Plain text
#: man-pages/man2/modify_ldt.2:207
msgid ""
"On 64-bit kernels before Linux 3.19, setting the \"lm\" bit in I<user_desc> "
"prevents the descriptor from being considered empty.  Keep in mind that the "
"\"lm\" bit does not exist in the 32-bit headers, but these buggy kernels "
"will still notice the bit even when set in a 32-bit process."
msgstr ""

#. type: Plain text
#: man-pages/man2/modify_ldt.2:210
msgid "B<arch_prctl>(2), B<set_thread_area>(2), B<vm86>(2)"
msgstr ""

#. type: TH
#: man-pages/man2/sgetmask.2:26
#, no-wrap
msgid "SGETMASK"
msgstr ""

#. type: Plain text
#: man-pages/man2/sgetmask.2:29
msgid "sgetmask, ssetmask - manipulation of signal mask (obsolete)"
msgstr ""

#. type: Plain text
#: man-pages/man2/sgetmask.2:31
msgid "B<long sgetmask(void);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/sgetmask.2:33
msgid "B<long ssetmask(long >I<newmask>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/sgetmask.2:42
msgid ""
"These system calls are obsolete.  I<Do not use them>; use B<sigprocmask>(2)  "
"instead."
msgstr ""

#. type: Plain text
#: man-pages/man2/sgetmask.2:45
msgid "B<sgetmask>()  returns the signal mask of the calling process."
msgstr ""

#. type: Plain text
#: man-pages/man2/sgetmask.2:50
msgid ""
"B<ssetmask>()  sets the signal mask of the calling process to the value "
"given in I<newmask>.  The previous signal mask is returned."
msgstr ""

#. type: Plain text
#: man-pages/man2/sgetmask.2:59
msgid ""
"The signal masks dealt with by these two system calls are plain bit masks "
"(unlike the I<sigset_t> used by B<sigprocmask>(2)); use B<sigmask>(3)  to "
"create and inspect these masks."
msgstr ""

#. type: Plain text
#: man-pages/man2/sgetmask.2:64
msgid ""
"B<sgetmask>()  always successfully returns the signal mask.  B<ssetmask>()  "
"always succeeds, and returns the previous signal mask."
msgstr ""

#. type: Plain text
#: man-pages/man2/sgetmask.2:66
msgid "These system calls always succeed."
msgstr ""

#.  f6187769dae48234f3877df3c4d99294cc2254fa
#. type: Plain text
#: man-pages/man2/sgetmask.2:73
msgid ""
"Since Linux 3.16, support for these system calls is optional, depending on "
"whether the kernel was built with the B<CONFIG_SGETMASK_SYSCALL> option."
msgstr ""

#. type: Plain text
#: man-pages/man2/sgetmask.2:79
msgid ""
"Glibc does not provide wrappers for these obsolete system calls; in the "
"unlikely event that you want to call them, use B<syscall>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/sgetmask.2:82
msgid ""
"These system calls are unaware of signal numbers greater than 31 (i.e., "
"real-time signals)."
msgstr ""

#. type: Plain text
#: man-pages/man2/sgetmask.2:84
msgid "These system calls do not exist on x86-64."
msgstr ""

#. type: Plain text
#: man-pages/man2/sgetmask.2:89
msgid "It is not possible to block B<SIGSTOP> or B<SIGKILL>."
msgstr ""

#. type: Plain text
#: man-pages/man2/sgetmask.2:91
msgid "B<sigprocmask>(2), B<signal>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/ustat.2:30
#, no-wrap
msgid "USTAT"
msgstr ""

#. type: Plain text
#: man-pages/man2/ustat.2:33
msgid "ustat - get filesystem statistics"
msgstr ""

#. type: Plain text
#: man-pages/man2/ustat.2:38
#, no-wrap
msgid ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>unistd.hE<gt>>    /* libc[45] */\n"
"B<#include E<lt>ustat.hE<gt>>     /* glibc2 */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/ustat.2:40
#, no-wrap
msgid "B<int ustat(dev_t >I<dev>B<, struct ustat *>I<ubuf>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/ustat.2:52
msgid ""
"B<ustat>()  returns information about a mounted filesystem.  I<dev> is a "
"device number identifying a device containing a mounted filesystem.  I<ubuf> "
"is a pointer to a I<ustat> structure that contains the following members:"
msgstr ""

#. type: Plain text
#: man-pages/man2/ustat.2:59
#, no-wrap
msgid ""
"daddr_t f_tfree;      /* Total free blocks */\n"
"ino_t   f_tinode;     /* Number of free inodes */\n"
"char    f_fname[6];   /* Filsys name */\n"
"char    f_fpack[6];   /* Filsys pack name */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/ustat.2:68
msgid ""
"The last two fields, I<f_fname> and I<f_fpack>, are not implemented and will "
"always be filled with null bytes (\\(aq\\e0\\(aq)."
msgstr ""

#. type: Plain text
#: man-pages/man2/ustat.2:77
msgid ""
"On success, zero is returned and the I<ustat> structure pointed to by "
"I<ubuf> will be filled in.  On error, -1 is returned, and I<errno> is set "
"appropriately."
msgstr ""

#. type: Plain text
#: man-pages/man2/ustat.2:82
msgid "I<ubuf> points outside of your accessible address space."
msgstr ""

#. type: Plain text
#: man-pages/man2/ustat.2:86
msgid "I<dev> does not refer to a device containing a mounted filesystem."
msgstr ""

#. type: Plain text
#: man-pages/man2/ustat.2:92
msgid ""
"The mounted filesystem referenced by I<dev> does not support this operation, "
"or any version of Linux before 1.3.16."
msgstr ""

#. type: Plain text
#: man-pages/man2/ustat.2:94
msgid "Since version 2.28, glibc no longer provides a wrapper for this system call."
msgstr ""

#. type: Plain text
#: man-pages/man2/ustat.2:104
msgid ""
"B<ustat>()  is deprecated and has been provided only for compatibility.  All "
"new programs should use B<statfs>(2)  instead."
msgstr ""

#. type: SS
#: man-pages/man2/ustat.2:104
#, no-wrap
msgid "HP-UX notes"
msgstr ""

#.  Some software tries to use this in order to test whether the
#.  underlying filesystem is NFS.
#. type: Plain text
#: man-pages/man2/ustat.2:118
msgid ""
"The HP-UX version of the I<ustat> structure has an additional field, "
"I<f_blksize>, that is unknown elsewhere.  HP-UX warns: For some filesystems, "
"the number of free inodes does not change.  Such filesystems will return -1 "
"in the field I<f_tinode>.  For some filesystems, inodes are dynamically "
"allocated.  Such filesystems will return the current number of free inodes."
msgstr ""

#. type: Plain text
#: man-pages/man2/ustat.2:120
msgid "B<stat>(2), B<statfs>(2)"
msgstr ""

#. type: TH
#: man-pages/man2/gettimeofday.2:40
#, no-wrap
msgid "GETTIMEOFDAY"
msgstr ""

#. type: Plain text
#: man-pages/man2/gettimeofday.2:43
msgid "gettimeofday, settimeofday - get / set time"
msgstr ""

#. type: Plain text
#: man-pages/man2/gettimeofday.2:48
#, no-wrap
msgid "B<int gettimeofday(struct timeval *>I<tv>B<, struct timezone *>I<tz>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/gettimeofday.2:51
#, no-wrap
msgid ""
"B<int settimeofday(const struct timeval *>I<tv>B<, const struct timezone "
"*>I<tz>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/gettimeofday.2:63
#, no-wrap
msgid ""
"B<settimeofday>():\n"
"    Since glibc 2.19:\n"
"        _DEFAULT_SOURCE\n"
"    Glibc 2.19 and earlier:\n"
"        _BSD_SOURCE\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/gettimeofday.2:75
msgid ""
"The functions B<gettimeofday>()  and B<settimeofday>()  can get and set the "
"time as well as a timezone.  The I<tv> argument is a I<struct timeval> (as "
"specified in I<E<lt>sys/time.hE<gt>>):"
msgstr ""

#. type: Plain text
#: man-pages/man2/gettimeofday.2:82
#, no-wrap
msgid ""
"struct timeval {\n"
"    time_t      tv_sec;     /* seconds */\n"
"    suseconds_t tv_usec;    /* microseconds */\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/gettimeofday.2:91
msgid ""
"and gives the number of seconds and microseconds since the Epoch (see "
"B<time>(2)).  The I<tz> argument is a I<struct timezone>:"
msgstr ""

#. type: Plain text
#: man-pages/man2/gettimeofday.2:98
#, no-wrap
msgid ""
"struct timezone {\n"
"    int tz_minuteswest;     /* minutes west of Greenwich */\n"
"    int tz_dsttime;         /* type of DST correction */\n"
"};\n"
msgstr ""

#.  FIXME . The compilation warning looks to be going away in 2.17
#.  see glibc commit 4b7634a5e03b0da6f8875de9d3f74c1cf6f2a6e8
#.  The following is covered under EPERM below:
#.  .PP
#.  Only the superuser may use
#.  .BR settimeofday ().
#. type: Plain text
#: man-pages/man2/gettimeofday.2:115
msgid ""
"If either I<tv> or I<tz> is NULL, the corresponding structure is not set or "
"returned.  (However, compilation warnings will result if I<tv> is NULL.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/gettimeofday.2:122
msgid ""
"The use of the I<timezone> structure is obsolete; the I<tz> argument should "
"normally be specified as NULL.  (See NOTES below.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/gettimeofday.2:141
msgid ""
"Under Linux, there are some peculiar \"warp clock\" semantics associated "
"with the B<settimeofday>()  system call if on the very first call (after "
"booting)  that has a non-NULL I<tz> argument, the I<tv> argument is NULL and "
"the I<tz_minuteswest> field is nonzero.  (The I<tz_dsttime> field should be "
"zero for this case.)  In such a case it is assumed that the CMOS clock is on "
"local time, and that it has to be incremented by this amount to get UTC "
"system time.  No doubt it is a bad idea to use this feature."
msgstr ""

#. type: Plain text
#: man-pages/man2/gettimeofday.2:148
msgid ""
"B<gettimeofday>()  and B<settimeofday>()  return 0 for success, or -1 for "
"failure (in which case I<errno> is set appropriately)."
msgstr ""

#. type: Plain text
#: man-pages/man2/gettimeofday.2:156
msgid "One of I<tv> or I<tz> pointed outside the accessible address space."
msgstr ""

#. type: Plain text
#: man-pages/man2/gettimeofday.2:161
msgid "(B<settimeofday>()): I<timezone> is invalid."
msgstr ""

#. type: Plain text
#: man-pages/man2/gettimeofday.2:168
msgid ""
"(B<settimeofday>()): I<tv.tv_sec> is negative or I<tv.tv_usec> is outside "
"the range [0..999,999]."
msgstr ""

#. type: TP
#: man-pages/man2/gettimeofday.2:168 man-pages/man2/clock_getres.2:221
#, no-wrap
msgid "B<EINVAL> (since Linux 4.3)"
msgstr ""

#.  commit e1d7ba8735551ed79c7a0463a042353574b96da3
#. type: Plain text
#: man-pages/man2/gettimeofday.2:177
msgid ""
"(B<settimeofday>()): An attempt was made to set the time to a value less "
"than the current value of the B<CLOCK_MONOTONIC> clock (see "
"B<clock_gettime>(2))."
msgstr ""

#. type: Plain text
#: man-pages/man2/gettimeofday.2:184
msgid ""
"The calling process has insufficient privilege to call B<settimeofday>(); "
"under Linux the B<CAP_SYS_TIME> capability is required."
msgstr ""

#. type: Plain text
#: man-pages/man2/gettimeofday.2:195
msgid ""
"SVr4, 4.3BSD.  POSIX.1-2001 describes B<gettimeofday>()  but not "
"B<settimeofday>().  POSIX.1-2008 marks B<gettimeofday>()  as obsolete, "
"recommending the use of B<clock_gettime>(2)  instead."
msgstr ""

#. type: Plain text
#: man-pages/man2/gettimeofday.2:203
msgid ""
"The time returned by B<gettimeofday>()  I<is> affected by discontinuous "
"jumps in the system time (e.g., if the system administrator manually changes "
"the system time).  If you need a monotonically increasing clock, see "
"B<clock_gettime>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/gettimeofday.2:208
msgid ""
"Macros for operating on I<timeval> structures are described in "
"B<timeradd>(3)."
msgstr ""

#. type: Plain text
#: man-pages/man2/gettimeofday.2:214
msgid "Traditionally, the fields of I<struct timeval> were of type I<long>."
msgstr ""

#. type: Plain text
#: man-pages/man2/gettimeofday.2:220
msgid ""
"On some architectures, an implementation of B<gettimeofday>()  is provided "
"in the B<vdso>(7)."
msgstr ""

#. type: SS
#: man-pages/man2/gettimeofday.2:220
#, no-wrap
msgid "The tz_dsttime field"
msgstr ""

#.  it has not
#.  been and will not be supported by libc or glibc.
#.  Each and every occurrence of this field in the kernel source
#.  (other than the declaration) is a bug.
#. type: Plain text
#: man-pages/man2/gettimeofday.2:245
msgid ""
"On a non-Linux kernel, with glibc, the I<tz_dsttime> field of I<struct "
"timezone> will be set to a nonzero value by B<gettimeofday>()  if the "
"current timezone has ever had or will have a daylight saving rule applied.  "
"In this sense it exactly mirrors the meaning of B<daylight>(3)  for the "
"current zone.  On Linux, with glibc, the setting of the I<tz_dsttime> field "
"of I<struct timezone> has never been used by B<settimeofday>()  or "
"B<gettimeofday>().  Thus, the following is purely of historical interest."
msgstr ""

#. type: Plain text
#: man-pages/man2/gettimeofday.2:255
msgid ""
"On old systems, the field I<tz_dsttime> contains a symbolic constant (values "
"are given below)  that indicates in which part of the year Daylight Saving "
"Time is in force.  (Note: this value is constant throughout the year: it "
"does not indicate that DST is in force, it just selects an algorithm.)  The "
"daylight saving time algorithms defined are as follows:"
msgstr ""

#. type: Plain text
#: man-pages/man2/gettimeofday.2:269
#, no-wrap
msgid ""
"B<DST_NONE>     /* not on DST */\n"
"B<DST_USA>      /* USA style DST */\n"
"B<DST_AUST>     /* Australian style DST */\n"
"B<DST_WET>      /* Western European DST */\n"
"B<DST_MET>      /* Middle European DST */\n"
"B<DST_EET>      /* Eastern European DST */\n"
"B<DST_CAN>      /* Canada */\n"
"B<DST_GB>       /* Great Britain and Eire */\n"
"B<DST_RUM>      /* Romania */\n"
"B<DST_TUR>      /* Turkey */\n"
"B<DST_AUSTALT>  /* Australian style with shift in 1986 */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/gettimeofday.2:279
msgid ""
"Of course it turned out that the period in which Daylight Saving Time is in "
"force cannot be given by a simple algorithm, one per country; indeed, this "
"period is determined by unpredictable political decisions.  So this method "
"of representing timezones has been abandoned."
msgstr ""

#. type: Plain text
#: man-pages/man2/gettimeofday.2:290
msgid ""
"B<date>(1), B<adjtimex>(2), B<clock_gettime>(2), B<time>(2), B<ctime>(3), "
"B<ftime>(3), B<timeradd>(3), B<capabilities>(7), B<time>(7), B<vdso>(7), "
"B<hwclock>(8)"
msgstr ""

#. type: TH
#: man-pages/man2/sendfile.2:19
#, no-wrap
msgid "SENDFILE"
msgstr ""

#. type: Plain text
#: man-pages/man2/sendfile.2:22
msgid "sendfile - transfer data between file descriptors"
msgstr ""

#. type: Plain text
#: man-pages/man2/sendfile.2:24
msgid "B<#include E<lt>sys/sendfile.hE<gt>>"
msgstr ""

#.  The below is too ugly. Comments about glibc versions belong
#.  in the notes, not in the header.
#
#.  .B #include <features.h>
#.  .br
#.  .B #if (__GLIBC__==2 && __GLIBC_MINOR__>=1) || __GLIBC__>2
#.  .br
#.  .B #include <sys/sendfile.h>
#.  .br
#.  #else
#.  .br
#.  .B #include <sys/types.h>
#.  .br
#.  .B /* No system prototype before glibc 2.1. */
#.  .br
#.  .BI "ssize_t sendfile(int" " out_fd" ", int" " in_fd" ", off_t *" \
#.                        offset ", size_t" " count" )
#.  .br
#.  .B #endif
#. type: Plain text
#: man-pages/man2/sendfile.2:47
msgid ""
"B<ssize_t sendfile(int>I< out_fd>B<, int>I< in_fd>B<, off_t *>I<offset>B<, "
"size_t>I< count>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/sendfile.2:57
msgid ""
"B<sendfile>()  copies data between one file descriptor and another.  Because "
"this copying is done within the kernel, B<sendfile>()  is more efficient "
"than the combination of B<read>(2)  and B<write>(2), which would require "
"transferring data to and from user space."
msgstr ""

#. type: Plain text
#: man-pages/man2/sendfile.2:62
msgid ""
"I<in_fd> should be a file descriptor opened for reading and I<out_fd> should "
"be a descriptor opened for writing."
msgstr ""

#. type: Plain text
#: man-pages/man2/sendfile.2:83
msgid ""
"If I<offset> is not NULL, then it points to a variable holding the file "
"offset from which B<sendfile>()  will start reading data from I<in_fd>.  "
"When B<sendfile>()  returns, this variable will be set to the offset of the "
"byte following the last byte that was read.  If I<offset> is not NULL, then "
"B<sendfile>()  does not modify the file offset of I<in_fd>; otherwise the "
"file offset is adjusted to reflect the number of bytes read from I<in_fd>."
msgstr ""

#. type: Plain text
#: man-pages/man2/sendfile.2:90
msgid ""
"If I<offset> is NULL, then data will be read from I<in_fd> starting at the "
"file offset, and the file offset will be updated by the call."
msgstr ""

#. type: Plain text
#: man-pages/man2/sendfile.2:93
msgid "I<count> is the number of bytes to copy between the file descriptors."
msgstr ""

#. type: Plain text
#: man-pages/man2/sendfile.2:100
msgid ""
"The I<in_fd> argument must correspond to a file which supports "
"B<mmap>(2)-like operations (i.e., it cannot be a socket)."
msgstr ""

#. type: Plain text
#: man-pages/man2/sendfile.2:108
msgid ""
"In Linux kernels before 2.6.33, I<out_fd> must refer to a socket.  Since "
"Linux 2.6.33 it can be any file.  If it is a regular file, then "
"B<sendfile>()  changes the file offset appropriately."
msgstr ""

#. type: Plain text
#: man-pages/man2/sendfile.2:117
msgid ""
"If the transfer was successful, the number of bytes written to I<out_fd> is "
"returned.  Note that a successful call to B<sendfile>()  may write fewer "
"bytes than requested; the caller should be prepared to retry the call if "
"there were unsent bytes.  See also NOTES."
msgstr ""

#. type: Plain text
#: man-pages/man2/sendfile.2:127
msgid ""
"Nonblocking I/O has been selected using B<O_NONBLOCK> and the write would "
"block."
msgstr ""

#. type: Plain text
#: man-pages/man2/sendfile.2:131
msgid ""
"The input file was not opened for reading or the output file was not opened "
"for writing."
msgstr ""

#. type: Plain text
#: man-pages/man2/sendfile.2:134 man-pages/man2/stat.2:394
msgid "Bad address."
msgstr ""

#. type: Plain text
#: man-pages/man2/sendfile.2:143
msgid ""
"Descriptor is not valid or locked, or an B<mmap>(2)-like operation is not "
"available for I<in_fd>, or I<count> is negative."
msgstr ""

#. type: Plain text
#: man-pages/man2/sendfile.2:151
msgid ""
"I<out_fd> has the B<O_APPEND> flag set.  This is not currently supported by "
"B<sendfile>()."
msgstr ""

#. type: Plain text
#: man-pages/man2/sendfile.2:155
msgid "Unspecified error while reading from I<in_fd>."
msgstr ""

#. type: Plain text
#: man-pages/man2/sendfile.2:159
msgid "Insufficient memory to read from I<in_fd>."
msgstr ""

#. type: Plain text
#: man-pages/man2/sendfile.2:164
msgid ""
"I<count> is too large, the operation would result in exceeding the maximum "
"size of either the input file or the output file."
msgstr ""

#. type: Plain text
#: man-pages/man2/sendfile.2:169
msgid "I<offset> is not NULL but the input file is not B<seek>(2)-able."
msgstr ""

#. type: Plain text
#: man-pages/man2/sendfile.2:175
msgid ""
"B<sendfile>()  first appeared in Linux 2.2.  The include file "
"I<E<lt>sys/sendfile.hE<gt>> is present since glibc 2.1."
msgstr ""

#. type: Plain text
#: man-pages/man2/sendfile.2:177
msgid "Not specified in POSIX.1-2001, nor in other standards."
msgstr ""

#. type: Plain text
#: man-pages/man2/sendfile.2:182
msgid ""
"Other UNIX systems implement B<sendfile>()  with different semantics and "
"prototypes.  It should not be used in portable programs."
msgstr ""

#.  commit e28cc71572da38a5a12c1cfe4d7032017adccf69
#. type: Plain text
#: man-pages/man2/sendfile.2:188
msgid ""
"B<sendfile>()  will transfer at most 0x7ffff000 (2,147,479,552) bytes, "
"returning the number of bytes actually transferred.  (This is true on both "
"32-bit and 64-bit systems.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/sendfile.2:198
msgid ""
"If you plan to use B<sendfile>()  for sending files to a TCP socket, but "
"need to send some header data in front of the file contents, you will find "
"it useful to employ the B<TCP_CORK> option, described in B<tcp>(7), to "
"minimize the number of packets and to tune performance."
msgstr ""

#. type: Plain text
#: man-pages/man2/sendfile.2:204
msgid ""
"In Linux 2.4 and earlier, I<out_fd> could also refer to a regular file; this "
"possibility went away in the Linux 2.6.x kernel series, but was restored in "
"Linux 2.6.33."
msgstr ""

#. type: Plain text
#: man-pages/man2/sendfile.2:216
msgid ""
"The original Linux B<sendfile>()  system call was not designed to handle "
"large file offsets.  Consequently, Linux 2.4 added B<sendfile64>(), with a "
"wider type for the I<offset> argument.  The glibc B<sendfile>()  wrapper "
"function transparently deals with the kernel differences."
msgstr ""

#. type: Plain text
#: man-pages/man2/sendfile.2:225
msgid ""
"Applications may wish to fall back to B<read>(2)/B<write>(2)  in the case "
"where B<sendfile>()  fails with B<EINVAL> or B<ENOSYS>."
msgstr ""

#. type: Plain text
#: man-pages/man2/sendfile.2:234
msgid ""
"If I<out_fd> refers to a socket or pipe with zero-copy support, callers must "
"ensure the transferred portions of the file referred to by I<in_fd> remain "
"unmodified until the reader on the other end of I<out_fd> has consumed the "
"transferred data."
msgstr ""

#. type: Plain text
#: man-pages/man2/sendfile.2:239
msgid ""
"The Linux-specific B<splice>(2)  call supports transferring data between "
"arbitrary file descriptors provided one (or both) of them is a pipe."
msgstr ""

#. type: Plain text
#: man-pages/man2/sendfile.2:244
msgid "B<copy_file_range>(2), B<mmap>(2), B<open>(2), B<socket>(2), B<splice>(2)"
msgstr ""

#. type: TH
#: man-pages/man2/getuid.2:26
#, no-wrap
msgid "GETUID"
msgstr ""

#. type: Plain text
#: man-pages/man2/getuid.2:29
msgid "getuid, geteuid - get user identity"
msgstr ""

#. type: Plain text
#: man-pages/man2/getuid.2:35
msgid "B<uid_t getuid(void);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/getuid.2:37
msgid "B<uid_t geteuid(void);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/getuid.2:40
msgid "B<getuid>()  returns the real user ID of the calling process."
msgstr ""

#. type: Plain text
#: man-pages/man2/getuid.2:43
msgid "B<geteuid>()  returns the effective user ID of the calling process."
msgstr ""

#. type: SS
#: man-pages/man2/getuid.2:48 man-pages/man2/sigaltstack.2:282
#: man-pages/man2/vfork.2:292
#, no-wrap
msgid "History"
msgstr ""

#. type: Plain text
#: man-pages/man2/getuid.2:57
msgid ""
"In UNIX\\ V6 the B<getuid>()  call returned I<(euid E<lt>E<lt> 8) + uid>.  "
"UNIX\\ V7 introduced separate calls B<getuid>()  and B<geteuid>()."
msgstr ""

#. type: Plain text
#: man-pages/man2/getuid.2:73
msgid ""
"The original Linux B<getuid>()  and B<geteuid>()  system calls supported "
"only 16-bit user IDs.  Subsequently, Linux 2.4 added B<getuid32>()  and "
"B<geteuid32>(), supporting 32-bit IDs.  The glibc B<getuid>()  and "
"B<geteuid>()  wrapper functions transparently deal with the variations "
"across kernel versions."
msgstr ""

#. type: Plain text
#: man-pages/man2/getuid.2:89
msgid ""
"On Alpha, instead of a pair of B<getuid>()  and B<geteuid>()  system calls, "
"a single B<getxuid>()  system call is provided, which returns a pair of real "
"and effective UIDs.  The glibc B<getuid>()  and B<geteuid>()  wrapper "
"functions transparently deal with this.  See B<syscall>(2)  for details "
"regarding register mapping."
msgstr ""

#. type: Plain text
#: man-pages/man2/getuid.2:93
msgid "B<getresuid>(2), B<setreuid>(2), B<setuid>(2), B<credentials>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/get_kernel_syms.2:10
#, no-wrap
msgid "GET_KERNEL_SYMS"
msgstr ""

#. type: Plain text
#: man-pages/man2/get_kernel_syms.2:13
msgid "get_kernel_syms - retrieve exported kernel and module symbols"
msgstr ""

#. type: Plain text
#: man-pages/man2/get_kernel_syms.2:18
#, no-wrap
msgid "B<int get_kernel_syms(struct kernel_sym *>I<table>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/get_kernel_syms.2:25
msgid "B<Note>: This system call is present only in kernels before Linux 2.6."
msgstr ""

#. type: Plain text
#: man-pages/man2/get_kernel_syms.2:32
msgid ""
"If I<table> is NULL, B<get_kernel_syms>()  returns the number of symbols "
"available for query.  Otherwise, it fills in a table of structures:"
msgstr ""

#. type: Plain text
#: man-pages/man2/get_kernel_syms.2:39
#, no-wrap
msgid ""
"struct kernel_sym {\n"
"    unsigned long value;\n"
"    char          name[60];\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/get_kernel_syms.2:47
msgid ""
"The symbols are interspersed with magic symbols of the form "
"B<#>I<module-name> with the kernel having an empty name.  The value "
"associated with a symbol of this form is the address at which the module is "
"loaded."
msgstr ""

#. type: Plain text
#: man-pages/man2/get_kernel_syms.2:51
msgid ""
"The symbols exported from each module follow their magic module tag and the "
"modules are returned in the reverse of the order in which they were loaded."
msgstr ""

#. type: Plain text
#: man-pages/man2/get_kernel_syms.2:57
msgid ""
"On success, returns the number of symbols copied to I<table>.  On error, -1 "
"is returned and I<errno> is set appropriately."
msgstr ""

#. type: Plain text
#: man-pages/man2/get_kernel_syms.2:59
msgid "There is only one possible error return:"
msgstr ""

#. type: Plain text
#: man-pages/man2/get_kernel_syms.2:63
msgid "B<get_kernel_syms>()  is not supported in this version of the kernel."
msgstr ""

#. type: Plain text
#: man-pages/man2/get_kernel_syms.2:70
msgid "B<get_kernel_syms>()  is Linux-specific."
msgstr ""

#. type: Plain text
#: man-pages/man2/get_kernel_syms.2:83
msgid ""
"There is no way to indicate the size of the buffer allocated for I<table>.  "
"If symbols have been added to the kernel since the program queried for the "
"symbol table size, memory will be corrupted."
msgstr ""

#. type: Plain text
#: man-pages/man2/get_kernel_syms.2:85
msgid "The length of exported symbol names is limited to 59 characters."
msgstr ""

#. type: Plain text
#: man-pages/man2/get_kernel_syms.2:91
msgid ""
"Because of these limitations, this system call is deprecated in favor of "
"B<query_module>(2)  (which is itself nowadays deprecated in favor of other "
"interfaces described on its manual page)."
msgstr ""

#. type: Plain text
#: man-pages/man2/get_kernel_syms.2:95
msgid ""
"B<create_module>(2), B<delete_module>(2), B<init_module>(2), "
"B<query_module>(2)"
msgstr ""

#. type: TH
#: man-pages/man2/connect.2:67
#, no-wrap
msgid "CONNECT"
msgstr ""

#. type: Plain text
#: man-pages/man2/connect.2:70
msgid "connect - initiate a connection on a socket"
msgstr ""

#. type: Plain text
#: man-pages/man2/connect.2:73
#, no-wrap
msgid "B<#include E<lt>sys/types.hE<gt>>          /* See NOTES */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/connect.2:78
#, no-wrap
msgid ""
"B<int connect(int >I<sockfd>B<, const struct sockaddr *>I<addr>B<,>\n"
"B<            socklen_t >I<addrlen>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/connect.2:97
msgid ""
"The B<connect>()  system call connects the socket referred to by the file "
"descriptor I<sockfd> to the address specified by I<addr>.  The I<addrlen> "
"argument specifies the size of I<addr>.  The format of the address in "
"I<addr> is determined by the address space of the socket I<sockfd>; see "
"B<socket>(2)  for further details."
msgstr ""

#. type: Plain text
#: man-pages/man2/connect.2:113
msgid ""
"If the socket I<sockfd> is of type B<SOCK_DGRAM>, then I<addr> is the "
"address to which datagrams are sent by default, and the only address from "
"which datagrams are received.  If the socket is of type B<SOCK_STREAM> or "
"B<SOCK_SEQPACKET>, this call attempts to make a connection to the socket "
"that is bound to the address specified by I<addr>."
msgstr ""

#. type: Plain text
#: man-pages/man2/connect.2:127
msgid ""
"Generally, connection-based protocol sockets may successfully B<connect>()  "
"only once; connectionless protocol sockets may use B<connect>()  multiple "
"times to change their association.  Connectionless sockets may dissolve the "
"association by connecting to an address with the I<sa_family> member of "
"I<sockaddr> set to B<AF_UNSPEC> (supported on Linux since kernel 2.2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/connect.2:132
msgid ""
"If the connection or binding succeeds, zero is returned.  On error, -1 is "
"returned, and I<errno> is set appropriately."
msgstr ""

#. type: Plain text
#: man-pages/man2/connect.2:135
msgid ""
"The following are general socket errors only.  There may be other "
"domain-specific error codes."
msgstr ""

#. type: Plain text
#: man-pages/man2/connect.2:143
msgid ""
"For UNIX domain sockets, which are identified by pathname: Write permission "
"is denied on the socket file, or search permission is denied for one of the "
"directories in the path prefix.  (See also B<path_resolution>(7).)"
msgstr ""

#. type: TP
#: man-pages/man2/connect.2:143 man-pages/man2/sysctl.2:81
#, no-wrap
msgid "B<EACCES>, B<EPERM>"
msgstr ""

#. type: Plain text
#: man-pages/man2/connect.2:148
msgid ""
"The user tried to connect to a broadcast address without having the socket "
"broadcast flag enabled or the connection request failed because of a local "
"firewall rule."
msgstr ""

#. type: Plain text
#: man-pages/man2/connect.2:151
msgid "Local address is already in use."
msgstr ""

#. type: Plain text
#: man-pages/man2/connect.2:164 man-pages/man2/listen.2:103
msgid ""
"(Internet domain sockets)  The socket referred to by I<sockfd> had not "
"previously been bound to an address and, upon attempting to bind it to an "
"ephemeral port, it was determined that all port numbers in the ephemeral "
"port range are currently in use.  See the discussion of "
"I</proc/sys/net/ipv4/ip_local_port_range> in B<ip>(7)."
msgstr ""

#. type: Plain text
#: man-pages/man2/connect.2:169
msgid ""
"The passed address didn't have the correct address family in its "
"I<sa_family> field."
msgstr ""

#. type: Plain text
#: man-pages/man2/connect.2:174
msgid ""
"For nonblocking UNIX domain sockets, the socket is nonblocking, and the "
"connection cannot be completed immediately.  For other socket families, "
"there are insufficient entries in the routing cache."
msgstr ""

#. type: Plain text
#: man-pages/man2/connect.2:178
msgid ""
"The socket is nonblocking and a previous connection attempt has not yet been "
"completed."
msgstr ""

#. type: TP
#: man-pages/man2/connect.2:182 man-pages/man2/recv.2:465
#, no-wrap
msgid "B<ECONNREFUSED>"
msgstr ""

#. type: Plain text
#: man-pages/man2/connect.2:187
msgid ""
"A B<connect>()  on a stream socket found no one listening on the remote "
"address."
msgstr ""

#. type: Plain text
#: man-pages/man2/connect.2:190
msgid "The socket structure address is outside the user's address space."
msgstr ""

#. type: TP
#: man-pages/man2/connect.2:190
#, no-wrap
msgid "B<EINPROGRESS>"
msgstr ""

#. type: Plain text
#: man-pages/man2/connect.2:217
msgid ""
"The socket is nonblocking and the connection cannot be completed "
"immediately.  (UNIX domain sockets failed with B<EAGAIN> instead.)  It is "
"possible to B<select>(2)  or B<poll>(2)  for completion by selecting the "
"socket for writing.  After B<select>(2)  indicates writability, use "
"B<getsockopt>(2)  to read the B<SO_ERROR> option at level B<SOL_SOCKET> to "
"determine whether B<connect>()  completed successfully (B<SO_ERROR> is zero) "
"or unsuccessfully (B<SO_ERROR> is one of the usual error codes listed here, "
"explaining the reason for the failure)."
msgstr ""

#.  For TCP, the connection will complete asynchronously.
#.  See http://lkml.org/lkml/2005/7/12/254
#. type: Plain text
#: man-pages/man2/connect.2:223
msgid ""
"The system call was interrupted by a signal that was caught; see "
"B<signal>(7)."
msgstr ""

#. type: Plain text
#: man-pages/man2/connect.2:226
msgid "The socket is already connected."
msgstr ""

#. type: TP
#: man-pages/man2/connect.2:226
#, no-wrap
msgid "B<ENETUNREACH>"
msgstr ""

#. type: Plain text
#: man-pages/man2/connect.2:229
msgid "Network is unreachable."
msgstr ""

#. type: TP
#: man-pages/man2/connect.2:234
#, no-wrap
msgid "B<EPROTOTYPE>"
msgstr ""

#. type: Plain text
#: man-pages/man2/connect.2:239
msgid ""
"The socket type does not support the requested communications protocol.  "
"This error can occur, for example, on an attempt to connect a UNIX domain "
"datagram socket to a stream socket."
msgstr ""

#. type: Plain text
#: man-pages/man2/connect.2:246
msgid ""
"Timeout while attempting connection.  The server may be too busy to accept "
"new connections.  Note that for IP sockets the timeout may be very long when "
"syncookies are enabled on the server."
msgstr ""

#.  SVr4 documents the additional
#.  general error codes
#.  .BR EADDRNOTAVAIL ,
#.  .BR EINVAL ,
#.  .BR EAFNOSUPPORT ,
#.  .BR EALREADY ,
#.  .BR EINTR ,
#.  .BR EPROTOTYPE ,
#.  and
#.  .BR ENOSR .
#.  It also
#.  documents many additional error conditions not described here.
#. type: Plain text
#: man-pages/man2/connect.2:262
msgid ""
"POSIX.1-2001, POSIX.1-2008, SVr4, 4.4BSD, (connectB<()> first appeared in "
"4.2BSD)."
msgstr ""

#. type: Plain text
#: man-pages/man2/connect.2:279
msgid ""
"If B<connect>()  fails, consider the state of the socket as unspecified.  "
"Portable applications should close the socket and create a new one for "
"reconnecting."
msgstr ""

#. type: Plain text
#: man-pages/man2/connect.2:284
msgid "An example of the use of B<connect>()  is shown in B<getaddrinfo>(3)."
msgstr ""

#. type: Plain text
#: man-pages/man2/connect.2:290
msgid ""
"B<accept>(2), B<bind>(2), B<getsockname>(2), B<listen>(2), B<socket>(2), "
"B<path_resolution>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/s390_pci_mmio_write.2:25
#, no-wrap
msgid "S390_PCI_MMIO_WRITE"
msgstr ""

#. type: Plain text
#: man-pages/man2/s390_pci_mmio_write.2:29
msgid ""
"s390_pci_mmio_write, s390_pci_mmio_read - transfer data to/from PCI MMIO "
"memory page"
msgstr ""

#. type: Plain text
#: man-pages/man2/s390_pci_mmio_write.2:32 man-pages/man2/s390_sthyi.2:31
#, no-wrap
msgid "B<#include E<lt>asm/unistd.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/s390_pci_mmio_write.2:37
#, no-wrap
msgid ""
"B<int s390_pci_mmio_write(unsigned long >I<mmio_addr>B<,>\n"
"B<                        void *>I<user_buffer>B<, size_t >I<length>B<);>\n"
"B<int s390_pci_mmio_read(unsigned long >I<mmio_addr>B<,>\n"
"B<                        void *>I<user_buffer>B<, size_t >I<length>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/s390_pci_mmio_write.2:56
msgid ""
"The B<s390_pci_mmio_write>()  system call writes I<length> bytes of data "
"from the user-space buffer I<user_buffer> to the PCI MMIO memory location "
"specified by I<mmio_addr>.  The B<s390_pci_mmio_read>()  system call reads "
"I<length> bytes of data from the PCI MMIO memory location specified by "
"I<mmio_addr> to the user-space buffer I<user_buffer>."
msgstr ""

#. type: Plain text
#: man-pages/man2/s390_pci_mmio_write.2:67
msgid ""
"These system calls must be used instead of the simple assignment or "
"data-transfer operations that are used to access the PCI MMIO memory areas "
"mapped to user space on the Linux System z platform.  The address specified "
"by I<mmio_addr> must belong to a PCI MMIO memory page mapping in the "
"caller's address space, and the data being written or read must not cross a "
"page boundary.  The I<length> value cannot be greater than the system page "
"size."
msgstr ""

#. type: Plain text
#: man-pages/man2/s390_pci_mmio_write.2:76
msgid ""
"On success, B<s390_pci_mmio_write>()  and B<s390_pci_mmio_read>()  return "
"0.  On error, -1 is returned and I<errno> is set to one of the error codes "
"listed below."
msgstr ""

#. type: Plain text
#: man-pages/man2/s390_pci_mmio_write.2:82
msgid "The address in I<mmio_addr> is invalid."
msgstr ""

#. type: Plain text
#: man-pages/man2/s390_pci_mmio_write.2:86
msgid ""
"I<user_buffer> does not point to a valid location in the caller's address "
"space."
msgstr ""

#. type: Plain text
#: man-pages/man2/s390_pci_mmio_write.2:91
msgid "Invalid I<length> argument."
msgstr ""

#. type: Plain text
#: man-pages/man2/s390_pci_mmio_write.2:94
msgid "PCI support is not enabled."
msgstr ""

#. type: Plain text
#: man-pages/man2/s390_pci_mmio_write.2:97
msgid "Insufficient memory."
msgstr ""

#. type: Plain text
#: man-pages/man2/s390_pci_mmio_write.2:99
msgid "These system calls are available since Linux 3.19."
msgstr ""

#. type: Plain text
#: man-pages/man2/s390_pci_mmio_write.2:102
msgid ""
"This Linux-specific system call is available only on the s390 architecture.  "
"The required PCI support is available beginning with System z EC12."
msgstr ""

#. type: TH
#: man-pages/man2/spu_run.2:26
#, no-wrap
msgid "SPU_RUN"
msgstr ""

#. type: Plain text
#: man-pages/man2/spu_run.2:29
msgid "spu_run - execute an SPU context"
msgstr ""

#. type: Plain text
#: man-pages/man2/spu_run.2:32
#, no-wrap
msgid "B<#include E<lt>sys/spu.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/spu_run.2:35
#, no-wrap
msgid ""
"B<int spu_run(int >I<fd>B<, unsigned int *>I<npc>B<, unsigned int "
"*>I<event>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/spu_run.2:53
msgid ""
"The B<spu_run>()  system call is used on PowerPC machines that implement the "
"Cell Broadband Engine Architecture in order to access Synergistic Processor "
"Units (SPUs).  The I<fd> argument is a file descriptor returned by "
"B<spu_create>(2)  that refers to a specific SPU context.  When the context "
"gets scheduled to a physical SPU, it starts execution at the instruction "
"pointer passed in I<npc>."
msgstr ""

#. type: Plain text
#: man-pages/man2/spu_run.2:62
msgid ""
"Execution of SPU code happens synchronously, meaning that B<spu_run>()  "
"blocks while the SPU is still running.  If there is a need to execute SPU "
"code in parallel with other code on either the main CPU or other SPUs, a new "
"thread of execution must be created first (e.g., using "
"B<pthread_create>(3))."
msgstr ""

#. type: Plain text
#: man-pages/man2/spu_run.2:72
msgid ""
"When B<spu_run>()  returns, the current value of the SPU program counter is "
"written to I<npc>, so successive calls to B<spu_run>()  can use the same "
"I<npc> pointer."
msgstr ""

#. type: Plain text
#: man-pages/man2/spu_run.2:82
msgid ""
"The I<event> argument provides a buffer for an extended status code.  If the "
"SPU context was created with the B<SPU_CREATE_EVENTS_ENABLED> flag, then "
"this buffer is populated by the Linux kernel before B<spu_run>()  returns."
msgstr ""

#. type: Plain text
#: man-pages/man2/spu_run.2:84
msgid "The status code may be one (or more) of the following constants:"
msgstr ""

#. type: TP
#: man-pages/man2/spu_run.2:84
#, no-wrap
msgid "B<SPE_EVENT_DMA_ALIGNMENT>"
msgstr ""

#. type: Plain text
#: man-pages/man2/spu_run.2:87
msgid "A DMA alignment error occurred."
msgstr ""

#. type: TP
#: man-pages/man2/spu_run.2:87
#, no-wrap
msgid "B<SPE_EVENT_INVALID_DMA>"
msgstr ""

#. type: Plain text
#: man-pages/man2/spu_run.2:90
msgid "An invalid MFC DMA command was attempted."
msgstr ""

#. type: TP
#: man-pages/man2/spu_run.2:90
#, no-wrap
msgid "B<SPE_EVENT_SPE_DATA_STORAGE>"
msgstr ""

#. type: Plain text
#: man-pages/man2/spu_run.2:93
msgid "A DMA storage error occurred."
msgstr ""

#. type: TP
#: man-pages/man2/spu_run.2:93
#, no-wrap
msgid "B<SPE_EVENT_SPE_ERROR>"
msgstr ""

#. type: Plain text
#: man-pages/man2/spu_run.2:96
msgid "An illegal instruction was executed."
msgstr ""

#. type: Plain text
#: man-pages/man2/spu_run.2:102
msgid ""
"NULL is a valid value for the I<event> argument.  In this case, the events "
"will not be reported to the calling process."
msgstr ""

#. type: Plain text
#: man-pages/man2/spu_run.2:111
msgid ""
"On success, B<spu_run>()  returns the value of the I<spu_status> register.  "
"On error, it returns -1 and sets I<errno> to one of the error codes listed "
"below."
msgstr ""

#. type: Plain text
#: man-pages/man2/spu_run.2:120
msgid ""
"The I<spu_status> register value is a bit mask of status codes and "
"optionally a 14-bit code returned from the B<stop-and-signal> instruction on "
"the SPU.  The bit masks for the status codes are:"
msgstr ""

#. type: TP
#: man-pages/man2/spu_run.2:120
#, no-wrap
msgid "B<0x02>"
msgstr ""

#. type: Plain text
#: man-pages/man2/spu_run.2:125
msgid "SPU was stopped by a B<stop-and-signal> instruction."
msgstr ""

#. type: TP
#: man-pages/man2/spu_run.2:125
#, no-wrap
msgid "B<0x04>"
msgstr ""

#. type: Plain text
#: man-pages/man2/spu_run.2:130
msgid "SPU was stopped by a B<halt> instruction."
msgstr ""

#. type: TP
#: man-pages/man2/spu_run.2:130
#, no-wrap
msgid "B<0x08>"
msgstr ""

#. type: Plain text
#: man-pages/man2/spu_run.2:133
msgid "SPU is waiting for a channel."
msgstr ""

#. type: TP
#: man-pages/man2/spu_run.2:133
#, no-wrap
msgid "B<0x10>"
msgstr ""

#. type: Plain text
#: man-pages/man2/spu_run.2:136
msgid "SPU is in single-step mode."
msgstr ""

#. type: TP
#: man-pages/man2/spu_run.2:136
#, no-wrap
msgid "B<0x20>"
msgstr ""

#. type: Plain text
#: man-pages/man2/spu_run.2:139
msgid "SPU has tried to execute an invalid instruction."
msgstr ""

#. type: TP
#: man-pages/man2/spu_run.2:139
#, no-wrap
msgid "B<0x40>"
msgstr ""

#. type: Plain text
#: man-pages/man2/spu_run.2:142
msgid "SPU has tried to access an invalid channel."
msgstr ""

#. type: TP
#: man-pages/man2/spu_run.2:142
#, no-wrap
msgid "B<0x3fff0000>"
msgstr ""

#. type: Plain text
#: man-pages/man2/spu_run.2:148
msgid ""
"The bits masked with this value contain the code returned from a "
"B<stop-and-signal> instruction.  These bits are valid only if the 0x02 bit "
"is set."
msgstr ""

#. type: Plain text
#: man-pages/man2/spu_run.2:153
msgid ""
"If B<spu_run>()  has not returned an error, one or more bits among the lower "
"eight ones are always set."
msgstr ""

#. type: Plain text
#: man-pages/man2/spu_run.2:164
msgid ""
"I<npc> is not a valid pointer, or I<event> is non-NULL and an invalid "
"pointer."
msgstr ""

#. type: Plain text
#: man-pages/man2/spu_run.2:174
msgid ""
"A signal occurred while B<spu_run>()  was in progress; see B<signal>(7).  "
"The I<npc> value has been updated to the new program counter value if "
"necessary."
msgstr ""

#. type: Plain text
#: man-pages/man2/spu_run.2:179
msgid "I<fd> is not a valid file descriptor returned from B<spu_create>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/spu_run.2:183
msgid ""
"There was not enough memory available to handle a page fault resulting from "
"a Memory Flow Controller (MFC) direct memory access."
msgstr ""

#. type: Plain text
#: man-pages/man2/spu_run.2:192
msgid "The B<spu_run>()  system call was added to Linux in kernel 2.6.16."
msgstr ""

#. type: Plain text
#: man-pages/man2/spu_run.2:196
msgid ""
"This call is Linux-specific and implemented only by the PowerPC "
"architecture.  Programs using this system call are not portable."
msgstr ""

#. type: Plain text
#: man-pages/man2/spu_run.2:207
msgid ""
"Glibc does not provide a wrapper for this system call; call it using "
"B<syscall>(2).  Note however, that B<spu_run>()  is meant to be used from "
"libraries that implement a more abstract interface to SPUs, not to be used "
"from regular applications.  See E<.UR "
"http://www.bsc.es\\:/projects\\:/deepcomputing\\:/linuxoncell/> E<.UE> for "
"the recommended libraries."
msgstr ""

#. type: Plain text
#: man-pages/man2/spu_run.2:212
msgid ""
"The following is an example of running a simple, one-instruction SPU program "
"with the B<spu_run>()  system call."
msgstr ""

#. type: Plain text
#: man-pages/man2/spu_run.2:220
#, no-wrap
msgid ""
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdint.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>sys/types.hE<gt>\n"
"#include E<lt>fcntl.hE<gt>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/spu_run.2:228
#, no-wrap
msgid ""
"int main(void)\n"
"{\n"
"    int context, fd, spu_status;\n"
"    uint32_t instruction, npc;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/spu_run.2:232
#, no-wrap
msgid ""
"    context = spu_create(\"/spu/example-context\", 0, 0755);\n"
"    if (context == -1)\n"
"        handle_error(\"spu_create\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/spu_run.2:237
#, no-wrap
msgid ""
"    /* write a \\(aqstop 0x1234\\(aq instruction to the SPU\\(aqs\n"
"     * local store memory\n"
"     */\n"
"    instruction = 0x00001234;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/spu_run.2:242
#, no-wrap
msgid ""
"    fd = open(\"/spu/example-context/mem\", O_RDWR);\n"
"    if (fd == -1)\n"
"        handle_error(\"open\");\n"
"    write(fd, &instruction, sizeof(instruction));\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/spu_run.2:248
#, no-wrap
msgid ""
"    /* set npc to the starting instruction address of the\n"
"     * SPU program. Since we wrote the instruction at the\n"
"     * start of the mem file, the entry point will be 0x0\n"
"     */\n"
"    npc = 0;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/spu_run.2:252
#, no-wrap
msgid ""
"    spu_status = spu_run(context, &npc, NULL);\n"
"    if (spu_status == -1)\n"
"        handle_error(\"open\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/spu_run.2:258
#, no-wrap
msgid ""
"    /* we should see a status code of 0x1234002:\n"
"     *   0x00000002 (spu was stopped due to stop-and-signal)\n"
"     * | 0x12340000 (the stop-and-signal code)\n"
"     */\n"
"    printf(\"SPU Status: 0x%08x\\en\", spu_status);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/spu_run.2:268
msgid "B<close>(2), B<spu_create>(2), B<capabilities>(7), B<spufs>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/timerfd_create.2:22
#, no-wrap
msgid "TIMERFD_CREATE"
msgstr ""

#. type: Plain text
#: man-pages/man2/timerfd_create.2:26
msgid ""
"timerfd_create, timerfd_settime, timerfd_gettime - timers that notify via "
"file descriptors"
msgstr ""

#. type: Plain text
#: man-pages/man2/timerfd_create.2:29
#, no-wrap
msgid "B<#include E<lt>sys/timerfd.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/timerfd_create.2:31
#, no-wrap
msgid "B<int timerfd_create(int >I<clockid>B<, int >I<flags>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/timerfd_create.2:35
#, no-wrap
msgid ""
"B<int timerfd_settime(int >I<fd>B<, int >I<flags>B<,>\n"
"B<                    const struct itimerspec *>I<new_value>B<,>\n"
"B<                    struct itimerspec *>I<old_value>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/timerfd_create.2:37
#, no-wrap
msgid "B<int timerfd_gettime(int >I<fd>B<, struct itimerspec *>I<curr_value>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/timerfd_create.2:50
msgid ""
"These system calls create and operate on a timer that delivers timer "
"expiration notifications via a file descriptor.  They provide an alternative "
"to the use of B<setitimer>(2)  or B<timer_create>(2), with the advantage "
"that the file descriptor may be monitored by B<select>(2), B<poll>(2), and "
"B<epoll>(7)."
msgstr ""

#. type: Plain text
#: man-pages/man2/timerfd_create.2:62
msgid ""
"The use of these three system calls is analogous to the use of "
"B<timer_create>(2), B<timer_settime>(2), and B<timer_gettime>(2).  (There is "
"no analog of B<timer_getoverrun>(2), since that functionality is provided by "
"B<read>(2), as described below.)"
msgstr ""

#. type: SS
#: man-pages/man2/timerfd_create.2:62
#, no-wrap
msgid "timerfd_create()"
msgstr ""

#. type: Plain text
#: man-pages/man2/timerfd_create.2:70
msgid ""
"B<timerfd_create>()  creates a new timer object, and returns a file "
"descriptor that refers to that timer.  The I<clockid> argument specifies the "
"clock that is used to mark the progress of the timer, and must be one of the "
"following:"
msgstr ""

#.  Note: the CLOCK_MONOTONIC_RAW clock added for clock_gettime()
#.  in 2.6.28 is not supported for POSIX timers -- mtk, Feb 2009
#. type: Plain text
#: man-pages/man2/timerfd_create.2:78 man-pages/man2/timer_create.2:70
msgid ""
"A nonsettable monotonically increasing clock that measures time from some "
"unspecified point in the past that does not change after system startup."
msgstr ""

#. type: TP
#: man-pages/man2/timerfd_create.2:78
#, no-wrap
msgid "B<CLOCK_BOOTTIME> (Since Linux 3.15)"
msgstr ""

#.  commit 70a08cca1227dc31c784ec930099a4417a06e7d0
#. type: Plain text
#: man-pages/man2/timerfd_create.2:93 man-pages/man2/timer_create.2:95
msgid ""
"Like B<CLOCK_MONOTONIC>, this is a monotonically increasing clock.  However, "
"whereas the B<CLOCK_MONOTONIC> clock does not measure the time while a "
"system is suspended, the B<CLOCK_BOOTTIME> clock does include the time "
"during which the system is suspended.  This is useful for applications that "
"need to be suspend-aware.  B<CLOCK_REALTIME> is not suitable for such "
"applications, since that clock is affected by discontinuous changes to the "
"system clock."
msgstr ""

#. type: TP
#: man-pages/man2/timerfd_create.2:93
#, no-wrap
msgid "B<CLOCK_REALTIME_ALARM> (since Linux 3.11)"
msgstr ""

#.  commit 9a7adcf5c6dea63d2e47e6f6d2f7a6c9f48b9337
#. type: Plain text
#: man-pages/man2/timerfd_create.2:102 man-pages/man2/timer_create.2:104
msgid ""
"This clock is like B<CLOCK_REALTIME>, but will wake the system if it is "
"suspended.  The caller must have the B<CAP_WAKE_ALARM> capability in order "
"to set a timer against this clock."
msgstr ""

#. type: TP
#: man-pages/man2/timerfd_create.2:102
#, no-wrap
msgid "B<CLOCK_BOOTTIME_ALARM> (since Linux 3.11)"
msgstr ""

#.  commit 9a7adcf5c6dea63d2e47e6f6d2f7a6c9f48b9337
#. type: Plain text
#: man-pages/man2/timerfd_create.2:111 man-pages/man2/timer_create.2:113
msgid ""
"This clock is like B<CLOCK_BOOTTIME>, but will wake the system if it is "
"suspended.  The caller must have the B<CAP_WAKE_ALARM> capability in order "
"to set a timer against this clock."
msgstr ""

#. type: Plain text
#: man-pages/man2/timerfd_create.2:114
msgid ""
"The current value of each of these clocks can be retrieved using "
"B<clock_gettime>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/timerfd_create.2:119
msgid ""
"Starting with Linux 2.6.27, the following values may be bitwise ORed in "
"I<flags> to change the behavior of B<timerfd_create>():"
msgstr ""

#. type: TP
#: man-pages/man2/timerfd_create.2:119
#, no-wrap
msgid "B<TFD_NONBLOCK>"
msgstr ""

#. type: TP
#: man-pages/man2/timerfd_create.2:129
#, no-wrap
msgid "B<TFD_CLOEXEC>"
msgstr ""

#. type: Plain text
#: man-pages/man2/timerfd_create.2:143
msgid ""
"In Linux versions up to and including 2.6.26, I<flags> must be specified as "
"zero."
msgstr ""

#. type: SS
#: man-pages/man2/timerfd_create.2:143
#, no-wrap
msgid "timerfd_settime()"
msgstr ""

#. type: Plain text
#: man-pages/man2/timerfd_create.2:148
msgid ""
"B<timerfd_settime>()  arms (starts) or disarms (stops)  the timer referred "
"to by the file descriptor I<fd>."
msgstr ""

#. type: Plain text
#: man-pages/man2/timerfd_create.2:157
msgid ""
"The I<new_value> argument specifies the initial expiration and interval for "
"the timer.  The I<itimerspec> structure used for this argument contains two "
"fields, each of which is in turn a structure of type I<timespec>:"
msgstr ""

#. type: Plain text
#: man-pages/man2/timerfd_create.2:169
#, no-wrap
msgid ""
"struct itimerspec {\n"
"    struct timespec it_interval;  /* Interval for periodic timer */\n"
"    struct timespec it_value;     /* Initial expiration */\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/timerfd_create.2:181
msgid ""
"I<new_value.it_value> specifies the initial expiration of the timer, in "
"seconds and nanoseconds.  Setting either field of I<new_value.it_value> to a "
"nonzero value arms the timer.  Setting both fields of I<new_value.it_value> "
"to zero disarms the timer."
msgstr ""

#. type: Plain text
#: man-pages/man2/timerfd_create.2:190
msgid ""
"Setting one or both fields of I<new_value.it_interval> to nonzero values "
"specifies the period, in seconds and nanoseconds, for repeated timer "
"expirations after the initial expiration.  If both fields of "
"I<new_value.it_interval> are zero, the timer expires just once, at the time "
"specified by I<new_value.it_value>."
msgstr ""

#. type: Plain text
#: man-pages/man2/timerfd_create.2:202
msgid ""
"By default, the initial expiration time specified in I<new_value> is "
"interpreted relative to the current time on the timer's clock at the time of "
"the call (i.e., I<new_value.it_value> specifies a time relative to the "
"current value of the clock specified by I<clockid>).  An absolute timeout "
"can be selected via the I<flags> argument."
msgstr ""

#. type: Plain text
#: man-pages/man2/timerfd_create.2:206
msgid "The I<flags> argument is a bit mask that can include the following values:"
msgstr ""

#. type: TP
#: man-pages/man2/timerfd_create.2:206
#, no-wrap
msgid "B<TFD_TIMER_ABSTIME>"
msgstr ""

#. type: Plain text
#: man-pages/man2/timerfd_create.2:214
msgid ""
"Interpret I<new_value.it_value> as an absolute value on the timer's clock.  "
"The timer will expire when the value of the timer's clock reaches the value "
"specified in I<new_value.it_value>."
msgstr ""

#. type: TP
#: man-pages/man2/timerfd_create.2:214
#, no-wrap
msgid "B<TFD_TIMER_CANCEL_ON_SET>"
msgstr ""

#. type: Plain text
#: man-pages/man2/timerfd_create.2:231
msgid ""
"If this flag is specified along with B<TFD_TIMER_ABSTIME> and the clock for "
"this timer is B<CLOCK_REALTIME> or B<CLOCK_REALTIME_ALARM>, then mark this "
"timer as cancelable if the real-time clock undergoes a discontinuous change "
"(B<settimeofday>(2), B<clock_settime>(2), or similar).  When such changes "
"occur, a current or future B<read>(2)  from the file descriptor will fail "
"with the error B<ECANCELED>."
msgstr ""

#. type: Plain text
#: man-pages/man2/timerfd_create.2:242
msgid ""
"If the I<old_value> argument is not NULL, then the I<itimerspec> structure "
"that it points to is used to return the setting of the timer that was "
"current at the time of the call; see the description of B<timerfd_gettime>()  "
"following."
msgstr ""

#. type: SS
#: man-pages/man2/timerfd_create.2:242
#, no-wrap
msgid "timerfd_gettime()"
msgstr ""

#. type: Plain text
#: man-pages/man2/timerfd_create.2:251
msgid ""
"B<timerfd_gettime>()  returns, in I<curr_value>, an I<itimerspec> structure "
"that contains the current setting of the timer referred to by the file "
"descriptor I<fd>."
msgstr ""

#. type: Plain text
#: man-pages/man2/timerfd_create.2:261
msgid ""
"The I<it_value> field returns the amount of time until the timer will next "
"expire.  If both fields of this structure are zero, then the timer is "
"currently disarmed.  This field always contains a relative value, regardless "
"of whether the B<TFD_TIMER_ABSTIME> flag was specified when setting the "
"timer."
msgstr ""

#. type: Plain text
#: man-pages/man2/timerfd_create.2:268
msgid ""
"The I<it_interval> field returns the interval of the timer.  If both fields "
"of this structure are zero, then the timer is set to expire just once, at "
"the time specified by I<curr_value.it_value>."
msgstr ""

#. type: SS
#: man-pages/man2/timerfd_create.2:268
#, no-wrap
msgid "Operating on a timer file descriptor"
msgstr ""

#. type: Plain text
#: man-pages/man2/timerfd_create.2:272
msgid ""
"The file descriptor returned by B<timerfd_create>()  supports the following "
"operations:"
msgstr ""

#. type: Plain text
#: man-pages/man2/timerfd_create.2:286
msgid ""
"If the timer has already expired one or more times since its settings were "
"last modified using B<timerfd_settime>(), or since the last successful "
"B<read>(2), then the buffer given to B<read>(2)  returns an unsigned 8-byte "
"integer (I<uint64_t>)  containing the number of expirations that have "
"occurred.  (The returned value is in host byte order\\(emthat is, the native "
"byte order for integers on the host machine.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/timerfd_create.2:299
msgid ""
"If no timer expirations have occurred at the time of the B<read>(2), then "
"the call either blocks until the next timer expiration, or fails with the "
"error B<EAGAIN> if the file descriptor has been made nonblocking (via the "
"use of the B<fcntl>(2)  B<F_SETFL> operation to set the B<O_NONBLOCK> flag)."
msgstr ""

#. type: Plain text
#: man-pages/man2/timerfd_create.2:305
msgid ""
"A B<read>(2)  fails with the error B<EINVAL> if the size of the supplied "
"buffer is less than 8 bytes."
msgstr ""

#. type: Plain text
#: man-pages/man2/timerfd_create.2:323
msgid ""
"If the associated clock is either B<CLOCK_REALTIME> or "
"B<CLOCK_REALTIME_ALARM>, the timer is absolute (B<TFD_TIMER_ABSTIME>), and "
"the flag B<TFD_TIMER_CANCEL_ON_SET> was specified when calling "
"B<timerfd_settime>(), then B<read>(2)  fails with the error B<ECANCELED> if "
"the real-time clock undergoes a discontinuous change.  (This allows the "
"reading application to discover such discontinuous changes to the clock.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/timerfd_create.2:334
msgid ""
"The file descriptor is readable (the B<select>(2)  I<readfds> argument; the "
"B<poll>(2)  B<POLLIN> flag)  if one or more timer expirations have occurred."
msgstr ""

#. type: Plain text
#: man-pages/man2/timerfd_create.2:341
msgid ""
"The file descriptor also supports the other file-descriptor multiplexing "
"APIs: B<pselect>(2), B<ppoll>(2), and B<epoll>(7)."
msgstr ""

#. type: Plain text
#: man-pages/man2/timerfd_create.2:344
msgid "The following timerfd-specific command is supported:"
msgstr ""

#. type: TP
#: man-pages/man2/timerfd_create.2:345
#, no-wrap
msgid "B<TFD_IOC_SET_TICKS> (since Linux 3.17)"
msgstr ""

#.  commit 5442e9fbd7c23172a1c9bc736629cd123a9923f0
#. type: Plain text
#: man-pages/man2/timerfd_create.2:358
msgid ""
"Adjust the number of timer expirations that have occurred.  The argument is "
"a pointer to a nonzero 8-byte integer (I<uint64_t>*)  containing the new "
"number of expirations.  Once the number is set, any waiter on the timer is "
"woken up.  The only purpose of this command is to restore the expirations "
"for the purpose of checkpoint/restore.  This operation is available only if "
"the kernel was configured with the B<CONFIG_CHECKPOINT_RESTORE> option."
msgstr ""

#. type: Plain text
#: man-pages/man2/timerfd_create.2:366
msgid ""
"When the file descriptor is no longer required it should be closed.  When "
"all file descriptors associated with the same timer object have been closed, "
"the timer is disarmed and its resources are freed by the kernel."
msgstr ""

#. type: Plain text
#: man-pages/man2/timerfd_create.2:378
msgid ""
"After a B<fork>(2), the child inherits a copy of the file descriptor created "
"by B<timerfd_create>().  The file descriptor refers to the same underlying "
"timer object as the corresponding file descriptor in the parent, and "
"B<read>(2)s in the child will return information about expirations of the "
"timer."
msgstr ""

#. type: Plain text
#: man-pages/man2/timerfd_create.2:384
msgid ""
"A file descriptor created by B<timerfd_create>()  is preserved across "
"B<execve>(2), and continues to generate timer expirations if the timer was "
"armed."
msgstr ""

#. type: Plain text
#: man-pages/man2/timerfd_create.2:391
msgid ""
"On success, B<timerfd_create>()  returns a new file descriptor.  On error, "
"-1 is returned and I<errno> is set to indicate the error."
msgstr ""

#. type: Plain text
#: man-pages/man2/timerfd_create.2:399
msgid ""
"B<timerfd_settime>()  and B<timerfd_gettime>()  return 0 on success; on "
"error they return -1, and set I<errno> to indicate the error."
msgstr ""

#. type: Plain text
#: man-pages/man2/timerfd_create.2:402
msgid "B<timerfd_create>()  can fail with the following errors:"
msgstr ""

#. type: Plain text
#: man-pages/man2/timerfd_create.2:410
msgid "The I<clockid> argument is neither B<CLOCK_MONOTONIC> nor B<CLOCK_REALTIME>;"
msgstr ""

#. type: Plain text
#: man-pages/man2/timerfd_create.2:430
msgid "There was insufficient kernel memory to create the timer."
msgstr ""

#. type: Plain text
#: man-pages/man2/timerfd_create.2:435
msgid ""
"B<timerfd_settime>()  and B<timerfd_gettime>()  can fail with the following "
"errors:"
msgstr ""

#. type: Plain text
#: man-pages/man2/timerfd_create.2:446 man-pages/man2/getitimer.2:146
msgid "I<new_value>, I<old_value>, or I<curr_value> is not valid a pointer."
msgstr ""

#. type: Plain text
#: man-pages/man2/timerfd_create.2:450
msgid "I<fd> is not a valid timerfd file descriptor."
msgstr ""

#. type: Plain text
#: man-pages/man2/timerfd_create.2:453
msgid "B<timerfd_settime>()  can also fail with the following errors:"
msgstr ""

#. type: Plain text
#: man-pages/man2/timerfd_create.2:459
msgid ""
"I<new_value> is not properly initialized (one of the I<tv_nsec> falls "
"outside the range zero to 999,999,999)."
msgstr ""

#. type: Plain text
#: man-pages/man2/timerfd_create.2:468
msgid ""
"These system calls are available on Linux since kernel 2.6.25.  Library "
"support is provided by glibc since version 2.8."
msgstr ""

#.  2.6.29
#. type: Plain text
#: man-pages/man2/timerfd_create.2:476
msgid ""
"Currently, B<timerfd_create>()  supports fewer types of clock IDs than "
"B<timer_create>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/timerfd_create.2:485
msgid ""
"The following program creates a timer and then monitors its progress.  The "
"program accepts up to three command-line arguments.  The first argument "
"specifies the number of seconds for the initial expiration of the timer.  "
"The second argument specifies the interval for the timer, in seconds.  The "
"third argument specifies the number of times the program should allow the "
"timer to expire before terminating.  The second and third command-line "
"arguments are optional."
msgstr ""

#. type: Plain text
#: man-pages/man2/timerfd_create.2:487 man-pages/man2/wait.2:626
msgid "The following shell session demonstrates the use of the program:"
msgstr ""

#. type: Plain text
#: man-pages/man2/timerfd_create.2:502
#, no-wrap
msgid ""
"$B< a.out 3 1 100>\n"
"0.000: timer started\n"
"3.000: read: 1; total=1\n"
"4.000: read: 1; total=2\n"
"B<^Z >                 # type control-Z to suspend the program\n"
"[1]+  Stopped                 ./timerfd3_demo 3 1 100\n"
"$ B<fg>                # Resume execution after a few seconds\n"
"a.out 3 1 100\n"
"9.660: read: 5; total=7\n"
"10.000: read: 1; total=8\n"
"11.000: read: 1; total=9\n"
"B<^C >                 # type control-C to suspend the program\n"
msgstr ""

#.  The commented out code here is what we currently need until
#.  the required stuff is in glibc
#
#
#. /* Link with -lrt */
#. #define _GNU_SOURCE
#. #include <sys/syscall.h>
#. #include <unistd.h>
#. #include <time.h>
#. #if defined(__i386__)
#. #define __NR_timerfd_create 322
#. #define __NR_timerfd_settime 325
#. #define __NR_timerfd_gettime 326
#. #endif
#
#. static int
#. timerfd_create(int clockid, int flags)
#. {
#.     return syscall(__NR_timerfd_create, clockid, flags);
#. }
#
#. static int
#. timerfd_settime(int fd, int flags, struct itimerspec *new_value,
#.         struct itimerspec *curr_value)
#. {
#.     return syscall(__NR_timerfd_settime, fd, flags, new_value,
#.                    curr_value);
#. }
#
#. static int
#. timerfd_gettime(int fd, struct itimerspec *curr_value)
#. {
#.     return syscall(__NR_timerfd_gettime, fd, curr_value);
#. }
#
#. #define TFD_TIMER_ABSTIME (1 << 0)
#
#. ////////////////////////////////////////////////////////////
#. type: Plain text
#: man-pages/man2/timerfd_create.2:551
#, no-wrap
msgid ""
"#include E<lt>sys/timerfd.hE<gt>\n"
"#include E<lt>time.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdint.hE<gt>        /* Definition of uint64_t */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/timerfd_create.2:562
#, no-wrap
msgid ""
"static void\n"
"print_elapsed_time(void)\n"
"{\n"
"    static struct timespec start;\n"
"    struct timespec curr;\n"
"    static int first_call = 1;\n"
"    int secs, nsecs;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/timerfd_create.2:568
#, no-wrap
msgid ""
"    if (first_call) {\n"
"        first_call = 0;\n"
"        if (clock_gettime(CLOCK_MONOTONIC, &start) == -1)\n"
"            handle_error(\"clock_gettime\");\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/timerfd_create.2:571
#, no-wrap
msgid ""
"    if (clock_gettime(CLOCK_MONOTONIC, &curr) == -1)\n"
"        handle_error(\"clock_gettime\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/timerfd_create.2:580
#, no-wrap
msgid ""
"    secs = curr.tv_sec - start.tv_sec;\n"
"    nsecs = curr.tv_nsec - start.tv_nsec;\n"
"    if (nsecs E<lt> 0) {\n"
"        secs--;\n"
"        nsecs += 1000000000;\n"
"    }\n"
"    printf(\"%d.%03d: \", secs, (nsecs + 500000) / 1000000);\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/timerfd_create.2:589
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    struct itimerspec new_value;\n"
"    int max_exp, fd;\n"
"    struct timespec now;\n"
"    uint64_t exp, tot_exp;\n"
"    ssize_t s;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/timerfd_create.2:595
#, no-wrap
msgid ""
"    if ((argc != 2) && (argc != 4)) {\n"
"        fprintf(stderr, \"%s init-secs [interval-secs max-exp]\\en\",\n"
"                argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/timerfd_create.2:598
#, no-wrap
msgid ""
"    if (clock_gettime(CLOCK_REALTIME, &now) == -1)\n"
"        handle_error(\"clock_gettime\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/timerfd_create.2:601
#, no-wrap
msgid ""
"    /* Create a CLOCK_REALTIME absolute timer with initial\n"
"       expiration and interval as specified in command line */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/timerfd_create.2:612
#, no-wrap
msgid ""
"    new_value.it_value.tv_sec = now.tv_sec + atoi(argv[1]);\n"
"    new_value.it_value.tv_nsec = now.tv_nsec;\n"
"    if (argc == 2) {\n"
"        new_value.it_interval.tv_sec = 0;\n"
"        max_exp = 1;\n"
"    } else {\n"
"        new_value.it_interval.tv_sec = atoi(argv[2]);\n"
"        max_exp = atoi(argv[3]);\n"
"    }\n"
"    new_value.it_interval.tv_nsec = 0;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/timerfd_create.2:616
#, no-wrap
msgid ""
"    fd = timerfd_create(CLOCK_REALTIME, 0);\n"
"    if (fd == -1)\n"
"        handle_error(\"timerfd_create\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/timerfd_create.2:619
#, no-wrap
msgid ""
"    if (timerfd_settime(fd, TFD_TIMER_ABSTIME, &new_value, NULL) == -1)\n"
"        handle_error(\"timerfd_settime\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/timerfd_create.2:622
#, no-wrap
msgid ""
"    print_elapsed_time();\n"
"    printf(\"timer started\\en\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/timerfd_create.2:627
#, no-wrap
msgid ""
"    for (tot_exp = 0; tot_exp E<lt> max_exp;) {\n"
"        s = read(fd, &exp, sizeof(uint64_t));\n"
"        if (s != sizeof(uint64_t))\n"
"            handle_error(\"read\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/timerfd_create.2:634
#, no-wrap
msgid ""
"        tot_exp += exp;\n"
"        print_elapsed_time();\n"
"        printf(\"read: %llu; total=%llu\\en\",\n"
"                (unsigned long long) exp,\n"
"                (unsigned long long) tot_exp);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/timerfd_create.2:649
msgid ""
"B<eventfd>(2), B<poll>(2), B<read>(2), B<select>(2), B<setitimer>(2), "
"B<signalfd>(2), B<timer_create>(2), B<timer_gettime>(2), "
"B<timer_settime>(2), B<epoll>(7), B<time>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/subpage_prot.2:30
#, no-wrap
msgid "SUBPAGE_PROT"
msgstr ""

#. type: Plain text
#: man-pages/man2/subpage_prot.2:33
msgid "subpage_prot - define a subpage protection for an address range"
msgstr ""

#. type: Plain text
#: man-pages/man2/subpage_prot.2:37
#, no-wrap
msgid ""
"B<long subpage_prot(unsigned long >I<addr>B<, unsigned long >I<len>B<,>\n"
"B<                  uint32_t *>I<map>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/subpage_prot.2:47
msgid ""
"The PowerPC-specific B<subpage_prot>()  system call provides the facility to "
"control the access permissions on individual 4\\ kB subpages on systems "
"configured with a page size of 64\\ kB."
msgstr ""

#. type: Plain text
#: man-pages/man2/subpage_prot.2:54
msgid ""
"The protection map is applied to the memory pages in the region starting at "
"I<addr> and continuing for I<len> bytes.  Both of these arguments must be "
"aligned to a 64-kB boundary."
msgstr ""

#. type: Plain text
#: man-pages/man2/subpage_prot.2:66
msgid ""
"The protection map is specified in the buffer pointed to by I<map>.  The map "
"has 2 bits per 4\\ kB subpage; thus each 32-bit word specifies the "
"protections of 16 4\\ kB subpages inside a 64\\ kB page (so, the number of "
"32-bit words pointed to by I<map> should equate to the number of 64-kB pages "
"specified by I<len>).  Each 2-bit field in the protection map is either 0 to "
"allow any access, 1 to prevent writes, or 2 or 3 to prevent all accesses."
msgstr ""

#. type: Plain text
#: man-pages/man2/subpage_prot.2:71
msgid ""
"On success, B<subpage_prot>()  returns 0.  Otherwise, one of the error codes "
"specified below is returned."
msgstr ""

#. type: Plain text
#: man-pages/man2/subpage_prot.2:77
msgid "The buffer referred to by I<map> is not accessible."
msgstr ""

#. type: Plain text
#: man-pages/man2/subpage_prot.2:87
msgid ""
"The I<addr> or I<len> arguments are incorrect.  Both of these arguments must "
"be aligned to a multiple of the system page size, and they must not refer to "
"a region outside of the address space of the process or to a region that "
"consists of huge pages."
msgstr ""

#. type: Plain text
#: man-pages/man2/subpage_prot.2:96
msgid ""
"This system call is provided on the PowerPC architecture since Linux "
"2.6.25.  The system call is provided only if the kernel is configured with "
"B<CONFIG_PPC_64K_PAGES>.  No library support is provided."
msgstr ""

#. type: Plain text
#: man-pages/man2/subpage_prot.2:106
msgid ""
"Normal page protections (at the 64-kB page level) also apply; the subpage "
"protection mechanism is an additional constraint, so putting 0 in a 2-bit "
"field won't allow writes to a page that is otherwise write-protected."
msgstr ""

#. type: SS
#: man-pages/man2/subpage_prot.2:106
#, no-wrap
msgid "Rationale"
msgstr ""

#.  In the initial implementation, it was the case that:
#.      In fact the whole process is switched to use 4 kB hardware pages when the
#.      subpage_prot system call is used, but this could be improved in future
#.      to switch only the affected segments.
#.  But Paul Mackerass says (Oct 2010): I'm pretty sure we now only switch
#.  the affected segment, not the whole process.
#. type: Plain text
#: man-pages/man2/subpage_prot.2:128
msgid ""
"This system call is provided to assist writing emulators that operate using "
"64-kB pages on PowerPC systems.  When emulating systems such as x86, which "
"uses a smaller page size, the emulator can no longer use the "
"memory-management unit (MMU)  and normal system calls for controlling page "
"protections.  (The emulator could emulate the MMU by checking and possibly "
"remapping the address for each memory access in software, but that is slow.)  "
"The idea is that the emulator supplies an array of protection masks to apply "
"to a specified range of virtual addresses.  These masks are applied at the "
"level where hardware page-table entries (PTEs)  are inserted into the "
"hardware page table based on the Linux PTEs, so the Linux PTEs are not "
"affected.  Implicit in this is that the regions of the address space that "
"are protected are switched to use 4-kB hardware pages rather than 64-kB "
"hardware pages (on machines with hardware 64-kB page support)."
msgstr ""

#. type: Plain text
#: man-pages/man2/subpage_prot.2:131
msgid "B<mprotect>(2), B<syscall>(2)"
msgstr ""

#. type: Plain text
#: man-pages/man2/subpage_prot.2:133
msgid ""
"I<Documentation/admin-guide/mm/hugetlbpage.rst> in the Linux kernel source "
"tree"
msgstr ""

#. type: TH
#: man-pages/man2/lookup_dcookie.2:27
#, no-wrap
msgid "LOOKUP_DCOOKIE"
msgstr ""

#. type: Plain text
#: man-pages/man2/lookup_dcookie.2:30
msgid "lookup_dcookie - return a directory entry's path"
msgstr ""

#. type: Plain text
#: man-pages/man2/lookup_dcookie.2:32
msgid ""
"B<int lookup_dcookie(u64 >I<cookie>B<, char *>I<buffer>B<, size_t "
">I<len>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/lookup_dcookie.2:38
msgid ""
"Look up the full path of the directory entry specified by the value "
"I<cookie>.  The cookie is an opaque identifier uniquely identifying a "
"particular directory entry.  The buffer given is filled in with the full "
"path of the directory entry."
msgstr ""

#. type: Plain text
#: man-pages/man2/lookup_dcookie.2:43
msgid ""
"For B<lookup_dcookie>()  to return successfully, the kernel must still hold "
"a cookie reference to the directory entry."
msgstr ""

#. type: Plain text
#: man-pages/man2/lookup_dcookie.2:50
msgid ""
"On success, B<lookup_dcookie>()  returns the length of the path string "
"copied into the buffer.  On error, -1 is returned, and I<errno> is set "
"appropriately."
msgstr ""

#. type: Plain text
#: man-pages/man2/lookup_dcookie.2:54
msgid "The buffer was not valid."
msgstr ""

#. type: Plain text
#: man-pages/man2/lookup_dcookie.2:58
msgid ""
"The kernel has no registered cookie/directory entry mappings at the time of "
"lookup, or the cookie does not refer to a valid directory entry."
msgstr ""

#. type: Plain text
#: man-pages/man2/lookup_dcookie.2:61
msgid "The name could not fit in the buffer."
msgstr ""

#. type: Plain text
#: man-pages/man2/lookup_dcookie.2:65
msgid ""
"The kernel could not allocate memory for the temporary buffer holding the "
"path."
msgstr ""

#. type: Plain text
#: man-pages/man2/lookup_dcookie.2:70
msgid ""
"The process does not have the capability B<CAP_SYS_ADMIN> required to look "
"up cookie values."
msgstr ""

#. type: Plain text
#: man-pages/man2/lookup_dcookie.2:73
msgid "The buffer was not large enough to hold the path of the directory entry."
msgstr ""

#. type: Plain text
#: man-pages/man2/lookup_dcookie.2:78
msgid ""
"Available since Linux 2.5.43.  The B<ENAMETOOLONG> error return was added in "
"2.5.70."
msgstr ""

#. type: Plain text
#: man-pages/man2/lookup_dcookie.2:81
msgid "B<lookup_dcookie>()  is Linux-specific."
msgstr ""

#. type: Plain text
#: man-pages/man2/lookup_dcookie.2:87
msgid ""
"B<lookup_dcookie>()  is a special-purpose system call, currently used only "
"by the B<oprofile>(1)  profiler.  It relies on a kernel driver to register "
"cookies for directory entries."
msgstr ""

#. type: Plain text
#: man-pages/man2/lookup_dcookie.2:90
msgid ""
"The path returned may be suffixed by the string \" (deleted)\" if the "
"directory entry has been removed."
msgstr ""

#. type: Plain text
#: man-pages/man2/lookup_dcookie.2:91
msgid "B<oprofile>(1)"
msgstr ""

#. type: TH
#: man-pages/man2/mincore.2:34
#, no-wrap
msgid "MINCORE"
msgstr ""

#. type: Plain text
#: man-pages/man2/mincore.2:37
msgid "mincore - determine whether pages are resident in memory"
msgstr ""

#. type: Plain text
#: man-pages/man2/mincore.2:43
msgid ""
"B<int mincore(void *>I<addr>B<, size_t >I<length>B<, unsigned char "
"*>I<vec>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/mincore.2:54
#, no-wrap
msgid ""
"B<mincore>():\n"
"    Since glibc 2.19:\n"
"        _DEFAULT_SOURCE\n"
"    Glibc 2.19 and earlier:\n"
"        _BSD_SOURCE || _SVID_SOURCE\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/mincore.2:65
msgid ""
"B<mincore>()  returns a vector that indicates whether pages of the calling "
"process's virtual memory are resident in core (RAM), and so will not cause a "
"disk access (page fault) if referenced.  The kernel returns residency "
"information about the pages starting at the address I<addr>, and continuing "
"for I<length> bytes."
msgstr ""

#. type: Plain text
#: man-pages/man2/mincore.2:79
msgid ""
"The I<addr> argument must be a multiple of the system page size.  The "
"I<length> argument need not be a multiple of the page size, but since "
"residency information is returned for whole pages, I<length> is effectively "
"rounded up to the next multiple of the page size.  One may obtain the page "
"size (B<PAGE_SIZE>)  using I<sysconf(_SC_PAGESIZE)>."
msgstr ""

#. type: Plain text
#: man-pages/man2/mincore.2:97
msgid ""
"The I<vec> argument must point to an array containing at least "
"I<(length+PAGE_SIZE-1) / PAGE_SIZE> bytes.  On return, the least significant "
"bit of each byte will be set if the corresponding page is currently resident "
"in memory, and be clear otherwise.  (The settings of the other bits in each "
"byte are undefined; these bits are reserved for possible later use.)  Of "
"course the information returned in I<vec> is only a snapshot: pages that are "
"not locked in memory can come and go at any moment, and the contents of "
"I<vec> may already be stale by the time this call returns."
msgstr ""

#. type: Plain text
#: man-pages/man2/mincore.2:104
msgid ""
"On success, B<mincore>()  returns zero.  On error, -1 is returned, and "
"I<errno> is set appropriately."
msgstr ""

#. type: Plain text
#: man-pages/man2/mincore.2:107
msgid "B<EAGAIN> kernel is temporarily out of resources."
msgstr ""

#. type: Plain text
#: man-pages/man2/mincore.2:111
msgid "I<vec> points to an invalid address."
msgstr ""

#. type: Plain text
#: man-pages/man2/mincore.2:115
msgid "I<addr> is not a multiple of the page size."
msgstr ""

#. type: Plain text
#: man-pages/man2/mincore.2:127
msgid ""
"I<length> is greater than (I<TASK_SIZE> - I<addr>).  (This could occur if a "
"negative value is specified for I<length>, since that value will be "
"interpreted as a large unsigned integer.)  In Linux 2.6.11 and earlier, the "
"error B<EINVAL> was returned for this condition."
msgstr ""

#. type: Plain text
#: man-pages/man2/mincore.2:135
msgid "I<addr> to I<addr> + I<length> contained unmapped memory."
msgstr ""

#. type: Plain text
#: man-pages/man2/mincore.2:137
msgid "Available since Linux 2.3.99pre1 and glibc 2.2."
msgstr ""

#.  It is on at least NetBSD, FreeBSD, OpenBSD, Solaris 8,
#.  AIX 5.1, SunOS 4.1
#.  .SH HISTORY
#.  The
#.  .BR mincore ()
#.  function first appeared in 4.4BSD.
#. type: Plain text
#: man-pages/man2/mincore.2:147
msgid ""
"B<mincore>()  is not specified in POSIX.1, and it is not available on all "
"UNIX implementations."
msgstr ""

#.  Linux (up to now, 2.6.5),
#.  .B mincore
#.  does not return correct information for MAP_PRIVATE mappings:
#.  for a MAP_PRIVATE file mapping,
#.  .B mincore
#.  returns the residency of the file pages, rather than any
#.  modified process-private pages that have been copied on write;
#.  for a MAP_PRIVATE mapping of
#.  .IR /dev/zero ,
#.  .B mincore
#.  always reports pages as nonresident;
#.  and for a MAP_PRIVATE, MAP_ANONYMOUS mapping,
#.  .B mincore
#.  always fails with the error
#.  .BR ENOMEM .
#. type: Plain text
#: man-pages/man2/mincore.2:169
msgid ""
"Before kernel 2.6.21, B<mincore>()  did not return correct information for "
"B<MAP_PRIVATE> mappings, or for nonlinear mappings (established using "
"B<remap_file_pages>(2))."
msgstr ""

#. type: Plain text
#: man-pages/man2/mincore.2:175
msgid ""
"B<fincore>(1), B<madvise>(2), B<mlock>(2), B<mmap>(2), B<posix_fadvise>(2), "
"B<posix_madvise>(3)"
msgstr ""

#. type: TH
#: man-pages/man2/shmctl.2:46
#, no-wrap
msgid "SHMCTL"
msgstr ""

#. type: Plain text
#: man-pages/man2/shmctl.2:49
msgid "shmctl - System V shared memory control"
msgstr ""

#. type: Plain text
#: man-pages/man2/shmctl.2:56
msgid "B<int shmctl(int >I<shmid>B<, int >I<cmd>B<, struct shmid_ds *>I<buf>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/shmctl.2:63
msgid ""
"B<shmctl>()  performs the control operation specified by I<cmd> on the "
"System\\ V shared memory segment whose identifier is given in I<shmid>."
msgstr ""

#. type: Plain text
#: man-pages/man2/shmctl.2:68
msgid ""
"The I<buf> argument is a pointer to a I<shmid_ds> structure, defined in "
"I<E<lt>sys/shm.hE<gt>> as follows:"
msgstr ""

#. type: Plain text
#: man-pages/man2/shmctl.2:82
#, no-wrap
msgid ""
"struct shmid_ds {\n"
"    struct ipc_perm shm_perm;    /* Ownership and permissions */\n"
"    size_t          shm_segsz;   /* Size of segment (bytes) */\n"
"    time_t          shm_atime;   /* Last attach time */\n"
"    time_t          shm_dtime;   /* Last detach time */\n"
"    time_t          shm_ctime;   /* Last change time */\n"
"    pid_t           shm_cpid;    /* PID of creator */\n"
"    pid_t           shm_lpid;    /* PID of last shmat(2)/shmdt(2) */\n"
"    shmatt_t        shm_nattch;  /* No. of current attaches */\n"
"    ...\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/shmctl.2:103
#, no-wrap
msgid ""
"struct ipc_perm {\n"
"    key_t          __key;    /* Key supplied to shmget(2) */\n"
"    uid_t          B<uid>;      /* Effective UID of owner */\n"
"    gid_t          B<gid>;      /* Effective GID of owner */\n"
"    uid_t          cuid;     /* Effective UID of creator */\n"
"    gid_t          cgid;     /* Effective GID of creator */\n"
"    unsigned short B<mode>;     /* B<Permissions> + SHM_DEST and\n"
"                                SHM_LOCKED flags */\n"
"    unsigned short __seq;    /* Sequence number */\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/shmctl.2:118
msgid ""
"Copy information from the kernel data structure associated with I<shmid> "
"into the I<shmid_ds> structure pointed to by I<buf>.  The caller must have "
"read permission on the shared memory segment."
msgstr ""

#. type: Plain text
#: man-pages/man2/shmctl.2:136
msgid ""
"Write the values of some members of the I<shmid_ds> structure pointed to by "
"I<buf> to the kernel data structure associated with this shared memory "
"segment, updating also its I<shm_ctime> member.  The following fields can be "
"changed: I<shm_perm.uid>, I<shm_perm.gid>, and (the least significant 9 bits "
"of) I<shm_perm.mode>.  The effective UID of the calling process must match "
"the owner (I<shm_perm.uid>)  or creator (I<shm_perm.cuid>)  of the shared "
"memory segment, or the caller must be privileged."
msgstr ""

#. type: Plain text
#: man-pages/man2/shmctl.2:149
msgid ""
"Mark the segment to be destroyed.  The segment will actually be destroyed "
"only after the last process detaches it (i.e., when the I<shm_nattch> member "
"of the associated structure I<shmid_ds> is zero).  The caller must be the "
"owner or creator of the segment, or be privileged.  The I<buf> argument is "
"ignored."
msgstr ""

#. type: Plain text
#: man-pages/man2/shmctl.2:157
msgid ""
"If a segment has been marked for destruction, then the (nonstandard)  "
"B<SHM_DEST> flag of the I<shm_perm.mode> field in the associated data "
"structure retrieved by B<IPC_STAT> will be set."
msgstr ""

#. type: Plain text
#: man-pages/man2/shmctl.2:160
msgid ""
"The caller I<must> ensure that a segment is eventually destroyed; otherwise "
"its pages that were faulted in will remain in memory or swap."
msgstr ""

#. type: Plain text
#: man-pages/man2/shmctl.2:165
msgid ""
"See also the description of I</proc/sys/kernel/shm_rmid_forced> in "
"B<proc>(5)."
msgstr ""

#. type: Plain text
#: man-pages/man2/shmctl.2:178
msgid ""
"Return information about system-wide shared memory limits and parameters in "
"the structure pointed to by I<buf>.  This structure is of type I<shminfo> "
"(thus, a cast is required), defined in I<E<lt>sys/shm.hE<gt>> if the "
"B<_GNU_SOURCE> feature test macro is defined:"
msgstr ""

#. type: Plain text
#: man-pages/man2/shmctl.2:192
#, no-wrap
msgid ""
"struct shminfo {\n"
"    unsigned long shmmax; /* Maximum segment size */\n"
"    unsigned long shmmin; /* Minimum segment size;\n"
"                             always 1 */\n"
"    unsigned long shmmni; /* Maximum number of segments */\n"
"    unsigned long shmseg; /* Maximum number of segments\n"
"                             that a process can attach;\n"
"                             unused within kernel */\n"
"    unsigned long shmall; /* Maximum number of pages of\n"
"                             shared memory, system-wide */\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/shmctl.2:205
msgid ""
"The I<shmmni>, I<shmmax>, and I<shmall> settings can be changed via I</proc> "
"files of the same name; see B<proc>(5)  for details."
msgstr ""

#. type: TP
#: man-pages/man2/shmctl.2:205
#, no-wrap
msgid "B<SHM_INFO> (Linux-specific)"
msgstr ""

#. type: Plain text
#: man-pages/man2/shmctl.2:216
msgid ""
"Return a I<shm_info> structure whose fields contain information about system "
"resources consumed by shared memory.  This structure is defined in "
"I<E<lt>sys/shm.hE<gt>> if the B<_GNU_SOURCE> feature test macro is defined:"
msgstr ""

#. type: Plain text
#: man-pages/man2/shmctl.2:233
#, no-wrap
msgid ""
"struct shm_info {\n"
"    int           used_ids; /* # of currently existing\n"
"                               segments */\n"
"    unsigned long shm_tot;  /* Total number of shared\n"
"                               memory pages */\n"
"    unsigned long shm_rss;  /* # of resident shared\n"
"                               memory pages */\n"
"    unsigned long shm_swp;  /* # of swapped shared\n"
"                               memory pages */\n"
"    unsigned long swap_attempts;\n"
"                            /* Unused since Linux 2.4 */\n"
"    unsigned long swap_successes;\n"
"                            /* Unused since Linux 2.4 */\n"
"};\n"
msgstr ""

#. type: TP
#: man-pages/man2/shmctl.2:235
#, no-wrap
msgid "B<SHM_STAT> (Linux-specific)"
msgstr ""

#. type: Plain text
#: man-pages/man2/shmctl.2:246
msgid ""
"Return a I<shmid_ds> structure as for B<IPC_STAT>.  However, the I<shmid> "
"argument is not a segment identifier, but instead an index into the kernel's "
"internal array that maintains information about all shared memory segments "
"on the system."
msgstr ""

#. type: TP
#: man-pages/man2/shmctl.2:246
#, no-wrap
msgid "B<SHM_STAT_ANY> (Linux-specific, since Linux 4.17)"
msgstr ""

#. type: Plain text
#: man-pages/man2/shmctl.2:259
msgid ""
"Return a I<shmid_ds> structure as for B<SHM_STAT>.  However, "
"I<shm_perm.mode> is not checked for read access for I<shmid>, meaning that "
"any user can employ this operation (just as any user may read "
"I</proc/sysvipc/shm> to obtain the same information)."
msgstr ""

#. type: Plain text
#: man-pages/man2/shmctl.2:262
msgid ""
"The caller can prevent or allow swapping of a shared memory segment with the "
"following I<cmd> values:"
msgstr ""

#. type: TP
#: man-pages/man2/shmctl.2:262
#, no-wrap
msgid "B<SHM_LOCK> (Linux-specific)"
msgstr ""

#. type: Plain text
#: man-pages/man2/shmctl.2:274
msgid ""
"Prevent swapping of the shared memory segment.  The caller must fault in any "
"pages that are required to be present after locking is enabled.  If a "
"segment has been locked, then the (nonstandard)  B<SHM_LOCKED> flag of the "
"I<shm_perm.mode> field in the associated data structure retrieved by "
"B<IPC_STAT> will be set."
msgstr ""

#. type: TP
#: man-pages/man2/shmctl.2:274
#, no-wrap
msgid "B<SHM_UNLOCK> (Linux-specific)"
msgstr ""

#. type: Plain text
#: man-pages/man2/shmctl.2:277
msgid "Unlock the segment, allowing it to be swapped out."
msgstr ""

#.  There was some weirdness in 2.6.9: SHM_LOCK and SHM_UNLOCK could
#.  be applied to a segment, regardless of ownership of the segment.
#.  This was a botch-up in the move to RLIMIT_MEMLOCK, and was fixed
#.  in 2.6.10.  MTK, May 2005
#. type: Plain text
#: man-pages/man2/shmctl.2:295
msgid ""
"In kernels before 2.6.10, only a privileged process could employ B<SHM_LOCK> "
"and B<SHM_UNLOCK>.  Since kernel 2.6.10, an unprivileged process can employ "
"these operations if its effective UID matches the owner or creator UID of "
"the segment, and (for B<SHM_LOCK>)  the amount of memory to be locked falls "
"within the B<RLIMIT_MEMLOCK> resource limit (see B<setrlimit>(2))."
msgstr ""

#. type: Plain text
#: man-pages/man2/shmctl.2:315
msgid ""
"A successful B<IPC_INFO> or B<SHM_INFO> operation returns the index of the "
"highest used entry in the kernel's internal array recording information "
"about all shared memory segments.  (This information can be used with "
"repeated B<SHM_STAT> or B<SHM_STAT_ANY> operations to obtain information "
"about all shared memory segments on the system.)  A successful B<SHM_STAT> "
"operation returns the identifier of the shared memory segment whose index "
"was given in I<shmid>.  Other operations return 0 on success."
msgstr ""

#. type: Plain text
#: man-pages/man2/shmctl.2:328
msgid ""
"B<IPC_STAT> or B<SHM_STAT> is requested and I<shm_perm.mode> does not allow "
"read access for I<shmid>, and the calling process does not have the "
"B<CAP_IPC_OWNER> capability in the user namespace that governs its IPC "
"namespace."
msgstr ""

#. type: Plain text
#: man-pages/man2/shmctl.2:339
msgid ""
"The argument I<cmd> has value B<IPC_SET> or B<IPC_STAT> but the address "
"pointed to by I<buf> isn't accessible."
msgstr ""

#. type: Plain text
#: man-pages/man2/shmctl.2:342 man-pages/man2/shmop.2:197
msgid "I<shmid> points to a removed identifier."
msgstr ""

#. type: Plain text
#: man-pages/man2/shmctl.2:353
msgid ""
"I<shmid> is not a valid identifier, or I<cmd> is not a valid command.  Or: "
"for a B<SHM_STAT> or B<SHM_STAT_ANY> operation, the index value specified in "
"I<shmid> referred to an array slot that is currently unused."
msgstr ""

#. type: Plain text
#: man-pages/man2/shmctl.2:364
msgid ""
"(In kernels since 2.6.9), B<SHM_LOCK> was specified and the size of the "
"to-be-locked segment would mean that the total bytes in locked shared memory "
"segments would exceed the limit for the real user ID of the calling "
"process.  This limit is defined by the B<RLIMIT_MEMLOCK> soft resource limit "
"(see B<setrlimit>(2))."
msgstr ""

#. type: Plain text
#: man-pages/man2/shmctl.2:369
msgid ""
"B<IPC_STAT> is attempted, and the GID or UID value is too large to be stored "
"in the structure pointed to by I<buf>."
msgstr ""

#. type: Plain text
#: man-pages/man2/shmctl.2:381
msgid ""
"B<IPC_SET> or B<IPC_RMID> is attempted, and the effective user ID of the "
"calling process is not that of the creator (found in I<shm_perm.cuid>), or "
"the owner (found in I<shm_perm.uid>), and the process was not privileged "
"(Linux: did not have the B<CAP_SYS_ADMIN> capability)."
msgstr ""

#. type: Plain text
#: man-pages/man2/shmctl.2:393
msgid ""
"Or (in kernels before 2.6.9), B<SHM_LOCK> or B<SHM_UNLOCK> was specified, "
"but the process was not privileged (Linux: did not have the B<CAP_IPC_LOCK> "
"capability).  (Since Linux 2.6.9, this error can also occur if the "
"B<RLIMIT_MEMLOCK> is 0 and the caller is not privileged.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/shmctl.2:423
msgid ""
"The B<IPC_INFO>, B<SHM_STAT> and B<SHM_INFO> operations are used by the "
"B<ipcs>(1)  program to provide information on allocated resources.  In the "
"future, these may modified or moved to a I</proc> filesystem interface."
msgstr ""

#. type: Plain text
#: man-pages/man2/shmctl.2:431
msgid ""
"Linux permits a process to attach (B<shmat>(2))  a shared memory segment "
"that has already been marked for deletion using I<shmctl(IPC_RMID)>.  This "
"feature is not available on other UNIX implementations; portable "
"applications should avoid relying on it."
msgstr ""

#. type: Plain text
#: man-pages/man2/shmctl.2:444
msgid ""
"Various fields in a I<struct shmid_ds> were typed as I<short> under Linux "
"2.2 and have become I<long> under Linux 2.4.  To take advantage of this, a "
"recompilation under glibc-2.1.91 or later should suffice.  (The kernel "
"distinguishes old and new calls by an B<IPC_64> flag in I<cmd>.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/shmctl.2:450
msgid ""
"B<mlock>(2), B<setrlimit>(2), B<shmget>(2), B<shmop>(2), B<capabilities>(7), "
"B<sysvipc>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/epoll_wait.2:22
#, no-wrap
msgid "EPOLL_WAIT"
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_wait.2:25
msgid "epoll_wait, epoll_pwait - wait for an I/O event on an epoll file descriptor"
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_wait.2:34
#, no-wrap
msgid ""
"B<int epoll_wait(int >I<epfd>B<, struct epoll_event *>I<events>B<,>\n"
"B<               int >I<maxevents>B<, int >I<timeout>B<);>\n"
"B<int epoll_pwait(int >I<epfd>B<, struct epoll_event *>I<events>B<,>\n"
"B<               int >I<maxevents>B<, int >I<timeout>B<,>\n"
"B<               const sigset_t *>I<sigmask>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_wait.2:52
msgid ""
"The B<epoll_wait>()  system call waits for events on the B<epoll>(7)  "
"instance referred to by the file descriptor I<epfd>.  The memory area "
"pointed to by I<events> will contain the events that will be available for "
"the caller.  Up to I<maxevents> are returned by B<epoll_wait>().  The "
"I<maxevents> argument must be greater than zero."
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_wait.2:62
msgid ""
"The I<timeout> argument specifies the number of milliseconds that "
"B<epoll_wait>()  will block.  Time is measured against the "
"B<CLOCK_MONOTONIC> clock.  The call will block until either:"
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_wait.2:64
msgid "a file descriptor delivers an event;"
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_wait.2:83
msgid ""
"Note that the I<timeout> interval will be rounded up to the system clock "
"granularity, and kernel scheduling delays mean that the blocking interval "
"may overrun by a small amount.  Specifying a I<timeout> of -1 causes "
"B<epoll_wait>()  to block indefinitely, while specifying a I<timeout> equal "
"to zero cause B<epoll_wait>()  to return immediately, even if no events are "
"available."
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_wait.2:87
msgid "The I<struct epoll_event> is defined as:"
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_wait.2:96
#, no-wrap
msgid ""
"typedef union epoll_data {\n"
"    void    *ptr;\n"
"    int      fd;\n"
"    uint32_t u32;\n"
"    uint64_t u64;\n"
"} epoll_data_t;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_wait.2:101
#, no-wrap
msgid ""
"struct epoll_event {\n"
"    uint32_t     events;    /* Epoll events */\n"
"    epoll_data_t data;      /* User data variable */\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_wait.2:114
msgid ""
"The I<data> field of each returned structure contains the same data as was "
"specified in the most recent call to B<epoll_ctl>(2)  (B<EPOLL_CTL_ADD>, "
"B<EPOLL_CTL_MOD>)  for the corresponding open file description.  The "
"I<events> field contains the returned event bit field."
msgstr ""

#. type: SS
#: man-pages/man2/epoll_wait.2:114
#, no-wrap
msgid "epoll_pwait()"
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_wait.2:128
msgid ""
"The relationship between B<epoll_wait>()  and B<epoll_pwait>()  is analogous "
"to the relationship between B<select>(2)  and B<pselect>(2): like "
"B<pselect>(2), B<epoll_pwait>()  allows an application to safely wait until "
"either a file descriptor becomes ready or until a signal is caught."
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_wait.2:132
msgid "The following B<epoll_pwait>()  call:"
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_wait.2:136
#, no-wrap
msgid "ready = epoll_pwait(epfd, &events, maxevents, timeout, &sigmask);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_wait.2:142 man-pages/man2/select.2:231
msgid "is equivalent to I<atomically> executing the following calls:"
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_wait.2:146 man-pages/man2/select.2:235
#, no-wrap
msgid "sigset_t origmask;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_wait.2:150
#, no-wrap
msgid ""
"pthread_sigmask(SIG_SETMASK, &sigmask, &origmask);\n"
"ready = epoll_wait(epfd, &events, maxevents, timeout);\n"
"pthread_sigmask(SIG_SETMASK, &origmask, NULL);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_wait.2:159
msgid ""
"The I<sigmask> argument may be specified as NULL, in which case "
"B<epoll_pwait>()  is equivalent to B<epoll_wait>()."
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_wait.2:171
msgid ""
"When successful, B<epoll_wait>()  returns the number of file descriptors "
"ready for the requested I/O, or zero if no file descriptor became ready "
"during the requested I<timeout> milliseconds.  When an error occurs, "
"B<epoll_wait>()  returns -1 and I<errno> is set appropriately."
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_wait.2:176
msgid "I<epfd> is not a valid file descriptor."
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_wait.2:181
msgid ""
"The memory area pointed to by I<events> is not accessible with write "
"permissions."
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_wait.2:188
msgid ""
"The call was interrupted by a signal handler before either (1) any of the "
"requested events occurred or (2) the I<timeout> expired; see B<signal>(7)."
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_wait.2:196
msgid ""
"I<epfd> is not an B<epoll> file descriptor, or I<maxevents> is less than or "
"equal to zero."
msgstr ""

#.  To be precise: kernel 2.5.44.
#.  The interface should be finalized by Linux kernel 2.5.66.
#. type: Plain text
#: man-pages/man2/epoll_wait.2:202
msgid ""
"B<epoll_wait>()  was added to the kernel in version 2.6.  Library support is "
"provided in glibc starting with version 2.3.2."
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_wait.2:206
msgid ""
"B<epoll_pwait>()  was added to Linux in kernel 2.6.19.  Library support is "
"provided in glibc starting with version 2.6."
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_wait.2:209
msgid "B<epoll_wait>()  is Linux-specific."
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_wait.2:219
msgid ""
"While one thread is blocked in a call to B<epoll_wait>(), it is possible for "
"another thread to add a file descriptor to the waited-upon B<epoll> "
"instance.  If the new file descriptor becomes ready, it will cause the "
"B<epoll_wait>()  call to unblock."
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_wait.2:231
msgid ""
"If more than I<maxevents> file descriptors are ready when B<epoll_wait>()  "
"is called, then successive B<epoll_wait>()  calls will round robin through "
"the set of ready file descriptors.  This behavior helps avoid starvation "
"scenarios, where a process fails to notice that additional file descriptors "
"are ready because it focuses on a set of file descriptors that are already "
"known to be ready."
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_wait.2:241
msgid ""
"Note that it is possible to call B<epoll_wait>()  on an B<epoll> instance "
"whose interest list is currently empty (or whose interest list becomes empty "
"because file descriptors are closed or removed from the interest in another "
"thread).  The call will block until some file descriptor is later added to "
"the interest list (in another thread) and that file descriptor becomes "
"ready."
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_wait.2:253
msgid ""
"In kernels before 2.6.37, a I<timeout> value larger than approximately "
"I<LONG_MAX / HZ> milliseconds is treated as -1 (i.e., infinity).  Thus, for "
"example, on a system where I<sizeof(long)> is 4 and the kernel I<HZ> value "
"is 1000, this means that timeouts greater than 35.79 minutes are treated as "
"infinity."
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_wait.2:266
msgid ""
"The raw B<epoll_pwait>()  system call has a sixth argument, I<size_t "
"sigsetsize>, which specifies the size in bytes of the I<sigmask> argument.  "
"The glibc B<epoll_pwait>()  wrapper function specifies this argument as a "
"fixed value (equal to I<sizeof(sigset_t)>)."
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_wait.2:269
msgid "B<epoll_create>(2), B<epoll_ctl>(2), B<epoll>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/setup.2:34
#, no-wrap
msgid "SETUP"
msgstr ""

#. type: TH
#: man-pages/man2/setup.2:34
#, no-wrap
msgid "2008-12-03"
msgstr ""

#. type: Plain text
#: man-pages/man2/setup.2:37
msgid "setup - setup devices and filesystems, mount root filesystem"
msgstr ""

#. type: Plain text
#: man-pages/man2/setup.2:41
msgid "B<int setup(void);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/setup.2:47
msgid ""
"B<setup>()  is called once from within I<linux/init/main.c>.  It calls "
"initialization functions for devices and filesystems configured into the "
"kernel and then mounts the root filesystem."
msgstr ""

#. type: Plain text
#: man-pages/man2/setup.2:53
msgid ""
"No user process may call B<setup>().  Any user process, even a process with "
"superuser permission, will receive B<EPERM>."
msgstr ""

#. type: Plain text
#: man-pages/man2/setup.2:56
msgid "B<setup>()  always returns -1 for a user process."
msgstr ""

#. type: Plain text
#: man-pages/man2/setup.2:62
msgid "Since Linux 2.1.121, no such function exists anymore."
msgstr ""

#. type: Plain text
#: man-pages/man2/setup.2:65
msgid ""
"This function is Linux-specific, and should not be used in programs intended "
"to be portable, or indeed in any programs at all."
msgstr ""

#. type: Plain text
#: man-pages/man2/setup.2:71
msgid ""
"The calling sequence varied: at some times B<setup>()  has had a single "
"argument I<void\\ *BIOS> and at other times a single argument I<int magic>."
msgstr ""

#. type: TH
#: man-pages/man2/sigprocmask.2:29
#, no-wrap
msgid "SIGPROCMASK"
msgstr ""

#. type: Plain text
#: man-pages/man2/sigprocmask.2:32
msgid "sigprocmask, rt_sigprocmask - examine and change blocked signals"
msgstr ""

#. type: Plain text
#: man-pages/man2/sigprocmask.2:38
#, no-wrap
msgid ""
"/* Prototype for the glibc wrapper function */\n"
"B<int sigprocmask(int >I<how>B<, const sigset_t *>I<set>B<, sigset_t "
"*>I<oldset>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/sigprocmask.2:42
#, no-wrap
msgid ""
"/* Prototype for the underlying system call */\n"
"B<int rt_sigprocmask(int >I<how>B<, const kernel_sigset_t *>I<set>B<,>\n"
"B<                   kernel_sigset_t *>I<oldset>B<, size_t "
">I<sigsetsize>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/sigprocmask.2:46
#, no-wrap
msgid ""
"/* Prototype for the legacy system call (deprecated) */\n"
"B<int sigprocmask(int >I<how>B<, const old_kernel_sigset_t *>I<set>B<,>\n"
"B<                old_kernel_sigset_t *>I<oldset>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/sigprocmask.2:56
msgid "B<sigprocmask>(): _POSIX_C_SOURCE"
msgstr ""

#. type: Plain text
#: man-pages/man2/sigprocmask.2:65
msgid ""
"B<sigprocmask>()  is used to fetch and/or change the signal mask of the "
"calling thread.  The signal mask is the set of signals whose delivery is "
"currently blocked for the caller (see also B<signal>(7)  for more details)."
msgstr ""

#. type: Plain text
#: man-pages/man2/sigprocmask.2:69
msgid "The behavior of the call is dependent on the value of I<how>, as follows."
msgstr ""

#. type: TP
#: man-pages/man2/sigprocmask.2:69
#, no-wrap
msgid "B<SIG_BLOCK>"
msgstr ""

#. type: Plain text
#: man-pages/man2/sigprocmask.2:74
msgid ""
"The set of blocked signals is the union of the current set and the I<set> "
"argument."
msgstr ""

#. type: TP
#: man-pages/man2/sigprocmask.2:74
#, no-wrap
msgid "B<SIG_UNBLOCK>"
msgstr ""

#. type: Plain text
#: man-pages/man2/sigprocmask.2:80
msgid ""
"The signals in I<set> are removed from the current set of blocked signals.  "
"It is permissible to attempt to unblock a signal which is not blocked."
msgstr ""

#. type: TP
#: man-pages/man2/sigprocmask.2:80
#, no-wrap
msgid "B<SIG_SETMASK>"
msgstr ""

#. type: Plain text
#: man-pages/man2/sigprocmask.2:84
msgid "The set of blocked signals is set to the argument I<set>."
msgstr ""

#. type: Plain text
#: man-pages/man2/sigprocmask.2:89
msgid ""
"If I<oldset> is non-NULL, the previous value of the signal mask is stored in "
"I<oldset>."
msgstr ""

#. type: Plain text
#: man-pages/man2/sigprocmask.2:98
msgid ""
"If I<set> is NULL, then the signal mask is unchanged (i.e., I<how> is "
"ignored), but the current value of the signal mask is nevertheless returned "
"in I<oldset> (if it is not NULL)."
msgstr ""

#. type: Plain text
#: man-pages/man2/sigprocmask.2:103
msgid ""
"A set of functions for modifying and inspecting variables of type "
"I<sigset_t> (\"signal sets\") is described in B<sigsetops>(3)."
msgstr ""

#. type: Plain text
#: man-pages/man2/sigprocmask.2:108
msgid ""
"The use of B<sigprocmask>()  is unspecified in a multithreaded process; see "
"B<pthread_sigmask>(3)."
msgstr ""

#. type: Plain text
#: man-pages/man2/sigprocmask.2:114
msgid ""
"B<sigprocmask>()  returns 0 on success and -1 on error.  In the event of an "
"error, I<errno> is set to indicate the cause."
msgstr ""

#. type: Plain text
#: man-pages/man2/sigprocmask.2:122
msgid ""
"The I<set> or I<oldset> argument points outside the process's allocated "
"address space."
msgstr ""

#. type: Plain text
#: man-pages/man2/sigprocmask.2:128
msgid ""
"Either the value specified in I<how> was invalid or the kernel does not "
"support the size passed in I<sigsetsize.>"
msgstr ""

#. type: Plain text
#: man-pages/man2/sigprocmask.2:134
msgid ""
"It is not possible to block B<SIGKILL> or B<SIGSTOP>.  Attempts to do so are "
"silently ignored."
msgstr ""

#. type: Plain text
#: man-pages/man2/sigprocmask.2:136
msgid "Each of the threads in a process has its own signal mask."
msgstr ""

#. type: Plain text
#: man-pages/man2/sigprocmask.2:142
msgid ""
"A child created via B<fork>(2)  inherits a copy of its parent's signal mask; "
"the signal mask is preserved across B<execve>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/sigprocmask.2:156
msgid ""
"If B<SIGBUS>, B<SIGFPE>, B<SIGILL>, or B<SIGSEGV> are generated while they "
"are blocked, the result is undefined, unless the signal was generated by "
"B<kill>(2), B<sigqueue>(3), or B<raise>(3)."
msgstr ""

#. type: Plain text
#: man-pages/man2/sigprocmask.2:167
msgid ""
"Note that it is permissible (although not very useful) to specify both "
"I<set> and I<oldset> as NULL."
msgstr ""

#. type: Plain text
#: man-pages/man2/sigprocmask.2:178
msgid ""
"The kernel's definition of I<sigset_t> differs in size from that used by the "
"C library.  In this manual page, the former is referred to as "
"I<kernel_sigset_t> (it is nevertheless named I<sigset_t> in the kernel "
"sources)."
msgstr ""

#. type: Plain text
#: man-pages/man2/sigprocmask.2:186
msgid ""
"The glibc wrapper function for B<sigprocmask>()  silently ignores attempts "
"to block the two real-time signals that are used internally by the NPTL "
"threading implementation.  See B<nptl>(7)  for details."
msgstr ""

#.  sizeof(kernel_sigset_t) == _NSIG / 8,
#.  which equals to 8 on most architectures, but e.g. on MIPS it's 16.
#. type: Plain text
#: man-pages/man2/sigprocmask.2:215
msgid ""
"The original Linux system call was named B<sigprocmask>().  However, with "
"the addition of real-time signals in Linux 2.2, the fixed-size, 32-bit "
"I<sigset_t> (referred to as I<old_kernel_sigset_t> in this manual page)  "
"type supported by that system call was no longer fit for purpose.  "
"Consequently, a new system call, B<rt_sigprocmask>(), was added to support "
"an enlarged I<sigset_t> type (referred to as I<kernel_sigset_t> in this "
"manual page).  The new system call takes a fourth argument, I<size_t "
"sigsetsize>, which specifies the size in bytes of the signal sets in I<set> "
"and I<oldset>.  This argument is currently required to have a fixed "
"architecture specific value (equal to I<sizeof(kernel_sigset_t)>)."
msgstr ""

#. type: Plain text
#: man-pages/man2/sigprocmask.2:222
msgid ""
"The glibc B<sigprocmask>()  wrapper function hides these details from us, "
"transparently calling B<rt_sigprocmask>()  when the kernel provides it."
msgstr ""

#. type: Plain text
#: man-pages/man2/sigprocmask.2:232
msgid ""
"B<kill>(2), B<pause>(2), B<sigaction>(2), B<signal>(2), B<sigpending>(2), "
"B<sigsuspend>(2), B<pthread_sigmask>(3), B<sigqueue>(3), B<sigsetops>(3), "
"B<signal>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/timer_getoverrun.2:26
#, no-wrap
msgid "TIMER_GETOVERRUN"
msgstr ""

#. type: Plain text
#: man-pages/man2/timer_getoverrun.2:29
msgid "timer_getoverrun - get overrun count for a POSIX per-process timer"
msgstr ""

#. type: Plain text
#: man-pages/man2/timer_getoverrun.2:34
#, no-wrap
msgid "B<int timer_getoverrun(timer_t >I<timerid>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/timer_getoverrun.2:45
msgid "B<timer_getoverrun>(): _POSIX_C_SOURCE\\ E<gt>=\\ 199309L"
msgstr ""

#. type: Plain text
#: man-pages/man2/timer_getoverrun.2:56
msgid ""
"B<timer_getoverrun>()  returns the \"overrun count\" for the timer referred "
"to by I<timerid>.  An application can use the overrun count to accurately "
"calculate the number of timer expirations that would have occurred over a "
"given time interval.  Timer overruns can occur both when receiving "
"expiration notifications via signals (B<SIGEV_SIGNAL>), and via threads "
"(B<SIGEV_THREAD>)."
msgstr ""

#. type: Plain text
#: man-pages/man2/timer_getoverrun.2:76
msgid ""
"When expiration notifications are delivered via a signal, overruns can occur "
"as follows.  Regardless of whether or not a real-time signal is used for "
"timer notifications, the system queues at most one signal per timer.  (This "
"is the behavior specified by POSIX.1.  The alternative, queuing one signal "
"for each timer expiration, could easily result in overflowing the allowed "
"limits for queued signals on the system.)  Because of system scheduling "
"delays, or because the signal may be temporarily blocked, there can be a "
"delay between the time when the notification signal is generated and the "
"time when it is delivered (e.g., caught by a signal handler) or accepted "
"(e.g., using B<sigwaitinfo>(2)).  In this interval, further timer "
"expirations may occur.  The timer overrun count is the number of additional "
"timer expirations that occurred between the time when the signal was "
"generated and when it was delivered or accepted."
msgstr ""

#. type: Plain text
#: man-pages/man2/timer_getoverrun.2:82
msgid ""
"Timer overruns can also occur when expiration notifications are delivered "
"via invocation of a thread, since there may be an arbitrary delay between an "
"expiration of the timer and the invocation of the notification thread, and "
"in that delay interval, additional timer expirations may occur."
msgstr ""

#. type: Plain text
#: man-pages/man2/timer_getoverrun.2:90
msgid ""
"On success, B<timer_getoverrun>()  returns the overrun count of the "
"specified timer; this count may be 0 if no overruns have occurred.  On "
"failure, -1 is returned, and I<errno> is set to indicate the error."
msgstr ""

#. type: Plain text
#: man-pages/man2/timer_getoverrun.2:111
msgid ""
"When timer notifications are delivered via signals (B<SIGEV_SIGNAL>), on "
"Linux it is also possible to obtain the overrun count via the I<si_overrun> "
"field of the I<siginfo_t> structure (see B<sigaction>(2)).  This allows an "
"application to avoid the overhead of making a system call to obtain the "
"overrun count, but is a nonportable extension to POSIX.1."
msgstr ""

#.  FIXME . Austin bug filed, 11 Feb 09
#. type: Plain text
#: man-pages/man2/timer_getoverrun.2:115
msgid ""
"POSIX.1 discusses timer overruns only in the context of timer notifications "
"using signals."
msgstr ""

#.  Bug filed: http://bugzilla.kernel.org/show_bug.cgi?id=12665
#.  http://thread.gmane.org/gmane.linux.kernel/113276/
#. type: Plain text
#: man-pages/man2/timer_getoverrun.2:128
msgid ""
"POSIX.1 specifies that if the timer overrun count is equal to or greater "
"than an implementation-defined maximum, B<DELAYTIMER_MAX>, then "
"B<timer_getoverrun>()  should return B<DELAYTIMER_MAX>.  However, Linux does "
"not implement this feature: instead, if the timer overrun value exceeds the "
"maximum representable integer, the counter cycles, starting once more from "
"low values."
msgstr ""

#. type: Plain text
#: man-pages/man2/timer_getoverrun.2:140
msgid ""
"B<clock_gettime>(2), B<sigaction>(2), B<signalfd>(2), B<sigwaitinfo>(2), "
"B<timer_create>(2), B<timer_delete>(2), B<timer_settime>(2), B<signal>(7), "
"B<time>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/futimesat.2:25
#, no-wrap
msgid "FUTIMESAT"
msgstr ""

#. type: Plain text
#: man-pages/man2/futimesat.2:29
msgid ""
"futimesat - change timestamps of a file relative to a directory file "
"descriptor"
msgstr ""

#. type: Plain text
#: man-pages/man2/futimesat.2:33
#, no-wrap
msgid ""
"B<#include E<lt>fcntl.hE<gt> /* Definition of AT_* constants */>\n"
"B<#include E<lt>sys/time.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/futimesat.2:36
#, no-wrap
msgid ""
"B<int futimesat(int >I<dirfd>B<, const char *>I<pathname>B<,>\n"
"B<              const struct timeval >I<times>B<[2]);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/futimesat.2:45
msgid "B<futimesat>(): _GNU_SOURCE"
msgstr ""

#. type: Plain text
#: man-pages/man2/futimesat.2:50
msgid "This system call is obsolete.  Use B<utimensat>(2)  instead."
msgstr ""

#. type: Plain text
#: man-pages/man2/futimesat.2:56
msgid ""
"The B<futimesat>()  system call operates in exactly the same way as "
"B<utimes>(2), except for the differences described in this manual page."
msgstr ""

#. type: Plain text
#: man-pages/man2/futimesat.2:66
msgid ""
"If the pathname given in I<pathname> is relative, then it is interpreted "
"relative to the directory referred to by the file descriptor I<dirfd> "
"(rather than relative to the current working directory of the calling "
"process, as is done by B<utimes>(2)  for a relative pathname)."
msgstr ""

#. type: Plain text
#: man-pages/man2/futimesat.2:91
msgid ""
"On success, B<futimesat>()  returns a 0.  On error, -1 is returned and "
"I<errno> is set to indicate the error."
msgstr ""

#. type: Plain text
#: man-pages/man2/futimesat.2:98
msgid ""
"The same errors that occur for B<utimes>(2)  can also occur for "
"B<futimesat>().  The following additional errors can occur for "
"B<futimesat>():"
msgstr ""

#. type: Plain text
#: man-pages/man2/futimesat.2:112
msgid ""
"B<futimesat>()  was added to Linux in kernel 2.6.16; library support was "
"added to glibc in version 2.4."
msgstr ""

#. type: Plain text
#: man-pages/man2/futimesat.2:117
msgid ""
"This system call is nonstandard.  It was implemented from a specification "
"that was proposed for POSIX.1, but that specification was replaced by the "
"one for B<utimensat>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/futimesat.2:119
msgid "A similar system call exists on Solaris."
msgstr ""

#.  The Solaris futimesat() also has this strangeness.
#. type: Plain text
#: man-pages/man2/futimesat.2:128
msgid ""
"If I<pathname> is NULL, then the glibc B<futimesat>()  wrapper function "
"updates the times for the file referred to by I<dirfd>."
msgstr ""

#. type: Plain text
#: man-pages/man2/futimesat.2:133
msgid ""
"B<stat>(2), B<utimensat>(2), B<utimes>(2), B<futimes>(3), "
"B<path_resolution>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/getitimer.2:13
#, no-wrap
msgid "GETITIMER"
msgstr ""

#. type: Plain text
#: man-pages/man2/getitimer.2:16
msgid "getitimer, setitimer - get or set value of an interval timer"
msgstr ""

#. type: Plain text
#: man-pages/man2/getitimer.2:23
#, no-wrap
msgid ""
"B<int getitimer(int >I<which>B<, struct itimerval *>I<curr_value>B<);>\n"
"B<int setitimer(int >I<which>B<, const struct itimerval *>I<new_value>B<,>\n"
"B<              struct itimerval *>I<old_value>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/getitimer.2:31
msgid ""
"These system calls provide access to interval timers, that is, timers that "
"initially expire at some point in the future, and (optionally) at regular "
"intervals after that.  When a timer expires, a signal is generated for the "
"calling process, and the timer is reset to the specified interval (if the "
"interval is nonzero)."
msgstr ""

#. type: Plain text
#: man-pages/man2/getitimer.2:37
msgid ""
"Three types of timers\\(emspecified via the I<which> argument\\(emare "
"provided, each of which counts against a different clock and generates a "
"different signal on timer expiration:"
msgstr ""

#. type: TP
#: man-pages/man2/getitimer.2:37
#, no-wrap
msgid "B<ITIMER_REAL>"
msgstr ""

#. type: Plain text
#: man-pages/man2/getitimer.2:43
msgid ""
"This timer counts down in real (i.e., wall clock) time.  At each expiration, "
"a B<SIGALRM> signal is generated."
msgstr ""

#. type: TP
#: man-pages/man2/getitimer.2:43
#, no-wrap
msgid "B<ITIMER_VIRTUAL>"
msgstr ""

#. type: Plain text
#: man-pages/man2/getitimer.2:50
msgid ""
"This timer counts down against the user-mode CPU time consumed by the "
"process.  (The measurement includes CPU time consumed by all threads in the "
"process.)  At each expiration, a B<SIGVTALRM> signal is generated."
msgstr ""

#. type: TP
#: man-pages/man2/getitimer.2:50
#, no-wrap
msgid "B<ITIMER_PROF>"
msgstr ""

#. type: Plain text
#: man-pages/man2/getitimer.2:58
msgid ""
"This timer counts down against the total (i.e., both user and system)  CPU "
"time consumed by the process.  (The measurement includes CPU time consumed "
"by all threads in the process.)  At each expiration, a B<SIGPROF> signal is "
"generated."
msgstr ""

#. type: Plain text
#: man-pages/man2/getitimer.2:63
msgid ""
"In conjunction with B<ITIMER_VIRTUAL>, this timer can be used to profile "
"user and system CPU time consumed by the process."
msgstr ""

#. type: Plain text
#: man-pages/man2/getitimer.2:65
msgid "A process has only one of each of the three types of timers."
msgstr ""

#. type: Plain text
#: man-pages/man2/getitimer.2:67
msgid "Timer values are defined by the following structures:"
msgstr ""

#. type: Plain text
#: man-pages/man2/getitimer.2:74
#, no-wrap
msgid ""
"struct itimerval {\n"
"    struct timeval it_interval; /* Interval for periodic timer */\n"
"    struct timeval it_value;    /* Time until next expiration */\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/getitimer.2:79
#, no-wrap
msgid ""
"struct timeval {\n"
"    time_t      tv_sec;         /* seconds */\n"
"    suseconds_t tv_usec;        /* microseconds */\n"
"};\n"
msgstr ""

#. type: SS
#: man-pages/man2/getitimer.2:82
#, no-wrap
msgid "getitimer()"
msgstr ""

#. type: Plain text
#: man-pages/man2/getitimer.2:89
msgid ""
"The function B<getitimer>()  places the current value of the timer specified "
"by I<which> in the buffer pointed to by I<curr_value>."
msgstr ""

#. type: Plain text
#: man-pages/man2/getitimer.2:100
msgid ""
"The I<it_value> substructure is populated with the amount of time remaining "
"until the next expiration of the specified timer.  This value changes as the "
"timer counts down, and will be reset to I<it_interval> when the timer "
"expires.  If both fields of I<it_value> are zero, then this timer is "
"currently disarmed (inactive)."
msgstr ""

#. type: Plain text
#: man-pages/man2/getitimer.2:107
msgid ""
"The I<it_interval> substructure is populated with the timer interval.  If "
"both fields of I<it_interval> are zero, then this is a single-shot timer "
"(i.e., it expires just once)."
msgstr ""

#. type: SS
#: man-pages/man2/getitimer.2:107
#, no-wrap
msgid "setitimer()"
msgstr ""

#. type: Plain text
#: man-pages/man2/getitimer.2:120
msgid ""
"The function B<setitimer>()  arms or disarms the timer specified by "
"I<which>, by setting the timer to the value specified by I<new_value>.  If "
"I<old_value> is non-NULL, the buffer it points to is used to return the "
"previous value of the timer (i.e., the same information that is returned by "
"B<getitimer>())."
msgstr ""

#. type: Plain text
#: man-pages/man2/getitimer.2:128
msgid ""
"If either field in I<new_value.it_value> is nonzero, then the timer is armed "
"to initially expire at the specified time.  If both fields in "
"I<new_value.it_value> are zero, then the timer is disarmed."
msgstr ""

#. type: Plain text
#: man-pages/man2/getitimer.2:133
msgid ""
"The I<new_value.it_interval> field specifies the new interval for the timer; "
"if both of its subfields are zero, the timer is single-shot."
msgstr ""

#. type: Plain text
#: man-pages/man2/getitimer.2:159
msgid ""
"I<which> is not one of B<ITIMER_REAL>, B<ITIMER_VIRTUAL>, or B<ITIMER_PROF>; "
"or (since Linux 2.6.22) one of the I<tv_usec> fields in the structure "
"pointed to by I<new_value> contains a value outside the range 0 to 999999."
msgstr ""

#. type: Plain text
#: man-pages/man2/getitimer.2:169
msgid ""
"POSIX.1-2001, SVr4, 4.4BSD (this call first appeared in 4.2BSD).  "
"POSIX.1-2008 marks B<getitimer>()  and B<setitimer>()  obsolete, "
"recommending the use of the POSIX timers API (B<timer_gettime>(2), "
"B<timer_settime>(2), etc.) instead."
msgstr ""

#. type: Plain text
#: man-pages/man2/getitimer.2:178
msgid ""
"Timers will never expire before the requested time, but may expire some "
"(short) time afterward, which depends on the system timer resolution and on "
"the system load; see B<time>(7).  (But see BUGS below.)  If the timer "
"expires while the process is active (always true for B<ITIMER_VIRTUAL>), the "
"signal will be delivered immediately when generated."
msgstr ""

#. type: Plain text
#: man-pages/man2/getitimer.2:184
msgid ""
"A child created via B<fork>(2)  does not inherit its parent's interval "
"timers.  Interval timers are preserved across an B<execve>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/getitimer.2:194
msgid ""
"POSIX.1 leaves the interaction between B<setitimer>()  and the three "
"interfaces B<alarm>(2), B<sleep>(3), and B<usleep>(3)  unspecified."
msgstr ""

#. type: Plain text
#: man-pages/man2/getitimer.2:196
msgid "The standards are silent on the meaning of the call:"
msgstr ""

#. type: Plain text
#: man-pages/man2/getitimer.2:198
#, no-wrap
msgid "    setitimer(which, NULL, &old_value);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/getitimer.2:201
msgid ""
"Many systems (Solaris, the BSDs, and perhaps others)  treat this as "
"equivalent to:"
msgstr ""

#. type: Plain text
#: man-pages/man2/getitimer.2:203
#, no-wrap
msgid "    getitimer(which, &old_value);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/getitimer.2:209
msgid ""
"In Linux, this is treated as being equivalent to a call in which the "
"I<new_value> fields are zero; that is, the timer is disabled.  I<Don't use "
"this Linux misfeature>: it is nonportable and unnecessary."
msgstr ""

#. type: Plain text
#: man-pages/man2/getitimer.2:218
msgid ""
"The generation and delivery of a signal are distinct, and only one instance "
"of each of the signals listed above may be pending for a process.  Under "
"very heavy loading, an B<ITIMER_REAL> timer may expire before the signal "
"from a previous expiration has been delivered.  The second signal in such an "
"event will be lost."
msgstr ""

#. type: Plain text
#: man-pages/man2/getitimer.2:233
msgid ""
"On Linux kernels before 2.6.16, timer values are represented in jiffies.  If "
"a request is made set a timer with a value whose jiffies representation "
"exceeds B<MAX_SEC_IN_JIFFIES> (defined in I<include/linux/jiffies.h>), then "
"the timer is silently truncated to this ceiling value.  On Linux/i386 "
"(where, since Linux 2.6.13, the default jiffy is 0.004 seconds), this means "
"that the ceiling value for a timer is approximately 99.42 days.  Since Linux "
"2.6.16, the kernel uses a different internal representation for times, and "
"this ceiling is removed."
msgstr ""

#.  4 Jul 2005: It looks like this bug may remain in 2.4.x.
#. 	http://lkml.org/lkml/2005/7/1/165
#. type: Plain text
#: man-pages/man2/getitimer.2:240
msgid ""
"On certain systems (including i386), Linux kernels before version 2.6.12 "
"have a bug which will produce premature timer expirations of up to one jiffy "
"under some circumstances.  This bug is fixed in kernel 2.6.12."
msgstr ""

#.  Bugzilla report 25 Apr 2006:
#.  http://bugzilla.kernel.org/show_bug.cgi?id=6443
#.  "setitimer() should reject noncanonical arguments"
#. type: Plain text
#: man-pages/man2/getitimer.2:259
msgid ""
"POSIX.1-2001 says that B<setitimer>()  should fail if a I<tv_usec> value is "
"specified that is outside of the range 0 to 999999.  However, in kernels up "
"to and including 2.6.21, Linux does not give an error, but instead silently "
"adjusts the corresponding seconds value for the timer.  From kernel 2.6.22 "
"onward, this nonconformance has been repaired: an improper I<tv_usec> value "
"results in an B<EINVAL> error."
msgstr ""

#. type: Plain text
#: man-pages/man2/getitimer.2:265
msgid ""
"B<gettimeofday>(2), B<sigaction>(2), B<signal>(2), B<timer_create>(2), "
"B<timerfd_create>(2), B<time>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/fork.2:39
#, no-wrap
msgid "FORK"
msgstr ""

#. type: Plain text
#: man-pages/man2/fork.2:42
msgid "fork - create a child process"
msgstr ""

#. type: Plain text
#: man-pages/man2/fork.2:48
msgid "B<pid_t fork(void);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/fork.2:57
msgid ""
"B<fork>()  creates a new process by duplicating the calling process.  The "
"new process is referred to as the I<child> process.  The calling process is "
"referred to as the I<parent> process."
msgstr ""

#. type: Plain text
#: man-pages/man2/fork.2:67
msgid ""
"The child process and the parent process run in separate memory spaces.  At "
"the time of B<fork>()  both memory spaces have the same content.  Memory "
"writes, file mappings (B<mmap>(2)), and unmappings (B<munmap>(2))  performed "
"by one of the processes do not affect the other."
msgstr ""

#. type: Plain text
#: man-pages/man2/fork.2:70
msgid ""
"The child process is an exact duplicate of the parent process except for the "
"following points:"
msgstr ""

#. type: Plain text
#: man-pages/man2/fork.2:75
msgid ""
"The child has its own unique process ID, and this PID does not match the ID "
"of any existing process group (B<setpgid>(2))  or session."
msgstr ""

#. type: Plain text
#: man-pages/man2/fork.2:77
msgid "The child's parent process ID is the same as the parent's process ID."
msgstr ""

#. type: Plain text
#: man-pages/man2/fork.2:81
msgid ""
"The child does not inherit its parent's memory locks (B<mlock>(2), "
"B<mlockall>(2))."
msgstr ""

#. type: Plain text
#: man-pages/man2/fork.2:87
msgid ""
"Process resource utilizations (B<getrusage>(2))  and CPU time counters "
"(B<times>(2))  are reset to zero in the child."
msgstr ""

#. type: Plain text
#: man-pages/man2/fork.2:90
msgid "The child's set of pending signals is initially empty (B<sigpending>(2))."
msgstr ""

#. type: Plain text
#: man-pages/man2/fork.2:93
msgid ""
"The child does not inherit semaphore adjustments from its parent "
"(B<semop>(2))."
msgstr ""

#. type: Plain text
#: man-pages/man2/fork.2:101
msgid ""
"The child does not inherit process-associated record locks from its parent "
"(B<fcntl>(2)).  (On the other hand, it does inherit B<fcntl>(2)  open file "
"description locks and B<flock>(2)  locks from its parent.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/fork.2:106
msgid ""
"The child does not inherit timers from its parent (B<setitimer>(2), "
"B<alarm>(2), B<timer_create>(2))."
msgstr ""

#. type: Plain text
#: man-pages/man2/fork.2:113
msgid ""
"The child does not inherit outstanding asynchronous I/O operations from its "
"parent (B<aio_read>(3), B<aio_write>(3)), nor does it inherit any "
"asynchronous I/O contexts from its parent (see B<io_setup>(2))."
msgstr ""

#. type: Plain text
#: man-pages/man2/fork.2:118
msgid ""
"The process attributes in the preceding list are all specified in POSIX.1.  "
"The parent and child also differ with respect to the following "
"Linux-specific process attributes:"
msgstr ""

#. type: Plain text
#: man-pages/man2/fork.2:125
msgid ""
"The child does not inherit directory change notifications (dnotify)  from "
"its parent (see the description of B<F_NOTIFY> in B<fcntl>(2))."
msgstr ""

#. type: Plain text
#: man-pages/man2/fork.2:131
msgid ""
"The B<prctl>(2)  B<PR_SET_PDEATHSIG> setting is reset so that the child does "
"not receive a signal when its parent terminates."
msgstr ""

#. type: Plain text
#: man-pages/man2/fork.2:138
msgid ""
"The default timer slack value is set to the parent's current timer slack "
"value.  See the description of B<PR_SET_TIMERSLACK> in B<prctl>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/fork.2:144
msgid ""
"Memory mappings that have been marked with the B<madvise>(2)  "
"B<MADV_DONTFORK> flag are not inherited across a B<fork>()."
msgstr ""

#. type: Plain text
#: man-pages/man2/fork.2:153
msgid ""
"Memory in address ranges that have been marked with the B<madvise>(2)  "
"B<MADV_WIPEONFORK> flag is zeroed in the child after a B<fork>().  (The "
"B<MADV_WIPEONFORK> setting remains in place for those address ranges in the "
"child.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/fork.2:158
msgid "The termination signal of the child is always B<SIGCHLD> (see B<clone>(2))."
msgstr ""

#. type: Plain text
#: man-pages/man2/fork.2:164
msgid ""
"The port access permission bits set by B<ioperm>(2)  are not inherited by "
"the child; the child must turn on any bits that it requires using "
"B<ioperm>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/fork.2:166 man-pages/man2/execve.2:247
msgid "Note the following further points:"
msgstr ""

#. type: Plain text
#: man-pages/man2/fork.2:175
msgid ""
"The child process is created with a single thread\\(emthe one that called "
"B<fork>().  The entire virtual address space of the parent is replicated in "
"the child, including the states of mutexes, condition variables, and other "
"pthreads objects; the use of B<pthread_atfork>(3)  may be helpful for "
"dealing with problems that this can cause."
msgstr ""

#. type: Plain text
#: man-pages/man2/fork.2:183
msgid ""
"After a B<fork>()  in a multithreaded program, the child can safely call "
"only async-signal-safe functions (see B<signal-safety>(7))  until such time "
"as it calls B<execve>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/fork.2:197
msgid ""
"The child inherits copies of the parent's set of open file descriptors.  "
"Each file descriptor in the child refers to the same open file description "
"(see B<open>(2))  as the corresponding file descriptor in the parent.  This "
"means that the two file descriptors share open file status flags, file "
"offset, and signal-driven I/O attributes (see the description of B<F_SETOWN> "
"and B<F_SETSIG> in B<fcntl>(2))."
msgstr ""

#. type: Plain text
#: man-pages/man2/fork.2:206
msgid ""
"The child inherits copies of the parent's set of open message queue "
"descriptors (see B<mq_overview>(7)).  Each file descriptor in the child "
"refers to the same open message queue description as the corresponding file "
"descriptor in the parent.  This means that the two file descriptors share "
"the same flags (I<mq_flags>)."
msgstr ""

#. type: Plain text
#: man-pages/man2/fork.2:214
msgid ""
"The child inherits copies of the parent's set of open directory streams (see "
"B<opendir>(3)).  POSIX.1 says that the corresponding directory streams in "
"the parent and child I<may> share the directory stream positioning; on "
"Linux/glibc they do not."
msgstr ""

#. type: Plain text
#: man-pages/man2/fork.2:221
msgid ""
"On success, the PID of the child process is returned in the parent, and 0 is "
"returned in the child.  On failure, -1 is returned in the parent, no child "
"process is created, and I<errno> is set appropriately."
msgstr ""

#.  NOTE! The following should match the description in pthread_create(3)
#. type: Plain text
#: man-pages/man2/fork.2:227
msgid ""
"A system-imposed limit on the number of threads was encountered.  There are "
"a number of limits that may trigger this error:"
msgstr ""

#. type: Plain text
#: man-pages/man2/fork.2:235
msgid ""
"the B<RLIMIT_NPROC> soft resource limit (set via B<setrlimit>(2)), which "
"limits the number of processes and threads for a real user ID, was reached;"
msgstr ""

#. type: Plain text
#: man-pages/man2/fork.2:240
msgid ""
"the kernel's system-wide limit on the number of processes and threads, "
"I</proc/sys/kernel/threads-max>, was reached (see B<proc>(5));"
msgstr ""

#. type: Plain text
#: man-pages/man2/fork.2:246
msgid ""
"the maximum number of PIDs, I</proc/sys/kernel/pid_max>, was reached (see "
"B<proc>(5)); or"
msgstr ""

#. type: Plain text
#: man-pages/man2/fork.2:250
msgid ""
"the PID limit (I<pids.max>)  imposed by the cgroup \"process number\" (PIDs) "
"controller was reached."
msgstr ""

#. type: Plain text
#: man-pages/man2/fork.2:258
msgid ""
"The caller is operating under the B<SCHED_DEADLINE> scheduling policy and "
"does not have the reset-on-fork flag set.  See B<sched>(7)."
msgstr ""

#. type: Plain text
#: man-pages/man2/fork.2:262
msgid ""
"B<fork>()  failed to allocate the necessary kernel structures because memory "
"is tight."
msgstr ""

#. type: Plain text
#: man-pages/man2/fork.2:268
msgid ""
"An attempt was made to create a child process in a PID namespace whose "
"\"init\" process has terminated.  See B<pid_namespaces>(7)."
msgstr ""

#.  e.g., arm (optionally), blackfin, c6x, frv, h8300, microblaze, xtensa
#. type: Plain text
#: man-pages/man2/fork.2:274
msgid ""
"B<fork>()  is not supported on this platform (for example, hardware without "
"a Memory-Management Unit)."
msgstr ""

#. type: Plain text
#: man-pages/man2/fork.2:288
msgid ""
"Under Linux, B<fork>()  is implemented using copy-on-write pages, so the "
"only penalty that it incurs is the time and memory required to duplicate the "
"parent's page tables, and to create a unique task structure for the child."
msgstr ""

#.  nptl/sysdeps/unix/sysv/linux/fork.c
#.  and does some magic to ensure that getpid(2) returns the right value.
#. type: Plain text
#: man-pages/man2/fork.2:312
msgid ""
"Since version 2.3.3, rather than invoking the kernel's B<fork>()  system "
"call, the glibc B<fork>()  wrapper that is provided as part of the NPTL "
"threading implementation invokes B<clone>(2)  with flags that provide the "
"same effect as the traditional system call.  (A call to B<fork>()  is "
"equivalent to a call to B<clone>(2)  specifying I<flags> as just "
"B<SIGCHLD>.)  The glibc wrapper invokes any fork handlers that have been "
"established using B<pthread_atfork>(3)."
msgstr ""

#. type: Plain text
#: man-pages/man2/fork.2:317
msgid "See B<pipe>(2)  and B<wait>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/fork.2:328
msgid ""
"B<clone>(2), B<execve>(2), B<exit>(2), B<setrlimit>(2), B<unshare>(2), "
"B<vfork>(2), B<wait>(2), B<daemon>(3), B<pthread_atfork>(3), "
"B<capabilities>(7), B<credentials>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/getpeername.2:42
#, no-wrap
msgid "GETPEERNAME"
msgstr ""

#. type: Plain text
#: man-pages/man2/getpeername.2:45
msgid "getpeername - get name of connected peer socket"
msgstr ""

#. type: Plain text
#: man-pages/man2/getpeername.2:50
msgid ""
"B<int getpeername(int >I<sockfd>B<, struct sockaddr *>I<addr>B<, socklen_t "
"*>I<addrlen>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/getpeername.2:63
msgid ""
"B<getpeername>()  returns the address of the peer connected to the socket "
"I<sockfd>, in the buffer pointed to by I<addr>.  The I<addrlen> argument "
"should be initialized to indicate the amount of space pointed to by "
"I<addr>.  On return it contains the actual size of the name returned (in "
"bytes).  The name is truncated if the buffer provided is too small."
msgstr ""

#. type: Plain text
#: man-pages/man2/getpeername.2:96
msgid "The socket is not connected."
msgstr ""

#. type: Plain text
#: man-pages/man2/getpeername.2:105
msgid ""
"POSIX.1-2001, POSIX.1-2008, SVr4, 4.4BSD (B<getpeername>()  first appeared "
"in 4.2BSD)."
msgstr ""

#. type: Plain text
#: man-pages/man2/getpeername.2:137
msgid ""
"For stream sockets, once a B<connect>(2)  has been performed, either socket "
"can call B<getpeername>()  to obtain the address of the peer socket.  On the "
"other hand, datagram sockets are connectionless.  Calling B<connect>(2)  on "
"a datagram socket merely sets the peer address for outgoing datagrams sent "
"with B<write>(2)  or B<recv>(2).  The caller of B<connect>(2)  can use "
"B<getpeername>()  to obtain the peer address that it earlier set for the "
"socket.  However, the peer socket is unaware of this information, and "
"calling B<getpeername>()  on the peer socket will return no useful "
"information (unless a B<connect>(2)  call was also executed on the peer).  "
"Note also that the receiver of a datagram can obtain the address of the "
"sender when using B<recvfrom>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/getpeername.2:143
msgid ""
"B<accept>(2), B<bind>(2), B<getsockname>(2), B<ip>(7), B<socket>(7), "
"B<unix>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/create_module.2:10
#, no-wrap
msgid "CREATE_MODULE"
msgstr ""

#. type: Plain text
#: man-pages/man2/create_module.2:13
msgid "create_module - create a loadable module entry"
msgstr ""

#. type: Plain text
#: man-pages/man2/create_module.2:18
#, no-wrap
msgid "B<caddr_t create_module(const char *>I<name>B<, size_t >I<size>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/create_module.2:30
msgid ""
"B<create_module>()  attempts to create a loadable module entry and reserve "
"the kernel memory that will be needed to hold the module.  This system call "
"requires privilege."
msgstr ""

#. type: Plain text
#: man-pages/man2/create_module.2:35
msgid ""
"On success, returns the kernel address at which the module will reside.  On "
"error, -1 is returned and I<errno> is set appropriately."
msgstr ""

#. type: Plain text
#: man-pages/man2/create_module.2:39
msgid "A module by that name already exists."
msgstr ""

#. type: Plain text
#: man-pages/man2/create_module.2:43
msgid "I<name> is outside the program's accessible address space."
msgstr ""

#. type: Plain text
#: man-pages/man2/create_module.2:46
msgid "The requested size is too small even for the module header information."
msgstr ""

#. type: Plain text
#: man-pages/man2/create_module.2:50
msgid ""
"The kernel could not allocate a contiguous block of memory large enough for "
"the module."
msgstr ""

#. type: Plain text
#: man-pages/man2/create_module.2:55
msgid ""
"B<create_module>()  is not supported in this version of the kernel (e.g., "
"the kernel is version 2.6 or later)."
msgstr ""

#. type: Plain text
#: man-pages/man2/create_module.2:61
msgid ""
"The caller was not privileged (did not have the B<CAP_SYS_MODULE> "
"capability)."
msgstr ""

#. type: Plain text
#: man-pages/man2/create_module.2:68
msgid "B<create_module>()  is Linux-specific."
msgstr ""

#. type: Plain text
#: man-pages/man2/create_module.2:79
msgid "B<delete_module>(2), B<init_module>(2), B<query_module>(2)"
msgstr ""

#. type: TH
#: man-pages/man2/sendmmsg.2:28
#, no-wrap
msgid "SENDMMSG"
msgstr ""

#. type: Plain text
#: man-pages/man2/sendmmsg.2:31
msgid "sendmmsg - send multiple messages on a socket"
msgstr ""

#. type: Plain text
#: man-pages/man2/sendmmsg.2:39
#, no-wrap
msgid ""
"B<int sendmmsg(int >I<sockfd>B<, struct mmsghdr *>I<msgvec>B<, unsigned int "
">I<vlen>B<,>\n"
"B<             int >I<flags>B<);>\n"
msgstr ""

#.  See commit 228e548e602061b08ee8e8966f567c12aa079682
#. type: Plain text
#: man-pages/man2/sendmmsg.2:49
msgid ""
"The B<sendmmsg>()  system call is an extension of B<sendmsg>(2)  that allows "
"the caller to transmit multiple messages on a socket using a single system "
"call.  (This has performance benefits for some applications.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/sendmmsg.2:54
msgid ""
"The I<sockfd> argument is the file descriptor of the socket on which data is "
"to be transmitted."
msgstr ""

#. type: Plain text
#: man-pages/man2/sendmmsg.2:75
#, no-wrap
msgid ""
"struct mmsghdr {\n"
"    struct msghdr msg_hdr;  /* Message header */\n"
"    unsigned int  msg_len;  /* Number of bytes transmitted */\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/sendmmsg.2:91
msgid ""
"The I<msg_hdr> field is a I<msghdr> structure, as described in "
"B<sendmsg>(2).  The I<msg_len> field is used to return the number of bytes "
"sent from the message in I<msg_hdr> (i.e., the same as the return value from "
"a single B<sendmsg>(2)  call)."
msgstr ""

#. type: Plain text
#: man-pages/man2/sendmmsg.2:97
msgid ""
"The I<flags> argument contains flags ORed together.  The flags are the same "
"as for B<sendmsg>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/sendmmsg.2:107
msgid ""
"A blocking B<sendmmsg>()  call blocks until I<vlen> messages have been "
"sent.  A nonblocking call sends as many messages as possible (up to the "
"limit specified by I<vlen>)  and returns immediately."
msgstr ""

#. type: Plain text
#: man-pages/man2/sendmmsg.2:119
msgid ""
"On return from B<sendmmsg>(), the I<msg_len> fields of successive elements "
"of I<msgvec> are updated to contain the number of bytes transmitted from the "
"corresponding I<msg_hdr>.  The return value of the call indicates the number "
"of elements of I<msgvec> that have been updated."
msgstr ""

#. type: Plain text
#: man-pages/man2/sendmmsg.2:129
msgid ""
"On success, B<sendmmsg>()  returns the number of messages sent from "
"I<msgvec>; if this is less than I<vlen>, the caller can retry with a further "
"B<sendmmsg>()  call to send the remaining messages."
msgstr ""

#.  commit 728ffb86f10873aaf4abd26dde691ee40ae731fe
#.      ... only return an error if no datagrams could be sent.
#.      If less than the requested number of messages were sent, the application
#.      must retry starting at the first failed one and if the problem is
#.      persistent the error will be returned.
#
#.      This matches the behavior of other syscalls like read/write - it
#.      is not an error if less than the requested number of elements are sent.
#. type: Plain text
#: man-pages/man2/sendmmsg.2:146
msgid ""
"Errors are as for B<sendmsg>(2).  An error is returned only if no datagrams "
"could be sent.  See also BUGS."
msgstr ""

#. type: Plain text
#: man-pages/man2/sendmmsg.2:151
msgid ""
"The B<sendmmsg>()  system call was added in Linux 3.0.  Support in glibc was "
"added in version 2.14."
msgstr ""

#. type: Plain text
#: man-pages/man2/sendmmsg.2:154
msgid "B<sendmmsg>()  is Linux-specific."
msgstr ""

#.  commit 98382f419f32d2c12d021943b87dea555677144b
#.      net: Cap number of elements for sendmmsg
#
#.      To limit the amount of time we can spend in sendmmsg, cap the
#.      number of elements to UIO_MAXIOV (currently 1024).
#
#.      For error handling an application using sendmmsg needs to retry at
#.      the first unsent message, so capping is simpler and requires less
#.      application logic than returning EINVAL.
#. type: Plain text
#: man-pages/man2/sendmmsg.2:169
msgid "The value specified in I<vlen> is capped to B<UIO_MAXIOV> (1024)."
msgstr ""

#. type: Plain text
#: man-pages/man2/sendmmsg.2:177
msgid ""
"If an error occurs after at least one message has been sent, the call "
"succeeds, and returns the number of messages sent.  The error code is lost.  "
"The caller can retry the transmission, starting at the first failed message, "
"but there is no guarantee that, if an error is returned, it will be the same "
"as the one that was lost on the previous call."
msgstr ""

#. type: Plain text
#: man-pages/man2/sendmmsg.2:186
msgid ""
"The example below uses B<sendmmsg>()  to send I<onetwo> and I<three> in two "
"distinct UDP datagrams using one system call.  The contents of the first "
"datagram originates from a pair of buffers."
msgstr ""

#. type: Plain text
#: man-pages/man2/sendmmsg.2:195
#, no-wrap
msgid ""
"#define _GNU_SOURCE\n"
"#include E<lt>netinet/ip.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>sys/types.hE<gt>\n"
"#include E<lt>sys/socket.hE<gt>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/sendmmsg.2:204
#, no-wrap
msgid ""
"int\n"
"main(void)\n"
"{\n"
"    int sockfd;\n"
"    struct sockaddr_in addr;\n"
"    struct mmsghdr msg[2];\n"
"    struct iovec msg1[2], msg2;\n"
"    int retval;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/sendmmsg.2:218
#, no-wrap
msgid ""
"    addr.sin_family = AF_INET;\n"
"    addr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);\n"
"    addr.sin_port = htons(1234);\n"
"    if (connect(sockfd, (struct sockaddr *) &addr, sizeof(addr)) == -1) {\n"
"        perror(\"connect()\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/sendmmsg.2:224
#, no-wrap
msgid ""
"    memset(msg1, 0, sizeof(msg1));\n"
"    msg1[0].iov_base = \"one\";\n"
"    msg1[0].iov_len = 3;\n"
"    msg1[1].iov_base = \"two\";\n"
"    msg1[1].iov_len = 3;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/sendmmsg.2:228
#, no-wrap
msgid ""
"    memset(&msg2, 0, sizeof(msg2));\n"
"    msg2.iov_base = \"three\";\n"
"    msg2.iov_len = 5;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/sendmmsg.2:232
#, no-wrap
msgid ""
"    memset(msg, 0, sizeof(msg));\n"
"    msg[0].msg_hdr.msg_iov = msg1;\n"
"    msg[0].msg_hdr.msg_iovlen = 2;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/sendmmsg.2:235
#, no-wrap
msgid ""
"    msg[1].msg_hdr.msg_iov = &msg2;\n"
"    msg[1].msg_hdr.msg_iovlen = 1;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/sendmmsg.2:241
#, no-wrap
msgid ""
"    retval = sendmmsg(sockfd, msg, 2, 0);\n"
"    if (retval == -1)\n"
"        perror(\"sendmmsg()\");\n"
"    else\n"
"        printf(\"%d messages sent\\en\", retval);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/sendmmsg.2:244
#, no-wrap
msgid ""
"    exit(0);\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/sendmmsg.2:249
msgid "B<recvmmsg>(2), B<sendmsg>(2), B<socket>(2), B<socket>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/mprotect.2:33
#, no-wrap
msgid "MPROTECT"
msgstr ""

#. type: Plain text
#: man-pages/man2/mprotect.2:36
msgid "mprotect, pkey_mprotect - set protection on a region of memory"
msgstr ""

#. type: Plain text
#: man-pages/man2/mprotect.2:41
#, no-wrap
msgid "B<int mprotect(void *>I<addr>B<, size_t >I<len>B<, int >I<prot>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/mprotect.2:46
#, no-wrap
msgid ""
"B<int pkey_mprotect(void *>I<addr>B<, size_t >I<len>B<, int >I<prot>B<, int "
">I<pkey>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/mprotect.2:54
msgid ""
"B<mprotect>()  changes the access protections for the calling process's "
"memory pages containing any part of the address range in the interval "
"[I<addr>,\\ I<addr>+I<len>-1].  I<addr> must be aligned to a page boundary."
msgstr ""

#. type: Plain text
#: man-pages/man2/mprotect.2:59
msgid ""
"If the calling process tries to access memory in a manner that violates the "
"protections, then the kernel generates a B<SIGSEGV> signal for the process."
msgstr ""

#. type: Plain text
#: man-pages/man2/mprotect.2:64
msgid ""
"I<prot> is a combination of the following access flags: B<PROT_NONE> or a "
"bitwise-or of the other values in the following list:"
msgstr ""

#. type: TP
#: man-pages/man2/mprotect.2:64 man-pages/man2/mmap.2:118
#, no-wrap
msgid "B<PROT_NONE>"
msgstr ""

#. type: Plain text
#: man-pages/man2/mprotect.2:67
msgid "The memory cannot be accessed at all."
msgstr ""

#. type: TP
#: man-pages/man2/mprotect.2:67 man-pages/man2/mmap.2:112
#, no-wrap
msgid "B<PROT_READ>"
msgstr ""

#. type: Plain text
#: man-pages/man2/mprotect.2:70
msgid "The memory can be read."
msgstr ""

#. type: TP
#: man-pages/man2/mprotect.2:70 man-pages/man2/mmap.2:115
#, no-wrap
msgid "B<PROT_WRITE>"
msgstr ""

#. type: Plain text
#: man-pages/man2/mprotect.2:73
msgid "The memory can be modified."
msgstr ""

#. type: TP
#: man-pages/man2/mprotect.2:73 man-pages/man2/mmap.2:109
#, no-wrap
msgid "B<PROT_EXEC>"
msgstr ""

#. type: Plain text
#: man-pages/man2/mprotect.2:76
msgid "The memory can be executed."
msgstr ""

#. type: TP
#: man-pages/man2/mprotect.2:76
#, no-wrap
msgid "B<PROT_SEM> (since Linux 2.5.7)"
msgstr ""

#. type: Plain text
#: man-pages/man2/mprotect.2:85
msgid ""
"The memory can be used for atomic operations.  This flag was introduced as "
"part of the B<futex>(2)  implementation (in order to guarantee the ability "
"to perform atomic operations required by commands such as B<FUTEX_WAIT>), "
"but is not currently used in on any architecture."
msgstr ""

#. type: TP
#: man-pages/man2/mprotect.2:85
#, no-wrap
msgid "B<PROT_SAO> (since Linux 2.6.26)"
msgstr ""

#.  commit aba46c5027cb59d98052231b36efcbbde9c77a1d
#.  commit ef3d3246a0d06be622867d21af25f997aeeb105f
#. type: Plain text
#: man-pages/man2/mprotect.2:94
msgid ""
"The memory should have strong access ordering.  This feature is specific to "
"the PowerPC architecture (version 2.06 of the architecture specification "
"adds the SAO CPU feature, and it is available on POWER 7 or PowerPC A2, for "
"example)."
msgstr ""

#. type: Plain text
#: man-pages/man2/mprotect.2:98
msgid ""
"Additionally (since Linux 2.6.0), I<prot> can have one of the following "
"flags set:"
msgstr ""

#.  mm/mmap.c:
#. 	vm_flags |= calc_vm_prot_bits(prot, pkey) | calc_vm_flag_bits(flags) |
#. 			mm->def_flags | VM_MAYREAD | VM_MAYWRITE | VM_MAYEXEC;
#.  And calc_vm_flag_bits converts only GROWSDOWN/DENYWRITE/LOCKED.
#. type: TP
#: man-pages/man2/mprotect.2:98
#, no-wrap
msgid "B<PROT_GROWSUP>"
msgstr ""

#.  The VMA is one that was marked with VM_GROWSUP by the kernel
#.  when the stack was created. Note that (unlike VM_GROWSDOWN),
#.  there is no mmap() flag (analogous to MAP_GROWSDOWN) for
#.  creating a VMA that is marked VM_GROWSUP.
#. type: Plain text
#: man-pages/man2/mprotect.2:113
msgid ""
"Apply the protection mode up to the end of a mapping that grows upwards.  "
"(Such mappings are created for the stack area on architectures\\(emfor "
"example, HP-PARISC\\(emthat have an upwardly growing stack.)"
msgstr ""

#. type: TP
#: man-pages/man2/mprotect.2:113
#, no-wrap
msgid "B<PROT_GROWSDOWN>"
msgstr ""

#. type: Plain text
#: man-pages/man2/mprotect.2:120
msgid ""
"Apply the protection mode down to the beginning of a mapping that grows "
"downward (which should be a stack segment or a segment mapped with the "
"B<MAP_GROWSDOWN> flag set)."
msgstr ""

#. type: Plain text
#: man-pages/man2/mprotect.2:139
msgid ""
"Like B<mprotect>(), B<pkey_mprotect>()  changes the protection on the pages "
"specified by I<addr> and I<len>.  The I<pkey> argument specifies the "
"protection key (see B<pkeys>(7))  to assign to the memory.  The protection "
"key must be allocated with B<pkey_alloc>(2)  before it is passed to "
"B<pkey_mprotect>().  For an example of the use of this system call, see "
"B<pkeys>(7)."
msgstr ""

#. type: Plain text
#: man-pages/man2/mprotect.2:148
msgid ""
"On success, B<mprotect>()  and B<pkey_mprotect>()  return zero.  On error, "
"these system calls return -1, and I<errno> is set appropriately."
msgstr ""

#. type: Plain text
#: man-pages/man2/mprotect.2:158
msgid ""
"The memory cannot be given the specified access.  This can happen, for "
"example, if you B<mmap>(2)  a file to which you have read-only access, then "
"ask B<mprotect>()  to mark it B<PROT_WRITE>."
msgstr ""

#. type: Plain text
#: man-pages/man2/mprotect.2:162
msgid "I<addr> is not a valid pointer, or not a multiple of the system page size."
msgstr ""

#. type: Plain text
#: man-pages/man2/mprotect.2:167
msgid "(B<pkey_mprotect>())  I<pkey> has not been allocated with B<pkey_alloc>(2)"
msgstr ""

#. type: Plain text
#: man-pages/man2/mprotect.2:175
msgid "Both B<PROT_GROWSUP> and B<PROT_GROWSDOWN> were specified in I<prot>."
msgstr ""

#. type: Plain text
#: man-pages/man2/mprotect.2:179
msgid "Invalid flags specified in I<prot>."
msgstr ""

#. type: Plain text
#: man-pages/man2/mprotect.2:186
msgid ""
"(PowerPC architecture)  B<PROT_SAO> was specified in I<prot>, but SAO "
"hardware feature is not available."
msgstr ""

#. type: Plain text
#: man-pages/man2/mprotect.2:189
msgid "Internal kernel structures could not be allocated."
msgstr ""

#. type: Plain text
#: man-pages/man2/mprotect.2:199
msgid ""
"Addresses in the range [I<addr>, I<addr>+I<len>-1] are invalid for the "
"address space of the process, or specify one or more pages that are not "
"mapped.  (Before kernel 2.4.19, the error B<EFAULT> was incorrectly produced "
"for these cases.)"
msgstr ""

#.  I.e., the number of VMAs would exceed the 64 kB maximum
#. type: Plain text
#: man-pages/man2/mprotect.2:211
msgid ""
"Changing the protection of a memory region would result in the total number "
"of mappings with distinct attributes (e.g., read versus read/write "
"protection)  exceeding the allowed maximum.  (For example, making the "
"protection of a range B<PROT_READ> in the middle of a region currently "
"protected as B<PROT_READ|PROT_WRITE> would result in three mappings: two "
"read/write mappings at each end and a read-only mapping in the middle.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/mprotect.2:215
msgid ""
"B<pkey_mprotect>()  first appeared in Linux 4.9; library support was added "
"in glibc 2.27."
msgstr ""

#.  SVr4 defines an additional error
#.  code EAGAIN. The SVr4 error conditions don't map neatly onto Linux's.
#. type: Plain text
#: man-pages/man2/mprotect.2:225
msgid ""
"B<mprotect>(): POSIX.1-2001, POSIX.1-2008, SVr4.  POSIX says that the "
"behavior of B<mprotect>()  is unspecified if it is applied to a region of "
"memory that was not obtained via B<mmap>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/mprotect.2:228
msgid "B<pkey_mprotect>()  is a nonportable Linux extension."
msgstr ""

#. type: Plain text
#: man-pages/man2/mprotect.2:235
msgid ""
"On Linux, it is always permissible to call B<mprotect>()  on any address in "
"a process's address space (except for the kernel vsyscall area).  In "
"particular, it can be used to change existing code mappings to be writable."
msgstr ""

#. type: Plain text
#: man-pages/man2/mprotect.2:249
msgid ""
"Whether B<PROT_EXEC> has any effect different from B<PROT_READ> depends on "
"processor architecture, kernel version, and process state.  If "
"B<READ_IMPLIES_EXEC> is set in the process's personality flags (see "
"B<personality>(2)), specifying B<PROT_READ> will implicitly add "
"B<PROT_EXEC>."
msgstr ""

#. type: Plain text
#: man-pages/man2/mprotect.2:254
msgid ""
"On some hardware architectures (e.g., i386), B<PROT_WRITE> implies "
"B<PROT_READ>."
msgstr ""

#. type: Plain text
#: man-pages/man2/mprotect.2:263
msgid ""
"POSIX.1 says that an implementation may permit access other than that "
"specified in I<prot>, but at a minimum can allow write access only if "
"B<PROT_WRITE> has been set, and must not allow any access if B<PROT_NONE> "
"has been set."
msgstr ""

#. type: Plain text
#: man-pages/man2/mprotect.2:276
msgid ""
"Applications should be careful when mixing use of B<mprotect>()  and "
"B<pkey_mprotect>().  On x86, when B<mprotect>()  is used with I<prot> set to "
"B<PROT_EXEC> a pkey may be allocated and set on the memory implicitly by the "
"kernel, but only when the pkey was 0 previously."
msgstr ""

#. type: Plain text
#: man-pages/man2/mprotect.2:286
msgid ""
"On systems that do not support protection keys in hardware, "
"B<pkey_mprotect>()  may still be used, but I<pkey> must be set to -1.  When "
"called this way, the operation of B<pkey_mprotect>()  is equivalent to "
"B<mprotect>()."
msgstr ""

#. type: Plain text
#: man-pages/man2/mprotect.2:294
msgid ""
"The program below demonstrates the use of B<mprotect>().  The program "
"allocates four pages of memory, makes the third of these pages read-only, "
"and then executes a loop that walks upward through the allocated region "
"modifying bytes."
msgstr ""

#. type: Plain text
#: man-pages/man2/mprotect.2:297
msgid "An example of what we might see when running the program is the following:"
msgstr ""

#. type: Plain text
#: man-pages/man2/mprotect.2:303
#, no-wrap
msgid ""
"$B< ./a.out>\n"
"Start of region:        0x804c000\n"
"Got SIGSEGV at address: 0x804e000\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/mprotect.2:315
#, no-wrap
msgid ""
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>signal.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>malloc.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"
"#include E<lt>sys/mman.hE<gt>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/mprotect.2:320
#, no-wrap
msgid "static char *buffer;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/mprotect.2:329
#, no-wrap
msgid ""
"static void\n"
"handler(int sig, siginfo_t *si, void *unused)\n"
"{\n"
"    /* Note: calling printf() from a signal handler is not safe\n"
"       (and should not be done in production programs), since\n"
"       printf() is not async-signal-safe; see signal-safety(7).\n"
"       Nevertheless, we use printf() here as a simple way of\n"
"       showing that the handler was called. */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/mprotect.2:334
#, no-wrap
msgid ""
"    printf(\"Got SIGSEGV at address: 0x%lx\\en\",\n"
"            (long) si-E<gt>si_addr);\n"
"    exit(EXIT_FAILURE);\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/mprotect.2:341
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    char *p;\n"
"    int pagesize;\n"
"    struct sigaction sa;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/mprotect.2:347
#, no-wrap
msgid ""
"    sa.sa_flags = SA_SIGINFO;\n"
"    sigemptyset(&sa.sa_mask);\n"
"    sa.sa_sigaction = handler;\n"
"    if (sigaction(SIGSEGV, &sa, NULL) == -1)\n"
"        handle_error(\"sigaction\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/mprotect.2:351
#, no-wrap
msgid ""
"    pagesize = sysconf(_SC_PAGE_SIZE);\n"
"    if (pagesize == -1)\n"
"        handle_error(\"sysconf\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/mprotect.2:354
#, no-wrap
msgid ""
"    /* Allocate a buffer aligned on a page boundary;\n"
"       initial protection is PROT_READ | PROT_WRITE */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/mprotect.2:358
#, no-wrap
msgid ""
"    buffer = memalign(pagesize, 4 * pagesize);\n"
"    if (buffer == NULL)\n"
"        handle_error(\"memalign\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/mprotect.2:360
#, no-wrap
msgid "    printf(\"Start of region:        0x%lx\\en\", (long) buffer);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/mprotect.2:364
#, no-wrap
msgid ""
"    if (mprotect(buffer + pagesize * 2, pagesize,\n"
"                PROT_READ) == -1)\n"
"        handle_error(\"mprotect\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/mprotect.2:367
#, no-wrap
msgid ""
"    for (p = buffer ; ; )\n"
"        *(p++) = \\(aqa\\(aq;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/mprotect.2:371
#, no-wrap
msgid ""
"    printf(\"Loop completed\\en\");     /* Should never happen */\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/mprotect.2:375
msgid "B<mmap>(2), B<sysconf>(3), B<pkeys>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/_exit.2:29
#, no-wrap
msgid "_EXIT"
msgstr ""

#. type: Plain text
#: man-pages/man2/_exit.2:32
msgid "_exit, _Exit - terminate the calling process"
msgstr ""

#. type: Plain text
#: man-pages/man2/_exit.2:36
msgid "B<void _exit(int >I<status>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/_exit.2:38
msgid "B<#include E<lt>stdlib.hE<gt>>"
msgstr ""

#. type: Plain text
#: man-pages/man2/_exit.2:40
msgid "B<void _Exit(int >I<status>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/_exit.2:48
msgid "B<_Exit>():"
msgstr ""

#. type: Plain text
#: man-pages/man2/_exit.2:50
msgid "_ISOC99_SOURCE || _POSIX_C_SOURCE\\ E<gt>=\\ 200112L"
msgstr ""

#. type: Plain text
#: man-pages/man2/_exit.2:66
msgid ""
"The function B<_exit>()  terminates the calling process \"immediately\".  "
"Any open file descriptors belonging to the process are closed.  Any children "
"of the process are inherited by B<init>(1)  (or by the nearest \"subreaper\" "
"process as defined through the use of the B<prctl>(2)  "
"B<PR_SET_CHILD_SUBREAPER> operation).  The process's parent is sent a "
"B<SIGCHLD> signal."
msgstr ""

#. type: Plain text
#: man-pages/man2/_exit.2:73
msgid ""
"The value I<status & 0377> is returned to the parent process as the "
"process's exit status, and can be collected using one of the B<wait>(2)  "
"family of calls."
msgstr ""

#. type: Plain text
#: man-pages/man2/_exit.2:78
msgid "The function B<_Exit>()  is equivalent to B<_exit>()."
msgstr ""

#. type: Plain text
#: man-pages/man2/_exit.2:80
msgid "These functions do not return."
msgstr ""

#. type: Plain text
#: man-pages/man2/_exit.2:85
msgid ""
"POSIX.1-2001, POSIX.1-2008, SVr4, 4.3BSD.  The function B<_Exit>()  was "
"introduced by C99."
msgstr ""

#. type: Plain text
#: man-pages/man2/_exit.2:89
msgid ""
"For a discussion on the effects of an exit, the transmission of exit status, "
"zombie processes, signals sent, and so on, see B<exit>(3)."
msgstr ""

#. type: Plain text
#: man-pages/man2/_exit.2:115
msgid ""
"The function B<_exit>()  is like B<exit>(3), but does not call any functions "
"registered with B<atexit>(3)  or B<on_exit>(3).  Open B<stdio>(3)  streams "
"are not flushed.  On the other hand, B<_exit>()  does close open file "
"descriptors, and this may cause an unknown delay, waiting for pending output "
"to finish.  If the delay is undesired, it may be useful to call functions "
"like B<tcflush>(3)  before calling B<_exit>().  Whether any pending I/O is "
"canceled, and which pending I/O may be canceled upon B<_exit>(), is "
"implementation-dependent."
msgstr ""

#. type: Plain text
#: man-pages/man2/_exit.2:122
msgid ""
"In glibc up to version 2.3, the B<_exit>()  wrapper function invoked the "
"kernel system call of the same name.  Since glibc 2.3, the wrapper function "
"invokes B<exit_group>(2), in order to terminate all of the threads in a "
"process."
msgstr ""

#. type: Plain text
#: man-pages/man2/_exit.2:133
msgid ""
"B<execve>(2), B<exit_group>(2), B<fork>(2), B<kill>(2), B<wait>(2), "
"B<wait4>(2), B<waitpid>(2), B<atexit>(3), B<exit>(3), B<on_exit>(3), "
"B<termios>(3)"
msgstr ""

#. type: TH
#: man-pages/man2/add_key.2:12
#, no-wrap
msgid "ADD_KEY"
msgstr ""

#. type: Plain text
#: man-pages/man2/add_key.2:15
msgid "add_key - add a key to the kernel's key management facility"
msgstr ""

#. type: Plain text
#: man-pages/man2/add_key.2:23
#, no-wrap
msgid ""
"B<key_serial_t add_key(const char *>I<type>B<, const char "
"*>I<description>B<,>\n"
"B<                     const void *>I<payload>B<, size_t >I<plen>B<,>\n"
"B<                     key_serial_t >I<keyring>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/add_key.2:39
msgid ""
"B<add_key>()  creates or updates a key of the given I<type> and "
"I<description>, instantiates it with the I<payload> of length I<plen>, "
"attaches it to the nominated I<keyring>, and returns the key's serial "
"number."
msgstr ""

#. type: Plain text
#: man-pages/man2/add_key.2:42
msgid ""
"The key may be rejected if the provided data is in the wrong format or it is "
"invalid in some other way."
msgstr ""

#.  FIXME The aforementioned phrases begs the question:
#.  which key types support this?
#.  FIXME Perhaps elaborate the implications here? Namely, the new
#.  key will have a new ID, and if the old key was a keyring that
#.  is consequently unlinked, then keys that it was anchoring
#.  will have their reference count decreased by one (and may
#.  consequently be garbage collected). Is this all correct?
#. type: Plain text
#: man-pages/man2/add_key.2:60
msgid ""
"If the destination I<keyring> already contains a key that matches the "
"specified I<type> and I<description>, then, if the key type supports it, "
"that key will be updated rather than a new key being created; if not, a new "
"key (with a different ID) will be created and it will displace the link to "
"the extant key from the keyring."
msgstr ""

#.  FIXME . Perhaps have a separate page describing special keyring IDs?
#. type: Plain text
#: man-pages/man2/add_key.2:68
msgid ""
"The destination I<keyring> serial number may be that of a valid keyring for "
"which the caller has I<write> permission.  Alternatively, it may be one of "
"the following special keyring IDs:"
msgstr ""

#. type: Plain text
#: man-pages/man2/add_key.2:72
msgid "This specifies the caller's thread-specific keyring (B<thread-keyring>(7))."
msgstr ""

#. type: Plain text
#: man-pages/man2/add_key.2:76
msgid ""
"This specifies the caller's process-specific keyring "
"(B<process-keyring>(7))."
msgstr ""

#. type: Plain text
#: man-pages/man2/add_key.2:80
msgid ""
"This specifies the caller's session-specific keyring "
"(B<session-keyring>(7))."
msgstr ""

#. type: Plain text
#: man-pages/man2/add_key.2:84
msgid "This specifies the caller's UID-specific keyring (B<user-keyring>(7))."
msgstr ""

#. type: Plain text
#: man-pages/man2/add_key.2:88
msgid ""
"This specifies the caller's UID-session keyring "
"(B<user-session-keyring>(7))."
msgstr ""

#. type: SS
#: man-pages/man2/add_key.2:88
#, no-wrap
msgid "Key types"
msgstr ""

#. type: Plain text
#: man-pages/man2/add_key.2:100
msgid ""
"The key I<type> is a string that specifies the key's type.  Internally, the "
"kernel defines a number of key types that are available in the core key "
"management code.  Among the types that are available for user-space use and "
"can be specified as the I<type> argument to B<add_key>()  are the following:"
msgstr ""

#. type: TP
#: man-pages/man2/add_key.2:100
#, no-wrap
msgid "I<\"keyring\">"
msgstr ""

#. type: Plain text
#: man-pages/man2/add_key.2:109
msgid ""
"Keyrings are special key types that may contain links to sequences of other "
"keys of any type.  If this interface is used to create a keyring, then "
"I<payload> should be NULL and I<plen> should be zero."
msgstr ""

#. type: TP
#: man-pages/man2/add_key.2:109
#, no-wrap
msgid "I<\"user\">"
msgstr ""

#. type: Plain text
#: man-pages/man2/add_key.2:116
msgid ""
"This is a general purpose key type whose payload may be read and updated by "
"user-space applications.  The key is kept entirely within kernel memory.  "
"The payload for keys of this type is a blob of arbitrary data of up to "
"32,767 bytes."
msgstr ""

#. type: TP
#: man-pages/man2/add_key.2:116
#, no-wrap
msgid "I<\"logon\"> (since Linux 3.3)"
msgstr ""

#.  commit 9f6ed2ca257fa8650b876377833e6f14e272848b
#. type: Plain text
#: man-pages/man2/add_key.2:124
msgid ""
"This key type is essentially the same as I<\"user\">, but it does not permit "
"the key to read.  This is suitable for storing payloads that you do not want "
"to be readable from user space."
msgstr ""

#. type: Plain text
#: man-pages/man2/add_key.2:131
msgid ""
"This key type vets the I<description> to ensure that it is qualified by a "
"\"service\" prefix, by checking to ensure that the I<description> contains a "
"':' that is preceded by other characters."
msgstr ""

#. type: TP
#: man-pages/man2/add_key.2:131
#, no-wrap
msgid "I<\"big_key\"> (since Linux 3.13)"
msgstr ""

#.  commit ab3c3587f8cda9083209a61dbe3a4407d3cada10
#. type: Plain text
#: man-pages/man2/add_key.2:140
msgid ""
"This key type is similar to I<\"user\">, but may hold a payload of up to 1\\ "
"MiB.  If the key payload is large enough, then it may be stored encrypted in "
"tmpfs (which can be swapped out) rather than kernel memory."
msgstr ""

#. type: Plain text
#: man-pages/man2/add_key.2:143
msgid "For further details on these key types, see B<keyrings>(7)."
msgstr ""

#. type: Plain text
#: man-pages/man2/add_key.2:150
msgid ""
"On success, B<add_key>()  returns the serial number of the key it created or "
"updated.  On error, -1 is returned and I<errno> is set to indicate the cause "
"of the error."
msgstr ""

#. type: Plain text
#: man-pages/man2/add_key.2:166
msgid ""
"One or more of I<type>, I<description>, and I<payload> points outside "
"process's accessible address space."
msgstr ""

#. type: Plain text
#: man-pages/man2/add_key.2:176
msgid "The payload data was invalid."
msgstr ""

#. type: Plain text
#: man-pages/man2/add_key.2:185
msgid ""
"I<type> was I<\"logon\"> and the I<description> was not qualified with a "
"prefix string of the form I<\"service:\">."
msgstr ""

#. type: Plain text
#: man-pages/man2/add_key.2:188
msgid "The keyring has expired."
msgstr ""

#. type: Plain text
#: man-pages/man2/add_key.2:191
msgid "The keyring has been revoked."
msgstr ""

#. type: Plain text
#: man-pages/man2/add_key.2:194
msgid "The keyring doesn't exist."
msgstr ""

#. type: Plain text
#: man-pages/man2/add_key.2:203
msgid ""
"The I<type> started with a period (\\(aq.\\(aq).  Key types that begin with "
"a period are reserved to the implementation."
msgstr ""

#. type: Plain text
#: man-pages/man2/add_key.2:213
msgid ""
"I<type> was I<\"keyring\"> and the I<description> started with a period "
"(\\(aq.\\(aq).  Keyrings with descriptions (names)  that begin with a period "
"are reserved to the implementation."
msgstr ""

#. type: Plain text
#: man-pages/man2/add_key.2:229
msgid ""
"The program below creates a key with the type, description, and payload "
"specified in its command-line arguments, and links that key into the session "
"keyring.  The following shell session demonstrates the use of the program:"
msgstr ""

#. type: Plain text
#: man-pages/man2/add_key.2:236
#, no-wrap
msgid ""
"$ B<./a.out user mykey \"Some payload\">\n"
"Key ID is 64a4dca\n"
"$ B<grep \\(aq64a4dca\\(aq /proc/keys>\n"
"064a4dca I--Q---    1 perm 3f010000  1000  1000 user    mykey: 12\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/add_key.2:257
#, no-wrap
msgid ""
"    if (argc != 4) {\n"
"        fprintf(stderr, \"Usage: %s type description payload\\en\",\n"
"                argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/add_key.2:264
#, no-wrap
msgid ""
"    key = add_key(argv[1], argv[2], argv[3], strlen(argv[3]),\n"
"                KEY_SPEC_SESSION_KEYRING);\n"
"    if (key == -1) {\n"
"        perror(\"add_key\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/add_key.2:285
msgid ""
"B<keyctl>(1), B<keyctl>(2), B<request_key>(2), B<keyctl>(3), B<keyrings>(7), "
"B<keyutils>(7), B<persistent-keyring>(7), B<process-keyring>(7), "
"B<session-keyring>(7), B<thread-keyring>(7), B<user-keyring>(7), "
"B<user-session-keyring>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/restart_syscall.2:33
#, no-wrap
msgid "RESTART_SYSCALL"
msgstr ""

#. type: Plain text
#: man-pages/man2/restart_syscall.2:36
msgid "restart_syscall - restart a system call after interruption by a stop signal"
msgstr ""

#. type: Plain text
#: man-pages/man2/restart_syscall.2:38
msgid "B<int restart_syscall(void);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/restart_syscall.2:53
msgid ""
"The B<restart_syscall>()  system call is used to restart certain system "
"calls after a process that was stopped by a signal (e.g., B<SIGSTOP> or "
"B<SIGTSTP>)  is later resumed after receiving a B<SIGCONT> signal.  This "
"system call is designed only for internal use by the kernel."
msgstr ""

#.  These system calls correspond to the special internal errno value
#.  ERESTART_RESTARTBLOCK. Each of the system calls has a "restart"
#.  helper function that is invoked by restart_syscall().
#.  Notable (as at Linux 3.17) is that poll() has such a "restart"
#.  function, but ppoll(), select(), and pselect() do not.
#.  This means that the latter system calls do not take account of the
#.  time spent in the stopped state when restarting.
#. type: Plain text
#: man-pages/man2/restart_syscall.2:88
msgid ""
"B<restart_syscall>()  is used for restarting only those system calls that, "
"when restarted, should adjust their time-related parameters\\(emnamely "
"B<poll>(2)  (since Linux 2.6.24), B<nanosleep>(2)  (since Linux 2.6), "
"B<clock_nanosleep>(2)  (since Linux 2.6), and B<futex>(2), when employed "
"with the B<FUTEX_WAIT> (since Linux 2.6.22)  and B<FUTEX_WAIT_BITSET> (since "
"Linux 2.6.31)  operations.  B<restart_syscall>()  restarts the interrupted "
"system call with a time argument that is suitably adjusted to account for "
"the time that has already elapsed (including the time where the process was "
"stopped by a signal).  Without the B<restart_syscall>()  mechanism, "
"restarting these system calls would not correctly deduct the already elapsed "
"time when the process continued execution."
msgstr ""

#. type: Plain text
#: man-pages/man2/restart_syscall.2:92
msgid ""
"The return value of B<restart_syscall>()  is the return value of whatever "
"system call is being restarted."
msgstr ""

#. type: Plain text
#: man-pages/man2/restart_syscall.2:96
msgid ""
"I<errno> is set as per the errors for whatever system call is being "
"restarted by B<restart_syscall>()."
msgstr ""

#. type: Plain text
#: man-pages/man2/restart_syscall.2:100
msgid "The B<restart_syscall>()  system call is present since Linux 2.6."
msgstr ""

#. type: Plain text
#: man-pages/man2/restart_syscall.2:106
msgid ""
"There is no glibc wrapper for this system call, because it is intended for "
"use only by the kernel and should never be called by applications."
msgstr ""

#. type: Plain text
#: man-pages/man2/restart_syscall.2:128
msgid ""
"The kernel uses B<restart_syscall>()  to ensure that when a system call is "
"restarted after a process has been stopped by a signal and then resumed by "
"B<SIGCONT>, then the time that the process spent in the stopped state is "
"counted against the timeout interval specified in the original system call.  "
"In the case of system calls that take a timeout argument and automatically "
"restart after a stop signal plus B<SIGCONT>, but which do not have the "
"B<restart_syscall>()  mechanism built in, then, after the process resumes "
"execution, the time that the process spent in the stop state is I<not> "
"counted against the timeout value.  Notable examples of system calls that "
"suffer this problem are B<ppoll>(2), B<select>(2), and B<pselect>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/restart_syscall.2:135
msgid ""
"From user space, the operation of B<restart_syscall>()  is largely "
"invisible: to the process that made the system call that is restarted, it "
"appears as though that system call executed and returned in the usual "
"fashion."
msgstr ""

#. type: Plain text
#: man-pages/man2/restart_syscall.2:138
msgid "B<sigaction>(2), B<sigreturn>(2), B<signal>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/eventfd.2:22
#, no-wrap
msgid "EVENTFD"
msgstr ""

#. type: Plain text
#: man-pages/man2/eventfd.2:25
msgid "eventfd - create a file descriptor for event notification"
msgstr ""

#. type: Plain text
#: man-pages/man2/eventfd.2:27
msgid "B<#include E<lt>sys/eventfd.hE<gt>>"
msgstr ""

#. type: Plain text
#: man-pages/man2/eventfd.2:29
msgid "B<int eventfd(unsigned int >I<initval>B<, int >I<flags>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/eventfd.2:39
msgid ""
"B<eventfd>()  creates an \"eventfd object\" that can be used as an event "
"wait/notify mechanism by user-space applications, and by the kernel to "
"notify user-space applications of events.  The object contains an unsigned "
"64-bit integer (I<uint64_t>)  counter that is maintained by the kernel.  "
"This counter is initialized with the value specified in the argument "
"I<initval>."
msgstr ""

#. type: Plain text
#: man-pages/man2/eventfd.2:44
msgid ""
"As its return value, B<eventfd>()  returns a new file descriptor that can be "
"used to refer to the eventfd object."
msgstr ""

#. type: Plain text
#: man-pages/man2/eventfd.2:49
msgid ""
"The following values may be bitwise ORed in I<flags> to change the behavior "
"of B<eventfd>():"
msgstr ""

#. type: TP
#: man-pages/man2/eventfd.2:49
#, no-wrap
msgid "B<EFD_CLOEXEC> (since Linux 2.6.27)"
msgstr ""

#. type: TP
#: man-pages/man2/eventfd.2:59
#, no-wrap
msgid "B<EFD_NONBLOCK> (since Linux 2.6.27)"
msgstr ""

#. type: TP
#: man-pages/man2/eventfd.2:69
#, no-wrap
msgid "B<EFD_SEMAPHORE> (since Linux 2.6.30)"
msgstr ""

#. type: Plain text
#: man-pages/man2/eventfd.2:73
msgid ""
"Provide semaphore-like semantics for reads from the new file descriptor.  "
"See below."
msgstr ""

#. type: Plain text
#: man-pages/man2/eventfd.2:80
msgid ""
"The following operations can be performed on the file descriptor returned by "
"B<eventfd>():"
msgstr ""

#. type: Plain text
#: man-pages/man2/eventfd.2:90
msgid ""
"Each successful B<read>(2)  returns an 8-byte integer.  A B<read>(2)  fails "
"with the error B<EINVAL> if the size of the supplied buffer is less than 8 "
"bytes."
msgstr ""

#. type: Plain text
#: man-pages/man2/eventfd.2:95
msgid ""
"The value returned by B<read>(2)  is in host byte order\\(emthat is, the "
"native byte order for integers on the host machine."
msgstr ""

#. type: Plain text
#: man-pages/man2/eventfd.2:102
msgid ""
"The semantics of B<read>(2)  depend on whether the eventfd counter currently "
"has a nonzero value and whether the B<EFD_SEMAPHORE> flag was specified when "
"creating the eventfd file descriptor:"
msgstr ""

#. type: Plain text
#: man-pages/man2/eventfd.2:110
msgid ""
"If B<EFD_SEMAPHORE> was not specified and the eventfd counter has a nonzero "
"value, then a B<read>(2)  returns 8 bytes containing that value, and the "
"counter's value is reset to zero."
msgstr ""

#. type: Plain text
#: man-pages/man2/eventfd.2:117
msgid ""
"If B<EFD_SEMAPHORE> was specified and the eventfd counter has a nonzero "
"value, then a B<read>(2)  returns 8 bytes containing the value 1, and the "
"counter's value is decremented by 1."
msgstr ""

#. type: Plain text
#: man-pages/man2/eventfd.2:127
msgid ""
"If the eventfd counter is zero at the time of the call to B<read>(2), then "
"the call either blocks until the counter becomes nonzero (at which time, the "
"B<read>(2)  proceeds as described above)  or fails with the error B<EAGAIN> "
"if the file descriptor has been made nonblocking."
msgstr ""

#. type: Plain text
#: man-pages/man2/eventfd.2:145
msgid ""
"A B<write>(2)  call adds the 8-byte integer value supplied in its buffer to "
"the counter.  The maximum value that may be stored in the counter is the "
"largest unsigned 64-bit value minus 1 (i.e., 0xfffffffffffffffe).  If the "
"addition would cause the counter's value to exceed the maximum, then the "
"B<write>(2)  either blocks until a B<read>(2)  is performed on the file "
"descriptor, or fails with the error B<EAGAIN> if the file descriptor has "
"been made nonblocking."
msgstr ""

#. type: Plain text
#: man-pages/man2/eventfd.2:152
msgid ""
"A B<write>(2)  fails with the error B<EINVAL> if the size of the supplied "
"buffer is less than 8 bytes, or if an attempt is made to write the value "
"0xffffffffffffffff."
msgstr ""

#. type: Plain text
#: man-pages/man2/eventfd.2:161
msgid ""
"The returned file descriptor supports B<poll>(2)  (and analogously "
"B<epoll>(7))  and B<select>(2), as follows:"
msgstr ""

#. type: Plain text
#: man-pages/man2/eventfd.2:172
msgid ""
"The file descriptor is readable (the B<select>(2)  I<readfds> argument; the "
"B<poll>(2)  B<POLLIN> flag)  if the counter has a value greater than 0."
msgstr ""

#. type: Plain text
#: man-pages/man2/eventfd.2:182
msgid ""
"The file descriptor is writable (the B<select>(2)  I<writefds> argument; the "
"B<poll>(2)  B<POLLOUT> flag)  if it is possible to write a value of at least "
"\"1\" without blocking."
msgstr ""

#. type: Plain text
#: man-pages/man2/eventfd.2:202
msgid ""
"If an overflow of the counter value was detected, then B<select>(2)  "
"indicates the file descriptor as being both readable and writable, and "
"B<poll>(2)  returns a B<POLLERR> event.  As noted above, B<write>(2)  can "
"never overflow the counter.  However an overflow can occur if 2^64 eventfd "
"\"signal posts\" were performed by the KAIO subsystem (theoretically "
"possible, but practically unlikely).  If an overflow has occurred, then "
"B<read>(2)  will return that maximum I<uint64_t> value (i.e., "
"0xffffffffffffffff)."
msgstr ""

#. type: Plain text
#: man-pages/man2/eventfd.2:209
msgid ""
"The eventfd file descriptor also supports the other file-descriptor "
"multiplexing APIs: B<pselect>(2)  and B<ppoll>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/eventfd.2:214
msgid ""
"When the file descriptor is no longer required it should be closed.  When "
"all file descriptors associated with the same eventfd object have been "
"closed, the resources for object are freed by the kernel."
msgstr ""

#. type: Plain text
#: man-pages/man2/eventfd.2:226
msgid ""
"A copy of the file descriptor created by B<eventfd>()  is inherited by the "
"child produced by B<fork>(2).  The duplicate file descriptor is associated "
"with the same eventfd object.  File descriptors created by B<eventfd>()  are "
"preserved across B<execve>(2), unless the close-on-exec flag has been set."
msgstr ""

#. type: Plain text
#: man-pages/man2/eventfd.2:233
msgid ""
"On success, B<eventfd>()  returns a new eventfd file descriptor.  On error, "
"-1 is returned and I<errno> is set to indicate the error."
msgstr ""

#. type: Plain text
#: man-pages/man2/eventfd.2:238 man-pages/man2/userfaultfd.2:432
msgid "An unsupported value was specified in I<flags>."
msgstr ""

#. type: Plain text
#: man-pages/man2/eventfd.2:257
msgid "There was insufficient memory to create a new eventfd file descriptor."
msgstr ""

#.  eventfd() is in glibc 2.7, but reportedly does not build
#. type: Plain text
#: man-pages/man2/eventfd.2:270
msgid ""
"B<eventfd>()  is available on Linux since kernel 2.6.22.  Working support is "
"provided in glibc since version 2.8.  The B<eventfd2>()  system call (see "
"NOTES) is available on Linux since kernel 2.6.27.  Since version 2.9, the "
"glibc B<eventfd>()  wrapper will employ the B<eventfd2>()  system call, if "
"it is supported by the kernel."
msgstr ""

#. type: tbl table
#: man-pages/man2/eventfd.2:280
#, no-wrap
msgid "B<eventfd>()"
msgstr ""

#. type: Plain text
#: man-pages/man2/eventfd.2:288
msgid "B<eventfd>()  and B<eventfd2>()  are Linux-specific."
msgstr ""

#. type: Plain text
#: man-pages/man2/eventfd.2:296
msgid ""
"Applications can use an eventfd file descriptor instead of a pipe (see "
"B<pipe>(2))  in all cases where a pipe is used simply to signal events.  The "
"kernel overhead of an eventfd file descriptor is much lower than that of a "
"pipe, and only one file descriptor is required (versus the two required for "
"a pipe)."
msgstr ""

#.  or eventually syslets/threadlets
#. type: Plain text
#: man-pages/man2/eventfd.2:302
msgid ""
"When used in the kernel, an eventfd file descriptor can provide a bridge "
"from kernel to user space, allowing, for example, functionalities like KAIO "
"(kernel AIO)  to signal to a file descriptor that some operation is "
"complete."
msgstr ""

#. type: Plain text
#: man-pages/man2/eventfd.2:319
msgid ""
"A key point about an eventfd file descriptor is that it can be monitored "
"just like any other file descriptor using B<select>(2), B<poll>(2), or "
"B<epoll>(7).  This means that an application can simultaneously monitor the "
"readiness of \"traditional\" files and the readiness of other kernel "
"mechanisms that support the eventfd interface.  (Without the B<eventfd>()  "
"interface, these mechanisms could not be multiplexed via B<select>(2), "
"B<poll>(2), or B<epoll>(7).)"
msgstr ""

#. type: Plain text
#: man-pages/man2/eventfd.2:328
msgid ""
"The current value of an eventfd counter can be viewed via the entry for the "
"corresponding file descriptor in the process's I</proc/[pid]/fdinfo> "
"directory.  See B<proc>(5)  for further details."
msgstr ""

#. type: Plain text
#: man-pages/man2/eventfd.2:342
msgid ""
"There are two underlying Linux system calls: B<eventfd>()  and the more "
"recent B<eventfd2>().  The former system call does not implement a I<flags> "
"argument.  The latter system call implements the I<flags> values described "
"above.  The glibc wrapper function will use B<eventfd2>()  where it is "
"available."
msgstr ""

#. type: SS
#: man-pages/man2/eventfd.2:342
#, no-wrap
msgid "Additional glibc features"
msgstr ""

#. type: Plain text
#: man-pages/man2/eventfd.2:346
msgid ""
"The GNU C library defines an additional type, and two functions that attempt "
"to abstract some of the details of reading and writing on an eventfd file "
"descriptor:"
msgstr ""

#. type: Plain text
#: man-pages/man2/eventfd.2:350
#, no-wrap
msgid "typedef uint64_t eventfd_t;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/eventfd.2:353
#, no-wrap
msgid ""
"int eventfd_read(int fd, eventfd_t *value);\n"
"int eventfd_write(int fd, eventfd_t value);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/eventfd.2:360
msgid ""
"The functions perform the read and write operations on an eventfd file "
"descriptor, returning 0 if the correct number of bytes was transferred, or "
"-1 otherwise."
msgstr ""

#. type: Plain text
#: man-pages/man2/eventfd.2:369
msgid ""
"The following program creates an eventfd file descriptor and then forks to "
"create a child process.  While the parent briefly sleeps, the child writes "
"each of the integers supplied in the program's command-line arguments to the "
"eventfd file descriptor.  When the parent has finished sleeping, it reads "
"from the eventfd file descriptor."
msgstr ""

#. type: Plain text
#: man-pages/man2/eventfd.2:383
#, no-wrap
msgid ""
"$B< ./a.out 1 2 4 7 14>\n"
"Child writing 1 to efd\n"
"Child writing 2 to efd\n"
"Child writing 4 to efd\n"
"Child writing 7 to efd\n"
"Child writing 14 to efd\n"
"Child completed write loop\n"
"Parent about to read\n"
"Parent read 28 (0x1c) from efd\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/eventfd.2:393
#, no-wrap
msgid ""
"#include E<lt>sys/eventfd.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdint.hE<gt>             /* Definition of uint64_t */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/eventfd.2:403
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int efd, j;\n"
"    uint64_t u;\n"
"    ssize_t s;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/eventfd.2:408
#, no-wrap
msgid ""
"    if (argc E<lt> 2) {\n"
"        fprintf(stderr, \"Usage: %s E<lt>numE<gt>...\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/eventfd.2:412
#, no-wrap
msgid ""
"    efd = eventfd(0, 0);\n"
"    if (efd == -1)\n"
"        handle_error(\"eventfd\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/eventfd.2:424
#, no-wrap
msgid ""
"    switch (fork()) {\n"
"    case 0:\n"
"        for (j = 1; j E<lt> argc; j++) {\n"
"            printf(\"Child writing %s to efd\\en\", argv[j]);\n"
"            u = strtoull(argv[j], NULL, 0);\n"
"                    /* strtoull() allows various bases */\n"
"            s = write(efd, &u, sizeof(uint64_t));\n"
"            if (s != sizeof(uint64_t))\n"
"                handle_error(\"write\");\n"
"        }\n"
"        printf(\"Child completed write loop\\en\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/eventfd.2:426 man-pages/man2/sched_setaffinity.2:401
#, no-wrap
msgid "        exit(EXIT_SUCCESS);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/eventfd.2:429
#, no-wrap
msgid ""
"    default:\n"
"        sleep(2);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/eventfd.2:437
#, no-wrap
msgid ""
"        printf(\"Parent about to read\\en\");\n"
"        s = read(efd, &u, sizeof(uint64_t));\n"
"        if (s != sizeof(uint64_t))\n"
"            handle_error(\"read\");\n"
"        printf(\"Parent read %llu (0x%llx) from efd\\en\",\n"
"                (unsigned long long) u, (unsigned long long) u);\n"
"        exit(EXIT_SUCCESS);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/eventfd.2:442
#, no-wrap
msgid ""
"    case -1:\n"
"        handle_error(\"fork\");\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/eventfd.2:453
msgid ""
"B<futex>(2), B<pipe>(2), B<poll>(2), B<read>(2), B<select>(2), "
"B<signalfd>(2), B<timerfd_create>(2), B<write>(2), B<epoll>(7), "
"B<sem_overview>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/posix_fadvise.2:29
#, no-wrap
msgid "POSIX_FADVISE"
msgstr ""

#. type: Plain text
#: man-pages/man2/posix_fadvise.2:32
msgid "posix_fadvise - predeclare an access pattern for file data"
msgstr ""

#. type: Plain text
#: man-pages/man2/posix_fadvise.2:35
#, no-wrap
msgid "B<#include E<lt>fcntl.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/posix_fadvise.2:38
#, no-wrap
msgid ""
"B<int posix_fadvise(int >I<fd>B<, off_t >I<offset>B<, off_t >I<len>B<, int "
">I<advice>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/posix_fadvise.2:47
msgid "B<posix_fadvise>():"
msgstr ""

#. type: Plain text
#: man-pages/man2/posix_fadvise.2:57
msgid ""
"Programs can use B<posix_fadvise>()  to announce an intention to access file "
"data in a specific pattern in the future, thus allowing the kernel to "
"perform appropriate optimizations."
msgstr ""

#. type: Plain text
#: man-pages/man2/posix_fadvise.2:64
msgid ""
"The I<advice> applies to a (not necessarily existent) region starting at "
"I<offset> and extending for I<len> bytes (or until the end of the file if "
"I<len> is 0) within the file referred to by I<fd>.  The I<advice> is not "
"binding; it merely constitutes an expectation on behalf of the application."
msgstr ""

#. type: Plain text
#: man-pages/man2/posix_fadvise.2:66
msgid "Permissible values for I<advice> include:"
msgstr ""

#. type: TP
#: man-pages/man2/posix_fadvise.2:66
#, no-wrap
msgid "B<POSIX_FADV_NORMAL>"
msgstr ""

#. type: Plain text
#: man-pages/man2/posix_fadvise.2:72
msgid ""
"Indicates that the application has no advice to give about its access "
"pattern for the specified data.  If no advice is given for an open file, "
"this is the default assumption."
msgstr ""

#. type: TP
#: man-pages/man2/posix_fadvise.2:72
#, no-wrap
msgid "B<POSIX_FADV_SEQUENTIAL>"
msgstr ""

#. type: Plain text
#: man-pages/man2/posix_fadvise.2:76
msgid ""
"The application expects to access the specified data sequentially (with "
"lower offsets read before higher ones)."
msgstr ""

#. type: TP
#: man-pages/man2/posix_fadvise.2:76
#, no-wrap
msgid "B<POSIX_FADV_RANDOM>"
msgstr ""

#. type: Plain text
#: man-pages/man2/posix_fadvise.2:79
msgid "The specified data will be accessed in random order."
msgstr ""

#. type: TP
#: man-pages/man2/posix_fadvise.2:79
#, no-wrap
msgid "B<POSIX_FADV_NOREUSE>"
msgstr ""

#. type: Plain text
#: man-pages/man2/posix_fadvise.2:82
msgid "The specified data will be accessed only once."
msgstr ""

#. type: Plain text
#: man-pages/man2/posix_fadvise.2:86
msgid ""
"In kernels before 2.6.18, B<POSIX_FADV_NOREUSE> had the same semantics as "
"B<POSIX_FADV_WILLNEED>.  This was probably a bug; since kernel 2.6.18, this "
"flag is a no-op."
msgstr ""

#. type: TP
#: man-pages/man2/posix_fadvise.2:86
#, no-wrap
msgid "B<POSIX_FADV_WILLNEED>"
msgstr ""

#. type: Plain text
#: man-pages/man2/posix_fadvise.2:89
msgid "The specified data will be accessed in the near future."
msgstr ""

#. type: Plain text
#: man-pages/man2/posix_fadvise.2:96
msgid ""
"B<POSIX_FADV_WILLNEED> initiates a nonblocking read of the specified region "
"into the page cache.  The amount of data read may be decreased by the kernel "
"depending on virtual memory load.  (A few megabytes will usually be fully "
"satisfied, and more is rarely useful.)"
msgstr ""

#. type: TP
#: man-pages/man2/posix_fadvise.2:96
#, no-wrap
msgid "B<POSIX_FADV_DONTNEED>"
msgstr ""

#. type: Plain text
#: man-pages/man2/posix_fadvise.2:99
msgid "The specified data will not be accessed in the near future."
msgstr ""

#. type: Plain text
#: man-pages/man2/posix_fadvise.2:107
msgid ""
"B<POSIX_FADV_DONTNEED> attempts to free cached pages associated with the "
"specified region.  This is useful, for example, while streaming large "
"files.  A program may periodically request the kernel to free cached data "
"that has already been used, so that more useful cached pages are not "
"discarded instead."
msgstr ""

#. type: Plain text
#: man-pages/man2/posix_fadvise.2:115
msgid ""
"Requests to discard partial pages are ignored.  It is preferable to preserve "
"needed data than discard unneeded data.  If the application requires that "
"data be considered for discarding, then I<offset> and I<len> must be "
"page-aligned."
msgstr ""

#. type: Plain text
#: man-pages/man2/posix_fadvise.2:127
msgid ""
"The implementation I<may> attempt to write back dirty pages in the specified "
"region, but this is not guaranteed.  Any unwritten dirty pages will not be "
"freed.  If the application wishes to ensure that dirty pages will be "
"released, it should call B<fsync>(2)  or B<fdatasync>(2)  first."
msgstr ""

#. type: Plain text
#: man-pages/man2/posix_fadvise.2:130
msgid "On success, zero is returned.  On error, an error number is returned."
msgstr ""

#. type: Plain text
#: man-pages/man2/posix_fadvise.2:134
msgid "The I<fd> argument was not a valid file descriptor."
msgstr ""

#. type: Plain text
#: man-pages/man2/posix_fadvise.2:137
msgid "An invalid value was specified for I<advice>."
msgstr ""

#.  commit 87ba81dba431232548ce29d5d224115d0c2355ac
#. type: Plain text
#: man-pages/man2/posix_fadvise.2:147
msgid ""
"The specified file descriptor refers to a pipe or FIFO.  (B<ESPIPE> is the "
"error specified by POSIX, but before kernel version 2.6.16, Linux returned "
"B<EINVAL> in this case.)"
msgstr ""

#.  of fadvise64_64()
#. type: Plain text
#: man-pages/man2/posix_fadvise.2:155
msgid ""
"Kernel support first appeared in Linux 2.5.60; the underlying system call is "
"called B<fadvise64>().  Library support has been provided since glibc "
"version 2.2, via the wrapper function B<posix_fadvise>()."
msgstr ""

#.  commit d3ac21cacc24790eb45d735769f35753f5b56ceb
#. type: Plain text
#: man-pages/man2/posix_fadvise.2:162
msgid ""
"Since Linux 3.18, support for the underlying system call is optional, "
"depending on the setting of the B<CONFIG_ADVISE_SYSCALLS> configuration "
"option."
msgstr ""

#. type: Plain text
#: man-pages/man2/posix_fadvise.2:171
msgid ""
"POSIX.1-2001, POSIX.1-2008.  Note that the type of the I<len> argument was "
"changed from I<size_t> to I<off_t> in POSIX.1-2003 TC1."
msgstr ""

#. type: Plain text
#: man-pages/man2/posix_fadvise.2:177
msgid ""
"Under Linux, B<POSIX_FADV_NORMAL> sets the readahead window to the default "
"size for the backing device; B<POSIX_FADV_SEQUENTIAL> doubles this size, and "
"B<POSIX_FADV_RANDOM> disables file readahead entirely.  These changes affect "
"the entire file, not just the specified region (but other open file handles "
"to the same file are unaffected)."
msgstr ""

#. type: Plain text
#: man-pages/man2/posix_fadvise.2:182
msgid ""
"The contents of the kernel buffer cache can be cleared via the "
"I</proc/sys/vm/drop_caches> interface described in B<proc>(5)."
msgstr ""

#. type: Plain text
#: man-pages/man2/posix_fadvise.2:189
msgid ""
"One can obtain a snapshot of which pages of a file are resident in the "
"buffer cache by opening a file, mapping it with B<mmap>(2), and then "
"applying B<mincore>(2)  to the mapping."
msgstr ""

#. type: Plain text
#: man-pages/man2/posix_fadvise.2:199
msgid ""
"The name of the wrapper function in the C library is B<posix_fadvise>().  "
"The underlying system call is called B<fadvise64>()  (or, on some "
"architectures, B<fadvise64_64>()); the difference between the two is that "
"the former system call assumes that the type of the I<len> argument is "
"I<size_t>, while the latter expects I<loff_t> there."
msgstr ""

#. type: SS
#: man-pages/man2/posix_fadvise.2:199
#, no-wrap
msgid "Architecture-specific variants"
msgstr ""

#. type: Plain text
#: man-pages/man2/posix_fadvise.2:216
msgid ""
"Some architectures require 64-bit arguments to be aligned in a suitable pair "
"of registers (see B<syscall>(2)  for further detail).  On such "
"architectures, the call signature of B<posix_fadvise>()  shown in the "
"SYNOPSIS would force a register to be wasted as padding between the I<fd> "
"and I<offset> arguments.  Therefore, these architectures define a version of "
"the system call that orders the arguments suitably, but is otherwise exactly "
"the same as B<posix_fadvise>()."
msgstr ""

#. type: Plain text
#: man-pages/man2/posix_fadvise.2:218
msgid "For example, since Linux 2.6.14, ARM has the following system call:"
msgstr ""

#. type: Plain text
#: man-pages/man2/posix_fadvise.2:223
#, no-wrap
msgid ""
"B<long arm_fadvise64_64(int >I<fd>B<, int >I<advice>B<,>\n"
"B<                      loff_t >I<offset>B<, loff_t >I<len>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/posix_fadvise.2:231
msgid ""
"These architecture-specific details are generally hidden from applications "
"by the glibc B<posix_fadvise>()  wrapper function, which invokes the "
"appropriate architecture-specific system call."
msgstr ""

#. type: Plain text
#: man-pages/man2/posix_fadvise.2:236
msgid ""
"In kernels before 2.6.6, if I<len> was specified as 0, then this was "
"interpreted literally as \"zero bytes\", rather than as meaning \"all bytes "
"through to the end of the file\"."
msgstr ""

#. type: Plain text
#: man-pages/man2/posix_fadvise.2:242
msgid ""
"B<fincore>(1), B<mincore>(2), B<readahead>(2), B<sync_file_range>(2), "
"B<posix_fallocate>(3), B<posix_madvise>(3)"
msgstr ""

#. type: TH
#: man-pages/man2/recv.2:41
#, no-wrap
msgid "RECV"
msgstr ""

#. type: Plain text
#: man-pages/man2/recv.2:44
msgid "recv, recvfrom, recvmsg - receive a message from a socket"
msgstr ""

#. type: Plain text
#: man-pages/man2/recv.2:53
#, no-wrap
msgid ""
"B<ssize_t recv(int >I<sockfd>B<, void *>I<buf>B<, size_t >I<len>B<, int "
">I<flags>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/recv.2:56
#, no-wrap
msgid ""
"B<ssize_t recvfrom(int >I<sockfd>B<, void *>I<buf>B<, size_t >I<len>B<, int "
">I<flags>B<,>\n"
"B<                 struct sockaddr *>I<src_addr>B<, socklen_t "
"*>I<addrlen>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/recv.2:58
#, no-wrap
msgid ""
"B<ssize_t recvmsg(int >I<sockfd>B<, struct msghdr *>I<msg>B<, int "
">I<flags>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/recv.2:70
msgid ""
"The B<recv>(), B<recvfrom>(), and B<recvmsg>()  calls are used to receive "
"messages from a socket.  They may be used to receive data on both "
"connectionless and connection-oriented sockets.  This page first describes "
"common features of all three system calls, and then describes the "
"differences between the calls."
msgstr ""

#. type: Plain text
#: man-pages/man2/recv.2:85
msgid ""
"The only difference between B<recv>()  and B<read>(2)  is the presence of "
"I<flags>.  With a zero I<flags> argument, B<recv>()  is generally equivalent "
"to B<read>(2)  (but see NOTES).  Also, the following call"
msgstr ""

#. type: Plain text
#: man-pages/man2/recv.2:87
#, no-wrap
msgid "    recv(sockfd, buf, len, flags);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/recv.2:91
#, no-wrap
msgid "    recvfrom(sockfd, buf, len, flags, NULL, NULL);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/recv.2:97
msgid ""
"All three calls return the length of the message on successful completion.  "
"If a message is too long to fit in the supplied buffer, excess bytes may be "
"discarded depending on the type of socket the message is received from."
msgstr ""

#. type: Plain text
#: man-pages/man2/recv.2:107
msgid ""
"If no messages are available at the socket, the receive calls wait for a "
"message to arrive, unless the socket is nonblocking (see B<fcntl>(2)), in "
"which case the value -1 is returned and the external variable I<errno> is "
"set to B<EAGAIN> or B<EWOULDBLOCK>.  The receive calls normally return any "
"data available, up to the requested amount, rather than waiting for receipt "
"of the full amount requested."
msgstr ""

#. type: Plain text
#: man-pages/man2/recv.2:114
msgid ""
"An application can use B<select>(2), B<poll>(2), or B<epoll>(7)  to "
"determine when more data arrives on a socket."
msgstr ""

#. type: Plain text
#: man-pages/man2/recv.2:118
msgid ""
"The I<flags> argument is formed by ORing one or more of the following "
"values:"
msgstr ""

#. type: TP
#: man-pages/man2/recv.2:118
#, no-wrap
msgid "B<MSG_CMSG_CLOEXEC> (B<recvmsg>() only; since Linux 2.6.23)"
msgstr ""

#. type: Plain text
#: man-pages/man2/recv.2:129
msgid ""
"Set the close-on-exec flag for the file descriptor received via a UNIX "
"domain file descriptor using the B<SCM_RIGHTS> operation (described in "
"B<unix>(7)).  This flag is useful for the same reasons as the B<O_CLOEXEC> "
"flag of B<open>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/recv.2:148
msgid ""
"Enables nonblocking operation; if the operation would block, the call fails "
"with the error B<EAGAIN> or B<EWOULDBLOCK>.  This provides similar behavior "
"to setting the B<O_NONBLOCK> flag (via the B<fcntl>(2)  B<F_SETFL> "
"operation), but differs in that B<MSG_DONTWAIT> is a per-call option, "
"whereas B<O_NONBLOCK> is a setting on the open file description (see "
"B<open>(2)), which will affect all threads in the calling process and as "
"well as other processes that hold file descriptors referring to the same "
"open file description."
msgstr ""

#. type: TP
#: man-pages/man2/recv.2:148
#, no-wrap
msgid "B<MSG_ERRQUEUE> (since Linux 2.2)"
msgstr ""

#. type: Plain text
#: man-pages/man2/recv.2:167
msgid ""
"This flag specifies that queued errors should be received from the socket "
"error queue.  The error is passed in an ancillary message with a type "
"dependent on the protocol (for IPv4 B<IP_RECVERR>).  The user should supply "
"a buffer of sufficient size.  See B<cmsg>(3)  and B<ip>(7)  for more "
"information.  The payload of the original packet that caused the error is "
"passed as normal data via I<msg_iovec>.  The original destination address of "
"the datagram that caused the error is supplied via I<msg_name>."
msgstr ""

#. type: Plain text
#: man-pages/man2/recv.2:171
msgid "The error is supplied in a I<sock_extended_err> structure:"
msgstr ""

#. type: Plain text
#: man-pages/man2/recv.2:178
#, no-wrap
msgid ""
"#define SO_EE_ORIGIN_NONE    0\n"
"#define SO_EE_ORIGIN_LOCAL   1\n"
"#define SO_EE_ORIGIN_ICMP    2\n"
"#define SO_EE_ORIGIN_ICMP6   3\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/recv.2:190
#, no-wrap
msgid ""
"struct sock_extended_err\n"
"{\n"
"    uint32_t ee_errno;   /* Error number */\n"
"    uint8_t  ee_origin;  /* Where the error originated */\n"
"    uint8_t  ee_type;    /* Type */\n"
"    uint8_t  ee_code;    /* Code */\n"
"    uint8_t  ee_pad;     /* Padding */\n"
"    uint32_t ee_info;    /* Additional information */\n"
"    uint32_t ee_data;    /* Other data */\n"
"    /* More data may follow */\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/recv.2:192
#, no-wrap
msgid "struct sockaddr *SO_EE_OFFENDER(struct sock_extended_err *);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/recv.2:216
msgid ""
"I<ee_errno> contains the I<errno> number of the queued error.  I<ee_origin> "
"is the origin code of where the error originated.  The other fields are "
"protocol-specific.  The macro B<SOCK_EE_OFFENDER> returns a pointer to the "
"address of the network object where the error originated from given a "
"pointer to the ancillary message.  If this address is not known, the "
"I<sa_family> member of the I<sockaddr> contains B<AF_UNSPEC> and the other "
"fields of the I<sockaddr> are undefined.  The payload of the packet that "
"caused the error is passed as normal data."
msgstr ""

#. type: Plain text
#: man-pages/man2/recv.2:230
msgid ""
"For local errors, no address is passed (this can be checked with the "
"I<cmsg_len> member of the I<cmsghdr>).  For error receives, the "
"B<MSG_ERRQUEUE> flag is set in the I<msghdr>.  After an error has been "
"passed, the pending socket error is regenerated based on the next queued "
"error and will be passed on the next socket operation."
msgstr ""

#. type: Plain text
#: man-pages/man2/recv.2:237
msgid ""
"This flag requests receipt of out-of-band data that would not be received in "
"the normal data stream.  Some protocols place expedited data at the head of "
"the normal data queue, and thus this flag cannot be used with such "
"protocols."
msgstr ""

#. type: TP
#: man-pages/man2/recv.2:237
#, no-wrap
msgid "B<MSG_PEEK>"
msgstr ""

#. type: Plain text
#: man-pages/man2/recv.2:244
msgid ""
"This flag causes the receive operation to return data from the beginning of "
"the receive queue without removing that data from the queue.  Thus, a "
"subsequent receive call will return the same data."
msgstr ""

#. type: TP
#: man-pages/man2/recv.2:244
#, no-wrap
msgid "B<MSG_TRUNC> (since Linux 2.2)"
msgstr ""

#.  commit 9f6f9af7694ede6314bed281eec74d588ba9474f
#. type: Plain text
#: man-pages/man2/recv.2:254
msgid ""
"For raw (B<AF_PACKET>), Internet datagram (since Linux 2.4.27/2.6.8), "
"netlink (since Linux 2.6.22), and UNIX datagram (since Linux 3.4) sockets: "
"return the real length of the packet or datagram, even when it was longer "
"than the passed buffer."
msgstr ""

#. type: Plain text
#: man-pages/man2/recv.2:257
msgid "For use with Internet stream sockets, see B<tcp>(7)."
msgstr ""

#. type: TP
#: man-pages/man2/recv.2:257
#, no-wrap
msgid "B<MSG_WAITALL> (since Linux 2.2)"
msgstr ""

#. type: Plain text
#: man-pages/man2/recv.2:266
msgid ""
"This flag requests that the operation block until the full request is "
"satisfied.  However, the call may still return less data than requested if a "
"signal is caught, an error or disconnect occurs, or the next data to be "
"received is of a different type than that returned.  This flag has no effect "
"for datagram sockets."
msgstr ""

#. type: SS
#: man-pages/man2/recv.2:266
#, no-wrap
msgid "recvfrom()"
msgstr ""

#. type: Plain text
#: man-pages/man2/recv.2:272
msgid ""
"B<recvfrom>()  places the received message into the buffer I<buf>.  The "
"caller must specify the size of the buffer in I<len>."
msgstr ""

#.  (Note: for datagram sockets in both the UNIX and Internet domains,
#.  .I src_addr
#.  is filled in.
#.  .I src_addr
#.  is also filled in for stream sockets in the UNIX domain, but is not
#.  filled in for stream sockets in the Internet domain.)
#.  [The above notes on AF_UNIX and AF_INET sockets apply as at
#.  Kernel 2.4.18. (MTK, 22 Jul 02)]
#. type: Plain text
#: man-pages/man2/recv.2:300
msgid ""
"If I<src_addr> is not NULL, and the underlying protocol provides the source "
"address of the message, that source address is placed in the buffer pointed "
"to by I<src_addr>.  In this case, I<addrlen> is a value-result argument.  "
"Before the call, it should be initialized to the size of the buffer "
"associated with I<src_addr>.  Upon return, I<addrlen> is updated to contain "
"the actual size of the source address.  The returned address is truncated if "
"the buffer provided is too small; in this case, I<addrlen> will return a "
"value greater than was supplied to the call."
msgstr ""

#. type: Plain text
#: man-pages/man2/recv.2:307
msgid ""
"If the caller is not interested in the source address, I<src_addr> and "
"I<addrlen> should be specified as NULL."
msgstr ""

#. type: SS
#: man-pages/man2/recv.2:307
#, no-wrap
msgid "recv()"
msgstr ""

#. type: Plain text
#: man-pages/man2/recv.2:315
msgid ""
"The B<recv>()  call is normally used only on a I<connected> socket (see "
"B<connect>(2)).  It is equivalent to the call:"
msgstr ""

#. type: Plain text
#: man-pages/man2/recv.2:318
#, no-wrap
msgid "    recvfrom(fd, buf, len, flags, NULL, 0);\n"
msgstr ""

#. type: SS
#: man-pages/man2/recv.2:318
#, no-wrap
msgid "recvmsg()"
msgstr ""

#. type: Plain text
#: man-pages/man2/recv.2:326
msgid ""
"The B<recvmsg>()  call uses a I<msghdr> structure to minimize the number of "
"directly supplied arguments.  This structure is defined as follows in "
"I<E<lt>sys/socket.hE<gt>>:"
msgstr ""

#. type: Plain text
#: man-pages/man2/recv.2:333
#, no-wrap
msgid ""
"struct iovec {                    /* Scatter/gather array items */\n"
"    void  *iov_base;              /* Starting address */\n"
"    size_t iov_len;               /* Number of bytes to transfer */\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/recv.2:343
#, no-wrap
msgid ""
"struct msghdr {\n"
"    void         *msg_name;       /* Optional address */\n"
"    socklen_t     msg_namelen;    /* Size of address */\n"
"    struct iovec *msg_iov;        /* Scatter/gather array */\n"
"    size_t        msg_iovlen;     /* # elements in msg_iov */\n"
"    void         *msg_control;    /* Ancillary data, see below */\n"
"    size_t        msg_controllen; /* Ancillary data buffer len */\n"
"    int           msg_flags;      /* Flags on received message */\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/recv.2:359
msgid ""
"The I<msg_name> field points to a caller-allocated buffer that is used to "
"return the source address if the socket is unconnected.  The caller should "
"set I<msg_namelen> to the size of this buffer before this call; upon return "
"from a successful call, I<msg_namelen> will contain the length of the "
"returned address.  If the application does not need to know the source "
"address, I<msg_name> can be specified as NULL."
msgstr ""

#. type: Plain text
#: man-pages/man2/recv.2:366
msgid ""
"The fields I<msg_iov> and I<msg_iovlen> describe scatter-gather locations, "
"as discussed in B<readv>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/recv.2:381
msgid ""
"The field I<msg_control>, which has length I<msg_controllen>, points to a "
"buffer for other protocol control-related messages or miscellaneous "
"ancillary data.  When B<recvmsg>()  is called, I<msg_controllen> should "
"contain the length of the available buffer in I<msg_control>; upon return "
"from a successful call it will contain the length of the control message "
"sequence."
msgstr ""

#. type: Plain text
#: man-pages/man2/recv.2:383
msgid "The messages are of the form:"
msgstr ""

#. type: Plain text
#: man-pages/man2/recv.2:394
#, no-wrap
msgid ""
"struct cmsghdr {\n"
"    size_t cmsg_len;    /* Data byte count, including header\n"
"                           (type is socklen_t in POSIX) */\n"
"    int    cmsg_level;  /* Originating protocol */\n"
"    int    cmsg_type;   /* Protocol-specific type */\n"
"/* followed by\n"
"    unsigned char cmsg_data[]; */\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/recv.2:399
msgid "Ancillary data should be accessed only by the macros defined in B<cmsg>(3)."
msgstr ""

#. type: Plain text
#: man-pages/man2/recv.2:402
msgid ""
"As an example, Linux uses this ancillary data mechanism to pass extended "
"errors, IP options, or file descriptors over UNIX domain sockets."
msgstr ""

#. type: Plain text
#: man-pages/man2/recv.2:410
msgid ""
"The I<msg_flags> field in the I<msghdr> is set on return of B<recvmsg>().  "
"It can contain several flags:"
msgstr ""

#. type: TP
#: man-pages/man2/recv.2:410
#, no-wrap
msgid "B<MSG_EOR>"
msgstr ""

#. type: Plain text
#: man-pages/man2/recv.2:415
msgid ""
"indicates end-of-record; the data returned completed a record (generally "
"used with sockets of type B<SOCK_SEQPACKET>)."
msgstr ""

#. type: TP
#: man-pages/man2/recv.2:415
#, no-wrap
msgid "B<MSG_TRUNC>"
msgstr ""

#. type: Plain text
#: man-pages/man2/recv.2:419
msgid ""
"indicates that the trailing portion of a datagram was discarded because the "
"datagram was larger than the buffer supplied."
msgstr ""

#. type: TP
#: man-pages/man2/recv.2:419
#, no-wrap
msgid "B<MSG_CTRUNC>"
msgstr ""

#. type: Plain text
#: man-pages/man2/recv.2:423
msgid ""
"indicates that some control data was discarded due to lack of space in the "
"buffer for ancillary data."
msgstr ""

#. type: Plain text
#: man-pages/man2/recv.2:426
msgid "is returned to indicate that expedited or out-of-band data was received."
msgstr ""

#. type: TP
#: man-pages/man2/recv.2:426
#, no-wrap
msgid "B<MSG_ERRQUEUE>"
msgstr ""

#. type: Plain text
#: man-pages/man2/recv.2:430
msgid ""
"indicates that no data was received but an extended error from the socket "
"error queue."
msgstr ""

#. type: Plain text
#: man-pages/man2/recv.2:436
msgid ""
"These calls return the number of bytes received, or -1 if an error "
"occurred.  In the event of an error, I<errno> is set to indicate the error."
msgstr ""

#. type: Plain text
#: man-pages/man2/recv.2:439
msgid ""
"When a stream socket peer has performed an orderly shutdown, the return "
"value will be 0 (the traditional \"end-of-file\" return)."
msgstr ""

#. type: Plain text
#: man-pages/man2/recv.2:443
msgid ""
"Datagram sockets in various domains (e.g., the UNIX and Internet domains)  "
"permit zero-length datagrams.  When such a datagram is received, the return "
"value is 0."
msgstr ""

#. type: Plain text
#: man-pages/man2/recv.2:446
msgid ""
"The value 0 may also be returned if the requested number of bytes to receive "
"from a stream socket was 0."
msgstr ""

#. type: Plain text
#: man-pages/man2/recv.2:451
msgid ""
"These are some standard errors generated by the socket layer.  Additional "
"errors may be generated and returned from the underlying protocol modules; "
"see their manual pages."
msgstr ""

#.  Actually EAGAIN on Linux
#. type: Plain text
#: man-pages/man2/recv.2:460
msgid ""
"The socket is marked nonblocking and the receive operation would block, or a "
"receive timeout had been set and the timeout expired before data was "
"received.  POSIX.1 allows either error to be returned for this case, and "
"does not require these constants to have the same value, so a portable "
"application should check for both possibilities."
msgstr ""

#. type: Plain text
#: man-pages/man2/recv.2:465
msgid "The argument I<sockfd> is an invalid file descriptor."
msgstr ""

#. type: Plain text
#: man-pages/man2/recv.2:469
msgid ""
"A remote host refused to allow the network connection (typically because it "
"is not running the requested service)."
msgstr ""

#. type: Plain text
#: man-pages/man2/recv.2:473
msgid "The receive buffer pointer(s) point outside the process's address space."
msgstr ""

#. type: Plain text
#: man-pages/man2/recv.2:478
msgid ""
"The receive was interrupted by delivery of a signal before any data was "
"available; see B<signal>(7)."
msgstr ""

#. type: Plain text
#: man-pages/man2/recv.2:486
msgid "Could not allocate memory for B<recvmsg>()."
msgstr ""

#. type: Plain text
#: man-pages/man2/recv.2:493
msgid ""
"The socket is associated with a connection-oriented protocol and has not "
"been connected (see B<connect>(2)  and B<accept>(2))."
msgstr ""

#. type: Plain text
#: man-pages/man2/recv.2:501
msgid ""
"POSIX.1-2001, POSIX.1-2008, 4.4BSD (these interfaces first appeared in "
"4.2BSD)."
msgstr ""

#. type: Plain text
#: man-pages/man2/recv.2:508
msgid ""
"POSIX.1 describes only the B<MSG_OOB>, B<MSG_PEEK>, and B<MSG_WAITALL> "
"flags."
msgstr ""

#. type: Plain text
#: man-pages/man2/recv.2:521
msgid ""
"If a zero-length datagram is pending, B<read>(2)  and B<recv>()  with a "
"I<flags> argument of zero provide different behavior.  In this circumstance, "
"B<read>(2)  has no effect (the datagram remains pending), while B<recv>()  "
"consumes the pending datagram."
msgstr ""

#. type: Plain text
#: man-pages/man2/recv.2:527
msgid "The I<socklen_t> type was invented by POSIX.  See also B<accept>(2)."
msgstr ""

#.  POSIX.1-2001, POSIX.1-2008
#.  glibc bug raised 12 Mar 2006
#.  http://sourceware.org/bugzilla/show_bug.cgi?id=2448
#.  The problem is an underlying kernel issue: the size of the
#.  __kernel_size_t type used to type this field varies
#.  across architectures, but socklen_t is always 32 bits.
#. type: Plain text
#: man-pages/man2/recv.2:543
msgid ""
"According to POSIX.1, the I<msg_controllen> field of the I<msghdr> structure "
"should be typed as I<socklen_t>, but glibc currently types it as I<size_t>."
msgstr ""

#. type: Plain text
#: man-pages/man2/recv.2:548
msgid ""
"See B<recvmmsg>(2)  for information about a Linux-specific system call that "
"can be used to receive multiple datagrams in a single call."
msgstr ""

#. type: Plain text
#: man-pages/man2/recv.2:553
msgid "An example of the use of B<recvfrom>()  is shown in B<getaddrinfo>(3)."
msgstr ""

#. type: Plain text
#: man-pages/man2/recv.2:568
msgid ""
"B<fcntl>(2), B<getsockopt>(2), B<read>(2), B<recvmmsg>(2), B<select>(2), "
"B<shutdown>(2), B<socket>(2), B<cmsg>(3), B<sockatmark>(3), B<ip>(7), "
"B<ipv6>(7), B<socket>(7), B<tcp>(7), B<udp>(7), B<unix>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/fanotify_mark.2:24
#, no-wrap
msgid "FANOTIFY_MARK"
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:28
msgid ""
"fanotify_mark - add, remove, or modify an fanotify mark on a filesystem "
"object"
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:31
#, no-wrap
msgid "B<#include E<lt>sys/fanotify.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:35
#, no-wrap
msgid ""
"B<int fanotify_mark(int >I<fanotify_fd>B<, unsigned int >I<flags>B<,>\n"
"B<                  uint64_t >I<mask>B<, int >I<dirfd>B<, const char "
"*>I<pathname>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:44
msgid ""
"B<fanotify_mark>()  adds, removes, or modifies an fanotify mark on a "
"filesystem object.  The caller must have read permission on the filesystem "
"object that is to be marked."
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:49
msgid ""
"The I<fanotify_fd> argument is a file descriptor returned by "
"B<fanotify_init>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:53
msgid ""
"I<flags> is a bit mask describing the modification to perform.  It must "
"include exactly one of the following values:"
msgstr ""

#. type: TP
#: man-pages/man2/fanotify_mark.2:53
#, no-wrap
msgid "B<FAN_MARK_ADD>"
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:62
msgid ""
"The events in I<mask> will be added to the mark mask (or to the ignore "
"mask).  I<mask> must be nonempty or the error B<EINVAL> will occur."
msgstr ""

#. type: TP
#: man-pages/man2/fanotify_mark.2:62
#, no-wrap
msgid "B<FAN_MARK_REMOVE>"
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:71
msgid ""
"The events in argument I<mask> will be removed from the mark mask (or from "
"the ignore mask).  I<mask> must be nonempty or the error B<EINVAL> will "
"occur."
msgstr ""

#. type: TP
#: man-pages/man2/fanotify_mark.2:71
#, no-wrap
msgid "B<FAN_MARK_FLUSH>"
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:94
msgid ""
"Remove either all marks for filesystems, all marks for mounts, or all marks "
"for directories and files from the fanotify group.  If I<flags> contains "
"B<FAN_MARK_MOUNT>, all marks for mounts are removed from the group.  If "
"I<flags> contains B<FAN_MARK_FILESYSTEM>, all marks for filesystems are "
"removed from the group.  Otherwise, all marks for directories and files are "
"removed.  No flag other than and at most one of the flags B<FAN_MARK_MOUNT> "
"or B<FAN_MARK_FILESYSTEM> can be used in conjunction with "
"B<FAN_MARK_FLUSH>.  I<mask> is ignored."
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:98
msgid ""
"If none of the values above is specified, or more than one is specified, the "
"call fails with the error B<EINVAL>."
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:102
msgid "In addition, zero or more of the following values may be ORed into I<flags>:"
msgstr ""

#. type: TP
#: man-pages/man2/fanotify_mark.2:102
#, no-wrap
msgid "B<FAN_MARK_DONT_FOLLOW>"
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:113
msgid ""
"If I<pathname> is a symbolic link, mark the link itself, rather than the "
"file to which it refers.  (By default, B<fanotify_mark>()  dereferences "
"I<pathname> if it is a symbolic link.)"
msgstr ""

#. type: TP
#: man-pages/man2/fanotify_mark.2:113
#, no-wrap
msgid "B<FAN_MARK_ONLYDIR>"
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:118
msgid ""
"If the filesystem object to be marked is not a directory, the error "
"B<ENOTDIR> shall be raised."
msgstr ""

#. type: TP
#: man-pages/man2/fanotify_mark.2:118
#, no-wrap
msgid "B<FAN_MARK_MOUNT>"
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:138
msgid ""
"Mark the mount point specified by I<pathname>.  If I<pathname> is not itself "
"a mount point, the mount point containing I<pathname> will be marked.  All "
"directories, subdirectories, and the contained files of the mount point will "
"be monitored.  This value cannot be used if the I<fanotify_fd> file "
"descriptor has been initialized with the flag B<FAN_REPORT_FID> or if any of "
"the new directory modification events are provided as a I<mask>.  Attempting "
"to do so will result in the error B<EINVAL> being returned."
msgstr ""

#. type: TP
#: man-pages/man2/fanotify_mark.2:138
#, no-wrap
msgid "B<FAN_MARK_FILESYSTEM> (since Linux 4.20)"
msgstr ""

#.  commit d54f4fba889b205e9cd8239182ca5d27d0ac3bc2
#. type: Plain text
#: man-pages/man2/fanotify_mark.2:148
msgid ""
"Mark the filesystem specified by I<pathname>.  The filesystem containing "
"I<pathname> will be marked.  All the contained files and directories of the "
"filesystem from any mount point will be monitored."
msgstr ""

#. type: TP
#: man-pages/man2/fanotify_mark.2:148
#, no-wrap
msgid "B<FAN_MARK_IGNORED_MASK>"
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:153
msgid "The events in I<mask> shall be added to or removed from the ignore mask."
msgstr ""

#. type: TP
#: man-pages/man2/fanotify_mark.2:153
#, no-wrap
msgid "B<FAN_MARK_IGNORED_SURV_MODIFY>"
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:159
msgid ""
"The ignore mask shall survive modify events.  If this flag is not set, the "
"ignore mask is cleared when a modify event occurs for the ignored file or "
"directory."
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:163
msgid ""
"I<mask> defines which events shall be listened for (or which shall be "
"ignored).  It is a bit mask composed of the following values:"
msgstr ""

#. type: TP
#: man-pages/man2/fanotify_mark.2:163
#, no-wrap
msgid "B<FAN_ACCESS>"
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:166
msgid "Create an event when a file or directory (but see BUGS) is accessed (read)."
msgstr ""

#. type: TP
#: man-pages/man2/fanotify_mark.2:166
#, no-wrap
msgid "B<FAN_MODIFY>"
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:169
msgid "Create an event when a file is modified (write)."
msgstr ""

#. type: TP
#: man-pages/man2/fanotify_mark.2:169
#, no-wrap
msgid "B<FAN_CLOSE_WRITE>"
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:172
msgid "Create an event when a writable file is closed."
msgstr ""

#. type: TP
#: man-pages/man2/fanotify_mark.2:172
#, no-wrap
msgid "B<FAN_CLOSE_NOWRITE>"
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:175
msgid "Create an event when a read-only file or directory is closed."
msgstr ""

#. type: TP
#: man-pages/man2/fanotify_mark.2:175
#, no-wrap
msgid "B<FAN_OPEN>"
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:178
msgid "Create an event when a file or directory is opened."
msgstr ""

#. type: TP
#: man-pages/man2/fanotify_mark.2:178
#, no-wrap
msgid "B<FAN_OPEN_EXEC> (since Linux 5.0)"
msgstr ""

#.  commit 9b076f1c0f4869b838a1b7aa0edb5664d47ec8aa
#. type: Plain text
#: man-pages/man2/fanotify_mark.2:183
msgid ""
"Create an event when a file is opened with the intent to be executed.  See "
"NOTES for additional details."
msgstr ""

#. type: TP
#: man-pages/man2/fanotify_mark.2:183
#, no-wrap
msgid "B<FAN_ATTRIB> (since Linux 5.1)"
msgstr ""

#.  commit 235328d1fa4251c6dcb32351219bb553a58838d2
#. type: Plain text
#: man-pages/man2/fanotify_mark.2:187
msgid "Create an event when the metadata for a file or directory has changed."
msgstr ""

#. type: TP
#: man-pages/man2/fanotify_mark.2:187
#, no-wrap
msgid "B<FAN_CREATE> (since Linux 5.1)"
msgstr ""

#.  commit 235328d1fa4251c6dcb32351219bb553a58838d2
#. type: Plain text
#: man-pages/man2/fanotify_mark.2:192
msgid ""
"Create an event when a file or directory has been created in a marked parent "
"directory."
msgstr ""

#. type: TP
#: man-pages/man2/fanotify_mark.2:192
#, no-wrap
msgid "B<FAN_DELETE> (since Linux 5.1)"
msgstr ""

#.  commit 235328d1fa4251c6dcb32351219bb553a58838d2
#. type: Plain text
#: man-pages/man2/fanotify_mark.2:197
msgid ""
"Create an event when a file or directory has been deleted in a marked parent "
"directory."
msgstr ""

#. type: TP
#: man-pages/man2/fanotify_mark.2:197
#, no-wrap
msgid "B<FAN_DELETE_SELF> (since Linux 5.1)"
msgstr ""

#.  commit 235328d1fa4251c6dcb32351219bb553a58838d2
#. type: Plain text
#: man-pages/man2/fanotify_mark.2:201
msgid "Create an event when a marked file or directory itself is deleted."
msgstr ""

#. type: TP
#: man-pages/man2/fanotify_mark.2:201
#, no-wrap
msgid "B<FAN_MOVED_FROM> (since Linux 5.1)"
msgstr ""

#.  commit 235328d1fa4251c6dcb32351219bb553a58838d2
#. type: Plain text
#: man-pages/man2/fanotify_mark.2:206
msgid ""
"Create an event when a file or directory has been moved from a marked parent "
"directory."
msgstr ""

#. type: TP
#: man-pages/man2/fanotify_mark.2:206
#, no-wrap
msgid "B<FAN_MOVED_TO> (since Linux 5.1)"
msgstr ""

#.  commit 235328d1fa4251c6dcb32351219bb553a58838d2
#. type: Plain text
#: man-pages/man2/fanotify_mark.2:211
msgid ""
"Create an event when a file or directory has been moved to a marked parent "
"directory."
msgstr ""

#. type: TP
#: man-pages/man2/fanotify_mark.2:211
#, no-wrap
msgid "B<FAN_MOVE_SELF> (since Linux 5.1)"
msgstr ""

#.  commit 235328d1fa4251c6dcb32351219bb553a58838d2
#. type: Plain text
#: man-pages/man2/fanotify_mark.2:215
msgid "Create an event when a marked file or directory itself has been moved."
msgstr ""

#. type: TP
#: man-pages/man2/fanotify_mark.2:215
#, no-wrap
msgid "B<FAN_Q_OVERFLOW>"
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:222
msgid ""
"Create an event when an overflow of the event queue occurs.  The size of the "
"event queue is limited to 16384 entries if B<FAN_UNLIMITED_QUEUE> is not set "
"in B<fanotify_init>(2)."
msgstr ""

#. type: TP
#: man-pages/man2/fanotify_mark.2:222
#, no-wrap
msgid "B<FAN_OPEN_PERM>"
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:230
msgid ""
"Create an event when a permission to open a file or directory is requested.  "
"An fanotify file descriptor created with B<FAN_CLASS_PRE_CONTENT> or "
"B<FAN_CLASS_CONTENT> is required."
msgstr ""

#. type: TP
#: man-pages/man2/fanotify_mark.2:230
#, no-wrap
msgid "B<FAN_OPEN_EXEC_PERM> (since Linux 5.0)"
msgstr ""

#.  commit 66917a3130f218dcef9eeab4fd11a71cd00cd7c9
#. type: Plain text
#: man-pages/man2/fanotify_mark.2:241
msgid ""
"Create an event when a permission to open a file for execution is "
"requested.  An fanotify file descriptor created with "
"B<FAN_CLASS_PRE_CONTENT> or B<FAN_CLASS_CONTENT> is required.  See NOTES for "
"additional details."
msgstr ""

#. type: TP
#: man-pages/man2/fanotify_mark.2:241
#, no-wrap
msgid "B<FAN_ACCESS_PERM>"
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:249
msgid ""
"Create an event when a permission to read a file or directory is requested.  "
"An fanotify file descriptor created with B<FAN_CLASS_PRE_CONTENT> or "
"B<FAN_CLASS_CONTENT> is required."
msgstr ""

#. type: TP
#: man-pages/man2/fanotify_mark.2:249
#, no-wrap
msgid "B<FAN_ONDIR>"
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:280
msgid ""
"Create events for directories\\(emfor example, when B<opendir>(3), "
"B<readdir>(3)  (but see BUGS), and B<closedir>(3)  are called.  Without this "
"flag, only events for files are created.  The B<FAN_ONDIR> flag is reported "
"in an event mask only if the I<fanotify_fd> file descriptor has been "
"initialized with the flag B<FAN_REPORT_FID>.  In the context of directory "
"entry events, such as B<FAN_CREATE>, B<FAN_DELETE>, B<FAN_MOVED_FROM>, and "
"B<FAN_MOVED_TO> for example, specifying the flag B<FAN_ONDIR> is required in "
"order to create events when subdirectory entries are modified (i.e., "
"B<mkdir>(2)/ B<rmdir>(2)).  Subdirectory entry modification events will "
"never be merged with nonsubdirectory entry modification events.  This flag "
"is never reported individually within an event and is always supplied in "
"conjunction with another event type."
msgstr ""

#. type: TP
#: man-pages/man2/fanotify_mark.2:280
#, no-wrap
msgid "B<FAN_EVENT_ON_CHILD>"
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:288
msgid ""
"Events for the immediate children of marked directories shall be created.  "
"The flag has no effect when marking mounts and filesystems.  Note that "
"events are not generated for children of the subdirectories of marked "
"directories.  To monitor complete directory trees it is necessary to mark "
"the relevant mount."
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:290
msgid "The following composed values are defined:"
msgstr ""

#. type: TP
#: man-pages/man2/fanotify_mark.2:290
#, no-wrap
msgid "B<FAN_CLOSE>"
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:294
msgid "A file is closed (B<FAN_CLOSE_WRITE>|B<FAN_CLOSE_NOWRITE>)."
msgstr ""

#. type: TP
#: man-pages/man2/fanotify_mark.2:294
#, no-wrap
msgid "B<FAN_MOVE>"
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:298
msgid "A file or directory has been moved (B<FAN_MOVED_FROM>|B<FAN_MOVED_TO>)."
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:303
msgid ""
"The filesystem object to be marked is determined by the file descriptor "
"I<dirfd> and the pathname specified in I<pathname>:"
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:309
msgid "If I<pathname> is NULL, I<dirfd> defines the filesystem object to be marked."
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:317
msgid ""
"If I<pathname> is NULL, and I<dirfd> takes the special value B<AT_FDCWD>, "
"the current working directory is to be marked."
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:323
msgid ""
"If I<pathname> is absolute, it defines the filesystem object to be marked, "
"and I<dirfd> is ignored."
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:334
msgid ""
"If I<pathname> is relative, and I<dirfd> does not have the value "
"B<AT_FDCWD>, then the filesystem object to be marked is determined by "
"interpreting I<pathname> relative the directory referred to by I<dirfd>."
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:344
msgid ""
"If I<pathname> is relative, and I<dirfd> has the value B<AT_FDCWD>, then the "
"filesystem object to be marked is determined by interpreting I<pathname> "
"relative the current working directory."
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:351
msgid ""
"On success, B<fanotify_mark>()  returns 0.  On error, -1 is returned, and "
"I<errno> is set to indicate the error."
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:356
msgid "An invalid file descriptor was passed in I<fanotify_fd>."
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:365
msgid ""
"An invalid value was passed in I<flags> or I<mask>, or I<fanotify_fd> was "
"not an fanotify file descriptor."
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:375
msgid ""
"The fanotify file descriptor was opened with B<FAN_CLASS_NOTIF> or "
"B<FAN_REPORT_FID> and mask contains a flag for permission events "
"(B<FAN_OPEN_PERM> or B<FAN_ACCESS_PERM>)."
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:388
msgid ""
"The filesystem object indicated by I<pathname> is not associated with a "
"filesystem that supports I<fsid> (e.g., B<tmpfs>(5)).  This error can be "
"returned only when an fanotify file descriptor returned by "
"B<fanotify_init>(2)  has been created with B<FAN_REPORT_FID>."
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:397
msgid ""
"The filesystem object indicated by I<dirfd> and I<pathname> does not exist.  "
"This error also occurs when trying to remove a mark from an object which is "
"not marked."
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:400
msgid "The necessary memory could not be allocated."
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:406
msgid ""
"The number of marks exceeds the limit of 8192 and the B<FAN_UNLIMITED_MARKS> "
"flag was not specified when the fanotify file descriptor was created with "
"B<fanotify_init>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:412
msgid ""
"This kernel does not implement B<fanotify_mark>().  The fanotify API is "
"available only if the kernel was configured with B<CONFIG_FANOTIFY>."
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:422
msgid ""
"I<flags> contains B<FAN_MARK_ONLYDIR>, and I<dirfd> and I<pathname> do not "
"specify a directory."
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:433
msgid ""
"The object indicated by I<pathname> is associated with a filesystem that "
"does not support the encoding of file handles.  This error can be returned "
"only when an fanotify file descriptor returned by B<fanotify_init>(2)  has "
"been created with B<FAN_REPORT_FID>."
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:447
msgid ""
"The filesystem object indicated by I<pathname> resides within a filesystem "
"subvolume (e.g., B<btrfs>(5))  which uses a different I<fsid> than its root "
"superblock.  This error can be returned only when an fanotify file "
"descriptor returned by B<fanotify_init>(2)  has been created with "
"B<FAN_REPORT_FID>."
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:451
msgid ""
"B<fanotify_mark>()  was introduced in version 2.6.36 of the Linux kernel and "
"enabled in version 2.6.37."
msgstr ""

#. type: SS
#: man-pages/man2/fanotify_mark.2:454
#, no-wrap
msgid "FAN_OPEN_EXEC and FAN_OPEN_EXEC_PERM"
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:471
msgid ""
"When using either B<FAN_OPEN_EXEC> or B<FAN_OPEN_EXEC_PERM> within the "
"I<mask>, events of these types will be returned only when the direct "
"execution of a program occurs.  More specifically, this means that events of "
"these types will be generated for files that are opened using B<execve>(2), "
"B<execveat>(2), or B<uselib>(2).  Events of these types will not be raised "
"in the situation where an interpreter is passed (or reads) a script file for "
"interpretation."
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:478
msgid ""
"Additionally, if a mark has also been placed on the Linux dynamic linker, a "
"user should also expect to receive an event for it when an ELF object has "
"been successfully opened using B<execve>(2)  or B<execveat>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:482
msgid ""
"For example, if the following ELF binary were to be invoked and a "
"B<FAN_OPEN_EXEC> mark has been placed on /:"
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:486
#, no-wrap
msgid "$ /bin/echo foo\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:492
msgid ""
"The listening application in this case would receive B<FAN_OPEN_EXEC> events "
"for both the ELF binary and interpreter, respectively:"
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:497
#, no-wrap
msgid ""
"/bin/echo\n"
"/lib64/ld-linux-x86-64.so.2\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:501
msgid "The following bugs were present in Linux kernels before version 3.16:"
msgstr ""

#.  Fixed by commit 0a8dd2db579f7a0ac7033d6b857c3d5dbaa77563
#. type: Plain text
#: man-pages/man2/fanotify_mark.2:511
msgid ""
"If I<flags> contains B<FAN_MARK_FLUSH>, I<dirfd> and I<pathname> must "
"specify a valid filesystem object, even though this object is not used."
msgstr ""

#.  Fixed by commit d4c7cf6cffb1bc711a833b5e304ba5bcfe76398b
#. type: Plain text
#: man-pages/man2/fanotify_mark.2:517
msgid "B<readdir>(2)  does not generate a B<FAN_ACCESS> event."
msgstr ""

#.  Fixed by commit cc299a98eb13a9853675a9cbb90b30b4011e1406
#. type: Plain text
#: man-pages/man2/fanotify_mark.2:525
msgid ""
"If B<fanotify_mark>()  is called with B<FAN_MARK_FLUSH>, I<flags> is not "
"checked for invalid values."
msgstr ""

#. type: Plain text
#: man-pages/man2/fanotify_mark.2:527
msgid "B<fanotify_init>(2), B<fanotify>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/init_module.2:27
#, no-wrap
msgid "INIT_MODULE"
msgstr ""

#. type: Plain text
#: man-pages/man2/init_module.2:30
msgid "init_module, finit_module - load a kernel module"
msgstr ""

#. type: Plain text
#: man-pages/man2/init_module.2:34
#, no-wrap
msgid ""
"B<int init_module(void *>I<module_image>B<, unsigned long >I<len>B<,>\n"
"B<                const char *>I<param_values>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/init_module.2:37
#, no-wrap
msgid ""
"B<int finit_module(int >I<fd>B<, const char *>I<param_values>B<,>\n"
"B<                 int >I<flags>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/init_module.2:45
msgid ""
"I<Note>: glibc provides no header file declaration of B<init_module>()  and "
"no wrapper function for B<finit_module>(); see NOTES."
msgstr ""

#. type: Plain text
#: man-pages/man2/init_module.2:54
msgid ""
"B<init_module>()  loads an ELF image into kernel space, performs any "
"necessary symbol relocations, initializes module parameters to values "
"provided by the caller, and then runs the module's I<init> function.  This "
"system call requires privilege."
msgstr ""

#. type: Plain text
#: man-pages/man2/init_module.2:62
msgid ""
"The I<module_image> argument points to a buffer containing the binary image "
"to be loaded; I<len> specifies the size of that buffer.  The module image "
"should be a valid ELF image, built for the running kernel."
msgstr ""

#. type: Plain text
#: man-pages/man2/init_module.2:73
msgid ""
"The I<param_values> argument is a string containing space-delimited "
"specifications of the values for module parameters (defined inside the "
"module using B<module_param>()  and B<module_param_array>()).  The kernel "
"parses this string and initializes the specified parameters.  Each of the "
"parameter specifications has the form:"
msgstr ""

#. type: Plain text
#: man-pages/man2/init_module.2:78
msgid "I<name>[B<=>I<value>[B<,>I<value>...]]"
msgstr ""

#. type: Plain text
#: man-pages/man2/init_module.2:93
msgid ""
"The parameter I<name> is one of those defined within the module using "
"I<module_param>()  (see the Linux kernel source file "
"I<include/linux/moduleparam.h>).  The parameter I<value> is optional in the "
"case of I<bool> and I<invbool> parameters.  Values for array parameters are "
"specified as a comma-separated list."
msgstr ""

#. type: SS
#: man-pages/man2/init_module.2:93
#, no-wrap
msgid "finit_module()"
msgstr ""

#.  commit 34e1169d996ab148490c01b65b4ee371cf8ffba2
#.  https://lwn.net/Articles/519010/
#. type: Plain text
#: man-pages/man2/init_module.2:111
msgid ""
"The B<finit_module>()  system call is like B<init_module>(), but reads the "
"module to be loaded from the file descriptor I<fd>.  It is useful when the "
"authenticity of a kernel module can be determined from its location in the "
"filesystem; in cases where that is possible, the overhead of using "
"cryptographically signed modules to determine the authenticity of a module "
"can be avoided.  The I<param_values> argument is as for B<init_module>()."
msgstr ""

#.  commit 2f3238aebedb243804f58d62d57244edec4149b2
#. type: Plain text
#: man-pages/man2/init_module.2:119
msgid ""
"The I<flags> argument modifies the operation of B<finit_module>().  It is a "
"bit mask value created by ORing together zero or more of the following "
"flags:"
msgstr ""

#. type: TP
#: man-pages/man2/init_module.2:119
#, no-wrap
msgid "B<MODULE_INIT_IGNORE_MODVERSIONS>"
msgstr ""

#. type: Plain text
#: man-pages/man2/init_module.2:122
msgid "Ignore symbol version hashes."
msgstr ""

#. type: TP
#: man-pages/man2/init_module.2:122
#, no-wrap
msgid "B<MODULE_INIT_IGNORE_VERMAGIC>"
msgstr ""

#. type: Plain text
#: man-pages/man2/init_module.2:125
msgid "Ignore kernel version magic."
msgstr ""

#.  http://www.tldp.org/HOWTO/Module-HOWTO/basekerncompat.html
#.  is dated, but informative
#. type: Plain text
#: man-pages/man2/init_module.2:143
msgid ""
"There are some safety checks built into a module to ensure that it matches "
"the kernel against which it is loaded.  These checks are recorded when the "
"module is built and verified when the module is loaded.  First, the module "
"records a \"vermagic\" string containing the kernel version number and "
"prominent features (such as the CPU type).  Second, if the module was built "
"with the B<CONFIG_MODVERSIONS> configuration option enabled, a version hash "
"is recorded for each symbol the module uses.  This hash is based on the "
"types of the arguments and return value for the function named by the "
"symbol.  In this case, the kernel version number within the \"vermagic\" "
"string is ignored, as the symbol version hashes are assumed to be "
"sufficiently reliable."
msgstr ""

#. type: Plain text
#: man-pages/man2/init_module.2:154
msgid ""
"Using the B<MODULE_INIT_IGNORE_VERMAGIC> flag indicates that the "
"\"vermagic\" string is to be ignored, and the "
"B<MODULE_INIT_IGNORE_MODVERSIONS> flag indicates that the symbol version "
"hashes are to be ignored.  If the kernel is built to permit forced loading "
"(i.e., configured with B<CONFIG_MODULE_FORCE_LOAD>), then loading continues, "
"otherwise it fails with the error B<ENOEXEC> as expected for malformed "
"modules."
msgstr ""

#. type: Plain text
#: man-pages/man2/init_module.2:159
msgid ""
"On success, these system calls return 0.  On error, -1 is returned and "
"I<errno> is set appropriately."
msgstr ""

#. type: TP
#: man-pages/man2/init_module.2:160
#, no-wrap
msgid "B<EBADMSG> (since Linux 3.7)"
msgstr ""

#. type: Plain text
#: man-pages/man2/init_module.2:163
msgid "Module signature is misformatted."
msgstr ""

#. type: Plain text
#: man-pages/man2/init_module.2:166
msgid "Timeout while trying to resolve a symbol reference by this module."
msgstr ""

#. type: Plain text
#: man-pages/man2/init_module.2:170
msgid ""
"An address argument referred to a location that is outside the process's "
"accessible address space."
msgstr ""

#. type: TP
#: man-pages/man2/init_module.2:170
#, no-wrap
msgid "B<ENOKEY> (since Linux 3.7)"
msgstr ""

#.  commit 48ba2462ace6072741fd8d0058207d630ce93bf1
#.  commit 1d0059f3a468825b5fc5405c636a2f6e02707ffa
#.  commit 106a4ee258d14818467829bf0e12aeae14c16cd7
#. type: Plain text
#: man-pages/man2/init_module.2:181
msgid ""
"Module signature is invalid or the kernel does not have a key for this "
"module.  This error is returned only if the kernel was configured with "
"B<CONFIG_MODULE_SIG_FORCE>; if the kernel was not configured with this "
"option, then an invalid or unsigned module simply taints the kernel."
msgstr ""

#. type: Plain text
#: man-pages/man2/init_module.2:195
msgid ""
"The caller was not privileged (did not have the B<CAP_SYS_MODULE> "
"capability), or module loading is disabled (see "
"I</proc/sys/kernel/modules_disabled> in B<proc>(5))."
msgstr ""

#. type: Plain text
#: man-pages/man2/init_module.2:198
msgid "The following errors may additionally occur for B<init_module>():"
msgstr ""

#. type: Plain text
#: man-pages/man2/init_module.2:201
msgid "A module with this name is already loaded."
msgstr ""

#.  .TP
#.  .BR EINVAL " (Linux 2.4 and earlier)"
#.  Some
#.  .I image
#.  slot is filled in incorrectly,
#.  .I image\->name
#.  does not correspond to the original module name, some
#.  .I image\->deps
#.  entry does not correspond to a loaded module,
#.  or some other similar inconsistency.
#. type: Plain text
#: man-pages/man2/init_module.2:217
msgid ""
"I<param_values> is invalid, or some part of the ELF image in I<module_image> "
"contains inconsistencies."
msgstr ""

#. type: Plain text
#: man-pages/man2/init_module.2:223
msgid ""
"The binary image supplied in I<module_image> is not an ELF image, or is an "
"ELF image that is invalid or for a different architecture."
msgstr ""

#. type: Plain text
#: man-pages/man2/init_module.2:226
msgid "The following errors may additionally occur for B<finit_module>():"
msgstr ""

#. type: Plain text
#: man-pages/man2/init_module.2:231
msgid "The file referred to by I<fd> is not opened for reading."
msgstr ""

#. type: Plain text
#: man-pages/man2/init_module.2:236
msgid "The file referred to by I<fd> is too large."
msgstr ""

#. type: Plain text
#: man-pages/man2/init_module.2:244
msgid "I<fd> does not refer to an open file."
msgstr ""

#. type: Plain text
#: man-pages/man2/init_module.2:256
msgid ""
"In addition to the above errors, if the module's I<init> function is "
"executed and returns an error, then B<init_module>()  or B<finit_module>()  "
"fails and I<errno> is set to the value returned by the I<init> function."
msgstr ""

#. type: Plain text
#: man-pages/man2/init_module.2:259
msgid "B<finit_module>()  is available since Linux 3.8."
msgstr ""

#. type: Plain text
#: man-pages/man2/init_module.2:264
msgid "B<init_module>()  and B<finit_module>()  are Linux-specific."
msgstr ""

#. type: Plain text
#: man-pages/man2/init_module.2:275
msgid ""
"The B<init_module>()  system call is not supported by glibc.  No declaration "
"is provided in glibc headers, but, through a quirk of history, glibc "
"versions before 2.23 did export an ABI for this system call.  Therefore, in "
"order to employ this system call, it is (before glibc 2.23) sufficient to "
"manually declare the interface in your code; alternatively, you can invoke "
"the system call using B<syscall>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/init_module.2:280
msgid ""
"Glibc does not provide a wrapper for B<finit_module>(); call it using "
"B<syscall>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/init_module.2:285
msgid ""
"Information about currently loaded modules can be found in I</proc/modules> "
"and in the file trees under the per-module subdirectories under "
"I</sys/module>."
msgstr ""

#. type: Plain text
#: man-pages/man2/init_module.2:289
msgid ""
"See the Linux kernel source file I<include/linux/module.h> for some useful "
"background information."
msgstr ""

#. type: Plain text
#: man-pages/man2/init_module.2:294
msgid ""
"In Linux 2.4 and earlier, the B<init_module>()  system call was rather "
"different:"
msgstr ""

#. type: Plain text
#: man-pages/man2/init_module.2:296
msgid "B<#include E<lt>linux/module.hE<gt>>"
msgstr ""

#. type: Plain text
#: man-pages/man2/init_module.2:298
msgid "B< int init_module(const char *>I<name>B<, struct module *>I<image>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/init_module.2:306
msgid ""
"(User-space applications can detect which version of B<init_module>()  is "
"available by calling B<query_module>(); the latter call fails with the error "
"B<ENOSYS> on Linux 2.6 and later.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/init_module.2:317
msgid ""
"The older version of the system call loads the relocated module image "
"pointed to by I<image> into kernel space and runs the module's I<init> "
"function.  The caller is responsible for providing the relocated image "
"(since Linux 2.6, the B<init_module>()  system call does the relocation)."
msgstr ""

#. type: Plain text
#: man-pages/man2/init_module.2:321
msgid ""
"The module image begins with a module structure and is followed by code and "
"data as appropriate.  Since Linux 2.2, the module structure is defined as "
"follows:"
msgstr ""

#. type: Plain text
#: man-pages/man2/init_module.2:344
#, no-wrap
msgid ""
"struct module {\n"
"    unsigned long         size_of_struct;\n"
"    struct module        *next;\n"
"    const char           *name;\n"
"    unsigned long         size;\n"
"    long                  usecount;\n"
"    unsigned long         flags;\n"
"    unsigned int          nsyms;\n"
"    unsigned int          ndeps;\n"
"    struct module_symbol *syms;\n"
"    struct module_ref    *deps;\n"
"    struct module_ref    *refs;\n"
"    int                 (*init)(void);\n"
"    void                (*cleanup)(void);\n"
"    const struct exception_table_entry *ex_table_start;\n"
"    const struct exception_table_entry *ex_table_end;\n"
"#ifdef __alpha__\n"
"    unsigned long gp;\n"
"#endif\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/init_module.2:354
msgid ""
"All of the pointer fields, with the exception of I<next> and I<refs>, are "
"expected to point within the module body and be initialized as appropriate "
"for kernel space, that is, relocated with the rest of the module."
msgstr ""

#. type: Plain text
#: man-pages/man2/init_module.2:359
msgid ""
"B<create_module>(2), B<delete_module>(2), B<query_module>(2), B<lsmod>(8), "
"B<modprobe>(8)"
msgstr ""

#. type: TH
#: man-pages/man2/gethostname.2:32
#, no-wrap
msgid "GETHOSTNAME"
msgstr ""

#. type: Plain text
#: man-pages/man2/gethostname.2:35
msgid "gethostname, sethostname - get/set hostname"
msgstr ""

#. type: Plain text
#: man-pages/man2/gethostname.2:39
msgid "B<int gethostname(char *>I<name>B<, size_t >I<len>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/gethostname.2:41
msgid "B<int sethostname(const char *>I<name>B<, size_t >I<len>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/gethostname.2:50
msgid "B<gethostname>():"
msgstr ""

#. type: Plain text
#: man-pages/man2/gethostname.2:53
msgid "Since glibc 2.12: _BSD_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 500"
msgstr ""

#. type: Plain text
#: man-pages/man2/gethostname.2:55
msgid "|| /* Since glibc 2.12: */ _POSIX_C_SOURCE\\ E<gt>=\\ 200112L"
msgstr ""

#. type: Plain text
#: man-pages/man2/gethostname.2:58
msgid "B<sethostname>():"
msgstr ""

#. type: Plain text
#: man-pages/man2/gethostname.2:73
msgid ""
"These system calls are used to access or to change the system hostname.  "
"More precisely, they operate on the hostname associated with the calling "
"process's UTS namespace."
msgstr ""

#. type: Plain text
#: man-pages/man2/gethostname.2:84
msgid ""
"B<sethostname>()  sets the hostname to the value given in the character "
"array I<name>.  The I<len> argument specifies the number of bytes in "
"I<name>.  (Thus, I<name> does not require a terminating null byte.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/gethostname.2:96
msgid ""
"B<gethostname>()  returns the null-terminated hostname in the character "
"array I<name>, which has a length of I<len> bytes.  If the null-terminated "
"hostname is too large to fit, then the name is truncated, and no error is "
"returned (but see NOTES below).  POSIX.1 says that if such truncation "
"occurs, then it is unspecified whether the returned buffer includes a "
"terminating null byte."
msgstr ""

#. type: Plain text
#: man-pages/man2/gethostname.2:106
msgid "I<name> is an invalid address."
msgstr ""

#.  Can't occur for gethostbyname() wrapper, since 'len' has an
#.  unsigned type; can occur for the underlying system call.
#. type: Plain text
#: man-pages/man2/gethostname.2:116
msgid ""
"I<len> is negative or, for B<sethostname>(), I<len> is larger than the "
"maximum allowed size."
msgstr ""

#. type: Plain text
#: man-pages/man2/gethostname.2:124
msgid ""
"(glibc B<gethostname>())  I<len> is smaller than the actual size.  (Before "
"version 2.1, glibc uses B<EINVAL> for this case.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/gethostname.2:132
msgid ""
"For B<sethostname>(), the caller did not have the B<CAP_SYS_ADMIN> "
"capability in the user namespace associated with its UTS namespace (see "
"B<namespaces>(7))."
msgstr ""

#. type: Plain text
#: man-pages/man2/gethostname.2:138
msgid ""
"SVr4, 4.4BSD (these interfaces first appeared in 4.2BSD).  POSIX.1-2001 and "
"POSIX.1-2008 specify B<gethostname>()  but not B<sethostname>()."
msgstr ""

#. type: Plain text
#: man-pages/man2/gethostname.2:148
msgid ""
"SUSv2 guarantees that \"Host names are limited to 255 bytes\".  POSIX.1 "
"guarantees that \"Host names (not including the terminating null byte) are "
"limited to B<HOST_NAME_MAX> bytes\".  On Linux, B<HOST_NAME_MAX> is defined "
"with the value 64, which has been the limit since Linux 1.0 (earlier kernels "
"imposed a limit of 8 bytes)."
msgstr ""

#. type: Plain text
#: man-pages/man2/gethostname.2:171
msgid ""
"The GNU C library does not employ the B<gethostname>()  system call; "
"instead, it implements B<gethostname>()  as a library function that calls "
"B<uname>(2)  and copies up to I<len> bytes from the returned I<nodename> "
"field into I<name>.  Having performed the copy, the function then checks if "
"the length of the I<nodename> was greater than or equal to I<len>, and if it "
"is, then the function returns -1 with I<errno> set to B<ENAMETOOLONG>; in "
"this case, a terminating null byte is not included in the returned I<name>."
msgstr ""

#.  At least glibc 2.0 and 2.1, older versions not checked
#. type: Plain text
#: man-pages/man2/gethostname.2:184
msgid ""
"Versions of glibc before 2.2 handle the case where the length of the "
"I<nodename> was greater than or equal to I<len> differently: nothing is "
"copied into I<name> and the function returns -1 with I<errno> set to "
"B<ENAMETOOLONG>."
msgstr ""

#. type: Plain text
#: man-pages/man2/gethostname.2:189
msgid ""
"B<hostname>(1), B<getdomainname>(2), B<setdomainname>(2), B<uname>(2), "
"B<uts_namespaces>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/userfaultfd.2:27
#, no-wrap
msgid "USERFAULTFD"
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:30
msgid ""
"userfaultfd - create a file descriptor for handling page faults in user "
"space"
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:34
#, no-wrap
msgid ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>linux/userfaultfd.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:36
#, no-wrap
msgid "B<int userfaultfd(int >I<flags>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:47
msgid ""
"B<userfaultfd>()  creates a new userfaultfd object that can be used for "
"delegation of page-fault handling to a user-space application, and returns a "
"file descriptor that refers to the new object.  The new userfaultfd object "
"is configured using B<ioctl>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:56
msgid ""
"Once the userfaultfd object is configured, the application can use "
"B<read>(2)  to receive userfaultfd notifications.  The reads from "
"userfaultfd may be blocking or non-blocking, depending on the value of "
"I<flags> used for the creation of the userfaultfd or subsequent calls to "
"B<fcntl>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:61
msgid ""
"The following values may be bitwise ORed in I<flags> to change the behavior "
"of B<userfaultfd>():"
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:68
msgid ""
"Enable the close-on-exec flag for the new userfaultfd file descriptor.  See "
"the description of the B<O_CLOEXEC> flag in B<open>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:75
msgid ""
"Enables non-blocking operation for the userfaultfd object.  See the "
"description of the B<O_NONBLOCK> flag in B<open>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:80
msgid ""
"When the last file descriptor referring to a userfaultfd object is closed, "
"all memory ranges that were registered with the object are unregistered and "
"unread events are flushed."
msgstr ""

#. type: SS
#: man-pages/man2/userfaultfd.2:80
#, no-wrap
msgid "Usage"
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:92
msgid ""
"The userfaultfd mechanism is designed to allow a thread in a multithreaded "
"program to perform user-space paging for the other threads in the process.  "
"When a page fault occurs for one of the regions registered to the "
"userfaultfd object, the faulting thread is put to sleep and an event is "
"generated that can be read via the userfaultfd file descriptor.  The "
"fault-handling thread reads events from this file descriptor and services "
"them using the operations described in B<ioctl_userfaultfd>(2).  When "
"servicing the page fault events, the fault-handling thread can trigger a "
"wake-up for the sleeping thread."
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:102
msgid ""
"It is possible for the faulting threads and the fault-handling threads to "
"run in the context of different processes.  In this case, these threads may "
"belong to different programs, and the program that executes the faulting "
"threads will not necessarily cooperate with the program that handles the "
"page faults.  In such non-cooperative mode, the process that monitors "
"userfaultfd and handles page faults needs to be aware of the changes in the "
"virtual memory layout of the faulting process to avoid memory corruption."
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:126
msgid ""
"Starting from Linux 4.11, userfaultfd can also notify the fault-handling "
"threads about changes in the virtual memory layout of the faulting process.  "
"In addition, if the faulting process invokes B<fork>(2), the userfaultfd "
"objects associated with the parent may be duplicated into the child process "
"and the userfaultfd monitor will be notified (via the B<UFFD_EVENT_FORK> "
"described below)  about the file descriptor associated with the userfault "
"objects created for the child process, which allows the userfaultfd monitor "
"to perform user-space paging for the child process.  Unlike page faults "
"which have to be synchronous and require an explicit or implicit wakeup, all "
"other events are delivered asynchronously and the non-cooperative process "
"resumes execution as soon as the userfaultfd manager executes B<read>(2).  "
"The userfaultfd manager should carefully synchronize calls to B<UFFDIO_COPY> "
"with the processing of events."
msgstr ""

#.  Regarding the preceding sentence, Mike Rapoport says:
#.      The major point here is that current events delivery model could be
#.      problematic for multi-threaded monitor. I even suspect that it would be
#.      impossible to ensure synchronization between page faults and non-page
#.      fault events in multi-threaded monitor.
#. type: Plain text
#: man-pages/man2/userfaultfd.2:134
msgid ""
"The current asynchronous model of the event delivery is optimal for single "
"threaded non-cooperative userfaultfd manager implementations."
msgstr ""

#.  FIXME elaborate about non-cooperating mode, describe its limitations
#.  for kernels before 4.11, features added in 4.11
#.  and limitations remaining in 4.11
#.  Maybe it's worth adding a dedicated sub-section...
#. type: SS
#: man-pages/man2/userfaultfd.2:140
#, no-wrap
msgid "Userfaultfd operation"
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:154
msgid ""
"After the userfaultfd object is created with B<userfaultfd>(), the "
"application must enable it using the B<UFFDIO_API> B<ioctl>(2)  operation.  "
"This operation allows a handshake between the kernel and user space to "
"determine the API version and supported features.  This operation must be "
"performed before any of the other B<ioctl>(2)  operations described below "
"(or those operations fail with the B<EINVAL> error)."
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:174
msgid ""
"After a successful B<UFFDIO_API> operation, the application then registers "
"memory address ranges using the B<UFFDIO_REGISTER> B<ioctl>(2)  operation.  "
"After successful completion of a B<UFFDIO_REGISTER> operation, a page fault "
"occurring in the requested memory range, and satisfying the mode defined at "
"the registration time, will be forwarded by the kernel to the user-space "
"application.  The application can then use the B<UFFDIO_COPY> or "
"B<UFFDIO_ZEROPAGE> B<ioctl>(2)  operations to resolve the page fault."
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:193
msgid ""
"Starting from Linux 4.14, if the application sets the B<UFFD_FEATURE_SIGBUS> "
"feature bit using the B<UFFDIO_API> B<ioctl>(2), no page-fault notification "
"will be forwarded to user space.  Instead a B<SIGBUS> signal is delivered to "
"the faulting process.  With this feature, userfaultfd can be used for "
"robustness purposes to simply catch any access to areas within the "
"registered address range that do not have pages allocated, without having to "
"listen to userfaultfd events.  No userfaultfd monitor will be required for "
"dealing with such memory accesses.  For example, this feature can be useful "
"for applications that want to prevent the kernel from automatically "
"allocating pages and filling holes in sparse files when the hole is accessed "
"through a memory mapping."
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:200
msgid ""
"The B<UFFD_FEATURE_SIGBUS> feature is implicitly inherited through "
"B<fork>(2)  if used in combination with B<UFFD_FEATURE_FORK>."
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:205
msgid ""
"Details of the various B<ioctl>(2)  operations can be found in "
"B<ioctl_userfaultfd>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:209
msgid ""
"Since Linux 4.11, events other than page-fault may enabled during "
"B<UFFDIO_API> operation."
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:214
msgid ""
"Up to Linux 4.11, userfaultfd can be used only with anonymous private memory "
"mappings.  Since Linux 4.11, userfaultfd can be also used with hugetlbfs and "
"shared memory mappings."
msgstr ""

#. type: SS
#: man-pages/man2/userfaultfd.2:216
#, no-wrap
msgid "Reading from the userfaultfd structure"
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:223
msgid ""
"Each B<read>(2)  from the userfaultfd file descriptor returns one or more "
"I<uffd_msg> structures, each of which describes a page-fault event or an "
"event required for the non-cooperative userfaultfd usage:"
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:234
#, no-wrap
msgid ""
"struct uffd_msg {\n"
"    __u8  event;            /* Type of event */\n"
"    ...\n"
"    union {\n"
"        struct {\n"
"            __u64 flags;    /* Flags describing fault */\n"
"            __u64 address;  /* Faulting address */\n"
"        } pagefault;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:239
#, no-wrap
msgid ""
"        struct {            /* Since Linux 4.11 */\n"
"            __u32 ufd;      /* Userfault file descriptor\n"
"                               of the child process */\n"
"        } fork;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:245
#, no-wrap
msgid ""
"        struct {            /* Since Linux 4.11 */\n"
"            __u64 from;     /* Old address of remapped area */\n"
"            __u64 to;       /* New address of remapped area */\n"
"            __u64 len;      /* Original mapping length */\n"
"        } remap;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:252
#, no-wrap
msgid ""
"        struct {            /* Since Linux 4.11 */\n"
"            __u64 start;    /* Start address of removed area */\n"
"            __u64 end;      /* End address of removed area */\n"
"        } remove;\n"
"        ...\n"
"    } arg;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:255
#, no-wrap
msgid ""
"    /* Padding fields omitted */\n"
"} __packed;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:269
msgid ""
"If multiple events are available and the supplied buffer is large enough, "
"B<read>(2)  returns as many events as will fit in the supplied buffer.  If "
"the buffer supplied to B<read>(2)  is smaller than the size of the "
"I<uffd_msg> structure, the B<read>(2)  fails with the error B<EINVAL>."
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:273
msgid "The fields set in the I<uffd_msg> structure are as follows:"
msgstr ""

#. type: TP
#: man-pages/man2/userfaultfd.2:273
#, no-wrap
msgid "I<event>"
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:284
msgid ""
"The type of event.  Depending of the event type, different fields of the "
"I<arg> union represent details required for the event processing.  The "
"non-page-fault events are generated only when appropriate feature is enabled "
"during API handshake with B<UFFDIO_API> B<ioctl>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:288
msgid "The following values can appear in the I<event> field:"
msgstr ""

#. type: TP
#: man-pages/man2/userfaultfd.2:289
#, no-wrap
msgid "B<UFFD_EVENT_PAGEFAULT> (since Linux 4.3)"
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:295
msgid ""
"A page-fault event.  The page-fault details are available in the "
"I<pagefault> field."
msgstr ""

#. type: TP
#: man-pages/man2/userfaultfd.2:295
#, no-wrap
msgid "B<UFFD_EVENT_FORK> (since Linux 4.11)"
msgstr ""

#.  FIXME describe duplication of userfault file descriptor during fork
#. type: Plain text
#: man-pages/man2/userfaultfd.2:308
msgid ""
"Generated when the faulting process invokes B<fork>(2)  (or B<clone>(2)  "
"without the B<CLONE_VM> flag).  The event details are available in the "
"I<fork> field."
msgstr ""

#. type: TP
#: man-pages/man2/userfaultfd.2:308
#, no-wrap
msgid "B<UFFD_EVENT_REMAP> (since Linux 4.11)"
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:315
msgid ""
"Generated when the faulting process invokes B<mremap>(2).  The event details "
"are available in the I<remap> field."
msgstr ""

#. type: TP
#: man-pages/man2/userfaultfd.2:315
#, no-wrap
msgid "B<UFFD_EVENT_REMOVE> (since Linux 4.11)"
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:327
msgid ""
"Generated when the faulting process invokes B<madvise>(2)  with "
"B<MADV_DONTNEED> or B<MADV_REMOVE> advice.  The event details are available "
"in the I<remove> field."
msgstr ""

#. type: TP
#: man-pages/man2/userfaultfd.2:327
#, no-wrap
msgid "B<UFFD_EVENT_UNMAP> (since Linux 4.11)"
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:339
msgid ""
"Generated when the faulting process unmaps a memory range, either explicitly "
"using B<munmap>(2)  or implicitly during B<mmap>(2)  or B<mremap>(2).  The "
"event details are available in the I<remove> field."
msgstr ""

#. type: TP
#: man-pages/man2/userfaultfd.2:340
#, no-wrap
msgid "I<pagefault.address>"
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:343
msgid "The address that triggered the page fault."
msgstr ""

#. type: TP
#: man-pages/man2/userfaultfd.2:343
#, no-wrap
msgid "I<pagefault.flags>"
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:349
msgid ""
"A bit mask of flags that describe the event.  For B<UFFD_EVENT_PAGEFAULT>, "
"the following flag may appear:"
msgstr ""

#. type: TP
#: man-pages/man2/userfaultfd.2:350
#, no-wrap
msgid "B<UFFD_PAGEFAULT_FLAG_WRITE>"
msgstr ""

#
#.  UFFD_PAGEFAULT_FLAG_WP is not yet supported.
#. type: Plain text
#: man-pages/man2/userfaultfd.2:360
msgid ""
"If the address is in a range that was registered with the "
"B<UFFDIO_REGISTER_MODE_MISSING> flag (see B<ioctl_userfaultfd>(2))  and this "
"flag is set, this a write fault; otherwise it is a read fault."
msgstr ""

#. type: TP
#: man-pages/man2/userfaultfd.2:361
#, no-wrap
msgid "I<fork.ufd>"
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:366
msgid ""
"The file descriptor associated with the userfault object created for the "
"child created by B<fork>(2)."
msgstr ""

#. type: TP
#: man-pages/man2/userfaultfd.2:366
#, no-wrap
msgid "I<remap.from>"
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:370
msgid ""
"The original address of the memory range that was remapped using "
"B<mremap>(2)."
msgstr ""

#. type: TP
#: man-pages/man2/userfaultfd.2:370
#, no-wrap
msgid "I<remap.to>"
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:374
msgid "The new address of the memory range that was remapped using B<mremap>(2)."
msgstr ""

#. type: TP
#: man-pages/man2/userfaultfd.2:374
#, no-wrap
msgid "I<remap.len>"
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:378
msgid ""
"The original length of the memory range that was remapped using "
"B<mremap>(2)."
msgstr ""

#. type: TP
#: man-pages/man2/userfaultfd.2:378
#, no-wrap
msgid "I<remove.start>"
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:383
msgid ""
"The start address of the memory range that was freed using B<madvise>(2)  or "
"unmapped"
msgstr ""

#. type: TP
#: man-pages/man2/userfaultfd.2:383
#, no-wrap
msgid "I<remove.end>"
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:388
msgid ""
"The end address of the memory range that was freed using B<madvise>(2)  or "
"unmapped"
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:392
msgid ""
"A B<read>(2)  on a userfaultfd file descriptor can fail with the following "
"errors:"
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:398
msgid ""
"The userfaultfd object has not yet been enabled using the B<UFFDIO_API> "
"B<ioctl>(2)  operation"
msgstr ""

#.  FIXME What is the reason for this seemingly odd behavior with respect
#.  to the O_NONBLOCK flag? (see userfaultfd_poll() in fs/userfaultfd.c).
#.  Something needs to be said about this.
#. type: Plain text
#: man-pages/man2/userfaultfd.2:420
msgid ""
"If the B<O_NONBLOCK> flag is enabled in the associated open file "
"description, the userfaultfd file descriptor can be monitored with "
"B<poll>(2), B<select>(2), and B<epoll>(7).  When events are available, the "
"file descriptor indicates as readable.  If the B<O_NONBLOCK> flag is not "
"enabled, then B<poll>(2)  (always) indicates the file as having a B<POLLERR> "
"condition, and B<select>(2)  indicates the file descriptor as both readable "
"and writable."
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:427
msgid ""
"On success, B<userfaultfd>()  returns a new file descriptor that refers to "
"the userfaultfd object.  On error, -1 is returned, and I<errno> is set "
"appropriately."
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:436
msgid ""
"The per-process limit on the number of open file descriptors has been "
"reached"
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:447
msgid "The B<userfaultfd>()  system call first appeared in Linux 4.3."
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:450
msgid ""
"The support for hugetlbfs and shared memory areas and non-page-fault events "
"was added in Linux 4.11"
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:454
msgid ""
"B<userfaultfd>()  is Linux-specific and should not be used in programs "
"intended to be portable."
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:468
msgid ""
"The userfaultfd mechanism can be used as an alternative to traditional "
"user-space paging techniques based on the use of the B<SIGSEGV> signal and "
"B<mmap>(2).  It can also be used to implement lazy restore for "
"checkpoint/restore mechanisms, as well as post-copy migration to allow "
"(nearly) uninterrupted execution when transferring virtual machines and "
"Linux containers from one host to another."
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:478
msgid ""
"If the B<UFFD_FEATURE_EVENT_FORK> is enabled and a system call from the "
"B<fork>(2)  family is interrupted by a signal or failed, a stale userfaultfd "
"descriptor might be created.  In this case, a spurious B<UFFD_EVENT_FORK> "
"will be delivered to the userfaultfd monitor."
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:484
msgid ""
"The program below demonstrates the use of the userfaultfd mechanism.  The "
"program creates two threads, one of which acts as the page-fault handler for "
"the process, for the pages in a demand-page zero region created using "
"B<mmap>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:496
msgid ""
"The program takes one command-line argument, which is the number of pages "
"that will be created in a mapping whose page faults will be handled via "
"userfaultfd.  After creating a userfaultfd object, the program then creates "
"an anonymous private mapping of the specified size and registers the address "
"range of that mapping using the B<UFFDIO_REGISTER> B<ioctl>(2)  operation.  "
"The program then creates a second thread that will perform the task of "
"handling page faults."
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:502
msgid ""
"The main thread then walks through the pages of the mapping fetching bytes "
"from successive pages.  Because the pages have not yet been accessed, the "
"first access of a byte in each page will trigger a page-fault event on the "
"userfaultfd file descriptor."
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:517
msgid ""
"Each of the page-fault events is handled by the second thread, which sits in "
"a loop processing input from the userfaultfd file descriptor.  In each loop "
"iteration, the second thread first calls B<poll>(2)  to check the state of "
"the file descriptor, and then reads an event from the file descriptor.  All "
"such events should be B<UFFD_EVENT_PAGEFAULT> events, which the thread "
"handles by copying a page of data into the faulting region using the "
"B<UFFDIO_COPY> B<ioctl>(2)  operation."
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:519
msgid "The following is an example of what we see when running the program:"
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:524
#, no-wrap
msgid ""
"$ B<./userfaultfd_demo 3>\n"
"Address returned by mmap() = 0x7fd30106c000\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:533
#, no-wrap
msgid ""
"fault_handler_thread():\n"
"    poll() returns: nready = 1; POLLIN = 1; POLLERR = 0\n"
"    UFFD_EVENT_PAGEFAULT event: flags = 0; address = 7fd30106c00f\n"
"        (uffdio_copy.copy returned 4096)\n"
"Read address 0x7fd30106c00f in main(): A\n"
"Read address 0x7fd30106c40f in main(): A\n"
"Read address 0x7fd30106c80f in main(): A\n"
"Read address 0x7fd30106cc0f in main(): A\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:542
#, no-wrap
msgid ""
"fault_handler_thread():\n"
"    poll() returns: nready = 1; POLLIN = 1; POLLERR = 0\n"
"    UFFD_EVENT_PAGEFAULT event: flags = 0; address = 7fd30106d00f\n"
"        (uffdio_copy.copy returned 4096)\n"
"Read address 0x7fd30106d00f in main(): B\n"
"Read address 0x7fd30106d40f in main(): B\n"
"Read address 0x7fd30106d80f in main(): B\n"
"Read address 0x7fd30106dc0f in main(): B\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:551
#, no-wrap
msgid ""
"fault_handler_thread():\n"
"    poll() returns: nready = 1; POLLIN = 1; POLLERR = 0\n"
"    UFFD_EVENT_PAGEFAULT event: flags = 0; address = 7fd30106e00f\n"
"        (uffdio_copy.copy returned 4096)\n"
"Read address 0x7fd30106e00f in main(): C\n"
"Read address 0x7fd30106e40f in main(): C\n"
"Read address 0x7fd30106e80f in main(): C\n"
"Read address 0x7fd30106ec0f in main(): C\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:557
#, no-wrap
msgid "/* userfaultfd_demo.c\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:576
#, no-wrap
msgid ""
"   Licensed under the GNU General Public License version 2 or later.\n"
"*/\n"
"#define _GNU_SOURCE\n"
"#include E<lt>sys/types.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>linux/userfaultfd.hE<gt>\n"
"#include E<lt>pthread.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>fcntl.hE<gt>\n"
"#include E<lt>signal.hE<gt>\n"
"#include E<lt>poll.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>sys/mman.hE<gt>\n"
"#include E<lt>sys/syscall.hE<gt>\n"
"#include E<lt>sys/ioctl.hE<gt>\n"
"#include E<lt>poll.hE<gt>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:581
#, no-wrap
msgid "static int page_size;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:591
#, no-wrap
msgid ""
"static void *\n"
"fault_handler_thread(void *arg)\n"
"{\n"
"    static struct uffd_msg msg;   /* Data read from userfaultfd */\n"
"    static int fault_cnt = 0;     /* Number of faults so far handled */\n"
"    long uffd;                    /* userfaultfd file descriptor */\n"
"    static char *page = NULL;\n"
"    struct uffdio_copy uffdio_copy;\n"
"    ssize_t nread;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:593
#, no-wrap
msgid "    uffd = (long) arg;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:595
#, no-wrap
msgid "    /* Create a page that will be copied into the faulting region */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:602
#, no-wrap
msgid ""
"    if (page == NULL) {\n"
"        page = mmap(NULL, page_size, PROT_READ | PROT_WRITE,\n"
"                    MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n"
"        if (page == MAP_FAILED)\n"
"            errExit(\"mmap\");\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:605
#, no-wrap
msgid ""
"    /* Loop, handling incoming events on the userfaultfd\n"
"       file descriptor */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:609
#, no-wrap
msgid "        /* See what poll() tells us about the userfaultfd */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:617
#, no-wrap
msgid ""
"        struct pollfd pollfd;\n"
"        int nready;\n"
"        pollfd.fd = uffd;\n"
"        pollfd.events = POLLIN;\n"
"        nready = poll(&pollfd, 1, -1);\n"
"        if (nready == -1)\n"
"            errExit(\"poll\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:623
#, no-wrap
msgid ""
"        printf(\"\\enfault_handler_thread():\\en\");\n"
"        printf(\"    poll() returns: nready = %d; \"\n"
"                \"POLLIN = %d; POLLERR = %d\\en\", nready,\n"
"                (pollfd.revents & POLLIN) != 0,\n"
"                (pollfd.revents & POLLERR) != 0);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:625
#, no-wrap
msgid "        /* Read an event from the userfaultfd */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:631
#, no-wrap
msgid ""
"        nread = read(uffd, &msg, sizeof(msg));\n"
"        if (nread == 0) {\n"
"            printf(\"EOF on userfaultfd!\\en\");\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:634
#, no-wrap
msgid ""
"        if (nread == -1)\n"
"            errExit(\"read\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:636
#, no-wrap
msgid "        /* We expect only one kind of event; verify that assumption */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:641
#, no-wrap
msgid ""
"        if (msg.event != UFFD_EVENT_PAGEFAULT) {\n"
"            fprintf(stderr, \"Unexpected event on userfaultfd\\en\");\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:643
#, no-wrap
msgid "        /* Display info about the page-fault event */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:647
#, no-wrap
msgid ""
"        printf(\"    UFFD_EVENT_PAGEFAULT event: \");\n"
"        printf(\"flags = %llx; \", msg.arg.pagefault.flags);\n"
"        printf(\"address = %llx\\en\", msg.arg.pagefault.address);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:651
#, no-wrap
msgid ""
"        /* Copy the page pointed to by \\(aqpage\\(aq into the faulting\n"
"           region. Vary the contents that are copied in, so that it\n"
"           is more obvious that each fault is handled separately. */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:654
#, no-wrap
msgid ""
"        memset(page, \\(aqA\\(aq + fault_cnt % 20, page_size);\n"
"        fault_cnt++;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:656
#, no-wrap
msgid "        uffdio_copy.src = (unsigned long) page;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:659
#, no-wrap
msgid ""
"        /* We need to handle page faults in units of pages(!).\n"
"           So, round faulting address down to page boundary */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:667
#, no-wrap
msgid ""
"        uffdio_copy.dst = (unsigned long) msg.arg.pagefault.address &\n"
"                                           ~(page_size - 1);\n"
"        uffdio_copy.len = page_size;\n"
"        uffdio_copy.mode = 0;\n"
"        uffdio_copy.copy = 0;\n"
"        if (ioctl(uffd, UFFDIO_COPY, &uffdio_copy) == -1)\n"
"            errExit(\"ioctl-UFFDIO_COPY\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:672
#, no-wrap
msgid ""
"        printf(\"        (uffdio_copy.copy returned %lld)\\en\",\n"
"                uffdio_copy.copy);\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:683
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    long uffd;          /* userfaultfd file descriptor */\n"
"    char *addr;         /* Start of region handled by userfaultfd */\n"
"    unsigned long len;  /* Length of region handled by userfaultfd */\n"
"    pthread_t thr;      /* ID of thread that handles page faults */\n"
"    struct uffdio_api uffdio_api;\n"
"    struct uffdio_register uffdio_register;\n"
"    int s;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:688
#, no-wrap
msgid ""
"    if (argc != 2) {\n"
"        fprintf(stderr, \"Usage: %s num-pages\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:691
#, no-wrap
msgid ""
"    page_size = sysconf(_SC_PAGE_SIZE);\n"
"    len = strtoul(argv[1], NULL, 0) * page_size;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:693
#, no-wrap
msgid "    /* Create and enable userfaultfd object */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:697
#, no-wrap
msgid ""
"    uffd = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);\n"
"    if (uffd == -1)\n"
"        errExit(\"userfaultfd\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:702
#, no-wrap
msgid ""
"    uffdio_api.api = UFFD_API;\n"
"    uffdio_api.features = 0;\n"
"    if (ioctl(uffd, UFFDIO_API, &uffdio_api) == -1)\n"
"        errExit(\"ioctl-UFFDIO_API\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:707
#, no-wrap
msgid ""
"    /* Create a private anonymous mapping. The memory will be\n"
"       demand-zero paged--that is, not yet allocated. When we\n"
"       actually touch the memory, it will be allocated via\n"
"       the userfaultfd. */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:712
#, no-wrap
msgid ""
"    addr = mmap(NULL, len, PROT_READ | PROT_WRITE,\n"
"                MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n"
"    if (addr == MAP_FAILED)\n"
"        errExit(\"mmap\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:714
#, no-wrap
msgid "    printf(\"Address returned by mmap() = %p\\en\", addr);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:718
#, no-wrap
msgid ""
"    /* Register the memory range of the mapping we just created for\n"
"       handling by the userfaultfd object. In mode, we request to track\n"
"       missing pages (i.e., pages that have not yet been faulted in). */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:724
#, no-wrap
msgid ""
"    uffdio_register.range.start = (unsigned long) addr;\n"
"    uffdio_register.range.len = len;\n"
"    uffdio_register.mode = UFFDIO_REGISTER_MODE_MISSING;\n"
"    if (ioctl(uffd, UFFDIO_REGISTER, &uffdio_register) == -1)\n"
"        errExit(\"ioctl-UFFDIO_REGISTER\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:726
#, no-wrap
msgid "    /* Create a thread that will process the userfaultfd events */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:732
#, no-wrap
msgid ""
"    s = pthread_create(&thr, NULL, fault_handler_thread, (void *) uffd);\n"
"    if (s != 0) {\n"
"        errno = s;\n"
"        errExit(\"pthread_create\");\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:736
#, no-wrap
msgid ""
"    /* Main thread now touches memory in the mapping, touching\n"
"       locations 1024 bytes apart. This will trigger userfaultfd\n"
"       events for all pages in the region. */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:748
#, no-wrap
msgid ""
"    int l;\n"
"    l = 0xf;    /* Ensure that faulting address is not on a page\n"
"                   boundary, in order to test that we correctly\n"
"                   handle that case in fault_handling_thread() */\n"
"    while (l E<lt> len) {\n"
"        char c = addr[l];\n"
"        printf(\"Read address %p in main(): \", addr + l);\n"
"        printf(\"%c\\en\", c);\n"
"        l += 1024;\n"
"        usleep(100000);         /* Slow things down a little */\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/userfaultfd.2:758
msgid "B<fcntl>(2), B<ioctl>(2), B<ioctl_userfaultfd>(2), B<madvise>(2), B<mmap>(2)"
msgstr ""

#. type: TH
#: man-pages/man2/perfmonctl.2:27
#, no-wrap
msgid "PERFMONCTL"
msgstr ""

#. type: Plain text
#: man-pages/man2/perfmonctl.2:30
msgid "perfmonctl - interface to IA-64 performance monitoring unit"
msgstr ""

#. type: Plain text
#: man-pages/man2/perfmonctl.2:34
#, no-wrap
msgid ""
"B<#include E<lt>syscall.hE<gt>>\n"
"B<#include E<lt>perfmon.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/perfmonctl.2:36
#, no-wrap
msgid ""
"B<long perfmonctl(int >I<fd>B<, int >I<cmd>B<, void *>I<arg>B<, int "
">I<narg>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/perfmonctl.2:47
msgid ""
"The IA-64-specific B<perfmonctl>()  system call provides an interface to the "
"PMU (performance monitoring unit).  The PMU consists of PMD (performance "
"monitoring data) registers and PMC (performance monitoring control) "
"registers, which gather hardware statistics."
msgstr ""

#. type: Plain text
#: man-pages/man2/perfmonctl.2:57
msgid ""
"B<perfmonctl>()  applies the operation I<cmd> to the input arguments "
"specified by I<arg>.  The number of arguments is defined by I<narg>.  The "
"I<fd> argument specifies the perfmon context to operate on."
msgstr ""

#. type: Plain text
#: man-pages/man2/perfmonctl.2:61
msgid "Supported values for I<cmd> are:"
msgstr ""

#. type: TP
#: man-pages/man2/perfmonctl.2:61
#, no-wrap
msgid "B<PFM_CREATE_CONTEXT>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perfmonctl.2:65
#, no-wrap
msgid ""
"B<perfmonctl(int >I<fd>B<, PFM_CREATE_CONTEXT, pfarg_context_t *>I<ctxt>B<, "
"1);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/perfmonctl.2:67
msgid "Set up a context."
msgstr ""

#. type: Plain text
#: man-pages/man2/perfmonctl.2:74
msgid ""
"The I<fd> parameter is ignored.  A new perfmon context is created as "
"specified in I<ctxt> and its file descriptor is returned in "
"I<ctxt-E<gt>ctx_fd>."
msgstr ""

#. type: Plain text
#: man-pages/man2/perfmonctl.2:86
msgid ""
"The file descriptor can be used in subsequent calls to B<perfmonctl>()  and "
"can be used to read event notifications (type I<pfm_msg_t>)  using "
"B<read>(2).  The file descriptor is pollable using B<select>(2), B<poll>(2), "
"and B<epoll>(7)."
msgstr ""

#. type: Plain text
#: man-pages/man2/perfmonctl.2:90
msgid "The context can be destroyed by calling B<close>(2)  on the file descriptor."
msgstr ""

#. type: TP
#: man-pages/man2/perfmonctl.2:90
#, no-wrap
msgid "B<PFM_WRITE_PMCS>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perfmonctl.2:95
#, no-wrap
msgid "B<perfmonctl(int >I<fd>B<, PFM_WRITE_PMCS, pfarg_reg_t *>I<pmcs>B<, n);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/perfmonctl.2:97
msgid "Set PMC registers."
msgstr ""

#. type: TP
#: man-pages/man2/perfmonctl.2:97
#, no-wrap
msgid "B<PFM_WRITE_PMDS>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perfmonctl.2:101
#, no-wrap
msgid "B<perfmonctl(int >I<fd>B<, PFM_WRITE_PMDS, pfarg_reg_t *>I<pmds>B<, n);>\n"
msgstr ""

#.  pfm_write_pmds()
#. type: Plain text
#: man-pages/man2/perfmonctl.2:104
msgid "Set PMD registers."
msgstr ""

#. type: TP
#: man-pages/man2/perfmonctl.2:104
#, no-wrap
msgid "B<PFM_READ_PMDS>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perfmonctl.2:109
#, no-wrap
msgid "B<perfmonctl(int >I<fd>B<, PFM_READ_PMDS, pfarg_reg_t *>I<pmds>B<, n);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/perfmonctl.2:111
msgid "Read PMD registers."
msgstr ""

#. type: TP
#: man-pages/man2/perfmonctl.2:111
#, no-wrap
msgid "B<PFM_START>"
msgstr ""

#.  .BI  "perfmonctl(int " fd ", PFM_START, arg, 1);
#. type: Plain text
#: man-pages/man2/perfmonctl.2:117
#, no-wrap
msgid "B<perfmonctl(int >I<fd>B<, PFM_START, NULL, 0);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/perfmonctl.2:119
msgid "Start monitoring."
msgstr ""

#. type: TP
#: man-pages/man2/perfmonctl.2:119
#, no-wrap
msgid "B<PFM_STOP>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perfmonctl.2:124
#, no-wrap
msgid "B<perfmonctl(int >I<fd>B<, PFM_STOP, NULL, 0);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/perfmonctl.2:126
msgid "Stop monitoring."
msgstr ""

#. type: TP
#: man-pages/man2/perfmonctl.2:126
#, no-wrap
msgid "B<PFM_LOAD_CONTEXT>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perfmonctl.2:131
#, no-wrap
msgid ""
"B<perfmonctl(int >I<fd>B<, PFM_LOAD_CONTEXT, pfarg_load_t *>I<largs>B<, "
"1);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/perfmonctl.2:133
msgid "Attach the context to a thread."
msgstr ""

#. type: TP
#: man-pages/man2/perfmonctl.2:133
#, no-wrap
msgid "B<PFM_UNLOAD_CONTEXT>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perfmonctl.2:138
#, no-wrap
msgid "B<perfmonctl(int >I<fd>B<, PFM_UNLOAD_CONTEXT, NULL, 0);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/perfmonctl.2:140
msgid "Detach the context from a thread."
msgstr ""

#. type: TP
#: man-pages/man2/perfmonctl.2:140
#, no-wrap
msgid "B<PFM_RESTART>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perfmonctl.2:145
#, no-wrap
msgid "B<perfmonctl(int >I<fd>B<, PFM_RESTART, NULL, 0);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/perfmonctl.2:147
msgid "Restart monitoring after receiving an overflow notification."
msgstr ""

#. type: TP
#: man-pages/man2/perfmonctl.2:147
#, no-wrap
msgid "B<PFM_GET_FEATURES>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perfmonctl.2:152
#, no-wrap
msgid ""
"B<perfmonctl(int >I<fd>B<, PFM_GET_FEATURES, pfarg_features_t *>I<arg>B<, "
"1);>\n"
msgstr ""

#. type: TP
#: man-pages/man2/perfmonctl.2:153
#, no-wrap
msgid "B<PFM_DEBUG>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perfmonctl.2:158
#, no-wrap
msgid "B<perfmonctl(int >I<fd>B<, PFM_DEBUG, >I<val>B<, 0);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/perfmonctl.2:162
msgid "If I<val> is nonzero, enable debugging mode, otherwise disable."
msgstr ""

#. type: TP
#: man-pages/man2/perfmonctl.2:162
#, no-wrap
msgid "B<PFM_GET_PMC_RESET_VAL>"
msgstr ""

#. type: Plain text
#: man-pages/man2/perfmonctl.2:167
#, no-wrap
msgid ""
"B<perfmonctl(int >I<fd>B<, PFM_GET_PMC_RESET_VAL, pfarg_reg_t *>I<req>B<, "
"n);>\n"
msgstr ""

#
#
#.  .TP
#.  .B PFM_CREATE_EVTSETS
#
#.  create or modify event sets
#.  .nf
#.  .BI  "perfmonctl(int " fd ", PFM_CREATE_EVTSETS, pfarg_setdesc_t *desc , n);
#.  .fi
#.  .TP
#.  .B PFM_DELETE_EVTSETS
#.  delete event sets
#.  .nf
#.  .BI  "perfmonctl(int " fd ", PFM_DELETE_EVTSET, pfarg_setdesc_t *desc , n);
#.  .fi
#.  .TP
#.  .B PFM_GETINFO_EVTSETS
#.  get information about event sets
#.  .nf
#.  .BI  "perfmonctl(int " fd ", PFM_GETINFO_EVTSETS, pfarg_setinfo_t *info, n);
#.  .fi
#. type: Plain text
#: man-pages/man2/perfmonctl.2:190
msgid "Reset PMC registers to default values."
msgstr ""

#. type: Plain text
#: man-pages/man2/perfmonctl.2:196
msgid ""
"B<perfmonctl>()  returns zero when the operation is successful.  On error, "
"-1 is returned and I<errno> is set to indicate the cause of the error."
msgstr ""

#. type: Plain text
#: man-pages/man2/perfmonctl.2:199
msgid "B<perfmonctl>()  is available since Linux 2.4."
msgstr ""

#. type: Plain text
#: man-pages/man2/perfmonctl.2:202
msgid ""
"B<perfmonctl>()  is Linux-specific and is available only on the IA-64 "
"architecture."
msgstr ""

#. type: Plain text
#: man-pages/man2/perfmonctl.2:207
msgid "B<gprof>(1)"
msgstr ""

#. type: Plain text
#: man-pages/man2/perfmonctl.2:208
msgid "The perfmon2 interface specification"
msgstr ""

#. type: TH
#: man-pages/man2/stat.2:40
#, no-wrap
msgid "STAT"
msgstr ""

#. type: Plain text
#: man-pages/man2/stat.2:43
msgid "stat, fstat, lstat, fstatat - get file status"
msgstr ""

#. type: Plain text
#: man-pages/man2/stat.2:48
#, no-wrap
msgid ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>sys/stat.hE<gt>>\n"
"B<#include E<lt>unistd.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/stat.2:52
#, no-wrap
msgid ""
"B<int stat(const char *>I<pathname>B<, struct stat *>I<statbuf>B<);>\n"
"B<int fstat(int >I<fd>B<, struct stat *>I<statbuf>B<);>\n"
"B<int lstat(const char *>I<pathname>B<, struct stat *>I<statbuf>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/stat.2:59
#, no-wrap
msgid ""
"B<int fstatat(int >I<dirfd>B<, const char *>I<pathname>B<, struct stat "
"*>I<statbuf>B<,>\n"
"B<            int >I<flags>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/stat.2:68
msgid "B<lstat>():"
msgstr ""

#. type: Plain text
#: man-pages/man2/stat.2:70
msgid "/* glibc 2.19 and earlier */ _BSD_SOURCE"
msgstr ""

#. type: Plain text
#: man-pages/man2/stat.2:72
#, no-wrap
msgid "    || /* Since glibc 2.20 */ _DEFAULT_SOURCE\n"
msgstr ""

#.    _XOPEN_SOURCE\ &&\ _XOPEN_SOURCE_EXTENDED
#. type: Plain text
#: man-pages/man2/stat.2:75
#, no-wrap
msgid "    || _XOPEN_SOURCE\\ E<gt>=\\ 500\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/stat.2:77
#, no-wrap
msgid "    || /* Since glibc 2.10: */ _POSIX_C_SOURCE\\ E<gt>=\\ 200112L\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/stat.2:80
msgid "B<fstatat>():"
msgstr ""

#. type: Plain text
#: man-pages/man2/stat.2:104
msgid ""
"These functions return information about a file, in the buffer pointed to by "
"I<statbuf>.  No permissions are required on the file itself, but\\(emin the "
"case of B<stat>(), B<fstatat>(), and B<lstat>()\\(emexecute (search) "
"permission is required on all of the directories in I<pathname> that lead to "
"the file."
msgstr ""

#. type: Plain text
#: man-pages/man2/stat.2:113
msgid ""
"B<stat>()  and B<fstatat>()  retrieve information about the file pointed to "
"by I<pathname>; the differences for B<fstatat>()  are described below."
msgstr ""

#. type: Plain text
#: man-pages/man2/stat.2:121
msgid ""
"B<lstat>()  is identical to B<stat>(), except that if I<pathname> is a "
"symbolic link, then it returns information about the link itself, not the "
"file that it refers to."
msgstr ""

#. type: Plain text
#: man-pages/man2/stat.2:129
msgid ""
"B<fstat>()  is identical to B<stat>(), except that the file about which "
"information is to be retrieved is specified by the file descriptor I<fd>."
msgstr ""

#. type: SS
#: man-pages/man2/stat.2:129
#, no-wrap
msgid "The stat structure"
msgstr ""

#. type: Plain text
#: man-pages/man2/stat.2:133
msgid ""
"All of these system calls return a I<stat> structure, which contains the "
"following fields:"
msgstr ""

#. type: Plain text
#: man-pages/man2/stat.2:147
#, no-wrap
msgid ""
"struct stat {\n"
"    dev_t     st_dev;         /* ID of device containing file */\n"
"    ino_t     st_ino;         /* Inode number */\n"
"    mode_t    st_mode;        /* File type and mode */\n"
"    nlink_t   st_nlink;       /* Number of hard links */\n"
"    uid_t     st_uid;         /* User ID of owner */\n"
"    gid_t     st_gid;         /* Group ID of owner */\n"
"    dev_t     st_rdev;        /* Device ID (if special file) */\n"
"    off_t     st_size;        /* Total size, in bytes */\n"
"    blksize_t st_blksize;     /* Block size for filesystem I/O */\n"
"    blkcnt_t  st_blocks;      /* Number of 512B blocks allocated */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/stat.2:151
#, no-wrap
msgid ""
"    /* Since Linux 2.6, the kernel supports nanosecond\n"
"       precision for the following timestamp fields.\n"
"       For the details before Linux 2.6, see NOTES. */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/stat.2:155
#, no-wrap
msgid ""
"    struct timespec st_atim;  /* Time of last access */\n"
"    struct timespec st_mtim;  /* Time of last modification */\n"
"    struct timespec st_ctim;  /* Time of last status change */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/stat.2:160
#, no-wrap
msgid ""
"#define st_atime st_atim.tv_sec      /* Backward compatibility */\n"
"#define st_mtime st_mtim.tv_sec\n"
"#define st_ctime st_ctim.tv_sec\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/stat.2:173
msgid ""
"I<Note>: the order of fields in the I<stat> structure varies somewhat across "
"architectures.  In addition, the definition above does not show the padding "
"bytes that may be present between some fields on various architectures.  "
"Consult the glibc and kernel source code if you need to know the details."
msgstr ""

#.  Background: inode attributes are modified with i_mutex held, but
#.  read by stat() without taking the mutex.
#. type: Plain text
#: man-pages/man2/stat.2:198
msgid ""
"I<Note>: for performance and simplicity reasons, different fields in the "
"I<stat> structure may contain state information from different moments "
"during the execution of the system call.  For example, if I<st_mode> or "
"I<st_uid> is changed by another process by calling B<chmod>(2)  or "
"B<chown>(2), B<stat>()  might return the old I<st_mode> together with the "
"new I<st_uid>, or the old I<st_uid> together with the new I<st_mode>."
msgstr ""

#. type: Plain text
#: man-pages/man2/stat.2:202
msgid "The fields in the I<stat> structure are as follows:"
msgstr ""

#. type: TP
#: man-pages/man2/stat.2:202
#, no-wrap
msgid "I<st_dev>"
msgstr ""

#. type: Plain text
#: man-pages/man2/stat.2:210
msgid ""
"This field describes the device on which this file resides.  (The "
"B<major>(3)  and B<minor>(3)  macros may be useful to decompose the device "
"ID in this field.)"
msgstr ""

#. type: TP
#: man-pages/man2/stat.2:210
#, no-wrap
msgid "I<st_ino>"
msgstr ""

#. type: Plain text
#: man-pages/man2/stat.2:213
msgid "This field contains the file's inode number."
msgstr ""

#. type: TP
#: man-pages/man2/stat.2:213
#, no-wrap
msgid "I<st_mode>"
msgstr ""

#. type: Plain text
#: man-pages/man2/stat.2:219
msgid ""
"This field contains the file type and mode.  See B<inode>(7)  for further "
"information."
msgstr ""

#. type: TP
#: man-pages/man2/stat.2:219
#, no-wrap
msgid "I<st_nlink>"
msgstr ""

#. type: Plain text
#: man-pages/man2/stat.2:222
msgid "This field contains the number of hard links to the file."
msgstr ""

#. type: TP
#: man-pages/man2/stat.2:222
#, no-wrap
msgid "I<st_uid>"
msgstr ""

#. type: TP
#: man-pages/man2/stat.2:225
#, no-wrap
msgid "I<st_gid>"
msgstr ""

#. type: TP
#: man-pages/man2/stat.2:228
#, no-wrap
msgid "I<st_rdev>"
msgstr ""

#. type: Plain text
#: man-pages/man2/stat.2:231
msgid "This field describes the device that this file (inode) represents."
msgstr ""

#. type: TP
#: man-pages/man2/stat.2:231
#, no-wrap
msgid "I<st_size>"
msgstr ""

#. type: Plain text
#: man-pages/man2/stat.2:237
msgid ""
"This field gives the size of the file (if it is a regular file or a symbolic "
"link) in bytes.  The size of a symbolic link is the length of the pathname "
"it contains, without a terminating null byte."
msgstr ""

#. type: TP
#: man-pages/man2/stat.2:237
#, no-wrap
msgid "I<st_blksize>"
msgstr ""

#. type: Plain text
#: man-pages/man2/stat.2:240
msgid "This field gives the \"preferred\" block size for efficient filesystem I/O."
msgstr ""

#. type: TP
#: man-pages/man2/stat.2:240
#, no-wrap
msgid "I<st_blocks>"
msgstr ""

#. type: Plain text
#: man-pages/man2/stat.2:247
msgid ""
"This field indicates the number of blocks allocated to the file, in 512-byte "
"units.  (This may be smaller than I<st_size>/512 when the file has holes.)"
msgstr ""

#. type: TP
#: man-pages/man2/stat.2:247
#, no-wrap
msgid "I<st_atime>"
msgstr ""

#. type: Plain text
#: man-pages/man2/stat.2:250
msgid "This is the file's last access timestamp."
msgstr ""

#. type: TP
#: man-pages/man2/stat.2:250
#, no-wrap
msgid "I<st_mtime>"
msgstr ""

#. type: Plain text
#: man-pages/man2/stat.2:253
msgid "This is the file's last modification timestamp."
msgstr ""

#. type: TP
#: man-pages/man2/stat.2:253
#, no-wrap
msgid "I<st_ctime>"
msgstr ""

#. type: Plain text
#: man-pages/man2/stat.2:256
msgid "This is the file's last status change timestamp."
msgstr ""

#. type: SS
#: man-pages/man2/stat.2:260
#, no-wrap
msgid "fstatat()"
msgstr ""

#. type: Plain text
#: man-pages/man2/stat.2:269
msgid ""
"The B<fstatat>()  system call is a more general interface for accessing file "
"information which can still provide exactly the behavior of each of "
"B<stat>(), B<lstat>(), and B<fstat>()."
msgstr ""

#. type: Plain text
#: man-pages/man2/stat.2:281
msgid ""
"If the pathname given in I<pathname> is relative, then it is interpreted "
"relative to the directory referred to by the file descriptor I<dirfd> "
"(rather than relative to the current working directory of the calling "
"process, as is done by B<stat>()  and B<lstat>()  for a relative pathname)."
msgstr ""

#. type: Plain text
#: man-pages/man2/stat.2:295
msgid ""
"If I<pathname> is relative and I<dirfd> is the special value B<AT_FDCWD>, "
"then I<pathname> is interpreted relative to the current working directory of "
"the calling process (like B<stat>()  and B<lstat>())."
msgstr ""

#. type: Plain text
#: man-pages/man2/stat.2:304
msgid ""
"I<flags> can either be 0, or include one or more of the following flags "
"ORed:"
msgstr ""

#.  commit 65cfc6722361570bfe255698d9cd4dccaf47570d
#.  Before glibc 2.16, defining _ATFILE_SOURCE sufficed
#. type: Plain text
#: man-pages/man2/stat.2:331
msgid ""
"If I<pathname> is an empty string, operate on the file referred to by "
"I<dirfd> (which may have been obtained using the B<open>(2)  B<O_PATH> "
"flag).  In this case, I<dirfd> can refer to any type of file, not just a "
"directory, and the behavior of B<fstatat>()  is similar to that of "
"B<fstat>().  If I<dirfd> is B<AT_FDCWD>, the call operates on the current "
"working directory.  This flag is Linux-specific; define B<_GNU_SOURCE> to "
"obtain its definition."
msgstr ""

#. type: TP
#: man-pages/man2/stat.2:331
#, no-wrap
msgid "B<AT_NO_AUTOMOUNT> (since Linux 2.6.38)"
msgstr ""

#.  commit 42f46148217865a545e129612075f3d828a2c4e4
#.  Before glibc 2.16, defining _ATFILE_SOURCE sufficed
#. type: Plain text
#: man-pages/man2/stat.2:358
msgid ""
"Don't automount the terminal (\"basename\") component of I<pathname> if it "
"is a directory that is an automount point.  This allows the caller to gather "
"attributes of an automount point (rather than the location it would mount).  "
"Since Linux 4.14, also don't instantiate a nonexistent name in an on-demand "
"directory such as used for automounter indirect maps.  This flag can be used "
"in tools that scan directories to prevent mass-automounting of a directory "
"of automount points.  The B<AT_NO_AUTOMOUNT> flag has no effect if the mount "
"point has already been mounted over.  This flag is Linux-specific; define "
"B<_GNU_SOURCE> to obtain its definition.  Both B<stat>()  and B<lstat>()  "
"act as though B<AT_NO_AUTOMOUNT> was set."
msgstr ""

#. type: Plain text
#: man-pages/man2/stat.2:369
msgid ""
"If I<pathname> is a symbolic link, do not dereference it: instead return "
"information about the link itself, like B<lstat>().  (By default, "
"B<fstatat>()  dereferences symbolic links, like B<stat>().)"
msgstr ""

#. type: Plain text
#: man-pages/man2/stat.2:374
msgid "See B<openat>(2)  for an explanation of the need for B<fstatat>()."
msgstr ""

#. type: Plain text
#: man-pages/man2/stat.2:397
msgid "Too many symbolic links encountered while traversing the path."
msgstr ""

#. type: Plain text
#: man-pages/man2/stat.2:413
msgid ""
"I<pathname> is an empty string and B<AT_EMPTY_PATH> was not specified in "
"I<flags>."
msgstr ""

#. type: Plain text
#: man-pages/man2/stat.2:421
msgid "A component of the path prefix of I<pathname> is not a directory."
msgstr ""

#. type: Plain text
#: man-pages/man2/stat.2:440
msgid ""
"I<pathname> or I<fd> refers to a file whose size, inode number, or number of "
"blocks cannot be represented in, respectively, the types I<off_t>, I<ino_t>, "
"or I<blkcnt_t>.  This error can occur when, for example, an application "
"compiled on a 32-bit platform without I<-D_FILE_OFFSET_BITS=64> calls "
"B<stat>()  on a file whose size exceeds I<(1E<lt>E<lt>31)-1> bytes."
msgstr ""

#. type: Plain text
#: man-pages/man2/stat.2:443
msgid "The following additional errors can occur for B<fstatat>():"
msgstr ""

#. type: Plain text
#: man-pages/man2/stat.2:461
msgid ""
"B<fstatat>()  was added to Linux in kernel 2.6.16; library support was added "
"to glibc in version 2.4."
msgstr ""

#.  SVr4 documents additional
#.  .BR fstat ()
#.  error conditions EINTR, ENOLINK, and EOVERFLOW.  SVr4
#.  documents additional
#.  .BR stat ()
#.  and
#.  .BR lstat ()
#.  error conditions EINTR, EMULTIHOP, ENOLINK, and EOVERFLOW.
#. type: Plain text
#: man-pages/man2/stat.2:474
msgid "B<stat>(), B<fstat>(), B<lstat>(): SVr4, 4.3BSD, POSIX.1-2001, POSIX.1.2008."
msgstr ""

#. type: Plain text
#: man-pages/man2/stat.2:477
msgid "B<fstatat>(): POSIX.1-2008."
msgstr ""

#. type: Plain text
#: man-pages/man2/stat.2:491
msgid ""
"According to POSIX.1-2001, B<lstat>()  on a symbolic link need return valid "
"information only in the I<st_size> field and the file type of the I<st_mode> "
"field of the I<stat> structure.  POSIX.1-2008 tightens the specification, "
"requiring B<lstat>()  to return valid information in all fields except the "
"mode bits in I<st_mode>."
msgstr ""

#. type: Plain text
#: man-pages/man2/stat.2:500
msgid ""
"Use of the I<st_blocks> and I<st_blksize> fields may be less portable.  "
"(They were introduced in BSD.  The interpretation differs between systems, "
"and possibly on a single system when NFS mounts are involved.)"
msgstr ""

#. type: SS
#: man-pages/man2/stat.2:501
#, no-wrap
msgid "Timestamp fields"
msgstr ""

#. type: Plain text
#: man-pages/man2/stat.2:512
msgid ""
"Older kernels and older standards did not support nanosecond timestamp "
"fields.  Instead, there were three timestamp fields\\(emI<st_atime>, "
"I<st_mtime>, and I<st_ctime>\\(emtyped as I<time_t> that recorded timestamps "
"with one-second precision."
msgstr ""

#. type: Plain text
#: man-pages/man2/stat.2:537
msgid ""
"Since kernel 2.5.48, the I<stat> structure supports nanosecond resolution "
"for the three file timestamp fields.  The nanosecond components of each "
"timestamp are available via names of the form I<st_atim.tv_nsec>, if "
"suitable feature test macros are defined.  Nanosecond timestamps were "
"standardized in POSIX.1-2008, and, starting with version 2.12, glibc exposes "
"the nanosecond component names if B<_POSIX_C_SOURCE> is defined with the "
"value 200809L or greater, or B<_XOPEN_SOURCE> is defined with the value 700 "
"or greater.  Up to and including glibc 2.19, the definitions of the "
"nanoseconds components are also defined if B<_BSD_SOURCE> or B<_SVID_SOURCE> "
"is defined.  If none of the aforementioned macros are defined, then the "
"nanosecond values are exposed with names of the form I<st_atimensec>."
msgstr ""

#.  See include/asm-i386/stat.h in the Linux 2.4 source code for the
#.  various versions of the structure definitions
#. type: Plain text
#: man-pages/man2/stat.2:562
msgid ""
"Over time, increases in the size of the I<stat> structure have led to three "
"successive versions of B<stat>(): I<sys_stat>()  (slot I<__NR_oldstat>), "
"I<sys_newstat>()  (slot I<__NR_stat>), and I<sys_stat64()> (slot "
"I<__NR_stat64>)  on 32-bit platforms such as i386.  The first two versions "
"were already present in Linux 1.0 (albeit with different names); the last "
"was added in Linux 2.4.  Similar remarks apply for B<fstat>()  and "
"B<lstat>()."
msgstr ""

#. type: Plain text
#: man-pages/man2/stat.2:566
msgid ""
"The kernel-internal versions of the I<stat> structure dealt with by the "
"different versions are, respectively:"
msgstr ""

#. type: TP
#: man-pages/man2/stat.2:566
#, no-wrap
msgid "I<__old_kernel_stat>"
msgstr ""

#. type: Plain text
#: man-pages/man2/stat.2:569
msgid "The original structure, with rather narrow fields, and no padding."
msgstr ""

#. type: TP
#: man-pages/man2/stat.2:569
#, no-wrap
msgid "I<stat>"
msgstr ""

#. type: Plain text
#: man-pages/man2/stat.2:575
msgid ""
"Larger I<st_ino> field and padding added to various parts of the structure "
"to allow for future expansion."
msgstr ""

#. type: TP
#: man-pages/man2/stat.2:575
#, no-wrap
msgid "I<stat64>"
msgstr ""

#. type: Plain text
#: man-pages/man2/stat.2:589
msgid ""
"Even larger I<st_ino> field, larger I<st_uid> and I<st_gid> fields to "
"accommodate the Linux-2.4 expansion of UIDs and GIDs to 32 bits, and various "
"other enlarged fields and further padding in the structure.  (Various "
"padding bytes were eventually consumed in Linux 2.6, with the advent of "
"32-bit device IDs and nanosecond components for the timestamp fields.)"
msgstr ""

#
#.  A note from Andries Brouwer, July 2007
#
#.  > Is the story not rather more complicated for some calls like
#.  > stat(2)?
#
#.  Yes and no, mostly no. See /usr/include/sys/stat.h .
#
#.  The idea is here not so much that syscalls change, but that
#.  the definitions of struct stat and of the types dev_t and mode_t change.
#.  This means that libc (even if it does not call the kernel
#.  but only calls some internal function) must know what the
#.  format of dev_t or of struct stat is.
#.  The communication between the application and libc goes via
#.  the include file <sys/stat.h> that defines a _STAT_VER and
#.  _MKNOD_VER describing the layout of the data that user space
#.  uses. Each (almost each) occurrence of stat() is replaced by
#.  an occurrence of xstat() where the first parameter of xstat()
#.  is this version number _STAT_VER.
#
#.  Now, also the definitions used by the kernel change.
#.  But glibc copes with this in the standard way, and the
#.  struct stat as returned by the kernel is repacked into
#.  the struct stat as expected by the application.
#.  Thus, _STAT_VER and this setup cater for the application-libc
#.  interface, rather than the libc-kernel interface.
#
#.  (Note that the details depend on gcc being used as c compiler.)
#. type: Plain text
#: man-pages/man2/stat.2:623
msgid ""
"The glibc B<stat>()  wrapper function hides these details from applications, "
"invoking the most recent version of the system call provided by the kernel, "
"and repacking the returned information if required for old binaries."
msgstr ""

#. type: Plain text
#: man-pages/man2/stat.2:629
msgid ""
"On modern 64-bit systems, life is simpler: there is a single B<stat>()  "
"system call and the kernel deals with a I<stat> structure that contains "
"fields of a sufficient size."
msgstr ""

#.  strace(1) shows the name "newfstatat" on x86-64
#. type: Plain text
#: man-pages/man2/stat.2:637
msgid ""
"The underlying system call employed by the glibc B<fstatat>()  wrapper "
"function is actually called B<fstatat64>()  or, on some architectures, "
"B<newfstatat>()."
msgstr ""

#. type: Plain text
#: man-pages/man2/stat.2:643
msgid ""
"The following program calls B<lstat>()  and displays selected fields in the "
"returned I<stat> structure."
msgstr ""

#. type: Plain text
#: man-pages/man2/stat.2:651
#, no-wrap
msgid ""
"#include E<lt>sys/types.hE<gt>\n"
"#include E<lt>sys/stat.hE<gt>\n"
"#include E<lt>time.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>sys/sysmacros.hE<gt>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/stat.2:656
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    struct stat sb;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/stat.2:661 man-pages/man2/readlink.2:305
#, no-wrap
msgid ""
"    if (argc != 2) {\n"
"        fprintf(stderr, \"Usage: %s E<lt>pathnameE<gt>\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/stat.2:666 man-pages/man2/readlink.2:310
#, no-wrap
msgid ""
"    if (lstat(argv[1], &sb) == -1) {\n"
"        perror(\"lstat\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/stat.2:669
#, no-wrap
msgid ""
"    printf(\"ID of containing device:  [%lx,%lx]\\en\",\n"
"\t    (long) major(sb.st_dev), (long) minor(sb.st_dev));\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/stat.2:671
#, no-wrap
msgid "    printf(\"File type:                \");\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/stat.2:682
#, no-wrap
msgid ""
"    switch (sb.st_mode & S_IFMT) {\n"
"    case S_IFBLK:  printf(\"block device\\en\");            break;\n"
"    case S_IFCHR:  printf(\"character device\\en\");        break;\n"
"    case S_IFDIR:  printf(\"directory\\en\");               break;\n"
"    case S_IFIFO:  printf(\"FIFO/pipe\\en\");               break;\n"
"    case S_IFLNK:  printf(\"symlink\\en\");                 break;\n"
"    case S_IFREG:  printf(\"regular file\\en\");            break;\n"
"    case S_IFSOCK: printf(\"socket\\en\");                  break;\n"
"    default:       printf(\"unknown?\\en\");                break;\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/stat.2:684
#, no-wrap
msgid "    printf(\"I-node number:            %ld\\en\", (long) sb.st_ino);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/stat.2:687
#, no-wrap
msgid ""
"    printf(\"Mode:                     %lo (octal)\\en\",\n"
"            (unsigned long) sb.st_mode);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/stat.2:691
#, no-wrap
msgid ""
"    printf(\"Link count:               %ld\\en\", (long) sb.st_nlink);\n"
"    printf(\"Ownership:                UID=%ld   GID=%ld\\en\",\n"
"            (long) sb.st_uid, (long) sb.st_gid);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/stat.2:698
#, no-wrap
msgid ""
"    printf(\"Preferred I/O block size: %ld bytes\\en\",\n"
"            (long) sb.st_blksize);\n"
"    printf(\"File size:                %lld bytes\\en\",\n"
"            (long long) sb.st_size);\n"
"    printf(\"Blocks allocated:         %lld\\en\",\n"
"            (long long) sb.st_blocks);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/stat.2:702
#, no-wrap
msgid ""
"    printf(\"Last status change:       %s\", ctime(&sb.st_ctime));\n"
"    printf(\"Last file access:         %s\", ctime(&sb.st_atime));\n"
"    printf(\"Last file modification:   %s\", ctime(&sb.st_mtime));\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/stat.2:717
msgid ""
"B<ls>(1), B<stat>(1), B<access>(2), B<chmod>(2), B<chown>(2), "
"B<readlink>(2), B<statx>(2), B<utime>(2), B<capabilities>(7), B<inode>(7), "
"B<symlink>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/select.2:38
#, no-wrap
msgid "SELECT"
msgstr ""

#. type: Plain text
#: man-pages/man2/select.2:54
#, no-wrap
msgid ""
"B<int select(int >I<nfds>B<, fd_set *>I<readfds>B<, fd_set "
"*>I<writefds>B<,>\n"
"B<           fd_set *>I<exceptfds>B<, struct timeval *>I<timeout>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/select.2:65
#, no-wrap
msgid ""
"B<int pselect(int >I<nfds>B<, fd_set *>I<readfds>B<, fd_set "
"*>I<writefds>B<,>\n"
"B<            fd_set *>I<exceptfds>B<, const struct timespec "
"*>I<timeout>B<,>\n"
"B<            const sigset_t *>I<sigmask>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/select.2:87
msgid ""
"B<select>()  and B<pselect>()  allow a program to monitor multiple file "
"descriptors, waiting until one or more of the file descriptors become "
"\"ready\" for some class of I/O operation (e.g., input possible).  A file "
"descriptor is considered ready if it is possible to perform a corresponding "
"I/O operation (e.g., B<read>(2), or a sufficiently small B<write>(2))  "
"without blocking."
msgstr ""

#. type: Plain text
#: man-pages/man2/select.2:94
msgid ""
"B<select>()  can monitor only file descriptors numbers that are less than "
"B<FD_SETSIZE>; B<poll>(2)  does not have this limitation.  See BUGS."
msgstr ""

#. type: Plain text
#: man-pages/man2/select.2:100
msgid ""
"The operation of B<select>()  and B<pselect>()  is identical, other than "
"these three differences:"
msgstr ""

#. type: TP
#: man-pages/man2/select.2:100
#, no-wrap
msgid "(i)"
msgstr ""

#. type: Plain text
#: man-pages/man2/select.2:110
msgid ""
"B<select>()  uses a timeout that is a I<struct timeval> (with seconds and "
"microseconds), while B<pselect>()  uses a I<struct timespec> (with seconds "
"and nanoseconds)."
msgstr ""

#. type: TP
#: man-pages/man2/select.2:110
#, no-wrap
msgid "(ii)"
msgstr ""

#. type: Plain text
#: man-pages/man2/select.2:118
msgid ""
"B<select>()  may update the I<timeout> argument to indicate how much time "
"was left.  B<pselect>()  does not change this argument."
msgstr ""

#. type: TP
#: man-pages/man2/select.2:118
#, no-wrap
msgid "(iii)"
msgstr ""

#. type: Plain text
#: man-pages/man2/select.2:127
msgid ""
"B<select>()  has no I<sigmask> argument, and behaves as B<pselect>()  called "
"with NULL I<sigmask>."
msgstr ""

#. type: Plain text
#: man-pages/man2/select.2:145
msgid ""
"Three independent sets of file descriptors are watched.  The file "
"descriptors listed in I<readfds> will be watched to see if characters become "
"available for reading (more precisely, to see if a read will not block; in "
"particular, a file descriptor is also ready on end-of-file).  The file "
"descriptors in I<writefds> will be watched to see if space is available for "
"write (though a large write may still block).  The file descriptors in "
"I<exceptfds> will be watched for exceptional conditions.  (For examples of "
"some exceptional conditions, see the discussion of B<POLLPRI> in "
"B<poll>(2).)"
msgstr ""

#. type: Plain text
#: man-pages/man2/select.2:151
msgid ""
"On exit, each of the file descriptor sets is modified in place to indicate "
"which file descriptors actually changed status.  (Thus, if using B<select>()  "
"within a loop, the sets must be reinitialized before each call.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/select.2:155
msgid ""
"Each of the three file descriptor sets may be specified as NULL if no file "
"descriptors are to be watched for the corresponding class of events."
msgstr ""

#. type: Plain text
#: man-pages/man2/select.2:168
msgid ""
"Four macros are provided to manipulate the sets.  B<FD_ZERO>()  clears a "
"set.  B<FD_SET>()  and B<FD_CLR>()  add and remove a given file descriptor "
"from a set.  B<FD_ISSET>()  tests to see if a file descriptor is part of the "
"set; this is useful after B<select>()  returns."
msgstr ""

#. type: Plain text
#: man-pages/man2/select.2:174
msgid ""
"I<nfds> should be set to the highest-numbered file descriptor in any of the "
"three sets, plus 1.  The indicated file descriptors in each set are checked, "
"up to this limit (but see BUGS)."
msgstr ""

#. type: Plain text
#: man-pages/man2/select.2:181
msgid ""
"The I<timeout> argument specifies the interval that B<select>()  should "
"block waiting for a file descriptor to become ready.  The call will block "
"until either:"
msgstr ""

#. type: Plain text
#: man-pages/man2/select.2:204
msgid ""
"Note that the I<timeout> interval will be rounded up to the system clock "
"granularity, and kernel scheduling delays mean that the blocking interval "
"may overrun by a small amount.  If both fields of the I<timeval> structure "
"are zero, then B<select>()  returns immediately.  (This is useful for "
"polling.)  If I<timeout> is NULL (no timeout), B<select>()  can block "
"indefinitely."
msgstr ""

#. type: Plain text
#: man-pages/man2/select.2:214
msgid ""
"I<sigmask> is a pointer to a signal mask (see B<sigprocmask>(2)); if it is "
"not NULL, then B<pselect>()  first replaces the current signal mask by the "
"one pointed to by I<sigmask>, then does the \"select\" function, and then "
"restores the original signal mask."
msgstr ""

#. type: Plain text
#: man-pages/man2/select.2:220
msgid ""
"Other than the difference in the precision of the I<timeout> argument, the "
"following B<pselect>()  call:"
msgstr ""

#. type: Plain text
#: man-pages/man2/select.2:225
#, no-wrap
msgid ""
"ready = pselect(nfds, &readfds, &writefds, &exceptfds,\n"
"                timeout, &sigmask);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/select.2:239
#, no-wrap
msgid ""
"pthread_sigmask(SIG_SETMASK, &sigmask, &origmask);\n"
"ready = select(nfds, &readfds, &writefds, &exceptfds, timeout);\n"
"pthread_sigmask(SIG_SETMASK, &origmask, NULL);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/select.2:262
msgid ""
"The reason that B<pselect>()  is needed is that if one wants to wait for "
"either a signal or for a file descriptor to become ready, then an atomic "
"test is needed to prevent race conditions.  (Suppose the signal handler sets "
"a global flag and returns.  Then a test of this global flag followed by a "
"call of B<select>()  could hang indefinitely if the signal arrived just "
"after the test but just before the call.  By contrast, B<pselect>()  allows "
"one to first block signals, handle the signals that have come in, then call "
"B<pselect>()  with the desired I<sigmask>, avoiding the race.)"
msgstr ""

#. type: SS
#: man-pages/man2/select.2:262
#, no-wrap
msgid "The timeout"
msgstr ""

#. type: Plain text
#: man-pages/man2/select.2:266
msgid ""
"The time structures involved are defined in I<E<lt>sys/time.hE<gt>> and look "
"like"
msgstr ""

#. type: Plain text
#: man-pages/man2/select.2:273
#, no-wrap
msgid ""
"struct timeval {\n"
"    long    tv_sec;         /* seconds */\n"
"    long    tv_usec;        /* microseconds */\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/select.2:277
msgid "and"
msgstr ""

#. type: Plain text
#: man-pages/man2/select.2:288
msgid "(However, see below on the POSIX.1 versions.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/select.2:296
msgid ""
"Some code calls B<select>()  with all three sets empty, I<nfds> zero, and a "
"non-NULL I<timeout> as a fairly portable way to sleep with subsecond "
"precision."
msgstr ""

#.  .PP - it is rumored that:
#.  On BSD, when a timeout occurs, the file descriptor bits are not changed.
#.  - it is certainly true that:
#.  Linux follows SUSv2 and sets the bit masks to zero upon a timeout.
#. type: Plain text
#: man-pages/man2/select.2:319
msgid ""
"On Linux, B<select>()  modifies I<timeout> to reflect the amount of time not "
"slept; most other implementations do not do this.  (POSIX.1 permits either "
"behavior.)  This causes problems both when Linux code which reads I<timeout> "
"is ported to other operating systems, and when code is ported to Linux that "
"reuses a I<struct timeval> for multiple B<select>()s in a loop without "
"reinitializing it.  Consider I<timeout> to be undefined after B<select>()  "
"returns."
msgstr ""

#. type: Plain text
#: man-pages/man2/select.2:337
msgid ""
"On success, B<select>()  and B<pselect>()  return the number of file "
"descriptors contained in the three returned descriptor sets (that is, the "
"total number of bits that are set in I<readfds>, I<writefds>, I<exceptfds>)  "
"which may be zero if the timeout expires before anything interesting "
"happens.  On error, -1 is returned, and I<errno> is set to indicate the "
"error; the file descriptor sets are unmodified, and I<timeout> becomes "
"undefined."
msgstr ""

#. type: Plain text
#: man-pages/man2/select.2:344
msgid ""
"An invalid file descriptor was given in one of the sets.  (Perhaps a file "
"descriptor that was already closed, or one on which an error has occurred.)  "
"However, see BUGS."
msgstr ""

#. type: Plain text
#: man-pages/man2/select.2:348
msgid "A signal was caught; see B<signal>(7)."
msgstr ""

#. type: Plain text
#: man-pages/man2/select.2:355
msgid ""
"I<nfds> is negative or exceeds the B<RLIMIT_NOFILE> resource limit (see "
"B<getrlimit>(2))."
msgstr ""

#. type: Plain text
#: man-pages/man2/select.2:360
msgid "The value contained within I<timeout> is invalid."
msgstr ""

#. type: Plain text
#: man-pages/man2/select.2:363
msgid "Unable to allocate memory for internal tables."
msgstr ""

#. type: Plain text
#: man-pages/man2/select.2:369
msgid ""
"B<pselect>()  was added to Linux in kernel 2.6.16.  Prior to this, "
"B<pselect>()  was emulated in glibc (but see BUGS)."
msgstr ""

#. type: Plain text
#: man-pages/man2/select.2:380
msgid ""
"B<select>()  conforms to POSIX.1-2001, POSIX.1-2008, and 4.4BSD (B<select>()  "
"first appeared in 4.2BSD).  Generally portable to/from non-BSD systems "
"supporting clones of the BSD socket layer (including System\\ V variants).  "
"However, note that the System\\ V variant typically sets the timeout "
"variable before exit, but the BSD variant does not."
msgstr ""

#. type: Plain text
#: man-pages/man2/select.2:384
msgid "B<pselect>()  is defined in POSIX.1g, and in POSIX.1-2001 and POSIX.1-2008."
msgstr ""

#. type: Plain text
#: man-pages/man2/select.2:401
msgid ""
"An I<fd_set> is a fixed size buffer.  Executing B<FD_CLR>()  or B<FD_SET>()  "
"with a value of I<fd> that is negative or is equal to or larger than "
"B<FD_SETSIZE> will result in undefined behavior.  Moreover, POSIX requires "
"I<fd> to be a valid file descriptor."
msgstr ""

#. type: Plain text
#: man-pages/man2/select.2:409
msgid ""
"The operation of B<select>()  and B<pselect>()  is not affected by the "
"B<O_NONBLOCK> flag."
msgstr ""

#.  Darwin, according to a report by Jeremy Sequoia, relayed by Josh Triplett
#. type: Plain text
#: man-pages/man2/select.2:426
msgid ""
"On some other UNIX systems, B<select>()  can fail with the error B<EAGAIN> "
"if the system fails to allocate kernel-internal resources, rather than "
"B<ENOMEM> as Linux does.  POSIX specifies this error for B<poll>(2), but not "
"for B<select>().  Portable programs may wish to check for B<EAGAIN> and "
"loop, just as with B<EINTR>."
msgstr ""

#. type: Plain text
#: man-pages/man2/select.2:439
msgid ""
"On systems that lack B<pselect>(), reliable (and more portable) signal "
"trapping can be achieved using the self-pipe trick.  In this technique, a "
"signal handler writes a byte to a pipe whose other end is monitored by "
"B<select>()  in the main program.  (To avoid possibly blocking when writing "
"to a pipe that may be full or reading from a pipe that may be empty, "
"nonblocking I/O is used when reading from and writing to the pipe.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/select.2:448
msgid ""
"Concerning the types involved, the classical situation is that the two "
"fields of a I<timeval> structure are typed as I<long> (as shown above), and "
"the structure is defined in I<E<lt>sys/time.hE<gt>>.  The POSIX.1 situation "
"is"
msgstr ""

#. type: Plain text
#: man-pages/man2/select.2:455
#, no-wrap
msgid ""
"struct timeval {\n"
"    time_t         tv_sec;     /* seconds */\n"
"    suseconds_t    tv_usec;    /* microseconds */\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/select.2:466
msgid ""
"where the structure is defined in I<E<lt>sys/select.hE<gt>> and the data "
"types I<time_t> and I<suseconds_t> are defined in I<E<lt>sys/types.hE<gt>>."
msgstr ""

#. type: Plain text
#: man-pages/man2/select.2:478
msgid ""
"Concerning prototypes, the classical situation is that one should include "
"I<E<lt>time.hE<gt>> for B<select>().  The POSIX.1 situation is that one "
"should include I<E<lt>sys/select.hE<gt>> for B<select>()  and B<pselect>()."
msgstr ""

#. type: Plain text
#: man-pages/man2/select.2:490
msgid ""
"Under glibc 2.0, I<E<lt>sys/select.hE<gt>> gives the wrong prototype for "
"B<pselect>().  Under glibc 2.1 to 2.2.1, it gives B<pselect>()  when "
"B<_GNU_SOURCE> is defined.  Since glibc 2.2.2, the requirements are as shown "
"in the SYNOPSIS."
msgstr ""

#. type: SS
#: man-pages/man2/select.2:490
#, no-wrap
msgid "Correspondence between select() and poll() notifications"
msgstr ""

#.  fs/select.c
#. type: Plain text
#: man-pages/man2/select.2:500
msgid ""
"Within the Linux kernel source, we find the following definitions which show "
"the correspondence between the readable, writable, and exceptional condition "
"notifications of B<select>()  and the event notifications provided by "
"B<poll>(2)  (and B<epoll>(7)):"
msgstr ""

#. type: Plain text
#: man-pages/man2/select.2:510
#, no-wrap
msgid ""
"#define POLLIN_SET (POLLRDNORM | POLLRDBAND | POLLIN | POLLHUP |\n"
"                    POLLERR)\n"
"                   /* Ready for reading */\n"
"#define POLLOUT_SET (POLLWRBAND | POLLWRNORM | POLLOUT | POLLERR)\n"
"                   /* Ready for writing */\n"
"#define POLLEX_SET (POLLPRI)\n"
"                   /* Exceptional condition */\n"
msgstr ""

#. type: SS
#: man-pages/man2/select.2:513
#, no-wrap
msgid "Multithreaded applications"
msgstr ""

#. type: Plain text
#: man-pages/man2/select.2:530
msgid ""
"If a file descriptor being monitored by B<select>()  is closed in another "
"thread, the result is unspecified.  On some UNIX systems, B<select>()  "
"unblocks and returns, with an indication that the file descriptor is ready "
"(a subsequent I/O operation will likely fail with an error, unless another "
"process reopens file descriptor between the time B<select>()  returned and "
"the I/O operation is performed).  On Linux (and some other systems), closing "
"the file descriptor in another thread has no effect on B<select>().  In "
"summary, any application that relies on a particular behavior in this "
"scenario must be considered buggy."
msgstr ""

#. type: Plain text
#: man-pages/man2/select.2:538
msgid ""
"The Linux kernel allows file descriptor sets of arbitrary size, determining "
"the length of the sets to be checked from the value of I<nfds>.  However, in "
"the glibc implementation, the I<fd_set> type is fixed in size.  See also "
"BUGS."
msgstr ""

#. type: Plain text
#: man-pages/man2/select.2:546
msgid ""
"The B<pselect>()  interface described in this page is implemented by glibc.  "
"The underlying Linux system call is named B<pselect6>().  This system call "
"has somewhat different behavior from the glibc wrapper function."
msgstr ""

#. type: Plain text
#: man-pages/man2/select.2:561
msgid ""
"The Linux B<pselect6>()  system call modifies its I<timeout> argument.  "
"However, the glibc wrapper function hides this behavior by using a local "
"variable for the timeout argument that is passed to the system call.  Thus, "
"the glibc B<pselect>()  function does not modify its I<timeout> argument; "
"this is the behavior required by POSIX.1-2001."
msgstr ""

#. type: Plain text
#: man-pages/man2/select.2:567
msgid ""
"The final argument of the B<pselect6>()  system call is not a I<sigset_t\\ "
"*> pointer, but is instead a structure of the form:"
msgstr ""

#. type: Plain text
#: man-pages/man2/select.2:575
#, no-wrap
msgid ""
"struct {\n"
"    const kernel_sigset_t *ss;   /* Pointer to signal set */\n"
"    size_t ss_len;               /* Size (in bytes) of object\n"
"                                    pointed to by 'ss' */\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/select.2:586
msgid ""
"This allows the system call to obtain both a pointer to the signal set and "
"its size, while allowing for the fact that most architectures support a "
"maximum of 6 arguments to a system call.  See B<sigprocmask>(2)  for a "
"discussion of the difference between the kernel and libc notion of the "
"signal set."
msgstr ""

#. type: Plain text
#: man-pages/man2/select.2:602
msgid ""
"POSIX allows an implementation to define an upper limit, advertised via the "
"constant B<FD_SETSIZE>, on the range of file descriptors that can be "
"specified in a file descriptor set.  The Linux kernel imposes no fixed "
"limit, but the glibc implementation makes I<fd_set> a fixed-size type, with "
"B<FD_SETSIZE> defined as 1024, and the B<FD_*>()  macros operating according "
"to that limit.  To monitor file descriptors greater than 1023, use "
"B<poll>(2)  instead."
msgstr ""

#. type: Plain text
#: man-pages/man2/select.2:611
msgid ""
"The implementation of the I<fd_set> arguments as value-result arguments "
"means that they must be reinitialized on each call to B<select>().  This "
"design error is avoided by B<poll>(2), which uses separate structure fields "
"for the input and output of the call."
msgstr ""

#. type: Plain text
#: man-pages/man2/select.2:623
msgid ""
"According to POSIX, B<select>()  should check all specified file descriptors "
"in the three file descriptor sets, up to the limit I<nfds-1>.  However, the "
"current implementation ignores any file descriptor in these sets that is "
"greater than the maximum file descriptor number that the process currently "
"has open.  According to POSIX, any such file descriptor that is specified in "
"one of the sets should result in the error B<EBADF>."
msgstr ""

#. type: Plain text
#: man-pages/man2/select.2:629
msgid ""
"Glibc 2.0 provided a version of B<pselect>()  that did not take a I<sigmask> "
"argument."
msgstr ""

#. type: Plain text
#: man-pages/man2/select.2:642
msgid ""
"Starting with version 2.1, glibc provided an emulation of B<pselect>()  that "
"was implemented using B<sigprocmask>(2)  and B<select>().  This "
"implementation remained vulnerable to the very race condition that "
"B<pselect>()  was designed to prevent.  Modern versions of glibc use the "
"(race-free)  B<pselect>()  system call on kernels where it is provided."
msgstr ""

#.  Stevens discusses a case where accept can block after select
#.  returns successfully because of an intervening RST from the client.
#.  Maybe the kernel should have returned EIO in such a situation?
#. type: Plain text
#: man-pages/man2/select.2:658
msgid ""
"Under Linux, B<select>()  may report a socket file descriptor as \"ready for "
"reading\", while nevertheless a subsequent read blocks.  This could for "
"example happen when data has arrived but upon examination has wrong checksum "
"and is discarded.  There may be other circumstances in which a file "
"descriptor is spuriously reported as ready.  Thus it may be safer to use "
"B<O_NONBLOCK> on sockets that should not block."
msgstr ""

#. type: Plain text
#: man-pages/man2/select.2:673
msgid ""
"On Linux, B<select>()  also modifies I<timeout> if the call is interrupted "
"by a signal handler (i.e., the B<EINTR> error return).  This is not "
"permitted by POSIX.1.  The Linux B<pselect>()  system call has the same "
"behavior, but the glibc wrapper hides this behavior by internally copying "
"the I<timeout> to a local variable and passing that variable to the system "
"call."
msgstr ""

#. type: Plain text
#: man-pages/man2/select.2:680
#, no-wrap
msgid ""
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>sys/time.hE<gt>\n"
"#include E<lt>sys/types.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/select.2:687
#, no-wrap
msgid ""
"int\n"
"main(void)\n"
"{\n"
"    fd_set rfds;\n"
"    struct timeval tv;\n"
"    int retval;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/select.2:689
#, no-wrap
msgid "    /* Watch stdin (fd 0) to see when it has input. */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/select.2:692
#, no-wrap
msgid ""
"    FD_ZERO(&rfds);\n"
"    FD_SET(0, &rfds);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/select.2:694
#, no-wrap
msgid "    /* Wait up to five seconds. */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/select.2:697
#, no-wrap
msgid ""
"    tv.tv_sec = 5;\n"
"    tv.tv_usec = 0;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/select.2:700
#, no-wrap
msgid ""
"    retval = select(1, &rfds, NULL, NULL, &tv);\n"
"    /* Don't rely on the value of tv now! */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/select.2:708
#, no-wrap
msgid ""
"    if (retval == -1)\n"
"        perror(\"select()\");\n"
"    else if (retval)\n"
"        printf(\"Data is available now.\\en\");\n"
"        /* FD_ISSET(0, &rfds) will be true. */\n"
"    else\n"
"        printf(\"No data within five seconds.\\en\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/select.2:724
msgid ""
"B<accept>(2), B<connect>(2), B<poll>(2), B<read>(2), B<recv>(2), "
"B<restart_syscall>(2), B<send>(2), B<sigprocmask>(2), B<write>(2), "
"B<epoll>(7), B<time>(7)"
msgstr ""

#. type: Plain text
#: man-pages/man2/select.2:726
msgid "For a tutorial with discussion and examples, see B<select_tut>(2)."
msgstr ""

#. type: TH
#: man-pages/man2/get_robust_list.2:30
#, no-wrap
msgid "GET_ROBUST_LIST"
msgstr ""

#. type: TH
#: man-pages/man2/get_robust_list.2:30
#, no-wrap
msgid "Linux System Calls"
msgstr ""

#. type: Plain text
#: man-pages/man2/get_robust_list.2:33
msgid "get_robust_list, set_robust_list - get/set list of robust futexes"
msgstr ""

#. type: Plain text
#: man-pages/man2/get_robust_list.2:38
#, no-wrap
msgid ""
"B<#include E<lt>linux/futex.hE<gt>>\n"
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>syscall.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/get_robust_list.2:42
#, no-wrap
msgid ""
"B<long get_robust_list(int >I<pid>B<, struct robust_list_head "
"**>I<head_ptr>B<,>\n"
"B<                     size_t *>I<len_ptr>B<);>\n"
"B<long set_robust_list(struct robust_list_head *>I<head>B<, size_t "
">I<len>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/get_robust_list.2:54
msgid ""
"These system calls deal with per-thread robust futex lists.  These lists are "
"managed in user space: the kernel knows only about the location of the head "
"of the list.  A thread can inform the kernel of the location of its robust "
"futex list using B<set_robust_list>().  The address of a thread's robust "
"futex list can be obtained using B<get_robust_list>()."
msgstr ""

#. type: Plain text
#: man-pages/man2/get_robust_list.2:66
msgid ""
"The purpose of the robust futex list is to ensure that if a thread "
"accidentally fails to unlock a futex before terminating or calling "
"B<execve>(2), another thread that is waiting on that futex is notified that "
"the former owner of the futex has died.  This notification consists of two "
"pieces: the B<FUTEX_OWNER_DIED> bit is set in the futex word, and the kernel "
"performs a B<futex>(2)  B<FUTEX_WAKE> operation on one of the threads "
"waiting on the futex."
msgstr ""

#. type: Plain text
#: man-pages/man2/get_robust_list.2:82
msgid ""
"The B<get_robust_list>()  system call returns the head of the robust futex "
"list of the thread whose thread ID is specified in I<pid>.  If I<pid> is 0, "
"the head of the list for the calling thread is returned.  The list head is "
"stored in the location pointed to by I<head_ptr>.  The size of the object "
"pointed to by I<**head_ptr> is stored in I<len_ptr>."
msgstr ""

#. type: Plain text
#: man-pages/man2/get_robust_list.2:89
msgid ""
"Permission to employ B<get_robust_list>()  is governed by a ptrace access "
"mode B<PTRACE_MODE_READ_REALCREDS> check; see B<ptrace>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/get_robust_list.2:101
msgid ""
"The B<set_robust_list>()  system call requests the kernel to record the head "
"of the list of robust futexes owned by the calling thread.  The I<head> "
"argument is the list head to record.  The I<len> argument should be "
"I<sizeof(*head)>."
msgstr ""

#. type: Plain text
#: man-pages/man2/get_robust_list.2:108
msgid ""
"The B<set_robust_list>()  and B<get_robust_list>()  system calls return zero "
"when the operation is successful, an error code otherwise."
msgstr ""

#. type: Plain text
#: man-pages/man2/get_robust_list.2:112
msgid "The B<set_robust_list>()  system call can fail with the following error:"
msgstr ""

#. type: Plain text
#: man-pages/man2/get_robust_list.2:117
msgid "I<len> does not equal I<sizeof(struct\\ robust_list_head)>."
msgstr ""

#. type: Plain text
#: man-pages/man2/get_robust_list.2:121
msgid "The B<get_robust_list>()  system call can fail with the following errors:"
msgstr ""

#. type: Plain text
#: man-pages/man2/get_robust_list.2:125
msgid "The head of the robust futex list can't be stored at the location I<head>."
msgstr ""

#. type: Plain text
#: man-pages/man2/get_robust_list.2:133
msgid ""
"The calling process does not have permission to see the robust futex list of "
"the thread with the thread ID I<pid>, and does not have the "
"B<CAP_SYS_PTRACE> capability."
msgstr ""

#. type: Plain text
#: man-pages/man2/get_robust_list.2:138
msgid "No thread with the thread ID I<pid> could be found."
msgstr ""

#. type: Plain text
#: man-pages/man2/get_robust_list.2:140
msgid "These system calls were added in Linux 2.6.17."
msgstr ""

#. type: Plain text
#: man-pages/man2/get_robust_list.2:145
msgid ""
"These system calls are not needed by normal applications.  No support for "
"them is provided in glibc.  In the unlikely event that you want to call them "
"directly, use B<syscall>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/get_robust_list.2:149
msgid ""
"A thread can have only one robust futex list; therefore applications that "
"wish to use this functionality should use the robust mutexes provided by "
"glibc."
msgstr ""

#.  commit 8141c7f3e7aee618312fa1c15109e1219de784a7
#. type: Plain text
#: man-pages/man2/get_robust_list.2:157
msgid ""
"In the initial implementation, a thread waiting on a futex was notified that "
"the owner had died only if the owner terminated.  Starting with Linux "
"2.6.28, notification was extended to include the case where the owner "
"performs an B<execve>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/get_robust_list.2:164
msgid ""
"The thread IDs mentioned in the main text are I<kernel> thread IDs of the "
"kind returned by B<clone>(2)  and B<gettid>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/get_robust_list.2:167
msgid "B<futex>(2), B<pthread_mutexattr_setrobust>(3)"
msgstr ""

#. type: Plain text
#: man-pages/man2/get_robust_list.2:171
msgid ""
"I<Documentation/robust-futexes.txt> and "
"I<Documentation/robust-futex-ABI.txt> in the Linux kernel source tree"
msgstr ""

#. type: TH
#: man-pages/man2/link.2:32
#, no-wrap
msgid "LINK"
msgstr ""

#. type: Plain text
#: man-pages/man2/link.2:35
msgid "link, linkat - make a new name for a file"
msgstr ""

#. type: Plain text
#: man-pages/man2/link.2:40
#, no-wrap
msgid "B<int link(const char *>I<oldpath>B<, const char *>I<newpath>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/link.2:46
#, no-wrap
msgid ""
"B<int linkat(int >I<olddirfd>B<, const char *>I<oldpath>B<,>\n"
"B<           int >I<newdirfd>B<, const char *>I<newpath>B<, int "
">I<flags>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/link.2:54
msgid "B<linkat>():"
msgstr ""

#. type: Plain text
#: man-pages/man2/link.2:69
msgid ""
"B<link>()  creates a new link (also known as a hard link) to an existing "
"file."
msgstr ""

#. type: Plain text
#: man-pages/man2/link.2:75
msgid "If I<newpath> exists, it will I<not> be overwritten."
msgstr ""

#. type: Plain text
#: man-pages/man2/link.2:80
msgid ""
"This new name may be used exactly as the old one for any operation; both "
"names refer to the same file (and so have the same permissions and "
"ownership) and it is impossible to tell which name was the \"original\"."
msgstr ""

#. type: SS
#: man-pages/man2/link.2:80
#, no-wrap
msgid "linkat()"
msgstr ""

#. type: Plain text
#: man-pages/man2/link.2:86
msgid ""
"The B<linkat>()  system call operates in exactly the same way as B<link>(), "
"except for the differences described here."
msgstr ""

#. type: Plain text
#: man-pages/man2/link.2:96
msgid ""
"If the pathname given in I<oldpath> is relative, then it is interpreted "
"relative to the directory referred to by the file descriptor I<olddirfd> "
"(rather than relative to the current working directory of the calling "
"process, as is done by B<link>()  for a relative pathname)."
msgstr ""

#. type: Plain text
#: man-pages/man2/link.2:108
msgid ""
"If I<oldpath> is relative and I<olddirfd> is the special value B<AT_FDCWD>, "
"then I<oldpath> is interpreted relative to the current working directory of "
"the calling process (like B<link>())."
msgstr ""

#. type: Plain text
#: man-pages/man2/link.2:125
msgid "The following values can be bitwise ORed in I<flags>:"
msgstr ""

#.  commit 11a7b371b64ef39fc5fb1b6f2218eef7c4d035e3
#.  Before glibc 2.16, defining _ATFILE_SOURCE sufficed
#. type: Plain text
#: man-pages/man2/link.2:152
msgid ""
"If I<oldpath> is an empty string, create a link to the file referenced by "
"I<olddirfd> (which may have been obtained using the B<open>(2)  B<O_PATH> "
"flag).  In this case, I<olddirfd> can refer to any type of file except a "
"directory.  This will generally not work if the file has a link count of "
"zero (files created with B<O_TMPFILE> and without B<O_EXCL> are an "
"exception).  The caller must have the B<CAP_DAC_READ_SEARCH> capability in "
"order to use this flag.  This flag is Linux-specific; define B<_GNU_SOURCE> "
"to obtain its definition."
msgstr ""

#. type: TP
#: man-pages/man2/link.2:152
#, no-wrap
msgid "B<AT_SYMLINK_FOLLOW> (since Linux 2.6.18)"
msgstr ""

#. type: Plain text
#: man-pages/man2/link.2:171
msgid ""
"By default, B<linkat>(), does not dereference I<oldpath> if it is a symbolic "
"link (like B<link>()).  The flag B<AT_SYMLINK_FOLLOW> can be specified in "
"I<flags> to cause I<oldpath> to be dereferenced if it is a symbolic link.  "
"If procfs is mounted, this can be used as an alternative to "
"B<AT_EMPTY_PATH>, like this:"
msgstr ""

#. type: Plain text
#: man-pages/man2/link.2:176
#, no-wrap
msgid ""
"linkat(AT_FDCWD, \"/proc/self/fd/E<lt>fdE<gt>\", newdirfd,\n"
"       newname, AT_SYMLINK_FOLLOW);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/link.2:182
msgid ""
"Before kernel 2.6.18, the I<flags> argument was unused, and had to be "
"specified as 0."
msgstr ""

#. type: Plain text
#: man-pages/man2/link.2:187
msgid "See B<openat>(2)  for an explanation of the need for B<linkat>()."
msgstr ""

#. type: Plain text
#: man-pages/man2/link.2:204
msgid ""
"Write access to the directory containing I<newpath> is denied, or search "
"permission is denied for one of the directories in the path prefix of "
"I<oldpath> or I<newpath>.  (See also B<path_resolution>(7).)"
msgstr ""

#. type: Plain text
#: man-pages/man2/link.2:211
msgid "I<newpath> already exists."
msgstr ""

#. type: Plain text
#: man-pages/man2/link.2:233
msgid ""
"The file referred to by I<oldpath> already has the maximum number of links "
"to it.  For example, on an B<ext4>(5)  filesystem that does not employ the "
"I<dir_index> feature, the limit on the number of hard links to a file is "
"65,000; on B<btrfs>(5), the limit is 65,535 links."
msgstr ""

#. type: Plain text
#: man-pages/man2/link.2:241
msgid ""
"A directory component in I<oldpath> or I<newpath> does not exist or is a "
"dangling symbolic link."
msgstr ""

#. type: Plain text
#: man-pages/man2/link.2:253
msgid ""
"A component used as a directory in I<oldpath> or I<newpath> is not, in fact, "
"a directory."
msgstr ""

#. type: Plain text
#: man-pages/man2/link.2:257
msgid "I<oldpath> is a directory."
msgstr ""

#. type: Plain text
#: man-pages/man2/link.2:262
msgid ""
"The filesystem containing I<oldpath> and I<newpath> does not support the "
"creation of hard links."
msgstr ""

#. type: TP
#: man-pages/man2/link.2:262
#, no-wrap
msgid "B<EPERM> (since Linux 3.6)"
msgstr ""

#. type: Plain text
#: man-pages/man2/link.2:269
msgid ""
"The caller does not have permission to create a hard link to this file (see "
"the description of I</proc/sys/fs/protected_hardlinks> in B<proc>(5))."
msgstr ""

#. type: Plain text
#: man-pages/man2/link.2:275
msgid "I<oldpath> is marked immutable or append-only.  (See B<ioctl_iflags>(2).)"
msgstr ""

#. type: Plain text
#: man-pages/man2/link.2:286
msgid ""
"I<oldpath> and I<newpath> are not on the same mounted filesystem.  (Linux "
"permits a filesystem to be mounted at multiple points, but B<link>()  does "
"not work across different mount points, even if the same filesystem is "
"mounted on both.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/link.2:289
msgid "The following additional errors can occur for B<linkat>():"
msgstr ""

#. type: Plain text
#: man-pages/man2/link.2:307
msgid ""
"B<AT_EMPTY_PATH> was specified in I<flags>, but the caller did not have the "
"B<CAP_DAC_READ_SEARCH> capability."
msgstr ""

#. type: Plain text
#: man-pages/man2/link.2:312
msgid ""
"An attempt was made to link to the I</proc/self/fd/NN> file corresponding to "
"a file descriptor created with"
msgstr ""

#. type: Plain text
#: man-pages/man2/link.2:314
#, no-wrap
msgid "    open(path, O_TMPFILE | O_EXCL, mode);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/link.2:317
msgid "See B<open>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/link.2:328
msgid ""
"I<oldpath> is a relative pathname and I<olddirfd> refers to a directory that "
"has been deleted, or I<newpath> is a relative pathname and I<newdirfd> "
"refers to a directory that has been deleted."
msgstr ""

#. type: Plain text
#: man-pages/man2/link.2:347
msgid ""
"B<AT_EMPTY_PATH> was specified in I<flags>, I<oldpath> is an empty string, "
"and I<olddirfd> refers to a directory."
msgstr ""

#. type: Plain text
#: man-pages/man2/link.2:351
msgid ""
"B<linkat>()  was added to Linux in kernel 2.6.16; library support was added "
"to glibc in version 2.4."
msgstr ""

#.  SVr4 documents additional ENOLINK and
#.  EMULTIHOP error conditions; POSIX.1 does not document ELOOP.
#.  X/OPEN does not document EFAULT, ENOMEM or EIO.
#. type: Plain text
#: man-pages/man2/link.2:357
msgid "B<link>(): SVr4, 4.3BSD, POSIX.1-2001 (but see NOTES), POSIX.1-2008."
msgstr ""

#. type: Plain text
#: man-pages/man2/link.2:360
msgid "B<linkat>(): POSIX.1-2008."
msgstr ""

#. type: Plain text
#: man-pages/man2/link.2:367
msgid ""
"Hard links, as created by B<link>(), cannot span filesystems.  Use "
"B<symlink>(2)  if this is required."
msgstr ""

#.  more precisely: since kernel 1.3.56
#.  For example, the default Solaris compilation environment
#.  behaves like Linux, and contributors to a March 2005
#.  thread in the Austin mailing list reported that some
#.  other (System V) implementations did/do the same -- MTK, Apr 05
#. type: Plain text
#: man-pages/man2/link.2:398
msgid ""
"POSIX.1-2001 says that B<link>()  should dereference I<oldpath> if it is a "
"symbolic link.  However, since kernel 2.0, Linux does not do so: if "
"I<oldpath> is a symbolic link, then I<newpath> is created as a (hard) link "
"to the same symbolic link file (i.e., I<newpath> becomes a symbolic link to "
"the same file that I<oldpath> refers to).  Some other implementations behave "
"in the same manner as Linux.  POSIX.1-2008 changes the specification of "
"B<link>(), making it implementation-dependent whether or not I<oldpath> is "
"dereferenced if it is a symbolic link.  For precise control over the "
"treatment of symbolic links when creating a link, use B<linkat>()."
msgstr ""

#. type: Plain text
#: man-pages/man2/link.2:418
msgid ""
"On older kernels where B<linkat>()  is unavailable, the glibc wrapper "
"function falls back to the use of B<link>(), unless the B<AT_SYMLINK_FOLLOW> "
"is specified.  When I<oldpath> and I<newpath> are relative pathnames, glibc "
"constructs pathnames based on the symbolic links in I</proc/self/fd> that "
"correspond to the I<olddirfd> and I<newdirfd> arguments."
msgstr ""

#. type: Plain text
#: man-pages/man2/link.2:424
msgid ""
"On NFS filesystems, the return code may be wrong in case the NFS server "
"performs the link creation and dies before it can say so.  Use B<stat>(2)  "
"to find out if the link got created."
msgstr ""

#. type: Plain text
#: man-pages/man2/link.2:432
msgid ""
"B<ln>(1), B<open>(2), B<rename>(2), B<stat>(2), B<symlink>(2), B<unlink>(2), "
"B<path_resolution>(7), B<symlink>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/listen.2:45
#, no-wrap
msgid "LISTEN"
msgstr ""

#. type: Plain text
#: man-pages/man2/listen.2:48
msgid "listen - listen for connections on a socket"
msgstr ""

#. type: Plain text
#: man-pages/man2/listen.2:54
#, no-wrap
msgid "B<int listen(int >I<sockfd>B<, int >I<backlog>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/listen.2:62
msgid ""
"B<listen>()  marks the socket referred to by I<sockfd> as a passive socket, "
"that is, as a socket that will be used to accept incoming connection "
"requests using B<accept>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/listen.2:69
msgid ""
"The I<sockfd> argument is a file descriptor that refers to a socket of type "
"B<SOCK_STREAM> or B<SOCK_SEQPACKET>."
msgstr ""

#. type: Plain text
#: man-pages/man2/listen.2:81
msgid ""
"The I<backlog> argument defines the maximum length to which the queue of "
"pending connections for I<sockfd> may grow.  If a connection request arrives "
"when the queue is full, the client may receive an error with an indication "
"of B<ECONNREFUSED> or, if the underlying protocol supports retransmission, "
"the request may be ignored so that a later reattempt at connection succeeds."
msgstr ""

#. type: Plain text
#: man-pages/man2/listen.2:90
msgid "Another socket is already listening on the same port."
msgstr ""

#. type: Plain text
#: man-pages/man2/listen.2:118
msgid "The socket is not of a type that supports the B<listen>()  operation."
msgstr ""

#. type: Plain text
#: man-pages/man2/listen.2:122
msgid "POSIX.1-2001, POSIX.1-2008, 4.4BSD (B<listen>()  first appeared in 4.2BSD)."
msgstr ""

#. type: Plain text
#: man-pages/man2/listen.2:124
msgid "To accept connections, the following steps are performed:"
msgstr ""

#. type: Plain text
#: man-pages/man2/listen.2:128
msgid "A socket is created with B<socket>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/listen.2:134
msgid ""
"The socket is bound to a local address using B<bind>(2), so that other "
"sockets may be B<connect>(2)ed to it."
msgstr ""

#. type: Plain text
#: man-pages/man2/listen.2:138
msgid ""
"A willingness to accept incoming connections and a queue limit for incoming "
"connections are specified with B<listen>()."
msgstr ""

#. type: Plain text
#: man-pages/man2/listen.2:141
msgid "Connections are accepted with B<accept>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/listen.2:164
msgid ""
"The behavior of the I<backlog> argument on TCP sockets changed with Linux "
"2.2.  Now it specifies the queue length for I<completely> established "
"sockets waiting to be accepted, instead of the number of incomplete "
"connection requests.  The maximum length of the queue for incomplete sockets "
"can be set using I</proc/sys/net/ipv4/tcp_max_syn_backlog>.  When syncookies "
"are enabled there is no logical maximum length and this setting is ignored.  "
"See B<tcp>(7)  for more information."
msgstr ""

#.  The following is now rather historic information (MTK, Jun 05)
#.  Don't rely on this value in portable applications since BSD
#.  (and some BSD-derived systems) limit the backlog to 5.
#. type: Plain text
#: man-pages/man2/listen.2:177
msgid ""
"If the I<backlog> argument is greater than the value in "
"I</proc/sys/net/core/somaxconn>, then it is silently truncated to that "
"value; the default value in this file is 128.  In kernels before 2.4.25, "
"this limit was a hard coded value, B<SOMAXCONN>, with the value 128."
msgstr ""

#. type: Plain text
#: man-pages/man2/listen.2:180 man-pages/man2/accept.2:373
msgid "See B<bind>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/listen.2:185
msgid "B<accept>(2), B<bind>(2), B<connect>(2), B<socket>(2), B<socket>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/lseek.2:47
#, no-wrap
msgid "LSEEK"
msgstr ""

#. type: Plain text
#: man-pages/man2/lseek.2:50
msgid "lseek - reposition read/write file offset"
msgstr ""

#. type: Plain text
#: man-pages/man2/lseek.2:56
msgid "B<off_t lseek(int >I<fd>B<, off_t >I<offset>B<, int >I<whence>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/lseek.2:66
msgid ""
"B<lseek>()  repositions the file offset of the open file description "
"associated with the file descriptor I<fd> to the argument I<offset> "
"according to the directive I<whence> as follows:"
msgstr ""

#. type: TP
#: man-pages/man2/lseek.2:66
#, no-wrap
msgid "B<SEEK_SET>"
msgstr ""

#. type: Plain text
#: man-pages/man2/lseek.2:71
msgid "The file offset is set to I<offset> bytes."
msgstr ""

#. type: TP
#: man-pages/man2/lseek.2:71
#, no-wrap
msgid "B<SEEK_CUR>"
msgstr ""

#. type: Plain text
#: man-pages/man2/lseek.2:76
msgid "The file offset is set to its current location plus I<offset> bytes."
msgstr ""

#. type: TP
#: man-pages/man2/lseek.2:76
#, no-wrap
msgid "B<SEEK_END>"
msgstr ""

#. type: Plain text
#: man-pages/man2/lseek.2:81
msgid "The file offset is set to the size of the file plus I<offset> bytes."
msgstr ""

#. type: Plain text
#: man-pages/man2/lseek.2:88
msgid ""
"B<lseek>()  allows the file offset to be set beyond the end of the file (but "
"this does not change the size of the file).  If data is later written at "
"this point, subsequent reads of the data in the gap (a \"hole\") return null "
"bytes (\\(aq\\e0\\(aq) until data is actually written into the gap."
msgstr ""

#. type: SS
#: man-pages/man2/lseek.2:88
#, no-wrap
msgid "Seeking file data and holes"
msgstr ""

#. type: Plain text
#: man-pages/man2/lseek.2:91
msgid ""
"Since version 3.1, Linux supports the following additional values for "
"I<whence>:"
msgstr ""

#. type: TP
#: man-pages/man2/lseek.2:91
#, no-wrap
msgid "B<SEEK_DATA>"
msgstr ""

#. type: Plain text
#: man-pages/man2/lseek.2:102
msgid ""
"Adjust the file offset to the next location in the file greater than or "
"equal to I<offset> containing data.  If I<offset> points to data, then the "
"file offset is set to I<offset>."
msgstr ""

#. type: TP
#: man-pages/man2/lseek.2:102
#, no-wrap
msgid "B<SEEK_HOLE>"
msgstr ""

#. type: Plain text
#: man-pages/man2/lseek.2:116
msgid ""
"Adjust the file offset to the next hole in the file greater than or equal to "
"I<offset>.  If I<offset> points into the middle of a hole, then the file "
"offset is set to I<offset>.  If there is no hole past I<offset>, then the "
"file offset is adjusted to the end of the file (i.e., there is an implicit "
"hole at the end of any file)."
msgstr ""

#. type: Plain text
#: man-pages/man2/lseek.2:122
msgid ""
"In both of the above cases, B<lseek>()  fails if I<offset> points past the "
"end of the file."
msgstr ""

#. type: Plain text
#: man-pages/man2/lseek.2:128
msgid ""
"These operations allow applications to map holes in a sparsely allocated "
"file.  This can be useful for applications such as file backup tools, which "
"can save space when creating backups and preserve holes, if they have a "
"mechanism for discovering holes."
msgstr ""

#.  https://lkml.org/lkml/2011/4/22/79
#.  http://lwn.net/Articles/440255/
#.  http://blogs.oracle.com/bonwick/entry/seek_hole_and_seek_data
#. type: Plain text
#: man-pages/man2/lseek.2:151
msgid ""
"For the purposes of these operations, a hole is a sequence of zeros that "
"(normally) has not been allocated in the underlying file storage.  However, "
"a filesystem is not obliged to report holes, so these operations are not a "
"guaranteed mechanism for mapping the storage space actually allocated to a "
"file.  (Furthermore, a sequence of zeros that actually has been written to "
"the underlying storage may not be reported as a hole.)  In the simplest "
"implementation, a filesystem can support the operations by making "
"B<SEEK_HOLE> always return the offset of the end of the file, and making "
"B<SEEK_DATA> always return I<offset> (i.e., even if the location referred to "
"by I<offset> is a hole, it can be considered to consist of data that is a "
"sequence of zeros)."
msgstr ""

#. type: Plain text
#: man-pages/man2/lseek.2:160
msgid ""
"The B<_GNU_SOURCE> feature test macro must be defined in order to obtain the "
"definitions of B<SEEK_DATA> and B<SEEK_HOLE> from I<E<lt>unistd.hE<gt>>."
msgstr ""

#. type: Plain text
#: man-pages/man2/lseek.2:166
msgid ""
"The B<SEEK_HOLE> and B<SEEK_DATA> operations are supported for the following "
"filesystems:"
msgstr ""

#. type: Plain text
#: man-pages/man2/lseek.2:168
msgid "Btrfs (since Linux 3.1)"
msgstr ""

#.  commit 93862d5e1ab875664c6cc95254fc365028a48bb1
#. type: Plain text
#: man-pages/man2/lseek.2:171
msgid "OCFS (since Linux 3.2)"
msgstr ""

#. type: Plain text
#: man-pages/man2/lseek.2:173
msgid "XFS (since Linux 3.5)"
msgstr ""

#. type: Plain text
#: man-pages/man2/lseek.2:175
msgid "ext4 (since Linux 3.8)"
msgstr ""

#. type: Plain text
#: man-pages/man2/lseek.2:178
msgid "B<tmpfs>(5)  (since Linux 3.8)"
msgstr ""

#.  commit 1c6dcbe5ceff81c2cf8d929646af675cd59fe7c0
#.  commit 24bab491220faa446d945624086d838af41d616c
#. type: Plain text
#: man-pages/man2/lseek.2:182
msgid "NFS (since Linux 3.18)"
msgstr ""

#.  commit 0b5da8db145bfd44266ac964a2636a0cf8d7c286
#. type: Plain text
#: man-pages/man2/lseek.2:185
msgid "FUSE (since Linux 4.5)"
msgstr ""

#. type: Plain text
#: man-pages/man2/lseek.2:193
msgid ""
"Upon successful completion, B<lseek>()  returns the resulting offset "
"location as measured in bytes from the beginning of the file.  On error, the "
"value I<(off_t)\\ -1> is returned and I<errno> is set to indicate the error."
msgstr ""

#.  Some systems may allow negative offsets for character devices
#.  and/or for remote filesystems.
#. type: Plain text
#: man-pages/man2/lseek.2:206
msgid ""
"I<whence> is not valid.  Or: the resulting file offset would be negative, or "
"beyond the end of a seekable device."
msgstr ""

#. type: Plain text
#: man-pages/man2/lseek.2:214
msgid ""
"I<whence> is B<SEEK_DATA> or B<SEEK_HOLE>, and the file offset is beyond the "
"end of the file."
msgstr ""

#.  HP-UX 11 says EINVAL for this case (but POSIX.1 says EOVERFLOW)
#. type: Plain text
#: man-pages/man2/lseek.2:219
msgid "The resulting file offset cannot be represented in an I<off_t>."
msgstr ""

#. type: Plain text
#: man-pages/man2/lseek.2:223
msgid "I<fd> is associated with a pipe, socket, or FIFO."
msgstr ""

#.  FIXME . Review http://austingroupbugs.net/view.php?id=415 in the future
#. type: Plain text
#: man-pages/man2/lseek.2:233
msgid ""
"B<SEEK_DATA> and B<SEEK_HOLE> are nonstandard extensions also present in "
"Solaris, FreeBSD, and DragonFly BSD; they are proposed for inclusion in the "
"next POSIX revision (Issue 8)."
msgstr ""

#. type: Plain text
#: man-pages/man2/lseek.2:238
msgid ""
"See B<open>(2)  for a discussion of the relationship between file "
"descriptors, open file descriptions, and files."
msgstr ""

#. type: Plain text
#: man-pages/man2/lseek.2:247
msgid ""
"If the B<O_APPEND> file status flag is set on the open file description, "
"then a B<write>(2)  I<always> moves the file offset to the end of the file, "
"regardless of the use of B<lseek>()."
msgstr ""

#. type: Plain text
#: man-pages/man2/lseek.2:251
msgid "The I<off_t> data type is a signed integer data type specified by POSIX.1."
msgstr ""

#. type: Plain text
#: man-pages/man2/lseek.2:255
msgid ""
"Some devices are incapable of seeking and POSIX does not specify which "
"devices must support B<lseek>()."
msgstr ""

#.  Other systems return the number of written characters,
#.  using SEEK_SET to set the counter. (Of written characters.)
#. type: Plain text
#: man-pages/man2/lseek.2:262
msgid ""
"On Linux, using B<lseek>()  on a terminal device fails with the error "
"B<ESPIPE>."
msgstr ""

#. type: Plain text
#: man-pages/man2/lseek.2:269
msgid ""
"B<dup>(2), B<fallocate>(2), B<fork>(2), B<open>(2), B<fseek>(3), "
"B<lseek64>(3), B<posix_fallocate>(3)"
msgstr ""

#. type: TH
#: man-pages/man2/ioctl_list.2:31
#, no-wrap
msgid "IOCTL_LIST"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_list.2:34
msgid "ioctl_list - list of ioctl calls in Linux/i386 kernel"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_list.2:41
msgid ""
"This is Ioctl List 1.3.27, a list of ioctl calls in Linux/i386 kernel "
"1.3.27.  It contains 421 ioctls from "
"I<E<lt>/usr/include/{asm,linux}/*.hE<gt>>.  For each ioctl, its numerical "
"value, its name, and its argument type are given."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_list.2:49
msgid ""
"An argument type of I<const struct foo\\ *> means the argument is input to "
"the kernel.  I<struct foo\\ *> means the kernel outputs the argument.  If "
"the kernel uses the argument for both input and output, this is marked with "
"I<//\\ I-O>."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_list.2:54
msgid ""
"Some ioctls take more arguments or return more values than a single "
"structure.  These are marked I<//\\ MORE> and documented further in a "
"separate section."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_list.2:56
msgid "This list is very incomplete."
msgstr ""

#. type: SS
#: man-pages/man2/ioctl_list.2:56
#, no-wrap
msgid "ioctl structure"
msgstr ""

#.  added two sections - aeb
#. type: Plain text
#: man-pages/man2/ioctl_list.2:61
msgid ""
"Ioctl command values are 32-bit constants.  In principle these constants are "
"completely arbitrary, but people have tried to build some structure into "
"them."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_list.2:80
msgid ""
"The old Linux situation was that of mostly 16-bit constants, where the last "
"byte is a serial number, and the preceding byte(s) give a type indicating "
"the driver.  Sometimes the major number was used: 0x03 for the B<HDIO_*> "
"ioctls, 0x06 for the B<LP*> ioctls.  And sometimes one or more ASCII letters "
"were used.  For example, B<TCGETS> has value 0x00005401, with 0x54 = "
"\\(aqT\\(aq indicating the terminal driver, and B<CYGETTIMEOUT> has value "
"0x00435906, with 0x43 0x59 = \\(aqC\\(aq \\(aqY\\(aq indicating the cyclades "
"driver."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_list.2:88
msgid ""
"Later (0.98p5) some more information was built into the number.  One has 2 "
"direction bits (00: none, 01: write, 10: read, 11: read/write)  followed by "
"14 size bits (giving the size of the argument), followed by an 8-bit type "
"(collecting the ioctls in groups for a common purpose or a common driver), "
"and an 8-bit serial number."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_list.2:99
msgid ""
"The macros describing this structure live in I<E<lt>asm/ioctl.hE<gt>> and "
"are B<_IO(type,nr)> and B<{_IOR,_IOW,_IOWR}(type,nr,size)>.  They use "
"I<sizeof(size)> so that size is a misnomer here: this third argument is a "
"data type."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_list.2:104
msgid ""
"Note that the size bits are very unreliable: in lots of cases they are "
"wrong, either because of buggy macros using I<sizeof(sizeof(struct))>, or "
"because of legacy values."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_list.2:108
msgid ""
"Thus, it seems that the new structure only gave disadvantages: it does not "
"help in checking, but it causes varying values for the various "
"architectures."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_list.2:114
msgid ""
"Decent ioctls return 0 on success and -1 on error, while any output value is "
"stored via the argument.  However, quite a few ioctls in fact return an "
"output value.  This is not yet indicated below."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_list.2:116
msgid "// Main table."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_list.2:118
msgid "// E<lt>include/asm-i386/socket.hE<gt>"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:120
#, no-wrap
msgid "0x00008901"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:120
#, no-wrap
msgid "FIOSETOWN"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:120 man-pages/man2/ioctl_list.2:121
#: man-pages/man2/ioctl_list.2:152 man-pages/man2/ioctl_list.2:153
#: man-pages/man2/ioctl_list.2:154 man-pages/man2/ioctl_list.2:156
#: man-pages/man2/ioctl_list.2:163 man-pages/man2/ioctl_list.2:164
#: man-pages/man2/ioctl_list.2:166 man-pages/man2/ioctl_list.2:172
#: man-pages/man2/ioctl_list.2:175 man-pages/man2/ioctl_list.2:196
#: man-pages/man2/ioctl_list.2:197 man-pages/man2/ioctl_list.2:309
#: man-pages/man2/ioctl_list.2:370 man-pages/man2/ioctl_list.2:372
#: man-pages/man2/ioctl_list.2:374 man-pages/man2/ioctl_list.2:375
#: man-pages/man2/ioctl_list.2:381 man-pages/man2/ioctl_list.2:382
#: man-pages/man2/ioctl_list.2:383 man-pages/man2/ioctl_list.2:505
#: man-pages/man2/ioctl_list.2:575 man-pages/man2/ioctl_list.2:598
#: man-pages/man2/ioctl_list.2:639 man-pages/man2/ioctl_list.2:677
#: man-pages/man2/ioctl_list.2:678 man-pages/man2/ioctl_list.2:682
#: man-pages/man2/ioctl_list.2:684 man-pages/man2/ioctl_list.2:700
#: man-pages/man2/ioctl_list.2:704
#, no-wrap
msgid "const int *"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:121
#, no-wrap
msgid "0x00008902"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:121
#, no-wrap
msgid "SIOCSPGRP"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:122
#, no-wrap
msgid "0x00008903"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:122
#, no-wrap
msgid "FIOGETOWN"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:122 man-pages/man2/ioctl_list.2:123
#: man-pages/man2/ioctl_list.2:124 man-pages/man2/ioctl_list.2:147
#: man-pages/man2/ioctl_list.2:151 man-pages/man2/ioctl_list.2:155
#: man-pages/man2/ioctl_list.2:157 man-pages/man2/ioctl_list.2:158
#: man-pages/man2/ioctl_list.2:167 man-pages/man2/ioctl_list.2:174
#: man-pages/man2/ioctl_list.2:179 man-pages/man2/ioctl_list.2:264
#: man-pages/man2/ioctl_list.2:266 man-pages/man2/ioctl_list.2:268
#: man-pages/man2/ioctl_list.2:270 man-pages/man2/ioctl_list.2:310
#: man-pages/man2/ioctl_list.2:316 man-pages/man2/ioctl_list.2:317
#: man-pages/man2/ioctl_list.2:318 man-pages/man2/ioctl_list.2:319
#: man-pages/man2/ioctl_list.2:320 man-pages/man2/ioctl_list.2:321
#: man-pages/man2/ioctl_list.2:323 man-pages/man2/ioctl_list.2:324
#: man-pages/man2/ioctl_list.2:325 man-pages/man2/ioctl_list.2:326
#: man-pages/man2/ioctl_list.2:333 man-pages/man2/ioctl_list.2:334
#: man-pages/man2/ioctl_list.2:336 man-pages/man2/ioctl_list.2:337
#: man-pages/man2/ioctl_list.2:338 man-pages/man2/ioctl_list.2:339
#: man-pages/man2/ioctl_list.2:340 man-pages/man2/ioctl_list.2:369
#: man-pages/man2/ioctl_list.2:371 man-pages/man2/ioctl_list.2:373
#: man-pages/man2/ioctl_list.2:376 man-pages/man2/ioctl_list.2:422
#: man-pages/man2/ioctl_list.2:438 man-pages/man2/ioctl_list.2:440
#: man-pages/man2/ioctl_list.2:442 man-pages/man2/ioctl_list.2:462
#: man-pages/man2/ioctl_list.2:466 man-pages/man2/ioctl_list.2:638
#: man-pages/man2/ioctl_list.2:666 man-pages/man2/ioctl_list.2:667
#: man-pages/man2/ioctl_list.2:668 man-pages/man2/ioctl_list.2:679
#: man-pages/man2/ioctl_list.2:680 man-pages/man2/ioctl_list.2:683
#: man-pages/man2/ioctl_list.2:694 man-pages/man2/ioctl_list.2:698
#: man-pages/man2/ioctl_list.2:699 man-pages/man2/ioctl_list.2:701
#: man-pages/man2/ioctl_list.2:703 man-pages/man2/ioctl_list.2:714
#: man-pages/man2/ioctl_list.2:715 man-pages/man2/ioctl_list.2:716
#: man-pages/man2/ioctl_list.2:717 man-pages/man2/ioctl_list.2:718
#: man-pages/man2/ioctl_list.2:720 man-pages/man2/ioctl_list.2:721
#: man-pages/man2/ioctl_list.2:722 man-pages/man2/ioctl_list.2:723
#: man-pages/man2/ioctl_list.2:730 man-pages/man2/ioctl_list.2:731
#: man-pages/man2/ioctl_list.2:732 man-pages/man2/ioctl_list.2:733
#: man-pages/man2/ioctl_list.2:756 man-pages/man2/ioctl_list.2:757
#: man-pages/man2/ioctl_list.2:758 man-pages/man2/ioctl_list.2:759
#: man-pages/man2/ioctl_list.2:760 man-pages/man2/ioctl_list.2:761
#: man-pages/man2/ioctl_list.2:762 man-pages/man2/ioctl_list.2:763
#: man-pages/man2/ioctl_list.2:764 man-pages/man2/ioctl_list.2:765
#: man-pages/man2/ioctl_list.2:766 man-pages/man2/ioctl_list.2:767
#: man-pages/man2/ioctl_list.2:768 man-pages/man2/ioctl_list.2:769
#: man-pages/man2/ioctl_list.2:770 man-pages/man2/ioctl_list.2:771
#: man-pages/man2/ioctl_list.2:772 man-pages/man2/ioctl_list.2:773
#: man-pages/man2/ioctl_list.2:774 man-pages/man2/ioctl_list.2:775
#: man-pages/man2/ioctl_list.2:776 man-pages/man2/ioctl_list.2:777
#: man-pages/man2/ioctl_list.2:778 man-pages/man2/ioctl_list.2:779
#: man-pages/man2/ioctl_list.2:780 man-pages/man2/ioctl_list.2:784
#: man-pages/man2/ioctl_list.2:785 man-pages/man2/ioctl_list.2:786
#: man-pages/man2/ioctl_list.2:787 man-pages/man2/ioctl_list.2:788
#: man-pages/man2/ioctl_list.2:789 man-pages/man2/ioctl_list.2:790
#: man-pages/man2/ioctl_list.2:791 man-pages/man2/ioctl_list.2:792
#: man-pages/man2/ioctl_list.2:793 man-pages/man2/ioctl_list.2:794
#: man-pages/man2/ioctl_list.2:795 man-pages/man2/ioctl_list.2:796
#: man-pages/man2/ioctl_list.2:797 man-pages/man2/ioctl_list.2:798
#: man-pages/man2/ioctl_list.2:799 man-pages/man2/ioctl_list.2:800
#: man-pages/man2/ioctl_list.2:801 man-pages/man2/ioctl_list.2:802
#: man-pages/man2/ioctl_list.2:803 man-pages/man2/ioctl_list.2:804
#: man-pages/man2/ioctl_list.2:833
#, no-wrap
msgid "int *"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:123
#, no-wrap
msgid "0x00008904"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:123
#, no-wrap
msgid "SIOCGPGRP"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:124
#, no-wrap
msgid "0x00008905"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:124
#, no-wrap
msgid "SIOCATMAR"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:125
#, no-wrap
msgid "0x00008906"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:125
#, no-wrap
msgid "SIOCGSTAMP"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:125
#, no-wrap
msgid "timeval *"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_list.2:129
msgid "// E<lt>include/asm-i386/termios.hE<gt>"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:131
#, no-wrap
msgid "0x00005401"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:131
#, no-wrap
msgid "TCGETS"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:131 man-pages/man2/ioctl_list.2:176
#, no-wrap
msgid "struct termios *"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:132 man-pages/man2/ioctl_list.2:695
#: man-pages/man2/ioctl_list.2:1036
#, no-wrap
msgid "0x00005402"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:132 man-pages/man2/ioctl_list.2:1036
#, no-wrap
msgid "TCSETS"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:132 man-pages/man2/ioctl_list.2:133
#: man-pages/man2/ioctl_list.2:134 man-pages/man2/ioctl_list.2:177
#, no-wrap
msgid "const struct termios *"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:133 man-pages/man2/ioctl_list.2:696
#: man-pages/man2/ioctl_list.2:1037
#, no-wrap
msgid "0x00005403"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:133 man-pages/man2/ioctl_list.2:1037
#, no-wrap
msgid "TCSETSW"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:134 man-pages/man2/ioctl_list.2:697
#: man-pages/man2/ioctl_list.2:1038
#, no-wrap
msgid "0x00005404"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:134 man-pages/man2/ioctl_list.2:1038
#, no-wrap
msgid "TCSETSF"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:135
#, no-wrap
msgid "0x00005405"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:135
#, no-wrap
msgid "TCGETA"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:135
#, no-wrap
msgid "struct termio *"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:136
#, no-wrap
msgid "0x00005406"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:136
#, no-wrap
msgid "TCSETA"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:136 man-pages/man2/ioctl_list.2:137
#: man-pages/man2/ioctl_list.2:138
#, no-wrap
msgid "const struct termio *"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:137
#, no-wrap
msgid "0x00005407"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:137
#, no-wrap
msgid "TCSETAW"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:138
#, no-wrap
msgid "0x00005408"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:138
#, no-wrap
msgid "TCSETAF"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:139
#, no-wrap
msgid "0x00005409"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:139
#, no-wrap
msgid "TCSBRK"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:139 man-pages/man2/ioctl_list.2:140
#: man-pages/man2/ioctl_list.2:141 man-pages/man2/ioctl_list.2:144
#: man-pages/man2/ioctl_list.2:168 man-pages/man2/ioctl_list.2:237
#: man-pages/man2/ioctl_list.2:256 man-pages/man2/ioctl_list.2:257
#: man-pages/man2/ioctl_list.2:265 man-pages/man2/ioctl_list.2:267
#: man-pages/man2/ioctl_list.2:269 man-pages/man2/ioctl_list.2:271
#: man-pages/man2/ioctl_list.2:286 man-pages/man2/ioctl_list.2:295
#: man-pages/man2/ioctl_list.2:341 man-pages/man2/ioctl_list.2:342
#: man-pages/man2/ioctl_list.2:343 man-pages/man2/ioctl_list.2:344
#: man-pages/man2/ioctl_list.2:345 man-pages/man2/ioctl_list.2:346
#: man-pages/man2/ioctl_list.2:412 man-pages/man2/ioctl_list.2:413
#: man-pages/man2/ioctl_list.2:415 man-pages/man2/ioctl_list.2:417
#: man-pages/man2/ioctl_list.2:418 man-pages/man2/ioctl_list.2:421
#: man-pages/man2/ioctl_list.2:439 man-pages/man2/ioctl_list.2:441
#: man-pages/man2/ioctl_list.2:443 man-pages/man2/ioctl_list.2:452
#: man-pages/man2/ioctl_list.2:458 man-pages/man2/ioctl_list.2:459
#: man-pages/man2/ioctl_list.2:460 man-pages/man2/ioctl_list.2:461
#: man-pages/man2/ioctl_list.2:463 man-pages/man2/ioctl_list.2:464
#: man-pages/man2/ioctl_list.2:465 man-pages/man2/ioctl_list.2:576
#: man-pages/man2/ioctl_list.2:838 man-pages/man2/ioctl_list.2:839
#: man-pages/man2/ioctl_list.2:840 man-pages/man2/ioctl_list.2:841
#, no-wrap
msgid "int"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:140
#, no-wrap
msgid "0x0000540A"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:140
#, no-wrap
msgid "TCXONC"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:141
#, no-wrap
msgid "0x0000540B"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:141
#, no-wrap
msgid "TCFLSH"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:142
#, no-wrap
msgid "0x0000540C"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:142
#, no-wrap
msgid "TIOCEXCL"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:142 man-pages/man2/ioctl_list.2:143
#: man-pages/man2/ioctl_list.2:160 man-pages/man2/ioctl_list.2:165
#: man-pages/man2/ioctl_list.2:170 man-pages/man2/ioctl_list.2:171
#: man-pages/man2/ioctl_list.2:173 man-pages/man2/ioctl_list.2:208
#: man-pages/man2/ioctl_list.2:209 man-pages/man2/ioctl_list.2:210
#: man-pages/man2/ioctl_list.2:211 man-pages/man2/ioctl_list.2:217
#: man-pages/man2/ioctl_list.2:218 man-pages/man2/ioctl_list.2:229
#: man-pages/man2/ioctl_list.2:230 man-pages/man2/ioctl_list.2:231
#: man-pages/man2/ioctl_list.2:246 man-pages/man2/ioctl_list.2:277
#: man-pages/man2/ioctl_list.2:281 man-pages/man2/ioctl_list.2:282
#: man-pages/man2/ioctl_list.2:283 man-pages/man2/ioctl_list.2:285
#: man-pages/man2/ioctl_list.2:287 man-pages/man2/ioctl_list.2:297
#: man-pages/man2/ioctl_list.2:303 man-pages/man2/ioctl_list.2:311
#: man-pages/man2/ioctl_list.2:313 man-pages/man2/ioctl_list.2:419
#: man-pages/man2/ioctl_list.2:420 man-pages/man2/ioctl_list.2:423
#: man-pages/man2/ioctl_list.2:424 man-pages/man2/ioctl_list.2:467
#: man-pages/man2/ioctl_list.2:504 man-pages/man2/ioctl_list.2:582
#: man-pages/man2/ioctl_list.2:615 man-pages/man2/ioctl_list.2:641
#: man-pages/man2/ioctl_list.2:642 man-pages/man2/ioctl_list.2:645
#: man-pages/man2/ioctl_list.2:646 man-pages/man2/ioctl_list.2:660
#: man-pages/man2/ioctl_list.2:661 man-pages/man2/ioctl_list.2:669
#: man-pages/man2/ioctl_list.2:686 man-pages/man2/ioctl_list.2:695
#: man-pages/man2/ioctl_list.2:696 man-pages/man2/ioctl_list.2:697
#: man-pages/man2/ioctl_list.2:712 man-pages/man2/ioctl_list.2:713
#: man-pages/man2/ioctl_list.2:719 man-pages/man2/ioctl_list.2:729
#: man-pages/man2/ioctl_list.2:734 man-pages/man2/ioctl_list.2:825
#: man-pages/man2/ioctl_list.2:837
#, no-wrap
msgid "void"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:143
#, no-wrap
msgid "0x0000540D"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:143
#, no-wrap
msgid "TIOCNXCL"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:144
#, no-wrap
msgid "0x0000540E"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:144
#, no-wrap
msgid "TIOCSCTTY"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:145
#, no-wrap
msgid "0x0000540F"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:145
#, no-wrap
msgid "TIOCGPGRP"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:145
#, no-wrap
msgid "pid_t *"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:146
#, no-wrap
msgid "0x00005410"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:146
#, no-wrap
msgid "TIOCSPGRP"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:146
#, no-wrap
msgid "const pid_t *"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:147
#, no-wrap
msgid "0x00005411"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:147
#, no-wrap
msgid "TIOCOUTQ"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:148
#, no-wrap
msgid "0x00005412"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:148
#, no-wrap
msgid "TIOCSTI"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:148 man-pages/man2/ioctl_list.2:159
#: man-pages/man2/ioctl_list.2:389 man-pages/man2/ioctl_list.2:390
#, no-wrap
msgid "const char *"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:149
#, no-wrap
msgid "0x00005413"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:149
#, no-wrap
msgid "TIOCGWINSZ"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:149
#, no-wrap
msgid "struct winsize *"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:150
#, no-wrap
msgid "0x00005414"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:150
#, no-wrap
msgid "TIOCSWINSZ"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:150
#, no-wrap
msgid "const struct winsize *"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:151
#, no-wrap
msgid "0x00005415"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:151
#, no-wrap
msgid "TIOCMGET"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:152
#, no-wrap
msgid "0x00005416"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:152
#, no-wrap
msgid "TIOCMBIS"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:153
#, no-wrap
msgid "0x00005417"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:153
#, no-wrap
msgid "TIOCMBIC"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:154
#, no-wrap
msgid "0x00005418"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:154
#, no-wrap
msgid "TIOCMSET"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:155
#, no-wrap
msgid "0x00005419"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:155
#, no-wrap
msgid "TIOCGSOFTCAR"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:156
#, no-wrap
msgid "0x0000541A"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:156
#, no-wrap
msgid "TIOCSSOFTCAR"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:157 man-pages/man2/ioctl_list.2:158
#, no-wrap
msgid "0x0000541B"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:157
#, no-wrap
msgid "FIONREAD"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:158
#, no-wrap
msgid "TIOCINQ"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:159
#, no-wrap
msgid "0x0000541C"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:159
#, no-wrap
msgid "TIOCLINUX"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:159 man-pages/man2/ioctl_list.2:234
#: man-pages/man2/ioctl_list.2:235 man-pages/man2/ioctl_list.2:236
#: man-pages/man2/ioctl_list.2:248 man-pages/man2/ioctl_list.2:249
#: man-pages/man2/ioctl_list.2:417 man-pages/man2/ioctl_list.2:418
#: man-pages/man2/ioctl_list.2:419 man-pages/man2/ioctl_list.2:420
#: man-pages/man2/ioctl_list.2:423 man-pages/man2/ioctl_list.2:424
#: man-pages/man2/ioctl_list.2:436 man-pages/man2/ioctl_list.2:598
#: man-pages/man2/ioctl_list.2:612 man-pages/man2/ioctl_list.2:613
#: man-pages/man2/ioctl_list.2:637
#, no-wrap
msgid "// MORE"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:160
#, no-wrap
msgid "0x0000541D"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:160
#, no-wrap
msgid "TIOCCONS"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:161
#, no-wrap
msgid "0x0000541E"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:161
#, no-wrap
msgid "TIOCGSERIAL"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:161
#, no-wrap
msgid "struct serial_struct *"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:162
#, no-wrap
msgid "0x0000541F"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:162
#, no-wrap
msgid "TIOCSSERIAL"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:162
#, no-wrap
msgid "const struct serial_struct *"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:163
#, no-wrap
msgid "0x00005420"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:163
#, no-wrap
msgid "TIOCPKT"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:164
#, no-wrap
msgid "0x00005421"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:164
#, no-wrap
msgid "FIONBIO"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:165
#, no-wrap
msgid "0x00005422"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:165
#, no-wrap
msgid "TIOCNOTTY"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:166
#, no-wrap
msgid "0x00005423"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:166
#, no-wrap
msgid "TIOCSETD"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:167
#, no-wrap
msgid "0x00005424"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:167
#, no-wrap
msgid "TIOCGETD"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:168
#, no-wrap
msgid "0x00005425"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:168
#, no-wrap
msgid "TCSBRKP"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:169
#, no-wrap
msgid "0x00005426"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:169
#, no-wrap
msgid "TIOCTTYGSTRUCT"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:169
#, no-wrap
msgid "struct tty_struct *"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:170
#, no-wrap
msgid "0x00005450"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:170
#, no-wrap
msgid "FIONCLEX"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:171
#, no-wrap
msgid "0x00005451"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:171
#, no-wrap
msgid "FIOCLEX"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:172
#, no-wrap
msgid "0x00005452"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:172
#, no-wrap
msgid "FIOASYNC"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:173
#, no-wrap
msgid "0x00005453"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:173
#, no-wrap
msgid "TIOCSERCONFIG"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:174
#, no-wrap
msgid "0x00005454"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:174
#, no-wrap
msgid "TIOCSERGWILD"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:175
#, no-wrap
msgid "0x00005455"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:175
#, no-wrap
msgid "TIOCSERSWILD"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:176
#, no-wrap
msgid "0x00005456"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:176
#, no-wrap
msgid "TIOCGLCKTRMIOS"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:177
#, no-wrap
msgid "0x00005457"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:177
#, no-wrap
msgid "TIOCSLCKTRMIOS"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:178
#, no-wrap
msgid "0x00005458"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:178
#, no-wrap
msgid "TIOCSERGSTRUCT"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:178
#, no-wrap
msgid "struct async_struct *"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:179
#, no-wrap
msgid "0x00005459"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:179
#, no-wrap
msgid "TIOCSERGETLSR"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:186
#, no-wrap
msgid "0x0000545A"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:186
#, no-wrap
msgid "TIOCSERGETMULTI"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:186
#, no-wrap
msgid "struct serial_multiport_struct *"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:187
#, no-wrap
msgid "0x0000545B"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:187
#, no-wrap
msgid "TIOCSERSETMULTI"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:187
#, no-wrap
msgid "const struct serial_multiport_struct *"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_list.2:191
msgid "// E<lt>include/linux/ax25.hE<gt>"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:193 man-pages/man2/ioctl_list.2:389
#: man-pages/man2/ioctl_list.2:474 man-pages/man2/ioctl_list.2:502
#, no-wrap
msgid "0x000089E0"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:193
#, no-wrap
msgid "SIOCAX25GETUID"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:193 man-pages/man2/ioctl_list.2:194
#: man-pages/man2/ioctl_list.2:195
#, no-wrap
msgid "const struct sockaddr_ax25 *"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:194 man-pages/man2/ioctl_list.2:390
#: man-pages/man2/ioctl_list.2:475 man-pages/man2/ioctl_list.2:503
#, no-wrap
msgid "0x000089E1"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:194
#, no-wrap
msgid "SIOCAX25ADDUID"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:195 man-pages/man2/ioctl_list.2:391
#: man-pages/man2/ioctl_list.2:504
#, no-wrap
msgid "0x000089E2"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:195
#, no-wrap
msgid "SIOCAX25DELUID"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:196 man-pages/man2/ioctl_list.2:505
#, no-wrap
msgid "0x000089E3"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:196
#, no-wrap
msgid "SIOCAX25NOUID"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:197
#, no-wrap
msgid "0x000089E4"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:197
#, no-wrap
msgid "SIOCAX25DIGCTL"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:198
#, no-wrap
msgid "0x000089E5"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:198
#, no-wrap
msgid "SIOCAX25GETPARMS"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:198
#, no-wrap
msgid "struct ax25_parms_struct *"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:198 man-pages/man2/ioctl_list.2:225
#: man-pages/man2/ioctl_list.2:233 man-pages/man2/ioctl_list.2:241
#: man-pages/man2/ioctl_list.2:316 man-pages/man2/ioctl_list.2:340
#: man-pages/man2/ioctl_list.2:363 man-pages/man2/ioctl_list.2:444
#: man-pages/man2/ioctl_list.2:446 man-pages/man2/ioctl_list.2:450
#: man-pages/man2/ioctl_list.2:474 man-pages/man2/ioctl_list.2:475
#: man-pages/man2/ioctl_list.2:502 man-pages/man2/ioctl_list.2:584
#: man-pages/man2/ioctl_list.2:617 man-pages/man2/ioctl_list.2:619
#: man-pages/man2/ioctl_list.2:621 man-pages/man2/ioctl_list.2:623
#: man-pages/man2/ioctl_list.2:625 man-pages/man2/ioctl_list.2:627
#: man-pages/man2/ioctl_list.2:629 man-pages/man2/ioctl_list.2:631
#: man-pages/man2/ioctl_list.2:636 man-pages/man2/ioctl_list.2:640
#: man-pages/man2/ioctl_list.2:648 man-pages/man2/ioctl_list.2:651
#: man-pages/man2/ioctl_list.2:653 man-pages/man2/ioctl_list.2:665
#: man-pages/man2/ioctl_list.2:666 man-pages/man2/ioctl_list.2:681
#: man-pages/man2/ioctl_list.2:683 man-pages/man2/ioctl_list.2:685
#: man-pages/man2/ioctl_list.2:694 man-pages/man2/ioctl_list.2:698
#: man-pages/man2/ioctl_list.2:699 man-pages/man2/ioctl_list.2:701
#: man-pages/man2/ioctl_list.2:702 man-pages/man2/ioctl_list.2:703
#: man-pages/man2/ioctl_list.2:708 man-pages/man2/ioctl_list.2:714
#: man-pages/man2/ioctl_list.2:715 man-pages/man2/ioctl_list.2:716
#: man-pages/man2/ioctl_list.2:717 man-pages/man2/ioctl_list.2:718
#: man-pages/man2/ioctl_list.2:720 man-pages/man2/ioctl_list.2:721
#: man-pages/man2/ioctl_list.2:723 man-pages/man2/ioctl_list.2:739
#: man-pages/man2/ioctl_list.2:740 man-pages/man2/ioctl_list.2:749
#: man-pages/man2/ioctl_list.2:750 man-pages/man2/ioctl_list.2:784
#: man-pages/man2/ioctl_list.2:785 man-pages/man2/ioctl_list.2:786
#: man-pages/man2/ioctl_list.2:787 man-pages/man2/ioctl_list.2:788
#: man-pages/man2/ioctl_list.2:789 man-pages/man2/ioctl_list.2:790
#: man-pages/man2/ioctl_list.2:791 man-pages/man2/ioctl_list.2:792
#: man-pages/man2/ioctl_list.2:793 man-pages/man2/ioctl_list.2:794
#: man-pages/man2/ioctl_list.2:795 man-pages/man2/ioctl_list.2:796
#: man-pages/man2/ioctl_list.2:797 man-pages/man2/ioctl_list.2:798
#: man-pages/man2/ioctl_list.2:799 man-pages/man2/ioctl_list.2:800
#: man-pages/man2/ioctl_list.2:801 man-pages/man2/ioctl_list.2:802
#: man-pages/man2/ioctl_list.2:803 man-pages/man2/ioctl_list.2:804
#: man-pages/man2/ioctl_list.2:817 man-pages/man2/ioctl_list.2:820
#: man-pages/man2/ioctl_list.2:823
#, no-wrap
msgid "// I-O"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:202
#, no-wrap
msgid "0x000089E6"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:202
#, no-wrap
msgid "SIOCAX25SETPARMS"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:202
#, no-wrap
msgid "const struct ax25_parms_struct *"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_list.2:206
msgid "// E<lt>include/linux/cdk.hE<gt>"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:208
#, no-wrap
msgid "0x00007314"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:208
#, no-wrap
msgid "STL_BINTR"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:209
#, no-wrap
msgid "0x00007315"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:209
#, no-wrap
msgid "STL_BSTART"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:210
#, no-wrap
msgid "0x00007316"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:210
#, no-wrap
msgid "STL_BSTOP"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:211
#, no-wrap
msgid "0x00007317"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:211
#, no-wrap
msgid "STL_BRESET"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_list.2:215
msgid "// E<lt>include/linux/cdrom.hE<gt>"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:217
#, no-wrap
msgid "0x00005301"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:217
#, no-wrap
msgid "CDROMPAUSE"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:218
#, no-wrap
msgid "0x00005302"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:218
#, no-wrap
msgid "CDROMRESUME"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:219
#, no-wrap
msgid "0x00005303"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:219
#, no-wrap
msgid "CDROMPLAYMSF"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:219 man-pages/man2/ioctl_list.2:234
#: man-pages/man2/ioctl_list.2:235 man-pages/man2/ioctl_list.2:248
#: man-pages/man2/ioctl_list.2:249 man-pages/man2/ioctl_list.2:250
#, no-wrap
msgid "const struct cdrom_msf *"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:220
#, no-wrap
msgid "0x00005304"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:220
#, no-wrap
msgid "CDROMPLAYTRKIND"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:220
#, no-wrap
msgid "const struct cdrom_ti *"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:221
#, no-wrap
msgid "0x00005305"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:221
#, no-wrap
msgid "CDROMREADTOCHDR"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:221
#, no-wrap
msgid "struct cdrom_tochdr *"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:225
#, no-wrap
msgid "0x00005306"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:225
#, no-wrap
msgid "CDROMREADTOCENTRY"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:225
#, no-wrap
msgid "struct cdrom_tocentry *"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:229
#, no-wrap
msgid "0x00005307"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:229
#, no-wrap
msgid "CDROMSTOP"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:230
#, no-wrap
msgid "0x00005308"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:230
#, no-wrap
msgid "CDROMSTART"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:231
#, no-wrap
msgid "0x00005309"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:231
#, no-wrap
msgid "CDROMEJECT"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:232
#, no-wrap
msgid "0x0000530A"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:232
#, no-wrap
msgid "CDROMVOLCTRL"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:232
#, no-wrap
msgid "const struct cdrom_volctrl *"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:233
#, no-wrap
msgid "0x0000530B"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:233
#, no-wrap
msgid "CDROMSUBCHNL"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:233
#, no-wrap
msgid "struct cdrom_subchnl *"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:234
#, no-wrap
msgid "0x0000530C"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:234
#, no-wrap
msgid "CDROMREADMODE2"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:235
#, no-wrap
msgid "0x0000530D"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:235
#, no-wrap
msgid "CDROMREADMODE1"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:236
#, no-wrap
msgid "0x0000530E"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:236
#, no-wrap
msgid "CDROMREADAUDIO"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:236
#, no-wrap
msgid "const struct cdrom_read_audio *"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:237
#, no-wrap
msgid "0x0000530F"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:237
#, no-wrap
msgid "CDROMEJECT_SW"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:241
#, no-wrap
msgid "0x00005310"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:241
#, no-wrap
msgid "CDROMMULTISESSION"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:241
#, no-wrap
msgid "struct cdrom_multisession *"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:245
#, no-wrap
msgid "0x00005311"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:245
#, no-wrap
msgid "CDROM_GET_UPC"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:245
#, no-wrap
msgid "struct { char [8]; } *"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:246
#, no-wrap
msgid "0x00005312"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:246
#, no-wrap
msgid "CDROMRESET"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:247
#, no-wrap
msgid "0x00005313"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:247
#, no-wrap
msgid "CDROMVOLREAD"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:247
#, no-wrap
msgid "struct cdrom_volctrl *"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:248
#, no-wrap
msgid "0x00005314"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:248
#, no-wrap
msgid "CDROMREADRAW"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:249
#, no-wrap
msgid "0x00005315"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:249
#, no-wrap
msgid "CDROMREADCOOKED"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:250
#, no-wrap
msgid "0x00005316"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:250
#, no-wrap
msgid "CDROMSEEK"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_list.2:254
msgid "// E<lt>include/linux/cm206.hE<gt>"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:256
#, no-wrap
msgid "0x00002000"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:256
#, no-wrap
msgid "CM206CTL_GET_STAT"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:257
#, no-wrap
msgid "0x00002001"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:257
#, no-wrap
msgid "CM206CTL_GET_LAST_STAT"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_list.2:261
msgid "// E<lt>include/linux/cyclades.hE<gt>"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:263
#, no-wrap
msgid "0x00435901"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:263
#, no-wrap
msgid "CYGETMON"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:263
#, no-wrap
msgid "struct cyclades_monitor *"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:264
#, no-wrap
msgid "0x00435902"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:264
#, no-wrap
msgid "CYGETTHRESH"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:265
#, no-wrap
msgid "0x00435903"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:265
#, no-wrap
msgid "CYSETTHRESH"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:266
#, no-wrap
msgid "0x00435904"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:266
#, no-wrap
msgid "CYGETDEFTHRESH"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:267
#, no-wrap
msgid "0x00435905"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:267
#, no-wrap
msgid "CYSETDEFTHRESH"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:268
#, no-wrap
msgid "0x00435906"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:268
#, no-wrap
msgid "CYGETTIMEOUT"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:269
#, no-wrap
msgid "0x00435907"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:269
#, no-wrap
msgid "CYSETTIMEOUT"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:270
#, no-wrap
msgid "0x00435908"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:270
#, no-wrap
msgid "CYGETDEFTIMEOUT"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:271
#, no-wrap
msgid "0x00435909"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:271
#, no-wrap
msgid "CYSETDEFTIMEOUT"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_list.2:275
msgid "// E<lt>include/linux/fd.hE<gt>"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:277
#, no-wrap
msgid "0x00000000"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:277
#, no-wrap
msgid "FDCLRPRM"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:278 man-pages/man2/ioctl_list.2:316
#: man-pages/man2/ioctl_list.2:1033
#, no-wrap
msgid "0x00000001"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:278 man-pages/man2/ioctl_list.2:1033
#, no-wrap
msgid "FDSETPRM"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:278 man-pages/man2/ioctl_list.2:279
#, no-wrap
msgid "const struct floppy_struct *"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:279 man-pages/man2/ioctl_list.2:317
#: man-pages/man2/ioctl_list.2:1034
#, no-wrap
msgid "0x00000002"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:279 man-pages/man2/ioctl_list.2:1034
#, no-wrap
msgid "FDDEFPRM"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:280
#, no-wrap
msgid "0x00000003"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:280
#, no-wrap
msgid "FDGETPRM"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:280
#, no-wrap
msgid "struct floppy_struct *"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:281
#, no-wrap
msgid "0x00000004"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:281
#, no-wrap
msgid "FDMSGON"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:282
#, no-wrap
msgid "0x00000005"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:282
#, no-wrap
msgid "FDMSGOFF"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:283
#, no-wrap
msgid "0x00000006"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:283
#, no-wrap
msgid "FDFMTBEG"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:284
#, no-wrap
msgid "0x00000007"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:284
#, no-wrap
msgid "FDFMTTRK"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:284
#, no-wrap
msgid "const struct format_descr *"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:285
#, no-wrap
msgid "0x00000008"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:285
#, no-wrap
msgid "FDFMTEND"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:286
#, no-wrap
msgid "0x0000000A"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:286
#, no-wrap
msgid "FDSETEMSGTRESH"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:287
#, no-wrap
msgid "0x0000000B"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:287
#, no-wrap
msgid "FDFLUSH"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:288
#, no-wrap
msgid "0x0000000C"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:288
#, no-wrap
msgid "FDSETMAXERRS"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:288
#, no-wrap
msgid "const struct floppy_max_errors *"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:289
#, no-wrap
msgid "0x0000000E"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:289
#, no-wrap
msgid "FDGETMAXERRS"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:289
#, no-wrap
msgid "struct floppy_max_errors *"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:290
#, no-wrap
msgid "0x00000010"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:290
#, no-wrap
msgid "FDGETDRVTYP"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:290
#, no-wrap
msgid "struct { char [16]; } *"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:291
#, no-wrap
msgid "0x00000014"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:291
#, no-wrap
msgid "FDSETDRVPRM"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:291
#, no-wrap
msgid "const struct floppy_drive_params *"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:292
#, no-wrap
msgid "0x00000015"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:292
#, no-wrap
msgid "FDGETDRVPRM"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:292
#, no-wrap
msgid "struct floppy_drive_params *"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:293
#, no-wrap
msgid "0x00000016"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:293
#, no-wrap
msgid "FDGETDRVSTAT"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:293 man-pages/man2/ioctl_list.2:294
#, no-wrap
msgid "struct floppy_drive_struct *"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:294
#, no-wrap
msgid "0x00000017"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:294
#, no-wrap
msgid "FDPOLLDRVSTAT"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:295
#, no-wrap
msgid "0x00000018"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:295
#, no-wrap
msgid "FDRESET"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:296
#, no-wrap
msgid "0x00000019"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:296
#, no-wrap
msgid "FDGETFDCSTAT"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:296
#, no-wrap
msgid "struct floppy_fdc_state *"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:297
#, no-wrap
msgid "0x0000001B"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:297
#, no-wrap
msgid "FDWERRORCLR"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:298
#, no-wrap
msgid "0x0000001C"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:298
#, no-wrap
msgid "FDWERRORGET"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:298
#, no-wrap
msgid "struct floppy_write_errors *"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:302
#, no-wrap
msgid "0x0000001E"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:302
#, no-wrap
msgid "FDRAWCMD"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:302
#, no-wrap
msgid "struct floppy_raw_cmd *"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:302 man-pages/man2/ioctl_list.2:352
#: man-pages/man2/ioctl_list.2:353 man-pages/man2/ioctl_list.2:354
#: man-pages/man2/ioctl_list.2:355 man-pages/man2/ioctl_list.2:356
#: man-pages/man2/ioctl_list.2:357 man-pages/man2/ioctl_list.2:402
#: man-pages/man2/ioctl_list.2:435 man-pages/man2/ioctl_list.2:616
#, no-wrap
msgid "// MORE // I-O"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:303
#, no-wrap
msgid "0x00000028"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:303
#, no-wrap
msgid "FDTWADDLE"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_list.2:307
msgid "// E<lt>include/linux/fs.hE<gt>"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:309
#, no-wrap
msgid "0x0000125D"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:309
#, no-wrap
msgid "BLKROSET"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:310
#, no-wrap
msgid "0x0000125E"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:310
#, no-wrap
msgid "BLKROGET"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:311
#, no-wrap
msgid "0x0000125F"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:311
#, no-wrap
msgid "BLKRRPART"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:312
#, no-wrap
msgid "0x00001260"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:312
#, no-wrap
msgid "BLKGETSIZE"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:312 man-pages/man2/ioctl_list.2:315
#, no-wrap
msgid "unsigned long *"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:313
#, no-wrap
msgid "0x00001261"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:313
#, no-wrap
msgid "BLKFLSBUF"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:314
#, no-wrap
msgid "0x00001262"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:314
#, no-wrap
msgid "BLKRASET"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:314
#, no-wrap
msgid "unsigned long"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:315
#, no-wrap
msgid "0x00001263"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:315
#, no-wrap
msgid "BLKRAGET"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:316 man-pages/man2/ioctl_list.2:1033
#, no-wrap
msgid "FIBMAP"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:317 man-pages/man2/ioctl_list.2:1034
#, no-wrap
msgid "FIGETBSZ"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:318
#, no-wrap
msgid "0x80086601"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:318
#, no-wrap
msgid "FS_IOC_GETFLAGS"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:319 man-pages/man2/ioctl_list.2:323
#: man-pages/man2/ioctl_list.2:324
#, no-wrap
msgid "0x40086602"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:319
#, no-wrap
msgid "FS_IOC_SETFLAGS"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:320
#, no-wrap
msgid "0x80087601"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:320
#, no-wrap
msgid "FS_IOC_GETVERSION"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:321
#, no-wrap
msgid "0x40087602"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:321
#, no-wrap
msgid "FS_IOC_SETVERSION"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:322
#, no-wrap
msgid "0xC020660B"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:322
#, no-wrap
msgid "FS_IOC_FIEMAP"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:322
#, no-wrap
msgid "struct fiemap *"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:323 man-pages/man2/ioctl_list.2:324
#, no-wrap
msgid "FS_IOC32_SETFLAGS"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:325
#, no-wrap
msgid "0x80047601"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:325
#, no-wrap
msgid "FS_IOC32_GETVERSION"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:326
#, no-wrap
msgid "0x40047602"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:326
#, no-wrap
msgid "FS_IOC32_SETVERSION"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_list.2:330
msgid "// E<lt>include/linux/hdreg.hE<gt>"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:332
#, no-wrap
msgid "0x00000301"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:332
#, no-wrap
msgid "HDIO_GETGEO"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:332
#, no-wrap
msgid "struct hd_geometry *"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:333
#, no-wrap
msgid "0x00000302"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:333
#, no-wrap
msgid "HDIO_GET_UNMASKINTR"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:334
#, no-wrap
msgid "0x00000304"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:334
#, no-wrap
msgid "HDIO_GET_MULTCOUNT"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:335
#, no-wrap
msgid "0x00000307"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:335
#, no-wrap
msgid "HDIO_GET_IDENTITY"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:335
#, no-wrap
msgid "struct hd_driveid *"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:336
#, no-wrap
msgid "0x00000308"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:336
#, no-wrap
msgid "HDIO_GET_KEEPSETTINGS"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:337
#, no-wrap
msgid "0x00000309"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:337
#, no-wrap
msgid "HDIO_GET_CHIPSET"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:338
#, no-wrap
msgid "0x0000030A"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:338
#, no-wrap
msgid "HDIO_GET_NOWERR"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:339
#, no-wrap
msgid "0x0000030B"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:339
#, no-wrap
msgid "HDIO_GET_DMA"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:340
#, no-wrap
msgid "0x0000031F"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:340
#, no-wrap
msgid "HDIO_DRIVE_CMD"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:341
#, no-wrap
msgid "0x00000321"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:341
#, no-wrap
msgid "HDIO_SET_MULTCOUNT"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:342
#, no-wrap
msgid "0x00000322"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:342
#, no-wrap
msgid "HDIO_SET_UNMASKINTR"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:343
#, no-wrap
msgid "0x00000323"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:343
#, no-wrap
msgid "HDIO_SET_KEEPSETTINGS"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:344
#, no-wrap
msgid "0x00000324"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:344
#, no-wrap
msgid "HDIO_SET_CHIPSET"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:345
#, no-wrap
msgid "0x00000325"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:345
#, no-wrap
msgid "HDIO_SET_NOWERR"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:346
#, no-wrap
msgid "0x00000326"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:346
#, no-wrap
msgid "HDIO_SET_DMA"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_list.2:350
msgid "// E<lt>include/linux/if_eql.hE<gt>"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:352 man-pages/man2/ioctl_list.2:363
#, no-wrap
msgid "0x000089F0"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:352
#, no-wrap
msgid "EQL_ENSLAVE"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:352 man-pages/man2/ioctl_list.2:353
#: man-pages/man2/ioctl_list.2:354 man-pages/man2/ioctl_list.2:355
#: man-pages/man2/ioctl_list.2:356 man-pages/man2/ioctl_list.2:357
#: man-pages/man2/ioctl_list.2:363 man-pages/man2/ioctl_list.2:617
#: man-pages/man2/ioctl_list.2:619 man-pages/man2/ioctl_list.2:621
#: man-pages/man2/ioctl_list.2:623 man-pages/man2/ioctl_list.2:625
#: man-pages/man2/ioctl_list.2:627 man-pages/man2/ioctl_list.2:629
#: man-pages/man2/ioctl_list.2:631 man-pages/man2/ioctl_list.2:636
#: man-pages/man2/ioctl_list.2:640 man-pages/man2/ioctl_list.2:653
#, no-wrap
msgid "struct ifreq *"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:353
#, no-wrap
msgid "0x000089F1"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:353
#, no-wrap
msgid "EQL_EMANCIPATE"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:354
#, no-wrap
msgid "0x000089F2"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:354
#, no-wrap
msgid "EQL_GETSLAVECFG"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:355
#, no-wrap
msgid "0x000089F3"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:355
#, no-wrap
msgid "EQL_SETSLAVECFG"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:356
#, no-wrap
msgid "0x000089F4"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:356
#, no-wrap
msgid "EQL_GETMASTRCFG"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:357
#, no-wrap
msgid "0x000089F5"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:357
#, no-wrap
msgid "EQL_SETMASTRCFG"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_list.2:361
msgid "// E<lt>include/linux/if_plip.hE<gt>"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:363
#, no-wrap
msgid "SIOCDEVPLIP"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_list.2:367
msgid "// E<lt>include/linux/if_ppp.hE<gt>"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:369
#, no-wrap
msgid "0x00005490"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:369
#, no-wrap
msgid "PPPIOCGFLAGS"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:370
#, no-wrap
msgid "0x00005491"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:370
#, no-wrap
msgid "PPPIOCSFLAGS"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:371
#, no-wrap
msgid "0x00005492"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:371
#, no-wrap
msgid "PPPIOCGASYNCMAP"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:372
#, no-wrap
msgid "0x00005493"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:372
#, no-wrap
msgid "PPPIOCSASYNCMAP"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:373
#, no-wrap
msgid "0x00005494"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:373
#, no-wrap
msgid "PPPIOCGUNIT"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:374
#, no-wrap
msgid "0x00005495"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:374
#, no-wrap
msgid "PPPIOCSINPSIG"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:375
#, no-wrap
msgid "0x00005497"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:375
#, no-wrap
msgid "PPPIOCSDEBUG"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:376
#, no-wrap
msgid "0x00005498"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:376
#, no-wrap
msgid "PPPIOCGDEBUG"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:377
#, no-wrap
msgid "0x00005499"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:377
#, no-wrap
msgid "PPPIOCGSTAT"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:377
#, no-wrap
msgid "struct ppp_stats *"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:378
#, no-wrap
msgid "0x0000549A"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:378
#, no-wrap
msgid "PPPIOCGTIME"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:378
#, no-wrap
msgid "struct ppp_ddinfo *"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:379
#, no-wrap
msgid "0x0000549B"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:379
#, no-wrap
msgid "PPPIOCGXASYNCMAP"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:379
#, no-wrap
msgid "struct { int [8]; } *"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:380
#, no-wrap
msgid "0x0000549C"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:380
#, no-wrap
msgid "PPPIOCSXASYNCMAP"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:380
#, no-wrap
msgid "const struct { int [8]; } *"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:381
#, no-wrap
msgid "0x0000549D"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:381
#, no-wrap
msgid "PPPIOCSMRU"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:382
#, no-wrap
msgid "0x0000549E"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:382
#, no-wrap
msgid "PPPIOCRASYNCMAP"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:383
#, no-wrap
msgid "0x0000549F"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:383
#, no-wrap
msgid "PPPIOCSMAXCID"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_list.2:387
msgid "// E<lt>include/linux/ipx.hE<gt>"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:389
#, no-wrap
msgid "SIOCAIPXITFCRT"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:390
#, no-wrap
msgid "SIOCAIPXPRISLT"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:391
#, no-wrap
msgid "SIOCIPXCFGDATA"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:391
#, no-wrap
msgid "struct ipx_config_data *"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_list.2:395
msgid "// E<lt>include/linux/kd.hE<gt>"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:397
#, no-wrap
msgid "0x00004B60"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:397
#, no-wrap
msgid "GIO_FONT"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:397
#, no-wrap
msgid "struct { char [8192]; } *"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:398
#, no-wrap
msgid "0x00004B61"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:398
#, no-wrap
msgid "PIO_FONT"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:398
#, no-wrap
msgid "const struct { char [8192]; } *"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:402
#, no-wrap
msgid "0x00004B6B"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:402
#, no-wrap
msgid "GIO_FONTX"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:402
#, no-wrap
msgid "struct console_font_desc *"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:403
#, no-wrap
msgid "0x00004B6C"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:403
#, no-wrap
msgid "PIO_FONTX"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:403
#, no-wrap
msgid "const struct console_font_desc *"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:403
#, no-wrap
msgid "//MORE"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:407
#, no-wrap
msgid "0x00004B70"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:407
#, no-wrap
msgid "GIO_CMAP"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:407
#, no-wrap
msgid "struct { char [48]; } *"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:408
#, no-wrap
msgid "0x00004B71"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:408
#, no-wrap
msgid "PIO_CMAP"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:408
#, no-wrap
msgid "const struct { char [48]; }"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:412
#, no-wrap
msgid "0x00004B2F"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:412
#, no-wrap
msgid "KIOCSOUND"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:413
#, no-wrap
msgid "0x00004B30"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:413
#, no-wrap
msgid "KDMKTONE"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:414
#, no-wrap
msgid "0x00004B31"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:414
#, no-wrap
msgid "KDGETLED"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:414 man-pages/man2/ioctl_list.2:416
#, no-wrap
msgid "char *"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:415
#, no-wrap
msgid "0x00004B32"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:415
#, no-wrap
msgid "KDSETLED"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:416
#, no-wrap
msgid "0x00004B33"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:416
#, no-wrap
msgid "KDGKBTYPE"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:417
#, no-wrap
msgid "0x00004B34"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:417
#, no-wrap
msgid "KDADDIO"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:418
#, no-wrap
msgid "0x00004B35"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:418
#, no-wrap
msgid "KDDELIO"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:419
#, no-wrap
msgid "0x00004B36"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:419
#, no-wrap
msgid "KDENABIO"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:420
#, no-wrap
msgid "0x00004B37"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:420
#, no-wrap
msgid "KDDISABIO"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:421
#, no-wrap
msgid "0x00004B3A"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:421
#, no-wrap
msgid "KDSETMODE"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:422
#, no-wrap
msgid "0x00004B3B"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:422
#, no-wrap
msgid "KDGETMODE"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:423
#, no-wrap
msgid "0x00004B3C"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:423
#, no-wrap
msgid "KDMAPDISP"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:424
#, no-wrap
msgid "0x00004B3D"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:424
#, no-wrap
msgid "KDUNMAPDISP"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:425
#, no-wrap
msgid "0x00004B40"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:425
#, no-wrap
msgid "GIO_SCRNMAP"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:425
#, no-wrap
msgid "struct { char [E_TABSZ]; } *"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:429
#, no-wrap
msgid "0x00004B41"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:429
#, no-wrap
msgid "PIO_SCRNMAP"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:429
#, no-wrap
msgid "const struct { char [E_TABSZ]; } *"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:430
#, no-wrap
msgid "0x00004B69"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:430
#, no-wrap
msgid "GIO_UNISCRNMAP"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:430
#, no-wrap
msgid "struct { short [E_TABSZ]; } *"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:431
#, no-wrap
msgid "0x00004B6A"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:431
#, no-wrap
msgid "PIO_UNISCRNMAP"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:431
#, no-wrap
msgid "const struct { short [E_TABSZ]; } *"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:435
#, no-wrap
msgid "0x00004B66"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:435
#, no-wrap
msgid "GIO_UNIMAP"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:435
#, no-wrap
msgid "struct unimapdesc *"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:436
#, no-wrap
msgid "0x00004B67"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:436
#, no-wrap
msgid "PIO_UNIMAP"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:436
#, no-wrap
msgid "const struct unimapdesc *"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:437
#, no-wrap
msgid "0x00004B68"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:437
#, no-wrap
msgid "PIO_UNIMAPCLR"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:437
#, no-wrap
msgid "const struct unimapinit *"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:438
#, no-wrap
msgid "0x00004B44"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:438
#, no-wrap
msgid "KDGKBMODE"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:439
#, no-wrap
msgid "0x00004B45"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:439
#, no-wrap
msgid "KDSKBMODE"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:440
#, no-wrap
msgid "0x00004B62"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:440
#, no-wrap
msgid "KDGKBMETA"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:441
#, no-wrap
msgid "0x00004B63"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:441
#, no-wrap
msgid "KDSKBMETA"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:442
#, no-wrap
msgid "0x00004B64"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:442
#, no-wrap
msgid "KDGKBLED"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:443
#, no-wrap
msgid "0x00004B65"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:443
#, no-wrap
msgid "KDSKBLED"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:444
#, no-wrap
msgid "0x00004B46"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:444
#, no-wrap
msgid "KDGKBENT"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:444
#, no-wrap
msgid "struct kbentry *"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:445
#, no-wrap
msgid "0x00004B47"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:445
#, no-wrap
msgid "KDSKBENT"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:445
#, no-wrap
msgid "const struct kbentry *"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:446
#, no-wrap
msgid "0x00004B48"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:446
#, no-wrap
msgid "KDGKBSENT"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:446
#, no-wrap
msgid "struct kbsentry *"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:447
#, no-wrap
msgid "0x00004B49"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:447
#, no-wrap
msgid "KDSKBSENT"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:447
#, no-wrap
msgid "const struct kbsentry *"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:448
#, no-wrap
msgid "0x00004B4A"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:448
#, no-wrap
msgid "KDGKBDIACR"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:448
#, no-wrap
msgid "struct kbdiacrs *"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:449
#, no-wrap
msgid "0x00004B4B"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:449
#, no-wrap
msgid "KDSKBDIACR"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:449
#, no-wrap
msgid "const struct kbdiacrs *"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:450
#, no-wrap
msgid "0x00004B4C"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:450
#, no-wrap
msgid "KDGETKEYCODE"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:450
#, no-wrap
msgid "struct kbkeycode *"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:451
#, no-wrap
msgid "0x00004B4D"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:451
#, no-wrap
msgid "KDSETKEYCODE"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:451
#, no-wrap
msgid "const struct kbkeycode *"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:452
#, no-wrap
msgid "0x00004B4E"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:452
#, no-wrap
msgid "KDSIGACCEPT"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_list.2:456
msgid "// E<lt>include/linux/lp.hE<gt>"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:458
#, no-wrap
msgid "0x00000601"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:458
#, no-wrap
msgid "LPCHAR"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:459
#, no-wrap
msgid "0x00000602"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:459
#, no-wrap
msgid "LPTIME"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:460
#, no-wrap
msgid "0x00000604"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:460
#, no-wrap
msgid "LPABORT"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:461
#, no-wrap
msgid "0x00000605"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:461
#, no-wrap
msgid "LPSETIRQ"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:462
#, no-wrap
msgid "0x00000606"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:462
#, no-wrap
msgid "LPGETIRQ"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:463
#, no-wrap
msgid "0x00000608"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:463
#, no-wrap
msgid "LPWAIT"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:464
#, no-wrap
msgid "0x00000609"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:464
#, no-wrap
msgid "LPCAREFUL"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:465
#, no-wrap
msgid "0x0000060A"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:465
#, no-wrap
msgid "LPABORTOPEN"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:466
#, no-wrap
msgid "0x0000060B"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:466
#, no-wrap
msgid "LPGETSTATUS"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:467
#, no-wrap
msgid "0x0000060C"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:467
#, no-wrap
msgid "LPRESET"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:468
#, no-wrap
msgid "0x0000060D"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:468
#, no-wrap
msgid "LPGETSTATS"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:468
#, no-wrap
msgid "struct lp_stats *"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_list.2:472
msgid "// E<lt>include/linux/mroute.hE<gt>"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:474
#, no-wrap
msgid "SIOCGETVIFCNT"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:474
#, no-wrap
msgid "struct sioc_vif_req *"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:475
#, no-wrap
msgid "SIOCGETSGCNT"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:475
#, no-wrap
msgid "struct sioc_sg_req *"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_list.2:480
msgid "// E<lt>include/linux/msdos_fs.hE<gt> see B<ioctl_fat>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:482
#, no-wrap
msgid "0x82307201"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:482
#, no-wrap
msgid "VFAT_IOCTL_READDIR_BOTH"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:482 man-pages/man2/ioctl_list.2:483
#, no-wrap
msgid "struct dirent [2]"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:483
#, no-wrap
msgid "0x82307202"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:483
#, no-wrap
msgid "VFAT_IOCTL_READDIR_SHORT"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:484
#, no-wrap
msgid "0x80047210"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:484
#, no-wrap
msgid "FAT_IOCTL_GET_ATTRIBUTES"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:484 man-pages/man2/ioctl_list.2:486
#, no-wrap
msgid "__u32 *"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:485
#, no-wrap
msgid "0x40047211"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:485
#, no-wrap
msgid "FAT_IOCTL_SET_ATTRIBUTES"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:485
#, no-wrap
msgid "const __u32 *"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:486
#, no-wrap
msgid "0x80047213"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:486
#, no-wrap
msgid "FAT_IOCTL_GET_VOLUME_ID"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_list.2:490
msgid "// E<lt>include/linux/mtio.hE<gt>"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:492
#, no-wrap
msgid "0x40086D01"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:492
#, no-wrap
msgid "MTIOCTOP"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:492
#, no-wrap
msgid "const struct mtop *"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:493
#, no-wrap
msgid "0x801C6D02"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:493
#, no-wrap
msgid "MTIOCGET"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:493
#, no-wrap
msgid "struct mtget *"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:494
#, no-wrap
msgid "0x80046D03"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:494
#, no-wrap
msgid "MTIOCPOS"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:494
#, no-wrap
msgid "struct mtpos *"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:495
#, no-wrap
msgid "0x80206D04"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:495
#, no-wrap
msgid "MTIOCGETCONFIG"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:495
#, no-wrap
msgid "struct mtconfiginfo *"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:496
#, no-wrap
msgid "0x40206D05"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:496
#, no-wrap
msgid "MTIOCSETCONFIG"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:496
#, no-wrap
msgid "const struct mtconfiginfo *"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_list.2:500
msgid "// E<lt>include/linux/netrom.hE<gt>"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:502
#, no-wrap
msgid "SIOCNRGETPARMS"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:502
#, no-wrap
msgid "struct nr_parms_struct *"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:503
#, no-wrap
msgid "SIOCNRSETPARMS"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:503
#, no-wrap
msgid "const struct nr_parms_struct *"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:504
#, no-wrap
msgid "SIOCNRDECOBS"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:505
#, no-wrap
msgid "SIOCNRRTCTL"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_list.2:509
msgid "// E<lt>include/uapi/linux/wireless.hE<gt>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_list.2:511
msgid "// This API is deprecated."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_list.2:514
msgid "// It is being replaced by nl80211 and cfg80211.  See"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_list.2:517
msgid "// I<https://wireless.wiki.kernel.org/en/developers/documentation/nl80211>"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:519
#, no-wrap
msgid "x00008b00"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:519
#, no-wrap
msgid "SIOCSIWCOMMIT"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:519 man-pages/man2/ioctl_list.2:520
#: man-pages/man2/ioctl_list.2:521 man-pages/man2/ioctl_list.2:522
#: man-pages/man2/ioctl_list.2:523 man-pages/man2/ioctl_list.2:524
#: man-pages/man2/ioctl_list.2:525 man-pages/man2/ioctl_list.2:526
#: man-pages/man2/ioctl_list.2:527 man-pages/man2/ioctl_list.2:528
#: man-pages/man2/ioctl_list.2:529 man-pages/man2/ioctl_list.2:530
#: man-pages/man2/ioctl_list.2:531 man-pages/man2/ioctl_list.2:532
#: man-pages/man2/ioctl_list.2:533 man-pages/man2/ioctl_list.2:534
#: man-pages/man2/ioctl_list.2:535 man-pages/man2/ioctl_list.2:536
#: man-pages/man2/ioctl_list.2:537 man-pages/man2/ioctl_list.2:538
#: man-pages/man2/ioctl_list.2:539 man-pages/man2/ioctl_list.2:540
#: man-pages/man2/ioctl_list.2:541 man-pages/man2/ioctl_list.2:542
#: man-pages/man2/ioctl_list.2:543 man-pages/man2/ioctl_list.2:544
#: man-pages/man2/ioctl_list.2:545 man-pages/man2/ioctl_list.2:546
#: man-pages/man2/ioctl_list.2:547 man-pages/man2/ioctl_list.2:548
#: man-pages/man2/ioctl_list.2:549 man-pages/man2/ioctl_list.2:550
#: man-pages/man2/ioctl_list.2:551 man-pages/man2/ioctl_list.2:552
#: man-pages/man2/ioctl_list.2:553 man-pages/man2/ioctl_list.2:554
#: man-pages/man2/ioctl_list.2:555 man-pages/man2/ioctl_list.2:556
#: man-pages/man2/ioctl_list.2:557 man-pages/man2/ioctl_list.2:558
#: man-pages/man2/ioctl_list.2:559 man-pages/man2/ioctl_list.2:560
#: man-pages/man2/ioctl_list.2:561 man-pages/man2/ioctl_list.2:562
#: man-pages/man2/ioctl_list.2:563 man-pages/man2/ioctl_list.2:564
#: man-pages/man2/ioctl_list.2:565 man-pages/man2/ioctl_list.2:566
#: man-pages/man2/ioctl_list.2:567 man-pages/man2/ioctl_list.2:568
#: man-pages/man2/ioctl_list.2:569
#, no-wrap
msgid "struct iwreq *"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:520
#, no-wrap
msgid "x00008b01"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:520
#, no-wrap
msgid "SIOCGIWNAME"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:521
#, no-wrap
msgid "x00008b02"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:521
#, no-wrap
msgid "SIOCSIWNWID"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:522
#, no-wrap
msgid "x00008b03"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:522
#, no-wrap
msgid "SIOCGIWNWID"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:523
#, no-wrap
msgid "x00008b04"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:523
#, no-wrap
msgid "SIOCSIWFREQ"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:524
#, no-wrap
msgid "x00008b05"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:524
#, no-wrap
msgid "SIOCGIWFREQ"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:525
#, no-wrap
msgid "x00008b06"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:525
#, no-wrap
msgid "SIOCSIWMODE"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:526
#, no-wrap
msgid "x00008b07"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:526
#, no-wrap
msgid "SIOCGIWMODE"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:527
#, no-wrap
msgid "x00008b08"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:527
#, no-wrap
msgid "SIOCSIWSENS"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:528
#, no-wrap
msgid "x00008b09"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:528
#, no-wrap
msgid "SIOCGIWSENS"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:529
#, no-wrap
msgid "x00008b0a"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:529
#, no-wrap
msgid "SIOCSIWRANGE"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:530
#, no-wrap
msgid "x00008b0b"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:530
#, no-wrap
msgid "SIOCGIWRANGE"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:531
#, no-wrap
msgid "x00008b0c"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:531
#, no-wrap
msgid "SIOCSIWPRIV"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:532
#, no-wrap
msgid "x00008b0d"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:532
#, no-wrap
msgid "SIOCGIWPRIV"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:533
#, no-wrap
msgid "x00008b0e"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:533
#, no-wrap
msgid "SIOCSIWSTATS"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:534
#, no-wrap
msgid "x00008b0f"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:534
#, no-wrap
msgid "SIOCGIWSTATS"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:535
#, no-wrap
msgid "x00008b10"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:535
#, no-wrap
msgid "SIOCSIWSPY"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:536
#, no-wrap
msgid "x00008b11"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:536
#, no-wrap
msgid "SIOCGIWSPY"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:537
#, no-wrap
msgid "x00008b12"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:537
#, no-wrap
msgid "SIOCSIWTHRSPY"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:538
#, no-wrap
msgid "x00008b13"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:538
#, no-wrap
msgid "SIOCGIWTHRSPY"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:539
#, no-wrap
msgid "x00008b14"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:539
#, no-wrap
msgid "SIOCSIWAP"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:540
#, no-wrap
msgid "x00008b15"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:540
#, no-wrap
msgid "SIOCGIWAP"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:541
#, no-wrap
msgid "x00008b17"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:541
#, no-wrap
msgid "SIOCGIWAPLIST"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:542
#, no-wrap
msgid "x00008b18"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:542
#, no-wrap
msgid "SIOCSIWSCAN"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:543
#, no-wrap
msgid "x00008b19"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:543
#, no-wrap
msgid "SIOCGIWSCAN"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:544
#, no-wrap
msgid "x00008b1a"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:544
#, no-wrap
msgid "SIOCSIWESSID"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:545
#, no-wrap
msgid "x00008b1b"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:545
#, no-wrap
msgid "SIOCGIWESSID"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:546
#, no-wrap
msgid "x00008b1c"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:546
#, no-wrap
msgid "SIOCSIWNICKN"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:547
#, no-wrap
msgid "x00008b1d"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:547
#, no-wrap
msgid "SIOCGIWNICKN"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:548
#, no-wrap
msgid "x00008b20"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:548
#, no-wrap
msgid "SIOCSIWRATE"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:549
#, no-wrap
msgid "x00008b21"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:549
#, no-wrap
msgid "SIOCGIWRATE"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:550
#, no-wrap
msgid "x00008b22"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:550
#, no-wrap
msgid "SIOCSIWRTS"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:551
#, no-wrap
msgid "x00008b23"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:551
#, no-wrap
msgid "SIOCGIWRTS"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:552
#, no-wrap
msgid "x00008b24"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:552
#, no-wrap
msgid "SIOCSIWFRAG"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:553
#, no-wrap
msgid "x00008b25"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:553
#, no-wrap
msgid "SIOCGIWFRAG"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:554
#, no-wrap
msgid "x00008b26"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:554
#, no-wrap
msgid "SIOCSIWTXPOW"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:555
#, no-wrap
msgid "x00008b27"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:555
#, no-wrap
msgid "SIOCGIWTXPOW"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:556
#, no-wrap
msgid "x00008b28"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:556
#, no-wrap
msgid "SIOCSIWRETRY"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:557
#, no-wrap
msgid "x00008b29"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:557
#, no-wrap
msgid "SIOCGIWRETRY"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:558
#, no-wrap
msgid "x00008b2a"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:558
#, no-wrap
msgid "SIOCSIWENCODE"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:559
#, no-wrap
msgid "x00008b2b"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:559
#, no-wrap
msgid "SIOCGIWENCODE"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:560
#, no-wrap
msgid "x00008b2c"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:560
#, no-wrap
msgid "SIOCSIWPOWER"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:561
#, no-wrap
msgid "x00008b2d"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:561
#, no-wrap
msgid "SIOCGIWPOWER"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:562
#, no-wrap
msgid "x00008b30"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:562
#, no-wrap
msgid "SIOCSIWGENIE"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:563
#, no-wrap
msgid "x00008b31"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:563
#, no-wrap
msgid "SIOCGIWGENIE"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:564
#, no-wrap
msgid "x00008b16"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:564
#, no-wrap
msgid "SIOCSIWMLME"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:565
#, no-wrap
msgid "x00008b32"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:565
#, no-wrap
msgid "SIOCSIWAUTH"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:566
#, no-wrap
msgid "x00008b33"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:566
#, no-wrap
msgid "SIOCGIWAUTH"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:567
#, no-wrap
msgid "x00008b34"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:567
#, no-wrap
msgid "SIOCSIWENCODEEXT"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:568
#, no-wrap
msgid "x00008b35"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:568
#, no-wrap
msgid "SIOCGIWENCODEEXT"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:569
#, no-wrap
msgid "x00008b36"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:569
#, no-wrap
msgid "SIOCSIWPMKSA"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_list.2:573
msgid "// E<lt>include/linux/sbpcd.hE<gt>"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:575
#, no-wrap
msgid "0x00009000"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:575
#, no-wrap
msgid "DDIOCSDBG"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:576 man-pages/man2/ioctl_list.2:592
#: man-pages/man2/ioctl_list.2:1035
#, no-wrap
msgid "0x00005382"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:576 man-pages/man2/ioctl_list.2:1035
#, no-wrap
msgid "CDROMAUDIOBUFSIZ"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_list.2:580
msgid "// E<lt>include/linux/scc.hE<gt>"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:582
#, no-wrap
msgid "0x00005470"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:582
#, no-wrap
msgid "TIOCSCCINI"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:583
#, no-wrap
msgid "0x00005471"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:583
#, no-wrap
msgid "TIOCCHANINI"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:583
#, no-wrap
msgid "const struct scc_modem *"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:584
#, no-wrap
msgid "0x00005472"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:584
#, no-wrap
msgid "TIOCGKISS"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:584
#, no-wrap
msgid "struct ioctl_command *"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:585
#, no-wrap
msgid "0x00005473"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:585
#, no-wrap
msgid "TIOCSKISS"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:585
#, no-wrap
msgid "const struct ioctl_command *"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:586
#, no-wrap
msgid "0x00005474"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:586
#, no-wrap
msgid "TIOCSCCSTAT"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:586
#, no-wrap
msgid "struct scc_stat *"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_list.2:590
msgid "// E<lt>include/linux/scsi.hE<gt>"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:592
#, no-wrap
msgid "SCSI_IOCTL_GET_IDLUN       struct { int [2]; } *"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:593
#, no-wrap
msgid "0x00005383"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:593
#, no-wrap
msgid "SCSI_IOCTL_TAGGED_ENABLE   void"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:594
#, no-wrap
msgid "0x00005384"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:594
#, no-wrap
msgid "SCSI_IOCTL_TAGGED_DISABLE  void"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:598
#, no-wrap
msgid "0x00005385"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:598
#, no-wrap
msgid "SCSI_IOCTL_PROBE_HOST"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_list.2:602
msgid "// E<lt>include/linux/smb_fs.hE<gt>"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:604
#, no-wrap
msgid "0x80027501"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:604
#, no-wrap
msgid "SMB_IOC_GETMOUNTUID"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:604
#, no-wrap
msgid "uid_t *"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_list.2:609
msgid "// E<lt>include/uapi/linux/sockios.hE<gt> see B<netdevice>(7)"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:612
#, no-wrap
msgid "0x0000890B"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:612
#, no-wrap
msgid "SIOCADDRT"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:612 man-pages/man2/ioctl_list.2:613
#, no-wrap
msgid "const struct rtentry *"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:613
#, no-wrap
msgid "0x0000890C"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:613
#, no-wrap
msgid "SIOCDELRT"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:614
#, no-wrap
msgid "0x00008910"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:614
#, no-wrap
msgid "SIOCGIFNAME"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:614
#, no-wrap
msgid "char []"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:615
#, no-wrap
msgid "0x00008911"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:615
#, no-wrap
msgid "SIOCSIFLINK"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:616
#, no-wrap
msgid "0x00008912"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:616
#, no-wrap
msgid "SIOCGIFCONF"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:616
#, no-wrap
msgid "struct ifconf *"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:617
#, no-wrap
msgid "0x00008913"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:617
#, no-wrap
msgid "SIOCGIFFLAGS"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:618
#, no-wrap
msgid "0x00008914"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:618
#, no-wrap
msgid "SIOCSIFFLAGS"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:618 man-pages/man2/ioctl_list.2:620
#: man-pages/man2/ioctl_list.2:622 man-pages/man2/ioctl_list.2:624
#: man-pages/man2/ioctl_list.2:626 man-pages/man2/ioctl_list.2:628
#: man-pages/man2/ioctl_list.2:630 man-pages/man2/ioctl_list.2:632
#: man-pages/man2/ioctl_list.2:637 man-pages/man2/ioctl_list.2:643
#: man-pages/man2/ioctl_list.2:644 man-pages/man2/ioctl_list.2:654
#, no-wrap
msgid "const struct ifreq *"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:619
#, no-wrap
msgid "0x00008915"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:619
#, no-wrap
msgid "SIOCGIFADDR"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:620
#, no-wrap
msgid "0x00008916"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:620
#, no-wrap
msgid "SIOCSIFADDR"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:621
#, no-wrap
msgid "0x00008917"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:621
#, no-wrap
msgid "SIOCGIFDSTADDR"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:622
#, no-wrap
msgid "0x00008918"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:622
#, no-wrap
msgid "SIOCSIFDSTADDR"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:623
#, no-wrap
msgid "0x00008919"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:623
#, no-wrap
msgid "SIOCGIFBRDADDR"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:624
#, no-wrap
msgid "0x0000891A"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:624
#, no-wrap
msgid "SIOCSIFBRDADDR"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:625
#, no-wrap
msgid "0x0000891B"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:625
#, no-wrap
msgid "SIOCGIFNETMASK"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:626
#, no-wrap
msgid "0x0000891C"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:626
#, no-wrap
msgid "SIOCSIFNETMASK"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:627
#, no-wrap
msgid "0x0000891D"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:627
#, no-wrap
msgid "SIOCGIFMETRIC"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:628
#, no-wrap
msgid "0x0000891E"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:628
#, no-wrap
msgid "SIOCSIFMETRIC"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:629
#, no-wrap
msgid "0x0000891F"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:629
#, no-wrap
msgid "SIOCGIFMEM"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:630
#, no-wrap
msgid "0x00008920"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:630
#, no-wrap
msgid "SIOCSIFMEM"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:631
#, no-wrap
msgid "0x00008921"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:631
#, no-wrap
msgid "SIOCGIFMTU"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:632
#, no-wrap
msgid "0x00008922"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:632
#, no-wrap
msgid "SIOCSIFMTU"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:636
#, no-wrap
msgid "0x00008923"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:636
#, no-wrap
msgid "OLD_SIOCGIFHWADDR"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:637
#, no-wrap
msgid "0x00008924"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:637
#, no-wrap
msgid "SIOCSIFHWADDR"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:638
#, no-wrap
msgid "0x00008925"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:638
#, no-wrap
msgid "SIOCGIFENCAP"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:639
#, no-wrap
msgid "0x00008926"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:639
#, no-wrap
msgid "SIOCSIFENCAP"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:640
#, no-wrap
msgid "0x00008927"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:640
#, no-wrap
msgid "SIOCGIFHWADDR"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:641
#, no-wrap
msgid "0x00008929"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:641
#, no-wrap
msgid "SIOCGIFSLAVE"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:642
#, no-wrap
msgid "0x00008930"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:642
#, no-wrap
msgid "SIOCSIFSLAVE"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:643
#, no-wrap
msgid "0x00008931"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:643
#, no-wrap
msgid "SIOCADDMULTI"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:644
#, no-wrap
msgid "0x00008932"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:644
#, no-wrap
msgid "SIOCDELMULTI"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:645
#, no-wrap
msgid "0x00008940"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:645
#, no-wrap
msgid "SIOCADDRTOLD"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:646
#, no-wrap
msgid "0x00008941"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:646
#, no-wrap
msgid "SIOCDELRTOLD"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:647
#, no-wrap
msgid "0x00008950"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:647
#, no-wrap
msgid "SIOCDARP"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:647 man-pages/man2/ioctl_list.2:649
#: man-pages/man2/ioctl_list.2:650 man-pages/man2/ioctl_list.2:652
#, no-wrap
msgid "const struct arpreq *"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:648
#, no-wrap
msgid "0x00008951"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:648
#, no-wrap
msgid "SIOCGARP"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:648 man-pages/man2/ioctl_list.2:651
#, no-wrap
msgid "struct arpreq *"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:649
#, no-wrap
msgid "0x00008952"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:649
#, no-wrap
msgid "SIOCSARP"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:650
#, no-wrap
msgid "0x00008960"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:650
#, no-wrap
msgid "SIOCDRARP"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:651
#, no-wrap
msgid "0x00008961"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:651
#, no-wrap
msgid "SIOCGRARP"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:652
#, no-wrap
msgid "0x00008962"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:652
#, no-wrap
msgid "SIOCSRARP"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:653
#, no-wrap
msgid "0x00008970"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:653
#, no-wrap
msgid "SIOCGIFMAP"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:654
#, no-wrap
msgid "0x00008971"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:654
#, no-wrap
msgid "SIOCSIFMAP"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_list.2:658
msgid "// E<lt>include/linux/soundcard.hE<gt>"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:660
#, no-wrap
msgid "0x00005100"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:660
#, no-wrap
msgid "SNDCTL_SEQ_RESET"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:661
#, no-wrap
msgid "0x00005101"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:661
#, no-wrap
msgid "SNDCTL_SEQ_SYNC"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:665
#, no-wrap
msgid "0xC08C5102"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:665
#, no-wrap
msgid "SNDCTL_SYNTH_INFO"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:665
#, no-wrap
msgid "struct synth_info *"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:666
#, no-wrap
msgid "0xC0045103"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:666
#, no-wrap
msgid "SNDCTL_SEQ_CTRLRATE"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:667
#, no-wrap
msgid "0x80045104"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:667
#, no-wrap
msgid "SNDCTL_SEQ_GETOUTCOUNT"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:668
#, no-wrap
msgid "0x80045105"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:668
#, no-wrap
msgid "SNDCTL_SEQ_GETINCOUNT"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:669
#, no-wrap
msgid "0x40045106"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:669
#, no-wrap
msgid "SNDCTL_SEQ_PERCMODE"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:673
#, no-wrap
msgid "0x40285107"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:673
#, no-wrap
msgid "SNDCTL_FM_LOAD_INSTR"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:673
#, no-wrap
msgid "const struct sbi_instrument *"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:677
#, no-wrap
msgid "0x40045108"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:677
#, no-wrap
msgid "SNDCTL_SEQ_TESTMIDI"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:678
#, no-wrap
msgid "0x40045109"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:678
#, no-wrap
msgid "SNDCTL_SEQ_RESETSAMPLES"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:679
#, no-wrap
msgid "0x8004510A"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:679
#, no-wrap
msgid "SNDCTL_SEQ_NRSYNTHS"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:680
#, no-wrap
msgid "0x8004510B"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:680
#, no-wrap
msgid "SNDCTL_SEQ_NRMIDIS"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:681
#, no-wrap
msgid "0xC074510C"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:681
#, no-wrap
msgid "SNDCTL_MIDI_INFO"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:681
#, no-wrap
msgid "struct midi_info *"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:682
#, no-wrap
msgid "0x4004510D"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:682
#, no-wrap
msgid "SNDCTL_SEQ_THRESHOLD"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:683
#, no-wrap
msgid "0xC004510E"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:683
#, no-wrap
msgid "SNDCTL_SYNTH_MEMAVL"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:684
#, no-wrap
msgid "0x4004510F"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:684
#, no-wrap
msgid "SNDCTL_FM_4OP_ENABLE"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:685
#, no-wrap
msgid "0xCFB85110"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:685
#, no-wrap
msgid "SNDCTL_PMGR_ACCESS"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:685 man-pages/man2/ioctl_list.2:702
#, no-wrap
msgid "struct patmgr_info *"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:686
#, no-wrap
msgid "0x00005111"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:686
#, no-wrap
msgid "SNDCTL_SEQ_PANIC"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:690
#, no-wrap
msgid "0x40085112"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:690
#, no-wrap
msgid "SNDCTL_SEQ_OUTOFBAND"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:690
#, no-wrap
msgid "const struct seq_event_rec *"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:694
#, no-wrap
msgid "0xC0045401"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:694
#, no-wrap
msgid "SNDCTL_TMR_TIMEBASE"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:695 man-pages/man2/ioctl_list.2:1036
#, no-wrap
msgid "SNDCTL_TMR_START"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:696 man-pages/man2/ioctl_list.2:1037
#, no-wrap
msgid "SNDCTL_TMR_STOP"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:697 man-pages/man2/ioctl_list.2:1038
#, no-wrap
msgid "SNDCTL_TMR_CONTINUE"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:698
#, no-wrap
msgid "0xC0045405"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:698
#, no-wrap
msgid "SNDCTL_TMR_TEMPO"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:699
#, no-wrap
msgid "0xC0045406"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:699
#, no-wrap
msgid "SNDCTL_TMR_SOURCE"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:700
#, no-wrap
msgid "0x40045407"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:700
#, no-wrap
msgid "SNDCTL_TMR_METRONOME"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:701
#, no-wrap
msgid "0x40045408"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:701
#, no-wrap
msgid "SNDCTL_TMR_SELECT"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:702
#, no-wrap
msgid "0xCFB85001"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:702
#, no-wrap
msgid "SNDCTL_PMGR_IFACE"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:703
#, no-wrap
msgid "0xC0046D00"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:703
#, no-wrap
msgid "SNDCTL_MIDI_PRETIME"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:704
#, no-wrap
msgid "0xC0046D01"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:704
#, no-wrap
msgid "SNDCTL_MIDI_MPUMODE"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:708
#, no-wrap
msgid "0xC0216D02"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:708
#, no-wrap
msgid "SNDCTL_MIDI_MPUCMD"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:708
#, no-wrap
msgid "struct mpu_command_rec *"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:712
#, no-wrap
msgid "0x00005000"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:712
#, no-wrap
msgid "SNDCTL_DSP_RESET"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:713
#, no-wrap
msgid "0x00005001"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:713
#, no-wrap
msgid "SNDCTL_DSP_SYNC"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:714
#, no-wrap
msgid "0xC0045002"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:714
#, no-wrap
msgid "SNDCTL_DSP_SPEED"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:715
#, no-wrap
msgid "0xC0045003"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:715
#, no-wrap
msgid "SNDCTL_DSP_STEREO"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:716
#, no-wrap
msgid "0xC0045004"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:716
#, no-wrap
msgid "SNDCTL_DSP_GETBLKSIZE"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:717
#, no-wrap
msgid "0xC0045006"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:717
#, no-wrap
msgid "SOUND_PCM_WRITE_CHANNELS"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:718
#, no-wrap
msgid "0xC0045007"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:718
#, no-wrap
msgid "SOUND_PCM_WRITE_FILTER"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:719
#, no-wrap
msgid "0x00005008"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:719
#, no-wrap
msgid "SNDCTL_DSP_POST"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:720
#, no-wrap
msgid "0xC0045009"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:720
#, no-wrap
msgid "SNDCTL_DSP_SUBDIVIDE"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:721
#, no-wrap
msgid "0xC004500A"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:721
#, no-wrap
msgid "SNDCTL_DSP_SETFRAGMENT"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:722
#, no-wrap
msgid "0x8004500B"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:722
#, no-wrap
msgid "SNDCTL_DSP_GETFMTS"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:723
#, no-wrap
msgid "0xC0045005"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:723
#, no-wrap
msgid "SNDCTL_DSP_SETFMT"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:727
#, no-wrap
msgid "0x800C500C"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:727
#, no-wrap
msgid "SNDCTL_DSP_GETOSPACE"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:727 man-pages/man2/ioctl_list.2:728
#, no-wrap
msgid "struct audio_buf_info *"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:728
#, no-wrap
msgid "0x800C500D"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:728
#, no-wrap
msgid "SNDCTL_DSP_GETISPACE"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:729
#, no-wrap
msgid "0x0000500E"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:729
#, no-wrap
msgid "SNDCTL_DSP_NONBLOCK"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:730
#, no-wrap
msgid "0x80045002"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:730
#, no-wrap
msgid "SOUND_PCM_READ_RATE"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:731
#, no-wrap
msgid "0x80045006"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:731
#, no-wrap
msgid "SOUND_PCM_READ_CHANNELS"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:732
#, no-wrap
msgid "0x80045005"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:732
#, no-wrap
msgid "SOUND_PCM_READ_BITS"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:733
#, no-wrap
msgid "0x80045007"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:733
#, no-wrap
msgid "SOUND_PCM_READ_FILTER"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:734
#, no-wrap
msgid "0x00004300"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:734
#, no-wrap
msgid "SNDCTL_COPR_RESET"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:735
#, no-wrap
msgid "0xCFB04301"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:735
#, no-wrap
msgid "SNDCTL_COPR_LOAD"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:735
#, no-wrap
msgid "const struct copr_buffer *"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:739
#, no-wrap
msgid "0xC0144302"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:739
#, no-wrap
msgid "SNDCTL_COPR_RDATA"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:739 man-pages/man2/ioctl_list.2:740
#: man-pages/man2/ioctl_list.2:749 man-pages/man2/ioctl_list.2:750
#, no-wrap
msgid "struct copr_debug_buf *"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:740
#, no-wrap
msgid "0xC0144303"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:740
#, no-wrap
msgid "SNDCTL_COPR_RCODE"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:744
#, no-wrap
msgid "0x40144304"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:744
#, no-wrap
msgid "SNDCTL_COPR_WDATA"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:744 man-pages/man2/ioctl_list.2:745
#, no-wrap
msgid "const struct copr_debug_buf *"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:745
#, no-wrap
msgid "0x40144305"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:745
#, no-wrap
msgid "SNDCTL_COPR_WCODE"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:749
#, no-wrap
msgid "0xC0144306"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:749
#, no-wrap
msgid "SNDCTL_COPR_RUN"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:750
#, no-wrap
msgid "0xC0144307"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:750
#, no-wrap
msgid "SNDCTL_COPR_HALT"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:754
#, no-wrap
msgid "0x4FA44308"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:754
#, no-wrap
msgid "SNDCTL_COPR_SENDMSG"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:754
#, no-wrap
msgid "const struct copr_msg *"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:755
#, no-wrap
msgid "0x8FA44309"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:755
#, no-wrap
msgid "SNDCTL_COPR_RCVMSG"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:755
#, no-wrap
msgid "struct copr_msg *"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:756
#, no-wrap
msgid "0x80044D00"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:756
#, no-wrap
msgid "SOUND_MIXER_READ_VOLUME"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:757
#, no-wrap
msgid "0x80044D01"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:757
#, no-wrap
msgid "SOUND_MIXER_READ_BASS"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:758
#, no-wrap
msgid "0x80044D02"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:758
#, no-wrap
msgid "SOUND_MIXER_READ_TREBLE"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:759
#, no-wrap
msgid "0x80044D03"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:759
#, no-wrap
msgid "SOUND_MIXER_READ_SYNTH"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:760
#, no-wrap
msgid "0x80044D04"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:760
#, no-wrap
msgid "SOUND_MIXER_READ_PCM"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:761
#, no-wrap
msgid "0x80044D05"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:761
#, no-wrap
msgid "SOUND_MIXER_READ_SPEAKER"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:762
#, no-wrap
msgid "0x80044D06"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:762
#, no-wrap
msgid "SOUND_MIXER_READ_LINE"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:763
#, no-wrap
msgid "0x80044D07"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:763
#, no-wrap
msgid "SOUND_MIXER_READ_MIC"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:764
#, no-wrap
msgid "0x80044D08"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:764
#, no-wrap
msgid "SOUND_MIXER_READ_CD"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:765
#, no-wrap
msgid "0x80044D09"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:765
#, no-wrap
msgid "SOUND_MIXER_READ_IMIX"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:766
#, no-wrap
msgid "0x80044D0A"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:766
#, no-wrap
msgid "SOUND_MIXER_READ_ALTPCM"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:767
#, no-wrap
msgid "0x80044D0B"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:767
#, no-wrap
msgid "SOUND_MIXER_READ_RECLEV"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:768
#, no-wrap
msgid "0x80044D0C"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:768
#, no-wrap
msgid "SOUND_MIXER_READ_IGAIN"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:769
#, no-wrap
msgid "0x80044D0D"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:769
#, no-wrap
msgid "SOUND_MIXER_READ_OGAIN"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:770
#, no-wrap
msgid "0x80044D0E"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:770
#, no-wrap
msgid "SOUND_MIXER_READ_LINE1"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:771
#, no-wrap
msgid "0x80044D0F"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:771
#, no-wrap
msgid "SOUND_MIXER_READ_LINE2"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:772
#, no-wrap
msgid "0x80044D10"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:772
#, no-wrap
msgid "SOUND_MIXER_READ_LINE3"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:773
#, no-wrap
msgid "0x80044D1C"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:773
#, no-wrap
msgid "SOUND_MIXER_READ_MUTE"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:774
#, no-wrap
msgid "0x80044D1D"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:774
#, no-wrap
msgid "SOUND_MIXER_READ_ENHANCE"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:775
#, no-wrap
msgid "0x80044D1E"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:775
#, no-wrap
msgid "SOUND_MIXER_READ_LOUD"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:776
#, no-wrap
msgid "0x80044DFF"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:776
#, no-wrap
msgid "SOUND_MIXER_READ_RECSRC"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:777
#, no-wrap
msgid "0x80044DFE"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:777
#, no-wrap
msgid "SOUND_MIXER_READ_DEVMASK"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:778
#, no-wrap
msgid "0x80044DFD"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:778
#, no-wrap
msgid "SOUND_MIXER_READ_RECMASK"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:779
#, no-wrap
msgid "0x80044DFB"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:779
#, no-wrap
msgid "SOUND_MIXER_READ_STEREODEVS"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:780
#, no-wrap
msgid "0x80044DFC"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:780
#, no-wrap
msgid "SOUND_MIXER_READ_CAPS"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:784
#, no-wrap
msgid "0xC0044D00"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:784
#, no-wrap
msgid "SOUND_MIXER_WRITE_VOLUME"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:785
#, no-wrap
msgid "0xC0044D01"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:785
#, no-wrap
msgid "SOUND_MIXER_WRITE_BASS"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:786
#, no-wrap
msgid "0xC0044D02"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:786
#, no-wrap
msgid "SOUND_MIXER_WRITE_TREBLE"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:787
#, no-wrap
msgid "0xC0044D03"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:787
#, no-wrap
msgid "SOUND_MIXER_WRITE_SYNTH"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:788
#, no-wrap
msgid "0xC0044D04"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:788
#, no-wrap
msgid "SOUND_MIXER_WRITE_PCM"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:789
#, no-wrap
msgid "0xC0044D05"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:789
#, no-wrap
msgid "SOUND_MIXER_WRITE_SPEAKER"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:790
#, no-wrap
msgid "0xC0044D06"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:790
#, no-wrap
msgid "SOUND_MIXER_WRITE_LINE"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:791
#, no-wrap
msgid "0xC0044D07"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:791
#, no-wrap
msgid "SOUND_MIXER_WRITE_MIC"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:792
#, no-wrap
msgid "0xC0044D08"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:792
#, no-wrap
msgid "SOUND_MIXER_WRITE_CD"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:793
#, no-wrap
msgid "0xC0044D09"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:793
#, no-wrap
msgid "SOUND_MIXER_WRITE_IMIX"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:794
#, no-wrap
msgid "0xC0044D0A"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:794
#, no-wrap
msgid "SOUND_MIXER_WRITE_ALTPCM"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:795
#, no-wrap
msgid "0xC0044D0B"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:795
#, no-wrap
msgid "SOUND_MIXER_WRITE_RECLEV"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:796
#, no-wrap
msgid "0xC0044D0C"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:796
#, no-wrap
msgid "SOUND_MIXER_WRITE_IGAIN"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:797
#, no-wrap
msgid "0xC0044D0D"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:797
#, no-wrap
msgid "SOUND_MIXER_WRITE_OGAIN"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:798
#, no-wrap
msgid "0xC0044D0E"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:798
#, no-wrap
msgid "SOUND_MIXER_WRITE_LINE1"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:799
#, no-wrap
msgid "0xC0044D0F"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:799
#, no-wrap
msgid "SOUND_MIXER_WRITE_LINE2"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:800
#, no-wrap
msgid "0xC0044D10"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:800
#, no-wrap
msgid "SOUND_MIXER_WRITE_LINE3"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:801
#, no-wrap
msgid "0xC0044D1C"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:801
#, no-wrap
msgid "SOUND_MIXER_WRITE_MUTE"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:802
#, no-wrap
msgid "0xC0044D1D"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:802
#, no-wrap
msgid "SOUND_MIXER_WRITE_ENHANCE"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:803
#, no-wrap
msgid "0xC0044D1E"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:803
#, no-wrap
msgid "SOUND_MIXER_WRITE_LOUD"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:804
#, no-wrap
msgid "0xC0044DFF"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:804
#, no-wrap
msgid "SOUND_MIXER_WRITE_RECSRC"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_list.2:809
msgid "// E<lt>include/linux/timerfd.hE<gt> see B<timerfd_create>(2)"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:811
#, no-wrap
msgid "0x40085400"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:811
#, no-wrap
msgid "TFD_IOC_SET_TICKS"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:811
#, no-wrap
msgid "uint64_t *"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_list.2:815
msgid "// E<lt>include/linux/umsdos_fs.hE<gt>"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:817
#, no-wrap
msgid "0x000004D2"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:817
#, no-wrap
msgid "UMSDOS_READDIR_DOS"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:817 man-pages/man2/ioctl_list.2:820
#: man-pages/man2/ioctl_list.2:823 man-pages/man2/ioctl_list.2:824
#, no-wrap
msgid "struct umsdos_ioctl *"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:818
#, no-wrap
msgid "0x000004D3"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:818
#, no-wrap
msgid "UMSDOS_UNLINK_DOS"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:818 man-pages/man2/ioctl_list.2:819
#: man-pages/man2/ioctl_list.2:821 man-pages/man2/ioctl_list.2:822
#: man-pages/man2/ioctl_list.2:826 man-pages/man2/ioctl_list.2:827
#, no-wrap
msgid "const struct umsdos_ioctl *"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:819
#, no-wrap
msgid "0x000004D4"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:819
#, no-wrap
msgid "UMSDOS_RMDIR_DOS"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:820
#, no-wrap
msgid "0x000004D5"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:820
#, no-wrap
msgid "UMSDOS_STAT_DOS"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:821
#, no-wrap
msgid "0x000004D6"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:821
#, no-wrap
msgid "UMSDOS_CREAT_EMD"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:822
#, no-wrap
msgid "0x000004D7"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:822
#, no-wrap
msgid "UMSDOS_UNLINK_EMD"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:823
#, no-wrap
msgid "0x000004D8"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:823
#, no-wrap
msgid "UMSDOS_READDIR_EMD"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:824
#, no-wrap
msgid "0x000004D9"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:824
#, no-wrap
msgid "UMSDOS_GETVERSION"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:825
#, no-wrap
msgid "0x000004DA"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:825
#, no-wrap
msgid "UMSDOS_INIT_EMD"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:826
#, no-wrap
msgid "0x000004DB"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:826
#, no-wrap
msgid "UMSDOS_DOS_SETUP"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:827
#, no-wrap
msgid "0x000004DC"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:827
#, no-wrap
msgid "UMSDOS_RENAME_DOS"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_list.2:831
msgid "// E<lt>include/linux/vt.hE<gt>"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:833
#, no-wrap
msgid "0x00005600"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:833
#, no-wrap
msgid "VT_OPENQRY"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:834
#, no-wrap
msgid "0x00005601"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:834
#, no-wrap
msgid "VT_GETMODE"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:834
#, no-wrap
msgid "struct vt_mode *"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:835
#, no-wrap
msgid "0x00005602"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:835
#, no-wrap
msgid "VT_SETMODE"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:835
#, no-wrap
msgid "const struct vt_mode *"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:836
#, no-wrap
msgid "0x00005603"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:836
#, no-wrap
msgid "VT_GETSTATE"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:836
#, no-wrap
msgid "struct vt_stat *"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:837
#, no-wrap
msgid "0x00005604"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:837
#, no-wrap
msgid "VT_SENDSIG"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:838
#, no-wrap
msgid "0x00005605"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:838
#, no-wrap
msgid "VT_RELDISP"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:839
#, no-wrap
msgid "0x00005606"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:839
#, no-wrap
msgid "VT_ACTIVATE"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:840
#, no-wrap
msgid "0x00005607"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:840
#, no-wrap
msgid "VT_WAITACTIVE"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:841
#, no-wrap
msgid "0x00005608"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:841
#, no-wrap
msgid "VT_DISALLOCATE"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:842
#, no-wrap
msgid "0x00005609"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:842
#, no-wrap
msgid "VT_RESIZE"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:842
#, no-wrap
msgid "const struct vt_sizes *"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:843
#, no-wrap
msgid "0x0000560A"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:843
#, no-wrap
msgid "VT_RESIZEX"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:843
#, no-wrap
msgid "const struct vt_consize *"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_list.2:850
msgid ""
"// More arguments.  Some ioctl's take a pointer to a structure which "
"contains additional pointers.  These are documented here in alphabetical "
"order."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_list.2:858
msgid ""
"B<CDROMREADAUDIO> takes an input pointer I<const struct cdrom_read_audio\\ "
"*>.  The I<buf> field points to an output buffer of length I<nframes\\ * "
"CD_FRAMESIZE_RAW>."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_list.2:874
msgid ""
"B<CDROMREADCOOKED>, B<CDROMREADMODE1>, B<CDROMREADMODE2>, and "
"B<CDROMREADRAW> take an input pointer I<const struct cdrom_msf\\ *>.  They "
"use the same pointer as an output pointer to I<char []>.  The length varies "
"by request.  For B<CDROMREADMODE1>, most drivers use CD_FRAMESIZE, but the "
"Optics Storage driver uses OPT_BLOCKSIZE instead (both have the numerical "
"value 2048)."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_list.2:880
#, no-wrap
msgid ""
"    CDROMREADCOOKED    char [CD_FRAMESIZE]\n"
"    CDROMREADMODE1     char [CD_FRAMESIZE or OPT_BLOCKSIZE]\n"
"    CDROMREADMODE2     char [CD_FRAMESIZE_RAW0]\n"
"    CDROMREADRAW       char [CD_FRAMESIZE_RAW]\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_list.2:894
msgid ""
"B<EQL_ENSLAVE>, B<EQL_EMANCIPATE>, B<EQL_GETSLAVECFG>, B<EQL_SETSLAVECFG>, "
"B<EQL_GETMASTERCFG>, and B<EQL_SETMASTERCFG> take a I<struct ifreq\\ *>.  "
"The I<ifr_data> field is a pointer to another structure as follows:"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_list.2:902
#, no-wrap
msgid ""
"    EQL_ENSLAVE         const struct slaving_request *\n"
"    EQL_EMANCIPATE      const struct slaving_request *\n"
"    EQL_GETSLAVECFG     struct slave_config *           // I-O\n"
"    EQL_SETSLAVECFG     const struct slave_config *\n"
"    EQL_GETMASTERCFG    struct master_config *\n"
"    EQL_SETMASTERCFG    const struct master_config *\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_list.2:919
msgid ""
"B<FDRAWCMD> takes a I<struct floppy raw_cmd\\ *>.  If I<flags & "
"FD_RAW_WRITE> is nonzero, then I<data> points to an input buffer of length "
"I<length>.  If I<flags & FD_RAW_READ> is nonzero, then I<data> points to an "
"output buffer of length I<length>."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_list.2:935
msgid ""
"B<GIO_FONTX> and B<PIO_FONTX> take a I<struct console_font_desc\\ *> or a "
"I<const struct console_font_desc\\ *>, respectively.  I<chardata> points to "
"a buffer of I<char [charcount]>.  This is an output buffer for B<GIO_FONTX> "
"and an input buffer for B<PIO_FONTX>."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_list.2:951
msgid ""
"B<GIO_UNIMAP> and B<PIO_UNIMAP> take a I<struct unimapdesc\\ *> or a I<const "
"struct unimapdesc\\ *>, respectively.  I<entries> points to a buffer of "
"I<struct unipair [entry_ct]>.  This is an output buffer for B<GIO_UNIMAP> "
"and an input buffer for B<PIO_UNIMAP>."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_list.2:955
msgid ""
"KDADDIO, KDDELIO, KDDISABIO, and KDENABIO enable or disable access to I/O "
"ports.  They are essentially alternate interfaces to 'ioperm'."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_list.2:961
msgid ""
"B<KDMAPDISP> and B<KDUNMAPDISP> enable or disable memory mappings or I/O "
"port access.  They are not implemented in the kernel."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_list.2:969
msgid ""
"B<SCSI_IOCTL_PROBE_HOST> takes an input pointer I<const int\\ *>, which is a "
"length.  It uses the same pointer as an output pointer to a I<char []> "
"buffer of this length."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_list.2:975
msgid ""
"B<SIOCADDRT> and B<SIOCDELRT> take an input pointer whose type depends on "
"the protocol:"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_list.2:981
#, no-wrap
msgid ""
"    Most protocols      const struct rtentry *\n"
"    AX.25               const struct ax25_route *\n"
"    NET/ROM             const struct nr_route_struct *\n"
"    INET6               const struct in6_rtmsg *\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_list.2:992
msgid ""
"B<SIOCGIFCONF> takes a I<struct ifconf\\ *>.  The I<ifc_buf> field points to "
"a buffer of length I<ifc_len> bytes, into which the kernel writes a list of "
"type I<struct ifreq []>."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_list.2:995
msgid "B<SIOCSIFHWADDR> takes an input pointer whose type depends on the protocol:"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_list.2:999
#, no-wrap
msgid ""
"    Most protocols      const struct ifreq *\n"
"    AX.25               const char [AX25_ADDR_LEN]\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_list.2:1014
msgid ""
"B<TIOCLINUX> takes a I<const char\\ *>.  It uses this to distinguish several "
"independent subcases.  In the table below, I<N + foo> means I<foo> after an "
"N-byte pad.  I<struct selection> is implicitly defined in "
"I<drivers/char/selection.c>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_list.2:1023
#, no-wrap
msgid ""
"    TIOCLINUX-2         1 + const struct selection *\n"
"    TIOCLINUX-3         void\n"
"    TIOCLINUX-4         void\n"
"    TIOCLINUX-5         4 + const struct { long [8]; } *\n"
"    TIOCLINUX-6         char *\n"
"    TIOCLINUX-7         char *\n"
"    TIOCLINUX-10        1 + const char *\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_list.2:1026
msgid "// Duplicate ioctls"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_list.2:1031
msgid ""
"This list does not include ioctls in the range B<SIOCDEVPRIVATE> and "
"B<SIOCPROTOPRIVATE>."
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_list.2:1035
#, no-wrap
msgid "SCSI_IOCTL_GET_IDLUN"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_list.2:1043
msgid "B<ioctl>(2), B<ioctl_fat>(2), B<netdevice>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/sysfs.2:27
#, no-wrap
msgid "SYSFS"
msgstr ""

#. type: Plain text
#: man-pages/man2/sysfs.2:30
msgid "sysfs - get filesystem type information"
msgstr ""

#. type: Plain text
#: man-pages/man2/sysfs.2:32
msgid "B<int sysfs(int >I<option>B<, const char *>I<fsname>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/sysfs.2:34
msgid ""
"B<int sysfs(int >I<option>B<, unsigned int >I<fs_index>B<, char "
"*>I<buf>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/sysfs.2:36
msgid "B<int sysfs(int >I<option>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/sysfs.2:44
msgid ""
"B<Note>: if you are looking for information about the B<sysfs> filesystem "
"that is normally mounted at I</sys>, see B<sysfs>(5)."
msgstr ""

#. type: Plain text
#: man-pages/man2/sysfs.2:54
msgid ""
"The (obsolete)  B<sysfs>()  system call returns information about the "
"filesystem types currently present in the kernel.  The specific form of the "
"B<sysfs>()  call and the information returned depends on the I<option> in "
"effect:"
msgstr ""

#. type: TP
#: man-pages/man2/sysfs.2:54
#, no-wrap
msgid "B<1>"
msgstr ""

#. type: Plain text
#: man-pages/man2/sysfs.2:59
msgid ""
"Translate the filesystem identifier string I<fsname> into a filesystem type "
"index."
msgstr ""

#. type: TP
#: man-pages/man2/sysfs.2:59
#, no-wrap
msgid "B<2>"
msgstr ""

#. type: Plain text
#: man-pages/man2/sysfs.2:70
msgid ""
"Translate the filesystem type index I<fs_index> into a null-terminated "
"filesystem identifier string.  This string will be written to the buffer "
"pointed to by I<buf>.  Make sure that I<buf> has enough space to accept the "
"string."
msgstr ""

#. type: TP
#: man-pages/man2/sysfs.2:70
#, no-wrap
msgid "B<3>"
msgstr ""

#. type: Plain text
#: man-pages/man2/sysfs.2:74
msgid "Return the total number of filesystem types currently present in the kernel."
msgstr ""

#. type: Plain text
#: man-pages/man2/sysfs.2:76
msgid "The numbering of the filesystem type indexes begins with zero."
msgstr ""

#. type: Plain text
#: man-pages/man2/sysfs.2:88
msgid ""
"On success, B<sysfs>()  returns the filesystem index for option B<1>, zero "
"for option B<2>, and the number of currently configured filesystems for "
"option B<3>.  On error, -1 is returned, and I<errno> is set appropriately."
msgstr ""

#. type: Plain text
#: man-pages/man2/sysfs.2:93
msgid "Either I<fsname> or I<buf> is outside your accessible address space."
msgstr ""

#. type: Plain text
#: man-pages/man2/sysfs.2:101
msgid ""
"I<fsname> is not a valid filesystem type identifier; I<fs_index> is "
"out-of-bounds; I<option> is invalid."
msgstr ""

#. type: Plain text
#: man-pages/man2/sysfs.2:110
msgid ""
"This System-V derived system call is obsolete; don't use it.  On systems "
"with I</proc>, the same information can be obtained via "
"I</proc/filesystems>; use that interface instead."
msgstr ""

#. type: Plain text
#: man-pages/man2/sysfs.2:112
msgid ""
"There is no libc or glibc support.  There is no way to guess how large "
"I<buf> should be."
msgstr ""

#. type: TH
#: man-pages/man2/dup.2:37
#, no-wrap
msgid "DUP"
msgstr ""

#. type: Plain text
#: man-pages/man2/dup.2:40
msgid "dup, dup2, dup3 - duplicate a file descriptor"
msgstr ""

#. type: Plain text
#: man-pages/man2/dup.2:46
#, no-wrap
msgid ""
"B<int dup(int >I<oldfd>B<);>\n"
"B<int dup2(int >I<oldfd>B<, int >I<newfd>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/dup.2:52
#, no-wrap
msgid "B<int dup3(int >I<oldfd>B<, int >I<newfd>B<, int >I<flags>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/dup.2:59
msgid ""
"The B<dup>()  system call creates a copy of the file descriptor I<oldfd>, "
"using the lowest-numbered unused file descriptor for the new descriptor."
msgstr ""

#. type: Plain text
#: man-pages/man2/dup.2:68
msgid ""
"After a successful return, the old and new file descriptors may be used "
"interchangeably.  They refer to the same open file description (see "
"B<open>(2))  and thus share file offset and file status flags; for example, "
"if the file offset is modified by using B<lseek>(2)  on one of the file "
"descriptors, the offset is also changed for the other."
msgstr ""

#. type: Plain text
#: man-pages/man2/dup.2:77
msgid ""
"The two file descriptors do not share file descriptor flags (the "
"close-on-exec flag).  The close-on-exec flag (B<FD_CLOEXEC>; see "
"B<fcntl>(2))  for the duplicate descriptor is off."
msgstr ""

#. type: SS
#: man-pages/man2/dup.2:77
#, no-wrap
msgid "dup2()"
msgstr ""

#. type: Plain text
#: man-pages/man2/dup.2:88
msgid ""
"The B<dup2>()  system call performs the same task as B<dup>(), but instead "
"of using the lowest-numbered unused file descriptor, it uses the file "
"descriptor number specified in I<newfd>.  If the file descriptor I<newfd> "
"was previously open, it is silently closed before being reused."
msgstr ""

#. type: Plain text
#: man-pages/man2/dup.2:104
msgid ""
"The steps of closing and reusing the file descriptor I<newfd> are performed "
"I<atomically>.  This is important, because trying to implement equivalent "
"functionality using B<close>(2)  and B<dup>()  would be subject to race "
"conditions, whereby I<newfd> might be reused between the two steps.  Such "
"reuse could happen because the main program is interrupted by a signal "
"handler that allocates a file descriptor, or because a parallel thread "
"allocates a file descriptor."
msgstr ""

#. type: Plain text
#: man-pages/man2/dup.2:106
msgid "Note the following points:"
msgstr ""

#. type: Plain text
#: man-pages/man2/dup.2:112
msgid ""
"If I<oldfd> is not a valid file descriptor, then the call fails, and "
"I<newfd> is not closed."
msgstr ""

#. type: Plain text
#: man-pages/man2/dup.2:124
msgid ""
"If I<oldfd> is a valid file descriptor, and I<newfd> has the same value as "
"I<oldfd>, then B<dup2>()  does nothing, and returns I<newfd>."
msgstr ""

#. type: SS
#: man-pages/man2/dup.2:124
#, no-wrap
msgid "dup3()"
msgstr ""

#. type: Plain text
#: man-pages/man2/dup.2:129
msgid "B<dup3>()  is the same as B<dup2>(), except that:"
msgstr ""

#. type: Plain text
#: man-pages/man2/dup.2:138
msgid ""
"The caller can force the close-on-exec flag to be set for the new file "
"descriptor by specifying B<O_CLOEXEC> in I<flags>.  See the description of "
"the same flag in B<open>(2)  for reasons why this may be useful."
msgstr ""

#.  Ulrich Drepper, LKML, 2008-10-09:
#. 	We deliberately decided on this change.  Otherwise, what is the
#. 	result of dup3(fd, fd, O_CLOEXEC)?
#. type: Plain text
#: man-pages/man2/dup.2:150
msgid "If I<oldfd> equals I<newfd>, then B<dup3>()  fails with the error B<EINVAL>."
msgstr ""

#. type: Plain text
#: man-pages/man2/dup.2:156
msgid ""
"On success, these system calls return the new file descriptor.  On error, -1 "
"is returned, and I<errno> is set appropriately."
msgstr ""

#. type: Plain text
#: man-pages/man2/dup.2:161
msgid "I<oldfd> isn't an open file descriptor."
msgstr ""

#. type: Plain text
#: man-pages/man2/dup.2:168
msgid ""
"I<newfd> is out of the allowed range for file descriptors (see the "
"discussion of B<RLIMIT_NOFILE> in B<getrlimit>(2))."
msgstr ""

#. type: Plain text
#: man-pages/man2/dup.2:178
msgid ""
"(Linux only) This may be returned by B<dup2>()  or B<dup3>()  during a race "
"condition with B<open>(2)  and B<dup>()."
msgstr ""

#. type: Plain text
#: man-pages/man2/dup.2:186
msgid ""
"The B<dup2>()  or B<dup3>()  call was interrupted by a signal; see "
"B<signal>(7)."
msgstr ""

#. type: Plain text
#: man-pages/man2/dup.2:191
msgid "(B<dup3>())  I<flags> contain an invalid value."
msgstr ""

#. type: Plain text
#: man-pages/man2/dup.2:197
msgid "(B<dup3>())  I<oldfd> was equal to I<newfd>."
msgstr ""

#. type: Plain text
#: man-pages/man2/dup.2:204
msgid ""
"The per-process limit on the number of open file descriptors has been "
"reached (see the discussion of B<RLIMIT_NOFILE> in B<getrlimit>(2))."
msgstr ""

#. type: Plain text
#: man-pages/man2/dup.2:209
msgid ""
"B<dup3>()  was added to Linux in version 2.6.27; glibc support is available "
"starting with version 2.9."
msgstr ""

#. type: Plain text
#: man-pages/man2/dup.2:213
msgid "B<dup>(), B<dup2>(): POSIX.1-2001, POSIX.1-2008, SVr4, 4.3BSD."
msgstr ""

#.  SVr4 documents additional
#.  EINTR and ENOLINK error conditions.  POSIX.1 adds EINTR.
#.  The EBUSY return is Linux-specific.
#. type: Plain text
#: man-pages/man2/dup.2:219
msgid "B<dup3>()  is Linux-specific."
msgstr ""

#. type: Plain text
#: man-pages/man2/dup.2:233
msgid ""
"The error returned by B<dup2>()  is different from that returned by "
"B<fcntl(>..., B<F_DUPFD>, ...B<)> when I<newfd> is out of range.  On some "
"systems, B<dup2>()  also sometimes returns B<EINVAL> like B<F_DUPFD>."
msgstr ""

#. type: Plain text
#: man-pages/man2/dup.2:249
msgid ""
"If I<newfd> was open, any errors that would have been reported at "
"B<close>(2)  time are lost.  If this is of concern, then\\(emunless the "
"program is single-threaded and does not allocate file descriptors in signal "
"handlers\\(emthe correct approach is I<not> to close I<newfd> before calling "
"B<dup2>(), because of the race condition described above.  Instead, code "
"something like the following could be used:"
msgstr ""

#. type: Plain text
#: man-pages/man2/dup.2:254
#, no-wrap
msgid ""
"    /* Obtain a duplicate of 'newfd' that can subsequently\n"
"       be used to check for close() errors; an EBADF error\n"
"       means that 'newfd' was not open. */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/dup.2:259
#, no-wrap
msgid ""
"    tmpfd = dup(newfd);\n"
"    if (tmpfd == -1 && errno != EBADF) {\n"
"        /* Handle unexpected dup() error */\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/dup.2:261
#, no-wrap
msgid "    /* Atomically duplicate 'oldfd' on 'newfd' */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/dup.2:265
#, no-wrap
msgid ""
"    if (dup2(oldfd, newfd) == -1) {\n"
"        /* Handle dup2() error */\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/dup.2:268
#, no-wrap
msgid ""
"    /* Now check for close() errors on the file originally\n"
"       referred to by 'newfd' */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/dup.2:274
#, no-wrap
msgid ""
"    if (tmpfd != -1) {\n"
"        if (close(tmpfd) == -1) {\n"
"            /* Handle errors from close */\n"
"        }\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/dup.2:278
msgid "B<close>(2), B<fcntl>(2), B<open>(2)"
msgstr ""

#. type: TH
#: man-pages/man2/tkill.2:29
#, no-wrap
msgid "TKILL"
msgstr ""

#. type: Plain text
#: man-pages/man2/tkill.2:32
msgid "tkill, tgkill - send a signal to a thread"
msgstr ""

#. type: Plain text
#: man-pages/man2/tkill.2:35
#, no-wrap
msgid "B<int tkill(int >I<tid>B<, int >I<sig>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/tkill.2:37
#, no-wrap
msgid "B<int tgkill(int >I<tgid>B<, int >I<tid>B<, int >I<sig>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/tkill.2:43
msgid "I<Note>: There is no glibc wrapper for B<tkill>(); see NOTES."
msgstr ""

#. type: Plain text
#: man-pages/man2/tkill.2:56
msgid ""
"B<tgkill>()  sends the signal I<sig> to the thread with the thread ID I<tid> "
"in the thread group I<tgid>.  (By contrast, B<kill>(2)  can be used to send "
"a signal only to a process (i.e., thread group)  as a whole, and the signal "
"will be delivered to an arbitrary thread within that process.)"
msgstr ""

#.  FIXME Maybe say something about the following:
#.  http://sourceware.org/bugzilla/show_bug.cgi?id=12889
#
#.  Quoting Rich Felker <bugdal@aerifal.cx>:
#
#.  There is a race condition in pthread_kill: it is possible that,
#.  between the time pthread_kill reads the pid/tid from the target
#.  thread descriptor and the time it makes the tgkill syscall,
#.  the target thread terminates and the same tid gets assigned
#.  to a new thread in the same process.
#
#.  (The tgkill syscall was designed to eliminate a similar race
#.  condition in tkill, but it only succeeded in eliminating races
#.  where the tid gets reused in a different process, and does not
#.  help if the same tid gets assigned to a new thread in the
#.  same process.)
#
#.  The only solution I can see is to introduce a mutex that ensures
#.  that a thread cannot exit while pthread_kill is being called on it.
#
#.  Note that in most real-world situations, like almost all race
#.  conditions, this one will be extremely rare. To make it
#.  measurable, one could exhaust all but 1-2 available pid values,
#.  possibly by lowering the max pid parameter in /proc, forcing
#.  the same tid to be reused rapidly.
#. type: Plain text
#: man-pages/man2/tkill.2:89
msgid ""
"B<tkill>()  is an obsolete predecessor to B<tgkill>().  It allows only the "
"target thread ID to be specified, which may result in the wrong thread being "
"signaled if a thread terminates and its thread ID is recycled.  Avoid using "
"this system call."
msgstr ""

#. type: Plain text
#: man-pages/man2/tkill.2:92
msgid ""
"These are the raw system call interfaces, meant for internal thread library "
"use."
msgstr ""

#. type: Plain text
#: man-pages/man2/tkill.2:104
msgid ""
"The B<RLIMIT_SIGPENDING> resource limit was reached and I<sig> is a "
"real-time signal."
msgstr ""

#. type: Plain text
#: man-pages/man2/tkill.2:109
msgid "Insufficient kernel memory was available and I<sig> is a real-time signal."
msgstr ""

#. type: Plain text
#: man-pages/man2/tkill.2:112
msgid "An invalid thread ID, thread group ID, or signal was specified."
msgstr ""

#. type: Plain text
#: man-pages/man2/tkill.2:117
msgid "Permission denied.  For the required permissions, see B<kill>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/tkill.2:120
msgid "No process with the specified thread ID (and thread group ID) exists."
msgstr ""

#. type: Plain text
#: man-pages/man2/tkill.2:125
msgid ""
"B<tkill>()  is supported since Linux 2.4.19 / 2.5.4.  B<tgkill>()  was added "
"in Linux 2.5.75."
msgstr ""

#. type: Plain text
#: man-pages/man2/tkill.2:129
msgid "Library support for B<tgkill>()  was added to glibc in version 2.30."
msgstr ""

#. type: Plain text
#: man-pages/man2/tkill.2:135
msgid ""
"B<tkill>()  and B<tgkill>()  are Linux-specific and should not be used in "
"programs that are intended to be portable."
msgstr ""

#. type: Plain text
#: man-pages/man2/tkill.2:141
msgid ""
"See the description of B<CLONE_THREAD> in B<clone>(2)  for an explanation of "
"thread groups."
msgstr ""

#. type: Plain text
#: man-pages/man2/tkill.2:148
msgid ""
"Glibc does not provide a wrapper for B<tkill>(); call it using "
"B<syscall>(2).  Before glibc 2.30, there was also no wrapper function for "
"B<tgkill>()."
msgstr ""

#. type: Plain text
#: man-pages/man2/tkill.2:152
msgid "B<clone>(2), B<gettid>(2), B<kill>(2), B<rt_sigqueueinfo>(2)"
msgstr ""

#. type: TH
#: man-pages/man2/getgid.2:25
#, no-wrap
msgid "GETGID"
msgstr ""

#. type: Plain text
#: man-pages/man2/getgid.2:28
msgid "getgid, getegid - get group identity"
msgstr ""

#. type: Plain text
#: man-pages/man2/getgid.2:34
msgid "B<gid_t getgid(void);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/getgid.2:36
msgid "B<gid_t getegid(void);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/getgid.2:39
msgid "B<getgid>()  returns the real group ID of the calling process."
msgstr ""

#. type: Plain text
#: man-pages/man2/getgid.2:42
msgid "B<getegid>()  returns the effective group ID of the calling process."
msgstr ""

#. type: Plain text
#: man-pages/man2/getgid.2:62
msgid ""
"The original Linux B<getgid>()  and B<getegid>()  system calls supported "
"only 16-bit group IDs.  Subsequently, Linux 2.4 added B<getgid32>()  and "
"B<getegid32>(), supporting 32-bit IDs.  The glibc B<getgid>()  and "
"B<getegid>()  wrapper functions transparently deal with the variations "
"across kernel versions."
msgstr ""

#. type: Plain text
#: man-pages/man2/getgid.2:78
msgid ""
"On Alpha, instead of a pair of B<getgid>()  and B<getegid>()  system calls, "
"a single B<getxgid>()  system call is provided, which returns a pair of real "
"and effective GIDs.  The glibc B<getgid>()  and B<getegid>()  wrapper "
"functions transparently deal with this.  See B<syscall>(2)  for details "
"regarding register mapping."
msgstr ""

#. type: Plain text
#: man-pages/man2/getgid.2:82
msgid "B<getresgid>(2), B<setgid>(2), B<setregid>(2), B<credentials>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/getunwind.2:27
#, no-wrap
msgid "GETUNWIND"
msgstr ""

#. type: Plain text
#: man-pages/man2/getunwind.2:30
msgid "getunwind - copy the unwind data to caller's buffer"
msgstr ""

#. type: Plain text
#: man-pages/man2/getunwind.2:34
#, no-wrap
msgid ""
"B<#include E<lt>syscall.hE<gt>>\n"
"B<#include E<lt>linux/unwind.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/getunwind.2:36
#, no-wrap
msgid "B<long getunwind(void >I<*buf>B<, size_t >I<buf_size>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/getunwind.2:42
msgid "I<Note: this function is obsolete.>"
msgstr ""

#. type: Plain text
#: man-pages/man2/getunwind.2:52
msgid ""
"The IA-64-specific B<getunwind>()  system call copies the kernel's call "
"frame unwind data into the buffer pointed to by I<buf> and returns the size "
"of the unwind data; this data describes the gate page (kernel code that is "
"mapped into user space)."
msgstr ""

#. type: Plain text
#: man-pages/man2/getunwind.2:64
msgid ""
"The size of the buffer I<buf> is specified in I<buf_size>.  The data is "
"copied only if I<buf_size> is greater than or equal to the size of the "
"unwind data and I<buf> is not NULL; otherwise, no data is copied, and the "
"call succeeds, returning the size that would be needed to store the unwind "
"data."
msgstr ""

#. type: Plain text
#: man-pages/man2/getunwind.2:68
msgid ""
"The first part of the unwind data contains an unwind table.  The rest "
"contains the associated unwind information, in no particular order.  The "
"unwind table contains entries of the following form:"
msgstr ""

#. type: Plain text
#: man-pages/man2/getunwind.2:74
#, no-wrap
msgid ""
"u64 start;      (64-bit address of start of function)\n"
"u64 end;        (64-bit address of end of function)\n"
"u64 info;       (BUF-relative offset to unwind info)\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/getunwind.2:83
msgid ""
"An entry whose I<start> value is zero indicates the end of the table.  For "
"more information about the format, see the I<IA-64 Software Conventions and "
"Runtime Architecture> manual."
msgstr ""

#. type: Plain text
#: man-pages/man2/getunwind.2:90
msgid ""
"On success, B<getunwind>()  returns the size of the unwind data.  On error, "
"-1 is returned and I<errno> is set to indicate the error."
msgstr ""

#. type: Plain text
#: man-pages/man2/getunwind.2:96
msgid ""
"B<getunwind>()  fails with the error B<EFAULT> if the unwind info can't be "
"stored in the space specified by I<buf>."
msgstr ""

#. type: Plain text
#: man-pages/man2/getunwind.2:98
msgid "This system call is available since Linux 2.4."
msgstr ""

#. type: Plain text
#: man-pages/man2/getunwind.2:101
msgid ""
"This system call is Linux-specific, and is available only on the IA-64 "
"architecture."
msgstr ""

#. type: Plain text
#: man-pages/man2/getunwind.2:105
msgid ""
"This system call has been deprecated.  The modern way to obtain the kernel's "
"unwind data is via the B<vdso>(7)."
msgstr ""

#. type: Plain text
#: man-pages/man2/getunwind.2:109
msgid ""
"Glibc does not provide a wrapper for this system call; in the unlikely event "
"that you want to call it, use B<syscall>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/getunwind.2:110
msgid "B<getauxval>(3)"
msgstr ""

#. type: TH
#: man-pages/man2/accept.2:41
#, no-wrap
msgid "ACCEPT"
msgstr ""

#. type: Plain text
#: man-pages/man2/accept.2:44
msgid "accept, accept4 - accept a connection on a socket"
msgstr ""

#. type: Plain text
#: man-pages/man2/accept.2:50
#, no-wrap
msgid ""
"B<int accept(int >I<sockfd>B<, struct sockaddr *>I<addr>B<, socklen_t "
"*>I<addrlen>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/accept.2:53
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>             /* See feature_test_macros(7) */\n"
"B<#include E<lt>sys/socket.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/accept.2:56
#, no-wrap
msgid ""
"B<int accept4(int >I<sockfd>B<, struct sockaddr *>I<addr>B<,>\n"
"B<            socklen_t *>I<addrlen>B<, int >I<flags>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/accept.2:72
msgid ""
"The B<accept>()  system call is used with connection-based socket types "
"(B<SOCK_STREAM>, B<SOCK_SEQPACKET>).  It extracts the first connection "
"request on the queue of pending connections for the listening socket, "
"I<sockfd>, creates a new connected socket, and returns a new file descriptor "
"referring to that socket.  The newly created socket is not in the listening "
"state.  The original socket I<sockfd> is unaffected by this call."
msgstr ""

#. type: Plain text
#: man-pages/man2/accept.2:81
msgid ""
"The argument I<sockfd> is a socket that has been created with B<socket>(2), "
"bound to a local address with B<bind>(2), and is listening for connections "
"after a B<listen>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/accept.2:99
msgid ""
"The argument I<addr> is a pointer to a I<sockaddr> structure.  This "
"structure is filled in with the address of the peer socket, as known to the "
"communications layer.  The exact format of the address returned I<addr> is "
"determined by the socket's address family (see B<socket>(2)  and the "
"respective protocol man pages).  When I<addr> is NULL, nothing is filled in; "
"in this case, I<addrlen> is not used, and should also be NULL."
msgstr ""

#. type: Plain text
#: man-pages/man2/accept.2:107
msgid ""
"The I<addrlen> argument is a value-result argument: the caller must "
"initialize it to contain the size (in bytes) of the structure pointed to by "
"I<addr>; on return it will contain the actual size of the peer address."
msgstr ""

#. type: Plain text
#: man-pages/man2/accept.2:125
msgid ""
"If no pending connections are present on the queue, and the socket is not "
"marked as nonblocking, B<accept>()  blocks the caller until a connection is "
"present.  If the socket is marked nonblocking and no pending connections are "
"present on the queue, B<accept>()  fails with the error B<EAGAIN> or "
"B<EWOULDBLOCK>."
msgstr ""

#. type: Plain text
#: man-pages/man2/accept.2:140
msgid ""
"In order to be notified of incoming connections on a socket, you can use "
"B<select>(2), B<poll>(2), or B<epoll>(7).  A readable event will be "
"delivered when a new connection is attempted and you may then call "
"B<accept>()  to get a socket for that connection.  Alternatively, you can "
"set the socket to deliver B<SIGIO> when activity occurs on a socket; see "
"B<socket>(7)  for details."
msgstr ""

#. type: Plain text
#: man-pages/man2/accept.2:150
msgid ""
"If I<flags> is 0, then B<accept4>()  is the same as B<accept>().  The "
"following values can be bitwise ORed in I<flags> to obtain different "
"behavior:"
msgstr ""

#. type: Plain text
#: man-pages/man2/accept.2:179
msgid ""
"On success, these system calls return a nonnegative integer that is a file "
"descriptor for the accepted socket.  On error, -1 is returned, I<errno> is "
"set appropriately, and I<addrlen> is left unchanged."
msgstr ""

#. type: SS
#: man-pages/man2/accept.2:179
#, no-wrap
msgid "Error handling"
msgstr ""

#. type: Plain text
#: man-pages/man2/accept.2:206
msgid ""
"Linux B<accept>()  (and B<accept4>())  passes already-pending network errors "
"on the new socket as an error code from B<accept>().  This behavior differs "
"from other BSD socket implementations.  For reliable operation the "
"application should detect the network errors defined for the protocol after "
"B<accept>()  and treat them like B<EAGAIN> by retrying.  In the case of "
"TCP/IP, these are B<ENETDOWN>, B<EPROTO>, B<ENOPROTOOPT>, B<EHOSTDOWN>, "
"B<ENONET>, B<EHOSTUNREACH>, B<EOPNOTSUPP>, and B<ENETUNREACH>."
msgstr ""

#.  Actually EAGAIN on Linux
#. type: Plain text
#: man-pages/man2/accept.2:216
msgid ""
"The socket is marked nonblocking and no connections are present to be "
"accepted.  POSIX.1-2001 and POSIX.1-2008 allow either error to be returned "
"for this case, and do not require these constants to have the same value, so "
"a portable application should check for both possibilities."
msgstr ""

#. type: Plain text
#: man-pages/man2/accept.2:220
msgid "I<sockfd> is not an open file descriptor."
msgstr ""

#. type: TP
#: man-pages/man2/accept.2:220
#, no-wrap
msgid "B<ECONNABORTED>"
msgstr ""

#. type: Plain text
#: man-pages/man2/accept.2:223
msgid "A connection has been aborted."
msgstr ""

#. type: Plain text
#: man-pages/man2/accept.2:228
msgid "The I<addr> argument is not in a writable part of the user address space."
msgstr ""

#. type: Plain text
#: man-pages/man2/accept.2:233
msgid ""
"The system call was interrupted by a signal that was caught before a valid "
"connection arrived; see B<signal>(7)."
msgstr ""

#. type: Plain text
#: man-pages/man2/accept.2:238
msgid ""
"Socket is not listening for connections, or I<addrlen> is invalid (e.g., is "
"negative)."
msgstr ""

#. type: Plain text
#: man-pages/man2/accept.2:243
msgid "(B<accept4>())  invalid value in I<flags>."
msgstr ""

#. type: TP
#: man-pages/man2/accept.2:249
#, no-wrap
msgid "B<ENOBUFS>, B<ENOMEM>"
msgstr ""

#. type: Plain text
#: man-pages/man2/accept.2:254
msgid ""
"Not enough free memory.  This often means that the memory allocation is "
"limited by the socket buffer limits, not by the system memory."
msgstr ""

#. type: Plain text
#: man-pages/man2/accept.2:263
msgid "The referenced socket is not of type B<SOCK_STREAM>."
msgstr ""

#. type: TP
#: man-pages/man2/accept.2:263
#, no-wrap
msgid "B<EPROTO>"
msgstr ""

#. type: Plain text
#: man-pages/man2/accept.2:266
msgid "Protocol error."
msgstr ""

#. type: Plain text
#: man-pages/man2/accept.2:270
msgid "In addition, Linux B<accept>()  may fail if:"
msgstr ""

#. type: Plain text
#: man-pages/man2/accept.2:273
msgid "Firewall rules forbid connection."
msgstr ""

#. type: Plain text
#: man-pages/man2/accept.2:285
msgid ""
"In addition, network errors for the new socket and as defined for the "
"protocol may be returned.  Various Linux kernels can return other errors "
"such as B<ENOSR>, B<ESOCKTNOSUPPORT>, B<EPROTONOSUPPORT>, B<ETIMEDOUT>.  The "
"value B<ERESTARTSYS> may be seen during a trace."
msgstr ""

#. type: Plain text
#: man-pages/man2/accept.2:290
msgid ""
"The B<accept4>()  system call is available starting with Linux 2.6.28; "
"support in glibc is available starting with version 2.10."
msgstr ""

#.  The BSD man page documents five possible error returns
#.  (EBADF, ENOTSOCK, EOPNOTSUPP, EWOULDBLOCK, EFAULT).
#.  POSIX.1-2001 documents errors
#.  EAGAIN, EBADF, ECONNABORTED, EINTR, EINVAL, EMFILE,
#.  ENFILE, ENOBUFS, ENOMEM, ENOTSOCK, EOPNOTSUPP, EPROTO, EWOULDBLOCK.
#.  In addition, SUSv2 documents EFAULT and ENOSR.
#. type: Plain text
#: man-pages/man2/accept.2:302
msgid ""
"B<accept>(): POSIX.1-2001, POSIX.1-2008, SVr4, 4.4BSD (B<accept>()  first "
"appeared in 4.2BSD)."
msgstr ""

#. type: Plain text
#: man-pages/man2/accept.2:305
msgid "B<accept4>()  is a nonstandard Linux extension."
msgstr ""

#.  Some testing seems to show that Tru64 5.1 and HP-UX 11 also
#.  do not inherit file status flags -- MTK Jun 05
#. type: Plain text
#: man-pages/man2/accept.2:320
msgid ""
"On Linux, the new socket returned by B<accept>()  does I<not> inherit file "
"status flags such as B<O_NONBLOCK> and B<O_ASYNC> from the listening "
"socket.  This behavior differs from the canonical BSD sockets "
"implementation.  Portable programs should not rely on inheritance or "
"noninheritance of file status flags and always explicitly set all required "
"flags on the socket returned from B<accept>()."
msgstr ""

#. type: Plain text
#: man-pages/man2/accept.2:326
msgid ""
"POSIX.1-2001 does not require the inclusion of I<E<lt>sys/types.hE<gt>>, and "
"this header file is not required on Linux.  However, some historical (BSD) "
"implementations required this header file, and portable applications are "
"probably wise to include it."
msgstr ""

#. type: Plain text
#: man-pages/man2/accept.2:348
msgid ""
"There may not always be a connection waiting after a B<SIGIO> is delivered "
"or B<select>(2), B<poll>(2), or B<epoll>(7)  return a readability event "
"because the connection might have been removed by an asynchronous network "
"error or another thread before B<accept>()  is called.  If this happens, "
"then the call will block waiting for the next connection to arrive.  To "
"ensure that B<accept>()  never blocks, the passed socket I<sockfd> needs to "
"have the B<O_NONBLOCK> flag set (see B<socket>(7))."
msgstr ""

#. type: Plain text
#: man-pages/man2/accept.2:359
msgid ""
"For certain protocols which require an explicit confirmation, such as "
"DECnet, B<accept>()  can be thought of as merely dequeuing the next "
"connection request and not implying confirmation.  Confirmation can be "
"implied by a normal read or write on the new file descriptor, and rejection "
"can be implied by closing the new socket.  Currently, only DECnet has these "
"semantics on Linux."
msgstr ""

#. type: SS
#: man-pages/man2/accept.2:359
#, no-wrap
msgid "The socklen_t type"
msgstr ""

#.  such as Linux libc4 and libc5, SunOS 4, SGI
#.  SunOS 5 has 'size_t *'
#. type: Plain text
#: man-pages/man2/accept.2:370
msgid ""
"In the original BSD sockets implementation (and on other older systems)  the "
"third argument of B<accept>()  was declared as an I<int\\ *>.  A POSIX.1g "
"draft standard wanted to change it into a I<size_t\\ *>C; later POSIX "
"standards and glibc 2.x have I<socklen_t\\ * >."
msgstr ""

#. type: Plain text
#: man-pages/man2/accept.2:379
msgid ""
"B<bind>(2), B<connect>(2), B<listen>(2), B<select>(2), B<socket>(2), "
"B<socket>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/readahead.2:28
#, no-wrap
msgid "READAHEAD"
msgstr ""

#. type: Plain text
#: man-pages/man2/readahead.2:31
msgid "readahead - initiate file readahead into page cache"
msgstr ""

#. type: Plain text
#: man-pages/man2/readahead.2:37
#, no-wrap
msgid ""
"B<ssize_t readahead(int >I<fd>B<, off64_t >I<offset>B<, size_t "
">I<count>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/readahead.2:44
msgid ""
"B<readahead>()  initiates readahead on a file so that subsequent reads from "
"that file will be satisfied from the cache, and not block on disk I/O "
"(assuming the readahead was initiated early enough and that other activity "
"on the system did not in the meantime flush pages from the cache)."
msgstr ""

#. type: Plain text
#: man-pages/man2/readahead.2:66
msgid ""
"The I<fd> argument is a file descriptor identifying the file which is to be "
"read.  The I<offset> argument specifies the starting point from which data "
"is to be read and I<count> specifies the number of bytes to be read.  I/O is "
"performed in whole pages, so that I<offset> is effectively rounded down to a "
"page boundary and bytes are read up to the next page boundary greater than "
"or equal to I<(offset+count)>.  B<readahead>()  does not read beyond the end "
"of the file.  The file offset of the open file description referred to by "
"the file descriptor I<fd> is left unchanged."
msgstr ""

#. type: Plain text
#: man-pages/man2/readahead.2:72
msgid ""
"On success, B<readahead>()  returns 0; on failure, -1 is returned, with "
"I<errno> set to indicate the cause of the error."
msgstr ""

#. type: Plain text
#: man-pages/man2/readahead.2:77 man-pages/man2/read.2:126
msgid "I<fd> is not a valid file descriptor or is not open for reading."
msgstr ""

#. type: Plain text
#: man-pages/man2/readahead.2:83
msgid "I<fd> does not refer to a file type to which B<readahead>()  can be applied."
msgstr ""

#. type: Plain text
#: man-pages/man2/readahead.2:88
msgid ""
"The B<readahead>()  system call appeared in Linux 2.4.13; glibc support has "
"been provided since version 2.3."
msgstr ""

#. type: Plain text
#: man-pages/man2/readahead.2:93
msgid ""
"The B<readahead>()  system call is Linux-specific, and its use should be "
"avoided in portable applications."
msgstr ""

#. type: Plain text
#: man-pages/man2/readahead.2:98
msgid ""
"On some 32-bit architectures, the calling signature for this system call "
"differs, for the reasons described in B<syscall>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/readahead.2:107
msgid ""
"B<readahead>()  attempts to schedule the reads in the background and return "
"immediately.  However, it may block while it reads the filesystem metadata "
"needed to locate the requested blocks.  This occurs frequently with ext[234] "
"on large files using indirect blocks instead of extents, giving the "
"appearance that the call blocks until the requested data has been read."
msgstr ""

#. type: Plain text
#: man-pages/man2/readahead.2:112
msgid "B<lseek>(2), B<madvise>(2), B<mmap>(2), B<posix_fadvise>(2), B<read>(2)"
msgstr ""

#. type: TH
#: man-pages/man2/nfsservctl.2:5
#, no-wrap
msgid "NFSSERVCTL"
msgstr ""

#. type: Plain text
#: man-pages/man2/nfsservctl.2:8
msgid "nfsservctl - syscall interface to kernel nfs daemon"
msgstr ""

#. type: Plain text
#: man-pages/man2/nfsservctl.2:11
#, no-wrap
msgid "B<#include E<lt>linux/nfsd/syscall.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/nfsservctl.2:14
#, no-wrap
msgid ""
"B<long nfsservctl(int >I<cmd>B<, struct nfsctl_arg *>I<argp>B<,>\n"
"B<                union nfsctl_res *>I<resp>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/nfsservctl.2:22
msgid ""
"I<Note>: Since Linux 3.1, this system call no longer exists.  It has been "
"replaced by a set of files in the I<nfsd> filesystem; see B<nfsd>(7)."
msgstr ""

#. type: Plain text
#: man-pages/man2/nfsservctl.2:37
#, no-wrap
msgid ""
"/*\n"
" * These are the commands understood by nfsctl().\n"
" */\n"
"#define NFSCTL_SVC        0  /* This is a server process. */\n"
"#define NFSCTL_ADDCLIENT  1  /* Add an NFS client. */\n"
"#define NFSCTL_DELCLIENT  2  /* Remove an NFS client. */\n"
"#define NFSCTL_EXPORT     3  /* Export a filesystem. */\n"
"#define NFSCTL_UNEXPORT   4  /* Unexport a filesystem. */\n"
"#define NFSCTL_UGIDUPDATE 5  /* Update a client's UID/GID map\n"
"                                (only in Linux 2.4.x and earlier). */\n"
"#define NFSCTL_GETFH      6  /* Get a file handle (used by mountd)\n"
"                                (only in Linux 2.4.x and earlier). */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/nfsservctl.2:49
#, no-wrap
msgid ""
"struct nfsctl_arg {\n"
"    int                       ca_version;     /* safeguard */\n"
"    union {\n"
"        struct nfsctl_svc     u_svc;\n"
"        struct nfsctl_client  u_client;\n"
"        struct nfsctl_export  u_export;\n"
"        struct nfsctl_uidmap  u_umap;\n"
"        struct nfsctl_fhparm  u_getfh;\n"
"        unsigned int          u_debug;\n"
"    } u;\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/nfsservctl.2:54
#, no-wrap
msgid ""
"union nfsctl_res {\n"
"        struct knfs_fh          cr_getfh;\n"
"        unsigned int            cr_debug;\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/nfsservctl.2:64
msgid ""
"This system call was removed from the Linux kernel in version 3.1.  Library "
"support was removed from glibc in version 2.28."
msgstr ""

#. type: Plain text
#: man-pages/man2/nfsservctl.2:65 man-pages/man2/exit_group.2:45
msgid "This call is Linux-specific."
msgstr ""

#. type: TH
#: man-pages/man2/bpf.2:26
#, no-wrap
msgid "BPF"
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:29
msgid "bpf - perform a command on an extended BPF map or program"
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:32
#, no-wrap
msgid "B<#include E<lt>linux/bpf.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:34
#, no-wrap
msgid ""
"B<int bpf(int >I<cmd>B<, union bpf_attr *>I<attr>B<, unsigned int "
">I<size>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:45
msgid ""
"The B<bpf>()  system call performs a range of operations related to extended "
"Berkeley Packet Filters.  Extended BPF (or eBPF) is similar to the original "
"(\"classic\") BPF (cBPF) used to filter network packets.  For both cBPF and "
"eBPF programs, the kernel statically analyzes the programs before loading "
"them, in order to ensure that they cannot harm the running system."
msgstr ""

#.  See 'enum bpf_func_id' in include/uapi/linux/bpf.h
#. type: Plain text
#: man-pages/man2/bpf.2:54
msgid ""
"eBPF extends cBPF in multiple ways, including the ability to call a fixed "
"set of in-kernel helper functions (via the B<BPF_CALL> opcode extension "
"provided by eBPF)  and access shared data structures such as eBPF maps."
msgstr ""

#. type: SS
#: man-pages/man2/bpf.2:54
#, no-wrap
msgid "Extended BPF Design/Architecture"
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:59
msgid ""
"eBPF maps are a generic data structure for storage of different data types.  "
"Data types are generally treated as binary blobs, so a user just specifies "
"the size of the key and the size of the value at map-creation time.  In "
"other words, a key/value for a given map can have an arbitrary structure."
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:65
msgid ""
"A user process can create multiple maps (with key/value-pairs being opaque "
"bytes of data) and access them via file descriptors.  Different eBPF "
"programs can access the same maps in parallel.  It's up to the user process "
"and eBPF program to decide what they store inside maps."
msgstr ""

#.  Defined by the kernel constant MAX_TAIL_CALL_CNT in include/linux/bpf.h
#. type: Plain text
#: man-pages/man2/bpf.2:83
msgid ""
"There's one special map type, called a program array.  This type of map "
"stores file descriptors referring to other eBPF programs.  When a lookup in "
"the map is performed, the program flow is redirected in-place to the "
"beginning of another eBPF program and does not return back to the calling "
"program.  The level of nesting has a fixed limit of 32, so that infinite "
"loops cannot be crafted.  At run time, the program file descriptors stored "
"in the map can be modified, so program functionality can be altered based on "
"specific requirements.  All programs referred to in a program-array map must "
"have been previously loaded into the kernel via B<bpf>().  If a map lookup "
"fails, the current program continues its execution.  See "
"B<BPF_MAP_TYPE_PROG_ARRAY> below for further details."
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:97
msgid ""
"Generally, eBPF programs are loaded by the user process and automatically "
"unloaded when the process exits.  In some cases, for example, B<tc-bpf>(8), "
"the program will continue to stay alive inside the kernel even after the "
"process that loaded the program exits.  In that case, the tc subsystem holds "
"a reference to the eBPF program after the file descriptor has been closed by "
"the user-space program.  Thus, whether a specific program continues to live "
"inside the kernel depends on how it is further attached to a given kernel "
"subsystem after it was loaded via B<bpf>()."
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:105
msgid ""
"Each eBPF program is a set of instructions that is safe to run until its "
"completion.  An in-kernel verifier statically determines that the eBPF "
"program terminates and is safe to execute.  During verification, the kernel "
"increments reference counts for each of the maps that the eBPF program uses, "
"so that the attached maps can't be removed until the program is unloaded."
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:116
msgid ""
"eBPF programs can be attached to different events.  These events can be the "
"arrival of network packets, tracing events, classification events by network "
"queueing disciplines (for eBPF programs attached to a B<tc>(8)  classifier), "
"and other types that may be added in the future.  A new event triggers "
"execution of the eBPF program, which may store information about the event "
"in eBPF maps.  Beyond storing data, eBPF programs may call a fixed set of "
"in-kernel helper functions."
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:119
msgid ""
"The same eBPF program can be attached to multiple events and different eBPF "
"programs can access the same map:"
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:131
#, no-wrap
msgid ""
"tracing     tracing    tracing    packet      packet     packet\n"
"event A     event B    event C    on eth0     on eth1    on eth2\n"
" |             |         |          |           |          ^\n"
" |             |         |          |           v          |\n"
" --E<gt> tracing E<lt>--     tracing      socket    tc ingress   tc egress\n"
"      prog_1          prog_2      prog_3    classifier    action\n"
"      |  |              |           |         prog_4      prog_5\n"
"   |---  -----|  |------|          map_3        |           |\n"
" map_1       map_2                              --| map_4 |--\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:150
msgid ""
"The operation to be performed by the B<bpf>()  system call is determined by "
"the I<cmd> argument.  Each operation takes an accompanying argument, "
"provided via I<attr>, which is a pointer to a union of type I<bpf_attr> (see "
"below).  The I<size> argument is the size of the union pointed to by "
"I<attr>."
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:154
msgid "The value provided in I<cmd> is one of the following:"
msgstr ""

#. type: TP
#: man-pages/man2/bpf.2:154 man-pages/man2/bpf.2:248 man-pages/man2/bpf.2:1016
#, no-wrap
msgid "B<BPF_MAP_CREATE>"
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:160
msgid ""
"Create a map and return a file descriptor that refers to the map.  The "
"close-on-exec file descriptor flag (see B<fcntl>(2))  is automatically "
"enabled for the new file descriptor."
msgstr ""

#. type: TP
#: man-pages/man2/bpf.2:160 man-pages/man2/bpf.2:385
#, no-wrap
msgid "B<BPF_MAP_LOOKUP_ELEM>"
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:163
msgid "Look up an element by key in a specified map and return its value."
msgstr ""

#. type: TP
#: man-pages/man2/bpf.2:163 man-pages/man2/bpf.2:421
#, no-wrap
msgid "B<BPF_MAP_UPDATE_ELEM>"
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:166
msgid "Create or update an element (key/value pair) in a specified map."
msgstr ""

#. type: TP
#: man-pages/man2/bpf.2:166 man-pages/man2/bpf.2:493
#, no-wrap
msgid "B<BPF_MAP_DELETE_ELEM>"
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:169
msgid "Look up and delete an element by key in a specified map."
msgstr ""

#. type: TP
#: man-pages/man2/bpf.2:169 man-pages/man2/bpf.2:523
#, no-wrap
msgid "B<BPF_MAP_GET_NEXT_KEY>"
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:173
msgid ""
"Look up an element by key in a specified map and return the key of the next "
"element."
msgstr ""

#. type: TP
#: man-pages/man2/bpf.2:173 man-pages/man2/bpf.2:1019
#, no-wrap
msgid "B<BPF_PROG_LOAD>"
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:180
msgid ""
"Verify and load an eBPF program, returning a new file descriptor associated "
"with the program.  The close-on-exec file descriptor flag (see B<fcntl>(2))  "
"is automatically enabled for the new file descriptor."
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:186
msgid ""
"The I<bpf_attr> union consists of various anonymous structures that are used "
"by different B<bpf>()  commands:"
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:197
#, no-wrap
msgid ""
"union bpf_attr {\n"
"    struct {    /* Used by BPF_MAP_CREATE */\n"
"        __u32         map_type;\n"
"        __u32         key_size;    /* size of key in bytes */\n"
"        __u32         value_size;  /* size of value in bytes */\n"
"        __u32         max_entries; /* maximum number of entries\n"
"                                      in a map */\n"
"    };\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:208
#, no-wrap
msgid ""
"    struct {    /* Used by BPF_MAP_*_ELEM and BPF_MAP_GET_NEXT_KEY\n"
"                   commands */\n"
"        __u32         map_fd;\n"
"        __aligned_u64 key;\n"
"        union {\n"
"            __aligned_u64 value;\n"
"            __aligned_u64 next_key;\n"
"        };\n"
"        __u64         flags;\n"
"    };\n"
msgstr ""

#.                  commit 2541517c32be2531e0da59dfd7efc1ce844644f5
#. type: Plain text
#: man-pages/man2/bpf.2:224
#, no-wrap
msgid ""
"    struct {    /* Used by BPF_PROG_LOAD */\n"
"        __u32         prog_type;\n"
"        __u32         insn_cnt;\n"
"        __aligned_u64 insns;      /* 'const struct bpf_insn *' */\n"
"        __aligned_u64 license;    /* 'const char *' */\n"
"        __u32         log_level;  /* verbosity level of verifier */\n"
"        __u32         log_size;   /* size of user buffer */\n"
"        __aligned_u64 log_buf;    /* user supplied 'char *'\n"
"                                     buffer */\n"
"        __u32         kern_version;\n"
"                                  /* checked when prog_type=kprobe\n"
"                                     (since Linux 4.1) */\n"
"    };\n"
"} __attribute__((aligned(8)));\n"
msgstr ""

#. type: SS
#: man-pages/man2/bpf.2:227
#, no-wrap
msgid "eBPF maps"
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:231
msgid ""
"Maps are a generic data structure for storage of different types of data.  "
"They allow sharing of data between eBPF kernel programs, and also between "
"kernel and user-space applications."
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:233
msgid "Each map type has the following attributes:"
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:235
msgid "type"
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:237
msgid "maximum number of elements"
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:239
msgid "key size in bytes"
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:241
msgid "value size in bytes"
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:248
msgid ""
"The following wrapper functions demonstrate how various B<bpf>()  commands "
"can be used to access the maps.  The functions use the I<cmd> argument to "
"invoke different operations."
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:254
msgid ""
"The B<BPF_MAP_CREATE> command creates a new map, returning a new file "
"descriptor that refers to the map."
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:269
#, no-wrap
msgid ""
"int\n"
"bpf_create_map(enum bpf_map_type map_type,\n"
"               unsigned int key_size,\n"
"               unsigned int value_size,\n"
"               unsigned int max_entries)\n"
"{\n"
"    union bpf_attr attr = {\n"
"        .map_type    = map_type,\n"
"        .key_size    = key_size,\n"
"        .value_size  = value_size,\n"
"        .max_entries = max_entries\n"
"    };\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:272
#, no-wrap
msgid ""
"    return bpf(BPF_MAP_CREATE, &attr, sizeof(attr));\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:290
msgid ""
"The new map has the type specified by I<map_type>, and attributes as "
"specified in I<key_size>, I<value_size>, and I<max_entries>.  On success, "
"this operation returns a file descriptor.  On error, -1 is returned and "
"I<errno> is set to B<EINVAL>, B<EPERM>, or B<ENOMEM>."
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:307
msgid ""
"The I<key_size> and I<value_size> attributes will be used by the verifier "
"during program loading to check that the program is calling "
"B<bpf_map_*_elem>()  helper functions with a correctly initialized I<key> "
"and to check that the program doesn't access the map element I<value> beyond "
"the specified I<value_size>.  For example, when a map is created with a "
"I<key_size> of 8 and the eBPF program calls"
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:311
#, no-wrap
msgid "bpf_map_lookup_elem(map_fd, fp - 4)\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:316
msgid "the program will be rejected, since the in-kernel helper function"
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:319
#, no-wrap
msgid "    bpf_map_lookup_elem(map_fd, void *key)\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:329
msgid ""
"expects to read 8 bytes from the location pointed to by I<key>, but the "
"I<fp\\ -\\ 4> (where I<fp> is the top of the stack)  starting address will "
"cause out-of-bounds stack access."
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:333
msgid ""
"Similarly, when a map is created with a I<value_size> of 1 and the eBPF "
"program contains"
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:338
#, no-wrap
msgid ""
"value = bpf_map_lookup_elem(...);\n"
"*(u32 *) value = 1;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:346
msgid ""
"the program will be rejected, since it accesses the I<value> pointer beyond "
"the specified 1 byte I<value_size> limit."
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:349
msgid "Currently, the following values are supported for I<map_type>:"
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:371
#, no-wrap
msgid ""
"enum bpf_map_type {\n"
"    BPF_MAP_TYPE_UNSPEC,  /* Reserve 0 as invalid map type */\n"
"    BPF_MAP_TYPE_HASH,\n"
"    BPF_MAP_TYPE_ARRAY,\n"
"    BPF_MAP_TYPE_PROG_ARRAY,\n"
"    BPF_MAP_TYPE_PERF_EVENT_ARRAY,\n"
"    BPF_MAP_TYPE_PERCPU_HASH,\n"
"    BPF_MAP_TYPE_PERCPU_ARRAY,\n"
"    BPF_MAP_TYPE_STACK_TRACE,\n"
"    BPF_MAP_TYPE_CGROUP_ARRAY,\n"
"    BPF_MAP_TYPE_LRU_HASH,\n"
"    BPF_MAP_TYPE_LRU_PERCPU_HASH,\n"
"    BPF_MAP_TYPE_LPM_TRIE,\n"
"    BPF_MAP_TYPE_ARRAY_OF_MAPS,\n"
"    BPF_MAP_TYPE_HASH_OF_MAPS,\n"
"    BPF_MAP_TYPE_DEVMAP,\n"
"    BPF_MAP_TYPE_SOCKMAP,\n"
"    BPF_MAP_TYPE_CPUMAP,\n"
"};\n"
msgstr ""

#.  FIXME We need an explanation of why one might choose each of
#.  these map implementations
#. type: Plain text
#: man-pages/man2/bpf.2:385
msgid ""
"I<map_type> selects one of the available map implementations in the kernel.  "
"For all map types, eBPF programs access maps with the same "
"B<bpf_map_lookup_elem>()  and B<bpf_map_update_elem>()  helper functions.  "
"Further details of the various map types are given below."
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:393
msgid ""
"The B<BPF_MAP_LOOKUP_ELEM> command looks up an element with a given I<key> "
"in the map referred to by the file descriptor I<fd>."
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:404
#, no-wrap
msgid ""
"int\n"
"bpf_lookup_elem(int fd, const void *key, void *value)\n"
"{\n"
"    union bpf_attr attr = {\n"
"        .map_fd = fd,\n"
"        .key    = ptr_to_u64(key),\n"
"        .value  = ptr_to_u64(value),\n"
"    };\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:407
#, no-wrap
msgid ""
"    return bpf(BPF_MAP_LOOKUP_ELEM, &attr, sizeof(attr));\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:416
msgid ""
"If an element is found, the operation returns zero and stores the element's "
"value into I<value>, which must point to a buffer of I<value_size> bytes."
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:421
msgid ""
"If no element is found, the operation returns -1 and sets I<errno> to "
"B<ENOENT>."
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:430
msgid ""
"The B<BPF_MAP_UPDATE_ELEM> command creates or updates an element with a "
"given I<key/value> in the map referred to by the file descriptor I<fd>."
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:443
#, no-wrap
msgid ""
"int\n"
"bpf_update_elem(int fd, const void *key, const void *value,\n"
"                uint64_t flags)\n"
"{\n"
"    union bpf_attr attr = {\n"
"        .map_fd = fd,\n"
"        .key    = ptr_to_u64(key),\n"
"        .value  = ptr_to_u64(value),\n"
"        .flags  = flags,\n"
"    };\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:446
#, no-wrap
msgid ""
"    return bpf(BPF_MAP_UPDATE_ELEM, &attr, sizeof(attr));\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:452
msgid "The I<flags> argument should be specified as one of the following:"
msgstr ""

#. type: TP
#: man-pages/man2/bpf.2:453
#, no-wrap
msgid "B<BPF_ANY>"
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:456
msgid "Create a new element or update an existing element."
msgstr ""

#. type: TP
#: man-pages/man2/bpf.2:456
#, no-wrap
msgid "B<BPF_NOEXIST>"
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:459
msgid "Create a new element only if it did not exist."
msgstr ""

#. type: TP
#: man-pages/man2/bpf.2:459
#, no-wrap
msgid "B<BPF_EXIST>"
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:462
msgid "Update an existing element."
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:493
msgid ""
"On success, the operation returns zero.  On error, -1 is returned and "
"I<errno> is set to B<EINVAL>, B<EPERM>, B<ENOMEM>, or B<E2BIG>.  B<E2BIG> "
"indicates that the number of elements in the map reached the I<max_entries> "
"limit specified at map creation time.  B<EEXIST> will be returned if "
"I<flags> specifies B<BPF_NOEXIST> and the element with I<key> already exists "
"in the map.  B<ENOENT> will be returned if I<flags> specifies B<BPF_EXIST> "
"and the element with I<key> doesn't exist in the map."
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:502
msgid ""
"The B<BPF_MAP_DELETE_ELEM> command deletes the element whose key is I<key> "
"from the map referred to by the file descriptor I<fd>."
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:512
#, no-wrap
msgid ""
"int\n"
"bpf_delete_elem(int fd, const void *key)\n"
"{\n"
"    union bpf_attr attr = {\n"
"        .map_fd = fd,\n"
"        .key    = ptr_to_u64(key),\n"
"    };\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:515
#, no-wrap
msgid ""
"    return bpf(BPF_MAP_DELETE_ELEM, &attr, sizeof(attr));\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:523
msgid ""
"On success, zero is returned.  If the element is not found, -1 is returned "
"and I<errno> is set to B<ENOENT>."
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:534
msgid ""
"The B<BPF_MAP_GET_NEXT_KEY> command looks up an element by I<key> in the map "
"referred to by the file descriptor I<fd> and sets the I<next_key> pointer to "
"the key of the next element."
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:545
#, no-wrap
msgid ""
"int\n"
"bpf_get_next_key(int fd, const void *key, void *next_key)\n"
"{\n"
"    union bpf_attr attr = {\n"
"        .map_fd   = fd,\n"
"        .key      = ptr_to_u64(key),\n"
"        .next_key = ptr_to_u64(next_key),\n"
"    };\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:548
#, no-wrap
msgid ""
"    return bpf(BPF_MAP_GET_NEXT_KEY, &attr, sizeof(attr));\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:576
msgid ""
"If I<key> is found, the operation returns zero and sets the I<next_key> "
"pointer to the key of the next element.  If I<key> is not found, the "
"operation returns zero and sets the I<next_key> pointer to the key of the "
"first element.  If I<key> is the last element, -1 is returned and I<errno> "
"is set to B<ENOENT>.  Other possible I<errno> values are B<ENOMEM>, "
"B<EFAULT>, B<EPERM>, and B<EINVAL>.  This method can be used to iterate over "
"all elements in the map."
msgstr ""

#. type: TP
#: man-pages/man2/bpf.2:576
#, no-wrap
msgid "B<close(map_fd)>"
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:583
msgid ""
"Delete the map referred to by the file descriptor I<map_fd>.  When the "
"user-space program that created a map exits, all maps will be deleted "
"automatically (but see NOTES)."
msgstr ""

#. type: SS
#: man-pages/man2/bpf.2:583
#, no-wrap
msgid "eBPF map types"
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:585
msgid "The following map types are supported:"
msgstr ""

#. type: TP
#: man-pages/man2/bpf.2:585
#, no-wrap
msgid "B<BPF_MAP_TYPE_HASH>"
msgstr ""

#.  commit 0f8e4bd8a1fc8c4185f1630061d0a1f2d197a475
#. type: Plain text
#: man-pages/man2/bpf.2:589
msgid "Hash-table maps have the following characteristics:"
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:594
msgid ""
"Maps are created and destroyed by user-space programs.  Both user-space and "
"eBPF programs can perform lookup, update, and delete operations."
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:596
msgid "The kernel takes care of allocating and freeing key/value pairs."
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:603
msgid ""
"The B<map_update_elem>()  helper will fail to insert new element when the "
"I<max_entries> limit is reached.  (This ensures that eBPF programs cannot "
"exhaust memory.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:606
msgid "B<map_update_elem>()  replaces existing elements atomically."
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:610
msgid "Hash-table maps are optimized for speed of lookup."
msgstr ""

#. type: TP
#: man-pages/man2/bpf.2:610
#, no-wrap
msgid "B<BPF_MAP_TYPE_ARRAY>"
msgstr ""

#.  commit 28fbcfa08d8ed7c5a50d41a0433aad222835e8e3
#. type: Plain text
#: man-pages/man2/bpf.2:614
msgid "Array maps have the following characteristics:"
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:628
msgid ""
"Optimized for fastest possible lookup.  In the future the verifier/JIT "
"compiler may recognize lookup() operations that employ a constant key and "
"optimize it into constant pointer.  It is possible to optimize a "
"non-constant key into direct pointer arithmetic as well, since pointers and "
"I<value_size> are constant for the life of the eBPF program.  In other "
"words, B<array_map_lookup_elem>()  may be 'inlined' by the verifier/JIT "
"compiler while preserving concurrent access to this map from user space."
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:630
msgid "All array elements pre-allocated and zero initialized at init time"
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:632
msgid "The key is an array index, and must be exactly four bytes."
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:637
msgid ""
"B<map_delete_elem>()  fails with the error B<EINVAL>, since elements cannot "
"be deleted."
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:652
msgid ""
"B<map_update_elem>()  replaces elements in a B<nonatomic> fashion; for "
"atomic updates, a hash-table map should be used instead.  There is however "
"one special case that can also be used with arrays: the atomic built-in "
"B<__sync_fetch_and_add()> can be used on 32 and 64 bit atomic counters.  For "
"example, it can be applied on the whole value itself if it represents a "
"single counter, or in case of a structure containing multiple counters, it "
"could be used on individual counters.  This is quite often useful for "
"aggregation and accounting of events."
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:655
msgid "Among the uses for array maps are the following:"
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:660
msgid ""
"As \"global\" eBPF variables: an array of 1 element whose key is (index) 0 "
"and where the value is a collection of 'global' variables which eBPF "
"programs can use to keep state between events."
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:662
msgid "Aggregation of tracing events into a fixed set of buckets."
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:665
msgid ""
"Accounting of networking events, for example, number of packets and packet "
"sizes."
msgstr ""

#. type: TP
#: man-pages/man2/bpf.2:666
#, no-wrap
msgid "B<BPF_MAP_TYPE_PROG_ARRAY> (since Linux 4.2)"
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:678
msgid ""
"A program array map is a special kind of array map whose map values contain "
"only file descriptors referring to other eBPF programs.  Thus, both the "
"I<key_size> and I<value_size> must be exactly four bytes.  This map is used "
"in conjunction with the B<bpf_tail_call>()  helper."
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:681
msgid ""
"This means that an eBPF program with a program array map attached to it can "
"call from kernel side into"
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:686
#, no-wrap
msgid ""
"void bpf_tail_call(void *context, void *prog_map,\n"
"                   unsigned int index);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:695
msgid ""
"and therefore replace its own program flow with the one from the program at "
"the given program array slot, if present.  This can be regarded as kind of a "
"jump table to a different eBPF program.  The invoked program will then reuse "
"the same stack.  When a jump into the new program has been performed, it "
"won't return to the old program anymore."
msgstr ""

#.  MAX_TAIL_CALL_CNT
#. type: Plain text
#: man-pages/man2/bpf.2:704
msgid ""
"If no eBPF program is found at the given index of the program array (because "
"the map slot doesn't contain a valid program file descriptor, the specified "
"lookup index/key is out of bounds, or the limit of 32 nested calls has been "
"exceed), execution continues with the current eBPF program.  This can be "
"used as a fall-through for default cases."
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:716
msgid ""
"A program array map is useful, for example, in tracing or networking, to "
"handle individual system calls or protocols in their own subprograms and use "
"their identifiers as an individual map index.  This approach may result in "
"performance benefits, and also makes it possible to overcome the maximum "
"instruction limit of a single eBPF program.  In dynamic environments, a "
"user-space daemon might atomically replace individual subprograms at "
"run-time with newer versions to alter overall program behavior, for "
"instance, if global policies change."
msgstr ""

#. type: SS
#: man-pages/man2/bpf.2:716
#, no-wrap
msgid "eBPF programs"
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:722
msgid ""
"The B<BPF_PROG_LOAD> command is used to load an eBPF program into the "
"kernel.  The return value for this command is a new file descriptor "
"associated with this eBPF program."
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:726
#, no-wrap
msgid "char bpf_log_buf[LOG_BUF_SIZE];\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:741
#, no-wrap
msgid ""
"int\n"
"bpf_prog_load(enum bpf_prog_type type,\n"
"              const struct bpf_insn *insns, int insn_cnt,\n"
"              const char *license)\n"
"{\n"
"    union bpf_attr attr = {\n"
"        .prog_type = type,\n"
"        .insns     = ptr_to_u64(insns),\n"
"        .insn_cnt  = insn_cnt,\n"
"        .license   = ptr_to_u64(license),\n"
"        .log_buf   = ptr_to_u64(bpf_log_buf),\n"
"        .log_size  = LOG_BUF_SIZE,\n"
"        .log_level = 1,\n"
"    };\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:744
#, no-wrap
msgid ""
"    return bpf(BPF_PROG_LOAD, &attr, sizeof(attr));\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:749
msgid "I<prog_type> is one of the available program types:"
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:760
#, no-wrap
msgid ""
"enum bpf_prog_type {\n"
"    BPF_PROG_TYPE_UNSPEC,        /* Reserve 0 as invalid\n"
"                                    program type */\n"
"    BPF_PROG_TYPE_SOCKET_FILTER,\n"
"    BPF_PROG_TYPE_KPROBE,\n"
"    BPF_PROG_TYPE_SCHED_CLS,\n"
"    BPF_PROG_TYPE_SCHED_ACT,\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:764
msgid "For further details of eBPF program types, see below."
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:768
msgid "The remaining fields of I<bpf_attr> are set as follows:"
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:773
msgid "I<insns> is an array of I<struct bpf_insn> instructions."
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:777
msgid ""
"I<insn_cnt> is the number of instructions in the program referred to by "
"I<insns>."
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:784
msgid ""
"I<license> is a license string, which must be GPL compatible to call helper "
"functions marked I<gpl_only>.  (The licensing rules are the same as for "
"kernel modules, so that also dual licenses, such as \"Dual BSD/GPL\", may be "
"used.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:792
msgid ""
"I<log_buf> is a pointer to a caller-allocated buffer in which the in-kernel "
"verifier can store the verification log.  This log is a multi-line string "
"that can be checked by the program author in order to understand how the "
"verifier came to the conclusion that the eBPF program is unsafe.  The format "
"of the output can change at any time as the verifier evolves."
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:801
msgid ""
"I<log_size> size of the buffer pointed to by I<log_buf>.  If the size of the "
"buffer is not large enough to store all verifier messages, -1 is returned "
"and I<errno> is set to B<ENOSPC>."
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:810
msgid ""
"I<log_level> verbosity level of the verifier.  A value of zero means that "
"the verifier will not provide a log; in this case, I<log_buf> must be a NULL "
"pointer, and I<log_size> must be zero."
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:816
msgid ""
"Applying B<close>(2)  to the file descriptor returned by B<BPF_PROG_LOAD> "
"will unload the eBPF program (but see NOTES)."
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:828
msgid ""
"Maps are accessible from eBPF programs and are used to exchange data between "
"eBPF programs and between eBPF programs and user-space programs.  For "
"example, eBPF programs can process various events (like kprobe, packets) and "
"store their data into a map, and user-space programs can then fetch data "
"from the map.  Conversely, user-space programs can use a map as a "
"configuration mechanism, populating the map with values checked by the eBPF "
"program, which then modifies its behavior on the fly according to those "
"values."
msgstr ""

#. type: SS
#: man-pages/man2/bpf.2:828
#, no-wrap
msgid "eBPF program types"
msgstr ""

#
#.  FIXME
#.  Somewhere in this page we need a general introduction to the
#.  bpf_context. For example, how does a BPF program access the
#.  context?
#. type: Plain text
#: man-pages/man2/bpf.2:842
msgid ""
"The eBPF program type (I<prog_type>)  determines the subset of kernel helper "
"functions that the program may call.  The program type also determines the "
"program input (context)\\(emthe format of I<struct bpf_context> (which is "
"the data blob passed into the eBPF program as the first argument)."
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:849
msgid ""
"For example, a tracing program does not have the exact same subset of helper "
"functions as a socket filter program (though they may have some helpers in "
"common).  Similarly, the input (context) for a tracing program is a set of "
"register values, while for a socket filter it is a network packet."
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:852
msgid ""
"The set of functions available to eBPF programs of a given type may increase "
"in the future."
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:854
msgid "The following program types are supported:"
msgstr ""

#. type: TP
#: man-pages/man2/bpf.2:854
#, no-wrap
msgid "B<BPF_PROG_TYPE_SOCKET_FILTER> (since Linux 3.19)"
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:859
msgid "Currently, the set of functions for B<BPF_PROG_TYPE_SOCKET_FILTER> is:"
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:868
#, no-wrap
msgid ""
"bpf_map_lookup_elem(map_fd, void *key)\n"
"                    /* look up key in a map_fd */\n"
"bpf_map_update_elem(map_fd, void *key, void *value)\n"
"                    /* update key/value */\n"
"bpf_map_delete_elem(map_fd, void *key)\n"
"                    /* delete key in a map_fd */\n"
msgstr ""

#.  FIXME: We need some text here to explain how the program
#.  accesses __sk_buff.
#.  See 'struct __sk_buff' and commit 9bac3d6d548e5
#
#.  Alexei commented:
#.  Actually now in case of SOCKET_FILTER, SCHED_CLS, SCHED_ACT
#.  the program can now access skb fields.
#. type: Plain text
#: man-pages/man2/bpf.2:883
msgid "The I<bpf_context> argument is a pointer to a I<struct __sk_buff>."
msgstr ""

#. type: TP
#: man-pages/man2/bpf.2:883
#, no-wrap
msgid "B<BPF_PROG_TYPE_KPROBE> (since Linux 4.1)"
msgstr ""

#.  commit 94caee8c312d96522bcdae88791aaa9ebcd5f22c
#.  commit a8cb5f556b567974d75ea29c15181c445c541b1f
#.  FIXME Document this program type
#. 	  Describe allowed helper functions for this program type
#. 	  Describe bpf_context for this program type
#. type: Plain text
#: man-pages/man2/bpf.2:892 man-pages/man2/bpf.2:900 man-pages/man2/bpf.2:908
msgid "[To be documented]"
msgstr ""

#. type: TP
#: man-pages/man2/bpf.2:892
#, no-wrap
msgid "B<BPF_PROG_TYPE_SCHED_CLS> (since Linux 4.1)"
msgstr ""

#. type: TP
#: man-pages/man2/bpf.2:900
#, no-wrap
msgid "B<BPF_PROG_TYPE_SCHED_ACT> (since Linux 4.1)"
msgstr ""

#. type: SS
#: man-pages/man2/bpf.2:908
#, no-wrap
msgid "Events"
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:911
msgid ""
"Once a program is loaded, it can be attached to an event.  Various kernel "
"subsystems have different ways to do so."
msgstr ""

#.  commit 89aa075832b0da4402acebd698d0411dcc82d03e
#. type: Plain text
#: man-pages/man2/bpf.2:920
msgid ""
"Since Linux 3.19, the following call will attach the program I<prog_fd> to "
"the socket I<sockfd>, which was created by an earlier call to B<socket>(2):"
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:925
#, no-wrap
msgid ""
"setsockopt(sockfd, SOL_SOCKET, SO_ATTACH_BPF,\n"
"           &prog_fd, sizeof(prog_fd));\n"
msgstr ""

#.  commit 2541517c32be2531e0da59dfd7efc1ce844644f5
#. type: Plain text
#: man-pages/man2/bpf.2:937
msgid ""
"Since Linux 4.1, the following call may be used to attach the eBPF program "
"referred to by the file descriptor I<prog_fd> to a perf event file "
"descriptor, I<event_fd>, that was created by a previous call to "
"B<perf_event_open>(2):"
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:941
#, no-wrap
msgid "ioctl(event_fd, PERF_EVENT_IOC_SET_BPF, prog_fd);\n"
msgstr ""

#. type: SH
#: man-pages/man2/bpf.2:945
#, no-wrap
msgid "EXAMPLES"
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:960
#, no-wrap
msgid ""
"/* bpf+sockets example:\n"
" * 1. create array map of 256 elements\n"
" * 2. load program that counts number of packets received\n"
" *    r0 = skb-E<gt>data[ETH_HLEN + offsetof(struct iphdr, protocol)]\n"
" *    map[r0]++\n"
" * 3. attach prog_fd to raw socket via setsockopt()\n"
" * 4. print number of received TCP/UDP packets every second\n"
" */\n"
"int\n"
"main(int argc, char **argv)\n"
"{\n"
"    int sock, map_fd, prog_fd, key;\n"
"    long long value = 0, tcp_cnt, udp_cnt;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:968
#, no-wrap
msgid ""
"    map_fd = bpf_create_map(BPF_MAP_TYPE_ARRAY, sizeof(key),\n"
"                            sizeof(value), 256);\n"
"    if (map_fd E<lt> 0) {\n"
"        printf(\"failed to create map '%s'\\en\", strerror(errno));\n"
"        /* likely not run as root */\n"
"        return 1;\n"
"    }\n"
msgstr ""

#.                                 == atomic64_add
#. type: Plain text
#: man-pages/man2/bpf.2:989
#, no-wrap
msgid ""
"    struct bpf_insn prog[] = {\n"
"        BPF_MOV64_REG(BPF_REG_6, BPF_REG_1),        /* r6 = r1 */\n"
"        BPF_LD_ABS(BPF_B, ETH_HLEN + offsetof(struct iphdr, protocol)),\n"
"                                /* r0 = ip-E<gt>proto */\n"
"        BPF_STX_MEM(BPF_W, BPF_REG_10, BPF_REG_0, -4),\n"
"                                /* *(u32 *)(fp - 4) = r0 */\n"
"        BPF_MOV64_REG(BPF_REG_2, BPF_REG_10),       /* r2 = fp */\n"
"        BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -4),      /* r2 = r2 - 4 */\n"
"        BPF_LD_MAP_FD(BPF_REG_1, map_fd),           /* r1 = map_fd */\n"
"        BPF_CALL_FUNC(BPF_FUNC_map_lookup_elem),\n"
"                                /* r0 = map_lookup(r1, r2) */\n"
"        BPF_JMP_IMM(BPF_JEQ, BPF_REG_0, 0, 2),\n"
"                                /* if (r0 == 0) goto pc+2 */\n"
"        BPF_MOV64_IMM(BPF_REG_1, 1),                /* r1 = 1 */\n"
"        BPF_XADD(BPF_DW, BPF_REG_0, BPF_REG_1, 0, 0),\n"
"                                /* lock *(u64 *) r0 += r1 */\n"
"        BPF_MOV64_IMM(BPF_REG_0, 0),                /* r0 = 0 */\n"
"        BPF_EXIT_INSN(),                            /* return r0 */\n"
"    };\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:992
#, no-wrap
msgid ""
"    prog_fd = bpf_prog_load(BPF_PROG_TYPE_SOCKET_FILTER, prog,\n"
"                            sizeof(prog) / sizeof(prog[0]), \"GPL\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:994
#, no-wrap
msgid "    sock = open_raw_sock(\"lo\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:997
#, no-wrap
msgid ""
"    assert(setsockopt(sock, SOL_SOCKET, SO_ATTACH_BPF, &prog_fd,\n"
"                      sizeof(prog_fd)) == 0);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:1006
#, no-wrap
msgid ""
"    for (;;) {\n"
"        key = IPPROTO_TCP;\n"
"        assert(bpf_lookup_elem(map_fd, &key, &tcp_cnt) == 0);\n"
"        key = IPPROTO_UDP;\n"
"        assert(bpf_lookup_elem(map_fd, &key, &udp_cnt) == 0);\n"
"        printf(\"TCP %lld UDP %lld packets\\en\", tcp_cnt, udp_cnt);\n"
"        sleep(1);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:1014
msgid ""
"Some complete working code can be found in the I<samples/bpf> directory in "
"the kernel source tree."
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:1019
msgid "The new file descriptor associated with the eBPF map."
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:1022
msgid "The new file descriptor associated with the eBPF program."
msgstr ""

#. type: TP
#: man-pages/man2/bpf.2:1022 man-pages/man2/fcntl.2:1641
#, no-wrap
msgid "All other commands"
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:1035
msgid ""
"The eBPF program is too large or a map reached the I<max_entries> limit "
"(maximum number of elements)."
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:1052
msgid ""
"For B<BPF_PROG_LOAD>, even though all program instructions are valid, the "
"program has been rejected because it was deemed unsafe.  This may be because "
"it may have accessed a disallowed memory region or an uninitialized "
"stack/register or because the function constraints don't match the actual "
"types or because there was a misaligned memory access.  In this case, it is "
"recommended to call B<bpf>()  again with I<log_level = 1> and examine "
"I<log_buf> for the specific reason provided by the verifier."
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:1067
msgid ""
"One of the pointers (I<key> or I<value> or I<log_buf> or I<insns>)  is "
"outside the accessible address space."
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:1072 man-pages/man2/fcntl.2:1724
msgid "The value specified in I<cmd> is not recognized by this kernel."
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:1079
msgid "For B<BPF_MAP_CREATE>, either I<map_type> or attributes are invalid."
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:1088
msgid ""
"For B<BPF_MAP_*_ELEM> commands, some of the fields of I<union bpf_attr> that "
"are not used by this command are not set to zero."
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:1096
msgid ""
"For B<BPF_PROG_LOAD>, indicates an attempt to load an invalid program.  eBPF "
"programs can be deemed invalid due to unrecognized instructions, the use of "
"reserved fields, jumps out of range, infinite loops or calls of unknown "
"functions."
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:1105
msgid ""
"For B<BPF_MAP_LOOKUP_ELEM> or B<BPF_MAP_DELETE_ELEM>, indicates that the "
"element with the given I<key> was not found."
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:1108
msgid "Cannot allocate sufficient memory."
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:1114
msgid ""
"The call was made without sufficient privilege (without the B<CAP_SYS_ADMIN> "
"capability)."
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:1118
msgid "The B<bpf>()  system call first appeared in Linux 3.18."
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:1122
msgid "The B<bpf>()  system call is Linux-specific."
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:1128
msgid ""
"In the current implementation, all B<bpf>()  commands require the caller to "
"have the B<CAP_SYS_ADMIN> capability."
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:1141
msgid ""
"eBPF objects (maps and programs) can be shared between processes.  For "
"example, after B<fork>(2), the child inherits file descriptors referring to "
"the same eBPF objects.  In addition, file descriptors referring to eBPF "
"objects can be transferred over UNIX domain sockets.  File descriptors "
"referring to eBPF objects can be duplicated in the usual way, using "
"B<dup>(2)  and similar calls.  An eBPF object is deallocated only after all "
"file descriptors referring to the object have been closed."
msgstr ""

#.  There are also examples for the tc classifier, in the iproute2
#.  project, in examples/bpf
#. type: Plain text
#: man-pages/man2/bpf.2:1153
msgid ""
"eBPF programs can be written in a restricted C that is compiled (using the "
"B<clang> compiler) into eBPF bytecode.  Various features are omitted from "
"this restricted C, such as loops, global variables, variadic functions, "
"floating-point numbers, and passing structures as function arguments.  Some "
"examples can be found in the I<samples/bpf/*_kern.c> files in the kernel "
"source tree."
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:1161
msgid ""
"The kernel contains a just-in-time (JIT) compiler that translates eBPF "
"bytecode into native machine code for better performance.  In kernels before "
"Linux 4.15, the JIT compiler is disabled by default, but its operation can "
"be controlled by writing one of the following integer strings to the file "
"I</proc/sys/net/core/bpf_jit_enable>:"
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:1163
msgid "Disable JIT compilation (default)."
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:1165
msgid "Normal compilation."
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:1171
msgid ""
"Debugging mode.  The generated opcodes are dumped in hexadecimal into the "
"kernel log.  These opcodes can then be disassembled using the program "
"I<tools/net/bpf_jit_disasm.c> provided in the kernel source tree."
msgstr ""

#.  commit 290af86629b25ffd1ed6232c4e9107da031705cb
#. type: Plain text
#: man-pages/man2/bpf.2:1182
msgid ""
"Since Linux 4.15, the kernel may configured with the "
"B<CONFIG_BPF_JIT_ALWAYS_ON> option.  In this case, the JIT compiler is "
"always enabled, and the I<bpf_jit_enable> is initialized to 1 and is "
"immutable.  (This kernel configuration option was provided as a mitigation "
"for one of the Spectre attacks against the BPF interpreter.)"
msgstr ""

#.  Last reviewed in Linux 4.18-rc by grepping for BPF_ALU64 in arch/
#.  and by checking the documentation for bpf_jit_enable in
#.  Documentation/sysctl/net.txt
#. type: Plain text
#: man-pages/man2/bpf.2:1188
msgid ""
"The JIT compiler for eBPF is currently available for the following "
"architectures:"
msgstr ""

#.  commit 0a14842f5a3c0e88a1e59fac5c3025db39721f74
#. type: Plain text
#: man-pages/man2/bpf.2:1191
msgid "x86-64 (since Linux 3.18; cBPF since Linux 3.0);"
msgstr ""

#.  commit ddecdfcea0ae891f782ae853771c867ab51024c2
#. type: Plain text
#: man-pages/man2/bpf.2:1195
msgid "ARM32 (since Linux 3.18; cBPF since Linux 3.4);"
msgstr ""

#.  commit 2809a2087cc44b55e4377d7b9be3f7f5d2569091
#. type: Plain text
#: man-pages/man2/bpf.2:1198
msgid "SPARC 32 (since Linux 3.18; cBPF since Linux 3.5);"
msgstr ""

#.  commit e54bcde3d69d40023ae77727213d14f920eb264a
#. type: Plain text
#: man-pages/man2/bpf.2:1201
msgid "ARM-64 (since Linux 3.18);"
msgstr ""

#.  commit c10302efe569bfd646b4c22df29577a4595b4580
#. type: Plain text
#: man-pages/man2/bpf.2:1204
msgid "s390 (since Linux 4.1; cBPF since Linux 3.7);"
msgstr ""

#.  commit 0ca87f05ba8bdc6791c14878464efc901ad71e99
#.  commit 156d0e290e969caba25f1851c52417c14d141b24
#. type: Plain text
#: man-pages/man2/bpf.2:1208
msgid "PowerPC 64 (since Linux 4.8; cBPF since Linux 3.1);"
msgstr ""

#.  commit 7a12b5031c6b947cc13918237ae652b536243b76
#. type: Plain text
#: man-pages/man2/bpf.2:1211
msgid "SPARC 64 (since Linux 4.12);"
msgstr ""

#.  commit 03f5781be2c7b7e728d724ac70ba10799cc710d7
#. type: Plain text
#: man-pages/man2/bpf.2:1214
msgid "x86-32 (since Linux 4.18);"
msgstr ""

#.  commit c6610de353da5ca6eee5b8960e838a87a90ead0c
#.  commit f381bf6d82f032b7410185b35d000ea370ac706b
#. type: Plain text
#: man-pages/man2/bpf.2:1218
msgid "MIPS 64 (since Linux 4.18; cBPF since Linux 3.16);"
msgstr ""

#.  commit 2353ecc6f91fd15b893fa01bf85a1c7a823ee4f2
#. type: Plain text
#: man-pages/man2/bpf.2:1221
msgid "riscv (since Linux 5.1)."
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:1228
msgid "B<seccomp>(2), B<bpf-helpers>(7), B<socket>(7), B<tc>(8), B<tc-bpf>(8)"
msgstr ""

#. type: Plain text
#: man-pages/man2/bpf.2:1230
msgid ""
"Both classic and extended BPF are explained in the kernel source file "
"I<Documentation/networking/filter.txt>."
msgstr ""

#. type: TH
#: man-pages/man2/semctl.2:42
#, no-wrap
msgid "SEMCTL"
msgstr ""

#. type: Plain text
#: man-pages/man2/semctl.2:45
msgid "semctl - System V semaphore control operations"
msgstr ""

#. type: Plain text
#: man-pages/man2/semctl.2:52
#, no-wrap
msgid "B<int semctl(int >I<semid>B<, int >I<semnum>B<, int >I<cmd>B<, ...);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/semctl.2:63
msgid ""
"B<semctl>()  performs the control operation specified by I<cmd> on the "
"System\\ V semaphore set identified by I<semid>, or on the I<semnum>-th "
"semaphore of that set.  (The semaphores in a set are numbered starting at "
"0.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/semctl.2:69
msgid ""
"This function has three or four arguments, depending on I<cmd>.  When there "
"are four, the fourth has the type I<union semun>.  The I<calling program> "
"must define this union as follows:"
msgstr ""

#. type: Plain text
#: man-pages/man2/semctl.2:79
#, no-wrap
msgid ""
"union semun {\n"
"    int              val;    /* Value for SETVAL */\n"
"    struct semid_ds *buf;    /* Buffer for IPC_STAT, IPC_SET */\n"
"    unsigned short  *array;  /* Array for GETALL, SETALL */\n"
"    struct seminfo  *__buf;  /* Buffer for IPC_INFO\n"
"                                (Linux-specific) */\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/semctl.2:85
msgid ""
"The I<semid_ds> data structure is defined in I<E<lt>sys/sem.hE<gt>> as "
"follows:"
msgstr ""

#. type: Plain text
#: man-pages/man2/semctl.2:94
#, no-wrap
msgid ""
"struct semid_ds {\n"
"    struct ipc_perm sem_perm;  /* Ownership and permissions */\n"
"    time_t          sem_otime; /* Last semop time */\n"
"    time_t          sem_ctime; /* Last change time */\n"
"    unsigned long   sem_nsems; /* No. of semaphores in set */\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/semctl.2:114
#, no-wrap
msgid ""
"struct ipc_perm {\n"
"    key_t          __key; /* Key supplied to semget(2) */\n"
"    uid_t          B<uid>;   /* Effective UID of owner */\n"
"    gid_t          B<gid>;   /* Effective GID of owner */\n"
"    uid_t          cuid;  /* Effective UID of creator */\n"
"    gid_t          cgid;  /* Effective GID of creator */\n"
"    unsigned short B<mode>;  /* Permissions */\n"
"    unsigned short __seq; /* Sequence number */\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/semctl.2:132
msgid ""
"Copy information from the kernel data structure associated with I<semid> "
"into the I<semid_ds> structure pointed to by I<arg.buf>.  The argument "
"I<semnum> is ignored.  The calling process must have read permission on the "
"semaphore set."
msgstr ""

#. type: Plain text
#: man-pages/man2/semctl.2:155
msgid ""
"Write the values of some members of the I<semid_ds> structure pointed to by "
"I<arg.buf> to the kernel data structure associated with this semaphore set, "
"updating also its I<sem_ctime> member.  The following members of the "
"structure are updated: I<sem_perm.uid>, I<sem_perm.gid>, and (the least "
"significant 9 bits of)  I<sem_perm.mode>.  The effective UID of the calling "
"process must match the owner (I<sem_perm.uid>)  or creator "
"(I<sem_perm.cuid>)  of the semaphore set, or the caller must be privileged.  "
"The argument I<semnum> is ignored."
msgstr ""

#. type: Plain text
#: man-pages/man2/semctl.2:170
msgid ""
"Immediately remove the semaphore set, awakening all processes blocked in "
"B<semop>(2)  calls on the set (with an error return and I<errno> set to "
"B<EIDRM>).  The effective user ID of the calling process must match the "
"creator or owner of the semaphore set, or the caller must be privileged.  "
"The argument I<semnum> is ignored."
msgstr ""

#. type: Plain text
#: man-pages/man2/semctl.2:182
msgid ""
"Return information about system-wide semaphore limits and parameters in the "
"structure pointed to by I<arg.__buf>.  This structure is of type I<seminfo>, "
"defined in I<E<lt>sys/sem.hE<gt>> if the B<_GNU_SOURCE> feature test macro "
"is defined:"
msgstr ""

#. type: Plain text
#: man-pages/man2/semctl.2:204
#, no-wrap
msgid ""
"struct  seminfo {\n"
"    int semmap;  /* Number of entries in semaphore\n"
"                    map; unused within kernel */\n"
"    int semmni;  /* Maximum number of semaphore sets */\n"
"    int semmns;  /* Maximum number of semaphores in all\n"
"                    semaphore sets */\n"
"    int semmnu;  /* System-wide maximum number of undo\n"
"                    structures; unused within kernel */\n"
"    int semmsl;  /* Maximum number of semaphores in a\n"
"                    set */\n"
"    int semopm;  /* Maximum number of operations for\n"
"                    semop(2) */\n"
"    int semume;  /* Maximum number of undo entries per\n"
"                    process; unused within kernel */\n"
"    int semusz;  /* Size of struct sem_undo */\n"
"    int semvmx;  /* Maximum semaphore value */\n"
"    int semaem;  /* Max. value that can be recorded for\n"
"                    semaphore adjustment (SEM_UNDO) */\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/semctl.2:218
msgid ""
"The I<semmsl>, I<semmns>, I<semopm>, and I<semmni> settings can be changed "
"via I</proc/sys/kernel/sem>; see B<proc>(5)  for details."
msgstr ""

#. type: TP
#: man-pages/man2/semctl.2:218
#, no-wrap
msgid "B<SEM_INFO> (Linux-specific)"
msgstr ""

#. type: Plain text
#: man-pages/man2/semctl.2:232
msgid ""
"Return a I<seminfo> structure containing the same information as for "
"B<IPC_INFO>, except that the following fields are returned with information "
"about system resources consumed by semaphores: the I<semusz> field returns "
"the number of semaphore sets that currently exist on the system; and the "
"I<semaem> field returns the total number of semaphores in all semaphore sets "
"on the system."
msgstr ""

#. type: TP
#: man-pages/man2/semctl.2:232
#, no-wrap
msgid "B<SEM_STAT> (Linux-specific)"
msgstr ""

#. type: Plain text
#: man-pages/man2/semctl.2:243
msgid ""
"Return a I<semid_ds> structure as for B<IPC_STAT>.  However, the I<semid> "
"argument is not a semaphore identifier, but instead an index into the "
"kernel's internal array that maintains information about all semaphore sets "
"on the system."
msgstr ""

#. type: TP
#: man-pages/man2/semctl.2:243
#, no-wrap
msgid "B<SEM_STAT_ANY> (Linux-specific, since Linux 4.17)"
msgstr ""

#. type: Plain text
#: man-pages/man2/semctl.2:256
msgid ""
"Return a I<seminfo> structure containing the same information as for "
"B<SEM_STAT>.  However, I<sem_perm.mode> is not checked for read access for "
"I<semid> meaning that any user can employ this operation (just as any user "
"may read I</proc/sysvipc/sem> to obtain the same information)."
msgstr ""

#. type: TP
#: man-pages/man2/semctl.2:256
#, no-wrap
msgid "B<GETALL>"
msgstr ""

#. type: Plain text
#: man-pages/man2/semctl.2:267
msgid ""
"Return B<semval> (i.e., the current value)  for all semaphores of the set "
"into I<arg.array>.  The argument I<semnum> is ignored.  The calling process "
"must have read permission on the semaphore set."
msgstr ""

#. type: TP
#: man-pages/man2/semctl.2:267 man-pages/man2/semctl.2:362
#, no-wrap
msgid "B<GETNCNT>"
msgstr ""

#. type: Plain text
#: man-pages/man2/semctl.2:280
msgid ""
"Return the value of B<semncnt> for the I<semnum>-th semaphore of the set "
"(i.e., the number of processes waiting for an increase of B<semval> for the "
"I<semnum>-th semaphore of the set).  The calling process must have read "
"permission on the semaphore set."
msgstr ""

#. type: TP
#: man-pages/man2/semctl.2:280 man-pages/man2/semctl.2:366
#, no-wrap
msgid "B<GETPID>"
msgstr ""

#. type: Plain text
#: man-pages/man2/semctl.2:290
msgid ""
"Return the value of B<sempid> for the I<semnum>-th semaphore of the set.  "
"This is the PID of the process that last performed an operation on that "
"semaphore (but see NOTES).  The calling process must have read permission on "
"the semaphore set."
msgstr ""

#. type: TP
#: man-pages/man2/semctl.2:290 man-pages/man2/semctl.2:370
#, no-wrap
msgid "B<GETVAL>"
msgstr ""

#. type: Plain text
#: man-pages/man2/semctl.2:298
msgid ""
"Return the value of B<semval> for the I<semnum>-th semaphore of the set.  "
"The calling process must have read permission on the semaphore set."
msgstr ""

#. type: TP
#: man-pages/man2/semctl.2:298 man-pages/man2/semctl.2:374
#, no-wrap
msgid "B<GETZCNT>"
msgstr ""

#. type: Plain text
#: man-pages/man2/semctl.2:311
msgid ""
"Return the value of B<semzcnt> for the I<semnum>-th semaphore of the set "
"(i.e., the number of processes waiting for B<semval> of the I<semnum>-th "
"semaphore of the set to become 0).  The calling process must have read "
"permission on the semaphore set."
msgstr ""

#. type: TP
#: man-pages/man2/semctl.2:311
#, no-wrap
msgid "B<SETALL>"
msgstr ""

#. type: Plain text
#: man-pages/man2/semctl.2:333
msgid ""
"Set B<semval> for all semaphores of the set using I<arg.array>, updating "
"also the I<sem_ctime> member of the I<semid_ds> structure associated with "
"the set.  Undo entries (see B<semop>(2))  are cleared for altered semaphores "
"in all processes.  If the changes to semaphore values would permit blocked "
"B<semop>(2)  calls in other processes to proceed, then those processes are "
"woken up.  The argument I<semnum> is ignored.  The calling process must have "
"alter (write) permission on the semaphore set."
msgstr ""

#. type: TP
#: man-pages/man2/semctl.2:333
#, no-wrap
msgid "B<SETVAL>"
msgstr ""

#. type: Plain text
#: man-pages/man2/semctl.2:351
msgid ""
"Set the value of B<semval> to I<arg.val> for the I<semnum>-th semaphore of "
"the set, updating also the I<sem_ctime> member of the I<semid_ds> structure "
"associated with the set.  Undo entries are cleared for altered semaphores in "
"all processes.  If the changes to semaphore values would permit blocked "
"B<semop>(2)  calls in other processes to proceed, then those processes are "
"woken up.  The calling process must have alter permission on the semaphore "
"set."
msgstr ""

#. type: Plain text
#: man-pages/man2/semctl.2:358
msgid "On failure, B<semctl>()  returns -1 with I<errno> indicating the error."
msgstr ""

#. type: Plain text
#: man-pages/man2/semctl.2:362
msgid ""
"Otherwise, the system call returns a nonnegative value depending on I<cmd> "
"as follows:"
msgstr ""

#. type: Plain text
#: man-pages/man2/semctl.2:366
msgid "the value of B<semncnt>."
msgstr ""

#. type: Plain text
#: man-pages/man2/semctl.2:370
msgid "the value of B<sempid>."
msgstr ""

#. type: Plain text
#: man-pages/man2/semctl.2:374
msgid "the value of B<semval>."
msgstr ""

#. type: Plain text
#: man-pages/man2/semctl.2:378
msgid "the value of B<semzcnt>."
msgstr ""

#. type: TP
#: man-pages/man2/semctl.2:378
#, no-wrap
msgid "B<IPC_INFO>"
msgstr ""

#. type: Plain text
#: man-pages/man2/semctl.2:388
msgid ""
"the index of the highest used entry in the kernel's internal array recording "
"information about all semaphore sets.  (This information can be used with "
"repeated B<SEM_STAT> or B<SEM_STAT_ANY> operations to obtain information "
"about all semaphore sets on the system.)"
msgstr ""

#. type: TP
#: man-pages/man2/semctl.2:388
#, no-wrap
msgid "B<SEM_INFO>"
msgstr ""

#. type: Plain text
#: man-pages/man2/semctl.2:392
msgid "as for B<IPC_INFO>."
msgstr ""

#. type: TP
#: man-pages/man2/semctl.2:392
#, no-wrap
msgid "B<SEM_STAT>"
msgstr ""

#. type: Plain text
#: man-pages/man2/semctl.2:396
msgid "the identifier of the semaphore set whose index was given in I<semid>."
msgstr ""

#. type: TP
#: man-pages/man2/semctl.2:396
#, no-wrap
msgid "B<SEM_STAT_ANY>"
msgstr ""

#. type: Plain text
#: man-pages/man2/semctl.2:400
msgid "as for B<SEM_STAT>."
msgstr ""

#. type: Plain text
#: man-pages/man2/semctl.2:404
msgid "All other I<cmd> values return 0 on success."
msgstr ""

#. type: Plain text
#: man-pages/man2/semctl.2:428
msgid ""
"The argument I<cmd> has one of the values B<GETALL>, B<GETPID>, B<GETVAL>, "
"B<GETNCNT>, B<GETZCNT>, B<IPC_STAT>, B<SEM_STAT>, B<SEM_STAT_ANY>, "
"B<SETALL>, or B<SETVAL> and the calling process does not have the required "
"permissions on the semaphore set and does not have the B<CAP_IPC_OWNER> "
"capability in the user namespace that governs its IPC namespace."
msgstr ""

#. type: Plain text
#: man-pages/man2/semctl.2:435
msgid "The address pointed to by I<arg.buf> or I<arg.array> isn't accessible."
msgstr ""

#. type: Plain text
#: man-pages/man2/semctl.2:438 man-pages/man2/semop.2:352
msgid "The semaphore set was removed."
msgstr ""

#. type: Plain text
#: man-pages/man2/semctl.2:449
msgid ""
"Invalid value for I<cmd> or I<semid>.  Or: for a B<SEM_STAT> operation, the "
"index value specified in I<semid> referred to an array slot that is "
"currently unused."
msgstr ""

#. type: Plain text
#: man-pages/man2/semctl.2:467
msgid ""
"The argument I<cmd> has the value B<IPC_SET> or B<IPC_RMID> but the "
"effective user ID of the calling process is not the creator (as found in "
"I<sem_perm.cuid>)  or the owner (as found in I<sem_perm.uid>)  of the "
"semaphore set, and the process does not have the B<CAP_SYS_ADMIN> "
"capability."
msgstr ""

#. type: Plain text
#: man-pages/man2/semctl.2:480
msgid ""
"The argument I<cmd> has the value B<SETALL> or B<SETVAL> and the value to "
"which B<semval> is to be set (for some semaphore of the set) is less than 0 "
"or greater than the implementation limit B<SEMVMX>."
msgstr ""

#.  POSIX.1-2001, POSIX.1-2008
#. type: Plain text
#: man-pages/man2/semctl.2:495
msgid ""
"POSIX.1 specifies the I<sem_nsems> field of the I<semid_ds> structure as "
"having the type I<unsigned\\ short>, and the field is so defined on most "
"other systems.  It was also so defined on Linux 2.2 and earlier, but, since "
"Linux 2.4, the field has the type I<unsigned\\ long>."
msgstr ""

#. type: Plain text
#: man-pages/man2/semctl.2:520
msgid ""
"The B<IPC_INFO>, B<SEM_STAT> and B<SEM_INFO> operations are used by the "
"B<ipcs>(1)  program to provide information on allocated resources.  In the "
"future these may modified or moved to a I</proc> filesystem interface."
msgstr ""

#. type: Plain text
#: man-pages/man2/semctl.2:533
msgid ""
"Various fields in a I<struct semid_ds> were typed as I<short> under Linux "
"2.2 and have become I<long> under Linux 2.4.  To take advantage of this, a "
"recompilation under glibc-2.1.91 or later should suffice.  (The kernel "
"distinguishes old and new calls by an B<IPC_64> flag in I<cmd>.)"
msgstr ""

#.  POSIX.1-2001, POSIX.1-2008
#. type: Plain text
#: man-pages/man2/semctl.2:543
msgid ""
"In some earlier versions of glibc, the I<semun> union was defined in "
"I<E<lt>sys/sem.hE<gt>>, but POSIX.1 requires that the caller define this "
"union.  On versions of glibc where this union is I<not> defined, the macro "
"B<_SEM_SEMUN_UNDEFINED> is defined in I<E<lt>sys/sem.hE<gt>>."
msgstr ""

#. type: Plain text
#: man-pages/man2/semctl.2:547
msgid "The following system limit on semaphore sets affects a B<semctl>()  call:"
msgstr ""

#. type: TP
#: man-pages/man2/semctl.2:547 man-pages/man2/semop.2:478
#, no-wrap
msgid "B<SEMVMX>"
msgstr ""

#. type: Plain text
#: man-pages/man2/semctl.2:552
msgid "Maximum value for B<semval>: implementation dependent (32767)."
msgstr ""

#. type: Plain text
#: man-pages/man2/semctl.2:557
msgid ""
"For greater portability, it is best to always call B<semctl>()  with four "
"arguments."
msgstr ""

#. type: SS
#: man-pages/man2/semctl.2:557
#, no-wrap
msgid "The sempid value"
msgstr ""

#. type: Plain text
#: man-pages/man2/semctl.2:566
msgid ""
"POSIX.1 defines I<sempid> as the \"process ID of [the] last operation\" on a "
"semaphore, and explicitly notes that this value is set by a successful "
"B<semop>(2)  call, with the implication that no other interface affects the "
"I<sempid> value."
msgstr ""

#.  At least OpenSolaris (and, one supposes, older Solaris) and Darwin
#. type: Plain text
#: man-pages/man2/semctl.2:584
msgid ""
"While some implementations conform to the behavior specified in POSIX.1, "
"others do not.  (The fault here probably lies with POSIX.1 inasmuch as it "
"likely failed to capture the full range of existing implementation "
"behaviors.)  Various other implementations also update I<sempid> for the "
"other operations that update the value of a semaphore: the B<SETVAL> and "
"B<SETALL> operations, as well as the semaphore adjustments performed on "
"process termination as a consequence of the use of the B<SEM_UNDO> flag (see "
"B<semop>(2))."
msgstr ""

#.  commit a5f4db877177d2a3d7ae62a7bac3a5a27e083d7f
#. type: Plain text
#: man-pages/man2/semctl.2:599
msgid ""
"Linux also updates I<sempid> for B<SETVAL> operations and semaphore "
"adjustments.  However, somewhat inconsistently, up to and including 4.5, "
"Linux did not update I<sempid> for B<SETALL> operations.  This was rectified "
"in Linux 4.6."
msgstr ""

#. type: Plain text
#: man-pages/man2/semctl.2:605
msgid ""
"B<ipc>(2), B<semget>(2), B<semop>(2), B<capabilities>(7), "
"B<sem_overview>(7), B<sysvipc>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/time.2:29
#, no-wrap
msgid "TIME"
msgstr ""

#. type: Plain text
#: man-pages/man2/time.2:32
msgid "time - get time in seconds"
msgstr ""

#. type: Plain text
#: man-pages/man2/time.2:36
msgid "B<time_t time(time_t *>I<tloc>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/time.2:40
msgid ""
"B<time>()  returns the time as the number of seconds since the Epoch, "
"1970-01-01 00:00:00 +0000 (UTC)."
msgstr ""

#. type: Plain text
#: man-pages/man2/time.2:46
msgid ""
"If I<tloc> is non-NULL, the return value is also stored in the memory "
"pointed to by I<tloc>."
msgstr ""

#. type: Plain text
#: man-pages/man2/time.2:50
msgid ""
"On success, the value of time in seconds since the Epoch is returned.  On "
"error, I<((time_t)\\ -1)> is returned, and I<errno> is set appropriately."
msgstr ""

#. type: Plain text
#: man-pages/man2/time.2:55
msgid "I<tloc> points outside your accessible address space (but see BUGS)."
msgstr ""

#. type: Plain text
#: man-pages/man2/time.2:64
msgid ""
"On systems where the C library B<time>()  wrapper function invokes an "
"implementation provided by the B<vdso>(7)  (so that there is no trap into "
"the kernel), an invalid address may instead trigger a B<SIGSEGV> signal."
msgstr ""

#.  Under 4.3BSD, this call is obsoleted by
#.  .BR gettimeofday (2).
#. type: Plain text
#: man-pages/man2/time.2:69
msgid ""
"SVr4, 4.3BSD, C89, C99, POSIX.1-2001.  POSIX does not specify any error "
"conditions."
msgstr ""

#. type: Plain text
#: man-pages/man2/time.2:84
msgid ""
"POSIX.1 defines I<seconds since the Epoch> using a formula that approximates "
"the number of seconds between a specified time and the Epoch.  This formula "
"takes account of the facts that all years that are evenly divisible by 4 are "
"leap years, but years that are evenly divisible by 100 are not leap years "
"unless they are also evenly divisible by 400, in which case they are leap "
"years.  This value is not the same as the actual number of seconds between "
"the time and the Epoch, because of leap seconds and because system clocks "
"are not required to be synchronized to a standard reference.  The intention "
"is that the interpretation of seconds since the Epoch values be consistent; "
"see POSIX.1-2008 Rationale A.4.15 for further rationale."
msgstr ""

#. type: Plain text
#: man-pages/man2/time.2:105
msgid ""
"On Linux, a call to B<time>()  with I<tloc> specified as NULL cannot fail "
"with the error B<EOVERFLOW>, even on ABIs where I<time_t> is a signed 32-bit "
"integer and the clock ticks past the time 2**31 (2038-01-19 03:14:08 UTC, "
"ignoring leap seconds).  (POSIX.1 permits, but does not require, the "
"B<EOVERFLOW> error in the case where the seconds since the Epoch will not "
"fit in I<time_t>.)  Instead, the behavior on Linux is undefined when the "
"system time is out of the I<time_t> range.  Applications intended to run "
"after 2038 should use ABIs with I<time_t> wider than 32 bits."
msgstr ""

#. type: Plain text
#: man-pages/man2/time.2:112
msgid ""
"Error returns from this system call are indistinguishable from successful "
"reports that the time is a few seconds I<before> the Epoch, so the C library "
"wrapper function never sets I<errno> as a result of this call."
msgstr ""

#. type: Plain text
#: man-pages/man2/time.2:120
msgid ""
"The I<tloc> argument is obsolescent and should always be NULL in new code.  "
"When I<tloc> is NULL, the call cannot fail."
msgstr ""

#. type: Plain text
#: man-pages/man2/time.2:125
msgid ""
"On some architectures, an implementation of B<time>()  is provided in the "
"B<vdso>(7)."
msgstr ""

#. type: Plain text
#: man-pages/man2/time.2:131
msgid ""
"B<date>(1), B<gettimeofday>(2), B<ctime>(3), B<ftime>(3), B<time>(7), "
"B<vdso>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/getgroups.2:32
#, no-wrap
msgid "GETGROUPS"
msgstr ""

#. type: Plain text
#: man-pages/man2/getgroups.2:35
msgid "getgroups, setgroups - get/set list of supplementary group IDs"
msgstr ""

#. type: Plain text
#: man-pages/man2/getgroups.2:41
msgid "B<int getgroups(int >I<size>B<, gid_t >I<list>B<[]);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/getgroups.2:43
msgid "B<#include E<lt>grp.hE<gt>>"
msgstr ""

#. type: Plain text
#: man-pages/man2/getgroups.2:45
msgid "B<int setgroups(size_t >I<size>B<, const gid_t *>I<list>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/getgroups.2:56
#, no-wrap
msgid ""
"B<setgroups>():\n"
"    Since glibc 2.19:\n"
"        _DEFAULT_SOURCE\n"
"    Glibc 2.19 and earlier:\n"
"        _BSD_SOURCE\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/getgroups.2:69
msgid ""
"B<getgroups>()  returns the supplementary group IDs of the calling process "
"in I<list>.  The argument I<size> should be set to the maximum number of "
"items that can be stored in the buffer pointed to by I<list>.  If the "
"calling process is a member of more than I<size> supplementary groups, then "
"an error results."
msgstr ""

#. type: Plain text
#: man-pages/man2/getgroups.2:75
msgid ""
"It is unspecified whether the effective group ID of the calling process is "
"included in the returned list.  (Thus, an application should also call "
"B<getegid>(2)  and add or remove the resulting value.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/getgroups.2:86
msgid ""
"If I<size> is zero, I<list> is not modified, but the total number of "
"supplementary group IDs for the process is returned.  This allows the caller "
"to determine the size of a dynamically allocated I<list> to be used in a "
"further call to B<getgroups>()."
msgstr ""

#. type: Plain text
#: man-pages/man2/getgroups.2:98
msgid ""
"B<setgroups>()  sets the supplementary group IDs for the calling process.  "
"Appropriate privileges are required (see the description of the B<EPERM> "
"error, below).  The I<size> argument specifies the number of supplementary "
"group IDs in the buffer pointed to by I<list>.  A process can drop all of "
"its supplementary groups with the call:"
msgstr ""

#. type: Plain text
#: man-pages/man2/getgroups.2:102
#, no-wrap
msgid "setgroups(0, NULL);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/getgroups.2:111
msgid ""
"On success, B<getgroups>()  returns the number of supplementary group IDs.  "
"On error, -1 is returned, and I<errno> is set appropriately."
msgstr ""

#. type: Plain text
#: man-pages/man2/getgroups.2:118
msgid ""
"On success, B<setgroups>()  returns 0.  On error, -1 is returned, and "
"I<errno> is set appropriately."
msgstr ""

#. type: Plain text
#: man-pages/man2/getgroups.2:123
msgid "I<list> has an invalid address."
msgstr ""

#. type: Plain text
#: man-pages/man2/getgroups.2:126
msgid "B<getgroups>()  can additionally fail with the following error:"
msgstr ""

#. type: Plain text
#: man-pages/man2/getgroups.2:130
msgid "I<size> is less than the number of supplementary group IDs, but is not zero."
msgstr ""

#. type: Plain text
#: man-pages/man2/getgroups.2:133
msgid "B<setgroups>()  can additionally fail with the following errors:"
msgstr ""

#. type: Plain text
#: man-pages/man2/getgroups.2:139
msgid ""
"I<size> is greater than B<NGROUPS_MAX> (32 before Linux 2.6.4; 65536 since "
"Linux 2.6.4)."
msgstr ""

#. type: Plain text
#: man-pages/man2/getgroups.2:148
msgid ""
"The calling process has insufficient privilege (the caller does not have the "
"B<CAP_SETGID> capability in the user namespace in which it resides)."
msgstr ""

#. type: TP
#: man-pages/man2/getgroups.2:148
#, no-wrap
msgid "B<EPERM> (since Linux 3.19)"
msgstr ""

#. type: Plain text
#: man-pages/man2/getgroups.2:157
msgid ""
"The use of B<setgroups>()  is denied in this user namespace.  See the "
"description of I</proc/[pid]/setgroups> in B<user_namespaces>(7)."
msgstr ""

#. type: Plain text
#: man-pages/man2/getgroups.2:160
msgid "B<getgroups>(): SVr4, 4.3BSD, POSIX.1-2001, POSIX.1-2008."
msgstr ""

#. type: Plain text
#: man-pages/man2/getgroups.2:166
msgid ""
"B<setgroups>(): SVr4, 4.3BSD.  Since B<setgroups>()  requires privilege, it "
"is not covered by POSIX.1."
msgstr ""

#. type: Plain text
#: man-pages/man2/getgroups.2:178
msgid ""
"A process can have up to B<NGROUPS_MAX> supplementary group IDs in addition "
"to the effective group ID.  The constant B<NGROUPS_MAX> is defined in "
"I<E<lt>limits.hE<gt>>.  The set of supplementary group IDs is inherited from "
"the parent process, and preserved across an B<execve>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/getgroups.2:181
msgid ""
"The maximum number of supplementary group IDs can be found at run time using "
"B<sysconf>(3):"
msgstr ""

#. type: Plain text
#: man-pages/man2/getgroups.2:186
#, no-wrap
msgid ""
"long ngroups_max;\n"
"ngroups_max = sysconf(_SC_NGROUPS_MAX);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/getgroups.2:195
msgid ""
"The maximum return value of B<getgroups>()  cannot be larger than one more "
"than this value.  Since Linux 2.6.4, the maximum number of supplementary "
"group IDs is also exposed via the Linux-specific read-only file, "
"I</proc/sys/kernel/ngroups_max>."
msgstr ""

#. type: Plain text
#: man-pages/man2/getgroups.2:206
msgid ""
"The original Linux B<getgroups>()  system call supported only 16-bit group "
"IDs.  Subsequently, Linux 2.4 added B<getgroups32>(), supporting 32-bit "
"IDs.  The glibc B<getgroups>()  wrapper function transparently deals with "
"the variation across kernel versions."
msgstr ""

#. type: Plain text
#: man-pages/man2/getgroups.2:220
msgid ""
"At the kernel level, user IDs and group IDs are a per-thread attribute.  "
"However, POSIX requires that all threads in a process share the same "
"credentials.  The NPTL threading implementation handles the POSIX "
"requirements by providing wrapper functions for the various system calls "
"that change process UIDs and GIDs.  These wrapper functions (including the "
"one for B<setgroups>())  employ a signal-based technique to ensure that when "
"one thread changes credentials, all of the other threads in the process also "
"change their credentials.  For details, see B<nptl>(7)."
msgstr ""

#. type: Plain text
#: man-pages/man2/getgroups.2:227
msgid ""
"B<getgid>(2), B<setgid>(2), B<getgrouplist>(3), B<group_member>(3), "
"B<initgroups>(3), B<capabilities>(7), B<credentials>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/readlink.2:44
#, no-wrap
msgid "READLINK"
msgstr ""

#. type: Plain text
#: man-pages/man2/readlink.2:47
msgid "readlink, readlinkat - read value of a symbolic link"
msgstr ""

#. type: Plain text
#: man-pages/man2/readlink.2:53
#, no-wrap
msgid ""
"B<ssize_t readlink(const char *>I<pathname>B<, char *>I<buf>B<, size_t "
">I<bufsiz>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/readlink.2:59
#, no-wrap
msgid ""
"B<ssize_t readlinkat(int >I<dirfd>B<, const char *>I<pathname>B<,>\n"
"B<                   char *>I<buf>B<, size_t >I<bufsiz>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/readlink.2:68
msgid "B<readlink>():"
msgstr ""

#. type: Plain text
#: man-pages/man2/readlink.2:75
msgid "B<readlinkat>():"
msgstr ""

#. type: Plain text
#: man-pages/man2/readlink.2:101
msgid ""
"B<readlink>()  places the contents of the symbolic link I<pathname> in the "
"buffer I<buf>, which has size I<bufsiz>.  B<readlink>()  does not append a "
"null byte to I<buf>.  It will (silently) truncate the contents (to a length "
"of I<bufsiz> characters), in case the buffer is too small to hold all of the "
"contents."
msgstr ""

#. type: SS
#: man-pages/man2/readlink.2:101
#, no-wrap
msgid "readlinkat()"
msgstr ""

#. type: Plain text
#: man-pages/man2/readlink.2:107
msgid ""
"The B<readlinkat>()  system call operates in exactly the same way as "
"B<readlink>(), except for the differences described here."
msgstr ""

#. type: Plain text
#: man-pages/man2/readlink.2:117
msgid ""
"If the pathname given in I<pathname> is relative, then it is interpreted "
"relative to the directory referred to by the file descriptor I<dirfd> "
"(rather than relative to the current working directory of the calling "
"process, as is done by B<readlink>()  for a relative pathname)."
msgstr ""

#. type: Plain text
#: man-pages/man2/readlink.2:129
msgid ""
"If I<pathname> is relative and I<dirfd> is the special value B<AT_FDCWD>, "
"then I<pathname> is interpreted relative to the current working directory of "
"the calling process (like B<readlink>())."
msgstr ""

#.  commit 65cfc6722361570bfe255698d9cd4dccaf47570d
#. type: Plain text
#: man-pages/man2/readlink.2:149
msgid ""
"Since Linux 2.6.39, I<pathname> can be an empty string, in which case the "
"call operates on the symbolic link referred to by I<dirfd> (which should "
"have been obtained using B<open>(2)  with the B<O_PATH> and B<O_NOFOLLOW> "
"flags)."
msgstr ""

#. type: Plain text
#: man-pages/man2/readlink.2:154
msgid "See B<openat>(2)  for an explanation of the need for B<readlinkat>()."
msgstr ""

#. type: Plain text
#: man-pages/man2/readlink.2:163
msgid ""
"On success, these calls return the number of bytes placed in I<buf>.  (If "
"the returned value equals I<bufsiz>, then truncation may have occurred.)  On "
"error, -1 is returned and I<errno> is set to indicate the error."
msgstr ""

#. type: Plain text
#: man-pages/man2/readlink.2:169
msgid ""
"Search permission is denied for a component of the path prefix.  (See also "
"B<path_resolution>(7).)"
msgstr ""

#. type: Plain text
#: man-pages/man2/readlink.2:173
msgid "I<buf> extends outside the process's allocated address space."
msgstr ""

#.  At the glibc level, bufsiz is unsigned, so this error can only occur
#.  if bufsiz==0.  However, the in the kernel syscall, bufsiz is signed,
#.  and this error can also occur if bufsiz < 0.
#.  See: http://thread.gmane.org/gmane.linux.man/380
#.  Subject: [patch 0/3] [RFC] kernel/glibc mismatch of "readlink" syscall?
#. type: Plain text
#: man-pages/man2/readlink.2:182
msgid "I<bufsiz> is not positive."
msgstr ""

#. type: Plain text
#: man-pages/man2/readlink.2:187
msgid ""
"The named file (i.e., the final filename component of I<pathname>)  is not a "
"symbolic link."
msgstr ""

#. type: Plain text
#: man-pages/man2/readlink.2:190 man-pages/man2/statfs.2:249
msgid "An I/O error occurred while reading from the filesystem."
msgstr ""

#. type: Plain text
#: man-pages/man2/readlink.2:196
msgid "A pathname, or a component of a pathname, was too long."
msgstr ""

#. type: Plain text
#: man-pages/man2/readlink.2:208
msgid "The following additional errors can occur for B<readlinkat>():"
msgstr ""

#. type: Plain text
#: man-pages/man2/readlink.2:222
msgid ""
"B<readlinkat>()  was added to Linux in kernel 2.6.16; library support was "
"added to glibc in version 2.4."
msgstr ""

#. type: Plain text
#: man-pages/man2/readlink.2:228
msgid ""
"B<readlink>(): 4.4BSD (B<readlink>()  first appeared in 4.2BSD), "
"POSIX.1-2001, POSIX.1-2008."
msgstr ""

#. type: Plain text
#: man-pages/man2/readlink.2:231
msgid "B<readlinkat>(): POSIX.1-2008."
msgstr ""

#. type: Plain text
#: man-pages/man2/readlink.2:239
msgid ""
"In versions of glibc up to and including glibc 2.4, the return type of "
"B<readlink>()  was declared as I<int>.  Nowadays, the return type is "
"declared as I<ssize_t>, as (newly) required in POSIX.1-2001."
msgstr ""

#. type: Plain text
#: man-pages/man2/readlink.2:262
msgid ""
"Using a statically sized buffer might not provide enough room for the "
"symbolic link contents.  The required size for the buffer can be obtained "
"from the I<stat.st_size> value returned by a call to B<lstat>(2)  on the "
"link.  However, the number of bytes written by B<readlink>()  and "
"B<readlinkat>()  should be checked to make sure that the size of the "
"symbolic link did not increase between the calls.  Dynamically allocating "
"the buffer for B<readlink>()  and B<readlinkat>()  also addresses a common "
"portability problem when using I<PATH_MAX> for the buffer size, as this "
"constant is not guaranteed to be defined per POSIX if the system does not "
"have such limit."
msgstr ""

#. type: Plain text
#: man-pages/man2/readlink.2:275
msgid ""
"On older kernels where B<readlinkat>()  is unavailable, the glibc wrapper "
"function falls back to the use of B<readlink>().  When I<pathname> is a "
"relative pathname, glibc constructs a pathname based on the symbolic link in "
"I</proc/self/fd> that corresponds to the I<dirfd> argument."
msgstr ""

#. type: Plain text
#: man-pages/man2/readlink.2:285
msgid ""
"The following program allocates the buffer needed by B<readlink>()  "
"dynamically from the information provided by B<lstat>(2), falling back to a "
"buffer of size B<PATH_MAX> in cases where B<lstat>(2)  reports a size of "
"zero."
msgstr ""

#. type: Plain text
#: man-pages/man2/readlink.2:293
#, no-wrap
msgid ""
"#include E<lt>sys/types.hE<gt>\n"
"#include E<lt>sys/stat.hE<gt>\n"
"#include E<lt>limits.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/readlink.2:300
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    struct stat sb;\n"
"    char *buf;\n"
"    ssize_t nbytes, bufsiz;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/readlink.2:313
#, no-wrap
msgid ""
"    /* Add one to the link size, so that we can determine whether\n"
"       the buffer returned by readlink() was truncated. */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/readlink.2:315
#, no-wrap
msgid "    bufsiz = sb.st_size + 1;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/readlink.2:319
#, no-wrap
msgid ""
"    /* Some magic symlinks under (for example) /proc and /sys\n"
"       report \\(aqst_size\\(aq as zero. In that case, take PATH_MAX as\n"
"       a \"good enough\" estimate. */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/readlink.2:322
#, no-wrap
msgid ""
"    if (sb.st_size == 0)\n"
"        bufsiz = PATH_MAX;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/readlink.2:328
#, no-wrap
msgid ""
"    buf = malloc(bufsiz);\n"
"    if (buf == NULL) {\n"
"        perror(\"malloc\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/readlink.2:334
#, no-wrap
msgid ""
"    nbytes = readlink(argv[1], buf, bufsiz);\n"
"    if (nbytes == -1) {\n"
"        perror(\"readlink\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/readlink.2:336
#, no-wrap
msgid ""
"    printf(\"\\(aq%s\\(aq points to \\(aq%.*s\\(aq\\en\", argv[1], (int) "
"nbytes, buf);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/readlink.2:342
#, no-wrap
msgid ""
"    /* If the return value was equal to the buffer size, then the\n"
"       the link target was larger than expected (perhaps because the\n"
"       target was changed between the call to lstat() and the call to\n"
"       readlink()). Warn the user that the returned target may have\n"
"       been truncated. */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/readlink.2:345
#, no-wrap
msgid ""
"    if (nbytes == bufsiz)\n"
"        printf(\"(Returned buffer may have been truncated)\\en\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/readlink.2:357
msgid ""
"B<readlink>(1), B<lstat>(2), B<stat>(2), B<symlink>(2), B<realpath>(3), "
"B<path_resolution>(7), B<symlink>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/ioctl_console.2:40
#, no-wrap
msgid "IOCTL_CONSOLE"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_console.2:43
msgid "ioctl_console - ioctls for console terminal and virtual consoles"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_console.2:49
msgid ""
"The following Linux-specific B<ioctl>(2)  requests are supported for console "
"terminals and virtual consoles.  Each requires a third argument, assumed "
"here to be I<argp>."
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_console.2:49
#, no-wrap
msgid "B<KDGETLED>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_console.2:59
msgid ""
"Get state of LEDs.  I<argp> points to a I<char>.  The lower three bits of "
"I<*argp> are set to the state of the LEDs, as follows:"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_console.2:61
#, no-wrap
msgid "LED_CAP "
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_console.2:61 man-pages/man2/ioctl_console.2:398
#, no-wrap
msgid "0x04"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_console.2:61
#, no-wrap
msgid "caps lock led"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_console.2:62
#, no-wrap
msgid "LED_NUM "
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_console.2:62
#, no-wrap
msgid "0x02"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_console.2:62
#, no-wrap
msgid "num lock led"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_console.2:63
#, no-wrap
msgid "LED_SCR "
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_console.2:63 man-pages/man2/ioctl_console.2:131
#, no-wrap
msgid "0x01"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_console.2:63
#, no-wrap
msgid "scroll lock led"
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_console.2:65
#, no-wrap
msgid "B<KDSETLED>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_console.2:74
msgid ""
"Set the LEDs.  The LEDs are set to correspond to the lower three bits of the "
"unsigned long integer in I<argp>.  However, if a higher order bit is set, "
"the LEDs revert to normal: displaying the state of the keyboard functions of "
"caps lock, num lock, and scroll lock."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_console.2:81
msgid ""
"Before Linux 1.1.54, the LEDs just reflected the state of the corresponding "
"keyboard flags, and KDGETLED/KDSETLED would also change the keyboard flags.  "
"Since Linux 1.1.54 the LEDs can be made to display arbitrary information, "
"but by default they display the keyboard flags.  The following two ioctls "
"are used to access the keyboard flags."
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_console.2:81
#, no-wrap
msgid "B<KDGKBLED>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_console.2:90
msgid ""
"Get keyboard flags CapsLock, NumLock, ScrollLock (not lights).  I<argp> "
"points to a char which is set to the flag state.  The low order three bits "
"(mask 0x7) get the current flag state, and the low order bits of the next "
"nibble (mask 0x70) get the default flag state.  (Since Linux 1.1.54.)"
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_console.2:90
#, no-wrap
msgid "B<KDSKBLED>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_console.2:99
msgid ""
"Set keyboard flags CapsLock, NumLock, ScrollLock (not lights).  I<argp> is "
"an unsigned long integer that has the desired flag state.  The low order "
"three bits (mask 0x7) have the flag state, and the low order bits of the "
"next nibble (mask 0x70) have the default flag state.  (Since Linux 1.1.54.)"
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_console.2:99
#, no-wrap
msgid "B<KDGKBTYPE>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_console.2:103
msgid "Get keyboard type.  This returns the value KB_101, defined as 0x02."
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_console.2:103
#, no-wrap
msgid "B<KDADDIO>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_console.2:108
msgid "Add I/O port as valid.  Equivalent to I<ioperm(arg,1,1)>."
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_console.2:108
#, no-wrap
msgid "B<KDDELIO>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_console.2:113
msgid "Delete I/O port as valid.  Equivalent to I<ioperm(arg,1,0)>."
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_console.2:113
#, no-wrap
msgid "B<KDENABIO>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_console.2:118
msgid ""
"Enable I/O to video board.  Equivalent to I<ioperm(0x3b4, 0x3df-0x3b4+1, "
"1)>."
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_console.2:118
#, no-wrap
msgid "B<KDDISABIO>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_console.2:123
msgid ""
"Disable I/O to video board.  Equivalent to I<ioperm(0x3b4, 0x3df-0x3b4+1, "
"0)>."
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_console.2:123
#, no-wrap
msgid "B<KDSETMODE>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_console.2:128
msgid "Set text/graphics mode.  I<argp> is an unsigned integer containing one of:"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_console.2:130
#, no-wrap
msgid "KD_TEXT"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_console.2:130
#, no-wrap
msgid "0x00"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_console.2:131
#, no-wrap
msgid "KD_GRAPHICS"
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_console.2:133
#, no-wrap
msgid "B<KDGETMODE>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_console.2:142
msgid ""
"Get text/graphics mode.  I<argp> points to an I<int> which is set to one of "
"the values shown above for B<KDSETMODE>."
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_console.2:142
#, no-wrap
msgid "B<KDMKTONE>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_console.2:156
msgid ""
"Generate tone of specified length.  The lower 16 bits of the unsigned long "
"integer in I<argp> specify the period in clock cycles, and the upper 16 bits "
"give the duration in msec.  If the duration is zero, the sound is turned "
"off.  Control returns immediately.  For example, I<argp> = (125E<lt>E<lt>16) "
"+ 0x637 would specify the beep normally associated with a ctrl-G.  (Thus "
"since Linux 0.99pl1; broken in Linux 2.1.49-50.)"
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_console.2:156
#, no-wrap
msgid "B<KIOCSOUND>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_console.2:168
msgid ""
"Start or stop sound generation.  The lower 16 bits of I<argp> specify the "
"period in clock cycles (that is, I<argp> = 1193180/frequency).  I<argp> = 0 "
"turns sound off.  In either case, control returns immediately."
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_console.2:168
#, no-wrap
msgid "B<GIO_CMAP>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_console.2:175
msgid ""
"Get the current default color map from kernel.  I<argp> points to a 48-byte "
"array.  (Since Linux 1.3.3.)"
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_console.2:175
#, no-wrap
msgid "B<PIO_CMAP>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_console.2:188
msgid ""
"Change the default text-mode color map.  I<argp> points to a 48-byte array "
"which contains, in order, the Red, Green, and Blue values for the 16 "
"available screen colors: 0 is off, and 255 is full intensity.  The default "
"colors are, in order: black, dark red, dark green, brown, dark blue, dark "
"purple, dark cyan, light grey, dark grey, bright red, bright green, yellow, "
"bright blue, bright purple, bright cyan and white.  (Since Linux 1.3.3.)"
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_console.2:188
#, no-wrap
msgid "B<GIO_FONT>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_console.2:198
msgid ""
"Gets 256-character screen font in expanded form.  I<argp> points to an "
"8192-byte array.  Fails with error code B<EINVAL> if the currently loaded "
"font is a 512-character font, or if the console is not in text mode."
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_console.2:198
#, no-wrap
msgid "B<GIO_FONTX>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_console.2:226
msgid ""
"Gets screen font and associated information.  I<argp> points to a I<struct "
"consolefontdesc> (see B<PIO_FONTX>).  On call, the I<charcount> field should "
"be set to the maximum number of characters that would fit in the buffer "
"pointed to by I<chardata>.  On return, the I<charcount> and I<charheight> "
"are filled with the respective data for the currently loaded font, and the "
"I<chardata> array contains the font data if the initial value of "
"I<charcount> indicated enough space was available; otherwise the buffer is "
"untouched and I<errno> is set to B<ENOMEM>.  (Since Linux 1.3.1.)"
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_console.2:226
#, no-wrap
msgid "B<PIO_FONT>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_console.2:241
msgid ""
"Sets 256-character screen font.  Load font into the EGA/VGA character "
"generator.  I<argp> points to an 8192-byte map, with 32 bytes per "
"character.  Only the first I<N> of them are used for an 8xI<N> font (0 E<lt> "
"I<N> E<lt>= 32).  This call also invalidates the Unicode mapping."
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_console.2:241
#, no-wrap
msgid "B<PIO_FONTX>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_console.2:246
msgid "Sets screen font and associated rendering information.  I<argp> points to a"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_console.2:257
#, no-wrap
msgid ""
"struct consolefontdesc {\n"
"    unsigned short charcount;  /* characters in font\n"
"                                  (256 or 512) */\n"
"    unsigned short charheight; /* scan lines per\n"
"                                  character (1-32) */\n"
"    char          *chardata;   /* font data in\n"
"                                  expanded form */\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_console.2:265
msgid ""
"If necessary, the screen will be appropriately resized, and B<SIGWINCH> sent "
"to the appropriate processes.  This call also invalidates the Unicode "
"mapping.  (Since Linux 1.3.1.)"
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_console.2:265
#, no-wrap
msgid "B<PIO_FONTRESET>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_console.2:273
msgid ""
"Resets the screen font, size and Unicode mapping to the bootup defaults.  "
"I<argp> is unused, but should be set to NULL to ensure compatibility with "
"future versions of Linux.  (Since Linux 1.3.28.)"
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_console.2:273
#, no-wrap
msgid "B<GIO_SCRNMAP>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_console.2:282
msgid ""
"Get screen mapping from kernel.  I<argp> points to an area of size E_TABSZ, "
"which is loaded with the font positions used to display each character.  "
"This call is likely to return useless information if the currently loaded "
"font is more than 256 characters."
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_console.2:282
#, no-wrap
msgid "B<GIO_UNISCRNMAP>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_console.2:294
msgid ""
"Get full Unicode screen mapping from kernel.  I<argp> points to an area of "
"size I<E_TABSZ*sizeof(unsigned short)>, which is loaded with the Unicodes "
"each character represent.  A special set of Unicodes, starting at U+F000, "
"are used to represent \"direct to font\" mappings.  (Since Linux 1.3.1.)"
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_console.2:294
#, no-wrap
msgid "B<PIO_SCRNMAP>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_console.2:301
msgid ""
"Loads the \"user definable\" (fourth) table in the kernel which maps bytes "
"into console screen symbols.  I<argp> points to an area of size E_TABSZ."
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_console.2:301
#, no-wrap
msgid "B<PIO_UNISCRNMAP>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_console.2:309
msgid ""
"Loads the \"user definable\" (fourth) table in the kernel which maps bytes "
"into Unicodes, which are then translated into screen symbols according to "
"the currently loaded Unicode-to-font map.  Special Unicodes starting at "
"U+F000 can be used to map directly to the font symbols.  (Since Linux "
"1.3.1.)"
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_console.2:309
#, no-wrap
msgid "B<GIO_UNIMAP>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_console.2:314
msgid "Get Unicode-to-font mapping from kernel.  I<argp> points to a"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_console.2:321
#, no-wrap
msgid ""
"struct unimapdesc {\n"
"    unsigned short  entry_ct;\n"
"    struct unipair *entries;\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_console.2:327
msgid "where I<entries> points to an array of"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_console.2:334
#, no-wrap
msgid ""
"struct unipair {\n"
"    unsigned short unicode;\n"
"    unsigned short fontpos;\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_console.2:338 man-pages/man2/ioctl_console.2:362
msgid "(Since Linux 1.1.92.)"
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_console.2:338
#, no-wrap
msgid "B<PIO_UNIMAP>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_console.2:345
msgid ""
"Put unicode-to-font mapping in kernel.  I<argp> points to a I<struct "
"unimapdesc>.  (Since Linux 1.1.92)"
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_console.2:345
#, no-wrap
msgid "B<PIO_UNIMAPCLR>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_console.2:350
msgid "Clear table, possibly advise hash algorithm.  I<argp> points to a"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_console.2:358
#, no-wrap
msgid ""
"struct unimapinit {\n"
"    unsigned short advised_hashsize;  /* 0 if no opinion */\n"
"    unsigned short advised_hashstep;  /* 0 if no opinion */\n"
"    unsigned short advised_hashlevel; /* 0 if no opinion */\n"
"};\n"
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_console.2:362
#, no-wrap
msgid "B<KDGKBMODE>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_console.2:370
msgid ""
"Gets current keyboard mode.  I<argp> points to a I<long> which is set to one "
"of these:"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_console.2:372
#, no-wrap
msgid "K_RAW"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_console.2:372
#, no-wrap
msgid "0x00  /* Raw (scancode) mode */"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_console.2:373
#, no-wrap
msgid "K_XLATE"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_console.2:373
#, no-wrap
msgid "0x01  /* Translate keycodes using keymap */"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_console.2:374
#, no-wrap
msgid "K_MEDIUMRAW"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_console.2:374
#, no-wrap
msgid "0x02  /* Medium raw (scancode) mode */"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_console.2:375
#, no-wrap
msgid "K_UNICODE"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_console.2:375
#, no-wrap
msgid "0x03  /* Unicode mode */"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_console.2:376
#, no-wrap
msgid "K_OFF"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_console.2:376
#, no-wrap
msgid "0x04  /* Disabled mode; since Linux 2.6.39 */"
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_console.2:379
#, no-wrap
msgid "B<KDSKBMODE>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_console.2:387
msgid ""
"Sets current keyboard mode.  I<argp> is a I<long> equal to one of the values "
"shown for B<KDGKBMODE>."
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_console.2:387
#, no-wrap
msgid "B<KDGKBMETA>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_console.2:395
msgid ""
"Gets meta key handling mode.  I<argp> points to a I<long> which is set to "
"one of these:"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_console.2:397
#, no-wrap
msgid "K_METABIT"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_console.2:397
#, no-wrap
msgid "0x03"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_console.2:397
#, no-wrap
msgid "set high order bit"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_console.2:398
#, no-wrap
msgid "K_ESCPREFIX"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_console.2:398
#, no-wrap
msgid "escape prefix"
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_console.2:400
#, no-wrap
msgid "B<KDSKBMETA>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_console.2:408
msgid ""
"Sets meta key handling mode.  I<argp> is a I<long> equal to one of the "
"values shown above for B<KDGKBMETA>."
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_console.2:408
#, no-wrap
msgid "B<KDGKBENT>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_console.2:413
msgid ""
"Gets one entry in key translation table (keycode to action code).  I<argp> "
"points to a"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_console.2:421
#, no-wrap
msgid ""
"struct kbentry {\n"
"    unsigned char  kb_table;\n"
"    unsigned char  kb_index;\n"
"    unsigned short kb_value;\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_console.2:440
msgid ""
"with the first two members filled in: I<kb_table> selects the key table (0 "
"E<lt>= I<kb_table> E<lt> MAX_NR_KEYMAPS), and I<kb_index> is the keycode (0 "
"E<lt>= I<kb_index> E<lt> NR_KEYS).  I<kb_value> is set to the corresponding "
"action code, or K_HOLE if there is no such key, or K_NOSUCHMAP if "
"I<kb_table> is invalid."
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_console.2:440
#, no-wrap
msgid "B<KDSKBENT>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_console.2:446
msgid "Sets one entry in translation table.  I<argp> points to a I<struct kbentry>."
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_console.2:446
#, no-wrap
msgid "B<KDGKBSENT>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_console.2:451
msgid "Gets one function key string.  I<argp> points to a"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_console.2:458
#, no-wrap
msgid ""
"struct kbsentry {\n"
"    unsigned char kb_func;\n"
"    unsigned char kb_string[512];\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_console.2:466
msgid ""
"I<kb_string> is set to the (null-terminated) string corresponding to the "
"I<kb_func>th function key action code."
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_console.2:466
#, no-wrap
msgid "B<KDSKBSENT>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_console.2:472
msgid "Sets one function key string entry.  I<argp> points to a I<struct kbsentry>."
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_console.2:472
#, no-wrap
msgid "B<KDGKBDIACR>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_console.2:477
msgid "Read kernel accent table.  I<argp> points to a"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_console.2:484
#, no-wrap
msgid ""
"struct kbdiacrs {\n"
"    unsigned int   kb_cnt;\n"
"    struct kbdiacr kbdiacr[256];\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_console.2:491
msgid "where I<kb_cnt> is the number of entries in the array, each of which is a"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_console.2:499
#, no-wrap
msgid ""
"struct kbdiacr {\n"
"    unsigned char diacr;\n"
"    unsigned char base;\n"
"    unsigned char result;\n"
"};\n"
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_console.2:501
#, no-wrap
msgid "B<KDGETKEYCODE>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_console.2:506
msgid "Read kernel keycode table entry (scan code to keycode).  I<argp> points to a"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_console.2:513
#, no-wrap
msgid ""
"struct kbkeycode {\n"
"    unsigned int scancode;\n"
"    unsigned int keycode;\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_console.2:527
msgid ""
"I<keycode> is set to correspond to the given I<scancode>.  (89 E<lt>= "
"I<scancode> E<lt>= 255 only.  For 1 E<lt>= I<scancode> E<lt>= 88, "
"I<keycode>==I<scancode>.)  (Since Linux 1.1.63.)"
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_console.2:527
#, no-wrap
msgid "B<KDSETKEYCODE>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_console.2:534
msgid ""
"Write kernel keycode table entry.  I<argp> points to a I<struct kbkeycode>.  "
"(Since Linux 1.1.63.)"
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_console.2:534
#, no-wrap
msgid "B<KDSIGACCEPT>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_console.2:546
msgid ""
"The calling process indicates its willingness to accept the signal I<argp> "
"when it is generated by pressing an appropriate key combination.  (1 E<lt>= "
"I<argp> E<lt>= NSIG).  (See I<spawn_console>()  in "
"I<linux/drivers/char/keyboard.c>.)"
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_console.2:546
#, no-wrap
msgid "B<VT_OPENQRY>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_console.2:556
msgid ""
"Returns the first available (non-opened) console.  I<argp> points to an "
"I<int> which is set to the number of the vt (1 E<lt>= I<*argp> E<lt>= "
"MAX_NR_CONSOLES)."
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_console.2:556
#, no-wrap
msgid "B<VT_GETMODE>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_console.2:561
msgid "Get mode of active vt.  I<argp> points to a"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_console.2:571
#, no-wrap
msgid ""
"struct vt_mode {\n"
"    char  mode;    /* vt mode */\n"
"    char  waitv;   /* if set, hang on writes if not active */\n"
"    short relsig;  /* signal to raise on release req */\n"
"    short acqsig;  /* signal to raise on acquisition */\n"
"    short frsig;   /* unused (set to 0) */\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_console.2:577
msgid ""
"which is set to the mode of the active vt.  I<mode> is set to one of these "
"values:"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_console.2:579
#, no-wrap
msgid "VT_AUTO"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_console.2:579
#, no-wrap
msgid "auto vt switching"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_console.2:580
#, no-wrap
msgid "VT_PROCESS"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_console.2:580
#, no-wrap
msgid "process controls switching"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_console.2:581
#, no-wrap
msgid "VT_ACKACQ"
msgstr ""

#. type: tbl table
#: man-pages/man2/ioctl_console.2:581
#, no-wrap
msgid "acknowledge switch"
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_console.2:583
#, no-wrap
msgid "B<VT_SETMODE>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_console.2:589
msgid "Set mode of active vt.  I<argp> points to a I<struct vt_mode>."
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_console.2:589
#, no-wrap
msgid "B<VT_GETSTATE>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_console.2:594
msgid "Get global vt state info.  I<argp> points to a"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_console.2:602
#, no-wrap
msgid ""
"struct vt_stat {\n"
"    unsigned short v_active;  /* active vt */\n"
"    unsigned short v_signal;  /* signal to send */\n"
"    unsigned short v_state;   /* vt bit mask */\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_console.2:609
msgid ""
"For each vt in use, the corresponding bit in the I<v_state> member is set.  "
"(Kernels 1.0 through 1.1.92.)"
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_console.2:609
#, no-wrap
msgid "B<VT_RELDISP>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_console.2:612
msgid "Release a display."
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_console.2:612
#, no-wrap
msgid "B<VT_ACTIVATE>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_console.2:619
msgid "Switch to vt I<argp> (1 E<lt>= I<argp> E<lt>= MAX_NR_CONSOLES)."
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_console.2:619
#, no-wrap
msgid "B<VT_WAITACTIVE>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_console.2:624
msgid "Wait until vt I<argp> has been activated."
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_console.2:624
#, no-wrap
msgid "B<VT_DISALLOCATE>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_console.2:629
msgid "Deallocate the memory associated with vt I<argp>.  (Since Linux 1.1.54.)"
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_console.2:629
#, no-wrap
msgid "B<VT_RESIZE>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_console.2:634
msgid "Set the kernel's idea of screensize.  I<argp> points to a"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_console.2:642
#, no-wrap
msgid ""
"struct vt_sizes {\n"
"    unsigned short v_rows;       /* # rows */\n"
"    unsigned short v_cols;       /* # columns */\n"
"    unsigned short v_scrollsize; /* no longer used */\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_console.2:649
msgid ""
"Note that this does not change the videomode.  See B<resizecons>(8).  (Since "
"Linux 1.1.54.)"
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_console.2:649
#, no-wrap
msgid "B<VT_RESIZEX>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_console.2:654
msgid "Set the kernel's idea of various screen parameters.  I<argp> points to a"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_console.2:669
#, no-wrap
msgid ""
"struct vt_consize {\n"
"    unsigned short v_rows;  /* number of rows */\n"
"    unsigned short v_cols;  /* number of columns */\n"
"    unsigned short v_vlin;  /* number of pixel rows\n"
"                               on screen */\n"
"    unsigned short v_clin;  /* number of pixel rows\n"
"                               per character */\n"
"    unsigned short v_vcol;  /* number of pixel columns\n"
"                               on screen */\n"
"    unsigned short v_ccol;  /* number of pixel columns\n"
"                               per character */\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_console.2:678
msgid ""
"Any parameter may be set to zero, indicating \"no change\", but if multiple "
"parameters are set, they must be self-consistent.  Note that this does not "
"change the videomode.  See B<resizecons>(8).  (Since Linux 1.3.3.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_console.2:685
msgid ""
"The action of the following ioctls depends on the first byte in the struct "
"pointed to by I<argp>, referred to here as the I<subcode>.  These are legal "
"only for the superuser or the owner of the current terminal."
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_console.2:685
#, no-wrap
msgid "B<TIOCLINUX, subcode=0>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_console.2:693
msgid ""
"Dump the screen.  Disappeared in Linux 1.1.92.  (With kernel 1.1.92 or "
"later, read from I</dev/vcsN> or I</dev/vcsaN> instead.)"
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_console.2:693
#, no-wrap
msgid "B<TIOCLINUX, subcode=1>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_console.2:697
msgid "Get task information.  Disappeared in Linux 1.1.92."
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_console.2:697
#, no-wrap
msgid "B<TIOCLINUX, subcode=2>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_console.2:702
msgid "Set selection.  I<argp> points to a"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_console.2:710
#, no-wrap
msgid ""
"struct {\n"
"    char  subcode;\n"
"    short xs, ys, xe, ye;\n"
"    short sel_mode;\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_console.2:730
msgid ""
"I<xs> and I<ys> are the starting column and row.  I<xe> and I<ye> are the "
"ending column and row.  (Upper left corner is row=column=1.)  I<sel_mode> is "
"0 for character-by-character selection, 1 for word-by-word selection, or 2 "
"for line-by-line selection.  The indicated screen characters are highlighted "
"and saved in the static array sel_buffer in I<devices/char/console.c>."
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_console.2:730
#, no-wrap
msgid "B<TIOCLINUX, subcode=3>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_console.2:736
msgid ""
"Paste selection.  The characters in the selection buffer are written to "
"I<fd>."
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_console.2:736
#, no-wrap
msgid "B<TIOCLINUX, subcode=4>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_console.2:739
msgid "Unblank the screen."
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_console.2:739
#, no-wrap
msgid "B<TIOCLINUX, subcode=5>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_console.2:744
msgid ""
"Sets contents of a 256-bit look up table defining characters in a \"word\", "
"for word-by-word selection.  (Since Linux 1.1.32.)"
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_console.2:744
#, no-wrap
msgid "B<TIOCLINUX, subcode=6>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_console.2:751
msgid ""
"I<argp> points to a char which is set to the value of the kernel variable "
"I<shift_state>.  (Since Linux 1.1.32.)"
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_console.2:751
#, no-wrap
msgid "B<TIOCLINUX, subcode=7>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_console.2:758
msgid ""
"I<argp> points to a char which is set to the value of the kernel variable "
"I<report_mouse>.  (Since Linux 1.1.33.)"
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_console.2:758
#, no-wrap
msgid "B<TIOCLINUX, subcode=8>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_console.2:766
msgid ""
"Dump screen width and height, cursor position, and all the "
"character-attribute pairs.  (Kernels 1.1.67 through 1.1.91 only.  With "
"kernel 1.1.92 or later, read from I</dev/vcsa*> instead.)"
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_console.2:766
#, no-wrap
msgid "B<TIOCLINUX, subcode=9>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_console.2:774
msgid ""
"Restore screen width and height, cursor position, and all the "
"character-attribute pairs.  (Kernels 1.1.67 through 1.1.91 only.  With "
"kernel 1.1.92 or later, write to I</dev/vcsa*> instead.)"
msgstr ""

#. type: TP
#: man-pages/man2/ioctl_console.2:774
#, no-wrap
msgid "B<TIOCLINUX, subcode=10>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_console.2:782
msgid ""
"Handles the Power Saving feature of the new generation of monitors.  VESA "
"screen blanking mode is set to I<argp[1]>, which governs what screen "
"blanking does:"
msgstr ""

#. type: IP
#: man-pages/man2/ioctl_console.2:783
#, no-wrap
msgid "0:"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_console.2:785
msgid "Screen blanking is disabled."
msgstr ""

#. type: IP
#: man-pages/man2/ioctl_console.2:785
#, no-wrap
msgid "1:"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_console.2:792
msgid ""
"The current video adapter register settings are saved, then the controller "
"is programmed to turn off the vertical synchronization pulses.  This puts "
"the monitor into \"standby\" mode.  If your monitor has an Off_Mode timer, "
"then it will eventually power down by itself."
msgstr ""

#. type: IP
#: man-pages/man2/ioctl_console.2:792
#, no-wrap
msgid "2:"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_console.2:802
msgid ""
"The current settings are saved, then both the vertical and horizontal "
"synchronization pulses are turned off.  This puts the monitor into \"off\" "
"mode.  If your monitor has no Off_Mode timer, or if you want your monitor to "
"power down immediately when the blank_timer times out, then you choose this "
"option.  (I<Caution:> Powering down frequently will damage the monitor.)  "
"(Since Linux 1.1.76.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_console.2:808
msgid "On success, 0 is returned.  On error, -1 is returned, and I<errno> is set."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_console.2:811
msgid "I<errno> may take on these values:"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_console.2:814
msgid "The file descriptor is invalid."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_console.2:819
msgid "The file descriptor or I<argp> is invalid."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_console.2:823
msgid ""
"The file descriptor is not associated with a character special device, or "
"the specified request does not apply to it."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_console.2:837
msgid ""
"B<Warning>: Do not regard this man page as documentation of the Linux "
"console ioctls.  This is provided for the curious only, as an alternative to "
"reading the source.  Ioctl's are undocumented Linux internals, liable to be "
"changed without warning.  (And indeed, this page more or less describes the "
"situation as of kernel version 1.1.94; there are many minor and not-so-minor "
"differences with earlier versions.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_console.2:842
msgid ""
"Very often, ioctls are introduced for communication between the kernel and "
"one particular well-known program (fdisk, hdparm, setserial, tunelp, "
"loadkeys, selection, setfont, etc.), and their behavior will be changed when "
"required by this particular program."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_console.2:846
msgid ""
"Programs using these ioctls will not be portable to other versions of UNIX, "
"will not work on older versions of Linux, and will not work on future "
"versions of Linux."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_console.2:848
msgid "Use POSIX functions."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_console.2:871
msgid ""
"B<dumpkeys>(1), B<kbd_mode>(1), B<loadkeys>(1), B<mknod>(1), B<setleds>(1), "
"B<setmetamode>(1), B<execve>(2), B<fcntl>(2), B<ioctl_tty>(2), B<ioperm>(2), "
"B<termios>(3), B<console_codes>(4), B<mt>(4), B<sd>(4), B<tty>(4), "
"B<ttyS>(4), B<vcs>(4), B<vcsa>(4), B<charsets>(7), B<mapscrn>(8), "
"B<resizecons>(8), B<setfont>(8)"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioctl_console.2:873
msgid "I</usr/include/linux/kd.h>, I</usr/include/linux/vt.h>"
msgstr ""

#. type: TH
#: man-pages/man2/getpagesize.2:25
#, no-wrap
msgid "GETPAGESIZE"
msgstr ""

#. type: Plain text
#: man-pages/man2/getpagesize.2:28
msgid "getpagesize - get memory page size"
msgstr ""

#. type: Plain text
#: man-pages/man2/getpagesize.2:32
msgid "B<int getpagesize(void);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/getpagesize.2:39
msgid "B<getpagesize>():"
msgstr ""

#. type: Plain text
#: man-pages/man2/getpagesize.2:46
#, no-wrap
msgid "_DEFAULT_SOURCE || ! (_POSIX_C_SOURCE\\ E<gt>=\\ 200112L)\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/getpagesize.2:51
#, no-wrap
msgid "_BSD_SOURCE || ! (_POSIX_C_SOURCE\\ E<gt>=\\ 200112L)\n"
msgstr ""

#.      || _XOPEN_SOURCE\ &&\ _XOPEN_SOURCE_EXTENDED
#. type: Plain text
#: man-pages/man2/getpagesize.2:56 man-pages/man2/vfork.2:59
msgid "Before glibc 2.12: _BSD_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 500"
msgstr ""

#.  .SH HISTORY
#.  This call first appeared in 4.2BSD.
#. type: Plain text
#: man-pages/man2/getpagesize.2:68
msgid ""
"The function B<getpagesize>()  returns the number of bytes in a memory page, "
"where \"page\" is a fixed-length block, the unit for memory allocation and "
"file mapping performed by B<mmap>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/getpagesize.2:75
msgid ""
"SVr4, 4.4BSD, SUSv2.  In SUSv2 the B<getpagesize>()  call is labeled LEGACY, "
"and in POSIX.1-2001 it has been dropped; HP-UX does not have this call."
msgstr ""

#. type: Plain text
#: man-pages/man2/getpagesize.2:80
msgid ""
"Portable applications should employ I<sysconf(_SC_PAGESIZE)> instead of "
"B<getpagesize>():"
msgstr ""

#. type: Plain text
#: man-pages/man2/getpagesize.2:85
#, no-wrap
msgid ""
"#include E<lt>unistd.hE<gt>\n"
"long sz = sysconf(_SC_PAGESIZE);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/getpagesize.2:92
msgid "(Most systems allow the synonym B<_SC_PAGE_SIZE> for B<_SC_PAGESIZE>.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/getpagesize.2:112
msgid ""
"Whether B<getpagesize>()  is present as a Linux system call depends on the "
"architecture.  If it is, it returns the kernel symbol B<PAGE_SIZE>, whose "
"value depends on the architecture and machine model.  Generally, one uses "
"binaries that are dependent on the architecture but not on the machine "
"model, in order to have a single binary distribution per architecture.  This "
"means that a user program should not find B<PAGE_SIZE> at compile time from "
"a header file, but use an actual system call, at least for those "
"architectures (like sun4) where this dependency exists.  Here glibc 2.0 "
"fails because its B<getpagesize>()  returns a statically derived value, and "
"does not use a system call.  Things are OK in glibc 2.1."
msgstr ""

#. type: Plain text
#: man-pages/man2/getpagesize.2:114
msgid "B<mmap>(2), B<sysconf>(3)"
msgstr ""

#. type: TH
#: man-pages/man2/s390_runtime_instr.2:25
#, no-wrap
msgid "S390_RUNTIME_INSTR"
msgstr ""

#. type: Plain text
#: man-pages/man2/s390_runtime_instr.2:28
msgid "s390_runtime_instr - enable/disable s390 CPU run-time instrumentation"
msgstr ""

#. type: Plain text
#: man-pages/man2/s390_runtime_instr.2:31
#, no-wrap
msgid "B<#include E<lt>asm/runtime_instr.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/s390_runtime_instr.2:33
#, no-wrap
msgid "B<int s390_runtime_instr(int >I<command>B<, int >I<signum>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/s390_runtime_instr.2:39
msgid ""
"The B<s390_runtime_instr>()  system call starts or stops CPU run-time "
"instrumentation for the calling thread."
msgstr ""

#. type: Plain text
#: man-pages/man2/s390_runtime_instr.2:47
msgid ""
"The I<command> argument controls whether run-time instrumentation is started "
"(B<S390_RUNTIME_INSTR_START>, 1) or stopped (B<S390_RUNTIME_INSTR_STOP>, 2) "
"for the calling thread."
msgstr ""

#. type: Plain text
#: man-pages/man2/s390_runtime_instr.2:54
msgid ""
"The I<signum> argument specifies the number of a real-time signal.  The "
"real-time signal is sent to the thread if the run-time instrumentation "
"buffer is full or if the run-time-instrumentation-halted interrupt occurred."
msgstr ""

#. type: Plain text
#: man-pages/man2/s390_runtime_instr.2:65
msgid ""
"On success, B<s390_runtime_instr>()  returns 0 and enables the thread for "
"run-time instrumentation by assigning the thread a default run-time "
"instrumentation control block.  The caller can then read and modify the "
"control block and start the run-time instrumentation.  On error, -1 is "
"returned and I<errno> is set to one of the error codes listed below."
msgstr ""

#. type: Plain text
#: man-pages/man2/s390_runtime_instr.2:73
msgid ""
"The value specified in I<command> is not a valid command or the value "
"specified in I<signum> is not a real-time signal number."
msgstr ""

#. type: Plain text
#: man-pages/man2/s390_runtime_instr.2:76
msgid "Allocating memory for the run-time instrumentation control block failed."
msgstr ""

#. type: Plain text
#: man-pages/man2/s390_runtime_instr.2:79
msgid "The run-time instrumentation facility is not available."
msgstr ""

#. type: Plain text
#: man-pages/man2/s390_runtime_instr.2:81
msgid "This system call is available since Linux 3.7."
msgstr ""

#. type: Plain text
#: man-pages/man2/s390_runtime_instr.2:84
msgid ""
"This Linux-specific system call is available only on the s390 architecture.  "
"The run-time instrumentation facility is available beginning with System z "
"EC12."
msgstr ""

#.  commit df2f815a7df7edb5335a3bdeee6a8f9f6f9c35c4
#. type: Plain text
#: man-pages/man2/s390_runtime_instr.2:94
msgid "The I<asm/runtime_instr.h> header file is available since Linux 4.16."
msgstr ""

#. type: Plain text
#: man-pages/man2/s390_runtime_instr.2:96
msgid "B<syscall>(2), B<signal>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/wait.2:49
#, no-wrap
msgid "WAIT"
msgstr ""

#. type: Plain text
#: man-pages/man2/wait.2:52
msgid "wait, waitpid, waitid - wait for process to change state"
msgstr ""

#. type: Plain text
#: man-pages/man2/wait.2:56
msgid "B<#include E<lt>sys/wait.hE<gt>>"
msgstr ""

#. type: Plain text
#: man-pages/man2/wait.2:58
msgid "B<pid_t wait(int *>I<wstatus>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/wait.2:60
msgid "B<pid_t waitpid(pid_t >I<pid>B<, int *>I<wstatus>B<, int >I<options>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/wait.2:65
#, no-wrap
msgid ""
"B<int waitid(idtype_t >I<idtype>B<, id_t >I<id>B<, siginfo_t *>I<infop>B<, "
"int >I<options>B<);>\n"
"                /* This is the glibc and POSIX interface; see\n"
"                   NOTES for information on the raw system call. */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/wait.2:74
msgid "B<waitid>():"
msgstr ""

#.     (_XOPEN_SOURCE && _XOPEN_SOURCE_EXTENDED)
#. type: Plain text
#: man-pages/man2/wait.2:79
#, no-wrap
msgid ""
"Since glibc 2.26:\n"
"_XOPEN_SOURCE E<gt>= 500 ||\n"
"    _POSIX_C_SOURCE\\ E<gt>=\\ 200809L\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/wait.2:84
#, no-wrap
msgid ""
"Glibc 2.25 and earlier:\n"
"    _XOPEN_SOURCE\n"
"        || /* Since glibc 2.12: */ _POSIX_C_SOURCE\\ E<gt>=\\ 200809L\n"
"        || /* Glibc versions E<lt>= 2.19: */ _BSD_SOURCE\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/wait.2:97
msgid ""
"All of these system calls are used to wait for state changes in a child of "
"the calling process, and obtain information about the child whose state has "
"changed.  A state change is considered to be: the child terminated; the "
"child was stopped by a signal; or the child was resumed by a signal.  In the "
"case of a terminated child, performing a wait allows the system to release "
"the resources associated with the child; if a wait is not performed, then "
"the terminated child remains in a \"zombie\" state (see NOTES below)."
msgstr ""

#. type: Plain text
#: man-pages/man2/wait.2:109
msgid ""
"If a child has already changed state, then these calls return immediately.  "
"Otherwise, they block until either a child changes state or a signal handler "
"interrupts the call (assuming that system calls are not automatically "
"restarted using the B<SA_RESTART> flag of B<sigaction>(2)).  In the "
"remainder of this page, a child whose state has changed and which has not "
"yet been waited upon by one of these system calls is termed I<waitable>."
msgstr ""

#. type: SS
#: man-pages/man2/wait.2:109
#, no-wrap
msgid "wait() and waitpid()"
msgstr ""

#. type: Plain text
#: man-pages/man2/wait.2:117
msgid ""
"The B<wait>()  system call suspends execution of the calling thread until "
"one of its children terminates.  The call I<wait(&wstatus)> is equivalent "
"to:"
msgstr ""

#. type: Plain text
#: man-pages/man2/wait.2:121
#, no-wrap
msgid "waitpid(-1, &wstatus, 0);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/wait.2:136
msgid ""
"The B<waitpid>()  system call suspends execution of the calling thread until "
"a child specified by I<pid> argument has changed state.  By default, "
"B<waitpid>()  waits only for terminated children, but this behavior is "
"modifiable via the I<options> argument, as described below."
msgstr ""

#. type: Plain text
#: man-pages/man2/wait.2:140
msgid "The value of I<pid> can be:"
msgstr ""

#. type: IP
#: man-pages/man2/wait.2:140
#, no-wrap
msgid "E<lt> -1"
msgstr ""

#. type: Plain text
#: man-pages/man2/wait.2:144
msgid ""
"meaning wait for any child process whose process group ID is equal to the "
"absolute value of I<pid>."
msgstr ""

#. type: Plain text
#: man-pages/man2/wait.2:146
msgid "meaning wait for any child process."
msgstr ""

#. type: Plain text
#: man-pages/man2/wait.2:149
msgid ""
"meaning wait for any child process whose process group ID is equal to that "
"of the calling process."
msgstr ""

#. type: IP
#: man-pages/man2/wait.2:149
#, no-wrap
msgid "E<gt> 0"
msgstr ""

#. type: Plain text
#: man-pages/man2/wait.2:153
msgid "meaning wait for the child whose process ID is equal to the value of I<pid>."
msgstr ""

#. type: Plain text
#: man-pages/man2/wait.2:157
msgid "The value of I<options> is an OR of zero or more of the following constants:"
msgstr ""

#. type: TP
#: man-pages/man2/wait.2:157 man-pages/man2/wait.2:289
#, no-wrap
msgid "B<WNOHANG>"
msgstr ""

#. type: Plain text
#: man-pages/man2/wait.2:160
msgid "return immediately if no child has exited."
msgstr ""

#. type: TP
#: man-pages/man2/wait.2:160
#, no-wrap
msgid "B<WUNTRACED>"
msgstr ""

#. type: Plain text
#: man-pages/man2/wait.2:169
msgid ""
"also return if a child has stopped (but not traced via B<ptrace>(2)).  "
"Status for I<traced> children which have stopped is provided even if this "
"option is not specified."
msgstr ""

#. type: TP
#: man-pages/man2/wait.2:169
#, no-wrap
msgid "B<WCONTINUED> (since Linux 2.6.10)"
msgstr ""

#. type: Plain text
#: man-pages/man2/wait.2:173
msgid "also return if a stopped child has been resumed by delivery of B<SIGCONT>."
msgstr ""

#. type: Plain text
#: man-pages/man2/wait.2:175
msgid "(For Linux-only options, see below.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/wait.2:189
msgid ""
"If I<wstatus> is not NULL, B<wait>()  and B<waitpid>()  store status "
"information in the I<int> to which it points.  This integer can be inspected "
"with the following macros (which take the integer itself as an argument, not "
"a pointer to it, as is done in B<wait>()  and B<waitpid>()!):"
msgstr ""

#. type: TP
#: man-pages/man2/wait.2:189
#, no-wrap
msgid "B<WIFEXITED(>I<wstatus>B<)>"
msgstr ""

#. type: Plain text
#: man-pages/man2/wait.2:197
msgid ""
"returns true if the child terminated normally, that is, by calling "
"B<exit>(3)  or B<_exit>(2), or by returning from main()."
msgstr ""

#. type: TP
#: man-pages/man2/wait.2:197
#, no-wrap
msgid "B<WEXITSTATUS(>I<wstatus>B<)>"
msgstr ""

#. type: Plain text
#: man-pages/man2/wait.2:210
msgid ""
"returns the exit status of the child.  This consists of the least "
"significant 8 bits of the I<status> argument that the child specified in a "
"call to B<exit>(3)  or B<_exit>(2)  or as the argument for a return "
"statement in main().  This macro should be employed only if B<WIFEXITED> "
"returned true."
msgstr ""

#. type: TP
#: man-pages/man2/wait.2:210
#, no-wrap
msgid "B<WIFSIGNALED(>I<wstatus>B<)>"
msgstr ""

#. type: Plain text
#: man-pages/man2/wait.2:213
msgid "returns true if the child process was terminated by a signal."
msgstr ""

#. type: TP
#: man-pages/man2/wait.2:213
#, no-wrap
msgid "B<WTERMSIG(>I<wstatus>B<)>"
msgstr ""

#. type: Plain text
#: man-pages/man2/wait.2:220
msgid ""
"returns the number of the signal that caused the child process to "
"terminate.  This macro should be employed only if B<WIFSIGNALED> returned "
"true."
msgstr ""

#. type: TP
#: man-pages/man2/wait.2:220
#, no-wrap
msgid "B<WCOREDUMP(>I<wstatus>B<)>"
msgstr ""

#. type: Plain text
#: man-pages/man2/wait.2:227
msgid ""
"returns true if the child produced a core dump (see B<core>(5)).  This macro "
"should be employed only if B<WIFSIGNALED> returned true."
msgstr ""

#. type: Plain text
#: man-pages/man2/wait.2:232
msgid ""
"This macro is not specified in POSIX.1-2001 and is not available on some "
"UNIX implementations (e.g., AIX, SunOS).  Therefore, enclose its use inside "
"I<#ifdef WCOREDUMP ... #endif>."
msgstr ""

#. type: TP
#: man-pages/man2/wait.2:232
#, no-wrap
msgid "B<WIFSTOPPED(>I<wstatus>B<)>"
msgstr ""

#. type: Plain text
#: man-pages/man2/wait.2:239
msgid ""
"returns true if the child process was stopped by delivery of a signal; this "
"is possible only if the call was done using B<WUNTRACED> or when the child "
"is being traced (see B<ptrace>(2))."
msgstr ""

#. type: TP
#: man-pages/man2/wait.2:239
#, no-wrap
msgid "B<WSTOPSIG(>I<wstatus>B<)>"
msgstr ""

#. type: Plain text
#: man-pages/man2/wait.2:245
msgid ""
"returns the number of the signal which caused the child to stop.  This macro "
"should be employed only if B<WIFSTOPPED> returned true."
msgstr ""

#. type: TP
#: man-pages/man2/wait.2:245
#, no-wrap
msgid "B<WIFCONTINUED(>I<wstatus>B<)>"
msgstr ""

#. type: Plain text
#: man-pages/man2/wait.2:250
msgid ""
"(since Linux 2.6.10)  returns true if the child process was resumed by "
"delivery of B<SIGCONT>."
msgstr ""

#. type: SS
#: man-pages/man2/wait.2:250
#, no-wrap
msgid "waitid()"
msgstr ""

#. type: Plain text
#: man-pages/man2/wait.2:255
msgid ""
"The B<waitid>()  system call (available since Linux 2.6.9) provides more "
"precise control over which child state changes to wait for."
msgstr ""

#. type: Plain text
#: man-pages/man2/wait.2:261
msgid ""
"The I<idtype> and I<id> arguments select the child(ren) to wait for, as "
"follows:"
msgstr ""

#. type: IP
#: man-pages/man2/wait.2:261
#, no-wrap
msgid "I<idtype> == B<P_PID>"
msgstr ""

#. type: Plain text
#: man-pages/man2/wait.2:264
msgid "Wait for the child whose process ID matches I<id>."
msgstr ""

#. type: IP
#: man-pages/man2/wait.2:264
#, no-wrap
msgid "I<idtype> == B<P_PGID>"
msgstr ""

#. type: Plain text
#: man-pages/man2/wait.2:267
msgid "Wait for any child whose process group ID matches I<id>."
msgstr ""

#. type: IP
#: man-pages/man2/wait.2:267
#, no-wrap
msgid "I<idtype> == B<P_ALL>"
msgstr ""

#. type: Plain text
#: man-pages/man2/wait.2:271
msgid "Wait for any child; I<id> is ignored."
msgstr ""

#. type: Plain text
#: man-pages/man2/wait.2:275
msgid ""
"The child state changes to wait for are specified by ORing one or more of "
"the following flags in I<options>:"
msgstr ""

#. type: TP
#: man-pages/man2/wait.2:275
#, no-wrap
msgid "B<WEXITED>"
msgstr ""

#. type: Plain text
#: man-pages/man2/wait.2:278
msgid "Wait for children that have terminated."
msgstr ""

#. type: TP
#: man-pages/man2/wait.2:278
#, no-wrap
msgid "B<WSTOPPED>"
msgstr ""

#. type: Plain text
#: man-pages/man2/wait.2:281
msgid "Wait for children that have been stopped by delivery of a signal."
msgstr ""

#. type: TP
#: man-pages/man2/wait.2:281
#, no-wrap
msgid "B<WCONTINUED>"
msgstr ""

#. type: Plain text
#: man-pages/man2/wait.2:286
msgid ""
"Wait for (previously stopped) children that have been resumed by delivery of "
"B<SIGCONT>."
msgstr ""

#. type: Plain text
#: man-pages/man2/wait.2:289
msgid "The following flags may additionally be ORed in I<options>:"
msgstr ""

#. type: Plain text
#: man-pages/man2/wait.2:293
msgid "As for B<waitpid>()."
msgstr ""

#. type: TP
#: man-pages/man2/wait.2:293
#, no-wrap
msgid "B<WNOWAIT>"
msgstr ""

#. type: Plain text
#: man-pages/man2/wait.2:297
msgid ""
"Leave the child in a waitable state; a later wait call can be used to again "
"retrieve the child status information."
msgstr ""

#. type: Plain text
#: man-pages/man2/wait.2:304
msgid ""
"Upon successful return, B<waitid>()  fills in the following fields of the "
"I<siginfo_t> structure pointed to by I<infop>:"
msgstr ""

#. type: Plain text
#: man-pages/man2/wait.2:307
msgid "The process ID of the child."
msgstr ""

#. type: Plain text
#: man-pages/man2/wait.2:311
msgid ""
"The real user ID of the child.  (This field is not set on most other "
"implementations.)"
msgstr ""

#. type: TP
#: man-pages/man2/wait.2:311
#, no-wrap
msgid "I<si_signo>"
msgstr ""

#. type: Plain text
#: man-pages/man2/wait.2:315
msgid "Always set to B<SIGCHLD>."
msgstr ""

#. type: TP
#: man-pages/man2/wait.2:315
#, no-wrap
msgid "I<si_status>"
msgstr ""

#. type: Plain text
#: man-pages/man2/wait.2:325
msgid ""
"Either the exit status of the child, as given to B<_exit>(2)  (or "
"B<exit>(3)), or the signal that caused the child to terminate, stop, or "
"continue.  The I<si_code> field can be used to determine how to interpret "
"this field."
msgstr ""

#. type: Plain text
#: man-pages/man2/wait.2:342
msgid ""
"Set to one of: B<CLD_EXITED> (child called B<_exit>(2)); B<CLD_KILLED> "
"(child killed by signal); B<CLD_DUMPED> (child killed by signal, and dumped "
"core); B<CLD_STOPPED> (child stopped by signal); B<CLD_TRAPPED> (traced "
"child has trapped); or B<CLD_CONTINUED> (child continued by B<SIGCONT>)."
msgstr ""

#. type: Plain text
#: man-pages/man2/wait.2:360
msgid ""
"If B<WNOHANG> was specified in I<options> and there were no children in a "
"waitable state, then B<waitid>()  returns 0 immediately and the state of the "
"I<siginfo_t> structure pointed to by I<infop> depends on the "
"implementation.  To (portably) distinguish this case from that where a child "
"was in a waitable state, zero out the I<si_pid> field before the call and "
"check for a nonzero value in this field after the call returns."
msgstr ""

#.  POSIX.1-2001 leaves this possibility unspecified; most
#.  implementations (including Linux) zero out the structure
#.  in this case, but at least one implementation (AIX 5.1)
#.  does not -- MTK Nov 04
#. type: Plain text
#: man-pages/man2/wait.2:383
msgid ""
"POSIX.1-2008 Technical Corrigendum 1 (2013) adds the requirement that when "
"B<WNOHANG> is specified in I<options> and there were no children in a "
"waitable state, then B<waitid>()  should zero out the I<si_pid> and "
"I<si_signo> fields of the structure.  On Linux and other implementations "
"that adhere to this requirement, it is not necessary to zero out the "
"I<si_pid> field before calling B<waitid>().  However, not all "
"implementations follow the POSIX.1 specification on this point."
msgstr ""

#. type: Plain text
#: man-pages/man2/wait.2:387
msgid ""
"B<wait>(): on success, returns the process ID of the terminated child; on "
"error, -1 is returned."
msgstr ""

#. type: Plain text
#: man-pages/man2/wait.2:396
msgid ""
"B<waitpid>(): on success, returns the process ID of the child whose state "
"has changed; if B<WNOHANG> was specified and one or more child(ren) "
"specified by I<pid> exist, but have not yet changed state, then 0 is "
"returned.  On error, -1 is returned."
msgstr ""

#.  FIXME As reported by Vegard Nossum, if infop is NULL, then waitid()
#.  returns the PID of the child.  Either this is a bug, or it is intended
#.  behavior that needs to be documented.  See my Jan 2009 LKML mail
#.  "waitid() return value strangeness when infop is NULL".
#. type: Plain text
#: man-pages/man2/wait.2:409
msgid ""
"B<waitid>(): returns 0 on success or if B<WNOHANG> was specified and no "
"child(ren) specified by I<id> has yet changed state; on error, -1 is "
"returned."
msgstr ""

#. type: Plain text
#: man-pages/man2/wait.2:413
msgid ""
"Each of these calls sets I<errno> to an appropriate value in the case of an "
"error."
msgstr ""

#. type: TP
#: man-pages/man2/wait.2:414 man-pages/man2/wait.2:419
#, no-wrap
msgid "B<ECHILD>"
msgstr ""

#. type: Plain text
#: man-pages/man2/wait.2:419
msgid ""
"(for B<wait>())  The calling process does not have any unwaited-for "
"children."
msgstr ""

#. type: Plain text
#: man-pages/man2/wait.2:439
msgid ""
"(for B<waitpid>()  or B<waitid>())  The process specified by I<pid> "
"(B<waitpid>())  or I<idtype> and I<id> (B<waitid>())  does not exist or is "
"not a child of the calling process.  (This can happen for one's own child if "
"the action for B<SIGCHLD> is set to B<SIG_IGN>.  See also the I<Linux Notes> "
"section about threads.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/wait.2:446
msgid ""
"B<WNOHANG> was not set and an unblocked signal or a B<SIGCHLD> was caught; "
"see B<signal>(7)."
msgstr ""

#. type: Plain text
#: man-pages/man2/wait.2:451
msgid "The I<options> argument was invalid."
msgstr ""

#. type: Plain text
#: man-pages/man2/wait.2:471
msgid ""
"A child that terminates, but has not been waited for becomes a \"zombie\".  "
"The kernel maintains a minimal set of information about the zombie process "
"(PID, termination status, resource usage information)  in order to allow the "
"parent to later perform a wait to obtain information about the child.  As "
"long as a zombie is not removed from the system via a wait, it will consume "
"a slot in the kernel process table, and if this table fills, it will not be "
"possible to create further processes.  If a parent process terminates, then "
"its \"zombie\" children (if any)  are adopted by B<init>(1), (or by the "
"nearest \"subreaper\" process as defined through the use of the B<prctl>(2)  "
"B<PR_SET_CHILD_SUBREAPER> operation); B<init>(1)  automatically performs a "
"wait to remove the zombies."
msgstr ""

#. type: Plain text
#: man-pages/man2/wait.2:500
msgid ""
"POSIX.1-2001 specifies that if the disposition of B<SIGCHLD> is set to "
"B<SIG_IGN> or the B<SA_NOCLDWAIT> flag is set for B<SIGCHLD> (see "
"B<sigaction>(2)), then children that terminate do not become zombies and a "
"call to B<wait>()  or B<waitpid>()  will block until all children have "
"terminated, and then fail with I<errno> set to B<ECHILD>.  (The original "
"POSIX standard left the behavior of setting B<SIGCHLD> to B<SIG_IGN> "
"unspecified.  Note that even though the default disposition of B<SIGCHLD> is "
"\"ignore\", explicitly setting the disposition to B<SIG_IGN> results in "
"different treatment of zombie process children.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/wait.2:513
msgid ""
"Linux 2.6 conforms to the POSIX requirements.  However, Linux 2.4 (and "
"earlier) does not: if a B<wait>()  or B<waitpid>()  call is made while "
"B<SIGCHLD> is being ignored, the call behaves just as though B<SIGCHLD> were "
"not being ignored, that is, the call blocks until the next child terminates "
"and then returns the process ID and status of that child."
msgstr ""

#. type: Plain text
#: man-pages/man2/wait.2:529
msgid ""
"In the Linux kernel, a kernel-scheduled thread is not a distinct construct "
"from a process.  Instead, a thread is simply a process that is created using "
"the Linux-unique B<clone>(2)  system call; other routines such as the "
"portable B<pthread_create>(3)  call are implemented using B<clone>(2).  "
"Before Linux 2.4, a thread was just a special case of a process, and as a "
"consequence one thread could not wait on the children of another thread, "
"even when the latter belongs to the same thread group.  However, POSIX "
"prescribes such functionality, and since Linux 2.4 a thread can, and by "
"default will, wait on children of other threads in the same thread group."
msgstr ""

#.  commit 91c4e8ea8f05916df0c8a6f383508ac7c9e10dba
#. type: Plain text
#: man-pages/man2/wait.2:538
msgid ""
"The following Linux-specific I<options> are for use with children created "
"using B<clone>(2); they can also, since Linux 4.7, be used with B<waitid>():"
msgstr ""

#. type: TP
#: man-pages/man2/wait.2:538
#, no-wrap
msgid "B<__WCLONE>"
msgstr ""

#.  since 0.99pl10
#. type: Plain text
#: man-pages/man2/wait.2:549
msgid ""
"Wait for \"clone\" children only.  If omitted, then wait for \"non-clone\" "
"children only.  (A \"clone\" child is one which delivers no signal, or a "
"signal other than B<SIGCHLD> to its parent upon termination.)  This option "
"is ignored if B<__WALL> is also specified."
msgstr ""

#. type: TP
#: man-pages/man2/wait.2:549
#, no-wrap
msgid "B<__WALL> (since Linux 2.4)"
msgstr ""

#.  since patch-2.3.48
#. type: Plain text
#: man-pages/man2/wait.2:554
msgid "Wait for all children, regardless of type (\"clone\" or \"non-clone\")."
msgstr ""

#. type: TP
#: man-pages/man2/wait.2:554
#, no-wrap
msgid "B<__WNOTHREAD> (since Linux 2.4)"
msgstr ""

#.  since patch-2.4.0-test8
#. type: Plain text
#: man-pages/man2/wait.2:560
msgid ""
"Do not wait for children of other threads in the same thread group.  This "
"was the default before Linux 2.4."
msgstr ""

#.  commit bf959931ddb88c4e4366e96dd22e68fa0db9527c
#.  prevents cases where an unreapable zombie is created if
#.  /sbin/init doesn't use __WALL.
#. type: Plain text
#: man-pages/man2/wait.2:568
msgid ""
"Since Linux 4.7, the B<__WALL> flag is automatically implied if the child is "
"being ptraced."
msgstr ""

#. type: Plain text
#: man-pages/man2/wait.2:572
msgid ""
"B<wait>()  is actually a library function that (in glibc) is implemented as "
"a call to B<wait4>(2)."
msgstr ""

#.  e.g., i386 has the system call, but not x86-64
#. type: Plain text
#: man-pages/man2/wait.2:580
msgid ""
"On some architectures, there is no B<waitpid>()  system call; instead, this "
"interface is implemented via a C library wrapper function that calls "
"B<wait4>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/wait.2:592
msgid ""
"The raw B<waitid>()  system call takes a fifth argument, of type I<struct "
"rusage\\ *>.  If this argument is non-NULL, then it is used to return "
"resource usage information about the child, in the same manner as "
"B<wait4>(2).  See B<getrusage>(2)  for details."
msgstr ""

#. type: Plain text
#: man-pages/man2/wait.2:607
msgid ""
"According to POSIX.1-2008, an application calling B<waitid>()  must ensure "
"that I<infop> points to a I<siginfo_t> structure (i.e., that it is a "
"non-null pointer).  On Linux, if I<infop> is NULL, B<waitid>()  succeeds, "
"and returns the process ID of the waited-for child.  Applications should "
"avoid relying on this inconsistent, nonstandard, and unnecessary feature."
msgstr ""

#.  fork.2 refers to this example program.
#. type: Plain text
#: man-pages/man2/wait.2:624
msgid ""
"The following program demonstrates the use of B<fork>(2)  and B<waitpid>().  "
"The program creates a child process.  If no command-line argument is "
"supplied to the program, then the child suspends its execution using "
"B<pause>(2), to allow the user to send signals to the child.  Otherwise, if "
"a command-line argument is supplied, then the child exits immediately, using "
"the integer supplied on the command line as the exit status.  The parent "
"process executes a loop that monitors the child using B<waitpid>(), and uses "
"the W*() macros described above to analyze the wait status value."
msgstr ""

#. type: Plain text
#: man-pages/man2/wait.2:640
#, no-wrap
msgid ""
"$B< ./a.out &>\n"
"Child PID is 32360\n"
"[1] 32359\n"
"$B< kill -STOP 32360>\n"
"stopped by signal 19\n"
"$B< kill -CONT 32360>\n"
"continued\n"
"$B< kill -TERM 32360>\n"
"killed by signal 15\n"
"[1]+  Done                    ./a.out\n"
"$\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/wait.2:649
#, no-wrap
msgid ""
"#include E<lt>sys/wait.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/wait.2:655
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    pid_t cpid, w;\n"
"    int wstatus;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/wait.2:667
#, no-wrap
msgid ""
"    if (cpid == 0) {            /* Code executed by child */\n"
"        printf(\"Child PID is %ld\\en\", (long) getpid());\n"
"        if (argc == 1)\n"
"            pause();                    /* Wait for signals */\n"
"        _exit(atoi(argv[1]));\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/wait.2:675
#, no-wrap
msgid ""
"    } else {                    /* Code executed by parent */\n"
"        do {\n"
"            w = waitpid(cpid, &wstatus, WUNTRACED | WCONTINUED);\n"
"            if (w == -1) {\n"
"                perror(\"waitpid\");\n"
"                exit(EXIT_FAILURE);\n"
"            }\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/wait.2:689
#, no-wrap
msgid ""
"            if (WIFEXITED(wstatus)) {\n"
"                printf(\"exited, status=%d\\en\", WEXITSTATUS(wstatus));\n"
"            } else if (WIFSIGNALED(wstatus)) {\n"
"                printf(\"killed by signal %d\\en\", WTERMSIG(wstatus));\n"
"            } else if (WIFSTOPPED(wstatus)) {\n"
"                printf(\"stopped by signal %d\\en\", WSTOPSIG(wstatus));\n"
"            } else if (WIFCONTINUED(wstatus)) {\n"
"                printf(\"continued\\en\");\n"
"            }\n"
"        } while (!WIFEXITED(wstatus) && !WIFSIGNALED(wstatus));\n"
"        exit(EXIT_SUCCESS);\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/wait.2:702
msgid ""
"B<_exit>(2), B<clone>(2), B<fork>(2), B<kill>(2), B<ptrace>(2), "
"B<sigaction>(2), B<signal>(2), B<wait4>(2), B<pthread_create>(3), "
"B<core>(5), B<credentials>(7), B<signal>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/fcntl.2:68
#, no-wrap
msgid "FCNTL"
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:71
msgid "fcntl - manipulate file descriptor"
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:75
#, no-wrap
msgid ""
"B<#include E<lt>unistd.hE<gt>>\n"
"B<#include E<lt>fcntl.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:77
#, no-wrap
msgid "B<int fcntl(int >I<fd>B<, int >I<cmd>B<, ... /* >I<arg>B< */ );>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:84
msgid ""
"B<fcntl>()  performs one of the operations described below on the open file "
"descriptor I<fd>.  The operation is determined by I<cmd>."
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:98
msgid ""
"B<fcntl>()  can take an optional third argument.  Whether or not this "
"argument is required is determined by I<cmd>.  The required argument type is "
"indicated in parentheses after each I<cmd> name (in most cases, the required "
"type is I<int>, and we identify the argument using the name I<arg>), or "
"I<void> is specified if the argument is not required."
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:109
msgid ""
"Certain of the operations below are supported only since a particular Linux "
"kernel version.  The preferred method of checking whether the host kernel "
"supports a particular operation is to invoke B<fcntl>()  with the desired "
"I<cmd> value and then test whether the call failed with B<EINVAL>, "
"indicating that the kernel does not recognize this value."
msgstr ""

#. type: SS
#: man-pages/man2/fcntl.2:109
#, no-wrap
msgid "Duplicating a file descriptor"
msgstr ""

#. type: TP
#: man-pages/man2/fcntl.2:110
#, no-wrap
msgid "B<F_DUPFD> (I<int>)"
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:119
msgid ""
"Duplicate the file descriptor I<fd> using the lowest-numbered available file "
"descriptor greater than or equal to I<arg>.  This is different from "
"B<dup2>(2), which uses exactly the file descriptor specified."
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:121
msgid "On success, the new file descriptor is returned."
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:125
msgid "See B<dup>(2)  for further details."
msgstr ""

#. type: TP
#: man-pages/man2/fcntl.2:125
#, no-wrap
msgid "B<F_DUPFD_CLOEXEC> (I<int>; since Linux 2.6.24)"
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:142
msgid ""
"As for B<F_DUPFD>, but additionally set the close-on-exec flag for the "
"duplicate file descriptor.  Specifying this flag permits a program to avoid "
"an additional B<fcntl>()  B<F_SETFD> operation to set the B<FD_CLOEXEC> "
"flag.  For an explanation of why this flag is useful, see the description of "
"B<O_CLOEXEC> in B<open>(2)."
msgstr ""

#. type: SS
#: man-pages/man2/fcntl.2:142
#, no-wrap
msgid "File descriptor flags"
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:160
msgid ""
"The following commands manipulate the flags associated with a file "
"descriptor.  Currently, only one such flag is defined: B<FD_CLOEXEC>, the "
"close-on-exec flag.  If the B<FD_CLOEXEC> bit is set, the file descriptor "
"will automatically be closed during a successful B<execve>(2).  (If the "
"B<execve>(2)  fails, the file descriptor is left open.)  If the "
"B<FD_CLOEXEC> bit is not set, the file descriptor will remain open across an "
"B<execve>(2)."
msgstr ""

#. type: TP
#: man-pages/man2/fcntl.2:160
#, no-wrap
msgid "B<F_GETFD> (I<void>)"
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:165
msgid ""
"Return (as the function result) the file descriptor flags; I<arg> is "
"ignored."
msgstr ""

#. type: TP
#: man-pages/man2/fcntl.2:165
#, no-wrap
msgid "B<F_SETFD> (I<int>)"
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:169
msgid "Set the file descriptor flags to the value specified by I<arg>."
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:184
msgid ""
"In multithreaded programs, using B<fcntl>()  B<F_SETFD> to set the "
"close-on-exec flag at the same time as another thread performs a B<fork>(2)  "
"plus B<execve>(2)  is vulnerable to a race condition that may "
"unintentionally leak the file descriptor to the program executed in the "
"child process.  See the discussion of the B<O_CLOEXEC> flag in B<open>(2)  "
"for details and a remedy to the problem."
msgstr ""

#. type: SS
#: man-pages/man2/fcntl.2:184
#, no-wrap
msgid "File status flags"
msgstr ""

#.  or
#.  .BR creat (2),
#. type: Plain text
#: man-pages/man2/fcntl.2:199
msgid ""
"Each open file description has certain associated status flags, initialized "
"by B<open>(2)  and possibly modified by B<fcntl>().  Duplicated file "
"descriptors (made with B<dup>(2), B<fcntl>(F_DUPFD), B<fork>(2), etc.) refer "
"to the same open file description, and thus share the same file status "
"flags."
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:202
msgid "The file status flags and their semantics are described in B<open>(2)."
msgstr ""

#. type: TP
#: man-pages/man2/fcntl.2:202
#, no-wrap
msgid "B<F_GETFL> (I<void>)"
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:208
msgid ""
"Return (as the function result)  the file access mode and the file status "
"flags; I<arg> is ignored."
msgstr ""

#. type: TP
#: man-pages/man2/fcntl.2:208
#, no-wrap
msgid "B<F_SETFL> (I<int>)"
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:233
msgid ""
"Set the file status flags to the value specified by I<arg>.  File access "
"mode (B<O_RDONLY>, B<O_WRONLY>, B<O_RDWR>)  and file creation flags (i.e., "
"B<O_CREAT>, B<O_EXCL>, B<O_NOCTTY>, B<O_TRUNC>)  in I<arg> are ignored.  On "
"Linux, this command can change only the B<O_APPEND>, B<O_ASYNC>, "
"B<O_DIRECT>, B<O_NOATIME>, and B<O_NONBLOCK> flags.  It is not possible to "
"change the B<O_DSYNC> and B<O_SYNC> flags; see BUGS, below."
msgstr ""

#. type: SS
#: man-pages/man2/fcntl.2:233
#, no-wrap
msgid "Advisory record locking"
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:238
msgid ""
"Linux implements traditional (\"process-associated\") UNIX record locks, as "
"standardized by POSIX.  For a Linux-specific alternative with better "
"semantics, see the discussion of open file description locks below."
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:249
msgid ""
"B<F_SETLK>, B<F_SETLKW>, and B<F_GETLK> are used to acquire, release, and "
"test for the existence of record locks (also known as byte-range, "
"file-segment, or file-region locks).  The third argument, I<lock>, is a "
"pointer to a structure that has at least the following fields (in "
"unspecified order)."
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:264
#, no-wrap
msgid ""
"struct flock {\n"
"    ...\n"
"    short l_type;    /* Type of lock: F_RDLCK,\n"
"                        F_WRLCK, F_UNLCK */\n"
"    short l_whence;  /* How to interpret l_start:\n"
"                        SEEK_SET, SEEK_CUR, SEEK_END */\n"
"    off_t l_start;   /* Starting offset for lock */\n"
"    off_t l_len;     /* Number of bytes to lock */\n"
"    pid_t l_pid;     /* PID of process blocking our lock\n"
"                        (set by F_GETLK and F_OFD_GETLK) */\n"
"    ...\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:272
msgid ""
"The I<l_whence>, I<l_start>, and I<l_len> fields of this structure specify "
"the range of bytes we wish to lock.  Bytes past the end of the file may be "
"locked, but not bytes before the start of the file."
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:292
msgid ""
"I<l_start> is the starting offset for the lock, and is interpreted relative "
"to either: the start of the file (if I<l_whence> is B<SEEK_SET>); the "
"current file offset (if I<l_whence> is B<SEEK_CUR>); or the end of the file "
"(if I<l_whence> is B<SEEK_END>).  In the final two cases, I<l_start> can be "
"a negative number provided the offset does not lie before the start of the "
"file."
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:307
msgid ""
"I<l_len> specifies the number of bytes to be locked.  If I<l_len> is "
"positive, then the range to be locked covers bytes I<l_start> up to and "
"including I<l_start>+I<l_len>-1.  Specifying 0 for I<l_len> has the special "
"meaning: lock all bytes starting at the location specified by I<l_whence> "
"and I<l_start> through to the end of file, no matter how large the file "
"grows."
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:320
msgid ""
"POSIX.1-2001 allows (but does not require)  an implementation to support a "
"negative I<l_len> value; if I<l_len> is negative, the interval described by "
"I<lock> covers bytes I<l_start>+I<l_len> up to and including I<l_start>-1.  "
"This is supported by Linux since kernel versions 2.4.21 and 2.5.49."
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:339
msgid ""
"The I<l_type> field can be used to place a read (B<F_RDLCK>)  or a write "
"(B<F_WRLCK>)  lock on a file.  Any number of processes may hold a read lock "
"(shared lock)  on a file region, but only one process may hold a write lock "
"(exclusive lock).  An exclusive lock excludes all other locks, both shared "
"and exclusive.  A single process can hold only one type of lock on a file "
"region; if a new lock is applied to an already-locked region, then the "
"existing lock is converted to the new lock type.  (Such conversions may "
"involve splitting, shrinking, or coalescing with an existing lock if the "
"byte range specified by the new lock does not precisely coincide with the "
"range of the existing lock.)"
msgstr ""

#. type: TP
#: man-pages/man2/fcntl.2:339
#, no-wrap
msgid "B<F_SETLK> (I<struct flock *>)"
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:364
msgid ""
"Acquire a lock (when I<l_type> is B<F_RDLCK> or B<F_WRLCK>)  or release a "
"lock (when I<l_type> is B<F_UNLCK>)  on the bytes specified by the "
"I<l_whence>, I<l_start>, and I<l_len> fields of I<lock>.  If a conflicting "
"lock is held by another process, this call returns -1 and sets I<errno> to "
"B<EACCES> or B<EAGAIN>.  (The error returned in this case differs across "
"implementations, so POSIX requires a portable application to check for both "
"errors.)"
msgstr ""

#. type: TP
#: man-pages/man2/fcntl.2:364
#, no-wrap
msgid "B<F_SETLKW> (I<struct flock *>)"
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:378
msgid ""
"As for B<F_SETLK>, but if a conflicting lock is held on the file, then wait "
"for that lock to be released.  If a signal is caught while waiting, then the "
"call is interrupted and (after the signal handler has returned)  returns "
"immediately (with return value -1 and I<errno> set to B<EINTR>; see "
"B<signal>(7))."
msgstr ""

#. type: TP
#: man-pages/man2/fcntl.2:378
#, no-wrap
msgid "B<F_GETLK> (I<struct flock *>)"
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:392
msgid ""
"On input to this call, I<lock> describes a lock we would like to place on "
"the file.  If the lock could be placed, B<fcntl>()  does not actually place "
"it, but returns B<F_UNLCK> in the I<l_type> field of I<lock> and leaves the "
"other fields of the structure unchanged."
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:409
msgid ""
"If one or more incompatible locks would prevent this lock being placed, then "
"B<fcntl>()  returns details about one of those locks in the I<l_type>, "
"I<l_whence>, I<l_start>, and I<l_len> fields of I<lock>.  If the conflicting "
"lock is a traditional (process-associated) record lock, then the I<l_pid> "
"field is set to the PID of the process holding that lock.  If the "
"conflicting lock is an open file description lock, then I<l_pid> is set to "
"-1.  Note that the returned information may already be out of date by the "
"time the caller inspects it."
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:417
msgid ""
"In order to place a read lock, I<fd> must be open for reading.  In order to "
"place a write lock, I<fd> must be open for writing.  To place both types of "
"lock, open a file read-write."
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:440
msgid ""
"When placing locks with B<F_SETLKW>, the kernel detects I<deadlocks>, "
"whereby two or more processes have their lock requests mutually blocked by "
"locks held by the other processes.  For example, suppose process A holds a "
"write lock on byte 100 of a file, and process B holds a write lock on byte "
"200.  If each process then attempts to lock the byte already locked by the "
"other process using B<F_SETLKW>, then, without deadlock detection, both "
"processes would remain blocked indefinitely.  When the kernel detects such "
"deadlocks, it causes one of the blocking lock requests to immediately fail "
"with the error B<EDEADLK>; an application that encounters such an error "
"should release some of its locks to allow other applications to proceed "
"before attempting regain the locks that it requires.  Circular deadlocks "
"involving more than two processes are also detected.  Note, however, that "
"there are limitations to the kernel's deadlock-detection algorithm; see "
"BUGS."
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:444
msgid ""
"As well as being removed by an explicit B<F_UNLCK>, record locks are "
"automatically released when the process terminates."
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:449
msgid ""
"Record locks are not inherited by a child created via B<fork>(2), but are "
"preserved across an B<execve>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:458
msgid ""
"Because of the buffering performed by the B<stdio>(3)  library, the use of "
"record locking with routines in that package should be avoided; use "
"B<read>(2)  and B<write>(2)  instead."
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:462
msgid ""
"The record locks described above are associated with the process (unlike the "
"open file description locks described below).  This has some unfortunate "
"consequences:"
msgstr ""

#.  (Additional file descriptors referring to the same file
#.  may have been obtained by calls to
#.  .BR open "(2), " dup "(2), " dup2 "(2), or " fcntl ().)
#. type: Plain text
#: man-pages/man2/fcntl.2:478
msgid ""
"If a process closes I<any> file descriptor referring to a file, then all of "
"the process's locks on that file are released, regardless of the file "
"descriptor(s) on which the locks were obtained.  This is bad: it means that "
"a process can lose its locks on a file such as I</etc/passwd> or "
"I</etc/mtab> when for some reason a library function decides to open, read, "
"and close the same file."
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:483
msgid ""
"The threads in a process share locks.  In other words, a multithreaded "
"program can't use record locking to ensure that threads don't simultaneously "
"access the same region of a file."
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:485
msgid "Open file description locks solve both of these problems."
msgstr ""

#. type: SS
#: man-pages/man2/fcntl.2:485
#, no-wrap
msgid "Open file description locks (non-POSIX)"
msgstr ""

#.  FIXME . Review progress into POSIX
#.  http://austingroupbugs.net/view.php?id=768
#. type: Plain text
#: man-pages/man2/fcntl.2:496
msgid ""
"Open file description locks are advisory byte-range locks whose operation is "
"in most respects identical to the traditional record locks described above.  "
"This lock type is Linux-specific, and available since Linux 3.15.  (There is "
"a proposal with the Austin Group to include this lock type in the next "
"revision of POSIX.1.)  For an explanation of open file descriptions, see "
"B<open>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:514
msgid ""
"The principal difference between the two lock types is that whereas "
"traditional record locks are associated with a process, open file "
"description locks are associated with the open file description on which "
"they are acquired, much like locks acquired with B<flock>(2).  Consequently "
"(and unlike traditional advisory record locks), open file description locks "
"are inherited across B<fork>(2)  (and B<clone>(2)  with B<CLONE_FILES>), and "
"are only automatically released on the last close of the open file "
"description, instead of being released on any close of the file."
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:520
msgid ""
"Conflicting lock combinations (i.e., a read lock and a write lock or two "
"write locks)  where one lock is an open file description lock and the other "
"is a traditional record lock conflict even when they are acquired by the "
"same process on the same file descriptor."
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:533
msgid ""
"Open file description locks placed via the same open file description (i.e., "
"via the same file descriptor, or via a duplicate of the file descriptor "
"created by B<fork>(2), B<dup>(2), B<fcntl>()  B<F_DUPFD>, and so on) are "
"always compatible: if a new lock is placed on an already locked region, then "
"the existing lock is converted to the new lock type.  (Such conversions may "
"result in splitting, shrinking, or coalescing with an existing lock as "
"discussed above.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:541
msgid ""
"On the other hand, open file description locks may conflict with each other "
"when they are acquired via different open file descriptions.  Thus, the "
"threads in a multithreaded program can use open file description locks to "
"synchronize access to a file region by having each thread perform its own "
"B<open>(2)  on the file and applying locks via the resulting file "
"descriptor."
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:552
msgid ""
"As with traditional advisory locks, the third argument to B<fcntl>(), "
"I<lock>, is a pointer to an I<flock> structure.  By contrast with "
"traditional record locks, the I<l_pid> field of that structure must be set "
"to zero when using the commands described below."
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:555
msgid ""
"The commands for working with open file description locks are analogous to "
"those used with traditional locks:"
msgstr ""

#. type: TP
#: man-pages/man2/fcntl.2:555
#, no-wrap
msgid "B<F_OFD_SETLK> (I<struct flock *>)"
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:576
msgid ""
"Acquire an open file description lock (when I<l_type> is B<F_RDLCK> or "
"B<F_WRLCK>)  or release an open file description lock (when I<l_type> is "
"B<F_UNLCK>)  on the bytes specified by the I<l_whence>, I<l_start>, and "
"I<l_len> fields of I<lock>.  If a conflicting lock is held by another "
"process, this call returns -1 and sets I<errno> to B<EAGAIN>."
msgstr ""

#. type: TP
#: man-pages/man2/fcntl.2:576
#, no-wrap
msgid "B<F_OFD_SETLKW> (I<struct flock *>)"
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:590
msgid ""
"As for B<F_OFD_SETLK>, but if a conflicting lock is held on the file, then "
"wait for that lock to be released.  If a signal is caught while waiting, "
"then the call is interrupted and (after the signal handler has returned) "
"returns immediately (with return value -1 and I<errno> set to B<EINTR>; see "
"B<signal>(7))."
msgstr ""

#. type: TP
#: man-pages/man2/fcntl.2:590
#, no-wrap
msgid "B<F_OFD_GETLK> (I<struct flock *>)"
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:609
msgid ""
"On input to this call, I<lock> describes an open file description lock we "
"would like to place on the file.  If the lock could be placed, B<fcntl>()  "
"does not actually place it, but returns B<F_UNLCK> in the I<l_type> field of "
"I<lock> and leaves the other fields of the structure unchanged.  If one or "
"more incompatible locks would prevent this lock being placed, then details "
"about one of these locks are returned via I<lock>, as described above for "
"B<F_GETLK>."
msgstr ""

#.  commit 57b65325fe34ec4c917bc4e555144b4a94d9e1f7
#. type: Plain text
#: man-pages/man2/fcntl.2:616
msgid ""
"In the current implementation, no deadlock detection is performed for open "
"file description locks.  (This contrasts with process-associated record "
"locks, for which the kernel does perform deadlock detection.)"
msgstr ""

#. type: SS
#: man-pages/man2/fcntl.2:616 man-pages/man2/fcntl.2:2067
#, no-wrap
msgid "Mandatory locking"
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:626
msgid ""
"I<Warning>: the Linux implementation of mandatory locking is unreliable.  "
"See BUGS below.  Because of these bugs, and the fact that the feature is "
"believed to be little used, since Linux 4.5, mandatory locking has been made "
"an optional feature, governed by a configuration option "
"(B<CONFIG_MANDATORY_FILE_LOCKING>).  This is an initial step toward removing "
"this feature completely."
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:631
msgid ""
"By default, both traditional (process-associated) and open file description "
"record locks are advisory.  Advisory locks are not enforced and are useful "
"only between cooperating processes."
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:651
msgid ""
"Both lock types can also be mandatory.  Mandatory locks are enforced for all "
"processes.  If a process tries to perform an incompatible access (e.g., "
"B<read>(2)  or B<write>(2))  on a file region that has an incompatible "
"mandatory lock, then the result depends upon whether the B<O_NONBLOCK> flag "
"is enabled for its open file description.  If the B<O_NONBLOCK> flag is not "
"enabled, then the system call is blocked until the lock is removed or "
"converted to a mode that is compatible with the access.  If the "
"B<O_NONBLOCK> flag is enabled, then the system call fails with the error "
"B<EAGAIN>."
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:668
msgid ""
"To make use of mandatory locks, mandatory locking must be enabled both on "
"the filesystem that contains the file to be locked, and on the file itself.  "
"Mandatory locking is enabled on a filesystem using the \"-o mand\" option to "
"B<mount>(8), or the B<MS_MANDLOCK> flag for B<mount>(2).  Mandatory locking "
"is enabled on a file by disabling group execute permission on the file and "
"enabling the set-group-ID permission bit (see B<chmod>(1)  and B<chmod>(2))."
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:673
msgid ""
"Mandatory locking is not specified by POSIX.  Some other systems also "
"support mandatory locking, although the details of how to enable it vary "
"across systems."
msgstr ""

#. type: SS
#: man-pages/man2/fcntl.2:673
#, no-wrap
msgid "Lost locks"
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:680
msgid ""
"When an advisory lock is obtained on a networked filesystem such as NFS it "
"is possible that the lock might get lost.  This may happen due to "
"administrative action on the server, or due to a network partition (i.e., "
"loss of network connectivity with the server)  which lasts long enough for "
"the server to assume that the client is no longer functioning."
msgstr ""

#.  commit ef1820f9be27b6ad158f433ab38002ab8131db4d
#. type: Plain text
#: man-pages/man2/fcntl.2:692
msgid ""
"When the filesystem determines that a lock has been lost, future B<read>(2)  "
"or B<write>(2)  requests may fail with the error B<EIO>.  This error will "
"persist until the lock is removed or the file descriptor is closed.  Since "
"Linux 3.12, this happens at least for NFSv4 (including all minor versions)."
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:699
msgid ""
"Some versions of UNIX send a signal (B<SIGLOST>)  in this circumstance.  "
"Linux does not define this signal, and does not provide any asynchronous "
"notification of lost locks."
msgstr ""

#. type: SS
#: man-pages/man2/fcntl.2:699
#, no-wrap
msgid "Managing signals"
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:708
msgid ""
"B<F_GETOWN>, B<F_SETOWN>, B<F_GETOWN_EX>, B<F_SETOWN_EX>, B<F_GETSIG> and "
"B<F_SETSIG> are used to manage I/O availability signals:"
msgstr ""

#. type: TP
#: man-pages/man2/fcntl.2:708
#, no-wrap
msgid "B<F_GETOWN> (I<void>)"
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:721
msgid ""
"Return (as the function result)  the process ID or process group currently "
"receiving B<SIGIO> and B<SIGURG> signals for events on file descriptor "
"I<fd>.  Process IDs are returned as positive values; process group IDs are "
"returned as negative values (but see BUGS below).  I<arg> is ignored."
msgstr ""

#. type: TP
#: man-pages/man2/fcntl.2:721
#, no-wrap
msgid "B<F_SETOWN> (I<int>)"
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:738
msgid ""
"Set the process ID or process group ID that will receive B<SIGIO> and "
"B<SIGURG> signals for events on the file descriptor I<fd>.  The target "
"process or process group ID is specified in I<arg>.  A process ID is "
"specified as a positive value; a process group ID is specified as a negative "
"value.  Most commonly, the calling process specifies itself as the owner "
"(that is, I<arg> is specified as B<getpid>(2))."
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:756
msgid ""
"As well as setting the file descriptor owner, one must also enable "
"generation of signals on the file descriptor.  This is done by using the "
"B<fcntl>()  B<F_SETFL> command to set the B<O_ASYNC> file status flag on the "
"file descriptor.  Subsequently, a B<SIGIO> signal is sent whenever input or "
"output becomes possible on the file descriptor.  The B<fcntl>()  B<F_SETSIG> "
"command can be used to obtain delivery of a signal other than B<SIGIO>."
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:773
msgid ""
"Sending a signal to the owner process (group) specified by B<F_SETOWN> is "
"subject to the same permissions checks as are described for B<kill>(2), "
"where the sending process is the one that employs B<F_SETOWN> (but see BUGS "
"below).  If this permission check fails, then the signal is silently "
"discarded.  I<Note>: The B<F_SETOWN> operation records the caller's "
"credentials at the time of the B<fcntl>()  call, and it is these saved "
"credentials that are used for the permission checks."
msgstr ""

#.  The following appears to be rubbish.  It doesn't seem to
#.  be true according to the kernel source, and I can write
#.  a program that gets a terminal-generated SIGIO even though
#.  it is not the foreground process group of the terminal.
#.  -- MTK, 8 Apr 05
#
#.  If the file descriptor
#.  .I fd
#.  refers to a terminal device, then SIGIO
#.  signals are sent to the foreground process group of the terminal.
#. type: Plain text
#: man-pages/man2/fcntl.2:797
msgid ""
"If the file descriptor I<fd> refers to a socket, B<F_SETOWN> also selects "
"the recipient of B<SIGURG> signals that are delivered when out-of-band data "
"arrives on that socket.  (B<SIGURG> is sent in any situation where "
"B<select>(2)  would report the socket as having an \"exceptional "
"condition\".)"
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:800
msgid "The following was true in 2.6.x kernels up to and including kernel 2.6.11:"
msgstr ""

#.  The relevant place in the (2.6) kernel source is the
#.  'switch' in fs/fcntl.c::send_sigio_to_task() -- MTK, Apr 2005
#.  send_sigurg()/send_sigurg_to_task() bypasses
#.  kill_fasync()/send_sigio()/send_sigio_to_task()
#.  to directly call send_group_sig_info()
#. 	-- MTK, Apr 2005 (kernel 2.6.11)
#. type: Plain text
#: man-pages/man2/fcntl.2:840
msgid ""
"If a nonzero value is given to B<F_SETSIG> in a multithreaded process "
"running with a threading library that supports thread groups (e.g., NPTL), "
"then a positive value given to B<F_SETOWN> has a different meaning: instead "
"of being a process ID identifying a whole process, it is a thread ID "
"identifying a specific thread within a process.  Consequently, it may be "
"necessary to pass B<F_SETOWN> the result of B<gettid>(2)  instead of "
"B<getpid>(2)  to get sensible results when B<F_SETSIG> is used.  (In current "
"Linux threading implementations, a main thread's thread ID is the same as "
"its process ID.  This means that a single-threaded program can equally use "
"B<gettid>(2)  or B<getpid>(2)  in this scenario.)  Note, however, that the "
"statements in this paragraph do not apply to the B<SIGURG> signal generated "
"for out-of-band data on a socket: this signal is always sent to either a "
"process or a process group, depending on the value given to B<F_SETOWN>."
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:851
msgid ""
"The above behavior was accidentally dropped in Linux 2.6.12, and won't be "
"restored.  From Linux 2.6.32 onward, use B<F_SETOWN_EX> to target B<SIGIO> "
"and B<SIGURG> signals at a particular thread."
msgstr ""

#. type: TP
#: man-pages/man2/fcntl.2:851
#, no-wrap
msgid "B<F_GETOWN_EX> (I<struct f_owner_ex *>) (since Linux 2.6.32)"
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:860
msgid ""
"Return the current file descriptor owner settings as defined by a previous "
"B<F_SETOWN_EX> operation.  The information is returned in the structure "
"pointed to by I<arg>, which has the following form:"
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:867
#, no-wrap
msgid ""
"struct f_owner_ex {\n"
"    int   type;\n"
"    pid_t pid;\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:884
msgid ""
"The I<type> field will have one of the values B<F_OWNER_TID>, "
"B<F_OWNER_PID>, or B<F_OWNER_PGRP>.  The I<pid> field is a positive integer "
"representing a thread ID, process ID, or process group ID.  See "
"B<F_SETOWN_EX> for more details."
msgstr ""

#. type: TP
#: man-pages/man2/fcntl.2:884
#, no-wrap
msgid "B<F_SETOWN_EX> (I<struct f_owner_ex *>) (since Linux 2.6.32)"
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:900
msgid ""
"This operation performs a similar task to B<F_SETOWN>.  It allows the caller "
"to direct I/O availability signals to a specific thread, process, or process "
"group.  The caller specifies the target of signals via I<arg>, which is a "
"pointer to a I<f_owner_ex> structure.  The I<type> field has one of the "
"following values, which define how I<pid> is interpreted:"
msgstr ""

#. type: TP
#: man-pages/man2/fcntl.2:901
#, no-wrap
msgid "B<F_OWNER_TID>"
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:910
msgid ""
"Send the signal to the thread whose thread ID (the value returned by a call "
"to B<clone>(2)  or B<gettid>(2))  is specified in I<pid>."
msgstr ""

#. type: TP
#: man-pages/man2/fcntl.2:910
#, no-wrap
msgid "B<F_OWNER_PID>"
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:915
msgid "Send the signal to the process whose ID is specified in I<pid>."
msgstr ""

#. type: TP
#: man-pages/man2/fcntl.2:915
#, no-wrap
msgid "B<F_OWNER_PGRP>"
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:923
msgid ""
"Send the signal to the process group whose ID is specified in I<pid>.  (Note "
"that, unlike with B<F_SETOWN>, a process group ID is specified as a positive "
"value here.)"
msgstr ""

#. type: TP
#: man-pages/man2/fcntl.2:924
#, no-wrap
msgid "B<F_GETSIG> (I<void>)"
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:939
msgid ""
"Return (as the function result)  the signal sent when input or output "
"becomes possible.  A value of zero means B<SIGIO> is sent.  Any other value "
"(including B<SIGIO>)  is the signal sent instead, and in this case "
"additional info is available to the signal handler if installed with "
"B<SA_SIGINFO>.  I<arg> is ignored."
msgstr ""

#. type: TP
#: man-pages/man2/fcntl.2:939
#, no-wrap
msgid "B<F_SETSIG> (I<int>)"
msgstr ""

#
#.  The following was true only up until 2.6.11:
#
#.  Additionally, passing a nonzero value to
#.  .B F_SETSIG
#.  changes the signal recipient from a whole process to a specific thread
#.  within a process.
#.  See the description of
#.  .B F_SETOWN
#.  for more details.
#. type: Plain text
#: man-pages/man2/fcntl.2:962
msgid ""
"Set the signal sent when input or output becomes possible to the value given "
"in I<arg>.  A value of zero means to send the default B<SIGIO> signal.  Any "
"other value (including B<SIGIO>)  is the signal to send instead, and in this "
"case additional info is available to the signal handler if installed with "
"B<SA_SIGINFO>."
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:990
msgid ""
"By using B<F_SETSIG> with a nonzero value, and setting B<SA_SIGINFO> for the "
"signal handler (see B<sigaction>(2)), extra information about I/O events is "
"passed to the handler in a I<siginfo_t> structure.  If the I<si_code> field "
"indicates the source is B<SI_SIGIO>, the I<si_fd> field gives the file "
"descriptor associated with the event.  Otherwise, there is no indication "
"which file descriptors are pending, and you should use the usual mechanisms "
"(B<select>(2), B<poll>(2), B<read>(2)  with B<O_NONBLOCK> set etc.) to "
"determine which file descriptors are available for I/O."
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1003
msgid ""
"Note that the file descriptor provided in I<si_fd> is the one that was "
"specified during the B<F_SETSIG> operation.  This can lead to an unusual "
"corner case.  If the file descriptor is duplicated (B<dup>(2)  or similar), "
"and the original file descriptor is closed, then I/O events will continue to "
"be generated, but the I<si_fd> field will contain the number of the now "
"closed file descriptor."
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1012
msgid ""
"By selecting a real time signal (value E<gt>= B<SIGRTMIN>), multiple I/O "
"events may be queued using the same signal numbers.  (Queuing is dependent "
"on available memory.)  Extra information is available if B<SA_SIGINFO> is "
"set for the signal handler, as above."
msgstr ""

#.  See fs/fcntl.c::send_sigio_to_task() (2.4/2.6) sources -- MTK, Apr 05
#. type: Plain text
#: man-pages/man2/fcntl.2:1025
msgid ""
"Note that Linux imposes a limit on the number of real-time signals that may "
"be queued to a process (see B<getrlimit>(2)  and B<signal>(7))  and if this "
"limit is reached, then the kernel reverts to delivering B<SIGIO>, and this "
"signal is delivered to the entire process rather than to a specific thread."
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1032
msgid ""
"Using these mechanisms, a program can implement fully asynchronous I/O "
"without using B<select>(2)  or B<poll>(2)  most of the time."
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1056
msgid ""
"The use of B<O_ASYNC> is specific to BSD and Linux.  The only use of "
"B<F_GETOWN> and B<F_SETOWN> specified in POSIX.1 is in conjunction with the "
"use of the B<SIGURG> signal on sockets.  (POSIX does not specify the "
"B<SIGIO> signal.)  B<F_GETOWN_EX>, B<F_SETOWN_EX>, B<F_GETSIG>, and "
"B<F_SETSIG> are Linux-specific.  POSIX has asynchronous I/O and the "
"I<aio_sigevent> structure to achieve similar things; these are also "
"available in Linux as part of the GNU C Library (Glibc)."
msgstr ""

#. type: SS
#: man-pages/man2/fcntl.2:1056
#, no-wrap
msgid "Leases"
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1071
msgid ""
"B<F_SETLEASE> and B<F_GETLEASE> (Linux 2.4 onward) are used to establish a "
"new lease, and retrieve the current lease, on the open file description "
"referred to by the file descriptor I<fd>.  A file lease provides a mechanism "
"whereby the process holding the lease (the \"lease holder\") is notified "
"(via delivery of a signal)  when a process (the \"lease breaker\") tries to "
"B<open>(2)  or B<truncate>(2)  the file referred to by that file descriptor."
msgstr ""

#. type: TP
#: man-pages/man2/fcntl.2:1071
#, no-wrap
msgid "B<F_SETLEASE> (I<int>)"
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1076
msgid ""
"Set or remove a file lease according to which of the following values is "
"specified in the integer I<arg>:"
msgstr ""

#. type: TP
#: man-pages/man2/fcntl.2:1077
#, no-wrap
msgid "B<F_RDLCK>"
msgstr ""

#.  The following became true in kernel 2.6.10:
#.  See the man-pages-2.09 Changelog for further info.
#. type: Plain text
#: man-pages/man2/fcntl.2:1086
msgid ""
"Take out a read lease.  This will cause the calling process to be notified "
"when the file is opened for writing or is truncated.  A read lease can be "
"placed only on a file descriptor that is opened read-only."
msgstr ""

#. type: TP
#: man-pages/man2/fcntl.2:1086
#, no-wrap
msgid "B<F_WRLCK>"
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1093
msgid ""
"Take out a write lease.  This will cause the caller to be notified when the "
"file is opened for reading or writing or is truncated.  A write lease may be "
"placed on a file only if there are no other open file descriptors for the "
"file."
msgstr ""

#. type: TP
#: man-pages/man2/fcntl.2:1093
#, no-wrap
msgid "B<F_UNLCK>"
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1096
msgid "Remove our lease from the file."
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1110
msgid ""
"Leases are associated with an open file description (see B<open>(2)).  This "
"means that duplicate file descriptors (created by, for example, B<fork>(2)  "
"or B<dup>(2))  refer to the same lease, and this lease may be modified or "
"released using any of these descriptors.  Furthermore, the lease is released "
"by either an explicit B<F_UNLCK> operation on any of these duplicate file "
"descriptors, or when all such file descriptors have been closed."
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1117
msgid ""
"Leases may be taken out only on regular files.  An unprivileged process may "
"take out a lease only on a file whose UID (owner) matches the filesystem UID "
"of the process.  A process with the B<CAP_LEASE> capability may take out "
"leases on arbitrary files."
msgstr ""

#. type: TP
#: man-pages/man2/fcntl.2:1117
#, no-wrap
msgid "B<F_GETLEASE> (I<void>)"
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1126
msgid ""
"Indicates what type of lease is associated with the file descriptor I<fd> by "
"returning either B<F_RDLCK>, B<F_WRLCK>, or B<F_UNLCK>, indicating, "
"respectively, a read lease , a write lease, or no lease.  I<arg> is ignored."
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1157
msgid ""
"When a process (the \"lease breaker\") performs an B<open>(2)  or "
"B<truncate>(2)  that conflicts with a lease established via B<F_SETLEASE>, "
"the system call is blocked by the kernel and the kernel notifies the lease "
"holder by sending it a signal (B<SIGIO> by default).  The lease holder "
"should respond to receipt of this signal by doing whatever cleanup is "
"required in preparation for the file to be accessed by another process "
"(e.g., flushing cached buffers) and then either remove or downgrade its "
"lease.  A lease is removed by performing an B<F_SETLEASE> command specifying "
"I<arg> as B<F_UNLCK>.  If the lease holder currently holds a write lease on "
"the file, and the lease breaker is opening the file for reading, then it is "
"sufficient for the lease holder to downgrade the lease to a read lease.  "
"This is done by performing an B<F_SETLEASE> command specifying I<arg> as "
"B<F_RDLCK>."
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1162
msgid ""
"If the lease holder fails to downgrade or remove the lease within the number "
"of seconds specified in I</proc/sys/fs/lease-break-time>, then the kernel "
"forcibly removes or downgrades the lease holder's lease."
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1172
msgid ""
"Once a lease break has been initiated, B<F_GETLEASE> returns the target "
"lease type (either B<F_RDLCK> or B<F_UNLCK>, depending on what would be "
"compatible with the lease breaker)  until the lease holder voluntarily "
"downgrades or removes the lease or the kernel forcibly does so after the "
"lease break timer expires."
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1176
msgid ""
"Once the lease has been voluntarily or forcibly removed or downgraded, and "
"assuming the lease breaker has not unblocked its system call, the kernel "
"permits the lease breaker's system call to proceed."
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1197
msgid ""
"If the lease breaker's blocked B<open>(2)  or B<truncate>(2)  is interrupted "
"by a signal handler, then the system call fails with the error B<EINTR>, but "
"the other steps still occur as described above.  If the lease breaker is "
"killed by a signal while blocked in B<open>(2)  or B<truncate>(2), then the "
"other steps still occur as described above.  If the lease breaker specifies "
"the B<O_NONBLOCK> flag when calling B<open>(2), then the call immediately "
"fails with the error B<EWOULDBLOCK>, but the other steps still occur as "
"described above."
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1218
msgid ""
"The default signal used to notify the lease holder is B<SIGIO>, but this can "
"be changed using the B<F_SETSIG> command to B<fcntl>().  If a B<F_SETSIG> "
"command is performed (even one specifying B<SIGIO>), and the signal handler "
"is established using B<SA_SIGINFO>, then the handler will receive a "
"I<siginfo_t> structure as its second argument, and the I<si_fd> field of "
"this argument will hold the file descriptor of the leased file that has been "
"accessed by another process.  (This is useful if the caller holds leases "
"against multiple files.)"
msgstr ""

#. type: SS
#: man-pages/man2/fcntl.2:1218
#, no-wrap
msgid "File and directory change notification (dnotify)"
msgstr ""

#. type: TP
#: man-pages/man2/fcntl.2:1219
#, no-wrap
msgid "B<F_NOTIFY> (I<int>)"
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1229
msgid ""
"(Linux 2.4 onward)  Provide notification when the directory referred to by "
"I<fd> or any of the files that it contains is changed.  The events to be "
"notified are specified in I<arg>, which is a bit mask specified by ORing "
"together zero or more of the following bits:"
msgstr ""

#. type: TP
#: man-pages/man2/fcntl.2:1232
#, no-wrap
msgid "B<DN_ACCESS>"
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1239
msgid "A file was accessed (B<read>(2), B<pread>(2), B<readv>(2), and similar)"
msgstr ""

#. type: TP
#: man-pages/man2/fcntl.2:1239
#, no-wrap
msgid "B<DN_MODIFY>"
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1248
msgid ""
"A file was modified (B<write>(2), B<pwrite>(2), B<writev>(2), "
"B<truncate>(2), B<ftruncate>(2), and similar)."
msgstr ""

#. type: TP
#: man-pages/man2/fcntl.2:1248
#, no-wrap
msgid "B<DN_CREATE>"
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1259
msgid ""
"A file was created (B<open>(2), B<creat>(2), B<mknod>(2), B<mkdir>(2), "
"B<link>(2), B<symlink>(2), B<rename>(2)  into this directory)."
msgstr ""

#. type: TP
#: man-pages/man2/fcntl.2:1259
#, no-wrap
msgid "B<DN_DELETE>"
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1266
msgid ""
"A file was unlinked (B<unlink>(2), B<rename>(2)  to another directory, "
"B<rmdir>(2))."
msgstr ""

#. type: TP
#: man-pages/man2/fcntl.2:1266
#, no-wrap
msgid "B<DN_RENAME>"
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1270
msgid "A file was renamed within this directory (B<rename>(2))."
msgstr ""

#. type: TP
#: man-pages/man2/fcntl.2:1270
#, no-wrap
msgid "B<DN_ATTRIB>"
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1278
msgid ""
"The attributes of a file were changed (B<chown>(2), B<chmod>(2), "
"B<utime>(2), B<utimensat>(2), and similar)."
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1286
msgid ""
"(In order to obtain these definitions, the B<_GNU_SOURCE> feature test macro "
"must be defined before including I<any> header files.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1294
msgid ""
"Directory notifications are normally \"one-shot\", and the application must "
"reregister to receive further notifications.  Alternatively, if "
"B<DN_MULTISHOT> is included in I<arg>, then notification will remain in "
"effect until explicitly removed."
msgstr ""

#.  The following does seem a poor API-design choice...
#. type: Plain text
#: man-pages/man2/fcntl.2:1306
msgid ""
"A series of B<F_NOTIFY> requests is cumulative, with the events in I<arg> "
"being added to the set already monitored.  To disable notification of all "
"events, make an B<F_NOTIFY> call specifying I<arg> as 0."
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1329
msgid ""
"Notification occurs via delivery of a signal.  The default signal is "
"B<SIGIO>, but this can be changed using the B<F_SETSIG> command to "
"B<fcntl>().  (Note that B<SIGIO> is one of the nonqueuing standard signals; "
"switching to the use of a real-time signal means that multiple notifications "
"can be queued to the process.)  In the latter case, the signal handler "
"receives a I<siginfo_t> structure as its second argument (if the handler was "
"established using B<SA_SIGINFO>)  and the I<si_fd> field of this structure "
"contains the file descriptor which generated the notification (useful when "
"establishing notification on multiple directories)."
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1334
msgid ""
"Especially when using B<DN_MULTISHOT>, a real time signal should be used for "
"notification, so that multiple notifications can be queued."
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1343
msgid ""
"B<NOTE:> New applications should use the I<inotify> interface (available "
"since kernel 2.6.13), which provides a much superior interface for obtaining "
"notifications of filesystem events.  See B<inotify>(7)."
msgstr ""

#. type: SS
#: man-pages/man2/fcntl.2:1343
#, no-wrap
msgid "Changing the capacity of a pipe"
msgstr ""

#. type: TP
#: man-pages/man2/fcntl.2:1344
#, no-wrap
msgid "B<F_SETPIPE_SZ> (I<int>; since Linux 2.6.35)"
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1365
msgid ""
"Change the capacity of the pipe referred to by I<fd> to be at least I<arg> "
"bytes.  An unprivileged process can adjust the pipe capacity to any value "
"between the system page size and the limit defined in "
"I</proc/sys/fs/pipe-max-size> (see B<proc>(5)).  Attempts to set the pipe "
"capacity below the page size are silently rounded up to the page size.  "
"Attempts by an unprivileged process to set the pipe capacity above the limit "
"in I</proc/sys/fs/pipe-max-size> yield the error B<EPERM>; a privileged "
"process (B<CAP_SYS_RESOURCE>)  can override the limit."
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1374
msgid ""
"When allocating the buffer for the pipe, the kernel may use a capacity "
"larger than I<arg>, if that is convenient for the implementation.  (In the "
"current implementation, the allocation is the next higher power-of-two "
"page-size multiple of the requested size.)  The actual capacity (in bytes) "
"that is set is returned as the function result."
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1378
msgid ""
"Attempting to set the pipe capacity smaller than the amount of buffer space "
"currently used to store data produces the error B<EBUSY>."
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1383
msgid ""
"Note that because of the way the pages of the pipe buffer are employed when "
"data is written to the pipe, the number of bytes that can be written may be "
"less than the nominal size, depending on the size of the writes."
msgstr ""

#. type: TP
#: man-pages/man2/fcntl.2:1383
#, no-wrap
msgid "B<F_GETPIPE_SZ> (I<void>; since Linux 2.6.35)"
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1388
msgid ""
"Return (as the function result) the capacity of the pipe referred to by "
"I<fd>."
msgstr ""

#. type: SS
#: man-pages/man2/fcntl.2:1388
#, no-wrap
msgid "File Sealing"
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1400
msgid ""
"File seals limit the set of allowed operations on a given file.  For each "
"seal that is set on a file, a specific set of operations will fail with "
"B<EPERM> on this file from now on.  The file is said to be sealed.  The "
"default set of seals depends on the type of the underlying file and "
"filesystem.  For an overview of file sealing, a discussion of its purpose, "
"and some code examples, see B<memfd_create>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1411
msgid ""
"Currently, file seals can be applied only to a file descriptor returned by "
"B<memfd_create>(2)  (if the B<MFD_ALLOW_SEALING> was employed).  On other "
"filesystems, all B<fcntl>()  operations that operate on seals will return "
"B<EINVAL>."
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1416
msgid ""
"Seals are a property of an inode.  Thus, all open file descriptors referring "
"to the same inode share the same set of seals.  Furthermore, seals can never "
"be removed, only added."
msgstr ""

#. type: TP
#: man-pages/man2/fcntl.2:1416
#, no-wrap
msgid "B<F_ADD_SEALS> (I<int>; since Linux 3.17)"
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1434
msgid ""
"Add the seals given in the bit-mask argument I<arg> to the set of seals of "
"the inode referred to by the file descriptor I<fd>.  Seals cannot be removed "
"again.  Once this call succeeds, the seals are enforced by the kernel "
"immediately.  If the current set of seals includes B<F_SEAL_SEAL> (see "
"below), then this call will be rejected with B<EPERM>.  Adding a seal that "
"is already set is a no-op, in case B<F_SEAL_SEAL> is not set already.  In "
"order to place a seal, the file descriptor I<fd> must be writable."
msgstr ""

#. type: TP
#: man-pages/man2/fcntl.2:1434
#, no-wrap
msgid "B<F_GET_SEALS> (I<void>; since Linux 3.17)"
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1444
msgid ""
"Return (as the function result) the current set of seals of the inode "
"referred to by I<fd>.  If no seals are set, 0 is returned.  If the file does "
"not support sealing, -1 is returned and I<errno> is set to B<EINVAL>."
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1446
msgid "The following seals are available:"
msgstr ""

#. type: TP
#: man-pages/man2/fcntl.2:1446
#, no-wrap
msgid "B<F_SEAL_SEAL>"
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1458
msgid ""
"If this seal is set, any further call to B<fcntl>()  with B<F_ADD_SEALS> "
"fails with the error B<EPERM>.  Therefore, this seal prevents any "
"modifications to the set of seals itself.  If the initial set of seals of a "
"file includes B<F_SEAL_SEAL>, then this effectively causes the set of seals "
"to be constant and locked."
msgstr ""

#. type: TP
#: man-pages/man2/fcntl.2:1458
#, no-wrap
msgid "B<F_SEAL_SHRINK>"
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1473
msgid ""
"If this seal is set, the file in question cannot be reduced in size.  This "
"affects B<open>(2)  with the B<O_TRUNC> flag as well as B<truncate>(2)  and "
"B<ftruncate>(2).  Those calls fail with B<EPERM> if you try to shrink the "
"file in question.  Increasing the file size is still possible."
msgstr ""

#. type: TP
#: man-pages/man2/fcntl.2:1473
#, no-wrap
msgid "B<F_SEAL_GROW>"
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1487
msgid ""
"If this seal is set, the size of the file in question cannot be increased.  "
"This affects B<write>(2)  beyond the end of the file, B<truncate>(2), "
"B<ftruncate>(2), and B<fallocate>(2).  These calls fail with B<EPERM> if you "
"use them to increase the file size.  If you keep the size or shrink it, "
"those calls still work as expected."
msgstr ""

#. type: TP
#: man-pages/man2/fcntl.2:1487
#, no-wrap
msgid "B<F_SEAL_WRITE>"
msgstr ""

#.  One or more other seals are typically used with F_SEAL_WRITE
#.  because, given a file with the F_SEAL_WRITE seal set, then,
#.  while it would no longer be possible to (say) write zeros into
#.  the last 100 bytes of a file, it would still be possible
#.  to (say) shrink the file by 100 bytes using ftruncate(), and
#.  then increase the file size by 100 bytes, which would have
#.  the effect of replacing the last hundred bytes by zeros.
#. type: Plain text
#: man-pages/man2/fcntl.2:1515
msgid ""
"If this seal is set, you cannot modify the contents of the file.  Note that "
"shrinking or growing the size of the file is still possible and allowed.  "
"Thus, this seal is normally used in combination with one of the other "
"seals.  This seal affects B<write>(2)  and B<fallocate>(2)  (only in "
"combination with the B<FALLOC_FL_PUNCH_HOLE> flag).  Those calls fail with "
"B<EPERM> if this seal is set.  Furthermore, trying to create new shared, "
"writable memory-mappings via B<mmap>(2)  will also fail with B<EPERM>."
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1529
msgid ""
"Using the B<F_ADD_SEALS> operation to set the B<F_SEAL_WRITE> seal fails "
"with B<EBUSY> if any writable, shared mapping exists.  Such mappings must be "
"unmapped before you can add this seal.  Furthermore, if there are any "
"asynchronous I/O operations (B<io_submit>(2))  pending on the file, all "
"outstanding writes will be discarded."
msgstr ""

#. type: SS
#: man-pages/man2/fcntl.2:1529
#, no-wrap
msgid "File read/write hints"
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1539
msgid ""
"Write lifetime hints can be used to inform the kernel about the relative "
"expected lifetime of writes on a given inode or via a particular open file "
"description.  (See B<open>(2)  for an explanation of open file "
"descriptions.)  In this context, the term \"write lifetime\" means the "
"expected time the data will live on media, before being overwritten or "
"erased."
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1547
msgid ""
"An application may use the different hint values specified below to separate "
"writes into different write classes, so that multiple users or applications "
"running on a single storage back-end can aggregate their I/O patterns in a "
"consistent manner.  However, there are no functional semantics implied by "
"these flags, and different I/O classes can use the write lifetime hints in "
"arbitrary ways, so long as the hints are used consistently."
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1550
msgid "The following operations can be applied to the file descriptor, I<fd>:"
msgstr ""

#. type: TP
#: man-pages/man2/fcntl.2:1550
#, no-wrap
msgid "B<F_GET_RW_HINT> (I<uint64_t *>; since Linux 4.13)"
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1555
msgid ""
"Returns the value of the read/write hint associated with the underlying "
"inode referred to by I<fd>."
msgstr ""

#. type: TP
#: man-pages/man2/fcntl.2:1555
#, no-wrap
msgid "B<F_SET_RW_HINT> (I<uint64_t *>; since Linux 4.13)"
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1562
msgid ""
"Sets the read/write hint value associated with the underlying inode referred "
"to by I<fd>.  This hint persists until either it is explicitly modified or "
"the underlying filesystem is unmounted."
msgstr ""

#. type: TP
#: man-pages/man2/fcntl.2:1562
#, no-wrap
msgid "B<F_GET_FILE_RW_HINT> (I<uint64_t *>; since Linux 4.13)"
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1567
msgid ""
"Returns the value of the read/write hint associated with the open file "
"description referred to by I<fd>."
msgstr ""

#. type: TP
#: man-pages/man2/fcntl.2:1567
#, no-wrap
msgid "B<F_SET_FILE_RW_HINT> (I<uint64_t *>; since Linux 4.13)"
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1572
msgid ""
"Sets the read/write hint value associated with the open file description "
"referred to by I<fd>."
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1575
msgid ""
"If an open file description has not been assigned a read/write hint, then it "
"shall use the value assigned to the inode, if any."
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1578
msgid "The following read/write hints are valid since Linux 4.13:"
msgstr ""

#. type: TP
#: man-pages/man2/fcntl.2:1578
#, no-wrap
msgid "B<RWH_WRITE_LIFE_NOT_SET>"
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1582
msgid "No specific hint has been set.  This is the default value."
msgstr ""

#. type: TP
#: man-pages/man2/fcntl.2:1582
#, no-wrap
msgid "B<RWH_WRITE_LIFE_NONE>"
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1585
msgid "No specific write lifetime is associated with this file or inode."
msgstr ""

#. type: TP
#: man-pages/man2/fcntl.2:1585
#, no-wrap
msgid "B<RWH_WRITE_LIFE_SHORT>"
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1589
msgid ""
"Data written to this inode or via this open file description is expected to "
"have a short lifetime."
msgstr ""

#. type: TP
#: man-pages/man2/fcntl.2:1589
#, no-wrap
msgid "B<RWH_WRITE_LIFE_MEDIUM>"
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1595
msgid ""
"Data written to this inode or via this open file description is expected to "
"have a lifetime longer than data written with B<RWH_WRITE_LIFE_SHORT>."
msgstr ""

#. type: TP
#: man-pages/man2/fcntl.2:1595
#, no-wrap
msgid "B<RWH_WRITE_LIFE_LONG>"
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1601
msgid ""
"Data written to this inode or via this open file description is expected to "
"have a lifetime longer than data written with B<RWH_WRITE_LIFE_MEDIUM>."
msgstr ""

#. type: TP
#: man-pages/man2/fcntl.2:1601
#, no-wrap
msgid "B<RWH_WRITE_LIFE_EXTREME>"
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1607
msgid ""
"Data written to this inode or via this open file description is expected to "
"have a lifetime longer than data written with B<RWH_WRITE_LIFE_LONG>."
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1610
msgid ""
"All the write-specific hints are relative to each other, and no individual "
"absolute meaning should be attributed to them."
msgstr ""

#. type: TP
#: man-pages/man2/fcntl.2:1612
#, no-wrap
msgid "B<F_DUPFD>"
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1615
msgid "The new file descriptor."
msgstr ""

#. type: TP
#: man-pages/man2/fcntl.2:1615
#, no-wrap
msgid "B<F_GETFD>"
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1618
msgid "Value of file descriptor flags."
msgstr ""

#. type: TP
#: man-pages/man2/fcntl.2:1618
#, no-wrap
msgid "B<F_GETFL>"
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1621
msgid "Value of file status flags."
msgstr ""

#. type: TP
#: man-pages/man2/fcntl.2:1621
#, no-wrap
msgid "B<F_GETLEASE>"
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1624
msgid "Type of lease held on file descriptor."
msgstr ""

#. type: TP
#: man-pages/man2/fcntl.2:1624
#, no-wrap
msgid "B<F_GETOWN>"
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1627
msgid "Value of file descriptor owner."
msgstr ""

#. type: TP
#: man-pages/man2/fcntl.2:1627
#, no-wrap
msgid "B<F_GETSIG>"
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1633
msgid ""
"Value of signal sent when read or write becomes possible, or zero for "
"traditional B<SIGIO> behavior."
msgstr ""

#. type: TP
#: man-pages/man2/fcntl.2:1633
#, no-wrap
msgid "B<F_GETPIPE_SZ>, B<F_SETPIPE_SZ>"
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1636
msgid "The pipe capacity."
msgstr ""

#. type: TP
#: man-pages/man2/fcntl.2:1636
#, no-wrap
msgid "B<F_GET_SEALS>"
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1641
msgid ""
"A bit mask identifying the seals that have been set for the inode referred "
"to by I<fd>."
msgstr ""

#. type: TP
#: man-pages/man2/fcntl.2:1649
#, no-wrap
msgid "B<EACCES> or B<EAGAIN>"
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1652
msgid "Operation is prohibited by locks held by other processes."
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1656
msgid ""
"The operation is prohibited because the file has been memory-mapped by "
"another process."
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1660
msgid "I<fd> is not an open file descriptor"
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1669
msgid ""
"I<cmd> is B<F_SETLK> or B<F_SETLKW> and the file descriptor open mode "
"doesn't match with the type of lock requested."
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1678
msgid ""
"I<cmd> is B<F_SETPIPE_SZ> and the new pipe capacity specified in I<arg> is "
"smaller than the amount of buffer space currently used to store data in the "
"pipe."
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1688
msgid ""
"I<cmd> is B<F_ADD_SEALS>, I<arg> includes B<F_SEAL_WRITE>, and there exists "
"a writable, shared mapping on the file referred to by I<fd>."
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1693
msgid ""
"It was detected that the specified B<F_SETLKW> command would cause a "
"deadlock."
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1697
msgid "I<lock> is outside your accessible address space."
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1706
msgid ""
"I<cmd> is B<F_SETLKW> or B<F_OFD_SETLKW> and the operation was interrupted "
"by a signal; see B<signal>(7)."
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1719
msgid ""
"I<cmd> is B<F_GETLK>, B<F_SETLK>, B<F_OFD_GETLK>, or B<F_OFD_SETLK>, and the "
"operation was interrupted by a signal before the lock was checked or "
"acquired.  Most likely when locking a remote file (e.g., locking over NFS), "
"but can sometimes happen locally."
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1732
msgid "I<cmd> is B<F_ADD_SEALS> and I<arg> includes an unrecognized sealing bit."
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1742
msgid ""
"I<cmd> is B<F_ADD_SEALS> or B<F_GET_SEALS> and the filesystem containing the "
"inode referred to by I<fd> does not support sealing."
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1754
msgid ""
"I<cmd> is B<F_DUPFD> and I<arg> is negative or is greater than the maximum "
"allowable value (see the discussion of B<RLIMIT_NOFILE> in B<getrlimit>(2))."
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1762
msgid "I<cmd> is B<F_SETSIG> and I<arg> is not an allowable signal number."
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1773
msgid ""
"I<cmd> is B<F_OFD_SETLK>, B<F_OFD_SETLKW>, or B<F_OFD_GETLK>, and I<l_pid> "
"was not specified as zero."
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1780
msgid ""
"I<cmd> is B<F_DUPFD> and the per-process limit on the number of open file "
"descriptors has been reached."
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1784
msgid ""
"Too many segment locks open, lock table is full, or a remote locking "
"protocol failed (e.g., locking over NFS)."
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1792
msgid ""
"B<F_NOTIFY> was specified in I<cmd>, but I<fd> does not refer to a "
"directory."
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1799
msgid ""
"I<cmd> is B<F_SETPIPE_SZ> and the soft or hard user pipe limit has been "
"reached; see B<pipe>(7)."
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1804
msgid ""
"Attempted to clear the B<O_APPEND> flag on a file that has the append-only "
"attribute set."
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1814
msgid ""
"I<cmd> was B<F_ADD_SEALS>, but I<fd> was not open for writing or the current "
"set of seals on the file already includes B<F_SEAL_SEAL>."
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1827
msgid ""
"SVr4, 4.3BSD, POSIX.1-2001.  Only the operations B<F_DUPFD>, B<F_GETFD>, "
"B<F_SETFD>, B<F_GETFL>, B<F_SETFL>, B<F_GETLK>, B<F_SETLK>, and B<F_SETLKW> "
"are specified in POSIX.1-2001."
msgstr ""

#.  .BR _BSD_SOURCE ,
#.  or
#. type: Plain text
#: man-pages/man2/fcntl.2:1839
msgid ""
"B<F_GETOWN> and B<F_SETOWN> are specified in POSIX.1-2001.  (To get their "
"definitions, define either B<_XOPEN_SOURCE> with the value 500 or greater, "
"or B<_POSIX_C_SOURCE> with the value 200809L or greater.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1847
msgid ""
"B<F_DUPFD_CLOEXEC> is specified in POSIX.1-2008.  (To get this definition, "
"define B<_POSIX_C_SOURCE> with the value 200809L or greater, or "
"B<_XOPEN_SOURCE> with the value 700 or greater.)"
msgstr ""

#.  .PP
#.  SVr4 documents additional EIO, ENOLINK and EOVERFLOW error conditions.
#. type: Plain text
#: man-pages/man2/fcntl.2:1864
msgid ""
"B<F_GETOWN_EX>, B<F_SETOWN_EX>, B<F_SETPIPE_SZ>, B<F_GETPIPE_SZ>, "
"B<F_GETSIG>, B<F_SETSIG>, B<F_NOTIFY>, B<F_GETLEASE>, and B<F_SETLEASE> are "
"Linux-specific.  (Define the B<_GNU_SOURCE> macro to obtain these "
"definitions.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1873
msgid ""
"B<F_OFD_SETLK>, B<F_OFD_SETLKW>, and B<F_OFD_GETLK> are Linux-specific (and "
"one must define B<_GNU_SOURCE> to obtain their definitions), but work is "
"being done to have them included in the next version of POSIX.1."
msgstr ""

#.  FIXME . Once glibc adds support, add a note about FTM requirements
#. type: Plain text
#: man-pages/man2/fcntl.2:1879
msgid "B<F_ADD_SEALS> and B<F_GET_SEALS> are Linux-specific."
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1885
msgid ""
"The errors returned by B<dup2>(2)  are different from those returned by "
"B<F_DUPFD>."
msgstr ""

#. type: SS
#: man-pages/man2/fcntl.2:1885
#, no-wrap
msgid "File locking"
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1907 man-pages/man2/fcntl.2:1949
msgid ""
"The original Linux B<fcntl>()  system call was not designed to handle large "
"file offsets (in the I<flock> structure).  Consequently, an B<fcntl64>()  "
"system call was added in Linux 2.4.  The newer system call employs a "
"different structure for file locking, I<flock64>, and corresponding "
"commands, B<F_GETLK64>, B<F_SETLK64>, and B<F_SETLKW64>.  However, these "
"details can be ignored by applications using glibc, whose B<fcntl>()  "
"wrapper function transparently employs the more recent system call where it "
"is available."
msgstr ""

#. type: SS
#: man-pages/man2/fcntl.2:1907
#, no-wrap
msgid "Record locks"
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:1913
msgid ""
"Since kernel 2.0, there is no interaction between the types of lock placed "
"by B<flock>(2)  and B<fcntl>()."
msgstr ""

#.  e.g., Solaris 8 documents this field in fcntl(2), and Irix 6.5
#.  documents it in fcntl(5).  mtk, May 2007
#.  Also, FreeBSD documents it (Apr 2014).
#. type: Plain text
#: man-pages/man2/fcntl.2:1928
msgid ""
"Several systems have more fields in I<struct flock> such as, for example, "
"I<l_sysid> (to identify the machine where the lock is held).  Clearly, "
"I<l_pid> alone is not going to be very useful if the process holding the "
"lock may live on a different machine; on Linux, while present on some "
"architectures (such as MIPS32), this field is not used."
msgstr ""

#. type: SS
#: man-pages/man2/fcntl.2:1949
#, no-wrap
msgid "Record locking and NFS"
msgstr ""

#
#.  Neil Brown: With NFSv3 the failure mode is the reverse.  If
#.      the server loses contact with a client then any lock stays in place
#.      indefinitely ("why can't I read my mail"... I remember it well).
#
#
#.  Jeff Layton:
#.      Note that this is not a firm timeout. The server runs a job
#.      periodically to clean out expired stateful objects, and it's likely
#.      that there is some time (maybe even up to another whole lease period)
#.      between when the timeout expires and the job actually runs. If the
#.      client gets a RENEW in there within that window, its lease will be
#.      renewed and its state preserved.
#. type: Plain text
#: man-pages/man2/fcntl.2:1977
msgid ""
"Before Linux 3.12, if an NFSv4 client loses contact with the server for a "
"period of time (defined as more than 90 seconds with no communication), it "
"might lose and regain a lock without ever being aware of the fact.  (The "
"period of time after which contact is assumed lost is known as the NFSv4 "
"leasetime.  On a Linux NFS server, this can be determined by looking at "
"I</proc/fs/nfsd/nfsv4leasetime>, which expresses the period in seconds.  The "
"default value for this file is 90.)  This scenario potentially risks data "
"corruption, since another process might acquire a lock in the intervening "
"period and perform file I/O."
msgstr ""

#.  commit ef1820f9be27b6ad158f433ab38002ab8131db4d
#.  commit f6de7a39c181dfb8a2c534661a53c73afb3081cd
#. type: Plain text
#: man-pages/man2/fcntl.2:1991
msgid ""
"Since Linux 3.12, if an NFSv4 client loses contact with the server, any I/O "
"to the file by a process which \"thinks\" it holds a lock will fail until "
"that process closes and reopens the file.  A kernel parameter, "
"I<nfs.recover_lost_locks>, can be set to 1 to obtain the pre-3.12 behavior, "
"whereby the client will attempt to recover lost locks when contact is "
"reestablished with the server.  Because of the attendant risk of data "
"corruption, this parameter defaults to 0 (disabled)."
msgstr ""

#. type: SS
#: man-pages/man2/fcntl.2:1992
#, no-wrap
msgid "F_SETFL"
msgstr ""

#.  FIXME . According to POSIX.1-2001, O_SYNC should also be modifiable
#.  via fcntl(2), but currently Linux does not permit this
#.  See http://bugzilla.kernel.org/show_bug.cgi?id=5994
#. type: Plain text
#: man-pages/man2/fcntl.2:2004
msgid ""
"It is not possible to use B<F_SETFL> to change the state of the B<O_DSYNC> "
"and B<O_SYNC> flags.  Attempts to change the state of these flags are "
"silently ignored."
msgstr ""

#. type: SS
#: man-pages/man2/fcntl.2:2004
#, no-wrap
msgid "F_GETOWN"
msgstr ""

#.  glibc source: sysdeps/unix/sysv/linux/i386/sysdep.h
#.  mtk, Dec 04: some limited testing on alpha and ia64 seems to
#.  indicate that ANY negative PGID value will cause F_GETOWN
#.  to misinterpret the return as an error. Some other architectures
#.  seem to have the same range check as i386.
#. type: Plain text
#: man-pages/man2/fcntl.2:2030
msgid ""
"A limitation of the Linux system call conventions on some architectures "
"(notably i386) means that if a (negative)  process group ID to be returned "
"by B<F_GETOWN> falls in the range -1 to -4095, then the return value is "
"wrongly interpreted by glibc as an error in the system call; that is, the "
"return value of B<fcntl>()  will be -1, and I<errno> will contain the "
"(positive) process group ID.  The Linux-specific B<F_GETOWN_EX> operation "
"avoids this problem.  Since glibc version 2.11, glibc makes the kernel "
"B<F_GETOWN> problem invisible by implementing B<F_GETOWN> using "
"B<F_GETOWN_EX>."
msgstr ""

#. type: SS
#: man-pages/man2/fcntl.2:2030
#, no-wrap
msgid "F_SETOWN"
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:2048
msgid ""
"In Linux 2.4 and earlier, there is bug that can occur when an unprivileged "
"process uses B<F_SETOWN> to specify the owner of a socket file descriptor as "
"a process (group) other than the caller.  In this case, B<fcntl>()  can "
"return -1 with I<errno> set to B<EPERM>, even when the owner process (group) "
"is one that the caller has permission to send signals to.  Despite this "
"error return, the file descriptor owner is set, and signals will be sent to "
"the owner."
msgstr ""

#. type: SS
#: man-pages/man2/fcntl.2:2048
#, no-wrap
msgid "Deadlock detection"
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:2067
msgid ""
"The deadlock-detection algorithm employed by the kernel when dealing with "
"B<F_SETLKW> requests can yield both false negatives (failures to detect "
"deadlocks, leaving a set of deadlocked processes blocked indefinitely)  and "
"false positives (B<EDEADLK> errors when there is no deadlock).  For example, "
"the kernel limits the lock depth of its dependency search to 10 steps, "
"meaning that circular deadlock chains that exceed that size will not be "
"detected.  In addition, the kernel may falsely indicate a deadlock when two "
"or more processes created using the B<clone>(2)  B<CLONE_FILES> flag place "
"locks that appear (to the kernel) to conflict."
msgstr ""

#.  http://marc.info/?l=linux-kernel&m=119013491707153&w=2
#
#.  Reconfirmed by Jeff Layton
#.      From: Jeff Layton <jlayton <at> redhat.com>
#.      Subject: Re: Status of fcntl() mandatory locking
#.      Newsgroups: gmane.linux.file-systems
#.      Date: 2014-04-28 10:07:57 GMT
#.      http://thread.gmane.org/gmane.linux.file-systems/84481/focus=84518
#. type: Plain text
#: man-pages/man2/fcntl.2:2089
msgid ""
"The Linux implementation of mandatory locking is subject to race conditions "
"which render it unreliable: a B<write>(2)  call that overlaps with a lock "
"may modify data after the mandatory lock is acquired; a B<read>(2)  call "
"that overlaps with a lock may detect changes to data that were made only "
"after a write lock was acquired.  Similar races exist between mandatory "
"locks and B<mmap>(2).  It is therefore inadvisable to rely on mandatory "
"locking."
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:2098
msgid ""
"B<dup2>(2), B<flock>(2), B<open>(2), B<socket>(2), B<lockf>(3), "
"B<capabilities>(7), B<feature_test_macros>(7), B<lslocks>(8)"
msgstr ""

#. type: Plain text
#: man-pages/man2/fcntl.2:2110
msgid ""
"I<locks.txt>, I<mandatory-locking.txt>, and I<dnotify.txt> in the Linux "
"kernel source directory I<Documentation/filesystems/> (on older kernels, "
"these files are directly under the I<Documentation/> directory, and "
"I<mandatory-locking.txt> is called I<mandatory.txt>)"
msgstr ""

#. type: TH
#: man-pages/man2/syscall.2:42
#, no-wrap
msgid "SYSCALL"
msgstr ""

#. type: Plain text
#: man-pages/man2/syscall.2:45
msgid "syscall - indirect system call"
msgstr ""

#. type: Plain text
#: man-pages/man2/syscall.2:50
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>         /* See feature_test_macros(7) */\n"
"B<#include E<lt>unistd.hE<gt>>\n"
"B<#include E<lt>sys/syscall.hE<gt>   >/* For SYS_xxx definitions */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/syscall.2:52
#, no-wrap
msgid "B<long syscall(long >I<number>B<, ...);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/syscall.2:64
msgid ""
"B<syscall>()  is a small library function that invokes the system call whose "
"assembly language interface has the specified I<number> with the specified "
"arguments.  Employing B<syscall>()  is useful, for example, when invoking a "
"system call that has no wrapper function in the C library."
msgstr ""

#. type: Plain text
#: man-pages/man2/syscall.2:71
msgid ""
"B<syscall>()  saves CPU registers before making the system call, restores "
"the registers upon return from the system call, and stores any error code "
"returned by the system call in B<errno>(3)  if an error occurs."
msgstr ""

#. type: Plain text
#: man-pages/man2/syscall.2:74
msgid ""
"Symbolic constants for system call numbers can be found in the header file "
"I<E<lt>sys/syscall.hE<gt>>."
msgstr ""

#. type: Plain text
#: man-pages/man2/syscall.2:80
msgid ""
"The return value is defined by the system call being invoked.  In general, a "
"0 return value indicates success.  A -1 return value indicates an error, and "
"an error code is stored in I<errno>."
msgstr ""

#. type: Plain text
#: man-pages/man2/syscall.2:84
msgid "B<syscall>()  first appeared in 4BSD."
msgstr ""

#. type: SS
#: man-pages/man2/syscall.2:84
#, no-wrap
msgid "Architecture-specific requirements"
msgstr ""

#. type: Plain text
#: man-pages/man2/syscall.2:95
msgid ""
"Each architecture ABI has its own requirements on how system call arguments "
"are passed to the kernel.  For system calls that have a glibc wrapper (e.g., "
"most system calls), glibc handles the details of copying arguments to the "
"right registers in a manner suitable for the architecture.  However, when "
"using B<syscall>()  to make a system call, the caller might need to handle "
"architecture-dependent details; this requirement is most commonly "
"encountered on certain 32-bit architectures."
msgstr ""

#. type: Plain text
#: man-pages/man2/syscall.2:107
msgid ""
"For example, on the ARM architecture Embedded ABI (EABI), a 64-bit value "
"(e.g., I<long long>)  must be aligned to an even register pair.  Thus, using "
"B<syscall>()  instead of the wrapper provided by glibc, the B<readahead>()  "
"system call would be invoked as follows on the ARM architecture with the "
"EABI in little endian mode:"
msgstr ""

#. type: Plain text
#: man-pages/man2/syscall.2:114
#, no-wrap
msgid ""
"syscall(SYS_readahead, fd, 0,\n"
"        (unsigned int) (offset & 0xFFFFFFFF),\n"
"        (unsigned int) (offset E<gt>E<gt> 32),\n"
"        count);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/syscall.2:130
msgid ""
"Since the offset argument is 64 bits, and the first argument (I<fd>)  is "
"passed in I<r0>, the caller must manually split and align the 64-bit value "
"so that it is passed in the I<r2>/I<r3> register pair.  That means inserting "
"a dummy value into I<r1> (the second argument of 0).  Care also must be "
"taken so that the split follows endian conventions (according to the C ABI "
"for the platform)."
msgstr ""

#.  Mike Frysinger: this issue ends up forcing MIPS
#.  O32 to take 7 arguments to syscall()
#. type: Plain text
#: man-pages/man2/syscall.2:135
msgid ""
"Similar issues can occur on MIPS with the O32 ABI, on PowerPC and parisc "
"with the 32-bit ABI, and on Xtensa."
msgstr ""

#.  See arch/parisc/kernel/sys_parisc.c.
#. type: Plain text
#: man-pages/man2/syscall.2:139
msgid ""
"Note that while the parisc C ABI also uses aligned register pairs, it uses a "
"shim layer to hide the issue from user space."
msgstr ""

#. type: Plain text
#: man-pages/man2/syscall.2:150
msgid ""
"The affected system calls are B<fadvise64_64>(2), B<ftruncate64>(2), "
"B<posix_fadvise>(2), B<pread64>(2), B<pwrite64>(2), B<readahead>(2), "
"B<sync_file_range>(2), and B<truncate64>(2)."
msgstr ""

#.  You need to look up the syscalls directly in the kernel source to see if
#.  they should be in this list.  For example, look at fs/read_write.c and
#.  the function signatures that do:
#.  ..., unsigned long, pos_l, unsigned long, pos_h, ...
#.  If they use off_t, then they most likely do not belong in this list.
#. type: Plain text
#: man-pages/man2/syscall.2:165
msgid ""
"This does not affect syscalls that manually split and assemble 64-bit values "
"such as B<_llseek>(2), B<preadv>(2), B<preadv2>(2), B<pwritev>(2), and "
"B<pwritev2>(2).  Welcome to the wonderful world of historical baggage."
msgstr ""

#. type: SS
#: man-pages/man2/syscall.2:165
#, no-wrap
msgid "Architecture calling conventions"
msgstr ""

#. type: Plain text
#: man-pages/man2/syscall.2:169
msgid ""
"Every architecture has its own way of invoking and passing arguments to the "
"kernel.  The details for various architectures are listed in the two tables "
"below."
msgstr ""

#. type: Plain text
#: man-pages/man2/syscall.2:177
msgid ""
"The first table lists the instruction used to transition to kernel mode "
"(which might not be the fastest or best way to transition to the kernel, so "
"you might have to refer to B<vdso>(7)), the register used to indicate the "
"system call number, the register(s) used to return the system call result, "
"and the register used to signal an error."
msgstr ""

#. type: Plain text
#: man-pages/man2/syscall.2:180 man-pages/man2/syscall.2:307
#: man-pages/man2/syscall.2:312 man-pages/man2/syscall.2:352
msgid "\\}"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscall.2:182 man-pages/man2/syscall.2:314
#, no-wrap
msgid "Arch/ABI"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscall.2:182
#, no-wrap
msgid "Instruction"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscall.2:182
#, no-wrap
msgid "System"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscall.2:182
#, no-wrap
msgid "Ret"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscall.2:182
#, no-wrap
msgid "Error"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscall.2:182 man-pages/man2/syscall.2:314
#, no-wrap
msgid "Notes"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscall.2:183
#, no-wrap
msgid "call #"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscall.2:183
#, no-wrap
msgid "val"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscall.2:183
#, no-wrap
msgid "val2"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscall.2:184 man-pages/man2/syscall.2:315
#, no-wrap
msgid "_"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscall.2:185 man-pages/man2/syscall.2:316
#, no-wrap
msgid "alpha"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscall.2:185
#, no-wrap
msgid "callsys"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscall.2:185 man-pages/man2/syscall.2:195
#, no-wrap
msgid "v0"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscall.2:185 man-pages/man2/syscall.2:316
#: man-pages/man2/syscall.2:318 man-pages/man2/syscall.2:327
#: man-pages/man2/syscall.2:332 man-pages/man2/syscall.2:341
#, no-wrap
msgid "a4"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscall.2:185 man-pages/man2/syscall.2:195
#: man-pages/man2/syscall.2:316 man-pages/man2/syscall.2:318
#: man-pages/man2/syscall.2:326 man-pages/man2/syscall.2:327
#: man-pages/man2/syscall.2:332 man-pages/man2/syscall.2:341
#, no-wrap
msgid "a3"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscall.2:185 man-pages/man2/syscall.2:192
#: man-pages/man2/syscall.2:195 man-pages/man2/syscall.2:204
#: man-pages/man2/syscall.2:205
#, no-wrap
msgid "1, 6"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscall.2:186 man-pages/man2/syscall.2:317
#, no-wrap
msgid "arc"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscall.2:186
#, no-wrap
msgid "trap0"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscall.2:186 man-pages/man2/syscall.2:192
#: man-pages/man2/syscall.2:325 man-pages/man2/syscall.2:328
#: man-pages/man2/syscall.2:330 man-pages/man2/syscall.2:331
#: man-pages/man2/syscall.2:339 man-pages/man2/syscall.2:340
#, no-wrap
msgid "r8"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscall.2:186 man-pages/man2/syscall.2:188
#: man-pages/man2/syscall.2:198 man-pages/man2/syscall.2:199
#: man-pages/man2/syscall.2:203 man-pages/man2/syscall.2:317
#: man-pages/man2/syscall.2:319 man-pages/man2/syscall.2:335
#, no-wrap
msgid "r0"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscall.2:187 man-pages/man2/syscall.2:318
#, no-wrap
msgid "arm/OABI"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscall.2:187
#, no-wrap
msgid "swi NR"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscall.2:187 man-pages/man2/syscall.2:200
#: man-pages/man2/syscall.2:316 man-pages/man2/syscall.2:318
#: man-pages/man2/syscall.2:326 man-pages/man2/syscall.2:327
#: man-pages/man2/syscall.2:332
#, no-wrap
msgid "a1"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscall.2:188 man-pages/man2/syscall.2:319
#, no-wrap
msgid "arm/EABI"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscall.2:188
#, no-wrap
msgid "swi 0x0"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscall.2:188 man-pages/man2/syscall.2:196
#: man-pages/man2/syscall.2:325 man-pages/man2/syscall.2:328
#: man-pages/man2/syscall.2:330 man-pages/man2/syscall.2:331
#: man-pages/man2/syscall.2:333 man-pages/man2/syscall.2:334
#: man-pages/man2/syscall.2:335
#, no-wrap
msgid "r7"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscall.2:188 man-pages/man2/syscall.2:201
#: man-pages/man2/syscall.2:202 man-pages/man2/syscall.2:203
#: man-pages/man2/syscall.2:317 man-pages/man2/syscall.2:319
#: man-pages/man2/syscall.2:335
#, no-wrap
msgid "r1"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscall.2:189 man-pages/man2/syscall.2:320
#, no-wrap
msgid "arm64"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscall.2:189
#, no-wrap
msgid "svc #0"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscall.2:189
#, no-wrap
msgid "x8"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscall.2:189 man-pages/man2/syscall.2:320
#, no-wrap
msgid "x0"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscall.2:189 man-pages/man2/syscall.2:320
#, no-wrap
msgid "x1"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscall.2:190 man-pages/man2/syscall.2:321
#, no-wrap
msgid "blackfin"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscall.2:190
#, no-wrap
msgid "excpt 0x0"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscall.2:190
#, no-wrap
msgid "P0"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscall.2:190 man-pages/man2/syscall.2:321
#, no-wrap
msgid "R0"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscall.2:191 man-pages/man2/syscall.2:322
#, no-wrap
msgid "i386"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscall.2:191
#, no-wrap
msgid "int $0x80"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscall.2:191
#, no-wrap
msgid "eax"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscall.2:191 man-pages/man2/syscall.2:322
#, no-wrap
msgid "edx"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscall.2:192
#, no-wrap
msgid "break 0x100000"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscall.2:192
#, no-wrap
msgid "r15"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscall.2:192 man-pages/man2/syscall.2:325
#: man-pages/man2/syscall.2:328 man-pages/man2/syscall.2:330
#: man-pages/man2/syscall.2:339 man-pages/man2/syscall.2:340
#, no-wrap
msgid "r9"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscall.2:192 man-pages/man2/syscall.2:325
#: man-pages/man2/syscall.2:339 man-pages/man2/syscall.2:340
#, no-wrap
msgid "r10"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscall.2:193 man-pages/man2/syscall.2:324
#, no-wrap
msgid "m68k"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscall.2:193
#, no-wrap
msgid "trap #0"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscall.2:193
#, no-wrap
msgid "d0"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscall.2:194 man-pages/man2/syscall.2:325
#, no-wrap
msgid "microblaze"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscall.2:194
#, no-wrap
msgid "brki r14,8"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscall.2:194
#, no-wrap
msgid "r12"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscall.2:194 man-pages/man2/syscall.2:198
#: man-pages/man2/syscall.2:199 man-pages/man2/syscall.2:201
#: man-pages/man2/syscall.2:202 man-pages/man2/syscall.2:203
#: man-pages/man2/syscall.2:317 man-pages/man2/syscall.2:319
#: man-pages/man2/syscall.2:330 man-pages/man2/syscall.2:331
#: man-pages/man2/syscall.2:333 man-pages/man2/syscall.2:334
#, no-wrap
msgid "r3"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscall.2:195
#, no-wrap
msgid "mips"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscall.2:195 man-pages/man2/syscall.2:207
#: man-pages/man2/syscall.2:208 man-pages/man2/syscall.2:209
#, no-wrap
msgid "syscall"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscall.2:195 man-pages/man2/syscall.2:318
#, no-wrap
msgid "v1"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscall.2:196 man-pages/man2/syscall.2:328
#, no-wrap
msgid "nios2"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscall.2:196
#, no-wrap
msgid "trap"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscall.2:196 man-pages/man2/syscall.2:201
#: man-pages/man2/syscall.2:202 man-pages/man2/syscall.2:317
#: man-pages/man2/syscall.2:319 man-pages/man2/syscall.2:333
#: man-pages/man2/syscall.2:334 man-pages/man2/syscall.2:335
#, no-wrap
msgid "r2"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscall.2:197 man-pages/man2/syscall.2:329
#, no-wrap
msgid "parisc"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscall.2:197
#, no-wrap
msgid "ble 0x100(%sr2, %r0)"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscall.2:197
#, no-wrap
msgid "r20"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscall.2:197
#, no-wrap
msgid "r28"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscall.2:198 man-pages/man2/syscall.2:330
#, no-wrap
msgid "powerpc"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscall.2:198 man-pages/man2/syscall.2:199
#, no-wrap
msgid "sc"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscall.2:199 man-pages/man2/syscall.2:331
#, no-wrap
msgid "powerpc64"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscall.2:199
#, no-wrap
msgid "cr0.SO"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscall.2:200 man-pages/man2/syscall.2:332
#, no-wrap
msgid "riscv"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscall.2:200
#, no-wrap
msgid "ecall"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscall.2:200
#, no-wrap
msgid "a7"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscall.2:200 man-pages/man2/syscall.2:316
#: man-pages/man2/syscall.2:324 man-pages/man2/syscall.2:326
#: man-pages/man2/syscall.2:327 man-pages/man2/syscall.2:332
#, no-wrap
msgid "a0"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscall.2:201 man-pages/man2/syscall.2:333
#, no-wrap
msgid "s390"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscall.2:201 man-pages/man2/syscall.2:202
#, no-wrap
msgid "svc 0"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscall.2:202 man-pages/man2/syscall.2:334
#, no-wrap
msgid "s390x"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscall.2:203 man-pages/man2/syscall.2:335
#, no-wrap
msgid "superh"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscall.2:203
#, no-wrap
msgid "trap #0x17"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscall.2:203
#, no-wrap
msgid "4, 6"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscall.2:204 man-pages/man2/syscall.2:336
#, no-wrap
msgid "sparc/32"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscall.2:204
#, no-wrap
msgid "t 0x10"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscall.2:204 man-pages/man2/syscall.2:205
#, no-wrap
msgid "g1"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscall.2:204 man-pages/man2/syscall.2:205
#: man-pages/man2/syscall.2:336 man-pages/man2/syscall.2:337
#, no-wrap
msgid "o0"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscall.2:204 man-pages/man2/syscall.2:205
#: man-pages/man2/syscall.2:336 man-pages/man2/syscall.2:337
#, no-wrap
msgid "o1"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscall.2:204 man-pages/man2/syscall.2:205
#, no-wrap
msgid "psr/csr"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscall.2:205 man-pages/man2/syscall.2:337
#, no-wrap
msgid "sparc/64"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscall.2:205
#, no-wrap
msgid "t 0x6d"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscall.2:206 man-pages/man2/syscall.2:338
#, no-wrap
msgid "tile"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscall.2:206
#, no-wrap
msgid "swint1"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscall.2:206
#, no-wrap
msgid "R10"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscall.2:206 man-pages/man2/syscall.2:338
#, no-wrap
msgid "R00"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscall.2:206 man-pages/man2/syscall.2:338
#, no-wrap
msgid "R01"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscall.2:207 man-pages/man2/syscall.2:339
#, no-wrap
msgid "x86-64"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscall.2:207 man-pages/man2/syscall.2:208
#, no-wrap
msgid "rax"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscall.2:207 man-pages/man2/syscall.2:208
#: man-pages/man2/syscall.2:339 man-pages/man2/syscall.2:340
#, no-wrap
msgid "rdx"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscall.2:208 man-pages/man2/syscall.2:340
#, no-wrap
msgid "x32"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscall.2:209 man-pages/man2/syscall.2:341
#, no-wrap
msgid "xtensa"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscall.2:209 man-pages/man2/syscall.2:316
#: man-pages/man2/syscall.2:318 man-pages/man2/syscall.2:326
#: man-pages/man2/syscall.2:327 man-pages/man2/syscall.2:332
#, no-wrap
msgid "a2"
msgstr ""

#. type: Plain text
#: man-pages/man2/syscall.2:213 man-pages/man2/syscall.2:345
msgid "Notes:"
msgstr ""

#. type: Plain text
#: man-pages/man2/syscall.2:229
msgid ""
"On a few architectures, a register is used as a boolean (0 indicating no "
"error, and -1 indicating an error) to signal that the system call failed.  "
"The actual error value is still contained in the return register.  On sparc, "
"the carry bit (I<csr>)  in the processor status register (I<psr>)  is used "
"instead of a full register.  On powerpc64, the summary overflow bit (I<SO>)  "
"in field 0 of the condition register (I<cr0>)  is used."
msgstr ""

#. type: Plain text
#: man-pages/man2/syscall.2:232
msgid "I<NR> is the system call number."
msgstr ""

#. type: Plain text
#: man-pages/man2/syscall.2:238
msgid ""
"For s390 and s390x, I<NR> (the system call number) may be passed directly "
"with I<svc\\ NR> if it is less than 256."
msgstr ""

#. type: Plain text
#: man-pages/man2/syscall.2:248
msgid ""
"On SuperH, the trap number controls the maximum number of arguments passed.  "
"A I<trap\\ #0x10> can be used with only 0-argument system calls, a I<trap\\ "
"#0x11> can be used with 0- or 1-argument system calls, and so on up to "
"I<trap #0x17> for 7-argument system calls."
msgstr ""

#. type: Plain text
#: man-pages/man2/syscall.2:251
msgid ""
"The x32 ABI shares syscall table with x86-64 ABI, but there are some "
"nuances:"
msgstr ""

#. type: Plain text
#: man-pages/man2/syscall.2:259
msgid ""
"In order to indicate that a system call is called under the x32 ABI, an "
"additional bit, B<__X32_SYSCALL_BIT>, is bitwise-ORed with the system call "
"number.  The ABI used by a process affects some process behaviors, including "
"signal handling or system call restarting."
msgstr ""

#. type: Plain text
#: man-pages/man2/syscall.2:287
msgid ""
"Since x32 has different sizes for I<long> and pointer types, layouts of some "
"(but not all; I<struct timeval> or I<struct rlimit> are 64-bit, for example) "
"structures are different.  In order to handle this, additional system calls "
"are added to the system call table, starting from number 512 (without the "
"B<__X32_SYSCALL_BIT>).  For example, B<__NR_readv> is defined as 19 for the "
"x86-64 ABI and as I<__X32_SYSCALL_BIT> | B<515> for the x32 ABI.  Most of "
"these additional system calls are actually identical to the system calls "
"used for providing i386 compat.  There are some notable exceptions, however, "
"such as B<preadv2>(2), which uses I<struct iovec> entities with 4-byte "
"pointers and sizes (\"compat_iovec\" in kernel terms), but passes an 8-byte "
"I<pos> argument in a single register and not two, as is done in every other "
"ABI."
msgstr ""

#. type: Plain text
#: man-pages/man2/syscall.2:303
msgid ""
"Some architectures (namely, Alpha, IA-64, MIPS, SuperH, sparc/32, and "
"sparc/64)  use an additional register (\"Retval2\" in the above table)  to "
"pass back a second return value from the B<pipe>(2)  system call; Alpha uses "
"this technique in the architecture-specific B<getxpid>(2), B<getxuid>(2), "
"and B<getxgid>(2)  system calls as well.  Other architectures do not use the "
"second return value register in the system call interface, even if it is "
"defined in the System V ABI."
msgstr ""

#. type: Plain text
#: man-pages/man2/syscall.2:309
msgid "The second table shows the registers used to pass the system call arguments."
msgstr ""

#. type: tbl table
#: man-pages/man2/syscall.2:314
#, no-wrap
msgid "arg1"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscall.2:314
#, no-wrap
msgid "arg2"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscall.2:314
#, no-wrap
msgid "arg3"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscall.2:314
#, no-wrap
msgid "arg4"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscall.2:314
#, no-wrap
msgid "arg5"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscall.2:314
#, no-wrap
msgid "arg6"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscall.2:314
#, no-wrap
msgid "arg7"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscall.2:316 man-pages/man2/syscall.2:327
#: man-pages/man2/syscall.2:332 man-pages/man2/syscall.2:341
#, no-wrap
msgid "a5"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscall.2:317 man-pages/man2/syscall.2:319
#: man-pages/man2/syscall.2:328 man-pages/man2/syscall.2:330
#: man-pages/man2/syscall.2:331 man-pages/man2/syscall.2:333
#: man-pages/man2/syscall.2:334 man-pages/man2/syscall.2:335
#, no-wrap
msgid "r4"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscall.2:317 man-pages/man2/syscall.2:319
#: man-pages/man2/syscall.2:325 man-pages/man2/syscall.2:328
#: man-pages/man2/syscall.2:330 man-pages/man2/syscall.2:331
#: man-pages/man2/syscall.2:333 man-pages/man2/syscall.2:334
#: man-pages/man2/syscall.2:335
#, no-wrap
msgid "r5"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscall.2:318
#, no-wrap
msgid "v2"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscall.2:318
#, no-wrap
msgid "v3"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscall.2:319 man-pages/man2/syscall.2:325
#: man-pages/man2/syscall.2:328 man-pages/man2/syscall.2:330
#: man-pages/man2/syscall.2:331 man-pages/man2/syscall.2:333
#: man-pages/man2/syscall.2:334 man-pages/man2/syscall.2:335
#, no-wrap
msgid "r6"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscall.2:320
#, no-wrap
msgid "x2"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscall.2:320
#, no-wrap
msgid "x3"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscall.2:320
#, no-wrap
msgid "x4"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscall.2:320
#, no-wrap
msgid "x5"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscall.2:321
#, no-wrap
msgid "R1"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscall.2:321
#, no-wrap
msgid "R2"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscall.2:321
#, no-wrap
msgid "R3"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscall.2:321
#, no-wrap
msgid "R4"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscall.2:321
#, no-wrap
msgid "R5"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscall.2:322
#, no-wrap
msgid "ebx"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscall.2:322
#, no-wrap
msgid "ecx"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscall.2:322
#, no-wrap
msgid "esi"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscall.2:322
#, no-wrap
msgid "edi"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscall.2:322
#, no-wrap
msgid "ebp"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscall.2:323
#, no-wrap
msgid "out0"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscall.2:323
#, no-wrap
msgid "out1"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscall.2:323
#, no-wrap
msgid "out2"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscall.2:323
#, no-wrap
msgid "out3"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscall.2:323
#, no-wrap
msgid "out4"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscall.2:323
#, no-wrap
msgid "out5"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscall.2:324
#, no-wrap
msgid "d1"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscall.2:324
#, no-wrap
msgid "d2"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscall.2:324
#, no-wrap
msgid "d3"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscall.2:324
#, no-wrap
msgid "d4"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscall.2:324
#, no-wrap
msgid "d5"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscall.2:326
#, no-wrap
msgid "mips/o32"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscall.2:327
#, no-wrap
msgid "mips/n32,64"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscall.2:329
#, no-wrap
msgid "r26"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscall.2:329
#, no-wrap
msgid "r25"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscall.2:329
#, no-wrap
msgid "r24"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscall.2:329
#, no-wrap
msgid "r23"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscall.2:329
#, no-wrap
msgid "r22"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscall.2:329
#, no-wrap
msgid "r21"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscall.2:336 man-pages/man2/syscall.2:337
#, no-wrap
msgid "o2"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscall.2:336 man-pages/man2/syscall.2:337
#, no-wrap
msgid "o3"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscall.2:336 man-pages/man2/syscall.2:337
#, no-wrap
msgid "o4"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscall.2:336 man-pages/man2/syscall.2:337
#, no-wrap
msgid "o5"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscall.2:338
#, no-wrap
msgid "R02"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscall.2:338
#, no-wrap
msgid "R03"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscall.2:338
#, no-wrap
msgid "R04"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscall.2:338
#, no-wrap
msgid "R05"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscall.2:339 man-pages/man2/syscall.2:340
#, no-wrap
msgid "rdi"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscall.2:339 man-pages/man2/syscall.2:340
#, no-wrap
msgid "rsi"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscall.2:341
#, no-wrap
msgid "a6"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscall.2:341
#, no-wrap
msgid "a8"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscall.2:341
#, no-wrap
msgid "a9"
msgstr ""

#. type: Plain text
#: man-pages/man2/syscall.2:348
msgid ""
"The mips/o32 system call convention passes arguments 5 through 8 on the user "
"stack."
msgstr ""

#. type: Plain text
#: man-pages/man2/syscall.2:355
msgid ""
"Note that these tables don't cover the entire calling convention\\(emsome "
"architectures may indiscriminately clobber other registers not listed here."
msgstr ""

#. type: Plain text
#: man-pages/man2/syscall.2:362
#, no-wrap
msgid ""
"#define _GNU_SOURCE\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>sys/syscall.hE<gt>\n"
"#include E<lt>sys/types.hE<gt>\n"
"#include E<lt>signal.hE<gt>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/syscall.2:367
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    pid_t tid;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/syscall.2:371
#, no-wrap
msgid ""
"    tid = syscall(SYS_gettid);\n"
"    syscall(SYS_tgkill, getpid(), tid, SIGHUP);\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/syscall.2:377
msgid "B<_syscall>(2), B<intro>(2), B<syscalls>(2), B<errno>(3), B<vdso>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/setns.2:8
#, no-wrap
msgid "SETNS"
msgstr ""

#. type: Plain text
#: man-pages/man2/setns.2:11
msgid "setns - reassociate thread with a namespace"
msgstr ""

#. type: Plain text
#: man-pages/man2/setns.2:15 man-pages/man2/sched_setaffinity.2:42
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>             /* See feature_test_macros(7) */\n"
"B<#include E<lt>sched.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/setns.2:17
#, no-wrap
msgid "B<int setns(int >I<fd>B<, int >I<nstype>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/setns.2:21
msgid ""
"Given a file descriptor referring to a namespace, reassociate the calling "
"thread with that namespace."
msgstr ""

#. type: Plain text
#: man-pages/man2/setns.2:34
msgid ""
"The I<fd> argument is a file descriptor referring to one of the namespace "
"entries in a I</proc/[pid]/ns/> directory; see B<namespaces>(7)  for further "
"information on I</proc/[pid]/ns/>.  The calling thread will be reassociated "
"with the corresponding namespace, subject to any constraints imposed by the "
"I<nstype> argument."
msgstr ""

#. type: Plain text
#: man-pages/man2/setns.2:40
msgid ""
"The I<nstype> argument specifies which type of namespace the calling thread "
"may be reassociated with.  This argument can have one of the following "
"values:"
msgstr ""

#. type: Plain text
#: man-pages/man2/setns.2:43
msgid "Allow any type of namespace to be joined."
msgstr ""

#. type: Plain text
#: man-pages/man2/setns.2:47
msgid "I<fd> must refer to a cgroup namespace."
msgstr ""

#. type: TP
#: man-pages/man2/setns.2:47
#, no-wrap
msgid "B<CLONE_NEWIPC> (since Linux 3.0)"
msgstr ""

#. type: Plain text
#: man-pages/man2/setns.2:51
msgid "I<fd> must refer to an IPC namespace."
msgstr ""

#. type: TP
#: man-pages/man2/setns.2:51
#, no-wrap
msgid "B<CLONE_NEWNET> (since Linux 3.0)"
msgstr ""

#. type: Plain text
#: man-pages/man2/setns.2:55
msgid "I<fd> must refer to a network namespace."
msgstr ""

#. type: TP
#: man-pages/man2/setns.2:55
#, no-wrap
msgid "B<CLONE_NEWNS> (since Linux 3.8)"
msgstr ""

#. type: Plain text
#: man-pages/man2/setns.2:59
msgid "I<fd> must refer to a mount namespace."
msgstr ""

#. type: Plain text
#: man-pages/man2/setns.2:63
msgid "I<fd> must refer to a descendant PID namespace."
msgstr ""

#. type: Plain text
#: man-pages/man2/setns.2:67
msgid "I<fd> must refer to a user namespace."
msgstr ""

#. type: TP
#: man-pages/man2/setns.2:67
#, no-wrap
msgid "B<CLONE_NEWUTS> (since Linux 3.0)"
msgstr ""

#. type: Plain text
#: man-pages/man2/setns.2:71
msgid "I<fd> must refer to a UTS namespace."
msgstr ""

#. type: Plain text
#: man-pages/man2/setns.2:87
msgid ""
"Specifying I<nstype> as 0 suffices if the caller knows (or does not care)  "
"what type of namespace is referred to by I<fd>.  Specifying a nonzero value "
"for I<nstype> is useful if the caller does not know what type of namespace "
"is referred to by I<fd> and wants to ensure that the namespace is of a "
"particular type.  (The caller might not know the type of the namespace "
"referred to by I<fd> if the file descriptor was opened by another process "
"and, for example, passed to the caller via a UNIX domain socket.)"
msgstr ""

#. type: SS
#: man-pages/man2/setns.2:87
#, no-wrap
msgid "Details for specific namespace types"
msgstr ""

#. type: Plain text
#: man-pages/man2/setns.2:90
msgid ""
"Note the following details and restrictions when reassociating with specific "
"namespace types:"
msgstr ""

#. type: TP
#: man-pages/man2/setns.2:90
#, no-wrap
msgid "User namespaces"
msgstr ""

#.  See kernel/user_namespace.c:userns_install() [3.8 source]
#. type: Plain text
#: man-pages/man2/setns.2:101
msgid ""
"A process reassociating itself with a user namespace must have the "
"B<CAP_SYS_ADMIN> capability in the target user namespace.  (This necessarily "
"implies that it is only possible to join a descendant user namespace.)  Upon "
"successfully joining a user namespace, a process is granted all capabilities "
"in that namespace, regardless of its user and group IDs."
msgstr ""

#. type: Plain text
#: man-pages/man2/setns.2:104
msgid "A multithreaded process may not change user namespace with B<setns>()."
msgstr ""

#. type: Plain text
#: man-pages/man2/setns.2:111
msgid ""
"It is not permitted to use B<setns>()  to reenter the caller's current user "
"namespace.  This prevents a caller that has dropped capabilities from "
"regaining those capabilities via a call to B<setns>()."
msgstr ""

#.  commit e66eded8309ebf679d3d3c1f5820d1f2ca332c71
#.  https://lwn.net/Articles/543273/
#. type: Plain text
#: man-pages/man2/setns.2:121
msgid ""
"For security reasons, a process can't join a new user namespace if it is "
"sharing filesystem-related attributes (the attributes whose sharing is "
"controlled by the B<clone>(2)  B<CLONE_FS> flag) with another process."
msgstr ""

#. type: Plain text
#: man-pages/man2/setns.2:124
msgid "For further details on user namespaces, see B<user_namespaces>(7)."
msgstr ""

#. type: Plain text
#: man-pages/man2/setns.2:133
msgid ""
"Changing the mount namespace requires that the caller possess both "
"B<CAP_SYS_CHROOT> and B<CAP_SYS_ADMIN> capabilities in its own user "
"namespace and B<CAP_SYS_ADMIN> in the user namespace that owns the target "
"mount namespace."
msgstr ""

#.  Above check is in fs/namespace.c:mntns_install() [3.8 source]
#. type: Plain text
#: man-pages/man2/setns.2:141
msgid ""
"A process can't join a new mount namespace if it is sharing "
"filesystem-related attributes (the attributes whose sharing is controlled by "
"the B<clone>(2)  B<CLONE_FS> flag) with another process."
msgstr ""

#. type: Plain text
#: man-pages/man2/setns.2:145
msgid ""
"See B<user_namespaces>(7)  for details on the interaction of user namespaces "
"and mount namespaces."
msgstr ""

#. type: TP
#: man-pages/man2/setns.2:145
#, no-wrap
msgid "PID namespaces"
msgstr ""

#. type: Plain text
#: man-pages/man2/setns.2:152
msgid ""
"In order to reassociate itself with a new PID namespace, the caller must "
"have the B<CAP_SYS_ADMIN> capability both in its own user namespace and in "
"the user namespace that owns the target PID namespace."
msgstr ""

#. type: Plain text
#: man-pages/man2/setns.2:161
msgid ""
"If I<fd> refers to a PID namespace, the semantics are somewhat different "
"from other namespace types: reassociating the calling thread with a PID "
"namespace changes only the PID namespace that subsequently created child "
"processes of the caller will be placed in; it does not change the PID "
"namespace of the caller itself."
msgstr ""

#. type: Plain text
#: man-pages/man2/setns.2:167
msgid ""
"Reassociating with a PID namespace is allowed only if the PID namespace "
"specified by I<fd> is a descendant (child, grandchild, etc.)  of the PID "
"namespace of the caller."
msgstr ""

#. type: Plain text
#: man-pages/man2/setns.2:170
msgid "For further details on PID namespaces, see B<pid_namespaces>(7)."
msgstr ""

#. type: TP
#: man-pages/man2/setns.2:170
#, no-wrap
msgid "Cgroup namespaces"
msgstr ""

#. type: Plain text
#: man-pages/man2/setns.2:177
msgid ""
"In order to reassociate itself with a new cgroup namespace, the caller must "
"have the B<CAP_SYS_ADMIN> capability both in its own user namespace and in "
"the user namespace that owns the target cgroup namespace."
msgstr ""

#. type: Plain text
#: man-pages/man2/setns.2:182
msgid ""
"Using B<setns>()  to change the caller's cgroup namespace does not change "
"the caller's cgroup memberships."
msgstr ""

#. type: TP
#: man-pages/man2/setns.2:182
#, no-wrap
msgid "Network, IPC, and UTS namespaces"
msgstr ""

#. type: Plain text
#: man-pages/man2/setns.2:189
msgid ""
"In order to reassociate itself with a new network, IPC, or UTS namespace, "
"the caller must have the B<CAP_SYS_ADMIN> capability both in its own user "
"namespace and in the user namespace that owns the target namespace."
msgstr ""

#. type: Plain text
#: man-pages/man2/setns.2:196
msgid ""
"On success, B<setns>()  returns 0.  On failure, -1 is returned and I<errno> "
"is set to indicate the error."
msgstr ""

#. type: Plain text
#: man-pages/man2/setns.2:206
msgid ""
"I<fd> refers to a namespace whose type does not match that specified in "
"I<nstype>."
msgstr ""

#. type: Plain text
#: man-pages/man2/setns.2:210
msgid "There is problem with reassociating the thread with the specified namespace."
msgstr ""

#. type: Plain text
#: man-pages/man2/setns.2:215
msgid ""
"The caller tried to join an ancestor (parent, grandparent, and so on)  PID "
"namespace."
msgstr ""

#. type: Plain text
#: man-pages/man2/setns.2:219
msgid ""
"The caller attempted to join the user namespace in which it is already a "
"member."
msgstr ""

#.  commit e66eded8309ebf679d3d3c1f5820d1f2ca332c71
#. type: Plain text
#: man-pages/man2/setns.2:226
msgid ""
"The caller shares filesystem (B<CLONE_FS>)  state (in particular, the root "
"directory)  with other processes and tried to join a new user namespace."
msgstr ""

#.  See kernel/user_namespace.c::userns_install() [kernel 3.15 sources]
#. type: Plain text
#: man-pages/man2/setns.2:230
msgid "The caller is multithreaded and tried to join a new user namespace."
msgstr ""

#. type: Plain text
#: man-pages/man2/setns.2:233
msgid "Cannot allocate sufficient memory to change the specified namespace."
msgstr ""

#. type: Plain text
#: man-pages/man2/setns.2:237
msgid "The calling thread did not have the required capability for this operation."
msgstr ""

#. type: Plain text
#: man-pages/man2/setns.2:242
msgid ""
"The B<setns>()  system call first appeared in Linux in kernel 3.0; library "
"support was added to glibc in version 2.14."
msgstr ""

#. type: Plain text
#: man-pages/man2/setns.2:246
msgid "The B<setns>()  system call is Linux-specific."
msgstr ""

#. type: Plain text
#: man-pages/man2/setns.2:252
msgid ""
"Not all of the attributes that can be shared when a new thread is created "
"using B<clone>(2)  can be changed using B<setns>()."
msgstr ""

#. type: Plain text
#: man-pages/man2/setns.2:261
msgid ""
"The program below takes two or more arguments.  The first argument specifies "
"the pathname of a namespace file in an existing I</proc/[pid]/ns/> "
"directory.  The remaining arguments specify a command and its arguments.  "
"The program opens the namespace file, joins that namespace using B<setns>(), "
"and executes the specified command inside that namespace."
msgstr ""

#. type: Plain text
#: man-pages/man2/setns.2:271
msgid ""
"The following shell session demonstrates the use of this program (compiled "
"as a binary named I<ns_exec>)  in conjunction with the B<CLONE_NEWUTS> "
"example program in the B<clone>(2)  man page (complied as a binary named "
"I<newuts>)."
msgstr ""

#. type: Plain text
#: man-pages/man2/setns.2:279
msgid ""
"We begin by executing the example program in B<clone>(2)  in the "
"background.  That program creates a child in a separate UTS namespace.  The "
"child changes the hostname in its namespace, and then both processes display "
"the hostnames in their UTS namespaces, so that we can see that they are "
"different."
msgstr ""

#. type: Plain text
#: man-pages/man2/setns.2:291
#, no-wrap
msgid ""
"$ B<su>                   # Need privilege for namespace operations\n"
"Password:\n"
"# B<./newuts bizarro &>\n"
"[1] 3549\n"
"clone() returned 3550\n"
"uts.nodename in child:  bizarro\n"
"uts.nodename in parent: antero\n"
"# B<uname -n>             # Verify hostname in the shell\n"
"antero\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/setns.2:298
msgid ""
"We then run the program shown below, using it to execute a shell.  Inside "
"that shell, we verify that the hostname is the one set by the child created "
"by the first program:"
msgstr ""

#. type: Plain text
#: man-pages/man2/setns.2:304
#, no-wrap
msgid ""
"# B<./ns_exec /proc/3550/ns/uts /bin/bash>\n"
"# B<uname -n>             # Executed in shell started by ns_exec\n"
"bizarro\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/setns.2:314
#, no-wrap
msgid ""
"#define _GNU_SOURCE\n"
"#include E<lt>fcntl.hE<gt>\n"
"#include E<lt>sched.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/setns.2:322
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int fd;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/setns.2:327
#, no-wrap
msgid ""
"    if (argc E<lt> 3) {\n"
"        fprintf(stderr, \"%s /proc/PID/ns/FILE cmd args...\\en\", "
"argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/setns.2:331
#, no-wrap
msgid ""
"    fd = open(argv[1], O_RDONLY); /* Get file descriptor for namespace */\n"
"    if (fd == -1)\n"
"        errExit(\"open\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/setns.2:334
#, no-wrap
msgid ""
"    if (setns(fd, 0) == -1)       /* Join that namespace */\n"
"        errExit(\"setns\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/setns.2:338
#, no-wrap
msgid ""
"    execvp(argv[2], &argv[2]);    /* Execute a command in namespace */\n"
"    errExit(\"execvp\");\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/setns.2:346
msgid ""
"B<nsenter>(1), B<clone>(2), B<fork>(2), B<unshare>(2), B<vfork>(2), "
"B<namespaces>(7), B<unix>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/mmap.2:40
#, no-wrap
msgid "MMAP"
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:43
msgid "mmap, munmap - map or unmap files or devices into memory"
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:51
#, no-wrap
msgid ""
"B<void *mmap(void *>I<addr>B<, size_t >I<length>B<, int >I<prot>B<, int "
">I<flags>B<,>\n"
"B<           int >I<fd>B<, off_t >I<offset>B<);>\n"
"B<int munmap(void *>I<addr>B<, size_t >I<length>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:54
msgid "See NOTES for information on feature test macro requirements."
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:63
msgid ""
"B<mmap>()  creates a new mapping in the virtual address space of the calling "
"process.  The starting address for the new mapping is specified in I<addr>.  "
"The I<length> argument specifies the length of the mapping (which must be "
"greater than 0)."
msgstr ""

#.  Before Linux 2.6.24, the address was rounded up to the next page
#.  boundary; since 2.6.24, it is rounded down!
#. type: Plain text
#: man-pages/man2/mmap.2:83
msgid ""
"If I<addr> is NULL, then the kernel chooses the (page-aligned) address at "
"which to create the mapping; this is the most portable method of creating a "
"new mapping.  If I<addr> is not NULL, then the kernel takes it as a hint "
"about where to place the mapping; on Linux, the kernel will pick a nearby "
"page boundary (but always above or equal to the value specified by "
"I</proc/sys/vm/mmap_min_addr>)  and attempt to create the mapping there.  If "
"another mapping already exists there, the kernel picks a new address that "
"may or may not depend on the hint.  The address of the new mapping is "
"returned as the result of the call."
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:95
msgid ""
"The contents of a file mapping (as opposed to an anonymous mapping; see "
"B<MAP_ANONYMOUS> below), are initialized using I<length> bytes starting at "
"offset I<offset> in the file (or other object) referred to by the file "
"descriptor I<fd>.  I<offset> must be a multiple of the page size as returned "
"by I<sysconf(_SC_PAGE_SIZE)>."
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:101
msgid ""
"After the B<mmap>()  call has returned, the file descriptor, I<fd>, can be "
"closed immediately without invalidating the mapping."
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:109
msgid ""
"The I<prot> argument describes the desired memory protection of the mapping "
"(and must not conflict with the open mode of the file).  It is either "
"B<PROT_NONE> or the bitwise OR of one or more of the following flags:"
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:112
msgid "Pages may be executed."
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:115
msgid "Pages may be read."
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:118
msgid "Pages may be written."
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:121
msgid "Pages may not be accessed."
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:130
msgid ""
"The I<flags> argument determines whether updates to the mapping are visible "
"to other processes mapping the same region, and whether updates are carried "
"through to the underlying file.  This behavior is determined by including "
"exactly one of the following values in I<flags>:"
msgstr ""

#. type: TP
#: man-pages/man2/mmap.2:130
#, no-wrap
msgid "B<MAP_SHARED>"
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:139
msgid ""
"Share this mapping.  Updates to the mapping are visible to other processes "
"mapping the same region, and (in the case of file-backed mappings)  are "
"carried through to the underlying file.  (To precisely control when updates "
"are carried through to the underlying file requires the use of B<msync>(2).)"
msgstr ""

#. type: TP
#: man-pages/man2/mmap.2:139
#, no-wrap
msgid "B<MAP_SHARED_VALIDATE> (since Linux 4.15)"
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:156
msgid ""
"This flag provides the same behavior as B<MAP_SHARED> except that "
"B<MAP_SHARED> mappings ignore unknown flags in I<flags>.  By contrast, when "
"creating a mapping using B<MAP_SHARED_VALIDATE>, the kernel verifies all "
"passed flags are known and fails the mapping with the error B<EOPNOTSUPP> "
"for unknown flags.  This mapping type is also required to be able to use "
"some mapping flags (e.g., B<MAP_SYNC>)."
msgstr ""

#. type: TP
#: man-pages/man2/mmap.2:156
#, no-wrap
msgid "B<MAP_PRIVATE>"
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:165
msgid ""
"Create a private copy-on-write mapping.  Updates to the mapping are not "
"visible to other processes mapping the same file, and are not carried "
"through to the underlying file.  It is unspecified whether changes made to "
"the file after the B<mmap>()  call are visible in the mapped region."
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:173
msgid ""
"Both B<MAP_SHARED> and B<MAP_PRIVATE> are described in POSIX.1-2001 and "
"POSIX.1-2008.  B<MAP_SHARED_VALIDATE> is a Linux extension."
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:176
msgid "In addition, zero or more of the following values can be ORed in I<flags>:"
msgstr ""

#. type: TP
#: man-pages/man2/mmap.2:176
#, no-wrap
msgid "B<MAP_32BIT> (since Linux 2.4.20, 2.6)"
msgstr ""

#.  See http://lwn.net/Articles/294642 "Tangled up in threads", 19 Aug 08
#. type: Plain text
#: man-pages/man2/mmap.2:192
msgid ""
"Put the mapping into the first 2 Gigabytes of the process address space.  "
"This flag is supported only on x86-64, for 64-bit programs.  It was added to "
"allow thread stacks to be allocated somewhere in the first 2\\ GB of memory, "
"so as to improve context-switch performance on some early 64-bit "
"processors.  Modern x86-64 processors no longer have this performance "
"problem, so use of this flag is not required on those systems.  The "
"B<MAP_32BIT> flag is ignored when B<MAP_FIXED> is set."
msgstr ""

#. type: TP
#: man-pages/man2/mmap.2:192
#, no-wrap
msgid "B<MAP_ANON>"
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:197
msgid "Synonym for B<MAP_ANONYMOUS>.  Deprecated."
msgstr ""

#. type: TP
#: man-pages/man2/mmap.2:197
#, no-wrap
msgid "B<MAP_ANONYMOUS>"
msgstr ""

#.  See the pgoff overflow check in do_mmap().
#.  See the offset check in sys_mmap in arch/x86/kernel/sys_x86_64.c.
#. type: Plain text
#: man-pages/man2/mmap.2:222
msgid ""
"The mapping is not backed by any file; its contents are initialized to "
"zero.  The I<fd> argument is ignored; however, some implementations require "
"I<fd> to be -1 if B<MAP_ANONYMOUS> (or B<MAP_ANON>)  is specified, and "
"portable applications should ensure this.  The I<offset> argument should be "
"zero.  The use of B<MAP_ANONYMOUS> in conjunction with B<MAP_SHARED> is "
"supported on Linux only since kernel 2.4."
msgstr ""

#. type: TP
#: man-pages/man2/mmap.2:222
#, no-wrap
msgid "B<MAP_DENYWRITE>"
msgstr ""

#.  Introduced in 1.1.36, removed in 1.3.24.
#. type: Plain text
#: man-pages/man2/mmap.2:230
msgid ""
"This flag is ignored.  (Long ago\\(emLinux 2.0 and earlier\\(emit signaled "
"that attempts to write to the underlying file should fail with B<ETXTBUSY>.  "
"But this was a source of denial-of-service attacks.)"
msgstr ""

#. type: TP
#: man-pages/man2/mmap.2:230
#, no-wrap
msgid "B<MAP_EXECUTABLE>"
msgstr ""

#.  Introduced in 1.1.38, removed in 1.3.24. Flag tested in proc_follow_link.
#.  (Long ago, it signaled that the underlying file is an executable.
#.  However, that information was not really used anywhere.)
#.  Linus talked about DOS related to MAP_EXECUTABLE, but he was thinking of
#.  MAP_DENYWRITE?
#. type: Plain text
#: man-pages/man2/mmap.2:238
msgid "This flag is ignored."
msgstr ""

#. type: TP
#: man-pages/man2/mmap.2:238
#, no-wrap
msgid "B<MAP_FILE>"
msgstr ""

#.  On some systems, this was required as the opposite of
#.  MAP_ANONYMOUS -- mtk, 1 May 2007
#. type: Plain text
#: man-pages/man2/mmap.2:244
msgid "Compatibility flag.  Ignored."
msgstr ""

#. type: TP
#: man-pages/man2/mmap.2:244
#, no-wrap
msgid "B<MAP_FIXED>"
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:262
msgid ""
"Don't interpret I<addr> as a hint: place the mapping at exactly that "
"address.  I<addr> must be suitably aligned: for most architectures a "
"multiple of the page size is sufficient; however, some architectures may "
"impose additional restrictions.  If the memory region specified by I<addr> "
"and I<len> overlaps pages of any existing mapping(s), then the overlapped "
"part of the existing mapping(s) will be discarded.  If the specified address "
"cannot be used, B<mmap>()  will fail."
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:270
msgid ""
"Software that aspires to be portable should use the B<MAP_FIXED> flag with "
"care, keeping in mind that the exact layout of a process's memory mappings "
"is allowed to change significantly between kernel versions, C library "
"versions, and operating system releases.  I<Carefully read the discussion of "
"this flag in NOTES!>"
msgstr ""

#. type: TP
#: man-pages/man2/mmap.2:270
#, no-wrap
msgid "B<MAP_FIXED_NOREPLACE> (since Linux 4.17)"
msgstr ""

#.  commit a4ff8e8620d3f4f50ac4b41e8067b7d395056843
#. type: Plain text
#: man-pages/man2/mmap.2:286
msgid ""
"This flag provides behavior that is similar to B<MAP_FIXED> with respect to "
"the I<addr> enforcement, but differs in that B<MAP_FIXED_NOREPLACE> never "
"clobbers a preexisting mapped range.  If the requested range would collide "
"with an existing mapping, then this call fails with the error B<EEXIST.> "
"This flag can therefore be used as a way to atomically (with respect to "
"other threads) attempt to map an address range: one thread will succeed; all "
"others will report failure."
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:296
msgid ""
"Note that older kernels which do not recognize the B<MAP_FIXED_NOREPLACE> "
"flag will typically (upon detecting a collision with a preexisting mapping)  "
"fall back to a \"non-B<MAP_FIXED\" type of behavior:> they will return an "
"address that is different from the requested address.  Therefore, "
"backward-compatible software should check the returned address against the "
"requested address."
msgstr ""

#. type: TP
#: man-pages/man2/mmap.2:296
#, no-wrap
msgid "B<MAP_GROWSDOWN>"
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:310
msgid ""
"This flag is used for stacks.  It indicates to the kernel virtual memory "
"system that the mapping should extend downward in memory.  The return "
"address is one page lower than the memory area that is actually created in "
"the process's virtual address space.  Touching an address in the \"guard\" "
"page below the mapping will cause the mapping to grow by a page.  This "
"growth can be repeated until the mapping grows to within a page of the high "
"end of the next lower mapping, at which point touching the \"guard\" page "
"will result in a B<SIGSEGV> signal."
msgstr ""

#. type: TP
#: man-pages/man2/mmap.2:310
#, no-wrap
msgid "B<MAP_HUGETLB> (since Linux 2.6.32)"
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:316
msgid ""
"Allocate the mapping using \"huge pages.\" See the Linux kernel source file "
"I<Documentation/admin-guide/mm/hugetlbpage.rst> for further information, as "
"well as NOTES, below."
msgstr ""

#. type: TP
#: man-pages/man2/mmap.2:316
#, no-wrap
msgid "B<MAP_HUGE_2MB>, B<MAP_HUGE_1GB> (since Linux 3.8)"
msgstr ""

#.  See https://lwn.net/Articles/533499/
#. type: Plain text
#: man-pages/man2/mmap.2:323
msgid ""
"Used in conjunction with B<MAP_HUGETLB> to select alternative hugetlb page "
"sizes (respectively, 2\\ MB and 1\\ GB)  on systems that support multiple "
"hugetlb page sizes."
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:333
msgid ""
"More generally, the desired huge page size can be configured by encoding the "
"base-2 logarithm of the desired page size in the six bits at the offset "
"B<MAP_HUGE_SHIFT>.  (A value of zero in this bit field provides the default "
"huge page size; the default huge page size can be discovered via the "
"I<Hugepagesize> field exposed by I</proc/meminfo>.)  Thus, the above two "
"constants are defined as:"
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:338
#, no-wrap
msgid ""
"#define MAP_HUGE_2MB    (21 E<lt>E<lt> MAP_HUGE_SHIFT)\n"
"#define MAP_HUGE_1GB    (30 E<lt>E<lt> MAP_HUGE_SHIFT)\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:344
msgid ""
"The range of huge page sizes that are supported by the system can be "
"discovered by listing the subdirectories in I</sys/kernel/mm/hugepages>."
msgstr ""

#. type: TP
#: man-pages/man2/mmap.2:344
#, no-wrap
msgid "B<MAP_LOCKED> (since Linux 2.5.37)"
msgstr ""

#.  If set, the mapped pages will not be swapped out.
#. type: Plain text
#: man-pages/man2/mmap.2:365
msgid ""
"Mark the mapped region to be locked in the same way as B<mlock>(2).  This "
"implementation will try to populate (prefault) the whole range but the "
"B<mmap>()  call doesn't fail with B<ENOMEM> if this fails.  Therefore major "
"faults might happen later on.  So the semantic is not as strong as "
"B<mlock>(2).  One should use B<mmap>()  plus B<mlock>(2)  when major faults "
"are not acceptable after the initialization of the mapping.  The "
"B<MAP_LOCKED> flag is ignored in older kernels."
msgstr ""

#. type: TP
#: man-pages/man2/mmap.2:365
#, no-wrap
msgid "B<MAP_NONBLOCK> (since Linux 2.5.46)"
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:380
msgid ""
"This flag is meaningful only in conjunction with B<MAP_POPULATE>.  Don't "
"perform read-ahead: create page tables entries only for pages that are "
"already present in RAM.  Since Linux 2.6.23, this flag causes "
"B<MAP_POPULATE> to do nothing.  One day, the combination of B<MAP_POPULATE> "
"and B<MAP_NONBLOCK> may be reimplemented."
msgstr ""

#. type: TP
#: man-pages/man2/mmap.2:380
#, no-wrap
msgid "B<MAP_NORESERVE>"
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:395
msgid ""
"Do not reserve swap space for this mapping.  When swap space is reserved, "
"one has the guarantee that it is possible to modify the mapping.  When swap "
"space is not reserved one might get B<SIGSEGV> upon a write if no physical "
"memory is available.  See also the discussion of the file "
"I</proc/sys/vm/overcommit_memory> in B<proc>(5).  In kernels before 2.6, "
"this flag had effect only for private writable mappings."
msgstr ""

#. type: TP
#: man-pages/man2/mmap.2:395
#, no-wrap
msgid "B<MAP_POPULATE> (since Linux 2.5.46)"
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:402
msgid ""
"Populate (prefault) page tables for a mapping.  For a file mapping, this "
"causes read-ahead on the file.  This will help to reduce blocking on page "
"faults later.  B<MAP_POPULATE> is supported for private mappings only since "
"Linux 2.6.23."
msgstr ""

#. type: TP
#: man-pages/man2/mmap.2:402
#, no-wrap
msgid "B<MAP_STACK> (since Linux 2.6.27)"
msgstr ""

#.  See http://lwn.net/Articles/294642 "Tangled up in threads", 19 Aug 08
#.  commit cd98a04a59e2f94fa64d5bf1e26498d27427d5e7
#.  http://thread.gmane.org/gmane.linux.kernel/720412
#.  "pthread_create() slow for many threads; also time to revisit 64b
#.   context switch optimization?"
#. type: Plain text
#: man-pages/man2/mmap.2:415
msgid ""
"Allocate the mapping at an address suitable for a process or thread stack.  "
"This flag is currently a no-op, but is used in the glibc threading "
"implementation so that if some architectures require special treatment for "
"stack allocations, support can later be transparently implemented for glibc."
msgstr ""

#. type: TP
#: man-pages/man2/mmap.2:415
#, no-wrap
msgid "B<MAP_SYNC> (since Linux 4.15)"
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:428
msgid ""
"This flag is available only with the B<MAP_SHARED_VALIDATE> mapping type; "
"mappings of type B<MAP_SHARED> will silently ignore this flag.  This flag is "
"supported only for files supporting DAX (direct mapping of persistent "
"memory).  For other files, creating a mapping with this flag results in an "
"B<EOPNOTSUPP> error."
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:436
msgid ""
"Shared file mappings with this flag provide the guarantee that while some "
"memory is writably mapped in the address space of the process, it will be "
"visible in the same file at the same offset even after the system crashes or "
"is rebooted.  In conjunction with the use of appropriate CPU instructions, "
"this provides users of such mappings with a more efficient way of making "
"data modifications persistent."
msgstr ""

#. type: TP
#: man-pages/man2/mmap.2:436
#, no-wrap
msgid "B<MAP_UNINITIALIZED> (since Linux 2.6.33)"
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:446
msgid ""
"Don't clear anonymous pages.  This flag is intended to improve performance "
"on embedded devices.  This flag is honored only if the kernel was configured "
"with the B<CONFIG_MMAP_ALLOW_UNINITIALIZED> option.  Because of the security "
"implications, that option is normally enabled only on embedded devices "
"(i.e., devices where one has complete control of the contents of user "
"memory)."
msgstr ""

#.  FIXME . for later review when Issue 8 is one day released...
#.  POSIX may add MAP_ANON in the future
#.  http://austingroupbugs.net/tag_view_page.php?tag_id=8
#.  http://austingroupbugs.net/view.php?id=850
#. type: Plain text
#: man-pages/man2/mmap.2:458
msgid ""
"Of the above flags, only B<MAP_FIXED> is specified in POSIX.1-2001 and "
"POSIX.1-2008.  However, most systems also support B<MAP_ANONYMOUS> (or its "
"synonym B<MAP_ANON>)."
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:464
msgid ""
"Memory mapped by B<mmap>()  is preserved across B<fork>(2), with the same "
"attributes."
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:472
msgid ""
"A file is mapped in multiples of the page size.  For a file that is not a "
"multiple of the page size, the remaining memory is zeroed when mapped, and "
"writes to that region are not written out to the file.  The effect of "
"changing the size of the underlying file of a mapping on the pages that "
"correspond to added or removed regions of the file is unspecified."
msgstr ""

#. type: SS
#: man-pages/man2/mmap.2:472
#, no-wrap
msgid "munmap()"
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:482
msgid ""
"The B<munmap>()  system call deletes the mappings for the specified address "
"range, and causes further references to addresses within the range to "
"generate invalid memory references.  The region is also automatically "
"unmapped when the process is terminated.  On the other hand, closing the "
"file descriptor does not unmap the region."
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:494
msgid ""
"The address I<addr> must be a multiple of the page size (but I<length> need "
"not be).  All pages containing a part of the indicated range are unmapped, "
"and subsequent references to these pages will generate B<SIGSEGV>.  It is "
"not an error if the indicated range does not contain any mapped pages."
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:505
msgid ""
"On success, B<mmap>()  returns a pointer to the mapped area.  On error, the "
"value B<MAP_FAILED> (that is, I<(void\\ *)\\ -1>)  is returned, and I<errno> "
"is set to indicate the cause of the error."
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:513
msgid ""
"On success, B<munmap>()  returns 0.  On failure, it returns -1, and I<errno> "
"is set to indicate the cause of the error (probably to B<EINVAL>)."
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:532
msgid ""
"A file descriptor refers to a non-regular file.  Or a file mapping was "
"requested, but I<fd> is not open for reading.  Or B<MAP_SHARED> was "
"requested and B<PROT_WRITE> is set, but I<fd> is not open in read/write "
"(B<O_RDWR>)  mode.  Or B<PROT_WRITE> is set, but the file is append-only."
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:536
msgid ""
"The file has been locked, or too much memory has been locked (see "
"B<setrlimit>(2))."
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:542
msgid "I<fd> is not a valid file descriptor (and B<MAP_ANONYMOUS> was not set)."
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:552
msgid ""
"B<MAP_FIXED_NOREPLACE> was specified in I<flags>, and the range covered by "
"I<addr> and I<length> clashes with an existing mapping."
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:560
msgid ""
"We don't like I<addr>, I<length>, or I<offset> (e.g., they are too large, or "
"not aligned on a page boundary)."
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:565
msgid "(since Linux 2.6.12)  I<length> was 0."
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:573
msgid ""
"I<flags> contained none of B<MAP_PRIVATE>, B<MAP_SHARED> or "
"B<MAP_SHARED_VALIDATE>."
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:585
msgid ""
"The underlying filesystem of the specified file does not support memory "
"mapping."
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:588
msgid "No memory is available."
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:596
msgid ""
"The process's maximum number of mappings would have been exceeded.  This "
"error can also occur for B<munmap>(), when unmapping a region in the middle "
"of an existing mapping, since this results in two smaller mappings on either "
"side of the region being unmapped."
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:604
msgid ""
"(since Linux 4.7)  The process's B<RLIMIT_DATA> limit, described in "
"B<getrlimit>(2), would have been exceeded."
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:616
msgid ""
"On 32-bit architecture together with the large file extension (i.e., using "
"64-bit I<off_t>): the number of pages used for I<length> plus number of "
"pages used for I<offset> would overflow I<unsigned long> (32 bits)."
msgstr ""

#.  (Since 2.4.25 / 2.6.0.)
#. type: Plain text
#: man-pages/man2/mmap.2:625
msgid ""
"The I<prot> argument asks for B<PROT_EXEC> but the mapped area belongs to a "
"file on a filesystem that was mounted no-exec."
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:635
msgid ""
"B<MAP_DENYWRITE> was set but the object specified by I<fd> is open for "
"writing."
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:637
msgid "Use of a mapped region can result in these signals:"
msgstr ""

#. type: TP
#: man-pages/man2/mmap.2:637
#, no-wrap
msgid "B<SIGSEGV>"
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:640
msgid "Attempted write into a region mapped as read-only."
msgstr ""

#. type: TP
#: man-pages/man2/mmap.2:640
#, no-wrap
msgid "B<SIGBUS>"
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:645
msgid ""
"Attempted access to a portion of the buffer that does not correspond to the "
"file (for example, beyond the end of the file, including the case where "
"another process has truncated the file)."
msgstr ""

#. type: tbl table
#: man-pages/man2/mmap.2:656
#, no-wrap
msgid ""
"B<mmap>(),\n"
"B<munmap>()"
msgstr ""

#.  POSIX.1-2001: It shall be defined to -1 or 0 or 200112L.
#.  -1: unavailable, 0: ask using sysconf().
#.  glibc defines it to 1.
#. type: Plain text
#: man-pages/man2/mmap.2:676
msgid ""
"On POSIX systems on which B<mmap>(), B<msync>(2), and B<munmap>()  are "
"available, B<_POSIX_MAPPED_FILES> is defined in I<E<lt>unistd.hE<gt>> to a "
"value greater than 0.  (See also B<sysconf>(3).)"
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:689
msgid ""
"On some hardware architectures (e.g., i386), B<PROT_WRITE> implies "
"B<PROT_READ>.  It is architecture dependent whether B<PROT_READ> implies "
"B<PROT_EXEC> or not.  Portable programs should always set B<PROT_EXEC> if "
"they intend to execute code in the new mapping."
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:704
msgid ""
"The portable way to create a mapping is to specify I<addr> as 0 (NULL), and "
"omit B<MAP_FIXED> from I<flags>.  In this case, the system chooses the "
"address for the mapping; the address is chosen so as not to conflict with "
"any existing mapping, and will not be 0.  If the B<MAP_FIXED> flag is "
"specified, and I<addr> is 0 (NULL), then the mapped address will be 0 "
"(NULL)."
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:737
msgid ""
"Certain I<flags> constants are defined only if suitable feature test macros "
"are defined (possibly by default): B<_DEFAULT_SOURCE> with glibc 2.19 or "
"later; or B<_BSD_SOURCE> or B<_SVID_SOURCE> in glibc 2.19 and earlier.  "
"(Employing B<_GNU_SOURCE> also suffices, and requiring that macro "
"specifically would have been more logical, since these flags are all "
"Linux-specific.)  The relevant flags are: B<MAP_32BIT>, B<MAP_ANONYMOUS> "
"(and the synonym B<MAP_ANON>), B<MAP_DENYWRITE>, B<MAP_EXECUTABLE>, "
"B<MAP_FILE>, B<MAP_GROWSDOWN>, B<MAP_HUGETLB>, B<MAP_LOCKED>, "
"B<MAP_NONBLOCK>, B<MAP_NORESERVE>, B<MAP_POPULATE>, and B<MAP_STACK>."
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:742
msgid ""
"An application can determine which pages of a mapping are currently resident "
"in the buffer/page cache using B<mincore>(2)."
msgstr ""

#. type: SS
#: man-pages/man2/mmap.2:742
#, no-wrap
msgid "Using MAP_FIXED safely"
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:754
msgid ""
"The only safe use for B<MAP_FIXED> is where the address range specified by "
"I<addr> and I<length> was previously reserved using another mapping; "
"otherwise, the use of B<MAP_FIXED> is hazardous because it forcibly removes "
"preexisting mappings, making it easy for a multithreaded process to corrupt "
"its own address space."
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:782
msgid ""
"For example, suppose that thread A looks through I</proc/E<lt>pidE<gt>/maps> "
"and in order to locate an unused address range that it can map using "
"B<MAP_FIXED>, while thread B simultaneously acquires part or all of that "
"same address range.  When thread A subsequently employs B<mmap(MAP_FIXED)>, "
"it will effectively clobber the mapping that thread B created.  In this "
"scenario, thread B need not create a mapping directly; simply making a "
"library call that, internally, uses B<dlopen>(3)  to load some other shared "
"library, will suffice.  The B<dlopen>(3)  call will map the library into the "
"process's address space.  Furthermore, almost any library call may be "
"implemented in a way that adds memory mappings to the address space, either "
"with this technique, or by simply allocating memory.  Examples include "
"B<brk>(2), B<malloc>(3), B<pthread_create>(3), and the PAM libraries E<.UR "
"http://www.linux-pam.org> E<.UE .>"
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:789
msgid ""
"Since Linux 4.17, a multithreaded program can use the B<MAP_FIXED_NOREPLACE> "
"flag to avoid the hazard described above when attempting to create a mapping "
"at a fixed address that has not been reserved by a preexisting mapping."
msgstr ""

#. type: SS
#: man-pages/man2/mmap.2:789
#, no-wrap
msgid "Timestamps changes for file-backed mappings"
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:796
msgid ""
"For file-backed mappings, the I<st_atime> field for the mapped file may be "
"updated at any time between the B<mmap>()  and the corresponding unmapping; "
"the first reference to a mapped page will update the field if it has not "
"been already."
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:814
msgid ""
"The I<st_ctime> and I<st_mtime> field for a file mapped with B<PROT_WRITE> "
"and B<MAP_SHARED> will be updated after a write to the mapped region, and "
"before a subsequent B<msync>(2)  with the B<MS_SYNC> or B<MS_ASYNC> flag, if "
"one occurs."
msgstr ""

#. type: SS
#: man-pages/man2/mmap.2:814
#, no-wrap
msgid "Huge page (Huge TLB) mappings"
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:821
msgid ""
"For mappings that employ huge pages, the requirements for the arguments of "
"B<mmap>()  and B<munmap>()  differ somewhat from the requirements for "
"mappings that use the native system page size."
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:829
msgid ""
"For B<mmap>(), I<offset> must be a multiple of the underlying huge page "
"size.  The system automatically aligns I<length> to be a multiple of the "
"underlying huge page size."
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:837
msgid ""
"For B<munmap>(), I<addr> and I<length> must both be a multiple of the "
"underlying huge page size."
msgstr ""

#.  Since around glibc 2.1/2.2, depending on the platform.
#. type: Plain text
#: man-pages/man2/mmap.2:852
msgid ""
"This page describes the interface provided by the glibc B<mmap>()  wrapper "
"function.  Originally, this function invoked a system call of the same "
"name.  Since kernel 2.4, that system call has been superseded by "
"B<mmap2>(2), and nowadays the glibc B<mmap>()  wrapper function invokes "
"B<mmap2>(2)  with a suitably adjusted value for I<offset>."
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:857
msgid ""
"On Linux, there are no guarantees like those suggested above under "
"B<MAP_NORESERVE>.  By default, any process can be killed at any moment when "
"the system runs out of memory."
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:864
msgid ""
"In kernels before 2.6.7, the B<MAP_POPULATE> flag has effect only if I<prot> "
"is specified as B<PROT_NONE>."
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:879
msgid ""
"SUSv3 specifies that B<mmap>()  should fail if I<length> is 0.  However, in "
"kernels before 2.6.12, B<mmap>()  succeeded in this case: no mapping was "
"created and the call returned I<addr>.  Since kernel 2.6.12, B<mmap>()  "
"fails with the error B<EINVAL> for this case."
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:896
msgid ""
"POSIX specifies that the system shall always zero fill any partial page at "
"the end of the object and that system will never write any modification of "
"the object beyond its end.  On Linux, when you write data to such partial "
"page after the end of the object, the data stays in the page cache even "
"after the file is closed and unmapped and even though the data is never "
"written to the file itself, subsequent mappings may see the modified "
"content.  In some cases, this could be fixed by calling B<msync>(2)  before "
"the unmap takes place; however, this doesn't work on B<tmpfs>(5)  (for "
"example, when using the POSIX shared memory interface documented in "
"B<shm_overview>(7))."
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:908
msgid ""
"The following program prints part of the file specified in its first "
"command-line argument to standard output.  The range of bytes to be printed "
"is specified via offset and length values in the second and third "
"command-line arguments.  The program creates a memory mapping of the "
"required pages of the file and then uses B<write>(2)  to output the desired "
"bytes."
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:916
#, no-wrap
msgid ""
"#include E<lt>sys/mman.hE<gt>\n"
"#include E<lt>sys/stat.hE<gt>\n"
"#include E<lt>fcntl.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:929
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    char *addr;\n"
"    int fd;\n"
"    struct stat sb;\n"
"    off_t offset, pa_offset;\n"
"    size_t length;\n"
"    ssize_t s;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:934
#, no-wrap
msgid ""
"    if (argc E<lt> 3 || argc E<gt> 4) {\n"
"        fprintf(stderr, \"%s file offset [length]\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:938
#, no-wrap
msgid ""
"    fd = open(argv[1], O_RDONLY);\n"
"    if (fd == -1)\n"
"        handle_error(\"open\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:941
#, no-wrap
msgid ""
"    if (fstat(fd, &sb) == -1)           /* To obtain file size */\n"
"        handle_error(\"fstat\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:945
#, no-wrap
msgid ""
"    offset = atoi(argv[2]);\n"
"    pa_offset = offset & ~(sysconf(_SC_PAGE_SIZE) - 1);\n"
"        /* offset for mmap() must be page aligned */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:950
#, no-wrap
msgid ""
"    if (offset E<gt>= sb.st_size) {\n"
"        fprintf(stderr, \"offset is past end of file\\en\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:956
#, no-wrap
msgid ""
"    if (argc == 4) {\n"
"        length = atoi(argv[3]);\n"
"        if (offset + length E<gt> sb.st_size)\n"
"            length = sb.st_size - offset;\n"
"                /* Can\\(aqt display bytes past end of file */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:960
#, no-wrap
msgid ""
"    } else {    /* No length arg ==E<gt> display to end of file */\n"
"        length = sb.st_size - offset;\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:965
#, no-wrap
msgid ""
"    addr = mmap(NULL, length + offset - pa_offset, PROT_READ,\n"
"                MAP_PRIVATE, fd, pa_offset);\n"
"    if (addr == MAP_FAILED)\n"
"        handle_error(\"mmap\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:970
#, no-wrap
msgid ""
"    s = write(STDOUT_FILENO, addr + offset - pa_offset, length);\n"
"    if (s != length) {\n"
"        if (s == -1)\n"
"            handle_error(\"write\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:974
#, no-wrap
msgid ""
"        fprintf(stderr, \"partial write\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:977
#, no-wrap
msgid ""
"    munmap(addr, length + offset - pa_offset);\n"
"    close(fd);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:997
msgid ""
"B<ftruncate>(2), B<getpagesize>(2), B<memfd_create>(2), B<mincore>(2), "
"B<mlock>(2), B<mmap2>(2), B<mprotect>(2), B<mremap>(2), B<msync>(2), "
"B<remap_file_pages>(2), B<setrlimit>(2), B<shmat>(2), B<userfaultfd>(2), "
"B<shm_open>(3), B<shm_overview>(7)"
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:1004
msgid ""
"The descriptions of the following files in B<proc>(5): I</proc/[pid]/maps>, "
"I</proc/[pid]/map_files>, and I</proc/[pid]/smaps>."
msgstr ""

#. type: TH
#: man-pages/man2/getsockopt.2:44
#, no-wrap
msgid "GETSOCKOPT"
msgstr ""

#. type: Plain text
#: man-pages/man2/getsockopt.2:47
msgid "getsockopt, setsockopt - get and set options on sockets"
msgstr ""

#. type: Plain text
#: man-pages/man2/getsockopt.2:56
#, no-wrap
msgid ""
"B<int getsockopt(int >I<sockfd>B<, int >I<level>B<, int >I<optname>B<,>\n"
"B<               void *>I<optval>B<, socklen_t *>I<optlen>B<);>\n"
"B<int setsockopt(int >I<sockfd>B<, int >I<level>B<, int >I<optname>B<,>\n"
"B<               const void *>I<optval>B<, socklen_t >I<optlen>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/getsockopt.2:66
msgid ""
"B<getsockopt>()  and B<setsockopt>()  manipulate options for the socket "
"referred to by the file descriptor I<sockfd>.  Options may exist at multiple "
"protocol levels; they are always present at the uppermost socket level."
msgstr ""

#. type: Plain text
#: man-pages/man2/getsockopt.2:85
msgid ""
"When manipulating socket options, the level at which the option resides and "
"the name of the option must be specified.  To manipulate options at the "
"sockets API level, I<level> is specified as B<SOL_SOCKET>.  To manipulate "
"options at any other level the protocol number of the appropriate protocol "
"controlling the option is supplied.  For example, to indicate that an option "
"is to be interpreted by the B<TCP> protocol, I<level> should be set to the "
"protocol number of B<TCP>; see B<getprotoent>(3)."
msgstr ""

#. type: Plain text
#: man-pages/man2/getsockopt.2:107
msgid ""
"The arguments I<optval> and I<optlen> are used to access option values for "
"B<setsockopt>().  For B<getsockopt>()  they identify a buffer in which the "
"value for the requested option(s) are to be returned.  For B<getsockopt>(), "
"I<optlen> is a value-result argument, initially containing the size of the "
"buffer pointed to by I<optval>, and modified on return to indicate the "
"actual size of the value returned.  If no option value is to be supplied or "
"returned, I<optval> may be NULL."
msgstr ""

#. type: Plain text
#: man-pages/man2/getsockopt.2:117
msgid ""
"I<Optname> and any specified options are passed uninterpreted to the "
"appropriate protocol module for interpretation.  The include file "
"I<E<lt>sys/socket.hE<gt>> contains definitions for socket level options, "
"described below.  Options at other protocol levels vary in format and name; "
"consult the appropriate entries in section 4 of the manual."
msgstr ""

#. type: Plain text
#: man-pages/man2/getsockopt.2:126
msgid ""
"Most socket-level options utilize an I<int> argument for I<optval>.  For "
"B<setsockopt>(), the argument should be nonzero to enable a boolean option, "
"or zero if the option is to be disabled."
msgstr ""

#. type: Plain text
#: man-pages/man2/getsockopt.2:130
msgid ""
"For a description of the available socket options see B<socket>(7)  and the "
"appropriate protocol man pages."
msgstr ""

#. type: Plain text
#: man-pages/man2/getsockopt.2:135
msgid ""
"On success, zero is returned for the standard options.  On error, -1 is "
"returned, and I<errno> is set appropriately."
msgstr ""

#. type: Plain text
#: man-pages/man2/getsockopt.2:139
msgid ""
"Netfilter allows the programmer to define custom socket options with "
"associated handlers; for such options, the return value on success is the "
"value returned by the handler."
msgstr ""

#. type: Plain text
#: man-pages/man2/getsockopt.2:155
msgid ""
"The address pointed to by I<optval> is not in a valid part of the process "
"address space.  For B<getsockopt>(), this error may also be returned if "
"I<optlen> is not in a valid part of the process address space."
msgstr ""

#. type: Plain text
#: man-pages/man2/getsockopt.2:166
msgid ""
"I<optlen> invalid in B<setsockopt>().  In some cases this error can also "
"occur for an invalid value in I<optval> (e.g., for the B<IP_ADD_MEMBERSHIP> "
"option described in B<ip>(7))."
msgstr ""

#. type: TP
#: man-pages/man2/getsockopt.2:166
#, no-wrap
msgid "B<ENOPROTOOPT>"
msgstr ""

#. type: Plain text
#: man-pages/man2/getsockopt.2:169
msgid "The option is unknown at the level indicated."
msgstr ""

#.  SVr4 documents additional ENOMEM and ENOSR error codes, but does
#.  not document the
#.  .BR SO_SNDLOWAT ", " SO_RCVLOWAT ", " SO_SNDTIMEO ", " SO_RCVTIMEO
#.  options
#. type: Plain text
#: man-pages/man2/getsockopt.2:181
msgid ""
"POSIX.1-2001, POSIX.1-2008, SVr4, 4.4BSD (these system calls first appeared "
"in 4.2BSD)."
msgstr ""

#. type: Plain text
#: man-pages/man2/getsockopt.2:195
msgid ""
"Several of the socket options should be handled at lower levels of the "
"system."
msgstr ""

#. type: Plain text
#: man-pages/man2/getsockopt.2:205
msgid ""
"B<ioctl>(2), B<socket>(2), B<getprotoent>(3), B<protocols>(5), B<ip>(7), "
"B<packet>(7), B<socket>(7), B<tcp>(7), B<udp>(7), B<unix>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/ptrace.2:105
#, no-wrap
msgid "PTRACE"
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:108
msgid "ptrace - process trace"
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:111
#, no-wrap
msgid "B<#include E<lt>sys/ptrace.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:114
#, no-wrap
msgid ""
"B<long ptrace(enum __ptrace_request >I<request>B<, pid_t >I<pid>B<, >\n"
"B<            void *>I<addr>B<, void *>I<data>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:123
msgid ""
"The B<ptrace>()  system call provides a means by which one process (the "
"\"tracer\")  may observe and control the execution of another process (the "
"\"tracee\"), and examine and change the tracee's memory and registers.  It "
"is primarily used to implement breakpoint debugging and system call tracing."
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:134
msgid ""
"A tracee first needs to be attached to the tracer.  Attachment and "
"subsequent commands are per thread: in a multithreaded process, every thread "
"can be individually attached to a (potentially different) tracer, or left "
"not attached and thus not debugged.  Therefore, \"tracee\" always means "
"\"(one) thread\", never \"a (possibly multithreaded) process\".  Ptrace "
"commands are always sent to a specific tracee using a call of the form"
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:136
#, no-wrap
msgid "    ptrace(PTRACE_foo, pid, ...)\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:140
msgid "where I<pid> is the thread ID of the corresponding Linux thread."
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:146
msgid ""
"(Note that in this page, a \"multithreaded process\" means a thread group "
"consisting of threads created using the B<clone>(2)  B<CLONE_THREAD> flag.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:157
msgid ""
"A process can initiate a trace by calling B<fork>(2)  and having the "
"resulting child do a B<PTRACE_TRACEME>, followed (typically) by an "
"B<execve>(2).  Alternatively, one process may commence tracing another "
"process using B<PTRACE_ATTACH> or B<PTRACE_SEIZE>."
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:174
msgid ""
"While being traced, the tracee will stop each time a signal is delivered, "
"even if the signal is being ignored.  (An exception is B<SIGKILL>, which has "
"its usual effect.)  The tracer will be notified at its next call to "
"B<waitpid>(2)  (or one of the related \"wait\" system calls); that call will "
"return a I<status> value containing information that indicates the cause of "
"the stop in the tracee.  While the tracee is stopped, the tracer can use "
"various ptrace requests to inspect and modify the tracee.  The tracer then "
"causes the tracee to continue, optionally ignoring the delivered signal (or "
"even delivering a different signal instead)."
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:184
msgid ""
"If the B<PTRACE_O_TRACEEXEC> option is not in effect, all successful calls "
"to B<execve>(2)  by the traced process will cause it to be sent a B<SIGTRAP> "
"signal, giving the parent a chance to gain control before the new program "
"begins execution."
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:188
msgid ""
"When the tracer is finished tracing, it can cause the tracee to continue "
"executing in a normal, untraced mode via B<PTRACE_DETACH>."
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:192
msgid "The value of I<request> determines the action to be performed:"
msgstr ""

#. type: TP
#: man-pages/man2/ptrace.2:192
#, no-wrap
msgid "B<PTRACE_TRACEME>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:202
msgid ""
"Indicate that this process is to be traced by its parent.  A process "
"probably shouldn't make this request if its parent isn't expecting to trace "
"it.  (I<pid>, I<addr>, and I<data> are ignored.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:217
msgid ""
"The B<PTRACE_TRACEME> request is used only by the tracee; the remaining "
"requests are used only by the tracer.  In the following requests, I<pid> "
"specifies the thread ID of the tracee to be acted on.  For requests other "
"than B<PTRACE_ATTACH>, B<PTRACE_SEIZE>, B<PTRACE_INTERRUPT>, and "
"B<PTRACE_KILL>, the tracee must be stopped."
msgstr ""

#. type: TP
#: man-pages/man2/ptrace.2:217
#, no-wrap
msgid "B<PTRACE_PEEKTEXT>, B<PTRACE_PEEKDATA>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:228
msgid ""
"Read a word at the address I<addr> in the tracee's memory, returning the "
"word as the result of the B<ptrace>()  call.  Linux does not have separate "
"text and data address spaces, so these two requests are currently "
"equivalent.  (I<data> is ignored; but see NOTES.)"
msgstr ""

#. type: TP
#: man-pages/man2/ptrace.2:228
#, no-wrap
msgid "B<PTRACE_PEEKUSER>"
msgstr ""

#.  PTRACE_PEEKUSR in kernel source, but glibc uses PTRACE_PEEKUSER,
#.  and that is the name that seems common on other systems.
#. type: Plain text
#: man-pages/man2/ptrace.2:246
msgid ""
"Read a word at offset I<addr> in the tracee's USER area, which holds the "
"registers and other information about the process (see "
"I<E<lt>sys/user.hE<gt>>).  The word is returned as the result of the "
"B<ptrace>()  call.  Typically, the offset must be word-aligned, though this "
"might vary by architecture.  See NOTES.  (I<data> is ignored; but see "
"NOTES.)"
msgstr ""

#. type: TP
#: man-pages/man2/ptrace.2:246
#, no-wrap
msgid "B<PTRACE_POKETEXT>, B<PTRACE_POKEDATA>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:258
msgid ""
"Copy the word I<data> to the address I<addr> in the tracee's memory.  As for "
"B<PTRACE_PEEKTEXT> and B<PTRACE_PEEKDATA>, these two requests are currently "
"equivalent."
msgstr ""

#. type: TP
#: man-pages/man2/ptrace.2:258
#, no-wrap
msgid "B<PTRACE_POKEUSER>"
msgstr ""

#.  PTRACE_POKEUSR in kernel source, but glibc uses PTRACE_POKEUSER,
#.  and that is the name that seems common on other systems.
#.  FIXME In the preceding sentence, which modifications are disallowed,
#.  and when they are disallowed, how does user space discover that fact?
#. type: Plain text
#: man-pages/man2/ptrace.2:274
msgid ""
"Copy the word I<data> to offset I<addr> in the tracee's USER area.  As for "
"B<PTRACE_PEEKUSER>, the offset must typically be word-aligned.  In order to "
"maintain the integrity of the kernel, some modifications to the USER area "
"are disallowed."
msgstr ""

#. type: TP
#: man-pages/man2/ptrace.2:274
#, no-wrap
msgid "B<PTRACE_GETREGS>, B<PTRACE_GETFPREGS>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:297
msgid ""
"Copy the tracee's general-purpose or floating-point registers, respectively, "
"to the address I<data> in the tracer.  See I<E<lt>sys/user.hE<gt>> for "
"information on the format of this data.  (I<addr> is ignored.)  Note that "
"SPARC systems have the meaning of I<data> and I<addr> reversed; that is, "
"I<data> is ignored and the registers are copied to the address I<addr>.  "
"B<PTRACE_GETREGS> and B<PTRACE_GETFPREGS> are not present on all "
"architectures."
msgstr ""

#. type: TP
#: man-pages/man2/ptrace.2:297
#, no-wrap
msgid "B<PTRACE_GETREGSET> (since Linux 2.6.34)"
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:318
msgid ""
"Read the tracee's registers.  I<addr> specifies, in an "
"architecture-dependent way, the type of registers to be read.  "
"B<NT_PRSTATUS> (with numerical value 1)  usually results in reading of "
"general-purpose registers.  If the CPU has, for example, floating-point "
"and/or vector registers, they can be retrieved by setting I<addr> to the "
"corresponding B<NT_foo> constant.  I<data> points to a B<struct iovec>, "
"which describes the destination buffer's location and length.  On return, "
"the kernel modifies B<iov.len> to indicate the actual number of bytes "
"returned."
msgstr ""

#. type: TP
#: man-pages/man2/ptrace.2:318
#, no-wrap
msgid "B<PTRACE_SETREGS>, B<PTRACE_SETFPREGS>"
msgstr ""

#.  FIXME . In the preceding sentence, which modifications are disallowed,
#.  and when they are disallowed, how does user space discover that fact?
#. type: Plain text
#: man-pages/man2/ptrace.2:343
msgid ""
"Modify the tracee's general-purpose or floating-point registers, "
"respectively, from the address I<data> in the tracer.  As for "
"B<PTRACE_POKEUSER>, some general-purpose register modifications may be "
"disallowed.  (I<addr> is ignored.)  Note that SPARC systems have the meaning "
"of I<data> and I<addr> reversed; that is, I<data> is ignored and the "
"registers are copied from the address I<addr>.  B<PTRACE_SETREGS> and "
"B<PTRACE_SETFPREGS> are not present on all architectures."
msgstr ""

#. type: TP
#: man-pages/man2/ptrace.2:343
#, no-wrap
msgid "B<PTRACE_SETREGSET> (since Linux 2.6.34)"
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:352
msgid ""
"Modify the tracee's registers.  The meaning of I<addr> and I<data> is "
"analogous to B<PTRACE_GETREGSET>."
msgstr ""

#. type: TP
#: man-pages/man2/ptrace.2:352
#, no-wrap
msgid "B<PTRACE_GETSIGINFO> (since Linux 2.3.99-pre6)"
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:364
msgid ""
"Retrieve information about the signal that caused the stop.  Copy a "
"I<siginfo_t> structure (see B<sigaction>(2))  from the tracee to the address "
"I<data> in the tracer.  (I<addr> is ignored.)"
msgstr ""

#. type: TP
#: man-pages/man2/ptrace.2:364
#, no-wrap
msgid "B<PTRACE_SETSIGINFO> (since Linux 2.3.99-pre6)"
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:380
msgid ""
"Set signal information: copy a I<siginfo_t> structure from the address "
"I<data> in the tracer to the tracee.  This will affect only signals that "
"would normally be delivered to the tracee and were caught by the tracer.  It "
"may be difficult to tell these normal signals from synthetic signals "
"generated by B<ptrace>()  itself.  (I<addr> is ignored.)"
msgstr ""

#. type: TP
#: man-pages/man2/ptrace.2:380
#, no-wrap
msgid "B<PTRACE_PEEKSIGINFO> (since Linux 3.10)"
msgstr ""

#.  commit 84c751bd4aebbaae995fe32279d3dba48327bad4
#. type: Plain text
#: man-pages/man2/ptrace.2:406
msgid ""
"Retrieve I<siginfo_t> structures without removing signals from a queue.  "
"I<addr> points to a I<ptrace_peeksiginfo_args> structure that specifies the "
"ordinal position from which copying of signals should start, and the number "
"of signals to copy.  I<siginfo_t> structures are copied into the buffer "
"pointed to by I<data>.  The return value contains the number of copied "
"signals (zero indicates that there is no signal corresponding to the "
"specified ordinal position).  Within the returned I<siginfo> structures, the "
"I<si_code> field includes information (B<__SI_CHLD>, B<__SI_FAULT>, etc.) "
"that are not otherwise exposed to user space."
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:415
#, no-wrap
msgid ""
"struct ptrace_peeksiginfo_args {\n"
"    u64 off;    /* Ordinal position in queue at which\n"
"                   to start copying signals */\n"
"    u32 flags;  /* PTRACE_PEEKSIGINFO_SHARED or 0 */\n"
"    s32 nr;     /* Number of signals to copy */\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:423
msgid ""
"Currently, there is only one flag, B<PTRACE_PEEKSIGINFO_SHARED>, for dumping "
"signals from the process-wide signal queue.  If this flag is not set, "
"signals are read from the per-thread queue of the specified thread."
msgstr ""

#. type: TP
#: man-pages/man2/ptrace.2:425
#, no-wrap
msgid "B<PTRACE_GETSIGMASK> (since Linux 3.11)"
msgstr ""

#.  commit 29000caecbe87b6b66f144f72111f0d02fbbf0c1
#. type: Plain text
#: man-pages/man2/ptrace.2:440
msgid ""
"Place a copy of the mask of blocked signals (see B<sigprocmask>(2))  in the "
"buffer pointed to by I<data>, which should be a pointer to a buffer of type "
"I<sigset_t>.  The I<addr> argument contains the size of the buffer pointed "
"to by I<data> (i.e., I<sizeof(sigset_t)>)."
msgstr ""

#. type: TP
#: man-pages/man2/ptrace.2:440
#, no-wrap
msgid "B<PTRACE_SETSIGMASK> (since Linux 3.11)"
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:454
msgid ""
"Change the mask of blocked signals (see B<sigprocmask>(2))  to the value "
"specified in the buffer pointed to by I<data>, which should be a pointer to "
"a buffer of type I<sigset_t>.  The I<addr> argument contains the size of the "
"buffer pointed to by I<data> (i.e., I<sizeof(sigset_t)>)."
msgstr ""

#. type: TP
#: man-pages/man2/ptrace.2:454
#, no-wrap
msgid "B<PTRACE_SETOPTIONS> (since Linux 2.4.6; see BUGS for caveats)"
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:463
msgid ""
"Set ptrace options from I<data>.  (I<addr> is ignored.)  I<data> is "
"interpreted as a bit mask of options, which are specified by the following "
"flags:"
msgstr ""

#. type: TP
#: man-pages/man2/ptrace.2:464
#, no-wrap
msgid "B<PTRACE_O_EXITKILL> (since Linux 3.8)"
msgstr ""

#.  commit 992fb6e170639b0849bace8e49bf31bd37c4123
#. type: Plain text
#: man-pages/man2/ptrace.2:472
msgid ""
"Send a B<SIGKILL> signal to the tracee if the tracer exits.  This option is "
"useful for ptrace jailers that want to ensure that tracees can never escape "
"the tracer's control."
msgstr ""

#. type: TP
#: man-pages/man2/ptrace.2:472
#, no-wrap
msgid "B<PTRACE_O_TRACECLONE> (since Linux 2.5.46)"
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:489
msgid ""
"Stop the tracee at the next B<clone>(2)  and automatically start tracing the "
"newly cloned process, which will start with a B<SIGSTOP>, or "
"B<PTRACE_EVENT_STOP> if B<PTRACE_SEIZE> was used.  A B<waitpid>(2)  by the "
"tracer will return a I<status> value such that"
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:492
#, no-wrap
msgid "  statusE<gt>E<gt>8 == (SIGTRAP | (PTRACE_EVENT_CLONEE<lt>E<lt>8))\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:496 man-pages/man2/ptrace.2:582
#: man-pages/man2/ptrace.2:613
msgid "The PID of the new process can be retrieved with B<PTRACE_GETEVENTMSG>."
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:517
msgid ""
"This option may not catch B<clone>(2)  calls in all cases.  If the tracee "
"calls B<clone>(2)  with the B<CLONE_VFORK> flag, B<PTRACE_EVENT_VFORK> will "
"be delivered instead if B<PTRACE_O_TRACEVFORK> is set; otherwise if the "
"tracee calls B<clone>(2)  with the exit signal set to B<SIGCHLD>, "
"B<PTRACE_EVENT_FORK> will be delivered if B<PTRACE_O_TRACEFORK> is set."
msgstr ""

#. type: TP
#: man-pages/man2/ptrace.2:517
#, no-wrap
msgid "B<PTRACE_O_TRACEEXEC> (since Linux 2.5.46)"
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:526
msgid ""
"Stop the tracee at the next B<execve>(2).  A B<waitpid>(2)  by the tracer "
"will return a I<status> value such that"
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:529
#, no-wrap
msgid "  statusE<gt>E<gt>8 == (SIGTRAP | (PTRACE_EVENT_EXECE<lt>E<lt>8))\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:535
msgid ""
"If the execing thread is not a thread group leader, the thread ID is reset "
"to thread group leader's ID before this stop.  Since Linux 3.0, the former "
"thread ID can be retrieved with B<PTRACE_GETEVENTMSG>."
msgstr ""

#. type: TP
#: man-pages/man2/ptrace.2:535
#, no-wrap
msgid "B<PTRACE_O_TRACEEXIT> (since Linux 2.5.60)"
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:543
msgid ""
"Stop the tracee at exit.  A B<waitpid>(2)  by the tracer will return a "
"I<status> value such that"
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:546
#, no-wrap
msgid "  statusE<gt>E<gt>8 == (SIGTRAP | (PTRACE_EVENT_EXITE<lt>E<lt>8))\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:550
msgid "The tracee's exit status can be retrieved with B<PTRACE_GETEVENTMSG>."
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:558
msgid ""
"The tracee is stopped early during process exit, when registers are still "
"available, allowing the tracer to see where the exit occurred, whereas the "
"normal exit notification is done after the process is finished exiting.  "
"Even though context is available, the tracer cannot prevent the exit from "
"happening at this point."
msgstr ""

#. type: TP
#: man-pages/man2/ptrace.2:558
#, no-wrap
msgid "B<PTRACE_O_TRACEFORK> (since Linux 2.5.46)"
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:575
msgid ""
"Stop the tracee at the next B<fork>(2)  and automatically start tracing the "
"newly forked process, which will start with a B<SIGSTOP>, or "
"B<PTRACE_EVENT_STOP> if B<PTRACE_SEIZE> was used.  A B<waitpid>(2)  by the "
"tracer will return a I<status> value such that"
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:578
#, no-wrap
msgid "  statusE<gt>E<gt>8 == (SIGTRAP | (PTRACE_EVENT_FORKE<lt>E<lt>8))\n"
msgstr ""

#. type: TP
#: man-pages/man2/ptrace.2:582
#, no-wrap
msgid "B<PTRACE_O_TRACESYSGOOD> (since Linux 2.4.6)"
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:589
msgid ""
"When delivering system call traps, set bit 7 in the signal number (i.e., "
"deliver I<SIGTRAP|0x80>).  This makes it easy for the tracer to distinguish "
"normal traps from those caused by a system call."
msgstr ""

#. type: TP
#: man-pages/man2/ptrace.2:589
#, no-wrap
msgid "B<PTRACE_O_TRACEVFORK> (since Linux 2.5.46)"
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:606
msgid ""
"Stop the tracee at the next B<vfork>(2)  and automatically start tracing the "
"newly vforked process, which will start with a B<SIGSTOP>, or "
"B<PTRACE_EVENT_STOP> if B<PTRACE_SEIZE> was used.  A B<waitpid>(2)  by the "
"tracer will return a I<status> value such that"
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:609
#, no-wrap
msgid "  statusE<gt>E<gt>8 == (SIGTRAP | (PTRACE_EVENT_VFORKE<lt>E<lt>8))\n"
msgstr ""

#. type: TP
#: man-pages/man2/ptrace.2:613
#, no-wrap
msgid "B<PTRACE_O_TRACEVFORKDONE> (since Linux 2.5.60)"
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:622
msgid ""
"Stop the tracee at the completion of the next B<vfork>(2).  A B<waitpid>(2)  "
"by the tracer will return a I<status> value such that"
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:625
#, no-wrap
msgid "  statusE<gt>E<gt>8 == (SIGTRAP | (PTRACE_EVENT_VFORK_DONEE<lt>E<lt>8))\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:629
msgid ""
"The PID of the new process can (since Linux 2.6.18) be retrieved with "
"B<PTRACE_GETEVENTMSG>."
msgstr ""

#. type: TP
#: man-pages/man2/ptrace.2:629
#, no-wrap
msgid "B<PTRACE_O_TRACESECCOMP> (since Linux 3.5)"
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:640
msgid ""
"Stop the tracee when a B<seccomp>(2)  B<SECCOMP_RET_TRACE> rule is "
"triggered.  A B<waitpid>(2)  by the tracer will return a I<status> value "
"such that"
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:643
#, no-wrap
msgid "  statusE<gt>E<gt>8 == (SIGTRAP | (PTRACE_EVENT_SECCOMPE<lt>E<lt>8))\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:655
msgid ""
"While this triggers a B<PTRACE_EVENT> stop, it is similar to a "
"syscall-enter-stop.  For details, see the note on B<PTRACE_EVENT_SECCOMP> "
"below.  The seccomp event message data (from the B<SECCOMP_RET_DATA> portion "
"of the seccomp filter rule) can be retrieved with B<PTRACE_GETEVENTMSG>."
msgstr ""

#. type: TP
#: man-pages/man2/ptrace.2:655
#, no-wrap
msgid "B<PTRACE_O_SUSPEND_SECCOMP> (since Linux 4.3)"
msgstr ""

#.  commit 13c4a90119d28cfcb6b5bdd820c233b86c2b0237
#. type: Plain text
#: man-pages/man2/ptrace.2:671
msgid ""
"Suspend the tracee's seccomp protections.  This applies regardless of mode, "
"and can be used when the tracee has not yet installed seccomp filters.  That "
"is, a valid use case is to suspend a tracee's seccomp protections before "
"they are installed by the tracee, let the tracee install the filters, and "
"then clear this flag when the filters should be resumed.  Setting this "
"option requires that the tracer have the B<CAP_SYS_ADMIN> capability, not "
"have any seccomp protections installed, and not have "
"B<PTRACE_O_SUSPEND_SECCOMP> set on itself."
msgstr ""

#. type: TP
#: man-pages/man2/ptrace.2:672
#, no-wrap
msgid "B<PTRACE_GETEVENTMSG> (since Linux 2.5.46)"
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:699
msgid ""
"Retrieve a message (as an I<unsigned long>)  about the ptrace event that "
"just happened, placing it at the address I<data> in the tracer.  For "
"B<PTRACE_EVENT_EXIT>, this is the tracee's exit status.  For "
"B<PTRACE_EVENT_FORK>, B<PTRACE_EVENT_VFORK>, B<PTRACE_EVENT_VFORK_DONE>, and "
"B<PTRACE_EVENT_CLONE>, this is the PID of the new process.  For "
"B<PTRACE_EVENT_SECCOMP>, this is the B<seccomp>(2)  filter's "
"B<SECCOMP_RET_DATA> associated with the triggered rule.  (I<addr> is "
"ignored.)"
msgstr ""

#. type: TP
#: man-pages/man2/ptrace.2:699
#, no-wrap
msgid "B<PTRACE_CONT>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:711
msgid ""
"Restart the stopped tracee process.  If I<data> is nonzero, it is "
"interpreted as the number of a signal to be delivered to the tracee; "
"otherwise, no signal is delivered.  Thus, for example, the tracer can "
"control whether a signal sent to the tracee is delivered or not.  (I<addr> "
"is ignored.)"
msgstr ""

#. type: TP
#: man-pages/man2/ptrace.2:711
#, no-wrap
msgid "B<PTRACE_SYSCALL>, B<PTRACE_SINGLESTEP>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:735
msgid ""
"Restart the stopped tracee as for B<PTRACE_CONT>, but arrange for the tracee "
"to be stopped at the next entry to or exit from a system call, or after "
"execution of a single instruction, respectively.  (The tracee will also, as "
"usual, be stopped upon receipt of a signal.)  From the tracer's perspective, "
"the tracee will appear to have been stopped by receipt of a B<SIGTRAP>.  So, "
"for B<PTRACE_SYSCALL>, for example, the idea is to inspect the arguments to "
"the system call at the first stop, then do another B<PTRACE_SYSCALL> and "
"inspect the return value of the system call at the second stop.  The I<data> "
"argument is treated as for B<PTRACE_CONT>.  (I<addr> is ignored.)"
msgstr ""

#. type: TP
#: man-pages/man2/ptrace.2:735
#, no-wrap
msgid "B<PTRACE_SYSEMU>, B<PTRACE_SYSEMU_SINGLESTEP> (since Linux 2.6.14)"
msgstr ""

#.  As at 3.7
#. type: Plain text
#: man-pages/man2/ptrace.2:757
msgid ""
"For B<PTRACE_SYSEMU>, continue and stop on entry to the next system call, "
"which will not be executed.  See the documentation on syscall-stops below.  "
"For B<PTRACE_SYSEMU_SINGLESTEP>, do the same but also singlestep if not a "
"system call.  This call is used by programs like User Mode Linux that want "
"to emulate all the tracee's system calls.  The I<data> argument is treated "
"as for B<PTRACE_CONT>.  The I<addr> argument is ignored.  These requests are "
"currently supported only on x86."
msgstr ""

#. type: TP
#: man-pages/man2/ptrace.2:757
#, no-wrap
msgid "B<PTRACE_LISTEN> (since Linux 3.4)"
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:768
msgid ""
"Restart the stopped tracee, but prevent it from executing.  The resulting "
"state of the tracee is similar to a process which has been stopped by a "
"B<SIGSTOP> (or other stopping signal).  See the \"group-stop\" subsection "
"for additional information.  B<PTRACE_LISTEN> works only on tracees attached "
"by B<PTRACE_SEIZE>."
msgstr ""

#. type: TP
#: man-pages/man2/ptrace.2:768
#, no-wrap
msgid "B<PTRACE_KILL>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:777
msgid ""
"Send the tracee a B<SIGKILL> to terminate it.  (I<addr> and I<data> are "
"ignored.)"
msgstr ""

#.  [Note from Denys Vlasenko:
#.      deprecation suggested by Oleg Nesterov. He prefers to deprecate it
#.      instead of describing (and needing to support) PTRACE_KILL's quirks.]
#. type: Plain text
#: man-pages/man2/ptrace.2:796
msgid ""
"I<This operation is deprecated; do not use it!> Instead, send a B<SIGKILL> "
"directly using B<kill>(2)  or B<tgkill>(2).  The problem with B<PTRACE_KILL> "
"is that it requires the tracee to be in signal-delivery-stop, otherwise it "
"may not work (i.e., may complete successfully but won't kill the tracee).  "
"By contrast, sending a B<SIGKILL> directly has no such limitation."
msgstr ""

#. type: TP
#: man-pages/man2/ptrace.2:796
#, no-wrap
msgid "B<PTRACE_INTERRUPT> (since Linux 3.4)"
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:824
msgid ""
"Stop a tracee.  If the tracee is running or sleeping in kernel space and "
"B<PTRACE_SYSCALL> is in effect, the system call is interrupted and "
"syscall-exit-stop is reported.  (The interrupted system call is restarted "
"when the tracee is restarted.)  If the tracee was already stopped by a "
"signal and B<PTRACE_LISTEN> was sent to it, the tracee stops with "
"B<PTRACE_EVENT_STOP> and I<WSTOPSIG(status)> returns the stop signal.  If "
"any other ptrace-stop is generated at the same time (for example, if a "
"signal is sent to the tracee), this ptrace-stop happens.  If none of the "
"above applies (for example, if the tracee is running in user space), it "
"stops with B<PTRACE_EVENT_STOP> with I<WSTOPSIG(status)> == B<SIGTRAP>.  "
"B<PTRACE_INTERRUPT> only works on tracees attached by B<PTRACE_SEIZE>."
msgstr ""

#. type: TP
#: man-pages/man2/ptrace.2:824
#, no-wrap
msgid "B<PTRACE_ATTACH>"
msgstr ""

#.  No longer true (removed by Denys Vlasenko, 2011, who remarks:
#.         "I think it isn't true in non-ancient 2.4 and in 2.6/3.x.
#.          Basically, it's not true for any Linux in practical use.
#.  ; the behavior of the tracee is as if it had done a
#.  .BR PTRACE_TRACEME .
#.  The calling process actually becomes the parent of the tracee
#.  process for most purposes (e.g., it will receive
#.  notification of tracee events and appears in
#.  .BR ps (1)
#.  output as the tracee's parent), but a
#.  .BR getppid (2)
#.  by the tracee will still return the PID of the original parent.
#. type: Plain text
#: man-pages/man2/ptrace.2:852
msgid ""
"Attach to the process specified in I<pid>, making it a tracee of the calling "
"process.  The tracee is sent a B<SIGSTOP>, but will not necessarily have "
"stopped by the completion of this call; use B<waitpid>(2)  to wait for the "
"tracee to stop.  See the \"Attaching and detaching\" subsection for "
"additional information.  (I<addr> and I<data> are ignored.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:858
msgid ""
"Permission to perform a B<PTRACE_ATTACH> is governed by a ptrace access mode "
"B<PTRACE_MODE_ATTACH_REALCREDS> check; see below."
msgstr ""

#. type: TP
#: man-pages/man2/ptrace.2:858
#, no-wrap
msgid "B<PTRACE_SEIZE> (since Linux 3.4)"
msgstr ""

#
#.  Noted by Dmitry Levin:
#
#.      PTRACE_SEIZE was introduced by commit v3.1-rc1~308^2~28, but
#.      it had to be used along with a temporary flag PTRACE_SEIZE_DEVEL,
#.      which was removed later by commit v3.4-rc1~109^2~20.
#
#.      That is, [before] v3.4 we had a test mode of PTRACE_SEIZE API,
#.      which was not compatible with the current PTRACE_SEIZE API introduced
#.      in Linux 3.4.
#. type: Plain text
#: man-pages/man2/ptrace.2:912
msgid ""
"Attach to the process specified in I<pid>, making it a tracee of the calling "
"process.  Unlike B<PTRACE_ATTACH>, B<PTRACE_SEIZE> does not stop the "
"process.  Group-stops are reported as B<PTRACE_EVENT_STOP> and "
"I<WSTOPSIG(status)> returns the stop signal.  Automatically attached "
"children stop with B<PTRACE_EVENT_STOP> and I<WSTOPSIG(status)> returns "
"B<SIGTRAP> instead of having B<SIGSTOP> signal delivered to them.  "
"B<execve>(2)  does not deliver an extra B<SIGTRAP>.  Only a B<PTRACE_SEIZE>d "
"process can accept B<PTRACE_INTERRUPT> and B<PTRACE_LISTEN> commands.  The "
"\"seized\" behavior just described is inherited by children that are "
"automatically attached using B<PTRACE_O_TRACEFORK>, B<PTRACE_O_TRACEVFORK>, "
"and B<PTRACE_O_TRACECLONE>.  I<addr> must be zero.  I<data> contains a bit "
"mask of ptrace options to activate immediately."
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:919
msgid ""
"Permission to perform a B<PTRACE_SEIZE> is governed by a ptrace access mode "
"B<PTRACE_MODE_ATTACH_REALCREDS> check; see below."
msgstr ""

#. type: TP
#: man-pages/man2/ptrace.2:919
#, no-wrap
msgid "B<PTRACE_SECCOMP_GET_FILTER> (since Linux 4.4)"
msgstr ""

#.  commit f8e529ed941ba2bbcbf310b575d968159ce7e895
#. type: Plain text
#: man-pages/man2/ptrace.2:924
msgid "This operation allows the tracer to dump the tracee's classic BPF filters."
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:933
msgid ""
"I<addr> is an integer specifying the index of the filter to be dumped.  The "
"most recently installed filter has the index 0.  If I<addr> is greater than "
"the number of installed filters, the operation fails with the error "
"B<ENOENT>."
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:939
msgid ""
"I<data> is either a pointer to a I<struct sock_filter> array that is large "
"enough to store the BPF program, or NULL if the program is not to be stored."
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:947
msgid ""
"Upon success, the return value is the number of instructions in the BPF "
"program.  If I<data> was NULL, then this return value can be used to "
"correctly size the I<struct sock_filter> array passed in a subsequent call."
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:957
msgid ""
"This operation fails with the error B<EACCES> if the caller does not have "
"the B<CAP_SYS_ADMIN> capability or if the caller is in strict or filter "
"seccomp mode.  If the filter referred to by I<addr> is not a classic BPF "
"filter, the operation fails with the error B<EMEDIUMTYPE>."
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:963
msgid ""
"This operation is available if the kernel was configured with both the "
"B<CONFIG_SECCOMP_FILTER> and the B<CONFIG_CHECKPOINT_RESTORE> options."
msgstr ""

#. type: TP
#: man-pages/man2/ptrace.2:963
#, no-wrap
msgid "B<PTRACE_DETACH>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:973
msgid ""
"Restart the stopped tracee as for B<PTRACE_CONT>, but first detach from it.  "
"Under Linux, a tracee can be detached in this way regardless of which method "
"was used to initiate tracing.  (I<addr> is ignored.)"
msgstr ""

#. type: TP
#: man-pages/man2/ptrace.2:973
#, no-wrap
msgid "B<PTRACE_GET_THREAD_AREA> (since Linux 2.6.0)"
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:990
msgid ""
"This operation performs a similar task to B<get_thread_area>(2).  It reads "
"the TLS entry in the GDT whose index is given in I<addr>, placing a copy of "
"the entry into the I<struct user_desc> pointed to by I<data>.  (By contrast "
"with B<get_thread_area>(2), the I<entry_number> of the I<struct user_desc> "
"is ignored.)"
msgstr ""

#. type: TP
#: man-pages/man2/ptrace.2:990
#, no-wrap
msgid "B<PTRACE_SET_THREAD_AREA> (since Linux 2.6.0)"
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:1008
msgid ""
"This operation performs a similar task to B<set_thread_area>(2).  It sets "
"the TLS entry in the GDT whose index is given in I<addr>, assigning it the "
"data supplied in the I<struct user_desc> pointed to by I<data>.  (By "
"contrast with B<set_thread_area>(2), the I<entry_number> of the I<struct "
"user_desc> is ignored; in other words, this ptrace operation can't be used "
"to allocate a free TLS entry.)"
msgstr ""

#. type: TP
#: man-pages/man2/ptrace.2:1008
#, no-wrap
msgid "B<PTRACE_GET_SYSCALL_INFO> (since Linux 5.3)"
msgstr ""

#.  commit 201766a20e30f982ccfe36bebfad9602c3ff574a
#. type: Plain text
#: man-pages/man2/ptrace.2:1029
msgid ""
"Retrieve information about the system call that caused the stop.  The "
"information is placed into the buffer pointed by the I<data> argument, which "
"should be a pointer to a buffer of type I<struct ptrace_syscall_info>.  The "
"I<addr> argument contains the size of the buffer pointed to by the I<data> "
"argument (i.e., I<sizeof(struct ptrace_syscall_info)>).  The return value "
"contains the number of bytes available to be written by the kernel.  If the "
"size of the data to be written by the kernel exceeds the size specified by "
"the I<addr> argument, the output data is truncated."
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:1033
msgid "The I<ptrace_syscall_info> structure contains the following fields:"
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:1062
#, no-wrap
msgid ""
"struct ptrace_syscall_info {\n"
"    __u8 op;         /* Type of system call stop */\n"
"    __u32 arch;      /* AUDIT_ARCH_* value; see seccomp(2) */\n"
"    __u64 instruction_pointer; /* CPU instruction pointer */\n"
"    __u64 stack_pointer;       /* CPU stack pointer */\n"
"    union {\n"
"        struct {     /* op == PTRACE_SYSCALL_INFO_ENTRY */\n"
"            __u64 nr;          /* System call number */\n"
"            __u64 args[6];     /* System call arguments */\n"
"        } entry;\n"
"        struct {     /* op == PTRACE_SYSCALL_INFO_EXIT */\n"
"            __s64 rval;        /* System call return value */\n"
"            __u8 is_error;     /* System call error flag;\n"
"                                  Boolean: does rval contain\n"
"                                  an error value (-ERRCODE) or\n"
"                                  a nonerror return value? */\n"
"        } exit;\n"
"        struct {     /* op == PTRACE_SYSCALL_INFO_SECCOMP */\n"
"            __u64 nr;          /* System call number */\n"
"            __u64 args[6];     /* System call arguments */\n"
"            __u32 ret_data;    /* SECCOMP_RET_DATA portion\n"
"                                  of SECCOMP_RET_TRACE\n"
"                                  return value */\n"
"        } seccomp;\n"
"    };\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:1076
msgid ""
"The I<op>, I<arch>, I<instruction_pointer>, and I<stack_pointer> fields are "
"defined for all kinds of ptrace system call stops.  The rest of the "
"structure is a union; one should read only those fields that are meaningful "
"for the kind of system call stop specified by the I<op> field."
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:1083
msgid ""
"The I<op> field has one of the following values (defined in "
"I<E<lt>linux/ptrace.hE<gt>)> indicating what type of stop occurred and which "
"part of the union is filled:"
msgstr ""

#. type: TP
#: man-pages/man2/ptrace.2:1084
#, no-wrap
msgid "B<PTRACE_SYSCALL_INFO_ENTRY>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:1090
msgid ""
"The I<entry> component of the union contains information relating to a "
"system call entry stop."
msgstr ""

#. type: TP
#: man-pages/man2/ptrace.2:1090
#, no-wrap
msgid "B<PTRACE_SYSCALL_INFO_EXIT>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:1096
msgid ""
"The I<exit> component of the union contains information relating to a system "
"call exit stop."
msgstr ""

#. type: TP
#: man-pages/man2/ptrace.2:1096
#, no-wrap
msgid "B<PTRACE_SYSCALL_INFO_SECCOMP>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:1103
msgid ""
"The I<exit> component of the union contains information relating to a "
"B<PTRACE_EVENT_SECCOMP> stop."
msgstr ""

#. type: TP
#: man-pages/man2/ptrace.2:1103
#, no-wrap
msgid "B<PTRACE_SYSCALL_INFO_NONE>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:1106
msgid "No component of the union contains relevant information."
msgstr ""

#. type: SS
#: man-pages/man2/ptrace.2:1108
#, no-wrap
msgid "Death under ptrace"
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:1117
msgid ""
"When a (possibly multithreaded) process receives a killing signal (one whose "
"disposition is set to B<SIG_DFL> and whose default action is to kill the "
"process), all threads exit.  Tracees report their death to their tracer(s).  "
"Notification of this event is delivered via B<waitpid>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:1126
msgid ""
"Note that the killing signal will first cause signal-delivery-stop (on one "
"tracee only), and only after it is injected by the tracer (or after it was "
"dispatched to a thread which isn't traced), will death from the signal "
"happen on I<all> tracees within a multithreaded process.  (The term "
"\"signal-delivery-stop\" is explained below.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:1138
msgid ""
"B<SIGKILL> does not generate signal-delivery-stop and therefore the tracer "
"can't suppress it.  B<SIGKILL> kills even within system calls "
"(syscall-exit-stop is not generated prior to death by B<SIGKILL>).  The net "
"effect is that B<SIGKILL> always kills the process (all its threads), even "
"if some threads of the process are ptraced."
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:1143
msgid ""
"When the tracee calls B<_exit>(2), it reports its death to its tracer.  "
"Other threads are not affected."
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:1147
msgid ""
"When any thread executes B<exit_group>(2), every tracee in its thread group "
"reports its death to its tracer."
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:1162
msgid ""
"If the B<PTRACE_O_TRACEEXIT> option is on, B<PTRACE_EVENT_EXIT> will happen "
"before actual death.  This applies to exits via B<exit>(2), "
"B<exit_group>(2), and signal deaths (except B<SIGKILL>, depending on the "
"kernel version; see BUGS below), and when threads are torn down on "
"B<execve>(2)  in a multithreaded process."
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:1187
msgid ""
"The tracer cannot assume that the ptrace-stopped tracee exists.  There are "
"many scenarios when the tracee may die while stopped (such as B<SIGKILL>).  "
"Therefore, the tracer must be prepared to handle an B<ESRCH> error on any "
"ptrace operation.  Unfortunately, the same error is returned if the tracee "
"exists but is not ptrace-stopped (for commands which require a stopped "
"tracee), or if it is not traced by the process which issued the ptrace "
"call.  The tracer needs to keep track of the stopped/running state of the "
"tracee, and interpret B<ESRCH> as \"tracee died unexpectedly\" only if it "
"knows that the tracee has been observed to enter ptrace-stop.  Note that "
"there is no guarantee that I<waitpid(WNOHANG)> will reliably report the "
"tracee's death status if a ptrace operation returned B<ESRCH>.  "
"I<waitpid(WNOHANG)> may return 0 instead.  In other words, the tracee may be "
"\"not yet fully dead\", but already refusing ptrace requests."
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:1201
msgid ""
"The tracer can't assume that the tracee I<always> ends its life by reporting "
"I<WIFEXITED(status)> or I<WIFSIGNALED(status)>; there are cases where this "
"does not occur.  For example, if a thread other than thread group leader "
"does an B<execve>(2), it disappears; its PID will never be seen again, and "
"any subsequent ptrace stops will be reported under the thread group leader's "
"PID."
msgstr ""

#. type: SS
#: man-pages/man2/ptrace.2:1201
#, no-wrap
msgid "Stopped states"
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:1223
msgid ""
"A tracee can be in two states: running or stopped.  For the purposes of "
"ptrace, a tracee which is blocked in a system call (such as B<read>(2), "
"B<pause>(2), etc.)  is nevertheless considered to be running, even if the "
"tracee is blocked for a long time.  The state of the tracee after "
"B<PTRACE_LISTEN> is somewhat of a gray area: it is not in any ptrace-stop "
"(ptrace commands won't work on it, and it will deliver B<waitpid>(2)  "
"notifications), but it also may be considered \"stopped\" because it is not "
"executing instructions (is not scheduled), and if it was in group-stop "
"before B<PTRACE_LISTEN>, it will not respond to signals until B<SIGCONT> is "
"received."
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:1227
msgid ""
"There are many kinds of states when the tracee is stopped, and in ptrace "
"discussions they are often conflated.  Therefore, it is important to use "
"precise terms."
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:1239
msgid ""
"In this manual page, any stopped state in which the tracee is ready to "
"accept ptrace commands from the tracer is called I<ptrace-stop>.  "
"Ptrace-stops can be further subdivided into I<signal-delivery-stop>, "
"I<group-stop>, I<syscall-stop>, I<PTRACE_EVENT stops>, and so on.  These "
"stopped states are described in detail below."
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:1244
msgid ""
"When the running tracee enters ptrace-stop, it notifies its tracer using "
"B<waitpid>(2)  (or one of the other \"wait\" system calls).  Most of this "
"manual page assumes that the tracer waits with:"
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:1246
#, no-wrap
msgid "    pid = waitpid(pid_or_minus_1, &status, __WALL);\n"
msgstr ""

#.  Denys Vlasenko:
#.      Do we require __WALL usage, or will just using 0 be ok? (With 0,
#.      I am not 100% sure there aren't ugly corner cases.) Are the
#.      rules different if user wants to use waitid? Will waitid require
#.      WEXITED?
#. type: Plain text
#: man-pages/man2/ptrace.2:1258
msgid ""
"Ptrace-stopped tracees are reported as returns with I<pid> greater than 0 "
"and I<WIFSTOPPED(status)> true."
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:1266
msgid ""
"The B<__WALL> flag does not include the B<WSTOPPED> and B<WEXITED> flags, "
"but implies their functionality."
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:1273
msgid ""
"Setting the B<WCONTINUED> flag when calling B<waitpid>(2)  is not "
"recommended: the \"continued\" state is per-process and consuming it can "
"confuse the real parent of the tracee."
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:1281
msgid ""
"Use of the B<WNOHANG> flag may cause B<waitpid>(2)  to return 0 (\"no wait "
"results available yet\")  even if the tracer knows there should be a "
"notification.  Example:"
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:1291
#, no-wrap
msgid ""
"errno = 0;\n"
"ptrace(PTRACE_CONT, pid, 0L, 0L);\n"
"if (errno == ESRCH) {\n"
"    /* tracee is dead */\n"
"    r = waitpid(tracee, &status, __WALL | WNOHANG);\n"
"    /* r can still be 0 here! */\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:1315
msgid ""
"The following kinds of ptrace-stops exist: signal-delivery-stops, "
"group-stops, B<PTRACE_EVENT> stops, syscall-stops.  They all are reported by "
"B<waitpid>(2)  with I<WIFSTOPPED(status)> true.  They may be differentiated "
"by examining the value I<statusE<gt>E<gt>8>, and if there is ambiguity in "
"that value, by querying B<PTRACE_GETSIGINFO>.  (Note: the "
"I<WSTOPSIG(status)> macro can't be used to perform this examination, because "
"it returns the value I<(statusE<gt>E<gt>8)\\ &\\ 0xff>.)"
msgstr ""

#. type: SS
#: man-pages/man2/ptrace.2:1315
#, no-wrap
msgid "Signal-delivery-stop"
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:1335
msgid ""
"When a (possibly multithreaded) process receives any signal except "
"B<SIGKILL>, the kernel selects an arbitrary thread which handles the "
"signal.  (If the signal is generated with B<tgkill>(2), the target thread "
"can be explicitly selected by the caller.)  If the selected thread is "
"traced, it enters signal-delivery-stop.  At this point, the signal is not "
"yet delivered to the process, and can be suppressed by the tracer.  If the "
"tracer doesn't suppress the signal, it passes the signal to the tracee in "
"the next ptrace restart request.  This second step of signal delivery is "
"called I<signal injection> in this manual page.  Note that if the signal is "
"blocked, signal-delivery-stop doesn't happen until the signal is unblocked, "
"with the usual exception that B<SIGSTOP> can't be blocked."
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:1349
msgid ""
"Signal-delivery-stop is observed by the tracer as B<waitpid>(2)  returning "
"with I<WIFSTOPPED(status)> true, with the signal returned by "
"I<WSTOPSIG(status)>.  If the signal is B<SIGTRAP>, this may be a different "
"kind of ptrace-stop; see the \"Syscall-stops\" and \"execve\" sections below "
"for details.  If I<WSTOPSIG(status)> returns a stopping signal, this may be "
"a group-stop; see below."
msgstr ""

#. type: SS
#: man-pages/man2/ptrace.2:1349
#, no-wrap
msgid "Signal injection and suppression"
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:1352
msgid ""
"After signal-delivery-stop is observed by the tracer, the tracer should "
"restart the tracee with the call"
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:1354
#, no-wrap
msgid "    ptrace(PTRACE_restart, pid, 0, sig)\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:1367
msgid ""
"where B<PTRACE_restart> is one of the restarting ptrace requests.  If I<sig> "
"is 0, then a signal is not delivered.  Otherwise, the signal I<sig> is "
"delivered.  This operation is called I<signal injection> in this manual "
"page, to distinguish it from signal-delivery-stop."
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:1373
msgid ""
"The I<sig> value may be different from the I<WSTOPSIG(status)> value: the "
"tracer can cause a different signal to be injected."
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:1389
msgid ""
"Note that a suppressed signal still causes system calls to return "
"prematurely.  In this case, system calls will be restarted: the tracer will "
"observe the tracee to reexecute the interrupted system call (or "
"B<restart_syscall>(2)  system call for a few system calls which use a "
"different mechanism for restarting) if the tracer uses B<PTRACE_SYSCALL>.  "
"Even system calls (such as B<poll>(2))  which are not restartable after "
"signal are restarted after signal is suppressed; however, kernel bugs exist "
"which cause some system calls to fail with B<EINTR> even though no "
"observable signal is injected to the tracee."
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:1400
msgid ""
"Restarting ptrace commands issued in ptrace-stops other than "
"signal-delivery-stop are not guaranteed to inject a signal, even if I<sig> "
"is nonzero.  No error is reported; a nonzero I<sig> may simply be ignored.  "
"Ptrace users should not try to \"create a new signal\" this way: use "
"B<tgkill>(2)  instead."
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:1407
msgid ""
"The fact that signal injection requests may be ignored when restarting the "
"tracee after ptrace stops that are not signal-delivery-stops is a cause of "
"confusion among ptrace users.  One typical scenario is that the tracer "
"observes group-stop, mistakes it for signal-delivery-stop, restarts the "
"tracee with"
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:1409
#, no-wrap
msgid "    ptrace(PTRACE_restart, pid, 0, stopsig)\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:1415
msgid ""
"with the intention of injecting I<stopsig>, but I<stopsig> gets ignored and "
"the tracee continues to run."
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:1435
msgid ""
"The B<SIGCONT> signal has a side effect of waking up (all threads of)  a "
"group-stopped process.  This side effect happens before "
"signal-delivery-stop.  The tracer can't suppress this side effect (it can "
"only suppress signal injection, which only causes the B<SIGCONT> handler to "
"not be executed in the tracee, if such a handler is installed).  In fact, "
"waking up from group-stop may be followed by signal-delivery-stop for "
"signal(s)  I<other than> B<SIGCONT>, if they were pending when B<SIGCONT> "
"was delivered.  In other words, B<SIGCONT> may be not the first signal "
"observed by the tracee after it was sent."
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:1439
msgid ""
"Stopping signals cause (all threads of) a process to enter group-stop.  This "
"side effect happens after signal injection, and therefore can be suppressed "
"by the tracer."
msgstr ""

#.  In the Linux 2.4 sources, in arch/i386/kernel/signal.c::do_signal(),
#.  there is:
#
#.              /* The debugger continued.  Ignore SIGSTOP.  */
#.              if (signr == SIGSTOP)
#.                      continue;
#. type: Plain text
#: man-pages/man2/ptrace.2:1449
msgid "In Linux 2.4 and earlier, the B<SIGSTOP> signal can't be injected."
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:1466
msgid ""
"B<PTRACE_GETSIGINFO> can be used to retrieve a I<siginfo_t> structure which "
"corresponds to the delivered signal.  B<PTRACE_SETSIGINFO> may be used to "
"modify it.  If B<PTRACE_SETSIGINFO> has been used to alter I<siginfo_t>, the "
"I<si_signo> field and the I<sig> parameter in the restarting command must "
"match, otherwise the result is undefined."
msgstr ""

#. type: SS
#: man-pages/man2/ptrace.2:1466
#, no-wrap
msgid "Group-stop"
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:1478
msgid ""
"When a (possibly multithreaded) process receives a stopping signal, all "
"threads stop.  If some threads are traced, they enter a group-stop.  Note "
"that the stopping signal will first cause signal-delivery-stop (on one "
"tracee only), and only after it is injected by the tracer (or after it was "
"dispatched to a thread which isn't traced), will group-stop be initiated on "
"I<all> tracees within the multithreaded process.  As usual, every tracee "
"reports its group-stop separately to the corresponding tracer."
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:1487
msgid ""
"Group-stop is observed by the tracer as B<waitpid>(2)  returning with "
"I<WIFSTOPPED(status)> true, with the stopping signal available via "
"I<WSTOPSIG(status)>.  The same result is returned by some other classes of "
"ptrace-stops, therefore the recommended practice is to perform the call"
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:1489
#, no-wrap
msgid "    ptrace(PTRACE_GETSIGINFO, pid, 0, &siginfo)\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:1510
msgid ""
"The call can be avoided if the signal is not B<SIGSTOP>, B<SIGTSTP>, "
"B<SIGTTIN>, or B<SIGTTOU>; only these four signals are stopping signals.  If "
"the tracer sees something else, it can't be a group-stop.  Otherwise, the "
"tracer needs to call B<PTRACE_GETSIGINFO>.  If B<PTRACE_GETSIGINFO> fails "
"with B<EINVAL>, then it is definitely a group-stop.  (Other failure codes "
"are possible, such as B<ESRCH> (\"no such process\") if a B<SIGKILL> killed "
"the tracee.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:1520
msgid ""
"If tracee was attached using B<PTRACE_SEIZE>, group-stop is indicated by "
"B<PTRACE_EVENT_STOP>: I<statusE<gt>E<gt>16 == PTRACE_EVENT_STOP>.  This "
"allows detection of group-stops without requiring an extra "
"B<PTRACE_GETSIGINFO> call."
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:1529
msgid ""
"As of Linux 2.6.38, after the tracer sees the tracee ptrace-stop and until "
"it restarts or kills it, the tracee will not run, and will not send "
"notifications (except B<SIGKILL> death) to the tracer, even if the tracer "
"enters into another B<waitpid>(2)  call."
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:1543
msgid ""
"The kernel behavior described in the previous paragraph causes a problem "
"with transparent handling of stopping signals.  If the tracer restarts the "
"tracee after group-stop, the stopping signal is effectively ignored\\(emthe "
"tracee doesn't remain stopped, it runs.  If the tracer doesn't restart the "
"tracee before entering into the next B<waitpid>(2), future B<SIGCONT> "
"signals will not be reported to the tracer; this would cause the B<SIGCONT> "
"signals to have no effect on the tracee."
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:1554
msgid ""
"Since Linux 3.4, there is a method to overcome this problem: instead of "
"B<PTRACE_CONT>, a B<PTRACE_LISTEN> command can be used to restart a tracee "
"in a way where it does not execute, but waits for a new event which it can "
"report via B<waitpid>(2)  (such as when it is restarted by a B<SIGCONT>)."
msgstr ""

#. type: SS
#: man-pages/man2/ptrace.2:1554
#, no-wrap
msgid "PTRACE_EVENT stops"
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:1560
msgid ""
"If the tracer sets B<PTRACE_O_TRACE_*> options, the tracee will enter "
"ptrace-stops called B<PTRACE_EVENT> stops."
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:1574
msgid ""
"B<PTRACE_EVENT> stops are observed by the tracer as B<waitpid>(2)  returning "
"with I<WIFSTOPPED(status)>, and I<WSTOPSIG(status)> returns B<SIGTRAP>.  An "
"additional bit is set in the higher byte of the status word: the value "
"I<statusE<gt>E<gt>8> will be"
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:1576
#, no-wrap
msgid "    (SIGTRAP | PTRACE_EVENT_foo E<lt>E<lt> 8).\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:1578
msgid "The following events exist:"
msgstr ""

#. type: TP
#: man-pages/man2/ptrace.2:1578
#, no-wrap
msgid "B<PTRACE_EVENT_VFORK>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:1591
msgid ""
"Stop before return from B<vfork>(2)  or B<clone>(2)  with the B<CLONE_VFORK> "
"flag.  When the tracee is continued after this stop, it will wait for child "
"to exit/exec before continuing its execution (in other words, the usual "
"behavior on B<vfork>(2))."
msgstr ""

#. type: TP
#: man-pages/man2/ptrace.2:1591
#, no-wrap
msgid "B<PTRACE_EVENT_FORK>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:1599
msgid ""
"Stop before return from B<fork>(2)  or B<clone>(2)  with the exit signal set "
"to B<SIGCHLD>."
msgstr ""

#. type: TP
#: man-pages/man2/ptrace.2:1599
#, no-wrap
msgid "B<PTRACE_EVENT_CLONE>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:1603
msgid "Stop before return from B<clone>(2)."
msgstr ""

#. type: TP
#: man-pages/man2/ptrace.2:1603
#, no-wrap
msgid "B<PTRACE_EVENT_VFORK_DONE>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:1613
msgid ""
"Stop before return from B<vfork>(2)  or B<clone>(2)  with the B<CLONE_VFORK> "
"flag, but after the child unblocked this tracee by exiting or execing."
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:1619
msgid ""
"For all four stops described above, the stop occurs in the parent (i.e., the "
"tracee), not in the newly created thread.  B<PTRACE_GETEVENTMSG> can be used "
"to retrieve the new thread's ID."
msgstr ""

#. type: TP
#: man-pages/man2/ptrace.2:1619
#, no-wrap
msgid "B<PTRACE_EVENT_EXEC>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:1626
msgid ""
"Stop before return from B<execve>(2).  Since Linux 3.0, "
"B<PTRACE_GETEVENTMSG> returns the former thread ID."
msgstr ""

#. type: TP
#: man-pages/man2/ptrace.2:1626
#, no-wrap
msgid "B<PTRACE_EVENT_EXIT>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:1642
msgid ""
"Stop before exit (including death from B<exit_group>(2)), signal death, or "
"exit caused by B<execve>(2)  in a multithreaded process.  "
"B<PTRACE_GETEVENTMSG> returns the exit status.  Registers can be examined "
"(unlike when \"real\" exit happens).  The tracee is still alive; it needs to "
"be B<PTRACE_CONT>ed or B<PTRACE_DETACH>ed to finish exiting."
msgstr ""

#. type: TP
#: man-pages/man2/ptrace.2:1642
#, no-wrap
msgid "B<PTRACE_EVENT_STOP>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:1649
msgid ""
"Stop induced by B<PTRACE_INTERRUPT> command, or group-stop, or initial "
"ptrace-stop when a new child is attached (only if attached using "
"B<PTRACE_SEIZE>)."
msgstr ""

#. type: TP
#: man-pages/man2/ptrace.2:1649
#, no-wrap
msgid "B<PTRACE_EVENT_SECCOMP>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:1662
msgid ""
"Stop triggered by a B<seccomp>(2)  rule on tracee syscall entry when "
"B<PTRACE_O_TRACESECCOMP> has been set by the tracer.  The seccomp event "
"message data (from the B<SECCOMP_RET_DATA> portion of the seccomp filter "
"rule) can be retrieved with B<PTRACE_GETEVENTMSG>.  The semantics of this "
"stop are described in detail in a separate section below."
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:1674
msgid ""
"B<PTRACE_GETSIGINFO> on B<PTRACE_EVENT> stops returns B<SIGTRAP> in "
"I<si_signo>, with I<si_code> set to I<(eventE<lt>E<lt>8)\\ |\\ SIGTRAP>."
msgstr ""

#. type: SS
#: man-pages/man2/ptrace.2:1674
#, no-wrap
msgid "Syscall-stops"
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:1701
msgid ""
"If the tracee was restarted by B<PTRACE_SYSCALL> or B<PTRACE_SYSEMU>, the "
"tracee enters syscall-enter-stop just prior to entering any system call "
"(which will not be executed if the restart was using B<PTRACE_SYSEMU>, "
"regardless of any change made to registers at this point or how the tracee "
"is restarted after this stop).  No matter which method caused the "
"syscall-entry-stop, if the tracer restarts the tracee with "
"B<PTRACE_SYSCALL>, the tracee enters syscall-exit-stop when the system call "
"is finished, or if it is interrupted by a signal.  (That is, "
"signal-delivery-stop never happens between syscall-enter-stop and "
"syscall-exit-stop; it happens I<after> syscall-exit-stop.).  If the tracee "
"is continued using any other method (including B<PTRACE_SYSEMU>), no "
"syscall-exit-stop occurs.  Note that all mentions B<PTRACE_SYSEMU> apply "
"equally to B<PTRACE_SYSEMU_SINGLESTEP.>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:1718
msgid ""
"However, even if the tracee was continued using B<PTRACE_SYSCALL>, it is not "
"guaranteed that the next stop will be a syscall-exit-stop.  Other "
"possibilities are that the tracee may stop in a B<PTRACE_EVENT> stop "
"(including seccomp stops), exit (if it entered B<_exit>(2)  or "
"B<exit_group>(2)), be killed by B<SIGKILL>, or die silently (if it is a "
"thread group leader, the B<execve>(2)  happened in another thread, and that "
"thread is not traced by the same tracer; this situation is discussed later)."
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:1733
msgid ""
"Syscall-enter-stop and syscall-exit-stop are observed by the tracer as "
"B<waitpid>(2)  returning with I<WIFSTOPPED(status)> true, and "
"I<WSTOPSIG(status)> giving B<SIGTRAP>.  If the B<PTRACE_O_TRACESYSGOOD> "
"option was set by the tracer, then I<WSTOPSIG(status)> will give the value "
"I<(SIGTRAP\\ |\\ 0x80)>."
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:1739
msgid ""
"Syscall-stops can be distinguished from signal-delivery-stop with B<SIGTRAP> "
"by querying B<PTRACE_GETSIGINFO> for the following cases:"
msgstr ""

#. type: TP
#: man-pages/man2/ptrace.2:1739
#, no-wrap
msgid "I<si_code> E<lt>= 0"
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:1751
msgid ""
"B<SIGTRAP> was delivered as a result of a user-space action, for example, a "
"system call (B<tgkill>(2), B<kill>(2), B<sigqueue>(3), etc.), expiration of "
"a POSIX timer, change of state on a POSIX message queue, or completion of an "
"asynchronous I/O request."
msgstr ""

#. type: TP
#: man-pages/man2/ptrace.2:1751
#, no-wrap
msgid "I<si_code> == SI_KERNEL (0x80)"
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:1755
msgid "B<SIGTRAP> was sent by the kernel."
msgstr ""

#. type: TP
#: man-pages/man2/ptrace.2:1755
#, no-wrap
msgid "I<si_code> == SIGTRAP or I<si_code> == (SIGTRAP|0x80)"
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:1758
msgid "This is a syscall-stop."
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:1763
msgid ""
"However, syscall-stops happen very often (twice per system call), and "
"performing B<PTRACE_GETSIGINFO> for every syscall-stop may be somewhat "
"expensive."
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:1786
msgid ""
"Some architectures allow the cases to be distinguished by examining "
"registers.  For example, on x86, I<rax> == -B<ENOSYS> in "
"syscall-enter-stop.  Since B<SIGTRAP> (like any other signal) always happens "
"I<after> syscall-exit-stop, and at this point I<rax> almost never contains "
"-B<ENOSYS>, the B<SIGTRAP> looks like \"syscall-stop which is not "
"syscall-enter-stop\"; in other words, it looks like a \"stray "
"syscall-exit-stop\" and can be detected this way.  But such detection is "
"fragile and is best avoided."
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:1792
msgid ""
"Using the B<PTRACE_O_TRACESYSGOOD> option is the recommended method to "
"distinguish syscall-stops from other kinds of ptrace-stops, since it is "
"reliable and does not incur a performance penalty."
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:1807
msgid ""
"Syscall-enter-stop and syscall-exit-stop are indistinguishable from each "
"other by the tracer.  The tracer needs to keep track of the sequence of "
"ptrace-stops in order to not misinterpret syscall-enter-stop as "
"syscall-exit-stop or vice versa.  In general, a syscall-enter-stop is always "
"followed by syscall-exit-stop, B<PTRACE_EVENT> stop, or the tracee's death; "
"no other kinds of ptrace-stop can occur in between.  However, note that "
"seccomp stops (see below) can cause syscall-exit-stops, without preceding "
"syscall-entry-stops.  If seccomp is in use, care needs to be taken not to "
"misinterpret such stops as syscall-entry-stops."
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:1812
msgid ""
"If after syscall-enter-stop, the tracer uses a restarting command other than "
"B<PTRACE_SYSCALL>, syscall-exit-stop is not generated."
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:1825
msgid ""
"B<PTRACE_GETSIGINFO> on syscall-stops returns B<SIGTRAP> in I<si_signo>, "
"with I<si_code> set to B<SIGTRAP> or I<(SIGTRAP|0x80)>."
msgstr ""

#. type: SS
#: man-pages/man2/ptrace.2:1825
#, no-wrap
msgid "PTRACE_EVENT_SECCOMP stops (Linux 3.5 to 4.7)"
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:1833
msgid ""
"The behavior of B<PTRACE_EVENT_SECCOMP> stops and their interaction with "
"other kinds of ptrace stops has changed between kernel versions.  This "
"documents the behavior from their introduction until Linux 4.7 (inclusive).  "
"The behavior in later kernel versions is documented in the next section."
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:1843
msgid ""
"A B<PTRACE_EVENT_SECCOMP> stop occurs whenever a B<SECCOMP_RET_TRACE> rule "
"is triggered.  This is independent of which methods was used to restart the "
"system call.  Notably, seccomp still runs even if the tracee was restarted "
"using B<PTRACE_SYSEMU> and this system call is unconditionally skipped."
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:1862
msgid ""
"Restarts from this stop will behave as if the stop had occurred right before "
"the system call in question.  In particular, both B<PTRACE_SYSCALL> and "
"B<PTRACE_SYSEMU> will normally cause a subsequent syscall-entry-stop.  "
"However, if after the B<PTRACE_EVENT_SECCOMP> the system call number is "
"negative, both the syscall-entry-stop and the system call itself will be "
"skipped.  This means that if the system call number is negative after a "
"B<PTRACE_EVENT_SECCOMP> and the tracee is restarted using B<PTRACE_SYSCALL>, "
"the next observed stop will be a syscall-exit-stop, rather than the "
"syscall-entry-stop that might have been expected."
msgstr ""

#. type: SS
#: man-pages/man2/ptrace.2:1862
#, no-wrap
msgid "PTRACE_EVENT_SECCOMP stops (since Linux 4.8)"
msgstr ""

#.  commit 93e35efb8de45393cf61ed07f7b407629bf698ea
#. type: Plain text
#: man-pages/man2/ptrace.2:1873
msgid ""
"Starting with Linux 4.8, the B<PTRACE_EVENT_SECCOMP> stop was reordered to "
"occur between syscall-entry-stop and syscall-exit-stop.  Note that seccomp "
"no longer runs (and no B<PTRACE_EVENT_SECCOMP> will be reported) if the "
"system call is skipped due to B<PTRACE_SYSEMU>."
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:1884
msgid ""
"Functionally, a B<PTRACE_EVENT_SECCOMP> stop functions comparably to a "
"syscall-entry-stop (i.e., continuations using B<PTRACE_SYSCALL> will cause "
"syscall-exit-stops, the system call number may be changed and any other "
"modified registers are visible to the to-be-executed system call as well).  "
"Note that there may be, but need not have been a preceding "
"syscall-entry-stop."
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:1895
msgid ""
"After a B<PTRACE_EVENT_SECCOMP> stop, seccomp will be rerun, with a "
"B<SECCOMP_RET_TRACE> rule now functioning the same as a "
"B<SECCOMP_RET_ALLOW>.  Specifically, this means that if registers are not "
"modified during the B<PTRACE_EVENT_SECCOMP> stop, the system call will then "
"be allowed."
msgstr ""

#. type: SS
#: man-pages/man2/ptrace.2:1895
#, no-wrap
msgid "PTRACE_SINGLESTEP stops"
msgstr ""

#
#.  FIXME .
#.  document stops occurring with PTRACE_SINGLESTEP
#. type: Plain text
#: man-pages/man2/ptrace.2:1901
msgid "[Details of these kinds of stops are yet to be documented.]"
msgstr ""

#. type: SS
#: man-pages/man2/ptrace.2:1901
#, no-wrap
msgid "Informational and restarting ptrace commands"
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:1911
msgid ""
"Most ptrace commands (all except B<PTRACE_ATTACH>, B<PTRACE_SEIZE>, "
"B<PTRACE_TRACEME>, B<PTRACE_INTERRUPT>, and B<PTRACE_KILL>)  require the "
"tracee to be in a ptrace-stop, otherwise they fail with B<ESRCH>."
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:1916
msgid ""
"When the tracee is in ptrace-stop, the tracer can read and write data to the "
"tracee using informational commands.  These commands leave the tracee in "
"ptrace-stopped state:"
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:1929
#, no-wrap
msgid ""
"ptrace(PTRACE_PEEKTEXT/PEEKDATA/PEEKUSER, pid, addr, 0);\n"
"ptrace(PTRACE_POKETEXT/POKEDATA/POKEUSER, pid, addr, long_val);\n"
"ptrace(PTRACE_GETREGS/GETFPREGS, pid, 0, &struct);\n"
"ptrace(PTRACE_SETREGS/SETFPREGS, pid, 0, &struct);\n"
"ptrace(PTRACE_GETREGSET, pid, NT_foo, &iov);\n"
"ptrace(PTRACE_SETREGSET, pid, NT_foo, &iov);\n"
"ptrace(PTRACE_GETSIGINFO, pid, 0, &siginfo);\n"
"ptrace(PTRACE_SETSIGINFO, pid, 0, &siginfo);\n"
"ptrace(PTRACE_GETEVENTMSG, pid, 0, &long_var);\n"
"ptrace(PTRACE_SETOPTIONS, pid, 0, PTRACE_O_flags);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:1942
msgid ""
"Note that some errors are not reported.  For example, setting signal "
"information (I<siginfo>)  may have no effect in some ptrace-stops, yet the "
"call may succeed (return 0 and not set I<errno>); querying "
"B<PTRACE_GETEVENTMSG> may succeed and return some random value if current "
"ptrace-stop is not documented as returning a meaningful event message."
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:1944
msgid "The call"
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:1946
#, no-wrap
msgid "    ptrace(PTRACE_SETOPTIONS, pid, 0, PTRACE_O_flags);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:1955
msgid ""
"affects one tracee.  The tracee's current flags are replaced.  Flags are "
"inherited by new tracees created and \"auto-attached\" via active "
"B<PTRACE_O_TRACEFORK>, B<PTRACE_O_TRACEVFORK>, or B<PTRACE_O_TRACECLONE> "
"options."
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:1958
msgid ""
"Another group of commands makes the ptrace-stopped tracee run.  They have "
"the form:"
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:1960
#, no-wrap
msgid "    ptrace(cmd, pid, 0, sig);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:1981
msgid ""
"where I<cmd> is B<PTRACE_CONT>, B<PTRACE_LISTEN>, B<PTRACE_DETACH>, "
"B<PTRACE_SYSCALL>, B<PTRACE_SINGLESTEP>, B<PTRACE_SYSEMU>, or "
"B<PTRACE_SYSEMU_SINGLESTEP>.  If the tracee is in signal-delivery-stop, "
"I<sig> is the signal to be injected (if it is nonzero).  Otherwise, I<sig> "
"may be ignored.  (When restarting a tracee from a ptrace-stop other than "
"signal-delivery-stop, recommended practice is to always pass 0 in I<sig>.)"
msgstr ""

#. type: SS
#: man-pages/man2/ptrace.2:1981
#, no-wrap
msgid "Attaching and detaching"
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:1983
msgid "A thread can be attached to the tracer using the call"
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:1985
#, no-wrap
msgid "    ptrace(PTRACE_ATTACH, pid, 0, 0);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:1987 man-pages/man2/ptrace.2:2841
msgid "or"
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:1989
#, no-wrap
msgid "    ptrace(PTRACE_SEIZE, pid, 0, PTRACE_O_flags);\n"
msgstr ""

#
#.  FIXME Describe how to attach to a thread which is already group-stopped.
#. type: Plain text
#: man-pages/man2/ptrace.2:2013
msgid ""
"B<PTRACE_ATTACH> sends B<SIGSTOP> to this thread.  If the tracer wants this "
"B<SIGSTOP> to have no effect, it needs to suppress it.  Note that if other "
"signals are concurrently sent to this thread during attach, the tracer may "
"see the tracee enter signal-delivery-stop with other signal(s) first! The "
"usual practice is to reinject these signals until B<SIGSTOP> is seen, then "
"suppress B<SIGSTOP> injection.  The design bug here is that a ptrace attach "
"and a concurrently delivered B<SIGSTOP> may race and the concurrent "
"B<SIGSTOP> may be lost."
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:2020
msgid ""
"Since attaching sends B<SIGSTOP> and the tracer usually suppresses it, this "
"may cause a stray B<EINTR> return from the currently executing system call "
"in the tracee, as described in the \"Signal injection and suppression\" "
"section."
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:2032
msgid ""
"Since Linux 3.4, B<PTRACE_SEIZE> can be used instead of B<PTRACE_ATTACH>.  "
"B<PTRACE_SEIZE> does not stop the attached process.  If you need to stop it "
"after attach (or at any other time) without sending it any signals, use "
"B<PTRACE_INTERRUPT> command."
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:2034
msgid "The request"
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:2036
#, no-wrap
msgid "    ptrace(PTRACE_TRACEME, 0, 0, 0);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:2042
msgid ""
"turns the calling thread into a tracee.  The thread continues to run "
"(doesn't enter ptrace-stop).  A common practice is to follow the "
"B<PTRACE_TRACEME> with"
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:2044
#, no-wrap
msgid "    raise(SIGSTOP);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:2047
msgid ""
"and allow the parent (which is our tracer now) to observe our "
"signal-delivery-stop."
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:2071
msgid ""
"If the B<PTRACE_O_TRACEFORK>, B<PTRACE_O_TRACEVFORK>, or "
"B<PTRACE_O_TRACECLONE> options are in effect, then children created by, "
"respectively, B<vfork>(2)  or B<clone>(2)  with the B<CLONE_VFORK> flag, "
"B<fork>(2)  or B<clone>(2)  with the exit signal set to B<SIGCHLD>, and "
"other kinds of B<clone>(2), are automatically attached to the same tracer "
"which traced their parent.  B<SIGSTOP> is delivered to the children, causing "
"them to enter signal-delivery-stop after they exit the system call which "
"created them."
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:2073
msgid "Detaching of the tracee is performed by:"
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:2075
#, no-wrap
msgid "    ptrace(PTRACE_DETACH, pid, 0, sig);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:2083
msgid ""
"B<PTRACE_DETACH> is a restarting operation; therefore it requires the tracee "
"to be in ptrace-stop.  If the tracee is in signal-delivery-stop, a signal "
"can be injected.  Otherwise, the I<sig> parameter may be silently ignored."
msgstr ""

#.  FIXME Describe how to detach from a group-stopped tracee so that it
#.  doesn't run, but continues to wait for SIGCONT.
#. type: Plain text
#: man-pages/man2/ptrace.2:2107
msgid ""
"If the tracee is running when the tracer wants to detach it, the usual "
"solution is to send B<SIGSTOP> (using B<tgkill>(2), to make sure it goes to "
"the correct thread), wait for the tracee to stop in signal-delivery-stop for "
"B<SIGSTOP> and then detach it (suppressing B<SIGSTOP> injection).  A design "
"bug is that this can race with concurrent B<SIGSTOP>s.  Another complication "
"is that the tracee may enter other ptrace-stops and needs to be restarted "
"and waited for again, until B<SIGSTOP> is seen.  Yet another complication is "
"to be sure that the tracee is not already ptrace-stopped, because no signal "
"delivery happens while it is\\(emnot even B<SIGSTOP>."
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:2115
msgid ""
"If the tracer dies, all tracees are automatically detached and restarted, "
"unless they were in group-stop.  Handling of restart from group-stop is "
"currently buggy, but the \"as planned\" behavior is to leave tracee stopped "
"and waiting for B<SIGCONT>.  If the tracee is restarted from "
"signal-delivery-stop, the pending signal is injected."
msgstr ""

#. type: SS
#: man-pages/man2/ptrace.2:2115
#, no-wrap
msgid "execve(2) under ptrace"
msgstr ""

#.  clone(2) CLONE_THREAD says:
#.      If  any  of the threads in a thread group performs an execve(2),
#.      then all threads other than the thread group leader are terminated,
#.      and the new program is executed in the thread group leader.
#
#.  In kernel 3.1 sources, see fs/exec.c::de_thread()
#. type: Plain text
#: man-pages/man2/ptrace.2:2134
msgid ""
"When one thread in a multithreaded process calls B<execve>(2), the kernel "
"destroys all other threads in the process, and resets the thread ID of the "
"execing thread to the thread group ID (process ID).  (Or, to put things "
"another way, when a multithreaded process does an B<execve>(2), at "
"completion of the call, it appears as though the B<execve>(2)  occurred in "
"the thread group leader, regardless of which thread did the B<execve>(2).)  "
"This resetting of the thread ID looks very confusing to tracers:"
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:2144
msgid ""
"All other threads stop in B<PTRACE_EVENT_EXIT> stop, if the "
"B<PTRACE_O_TRACEEXIT> option was turned on.  Then all other threads except "
"the thread group leader report death as if they exited via B<_exit>(2)  with "
"exit code 0."
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:2152
msgid ""
"The execing tracee changes its thread ID while it is in the B<execve>(2).  "
"(Remember, under ptrace, the \"pid\" returned from B<waitpid>(2), or fed "
"into ptrace calls, is the tracee's thread ID.)  That is, the tracee's thread "
"ID is reset to be the same as its process ID, which is the same as the "
"thread group leader's thread ID."
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:2158
msgid ""
"Then a B<PTRACE_EVENT_EXEC> stop happens, if the B<PTRACE_O_TRACEEXEC> "
"option was turned on."
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:2179
msgid ""
"If the thread group leader has reported its B<PTRACE_EVENT_EXIT> stop by "
"this time, it appears to the tracer that the dead thread leader \"reappears "
"from nowhere\".  (Note: the thread group leader does not report death via "
"I<WIFEXITED(status)> until there is at least one other live thread.  This "
"eliminates the possibility that the tracer will see it dying and then "
"reappearing.)  If the thread group leader was still alive, for the tracer "
"this may look as if thread group leader returns from a different system call "
"than it entered, or even \"returned from a system call even though it was "
"not in any system call\".  If the thread group leader was not traced (or was "
"traced by a different tracer), then during B<execve>(2)  it will appear as "
"if it has become a tracee of the tracer of the execing tracee."
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:2182
msgid ""
"All of the above effects are the artifacts of the thread ID change in the "
"tracee."
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:2202
msgid ""
"The B<PTRACE_O_TRACEEXEC> option is the recommended tool for dealing with "
"this situation.  First, it enables B<PTRACE_EVENT_EXEC> stop, which occurs "
"before B<execve>(2)  returns.  In this stop, the tracer can use "
"B<PTRACE_GETEVENTMSG> to retrieve the tracee's former thread ID.  (This "
"feature was introduced in Linux 3.0.)  Second, the B<PTRACE_O_TRACEEXEC> "
"option disables legacy B<SIGTRAP> generation on B<execve>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:2208
msgid ""
"When the tracer receives B<PTRACE_EVENT_EXEC> stop notification, it is "
"guaranteed that except this tracee and the thread group leader, no other "
"threads from the process are alive."
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:2216
msgid ""
"On receiving the B<PTRACE_EVENT_EXEC> stop notification, the tracer should "
"clean up all its internal data structures describing the threads of this "
"process, and retain only one data structure\\(emone which describes the "
"single still running tracee, with"
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:2218
#, no-wrap
msgid "    thread ID == thread group ID == process ID.\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:2222
msgid "Example: two threads call B<execve>(2)  at the same time:"
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:2233
#, no-wrap
msgid ""
"*** we get syscall-enter-stop in thread 1: **\n"
"PID1 execve(\"/bin/foo\", \"foo\" E<lt>unfinished ...E<gt>\n"
"*** we issue PTRACE_SYSCALL for thread 1 **\n"
"*** we get syscall-enter-stop in thread 2: **\n"
"PID2 execve(\"/bin/bar\", \"bar\" E<lt>unfinished ...E<gt>\n"
"*** we issue PTRACE_SYSCALL for thread 2 **\n"
"*** we get PTRACE_EVENT_EXEC for PID0, we issue PTRACE_SYSCALL **\n"
"*** we get syscall-exit-stop for PID0: **\n"
"PID0 E<lt>... execve resumedE<gt> )             = 0\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:2261
msgid ""
"If the B<PTRACE_O_TRACEEXEC> option is I<not> in effect for the execing "
"tracee, and if the tracee was B<PTRACE_ATTACH>ed rather that "
"B<PTRACE_SEIZE>d, the kernel delivers an extra B<SIGTRAP> to the tracee "
"after B<execve>(2)  returns.  This is an ordinary signal (similar to one "
"which can be generated by I<kill -TRAP>), not a special kind of "
"ptrace-stop.  Employing B<PTRACE_GETSIGINFO> for this signal returns "
"I<si_code> set to 0 (I<SI_USER>).  This signal may be blocked by signal "
"mask, and thus may be delivered (much) later."
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:2282
msgid ""
"Usually, the tracer (for example, B<strace>(1))  would not want to show this "
"extra post-execve B<SIGTRAP> signal to the user, and would suppress its "
"delivery to the tracee (if B<SIGTRAP> is set to B<SIG_DFL>, it is a killing "
"signal).  However, determining I<which> B<SIGTRAP> to suppress is not easy.  "
"Setting the B<PTRACE_O_TRACEEXEC> option or using B<PTRACE_SEIZE> and thus "
"suppressing this extra B<SIGTRAP> is the recommended approach."
msgstr ""

#. type: SS
#: man-pages/man2/ptrace.2:2282
#, no-wrap
msgid "Real parent"
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:2289
msgid ""
"The ptrace API (ab)uses the standard UNIX parent/child signaling over "
"B<waitpid>(2).  This used to cause the real parent of the process to stop "
"receiving several kinds of B<waitpid>(2)  notifications when the child "
"process is traced by some other process."
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:2292
msgid ""
"Many of these bugs have been fixed, but as of Linux 2.6.38 several still "
"exist; see BUGS below."
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:2294
msgid "As of Linux 2.6.38, the following is believed to work correctly:"
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:2302
msgid ""
"exit/death by signal is reported first to the tracer, then, when the tracer "
"consumes the B<waitpid>(2)  result, to the real parent (to the real parent "
"only when the whole multithreaded process exits).  If the tracer and the "
"real parent are the same process, the report is sent only once."
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:2310
msgid ""
"On success, the B<PTRACE_PEEK*> requests return the requested data (but see "
"NOTES), the B<PTRACE_SECCOMP_GET_FILTER> request returns the number of "
"instructions in the BPF program, and other requests return zero."
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:2320
msgid ""
"On error, all requests return -1, and I<errno> is set appropriately.  Since "
"the value returned by a successful B<PTRACE_PEEK*> request may be -1, the "
"caller must clear I<errno> before the call, and then check it afterward to "
"determine whether or not an error occurred."
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:2324
msgid "(i386 only) There was an error with allocating or freeing a debug register."
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:2335
msgid ""
"There was an attempt to read from or write to an invalid area in the "
"tracer's or the tracee's memory, probably because the area wasn't mapped or "
"accessible.  Unfortunately, under Linux, different variations of this fault "
"will return B<EIO> or B<EFAULT> more or less arbitrarily."
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:2338
msgid "An attempt was made to set an invalid option."
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:2345
msgid ""
"I<request> is invalid, or an attempt was made to read from or write to an "
"invalid area in the tracer's or the tracee's memory, or there was a "
"word-alignment violation, or an invalid signal was specified during a "
"restart request."
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:2358
msgid ""
"The specified process cannot be traced.  This could be because the tracer "
"has insufficient privileges (the required capability is B<CAP_SYS_PTRACE>); "
"unprivileged processes cannot trace processes that they cannot send signals "
"to or those running set-user-ID/set-group-ID programs, for obvious reasons.  "
"Alternatively, the process may already be being traced, or (on kernels "
"before 2.6.26) be B<init>(1)  (PID 1)."
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:2363
msgid ""
"The specified process does not exist, or is not currently being traced by "
"the caller, or is not stopped (for requests that require a stopped tracee)."
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:2365
msgid "SVr4, 4.3BSD."
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:2380
msgid ""
"Although arguments to B<ptrace>()  are interpreted according to the "
"prototype given, glibc currently declares B<ptrace>()  as a variadic "
"function with only the I<request> argument fixed.  It is recommended to "
"always supply four arguments, even if the requested operation does not use "
"them, setting unused/ignored arguments to I<0L> or I<(void\\ *)\\ 0>."
msgstr ""

#.  See commit 00cd5c37afd5f431ac186dd131705048c0a11fdb
#. type: Plain text
#: man-pages/man2/ptrace.2:2385
msgid ""
"In Linux kernels before 2.6.26, B<init>(1), the process with PID 1, may not "
"be traced."
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:2388
msgid ""
"A tracees parent continues to be the tracer even if that tracer calls "
"B<execve>(2)."
msgstr ""

#.  See http://lkml.org/lkml/2008/5/8/375
#. type: Plain text
#: man-pages/man2/ptrace.2:2395
msgid ""
"The layout of the contents of memory and the USER area are quite "
"operating-system- and architecture-specific.  The offset supplied, and the "
"data returned, might not entirely match with the definition of I<struct "
"user>."
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:2398
msgid ""
"The size of a \"word\" is determined by the operating-system variant (e.g., "
"for 32-bit Linux it is 32 bits)."
msgstr ""

#
#. """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
#. type: Plain text
#: man-pages/man2/ptrace.2:2409
msgid ""
"This page documents the way the B<ptrace>()  call works currently in Linux.  "
"Its behavior differs significantly on other flavors of UNIX.  In any case, "
"use of B<ptrace>()  is highly specific to the operating system and "
"architecture."
msgstr ""

#. type: SS
#: man-pages/man2/ptrace.2:2409
#, no-wrap
msgid "Ptrace access mode checking"
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:2424
msgid ""
"Various parts of the kernel-user-space API (not just B<ptrace>()  "
"operations), require so-called \"ptrace access mode\" checks, whose outcome "
"determines whether an operation is permitted (or, in a few cases, causes a "
"\"read\" operation to return sanitized data).  These checks are performed in "
"cases where one process can inspect sensitive information about, or in some "
"cases modify the state of, another process.  The checks are based on factors "
"such as the credentials and capabilities of the two processes, whether or "
"not the \"target\" process is dumpable, and the results of checks performed "
"by any enabled Linux Security Module (LSM)\\(emfor example, SELinux, Yama, "
"or Smack\\(emand by the commoncap LSM (which is always invoked)."
msgstr ""

#.  commit 006ebb40d3d65338bd74abb03b945f8d60e362bd
#. type: Plain text
#: man-pages/man2/ptrace.2:2429
msgid ""
"Prior to Linux 2.6.27, all access checks were of a single type.  Since Linux "
"2.6.27, two access mode levels are distinguished:"
msgstr ""

#. type: TP
#: man-pages/man2/ptrace.2:2429
#, no-wrap
msgid "B<PTRACE_MODE_READ>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:2445
msgid ""
"For \"read\" operations or other operations that are less dangerous, such "
"as: B<get_robust_list>(2); B<kcmp>(2); reading I</proc/[pid]/auxv>, "
"I</proc/[pid]/environ>, or I</proc/[pid]/stat>; or B<readlink>(2)  of a "
"I</proc/[pid]/ns/*> file."
msgstr ""

#. type: TP
#: man-pages/man2/ptrace.2:2445
#, no-wrap
msgid "B<PTRACE_MODE_ATTACH>"
msgstr ""

#
#.  Regarding the above description of the distinction between
#.  PTRACE_MODE_READ and PTRACE_MODE_ATTACH, Stephen Smalley notes:
#
#.      That was the intent when the distinction was introduced, but it doesn't
#.      appear to have been properly maintained, e.g. there is now a common
#.      helper lock_trace() that is used for
#.      /proc/pid/{stack,syscall,personality} but checks PTRACE_MODE_ATTACH, and
#.      PTRACE_MODE_ATTACH is also used in timerslack_ns_write/show().  Likely
#.      should review and make them consistent.  There was also some debate
#.      about proper handling of /proc/pid/fd.  Arguably that one might belong
#.      back in the _ATTACH camp.
#. type: Plain text
#: man-pages/man2/ptrace.2:2468
msgid ""
"For \"write\" operations, or other operations that are more dangerous, such "
"as: ptrace attaching (B<PTRACE_ATTACH>)  to another process or calling "
"B<process_vm_writev>(2).  (B<PTRACE_MODE_ATTACH> was effectively the default "
"before Linux 2.6.27.)"
msgstr ""

#.  commit caaee6234d05a58c5b4d05e7bf766131b810a657
#. type: Plain text
#: man-pages/man2/ptrace.2:2473
msgid ""
"Since Linux 4.5, the above access mode checks are combined (ORed) with one "
"of the following modifiers:"
msgstr ""

#. type: TP
#: man-pages/man2/ptrace.2:2473
#, no-wrap
msgid "B<PTRACE_MODE_FSCREDS>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:2478
msgid ""
"Use the caller's filesystem UID and GID (see B<credentials>(7))  or "
"effective capabilities for LSM checks."
msgstr ""

#. type: TP
#: man-pages/man2/ptrace.2:2478
#, no-wrap
msgid "B<PTRACE_MODE_REALCREDS>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:2482
msgid ""
"Use the caller's real UID and GID or permitted capabilities for LSM checks.  "
"This was effectively the default before Linux 4.5."
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:2486
msgid ""
"Because combining one of the credential modifiers with one of the "
"aforementioned access modes is typical, some macros are defined in the "
"kernel sources for the combinations:"
msgstr ""

#. type: TP
#: man-pages/man2/ptrace.2:2486
#, no-wrap
msgid "B<PTRACE_MODE_READ_FSCREDS>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:2490
msgid "Defined as B<PTRACE_MODE_READ | PTRACE_MODE_FSCREDS>."
msgstr ""

#. type: TP
#: man-pages/man2/ptrace.2:2490
#, no-wrap
msgid "B<PTRACE_MODE_READ_REALCREDS>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:2494
msgid "Defined as B<PTRACE_MODE_READ | PTRACE_MODE_REALCREDS>."
msgstr ""

#. type: TP
#: man-pages/man2/ptrace.2:2494
#, no-wrap
msgid "B<PTRACE_MODE_ATTACH_FSCREDS>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:2498
msgid "Defined as B<PTRACE_MODE_ATTACH | PTRACE_MODE_FSCREDS>."
msgstr ""

#. type: TP
#: man-pages/man2/ptrace.2:2498
#, no-wrap
msgid "B<PTRACE_MODE_ATTACH_REALCREDS>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:2502
msgid "Defined as B<PTRACE_MODE_ATTACH | PTRACE_MODE_REALCREDS>."
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:2504
msgid "One further modifier can be ORed with the access mode:"
msgstr ""

#. type: TP
#: man-pages/man2/ptrace.2:2504
#, no-wrap
msgid "B<PTRACE_MODE_NOAUDIT> (since Linux 3.3)"
msgstr ""

#.  commit 69f594a38967f4540ce7a29b3fd214e68a8330bd
#.  Just for /proc/pid/stat
#. type: Plain text
#: man-pages/man2/ptrace.2:2518
msgid ""
"Don't audit this access mode check.  This modifier is employed for ptrace "
"access mode checks (such as checks when reading I</proc/[pid]/stat>)  that "
"merely cause the output to be filtered or sanitized, rather than causing an "
"error to be returned to the caller.  In these cases, accessing the file is "
"not a security violation and there is no reason to generate a security audit "
"record.  This modifier suppresses the generation of such an audit record for "
"the particular access check."
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:2529
msgid ""
"Note that all of the B<PTRACE_MODE_*> constants described in this subsection "
"are kernel-internal, and not visible to user space.  The constant names are "
"mentioned here in order to label the various kinds of ptrace access mode "
"checks that are performed for various system calls and accesses to various "
"pseudofiles (e.g., under I</proc>).  These names are used in other manual "
"pages to provide a simple shorthand for labeling the different kernel "
"checks."
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:2538
msgid ""
"The algorithm employed for ptrace access mode checking determines whether "
"the calling process is allowed to perform the corresponding action on the "
"target process.  (In the case of opening I</proc/[pid]> files, the \"calling "
"process\" is the one opening the file, and the process with the "
"corresponding PID is the \"target process\".)  The algorithm is as follows:"
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:2541
msgid ""
"If the calling thread and the target thread are in the same thread group, "
"access is always allowed."
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:2550
msgid ""
"If the access mode specifies B<PTRACE_MODE_FSCREDS>, then, for the check in "
"the next step, employ the caller's filesystem UID and GID.  (As noted in "
"B<credentials>(7), the filesystem UID and GID almost always have the same "
"values as the corresponding effective IDs.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:2558
msgid ""
"Otherwise, the access mode specifies B<PTRACE_MODE_REALCREDS>, so use the "
"caller's real UID and GID for the checks in the next step.  (Most APIs that "
"check the caller's UID and GID use the effective IDs.  For historical "
"reasons, the B<PTRACE_MODE_REALCREDS> check uses the real IDs instead.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:2562 man-pages/man2/ptrace.2:2609
msgid "Deny access if I<neither> of the following is true:"
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:2569
msgid ""
"The real, effective, and saved-set user IDs of the target match the caller's "
"user ID, I<and> the real, effective, and saved-set group IDs of the target "
"match the caller's group ID."
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:2573
msgid ""
"The caller has the B<CAP_SYS_PTRACE> capability in the user namespace of the "
"target."
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:2584
msgid ""
"Deny access if the target process \"dumpable\" attribute has a value other "
"than 1 (B<SUID_DUMP_USER>; see the discussion of B<PR_SET_DUMPABLE> in "
"B<prctl>(2)), and the caller does not have the B<CAP_SYS_PTRACE> capability "
"in the user namespace of the target process."
msgstr ""

#.  (in cap_ptrace_access_check()):
#. type: Plain text
#: man-pages/man2/ptrace.2:2592
msgid ""
"The kernel LSM I<security_ptrace_access_check>()  interface is invoked to "
"see if ptrace access is permitted.  The results depend on the LSM(s).  The "
"implementation of this interface in the commoncap LSM performs the following "
"steps:"
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:2605
msgid ""
"If the access mode includes B<PTRACE_MODE_FSCREDS>, then use the caller's "
"I<effective> capability set in the following check; otherwise (the access "
"mode specifies B<PTRACE_MODE_REALCREDS>, so) use the caller's I<permitted> "
"capability set."
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:2615
msgid ""
"The caller and the target process are in the same user namespace, and the "
"caller's capabilities are a superset of the target process's I<permitted> "
"capabilities."
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:2619
msgid ""
"The caller has the B<CAP_SYS_PTRACE> capability in the target process's user "
"namespace."
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:2625
msgid ""
"Note that the commoncap LSM does not distinguish between B<PTRACE_MODE_READ> "
"and B<PTRACE_MODE_ATTACH>."
msgstr ""

#
#. """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
#. type: Plain text
#: man-pages/man2/ptrace.2:2632
msgid ""
"If access has not been denied by any of the preceding steps, then access is "
"allowed."
msgstr ""

#. type: SS
#: man-pages/man2/ptrace.2:2632
#, no-wrap
msgid "/proc/sys/kernel/yama/ptrace_scope"
msgstr ""

#.  commit 2d514487faf188938a4ee4fb3464eeecfbdcf8eb
#. type: Plain text
#: man-pages/man2/ptrace.2:2651
msgid ""
"On systems with the Yama Linux Security Module (LSM) installed (i.e., the "
"kernel was configured with B<CONFIG_SECURITY_YAMA>), the "
"I</proc/sys/kernel/yama/ptrace_scope> file (available since Linux 3.4)  can "
"be used to restrict the ability to trace a process with B<ptrace>()  (and "
"thus also the ability to use tools such as B<strace>(1)  and B<gdb>(1)).  "
"The goal of such restrictions is to prevent attack escalation whereby a "
"compromised process can ptrace-attach to other sensitive processes (e.g., a "
"GPG agent or an SSH session) owned by the user in order to gain additional "
"credentials that may exist in memory and thus expand the scope of the "
"attack."
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:2653
msgid "More precisely, the Yama LSM limits two types of operations:"
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:2660
msgid ""
"Any operation that performs a ptrace access mode B<PTRACE_MODE_ATTACH> "
"check\\(emfor example, B<ptrace>()  B<PTRACE_ATTACH>.  (See the \"Ptrace "
"access mode checking\" discussion above.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:2664
msgid "B<ptrace>()  B<PTRACE_TRACEME>."
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:2670
msgid ""
"A process that has the B<CAP_SYS_PTRACE> capability can update the "
"I</proc/sys/kernel/yama/ptrace_scope> file with one of the following values:"
msgstr ""

#. type: TP
#: man-pages/man2/ptrace.2:2670
#, no-wrap
msgid "0 (\"classic ptrace permissions\")"
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:2675
msgid ""
"No additional restrictions on operations that perform B<PTRACE_MODE_ATTACH> "
"checks (beyond those imposed by the commoncap and other LSMs)."
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:2679 man-pages/man2/ptrace.2:2708
msgid "The use of B<PTRACE_TRACEME> is unchanged."
msgstr ""

#. type: TP
#: man-pages/man2/ptrace.2:2679
#, no-wrap
msgid "1 (\"restricted ptrace\") [default value]"
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:2690
msgid ""
"When performing an operation that requires a B<PTRACE_MODE_ATTACH> check, "
"the calling process must either have the B<CAP_SYS_PTRACE> capability in the "
"user namespace of the target process or it must have a predefined "
"relationship with the target process.  By default, the predefined "
"relationship is that the target process must be a descendant of the caller."
msgstr ""

#.  commit 90bb766440f2147486a2acc3e793d7b8348b0c22
#. type: Plain text
#: man-pages/man2/ptrace.2:2704
msgid ""
"A target process can employ the B<prctl>(2)  B<PR_SET_PTRACER> operation to "
"declare an additional PID that is allowed to perform B<PTRACE_MODE_ATTACH> "
"operations on the target.  See the kernel source file "
"I<Documentation/admin-guide/LSM/Yama.rst> (or "
"I<Documentation/security/Yama.txt> before Linux 4.13)  for further details."
msgstr ""

#. type: TP
#: man-pages/man2/ptrace.2:2708
#, no-wrap
msgid "2 (\"admin-only attach\")"
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:2716
msgid ""
"Only processes with the B<CAP_SYS_PTRACE> capability in the user namespace "
"of the target process may perform B<PTRACE_MODE_ATTACH> operations or trace "
"children that employ B<PTRACE_TRACEME>."
msgstr ""

#. type: TP
#: man-pages/man2/ptrace.2:2716
#, no-wrap
msgid "3 (\"no attach\")"
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:2722
msgid ""
"No process may perform B<PTRACE_MODE_ATTACH> operations or trace children "
"that employ B<PTRACE_TRACEME>."
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:2724
msgid "Once this value has been written to the file, it cannot be changed."
msgstr ""

#
#. """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
#. type: Plain text
#: man-pages/man2/ptrace.2:2739
msgid ""
"With respect to values 1 and 2, note that creating a new user namespace "
"effectively removes the protection offered by Yama.  This is because a "
"process in the parent user namespace whose effective UID matches the UID of "
"the creator of a child namespace has all capabilities (including "
"B<CAP_SYS_PTRACE>)  when performing operations within the child user "
"namespace (and further-removed descendants of that namespace).  "
"Consequently, when a process tries to use user namespaces to sandbox itself, "
"it inadvertently weakens the protections offered by the Yama LSM."
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:2751
msgid ""
"At the system call level, the B<PTRACE_PEEKTEXT>, B<PTRACE_PEEKDATA>, and "
"B<PTRACE_PEEKUSER> requests have a different API: they store the result at "
"the address specified by the I<data> parameter, and the return value is the "
"error flag.  The glibc wrapper function provides the API given in "
"DESCRIPTION above, with the result being returned via the function return "
"value."
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:2762
msgid ""
"On hosts with 2.6 kernel headers, B<PTRACE_SETOPTIONS> is declared with a "
"different value than the one for 2.4.  This leads to applications compiled "
"with 2.6 kernel headers failing when run on 2.4 kernels.  This can be worked "
"around by redefining B<PTRACE_SETOPTIONS> to B<PTRACE_OLDSETOPTIONS>, if "
"that is defined."
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:2765
msgid ""
"Group-stop notifications are sent to the tracer, but not to real parent.  "
"Last confirmed on 2.6.38.6."
msgstr ""

#.  Note from Denys Vlasenko:
#.      Here "exits" means any kind of death - _exit, exit_group,
#.      signal death. Signal death and exit_group cases are trivial,
#.      though: since signal death and exit_group kill all other threads
#.      too, "until all other threads exit" thing happens rather soon
#.      in these cases. Therefore, only _exit presents observably
#.      puzzling behavior to ptrace users: thread leader _exit's,
#.      but WIFEXITED isn't reported! We are trying to explain here
#.      why it is so.
#.   FIXME . need to test/verify this scenario
#. type: Plain text
#: man-pages/man2/ptrace.2:2796
msgid ""
"If a thread group leader is traced and exits by calling B<_exit>(2), a "
"B<PTRACE_EVENT_EXIT> stop will happen for it (if requested), but the "
"subsequent B<WIFEXITED> notification will not be delivered until all other "
"threads exit.  As explained above, if one of other threads calls "
"B<execve>(2), the death of the thread group leader will I<never> be "
"reported.  If the execed thread is not traced by this tracer, the tracer "
"will never know that B<execve>(2)  happened.  One possible workaround is to "
"B<PTRACE_DETACH> the thread group leader instead of restarting it in this "
"case.  Last confirmed on 2.6.38.6."
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:2806
msgid ""
"A B<SIGKILL> signal may still cause a B<PTRACE_EVENT_EXIT> stop before "
"actual signal death.  This may be changed in the future; B<SIGKILL> is meant "
"to always immediately kill tasks even under ptrace.  Last confirmed on Linux "
"3.13."
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:2824
msgid ""
"Some system calls return with B<EINTR> if a signal was sent to a tracee, but "
"delivery was suppressed by the tracer.  (This is very typical operation: it "
"is usually done by debuggers on every attach, in order to not introduce a "
"bogus B<SIGSTOP>).  As of Linux 3.2.9, the following system calls are "
"affected (this list is likely incomplete): B<epoll_wait>(2), and B<read>(2)  "
"from an B<inotify>(7)  file descriptor.  The usual symptom of this bug is "
"that when you attach to a quiescent process with the command"
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:2828
#, no-wrap
msgid "strace -p E<lt>process-IDE<gt>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:2833
msgid "then, instead of the usual and expected one-line output such as"
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:2837
#, no-wrap
msgid "restart_syscall(E<lt>... resuming interrupted call ...E<gt>_\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:2845
#, no-wrap
msgid "select(6, [5], NULL, [5], NULL_\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:2850
msgid ""
"('_' denotes the cursor position), you observe more than one line.  For "
"example:"
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:2855
#, no-wrap
msgid ""
"    clock_gettime(CLOCK_MONOTONIC, {15370, 690928118}) = 0\n"
"    epoll_wait(4,_\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:2877
msgid ""
"What is not visible here is that the process was blocked in B<epoll_wait>(2)  "
"before B<strace>(1)  has attached to it.  Attaching caused B<epoll_wait>(2)  "
"to return to user space with the error B<EINTR>.  In this particular case, "
"the program reacted to B<EINTR> by checking the current time, and then "
"executing B<epoll_wait>(2)  again.  (Programs which do not expect such "
"\"stray\" B<EINTR> errors may behave in an unintended way upon an "
"B<strace>(1)  attach.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:2883
msgid ""
"Contrary to the normal rules, the glibc wrapper for B<ptrace>()  can set "
"I<errno> to zero."
msgstr ""

#. type: Plain text
#: man-pages/man2/ptrace.2:2899
msgid ""
"B<gdb>(1), B<ltrace>(1), B<strace>(1), B<clone>(2), B<execve>(2), "
"B<fork>(2), B<gettid>(2), B<prctl>(2), B<seccomp>(2), B<sigaction>(2), "
"B<tgkill>(2), B<vfork>(2), B<waitpid>(2), B<exec>(3), B<capabilities>(7), "
"B<signal>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/inotify_init.2:29
#, no-wrap
msgid "INOTIFY_INIT"
msgstr ""

#. type: Plain text
#: man-pages/man2/inotify_init.2:32
msgid "inotify_init, inotify_init1 - initialize an inotify instance"
msgstr ""

#. type: Plain text
#: man-pages/man2/inotify_init.2:35
#, no-wrap
msgid "B<#include E<lt>sys/inotify.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/inotify_init.2:38
#, no-wrap
msgid ""
"B<int inotify_init(void);>\n"
"B<int inotify_init1(int >I<flags>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/inotify_init.2:42
msgid "For an overview of the inotify API, see B<inotify>(7)."
msgstr ""

#. type: Plain text
#: man-pages/man2/inotify_init.2:46
msgid ""
"B<inotify_init>()  initializes a new inotify instance and returns a file "
"descriptor associated with a new inotify event queue."
msgstr ""

#. type: Plain text
#: man-pages/man2/inotify_init.2:56
msgid ""
"If I<flags> is 0, then B<inotify_init1>()  is the same as "
"B<inotify_init>().  The following values can be bitwise ORed in I<flags> to "
"obtain different behavior:"
msgstr ""

#. type: TP
#: man-pages/man2/inotify_init.2:56
#, no-wrap
msgid "B<IN_NONBLOCK>"
msgstr ""

#. type: TP
#: man-pages/man2/inotify_init.2:66
#, no-wrap
msgid "B<IN_CLOEXEC>"
msgstr ""

#. type: Plain text
#: man-pages/man2/inotify_init.2:81
msgid ""
"On success, these system calls return a new file descriptor.  On error, -1 "
"is returned, and I<errno> is set to indicate the error."
msgstr ""

#. type: Plain text
#: man-pages/man2/inotify_init.2:87
msgid "(B<inotify_init1>())  An invalid value was specified in I<flags>."
msgstr ""

#. type: Plain text
#: man-pages/man2/inotify_init.2:90
msgid "The user limit on the total number of inotify instances has been reached."
msgstr ""

#. type: Plain text
#: man-pages/man2/inotify_init.2:99
msgid "Insufficient kernel memory is available."
msgstr ""

#. type: Plain text
#: man-pages/man2/inotify_init.2:106
msgid ""
"B<inotify_init>()  first appeared in Linux 2.6.13; library support was added "
"to glibc in version 2.4.  B<inotify_init1>()  was added in Linux 2.6.27; "
"library support was added to glibc in version 2.9."
msgstr ""

#. type: Plain text
#: man-pages/man2/inotify_init.2:111
msgid "B<inotify_add_watch>(2), B<inotify_rm_watch>(2), B<inotify>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/vhangup.2:28
#, no-wrap
msgid "VHANGUP"
msgstr ""

#. type: Plain text
#: man-pages/man2/vhangup.2:31
msgid "vhangup - virtually hangup the current terminal"
msgstr ""

#. type: Plain text
#: man-pages/man2/vhangup.2:35
msgid "B<int vhangup(void);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/vhangup.2:43
msgid "B<vhangup>():"
msgstr ""

#. type: Plain text
#: man-pages/man2/vhangup.2:58
msgid ""
"B<vhangup>()  simulates a hangup on the current terminal.  This call "
"arranges for other users to have a ``clean'' terminal at login time."
msgstr ""

#. type: Plain text
#: man-pages/man2/vhangup.2:71
msgid ""
"The calling process has insufficient privilege to call B<vhangup>(); the "
"B<CAP_SYS_TTY_CONFIG> capability is required."
msgstr ""

#. type: Plain text
#: man-pages/man2/vhangup.2:76
msgid "B<init>(1), B<capabilities>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/getpriority.2:45
#, no-wrap
msgid "GETPRIORITY"
msgstr ""

#. type: Plain text
#: man-pages/man2/getpriority.2:48
msgid "getpriority, setpriority - get/set program scheduling priority"
msgstr ""

#. type: Plain text
#: man-pages/man2/getpriority.2:54
msgid "B<int getpriority(int >I<which>B<, id_t >I<who>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/getpriority.2:56
msgid "B<int setpriority(int >I<which>B<, id_t >I<who>B<, int >I<prio>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/getpriority.2:70
msgid ""
"The scheduling priority of the process, process group, or user, as indicated "
"by I<which> and I<who> is obtained with the B<getpriority>()  call and set "
"with the B<setpriority>()  call.  The process attribute dealt with by these "
"system calls is the same attribute (also known as the \"nice\" value) that "
"is dealt with by B<nice>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/getpriority.2:93
msgid ""
"The value I<which> is one of B<PRIO_PROCESS>, B<PRIO_PGRP>, or B<PRIO_USER>, "
"and I<who> is interpreted relative to I<which> (a process identifier for "
"B<PRIO_PROCESS>, process group identifier for B<PRIO_PGRP>, and a user ID "
"for B<PRIO_USER>).  A zero value for I<who> denotes (respectively) the "
"calling process, the process group of the calling process, or the real user "
"ID of the calling process."
msgstr ""

#. type: Plain text
#: man-pages/man2/getpriority.2:102
msgid ""
"The I<prio> argument is a value in the range -20 to 19 (but see NOTES "
"below).  with -20 being the highest priority and 19 being the lowest "
"priority.  Attempts to set a priority outside this range are silently "
"clamped to the range.  The default priority is 0; lower values give a "
"process a higher scheduling priority."
msgstr ""

#. type: Plain text
#: man-pages/man2/getpriority.2:111
msgid ""
"The B<getpriority>()  call returns the highest priority (lowest numerical "
"value)  enjoyed by any of the specified processes.  The B<setpriority>()  "
"call sets the priorities of all of the specified processes to the specified "
"value."
msgstr ""

#. type: Plain text
#: man-pages/man2/getpriority.2:135
msgid ""
"On success, B<getpriority>()  returns the calling thread's nice value, which "
"may be a negative number.  On error, it returns -1 and sets I<errno> to "
"indicate the cause of the error.  Since a successful call to "
"B<getpriority>()  can legitimately return the value -1, it is necessary to "
"clear the external variable I<errno> prior to the call, then check it "
"afterward to determine if -1 is an error or a legitimate value."
msgstr ""

#. type: Plain text
#: man-pages/man2/getpriority.2:141
msgid ""
"B<setpriority>()  returns 0 on success.  On error, it returns -1 and sets "
"I<errno> to indicate the cause of the error."
msgstr ""

#. type: Plain text
#: man-pages/man2/getpriority.2:150
msgid "I<which> was not one of B<PRIO_PROCESS>, B<PRIO_PGRP>, or B<PRIO_USER>."
msgstr ""

#. type: Plain text
#: man-pages/man2/getpriority.2:157
msgid "No process was located using the I<which> and I<who> values specified."
msgstr ""

#. type: Plain text
#: man-pages/man2/getpriority.2:161
msgid "In addition to the errors indicated above, B<setpriority>()  may fail if:"
msgstr ""

#. type: Plain text
#: man-pages/man2/getpriority.2:168
msgid ""
"The caller attempted to set a lower nice value (i.e., a higher process "
"priority), but did not have the required privilege (on Linux: did not have "
"the B<CAP_SYS_NICE> capability)."
msgstr ""

#. type: Plain text
#: man-pages/man2/getpriority.2:176
msgid ""
"A process was located, but its effective user ID did not match either the "
"effective or the real user ID of the caller, and was not privileged (on "
"Linux: did not have the B<CAP_SYS_NICE> capability).  But see NOTES below."
msgstr ""

#. type: Plain text
#: man-pages/man2/getpriority.2:179
msgid ""
"POSIX.1-2001, POSIX.1-2008, SVr4, 4.4BSD (these interfaces first appeared in "
"4.2BSD)."
msgstr ""

#. type: Plain text
#: man-pages/man2/getpriority.2:194
msgid ""
"A child created by B<fork>(2)  inherits its parent's nice value.  The nice "
"value is preserved across B<execve>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/getpriority.2:209
msgid ""
"The details on the condition for B<EPERM> depend on the system.  The above "
"description is what POSIX.1-2001 says, and seems to be followed on all "
"System\\ V-like systems.  Linux kernels before 2.6.12 required the real or "
"effective user ID of the caller to match the real user of the process I<who> "
"(instead of its effective user ID).  Linux 2.6.12 and later require the "
"effective user ID of the caller to match the real or effective user ID of "
"the process I<who>.  All BSD-like systems (SunOS 4.1.3, Ultrix 4.2, 4.3BSD, "
"FreeBSD 4.3, OpenBSD-2.5, ...) behave in the same manner as Linux 2.6.12 and "
"later."
msgstr ""

#. type: Plain text
#: man-pages/man2/getpriority.2:222 man-pages/man2/wait4.2:169
msgid ""
"Including I<E<lt>sys/time.hE<gt>> is not required these days, but increases "
"portability.  (Indeed, I<E<lt>sys/resource.hE<gt>> defines the I<rusage> "
"structure with fields of type I<struct timeval> defined in "
"I<E<lt>sys/time.hE<gt>>.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/getpriority.2:237
msgid ""
"Within the kernel, nice values are actually represented using the range "
"40..1 (since negative numbers are error codes) and these are the values "
"employed by the B<setpriority>()  and B<getpriority>()  system calls.  The "
"glibc wrapper functions for these system calls handle the translations "
"between the user-land and kernel representations of the nice value according "
"to the formula I<unice\\ =\\ 20\\ -\\ knice>.  (Thus, the kernel's 40..1 "
"range corresponds to the range -20..19 as seen by user space.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/getpriority.2:244
msgid ""
"According to POSIX, the nice value is a per-process setting.  However, under "
"the current Linux/NPTL implementation of POSIX threads, the nice value is a "
"per-thread attribute: different threads in the same process can have "
"different nice values.  Portable applications should avoid relying on the "
"Linux behavior, which may be made standards conformant in the future."
msgstr ""

#. type: Plain text
#: man-pages/man2/getpriority.2:250
msgid "B<nice>(1), B<renice>(1), B<fork>(2), B<capabilities>(7), B<sched>(7)"
msgstr ""

#. type: Plain text
#: man-pages/man2/getpriority.2:252
msgid ""
"I<Documentation/scheduler/sched-nice-design.txt> in the Linux kernel source "
"tree (since Linux 2.6.23)"
msgstr ""

#. type: TH
#: man-pages/man2/sysctl.2:30
#, no-wrap
msgid "SYSCTL"
msgstr ""

#. type: Plain text
#: man-pages/man2/sysctl.2:33
msgid "sysctl - read/write system parameters"
msgstr ""

#. type: Plain text
#: man-pages/man2/sysctl.2:37
#, no-wrap
msgid ""
"B<#include E<lt>unistd.hE<gt>>\n"
"B<#include E<lt>linux/sysctl.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/sysctl.2:39
#, no-wrap
msgid "B<int _sysctl(struct __sysctl_args *>I<args>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/sysctl.2:46
msgid "B<Do not use this system call!> See NOTES."
msgstr ""

#. type: Plain text
#: man-pages/man2/sysctl.2:53
msgid ""
"The B<_sysctl>()  call reads and/or writes kernel parameters.  For example, "
"the hostname, or the maximum number of open files.  The argument has the "
"form"
msgstr ""

#. type: Plain text
#: man-pages/man2/sysctl.2:65
#, no-wrap
msgid ""
"struct __sysctl_args {\n"
"    int    *name;    /* integer vector describing variable */\n"
"    int     nlen;    /* length of this vector */\n"
"    void   *oldval;  /* 0 or address where to store old value */\n"
"    size_t *oldlenp; /* available room for old value,\n"
"                        overwritten by actual size of old value */\n"
"    void   *newval;  /* 0 or address of new value */\n"
"    size_t  newlen;  /* size of new value */\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/sysctl.2:73
msgid ""
"This call does a search in a tree structure, possibly resembling a directory "
"tree under I</proc/sys>, and if the requested item is found calls some "
"appropriate routine to read or modify the value."
msgstr ""

#. type: Plain text
#: man-pages/man2/sysctl.2:80
msgid ""
"Upon successful completion, B<_sysctl>()  returns 0.  Otherwise, a value of "
"-1 is returned and I<errno> is set to indicate the error."
msgstr ""

#. type: Plain text
#: man-pages/man2/sysctl.2:89
msgid ""
"No search permission for one of the encountered \"directories\", or no read "
"permission where I<oldval> was nonzero, or no write permission where "
"I<newval> was nonzero."
msgstr ""

#. type: Plain text
#: man-pages/man2/sysctl.2:95
msgid ""
"The invocation asked for the previous value by setting I<oldval> non-NULL, "
"but allowed zero room in I<oldlenp>."
msgstr ""

#. type: Plain text
#: man-pages/man2/sysctl.2:99
msgid "I<name> was not found."
msgstr ""

#. type: Plain text
#: man-pages/man2/sysctl.2:113
msgid ""
"This call is Linux-specific, and should not be used in programs intended to "
"be portable.  A B<sysctl>()  call has been present in Linux since version "
"1.3.57.  It originated in 4.4BSD.  Only Linux has the I</proc/sys> mirror, "
"and the object naming schemes differ between Linux and 4.4BSD, but the "
"declaration of the B<sysctl>()  function is the same in both."
msgstr ""

#.  See http://lwn.net/Articles/247243/
#.  Though comments in suggest that it is needed by old glibc binaries,
#.  so maybe it's not going away.
#. type: Plain text
#: man-pages/man2/sysctl.2:130
msgid ""
"Glibc does not provide a wrapper for this system call; call it using "
"B<syscall>(2).  Or rather...  I<don't> call it: use of this system call has "
"long been discouraged, and it is so unloved that B<it is likely to disappear "
"in a future kernel version>.  Since Linux 2.6.24, uses of this system call "
"result in warnings in the kernel log.  Remove it from your programs now; use "
"the I</proc/sys> interface instead."
msgstr ""

#. type: Plain text
#: man-pages/man2/sysctl.2:134
msgid ""
"This system call is available only if the kernel was configured with the "
"B<CONFIG_SYSCTL_SYSCALL> option."
msgstr ""

#. type: Plain text
#: man-pages/man2/sysctl.2:137
msgid ""
"The object names vary between kernel versions, making this system call "
"worthless for applications."
msgstr ""

#. type: Plain text
#: man-pages/man2/sysctl.2:139
msgid "Not all available objects are properly documented."
msgstr ""

#. type: Plain text
#: man-pages/man2/sysctl.2:142
msgid ""
"It is not yet possible to change operating system by writing to "
"I</proc/sys/kernel/ostype>."
msgstr ""

#. type: Plain text
#: man-pages/man2/sysctl.2:151
#, no-wrap
msgid ""
"#define _GNU_SOURCE\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>sys/syscall.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>linux/sysctl.hE<gt>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/sysctl.2:153
#, no-wrap
msgid "int _sysctl(struct __sysctl_args *args );\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/sysctl.2:155
#, no-wrap
msgid "#define OSNAMESZ 100\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/sysctl.2:163
#, no-wrap
msgid ""
"int\n"
"main(void)\n"
"{\n"
"    struct __sysctl_args args;\n"
"    char osname[OSNAMESZ];\n"
"    size_t osnamelth;\n"
"    int name[] = { CTL_KERN, KERN_OSTYPE };\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/sysctl.2:169
#, no-wrap
msgid ""
"    memset(&args, 0, sizeof(struct __sysctl_args));\n"
"    args.name = name;\n"
"    args.nlen = sizeof(name)/sizeof(name[0]);\n"
"    args.oldval = osname;\n"
"    args.oldlenp = &osnamelth;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/sysctl.2:171
#, no-wrap
msgid "    osnamelth = sizeof(osname);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/sysctl.2:179
#, no-wrap
msgid ""
"    if (syscall(SYS__sysctl, &args) == -1) {\n"
"        perror(\"_sysctl\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
"    printf(\"This machine is running %*s\\en\", osnamelth, osname);\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""

#. type: TH
#: man-pages/man2/mkdir.2:11
#, no-wrap
msgid "MKDIR"
msgstr ""

#. type: Plain text
#: man-pages/man2/mkdir.2:14
msgid "mkdir, mkdirat - create a directory"
msgstr ""

#.  .B #include <unistd.h>
#. type: Plain text
#: man-pages/man2/mkdir.2:19
#, no-wrap
msgid ""
"B<#include E<lt>sys/stat.hE<gt>>\n"
"B<#include E<lt>sys/types.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/mkdir.2:21
#, no-wrap
msgid "B<int mkdir(const char *>I<pathname>B<, mode_t >I<mode>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/mkdir.2:26
#, no-wrap
msgid ""
"B<int mkdirat(int >I<dirfd>B<, const char *>I<pathname>B<, mode_t "
">I<mode>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/mkdir.2:34
msgid "B<mkdirat>():"
msgstr ""

#. type: Plain text
#: man-pages/man2/mkdir.2:50
msgid "B<mkdir>()  attempts to create a directory named I<pathname>."
msgstr ""

#. type: Plain text
#: man-pages/man2/mkdir.2:64
msgid ""
"The argument I<mode> specifies the mode for the new directory (see "
"B<inode>(7)).  It is modified by the process's I<umask> in the usual way: in "
"the absence of a default ACL, the mode of the created directory is (I<mode> "
"& ~I<umask> & 0777).  Whether other I<mode> bits are honored for the created "
"directory depends on the operating system.  For Linux, see NOTES below."
msgstr ""

#. type: Plain text
#: man-pages/man2/mkdir.2:74
msgid ""
"The newly created directory will be owned by the effective user ID of the "
"process.  If the directory containing the file has the set-group-ID bit set, "
"or if the filesystem is mounted with BSD group semantics (I<mount -o "
"bsdgroups> or, synonymously I<mount -o grpid>), the new directory will "
"inherit the group ownership from its parent; otherwise it will be owned by "
"the effective group ID of the process."
msgstr ""

#. type: Plain text
#: man-pages/man2/mkdir.2:79
msgid ""
"If the parent directory has the set-group-ID bit set, then so will the newly "
"created directory."
msgstr ""

#. type: SS
#: man-pages/man2/mkdir.2:79
#, no-wrap
msgid "mkdirat()"
msgstr ""

#. type: Plain text
#: man-pages/man2/mkdir.2:85
msgid ""
"The B<mkdirat>()  system call operates in exactly the same way as "
"B<mkdir>(), except for the differences described here."
msgstr ""

#. type: Plain text
#: man-pages/man2/mkdir.2:95
msgid ""
"If the pathname given in I<pathname> is relative, then it is interpreted "
"relative to the directory referred to by the file descriptor I<dirfd> "
"(rather than relative to the current working directory of the calling "
"process, as is done by B<mkdir>()  for a relative pathname)."
msgstr ""

#. type: Plain text
#: man-pages/man2/mkdir.2:107
msgid ""
"If I<pathname> is relative and I<dirfd> is the special value B<AT_FDCWD>, "
"then I<pathname> is interpreted relative to the current working directory of "
"the calling process (like B<mkdir>())."
msgstr ""

#. type: Plain text
#: man-pages/man2/mkdir.2:118
msgid "See B<openat>(2)  for an explanation of the need for B<mkdirat>()."
msgstr ""

#. type: Plain text
#: man-pages/man2/mkdir.2:125
msgid ""
"B<mkdir>()  and B<mkdirat>()  return zero on success, or -1 if an error "
"occurred (in which case, I<errno> is set appropriately)."
msgstr ""

#. type: Plain text
#: man-pages/man2/mkdir.2:134
msgid ""
"The parent directory does not allow write permission to the process, or one "
"of the directories in I<pathname> did not allow search permission.  (See "
"also B<path_resolution>(7).)"
msgstr ""

#. type: Plain text
#: man-pages/man2/mkdir.2:145
msgid ""
"I<pathname> already exists (not necessarily as a directory).  This includes "
"the case where I<pathname> is a symbolic link, dangling or not."
msgstr ""

#. type: Plain text
#: man-pages/man2/mkdir.2:154
msgid ""
"The final component (\"basename\") of the new directory's I<pathname> is "
"invalid (e.g., it contains characters not permitted by the underlying "
"filesystem)."
msgstr ""

#. type: Plain text
#: man-pages/man2/mkdir.2:162
msgid "The number of links to the parent directory would exceed B<LINK_MAX>."
msgstr ""

#. type: Plain text
#: man-pages/man2/mkdir.2:178
msgid "The device containing I<pathname> has no room for the new directory."
msgstr ""

#. type: Plain text
#: man-pages/man2/mkdir.2:182
msgid ""
"The new directory cannot be created because the user's disk quota is "
"exhausted."
msgstr ""

#. type: Plain text
#: man-pages/man2/mkdir.2:192
msgid ""
"The filesystem containing I<pathname> does not support the creation of "
"directories."
msgstr ""

#. type: Plain text
#: man-pages/man2/mkdir.2:199
msgid "The following additional errors can occur for B<mkdirat>():"
msgstr ""

#. type: Plain text
#: man-pages/man2/mkdir.2:213
msgid ""
"B<mkdirat>()  was added to Linux in kernel 2.6.16; library support was added "
"to glibc in version 2.4."
msgstr ""

#.  SVr4 documents additional EIO, EMULTIHOP
#. type: Plain text
#: man-pages/man2/mkdir.2:217
msgid "B<mkdir>(): SVr4, BSD, POSIX.1-2001, POSIX.1-2008."
msgstr ""

#. type: Plain text
#: man-pages/man2/mkdir.2:220
msgid "B<mkdirat>(): POSIX.1-2008."
msgstr ""

#. type: Plain text
#: man-pages/man2/mkdir.2:225
msgid ""
"Under Linux, apart from the permission bits, the B<S_ISVTX> I<mode> bit is "
"also honored."
msgstr ""

#. type: Plain text
#: man-pages/man2/mkdir.2:229
msgid ""
"There are many infelicities in the protocol underlying NFS.  Some of these "
"affect B<mkdir>()."
msgstr ""

#. type: Plain text
#: man-pages/man2/mkdir.2:242
msgid ""
"On older kernels where B<mkdirat>()  is unavailable, the glibc wrapper "
"function falls back to the use of B<mkdir>().  When I<pathname> is a "
"relative pathname, glibc constructs a pathname based on the symbolic link in "
"I</proc/self/fd> that corresponds to the I<dirfd> argument."
msgstr ""

#. type: Plain text
#: man-pages/man2/mkdir.2:253
msgid ""
"B<mkdir>(1), B<chmod>(2), B<chown>(2), B<mknod>(2), B<mount>(2), "
"B<rmdir>(2), B<stat>(2), B<umask>(2), B<unlink>(2), B<acl>(5)  "
"B<path_resolution>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/getsid.2:27
#, no-wrap
msgid "GETSID"
msgstr ""

#. type: Plain text
#: man-pages/man2/getsid.2:30
msgid "getsid - get session ID"
msgstr ""

#. type: Plain text
#: man-pages/man2/getsid.2:36
msgid "B<pid_t getsid(pid_t>I< pid>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/getsid.2:45
msgid "B<getsid>():"
msgstr ""

#. type: Plain text
#: man-pages/man2/getsid.2:50 man-pages/man2/setpgid.2:82
#, no-wrap
msgid "    || /* Since glibc 2.12: */ _POSIX_C_SOURCE\\ E<gt>=\\ 200809L\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/getsid.2:64
msgid ""
"I<getsid(0)> returns the session ID of the calling process.  B<getsid>()  "
"returns the session ID of the process with process ID I<pid>.  If I<pid> is "
"0, B<getsid>()  returns the session ID of the calling process."
msgstr ""

#. type: Plain text
#: man-pages/man2/getsid.2:69
msgid ""
"On success, a session ID is returned.  On error, I<(pid_t)\\ -1> will be "
"returned, and I<errno> is set appropriately."
msgstr ""

#. type: Plain text
#: man-pages/man2/getsid.2:76
msgid ""
"A process with process ID I<pid> exists, but it is not in the same session "
"as the calling process, and the implementation considers this an error."
msgstr ""

#. type: Plain text
#: man-pages/man2/getsid.2:81
msgid "No process with process ID I<pid> was found."
msgstr ""

#.  Linux has this system call since Linux 1.3.44.
#.  There is libc support since libc 5.2.19.
#. type: Plain text
#: man-pages/man2/getsid.2:85
msgid "This system call is available on Linux since version 2.0."
msgstr ""

#. type: Plain text
#: man-pages/man2/getsid.2:90
msgid "Linux does not return B<EPERM>."
msgstr ""

#. type: Plain text
#: man-pages/man2/getsid.2:94
msgid "See B<credentials>(7)  for a description of sessions and session IDs."
msgstr ""

#. type: Plain text
#: man-pages/man2/getsid.2:97
msgid "B<getpgid>(2), B<setsid>(2), B<credentials>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/open_by_handle_at.2:25
#, no-wrap
msgid "OPEN_BY_HANDLE_AT"
msgstr ""

#. type: Plain text
#: man-pages/man2/open_by_handle_at.2:29
msgid ""
"name_to_handle_at, open_by_handle_at - obtain handle for a pathname and open "
"file via a handle"
msgstr ""

#. type: Plain text
#: man-pages/man2/open_by_handle_at.2:35
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>         /* See feature_test_macros(7) */\n"
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>sys/stat.hE<gt>>\n"
"B<#include E<lt>fcntl.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/open_by_handle_at.2:39
#, no-wrap
msgid ""
"B<int name_to_handle_at(int >I<dirfd>B<, const char *>I<pathname>B<,>\n"
"B<                      struct file_handle *>I<handle>B<,>\n"
"B<                      int *>I<mount_id>B<, int >I<flags>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/open_by_handle_at.2:42
#, no-wrap
msgid ""
"B<int open_by_handle_at(int >I<mount_fd>B<, struct file_handle "
"*>I<handle>B<,>\n"
"B<                      int >I<flags>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/open_by_handle_at.2:59
msgid ""
"The B<name_to_handle_at>()  and B<open_by_handle_at>()  system calls split "
"the functionality of B<openat>(2)  into two parts: B<name_to_handle_at>()  "
"returns an opaque handle that corresponds to a specified file; "
"B<open_by_handle_at>()  opens the file corresponding to a handle returned by "
"a previous call to B<name_to_handle_at>()  and returns an open file "
"descriptor."
msgstr ""

#. type: SS
#: man-pages/man2/open_by_handle_at.2:59
#, no-wrap
msgid "name_to_handle_at()"
msgstr ""

#. type: Plain text
#: man-pages/man2/open_by_handle_at.2:71
msgid ""
"The B<name_to_handle_at>()  system call returns a file handle and a mount ID "
"corresponding to the file specified by the I<dirfd> and I<pathname> "
"arguments.  The file handle is returned via the argument I<handle>, which is "
"a pointer to a structure of the following form:"
msgstr ""

#. type: Plain text
#: man-pages/man2/open_by_handle_at.2:80
#, no-wrap
msgid ""
"struct file_handle {\n"
"    unsigned int  handle_bytes;   /* Size of f_handle [in, out] */\n"
"    int           handle_type;    /* Handle type [out] */\n"
"    unsigned char f_handle[0];    /* File identifier (sized by\n"
"                                     caller) [out] */\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/open_by_handle_at.2:101
msgid ""
"It is the caller's responsibility to allocate the structure with a size "
"large enough to hold the handle returned in I<f_handle>.  Before the call, "
"the I<handle_bytes> field should be initialized to contain the allocated "
"size for I<f_handle>.  (The constant B<MAX_HANDLE_SZ>, defined in "
"I<E<lt>fcntl.hE<gt>>, specifies the maximum expected size for a file "
"handle.  It is not a guaranteed upper limit as future filesystems may "
"require more space.)  Upon successful return, the I<handle_bytes> field is "
"updated to contain the number of bytes actually written to I<f_handle>."
msgstr ""

#. type: Plain text
#: man-pages/man2/open_by_handle_at.2:123
msgid ""
"The caller can discover the required size for the I<file_handle> structure "
"by making a call in which I<handle-E<gt>handle_bytes> is zero; in this case, "
"the call fails with the error B<EOVERFLOW> and I<handle-E<gt>handle_bytes> "
"is set to indicate the required size; the caller can then use this "
"information to allocate a structure of the correct size (see EXAMPLE "
"below).  Some care is needed here as B<EOVERFLOW> can also indicate that no "
"file handle is available for this particular name in a filesystem which does "
"normally support file-handle lookup.  This case can be detected when the "
"B<EOVERFLOW> error is returned without I<handle_bytes> being increased."
msgstr ""

#. type: Plain text
#: man-pages/man2/open_by_handle_at.2:134
msgid ""
"Other than the use of the I<handle_bytes> field, the caller should treat the "
"I<file_handle> structure as an opaque data type: the I<handle_type> and "
"I<f_handle> fields are needed only by a subsequent call to "
"B<open_by_handle_at>()."
msgstr ""

#. type: Plain text
#: man-pages/man2/open_by_handle_at.2:142
msgid ""
"The I<flags> argument is a bit mask constructed by ORing together zero or "
"more of B<AT_EMPTY_PATH> and B<AT_SYMLINK_FOLLOW>, described below."
msgstr ""

#. type: Plain text
#: man-pages/man2/open_by_handle_at.2:149
msgid ""
"Together, the I<pathname> and I<dirfd> arguments identify the file for which "
"a handle is to be obtained.  There are four distinct cases:"
msgstr ""

#. type: Plain text
#: man-pages/man2/open_by_handle_at.2:157
msgid ""
"If I<pathname> is a nonempty string containing an absolute pathname, then a "
"handle is returned for the file referred to by that pathname.  In this case, "
"I<dirfd> is ignored."
msgstr ""

#. type: Plain text
#: man-pages/man2/open_by_handle_at.2:168
msgid ""
"If I<pathname> is a nonempty string containing a relative pathname and "
"I<dirfd> has the special value B<AT_FDCWD>, then I<pathname> is interpreted "
"relative to the current working directory of the caller, and a handle is "
"returned for the file to which it refers."
msgstr ""

#. type: Plain text
#: man-pages/man2/open_by_handle_at.2:181
msgid ""
"If I<pathname> is a nonempty string containing a relative pathname and "
"I<dirfd> is a file descriptor referring to a directory, then I<pathname> is "
"interpreted relative to the directory referred to by I<dirfd>, and a handle "
"is returned for the file to which it refers.  (See B<openat>(2)  for an "
"explanation of why \"directory file descriptors\" are useful.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/open_by_handle_at.2:195
msgid ""
"If I<pathname> is an empty string and I<flags> specifies the value "
"B<AT_EMPTY_PATH>, then I<dirfd> can be an open file descriptor referring to "
"any type of file, or B<AT_FDCWD>, meaning the current working directory, and "
"a handle is returned for the file to which it refers."
msgstr ""

#. type: Plain text
#: man-pages/man2/open_by_handle_at.2:211
msgid ""
"The I<mount_id> argument returns an identifier for the filesystem mount that "
"corresponds to I<pathname>.  This corresponds to the first field in one of "
"the records in I</proc/self/mountinfo>.  Opening the pathname in the fifth "
"field of that record yields a file descriptor for the mount point; that file "
"descriptor can be used in a subsequent call to B<open_by_handle_at>().  "
"I<mount_id> is returned both for a successful call and for a call that "
"results in the error B<EOVERFLOW>."
msgstr ""

#. type: Plain text
#: man-pages/man2/open_by_handle_at.2:224
msgid ""
"By default, B<name_to_handle_at>()  does not dereference I<pathname> if it "
"is a symbolic link, and thus returns a handle for the link itself.  If "
"B<AT_SYMLINK_FOLLOW> is specified in I<flags>, I<pathname> is dereferenced "
"if it is a symbolic link (so that the call returns a handle for the file "
"referred to by the link)."
msgstr ""

#.  commit 20fa19027286983ab2734b5910c4a687436e0c31
#. type: Plain text
#: man-pages/man2/open_by_handle_at.2:241
msgid ""
"B<name_to_handle_at>()  does not trigger a mount when the final component of "
"the pathname is an automount point.  When a filesystem supports both file "
"handles and automount points, a B<name_to_handle_at>()  call on an automount "
"point will return with error B<EOVERFLOW> without having increased "
"I<handle_bytes>.  This can happen since Linux 4.13 with NFS when accessing a "
"directory which is on a separate filesystem on the server.  In this case, "
"the automount can be triggered by adding a \"/\" to the end of the pathname."
msgstr ""

#. type: SS
#: man-pages/man2/open_by_handle_at.2:241
#, no-wrap
msgid "open_by_handle_at()"
msgstr ""

#. type: Plain text
#: man-pages/man2/open_by_handle_at.2:248
msgid ""
"The B<open_by_handle_at>()  system call opens the file referred to by "
"I<handle>, a file handle returned by a previous call to "
"B<name_to_handle_at>()."
msgstr ""

#. type: Plain text
#: man-pages/man2/open_by_handle_at.2:258
msgid ""
"The I<mount_fd> argument is a file descriptor for any object (file, "
"directory, etc.)  in the mounted filesystem with respect to which I<handle> "
"should be interpreted.  The special value B<AT_FDCWD> can be specified, "
"meaning the current working directory of the caller."
msgstr ""

#. type: Plain text
#: man-pages/man2/open_by_handle_at.2:271
msgid ""
"The I<flags> argument is as for B<open>(2).  If I<handle> refers to a "
"symbolic link, the caller must specify the B<O_PATH> flag, and the symbolic "
"link is not dereferenced; the B<O_NOFOLLOW> flag, if specified, is ignored."
msgstr ""

#. type: Plain text
#: man-pages/man2/open_by_handle_at.2:276
msgid ""
"The caller must have the B<CAP_DAC_READ_SEARCH> capability to invoke "
"B<open_by_handle_at>()."
msgstr ""

#. type: Plain text
#: man-pages/man2/open_by_handle_at.2:283
msgid ""
"On success, B<name_to_handle_at>()  returns 0, and B<open_by_handle_at>()  "
"returns a nonnegative file descriptor."
msgstr ""

#. type: Plain text
#: man-pages/man2/open_by_handle_at.2:287
msgid ""
"In the event of an error, both system calls return -1 and set I<errno> to "
"indicate the cause of the error."
msgstr ""

#. type: Plain text
#: man-pages/man2/open_by_handle_at.2:294
msgid ""
"B<name_to_handle_at>()  and B<open_by_handle_at>()  can fail for the same "
"errors as B<openat>(2).  In addition, they can fail with the errors noted "
"below."
msgstr ""

#. type: Plain text
#: man-pages/man2/open_by_handle_at.2:297
msgid "B<name_to_handle_at>()  can fail with the following errors:"
msgstr ""

#. type: Plain text
#: man-pages/man2/open_by_handle_at.2:304
msgid ""
"I<pathname>, I<mount_id>, or I<handle> points outside your accessible "
"address space."
msgstr ""

#. type: Plain text
#: man-pages/man2/open_by_handle_at.2:308
msgid "I<flags> includes an invalid bit value."
msgstr ""

#. type: Plain text
#: man-pages/man2/open_by_handle_at.2:313
msgid "I<handle-E<gt>handle_bytes> is greater than B<MAX_HANDLE_SZ>."
msgstr ""

#. type: Plain text
#: man-pages/man2/open_by_handle_at.2:320
msgid ""
"I<pathname> is an empty string, but B<AT_EMPTY_PATH> was not specified in "
"I<flags>."
msgstr ""

#. type: Plain text
#: man-pages/man2/open_by_handle_at.2:332
msgid ""
"The file descriptor supplied in I<dirfd> does not refer to a directory, and "
"it is not the case that both I<flags> includes B<AT_EMPTY_PATH> and "
"I<pathname> is an empty string."
msgstr ""

#. type: Plain text
#: man-pages/man2/open_by_handle_at.2:335
msgid "The filesystem does not support decoding of a pathname to a file handle."
msgstr ""

#. type: Plain text
#: man-pages/man2/open_by_handle_at.2:345
msgid ""
"The I<handle-E<gt>handle_bytes> value passed into the call was too small.  "
"When this error occurs, I<handle-E<gt>handle_bytes> is updated to indicate "
"the required size for the handle."
msgstr ""

#. type: Plain text
#: man-pages/man2/open_by_handle_at.2:348
msgid "B<open_by_handle_at>()  can fail with the following errors:"
msgstr ""

#. type: Plain text
#: man-pages/man2/open_by_handle_at.2:352
msgid "I<mount_fd> is not an open file descriptor."
msgstr ""

#. type: Plain text
#: man-pages/man2/open_by_handle_at.2:356
msgid "I<handle> points outside your accessible address space."
msgstr ""

#. type: Plain text
#: man-pages/man2/open_by_handle_at.2:362
msgid ""
"I<handle-E<gt>handle_bytes> is greater than B<MAX_HANDLE_SZ> or is equal to "
"zero."
msgstr ""

#. type: Plain text
#: man-pages/man2/open_by_handle_at.2:369
msgid ""
"I<handle> refers to a symbolic link, but B<O_PATH> was not specified in "
"I<flags>."
msgstr ""

#. type: Plain text
#: man-pages/man2/open_by_handle_at.2:374
msgid "The caller does not have the B<CAP_DAC_READ_SEARCH> capability."
msgstr ""

#. type: TP
#: man-pages/man2/open_by_handle_at.2:374
#, no-wrap
msgid "B<ESTALE>"
msgstr ""

#. type: Plain text
#: man-pages/man2/open_by_handle_at.2:380
msgid ""
"The specified I<handle> is not valid.  This error will occur if, for "
"example, the file has been deleted."
msgstr ""

#. type: Plain text
#: man-pages/man2/open_by_handle_at.2:383
msgid ""
"These system calls first appeared in Linux 2.6.39.  Library support is "
"provided in glibc since version 2.14."
msgstr ""

#. type: Plain text
#: man-pages/man2/open_by_handle_at.2:390
msgid ""
"FreeBSD has a broadly similar pair of system calls in the form of B<getfh>()  "
"and B<openfh>()."
msgstr ""

#. type: Plain text
#: man-pages/man2/open_by_handle_at.2:395
msgid ""
"A file handle can be generated in one process using B<name_to_handle_at>()  "
"and later used in a different process that calls B<open_by_handle_at>()."
msgstr ""

#. type: Plain text
#: man-pages/man2/open_by_handle_at.2:401
msgid ""
"Some filesystem don't support the translation of pathnames to file handles, "
"for example, I</proc>, I</sys>, and various network filesystems."
msgstr ""

#. type: Plain text
#: man-pages/man2/open_by_handle_at.2:408
msgid ""
"A file handle may become invalid (\"stale\") if a file is deleted, or for "
"other filesystem-specific reasons.  Invalid handles are notified by an "
"B<ESTALE> error from B<open_by_handle_at>()."
msgstr ""

#.  https://lwn.net/Articles/375888/
#. 	"Open by handle" - Jonathan Corbet, 2010-02-23
#. type: Plain text
#: man-pages/man2/open_by_handle_at.2:418
msgid ""
"These system calls are designed for use by user-space file servers.  For "
"example, a user-space NFS server might generate a file handle and pass it to "
"an NFS client.  Later, when the client wants to open the file, it could pass "
"the handle back to the server.  This sort of functionality allows a "
"user-space file server to operate in a stateless fashion with respect to the "
"files it serves."
msgstr ""

#.  commit bcda76524cd1fa32af748536f27f674a13e56700
#. type: Plain text
#: man-pages/man2/open_by_handle_at.2:440
msgid ""
"If I<pathname> refers to a symbolic link and I<flags> does not specify "
"B<AT_SYMLINK_FOLLOW>, then B<name_to_handle_at>()  returns a handle for the "
"link (rather than the file to which it refers).  The process receiving the "
"handle can later perform operations on the symbolic link by converting the "
"handle to a file descriptor using B<open_by_handle_at>()  with the B<O_PATH> "
"flag, and then passing the file descriptor as the I<dirfd> argument in "
"system calls such as B<readlinkat>(2)  and B<fchownat>(2)."
msgstr ""

#. type: SS
#: man-pages/man2/open_by_handle_at.2:440
#, no-wrap
msgid "Obtaining a persistent filesystem ID"
msgstr ""

#. type: Plain text
#: man-pages/man2/open_by_handle_at.2:454
msgid ""
"The mount IDs in I</proc/self/mountinfo> can be reused as filesystems are "
"unmounted and mounted.  Therefore, the mount ID returned by "
"B<name_to_handle_at>()  (in I<*mount_id>)  should not be treated as a "
"persistent identifier for the corresponding mounted filesystem.  However, an "
"application can use the information in the I<mountinfo> record that "
"corresponds to the mount ID to derive a persistent identifier."
msgstr ""

#.  e.g., http://stackoverflow.com/questions/6748429/using-libblkid-to-find-uuid-of-a-partition
#. type: Plain text
#: man-pages/man2/open_by_handle_at.2:470
msgid ""
"For example, one can use the device name in the fifth field of the "
"I<mountinfo> record to search for the corresponding device UUID via the "
"symbolic links in I</dev/disks/by-uuid>.  (A more comfortable way of "
"obtaining the UUID is to use the B<libblkid>(3)  library.)  That process can "
"then be reversed, using the UUID to look up the device name, and then "
"obtaining the corresponding mount point, in order to produce the I<mount_fd> "
"argument used by B<open_by_handle_at>()."
msgstr ""

#. type: Plain text
#: man-pages/man2/open_by_handle_at.2:482
msgid ""
"The two programs below demonstrate the use of B<name_to_handle_at>()  and "
"B<open_by_handle_at>().  The first program (I<t_name_to_handle_at.c>)  uses "
"B<name_to_handle_at>()  to obtain the file handle and mount ID for the file "
"specified in its command-line argument; the handle and mount ID are written "
"to standard output."
msgstr ""

#. type: Plain text
#: man-pages/man2/open_by_handle_at.2:502
msgid ""
"The second program (I<t_open_by_handle_at.c>)  reads a mount ID and file "
"handle from standard input.  The program then employs B<open_by_handle_at>()  "
"to open the file using that handle.  If an optional command-line argument is "
"supplied, then the I<mount_fd> argument for B<open_by_handle_at>()  is "
"obtained by opening the directory named in that argument.  Otherwise, "
"I<mount_fd> is obtained by scanning I</proc/self/mountinfo> to find a record "
"whose mount ID matches the mount ID read from standard input, and the mount "
"directory specified in that record is opened.  (These programs do not deal "
"with the fact that mount IDs are not persistent.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/open_by_handle_at.2:504
msgid "The following shell session demonstrates the use of these two programs:"
msgstr ""

#. type: Plain text
#: man-pages/man2/open_by_handle_at.2:514
#, no-wrap
msgid ""
"$ B<echo 'Can you please think about it?' E<gt> cecilia.txt>\n"
"$ B<./t_name_to_handle_at cecilia.txt E<gt> fh>\n"
"$ B<./t_open_by_handle_at E<lt> fh>\n"
"open_by_handle_at: Operation not permitted\n"
"$ B<sudo ./t_open_by_handle_at E<lt> fh>      # Need CAP_SYS_ADMIN\n"
"Read 31 bytes\n"
"$ B<rm cecilia.txt>\n"
msgstr ""

#.  Christoph Hellwig: That's why the file handles contain a generation
#.  counter that gets incremented in this case.
#. type: Plain text
#: man-pages/man2/open_by_handle_at.2:525
msgid ""
"Now we delete and (quickly) re-create the file so that it has the same "
"content and (by chance) the same inode.  Nevertheless, "
"B<open_by_handle_at>()  recognizes that the original file referred to by the "
"file handle no longer exists."
msgstr ""

#. type: Plain text
#: man-pages/man2/open_by_handle_at.2:536
#, no-wrap
msgid ""
"$ B<stat --printf=\"%i\\en\" cecilia.txt>     # Display inode number\n"
"4072121\n"
"$ B<rm cecilia.txt>\n"
"$ B<echo 'Can you please think about it?' E<gt> cecilia.txt>\n"
"$ B<stat --printf=\"%i\\en\" cecilia.txt>     # Check inode number\n"
"4072121\n"
"$ B<sudo ./t_open_by_handle_at E<lt> fh>\n"
"open_by_handle_at: Stale NFS file handle\n"
msgstr ""

#. type: SS
#: man-pages/man2/open_by_handle_at.2:538
#, no-wrap
msgid "Program source: t_name_to_handle_at.c"
msgstr ""

#. type: Plain text
#: man-pages/man2/open_by_handle_at.2:550
#, no-wrap
msgid ""
"#define _GNU_SOURCE\n"
"#include E<lt>sys/types.hE<gt>\n"
"#include E<lt>sys/stat.hE<gt>\n"
"#include E<lt>fcntl.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/open_by_handle_at.2:560
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    struct file_handle *fhp;\n"
"    int mount_id, fhsize, flags, dirfd, j;\n"
"    char *pathname;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/open_by_handle_at.2:565
#, no-wrap
msgid ""
"    if (argc != 2) {\n"
"        fprintf(stderr, \"Usage: %s pathname\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/open_by_handle_at.2:567
#, no-wrap
msgid "    pathname = argv[1];\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/open_by_handle_at.2:569
#, no-wrap
msgid "    /* Allocate file_handle structure */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/open_by_handle_at.2:574
#, no-wrap
msgid ""
"    fhsize = sizeof(*fhp);\n"
"    fhp = malloc(fhsize);\n"
"    if (fhp == NULL)\n"
"        errExit(\"malloc\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/open_by_handle_at.2:577
#, no-wrap
msgid ""
"    /* Make an initial call to name_to_handle_at() to discover\n"
"       the size required for file handle */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/open_by_handle_at.2:586
#, no-wrap
msgid ""
"    dirfd = AT_FDCWD;           /* For name_to_handle_at() calls */\n"
"    flags = 0;                  /* For name_to_handle_at() calls */\n"
"    fhp-E<gt>handle_bytes = 0;\n"
"    if (name_to_handle_at(dirfd, pathname, fhp,\n"
"                &mount_id, flags) != -1 || errno != EOVERFLOW) {\n"
"        fprintf(stderr, \"Unexpected result from "
"name_to_handle_at()\\en\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/open_by_handle_at.2:588
#, no-wrap
msgid "    /* Reallocate file_handle structure with correct size */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/open_by_handle_at.2:593
#, no-wrap
msgid ""
"    fhsize = sizeof(struct file_handle) + fhp-E<gt>handle_bytes;\n"
"    fhp = realloc(fhp, fhsize);         /* Copies fhp-E<gt>handle_bytes */\n"
"    if (fhp == NULL)\n"
"        errExit(\"realloc\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/open_by_handle_at.2:595
#, no-wrap
msgid "    /* Get file handle from pathname supplied on command line */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/open_by_handle_at.2:598
#, no-wrap
msgid ""
"    if (name_to_handle_at(dirfd, pathname, fhp, &mount_id, flags) == -1)\n"
"        errExit(\"name_to_handle_at\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/open_by_handle_at.2:601
#, no-wrap
msgid ""
"    /* Write mount ID, file handle size, and file handle to stdout,\n"
"       for later reuse by t_open_by_handle_at.c */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/open_by_handle_at.2:607
#, no-wrap
msgid ""
"    printf(\"%d\\en\", mount_id);\n"
"    printf(\"%d %d   \", fhp-E<gt>handle_bytes, fhp-E<gt>handle_type);\n"
"    for (j = 0; j E<lt> fhp-E<gt>handle_bytes; j++)\n"
"        printf(\" %02x\", fhp-E<gt>f_handle[j]);\n"
"    printf(\"\\en\");\n"
msgstr ""

#. type: SS
#: man-pages/man2/open_by_handle_at.2:611
#, no-wrap
msgid "Program source: t_open_by_handle_at.c"
msgstr ""

#. type: Plain text
#: man-pages/man2/open_by_handle_at.2:623
#, no-wrap
msgid ""
"#define _GNU_SOURCE\n"
"#include E<lt>sys/types.hE<gt>\n"
"#include E<lt>sys/stat.hE<gt>\n"
"#include E<lt>fcntl.hE<gt>\n"
"#include E<lt>limits.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/open_by_handle_at.2:632
#, no-wrap
msgid ""
"/* Scan /proc/self/mountinfo to find the line whose mount ID matches\n"
"   \\(aqmount_id\\(aq. (An easier way to do this is to install and use the\n"
"   \\(aqlibmount\\(aq library provided by the \\(aqutil-linux\\(aq "
"project.)\n"
"   Open the corresponding mount path and return the resulting file\n"
"   descriptor. */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/open_by_handle_at.2:642
#, no-wrap
msgid ""
"static int\n"
"open_mount_path_by_id(int mount_id)\n"
"{\n"
"    char *linep;\n"
"    size_t lsize;\n"
"    char mount_path[PATH_MAX];\n"
"    int mi_mount_id, found;\n"
"    ssize_t nread;\n"
"    FILE *fp;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/open_by_handle_at.2:646
#, no-wrap
msgid ""
"    fp = fopen(\"/proc/self/mountinfo\", \"r\");\n"
"    if (fp == NULL)\n"
"        errExit(\"fopen\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/open_by_handle_at.2:653
#, no-wrap
msgid ""
"    found = 0;\n"
"    linep = NULL;\n"
"    while (!found) {\n"
"        nread = getline(&linep, &lsize, fp);\n"
"        if (nread == -1)\n"
"            break;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/open_by_handle_at.2:660
#, no-wrap
msgid ""
"        nread = sscanf(linep, \"%d %*d %*s %*s %s\",\n"
"                       &mi_mount_id, mount_path);\n"
"        if (nread != 2) {\n"
"            fprintf(stderr, \"Bad sscanf()\\en\");\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/open_by_handle_at.2:665
#, no-wrap
msgid ""
"        if (mi_mount_id == mount_id)\n"
"            found = 1;\n"
"    }\n"
"    free(linep);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/open_by_handle_at.2:667
#, no-wrap
msgid "    fclose(fp);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/open_by_handle_at.2:672
#, no-wrap
msgid ""
"    if (!found) {\n"
"        fprintf(stderr, \"Could not find mount point\\en\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/open_by_handle_at.2:675
#, no-wrap
msgid ""
"    return open(mount_path, O_RDONLY);\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/open_by_handle_at.2:686
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    struct file_handle *fhp;\n"
"    int mount_id, fd, mount_fd, handle_bytes, j;\n"
"    ssize_t nread;\n"
"    char buf[1000];\n"
"#define LINE_SIZE 100\n"
"    char line1[LINE_SIZE], line2[LINE_SIZE];\n"
"    char *nextp;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/open_by_handle_at.2:691
#, no-wrap
msgid ""
"    if ((argc E<gt> 1 && strcmp(argv[1], \"--help\") == 0) || argc E<gt> 2) "
"{\n"
"        fprintf(stderr, \"Usage: %s [mount-path]\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/open_by_handle_at.2:693
#, no-wrap
msgid "    /* Standard input contains mount ID and file handle information:\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/open_by_handle_at.2:697
#, no-wrap
msgid ""
"         Line 1: E<lt>mount_idE<gt>\n"
"         Line 2: E<lt>handle_bytesE<gt> E<lt>handle_typeE<gt>   E<lt>bytes "
"of handle in hexE<gt>\n"
"    */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/open_by_handle_at.2:703
#, no-wrap
msgid ""
"    if ((fgets(line1, sizeof(line1), stdin) == NULL) ||\n"
"           (fgets(line2, sizeof(line2), stdin) == NULL)) {\n"
"        fprintf(stderr, \"Missing mount_id / file handle\\en\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/open_by_handle_at.2:705
#, no-wrap
msgid "    mount_id = atoi(line1);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/open_by_handle_at.2:707
#, no-wrap
msgid "    handle_bytes = strtoul(line2, &nextp, 0);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/open_by_handle_at.2:709
#, no-wrap
msgid "    /* Given handle_bytes, we can now allocate file_handle structure */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/open_by_handle_at.2:713
#, no-wrap
msgid ""
"    fhp = malloc(sizeof(struct file_handle) + handle_bytes);\n"
"    if (fhp == NULL)\n"
"        errExit(\"malloc\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/open_by_handle_at.2:715
#, no-wrap
msgid "    fhp-E<gt>handle_bytes = handle_bytes;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/open_by_handle_at.2:717
#, no-wrap
msgid "    fhp-E<gt>handle_type = strtoul(nextp, &nextp, 0);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/open_by_handle_at.2:720
#, no-wrap
msgid ""
"    for (j = 0; j E<lt> fhp-E<gt>handle_bytes; j++)\n"
"        fhp-E<gt>f_handle[j] = strtoul(nextp, &nextp, 16);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/open_by_handle_at.2:725
#, no-wrap
msgid ""
"    /* Obtain file descriptor for mount point, either by opening\n"
"       the pathname specified on the command line, or by scanning\n"
"       /proc/self/mounts to find a mount that matches the "
"\\(aqmount_id\\(aq\n"
"       that we received from stdin. */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/open_by_handle_at.2:730
#, no-wrap
msgid ""
"    if (argc E<gt> 1)\n"
"        mount_fd = open(argv[1], O_RDONLY);\n"
"    else\n"
"        mount_fd = open_mount_path_by_id(mount_id);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/open_by_handle_at.2:733
#, no-wrap
msgid ""
"    if (mount_fd == -1)\n"
"        errExit(\"opening mount fd\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/open_by_handle_at.2:735
#, no-wrap
msgid "    /* Open file using handle and mount point */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/open_by_handle_at.2:739
#, no-wrap
msgid ""
"    fd = open_by_handle_at(mount_fd, fhp, O_RDONLY);\n"
"    if (fd == -1)\n"
"        errExit(\"open_by_handle_at\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/open_by_handle_at.2:741
#, no-wrap
msgid "    /* Try reading a few bytes from the file */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/open_by_handle_at.2:745
#, no-wrap
msgid ""
"    nread = read(fd, buf, sizeof(buf));\n"
"    if (nread == -1)\n"
"        errExit(\"read\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/open_by_handle_at.2:747
#, no-wrap
msgid "    printf(\"Read %zd bytes\\en\", nread);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/open_by_handle_at.2:757
msgid "B<open>(2), B<libblkid>(3), B<blkid>(8), B<findfs>(8), B<mount>(8)"
msgstr ""

#. type: Plain text
#: man-pages/man2/open_by_handle_at.2:766
msgid ""
"The I<libblkid> and I<libmount> documentation in the latest I<util-linux> "
"release at E<.UR https://www.kernel.org/pub/linux/utils/util-linux/> E<.UE>"
msgstr ""

#. type: TH
#: man-pages/man2/epoll_ctl.2:20
#, no-wrap
msgid "EPOLL_CTL"
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_ctl.2:23
msgid "epoll_ctl - control interface for an epoll file descriptor"
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_ctl.2:25
msgid "B<#include E<lt>sys/epoll.hE<gt>>"
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_ctl.2:28
msgid ""
"B<int epoll_ctl(int >I<epfd>B<, int >I<op>B<, int >I<fd>B<, struct "
"epoll_event *>I<event>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_ctl.2:39
msgid ""
"This system call is used to add, modify, or remove entries in the interest "
"list of the B<epoll>(7)  instance referred to by the file descriptor "
"I<epfd>.  It requests that the operation I<op> be performed for the target "
"file descriptor, I<fd>."
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_ctl.2:43
msgid "Valid values for the I<op> argument are:"
msgstr ""

#. type: TP
#: man-pages/man2/epoll_ctl.2:43
#, no-wrap
msgid "B<EPOLL_CTL_ADD>"
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_ctl.2:52
msgid ""
"Add I<fd> to the interest list and associate the settings specified in "
"I<event> with the internal file linked to I<fd>."
msgstr ""

#. type: TP
#: man-pages/man2/epoll_ctl.2:52
#, no-wrap
msgid "B<EPOLL_CTL_MOD>"
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_ctl.2:58
msgid ""
"Change the settings associated with I<fd> in the interest list to the new "
"settings specified in I<event>."
msgstr ""

#. type: TP
#: man-pages/man2/epoll_ctl.2:58
#, no-wrap
msgid "B<EPOLL_CTL_DEL>"
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_ctl.2:66
msgid ""
"Remove (deregister) the target file descriptor I<fd> from the interest "
"list.  The I<event> argument is ignored and can be NULL (but see BUGS "
"below)."
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_ctl.2:74
msgid ""
"The I<event> argument describes the object linked to the file descriptor "
"I<fd>.  The I<struct epoll_event> is defined as:"
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_ctl.2:83
#, no-wrap
msgid ""
"typedef union epoll_data {\n"
"    void        *ptr;\n"
"    int          fd;\n"
"    uint32_t     u32;\n"
"    uint64_t     u64;\n"
"} epoll_data_t;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_ctl.2:88
#, no-wrap
msgid ""
"struct epoll_event {\n"
"    uint32_t     events;      /* Epoll events */\n"
"    epoll_data_t data;        /* User data variable */\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_ctl.2:95
msgid ""
"The I<events> member is a bit mask composed by ORing together zero or more "
"of the following available event types:"
msgstr ""

#. type: TP
#: man-pages/man2/epoll_ctl.2:95
#, no-wrap
msgid "B<EPOLLIN>"
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_ctl.2:100
msgid "The associated file is available for B<read>(2)  operations."
msgstr ""

#. type: TP
#: man-pages/man2/epoll_ctl.2:100
#, no-wrap
msgid "B<EPOLLOUT>"
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_ctl.2:105
msgid "The associated file is available for B<write>(2)  operations."
msgstr ""

#. type: TP
#: man-pages/man2/epoll_ctl.2:105
#, no-wrap
msgid "B<EPOLLRDHUP> (since Linux 2.6.17)"
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_ctl.2:111
msgid ""
"Stream socket peer closed connection, or shut down writing half of "
"connection.  (This flag is especially useful for writing simple code to "
"detect peer shutdown when using Edge Triggered monitoring.)"
msgstr ""

#. type: TP
#: man-pages/man2/epoll_ctl.2:111
#, no-wrap
msgid "B<EPOLLPRI>"
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_ctl.2:118
msgid ""
"There is an exceptional condition on the file descriptor.  See the "
"discussion of B<POLLPRI> in B<poll>(2)."
msgstr ""

#. type: TP
#: man-pages/man2/epoll_ctl.2:118
#, no-wrap
msgid "B<EPOLLERR>"
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_ctl.2:126
msgid ""
"Error condition happened on the associated file descriptor.  This event is "
"also reported for the write end of a pipe when the read end has been "
"closed.  B<epoll_wait>(2)  will always report for this event; it is not "
"necessary to set it in I<events>."
msgstr ""

#. type: TP
#: man-pages/man2/epoll_ctl.2:126
#, no-wrap
msgid "B<EPOLLHUP>"
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_ctl.2:132
msgid ""
"Hang up happened on the associated file descriptor.  B<epoll_wait>(2)  will "
"always wait for this event; it is not necessary to set it in I<events>."
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_ctl.2:137
msgid ""
"Note that when reading from a channel such as a pipe or a stream socket, "
"this event merely indicates that the peer closed its end of the channel.  "
"Subsequent reads from the channel will return 0 (end of file)  only after "
"all outstanding data in the channel has been consumed."
msgstr ""

#. type: TP
#: man-pages/man2/epoll_ctl.2:137
#, no-wrap
msgid "B<EPOLLET>"
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_ctl.2:147
msgid ""
"Sets the Edge Triggered behavior for the associated file descriptor.  The "
"default behavior for B<epoll> is Level Triggered.  See B<epoll>(7)  for more "
"detailed information about Edge and Level Triggered event distribution "
"architectures."
msgstr ""

#. type: TP
#: man-pages/man2/epoll_ctl.2:147
#, no-wrap
msgid "B<EPOLLONESHOT> (since Linux 2.6.2)"
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_ctl.2:161
msgid ""
"Sets the one-shot behavior for the associated file descriptor.  This means "
"that after an event is pulled out with B<epoll_wait>(2)  the associated file "
"descriptor is internally disabled and no other events will be reported by "
"the B<epoll> interface.  The user must call B<epoll_ctl>()  with "
"B<EPOLL_CTL_MOD> to rearm the file descriptor with a new event mask."
msgstr ""

#. type: TP
#: man-pages/man2/epoll_ctl.2:161
#, no-wrap
msgid "B<EPOLLWAKEUP> (since Linux 3.5)"
msgstr ""

#.  commit 4d7e30d98939a0340022ccd49325a3d70f7e0238
#. type: Plain text
#: man-pages/man2/epoll_ctl.2:189
msgid ""
"If B<EPOLLONESHOT> and B<EPOLLET> are clear and the process has the "
"B<CAP_BLOCK_SUSPEND> capability, ensure that the system does not enter "
"\"suspend\" or \"hibernate\" while this event is pending or being "
"processed.  The event is considered as being \"processed\" from the time "
"when it is returned by a call to B<epoll_wait>(2)  until the next call to "
"B<epoll_wait>(2)  on the same B<epoll>(7)  file descriptor, the closure of "
"that file descriptor, the removal of the event file descriptor with "
"B<EPOLL_CTL_DEL>, or the clearing of B<EPOLLWAKEUP> for the event file "
"descriptor with B<EPOLL_CTL_MOD>.  See also BUGS."
msgstr ""

#. type: TP
#: man-pages/man2/epoll_ctl.2:189
#, no-wrap
msgid "B<EPOLLEXCLUSIVE> (since Linux 4.5)"
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_ctl.2:204
msgid ""
"Sets an exclusive wakeup mode for the epoll file descriptor that is being "
"attached to the target file descriptor, I<fd>.  When a wakeup event occurs "
"and multiple epoll file descriptors are attached to the same target file "
"using B<EPOLLEXCLUSIVE>, one or more of the epoll file descriptors will "
"receive an event with B<epoll_wait>(2).  The default in this scenario (when "
"B<EPOLLEXCLUSIVE> is not set) is for all epoll file descriptors to receive "
"an event.  B<EPOLLEXCLUSIVE> is thus useful for avoiding thundering herd "
"problems in certain scenarios."
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_ctl.2:213
msgid ""
"If the same file descriptor is in multiple epoll instances, some with the "
"B<EPOLLEXCLUSIVE> flag, and others without, then events will be provided to "
"all epoll instances that did not specify B<EPOLLEXCLUSIVE>, and at least one "
"of the epoll instances that did specify B<EPOLLEXCLUSIVE>."
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_ctl.2:232
msgid ""
"The following values may be specified in conjunction with B<EPOLLEXCLUSIVE>: "
"B<EPOLLIN>, B<EPOLLOUT>, B<EPOLLWAKEUP>, and B<EPOLLET>.  B<EPOLLHUP> and "
"B<EPOLLERR> can also be specified, but this is not required: as usual, these "
"events are always reported if they occur, regardless of whether they are "
"specified in I<events>.  Attempts to specify other values in I<events> yield "
"the error B<EINVAL>."
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_ctl.2:259
msgid ""
"B<EPOLLEXCLUSIVE> may be used only in an B<EPOLL_CTL_ADD> operation; "
"attempts to employ it with B<EPOLL_CTL_MOD> yield an error.  If "
"B<EPOLLEXCLUSIVE> has been set using B<epoll_ctl>(), then a subsequent "
"B<EPOLL_CTL_MOD> on the same I<epfd>,\\ I<fd> pair yields an error.  A call "
"to B<epoll_ctl>()  that specifies B<EPOLLEXCLUSIVE> in I<events> and "
"specifies the target file descriptor I<fd> as an epoll instance will "
"likewise fail.  The error in all of these cases is B<EINVAL>."
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_ctl.2:268
msgid ""
"When successful, B<epoll_ctl>()  returns zero.  When an error occurs, "
"B<epoll_ctl>()  returns -1 and I<errno> is set appropriately."
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_ctl.2:275
msgid "I<epfd> or I<fd> is not a valid file descriptor."
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_ctl.2:283
msgid ""
"I<op> was B<EPOLL_CTL_ADD>, and the supplied file descriptor I<fd> is "
"already registered with this epoll instance."
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_ctl.2:296
msgid ""
"I<epfd> is not an B<epoll> file descriptor, or I<fd> is the same as I<epfd>, "
"or the requested operation I<op> is not supported by this interface."
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_ctl.2:302
msgid ""
"An invalid event type was specified along with B<EPOLLEXCLUSIVE> in "
"I<events>."
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_ctl.2:311
msgid "I<op> was B<EPOLL_CTL_MOD> and I<events> included B<EPOLLEXCLUSIVE>."
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_ctl.2:321
msgid ""
"I<op> was B<EPOLL_CTL_MOD> and the B<EPOLLEXCLUSIVE> flag has previously "
"been applied to this I<epfd>,\\ I<fd> pair."
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_ctl.2:329
msgid ""
"B<EPOLLEXCLUSIVE> was specified in I<event> and I<fd> refers to an epoll "
"instance."
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_ctl.2:336
msgid ""
"I<fd> refers to an epoll instance and this B<EPOLL_CTL_ADD> operation would "
"result in a circular loop of epoll instances monitoring one another."
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_ctl.2:346
msgid ""
"I<op> was B<EPOLL_CTL_MOD> or B<EPOLL_CTL_DEL>, and I<fd> is not registered "
"with this epoll instance."
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_ctl.2:351
msgid ""
"There was insufficient memory to handle the requested I<op> control "
"operation."
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_ctl.2:361
msgid ""
"The limit imposed by I</proc/sys/fs/epoll/max_user_watches> was encountered "
"while trying to register (B<EPOLL_CTL_ADD>)  a new file descriptor on an "
"epoll instance.  See B<epoll>(7)  for further details."
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_ctl.2:370
msgid ""
"The target file I<fd> does not support B<epoll>.  This error can occur if "
"I<fd> refers to, for example, a regular file or a directory."
msgstr ""

#.  To be precise: kernel 2.5.44.
#.  The interface should be finalized by Linux kernel 2.5.66.
#. type: Plain text
#: man-pages/man2/epoll_ctl.2:375
msgid "B<epoll_ctl>()  was added to the kernel in version 2.6."
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_ctl.2:379
msgid ""
"B<epoll_ctl>()  is Linux-specific.  Library support is provided in glibc "
"starting with version 2.3.2."
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_ctl.2:384
msgid ""
"The B<epoll> interface supports all file descriptors that support "
"B<poll>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_ctl.2:398
msgid ""
"In kernel versions before 2.6.9, the B<EPOLL_CTL_DEL> operation required a "
"non-null pointer in I<event>, even though this argument is ignored.  Since "
"Linux 2.6.9, I<event> can be specified as NULL when using B<EPOLL_CTL_DEL>.  "
"Applications that need to be portable to kernels before 2.6.9 should specify "
"a non-null pointer in I<event>."
msgstr ""

#.  commit a8159414d7e3af7233e7a5a82d1c5d85379bd75c (behavior change)
#.  https://lwn.net/Articles/520198/
#. type: Plain text
#: man-pages/man2/epoll_ctl.2:425
msgid ""
"If B<EPOLLWAKEUP> is specified in I<flags>, but the caller does not have the "
"B<CAP_BLOCK_SUSPEND> capability, then the B<EPOLLWAKEUP> flag is I<silently "
"ignored>.  This unfortunate behavior is necessary because no validity checks "
"were performed on the I<flags> argument in the original implementation, and "
"the addition of the B<EPOLLWAKEUP> with a check that caused the call to fail "
"if the caller did not have the B<CAP_BLOCK_SUSPEND> capability caused a "
"breakage in at least one existing user-space application that happened to "
"randomly (and uselessly) specify this bit.  A robust application should "
"therefore double check that it has the B<CAP_BLOCK_SUSPEND> capability if "
"attempting to use the B<EPOLLWAKEUP> flag."
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_ctl.2:429
msgid "B<epoll_create>(2), B<epoll_wait>(2), B<poll>(2), B<epoll>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/wait4.2:33
#, no-wrap
msgid "WAIT4"
msgstr ""

#. type: Plain text
#: man-pages/man2/wait4.2:36
msgid "wait3, wait4 - wait for process to change state, BSD style"
msgstr ""

#. type: Plain text
#: man-pages/man2/wait4.2:42
#, no-wrap
msgid ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>sys/time.hE<gt>>\n"
"B<#include E<lt>sys/resource.hE<gt>>\n"
"B<#include E<lt>sys/wait.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/wait4.2:45
#, no-wrap
msgid ""
"B<pid_t wait3(int *>I<wstatus>B<, int >I<options>B<,>\n"
"B<            struct rusage *>I<rusage>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/wait4.2:48
#, no-wrap
msgid ""
"B<pid_t wait4(pid_t >I<pid>B<, int *>I<wstatus>B<, int >I<options>B<,>\n"
"B<            struct rusage *>I<rusage>B<);>\n"
msgstr ""

#.           || _XOPEN_SOURCE\ &&\ _XOPEN_SOURCE_EXTENDED
#. type: Plain text
#: man-pages/man2/wait4.2:62
#, no-wrap
msgid ""
"B<wait3>():\n"
"    Since glibc 2.19:\n"
"        _DEFAULT_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 500\n"
"    Glibc 2.19 and earlier:\n"
"        _BSD_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 500\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/wait4.2:68
#, no-wrap
msgid ""
"B<wait4>():\n"
"    Since glibc 2.19:\n"
"        _DEFAULT_SOURCE\n"
"    Glibc 2.19 and earlier:\n"
"        _BSD_SOURCE\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/wait4.2:75
msgid ""
"These functions are nonstandard; in new programs, the use of B<waitpid>(2)  "
"or B<waitid>(2)  is preferable."
msgstr ""

#. type: Plain text
#: man-pages/man2/wait4.2:85
msgid ""
"The B<wait3>()  and B<wait4>()  system calls are similar to B<waitpid>(2), "
"but additionally return resource usage information about the child in the "
"structure pointed to by I<rusage>."
msgstr ""

#. type: Plain text
#: man-pages/man2/wait4.2:91
msgid ""
"Other than the use of the I<rusage> argument, the following B<wait3>()  "
"call:"
msgstr ""

#. type: Plain text
#: man-pages/man2/wait4.2:95
#, no-wrap
msgid "wait3(wstatus, options, rusage);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/wait4.2:99 man-pages/man2/wait4.2:117
msgid "is equivalent to:"
msgstr ""

#. type: Plain text
#: man-pages/man2/wait4.2:103
#, no-wrap
msgid "waitpid(-1, wstatus, options);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/wait4.2:109
msgid "Similarly, the following B<wait4>()  call:"
msgstr ""

#. type: Plain text
#: man-pages/man2/wait4.2:113
#, no-wrap
msgid "wait4(pid, wstatus, options, rusage);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/wait4.2:121
#, no-wrap
msgid "waitpid(pid, wstatus, options);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/wait4.2:132
msgid ""
"In other words, B<wait3>()  waits of any child, while B<wait4>()  can be "
"used to select a specific child, or children, on which to wait.  See "
"B<wait>(2)  for further details."
msgstr ""

#. type: Plain text
#: man-pages/man2/wait4.2:142
msgid ""
"If I<rusage> is not NULL, the I<struct rusage> to which it points will be "
"filled with accounting information about the child.  See B<getrusage>(2)  "
"for details."
msgstr ""

#. type: Plain text
#: man-pages/man2/wait4.2:145 man-pages/man2/wait4.2:148
msgid "As for B<waitpid>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/wait4.2:150
msgid "4.3BSD."
msgstr ""

#. type: Plain text
#: man-pages/man2/wait4.2:157
msgid ""
"SUSv1 included a specification of B<wait3>(); SUSv2 included B<wait3>(), but "
"marked it LEGACY; SUSv3 removed it."
msgstr ""

#. type: Plain text
#: man-pages/man2/wait4.2:175
msgid ""
"On Linux, B<wait3>()  is a library function implemented on top of the "
"B<wait4>()  system call."
msgstr ""

#. type: Plain text
#: man-pages/man2/wait4.2:181
msgid ""
"B<fork>(2), B<getrusage>(2), B<sigaction>(2), B<signal>(2), B<wait>(2), "
"B<signal>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/pciconfig_read.2:8
#, no-wrap
msgid "PCICONFIG_READ"
msgstr ""

#. type: TH
#: man-pages/man2/pciconfig_read.2:8
#, no-wrap
msgid "2016-07-17"
msgstr ""

#. type: Plain text
#: man-pages/man2/pciconfig_read.2:11
msgid ""
"pciconfig_read, pciconfig_write, pciconfig_iobase - pci device information "
"handling"
msgstr ""

#. type: Plain text
#: man-pages/man2/pciconfig_read.2:14
#, no-wrap
msgid "B<#include E<lt>pci.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/pciconfig_read.2:21
#, no-wrap
msgid ""
"B<int pciconfig_read(unsigned long >I<bus>B<, unsigned long >I<dfn>B<,>\n"
"B<          unsigned long >I<off>B<, unsigned long >I<len>B<, void "
"*>I<buf>B<);>\n"
"B<int pciconfig_write(unsigned long >I<bus>B<, unsigned long >I<dfn>B<,>\n"
"B<          unsigned long >I<off>B<, unsigned long >I<len>B<, void "
"*>I<buf>B<);>\n"
"B<int pciconfig_iobase(long >I<which>B<, unsigned long >I<bus>B<,>\n"
"B<          unsigned long >I<devfn>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/pciconfig_read.2:27
msgid ""
"Most of the interaction with PCI devices is already handled by the kernel "
"PCI layer, and thus these calls should not normally need to be accessed from "
"user space."
msgstr ""

#. type: TP
#: man-pages/man2/pciconfig_read.2:27 man-pages/man2/pciconfig_read.2:51
#, no-wrap
msgid "B<pciconfig_read>()"
msgstr ""

#. type: Plain text
#: man-pages/man2/pciconfig_read.2:36
msgid "Reads to I<buf> from device I<dev> at offset I<off> value."
msgstr ""

#. type: TP
#: man-pages/man2/pciconfig_read.2:36 man-pages/man2/pciconfig_read.2:57
#, no-wrap
msgid "B<pciconfig_write>()"
msgstr ""

#. type: Plain text
#: man-pages/man2/pciconfig_read.2:45
msgid "Writes from I<buf> to device I<dev> at offset I<off> value."
msgstr ""

#. type: TP
#: man-pages/man2/pciconfig_read.2:45 man-pages/man2/pciconfig_read.2:63
#, no-wrap
msgid "B<pciconfig_iobase>()"
msgstr ""

#. type: Plain text
#: man-pages/man2/pciconfig_read.2:50
msgid ""
"You pass it a bus/devfn pair and get a physical address for either the "
"memory offset (for things like prep, this is 0xc0000000), the IO base for "
"PIO cycles, or the ISA holes if any."
msgstr ""

#. type: Plain text
#: man-pages/man2/pciconfig_read.2:77
msgid ""
"Returns information on locations of various I/O regions in physical memory "
"according to the I<which> value.  Values for I<which> are: "
"B<IOBASE_BRIDGE_NUMBER>, B<IOBASE_MEMORY>, B<IOBASE_IO>, B<IOBASE_ISA_IO>, "
"B<IOBASE_ISA_MEM>."
msgstr ""

#. type: Plain text
#: man-pages/man2/pciconfig_read.2:84
msgid "I<len> value is invalid.  This does not apply to B<pciconfig_iobase>()."
msgstr ""

#. type: Plain text
#: man-pages/man2/pciconfig_read.2:93
msgid ""
"For B<pciconfig_iobase>(), \"hose\" value is NULL.  For the other calls, "
"could not find a slot."
msgstr ""

#. type: Plain text
#: man-pages/man2/pciconfig_read.2:98
msgid "The system has not implemented these calls (B<CONFIG_PCI> not defined)."
msgstr ""

#. type: Plain text
#: man-pages/man2/pciconfig_read.2:105
msgid ""
"This return value is valid only for B<pciconfig_iobase>().  It is returned "
"if the value for I<which> is invalid."
msgstr ""

#. type: Plain text
#: man-pages/man2/pciconfig_read.2:112
msgid ""
"User does not have the B<CAP_SYS_ADMIN> capability.  This does not apply to "
"B<pciconfig_iobase>()."
msgstr ""

#. type: Plain text
#: man-pages/man2/pciconfig_read.2:114
msgid "These calls are Linux-specific, available since Linux 2.0.26/2.1.11."
msgstr ""

#. type: Plain text
#: man-pages/man2/pciconfig_read.2:115
msgid "B<capabilities>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/statfs.2:28
#, no-wrap
msgid "STATFS"
msgstr ""

#. type: Plain text
#: man-pages/man2/statfs.2:31
msgid "statfs, fstatfs - get filesystem statistics"
msgstr ""

#. type: Plain text
#: man-pages/man2/statfs.2:33
msgid "B<#include E<lt>sys/vfs.hE<gt> >/* or E<lt>sys/statfs.hE<gt> */"
msgstr ""

#. type: Plain text
#: man-pages/man2/statfs.2:35
msgid "B<int statfs(const char *>I<path>B<, struct statfs *>I<buf>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/statfs.2:37
msgid "B<int fstatfs(int >I<fd>B<, struct statfs *>I<buf>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/statfs.2:47
msgid ""
"The B<statfs>()  system call returns information about a mounted "
"filesystem.  I<path> is the pathname of any file within the mounted "
"filesystem.  I<buf> is a pointer to a I<statfs> structure defined "
"approximately as follows:"
msgstr ""

#. type: Plain text
#: man-pages/man2/statfs.2:67
#, no-wrap
msgid ""
"struct statfs {\n"
"    __fsword_t f_type;    /* Type of filesystem (see below) */\n"
"    __fsword_t f_bsize;   /* Optimal transfer block size */\n"
"    fsblkcnt_t f_blocks;  /* Total data blocks in filesystem */\n"
"    fsblkcnt_t f_bfree;   /* Free blocks in filesystem */\n"
"    fsblkcnt_t f_bavail;  /* Free blocks available to\n"
"                             unprivileged user */\n"
"    fsfilcnt_t f_files;   /* Total file nodes in filesystem */\n"
"    fsfilcnt_t f_ffree;   /* Free file nodes in filesystem */\n"
"    fsid_t     f_fsid;    /* Filesystem ID */\n"
"    __fsword_t f_namelen; /* Maximum length of filenames */\n"
"    __fsword_t f_frsize;  /* Fragment size (since Linux 2.6) */\n"
"    __fsword_t f_flags;   /* Mount flags of filesystem\n"
"                             (since Linux 2.6.36) */\n"
"    __fsword_t f_spare[xxx];\n"
"                    /* Padding bytes reserved for future use */\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/statfs.2:72
msgid "The following filesystem types may appear in I<f_type>:"
msgstr ""

#. type: Plain text
#: man-pages/man2/statfs.2:160
#, no-wrap
msgid ""
"ADFS_SUPER_MAGIC      0xadf5\n"
"AFFS_SUPER_MAGIC      0xadff\n"
"AFS_SUPER_MAGIC       0x5346414f\n"
"ANON_INODE_FS_MAGIC   0x09041934 /* Anonymous inode FS (for\n"
"                                    pseudofiles that have no name;\n"
"                                    e.g., epoll, signalfd, bpf) */\n"
"AUTOFS_SUPER_MAGIC    0x0187\n"
"BDEVFS_MAGIC          0x62646576\n"
"BEFS_SUPER_MAGIC      0x42465331\n"
"BFS_MAGIC             0x1badface\n"
"BINFMTFS_MAGIC        0x42494e4d\n"
"BPF_FS_MAGIC          0xcafe4a11\n"
"BTRFS_SUPER_MAGIC     0x9123683e\n"
"BTRFS_TEST_MAGIC      0x73727279\n"
"CGROUP_SUPER_MAGIC    0x27e0eb   /* Cgroup pseudo FS */\n"
"CGROUP2_SUPER_MAGIC   0x63677270 /* Cgroup v2 pseudo FS */\n"
"CIFS_MAGIC_NUMBER     0xff534d42\n"
"CODA_SUPER_MAGIC      0x73757245\n"
"COH_SUPER_MAGIC       0x012ff7b7\n"
"CRAMFS_MAGIC          0x28cd3d45\n"
"DEBUGFS_MAGIC         0x64626720\n"
"DEVFS_SUPER_MAGIC     0x1373     /* Linux 2.6.17 and earlier */\n"
"DEVPTS_SUPER_MAGIC    0x1cd1\n"
"ECRYPTFS_SUPER_MAGIC  0xf15f\n"
"EFIVARFS_MAGIC        0xde5e81e4\n"
"EFS_SUPER_MAGIC       0x00414a53\n"
"EXT_SUPER_MAGIC       0x137d     /* Linux 2.0 and earlier */\n"
"EXT2_OLD_SUPER_MAGIC  0xef51\n"
"EXT2_SUPER_MAGIC      0xef53\n"
"EXT3_SUPER_MAGIC      0xef53\n"
"EXT4_SUPER_MAGIC      0xef53\n"
"F2FS_SUPER_MAGIC      0xf2f52010\n"
"FUSE_SUPER_MAGIC      0x65735546\n"
"FUTEXFS_SUPER_MAGIC   0xbad1dea  /* Unused */\n"
"HFS_SUPER_MAGIC       0x4244\n"
"HOSTFS_SUPER_MAGIC    0x00c0ffee\n"
"HPFS_SUPER_MAGIC      0xf995e849\n"
"HUGETLBFS_MAGIC       0x958458f6\n"
"ISOFS_SUPER_MAGIC     0x9660\n"
"JFFS2_SUPER_MAGIC     0x72b6\n"
"JFS_SUPER_MAGIC       0x3153464a\n"
"MINIX_SUPER_MAGIC     0x137f     /* original minix FS */\n"
"MINIX_SUPER_MAGIC2    0x138f     /* 30 char minix FS */\n"
"MINIX2_SUPER_MAGIC    0x2468     /* minix V2 FS */\n"
"MINIX2_SUPER_MAGIC2   0x2478     /* minix V2 FS, 30 char names */\n"
"MINIX3_SUPER_MAGIC    0x4d5a     /* minix V3 FS, 60 char names */\n"
"MQUEUE_MAGIC          0x19800202 /* POSIX message queue FS */\n"
"MSDOS_SUPER_MAGIC     0x4d44\n"
"MTD_INODE_FS_MAGIC    0x11307854\n"
"NCP_SUPER_MAGIC       0x564c\n"
"NFS_SUPER_MAGIC       0x6969\n"
"NILFS_SUPER_MAGIC     0x3434\n"
"NSFS_MAGIC            0x6e736673\n"
"NTFS_SB_MAGIC         0x5346544e\n"
"OCFS2_SUPER_MAGIC     0x7461636f\n"
"OPENPROM_SUPER_MAGIC  0x9fa1\n"
"OVERLAYFS_SUPER_MAGIC 0x794c7630\n"
"PIPEFS_MAGIC          0x50495045\n"
"PROC_SUPER_MAGIC      0x9fa0     /* /proc FS */\n"
"PSTOREFS_MAGIC        0x6165676c\n"
"QNX4_SUPER_MAGIC      0x002f\n"
"QNX6_SUPER_MAGIC      0x68191122\n"
"RAMFS_MAGIC           0x858458f6\n"
"REISERFS_SUPER_MAGIC  0x52654973\n"
"ROMFS_MAGIC           0x7275\n"
"SECURITYFS_MAGIC      0x73636673\n"
"SELINUX_MAGIC         0xf97cff8c\n"
"SMACK_MAGIC           0x43415d53\n"
"SMB_SUPER_MAGIC       0x517b\n"
"SOCKFS_MAGIC          0x534f434b\n"
"SQUASHFS_MAGIC        0x73717368\n"
"SYSFS_MAGIC           0x62656572\n"
"SYSV2_SUPER_MAGIC     0x012ff7b6\n"
"SYSV4_SUPER_MAGIC     0x012ff7b5\n"
"TMPFS_MAGIC           0x01021994\n"
"TRACEFS_MAGIC         0x74726163\n"
"UDF_SUPER_MAGIC       0x15013346\n"
"UFS_MAGIC             0x00011954\n"
"USBDEVICE_SUPER_MAGIC 0x9fa2\n"
"V9FS_MAGIC            0x01021997\n"
"VXFS_SUPER_MAGIC      0xa501fcf5\n"
"XENFS_SUPER_MAGIC     0xabba1974\n"
"XENIX_SUPER_MAGIC     0x012ff7b4\n"
"XFS_SUPER_MAGIC       0x58465342\n"
"_XIAFS_SUPER_MAGIC    0x012fd16d /* Linux 2.0 and earlier */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/statfs.2:166
msgid ""
"Most of these MAGIC constants are defined in I</usr/include/linux/magic.h>, "
"and some are hardcoded in kernel sources."
msgstr ""

#.  XXX Keep this list in sync with statvfs(3)
#. type: Plain text
#: man-pages/man2/statfs.2:172
msgid ""
"The I<f_flags> field is a bit mask indicating mount options for the "
"filesystem.  It contains zero or more of the following bits:"
msgstr ""

#. type: TP
#: man-pages/man2/statfs.2:172
#, no-wrap
msgid "B<ST_MANDLOCK>"
msgstr ""

#. type: Plain text
#: man-pages/man2/statfs.2:176
msgid "Mandatory locking is permitted on the filesystem (see B<fcntl>(2))."
msgstr ""

#. type: TP
#: man-pages/man2/statfs.2:176
#, no-wrap
msgid "B<ST_NOATIME>"
msgstr ""

#. type: Plain text
#: man-pages/man2/statfs.2:180
msgid "Do not update access times; see B<mount>(2)."
msgstr ""

#. type: TP
#: man-pages/man2/statfs.2:180
#, no-wrap
msgid "B<ST_NODEV>"
msgstr ""

#. type: Plain text
#: man-pages/man2/statfs.2:183
msgid "Disallow access to device special files on this filesystem."
msgstr ""

#. type: TP
#: man-pages/man2/statfs.2:183
#, no-wrap
msgid "B<ST_NODIRATIME>"
msgstr ""

#. type: Plain text
#: man-pages/man2/statfs.2:187
msgid "Do not update directory access times; see B<mount>(2)."
msgstr ""

#. type: TP
#: man-pages/man2/statfs.2:187
#, no-wrap
msgid "B<ST_NOEXEC>"
msgstr ""

#. type: Plain text
#: man-pages/man2/statfs.2:190
msgid "Execution of programs is disallowed on this filesystem."
msgstr ""

#. type: TP
#: man-pages/man2/statfs.2:190
#, no-wrap
msgid "B<ST_NOSUID>"
msgstr ""

#. type: Plain text
#: man-pages/man2/statfs.2:195
msgid ""
"The set-user-ID and set-group-ID bits are ignored by B<exec>(3)  for "
"executable files on this filesystem"
msgstr ""

#. type: TP
#: man-pages/man2/statfs.2:195
#, no-wrap
msgid "B<ST_RDONLY>"
msgstr ""

#. type: Plain text
#: man-pages/man2/statfs.2:198
msgid "This filesystem is mounted read-only."
msgstr ""

#. type: TP
#: man-pages/man2/statfs.2:198
#, no-wrap
msgid "B<ST_RELATIME>"
msgstr ""

#. type: Plain text
#: man-pages/man2/statfs.2:202
msgid "Update atime relative to mtime/ctime; see B<mount>(2)."
msgstr ""

#. type: TP
#: man-pages/man2/statfs.2:202
#, no-wrap
msgid "B<ST_SYNCHRONOUS>"
msgstr ""

#. type: Plain text
#: man-pages/man2/statfs.2:208
msgid ""
"Writes are synched to the filesystem immediately (see the description of "
"B<O_SYNC> in B<open>(2))."
msgstr ""

#. type: Plain text
#: man-pages/man2/statfs.2:212
msgid "Nobody knows what I<f_fsid> is supposed to contain (but see below)."
msgstr ""

#. type: Plain text
#: man-pages/man2/statfs.2:214
msgid "Fields that are undefined for a particular filesystem are set to 0."
msgstr ""

#. type: Plain text
#: man-pages/man2/statfs.2:218
msgid ""
"B<fstatfs>()  returns the same information about an open file referenced by "
"descriptor I<fd>."
msgstr ""

#. type: Plain text
#: man-pages/man2/statfs.2:231
msgid ""
"(B<statfs>())  Search permission is denied for a component of the path "
"prefix of I<path>.  (See also B<path_resolution>(7).)"
msgstr ""

#. type: Plain text
#: man-pages/man2/statfs.2:236
msgid "(B<fstatfs>())  I<fd> is not a valid open file descriptor."
msgstr ""

#. type: Plain text
#: man-pages/man2/statfs.2:242
msgid "I<buf> or I<path> points to an invalid address."
msgstr ""

#. type: Plain text
#: man-pages/man2/statfs.2:246
msgid "The call was interrupted by a signal; see B<signal>(7)."
msgstr ""

#. type: Plain text
#: man-pages/man2/statfs.2:254
msgid ""
"(B<statfs>())  Too many symbolic links were encountered in translating "
"I<path>."
msgstr ""

#. type: Plain text
#: man-pages/man2/statfs.2:259
msgid "(B<statfs>())  I<path> is too long."
msgstr ""

#. type: Plain text
#: man-pages/man2/statfs.2:265
msgid "(B<statfs>())  The file referred to by I<path> does not exist."
msgstr ""

#. type: Plain text
#: man-pages/man2/statfs.2:271
msgid "The filesystem does not support this call."
msgstr ""

#. type: Plain text
#: man-pages/man2/statfs.2:277
msgid "(B<statfs>())  A component of the path prefix of I<path> is not a directory."
msgstr ""

#. type: Plain text
#: man-pages/man2/statfs.2:280
msgid "Some values were too large to be represented in the returned struct."
msgstr ""

#. type: Plain text
#: man-pages/man2/statfs.2:286
msgid ""
"Linux-specific.  The Linux B<statfs>()  was inspired by the 4.4BSD one (but "
"they do not use the same structure)."
msgstr ""

#. type: Plain text
#: man-pages/man2/statfs.2:298
msgid ""
"The I<__fsword_t> type used for various fields in the I<statfs> structure "
"definition is a glibc internal type, not intended for public use.  This "
"leaves the programmer in a bit of a conundrum when trying to copy or compare "
"these fields to local variables in a program.  Using I<unsigned\\ int> for "
"such variables suffices on most systems."
msgstr ""

#. type: Plain text
#: man-pages/man2/statfs.2:320
msgid ""
"The original Linux B<statfs>()  and B<fstatfs>()  system calls were not "
"designed with extremely large file sizes in mind.  Subsequently, Linux 2.6 "
"added new B<statfs64>()  and B<fstatfs64>()  system calls that employ a new "
"structure, I<statfs64>.  The new structure contains the same fields as the "
"original I<statfs> structure, but the sizes of various fields are increased, "
"to accommodate large file sizes.  The glibc B<statfs>()  and B<fstatfs>()  "
"wrapper functions transparently deal with the kernel differences."
msgstr ""

#. type: Plain text
#: man-pages/man2/statfs.2:325
msgid ""
"Some systems have only I<E<lt>sys/vfs.hE<gt>>, other systems also have "
"I<E<lt>sys/statfs.hE<gt>>, where the former includes the latter.  So it "
"seems including the former is the best choice."
msgstr ""

#. type: Plain text
#: man-pages/man2/statfs.2:335
msgid ""
"LSB has deprecated the library calls B<statfs>()  and B<fstatfs>()  and "
"tells us to use B<statvfs>(2)  and B<fstatvfs>(2)  instead."
msgstr ""

#. type: SS
#: man-pages/man2/statfs.2:335
#, no-wrap
msgid "The f_fsid field"
msgstr ""

#. type: Plain text
#: man-pages/man2/statfs.2:360
msgid ""
"Solaris, Irix and POSIX have a system call B<statvfs>(2)  that returns a "
"I<struct statvfs> (defined in I<E<lt>sys/statvfs.hE<gt>>)  containing an "
"I<unsigned long> I<f_fsid>.  Linux, SunOS, HP-UX, 4.4BSD have a system call "
"B<statfs>()  that returns a I<struct statfs> (defined in "
"I<E<lt>sys/vfs.hE<gt>>)  containing a I<fsid_t> I<f_fsid>, where I<fsid_t> "
"is defined as I<struct { int val[2]; }>.  The same holds for FreeBSD, except "
"that it uses the include file I<E<lt>sys/mount.hE<gt>>."
msgstr ""

#. type: Plain text
#: man-pages/man2/statfs.2:373
msgid ""
"The general idea is that I<f_fsid> contains some random stuff such that the "
"pair (I<f_fsid>,I<ino>)  uniquely determines a file.  Some operating systems "
"use (a variation on) the device number, or the device number combined with "
"the filesystem type.  Several operating systems restrict giving out the "
"I<f_fsid> field to the superuser only (and zero it for unprivileged users), "
"because this field is used in the filehandle of the filesystem when "
"NFS-exported, and giving it out is a security concern."
msgstr ""

#. type: Plain text
#: man-pages/man2/statfs.2:379
msgid ""
"Under some operating systems, the I<fsid> can be used as the second argument "
"to the B<sysfs>(2)  system call."
msgstr ""

#.  broken in commit ff0c7d15f9787b7e8c601533c015295cc68329f8
#.  fixed in commit d70ef97baf048412c395bb5d65791d8fe133a52b
#. type: Plain text
#: man-pages/man2/statfs.2:388
msgid ""
"From Linux 2.6.38 up to and including Linux 3.1, B<fstatfs>()  failed with "
"the error B<ENOSYS> for file descriptors created by B<pipe>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/statfs.2:391
msgid "B<stat>(2), B<statvfs>(3), B<path_resolution>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/sync.2:36
#, no-wrap
msgid "SYNC"
msgstr ""

#. type: Plain text
#: man-pages/man2/sync.2:39
msgid "sync, syncfs - commit filesystem caches to disk"
msgstr ""

#. type: Plain text
#: man-pages/man2/sync.2:43
msgid "B<void sync(void);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/sync.2:45
msgid "B<int syncfs(int >I<fd>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/sync.2:52
msgid "B<sync>():"
msgstr ""

#. type: Plain text
#: man-pages/man2/sync.2:62
msgid "B<syncfs>():"
msgstr ""

#. type: Plain text
#: man-pages/man2/sync.2:71
msgid ""
"B<sync>()  causes all pending modifications to filesystem metadata and "
"cached file data to be written to the underlying filesystems."
msgstr ""

#. type: Plain text
#: man-pages/man2/sync.2:78
msgid ""
"B<syncfs>()  is like B<sync>(), but synchronizes just the filesystem "
"containing file referred to by the open file descriptor I<fd>."
msgstr ""

#. type: Plain text
#: man-pages/man2/sync.2:84
msgid ""
"B<syncfs>()  returns 0 on success; on error, it returns -1 and sets I<errno> "
"to indicate the error."
msgstr ""

#. type: Plain text
#: man-pages/man2/sync.2:87
msgid "B<sync>()  is always successful."
msgstr ""

#. type: Plain text
#: man-pages/man2/sync.2:90
msgid "B<syncfs>()  can fail for at least the following reason:"
msgstr ""

#. type: Plain text
#: man-pages/man2/sync.2:98
msgid ""
"B<syncfs>()  first appeared in Linux 2.6.39; library support was added to "
"glibc in version 2.14."
msgstr ""

#. type: Plain text
#: man-pages/man2/sync.2:101
msgid "B<sync>(): POSIX.1-2001, POSIX.1-2008, SVr4, 4.3BSD."
msgstr ""

#. type: Plain text
#: man-pages/man2/sync.2:104
msgid "B<syncfs>()  is Linux-specific."
msgstr ""

#. type: Plain text
#: man-pages/man2/sync.2:113
msgid ""
"Since glibc 2.2.2, the Linux prototype for B<sync>()  is as listed above, "
"following the various standards.  In glibc 2.2.1 and earlier, it was \"int "
"sync(void)\", and B<sync>()  always returned 0."
msgstr ""

#. type: Plain text
#: man-pages/man2/sync.2:124
msgid ""
"According to the standard specification (e.g., POSIX.1-2001), B<sync>()  "
"schedules the writes, but may return before the actual writing is done.  "
"However Linux waits for I/O completions, and thus B<sync>()  or B<syncfs>()  "
"provide the same guarantees as fsync called on every file in the system or "
"filesystem respectively."
msgstr ""

#. type: Plain text
#: man-pages/man2/sync.2:127
msgid ""
"Before version 1.3.20 Linux did not wait for I/O to complete before "
"returning."
msgstr ""

#. type: Plain text
#: man-pages/man2/sync.2:130
msgid "B<sync>(1), B<fdatasync>(2), B<fsync>(2)"
msgstr ""

#. type: TH
#: man-pages/man2/get_mempolicy.2:27
#, no-wrap
msgid "GET_MEMPOLICY"
msgstr ""

#. type: Plain text
#: man-pages/man2/get_mempolicy.2:30
msgid "get_mempolicy - retrieve NUMA memory policy for a thread"
msgstr ""

#. type: Plain text
#: man-pages/man2/get_mempolicy.2:32
msgid "B<#include E<lt>numaif.hE<gt>>"
msgstr ""

#. type: Plain text
#: man-pages/man2/get_mempolicy.2:37
#, no-wrap
msgid ""
"B<long get_mempolicy(int *>I<mode>B<, unsigned long *>I<nodemask>B<,>\n"
"B<                  unsigned long >I<maxnode>B<, void *>I<addr>B<,>\n"
"B<                  unsigned long >I<flags>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/get_mempolicy.2:45
msgid ""
"B<get_mempolicy>()  retrieves the NUMA policy of the calling thread or of a "
"memory address, depending on the setting of I<flags>."
msgstr ""

#. type: Plain text
#: man-pages/man2/get_mempolicy.2:72
msgid ""
"If I<flags> is specified as 0, then information about the calling thread's "
"default policy (as set by B<set_mempolicy>(2))  is returned, in the buffers "
"pointed to by I<mode> and I<nodemask>.  The value returned in these "
"arguments may be used to restore the thread's policy to its state at the "
"time of the call to B<get_mempolicy>()  using B<set_mempolicy>(2).  When "
"I<flags> is 0, I<addr> must be specified as NULL."
msgstr ""

#. type: Plain text
#: man-pages/man2/get_mempolicy.2:94
msgid ""
"If I<flags> specifies B<MPOL_F_MEMS_ALLOWED> (available since Linux 2.6.24), "
"the I<mode> argument is ignored and the set of nodes (memories) that the "
"thread is allowed to specify in subsequent calls to B<mbind>(2)  or "
"B<set_mempolicy>(2)  (in the absence of any I<mode flags>)  is returned in "
"I<nodemask>.  It is not permitted to combine B<MPOL_F_MEMS_ALLOWED> with "
"either B<MPOL_F_ADDR> or B<MPOL_F_NODE>."
msgstr ""

#. type: Plain text
#: man-pages/man2/get_mempolicy.2:108
msgid ""
"If I<flags> specifies B<MPOL_F_ADDR>, then information is returned about the "
"policy governing the memory address given in I<addr>.  This policy may be "
"different from the thread's default policy if B<mbind>(2)  or one of the "
"helper functions described in B<numa>(3)  has been used to establish a "
"policy for the memory range containing I<addr>."
msgstr ""

#. type: Plain text
#: man-pages/man2/get_mempolicy.2:129
msgid ""
"If the I<mode> argument is not NULL, then B<get_mempolicy>()  will store the "
"policy mode and any optional I<mode flags> of the requested NUMA policy in "
"the location pointed to by this argument.  If I<nodemask> is not NULL, then "
"the nodemask associated with the policy will be stored in the location "
"pointed to by this argument.  I<maxnode> specifies the number of node IDs "
"that can be stored into I<nodemask>\\(emthat is, the maximum node ID plus "
"one.  The value specified by I<maxnode> is always rounded to a multiple of "
"I<sizeof(unsigned\\ long)*8>."
msgstr ""

#. type: Plain text
#: man-pages/man2/get_mempolicy.2:146
msgid ""
"If I<flags> specifies both B<MPOL_F_NODE> and B<MPOL_F_ADDR>, "
"B<get_mempolicy>()  will return the node ID of the node on which the address "
"I<addr> is allocated into the location pointed to by I<mode>.  If no page "
"has yet been allocated for the specified address, B<get_mempolicy>()  will "
"allocate a page as if the thread had performed a read (load) access to that "
"address, and return the ID of the node where that page was allocated."
msgstr ""

#.  Note:  code returns next interleave node via 'mode' argument -Lee Schermerhorn
#. type: Plain text
#: man-pages/man2/get_mempolicy.2:171
msgid ""
"If I<flags> specifies B<MPOL_F_NODE>, but not B<MPOL_F_ADDR>, and the "
"thread's current policy is B<MPOL_INTERLEAVE>, then B<get_mempolicy>()  will "
"return in the location pointed to by a non-NULL I<mode> argument, the node "
"ID of the next node that will be used for interleaving of internal kernel "
"pages allocated on behalf of the thread.  These allocations include pages "
"for memory-mapped files in process memory ranges mapped using the B<mmap>(2)  "
"call with the B<MAP_PRIVATE> flag for read accesses, and in memory ranges "
"mapped with the B<MAP_SHARED> flag for all accesses."
msgstr ""

#. type: Plain text
#: man-pages/man2/get_mempolicy.2:173
msgid "Other flag values are reserved."
msgstr ""

#. type: Plain text
#: man-pages/man2/get_mempolicy.2:176
msgid "For an overview of the possible policies see B<set_mempolicy>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/get_mempolicy.2:183
msgid ""
"On success, B<get_mempolicy>()  returns 0; on error, -1 is returned and "
"I<errno> is set to indicate the error."
msgstr ""

#. type: Plain text
#: man-pages/man2/get_mempolicy.2:235
msgid ""
"The value specified by I<maxnode> is less than the number of node IDs "
"supported by the system.  Or I<flags> specified values other than "
"B<MPOL_F_NODE> or B<MPOL_F_ADDR>; or I<flags> specified B<MPOL_F_ADDR> and "
"I<addr> is NULL, or I<flags> did not specify B<MPOL_F_ADDR> and I<addr> is "
"not NULL.  Or, I<flags> specified B<MPOL_F_NODE> but not B<MPOL_F_ADDR> and "
"the current thread policy is not B<MPOL_INTERLEAVE>.  Or, I<flags> specified "
"B<MPOL_F_MEMS_ALLOWED> with either B<MPOL_F_ADDR> or B<MPOL_F_NODE>.  (And "
"there are other B<EINVAL> cases.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/get_mempolicy.2:239
msgid ""
"The B<get_mempolicy>()  system call was added to the Linux kernel in version "
"2.6.7."
msgstr ""

#. type: Plain text
#: man-pages/man2/get_mempolicy.2:251
msgid ""
"B<getcpu>(2), B<mbind>(2), B<mmap>(2), B<set_mempolicy>(2), B<numa>(3), "
"B<numa>(7), B<numactl>(8)"
msgstr ""

#. type: TH
#: man-pages/man2/adjtimex.2:29
#, no-wrap
msgid "ADJTIMEX"
msgstr ""

#. type: Plain text
#: man-pages/man2/adjtimex.2:32
msgid "adjtimex, ntp_adjtime - tune kernel clock"
msgstr ""

#. type: Plain text
#: man-pages/man2/adjtimex.2:35
#, no-wrap
msgid "B<#include E<lt>sys/timex.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/adjtimex.2:37
#, no-wrap
msgid "B<int adjtimex(struct timex *>I<buf>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/adjtimex.2:39
#, no-wrap
msgid "B<int ntp_adjtime(struct timex *>I<buf>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/adjtimex.2:50
msgid ""
"Linux uses David L.\\& Mills' clock adjustment algorithm (see RFC\\ 5905).  "
"The system call B<adjtimex>()  reads and optionally sets adjustment "
"parameters for this algorithm.  It takes a pointer to a I<timex> structure, "
"updates kernel parameters from (selected) field values, and returns the same "
"structure updated with the current kernel values.  This structure is "
"declared as follows:"
msgstr ""

#. type: Plain text
#: man-pages/man2/adjtimex.2:95
#, no-wrap
msgid ""
"struct timex {\n"
"    int  modes;      /* Mode selector */\n"
"    long offset;     /* Time offset; nanoseconds, if STA_NANO\n"
"                        status flag is set, otherwise\n"
"                        microseconds */\n"
"    long freq;       /* Frequency offset; see NOTES for units */\n"
"    long maxerror;   /* Maximum error (microseconds) */\n"
"    long esterror;   /* Estimated error (microseconds) */\n"
"    int  status;     /* Clock command/status */\n"
"    long constant;   /* PLL (phase-locked loop) time constant */\n"
"    long precision;  /* Clock precision\n"
"                        (microseconds, read-only) */\n"
"    long tolerance;  /* Clock frequency tolerance (read-only);\n"
"                        see NOTES for units */\n"
"    struct timeval time;\n"
"                     /* Current time (read-only, except for\n"
"                        ADJ_SETOFFSET); upon return, time.tv_usec\n"
"                        contains nanoseconds, if STA_NANO status\n"
"                        flag is set, otherwise microseconds */\n"
"    long tick;       /* Microseconds between clock ticks */\n"
"    long ppsfreq;    /* PPS (pulse per second) frequency\n"
"                        (read-only); see NOTES for units */\n"
"    long jitter;     /* PPS jitter (read-only); nanoseconds, if\n"
"                        STA_NANO status flag is set, otherwise\n"
"                        microseconds */\n"
"    int  shift;      /* PPS interval duration\n"
"                        (seconds, read-only) */\n"
"    long stabil;     /* PPS stability (read-only);\n"
"                        see NOTES for units */\n"
"    long jitcnt;     /* PPS count of jitter limit exceeded\n"
"                        events (read-only) */\n"
"    long calcnt;     /* PPS count of calibration intervals\n"
"                        (read-only) */\n"
"    long errcnt;     /* PPS count of calibration errors\n"
"                        (read-only) */\n"
"    long stbcnt;     /* PPS count of stability limit exceeded\n"
"                        events (read-only) */\n"
"    int tai;         /* TAI offset, as set by previous ADJ_TAI\n"
"                        operation (seconds, read-only,\n"
"                        since Linux 2.6.26) */\n"
"    /* Further padding bytes to allow for future expansion */\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/adjtimex.2:108
msgid ""
"The I<modes> field determines which parameters, if any, to set.  (As "
"described later in this page, the constants used for B<ntp_adjtime>()  are "
"equivalent but differently named.)  It is a bit mask containing a "
"bitwise-I<or> combination of zero or more of the following bits:"
msgstr ""

#. type: TP
#: man-pages/man2/adjtimex.2:108
#, no-wrap
msgid "B<ADJ_OFFSET>"
msgstr ""

#.  commit 074b3b87941c99bc0ce35385b5817924b1ed0c23
#. type: Plain text
#: man-pages/man2/adjtimex.2:118
msgid ""
"Set time offset from I<buf.offset>.  Since Linux 2.6.26, the supplied value "
"is clamped to the range (-0.5s, +0.5s).  In older kernels, an B<EINVAL> "
"error occurs if the supplied value is out of range."
msgstr ""

#. type: TP
#: man-pages/man2/adjtimex.2:118
#, no-wrap
msgid "B<ADJ_FREQUENCY>"
msgstr ""

#.  commit 074b3b87941c99bc0ce35385b5817924b1ed0c23
#. type: Plain text
#: man-pages/man2/adjtimex.2:128
msgid ""
"Set frequency offset from I<buf.freq>.  Since Linux 2.6.26, the supplied "
"value is clamped to the range (-32768000, +32768000).  In older kernels, an "
"B<EINVAL> error occurs if the supplied value is out of range."
msgstr ""

#. type: TP
#: man-pages/man2/adjtimex.2:128
#, no-wrap
msgid "B<ADJ_MAXERROR>"
msgstr ""

#. type: Plain text
#: man-pages/man2/adjtimex.2:132
msgid "Set maximum time error from I<buf.maxerror>."
msgstr ""

#. type: TP
#: man-pages/man2/adjtimex.2:132
#, no-wrap
msgid "B<ADJ_ESTERROR>"
msgstr ""

#. type: Plain text
#: man-pages/man2/adjtimex.2:136
msgid "Set estimated time error from I<buf.esterror>."
msgstr ""

#. type: TP
#: man-pages/man2/adjtimex.2:136
#, no-wrap
msgid "B<ADJ_STATUS>"
msgstr ""

#. type: Plain text
#: man-pages/man2/adjtimex.2:141
msgid ""
"Set clock status bits from I<buf.status>.  A description of these bits is "
"provided below."
msgstr ""

#. type: TP
#: man-pages/man2/adjtimex.2:141
#, no-wrap
msgid "B<ADJ_TIMECONST>"
msgstr ""

#. type: Plain text
#: man-pages/man2/adjtimex.2:148
msgid ""
"Set PLL time constant from I<buf.constant>.  If the B<STA_NANO> status flag "
"(see below) is clear, the kernel adds 4 to this value."
msgstr ""

#. type: TP
#: man-pages/man2/adjtimex.2:148
#, no-wrap
msgid "B<ADJ_SETOFFSET> (since Linux 2.6.39)"
msgstr ""

#.  commit 094aa1881fdc1b8889b442eb3511b31f3ec2b762
#.  Author: Richard Cochran <richardcochran@gmail.com>
#. type: Plain text
#: man-pages/man2/adjtimex.2:163
msgid ""
"Add I<buf.time> to the current time.  If I<buf.status> includes the "
"B<ADJ_NANO> flag, then I<buf.time.tv_usec> is interpreted as a nanosecond "
"value; otherwise it is interpreted as microseconds."
msgstr ""

#. type: TP
#: man-pages/man2/adjtimex.2:163
#, no-wrap
msgid "B<ADJ_MICRO> (since Linux 2.6.26)"
msgstr ""

#.  commit eea83d896e318bda54be2d2770d2c5d6668d11db
#.  Author: Roman Zippel <zippel@linux-m68k.org>
#. type: Plain text
#: man-pages/man2/adjtimex.2:168
msgid "Select microsecond resolution."
msgstr ""

#. type: TP
#: man-pages/man2/adjtimex.2:168
#, no-wrap
msgid "B<ADJ_NANO> (since Linux 2.6.26)"
msgstr ""

#.  commit eea83d896e318bda54be2d2770d2c5d6668d11db
#.  Author: Roman Zippel <zippel@linux-m68k.org>
#. type: Plain text
#: man-pages/man2/adjtimex.2:178
msgid ""
"Select nanosecond resolution.  Only one of B<ADJ_MICRO> and B<ADJ_NANO> "
"should be specified."
msgstr ""

#. type: TP
#: man-pages/man2/adjtimex.2:178
#, no-wrap
msgid "B<ADJ_TAI> (since Linux 2.6.26)"
msgstr ""

#.  commit 153b5d054ac2d98ea0d86504884326b6777f683d
#. type: Plain text
#: man-pages/man2/adjtimex.2:183
msgid "Set TAI (Atomic International Time) offset from I<buf.constant>."
msgstr ""

#. type: Plain text
#: man-pages/man2/adjtimex.2:190
msgid ""
"B<ADJ_TAI> should not be used in conjunction with B<ADJ_TIMECONST>, since "
"the latter mode also employs the I<buf.constant> field."
msgstr ""

#. type: Plain text
#: man-pages/man2/adjtimex.2:196
msgid ""
"For a complete explanation of TAI and the difference between TAI and UTC, "
"see E<.UR http://www.bipm.org/en/bipm/tai/tai.html> I<BIPM> E<.UE>"
msgstr ""

#. type: TP
#: man-pages/man2/adjtimex.2:196
#, no-wrap
msgid "B<ADJ_TICK>"
msgstr ""

#. type: Plain text
#: man-pages/man2/adjtimex.2:200
msgid "Set tick value from I<buf.tick>."
msgstr ""

#.  In general, the other bits are ignored, but ADJ_OFFSET_SINGLESHOT 0x8001
#.  ORed with ADJ_NANO (0x2000) gives 0xa0001 == ADJ_OFFSET_SS_READ!!
#. type: Plain text
#: man-pages/man2/adjtimex.2:208
msgid ""
"Alternatively, I<modes> can be specified as either of the following "
"(multibit mask) values, in which case other bits should not be specified in "
"I<modes>:"
msgstr ""

#. type: TP
#: man-pages/man2/adjtimex.2:208
#, no-wrap
msgid "B<ADJ_OFFSET_SINGLESHOT>"
msgstr ""

#.  In user space, ADJ_OFFSET_SINGLESHOT is 0x8001
#.  In kernel space it is 0x0001, and must be ANDed with ADJ_ADJTIME (0x8000)
#. type: Plain text
#: man-pages/man2/adjtimex.2:217
msgid ""
"Old-fashioned B<adjtime>(): (gradually) adjust time by value specified in "
"I<buf.offset>, which specifies an adjustment in microseconds."
msgstr ""

#. type: TP
#: man-pages/man2/adjtimex.2:217
#, no-wrap
msgid "B<ADJ_OFFSET_SS_READ> (functional since Linux 2.6.28)"
msgstr ""

#.  In user space, ADJ_OFFSET_SS_READ is 0xa001
#.  In kernel space there is ADJ_OFFSET_READONLY (0x2000) anded with
#.  ADJ_ADJTIME (0x8000) and ADJ_OFFSET_SINGLESHOT (0x0001) to give 0xa001)
#.  commit 52bfb36050c8529d9031d2c2513b281a360922ec
#.  commit 916c7a855174e3b53d182b97a26b2e27a29726a1
#. type: Plain text
#: man-pages/man2/adjtimex.2:232
msgid ""
"Return (in I<buf.offset>)  the remaining amount of time to be adjusted after "
"an earlier B<ADJ_OFFSET_SINGLESHOT> operation.  This feature was added in "
"Linux 2.6.24, but did not work correctly until Linux 2.6.28."
msgstr ""

#. type: Plain text
#: man-pages/man2/adjtimex.2:238
msgid ""
"Ordinary users are restricted to a value of either 0 or "
"B<ADJ_OFFSET_SS_READ> for I<modes>.  Only the superuser may set any "
"parameters."
msgstr ""

#. type: Plain text
#: man-pages/man2/adjtimex.2:245
msgid ""
"The I<buf.status> field is a bit mask that is used to set and/or retrieve "
"status bits associated with the NTP implementation.  Some bits in the mask "
"are both readable and settable, while others are read-only."
msgstr ""

#. type: TP
#: man-pages/man2/adjtimex.2:245
#, no-wrap
msgid "B<STA_PLL> (read-write)"
msgstr ""

#. type: Plain text
#: man-pages/man2/adjtimex.2:249
msgid "Enable phase-locked loop (PLL) updates via B<ADJ_OFFSET>."
msgstr ""

#. type: TP
#: man-pages/man2/adjtimex.2:249
#, no-wrap
msgid "B<STA_PPSFREQ> (read-write)"
msgstr ""

#. type: Plain text
#: man-pages/man2/adjtimex.2:252
msgid "Enable PPS (pulse-per-second) frequency discipline."
msgstr ""

#. type: TP
#: man-pages/man2/adjtimex.2:252
#, no-wrap
msgid "B<STA_PPSTIME> (read-write)"
msgstr ""

#. type: Plain text
#: man-pages/man2/adjtimex.2:255
msgid "Enable PPS time discipline."
msgstr ""

#. type: TP
#: man-pages/man2/adjtimex.2:255
#, no-wrap
msgid "B<STA_FLL> (read-write)"
msgstr ""

#. type: Plain text
#: man-pages/man2/adjtimex.2:258
msgid "Select frequency-locked loop (FLL) mode."
msgstr ""

#. type: TP
#: man-pages/man2/adjtimex.2:258
#, no-wrap
msgid "B<STA_INS> (read-write)"
msgstr ""

#.  John Stultz;
#.      Usually this is written as extending the day by one second,
#.      which is represented as:
#.         23:59:59
#.         23:59:60
#.         00:00:00
#
#.      But since posix cannot represent 23:59:60, we repeat the last second:
#.         23:59:59 + TIME_INS
#.         23:59:59 + TIME_OOP
#.         00:00:00 + TIME_WAIT
#. type: Plain text
#: man-pages/man2/adjtimex.2:275
msgid ""
"Insert a leap second after the last second of the UTC day, thus extending "
"the last minute of the day by one second.  Leap-second insertion will occur "
"each day, so long as this flag remains set."
msgstr ""

#. type: TP
#: man-pages/man2/adjtimex.2:275
#, no-wrap
msgid "B<STA_DEL> (read-write)"
msgstr ""

#.  John Stultz:
#.      Similarly the progression here is:
#.         23:59:57 + TIME_DEL
#.         23:59:58 + TIME_DEL
#.         00:00:00 + TIME_WAIT
#.  FIXME Does there need to be a statement that it is nonsensical to set
#.  to set both STA_INS and STA_DEL?
#. type: Plain text
#: man-pages/man2/adjtimex.2:287
msgid ""
"Delete a leap second at the last second of the UTC day.  Leap second "
"deletion will occur each day, so long as this flag remains set."
msgstr ""

#. type: TP
#: man-pages/man2/adjtimex.2:287
#, no-wrap
msgid "B<STA_UNSYNC> (read-write)"
msgstr ""

#. type: Plain text
#: man-pages/man2/adjtimex.2:290
msgid "Clock unsynchronized."
msgstr ""

#. type: TP
#: man-pages/man2/adjtimex.2:290
#, no-wrap
msgid "B<STA_FREQHOLD> (read-write)"
msgstr ""

#.  Following text from John Stultz:
#. type: Plain text
#: man-pages/man2/adjtimex.2:300
msgid ""
"Hold frequency.  Normally adjustments made via B<ADJ_OFFSET> result in "
"dampened frequency adjustments also being made.  So a single call corrects "
"the current offset, but as offsets in the same direction are made "
"repeatedly, the small frequency adjustments will accumulate to fix the "
"long-term skew."
msgstr ""

#.  According to the Kernel Application Program Interface document,
#.  STA_FREQHOLD is not used by the NTP version 4 daemon
#. type: Plain text
#: man-pages/man2/adjtimex.2:307
msgid ""
"This flag prevents the small frequency adjustment from being made when "
"correcting for an B<ADJ_OFFSET> value."
msgstr ""

#. type: TP
#: man-pages/man2/adjtimex.2:307
#, no-wrap
msgid "B<STA_PPSSIGNAL> (read-only)"
msgstr ""

#. type: Plain text
#: man-pages/man2/adjtimex.2:310
msgid "A valid PPS (pulse-per-second) signal is present."
msgstr ""

#. type: TP
#: man-pages/man2/adjtimex.2:310
#, no-wrap
msgid "B<STA_PPSJITTER> (read-only)"
msgstr ""

#. type: Plain text
#: man-pages/man2/adjtimex.2:313
msgid "PPS signal jitter exceeded."
msgstr ""

#. type: TP
#: man-pages/man2/adjtimex.2:313
#, no-wrap
msgid "B<STA_PPSWANDER> (read-only)"
msgstr ""

#. type: Plain text
#: man-pages/man2/adjtimex.2:316
msgid "PPS signal wander exceeded."
msgstr ""

#. type: TP
#: man-pages/man2/adjtimex.2:316
#, no-wrap
msgid "B<STA_PPSERROR> (read-only)"
msgstr ""

#. type: Plain text
#: man-pages/man2/adjtimex.2:319
msgid "PPS signal calibration error."
msgstr ""

#. type: TP
#: man-pages/man2/adjtimex.2:319
#, no-wrap
msgid "B<STA_CLOCKERR> (read-only)"
msgstr ""

#.  Not set in current kernel (4.5), but checked in a few places
#. type: Plain text
#: man-pages/man2/adjtimex.2:323
msgid "Clock hardware fault."
msgstr ""

#. type: TP
#: man-pages/man2/adjtimex.2:323
#, no-wrap
msgid "B<STA_NANO> (read-only; since Linux 2.6.26)"
msgstr ""

#.  commit eea83d896e318bda54be2d2770d2c5d6668d11db
#.  Author: Roman Zippel <zippel@linux-m68k.org>
#. type: Plain text
#: man-pages/man2/adjtimex.2:332
msgid ""
"Resolution (0 = microsecond, 1 = nanoseconds).  Set via B<ADJ_NANO>, cleared "
"via B<ADJ_MICRO>."
msgstr ""

#. type: TP
#: man-pages/man2/adjtimex.2:332
#, no-wrap
msgid "B<STA_MODE> (since Linux 2.6.26)"
msgstr ""

#.  commit eea83d896e318bda54be2d2770d2c5d6668d11db
#.  Author: Roman Zippel <zippel@linux-m68k.org>
#. type: Plain text
#: man-pages/man2/adjtimex.2:337
msgid "Mode (0 = Phase Locked Loop, 1 = Frequency Locked Loop)."
msgstr ""

#. type: TP
#: man-pages/man2/adjtimex.2:337
#, no-wrap
msgid "B<STA_CLK> (read-only; since Linux 2.6.26)"
msgstr ""

#.  commit eea83d896e318bda54be2d2770d2c5d6668d11db
#.  Author: Roman Zippel <zippel@linux-m68k.org>
#. type: Plain text
#: man-pages/man2/adjtimex.2:342
msgid "Clock source (0 = A, 1 = B); currently unused."
msgstr ""

#. type: Plain text
#: man-pages/man2/adjtimex.2:347
msgid "Attempts to set read-only I<status> bits are silently ignored."
msgstr ""

#. type: SS
#: man-pages/man2/adjtimex.2:347
#, no-wrap
msgid "ntp_adjtime ()"
msgstr ""

#. type: Plain text
#: man-pages/man2/adjtimex.2:356
msgid ""
"The B<ntp_adjtime>()  library function (described in the NTP \"Kernel "
"Application Program API\", KAPI)  is a more portable interface for "
"performing the same task as B<adjtimex>().  Other than the following points, "
"it is identical to B<adjtime>():"
msgstr ""

#. type: Plain text
#: man-pages/man2/adjtimex.2:363
msgid ""
"The constants used in I<modes> are prefixed with \"MOD_\" rather than "
"\"ADJ_\", and have the same suffixes (thus, B<MOD_OFFSET>, B<MOD_FREQUENCY>, "
"and so on), other than the exceptions noted in the following points."
msgstr ""

#. type: Plain text
#: man-pages/man2/adjtimex.2:367
msgid "B<MOD_CLKA> is the synonym for B<ADJ_OFFSET_SINGLESHOT>."
msgstr ""

#. type: Plain text
#: man-pages/man2/adjtimex.2:371
msgid "B<MOD_CLKB> is the synonym for B<ADJ_TICK>."
msgstr ""

#. type: Plain text
#: man-pages/man2/adjtimex.2:375
msgid ""
"The is no synonym for B<ADJ_OFFSET_SS_READ>, which is not described in the "
"KAPI."
msgstr ""

#. type: Plain text
#: man-pages/man2/adjtimex.2:381
msgid ""
"On success, B<adjtimex>()  and B<ntp_adjtime>()  return the clock state; "
"that is, one of the following values:"
msgstr ""

#. type: TP
#: man-pages/man2/adjtimex.2:381
#, no-wrap
msgid "B<TIME_OK>"
msgstr ""

#. type: Plain text
#: man-pages/man2/adjtimex.2:384
msgid "Clock synchronized, no leap second adjustment pending."
msgstr ""

#. type: TP
#: man-pages/man2/adjtimex.2:384
#, no-wrap
msgid "B<TIME_INS>"
msgstr ""

#. type: Plain text
#: man-pages/man2/adjtimex.2:387
msgid "Indicates that a leap second will be added at the end of the UTC day."
msgstr ""

#. type: TP
#: man-pages/man2/adjtimex.2:387
#, no-wrap
msgid "B<TIME_DEL>"
msgstr ""

#. type: Plain text
#: man-pages/man2/adjtimex.2:390
msgid "Indicates that a leap second will be deleted at the end of the UTC day."
msgstr ""

#. type: TP
#: man-pages/man2/adjtimex.2:390
#, no-wrap
msgid "B<TIME_OOP>"
msgstr ""

#. type: Plain text
#: man-pages/man2/adjtimex.2:393
msgid "Insertion of a leap second is in progress."
msgstr ""

#. type: TP
#: man-pages/man2/adjtimex.2:393
#, no-wrap
msgid "B<TIME_WAIT>"
msgstr ""

#. type: Plain text
#: man-pages/man2/adjtimex.2:403
msgid ""
"A leap-second insertion or deletion has been completed.  This value will be "
"returned until the next B<ADJ_STATUS> operation clears the B<STA_INS> and "
"B<STA_DEL> flags."
msgstr ""

#. type: TP
#: man-pages/man2/adjtimex.2:403
#, no-wrap
msgid "B<TIME_ERROR>"
msgstr ""

#. type: Plain text
#: man-pages/man2/adjtimex.2:407
msgid ""
"The system clock is not synchronized to a reliable server.  This value is "
"returned when any of the following holds true:"
msgstr ""

#. type: Plain text
#: man-pages/man2/adjtimex.2:414
msgid "Either B<STA_UNSYNC> or B<STA_CLOCKERR> is set."
msgstr ""

#. type: Plain text
#: man-pages/man2/adjtimex.2:421
msgid ""
"B<STA_PPSSIGNAL> is clear and either B<STA_PPSFREQ> or B<STA_PPSTIME> is "
"set."
msgstr ""

#. type: Plain text
#: man-pages/man2/adjtimex.2:426
msgid "B<STA_PPSTIME> and B<STA_PPSJITTER> are both set."
msgstr ""

#. type: Plain text
#: man-pages/man2/adjtimex.2:433
msgid ""
"B<STA_PPSFREQ> is set and either B<STA_PPSWANDER> or B<STA_PPSJITTER> is "
"set."
msgstr ""

#. type: Plain text
#: man-pages/man2/adjtimex.2:440
msgid ""
"The symbolic name B<TIME_BAD> is a synonym for B<TIME_ERROR>, provided for "
"backward compatibility."
msgstr ""

#.  commit 6b43ae8a619d17c4935c3320d2ef9e92bdeed05d changed to asynchronous
#.   operation, so we can no longer rely on the return code.
#. type: Plain text
#: man-pages/man2/adjtimex.2:446
msgid ""
"Note that starting with Linux 3.4, the call operates asynchronously and the "
"return value usually will not reflect a state change caused by the call "
"itself."
msgstr ""

#. type: Plain text
#: man-pages/man2/adjtimex.2:449
msgid "On failure, these calls return -1 and set I<errno>."
msgstr ""

#. type: Plain text
#: man-pages/man2/adjtimex.2:454
msgid "I<buf> does not point to writable memory."
msgstr ""

#. type: TP
#: man-pages/man2/adjtimex.2:454 man-pages/man2/adjtimex.2:461
#, no-wrap
msgid "B<EINVAL> (kernels before Linux 2.6.26)"
msgstr ""

#.  From a quick glance, it appears there was no clamping or range check
#.  for buf.freq in kernels before 2.0
#. type: Plain text
#: man-pages/man2/adjtimex.2:461
msgid ""
"An attempt was made to set I<buf.freq> to a value outside the range "
"(-33554432, +33554432)."
msgstr ""

#. type: Plain text
#: man-pages/man2/adjtimex.2:468
msgid ""
"An attempt was made to set I<buf.offset> to a value outside the permitted "
"range.  In kernels before Linux 2.0, the permitted range was (-131072, "
"+131072).  From Linux 2.0 onwards, the permitted range was (-512000, "
"+512000)."
msgstr ""

#. type: Plain text
#: man-pages/man2/adjtimex.2:473
msgid ""
"An attempt was made to set I<buf.status> to a value other than those listed "
"above."
msgstr ""

#. type: Plain text
#: man-pages/man2/adjtimex.2:484
msgid ""
"An attempt was made to set I<buf.tick> to a value outside the range "
"900000/B<HZ> to 1100000/B<HZ>, where B<HZ> is the system timer interrupt "
"frequency."
msgstr ""

#. type: Plain text
#: man-pages/man2/adjtimex.2:493
msgid ""
"I<buf.modes> is neither 0 nor B<ADJ_OFFSET_SS_READ>, and the caller does not "
"have sufficient privilege.  Under Linux, the B<CAP_SYS_TIME> capability is "
"required."
msgstr ""

#. type: tbl table
#: man-pages/man2/adjtimex.2:503
#, no-wrap
msgid "B<ntp_adjtime>()"
msgstr ""

#. type: Plain text
#: man-pages/man2/adjtimex.2:507
msgid "Neither of these interfaces is described in POSIX.1"
msgstr ""

#. type: Plain text
#: man-pages/man2/adjtimex.2:511
msgid ""
"B<adjtimex>()  is Linux-specific and should not be used in programs intended "
"to be portable."
msgstr ""

#. type: Plain text
#: man-pages/man2/adjtimex.2:514
msgid "The preferred API for the NTP daemon is B<ntp_adjtime>()."
msgstr ""

#. type: Plain text
#: man-pages/man2/adjtimex.2:527
msgid ""
"In struct I<timex>, I<freq>, I<ppsfreq>, and I<stabil> are ppm (parts per "
"million) with a 16-bit fractional part, which means that a value of 1 in one "
"of those fields actually means 2^-16 ppm, and 2^16=65536 is 1 ppm.  This is "
"the case for both input values (in the case of I<freq>)  and output values."
msgstr ""

#. type: Plain text
#: man-pages/man2/adjtimex.2:535
msgid ""
"The leap-second processing triggered by B<STA_INS> and B<STA_DEL> is done by "
"the kernel in timer context.  Thus, it will take one tick into the second "
"for the leap second to be inserted or deleted."
msgstr ""

#. type: Plain text
#: man-pages/man2/adjtimex.2:543
msgid ""
"B<settimeofday>(2), B<adjtime>(3), B<ntp_gettime>(3), B<capabilities>(7), "
"B<time>(7), B<adjtimex>(8), B<hwclock>(8)"
msgstr ""

#. type: Plain text
#: man-pages/man2/adjtimex.2:547
msgid ""
"E<.UR "
"http://www.slac.stanford.edu/comp/unix/\\:package/\\:rtems/\\:src/\\:ssrlApps/\\:ntpNanoclock/\\:api.htm> "
"NTP \"Kernel Application Program Interface\" E<.UE>"
msgstr ""

#. type: TH
#: man-pages/man2/migrate_pages.2:18
#, no-wrap
msgid "MIGRATE_PAGES"
msgstr ""

#. type: Plain text
#: man-pages/man2/migrate_pages.2:21
msgid "migrate_pages - move all pages in a process to another set of nodes"
msgstr ""

#. type: Plain text
#: man-pages/man2/migrate_pages.2:28
#, no-wrap
msgid ""
"B<long migrate_pages(int >I<pid>B<, unsigned long >I<maxnode,>\n"
"B<                   const unsigned long *>I<old_nodes,>\n"
"B<                   const unsigned long *>I<new_nodes>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/migrate_pages.2:47
msgid ""
"B<migrate_pages>()  attempts to move all pages of the process I<pid> that "
"are in memory nodes I<old_nodes> to the memory nodes in I<new_nodes>.  Pages "
"not located in any node in I<old_nodes> will not be migrated.  As far as "
"possible, the kernel maintains the relative topology relationship inside "
"I<old_nodes> during the migration to I<new_nodes>."
msgstr ""

#. type: Plain text
#: man-pages/man2/migrate_pages.2:69
msgid ""
"The I<old_nodes> and I<new_nodes> arguments are pointers to bit masks of "
"node numbers, with up to I<maxnode> bits in each mask.  These masks are "
"maintained as arrays of unsigned I<long> integers (in the last I<long> "
"integer, the bits beyond those specified by I<maxnode> are ignored).  The "
"I<maxnode> argument is the maximum node number in the bit mask plus one "
"(this is the same as in B<mbind>(2), but different from B<select>(2))."
msgstr ""

#. type: Plain text
#: man-pages/man2/migrate_pages.2:83
msgid ""
"The I<pid> argument is the ID of the process whose pages are to be moved.  "
"To move pages in another process, the caller must be privileged "
"(B<CAP_SYS_NICE>)  or the real or effective user ID of the calling process "
"must match the real or saved-set user ID of the target process.  If I<pid> "
"is 0, then B<migrate_pages>()  moves pages of the calling process."
msgstr ""

#. type: Plain text
#: man-pages/man2/migrate_pages.2:88
msgid ""
"Pages shared with another process will be moved only if the initiating "
"process has the B<CAP_SYS_NICE> privilege."
msgstr ""

#. type: Plain text
#: man-pages/man2/migrate_pages.2:96
msgid ""
"On success B<migrate_pages>()  returns the number of pages that could not be "
"moved (i.e., a return of zero means that all pages were successfully "
"moved).  On error, it returns -1, and sets I<errno> to indicate the error."
msgstr ""

#. type: Plain text
#: man-pages/man2/migrate_pages.2:104
msgid ""
"Part or all of the memory range specified by I<old_nodes>/I<new_nodes> and "
"I<maxnode> points outside your accessible address space."
msgstr ""

#.  As at 3.5, this limit is "a page worth of bits", e.g.,
#.  8 * 4096 bits, assuming a 4kB page size.
#. type: Plain text
#: man-pages/man2/migrate_pages.2:121
msgid ""
"The value specified by I<maxnode> exceeds a kernel-imposed limit.  Or, "
"I<old_nodes> or I<new_nodes> specifies one or more node IDs that are greater "
"than the maximum supported node ID.  Or, none of the node IDs specified by "
"I<new_nodes> are on-line and allowed by the process's current cpuset "
"context, or none of the specified nodes contain memory."
msgstr ""

#. type: Plain text
#: man-pages/man2/migrate_pages.2:130
msgid ""
"Insufficient privilege (B<CAP_SYS_NICE>)  to move pages of the process "
"specified by I<pid>, or insufficient privilege (B<CAP_SYS_NICE>)  to access "
"the specified target nodes."
msgstr ""

#.  FIXME Document the other errors that can occur for migrate_pages()
#. type: Plain text
#: man-pages/man2/migrate_pages.2:136
msgid "No process matching I<pid> could be found."
msgstr ""

#. type: Plain text
#: man-pages/man2/migrate_pages.2:140
msgid ""
"The B<migrate_pages>()  system call first appeared on Linux in version "
"2.6.16."
msgstr ""

#. type: Plain text
#: man-pages/man2/migrate_pages.2:154
msgid ""
"Use B<get_mempolicy>(2)  with the B<MPOL_F_MEMS_ALLOWED> flag to obtain the "
"set of nodes that are allowed by the calling process's cpuset.  Note that "
"this information is subject to change at any time by manual or automatic "
"reconfiguration of the cpuset."
msgstr ""

#. type: Plain text
#: man-pages/man2/migrate_pages.2:166
msgid ""
"Use of B<migrate_pages>()  may result in pages whose location (node) "
"violates the memory policy established for the specified addresses (see "
"B<mbind>(2))  and/or the specified process (see B<set_mempolicy>(2)).  That "
"is, memory policy does not constrain the destination nodes used by "
"B<migrate_pages>()."
msgstr ""

#. type: Plain text
#: man-pages/man2/migrate_pages.2:184
msgid "I<Documentation/vm/page_migration.rst> in the Linux kernel source tree"
msgstr ""

#. type: TH
#: man-pages/man2/execve.2:37
#, no-wrap
msgid "EXECVE"
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:40
msgid "execve - execute program"
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:44
msgid "B<int execve(const char *>I<pathname>B<, char *const >I<argv>B<[], >"
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:46
msgid "B< char *const >I<envp>B<[]);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:52
msgid ""
"B<execve>()  executes the program referred to by I<pathname>.  This causes "
"the program that is currently being run by the calling process to be "
"replaced with a new program, with newly initialized stack, heap, and "
"(initialized and uninitialized) data segments."
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:55
msgid ""
"I<pathname> must be either a binary executable, or a script starting with a "
"line of the form:"
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:59 man-pages/man2/execve.2:305
#, no-wrap
msgid "B<#!>I<interpreter >[optional-arg]\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:63
msgid "For details of the latter case, see \"Interpreter scripts\" below."
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:72
msgid ""
"I<argv> is an array of argument strings passed to the new program.  By "
"convention, the first of these strings (i.e., I<argv[0]>)  should contain "
"the filename associated with the file being executed.  I<envp> is an array "
"of strings, conventionally of the form B<key=value>, which are passed as "
"environment to the new program.  The I<argv> and I<envp> arrays must each "
"include a null pointer at the end of the array."
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:75
msgid ""
"The argument vector and environment can be accessed by the called program's "
"main function, when it is defined as:"
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:79
#, no-wrap
msgid "int main(int argc, char *argv[], char *envp[])\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:87
msgid ""
"Note, however, that the use of a third argument to the main function is not "
"specified in POSIX.1; according to POSIX.1, the environment should be "
"accessed via the external variable B<environ>(7)."
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:92
msgid ""
"B<execve>()  does not return on success, and the text, initialized data, "
"uninitialized data (bss), and stack of the calling process are overwritten "
"according to the contents of the newly loaded program."
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:96
msgid ""
"If the current program is being ptraced, a B<SIGTRAP> signal is sent to it "
"after a successful B<execve>()."
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:104
msgid ""
"If the set-user-ID bit is set on the program file referred to by "
"I<pathname>, then the effective user ID of the calling process is changed to "
"that of the owner of the program file.  Similarly, when the set-group-ID bit "
"of the program file is set the effective group ID of the calling process is "
"set to the group of the program file."
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:109
msgid ""
"The aforementioned transformations of the effective IDs are I<not> performed "
"(i.e., the set-user-ID and set-group-ID bits are ignored)  if any of the "
"following is true:"
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:114
msgid ""
"the I<no_new_privs> attribute is set for the calling thread (see "
"B<prctl>(2));"
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:122
msgid ""
"the underlying filesystem is mounted I<nosuid> (the B<MS_NOSUID> flag for "
"B<mount>(2)); or"
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:124
msgid "the calling process is being ptraced."
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:128
msgid ""
"The capabilities of the program file (see B<capabilities>(7))  are also "
"ignored if any of the above are true."
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:133
msgid ""
"The effective user ID of the process is copied to the saved set-user-ID; "
"similarly, the effective group ID is copied to the saved set-group-ID.  This "
"copying takes place after any effective ID changes that occur because of the "
"set-user-ID and set-group-ID mode bits."
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:137
msgid ""
"The process's real UID and real GID, as well its supplementary group IDs, "
"are unchanged by a call to B<execve>()."
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:145
msgid ""
"If the executable is an a.out dynamically linked binary executable "
"containing shared-library stubs, the Linux dynamic linker B<ld.so>(8)  is "
"called at the start of execution to bring needed shared objects into memory "
"and link the executable with them."
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:153
msgid ""
"If the executable is a dynamically linked ELF executable, the interpreter "
"named in the PT_INTERP segment is used to load the needed shared objects.  "
"This interpreter is typically I</lib/ld-linux.so.2> for binaries linked with "
"glibc (see B<ld-linux.so>(8))."
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:157
msgid ""
"All process attributes are preserved during an B<execve>(), except the "
"following:"
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:161
msgid ""
"The dispositions of any signals that are being caught are reset to the "
"default (B<signal>(7))."
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:164
msgid "Any alternate signal stack is not preserved (B<sigaltstack>(2))."
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:167
msgid "Memory mappings are not preserved (B<mmap>(2))."
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:170
msgid "Attached System\\ V shared memory segments are detached (B<shmat>(2))."
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:173
msgid "POSIX shared memory regions are unmapped (B<shm_open>(3))."
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:176
msgid "Open POSIX message queue descriptors are closed (B<mq_overview>(7))."
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:179
msgid "Any open POSIX named semaphores are closed (B<sem_overview>(7))."
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:182
msgid "POSIX timers are not preserved (B<timer_create>(2))."
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:185
msgid "Any open directory streams are closed (B<opendir>(3))."
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:189
msgid "Memory locks are not preserved (B<mlock>(2), B<mlockall>(2))."
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:193
msgid "Exit handlers are not preserved (B<atexit>(3), B<on_exit>(3))."
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:196
msgid "The floating-point environment is reset to the default (see B<fenv>(3))."
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:202
msgid ""
"The process attributes in the preceding list are all specified in POSIX.1.  "
"The following Linux-specific process attributes are also not preserved "
"during an B<execve>():"
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:209
msgid ""
"The B<prctl>(2)  B<PR_SET_DUMPABLE> flag is set, unless a set-user-ID or "
"set-group ID program is being executed, in which case it is cleared."
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:214
msgid "The B<prctl>(2)  B<PR_SET_KEEPCAPS> flag is cleared."
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:221
msgid ""
"(Since Linux 2.4.36 / 2.6.23)  If a set-user-ID or set-group-ID program is "
"being executed, then the parent death signal set by B<prctl>(2)  "
"B<PR_SET_PDEATHSIG> flag is cleared."
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:228
msgid ""
"The process name, as set by B<prctl>(2)  B<PR_SET_NAME> (and displayed by "
"I<ps\\ -o comm>), is reset to the name of the new executable file."
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:235
msgid ""
"The B<SECBIT_KEEP_CAPS> I<securebits> flag is cleared.  See "
"B<capabilities>(7)."
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:240
msgid "The termination signal is reset to B<SIGCHLD> (see B<clone>(2))."
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:245
msgid ""
"The file descriptor table is unshared, undoing the effect of the "
"B<CLONE_FILES> flag of B<clone>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:251
msgid ""
"All threads other than the calling thread are destroyed during an "
"B<execve>().  Mutexes, condition variables, and other pthreads objects are "
"not preserved."
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:254
msgid ""
"The equivalent of I<setlocale(LC_ALL, \"C\")> is executed at program "
"start-up."
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:262
msgid ""
"POSIX.1 specifies that the dispositions of any signals that are ignored or "
"set to the default are left unchanged.  POSIX.1 specifies one exception: if "
"B<SIGCHLD> is being ignored, then an implementation may leave the "
"disposition unchanged or reset it to the default; Linux does the former."
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:266
msgid ""
"Any outstanding asynchronous I/O operations are canceled (B<aio_read>(3), "
"B<aio_write>(3))."
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:271
msgid "For the handling of capabilities during B<execve>(), see B<capabilities>(7)."
msgstr ""

#.  On Linux it appears that these file descriptors are
#.  always open after an execve(), and it looks like
#.  Solaris 8 and FreeBSD 6.1 are the same. -- mtk, 30 Apr 2007
#. type: Plain text
#: man-pages/man2/execve.2:298
msgid ""
"By default, file descriptors remain open across an B<execve>().  File "
"descriptors that are marked close-on-exec are closed; see the description of "
"B<FD_CLOEXEC> in B<fcntl>(2).  (If a file descriptor is closed, this will "
"cause the release of all record locks obtained on the underlying file by "
"this process.  See B<fcntl>(2)  for details.)  POSIX.1 says that if file "
"descriptors 0, 1, and 2 would otherwise be closed after a successful "
"B<execve>(), and the process would gain privilege because the set-user-ID or "
"set-group_ID mode bit was set on the executed file, then the system may open "
"an unspecified file for each of these file descriptors.  As a general "
"principle, no portable program, whether privileged or not, can assume that "
"these three file descriptors will remain closed across an B<execve>()."
msgstr ""

#. type: SS
#: man-pages/man2/execve.2:298 man-pages/man2/execve.2:628
#, no-wrap
msgid "Interpreter scripts"
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:301
msgid ""
"An interpreter script is a text file that has execute permission enabled and "
"whose first line is of the form:"
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:311
msgid "The I<interpreter> must be a valid pathname for an executable file."
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:319
msgid ""
"If the I<pathname> argument of B<execve>()  specifies an interpreter script, "
"then I<interpreter> will be invoked with the following arguments:"
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:323
#, no-wrap
msgid "I<interpreter> [optional-arg] I<pathname> arg...\n"
msgstr ""

#.  See the P - preserve-argv[0] option.
#.  Documentation/admin-guide/binfmt-misc.rst
#.  https://www.kernel.org/doc/html/latest/admin-guide/binfmt-misc.html
#. type: Plain text
#: man-pages/man2/execve.2:346
msgid ""
"where I<pathname> is the absolute pathname of the file specified as the "
"first argument of B<execve>(), and I<arg...> is the series of words pointed "
"to by the I<argv> argument of B<execve>(), starting at I<argv>[1].  Note "
"that there is no way to get the I<argv[0]> that was passed to the "
"B<execve>()  call."
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:351
msgid ""
"For portable use, I<optional-arg> should either be absent, or be specified "
"as a single word (i.e., it should not contain white space); see NOTES below."
msgstr ""

#.  commit bf2a9a39639b8b51377905397a5005f444e9a892
#. type: Plain text
#: man-pages/man2/execve.2:358
msgid ""
"Since Linux 2.6.28, the kernel permits the interpreter of a script to itself "
"be a script.  This permission is recursive, up to a limit of four "
"recursions, so that the interpreter may be a script which is interpreted by "
"a script, and so on."
msgstr ""

#. type: SS
#: man-pages/man2/execve.2:358
#, no-wrap
msgid "Limits on size of arguments and environment"
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:371
msgid ""
"Most UNIX implementations impose some limit on the total size of the "
"command-line argument (I<argv>)  and environment (I<envp>)  strings that may "
"be passed to a new program.  POSIX.1 allows an implementation to advertise "
"this limit using the B<ARG_MAX> constant (either defined in "
"I<E<lt>limits.hE<gt>> or available at run time using the call "
"I<sysconf(_SC_ARG_MAX)>)."
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:378
msgid ""
"On Linux prior to kernel 2.6.23, the memory used to store the environment "
"and argument strings was limited to 32 pages (defined by the kernel constant "
"B<MAX_ARG_PAGES>).  On architectures with a 4-kB page size, this yields a "
"maximum size of 128\\ kB."
msgstr ""

#.  For some background on the changes to ARG_MAX in kernels 2.6.23 and
#.  2.6.25, see:
#.      http://sourceware.org/bugzilla/show_bug.cgi?id=5786
#.      http://bugzilla.kernel.org/show_bug.cgi?id=10095
#.      http://thread.gmane.org/gmane.linux.kernel/646709/focus=648101,
#.      checked into 2.6.25 as commit a64e715fc74b1a7dcc5944f848acc38b2c4d4ee2.
#.  Ollie: That doesn't include the lists of pointers, though,
#.  so the actual usage is a bit higher (1 pointer per argument).
#. type: Plain text
#: man-pages/man2/execve.2:418
msgid ""
"On kernel 2.6.23 and later, most architectures support a size limit derived "
"from the soft B<RLIMIT_STACK> resource limit (see B<getrlimit>(2))  that is "
"in force at the time of the B<execve>()  call.  (Architectures with no "
"memory management unit are excepted: they maintain the limit that was in "
"effect before kernel 2.6.23.)  This change allows programs to have a much "
"larger argument and/or environment list.  For these architectures, the total "
"size is limited to 1/4 of the allowed stack size.  (Imposing the 1/4-limit "
"ensures that the new program always has some stack space.)  Additionally, "
"the total size is limited to 3/4 of the value of the kernel constant "
"B<_STK_LIM> (8 Mibibytes).  Since Linux 2.6.25, the kernel also places a "
"floor of 32 pages on this size limit, so that, even when B<RLIMIT_STACK> is "
"set very low, applications are guaranteed to have at least as much argument "
"and environment space as was provided by Linux 2.6.23 and earlier.  (This "
"guarantee was not provided in Linux 2.6.23 and 2.6.24.)  Additionally, the "
"limit per string is 32 pages (the kernel constant B<MAX_ARG_STRLEN>), and "
"the maximum number of strings is 0x7FFFFFFF."
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:424
msgid ""
"On success, B<execve>()  does not return, on error -1 is returned, and "
"I<errno> is set appropriately."
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:432
msgid ""
"The total number of bytes in the environment (I<envp>)  and argument list "
"(I<argv>)  is too large."
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:439
msgid ""
"Search permission is denied on a component of the path prefix of I<pathname> "
"or the name of a script interpreter.  (See also B<path_resolution>(7).)"
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:442
msgid "The file or a script interpreter is not a regular file."
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:445
msgid "Execute permission is denied for the file or a script or ELF interpreter."
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:449
msgid "The filesystem is mounted I<noexec>."
msgstr ""

#. type: TP
#: man-pages/man2/execve.2:449
#, no-wrap
msgid "B<EAGAIN> (since Linux 3.1)"
msgstr ""

#.  commit 72fa59970f8698023045ab0713d66f3f4f96945c
#. type: Plain text
#: man-pages/man2/execve.2:459
msgid ""
"Having changed its real UID using one of the B<set*uid>()  calls, the caller "
"was\\(emand is now still\\(emabove its B<RLIMIT_NPROC> resource limit (see "
"B<setrlimit>(2)).  For a more detailed explanation of this error, see NOTES."
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:467
msgid ""
"I<pathname> or one of the pointers in the vectors I<argv> or I<envp> points "
"outside your accessible address space."
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:471
msgid ""
"An ELF executable had more than one PT_INTERP segment (i.e., tried to name "
"more than one interpreter)."
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:477
msgid "An ELF interpreter was a directory."
msgstr ""

#. type: TP
#: man-pages/man2/execve.2:477
#, no-wrap
msgid "B<ELIBBAD>"
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:480
msgid "An ELF interpreter was not in a recognized format."
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:485
msgid ""
"Too many symbolic links were encountered in resolving I<pathname> or the "
"name of a script or ELF interpreter."
msgstr ""

#.  commit d740269867021faf4ce38a449353d2b986c34a67
#. type: Plain text
#: man-pages/man2/execve.2:493
msgid ""
"The maximum recursion limit was reached during recursive script "
"interpretation (see \"Interpreter scripts\", above).  Before Linux 3.8, the "
"error produced for this case was B<ENOEXEC>."
msgstr ""

#.  FIXME but see http://sourceware.org/bugzilla/show_bug.cgi?id=12241
#. type: Plain text
#: man-pages/man2/execve.2:510
msgid ""
"The file I<pathname> or a script or ELF interpreter does not exist, or a "
"shared library needed for the file or interpreter cannot be found."
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:515
msgid ""
"An executable is not in a recognized format, is for the wrong architecture, "
"or has some other format error that means it cannot be executed."
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:523
msgid ""
"A component of the path prefix of I<pathname> or a script or ELF interpreter "
"is not a directory."
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:529
msgid ""
"The filesystem is mounted I<nosuid>, the user is not the superuser, and the "
"file has the set-user-ID or set-group-ID bit set."
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:533
msgid ""
"The process is being traced, the user is not the superuser and the file has "
"the set-user-ID or set-group-ID bit set."
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:539
msgid ""
"A \"capability-dumb\" applications would not obtain the full set of "
"permitted capabilities granted by the executable file.  See "
"B<capabilities>(7)."
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:542
msgid "The specified executable was open for writing by one or more processes."
msgstr ""

#.  SVr4 documents additional error
#.  conditions EAGAIN, EINTR, ELIBACC, ENOLINK, EMULTIHOP; POSIX does not
#.  document ETXTBSY, EPERM, EFAULT, ELOOP, EIO, ENFILE, EMFILE, EINVAL,
#.  EISDIR or ELIBBAD error conditions.
#. type: Plain text
#: man-pages/man2/execve.2:550
msgid ""
"POSIX.1-2001, POSIX.1-2008, SVr4, 4.3BSD.  POSIX does not document the #! "
"behavior, but it exists (with some variations) on other UNIX systems."
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:566
msgid ""
"One sometimes sees B<execve>()  (and the related functions described in "
"B<exec>(3))  described as \"executing a I<new> process\" (or similar).  This "
"is a highly misleading description: there is no new process; many attributes "
"of the calling process remain unchanged (in particular, its PID).  All that "
"B<execve>()  does is arrange for an existing process (the calling process)  "
"to execute a new program."
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:569
msgid "Set-user-ID and set-group-ID processes can not be B<ptrace>(2)d."
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:580
msgid ""
"The result of mounting a filesystem I<nosuid> varies across Linux kernel "
"versions: some will refuse execution of set-user-ID and set-group-ID "
"executables when this would give the user powers they did not have already "
"(and return B<EPERM>), some will just ignore the set-user-ID and "
"set-group-ID bits and B<exec>()  successfully."
msgstr ""

#.  e.g., EFAULT on Solaris 8 and FreeBSD 6.1; but
#.  HP-UX 11 is like Linux -- mtk, Apr 2007
#.  Bug filed 30 Apr 2007: http://bugzilla.kernel.org/show_bug.cgi?id=8408
#.  Bug rejected (because fix would constitute an ABI change).
#. type: Plain text
#: man-pages/man2/execve.2:602
msgid ""
"On Linux, I<argv> and I<envp> can be specified as NULL.  In both cases, this "
"has the same effect as specifying the argument as a pointer to a list "
"containing a single null pointer.  B<Do not take advantage of this "
"nonstandard and nonportable misfeature!> On many other UNIX systems, "
"specifying I<argv> as NULL will result in an error (B<EFAULT>).  I<Some> "
"other UNIX systems treat the I<envp==NULL> case the same as Linux."
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:613
msgid ""
"POSIX.1 says that values returned by B<sysconf>(3)  should be invariant over "
"the lifetime of a process.  However, since Linux 2.6.23, if the "
"B<RLIMIT_STACK> resource limit changes, then the value reported by "
"B<_SC_ARG_MAX> will also change, to reflect the fact that the limit on space "
"for holding command-line arguments and environment variables has changed."
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:628
msgid ""
"In most cases where B<execve>()  fails, control returns to the original "
"executable image, and the caller of B<execve>()  can then handle the error.  "
"However, in (rare) cases (typically caused by resource exhaustion), failure "
"may occur past the point of no return: the original executable image has "
"been torn down, but the new image could not be completely built.  In such "
"cases, the kernel kills the process with a B<SIGKILL> signal."
msgstr ""

#.  commit 6eb3c3d0a52dca337e327ae8868ca1f44a712e02
#. type: Plain text
#: man-pages/man2/execve.2:636
msgid ""
"The kernel imposes a maximum length on the text that follows the \"#!\" "
"characters at the start of a script; characters beyond the limit are "
"ignored.  Before Linux 5.1, the limit is 127 characters.  Since Linux 5.1, "
"the limit is 255 characters."
msgstr ""

#.  e.g., Solaris 8
#.  e.g., FreeBSD before 6.0, but not FreeBSD 6.0 onward
#. type: Plain text
#: man-pages/man2/execve.2:655
msgid ""
"The semantics of the I<optional-arg> argument of an interpreter script vary "
"across implementations.  On Linux, the entire string following the "
"I<interpreter> name is passed as a single argument to the interpreter, and "
"this string can include white space.  However, behavior differs on some "
"other systems.  Some systems use the first white space to terminate "
"I<optional-arg>.  On some systems, an interpreter script can have multiple "
"arguments, and white spaces in I<optional-arg> are used to delimit the "
"arguments."
msgstr ""

#
#.  .SH BUGS
#.  Some Linux versions have failed to check permissions on ELF
#.  interpreters.  This is a security hole, because it allows users to
#.  open any file, such as a rewinding tape device, for reading.  Some
#.  Linux versions have also had other security holes in
#.  .BR execve ()
#.  that could be exploited for denial of service by a suitably crafted
#.  ELF binary. There are no known problems with 2.0.34 or 2.2.15.
#. type: Plain text
#: man-pages/man2/execve.2:667
msgid ""
"Linux (like most other modern UNIX systems)  ignores the set-user-ID and "
"set-group-ID bits on scripts."
msgstr ""

#. type: SS
#: man-pages/man2/execve.2:667
#, no-wrap
msgid "execve() and EAGAIN"
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:673
msgid ""
"A more detailed explanation of the B<EAGAIN> error that can occur (since "
"Linux 3.1) when calling B<execve>()  is as follows."
msgstr ""

#.  commit 909cc4ae86f3380152a18e2a3c44523893ee11c4
#. type: Plain text
#: man-pages/man2/execve.2:695
msgid ""
"The B<EAGAIN> error can occur when a I<preceding> call to B<setuid>(2), "
"B<setreuid>(2), or B<setresuid>(2)  caused the real user ID of the process "
"to change, and that change caused the process to exceed its B<RLIMIT_NPROC> "
"resource limit (i.e., the number of processes belonging to the new real UID "
"exceeds the resource limit).  From Linux 2.6.0 to 3.0, this caused the "
"B<set*uid>()  call to fail.  (Prior to 2.6, the resource limit was not "
"imposed on processes that changed their user IDs.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:726
msgid ""
"Since Linux 3.1, the scenario just described no longer causes the "
"B<set*uid>()  call to fail, because it too often led to security holes where "
"buggy applications didn't check the return status and assumed that\\(emif "
"the caller had root privileges\\(emthe call would always succeed.  Instead, "
"the B<set*uid>()  calls now successfully change the real UID, but the kernel "
"sets an internal flag, named B<PF_NPROC_EXCEEDED>, to note that the "
"B<RLIMIT_NPROC> resource limit has been exceeded.  If the "
"B<PF_NPROC_EXCEEDED> flag is set and the resource limit is still exceeded at "
"the time of a subsequent B<execve>()  call, that call fails with the error "
"B<EAGAIN>.  This kernel logic ensures that the B<RLIMIT_NPROC> resource "
"limit is still enforced for the common privileged daemon "
"workflow\\(emnamely, B<fork>(2)  + B<set*uid>()  + B<execve>()."
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:742
msgid ""
"If the resource limit was not still exceeded at the time of the B<execve>()  "
"call (because other processes belonging to this real UID terminated between "
"the B<set*uid>()  call and the B<execve>()  call), then the B<execve>()  "
"call succeeds and the kernel clears the B<PF_NPROC_EXCEEDED> process flag.  "
"The flag is also cleared if a subsequent call to B<fork>(2)  by this process "
"succeeds."
msgstr ""

#. type: SS
#: man-pages/man2/execve.2:742 man-pages/man2/times.2:185
#, no-wrap
msgid "Historical"
msgstr ""

#
#.  .SH BUGS
#.  Some Linux versions have failed to check permissions on ELF
#.  interpreters.  This is a security hole, because it allows users to
#.  open any file, such as a rewinding tape device, for reading.  Some
#.  Linux versions have also had other security holes in
#.  .BR execve ()
#.  that could be exploited for denial of service by a suitably crafted
#.  ELF binary. There are no known problems with 2.0.34 or 2.2.15.
#. type: Plain text
#: man-pages/man2/execve.2:762
msgid ""
"With UNIX\\ V6, the argument list of an B<exec>()  call was ended by 0, "
"while the argument list of I<main> was ended by -1.  Thus, this argument "
"list was not directly usable in a further B<exec>()  call.  Since UNIX\\ V7, "
"both are NULL."
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:765
msgid ""
"The following program is designed to be execed by the second program below.  "
"It just echoes its command-line arguments, one per line."
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:769
#, no-wrap
msgid "/* myecho.c */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:772
#, no-wrap
msgid ""
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:777
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int j;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:780
#, no-wrap
msgid ""
"    for (j = 0; j E<lt> argc; j++)\n"
"        printf(\"argv[%d]: %s\\en\", j, argv[j]);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:788
msgid ""
"This program can be used to exec the program named in its command-line "
"argument:"
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:792
#, no-wrap
msgid "/* execve.c */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:796
#, no-wrap
msgid ""
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:802
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    char *newargv[] = { NULL, \"hello\", \"world\", NULL };\n"
"    char *newenviron[] = { NULL };\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:807
#, no-wrap
msgid ""
"    if (argc != 2) {\n"
"        fprintf(stderr, \"Usage: %s E<lt>file-to-execE<gt>\\en\", "
"argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:809
#, no-wrap
msgid "    newargv[0] = argv[1];\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:814
#, no-wrap
msgid ""
"    execve(argv[1], newargv, newenviron);\n"
"    perror(\"execve\");   /* execve() returns only on error */\n"
"    exit(EXIT_FAILURE);\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:818
msgid "We can use the second program to exec the first as follows:"
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:827
#, no-wrap
msgid ""
"$B< cc myecho.c -o myecho>\n"
"$B< cc execve.c -o execve>\n"
"$B< ./execve ./myecho>\n"
"argv[0]: ./myecho\n"
"argv[1]: hello\n"
"argv[2]: world\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:835
msgid ""
"We can also use these programs to demonstrate the use of a script "
"interpreter.  To do this we create a script whose \"interpreter\" is our "
"I<myecho> program:"
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:842
#, no-wrap
msgid ""
"$B< cat E<gt> script>\n"
"B<#!./myecho script-arg>\n"
"B<^D>\n"
"$B< chmod +x script>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:846
msgid "We can then use our program to exec the script:"
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:855
#, no-wrap
msgid ""
"$B< ./execve ./script>\n"
"argv[0]: ./myecho\n"
"argv[1]: script-arg\n"
"argv[2]: ./script\n"
"argv[3]: hello\n"
"argv[4]: world\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:870
msgid ""
"B<chmod>(2), B<execveat>(2), B<fork>(2), B<get_robust_list>(2), "
"B<ptrace>(2), B<exec>(3), B<fexecve>(3), B<getopt>(3), B<system>(3), "
"B<credentials>(7), B<environ>(7), B<path_resolution>(7), B<ld.so>(8)"
msgstr ""

#. type: TH
#: man-pages/man2/fsync.2:38
#, no-wrap
msgid "FSYNC"
msgstr ""

#. type: Plain text
#: man-pages/man2/fsync.2:41
msgid "fsync, fdatasync - synchronize a file's in-core state with storage device"
msgstr ""

#. type: Plain text
#: man-pages/man2/fsync.2:45
msgid "B<int fsync(int >I<fd>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/fsync.2:47
msgid "B<int fdatasync(int >I<fd>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/fsync.2:59
#, no-wrap
msgid ""
"B<fsync>():\n"
"    Glibc 2.16 and later:\n"
"        No feature test macros need be defined\n"
"    Glibc up to and including 2.15:\n"
"        _BSD_SOURCE || _XOPEN_SOURCE\n"
"            || /* since glibc 2.8: */ _POSIX_C_SOURCE\\ E<gt>=\\ 200112L\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/fsync.2:62
#, no-wrap
msgid ""
"B<fdatasync>():\n"
"    _POSIX_C_SOURCE\\ E<gt>=\\ 199309L || _XOPEN_SOURCE\\ E<gt>=\\ 500\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/fsync.2:73
msgid ""
"B<fsync>()  transfers (\"flushes\") all modified in-core data of (i.e., "
"modified buffer cache pages for) the file referred to by the file descriptor "
"I<fd> to the disk device (or other permanent storage device) so that all "
"changed information can be retrieved even if the system crashes or is "
"rebooted.  This includes writing through or flushing a disk cache if "
"present.  The call blocks until the device reports that the transfer has "
"completed."
msgstr ""

#. type: Plain text
#: man-pages/man2/fsync.2:78
msgid ""
"As well as flushing the file data, B<fsync>()  also flushes the metadata "
"information associated with the file (see B<inode>(7))."
msgstr ""

#. type: Plain text
#: man-pages/man2/fsync.2:86
msgid ""
"Calling B<fsync>()  does not necessarily ensure that the entry in the "
"directory containing the file has also reached disk.  For that an explicit "
"B<fsync>()  on a file descriptor for the directory is also needed."
msgstr ""

#. type: Plain text
#: man-pages/man2/fsync.2:107
msgid ""
"B<fdatasync>()  is similar to B<fsync>(), but does not flush modified "
"metadata unless that metadata is needed in order to allow a subsequent data "
"retrieval to be correctly handled.  For example, changes to I<st_atime> or "
"I<st_mtime> (respectively, time of last access and time of last "
"modification; see B<inode>(7))  do not require flushing because they are not "
"necessary for a subsequent data read to be handled correctly.  On the other "
"hand, a change to the file size (I<st_size>, as made by say "
"B<ftruncate>(2)), would require a metadata flush."
msgstr ""

#. type: Plain text
#: man-pages/man2/fsync.2:112
msgid ""
"The aim of B<fdatasync>()  is to reduce disk activity for applications that "
"do not require all metadata to be synchronized with the disk."
msgstr ""

#. type: Plain text
#: man-pages/man2/fsync.2:117
msgid ""
"On success, these system calls return zero.  On error, -1 is returned, and "
"I<errno> is set appropriately."
msgstr ""

#.  commit 088737f44bbf6378745f5b57b035e57ee3dc4750
#. type: Plain text
#: man-pages/man2/fsync.2:136
msgid ""
"An error occurred during synchronization.  This error may relate to data "
"written to some other file descriptor on the same file.  Since Linux 4.13, "
"errors from write-back will be reported to all file descriptors that might "
"have written the data which triggered the error.  Some filesystems (e.g., "
"NFS) keep close track of which data came through which file descriptor, and "
"give more precise reporting.  Other filesystems (e.g., most local "
"filesystems) will report errors to all file descriptors that were open on "
"the file when the error was recorded."
msgstr ""

#. type: Plain text
#: man-pages/man2/fsync.2:139
msgid "Disk space was exhausted while synchronizing."
msgstr ""

#. type: TP
#: man-pages/man2/fsync.2:139
#, no-wrap
msgid "B<EROFS>, B<EINVAL>"
msgstr ""

#. type: Plain text
#: man-pages/man2/fsync.2:144
msgid ""
"I<fd> is bound to a special file (e.g., a pipe, FIFO, or socket)  which does "
"not support synchronization."
msgstr ""

#. type: TP
#: man-pages/man2/fsync.2:144 man-pages/man2/close.2:87
#, no-wrap
msgid "B<ENOSPC>, B<EDQUOT>"
msgstr ""

#. type: Plain text
#: man-pages/man2/fsync.2:152
msgid ""
"I<fd> is bound to a file on NFS or another filesystem which does not "
"allocate space at the time of a B<write>(2)  system call, and some previous "
"write failed due to insufficient storage space."
msgstr ""

#.  POSIX.1-2001: It shall be defined to -1 or 0 or 200112L.
#.  -1: unavailable, 0: ask using sysconf().
#.  glibc defines them to 1.
#. type: Plain text
#: man-pages/man2/fsync.2:167
msgid ""
"On POSIX systems on which B<fdatasync>()  is available, "
"B<_POSIX_SYNCHRONIZED_IO> is defined in I<E<lt>unistd.hE<gt>> to a value "
"greater than 0.  (See also B<sysconf>(3).)"
msgstr ""

#. type: Plain text
#: man-pages/man2/fsync.2:173
msgid ""
"On some UNIX systems (but not Linux), I<fd> must be a I<writable> file "
"descriptor."
msgstr ""

#. type: Plain text
#: man-pages/man2/fsync.2:179
msgid ""
"In Linux 2.2 and earlier, B<fdatasync>()  is equivalent to B<fsync>(), and "
"so has no performance advantage."
msgstr ""

#. type: Plain text
#: man-pages/man2/fsync.2:189
msgid ""
"The B<fsync>()  implementations in older kernels and lesser used filesystems "
"do not know how to flush disk caches.  In these cases disk caches need to be "
"disabled using B<hdparm>(8)  or B<sdparm>(8)  to guarantee safe operation."
msgstr ""

#. type: Plain text
#: man-pages/man2/fsync.2:200
msgid ""
"B<sync>(1), B<bdflush>(2), B<open>(2), B<posix_fadvise>(2), B<pwritev>(2), "
"B<sync>(2), B<sync_file_range>(2), B<fflush>(3), B<fileno>(3), B<hdparm>(8), "
"B<mount>(8)"
msgstr ""

#. type: TH
#: man-pages/man2/sched_setaffinity.2:34
#, no-wrap
msgid "SCHED_SETAFFINITY"
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_setaffinity.2:38
msgid ""
"sched_setaffinity, sched_getaffinity - set and get a thread's CPU affinity "
"mask"
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_setaffinity.2:45
#, no-wrap
msgid ""
"B<int sched_setaffinity(pid_t >I<pid>B<, size_t >I<cpusetsize>B<,>\n"
"B<                      const cpu_set_t *>I<mask>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_setaffinity.2:48
#, no-wrap
msgid ""
"B<int sched_getaffinity(pid_t >I<pid>B<, size_t >I<cpusetsize>B<,>\n"
"B<                      cpu_set_t *>I<mask>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_setaffinity.2:63
msgid ""
"A thread's CPU affinity mask determines the set of CPUs on which it is "
"eligible to run.  On a multiprocessor system, setting the CPU affinity mask "
"can be used to obtain performance benefits.  For example, by dedicating one "
"CPU to a particular thread (i.e., setting the affinity mask of that thread "
"to specify a single CPU, and setting the affinity mask of all other threads "
"to exclude that CPU), it is possible to ensure maximum execution speed for "
"that thread.  Restricting a thread to run on a single CPU also avoids the "
"performance cost caused by the cache invalidation that occurs when a thread "
"ceases to execute on one CPU and then recommences execution on a different "
"CPU."
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_setaffinity.2:70
msgid ""
"A CPU affinity mask is represented by the I<cpu_set_t> structure, a \"CPU "
"set\", pointed to by I<mask>.  A set of macros for manipulating CPU sets is "
"described in B<CPU_SET>(3)."
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_setaffinity.2:85
msgid ""
"B<sched_setaffinity>()  sets the CPU affinity mask of the thread whose ID is "
"I<pid> to the value specified by I<mask>.  If I<pid> is zero, then the "
"calling thread is used.  The argument I<cpusetsize> is the length (in bytes) "
"of the data pointed to by I<mask>.  Normally this argument would be "
"specified as I<sizeof(cpu_set_t)>."
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_setaffinity.2:92
msgid ""
"If the thread specified by I<pid> is not currently running on one of the "
"CPUs specified in I<mask>, then that thread is migrated to one of the CPUs "
"specified in I<mask>."
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_setaffinity.2:107
msgid ""
"B<sched_getaffinity>()  writes the affinity mask of the thread whose ID is "
"I<pid> into the I<cpu_set_t> structure pointed to by I<mask>.  The "
"I<cpusetsize> argument specifies the size (in bytes) of I<mask>.  If I<pid> "
"is zero, then the mask of the calling thread is returned."
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_setaffinity.2:119
msgid ""
"On success, B<sched_setaffinity>()  and B<sched_getaffinity>()  return 0 "
"(but see \"C library/kernel differences\" below, which notes that the "
"underlying B<sched_getaffinity>()  differs in its return value).  On error, "
"-1 is returned, and I<errno> is set appropriately."
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_setaffinity.2:123
msgid "A supplied memory address was invalid."
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_setaffinity.2:133
msgid ""
"The affinity bit mask I<mask> contains no processors that are currently "
"physically on the system and permitted to the thread according to any "
"restrictions that may be imposed by I<cpuset> cgroups or the \"cpuset\" "
"mechanism described in B<cpuset>(7)."
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_setaffinity.2:140
msgid ""
"(B<sched_getaffinity>()  and, in kernels before 2.6.9, "
"B<sched_setaffinity>())  I<cpusetsize> is smaller than the size of the "
"affinity mask used by the kernel."
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_setaffinity.2:151
msgid ""
"(B<sched_setaffinity>())  The calling thread does not have appropriate "
"privileges.  The caller needs an effective user ID equal to the real user ID "
"or effective user ID of the thread identified by I<pid>, or it must possess "
"the B<CAP_SYS_NICE> capability in the user namespace of the thread I<pid>."
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_setaffinity.2:165
msgid ""
"The CPU affinity system calls were introduced in Linux kernel 2.5.8.  The "
"system call wrappers were introduced in glibc 2.3.  Initially, the glibc "
"interfaces included a I<cpusetsize> argument, typed as I<unsigned int>.  In "
"glibc 2.3.3, the I<cpusetsize> argument was removed, but was then restored "
"in glibc 2.3.4, with type I<size_t>."
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_setaffinity.2:180
msgid ""
"After a call to B<sched_setaffinity>(), the set of CPUs on which the thread "
"will actually run is the intersection of the set specified in the I<mask> "
"argument and the set of CPUs actually present on the system.  The system may "
"further restrict the set of CPUs on which the thread runs if the \"cpuset\" "
"mechanism described in B<cpuset>(7)  is being used.  These restrictions on "
"the actual set of CPUs on which the thread will run are silently imposed by "
"the kernel."
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_setaffinity.2:192
msgid ""
"There are various ways of determining the number of CPUs available on the "
"system, including: inspecting the contents of I</proc/cpuinfo>; using "
"B<sysconf>(3)  to obtain the values of the B<_SC_NPROCESSORS_CONF> and "
"B<_SC_NPROCESSORS_ONLN> parameters; and inspecting the list of CPU "
"directories under I</sys/devices/system/cpu/>."
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_setaffinity.2:195
msgid "B<sched>(7)  has a description of the Linux scheduling scheme."
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_setaffinity.2:212
msgid ""
"The affinity mask is a per-thread attribute that can be adjusted "
"independently for each of the threads in a thread group.  The value returned "
"from a call to B<gettid>(2)  can be passed in the argument I<pid>.  "
"Specifying I<pid> as 0 will set the attribute for the calling thread, and "
"passing the value returned from a call to B<getpid>(2)  will set the "
"attribute for the main thread of the thread group.  (If you are using the "
"POSIX threads API, then use B<pthread_setaffinity_np>(3)  instead of "
"B<sched_setaffinity>().)"
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_setaffinity.2:230
msgid ""
"The I<isolcpus> boot option can be used to isolate one or more CPUs at boot "
"time, so that no processes are scheduled onto those CPUs.  Following the use "
"of this boot option, the only way to schedule processes onto the isolated "
"CPUs is via B<sched_setaffinity>()  or the B<cpuset>(7)  mechanism.  For "
"further information, see the kernel source file "
"I<Documentation/admin-guide/kernel-parameters.txt>.  As noted in that file, "
"I<isolcpus> is the preferred mechanism of isolating CPUs (versus the "
"alternative of manually setting the CPU affinity of all processes on the "
"system)."
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_setaffinity.2:236
msgid ""
"A child created via B<fork>(2)  inherits its parent's CPU affinity mask.  "
"The affinity mask is preserved across an B<execve>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_setaffinity.2:244
msgid ""
"This manual page describes the glibc interface for the CPU affinity calls.  "
"The actual system call interface is slightly different, with the I<mask> "
"being typed as I<unsigned long\\ *>, reflecting the fact that the underlying "
"implementation of CPU sets is a simple bit mask."
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_setaffinity.2:256
msgid ""
"On success, the raw B<sched_getaffinity>()  system call returns the number "
"of bytes placed copied into the I<mask> buffer; this will be the minimum of "
"I<cpusetsize> and the size (in bytes) of the I<cpumask_t> data type that is "
"used internally by the kernel to represent the CPU set bit mask."
msgstr ""

#. type: SS
#: man-pages/man2/sched_setaffinity.2:256
#, no-wrap
msgid "Handling systems with large CPU affinity masks"
msgstr ""

#.  FIXME . See https://sourceware.org/bugzilla/show_bug.cgi?id=15630
#.  and https://sourceware.org/ml/libc-alpha/2013-07/msg00288.html
#. type: Plain text
#: man-pages/man2/sched_setaffinity.2:268
msgid ""
"The underlying system calls (which represent CPU masks as bit masks of type "
"I<unsigned long\\ *>)  impose no restriction on the size of the CPU mask.  "
"However, the I<cpu_set_t> data type used by glibc has a fixed size of 128 "
"bytes, meaning that the maximum CPU number that can be represented is 1023.  "
"If the kernel CPU affinity mask is larger than 1024, then calls of the form:"
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_setaffinity.2:270
#, no-wrap
msgid "    sched_getaffinity(pid, sizeof(cpu_set_t), &mask);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_setaffinity.2:280
msgid ""
"fail with the error B<EINVAL>, the error produced by the underlying system "
"call for the case where the I<mask> size specified in I<cpusetsize> is "
"smaller than the size of the affinity mask used by the kernel.  (Depending "
"on the system CPU topology, the kernel affinity mask can be substantially "
"larger than the number of active CPUs in the system.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_setaffinity.2:291
msgid ""
"When working on systems with large kernel CPU affinity masks, one must "
"dynamically allocate the I<mask> argument (see B<CPU_ALLOC>(3)).  Currently, "
"the only way to do this is by probing for the size of the required mask "
"using B<sched_getaffinity>()  calls with increasing mask sizes (until the "
"call does not fail with the error B<EINVAL>)."
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_setaffinity.2:306
msgid ""
"Be aware that B<CPU_ALLOC>(3)  may allocate a slightly larger CPU set than "
"requested (because CPU sets are implemented as bit masks allocated in units "
"of I<sizeof(long)>).  Consequently, B<sched_getaffinity>()  can set bits "
"beyond the requested allocation size, because the kernel sees a few "
"additional bits.  Therefore, the caller should iterate over the bits in the "
"returned set, counting those which are set, and stop upon reaching the value "
"returned by B<CPU_COUNT>(3)  (rather than iterating over the number of bits "
"requested to be allocated)."
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_setaffinity.2:315
msgid ""
"The program below creates a child process.  The parent and child then each "
"assign themselves to a specified CPU and execute identical loops that "
"consume some CPU time.  Before terminating, the parent waits for the child "
"to complete.  The program takes three command-line arguments: the CPU number "
"for the parent, the CPU number for the child, and the number of loop "
"iterations that both processes should perform."
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_setaffinity.2:319
msgid ""
"As the sample runs below demonstrate, the amount of real and CPU time "
"consumed when running the program will depend on intra-core caching effects "
"and whether the processes are using the same CPU."
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_setaffinity.2:324
msgid ""
"We first employ B<lscpu>(1)  to determine that this (x86)  system has two "
"cores, each with two CPUs:"
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_setaffinity.2:331
#, no-wrap
msgid ""
"$ B<lscpu | egrep -i 'core.*:|socket'>\n"
"Thread(s) per core:    2\n"
"Core(s) per socket:    2\n"
"Socket(s):             1\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_setaffinity.2:338
msgid ""
"We then time the operation of the example program for three cases: both "
"processes running on the same CPU; both processes running on different CPUs "
"on the same core; and both processes running on different CPUs on different "
"cores."
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_setaffinity.2:353
#, no-wrap
msgid ""
"$ B<time -p ./a.out 0 0 100000000>\n"
"real 14.75\n"
"user 3.02\n"
"sys 11.73\n"
"$ B<time -p ./a.out 0 1 100000000>\n"
"real 11.52\n"
"user 3.98\n"
"sys 19.06\n"
"$ B<time -p ./a.out 0 3 100000000>\n"
"real 7.89\n"
"user 3.29\n"
"sys 12.07\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_setaffinity.2:364
#, no-wrap
msgid ""
"#define _GNU_SOURCE\n"
"#include E<lt>sched.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>sys/wait.hE<gt>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_setaffinity.2:374
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    cpu_set_t set;\n"
"    int parentCPU, childCPU;\n"
"    int nloops, j;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_setaffinity.2:380
#, no-wrap
msgid ""
"    if (argc != 4) {\n"
"        fprintf(stderr, \"Usage: %s parent-cpu child-cpu num-loops\\en\",\n"
"                argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_setaffinity.2:384
#, no-wrap
msgid ""
"    parentCPU = atoi(argv[1]);\n"
"    childCPU = atoi(argv[2]);\n"
"    nloops = atoi(argv[3]);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_setaffinity.2:386
#, no-wrap
msgid "    CPU_ZERO(&set);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_setaffinity.2:390
#, no-wrap
msgid ""
"    switch (fork()) {\n"
"    case -1:            /* Error */\n"
"        errExit(\"fork\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_setaffinity.2:393
#, no-wrap
msgid ""
"    case 0:             /* Child */\n"
"        CPU_SET(childCPU, &set);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_setaffinity.2:396
#: man-pages/man2/sched_setaffinity.2:407
#, no-wrap
msgid ""
"        if (sched_setaffinity(getpid(), sizeof(set), &set) == -1)\n"
"            errExit(\"sched_setaffinity\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_setaffinity.2:399
#: man-pages/man2/sched_setaffinity.2:410
#, no-wrap
msgid ""
"        for (j = 0; j E<lt> nloops; j++)\n"
"            getppid();\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_setaffinity.2:404
#, no-wrap
msgid ""
"    default:            /* Parent */\n"
"        CPU_SET(parentCPU, &set);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_setaffinity.2:415
#, no-wrap
msgid ""
"        wait(NULL);     /* Wait for child to terminate */\n"
"        exit(EXIT_SUCCESS);\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_setaffinity.2:439
msgid ""
"B<lscpu>(1), B<nproc>(1), B<taskset>(1), B<clone>(2), B<getcpu>(2), "
"B<getpriority>(2), B<gettid>(2), B<nice>(2), B<sched_get_priority_max>(2), "
"B<sched_get_priority_min>(2), B<sched_getscheduler>(2), "
"B<sched_setscheduler>(2), B<setpriority>(2), B<CPU_SET>(3), "
"B<get_nprocs>(3), B<pthread_setaffinity_np>(3), B<sched_getcpu>(3), "
"B<capabilities>(7), B<cpuset>(7), B<sched>(7), B<numactl>(8)"
msgstr ""

#. type: TH
#: man-pages/man2/reboot.2:28
#, no-wrap
msgid "REBOOT"
msgstr ""

#. type: Plain text
#: man-pages/man2/reboot.2:31
msgid "reboot - reboot or enable/disable Ctrl-Alt-Del"
msgstr ""

#. type: Plain text
#: man-pages/man2/reboot.2:34
#, no-wrap
msgid ""
"/* Since kernel version 2.1.30 there are symbolic names LINUX_REBOOT_*\n"
"   for the constants and a fourth argument to the call: */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/reboot.2:38
msgid "B<#include E<lt>linux/reboot.hE<gt>>"
msgstr ""

#. type: Plain text
#: man-pages/man2/reboot.2:40
msgid ""
"B<int reboot(int >I<magic>B<, int >I<magic2>B<, int >I<cmd>B<, void "
"*>I<arg>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/reboot.2:45
#, no-wrap
msgid ""
"/* Under glibc and most alternative libc's (including uclibc, dietlibc,\n"
"   musl and a few others), some of the constants involved have gotten\n"
"   symbolic names RB_*, and the library call is a 1-argument\n"
"   wrapper around the system call: */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/reboot.2:49
msgid "B<#include E<lt>sys/reboot.hE<gt>>"
msgstr ""

#. type: Plain text
#: man-pages/man2/reboot.2:51
msgid "B<int reboot(int >I<cmd>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/reboot.2:58
msgid ""
"The B<reboot>()  call reboots the system, or enables/disables the reboot "
"keystroke (abbreviated CAD, since the default is Ctrl-Alt-Delete; it can be "
"changed using B<loadkeys>(1))."
msgstr ""

#. type: Plain text
#: man-pages/man2/reboot.2:82
msgid ""
"This system call fails (with the error B<EINVAL>)  unless I<magic> equals "
"B<LINUX_REBOOT_MAGIC1> (that is, 0xfee1dead) and I<magic2> equals "
"B<LINUX_REBOOT_MAGIC2> (that is, 672274793).  However, since 2.1.17 also "
"B<LINUX_REBOOT_MAGIC2A> (that is, 85072278)  and since 2.1.97 also "
"B<LINUX_REBOOT_MAGIC2B> (that is, 369367448)  and since 2.5.71 also "
"B<LINUX_REBOOT_MAGIC2C> (that is, 537993216)  are permitted as values for "
"I<magic2>.  (The hexadecimal values of these constants are meaningful.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/reboot.2:86
msgid "The I<cmd> argument can have the following values:"
msgstr ""

#. type: TP
#: man-pages/man2/reboot.2:86
#, no-wrap
msgid "B<LINUX_REBOOT_CMD_CAD_OFF>"
msgstr ""

#. type: Plain text
#: man-pages/man2/reboot.2:96
msgid ""
"(B<RB_DISABLE_CAD>, 0).  CAD is disabled.  This means that the CAD keystroke "
"will cause a B<SIGINT> signal to be sent to init (process 1), whereupon this "
"process may decide upon a proper action (maybe: kill all processes, sync, "
"reboot)."
msgstr ""

#. type: TP
#: man-pages/man2/reboot.2:96
#, no-wrap
msgid "B<LINUX_REBOOT_CMD_CAD_ON>"
msgstr ""

#. type: Plain text
#: man-pages/man2/reboot.2:104
msgid ""
"(B<RB_ENABLE_CAD>, 0x89abcdef).  CAD is enabled.  This means that the CAD "
"keystroke will immediately cause the action associated with "
"B<LINUX_REBOOT_CMD_RESTART>."
msgstr ""

#. type: TP
#: man-pages/man2/reboot.2:104
#, no-wrap
msgid "B<LINUX_REBOOT_CMD_HALT>"
msgstr ""

#. type: Plain text
#: man-pages/man2/reboot.2:113
msgid ""
"(B<RB_HALT_SYSTEM>, 0xcdef0123; since Linux 1.1.76).  The message \"System "
"halted.\" is printed, and the system is halted.  Control is given to the ROM "
"monitor, if there is one.  If not preceded by a B<sync>(2), data will be "
"lost."
msgstr ""

#. type: TP
#: man-pages/man2/reboot.2:113
#, no-wrap
msgid "B<LINUX_REBOOT_CMD_KEXEC>"
msgstr ""

#. type: Plain text
#: man-pages/man2/reboot.2:121
msgid ""
"(B<RB_KEXEC>, 0x45584543, since Linux 2.6.13).  Execute a kernel that has "
"been loaded earlier with B<kexec_load>(2).  This option is available only if "
"the kernel was configured with B<CONFIG_KEXEC>."
msgstr ""

#. type: TP
#: man-pages/man2/reboot.2:121
#, no-wrap
msgid "B<LINUX_REBOOT_CMD_POWER_OFF>"
msgstr ""

#. type: Plain text
#: man-pages/man2/reboot.2:130
msgid ""
"(B<RB_POWER_OFF>, 0x4321fedc; since Linux 2.1.30).  The message \"Power "
"down.\" is printed, the system is stopped, and all power is removed from the "
"system, if possible.  If not preceded by a B<sync>(2), data will be lost."
msgstr ""

#. type: TP
#: man-pages/man2/reboot.2:130
#, no-wrap
msgid "B<LINUX_REBOOT_CMD_RESTART>"
msgstr ""

#. type: Plain text
#: man-pages/man2/reboot.2:139
msgid ""
"(B<RB_AUTOBOOT>, 0x1234567).  The message \"Restarting system.\" is printed, "
"and a default restart is performed immediately.  If not preceded by a "
"B<sync>(2), data will be lost."
msgstr ""

#. type: TP
#: man-pages/man2/reboot.2:139
#, no-wrap
msgid "B<LINUX_REBOOT_CMD_RESTART2>"
msgstr ""

#. type: Plain text
#: man-pages/man2/reboot.2:149
msgid ""
"(0xa1b2c3d4; since Linux 2.1.30).  The message \"Restarting system with "
"command \\(aq%s\\(aq\" is printed, and a restart (using the command string "
"given in I<arg>)  is performed immediately.  If not preceded by a "
"B<sync>(2), data will be lost."
msgstr ""

#. type: TP
#: man-pages/man2/reboot.2:149
#, no-wrap
msgid "B<LINUX_REBOOT_CMD_SW_SUSPEND>"
msgstr ""

#. type: Plain text
#: man-pages/man2/reboot.2:156
msgid ""
"(B<RB_SW_SUSPEND>, 0xd000fce1; since Linux 2.5.18).  The system is suspended "
"(hibernated) to disk.  This option is available only if the kernel was "
"configured with B<CONFIG_HIBERNATION>."
msgstr ""

#. type: Plain text
#: man-pages/man2/reboot.2:159
msgid "Only the superuser may call B<reboot>()."
msgstr ""

#. type: Plain text
#: man-pages/man2/reboot.2:166
msgid ""
"The precise effect of the above actions depends on the architecture.  For "
"the i386 architecture, the additional argument does not do anything at "
"present (2.1.122), but the type of reboot can be determined by kernel "
"command-line arguments (\"reboot=...\") to be either warm or cold, and "
"either hard or through the BIOS."
msgstr ""

#. type: SS
#: man-pages/man2/reboot.2:166
#, no-wrap
msgid "Behavior inside PID namespaces"
msgstr ""

#.  commit cf3f89214ef6a33fad60856bc5ffd7bb2fc4709b
#.  see also commit 923c7538236564c46ee80c253a416705321f13e3
#. type: Plain text
#: man-pages/man2/reboot.2:181
msgid ""
"Since Linux 3.4, if B<reboot>()  is called from a PID namespace other than "
"the initial PID namespace with one of the I<cmd> values listed below, it "
"performs a \"reboot\" of that namespace: the \"init\" process of the PID "
"namespace is immediately terminated, with the effects described in "
"B<pid_namespaces>(7)."
msgstr ""

#. type: Plain text
#: man-pages/man2/reboot.2:187
msgid ""
"The values that can be supplied in I<cmd> when calling B<reboot>()  in this "
"case are as follows:"
msgstr ""

#. type: TP
#: man-pages/man2/reboot.2:187
#, no-wrap
msgid "B<LINUX_REBOOT_CMD_RESTART>, B<LINUX_REBOOT_CMD_RESTART2>"
msgstr ""

#. type: Plain text
#: man-pages/man2/reboot.2:195
msgid ""
"The \"init\" process is terminated, and B<wait>(2)  in the parent process "
"reports that the child was killed with a B<SIGHUP> signal."
msgstr ""

#. type: TP
#: man-pages/man2/reboot.2:195
#, no-wrap
msgid "B<LINUX_REBOOT_CMD_POWER_OFF>, B<LINUX_REBOOT_CMD_HALT>"
msgstr ""

#. type: Plain text
#: man-pages/man2/reboot.2:203
msgid ""
"The \"init\" process is terminated, and B<wait>(2)  in the parent process "
"reports that the child was killed with a B<SIGINT> signal."
msgstr ""

#. type: Plain text
#: man-pages/man2/reboot.2:212
msgid ""
"For the other I<cmd> values, B<reboot>()  returns -1 and I<errno> is set to "
"B<EINVAL>."
msgstr ""

#. type: Plain text
#: man-pages/man2/reboot.2:225
msgid ""
"For the values of I<cmd> that stop or restart the system, a successful call "
"to B<reboot>()  does not return.  For the other I<cmd> values, zero is "
"returned on success.  In all cases, -1 is returned on failure, and I<errno> "
"is set appropriately."
msgstr ""

#. type: Plain text
#: man-pages/man2/reboot.2:230
msgid "Problem with getting user-space data under B<LINUX_REBOOT_CMD_RESTART2>."
msgstr ""

#. type: Plain text
#: man-pages/man2/reboot.2:233
msgid "Bad magic numbers or I<cmd>."
msgstr ""

#. type: Plain text
#: man-pages/man2/reboot.2:240
msgid ""
"The calling process has insufficient privilege to call B<reboot>(); the "
"caller must have the B<CAP_SYS_BOOT> inside its user namespace."
msgstr ""

#. type: Plain text
#: man-pages/man2/reboot.2:244
msgid ""
"B<reboot>()  is Linux-specific, and should not be used in programs intended "
"to be portable."
msgstr ""

#. type: Plain text
#: man-pages/man2/reboot.2:253
msgid ""
"B<systemctl>(1), B<systemd>(1), B<kexec_load>(2), B<sync>(2), "
"B<bootparam>(7), B<capabilities>(7), B<ctrlaltdel>(8), B<halt>(8), "
"B<shutdown>(8)"
msgstr ""

#. type: TH
#: man-pages/man2/read.2:35
#, no-wrap
msgid "READ"
msgstr ""

#. type: TH
#: man-pages/man2/read.2:35 man-pages/man2/mlock.2:26
#, no-wrap
msgid "2018-02-02"
msgstr ""

#. type: Plain text
#: man-pages/man2/read.2:38
msgid "read - read from a file descriptor"
msgstr ""

#. type: Plain text
#: man-pages/man2/read.2:43
#, no-wrap
msgid "B<ssize_t read(int >I<fd>B<, void *>I<buf>B<, size_t >I<count>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/read.2:52
msgid ""
"B<read>()  attempts to read up to I<count> bytes from file descriptor I<fd> "
"into the buffer starting at I<buf>."
msgstr ""

#. type: Plain text
#: man-pages/man2/read.2:60
msgid ""
"On files that support seeking, the read operation commences at the file "
"offset, and the file offset is incremented by the number of bytes read.  If "
"the file offset is at or past the end of file, no bytes are read, and "
"B<read>()  returns zero."
msgstr ""

#. type: Plain text
#: man-pages/man2/read.2:75
msgid ""
"If I<count> is zero, B<read>()  I<may> detect the errors described below.  "
"In the absence of any errors, or if B<read>()  does not check for errors, a "
"B<read>()  with a I<count> of 0 returns zero and has no other effects."
msgstr ""

#. type: Plain text
#: man-pages/man2/read.2:92
msgid ""
"On success, the number of bytes read is returned (zero indicates end of "
"file), and the file position is advanced by this number.  It is not an error "
"if this number is smaller than the number of bytes requested; this may "
"happen for example because fewer bytes are actually available right now "
"(maybe because we were close to end-of-file, or because we are reading from "
"a pipe, or from a terminal), or because B<read>()  was interrupted by a "
"signal.  See also NOTES."
msgstr ""

#. type: Plain text
#: man-pages/man2/read.2:98
msgid ""
"On error, -1 is returned, and I<errno> is set appropriately.  In this case, "
"it is left unspecified whether the file position (if any) changes."
msgstr ""

#. type: Plain text
#: man-pages/man2/read.2:111
msgid ""
"The file descriptor I<fd> refers to a file other than a socket and has been "
"marked nonblocking (B<O_NONBLOCK>), and the read would block.  See "
"B<open>(2)  for further details on the B<O_NONBLOCK> flag."
msgstr ""

#.  Actually EAGAIN on Linux
#. type: Plain text
#: man-pages/man2/read.2:122
msgid ""
"The file descriptor I<fd> refers to a socket and has been marked nonblocking "
"(B<O_NONBLOCK>), and the read would block.  POSIX.1-2001 allows either error "
"to be returned for this case, and does not require these constants to have "
"the same value, so a portable application should check for both "
"possibilities."
msgstr ""

#. type: Plain text
#: man-pages/man2/read.2:134
msgid ""
"The call was interrupted by a signal before any data was read; see "
"B<signal>(7)."
msgstr ""

#. type: Plain text
#: man-pages/man2/read.2:145
msgid ""
"I<fd> is attached to an object which is unsuitable for reading; or the file "
"was opened with the B<O_DIRECT> flag, and either the address specified in "
"I<buf>, the value specified in I<count>, or the file offset is not suitably "
"aligned."
msgstr ""

#. type: Plain text
#: man-pages/man2/read.2:155
msgid ""
"I<fd> was created via a call to B<timerfd_create>(2)  and the wrong size "
"buffer was given to B<read>(); see B<timerfd_create>(2)  for further "
"information."
msgstr ""

#. type: Plain text
#: man-pages/man2/read.2:175
msgid ""
"I/O error.  This will happen for example when the process is in a background "
"process group, tries to read from its controlling terminal, and either it is "
"ignoring or blocking B<SIGTTIN> or its process group is orphaned.  It may "
"also occur when there is a low-level I/O error while reading from a disk or "
"tape.  A further possible cause of B<EIO> on networked filesystems is when "
"an advisory lock had been taken out on the file descriptor and this lock has "
"been lost.  See the I<Lost locks> section of B<fcntl>(2)  for further "
"details."
msgstr ""

#. type: Plain text
#: man-pages/man2/read.2:179
msgid "I<fd> refers to a directory."
msgstr ""

#.  commit e28cc71572da38a5a12c1cfe4d7032017adccf69
#. type: Plain text
#: man-pages/man2/read.2:199
msgid ""
"On Linux, B<read>()  (and similar system calls) will transfer at most "
"0x7ffff000 (2,147,479,552) bytes, returning the number of bytes actually "
"transferred.  (This is true on both 32-bit and 64-bit systems.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/read.2:215
msgid ""
"On NFS filesystems, reading small amounts of data will update the timestamp "
"only the first time, subsequent calls may not do so.  This is caused by "
"client side attribute caching, because most if not all NFS clients leave "
"I<st_atime> (last file access time)  updates to the server, and client side "
"reads satisfied from the client's cache will not cause I<st_atime> updates "
"on the server as there are no server-side reads.  UNIX semantics can be "
"obtained by disabling client-side attribute caching, but in most situations "
"this will substantially increase server load and decrease performance."
msgstr ""

#.  http://thread.gmane.org/gmane.linux.kernel/1649458
#.     From: Michael Kerrisk (man-pages <mtk.manpages <at> gmail.com>
#.     Subject: Update of file offset on write() etc. is non-atomic with I/O
#.     Date: 2014-02-17 15:41:37 GMT
#.     Newsgroups: gmane.linux.kernel, gmane.linux.file-systems
#.  commit 9c225f2655e36a470c4f58dbbc99244c5fc7f2d4
#.     Author: Linus Torvalds <torvalds@linux-foundation.org>
#.     Date:   Mon Mar 3 09:36:58 2014 -0800
#
#.         vfs: atomic f_pos accesses as per POSIX
#. type: Plain text
#: man-pages/man2/read.2:254
msgid ""
"Among the APIs subsequently listed are B<read>()  and B<readv>(2).  And "
"among the effects that should be atomic across threads (and processes)  are "
"updates of the file offset.  However, on Linux before version 3.14, this was "
"not the case: if two processes that share an open file description (see "
"B<open>(2))  perform a B<read>()  (or B<readv>(2))  at the same time, then "
"the I/O operations were not atomic with respect updating the file offset, "
"with the result that the reads in the two processes might (incorrectly) "
"overlap in the blocks of data that they obtained.  This problem was fixed in "
"Linux 3.14."
msgstr ""

#. type: Plain text
#: man-pages/man2/read.2:266
msgid ""
"B<close>(2), B<fcntl>(2), B<ioctl>(2), B<lseek>(2), B<open>(2), B<pread>(2), "
"B<readdir>(2), B<readlink>(2), B<readv>(2), B<select>(2), B<write>(2), "
"B<fread>(3)"
msgstr ""

#. type: TH
#: man-pages/man2/sigaltstack.2:27
#, no-wrap
msgid "SIGALTSTACK"
msgstr ""

#. type: TH
#: man-pages/man2/sigaltstack.2:27
#, no-wrap
msgid "2017-11-08"
msgstr ""

#. type: Plain text
#: man-pages/man2/sigaltstack.2:30
msgid "sigaltstack - set and/or get signal stack context"
msgstr ""

#. type: Plain text
#: man-pages/man2/sigaltstack.2:34
msgid "B<int sigaltstack(const stack_t *>I<ss>B<, stack_t *>I<old_ss>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/sigaltstack.2:41
msgid "B<sigaltstack>():"
msgstr ""

#.     || _XOPEN_SOURCE\ &&\ _XOPEN_SOURCE_EXTENDED
#. type: Plain text
#: man-pages/man2/sigaltstack.2:48
#, no-wrap
msgid ""
"_XOPEN_SOURCE\\ E<gt>=\\ 500\n"
"    || /* Since glibc 2.12: */ _POSIX_C_SOURCE\\ E<gt>=\\ 200809L\n"
"    || /* Glibc versions E<lt>= 2.19: */ _BSD_SOURCE\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/sigaltstack.2:60
msgid ""
"B<sigaltstack>()  allows a process to define a new alternate signal stack "
"and/or retrieve the state of an existing alternate signal stack.  An "
"alternate signal stack is used during the execution of a signal handler if "
"the establishment of that handler (see B<sigaction>(2))  requested it."
msgstr ""

#. type: Plain text
#: man-pages/man2/sigaltstack.2:63
msgid ""
"The normal sequence of events for using an alternate signal stack is the "
"following:"
msgstr ""

#. type: Plain text
#: man-pages/man2/sigaltstack.2:67
msgid "Allocate an area of memory to be used for the alternate signal stack."
msgstr ""

#. type: Plain text
#: man-pages/man2/sigaltstack.2:73
msgid ""
"Use B<sigaltstack>()  to inform the system of the existence and location of "
"the alternate signal stack."
msgstr ""

#. type: Plain text
#: man-pages/man2/sigaltstack.2:80
msgid ""
"When establishing a signal handler using B<sigaction>(2), inform the system "
"that the signal handler should be executed on the alternate signal stack by "
"specifying the B<SA_ONSTACK> flag."
msgstr ""

#. type: Plain text
#: man-pages/man2/sigaltstack.2:87
msgid ""
"The I<ss> argument is used to specify a new alternate signal stack, while "
"the I<old_ss> argument is used to retrieve information about the currently "
"established signal stack.  If we are interested in performing just one of "
"these tasks, then the other argument can be specified as NULL."
msgstr ""

#. type: Plain text
#: man-pages/man2/sigaltstack.2:91
msgid ""
"The I<stack_t> type used to type the arguments of this function is defined "
"as follows:"
msgstr ""

#. type: Plain text
#: man-pages/man2/sigaltstack.2:99
#, no-wrap
msgid ""
"typedef struct {\n"
"    void  *ss_sp;     /* Base address of stack */\n"
"    int    ss_flags;  /* Flags */\n"
"    size_t ss_size;   /* Number of bytes in stack */\n"
"} stack_t;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/sigaltstack.2:104
msgid ""
"To establish a new alternate signal stack, the fields of this structure are "
"set as follows:"
msgstr ""

#. type: TP
#: man-pages/man2/sigaltstack.2:104
#, no-wrap
msgid "I<ss.ss_flags>"
msgstr ""

#. type: Plain text
#: man-pages/man2/sigaltstack.2:107
msgid "This field contains either 0, or the following flag:"
msgstr ""

#. type: TP
#: man-pages/man2/sigaltstack.2:108
#, no-wrap
msgid "B<SS_AUTODISARM> (since Linux 4.7)"
msgstr ""

#.  commit 2a74213838104a41588d86fd5e8d344972891ace
#.  See tools/testing/selftests/sigaltstack/sas.c in kernel sources
#. type: Plain text
#: man-pages/man2/sigaltstack.2:115
msgid ""
"Clear the alternate signal stack settings on entry to the signal handler.  "
"When the signal handler returns, the previous alternate signal stack "
"settings are restored."
msgstr ""

#. type: Plain text
#: man-pages/man2/sigaltstack.2:126
msgid ""
"This flag was added in order make it safe to switch away from the signal "
"handler with B<swapcontext>(3).  Without this flag, a subsequently handled "
"signal will corrupt the state of the switched-away signal handler.  On "
"kernels where this flag is not supported, B<sigaltstack>()  fails with the "
"error B<EINVAL> when this flag is supplied."
msgstr ""

#. type: TP
#: man-pages/man2/sigaltstack.2:127
#, no-wrap
msgid "I<ss.ss_sp>"
msgstr ""

#. type: Plain text
#: man-pages/man2/sigaltstack.2:133
msgid ""
"This field specifies the starting address of the stack.  When a signal "
"handler is invoked on the alternate stack, the kernel automatically aligns "
"the address given in I<ss.ss_sp> to a suitable address boundary for the "
"underlying hardware architecture."
msgstr ""

#. type: TP
#: man-pages/man2/sigaltstack.2:133
#, no-wrap
msgid "I<ss.ss_size>"
msgstr ""

#. type: Plain text
#: man-pages/man2/sigaltstack.2:140
msgid ""
"This field specifies the size of the stack.  The constant B<SIGSTKSZ> is "
"defined to be large enough to cover the usual size requirements for an "
"alternate signal stack, and the constant B<MINSIGSTKSZ> defines the minimum "
"size required to execute a signal handler."
msgstr ""

#. type: Plain text
#: man-pages/man2/sigaltstack.2:147
msgid ""
"To disable an existing stack, specify I<ss.ss_flags> as B<SS_DISABLE>.  In "
"this case, the kernel ignores any other flags in I<ss.ss_flags> and the "
"remaining fields in I<ss>."
msgstr ""

#. type: Plain text
#: man-pages/man2/sigaltstack.2:155
msgid ""
"If I<old_ss> is not NULL, then it is used to return information about the "
"alternate signal stack which was in effect prior to the call to "
"B<sigaltstack>().  The I<old_ss.ss_sp> and I<old_ss.ss_size> fields return "
"the starting address and size of that stack.  The I<old_ss.ss_flags> may "
"return either of the following values:"
msgstr ""

#. type: TP
#: man-pages/man2/sigaltstack.2:155
#, no-wrap
msgid "B<SS_ONSTACK>"
msgstr ""

#. type: Plain text
#: man-pages/man2/sigaltstack.2:161
msgid ""
"The process is currently executing on the alternate signal stack.  (Note "
"that it is not possible to change the alternate signal stack if the process "
"is currently executing on it.)"
msgstr ""

#. type: TP
#: man-pages/man2/sigaltstack.2:161
#, no-wrap
msgid "B<SS_DISABLE>"
msgstr ""

#. type: Plain text
#: man-pages/man2/sigaltstack.2:164
msgid "The alternate signal stack is currently disabled."
msgstr ""

#.  FIXME Was it intended that one can set up a different alternative
#.  signal stack in this scenario? (In passing, if one does this, the
#.  sigaltstack(NULL, &old_ss) now returns old_ss.ss_flags==SS_AUTODISARM
#.  rather than old_ss.ss_flags==SS_DISABLE. The API design here seems
#.  confusing...
#. type: Plain text
#: man-pages/man2/sigaltstack.2:179
msgid ""
"Alternatively, this value is returned if the process is currently executing "
"on an alternate signal stack that was established using the B<SS_AUTODISARM> "
"flag.  In this case, it is safe to switch away from the signal handler with "
"B<swapcontext>(3).  It is also possible to set up a different alternative "
"signal stack using a further call to B<sigaltstack>()."
msgstr ""

#. type: TP
#: man-pages/man2/sigaltstack.2:179
#, no-wrap
msgid "B<SS_AUTODISARM>"
msgstr ""

#. type: Plain text
#: man-pages/man2/sigaltstack.2:183
msgid ""
"The alternate signal stack has been marked to be autodisarmed as described "
"above."
msgstr ""

#. type: Plain text
#: man-pages/man2/sigaltstack.2:190
msgid ""
"By specifying I<ss> as NULL, and I<old_ss> as a non-NULL value, one can "
"obtain the current settings for the alternate signal stack without changing "
"them."
msgstr ""

#. type: Plain text
#: man-pages/man2/sigaltstack.2:194
msgid ""
"B<sigaltstack>()  returns 0 on success, or -1 on failure with I<errno> set "
"to indicate the error."
msgstr ""

#. type: Plain text
#: man-pages/man2/sigaltstack.2:199
msgid ""
"Either I<ss> or I<old_ss> is not NULL and points to an area outside of the "
"process's address space."
msgstr ""

#. type: Plain text
#: man-pages/man2/sigaltstack.2:203
msgid "I<ss> is not NULL and the I<ss_flags> field contains an invalid flag."
msgstr ""

#. type: Plain text
#: man-pages/man2/sigaltstack.2:209
msgid ""
"The specified size of the new alternate signal stack I<ss.ss_size> was less "
"than B<MINSIGSTKSZ>."
msgstr ""

#. type: Plain text
#: man-pages/man2/sigaltstack.2:214
msgid ""
"An attempt was made to change the alternate signal stack while it was active "
"(i.e., the process was already executing on the current alternate signal "
"stack)."
msgstr ""

#. type: tbl table
#: man-pages/man2/sigaltstack.2:224
#, no-wrap
msgid "B<sigaltstack>()"
msgstr ""

#. type: Plain text
#: man-pages/man2/sigaltstack.2:228
msgid "POSIX.1-2001, POSIX.1-2008, SUSv2, SVr4."
msgstr ""

#. type: Plain text
#: man-pages/man2/sigaltstack.2:232
msgid "The B<SS_AUTODISARM> flag is a Linux extension."
msgstr ""

#. type: Plain text
#: man-pages/man2/sigaltstack.2:240
msgid ""
"The most common usage of an alternate signal stack is to handle the "
"B<SIGSEGV> signal that is generated if the space available for the normal "
"process stack is exhausted: in this case, a signal handler for B<SIGSEGV> "
"cannot be invoked on the process stack; if we wish to handle it, we must use "
"an alternate signal stack."
msgstr ""

#. type: Plain text
#: man-pages/man2/sigaltstack.2:250
msgid ""
"Establishing an alternate signal stack is useful if a process expects that "
"it may exhaust its standard stack.  This may occur, for example, because the "
"stack grows so large that it encounters the upwardly growing heap, or it "
"reaches a limit established by a call to B<setrlimit(RLIMIT_STACK, &rlim)>.  "
"If the standard stack is exhausted, the kernel sends the process a "
"B<SIGSEGV> signal.  In these circumstances the only way to catch this signal "
"is on an alternate signal stack."
msgstr ""

#. type: Plain text
#: man-pages/man2/sigaltstack.2:256
msgid ""
"On most hardware architectures supported by Linux, stacks grow downward.  "
"B<sigaltstack>()  automatically takes account of the direction of stack "
"growth."
msgstr ""

#. type: Plain text
#: man-pages/man2/sigaltstack.2:265
msgid ""
"Functions called from a signal handler executing on an alternate signal "
"stack will also use the alternate signal stack.  (This also applies to any "
"handlers invoked for other signals while the process is executing on the "
"alternate signal stack.)  Unlike the standard stack, the system does not "
"automatically extend the alternate signal stack.  Exceeding the allocated "
"size of the alternate signal stack will lead to unpredictable results."
msgstr ""

#. type: Plain text
#: man-pages/man2/sigaltstack.2:273
msgid ""
"A successful call to B<execve>(2)  removes any existing alternate signal "
"stack.  A child process created via B<fork>(2)  inherits a copy of its "
"parent's alternate signal stack settings."
msgstr ""

#. type: Plain text
#: man-pages/man2/sigaltstack.2:282
msgid ""
"B<sigaltstack>()  supersedes the older B<sigstack>()  call.  For backward "
"compatibility, glibc also provides B<sigstack>().  All new applications "
"should be written using B<sigaltstack>()."
msgstr ""

#. type: Plain text
#: man-pages/man2/sigaltstack.2:289
msgid ""
"4.2BSD had a B<sigstack>()  system call.  It used a slightly different "
"struct, and had the major disadvantage that the caller had to know the "
"direction of stack growth."
msgstr ""

#. type: Plain text
#: man-pages/man2/sigaltstack.2:298
msgid ""
"The following code segment demonstrates the use of B<sigaltstack>()  (and "
"B<sigaction>(2))  to install an alternate signal stack that is employed by a "
"handler for the B<SIGSEGV> signal:"
msgstr ""

#. type: Plain text
#: man-pages/man2/sigaltstack.2:302
#, no-wrap
msgid "stack_t ss;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/sigaltstack.2:308
#, no-wrap
msgid ""
"ss.ss_sp = malloc(SIGSTKSZ);\n"
"if (ss.ss_sp == NULL) {\n"
"    perror(\"malloc\");\n"
"    exit(EXIT_FAILURE);\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/sigaltstack.2:315
#, no-wrap
msgid ""
"ss.ss_size = SIGSTKSZ;\n"
"ss.ss_flags = 0;\n"
"if (sigaltstack(&ss, NULL) == -1) {\n"
"    perror(\"sigaltstack\");\n"
"    exit(EXIT_FAILURE);\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/sigaltstack.2:323
#, no-wrap
msgid ""
"sa.sa_flags = SA_ONSTACK;\n"
"sa.sa_handler = handler();      /* Address of a signal handler */\n"
"sigemptyset(&sa.sa_mask);\n"
"if (sigaction(SIGSEGV, &sa, NULL) == -1) {\n"
"    perror(\"sigaction\");\n"
"    exit(EXIT_FAILURE);\n"
"}\n"
msgstr ""

#.  Linux 2.3.40
#.  After quite a bit of web and mail archive searching,
#.  I could not find the patch on any mailing list, and I
#.  could find no place where the rationale for this change
#.  explained -- mtk
#.  See the source code of Illumos and FreeBSD, for example.
#. type: Plain text
#: man-pages/man2/sigaltstack.2:363
msgid ""
"In Linux 2.2 and earlier, the only flag that could be specified in "
"I<ss.sa_flags> was B<SS_DISABLE>.  In the lead up to the release of the "
"Linux 2.4 kernel, a change was made to allow B<sigaltstack>()  to allow "
"I<ss.ss_flags==SS_ONSTACK> with the same meaning as I<ss.ss_flags==0> (i.e., "
"the inclusion of B<SS_ONSTACK> in I<ss.ss_flags> is a no-op).  On other "
"implementations, and according to POSIX.1, B<SS_ONSTACK> appears only as a "
"reported flag in I<old_ss.ss_flags>.  On Linux, there is no need ever to "
"specify B<SS_ONSTACK> in I<ss.ss_flags>, and indeed doing so should be "
"avoided on portability grounds: various other systems give an error if "
"B<SS_ONSTACK> is specified in I<ss.ss_flags>."
msgstr ""

#. type: Plain text
#: man-pages/man2/sigaltstack.2:369
msgid ""
"B<execve>(2), B<setrlimit>(2), B<sigaction>(2), B<siglongjmp>(3), "
"B<sigsetjmp>(3), B<signal>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/uname.2:27
#, no-wrap
msgid "UNAME"
msgstr ""

#. type: Plain text
#: man-pages/man2/uname.2:30
msgid "uname - get name and information about current kernel"
msgstr ""

#. type: Plain text
#: man-pages/man2/uname.2:32
msgid "B<#include E<lt>sys/utsname.hE<gt>>"
msgstr ""

#. type: Plain text
#: man-pages/man2/uname.2:34
msgid "B<int uname(struct utsname *>I<buf>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/uname.2:42
msgid ""
"B<uname>()  returns system information in the structure pointed to by "
"I<buf>.  The I<utsname> struct is defined in I<E<lt>sys/utsname.hE<gt>>:"
msgstr ""

#. type: Plain text
#: man-pages/man2/uname.2:56
#, no-wrap
msgid ""
"struct utsname {\n"
"    char sysname[];    /* Operating system name (e.g., \"Linux\") */\n"
"    char nodename[];   /* Name within \"some implementation-defined\n"
"                          network\" */\n"
"    char release[];    /* Operating system release (e.g., \"2.6.28\") */\n"
"    char version[];    /* Operating system version */\n"
"    char machine[];    /* Hardware identifier */\n"
"#ifdef _GNU_SOURCE\n"
"    char domainname[]; /* NIS or YP domain name */\n"
"#endif\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/uname.2:63
msgid ""
"The length of the arrays in a I<struct utsname> is unspecified (see NOTES); "
"the fields are terminated by a null byte (\\(aq\\e0\\(aq)."
msgstr ""

#. type: Plain text
#: man-pages/man2/uname.2:73
msgid "I<buf> is not valid."
msgstr ""

#. type: Plain text
#: man-pages/man2/uname.2:78
msgid "POSIX.1-2001, POSIX.1-2008, SVr4.  There is no B<uname>()  call in 4.3BSD."
msgstr ""

#. type: Plain text
#: man-pages/man2/uname.2:82
msgid "The I<domainname> member (the NIS or YP domain name) is a GNU extension."
msgstr ""

#. type: Plain text
#: man-pages/man2/uname.2:98
msgid ""
"This is a system call, and the operating system presumably knows its name, "
"release and version.  It also knows what hardware it runs on.  So, four of "
"the fields of the struct are meaningful.  On the other hand, the field "
"I<nodename> is meaningless: it gives the name of the present machine in some "
"undefined network, but typically machines are in more than one network and "
"have several names.  Moreover, the kernel has no way of knowing about such "
"things, so it has to be told what to answer here.  The same holds for the "
"additional I<domainname> field."
msgstr ""

#. type: Plain text
#: man-pages/man2/uname.2:116
msgid ""
"To this end, Linux uses the system calls B<sethostname>(2)  and "
"B<setdomainname>(2).  Note that there is no standard that says that the "
"hostname set by B<sethostname>(2)  is the same string as the I<nodename> "
"field of the struct returned by B<uname>()  (indeed, some systems allow a "
"256-byte hostname and an 8-byte nodename), but this is true on Linux.  The "
"same holds for B<setdomainname>(2)  and the I<domainname> field."
msgstr ""

#. type: Plain text
#: man-pages/man2/uname.2:131
msgid ""
"The length of the fields in the struct varies.  Some operating systems or "
"libraries use a hardcoded 9 or 33 or 65 or 257.  Other systems use "
"B<SYS_NMLN> or B<_SYS_NMLN> or B<UTSLEN> or B<_UTSNAME_LENGTH>.  Clearly, it "
"is a bad idea to use any of these constants; just use sizeof(...).  Often "
"257 is chosen in order to have room for an internet hostname."
msgstr ""

#. type: Plain text
#: man-pages/man2/uname.2:138
msgid ""
"Part of the utsname information is also accessible via "
"I</proc/sys/kernel/>{I<ostype>, I<hostname>, I<osrelease>, I<version>, "
"I<domainname>}."
msgstr ""

#.  That was back before Linux 1.0
#.  That was also back before Linux 1.0
#. type: Plain text
#: man-pages/man2/uname.2:167
msgid ""
"Over time, increases in the size of the I<utsname> structure have led to "
"three successive versions of B<uname>(): I<sys_olduname>()  (slot "
"I<__NR_oldolduname>), I<sys_uname>()  (slot I<__NR_olduname>), and "
"I<sys_newuname>()  (slot I<__NR_uname)>.  The first one used length 9 for "
"all fields; the second used 65; the third also uses 65 but adds the "
"I<domainname> field.  The glibc B<uname>()  wrapper function hides these "
"details from applications, invoking the most recent version of the system "
"call provided by the kernel."
msgstr ""

#. type: Plain text
#: man-pages/man2/uname.2:171
msgid "B<uname>(1), B<getdomainname>(2), B<gethostname>(2), B<uts_namespaces>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/sigsuspend.2:29
#, no-wrap
msgid "SIGSUSPEND"
msgstr ""

#. type: Plain text
#: man-pages/man2/sigsuspend.2:32
msgid "sigsuspend, rt_sigsuspend - wait for a signal"
msgstr ""

#. type: Plain text
#: man-pages/man2/sigsuspend.2:36
msgid "B<int sigsuspend(const sigset_t *>I<mask>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/sigsuspend.2:45
msgid "B<sigsuspend>(): _POSIX_C_SOURCE"
msgstr ""

#. type: Plain text
#: man-pages/man2/sigsuspend.2:53
msgid ""
"B<sigsuspend>()  temporarily replaces the signal mask of the calling thread "
"with the mask given by I<mask> and then suspends the thread until delivery "
"of a signal whose action is to invoke a signal handler or to terminate a "
"process."
msgstr ""

#. type: Plain text
#: man-pages/man2/sigsuspend.2:62
msgid ""
"If the signal terminates the process, then B<sigsuspend>()  does not "
"return.  If the signal is caught, then B<sigsuspend>()  returns after the "
"signal handler returns, and the signal mask is restored to the state before "
"the call to B<sigsuspend>()."
msgstr ""

#. type: Plain text
#: man-pages/man2/sigsuspend.2:70
msgid ""
"It is not possible to block B<SIGKILL> or B<SIGSTOP>; specifying these "
"signals in I<mask>, has no effect on the thread's signal mask."
msgstr ""

#. type: Plain text
#: man-pages/man2/sigsuspend.2:76
msgid ""
"B<sigsuspend>()  always returns -1, with I<errno> set to indicate the error "
"(normally, B<EINTR>)."
msgstr ""

#. type: Plain text
#: man-pages/man2/sigsuspend.2:81
msgid ""
"I<mask> points to memory which is not a valid part of the process address "
"space."
msgstr ""

#. type: Plain text
#: man-pages/man2/sigsuspend.2:85
msgid "The call was interrupted by a signal; B<signal>(7)."
msgstr ""

#. type: Plain text
#: man-pages/man2/sigsuspend.2:105
msgid ""
"Normally, B<sigsuspend>()  is used in conjunction with B<sigprocmask>(2)  in "
"order to prevent delivery of a signal during the execution of a critical "
"code section.  The caller first blocks the signals with B<sigprocmask>(2).  "
"When the critical code has completed, the caller then waits for the signals "
"by calling B<sigsuspend>()  with the signal mask that was returned by "
"B<sigprocmask>(2)  (in the I<oldset> argument)."
msgstr ""

#. type: Plain text
#: man-pages/man2/sigsuspend.2:137
msgid ""
"The original Linux system call was named B<sigsuspend>().  However, with the "
"addition of real-time signals in Linux 2.2, the fixed-size, 32-bit "
"I<sigset_t> type supported by that system call was no longer fit for "
"purpose.  Consequently, a new system call, B<rt_sigsuspend>(), was added to "
"support an enlarged I<sigset_t> type.  The new system call takes a second "
"argument, I<size_t sigsetsize>, which specifies the size in bytes of the "
"signal set in I<mask>.  This argument is currently required to have the "
"value I<sizeof(sigset_t)> (or the error B<EINVAL> results).  The glibc "
"B<sigsuspend>()  wrapper function hides these details from us, transparently "
"calling B<rt_sigsuspend>()  when the kernel provides it."
msgstr ""

#. type: Plain text
#: man-pages/man2/sigsuspend.2:146
msgid ""
"B<kill>(2), B<pause>(2), B<sigaction>(2), B<signal>(2), B<sigprocmask>(2), "
"B<sigwaitinfo>(2), B<sigsetops>(3), B<sigwait>(3), B<signal>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/mlock.2:26
#, no-wrap
msgid "MLOCK"
msgstr ""

#. type: Plain text
#: man-pages/man2/mlock.2:29
msgid "mlock, mlock2, munlock, mlockall, munlockall - lock and unlock memory"
msgstr ""

#. type: Plain text
#: man-pages/man2/mlock.2:36
#, no-wrap
msgid ""
"B<int mlock(const void *>I<addr>B<, size_t >I<len>B<);>\n"
"B<int mlock2(const void *>I<addr>B<, size_t >I<len>B<, int >I<flags>B<);>\n"
"B<int munlock(const void *>I<addr>B<, size_t >I<len>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/mlock.2:39
#, no-wrap
msgid ""
"B<int mlockall(int >I<flags>B<);>\n"
"B<int munlockall(void);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/mlock.2:48
msgid ""
"B<mlock>(), B<mlock2>(), and B<mlockall>()  lock part or all of the calling "
"process's virtual address space into RAM, preventing that memory from being "
"paged to the swap area."
msgstr ""

#. type: Plain text
#: man-pages/man2/mlock.2:56
msgid ""
"B<munlock>()  and B<munlockall>()  perform the converse operation, unlocking "
"part or all of the calling process's virtual address space, so that pages in "
"the specified virtual address range may once more to be swapped out if "
"required by the kernel memory manager."
msgstr ""

#. type: Plain text
#: man-pages/man2/mlock.2:58
msgid "Memory locking and unlocking are performed in units of whole pages."
msgstr ""

#. type: SS
#: man-pages/man2/mlock.2:58
#, no-wrap
msgid "mlock(), mlock2(), and munlock()"
msgstr ""

#. type: Plain text
#: man-pages/man2/mlock.2:68
msgid ""
"B<mlock>()  locks pages in the address range starting at I<addr> and "
"continuing for I<len> bytes.  All pages that contain a part of the specified "
"address range are guaranteed to be resident in RAM when the call returns "
"successfully; the pages are guaranteed to stay in RAM until later unlocked."
msgstr ""

#.  commit a8ca5d0ecbdde5cc3d7accacbd69968b0c98764e
#.  commit de60f5f10c58d4f34b68622442c0e04180367f3f
#.  commit b0f205c2a3082dd9081f9a94e50658c5fa906ff1
#. type: Plain text
#: man-pages/man2/mlock.2:82
msgid ""
"B<mlock2>()  also locks pages in the specified range starting at I<addr> and "
"continuing for I<len> bytes.  However, the state of the pages contained in "
"that range after the call returns successfully will depend on the value in "
"the I<flags> argument."
msgstr ""

#. type: Plain text
#: man-pages/man2/mlock.2:86
msgid "The I<flags> argument can be either 0 or the following constant:"
msgstr ""

#. type: TP
#: man-pages/man2/mlock.2:86
#, no-wrap
msgid "B<MLOCK_ONFAULT>"
msgstr ""

#. type: Plain text
#: man-pages/man2/mlock.2:91
msgid ""
"Lock pages that are currently resident and mark the entire range so that the "
"remaining nonresident pages are locked when they are populated by a page "
"fault."
msgstr ""

#. type: Plain text
#: man-pages/man2/mlock.2:99
msgid "If I<flags> is 0, B<mlock2>()  behaves exactly the same as B<mlock>()."
msgstr ""

#. type: Plain text
#: man-pages/man2/mlock.2:108
msgid ""
"B<munlock>()  unlocks pages in the address range starting at I<addr> and "
"continuing for I<len> bytes.  After this call, all pages that contain a part "
"of the specified memory range can be moved to external swap space again by "
"the kernel."
msgstr ""

#. type: SS
#: man-pages/man2/mlock.2:108
#, no-wrap
msgid "mlockall() and munlockall()"
msgstr ""

#. type: Plain text
#: man-pages/man2/mlock.2:118
msgid ""
"B<mlockall>()  locks all pages mapped into the address space of the calling "
"process.  This includes the pages of the code, data and stack segment, as "
"well as shared libraries, user space kernel data, shared memory, and "
"memory-mapped files.  All mapped pages are guaranteed to be resident in RAM "
"when the call returns successfully; the pages are guaranteed to stay in RAM "
"until later unlocked."
msgstr ""

#. type: Plain text
#: man-pages/man2/mlock.2:123
msgid ""
"The I<flags> argument is constructed as the bitwise OR of one or more of the "
"following constants:"
msgstr ""

#. type: TP
#: man-pages/man2/mlock.2:123
#, no-wrap
msgid "B<MCL_CURRENT>"
msgstr ""

#. type: Plain text
#: man-pages/man2/mlock.2:127
msgid ""
"Lock all pages which are currently mapped into the address space of the "
"process."
msgstr ""

#. type: TP
#: man-pages/man2/mlock.2:127
#, no-wrap
msgid "B<MCL_FUTURE>"
msgstr ""

#. type: Plain text
#: man-pages/man2/mlock.2:134
msgid ""
"Lock all pages which will become mapped into the address space of the "
"process in the future.  These could be, for instance, new pages required by "
"a growing heap and stack as well as new memory-mapped files or shared memory "
"regions."
msgstr ""

#. type: TP
#: man-pages/man2/mlock.2:134
#, no-wrap
msgid "B<MCL_ONFAULT> (since Linux 4.4)"
msgstr ""

#. type: Plain text
#: man-pages/man2/mlock.2:161
msgid ""
"Used together with B<MCL_CURRENT>, B<MCL_FUTURE>, or both.  Mark all current "
"(with B<MCL_CURRENT>)  or future (with B<MCL_FUTURE>)  mappings to lock "
"pages when they are faulted in.  When used with B<MCL_CURRENT>, all present "
"pages are locked, but B<mlockall>()  will not fault in non-present pages.  "
"When used with B<MCL_FUTURE>, all future mappings will be marked to lock "
"pages when they are faulted in, but they will not be populated by the lock "
"when the mapping is created.  B<MCL_ONFAULT> must be used with either "
"B<MCL_CURRENT> or B<MCL_FUTURE> or both."
msgstr ""

#. type: Plain text
#: man-pages/man2/mlock.2:174
msgid ""
"If B<MCL_FUTURE> has been specified, then a later system call (e.g., "
"B<mmap>(2), B<sbrk>(2), B<malloc>(3)), may fail if it would cause the number "
"of locked bytes to exceed the permitted maximum (see below).  In the same "
"circumstances, stack growth may likewise fail: the kernel will deny stack "
"expansion and deliver a B<SIGSEGV> signal to the process."
msgstr ""

#. type: Plain text
#: man-pages/man2/mlock.2:178
msgid ""
"B<munlockall>()  unlocks all pages mapped into the address space of the "
"calling process."
msgstr ""

#. type: Plain text
#: man-pages/man2/mlock.2:184
msgid ""
"On success, these system calls return 0.  On error, -1 is returned, I<errno> "
"is set appropriately, and no changes are made to any locks in the address "
"space of the process."
msgstr ""

#. type: Plain text
#: man-pages/man2/mlock.2:193
msgid ""
"(Linux 2.6.9 and later) the caller had a nonzero B<RLIMIT_MEMLOCK> soft "
"resource limit, but tried to lock more memory than the limit permitted.  "
"This limit is not enforced if the process is privileged (B<CAP_IPC_LOCK>)."
msgstr ""

#.  In the case of mlock(), this check is somewhat buggy: it doesn't
#.  take into account whether the to-be-locked range overlaps with
#.  already locked pages.  Thus, suppose we allocate
#.  (num_physpages / 4 + 1) of memory, and lock those pages once using
#.  mlock(), and then lock the *same* page range a second time.
#.  In the case, the second mlock() call will fail, since the check
#.  calculates that the process is trying to lock (num_physpages / 2 + 2)
#.  pages, which of course is not true.  (MTK, Nov 04, kernel 2.4.28)
#. type: Plain text
#: man-pages/man2/mlock.2:205
msgid ""
"(Linux 2.4 and earlier) the calling process tried to lock more than half of "
"RAM."
msgstr ""

#. SVr4 documents an additional EAGAIN error code.
#. type: Plain text
#: man-pages/man2/mlock.2:211
msgid ""
"The caller is not privileged, but needs privilege (B<CAP_IPC_LOCK>)  to "
"perform the requested operation."
msgstr ""

#. type: Plain text
#: man-pages/man2/mlock.2:217
msgid "For B<mlock>(), B<mlock2>(), and B<munlock>():"
msgstr ""

#. type: Plain text
#: man-pages/man2/mlock.2:220
msgid "Some or all of the specified address range could not be locked."
msgstr ""

#. type: Plain text
#: man-pages/man2/mlock.2:227
msgid ""
"The result of the addition I<addr>+I<len> was less than I<addr> (e.g., the "
"addition may have resulted in an overflow)."
msgstr ""

#. type: Plain text
#: man-pages/man2/mlock.2:232
msgid "(Not on Linux)  I<addr> was not a multiple of the page size."
msgstr ""

#. type: Plain text
#: man-pages/man2/mlock.2:236
msgid ""
"Some of the specified address range does not correspond to mapped pages in "
"the address space of the process."
msgstr ""

#.  I.e., the number of VMAs would exceed the 64kB maximum
#. type: Plain text
#: man-pages/man2/mlock.2:245
msgid ""
"Locking or unlocking a region would result in the total number of mappings "
"with distinct attributes (e.g., locked versus unlocked)  exceeding the "
"allowed maximum.  (For example, unlocking a range in the middle of a "
"currently locked mapping would result in three mappings: two locked mappings "
"at each end and an unlocked mapping in the middle.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/mlock.2:248
msgid "For B<mlock2>():"
msgstr ""

#. type: Plain text
#: man-pages/man2/mlock.2:251
msgid "Unknown I<flags> were specified."
msgstr ""

#. type: Plain text
#: man-pages/man2/mlock.2:254
msgid "For B<mlockall>():"
msgstr ""

#. type: Plain text
#: man-pages/man2/mlock.2:262
msgid ""
"Unknown I<flags> were specified or B<MCL_ONFAULT> was specified without "
"either B<MCL_FUTURE> or B<MCL_CURRENT>."
msgstr ""

#. type: Plain text
#: man-pages/man2/mlock.2:265
msgid "For B<munlockall>():"
msgstr ""

#. type: Plain text
#: man-pages/man2/mlock.2:269
msgid "(Linux 2.6.8 and earlier) The caller was not privileged (B<CAP_IPC_LOCK>)."
msgstr ""

#. type: Plain text
#: man-pages/man2/mlock.2:273
msgid ""
"B<mlock2>()  is available since Linux 4.4; glibc support was added in "
"version 2.27."
msgstr ""

#. type: Plain text
#: man-pages/man2/mlock.2:278
msgid "mlock2 ()  is Linux specific."
msgstr ""

#. type: Plain text
#: man-pages/man2/mlock.2:290
msgid ""
"On POSIX systems on which B<mlock>()  and B<munlock>()  are available, "
"B<_POSIX_MEMLOCK_RANGE> is defined in I<E<lt>unistd.hE<gt>> and the number "
"of bytes in a page can be determined from the constant B<PAGESIZE> (if "
"defined) in I<E<lt>limits.hE<gt>> or by calling I<sysconf(_SC_PAGESIZE)>."
msgstr ""

#.  POSIX.1-2001: It shall be defined to -1 or 0 or 200112L.
#.  -1: unavailable, 0: ask using sysconf().
#.  glibc defines it to 1.
#. type: Plain text
#: man-pages/man2/mlock.2:303
msgid ""
"On POSIX systems on which B<mlockall>()  and B<munlockall>()  are available, "
"B<_POSIX_MEMLOCK> is defined in I<E<lt>unistd.hE<gt>> to a value greater "
"than 0.  (See also B<sysconf>(3).)"
msgstr ""

#. type: Plain text
#: man-pages/man2/mlock.2:321
msgid ""
"Memory locking has two main applications: real-time algorithms and "
"high-security data processing.  Real-time applications require deterministic "
"timing, and, like scheduling, paging is one major cause of unexpected "
"program execution delays.  Real-time applications will usually also switch "
"to a real-time scheduler with B<sched_setscheduler>(2).  Cryptographic "
"security software often handles critical bytes like passwords or secret keys "
"as data structures.  As a result of paging, these secrets could be "
"transferred onto a persistent swap store medium, where they might be "
"accessible to the enemy long after the security software has erased the "
"secrets in RAM and terminated.  (But be aware that the suspend mode on "
"laptops and some desktop computers will save a copy of the system's RAM to "
"disk, regardless of memory locks.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/mlock.2:334
msgid ""
"Real-time processes that are using B<mlockall>()  to prevent delays on page "
"faults should reserve enough locked stack pages before entering the "
"time-critical section, so that no page fault can be caused by function "
"calls.  This can be achieved by calling a function that allocates a "
"sufficiently large automatic variable (an array) and writes to the memory "
"occupied by this array in order to touch these stack pages.  This way, "
"enough pages will be mapped for the stack and can be locked into RAM.  The "
"dummy writes ensure that not even copy-on-write page faults can occur in the "
"critical section."
msgstr ""

#. type: Plain text
#: man-pages/man2/mlock.2:349
msgid ""
"Memory locks are not inherited by a child created via B<fork>(2)  and are "
"automatically removed (unlocked) during an B<execve>(2)  or when the process "
"terminates.  The B<mlockall>()  B<MCL_FUTURE> and B<MCL_FUTURE | "
"MCL_ONFAULT> settings are not inherited by a child created via B<fork>(2)  "
"and are cleared during an B<execve>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/mlock.2:363
msgid ""
"Note that B<fork>(2)  will prepare the address space for a copy-on-write "
"operation.  The consequence is that any write access that follows will cause "
"a page fault that in turn may cause high latencies for a real-time process.  "
"Therefore, it is crucial not to invoke B<fork>(2)  after an B<mlockall>()  "
"or B<mlock>()  operation\\(emnot even from a thread which runs at a low "
"priority within a process which also has a thread running at elevated "
"priority."
msgstr ""

#. type: Plain text
#: man-pages/man2/mlock.2:367
msgid ""
"The memory lock on an address range is automatically removed if the address "
"range is unmapped via B<munmap>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/mlock.2:381
msgid ""
"Memory locks do not stack, that is, pages which have been locked several "
"times by calls to B<mlock>(), B<mlock2>(), or B<mlockall>()  will be "
"unlocked by a single call to B<munlock>()  for the corresponding range or by "
"B<munlockall>().  Pages which are mapped to several locations or by several "
"processes stay locked into RAM as long as they are locked at least at one "
"location or by at least one process."
msgstr ""

#. type: Plain text
#: man-pages/man2/mlock.2:390
msgid ""
"If a call to B<mlockall>()  which uses the B<MCL_FUTURE> flag is followed by "
"another call that does not specify this flag, the changes made by the "
"B<MCL_FUTURE> call will be lost."
msgstr ""

#. type: Plain text
#: man-pages/man2/mlock.2:401
msgid ""
"The B<mlock2>()  B<MLOCK_ONFAULT> flag and the B<mlockall>()  B<MCL_ONFAULT> "
"flag allow efficient memory locking for applications that deal with large "
"mappings where only a (small) portion of pages in the mapping are touched.  "
"In such cases, locking all of the pages in a mapping would incur a "
"significant penalty for memory locking."
msgstr ""

#. type: Plain text
#: man-pages/man2/mlock.2:417
msgid ""
"Under Linux, B<mlock>(), B<mlock2>(), and B<munlock>()  automatically round "
"I<addr> down to the nearest page boundary.  However, the POSIX.1 "
"specification of B<mlock>()  and B<munlock>()  allows an implementation to "
"require that I<addr> is page aligned, so portable applications should ensure "
"this."
msgstr ""

#. type: Plain text
#: man-pages/man2/mlock.2:431
msgid ""
"The I<VmLck> field of the Linux-specific I</proc/[pid]/status> file shows "
"how many kilobytes of memory the process with ID I<PID> has locked using "
"B<mlock>(), B<mlock2>(), B<mlockall>(), and B<mmap>(2)  B<MAP_LOCKED>."
msgstr ""

#. type: SS
#: man-pages/man2/mlock.2:431
#, no-wrap
msgid "Limits and permissions"
msgstr ""

#. type: Plain text
#: man-pages/man2/mlock.2:438
msgid ""
"In Linux 2.6.8 and earlier, a process must be privileged (B<CAP_IPC_LOCK>)  "
"in order to lock memory and the B<RLIMIT_MEMLOCK> soft resource limit "
"defines a limit on how much memory the process may lock."
msgstr ""

#. type: Plain text
#: man-pages/man2/mlock.2:444
msgid ""
"Since Linux 2.6.9, no limits are placed on the amount of memory that a "
"privileged process can lock and the B<RLIMIT_MEMLOCK> soft resource limit "
"instead defines a limit on how much memory an unprivileged process may lock."
msgstr ""

#.  commit 0cf2f6f6dc605e587d2c1120f295934c77e810e8
#. type: Plain text
#: man-pages/man2/mlock.2:467
msgid ""
"In Linux 4.8 and earlier, a bug in the kernel's accounting of locked memory "
"for unprivileged processes (i.e., without B<CAP_IPC_LOCK>)  meant that if "
"the region specified by I<addr> and I<len> overlapped an existing lock, then "
"the already locked bytes in the overlapping region were counted twice when "
"checking against the limit.  Such double accounting could incorrectly "
"calculate a \"total locked memory\" value for the process that exceeded the "
"B<RLIMIT_MEMLOCK> limit, with the result that B<mlock>()  and B<mlock2>()  "
"would fail on requests that should have succeeded.  This bug was fixed in "
"Linux 4.9"
msgstr ""

#. type: Plain text
#: man-pages/man2/mlock.2:475
msgid ""
"In the 2.4 series Linux kernels up to and including 2.4.17, a bug caused the "
"B<mlockall>()  B<MCL_FUTURE> flag to be inherited across a B<fork>(2).  This "
"was rectified in kernel 2.4.18."
msgstr ""

#.  See the following LKML thread:
#.  http://marc.theaimsgroup.com/?l=linux-kernel&m=113801392825023&w=2
#.  "Rationale for RLIMIT_MEMLOCK"
#.  23 Jan 2006
#. type: Plain text
#: man-pages/man2/mlock.2:492
msgid ""
"Since kernel 2.6.9, if a privileged process calls I<mlockall(MCL_FUTURE)> "
"and later drops privileges (loses the B<CAP_IPC_LOCK> capability by, for "
"example, setting its effective UID to a nonzero value), then subsequent "
"memory allocations (e.g., B<mmap>(2), B<brk>(2))  will fail if the "
"B<RLIMIT_MEMLOCK> resource limit is encountered."
msgstr ""

#. type: Plain text
#: man-pages/man2/mlock.2:499
msgid ""
"B<mincore>(2), B<mmap>(2), B<setrlimit>(2), B<shmctl>(2), B<sysconf>(3), "
"B<proc>(5), B<capabilities>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/futex.2:22
#, no-wrap
msgid "FUTEX"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:25
msgid "futex - fast user-space locking"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:30
#, no-wrap
msgid ""
"B<#include E<lt>linux/futex.hE<gt>>\n"
"B<#include E<lt>sys/time.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:35
#, no-wrap
msgid ""
"B<int futex(int *>I<uaddr>B<, int >I<futex_op>B<, int >I<val>B<,>\n"
"B<          const struct timespec *>I<timeout>B<,>I< >  /* or: B<uint32_t "
">I<val2>B< */>\n"
"B<          int *>I<uaddr2>B<, int >I<val3>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:57
msgid ""
"The B<futex>()  system call provides a method for waiting until a certain "
"condition becomes true.  It is typically used as a blocking construct in the "
"context of shared-memory synchronization.  When using futexes, the majority "
"of the synchronization operations are performed in user space.  A user-space "
"program employs the B<futex>()  system call only when it is likely that the "
"program has to block for a longer time until the condition becomes true.  "
"Other B<futex>()  operations can be used to wake any processes or threads "
"waiting for a particular condition."
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:76
msgid ""
"A futex is a 32-bit value\\(emreferred to below as a I<futex word>\\(emwhose "
"address is supplied to the B<futex>()  system call.  (Futexes are 32 bits in "
"size on all platforms, including 64-bit systems.)  All futex operations are "
"governed by this value.  In order to share a futex between processes, the "
"futex is placed in a region of shared memory, created using (for example)  "
"B<mmap>(2)  or B<shmat>(2).  (Thus, the futex word may have different "
"virtual addresses in different processes, but these addresses all refer to "
"the same location in physical memory.)  In a multithreaded program, it is "
"sufficient to place the futex word in a global variable shared by all "
"threads."
msgstr ""

#.  Notes from Darren Hart (Dec 2015):
#.      Totally ordered with respect futex operations refers to semantics
#.      of the ACQUIRE/RELEASE operations and how they impact ordering of
#.      memory reads and writes. The kernel futex operations are protected
#.      by spinlocks, which ensure that all operations are serialized
#.      with respect to one another.
#
#.      This is a lot to attempt to define in this document. Perhaps a
#.      reference to linux/Documentation/memory-barriers.txt as a footnote
#.      would be sufficient? Or perhaps for this manual, "serialized" would
#.      be sufficient, with a footnote regarding "totally ordered" and a
#.      pointer to the memory-barrier documentation?
#.  FIXME(Torvald Riegel):
#.  Eventually we want to have some text in NOTES to satisfy
#.  the reference in the following sentence
#.      See NOTES for a detailed specification of
#.      the synchronization semantics.
#. type: Plain text
#: man-pages/man2/futex.2:109
msgid ""
"When executing a futex operation that requests to block a thread, the kernel "
"will block only if the futex word has the value that the calling thread "
"supplied (as one of the arguments of the B<futex>()  call) as the expected "
"value of the futex word.  The loading of the futex word's value, the "
"comparison of that value with the expected value, and the actual blocking "
"will happen atomically and will be totally ordered with respect to "
"concurrent operations performed by other threads on the same futex word.  "
"Thus, the futex word is used to connect the synchronization in user space "
"with the implementation of blocking by the kernel.  Analogously to an atomic "
"compare-and-exchange operation that potentially changes shared memory, "
"blocking via a futex is an atomic compare-and-block operation."
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:136
msgid ""
"One use of futexes is for implementing locks.  The state of the lock (i.e., "
"acquired or not acquired)  can be represented as an atomically accessed flag "
"in shared memory.  In the uncontended case, a thread can access or modify "
"the lock state with atomic instructions, for example atomically changing it "
"from not acquired to acquired using an atomic compare-and-exchange "
"instruction.  (Such instructions are performed entirely in user mode, and "
"the kernel maintains no information about the lock state.)  On the other "
"hand, a thread may be unable to acquire a lock because it is already "
"acquired by another thread.  It then may pass the lock's flag as a futex "
"word and the value representing the acquired state as the expected value to "
"a B<futex>()  wait operation.  This B<futex>()  operation will block if and "
"only if the lock is still acquired (i.e., the value in the futex word still "
"matches the \"acquired state\").  When releasing the lock, a thread has to "
"first reset the lock state to not acquired and then execute a futex "
"operation that wakes threads blocked on the lock flag used as a futex word "
"(this can be further optimized to avoid unnecessary wake-ups).  See "
"B<futex>(7)  for more detail on how to use futexes."
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:139
msgid ""
"Besides the basic wait and wake-up futex functionality, there are further "
"futex operations aimed at supporting more complex use cases."
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:148
msgid ""
"Note that no explicit initialization or destruction is necessary to use "
"futexes; the kernel maintains a futex (i.e., the kernel-internal "
"implementation artifact)  only while operations such as B<FUTEX_WAIT>, "
"described below, are being performed on a particular futex word."
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:160
msgid ""
"The I<uaddr> argument points to the futex word.  On all platforms, futexes "
"are four-byte integers that must be aligned on a four-byte boundary.  The "
"operation to perform on the futex is specified in the I<futex_op> argument; "
"I<val> is a value whose meaning and purpose depends on I<futex_op>."
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:168
msgid ""
"The remaining arguments (I<timeout>, I<uaddr2>, and I<val3>)  are required "
"only for certain of the futex operations described below.  Where one of "
"these arguments is not required, it is ignored."
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:186
msgid ""
"For several blocking operations, the I<timeout> argument is a pointer to a "
"I<timespec> structure that specifies a timeout for the operation.  However, "
"notwithstanding the prototype shown above, for some operations, the least "
"significant four bytes of this argument are instead used as an integer whose "
"meaning is determined by the operation.  For these operations, the kernel "
"casts the I<timeout> value first to I<unsigned long>, then to I<uint32_t>, "
"and in the remainder of this page, this argument is referred to as I<val2> "
"when interpreted in this fashion."
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:191
msgid ""
"Where it is required, the I<uaddr2> argument is a pointer to a second futex "
"word that is employed by the operation."
msgstr ""

#
#. """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
#. type: Plain text
#: man-pages/man2/futex.2:198
msgid ""
"The interpretation of the final integer argument, I<val3>, depends on the "
"operation."
msgstr ""

#. type: SS
#: man-pages/man2/futex.2:198
#, no-wrap
msgid "Futex operations"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:208
msgid ""
"The I<futex_op> argument consists of two parts: a command that specifies the "
"operation to be performed, bit-wise ORed with zero or more options that "
"modify the behaviour of the operation.  The options that may be included in "
"I<futex_op> are as follows:"
msgstr ""

#. type: TP
#: man-pages/man2/futex.2:208
#, no-wrap
msgid "B<FUTEX_PRIVATE_FLAG> (since Linux 2.6.22)"
msgstr ""

#.  commit 34f01cc1f512fa783302982776895c73714ebbc2
#.  I.e., It allows the kernel choose the fast path for validating
#.  the user-space address and avoids expensive VMA lookups,
#.  taking reference counts on file backing store, and so on.
#. type: Plain text
#: man-pages/man2/futex.2:219
msgid ""
"This option bit can be employed with all futex operations.  It tells the "
"kernel that the futex is process-private and not shared with another process "
"(i.e., it is being used for synchronization only between threads of the same "
"process).  This allows the kernel to make some additional performance "
"optimizations."
msgstr ""

#.  except the obsolete FUTEX_FD, for which the "private" flag was
#.  meaningless
#. type: Plain text
#: man-pages/man2/futex.2:234
msgid ""
"As a convenience, I<E<lt>linux/futex.hE<gt>> defines a set of constants with "
"the suffix B<_PRIVATE> that are equivalents of all of the operations listed "
"below, but with the B<FUTEX_PRIVATE_FLAG> ORed into the constant value.  "
"Thus, there are B<FUTEX_WAIT_PRIVATE>, B<FUTEX_WAKE_PRIVATE>, and so on."
msgstr ""

#. type: TP
#: man-pages/man2/futex.2:234
#, no-wrap
msgid "B<FUTEX_CLOCK_REALTIME> (since Linux 2.6.28)"
msgstr ""

#.  commit 1acdac104668a0834cfa267de9946fac7764d486
#.  commit 337f13046ff03717a9e99675284a817527440a49
#. type: Plain text
#: man-pages/man2/futex.2:245
msgid ""
"This option bit can be employed only with the B<FUTEX_WAIT_BITSET>, "
"B<FUTEX_WAIT_REQUEUE_PI>, and (since Linux 4.5)  B<FUTEX_WAIT> operations."
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:251
msgid ""
"If this option is set, the kernel measures the I<timeout> against the "
"B<CLOCK_REALTIME> clock."
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:257
msgid ""
"If this option is not set, the kernel measures the I<timeout> against the "
"B<CLOCK_MONOTONIC> clock."
msgstr ""

#
#. """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
#. type: Plain text
#: man-pages/man2/futex.2:264
msgid "The operation specified in I<futex_op> is one of the following:"
msgstr ""

#. type: TP
#: man-pages/man2/futex.2:264
#, no-wrap
msgid "B<FUTEX_WAIT> (since Linux 2.6.0)"
msgstr ""

#.  Strictly speaking, since some time in 2.5.x
#.  FIXME: Torvald, I think we may need to add some explanation of
#.  "totally ordered" here.
#. type: Plain text
#: man-pages/man2/futex.2:290
msgid ""
"This operation tests that the value at the futex word pointed to by the "
"address I<uaddr> still contains the expected value I<val>, and if so, then "
"sleeps waiting for a B<FUTEX_WAKE> operation on the futex word.  The load of "
"the value of the futex word is an atomic memory access (i.e., using atomic "
"machine instructions of the respective architecture).  This load, the "
"comparison with the expected value, and starting to sleep are performed "
"atomically and totally ordered with respect to other futex operations on the "
"same futex word.  If the thread starts to sleep, it is considered a waiter "
"on this futex word.  If the futex value does not match I<val>, then the call "
"fails immediately with the error B<EAGAIN>."
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:301
msgid ""
"The purpose of the comparison with the expected value is to prevent lost "
"wake-ups.  If another thread changed the value of the futex word after the "
"calling thread decided to block based on the prior value, and if the other "
"thread executed a B<FUTEX_WAKE> operation (or similar wake-up) after the "
"value change and before this B<FUTEX_WAIT> operation, then the calling "
"thread will observe the value change and will not start to sleep."
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:319
msgid ""
"If the I<timeout> is not NULL, the structure it points to specifies a "
"timeout for the wait.  (This interval will be rounded up to the system clock "
"granularity, and is guaranteed not to expire early.)  The timeout is by "
"default measured according to the B<CLOCK_MONOTONIC> clock, but, since Linux "
"4.5, the B<CLOCK_REALTIME> clock can be selected by specifying "
"B<FUTEX_CLOCK_REALTIME> in I<futex_op>.  If I<timeout> is NULL, the call "
"blocks indefinitely."
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:338
msgid ""
"I<Note>: for B<FUTEX_WAIT>, I<timeout> is interpreted as a I<relative> "
"value.  This differs from other futex operations, where I<timeout> is "
"interpreted as an absolute value.  To obtain the equivalent of B<FUTEX_WAIT> "
"with an absolute timeout, employ B<FUTEX_WAIT_BITSET> with I<val3> specified "
"as B<FUTEX_BITSET_MATCH_ANY>."
msgstr ""

#.  FIXME . (Torvald) I think we should remove this.  Or maybe adapt to a
#.  different example.
#
#.      For
#.      .BR futex (7),
#.      this call is executed if decrementing the count gave a negative value
#.      (indicating contention),
#.      and will sleep until another process or thread releases
#.      the futex and executes the
#.      .B FUTEX_WAKE
#.      operation.
#
#. """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
#. type: Plain text
#: man-pages/man2/futex.2:358
msgid "The arguments I<uaddr2> and I<val3> are ignored."
msgstr ""

#. type: TP
#: man-pages/man2/futex.2:358
#, no-wrap
msgid "B<FUTEX_WAKE> (since Linux 2.6.0)"
msgstr ""

#.  Strictly speaking, since Linux 2.5.x
#. type: Plain text
#: man-pages/man2/futex.2:375
msgid ""
"This operation wakes at most I<val> of the waiters that are waiting (e.g., "
"inside B<FUTEX_WAIT>)  on the futex word at the address I<uaddr>.  Most "
"commonly, I<val> is specified as either 1 (wake up a single waiter) or "
"B<INT_MAX> (wake up all waiters).  No guarantee is provided about which "
"waiters are awoken (e.g., a waiter with a higher scheduling priority is not "
"guaranteed to be awoken in preference to a waiter with a lower priority)."
msgstr ""

#.  FIXME . (Torvald) I think we should remove this.  Or maybe adapt to
#.  a different example.
#
#.      For
#.      .BR futex (7),
#.      this is executed if incrementing the count showed that
#.      there were waiters,
#.      once the futex value has been set to 1
#.      (indicating that it is available).
#
#.  How does "incrementing the count show that there were waiters"?
#
#. """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
#. type: Plain text
#: man-pages/man2/futex.2:396
msgid "The arguments I<timeout>, I<uaddr2>, and I<val3> are ignored."
msgstr ""

#. type: TP
#: man-pages/man2/futex.2:396
#, no-wrap
msgid "B<FUTEX_FD> (from Linux 2.6.0 up to and including Linux 2.6.25)"
msgstr ""

#.  Strictly speaking, from Linux 2.5.x to 2.6.25
#. type: Plain text
#: man-pages/man2/futex.2:410
msgid ""
"This operation creates a file descriptor that is associated with the futex "
"at I<uaddr>.  The caller must close the returned file descriptor after use.  "
"When another process or thread performs a B<FUTEX_WAKE> on the futex word, "
"the file descriptor indicates as being readable with B<select>(2), "
"B<poll>(2), and B<epoll>(7)"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:417
msgid ""
"The file descriptor can be used to obtain asynchronous notifications: if "
"I<val> is nonzero, then, when another process or thread executes a "
"B<FUTEX_WAKE>, the caller will receive the signal number that was passed in "
"I<val>."
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:424
msgid "The arguments I<timeout>, I<uaddr2> and I<val3> are ignored."
msgstr ""

#.  commit 82af7aca56c67061420d618cc5a30f0fd4106b80
#
#. """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
#. type: Plain text
#: man-pages/man2/futex.2:433
msgid ""
"Because it was inherently racy, B<FUTEX_FD> has been removed from Linux "
"2.6.26 onward."
msgstr ""

#. type: TP
#: man-pages/man2/futex.2:433
#, no-wrap
msgid "B<FUTEX_REQUEUE> (since Linux 2.6.0)"
msgstr ""

#
#. """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
#. type: Plain text
#: man-pages/man2/futex.2:445
msgid ""
"This operation performs the same task as B<FUTEX_CMP_REQUEUE> (see below), "
"except that no check is made using the value in I<val3>.  (The argument "
"I<val3> is ignored.)"
msgstr ""

#. type: TP
#: man-pages/man2/futex.2:445
#, no-wrap
msgid "B<FUTEX_CMP_REQUEUE> (since Linux 2.6.7)"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:469
msgid ""
"This operation first checks whether the location I<uaddr> still contains the "
"value I<val3>.  If not, the operation fails with the error B<EAGAIN>.  "
"Otherwise, the operation wakes up a maximum of I<val> waiters that are "
"waiting on the futex at I<uaddr>.  If there are more than I<val> waiters, "
"then the remaining waiters are removed from the wait queue of the source "
"futex at I<uaddr> and added to the wait queue of the target futex at "
"I<uaddr2>.  The I<val2> argument specifies an upper limit on the number of "
"waiters that are requeued to the futex at I<uaddr2>."
msgstr ""

#.  FIXME(Torvald) Is the following correct?  Or is just the decision
#.  which threads to wake or requeue part of the atomic operation?
#.  Notes from a f2f conversation with Thomas Gleixner (Aug 2015): ###
#. 	The operation is serialized with respect to operations on both
#. 	source and target futex. No other waiter can enqueue itself
#. 	for waiting and no other waiter can dequeue itself because of
#. 	a timeout or signal.
#. type: Plain text
#: man-pages/man2/futex.2:485
msgid ""
"The load from I<uaddr> is an atomic memory access (i.e., using atomic "
"machine instructions of the respective architecture).  This load, the "
"comparison with I<val3>, and the requeueing of any waiters are performed "
"atomically and totally ordered with respect to other operations on the same "
"futex word."
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:503
msgid ""
"Typical values to specify for I<val> are 0 or 1.  (Specifying B<INT_MAX> is "
"not useful, because it would make the B<FUTEX_CMP_REQUEUE> operation "
"equivalent to B<FUTEX_WAKE>.)  The limit value specified via I<val2> is "
"typically either 1 or B<INT_MAX>.  (Specifying the argument as 0 is not "
"useful, because it would make the B<FUTEX_CMP_REQUEUE> operation equivalent "
"to B<FUTEX_WAIT>.)"
msgstr ""

#.  But, as Rich Felker points out, there remain valid use cases for
#.  FUTEX_REQUEUE, for example, when the calling thread is requeuing
#.  the target(s) to a lock that the calling thread owns
#.      From: Rich Felker <dalias@libc.org>
#.      Date: Wed, 29 Oct 2014 22:43:17 -0400
#.      To: Darren Hart <dvhart@infradead.org>
#.      CC: libc-alpha@sourceware.org, ...
#.      Subject: Re: Add futex wrapper to glibc?
#. type: Plain text
#: man-pages/man2/futex.2:520
msgid ""
"The B<FUTEX_CMP_REQUEUE> operation was added as a replacement for the "
"earlier B<FUTEX_REQUEUE>.  The difference is that the check of the value at "
"I<uaddr> can be used to ensure that requeueing happens only under certain "
"conditions, which allows race conditions to be avoided in certain use cases."
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:532
msgid ""
"Both B<FUTEX_REQUEUE> and B<FUTEX_CMP_REQUEUE> can be used to avoid "
"\"thundering herd\" wake-ups that could occur when using B<FUTEX_WAKE> in "
"cases where all of the waiters that are woken need to acquire another "
"futex.  Consider the following scenario, where multiple waiter threads are "
"waiting on B, a wait queue implemented using a futex:"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:542
#, no-wrap
msgid ""
"lock(A)\n"
"while (!check_value(V)) {\n"
"    unlock(A);\n"
"    block_on(B);\n"
"    lock(A);\n"
"};\n"
"unlock(A);\n"
msgstr ""

#
#. """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
#. type: Plain text
#: man-pages/man2/futex.2:557
msgid ""
"If a waker thread used B<FUTEX_WAKE>, then all waiters waiting on B would be "
"woken up, and they would all try to acquire lock A.  However, waking all of "
"the threads in this manner would be pointless because all except one of the "
"threads would immediately block on lock A again.  By contrast, a requeue "
"operation wakes just one waiter and moves the other waiters to lock A, and "
"when the woken waiter unlocks A then the next waiter can proceed."
msgstr ""

#. type: TP
#: man-pages/man2/futex.2:557
#, no-wrap
msgid "B<FUTEX_WAKE_OP> (since Linux 2.6.14)"
msgstr ""

#.  commit 4732efbeb997189d9f9b04708dc26bf8613ed721
#. 	Author: Jakub Jelinek <jakub@redhat.com>
#. 	Date:   Tue Sep 6 15:16:25 2005 -0700
#.  FIXME. (Torvald) The glibc condvar implementation is currently being
#.      revised (e.g., to not use an internal lock anymore).
#.      It is probably more future-proof to remove this paragraph.
#.  [Torvald, do you have an update here?]
#. type: Plain text
#: man-pages/man2/futex.2:576
msgid ""
"This operation was added to support some user-space use cases where more "
"than one futex must be handled at the same time.  The most notable example "
"is the implementation of B<pthread_cond_signal>(3), which requires "
"operations on two futexes, the one used to implement the mutex and the one "
"used in the implementation of the wait queue associated with the condition "
"variable.  B<FUTEX_WAKE_OP> allows such cases to be implemented without "
"leading to high rates of contention and context switching."
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:582
msgid ""
"The B<FUTEX_WAKE_OP> operation is equivalent to executing the following code "
"atomically and totally ordered with respect to other futex operations on any "
"of the two supplied futex words:"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:590
#, no-wrap
msgid ""
"int oldval = *(int *) uaddr2;\n"
"*(int *) uaddr2 = oldval I<op> I<oparg>;\n"
"futex(uaddr, FUTEX_WAKE, val, 0, 0, 0);\n"
"if (oldval I<cmp> I<cmparg>)\n"
"    futex(uaddr2, FUTEX_WAKE, val2, 0, 0, 0);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:596
msgid "In other words, B<FUTEX_WAKE_OP> does the following:"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:604
msgid ""
"saves the original value of the futex word at I<uaddr2> and performs an "
"operation to modify the value of the futex at I<uaddr2>; this is an atomic "
"read-modify-write memory access (i.e., using atomic machine instructions of "
"the respective architecture)"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:610
msgid ""
"wakes up a maximum of I<val> waiters on the futex for the futex word at "
"I<uaddr>; and"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:618
msgid ""
"dependent on the results of a test of the original value of the futex word "
"at I<uaddr2>, wakes up a maximum of I<val2> waiters on the futex for the "
"futex word at I<uaddr2>."
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:624
msgid ""
"The operation and comparison that are to be performed are encoded in the "
"bits of the argument I<val3>.  Pictorially, the encoding is:"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:631
#, no-wrap
msgid ""
"+---+---+-----------+-----------+\n"
"|op |cmp|   oparg   |  cmparg   |\n"
"+---+---+-----------+-----------+\n"
"  4   4       12          12    E<lt>== # of bits\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:635
msgid "Expressed in code, the encoding is:"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:643
#, no-wrap
msgid ""
"#define FUTEX_OP(op, oparg, cmp, cmparg) \\e\n"
"                (((op & 0xf) E<lt>E<lt> 28) | \\e\n"
"                ((cmp & 0xf) E<lt>E<lt> 24) | \\e\n"
"                ((oparg & 0xfff) E<lt>E<lt> 12) | \\e\n"
"                (cmparg & 0xfff))\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:656
msgid ""
"In the above, I<op> and I<cmp> are each one of the codes listed below.  The "
"I<oparg> and I<cmparg> components are literal numeric values, except as "
"noted below."
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:660
msgid "The I<op> component has one of the following values:"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:668
#, no-wrap
msgid ""
"FUTEX_OP_SET        0  /* uaddr2 = oparg; */\n"
"FUTEX_OP_ADD        1  /* uaddr2 += oparg; */\n"
"FUTEX_OP_OR         2  /* uaddr2 |= oparg; */\n"
"FUTEX_OP_ANDN       3  /* uaddr2 &= ~oparg; */\n"
"FUTEX_OP_XOR        4  /* uaddr2 ^= oparg; */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:676
msgid ""
"In addition, bit-wise ORing the following value into I<op> causes I<(1\\ "
"E<lt>E<lt>\\ oparg)> to be used as the operand:"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:680
#, no-wrap
msgid "FUTEX_OP_ARG_SHIFT  8  /* Use (1 E<lt>E<lt> oparg) as operand */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:686
msgid "The I<cmp> field is one of the following:"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:695
#, no-wrap
msgid ""
"FUTEX_OP_CMP_EQ     0  /* if (oldval == cmparg) wake */\n"
"FUTEX_OP_CMP_NE     1  /* if (oldval != cmparg) wake */\n"
"FUTEX_OP_CMP_LT     2  /* if (oldval E<lt> cmparg) wake */\n"
"FUTEX_OP_CMP_LE     3  /* if (oldval E<lt>= cmparg) wake */\n"
"FUTEX_OP_CMP_GT     4  /* if (oldval E<gt> cmparg) wake */\n"
"FUTEX_OP_CMP_GE     5  /* if (oldval E<gt>= cmparg) wake */\n"
msgstr ""

#
#. """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
#. type: Plain text
#: man-pages/man2/futex.2:707
msgid ""
"The return value of B<FUTEX_WAKE_OP> is the sum of the number of waiters "
"woken on the futex I<uaddr> plus the number of waiters woken on the futex "
"I<uaddr2>."
msgstr ""

#. type: TP
#: man-pages/man2/futex.2:707
#, no-wrap
msgid "B<FUTEX_WAIT_BITSET> (since Linux 2.6.25)"
msgstr ""

#.  commit cd689985cf49f6ff5c8eddc48d98b9d581d9475d
#. type: Plain text
#: man-pages/man2/futex.2:720
msgid ""
"This operation is like B<FUTEX_WAIT> except that I<val3> is used to provide "
"a 32-bit bit mask to the kernel.  This bit mask, in which at least one bit "
"must be set, is stored in the kernel-internal state of the waiter.  See the "
"description of B<FUTEX_WAKE_BITSET> for further details."
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:728 man-pages/man2/futex.2:1269
msgid ""
"If I<timeout> is not NULL, the structure it points to specifies an absolute "
"timeout for the wait operation.  If I<timeout> is NULL, the operation can "
"block indefinitely."
msgstr ""

#
#. """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
#. type: Plain text
#: man-pages/man2/futex.2:736
msgid "The I<uaddr2> argument is ignored."
msgstr ""

#. type: TP
#: man-pages/man2/futex.2:736
#, no-wrap
msgid "B<FUTEX_WAKE_BITSET> (since Linux 2.6.25)"
msgstr ""

#.  commit cd689985cf49f6ff5c8eddc48d98b9d581d9475d
#. type: Plain text
#: man-pages/man2/futex.2:754
msgid ""
"This operation is the same as B<FUTEX_WAKE> except that the I<val3> argument "
"is used to provide a 32-bit bit mask to the kernel.  This bit mask, in which "
"at least one bit must be set, is used to select which waiters should be "
"woken up.  The selection is done by a bit-wise AND of the \"wake\" bit mask "
"(i.e., the value in I<val3>)  and the bit mask which is stored in the "
"kernel-internal state of the waiter (the \"wait\" bit mask that is set using "
"B<FUTEX_WAIT_BITSET>).  All of the waiters for which the result of the AND "
"is nonzero are woken up; the remaining waiters are left sleeping."
msgstr ""

#.  According to http://locklessinc.com/articles/futex_cheat_sheet/:
#
#.     "The original reason for the addition of these extensions
#.      was to improve the performance of pthread read-write locks
#.      in glibc. However, the pthreads library no longer uses the
#.      same locking algorithm, and these extensions are not used
#.      without the bitset parameter being all ones.
#
#.  The page goes on to note that the FUTEX_WAIT_BITSET operation
#.  is nevertheless used (with a bit mask of all ones) in order to
#.  obtain the absolute timeout functionality that is useful
#.  for efficiently implementing Pthreads APIs (which use absolute
#.  timeouts); FUTEX_WAIT provides only relative timeouts.
#. type: Plain text
#: man-pages/man2/futex.2:781
msgid ""
"The effect of B<FUTEX_WAIT_BITSET> and B<FUTEX_WAKE_BITSET> is to allow "
"selective wake-ups among multiple waiters that are blocked on the same "
"futex.  However, note that, depending on the use case, employing this "
"bit-mask multiplexing feature on a futex can be less efficient than simply "
"using multiple futexes, because employing bit-mask multiplexing requires the "
"kernel to check all waiters on a futex, including those that are not "
"interested in being woken up (i.e., they do not have the relevant bit set in "
"their \"wait\" bit mask)."
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:810
msgid ""
"The constant B<FUTEX_BITSET_MATCH_ANY>, which corresponds to all 32 bits set "
"in the bit mask, can be used as the I<val3> argument for "
"B<FUTEX_WAIT_BITSET> and B<FUTEX_WAKE_BITSET>.  Other than differences in "
"the handling of the I<timeout> argument, the B<FUTEX_WAIT> operation is "
"equivalent to B<FUTEX_WAIT_BITSET> with I<val3> specified as "
"B<FUTEX_BITSET_MATCH_ANY>; that is, allow a wake-up by any waker.  The "
"B<FUTEX_WAKE> operation is equivalent to B<FUTEX_WAKE_BITSET> with I<val3> "
"specified as B<FUTEX_BITSET_MATCH_ANY>; that is, wake up any waiter(s)."
msgstr ""

#
#. """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
#. type: Plain text
#: man-pages/man2/futex.2:819
msgid "The I<uaddr2> and I<timeout> arguments are ignored."
msgstr ""

#. type: SS
#: man-pages/man2/futex.2:819
#, no-wrap
msgid "Priority-inheritance futexes"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:829
msgid ""
"Linux supports priority-inheritance (PI) futexes in order to handle "
"priority-inversion problems that can be encountered with normal futex "
"locks.  Priority inversion is the problem that occurs when a high-priority "
"task is blocked waiting to acquire a lock held by a low-priority task, while "
"tasks at an intermediate priority continuously preempt the low-priority task "
"from the CPU.  Consequently, the low-priority task makes no progress toward "
"releasing the lock, and the high-priority task remains blocked."
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:846
msgid ""
"Priority inheritance is a mechanism for dealing with the priority-inversion "
"problem.  With this mechanism, when a high-priority task becomes blocked by "
"a lock held by a low-priority task, the priority of the low-priority task is "
"temporarily raised to that of the high-priority task, so that it is not "
"preempted by any intermediate level tasks, and can thus make progress toward "
"releasing the lock.  To be effective, priority inheritance must be "
"transitive, meaning that if a high-priority task blocks on a lock held by a "
"lower-priority task that is itself blocked by a lock held by another "
"intermediate-priority task (and so on, for chains of arbitrary length), then "
"both of those tasks (or more generally, all of the tasks in a lock chain)  "
"have their priorities raised to be the same as the high-priority task."
msgstr ""

#
#.  Quoting Darren Hart:
#.      These opcodes paired with the PI futex value policy (described below)
#.      defines a "futex" as PI aware. These were created very specifically
#.      in support of PI pthread_mutexes, so it makes a lot more sense to
#.      talk about a PI aware pthread_mutex, than a PI aware futex, since
#.      there is a lot of policy and scaffolding that has to be built up
#.      around it to use it properly (this is what a PI pthread_mutex is).
#. type: Plain text
#: man-pages/man2/futex.2:862
msgid ""
"From a user-space perspective, what makes a futex PI-aware is a policy "
"agreement (described below)  between user space and the kernel about the "
"value of the futex word, coupled with the use of the PI-futex operations "
"described below.  (Unlike the other futex operations described above, the "
"PI-futex operations are designed for the implementation of very specific IPC "
"mechanisms.)"
msgstr ""

#.        mtk: The following text is drawn from the Hart/Guniguntala paper
#.        (listed in SEE ALSO), but I have reworded some pieces
#.        significantly.
#. type: Plain text
#: man-pages/man2/futex.2:870
msgid ""
"The PI-futex operations described below differ from the other futex "
"operations in that they impose policy on the use of the value of the futex "
"word:"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:872
msgid "If the lock is not acquired, the futex word's value shall be 0."
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:878
msgid ""
"If the lock is acquired, the futex word's value shall be the thread ID (TID; "
"see B<gettid>(2))  of the owning thread."
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:883
msgid ""
"If the lock is owned and there are threads contending for the lock, then the "
"B<FUTEX_WAITERS> bit shall be set in the futex word's value; in other words, "
"this value is:"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:885
#, no-wrap
msgid "    FUTEX_WAITERS | TID\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:889
msgid ""
"(Note that is invalid for a PI futex word to have no owner and "
"B<FUTEX_WAITERS> set.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:900
msgid ""
"With this policy in place, a user-space application can acquire an "
"unacquired lock or release a lock using atomic instructions executed in user "
"mode (e.g., a compare-and-swap operation such as I<cmpxchg> on the x86 "
"architecture).  Acquiring a lock simply consists of using compare-and-swap "
"to atomically set the futex word's value to the caller's TID if its previous "
"value was 0.  Releasing a lock requires using compare-and-swap to set the "
"futex word's value to 0 if the previous value was the expected TID."
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:911
msgid ""
"If a futex is already acquired (i.e., has a nonzero value), waiters must "
"employ the B<FUTEX_LOCK_PI> operation to acquire the lock.  If other threads "
"are waiting for the lock, then the B<FUTEX_WAITERS> bit is set in the futex "
"value; in this case, the lock owner must employ the B<FUTEX_UNLOCK_PI> "
"operation to release the lock."
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:921
msgid ""
"In the cases where callers are forced into the kernel (i.e., required to "
"perform a B<futex>()  call), they then deal directly with a so-called "
"RT-mutex, a kernel locking mechanism which implements the required "
"priority-inheritance semantics.  After the RT-mutex is acquired, the futex "
"value is updated accordingly, before the calling thread returns to user "
"space."
msgstr ""

#.  tglx (July 2015):
#.      If there are multiple waiters on a pi futex then a wake pi operation
#.      will wake the first waiter and hand over the lock to this waiter. This
#.      includes handing over the rtmutex which represents the futex in the
#.      kernel. The strict requirement is that the futex owner and the rtmutex
#.      owner must be the same, except for the update period which is
#.      serialized by the futex internal locking. That means the kernel must
#.      update the user-space value prior to returning to user space
#. type: Plain text
#: man-pages/man2/futex.2:938
msgid ""
"It is important to note that the kernel will update the futex word's value "
"prior to returning to user space.  (This prevents the possibility of the "
"futex word's value ending up in an invalid state, such as having an owner "
"but the value being 0, or having waiters but not having the B<FUTEX_WAITERS> "
"bit set.)"
msgstr ""

#.  tglx (July 2015):
#.      The FUTEX_OWNER_DIED bit can also be set on uncontended futexes, where
#.      the kernel has no state associated. This happens via the robust futex
#.      mechanism. In that case the futex value will be set to
#.      FUTEX_OWNER_DIED. The robust futex mechanism is also available for non
#.      PI futexes.
#. type: Plain text
#: man-pages/man2/futex.2:957
msgid ""
"If a futex has an associated RT-mutex in the kernel (i.e., there are blocked "
"waiters)  and the owner of the futex/RT-mutex dies unexpectedly, then the "
"kernel cleans up the RT-mutex and hands it over to the next waiter.  This in "
"turn requires that the user-space value is updated accordingly.  To indicate "
"that this is required, the kernel sets the B<FUTEX_OWNER_DIED> bit in the "
"futex word along with the thread ID of the new owner.  User space can detect "
"this situation via the presence of the B<FUTEX_OWNER_DIED> bit and is then "
"responsible for cleaning up the stale state left over by the dead owner."
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:962
msgid ""
"PI futexes are operated on by specifying one of the values listed below in "
"I<futex_op>.  Note that the PI futex operations must be used as paired "
"operations and are subject to some additional requirements:"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:973
msgid ""
"B<FUTEX_LOCK_PI> and B<FUTEX_TRYLOCK_PI> pair with B<FUTEX_UNLOCK_PI>.  "
"B<FUTEX_UNLOCK_PI> must be called only on a futex owned by the calling "
"thread, as defined by the value policy, otherwise the error B<EPERM> "
"results."
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:987
msgid ""
"B<FUTEX_WAIT_REQUEUE_PI> pairs with B<FUTEX_CMP_REQUEUE_PI>.  This must be "
"performed from a non-PI futex to a distinct PI futex (or the error B<EINVAL> "
"results).  Additionally, I<val> (the number of waiters to be woken) must be "
"1 (or the error B<EINVAL> results)."
msgstr ""

#
#. """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
#. type: Plain text
#: man-pages/man2/futex.2:992
msgid "The PI futex operations are as follows:"
msgstr ""

#. type: TP
#: man-pages/man2/futex.2:992
#, no-wrap
msgid "B<FUTEX_LOCK_PI> (since Linux 2.6.18)"
msgstr ""

#.  commit c87e2837be82df479a6bae9f155c43516d2feebc
#. type: Plain text
#: man-pages/man2/futex.2:999
msgid ""
"This operation is used after an attempt to acquire the lock via an atomic "
"user-mode instruction failed because the futex word has a nonzero "
"value\\(emspecifically, because it contained the (PID-namespace-specific) "
"TID of the lock owner."
msgstr ""

#.  tglx (July 2015):
#.      The operation here is similar to the FUTEX_WAIT logic. When the user
#.      space atomic acquire does not succeed because the futex value was non
#.      zero, then the waiter goes into the kernel, takes the kernel internal
#.      lock and retries the acquisition under the lock. If the acquisition
#.      does not succeed either, then it sets the FUTEX_WAITERS bit, to signal
#.      the lock owner that it needs to go into the kernel. Here is the pseudo
#.      code:
#
#.      	lock(kernel_lock);
#.      retry:
#.      	/*
#.      	 * Owner might have unlocked in userspace before we
#.      	 * were able to set the waiter bit.
#.               */
#.              if (atomic_acquire(futex) == SUCCESS) {
#.      	   unlock(kernel_lock());
#.      	   return 0;
#.      	}
#
#.      	/*
#.      	 * Owner might have unlocked after the above atomic_acquire()
#.      	 * attempt.
#.      	 */
#.      	if (atomic_set_waiters_bit(futex) != SUCCESS)
#.      	   goto retry;
#
#.      	queue_waiter();
#.      	unlock(kernel_lock);
#.      	block();
#. type: Plain text
#: man-pages/man2/futex.2:1042
msgid ""
"The operation checks the value of the futex word at the address I<uaddr>.  "
"If the value is 0, then the kernel tries to atomically set the futex value "
"to the caller's TID.  If the futex word's value is nonzero, the kernel "
"atomically sets the B<FUTEX_WAITERS> bit, which signals the futex owner that "
"it cannot unlock the futex in user space atomically by setting the futex "
"value to 0.  After that, the kernel:"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1045
msgid "Tries to find the thread which is associated with the owner TID."
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1051
msgid ""
"Creates or reuses kernel state on behalf of the owner.  (If this is the "
"first waiter, there is no kernel state for this futex, so kernel state is "
"created by locking the RT-mutex and the futex owner is made the owner of the "
"RT-mutex.  If there are existing waiters, then the existing state is "
"reused.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1054
msgid ""
"Attaches the waiter to the futex (i.e., the waiter is enqueued on the "
"RT-mutex waiter list)."
msgstr ""

#.  August 2015:
#.      mtk: If the realm is restricted purely to SCHED_OTHER (SCHED_NORMAL)
#.           processes, does the nice value come into play also?
#
#.      tglx: No. SCHED_OTHER/NORMAL tasks are handled in FIFO order
#.  (i.e., task 1 blocks on lock A, held by task 2,
#.  while task 2 blocks on lock B, held by task 3)
#. type: Plain text
#: man-pages/man2/futex.2:1082
msgid ""
"If more than one waiter exists, the enqueueing of the waiter is in "
"descending priority order.  (For information on priority ordering, see the "
"discussion of the B<SCHED_DEADLINE>, B<SCHED_FIFO>, and B<SCHED_RR> "
"scheduling policies in B<sched>(7).)  The owner inherits either the waiter's "
"CPU bandwidth (if the waiter is scheduled under the B<SCHED_DEADLINE> "
"policy) or the waiter's priority (if the waiter is scheduled under the "
"B<SCHED_RR> or B<SCHED_FIFO> policy).  This inheritance follows the lock "
"chain in the case of nested locking and performs deadlock detection."
msgstr ""

#.  2016-07-07 response from Thomas Gleixner on LKML:
#.  From: Thomas Gleixner <tglx@linutronix.de>
#.  Date: 6 July 2016 at 20:57
#.  Subject: Re: futex: Allow FUTEX_CLOCK_REALTIME with FUTEX_WAIT op
#
#.  On Thu, 23 Jun 2016, Michael Kerrisk (man-pages) wrote:
#.  > On 06/23/2016 08:28 PM, Darren Hart wrote:
#.  > > And as a follow-on, what is the reason for FUTEX_LOCK_PI only using
#.  > > CLOCK_REALTIME? It seems reasonable to me that a user may want to wait a
#.  > > specific amount of time, regardless of wall time.
#.  >
#.  > Yes, that's another weird inconsistency.
#
#.  The reason is that phtread_mutex_timedlock() uses absolute timeouts based on
#.  CLOCK_REALTIME. glibc folks asked to make that the default behaviour back
#.  then when we added LOCK_PI.
#. type: Plain text
#: man-pages/man2/futex.2:1111
msgid ""
"The I<timeout> argument provides a timeout for the lock attempt.  If "
"I<timeout> is not NULL, the structure it points to specifies an absolute "
"timeout, measured against the B<CLOCK_REALTIME> clock.  If I<timeout> is "
"NULL, the operation will block indefinitely."
msgstr ""

#
#. """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
#. type: Plain text
#: man-pages/man2/futex.2:1121
msgid "The I<uaddr2>, I<val>, and I<val3> arguments are ignored."
msgstr ""

#. type: TP
#: man-pages/man2/futex.2:1121
#, no-wrap
msgid "B<FUTEX_TRYLOCK_PI> (since Linux 2.6.18)"
msgstr ""

#.  commit c87e2837be82df479a6bae9f155c43516d2feebc
#. type: Plain text
#: man-pages/man2/futex.2:1128
msgid ""
"This operation tries to acquire the lock at I<uaddr>.  It is invoked when a "
"user-space atomic acquire did not succeed because the futex word was not 0."
msgstr ""

#.  Paraphrasing a f2f conversation with Thomas Gleixner about the
#.  above point (Aug 2015): ###
#. 	There is a rare possibility of a race condition involving an
#. 	uncontended futex with no owner, but with waiters.  The
#. 	kernel-user-space contract is that if a futex is nonzero, you must
#. 	go into kernel.  The futex was owned by a task, and that task dies
#. 	but there are no waiters, so the futex value is non zero.
#. 	Therefore, the next locker has to go into the kernel,
#. 	so that the kernel has a chance to clean up. (CMXCH on zero
#. 	in user space would fail, so kernel has to clean up.)
#.  Darren Hart (Oct 2015):
#.      The trylock in the kernel has more state, so it can independently
#.      verify the  flags that userspace must trust implicitly.
#. type: Plain text
#: man-pages/man2/futex.2:1152
msgid ""
"Because the kernel has access to more state information than user space, "
"acquisition of the lock might succeed if performed by the kernel in cases "
"where the futex word (i.e., the state information accessible to use-space) "
"contains stale state (B<FUTEX_WAITERS> and/or B<FUTEX_OWNER_DIED>).  This "
"can happen when the owner of the futex died.  User space cannot handle this "
"condition in a race-free manner, but the kernel can fix this up and acquire "
"the futex."
msgstr ""

#
#. """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
#. type: Plain text
#: man-pages/man2/futex.2:1163 man-pages/man2/futex.2:1186
msgid "The I<uaddr2>, I<val>, I<timeout>, and I<val3> arguments are ignored."
msgstr ""

#. type: TP
#: man-pages/man2/futex.2:1163
#, no-wrap
msgid "B<FUTEX_UNLOCK_PI> (since Linux 2.6.18)"
msgstr ""

#.  commit c87e2837be82df479a6bae9f155c43516d2feebc
#. type: Plain text
#: man-pages/man2/futex.2:1171
msgid ""
"This operation wakes the top priority waiter that is waiting in "
"B<FUTEX_LOCK_PI> on the futex address provided by the I<uaddr> argument."
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1175
msgid ""
"This is called when the user-space value at I<uaddr> cannot be changed "
"atomically from a TID (of the owner) to 0."
msgstr ""

#. type: TP
#: man-pages/man2/futex.2:1186
#, no-wrap
msgid "B<FUTEX_CMP_REQUEUE_PI> (since Linux 2.6.31)"
msgstr ""

#.  commit 52400ba946759af28442dee6265c5c0180ac7122
#. type: Plain text
#: man-pages/man2/futex.2:1199
msgid ""
"This operation is a PI-aware variant of B<FUTEX_CMP_REQUEUE>.  It requeues "
"waiters that are blocked via B<FUTEX_WAIT_REQUEUE_PI> on I<uaddr> from a "
"non-PI source futex (I<uaddr>)  to a PI target futex (I<uaddr2>)."
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1215
msgid ""
"As with B<FUTEX_CMP_REQUEUE>, this operation wakes up a maximum of I<val> "
"waiters that are waiting on the futex at I<uaddr>.  However, for "
"B<FUTEX_CMP_REQUEUE_PI>, I<val> is required to be 1 (since the main point is "
"to avoid a thundering herd).  The remaining waiters are removed from the "
"wait queue of the source futex at I<uaddr> and added to the wait queue of "
"the target futex at I<uaddr2>."
msgstr ""

#.  val2 is the cap on the number of requeued waiters.
#.  In the glibc pthread_cond_broadcast() implementation, this argument
#.  is specified as INT_MAX, and for pthread_cond_signal() it is 0.
#
#.        The page at http://locklessinc.com/articles/futex_cheat_sheet/
#.        notes that "priority-inheritance Futex to priority-inheritance
#.        Futex requeues are currently unsupported". However, probably
#.        the page does not need to say nothing about this, since
#.        Thomas Gleixner commented (July 2015): "they never will be
#.        supported because they make no sense at all"
#
#. """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
#. type: Plain text
#: man-pages/man2/futex.2:1235
msgid ""
"The I<val2> and I<val3> arguments serve the same purposes as for "
"B<FUTEX_CMP_REQUEUE>."
msgstr ""

#. type: TP
#: man-pages/man2/futex.2:1235
#, no-wrap
msgid "B<FUTEX_WAIT_REQUEUE_PI> (since Linux 2.6.31)"
msgstr ""

#.  commit 52400ba946759af28442dee6265c5c0180ac7122
#. type: Plain text
#: man-pages/man2/futex.2:1249
msgid ""
"Wait on a non-PI futex at I<uaddr> and potentially be requeued (via a "
"B<FUTEX_CMP_REQUEUE_PI> operation in another task) onto a PI futex at "
"I<uaddr2>.  The wait operation on I<uaddr> is the same as for B<FUTEX_WAIT>."
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1261
msgid ""
"The waiter can be removed from the wait on I<uaddr> without requeueing on "
"I<uaddr2> via a B<FUTEX_WAKE> operation in another task.  In this case, the "
"B<FUTEX_WAIT_REQUEUE_PI> operation fails with the error B<EAGAIN>."
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1273
msgid "The I<val3> argument is ignored."
msgstr ""

#
#.  Darren Hart notes that a patch to allow glibc to fully support
#.  PI-aware pthreads condition variables has not yet been accepted into
#.  glibc. The story is complex, and can be found at
#.  https://sourceware.org/bugzilla/show_bug.cgi?id=11588
#.  Darren notes that in the meantime, the patch is shipped with various
#.  PREEMPT_RT-enabled Linux systems.
#
#.  Related to the preceding, Darren proposed that somewhere, man-pages
#.  should document the following point:
#
#.      While the Linux kernel, since 2.6.31, supports requeueing of
#.      priority-inheritance (PI) aware mutexes via the
#.      FUTEX_WAIT_REQUEUE_PI and FUTEX_CMP_REQUEUE_PI futex operations,
#.      the glibc implementation does not yet take full advantage of this.
#.      Specifically, the condvar internal data lock remains a non-PI aware
#.      mutex, regardless of the type of the pthread_mutex associated with
#.      the condvar. This can lead to an unbounded priority inversion on
#.      the internal data lock even when associating a PI aware
#.      pthread_mutex with a condvar during a pthread_cond*_wait
#.      operation. For this reason, it is not recommended to rely on
#.      priority inheritance when using pthread condition variables.
#
#.  The problem is that the obvious location for this text is
#.  the pthread_cond*wait(3) man page. However, such a man page
#.  does not currently exist.
#
#. """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
#. type: Plain text
#: man-pages/man2/futex.2:1317
msgid ""
"The B<FUTEX_WAIT_REQUEUE_PI> and B<FUTEX_CMP_REQUEUE_PI> were added to "
"support a fairly specific use case: support for priority-inheritance-aware "
"POSIX threads condition variables.  The idea is that these operations should "
"always be paired, in order to ensure that user space and the kernel remain "
"in sync.  Thus, in the B<FUTEX_WAIT_REQUEUE_PI> operation, the user-space "
"application pre-specifies the target of the requeue that takes place in the "
"B<FUTEX_CMP_REQUEUE_PI> operation."
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1326
msgid ""
"In the event of an error (and assuming that B<futex>()  was invoked via "
"B<syscall>(2)), all operations return -1 and set I<errno> to indicate the "
"cause of the error."
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1329
msgid ""
"The return value on success depends on the operation, as described in the "
"following list:"
msgstr ""

#. type: TP
#: man-pages/man2/futex.2:1329
#, no-wrap
msgid "B<FUTEX_WAIT>"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1340
msgid ""
"Returns 0 if the caller was woken up.  Note that a wake-up can also be "
"caused by common futex usage patterns in unrelated code that happened to "
"have previously used the futex word's memory location (e.g., typical "
"futex-based implementations of Pthreads mutexes can cause this under some "
"conditions).  Therefore, callers should always conservatively assume that a "
"return value of 0 can mean a spurious wake-up, and use the futex word's "
"value (i.e., the user-space synchronization scheme)  to decide whether to "
"continue to block or not."
msgstr ""

#. type: TP
#: man-pages/man2/futex.2:1340
#, no-wrap
msgid "B<FUTEX_WAKE>"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1343 man-pages/man2/futex.2:1349
#: man-pages/man2/futex.2:1376
msgid "Returns the number of waiters that were woken up."
msgstr ""

#. type: TP
#: man-pages/man2/futex.2:1343
#, no-wrap
msgid "B<FUTEX_FD>"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1346
msgid "Returns the new file descriptor associated with the futex."
msgstr ""

#. type: TP
#: man-pages/man2/futex.2:1346
#, no-wrap
msgid "B<FUTEX_REQUEUE>"
msgstr ""

#. type: TP
#: man-pages/man2/futex.2:1349
#, no-wrap
msgid "B<FUTEX_CMP_REQUEUE>"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1359
msgid ""
"Returns the total number of waiters that were woken up or requeued to the "
"futex for the futex word at I<uaddr2>.  If this value is greater than "
"I<val>, then the difference is the number of waiters requeued to the futex "
"for the futex word at I<uaddr2>."
msgstr ""

#. type: TP
#: man-pages/man2/futex.2:1359
#, no-wrap
msgid "B<FUTEX_WAKE_OP>"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1367
msgid ""
"Returns the total number of waiters that were woken up.  This is the sum of "
"the woken waiters on the two futexes for the futex words at I<uaddr> and "
"I<uaddr2>."
msgstr ""

#. type: TP
#: man-pages/man2/futex.2:1367
#, no-wrap
msgid "B<FUTEX_WAIT_BITSET>"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1373
msgid ""
"Returns 0 if the caller was woken up.  See B<FUTEX_WAIT> for how to "
"interpret this correctly in practice."
msgstr ""

#. type: TP
#: man-pages/man2/futex.2:1373
#, no-wrap
msgid "B<FUTEX_WAKE_BITSET>"
msgstr ""

#. type: TP
#: man-pages/man2/futex.2:1376
#, no-wrap
msgid "B<FUTEX_LOCK_PI>"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1379 man-pages/man2/futex.2:1382
msgid "Returns 0 if the futex was successfully locked."
msgstr ""

#. type: TP
#: man-pages/man2/futex.2:1379
#, no-wrap
msgid "B<FUTEX_TRYLOCK_PI>"
msgstr ""

#. type: TP
#: man-pages/man2/futex.2:1382
#, no-wrap
msgid "B<FUTEX_UNLOCK_PI>"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1385
msgid "Returns 0 if the futex was successfully unlocked."
msgstr ""

#. type: TP
#: man-pages/man2/futex.2:1385
#, no-wrap
msgid "B<FUTEX_CMP_REQUEUE_PI>"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1395
msgid ""
"Returns the total number of waiters that were woken up or requeued to the "
"futex for the futex word at I<uaddr2>.  If this value is greater than "
"I<val>, then difference is the number of waiters requeued to the futex for "
"the futex word at I<uaddr2>."
msgstr ""

#. type: TP
#: man-pages/man2/futex.2:1395
#, no-wrap
msgid "B<FUTEX_WAIT_REQUEUE_PI>"
msgstr ""

#
#. """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
#. type: Plain text
#: man-pages/man2/futex.2:1403
msgid ""
"Returns 0 if the caller was successfully requeued to the futex for the futex "
"word at I<uaddr2>."
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1407
msgid "No read access to the memory of a futex word."
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1417
msgid ""
"(B<FUTEX_WAIT>, B<FUTEX_WAIT_BITSET>, B<FUTEX_WAIT_REQUEUE_PI>)  The value "
"pointed to by I<uaddr> was not equal to the expected value I<val> at the "
"time of the call."
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1425
msgid ""
"B<Note>: on Linux, the symbolic names B<EAGAIN> and B<EWOULDBLOCK> (both of "
"which appear in different parts of the kernel futex code)  have the same "
"value."
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1433
msgid ""
"(B<FUTEX_CMP_REQUEUE>, B<FUTEX_CMP_REQUEUE_PI>)  The value pointed to by "
"I<uaddr> is not equal to the expected value I<val3>."
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1446
msgid ""
"(B<FUTEX_LOCK_PI>, B<FUTEX_TRYLOCK_PI>, B<FUTEX_CMP_REQUEUE_PI>)  The futex "
"owner thread ID of I<uaddr> (for B<FUTEX_CMP_REQUEUE_PI>: I<uaddr2>)  is "
"about to exit, but has not yet handled the internal state cleanup.  Try "
"again."
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1454
msgid ""
"(B<FUTEX_LOCK_PI>, B<FUTEX_TRYLOCK_PI>, B<FUTEX_CMP_REQUEUE_PI>)  The futex "
"word at I<uaddr> is already locked by the caller."
msgstr ""

#.  FIXME . I see that kernel/locking/rtmutex.c uses EDEADLK in some
#.        places, and EDEADLOCK in others. On almost all architectures
#.        these constants are synonymous. Is there a reason that both
#.        names are used?
#
#.        tglx (July 2015): "No. We should probably fix that."
#. type: Plain text
#: man-pages/man2/futex.2:1467
msgid ""
"(B<FUTEX_CMP_REQUEUE_PI>)  While requeueing a waiter to the PI futex for the "
"futex word at I<uaddr2>, the kernel detected a deadlock."
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1475
msgid ""
"A required pointer argument (i.e., I<uaddr>, I<uaddr2>, or I<timeout>)  did "
"not point to a valid user-space address."
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1485
msgid ""
"A B<FUTEX_WAIT> or B<FUTEX_WAIT_BITSET> operation was interrupted by a "
"signal (see B<signal>(7)).  In kernels before Linux 2.6.22, this error could "
"also be returned for a spurious wakeup; since Linux 2.6.22, this no longer "
"happens."
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1496
msgid ""
"The operation in I<futex_op> is one of those that employs a timeout, but the "
"supplied I<timeout> argument was invalid (I<tv_sec> was less than zero, or "
"I<tv_nsec> was not less than 1,000,000,000)."
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1506
msgid ""
"The operation specified in I<futex_op> employs one or both of the pointers "
"I<uaddr> and I<uaddr2>, but one of these does not point to a valid "
"object\\(emthat is, the address is not four-byte-aligned."
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1513
msgid ""
"(B<FUTEX_WAIT_BITSET>, B<FUTEX_WAKE_BITSET>)  The bit mask supplied in "
"I<val3> is zero."
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1520
msgid ""
"(B<FUTEX_CMP_REQUEUE_PI>)  I<uaddr> equals I<uaddr2> (i.e., an attempt was "
"made to requeue to the same futex)."
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1526
msgid "(B<FUTEX_FD>)  The signal number supplied in I<val> is invalid."
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1539
msgid ""
"(B<FUTEX_WAKE>, B<FUTEX_WAKE_OP>, B<FUTEX_WAKE_BITSET>, B<FUTEX_REQUEUE>, "
"B<FUTEX_CMP_REQUEUE>)  The kernel detected an inconsistency between the "
"user-space state at I<uaddr> and the kernel state\\(emthat is, it detected a "
"waiter which waits in B<FUTEX_LOCK_PI> on I<uaddr>."
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1554
msgid ""
"(B<FUTEX_LOCK_PI>, B<FUTEX_TRYLOCK_PI>, B<FUTEX_UNLOCK_PI>)  The kernel "
"detected an inconsistency between the user-space state at I<uaddr> and the "
"kernel state.  This indicates either state corruption or that the kernel "
"found a waiter on I<uaddr> which is waiting via B<FUTEX_WAIT> or "
"B<FUTEX_WAIT_BITSET>."
msgstr ""

#.  From a conversation with Thomas Gleixner (Aug 2015): ###
#. 	The kernel sees: I have non PI state for a futex you tried to
#.      tell me was PI
#. type: Plain text
#: man-pages/man2/futex.2:1569
msgid ""
"(B<FUTEX_CMP_REQUEUE_PI>)  The kernel detected an inconsistency between the "
"user-space state at I<uaddr2> and the kernel state; that is, the kernel "
"detected a waiter which waits via B<FUTEX_WAIT> or B<FUTEX_WAIT_BITSET> on "
"I<uaddr2>."
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1581
msgid ""
"(B<FUTEX_CMP_REQUEUE_PI>)  The kernel detected an inconsistency between the "
"user-space state at I<uaddr> and the kernel state; that is, the kernel "
"detected a waiter which waits via B<FUTEX_WAIT> or B<FUTEX_WAIT_BITESET> on "
"I<uaddr>."
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1593
msgid ""
"(B<FUTEX_CMP_REQUEUE_PI>)  The kernel detected an inconsistency between the "
"user-space state at I<uaddr> and the kernel state; that is, the kernel "
"detected a waiter which waits on I<uaddr> via B<FUTEX_LOCK_PI> (instead of "
"B<FUTEX_WAIT_REQUEUE_PI>)."
msgstr ""

#.  This deals with the case:
#.      wait_requeue_pi(A, B);
#.      requeue_pi(A, C);
#. type: Plain text
#: man-pages/man2/futex.2:1603
msgid ""
"(B<FUTEX_CMP_REQUEUE_PI>)  An attempt was made to requeue a waiter to a "
"futex other than that specified by the matching B<FUTEX_WAIT_REQUEUE_PI> "
"call for that waiter."
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1609
msgid "(B<FUTEX_CMP_REQUEUE_PI>)  The I<val> argument is not 1."
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1612
msgid "Invalid argument."
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1616
msgid ""
"(B<FUTEX_FD>)  The system-wide limit on the total number of open files has "
"been reached."
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1622
msgid ""
"(B<FUTEX_LOCK_PI>, B<FUTEX_TRYLOCK_PI>, B<FUTEX_CMP_REQUEUE_PI>)  The kernel "
"could not allocate memory to hold state information."
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1626
msgid "Invalid operation specified in I<futex_op>."
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1637
msgid ""
"The B<FUTEX_CLOCK_REALTIME> option was specified in I<futex_op>, but the "
"accompanying operation was neither B<FUTEX_WAIT>, B<FUTEX_WAIT_BITSET>, nor "
"B<FUTEX_WAIT_REQUEUE_PI>."
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1647
msgid ""
"(B<FUTEX_LOCK_PI>, B<FUTEX_TRYLOCK_PI>, B<FUTEX_UNLOCK_PI>, "
"B<FUTEX_CMP_REQUEUE_PI>, B<FUTEX_WAIT_REQUEUE_PI>)  A run-time check "
"determined that the operation is not available.  The PI-futex operations are "
"not implemented on all architectures and are not supported on some CPU "
"variants."
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1659
msgid ""
"(B<FUTEX_LOCK_PI>, B<FUTEX_TRYLOCK_PI>, B<FUTEX_CMP_REQUEUE_PI>)  The caller "
"is not allowed to attach itself to the futex at I<uaddr> (for "
"B<FUTEX_CMP_REQUEUE_PI>: the futex at I<uaddr2>).  (This may be caused by a "
"state corruption in user space.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1663
msgid ""
"(B<FUTEX_UNLOCK_PI>)  The caller does not own the lock represented by the "
"futex word."
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1671
msgid ""
"(B<FUTEX_LOCK_PI>, B<FUTEX_TRYLOCK_PI>, B<FUTEX_CMP_REQUEUE_PI>)  The thread "
"ID in the futex word at I<uaddr> does not exist."
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1677
msgid ""
"(B<FUTEX_CMP_REQUEUE_PI>)  The thread ID in the futex word at I<uaddr2> does "
"not exist."
msgstr ""

#
#. """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
#. type: Plain text
#: man-pages/man2/futex.2:1687
msgid ""
"The operation in I<futex_op> employed the timeout specified in I<timeout>, "
"and the timeout expired before the operation completed."
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1691
msgid ""
"Futexes were first made available in a stable kernel release with Linux "
"2.6.0."
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1698
msgid ""
"Initial futex support was merged in Linux 2.5.7 but with different semantics "
"from what was described above.  A four-argument system call with the "
"semantics described in this page was introduced in Linux 2.5.40.  A fifth "
"argument was added in Linux 2.5.70, and a sixth argument was added in Linux "
"2.6.7."
msgstr ""

#.  TODO FIXME(Torvald) Above, we cite this section and claim it contains
#.  details on the synchronization semantics; add the C11 equivalents
#.  here (or whatever we find consensus for).
#
#. """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
#. type: Plain text
#: man-pages/man2/futex.2:1714
msgid ""
"Several higher-level programming abstractions are implemented via futexes, "
"including POSIX semaphores and various POSIX threads synchronization "
"mechanisms (mutexes, condition variables, read-write locks, and barriers)."
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1725
msgid ""
"The program below demonstrates use of futexes in a program where a parent "
"process and a child process use a pair of futexes located inside a shared "
"anonymous mapping to synchronize access to a shared resource: the terminal.  "
"The two processes each write I<nloops> (a command-line argument that "
"defaults to 5 if omitted)  messages to the terminal and employ a "
"synchronization protocol that ensures that they alternate in writing "
"messages.  Upon running this program we see output such as the following:"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1739
#, no-wrap
msgid ""
"$ B<./futex_demo>\n"
"Parent (18534) 0\n"
"Child  (18535) 0\n"
"Parent (18534) 1\n"
"Child  (18535) 1\n"
"Parent (18534) 2\n"
"Child  (18535) 2\n"
"Parent (18534) 3\n"
"Child  (18535) 3\n"
"Parent (18534) 4\n"
"Child  (18535) 4\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1745
#, no-wrap
msgid "/* futex_demo.c\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1748
#, no-wrap
msgid ""
"   Usage: futex_demo [nloops]\n"
"                    (Default: 5)\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1767
#, no-wrap
msgid ""
"   Demonstrate the use of futexes in a program where parent and child\n"
"   use a pair of futexes located inside a shared anonymous mapping to\n"
"   synchronize access to a shared resource: the terminal. The two\n"
"   processes each write \\(aqnum-loops\\(aq messages to the terminal and "
"employ\n"
"   a synchronization protocol that ensures that they alternate in\n"
"   writing messages.\n"
"*/\n"
"#define _GNU_SOURCE\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"
"#include E<lt>stdatomic.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>sys/wait.hE<gt>\n"
"#include E<lt>sys/mman.hE<gt>\n"
"#include E<lt>sys/syscall.hE<gt>\n"
"#include E<lt>linux/futex.hE<gt>\n"
"#include E<lt>sys/time.hE<gt>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1772
#, no-wrap
msgid "static int *futex1, *futex2, *iaddr;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1780
#, no-wrap
msgid ""
"static int\n"
"futex(int *uaddr, int futex_op, int val,\n"
"      const struct timespec *timeout, int *uaddr2, int val3)\n"
"{\n"
"    return syscall(SYS_futex, uaddr, futex_op, val,\n"
"                   timeout, uaddr, val3);\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1783
#, no-wrap
msgid ""
"/* Acquire the futex pointed to by \\(aqfutexp\\(aq: wait for its value to\n"
"   become 1, and then set the value to 0. */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1788
#, no-wrap
msgid ""
"static void\n"
"fwait(int *futexp)\n"
"{\n"
"    int s;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1791
#, no-wrap
msgid ""
"    /* atomic_compare_exchange_strong(ptr, oldval, newval)\n"
"       atomically performs the equivalent of:\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1794
#, no-wrap
msgid ""
"           if (*ptr == *oldval)\n"
"               *ptr = newval;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1796
#, no-wrap
msgid "       It returns true if the test yielded true and *ptr was updated. */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1798
#, no-wrap
msgid "    while (1) {\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1803
#, no-wrap
msgid ""
"        /* Is the futex available? */\n"
"        const int zero = 0;\n"
"        if (atomic_compare_exchange_strong(futexp, &zero, 1))\n"
"            break;      /* Yes */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1805
#, no-wrap
msgid "        /* Futex is not available; wait */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1811
#, no-wrap
msgid ""
"        s = futex(futexp, FUTEX_WAIT, 0, NULL, NULL, 0);\n"
"        if (s == -1 && errno != EAGAIN)\n"
"            errExit(\"futex-FUTEX_WAIT\");\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1815
#, no-wrap
msgid ""
"/* Release the futex pointed to by \\(aqfutexp\\(aq: if the futex "
"currently\n"
"   has the value 0, set its value to 1 and the wake any futex waiters,\n"
"   so that if the peer is blocked in fpost(), it can proceed. */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1820
#, no-wrap
msgid ""
"static void\n"
"fpost(int *futexp)\n"
"{\n"
"    int s;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1822
#, no-wrap
msgid "    /* atomic_compare_exchange_strong() was described in comments above */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1830
#, no-wrap
msgid ""
"    const int one = 1;\n"
"    if (atomic_compare_exchange_strong(futexp, &one, 0)) {\n"
"        s = futex(futexp, FUTEX_WAKE, 1, NULL, NULL, 0);\n"
"        if (s  == -1)\n"
"            errExit(\"futex-FUTEX_WAKE\");\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1836
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    pid_t childPid;\n"
"    int j, nloops;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1838
#, no-wrap
msgid "    setbuf(stdout, NULL);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1840
#, no-wrap
msgid "    nloops = (argc E<gt> 1) ? atoi(argv[1]) : 5;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1845
#, no-wrap
msgid ""
"    /* Create a shared anonymous mapping that will hold the futexes.\n"
"       Since the futexes are being shared between processes, we\n"
"       subsequently use the \"shared\" futex operations (i.e., not the\n"
"       ones suffixed \"_PRIVATE\") */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1850
#, no-wrap
msgid ""
"    iaddr = mmap(NULL, sizeof(int) * 2, PROT_READ | PROT_WRITE,\n"
"                MAP_ANONYMOUS | MAP_SHARED, -1, 0);\n"
"    if (iaddr == MAP_FAILED)\n"
"        errExit(\"mmap\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1853
#, no-wrap
msgid ""
"    futex1 = &iaddr[0];\n"
"    futex2 = &iaddr[1];\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1856
#, no-wrap
msgid ""
"    *futex1 = 0;        /* State: unavailable */\n"
"    *futex2 = 1;        /* State: available */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1859
#, no-wrap
msgid ""
"    /* Create a child process that inherits the shared anonymous\n"
"       mapping */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1863
#, no-wrap
msgid ""
"    childPid = fork();\n"
"    if (childPid == -1)\n"
"        errExit(\"fork\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1870
#, no-wrap
msgid ""
"    if (childPid == 0) {        /* Child */\n"
"        for (j = 0; j E<lt> nloops; j++) {\n"
"            fwait(futex1);\n"
"            printf(\"Child  (%ld) %d\\en\", (long) getpid(), j);\n"
"            fpost(futex2);\n"
"        }\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1873
#, no-wrap
msgid ""
"        exit(EXIT_SUCCESS);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1881
#, no-wrap
msgid ""
"    for (j = 0; j E<lt> nloops; j++) {\n"
"        fwait(futex2);\n"
"        printf(\"Parent (%ld) %d\\en\", (long) getpid(), j);\n"
"        fpost(futex1);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1883
#, no-wrap
msgid "    wait(NULL);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1894
msgid ""
"B<get_robust_list>(2), B<restart_syscall>(2), "
"B<pthread_mutexattr_getprotocol>(3), B<futex>(7), B<sched>(7)"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1896
msgid "The following kernel source files:"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1898
msgid "I<Documentation/pi-futex.txt>"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1900
msgid "I<Documentation/futex-requeue-pi.txt>"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1902
msgid "I<Documentation/locking/rt-mutex.txt>"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1904
msgid "I<Documentation/locking/rt-mutex-design.txt>"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1906
msgid "I<Documentation/robust-futex-ABI.txt>"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1910
msgid ""
"Franke, H., Russell, R., and Kirwood, M., 2002.  I<Fuss, Futexes and "
"Furwocks: Fast Userlevel Locking in Linux> (from proceedings of the Ottawa "
"Linux Symposium 2002),"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1913
msgid ""
"E<.UR http://kernel.org\\:/doc\\:/ols\\:/2002\\:/ols2002-pages-479-495.pdf> "
"E<.UE>"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1917
msgid ""
"Hart, D., 2009. I<A futex overview and update>, E<.UR "
"http://lwn.net/Articles/360699/> E<.UE>"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1923
msgid ""
"Hart, D.\\& and Guniguntala, D., 2009.  I<Requeue-PI: Making Glibc Condvars "
"PI-Aware> (from proceedings of the 2009 Real-Time Linux Workshop), E<.UR "
"http://lwn.net/images/conf/rtlws11/papers/proc/p10.pdf> E<.UE>"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1927
msgid ""
"Drepper, U., 2011. I<Futexes Are Tricky>, E<.UR "
"http://www.akkadia.org/drepper/futex.pdf> E<.UE>"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1929
msgid "Futex example library, futex-*.tar.bz2 at"
msgstr ""

#. type: Plain text
#: man-pages/man2/futex.2:1931
msgid ""
"E<.UR ftp://ftp.kernel.org\\:/pub\\:/linux\\:/kernel\\:/people\\:/rusty/> "
"E<.UE>"
msgstr ""

#. type: TH
#: man-pages/man2/semop.2:35
#, no-wrap
msgid "SEMOP"
msgstr ""

#. type: Plain text
#: man-pages/man2/semop.2:38
msgid "semop, semtimedop - System V semaphore operations"
msgstr ""

#. type: Plain text
#: man-pages/man2/semop.2:45
#, no-wrap
msgid ""
"B<int semop(int >I<semid>B<, struct sembuf *>I<sops>B<, size_t "
">I<nsops>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/semop.2:48
#, no-wrap
msgid ""
"B<int semtimedop(int >I<semid>B<, struct sembuf *>I<sops>B<, size_t "
">I<nsops>B<,>\n"
"B<               const struct timespec *>I<timeout>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/semop.2:57
msgid "B<semtimedop>(): _GNU_SOURCE"
msgstr ""

#. type: Plain text
#: man-pages/man2/semop.2:60
msgid ""
"Each semaphore in a System\\ V semaphore set has the following associated "
"values:"
msgstr ""

#. type: Plain text
#: man-pages/man2/semop.2:67
#, no-wrap
msgid ""
"unsigned short  semval;   /* semaphore value */\n"
"unsigned short  semzcnt;  /* # waiting for zero */\n"
"unsigned short  semncnt;  /* # waiting for increase */\n"
"pid_t           sempid;   /* PID of process that last\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/semop.2:82
msgid ""
"B<semop>()  performs operations on selected semaphores in the set indicated "
"by I<semid>.  Each of the I<nsops> elements in the array pointed to by "
"I<sops> is a structure that specifies an operation to be performed on a "
"single semaphore.  The elements of this structure are of type I<struct "
"sembuf>, containing the following members:"
msgstr ""

#. type: Plain text
#: man-pages/man2/semop.2:88
#, no-wrap
msgid ""
"unsigned short sem_num;  /* semaphore number */\n"
"short          sem_op;   /* semaphore operation */\n"
"short          sem_flg;  /* operation flags */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/semop.2:100
msgid ""
"Flags recognized in I<sem_flg> are B<IPC_NOWAIT> and B<SEM_UNDO>.  If an "
"operation specifies B<SEM_UNDO>, it will be automatically undone when the "
"process terminates."
msgstr ""

#. type: Plain text
#: man-pages/man2/semop.2:115
msgid ""
"The set of operations contained in I<sops> is performed in I<array order>, "
"and I<atomically>, that is, the operations are performed either as a "
"complete unit, or not at all.  The behavior of the system call if not all "
"operations can be performed immediately depends on the presence of the "
"B<IPC_NOWAIT> flag in the individual I<sem_flg> fields, as noted below."
msgstr ""

#. type: Plain text
#: man-pages/man2/semop.2:122
msgid ""
"Each operation is performed on the I<sem_num>-th semaphore of the semaphore "
"set, where the first semaphore of the set is numbered 0.  There are three "
"types of operation, distinguished by the value of I<sem_op>."
msgstr ""

#. type: Plain text
#: man-pages/man2/semop.2:137
msgid ""
"If I<sem_op> is a positive integer, the operation adds this value to the "
"semaphore value (I<semval>).  Furthermore, if B<SEM_UNDO> is specified for "
"this operation, the system subtracts the value I<sem_op> from the semaphore "
"adjustment (I<semadj>)  value for this semaphore.  This operation can always "
"proceed\\(emit never forces a thread to wait.  The calling process must have "
"alter permission on the semaphore set."
msgstr ""

#. type: Plain text
#: man-pages/man2/semop.2:162
msgid ""
"If I<sem_op> is zero, the process must have read permission on the semaphore "
"set.  This is a \"wait-for-zero\" operation: if I<semval> is zero, the "
"operation can immediately proceed.  Otherwise, if B<IPC_NOWAIT> is specified "
"in I<sem_flg>, B<semop>()  fails with I<errno> set to B<EAGAIN> (and none of "
"the operations in I<sops> is performed).  Otherwise, I<semzcnt> (the count "
"of threads waiting until this semaphore's value becomes zero)  is "
"incremented by one and the thread sleeps until one of the following occurs:"
msgstr ""

#. type: Plain text
#: man-pages/man2/semop.2:167
msgid "I<semval> becomes 0, at which time the value of I<semzcnt> is decremented."
msgstr ""

#. type: Plain text
#: man-pages/man2/semop.2:175
msgid ""
"The semaphore set is removed: B<semop>()  fails, with I<errno> set to "
"B<EIDRM>."
msgstr ""

#. type: Plain text
#: man-pages/man2/semop.2:185
msgid ""
"The calling thread catches a signal: the value of I<semzcnt> is decremented "
"and B<semop>()  fails, with I<errno> set to B<EINTR>."
msgstr ""

#. type: Plain text
#: man-pages/man2/semop.2:227
msgid ""
"If I<sem_op> is less than zero, the process must have alter permission on "
"the semaphore set.  If I<semval> is greater than or equal to the absolute "
"value of I<sem_op>, the operation can proceed immediately: the absolute "
"value of I<sem_op> is subtracted from I<semval>, and, if B<SEM_UNDO> is "
"specified for this operation, the system adds the absolute value of "
"I<sem_op> to the semaphore adjustment (I<semadj>)  value for this "
"semaphore.  If the absolute value of I<sem_op> is greater than I<semval>, "
"and B<IPC_NOWAIT> is specified in I<sem_flg>, B<semop>()  fails, with "
"I<errno> set to B<EAGAIN> (and none of the operations in I<sops> is "
"performed).  Otherwise, I<semncnt> (the counter of threads waiting for this "
"semaphore's value to increase)  is incremented by one and the thread sleeps "
"until one of the following occurs:"
msgstr ""

#. type: Plain text
#: man-pages/man2/semop.2:232
msgid ""
"I<semval> becomes greater than or equal to the absolute value of I<sem_op>: "
"the operation now proceeds, as described above."
msgstr ""

#. type: Plain text
#: man-pages/man2/semop.2:239
msgid ""
"The semaphore set is removed from the system: B<semop>()  fails, with "
"I<errno> set to B<EIDRM>."
msgstr ""

#. type: Plain text
#: man-pages/man2/semop.2:249
msgid ""
"The calling thread catches a signal: the value of I<semncnt> is decremented "
"and B<semop>()  fails, with I<errno> set to B<EINTR>."
msgstr ""

#.  and
#.  .I sem_ctime
#. type: Plain text
#: man-pages/man2/semop.2:260
msgid ""
"On successful completion, the I<sempid> value for each semaphore specified "
"in the array pointed to by I<sops> is set to the caller's process ID.  In "
"addition, the I<sem_otime> is set to the current time."
msgstr ""

#. type: SS
#: man-pages/man2/semop.2:260
#, no-wrap
msgid "semtimedop()"
msgstr ""

#. type: Plain text
#: man-pages/man2/semop.2:290
msgid ""
"B<semtimedop>()  behaves identically to B<semop>()  except that in those "
"cases where the calling thread would sleep, the duration of that sleep is "
"limited by the amount of elapsed time specified by the I<timespec> structure "
"whose address is passed in the I<timeout> argument.  (This sleep interval "
"will be rounded up to the system clock granularity, and kernel scheduling "
"delays mean that the interval may overrun by a small amount.)  If the "
"specified time limit has been reached, B<semtimedop>()  fails with I<errno> "
"set to B<EAGAIN> (and none of the operations in I<sops> is performed).  If "
"the I<timeout> argument is NULL, then B<semtimedop>()  behaves exactly like "
"B<semop>()."
msgstr ""

#. type: Plain text
#: man-pages/man2/semop.2:298
msgid ""
"Note that if B<semtimedop>()  is interrupted by a signal, causing the call "
"to fail with the error B<EINTR>, the contents of I<timeout> are left "
"unchanged."
msgstr ""

#. type: Plain text
#: man-pages/man2/semop.2:308
msgid ""
"If successful, B<semop>()  and B<semtimedop>()  return 0; otherwise they "
"return -1 with I<errno> indicating the error."
msgstr ""

#. type: Plain text
#: man-pages/man2/semop.2:320
msgid ""
"The argument I<nsops> is greater than B<SEMOPM>, the maximum number of "
"operations allowed per system call."
msgstr ""

#. type: Plain text
#: man-pages/man2/semop.2:327
msgid ""
"The calling process does not have the permissions required to perform the "
"specified semaphore operations, and does not have the B<CAP_IPC_OWNER> "
"capability in the user namespace that governs its IPC namespace."
msgstr ""

#. type: Plain text
#: man-pages/man2/semop.2:336
msgid ""
"An operation could not proceed immediately and either B<IPC_NOWAIT> was "
"specified in I<sem_flg> or the time limit specified in I<timeout> expired."
msgstr ""

#. type: Plain text
#: man-pages/man2/semop.2:343
msgid ""
"An address specified in either the I<sops> or the I<timeout> argument isn't "
"accessible."
msgstr ""

#. type: Plain text
#: man-pages/man2/semop.2:349
msgid ""
"For some operation the value of I<sem_num> is less than 0 or greater than or "
"equal to the number of semaphores in the set."
msgstr ""

#. type: Plain text
#: man-pages/man2/semop.2:356
msgid ""
"While blocked in this system call, the thread caught a signal; see "
"B<signal>(7)."
msgstr ""

#. type: Plain text
#: man-pages/man2/semop.2:363
msgid ""
"The semaphore set doesn't exist, or I<semid> is less than zero, or I<nsops> "
"has a nonpositive value."
msgstr ""

#. type: Plain text
#: man-pages/man2/semop.2:371
msgid ""
"The I<sem_flg> of some operation specified B<SEM_UNDO> and the system does "
"not have enough memory to allocate the undo structure."
msgstr ""

#. type: Plain text
#: man-pages/man2/semop.2:379
msgid ""
"For some operation I<sem_op+semval> is greater than B<SEMVMX>, the "
"implementation dependent maximum value for I<semval>."
msgstr ""

#. type: Plain text
#: man-pages/man2/semop.2:386
msgid ""
"B<semtimedop>()  first appeared in Linux 2.5.52, and was subsequently "
"backported into kernel 2.4.22.  Glibc support for B<semtimedop>()  first "
"appeared in version 2.3.3."
msgstr ""

#. type: Plain text
#: man-pages/man2/semop.2:410
msgid ""
"The I<sem_undo> structures of a process aren't inherited by the child "
"produced by B<fork>(2), but they are inherited across an B<execve>(2)  "
"system call."
msgstr ""

#. type: Plain text
#: man-pages/man2/semop.2:416
msgid ""
"B<semop>()  is never automatically restarted after being interrupted by a "
"signal handler, regardless of the setting of the B<SA_RESTART> flag when "
"establishing a signal handler."
msgstr ""

#. type: Plain text
#: man-pages/man2/semop.2:449
msgid ""
"A semaphore adjustment (I<semadj>)  value is a per-process, per-semaphore "
"integer that is the negated sum of all operations performed on a semaphore "
"specifying the B<SEM_UNDO> flag.  Each process has a list of I<semadj> "
"values\\(emone value for each semaphore on which it has operated using "
"B<SEM_UNDO>.  When a process terminates, each of its per-semaphore I<semadj> "
"values is added to the corresponding semaphore, thus undoing the effect of "
"that process's operations on the semaphore (but see BUGS below).  When a "
"semaphore's value is directly set using the B<SETVAL> or B<SETALL> request "
"to B<semctl>(2), the corresponding I<semadj> values in all processes are "
"cleared.  The B<clone>(2)  B<CLONE_SYSVSEM> flag allows more than one "
"process to share a I<semadj> list; see B<clone>(2)  for details."
msgstr ""

#. type: Plain text
#: man-pages/man2/semop.2:454
msgid ""
"The I<semval>, I<sempid>, I<semzcnt>, and I<semnct> values for a semaphore "
"can all be retrieved using appropriate B<semctl>(2)  calls."
msgstr ""

#. type: Plain text
#: man-pages/man2/semop.2:458
msgid "The following limits on semaphore set resources affect the B<semop>()  call:"
msgstr ""

#. type: TP
#: man-pages/man2/semop.2:458
#, no-wrap
msgid "B<SEMOPM>"
msgstr ""

#.  commit e843e7d2c88b7db107a86bd2c7145dc715c058f4
#.  This /proc file is not available in Linux 2.2 and earlier -- MTK
#.  See comment in Linux 3.19 source file include/uapi/linux/sem.h
#. type: Plain text
#: man-pages/man2/semop.2:478
msgid ""
"Maximum number of operations allowed for one B<semop>()  call.  Before Linux "
"3.19, the default value for this limit was 32.  Since Linux 3.19, the "
"default value is 500.  On Linux, this limit can be read and modified via the "
"third field of I</proc/sys/kernel/sem>.  I<Note>: this limit should not be "
"raised above 1000, because of the risk of that B<semop>()  fails due to "
"kernel memory fragmentation when allocating memory to copy the I<sops> "
"array."
msgstr ""

#. type: Plain text
#: man-pages/man2/semop.2:483
msgid "Maximum allowable value for I<semval>: implementation dependent (32767)."
msgstr ""

#. type: Plain text
#: man-pages/man2/semop.2:490
msgid ""
"The implementation has no intrinsic limits for the adjust on exit maximum "
"value (B<SEMAEM>), the system wide maximum number of undo structures "
"(B<SEMMNU>)  and the per-process maximum number of undo entries system "
"parameters."
msgstr ""

#. type: Plain text
#: man-pages/man2/semop.2:511
msgid ""
"When a process terminates, its set of associated I<semadj> structures is "
"used to undo the effect of all of the semaphore operations it performed with "
"the B<SEM_UNDO> flag.  This raises a difficulty: if one (or more) of these "
"semaphore adjustments would result in an attempt to decrease a semaphore's "
"value below zero, what should an implementation do? One possible approach "
"would be to block until all the semaphore adjustments could be performed.  "
"This is however undesirable since it could force process termination to "
"block for arbitrarily long periods.  Another possibility is that such "
"semaphore adjustments could be ignored altogether (somewhat analogously to "
"failing when B<IPC_NOWAIT> is specified for a semaphore operation).  Linux "
"adopts a third approach: decreasing the semaphore value as far as possible "
"(i.e., to zero) and allowing process termination to proceed immediately."
msgstr ""

#.  The bug report:
#.  http://marc.theaimsgroup.com/?l=linux-kernel&m=110260821123863&w=2
#.  the fix:
#.  http://marc.theaimsgroup.com/?l=linux-kernel&m=110261701025794&w=2
#. type: Plain text
#: man-pages/man2/semop.2:520
msgid ""
"In kernels 2.6.x, x E<lt>= 10, there is a bug that in some circumstances "
"prevents a thread that is waiting for a semaphore value to become zero from "
"being woken up when the value does actually become zero.  This bug is fixed "
"in kernel 2.6.11."
msgstr ""

#. type: Plain text
#: man-pages/man2/semop.2:525
msgid ""
"The following code segment uses B<semop>()  to atomically wait for the value "
"of semaphore 0 to become zero, and then increment the semaphore value by "
"one."
msgstr ""

#. type: Plain text
#: man-pages/man2/semop.2:530
#, no-wrap
msgid ""
"struct sembuf sops[2];\n"
"int semid;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/semop.2:532
#, no-wrap
msgid "/* Code to set I<semid> omitted */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/semop.2:536
#, no-wrap
msgid ""
"sops[0].sem_num = 0;        /* Operate on semaphore 0 */\n"
"sops[0].sem_op = 0;         /* Wait for value to equal 0 */\n"
"sops[0].sem_flg = 0;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/semop.2:540
#, no-wrap
msgid ""
"sops[1].sem_num = 0;        /* Operate on semaphore 0 */\n"
"sops[1].sem_op = 1;         /* Increment value by one */\n"
"sops[1].sem_flg = 0;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/semop.2:545
#, no-wrap
msgid ""
"if (semop(semid, sops, 2) == -1) {\n"
"    perror(\"semop\");\n"
"    exit(EXIT_FAILURE);\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/semop.2:555
msgid ""
"B<clone>(2), B<semctl>(2), B<semget>(2), B<sigaction>(2), "
"B<capabilities>(7), B<sem_overview>(7), B<sysvipc>(7), B<time>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/vfork.2:29
#, no-wrap
msgid "VFORK"
msgstr ""

#. type: Plain text
#: man-pages/man2/vfork.2:32
msgid "vfork - create a child process and block parent"
msgstr ""

#. type: Plain text
#: man-pages/man2/vfork.2:38
msgid "B<pid_t vfork(void);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/vfork.2:45
msgid "B<vfork>():"
msgstr ""

#. type: TP
#: man-pages/man2/vfork.2:48
#, no-wrap
msgid "Since glibc 2.12:"
msgstr ""

#. type: Plain text
#: man-pages/man2/vfork.2:54
#, no-wrap
msgid ""
"(_XOPEN_SOURCE\\ E<gt>=\\ 500) && ! (_POSIX_C_SOURCE\\ E<gt>=\\ 200809L)\n"
"    || /* Since glibc 2.19: */ _DEFAULT_SOURCE\n"
"    || /* Glibc versions E<lt>= 2.19: */ _BSD_SOURCE\n"
msgstr ""

#. type: SS
#: man-pages/man2/vfork.2:63
#, no-wrap
msgid "Standard description"
msgstr ""

#. type: Plain text
#: man-pages/man2/vfork.2:82
msgid ""
"(From POSIX.1)  The B<vfork>()  function has the same effect as B<fork>(2), "
"except that the behavior is undefined if the process created by B<vfork>()  "
"either modifies any data other than a variable of type I<pid_t> used to "
"store the return value from B<vfork>(), or returns from the function in "
"which B<vfork>()  was called, or calls any other function before "
"successfully calling B<_exit>(2)  or one of the B<exec>(3)  family of "
"functions."
msgstr ""

#. type: SS
#: man-pages/man2/vfork.2:82
#, no-wrap
msgid "Linux description"
msgstr ""

#. type: Plain text
#: man-pages/man2/vfork.2:89
msgid ""
"B<vfork>(), just like B<fork>(2), creates a child process of the calling "
"process.  For details and return value and errors, see B<fork>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/vfork.2:98
msgid ""
"B<vfork>()  is a special case of B<clone>(2).  It is used to create new "
"processes without copying the page tables of the parent process.  It may be "
"useful in performance-sensitive applications where a child is created which "
"then immediately issues an B<execve>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/vfork.2:118
msgid ""
"B<vfork>()  differs from B<fork>(2)  in that the calling thread is suspended "
"until the child terminates (either normally, by calling B<_exit>(2), or "
"abnormally, after delivery of a fatal signal), or it makes a call to "
"B<execve>(2).  Until that point, the child shares all memory with its "
"parent, including the stack.  The child must not return from the current "
"function or call B<exit>(3)  (which would have the effect of calling exit "
"handlers established by the parent process and flushing the parent's "
"B<stdio>(3)  buffers), but may call B<_exit>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/vfork.2:129
msgid ""
"As with B<fork>(2), the child process created by B<vfork>()  inherits copies "
"of various of the caller's process attributes (e.g., file descriptors, "
"signal dispositions, and current working directory); the B<vfork>()  call "
"differs only in the treatment of the virtual address space, as described "
"above."
msgstr ""

#. type: Plain text
#: man-pages/man2/vfork.2:135
msgid ""
"Signals sent to the parent arrive after the child releases the parent's "
"memory (i.e., after the child terminates or calls B<execve>(2))."
msgstr ""

#. type: SS
#: man-pages/man2/vfork.2:135
#, no-wrap
msgid "Historic description"
msgstr ""

#. type: Plain text
#: man-pages/man2/vfork.2:162
msgid ""
"Under Linux, B<fork>(2)  is implemented using copy-on-write pages, so the "
"only penalty incurred by B<fork>(2)  is the time and memory required to "
"duplicate the parent's page tables, and to create a unique task structure "
"for the child.  However, in the bad old days a B<fork>(2)  would require "
"making a complete copy of the caller's data space, often needlessly, since "
"usually immediately afterward an B<exec>(3)  is done.  Thus, for greater "
"efficiency, BSD introduced the B<vfork>()  system call, which did not fully "
"copy the address space of the parent process, but borrowed the parent's "
"memory and thread of control until a call to B<execve>(2)  or an exit "
"occurred.  The parent process was suspended while the child was using its "
"resources.  The use of B<vfork>()  was tricky: for example, not modifying "
"data in the parent process depended on knowing which variables were held in "
"a register."
msgstr ""

#. type: Plain text
#: man-pages/man2/vfork.2:166
msgid ""
"4.3BSD; POSIX.1-2001 (but marked OBSOLETE).  POSIX.1-2008 removes the "
"specification of B<vfork>()."
msgstr ""

#.  In AIXv3.1 vfork is equivalent to fork.
#. type: Plain text
#: man-pages/man2/vfork.2:177
msgid ""
"The requirements put on B<vfork>()  by the standards are weaker than those "
"put on B<fork>(2), so an implementation where the two are synonymous is "
"compliant.  In particular, the programmer cannot rely on the parent "
"remaining blocked until the child either terminates or calls B<execve>(2), "
"and cannot rely on any specific behavior with respect to shared memory."
msgstr ""

#. type: Plain text
#: man-pages/man2/vfork.2:196
msgid ""
"Some consider the semantics of B<vfork>()  to be an architectural blemish, "
"and the 4.2BSD man page stated: \"This system call will be eliminated when "
"proper system sharing mechanisms are implemented.  Users should not depend "
"on the memory sharing semantics of B<vfork>()  as it will, in that case, be "
"made synonymous to B<fork>(2).\" However, even though modern memory "
"management hardware has decreased the performance difference between "
"B<fork>(2)  and B<vfork>(), there are various reasons why Linux and other "
"systems have retained B<vfork>():"
msgstr ""

#. type: Plain text
#: man-pages/man2/vfork.2:200
msgid ""
"Some performance-critical applications require the small performance "
"advantage conferred by B<vfork>()."
msgstr ""

#.  http://stackoverflow.com/questions/4259629/what-is-the-difference-between-fork-and-vfork
#.  http://developers.sun.com/solaris/articles/subprocess/subprocess.html
#.  http://mailman.uclinux.org/pipermail/uclinux-dev/2009-April/000684.html
#. type: Plain text
#: man-pages/man2/vfork.2:217
msgid ""
"B<vfork>()  can be implemented on systems that lack a memory-management unit "
"(MMU), but B<fork>(2)  can't be implemented on such systems.  (POSIX.1-2008 "
"removed B<vfork>()  from the standard; the POSIX rationale for the "
"B<posix_spawn>(3)  function notes that that function, which provides "
"functionality equivalent to B<fork>(2)+B<exec>(3), is designed to be "
"implementable on systems that lack an MMU.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/vfork.2:234
msgid ""
"On systems where memory is constrained, B<vfork>()  avoids the need to "
"temporarily commit memory (see the description of "
"I</proc/sys/vm/overcommit_memory> in B<proc>(5))  in order to execute a new "
"program.  (This can be especially beneficial where a large parent process "
"wishes to execute a small helper program in a child process.)  By contrast, "
"using B<fork>(2)  in this scenario requires either committing an amount of "
"memory equal to the size of the parent process (if strict overcommitting is "
"in force)  or overcommitting memory with the risk that a process is "
"terminated by the out-of-memory (OOM) killer."
msgstr ""

#. type: Plain text
#: man-pages/man2/vfork.2:245
msgid ""
"The child process should take care not to modify the memory in unintended "
"ways, since such changes will be seen by the parent process once the child "
"terminates or executes another program.  In this regard, signal handlers can "
"be especially problematic: if a signal handler that is invoked in the child "
"of B<vfork>()  changes memory, those changes may result in an inconsistent "
"process state from the perspective of the parent process (e.g., memory "
"changes would be visible in the parent, but changes to the state of open "
"file descriptors would not be visible)."
msgstr ""

#. type: Plain text
#: man-pages/man2/vfork.2:271
msgid ""
"When B<vfork>()  is called in a multithreaded process, only the calling "
"thread is suspended until the child terminates or executes a new program.  "
"This means that the child is sharing an address space with other running "
"code.  This can be dangerous if another thread in the parent process changes "
"credentials (using B<setuid>(2)  or similar), since there are now two "
"processes with different privilege levels running in the same address "
"space.  As an example of the dangers, suppose that a multithreaded program "
"running as root creates a child using B<vfork>().  After the B<vfork>(), a "
"thread in the parent process drops the process to an unprivileged user in "
"order to run some untrusted code (e.g., perhaps via plug-in opened with "
"B<dlopen>(3)).  In this case, attacks are possible where the parent process "
"uses B<mmap>(2)  to map in code that will be executed by the privileged "
"child process."
msgstr ""

#. type: Plain text
#: man-pages/man2/vfork.2:282
msgid ""
"Fork handlers established using B<pthread_atfork>(3)  are not called when a "
"multithreaded program employing the NPTL threading library calls "
"B<vfork>().  Fork handlers are called in this case in a program using the "
"LinuxThreads threading library.  (See B<pthreads>(7)  for a description of "
"Linux threading libraries.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/vfork.2:290
msgid ""
"A call to B<vfork>()  is equivalent to calling B<clone>(2)  with I<flags> "
"specified as:"
msgstr ""

#. type: Plain text
#: man-pages/man2/vfork.2:292
#, no-wrap
msgid "     CLONE_VM | CLONE_VFORK | SIGCHLD\n"
msgstr ""

#.  In the release notes for 4.2BSD Sam Leffler wrote: `vfork: Is still
#.  present, but definitely on its way out'.
#. type: Plain text
#: man-pages/man2/vfork.2:310
msgid ""
"The B<vfork>()  system call appeared in 3.0BSD.  In 4.4BSD it was made "
"synonymous to B<fork>(2)  but NetBSD introduced it again; see E<.UR "
"http://www.netbsd.org\\:/Documentation\\:/kernel\\:/vfork.html> E<.UE .> In "
"Linux, it has been equivalent to B<fork>(2)  until 2.2.0-pre6 or so.  Since "
"2.2.0-pre9 (on i386, somewhat later on other architectures) it is an "
"independent system call.  Support was added in glibc 2.0.112."
msgstr ""

#
#.  As far as I can tell, the following is not true in 2.6.19:
#.  Currently (Linux 2.3.25),
#.  .BR strace (1)
#.  cannot follow
#.  .BR vfork ()
#.  and requires a kernel patch.
#. type: Plain text
#: man-pages/man2/vfork.2:331
msgid ""
"Details of the signal handling are obscure and differ between systems.  The "
"BSD man page states: \"To avoid a possible deadlock situation, processes "
"that are children in the middle of a B<vfork>()  are never sent B<SIGTTOU> "
"or B<SIGTTIN> signals; rather, output or I<ioctl>s are allowed and input "
"attempts result in an end-of-file indication.\""
msgstr ""

#. type: Plain text
#: man-pages/man2/vfork.2:337
msgid ""
"B<clone>(2), B<execve>(2), B<_exit>(2), B<fork>(2), B<unshare>(2), "
"B<wait>(2)"
msgstr ""

#. type: TH
#: man-pages/man2/clock_getres.2:30
#, no-wrap
msgid "CLOCK_GETRES"
msgstr ""

#. type: Plain text
#: man-pages/man2/clock_getres.2:33
msgid "clock_getres, clock_gettime, clock_settime - clock and time functions"
msgstr ""

#. type: Plain text
#: man-pages/man2/clock_getres.2:37
msgid "B<int clock_getres(clockid_t >I<clk_id>B<, struct timespec *>I<res>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/clock_getres.2:39
msgid "B<int clock_gettime(clockid_t >I<clk_id>B<, struct timespec *>I<tp>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/clock_getres.2:41
msgid ""
"B<int clock_settime(clockid_t >I<clk_id>B<, const struct timespec "
"*>I<tp>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/clock_getres.2:53
msgid "B<clock_getres>(), B<clock_gettime>(), B<clock_settime>():"
msgstr ""

#. type: Plain text
#: man-pages/man2/clock_getres.2:55
msgid "_POSIX_C_SOURCE\\ E<gt>=\\ 199309L"
msgstr ""

#. type: Plain text
#: man-pages/man2/clock_getres.2:76
msgid ""
"The function B<clock_getres>()  finds the resolution (precision) of the "
"specified clock I<clk_id>, and, if I<res> is non-NULL, stores it in the "
"I<struct timespec> pointed to by I<res>.  The resolution of clocks depends "
"on the implementation and cannot be configured by a particular process.  If "
"the time value pointed to by the argument I<tp> of B<clock_settime>()  is "
"not a multiple of I<res>, then it is truncated to a multiple of I<res>."
msgstr ""

#. type: Plain text
#: man-pages/man2/clock_getres.2:83
msgid ""
"The functions B<clock_gettime>()  and B<clock_settime>()  retrieve and set "
"the time of the specified clock I<clk_id>."
msgstr ""

#. type: Plain text
#: man-pages/man2/clock_getres.2:92
msgid ""
"The I<res> and I<tp> arguments are I<timespec> structures, as specified in "
"I<E<lt>time.hE<gt>>:"
msgstr ""

#. type: Plain text
#: man-pages/man2/clock_getres.2:99
#, no-wrap
msgid ""
"struct timespec {\n"
"    time_t   tv_sec;        /* seconds */\n"
"    long     tv_nsec;       /* nanoseconds */\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/clock_getres.2:107
msgid ""
"The I<clk_id> argument is the identifier of the particular clock on which to "
"act.  A clock may be system-wide and hence visible for all processes, or "
"per-process if it measures time only within a single process."
msgstr ""

#. type: Plain text
#: man-pages/man2/clock_getres.2:114
msgid ""
"All implementations support the system-wide real-time clock, which is "
"identified by B<CLOCK_REALTIME>.  Its time represents seconds and "
"nanoseconds since the Epoch.  When its time is changed, timers for a "
"relative interval are unaffected, but timers for an absolute point in time "
"are affected."
msgstr ""

#. type: Plain text
#: man-pages/man2/clock_getres.2:118
msgid ""
"More clocks may be implemented.  The interpretation of the corresponding "
"time values and the effect on timers is unspecified."
msgstr ""

#. type: Plain text
#: man-pages/man2/clock_getres.2:121
msgid ""
"Sufficiently recent versions of glibc and the Linux kernel support the "
"following clocks:"
msgstr ""

#. type: Plain text
#: man-pages/man2/clock_getres.2:130
msgid ""
"System-wide clock that measures real (i.e., wall-clock) time.  Setting this "
"clock requires appropriate privileges.  This clock is affected by "
"discontinuous jumps in the system time (e.g., if the system administrator "
"manually changes the clock), and by the incremental adjustments performed by "
"B<adjtime>(3)  and NTP."
msgstr ""

#. type: TP
#: man-pages/man2/clock_getres.2:130
#, no-wrap
msgid "B<CLOCK_REALTIME_COARSE> (since Linux 2.6.32; Linux-specific)"
msgstr ""

#.  Added in commit da15cfdae03351c689736f8d142618592e3cebc3
#. type: Plain text
#: man-pages/man2/clock_getres.2:139
msgid ""
"A faster but less precise version of B<CLOCK_REALTIME>.  Use when you need "
"very fast, but not fine-grained timestamps.  Requires per-architecture "
"support, and probably also architecture support for this flag in the "
"B<vdso>(7)."
msgstr ""

#. type: Plain text
#: man-pages/man2/clock_getres.2:145
msgid ""
"Clock that cannot be set and represents monotonic time since\\(emas "
"described by POSIX\\(em\"some unspecified point in the past\".  On Linux, "
"that point corresponds to the number of seconds that the system has been "
"running since it was booted."
msgstr ""

#. type: Plain text
#: man-pages/man2/clock_getres.2:154
msgid ""
"The B<CLOCK_MONOTONIC> clock is not affected by discontinuous jumps in the "
"system time (e.g., if the system administrator manually changes the clock), "
"but is affected by the incremental adjustments performed by B<adjtime>(3)  "
"and NTP.  This clock does not count time that the system is suspended."
msgstr ""

#. type: TP
#: man-pages/man2/clock_getres.2:154
#, no-wrap
msgid "B<CLOCK_MONOTONIC_COARSE> (since Linux 2.6.32; Linux-specific)"
msgstr ""

#.  Added in commit da15cfdae03351c689736f8d142618592e3cebc3
#. type: Plain text
#: man-pages/man2/clock_getres.2:163
msgid ""
"A faster but less precise version of B<CLOCK_MONOTONIC>.  Use when you need "
"very fast, but not fine-grained timestamps.  Requires per-architecture "
"support, and probably also architecture support for this flag in the "
"B<vdso>(7)."
msgstr ""

#. type: TP
#: man-pages/man2/clock_getres.2:163
#, no-wrap
msgid "B<CLOCK_MONOTONIC_RAW> (since Linux 2.6.28; Linux-specific)"
msgstr ""

#.  Added in commit 2d42244ae71d6c7b0884b5664cf2eda30fb2ae68, John Stultz
#. type: Plain text
#: man-pages/man2/clock_getres.2:173
msgid ""
"Similar to B<CLOCK_MONOTONIC>, but provides access to a raw hardware-based "
"time that is not subject to NTP adjustments or the incremental adjustments "
"performed by B<adjtime>(3).  This clock does not count time that the system "
"is suspended."
msgstr ""

#. type: TP
#: man-pages/man2/clock_getres.2:173
#, no-wrap
msgid "B<CLOCK_BOOTTIME> (since Linux 2.6.39; Linux-specific)"
msgstr ""

#.  commit 7fdd7f89006dd5a4c702fa0ce0c272345fa44ae0
#.  commit 70a08cca1227dc31c784ec930099a4417a06e7d0
#. type: Plain text
#: man-pages/man2/clock_getres.2:186
msgid ""
"Identical to B<CLOCK_MONOTONIC>, except it also includes any time that the "
"system is suspended.  This allows applications to get a suspend-aware "
"monotonic clock without having to deal with the complications of "
"B<CLOCK_REALTIME>, which may have discontinuities if the time is changed "
"using B<settimeofday>(2)  or similar."
msgstr ""

#. type: TP
#: man-pages/man2/clock_getres.2:186 man-pages/man2/timer_create.2:70
#, no-wrap
msgid "B<CLOCK_PROCESS_CPUTIME_ID> (since Linux 2.6.12)"
msgstr ""

#. type: Plain text
#: man-pages/man2/clock_getres.2:190
msgid ""
"Per-process CPU-time clock (measures CPU time consumed by all threads in the "
"process)."
msgstr ""

#. type: TP
#: man-pages/man2/clock_getres.2:190 man-pages/man2/timer_create.2:74
#, no-wrap
msgid "B<CLOCK_THREAD_CPUTIME_ID> (since Linux 2.6.12)"
msgstr ""

#. type: Plain text
#: man-pages/man2/clock_getres.2:193
msgid "Thread-specific CPU-time clock."
msgstr ""

#. type: Plain text
#: man-pages/man2/clock_getres.2:201
msgid ""
"B<clock_gettime>(), B<clock_settime>(), and B<clock_getres>()  return 0 for "
"success, or -1 for failure (in which case I<errno> is set appropriately)."
msgstr ""

#. type: Plain text
#: man-pages/man2/clock_getres.2:206
msgid "I<tp> points outside the accessible address space."
msgstr ""

#.  Linux also gives this error on attempts to set CLOCK_PROCESS_CPUTIME_ID
#.  and CLOCK_THREAD_CPUTIME_ID, when probably the proper error should be
#.  EPERM.
#. type: Plain text
#: man-pages/man2/clock_getres.2:214
msgid "The I<clk_id> specified is not supported on this system."
msgstr ""

#. type: Plain text
#: man-pages/man2/clock_getres.2:221
msgid ""
"(B<clock_settime>()): I<tp.tv_sec> is negative or I<tp.tv_nsec> is outside "
"the range [0..999,999,999]."
msgstr ""

#.  commit e1d7ba8735551ed79c7a0463a042353574b96da3
#. type: Plain text
#: man-pages/man2/clock_getres.2:234
msgid ""
"A call to B<clock_settime>()  with a I<clk_id> of B<CLOCK_REALTIME> "
"attempted to set the time to a value less than the current value of the "
"B<CLOCK_MONOTONIC> clock."
msgstr ""

#. type: Plain text
#: man-pages/man2/clock_getres.2:238
msgid "B<clock_settime>()  does not have permission to set the clock indicated."
msgstr ""

#. type: Plain text
#: man-pages/man2/clock_getres.2:240
msgid "These system calls first appeared in Linux 2.6."
msgstr ""

#. type: tbl table
#: man-pages/man2/clock_getres.2:252
#, no-wrap
msgid ""
"B<clock_getres>(),\n"
"B<clock_gettime>(),\n"
"B<clock_settime>()"
msgstr ""

#. type: Plain text
#: man-pages/man2/clock_getres.2:257
msgid "POSIX.1-2001, POSIX.1-2008, SUSv2."
msgstr ""

#. type: Plain text
#: man-pages/man2/clock_getres.2:272
msgid ""
"On POSIX systems on which these functions are available, the symbol "
"B<_POSIX_TIMERS> is defined in I<E<lt>unistd.hE<gt>> to a value greater than "
"0.  The symbols B<_POSIX_MONOTONIC_CLOCK>, B<_POSIX_CPUTIME>, "
"B<_POSIX_THREAD_CPUTIME> indicate that B<CLOCK_MONOTONIC>, "
"B<CLOCK_PROCESS_CPUTIME_ID>, B<CLOCK_THREAD_CPUTIME_ID> are available.  (See "
"also B<sysconf>(3).)"
msgstr ""

#. type: Plain text
#: man-pages/man2/clock_getres.2:274
msgid "POSIX.1 specifies the following:"
msgstr ""

#. type: Plain text
#: man-pages/man2/clock_getres.2:286
msgid ""
"Setting the value of the B<CLOCK_REALTIME> clock via B<clock_settime>()  "
"shall have no effect on threads that are blocked waiting for a relative time "
"service based upon this clock, including the B<nanosleep>()  function; nor "
"on the expiration of relative timers based upon this clock.  Consequently, "
"these time services shall expire when the requested relative interval "
"elapses, independently of the new or old value of the clock."
msgstr ""

#. type: Plain text
#: man-pages/man2/clock_getres.2:294
msgid ""
"On some architectures, an implementation of B<clock_gettime>()  is provided "
"in the B<vdso>(7)."
msgstr ""

#. type: SS
#: man-pages/man2/clock_getres.2:294
#, no-wrap
msgid "Historical note for SMP systems"
msgstr ""

#. type: Plain text
#: man-pages/man2/clock_getres.2:306
msgid ""
"Before Linux added kernel support for B<CLOCK_PROCESS_CPUTIME_ID> and "
"B<CLOCK_THREAD_CPUTIME_ID>, glibc implemented these clocks on many platforms "
"using timer registers from the CPUs (TSC on i386, AR.ITC on Itanium).  These "
"registers may differ between CPUs and as a consequence these clocks may "
"return B<bogus results> if a process is migrated to another CPU."
msgstr ""

#. type: Plain text
#: man-pages/man2/clock_getres.2:317
msgid ""
"If the CPUs in an SMP system have different clock sources, then there is no "
"way to maintain a correlation between the timer registers since each CPU "
"will run at a slightly different frequency.  If that is the case, then "
"I<clock_getcpuclockid(0)> will return B<ENOENT> to signify this condition.  "
"The two clocks will then be useful only if it can be ensured that a process "
"stays on a certain CPU."
msgstr ""

#. type: Plain text
#: man-pages/man2/clock_getres.2:326
msgid ""
"The processors in an SMP system do not start all at exactly the same time "
"and therefore the timer registers are typically running at an offset.  Some "
"architectures include code that attempts to limit these offsets on bootup.  "
"However, the code cannot guarantee to accurately tune the offsets.  Glibc "
"contains no provisions to deal with these offsets (unlike the Linux "
"Kernel).  Typically these offsets are small and therefore the effects may be "
"negligible in most cases."
msgstr ""

#. type: Plain text
#: man-pages/man2/clock_getres.2:335
msgid ""
"Since glibc 2.4, the wrapper functions for the system calls described in "
"this page avoid the abovementioned problems by employing the kernel "
"implementation of B<CLOCK_PROCESS_CPUTIME_ID> and "
"B<CLOCK_THREAD_CPUTIME_ID>, on systems that provide such an implementation "
"(i.e., Linux 2.6.12 and later)."
msgstr ""

#.  See http://bugzilla.kernel.org/show_bug.cgi?id=11972
#. type: Plain text
#: man-pages/man2/clock_getres.2:345
msgid ""
"According to POSIX.1-2001, a process with \"appropriate privileges\" may set "
"the B<CLOCK_PROCESS_CPUTIME_ID> and B<CLOCK_THREAD_CPUTIME_ID> clocks using "
"B<clock_settime>().  On Linux, these clocks are not settable (i.e., no "
"process has \"appropriate privileges\")."
msgstr ""

#. type: Plain text
#: man-pages/man2/clock_getres.2:358
msgid ""
"B<date>(1), B<gettimeofday>(2), B<settimeofday>(2), B<time>(2), "
"B<adjtime>(3), B<clock_getcpuclockid>(3), B<ctime>(3), B<ftime>(3), "
"B<pthread_getcpuclockid>(3), B<sysconf>(3), B<time>(7), B<vdso>(7), "
"B<hwclock>(8)"
msgstr ""

#. type: TH
#: man-pages/man2/getrandom.2:27
#, no-wrap
msgid "GETRANDOM"
msgstr ""

#. type: Plain text
#: man-pages/man2/getrandom.2:30
msgid "getrandom - obtain a series of random bytes"
msgstr ""

#. type: Plain text
#: man-pages/man2/getrandom.2:32
msgid "B<#include E<lt>sys/random.hE<gt>>"
msgstr ""

#. type: Plain text
#: man-pages/man2/getrandom.2:34
msgid ""
"B<ssize_t getrandom(void *>I<buf>B<, size_t >I<buflen>B<, unsigned int "
">I<flags>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/getrandom.2:44
msgid ""
"The B<getrandom>()  system call fills the buffer pointed to by I<buf> with "
"up to I<buflen> random bytes.  These bytes can be used to seed user-space "
"random number generators or for cryptographic purposes."
msgstr ""

#. type: Plain text
#: man-pages/man2/getrandom.2:55
msgid ""
"By default, B<getrandom>()  draws entropy from the I<urandom> source (i.e., "
"the same source as the I</dev/urandom> device).  This behavior can be "
"changed via the I<flags> argument."
msgstr ""

#. type: Plain text
#: man-pages/man2/getrandom.2:65
msgid ""
"If the I<urandom> source has been initialized, reads of up to 256 bytes will "
"always return as many bytes as requested and will not be interrupted by "
"signals.  No such guarantees apply for larger buffer sizes.  For example, if "
"the call is interrupted by a signal handler, it may return a partially "
"filled buffer, or fail with the error B<EINTR>."
msgstr ""

#. type: Plain text
#: man-pages/man2/getrandom.2:74
msgid ""
"If the I<urandom> source has not yet been initialized, then B<getrandom>()  "
"will block, unless B<GRND_NONBLOCK> is specified in I<flags>."
msgstr ""

#. type: Plain text
#: man-pages/man2/getrandom.2:79
msgid ""
"The I<flags> argument is a bit mask that can contain zero or more of the "
"following values ORed together:"
msgstr ""

#. type: TP
#: man-pages/man2/getrandom.2:79
#, no-wrap
msgid "B<GRND_RANDOM>"
msgstr ""

#. type: Plain text
#: man-pages/man2/getrandom.2:104
msgid ""
"If this bit is set, then random bytes are drawn from the I<random> source "
"(i.e., the same source as the I</dev/random> device)  instead of the "
"I<urandom> source.  The I<random> source is limited based on the entropy "
"that can be obtained from environmental noise.  If the number of available "
"bytes in the I<random> source is less than requested in I<buflen>, the call "
"returns just the available random bytes.  If no random bytes are available, "
"the behavior depends on the presence of B<GRND_NONBLOCK> in the I<flags> "
"argument."
msgstr ""

#. type: TP
#: man-pages/man2/getrandom.2:104
#, no-wrap
msgid "B<GRND_NONBLOCK>"
msgstr ""

#. type: Plain text
#: man-pages/man2/getrandom.2:122
msgid ""
"By default, when reading from the I<random> source, B<getrandom>()  blocks "
"if no random bytes are available, and when reading from the I<urandom> "
"source, it blocks if the entropy pool has not yet been initialized.  If the "
"B<GRND_NONBLOCK> flag is set, then B<getrandom>()  does not block in these "
"cases, but instead immediately returns -1 with I<errno> set to B<EAGAIN>."
msgstr ""

#. type: Plain text
#: man-pages/man2/getrandom.2:136
msgid ""
"On success, B<getrandom>()  returns the number of bytes that were copied to "
"the buffer I<buf>.  This may be less than the number of bytes requested via "
"I<buflen> if either B<GRND_RANDOM> was specified in I<flags> and "
"insufficient entropy was present in the I<random> source or the system call "
"was interrupted by a signal."
msgstr ""

#. type: Plain text
#: man-pages/man2/getrandom.2:148
msgid ""
"The requested entropy was not available, and B<getrandom>()  would have "
"blocked if the B<GRND_NONBLOCK> flag was not set."
msgstr ""

#. type: Plain text
#: man-pages/man2/getrandom.2:153
msgid "The address referred to by I<buf> is outside the accessible address space."
msgstr ""

#. type: Plain text
#: man-pages/man2/getrandom.2:163
msgid ""
"The call was interrupted by a signal handler; see the description of how "
"interrupted B<read>(2)  calls on \"slow\" devices are handled with and "
"without the B<SA_RESTART> flag in the B<signal>(7)  man page."
msgstr ""

#. type: Plain text
#: man-pages/man2/getrandom.2:172
msgid ""
"The glibc wrapper function for B<getrandom>()  determined that the "
"underlying kernel does not implement this system call."
msgstr ""

#. type: Plain text
#: man-pages/man2/getrandom.2:176
msgid ""
"B<getrandom>()  was introduced in version 3.17 of the Linux kernel.  Support "
"was added to glibc in version 2.25."
msgstr ""

#. type: Plain text
#: man-pages/man2/getrandom.2:182
msgid ""
"For an overview and comparison of the various interfaces that can be used to "
"obtain randomness, see B<random>(7)."
msgstr ""

#. type: Plain text
#: man-pages/man2/getrandom.2:200
msgid ""
"Unlike I</dev/random> and I</dev/urandom>, B<getrandom>()  does not involve "
"the use of pathnames or file descriptors.  Thus, B<getrandom>()  can be "
"useful in cases where B<chroot>(2)  makes I</dev> pathnames invisible, and "
"where an application (e.g., a daemon during start-up)  closes a file "
"descriptor for one of these files that was opened by a library."
msgstr ""

#. type: SS
#: man-pages/man2/getrandom.2:200
#, no-wrap
msgid "Maximum number of bytes returned"
msgstr ""

#. type: Plain text
#: man-pages/man2/getrandom.2:202
msgid "As of Linux 3.19 the following limits apply:"
msgstr ""

#. type: Plain text
#: man-pages/man2/getrandom.2:210
msgid ""
"When reading from the I<urandom> source, a maximum of 33554431 bytes is "
"returned by a single call to B<getrandom>()  on systems where I<int> has a "
"size of 32 bits."
msgstr ""

#. type: Plain text
#: man-pages/man2/getrandom.2:214
msgid "When reading from the I<random> source, a maximum of 512 bytes is returned."
msgstr ""

#. type: SS
#: man-pages/man2/getrandom.2:214
#, no-wrap
msgid "Interruption by a signal handler"
msgstr ""

#. type: Plain text
#: man-pages/man2/getrandom.2:240
msgid ""
"When reading from the I<urandom> source (B<GRND_RANDOM> is not set), "
"B<getrandom>()  will block until the entropy pool has been initialized "
"(unless the B<GRND_NONBLOCK> flag was specified).  If a request is made to "
"read a large number of bytes (more than 256), B<getrandom>()  will block "
"until those bytes have been generated and transferred from kernel memory to "
"I<buf>.  When reading from the I<random> source (B<GRND_RANDOM> is set), "
"B<getrandom>()  will block until some random bytes become available (unless "
"the B<GRND_NONBLOCK> flag was specified)."
msgstr ""

#. type: Plain text
#: man-pages/man2/getrandom.2:265
msgid ""
"The behavior when a call to B<getrandom>()  that is blocked while reading "
"from the I<urandom> source is interrupted by a signal handler depends on the "
"initialization state of the entropy buffer and on the request size, "
"I<buflen>.  If the entropy is not yet initialized, then the call fails with "
"the B<EINTR> error.  If the entropy pool has been initialized and the "
"request size is large (I<buflen>\\ E<gt>\\ 256), the call either succeeds, "
"returning a partially filled buffer, or fails with the error B<EINTR>.  If "
"the entropy pool has been initialized and the request size is small "
"(I<buflen>\\ E<lt>=\\ 256), then B<getrandom>()  will not fail with "
"B<EINTR>.  Instead, it will return all of the bytes that have been "
"requested."
msgstr ""

#. type: Plain text
#: man-pages/man2/getrandom.2:271
msgid ""
"When reading from the I<random> source, blocking requests of any size can be "
"interrupted by a signal handler (the call fails with the error B<EINTR>)."
msgstr ""

#. type: Plain text
#: man-pages/man2/getrandom.2:277
msgid ""
"Using B<getrandom>()  to read small buffers (E<lt>=\\ 256 bytes) from the "
"I<urandom> source is the preferred mode of usage."
msgstr ""

#. type: Plain text
#: man-pages/man2/getrandom.2:284
msgid ""
"The special treatment of small values of I<buflen> was designed for "
"compatibility with OpenBSD's B<getentropy>(3), which is nowadays supported "
"by glibc."
msgstr ""

#. type: Plain text
#: man-pages/man2/getrandom.2:298
msgid ""
"The user of B<getrandom>()  I<must> always check the return value, to "
"determine whether either an error occurred or fewer bytes than requested "
"were returned.  In the case where B<GRND_RANDOM> is not specified and "
"I<buflen> is less than or equal to 256, a return of fewer bytes than "
"requested should never happen, but the careful programmer will check for "
"this anyway!"
msgstr ""

#.  FIXME patch proposed https://lkml.org/lkml/2014/11/29/16
#. type: Plain text
#: man-pages/man2/getrandom.2:301
msgid "As of Linux 3.19, the following bug exists:"
msgstr ""

#. type: Plain text
#: man-pages/man2/getrandom.2:305
msgid ""
"Depending on CPU load, B<getrandom>()  does not react to interrupts before "
"reading all bytes requested."
msgstr ""

#. type: Plain text
#: man-pages/man2/getrandom.2:310
msgid "B<getentropy>(3), B<random>(4), B<urandom>(4), B<random>(7), B<signal>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/timer_create.2:26
#, no-wrap
msgid "TIMER_CREATE"
msgstr ""

#. type: Plain text
#: man-pages/man2/timer_create.2:29
msgid "timer_create - create a POSIX per-process timer"
msgstr ""

#. type: Plain text
#: man-pages/man2/timer_create.2:33
#, no-wrap
msgid ""
"B<#include E<lt>signal.hE<gt>>\n"
"B<#include E<lt>time.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/timer_create.2:36
#, no-wrap
msgid ""
"B<int timer_create(clockid_t >I<clockid>B<, struct sigevent *>I<sevp>B<,>\n"
"B<                 timer_t *>I<timerid>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/timer_create.2:47
msgid "B<timer_create>(): _POSIX_C_SOURCE\\ E<gt>=\\ 199309L"
msgstr ""

#. type: Plain text
#: man-pages/man2/timer_create.2:55
msgid ""
"B<timer_create>()  creates a new per-process interval timer.  The ID of the "
"new timer is returned in the buffer pointed to by I<timerid>, which must be "
"a non-null pointer.  This ID is unique within the process, until the timer "
"is deleted.  The new timer is initially disarmed."
msgstr ""

#. type: Plain text
#: man-pages/man2/timer_create.2:60
msgid ""
"The I<clockid> argument specifies the clock that the new timer uses to "
"measure time.  It can be specified as one of the following values:"
msgstr ""

#. type: Plain text
#: man-pages/man2/timer_create.2:74
msgid ""
"A clock that measures (user and system) CPU time consumed by (all of the "
"threads in) the calling process."
msgstr ""

#.  The CLOCK_MONOTONIC_RAW that was added in 2.6.28 can't be used
#.  to create a timer -- mtk, Feb 2009
#. type: Plain text
#: man-pages/man2/timer_create.2:80
msgid ""
"A clock that measures (user and system) CPU time consumed by the calling "
"thread."
msgstr ""

#. type: TP
#: man-pages/man2/timer_create.2:80
#, no-wrap
msgid "B<CLOCK_BOOTTIME> (Since Linux 2.6.39)"
msgstr ""

#. type: TP
#: man-pages/man2/timer_create.2:95
#, no-wrap
msgid "B<CLOCK_REALTIME_ALARM> (since Linux 3.0)"
msgstr ""

#. type: TP
#: man-pages/man2/timer_create.2:104
#, no-wrap
msgid "B<CLOCK_BOOTTIME_ALARM> (since Linux 3.0)"
msgstr ""

#. type: Plain text
#: man-pages/man2/timer_create.2:122
msgid ""
"As well as the above values, I<clockid> can be specified as the I<clockid> "
"returned by a call to B<clock_getcpuclockid>(3)  or "
"B<pthread_getcpuclockid>(3)."
msgstr ""

#. type: Plain text
#: man-pages/man2/timer_create.2:131
msgid ""
"The I<sevp> argument points to a I<sigevent> structure that specifies how "
"the caller should be notified when the timer expires.  For the definition "
"and general details of this structure, see B<sigevent>(7)."
msgstr ""

#. type: Plain text
#: man-pages/man2/timer_create.2:135
msgid "The I<sevp.sigev_notify> field can have the following values:"
msgstr ""

#. type: TP
#: man-pages/man2/timer_create.2:135
#, no-wrap
msgid "B<SIGEV_NONE>"
msgstr ""

#. type: Plain text
#: man-pages/man2/timer_create.2:140
msgid ""
"Don't asynchronously notify when the timer expires.  Progress of the timer "
"can be monitored using B<timer_gettime>(2)."
msgstr ""

#. type: TP
#: man-pages/man2/timer_create.2:140
#, no-wrap
msgid "B<SIGEV_SIGNAL>"
msgstr ""

#. type: Plain text
#: man-pages/man2/timer_create.2:158
msgid ""
"Upon timer expiration, generate the signal I<sigev_signo> for the process.  "
"See B<sigevent>(7)  for general details.  The I<si_code> field of the "
"I<siginfo_t> structure will be set to B<SI_TIMER>.  At any point in time, at "
"most one signal is queued to the process for a given timer; see "
"B<timer_getoverrun>(2)  for more details."
msgstr ""

#. type: TP
#: man-pages/man2/timer_create.2:158
#, no-wrap
msgid "B<SIGEV_THREAD>"
msgstr ""

#. type: Plain text
#: man-pages/man2/timer_create.2:166
msgid ""
"Upon timer expiration, invoke I<sigev_notify_function> as if it were the "
"start function of a new thread.  See B<sigevent>(7)  for details."
msgstr ""

#. type: TP
#: man-pages/man2/timer_create.2:166
#, no-wrap
msgid "B<SIGEV_THREAD_ID> (Linux-specific)"
msgstr ""

#. type: Plain text
#: man-pages/man2/timer_create.2:180
msgid ""
"As for B<SIGEV_SIGNAL>, but the signal is targeted at the thread whose ID is "
"given in I<sigev_notify_thread_id>, which must be a thread in the same "
"process as the caller.  The I<sigev_notify_thread_id> field specifies a "
"kernel thread ID, that is, the value returned by B<clone>(2)  or "
"B<gettid>(2).  This flag is intended only for use by threading libraries."
msgstr ""

#. type: Plain text
#: man-pages/man2/timer_create.2:195
msgid ""
"Specifying I<sevp> as NULL is equivalent to specifying a pointer to a "
"I<sigevent> structure in which I<sigev_notify> is B<SIGEV_SIGNAL>, "
"I<sigev_signo> is B<SIGALRM>, and I<sigev_value.sival_int> is the timer ID."
msgstr ""

#. type: Plain text
#: man-pages/man2/timer_create.2:203
msgid ""
"On success, B<timer_create>()  returns 0, and the ID of the new timer is "
"placed in I<*timerid>.  On failure, -1 is returned, and I<errno> is set to "
"indicate the error."
msgstr ""

#. type: Plain text
#: man-pages/man2/timer_create.2:207
msgid "Temporary error during kernel allocation of timer structures."
msgstr ""

#. type: Plain text
#: man-pages/man2/timer_create.2:215
msgid ""
"Clock ID, I<sigev_notify>, I<sigev_signo>, or I<sigev_notify_thread_id> is "
"invalid."
msgstr ""

#. type: Plain text
#: man-pages/man2/timer_create.2:226
msgid "A program may create multiple interval timers using B<timer_create>()."
msgstr ""

#. type: Plain text
#: man-pages/man2/timer_create.2:231
msgid ""
"Timers are not inherited by the child of a B<fork>(2), and are disarmed and "
"deleted during an B<execve>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/timer_create.2:239
msgid ""
"The kernel preallocates a \"queued real-time signal\" for each timer created "
"using B<timer_create>().  Consequently, the number of timers is limited by "
"the B<RLIMIT_SIGPENDING> resource limit (see B<setrlimit>(2))."
msgstr ""

#. type: Plain text
#: man-pages/man2/timer_create.2:244
msgid ""
"The timers created by B<timer_create>()  are commonly known as \"POSIX "
"(interval) timers\".  The POSIX timers API consists of the following "
"interfaces:"
msgstr ""

#. type: Plain text
#: man-pages/man2/timer_create.2:247
msgid "B<timer_create>(): Create a timer."
msgstr ""

#. type: Plain text
#: man-pages/man2/timer_create.2:250
msgid "B<timer_settime>(2): Arm (start) or disarm (stop) a timer."
msgstr ""

#. type: Plain text
#: man-pages/man2/timer_create.2:254
msgid ""
"B<timer_gettime>(2): Fetch the time remaining until the next expiration of a "
"timer, along with the interval setting of the timer."
msgstr ""

#. type: Plain text
#: man-pages/man2/timer_create.2:257
msgid ""
"B<timer_getoverrun>(2): Return the overrun count for the last timer "
"expiration."
msgstr ""

#. type: Plain text
#: man-pages/man2/timer_create.2:260
msgid "B<timer_delete>(2): Disarm and delete a timer."
msgstr ""

#. type: Plain text
#: man-pages/man2/timer_create.2:268
msgid ""
"Since Linux 3.10, the I</proc/[pid]/timers> file can be used to list the "
"POSIX timers for the process with PID I<pid>.  See B<proc>(5)  for further "
"information."
msgstr ""

#.  baa73d9e478ff32d62f3f9422822b59dd9a95a21
#. type: Plain text
#: man-pages/man2/timer_create.2:276
msgid ""
"Since Linux 4.10, support for POSIX timers is a configurable option that is "
"enabled by default.  Kernel support can be disabled via the "
"B<CONFIG_POSIX_TIMERS> option."
msgstr ""

#.  See nptl/sysdeps/unix/sysv/linux/timer_create.c
#. type: Plain text
#: man-pages/man2/timer_create.2:280
msgid ""
"Part of the implementation of the POSIX timers API is provided by glibc.  In "
"particular:"
msgstr ""

#. type: Plain text
#: man-pages/man2/timer_create.2:294
msgid ""
"Much of the functionality for B<SIGEV_THREAD> is implemented within glibc, "
"rather than the kernel.  (This is necessarily so, since the thread involved "
"in handling the notification is one that must be managed by the C library "
"POSIX threads implementation.)  Although the notification delivered to the "
"process is via a thread, internally the NPTL implementation uses a "
"I<sigev_notify> value of B<SIGEV_THREAD_ID> along with a real-time signal "
"that is reserved by the implementation (see B<nptl>(7))."
msgstr ""

#. type: Plain text
#: man-pages/man2/timer_create.2:301
msgid ""
"The implementation of the default case where I<evp> is NULL is handled "
"inside glibc, which invokes the underlying system call with a suitably "
"populated I<sigevent> structure."
msgstr ""

#.  See the glibc source file kernel-posix-timers.h for the structure
#.  that glibc uses to map user-space timer IDs to kernel timer IDs
#.  The kernel-level timer ID is exposed via siginfo.si_tid.
#. type: Plain text
#: man-pages/man2/timer_create.2:307
msgid ""
"The timer IDs presented at user level are maintained by glibc, which maps "
"these IDs to the timer IDs employed by the kernel."
msgstr ""

#.  glibc commit 93a78ac437ba44f493333d7e2a4b0249839ce460
#. type: Plain text
#: man-pages/man2/timer_create.2:317
msgid ""
"The POSIX timers system calls first appeared in Linux 2.6.  Prior to this, "
"glibc provided an incomplete user-space implementation (B<CLOCK_REALTIME> "
"timers only) using POSIX threads, and in glibc versions before 2.17, the "
"implementation falls back to this technique on systems running pre-2.6 Linux "
"kernels."
msgstr ""

#. type: Plain text
#: man-pages/man2/timer_create.2:329
msgid ""
"The program below takes two arguments: a sleep period in seconds, and a "
"timer frequency in nanoseconds.  The program establishes a handler for the "
"signal it uses for the timer, blocks that signal, creates and arms a timer "
"that expires with the given frequency, sleeps for the specified number of "
"seconds, and then unblocks the timer signal.  Assuming that the timer "
"expired at least once while the program slept, the signal handler will be "
"invoked, and the handler displays some information about the timer "
"notification.  The program terminates after one invocation of the signal "
"handler."
msgstr ""

#. type: Plain text
#: man-pages/man2/timer_create.2:334
msgid ""
"In the following example run, the program sleeps for 1 second, after "
"creating a timer that has a frequency of 100 nanoseconds.  By the time the "
"signal is unblocked and delivered, there have been around ten million "
"overruns."
msgstr ""

#. type: Plain text
#: man-pages/man2/timer_create.2:346
#, no-wrap
msgid ""
"$ B<./a.out 1 100>\n"
"Establishing handler for signal 34\n"
"Blocking signal 34\n"
"timer ID is 0x804c008\n"
"Sleeping for 1 seconds\n"
"Unblocking signal 34\n"
"Caught signal 34\n"
"    sival_ptr = 0xbfb174f4;     *sival_ptr = 0x804c008\n"
"    overrun count = 10004886\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/timer_create.2:356
#, no-wrap
msgid ""
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>signal.hE<gt>\n"
"#include E<lt>time.hE<gt>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/timer_create.2:359
#, no-wrap
msgid ""
"#define CLOCKID CLOCK_REALTIME\n"
"#define SIG SIGRTMIN\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/timer_create.2:368
#, no-wrap
msgid ""
"static void\n"
"print_siginfo(siginfo_t *si)\n"
"{\n"
"    timer_t *tidp;\n"
"    int or;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/timer_create.2:370
#, no-wrap
msgid "    tidp = si-E<gt>si_value.sival_ptr;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/timer_create.2:373
#, no-wrap
msgid ""
"    printf(\"    sival_ptr = %p; \", si-E<gt>si_value.sival_ptr);\n"
"    printf(\"    *sival_ptr = 0x%lx\\en\", (long) *tidp);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/timer_create.2:380
#, no-wrap
msgid ""
"    or = timer_getoverrun(*tidp);\n"
"    if (or == -1)\n"
"        errExit(\"timer_getoverrun\");\n"
"    else\n"
"        printf(\"    overrun count = %d\\en\", or);\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/timer_create.2:389
#, no-wrap
msgid ""
"static void\n"
"handler(int sig, siginfo_t *si, void *uc)\n"
"{\n"
"    /* Note: calling printf() from a signal handler is not safe\n"
"       (and should not be done in production programs), since\n"
"       printf() is not async-signal-safe; see signal-safety(7).\n"
"       Nevertheless, we use printf() here as a simple way of\n"
"       showing that the handler was called. */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/timer_create.2:394
#, no-wrap
msgid ""
"    printf(\"Caught signal %d\\en\", sig);\n"
"    print_siginfo(si);\n"
"    signal(sig, SIG_IGN);\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/timer_create.2:404
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    timer_t timerid;\n"
"    struct sigevent sev;\n"
"    struct itimerspec its;\n"
"    long long freq_nanosecs;\n"
"    sigset_t mask;\n"
"    struct sigaction sa;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/timer_create.2:410
#, no-wrap
msgid ""
"    if (argc != 3) {\n"
"        fprintf(stderr, \"Usage: %s E<lt>sleep-secsE<gt> "
"E<lt>freq-nanosecsE<gt>\\en\",\n"
"                argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/timer_create.2:412
#, no-wrap
msgid "    /* Establish handler for timer signal */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/timer_create.2:419
#, no-wrap
msgid ""
"    printf(\"Establishing handler for signal %d\\en\", SIG);\n"
"    sa.sa_flags = SA_SIGINFO;\n"
"    sa.sa_sigaction = handler;\n"
"    sigemptyset(&sa.sa_mask);\n"
"    if (sigaction(SIG, &sa, NULL) == -1)\n"
"        errExit(\"sigaction\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/timer_create.2:421
#, no-wrap
msgid "    /* Block timer signal temporarily */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/timer_create.2:427
#, no-wrap
msgid ""
"    printf(\"Blocking signal %d\\en\", SIG);\n"
"    sigemptyset(&mask);\n"
"    sigaddset(&mask, SIG);\n"
"    if (sigprocmask(SIG_SETMASK, &mask, NULL) == -1)\n"
"        errExit(\"sigprocmask\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/timer_create.2:429
#, no-wrap
msgid "    /* Create the timer */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/timer_create.2:435
#, no-wrap
msgid ""
"    sev.sigev_notify = SIGEV_SIGNAL;\n"
"    sev.sigev_signo = SIG;\n"
"    sev.sigev_value.sival_ptr = &timerid;\n"
"    if (timer_create(CLOCKID, &sev, &timerid) == -1)\n"
"        errExit(\"timer_create\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/timer_create.2:437
#, no-wrap
msgid "    printf(\"timer ID is 0x%lx\\en\", (long) timerid);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/timer_create.2:439
#, no-wrap
msgid "    /* Start the timer */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/timer_create.2:445
#, no-wrap
msgid ""
"    freq_nanosecs = atoll(argv[2]);\n"
"    its.it_value.tv_sec = freq_nanosecs / 1000000000;\n"
"    its.it_value.tv_nsec = freq_nanosecs % 1000000000;\n"
"    its.it_interval.tv_sec = its.it_value.tv_sec;\n"
"    its.it_interval.tv_nsec = its.it_value.tv_nsec;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/timer_create.2:448
#, no-wrap
msgid ""
"    if (timer_settime(timerid, 0, &its, NULL) == -1)\n"
"         errExit(\"timer_settime\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/timer_create.2:451
#, no-wrap
msgid ""
"    /* Sleep for a while; meanwhile, the timer may expire\n"
"       multiple times */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/timer_create.2:454
#, no-wrap
msgid ""
"    printf(\"Sleeping for %d seconds\\en\", atoi(argv[1]));\n"
"    sleep(atoi(argv[1]));\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/timer_create.2:457
#, no-wrap
msgid ""
"    /* Unlock the timer signal, so that timer notification\n"
"       can be delivered */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/timer_create.2:461
#, no-wrap
msgid ""
"    printf(\"Unblocking signal %d\\en\", SIG);\n"
"    if (sigprocmask(SIG_UNBLOCK, &mask, NULL) == -1)\n"
"        errExit(\"sigprocmask\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/timer_create.2:479
msgid ""
"B<clock_gettime>(2), B<setitimer>(2), B<timer_delete>(2), "
"B<timer_getoverrun>(2), B<timer_settime>(2), B<timerfd_create>(2), "
"B<clock_getcpuclockid>(3), B<pthread_getcpuclockid>(3), B<pthreads>(7), "
"B<sigevent>(7), B<signal>(7), B<time>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/exit_group.2:25
#, no-wrap
msgid "EXIT_GROUP"
msgstr ""

#. type: TH
#: man-pages/man2/exit_group.2:25
#, no-wrap
msgid "2008-11-27"
msgstr ""

#. type: Plain text
#: man-pages/man2/exit_group.2:28
msgid "exit_group - exit all threads in a process"
msgstr ""

#. type: Plain text
#: man-pages/man2/exit_group.2:33
#, no-wrap
msgid "B<void exit_group(int >I<status>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/exit_group.2:39
msgid ""
"This system call is equivalent to B<_exit>(2)  except that it terminates not "
"only the calling thread, but all threads in the calling process's thread "
"group."
msgstr ""

#. type: Plain text
#: man-pages/man2/exit_group.2:41
msgid "This system call does not return."
msgstr ""

#. type: Plain text
#: man-pages/man2/exit_group.2:43
msgid "This call is present since Linux 2.5.35."
msgstr ""

#. type: Plain text
#: man-pages/man2/exit_group.2:49
msgid ""
"Since glibc 2.3, this is the system call invoked when the B<_exit>(2)  "
"wrapper function is called."
msgstr ""

#. type: TH
#: man-pages/man2/times.2:38
#, no-wrap
msgid "TIMES"
msgstr ""

#. type: Plain text
#: man-pages/man2/times.2:41
msgid "times - get process times"
msgstr ""

#. type: Plain text
#: man-pages/man2/times.2:43
msgid "B<#include E<lt>sys/times.hE<gt>>"
msgstr ""

#. type: Plain text
#: man-pages/man2/times.2:45
msgid "B<clock_t times(struct tms *>I<buf>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/times.2:56
msgid ""
"B<times>()  stores the current process times in the I<struct tms> that "
"I<buf> points to.  The I<struct tms> is as defined in "
"I<E<lt>sys/times.hE<gt>>:"
msgstr ""

#. type: Plain text
#: man-pages/man2/times.2:65
#, no-wrap
msgid ""
"struct tms {\n"
"    clock_t tms_utime;  /* user time */\n"
"    clock_t tms_stime;  /* system time */\n"
"    clock_t tms_cutime; /* user time of children */\n"
"    clock_t tms_cstime; /* system time of children */\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/times.2:76
msgid ""
"The I<tms_utime> field contains the CPU time spent executing instructions of "
"the calling process.  The I<tms_stime> field contains the CPU time spent "
"executing inside the kernel while performing tasks on behalf of the calling "
"process."
msgstr ""

#. type: Plain text
#: man-pages/man2/times.2:91
msgid ""
"The I<tms_cutime> field contains the sum of the I<tms_utime> and "
"I<tms_cutime> values for all waited-for terminated children.  The "
"I<tms_cstime> field contains the sum of the I<tms_stime> and I<tms_cstime> "
"values for all waited-for terminated children."
msgstr ""

#. type: Plain text
#: man-pages/man2/times.2:100
msgid ""
"Times for terminated children (and their descendants)  are added in at the "
"moment B<wait>(2)  or B<waitpid>(2)  returns their process ID.  In "
"particular, times of grandchildren that the children did not wait for are "
"never seen."
msgstr ""

#. type: Plain text
#: man-pages/man2/times.2:102
msgid "All times reported are in clock ticks."
msgstr ""

#. type: Plain text
#: man-pages/man2/times.2:111
msgid ""
"B<times>()  returns the number of clock ticks that have elapsed since an "
"arbitrary point in the past.  The return value may overflow the possible "
"range of type I<clock_t>.  On error, I<(clock_t)\\ -1> is returned, and "
"I<errno> is set appropriately."
msgstr ""

#. type: Plain text
#: man-pages/man2/times.2:116
msgid "I<tms> points outside the process's address space."
msgstr ""

#. type: Plain text
#: man-pages/man2/times.2:120
msgid "The number of clock ticks per second can be obtained using:"
msgstr ""

#. type: Plain text
#: man-pages/man2/times.2:124
#, no-wrap
msgid "sysconf(_SC_CLK_TCK);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/times.2:131
msgid ""
"In POSIX.1-1996 the symbol B<CLK_TCK> (defined in I<E<lt>time.hE<gt>>)  is "
"mentioned as obsolescent.  It is obsolete now."
msgstr ""

#.  See the description of times() in XSH, which says:
#. 	The times of a terminated child process are included... when wait()
#. 	or waitpid() returns the process ID of this terminated child.
#. type: Plain text
#: man-pages/man2/times.2:150
msgid ""
"In Linux kernel versions before 2.6.9, if the disposition of B<SIGCHLD> is "
"set to B<SIG_IGN>, then the times of terminated children are automatically "
"included in the I<tms_cstime> and I<tms_cutime> fields, although "
"POSIX.1-2001 says that this should happen only if the calling process "
"B<wait>(2)s on its children.  This nonconformance is rectified in Linux "
"2.6.9 and later."
msgstr ""

#. type: Plain text
#: man-pages/man2/times.2:159
msgid ""
"On Linux, the I<buf> argument can be specified as NULL, with the result that "
"B<times>()  just returns a function result.  However, POSIX does not specify "
"this behavior, and most other UNIX implementations require a non-NULL value "
"for I<buf>."
msgstr ""

#. type: Plain text
#: man-pages/man2/times.2:168
msgid ""
"Note that B<clock>(3)  also returns a value of type I<clock_t>, but this "
"value is measured in units of B<CLOCKS_PER_SEC>, not the clock ticks used by "
"B<times>()."
msgstr ""

#.  .PP
#.  On older systems the number of clock ticks per second is given
#.  by the variable HZ.
#. type: Plain text
#: man-pages/man2/times.2:185
msgid ""
"On Linux, the \"arbitrary point in the past\" from which the return value of "
"B<times>()  is measured has varied across kernel versions.  On Linux 2.4 and "
"earlier, this point is the moment the system was booted.  Since Linux 2.6, "
"this point is I<(2^32/HZ) - 300> seconds before system boot time.  This "
"variability across kernel versions (and across UNIX implementations), "
"combined with the fact that the returned value may overflow the range of "
"I<clock_t>, means that a portable application would be wise to avoid using "
"this value.  To measure changes in elapsed time, use B<clock_gettime>(2)  "
"instead."
msgstr ""

#. type: Plain text
#: man-pages/man2/times.2:196
msgid ""
"SVr1-3 returns I<long> and the struct members are of type I<time_t> although "
"they store clock ticks, not seconds since the Epoch.  V7 used I<long> for "
"the struct members, because it had no type I<time_t> yet."
msgstr ""

#.  The problem is that a syscall return of -4095 to -1
#.  is interpreted by glibc as an error, and the wrapper converts
#.  the return value to -1.
#.  http://marc.info/?l=linux-kernel&m=119447727031225&w=2
#.  "compat_sys_times() bogus until jiffies >= 0"
#.  November 2007
#. type: Plain text
#: man-pages/man2/times.2:211
msgid ""
"A limitation of the Linux system call conventions on some architectures "
"(notably i386) means that on Linux 2.6 there is a small time window (41 "
"seconds) soon after boot when B<times>()  can return -1, falsely indicating "
"that an error occurred.  The same problem can occur when the return value "
"wraps past the maximum value that can be stored in B<clock_t>."
msgstr ""

#. type: Plain text
#: man-pages/man2/times.2:217
msgid ""
"B<time>(1), B<getrusage>(2), B<wait>(2), B<clock>(3), B<sysconf>(3), "
"B<time>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/setgid.2:30
#, no-wrap
msgid "SETGID"
msgstr ""

#. type: Plain text
#: man-pages/man2/setgid.2:33
msgid "setgid - set group identity"
msgstr ""

#. type: Plain text
#: man-pages/man2/setgid.2:39
msgid "B<int setgid(gid_t >I<gid>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/setgid.2:46
msgid ""
"B<setgid>()  sets the effective group ID of the calling process.  If the "
"calling process is privileged (more precisely: has the B<CAP_SETGID> "
"capability in its user namespace), the real GID and saved set-group-ID are "
"also set."
msgstr ""

#. type: Plain text
#: man-pages/man2/setgid.2:56
msgid ""
"Under Linux, B<setgid>()  is implemented like the POSIX version with the "
"B<_POSIX_SAVED_IDS> feature.  This allows a set-group-ID program that is not "
"set-user-ID-root to drop all of its group privileges, do some un-privileged "
"work, and then reengage the original effective group ID in a secure manner."
msgstr ""

#. type: Plain text
#: man-pages/man2/setgid.2:67
msgid "The group ID specified in I<gid> is not valid in this user namespace."
msgstr ""

#. type: Plain text
#: man-pages/man2/setgid.2:74
msgid ""
"The calling process is not privileged (does not have the B<CAP_SETGID> "
"capability in its user namespace), and I<gid> does not match the real group "
"ID or saved set-group-ID of the calling process."
msgstr ""

#. type: Plain text
#: man-pages/man2/setgid.2:87
msgid ""
"The original Linux B<setgid>()  system call supported only 16-bit group "
"IDs.  Subsequently, Linux 2.4 added B<setgid32>()  supporting 32-bit IDs.  "
"The glibc B<setgid>()  wrapper function transparently deals with the "
"variation across kernel versions."
msgstr ""

#. type: Plain text
#: man-pages/man2/setgid.2:101
msgid ""
"At the kernel level, user IDs and group IDs are a per-thread attribute.  "
"However, POSIX requires that all threads in a process share the same "
"credentials.  The NPTL threading implementation handles the POSIX "
"requirements by providing wrapper functions for the various system calls "
"that change process UIDs and GIDs.  These wrapper functions (including the "
"one for B<setgid>())  employ a signal-based technique to ensure that when "
"one thread changes credentials, all of the other threads in the process also "
"change their credentials.  For details, see B<nptl>(7)."
msgstr ""

#. type: Plain text
#: man-pages/man2/setgid.2:107
msgid ""
"B<getgid>(2), B<setegid>(2), B<setregid>(2), B<capabilities>(7), "
"B<credentials>(7), B<user_namespaces>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/ioperm.2:34
#, no-wrap
msgid "IOPERM"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioperm.2:37
msgid "ioperm - set port input/output permissions"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioperm.2:40
msgid "B<#include E<lt>sys/io.hE<gt>> /* for glibc */"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioperm.2:42
msgid ""
"B<int ioperm(unsigned long >I<from>B<, unsigned long >I<num>B<, int "
">I<turn_on>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/ioperm.2:56
msgid ""
"B<ioperm>()  sets the port access permission bits for the calling thread for "
"I<num> bits starting from port address I<from>.  If I<turn_on> is nonzero, "
"then permission for the specified bits is enabled; otherwise it is "
"disabled.  If I<turn_on> is nonzero, the calling thread must be privileged "
"(B<CAP_SYS_RAWIO>)."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioperm.2:65
msgid ""
"Before Linux 2.6.8, only the first 0x3ff I/O ports could be specified in "
"this manner.  For more ports, the B<iopl>(2)  system call had to be used "
"(with a I<level> argument of 3).  Since Linux 2.6.8, 65,536 I/O ports can be "
"specified."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioperm.2:73
msgid ""
"Permissions are inherited by the child created by B<fork>(2)  (but see "
"NOTES).  Permissions are preserved across B<execve>(2); this is useful for "
"giving port access permissions to unprivileged programs."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioperm.2:89
msgid "Invalid values for I<from> or I<num>."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioperm.2:92
msgid "(on PowerPC) This call is not supported."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioperm.2:99
msgid "The calling thread has insufficient privilege."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioperm.2:103
msgid ""
"B<ioperm>()  is Linux-specific and should not be used in programs intended "
"to be portable."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioperm.2:107
msgid ""
"The I</proc/ioports> file shows the I/O ports that are currently allocated "
"on the system."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioperm.2:111
msgid ""
"Before Linux 2.4, permissions were not inherited by a child created by "
"B<fork>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioperm.2:119
msgid ""
"Glibc has an B<ioperm>()  prototype both in I<E<lt>sys/io.hE<gt>> and in "
"I<E<lt>sys/perm.hE<gt>>.  Avoid the latter, it is available on i386 only."
msgstr ""

#. type: Plain text
#: man-pages/man2/ioperm.2:122
msgid "B<iopl>(2), B<outb>(2), B<capabilities>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/vm86.2:26
#, no-wrap
msgid "VM86"
msgstr ""

#. type: TH
#: man-pages/man2/vm86.2:26
#, no-wrap
msgid "2009-02-20"
msgstr ""

#. type: Plain text
#: man-pages/man2/vm86.2:29
msgid "vm86old, vm86 - enter virtual 8086 mode"
msgstr ""

#. type: Plain text
#: man-pages/man2/vm86.2:31
msgid "B<#include E<lt>sys/vm86.hE<gt>>"
msgstr ""

#. type: Plain text
#: man-pages/man2/vm86.2:33
msgid "B<int vm86old(struct vm86_struct *>I<info>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/vm86.2:35
msgid "B<int vm86(unsigned long >I<fn>B<, struct vm86plus_struct *>I<v86>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/vm86.2:48
msgid ""
"The system call B<vm86>()  was introduced in Linux 0.97p2.  In Linux 2.1.15 "
"and 2.0.28, it was renamed to B<vm86old>(), and a new B<vm86>()  was "
"introduced.  The definition of I<struct vm86_struct> was changed in 1.1.8 "
"and 1.1.9."
msgstr ""

#. type: Plain text
#: man-pages/man2/vm86.2:52
msgid ""
"These calls cause the process to enter VM86 mode (virtual-8086 in Intel "
"literature), and are used by B<dosemu>."
msgstr ""

#. type: Plain text
#: man-pages/man2/vm86.2:54
msgid "VM86 mode is an emulation of real mode within a protected mode task."
msgstr ""

#. type: Plain text
#: man-pages/man2/vm86.2:64
msgid ""
"This return value is specific to i386 and indicates a problem with getting "
"user-space data."
msgstr ""

#. type: Plain text
#: man-pages/man2/vm86.2:68
msgid ""
"This return value indicates the call is not implemented on the present "
"architecture."
msgstr ""

#. type: Plain text
#: man-pages/man2/vm86.2:73
msgid ""
"Saved kernel stack exists.  (This is a kernel sanity check; the saved stack "
"should exist only within vm86 mode itself.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/vm86.2:75
msgid ""
"This call is specific to Linux on 32-bit Intel processors, and should not be "
"used in programs intended to be portable."
msgstr ""

#. type: TH
#: man-pages/man2/setpgid.2:48
#, no-wrap
msgid "SETPGID"
msgstr ""

#. type: Plain text
#: man-pages/man2/setpgid.2:51
msgid "setpgid, getpgid, setpgrp, getpgrp - set/get process group"
msgstr ""

#. type: Plain text
#: man-pages/man2/setpgid.2:57
msgid "B<int setpgid(pid_t >I<pid>B<, pid_t >I<pgid>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/setpgid.2:59
msgid "B<pid_t getpgid(pid_t >I<pid>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/setpgid.2:61
msgid "B<pid_t getpgrp(void);> /* POSIX.1 version */"
msgstr ""

#. type: Plain text
#: man-pages/man2/setpgid.2:64
msgid ""
"B<pid_t getpgrp(pid_t >I<pid>B<);\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ > /* BSD "
"version */"
msgstr ""

#. type: Plain text
#: man-pages/man2/setpgid.2:66
msgid "B<int setpgrp(void);> /* System V version */"
msgstr ""

#. type: Plain text
#: man-pages/man2/setpgid.2:69
msgid "B<int setpgrp(pid_t >I<pid>B<, pid_t >I<pgid>B<);\\ > /* BSD version */"
msgstr ""

#. type: Plain text
#: man-pages/man2/setpgid.2:77
msgid "B<getpgid>():"
msgstr ""

#. type: Plain text
#: man-pages/man2/setpgid.2:85
msgid "B<setpgrp>() (POSIX.1):"
msgstr ""

#.     || _XOPEN_SOURCE\ &&\ _XOPEN_SOURCE_EXTENDED
#. type: Plain text
#: man-pages/man2/setpgid.2:90
#, no-wrap
msgid ""
"    _XOPEN_SOURCE\\ E<gt>=\\ 500\n"
"        || /* Since glibc 2.19: */ _DEFAULT_SOURCE\n"
"        || /* Glibc versions E<lt>= 2.19: */ _SVID_SOURCE\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/setpgid.2:94
msgid "B<setpgrp>()\\ (BSD), B<getpgrp>()\\ (BSD):"
msgstr ""

#. type: Plain text
#: man-pages/man2/setpgid.2:99
#, no-wrap
msgid ""
"    [These are available only before glibc 2.19]\n"
"    _BSD_SOURCE &&\n"
"        !\\ (_POSIX_SOURCE || _POSIX_C_SOURCE || _XOPEN_SOURCE ||\n"
"            _GNU_SOURCE || _SVID_SOURCE)\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/setpgid.2:110
msgid ""
"All of these interfaces are available on Linux, and are used for getting and "
"setting the process group ID (PGID) of a process.  The preferred, "
"POSIX.1-specified ways of doing this are: B<getpgrp>(void), for retrieving "
"the calling process's PGID; and B<setpgid>(), for setting a process's PGID."
msgstr ""

#. type: Plain text
#: man-pages/man2/setpgid.2:135
msgid ""
"B<setpgid>()  sets the PGID of the process specified by I<pid> to I<pgid>.  "
"If I<pid> is zero, then the process ID of the calling process is used.  If "
"I<pgid> is zero, then the PGID of the process specified by I<pid> is made "
"the same as its process ID.  If B<setpgid>()  is used to move a process from "
"one process group to another (as is done by some shells when creating "
"pipelines), both process groups must be part of the same session (see "
"B<setsid>(2)  and B<credentials>(7)).  In this case, the I<pgid> specifies "
"an existing process group to be joined and the session ID of that group must "
"match the session ID of the joining process."
msgstr ""

#. type: Plain text
#: man-pages/man2/setpgid.2:140
msgid ""
"The POSIX.1 version of B<getpgrp>(), which takes no arguments, returns the "
"PGID of the calling process."
msgstr ""

#. type: Plain text
#: man-pages/man2/setpgid.2:151
msgid ""
"B<getpgid>()  returns the PGID of the process specified by I<pid>.  If "
"I<pid> is zero, the process ID of the calling process is used.  (Retrieving "
"the PGID of a process other than the caller is rarely necessary, and the "
"POSIX.1 B<getpgrp>()  is preferred for that task.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/setpgid.2:156
msgid ""
"The System\\ V-style B<setpgrp>(), which takes no arguments, is equivalent "
"to I<setpgid(0,\\ 0)>."
msgstr ""

#. type: Plain text
#: man-pages/man2/setpgid.2:164
msgid ""
"The BSD-specific B<setpgrp>()  call, which takes arguments I<pid> and "
"I<pgid>, is a wrapper function that calls"
msgstr ""

#. type: Plain text
#: man-pages/man2/setpgid.2:166
#, no-wrap
msgid "    setpgid(pid, pgid)\n"
msgstr ""

#.  The true BSD setpgrp() system call differs in allowing the PGID
#.  to be set to arbitrary values, rather than being restricted to
#.  PGIDs in the same session.
#. type: Plain text
#: man-pages/man2/setpgid.2:177
msgid ""
"Since glibc 2.19, the BSD-specific B<setpgrp>()  function is no longer "
"exposed by I<E<lt>unistd.hE<gt>>; calls should be replaced with the "
"B<setpgid>()  call shown above."
msgstr ""

#. type: Plain text
#: man-pages/man2/setpgid.2:183
msgid ""
"The BSD-specific B<getpgrp>()  call, which takes a single I<pid> argument, "
"is a wrapper function that calls"
msgstr ""

#. type: Plain text
#: man-pages/man2/setpgid.2:185
#, no-wrap
msgid "    getpgid(pid)\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/setpgid.2:196
msgid ""
"Since glibc 2.19, the BSD-specific B<getpgrp>()  function is no longer "
"exposed by I<E<lt>unistd.hE<gt>>; calls should be replaced with calls to the "
"POSIX.1 B<getpgrp>()  which takes no arguments (if the intent is to obtain "
"the caller's PGID), or with the B<getpgid>()  call shown above."
msgstr ""

#. type: Plain text
#: man-pages/man2/setpgid.2:205
msgid ""
"On success, B<setpgid>()  and B<setpgrp>()  return zero.  On error, -1 is "
"returned, and I<errno> is set appropriately."
msgstr ""

#. type: Plain text
#: man-pages/man2/setpgid.2:209
msgid "The POSIX.1 B<getpgrp>()  always returns the PGID of the caller."
msgstr ""

#. type: Plain text
#: man-pages/man2/setpgid.2:217
msgid ""
"B<getpgid>(), and the BSD-specific B<getpgrp>()  return a process group on "
"success.  On error, -1 is returned, and I<errno> is set appropriately."
msgstr ""

#. type: Plain text
#: man-pages/man2/setpgid.2:226
msgid ""
"An attempt was made to change the process group ID of one of the children of "
"the calling process and the child had already performed an B<execve>(2)  "
"(B<setpgid>(), B<setpgrp>())."
msgstr ""

#. type: Plain text
#: man-pages/man2/setpgid.2:232
msgid "I<pgid> is less than 0 (B<setpgid>(), B<setpgrp>())."
msgstr ""

#. type: Plain text
#: man-pages/man2/setpgid.2:241
msgid ""
"An attempt was made to move a process into a process group in a different "
"session, or to change the process group ID of one of the children of the "
"calling process and the child was in a different session, or to change the "
"process group ID of a session leader (B<setpgid>(), B<setpgrp>())."
msgstr ""

#. type: Plain text
#: man-pages/man2/setpgid.2:251
msgid ""
"For B<getpgid>(): I<pid> does not match any process.  For B<setpgid>(): "
"I<pid> is not the calling process and not a child of the calling process."
msgstr ""

#. type: Plain text
#: man-pages/man2/setpgid.2:257
msgid ""
"B<setpgid>()  and the version of B<getpgrp>()  with no arguments conform to "
"POSIX.1-2001."
msgstr ""

#. type: Plain text
#: man-pages/man2/setpgid.2:266
msgid ""
"POSIX.1-2001 also specifies B<getpgid>()  and the version of B<setpgrp>()  "
"that takes no arguments.  (POSIX.1-2008 marks this B<setpgrp>()  "
"specification as obsolete.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/setpgid.2:273
msgid ""
"The version of B<getpgrp>()  with one argument and the version of "
"B<setpgrp>()  that takes two arguments derive from 4.2BSD, and are not "
"specified by POSIX.1."
msgstr ""

#. type: Plain text
#: man-pages/man2/setpgid.2:279
msgid ""
"A child created via B<fork>(2)  inherits its parent's process group ID.  The "
"PGID is preserved across an B<execve>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/setpgid.2:284
msgid ""
"Each process group is a member of a session and each process is a member of "
"the session of which its process group is a member.  (See "
"B<credentials>(7).)"
msgstr ""

#. type: Plain text
#: man-pages/man2/setpgid.2:311
msgid ""
"A session can have a controlling terminal.  At any time, one (and only one) "
"of the process groups in the session can be the foreground process group for "
"the terminal; the remaining process groups are in the background.  If a "
"signal is generated from the terminal (e.g., typing the interrupt key to "
"generate B<SIGINT>), that signal is sent to the foreground process group.  "
"(See B<termios>(3)  for a description of the characters that generate "
"signals.)  Only the foreground process group may B<read>(2)  from the "
"terminal; if a background process group tries to B<read>(2)  from the "
"terminal, then the group is sent a B<SIGTTIN> signal, which suspends it.  "
"The B<tcgetpgrp>(3)  and B<tcsetpgrp>(3)  functions are used to get/set the "
"foreground process group of the controlling terminal."
msgstr ""

#. type: Plain text
#: man-pages/man2/setpgid.2:319
msgid ""
"The B<setpgid>()  and B<getpgrp>()  calls are used by programs such as "
"B<bash>(1)  to create process groups in order to implement shell job "
"control."
msgstr ""

#.  exit.3 refers to the following text:
#. type: Plain text
#: man-pages/man2/setpgid.2:333
msgid ""
"If the termination of a process causes a process group to become orphaned, "
"and if any member of the newly orphaned process group is stopped, then a "
"B<SIGHUP> signal followed by a B<SIGCONT> signal will be sent to each "
"process in the newly orphaned process group.  An orphaned process group is "
"one in which the parent of every member of process group is either itself "
"also a member of the process group or is a member of a process group in a "
"different session (see also B<credentials>(7))."
msgstr ""

#. type: Plain text
#: man-pages/man2/setpgid.2:339
msgid ""
"B<getuid>(2), B<setsid>(2), B<tcgetpgrp>(3), B<tcsetpgrp>(3), B<termios>(3), "
"B<credentials>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/shmop.2:41
#, no-wrap
msgid "SHMOP"
msgstr ""

#. type: Plain text
#: man-pages/man2/shmop.2:44
msgid "shmat, shmdt - System V shared memory operations"
msgstr ""

#. type: Plain text
#: man-pages/man2/shmop.2:48
#, no-wrap
msgid ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>sys/shm.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/shmop.2:50
#, no-wrap
msgid ""
"B<void *shmat(int >I<shmid>B<, const void *>I<shmaddr>B<, int "
">I<shmflg>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/shmop.2:52
#, no-wrap
msgid "B<int shmdt(const void *>I<shmaddr>B<);>\n"
msgstr ""

#. type: SS
#: man-pages/man2/shmop.2:54
#, no-wrap
msgid "shmat()"
msgstr ""

#. type: Plain text
#: man-pages/man2/shmop.2:62
msgid ""
"B<shmat>()  attaches the System\\ V shared memory segment identified by "
"I<shmid> to the address space of the calling process.  The attaching address "
"is specified by I<shmaddr> with one of the following criteria:"
msgstr ""

#. type: Plain text
#: man-pages/man2/shmop.2:68
msgid ""
"If I<shmaddr> is NULL, the system chooses a suitable (unused) page-aligned "
"address to attach the segment."
msgstr ""

#. type: Plain text
#: man-pages/man2/shmop.2:80
msgid ""
"If I<shmaddr> isn't NULL and B<SHM_RND> is specified in I<shmflg>, the "
"attach occurs at the address equal to I<shmaddr> rounded down to the nearest "
"multiple of B<SHMLBA>."
msgstr ""

#. type: Plain text
#: man-pages/man2/shmop.2:84
msgid ""
"Otherwise, I<shmaddr> must be a page-aligned address at which the attach "
"occurs."
msgstr ""

#. type: Plain text
#: man-pages/man2/shmop.2:90
msgid ""
"In addition to B<SHM_RND>, the following flags may be specified in the "
"I<shmflg> bit-mask argument:"
msgstr ""

#. type: TP
#: man-pages/man2/shmop.2:90
#, no-wrap
msgid "B<SHM_EXEC> (Linux-specific; since Linux 2.6.9)"
msgstr ""

#. type: Plain text
#: man-pages/man2/shmop.2:94
msgid ""
"Allow the contents of the segment to be executed.  The caller must have "
"execute permission on the segment."
msgstr ""

#. type: TP
#: man-pages/man2/shmop.2:94
#, no-wrap
msgid "B<SHM_RDONLY>"
msgstr ""

#. type: Plain text
#: man-pages/man2/shmop.2:102
msgid ""
"Attach the segment for read-only access.  The process must have read "
"permission for the segment.  If this flag is not specified, the segment is "
"attached for read and write access, and the process must have read and write "
"permission for the segment.  There is no notion of a write-only shared "
"memory segment."
msgstr ""

#. type: TP
#: man-pages/man2/shmop.2:102
#, no-wrap
msgid "B<SHM_REMAP> (Linux-specific)"
msgstr ""

#. type: Plain text
#: man-pages/man2/shmop.2:115
msgid ""
"This flag specifies that the mapping of the segment should replace any "
"existing mapping in the range starting at I<shmaddr> and continuing for the "
"size of the segment.  (Normally, an B<EINVAL> error would result if a "
"mapping already exists in this address range.)  In this case, I<shmaddr> "
"must not be NULL."
msgstr ""

#. type: Plain text
#: man-pages/man2/shmop.2:122
msgid ""
"The B<brk>(2)  value of the calling process is not altered by the attach.  "
"The segment will automatically be detached at process exit.  The same "
"segment may be attached as a read and as a read-write one, and more than "
"once, in the process's address space."
msgstr ""

#. type: Plain text
#: man-pages/man2/shmop.2:130
msgid ""
"A successful B<shmat>()  call updates the members of the I<shmid_ds> "
"structure (see B<shmctl>(2))  associated with the shared memory segment as "
"follows:"
msgstr ""

#. type: Plain text
#: man-pages/man2/shmop.2:133
msgid "I<shm_atime> is set to the current time."
msgstr ""

#. type: Plain text
#: man-pages/man2/shmop.2:136 man-pages/man2/shmop.2:163
msgid "I<shm_lpid> is set to the process-ID of the calling process."
msgstr ""

#. type: Plain text
#: man-pages/man2/shmop.2:140
msgid "I<shm_nattch> is incremented by one."
msgstr ""

#. type: SS
#: man-pages/man2/shmop.2:140
#, no-wrap
msgid "shmdt()"
msgstr ""

#. type: Plain text
#: man-pages/man2/shmop.2:151
msgid ""
"B<shmdt>()  detaches the shared memory segment located at the address "
"specified by I<shmaddr> from the address space of the calling process.  The "
"to-be-detached segment must be currently attached with I<shmaddr> equal to "
"the value returned by the attaching B<shmat>()  call."
msgstr ""

#. type: Plain text
#: man-pages/man2/shmop.2:157
msgid ""
"On a successful B<shmdt>()  call, the system updates the members of the "
"I<shmid_ds> structure associated with the shared memory segment as follows:"
msgstr ""

#. type: Plain text
#: man-pages/man2/shmop.2:160
msgid "I<shm_dtime> is set to the current time."
msgstr ""

#. type: Plain text
#: man-pages/man2/shmop.2:168
msgid ""
"I<shm_nattch> is decremented by one.  If it becomes 0 and the segment is "
"marked for deletion, the segment is deleted."
msgstr ""

#. type: Plain text
#: man-pages/man2/shmop.2:176
msgid ""
"On success, B<shmat>()  returns the address of the attached shared memory "
"segment; on error, I<(void\\ *)\\ -1> is returned, and I<errno> is set to "
"indicate the cause of the error."
msgstr ""

#. type: Plain text
#: man-pages/man2/shmop.2:182
msgid ""
"On success, B<shmdt>()  returns 0; on error -1 is returned, and I<errno> is "
"set to indicate the cause of the error."
msgstr ""

#. type: Plain text
#: man-pages/man2/shmop.2:188
msgid "When B<shmat>()  fails, I<errno> is set to one of the following:"
msgstr ""

#. type: Plain text
#: man-pages/man2/shmop.2:194
msgid ""
"The calling process does not have the required permissions for the requested "
"attach type, and does not have the B<CAP_IPC_OWNER> capability in the user "
"namespace that governs its IPC namespace."
msgstr ""

#. type: Plain text
#: man-pages/man2/shmop.2:211
msgid ""
"Invalid I<shmid> value, unaligned (i.e., not page-aligned and B<SHM_RND> was "
"not specified) or invalid I<shmaddr> value, or can't attach segment at "
"I<shmaddr>, or B<SHM_REMAP> was specified and I<shmaddr> was NULL."
msgstr ""

#. type: Plain text
#: man-pages/man2/shmop.2:214
msgid "Could not allocate memory for the descriptor or for the page tables."
msgstr ""

#. type: Plain text
#: man-pages/man2/shmop.2:220
msgid "When B<shmdt>()  fails, I<errno> is set as follows:"
msgstr ""

#.  The following since 2.6.17-rc1:
#. type: Plain text
#: man-pages/man2/shmop.2:228
msgid ""
"There is no shared memory segment attached at I<shmaddr>; or, I<shmaddr> is "
"not aligned on a page boundary."
msgstr ""

#. type: Plain text
#: man-pages/man2/shmop.2:243
msgid ""
"In SVID 3 (or perhaps earlier), the type of the I<shmaddr> argument was "
"changed from I<char\\ *> into I<const void\\ *>, and the returned type of "
"B<shmat>()  from I<char\\ *> into I<void\\ *>."
msgstr ""

#. type: Plain text
#: man-pages/man2/shmop.2:248
msgid "After a B<fork>(2), the child inherits the attached shared memory segments."
msgstr ""

#. type: Plain text
#: man-pages/man2/shmop.2:252
msgid ""
"After an B<execve>(2), all attached shared memory segments are detached from "
"the process."
msgstr ""

#. type: Plain text
#: man-pages/man2/shmop.2:256
msgid ""
"Upon B<_exit>(2), all attached shared memory segments are detached from the "
"process."
msgstr ""

#. type: Plain text
#: man-pages/man2/shmop.2:268
msgid ""
"Using B<shmat>()  with I<shmaddr> equal to NULL is the preferred, portable "
"way of attaching a shared memory segment.  Be aware that the shared memory "
"segment attached in this way may be attached at different addresses in "
"different processes.  Therefore, any pointers maintained within the shared "
"memory must be made relative (typically to the starting address of the "
"segment), rather than absolute."
msgstr ""

#. type: Plain text
#: man-pages/man2/shmop.2:273
msgid ""
"On Linux, it is possible to attach a shared memory segment even if it is "
"already marked to be deleted.  However, POSIX.1 does not specify this "
"behavior and many other implementations do not support it."
msgstr ""

#. type: Plain text
#: man-pages/man2/shmop.2:276
msgid "The following system parameter affects B<shmat>():"
msgstr ""

#. type: TP
#: man-pages/man2/shmop.2:276
#, no-wrap
msgid "B<SHMLBA>"
msgstr ""

#. type: Plain text
#: man-pages/man2/shmop.2:291
msgid ""
"Segment low boundary address multiple.  When explicitly specifying an attach "
"address in a call to B<shmat>(), the caller should ensure that the address "
"is a multiple of this value.  This is necessary on some architectures, in "
"order either to ensure good CPU cache performance or to ensure that "
"different attaches of the same segment have consistent views within the CPU "
"cache.  B<SHMLBA> is normally some multiple of the system page size.  (On "
"many Linux architectures, B<SHMLBA> is the same as the system page size.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/shmop.2:295
msgid ""
"The implementation places no intrinsic per-process limit on the number of "
"shared memory segments (B<SHMSEG>)."
msgstr ""

#. type: Plain text
#: man-pages/man2/shmop.2:302
msgid ""
"B<brk>(2), B<mmap>(2), B<shmctl>(2), B<shmget>(2), B<capabilities>(7), "
"B<shm_overview>(7), B<sysvipc>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/umount.2:30
#, no-wrap
msgid "UMOUNT"
msgstr ""

#. type: Plain text
#: man-pages/man2/umount.2:33
msgid "umount, umount2 - unmount filesystem"
msgstr ""

#. type: Plain text
#: man-pages/man2/umount.2:38
#, no-wrap
msgid "B<int umount(const char *>I<target>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/umount.2:40
#, no-wrap
msgid "B<int umount2(const char *>I<target>B<, int >I<flags>B<);>\n"
msgstr ""

#.  Note: the kernel naming differs from the glibc naming
#.  umount2 is the glibc name for what the kernel now calls umount
#.  and umount is the glibc name for oldumount
#. type: Plain text
#: man-pages/man2/umount.2:50
msgid ""
"B<umount>()  and B<umount2>()  remove the attachment of the (topmost) "
"filesystem mounted on I<target>."
msgstr ""

#. type: Plain text
#: man-pages/man2/umount.2:54
msgid ""
"Appropriate privilege (Linux: the B<CAP_SYS_ADMIN> capability) is required "
"to unmount filesystems."
msgstr ""

#. type: Plain text
#: man-pages/man2/umount.2:62
msgid ""
"Linux 2.1.116 added the B<umount2>()  system call, which, like B<umount>(), "
"unmounts a target, but allows additional I<flags> controlling the behavior "
"of the operation:"
msgstr ""

#. type: TP
#: man-pages/man2/umount.2:62
#, no-wrap
msgid "B<MNT_FORCE> (since Linux 2.1.116)"
msgstr ""

#. type: Plain text
#: man-pages/man2/umount.2:80
msgid ""
"Ask the filesystem to abort pending requests before attempting the unmount.  "
"This may allow the unmount to complete without waiting for an inaccessible "
"server, but could cause data loss.  If, after aborting requests, some "
"processes still have active references to the filesystem, the unmount will "
"still fail.  As at Linux 4.12, B<MNT_FORCE> is supported only on the "
"following filesystems: 9p (since Linux 2.6.16), ceph (since Linux 2.6.34), "
"cifs (since Linux 2.6.12), fuse (since Linux 2.6.16), lustre (since Linux "
"3.11), and NFS (since Linux 2.1.116)."
msgstr ""

#. type: TP
#: man-pages/man2/umount.2:80
#, no-wrap
msgid "B<MNT_DETACH> (since Linux 2.4.11)"
msgstr ""

#. type: Plain text
#: man-pages/man2/umount.2:86
msgid ""
"Perform a lazy unmount: make the mount point unavailable for new accesses, "
"immediately disconnect the filesystem and all filesystems mounted below it "
"from each other and from the mount table, and actually perform the unmount "
"when the mount point ceases to be busy."
msgstr ""

#. type: TP
#: man-pages/man2/umount.2:86
#, no-wrap
msgid "B<MNT_EXPIRE> (since Linux 2.6.8)"
msgstr ""

#. type: Plain text
#: man-pages/man2/umount.2:105
msgid ""
"Mark the mount point as expired.  If a mount point is not currently in use, "
"then an initial call to B<umount2>()  with this flag fails with the error "
"B<EAGAIN>, but marks the mount point as expired.  The mount point remains "
"expired as long as it isn't accessed by any process.  A second B<umount2>()  "
"call specifying B<MNT_EXPIRE> unmounts an expired mount point.  This flag "
"cannot be specified with either B<MNT_FORCE> or B<MNT_DETACH>."
msgstr ""

#. type: TP
#: man-pages/man2/umount.2:105
#, no-wrap
msgid "B<UMOUNT_NOFOLLOW> (since Linux 2.6.34)"
msgstr ""

#.  Later added to 2.6.33-stable
#. type: Plain text
#: man-pages/man2/umount.2:113
msgid ""
"Don't dereference I<target> if it is a symbolic link.  This flag allows "
"security problems to be avoided in set-user-ID-I<root> programs that allow "
"unprivileged users to unmount filesystems."
msgstr ""

#. type: Plain text
#: man-pages/man2/umount.2:131
msgid ""
"A call to B<umount2>()  specifying B<MNT_EXPIRE> successfully marked an "
"unbusy filesystem as expired."
msgstr ""

#. type: Plain text
#: man-pages/man2/umount.2:135
msgid "I<target> could not be unmounted because it is busy."
msgstr ""

#. type: Plain text
#: man-pages/man2/umount.2:139
msgid "I<target> points outside the user address space."
msgstr ""

#. type: Plain text
#: man-pages/man2/umount.2:143
msgid "I<target> is not a mount point."
msgstr ""

#. type: Plain text
#: man-pages/man2/umount.2:152
msgid ""
"B<umount2>()  was called with B<MNT_EXPIRE> and either B<MNT_DETACH> or "
"B<MNT_FORCE>."
msgstr ""

#. type: TP
#: man-pages/man2/umount.2:152
#, no-wrap
msgid "B<EINVAL> (since Linux 2.6.34)"
msgstr ""

#. type: Plain text
#: man-pages/man2/umount.2:157
msgid "B<umount2>()  was called with an invalid flag value in I<flags>."
msgstr ""

#.  http://sourceware.org/bugzilla/show_bug.cgi?id=10092
#. type: Plain text
#: man-pages/man2/umount.2:176
msgid "B<MNT_DETACH> and B<MNT_EXPIRE> are available in glibc since version 2.11."
msgstr ""

#. type: Plain text
#: man-pages/man2/umount.2:179
msgid ""
"These functions are Linux-specific and should not be used in programs "
"intended to be portable."
msgstr ""

#. type: SS
#: man-pages/man2/umount.2:180
#, no-wrap
msgid "umount() and shared mount points"
msgstr ""

#. type: Plain text
#: man-pages/man2/umount.2:189
msgid ""
"Shared mount points cause any mount activity on a mount point, including "
"B<umount>()  operations, to be forwarded to every shared mount point in the "
"peer group and every slave mount of that peer group.  This means that "
"B<umount>()  of any peer in a set of shared mounts will cause all of its "
"peers to be unmounted and all of their slaves to be unmounted as well."
msgstr ""

#. type: Plain text
#: man-pages/man2/umount.2:197
msgid ""
"This propagation of unmount activity can be particularly surprising on "
"systems where every mount point is shared by default.  On such systems, "
"recursively bind mounting the root directory of the filesystem onto a "
"subdirectory and then later unmounting that subdirectory with B<MNT_DETACH> "
"will cause every mount in the mount namespace to be lazily unmounted."
msgstr ""

#. type: Plain text
#: man-pages/man2/umount.2:212
msgid ""
"To ensure B<umount>()  does not propagate in this fashion, the mount point "
"may be remounted using a B<mount>()  call with a I<mount_flags> argument "
"that includes both B<MS_REC> and B<MS_PRIVATE> prior to B<umount>()  being "
"called."
msgstr ""

#. type: Plain text
#: man-pages/man2/umount.2:223
msgid ""
"The original B<umount>()  function was called as I<umount(device)> and would "
"return B<ENOTBLK> when called with something other than a block device.  In "
"Linux 0.98p4, a call I<umount(dir)> was added, in order to support anonymous "
"devices.  In Linux 2.3.99-pre7, the call I<umount(device)> was removed, "
"leaving only I<umount(dir)> (since now devices can be mounted in more than "
"one place, so specifying the device does not suffice)."
msgstr ""

#. type: Plain text
#: man-pages/man2/umount.2:228
msgid ""
"B<mount>(2), B<mount_namespaces>(7), B<path_resolution>(7), B<mount>(8), "
"B<umount>(8)"
msgstr ""

#. type: TH
#: man-pages/man2/s390_sthyi.2:25
#, no-wrap
msgid "S390_STHYI"
msgstr ""

#. type: Plain text
#: man-pages/man2/s390_sthyi.2:28
msgid "s390_sthyi - emulate STHYI instruction"
msgstr ""

#. type: Plain text
#: man-pages/man2/s390_sthyi.2:34
#, no-wrap
msgid ""
"B<int s390_sthyi(unsigned long >I<function_code>B<, void "
"*>I<resp_buffer>B<,>\n"
"B<               uint64_t *>I<return_code>B<, unsigned long >I<flags>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/s390_sthyi.2:43
msgid ""
"The B<s390_sthyi>()  system call emulates the STHYI (Store Hypervisor "
"Information) instruction.  It provides hardware resource information for the "
"machine and its virtualization levels.  This includes CPU type and capacity, "
"as well as the machine model and other metrics."
msgstr ""

#. type: Plain text
#: man-pages/man2/s390_sthyi.2:48
msgid ""
"The I<function_code> argument indicates which function to perform.  The "
"following code(s) are supported:"
msgstr ""

#. type: Plain text
#: man-pages/man2/s390_sthyi.2:52
msgid ""
"Return CP (Central Processor) and IFL (Integrated Facility for Linux)  "
"capacity information."
msgstr ""

#. type: Plain text
#: man-pages/man2/s390_sthyi.2:62
msgid ""
"The I<resp_buffer> argument specifies the address of a response buffer.  "
"When the I<function_code> is 0, the buffer must be one page (4K) in size.  "
"If the system call returns 0, the response buffer will be filled with CPU "
"capacity information.  Otherwise, the response buffer's content is "
"unchanged."
msgstr ""

#. type: Plain text
#: man-pages/man2/s390_sthyi.2:67
msgid ""
"The I<return_code> argument stores the return code of the STHYI instruction, "
"using one of the following values:"
msgstr ""

#. type: Plain text
#: man-pages/man2/s390_sthyi.2:70
msgid "Success."
msgstr ""

#. type: Plain text
#: man-pages/man2/s390_sthyi.2:73
msgid "Unsupported function code."
msgstr ""

#. type: Plain text
#: man-pages/man2/s390_sthyi.2:80
msgid ""
"For further details about I<return_code>, I<function_code>, and "
"I<resp_buffer>, see the reference given in NOTES."
msgstr ""

#. type: Plain text
#: man-pages/man2/s390_sthyi.2:85
msgid ""
"The I<flags> argument is provided to allow for future extensions and "
"currently must be set to 0."
msgstr ""

#. type: Plain text
#: man-pages/man2/s390_sthyi.2:96
msgid ""
"On success (that is: emulation succeeded), the return value of "
"B<s390_sthyi>()  matches the condition code of the STHYI instructions, which "
"is a value in the range [0..3].  A return value of 0 indicates that CPU "
"capacity information is stored in I<*resp_buffer>.  A return value of 3 "
"indicates \"unsupported function code\" and the content of I<*resp_buffer> "
"is unchanged.  The return values 1 and 2 are reserved."
msgstr ""

#. type: Plain text
#: man-pages/man2/s390_sthyi.2:108
msgid ""
"The value specified in I<resp_buffer> or I<return_code> is not a valid "
"address."
msgstr ""

#. type: Plain text
#: man-pages/man2/s390_sthyi.2:113
msgid "The value specified in I<flags> is nonzero."
msgstr ""

#. type: Plain text
#: man-pages/man2/s390_sthyi.2:116
msgid "Allocating memory for handling the CPU capacity information failed."
msgstr ""

#. type: Plain text
#: man-pages/man2/s390_sthyi.2:121
msgid "The value specified in I<function_code> is not valid."
msgstr ""

#. type: Plain text
#: man-pages/man2/s390_sthyi.2:123
msgid "This system call is available since Linux 4.15."
msgstr ""

#. type: Plain text
#: man-pages/man2/s390_sthyi.2:134
msgid ""
"For details of the STHYI instruction, see E<.UR "
"https://www.ibm.com\\:/support\\:/knowledgecenter\\:/SSB27U_6.3.0\\:/com.ibm.zvm.v630.hcpb4\\:/hcpb4sth.htm> "
"the documentation page E<.UE .>"
msgstr ""

#. type: Plain text
#: man-pages/man2/s390_sthyi.2:138
msgid ""
"When the system call interface is used, the response buffer doesn't have to "
"fulfill alignment requirements described in the STHYI instruction "
"definition."
msgstr ""

#. type: Plain text
#: man-pages/man2/s390_sthyi.2:141
msgid ""
"The kernel caches the response (for up to one second, as of Linux 4.16).  "
"Subsequent system call invocations may return the cached response."
msgstr ""

#. type: TH
#: man-pages/man2/bdflush.2:27
#, no-wrap
msgid "BDFLUSH"
msgstr ""

#. type: TH
#: man-pages/man2/bdflush.2:27
#, no-wrap
msgid "2016-10-08"
msgstr ""

#. type: Plain text
#: man-pages/man2/bdflush.2:30
msgid "bdflush - start, flush, or tune buffer-dirty-flush daemon"
msgstr ""

#. type: Plain text
#: man-pages/man2/bdflush.2:33
#, no-wrap
msgid "B<#include E<lt>sys/kdaemon.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/bdflush.2:36
#, no-wrap
msgid ""
"B<int bdflush(int >I<func>B<, long *>I<address>B<);>\n"
"B<int bdflush(int >I<func>B<, long >I<data>B<);>\n"
msgstr ""

#.  As noted in a changes in the 2.5.12 source
#. type: Plain text
#: man-pages/man2/bdflush.2:48
msgid ""
"I<Note>: Since Linux 2.6, this system call is deprecated and does nothing.  "
"It is likely to disappear altogether in a future kernel release.  Nowadays, "
"the task performed by B<bdflush>()  is handled by the kernel I<pdflush> "
"thread."
msgstr ""

#. type: Plain text
#: man-pages/man2/bdflush.2:55
msgid ""
"B<bdflush>()  starts, flushes, or tunes the buffer-dirty-flush daemon.  Only "
"a privileged process (one with the B<CAP_SYS_ADMIN> capability) may call "
"B<bdflush>()."
msgstr ""

#. type: Plain text
#: man-pages/man2/bdflush.2:61
msgid ""
"If I<func> is negative or 0, and no daemon has been started, then "
"B<bdflush>()  enters the daemon code and never returns."
msgstr ""

#. type: Plain text
#: man-pages/man2/bdflush.2:66
msgid "If I<func> is 1, some dirty buffers are written to disk."
msgstr ""

#. type: Plain text
#: man-pages/man2/bdflush.2:75
msgid ""
"If I<func> is 2 or more and is even (low bit is 0), then I<address> is the "
"address of a long word, and the tuning parameter numbered (I<func>-2)/2 is "
"returned to the caller in that address."
msgstr ""

#. type: Plain text
#: man-pages/man2/bdflush.2:84
msgid ""
"If I<func> is 3 or more and is odd (low bit is 1), then I<data> is a long "
"word, and the kernel sets tuning parameter numbered (I<func>-3)/2 to that "
"value."
msgstr ""

#. type: Plain text
#: man-pages/man2/bdflush.2:88
msgid ""
"The set of parameters, their values, and their valid ranges are defined in "
"the Linux kernel source file I<fs/buffer.c>."
msgstr ""

#. type: Plain text
#: man-pages/man2/bdflush.2:97
msgid ""
"If I<func> is negative or 0 and the daemon successfully starts, B<bdflush>()  "
"never returns.  Otherwise, the return value is 0 on success and -1 on "
"failure, with I<errno> set to indicate the error."
msgstr ""

#. type: Plain text
#: man-pages/man2/bdflush.2:102
msgid ""
"An attempt was made to enter the daemon code after another process has "
"already entered."
msgstr ""

#. type: Plain text
#: man-pages/man2/bdflush.2:106
msgid "I<address> points outside your accessible address space."
msgstr ""

#. type: Plain text
#: man-pages/man2/bdflush.2:110
msgid ""
"An attempt was made to read or write an invalid parameter number, or to "
"write an invalid value to a parameter."
msgstr ""

#. type: Plain text
#: man-pages/man2/bdflush.2:115
msgid "Caller does not have the B<CAP_SYS_ADMIN> capability."
msgstr ""

#. type: Plain text
#: man-pages/man2/bdflush.2:117
msgid "Since version 2.23, glibc no longer supports this obsolete system call."
msgstr ""

#. type: Plain text
#: man-pages/man2/bdflush.2:121
msgid ""
"B<bdflush>()  is Linux-specific and should not be used in programs intended "
"to be portable."
msgstr ""

#. type: Plain text
#: man-pages/man2/bdflush.2:124
msgid "B<sync>(1), B<fsync>(2), B<sync>(2)"
msgstr ""

#. type: TH
#: man-pages/man2/pause.2:30
#, no-wrap
msgid "PAUSE"
msgstr ""

#. type: Plain text
#: man-pages/man2/pause.2:33
msgid "pause - wait for signal"
msgstr ""

#. type: Plain text
#: man-pages/man2/pause.2:37
msgid "B<int pause(void);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/pause.2:42
msgid ""
"B<pause>()  causes the calling process (or thread) to sleep until a signal "
"is delivered that either terminates the process or causes the invocation of "
"a signal-catching function."
msgstr ""

#.  .BR ERESTARTNOHAND .
#. type: Plain text
#: man-pages/man2/pause.2:53
msgid ""
"B<pause>()  returns only when a signal was caught and the signal-catching "
"function returned.  In this case, B<pause>()  returns -1, and I<errno> is "
"set to B<EINTR>."
msgstr ""

#. type: Plain text
#: man-pages/man2/pause.2:57
msgid "a signal was caught and the signal-catching function returned."
msgstr ""

#. type: Plain text
#: man-pages/man2/pause.2:63
msgid "B<kill>(2), B<select>(2), B<signal>(2), B<sigsuspend>(2)"
msgstr ""

#. type: TH
#: man-pages/man2/process_vm_readv.2:29
#, no-wrap
msgid "PROCESS_VM_READV"
msgstr ""

#. type: Plain text
#: man-pages/man2/process_vm_readv.2:32
msgid ""
"process_vm_readv, process_vm_writev - transfer data between process address "
"spaces"
msgstr ""

#. type: Plain text
#: man-pages/man2/process_vm_readv.2:42
#, no-wrap
msgid ""
"B<ssize_t process_vm_readv(pid_t >I<pid>B<,>\n"
"B<                         const struct iovec *>I<local_iov>B<,>\n"
"B<                         unsigned long >I<liovcnt>B<,>\n"
"B<                         const struct iovec *>I<remote_iov>B<,>\n"
"B<                         unsigned long >I<riovcnt>B<,>\n"
"B<                         unsigned long >I<flags>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/process_vm_readv.2:49
#, no-wrap
msgid ""
"B<ssize_t process_vm_writev(pid_t >I<pid>B<,>\n"
"B<                          const struct iovec *>I<local_iov>B<,>\n"
"B<                          unsigned long >I<liovcnt>B<,>\n"
"B<                          const struct iovec *>I<remote_iov>B<,>\n"
"B<                          unsigned long >I<riovcnt>B<,>\n"
"B<                          unsigned long >I<flags>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/process_vm_readv.2:58
msgid "B<process_vm_readv>(), B<process_vm_writev>():"
msgstr ""

#. type: Plain text
#: man-pages/man2/process_vm_readv.2:62
msgid "B<_GNU_SOURCE>"
msgstr ""

#. type: Plain text
#: man-pages/man2/process_vm_readv.2:72
msgid ""
"These system calls transfer data between the address space of the calling "
"process (\"the local process\") and the process identified by I<pid> (\"the "
"remote process\").  The data moves directly between the address spaces of "
"the two processes, without passing through kernel space."
msgstr ""

#. type: Plain text
#: man-pages/man2/process_vm_readv.2:97
msgid ""
"The B<process_vm_readv>()  system call transfers data from the remote "
"process to the local process.  The data to be transferred is identified by "
"I<remote_iov> and I<riovcnt>: I<remote_iov> is a pointer to an array "
"describing address ranges in the process I<pid>, and I<riovcnt> specifies "
"the number of elements in I<remote_iov>.  The data is transferred to the "
"locations specified by I<local_iov> and I<liovcnt>: I<local_iov> is a "
"pointer to an array describing address ranges in the calling process, and "
"I<liovcnt> specifies the number of elements in I<local_iov>."
msgstr ""

#. type: Plain text
#: man-pages/man2/process_vm_readv.2:111
msgid ""
"The B<process_vm_writev>()  system call is the converse of "
"B<process_vm_readv>()\\(emit transfers data from the local process to the "
"remote process.  Other than the direction of the transfer, the arguments "
"I<liovcnt>, I<local_iov>, I<riovcnt>, and I<remote_iov> have the same "
"meaning as for B<process_vm_readv>()."
msgstr ""

#. type: Plain text
#: man-pages/man2/process_vm_readv.2:121
msgid ""
"The I<local_iov> and I<remote_iov> arguments point to an array of I<iovec> "
"structures, defined in I<E<lt>sys/uio.hE<gt>> as:"
msgstr ""

#. type: Plain text
#: man-pages/man2/process_vm_readv.2:144
msgid ""
"Buffers are processed in array order.  This means that B<process_vm_readv>()  "
"completely fills I<local_iov[0]> before proceeding to I<local_iov[1]>, and "
"so on.  Likewise, I<remote_iov[0]> is completely read before proceeding to "
"I<remote_iov[1]>, and so on."
msgstr ""

#. type: Plain text
#: man-pages/man2/process_vm_readv.2:155
msgid ""
"Similarly, B<process_vm_writev>()  writes out the entire contents of "
"I<local_iov[0]> before proceeding to I<local_iov[1]>, and it completely "
"fills I<remote_iov[0]> before proceeding to I<remote_iov[1]>."
msgstr ""

#. type: Plain text
#: man-pages/man2/process_vm_readv.2:163
msgid ""
"The lengths of I<remote_iov[i].iov_len> and I<local_iov[i].iov_len> do not "
"have to be the same.  Thus, it is possible to split a single local buffer "
"into multiple remote buffers, or vice versa."
msgstr ""

#. type: Plain text
#: man-pages/man2/process_vm_readv.2:167
msgid "The I<flags> argument is currently unused and must be set to 0."
msgstr ""

#.  In time, glibc might provide a wrapper that works around this limit,
#.  as is done for readv()/writev()
#. type: Plain text
#: man-pages/man2/process_vm_readv.2:180
msgid ""
"The values specified in the I<liovcnt> and I<riovcnt> arguments must be less "
"than or equal to B<IOV_MAX> (defined in I<E<lt>limits.hE<gt>> or accessible "
"via the call I<sysconf(_SC_IOV_MAX)>)."
msgstr ""

#. type: Plain text
#: man-pages/man2/process_vm_readv.2:190
msgid ""
"The count arguments and I<local_iov> are checked before doing any "
"transfers.  If the counts are too big, or I<local_iov> is invalid, or the "
"addresses refer to regions that are inaccessible to the local process, none "
"of the vectors will be processed and an error will be returned immediately."
msgstr ""

#. type: Plain text
#: man-pages/man2/process_vm_readv.2:210
msgid ""
"Note, however, that these system calls do not check the memory regions in "
"the remote process until just before doing the read/write.  Consequently, a "
"partial read/write (see RETURN VALUE)  may result if one of the "
"I<remote_iov> elements points to an invalid memory region in the remote "
"process.  No further reads/writes will be attempted beyond that point.  Keep "
"this in mind when attempting to read data of unknown length (such as C "
"strings that are null-terminated) from a remote process, by avoiding "
"spanning memory pages (typically 4\\ KiB) in a single remote I<iovec> "
"element.  (Instead, split the remote read into two I<remote_iov> elements "
"and have them merge back into a single write I<local_iov> entry.  The first "
"read entry goes up to the page boundary, while the second starts on the next "
"page boundary.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/process_vm_readv.2:216
msgid ""
"Permission to read from or write to another process is governed by a ptrace "
"access mode B<PTRACE_MODE_ATTACH_REALCREDS> check; see B<ptrace>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/process_vm_readv.2:232
msgid ""
"On success, B<process_vm_readv>()  returns the number of bytes read and "
"B<process_vm_writev>()  returns the number of bytes written.  This return "
"value may be less than the total number of requested bytes, if a partial "
"read/write occurred.  (Partial transfers apply at the granularity of "
"I<iovec> elements.  These system calls won't perform a partial transfer that "
"splits a single I<iovec> element.)  The caller should check the return value "
"to determine whether a partial read/write occurred."
msgstr ""

#. type: Plain text
#: man-pages/man2/process_vm_readv.2:236
msgid "On error, -1 is returned and I<errno> is set appropriately."
msgstr ""

#. type: Plain text
#: man-pages/man2/process_vm_readv.2:242
msgid ""
"The memory described by I<local_iov> is outside the caller's accessible "
"address space."
msgstr ""

#. type: Plain text
#: man-pages/man2/process_vm_readv.2:248
msgid ""
"The memory described by I<remote_iov> is outside the accessible address "
"space of the process I<pid>."
msgstr ""

#. type: Plain text
#: man-pages/man2/process_vm_readv.2:259
msgid ""
"The sum of the I<iov_len> values of either I<local_iov> or I<remote_iov> "
"overflows a I<ssize_t> value."
msgstr ""

#. type: Plain text
#: man-pages/man2/process_vm_readv.2:263
msgid "I<flags> is not 0."
msgstr ""

#. type: Plain text
#: man-pages/man2/process_vm_readv.2:269
msgid "I<liovcnt> or I<riovcnt> is too large."
msgstr ""

#. type: Plain text
#: man-pages/man2/process_vm_readv.2:274
msgid "Could not allocate memory for internal copies of the I<iovec> structures."
msgstr ""

#. type: Plain text
#: man-pages/man2/process_vm_readv.2:278
msgid ""
"The caller does not have permission to access the address space of the "
"process I<pid>."
msgstr ""

#. type: Plain text
#: man-pages/man2/process_vm_readv.2:283
msgid "No process with ID I<pid> exists."
msgstr ""

#. type: Plain text
#: man-pages/man2/process_vm_readv.2:286
msgid ""
"These system calls were added in Linux 3.2.  Support is provided in glibc "
"since version 2.15."
msgstr ""

#. type: Plain text
#: man-pages/man2/process_vm_readv.2:294
msgid ""
"The data transfers performed by B<process_vm_readv>()  and "
"B<process_vm_writev>()  are not guaranteed to be atomic in any way."
msgstr ""

#.  Original user is MPI, http://www.mcs.anl.gov/research/projects/mpi/
#.  See also some benchmarks at http://lwn.net/Articles/405284/
#.  and http://marc.info/?l=linux-mm&m=130105930902915&w=2
#. type: Plain text
#: man-pages/man2/process_vm_readv.2:302
msgid ""
"These system calls were designed to permit fast message passing by allowing "
"messages to be exchanged with a single copy operation (rather than the "
"double copy that would be required when using, for example, shared memory or "
"pipes)."
msgstr ""

#. type: Plain text
#: man-pages/man2/process_vm_readv.2:310
msgid ""
"The following code sample demonstrates the use of B<process_vm_readv>().  It "
"reads 20 bytes at the address 0x10000 from the process with PID 10 and "
"writes the first 10 bytes into I<buf1> and the second 10 bytes into I<buf2>."
msgstr ""

#. type: Plain text
#: man-pages/man2/process_vm_readv.2:313
#, no-wrap
msgid "#include E<lt>sys/uio.hE<gt>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/process_vm_readv.2:323
#, no-wrap
msgid ""
"int\n"
"main(void)\n"
"{\n"
"    struct iovec local[2];\n"
"    struct iovec remote[1];\n"
"    char buf1[10];\n"
"    char buf2[10];\n"
"    ssize_t nread;\n"
"    pid_t pid = 10;             /* PID of remote process */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/process_vm_readv.2:330
#, no-wrap
msgid ""
"    local[0].iov_base = buf1;\n"
"    local[0].iov_len = 10;\n"
"    local[1].iov_base = buf2;\n"
"    local[1].iov_len = 10;\n"
"    remote[0].iov_base = (void *) 0x10000;\n"
"    remote[0].iov_len = 20;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/process_vm_readv.2:337
#, no-wrap
msgid ""
"    nread = process_vm_readv(pid, local, 2, remote, 1, 0);\n"
"    if (nread != 20)\n"
"        return 1;\n"
"    else\n"
"        return 0;\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/process_vm_readv.2:340
msgid "B<readv>(2), B<writev>(2)"
msgstr ""

#. type: TH
#: man-pages/man2/pread.2:25
#, no-wrap
msgid "PREAD"
msgstr ""

#. type: Plain text
#: man-pages/man2/pread.2:28
msgid "pread, pwrite - read from or write to a file descriptor at a given offset"
msgstr ""

#. type: Plain text
#: man-pages/man2/pread.2:33
msgid ""
"B<ssize_t pread(int >I<fd>B<, void *>I<buf>B<, size_t >I<count>B<, off_t "
">I<offset>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/pread.2:36
msgid ""
"B<ssize_t pwrite(int >I<fd>B<, const void *>I<buf>B<, size_t >I<count>B<, "
"off_t >I<offset>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/pread.2:46
msgid "B<pread>(), B<pwrite>():"
msgstr ""

#. type: Plain text
#: man-pages/man2/pread.2:50
msgid "|| /* Since glibc 2.12: */ _POSIX_C_SOURCE\\ E<gt>=\\ 200809L"
msgstr ""

#. type: Plain text
#: man-pages/man2/pread.2:64
msgid ""
"B<pread>()  reads up to I<count> bytes from file descriptor I<fd> at offset "
"I<offset> (from the start of the file) into the buffer starting at I<buf>.  "
"The file offset is not changed."
msgstr ""

#. type: Plain text
#: man-pages/man2/pread.2:75
msgid ""
"B<pwrite>()  writes up to I<count> bytes from the buffer starting at I<buf> "
"to the file descriptor I<fd> at offset I<offset>.  The file offset is not "
"changed."
msgstr ""

#. type: Plain text
#: man-pages/man2/pread.2:79
msgid "The file referenced by I<fd> must be capable of seeking."
msgstr ""

#. type: Plain text
#: man-pages/man2/pread.2:87
msgid ""
"On success, B<pread>()  returns the number of bytes read (a return of zero "
"indicates end of file)  and B<pwrite>()  returns the number of bytes "
"written."
msgstr ""

#. type: Plain text
#: man-pages/man2/pread.2:97
msgid ""
"On error, -1 is returned and I<errno> is set to indicate the cause of the "
"error."
msgstr ""

#. type: Plain text
#: man-pages/man2/pread.2:112
msgid ""
"B<pread>()  can fail and set I<errno> to any error specified for B<read>(2)  "
"or B<lseek>(2).  B<pwrite>()  can fail and set I<errno> to any error "
"specified for B<write>(2)  or B<lseek>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/pread.2:123
msgid ""
"The B<pread>()  and B<pwrite>()  system calls were added to Linux in version "
"2.1.60; the entries in the i386 system call table were added in 2.1.69.  C "
"library support (including emulation using B<lseek>(2)  on older kernels "
"without the system calls) was added in glibc 2.1."
msgstr ""

#. type: Plain text
#: man-pages/man2/pread.2:134
msgid ""
"The B<pread>()  and B<pwrite>()  system calls are especially useful in "
"multithreaded applications.  They allow multiple threads to perform I/O on "
"the same file descriptor without being affected by changes to the file "
"offset by other threads."
msgstr ""

#. type: Plain text
#: man-pages/man2/pread.2:150
msgid ""
"On Linux, the underlying system calls were renamed in kernel 2.6: B<pread>()  "
"became B<pread64>(), and B<pwrite>()  became B<pwrite64>().  The system call "
"numbers remained the same.  The glibc B<pread>()  and B<pwrite>()  wrapper "
"functions transparently deal with the change."
msgstr ""

#.  FIXME . https://bugzilla.kernel.org/show_bug.cgi?id=43178
#. type: Plain text
#: man-pages/man2/pread.2:167
msgid ""
"POSIX requires that opening a file with the B<O_APPEND> flag should have no "
"effect on the location at which B<pwrite>()  writes data.  However, on "
"Linux, if a file is opened with B<O_APPEND>, B<pwrite>()  appends data to "
"the end of the file, regardless of the value of I<offset>."
msgstr ""

#. type: Plain text
#: man-pages/man2/pread.2:171
msgid "B<lseek>(2), B<read>(2), B<readv>(2), B<write>(2)"
msgstr ""

#. type: TH
#: man-pages/man2/sigpending.2:29
#, no-wrap
msgid "SIGPENDING"
msgstr ""

#. type: Plain text
#: man-pages/man2/sigpending.2:32
msgid "sigpending, rt_sigpending - examine pending signals"
msgstr ""

#. type: Plain text
#: man-pages/man2/sigpending.2:36
msgid "B<int sigpending(sigset_t *>I<set>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/sigpending.2:45
msgid "B<sigpending>(): _POSIX_C_SOURCE"
msgstr ""

#. type: Plain text
#: man-pages/man2/sigpending.2:53
msgid ""
"B<sigpending>()  returns the set of signals that are pending for delivery to "
"the calling thread (i.e., the signals which have been raised while "
"blocked).  The mask of pending signals is returned in I<set>."
msgstr ""

#. type: Plain text
#: man-pages/man2/sigpending.2:59
msgid ""
"B<sigpending>()  returns 0 on success and -1 on error.  In the event of an "
"error, I<errno> is set to indicate the cause."
msgstr ""

#. type: Plain text
#: man-pages/man2/sigpending.2:64
msgid ""
"I<set> points to memory which is not a valid part of the process address "
"space."
msgstr ""

#. type: Plain text
#: man-pages/man2/sigpending.2:74
msgid ""
"If a signal is both blocked and has a disposition of \"ignored\", it is "
"I<not> added to the mask of pending signals when generated."
msgstr ""

#. type: Plain text
#: man-pages/man2/sigpending.2:79
msgid ""
"The set of signals that is pending for a thread is the union of the set of "
"signals that is pending for that thread and the set of signals that is "
"pending for the process as a whole; see B<signal>(7)."
msgstr ""

#. type: Plain text
#: man-pages/man2/sigpending.2:86
msgid ""
"A child created via B<fork>(2)  initially has an empty pending signal set; "
"the pending signal set is preserved across an B<execve>(2)."
msgstr ""

#.  This argument is currently required to be less than or equal to
#.  .IR sizeof(sigset_t)
#.  (or the error
#.  .B EINVAL
#.  results).
#. type: Plain text
#: man-pages/man2/sigpending.2:113
msgid ""
"The original Linux system call was named B<sigpending>().  However, with the "
"addition of real-time signals in Linux 2.2, the fixed-size, 32-bit "
"I<sigset_t> argument supported by that system call was no longer fit for "
"purpose.  Consequently, a new system call, B<rt_sigpending>(), was added to "
"support an enlarged I<sigset_t> type.  The new system call takes a second "
"argument, I<size_t sigsetsize>, which specifies the size in bytes of the "
"signal set in I<set>.  The glibc B<sigpending>()  wrapper function hides "
"these details from us, transparently calling B<rt_sigpending>()  when the "
"kernel provides it."
msgstr ""

#. type: Plain text
#: man-pages/man2/sigpending.2:119
msgid ""
"In versions of glibc up to and including 2.2.1, there is a bug in the "
"wrapper function for B<sigpending>()  which means that information about "
"pending real-time signals is not correctly returned."
msgstr ""

#. type: Plain text
#: man-pages/man2/sigpending.2:126
msgid ""
"B<kill>(2), B<sigaction>(2), B<signal>(2), B<sigprocmask>(2), "
"B<sigsuspend>(2), B<sigsetops>(3), B<signal>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/unimplemented.2:26
#, no-wrap
msgid "UNIMPLEMENTED"
msgstr ""

#. type: Plain text
#: man-pages/man2/unimplemented.2:31
msgid ""
"afs_syscall, break, fattach, fdetach, ftime, getmsg, getpmsg, gtty, "
"isastream, lock, madvise1, mpx, prof, profil, putmsg, putpmsg, security, "
"stty, tuxcall, ulimit, vserver - unimplemented system calls"
msgstr ""

#. type: Plain text
#: man-pages/man2/unimplemented.2:33
msgid "Unimplemented system calls."
msgstr ""

#. type: Plain text
#: man-pages/man2/unimplemented.2:35
msgid "These system calls are not implemented in the Linux kernel."
msgstr ""

#. type: Plain text
#: man-pages/man2/unimplemented.2:40
msgid "These system calls always return -1 and set I<errno> to B<ENOSYS>."
msgstr ""

#. type: Plain text
#: man-pages/man2/unimplemented.2:47
msgid ""
"Note that B<ftime>(3), B<profil>(3), and B<ulimit>(3)  are implemented as "
"library functions."
msgstr ""

#. type: Plain text
#: man-pages/man2/unimplemented.2:56
msgid ""
"Some system calls, like B<alloc_hugepages>(2), B<free_hugepages>(2), "
"B<ioperm>(2), B<iopl>(2), and B<vm86>(2)  exist only on certain "
"architectures."
msgstr ""

#. type: Plain text
#: man-pages/man2/unimplemented.2:64
msgid ""
"Some system calls, like B<ipc>(2), B<create_module>(2), B<init_module>(2), "
"and B<delete_module>(2)  exist only when the Linux kernel was built with "
"support for them."
msgstr ""

#. type: Plain text
#: man-pages/man2/unimplemented.2:65
msgid "B<syscalls>(2)"
msgstr ""

#. type: TH
#: man-pages/man2/close.2:36
#, no-wrap
msgid "CLOSE"
msgstr ""

#. type: Plain text
#: man-pages/man2/close.2:39
msgid "close - close a file descriptor"
msgstr ""

#. type: Plain text
#: man-pages/man2/close.2:44
#, no-wrap
msgid "B<int close(int >I<fd>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/close.2:54
msgid ""
"B<close>()  closes a file descriptor, so that it no longer refers to any "
"file and may be reused.  Any record locks (see B<fcntl>(2))  held on the "
"file it was associated with, and owned by the process, are removed "
"(regardless of the file descriptor that was used to obtain the lock)."
msgstr ""

#. type: Plain text
#: man-pages/man2/close.2:65
msgid ""
"If I<fd> is the last file descriptor referring to the underlying open file "
"description (see B<open>(2)), the resources associated with the open file "
"description are freed; if the file descriptor was the last reference to a "
"file which has been removed using B<unlink>(2), the file is deleted."
msgstr ""

#. type: Plain text
#: man-pages/man2/close.2:71
msgid ""
"B<close>()  returns zero on success.  On error, -1 is returned, and I<errno> "
"is set appropriately."
msgstr ""

#. type: Plain text
#: man-pages/man2/close.2:76
msgid "I<fd> isn't a valid open file descriptor."
msgstr ""

#.  Though, it's in doubt whether this error can ever occur; see
#.  https://lwn.net/Articles/576478/ "Returning EINTR from close()"
#. type: Plain text
#: man-pages/man2/close.2:84
msgid "The B<close>()  call was interrupted by a signal; see B<signal>(7)."
msgstr ""

#. type: Plain text
#: man-pages/man2/close.2:96
msgid ""
"On NFS, these errors are not normally reported against the first write which "
"exceeds the available storage space, but instead against a subsequent "
"B<write>(2), B<fsync>(2), or B<close>()."
msgstr ""

#. type: Plain text
#: man-pages/man2/close.2:100
msgid ""
"See NOTES for a discussion of why B<close>()  should not be retried after an "
"error."
msgstr ""

#. type: Plain text
#: man-pages/man2/close.2:111
msgid ""
"A successful close does not guarantee that the data has been successfully "
"saved to disk, as the kernel uses the buffer cache to defer writes.  "
"Typically, filesystems do not flush buffers when a file is closed.  If you "
"need to be sure that the data is physically stored on the underlying disk, "
"use B<fsync>(2).  (It will depend on the disk hardware at this point.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/close.2:118
msgid ""
"The close-on-exec file descriptor flag can be used to ensure that a file "
"descriptor is automatically closed upon a successful B<execve>(2); see "
"B<fcntl>(2)  for details."
msgstr ""

#.  Date: Tue, 4 Sep 2007 13:57:35 +0200
#.  From: Fredrik Noring <noring@nocrew.org>
#.  One such race involves signals and ERESTARTSYS. If a file descriptor
#.  in use by a system call is closed and then reused by e.g. an
#.  independent open() in some unrelated thread, before the original system
#.  call has restarted after ERESTARTSYS, the original system call will
#.  later restart with the reused file descriptor. This is most likely a
#.  serious programming error.
#. type: Plain text
#: man-pages/man2/close.2:134
msgid ""
"It is probably unwise to close file descriptors while they may be in use by "
"system calls in other threads in the same process.  Since a file descriptor "
"may be reused, there are some obscure race conditions that may cause "
"unintended side effects."
msgstr ""

#. type: SS
#: man-pages/man2/close.2:134
#, no-wrap
msgid "Dealing with error returns from close()"
msgstr ""

#. type: Plain text
#: man-pages/man2/close.2:146
msgid ""
"A careful programmer will check the return value of B<close>(), since it is "
"quite possible that errors on a previous B<write>(2)  operation are reported "
"only on the final B<close>()  that releases the open file description.  "
"Failing to check the return value when closing a file may lead to I<silent> "
"loss of data.  This can especially be observed with NFS and with disk quota."
msgstr ""

#. type: Plain text
#: man-pages/man2/close.2:152
msgid ""
"Note, however, that a failure return should be used only for diagnostic "
"purposes (i.e., a warning to the application that there may still be I/O "
"pending or there may have been failed I/O)  or remedial purposes (e.g., "
"writing the file once more or creating a backup)."
msgstr ""

#.  The file descriptor is released early in close();
#.  close() ==> __close_fd():
#. 			__put_unused_fd() ==> __clear_open_fd()
#. 			return filp_close(file, files);
#
#.  The errors are returned by filp_close() after the FD has been
#.  cleared for re-use.
#.  filp_close()
#. type: Plain text
#: man-pages/man2/close.2:173
msgid ""
"Retrying the B<close>()  after a failure return is the wrong thing to do, "
"since this may cause a reused file descriptor from another thread to be "
"closed.  This can occur because the Linux kernel I<always> releases the file "
"descriptor early in the close operation, freeing it for reuse; the steps "
"that may return an error, such as flushing data to the filesystem or device, "
"occur only later in the close operation."
msgstr ""

#.  FreeBSD documents this explicitly. From the look of the source code
#.  SVR4, ancient SunOS, later Solaris, and AIX all do this.
#.  Issue 8
#. type: Plain text
#: man-pages/man2/close.2:186
msgid ""
"Many other implementations similarly always close the file descriptor "
"(except in the case of B<EBADF>, meaning that the file descriptor was "
"invalid)  even if they subsequently report an error on return from "
"B<close>().  POSIX.1 is currently silent on this point, but there are plans "
"to mandate this behavior in the next major release of the standard."
msgstr ""

#. type: Plain text
#: man-pages/man2/close.2:191
msgid ""
"A careful programmer who wants to know about I/O errors may precede "
"B<close>()  with a call to B<fsync>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/close.2:198
msgid ""
"The B<EINTR> error is a somewhat special case.  Regarding the B<EINTR> "
"error, POSIX.1-2013 says:"
msgstr ""

#. type: Plain text
#: man-pages/man2/close.2:209
msgid ""
"If B<close>()  is interrupted by a signal that is to be caught, it shall "
"return -1 with I<errno> set to B<EINTR> and the state of I<fildes> is "
"unspecified."
msgstr ""

#.  FIXME . for later review when Issue 8 is one day released...
#.  POSIX proposes further changes for EINTR
#.  http://austingroupbugs.net/tag_view_page.php?tag_id=8
#.  http://austingroupbugs.net/view.php?id=529
#
#.  FIXME .
#.  Review the following glibc bug later
#.  https://sourceware.org/bugzilla/show_bug.cgi?id=14627
#. type: Plain text
#: man-pages/man2/close.2:244
msgid ""
"This permits the behavior that occurs on Linux and many other "
"implementations, where, as with other errors that may be reported by "
"B<close>(), the file descriptor is guaranteed to be closed.  However, it "
"also permits another possibility: that the implementation returns an "
"B<EINTR> error and keeps the file descriptor open.  (According to its "
"documentation, HP-UX's B<close>()  does this.)  The caller must then once "
"more use B<close>()  to close the file descriptor, to avoid file descriptor "
"leaks.  This divergence in implementation behaviors provides a difficult "
"hurdle for portable applications, since on many implementations, B<close>()  "
"must not be called again after an B<EINTR> error, and on at least one, "
"B<close>()  must be called again.  There are plans to address this conundrum "
"for the next major release of the POSIX.1 standard."
msgstr ""

#. type: Plain text
#: man-pages/man2/close.2:250
msgid ""
"B<fcntl>(2), B<fsync>(2), B<open>(2), B<shutdown>(2), B<unlink>(2), "
"B<fclose>(3)"
msgstr ""

#. type: TH
#: man-pages/man2/sched_rr_get_interval.2:29
#, no-wrap
msgid "SCHED_RR_GET_INTERVAL"
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_rr_get_interval.2:32
msgid "sched_rr_get_interval - get the SCHED_RR interval for the named process"
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_rr_get_interval.2:36
msgid "B<int sched_rr_get_interval(pid_t >I<pid>B<, struct timespec *>I<tp>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_rr_get_interval.2:47
msgid ""
"B<sched_rr_get_interval>()  writes into the I<timespec> structure pointed to "
"by I<tp> the round-robin time quantum for the process identified by I<pid>.  "
"The specified process should be running under the B<SCHED_RR> scheduling "
"policy."
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_rr_get_interval.2:51
msgid "The I<timespec> structure has the following form:"
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_rr_get_interval.2:58
#, no-wrap
msgid ""
"struct timespec {\n"
"    time_t tv_sec;    /* seconds */\n"
"    long   tv_nsec;   /* nanoseconds */\n"
"};\n"
msgstr ""

#.  FIXME . On Linux, sched_rr_get_interval()
#.  returns the timeslice for SCHED_OTHER processes -- this timeslice
#.  is influenced by the nice value.
#.  For SCHED_FIFO processes, this always returns 0.
#
#.  The round-robin time quantum value is not alterable under Linux
#.  1.3.81.
#. type: Plain text
#: man-pages/man2/sched_rr_get_interval.2:73
msgid ""
"If I<pid> is zero, the time quantum for the calling process is written into "
"I<*tp>."
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_rr_get_interval.2:80
msgid ""
"On success, B<sched_rr_get_interval>()  returns 0.  On error, -1 is "
"returned, and I<errno> is set appropriately."
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_rr_get_interval.2:84
msgid "Problem with copying information to user space."
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_rr_get_interval.2:87
msgid "Invalid pid."
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_rr_get_interval.2:90
msgid "The system call is not yet implemented (only on rather old kernels)."
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_rr_get_interval.2:94
msgid "Could not find a process with the ID I<pid>."
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_rr_get_interval.2:103
msgid ""
"POSIX systems on which B<sched_rr_get_interval>()  is available define "
"B<_POSIX_PRIORITY_SCHEDULING> in I<E<lt>unistd.hE<gt>>."
msgstr ""

#.  commit a4ec24b48ddef1e93f7578be53270f0b95ad666c
#. type: Plain text
#: man-pages/man2/sched_rr_get_interval.2:117
msgid ""
"POSIX does not specify any mechanism for controlling the size of the "
"round-robin time quantum.  Older Linux kernels provide a (nonportable) "
"method of doing this.  The quantum can be controlled by adjusting the "
"process's nice value (see B<setpriority>(2)).  Assigning a negative (i.e., "
"high) nice value results in a longer quantum; assigning a positive (i.e., "
"low) nice value results in a shorter quantum.  The default quantum is 0.1 "
"seconds; the degree to which changing the nice value affects the quantum has "
"varied somewhat across kernel versions.  This method of adjusting the "
"quantum was removed starting with Linux 2.6.24."
msgstr ""

#.  commit ce0dbbbb30aee6a835511d5be446462388ba9eee
#.  .SH BUGS
#.  As of Linux 1.3.81
#.  .BR sched_rr_get_interval ()
#.  returns with error
#.  ENOSYS, because SCHED_RR has not yet been fully implemented and tested
#.  properly.
#. type: Plain text
#: man-pages/man2/sched_rr_get_interval.2:132
msgid ""
"Linux 3.9 added a new mechanism for adjusting (and viewing) the B<SCHED_RR> "
"quantum: the I</proc/sys/kernel/sched_rr_timeslice_ms> file exposes the "
"quantum as a millisecond value, whose default is 100.  Writing 0 to this "
"file resets the quantum to the default value."
msgstr ""
