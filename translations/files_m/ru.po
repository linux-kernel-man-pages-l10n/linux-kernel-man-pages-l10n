# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# 
# Translators:
# aereiae <aereiae@gmail.com>, 2014
# aereiae <aereiae@gmail.com>, 2014
# Alexey, 2016
# Alexey <a.chepugov@gmail.com>, 2015
# Alexey, 2016
# Azamat Hackimov <azamat.hackimov@gmail.com>, 2013-2017
# Dmitriy S. Seregin <dseregin@59.ru>, 2013
# Dmitry Bolkhovskikh <d20052005@yandex.ru>, 2017
# ITriskTI <ITriskTI@gmail.com>, 2013
# ITriskTI <ITriskTI@gmail.com>, 2013
# Max Is <ismax799@gmail.com>, 2016
# Dmitriy S. Seregin <dseregin@59.ru>, 2013
# Yuri Kozlov <yuray@komyakino.ru>, 2011-2019
# Yuri Kozlov <yuray@komyakino.ru>, 2013
# Alexey <a.chepugov@gmail.com>, 2015
# Иван Павлов <pavia00@gmail.com>, 2017
# Малянов Евгений Викторович <maljanow@outlook.com>, 2014
msgid ""
msgstr ""
"Project-Id-Version: translation of man-pages\n"
"POT-Creation-Date: 2019-08-26 09:26+0300\n"
"PO-Revision-Date: 2019-08-26 06:21+0000\n"
"Last-Translator: Yuri Kozlov <yuray@komyakino.ru>\n"
"Language-Team: Russian (http://www.transifex.com/kruvalig/man-pages/language/ru/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ru\n"
"Plural-Forms: nplurals=4; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n%10<=4 && (n%100<12 || n%100>14) ? 1 : n%10==0 || (n%10>=5 && n%10<=9) || (n%100>=11 && n%100<=14)? 2 : 3);\n"

#. type: TH
#: man-pages/man4/msr.4:26
#, no-wrap
msgid "MSR"
msgstr "MSR"

#. type: TH
#: man-pages/man4/msr.4:26
#, no-wrap
msgid "2009-03-31"
msgstr "2009-03-31"

#. type: TH
#: man-pages/man4/msr.4:26
#, no-wrap
msgid "Linux"
msgstr "Linux"

#. type: TH
#: man-pages/man4/msr.4:26
#, no-wrap
msgid "Linux Programmer's Manual"
msgstr "Руководство программиста Linux"

#. type: SH
#: man-pages/man4/msr.4:27
#, no-wrap
msgid "NAME"
msgstr "ИМЯ"

#. type: Plain text
#: man-pages/man4/msr.4:29
msgid "msr - x86 CPU MSR access device"
msgstr "msr - устройство доступа к MSR процессоров x86"

#. type: SH
#: man-pages/man4/msr.4:29
#, no-wrap
msgid "DESCRIPTION"
msgstr "ОПИСАНИЕ"

#. type: Plain text
#: man-pages/man4/msr.4:36
msgid ""
"I</dev/cpu/CPUNUM/msr> provides an interface to read and write the model-"
"specific registers (MSRs) of an x86 CPU.  I<CPUNUM> is the number of the CPU"
" to access as listed in I</proc/cpuinfo>."
msgstr "Устройство I</dev/cpu/CPUNUM/msr> предоставляет интерфейс для чтения и записи в специальные регистры модели (model-specific registers, MSR) процессоров x86. В I<CPUNUM> задаётся номер процессора для доступа; номера перечислены в I</proc/cpuinfo>."

#. type: Plain text
#: man-pages/man4/msr.4:42
msgid ""
"The register access is done by opening the file and seeking to the MSR "
"number as offset in the file, and then reading or writing in chunks of 8 "
"bytes.  An I/O transfer of more than 8 bytes means multiple reads or writes "
"of the same register."
msgstr "Доступ к регистру выполняется открытием файла и переходом в файле по смещению под номером нужного MSR; чтение и запись производится порциями по 8 байт. Ввод/вывод более 8 байт выполняется несколькими операциями чтения или записи в нужный регистр."

#. type: Plain text
#: man-pages/man4/msr.4:47
msgid ""
"This file is protected so that it can be read and written only by the user "
"I<root>, or members of the group I<root>."
msgstr "Файл доступен на чтение и запись только пользователю I<root> или членам группы I<root>."

#. type: SH
#: man-pages/man4/msr.4:47
#, no-wrap
msgid "NOTES"
msgstr "ЗАМЕЧАНИЯ"

#. type: Plain text
#: man-pages/man4/msr.4:53
msgid ""
"The I<msr> driver is not auto-loaded.  On modular kernels you might need to "
"use the following command to load it explicitly before use:"
msgstr "Драйвер I<msr> автоматически не загружается. В модульных ядрах нужно выполнить загрузку явно:"

#. type: Plain text
#: man-pages/man4/msr.4:57
#, no-wrap
msgid "$ modprobe msr\n"
msgstr "$ modprobe msr\n"

#. type: SH
#: man-pages/man4/msr.4:60
#, no-wrap
msgid "SEE ALSO"
msgstr "СМОТРИТЕ ТАКЖЕ"

#. type: Plain text
#: man-pages/man4/msr.4:63
msgid ""
"Intel Corporation Intel 64 and IA-32 Architectures Software Developer's "
"Manual Volume 3B Appendix B, for an overview of the Intel CPU MSRs."
msgstr "Intel Corporation Intel 64 and IA-32 Architectures Software Developer's Manual Volume 3B Appendix B for an overview of the Intel CPU MSRs."

#. type: TH
#: man-pages/man4/mem.4:26
#, no-wrap
msgid "MEM"
msgstr "MEM"

#. type: TH
#: man-pages/man4/mem.4:26
#, no-wrap
msgid "2015-01-02"
msgstr "2015-01-02"

#. type: Plain text
#: man-pages/man4/mem.4:29
msgid "mem, kmem, port - system memory, kernel memory and system ports"
msgstr "mem, kmem, port - системная память, память ядра и порты системы"

#. type: Plain text
#: man-pages/man4/mem.4:34
msgid ""
"I</dev/mem> is a character device file that is an image of the main memory "
"of the computer.  It may be used, for example, to examine (and even patch) "
"the system."
msgstr "Файл I</dev/mem> — это файл символьного устройства, представляющий образ физической памяти компьютера. Этот файл может быть использован для исследования системы (и даже для внесения в неё исправлений)."

#. type: Plain text
#: man-pages/man4/mem.4:39
msgid ""
"Byte addresses in I</dev/mem> are interpreted as physical memory addresses."
"  References to nonexistent locations cause errors to be returned."
msgstr "Адреса байтов в I</dev/mem> рассматриваются как адреса физической памяти. При ссылках на несуществующие адреса возвращаются ошибки."

#. type: Plain text
#: man-pages/man4/mem.4:42
msgid ""
"Examining and patching is likely to lead to unexpected results when read-"
"only or write-only bits are present."
msgstr "Исследование системы или внесение в неё исправлений иногда приводят к непредвиденным результатам в том случае, если есть биты, которые разрешается только читать или только записывать."

#. type: Plain text
#: man-pages/man4/mem.4:49
msgid ""
"Since Linux 2.6.26, and depending on the architecture, the "
"B<CONFIG_STRICT_DEVMEM> kernel configuration option limits the areas which "
"can be accessed through this file.  For example: on x86, RAM access is not "
"allowed but accessing memory-mapped PCI regions is."
msgstr "Начиная с версии Linux 2.6.26 и в зависимости от архитектуры, параметр настройки ядра B<CONFIG_STRICT_DEVMEM> ограничивает области, к которым можно получить доступ через этот файл. Например, на архитектуре x86 доступ к ОЗУ не разрешен, однако к отображенной в области PCI памяти доступ есть."

#. type: Plain text
#: man-pages/man4/mem.4:51 man-pages/man4/mem.4:70 man-pages/man4/mem.4:84
msgid "It is typically created by:"
msgstr "Обычно, этот файл создается так:"

#. type: Plain text
#: man-pages/man4/mem.4:56
#, no-wrap
msgid ""
"mknod -m 660 /dev/mem c 1 1\n"
"chown root:kmem /dev/mem\n"
msgstr "mknod -m 660 /dev/mem c 1 1\nchown root:kmem /dev/mem\n"

#. type: Plain text
#: man-pages/man4/mem.4:68
msgid ""
"The file I</dev/kmem> is the same as I</dev/mem>, except that the kernel "
"virtual memory rather than physical memory is accessed.  Since Linux 2.6.26,"
" this file is available only if the B<CONFIG_DEVKMEM> kernel configuration "
"option is enabled."
msgstr "Файл I</dev/kmem> идентичен файлу I</dev/mem> за исключением того, что обеспечивает доступ к виртуальной памяти ядра, а не к физической. Начиная с версии Linux 2.6.26, этот файл становится доступен только после включения параметра настройки ядра B<CONFIG_DEVKMEM>."

#. type: Plain text
#: man-pages/man4/mem.4:75
#, no-wrap
msgid ""
"mknod -m 640 /dev/kmem c 1 2\n"
"chown root:kmem /dev/kmem\n"
msgstr "mknod -m 640 /dev/kmem c 1 2\nchown root:kmem /dev/kmem\n"

#. type: Plain text
#: man-pages/man4/mem.4:82
msgid ""
"I</dev/port> is similar to I</dev/mem>, but the I/O ports are accessed."
msgstr "Файл I</dev/port> похож на I</dev/mem>, но предоставляет доступ к портам ввода-вывода."

#. type: Plain text
#: man-pages/man4/mem.4:89
#, no-wrap
msgid ""
"mknod -m 660 /dev/port c 1 4\n"
"chown root:kmem /dev/port\n"
msgstr "mknod -m 660 /dev/port c 1 4\nchown root:kmem /dev/port\n"

#. type: SH
#: man-pages/man4/mem.4:91
#, no-wrap
msgid "FILES"
msgstr "ФАЙЛЫ"

#. type: Plain text
#: man-pages/man4/mem.4:93
msgid "I</dev/mem>"
msgstr "I</dev/mem>"

#. type: Plain text
#: man-pages/man4/mem.4:95
msgid "I</dev/kmem>"
msgstr "I</dev/kmem>"

#. type: Plain text
#: man-pages/man4/mem.4:97
msgid "I</dev/port>"
msgstr "I</dev/port>"

#. type: Plain text
#: man-pages/man4/mem.4:100
msgid "B<chown>(1), B<mknod>(1), B<ioperm>(2)"
msgstr "B<chown>(1), B<mknod>(1), B<ioperm>(2)"

#. type: TH
#: man-pages/man4/mouse.4:26
#, no-wrap
msgid "MOUSE"
msgstr "MOUSE"

#. type: TH
#: man-pages/man4/mouse.4:26
#, no-wrap
msgid "2016-10-08"
msgstr "2016-10-08"

#. type: Plain text
#: man-pages/man4/mouse.4:29
msgid "mouse - serial mouse interface"
msgstr "mouse - последовательный интерфейс мыши"

#. type: SH
#: man-pages/man4/mouse.4:29
#, no-wrap
msgid "CONFIGURATION"
msgstr "НАСТРОЙКА"

#. type: Plain text
#: man-pages/man4/mouse.4:33
msgid ""
"Serial mice are connected to a serial RS232/V24 dialout line, see B<ttyS>(4)"
"  for a description."
msgstr "Мышь подключается последовательному порту RS232/V24, описание смотрите в B<ttyS>(4)."

#. type: SS
#: man-pages/man4/mouse.4:34
#, no-wrap
msgid "Introduction"
msgstr "Введение"

#. type: Plain text
#: man-pages/man4/mouse.4:36
msgid "The pinout of the usual 9 pin plug as used for serial mice is:"
msgstr "Описание разъёма c 9 контактами, используемого для подключения мыши: "

#. type: tbl table
#: man-pages/man4/mouse.4:40
#, no-wrap
msgid "pin"
msgstr "контакт"

#. type: tbl table
#: man-pages/man4/mouse.4:40
#, no-wrap
msgid "name"
msgstr "название"

#. type: tbl table
#: man-pages/man4/mouse.4:40
#, no-wrap
msgid "used for"
msgstr "назначение"

#. type: tbl table
#: man-pages/man4/mouse.4:41 man-pages/man4/mouse.4:101
#: man-pages/man4/mouse.4:146 man-pages/man4/mouse.4:182
#, no-wrap
msgid "2"
msgstr "2"

#. type: tbl table
#: man-pages/man4/mouse.4:41
#, no-wrap
msgid "RX"
msgstr "RX"

#. type: tbl table
#: man-pages/man4/mouse.4:41
#, no-wrap
msgid "Data"
msgstr "Данные"

#. type: tbl table
#: man-pages/man4/mouse.4:42 man-pages/man4/mouse.4:102
#: man-pages/man4/mouse.4:147 man-pages/man4/mouse.4:183
#, no-wrap
msgid "3"
msgstr "3"

#. type: tbl table
#: man-pages/man4/mouse.4:42
#, no-wrap
msgid "TX"
msgstr "TX"

#. type: tbl table
#: man-pages/man4/mouse.4:42
#, no-wrap
msgid "-12 V, Imax = 10 mA"
msgstr "-12 В, Iмакс = 10 мА"

#. type: tbl table
#: man-pages/man4/mouse.4:43 man-pages/man4/mouse.4:148
#, no-wrap
msgid "4"
msgstr "4"

#. type: tbl table
#: man-pages/man4/mouse.4:43
#, no-wrap
msgid "DTR"
msgstr "DTR"

#. type: tbl table
#: man-pages/man4/mouse.4:43 man-pages/man4/mouse.4:44
#, no-wrap
msgid "+12 V, Imax = 10 mA"
msgstr "+12 В, Iмакс = 10 мА"

#. type: tbl table
#: man-pages/man4/mouse.4:44
#, no-wrap
msgid "7"
msgstr "7"

#. type: tbl table
#: man-pages/man4/mouse.4:44
#, no-wrap
msgid "RTS"
msgstr "RTS"

#. type: tbl table
#: man-pages/man4/mouse.4:45 man-pages/man4/mouse.4:149
#, no-wrap
msgid "5"
msgstr "5"

#. type: tbl table
#: man-pages/man4/mouse.4:45
#, no-wrap
msgid "GND"
msgstr "GND"

#. type: tbl table
#: man-pages/man4/mouse.4:45
#, no-wrap
msgid "Ground"
msgstr "Земля"

#. type: Plain text
#: man-pages/man4/mouse.4:49
msgid "This is the specification, in fact 9 V suffices with most mice."
msgstr "Такое описание приводится в документации, почти любой мыши хватает 9 V."

#. type: Plain text
#: man-pages/man4/mouse.4:55
msgid ""
"The mouse driver can recognize a mouse by dropping RTS to low and raising it"
" again.  About 14 ms later the mouse will send 0x4D (\\(aqM\\(aq) on the "
"data line.  After a further 63 ms, a Microsoft-compatible 3-button mouse "
"will send 0x33 (\\(aq3\\(aq)."
msgstr "Драйвер мыши может распознать мышь, посылая низкий сигнал RTS и затем высокий. Примерно через 14 миллисекунд мышь пошлёт 0x4D (\\(aqM\\(aq) по линии данных. Ещё через 63 миллисекунды трёх-кнопочная Microsoft-совместимая мышь пошлёт 0x33 (\\(aq3\\(aq)."

#. type: Plain text
#: man-pages/man4/mouse.4:67
msgid ""
"The relative mouse movement is sent as I<dx> (positive means right)  and "
"I<dy> (positive means down).  Various mice can operate at different speeds."
"  To select speeds, cycle through the speeds 9600, 4800, 2400, and 1200 "
"bit/s, each time writing the two characters from the table below and waiting"
" 0.1 seconds.  The following table shows available speeds and the strings "
"that select them:"
msgstr "Относительное движение мыши посылается как I<dx> (положительное значение означает движение направо) и I<dy> (положительное значение означает движение вниз). Различные мыши могут работать на разных скоростях. Для определения скорости устанавливаются следующие её значения (по очереди): 9600, 4800, 2400 и 1200 бит/с; каждый раз при установке значения скорости пишутся 2 символа из таблицы, приведённой ниже, и после этого выполняется ожидание, равное 0,1 секунды. В таблице указаны скорости и символы, соответствующие им:"

#. type: tbl table
#: man-pages/man4/mouse.4:71
#, no-wrap
msgid "bit/s"
msgstr "бит/с"

#. type: tbl table
#: man-pages/man4/mouse.4:71
#, no-wrap
msgid "string"
msgstr "строка"

#. type: tbl table
#: man-pages/man4/mouse.4:72
#, no-wrap
msgid "9600"
msgstr "9600"

#. type: tbl table
#: man-pages/man4/mouse.4:72
#, no-wrap
msgid "*q"
msgstr "*q"

#. type: tbl table
#: man-pages/man4/mouse.4:73
#, no-wrap
msgid "4800"
msgstr "4800"

#. type: tbl table
#: man-pages/man4/mouse.4:73
#, no-wrap
msgid "*p"
msgstr "*p"

#. type: tbl table
#: man-pages/man4/mouse.4:74
#, no-wrap
msgid "2400"
msgstr "2400"

#. type: tbl table
#: man-pages/man4/mouse.4:74
#, no-wrap
msgid "*o"
msgstr "*o"

#. type: tbl table
#: man-pages/man4/mouse.4:75
#, no-wrap
msgid "1200"
msgstr "1200"

#. type: tbl table
#: man-pages/man4/mouse.4:75
#, no-wrap
msgid "*n"
msgstr "*n"

#. type: Plain text
#: man-pages/man4/mouse.4:79
msgid ""
"The first byte of a data packet can be used for synchronization purposes."
msgstr "Первый байт из пакета данных может использоваться для синхронизации."

#. type: SS
#: man-pages/man4/mouse.4:79
#, no-wrap
msgid "Microsoft protocol"
msgstr "Протокол Microsoft"

#. type: Plain text
#: man-pages/man4/mouse.4:95
msgid ""
"The B<Microsoft> protocol uses 1 start bit, 7 data bits, no parity and one "
"stop bit at the speed of 1200 bits/sec.  Data is sent to RxD in 3-byte "
"packets.  The I<dx> and I<dy> movements are sent as two's-complement, I<lb> "
"(I<rb>)  are set when the left (right)  button is pressed:"
msgstr "В протоколе B<Microsoft> используется один начальный бит, 7 битов данных (без проверки четности), один стоп-бит; протокол работает со скоростью 1200 бит/с. Данные пересылаются по RxD трёх-байтовыми пакетами. Движения по I<dx> и I<dy> пересылаются в коде дополнения до 2. Значения I<lb> (I<rb>), устанавливаемые при нажатии левой (правой) кнопки:"

#. type: tbl table
#: man-pages/man4/mouse.4:99 man-pages/man4/mouse.4:144
#: man-pages/man4/mouse.4:180
#, no-wrap
msgid "byte"
msgstr "байт"

#. type: tbl table
#: man-pages/man4/mouse.4:99 man-pages/man4/mouse.4:144
#: man-pages/man4/mouse.4:180
#, no-wrap
msgid "d6"
msgstr "d6"

#. type: tbl table
#: man-pages/man4/mouse.4:99 man-pages/man4/mouse.4:144
#: man-pages/man4/mouse.4:180
#, no-wrap
msgid "d5"
msgstr "d5"

#. type: tbl table
#: man-pages/man4/mouse.4:99 man-pages/man4/mouse.4:144
#: man-pages/man4/mouse.4:180
#, no-wrap
msgid "d4"
msgstr "d4"

#. type: tbl table
#: man-pages/man4/mouse.4:99 man-pages/man4/mouse.4:144
#: man-pages/man4/mouse.4:180
#, no-wrap
msgid "d3"
msgstr "d3"

#. type: tbl table
#: man-pages/man4/mouse.4:99 man-pages/man4/mouse.4:144
#: man-pages/man4/mouse.4:180
#, no-wrap
msgid "d2"
msgstr "d2"

#. type: tbl table
#: man-pages/man4/mouse.4:99 man-pages/man4/mouse.4:144
#: man-pages/man4/mouse.4:180
#, no-wrap
msgid "d1"
msgstr "d1"

#. type: tbl table
#: man-pages/man4/mouse.4:99 man-pages/man4/mouse.4:144
#: man-pages/man4/mouse.4:180
#, no-wrap
msgid "d0"
msgstr "d0"

#. type: tbl table
#: man-pages/man4/mouse.4:100 man-pages/man4/mouse.4:145
#: man-pages/man4/mouse.4:181
#, no-wrap
msgid "1"
msgstr "1"

#. type: tbl table
#: man-pages/man4/mouse.4:100 man-pages/man4/mouse.4:145
#: man-pages/man4/mouse.4:181
#, no-wrap
msgid "lb"
msgstr "lb"

#. type: tbl table
#: man-pages/man4/mouse.4:100 man-pages/man4/mouse.4:145
#: man-pages/man4/mouse.4:181
#, no-wrap
msgid "rb"
msgstr "rb"

#. type: tbl table
#: man-pages/man4/mouse.4:100
#, no-wrap
msgid "dy7"
msgstr "dy7"

#. type: tbl table
#: man-pages/man4/mouse.4:100 man-pages/man4/mouse.4:183
#, no-wrap
msgid "dy6"
msgstr "dy6"

#. type: tbl table
#: man-pages/man4/mouse.4:100
#, no-wrap
msgid "dx7"
msgstr "dx7"

#. type: tbl table
#: man-pages/man4/mouse.4:100 man-pages/man4/mouse.4:182
#, no-wrap
msgid "dx6"
msgstr "dx6"

#. type: tbl table
#: man-pages/man4/mouse.4:101 man-pages/man4/mouse.4:102
#: man-pages/man4/mouse.4:145 man-pages/man4/mouse.4:146
#: man-pages/man4/mouse.4:147 man-pages/man4/mouse.4:148
#: man-pages/man4/mouse.4:149 man-pages/man4/mouse.4:181
#: man-pages/man4/mouse.4:182 man-pages/man4/mouse.4:183
#, no-wrap
msgid "0"
msgstr "0"

#. type: tbl table
#: man-pages/man4/mouse.4:101 man-pages/man4/mouse.4:182
#, no-wrap
msgid "dx5"
msgstr "dx5"

#. type: tbl table
#: man-pages/man4/mouse.4:101 man-pages/man4/mouse.4:182
#, no-wrap
msgid "dx4"
msgstr "dx4"

#. type: tbl table
#: man-pages/man4/mouse.4:101 man-pages/man4/mouse.4:182
#, no-wrap
msgid "dx3"
msgstr "dx3"

#. type: tbl table
#: man-pages/man4/mouse.4:101 man-pages/man4/mouse.4:182
#, no-wrap
msgid "dx2"
msgstr "dx2"

#. type: tbl table
#: man-pages/man4/mouse.4:101 man-pages/man4/mouse.4:182
#, no-wrap
msgid "dx1"
msgstr "dx1"

#. type: tbl table
#: man-pages/man4/mouse.4:101 man-pages/man4/mouse.4:182
#, no-wrap
msgid "dx0"
msgstr "dx0"

#. type: tbl table
#: man-pages/man4/mouse.4:102 man-pages/man4/mouse.4:183
#, no-wrap
msgid "dy5"
msgstr "dy5"

#. type: tbl table
#: man-pages/man4/mouse.4:102 man-pages/man4/mouse.4:183
#, no-wrap
msgid "dy4"
msgstr "dy4"

#. type: tbl table
#: man-pages/man4/mouse.4:102 man-pages/man4/mouse.4:183
#, no-wrap
msgid "dy3"
msgstr "dy3"

#. type: tbl table
#: man-pages/man4/mouse.4:102 man-pages/man4/mouse.4:183
#, no-wrap
msgid "dy2"
msgstr "dy2"

#. type: tbl table
#: man-pages/man4/mouse.4:102 man-pages/man4/mouse.4:183
#, no-wrap
msgid "dy1"
msgstr "dy1"

#. type: tbl table
#: man-pages/man4/mouse.4:102 man-pages/man4/mouse.4:183
#, no-wrap
msgid "dy0"
msgstr "dy0"

#. type: SS
#: man-pages/man4/mouse.4:104
#, no-wrap
msgid "3-button Microsoft protocol"
msgstr "Протокол Microsoft для трёх-кнопочной мыши"

#. type: Plain text
#: man-pages/man4/mouse.4:113
msgid ""
"Original Microsoft mice only have two buttons.  However, there are some "
"three button mice which also use the Microsoft protocol.  Pressing or "
"releasing the middle button is reported by sending a packet with zero "
"movement and no buttons pressed.  (Thus, unlike for the other two buttons, "
"the status of the middle button is not reported in each packet.)"
msgstr "Первоначально мышь Microsoft имела две кнопки. Но есть несколько трёх-кнопочных мышей, также использующих протокол Microsoft. О нажатии или отпускании средней кнопки сообщается  отправкой пакета с нулевым движением и ненажатыми клавишами. (Таким образом, в отличие от двух других кнопок, состояние средней в каждом пакете не передаётся)."

#. type: SS
#: man-pages/man4/mouse.4:113
#, no-wrap
msgid "Logitech protocol"
msgstr "Протокол Logitech"

#. type: Plain text
#: man-pages/man4/mouse.4:122
msgid ""
"Logitech serial 3-button mice use a different extension of the Microsoft "
"protocol: when the middle button is up, the above 3-byte packet is sent.  "
"When the middle button is down a 4-byte packet is sent, where the 4th byte "
"has value 0x20 (or at least has the 0x20 bit set).  In particular, a press "
"of the middle button is reported as 0,0,0,0x20 when no other buttons are "
"down."
msgstr "Трёх-кнопочная мышь Logitech представляет собой расширенный вариант протокола Microsoft: когда средняя кнопка отпущена, посылается вышеописанный трёх-байтовый пакет, а когда она нажата, посылается четырёх-байтовый пакет, где четвёртый байт имеет значение 0x20 (или, как минимум, в нём установлен бит 0x20). В частности, о нажатии средней кнопки сообщается с помощью пакета 0,0,0,0x20 при том, что остальные кнопки остаются ненажатыми."

#. type: SS
#: man-pages/man4/mouse.4:122
#, no-wrap
msgid "Mousesystems protocol"
msgstr "Протокол Mousesystems"

#. type: Plain text
#: man-pages/man4/mouse.4:140
msgid ""
"The B<Mousesystems> protocol uses 1 start bit, 8 data bits, no parity and "
"two stop bits at the speed of 1200 bits/sec.  Data is sent to RxD in 5-byte "
"packets.  I<dx> is sent as the sum of the two two's-complement values, I<dy>"
" is send as negated sum of the two two's-complement values.  I<lb> (I<mb>, "
"I<rb>)  are cleared when the left (middle, right) button is pressed:"
msgstr "В протоколе B<Mousesystems> используется один начальный бит, 8 битов данных, без проверки чётности и два стоп-бита при скорости 1200 бит/с. Данные посылаются по RxD пяти-байтовыми пакетами. I<dx> посылается как сумма значений в коде дополнения до 2, I<dy> посылается как отрицательная сумма значений в коде дополнения до 2. I<lb> (I<mb>, I<rb>) обнуляются при нажатии левой (средней, правой) кнопки:"

#. type: tbl table
#: man-pages/man4/mouse.4:144 man-pages/man4/mouse.4:180
#, no-wrap
msgid "d7"
msgstr "d7"

#. type: tbl table
#: man-pages/man4/mouse.4:145 man-pages/man4/mouse.4:181
#, no-wrap
msgid "mb"
msgstr "mb"

#. type: tbl table
#: man-pages/man4/mouse.4:146
#, no-wrap
msgid "dxa6"
msgstr "dxa6"

#. type: tbl table
#: man-pages/man4/mouse.4:146
#, no-wrap
msgid "dxa5"
msgstr "dxa5"

#. type: tbl table
#: man-pages/man4/mouse.4:146
#, no-wrap
msgid "dxa4"
msgstr "dxa4"

#. type: tbl table
#: man-pages/man4/mouse.4:146
#, no-wrap
msgid "dxa3"
msgstr "dxa3"

#. type: tbl table
#: man-pages/man4/mouse.4:146
#, no-wrap
msgid "dxa2"
msgstr "dxa2"

#. type: tbl table
#: man-pages/man4/mouse.4:146
#, no-wrap
msgid "dxa1"
msgstr "dxa1"

#. type: tbl table
#: man-pages/man4/mouse.4:146
#, no-wrap
msgid "dxa0"
msgstr "dxa0"

#. type: tbl table
#: man-pages/man4/mouse.4:147
#, no-wrap
msgid "dya6"
msgstr "dya6"

#. type: tbl table
#: man-pages/man4/mouse.4:147
#, no-wrap
msgid "dya5"
msgstr "dya5"

#. type: tbl table
#: man-pages/man4/mouse.4:147
#, no-wrap
msgid "dya4"
msgstr "dya4"

#. type: tbl table
#: man-pages/man4/mouse.4:147
#, no-wrap
msgid "dya3"
msgstr "dya3"

#. type: tbl table
#: man-pages/man4/mouse.4:147
#, no-wrap
msgid "dya2"
msgstr "dya2"

#. type: tbl table
#: man-pages/man4/mouse.4:147
#, no-wrap
msgid "dya1"
msgstr "dya1"

#. type: tbl table
#: man-pages/man4/mouse.4:147
#, no-wrap
msgid "dya0"
msgstr "dya0"

#. type: tbl table
#: man-pages/man4/mouse.4:148
#, no-wrap
msgid "dxb6"
msgstr "dxb6"

#. type: tbl table
#: man-pages/man4/mouse.4:148
#, no-wrap
msgid "dxb5"
msgstr "dxb5"

#. type: tbl table
#: man-pages/man4/mouse.4:148
#, no-wrap
msgid "dxb4"
msgstr "dxb4"

#. type: tbl table
#: man-pages/man4/mouse.4:148
#, no-wrap
msgid "dxb3"
msgstr "dxb3"

#. type: tbl table
#: man-pages/man4/mouse.4:148
#, no-wrap
msgid "dxb2"
msgstr "dxb2"

#. type: tbl table
#: man-pages/man4/mouse.4:148
#, no-wrap
msgid "dxb1"
msgstr "dxb1"

#. type: tbl table
#: man-pages/man4/mouse.4:148
#, no-wrap
msgid "dxb0"
msgstr "dxb0"

#. type: tbl table
#: man-pages/man4/mouse.4:149
#, no-wrap
msgid "dyb6"
msgstr "dyb6"

#. type: tbl table
#: man-pages/man4/mouse.4:149
#, no-wrap
msgid "dyb5"
msgstr "dyb5"

#. type: tbl table
#: man-pages/man4/mouse.4:149
#, no-wrap
msgid "dyb4"
msgstr "dyb4"

#. type: tbl table
#: man-pages/man4/mouse.4:149
#, no-wrap
msgid "dyb3"
msgstr "dyb3"

#. type: tbl table
#: man-pages/man4/mouse.4:149
#, no-wrap
msgid "dyb2"
msgstr "dyb2"

#. type: tbl table
#: man-pages/man4/mouse.4:149
#, no-wrap
msgid "dyb1"
msgstr "dyb1"

#. type: tbl table
#: man-pages/man4/mouse.4:149
#, no-wrap
msgid "dyb0"
msgstr "dyb0"

#. type: Plain text
#: man-pages/man4/mouse.4:154
msgid ""
"Bytes 4 and 5 describe the change that occurred since bytes 2 and 3 were "
"transmitted."
msgstr "Четвёртый и пятый байты описывают изменения, произошедшие за время передачи второго и третьего байта."

#. type: SS
#: man-pages/man4/mouse.4:154
#, no-wrap
msgid "Sun protocol"
msgstr "Протокол Sun"

#. type: Plain text
#: man-pages/man4/mouse.4:159
msgid ""
"The B<Sun> protocol is the 3-byte version of the above 5-byte Mousesystems "
"protocol: the last two bytes are not sent."
msgstr "Протокол B<Sun> представляет собой трёх-байтовую версию протокола Mousesystems (описанного выше): два последних байта не отсылаются."

#. type: SS
#: man-pages/man4/mouse.4:159
#, no-wrap
msgid "MM protocol"
msgstr "Протокол MM"

#. type: Plain text
#: man-pages/man4/mouse.4:176
msgid ""
"The B<MM> protocol uses 1 start bit, 8 data bits, odd parity and one stop "
"bit at the speed of 1200 bits/sec.  Data is sent to RxD in 3-byte packets.  "
"I<dx> and I<dy> are sent as single signed values, the sign bit indicating a "
"negative value.  I<lb> (I<mb>, I<rb>)  are set when the left (middle, right)"
" button is pressed:"
msgstr "В протоколе B<MM>  используется один начальный бит, 8 битов данных, контроль по нечётности и один стоп-бит при скорости 1200 бит/с. Данные посылаются по RxD трёх-байтовыми пакетами. I<dx> и I<dy> отсылаются как единичные значения со знаком, бит знака указывает на отрицательное значение. I<lb> (I<mb>, I<rb>) устанавливаются при нажатии левой (средней, правой) кнопки:"

#. type: tbl table
#: man-pages/man4/mouse.4:181
#, no-wrap
msgid "dxs"
msgstr "dxs"

#. type: tbl table
#: man-pages/man4/mouse.4:181
#, no-wrap
msgid "dys"
msgstr "dys"

#. type: TP
#: man-pages/man4/mouse.4:186
#, no-wrap
msgid "I</dev/mouse>"
msgstr "I</dev/mouse>"

#. type: Plain text
#: man-pages/man4/mouse.4:189
msgid "A commonly used symbolic link pointing to a mouse device."
msgstr "Обычно используется символьная ссылка на устройство мыши."

#. type: Plain text
#: man-pages/man4/mouse.4:191
msgid "B<ttyS>(4), B<gpm>(8)"
msgstr "B<ttyS>(4), B<gpm>(8)"

#. type: TH
#: man-pages/man1/memusage.1:24
#, no-wrap
msgid "MEMUSAGE"
msgstr "MEMUSAGE"

#. type: TH
#: man-pages/man1/memusage.1:24
#, no-wrap
msgid "2019-03-06"
msgstr "2019-03-06"

#. type: TH
#: man-pages/man1/memusage.1:24
#, no-wrap
msgid "GNU"
msgstr "GNU"

#. type: TH
#: man-pages/man1/memusage.1:24
#, no-wrap
msgid "Linux user manual"
msgstr "Руководство пользователя Linux"

#. type: Plain text
#: man-pages/man1/memusage.1:27
msgid "memusage - profile memory usage of a program"
msgstr "memusage - исследует использование памяти программы"

#. type: SH
#: man-pages/man1/memusage.1:27
#, no-wrap
msgid "SYNOPSIS"
msgstr "ОБЗОР"

#. type: Plain text
#: man-pages/man1/memusage.1:29
msgid "B<memusage> [I<option>]... I<program> [I<programoption>]..."
msgstr "B<memusage> [I<параметры>]… I<программа> [I<параметры_программы>]…"

#. type: Plain text
#: man-pages/man1/memusage.1:53
msgid ""
"B<memusage> is a bash script which profiles memory usage of the program, "
"I<program>.  It preloads the B<libmemusage.so> library into the caller's "
"environment (via the B<LD_PRELOAD> environment variable; see B<ld.so>(8)).  "
"The B<libmemusage.so> library traces memory allocation by intercepting calls"
" to B<malloc>(3), B<calloc>(3), B<free>(3), and B<realloc>(3); optionally, "
"calls to B<mmap>(2), B<mremap>(2), and B<munmap>(2)  can also be "
"intercepted."
msgstr "Программа B<memusage> представляет собой сценарий bash, который описывает использование памяти I<программой>. Сценарий загружает библиотеку B<libmemusage.so> в окружение вызывающего (через переменную окружения B<LD_PRELOAD>, смотрите B<ld.so>(8)). Библиотека B<libmemusage.so> отслеживает распределение памяти путём перехвата вызовов B<malloc>(3), B<calloc>(3), B<free>(3) и B<realloc>(3); при необходимости, также могут быть перехвачены вызовы B<mmap>(2), B<mremap>(2) и B<munmap>(2)."

#. type: Plain text
#: man-pages/man1/memusage.1:62
msgid ""
"B<memusage> can output the collected data in textual form, or it can use "
"B<memusagestat>(1)  (see the B<-p> option, below)  to create a PNG file "
"containing graphical representation of the collected data."
msgstr "B<memusage> может выводить собранные данные в текстовом виде, также может использовать B<memusagestat>(1) (смотрите вариант B<-р> далее) для того, чтобы создать файл PNG, содержащий графическое представление собранных данных."

#. type: SS
#: man-pages/man1/memusage.1:62
#, no-wrap
msgid "Memory usage summary"
msgstr "Сводка использование памяти"

#. type: Plain text
#: man-pages/man1/memusage.1:66
msgid ""
"The \"Memory usage summary\" line output by B<memusage> contains three "
"fields:"
msgstr "Выводимая B<memusage> строка \"сводка использование памяти\" содержит три поля:"

#. type: TP
#: man-pages/man1/memusage.1:67
#, no-wrap
msgid "B<heap total>"
msgstr "B<heap total>"

#. type: Plain text
#: man-pages/man1/memusage.1:84
msgid ""
"Sum of I<size> arguments of all B<malloc>(3)  calls, products of arguments "
"(I<nmemb>*I<size>) of all B<calloc>(3)  calls, and sum of I<length> "
"arguments of all B<mmap>(2)  calls.  In the case of B<realloc>(3)  and "
"B<mremap>(2), if the new size of an allocation is larger than the previous "
"size, the sum of all such differences (new size minus old size) is added."
msgstr "Сумма  аргументов I<size>  всех вызовов B<malloc> (3), результат аргументов (I<nmemb>*I<size>) всех вызовов B<calloc>(3) и сумма аргументов I<length> всех вызовов B<mmap> (2) . В случае B<realloc> (3) и B<mremap> (2), если новый размер блока адресов больше, чем в предыдущий размер, добавляется сумма всех таких различий (новый размер минус старый размер)."

#. type: TP
#: man-pages/man1/memusage.1:84
#, no-wrap
msgid "B<heap peak>"
msgstr "B<heap peak>"

#. type: Plain text
#: man-pages/man1/memusage.1:98
msgid ""
"Maximum of all I<size> arguments of B<malloc>(3), all products of "
"I<nmemb>*I<size> of B<calloc>(3), all I<size> arguments of B<realloc>(3), "
"I<length> arguments of B<mmap>(2), and I<new_size> arguments of "
"B<mremap>(2)."
msgstr "Максимальное значение всех аргументов I<size> у B<malloc>(3), все произведения I<nmemb>*I<size> у B<calloc>(3), все аргументы I<size> у B<realloc>(3), аргументы I<length> у B<mmap>(2) и аргументы I<new_size> у B<mremap>(2)."

#. type: TP
#: man-pages/man1/memusage.1:98
#, no-wrap
msgid "B<stack peak>"
msgstr "B<stack peak>"

#. type: Plain text
#: man-pages/man1/memusage.1:105
msgid ""
"Before the first call to any monitored function, the stack pointer address "
"(base stack pointer) is saved.  After each function call, the actual stack "
"pointer address is read and the difference from the base stack pointer "
"computed.  The maximum of these differences is then the stack peak."
msgstr "Перед первым вызовом любой отслеживаемой функции сохраняется адрес указателя стека (базовый указатель стека). После каждого вызова функции читается текущий адрес указателя стека и вычисляет разница с базовым указателем стека. Максимальное значение среди вычитаний является пиком стека."

#. type: Plain text
#: man-pages/man1/memusage.1:122
msgid ""
"Immediately following this summary line, a table shows the number calls, "
"total memory allocated or deallocated, and number of failed calls for each "
"intercepted function.  For B<realloc>(3)  and B<mremap>(2), the additional "
"field \"nomove\" shows reallocations that changed the address of a block, "
"and the additional \"dec\" field shows reallocations that decreased the size"
" of the block.  For B<realloc>(3), the additional field \"free\" shows "
"reallocations that caused a block to be freed (i.e., the reallocated size "
"was 0)."
msgstr "Сразу за строкой итога в таблице для каждой перехваченной функции показывается количество вызовов, общее количество выделенной и освобождённой памяти и количество вызовов с ошибками. Для B<realloc>(3) и B<mremap>(2) также есть поле «nomove», показывающее переразмещения, у которых изменился адрес блока, и поле «dec», показывающее переразмещения, у которых уменьшился размер блока. Для B<realloc>(3) в дополнительном поле «free» показываются переразмещения, которые были вызваны освобождением блока (т. е., размер переразмещения был равен 0)."

#. type: Plain text
#: man-pages/man1/memusage.1:131
msgid ""
"The \"realloc/total memory\" of the table output by B<memusage> does not "
"reflect cases where B<realloc>(3)  is used to reallocate a block of memory "
"to have a smaller size than previously.  This can cause sum of all \"total "
"memory\" cells (excluding \"free\")  to be larger than the \"free/total "
"memory\" cell."
msgstr "Таблица «realloc/total memory», выводимая B<memusage>, не отражает случаи, где B<realloc>(3) используется для переразмещения блока памяти меньшего размера, чем предыдущий. Это может привести к тому, что сумма всех ячеек «total memory» (кроме «free») будет больше, чем ячейка «free/total memory»."

#. type: SS
#: man-pages/man1/memusage.1:131
#, no-wrap
msgid "Histogram for block sizes"
msgstr "Гистограмма размеров блоков"

#. type: Plain text
#: man-pages/man1/memusage.1:134
msgid ""
"The \"Histogram for block sizes\" provides a breakdown of memory allocations"
" into various bucket sizes."
msgstr "«Гистограмма размеров блоков»  выдает разбивку адресованных блоков по размерам."

#. type: SH
#: man-pages/man1/memusage.1:134
#, no-wrap
msgid "OPTIONS"
msgstr "ПАРАМЕТРЫ"

#. type: TP
#: man-pages/man1/memusage.1:135
#, no-wrap
msgid "B<-n\\ >I<name>,\\ B<--progname=>I<name>"
msgstr "B<-n\\ >I<имя>,\\ B<--progname=>I<имя>"

#. type: Plain text
#: man-pages/man1/memusage.1:138
msgid "Name of the program file to profile."
msgstr "Имя файла профилируемой программы."

#. type: TP
#: man-pages/man1/memusage.1:138
#, no-wrap
msgid "B<-p\\ >I<file>,\\ B<--png=>I<file>"
msgstr "B<-p\\ >I<file>,\\ B<--png=>I<file>"

#. type: Plain text
#: man-pages/man1/memusage.1:142
msgid "Generate PNG graphic and store it in I<file>."
msgstr "Создать изображение в формате PNG и сохранить его в "

#. type: TP
#: man-pages/man1/memusage.1:142
#, no-wrap
msgid "B<-d\\ >I<file>,\\ B<--data=>I<file>"
msgstr "B<-d\\ >I<файл>,\\ B<--data=>I<файл>"

#. type: Plain text
#: man-pages/man1/memusage.1:146
msgid "Generate binary data file and store it in I<file>."
msgstr "Создать двоичный файл данных и сохранить его в I<файл>."

#. type: TP
#: man-pages/man1/memusage.1:146
#, no-wrap
msgid "B<-u>,\\ B<--unbuffered>"
msgstr "B<-u>,\\ B<--unbuffered>"

#. type: Plain text
#: man-pages/man1/memusage.1:149
msgid "Do not buffer output."
msgstr "Не буферизуйте вывод."

#. type: TP
#: man-pages/man1/memusage.1:149
#, no-wrap
msgid "B<-b\\ >I<size>,\\ B<--buffer=>I<size>"
msgstr "B<-b\\ >I<size>,\\ B<--buffer=>I<size>"

#. type: Plain text
#: man-pages/man1/memusage.1:154
msgid "Collect I<size> entries before writing them out."
msgstr "Собрать I<size> записей перед тем, как записать их."

#. type: TP
#: man-pages/man1/memusage.1:154
#, no-wrap
msgid "B<--no-timer>"
msgstr "B<--no-timer>"

#. type: Plain text
#: man-pages/man1/memusage.1:159
msgid "Disable timer-based (B<SIGPROF>)  sampling of stack pointer value."
msgstr "Отключить измерение значения указателя стека на основе таймера (B<SIGPROF>)."

#. type: TP
#: man-pages/man1/memusage.1:159
#, no-wrap
msgid "B<-m>,\\ B<--mmap>"
msgstr "B<-m>,\\ B<--mmap>"

#. type: Plain text
#: man-pages/man1/memusage.1:166
msgid "Also trace B<mmap>(2), B<mremap>(2), and B<munmap>(2)."
msgstr "Также трассировать B<mmap>(2), B<mremap>(2) и B<munmap>(2)."

#. type: TP
#: man-pages/man1/memusage.1:166
#, no-wrap
msgid "B<-?>,\\ B<--help>"
msgstr "B<-?>,\\ B<--help>"

#. type: Plain text
#: man-pages/man1/memusage.1:169
msgid "Print help and exit."
msgstr "Показать справку по использованию и завершить работу."

#. type: TP
#: man-pages/man1/memusage.1:169
#, no-wrap
msgid "B<--usage>"
msgstr "B<--usage>"

#. type: Plain text
#: man-pages/man1/memusage.1:172
msgid "Print a short usage message and exit."
msgstr "Показать короткое сообщение об использовании и завершить работу."

#. type: TP
#: man-pages/man1/memusage.1:172
#, no-wrap
msgid "B<-V>,\\ B<--version>"
msgstr "B<-V>,\\ B<--version>"

#. type: Plain text
#: man-pages/man1/memusage.1:175
msgid "Print version information and exit."
msgstr "Показать информацию о версии и завершить работу."

#. type: TP
#: man-pages/man1/memusage.1:175
#, no-wrap
msgid "The following options apply only when generating graphical output:"
msgstr "Следующие параметры применяются только когда используется графический вывод:"

#. type: TP
#: man-pages/man1/memusage.1:177
#, no-wrap
msgid "B<-t>,\\ B<--time-based>"
msgstr "B<-t>,\\ B<--time-based>"

#. type: Plain text
#: man-pages/man1/memusage.1:180
msgid ""
"Use time (rather than number of function calls) as the scale for the X axis."
msgstr "По оси X — время (а не количество вызовов функций)."

#. type: TP
#: man-pages/man1/memusage.1:180
#, no-wrap
msgid "B<-T>,\\ B<--total>"
msgstr "B<-T>,\\ B<--total>"

#. type: Plain text
#: man-pages/man1/memusage.1:183
msgid "Also draw a graph of total memory use."
msgstr "Построить также график общего использования памяти."

#. type: TP
#: man-pages/man1/memusage.1:183
#, no-wrap
msgid "B<--title=>I<name>"
msgstr "B<--title=>I<название>"

#. type: Plain text
#: man-pages/man1/memusage.1:188
msgid "Use I<name> as the title of the graph."
msgstr "Использовать I<название> в качестве заголовка графика."

#. type: TP
#: man-pages/man1/memusage.1:188
#, no-wrap
msgid "B<-x\\ >I<size>,\\ B<--x-size=>I<size>"
msgstr "B<-x\\ >I<size>,\\ B<--x-size=>I<size>"

#. type: Plain text
#: man-pages/man1/memusage.1:193
msgid "Make the graph I<size> pixels wide."
msgstr "Рисовать график шириной в I<size> пикселов."

#. type: TP
#: man-pages/man1/memusage.1:193
#, no-wrap
msgid "B<-y\\ >I<size>,\\ B<--y-size=>I<size>"
msgstr "B<-y\\ >I<size>,\\ B<--y-size=>I<size>"

#. type: Plain text
#: man-pages/man1/memusage.1:198
msgid "Make the graph I<size> pixels high."
msgstr "Рисовать график высотой в I<size> пикселов."

#. type: SH
#: man-pages/man1/memusage.1:198
#, no-wrap
msgid "EXIT STATUS"
msgstr "КОД РЕЗУЛЬТАТА"

#. type: Plain text
#: man-pages/man1/memusage.1:200
msgid "Exit status is equal to the exit status of profiled program."
msgstr "Код завершения работы равен коду выхода профилируемой программы."

#. type: SH
#: man-pages/man1/memusage.1:200
#, no-wrap
msgid "BUGS"
msgstr "ДЕФЕКТЫ"

#. type: Plain text
#: man-pages/man1/memusage.1:204
msgid ""
"To report bugs, see E<.UR http://www.gnu.org/software/libc/bugs.html> E<.UE>"
msgstr "Сообщения об ошибках доступны по адресу E<.UR http://www.gnu.org/software/libc/bugs.html> E<.UE>"

#. type: SH
#: man-pages/man1/memusage.1:204
#, no-wrap
msgid "EXAMPLE"
msgstr "ПРИМЕР"

#. type: Plain text
#: man-pages/man1/memusage.1:211
msgid ""
"Below is a simple program that reallocates a block of memory in cycles that "
"rise to a peak before then cyclically reallocating the memory in smaller "
"blocks that return to zero.  After compiling the program and running the "
"following commands, a graph of the memory usage of the program can be found "
"in the file I<memusage.png>:"
msgstr "Ниже показана простая программа, которая переразмещает блок памяти в цикле, который достигает пика до того как размер циклически переразмещаемой памяти достигнет нуля. После компиляции программы и запуска следующих команд график использования памяти программой можно найти в файле I<memusage.png>:"

#. type: Plain text
#: man-pages/man1/memusage.1:235
#, no-wrap
msgid ""
"$ B<memusage --data=memusage.dat ./a.out>\n"
"\\&...\n"
"Memory usage summary: heap total: 45200, heap peak: 6440, stack peak: 224\n"
"        total calls  total memory  failed calls\n"
" malloc|         1           400             0\n"
"realloc|        40         44800             0  (nomove:40, dec:19, free:0)\n"
" calloc|         0             0             0\n"
"   free|         1           440\n"
"Histogram for block sizes:\n"
"  192-207             1   2% ================\n"
"\\&...\n"
" 2192-2207            1   2% ================\n"
" 2240-2255            2   4% =================================\n"
" 2832-2847            2   4% =================================\n"
" 3440-3455            2   4% =================================\n"
" 4032-4047            2   4% =================================\n"
" 4640-4655            2   4% =================================\n"
" 5232-5247            2   4% =================================\n"
" 5840-5855            2   4% =================================\n"
" 6432-6447            1   2% ================\n"
"$ B<memusagestat memusage.dat memusage.png>\n"
msgstr "$ B<memusage --data=memusage.dat ./a.out>\n\\&...\nMemory usage summary: heap total: 45200, heap peak: 6440, stack peak: 224\n        total calls  total memory  failed calls\n malloc|         1           400             0\nrealloc|        40         44800             0  (nomove:40, dec:19, free:0)\n calloc|         0             0             0\n   free|         1           440\nHistogram for block sizes:\n  192-207             1   2% ================\n\\&...\n 2192-2207            1   2% ================\n 2240-2255            2   4% =================================\n 2832-2847            2   4% =================================\n 3440-3455            2   4% =================================\n 4032-4047            2   4% =================================\n 4640-4655            2   4% =================================\n 5232-5247            2   4% =================================\n 5840-5855            2   4% =================================\n 6432-6447            1   2% ================\n$ B<memusagestat memusage.dat memusage.png>\n"

#. type: SS
#: man-pages/man1/memusage.1:237
#, no-wrap
msgid "Program source"
msgstr "Исходный код программы"

#. type: Plain text
#: man-pages/man1/memusage.1:241
#, no-wrap
msgid ""
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
msgstr "#include E<lt>stdio.hE<gt>\n#include E<lt>stdlib.hE<gt>\n"

#. type: Plain text
#: man-pages/man1/memusage.1:243
#, no-wrap
msgid "#define CYCLES 20\n"
msgstr "#define CYCLES 20\n"

#. type: Plain text
#: man-pages/man1/memusage.1:249
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"     int i, j;\n"
"     int *p;\n"
msgstr "int\nmain(int argc, char *argv[])\n{\n     int i, j;\n     int *p;\n"

#. type: Plain text
#: man-pages/man1/memusage.1:252
#, no-wrap
msgid ""
"     printf(\"malloc: %zd\\en\", sizeof(int) * 100);\n"
"     p = malloc(sizeof(int) * 100);\n"
msgstr "     printf(\"malloc: %zd\\en\", sizeof(int) * 100);\n     p = malloc(sizeof(int) * 100);\n"

#. type: Plain text
#: man-pages/man1/memusage.1:258
#, no-wrap
msgid ""
"     for (i = 0; i E<lt> CYCLES; i++) {\n"
"         if (i E<lt> CYCLES / 2)\n"
"             j = i;\n"
"         else\n"
"             j--;\n"
msgstr "     for (i = 0; i E<lt> CYCLES; i++) {\n         if (i E<lt> CYCLES / 2)\n             j = i;\n         else\n             j--;\n"

#. type: Plain text
#: man-pages/man1/memusage.1:261
#, no-wrap
msgid ""
"         printf(\"realloc: %zd\\en\", sizeof(int) * (j * 50 + 110));\n"
"         p = realloc(p, sizeof(int) * (j * 50 + 100));\n"
msgstr "         printf(\"realloc: %zd\\en\", sizeof(int) * (j * 50 + 110));\n         p = realloc(p, sizeof(int) * (j * 50 + 100));\n"

#. type: Plain text
#: man-pages/man1/memusage.1:265
#, no-wrap
msgid ""
"         printf(\"realloc: %zd\\en\", sizeof(int) * ((j+1) * 150 + 110));\n"
"         p = realloc(p, sizeof(int) * ((j + 1) * 150 + 110));\n"
"     }\n"
msgstr "         printf(\"realloc: %zd\\en\", sizeof(int) * ((j+1) * 150 + 110));\n         p = realloc(p, sizeof(int) * ((j + 1) * 150 + 110));\n     }\n"

#. type: Plain text
#: man-pages/man1/memusage.1:269
#, no-wrap
msgid ""
"     free(p);\n"
"     exit(EXIT_SUCCESS);\n"
"}\n"
msgstr "     free(p);\n     exit(EXIT_SUCCESS);\n}\n"

#. type: Plain text
#: man-pages/man1/memusage.1:273
msgid "B<memusagestat>(1), B<mtrace>(1)  B<ld.so>(8)"
msgstr "B<memusagestat>(1), B<mtrace>(1)  B<ld.so>(8)"

#. type: TH
#: man-pages/man1/memusagestat.1:23
#, no-wrap
msgid "MEMUSAGESTAT"
msgstr "MEMUSAGESTAT"

#. type: TH
#: man-pages/man1/memusagestat.1:23
#, no-wrap
msgid "Linux programmer's manual"
msgstr "Руководство программиста Linux"

#. type: Plain text
#: man-pages/man1/memusagestat.1:26
msgid "memusagestat - generate graphic from memory profiling data"
msgstr "memusagestat -  генерирует график по данным профилирования памяти"

#. type: Plain text
#: man-pages/man1/memusagestat.1:28
msgid "B<memusagestat> [I<option>]... I<datafile> [I<outfile>]"
msgstr "B<memusagestat> [I<параметр>]... I<файл_с_данными> [I<файл_результата>]"

#. type: Plain text
#: man-pages/man1/memusagestat.1:39
msgid ""
"B<memusagestat> creates a PNG file containing a graphical representation of "
"the memory profiling data in the file I<datafile>; that file is generated "
"via the I<-d> (or I<--data>)  option of B<memusage>(1)."
msgstr "Программа B<memusagestat> создаёт файл в формате PNG с графическим представлением данных профилирования памяти из файла I<datafile>; этот файл генерируется с программой B<memusage>(1), запущенной с параметром I<-d> (или I<--data>)."

#. type: Plain text
#: man-pages/man1/memusagestat.1:47
msgid ""
"The red line in the graph shows the heap usage (allocated memory)  and the "
"green line shows the stack usage.  The x-scale is either the number of "
"memory-handling function calls or (if the I<-t> option is specified)  time."
msgstr "Красной линией на графике показывается использование кучи (выделяемой памяти), а зелёной — использование стека. По оси Х отражается количество вызовов функций работы с памятью (если указан параметр I<-t>) или время."

#. type: TP
#: man-pages/man1/memusagestat.1:48
#, no-wrap
msgid "B<-o\\ >I<file>,\\ B<--output=>I<file>"
msgstr "B<-o\\ >I<файл>,\\ B<--output=>I<файл>"

#. type: Plain text
#: man-pages/man1/memusagestat.1:51
msgid "Name of the output file."
msgstr "Имя выходного файла."

#. type: TP
#: man-pages/man1/memusagestat.1:51
#, no-wrap
msgid "B<-s\\ >I<string>,\\ B<--string=>I<string>"
msgstr "B<-s\\ >I<строка>,\\ B<--string=>I<строка>"

#. type: Plain text
#: man-pages/man1/memusagestat.1:56
msgid "Use I<string> as the title inside the output graph."
msgstr "Использовать I<строку> в качестве заголовка графика."

#. type: TP
#: man-pages/man1/memusagestat.1:56
#, no-wrap
msgid "B<-t>,\\ B<--time>"
msgstr "B<-t>,\\ B<--time>"

#. type: Plain text
#: man-pages/man1/memusagestat.1:62
msgid "Also draw a graph of total memory consumption."
msgstr "Также строить график общего потребления памяти."

#. type: Plain text
#: man-pages/man1/memusagestat.1:67
msgid "Make the output graph I<size> pixels wide."
msgstr "Рисовать график шириной в I<size> пикселов."

#. type: Plain text
#: man-pages/man1/memusagestat.1:72
msgid "Make the output graph I<size> pixels high."
msgstr "Рисовать график высотой в I<size> пикселов."

#. type: Plain text
#: man-pages/man1/memusagestat.1:75
msgid "Print a help message and exit."
msgstr "Показать сообщение об использовании и завершить работу."

#. type: Plain text
#: man-pages/man1/memusagestat.1:88
msgid "See B<memusage>(1)."
msgstr "Смотрите B<memusage>(1)."

#. type: Plain text
#: man-pages/man1/memusagestat.1:90
msgid "B<memusage>(1), B<mtrace>(1)"
msgstr "B<memusage>(1), B<mtrace>(1)"

#. type: TH
#: man-pages/man1/mtrace.1:23
#, no-wrap
msgid "MTRACE"
msgstr "MTRACE"

#. type: TH
#: man-pages/man1/mtrace.1:23
#, no-wrap
msgid "2017-09-15"
msgstr "2017-09-15"

#. type: Plain text
#: man-pages/man1/mtrace.1:26
msgid "mtrace - interpret the malloc trace log"
msgstr "mtrace - трактует журнал трассировки malloc"

#. type: Plain text
#: man-pages/man1/mtrace.1:28
msgid "B<mtrace> [I<option>]... [I<binary>] I<mtracedata>"
msgstr "B<mtrace> [I<параметр>]… [I<binary>] I<mtracedata>"

#. type: Plain text
#: man-pages/man1/mtrace.1:44
msgid ""
"B<mtrace> is a Perl script used to interpret and provide human readable "
"output of the trace log contained in the file I<mtracedata>, whose contents "
"were produced by B<mtrace>(3).  If I<binary> is provided, the output of "
"B<mtrace> also contains the source file name with line number information "
"for problem locations (assuming that I<binary> was compiled with debugging "
"information)."
msgstr "Программа B<mtrace> представляет собой сценарий Perl и используется для трактовки и вывода в понятном человеку виде журнала трассировки из файла I<mtracedata>, который создаётся B<mtrace>(3). Если указан файл I<binary>, то вывод B<mtrace> также содержит имя файла исходного кода и номера строк соответствующих мест (предполагается, что I<binary> скомпилирован с отладочной информацией)."

#. type: Plain text
#: man-pages/man1/mtrace.1:51
msgid ""
"For more information about the B<mtrace>(3)  function and B<mtrace> script "
"usage, see B<mtrace>(3)."
msgstr "Подробней о функции B<mtrace>(3) и использовании сценария B<mtrace> смотрите в B<mtrace>(3)."

#. type: TP
#: man-pages/man1/mtrace.1:52
#, no-wrap
msgid "B<--help>"
msgstr "B<--help>"

#. type: TP
#: man-pages/man1/mtrace.1:55
#, no-wrap
msgid "B<--version>"
msgstr "B<--version>"

#. type: Plain text
#: man-pages/man1/mtrace.1:62
msgid ""
"For bug reporting instructions, please see: E<.UR "
"http://www.gnu.org/software/libc/bugs.html> E<.UE .>"
msgstr "Инструкции по созданию отчетов об ошибках можно найти по адресу E<.UR http://www.gnu.org/software/libc/bugs.html> E<.UE .>"

#. type: Plain text
#: man-pages/man1/mtrace.1:64
msgid "B<memusage>(1), B<mtrace>(3)"
msgstr "B<memusage>(1), B<mtrace>(3)"

#. type: TH
#: man-pages/man7/mq_overview.7:26
#, no-wrap
msgid "MQ_OVERVIEW"
msgstr "MQ_OVERVIEW"

#. type: Plain text
#: man-pages/man7/mq_overview.7:29
msgid "mq_overview - overview of POSIX message queues"
msgstr "mq_overview - обзор очередей сообщений POSIX"

#. type: Plain text
#: man-pages/man7/mq_overview.7:37
msgid ""
"POSIX message queues allow processes to exchange data in the form of "
"messages.  This API is distinct from that provided by System V message "
"queues (B<msgget>(2), B<msgsnd>(2), B<msgrcv>(2), etc.), but provides "
"similar functionality."
msgstr "Очереди сообщений POSIX позволяют процессам обмениваться данными в виде сообщений. Данный программный интерфейс отличается от используемого в очередях сообщений System V (B<msgget>(2), B<msgsnd>(2), B<msgrcv>(2), etc.), но предоставляет схожие возможности."

#. type: Plain text
#: man-pages/man7/mq_overview.7:52
msgid ""
"Message queues are created and opened using B<mq_open>(3); this function "
"returns a I<message queue descriptor> (I<mqd_t>), which is used to refer to "
"the open message queue in later calls.  Each message queue is identified by "
"a name of the form I</somename>; that is, a null-terminated string of up to "
"B<NAME_MAX> (i.e., 255) characters consisting of an initial slash, followed "
"by one or more characters, none of which are slashes.  Two processes can "
"operate on the same queue by passing the same name to B<mq_open>(3)."
msgstr "Очереди сообщений создаются и открываются с помощью B<mq_open>(3); эта функция возвращает I<дескриптор очереди сообщений> (I<mqd_t>), который используется в последующих вызовах для ссылки на открытую очередь сообщений. Каждая очередь сообщений описывается именем в виде I</некое_имя>; оно представляет собой строку с null в конце и длиной до B<NAME_MAX> (т. е., 255) символов, состоящую из начальной косой черты, одного и более символа (любого, кроме косой черты). Два процесса могут работать через одну очередь, если укажут одинаковое имя в B<mq_open>(3)."

#. type: Plain text
#: man-pages/man7/mq_overview.7:68
msgid ""
"Messages are transferred to and from a queue using B<mq_send>(3)  and "
"B<mq_receive>(3).  When a process has finished using the queue, it closes it"
" using B<mq_close>(3), and when the queue is no longer required, it can be "
"deleted using B<mq_unlink>(3).  Queue attributes can be retrieved and (in "
"some cases) modified using B<mq_getattr>(3)  and B<mq_setattr>(3).  A "
"process can request asynchronous notification of the arrival of a message on"
" a previously empty queue using B<mq_notify>(3)."
msgstr "Сообщения передаются в и из очереди с помощью функций B<mq_send>(3) и B<mq_receive>(3). Когда процесс прекращает использовать очередь, он закрывает её с помощью функции B<mq_close>(3), и если очередь больше не нужна, то она может быть удалена с помощью функции B<mq_unlink>(3). Атрибуты очереди можно получить и (в некоторых случаях) изменить с помощью функций B<mq_getattr>(3) и B<mq_setattr>(3). Процесс может запросить асинхронное уведомление о поступлении сообщения в пустую очередь с помощью функции B<mq_notify>(3)."

#. type: Plain text
#: man-pages/man7/mq_overview.7:81
msgid ""
"A message queue descriptor is a reference to an I<open message queue "
"description> (see B<open>(2)).  After a B<fork>(2), a child inherits copies "
"of its parent's message queue descriptors, and these descriptors refer to "
"the same open message queue descriptions as the corresponding message queue "
"descriptors in the parent.  Corresponding message queue descriptors in the "
"two processes share the flags (I<mq_flags>)  that are associated with the "
"open message queue description."
msgstr "Дескриптор очереди сообщений — это ссылка на I<открытое описание очереди сообщений> (смотрите B<open>(2)). После вызова B<fork>(2) потомок наследует копии дескрипторов очередей сообщений родителя и эти дескрипторы ссылаются на те же открытые описания очередей сообщений родителя. Соответствующие дескрипторы очередей сообщений двух процессов используют общий флаг (I<mq_flags>), который связан с открытым описанием очереди сообщений."

#. type: Plain text
#: man-pages/man7/mq_overview.7:94
msgid ""
"Each message has an associated I<priority>, and messages are always "
"delivered to the receiving process highest priority first.  Message "
"priorities range from 0 (low) to I<sysconf(_SC_MQ_PRIO_MAX)\\ -\\ 1> (high)."
"  On Linux, I<sysconf(_SC_MQ_PRIO_MAX)> returns 32768, but POSIX.1 requires "
"only that an implementation support at least priorities in the range 0 to "
"31; some implementations provide only this range."
msgstr "У каждого сообщения есть I<приоритет>, и сначала в принимающий процесс всегда доставляются сообщения наивысшим приоритетом. Диапазон приоритетов сообщений: 0 (низший) — I<sysconf(_SC_MQ_PRIO_MAX)\\ -\\ 1> (высший). В Linux, I<sysconf(_SC_MQ_PRIO_MAX)> возвращает 32768, но в POSIX.1 требуется реализация поддержки только диапазона приоритетов от 0 до 31; некоторые реализации предоставляют только этот диапазон."

#. type: Plain text
#: man-pages/man7/mq_overview.7:97
msgid ""
"The remainder of this section describes some specific details of the Linux "
"implementation of POSIX message queues."
msgstr "Далее в разделе описываются особенности реализации очередей сообщений POSIX в Linux."

#. type: SS
#: man-pages/man7/mq_overview.7:97
#, no-wrap
msgid "Library interfaces and system calls"
msgstr "Библиотечные интерфейсы и системные вызовы"

#. type: Plain text
#: man-pages/man7/mq_overview.7:103
msgid ""
"In most cases the B<mq_*>()  library interfaces listed above are implemented"
" on top of underlying system calls of the same name.  Deviations from this "
"scheme are indicated in the following table:"
msgstr "В большинстве случаев, перечисленные выше библиотечные интерфейсы B<mq_*>() реализуются поверх системных вызовов с теми же именами. Исключения из этого правила перечислены в следующей таблице:"

#. type: tbl table
#: man-pages/man7/mq_overview.7:107
#, no-wrap
msgid "Library interface"
msgstr "Библиотечный интерфейс"

#. type: tbl table
#: man-pages/man7/mq_overview.7:107
#, no-wrap
msgid "System call"
msgstr "Системный вызов"

#. type: tbl table
#: man-pages/man7/mq_overview.7:108
#, no-wrap
msgid "mq_close(3)"
msgstr "mq_close(3)"

#. type: tbl table
#: man-pages/man7/mq_overview.7:108
#, no-wrap
msgid "close(2)"
msgstr "close(2)"

#. type: tbl table
#: man-pages/man7/mq_overview.7:109
#, no-wrap
msgid "mq_getattr(3)"
msgstr "mq_getattr(3)"

#. type: tbl table
#: man-pages/man7/mq_overview.7:109 man-pages/man7/mq_overview.7:114
#, no-wrap
msgid "mq_getsetattr(2)"
msgstr "mq_getsetattr(2)"

#. type: tbl table
#: man-pages/man7/mq_overview.7:110
#, no-wrap
msgid "mq_notify(3)"
msgstr "mq_notify(3)"

#. type: tbl table
#: man-pages/man7/mq_overview.7:110
#, no-wrap
msgid "mq_notify(2)"
msgstr "mq_notify(2)"

#. type: tbl table
#: man-pages/man7/mq_overview.7:111
#, no-wrap
msgid "mq_open(3)"
msgstr "mq_open(3)"

#. type: tbl table
#: man-pages/man7/mq_overview.7:111
#, no-wrap
msgid "mq_open(2)"
msgstr "mq_open(2)"

#. type: tbl table
#: man-pages/man7/mq_overview.7:112
#, no-wrap
msgid "mq_receive(3)"
msgstr "mq_receive(3)"

#. type: tbl table
#: man-pages/man7/mq_overview.7:112 man-pages/man7/mq_overview.7:115
#, no-wrap
msgid "mq_timedreceive(2)"
msgstr "mq_timedreceive(2)"

#. type: tbl table
#: man-pages/man7/mq_overview.7:113
#, no-wrap
msgid "mq_send(3)"
msgstr "mq_send(3)"

#. type: tbl table
#: man-pages/man7/mq_overview.7:113 man-pages/man7/mq_overview.7:116
#, no-wrap
msgid "mq_timedsend(2)"
msgstr "mq_timedsend(2)"

#. type: tbl table
#: man-pages/man7/mq_overview.7:114
#, no-wrap
msgid "mq_setattr(3)"
msgstr "mq_setattr(3)"

#. type: tbl table
#: man-pages/man7/mq_overview.7:115
#, no-wrap
msgid "mq_timedreceive(3)"
msgstr "mq_timedreceive(3)"

#. type: tbl table
#: man-pages/man7/mq_overview.7:116
#, no-wrap
msgid "mq_timedsend(3)"
msgstr "mq_timedsend(3)"

#. type: tbl table
#: man-pages/man7/mq_overview.7:117
#, no-wrap
msgid "mq_unlink(3)"
msgstr "mq_unlink(3)"

#. type: tbl table
#: man-pages/man7/mq_overview.7:117
#, no-wrap
msgid "mq_unlink(2)"
msgstr "mq_unlink(2)"

#. type: SS
#: man-pages/man7/mq_overview.7:120
#, no-wrap
msgid "Versions"
msgstr "Версии"

#. type: Plain text
#: man-pages/man7/mq_overview.7:123
msgid ""
"POSIX message queues have been supported on Linux since kernel 2.6.6.  Glibc"
" support has been provided since version 2.3.4."
msgstr "Поддержка очередей сообщений POSIX началась в ядре Linux версии 2.6.6. Поддержка в glibc предоставляется с версии 2.3.4."

#. type: SS
#: man-pages/man7/mq_overview.7:123
#, no-wrap
msgid "Kernel configuration"
msgstr "Конфигурация ядра"

#. type: Plain text
#: man-pages/man7/mq_overview.7:128
msgid ""
"Support for POSIX message queues is configurable via the "
"B<CONFIG_POSIX_MQUEUE> kernel configuration option.  This option is enabled "
"by default."
msgstr "Поддержка очередей сообщений POSIX включается параметром настройки ядра B<CONFIG_POSIX_MQUEUE>. Данный параметр включён по умолчанию."

#. type: SS
#: man-pages/man7/mq_overview.7:128
#, no-wrap
msgid "Persistence"
msgstr "Устойчивость"

#. type: Plain text
#: man-pages/man7/mq_overview.7:133
msgid ""
"POSIX message queues have kernel persistence: if not removed by "
"B<mq_unlink>(3), a message queue will exist until the system is shut down."
msgstr "Очереди сообщений POSIX располагаются в ядре. Пока очередь не удалёна с помощью B<mq_unlink>(3), она остаётся в системе до её выключения."

#. type: SS
#: man-pages/man7/mq_overview.7:133
#, no-wrap
msgid "Linking"
msgstr "Компоновка"

#. type: Plain text
#: man-pages/man7/mq_overview.7:138
msgid ""
"Programs using the POSIX message queue API must be compiled with I<cc -lrt> "
"to link against the real-time library, I<librt>."
msgstr "Программы, в которых используется программный интерфейс очереди сообщений POSIX, для компоновки с библиотекой реального времени I<librt> должны компилироваться с помощью I<cc -lrt>."

#. type: SS
#: man-pages/man7/mq_overview.7:138
#, no-wrap
msgid "/proc interfaces"
msgstr "Интерфейсы /proc"

#. type: Plain text
#: man-pages/man7/mq_overview.7:142
msgid ""
"The following interfaces can be used to limit the amount of kernel memory "
"consumed by POSIX message queues and to set the default attributes for new "
"message queues:"
msgstr "Для ограничения потребления очередями сообщений POSIX памяти ядра и задания атрибутов по умолчанию для новых очередей сообщений, можно использовать следующие интерфейсы:"

#. type: TP
#: man-pages/man7/mq_overview.7:142
#, no-wrap
msgid "I</proc/sys/fs/mqueue/msg_default> (since Linux 3.5)"
msgstr "I</proc/sys/fs/mqueue/msg_default> (начиная с Linux 3.5)"

#. type: Plain text
#: man-pages/man7/mq_overview.7:166
msgid ""
"This file defines the value used for a new queue's I<mq_maxmsg> setting when"
" the queue is created with a call to B<mq_open>(3)  where I<attr> is "
"specified as NULL.  The default value for this file is 10.  The minimum and "
"maximum are as for I</proc/sys/fs/mqueue/msg_max>.  A new queue's default "
"I<mq_maxmsg> value will be the smaller of I<msg_default> and I<msg_max>.  Up"
" until Linux 2.6.28, the default I<mq_maxmsg> was 10; from Linux 2.6.28 to "
"Linux 3.4, the default was the value defined for the I<msg_max> limit."
msgstr "В данном файле задаётся значение, которое используется для I<mq_maxmsg> в создаваемой новой очереди с помощью вызова B<mq_open>(3) со значением I<attr> равным NULL. Значение для этого файла по умолчанию равно 10. Минимальное и максимальные значение такие же как для I</proc/sys/fs/mqueue/msg_max>.  Значение по умолчанию I<mq_maxmsg> у новой очереди будет меньше I<msg_default> и I<msg_max>. До Linux 2.6.28 значение I<mq_maxmsg> по умолчанию равнялось 10; с Linux 2.6.28 по Linux 3.4 значение по умолчанию равнялось ограничению I<msg_max>."

#. type: TP
#: man-pages/man7/mq_overview.7:166
#, no-wrap
msgid "I</proc/sys/fs/mqueue/msg_max>"
msgstr "I</proc/sys/fs/mqueue/msg_max>"

#. type: Plain text
#: man-pages/man7/mq_overview.7:187
msgid ""
"This file can be used to view and change the ceiling value for the maximum "
"number of messages in a queue.  This value acts as a ceiling on the "
"I<attr-E<gt>mq_maxmsg> argument given to B<mq_open>(3).  The default value "
"for I<msg_max> is 10.  The minimum value is 1 (10 in kernels before 2.6.28)."
"  The upper limit is B<HARD_MSGMAX>.  The I<msg_max> limit is ignored for "
"privileged processes (B<CAP_SYS_RESOURCE>), but the B<HARD_MSGMAX> ceiling "
"is nevertheless imposed."
msgstr "Данный файл можно использовать для просмотра и изменения значения максимального количества сообщений в очереди. Это значение служит верхним пределом для аргумента I<attr-E<gt>mq_maxmsg>, указываемого в B<mq_open>(3). Значение I<msg_max> по умолчанию равно 10. Минимальное значение равно 1 (10 в ядрах до версии 2.6.28). Верхний предел равен B<HARD_MSGMAX>. Ограничитель I<msg_max> игнорируется для привилегированных процессов (B<CAP_SYS_RESOURCE>), но, тем не менее, учитывается предел B<HARD_MSGMAX>."

#. type: Plain text
#: man-pages/man7/mq_overview.7:191
msgid "The definition of B<HARD_MSGMAX> has changed across kernel versions:"
msgstr "Определение B<HARD_MSGMAX> изменялось в разных версиях ядра следующим образом:"

#. type: IP
#: man-pages/man7/mq_overview.7:192 man-pages/man7/mq_overview.7:195
#: man-pages/man7/mq_overview.7:198 man-pages/man7/mq_overview.7:246
#: man-pages/man7/mq_overview.7:249 man-pages/man7/mq_overview.7:251
#, no-wrap
msgid "*"
msgstr "*"

#. type: Plain text
#: man-pages/man7/mq_overview.7:195
msgid "Up to Linux 2.6.32: I<131072\\ /\\ sizeof(void\\ *)>"
msgstr "До Linux 2.6.32: I<131072\\ /\\ sizeof(void\\ *)>"

#. type: Plain text
#: man-pages/man7/mq_overview.7:198
msgid "Linux 2.6.33 to 3.4: I<(32768\\ *\\ sizeof(void\\ *) / 4)>"
msgstr "Linux 2.6.33 по 3.4: I<(32768\\ *\\ sizeof(void\\ *) / 4)>"

#.  commit 5b5c4d1a1440e94994c73dddbad7be0676cd8b9a
#. type: Plain text
#: man-pages/man7/mq_overview.7:202
msgid "Since Linux 3.5: 65,536"
msgstr "Начиная с Linux 3.5: 65536"

#. type: TP
#: man-pages/man7/mq_overview.7:203
#, no-wrap
msgid "I</proc/sys/fs/mqueue/msgsize_default> (since Linux 3.5)"
msgstr "I</proc/sys/fs/mqueue/msgsize_default> (начиная с Linux 3.5)"

#. type: Plain text
#: man-pages/man7/mq_overview.7:230
msgid ""
"This file defines the value used for a new queue's I<mq_msgsize> setting "
"when the queue is created with a call to B<mq_open>(3)  where I<attr> is "
"specified as NULL.  The default value for this file is 8192 (bytes).  The "
"minimum and maximum are as for I</proc/sys/fs/mqueue/msgsize_max>.  If "
"I<msgsize_default> exceeds I<msgsize_max>, a new queue's default "
"I<mq_msgsize> value is capped to the I<msgsize_max> limit.  Up until Linux "
"2.6.28, the default I<mq_msgsize> was 8192; from Linux 2.6.28 to Linux 3.4, "
"the default was the value defined for the I<msgsize_max> limit."
msgstr "В данном файле задаётся значение, которое используется для I<mq_msgsize> в создаваемой новой очереди с помощью вызова B<mq_open>(3) со значением I<attr> равным NULL. Значение для этого файла по умолчанию равно 8192 (байты). Минимальное и максимальные значение такие же как для I</proc/sys/fs/mqueue/msgsize_max>. Если I<msgsize_default> превышает I<msgsize_max>,  то значение I<mq_msgsize> для новой очереди по умолчанию ограничивается I<msgsize_max>.До Linux 2.6.28 значение I<mq_msgsize> по умолчанию равнялось 8192; с Linux 2.6.28 по Linux 3.4 значение по умолчанию равнялось ограничению I<msgsize_max>."

#. type: TP
#: man-pages/man7/mq_overview.7:230
#, no-wrap
msgid "I</proc/sys/fs/mqueue/msgsize_max>"
msgstr "I</proc/sys/fs/mqueue/msgsize_max>"

#. type: Plain text
#: man-pages/man7/mq_overview.7:245
msgid ""
"This file can be used to view and change the ceiling on the maximum message "
"size.  This value acts as a ceiling on the I<attr-E<gt>mq_msgsize> argument "
"given to B<mq_open>(3).  The default value for I<msgsize_max> is 8192 bytes."
"  The minimum value is 128 (8192 in kernels before 2.6.28).  The upper limit"
" for I<msgsize_max> has varied across kernel versions:"
msgstr "Данный файл можно использовать для просмотра и изменения максимального размера сообщения. Это значение служит верхним пределом для аргумента I<attr-E<gt>mq_msgsize>, указываемого в B<mq_open>(3). Значение I<msgsize_max> по умолчанию равно 8192 байта. Минимальное значение равно 128 (8192 в ядрах до версии 2.6.28). Верхний предел I<msgsize_max> изменялся в разных версиях ядер следующим образом:"

#. type: Plain text
#: man-pages/man7/mq_overview.7:249
msgid "Before Linux 2.6.28, the upper limit is B<INT_MAX>."
msgstr "До Linux 2.6.28 верхний предел был равен B<INT_MAX>."

#. type: Plain text
#: man-pages/man7/mq_overview.7:251
msgid "From Linux 2.6.28 to 3.4, the limit is 1,048,576."
msgstr "С Linux 2.6.28 по 3.4 предел равен 1048576."

#. type: Plain text
#: man-pages/man7/mq_overview.7:254
msgid "Since Linux 3.5, the limit is 16,777,216 (B<HARD_MSGSIZEMAX>)."
msgstr "Начиная с Linux 3.5 предел равен 16777216 (B<HARD_MSGSIZEMAX>)."

#. type: Plain text
#: man-pages/man7/mq_overview.7:263
msgid ""
"The I<msgsize_max> limit is ignored for privileged process "
"(B<CAP_SYS_RESOURCE>), but, since Linux 3.5, the B<HARD_MSGSIZEMAX> ceiling "
"is enforced for privileged processes."
msgstr "Предел I<msgsize_max> игнорируется для привилегированных процессов (B<CAP_SYS_RESOURCE>), но, начиная с Linux 3.5, накладывается ограничение B<HARD_MSGSIZEMAX>."

#. type: TP
#: man-pages/man7/mq_overview.7:263
#, no-wrap
msgid "I</proc/sys/fs/mqueue/queues_max>"
msgstr "I</proc/sys/fs/mqueue/queues_max>"

#. type: Plain text
#: man-pages/man7/mq_overview.7:275
msgid ""
"This file can be used to view and change the system-wide limit on the number"
" of message queues that can be created.  The default value for I<queues_max>"
" is 256.  No ceiling is imposed on the I<queues_max> limit; privileged "
"processes (B<CAP_SYS_RESOURCE>)  can exceed the limit (but see BUGS)."
msgstr "Данный файл можно использовать для просмотра и изменения системного ограничения на количество сообщений в очереди. Значение I<queues_max> по умолчанию равно 256. У I<queues_max> нет верхнего предела; привилегированные процессы (B<CAP_SYS_RESOURCE>) могут превышать ограничение (но смотрите ДЕФЕКТЫ)."

#. type: SS
#: man-pages/man7/mq_overview.7:275
#, no-wrap
msgid "Resource limit"
msgstr "Ограничение ресурса"

#. type: Plain text
#: man-pages/man7/mq_overview.7:282
msgid ""
"The B<RLIMIT_MSGQUEUE> resource limit, which places a limit on the amount of"
" space that can be consumed by all of the message queues belonging to a "
"process's real user ID, is described in B<getrlimit>(2)."
msgstr "Ограничение ресурса B<RLIMIT_MSGQUEUE>, накладываемое на количество пространства, которое могут занять все очереди сообщений, принадлежащие процессу с реальным пользовательским ID, описано в B<getrlimit>(2)."

#. type: SS
#: man-pages/man7/mq_overview.7:282
#, no-wrap
msgid "Mounting the message queue filesystem"
msgstr "Монтирование файловой системы очереди сообщений"

#. type: Plain text
#: man-pages/man7/mq_overview.7:288
msgid ""
"On Linux, message queues are created in a virtual filesystem.  (Other "
"implementations may also provide such a feature, but the details are likely "
"to differ.)  This filesystem can be mounted (by the superuser) using the "
"following commands:"
msgstr "В Linux очереди сообщений создаются в виртуальной файловой системе (другие реализации могут делать также, но, вероятно, по-другому). Данная файловая система может быть смонтирована (суперпользователем) с помощью команд:"

#. type: Plain text
#: man-pages/man7/mq_overview.7:293
#, no-wrap
msgid ""
"#B< mkdir /dev/mqueue>\n"
"#B< mount -t mqueue none /dev/mqueue>\n"
msgstr "#B< mkdir /dev/mqueue>\n#B< mount -t mqueue none /dev/mqueue>\n"

#. type: Plain text
#: man-pages/man7/mq_overview.7:297
msgid "The sticky bit is automatically enabled on the mount directory."
msgstr "Закрепляющий бит устанавливается на каталог назначения автоматически."

#. type: Plain text
#: man-pages/man7/mq_overview.7:304
msgid ""
"After the filesystem has been mounted, the message queues on the system can "
"be viewed and manipulated using the commands usually used for files (e.g., "
"B<ls>(1)  and B<rm>(1))."
msgstr "После примонтирования файловой системы очередь сообщений в системе можно просматривать и изменять с помощью команд как с обычными файлами (например, B<ls>(1) и B<rm>(1))."

#. type: Plain text
#: man-pages/man7/mq_overview.7:307
msgid ""
"The contents of each file in the directory consist of a single line "
"containing information about the queue:"
msgstr "Содержимое каждого файла в каталоге состоит из одной строки, в которой представлена информация об очереди:"

#. type: Plain text
#: man-pages/man7/mq_overview.7:312
#, no-wrap
msgid ""
"$B< cat /dev/mqueue/mymq>\n"
"QSIZE:129     NOTIFY:2    SIGNO:0    NOTIFY_PID:8260\n"
msgstr "$B< cat /dev/mqueue/mymq>\nQSIZE:129     NOTIFY:2    SIGNO:0    NOTIFY_PID:8260\n"

#. type: Plain text
#: man-pages/man7/mq_overview.7:316
msgid "These fields are as follows:"
msgstr "Эти поля означают следующее:"

#. type: TP
#: man-pages/man7/mq_overview.7:316
#, no-wrap
msgid "B<QSIZE>"
msgstr "B<QSIZE>"

#. type: Plain text
#: man-pages/man7/mq_overview.7:319
msgid "Number of bytes of data in all messages in the queue (but see BUGS)."
msgstr "Количество байтов данных во всех сообщениях очереди (но смотрите ДЕФЕКТЫ)."

#. type: TP
#: man-pages/man7/mq_overview.7:319
#, no-wrap
msgid "B<NOTIFY_PID>"
msgstr "B<NOTIFY_PID>"

#. type: Plain text
#: man-pages/man7/mq_overview.7:325
msgid ""
"If this is nonzero, then the process with this PID has used B<mq_notify>(3)"
"  to register for asynchronous message notification, and the remaining "
"fields describe how notification occurs."
msgstr "Если это значение не равно нулю, то процесс с данным PID использовал B<mq_notify>(3) для регистрации асинхронных уведомлений о сообщениях, а оставшиеся поля описывают как производится уведомление."

#. type: TP
#: man-pages/man7/mq_overview.7:325
#, no-wrap
msgid "B<NOTIFY>"
msgstr "B<NOTIFY>"

#. type: Plain text
#: man-pages/man7/mq_overview.7:335
msgid ""
"Notification method: 0 is B<SIGEV_SIGNAL>; 1 is B<SIGEV_NONE>; and 2 is "
"B<SIGEV_THREAD>."
msgstr "Способ уведомления: 0 — B<SIGEV_SIGNAL>; 1 — B<SIGEV_NONE>; 2 — B<SIGEV_THREAD>."

#. type: TP
#: man-pages/man7/mq_overview.7:335
#, no-wrap
msgid "B<SIGNO>"
msgstr "B<SIGNO>"

#. type: Plain text
#: man-pages/man7/mq_overview.7:339
msgid "Signal number to be used for B<SIGEV_SIGNAL>."
msgstr "Номер сигнала, который будет использован для B<SIGEV_SIGNAL>."

#. type: SS
#: man-pages/man7/mq_overview.7:339
#, no-wrap
msgid "Linux implementation of message queue descriptors"
msgstr "Реализация дескрипторов очереди сообщений в Linux"

#. type: Plain text
#: man-pages/man7/mq_overview.7:348
msgid ""
"On Linux, a message queue descriptor is actually a file descriptor.  (POSIX "
"does not require such an implementation.)  This means that a message queue "
"descriptor can be monitored using B<select>(2), B<poll>(2), or B<epoll>(7)."
"  This is not portable."
msgstr "В Linux дескриптор очереди сообщений представляет собой файловый дескриптор (в POSIX не требуется этого от реализации). Это означает, что за дескриптором очереди сообщений можно следить с помощью B<select>(2), B<poll>(2) или B<epoll>(7). Это является непереносимым свойством."

#. type: Plain text
#: man-pages/man7/mq_overview.7:353
msgid ""
"The close-on-exec flag (see B<open>(2))  is automatically set on the file "
"descriptor returned by B<mq_open>(2)."
msgstr "Флаг close-on-exec (смотрите B<open>(2)) устанавливается автоматически на файловом дескрипторе, возвращаемом B<mq_open>(2)."

#. type: SS
#: man-pages/man7/mq_overview.7:353
#, no-wrap
msgid "IPC namespaces"
msgstr "Пространства имён IPC"

#. type: Plain text
#: man-pages/man7/mq_overview.7:357
msgid ""
"For a discussion of the interaction of System V IPC objects and IPC "
"namespaces, see B<namespaces>(7)."
msgstr "Обсуждение связи объектов System V IPC с пространствами IPC смотрите в B<namespaces>(7)."

#. type: Plain text
#: man-pages/man7/mq_overview.7:367
msgid ""
"System V message queues (B<msgget>(2), B<msgsnd>(2), B<msgrcv>(2), etc.) are"
" an older API for exchanging messages between processes.  POSIX message "
"queues provide a better designed interface than System V message queues; on "
"the other hand POSIX message queues are less widely available (especially on"
" older systems) than System V message queues."
msgstr "Очереди сообщений System V (B<msgget>(2), B<msgsnd>(2), B<msgrcv>(2) и т. д.) — более старый программный интерфейс обмена сообщениями между процессами. Очереди сообщений POSIX имеют более проработанный интерфейс чем очереди сообщений System V; с другой стороны, очереди сообщений POSIX не так широко распространены (особенно в старых системах) чем очереди сообщений System V."

#. type: Plain text
#: man-pages/man7/mq_overview.7:370
msgid ""
"Linux does not currently (2.6.26) support the use of access control lists "
"(ACLs) for POSIX message queues."
msgstr "В Linux (версия 2.6.26) пока нет поддержки использования списков контроля доступа (ACL) для очередей сообщений POSIX."

#. type: Plain text
#: man-pages/man7/mq_overview.7:379
msgid ""
"In Linux versions 3.5 to 3.14, the kernel imposed a ceiling of 1024 "
"(B<HARD_QUEUESMAX>)  on the value to which the I<queues_max> limit could be "
"raised, and the ceiling was enforced even for privileged processes.  This "
"ceiling value was removed in Linux 3.14, and patches to stable kernels 3.5.x"
" to 3.13.x also removed the ceiling."
msgstr "В Linux версиях с 3.5 по 3.14 ядро устанавливает верхний предел в 1024 (B<HARD_QUEUESMAX>) на значение ограничения I<queues_max> и это влияет даже на привилегированные процессы. Это предельное значение было удалено в Linux 3.14,  а также есть заплаты к стабильным ядрам версий с 3.5.x по 3.13.x для удаления этого предела."

#.  commit d6629859b36d
#.  commit de54b9ac253787c366bbfb28d901a31954eb3511
#. type: Plain text
#: man-pages/man7/mq_overview.7:393
msgid ""
"As originally implemented (and documented), the QSIZE field displayed the "
"total number of (user-supplied)  bytes in all messages in the message queue."
"  Some changes in Linux 3.5 inadvertently changed the behavior, so that this"
" field also included a count of kernel overhead bytes used to store the "
"messages in the queue.  This behavioral regression was rectified in Linux "
"4.2 (and earlier stable kernel series), so that the count once more included"
" just the bytes of user data in messages in the queue."
msgstr "Первоначально реализованное (и описанное) поле QSIZE показывало общее количество (пользовательских) байт всех сообщений в очереди. Некоторые изменения в Linux 3.5 непреднамеренно изменили это поведение, и поле стало также включать байты издержек ядра, которые требуются для хранения сообщений в очереди. Это было исправлено в Linux 4.2 (и более ранних стабильных ядрах), и теперь снова считаются байты только пользовательских сообщений в очереди."

#. type: Plain text
#: man-pages/man7/mq_overview.7:396
msgid ""
"An example of the use of various message queue functions is shown in "
"B<mq_notify>(3)."
msgstr "Пример использования функций работы с очередью сообщений смотрите в B<mq_notify>(3)."

#. type: Plain text
#: man-pages/man7/mq_overview.7:409
msgid ""
"B<getrlimit>(2), B<mq_getsetattr>(2), B<poll>(2), B<select>(2), "
"B<mq_close>(3), B<mq_getattr>(3), B<mq_notify>(3), B<mq_open>(3), "
"B<mq_receive>(3), B<mq_send>(3), B<mq_unlink>(3), B<epoll>(7), "
"B<namespaces>(7)"
msgstr "B<getrlimit>(2), B<mq_getsetattr>(2), B<poll>(2), B<select>(2), B<mq_close>(3), B<mq_getattr>(3), B<mq_notify>(3), B<mq_open>(3), B<mq_receive>(3), B<mq_send>(3), B<mq_unlink>(3), B<epoll>(7), B<namespaces>(7)"

#. type: TH
#: man-pages/man7/mailaddr.7:27
#, no-wrap
msgid "MAILADDR"
msgstr "MAILADDR"

#. type: TH
#: man-pages/man7/mailaddr.7:27
#, no-wrap
msgid "2017-05-03"
msgstr "2017-05-03"

#. type: TH
#: man-pages/man7/mailaddr.7:27
#, no-wrap
msgid "Linux User's Manual"
msgstr "Руководство пользователя Linux"

#. type: Plain text
#: man-pages/man7/mailaddr.7:31
msgid "mailaddr - mail addressing description"
msgstr "mailaddr - описание формата почтового адреса"

#. type: Plain text
#: man-pages/man7/mailaddr.7:36
msgid ""
"This manual page gives a brief introduction to SMTP mail addresses, as used "
"on the Internet.  These addresses are in the general format"
msgstr "В этой странице кратко описываются почтовые адреса SMTP, используемые в Интернете. Общий формат этих адресов:"

#. type: Plain text
#: man-pages/man7/mailaddr.7:38
msgid "  user@domain"
msgstr "  пользователь@домен"

#. type: Plain text
#: man-pages/man7/mailaddr.7:41
msgid ""
"where a domain is a hierarchical dot-separated list of subdomains.  These "
"examples are valid forms of the same address:"
msgstr "где «домен» это иерархический список поддоменов, разделённых точками. Примеры корректных записей одного адреса:"

#. type: Plain text
#: man-pages/man7/mailaddr.7:43
msgid "  john.doe@monet.example.com"
msgstr "  john.doe@monet.example.com"

#. type: Plain text
#: man-pages/man7/mailaddr.7:45
msgid "  John Doe E<lt>john.doe@monet.example.comE<gt>"
msgstr "  John Doe E<lt>john.doe@monet.example.comE<gt>"

#. type: Plain text
#: man-pages/man7/mailaddr.7:47
msgid "  john.doe@monet.example.com (John Doe)"
msgstr "  john.doe@monet.example.com (John Doe)"

#. type: Plain text
#: man-pages/man7/mailaddr.7:51
msgid ""
"The domain part (\"monet.example.com\") is a mail-accepting domain.  It can "
"be a host and in the past it usually was, but it doesn't have to be.  The "
"domain part is not case sensitive."
msgstr "Доменная часть («monet.example.com») является доменом, который принимает почту. Это может быть узел (и в прошлом, обычно, это так и было), а может и нет. В доменной части не учитывает регистр букв."

#. type: Plain text
#: man-pages/man7/mailaddr.7:59
msgid ""
"The local part (\"john.doe\") is often a username, but its meaning is "
"defined by the local software.  Sometimes it is case sensitive, although "
"that is unusual.  If you see a local-part that looks like garbage, it is "
"usually because of a gateway between an internal e-mail system and the net, "
"here are some examples:"
msgstr "Локальная часть («john.doe») — это, часто, имя пользователя, но точное значение определяется локальным программным обеспечением. Иногда, здесь важен регистр букв, хотя это необычно. Если вы видите, что локальная часть выглядит бессмысленно, то, обычно,это из-за того, что существует шлюз между внутренней почтовой системой электронной почты и сетью, примеры:"

#. type: Plain text
#: man-pages/man7/mailaddr.7:61
msgid "  \"surname/admd=telemail/c=us/o=hp/prmd=hp\"@some.where"
msgstr "  \"surname/admd=telemail/c=us/o=hp/prmd=hp\"@some.where"

#. type: Plain text
#: man-pages/man7/mailaddr.7:63
msgid "  USER%SOMETHING@some.where"
msgstr "  USER%SOMETHING@some.where"

#. type: Plain text
#: man-pages/man7/mailaddr.7:65
msgid "  machine!machine!name@some.where"
msgstr "  machine!machine!name@some.where"

#. type: Plain text
#: man-pages/man7/mailaddr.7:67
msgid "  I2461572@some.where"
msgstr "  I2461572@some.where"

#. type: Plain text
#: man-pages/man7/mailaddr.7:71
msgid ""
"(These are, respectively, an X.400 gateway, a gateway to an arbitrary "
"internal mail system that lacks proper internet support, an UUCP gateway, "
"and the last one is just boring username policy.)"
msgstr "(здесь показан, соответственно, шлюз X.400, шлюз в произвольную внутреннюю почтовую систему без поддержки Интернета, шлюз UUCP и перенаправляющая пользователям политика)."

#. type: Plain text
#: man-pages/man7/mailaddr.7:77
msgid ""
"The real-name part (\"John Doe\") can either be placed before E<lt>E<gt>, or"
" in () at the end.  (Strictly speaking the two aren't the same, but the "
"difference is beyond the scope of this page.)  The name may have to be "
"quoted using \"\", for example, if it contains \".\":"
msgstr "Часть настоящего имени («John Doe») может указываться перед E<lt>E<gt> или в конце в () (строго говоря, такое размещение неравнозначно, но описание отличий лежит за границами этой страницы). Имя может быть заключено в \"\", например, если содержит «.»:"

#. type: Plain text
#: man-pages/man7/mailaddr.7:79
msgid "  \"John Q. Doe\" E<lt>john.doe@monet.example.comE<gt>"
msgstr "  \"John Q. Doe\" E<lt>john.doe@monet.example.comE<gt>"

#. type: SS
#: man-pages/man7/mailaddr.7:79
#, no-wrap
msgid "Abbreviation"
msgstr "Сокращение"

#. type: Plain text
#: man-pages/man7/mailaddr.7:87
msgid ""
"Some mail systems let users abbreviate the domain name.  For instance, users"
" at example.com may get away with \"john.doe@monet\" to send mail to John "
"Doe.  I<This behavior is deprecated.> Sometimes it works, but you should not"
" depend on it."
msgstr "Некоторые почтовые системы позволяют пользователям не указывать доменное имя. Например, пользователи в example.com могут указать «john.doe@monet», чтобы отправить письмо John Doe. I<Так делать не рекомендуется.> Иногда это работает, но вы не должны на это полагаться."

#. type: SS
#: man-pages/man7/mailaddr.7:87
#, no-wrap
msgid "Route-addrs"
msgstr "Route-addrs"

#. type: Plain text
#: man-pages/man7/mailaddr.7:93
msgid ""
"In the past, sometimes one had to route a message through several hosts to "
"get it to its final destination.  Addresses which show these relays are "
"termed \"route-addrs\".  These use the syntax:"
msgstr "В прошлом, иногда было нужно перенаправлять сообщение через несколько узлов, чтобы оно дошло до назначения. Адреса, в которых задаются ретрансляторы, называются «route-addrs». Для них используется синтаксис:"

#. type: Plain text
#: man-pages/man7/mailaddr.7:95
msgid "  E<lt>@hosta,@hostb:user@hostcE<gt>"
msgstr "  E<lt>@узелА,@узелБ:пользователь@узелВE<gt>"

#. type: Plain text
#: man-pages/man7/mailaddr.7:99
msgid ""
"This specifies that the message should be sent to hosta, from there to "
"hostb, and finally to hostc.  Many hosts disregard route-addrs and send "
"directly to hostc."
msgstr "Здесь указывается, что сообщение должно быть послано узлуА, потом узлуБ и, наконец узлуВ. Многие узлы игнорируют route-addrs и посылают сообщение напрямую узлуВ."

#. type: Plain text
#: man-pages/man7/mailaddr.7:104
msgid ""
"Route-addrs are very unusual now.  They occur sometimes in old mail "
"archives.  It is generally possible to ignore all but the \"user@hostc\" "
"part of the address to determine the actual address."
msgstr "В настоящее время использование route-addrs выглядит очень необычно. Иногда их можно встретить в старых почтовых архивах. Обычно, для определения действительного адреса можно игнорировать всё, кроме части «пользователь@узелВ»."

#. type: SS
#: man-pages/man7/mailaddr.7:104
#, no-wrap
msgid "Postmaster"
msgstr "Postmaster"

#. type: Plain text
#: man-pages/man7/mailaddr.7:110
msgid ""
"Every site is required to have a user or user alias designated "
"\"postmaster\" to which problems with the mail system may be addressed.  The"
" \"postmaster\" address is not case sensitive."
msgstr "Для каждого сайта необходим пользователь или псевдоним, называемый «postmaster», которому можно сообщать о проблемах в почтовой системе. В адресе «postmaster» не учитывается регистр символов."

#. type: Plain text
#: man-pages/man7/mailaddr.7:112
msgid "I</etc/aliases>"
msgstr "I</etc/aliases>"

#. type: Plain text
#: man-pages/man7/mailaddr.7:114
msgid "I<~/.forward>"
msgstr "I<~/.forward>"

#. type: Plain text
#: man-pages/man7/mailaddr.7:119
msgid "B<mail>(1), B<aliases>(5), B<forward>(5), B<sendmail>(8)"
msgstr "B<mail>(1), B<aliases>(5), B<forward>(5), B<sendmail>(8)"

#. type: Plain text
#: man-pages/man7/mailaddr.7:122
msgid "E<.UR http://www.ietf.org\\:/rfc\\:/rfc5322.txt> IETF RFC\\ 5322 E<.UE>"
msgstr "E<.UR http://www.ietf.org\\:/rfc\\:/rfc5322.txt> IETF RFC\\ 5322 E<.UE>"

#. type: TH
#: man-pages/man7/mount_namespaces.7:26
#, no-wrap
msgid "MOUNT_NAMESPACES"
msgstr "MOUNT_NAMESPACES"

#. type: TH
#: man-pages/man7/mount_namespaces.7:26
#, no-wrap
msgid "2019-08-02"
msgstr ""

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:29
msgid "mount_namespaces - overview of Linux mount namespaces"
msgstr "mount_namespaces - обзор пространств имён монтирования в Linux"

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:32
msgid "For an overview of namespaces, see B<namespaces>(7)."
msgstr "Обзор пространств имён смотрите в B<namespaces>(7)."

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:37
msgid ""
"Mount namespaces provide isolation of the list of mount points seen by the "
"processes in each namespace instance.  Thus, the processes in each of the "
"mount namespace instances will see distinct single-directory hierarchies."
msgstr "Пространства имён монтирования позволяют изолировать список точек монтирования, видимый процессами в каждом экземпляре пространства имён. То есть, процессы в каждом из экземпляров пространства имён монтирования будут видеть разные иерархии в одном и том же каталоге."

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:50
msgid ""
"The views provided by the I</proc/[pid]/mounts>, I</proc/[pid]/mountinfo>, "
"and I</proc/[pid]/mountstats> files (all described in B<proc>(5))  "
"correspond to the mount namespace in which the process with the PID I<[pid]>"
" resides.  (All of the processes that reside in the same mount namespace "
"will see the same view in these files.)"
msgstr "Данные файлов I</proc/[pid]/mounts>, I</proc/[pid]/mountinfo> и I</proc/[pid]/mountstats> (описаны в B<proc>(5)) соответствуют пространству имён монтирования, в котором расположен процесс с PID I<[pid]> (для всех процессов, которые расположены в одном пространстве имён монтирования, данные в этих файлах одинаковы)."

#.  ============================================================
#. type: Plain text
#: man-pages/man7/mount_namespaces.7:70
msgid ""
"When a process creates a new mount namespace using B<clone>(2)  or "
"B<unshare>(2)  with the B<CLONE_NEWNS> flag, the mount point list for the "
"new namespace is a I<copy> of the caller's mount point list.  Subsequent "
"modifications to the mount point list (B<mount>(2)  and B<umount>(2))  in "
"either mount namespace will not (by default) affect the mount point list "
"seen in the other namespace (but see the following discussion of shared "
"subtrees)."
msgstr "Когда процесс создаёт новое пространство имён монтирования с помощью B<clone>(2) или B<unshare>(2)  с флагом B<CLONE_NEWNS> список точек монтирования для нового пространства имён представляет собой I<копию> списка точек монтирования вызывающего. Последующие изменения списка точек монтирования (B<mount>(2) и B<umount>(2)) в любом пространстве имён монтирования не влияют (по умолчанию) на список точек монтирования, видимый из другого пространства имён (но смотрите далее описание общих поддеревьев)."

#. type: SS
#: man-pages/man7/mount_namespaces.7:70
#, no-wrap
msgid "Restrictions on mount namespaces"
msgstr "Ограничения у пространств имён монтирования"

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:72
msgid "Note the following points with respect to mount namespaces:"
msgstr "Отметим следующие моменты относительно пространств имён монтирования:"

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:77
msgid ""
"A mount namespace has an owner user namespace.  A mount namespace whose "
"owner user namespace is different from the owner user namespace of its "
"parent mount namespace is considered a less privileged mount namespace."
msgstr "Владельцем пространства имён монтирования является владелец пользовательского пространство имён. Пространство имён монтирования, чей владелец пользовательского пространства имён отличается от владельца пользовательского пространства имён родительского пространства имён монтирования, считается менее привилегированным пространством имён монтирования."

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:84
msgid ""
"When creating a less privileged mount namespace, shared mounts are reduced "
"to slave mounts.  (Shared and slave mounts are discussed below.)  This "
"ensures that mappings performed in less privileged mount namespaces will not"
" propagate to more privileged mount namespaces."
msgstr "При создании менее привилегированного пространства имён монтирования количество общих точек монтирования сокращаются до списка подчинённых точек монтирования (про общие и подчинённые точки монтирования смотрите далее). Это гарантирует, что отображения, выполняемые в менее привилегированном пространстве имён монтирования, не распространятся в более привилегированные пространства имён монтирования."

#.  FIXME .
#. 	What does "come as a single unit from more privileged mount" mean?
#. type: Plain text
#: man-pages/man7/mount_namespaces.7:97
msgid ""
"Mounts that come as a single unit from more privileged mount are locked "
"together and may not be separated in a less privileged mount namespace.  "
"(The B<unshare>(2)  B<CLONE_NEWNS> operation brings across all of the mounts"
" from the original mount namespace as a single unit, and recursive mounts "
"that propagate between mount namespaces propagate as a single unit.)"
msgstr "Точки монтирования, которые появились как единый блок из более привилегированного монтирования, объединяются и не могут быть разделены в менее привилегированном пространстве имён монтирования (операция B<unshare>(2) B<CLONE_NEWNS> переносит все точки монтирования из исходного пространства имён монтирования единым блоком и рекурсивные монтирования, которые передаются в нескольких пространствах имён монтирования, также единым блоком)."

#.  commit 9566d6742852c527bf5af38af5cbb878dad75705
#.  Author: Eric W. Biederman <ebiederm@xmission.com>
#.  Date:   Mon Jul 28 17:26:07 2014 -0700
#.       mnt: Correct permission checks in do_remount
#. type: Plain text
#: man-pages/man7/mount_namespaces.7:118
msgid ""
"The B<mount>(2)  flags B<MS_RDONLY>, B<MS_NOSUID>, B<MS_NOEXEC>, and the "
"\"atime\" flags (B<MS_NOATIME>, B<MS_NODIRATIME>, B<MS_RELATIME>)  settings "
"become locked when propagated from a more privileged to a less privileged "
"mount namespace, and may not be changed in the less privileged mount "
"namespace."
msgstr "Значения флагов B<MS_RDONLY>, B<MS_NOSUID>, B<MS_NOEXEC> у B<mount>(2) и флагов «atime» (B<MS_NOATIME>, B<MS_NODIRATIME>, B<MS_RELATIME>) блокируются при передаче из более привилегированного в менее привилегированное пространство имён монтирования, и не могут быть изменены в менее привилегированном пространстве имён монтирования."

#.  (As of 3.18-rc1 (in Al Viro's 2014-08-30 vfs.git#for-next tree))
#. type: Plain text
#: man-pages/man7/mount_namespaces.7:127
msgid ""
"A file or directory that is a mount point in one namespace that is not a "
"mount point in another namespace, may be renamed, unlinked, or removed "
"(B<rmdir>(2))  in the mount namespace in which it is not a mount point "
"(subject to the usual permission checks).  Consequently, the mount point is "
"removed in the mount namespace where it was a mount point."
msgstr ""

#.  mtk: The change was in Linux 3.18, I think, with this commit:
#.      commit 8ed936b5671bfb33d89bc60bdcc7cf0470ba52fe
#.      Author: Eric W. Biederman <ebiederman@twitter.com>
#.      Date:   Tue Oct 1 18:33:48 2013 -0700
#.          vfs: Lazily remove mounts on unlinked files and directories.
#. type: Plain text
#: man-pages/man7/mount_namespaces.7:143
msgid ""
"Previously (before Linux 3.18), attempting to unlink, rename, or remove a "
"file or directory that was a mount point in another mount namespace would "
"result in the error B<EBUSY>.  That behavior had technical problems of "
"enforcement (e.g., for NFS)  and permitted denial-of-service attacks against"
" more privileged users.  (i.e., preventing individual files from being "
"updated by bind mounting on top of them)."
msgstr ""

#. type: SH
#: man-pages/man7/mount_namespaces.7:143
#, no-wrap
msgid "SHARED SUBTREES"
msgstr "ОБЩИЕ ПОДДЕРЕВЬЯ"

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:158
msgid ""
"After the implementation of mount namespaces was completed, experience "
"showed that the isolation that they provided was, in some cases, too great."
"  For example, in order to make a newly loaded optical disk available in all"
" mount namespaces, a mount operation was required in each namespace.  For "
"this use case, and others, the shared subtree feature was introduced in "
"Linux 2.6.15.  This feature allows for automatic, controlled propagation of "
"mount and unmount I<events> between namespaces (or, more precisely, between "
"the members of a I<peer group> that are propagating events to one another)."
msgstr "После завершения реализации пространств имён монтирования опыт использования показал, что полученная изоляция, в некоторых случаях, слишком велика. Например, чтобы только что смонтированный оптический диск сделать доступным в во всех пространствах имён, требуется операция монтирования в каждом пространстве имён. Для этого случаях и других в Linux 2.6.15 были добавлены общие поддеревья. Это свойство предоставляет автоматическое, управляемое распространение I<событий> монтирования и размонтирования в пространствах имён (или, точнее, между членами I<равноправной группы>, которые обмениваются событиями между собой)."

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:163
msgid ""
"Each mount point is marked (via B<mount>(2))  as having one of the following"
" I<propagation types>:"
msgstr "Каждая точка монтирования помечается (в B<mount>(2)) одним из следующих I<типов распространения>:"

#. type: TP
#: man-pages/man7/mount_namespaces.7:163
#, no-wrap
msgid "B<MS_SHARED>"
msgstr "B<MS_SHARED>"

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:173
msgid ""
"This mount point shares events with members of a peer group.  Mount and "
"unmount events immediately under this mount point will propagate to the "
"other mount points that are members of the peer group.  I<Propagation> here "
"means that the same mount or unmount will automatically occur under all of "
"the other mount points in the peer group.  Conversely, mount and unmount "
"events that take place under peer mount points will propagate to this mount "
"point."
msgstr "События такой точки монтирования являются общими с остальными членами равноправной группы. События монтирования и размонтирования этой точки сразу же распространяются на другие точки монтирования, являющиеся членами равноправной группы. То есть монтирование или размонтирование автоматически происходит и у всех остальных точек монтирования в равноправной группе. И наоборот, события монтирования и размонтирования, возникшие у точек монтирования равноправной группы, будут распространены и на эту точку монтирования."

#. type: TP
#: man-pages/man7/mount_namespaces.7:173
#, no-wrap
msgid "B<MS_PRIVATE>"
msgstr "B<MS_PRIVATE>"

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:177
msgid ""
"This mount point is private; it does not have a peer group.  Mount and "
"unmount events do not propagate into or out of this mount point."
msgstr "Данная точка монтирования индивидуальна; у неё нет равноправной группы. События монтирования и размонтирования не распространяются от этой точки и на эту точку."

#. type: TP
#: man-pages/man7/mount_namespaces.7:177
#, no-wrap
msgid "B<MS_SLAVE>"
msgstr "B<MS_SLAVE>"

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:182
msgid ""
"Mount and unmount events propagate into this mount point from a (master) "
"shared peer group.  Mount and unmount events under this mount point do not "
"propagate to any peer."
msgstr "События монтирования и размонтирования распространяются на эту точку монтирования из (главной) общей равноправной группы. События монтирования и размонтирования этой точки не распространяются на членов группы."

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:187
msgid ""
"Note that a mount point can be the slave of another peer group while at the "
"same time sharing mount and unmount events with a peer group of which it is "
"a member.  (More precisely, one peer group can be the slave of another peer "
"group.)"
msgstr "Заметим, что точка монтирования может быть подчинённой одной равноправной группе и в тоже время может распространять события в другую группу, где она является членом (точнее, одна равноправная группа может быть подчинённой другой равноправной группе)."

#. type: TP
#: man-pages/man7/mount_namespaces.7:187
#, no-wrap
msgid "B<MS_UNBINDABLE>"
msgstr "B<MS_UNBINDABLE>"

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:196
msgid ""
"This is like a private mount, and in addition this mount can't be bind "
"mounted.  Attempts to bind mount this mount (B<mount>(2)  with the "
"B<MS_BIND> flag) will fail."
msgstr "Данный тип подобен индивидуальной точке монтирования, но дополнительно такая точка монтирования не может быть привязана (bind). Попытка привязать эту точку монтирования (B<mount>(2) с флагом B<MS_BIND>) завершится ошибкой."

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:207
msgid ""
"When a recursive bind mount (B<mount>(2)  with the B<MS_BIND> and B<MS_REC> "
"flags) is performed on a directory subtree, any bind mounts within the "
"subtree are automatically pruned (i.e., not replicated)  when replicating "
"that subtree to produce the target subtree."
msgstr "При рекурсивной привязке (B<mount>(2) с флагами B<MS_BIND> и B<MS_REC>) поддерева каталога все привязки внутри поддерева автоматически удаляются (т. е., не копируются) при копировании этого поддерева для создания целевого поддерева."

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:210
msgid ""
"For a discussion of the propagation type assigned to a new mount, see NOTES."
msgstr "Описание типа распространения, назначаемого на новое монтирование, смотрите в ЗАМЕЧАНИЯХ."

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:216
msgid ""
"The propagation type is a per-mount-point setting; some mount points may be "
"marked as shared (with each shared mount point being a member of a distinct "
"peer group), while others are private (or slaved or unbindable)."
msgstr "Тип распространения имеется у каждой точки монтирования; некоторые точки монтирования могут быть помечены как общие (каждая общая точка монтирования является членом определённой равноправной группы), а некоторые как индивидуальные (или подчинённые или непривязываемые)."

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:227
msgid ""
"Note that a mount's propagation type determines whether mounts and unmounts "
"of mount points I<immediately under> the mount point are propagated.  Thus, "
"the propagation type does not affect propagation of events for grandchildren"
" and further removed descendant mount points.  What happens if the mount "
"point itself is unmounted is determined by the propagation type that is in "
"effect for the I<parent> of the mount point."
msgstr "Заметим, что тип распространения монтирования определяет, будет ли монтирование или размонтирование распространяться точки монтирования, находящиеся I<на одну ступень ниже> точки, где возникло событие. То есть, тип распространения не влияет на распространение событий для внуков и в дальнейшем удаляемых потомков точки монтирования. Это случается, если сама точка монтирования размонтируется из-за действия типа распространения который, в сущности, влияние I<родительской> точки монтирования."

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:231
msgid ""
"Members are added to a I<peer group> when a mount point is marked as shared "
"and either:"
msgstr "Члены добавляются в I<равноправную группу>, если точка монтирования помечается как общая, или:"

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:233
msgid ""
"the mount point is replicated during the creation of a new mount namespace; "
"or"
msgstr "точка монтирования копируется при создании нового пространства имён монтирования"

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:235
msgid "a new bind mount is created from the mount point."
msgstr "создаётся новая привязка из точки монтирования"

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:238
msgid ""
"In both of these cases, the new mount point joins the peer group of which "
"the existing mount point is a member."
msgstr "В обоих случаях новая точка монтирования присоединяется к равноправной группе, в которую входит существующая точка монтирования."

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:244
msgid ""
"A new peer group is also created when a child mount point is created under "
"an existing mount point that is marked as shared.  In this case, the new "
"child mount point is also marked as shared and the resulting peer group "
"consists of all the mount points that are replicated under the peers of "
"parent mount."
msgstr "Новая равноправная группа также создаётся, если дочерняя точка монтирования создана под существующей точкой монтирования, помеченной как общая. В этом случае, новая дочерняя точка монтирования также помечается как общая и получаемая равноправная группа состоит из всех точек монтирования, которые дублируются в равноправных группах родительской точки монтирования."

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:249
msgid ""
"A mount ceases to be a member of a peer group when either the mount is "
"explicitly unmounted, or when the mount is implicitly unmounted because a "
"mount namespace is removed (because it has no more member processes)."
msgstr "Точка монтирования перестаёт быть членом равноправной группы, когда происходит её явное размонтирование или неявное из-за удаления пространства имён монтирования (из-за отсутствия участвующих процессов)."

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:258
msgid ""
"The propagation type of the mount points in a mount namespace can be "
"discovered via the \"optional fields\" exposed in I</proc/[pid]/mountinfo>."
"  (See B<proc>(5)  for details of this file.)  The following tags can appear"
" in the optional fields for a record in that file:"
msgstr "Тип распространения точек монтирования в пространстве имён монтирования может узнать через «необязательные поля» в файле I</proc/[pid]/mountinfo> (описание файла смотрите в B<proc>(5)). В необязательных полях этого файла могут появляться следующие метки:"

#. type: TP
#: man-pages/man7/mount_namespaces.7:258
#, no-wrap
msgid "I<shared:X>"
msgstr "I<shared:X>"

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:267
msgid ""
"This mount point is shared in peer group I<X>.  Each peer group has a unique"
" ID that is automatically generated by the kernel, and all mount points in "
"the same peer group will show the same ID.  (These IDs are assigned starting"
" from the value 1, and may be recycled when a peer group ceases to have any "
"members.)"
msgstr "Эта точка монтирования является общей в равноправной группе I<X>. Каждая равноправная группа имеет автоматически генерируемый ядром уникальный идентификатор, и у всех точек монтирования одной равноправной группы здесь будет одинаковый идентификатор (эти идентификаторы начинаются с 1 и могут повторно использоваться, когда в равноправной группе не останется членов)."

#. type: TP
#: man-pages/man7/mount_namespaces.7:267
#, no-wrap
msgid "I<master:X>"
msgstr "I<master:X>"

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:271
msgid "This mount is a slave to shared peer group I<X>."
msgstr "Эта точка монтирования является подчинённой общей равноправной группе I<X>."

#. type: TP
#: man-pages/man7/mount_namespaces.7:271
#, no-wrap
msgid "I<propagate_from:X> (since Linux 2.6.26)"
msgstr "I<propagate_from:X> (начиная с Linux 2.6.26)"

#.  commit 97e7e0f71d6d948c25f11f0a33878d9356d9579e
#. type: Plain text
#: man-pages/man7/mount_namespaces.7:292
msgid ""
"This mount is a slave and receives propagation from shared peer group I<X>."
"  This tag will always appear in conjunction with a I<master:X> tag.  Here, "
"I<X> is the closest dominant peer group under the process's root directory."
"  If I<X> is the immediate master of the mount, or if there is no dominant "
"peer group under the same root, then only the I<master:X> field is present "
"and not the I<propagate_from:X> field.  For further details, see below."
msgstr "Эта точка монтирования является подчинённой и принимает события от общей равноправной группы I<X>. Данная метка всегда появляется вместе с меткой I<master:X>. Здесь I<X> это ближайшая главенствующая равноправная группа из корневого каталога процесса. Если I<X> является непосредственным владельцем точки монтирования, или в том же корне нет ближайшей главенствующей равноправной группы, то существует только поле I<master:X>, и поле I<propagate_from:X> отсутствует. Подробности смотрите ниже."

#. type: TP
#: man-pages/man7/mount_namespaces.7:292
#, no-wrap
msgid "I<unbindable>"
msgstr "I<unbindable>"

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:295
msgid "This is an unbindable mount."
msgstr "Точка монтирования является непривязываемой."

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:297
msgid "If none of the above tags is present, then this is a private mount."
msgstr "Если нет ни одной из вышеперечисленных меток, то точка монтирования является индивидуальной."

#. type: SS
#: man-pages/man7/mount_namespaces.7:297
#, no-wrap
msgid "MS_SHARED and MS_PRIVATE example"
msgstr "Пример MS_SHARED и MS_PRIVATE"

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:302
msgid ""
"Suppose that on a terminal in the initial mount namespace, we mark one mount"
" point as shared and another as private, and then view the mounts in "
"I</proc/self/mountinfo>:"
msgstr "Предположим, что на терминале в первоначальном пространстве имён монтирования мы помечаем одну точку монтирования как общую, а другую — как индивидуальную, и затем смотрим точки монтирования в I</proc/self/mountinfo>:"

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:310
#, no-wrap
msgid ""
"sh1# B<mount --make-shared /mntS>\n"
"sh1# B<mount --make-private /mntP>\n"
"sh1# B<cat /proc/self/mountinfo | grep \\(aq/mnt\\(aq | sed \\(aqs/ - .*//\\(aq>\n"
"77 61 8:17 / /mntS rw,relatime shared:1\n"
"83 61 8:15 / /mntP rw,relatime\n"
msgstr "sh1# B<mount --make-shared /mntS>\nsh1# B<mount --make-private /mntP>\nsh1# B<cat /proc/self/mountinfo | grep \\(aq/mnt\\(aq | sed \\(aqs/ - .*//\\(aq>\n77 61 8:17 / /mntS rw,relatime shared:1\n83 61 8:15 / /mntP rw,relatime\n"

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:329
msgid ""
"From the I</proc/self/mountinfo> output, we see that I</mntS> is a shared "
"mount in peer group 1, and that I</mntP> has no optional tags, indicating "
"that it is a private mount.  The first two fields in each record in this "
"file are the unique ID for this mount, and the mount ID of the parent mount."
"  We can further inspect this file to see that the parent mount point of "
"I</mntS> and I</mntP> is the root directory, I</>, which is mounted as "
"private:"
msgstr "Из вывода I</proc/self/mountinfo> мы видим, что I</mntS> является общей точкой монтирования в равноправной группе 1, и что I</mntP> не имеет необязательных меток, то есть это индивидуальная точка монтирования. Первые два поля в каждой записи этого файла содержат уникальный идентификатор этой точки монтирования и идентификатор точки монтирования родительской точки монтирования. Далее в файле мы видим, что родительская точка монтирования I</mntS> и I</mntP> является корневым каталогом, I</>, которая смонтирована как индивидуальная:"

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:334
#, no-wrap
msgid ""
"sh1# B<cat /proc/self/mountinfo | awk \\(aq$1 == 61\\(aq | sed \\(aqs/ - .*//\\(aq>\n"
"61 0 8:2 / / rw,relatime\n"
msgstr "sh1# B<cat /proc/self/mountinfo | awk \\(aq$1 == 61\\(aq | sed \\(aqs/ - .*//\\(aq>\n61 0 8:2 / / rw,relatime\n"

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:340
msgid ""
"On a second terminal, we create a new mount namespace where we run a second "
"shell and inspect the mounts:"
msgstr "На втором терминале мы создаём новое пространство имён монтирования, в котором запускаем вторую оболочку, и смотрим точки монтирования:"

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:347
#, no-wrap
msgid ""
"$ B<PS1=\\(aqsh2# \\(aq sudo unshare -m --propagation unchanged sh>\n"
"sh2# B<cat /proc/self/mountinfo | grep \\(aq/mnt\\(aq | sed \\(aqs/ - .*//\\(aq>\n"
"222 145 8:17 / /mntS rw,relatime shared:1\n"
"225 145 8:15 / /mntP rw,relatime\n"
msgstr "$ B<PS1=\\(aqsh2# \\(aq sudo unshare -m --propagation unchanged sh>\nsh2# B<cat /proc/self/mountinfo | grep \\(aq/mnt\\(aq | sed \\(aqs/ - .*//\\(aq>\n222 145 8:17 / /mntS rw,relatime shared:1\n225 145 8:15 / /mntP rw,relatime\n"

#.  Since util-linux 2.27
#. type: Plain text
#: man-pages/man7/mount_namespaces.7:361
msgid ""
"The new mount namespace received a copy of the initial mount namespace's "
"mount points.  These new mount points maintain the same propagation types, "
"but have unique mount IDs.  (The I<--propagation\\ unchanged> option "
"prevents B<unshare>(1)  from marking all mounts as private when creating a "
"new mount namespace, which it does by default.)"
msgstr "Новое пространство имён монтирования получает копию точек монтирования из начального пространства имён монтирования. Эти новые точки монтирования имеют тот же тип распространения, но другие уникальные идентификаторы монтирования (при создании нового пространства имён монтирования передача параметра I<--propagation\\ unchanged> программе B<unshare>(1) не даёт помечать все точки монтирования как индивидуальные (что делается по умолчанию))."

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:367
msgid ""
"In the second terminal, we then create submounts under each of I</mntS> and "
"I</mntP> and inspect the set-up:"
msgstr "Далее на втором терминале мы создаём подмонтирования в каталоге  I</mntS> и I</mntP> и смотрим что получилось:"

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:379
#, no-wrap
msgid ""
"sh2# B<mkdir /mntS/a>\n"
"sh2# B<mount /dev/sdb6 /mntS/a>\n"
"sh2# B<mkdir /mntP/b>\n"
"sh2# B<mount /dev/sdb7 /mntP/b>\n"
"sh2# B<cat /proc/self/mountinfo | grep \\(aq/mnt\\(aq | sed \\(aqs/ - .*//\\(aq>\n"
"222 145 8:17 / /mntS rw,relatime shared:1\n"
"225 145 8:15 / /mntP rw,relatime\n"
"178 222 8:22 / /mntS/a rw,relatime shared:2\n"
"230 225 8:23 / /mntP/b rw,relatime\n"
msgstr "sh2# B<mkdir /mntS/a>\nsh2# B<mount /dev/sdb6 /mntS/a>\nsh2# B<mkdir /mntP/b>\nsh2# B<mount /dev/sdb7 /mntP/b>\nsh2# B<cat /proc/self/mountinfo | grep \\(aq/mnt\\(aq | sed \\(aqs/ - .*//\\(aq>\n222 145 8:17 / /mntS rw,relatime shared:1\n225 145 8:15 / /mntP rw,relatime\n178 222 8:22 / /mntS/a rw,relatime shared:2\n230 225 8:23 / /mntP/b rw,relatime\n"

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:387
msgid ""
"From the above, it can be seen that I</mntS/a> was created as shared "
"(inheriting this setting from its parent mount) and I</mntP/b> was created "
"as a private mount."
msgstr "Из показанного выше мы видим, что I</mntS/a> была создана как общая (унаследовала от родительской точки монтирования), а I</mntP/b> — как индивидуальная точка монтирования."

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:395
msgid ""
"Returning to the first terminal and inspecting the set-up, we see that the "
"new mount created under the shared mount point I</mntS> propagated to its "
"peer mount (in the initial mount namespace), but the new mount created under"
" the private mount point I</mntP> did not propagate:"
msgstr "Если вернуться на первый терминал и и ещё раз посмотреть параметры, то можно увидеть, что новая точка монтирования, созданная в общей точке монтирования I</mntS>, передалась в свою равноправную группу монтирования (в начальном пространстве имён монтирования), а новая точка монтирования, созданная в индивидуальной точке монтирования I</mntP>, нет:"

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:402
#, no-wrap
msgid ""
"sh1# B<cat /proc/self/mountinfo | grep \\(aq/mnt\\(aq | sed \\(aqs/ - .*//\\(aq>\n"
"77 61 8:17 / /mntS rw,relatime shared:1\n"
"83 61 8:15 / /mntP rw,relatime\n"
"179 77 8:22 / /mntS/a rw,relatime shared:2\n"
msgstr "sh1# B<cat /proc/self/mountinfo | grep \\(aq/mnt\\(aq | sed \\(aqs/ - .*//\\(aq>\n77 61 8:17 / /mntS rw,relatime shared:1\n83 61 8:15 / /mntP rw,relatime\n179 77 8:22 / /mntS/a rw,relatime shared:2\n"

#. type: SS
#: man-pages/man7/mount_namespaces.7:405
#, no-wrap
msgid "MS_SLAVE example"
msgstr "Пример MS_SLAVE"

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:414
msgid ""
"Making a mount point a slave allows it to receive propagated mount and "
"unmount events from a master shared peer group, while preventing it from "
"propagating events to that master.  This is useful if we want to (say) "
"receive a mount event when an optical disk is mounted in the master shared "
"peer group (in another mount namespace), but want to prevent mount and "
"unmount events under the slave mount from having side effects in other "
"namespaces."
msgstr "Создание подчинённой точки монтирования позволяет ей принимать распространяемые события монтирования и размонтирования из главной общей равноправной группы, но запрещает распространять события в эту главную группу. Это полезно, если требуется, скажем, принимать событие монтирования оптического диска в главной общей равноправной группе (в другом пространстве имён монтирования), но не нужно, чтобы события монтирования и размонтирования в подчинённой точке монтирования передавались в другие пространства имён."

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:417
msgid ""
"We can demonstrate the effect of slaving by first marking two mount points "
"as shared in the initial mount namespace:"
msgstr "Для демонстрации следствия подчинённости сначала создадим две общие точки монтирования в начальном пространстве имён монтирования:"

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:425
#, no-wrap
msgid ""
"sh1# B<mount --make-shared /mntX>\n"
"sh1# B<mount --make-shared /mntY>\n"
"sh1# B<cat /proc/self/mountinfo | grep \\(aq/mnt\\(aq | sed \\(aqs/ - .*//\\(aq>\n"
"132 83 8:23 / /mntX rw,relatime shared:1\n"
"133 83 8:22 / /mntY rw,relatime shared:2\n"
msgstr "sh1# B<mount --make-shared /mntX>\nsh1# B<mount --make-shared /mntY>\nsh1# B<cat /proc/self/mountinfo | grep \\(aq/mnt\\(aq | sed \\(aqs/ - .*//\\(aq>\n132 83 8:23 / /mntX rw,relatime shared:1\n133 83 8:22 / /mntY rw,relatime shared:2\n"

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:430
msgid ""
"On a second terminal, we create a new mount namespace and inspect the mount "
"points:"
msgstr "На втором терминале создадим новое пространство имён монтирования и посмотрим точки монтирования:"

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:437
#, no-wrap
msgid ""
"sh2# B<unshare -m --propagation unchanged sh>\n"
"sh2# B<cat /proc/self/mountinfo | grep \\(aq/mnt\\(aq | sed \\(aqs/ - .*//\\(aq>\n"
"168 167 8:23 / /mntX rw,relatime shared:1\n"
"169 167 8:22 / /mntY rw,relatime shared:2\n"
msgstr "sh2# B<unshare -m --propagation unchanged sh>\nsh2# B<cat /proc/self/mountinfo | grep \\(aq/mnt\\(aq | sed \\(aqs/ - .*//\\(aq>\n168 167 8:23 / /mntX rw,relatime shared:1\n169 167 8:22 / /mntY rw,relatime shared:2\n"

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:441
msgid ""
"In the new mount namespace, we then mark one of the mount points as a slave:"
msgstr "Далее в новом пространстве имён монтирования пометим одну из точек монтирования как подчинённую:"

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:448
#, no-wrap
msgid ""
"sh2# B<mount --make-slave /mntY>\n"
"sh2# B<cat /proc/self/mountinfo | grep \\(aq/mnt\\(aq | sed \\(aqs/ - .*//\\(aq>\n"
"168 167 8:23 / /mntX rw,relatime shared:1\n"
"169 167 8:22 / /mntY rw,relatime master:2\n"
msgstr "sh2# B<mount --make-slave /mntY>\nsh2# B<cat /proc/self/mountinfo | grep \\(aq/mnt\\(aq | sed \\(aqs/ - .*//\\(aq>\n168 167 8:23 / /mntX rw,relatime shared:1\n169 167 8:22 / /mntY rw,relatime master:2\n"

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:455
msgid ""
"From the above output, we see that I</mntY> is now a slave mount that is "
"receiving propagation events from the shared peer group with the ID 2."
msgstr "Из показанного выше видно, что I</mntY> теперь подчинённая точка монтирования, которая принимать распространяемые события от общей равноправной группы с ID 2."

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:460
msgid ""
"Continuing in the new namespace, we create submounts under each of I</mntX> "
"and I</mntY>:"
msgstr "Далее в новом пространстве имён создадим подмонтирования в I</mntX> и I</mntY>:"

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:467
#, no-wrap
msgid ""
"sh2# B<mkdir /mntX/a>\n"
"sh2# B<mount /dev/sda3 /mntX/a>\n"
"sh2# B<mkdir /mntY/b>\n"
"sh2# B<mount /dev/sda5 /mntY/b>\n"
msgstr "sh2# B<mkdir /mntX/a>\nsh2# B<mount /dev/sda3 /mntX/a>\nsh2# B<mkdir /mntY/b>\nsh2# B<mount /dev/sda5 /mntY/b>\n"

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:477
msgid ""
"When we inspect the state of the mount points in the new mount namespace, we"
" see that I</mntX/a> was created as a new shared mount (inheriting the "
"\"shared\" setting from its parent mount) and I</mntY/b> was created as a "
"private mount:"
msgstr "Если посмотреть состояние точек монтирования в новом пространстве имён монтирования можно увидеть, что I</mntX/a> создана как новая общая точка монтирования (наследует «общность» от родительской точки монтирования), а I</mntY/b> создана как индивидуальная точка монтирования:"

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:485
#, no-wrap
msgid ""
"sh2# B<cat /proc/self/mountinfo | grep \\(aq/mnt\\(aq | sed \\(aqs/ - .*//\\(aq>\n"
"168 167 8:23 / /mntX rw,relatime shared:1\n"
"169 167 8:22 / /mntY rw,relatime master:2\n"
"173 168 8:3 / /mntX/a rw,relatime shared:3\n"
"175 169 8:5 / /mntY/b rw,relatime\n"
msgstr "sh2# B<cat /proc/self/mountinfo | grep \\(aq/mnt\\(aq | sed \\(aqs/ - .*//\\(aq>\n168 167 8:23 / /mntX rw,relatime shared:1\n169 167 8:22 / /mntY rw,relatime master:2\n173 168 8:3 / /mntX/a rw,relatime shared:3\n175 169 8:5 / /mntY/b rw,relatime\n"

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:496
msgid ""
"Returning to the first terminal (in the initial mount namespace), we see "
"that the mount I</mntX/a> propagated to the peer (the shared I</mntX>), but "
"the mount I</mntY/b> was not propagated:"
msgstr "Если вернуться на первый терминал (в начальное пространство имён монтирования), то можно увидеть, что точка монтирования I</mntX/a> передалась в свою равноправную группу (общую с I</mntX>), а точка монтирования I</mntY/b> нет:"

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:503
#, no-wrap
msgid ""
"sh1# B<cat /proc/self/mountinfo | grep \\(aq/mnt\\(aq | sed \\(aqs/ - .*//\\(aq>\n"
"132 83 8:23 / /mntX rw,relatime shared:1\n"
"133 83 8:22 / /mntY rw,relatime shared:2\n"
"174 132 8:3 / /mntX/a rw,relatime shared:3\n"
msgstr "sh1# B<cat /proc/self/mountinfo | grep \\(aq/mnt\\(aq | sed \\(aqs/ - .*//\\(aq>\n132 83 8:23 / /mntX rw,relatime shared:1\n133 83 8:22 / /mntY rw,relatime shared:2\n174 132 8:3 / /mntX/a rw,relatime shared:3\n"

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:509
msgid "Now we create a new mount point under I</mntY> in the first shell:"
msgstr "Теперь создадим новую точку монтирования в I</mntY> в первом терминале:"

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:519
#, no-wrap
msgid ""
"sh1# B<mkdir /mntY/c>\n"
"sh1# B<mount /dev/sda1 /mntY/c>\n"
"sh1# B<cat /proc/self/mountinfo | grep '/mnt' | sed 's/ - .*//'>\n"
"132 83 8:23 / /mntX rw,relatime shared:1\n"
"133 83 8:22 / /mntY rw,relatime shared:2\n"
"174 132 8:3 / /mntX/a rw,relatime shared:3\n"
"178 133 8:1 / /mntY/c rw,relatime shared:4\n"
msgstr "sh1# B<mkdir /mntY/c>\nsh1# B<mount /dev/sda1 /mntY/c>\nsh1# B<cat /proc/self/mountinfo | grep '/mnt' | sed 's/ - .*//'>\n132 83 8:23 / /mntX rw,relatime shared:1\n133 83 8:22 / /mntY rw,relatime shared:2\n174 132 8:3 / /mntX/a rw,relatime shared:3\n178 133 8:1 / /mntY/c rw,relatime shared:4\n"

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:526
msgid ""
"When we examine the mount points in the second mount namespace, we see that "
"in this case the new mount has been propagated to the slave mount point, and"
" that the new mount is itself a slave mount (to peer group 4):"
msgstr "Если посмотреть точки монтирования во втором пространстве имён монтирования, то можно увидеть, что на этот раз новая точка монтирования передалась в подчинённую точку монтирования и что эта новая точка монтирования сама является подчинённой (равноправной группе 4):"

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:535
#, no-wrap
msgid ""
"sh2# B<cat /proc/self/mountinfo | grep \\(aq/mnt\\(aq | sed \\(aqs/ - .*//\\(aq>\n"
"168 167 8:23 / /mntX rw,relatime shared:1\n"
"169 167 8:22 / /mntY rw,relatime master:2\n"
"173 168 8:3 / /mntX/a rw,relatime shared:3\n"
"175 169 8:5 / /mntY/b rw,relatime\n"
"179 169 8:1 / /mntY/c rw,relatime master:4\n"
msgstr "sh2# B<cat /proc/self/mountinfo | grep \\(aq/mnt\\(aq | sed \\(aqs/ - .*//\\(aq>\n168 167 8:23 / /mntX rw,relatime shared:1\n169 167 8:22 / /mntY rw,relatime master:2\n173 168 8:3 / /mntX/a rw,relatime shared:3\n175 169 8:5 / /mntY/b rw,relatime\n179 169 8:1 / /mntY/c rw,relatime master:4\n"

#. type: SS
#: man-pages/man7/mount_namespaces.7:538
#, no-wrap
msgid "MS_UNBINDABLE example"
msgstr "Пример MS_UNBINDABLE"

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:543
msgid ""
"One of the primary purposes of unbindable mounts is to avoid the \"mount "
"point explosion\" problem when repeatedly performing bind mounts of a "
"higher-level subtree at a lower-level mount point.  The problem is "
"illustrated by the following shell session."
msgstr "Одним из основных назначений непривязываемых точек монтирования является решение проблемы «взрыва точек монтирования» — повторяющееся выполнение привязки точки монтирования поддерева верхнего уровня в точках монтирования нижнего уровня. Эта проблема показана в сеансе далее."

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:545
msgid "Suppose we have a system with the following mount points:"
msgstr "Предположим, что имеется система с следующими точками монтирования:"

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:552
#, no-wrap
msgid ""
"# B<mount | awk \\(aq{print $1, $2, $3}\\(aq>\n"
"/dev/sda1 on /\n"
"/dev/sdb6 on /mntX\n"
"/dev/sdb7 on /mntY\n"
msgstr "# B<mount | awk \\(aq{print $1, $2, $3}\\(aq>\n/dev/sda1 on /\n/dev/sdb6 on /mntX\n/dev/sdb7 on /mntY\n"

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:558
msgid ""
"Suppose furthermore that we wish to recursively bind mount the root "
"directory under several users' home directories.  We do this for the first "
"user, and inspect the mount points:"
msgstr "Предположим, что нужно рекурсивно привязать точки монтирования корневого каталога в нескольких пользовательских домашних каталогах. Сделаем это для первого пользователя и посмотрим точки монтирования:"

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:569
#, no-wrap
msgid ""
"# B<mount --rbind / /home/cecilia/>\n"
"# B<mount | awk \\(aq{print $1, $2, $3}\\(aq>\n"
"/dev/sda1 on /\n"
"/dev/sdb6 on /mntX\n"
"/dev/sdb7 on /mntY\n"
"/dev/sda1 on /home/cecilia\n"
"/dev/sdb6 on /home/cecilia/mntX\n"
"/dev/sdb7 on /home/cecilia/mntY\n"
msgstr "# B<mount --rbind / /home/cecilia/>\n# B<mount | awk \\(aq{print $1, $2, $3}\\(aq>\n/dev/sda1 on /\n/dev/sdb6 on /mntX\n/dev/sdb7 on /mntY\n/dev/sda1 on /home/cecilia\n/dev/sdb6 on /home/cecilia/mntX\n/dev/sdb7 on /home/cecilia/mntY\n"

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:574
msgid ""
"When we repeat this operation for the second user, we start to see the "
"explosion problem:"
msgstr "Повторяя эту операцию для второго пользователя сталкиваемся с проблемой взрывного роста:"

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:591
#, no-wrap
msgid ""
"# B<mount --rbind / /home/henry>\n"
"# B<mount | awk \\(aq{print $1, $2, $3}\\(aq>\n"
"/dev/sda1 on /\n"
"/dev/sdb6 on /mntX\n"
"/dev/sdb7 on /mntY\n"
"/dev/sda1 on /home/cecilia\n"
"/dev/sdb6 on /home/cecilia/mntX\n"
"/dev/sdb7 on /home/cecilia/mntY\n"
"/dev/sda1 on /home/henry\n"
"/dev/sdb6 on /home/henry/mntX\n"
"/dev/sdb7 on /home/henry/mntY\n"
"/dev/sda1 on /home/henry/home/cecilia\n"
"/dev/sdb6 on /home/henry/home/cecilia/mntX\n"
"/dev/sdb7 on /home/henry/home/cecilia/mntY\n"
msgstr "# B<mount --rbind / /home/henry>\n# B<mount | awk \\(aq{print $1, $2, $3}\\(aq>\n/dev/sda1 on /\n/dev/sdb6 on /mntX\n/dev/sdb7 on /mntY\n/dev/sda1 on /home/cecilia\n/dev/sdb6 on /home/cecilia/mntX\n/dev/sdb7 on /home/cecilia/mntY\n/dev/sda1 on /home/henry\n/dev/sdb6 on /home/henry/mntX\n/dev/sdb7 on /home/henry/mntY\n/dev/sda1 on /home/henry/home/cecilia\n/dev/sdb6 on /home/henry/home/cecilia/mntX\n/dev/sdb7 on /home/henry/home/cecilia/mntY\n"

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:605
msgid ""
"Under I</home/henry>, we have not only recursively added the I</mntX> and "
"I</mntY> mounts, but also the recursive mounts of those directories under "
"I</home/cecilia> that were created in the previous step.  Upon repeating the"
" step for a third user, it becomes obvious that the explosion is exponential"
" in nature:"
msgstr "В I</home/henry> рекурсивно добавились не только точки монтирования I</mntX> и I</mntY>, но и рекурсивные точки монтирования этих каталогов, смонтированных в I</home/cecilia>, который мы создали на предыдущем шаге. Далее повторяя процесс для третьего пользователя, станет очевидно, что взрывной рост происходит экспоненциально:"

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:634
#, no-wrap
msgid ""
"# B<mount --rbind / /home/otto>\n"
"# B<mount | awk \\(aq{print $1, $2, $3}\\(aq>\n"
"/dev/sda1 on /\n"
"/dev/sdb6 on /mntX\n"
"/dev/sdb7 on /mntY\n"
"/dev/sda1 on /home/cecilia\n"
"/dev/sdb6 on /home/cecilia/mntX\n"
"/dev/sdb7 on /home/cecilia/mntY\n"
"/dev/sda1 on /home/henry\n"
"/dev/sdb6 on /home/henry/mntX\n"
"/dev/sdb7 on /home/henry/mntY\n"
"/dev/sda1 on /home/henry/home/cecilia\n"
"/dev/sdb6 on /home/henry/home/cecilia/mntX\n"
"/dev/sdb7 on /home/henry/home/cecilia/mntY\n"
"/dev/sda1 on /home/otto\n"
"/dev/sdb6 on /home/otto/mntX\n"
"/dev/sdb7 on /home/otto/mntY\n"
"/dev/sda1 on /home/otto/home/cecilia\n"
"/dev/sdb6 on /home/otto/home/cecilia/mntX\n"
"/dev/sdb7 on /home/otto/home/cecilia/mntY\n"
"/dev/sda1 on /home/otto/home/henry\n"
"/dev/sdb6 on /home/otto/home/henry/mntX\n"
"/dev/sdb7 on /home/otto/home/henry/mntY\n"
"/dev/sda1 on /home/otto/home/henry/home/cecilia\n"
"/dev/sdb6 on /home/otto/home/henry/home/cecilia/mntX\n"
"/dev/sdb7 on /home/otto/home/henry/home/cecilia/mntY\n"
msgstr "# B<mount --rbind / /home/otto>\n# B<mount | awk \\(aq{print $1, $2, $3}\\(aq>\n/dev/sda1 on /\n/dev/sdb6 on /mntX\n/dev/sdb7 on /mntY\n/dev/sda1 on /home/cecilia\n/dev/sdb6 on /home/cecilia/mntX\n/dev/sdb7 on /home/cecilia/mntY\n/dev/sda1 on /home/henry\n/dev/sdb6 on /home/henry/mntX\n/dev/sdb7 on /home/henry/mntY\n/dev/sda1 on /home/henry/home/cecilia\n/dev/sdb6 on /home/henry/home/cecilia/mntX\n/dev/sdb7 on /home/henry/home/cecilia/mntY\n/dev/sda1 on /home/otto\n/dev/sdb6 on /home/otto/mntX\n/dev/sdb7 on /home/otto/mntY\n/dev/sda1 on /home/otto/home/cecilia\n/dev/sdb6 on /home/otto/home/cecilia/mntX\n/dev/sdb7 on /home/otto/home/cecilia/mntY\n/dev/sda1 on /home/otto/home/henry\n/dev/sdb6 on /home/otto/home/henry/mntX\n/dev/sdb7 on /home/otto/home/henry/mntY\n/dev/sda1 on /home/otto/home/henry/home/cecilia\n/dev/sdb6 on /home/otto/home/henry/home/cecilia/mntX\n/dev/sdb7 on /home/otto/home/henry/home/cecilia/mntY\n"

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:642
msgid ""
"The mount explosion problem in the above scenario can be avoided by making "
"each of the new mounts unbindable.  The effect of doing this is that "
"recursive mounts of the root directory will not replicate the unbindable "
"mounts.  We make such a mount for the first user:"
msgstr "Проблемы взрывного роста монтирования в показанном сценарии можно избежать, если делать каждое новое монтирование непривязываемым. В этом случае рекурсивное монтирование корневого каталоге не копирует непривязываемые точки монтирования. Сделаем такое монтирование для первого пользователя:"

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:646
#, no-wrap
msgid "# B<mount --rbind --make-unbindable / /home/cecilia>\n"
msgstr "# B<mount --rbind --make-unbindable / /home/cecilia>\n"

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:650
msgid ""
"Before going further, we show that unbindable mounts are indeed unbindable:"
msgstr "Перед тем как продолжить, посмотрим, что непривязываемые точки монтирования действительно нельзя привязать:"

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:657
#, no-wrap
msgid ""
"# B<mkdir /mntZ>\n"
"# B<mount --bind /home/cecilia /mntZ>\n"
"mount: wrong fs type, bad option, bad superblock on /home/cecilia,\n"
"       missing codepage or helper program, or other error\n"
msgstr "# B<mkdir /mntZ>\n# B<mount --bind /home/cecilia /mntZ>\nmount: wrong fs type, bad option, bad superblock on /home/cecilia,\n       missing codepage or helper program, or other error\n"

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:660
#, no-wrap
msgid ""
"       In some cases useful info is found in syslog - try\n"
"       dmesg | tail or so.\n"
msgstr "       В некоторых случаях полезная информация может быть\n       найдена в syslog - попробуйте dmesg | tail или что-то\n       в этом роде.\n"

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:664
msgid ""
"Now we create unbindable recursive bind mounts for the other two users:"
msgstr "Теперь создадим непривязываемое рекурсивное монтирования для остальных пользователей:"

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:669
#, no-wrap
msgid ""
"# B<mount --rbind --make-unbindable / /home/henry>\n"
"# B<mount --rbind --make-unbindable / /home/otto>\n"
msgstr "# B<mount --rbind --make-unbindable / /home/henry>\n# B<mount --rbind --make-unbindable / /home/otto>\n"

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:676
msgid ""
"Upon examining the list of mount points, we see there has been no explosion "
"of mount points, because the unbindable mounts were not replicated under "
"each user's directory:"
msgstr "Если посмотреть список точек монтирования, то можно увидеть, что взрывного роста не произошло, так как непривязываемые точки монтирования не скопировались в каждый пользовательский каталог:"

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:692
#, no-wrap
msgid ""
"# B<mount | awk \\(aq{print $1, $2, $3}\\(aq>\n"
"/dev/sda1 on /\n"
"/dev/sdb6 on /mntX\n"
"/dev/sdb7 on /mntY\n"
"/dev/sda1 on /home/cecilia\n"
"/dev/sdb6 on /home/cecilia/mntX\n"
"/dev/sdb7 on /home/cecilia/mntY\n"
"/dev/sda1 on /home/henry\n"
"/dev/sdb6 on /home/henry/mntX\n"
"/dev/sdb7 on /home/henry/mntY\n"
"/dev/sda1 on /home/otto\n"
"/dev/sdb6 on /home/otto/mntX\n"
"/dev/sdb7 on /home/otto/mntY\n"
msgstr "# B<mount | awk \\(aq{print $1, $2, $3}\\(aq>\n/dev/sda1 on /\n/dev/sdb6 on /mntX\n/dev/sdb7 on /mntY\n/dev/sda1 on /home/cecilia\n/dev/sdb6 on /home/cecilia/mntX\n/dev/sdb7 on /home/cecilia/mntY\n/dev/sda1 on /home/henry\n/dev/sdb6 on /home/henry/mntX\n/dev/sdb7 on /home/henry/mntY\n/dev/sda1 on /home/otto\n/dev/sdb6 on /home/otto/mntX\n/dev/sdb7 on /home/otto/mntY\n"

#. type: SS
#: man-pages/man7/mount_namespaces.7:695
#, no-wrap
msgid "Propagation type transitions"
msgstr "Переходы типов распространения"

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:704
msgid ""
"The following table shows the effect that applying a new propagation type "
"(i.e., I<mount --make-xxxx>)  has on the existing propagation type of a "
"mount point.  The rows correspond to existing propagation types, and the "
"columns are the new propagation settings.  For reasons of space, \"private\""
" is abbreviated as \"priv\" and \"unbindable\" as \"unbind\"."
msgstr "В следующей таблице показано как влияет применение нового типа распространения (т. е., I<mount --make-xxxx>) на текущий тип распространения точки монтирования. Строки соответствуют существующим типам распространения, а столбцы — заданию нового типа распространения. Из-за нехватки места «индивидуальная» тип сокращён до «инд», а «непривязываемая» до «неприв»."

#. type: tbl table
#: man-pages/man7/mount_namespaces.7:707
#, no-wrap
msgid "make-shared"
msgstr "сделать-общим"

#. type: tbl table
#: man-pages/man7/mount_namespaces.7:707
#, no-wrap
msgid "make-slave"
msgstr "сделать-подчинён"

#. type: tbl table
#: man-pages/man7/mount_namespaces.7:707
#, no-wrap
msgid "make-priv"
msgstr "сделать-инд"

#. type: tbl table
#: man-pages/man7/mount_namespaces.7:707
#, no-wrap
msgid "make-unbind"
msgstr "сделать-неприв"

#. type: tbl table
#: man-pages/man7/mount_namespaces.7:708 man-pages/man7/mount_namespaces.7:711
#: man-pages/man7/mount_namespaces.7:712 man-pages/man7/mount_namespaces.7:756
#: man-pages/man7/mount_namespaces.7:758 man-pages/man7/mount_namespaces.7:759
#: man-pages/man7/mount_namespaces.7:800 man-pages/man7/mount_namespaces.7:802
#: man-pages/man7/mount_namespaces.7:803
#, no-wrap
msgid "shared"
msgstr "общий"

#. type: tbl table
#: man-pages/man7/mount_namespaces.7:708
#, no-wrap
msgid "slave/priv [1]"
msgstr "общий/инд [1]"

#. type: tbl table
#: man-pages/man7/mount_namespaces.7:708 man-pages/man7/mount_namespaces.7:709
#: man-pages/man7/mount_namespaces.7:710 man-pages/man7/mount_namespaces.7:711
#: man-pages/man7/mount_namespaces.7:712
#, no-wrap
msgid "priv"
msgstr "инд"

#. type: tbl table
#: man-pages/man7/mount_namespaces.7:708 man-pages/man7/mount_namespaces.7:709
#: man-pages/man7/mount_namespaces.7:710 man-pages/man7/mount_namespaces.7:711
#: man-pages/man7/mount_namespaces.7:712 man-pages/man7/mount_namespaces.7:756
#: man-pages/man7/mount_namespaces.7:800
#, no-wrap
msgid "unbind"
msgstr "неприв"

#. type: tbl table
#: man-pages/man7/mount_namespaces.7:709 man-pages/man7/mount_namespaces.7:710
#: man-pages/man7/mount_namespaces.7:756 man-pages/man7/mount_namespaces.7:759
#: man-pages/man7/mount_namespaces.7:800 man-pages/man7/mount_namespaces.7:803
#, no-wrap
msgid "slave"
msgstr "подчинён"

#. type: tbl table
#: man-pages/man7/mount_namespaces.7:709 man-pages/man7/mount_namespaces.7:710
#: man-pages/man7/mount_namespaces.7:758 man-pages/man7/mount_namespaces.7:802
#, no-wrap
msgid "slave+shared"
msgstr "подчинён+общий"

#. type: tbl table
#: man-pages/man7/mount_namespaces.7:709
#, no-wrap
msgid "slave [2]"
msgstr "подчинён [2]"

#. type: tbl table
#: man-pages/man7/mount_namespaces.7:711 man-pages/man7/mount_namespaces.7:756
#: man-pages/man7/mount_namespaces.7:759 man-pages/man7/mount_namespaces.7:800
#: man-pages/man7/mount_namespaces.7:803
#, no-wrap
msgid "private"
msgstr "инд"

#. type: tbl table
#: man-pages/man7/mount_namespaces.7:711
#, no-wrap
msgid "priv [2]"
msgstr "инд [2]"

#. type: tbl table
#: man-pages/man7/mount_namespaces.7:712 man-pages/man7/mount_namespaces.7:803
#, no-wrap
msgid "unbindable"
msgstr "неприв"

#. type: tbl table
#: man-pages/man7/mount_namespaces.7:712
#, no-wrap
msgid "unbind [2]"
msgstr "неприв [2]"

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:716
msgid "Note the following details to the table:"
msgstr "Замечания к таблице:"

#. type: IP
#: man-pages/man7/mount_namespaces.7:716
#, no-wrap
msgid "[1]"
msgstr "[1]"

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:719
msgid ""
"If a shared mount is the only mount in its peer group, making it a slave "
"automatically makes it private."
msgstr "Если общая точка монтирования смонтирована только в её равноправной группе, то изменение её типа на подчинённый автоматически делает её индивидуальной."

#. type: IP
#: man-pages/man7/mount_namespaces.7:719
#, no-wrap
msgid "[2]"
msgstr "[2]"

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:722
msgid "Slaving a nonshared mount has no effect on the mount."
msgstr "Подчинение не общей точки монтирования не влияет на монтирование."

#. type: SS
#: man-pages/man7/mount_namespaces.7:722
#, no-wrap
msgid "Bind (MS_BIND) semantics"
msgstr "Семантика привязывания (MS_BIND)"

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:724 man-pages/man7/mount_namespaces.7:772
msgid "Suppose that the following command is performed:"
msgstr "Предположим, что выполняется следующая команда:"

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:728
#, no-wrap
msgid "mount --bind A/a B/b\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:750
msgid ""
"Here, I<A> is the source mount point, I<B> is the destination mount point, "
"I<a> is a subdirectory path under the mount point I<A>, and I<b> is a "
"subdirectory path under the mount point I<B>.  The propagation type of the "
"resulting mount, I<B/b>, depends on the propagation types of the mount "
"points I<A> and I<B>, and is summarized in the following table."
msgstr "Здесь I<A> — исходная точка монтирования, I<B> — целевая точка монтирования, I<a> — подкаталог в точке монтирования I<A> и I<b> — подкаталог в точке монтирования I<B>. Тип распространения получаемой точки, I<B/b>, зависит от типов распространения точек монтирования I<A> и I<B>, и рассчитывается по следующей таблице:"

#. type: tbl table
#: man-pages/man7/mount_namespaces.7:755 man-pages/man7/mount_namespaces.7:799
#, no-wrap
msgid "source(A)"
msgstr "исход(A)"

#. type: tbl table
#: man-pages/man7/mount_namespaces.7:757 man-pages/man7/mount_namespaces.7:801
#, no-wrap
msgid "_"
msgstr "_"

#. type: tbl table
#: man-pages/man7/mount_namespaces.7:758 man-pages/man7/mount_namespaces.7:802
#, no-wrap
msgid "dest(B)"
msgstr "цель(B)"

#. type: tbl table
#: man-pages/man7/mount_namespaces.7:758 man-pages/man7/mount_namespaces.7:802
#, no-wrap
msgid "shared    |"
msgstr "общий    |"

#. type: tbl table
#: man-pages/man7/mount_namespaces.7:758 man-pages/man7/mount_namespaces.7:759
#: man-pages/man7/mount_namespaces.7:802
#, no-wrap
msgid "invalid"
msgstr "некорректно"

#. type: tbl table
#: man-pages/man7/mount_namespaces.7:759 man-pages/man7/mount_namespaces.7:803
#, no-wrap
msgid "nonshared |"
msgstr "не_общий |"

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:765
msgid ""
"Note that a recursive bind of a subtree follows the same semantics as for a "
"bind operation on each mount in the subtree.  (Unbindable mounts are "
"automatically pruned at the target mount point.)"
msgstr "Заметим, что рекурсивное привязывание поддерева имеет такую же семантику как в операции привязывания каждой точки монтирования в поддереве (непривязываемые точки монтирования автоматически убираются из целевой точки монтирования)."

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:770 man-pages/man7/mount_namespaces.7:812
msgid ""
"For further details, see I<Documentation/filesystems/sharedsubtree.txt> in "
"the kernel source tree."
msgstr "Дополнительную информацию смотрите в файле I<Documentation/filesystems/sharedsubtree.txt> дерева исходного кода ядра."

#. type: SS
#: man-pages/man7/mount_namespaces.7:770
#, no-wrap
msgid "Move (MS_MOVE) semantics"
msgstr "Семантика перемещения (MS_MOVE)"

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:776
#, no-wrap
msgid "mount --move A B/b\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:794
msgid ""
"Here, I<A> is the source mount point, I<B> is the destination mount point, "
"and I<b> is a subdirectory path under the mount point I<B>.  The propagation"
" type of the resulting mount, I<B/b>, depends on the propagation types of "
"the mount points I<A> and I<B>, and is summarized in the following table."
msgstr "Здесь I<A> — исходная точка монтирования, I<B> — целевая точка монтирования и I<b> — подкаталог в точке монтирования I<B>. Тип распространения получаемой точки, I<B/b>, зависит от типов распространения точек монтирования I<A> и I<B>, и рассчитывается по следующей таблице:"

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:807
msgid "Note: moving a mount that resides under a shared mount is invalid."
msgstr "Замечание: перемещение точки монтирования, располагающейся ниже общей точки, некорректно."

#. type: SS
#: man-pages/man7/mount_namespaces.7:812
#, no-wrap
msgid "Mount semantics"
msgstr "Семантики монтирования"

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:814
msgid "Suppose that we use the following command to create a mount point:"
msgstr "Предположим, что для создания точки монтирования используется следующая команда:"

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:818
#, no-wrap
msgid "mount device B/b\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:833
msgid ""
"Here, I<B> is the destination mount point, and I<b> is a subdirectory path "
"under the mount point I<B>.  The propagation type of the resulting mount, "
"I<B/b>, follows the same rules as for a bind mount, where the propagation "
"type of the source mount is considered always to be private."
msgstr "Здесь I<B> — целевая точка монтирования и I<b> — подкаталог в точке монтирования I<B>. Тип распространения получаемой точки, I<B/b>, получается таким же как при привязывании, где тип распространения исходной точки монтирования всегда равен индивидуальному."

#. type: SS
#: man-pages/man7/mount_namespaces.7:833
#, no-wrap
msgid "Unmount semantics"
msgstr "Семантики размонтирования"

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:835
msgid "Suppose that we use the following command to tear down a mount point:"
msgstr "Предположим, что для размонтирования точки используется следующая команда:"

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:839
#, no-wrap
msgid "unmount A\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:860
msgid ""
"Here, I<A> is a mount point on I<B/b>, where I<B> is the parent mount and "
"I<b> is a subdirectory path under the mount point I<B>.  If B<B> is shared, "
"then all most-recently-mounted mounts at I<b> on mounts that receive "
"propagation from mount I<B> and do not have submounts under them are "
"unmounted."
msgstr "Здесь I<A> точка монтирования на I<B/b>, где I<B> — родительская точка монтирования и I<b> — подкаталог в точке монтирования I<B>. Если B<B> имеет общий тип распространения, то все последние монтирования в I<b>, получающие события от точки монтирования I<B> и не имеющие подмонтирований внутри, будут размонтированы."

#. type: SS
#: man-pages/man7/mount_namespaces.7:860
#, no-wrap
msgid "The /proc/[pid]/mountinfo propagate_from tag"
msgstr "Метка /proc/[pid]/mountinfo propagate_from"

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:870
msgid ""
"The I<propagate_from:X> tag is shown in the optional fields of a "
"I</proc/[pid]/mountinfo> record in cases where a process can't see a slave's"
" immediate master (i.e., the pathname of the master is not reachable from "
"the filesystem root directory)  and so cannot determine the chain of "
"propagation between the mounts it can see."
msgstr "Метка I<propagate_from:X> появляется в необязательных полях записи I</proc/[pid]/mountinfo> в случаях, когда процесс не может видеть непосредственного мастера (т. е., путь к мастеру недоступен из корневого каталога файловой системы) и поэтому не может определить цепочку распространения между точками монтирования, которые он может видеть."

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:885
msgid ""
"In the following example, we first create a two-link master-slave chain "
"between the mounts I</mnt>, I</tmp/etc>, and I</mnt/tmp/etc>.  Then the "
"B<chroot>(1)  command is used to make the I</tmp/etc> mount point "
"unreachable from the root directory, creating a situation where the master "
"of I</mnt/tmp/etc> is not reachable from the (new) root directory of the "
"process."
msgstr "В следующем примере сначала создаётся двусвязная цепочка мастер-подчинённый между точками монтирования I</mnt>, I</tmp/etc> и I</mnt/tmp/etc>. Затем используется команда B<chroot>(1), чтобы сделать точку монтирования I</tmp/etc> недоступной из корневого каталога, что создаёт ситуацию, где мастер для I</mnt/tmp/etc> недоступен из (нового) корневого каталога процесса."

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:898
msgid ""
"First, we bind mount the root directory onto I</mnt> and then bind mount "
"I</proc> at I</mnt/proc> so that after the later B<chroot>(1)  the "
"B<proc>(5)  filesystem remains visible at the correct location in the "
"chroot-ed environment."
msgstr "Сначала привяжем корневой каталог в I</mnt>, а затем привяжем I</proc> в I</mnt/proc>, чтобы после этого в правильном месте chroot-окружения для B<chroot>(1) осталась доступной файловая система B<proc>(5)."

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:904
#, no-wrap
msgid ""
"# B<mkdir -p /mnt/proc>\n"
"# B<mount --bind / /mnt>\n"
"# B<mount --bind /proc /mnt/proc>\n"
msgstr "# B<mkdir -p /mnt/proc>\n# B<mount --bind / /mnt>\n# B<mount --bind /proc /mnt/proc>\n"

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:910
msgid ""
"Next, we ensure that the I</mnt> mount is a shared mount in a new peer group"
" (with no peers):"
msgstr "Теперь убедимся, что точка монтирования I</mnt> является общей в новой равноправной группе (без членов):"

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:918
#, no-wrap
msgid ""
"# B<mount --make-private /mnt>  # Isolate from any previous peer group\n"
"# B<mount --make-shared /mnt>\n"
"# B<cat /proc/self/mountinfo | grep \\(aq/mnt\\(aq | sed \\(aqs/ - .*//\\(aq>\n"
"239 61 8:2 / /mnt ... shared:102\n"
"248 239 0:4 / /mnt/proc ... shared:5\n"
msgstr "# B<mount --make-private /mnt>  # Изолировать от любой предыдущей группы\n# B<mount --make-shared /mnt>\n# B<cat /proc/self/mountinfo | grep \\(aq/mnt\\(aq | sed \\(aqs/ - .*//\\(aq>\n239 61 8:2 / /mnt ... shared:102\n248 239 0:4 / /mnt/proc ... shared:5\n"

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:925
msgid "Next, we bind mount I</mnt/etc> onto I</tmp/etc>:"
msgstr "Теперь привяжем I</mnt/etc> к I</tmp/etc>:"

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:934
#, no-wrap
msgid ""
"# B<mkdir -p /tmp/etc>\n"
"# B<mount --bind /mnt/etc /tmp/etc>\n"
"# B<cat /proc/self/mountinfo | egrep \\(aq/mnt|/tmp/\\(aq | sed \\(aqs/ - .*//\\(aq>\n"
"239 61 8:2 / /mnt ... shared:102\n"
"248 239 0:4 / /mnt/proc ... shared:5\n"
"267 40 8:2 /etc /tmp/etc ... shared:102\n"
msgstr "# B<mkdir -p /tmp/etc>\n# B<mount --bind /mnt/etc /tmp/etc>\n# B<cat /proc/self/mountinfo | egrep \\(aq/mnt|/tmp/\\(aq | sed \\(aqs/ - .*//\\(aq>\n239 61 8:2 / /mnt ... shared:102\n248 239 0:4 / /mnt/proc ... shared:5\n267 40 8:2 /etc /tmp/etc ... shared:102\n"

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:946
msgid ""
"Initially, these two mount points are in the same peer group, but we then "
"make the I</tmp/etc> a slave of I</mnt/etc>, and then make I</tmp/etc> "
"shared as well, so that it can propagate events to the next slave in the "
"chain:"
msgstr "Первоначально, эти две точки монтирования были в одной равноправной группе, но мы сделали I</tmp/etc> подчинённой I</mnt/etc>, а затем сделали I</tmp/etc> общей, так чтобы она могла распространять события следующему подчинённому в цепочке:"

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:955
#, no-wrap
msgid ""
"# B<mount --make-slave /tmp/etc>\n"
"# B<mount --make-shared /tmp/etc>\n"
"# B<cat /proc/self/mountinfo | egrep \\(aq/mnt|/tmp/\\(aq | sed \\(aqs/ - .*//\\(aq>\n"
"239 61 8:2 / /mnt ... shared:102\n"
"248 239 0:4 / /mnt/proc ... shared:5\n"
"267 40 8:2 /etc /tmp/etc ... shared:105 master:102\n"
msgstr "# B<mount --make-slave /tmp/etc>\n# B<mount --make-shared /tmp/etc>\n# B<cat /proc/self/mountinfo | egrep \\(aq/mnt|/tmp/\\(aq | sed \\(aqs/ - .*//\\(aq>\n239 61 8:2 / /mnt ... shared:102\n248 239 0:4 / /mnt/proc ... shared:5\n267 40 8:2 /etc /tmp/etc ... shared:105 master:102\n"

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:967
msgid ""
"Then we bind mount I</tmp/etc> onto I</mnt/tmp/etc>.  Again, the two mount "
"points are initially in the same peer group, but we then make "
"I</mnt/tmp/etc> a slave of I</tmp/etc>:"
msgstr "Затем мы привязали I</tmp/etc> в I</mnt/tmp/etc>. Опять же, две точки монтирования первоначально были в одной равноправной группе, но позднее мы сделали I</mnt/tmp/etc> подчинённой I</tmp/etc>:"

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:978
#, no-wrap
msgid ""
"# B<mkdir -p /mnt/tmp/etc>\n"
"# B<mount --bind /tmp/etc /mnt/tmp/etc>\n"
"# B<mount --make-slave /mnt/tmp/etc>\n"
"# B<cat /proc/self/mountinfo | egrep \\(aq/mnt|/tmp/\\(aq | sed \\(aqs/ - .*//\\(aq>\n"
"239 61 8:2 / /mnt ... shared:102\n"
"248 239 0:4 / /mnt/proc ... shared:5\n"
"267 40 8:2 /etc /tmp/etc ... shared:105 master:102\n"
"273 239 8:2 /etc /mnt/tmp/etc ... master:105\n"
msgstr "# B<mkdir -p /mnt/tmp/etc>\n# B<mount --bind /tmp/etc /mnt/tmp/etc>\n# B<mount --make-slave /mnt/tmp/etc>\n# B<cat /proc/self/mountinfo | egrep \\(aq/mnt|/tmp/\\(aq | sed \\(aqs/ - .*//\\(aq>\n239 61 8:2 / /mnt ... shared:102\n248 239 0:4 / /mnt/proc ... shared:5\n267 40 8:2 /etc /tmp/etc ... shared:105 master:102\n273 239 8:2 /etc /mnt/tmp/etc ... master:105\n"

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:987
msgid ""
"From the above, we see that I</mnt> is the master of the slave I</tmp/etc>, "
"which in turn is the master of the slave I</mnt/tmp/etc>."
msgstr "Из показанного выше можно видеть, что I</mnt> является главной для подчинённой I</tmp/etc>, которая, в свою очередь, является главной для подчинённой I</mnt/tmp/etc>."

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:994
msgid ""
"We then B<chroot>(1)  to the I</mnt> directory, which renders the mount with"
" ID 267 unreachable from the (new) root directory:"
msgstr "Теперь выполним B<chroot>(1) в каталог I</mnt>, который делает точку монтирования с ID 267 недоступной из (нового корневого каталога:"

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:998
#, no-wrap
msgid "# B<chroot /mnt>\n"
msgstr "# B<chroot /mnt>\n"

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:1003
msgid ""
"When we examine the state of the mounts inside the chroot-ed environment, we"
" see the following:"
msgstr "Если мы проверим состояние точек монтирования внутри окружения chroot, то увидим следующее:"

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:1010
#, no-wrap
msgid ""
"# B<cat /proc/self/mountinfo | sed \\(aqs/ - .*//\\(aq>\n"
"239 61 8:2 / / ... shared:102\n"
"248 239 0:4 / /proc ... shared:5\n"
"273 239 8:2 /etc /tmp/etc ... master:105 propagate_from:102\n"
msgstr "# B<cat /proc/self/mountinfo | sed \\(aqs/ - .*//\\(aq>\n239 61 8:2 / / ... shared:102\n248 239 0:4 / /proc ... shared:5\n273 239 8:2 /etc /tmp/etc ... master:105 propagate_from:102\n"

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:1025
msgid ""
"Above, we see that the mount with ID 273 is a slave whose master is the peer"
" group 105.  The mount point for that master is unreachable, and so a "
"I<propagate_from> tag is displayed, indicating that the closest dominant "
"peer group (i.e., the nearest reachable mount in the slave chain)  is the "
"peer group with the ID 102 (corresponding to the I</mnt> mount point before "
"the B<chroot>(1)  was performed."
msgstr "Здесь мы видим, что точка монтирования с ID 273 является подчинённой для главной, которая входит в равноправную группу 105. Точка монтирования этой главной недоступна и поэтому появилась метка I<propagate_from>, показывающая, что идентификатор ближайшей ведущей равноправной группы (т. е., ближайшая достижимая точка монтирования в подчинённой цепи) равен 102 (соответствует точке монтирования I</mnt> до выполнения B<chroot>(1))."

#. type: SH
#: man-pages/man7/mount_namespaces.7:1025
#, no-wrap
msgid "VERSIONS"
msgstr "ВЕРСИИ"

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:1027
msgid "Mount namespaces first appeared in Linux 2.4.19."
msgstr "Пространство имён монтирования впервые появилось в Linux 2.4.19."

#. type: SH
#: man-pages/man7/mount_namespaces.7:1027
#, no-wrap
msgid "CONFORMING TO"
msgstr "СООТВЕТСТВИЕ СТАНДАРТАМ"

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:1030
msgid "Namespaces are a Linux-specific feature."
msgstr "Пространства имён есть только в Linux."

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:1040
msgid ""
"The propagation type assigned to a new mount point depends on the "
"propagation type of the parent mount.  If the mount point has a parent "
"(i.e., it is a non-root mount point) and the propagation type of the parent "
"is B<MS_SHARED>, then the propagation type of the new mount is also "
"B<MS_SHARED>.  Otherwise, the propagation type of the new mount is "
"B<MS_PRIVATE>."
msgstr ""

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:1053
msgid ""
"Notwithstanding the fact that the default propagation type for new mount "
"points is in many cases B<MS_PRIVATE>, B<MS_SHARED> is typically more "
"useful.  For this reason, B<systemd>(1)  automatically remounts all mount "
"points as B<MS_SHARED> on system startup.  Thus, on most modern systems, the"
" default propagation type is in practice B<MS_SHARED>."
msgstr "Несмотря на то, что тип распространения по умолчанию для новой точки монтирования во многих случаях равен B<MS_PRIVATE>, обычно, тип B<MS_SHARED> полезнее. По этой причине, при запуске системы B<systemd>(1) автоматически перемонтирует все точки монтирования как B<MS_SHARED>. Таким образом, в современных системах типом распространения по умолчанию практически является B<MS_SHARED>."

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:1068
msgid ""
"Since, when one uses B<unshare>(1)  to create a mount namespace, the goal is"
" commonly to provide full isolation of the mount points in the new "
"namespace, B<unshare>(1)  (since I<util-linux> version 2.27) in turn "
"reverses the step performed by B<systemd>(1), by making all mount points "
"private in the new namespace.  That is, B<unshare>(1)  performs the "
"equivalent of the following in the new mount namespace:"
msgstr "При создании пространства имён монтирования с помощью B<unshare>(1) чаще всего требуется создать полную изоляцию точек монтирования в новом пространстве имён, и B<unshare>(1) (начиная с I<util-linux> версии 2.27) отменяет изменения B<systemd>(1), делая все точки монтирования индивидуальными в новом пространстве имён. То есть B<unshare>(1) в новом пространстве имён монтирования выполняет эквивалент следующего:"

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:1072
#, no-wrap
msgid "mount --make-rprivate /\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:1079
msgid ""
"To prevent this, one can use the I<--propagation\\ unchanged> option to "
"B<unshare>(1)."
msgstr "Чтобы этого не происходило в B<unshare>(1) можно использовать параметр I<--propagation\\ unchanged>."

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:1086
msgid ""
"For a discussion of propagation types when moving mounts (B<MS_MOVE>)  and "
"creating bind mounts (B<MS_BIND>), see "
"I<Documentation/filesystems/sharedsubtree.txt>."
msgstr "Описание типов распространения при перемещении точек монтирования (B<MS_MOVE>) и создании привязок монтирования (B<MS_BIND>) смотрите в I<Documentation/filesystems/sharedsubtree.txt>."

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:1099
msgid ""
"B<unshare>(1), B<clone>(2), B<mount>(2), B<pivot_root>(2), B<setns>(2), "
"B<umount>(2), B<unshare>(2), B<proc>(5), B<namespaces>(7), "
"B<user_namespaces>(7), B<findmnt>(8), B<pivot_root>(8)"
msgstr ""

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:1101
msgid ""
"I<Documentation/filesystems/sharedsubtree.txt> in the kernel source tree."
msgstr "Файл I<Documentation/filesystems/sharedsubtree.txt> в дереве исходного кода ядра Linux."

#. type: TH
#: man-pages/man7/man-pages.7:30
#, no-wrap
msgid "MAN-PAGES"
msgstr "MAN-PAGES"

#. type: Plain text
#: man-pages/man7/man-pages.7:33
msgid "man-pages - conventions for writing Linux man pages"
msgstr "man-pages — правила написания справочных страниц Linux"

#. type: Plain text
#: man-pages/man7/man-pages.7:37
msgid "B<man> [I<section>] I<title>"
msgstr "B<man> [I<раздел>] I<имя>"

#. type: Plain text
#: man-pages/man7/man-pages.7:48
msgid ""
"This page describes the conventions that should be employed when writing man"
" pages for the Linux I<man-pages> project, which documents the user-space "
"API provided by the Linux kernel and the GNU C library.  The project thus "
"provides most of the pages in Section 2, many of the pages that appear in "
"Sections 3, 4, and 7, and a few of the pages that appear in Sections 1, 5, "
"and 8 of the man pages on a Linux system.  The conventions described on this"
" page may also be useful for authors writing man pages for other projects."
msgstr "На этой странице описаны правила, которые необходимо применять при написании справочных страниц для проекта I<man-pages> Linux, который, в свою очередь, документирует программный интерфейс пространства пользователя, предоставляемый ядром Linux и библиотекой GNU C. Таким образом, проект отвечает за большинство страниц из Раздела 2, за многие страницы из Разделов 3, 4, и 7, и за несколько страниц из Разделов 1, 5 и 8 справочной системы Linux. Данные правила также могут быть полезны при написании справочных страниц для других проектов."

#. type: SS
#: man-pages/man7/man-pages.7:48
#, no-wrap
msgid "Sections of the manual pages"
msgstr "Разделы справочных страниц"

#. type: Plain text
#: man-pages/man7/man-pages.7:51
msgid "The manual Sections are traditionally defined as follows:"
msgstr "Традиционно они следующие:"

#. type: TP
#: man-pages/man7/man-pages.7:51
#, no-wrap
msgid "B<1 User commands (Programs)>"
msgstr "B<1 Команды пользователя (Программы)>"

#. type: Plain text
#: man-pages/man7/man-pages.7:55
msgid "Those commands that can be executed by the user from within a shell."
msgstr "Команды, которые пользователь запустить из оболочки."

#. type: TP
#: man-pages/man7/man-pages.7:55
#, no-wrap
msgid "B<2 System calls>"
msgstr "B<2 Системные вызовы>"

#. type: Plain text
#: man-pages/man7/man-pages.7:58
msgid "Those functions which wrap operations performed by the kernel."
msgstr "Функции, являющиеся оберткой операций, выполняемых ядром."

#. type: TP
#: man-pages/man7/man-pages.7:58
#, no-wrap
msgid "B<3 Library calls>"
msgstr "B<3 Библиотечные вызовы>"

#. type: Plain text
#: man-pages/man7/man-pages.7:64
msgid ""
"All library functions excluding the system call wrappers (Most of the "
"I<libc> functions)."
msgstr "Все библиотечные функции (в основном функции I<libc>), за исключением представленных в Разделе 2."

#. type: TP
#: man-pages/man7/man-pages.7:64
#, no-wrap
msgid "B<4 Special files (devices)>"
msgstr "B<4 Специальные файлы (устройства)>"

#. type: Plain text
#: man-pages/man7/man-pages.7:69
msgid ""
"Files found in I</dev> which allow to access to devices through the kernel."
msgstr "Файлы из I</dev>, дающие доступ к устройствам через ядро."

#. type: TP
#: man-pages/man7/man-pages.7:69
#, no-wrap
msgid "B<5 File formats and configuration files>"
msgstr "B<5 Форматы файлов и конфигурационные фалы>"

#. type: Plain text
#: man-pages/man7/man-pages.7:72
msgid "Describes various human-readable file formats and configuration files."
msgstr "Описывает различные подходящие для чтения форматы файлов и конфигурационные файлы."

#. type: TP
#: man-pages/man7/man-pages.7:72
#, no-wrap
msgid "B<6 Games>"
msgstr "B<6 Игры>"

#. type: Plain text
#: man-pages/man7/man-pages.7:75
msgid "Games and funny little programs available on the system."
msgstr "Игры и забавные небольшие программы"

#. type: TP
#: man-pages/man7/man-pages.7:75
#, no-wrap
msgid "B<7 Overview, conventions, and miscellaneous>"
msgstr "B<7 Обзоры, соглашения и разное>"

#. type: Plain text
#: man-pages/man7/man-pages.7:80
msgid ""
"Overviews or descriptions of various topics, conventions and protocols, "
"character set standards, the standard filesystem layout, and miscellaneous "
"other things."
msgstr "Описания или обзоры, касающиеся различных тем, соглашений и протоколов, а также наборов символов, стандартный шаблон файловой системы, разное."

#. type: TP
#: man-pages/man7/man-pages.7:80
#, no-wrap
msgid "B<8 System management commands>"
msgstr "B<8 Команды для системного администрирования>"

#.  .TP
#.  .B 9 Kernel routines
#.  This is an obsolete manual section.
#.  Once it was thought a good idea to document the Linux kernel here,
#.  but in fact very little has been documented, and the documentation
#.  that exists is outdated already.
#.  There are better sources of
#.  information for kernel developers.
#. type: Plain text
#: man-pages/man7/man-pages.7:93
msgid "Commands like B<mount>(8), many of which only root can execute."
msgstr "Команды подобные B<mount>(8), большинство из которых могут запускаться только суперпользователем."

#. type: SS
#: man-pages/man7/man-pages.7:93
#, no-wrap
msgid "Macro package"
msgstr "Пакет макросов"

#. type: Plain text
#: man-pages/man7/man-pages.7:100
msgid ""
"New manual pages should be marked up using the B<groff an.tmac> package "
"described in B<man>(7).  This choice is mainly for consistency: the vast "
"majority of existing Linux manual pages are marked up using these macros."
msgstr "Новые справочные страницы должны размечаться с помощью пакета B<groff an.tmac>, описанного в B<man>(7). Данный выбор основан, в основном, на том, что большинство из существующих страниц Linux размечены с помощью этих макросов."

#. type: SS
#: man-pages/man7/man-pages.7:100
#, no-wrap
msgid "Conventions for source file layout"
msgstr "Правила, касающиеся формата исходных файлов"

#. type: Plain text
#: man-pages/man7/man-pages.7:105
msgid ""
"Please limit source code line length to no more than about 75 characters "
"wherever possible.  This helps avoid line-wrapping in some mail clients when"
" patches are submitted inline."
msgstr "Длина строки не должна превышать 75 символов. В некоторых почтовых клиентах это помогает избежать переноса строк в заплатах, встроенные в письмо."

#. type: Plain text
#: man-pages/man7/man-pages.7:109
msgid ""
"New sentences should be started on new lines.  This makes it easier to see "
"the effect of patches, which often operate at the level of individual "
"sentences."
msgstr "Новые операторы — с новой строки. Это облегчает возможность просмотра изменений после применения заплат, которые зачастую изменяют отдельные строки кода."

#. type: SS
#: man-pages/man7/man-pages.7:109
#, no-wrap
msgid "Title line"
msgstr "Заголовок"

#. type: Plain text
#: man-pages/man7/man-pages.7:113
msgid "The first command in a man page should be a B<TH> command:"
msgstr "Первой должна быть команда B<TH>:"

#. type: Plain text
#: man-pages/man7/man-pages.7:117
msgid "B<\\&.TH> I<title section date source manual>"
msgstr "B<\\&.TH> I<заголовок раздел дата источник справочник>"

#. type: Plain text
#: man-pages/man7/man-pages.7:120
msgid "where:"
msgstr "где:"

#. type: TP
#: man-pages/man7/man-pages.7:121
#, no-wrap
msgid "I<title>"
msgstr "I<заголовок>"

#. type: Plain text
#: man-pages/man7/man-pages.7:125
msgid "The title of the man page, written in all caps (e.g., I<MAN-PAGES>)."
msgstr "Название страницы, написанное заглавными буквами (например I<MAN-PAGES>)."

#. type: TP
#: man-pages/man7/man-pages.7:125
#, no-wrap
msgid "I<section>"
msgstr "I<раздел>"

#. type: Plain text
#: man-pages/man7/man-pages.7:129
msgid ""
"The section number in which the man page should be placed (e.g., I<7>)."
msgstr "Номер раздела для размещения страницы (например I<7>)."

#. type: TP
#: man-pages/man7/man-pages.7:129
#, no-wrap
msgid "I<date>"
msgstr "I<дата>"

#. type: Plain text
#: man-pages/man7/man-pages.7:138
msgid ""
"The date of the last nontrivial change that was made to the man page.  "
"(Within the I<man-pages> project, the necessary updates to these timestamps "
"are handled automatically by scripts, so there is no need to manually update"
" them as part of a patch.)  Dates should be written in the form YYYY-MM-DD."
msgstr "Дата последнего значительного изменения справочной страницы (в проекте I<man-pages> необходимые обновления временных отметок выполняются автоматически при помощи сценариев, вручную устанавливать её заплатой не нужно). Дата должна иметь вид YYYY-MM-DD, т. е. год-месяц-день."

#. type: TP
#: man-pages/man7/man-pages.7:138
#, no-wrap
msgid "I<source>"
msgstr "I<источник>"

#. type: Plain text
#: man-pages/man7/man-pages.7:141
msgid "The source of the command, function, or system call."
msgstr "Источник команды, функции, системного вызова."

#. type: Plain text
#: man-pages/man7/man-pages.7:145
msgid ""
"For those few I<man-pages> pages in Sections 1 and 8, probably you just want"
" to write I<GNU>."
msgstr "Для нескольких страниц I<man-pages> в Разделах 1 и 8, можно написать I<GNU>."

#. type: Plain text
#: man-pages/man7/man-pages.7:153
msgid ""
"For system calls, just write I<Linux>.  (An earlier practice was to write "
"the version number of the kernel from which the manual page was being "
"written/checked.  However, this was never done consistently, and so was "
"probably worse than including no version number.  Henceforth, avoid "
"including a version number.)"
msgstr "Для системных вызовов — I<Linux>. (Ранее, стандартной практикой было писать версию ядра, используя которую был написана или проверена страница. Это никогда не было общепринятым. Так что не делайте этого)."

#. type: Plain text
#: man-pages/man7/man-pages.7:158
msgid ""
"For library calls that are part of glibc or one of the other common GNU "
"libraries, just use I<GNU C Library>, I<GNU>, or an empty string."
msgstr "Для библиотечных вызовов, являющихся частью glibc или других библиотек GNU — I<GNU C Library>, I<GNU>, или пустую строку."

#. type: Plain text
#: man-pages/man7/man-pages.7:161
msgid "For Section 4 pages, use I<Linux>."
msgstr "Для страниц из Раздела 4 — I<Linux>."

#. type: Plain text
#: man-pages/man7/man-pages.7:164
msgid "In cases of doubt, just write I<Linux>, or I<GNU>."
msgstr "Если возникают сомнения — I<Linux> или I<GNU>."

#. type: TP
#: man-pages/man7/man-pages.7:164
#, no-wrap
msgid "I<manual>"
msgstr "I<справочник>"

#. type: Plain text
#: man-pages/man7/man-pages.7:169
msgid ""
"The title of the manual (e.g., for Section 2 and 3 pages in the I<man-pages>"
" package, use I<Linux Programmer's Manual>)."
msgstr "Название справочника (например для Разделов 2, 3 в пакете I<man-pages> — I<Linux Programmer's Manual>)."

#. type: SS
#: man-pages/man7/man-pages.7:170
#, no-wrap
msgid "Sections within a manual page"
msgstr "Разделы внутри справочной страницы"

#. type: Plain text
#: man-pages/man7/man-pages.7:177
msgid ""
"The list below shows conventional or suggested sections.  Most manual pages "
"should include at least the B<highlighted> sections.  Arrange a new manual "
"page so that sections are placed in the order shown in the list."
msgstr "Следующий список содержит общепринятые и рекомендуемые разделы. Большинство справочных страниц должно включать в себя по крайней мере B<выделенные жирным> разделы. Соблюдайте очередность, как показано в списке."

#.  May 07: Few current man pages have an ERROR HANDLING section,,,
#.  ERROR HANDLING,
#.  May 07: Almost no current man pages have a USAGE section,,,
#.  USAGE,
#.  DIAGNOSTICS,
#.  May 07: Almost no current man pages have a SECURITY section,,,
#.  SECURITY,
#.  AUTHORS sections are discouraged
#.  AUTHORS             [Discouraged]
#. type: Plain text
#: man-pages/man7/man-pages.7:206
#, no-wrap
msgid ""
"B<NAME>\n"
"B<SYNOPSIS>\n"
"CONFIGURATION      [Normally only in Section 4]\n"
"B<DESCRIPTION>\n"
"OPTIONS            [Normally only in Sections 1, 8]\n"
"EXIT STATUS        [Normally only in Sections 1, 8]\n"
"RETURN VALUE       [Normally only in Sections 2, 3]\n"
"ERRORS             [Typically only in Sections 2, 3]\n"
"ENVIRONMENT\n"
"FILES\n"
"VERSIONS           [Normally only in Sections 2, 3]\n"
"ATTRIBUTES         [Normally only in Sections 2, 3]\n"
"CONFORMING TO\n"
"NOTES\n"
"BUGS\n"
"EXAMPLE\n"
"B<SEE ALSO>\n"
msgstr "B<ИМЯ>\nB<ОБЗОР>\nКОНФИГУРАЦИЯ             [Как правило, только в разделе 4]\nB<ОПИСАНИЕ>\nПАРАМЕТРЫ                [Как правило, только в разделах 1, 8]\nКОД ВЫХОДА               [Как правило, только в разделах 1, 8]\nВОЗВРАЩАЕМЫЕ ЗНАЧЕНИЯ    [Как правило, только в разделах 2, 3]\nОШИБКИ                   [Обычно только в разделах 2, 3]\nОКРУЖЕНИЕ\nФАЙЛЫ\nВЕРСИИ                   [Как правило, только в разделах 2, 3]\nАТРИБУТЫ                 [Как правило, только в разделах 2, 3]\nСООТВЕТСТВИЕ СТАНДАРТАМ\nЗАМЕЧАНИЯ\nДЕФЕКТЫ\nПРИМЕРЫ\nB<СМОТРИ ТАКЖЕ>\n"

#. type: Plain text
#: man-pages/man7/man-pages.7:217
msgid ""
"I<Where a traditional heading would apply>, I<please use it>; this kind of "
"consistency can make the information easier to understand.  If you must, you"
" can create your own headings if they make things easier to understand (this"
" can be especially useful for pages in Sections 4 and 5).  However, before "
"doing this, consider whether you could use the traditional headings, with "
"some subsections (I<.SS>) within those sections."
msgstr "I<Там, где обычно используются заголовки>, I<используйте их>;  это правило может сделать информацию более доступной для понимания. Если это необходимо, Вы можете создать свои собственные заголовки, если они сделают текст более понятным (это может быть особенно полезным для страниц в разделах 4 и 5).  Тем не менее, прежде чем создавать их, подумайте, можно ли обойтись традиционными заголовками с созданием своих собственных подразделов (I<.SS>) в пределах стандартных разделов."

#. type: Plain text
#: man-pages/man7/man-pages.7:220
msgid ""
"The following list elaborates on the contents of each of the above sections."
msgstr "В приведённом ниже списке объясняется назначение каждого из разделов."

#. type: TP
#: man-pages/man7/man-pages.7:220
#, no-wrap
msgid "B<NAME>"
msgstr "B<ИМЯ>"

#. type: Plain text
#: man-pages/man7/man-pages.7:223
msgid "The name of this manual page."
msgstr "Название данной справочной страниц."

#. type: Plain text
#: man-pages/man7/man-pages.7:232
msgid ""
"See B<man>(7)  for important details of the line(s) that should follow the "
"B<.SH NAME> command.  All words in this line (including the word immediately"
" following the \"\\e-\") should be in lowercase, except where English or "
"technical terminological convention dictates otherwise."
msgstr "Смотрите B<man>(7), чтобы ознакомиться с правилами написания заголовков, которые должны следовать за командой B<.SH NAME>. Все слова в этой строке (в том числе идущие сразу после «\\e-») должны быть в нижнем регистре, за исключением тех случаев, когда правилами языка, на котором написана страница, или сложившейся практикой употребления технических терминов определено иное."

#. type: TP
#: man-pages/man7/man-pages.7:232
#, no-wrap
msgid "B<SYNOPSIS>"
msgstr "B<ОБЗОР>"

#. type: Plain text
#: man-pages/man7/man-pages.7:235
msgid "A brief summary of the command or function's interface."
msgstr "Краткое описание команды или интерфейса функции"

#. type: Plain text
#: man-pages/man7/man-pages.7:245
msgid ""
"For commands, this shows the syntax of the command and its arguments "
"(including options); boldface is used for as-is text and italics are used to"
" indicate replaceable arguments.  Brackets ([]) surround optional arguments,"
" vertical bars (|)  separate choices, and ellipses (\\&...) can be repeated."
"  For functions, it shows any required data declarations or B<#include> "
"directives, followed by the function declaration."
msgstr "Для команд здесь показываются синтаксис и аргументы (включая параметры); полужирное начертание используется для неизменяемого текста, а курсивом обозначаются меняющиеся аргументы. Квадратные скобки ([]) показывают необязательные аргументы, вертикальная черта (|) указывает на выбор одного из вариантов, многоточие (\\&...) означает возможное повторение. Для функций показываются все необходимые объявления данных или B<#include> директивы с последующим объявлением функции."

#.  FIXME . Say something here about compiler options
#. type: Plain text
#: man-pages/man7/man-pages.7:251
msgid ""
"Where a feature test macro must be defined in order to obtain the "
"declaration of a function (or a variable) from a header file, then the "
"SYNOPSIS should indicate this, as described in B<feature_test_macros>(7)."
msgstr "Если для получения объявления функции (или переменной) из заголовочного файла требуется определить макрос тестирования свойств, то это указывается в ОБЗОРЕ согласно описанию из B<feature_test_macros>(7)."

#. type: TP
#: man-pages/man7/man-pages.7:251
#, no-wrap
msgid "B<CONFIGURATION>"
msgstr "B<КОНФИГУРАЦИЯ>"

#. type: Plain text
#: man-pages/man7/man-pages.7:254
msgid "Configuration details for a device."
msgstr "Особенности настройки устройства"

#. type: Plain text
#: man-pages/man7/man-pages.7:256
msgid "This section normally appears only in Section 4 pages."
msgstr "Этот раздел, как правило, присутствует только в разделе 4."

#. type: TP
#: man-pages/man7/man-pages.7:256
#, no-wrap
msgid "B<DESCRIPTION>"
msgstr "B<ОПИСАНИЕ>"

#. type: Plain text
#: man-pages/man7/man-pages.7:259
msgid "An explanation of what the program, function, or format does."
msgstr "Объяснение того, для чего предназначена программа, функция или формат"

#.  If there is some kind of input grammar or complex set of subcommands,
#.  consider describing them in a separate
#.  .B USAGE
#.  section (and just place an overview in the
#.  .B DESCRIPTION
#.  section).
#. type: Plain text
#: man-pages/man7/man-pages.7:274
msgid ""
"Discuss how it interacts with files and standard input, and what it produces"
" on standard output or standard error.  Omit internals and implementation "
"details unless they're critical for understanding the interface.  Describe "
"the usual case; for information on command-line options of a program use the"
" B<OPTIONS> section."
msgstr "Здесь описывается взаимодействие с файлами и стандартным вводом, и что записывается в стандартный вывода вывод или ошибок; не приводятся детали реализации, если они не критичны для понимания интерфейса; показывается типичное использование; информация о параметрах командной строки программы даётся в разделе B<OPTIONS>."

#. type: Plain text
#: man-pages/man7/man-pages.7:282
msgid ""
"When describing new behavior or new flags for a system call or library "
"function, be careful to note the kernel or C library version that introduced"
" the change.  The preferred method of noting this information for flags is "
"as part of a B<.TP> list, in the following form (here, for a new system call"
" flag):"
msgstr "Если описывается новое поведение или новые флаги системного вызова или библиотечной функции, отметьте где введено изменение — версию ядра или библиотеки С. Данную информацию целесообразно приводить в виде части списка B<.TP> в следующем виде (здесь показан новый флаг системного вызова):"

#. type: TP
#: man-pages/man7/man-pages.7:283
#, no-wrap
msgid "B<XYZ_FLAG> (since Linux 3.7)"
msgstr "B<XYZ_FLAG> (начиная с Linux 3.7)"

#. type: Plain text
#: man-pages/man7/man-pages.7:286
msgid "Description of flag..."
msgstr "Описание флагов…"

#. type: Plain text
#: man-pages/man7/man-pages.7:291
msgid ""
"Including version information is especially useful to users who are "
"constrained to using older kernel or C library versions (which is typical in"
" embedded systems, for example)."
msgstr "Включает информацию о версии, что особенно востребовано пользователями, которые вынуждены использовать старые версии ядра или библиотеки C (что характерно, например, для встраиваемых систем). "

#. type: TP
#: man-pages/man7/man-pages.7:291
#, no-wrap
msgid "B<OPTIONS>"
msgstr "B<ПАРАМЕТРЫ>"

#. type: Plain text
#: man-pages/man7/man-pages.7:295
msgid ""
"A description of the command-line options accepted by a program and how they"
" change its behavior."
msgstr "Описание параметров командной строки и их влияния на поведение программы."

#. type: Plain text
#: man-pages/man7/man-pages.7:300 man-pages/man7/man-pages.7:306
msgid "This section should appear only for Section 1 and 8 manual pages."
msgstr "Этот раздел как правило содержится только в разделах 1 и 8."

#. type: TP
#: man-pages/man7/man-pages.7:300
#, no-wrap
msgid "B<EXIT STATUS>"
msgstr "B<КОД ВЫХОДА>"

#. type: Plain text
#: man-pages/man7/man-pages.7:304
msgid ""
"A list of the possible exit status values of a program and the conditions "
"that cause these values to be returned."
msgstr "Перечень возможных значений кода выхода программы и ситуаций, при которых программа возвращает данное значение кода."

#. type: TP
#: man-pages/man7/man-pages.7:306
#, no-wrap
msgid "B<RETURN VALUE>"
msgstr "B<ВОЗВРАЩАЕМЫЕ ЗНАЧЕНИЯ>"

#. type: Plain text
#: man-pages/man7/man-pages.7:311
msgid ""
"For Section 2 and 3 pages, this section gives a list of the values the "
"library routine will return to the caller and the conditions that cause "
"these values to be returned."
msgstr "Для разделов 2 и 3 эта секция содержит перечень значений, возвращаемых библиотеками вызывающей их программе и условия, при которых библиотеки возвращают данные значения."

#. type: TP
#: man-pages/man7/man-pages.7:311
#, no-wrap
msgid "B<ERRORS>"
msgstr "B<ОШИБКИ>"

#. type: Plain text
#: man-pages/man7/man-pages.7:318
msgid ""
"For Section 2 and 3 manual pages, this is a list of the values that may be "
"placed in I<errno> in the event of an error, along with information about "
"the cause of the errors."
msgstr "В справочных страницах разделов 2 и 3 здесь описываются значения ошибок, которые могут быть помещены в I<errno>, а также приводится описание причин ошибок."

#. type: Plain text
#: man-pages/man7/man-pages.7:326
msgid ""
"Where several different conditions produce the same error, the preferred "
"approach is to create separate list entries (with duplicate error names) for"
" each of the conditions.  This makes the separate conditions clear, may make"
" the list easier to read, and allows metainformation (e.g., kernel version "
"number where the condition first became applicable)  to be more easily "
"marked for each condition."
msgstr "Если ошибка возникает при нескольких различных условиях, предпочтительней создавать отдельные записи списка (с повторением имени ошибки) для каждого из условий. Такое разделение делает условия более понятными, этот список проще читать и можно указывать метаинформацию (например, номер версии ядра, в котором условие начало действовать) на каждое условие."

#. type: Plain text
#: man-pages/man7/man-pages.7:328
msgid "I<The error list should be in alphabetical order>."
msgstr "I<Список ошибок должен быть в алфавитном порядке>."

#. type: TP
#: man-pages/man7/man-pages.7:328
#, no-wrap
msgid "B<ENVIRONMENT>"
msgstr "B<ОКРУЖЕНИЕ>"

#. type: Plain text
#: man-pages/man7/man-pages.7:332
msgid ""
"A list of all environment variables that affect the program or function and "
"how they affect it."
msgstr "Перечень переменных окружения, влияющих на программу и оказываемый ими эффект."

#. type: TP
#: man-pages/man7/man-pages.7:332
#, no-wrap
msgid "B<FILES>"
msgstr "B<ФАЙЛЫ>"

#. type: Plain text
#: man-pages/man7/man-pages.7:337
msgid ""
"A list of the files the program or function uses, such as configuration "
"files, startup files, and files the program directly operates on."
msgstr "Список файлов, используемых программой или функцией, таких как конфигурационные файлы, файлы запуска и файлы, с которыми непосредственно работает программа."

#.  May 07: Almost no current man pages have a DIAGNOSTICS section;
#.          "RETURN VALUE" or "EXIT STATUS" is preferred.
#.  .TP
#.  .B DIAGNOSTICS
#.  gives an overview of the most common error messages and how to
#.  cope with them.
#.  You don't need to explain system error messages
#.  or fatal signals that can appear during execution of any program
#.  unless they're special in some way to the program.
#.  May 07: Almost no current man pages have a SECURITY section.
#. .TP
#. .B SECURITY
#. discusses security issues and implications.
#. Warn about configurations or environments that should be avoided,
#. commands that may have security implications, and so on, especially
#. if they aren't obvious.
#. Discussing security in a separate section isn't necessary;
#. if it's easier to understand, place security information in the
#. other sections (such as the
#.  .B DESCRIPTION
#.  or
#.  .B USAGE
#.  section).
#.  However, please include security information somewhere!
#. type: Plain text
#: man-pages/man7/man-pages.7:370
msgid ""
"Give the full pathname of these files, and use the installation process to "
"modify the directory part to match user preferences.  For many programs, the"
" default installation location is in I</usr/local>, so your base manual page"
" should use I</usr/local> as the base."
msgstr "Указывайте полный путь к этим файлам, также используйте возможность изменить во время установки изменить путь в соответствии с предпочтениями пользователя."

#. type: TP
#: man-pages/man7/man-pages.7:370
#, no-wrap
msgid "B<ATTRIBUTES>"
msgstr "B<АТРИБУТЫ>"

#. type: Plain text
#: man-pages/man7/man-pages.7:376
msgid ""
"A summary of various attributes of the function(s) documented on this page."
"  See B<attributes>(7)  for further details."
msgstr "Общая информация о различных атрибутах функции(функций), описанной на этой странице. Смотри B<attributes>(7) для получения дополнительных сведений."

#. type: TP
#: man-pages/man7/man-pages.7:376
#, no-wrap
msgid "B<VERSIONS>"
msgstr "B<ВЕРСИИ>"

#. type: Plain text
#: man-pages/man7/man-pages.7:381
msgid ""
"A brief summary of the Linux kernel or glibc versions where a system call or"
" library function appeared, or changed significantly in its operation."
msgstr "Краткое описание ядра Linux или версии glibc, где впервые появился системный вызов или функция библиотеки, либо существенно изменилось их действие."

#. type: Plain text
#: man-pages/man7/man-pages.7:394
msgid ""
"As a general rule, every new interface should include a VERSIONS section in "
"its manual page.  Unfortunately, many existing manual pages don't include "
"this information (since there was no policy to do so when they were "
"written).  Patches to remedy this are welcome, but, from the perspective of "
"programmers writing new code, this information probably matters only in the "
"case of kernel interfaces that have been added in Linux 2.4 or later (i.e., "
"changes since kernel 2.2), and library functions that have been added to "
"glibc since version 2.1 (i.e., changes since glibc 2.0)."
msgstr "Как правило, описание каждого нового интерфейса должно включать раздел ВЕРСИИ в справочной странице. К сожалению, в многих справочных страницах эта информация отсутствует (когда они были написаны, не было правила, предписывающего делать это). Заплаты, исправляющие подобные недостатки, приветствуются, но, с точки зрения программистов, пишущих новый код, эта информация, вероятно, имеет значение только в том случае, если интерфейсы ядра были добавлены в Linux 2.4 или позже (т. е., отличаются от ядра 2.2), а для библиотечных функций, если изменения были добавлены начиная с glibc версии 2.1 (т. е., отличаются от glibc 2.0). "

#. type: Plain text
#: man-pages/man7/man-pages.7:399
msgid ""
"The B<syscalls>(2)  manual page also provides information about kernel "
"versions in which various system calls first appeared."
msgstr "Справочная страница B<syscalls>(2) также содержит информацию о версиях ядра, в которых были впервые реализованы различные системные вызовы."

#. type: TP
#: man-pages/man7/man-pages.7:399
#, no-wrap
msgid "B<CONFORMING TO>"
msgstr "B<СООТВЕТСТВИЕ СТАНДАРТАМ>"

#. type: Plain text
#: man-pages/man7/man-pages.7:403
msgid ""
"A description of any standards or conventions that relate to the function or"
" command described by the manual page."
msgstr "Описание любых стандартов или соглашений, относящихся к функции или команде, речь о которой идет на странице."

#. type: Plain text
#: man-pages/man7/man-pages.7:407
msgid ""
"The preferred terms to use for the various standards are listed as headings "
"in B<standards>(7)."
msgstr "Предпочтительные обозначения для различных стандартов указаны в качестве заголовков на странице B<standards>(7)."

#. type: Plain text
#: man-pages/man7/man-pages.7:416
msgid ""
"For a page in Section 2 or 3, this section should note the POSIX.1 "
"version(s) that the call conforms to, and also whether the call is specified"
" in C99.  (Don't worry too much about other standards like SUS, SUSv2, and "
"XPG, or the SVr4 and 4.xBSD implementation standards, unless the call was "
"specified in those standards, but isn't in the current version of POSIX.1.)"
msgstr "Для страницы из раздела 2 или 3, данный раздел должен показывать версию POSIX.1, которой соответствует вызов, а также есть ли вызов в C99 (наличие в других стандартах, таких как SUS, SUSv2 и XPG, или реализациях стандартов SVr4 и 4.xBSD, не важно; если вызов был в этих стандартах, но отсутствует в текущей версии POSIX.1, то это стоит упомянуть)."

#. type: Plain text
#: man-pages/man7/man-pages.7:420
msgid ""
"If the call is not governed by any standards but commonly exists on other "
"systems, note them.  If the call is Linux-specific, note this."
msgstr "Если вызов не соответствует какому-либо стандарту, но существует во многих системах, также упомяните об этом. Если вызов есть только в Linux, то это также стоит отметить."

#. type: Plain text
#: man-pages/man7/man-pages.7:424
msgid ""
"If this section consists of just a list of standards (which it commonly "
"does), terminate the list with a period (\\(aq.\\(aq)."
msgstr "Если данный раздел состоит только из списка стандартов (что, обычно, и есть), завершите список точкой (\\(aq.\\(aq)."

#. type: TP
#: man-pages/man7/man-pages.7:424
#, no-wrap
msgid "B<NOTES>"
msgstr "B<ЗАМЕЧАНИЯ>"

#. type: Plain text
#: man-pages/man7/man-pages.7:427
msgid "Miscellaneous notes."
msgstr "Различные замечания."

#. type: Plain text
#: man-pages/man7/man-pages.7:430
msgid ""
"For Section 2 and 3 man pages you may find it useful to include subsections "
"(B<SS>) named I<Linux Notes> and I<Glibc Notes>."
msgstr "Для разделов 2 и 3 может быть полезным создание подразделов (B<SS>), озаглавленных I<Примечания для Linux> и I<Примечания для Glibc>."

#. type: Plain text
#: man-pages/man7/man-pages.7:436
msgid ""
"In Section 2, use the heading I<C library/kernel differences> to mark off "
"notes that describe the differences (if any) between the C library wrapper "
"function for a system call and the raw system call interface provided by the"
" kernel."
msgstr "В разделе 2 используйте заголовок I<Различия между ядром и библиотекой С>, чтобы отметить различия (если имеются) между  системными вызовами функций библиотеки и ядра."

#. type: TP
#: man-pages/man7/man-pages.7:436
#, no-wrap
msgid "B<BUGS>"
msgstr "B<ДЕФЕКТЫ>"

#. type: Plain text
#: man-pages/man7/man-pages.7:440
msgid ""
"A list of limitations, known defects or inconveniences, and other "
"questionable activities."
msgstr "Перечень известных ошибок, ограничений, недостатков причиняющих неудобство а также других сомнительных свойств."

#. type: TP
#: man-pages/man7/man-pages.7:440
#, no-wrap
msgid "B<EXAMPLE>"
msgstr "B<ПРИМЕРЫ>"

#. type: Plain text
#: man-pages/man7/man-pages.7:444
msgid ""
"One or more examples demonstrating how this function, file or command is "
"used."
msgstr "Один или несколько примеров, демонстрирующих, каким образом данная функция, команда или файл используются."

#. type: Plain text
#: man-pages/man7/man-pages.7:447
msgid ""
"For details on writing example programs, see I<Example programs> below."
msgstr "Для получения более подробной информации о написании примеров программ смотрите раздел I<Примеры программ> далее."

#. type: TP
#: man-pages/man7/man-pages.7:447
#, no-wrap
msgid "B<AUTHORS>"
msgstr "B<АВТОРЫ>"

#. type: Plain text
#: man-pages/man7/man-pages.7:450
msgid "A list of authors of the documentation or program."
msgstr "Список авторов документа или программы."

#. type: Plain text
#: man-pages/man7/man-pages.7:458
msgid ""
"B<Use of an AUTHORS section is strongly discouraged>.  Generally, it is "
"better not to clutter every page with a list of (over time potentially "
"numerous) authors; if you write or significantly amend a page, add a "
"copyright notice as a comment in the source file.  If you are the author of "
"a device driver and want to include an address for reporting bugs, place "
"this under the BUGS section."
msgstr "B<Использовать раздел АВТОРЫ настоятельно не рекомендуется>. Лучше не загромождать каждую страницу списком  авторов (список со временем увеличивается); если вы написали или значительно исправили страницу, добавьте уведомление об авторском праве в виде комментария в исходный файл. Если вы автор драйвера устройства и хотите включить адрес для отправки сообщений об ошибках, то сделайте это в разделе ДЕФЕКТЫ."

#. type: TP
#: man-pages/man7/man-pages.7:458
#, no-wrap
msgid "B<SEE ALSO>"
msgstr "B<СМОТРИ ТАКЖЕ>"

#. type: Plain text
#: man-pages/man7/man-pages.7:462
msgid ""
"A comma-separated list of related man pages, possibly followed by other "
"related pages or documents."
msgstr "Разделённый запятыми список уместных справочных страниц, возможно, ведущих на другие страницы или документы."

#. type: Plain text
#: man-pages/man7/man-pages.7:466
msgid ""
"The list should be ordered by section number and then alphabetically by "
"name.  Do not terminate this list with a period."
msgstr "Список должен быть упорядочен по номеру раздела, а затем по алфавиту. Не заканчивайте список точкой."

#. type: Plain text
#: man-pages/man7/man-pages.7:477
msgid ""
"Where the SEE ALSO list contains many long manual page names, to improve the"
" visual result of the output, it may be useful to employ the I<.ad l> (don't"
" right justify)  and I<.nh> (don't hyphenate)  directives.  Hyphenation of "
"individual page names can be prevented by preceding words with the string "
"\"\\e%\"."
msgstr "Если список B<СМОТРИТЕ ТАКЖЕ> содержит много длинных имён справочных страниц, то для улучшения визуального представления может быть полезно воспользоваться командами I<.ad l> (не выравнивать по правому краю) и I<.nh> (отключить перенос). Запретить перенос имён справочных страниц можно с помощью указания перед словом строки «\\e%»."

#. type: Plain text
#: man-pages/man7/man-pages.7:482
msgid ""
"Given the distributed, autonomous nature of FOSS projects and their "
"documentation, it is sometimes necessary\\(emand in many cases "
"desirable\\(emthat the SEE ALSO section includes references to manual pages "
"provided by other projects."
msgstr "Учитывая распределённую, автономную природу проектов FOSS и их документирование, иногда необходимо — и во многих случаях желательно — включать в раздел B<СМОТРИТЕ ТАКЖЕ> ссылки на справочные страницы из других проектов."

#. type: SH
#: man-pages/man7/man-pages.7:482
#, no-wrap
msgid "STYLE GUIDE"
msgstr "РУКОВОДСТВО ПО СТИЛЮ ОФОРМЛЕНИЯ"

#. type: Plain text
#: man-pages/man7/man-pages.7:489
msgid ""
"The following subsections describe the preferred style for the I<man-pages> "
"project.  For details not covered below, the Chicago Manual of Style is "
"usually a good source; try also grepping for preexisting usage in the "
"project source tree."
msgstr "В следующих абзацах представлен предпочтительный стиль написания страница в проекте I<man-pages>. Если что-то не описано подробно, то следует придерживаться чикагского стилистического справочника (Chicago Manual of Style); также постарайтесь поискать схожие примеры в исходном коде дерева проекта."

#. type: SS
#: man-pages/man7/man-pages.7:489
#, no-wrap
msgid "Use of gender-neutral language"
msgstr "Использование гендерно-нейтральных выражений"

#. type: Plain text
#: man-pages/man7/man-pages.7:495
msgid ""
"As far as possible, use gender-neutral language in the text of man pages.  "
"Use of \"they\" (\"them\", \"themself\", \"their\") as a gender-neutral "
"singular pronoun is acceptable."
msgstr "Используйте гендерно-нейтральный язык в тексте справочных страниц насколько это возможно. Приемлемо использовать местоимения «они» («им», «себя», «их»)."

#. type: SS
#: man-pages/man7/man-pages.7:495
#, no-wrap
msgid "Formatting conventions for manual pages describing commands"
msgstr "Соглашения о форматировании справочных страниц, описывающих команды"

#. type: Plain text
#: man-pages/man7/man-pages.7:500
msgid ""
"For manual pages that describe a command (typically in Sections 1 and 8), "
"the arguments are always specified using italics, I<even in the SYNOPSIS "
"section>."
msgstr "Для справочных страниц, описывающих команду (как правило в разделах 1 и 8), аргументы всегда указываются с помощью курсива, I<даже в разделе ОБЗОР>."

#. type: Plain text
#: man-pages/man7/man-pages.7:504
msgid ""
"The name of the command, and its options, should always be formatted in "
"bold."
msgstr "Имя команд и их опции, всегда должны быть оформленными полужирным стилем."

#. type: SS
#: man-pages/man7/man-pages.7:504
#, no-wrap
msgid "Formatting conventions for manual pages describing functions"
msgstr "Соглашения по оформлению справочных страниц, описывающих функции"

#. type: Plain text
#: man-pages/man7/man-pages.7:509
msgid ""
"For manual pages that describe functions (typically in Sections 2 and 3), "
"the arguments are always specified using italics, I<even in the SYNOPSIS "
"section>, where the rest of the function is specified in bold:"
msgstr "В справочных страницах, которые описывают функции (обычно, в разделах 2 и 3), параметры всегда оформляются, используя курсив;  I<даже в разделе ОБЗОР>, где остальная часть функции определена полужирным:"

#. type: Plain text
#: man-pages/man7/man-pages.7:511
msgid "B< int myfunction(int >I<argc>B<, char **>I<argv>B<);>"
msgstr "B< int имя_функции(int >I<argc>B<, char **>I<argv>B<);>"

#. type: Plain text
#: man-pages/man7/man-pages.7:513
msgid "Variable names should, like argument names, be specified in italics."
msgstr "Имена переменных, как и имена параметров, должны быть оформлены курсивом."

#. type: Plain text
#: man-pages/man7/man-pages.7:522
msgid ""
"Any reference to the subject of the current manual page should be written "
"with the name in bold followed by a pair of parentheses in Roman (normal) "
"font.  For example, in the B<fcntl>(2)  man page, references to the subject "
"of the page would be written as: B<fcntl>().  The preferred way to write "
"this in the source file is:"
msgstr "Любая ссылка на тему текущей справочной страницы должна быть записана с именем оформленным полужирным, включая пару круглых скобок, в прямом(нормальном) шрифте. Например, на странице B<fcntl>(2), ссылки на тему страницы были бы записаны как: B<fcntl>(). Рекомендуемый способ записи в исходном файле:"

#. type: Plain text
#: man-pages/man7/man-pages.7:525
#, no-wrap
msgid "    .BR fcntl ()\n"
msgstr "    .BR fcntl ()\n"

#. type: Plain text
#: man-pages/man7/man-pages.7:530
msgid ""
"(Using this format, rather than the use of \"\\efB...\\efP()\" makes it "
"easier to write tools that parse man page source files.)"
msgstr "(используйте этот формат вместо б\\efB...\\efP ()» — такой подход упрощает создание инструментов разбора исходных файлов справочных страниц)"

#. type: SS
#: man-pages/man7/man-pages.7:530
#, no-wrap
msgid "Formatting conventions (general)"
msgstr "Общие соглашения по оформлению"

#. type: Plain text
#: man-pages/man7/man-pages.7:540
msgid ""
"Filenames (whether pathnames, or references to header files)  are always in "
"italics (e.g., I<E<lt>stdio.hE<gt>>), except in the SYNOPSIS section, where "
"included files are in bold (e.g., B<#include E<lt>stdio.hE<gt>>).  When "
"referring to a standard header file include, specify the header file "
"surrounded by angle brackets, in the usual C way (e.g., "
"I<E<lt>stdio.hE<gt>>)."
msgstr "Имена файлов (также пути или ссылки на заголовочные файлы) всегда должны быть оформлены курсивом (например, I<E<lt>stdio.hE<gt>>), кроме раздела ОБЗОР, где включаемые файлы должны быть полужирным (например, B<#include E<lt>stdio.hE<gt>>). Тут ссылка на стандартный заголовочный файл включает имя заголовочного файл, окружённого угловыми скобками, это типично для C (например, I<E<lt>stdio.hE<gt>>)."

#. type: Plain text
#: man-pages/man7/man-pages.7:544
msgid ""
"Special macros, which are usually in uppercase, are in bold (e.g., "
"B<MAXINT>).  Exception: don't boldface NULL."
msgstr "Специальные макросы, которые обычно находятся в верхнем регистре, оформляют полужирным (например, B<MAXINT>). Исключение: не делайте полужирным NULL."

#. type: Plain text
#: man-pages/man7/man-pages.7:549
msgid ""
"When enumerating a list of error codes, the codes are in bold (this list "
"usually uses the B<\\&.TP> macro)."
msgstr "В списке, при перечислении кодов ошибок, коды оформляют полужирным (в этом списке обычно используют макрос B<\\&.TP>)."

#. type: Plain text
#: man-pages/man7/man-pages.7:553
msgid ""
"Complete commands should, if long, be written as an indented line on their "
"own, with a blank line before and after the command, for example"
msgstr "Составные команды, если они длинные, должны быть записаны с отступом по линии, как самодостаточные, с пустой строкой перед и после команды, например"

#. type: Plain text
#: man-pages/man7/man-pages.7:557
#, no-wrap
msgid "man 7 man-pages\n"
msgstr "man 7 man-pages\n"

#. type: Plain text
#: man-pages/man7/man-pages.7:567
msgid ""
"If the command is short, then it can be included inline in the text, in "
"italic format, for example, I<man 7 man-pages>.  In this case, it may be "
"worth using nonbreaking spaces (\"\\e\\ \") at suitable places in the "
"command.  Command options should be written in italics (e.g., I<-l>)."
msgstr "Если команда короткая, то её можно включить прямо в текст как курсив, например I<man 7 man-pages>. В этом случае может потребоваться использовать неразрывные пробелы («\\e\\ ») в соответствующих местах команды. Параметры команды также должны быть выделены курсивом (например, I<-l>)."

#. type: Plain text
#: man-pages/man7/man-pages.7:572
msgid ""
"Expressions, if not written on a separate indented line, should be specified"
" in italics.  Again, the use of nonbreaking spaces may be appropriate if the"
" expression is inlined with normal text."
msgstr "Выражения, если не записаны на отдельной строке с отступом, должны выделяться курсивом. Здесь также может потребоваться задавать неразрывные пробелы, если выражение встроено в обычный текст."

#. type: Plain text
#: man-pages/man7/man-pages.7:574
msgid ""
"When showing example shell sessions, user input should be formatted in bold,"
" for example"
msgstr "При показе примера сеанса оболочки пользовательский ввод должен быть выделен жирным, например"

#. type: Plain text
#: man-pages/man7/man-pages.7:579
#, no-wrap
msgid ""
"$ B<date>\n"
"Thu Jul  7 13:01:27 CEST 2016\n"
msgstr "$ B<date>\nThu Jul  7 13:01:27 CEST 2016\n"

#. type: Plain text
#: man-pages/man7/man-pages.7:591
msgid ""
"Any reference to another man page should be written with the name in bold, "
"I<always> followed by the section number, formatted in Roman (normal) font, "
"without any separating spaces (e.g., B<intro>(2)).  The preferred way to "
"write this in the source file is:"
msgstr "Все ссылки на другие справочные страницы должны выделяться жирным шрифтом, I<всегда> должен быть указан номер раздела шрифтом Roman (обычным) и без пробелов (например, B<intro>(2)). В исходном файле это лучше записывать так:"

#. type: Plain text
#: man-pages/man7/man-pages.7:594
#, no-wrap
msgid "    .BR intro (2)\n"
msgstr "    .BR intro (2)\n"

#. type: Plain text
#: man-pages/man7/man-pages.7:599
msgid ""
"(Including the section number in cross references lets tools like "
"B<man2html>(1)  create properly hyperlinked pages.)"
msgstr "(включение номера раздела в перекрёстных ссылках позволяет таким инструментам как B<man2html>(1) создавать правильные гиперссылки между страницами)"

#. type: Plain text
#: man-pages/man7/man-pages.7:603
msgid ""
"Control characters should be written in bold face, with no quotes; for "
"example, B<^X>."
msgstr "Управляющие знаки следует писать полужирным шрифтом, без кавычек, как в примере B<^X>."

#. type: SS
#: man-pages/man7/man-pages.7:603
#, no-wrap
msgid "Spelling"
msgstr "Орфография"

#. type: Plain text
#: man-pages/man7/man-pages.7:609
msgid ""
"Starting with release 2.59, I<man-pages> follows American spelling "
"conventions (previously, there was a random mix of British and American "
"spellings); please write all new pages and patches according to these "
"conventions."
msgstr "Начиная с версии I<man-pages> следует при написании Американским соглашениям (до этого использовалось английское и американское написание); пишите новые страницы и присылайте заплаты с учётом этих соглашений."

#. type: Plain text
#: man-pages/man7/man-pages.7:612
msgid ""
"Aside from the well-known spelling differences, there are a few other "
"subtleties to watch for:"
msgstr "Кроме известных различий в написании, есть несколько других тонкостей, которые следует учесть:"

#. type: Plain text
#: man-pages/man7/man-pages.7:616
msgid ""
"American English tends to use the forms \"backward\", \"upward\", "
"\"toward\", and so on rather than the British forms \"backwards\", "
"\"upwards\", \"towards\", and so on."
msgstr "Американский вариант английского языка имеет обыкновение использовать формы «backward» (назад), «upward» (вверх), «toward» (к) и т. д., а в британском варианте это «backwards», «upwards», «towards» и т. д."

#. type: SS
#: man-pages/man7/man-pages.7:616
#, no-wrap
msgid "BSD version numbers"
msgstr "Номера версий BSD"

#. type: Plain text
#: man-pages/man7/man-pages.7:624
msgid ""
"The classical scheme for writing BSD version numbers is I<x.yBSD>, where "
"I<x.y> is the version number (e.g., 4.2BSD).  Avoid forms such as I<BSD "
"4.3>."
msgstr "Классической схемой обозначения версий BSD является I<x.yBSD>, где I<x.y> - номер версии (например, 4.2BSD). Избегайте написания в стиле I<BSD 4.3>."

#. type: SS
#: man-pages/man7/man-pages.7:624
#, no-wrap
msgid "Capitalization"
msgstr "Печать заглавными буквами"

#. type: Plain text
#: man-pages/man7/man-pages.7:630
msgid ""
"In subsection (\"SS\") headings, capitalize the first word in the heading, "
"but otherwise use lowercase, except where English usage (e.g., proper nouns)"
" or programming language requirements (e.g., identifier names) dictate "
"otherwise.  For example:"
msgstr "В заголовках разделов («SS») начинайте первое слово заголовка с заглавной буквы, а остальные буквы должны быть строчными, если обратного не требуют правила английского языка (например, имён собственных) или языка программирования (например, идентификаторы имён). Пример:"

#. type: Plain text
#: man-pages/man7/man-pages.7:633
#, no-wrap
msgid "    .SS Unicode under Linux\n"
msgstr "    .SS Юникод в Linux\n"

#. type: SS
#: man-pages/man7/man-pages.7:635
#, no-wrap
msgid "Indentation of structure definitions, shell session logs, and so on"
msgstr "Отступ при определении структур, содержимого журналов сеансов оболочек и т. п."

#. type: Plain text
#: man-pages/man7/man-pages.7:650
msgid ""
"When structure definitions, shell session logs, and so on are included in "
"running text, indent them by 4 spaces (i.e., a block enclosed by I<.in\\ "
"+4n> and I<.in>), format them using the I<.EX> and I<EE> macros, and "
"surround them with suitable paragraph markers (either I<.PP> or I<.IP>).  "
"For example:"
msgstr "При включении определений структур, журналов сеансов оболочек и т. п. в выполняемый текст, нужно использовать отступ в 4 пробела (т. е., блок заключается в I<.in\\ +4n> и I<.in>), форматировать их с помощью макросов I<.EX> и I<EE> и окружить их подходящими маркерами параграфа (I<.PP> или I<.IP>). Пример:"

#. type: Plain text
#: man-pages/man7/man-pages.7:664
#, no-wrap
msgid ""
"    .PP\n"
"    .in +4n\n"
"    .EX\n"
"    int\n"
"    main(int argc, char *argv[])\n"
"    {\n"
"        return 0;\n"
"    }\n"
"    .EE\n"
"    .in\n"
"    .PP\n"
msgstr "    .PP\n    .in +4n\n    .EX\n    int\n    main(int argc, char *argv[])\n    {\n        return 0;\n    }\n    .EE\n    .in\n    .PP\n"

#. type: SS
#: man-pages/man7/man-pages.7:666
#, no-wrap
msgid "Preferred terms"
msgstr "Предпочтительные термины"

#. type: Plain text
#: man-pages/man7/man-pages.7:669
msgid ""
"The following table lists some preferred terms to use in man pages, mainly "
"to ensure consistency across pages."
msgstr "В следующей таблице перечислены некоторые предпочтительные термины, для использования в справочных страницах, главным образом, для непротиворечивости информации на страницах."

#. type: tbl table
#: man-pages/man7/man-pages.7:673
#, no-wrap
msgid "Term"
msgstr "Термин (перевод)"

#. type: tbl table
#: man-pages/man7/man-pages.7:673
#, no-wrap
msgid "Avoid using"
msgstr "Не используйте"

#. type: tbl table
#: man-pages/man7/man-pages.7:673 man-pages/man7/man-pages.7:738
#, no-wrap
msgid "Notes"
msgstr "Замечания"

#. type: tbl table
#: man-pages/man7/man-pages.7:675
#, no-wrap
msgid "bit mask"
msgstr "bit mask (маска битов)"

#. type: tbl table
#: man-pages/man7/man-pages.7:675
#, no-wrap
msgid "bitmask"
msgstr "bitmask"

#. type: tbl table
#: man-pages/man7/man-pages.7:676
#, no-wrap
msgid "built-in"
msgstr "built-in (встроенный)"

#. type: tbl table
#: man-pages/man7/man-pages.7:676
#, no-wrap
msgid "builtin"
msgstr "builtin"

#. type: tbl table
#: man-pages/man7/man-pages.7:677
#, no-wrap
msgid "Epoch"
msgstr "Epoch (эпоха)"

#. type: tbl table
#: man-pages/man7/man-pages.7:677
#, no-wrap
msgid "epoch"
msgstr "epoch"

#. type: tbl table
#: man-pages/man7/man-pages.7:679
#, no-wrap
msgid "For the UNIX Epoch (00:00:00, 1 Jan 1970 UTC)"
msgstr "Эпоха UNIX (00:00:00, 1 января 1970 UTC)"

#. type: tbl table
#: man-pages/man7/man-pages.7:680
#, no-wrap
msgid "filename"
msgstr "filename (имя файла)"

#. type: tbl table
#: man-pages/man7/man-pages.7:680
#, no-wrap
msgid "file name"
msgstr "file name"

#. type: tbl table
#: man-pages/man7/man-pages.7:681
#, no-wrap
msgid "filesystem"
msgstr "filesystem (файловая система)"

#. type: tbl table
#: man-pages/man7/man-pages.7:681
#, no-wrap
msgid "file system"
msgstr "file system"

#. type: tbl table
#: man-pages/man7/man-pages.7:682
#, no-wrap
msgid "hostname"
msgstr "hostname (имя узла)"

#. type: tbl table
#: man-pages/man7/man-pages.7:682
#, no-wrap
msgid "host name"
msgstr "host name"

#. type: tbl table
#: man-pages/man7/man-pages.7:683
#, no-wrap
msgid "inode"
msgstr "inode"

#. type: tbl table
#: man-pages/man7/man-pages.7:683
#, no-wrap
msgid "i-node"
msgstr "i-node"

#. type: tbl table
#: man-pages/man7/man-pages.7:684
#, no-wrap
msgid "lowercase"
msgstr "lowercase (строчные)"

#. type: tbl table
#: man-pages/man7/man-pages.7:684
#, no-wrap
msgid "lower case, lower-case"
msgstr "lower case, lower-case"

#. type: tbl table
#: man-pages/man7/man-pages.7:685
#, no-wrap
msgid "nonzero"
msgstr "nonzero"

#. type: tbl table
#: man-pages/man7/man-pages.7:685
#, no-wrap
msgid "non-zero"
msgstr "non-zero"

#. type: tbl table
#: man-pages/man7/man-pages.7:686
#, no-wrap
msgid "pathname"
msgstr "pathname (путь)"

#. type: tbl table
#: man-pages/man7/man-pages.7:686
#, no-wrap
msgid "path name"
msgstr "path name"

#. type: tbl table
#: man-pages/man7/man-pages.7:687 man-pages/man7/man-pages.7:755
#, no-wrap
msgid "pseudoterminal"
msgstr "pseudoterminal (псевдо-терминал)"

#. type: tbl table
#: man-pages/man7/man-pages.7:687
#, no-wrap
msgid "pseudo-terminal"
msgstr "pseudo-terminal"

#. type: tbl table
#: man-pages/man7/man-pages.7:688
#, no-wrap
msgid "privileged port"
msgstr "privileged port (привилегированный порт)"

#. type: tbl table
#: man-pages/man7/man-pages.7:691
#, no-wrap
msgid ""
"reserved port,\n"
"system port"
msgstr "reserved port,\nsystem port"

#. type: tbl table
#: man-pages/man7/man-pages.7:692
#, no-wrap
msgid "real-time"
msgstr "real-time (реальное время)"

#. type: tbl table
#: man-pages/man7/man-pages.7:695
#, no-wrap
msgid ""
"realtime,\n"
"real time"
msgstr "realtime,\nreal time"

#. type: tbl table
#: man-pages/man7/man-pages.7:696
#, no-wrap
msgid "run time"
msgstr "run time (время исполнения)"

#. type: tbl table
#: man-pages/man7/man-pages.7:696
#, no-wrap
msgid "runtime"
msgstr "runtime"

#. type: tbl table
#: man-pages/man7/man-pages.7:697
#, no-wrap
msgid "saved set-group-ID"
msgstr "saved set-group-ID (сохранённый set-group-ID)"

#. type: tbl table
#: man-pages/man7/man-pages.7:700
#, no-wrap
msgid ""
"saved group ID,\n"
"saved set-GID"
msgstr "saved group ID,\nsaved set-GID"

#. type: tbl table
#: man-pages/man7/man-pages.7:701
#, no-wrap
msgid "saved set-user-ID"
msgstr "saved set-user-ID (сохранённый saved set-user-ID)"

#. type: tbl table
#: man-pages/man7/man-pages.7:704
#, no-wrap
msgid ""
"saved user ID,\n"
"saved set-UID"
msgstr "saved user ID,\nsaved set-UID"

#. type: tbl table
#: man-pages/man7/man-pages.7:705
#, no-wrap
msgid "set-group-ID"
msgstr "set-group-ID"

#. type: tbl table
#: man-pages/man7/man-pages.7:705
#, no-wrap
msgid "set-GID, setgid"
msgstr "set-GID, setgid"

#. type: tbl table
#: man-pages/man7/man-pages.7:706
#, no-wrap
msgid "set-user-ID"
msgstr "set-user-ID"

#. type: tbl table
#: man-pages/man7/man-pages.7:706
#, no-wrap
msgid "set-UID, setuid"
msgstr "set-UID, setuid"

#. type: tbl table
#: man-pages/man7/man-pages.7:707
#, no-wrap
msgid "superuser"
msgstr "superuser (суперпользователь)"

#. type: tbl table
#: man-pages/man7/man-pages.7:710
#, no-wrap
msgid ""
"super user,\n"
"super-user"
msgstr "super user,\nsuper-user"

#. type: tbl table
#: man-pages/man7/man-pages.7:711
#, no-wrap
msgid "superblock"
msgstr "superblock (суперблок)"

#. type: tbl table
#: man-pages/man7/man-pages.7:714
#, no-wrap
msgid ""
"super block,\n"
"super-block"
msgstr "super block,\nsuper-block"

#. type: tbl table
#: man-pages/man7/man-pages.7:715
#, no-wrap
msgid "timestamp"
msgstr "timestamp (метка времени)"

#. type: tbl table
#: man-pages/man7/man-pages.7:715
#, no-wrap
msgid "time stamp"
msgstr "time stamp"

#. type: tbl table
#: man-pages/man7/man-pages.7:716
#, no-wrap
msgid "timezone"
msgstr "timezone (часовой пояс)"

#. type: tbl table
#: man-pages/man7/man-pages.7:716
#, no-wrap
msgid "time zone"
msgstr "time zone"

#. type: tbl table
#: man-pages/man7/man-pages.7:717
#, no-wrap
msgid "uppercase"
msgstr "uppercase (прописные)"

#. type: tbl table
#: man-pages/man7/man-pages.7:717
#, no-wrap
msgid "upper case, upper-case"
msgstr "upper case, upper-case"

#. type: tbl table
#: man-pages/man7/man-pages.7:718
#, no-wrap
msgid "usable"
msgstr "usable (приемлемый)"

#. type: tbl table
#: man-pages/man7/man-pages.7:718
#, no-wrap
msgid "useable"
msgstr "useable"

#. type: tbl table
#: man-pages/man7/man-pages.7:719
#, no-wrap
msgid "user space"
msgstr "user space (пространство пользователя)"

#. type: tbl table
#: man-pages/man7/man-pages.7:719
#, no-wrap
msgid "userspace"
msgstr "userspace"

#. type: tbl table
#: man-pages/man7/man-pages.7:720
#, no-wrap
msgid "username"
msgstr "username (имя пользователя)"

#. type: tbl table
#: man-pages/man7/man-pages.7:720
#, no-wrap
msgid "user name"
msgstr "user name"

#. type: tbl table
#: man-pages/man7/man-pages.7:721
#, no-wrap
msgid "x86-64"
msgstr "x86-64"

#. type: tbl table
#: man-pages/man7/man-pages.7:721
#, no-wrap
msgid "x86_64"
msgstr "x86_64"

#. type: tbl table
#: man-pages/man7/man-pages.7:723
#, no-wrap
msgid "Except if referring to result of \"uname\\ -m\" or similar"
msgstr "Кроме случая, когда ссылаются на результат «uname\\ -m» или подобных"

#. type: tbl table
#: man-pages/man7/man-pages.7:724
#, no-wrap
msgid "zeros"
msgstr "zeros (нули)"

#. type: tbl table
#: man-pages/man7/man-pages.7:724
#, no-wrap
msgid "zeroes"
msgstr "zeroes"

#. type: Plain text
#: man-pages/man7/man-pages.7:730
msgid "See also the discussion I<Hyphenation of attributive compounds> below."
msgstr "Смотрите также I<Дефисы в составных терминах> далее."

#. type: SS
#: man-pages/man7/man-pages.7:730
#, no-wrap
msgid "Terms to avoid"
msgstr "Термины, которых следует избегать"

#. type: Plain text
#: man-pages/man7/man-pages.7:734
msgid ""
"The following table lists some terms to avoid using in man pages, along with"
" some suggested alternatives, mainly to ensure consistency across pages."
msgstr "В следующей таблице перечислены некоторые термины, которые лучше не использовать в справочных страницах и предлагаемые им альтернативы, использование которых поможет избежать противоречий между справочными страницами."

#. type: tbl table
#: man-pages/man7/man-pages.7:738
#, no-wrap
msgid "Avoid"
msgstr "Не используйте"

#. type: tbl table
#: man-pages/man7/man-pages.7:738
#, no-wrap
msgid "Use instead"
msgstr "Для использования"

#. type: tbl table
#: man-pages/man7/man-pages.7:740
#, no-wrap
msgid "32bit"
msgstr "32bit"

#. type: tbl table
#: man-pages/man7/man-pages.7:740
#, no-wrap
msgid "32-bit"
msgstr "32-bit (32-битный)"

#. type: tbl table
#: man-pages/man7/man-pages.7:742
#, no-wrap
msgid "same for 8-bit, 16-bit, etc."
msgstr "это же с 8-bit, 16-bit и т. п."

#. type: tbl table
#: man-pages/man7/man-pages.7:743
#, no-wrap
msgid "current process"
msgstr "current process (текущий процесс)"

#. type: tbl table
#: man-pages/man7/man-pages.7:743
#, no-wrap
msgid "calling process"
msgstr "calling process (вызывающий процесс)"

#. type: tbl table
#: man-pages/man7/man-pages.7:745
#, no-wrap
msgid "A common mistake made by kernel programmers when writing man pages"
msgstr "Частая ошибка, делаемая программистами ядра при написании справочных страниц"

#. type: tbl table
#: man-pages/man7/man-pages.7:746
#, no-wrap
msgid "manpage"
msgstr "manpage"

#. type: tbl table
#: man-pages/man7/man-pages.7:748
#, no-wrap
msgid "man page, manual page"
msgstr "man page, manual page (справочная страница)"

#. type: tbl table
#: man-pages/man7/man-pages.7:749
#, no-wrap
msgid "minus infinity"
msgstr "minus infinity (минус бесконечность)"

#. type: tbl table
#: man-pages/man7/man-pages.7:749
#, no-wrap
msgid "negative infinity"
msgstr "negative infinity (отрицательная бесконечность)"

#. type: tbl table
#: man-pages/man7/man-pages.7:750
#, no-wrap
msgid "non-root"
msgstr "non-root"

#. type: tbl table
#: man-pages/man7/man-pages.7:750 man-pages/man7/man-pages.7:751
#, no-wrap
msgid "unprivileged user"
msgstr "unprivileged user (непривилегированный пользователь)"

#. type: tbl table
#: man-pages/man7/man-pages.7:751
#, no-wrap
msgid "non-superuser"
msgstr "non-superuser"

#. type: tbl table
#: man-pages/man7/man-pages.7:752
#, no-wrap
msgid "nonprivileged"
msgstr "nonprivileged"

#. type: tbl table
#: man-pages/man7/man-pages.7:752
#, no-wrap
msgid "unprivileged"
msgstr "непривилегированный "

#. type: tbl table
#: man-pages/man7/man-pages.7:753
#, no-wrap
msgid "OS"
msgstr "OS"

#. type: tbl table
#: man-pages/man7/man-pages.7:753
#, no-wrap
msgid "operating system"
msgstr "operating system (операционная система)"

#. type: tbl table
#: man-pages/man7/man-pages.7:754
#, no-wrap
msgid "plus infinity"
msgstr "plus infinity (плюс бесконечность)"

#. type: tbl table
#: man-pages/man7/man-pages.7:754
#, no-wrap
msgid "positive infinity"
msgstr "positive infinity (положительная бесконечность)"

#. type: tbl table
#: man-pages/man7/man-pages.7:755
#, no-wrap
msgid "pty"
msgstr "pty"

#. type: tbl table
#: man-pages/man7/man-pages.7:756
#, no-wrap
msgid "tty"
msgstr "tty"

#. type: tbl table
#: man-pages/man7/man-pages.7:756
#, no-wrap
msgid "terminal"
msgstr "terminal (терминал)"

#. type: tbl table
#: man-pages/man7/man-pages.7:757
#, no-wrap
msgid "Unices"
msgstr "Unices"

#. type: tbl table
#: man-pages/man7/man-pages.7:757 man-pages/man7/man-pages.7:758
#, no-wrap
msgid "UNIX systems"
msgstr "UNIX systems (системы UNIX)"

#. type: tbl table
#: man-pages/man7/man-pages.7:758
#, no-wrap
msgid "Unixes"
msgstr "Unixes"

#. type: SS
#: man-pages/man7/man-pages.7:760
#, no-wrap
msgid "Trademarks"
msgstr "Торговые марки"

#. type: Plain text
#: man-pages/man7/man-pages.7:764
msgid ""
"Use the correct spelling and case for trademarks.  The following is a list "
"of the correct spellings of various relevant trademarks that are sometimes "
"misspelled:"
msgstr "При упоминании торговых марок соблюдайте правильное написание с соблюдением регистра. Вот список правильного написания различных торговых марок, которые иногда указывают неправильно:"

#. type: Plain text
#: man-pages/man7/man-pages.7:769
#, no-wrap
msgid ""
"     DG/UX\n"
"     HP-UX\n"
"     UNIX\n"
"     UnixWare\n"
msgstr "     DG/UX\n     HP-UX\n     UNIX\n     UnixWare\n"

#. type: SS
#: man-pages/man7/man-pages.7:769
#, no-wrap
msgid "NULL, NUL, null pointer, and null character"
msgstr "NULL, NUL, указатель null и символ null"

#. type: Plain text
#: man-pages/man7/man-pages.7:781
msgid ""
"A I<null pointer> is a pointer that points to nothing, and is normally "
"indicated by the constant I<NULL>.  On the other hand, I<NUL> is the I<null "
"byte>, a byte with the value 0, represented in C via the character constant "
"I<\\(aq\\e0\\(aq>."
msgstr "I<Указатель null> — это указатель, который ни на что не указывает и, как правило, имеет значение константы I<NULL>.  С другой стороны, I<NUL>  представляет собой I<байт null>, байт со значением 0, который в C представляется символьной константой I<\\(aq\\e0\\(aq>."

#. type: Plain text
#: man-pages/man7/man-pages.7:784
msgid ""
"The preferred term for the pointer is \"null pointer\" or simply \"NULL\"; "
"avoid writing \"NULL pointer\"."
msgstr "Данный указатель лучше называть «указатель null» или просто «NULL»; не используйте «указатель NULL»."

#. type: Plain text
#: man-pages/man7/man-pages.7:792
msgid ""
"The preferred term for the byte is \"null byte\".  Avoid writing \"NUL\", "
"since it is too easily confused with \"NULL\".  Avoid also the terms \"zero "
"byte\" and \"null character\".  The byte that terminates a C string should "
"be described as \"the terminating null byte\"; strings may be described as "
"\"null-terminated\", but avoid the use of \"NUL-terminated\"."
msgstr "Для описания байта используйте «байт null». Не пишите «NUL», так как такое наименование легко спутать с «NULL». Также избегайте терминов «нулевой байт» и «символ null». Байт, которым заканчиваются строки в C, нужно описывать как «завершающий байт null» (terminating null byte); про строки можно сказать как «завершающиеся null» (null-terminated), но не используйте «завершающиеся NUL»."

#. type: SS
#: man-pages/man7/man-pages.7:792
#, no-wrap
msgid "Hyperlinks"
msgstr "Гиперссылки"

#. type: Plain text
#: man-pages/man7/man-pages.7:800
msgid ""
"For hyperlinks, use the I<.UR>/I<.UE> macro pair (see B<groff_man>(7)).  "
"This produces proper hyperlinks that can be used in a web browser, when "
"rendering a page with, say:"
msgstr "Для указания гиперссылок используйте пару макросов I<.UR>/I<.UE> (смотрите B<groff_man>(7)). Они создаёт корректные гиперссылки, которые можно использовать  при просмотре в браузере, например так:"

#. type: Plain text
#: man-pages/man7/man-pages.7:802
#, no-wrap
msgid "     BROWSER=firefox man -H pagename\n"
msgstr "     BROWSER=firefox man -H имя_страницы\n"

#. type: SS
#: man-pages/man7/man-pages.7:802
#, no-wrap
msgid "Use of e.g., i.e., etc., a.k.a., and similar"
msgstr "Использование сокращений e.g. (например), i.e. (т. е.), a.k.a. (также известно как) и подобных"

#. type: Plain text
#: man-pages/man7/man-pages.7:807
msgid ""
"In general, the use of abbreviations such as \"e.g.\", \"i.e.\", \"etc.\", "
"\"cf.\", and \"a.k.a.\" should be avoided, in favor of suitable full "
"wordings (\"for example\", \"that is\", \"compare to\", \"and so on\", "
"\"also known as\")."
msgstr "Обычно лучше не использовать сокращения вида «e.g.», «i.e.», «etc.», «cf.», «a.k.a.», а писать слова полностью («например», «то есть», «и так далее», «по сравнению с», «также известно как»)."

#. type: Plain text
#: man-pages/man7/man-pages.7:811
msgid ""
"The only place where such abbreviations may be acceptable is in I<short> "
"parenthetical asides (e.g., like this one)."
msgstr "Единственным приемлемым местом для их использования является I<короткая> сноска (как, напр.,  эта)."

#. type: Plain text
#: man-pages/man7/man-pages.7:814
msgid ""
"Always include periods in such abbreviations, as shown here.  In addition, "
"\"e.g.\" and \"i.e.\" should always be followed by a comma."
msgstr "Всегда указывайте точки в подобных аббревиатурах. Также после «напр.р» и «т.е.» всегда ставится запятая."

#. type: SS
#: man-pages/man7/man-pages.7:814
#, no-wrap
msgid "Em-dashes"
msgstr "Длинное тире"

#. type: Plain text
#: man-pages/man7/man-pages.7:822
msgid ""
"The way to write an em-dash\\(emthe glyph that appears at either end of this"
" subphrase\\(emin *roff is with the macro \"\\e(em\".  (On an ASCII "
"terminal, an em-dash typically renders as two hyphens, but in other "
"typographical contexts it renders as a long dash.)  Em-dashes should be "
"written I<without> surrounding spaces."
msgstr "Для написания тире — символический знак, который появится в конце этой фразы\\(emв *roff используется макрос «\\e(em» (на терминалах с ASCII тире, обычно, отображается в виде двух переносов, но в других типографских контекстах оно может выглядеть как длинное тире). Тире должно записываться I<без> окружающих его пробелов."

#. type: SS
#: man-pages/man7/man-pages.7:822
#, no-wrap
msgid "Hyphenation of attributive compounds"
msgstr "Дефисы в составных терминах"

#. type: Plain text
#: man-pages/man7/man-pages.7:825
msgid ""
"Compound terms should be hyphenated when used attributively (i.e., to "
"qualify a following noun). Some examples:"
msgstr "Составные термины пишутся через дефис при использовании в качестве определителя (т. е., для уточнения последующего существительного). Примеры:"

#. type: Plain text
#: man-pages/man7/man-pages.7:832
#, no-wrap
msgid ""
"    32-bit value\n"
"    command-line argument\n"
"    floating-point number\n"
"    run-time check\n"
"    user-space function\n"
"    wide-character string\n"
msgstr "    32-bit value (32-битное значение)\n    command-line argument (аргумент командной строки)\n    floating-point number (число с плавающей запятой)\n    run-time check (проверка во время выполнения)\n    user-space function (функция пространства пользователя)\n    wide-character string (строка широких символов)\n"

#. type: SS
#: man-pages/man7/man-pages.7:832
#, no-wrap
msgid "Hyphenation with multi, non, pre, re, sub, and so on"
msgstr "Дефис с multi, non, pre, re, sub и т. п."

#. type: Plain text
#: man-pages/man7/man-pages.7:838
msgid ""
"The general tendency in modern English is not to hyphenate after prefixes "
"such as \"multi\", \"non\", \"pre\", \"re\", \"sub\", and so on.  Manual "
"pages should generally follow this rule when these prefixes are used in "
"natural English constructions with simple suffixes.  The following list "
"gives some examples of the preferred forms:"
msgstr "Общая тенденция на современном английском языке состоит в том, чтобы не ставить дефисы после префиксов «multi», «non», «pre», «re», «sub» и т. д. В справочных страницах, в основном, нужно следовать этому правилу, когда эти префиксы используются в естественных английских конструкциях с простыми суффиксами. В следующем списке приведены некоторые примеры правильного написания:"

#. type: Plain text
#: man-pages/man7/man-pages.7:859
#, no-wrap
msgid ""
"    interprocess\n"
"    multithreaded\n"
"    multiprocess\n"
"    nonblocking\n"
"    nondefault\n"
"    nonempty\n"
"    noninteractive\n"
"    nonnegative\n"
"    nonportable\n"
"    nonzero\n"
"    preallocated\n"
"    precreate\n"
"    prerecorded\n"
"    reestablished\n"
"    reinitialize\n"
"    rearm\n"
"    reread\n"
"    subcomponent\n"
"    subdirectory\n"
"    subsystem\n"
msgstr "    interprocess\n    multithreaded\n    multiprocess\n    nonblocking\n    nondefault\n    nonempty\n    noninteractive\n    nonnegative\n    nonportable\n    nonzero\n    preallocated\n    precreate\n    prerecorded\n    reestablished\n    reinitialize\n    rearm\n    reread\n    subcomponent\n    subdirectory\n    subsystem\n"

#. type: Plain text
#: man-pages/man7/man-pages.7:863
msgid ""
"Hyphens should be retained when the prefixes are used in nonstandard English"
" words, with trademarks, proper nouns, acronyms, or compound terms.  Some "
"examples:"
msgstr "Дефисы должны быть сохранены после префиксов для нестандартных английских слов, торговых марок, имён собственных, акронимов или составных терминов. Несколько примеров:"

#. type: Plain text
#: man-pages/man7/man-pages.7:868
#, no-wrap
msgid ""
"    non-ASCII\n"
"    non-English\n"
"    non-NULL\n"
"    non-real-time\n"
msgstr "    non-ASCII\n    non-English\n    non-NULL\n    non-real-time\n"

#. type: Plain text
#: man-pages/man7/man-pages.7:871
msgid ""
"Finally, note that \"re-create\" and \"recreate\" are two different verbs, "
"and the former is probably what you want."
msgstr "И напоследок заметим, что «re-create» и «recreate» — это два различных глагола и первый, вероятно то, что нужно."

#. type: SS
#: man-pages/man7/man-pages.7:871
#, no-wrap
msgid "Real minus character"
msgstr "Символ математического минуса"

#. type: Plain text
#: man-pages/man7/man-pages.7:878
msgid ""
"Where a real minus character is required (e.g., for numbers such as -1, for "
"man page cross references such as B<utf-8>(7), or when writing options that "
"have a leading dash, such as in I<ls\\ -l>), use the following form in the "
"man page source:"
msgstr "Если требуется символ математического минуса (например, для чисел (-1), перекрёстных ссылок справочных страниц (B<utf-8>(7) или при записи параметров, у которых есть начальные тире (I<ls\\ -l>)), используйте следующую форму записи в справочной странице:"

#. type: Plain text
#: man-pages/man7/man-pages.7:880
#, no-wrap
msgid "    \\e-\n"
msgstr "    \\e-\n"

#. type: Plain text
#: man-pages/man7/man-pages.7:882
msgid "This guideline applies also to code examples."
msgstr "Это правило применимо и в примерах кода."

#. type: SS
#: man-pages/man7/man-pages.7:882
#, no-wrap
msgid "Character constants"
msgstr "Символьные константы"

#. type: Plain text
#: man-pages/man7/man-pages.7:885
msgid ""
"To produce single quotes that render well in both ASCII and UTF-8, use the "
"following form for character constants in the man page source:"
msgstr "Чтобы получить одинарные кавычки, которые хорошо отображаются и в ASCII и в UTF-8, используйте следующую форму записи символьных констант в справочной странице:"

#. type: Plain text
#: man-pages/man7/man-pages.7:887
#, no-wrap
msgid "    \\e(aqC\\e(aq\n"
msgstr "    \\e(aqC\\e(aq\n"

#. type: Plain text
#: man-pages/man7/man-pages.7:892
msgid ""
"where I<C> is the quoted character.  This guideline applies also to "
"character constants used in code examples."
msgstr "где I<C> — символ в кавычках. Это правило применимо и в примерах кода."

#. type: SS
#: man-pages/man7/man-pages.7:892
#, no-wrap
msgid "Example programs and shell sessions"
msgstr "Примеры программ и сценариев оболочки"

#. type: Plain text
#: man-pages/man7/man-pages.7:896
msgid ""
"Manual pages may include example programs demonstrating how to use a system "
"call or library function.  However, note the following:"
msgstr "Справочные страницы могут включать примеры программ, демонстрирующие использование системных вызовов или библиотечных функций. При этом нужно учитывать ряд условий:"

#. type: Plain text
#: man-pages/man7/man-pages.7:898
msgid "Example programs should be written in C."
msgstr "Примеры программ должны быть написаны на языке C."

#. type: Plain text
#: man-pages/man7/man-pages.7:904
msgid ""
"An example program is necessary and useful only if it demonstrates something"
" beyond what can easily be provided in a textual description of the "
"interface.  An example program that does nothing other than call an "
"interface usually serves little purpose."
msgstr "Примеры программ необходимы и полезны лишь в тех случаях, когда они демонстрируют что-то сверх того, что может быть легко представлено в текстовом описании командного интерфейса. Примеры программ, которые не показывают ничего кроме вызова команды, как правило обладают незначительной полезностью."

#. type: Plain text
#: man-pages/man7/man-pages.7:907
msgid ""
"Example programs should be fairly short (preferably less than 100 lines; "
"ideally less than 50 lines)."
msgstr "Примеры программ должны быть предельно короткими (желательно менее 100 строк; в идеале менее 50 строк)"

#. type: Plain text
#: man-pages/man7/man-pages.7:910
msgid ""
"Example programs should do error checking after system calls and library "
"function calls."
msgstr "В примерах программ должна быть реализована проверка ошибок после системных вызовов и вызовов библиотечных функций."

#. type: Plain text
#: man-pages/man7/man-pages.7:913
msgid ""
"Example programs should be complete, and compile without warnings when "
"compiled with I<cc\\ -Wall>."
msgstr "Примеры программ должны быть полными и компилироваться без предупреждений при использовании  I<cc\\ -Wall>."

#. type: Plain text
#: man-pages/man7/man-pages.7:918
msgid ""
"Where possible and appropriate, example programs should allow "
"experimentation, by varying their behavior based on inputs (ideally from "
"command-line arguments, or alternatively, via input read by the program)."
msgstr "Там, где это возможно и целесообразно, примеры программ должны демонстрировать эксперимент, изменяя свое поведение в зависимости от входных параметров (в идеале от параметров командной строки или получаемых программой через стандартный ввод)."

#. type: Plain text
#: man-pages/man7/man-pages.7:924
msgid ""
"Example programs should be laid out according to Kernighan and Ritchie "
"style, with 4-space indents.  (Avoid the use of TAB characters in source "
"code!)  The following command can be used to format your source code to "
"something close to the preferred style:"
msgstr "Примеры программ должны быть написаны в стиле Кернигана (Kernighan) и Ритчи (Ritchie), с отступом, состоящим из 4 пробелов. (Избегайте использования символа табуляции в исходном коде!) Следующие команды могут быть использованы для форматирования исходного кода в что-то близкое к предпочтительному стилю:"

#. type: Plain text
#: man-pages/man7/man-pages.7:926
#, no-wrap
msgid "    indent -npro -kr -i4 -ts4 -sob -l72 -ss -nut -psl prog.c\n"
msgstr "    indent -npro -kr -i4 -ts4 -sob -l72 -ss -nut -psl prog.c\n"

#. type: Plain text
#: man-pages/man7/man-pages.7:928
msgid ""
"For consistency, all example programs should terminate using either of:"
msgstr "Для удобства восприятия, все программы должны завершаться с использованием одного из вариантов:"

#. type: Plain text
#: man-pages/man7/man-pages.7:931
#, no-wrap
msgid ""
"     exit(EXIT_SUCCESS);\n"
"     exit(EXIT_FAILURE);\n"
msgstr "     exit(EXIT_SUCCESS);\n     exit(EXIT_FAILURE);\n"

#. type: Plain text
#: man-pages/man7/man-pages.7:933
msgid "Avoid using the following forms to terminate a program:"
msgstr "Избегайте использования следующих форм завершения программы:"

#. type: Plain text
#: man-pages/man7/man-pages.7:937
#, no-wrap
msgid ""
"    exit(0);\n"
"    exit(1);\n"
"    return n;\n"
msgstr "    exit(0);\n    exit(1);\n    return n;\n"

#. type: Plain text
#: man-pages/man7/man-pages.7:943
msgid ""
"If there is extensive explanatory text before the program source code, mark "
"off the source code with a subsection heading I<Program source>, as in:"
msgstr "В случаях, когда примеру программы предшествует обширный пояснительный текст, определите код в подраздел и пометьте соответствующим заголовком  I<Код программы>, как показано ниже:"

#. type: Plain text
#: man-pages/man7/man-pages.7:945
msgid ".SS Program source"
msgstr ".SS Код программы"

#. type: Plain text
#: man-pages/man7/man-pages.7:947
msgid "Always do this if the explanatory text includes a shell session log."
msgstr "Всегда делайте это, если пояснительный текст включает примеры вывода в терминал."

#. type: Plain text
#: man-pages/man7/man-pages.7:950
msgid ""
"If you include a shell session log demonstrating the use of a program or "
"other system feature:"
msgstr "Если включаете лог вывода в терминал, демонстрирующий использование программы или системной функции:"

#. type: Plain text
#: man-pages/man7/man-pages.7:952
msgid "Place the session log above the source code listing"
msgstr "Поместите лог терминала выше листинга кода программы."

#. type: Plain text
#: man-pages/man7/man-pages.7:954
msgid "Indent the session log by four spaces."
msgstr "Обозначьте лог терминала четырьмя пробелами."

#. type: Plain text
#: man-pages/man7/man-pages.7:957
msgid ""
"Boldface the user input text, to distinguish it from output produced by the "
"system."
msgstr "Выделите полужирным вводимый пользователем текст, чтобы отличить его от вывода системы."

#. type: Plain text
#: man-pages/man7/man-pages.7:962
msgid ""
"For some examples of what example programs should look like, see B<wait>(2)"
"  and B<pipe>(2)."
msgstr "Ознакомиться с тем, как должны выглядеть примеры программ Вы можете, прочитав B<wait>(2)  и B<pipe>(2)."

#. type: Plain text
#: man-pages/man7/man-pages.7:969
msgid ""
"For canonical examples of how man pages in the I<man-pages> package should "
"look, see B<pipe>(2)  and B<fcntl>(2)."
msgstr "В качестве канонического примера того, как должны выглядеть страницы в пакете I<man-pages>, смотрите B<pipe>(2) и B<fcntl>(2)."

#. type: Plain text
#: man-pages/man7/man-pages.7:976
msgid ""
"B<man>(1), B<man2html>(1), B<attributes>(7), B<groff>(7), B<groff_man>(7), "
"B<man>(7), B<mdoc>(7)"
msgstr "B<man>(1), B<man2html>(1), B<attributes>(7), B<groff>(7), B<groff_man>(7), B<man>(7), B<mdoc>(7)"

#. type: TH
#: man-pages/man7/math_error.7:26
#, no-wrap
msgid "MATH_ERROR"
msgstr "MATH_ERROR"

#. type: Plain text
#: man-pages/man7/math_error.7:29
msgid "math_error - detecting errors from mathematical functions"
msgstr "math_error - определение ошибок при выполнении математических функций"

#. type: Plain text
#: man-pages/man7/math_error.7:34
#, no-wrap
msgid ""
"B<#include E<lt>math.hE<gt>>\n"
"B<#include E<lt>errno.hE<gt>>\n"
"B<#include E<lt>fenv.hE<gt>>\n"
msgstr "B<#include E<lt>math.hE<gt>>\nB<#include E<lt>errno.hE<gt>>\nB<#include E<lt>fenv.hE<gt>>\n"

#. type: Plain text
#: man-pages/man7/math_error.7:53
msgid ""
"When an error occurs, most library functions indicate this fact by returning"
" a special value (e.g., -1 or NULL).  Because they typically return a "
"floating-point number, the mathematical functions declared in "
"I<E<lt>math.hE<gt>> indicate an error using other mechanisms.  There are two"
" error-reporting mechanisms: the older one sets I<errno>; the newer one uses"
" the floating-point exception mechanism (the use of B<feclearexcept>(3)  and"
" B<fetestexcept>(3), as outlined below)  described in B<fenv>(3)."
msgstr "При возникновении ошибки большинство библиотечных функций возвращают специальное значение (например, -1 или NULL). Так как математические функции, объявленные в I<E<lt>math.hE<gt>>, обычно, возвращают число с плавающей запятой, то для выдачи ошибки используются другие способы. Есть два варианта вернуть сообщение об ошибке: старый — изменяя I<errno>; новый — используя механизм исключений плавающей запятой (с помощью B<feclearexcept>(3) и B<fetestexcept>(3) как описано ниже), описанный в B<fenv>(3)."

#. type: Plain text
#: man-pages/man7/math_error.7:58
msgid ""
"A portable program that needs to check for an error from a mathematical "
"function should set I<errno> to zero, and make the following call"
msgstr "Переносимая программа, которой требуется проверка на ошибки в математических функциях, должна обнулить I<errno> и выполнить вызов"

#. type: Plain text
#: man-pages/man7/math_error.7:62
#, no-wrap
msgid "feclearexcept(FE_ALL_EXCEPT);\n"
msgstr "feclearexcept(FE_ALL_EXCEPT);\n"

#. type: Plain text
#: man-pages/man7/math_error.7:66
msgid "before calling a mathematical function."
msgstr "перед тем, как вызвать математическую функцию."

#. type: Plain text
#: man-pages/man7/math_error.7:72
msgid ""
"Upon return from the mathematical function, if I<errno> is nonzero, or the "
"following call (see B<fenv>(3))  returns nonzero"
msgstr "По возврату из математической функции, если переменная I<errno> ненулевая, а так же следующий вызов (смотрите B<fenv>(3)) вернул ненулевое значение"

#. type: Plain text
#: man-pages/man7/math_error.7:77
#, no-wrap
msgid ""
"fetestexcept(FE_INVALID | FE_DIVBYZERO | FE_OVERFLOW |\n"
"             FE_UNDERFLOW);\n"
msgstr "fetestexcept(FE_INVALID | FE_DIVBYZERO | FE_OVERFLOW |\n             FE_UNDERFLOW);\n"

#.  enum
#.  {
#.  FE_INVALID = 0x01,
#.  __FE_DENORM = 0x02,
#.  FE_DIVBYZERO = 0x04,
#.  FE_OVERFLOW = 0x08,
#.  FE_UNDERFLOW = 0x10,
#.  FE_INEXACT = 0x20
#.  };
#. type: Plain text
#: man-pages/man7/math_error.7:90
msgid "then an error occurred in the mathematical function."
msgstr "то ошибка произошла в математической функции."

#. type: Plain text
#: man-pages/man7/math_error.7:93
msgid ""
"The error conditions that can occur for mathematical functions are described"
" below."
msgstr "Условия возникновения математических ошибок приведены ниже."

#. type: SS
#: man-pages/man7/math_error.7:93
#, no-wrap
msgid "Domain error"
msgstr "Ошибка области"

#. type: Plain text
#: man-pages/man7/math_error.7:109
msgid ""
"A I<domain error> occurs when a mathematical function is supplied with an "
"argument whose value falls outside the domain for which the function is "
"defined (e.g., giving a negative argument to B<log>(3)).  When a domain "
"error occurs, math functions commonly return a NaN (though some functions "
"return a different value in this case); I<errno> is set to B<EDOM>, and an "
"\"invalid\" (B<FE_INVALID>)  floating-point exception is raised."
msgstr "I<Ошибка области> возникает, когда математической функции передаётся аргумент, чьё значение выходит за границы области, ожидаемой функцией (например, передача отрицательного значения в функцию B<log>(3)). Когда возникает ошибка области, чаще всего, математические функции возвращают NaN (хотя некоторые функции в этом случае возвращают другое значение); I<errno> присваивается B<EDOM> возникает исключение плавающей запятой «invalid» (B<FE_INVALID>)."

#. type: SS
#: man-pages/man7/math_error.7:109
#, no-wrap
msgid "Pole error"
msgstr "Ошибка особой точки"

#. type: Plain text
#: man-pages/man7/math_error.7:133
msgid ""
"A I<pole error> occurs when the mathematical result of a function is an "
"exact infinity (e.g., the logarithm of 0 is negative infinity).  When a pole"
" error occurs, the function returns the (signed) value B<HUGE_VAL>, "
"B<HUGE_VALF>, or B<HUGE_VALL>, depending on whether the function result type"
" is I<double>, I<float>, or I<long double>.  The sign of the result is that "
"which is mathematically correct for the function.  I<errno> is set to "
"B<ERANGE>, and a \"divide-by-zero\" (B<FE_DIVBYZERO>)  floating-point "
"exception is raised."
msgstr "I<Ошибка особой точки> возникает, когда результат математической функции должен быть равен бесконечности (например, логарифм 0 равен отрицательной бесконечности). Когда возникает ошибка особой точки функция возвращает значение (со знаком) B<HUGE_VAL>, B<HUGE_VALF> или B<HUGE_VALL>, в зависимости от типа результата функции — I<double>, I<float> или I<long double>. Знак результата будет математически корректным для функции. Переменной I<errno> присваивается значение B<ERANGE> и возникает исключение плавающей запятой «divide-by-zero» (B<FE_DIVBYZERO>)."

#. type: SS
#: man-pages/man7/math_error.7:133
#, no-wrap
msgid "Range error"
msgstr "Ошибка диапазона"

#. type: Plain text
#: man-pages/man7/math_error.7:140
msgid ""
"A I<range error> occurs when the magnitude of the function result means that"
" it cannot be represented in the result type of the function.  The return "
"value of the function depends on whether the range error was an overflow or "
"an underflow."
msgstr "I<Ошибка диапазона> возникает, когда величина результата функции не может быть представлена типом результата функции. Возвращаемое значение функции зависит от того, было ли при ошибке диапазона переполнение или исчерпание."

#. type: Plain text
#: man-pages/man7/math_error.7:162
msgid ""
"A floating result I<overflows> if the result is finite, but is too large to "
"represented in the result type.  When an overflow occurs, the function "
"returns the value B<HUGE_VAL>, B<HUGE_VALF>, or B<HUGE_VALL>, depending on "
"whether the function result type is I<double>, I<float>, or I<long double>."
"  I<errno> is set to B<ERANGE>, and an \"overflow\" (B<FE_OVERFLOW>)  "
"floating-point exception is raised."
msgstr "Результат с плавающей запятой I<переполнен>, если он является конечным значением, но слишком большим для представления типом результата. При возникновении переполнения функция возвращает значение B<HUGE_VAL>, B<HUGE_VALF> или B<HUGE_VALL>, в зависимости от того, каков тип результата функции —  I<double>, I<float> или I<long double>. Переменной I<errno> присваивается значение B<ERANGE> и возникает переполнение плавающей запятой «overflow» (B<FE_OVERFLOW>)."

#. type: Plain text
#: man-pages/man7/math_error.7:177
msgid ""
"A floating result I<underflows> if the result is too small to be represented"
" in the result type.  If an underflow occurs, a mathematical function "
"typically returns 0.0 (C99 says a function shall return \"an implementation-"
"defined value whose magnitude is no greater than the smallest normalized "
"positive number in the specified type\").  I<errno> may be set to B<ERANGE>,"
" and an \"overflow\" (B<FE_UNDERFLOW>)  floating-point exception may be "
"raised."
msgstr "Результат с плавающей запятой I<потерял значимость>, если он слишком мал для представления типом результата. При возникновении исчерпаемости математическая функция, обычно, возвращает 0.0 (в C99 сказано, что функция должна возвращать «определяемое реализацией» значение, чья величина не больше, чем самое маленькое положительное число заданного типа»). Переменной I<errno> может быть присвоено значение B<ERANGE> и может возникать переполнение плавающей запятой «overflow» (B<FE_UNDERFLOW>)."

#. type: Plain text
#: man-pages/man7/math_error.7:187
msgid ""
"Some functions deliver a range error if the supplied argument value, or the "
"correct function result, would be I<subnormal>.  A subnormal value is one "
"that is nonzero, but with a magnitude that is so small that it can't be "
"presented in normalized form (i.e., with a 1 in the most significant bit of "
"the significand).  The representation of a subnormal number will contain one"
" or more leading zeros in the significand."
msgstr "Некоторые функции возвращают ошибку диапазона, ели значение аргумента или правильный результат функции был бы I<субнормальным>. Субнормальное значение — ненулевое значение, но его величина так мала, что не может быть представлена в нормализованном виде (т. е., есть 1 с самом значимом бите значащей части). Представление субнормального числа будет содержать один или более начальных нулей в значащей части."

#.  See CONFORMANCE in the glibc 2.8 (and earlier) source.
#. type: Plain text
#: man-pages/man7/math_error.7:209
msgid ""
"The I<math_errhandling> identifier specified by C99 and POSIX.1 is not "
"supported by glibc.  This identifier is supposed to indicate which of the "
"two error-notification mechanisms (I<errno>, exceptions retrievable via "
"B<fettestexcept>(3))  is in use.  The standards require that at least one be"
" in use, but permit both to be available.  The current (version 2.8) "
"situation under glibc is messy.  Most (but not all) functions raise "
"exceptions on errors.  Some also set I<errno>.  A few functions set "
"I<errno>, but don't raise an exception.  A very few functions do neither.  "
"See the individual manual pages for details."
msgstr "Идентификатор I<math_errhandling>, определённый в C99 и POSIX.1, не поддерживается в glibc. Данный идентификатор предполагается для указания какой из двух способов использован для уведомления об ошибке (I<errno>, исключение, извлекаемое с помощью B<fettestexcept>(3)). Стандарты требуют, чтобы использовался какой-то один, но допускают быть доступным обоим. На данный момент (версия 2.8) ситуация в glibc запутанная. Большинство (но не все) функций вызывают при ошибке исключение. Некоторые также изменяют I<errno>. Несколько функций изменяют I<errno>, но не вызывают исключение. Очень малое количество функций не делают ни того, ни другого. Всё это описано в их справочных страницах."

#. http://www.securecoding.cert.org/confluence/display/seccode/FLP32-C.+Prevent+or+detect+domain+and+range+errors+in+math+functions
#. type: Plain text
#: man-pages/man7/math_error.7:222
msgid ""
"To avoid the complexities of using I<errno> and B<fetestexcept>(3)  for "
"error checking, it is often advised that one should instead check for bad "
"argument values before each call.  For example, the following code ensures "
"that B<log>(3)'s argument is not a NaN and is not zero (a pole error) or "
"less than zero (a domain error):"
msgstr "Чтобы при проверке ошибок избежать сложностей с использованием I<errno> и B<fetestexcept>(3) часто советуют перед вызовом проверять аргументы на некорректные значения. Например, следующий код проверяет, что аргумент B<log>(3) не равен NaN и не равен нулю (ошибка особой точки) или меньше нуля (ошибка области):"

#. type: Plain text
#: man-pages/man7/math_error.7:226
#, no-wrap
msgid "double x, r;\n"
msgstr "double x, r;\n"

#. type: Plain text
#: man-pages/man7/math_error.7:230
#, no-wrap
msgid ""
"if (isnan(x) || islessequal(x, 0)) {\n"
"    /* Deal with NaN / pole error / domain error */\n"
"}\n"
msgstr "if (isnan(x) || islessequal(x, 0)) {\n    /* обработка NaN / ошибки особой точки / ошибки области */\n}\n"

#. type: Plain text
#: man-pages/man7/math_error.7:232
#, no-wrap
msgid "r = log(x);\n"
msgstr "r = log(x);\n"

#. type: Plain text
#: man-pages/man7/math_error.7:240
msgid ""
"The discussion on this page does not apply to the complex mathematical "
"functions (i.e., those declared by I<E<lt>complex.hE<gt>>), which in general"
" are not required to return errors by C99 and POSIX.1."
msgstr "Данная страница не применима к комплексным математическим функциям (описанным в I<E<lt>complex.hE<gt>>), для которых в C99 and POSIX.1, обычно, не требуется возвращать ошибки."

#. type: Plain text
#: man-pages/man7/math_error.7:256
msgid ""
"The B<gcc>(1)  I<-fno-math-errno> option causes the executable to employ "
"implementations of some mathematical functions that are faster than the "
"standard implementations, but do not set I<errno> on error.  (The B<gcc>(1)"
"  I<-ffast-math> option also enables I<-fno-math-errno>.)  An error can "
"still be tested for using B<fetestexcept>(3)."
msgstr "Параметр B<gcc>(1) I<-fno-math-errno> заставляет в исполняемых файлах вызывать реализации некоторых математических функций, которые быстрее стандартных, но не изменяющие I<errno> при ошибке (параметр B<gcc>(1) I<-ffast-math> также включает I<-fno-math-errno>.) Возникновение ошибки по-прежнему можно проверить с помощью B<fetestexcept>(3)."

#. type: Plain text
#: man-pages/man7/math_error.7:265
msgid ""
"B<gcc>(1), B<errno>(3), B<fenv>(3), B<fpclassify>(3), B<INFINITY>(3), "
"B<isgreater>(3), B<matherr>(3), B<nan>(3)"
msgstr "B<gcc>(1), B<errno>(3), B<fenv>(3), B<fpclassify>(3), B<INFINITY>(3), B<isgreater>(3), B<matherr>(3), B<nan>(3)"

#. type: Plain text
#: man-pages/man7/math_error.7:266
msgid "I<info libc>"
msgstr "I<info libc>"

#. type: TH
#: man-pages/man7/man.7:34
#, no-wrap
msgid "MAN"
msgstr "MAN"

#. type: Plain text
#: man-pages/man7/man.7:37
msgid "man - macros to format man pages"
msgstr "man - макросы для форматирования справочных страниц"

#. type: Plain text
#: man-pages/man7/man.7:41
msgid "B<groff -Tascii -man> I<file> \\&..."
msgstr "B<groff -Tascii -man> I<файл> \\&..."

#. type: Plain text
#: man-pages/man7/man.7:45
msgid "B<groff -Tps -man> I<file> \\&..."
msgstr "B<groff -Tps -man> I<файл> \\&..."

#. type: Plain text
#: man-pages/man7/man.7:62
msgid ""
"This manual page explains the B<groff an.tmac> macro package (often called "
"the B<man> macro package).  This macro package should be used by developers "
"when writing or porting man pages for Linux.  It is fairly compatible with "
"other versions of this macro package, so porting man pages should not be a "
"major problem (exceptions include the NET-2 BSD release, which uses a "
"totally different macro package called mdoc; see B<mdoc>(7))."
msgstr "В этой справочной странице описывается макет макросов B<groff an.tmac> (часто называемый макетом макросов B<man>). Данный пакет макросов должен использоваться разработчиками для написания или переноса справочных страниц в Linux. Он относительно совместим с другими версиями этого пакета макросов, так что перенос справочных страниц не должен быть большой проблемой (кроме выпуска NET-2 BSD, в котором используется полностью другой пакет макросов mdoc; смотрите B<mdoc>(7))."

#. type: Plain text
#: man-pages/man7/man.7:74
msgid ""
"Note that NET-2 BSD mdoc man pages can be used with B<groff> simply by "
"specifying the B<-mdoc> option instead of the B<-man> option.  Using the "
"B<-mandoc> option is, however, recommended, since this will automatically "
"detect which macro package is in use."
msgstr "Заметим, что справочные страницы NET-2 BSD mdoc можно использовать с B<groff> просто указав параметра B<-mdoc> вместо B<-man>. Однако рекомендуется использовать параметр B<-mandoc>, так как это включает автоматическое определение какой пакет макросов использовать."

#. type: Plain text
#: man-pages/man7/man.7:78
msgid ""
"For conventions that should be employed when writing man pages for the Linux"
" I<man-pages> package, see B<man-pages>(7)."
msgstr "Соглашения, которые нужно соблюдать при написании справочных страниц для пакета Linux I<man-pages> смотрите в B<man-pages>(7)."

#. type: Plain text
#: man-pages/man7/man.7:81
msgid ""
"The first command in a man page (after comment lines, that is, lines that "
"start with B<.\\e\">) should be"
msgstr "Первой командой в справочной странице (после комментариев, то есть строк, которые начинаются с B<.\\e\">) должна быть"

#. type: Plain text
#: man-pages/man7/man.7:91
msgid ""
"For details of the arguments that should be supplied to the B<TH> command, "
"see B<man-pages>(7)."
msgstr "Описание аргументов команды B<TH> смотрите в B<man-pages>(7)."

#. type: Plain text
#: man-pages/man7/man.7:97
msgid ""
"Note that BSD mdoc-formatted pages begin with the B<Dd> command, not the "
"B<TH> command."
msgstr "Заметим, что страницы, отформатированные под BSD mdoc, начинаются с команды B<Dd>, а не B<TH>."

#. type: SS
#: man-pages/man7/man.7:97
#, no-wrap
msgid "Sections"
msgstr "Разделы"

#.  The following doesn't seem to be required (see Debian bug 411303),
#.  If the name contains spaces and appears
#.  on the same line as
#.  .BR \&.SH ,
#.  then place the heading in double quotes.
#. type: Plain text
#: man-pages/man7/man.7:106
msgid "Sections are started with B<\\&.SH> followed by the heading name."
msgstr "Разделы начинаются с макроса B<\\&.SH>, за которым следует название заголовка."

#. type: Plain text
#: man-pages/man7/man.7:109
msgid ""
"The only mandatory heading is NAME, which should be the first section and be"
" followed on the next line by a one-line description of the program:"
msgstr "Единственным обязательным заголовком является ИМЯ, оно должно быть первым разделом и снабжаться однострочным описанием программы на следующей строке:"

#. type: Plain text
#: man-pages/man7/man.7:112
msgid "\\&.SH NAME"
msgstr "\\&.SH ИМЯ"

#. type: Plain text
#: man-pages/man7/man.7:114
msgid "item \\e- description"
msgstr "элемент \\e- описание"

#. type: Plain text
#: man-pages/man7/man.7:128
msgid ""
"It is extremely important that this format is followed, and that there is a "
"backslash before the single dash which follows the item name.  This syntax "
"is used by the B<mandb>(8)  program to create a database of short "
"descriptions for the B<whatis>(1)  and B<apropos>(1)  commands.  (See "
"B<lexgrog>(1)  for further details on the syntax of the NAME section.)"
msgstr "Чрезвычайно важно следовать этому формату, и ставить наклонную черту влево перед одиночным минусом, который указывается после названия объекта. Этот синтаксис используется программой B<mandb>(8) при создании базы данных кратких описаний для команд B<whatis>(1) и B<apropos>(1) (описание синтаксиса раздела ИМЯ смотрите в B<lexgrog>(1))."

#. type: Plain text
#: man-pages/man7/man.7:131
msgid ""
"For a list of other sections that might appear in a manual page, see B<man-"
"pages>(7)."
msgstr "Список разделов, которые могут присутствовать в справочной странице, смотрите в B<man-pages>(7)."

#. type: SS
#: man-pages/man7/man.7:131
#, no-wrap
msgid "Fonts"
msgstr "Шрифты"

#. type: Plain text
#: man-pages/man7/man.7:133
msgid "The commands to select the type face are:"
msgstr "Команды для выбора начертания шрифта:"

#. type: TP
#: man-pages/man7/man.7:133
#, no-wrap
msgid "B<\\&.B>"
msgstr "B<\\&.B>"

#. type: Plain text
#: man-pages/man7/man.7:136
msgid "Bold"
msgstr "Полужирный"

#. type: TP
#: man-pages/man7/man.7:136
#, no-wrap
msgid "B<\\&.BI>"
msgstr "B<\\&.BI>"

#. type: Plain text
#: man-pages/man7/man.7:140
msgid ""
"Bold alternating with italics (especially useful for function "
"specifications)"
msgstr "Полужирный курсив (часто применяется при описании функций)"

#. type: TP
#: man-pages/man7/man.7:140
#, no-wrap
msgid "B<\\&.BR>"
msgstr "B<\\&.BR>"

#. type: Plain text
#: man-pages/man7/man.7:145
msgid ""
"Bold alternating with Roman (especially useful for referring to other manual"
" pages)"
msgstr "Полужирный прямой (часто применяется для ссылок на другие справочные страницы)"

#. type: TP
#: man-pages/man7/man.7:145
#, no-wrap
msgid "B<\\&.I>"
msgstr "B<\\&.I>"

#. type: Plain text
#: man-pages/man7/man.7:148
msgid "Italics"
msgstr "Курсив"

#. type: TP
#: man-pages/man7/man.7:148
#, no-wrap
msgid "B<\\&.IB>"
msgstr "B<\\&.IB>"

#. type: Plain text
#: man-pages/man7/man.7:151
msgid "Italics alternating with bold"
msgstr "Курсив, чередующийся с полужирным"

#. type: TP
#: man-pages/man7/man.7:151
#, no-wrap
msgid "B<\\&.IR>"
msgstr "B<\\&.IR>"

#. type: Plain text
#: man-pages/man7/man.7:154
msgid "Italics alternating with Roman"
msgstr "Курсив, чередующийся с прямым"

#. type: TP
#: man-pages/man7/man.7:154
#, no-wrap
msgid "B<\\&.RB>"
msgstr "B<\\&.RB>"

#. type: Plain text
#: man-pages/man7/man.7:157
msgid "Roman alternating with bold"
msgstr "Прямой, чередующийся с полужирным"

#. type: TP
#: man-pages/man7/man.7:157
#, no-wrap
msgid "B<\\&.RI>"
msgstr "B<\\&.RI>"

#. type: Plain text
#: man-pages/man7/man.7:160
msgid "Roman alternating with italics"
msgstr "Прямой, чередующийся с курсивом"

#. type: TP
#: man-pages/man7/man.7:160
#, no-wrap
msgid "B<\\&.SB>"
msgstr "B<\\&.SB>"

#. type: Plain text
#: man-pages/man7/man.7:163
msgid "Small alternating with bold"
msgstr "Капитель, чередующаяся с полужирным"

#. type: TP
#: man-pages/man7/man.7:163
#, no-wrap
msgid "B<\\&.SM>"
msgstr "B<\\&.SM>"

#. type: Plain text
#: man-pages/man7/man.7:166
msgid "Small (useful for acronyms)"
msgstr "Капитель (полезна для аббревиатур)"

#. type: Plain text
#: man-pages/man7/man.7:179
msgid ""
"Traditionally, each command can have up to six arguments, but the GNU "
"implementation removes this limitation (you might still want to limit "
"yourself to 6 arguments for portability's sake).  Arguments are delimited by"
" spaces.  Double quotes can be used to specify an argument which contains "
"spaces.  All of the arguments will be printed next to each other without "
"intervening spaces, so that the B<\\&.BR> command can be used to specify a "
"word in bold followed by a mark of punctuation in Roman.  If no arguments "
"are given, the command is applied to the following line of text."
msgstr "Традиционно, у каждой команды может быть до шести аргументов, но в реализации GNU удалено это ограничение (вы могли бы ограничить себя 6 аргументами с целью переносимости). Аргументы разделяются пробелами. Для указания аргумента с пробелами можно использовать двойные кавычки. Все аргументы будут выведены друг за другом без разделяющих пробелов, поэтому для выделения слова жирным и последующим знаком пунктуации прямым можно использовать команду B<\\&.BR> Если аргументы не заданы, то команда применяется к следующей строке текста."

#. type: SS
#: man-pages/man7/man.7:179
#, no-wrap
msgid "Other macros and strings"
msgstr "Другие макросы и строки"

#. type: Plain text
#: man-pages/man7/man.7:199
msgid ""
"Below are other relevant macros and predefined strings.  Unless noted "
"otherwise, all macros cause a break (end the current line of text).  Many of"
" these macros set or use the \"prevailing indent.\" The \"prevailing "
"indent\" value is set by any macro with the parameter I<i> below; macros may"
" omit I<i> in which case the current prevailing indent will be used.  As a "
"result, successive indented paragraphs can use the same indent without "
"respecifying the indent value.  A normal (nonindented) paragraph resets the "
"prevailing indent value to its default value (0.5 inches).  By default, a "
"given indent is measured in ens; try to use ens or ems as units for indents,"
" since these will automatically adjust to font size changes.  The other key "
"macro definitions are:"
msgstr "Далее описываются другие  \tсопутствующие макросы и предопределённые строки. Если не указано обратного, все макросы выполняют разрыв (конец текста в текущей строке). Многие из этих макросов изменяют или используют «преобладающий отступ». Это значение изменяется любым макросом с параметром I<i> ниже; в макросы можно не указывать I<i> и в этом случае будет использован текущий преобладающий отступ. Это позволяет использовать единый отступ для рядом стоящих параграфов без указания значения отступа. Обычный (без отступа) параграф сбрасывает значение преобладающего отступа в значение по умолчанию (0.5 дюйма). По умолчанию, задаваемый отступ измеряется в ens; старайтесь использовать для отступов единицы измерения ens или ems, так как при этом автоматически выбирается правильный размер шрифта. Другие основные макросы:"

#. type: SS
#: man-pages/man7/man.7:199
#, no-wrap
msgid "Normal paragraphs"
msgstr "Обычные параграфы"

#. type: TP
#: man-pages/man7/man.7:200
#, no-wrap
msgid "B<\\&.LP>"
msgstr "B<\\&.LP>"

#. type: Plain text
#: man-pages/man7/man.7:205 man-pages/man7/man.7:210
msgid "Same as B<\\&.PP> (begin a new paragraph)."
msgstr "Тоже что и B<\\&.PP> (начало нового параграфа)."

#. type: TP
#: man-pages/man7/man.7:205
#, no-wrap
msgid "B<\\&.P>"
msgstr "B<\\&.P>"

#. type: TP
#: man-pages/man7/man.7:210
#, no-wrap
msgid "B<\\&.PP>"
msgstr "B<\\&.PP>"

#. type: Plain text
#: man-pages/man7/man.7:213
msgid "Begin a new paragraph and reset prevailing indent."
msgstr "Начинает новый параграф и сбрасывает преобладающий отступ."

#. type: SS
#: man-pages/man7/man.7:213
#, no-wrap
msgid "Relative margin indent"
msgstr "Относительная граница отступа"

#. type: TP
#: man-pages/man7/man.7:214
#, no-wrap
msgid "B<\\&.RS>I< i>"
msgstr "B<\\&.RS>I< i>"

#. type: Plain text
#: man-pages/man7/man.7:225
msgid ""
"Start relative margin indent: moves the left margin I<i> to the right (if "
"I<i> is omitted, the prevailing indent value is used).  A new prevailing "
"indent is set to 0.5 inches.  As a result, all following paragraph(s) will "
"be indented until the corresponding B<\\&.RE>."
msgstr "Начало относительной границы отступа: левая граница I<i> перемещается вправо (если I<i> не задано, то используется преобладающий отступ). Новым значением преобладающего отступа становится 0.5 дюйма. В результате все последующие параграфы будут иметь отступ пока не появится соответствующий B<\\&.RE>."

#. type: TP
#: man-pages/man7/man.7:225
#, no-wrap
msgid "B<\\&.RE>"
msgstr "B<\\&.RE>"

#. type: Plain text
#: man-pages/man7/man.7:229
msgid ""
"End relative margin indent and restores the previous value of the prevailing"
" indent."
msgstr "Завершает учёт относительной границы отступа и восстанавливает предыдущее значение преобладающего отступа."

#. type: SS
#: man-pages/man7/man.7:229
#, no-wrap
msgid "Indented paragraph macros"
msgstr "Макросы параграфа с отступом"

#. type: TP
#: man-pages/man7/man.7:230
#, no-wrap
msgid "B<\\&.HP>I< i>"
msgstr "B<\\&.HP>I< i>"

#. type: Plain text
#: man-pages/man7/man.7:235
msgid ""
"Begin paragraph with a hanging indent (the first line of the paragraph is at"
" the left margin of normal paragraphs, and the rest of the paragraph's lines"
" are indented)."
msgstr "Начинает параграф с висящим отступом (первая строка параграфа имеет левую границу как у обычных параграфов, а остальные строки параграфа имеют отступ)."

#. type: TP
#: man-pages/man7/man.7:235
#, no-wrap
msgid "B<\\&.IP>I< x i>"
msgstr "B<\\&.IP>I< x i>"

#. type: Plain text
#: man-pages/man7/man.7:256
msgid ""
"Indented paragraph with optional hanging tag.  If the tag I<x> is omitted, "
"the entire following paragraph is indented by I<i>.  If the tag I<x> is "
"provided, it is hung at the left margin before the following indented "
"paragraph (this is just like B<\\&.TP> except the tag is included with the "
"command instead of being on the following line).  If the tag is too long, "
"the text after the tag will be moved down to the next line (text will not be"
" lost or garbled).  For bulleted lists, use this macro with \\e(bu (bullet) "
"or \\e(em (em dash)  as the tag, and for numbered lists, use the number or "
"letter followed by a period as the tag; this simplifies translation to other"
" formats."
msgstr "Параграф с отступом и необязательным весящим тегом. Если тег I<x> не указан, то весь последующий параграф имеет отступ I<i>. Если тег I<x> задан, то он висит у левой границы перед последующим параграфом с отступом (как при B<\\&.TP>, то тег стоит рядом с командой, а не на следующей строке). Если тег слишком длинный, то текст после тега будет помещён вниз на следующую строку (текст не теряется или искажается). Для списков с маркером используйте этот макрос с \\e(bu (маркер) или \\e(em (тире) в качестве тега, а для нумерованных списков в качестве тега используйте цифру или букву с точкой; это упрощает трансляцию в другие форматы."

#. type: TP
#: man-pages/man7/man.7:256
#, no-wrap
msgid "B<\\&.TP>I< i>"
msgstr "B<\\&.TP>I< i>"

#. type: Plain text
#: man-pages/man7/man.7:263
msgid ""
"Begin paragraph with hanging tag.  The tag is given on the next line, but "
"its results are like those of the B<\\&.IP> command."
msgstr "Начинает параграф с висящим тегом. Тег задаётся на следующей строке, но результат будет подобен команде B<\\&.IP>."

#. type: SS
#: man-pages/man7/man.7:263
#, no-wrap
msgid "Hypertext link macros"
msgstr "Макросы гиперссылок"

#. type: TP
#: man-pages/man7/man.7:264
#, no-wrap
msgid "B<\\&.UR>I< url>"
msgstr "B<\\&.UR>I< url>"

#. type: Plain text
#: man-pages/man7/man.7:271
msgid ""
"Insert a hypertext link to the URI (URL)  I<url>, with all text up to the "
"following B<\\&.UE> macro as the link text."
msgstr "Вставляет гипертекстовую ссылку в URI (URL) I<url> в виде текста ссылки, окружая её текстом до следующего макроса B<\\&.UE>."

#. type: TP
#: man-pages/man7/man.7:271
#, no-wrap
msgid "B<\\&.UE>"
msgstr "B<\\&.UE>"

#. type: Plain text
#: man-pages/man7/man.7:288
msgid ""
"[I<trailer>] Terminate the link text of the preceding B<\\&.UR> macro, with "
"the optional I<trailer> (if present, usually a closing parenthesis and/or "
"end-of-sentence punctuation) immediately following.  For non-HTML output "
"devices (e.g., B<man -Tutf8>), the link text is followed by the URL in angle"
" brackets; if there is no link text, the URL is printed as its own link "
"text, surrounded by angle brackets.  (Angle brackets may not be available on"
" all output devices.)  For the HTML output device, the link text is "
"hyperlinked to the URL; if there is no link text, the URL is printed as its "
"own link text."
msgstr "[I<trailer>] Завершает текст ссылки из макроса B<\\&.UR> необязательным I<trailer> (если есть, то это, обычно закрывающая круглая скобка и/или знак конца элемента), указываем тут же. Для устройств, не выводящих HTML (например, B<man -Tutf8>), текст ссылки указывается после URL в угловых скобках; если текста нет, то URL печатается как ссылка, окружённая в квадратных скобках (угловые скобки могут отсутствовать на некоторых устройствах). Для устройств выводящих HTML, текст ссылки ведёт на URL; если текста нет, то печатается URL как ссылка."

#. type: Plain text
#: man-pages/man7/man.7:291
msgid ""
"These macros have been supported since GNU Troff 1.20 (2009-01-05) and "
"Heirloom Doctools Troff since 160217 (2016-02-17)."
msgstr "Эти макросы поддерживаются в GNU Troff начиная с версии 1.20 (2009-01-05) и в Heirloom Doctools Troff начиная с версии 160217 (2016-02-17)."

#. type: SS
#: man-pages/man7/man.7:291
#, no-wrap
msgid "Miscellaneous macros"
msgstr "Различные макросы"

#. type: TP
#: man-pages/man7/man.7:292
#, no-wrap
msgid "B<\\&.DT>"
msgstr "B<\\&.DT>"

#. type: Plain text
#: man-pages/man7/man.7:296
msgid ""
"Reset tabs to default tab values (every 0.5 inches); does not cause a break."
msgstr "Сбрасывает значение табуляций в умолчательное (каждые 0.5 дюйма); не приводит к разрыву."

#. type: TP
#: man-pages/man7/man.7:296
#, no-wrap
msgid "B<\\&.PD>I< d>"
msgstr "B<\\&.PD>I< d>"

#. type: Plain text
#: man-pages/man7/man.7:301
msgid ""
"Set inter-paragraph vertical distance to d (if omitted, d=0.4v); does not "
"cause a break."
msgstr "Устанавливает вертикальное расстояние между параграфами равным d (если не указано, то d=0.4v); не приводит к разрыву."

#. type: TP
#: man-pages/man7/man.7:301
#, no-wrap
msgid "B<\\&.SS>I< t>"
msgstr "B<\\&.SS>I< t>"

#. type: Plain text
#: man-pages/man7/man.7:308
msgid ""
"Subheading I<t> (like B<\\&.SH>, but used for a subsection inside a "
"section)."
msgstr "Подзаголовок I<t> (как B<\\&.SH>, но используется для подраздела внутри раздела)."

#. type: SS
#: man-pages/man7/man.7:308
#, no-wrap
msgid "Predefined strings"
msgstr "Предопределенные строки"

#. type: Plain text
#: man-pages/man7/man.7:312
msgid "The B<man> package has the following predefined strings:"
msgstr "В пакете B<man> есть следующие предопределённые строки:"

#. type: IP
#: man-pages/man7/man.7:312
#, no-wrap
msgid "\\e*R"
msgstr "\\e*R"

#. type: Plain text
#: man-pages/man7/man.7:314
msgid "Registration Symbol: \\*R"
msgstr "Символ регистрации прав: \\*R"

#. type: IP
#: man-pages/man7/man.7:314
#, no-wrap
msgid "\\e*S"
msgstr "\\e*S"

#. type: Plain text
#: man-pages/man7/man.7:316
msgid "Change to default font size"
msgstr "Изменяет размер шрифта по умолчанию"

#. type: IP
#: man-pages/man7/man.7:316
#, no-wrap
msgid "\\e*(Tm"
msgstr "\\e*(Tm"

#. type: Plain text
#: man-pages/man7/man.7:318
msgid "Trademark Symbol: \\*(Tm"
msgstr "Това́рный знак: \\*(Tm"

#. type: IP
#: man-pages/man7/man.7:318
#, no-wrap
msgid "\\e*(lq"
msgstr "\\e*(lq"

#. type: Plain text
#: man-pages/man7/man.7:320
msgid "Left angled double quote: ``"
msgstr "Двойная кавычка с наклоном влево: ``"

#. type: IP
#: man-pages/man7/man.7:320
#, no-wrap
msgid "\\e*(rq"
msgstr "\\e*(rq"

#. type: Plain text
#: man-pages/man7/man.7:322
msgid "Right angled double quote: ''"
msgstr "Двойная кавычка с наклоном вправо: \""

#. type: SS
#: man-pages/man7/man.7:322
#, no-wrap
msgid "Safe subset"
msgstr "Безопасный набор"

#. type: Plain text
#: man-pages/man7/man.7:366
msgid ""
"Although technically B<man> is a troff macro package, in reality a large "
"number of other tools process man page files that don't implement all of "
"troff's abilities.  Thus, it's best to avoid some of troff's more exotic "
"abilities where possible to permit these other tools to work correctly.  "
"Avoid using the various troff preprocessors (if you must, go ahead and use "
"B<tbl>(1), but try to use the B<IP> and B<TP> commands instead for two-"
"column tables).  Avoid using computations; most other tools can't process "
"them.  Use simple commands that are easy to translate to other formats.  The"
" following troff macros are believed to be safe (though in many cases they "
"will be ignored by translators): B<\\e\">, B<.>, B<ad>, B<bp>, B<br>, B<ce>,"
" B<de>, B<ds>, B<el>, B<ie>, B<if>, B<fi>, B<ft>, B<hy>, B<ig>, B<in>, "
"B<na>, B<ne>, B<nf>, B<nh>, B<ps>, B<so>, B<sp>, B<ti>, B<tr>."
msgstr "Хотя технически B<man> и является пакетом макросов troff, большое количество других инструментов обработки файлов справочных страниц не реализуют все свойства troff. То есть, лучше не использовать некоторые экзотические возможности troff, если нужно чтобы такие инструменты работали правильно. Не используйте различные препроцессоры troff (если очень нужно, то, конечно, используйте B<tbl>(1), но старайтесь использовать команды B<IP> и B<TP> вместо двухколоночных таблиц). Не применяйте вычисления; большинство инструментов не обрабатывают их. Используйте простые команды, которые легко транслировать в другие форматы. Следующие макросы troff можно использовать без проблем (хотя во многих случаях они будут игнорироваться трансляторами): B<\\e\">, B<.>, B<ad>, B<bp>, B<br>, B<ce>, B<de>, B<ds>, B<el>, B<ie>, B<if>, B<fi>, B<ft>, B<hy>, B<ig>, B<in>, B<na>, B<ne>, B<nf>, B<nh>, B<ps>, B<so>, B<sp>, B<ti>, B<tr>."

#. type: Plain text
#: man-pages/man7/man.7:389
msgid ""
"You may also use many troff escape sequences (those sequences beginning with"
" \\e).  When you need to include the backslash character as normal text, use"
" \\ee.  Other sequences you may use, where x or xx are any characters and N "
"is any digit, include: B<\\e\\(aq>, B<\\e\\(ga>, B<\\e->, B<\\e.>, B<\\e\">,"
" B<\\e%>, B<\\e*x>, B<\\e*(xx>, B<\\e(xx>, B<\\e$N>, B<\\enx>, B<\\en(xx>, "
"B<\\efx>, and B<\\ef(xx>.  Avoid using the escape sequences for drawing "
"graphics."
msgstr "Также можно использовать много экранированных последовательностей troff (начинающихся с \\e). Если нужно включить обратную косую черту в текст используйте \\ee. Можно использовать другие последовательности (здесь x или xx могут быть любыми символами и N любой цифрой): B<\\e\\(aq>, B<\\e\\(ga>, B<\\e->, B<\\e.>, B<\\e\">, B<\\e%>, B<\\e*x>, B<\\e*(xx>, B<\\e(xx>, B<\\e$N>, B<\\enx>, B<\\en(xx>, B<\\efx> и B<\\ef(xx>. Не используйте экранированные последовательности для рисования графики."

#. type: Plain text
#: man-pages/man7/man.7:420
msgid ""
"Do not use the optional parameter for B<bp> (break page).  Use only positive"
" values for B<sp> (vertical space).  Don't define a macro (B<de>)  with the "
"same name as a macro in this or the mdoc macro package with a different "
"meaning; it's likely that such redefinitions will be ignored.  Every "
"positive indent (B<in>)  should be paired with a matching negative indent "
"(although you should be using the B<RS> and B<RE> macros instead).  The "
"condition test (B<if,ie>)  should only have \\(aqt\\(aq or \\(aqn\\(aq as "
"the condition.  Only translations (B<tr>)  that can be ignored should be "
"used.  Font changes (B<ft> and the B<\\ef> escape sequence)  should only "
"have the values 1, 2, 3, 4, R, I, B, P, or CW (the ft command may also have "
"no parameters)."
msgstr "Не используйте необязательный параметр B<bp> (разрыв страницы). Используйте только положительные значения для B<sp> (вертикальный отступ). Не определяйте макрос (B<de>) с тем же именем как в этом пакете или пакете макросов mdoc с другим смыслом; такое переопределение, вероятнее всего, будет проигнорировано. Каждый положительный отступ (B<in>) должен составлять пару с отрицательным отступом (хотя для этого лучше использовать макросы B<RS> и B<RE>). В проверке условия (B<if,ie>) нужно использовать только \\(aqt\\(aq или \\(aqn\\(aq в качестве условия. Должны использоваться только трансляции (B<tr>), которые можно игнорировать. Для изменения шрифта (экранированные последовательности B<ft> и B<\\ef>) должны использоваться только значения 1, 2, 3, 4, R, I, B, P или CW (также команда ft может указываться без параметров)."

#. type: Plain text
#: man-pages/man7/man.7:427
msgid ""
"If you use capabilities beyond these, check the results carefully on several"
" tools.  Once you've confirmed that the additional capability is safe, let "
"the maintainer of this document know about the safe command or sequence that"
" should be added to this list."
msgstr "Если кроме этих возможностей вы используете какие-то другие, то внимательно проверяйте результат на нескольких инструментах. После положительной проверки дополнительной возможности, напишите об этом сопровождающему этого документа о безопасной команде или последовательности, которая будет вставлена в этот список."

#. type: Plain text
#: man-pages/man7/man.7:429
msgid "I</usr/share/groff/>[*/]I<tmac/an.tmac>"
msgstr "I</usr/share/groff/>[*/]I<tmac/an.tmac>"

#. type: Plain text
#: man-pages/man7/man.7:431
msgid "I</usr/man/whatis>"
msgstr "I</usr/man/whatis>"

#. type: Plain text
#: man-pages/man7/man.7:447
msgid ""
"By all means include full URLs (or URIs) in the text itself; some tools such"
" as B<man2html>(1)  can automatically turn them into hypertext links.  You "
"can also use the B<UR> and B<UE> macros to identify links to related "
"information.  If you include URLs, use the full URL (e.g., E<.UR "
"http://www.kernel.org> E<.UE )> to ensure that tools can automatically find "
"the URLs."
msgstr "Всегда включайте полные URL (или URI) в сам текст; некоторые инструменты, например B<man2html>(1), могут автоматически преобразовывать их в гипертекстовые ссылки. Для обозначения ссылок также вы можете использовать макросы B<UR> и B<UE>. При добавлении URL используйте полный URL (например, E<.UR http://www.kernel.org> E<.UE )>, чтобы инструменты могли автоматически найти URL."

#. type: Plain text
#: man-pages/man7/man.7:456
msgid ""
"Tools processing these files should open the file and examine the first "
"nonwhitespace character.  A period (.) or single quote (\\(aq) at the "
"beginning of a line indicates a troff-based file (such as man or mdoc).  A "
"left angle bracket (E<lt>) indicates an SGML/XML-based file (such as HTML or"
" Docbook).  Anything else suggests simple ASCII text (e.g., a \"catman\" "
"result)."
msgstr "Инструменты, обрабатывающие эти файлы, должны открыть файл и исследовать первый непробельный символ. Считается, что точка (.) или одинарная кавычка (\\(aq) в начале строки указывает, что файл в формате troff (man или mdoc). Левая угловая скобка (E<lt>) указывает, что файл в SGML/XML-подобном  формате (HTML или Docbook). При нахождении любого другого символа считается, что это простой текст ASCII (например, результат «catman»)."

#. type: Plain text
#: man-pages/man7/man.7:467
msgid ""
"Many man pages begin with B<\\(aq\\e\"> followed by a space and a list of "
"characters, indicating how the page is to be preprocessed.  For "
"portability's sake to non-troff translators we recommend that you avoid "
"using anything other than B<tbl>(1), and Linux can detect that "
"automatically.  However, you might want to include this information so your "
"man page can be handled by other (less capable) systems.  Here are the "
"definitions of the preprocessors invoked by these characters:"
msgstr "Много справочных страниц начинаются с B<\\(aq\\e\">, после которого идёт пробел и список символов, указывающих как страница должна быть предварительно обработана. Для совместимости с не troff подобными трансляторами, мы рекомендуем не использовать что-либо кроме B<tbl>(1), и Linux может обнаружить это автоматически. Однако вы можете захотеть включить эту информацию для того, чтобы ваша справочная страница могла быть обработана другими (менее развитыми) системами. Вот определения препроцессоров, вызываемых этими символами:"

#. type: TP
#: man-pages/man7/man.7:467
#, no-wrap
msgid "B<e>"
msgstr "B<e>"

#. type: Plain text
#: man-pages/man7/man.7:470
msgid "eqn(1)"
msgstr "eqn(1)"

#. type: TP
#: man-pages/man7/man.7:470
#, no-wrap
msgid "B<g>"
msgstr "B<g>"

#. type: Plain text
#: man-pages/man7/man.7:473
msgid "grap(1)"
msgstr "grap(1)"

#. type: TP
#: man-pages/man7/man.7:473
#, no-wrap
msgid "B<p>"
msgstr "B<p>"

#. type: Plain text
#: man-pages/man7/man.7:476
msgid "pic(1)"
msgstr "pic(1)"

#. type: TP
#: man-pages/man7/man.7:476
#, no-wrap
msgid "B<r>"
msgstr "B<r>"

#. type: Plain text
#: man-pages/man7/man.7:479
msgid "refer(1)"
msgstr "refer(1)"

#. type: TP
#: man-pages/man7/man.7:479
#, no-wrap
msgid "B<t>"
msgstr "B<t>"

#. type: Plain text
#: man-pages/man7/man.7:482
msgid "tbl(1)"
msgstr "tbl(1)"

#. type: TP
#: man-pages/man7/man.7:482
#, no-wrap
msgid "B<v>"
msgstr "B<v>"

#. type: Plain text
#: man-pages/man7/man.7:485
msgid "vgrind(1)"
msgstr "vgrind(1)"

#. type: Plain text
#: man-pages/man7/man.7:498
msgid ""
"Most of the macros describe formatting (e.g., font type and spacing) instead"
" of marking semantic content (e.g., this text is a reference to another "
"page), compared to formats like mdoc and DocBook (even HTML has more "
"semantic markings).  This situation makes it harder to vary the B<man> "
"format for different media, to make the formatting consistent for a given "
"media, and to automatically insert cross-references.  By sticking to the "
"safe subset described above, it should be easier to automate transitioning "
"to a different reference page format in the future."
msgstr "Большинство макросов служат для форматирования (например, тип шрифта и интервал), а не для маркировки семантического содержания (например, что текст — ссылка на другую страницу), если сравнивать с форматами mdoc и DocBook (даже в HTML больше семантической маркировки). Это усложняет создание формата B<man> для разных носителей, чтобы выдать непротиворечивый результат для определённого носителя и автоматически вставить перекрестные ссылки. Использование безопасного подмножества, описанного выше, должно упростить автоматизацию перехода между разными форматами ссылок в будущем."

#.  .SH AUTHORS
#.  .IP \(em 3m
#.  James Clark (jjc@jclark.com) wrote the implementation of the macro
#. package.
#.  .IP \(em
#.  Rickard E. Faith (faith@cs.unc.edu) wrote the initial version of
#.  this manual page.
#.  .IP \(em
#.  Jens Schweikhardt (schweikh@noc.fdn.de) wrote the Linux Man-Page Mini-
#. HOWTO
#.  (which influenced this manual page).
#.  .IP \(em
#.  David A. Wheeler (dwheeler@ida.org) heavily modified this
#.  manual page, such as adding detailed information on sections and macros.
#. type: Plain text
#: man-pages/man7/man.7:514
msgid "The Sun macro B<TX> is not implemented."
msgstr "Макрос Sun B<TX> не реализован."

#. type: Plain text
#: man-pages/man7/man.7:524
msgid ""
"B<apropos>(1), B<groff>(1), B<lexgrog>(1), B<man>(1), B<man2html>(1), "
"B<whatis>(1), B<groff_man>(7), B<groff_www>(7), B<man-pages>(7), B<mdoc>(7)"
msgstr "B<apropos>(1), B<groff>(1), B<lexgrog>(1), B<man>(1), B<man2html>(1), B<whatis>(1), B<groff_man>(7), B<groff_www>(7), B<man-pages>(7), B<mdoc>(7)"

#. type: TH
#: man-pages/man2/mkdir.2:11
#, no-wrap
msgid "MKDIR"
msgstr "MKDIR"

#. type: Plain text
#: man-pages/man2/mkdir.2:14
msgid "mkdir, mkdirat - create a directory"
msgstr "mkdir, mkdirat - создаёт каталог"

#.  .B #include <unistd.h>
#. type: Plain text
#: man-pages/man2/mkdir.2:19
#, no-wrap
msgid ""
"B<#include E<lt>sys/stat.hE<gt>>\n"
"B<#include E<lt>sys/types.hE<gt>>\n"
msgstr "B<#include E<lt>sys/stat.hE<gt>>\nB<#include E<lt>sys/types.hE<gt>>\n"

#. type: Plain text
#: man-pages/man2/mkdir.2:21
#, no-wrap
msgid "B<int mkdir(const char *>I<pathname>B<, mode_t >I<mode>B<);>\n"
msgstr "B<int mkdir(const char *>I<pathname>B<, mode_t >I<mode>B<);>\n"

#. type: Plain text
#: man-pages/man2/mkdir.2:24
#, no-wrap
msgid ""
"B<#include E<lt>fcntl.hE<gt>           >/* Definition of AT_* constants */\n"
"B<#include E<lt>sys/stat.hE<gt>>\n"
msgstr "B<#include E<lt>fcntl.hE<gt>           >/* определения констант AT_* */\nB<#include E<lt>sys/stat.hE<gt>>\n"

#. type: Plain text
#: man-pages/man2/mkdir.2:26
#, no-wrap
msgid ""
"B<int mkdirat(int >I<dirfd>B<, const char *>I<pathname>B<, mode_t "
">I<mode>B<);>\n"
msgstr "B<int mkdirat(int >I<dirfd>B<, const char *>I<pathname>B<, mode_t >I<mode>B<);>\n"

#. type: Plain text
#: man-pages/man2/mkdir.2:31
msgid ""
"Feature Test Macro Requirements for glibc (see B<feature_test_macros>(7)):"
msgstr "Требования макроса тестирования свойств для glibc (смотрите B<feature_test_macros>(7)):"

#. type: Plain text
#: man-pages/man2/mkdir.2:34
msgid "B<mkdirat>():"
msgstr "B<mkdirat>():"

#. type: TP
#: man-pages/man2/mkdir.2:37
#, no-wrap
msgid "Since glibc 2.10:"
msgstr "Начиная с glibc 2.10:"

#. type: Plain text
#: man-pages/man2/mkdir.2:40
msgid "_POSIX_C_SOURCE\\ E<gt>=\\ 200809L"
msgstr "_POSIX_C_SOURCE\\ E<gt>=\\ 200809L"

#. type: TP
#: man-pages/man2/mkdir.2:40
#, no-wrap
msgid "Before glibc 2.10:"
msgstr "До glibc 2.10:"

#. type: Plain text
#: man-pages/man2/mkdir.2:43
msgid "_ATFILE_SOURCE"
msgstr "_ATFILE_SOURCE"

#. type: Plain text
#: man-pages/man2/mkdir.2:50
msgid "B<mkdir>()  attempts to create a directory named I<pathname>."
msgstr "Функция B<mkdir>() пытается создать каталог с именем I<pathname>."

#. type: Plain text
#: man-pages/man2/mkdir.2:64
msgid ""
"The argument I<mode> specifies the mode for the new directory (see "
"B<inode>(7)).  It is modified by the process's I<umask> in the usual way: in"
" the absence of a default ACL, the mode of the created directory is (I<mode>"
" & ~I<umask> & 0777).  Whether other I<mode> bits are honored for the "
"created directory depends on the operating system.  For Linux, see NOTES "
"below."
msgstr "В аргументе I<mode> задаются права доступа к новому каталогу (смотрите B<inode>(7)). Эти права стандартным образом изменяются с помощью согласно I<umask> процесса: при отсутствии списка доступа по умолчанию права на созданный каталог будут рассчитаны как (I<mode> & ~I<umask> & 0777). Другие биты I<mode> на создаваемый каталог зависят от операционной системы. Для Linux они описаны в ЗАМЕЧАНИЯХ."

#. type: Plain text
#: man-pages/man2/mkdir.2:74
msgid ""
"The newly created directory will be owned by the effective user ID of the "
"process.  If the directory containing the file has the set-group-ID bit set,"
" or if the filesystem is mounted with BSD group semantics (I<mount -o "
"bsdgroups> or, synonymously I<mount -o grpid>), the new directory will "
"inherit the group ownership from its parent; otherwise it will be owned by "
"the effective group ID of the process."
msgstr "Создаваемый каталог будет принадлежать фактическому владельцу процесса. Если у родительского каталога установлен флаг set-group-ID, или файловая система смонтирована с семантикой групп в стиле BSD (I<mount -o bsdgroups> или, что одно и тоже, I<mount -o grpid>), то новый каталог унаследует группу владельца от своего родительского каталога; в противном случае группой владельцем станет фактическая группа процесса."

#. type: Plain text
#: man-pages/man2/mkdir.2:79
msgid ""
"If the parent directory has the set-group-ID bit set, then so will the newly"
" created directory."
msgstr "Если у родительского каталога установлен бит set-group-ID, то он будет установлен также и у создаваемого каталога."

#. type: SS
#: man-pages/man2/mkdir.2:79
#, no-wrap
msgid "mkdirat()"
msgstr "mkdirat()"

#. type: Plain text
#: man-pages/man2/mkdir.2:85
msgid ""
"The B<mkdirat>()  system call operates in exactly the same way as "
"B<mkdir>(), except for the differences described here."
msgstr "Системный вызов B<mkdirat>() работает также как системный вызов B<mkdir>(), за исключением случаев, описанных здесь."

#. type: Plain text
#: man-pages/man2/mkdir.2:95
msgid ""
"If the pathname given in I<pathname> is relative, then it is interpreted "
"relative to the directory referred to by the file descriptor I<dirfd> "
"(rather than relative to the current working directory of the calling "
"process, as is done by B<mkdir>()  for a relative pathname)."
msgstr "Если в I<pathname> задан относительный путь, то он считается относительно каталога, на который ссылается файловый дескриптор I<dirfd> (а не относительно текущего рабочего каталога вызывающего процесса, как это делается в B<mkdir>())."

#. type: Plain text
#: man-pages/man2/mkdir.2:107
msgid ""
"If I<pathname> is relative and I<dirfd> is the special value B<AT_FDCWD>, "
"then I<pathname> is interpreted relative to the current working directory of"
" the calling process (like B<mkdir>())."
msgstr "Если в I<pathname> задан относительный путь и I<dirfd> равно специальному значению B<AT_FDCWD>, то I<pathname> рассматривается относительно текущего рабочего каталога вызывающего процесса (как B<mkdir>())."

#. type: Plain text
#: man-pages/man2/mkdir.2:113
msgid "If I<pathname> is absolute, then I<dirfd> is ignored."
msgstr "Если в I<pathname> задан абсолютный путь, то I<dirfd> игнорируется."

#. type: Plain text
#: man-pages/man2/mkdir.2:118
msgid "See B<openat>(2)  for an explanation of the need for B<mkdirat>()."
msgstr "Смотрите в B<openat>(2) объяснение необходимости B<mkdirat>()."

#. type: SH
#: man-pages/man2/mkdir.2:118
#, no-wrap
msgid "RETURN VALUE"
msgstr "ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ"

#. type: Plain text
#: man-pages/man2/mkdir.2:125
msgid ""
"B<mkdir>()  and B<mkdirat>()  return zero on success, or -1 if an error "
"occurred (in which case, I<errno> is set appropriately)."
msgstr "При успешном выполнении вызовов B<mkdir>() и B<mkdirat>() возвращается 0. В случае ошибки возвращается -1, а I<errno> устанавливается в соответствующее значение."

#. type: SH
#: man-pages/man2/mkdir.2:125
#, no-wrap
msgid "ERRORS"
msgstr "ОШИБКИ"

#. type: TP
#: man-pages/man2/mkdir.2:126
#, no-wrap
msgid "B<EACCES>"
msgstr "B<EACCES>"

#. type: Plain text
#: man-pages/man2/mkdir.2:134
msgid ""
"The parent directory does not allow write permission to the process, or one "
"of the directories in I<pathname> did not allow search permission.  (See "
"also B<path_resolution>(7).)"
msgstr "У процесса нет прав на запись в родительский каталог, или в одном из каталогов в I<pathname> не разрешён поиск (смотрите также B<path_resolution>(7))."

#. type: TP
#: man-pages/man2/mkdir.2:134
#, no-wrap
msgid "B<EDQUOT>"
msgstr "B<EDQUOT>"

#. type: Plain text
#: man-pages/man2/mkdir.2:138
msgid ""
"The user's quota of disk blocks or inodes on the filesystem has been "
"exhausted."
msgstr "Исчерпана пользовательская квота на дисковые блоки или иноды файловой системы."

#. type: TP
#: man-pages/man2/mkdir.2:138
#, no-wrap
msgid "B<EEXIST>"
msgstr "B<EEXIST>"

#. type: Plain text
#: man-pages/man2/mkdir.2:145
msgid ""
"I<pathname> already exists (not necessarily as a directory).  This includes "
"the case where I<pathname> is a symbolic link, dangling or not."
msgstr "I<pathname> уже существует (и необязательно как каталог). В этом случае I<pathname> может быть символьной ссылкой, повисшей или нет."

#. type: TP
#: man-pages/man2/mkdir.2:145
#, no-wrap
msgid "B<EFAULT>"
msgstr "B<EFAULT>"

#. type: Plain text
#: man-pages/man2/mkdir.2:148
msgid "I<pathname> points outside your accessible address space."
msgstr "Аргумент I<pathname> указывает за пределы доступного адресного пространства."

#. type: TP
#: man-pages/man2/mkdir.2:148
#, no-wrap
msgid "B<EINVAL>"
msgstr "B<EINVAL>"

#. type: Plain text
#: man-pages/man2/mkdir.2:154
msgid ""
"The final component (\"basename\") of the new directory's I<pathname> is "
"invalid (e.g., it contains characters not permitted by the underlying "
"filesystem)."
msgstr "Последний компонент («основная часть» (basename)) нового каталога I<pathname> некорректен (например, содержит недопустимые в нижележащей файловой системе символы)."

#. type: TP
#: man-pages/man2/mkdir.2:154
#, no-wrap
msgid "B<ELOOP>"
msgstr "B<ELOOP>"

#. type: Plain text
#: man-pages/man2/mkdir.2:158
msgid "Too many symbolic links were encountered in resolving I<pathname>."
msgstr "Во время определения I<pathname> встретилось слишком много символьных ссылок."

#. type: TP
#: man-pages/man2/mkdir.2:158
#, no-wrap
msgid "B<EMLINK>"
msgstr "B<EMLINK>"

#. type: Plain text
#: man-pages/man2/mkdir.2:162
msgid "The number of links to the parent directory would exceed B<LINK_MAX>."
msgstr "Количество ссылок на родительский каталог превысило бы B<LINK_MAX>."

#. type: TP
#: man-pages/man2/mkdir.2:162
#, no-wrap
msgid "B<ENAMETOOLONG>"
msgstr "B<ENAMETOOLONG>"

#. type: Plain text
#: man-pages/man2/mkdir.2:165
msgid "I<pathname> was too long."
msgstr "I<pathname> слишком длинен."

#. type: TP
#: man-pages/man2/mkdir.2:165
#, no-wrap
msgid "B<ENOENT>"
msgstr "B<ENOENT>"

#. type: Plain text
#: man-pages/man2/mkdir.2:170
msgid ""
"A directory component in I<pathname> does not exist or is a dangling "
"symbolic link."
msgstr "Один из каталогов в I<pathname> не существует или является повисшей символьной ссылкой."

#. type: TP
#: man-pages/man2/mkdir.2:170
#, no-wrap
msgid "B<ENOMEM>"
msgstr "B<ENOMEM>"

#. type: Plain text
#: man-pages/man2/mkdir.2:173
msgid "Insufficient kernel memory was available."
msgstr "Недостаточное количество памяти ядра."

#. type: TP
#: man-pages/man2/mkdir.2:173 man-pages/man2/mkdir.2:178
#, no-wrap
msgid "B<ENOSPC>"
msgstr "B<ENOSPC>"

#. type: Plain text
#: man-pages/man2/mkdir.2:178
msgid "The device containing I<pathname> has no room for the new directory."
msgstr "На устройстве, содержащем I<pathname>, нет места для создания нового каталога."

#. type: Plain text
#: man-pages/man2/mkdir.2:182
msgid ""
"The new directory cannot be created because the user's disk quota is "
"exhausted."
msgstr "Новый каталог не может быть создан, так как превышена пользовательская дисковая квота."

#. type: TP
#: man-pages/man2/mkdir.2:182 man-pages/man2/mkdir.2:203
#, no-wrap
msgid "B<ENOTDIR>"
msgstr "B<ENOTDIR>"

#. type: Plain text
#: man-pages/man2/mkdir.2:187
msgid ""
"A component used as a directory in I<pathname> is not, in fact, a directory."
msgstr "Компонент пути, использованный как каталог в I<pathname>, в действительности таковым не является."

#. type: TP
#: man-pages/man2/mkdir.2:187
#, no-wrap
msgid "B<EPERM>"
msgstr "B<EPERM>"

#. type: Plain text
#: man-pages/man2/mkdir.2:192
msgid ""
"The filesystem containing I<pathname> does not support the creation of "
"directories."
msgstr "Файловая система, содержащая I<pathname>, не поддерживает создание каталогов."

#. type: TP
#: man-pages/man2/mkdir.2:192
#, no-wrap
msgid "B<EROFS>"
msgstr "B<EROFS>"

#. type: Plain text
#: man-pages/man2/mkdir.2:196
msgid "I<pathname> refers to a file on a read-only filesystem."
msgstr "I<pathname> указывает на файл в файловой системе, доступной только для чтения."

#. type: Plain text
#: man-pages/man2/mkdir.2:199
msgid "The following additional errors can occur for B<mkdirat>():"
msgstr "В B<mkdirat>() дополнительно могут возникнуть следующие ошибки:"

#. type: TP
#: man-pages/man2/mkdir.2:199
#, no-wrap
msgid "B<EBADF>"
msgstr "B<EBADF>"

#. type: Plain text
#: man-pages/man2/mkdir.2:203
msgid "I<dirfd> is not a valid file descriptor."
msgstr "I<dirfd> не является правильным файловым дескриптором."

#. type: Plain text
#: man-pages/man2/mkdir.2:209
msgid ""
"I<pathname> is relative and I<dirfd> is a file descriptor referring to a "
"file other than a directory."
msgstr "Значение I<pathname> содержит относительный путь и I<dirfd> содержит файловый дескриптор, указывающий на файл, а не на каталог."

#. type: Plain text
#: man-pages/man2/mkdir.2:213
msgid ""
"B<mkdirat>()  was added to Linux in kernel 2.6.16; library support was added"
" to glibc in version 2.4."
msgstr "Вызов B<mkdirat>() был добавлен в ядро Linux версии 2.6.16; поддержка в glibc доступна с версии 2.4."

#.  SVr4 documents additional EIO, EMULTIHOP
#. type: Plain text
#: man-pages/man2/mkdir.2:217
msgid "B<mkdir>(): SVr4, BSD, POSIX.1-2001, POSIX.1-2008."
msgstr "B<mkdir>(): SVr4, BSD, POSIX.1-2001, POSIX.1-2008."

#. type: Plain text
#: man-pages/man2/mkdir.2:220
msgid "B<mkdirat>(): POSIX.1-2008."
msgstr "B<mkdirat>(): POSIX.1-2008."

#. type: Plain text
#: man-pages/man2/mkdir.2:225
msgid ""
"Under Linux, apart from the permission bits, the B<S_ISVTX> I<mode> bit is "
"also honored."
msgstr "В Linux кроме битов прав, в I<mode> учитывается также бит B<S_ISVTX>."

#. type: Plain text
#: man-pages/man2/mkdir.2:229
msgid ""
"There are many infelicities in the protocol underlying NFS.  Some of these "
"affect B<mkdir>()."
msgstr "В протоколе, на котором работает NFS, есть множество недоработок. Некоторые из них влияют на B<mkdir>()."

#. type: SS
#: man-pages/man2/mkdir.2:229
#, no-wrap
msgid "Glibc notes"
msgstr "Замечания по glibc"

#. type: Plain text
#: man-pages/man2/mkdir.2:242
msgid ""
"On older kernels where B<mkdirat>()  is unavailable, the glibc wrapper "
"function falls back to the use of B<mkdir>().  When I<pathname> is a "
"relative pathname, glibc constructs a pathname based on the symbolic link in"
" I</proc/self/fd> that corresponds to the I<dirfd> argument."
msgstr "В старых ядрах, где B<mkdirat>() отсутствует, обёрточная функция glibc использует B<mkdir>(). Если I<pathname> является относительным путём, то glibc собирает путь относительно символической ссылки в I</proc/self/fd>, которая соответствует аргументу I<dirfd>."

#. type: Plain text
#: man-pages/man2/mkdir.2:253
msgid ""
"B<mkdir>(1), B<chmod>(2), B<chown>(2), B<mknod>(2), B<mount>(2), "
"B<rmdir>(2), B<stat>(2), B<umask>(2), B<unlink>(2), B<acl>(5)  "
"B<path_resolution>(7)"
msgstr "B<mkdir>(1), B<chmod>(2), B<chown>(2), B<mknod>(2), B<mount>(2), B<rmdir>(2), B<stat>(2), B<umask>(2), B<unlink>(2), B<acl>(5)  B<path_resolution>(7)"

#. type: TH
#: man-pages/man2/mmap.2:40
#, no-wrap
msgid "MMAP"
msgstr "MMAP"

#. type: TH
#: man-pages/man2/mmap.2:40
#, no-wrap
msgid "2019-02-27"
msgstr "2019-02-27"

#. type: Plain text
#: man-pages/man2/mmap.2:43
msgid "mmap, munmap - map or unmap files or devices into memory"
msgstr "mmap, munmap - отображает файлы или устройства в памяти, или удаляет их отображение"

#. type: Plain text
#: man-pages/man2/mmap.2:46
#, no-wrap
msgid "B<#include E<lt>sys/mman.hE<gt>>\n"
msgstr "B<#include E<lt>sys/mman.hE<gt>>\n"

#. type: Plain text
#: man-pages/man2/mmap.2:51
#, no-wrap
msgid ""
"B<void *mmap(void *>I<addr>B<, size_t >I<length>B<, int >I<prot>B<, int >I<flags>B<,>\n"
"B<           int >I<fd>B<, off_t >I<offset>B<);>\n"
"B<int munmap(void *>I<addr>B<, size_t >I<length>B<);>\n"
msgstr "B<void *mmap(void *>I<addr>B<, size_t >I<length>B<, int >I<prot>B<, int >I<flags>B<,>\nB<           int >I<fd>B<, off_t >I<offset>B<);>\nB<int munmap(void *>I<addr>B<, size_t >I<length>B<);>\n"

#. type: Plain text
#: man-pages/man2/mmap.2:54
msgid "See NOTES for information on feature test macro requirements."
msgstr "Информацию по требованиям макроса тестирования свойств смотрите в разделе ЗАМЕЧАНИЯ."

#. type: Plain text
#: man-pages/man2/mmap.2:63
msgid ""
"B<mmap>()  creates a new mapping in the virtual address space of the calling"
" process.  The starting address for the new mapping is specified in I<addr>."
"  The I<length> argument specifies the length of the mapping (which must be "
"greater than 0)."
msgstr "Вызов B<mmap>() создаёт новое отображение в виртуальном адресном пространстве вызывающего процесса. Адрес начала нового отображения указывается в I<addr>. В аргументе I<length> задаётся длина отображения (должна быть больше 0)."

#.  Before Linux 2.6.24, the address was rounded up to the next page
#.  boundary; since 2.6.24, it is rounded down!
#. type: Plain text
#: man-pages/man2/mmap.2:83
msgid ""
"If I<addr> is NULL, then the kernel chooses the (page-aligned) address at "
"which to create the mapping; this is the most portable method of creating a "
"new mapping.  If I<addr> is not NULL, then the kernel takes it as a hint "
"about where to place the mapping; on Linux, the kernel will pick a nearby "
"page boundary (but always above or equal to the value specified by "
"I</proc/sys/vm/mmap_min_addr>)  and attempt to create the mapping there.  If"
" another mapping already exists there, the kernel picks a new address that "
"may or may not depend on the hint.  The address of the new mapping is "
"returned as the result of the call."
msgstr "Если значение I<addr> равно NULL, то ядро само выбирает адрес (выровненный по странице), по которому создаётся отображение; это наиболее переносимый метод создания нового отображения. Если значение I<addr> не равно NULL, то ядро учитывает это при размещении отображения; в Linux ядро выберет ближайшую к границе страницу (но всегда выше или равною значению, заданному в I</proc/sys/vm/mmap_min_addr>) и попытается создать отображение. Если по этому адресу уже есть отображение, то ядро выберет новый адрес, который может и не зависеть от подсказки. Адрес нового отображения возвращается как результат вызова."

#. type: Plain text
#: man-pages/man2/mmap.2:95
msgid ""
"The contents of a file mapping (as opposed to an anonymous mapping; see "
"B<MAP_ANONYMOUS> below), are initialized using I<length> bytes starting at "
"offset I<offset> in the file (or other object) referred to by the file "
"descriptor I<fd>.  I<offset> must be a multiple of the page size as returned"
" by I<sysconf(_SC_PAGE_SIZE)>."
msgstr "Содержимое файлового отображения (в отличие от анонимного отображения; смотрите B<MAP_ANONYMOUS> далее) инициализируется данными из файла (или объекта), на который указывает файловый дескриптор I<fd>, длиной I<length> байт, начиная со смещения I<offset>. Значение I<offset> должно быть кратно размеру (возвращается I<sysconf(_SC_PAGE_SIZE)>) страницы."

#. type: Plain text
#: man-pages/man2/mmap.2:101
msgid ""
"After the B<mmap>()  call has returned, the file descriptor, I<fd>, can be "
"closed immediately without invalidating the mapping."
msgstr "После возврата из вызова B<mmap>() файловый дескриптор I<fd> может быть немедленно закрыт без признания отображения недействительным."

#. type: Plain text
#: man-pages/man2/mmap.2:109
msgid ""
"The I<prot> argument describes the desired memory protection of the mapping "
"(and must not conflict with the open mode of the file).  It is either "
"B<PROT_NONE> or the bitwise OR of one or more of the following flags:"
msgstr "В аргументе I<prot> указывается желаемая защита памяти отображения (не должна конфликтовать с режимом открытого файла). Значением может быть B<PROT_NONE> или побитово сложенные (OR) следующие флаги:"

#. type: TP
#: man-pages/man2/mmap.2:109
#, no-wrap
msgid "B<PROT_EXEC>"
msgstr "B<PROT_EXEC>"

#. type: Plain text
#: man-pages/man2/mmap.2:112
msgid "Pages may be executed."
msgstr "Страницы доступны для исполнения."

#. type: TP
#: man-pages/man2/mmap.2:112
#, no-wrap
msgid "B<PROT_READ>"
msgstr "B<PROT_READ>"

#. type: Plain text
#: man-pages/man2/mmap.2:115
msgid "Pages may be read."
msgstr "Страницы доступны для чтения."

#. type: TP
#: man-pages/man2/mmap.2:115
#, no-wrap
msgid "B<PROT_WRITE>"
msgstr "B<PROT_WRITE>"

#. type: Plain text
#: man-pages/man2/mmap.2:118
msgid "Pages may be written."
msgstr "Страницы доступны для записи."

#. type: TP
#: man-pages/man2/mmap.2:118
#, no-wrap
msgid "B<PROT_NONE>"
msgstr "B<PROT_NONE>"

#. type: Plain text
#: man-pages/man2/mmap.2:121
msgid "Pages may not be accessed."
msgstr "Страницы недоступны."

#. type: Plain text
#: man-pages/man2/mmap.2:130
msgid ""
"The I<flags> argument determines whether updates to the mapping are visible "
"to other processes mapping the same region, and whether updates are carried "
"through to the underlying file.  This behavior is determined by including "
"exactly one of the following values in I<flags>:"
msgstr "В аргументе I<flags> задаётся будут ли изменения отображения видимы другим процессам, отображающим ту же область, и будут ли изменения перенесены в отображённый файл. Данное поведение определяется в I<flags> одним из следующих значений:"

#. type: TP
#: man-pages/man2/mmap.2:130
#, no-wrap
msgid "B<MAP_SHARED>"
msgstr "B<MAP_SHARED>"

#. type: Plain text
#: man-pages/man2/mmap.2:139
msgid ""
"Share this mapping.  Updates to the mapping are visible to other processes "
"mapping the same region, and (in the case of file-backed mappings)  are "
"carried through to the underlying file.  (To precisely control when updates "
"are carried through to the underlying file requires the use of B<msync>(2).)"
msgstr "Сделать отображение общим. Изменения отображения видимы всем процессам, отображающим ту же область и (если отображение выполняется из файла) изменения заносятся в отображённый файл (для более точного контроля над изменениями файла нужно использовать B<msync>(2))."

#. type: TP
#: man-pages/man2/mmap.2:139
#, no-wrap
msgid "B<MAP_SHARED_VALIDATE> (since Linux 4.15)"
msgstr "B<MAP_SHARED_VALIDATE> (начиная с Linux 4.15)"

#. type: Plain text
#: man-pages/man2/mmap.2:156
msgid ""
"This flag provides the same behavior as B<MAP_SHARED> except that "
"B<MAP_SHARED> mappings ignore unknown flags in I<flags>.  By contrast, when "
"creating a mapping using B<MAP_SHARED_VALIDATE>, the kernel verifies all "
"passed flags are known and fails the mapping with the error B<EOPNOTSUPP> "
"for unknown flags.  This mapping type is also required to be able to use "
"some mapping flags (e.g., B<MAP_SYNC>)."
msgstr "Данный флаг представляет тоже, что и B<MAP_SHARED>, отображения B<MAP_SHARED> игнорируют неизвестные флаги I<flags>. Если же отображение создаётся с B<MAP_SHARED_VALIDATE>, ядро проверят, что ему известны все переданные флаги и завершает отображение ошибкой B<EOPNOTSUPP>, если есть неизвестные флаги. Этот тип отображения также требуется для использования некоторых флагов отображения (например, B<MAP_SYNC>)."

#. type: TP
#: man-pages/man2/mmap.2:156
#, no-wrap
msgid "B<MAP_PRIVATE>"
msgstr "B<MAP_PRIVATE>"

#. type: Plain text
#: man-pages/man2/mmap.2:165
msgid ""
"Create a private copy-on-write mapping.  Updates to the mapping are not "
"visible to other processes mapping the same file, and are not carried "
"through to the underlying file.  It is unspecified whether changes made to "
"the file after the B<mmap>()  call are visible in the mapped region."
msgstr "Создать закрытое отображение с механизмом копирования при записи. Изменения отображения невидимы другим процессам, отображающим тот же файл, и сам файл не изменяется. Не определено, будут ли видимы в отображённой области изменения в файле, сделанные после вызова B<mmap>()."

#. type: Plain text
#: man-pages/man2/mmap.2:173
msgid ""
"Both B<MAP_SHARED> and B<MAP_PRIVATE> are described in POSIX.1-2001 and "
"POSIX.1-2008.  B<MAP_SHARED_VALIDATE> is a Linux extension."
msgstr "Флаги B<MAP_SHARED> и B<MAP_PRIVATE> описаны в POSIX.1-2001 и POSIX.1-2008. Флаг B<MAP_SHARED_VALIDATE> является расширением Linux."

#. type: Plain text
#: man-pages/man2/mmap.2:176
msgid ""
"In addition, zero or more of the following values can be ORed in I<flags>:"
msgstr "Кроме этого в I<flags> могут быть указаны (побитовым сложением):"

#. type: TP
#: man-pages/man2/mmap.2:176
#, no-wrap
msgid "B<MAP_32BIT> (since Linux 2.4.20, 2.6)"
msgstr "B<MAP_32BIT> (начиная с Linux 2.4.20, 2.6)"

#.  See http://lwn.net/Articles/294642 "Tangled up in threads", 19 Aug 08
#. type: Plain text
#: man-pages/man2/mmap.2:192
msgid ""
"Put the mapping into the first 2 Gigabytes of the process address space.  "
"This flag is supported only on x86-64, for 64-bit programs.  It was added to"
" allow thread stacks to be allocated somewhere in the first 2\\ GB of "
"memory, so as to improve context-switch performance on some early 64-bit "
"processors.  Modern x86-64 processors no longer have this performance "
"problem, so use of this flag is not required on those systems.  The "
"B<MAP_32BIT> flag is ignored when B<MAP_FIXED> is set."
msgstr "Поместить отображение в первые 2 гигабайта адресного пространства процесса. Этот флаг поддерживается только на архитектуре x86-64 для 64-битных программ. Он был добавлен для размещения стеков нитей в первых 2\\ ГБ памяти, что даёт увеличение производительности при переключения контекста на некоторых первых 64-битных процессорах. В современных процессорах x86-64 такой проблемы с производительностью больше нет, поэтому на таких системах данный флаг больше не требуется. Он игнорируется, если указан флаг B<MAP_FIXED>."

#. type: TP
#: man-pages/man2/mmap.2:192
#, no-wrap
msgid "B<MAP_ANON>"
msgstr "B<MAP_ANON>"

#. type: Plain text
#: man-pages/man2/mmap.2:197
msgid "Synonym for B<MAP_ANONYMOUS>.  Deprecated."
msgstr "Синоним B<MAP_ANONYMOUS>. Устарел."

#. type: TP
#: man-pages/man2/mmap.2:197
#, no-wrap
msgid "B<MAP_ANONYMOUS>"
msgstr "B<MAP_ANONYMOUS>"

#.  See the pgoff overflow check in do_mmap().
#.  See the offset check in sys_mmap in arch/x86/kernel/sys_x86_64.c.
#. type: Plain text
#: man-pages/man2/mmap.2:222
msgid ""
"The mapping is not backed by any file; its contents are initialized to zero."
"  The I<fd> argument is ignored; however, some implementations require I<fd>"
" to be -1 if B<MAP_ANONYMOUS> (or B<MAP_ANON>)  is specified, and portable "
"applications should ensure this.  The I<offset> argument should be zero.  "
"The use of B<MAP_ANONYMOUS> in conjunction with B<MAP_SHARED> is supported "
"on Linux only since kernel 2.4."
msgstr "Отображение не привязанное к файлу; его содержимое инициализируется нулями. Аргумент I<fd> игнорируется ; однако в некоторых реализациях при указании B<MAP_ANONYMOUS> (или B<MAP_ANON>) требуется указывать I<fd> равное -1, и так нужно поступать для переносимости приложений.  Аргумент I<offset> должен быть ноль.  Использование B<MAP_ANONYMOUS> вместе с B<MAP_SHARED> поддерживается в Linux только начиная с ядра версии 2.4."

#. type: TP
#: man-pages/man2/mmap.2:222
#, no-wrap
msgid "B<MAP_DENYWRITE>"
msgstr "B<MAP_DENYWRITE>"

#.  Introduced in 1.1.36, removed in 1.3.24.
#. type: Plain text
#: man-pages/man2/mmap.2:230
msgid ""
"This flag is ignored.  (Long ago\\(emLinux 2.0 and earlier\\(emit signaled "
"that attempts to write to the underlying file should fail with B<ETXTBUSY>."
"  But this was a source of denial-of-service attacks.)"
msgstr "Этот флаг игнорируется (раньше — Linux 2.0 и старее — он обозначал, что попытки записи в подчинённые файлы должны завершаться с кодом ошибки B<ETXTBUSY>. Но это стало основой для атак типа отказа в обслуживании)."

#. type: TP
#: man-pages/man2/mmap.2:230
#, no-wrap
msgid "B<MAP_EXECUTABLE>"
msgstr "B<MAP_EXECUTABLE>"

#.  Introduced in 1.1.38, removed in 1.3.24. Flag tested in proc_follow_link.
#.  (Long ago, it signaled that the underlying file is an executable.
#.  However, that information was not really used anywhere.)
#.  Linus talked about DOS related to MAP_EXECUTABLE, but he was thinking of
#.  MAP_DENYWRITE?
#. type: Plain text
#: man-pages/man2/mmap.2:238
msgid "This flag is ignored."
msgstr "Этот флаг игнорируется."

#. type: TP
#: man-pages/man2/mmap.2:238
#, no-wrap
msgid "B<MAP_FILE>"
msgstr "B<MAP_FILE>"

#.  On some systems, this was required as the opposite of
#.  MAP_ANONYMOUS -- mtk, 1 May 2007
#. type: Plain text
#: man-pages/man2/mmap.2:244
msgid "Compatibility flag.  Ignored."
msgstr "Флаг для совместимости, игнорируется."

#. type: TP
#: man-pages/man2/mmap.2:244
#, no-wrap
msgid "B<MAP_FIXED>"
msgstr "B<MAP_FIXED>"

#. type: Plain text
#: man-pages/man2/mmap.2:262
msgid ""
"Don't interpret I<addr> as a hint: place the mapping at exactly that "
"address.  I<addr> must be suitably aligned: for most architectures a "
"multiple of the page size is sufficient; however, some architectures may "
"impose additional restrictions.  If the memory region specified by I<addr> "
"and I<len> overlaps pages of any existing mapping(s), then the overlapped "
"part of the existing mapping(s) will be discarded.  If the specified address"
" cannot be used, B<mmap>()  will fail."
msgstr "Не учитывать I<addr> как подсказку: помещать отображение точно по этому адресу. Значение I<addr> должно быть выровнено соответствующим образом: на большинстве архитектур оно должно быть кратно размеру страницы; однако некоторые архитектуры могут накладывать дополнительные ограничения. Если область памяти, задаваемая I<addr> и I<len>, перекрывается со страницами существующих отображений, то перекрывающаяся часть существующих отображений будет отброшена. Если заданный адрес не может быть использован, то вызов B<mmap>() завершается ошибкой."

#. type: Plain text
#: man-pages/man2/mmap.2:270
msgid ""
"Software that aspires to be portable should use the B<MAP_FIXED> flag with "
"care, keeping in mind that the exact layout of a process's memory mappings "
"is allowed to change significantly between kernel versions, C library "
"versions, and operating system releases.  I<Carefully read the discussion of"
" this flag in NOTES!>"
msgstr "В переносимом ПО флаг B<MAP_FIXED> нужно использовать осторожно, так как точная раскладка процесса в памяти, доступная для изменения, может значительно отличаться в разных версиях ядер, библиотеки С и выпусках операционной системы. I<Внимательно прочитайте описание этого флага в ЗАМЕЧАНИЯХ!>"

#. type: TP
#: man-pages/man2/mmap.2:270
#, no-wrap
msgid "B<MAP_FIXED_NOREPLACE> (since Linux 4.17)"
msgstr "B<MAP_FIXED_NOREPLACE> (начиная с Linux 4.17)"

#.  commit a4ff8e8620d3f4f50ac4b41e8067b7d395056843
#. type: Plain text
#: man-pages/man2/mmap.2:286
msgid ""
"This flag provides behavior that is similar to B<MAP_FIXED> with respect to "
"the I<addr> enforcement, but differs in that B<MAP_FIXED_NOREPLACE> never "
"clobbers a preexisting mapped range.  If the requested range would collide "
"with an existing mapping, then this call fails with the error B<EEXIST.> "
"This flag can therefore be used as a way to atomically (with respect to "
"other threads) attempt to map an address range: one thread will succeed; all"
" others will report failure."
msgstr "Данный флаг действует схожим с B<MAP_FIXED> образом при контроле I<addr>, но в отличие от него, флаг B<MAP_FIXED_NOREPLACE> никогда не разделяет уже существующий отображённый диапазон. Если запрошенный диапазон пересекается с существующим отображением, то такой вызов завершается ошибкой B<EEXIST>. Поэтому данный флаг можно использовать как атомарную (если есть другие нити) попытку отображения адресного диапазона: для одной нити она закончится успешно; все остальные получат ошибку."

#. type: Plain text
#: man-pages/man2/mmap.2:296
msgid ""
"Note that older kernels which do not recognize the B<MAP_FIXED_NOREPLACE> "
"flag will typically (upon detecting a collision with a preexisting mapping)"
"  fall back to a \"non-B<MAP_FIXED>\" type of behavior: they will return an "
"address that is different from the requested address.  Therefore, backward-"
"compatible software should check the returned address against the requested "
"address."
msgstr "Заметим, что старые ядра, не понимающие флаг B<MAP_FIXED_NOREPLACE>, обычно (при обнаружении пересечения с существующим отображением) переходят к запасному варианту поведения, «не B<MAP_FIXED>»: они возвращают адрес, отличающийся от запрашиваемого адреса. Поэтому, ПО с обратной совместимостью должно сравнивать возращённый адрес с запрашиваемым."

#. type: TP
#: man-pages/man2/mmap.2:296
#, no-wrap
msgid "B<MAP_GROWSDOWN>"
msgstr "B<MAP_GROWSDOWN>"

#. type: Plain text
#: man-pages/man2/mmap.2:310
msgid ""
"This flag is used for stacks.  It indicates to the kernel virtual memory "
"system that the mapping should extend downward in memory.  The return "
"address is one page lower than the memory area that is actually created in "
"the process's virtual address space.  Touching an address in the \"guard\" "
"page below the mapping will cause the mapping to grow by a page.  This "
"growth can be repeated until the mapping grows to within a page of the high "
"end of the next lower mapping, at which point touching the \"guard\" page "
"will result in a B<SIGSEGV> signal."
msgstr "Этот флаг используется для стеков. Для виртуальной системы памяти ядра он обозначает, что отображение должно расширяться вниз по памяти. Возвращаемый адрес указывает на одну страницу ниже области памяти, которая в действительности создаётся в виртуальном адресном пространстве процесса. Обращение к адресу ниже «защитной» страницы отображения приведёт к расширению отображения на страницу. Увеличение таким способом можно повторять до тех пор, пока рост отображения страницы верхним концом не достигнет следующего нижнего отображения, при таком обращении к «защитной» страницы возникнет сигнал B<SIGSEGV>."

#. type: TP
#: man-pages/man2/mmap.2:310
#, no-wrap
msgid "B<MAP_HUGETLB> (since Linux 2.6.32)"
msgstr "B<MAP_HUGETLB> (начиная с Linux 2.6.32)"

#. type: Plain text
#: man-pages/man2/mmap.2:316
msgid ""
"Allocate the mapping using \"huge pages.\" See the Linux kernel source file "
"I<Documentation/admin-guide/mm/hugetlbpage.rst> for further information, as "
"well as NOTES, below."
msgstr "Выделять отображение используя «огромные страницы». Дополнительную информацию смотрите в файле исходного кода ядра Linux I<Documentation/admin-guide/mm/hugetlbpage.rst>, а также следующее дополнение."

#. type: TP
#: man-pages/man2/mmap.2:316
#, no-wrap
msgid "B<MAP_HUGE_2MB>, B<MAP_HUGE_1GB> (since Linux 3.8)"
msgstr "B<MAP_HUGE_2MB>, B<MAP_HUGE_1GB> (начиная с Linux 3.8)"

#.  See https://lwn.net/Articles/533499/
#. type: Plain text
#: man-pages/man2/mmap.2:323
msgid ""
"Used in conjunction with B<MAP_HUGETLB> to select alternative hugetlb page "
"sizes (respectively, 2\\ MB and 1\\ GB)  on systems that support multiple "
"hugetlb page sizes."
msgstr "Используется как дополнение к B<MAP_HUGETLB> для выбора размера страницы hugetlb (2\\ МБ и 1\\ ГБ, соответственно), сработает только в системе которая поддерживает различные размеры больших страниц."

#. type: Plain text
#: man-pages/man2/mmap.2:333
msgid ""
"More generally, the desired huge page size can be configured by encoding the"
" base-2 logarithm of the desired page size in the six bits at the offset "
"B<MAP_HUGE_SHIFT>.  (A value of zero in this bit field provides the default "
"huge page size; the default huge page size can be discovered via the "
"I<Hugepagesize> field exposed by I</proc/meminfo>.)  Thus, the above two "
"constants are defined as:"
msgstr "Вообще, желаемый размер огромной страницы можно настроить закодировав логарифм 2 от желаемого размера страницы в шести битах со смещением B<MAP_HUGE_SHIFT> (значение нуля в этом битовом поле означает выбор значения огромной страницы по умолчанию; это значение можно найти в поле I<Hugepagesize> просмотрев файл I</proc/meminfo>). Таким образом две показанные выше константы определены как:"

#. type: Plain text
#: man-pages/man2/mmap.2:338
#, no-wrap
msgid ""
"#define MAP_HUGE_2MB    (21 E<lt>E<lt> MAP_HUGE_SHIFT)\n"
"#define MAP_HUGE_1GB    (30 E<lt>E<lt> MAP_HUGE_SHIFT)\n"
msgstr "#define MAP_HUGE_2MB    (21 E<lt>E<lt> MAP_HUGE_SHIFT)\n#define MAP_HUGE_1GB    (30 E<lt>E<lt> MAP_HUGE_SHIFT)\n"

#. type: Plain text
#: man-pages/man2/mmap.2:344
msgid ""
"The range of huge page sizes that are supported by the system can be "
"discovered by listing the subdirectories in I</sys/kernel/mm/hugepages>."
msgstr "Рабочий диапазон страниц огромного размера может быть обнаружен, перечислив подкаталоги в I</sys/kernel/mm/hugepages>."

#. type: TP
#: man-pages/man2/mmap.2:344
#, no-wrap
msgid "B<MAP_LOCKED> (since Linux 2.5.37)"
msgstr "B<MAP_LOCKED> (начиная с Linux 2.5.37)"

#.  If set, the mapped pages will not be swapped out.
#. type: Plain text
#: man-pages/man2/mmap.2:365
msgid ""
"Mark the mapped region to be locked in the same way as B<mlock>(2).  This "
"implementation will try to populate (prefault) the whole range but the "
"B<mmap>()  call doesn't fail with B<ENOMEM> if this fails.  Therefore major "
"faults might happen later on.  So the semantic is not as strong as "
"B<mlock>(2).  One should use B<mmap>()  plus B<mlock>(2)  when major faults "
"are not acceptable after the initialization of the mapping.  The "
"B<MAP_LOCKED> flag is ignored in older kernels."
msgstr "Пометить отображаемую область как заблокированную таким же образом как с помощью B<mlock>(2). Данная реализация будет пытаться заполнить (предотказ) область полностью, но вызов B<mmap>() не завершится ошибкой B<ENOMEM>, если это не удастся сделать. Поэтому действительные отказы могут произойти позднее. Такой алгоритм не совпадает с B<mlock>(2). Нужно использовать B<mmap>() плюс B<mlock>(2), если действительные отказы недопустимы после инициализации отображения. В старых ядрах флаг B<MAP_LOCKED> игнорируется."

#. type: TP
#: man-pages/man2/mmap.2:365
#, no-wrap
msgid "B<MAP_NONBLOCK> (since Linux 2.5.46)"
msgstr "B<MAP_NONBLOCK> (начиная с Linux 2.5.46)"

#. type: Plain text
#: man-pages/man2/mmap.2:380
msgid ""
"This flag is meaningful only in conjunction with B<MAP_POPULATE>.  Don't "
"perform read-ahead: create page tables entries only for pages that are "
"already present in RAM.  Since Linux 2.6.23, this flag causes "
"B<MAP_POPULATE> to do nothing.  One day, the combination of B<MAP_POPULATE> "
"and B<MAP_NONBLOCK> may be reimplemented."
msgstr "Данный флаг имеет смысл только вместе с B<MAP_POPULATE>. Не выполнять упреждающее чтение: только создать записи в таблице страниц для страниц, которые уже есть ОЗУ. Начиная с Linux 2.6.23 этот флаг приводит к тому, что выполнение работы B<MAP_POPULATE> отменяется. Когда-нибудь комбинация B<MAP_POPULATE> и B<MAP_NONBLOCK> может быть реализована заново."

#. type: TP
#: man-pages/man2/mmap.2:380
#, no-wrap
msgid "B<MAP_NORESERVE>"
msgstr "B<MAP_NORESERVE>"

#. type: Plain text
#: man-pages/man2/mmap.2:395
msgid ""
"Do not reserve swap space for this mapping.  When swap space is reserved, "
"one has the guarantee that it is possible to modify the mapping.  When swap "
"space is not reserved one might get B<SIGSEGV> upon a write if no physical "
"memory is available.  See also the discussion of the file "
"I</proc/sys/vm/overcommit_memory> in B<proc>(5).  In kernels before 2.6, "
"this flag had effect only for private writable mappings."
msgstr "Не резервировать страницы пространства подкачки для этого отображения. Если пространство подкачки резервируется, то для отображения гарантируется возможность изменения. Если оно не резервируется, то можно получить сигнал B<SIGSEGV> при записи, если физическая память будет недоступна. Смотрите также описание файла I</proc/sys/vm/overcommit_memory> в B<proc>(5). В ядрах до 2.6 этот флаг действовал только для частных доступных на запись отображений."

#. type: TP
#: man-pages/man2/mmap.2:395
#, no-wrap
msgid "B<MAP_POPULATE> (since Linux 2.5.46)"
msgstr "B<MAP_POPULATE> (начиная с Linux 2.5.46)"

#. type: Plain text
#: man-pages/man2/mmap.2:402
msgid ""
"Populate (prefault) page tables for a mapping.  For a file mapping, this "
"causes read-ahead on the file.  This will help to reduce blocking on page "
"faults later.  B<MAP_POPULATE> is supported for private mappings only since "
"Linux 2.6.23."
msgstr "Наполнить (до возникновения страничного прерывания, prefault) страничные таблицы отображения. Для файлового отображения это приводит к опережающему чтению из файла. В дальнейшем это помогает сократить блокировку по отказу страниц. Флаг B<MAP_POPULATE> поддерживается для закрытых отображений только начиная с Linux 2.6.23."

#. type: TP
#: man-pages/man2/mmap.2:402
#, no-wrap
msgid "B<MAP_STACK> (since Linux 2.6.27)"
msgstr "B<MAP_STACK> (начиная с Linux 2.6.27)"

#.  See http://lwn.net/Articles/294642 "Tangled up in threads", 19 Aug 08
#.  commit cd98a04a59e2f94fa64d5bf1e26498d27427d5e7
#.  http://thread.gmane.org/gmane.linux.kernel/720412
#.  "pthread_create() slow for many threads; also time to revisit 64b
#.   context switch optimization?"
#. type: Plain text
#: man-pages/man2/mmap.2:415
msgid ""
"Allocate the mapping at an address suitable for a process or thread stack.  "
"This flag is currently a no-op, but is used in the glibc threading "
"implementation so that if some architectures require special treatment for "
"stack allocations, support can later be transparently implemented for glibc."
msgstr "Разместить отображение по адресу, пригодному для процесса или для стека нити. В настоящее время для этого флага не выполняются какие-либо действия, но он используется для реализации нитей в glibc; если на какой-то архитектуре потребуются специальные действия по выделению стека, то позже их поддержка может быть прозрачно добавлена в glibc."

#. type: TP
#: man-pages/man2/mmap.2:415
#, no-wrap
msgid "B<MAP_SYNC> (since Linux 4.15)"
msgstr "B<MAP_SYNC> (начиная с Linux 4.15)"

#. type: Plain text
#: man-pages/man2/mmap.2:428
msgid ""
"This flag is available only with the B<MAP_SHARED_VALIDATE> mapping type; "
"mappings of type B<MAP_SHARED> will silently ignore this flag.  This flag is"
" supported only for files supporting DAX (direct mapping of persistent "
"memory).  For other files, creating a mapping with this flag results in an "
"B<EOPNOTSUPP> error."
msgstr "Данный флаг доступен только с типом отображения B<MAP_SHARED_VALIDATE>; отображения с типом B<MAP_SHARED> будут просто игнорировать этот флаг. Этот флаг поддерживается только для файлов поддерживаемых DAX (прямое отображение в постоянную память). Для остальных файлов, создание отображения с этим флагом приводит к возврату ошибки B<EOPNOTSUPP>."

#. type: Plain text
#: man-pages/man2/mmap.2:436
msgid ""
"Shared file mappings with this flag provide the guarantee that while some "
"memory is writably mapped in the address space of the process, it will be "
"visible in the same file at the same offset even after the system crashes or"
" is rebooted.  In conjunction with the use of appropriate CPU instructions, "
"this provides users of such mappings with a more efficient way of making "
"data modifications persistent."
msgstr "Общие файловые отображения с этим флагом представляют гарантию того, что пока есть часть памяти отображённая для записи в адресном пространстве процесса, она будет видима в том же файле по тому же смещению даже после падения или перезагрузки системы. Вместе с использованием соответствующих инструкций ЦП это позволяет пользователям таких отображений эффективней выполнять устойчивые изменения данных."

#. type: TP
#: man-pages/man2/mmap.2:436
#, no-wrap
msgid "B<MAP_UNINITIALIZED> (since Linux 2.6.33)"
msgstr "B<MAP_UNINITIALIZED> (начиная с Linux 2.6.33)"

#. type: Plain text
#: man-pages/man2/mmap.2:446
msgid ""
"Don't clear anonymous pages.  This flag is intended to improve performance "
"on embedded devices.  This flag is honored only if the kernel was configured"
" with the B<CONFIG_MMAP_ALLOW_UNINITIALIZED> option.  Because of the "
"security implications, that option is normally enabled only on embedded "
"devices (i.e., devices where one has complete control of the contents of "
"user memory)."
msgstr "Не очищать анонимные страницы. Этот флаг предназначен для повышения производительности на встраиваемых устройствах. Он учитывается, только если ядро было собрано с поддержкой параметра B<CONFIG_MMAP_ALLOW_UNINITIALIZED>. Так как этот параметр может привести к нарушению безопасности, обычно он устанавливается только на встраиваемых устройствах (то есть, устройствах, где только один человек имеет полный контроль над содержимым пользовательской памяти)."

#.  FIXME . for later review when Issue 8 is one day released...
#.  POSIX may add MAP_ANON in the future
#.  http://austingroupbugs.net/tag_view_page.php?tag_id=8
#.  http://austingroupbugs.net/view.php?id=850
#. type: Plain text
#: man-pages/man2/mmap.2:458
msgid ""
"Of the above flags, only B<MAP_FIXED> is specified in POSIX.1-2001 and "
"POSIX.1-2008.  However, most systems also support B<MAP_ANONYMOUS> (or its "
"synonym B<MAP_ANON>)."
msgstr "Из флагов, перечисленных выше, в POSIX.1-2001 и POSIX.1-2008 определён только B<MAP_FIXED>. Однако, большинство систем также поддерживают B<MAP_ANONYMOUS> (или его синоним  B<MAP_ANON>)."

#. type: Plain text
#: man-pages/man2/mmap.2:464
msgid ""
"Memory mapped by B<mmap>()  is preserved across B<fork>(2), with the same "
"attributes."
msgstr "Память, отображённая с помощью B<mmap>(), сохраняется при B<fork>(2) с теми же атрибутами."

#. type: Plain text
#: man-pages/man2/mmap.2:472
msgid ""
"A file is mapped in multiples of the page size.  For a file that is not a "
"multiple of the page size, the remaining memory is zeroed when mapped, and "
"writes to that region are not written out to the file.  The effect of "
"changing the size of the underlying file of a mapping on the pages that "
"correspond to added or removed regions of the file is unspecified."
msgstr "Файл отображается по кратному размеру страницы. Для файла, который не кратен размеру страницы, оставшаяся память при отображении заполняется нулями, и запись в эту область не приводит к изменению файла. Действия при изменении размера отображаемого файла на страницы, которые соответствуют добавленным или удалённым областям файла, не определены."

#. type: SS
#: man-pages/man2/mmap.2:472
#, no-wrap
msgid "munmap()"
msgstr "munmap()"

#. type: Plain text
#: man-pages/man2/mmap.2:482
msgid ""
"The B<munmap>()  system call deletes the mappings for the specified address "
"range, and causes further references to addresses within the range to "
"generate invalid memory references.  The region is also automatically "
"unmapped when the process is terminated.  On the other hand, closing the "
"file descriptor does not unmap the region."
msgstr "Системный вызов B<munmap>() удаляет отображение для указанного адресного диапазона и это приводит к тому, что дальнейшее обращение по адресам внутри диапазона приводит к генерации неправильных ссылок на память. Также для диапазона отображение автоматически удаляется при завершении работы процесса. С другой стороны, закрытие файлового дескриптора не приводит к удалению отображения диапазона."

#. type: Plain text
#: man-pages/man2/mmap.2:494
msgid ""
"The address I<addr> must be a multiple of the page size (but I<length> need "
"not be).  All pages containing a part of the indicated range are unmapped, "
"and subsequent references to these pages will generate B<SIGSEGV>.  It is "
"not an error if the indicated range does not contain any mapped pages."
msgstr "Адрес I<addr> должен быть кратен размеру страницы (но значения I<length> это не касается). Все страницы, содержащие часть указанного диапазона, удаляются из отображения и последующие ссылки на эти страницы приводят к генерации сигнала B<SIGSEGV>. Это не ошибка, если указанный диапазон не содержит каких-либо отображённых страниц."

#. type: Plain text
#: man-pages/man2/mmap.2:505
msgid ""
"On success, B<mmap>()  returns a pointer to the mapped area.  On error, the "
"value B<MAP_FAILED> (that is, I<(void\\ *)\\ -1>)  is returned, and I<errno>"
" is set to indicate the cause of the error."
msgstr "При успешном выполнении B<mmap>() возвращается указатель на отображённую область. При ошибке возвращается значение B<MAP_FAILED> (а именно, I<(void\\ *)\\ -1>) и  I<errno> устанавливается в соответствующее значение. "

#. type: Plain text
#: man-pages/man2/mmap.2:513
msgid ""
"On success, B<munmap>()  returns 0.  On failure, it returns -1, and I<errno>"
" is set to indicate the cause of the error (probably to B<EINVAL>)."
msgstr "При успешном выполнении B<munmap>() возвращает 0. При сбои возвращается -1, и код ошибки  кладётся в I<errno> (скорее всего B<EINVAL>)."

#. type: Plain text
#: man-pages/man2/mmap.2:532
msgid ""
"A file descriptor refers to a non-regular file.  Or a file mapping was "
"requested, but I<fd> is not open for reading.  Or B<MAP_SHARED> was "
"requested and B<PROT_WRITE> is set, but I<fd> is not open in read/write "
"(B<O_RDWR>)  mode.  Or B<PROT_WRITE> is set, but the file is append-only."
msgstr "Файловый дескриптор указывает на не обычный файл. Или было запрошено отображение файла (mapping), но I<fd> не открыт на чтение. Или был указан флаг B<MAP_SHARED> и установлен бит B<PROT_WRITE>, но I<fd> не открыт в режиме чтения/записи (B<O_RDWR>). Или был указан флаг B<PROT_WRITE>, но файл доступен только для дополнения."

#. type: TP
#: man-pages/man2/mmap.2:532
#, no-wrap
msgid "B<EAGAIN>"
msgstr "B<EAGAIN>"

#. type: Plain text
#: man-pages/man2/mmap.2:536
msgid ""
"The file has been locked, or too much memory has been locked (see "
"B<setrlimit>(2))."
msgstr "Файл заблокирован, или блокируется слишком много памяти (смотрите B<setrlimit>(2))."

#. type: Plain text
#: man-pages/man2/mmap.2:542
msgid ""
"I<fd> is not a valid file descriptor (and B<MAP_ANONYMOUS> was not set)."
msgstr "Значение I<fd> не является правильным файловым дескриптором (и B<MAP_ANONYMOUS> не установлен)."

#. type: Plain text
#: man-pages/man2/mmap.2:552
msgid ""
"B<MAP_FIXED_NOREPLACE> was specified in I<flags>, and the range covered by "
"I<addr> and I<length> clashes with an existing mapping."
msgstr "В I<flags> указан B<MAP_FIXED_NOREPLACE> и диапазон, покрываемый I<addr> и I<length>, пересекается с существующим отображением."

#. type: Plain text
#: man-pages/man2/mmap.2:560
msgid ""
"We don't like I<addr>, I<length>, or I<offset> (e.g., they are too large, or"
" not aligned on a page boundary)."
msgstr "Неправильное значение I<addr>, I<length> или I<offset> (например, оно либо слишком велико, либо не выровнено по границе страницы)."

#. type: Plain text
#: man-pages/man2/mmap.2:565
msgid "(since Linux 2.6.12)  I<length> was 0."
msgstr "(начиная с Linux 2.6.12) Значение I<length> равно 0."

#. type: Plain text
#: man-pages/man2/mmap.2:573
msgid ""
"I<flags> contained neither B<MAP_PRIVATE> or B<MAP_SHARED>, or contained "
"both of these values."
msgstr "Значение I<flags> не содержит B<MAP_PRIVATE> или B<MAP_SHARED>, или содержит сразу эта эти флага."

#. type: TP
#: man-pages/man2/mmap.2:573
#, no-wrap
msgid "B<ENFILE>"
msgstr "B<ENFILE>"

#.  This is for shared anonymous segments
#.  [2.6.7] shmem_zero_setup()-->shmem_file_setup()-->get_empty_filp()
#.  .TP
#.  .B ENOEXEC
#.  A file could not be mapped for reading.
#. type: Plain text
#: man-pages/man2/mmap.2:581
msgid ""
"The system-wide limit on the total number of open files has been reached."
msgstr "Достигнуто максимальное количество открытых файлов в системе."

#. type: TP
#: man-pages/man2/mmap.2:581
#, no-wrap
msgid "B<ENODEV>"
msgstr "B<ENODEV>"

#. type: Plain text
#: man-pages/man2/mmap.2:585
msgid ""
"The underlying filesystem of the specified file does not support memory "
"mapping."
msgstr "Используемая файловая система для указанного файла не поддерживает отображение памяти."

#. type: Plain text
#: man-pages/man2/mmap.2:588
msgid "No memory is available."
msgstr "Больше нет доступной памяти."

#. type: Plain text
#: man-pages/man2/mmap.2:596
msgid ""
"The process's maximum number of mappings would have been exceeded.  This "
"error can also occur for B<munmap>(), when unmapping a region in the middle "
"of an existing mapping, since this results in two smaller mappings on either"
" side of the region being unmapped."
msgstr "Процесс превысил бы ограничение на максимальное количество отображений. Эта ошибка также может возникнуть в B<munmap>() при удалении отображения области в середине существующего отображения, так как при этом выполняется удаление отображения двух отображений меньшего размера на любом конце области."

#. type: Plain text
#: man-pages/man2/mmap.2:604
msgid ""
"(since Linux 4.7)  The process's B<RLIMIT_DATA> limit, described in "
"B<getrlimit>(2), would have been exceeded."
msgstr "(начиная с Linux 4.7) Было бы превышено ограничение процесса B<RLIMIT_DATA>, описанное в B<getrlimit>(2)."

#. type: TP
#: man-pages/man2/mmap.2:604
#, no-wrap
msgid "B<EOVERFLOW>"
msgstr "B<EOVERFLOW>"

#. type: Plain text
#: man-pages/man2/mmap.2:616
msgid ""
"On 32-bit architecture together with the large file extension (i.e., using "
"64-bit I<off_t>): the number of pages used for I<length> plus number of "
"pages used for I<offset> would overflow I<unsigned long> (32 bits)."
msgstr "На 32-битной архитектуре вместе с расширением для больших файлов (т.е., используется 64-битный I<off_t>): количество страниц, используемых для I<length> плюс количество страниц, используемых для I<offset> приводит к переполнению I<unsigned long> (32 бита)."

#.  (Since 2.4.25 / 2.6.0.)
#. type: Plain text
#: man-pages/man2/mmap.2:625
msgid ""
"The I<prot> argument asks for B<PROT_EXEC> but the mapped area belongs to a "
"file on a filesystem that was mounted no-exec."
msgstr "Аргументом I<prot> запрашивается B<PROT_EXEC>, но отображённая область принадлежит файлу на файловой системе, которая смонтирована с флагом no-exec."

#. type: Plain text
#: man-pages/man2/mmap.2:629
msgid "The operation was prevented by a file seal; see B<fcntl>(2)."
msgstr "Выполнение операции предотвращено опечатыванием (file seal); смотрите B<fcntl>(2)."

#. type: TP
#: man-pages/man2/mmap.2:629
#, no-wrap
msgid "B<ETXTBSY>"
msgstr "B<ETXTBSY>"

#. type: Plain text
#: man-pages/man2/mmap.2:635
msgid ""
"B<MAP_DENYWRITE> was set but the object specified by I<fd> is open for "
"writing."
msgstr "Был задан флаг B<MAP_DENYWRITE>, но объект, указываемый I<fd>, открыт на запись."

#. type: Plain text
#: man-pages/man2/mmap.2:637
msgid "Use of a mapped region can result in these signals:"
msgstr "При использовании отображаемой области памяти могут возникать следующие сигналы:"

#. type: TP
#: man-pages/man2/mmap.2:637
#, no-wrap
msgid "B<SIGSEGV>"
msgstr "B<SIGSEGV>"

#. type: Plain text
#: man-pages/man2/mmap.2:640
msgid "Attempted write into a region mapped as read-only."
msgstr "Попытка записи в область, отображённую только для чтения."

#. type: TP
#: man-pages/man2/mmap.2:640
#, no-wrap
msgid "B<SIGBUS>"
msgstr "B<SIGBUS>"

#. type: Plain text
#: man-pages/man2/mmap.2:645
msgid ""
"Attempted access to a portion of the buffer that does not correspond to the "
"file (for example, beyond the end of the file, including the case where "
"another process has truncated the file)."
msgstr "Попытка доступа к части буфера, которая не совпадает файлом (например, она может находиться за пределами файла. Подобной является ситуация, когда другой процесс уменьшил длину файла)."

#. type: SH
#: man-pages/man2/mmap.2:645
#, no-wrap
msgid "ATTRIBUTES"
msgstr "АТРИБУТЫ"

#. type: Plain text
#: man-pages/man2/mmap.2:648
msgid ""
"For an explanation of the terms used in this section, see B<attributes>(7)."
msgstr "Описание терминов данного раздела смотрите в B<attributes>(7)."

#. type: tbl table
#: man-pages/man2/mmap.2:652
#, no-wrap
msgid "Interface"
msgstr "Интерфейс"

#. type: tbl table
#: man-pages/man2/mmap.2:652
#, no-wrap
msgid "Attribute"
msgstr "Атрибут"

#. type: tbl table
#: man-pages/man2/mmap.2:652
#, no-wrap
msgid "Value"
msgstr "Значение"

#. type: tbl table
#: man-pages/man2/mmap.2:656
#, no-wrap
msgid ""
"B<mmap>(),\n"
"B<munmap>()"
msgstr "B<mmap>(),\nB<munmap>()"

#. type: tbl table
#: man-pages/man2/mmap.2:656
#, no-wrap
msgid "Thread safety"
msgstr "Безвредность в нитях"

#. type: tbl table
#: man-pages/man2/mmap.2:656
#, no-wrap
msgid "MT-Safe"
msgstr "MT-Safe"

#.  SVr4 documents additional error codes ENXIO and ENODEV.
#.  SUSv2 documents additional error codes EMFILE and EOVERFLOW.
#. type: Plain text
#: man-pages/man2/mmap.2:662
msgid "POSIX.1-2001, POSIX.1-2008, SVr4, 4.4BSD."
msgstr "POSIX.1-2001, POSIX.1-2008, SVr4, 4.4BSD."

#. type: SH
#: man-pages/man2/mmap.2:662
#, no-wrap
msgid "AVAILABILITY"
msgstr "ДОСТУПНОСТЬ"

#.  POSIX.1-2001: It shall be defined to -1 or 0 or 200112L.
#.  -1: unavailable, 0: ask using sysconf().
#.  glibc defines it to 1.
#. type: Plain text
#: man-pages/man2/mmap.2:676
msgid ""
"On POSIX systems on which B<mmap>(), B<msync>(2), and B<munmap>()  are "
"available, B<_POSIX_MAPPED_FILES> is defined in I<E<lt>unistd.hE<gt>> to a "
"value greater than 0.  (See also B<sysconf>(3).)"
msgstr "В системах POSIX, в которых есть вызовы B<mmap>(), B<msync>(2) и B<munmap>(), значение B<_POSIX_MAPPED_FILES>, определённое в I<E<lt>unistd.hE<gt>>, больше 0 (смотрите также B<sysconf>(3))."

#. type: Plain text
#: man-pages/man2/mmap.2:689
msgid ""
"On some hardware architectures (e.g., i386), B<PROT_WRITE> implies "
"B<PROT_READ>.  It is architecture dependent whether B<PROT_READ> implies "
"B<PROT_EXEC> or not.  Portable programs should always set B<PROT_EXEC> if "
"they intend to execute code in the new mapping."
msgstr "На некоторых архитектурах (например, i386), флаг B<PROT_WRITE> подразумевает флаг B<PROT_READ>. Также от архитектуры зависит подразумевает ли B<PROT_READ> флаг B<PROT_EXEC> или нет. Переносимые программы должны всегда устанавливать B<PROT_EXEC>, если они собираются выполнять код, находящийся в отображении."

#. type: Plain text
#: man-pages/man2/mmap.2:704
msgid ""
"The portable way to create a mapping is to specify I<addr> as 0 (NULL), and "
"omit B<MAP_FIXED> from I<flags>.  In this case, the system chooses the "
"address for the mapping; the address is chosen so as not to conflict with "
"any existing mapping, and will not be 0.  If the B<MAP_FIXED> flag is "
"specified, and I<addr> is 0 (NULL), then the mapped address will be 0 "
"(NULL)."
msgstr "Переносимый способ создания отображения: указать в I<addr> значение 0 (NULL) и убрать B<MAP_FIXED> из I<flags>. В этом случае, система сама выберет адрес для отображения; адрес, выбранный таким образом, не будет будет конфликтовать с существующими отображениями и не будет равен 0. Если указан флаг B<MAP_FIXED> и значение I<addr> равно 0 (NULL), то адрес отображения будет равен 0 (NULL)."

#. type: Plain text
#: man-pages/man2/mmap.2:737
msgid ""
"Certain I<flags> constants are defined only if suitable feature test macros "
"are defined (possibly by default): B<_DEFAULT_SOURCE> with glibc 2.19 or "
"later; or B<_BSD_SOURCE> or B<_SVID_SOURCE> in glibc 2.19 and earlier.  "
"(Employing B<_GNU_SOURCE> also suffices, and requiring that macro "
"specifically would have been more logical, since these flags are all Linux-"
"specific.)  The relevant flags are: B<MAP_32BIT>, B<MAP_ANONYMOUS> (and the "
"synonym B<MAP_ANON>), B<MAP_DENYWRITE>, B<MAP_EXECUTABLE>, B<MAP_FILE>, "
"B<MAP_GROWSDOWN>, B<MAP_HUGETLB>, B<MAP_LOCKED>, B<MAP_NONBLOCK>, "
"B<MAP_NORESERVE>, B<MAP_POPULATE>, and B<MAP_STACK>."
msgstr "Некоторые константы I<flags> определены только, если определён подходящий макрос тестирования свойств (возможно, по умолчанию): B<_DEFAULT_SOURCE> в glibc 2.19 и новее; B<_BSD_SOURCE> или B<_SVID_SOURCE> в glibc 2.19 и старее (также достаточно использовать B<_GNU_SOURCE> и требовать, этот макрос логично, так как данные флаги есть только в Linux). Соответственно, флаги: B<MAP_32BIT>, B<MAP_ANONYMOUS> (и синоним B<MAP_ANON>), B<MAP_DENYWRITE>, B<MAP_EXECUTABLE>, B<MAP_FILE>, B<MAP_GROWSDOWN>, B<MAP_HUGETLB>, B<MAP_LOCKED>, B<MAP_NONBLOCK>, B<MAP_NORESERVE>, B<MAP_POPULATE> и B<MAP_STACK>."

#. type: Plain text
#: man-pages/man2/mmap.2:742
msgid ""
"An application can determine which pages of a mapping are currently resident"
" in the buffer/page cache using B<mincore>(2)."
msgstr "Приложение может определить какие страницы отображены в данный момент в буфере/страничном кэше с помощью B<mincore>(2)."

#. type: SS
#: man-pages/man2/mmap.2:742
#, no-wrap
msgid "Using MAP_FIXED safely"
msgstr "Безопасное использование MAP_FIXED"

#. type: Plain text
#: man-pages/man2/mmap.2:754
msgid ""
"The only safe use for B<MAP_FIXED> is where the address range specified by "
"I<addr> and I<length> was previously reserved using another mapping; "
"otherwise, the use of B<MAP_FIXED> is hazardous because it forcibly removes "
"preexisting mappings, making it easy for a multithreaded process to corrupt "
"its own address space."
msgstr "Единственным вариантом безопасного использования B<MAP_FIXED> является предварительное резервирование адресного пространства, указываемого в I<addr> и I<length>, другим отображением; в остальных случаях использование B<MAP_FIXED> опасно, так как оно выполняет принудительное удаление существующих отображений, что позволяет легко повредить собственное адресное пространство многонитевого процесса."

#. type: Plain text
#: man-pages/man2/mmap.2:782
msgid ""
"For example, suppose that thread A looks through I</proc/E<lt>pidE<gt>/maps>"
" and in order to locate an unused address range that it can map using "
"B<MAP_FIXED>, while thread B simultaneously acquires part or all of that "
"same address range.  When thread A subsequently employs B<mmap(MAP_FIXED)>, "
"it will effectively clobber the mapping that thread B created.  In this "
"scenario, thread B need not create a mapping directly; simply making a "
"library call that, internally, uses B<dlopen>(3)  to load some other shared "
"library, will suffice.  The B<dlopen>(3)  call will map the library into the"
" process's address space.  Furthermore, almost any library call may be "
"implemented in a way that adds memory mappings to the address space, either "
"with this technique, or by simply allocating memory.  Examples include "
"B<brk>(2), B<malloc>(3), B<pthread_create>(3), and the PAM libraries E<.UR "
"http://www.linux-pam.org> E<.UE .>"
msgstr "Предположим, например, что нить A просматривает I</proc/E<lt>pidE<gt>/maps>в поиске неиспользуемого адресного диапазона, который она сможет отобразить используя B<MAP_FIXED>, но одновременно с этим нить B захватывает часть или весь этот же адресный диапазон. Когда после этого нить A запустит B<mmap(MAP_FIXED)>, это, фактически, разобьёт отображение, созданное нитью B. В этом сценарии нити B не нужно создавать отображение явным образом; будет достаточно просто сделать библиотечный вызов, например, B<dlopen>(3) для загрузки какой-то другой общей библиотеки. Вызов B<dlopen>(3) отобразит библиотеку в адресное пространство процесса. Более того, почти каждый библиотечный вызов можно реализовать так, чтобы он добавлял отображения памяти в адресное пространство с помощью этого метода или просто выделяя память. Например, такими вызовами являются B<brk>(2), B<malloc>(3), B<pthread_create>(3) и библиотеки PAM E<.UR http://www.linux-pam.org> E<.UE .>"

#. type: Plain text
#: man-pages/man2/mmap.2:789
msgid ""
"Since Linux 4.17, a multithreaded program can use the B<MAP_FIXED_NOREPLACE>"
" flag to avoid the hazard described above when attempting to create a "
"mapping at a fixed address that has not been reserved by a preexisting "
"mapping."
msgstr "Начиная с Linux 4.17, в многонитевых программах можно использовать флаг B<MAP_FIXED_NOREPLACE> и, тем самым, избежать опасности, описанной выше, когда выполняется попытка создать отображение по фиксированному адресу, который не был зарезервирован существующим отображением."

#. type: SS
#: man-pages/man2/mmap.2:789
#, no-wrap
msgid "Timestamps changes for file-backed mappings"
msgstr "Изменение временных отметок для отображённых файлов"

#. type: Plain text
#: man-pages/man2/mmap.2:796
msgid ""
"For file-backed mappings, the I<st_atime> field for the mapped file may be "
"updated at any time between the B<mmap>()  and the corresponding unmapping; "
"the first reference to a mapped page will update the field if it has not "
"been already."
msgstr "У отображённых файлов поле I<st_atime> может измениться в любой момент между вызовом B<mmap>() и соответствующим удалением отображения; первое обращение к отображённой странице приведёт к обновлению поля, если это ещё не было сделано."

#. type: Plain text
#: man-pages/man2/mmap.2:814
msgid ""
"The I<st_ctime> and I<st_mtime> field for a file mapped with B<PROT_WRITE> "
"and B<MAP_SHARED> will be updated after a write to the mapped region, and "
"before a subsequent B<msync>(2)  with the B<MS_SYNC> or B<MS_ASYNC> flag, if"
" one occurs."
msgstr "Поля I<st_ctime> и I<st_mtime> у отображённого с помощью флагов B<PROT_WRITE> и B<MAP_SHARED> файла будут обновлены после записи отображённой области и перед последующим вызовом B<msync>(2) с флагом B<MS_SYNC> или B<MS_ASYNC>, если он будет вызван."

#. type: SS
#: man-pages/man2/mmap.2:814
#, no-wrap
msgid "Huge page (Huge TLB) mappings"
msgstr "Отображения огромных страниц (Huge TLB)"

#. type: Plain text
#: man-pages/man2/mmap.2:821
msgid ""
"For mappings that employ huge pages, the requirements for the arguments of "
"B<mmap>()  and B<munmap>()  differ somewhat from the requirements for "
"mappings that use the native system page size."
msgstr "Для отображений, работающих с огромными страницами, требования к аргументам B<mmap>() и B<munmap>() несколько отличаются от требований к отображениям, в которых используются страницы с системным размером."

#. type: Plain text
#: man-pages/man2/mmap.2:829
msgid ""
"For B<mmap>(), I<offset> must be a multiple of the underlying huge page "
"size.  The system automatically aligns I<length> to be a multiple of the "
"underlying huge page size."
msgstr "Для B<mmap>(), I<offset> должно быть кратно размеру нижележащей огромной страницы. Система автоматически выравнивает I<length> до кратного значения размера нижележащей огромной страницы."

#. type: Plain text
#: man-pages/man2/mmap.2:837
msgid ""
"For B<munmap>(), I<addr> and I<length> must both be a multiple of the "
"underlying huge page size."
msgstr "Для B<munmap>(), I<addr> и I<length> должны быть кратны размеру нижележащей огромной страницы."

#. type: SS
#: man-pages/man2/mmap.2:837
#, no-wrap
msgid "C library/kernel differences"
msgstr "Отличия между библиотекой C и ядром"

#.  Since around glibc 2.1/2.2, depending on the platform.
#. type: Plain text
#: man-pages/man2/mmap.2:852
msgid ""
"This page describes the interface provided by the glibc B<mmap>()  wrapper "
"function.  Originally, this function invoked a system call of the same name."
"  Since kernel 2.4, that system call has been superseded by B<mmap2>(2), and"
" nowadays the glibc B<mmap>()  wrapper function invokes B<mmap2>(2)  with a "
"suitably adjusted value for I<offset>."
msgstr "В данной странице описывается интерфейс, предоставляемый обёрточной функцией glibc B<mmap>(). Раньше, эта функция обращалась к системному вызову с тем же именем. Начиная с ядра 2.4, данный системный вызов был заменён на B<mmap2>(2). В настоящее время обёрточная функция glibc, B<mmap>(), вызывает B<mmap2>(2) с подходящим подкорректированным значением I<offset>."

#. type: Plain text
#: man-pages/man2/mmap.2:857
msgid ""
"On Linux, there are no guarantees like those suggested above under "
"B<MAP_NORESERVE>.  By default, any process can be killed at any moment when "
"the system runs out of memory."
msgstr "В Linux не гарантируется результат флага B<MAP_NORESERVE>, описанный выше. По умолчанию, любой процесс может быть принудительно завершён в любой момент, если в системе закончилась память."

#. type: Plain text
#: man-pages/man2/mmap.2:864
msgid ""
"In kernels before 2.6.7, the B<MAP_POPULATE> flag has effect only if I<prot>"
" is specified as B<PROT_NONE>."
msgstr "В ядрах до версии 2.6.7 флаг B<MAP_POPULATE> учитывается только, если значение I<prot> равно B<PROT_NONE>."

#. type: Plain text
#: man-pages/man2/mmap.2:879
msgid ""
"SUSv3 specifies that B<mmap>()  should fail if I<length> is 0.  However, in "
"kernels before 2.6.12, B<mmap>()  succeeded in this case: no mapping was "
"created and the call returned I<addr>.  Since kernel 2.6.12, B<mmap>()  "
"fails with the error B<EINVAL> for this case."
msgstr "В SUSv3 указано, что B<mmap>() должен завершаться с ошибкой, если I<length> равно 0. Однако в ядрах до версии 2.6.12 вызов B<mmap>() в этом случае выполняется успешно: отображение не создаётся и вызов возвращает I<addr>. Начиная с ядра версии 2.6.12, в этом случае вызов B<mmap>() завершается с ошибкой B<EINVAL>."

#. type: Plain text
#: man-pages/man2/mmap.2:896
msgid ""
"POSIX specifies that the system shall always zero fill any partial page at "
"the end of the object and that system will never write any modification of "
"the object beyond its end.  On Linux, when you write data to such partial "
"page after the end of the object, the data stays in the page cache even "
"after the file is closed and unmapped and even though the data is never "
"written to the file itself, subsequent mappings may see the modified "
"content.  In some cases, this could be fixed by calling B<msync>(2)  before "
"the unmap takes place; however, this doesn't work on B<tmpfs>(5)  (for "
"example, when using the POSIX shared memory interface documented in "
"B<shm_overview>(7))."
msgstr "В POSIX сказано, что система всегда должна заполнять нулями любую частичную страницу у конца объекта и что система никогда не должна вносить любые изменения вне пределов объекта. В Linux, если вы пишите данные в такую частичную страницу за концом объекта, то данные остаются в страничном кэше даже после закрытия и выключения отображения файла и хотя данные никогда не пишутся в сам файл, последующие отображения могут увидеть изменённое содержимое. В некоторых случаях это можно исправить вызвав B<msync>(2) перед выключением отображения; однако это не работает на B<tmpfs>(5) (например, когда используется интерфейс общей памяти POSIX, описанный в B<shm_overview>(7))."

#. type: Plain text
#: man-pages/man2/mmap.2:908
msgid ""
"The following program prints part of the file specified in its first "
"command-line argument to standard output.  The range of bytes to be printed "
"is specified via offset and length values in the second and third command-"
"line arguments.  The program creates a memory mapping of the required pages "
"of the file and then uses B<write>(2)  to output the desired bytes."
msgstr "Следующая программа выводит часть файла, указанного в первом аргументе командной строки, в стандартный вывод. Диапазон выдаваемых байт задаётся смещением и длиной во втором и третьем аргументах командной строки. Программа создаёт отображение требуемых страниц файла и затем использует B<write>(2) для вывода запрошенных байт."

#. type: Plain text
#: man-pages/man2/mmap.2:916
#, no-wrap
msgid ""
"#include E<lt>sys/mman.hE<gt>\n"
"#include E<lt>sys/stat.hE<gt>\n"
"#include E<lt>fcntl.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
msgstr "#include E<lt>sys/mman.hE<gt>\n#include E<lt>sys/stat.hE<gt>\n#include E<lt>fcntl.hE<gt>\n#include E<lt>stdio.hE<gt>\n#include E<lt>stdlib.hE<gt>\n#include E<lt>unistd.hE<gt>\n"

#. type: Plain text
#: man-pages/man2/mmap.2:919
#, no-wrap
msgid ""
"#define handle_error(msg) \\e\n"
"    do { perror(msg); exit(EXIT_FAILURE); } while (0)\n"
msgstr "#define handle_error(msg) \\e\n    do { perror(msg); exit(EXIT_FAILURE); } while (0)\n"

#. type: Plain text
#: man-pages/man2/mmap.2:929
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    char *addr;\n"
"    int fd;\n"
"    struct stat sb;\n"
"    off_t offset, pa_offset;\n"
"    size_t length;\n"
"    ssize_t s;\n"
msgstr "int\nmain(int argc, char *argv[])\n{\n    char *addr;\n    int fd;\n    struct stat sb;\n    off_t offset, pa_offset;\n    size_t length;\n    ssize_t s;\n"

#. type: Plain text
#: man-pages/man2/mmap.2:934
#, no-wrap
msgid ""
"    if (argc E<lt> 3 || argc E<gt> 4) {\n"
"        fprintf(stderr, \"%s file offset [length]\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr "    if (argc E<lt> 3 || argc E<gt> 4) {\n        fprintf(stderr, \"%s файл смещение [длина]\\en\", argv[0]);\n        exit(EXIT_FAILURE);\n    }\n"

#. type: Plain text
#: man-pages/man2/mmap.2:938
#, no-wrap
msgid ""
"    fd = open(argv[1], O_RDONLY);\n"
"    if (fd == -1)\n"
"        handle_error(\"open\");\n"
msgstr "    fd = open(argv[1], O_RDONLY);\n    if (fd == -1)\n        handle_error(\"open\");\n"

#. type: Plain text
#: man-pages/man2/mmap.2:941
#, no-wrap
msgid ""
"    if (fstat(fd, &sb) == -1)           /* To obtain file size */\n"
"        handle_error(\"fstat\");\n"
msgstr "    if (fstat(fd, &sb) == -1)           /* получение размера файла */\n        handle_error(\"fstat\");\n"

#. type: Plain text
#: man-pages/man2/mmap.2:945
#, no-wrap
msgid ""
"    offset = atoi(argv[2]);\n"
"    pa_offset = offset & ~(sysconf(_SC_PAGE_SIZE) - 1);\n"
"        /* offset for mmap() must be page aligned */\n"
msgstr "    offset = atoi(argv[2]);\n    pa_offset = offset & ~(sysconf(_SC_PAGE_SIZE) - 1);\n        /* для mmap() нужно выронить смещение */\n"

#. type: Plain text
#: man-pages/man2/mmap.2:950
#, no-wrap
msgid ""
"    if (offset E<gt>= sb.st_size) {\n"
"        fprintf(stderr, \"offset is past end of file\\en\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr "    if (offset E<gt>= sb.st_size) {\n        fprintf(stderr, \"указанное смещение находится за концом файла\\en\");\n        exit(EXIT_FAILURE);\n    }\n"

#. type: Plain text
#: man-pages/man2/mmap.2:956
#, no-wrap
msgid ""
"    if (argc == 4) {\n"
"        length = atoi(argv[3]);\n"
"        if (offset + length E<gt> sb.st_size)\n"
"            length = sb.st_size - offset;\n"
"                /* Can\\(aqt display bytes past end of file */\n"
msgstr "    if (argc == 4) {\n        length = atoi(argv[3]);\n        if (offset + length E<gt> sb.st_size)\n            length = sb.st_size - offset;\n                /* Нельзя показать байты за концом файла */\n"

#. type: Plain text
#: man-pages/man2/mmap.2:960
#, no-wrap
msgid ""
"    } else {    /* No length arg ==E<gt> display to end of file */\n"
"        length = sb.st_size - offset;\n"
"    }\n"
msgstr "    } else {    /* Не указана длина ==E<gt> показать всё до конца файла */\n        length = sb.st_size - offset;\n    }\n"

#. type: Plain text
#: man-pages/man2/mmap.2:965
#, no-wrap
msgid ""
"    addr = mmap(NULL, length + offset - pa_offset, PROT_READ,\n"
"                MAP_PRIVATE, fd, pa_offset);\n"
"    if (addr == MAP_FAILED)\n"
"        handle_error(\"mmap\");\n"
msgstr "    addr = mmap(NULL, length + offset - pa_offset, PROT_READ,\n                MAP_PRIVATE, fd, pa_offset);\n    if (addr == MAP_FAILED)\n        handle_error(\"mmap\");\n"

#. type: Plain text
#: man-pages/man2/mmap.2:970
#, no-wrap
msgid ""
"    s = write(STDOUT_FILENO, addr + offset - pa_offset, length);\n"
"    if (s != length) {\n"
"        if (s == -1)\n"
"            handle_error(\"write\");\n"
msgstr "    s = write(STDOUT_FILENO, addr + offset - pa_offset, length);\n    if (s != length) {\n        if (s == -1)\n            handle_error(\"write\");\n"

#. type: Plain text
#: man-pages/man2/mmap.2:974
#, no-wrap
msgid ""
"        fprintf(stderr, \"partial write\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr "        fprintf(stderr, \"частичная запись\");\n        exit(EXIT_FAILURE);\n    }\n"

#. type: Plain text
#: man-pages/man2/mmap.2:977
#, no-wrap
msgid ""
"    munmap(addr, length + offset - pa_offset);\n"
"    close(fd);\n"
msgstr "    munmap(addr, length + offset - pa_offset);\n    close(fd);\n"

#. type: Plain text
#: man-pages/man2/mmap.2:980
#, no-wrap
msgid ""
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr "    exit(EXIT_SUCCESS);\n}\n"

#. type: Plain text
#: man-pages/man2/mmap.2:997
msgid ""
"B<ftruncate>(2), B<getpagesize>(2), B<memfd_create>(2), B<mincore>(2), "
"B<mlock>(2), B<mmap2>(2), B<mprotect>(2), B<mremap>(2), B<msync>(2), "
"B<remap_file_pages>(2), B<setrlimit>(2), B<shmat>(2), B<userfaultfd>(2), "
"B<shm_open>(3), B<shm_overview>(7)"
msgstr "B<ftruncate>(2), B<getpagesize>(2), B<memfd_create>(2), B<mincore>(2), B<mlock>(2), B<mmap2>(2), B<mprotect>(2), B<mremap>(2), B<msync>(2), B<remap_file_pages>(2), B<setrlimit>(2), B<shmat>(2), B<userfaultfd>(2), B<shm_open>(3), B<shm_overview>(7)"

#. type: Plain text
#: man-pages/man2/mmap.2:1004
msgid ""
"The descriptions of the following files in B<proc>(5): I</proc/[pid]/maps>, "
"I</proc/[pid]/map_files>, and I</proc/[pid]/smaps>."
msgstr "Описание в B<proc>(5) следующих файлов: I</proc/[pid]/maps>, I</proc/[pid]/map_files> и I</proc/[pid]/smaps>."

#. type: Plain text
#: man-pages/man2/mmap.2:1005
msgid "B.O. Gallmeister, POSIX.4, O'Reilly, pp. 128\\(en129 and 389\\(en391."
msgstr "B.O. Gallmeister, POSIX.4, O'Reilly, страницы 128\\(en129 и 389\\(en391."

#. type: TH
#: man-pages/man2/msgctl.2:38
#, no-wrap
msgid "MSGCTL"
msgstr "MSGCTL"

#. type: Plain text
#: man-pages/man2/msgctl.2:41
msgid "msgctl - System V message control operations"
msgstr "msgctl - операции для работы с сообщениями System V"

#. type: Plain text
#: man-pages/man2/msgctl.2:46
#, no-wrap
msgid ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>sys/ipc.hE<gt>>\n"
"B<#include E<lt>sys/msg.hE<gt>>\n"
msgstr "B<#include E<lt>sys/types.hE<gt>>\nB<#include E<lt>sys/ipc.hE<gt>>\nB<#include E<lt>sys/msg.hE<gt>>\n"

#. type: Plain text
#: man-pages/man2/msgctl.2:48
#, no-wrap
msgid ""
"B<int msgctl(int >I<msqid>B<, int >I<cmd>B<, struct msqid_ds *>I<buf>B<);>\n"
msgstr "B<int msgctl(int >I<msqid>B<, int >I<cmd>B<, struct msqid_ds *>I<buf>B<);>\n"

#. type: Plain text
#: man-pages/man2/msgctl.2:55
msgid ""
"B<msgctl>()  performs the control operation specified by I<cmd> on the "
"System\\ V message queue with identifier I<msqid>."
msgstr "Вызов B<msgctl>() выполняет операцию, заданную в I<cmd>, над очередью сообщений System\\ V с идентификатором I<msqid>."

#. type: Plain text
#: man-pages/man2/msgctl.2:59
msgid ""
"The I<msqid_ds> data structure is defined in I<E<lt>sys/msg.hE<gt>> as "
"follows:"
msgstr "Структура данных I<msqid_ds> определена в I<E<lt>sys/msg.hE<gt>> следующим образом:"

#. type: Plain text
#: man-pages/man2/msgctl.2:76
#, no-wrap
msgid ""
"struct msqid_ds {\n"
"    struct ipc_perm msg_perm;     /* Ownership and permissions */\n"
"    time_t          msg_stime;    /* Time of last msgsnd(2) */\n"
"    time_t          msg_rtime;    /* Time of last msgrcv(2) */\n"
"    time_t          msg_ctime;    /* Time of last change */\n"
"    unsigned long   __msg_cbytes; /* Current number of bytes in\n"
"                                     queue (nonstandard) */\n"
"    msgqnum_t       msg_qnum;     /* Current number of messages\n"
"                                     in queue */\n"
"    msglen_t        msg_qbytes;   /* Maximum number of bytes\n"
"                                     allowed in queue */\n"
"    pid_t           msg_lspid;    /* PID of last msgsnd(2) */\n"
"    pid_t           msg_lrpid;    /* PID of last msgrcv(2) */\n"
"};\n"
msgstr "struct msqid_ds {\n    struct ipc_perm msg_perm;     /* владелец и права */\n    time_t          msg_stime;    /* время последнего msgsnd(2) */\n    time_t          msg_rtime;    /* время последнего msgrcv(2) */\n    time_t          msg_ctime;    /* время последнего изменения */\n    unsigned long   __msg_cbytes; /* текущее количество байт в\n                                     очереди (нет в стандарте) */\n    msgqnum_t       msg_qnum;     /* текущее количество сообщений\n                                     в очереди */\n    msglen_t        msg_qbytes;   /* максимальное количество байт\n                                     для очереди */\n    pid_t           msg_lspid;    /* PID последнего msgsnd(2) */\n    pid_t           msg_lrpid;    /* PID последнего msgrcv(2) */\n};\n"

#. type: Plain text
#: man-pages/man2/msgctl.2:84
msgid ""
"The I<ipc_perm> structure is defined as follows (the highlighted fields are "
"settable using B<IPC_SET>):"
msgstr "Структура I<ipc_perm> определена следующим образом (значения полей устанавливаются с помощью B<IPC_SET>):"

#. type: Plain text
#: man-pages/man2/msgctl.2:96
#, no-wrap
msgid ""
"struct ipc_perm {\n"
"    key_t          __key;       /* Key supplied to msgget(2) */\n"
"    uid_t          B<uid>;         /* Effective UID of owner */\n"
"    gid_t          B<gid>;         /* Effective GID of owner */\n"
"    uid_t          cuid;        /* Effective UID of creator */\n"
"    gid_t          cgid;        /* Effective GID of creator */\n"
"    unsigned short B<mode>;        /* Permissions */\n"
"    unsigned short __seq;       /* Sequence number */\n"
"};\n"
msgstr "struct ipc_perm {\n    key_t          __key;       /* ключ, передаваемый в msgget(2) */\n    uid_t          B<uid>;         /* эффективный UID владельца */\n    gid_t          B<gid>;         /* эффективный GID владельца */\n    uid_t          cuid;        /* эффективный UID создателя */\n    gid_t          cgid;        /* эффективный GID создателя */\n    unsigned short B<mode>;        /* права */\n    unsigned short __seq;       /* порядковый номер */\n};\n"

#. type: Plain text
#: man-pages/man2/msgctl.2:102
msgid "Valid values for I<cmd> are:"
msgstr "Возможные значения I<cmd>:"

#. type: TP
#: man-pages/man2/msgctl.2:102
#, no-wrap
msgid "B<IPC_STAT>"
msgstr "B<IPC_STAT>"

#. type: Plain text
#: man-pages/man2/msgctl.2:111
msgid ""
"Copy information from the kernel data structure associated with I<msqid> "
"into the I<msqid_ds> structure pointed to by I<buf>.  The caller must have "
"read permission on the message queue."
msgstr "Копирует информацию из структуры данных ядра, связанной с I<msqid>, в структуру I<msqid_ds>, расположенную по адресу I<buf>. Вызывающий должен иметь права на чтение очереди сообщений."

#. type: TP
#: man-pages/man2/msgctl.2:111
#, no-wrap
msgid "B<IPC_SET>"
msgstr "B<IPC_SET>"

#. type: Plain text
#: man-pages/man2/msgctl.2:138
msgid ""
"Write the values of some members of the I<msqid_ds> structure pointed to by "
"I<buf> to the kernel data structure associated with this message queue, "
"updating also its I<msg_ctime> member.  The following members of the "
"structure are updated: I<msg_qbytes>, I<msg_perm.uid>, I<msg_perm.gid>, and "
"(the least significant 9 bits of)  I<msg_perm.mode>.  The effective UID of "
"the calling process must match the owner (I<msg_perm.uid>)  or creator "
"(I<msg_perm.cuid>)  of the message queue, or the caller must be privileged."
"  Appropriate privilege (Linux: the B<CAP_SYS_RESOURCE> capability) is "
"required to raise the I<msg_qbytes> value beyond the system parameter "
"B<MSGMNB>."
msgstr "Записывает значения некоторых полей структуры I<msqid_ds>, адрес которой указан в I<buf>, в структуру данных ядра, связанную с этой очередью сообщений, обновляя при этом её поле I<msg_ctime>. Обновляются следующие поля структуры: I<msg_qbytes>, I<msg_perm.uid>, I<msg_perm.gid> и I<msg_perm.mode> (младшие 9 бит). Эффективный UID вызывающего процесса должен совпадать с идентификатором владельца (I<msg_perm.uid>) или создателя (I<msg_perm.cuid>) очереди сообщений, или вызывающий должен иметь привилегии. Для указания значения I<msg_qbytes> большего чем значение системного параметра B<MSGMNB> также требуются соответствующие привилегии (Linux: мандат B<CAP_SYS_RESOURCE>)."

#. type: TP
#: man-pages/man2/msgctl.2:138
#, no-wrap
msgid "B<IPC_RMID>"
msgstr "B<IPC_RMID>"

#. type: Plain text
#: man-pages/man2/msgctl.2:152
msgid ""
"Immediately remove the message queue, awakening all waiting reader and "
"writer processes (with an error return and I<errno> set to B<EIDRM>).  The "
"calling process must have appropriate privileges or its effective user ID "
"must be either that of the creator or owner of the message queue.  The third"
" argument to B<msgctl>()  is ignored in this case."
msgstr "Немедленно удаляет очередь сообщений, «будя» все процессы, ожидающие записи или чтения этой очереди (при этом возвращается ошибка, а переменная I<errno> приобретает значение B<EIDRM>). Вызывающий процесс должен иметь соответствующие привилегии или его эффективный идентификатор пользователя должен совпадать с идентификатором создателя или владельца очереди сообщений. Третий аргумент B<msgctl>() в этом случае игнорируется."

#. type: TP
#: man-pages/man2/msgctl.2:152
#, no-wrap
msgid "B<IPC_INFO> (Linux-specific)"
msgstr "B<IPC_INFO> (есть только в Linux)"

#. type: Plain text
#: man-pages/man2/msgctl.2:165
msgid ""
"Return information about system-wide message queue limits and parameters in "
"the structure pointed to by I<buf>.  This structure is of type I<msginfo> "
"(thus, a cast is required), defined in I<E<lt>sys/msg.hE<gt>> if the "
"B<_GNU_SOURCE> feature test macro is defined:"
msgstr "Возвращает параметры и информацию о системных максимальных значениях очереди сообщений в структуре, указанной в I<buf>. Данная структура имеет тип I<msginfo> (то есть, требуется приведение типов) и определена в I<E<lt>sys/msg.hE<gt>>, если определён макрос тестирования свойств B<_GNU_SOURCE>:"

#. type: Plain text
#: man-pages/man2/msgctl.2:189
#, no-wrap
msgid ""
"struct msginfo {\n"
"    int msgpool; /* Size in kibibytes of buffer pool\n"
"                    used to hold message data;\n"
"                    unused within kernel */\n"
"    int msgmap;  /* Maximum number of entries in message\n"
"                    map; unused within kernel */\n"
"    int msgmax;  /* Maximum number of bytes that can be\n"
"                    written in a single message */\n"
"    int msgmnb;  /* Maximum number of bytes that can be\n"
"                    written to queue; used to initialize\n"
"                    msg_qbytes during queue creation\n"
"                    (msgget(2)) */\n"
"    int msgmni;  /* Maximum number of message queues */\n"
"    int msgssz;  /* Message segment size;\n"
"                    unused within kernel */\n"
"    int msgtql;  /* Maximum number of messages on all queues\n"
"                    in system; unused within kernel */\n"
"    unsigned short int msgseg;\n"
"                 /* Maximum number of segments;\n"
"                    unused within kernel */\n"
"};\n"
msgstr "struct msginfo {\n    int msgpool; /* размер в килобайтах буферного пула,\n                    используемого для хранения данных сообщения;\n                    ядром не используется */\n    int msgmap;  /* максимальное количество элементов в карте\n                    сообщений; ядром не используется */\n    int msgmax;  /* максимальное количество байт, которые могут быть\n                    записаны в одно сообщение */\n    int msgmnb;  /* максимальное количество байт, которое можно\n                    записать в очередь; используется для инициализации\n                    msg_qbytes во время создания очереди\n                    (msgget(2)) */\n    int msgmni;  /* максимальное количество очередей сообщений */\n    int msgssz;  /* размер сегмента сообщения;\n                    ядром не используется */\n    int msgtql;  /* максимальное количество сообщений во всех очередях\n                    в системе; ядром не используется */\n    unsigned short int msgseg;\n                 /* максимальное количество сегментов;\n                    ядром не используется */\n};\n"

#. type: Plain text
#: man-pages/man2/msgctl.2:202
msgid ""
"The I<msgmni>, I<msgmax>, and I<msgmnb> settings can be changed via I</proc>"
" files of the same name; see B<proc>(5)  for details."
msgstr "Значения I<msgmni>, I<msgmax> и I<msgmnb> можно изменить с помощью файлов в I</proc> с теми же именами; подробней смотрите B<proc>(5)."

#. type: TP
#: man-pages/man2/msgctl.2:202
#, no-wrap
msgid "B<MSG_INFO> (Linux-specific)"
msgstr "B<MSG_INFO> (есть только в Linux)"

#. type: Plain text
#: man-pages/man2/msgctl.2:219
msgid ""
"Return a I<msginfo> structure containing the same information as for "
"B<IPC_INFO>, except that the following fields are returned with information "
"about system resources consumed by message queues: the I<msgpool> field "
"returns the number of message queues that currently exist on the system; the"
" I<msgmap> field returns the total number of messages in all queues on the "
"system; and the I<msgtql> field returns the total number of bytes in all "
"messages in all queues on the system."
msgstr "Возвращает структуру I<msginfo>, содержащую такую же информацию что и при операции B<IPC_INFO>, за исключением того, что возвращаемые значения полей содержат информацию о системных ресурсах, потребляемых очередями сообщений: в поле I<msgpool> возвращается количество очередей сообщений, которые в данный момент находятся в системе; в поле I<msgmap> возвращается общее количество сообщений во всех очередях системы; в поле I<msgtql> возвращается общее количество байт во всех сообщениях во всех очередях системы."

#. type: TP
#: man-pages/man2/msgctl.2:219
#, no-wrap
msgid "B<MSG_STAT> (Linux-specific)"
msgstr "B<MSG_STAT> (есть только в Linux)"

#. type: Plain text
#: man-pages/man2/msgctl.2:230
msgid ""
"Return a I<msqid_ds> structure as for B<IPC_STAT>.  However, the I<msqid> "
"argument is not a queue identifier, but instead an index into the kernel's "
"internal array that maintains information about all message queues on the "
"system."
msgstr "Возвращает структуру I<msqid_ds> как в операции B<IPC_STAT>. Однако аргумент I<msqid> является не уникальным идентификатором, а индексом во внутреннем массиве ядра, в котором содержится информации о всех очередях сообщений в системе."

#. type: TP
#: man-pages/man2/msgctl.2:230
#, no-wrap
msgid "B<MSG_STAT_ANY> (Linux-specific, since Linux 4.17)"
msgstr "B<MSG_STAT_ANY> (есть только в Linux, начиная с Linux 4.17)"

#. type: Plain text
#: man-pages/man2/msgctl.2:243
msgid ""
"Return a I<msqid_ds> structure as for B<MSG_STAT>.  However, "
"I<msg_perm.mode> is not checked for read access for I<msqid> meaning that "
"any user can employ this operation (just as any user may read "
"I</proc/sysvipc/msg> to obtain the same information)."
msgstr "Возвращает структуру I<msqid_ds> как для B<MSG_STAT>. Однако I<msg_perm.mode> не проверяется на доступность чтения для I<msqid>, что означает, что эту операцию может выполнять пользователь (как и любой пользователь, который может прочитать эту же информацию из I</proc/sysvipc/msg>)."

#. type: Plain text
#: man-pages/man2/msgctl.2:268
msgid ""
"On success, B<IPC_STAT>, B<IPC_SET>, and B<IPC_RMID> return 0.  A successful"
" B<IPC_INFO> or B<MSG_INFO> operation returns the index of the highest used "
"entry in the kernel's internal array recording information about all message"
" queues.  (This information can be used with repeated B<MSG_STAT> or "
"B<MSG_STAT_ANY> operations to obtain information about all queues on the "
"system.)  A successful B<MSG_STAT> or B<MSG_STAT_ANY> operation returns the "
"identifier of the queue whose index was given in I<msqid>."
msgstr "При успешном выполнении B<IPC_STAT>, B<IPC_SET> и B<IPC_RMID> возвращается 0. При успешном выполнении операции B<IPC_INFO> или B<MSG_INFO> возвращается индекс самого последнего использованного элемента во внутреннем массиве ядра, в котором записана информация о всех очередях сообщений. (Эта информация может быть использована при повторяющихся операциях B<MSG_STAT> и B<MSG_STAT_ANY> для получения информации о всех очередях системы.) При успешном выполнении операции B<MSG_STAT> или B<MSG_STAT_ANY> возвращается идентификатор очереди, чей индекс был указан в I<msqid>."

#. type: Plain text
#: man-pages/man2/msgctl.2:272
msgid "On error, -1 is returned with I<errno> indicating the error."
msgstr "В случае ошибки возвращается -1, а в I<errno> записывается значение ошибки."

#. type: Plain text
#: man-pages/man2/msgctl.2:276
msgid "On failure, I<errno> is set to one of the following:"
msgstr "В случае возникновения ошибки I<errno> может принимать следующие значения:"

#. type: Plain text
#: man-pages/man2/msgctl.2:289
msgid ""
"The argument I<cmd> is equal to B<IPC_STAT> or B<MSG_STAT>, but the calling "
"process does not have read permission on the message queue I<msqid>, and "
"does not have the B<CAP_IPC_OWNER> capability in the user namespace that "
"governs its IPC namespace."
msgstr "Значение аргумента I<cmd> равно B<IPC_STAT> или B<MSG_STAT>, но вызывающий процесс не имеет прав на чтение очереди сообщений I<msqid>, и не имеет мандата B<CAP_IPC_OWNER> в пространстве имён пользователя, которое управляет его пространством имён IPC."

#. type: Plain text
#: man-pages/man2/msgctl.2:300
msgid ""
"The argument I<cmd> has the value B<IPC_SET> or B<IPC_STAT>, but the address"
" pointed to by I<buf> isn't accessible."
msgstr "Значение аргумента I<cmd> равно B<IPC_SET> или B<IPC_STAT>, но адрес, указанный в I<buf>, недоступен."

#. type: TP
#: man-pages/man2/msgctl.2:300
#, no-wrap
msgid "B<EIDRM>"
msgstr "B<EIDRM>"

#. type: Plain text
#: man-pages/man2/msgctl.2:303
msgid "The message queue was removed."
msgstr "Очередь сообщений была удалена."

#. type: Plain text
#: man-pages/man2/msgctl.2:314
msgid ""
"Invalid value for I<cmd> or I<msqid>.  Or: for a B<MSG_STAT> operation, the "
"index value specified in I<msqid> referred to an array slot that is "
"currently unused."
msgstr "Неверное значение I<cmd> или I<msqid>. Или: для операции B<MSG_STAT> значение индекса, указанного в I<msqid>, ссылается на слот массива, который в данный момент не используется."

#. type: Plain text
#: man-pages/man2/msgctl.2:332
msgid ""
"The argument I<cmd> has the value B<IPC_SET> or B<IPC_RMID>, but the "
"effective user ID of the calling process is not the creator (as found in "
"I<msg_perm.cuid>)  or the owner (as found in I<msg_perm.uid>)  of the "
"message queue, and the caller is not privileged (Linux: does not have the "
"B<CAP_SYS_ADMIN> capability)."
msgstr "Значение аргумента I<cmd> равно B<IPC_SET> или B<IPC_RMID>, но эффективный пользовательский идентификатор вызывающего процесса не равен идентификатору создателя (I<msg_perm.cuid>) или владельца (I<msg_perm.uid>) очереди сообщений, и вызывающий не имеет прав (Linux: не имеет мандата B<CAP_SYS_ADMIN>)."

#. type: Plain text
#: man-pages/man2/msgctl.2:343
msgid ""
"An attempt (B<IPC_SET>)  was made to increase I<msg_qbytes> beyond the "
"system parameter B<MSGMNB>, but the caller is not privileged (Linux: does "
"not have the B<CAP_SYS_RESOURCE> capability)."
msgstr "Была предпринята попытка (B<IPC_SET>) увеличить I<msg_qbytes> и нарушить границы системного параметра B<MSGMNB>, но вызывающий не имеет прав (Linux: не имеет мандата B<CAP_SYS_RESOURCE>)."

#.  SVID does not document the EIDRM error condition.
#. type: Plain text
#: man-pages/man2/msgctl.2:346
msgid "POSIX.1-2001, POSIX.1-2008, SVr4."
msgstr "POSIX.1-2001, POSIX.1-2008, SVr4."

#.  Like Linux, the FreeBSD man pages still document
#.  the inclusion of these header files.
#. type: Plain text
#: man-pages/man2/msgctl.2:359
msgid ""
"The inclusion of I<E<lt>sys/types.hE<gt>> and I<E<lt>sys/ipc.hE<gt>> isn't "
"required on Linux or by any version of POSIX.  However, some old "
"implementations required the inclusion of these header files, and the SVID "
"also documented their inclusion.  Applications intended to be portable to "
"such old systems may need to include these header files."
msgstr "Включение файлов I<E<lt>sys/types.hE<gt>> и I<E<lt>sys/ipc.hE<gt>> не требуется в Linux или любых версий POSIX. Однако, некоторые старые реализации требуют включения данных заголовочных файлов, и это также требуется по SVID. В приложениях, которые нужно перенести на такие старые системы, может потребоваться включить данных заголовочные файлы."

#. type: Plain text
#: man-pages/man2/msgctl.2:371
msgid ""
"The B<IPC_INFO>, B<MSG_STAT> and B<MSG_INFO> operations are used by the "
"B<ipcs>(1)  program to provide information on allocated resources.  In the "
"future these may modified or moved to a I</proc> filesystem interface."
msgstr "Операции B<IPC_INFO>, B<MSG_STAT> и B<MSG_INFO> используются программой B<ipcs>(1) для получения информации о выделенных ресурсах. В будущем для этого может быть задействован интерфейс файловой системы I</proc>."

#. type: Plain text
#: man-pages/man2/msgctl.2:385
msgid ""
"Various fields in the I<struct msqid_ds> were typed as I<short> under Linux "
"2.2 and have become I<long> under Linux 2.4.  To take advantage of this, a "
"recompilation under glibc-2.1.91 or later should suffice.  (The kernel "
"distinguishes old and new calls by an B<IPC_64> flag in I<cmd>.)"
msgstr "Различные поля в I<struct msqid_ds>, которые имели тип I<short> в Linux 2.2, в Linux 2.4 теперь имеют тип I<long>. Чтобы воспользоваться этим преимуществом достаточно пересобрать программу с glibc-2.1.91 или более новой версией. (Ядро различает старые и новые вызовы по флагу B<IPC_64> в I<cmd>.)"

#. type: Plain text
#: man-pages/man2/msgctl.2:391
msgid ""
"B<msgget>(2), B<msgrcv>(2), B<msgsnd>(2), B<capabilities>(7), "
"B<mq_overview>(7), B<sysvipc>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/memfd_create.2:21
#, no-wrap
msgid "MEMFD_CREATE"
msgstr "MEMFD_CREATE"

#. type: Plain text
#: man-pages/man2/memfd_create.2:24
msgid "memfd_create - create an anonymous file"
msgstr "memfd_create - создаёт анонимный файл"

#. type: Plain text
#: man-pages/man2/memfd_create.2:28
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>         /* See feature_test_macros(7) */\n"
"B<#include E<lt>sys/mman.hE<gt>>\n"
msgstr "B<#define _GNU_SOURCE>         /* смотрите feature_test_macros(7) */\nB<#include E<lt>sys/mman.hE<gt>>\n"

#. type: Plain text
#: man-pages/man2/memfd_create.2:30
#, no-wrap
msgid "B<int memfd_create(const char *>I<name>B<, unsigned int >I<flags>B<);>\n"
msgstr "B<int memfd_create(const char *>I<name>B<, unsigned int >I<flags>B<);>\n"

#.  David Herrmann:
#.      memfd uses VM_NORESERVE so each page is accounted on first access.
#.      This means, the overcommit-limits (see __vm_enough_memory()) and the
#.      memory-cgroup limits (mem_cgroup_try_charge()) are applied. Note that
#.      those are accounted on "current" and "current->mm", that is, the
#.      process doing the first page access.
#. type: Plain text
#: man-pages/man2/memfd_create.2:53
msgid ""
"B<memfd_create>()  creates an anonymous file and returns a file descriptor "
"that refers to it.  The file behaves like a regular file, and so can be "
"modified, truncated, memory-mapped, and so on.  However, unlike a regular "
"file, it lives in RAM and has a volatile backing storage.  Once all "
"references to the file are dropped, it is automatically released.  Anonymous"
" memory is used for all backing pages of the file.  Therefore, files created"
" by B<memfd_create>()  have the same semantics as other anonymous memory "
"allocations such as those allocated using B<mmap>(2)  with the "
"B<MAP_ANONYMOUS> flag."
msgstr "Вызов B<memfd_create>() создаёт анонимный файл и возвращает ссылающийся на него файловый дескриптор. Анонимный файл ведёт себя как обычный файл и может быть изменён, обрезан, отображён в память и т.д. Однако в отличие от обычного файла он располагается в ОЗУ и не имеет энергонезависимого хранилища. Как только все ссылки на файл удаляются, он автоматически исчезает. Анонимные файлы располагаются в анонимной памяти. Поэтому у файлов, создаваемых B<memfd_create>(), такая же семантика как и областей анонимной памяти, выделяемой с помощью B<mmap>(2) с флагом B<MAP_ANONYMOUS>."

#. type: Plain text
#: man-pages/man2/memfd_create.2:60
msgid ""
"The initial size of the file is set to 0.  Following the call, the file size"
" should be set using B<ftruncate>(2).  (Alternatively, the file may be "
"populated by calls to B<write>(2)  or similar.)"
msgstr "Первоначально, размер файла равен 0. После этого вызова нужно задать размер файла с помощью B<ftruncate>(2) (или заполнить файл с помощью B<write>(2) или подобными)."

#. type: Plain text
#: man-pages/man2/memfd_create.2:71
msgid ""
"The name supplied in I<name> is used as a filename and will be displayed as "
"the target of the corresponding symbolic link in the directory "
"I</proc/self/fd/>.  The displayed name is always prefixed with I<memfd:> and"
" serves only for debugging purposes.  Names do not affect the behavior of "
"the file descriptor, and as such multiple files can have the same name "
"without any side effects."
msgstr "Имя, указанное в I<name>, используется в качестве имени файла и будет показываться как цель соответствующей символьной ссылки в каталоге. I</proc/self/fd/>. Отображаемое имя всегда начинается с I<memfd:> и служит только для отладки. Имена не влияют на поведение файлового дескриптора и поэтому несколько файлов могут иметь одно имя без каких-либо последствий."

#. type: Plain text
#: man-pages/man2/memfd_create.2:76
msgid ""
"The following values may be bitwise ORed in I<flags> to change the behavior "
"of B<memfd_create>():"
msgstr "Для изменения поведения B<memfd_create>() можно использовать следующие  значения I<flags> (через OR):"

#. type: TP
#: man-pages/man2/memfd_create.2:76
#, no-wrap
msgid "B<MFD_CLOEXEC>"
msgstr "B<MFD_CLOEXEC>"

#. type: Plain text
#: man-pages/man2/memfd_create.2:86
msgid ""
"Set the close-on-exec (B<FD_CLOEXEC>)  flag on the new file descriptor.  See"
" the description of the B<O_CLOEXEC> flag in B<open>(2)  for reasons why "
"this may be useful."
msgstr "Устанавливает флаг close-on-exec (B<FD_CLOEXEC>) для нового открытого файлового дескриптора. Смотрите описание флага B<O_CLOEXEC> в B<open>(2) для того, чтобы узнать как это может пригодиться."

#. type: TP
#: man-pages/man2/memfd_create.2:86
#, no-wrap
msgid "B<MFD_ALLOW_SEALING>"
msgstr "B<MFD_ALLOW_SEALING>"

#.  FIXME Why is the MFD_ALLOW_SEALING behavior not simply the default?
#.  Is it worth adding some text explaining this?
#. type: Plain text
#: man-pages/man2/memfd_create.2:102
msgid ""
"Allow sealing operations on this file.  See the discussion of the "
"B<F_ADD_SEALS> and B<F_GET_SEALS> operations in B<fcntl>(2), and also NOTES,"
" below.  The initial set of seals is empty.  If this flag is not set, the "
"initial set of seals will be B<F_SEAL_SEAL>, meaning that no other seals can"
" be set on the file."
msgstr "Разрешает операции опечатывания (sealing) файла. Описание операций B<F_ADD_SEALS> и B<F_GET_SEALS> смотрите в B<fcntl>(2), а также в ЗАМЕЧАНИЯ ниже. Первоначально набор печатей пуст. Если этот флаг не установлен, то начальным набором печатей будет B<F_SEAL_SEAL>, означающий запрещение установки печатей на файл."

#. type: TP
#: man-pages/man2/memfd_create.2:102
#, no-wrap
msgid "B<MFD_HUGETLB> (since Linux 4.14)"
msgstr "B<MFD_HUGETLB> (начиная с Linux 4.14)"

#.  commit 749df87bd7bee5a79cef073f5d032ddb2b211de8
#.  commit 47b9012ecdc747f6936395265e677d41e11a31ff
#. type: Plain text
#: man-pages/man2/memfd_create.2:118
msgid ""
"The anonymous file will be created in the hugetlbfs filesystem using huge "
"pages.  See the Linux kernel source file I<Documentation/admin-"
"guide/mm/hugetlbpage.rst> for more information about hugetlbfs.  Specifying "
"both B<MFD_HUGETLB> and B<MFD_ALLOW_SEALING> in I<flags> is supported since "
"Linux 4.16."
msgstr "В файловой системе hugetlbfs, использующей огромные страницы, будет создан анонимный файл. В файле исходного кода Linux I<Documentation/admin-guide/mm/hugetlbpage.rst> дана подробная информация о hugetlbfs. Одновременное указание B<MFD_HUGETLB> и B<MFD_ALLOW_SEALING> в I<flags> поддерживается начиная с Linux 4.16."

#. type: TP
#: man-pages/man2/memfd_create.2:118
#, no-wrap
msgid "B<MFD_HUGE_2MB>, B<MFD_HUGE_1GB>, B<...>"
msgstr "B<MFD_HUGE_2MB>, B<MFD_HUGE_1GB>, B<...>"

#. type: Plain text
#: man-pages/man2/memfd_create.2:127
msgid ""
"Used in conjunction with B<MFD_HUGETLB> to select alternative hugetlb page "
"sizes (respectively, 2\\ MB, 1\\ GB, ...)  on systems that support multiple "
"hugetlb page sizes.  Definitions for known huge page sizes are included in "
"the header file I<E<lt>linux/memfd.hE<gt>.>"
msgstr "Используется как дополнение к B<MFD_HUGETLB> для выбора размера страницы hugetlb (соответственно, 2\\ МБ, 1\\ ГБ, …) в системах, которые поддерживают различные размеры страниц hugetlb. Определения размеров огромных страниц включены в заголовочный файл I<E<lt>linux/memfd.hE<gt>.>"

#. type: Plain text
#: man-pages/man2/memfd_create.2:131
msgid ""
"For details on encoding huge page sizes not included in the header file, see"
" the discussion of the similarly named constants in B<mmap>(2)."
msgstr "Дополнительную информацию о кодировании размеров огромных страниц, отсутствующих в заголовочном файле, смотрите в описании сходных по имени констант в B<mmap>(2)."

#. type: Plain text
#: man-pages/man2/memfd_create.2:135
msgid "Unused bits in I<flags> must be 0."
msgstr "Неиспользуемые биты в I<flags> должны быть равны 0."

#. type: Plain text
#: man-pages/man2/memfd_create.2:144
msgid ""
"As its return value, B<memfd_create>()  returns a new file descriptor that "
"can be used to refer to the file.  This file descriptor is opened for both "
"reading and writing (B<O_RDWR>)  and B<O_LARGEFILE> is set for the file "
"descriptor."
msgstr "В качестве возвращаемого значения B<memfd_create>() возвращает новый файловый дескриптор, который можно использовать для обращения к файлу. Данный файловый дескриптор открыт на чтение и запись (B<O_RDWR>) и в файловом дескрипторе установлен флаг B<O_LARGEFILE>."

#. type: Plain text
#: man-pages/man2/memfd_create.2:157
msgid ""
"With respect to B<fork>(2)  and B<execve>(2), the usual semantics apply for "
"the file descriptor created by B<memfd_create>().  A copy of the file "
"descriptor is inherited by the child produced by B<fork>(2)  and refers to "
"the same file.  The file descriptor is preserved across B<execve>(2), unless"
" the close-on-exec flag has been set."
msgstr "При вызове B<fork>(2) и B<execve>(2) с файловым дескриптором, созданным B<memfd_create>(), применяется обычная семантика. Копия файлового дескриптора наследуется потомком, созданным B<fork>(2), указывает на тот же файл. Файловый дескриптор сохраняется при после B<execve>(2), если не установлен флаг close-on-exec."

#. type: Plain text
#: man-pages/man2/memfd_create.2:164
msgid ""
"On success, B<memfd_create>()  returns a new file descriptor.  On error, -1 "
"is returned and I<errno> is set to indicate the error."
msgstr "При успешном выполнении B<memfd_create>() возвращает новый файловый дескриптор. При ошибке возвращается -1, и I<errno> устанавливается в соответствующее значение."

#. type: Plain text
#: man-pages/man2/memfd_create.2:170
msgid "The address in I<name> points to invalid memory."
msgstr "Некорректный адрес в I<name>."

#. type: Plain text
#: man-pages/man2/memfd_create.2:174
msgid "I<flags> included unknown bits."
msgstr "В I<flags> указаны неизвестные биты."

#.  NAME_MAX - strlen("memfd:")
#. type: Plain text
#: man-pages/man2/memfd_create.2:181
msgid ""
"I<name> was too long.  (The limit is 249 bytes, excluding the terminating "
"null byte.)"
msgstr "Значение I<name> было слишком длинным (ограничено 249 байтами, не считая конечный байт null)."

#. type: Plain text
#: man-pages/man2/memfd_create.2:189
msgid ""
"Both B<MFD_HUGETLB> and B<MFD_ALLOW_SEALING> were specified in I<flags>."
msgstr "В I<flags> указаны B<MFD_HUGETLB> и B<MFD_ALLOW_SEALING> одновременно."

#. type: TP
#: man-pages/man2/memfd_create.2:189
#, no-wrap
msgid "B<EMFILE>"
msgstr "B<EMFILE>"

#. type: Plain text
#: man-pages/man2/memfd_create.2:192
msgid ""
"The per-process limit on the number of open file descriptors has been "
"reached."
msgstr "Было достигнуто ограничение по количеству открытых файловых дескрипторов на процесс."

#. type: Plain text
#: man-pages/man2/memfd_create.2:198
msgid "There was insufficient memory to create a new anonymous file."
msgstr "Недостаточно памяти для создания нового анонимного файла."

#. type: Plain text
#: man-pages/man2/memfd_create.2:203
msgid ""
"The B<memfd_create>()  system call first appeared in Linux 3.17; glibc "
"support was added in version 2.27."
msgstr "Системный вызов B<memfd_create>() появился в Linux 3.17; поддержка в glibc началась с версии 2.27."

#. type: Plain text
#: man-pages/man2/memfd_create.2:207
msgid "The B<memfd_create>()  system call is Linux-specific."
msgstr "Системный вызов B<memfd_create>() есть только в Linux."

#.  See also http://lwn.net/Articles/593918/
#.  and http://lwn.net/Articles/594919/ and http://lwn.net/Articles/591108/
#. type: Plain text
#: man-pages/man2/memfd_create.2:221
msgid ""
"The B<memfd_create>()  system call provides a simple alternative to manually"
" mounting a B<tmpfs>(5)  filesystem and creating and opening a file in that "
"filesystem.  The primary purpose of B<memfd_create>()  is to create files "
"and associated file descriptors that are used with the file-sealing APIs "
"provided by B<fcntl>(2)."
msgstr "Системный вызов B<memfd_create>() предоставляет простую альтернативу ручному монтированию файловой системы B<tmpfs>(5), созданию и открытию файла в этой файловой системе. Основным предназначением B<memfd_create>() является создание файлов и соответствующих файловых дескрипторов, которые используются с программным интерфейсом опечатывания файлов, предоставляемым B<fcntl>(2)."

#. type: Plain text
#: man-pages/man2/memfd_create.2:235
msgid ""
"The B<memfd_create>()  system call also has uses without file sealing (which"
" is why file-sealing is disabled, unless explicitly requested with the "
"B<MFD_ALLOW_SEALING> flag).  In particular, it can be used as an alternative"
" to creating files in I<tmp> or as an alternative to using the B<open>(2)  "
"B<O_TMPFILE> in cases where there is no intention to actually link the "
"resulting file into the filesystem."
msgstr "Системный вызов B<memfd_create>() также используется и без опечатывания файла (вот почему опечатывание файлов отключено, если этого не запросить явно с помощью флага B<MFD_ALLOW_SEALING>). В частности, он может использоваться как альтернатива созданию файлов в I<tmp> или использованию B<open>(2) с B<O_TMPFILE> в случаях, когда не требуется реальная ссылка на конечный файл в файловой системе."

#. type: SS
#: man-pages/man2/memfd_create.2:235
#, no-wrap
msgid "File sealing"
msgstr "Опечатывание файла (file sealing)"

#. type: Plain text
#: man-pages/man2/memfd_create.2:253
msgid ""
"In the absence of file sealing, processes that communicate via shared memory"
" must either trust each other, or take measures to deal with the possibility"
" that an untrusted peer may manipulate the shared memory region in "
"problematic ways.  For example, an untrusted peer might modify the contents "
"of the shared memory at any time, or shrink the shared memory region.  The "
"former possibility leaves the local process vulnerable to time-of-check-to-"
"time-of-use race conditions (typically dealt with by copying data from the "
"shared memory region before checking and using it).  The latter possibility "
"leaves the local process vulnerable to B<SIGBUS> signals when an attempt is "
"made to access a now-nonexistent location in the shared memory region.  "
"(Dealing with this possibility necessitates the use of a handler for the "
"B<SIGBUS> signal.)"
msgstr "Ели файл не опечатан, то процессы, которые связываются через общую память, должны или доверять друг другу, или учитывать возможность того, что недоверенная сторона может работать с общей памятью проблемным способом. Например, недоверенная сторона может изменить содержимое общей памяти в любое время или уменьшить область общей памяти. Первая возможность делает локальный процесс уязвимым к состязательности условий «момент проверки — момент использования» (обычно решается копированием данных из области общей памяти перед проверкой и использованием). Последняя возможность делает локальный процесс уязвимым к сигналам B<SIGBUS>, которые возникают при попытке получить доступ к теперь несуществующему расположению в области общей памяти (решается использованием обработчика сигнала B<SIGBUS>)."

#. type: Plain text
#: man-pages/man2/memfd_create.2:259
msgid ""
"Dealing with untrusted peers imposes extra complexity on code that employs "
"shared memory.  Memory sealing enables that extra complexity to be "
"eliminated, by allowing a process to operate secure in the knowledge that "
"its peer can't modify the shared memory in an undesired fashion."
msgstr "Взаимодействие с недоверенными сторонами приводит к усложнению кода для работы с общей памятью. Опечатывание памяти позволяет устранить эту сложность, позволяя процессу безопасно работать, зная что его партнёр не может изменить общую память нежелательным способом."

#. type: Plain text
#: man-pages/man2/memfd_create.2:261
msgid "An example of the usage of the sealing mechanism is as follows:"
msgstr "В примере использования механизма опечатывания происходит следующее:"

#. type: IP
#: man-pages/man2/memfd_create.2:261
#, no-wrap
msgid "1."
msgstr "1."

#. type: Plain text
#: man-pages/man2/memfd_create.2:267
msgid ""
"The first process creates a B<tmpfs>(5)  file using B<memfd_create>().  The "
"call yields a file descriptor used in subsequent steps."
msgstr "Первый процесс создаёт файл B<tmpfs>(5) с помощью B<memfd_create>(). Вызов возвращает файловый дескриптор, используемый далее."

#. type: IP
#: man-pages/man2/memfd_create.2:267
#, no-wrap
msgid "2."
msgstr "2."

#. type: Plain text
#: man-pages/man2/memfd_create.2:274
msgid ""
"The first process sizes the file created in the previous step using "
"B<ftruncate>(2), maps it using B<mmap>(2), and populates the shared memory "
"with the desired data."
msgstr "Первый процесс задаёт размер файла, созданного ранее, с помощью B<ftruncate>(2), отображает его с помощью B<mmap>(2) и заполняется общую память нужными данными."

#. type: IP
#: man-pages/man2/memfd_create.2:274
#, no-wrap
msgid "3."
msgstr "3."

#. type: Plain text
#: man-pages/man2/memfd_create.2:284
msgid ""
"The first process uses the B<fcntl>(2)  B<F_ADD_SEALS> operation to place "
"one or more seals on the file, in order to restrict further modifications on"
" the file.  (If placing the seal B<F_SEAL_WRITE>, then it will be necessary "
"to first unmap the shared writable mapping created in the previous step.)"
msgstr "Первый процесс использует B<fcntl>(2) с операцией B<F_ADD_SEALS> для установки одной или более печатей на файл, чтобы в дальнейшем ограничить изменение файла (если устанавливается печать B<F_SEAL_WRITE>, то сначала нужно удалить общее доступное на запись отображение, созданное ранее)."

#. type: IP
#: man-pages/man2/memfd_create.2:284
#, no-wrap
msgid "4."
msgstr "4."

#. type: Plain text
#: man-pages/man2/memfd_create.2:289
msgid ""
"A second process obtains a file descriptor for the B<tmpfs>(5)  file and "
"maps it.  Among the possible ways in which this could happen are the "
"following:"
msgstr "Второй процесс получает файловый дескриптор файла B<tmpfs>(5) и отображает его. Варианты того, как это можно сделать:"

#. type: Plain text
#: man-pages/man2/memfd_create.2:300
msgid ""
"The process that called B<memfd_create>()  could transfer the resulting file"
" descriptor to the second process via a UNIX domain socket (see B<unix>(7)  "
"and B<cmsg>(3)).  The second process then maps the file using B<mmap>(2)."
msgstr "Процесс, вызвавший B<memfd_create>(), может переслать полученный файловый дескриптор второму процессу через доменный сокет UNIX (смотрите B<unix>(7) и B<cmsg>(3)). Второй процесс затем отображает файл с помощью B<mmap>(2)."

#. type: Plain text
#: man-pages/man2/memfd_create.2:308
msgid ""
"The second process is created via B<fork>(2)  and thus automatically "
"inherits the file descriptor and mapping.  (Note that in this case and the "
"next, there is a natural trust relationship between the two processes, since"
" they are running under the same user ID.  Therefore, file sealing would not"
" normally be necessary.)"
msgstr "Второй процесс создаётся с помощью B<fork>(2) и, таким образом, наследует файловый дескриптор и отображение (заметим, что в этом случае и следующем образуется природное доверие между двумя процессами, так как они работают с правами одного пользовательского идентификатора. Поэтому опечатывание файла здесь не нужно)."

#. type: Plain text
#: man-pages/man2/memfd_create.2:322
msgid ""
"The second process opens the file I</proc/E<lt>pidE<gt>/fd/E<lt>fdE<gt>>, "
"where I<E<lt>pidE<gt>> is the PID of the first process (the one that called "
"B<memfd_create>()), and I<E<lt>fdE<gt>> is the number of the file descriptor"
" returned by the call to B<memfd_create>()  in that process.  The second "
"process then maps the file using B<mmap>(2)."
msgstr "Второй процесс открывает файл I</proc/E<lt>pidE<gt>/fd/E<lt>fdE<gt>>, где I<E<lt>pidE<gt>> — PID первого процесса (вызвавшего B<memfd_create>()), а I<E<lt>fdE<gt>> — номер файлового дескриптора, возвращённого вызовом B<memfd_create>() в этом процессе. Затем второй процесс отображает файл с помощью B<mmap>(2)."

#. type: IP
#: man-pages/man2/memfd_create.2:323
#, no-wrap
msgid "5."
msgstr "5."

#. type: Plain text
#: man-pages/man2/memfd_create.2:335
msgid ""
"The second process uses the B<fcntl>(2)  B<F_GET_SEALS> operation to "
"retrieve the bit mask of seals that has been applied to the file.  This bit "
"mask can be inspected in order to determine what kinds of restrictions have "
"been placed on file modifications.  If desired, the second process can apply"
" further seals to impose additional restrictions (so long as the "
"B<F_SEAL_SEAL> seal has not yet been applied)."
msgstr "Второй процесс использует B<fcntl>(2) с операцией B<F_GET_SEALS> для получения битовой маски печатей, которые были применены к файлу. Данная маска проверяется, чтобы определить какие ограничения наложены на изменения файла. Если требуется, то второй процесс может наложить дополнительные печати, что ещё ограничить действия (возможно до тех пор, пока не будет наложена печать B<F_SEAL_SEAL>)."

#. type: Plain text
#: man-pages/man2/memfd_create.2:339
msgid ""
"Below are shown two example programs that demonstrate the use of "
"B<memfd_create>()  and the file sealing API."
msgstr "Далее показано два примера программы, в которых продемонстрировано использование B<memfd_create>() и программный интерфейс опечатывания файла."

#. type: Plain text
#: man-pages/man2/memfd_create.2:354
msgid ""
"The first program, I<t_memfd_create.c>, creates a B<tmpfs>(5)  file using "
"B<memfd_create>(), sets a size for the file, maps it into memory, and "
"optionally places some seals on the file.  The program accepts up to three "
"command-line arguments, of which the first two are required.  The first "
"argument is the name to associate with the file, the second argument is the "
"size to be set for the file, and the optional third argument is a string of "
"characters that specify seals to be set on file."
msgstr "Первая программа, I<t_memfd_create.c>, создаёт файл B<tmpfs>(5) с помощью B<memfd_create>(), изменяет его размер, отображает в память и, возможно, накладывает несколько печатей на файл. Программа принимает не более трёх аргументов командной строки, два первых обязательные. Первым аргументом задаётся имя файла, во втором — размер файла, а в необязательном третьем — строка символов, задающих устанавливаемые печати на файл."

#. type: Plain text
#: man-pages/man2/memfd_create.2:360
msgid ""
"The second program, I<t_get_seals.c>, can be used to open an existing file "
"that was created via B<memfd_create>()  and inspect the set of seals that "
"have been applied to that file."
msgstr "Вторая программа, I<t_get_seals.c>, может использоваться для открытия существующего файла, созданного B<memfd_create>(), и проверки набора печатей, применённых к файлу."

#. type: Plain text
#: man-pages/man2/memfd_create.2:365
msgid ""
"The following shell session demonstrates the use of these programs.  First "
"we create a B<tmpfs>(5)  file and set some seals on it:"
msgstr "Следующий пример сеанса показывает как использовать программу. Сначала создаётся файл B<tmpfs>(5) и накладываются печати:"

#. type: Plain text
#: man-pages/man2/memfd_create.2:371
#, no-wrap
msgid ""
"$ B<./t_memfd_create my_memfd_file 4096 sw &>\n"
"[1] 11775\n"
"PID: 11775; fd: 3; /proc/11775/fd/3\n"
msgstr "$ B<./t_memfd_create my_memfd_file 4096 sw &>\n[1] 11775\nPID: 11775; fd: 3; /proc/11775/fd/3\n"

#. type: Plain text
#: man-pages/man2/memfd_create.2:389
msgid ""
"At this point, the I<t_memfd_create> program continues to run in the "
"background.  From another program, we can obtain a file descriptor for the "
"file created by B<memfd_create>()  by opening the I</proc/[pid]/fd> file "
"that corresponds to the file descriptor opened by B<memfd_create>().  Using "
"that pathname, we inspect the content of the I</proc/[pid]/fd> symbolic "
"link, and use our I<t_get_seals> program to view the seals that have been "
"placed on the file:"
msgstr "После этого программа I<t_memfd_create> продолжает выполняться в фоновом режиме. Из другой программы можно получить дескриптор файла, созданный B<memfd_create>(), открыв файл I</proc/[pid]/fd>, который соответствует файловому дескриптору, открытому B<memfd_create>(). Используя это имя, можно просмотреть содержимое символьной ссылки I</proc/[pid]/fd> и использовать программу I<t_get_seals> для просмотра печатей, которые установлены на файл:"

#. type: Plain text
#: man-pages/man2/memfd_create.2:396
#, no-wrap
msgid ""
"$ B<readlink /proc/11775/fd/3>\n"
"/memfd:my_memfd_file (deleted)\n"
"$ B<./t_get_seals /proc/11775/fd/3>\n"
"Existing seals: WRITE SHRINK\n"
msgstr "$ B<readlink /proc/11775/fd/3>\n/memfd:my_memfd_file (удалён)\n$ B<./t_get_seals /proc/11775/fd/3>\nНаложенные печати: WRITE SHRINK\n"

#. type: SS
#: man-pages/man2/memfd_create.2:398
#, no-wrap
msgid "Program source: t_memfd_create.c"
msgstr "Исходный код программы: t_memfd_create.c"

#. type: Plain text
#: man-pages/man2/memfd_create.2:408
#, no-wrap
msgid ""
"#define _GNU_SOURCE\n"
"#include E<lt>sys/mman.hE<gt>\n"
"#include E<lt>fcntl.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
msgstr "#define _GNU_SOURCE\n#include E<lt>sys/mman.hE<gt>\n#include E<lt>fcntl.hE<gt>\n#include E<lt>stdlib.hE<gt>\n#include E<lt>unistd.hE<gt>\n#include E<lt>string.hE<gt>\n#include E<lt>stdio.hE<gt>\n"

#. type: Plain text
#: man-pages/man2/memfd_create.2:411 man-pages/man2/memfd_create.2:494
#, no-wrap
msgid ""
"#define errExit(msg)    do { perror(msg); exit(EXIT_FAILURE); \\e\n"
"                        } while (0)\n"
msgstr "#define errExit(msg)    do { perror(msg); exit(EXIT_FAILURE); \\e\n                        } while (0)\n"

#. type: Plain text
#: man-pages/man2/memfd_create.2:420
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int fd;\n"
"    unsigned int seals;\n"
"    char *addr;\n"
"    char *name, *seals_arg;\n"
"    ssize_t len;\n"
msgstr "int\nmain(int argc, char *argv[])\n{\n    int fd;\n    unsigned int seals;\n    char *addr;\n    char *name, *seals_arg;\n    ssize_t len;\n"

#. type: Plain text
#: man-pages/man2/memfd_create.2:431
#, no-wrap
msgid ""
"    if (argc E<lt> 3) {\n"
"        fprintf(stderr, \"%s name size [seals]\\en\", argv[0]);\n"
"        fprintf(stderr, \"\\et\\(aqseals\\(aq can contain any of the \"\n"
"                \"following characters:\\en\");\n"
"        fprintf(stderr, \"\\et\\etg - F_SEAL_GROW\\en\");\n"
"        fprintf(stderr, \"\\et\\ets - F_SEAL_SHRINK\\en\");\n"
"        fprintf(stderr, \"\\et\\etw - F_SEAL_WRITE\\en\");\n"
"        fprintf(stderr, \"\\et\\etS - F_SEAL_SEAL\\en\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr "    if (argc E<lt> 3) {\n        fprintf(stderr, \"%s имя размер [печати]\\en\", argv[0]);\n        fprintf(stderr, \"\\et в \\(aqпечати\\(aq могут быть \"\n                \"следующие символы:\\en\");\n        fprintf(stderr, \"\\et\\etg - F_SEAL_GROW\\en\");\n        fprintf(stderr, \"\\et\\ets - F_SEAL_SHRINK\\en\");\n        fprintf(stderr, \"\\et\\etw - F_SEAL_WRITE\\en\");\n        fprintf(stderr, \"\\et\\etS - F_SEAL_SEAL\\en\");\n        exit(EXIT_FAILURE);\n    }\n"

#. type: Plain text
#: man-pages/man2/memfd_create.2:435
#, no-wrap
msgid ""
"    name = argv[1];\n"
"    len = atoi(argv[2]);\n"
"    seals_arg = argv[3];\n"
msgstr "    name = argv[1];\n    len = atoi(argv[2]);\n    seals_arg = argv[3];\n"

#. type: Plain text
#: man-pages/man2/memfd_create.2:438
#, no-wrap
msgid ""
"    /* Create an anonymous file in tmpfs; allow seals to be\n"
"       placed on the file */\n"
msgstr "    /* Создаётся анонимный файл в tmpfs; на файл\n       накладываются указанные печати */\n"

#. type: Plain text
#: man-pages/man2/memfd_create.2:442
#, no-wrap
msgid ""
"    fd = memfd_create(name, MFD_ALLOW_SEALING);\n"
"    if (fd == -1)\n"
"        errExit(\"memfd_create\");\n"
msgstr "    fd = memfd_create(name, MFD_ALLOW_SEALING);\n    if (fd == -1)\n        errExit(\"memfd_create\");\n"

#. type: Plain text
#: man-pages/man2/memfd_create.2:444
#, no-wrap
msgid "    /* Size the file as specified on the command line */\n"
msgstr "    /* Размер файл как указано в командной строке */\n"

#. type: Plain text
#: man-pages/man2/memfd_create.2:447
#, no-wrap
msgid ""
"    if (ftruncate(fd, len) == -1)\n"
"        errExit(\"truncate\");\n"
msgstr "    if (ftruncate(fd, len) == -1)\n        errExit(\"truncate\");\n"

#. type: Plain text
#: man-pages/man2/memfd_create.2:450
#, no-wrap
msgid ""
"    printf(\"PID: %ld; fd: %d; /proc/%ld/fd/%d\\en\",\n"
"            (long) getpid(), fd, (long) getpid(), fd);\n"
msgstr "    printf(\"PID: %ld; fd: %d; /proc/%ld/fd/%d\\en\",\n            (long) getpid(), fd, (long) getpid(), fd);\n"

#. type: Plain text
#: man-pages/man2/memfd_create.2:453
#, no-wrap
msgid ""
"    /* Code to map the file and populate the mapping with data\n"
"       omitted */\n"
msgstr "    /* Здесь может быть код для отображения файла и заполнения данными */\n"

#. type: Plain text
#: man-pages/man2/memfd_create.2:456
#, no-wrap
msgid ""
"    /* If a \\(aqseals\\(aq command-line argument was supplied, set some\n"
"       seals on the file */\n"
msgstr "    /* Если в командной строке задан параметр \\(aqпечати\\(aq, то\n       накладываем их на файл */\n"

#. type: Plain text
#: man-pages/man2/memfd_create.2:459
#, no-wrap
msgid ""
"    if (seals_arg != NULL) {\n"
"        seals = 0;\n"
msgstr "    if (seals_arg != NULL) {\n        seals = 0;\n"

#. type: Plain text
#: man-pages/man2/memfd_create.2:468
#, no-wrap
msgid ""
"        if (strchr(seals_arg, \\(aqg\\(aq) != NULL)\n"
"            seals |= F_SEAL_GROW;\n"
"        if (strchr(seals_arg, \\(aqs\\(aq) != NULL)\n"
"            seals |= F_SEAL_SHRINK;\n"
"        if (strchr(seals_arg, \\(aqw\\(aq) != NULL)\n"
"            seals |= F_SEAL_WRITE;\n"
"        if (strchr(seals_arg, \\(aqS\\(aq) != NULL)\n"
"            seals |= F_SEAL_SEAL;\n"
msgstr "        if (strchr(seals_arg, \\(aqg\\(aq) != NULL)\n            seals |= F_SEAL_GROW;\n        if (strchr(seals_arg, \\(aqs\\(aq) != NULL)\n            seals |= F_SEAL_SHRINK;\n        if (strchr(seals_arg, \\(aqw\\(aq) != NULL)\n            seals |= F_SEAL_WRITE;\n        if (strchr(seals_arg, \\(aqS\\(aq) != NULL)\n            seals |= F_SEAL_SEAL;\n"

#. type: Plain text
#: man-pages/man2/memfd_create.2:472
#, no-wrap
msgid ""
"        if (fcntl(fd, F_ADD_SEALS, seals) == -1)\n"
"            errExit(\"fcntl\");\n"
"    }\n"
msgstr "        if (fcntl(fd, F_ADD_SEALS, seals) == -1)\n            errExit(\"fcntl\");\n    }\n"

#. type: Plain text
#: man-pages/man2/memfd_create.2:475
#, no-wrap
msgid ""
"    /* Keep running, so that the file created by memfd_create()\n"
"       continues to exist */\n"
msgstr "    /* Продолжаем выполнение для того, чтобы файл, созданный memfd_create(),\n       продолжал существовать */\n"

#. type: Plain text
#: man-pages/man2/memfd_create.2:477
#, no-wrap
msgid "    pause();\n"
msgstr "    pause();\n"

#. type: SS
#: man-pages/man2/memfd_create.2:481
#, no-wrap
msgid "Program source: t_get_seals.c"
msgstr "Исходный код программы: t_get_seals.c"

#. type: Plain text
#: man-pages/man2/memfd_create.2:491
#, no-wrap
msgid ""
"#define _GNU_SOURCE\n"
"#include E<lt>sys/mman.hE<gt>\n"
"#include E<lt>fcntl.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
msgstr "#define _GNU_SOURCE\n#include E<lt>sys/mman.hE<gt>\n#include E<lt>fcntl.hE<gt>\n#include E<lt>unistd.hE<gt>\n#include E<lt>stdlib.hE<gt>\n#include E<lt>string.hE<gt>\n#include E<lt>stdio.hE<gt>\n"

#. type: Plain text
#: man-pages/man2/memfd_create.2:500
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int fd;\n"
"    unsigned int seals;\n"
msgstr "int\nmain(int argc, char *argv[])\n{\n    int fd;\n    unsigned int seals;\n"

#. type: Plain text
#: man-pages/man2/memfd_create.2:505
#, no-wrap
msgid ""
"    if (argc != 2) {\n"
"        fprintf(stderr, \"%s /proc/PID/fd/FD\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr "    if (argc != 2) {\n        fprintf(stderr, \"%s /proc/PID/fd/FD\\en\", argv[0]);\n        exit(EXIT_FAILURE);\n    }\n"

#. type: Plain text
#: man-pages/man2/memfd_create.2:509
#, no-wrap
msgid ""
"    fd = open(argv[1], O_RDWR);\n"
"    if (fd == -1)\n"
"        errExit(\"open\");\n"
msgstr "    fd = open(argv[1], O_RDWR);\n    if (fd == -1)\n        errExit(\"open\");\n"

#. type: Plain text
#: man-pages/man2/memfd_create.2:513
#, no-wrap
msgid ""
"    seals = fcntl(fd, F_GET_SEALS);\n"
"    if (seals == -1)\n"
"        errExit(\"fcntl\");\n"
msgstr "    seals = fcntl(fd, F_GET_SEALS);\n    if (seals == -1)\n        errExit(\"fcntl\");\n"

#. type: Plain text
#: man-pages/man2/memfd_create.2:524
#, no-wrap
msgid ""
"    printf(\"Existing seals:\");\n"
"    if (seals & F_SEAL_SEAL)\n"
"        printf(\" SEAL\");\n"
"    if (seals & F_SEAL_GROW)\n"
"        printf(\" GROW\");\n"
"    if (seals & F_SEAL_WRITE)\n"
"        printf(\" WRITE\");\n"
"    if (seals & F_SEAL_SHRINK)\n"
"        printf(\" SHRINK\");\n"
"    printf(\"\\en\");\n"
msgstr "    printf(\"Наложенные печати:\");\n    if (seals & F_SEAL_SEAL)\n        printf(\" SEAL\");\n    if (seals & F_SEAL_GROW)\n        printf(\" GROW\");\n    if (seals & F_SEAL_WRITE)\n        printf(\" WRITE\");\n    if (seals & F_SEAL_SHRINK)\n        printf(\" SHRINK\");\n    printf(\"\\en\");\n"

#. type: Plain text
#: man-pages/man2/memfd_create.2:527
#, no-wrap
msgid ""
"    /* Code to map the file and access the contents of the\n"
"       resulting mapping omitted */\n"
msgstr "    /* Здесь может быть код для отображения и доступа к содержимому файла */\n"

#. type: Plain text
#: man-pages/man2/memfd_create.2:536
msgid "B<fcntl>(2), B<ftruncate>(2), B<mmap>(2), B<shmget>(2), B<shm_open>(3)"
msgstr "B<fcntl>(2), B<ftruncate>(2), B<mmap>(2), B<shmget>(2), B<shm_open>(3)"

#. type: TH
#: man-pages/man2/mknod.2:15
#, no-wrap
msgid "MKNOD"
msgstr "MKNOD"

#. type: Plain text
#: man-pages/man2/mknod.2:18
msgid "mknod, mknodat - create a special or ordinary file"
msgstr "mknod, mknodat - создаёт специальный или обычный файл"

#. type: Plain text
#: man-pages/man2/mknod.2:24
#, no-wrap
msgid ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>sys/stat.hE<gt>>\n"
"B<#include E<lt>fcntl.hE<gt>>\n"
"B<#include E<lt>unistd.hE<gt>>\n"
msgstr "B<#include E<lt>sys/types.hE<gt>>\nB<#include E<lt>sys/stat.hE<gt>>\nB<#include E<lt>fcntl.hE<gt>>\nB<#include E<lt>unistd.hE<gt>>\n"

#. type: Plain text
#: man-pages/man2/mknod.2:26
#, no-wrap
msgid ""
"B<int mknod(const char *>I<pathname>B<, mode_t >I<mode>B<, dev_t "
">I<dev>B<);>\n"
msgstr "B<int mknod(const char *>I<pathname>B<, mode_t >I<mode>B<, dev_t >I<dev>B<);>\n"

#. type: Plain text
#: man-pages/man2/mknod.2:32
#, no-wrap
msgid ""
"B<int mknodat(int >I<dirfd>B<, const char *>I<pathname>B<, mode_t "
">I<mode>B<, dev_t >I<dev>B<);>\n"
msgstr "B<int mknodat(int >I<dirfd>B<, const char *>I<pathname>B<, mode_t >I<mode>B<, dev_t >I<dev>B<);>\n"

#. type: Plain text
#: man-pages/man2/mknod.2:40
msgid "B<mknod>():"
msgstr "B<mknod>():"

#.     || _XOPEN_SOURCE\ &&\ _XOPEN_SOURCE_EXTENDED
#. type: Plain text
#: man-pages/man2/mknod.2:46
#, no-wrap
msgid ""
"_XOPEN_SOURCE\\ E<gt>=\\ 500\n"
"    || /* Since glibc 2.19: */ _DEFAULT_SOURCE\n"
"    || /* Glibc versions E<lt>= 2.19: */ _BSD_SOURCE || _SVID_SOURCE\n"
msgstr "_XOPEN_SOURCE\\ E<gt>=\\ 500\n    || /* Since glibc 2.19: */ _DEFAULT_SOURCE\n    || /* Glibc versions E<lt>= 2.19: */ _BSD_SOURCE || _SVID_SOURCE\n"

#. type: Plain text
#: man-pages/man2/mknod.2:58
msgid ""
"The system call B<mknod>()  creates a filesystem node (file, device special "
"file, or named pipe) named I<pathname>, with attributes specified by I<mode>"
" and I<dev>."
msgstr "Системный вызов B<mknod>() создаёт запись (node) в файловой системе (обычный файл, файл устройства или именованный канал) с именем I<pathname> и атрибутами, заданными в I<mode> и I<dev>."

#. type: Plain text
#: man-pages/man2/mknod.2:66
msgid ""
"The I<mode> argument specifies both the file mode to use and the type of "
"node to be created.  It should be a combination (using bitwise OR) of one of"
" the file types listed below and zero or more of the file mode bits listed "
"in B<inode>(7)."
msgstr "В аргументе I<mode> указывается используемый режим файла и тип создаваемого узла. В этом параметре должна быть битовая комбинация (используя побитовое логическое сложение ИЛИ) нуля или более режимов файла, перечисленных в B<inode>(7)."

#. type: Plain text
#: man-pages/man2/mknod.2:72
msgid ""
"The file mode is modified by the process's I<umask> in the usual way: in the"
" absence of a default ACL, the permissions of the created node are (I<mode> "
"& ~I<umask>)."
msgstr "Режим файла изменяется согласно значению I<umask> процесса: при отсутствии списка контроля доступа по умолчанию права на создаваемый узел становятся равны (I<mode> & ~I<umask>)."

#.  (S_IFSOCK since Linux 1.2.4)
#. type: Plain text
#: man-pages/man2/mknod.2:86
msgid ""
"The file type must be one of B<S_IFREG>, B<S_IFCHR>, B<S_IFBLK>, B<S_IFIFO>,"
" or B<S_IFSOCK> to specify a regular file (which will be created empty), "
"character special file, block special file, FIFO (named pipe), or UNIX "
"domain socket, respectively.  (Zero file type is equivalent to type "
"B<S_IFREG>.)"
msgstr "Для указания обычного файла, специального символьного файла, специального блочного файла, FIFO (именованного канала) или доменного сокета UNIX типом должен быть один из B<S_IFREG>, B<S_IFCHR>, B<S_IFBLK>, B<S_IFIFO> или B<S_IFSOCK>, соответственно (нулевой тип файла эквивалентен типу B<S_IFREG>)."

#. type: Plain text
#: man-pages/man2/mknod.2:99
msgid ""
"If the file type is B<S_IFCHR> or B<S_IFBLK>, then I<dev> specifies the "
"major and minor numbers of the newly created device special file "
"(B<makedev>(3)  may be useful to build the value for I<dev>); otherwise it "
"is ignored."
msgstr "Если тип файла равен B<S_IFCHR> или B<S_IFBLK>, то в I<dev> задаётся основной и вспомогательный номера создаваемого специального файла устройства (B<makedev>(3) может оказаться полезной при создании значения для I<dev>); в остальных случаях аргумент игнорируется."

#. type: Plain text
#: man-pages/man2/mknod.2:105
msgid ""
"If I<pathname> already exists, or is a symbolic link, this call fails with "
"an B<EEXIST> error."
msgstr "Если I<pathname> уже существует, или является символьной ссылкой, то вызов завершается с ошибкой B<EEXIST>."

#. type: Plain text
#: man-pages/man2/mknod.2:114
msgid ""
"The newly created node will be owned by the effective user ID of the "
"process.  If the directory containing the node has the set-group-ID bit set,"
" or if the filesystem is mounted with BSD group semantics, the new node will"
" inherit the group ownership from its parent directory; otherwise it will be"
" owned by the effective group ID of the process."
msgstr "Созданный файл будет принадлежать ID эффективного владельца процесса. Если в правах доступа к каталогу, в котором находится файл, установлен бит set-group-ID, или если файловая система смонтирована с семантикой групп BSD, то новый файл унаследует группу-владельца от своего родительского каталога; в противном случае группой-владельцем станет ID эффективной группы процесса."

#. type: SS
#: man-pages/man2/mknod.2:114
#, no-wrap
msgid "mknodat()"
msgstr "mknodat()"

#. type: Plain text
#: man-pages/man2/mknod.2:120
msgid ""
"The B<mknodat>()  system call operates in exactly the same way as "
"B<mknod>(), except for the differences described here."
msgstr "Системный вызов B<mknodat>() работает также как системный вызов B<mknod>(), за исключением случаев, описанных здесь."

#. type: Plain text
#: man-pages/man2/mknod.2:130
msgid ""
"If the pathname given in I<pathname> is relative, then it is interpreted "
"relative to the directory referred to by the file descriptor I<dirfd> "
"(rather than relative to the current working directory of the calling "
"process, as is done by B<mknod>()  for a relative pathname)."
msgstr "Если в I<pathname> задан относительный путь, то он считается относительно каталога, на который ссылается файловый дескриптор I<dirfd> (а не относительно текущего рабочего каталога вызывающего процесса, как это делается в B<mknod>())."

#. type: Plain text
#: man-pages/man2/mknod.2:142
msgid ""
"If I<pathname> is relative and I<dirfd> is the special value B<AT_FDCWD>, "
"then I<pathname> is interpreted relative to the current working directory of"
" the calling process (like B<mknod>())."
msgstr "Если в I<pathname> задан относительный путь и I<dirfd> равно специальному значению B<AT_FDCWD>, то I<pathname> рассматривается относительно текущего рабочего каталога вызывающего процесса (как B<mknod>())."

#. type: Plain text
#: man-pages/man2/mknod.2:153
msgid "See B<openat>(2)  for an explanation of the need for B<mknodat>()."
msgstr "Смотрите в B<openat>(2) объяснение необходимости B<mknodat>()."

#. type: Plain text
#: man-pages/man2/mknod.2:160
msgid ""
"B<mknod>()  and B<mknodat>()  return zero on success, or -1 if an error "
"occurred (in which case, I<errno> is set appropriately)."
msgstr "При успешном выполнении вызовов B<mknod>() и B<mknodat>() возвращается 0. В случае ошибки возвращается -1, а I<errno> устанавливается в соответствующее значение."

#. type: Plain text
#: man-pages/man2/mknod.2:169
msgid ""
"The parent directory does not allow write permission to the process, or one "
"of the directories in the path prefix of I<pathname> did not allow search "
"permission.  (See also B<path_resolution>(7).)"
msgstr "У процесса нет прав на запись в родительский каталог, или в одном из каталогов в I<pathname> не разрешён поиск (смотрите также B<path_resolution>(7))."

#. type: Plain text
#: man-pages/man2/mknod.2:180
msgid ""
"I<pathname> already exists.  This includes the case where I<pathname> is a "
"symbolic link, dangling or not."
msgstr "I<pathname> уже существует. В этом случае I<pathname> может быть символьной ссылкой, повисшей или нет."

#. type: Plain text
#: man-pages/man2/mknod.2:188
msgid ""
"I<mode> requested creation of something other than a regular file, device "
"special file, FIFO or socket."
msgstr "В аргументе I<mode> указано значение, отличное от значения для обычного файла, специального файла устройства, FIFO или сокета."

#. type: Plain text
#: man-pages/man2/mknod.2:208
msgid "The device containing I<pathname> has no room for the new node."
msgstr "На устройстве, содержащем I<pathname>, нет места для создания нового элемента."

#.  For UNIX domain sockets and regular files, EPERM is returned only in
#.  Linux 2.2 and earlier; in Linux 2.4 and later, unprivileged can
#.  use mknod() to make these files.
#. type: Plain text
#: man-pages/man2/mknod.2:227
msgid ""
"I<mode> requested creation of something other than a regular file, FIFO "
"(named pipe), or UNIX domain socket, and the caller is not privileged "
"(Linux: does not have the B<CAP_MKNOD> capability); also returned if the "
"filesystem containing I<pathname> does not support the type of node "
"requested."
msgstr "В аргументе I<mode> запрошено создание чего-то, отличного от обычного файла, специального файла устройства, FIFO (именованного канала) или доменного сокета UNIX, и у вызвавшего процесса нет прав (Linux: не имеет мандата B<CAP_MKNOD>); также завершается, если файловая система, содержащая I<pathname>, не поддерживает тип запрашиваемой ноды."

#. type: Plain text
#: man-pages/man2/mknod.2:234
msgid "The following additional errors can occur for B<mknodat>():"
msgstr "В B<mknodat>() дополнительно могут возникнуть следующие ошибки:"

#. type: Plain text
#: man-pages/man2/mknod.2:248
msgid ""
"B<mknodat>()  was added to Linux in kernel 2.6.16; library support was added"
" to glibc in version 2.4."
msgstr "Вызов B<mknodat>() был добавлен в ядро Linux версии 2.6.16; поддержка в glibc доступна с версии 2.4."

#.  The Linux version differs from the SVr4 version in that it
#.  does not require root permission to create pipes, also in that no
#.  EMULTIHOP, ENOLINK, or EINTR error is documented.
#. type: Plain text
#: man-pages/man2/mknod.2:254
msgid "B<mknod>(): SVr4, 4.4BSD, POSIX.1-2001 (but see below), POSIX.1-2008."
msgstr "B<mknod>(): SVr4, 4.4BSD, POSIX.1-2001 (но смотрите ниже), POSIX.1-2008."

#. type: Plain text
#: man-pages/man2/mknod.2:257
msgid "B<mknodat>(): POSIX.1-2008."
msgstr "B<mknodat>(): POSIX.1-2008."

#. type: Plain text
#: man-pages/man2/mknod.2:275
msgid ""
"POSIX.1-2001 says: \"The only portable use of B<mknod>()  is to create a "
"FIFO-special file.  If I<mode> is not B<S_IFIFO> or I<dev> is not 0, the "
"behavior of B<mknod>()  is unspecified.\" However, nowadays one should never"
" use B<mknod>()  for this purpose; one should use B<mkfifo>(3), a function "
"especially defined for this purpose."
msgstr "В POSIX.1-2001 сказано: «Единственный способ, которым можно использовать B<mknod>() в переносимых программах это создание специального файла FIFO. Если значение I<mode> не равно B<S_IFIFO> или I<dev> не равно 0, то поведение B<mknod>() не определено.» Однако, в настоящее время никогда не используйте B<mknod>() для этой цели; вместо этого используйте функцию B<mkfifo>(3), которая создана специально для этого."

#.  and one should make UNIX domain sockets with socket(2) and bind(2).
#. type: Plain text
#: man-pages/man2/mknod.2:282
msgid ""
"Under Linux, B<mknod>()  cannot be used to create directories.  One should "
"make directories with B<mkdir>(2)."
msgstr "В Linux вызов B<mknod>() не может использоваться для создания каталогов. Для этого есть системный вызов B<mkdir>(2)."

#. type: Plain text
#: man-pages/man2/mknod.2:288
msgid ""
"There are many infelicities in the protocol underlying NFS.  Some of these "
"affect B<mknod>()  and B<mknodat>()."
msgstr "В протоколе, на котором работает NFS, есть множество недоработок. Некоторые из них влияют на B<mknod>() и B<mknodat>()."

#. type: Plain text
#: man-pages/man2/mknod.2:302
msgid ""
"B<mknod>(1), B<chmod>(2), B<chown>(2), B<fcntl>(2), B<mkdir>(2), "
"B<mount>(2), B<socket>(2), B<stat>(2), B<umask>(2), B<unlink>(2), "
"B<makedev>(3), B<mkfifo>(3), B<acl>(5)  B<path_resolution>(7)"
msgstr "B<mknod>(1), B<chmod>(2), B<chown>(2), B<fcntl>(2), B<mkdir>(2), B<mount>(2), B<socket>(2), B<stat>(2), B<umask>(2), B<unlink>(2), B<makedev>(3), B<mkfifo>(3), B<acl>(5)  B<path_resolution>(7)"

#. type: TH
#: man-pages/man2/madvise.2:35
#, no-wrap
msgid "MADVISE"
msgstr "MADVISE"

#. type: Plain text
#: man-pages/man2/madvise.2:38
msgid "madvise - give advice about use of memory"
msgstr "madvise - отсылает предложения по использованию памяти"

#. type: Plain text
#: man-pages/man2/madvise.2:40
msgid "B<#include E<lt>sys/mman.hE<gt>>"
msgstr "B<#include E<lt>sys/mman.hE<gt>>"

#. type: Plain text
#: man-pages/man2/madvise.2:42
msgid ""
"B<int madvise(void *>I<addr>B<, size_t >I<length>B<, int >I<advice>B<);>"
msgstr "B<int madvise(void *>I<addr>B<, size_t >I<length>B<, int >I<advice>B<);>"

#. type: Plain text
#: man-pages/man2/madvise.2:49
msgid "B<madvise>():"
msgstr "B<madvise>():"

#. type: TP
#: man-pages/man2/madvise.2:51
#, no-wrap
msgid "Since glibc 2.19:"
msgstr "Начиная с glibc 2.19:"

#. type: Plain text
#: man-pages/man2/madvise.2:54
msgid "_DEFAULT_SOURCE"
msgstr "_DEFAULT_SOURCE"

#. type: TP
#: man-pages/man2/madvise.2:54
#, no-wrap
msgid "Up to and including glibc 2.19:"
msgstr "Начиная с glibc 2.19:"

#. type: Plain text
#: man-pages/man2/madvise.2:57
msgid "_BSD_SOURCE"
msgstr "_BSD_SOURCE"

#. type: Plain text
#: man-pages/man2/madvise.2:70
msgid ""
"The B<madvise>()  system call is used to give advice or directions to the "
"kernel about the address range beginning at address I<addr> and with size "
"I<length> bytes In most cases, the goal of such advice is to improve system "
"or application performance."
msgstr "Системный вызов B<madvise>() используется, чтобы дать совет или указать направление ядру о диапазоне адресов, начинающемся с адреса I<addr> и имеющем размер I<length> байт. В большинстве случаев, целью такого совета является повышение производительности системы или приложения."

#.  ======================================================================
#. type: Plain text
#: man-pages/man2/madvise.2:83
msgid ""
"Initially, the system call supported a set of \"conventional\" I<advice> "
"values, which are also available on several other implementations.  (Note, "
"though, that B<madvise>()  is not specified in POSIX.)  Subsequently, a "
"number of Linux-specific I<advice> values have been added."
msgstr "Первоначально, системный вызов поддерживал набор «стандартных» значений I<advice>, которые также доступны и в некоторых других реализациях (однако отметим, что B<madvise>() отсутствует в POSIX). В последствии было добавлено несколько значений I<advice>, имеющихся только в Linux."

#. type: SS
#: man-pages/man2/madvise.2:83
#, no-wrap
msgid "Conventional advice values"
msgstr "Стандартные значения предложений"

#. type: Plain text
#: man-pages/man2/madvise.2:102
msgid ""
"The I<advice> values listed below allow an application to tell the kernel "
"how it expects to use some mapped or shared memory areas, so that the kernel"
" can choose appropriate read-ahead and caching techniques.  These I<advice> "
"values do not influence the semantics of the application (except in the case"
" of B<MADV_DONTNEED>), but may influence its performance.  All of the "
"I<advice> values listed here have analogs in the POSIX-specified "
"B<posix_madvise>(3)  function, and the values have the same meanings, with "
"the exception of B<MADV_DONTNEED>."
msgstr "Значения I<advice>, перечисленные далее, позволяют приложению указать ядру как оно будет использовать некоторые отображённые или общие области памяти, чтобы ядро могло выбрать подходящие методы упреждающего чтения и кэширования. Эти значения I<advice> не влияют на семантику приложения (за исключением B<MADV_DONTNEED>), но могут повлиять на его производительность. Все перечисленные здесь значения I<advice>  имеют аналоги в определённой POSIX функции B<posix_madvise>(3) и имеют тот же смысл, за исключением B<MADV_DONTNEED>."

#. type: Plain text
#: man-pages/man2/madvise.2:106
msgid ""
"The advice is indicated in the I<advice> argument, which is one of the "
"following:"
msgstr "В I<advice> помещается нужное предложения, одно из:"

#. type: TP
#: man-pages/man2/madvise.2:106
#, no-wrap
msgid "B<MADV_NORMAL>"
msgstr "B<MADV_NORMAL>"

#. type: Plain text
#: man-pages/man2/madvise.2:110
msgid "No special treatment.  This is the default."
msgstr "Нет никаких специальных указаний. Используется по умолчанию."

#. type: TP
#: man-pages/man2/madvise.2:110
#, no-wrap
msgid "B<MADV_RANDOM>"
msgstr "B<MADV_RANDOM>"

#. type: Plain text
#: man-pages/man2/madvise.2:114
msgid ""
"Expect page references in random order.  (Hence, read ahead may be less "
"useful than normally.)"
msgstr "Ожидать обращение к страницам в случайном порядке (здесь упреждающее чтение может быть менее эффективным)."

#. type: TP
#: man-pages/man2/madvise.2:114
#, no-wrap
msgid "B<MADV_SEQUENTIAL>"
msgstr "B<MADV_SEQUENTIAL>"

#. type: Plain text
#: man-pages/man2/madvise.2:119
msgid ""
"Expect page references in sequential order.  (Hence, pages in the given "
"range can be aggressively read ahead, and may be freed soon after they are "
"accessed.)"
msgstr "Ожидать последовательного обращения к страницам (здесь к страницам в заданном диапазоне можно применить агрессивное упреждающее чтение и быстро высвободить их сразу после доступа)."

#. type: TP
#: man-pages/man2/madvise.2:119
#, no-wrap
msgid "B<MADV_WILLNEED>"
msgstr "B<MADV_WILLNEED>"

#. type: Plain text
#: man-pages/man2/madvise.2:123
msgid ""
"Expect access in the near future.  (Hence, it might be a good idea to read "
"some pages ahead.)"
msgstr "Ожидать доступа в ближайшем будущем (здесь можно применить упреждающее чтение нескольких страниц)."

#. type: TP
#: man-pages/man2/madvise.2:123
#, no-wrap
msgid "B<MADV_DONTNEED>"
msgstr "B<MADV_DONTNEED>"

#. type: Plain text
#: man-pages/man2/madvise.2:128
msgid ""
"Do not expect access in the near future.  (For the time being, the "
"application is finished with the given range, so the kernel can free "
"resources associated with it.)"
msgstr "В ближайшем будущем не ожидается доступ (в настоящее время приложение закончило работу с данным диапазоном, поэтому ядро может освободить ресурсы, связанные с приложением)."

#. type: Plain text
#: man-pages/man2/madvise.2:139
msgid ""
"After a successful B<MADV_DONTNEED> operation, the semantics of memory "
"access in the specified region are changed: subsequent accesses of pages in "
"the range will succeed, but will result in either repopulating the memory "
"contents from the up-to-date contents of the underlying mapped file (for "
"shared file mappings, shared anonymous mappings, and shmem-based techniques "
"such as System V shared memory segments)  or zero-fill-on-demand pages for "
"anonymous private mappings."
msgstr "После успешного выполнения операции B<MADV_DONTNEED> семантика доступа к памяти в заданной области изменяется: последующий доступ к страницам в области будет успешным, но будет приводить к или повторному заполнению памяти актуальным содержимым из нижележащего отображённого файла (для общих отображений файла, общих анонимных отображений  и методов на основе shmem, таких как сегментов общей памяти System V) или к заполнению нулями страниц по требованию у частных анонимных отображений."

#. type: Plain text
#: man-pages/man2/madvise.2:146
msgid ""
"Note that, when applied to shared mappings, B<MADV_DONTNEED> might not lead "
"to immediate freeing of the pages in the range.  The kernel is free to delay"
" freeing the pages until an appropriate moment.  The resident set size (RSS)"
" of the calling process will be immediately reduced however."
msgstr "Заметим, что при применении к общим отображениям операция B<MADV_DONTNEED> может не приводить к немедленному освобождению страниц области. Ядро может задержать освобождение до подходящего момента. Однако размер постоянно занимаемой памяти (RSS) вызывающего процесса будет сокращён сразу же."

#.  http://lwn.net/Articles/162860/
#.  ======================================================================
#. type: Plain text
#: man-pages/man2/madvise.2:161
msgid ""
"B<MADV_DONTNEED> cannot be applied to locked pages, Huge TLB pages, or "
"B<VM_PFNMAP> pages.  (Pages marked with the kernel-internal B<VM_PFNMAP> "
"flag are special memory areas that are not managed by the virtual memory "
"subsystem.  Such pages are typically created by device drivers that map the "
"pages into user space.)"
msgstr "Операция B<MADV_DONTNEED> не может применяться к заблокированным страницам, страницам Huge TLB или страницам B<VM_PFNMAP> (страницы, помеченные внутренним флагом ядра B<VM_PFNMAP> представляют собой специальные области памяти, которые не управляются из подсистемы виртуальной памяти; обычно, эти страницы создаются драйверами устройств, которые отображают страницы в пользовательское пространство)."

#. type: SS
#: man-pages/man2/madvise.2:161
#, no-wrap
msgid "Linux-specific advice values"
msgstr "Значения предложений, имеющиеся только в Linux"

#. type: Plain text
#: man-pages/man2/madvise.2:170
msgid ""
"The following Linux-specific I<advice> values have no counterparts in the "
"POSIX-specified B<posix_madvise>(3), and may or may not have counterparts in"
" the B<madvise>()  interface available on other implementations.  Note that "
"some of these operations change the semantics of memory accesses."
msgstr "Следующие значения I<advice> имеются только в Linux и не имеют аналога в определённой POSIX функции B<posix_madvise>(3), а также могут не иметь аналога и в других реализациях интерфейса B<madvise>(). Заметим, что некоторые из этих операций изменяют семантику доступа к памяти."

#. type: TP
#: man-pages/man2/madvise.2:170
#, no-wrap
msgid "B<MADV_REMOVE> (since Linux 2.6.16)"
msgstr "B<MADV_REMOVE> (начиная с Linux 2.6.16)"

#.  commit f6b3ec238d12c8cc6cc71490c6e3127988460349
#.  Databases want to use this feature to drop a section of their
#.  bufferpool (shared memory segments) - without writing back to
#.  disk/swap space.  This feature is also useful for supporting
#.  hot-plug memory on UML.
#. type: Plain text
#: man-pages/man2/madvise.2:184
msgid ""
"Free up a given range of pages and its associated backing store.  This is "
"equivalent to punching a hole in the corresponding byte range of the backing"
" store (see B<fallocate>(2)).  Subsequent accesses in the specified address "
"range will see bytes containing zero."
msgstr "Освободить указанный диапазон страниц и связанные с ним хранилища. Эквивалентен пробивке отверстия в соответствующем диапазоне байт хранилища (смотрите B<fallocate>(2)). Последующий доступ к указанному адресному диапазону будет возвращать байты с нулями."

#. type: Plain text
#: man-pages/man2/madvise.2:189
msgid ""
"The specified address range must be mapped shared and writable.  This flag "
"cannot be applied to locked pages, Huge TLB pages, or B<VM_PFNMAP> pages."
msgstr "Указываемый адресный диапазон должен быть общим и доступным на запись отображением. Этот флаг не может применять к заблокированным страницам, страницам Huge TLB или страницам B<VM_PFNMAP>."

#.  commit 3f31d07571eeea18a7d34db9af21d2285b807a17
#. type: Plain text
#: man-pages/man2/madvise.2:205
msgid ""
"In the initial implementation, only B<tmpfs>(5)  was supported "
"B<MADV_REMOVE>; but since Linux 3.5, any filesystem which supports the "
"B<fallocate>(2)  B<FALLOC_FL_PUNCH_HOLE> mode also supports B<MADV_REMOVE>."
"  Hugetlbfs fails with the error B<EINVAL> and other filesystems fail with "
"the error B<EOPNOTSUPP>."
msgstr "В первоначальной реализации B<MADV_REMOVE> поддерживался только в B<tmpfs>(5), но начиная с Linux 3.5 все файловые системы, поддерживающие B<fallocate>(2) с режимом B<FALLOC_FL_PUNCH_HOLE>, также поддерживают B<MADV_REMOVE>. Hugetlbfs возвращает ошибку B<EINVAL>, а другие файловые системы возвращают ошибку B<EOPNOTSUPP>."

#. type: TP
#: man-pages/man2/madvise.2:205
#, no-wrap
msgid "B<MADV_DONTFORK> (since Linux 2.6.16)"
msgstr "B<MADV_DONTFORK> (начиная с Linux 2.6.16)"

#.  commit f822566165dd46ff5de9bf895cfa6c51f53bb0c4
#.  See http://lwn.net/Articles/171941/
#.  [PATCH] madvise MADV_DONTFORK/MADV_DOFORK
#.  Currently, copy-on-write may change the physical address of
#.  a page even if the user requested that the page is pinned in
#.  memory (either by mlock or by get_user_pages).  This happens
#.  if the process forks meanwhile, and the parent writes to that
#.  page.  As a result, the page is orphaned: in case of
#.  get_user_pages, the application will never see any data hardware
#.  DMA's into this page after the COW.  In case of mlock'd memory,
#.  the parent is not getting the realtime/security benefits of mlock.
#.  In particular, this affects the Infiniband modules which do DMA from
#.  and into user pages all the time.
#.  This patch adds madvise options to control whether memory range is
#.  inherited across fork. Useful e.g. for when hardware is doing DMA
#.  from/into these pages.  Could also be useful to an application
#.  wanting to speed up its forks by cutting large areas out of
#.  consideration.
#.  SEE ALSO: http://lwn.net/Articles/171941/
#.  "Tweaks to madvise() and posix_fadvise()", 14 Feb 2006
#. type: Plain text
#: man-pages/man2/madvise.2:237
msgid ""
"Do not make the pages in this range available to the child after a "
"B<fork>(2).  This is useful to prevent copy-on-write semantics from changing"
" the physical location of a page if the parent writes to it after a "
"B<fork>(2).  (Such page relocations cause problems for hardware that DMAs "
"into the page.)"
msgstr "Сделать недоступными страницы в указанном диапазоне для потомка после B<fork>(2). Это полезно для предотвращения изменения физического расположения страницы копирования-при-записи, если родитель будет изменять её после B<fork>(2) (перемещение таких страниц вызывает проблемы для оборудования, обращающегося к страницам через DMA)."

#. type: TP
#: man-pages/man2/madvise.2:237
#, no-wrap
msgid "B<MADV_DOFORK> (since Linux 2.6.16)"
msgstr "B<MADV_DOFORK> (начиная с Linux 2.6.16)"

#. type: Plain text
#: man-pages/man2/madvise.2:243
msgid ""
"Undo the effect of B<MADV_DONTFORK>, restoring the default behavior, whereby"
" a mapping is inherited across B<fork>(2)."
msgstr "Отменить действие B<MADV_DONTFORK>, восстановить поведение по умолчанию, в силу чего происходит наследование отображения после B<fork>(2)."

#. type: TP
#: man-pages/man2/madvise.2:243
#, no-wrap
msgid "B<MADV_HWPOISON> (since Linux 2.6.32)"
msgstr "B<MADV_HWPOISON> (начиная с Linux 2.6.32)"

#.  commit 9893e49d64a4874ea67849ee2cfbf3f3d6817573
#. type: Plain text
#: man-pages/man2/madvise.2:258
msgid ""
"Poison the pages in the range specified by I<addr> and I<length> and handle "
"subsequent references to those pages like a hardware memory corruption.  "
"This operation is available only for privileged (B<CAP_SYS_ADMIN>)  "
"processes.  This operation may result in the calling process receiving a "
"B<SIGBUS> and the page being unmapped."
msgstr "Испортить страницы в диапазоне, заданном I<addr> и I<length>, и обрабатывать последующие ссылки на эти страницы как при аппаратном повреждении памяти. Данная операция доступна только для привилегированных (B<CAP_SYS_ADMIN>) процессов. Она может привести к тому, что вызывающий процесс получит B<SIGBUS> и отображение страницы удалится."

#. type: Plain text
#: man-pages/man2/madvise.2:262 man-pages/man2/madvise.2:319
msgid ""
"This feature is intended for testing of memory error-handling code; it is "
"available only if the kernel was configured with B<CONFIG_MEMORY_FAILURE>."
msgstr "Это свойство предназначено для тестирования кода обработки ошибок памяти; оно доступно только, если ядро было собрано с параметром B<CONFIG_MEMORY_FAILURE>."

#. type: TP
#: man-pages/man2/madvise.2:262
#, no-wrap
msgid "B<MADV_MERGEABLE> (since Linux 2.6.32)"
msgstr "B<MADV_MERGEABLE> (начиная с Linux 2.6.32)"

#.  commit f8af4da3b4c14e7267c4ffb952079af3912c51c5
#. type: Plain text
#: man-pages/man2/madvise.2:276
msgid ""
"Enable Kernel Samepage Merging (KSM) for the pages in the range specified by"
" I<addr> and I<length>.  The kernel regularly scans those areas of user "
"memory that have been marked as mergeable, looking for pages with identical "
"content.  These are replaced by a single write-protected page (which is "
"automatically copied if a process later wants to update the content of the "
"page).  KSM merges only private anonymous pages (see B<mmap>(2))."
msgstr "Включает слияние одинаковых страниц ядра (Kernel Samepage Merging, KSM) для страниц в диапазоне, указанном I<addr> и I<length>. Ядро периодически сканирует области пользовательской памяти, которые были помечены для слияния, разыскивая станицы с одинаковым содержимым. Такие страницы заменяются единственной страницей, защищённой от записи (которая автоматически копируется, если позднее процесс захочет изменить содержимое страницы). При KSM слияние выполняется только для частных анонимных страниц (смотрите B<mmap>(2))."

#. type: Plain text
#: man-pages/man2/madvise.2:283
msgid ""
"The KSM feature is intended for applications that generate many instances of"
" the same data (e.g., virtualization systems such as KVM).  It can consume a"
" lot of processing power; use with care.  See the Linux kernel source file "
"I<Documentation/admin-guide/mm/ksm.rst> for more details."
msgstr "Возможность KSM предназначена для приложений, которые генерируют много экземпляров одинаковых данных (например, для систем виртуализации, таких как KVM). Эта возможность может нагрузить процессор; используйте осторожно. Дополнительную информацию можно найти в файле исходного кода ядра I<Documentation/admin-guide/mm/ksm.rst>."

#. type: Plain text
#: man-pages/man2/madvise.2:290
msgid ""
"The B<MADV_MERGEABLE> and B<MADV_UNMERGEABLE> operations are available only "
"if the kernel was configured with B<CONFIG_KSM>."
msgstr "Операции B<MADV_MERGEABLE> и B<MADV_UNMERGEABLE>  доступны только, если ядро собрано с параметром B<CONFIG_KSM>."

#. type: TP
#: man-pages/man2/madvise.2:290
#, no-wrap
msgid "B<MADV_UNMERGEABLE> (since Linux 2.6.32)"
msgstr "B<MADV_UNMERGEABLE> (начиная с Linux 2.6.32)"

#. type: Plain text
#: man-pages/man2/madvise.2:299
msgid ""
"Undo the effect of an earlier B<MADV_MERGEABLE> operation on the specified "
"address range; KSM unmerges whatever pages it had merged in the address "
"range specified by I<addr> and I<length>."
msgstr "Отменить действие ранее применённой операции B<MADV_MERGEABLE> для указанного диапазона; KSM разделяет ранее объединённые страницы в диапазоне, заданном I<addr> и I<length>."

#. type: TP
#: man-pages/man2/madvise.2:299
#, no-wrap
msgid "B<MADV_SOFT_OFFLINE> (since Linux 2.6.33)"
msgstr "B<MADV_SOFT_OFFLINE> (начиная с Linux 2.6.33)"

#.  commit afcf938ee0aac4ef95b1a23bac704c6fbeb26de6
#. type: Plain text
#: man-pages/man2/madvise.2:315
msgid ""
"Soft offline the pages in the range specified by I<addr> and I<length>.  The"
" memory of each page in the specified range is preserved (i.e., when next "
"accessed, the same content will be visible, but in a new physical page "
"frame), and the original page is offlined (i.e., no longer used, and taken "
"out of normal memory management).  The effect of the B<MADV_SOFT_OFFLINE> "
"operation is invisible to (i.e., does not change the semantics of)  the "
"calling process."
msgstr "Программно отключить страницы в диапазоне, указанном I<addr> и I<length>. Память каждой страницы в указанном диапазоне сохраняется (т. е., при следующем доступе будет выдано то же содержимое, но в новых физических границах страницы) и первоначальная страница отключается (т. е., больше не используется и не участвует при обычном управлении памятью). Эффект операции B<MADV_SOFT_OFFLINE> обычно незаметен (т. е., не изменяет семантику) для вызывающего процесса."

#. type: TP
#: man-pages/man2/madvise.2:319
#, no-wrap
msgid "B<MADV_HUGEPAGE> (since Linux 2.6.38)"
msgstr "B<MADV_HUGEPAGE> (начиная с Linux 2.6.38)"

#.  commit 0af4e98b6b095c74588af04872f83d333c958c32
#.  http://lwn.net/Articles/358904/
#.  https://lwn.net/Articles/423584/
#. type: Plain text
#: man-pages/man2/madvise.2:335
msgid ""
"Enable Transparent Huge Pages (THP) for pages in the range specified by "
"I<addr> and I<length>.  Currently, Transparent Huge Pages work only with "
"private anonymous pages (see B<mmap>(2)).  The kernel will regularly scan "
"the areas marked as huge page candidates to replace them with huge pages.  "
"The kernel will also allocate huge pages directly when the region is "
"naturally aligned to the huge page size (see B<posix_memalign>(2))."
msgstr "Включает прозрачность огромных страниц (Transparent Huge Pages, THP) для страниц в диапазоне, указанном I<addr> и I<length>. В настоящий момент, THP работает только для закрытых (private) анонимных страниц (смотрите B<mmap>(2)). Ядро будет периодически сканировать области, помеченные как кандидаты в огромные страницы, для замены их огромными страницами. Ядро также будет непосредственно выделять огромные страницы, если область выравнена на аппаратный (naturally) размер огромной страницы при создании (смотрите B<posix_memalign>(2))."

#. type: Plain text
#: man-pages/man2/madvise.2:344
msgid ""
"This feature is primarily aimed at applications that use large mappings of "
"data and access large regions of that memory at a time (e.g., virtualization"
" systems such as QEMU).  It can very easily waste memory (e.g., a 2\\ MB "
"mapping that only ever accesses 1 byte will result in 2\\ MB of wired memory"
" instead of one 4\\ KB page).  See the Linux kernel source file "
"I<Documentation/admin-guide/mm/transhuge.rst> for more details."
msgstr "В основном, эта возможность предназначена для приложений, которые используют большие отображения данных и доступ к большим областям этой памяти за один приём (например, системы виртуализации, такие как QEMU). С её помощью можно очень легко занять память (например, на 2\\ МБ отображение, из которого нужен только 1 байт, будет потрачено 2\\ МБ реальной памяти вместо одной 4\\ КБ страницы). Дополнительную информацию смотрите в файле I<Documentation/admin-guide/mm/transhuge.rst> из исходного кода ядра."

#. type: Plain text
#: man-pages/man2/madvise.2:351
msgid ""
"The B<MADV_HUGEPAGE> and B<MADV_NOHUGEPAGE> operations are available only if"
" the kernel was configured with B<CONFIG_TRANSPARENT_HUGEPAGE>."
msgstr "Операции B<MADV_HUGEPAGE> и B<MADV_NOHUGEPAGE> доступны только, если ядро собрано с параметром B<CONFIG_TRANSPARENT_HUGEPAGE>."

#. type: TP
#: man-pages/man2/madvise.2:351
#, no-wrap
msgid "B<MADV_NOHUGEPAGE> (since Linux 2.6.38)"
msgstr "B<MADV_NOHUGEPAGE> (начиная с Linux 2.6.38)"

#. type: Plain text
#: man-pages/man2/madvise.2:358
msgid ""
"Ensures that memory in the address range specified by I<addr> and I<length> "
"will not be collapsed into huge pages."
msgstr "Проверить, что память адресного пространства, указанного в I<addr> и I<length>, не будет свёрнута в огромные страницы."

#. type: TP
#: man-pages/man2/madvise.2:358
#, no-wrap
msgid "B<MADV_DONTDUMP> (since Linux 3.4)"
msgstr "B<MADV_DONTDUMP> (начиная с Linux 3.4)"

#.  commit 909af768e88867016f427264ae39d27a57b6a8ed
#.  commit accb61fe7bb0f5c2a4102239e4981650f9048519
#. type: Plain text
#: man-pages/man2/madvise.2:374
msgid ""
"Exclude from a core dump those pages in the range specified by I<addr> and "
"I<length>.  This is useful in applications that have large areas of memory "
"that are known not to be useful in a core dump.  The effect of "
"B<MADV_DONTDUMP> takes precedence over the bit mask that is set via the "
"I</proc/[pid]/coredump_filter> file (see B<core>(5))."
msgstr "Исключить из дампа памяти страницы диапазона, задаваемого значениями I<addr> и I<length>. Это полезно в приложениях, которые занимают большие области в памяти, про которые известно, что они ничем не помогут будучи в дампе памяти. Действие B<MADV_DONTDUMP> имеет преимущество над битовой маской, которая устанавливается в файле I</proc/[pid]/coredump_filter> (смотрите B<core>(5))."

#. type: TP
#: man-pages/man2/madvise.2:374
#, no-wrap
msgid "B<MADV_DODUMP> (since Linux 3.4)"
msgstr "B<MADV_DODUMP> (начиная с Linux 3.4)"

#. type: Plain text
#: man-pages/man2/madvise.2:378
msgid "Undo the effect of an earlier B<MADV_DONTDUMP>."
msgstr "Отменяет действие, установленное ранее B<MADV_DONTDUMP>."

#. type: TP
#: man-pages/man2/madvise.2:378
#, no-wrap
msgid "B<MADV_FREE> (since Linux 4.5)"
msgstr "B<MADV_FREE> (начиная с Linux 4.5)"

#. type: Plain text
#: man-pages/man2/madvise.2:400
msgid ""
"The application no longer requires the pages in the range specified by "
"I<addr> and I<len>.  The kernel can thus free these pages, but the freeing "
"could be delayed until memory pressure occurs.  For each of the pages that "
"has been marked to be freed but has not yet been freed, the free operation "
"will be canceled if the caller writes into the page.  After a successful "
"B<MADV_FREE> operation, any stale data (i.e., dirty, unwritten pages) will "
"be lost when the kernel frees the pages.  However, subsequent writes to "
"pages in the range will succeed and then kernel cannot free those dirtied "
"pages, so that the caller can always see just written data.  If there is no "
"subsequent write, the kernel can free the pages at any time.  Once pages in "
"the range have been freed, the caller will see zero-fill-on-demand pages "
"upon subsequent page references."
msgstr "Приложению больше не требуются страницы в диапазоне, задаваемом I<addr> и I<len>, поэтому ядро может освободить эти страницы, но освобождение может быть отложено до тех пор, пока не понадобится память. Для каждой страницы, помеченной как свободная, но ещё не освобождённая, операция освобождения будет отменена, если вызывающий выполнит запись в эту страницу. После успешного выполнения операции B<MADV_FREE> все повисшие данные (т. е., изменённые (dirty) и не записанные страницы) будут потеряны в момент освобождения страниц ядром. Однако последующая запись в страницы в этом диапазоне будет успешной и поэтому ядро не сможет освободить эти изменённые страницы и вызывающий всегда может видеть только что записанные данные. Если последующей записи не было, то ядро может освободить страницы в любой момент. После освобождения страниц диапазона при последующем доступе вызывающий может видеть страницы заполненные нулями по требованию."

#.  commit 93e06c7a645343d222c9a838834a51042eebbbf7
#. type: Plain text
#: man-pages/man2/madvise.2:411
msgid ""
"The B<MADV_FREE> operation can be applied only to private anonymous pages "
"(see B<mmap>(2)).  In Linux before version 4.12, when freeing pages on a "
"swapless system, the pages in the given range are freed instantly, "
"regardless of memory pressure."
msgstr "Операция B<MADV_FREE> может применяться только при частным анонимным страницам (смотрите B<mmap>(2)). В Linux до версии 4.12 страницы задаваемого диапазона в системе без подкачки освобождаются сразу, независимо от необходимости в памяти."

#. type: TP
#: man-pages/man2/madvise.2:411
#, no-wrap
msgid "B<MADV_WIPEONFORK> (since Linux 4.14)"
msgstr "B<MADV_WIPEONFORK> (начиная с Linux 4.14)"

#.  commit d2cd9ede6e193dd7d88b6d27399e96229a551b19
#. type: Plain text
#: man-pages/man2/madvise.2:420
msgid ""
"Present the child process with zero-filled memory in this range after a "
"B<fork>(2).  This is useful in forking servers in order to ensure that "
"sensitive per-process data (for example, PRNG seeds, cryptographic secrets, "
"and so on)  is not handed to child processes."
msgstr "Выдать дочернему процессу заполненную нулями память в этом диапазоне после B<fork>(2). Это позволяет при ветвлении (forking) серверов стереть важные данные процесса (например, начальные значения PRNG, данные шифрования и т. п.) у дочерних процессов."

#. type: Plain text
#: man-pages/man2/madvise.2:425
msgid ""
"The B<MADV_WIPEONFORK> operation can be applied only to private anonymous "
"pages (see B<mmap>(2))."
msgstr "Операция B<MADV_WIPEONFORK> применима только к частным анонимным страницам (смотрите B<mmap>(2))."

#. type: Plain text
#: man-pages/man2/madvise.2:433
msgid ""
"Within the child created by B<fork>(2), the B<MADV_WIPEONFORK> setting "
"remains in place on the specified address range.  This setting is cleared "
"during B<execve>(2)."
msgstr "В потомке, созданном B<fork>(2), значение B<MADV_WIPEONFORK> остаётся у указанного адресного диапазона. Это значение стирается при B<execve>(2)."

#. type: TP
#: man-pages/man2/madvise.2:433
#, no-wrap
msgid "B<MADV_KEEPONFORK> (since Linux 4.14)"
msgstr "B<MADV_KEEPONFORK> (начиная с Linux 4.14)"

#.  commit d2cd9ede6e193dd7d88b6d27399e96229a551b19
#. type: Plain text
#: man-pages/man2/madvise.2:438
msgid "Undo the effect of an earlier B<MADV_WIPEONFORK>."
msgstr "Отменяет действие, установленное ранее B<MADV_WIPEONFORK>."

#. type: Plain text
#: man-pages/man2/madvise.2:445
msgid ""
"On success, B<madvise>()  returns zero.  On error, it returns -1 and "
"I<errno> is set appropriately."
msgstr "При нормальном завершении работы B<madvise>() возвращает ноль. При ошибке возвращается -1, а переменной I<errno> присваивается соответствующее значение."

#. type: Plain text
#: man-pages/man2/madvise.2:452
msgid ""
"I<advice> is B<MADV_REMOVE>, but the specified address range is not a shared"
" writable mapping."
msgstr "В I<advice> указан B<MADV_REMOVE>, но описанный диапазон адресов не является общей памятью с разрешением на записи"

#. type: Plain text
#: man-pages/man2/madvise.2:455
msgid "A kernel resource was temporarily unavailable."
msgstr "Ресурс ядра временно недоступен."

#. type: Plain text
#: man-pages/man2/madvise.2:458
msgid "The map exists, but the area maps something that isn't a file."
msgstr "Отображение существует, то область отображения не является файловой."

#.  .I length
#.  is zero,
#. type: Plain text
#: man-pages/man2/madvise.2:466
msgid "I<addr> is not page-aligned or I<length> is negative."
msgstr "Значение параметра I<addr> не выровнено по границе страницы или  параметр I<length>  содержит отрицательное число."

#. type: Plain text
#: man-pages/man2/madvise.2:470
msgid "I<advice> is not a valid."
msgstr "Значение I<advice> недопустимо."

#. type: Plain text
#: man-pages/man2/madvise.2:480
msgid ""
"I<advice> is B<MADV_DONTNEED> or B<MADV_REMOVE> and the specified address "
"range includes locked, Huge TLB pages, or B<VM_PFNMAP> pages."
msgstr "Значение I<advice> равно B<MADV_DONTNEED> или B<MADV_REMOVE>, а указанный адресный диапазон включает заблокированные, Huge TLB или B<VM_PFNMAP> страницы."

#. type: Plain text
#: man-pages/man2/madvise.2:489
msgid ""
"I<advice> is B<MADV_MERGEABLE> or B<MADV_UNMERGEABLE>, but the kernel was "
"not configured with B<CONFIG_KSM>."
msgstr "Значение I<advice> равно B<MADV_MERGEABLE> или B<MADV_UNMERGEABLE>, но ядро было собрано без параметра B<CONFIG_KSM>."

#. type: Plain text
#: man-pages/man2/madvise.2:501
msgid ""
"I<advice> is B<MADV_FREE> or B<MADV_WIPEONFORK> but the specified address "
"range includes file, Huge TLB, B<MAP_SHARED>, or B<VM_PFNMAP> ranges."
msgstr "Значение I<advice> равно B<MADV_FREE> или B<MADV_WIPEONFORK>, но в указанном адресном диапазоне содержится файл, Huge TLB, диапазоны B<MAP_SHARED> или B<VM_PFNMAP>."

#. type: TP
#: man-pages/man2/madvise.2:501
#, no-wrap
msgid "B<EIO>"
msgstr "B<EIO>"

#. type: Plain text
#: man-pages/man2/madvise.2:507
msgid ""
"(for B<MADV_WILLNEED>)  Paging in this area would exceed the process's "
"maximum resident set size."
msgstr "(для B<MADV_WILLNEED>) Выделение страницы в данной области превысило бы максимальный размер постоянно находящихся в памяти страниц для процесса (rss)."

#. type: Plain text
#: man-pages/man2/madvise.2:512
msgid "(for B<MADV_WILLNEED>)  Not enough memory: paging in failed."
msgstr "(для B<MADV_WILLNEED>) Недостаточно памяти: не удалось выделить страницу"

#. type: Plain text
#: man-pages/man2/madvise.2:516
msgid ""
"Addresses in the specified range are not currently mapped, or are outside "
"the address space of the process."
msgstr "Адреса в указанном диапазоне в настоящее время не отображены, или лежит вне адресного пространства процесса."

#. type: Plain text
#: man-pages/man2/madvise.2:524
msgid ""
"I<advice> is B<MADV_HWPOISON>, but the caller does not have the "
"B<CAP_SYS_ADMIN> capability."
msgstr "В переменной I<advice> содержится B<MADV_HWPOISON>, но вызывающий не имеет мандата B<CAP_SYS_ADMIN>."

#.  commit d3ac21cacc24790eb45d735769f35753f5b56ceb
#. type: Plain text
#: man-pages/man2/madvise.2:531
msgid ""
"Since Linux 3.18, support for this system call is optional, depending on the"
" setting of the B<CONFIG_ADVISE_SYSCALLS> configuration option."
msgstr "Начиная с Linux 3.18 поддержка данного системного вызова необязательна, она зависит от того, собрано ли ядро с параметром B<CONFIG_ADVISE_SYSCALLS>."

#. type: Plain text
#: man-pages/man2/madvise.2:541
msgid ""
"B<madvise>()  is not specified by any standards.  Versions of this system "
"call, implementing a wide variety of I<advice> values, exist on many other "
"implementations.  Other implementations typically implement at least the "
"flags listed above under I<Conventional advice flags>, albeit with some "
"variation in semantics."
msgstr "Вызов B<madvise>() не включён ни в один стандарт. Версии этого системного вызова, реализующие широкий набор значений I<advice>, существуют во многих других системах. В них, обычно, реализуются, как минимум, флаги перечисленные в I<Стандартные значения предложений>, хотя и с некоторыми различиями в семантике."

#. type: Plain text
#: man-pages/man2/madvise.2:552
msgid ""
"POSIX.1-2001 describes B<posix_madvise>(3)  with constants "
"B<POSIX_MADV_NORMAL>, B<POSIX_MADV_RANDOM>, B<POSIX_MADV_SEQUENTIAL>, "
"B<POSIX_MADV_WILLNEED>, and B<POSIX_MADV_DONTNEED>, and so on, with behavior"
" close to the similarly named flags listed above."
msgstr "В POSIX-2001 описана функция B<posix_madvise>(3) с константами B<POSIX_MADV_NORMAL>, B<POSIX_MADV_RANDOM>, B<POSIX_MADV_SEQUENTIAL>, B<POSIX_MADV_WILLNEED> и B<POSIX_MADV_DONTNEED>, и т. п., реализующая поведение близкое к флагам с именами, перечисленным выше."

#. type: SS
#: man-pages/man2/madvise.2:553
#, no-wrap
msgid "Linux notes"
msgstr "Замечания, касающиеся Linux"

#.  .SH HISTORY
#.  The
#.  .BR madvise ()
#.  function first appeared in 4.4BSD.
#. type: Plain text
#: man-pages/man2/madvise.2:569
msgid ""
"The Linux implementation requires that the address I<addr> be page-aligned, "
"and allows I<length> to be zero.  If there are some parts of the specified "
"address range that are not mapped, the Linux version of B<madvise>()  "
"ignores them and applies the call to the rest (but returns B<ENOMEM> from "
"the system call, as it should)."
msgstr "Для реализации Linux требуется, чтобы адрес I<addr> был выровнен на границу страницы, а значение I<length> может быть нулевым. Если какие-то части указанного адресного диапазона не отображены, то версия Linux B<madvise>() игнорирует их и вызов применяется к оставшейся области (но возвращается значение B<ENOMEM>, как и должно)."

#. type: Plain text
#: man-pages/man2/madvise.2:578
msgid ""
"B<getrlimit>(2), B<mincore>(2), B<mmap>(2), B<mprotect>(2), B<msync>(2), "
"B<munmap>(2), B<prctl>(2), B<posix_madvise>(3), B<core>(5)"
msgstr "B<getrlimit>(2), B<mincore>(2), B<mmap>(2), B<mprotect>(2), B<msync>(2), B<munmap>(2), B<prctl>(2), B<posix_madvise>(3), B<core>(5)"

#. type: TH
#: man-pages/man2/msgget.2:35
#, no-wrap
msgid "MSGGET"
msgstr "MSGGET"

#. type: Plain text
#: man-pages/man2/msgget.2:38
msgid "msgget - get a System V message queue identifier"
msgstr "msgget - возвращает идентификатор очереди сообщений System V"

#. type: Plain text
#: man-pages/man2/msgget.2:45
#, no-wrap
msgid "B<int msgget(key_t >I<key>B<, int >I<msgflg>B<);>\n"
msgstr "B<int msgget(key_t >I<key>B<, int >I<msgflg>B<);>\n"

#. type: Plain text
#: man-pages/man2/msgget.2:61
msgid ""
"The B<msgget>()  system call returns the System\\ V message queue identifier"
" associated with the value of the I<key> argument.  It may be used either to"
" obtain the identifier of a previously created message queue (when I<msgflg>"
" is zero and I<key> does not have the value B<IPC_PRIVATE>), or to create a "
"new set."
msgstr "Системный вызов B<msgget>() возвращает идентификатор очереди сообщений System\\ V, связанный со значением аргумента I<key>. Его можно использовать для получения идентификатора уже созданной очереди сообщений (если I<msgflg> равно нулю и значение I<key> не равно B<IPC_PRIVATE>) или для создания новой."

#. type: Plain text
#: man-pages/man2/msgget.2:76
msgid ""
"A new message queue is created if I<key> has the value B<IPC_PRIVATE> or "
"I<key> isn't B<IPC_PRIVATE>, no message queue with the given key I<key> "
"exists, and B<IPC_CREAT> is specified in I<msgflg>."
msgstr "Новая очередь сообщений создаётся, если значение I<key> равно B<IPC_PRIVATE>, или если I<key> не равно B<IPC_PRIVATE>,не существует ни одной очереди сообщений с заданным ключом I<key> и в поле I<msgflg> указан флаг B<IPC_CREAT>."

#. type: Plain text
#: man-pages/man2/msgget.2:95
msgid ""
"If I<msgflg> specifies both B<IPC_CREAT> and B<IPC_EXCL> and a message queue"
" already exists for I<key>, then B<msgget>()  fails with I<errno> set to "
"B<EEXIST>.  (This is analogous to the effect of the combination B<O_CREAT | "
"O_EXCL> for B<open>(2).)"
msgstr "Если в I<msgflg> одновременно заданы B<IPC_CREAT> и B<IPC_EXCL> и с таким I<key> очередь сообщений уже существует, то B<msgget>() завершится с ошибкой и I<errno> будет равно B<EEXIST> (тот же эффект как для комбинации B<O_CREAT | O_EXCL> у B<open>(2))."

#. type: Plain text
#: man-pages/man2/msgget.2:105
msgid ""
"Upon creation, the least significant bits of the argument I<msgflg> define "
"the permissions of the message queue.  These permission bits have the same "
"format and semantics as the permissions specified for the I<mode> argument "
"of B<open>(2).  (The execute permissions are not used.)"
msgstr "При создании права доступа к очереди сообщений определяются младшими битами параметра I<msgflg>. Эти биты прав имеют тот же формат и значение, что и права в аргументе I<mode> у вызова B<open>(2) (право на исполнение не используется)."

#. type: Plain text
#: man-pages/man2/msgget.2:112
msgid ""
"If a new message queue is created, then its associated data structure "
"I<msqid_ds> (see B<msgctl>(2))  is initialized as follows:"
msgstr "Если создаётся новая очередь сообщений, то этот системный вызов инициализирует структуру данных I<msqid_ds> (смотрите B<msgctl>(2)) следующим образом:"

#. type: Plain text
#: man-pages/man2/msgget.2:117
msgid ""
"I<msg_perm.cuid> and I<msg_perm.uid> are set to the effective user ID of the"
" calling process."
msgstr "Полям I<msg_perm.cuid> и I<msg_perm.uid> присваивается эффективный идентификатор пользователя вызывающего процесса."

#. type: Plain text
#: man-pages/man2/msgget.2:122
msgid ""
"I<msg_perm.cgid> and I<msg_perm.gid> are set to the effective group ID of "
"the calling process."
msgstr "Полям I<msg_perm.cgid> и I<msg_perm.gid> присваивается эффективный идентификатор группы вызывающего процесса."

#. type: Plain text
#: man-pages/man2/msgget.2:127
msgid ""
"The least significant 9 bits of I<msg_perm.mode> are set to the least "
"significant 9 bits of I<msgflg>."
msgstr "Младшим 9 битам I<msg_perm.mode> присваивается значение младших 9 битов I<msgflg>."

#. type: Plain text
#: man-pages/man2/msgget.2:135
msgid ""
"I<msg_qnum>, I<msg_lspid>, I<msg_lrpid>, I<msg_stime>, and I<msg_rtime> are "
"set to 0."
msgstr "I<msg_qnum>, I<msg_lspid>, I<msg_lrpid>, I<msg_stime> и  I<msg_rtime> присваивается 0."

#. type: Plain text
#: man-pages/man2/msgget.2:138
msgid "I<msg_ctime> is set to the current time."
msgstr "В поле I<msg_ctime> записывается текущее время."

#. type: Plain text
#: man-pages/man2/msgget.2:142
msgid "I<msg_qbytes> is set to the system limit B<MSGMNB>."
msgstr "В поле I<msg_qbytes> записывается системное ограничение B<MSGMNB>."

#. type: Plain text
#: man-pages/man2/msgget.2:146
msgid ""
"If the message queue already exists the permissions are verified, and a "
"check is made to see if it is marked for destruction."
msgstr "Если очередь сообщений уже существует, то проверяются права доступа к ней и не помечена ли она для удаления."

#. type: Plain text
#: man-pages/man2/msgget.2:152
msgid ""
"If successful, the return value will be the message queue identifier (a "
"nonnegative integer), otherwise -1 with I<errno> indicating the error."
msgstr "При успешном выполнении возвращается идентификатор очереди сообщений (неотрицательное целое), иначе возвращается -1, а переменной I<errno> присваивается номер ошибки."

#. type: Plain text
#: man-pages/man2/msgget.2:156
msgid "On failure, I<errno> is set to one of the following values:"
msgstr "При ошибке I<errno> устанавливается в одно из следующих значений:"

#. type: Plain text
#: man-pages/man2/msgget.2:164
msgid ""
"A message queue exists for I<key>, but the calling process does not have "
"permission to access the queue, and does not have the B<CAP_IPC_OWNER> "
"capability in the user namespace that governs its IPC namespace."
msgstr "Очередь сообщений для ключа I<key> существует, но вызывающий процесс не имеет прав доступа к ней и не имеет мандата B<CAP_IPC_OWNER>, который управляет его пространством имён IPC."

#. type: Plain text
#: man-pages/man2/msgget.2:173
msgid ""
"B<IPC_CREAT> and B<IPC_EXCL> were specified in I<msgflg>, but a message "
"queue already exists for I<key>."
msgstr "В I<msgflg> указаны B<IPC_CREAT> и B<IPC_EXCL>, но очередь сообщений уже существует для I<key>."

#. type: Plain text
#: man-pages/man2/msgget.2:181
msgid ""
"No message queue exists for I<key> and I<msgflg> did not specify "
"B<IPC_CREAT>."
msgstr "Для ключа I<key> не существует очереди сообщений, но в I<msgflg> нет флага B<IPC_CREAT>."

#. type: Plain text
#: man-pages/man2/msgget.2:185
msgid ""
"A message queue has to be created but the system does not have enough memory"
" for the new data structure."
msgstr "Очередь сообщений необходимо создать, но системе не хватает памяти для хранения новой структуры данных."

#. type: Plain text
#: man-pages/man2/msgget.2:191
msgid ""
"A message queue has to be created but the system limit for the maximum "
"number of message queues (B<MSGMNI>)  would be exceeded."
msgstr "Очередь сообщений необходимо создать, но лимит, определяющий количество очередей сообщений (B<MSGMNI>), уже достигнут."

#. type: Plain text
#: man-pages/man2/msgget.2:216
msgid ""
"B<IPC_PRIVATE> isn't a flag field but a I<key_t> type.  If this special "
"value is used for I<key>, the system call ignores everything but the least "
"significant 9 bits of I<msgflg> and creates a new message queue (on "
"success)."
msgstr "B<IPC_PRIVATE> является не полем с флагами, а имеет тип I<key_t>. Если при работе с I<key> используется это специальное значение, то системный вызов игнорирует всё, кроме 9-ти младших битов в I<msgflg> и создаёт новую очередь сообщений (если это возможно)."

#. type: Plain text
#: man-pages/man2/msgget.2:220
msgid ""
"The following is a system limit on message queue resources affecting a "
"B<msgget>()  call:"
msgstr "На вызов B<msgget>() влияет системное ограничение по очередям сообщений:"

#. type: TP
#: man-pages/man2/msgget.2:220
#, no-wrap
msgid "B<MSGMNI>"
msgstr "B<MSGMNI>"

#.  commit 0050ee059f7fc86b1df2527aaa14ed5dc72f9973
#. type: Plain text
#: man-pages/man2/msgget.2:230
msgid ""
"System-wide limit on the number of message queues.  Before Linux 3.19, the "
"default value for this limit was calculated using a formula based on "
"available system memory.  Since Linux 3.19, the default value is 32,000.  On"
" Linux, this limit can be read and modified via I</proc/sys/kernel/msgmni>."
msgstr "Системное ограничение на максимальное количество очередей сообщений. В системах Linux до версии 3.19, значением по умолчанию этого ограничения рассчитывалось на основе формулы зависящей от доступной системной памяти. Начиная с Linux 3.19, значение по умолчанию равно 32000. В Linux это ограничение можно прочитать и изменять через  I</proc/sys/kernel/msgmni>)."

#. type: Plain text
#: man-pages/man2/msgget.2:236
msgid ""
"Until version 2.3.20, Linux would return B<EIDRM> for a B<msgget>()  on a "
"message queue scheduled for deletion."
msgstr "В Linux до версии 2.3.20 вызов B<msgget>() возвращал значение B<EIDRM>, если очередь сообщений была запланирована к удалению."

#. type: Plain text
#: man-pages/man2/msgget.2:242
msgid ""
"The name choice B<IPC_PRIVATE> was perhaps unfortunate, B<IPC_NEW> would "
"more clearly show its function."
msgstr "Имя B<IPC_PRIVATE>, возможно, было выбрано неудачно, B<IPC_NEW> отражает смысл действия более ясно."

#. type: Plain text
#: man-pages/man2/msgget.2:249
msgid ""
"B<msgctl>(2), B<msgrcv>(2), B<msgsnd>(2), B<ftok>(3), B<capabilities>(7), "
"B<mq_overview>(7), B<sysvipc>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/modify_ldt.2:25
#, no-wrap
msgid "MODIFY_LDT"
msgstr "MODIFY_LDT"

#. type: Plain text
#: man-pages/man2/modify_ldt.2:28
msgid "modify_ldt - get or set a per-process LDT entry"
msgstr "modify_ldt - возвращает или изменяет запись LDT у процесса"

#. type: Plain text
#: man-pages/man2/modify_ldt.2:31
#, no-wrap
msgid "B<#include E<lt>sys/types.hE<gt>>\n"
msgstr "B<#include E<lt>sys/types.hE<gt>>\n"

#. type: Plain text
#: man-pages/man2/modify_ldt.2:33
#, no-wrap
msgid ""
"B<int modify_ldt(int >I<func>B<, void *>I<ptr>B<, unsigned long "
">I<bytecount>B<);>\n"
msgstr "B<int modify_ldt(int >I<func>B<, void *>I<ptr>B<, unsigned long >I<bytecount>B<);>\n"

#. type: Plain text
#: man-pages/man2/modify_ldt.2:37
msgid "I<Note>: There is no glibc wrapper for this system call; see NOTES."
msgstr "I<Замечание>: В glibc нет обёрточной функции для данного системного вызова; смотрите ЗАМЕЧАНИЯ."

#. type: Plain text
#: man-pages/man2/modify_ldt.2:45
msgid ""
"B<modify_ldt>()  reads or writes the local descriptor table (LDT) for a "
"process.  The LDT is an array of segment descriptors that can be referenced "
"by user code.  Linux allows processes to configure a per-process (actually "
"per-mm) LDT.  For more information about the LDT, see the Intel Software "
"Developer's Manual or the AMD Architecture Programming Manual."
msgstr "Вызов B<modify_ldt>() считывает или записывает таблицу локальных дескрипторов (LDT) процесса. LDT представляет собой массив дескрипторов сегментов, которые могут использоваться в пользовательском коде. В Linux процессам разрешено настраивать попроцессные (в действительности, пространство памяти) LDT. Дополнительную информацию о LDT, смотрите в Intel Software Developer's Manual или AMD Architecture Programming Manual."

#. type: Plain text
#: man-pages/man2/modify_ldt.2:59
msgid ""
"When I<func> is 0, B<modify_ldt>()  reads the LDT into the memory pointed to"
" by I<ptr>.  The number of bytes read is the smaller of I<bytecount> and the"
" actual size of the LDT, although the kernel may act as though the LDT is "
"padded with additional trailing zero bytes.  On success, B<modify_ldt>()  "
"will return the number of bytes read."
msgstr "Если I<func> равно 0, то B<modify_ldt>() читает LDT в память, на которую указывает I<ptr>. Количество читаемых байт — меньшее из I<bytecount> и реального размера LDT несмотря на то, что ядро может действовать как будто LDT заполняется дополнительными нулевыми байтами в конце. При успешном выполнении B<modify_ldt>() возвращает количество прочитанных байт."

#. type: Plain text
#: man-pages/man2/modify_ldt.2:73
msgid ""
"When I<func> is 1 or 0x11, B<modify_ldt>()  modifies the LDT entry indicated"
" by I<ptr-E<gt>entry_number>.  I<ptr> points to a I<user_desc> structure and"
" I<bytecount> must equal the size of this structure."
msgstr "Если значение I<func> равно 1 или 0x11, то B<modify_ldt>() изменяет запись LDT, на которую указывает I<ptr-E<gt>entry_number>. Значение I<ptr> указывает на структуру I<user_desc>, а I<bytecount> должно быть равно размеру этой структуры."

#. type: Plain text
#: man-pages/man2/modify_ldt.2:77
msgid "The I<user_desc> structure is defined in I<E<lt>asm/ldt.hE<gt>> as:"
msgstr "Структура I<user_desc> определена в I<E<lt>asm/ldt.hE<gt>> следующим образом:"

#. type: Plain text
#: man-pages/man2/modify_ldt.2:91
#, no-wrap
msgid ""
"struct user_desc {\n"
"    unsigned int  entry_number;\n"
"    unsigned long base_addr;\n"
"    unsigned int  limit;\n"
"    unsigned int  seg_32bit:1;\n"
"    unsigned int  contents:2;\n"
"    unsigned int  read_exec_only:1;\n"
"    unsigned int  limit_in_pages:1;\n"
"    unsigned int  seg_not_present:1;\n"
"    unsigned int  useable:1;\n"
"};\n"
msgstr "struct user_desc {\n    unsigned int  entry_number;\n    unsigned long base_addr;\n    unsigned int  limit;\n    unsigned int  seg_32bit:1;\n    unsigned int  contents:2;\n    unsigned int  read_exec_only:1;\n    unsigned int  limit_in_pages:1;\n    unsigned int  seg_not_present:1;\n    unsigned int  useable:1;\n};\n"

#. type: Plain text
#: man-pages/man2/modify_ldt.2:96
msgid ""
"In Linux 2.4 and earlier, this structure was named I<modify_ldt_ldt_s>."
msgstr "В Linux версии 2.4 и более ранних эта структура называлась I<modify_ldt_ldt_s>."

#. type: Plain text
#: man-pages/man2/modify_ldt.2:104
msgid ""
"The I<contents> field is the segment type (data, expand-down data, non-"
"conforming code, or conforming code).  The other fields match their "
"descriptions in the CPU manual, although B<modify_ldt>()  cannot set the "
"hardware-defined \"accessed\" bit described in the CPU manual."
msgstr "В поле I<contents> определяется тип сегмента (данные, данные, расширяемые вниз (expand-down data), не соответствующий код (non-conforming code) или соответствующий код). Назначение других полей совпадает с их описанием в руководстве к процессору, несмотря на то, что B<modify_ldt>() не может изменить аппаратно-определяемый бит «доступа», описанный в руководстве к ЦП."

#. type: Plain text
#: man-pages/man2/modify_ldt.2:121
msgid ""
"A I<user_desc> is considered \"empty\" if I<read_exec_only> and "
"I<seg_not_present> are set to 1 and all of the other fields are 0.  An LDT "
"entry can be cleared by setting it to an \"empty\" I<user_desc> or, if "
"I<func> is 1, by setting both I<base> and I<limit> to 0."
msgstr "A I<user_desc> считается «пустым», если I<read_exec_only> и I<seg_not_present> равны 1, а все остальные поля равны 0. Элемент LDT можно очистить, назначив ему «пустой» I<user_desc> или, если I<func> равно 1, установив I<base> и I<limit> в 0."

#. type: Plain text
#: man-pages/man2/modify_ldt.2:130
msgid ""
"A conforming code segment (i.e., one with I<contents==3>)  will be rejected "
"if I<func> is 1 or if I<seg_not_present> is 0."
msgstr "Сегмент соответствующего кода (conforming code segment, т. е., с I<contents==3>) будет отклонён, если I<func> равно 1 или если I<seg_not_present> равно 0."

#. type: Plain text
#: man-pages/man2/modify_ldt.2:137
msgid ""
"When I<func> is 2, B<modify_ldt>()  will read zeros.  This appears to be a "
"leftover from Linux 2.4."
msgstr "Если I<func> равно 2, то B<modify_ldt>() прочитает нули. Это, кажется, пережиток из Linux 2.4."

#. type: Plain text
#: man-pages/man2/modify_ldt.2:147
msgid ""
"On success, B<modify_ldt>()  returns either the actual number of bytes read "
"(for reading)  or 0 (for writing).  On failure, B<modify_ldt>()  returns -1 "
"and sets I<errno> to indicate the error."
msgstr "При успешном выполнении B<modify_ldt>() возвращается реальное количество прочитанных байт (при чтении) или 0 (при записи). При ошибке B<modify_ldt>() возвращает -1, а I<errno> устанавливается в соответствующее значение."

#. type: Plain text
#: man-pages/man2/modify_ldt.2:152
msgid "I<ptr> points outside the address space."
msgstr "Значение I<ptr> указывает за пределы адресного пространства."

#. type: Plain text
#: man-pages/man2/modify_ldt.2:165
msgid ""
"I<ptr> is 0, or I<func> is 1 and I<bytecount> is not equal to the size of "
"the structure I<user_desc>, or I<func> is 1 or 0x11 and the new LDT entry "
"has invalid values."
msgstr "Значение I<ptr> равно 0, или I<func> равно 1, а I<bytecount> не равно размеру структуры I<user_desc>, или I<func> равно 1 или 0x11, а новый элемент LDT содержит неправильные значения."

#. type: TP
#: man-pages/man2/modify_ldt.2:165
#, no-wrap
msgid "B<ENOSYS>"
msgstr "B<ENOSYS>"

#. type: Plain text
#: man-pages/man2/modify_ldt.2:169
msgid "I<func> is neither 0, 1, 2, nor 0x11."
msgstr "Значение I<func> не равно 0, 1, 2 или 0x11."

#. type: Plain text
#: man-pages/man2/modify_ldt.2:172
msgid ""
"This call is Linux-specific and should not be used in programs intended to "
"be portable."
msgstr "Данный вызов есть только в Linux и не должен использоваться в программах, которые должны быть переносимыми."

#. type: Plain text
#: man-pages/man2/modify_ldt.2:175
msgid ""
"Glibc does not provide a wrapper for this system call; call it using "
"B<syscall>(2)."
msgstr "В glibc нет обёртки для данного системного вызова; запускайте его с помощью B<syscall>(2)."

#. type: Plain text
#: man-pages/man2/modify_ldt.2:185
msgid ""
"B<modify_ldt>()  should not be used for thread-local storage, as it slows "
"down context switches and only supports a limited number of threads.  "
"Threading libraries should use B<set_thread_area>(2)  or B<arch_prctl>(2)  "
"instead, except on extremely old kernels that do not support those system "
"calls."
msgstr "Вызов B<modify_ldt>() не должен использоваться для локального хранилища нити, так как это замедляет переключение контекста и поддерживается только для ограниченного количества нитей. Вместо этого в библиотеках нитей должны использоваться B<set_thread_area>(2) или B<arch_prctl>(2), только если не нужна поддержка старых ядер, где нет этих вызовов."

#. type: Plain text
#: man-pages/man2/modify_ldt.2:190
msgid ""
"The normal use for B<modify_ldt>()  is to run legacy 16-bit or segmented "
"32-bit code.  Not all kernels allow 16-bit segments to be installed, "
"however."
msgstr "Обычно, B<modify_ldt>() используют для запуска старого 16-битного или сегментированного 32-битного кода. Однако, не все ядра допускают установку 16-битных сегментов."

#. type: Plain text
#: man-pages/man2/modify_ldt.2:198
msgid ""
"Even on 64-bit kernels, B<modify_ldt>()  cannot be used to create a long "
"mode (i.e., 64-bit) code segment.  The undocumented field \"lm\" in "
"I<user_desc> is not useful, and, despite its name, does not result in a long"
" mode segment."
msgstr "Даже в 64-битных ядрах вызов B<modify_ldt>() нельзя использовать для создания сегмента кода в длинном режиме (т. е., 64-битного). Недокументированное поле «lm» в I<user_desc> не помогает и, несмотря на имя, не образует сегмент в длинном режиме."

#.  commit e30ab185c490e9a9381385529e0fd32f0a399495
#. type: Plain text
#: man-pages/man2/modify_ldt.2:207
msgid ""
"On 64-bit kernels before Linux 3.19, setting the \"lm\" bit in I<user_desc> "
"prevents the descriptor from being considered empty.  Keep in mind that the "
"\"lm\" bit does not exist in the 32-bit headers, but these buggy kernels "
"will still notice the bit even when set in a 32-bit process."
msgstr "В 64-битных ядрах до Linux 3.19, установка бита «lm» в I<user_desc> приводила к тому, что дескриптор переставал считаться пустым. Учтите, что бит «lm» не существует в 32-битных заголовках, но есть дефектные ядра, которые по-прежнему сообщают о бите даже в 32-битном процессе."

#. type: Plain text
#: man-pages/man2/modify_ldt.2:210
msgid "B<arch_prctl>(2), B<set_thread_area>(2), B<vm86>(2)"
msgstr "B<arch_prctl>(2), B<set_thread_area>(2), B<vm86>(2)"

#. type: TH
#: man-pages/man2/mount.2:40
#, no-wrap
msgid "MOUNT"
msgstr "MOUNT"

#. type: Plain text
#: man-pages/man2/mount.2:43
msgid "mount - mount filesystem"
msgstr "mount - применяется для монтирования файловых систем."

#. type: Plain text
#: man-pages/man2/mount.2:46
#, no-wrap
msgid "B<#include E<lt>sys/mount.hE<gt>>\n"
msgstr "B<#include E<lt>sys/mount.hE<gt>>\n"

#. type: Plain text
#: man-pages/man2/mount.2:50
#, no-wrap
msgid ""
"B<int mount(const char *>I<source>B<, const char *>I<target>B<,>\n"
"B<          const char *>I<filesystemtype>B<, unsigned long >I<mountflags>B<,>\n"
"B<          const void *>I<data>B<);>\n"
msgstr "B<int mount(const char *>I<source>B<, const char *>I<target>B<,>\nB<          const char *>I<filesystemtype>B<, unsigned long >I<mountflags>B<,>\nB<          const void *>I<data>B<);>\n"

#. type: Plain text
#: man-pages/man2/mount.2:60
msgid ""
"B<mount>()  attaches the filesystem specified by I<source> (which is often a"
" pathname referring to a device, but can also be the pathname of a directory"
" or file, or a dummy string) to the location (a directory or file)  "
"specified by the pathname in I<target>."
msgstr "Вызов B<mount>() подключает файловую систему, указанную в I<source> (обычно здесь задаётся название устройства, но также может быть указано имя каталога, или файла, или фиктивное устройство), к пути заданному в I<target>(каталогу или файлу)."

#. type: Plain text
#: man-pages/man2/mount.2:64
msgid ""
"Appropriate privilege (Linux: the B<CAP_SYS_ADMIN> capability) is required "
"to mount filesystems."
msgstr "Для монтирования файловых систем требуются специальные права (Linux: мандат B<CAP_SYS_ADMIN>)."

#. type: Plain text
#: man-pages/man2/mount.2:73
msgid ""
"Values for the I<filesystemtype> argument supported by the kernel are listed"
" in I</proc/filesystems> (e.g., \"btrfs\", \"ext4\", \"jfs\", \"xfs\", "
"\"vfat\", \"fuse\", \"tmpfs\", \"cgroup\", \"proc\", \"mqueue\", \"nfs\", "
"\"cifs\", \"iso9660\").  Further types may become available when the "
"appropriate modules are loaded."
msgstr "Вариант I<filesystemtype> доступные ядру перечислены в  I</proc/filesystems> (например: \"btrfs\", \"ext4\", \"jfs\", \"xfs\", \"vfat\", \"fuse\", \"tmpfs\", \"cgroup\", \"proc\", \"mqueue\", \"nfs\", \"cifs\", \"iso9660\"). Дополнительные типы становятся доступными после загрузки соответствующих модулей."

#. type: Plain text
#: man-pages/man2/mount.2:82
msgid ""
"The I<data> argument is interpreted by the different filesystems.  Typically"
" it is a string of comma-separated options understood by this filesystem.  "
"See B<mount>(8)  for details of the options available for each filesystem "
"type."
msgstr "Аргумент I<data> рассматривается каждой файловой системой по-своему. Обычно, это строка параметров, перечисленных через запятую, которые понимает файловая система. О том, какие параметры доступны для каждого типа файловой системы смотрите B<mount>(8)."

#. type: Plain text
#: man-pages/man2/mount.2:92
msgid ""
"A call to B<mount>()  performs one of a number of general types of "
"operation, depending on the bits specified in I<mountflags>.  The choice of "
"which operation to perform is determined by testing the bits set in "
"I<mountflags>, with the tests being conducted in the order listed here:"
msgstr "Вызов B<mount>() выполняет один из нескольких типов операций, в зависимости от значений, указанных в I<mountflags>. Выбор выполняемой операции определяется путем тестирования значений, установленных в I<mountflags>, с проведением тестов в следующем порядке:"

#. type: Plain text
#: man-pages/man2/mount.2:97
msgid "Remount an existing mount: I<mountflags> includes B<MS_REMOUNT>."
msgstr "Перемонтировать существующие точки монтирования: I<mountflags> включает B<MS_REMOUNT>."

#. type: Plain text
#: man-pages/man2/mount.2:102
msgid "Create a bind mount: I<mountflags> includes B<MS_BIND>."
msgstr "Создать привязку (bind mount): I<mountflags> включает B<MS_BIND>."

#. type: Plain text
#: man-pages/man2/mount.2:111
msgid ""
"Change the propagation type of an existing mount: I<mountflags> includes one"
" of B<MS_SHARED>, B<MS_PRIVATE>, B<MS_SLAVE>, or B<MS_UNBINDABLE>."
msgstr "Изменить тип существующего монтирования: I<mountflags> включает одно из B<MS_SHARED>, B<MS_PRIVATE>, B<MS_SLAVE> или B<MS_UNBINDABLE>."

#. type: Plain text
#: man-pages/man2/mount.2:116
msgid ""
"Move an existing mount to a new location: I<mountflags> includes B<MS_MOVE>."
msgstr "Переместить существующее монтирование в новое место: I<mountflags> включает B<MS_MOVE>."

#. type: Plain text
#: man-pages/man2/mount.2:120
msgid "Create a new mount: I<mountflags> includes none of the above flags."
msgstr "Создать новое монтирование: I<mountflags> не содержит ни один из указанных выше флагов."

#. type: Plain text
#: man-pages/man2/mount.2:128
msgid ""
"Each of these operations is detailed later in this page.  Further flags may "
"be specified in I<mountflags> to modify the behavior of B<mount>(), as "
"described below."
msgstr "Каждая из этих операций подробно описана далее на этой странице. Для изменения поведения B<mount>() могут быть указаны дополнительные флаги в I<mountflags>, как описано ниже."

#. type: SS
#: man-pages/man2/mount.2:128
#, no-wrap
msgid "Additional mount flags"
msgstr "Дополнительные флаги для монтирования"

#.  FIXME 2.6.25 Added MS_I_VERSION, which needs to be documented.
#.  commit 7a224228ed79d587ece2304869000aad1b8e97dd
#.  (This is a per-superblock flag)
#. type: Plain text
#: man-pages/man2/mount.2:138
msgid ""
"The list below describes the additional flags that can be specified in "
"I<mountflags>.  Note that some operation types ignore some or all of these "
"flags, as described later in this page."
msgstr "Ниже расположенный список дополнительных флагов, которые можно использовать в  I<mountflags>. Обратите внимание на то, что некоторые из них или даже все игнорируются операциями. Такие случае будут описаны далее по тексту."

#. type: TP
#: man-pages/man2/mount.2:138
#, no-wrap
msgid "B<MS_DIRSYNC> (since Linux 2.5.19)"
msgstr "B<MS_DIRSYNC> (начиная с Linux 2.5.19)"

#. type: Plain text
#: man-pages/man2/mount.2:144
msgid ""
"Make directory changes on this filesystem synchronous.  (This property can "
"be obtained for individual directories or subtrees using B<chattr>(1).)"
msgstr "Осуществлять изменения каталогов на этой файловой системе синхронно. Это свойство может быть получено для отдельных каталогов или дерева подкаталогов с помощью B<chattr>(1)."

#. type: TP
#: man-pages/man2/mount.2:144
#, no-wrap
msgid "B<MS_LAZYTIME> (since Linux 4.0)"
msgstr "B<MS_LAZYTIME> (начиная с Linux 4.0)"

#.  commit 0ae45f63d4ef8d8eeec49c7d8b44a1775fff13e8
#.  commit fe032c422c5ba562ba9c2d316f55e258e03259c6
#.  commit a26f49926da938f47561f386be56a83dd37a496d
#. type: Plain text
#: man-pages/man2/mount.2:152
msgid ""
"Reduce on-disk updates of inode timestamps (atime, mtime, ctime)  by "
"maintaining these changes only in memory.  The on-disk timestamps are "
"updated only when:"
msgstr "Можно уменьшить количество обращений к диску, если сохранять дескрипторы меток времени (atime, mtime, ctime) только в памяти. Временные метки на диске обновляются только в следующих случаях:"

#. type: IP
#: man-pages/man2/mount.2:153
#, no-wrap
msgid "(a)"
msgstr "(a)"

#. type: Plain text
#: man-pages/man2/mount.2:155
msgid ""
"the inode needs to be updated for some change unrelated to file timestamps;"
msgstr "дескрипторы необходимо обновить для некоторого изменения, не связанного с временными метками файлов;"

#. type: IP
#: man-pages/man2/mount.2:155
#, no-wrap
msgid "(b)"
msgstr "(b)"

#. type: Plain text
#: man-pages/man2/mount.2:161
msgid "the application employs B<fsync>(2), B<syncfs>(2), or B<sync>(2);"
msgstr "приложение использует B<fsync>(2), B<syncfs>(2), or B<sync>(2);"

#. type: IP
#: man-pages/man2/mount.2:161
#, no-wrap
msgid "(c)"
msgstr "(c)"

#. type: Plain text
#: man-pages/man2/mount.2:163
msgid "an undeleted inode is evicted from memory; or"
msgstr "неиспользуемый дескриптор вытесняется из памяти; или"

#. type: IP
#: man-pages/man2/mount.2:163
#, no-wrap
msgid "(d)"
msgstr "(d)"

#. type: Plain text
#: man-pages/man2/mount.2:165
msgid "more than 24 hours have passed since the inode was written to disk."
msgstr "прошло более 24 часов с момента записи дескриптора на диск."

#. type: Plain text
#: man-pages/man2/mount.2:171
msgid ""
"This mount option significantly reduces writes needed to update the inode's "
"timestamps, especially mtime and atime.  However, in the event of a system "
"crash, the atime and mtime fields on disk might be out of date by up to 24 "
"hours."
msgstr "Данный параметр монтирования существенно сокращает количество операций записи, необходимых для обновления меток времени inode, особенно mtime и atime. Однако, если произойдёт падение системы, то поля atime и mtime на диске могут оказаться устаревшими на 24 часа."

#. type: Plain text
#: man-pages/man2/mount.2:185
msgid ""
"Examples of workloads where this option could be of significant benefit "
"include frequent random writes to preallocated files, as well as cases where"
" the B<MS_STRICTATIME> mount option is also enabled.  (The advantage of "
"combining B<MS_STRICTATIME> and B<MS_LAZYTIME> is that B<stat>(2)  will "
"return the correctly updated atime, but the atime updates will be flushed to"
" disk only in the cases listed above.)"
msgstr "В качестве примеров, где данный параметр может принести значительную выгоду это частые произвольные операции записи в уже выделенные файлы, а также случаи, когда также включён параметр монтирования B<MS_STRICTATIME> (преимущество объединения B<MS_STRICTATIME> и B<MS_LAZYTIME> в том, что B<stat>(2) будет возвращать правильное обновлённое время, но обновления atime будет производиться на диск только в случаях перечисленных выше)."

#. type: TP
#: man-pages/man2/mount.2:185
#, no-wrap
msgid "B<MS_MANDLOCK>"
msgstr "B<MS_MANDLOCK>"

#.  commit 95ace75414f312f9a7b93d873f386987b92a5301
#. type: Plain text
#: man-pages/man2/mount.2:198
msgid ""
"Permit mandatory locking on files in this filesystem.  (Mandatory locking "
"must still be enabled on a per-file basis, as described in B<fcntl>(2).)  "
"Since Linux 4.5, this mount option requires the B<CAP_SYS_ADMIN> capability "
"and a kernel configured with the B<CONFIG_MANDATORY_FILE_LOCKING> option."
msgstr "Разрешить обязательную блокировку файлов в этой файловой системе (обязательная блокировка всё равно сначала должна быть включена для определённого файла как описано в B<fcntl>(2)). Начиная с Linux 4.5 этот параметр монтирования требует мандата B<CAP_SYS_ADMIN> и ядро должно быть настроено с параметром B<CONFIG_MANDATORY_FILE_LOCKING>."

#. type: TP
#: man-pages/man2/mount.2:198
#, no-wrap
msgid "B<MS_NOATIME>"
msgstr "B<MS_NOATIME>"

#. type: Plain text
#: man-pages/man2/mount.2:201
msgid ""
"Do not update access times for (all types of) files on this filesystem."
msgstr "Не обновлять время доступа для (всех типов) файлов в этой файловой системе."

#. type: TP
#: man-pages/man2/mount.2:201
#, no-wrap
msgid "B<MS_NODEV>"
msgstr "B<MS_NODEV>"

#. type: Plain text
#: man-pages/man2/mount.2:204
msgid "Do not allow access to devices (special files) on this filesystem."
msgstr "Запретить доступ к устройствам (специальным файлам) в этой файловой системе."

#. type: TP
#: man-pages/man2/mount.2:204
#, no-wrap
msgid "B<MS_NODIRATIME>"
msgstr "B<MS_NODIRATIME>"

#. type: Plain text
#: man-pages/man2/mount.2:213
msgid ""
"Do not update access times for directories on this filesystem.  This flag "
"provides a subset of the functionality provided by B<MS_NOATIME>; that is, "
"B<MS_NOATIME> implies B<MS_NODIRATIME>."
msgstr "Не обновлять время доступа для каталогов в этой файловой системе. Данный флаг частично предоставляет свойство B<MS_NOATIME>; то есть при B<MS_NOATIME> подразумевается B<MS_NODIRATIME>."

#. type: TP
#: man-pages/man2/mount.2:213
#, no-wrap
msgid "B<MS_NOEXEC>"
msgstr "B<MS_NOEXEC>"

#.  (Possibly useful for a filesystem that contains non-Linux executables.
#.  Often used as a security feature, e.g., to make sure that restricted
#.  users cannot execute files uploaded using ftp or so.)
#. type: Plain text
#: man-pages/man2/mount.2:219
msgid "Do not allow programs to be executed from this filesystem."
msgstr "Запретить исполнение программ в этой файловой системе."

#. type: TP
#: man-pages/man2/mount.2:219
#, no-wrap
msgid "B<MS_NOSUID>"
msgstr "B<MS_NOSUID>"

#.  (This is a security feature to prevent users executing set-user-ID and
#.  set-group-ID programs from removable disk devices.)
#. type: Plain text
#: man-pages/man2/mount.2:225
msgid ""
"Do not honor set-user-ID and set-group-ID bits or file capabilities when "
"executing programs from this filesystem."
msgstr "Не учитывать биты set-UID и set-GID или файловые мандаты при исполнении программ в этой файловой системе."

#. type: TP
#: man-pages/man2/mount.2:225
#, no-wrap
msgid "B<MS_RDONLY>"
msgstr "B<MS_RDONLY>"

#. type: Plain text
#: man-pages/man2/mount.2:228
msgid "Mount filesystem read-only."
msgstr "Подключить файловую систему в режиме только для чтения."

#. type: TP
#: man-pages/man2/mount.2:228
#, no-wrap
msgid "B<MS_REC> (since Linux 2.4.11)"
msgstr "B<MS_REC> (начиная с Linux 2.4.11)"

#. type: Plain text
#: man-pages/man2/mount.2:236
msgid ""
"Used in conjunction with B<MS_BIND> to create a recursive bind mount, and in"
" conjunction with the propagation type flags to recursively change the "
"propagation type of all of the mounts in a subtree.  See below for further "
"details."
msgstr "Используется вместе с B<MS_BIND> для создания рекурсивной точки монтирования и вместе с флагами типа распространения для рекурсивного изменения типа распространения всех точек монтирования в поддереве. Подробности смотрите далее."

#. type: TP
#: man-pages/man2/mount.2:236
#, no-wrap
msgid "B<MS_RELATIME> (since Linux 2.6.20)"
msgstr "B<MS_RELATIME> (начиная с Linux 2.6.20)"

#.  Matthew Garrett notes in the patch that added this behavior
#.  that this lets utilities such as tmpreaper (which deletes
#.  files based on last access time) work correctly.
#. type: Plain text
#: man-pages/man2/mount.2:257
msgid ""
"When a file on this filesystem is accessed, update the file's last access "
"time (atime) only if the current value of atime is less than or equal to the"
" file's last modification time (mtime)  or last status change time (ctime)."
"  This option is useful for programs, such as B<mutt>(1), that need to know "
"when a file has been read since it was last modified.  Since Linux 2.6.30, "
"the kernel defaults to the behavior provided by this flag (unless "
"B<MS_NOATIME> was specified), and the B<MS_STRICTATIME> flag is required to "
"obtain traditional semantics.  In addition, since Linux 2.6.30, the file's "
"last access time is always updated if it is more than 1 day old."
msgstr "При доступе к файлу на этой файловой системе значение времени последнего доступа к файлу (atime) обновляется, только если текущее значение atime меньше или равно времени последнего изменения файла (mtime) или времени последнего изменения состояния файла (ctime). Этот флаг полезен для программ (например, B<mutt>(1)), которым нужно знать, что файл был прочитан с момента его последнего изменения. Начиная с Linux 2.6.30 в ядро это поведение включено по умолчанию (если не указан B<MS_NOATIME>), а чтобы получить обычное поведение нужно указать флаг B<MS_STRICTATIME>. Также, начиная с Linux 2.6.30 время последнего доступа к файлу всегда обновляется, если оно устаревает на один день."

#. type: TP
#: man-pages/man2/mount.2:257
#, no-wrap
msgid "B<MS_SILENT> (since Linux 2.6.17)"
msgstr "B<MS_SILENT> (начиная с Linux 2.6.17)"

#. type: Plain text
#: man-pages/man2/mount.2:265
msgid ""
"Suppress the display of certain (I<printk>())  warning messages in the "
"kernel log.  This flag supersedes the misnamed and obsolete B<MS_VERBOSE> "
"flag (available since Linux 2.4.12), which has the same meaning."
msgstr "Не выводить определённые (I<printk>()) предупреждающие сообщения в журнал ядра. Этот флаг заменяет неправильно названный и устаревший флаг B<MS_VERBOSE> (доступный начиная с Linux 2.4.12), который выполняет такую же функцию."

#. type: TP
#: man-pages/man2/mount.2:265
#, no-wrap
msgid "B<MS_STRICTATIME> (since Linux 2.6.30)"
msgstr "B<MS_STRICTATIME> (начиная с Linux 2.6.30)"

#. type: Plain text
#: man-pages/man2/mount.2:275
msgid ""
"Always update the last access time (atime) when files on this filesystem are"
" accessed.  (This was the default behavior before Linux 2.6.30.)  Specifying"
" this flag overrides the effect of setting the B<MS_NOATIME> and "
"B<MS_RELATIME> flags."
msgstr "Всегда обновлять время последнего доступа (atime) при доступе к файлам на этой файловой системе (это выполнялось по умолчанию до Linux 2.6.30). Задание этого флага отменяет поведение флагов B<MS_NOATIME> и B<MS_RELATIME>."

#. type: TP
#: man-pages/man2/mount.2:275
#, no-wrap
msgid "B<MS_SYNCHRONOUS>"
msgstr "B<MS_SYNCHRONOUS>"

#. type: Plain text
#: man-pages/man2/mount.2:283
msgid ""
"Make writes on this filesystem synchronous (as though the B<O_SYNC> flag to "
"B<open>(2)  was specified for all file opens to this filesystem)."
msgstr "Осуществлять запись на эту файловую систему синхронно (как если бы флаг B<O_SYNC> для B<open>(2) был указан для всех файлов, открытых на этой файловой системе)."

#. type: Plain text
#: man-pages/man2/mount.2:289
msgid ""
"From Linux 2.4 onward, some of the above flags are settable on a per-mount "
"basis, while others apply to the superblock of the mounted filesystem, "
"meaning that all mounts of the same filesystem share those flags.  "
"(Previously, all of the flags were per-superblock.)"
msgstr "Начиная с Linux 2.4 одни из показанных выше флагов можно устанавливать на точки монтирования (свой набор на каждой), а другие — на суперблок смонтированной файловой системы, то есть все монтирования одной файловой системы имеют одинаковый набор этих флагов (ранее все флаги применялись к суперблоку)."

#. type: Plain text
#: man-pages/man2/mount.2:291
msgid "The per-mount-point flags are as follows:"
msgstr "Флаги набора для точки монтирования:"

#. type: Plain text
#: man-pages/man2/mount.2:295
msgid ""
"Since Linux 2.4: B<MS_NODEV>, B<MS_NOEXEC>, and B<MS_NOSUID> flags are "
"settable on a per-mount-point basis."
msgstr "Начиная с Linux 2.4: флаги B<MS_NODEV>, B<MS_NOEXEC> и B<MS_NOSUID> задаются для каждой точки монтирования отдельно."

#. type: Plain text
#: man-pages/man2/mount.2:300
msgid "Since Linux 2.6.16: B<MS_NOATIME> and B<MS_NODIRATIME>."
msgstr "Начиная с Linux 2.6.16: B<MS_NOATIME> и B<MS_NODIRATIME>."

#. type: Plain text
#: man-pages/man2/mount.2:303
msgid "Since Linux 2.6.20: B<MS_RELATIME>."
msgstr "Начиная с Linux 2.6.20: B<MS_RELATIME>."

#.  And MS_I_VERSION?
#. type: Plain text
#: man-pages/man2/mount.2:319
msgid ""
"The following flags are per-superblock: B<MS_DIRSYNC>, B<MS_LAZYTIME>, "
"B<MS_MANDLOCK>, B<MS_MS_SILENT>, and B<MS_SYNCHRONOUS>.  The initial "
"settings of these flags are determined on the first mount of the filesystem,"
" and will be shared by all subsequent mounts of the same filesystem.  "
"Subsequently, the settings of the flags can be changed via a remount "
"operation (see below).  Such changes will be visible via all mount points "
"associated with the filesystem."
msgstr "Следующие флаги указываются для суперблока: B<MS_DIRSYNC>, B<MS_LAZYTIME>, B<MS_MANDLOCK>, B<MS_MS_SILENT> и B<MS_SYNCHRONOUS>. Начальный настройки этих флагов определяются по первому монтированию файловой системы и будут общими для всех последующих монтирований этой файловой системы. Следовательно, набор флагом можно изменить через операцию перемонтирования (смотрите далее). Эти изменения отразятся на всех точках монтирования, связанных с этой файловой системой."

#. type: Plain text
#: man-pages/man2/mount.2:327
msgid ""
"Since Linux 2.6.16, B<MS_RDONLY> can be set or cleared on a per-mount-point "
"basis as well as on the underlying filesystem superblock.  The mounted "
"filesystem will be writable only if neither the filesystem nor the "
"mountpoint are flagged as read-only."
msgstr "Начиная с Linux 2.6.16 флаг B<MS_RDONLY> может устанавливаться и сбрасываться на точках монтирования по отдельности, а также на нижележащем суперблоке файловой системы. Смонтированная файловая система будет доступна на запись только, если она сама и её точка монтирования не помечены только для чтения."

#. type: SS
#: man-pages/man2/mount.2:327
#, no-wrap
msgid "Remounting an existing mount"
msgstr "Перемонтированние существующих точек монтирования."

#. type: Plain text
#: man-pages/man2/mount.2:341
msgid ""
"An existing mount may be remounted by specifying B<MS_REMOUNT> in "
"I<mountflags>.  This allows you to change the I<mountflags> and I<data> of "
"an existing mount without having to unmount and remount the filesystem.  "
"I<target> should be the same value specified in the initial B<mount>()  "
"call."
msgstr "Существующие монтирования можно перемонтировать, указав B<MS_REMOUNT> в I<mountflags>. Это позволяет изменить I<mountflags> и I<data> существующих монтирований без необходимости размонтировать и заново монтировать файловую систему. I<target> должен соответствовать указанному при начальном вызове B<mount>()."

#. type: Plain text
#: man-pages/man2/mount.2:347
msgid "The I<source> and I<filesystemtype> arguments are ignored."
msgstr "Аргументы I<source> и I<filesystemtype> игнорируются."

#. type: Plain text
#: man-pages/man2/mount.2:355
msgid ""
"The I<mountflags> and I<data> arguments should match the values used in the "
"original B<mount>()  call, except for those parameters that are being "
"deliberately changed."
msgstr "Аргументы I<mountflags> и I<data> должны совпадать со значениями, используемыми в первоначальном вызове B<mount>(), за исключением параметров, которые были преднамеренно изменены."

#.  FIXME
#.  MS_LAZYTIME seems to be available only on a few filesystems,
#.  and on ext4, it seems (from experiment that this flag
#.  can only be enabled (but not disabled) on a remount.
#.  The following code in ext4_remount() (kernel 4.17) seems to
#.  confirm this:
#.         if (*flags & SB_LAZYTIME)
#.                 sb->s_flags |= SB_LAZYTIME;
#.  See the definition of MS_RMT_MASK in include/uapi/linux/fs.h,
#.  which excludes MS_DIRSYNC and MS_SILENT, although SB_DIRSYNC
#.  and SB_SILENT are split out as per-superblock flags in do_mount()
#.  (Linux 4.17 source code)
#. type: Plain text
#: man-pages/man2/mount.2:397
msgid ""
"The following I<mountflags> can be changed: B<MS_LAZYTIME>, B<MS_MANDLOCK>, "
"B<MS_NOATIME>, B<MS_NODEV>, B<MS_NODIRATIME>, B<MS_NOEXEC>, B<MS_NOSUID>, "
"B<MS_RELATIME>, B<MS_RDONLY>, B<MS_STRICTATIME> (whose effect is to clear "
"the B<MS_NOATIME> and B<MS_RELATIME> flags), and B<MS_SYNCHRONOUS>.  "
"Attempts to change the setting of the B<MS_DIRSYNC> and B<MS_SILENT> flags "
"during a remount are silently ignored.  Note that changes to per-superblock "
"flags are visible via all mount points of the associated filesystem (because"
" the per-superblock flags are shared by all mount points)."
msgstr "В I<mountflags> можно изменять: B<MS_LAZYTIME>, B<MS_MANDLOCK>, B<MS_NOATIME>, B<MS_NODEV>, B<MS_NODIRATIME>, B<MS_NOEXEC>, B<MS_NOSUID>, B<MS_RELATIME>, B<MS_RDONLY>, B<MS_STRICTATIME> (стирает флаги B<MS_NOATIME> и B<MS_RELATIME>) и B<MS_SYNCHRONOUS>. Попытка изменить флаги B<MS_DIRSYNC> и B<MS_SILENT> при перементировании игнорируется без ошибки. Заметим, что изменения флагов суперблока видимы на всех точках монтирования файловой системы (так как флаги суперблока едины для всех точек монтирования)."

#.  commit ffbc6f0ead47fa5a1dc9642b0331cb75c20a640e
#. type: Plain text
#: man-pages/man2/mount.2:411
msgid ""
"Since Linux 3.17, if none of B<MS_NOATIME>, B<MS_NODIRATIME>, "
"B<MS_RELATIME>, or B<MS_STRICTATIME> is specified in I<mountflags>, then the"
" remount operation preserves the existing values of these flags (rather than"
" defaulting to B<MS_RELATIME>)."
msgstr "Начиная с Linux 3.17, если не одно из значений B<MS_NOATIME>, B<MS_NODIRATIME>, B<MS_RELATIME>, или B<MS_STRICTATIME> не указано в I<mountflags> , то при перемонтировании сохраняются текущие значения этих флагов (а не изменяются на значение по умолчанию B<MS_RELATIME>)."

#.  See https://lwn.net/Articles/281157/
#. type: Plain text
#: man-pages/man2/mount.2:423
msgid ""
"Since Linux 2.6.26, the B<MS_REMOUNT> flag can be used with B<MS_BIND> to "
"modify only the per-mount-point flags.  This is particularly useful for "
"setting or clearing the \"read-only\" flag on a mount point without changing"
" the underlying filesystem.  Specifying I<mountflags> as:"
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:427
#, no-wrap
msgid "MS_REMOUNT | MS_BIND | MS_RDONLY\n"
msgstr "MS_REMOUNT | MS_BIND | MS_RDONLY\n"

#. type: Plain text
#: man-pages/man2/mount.2:433
msgid ""
"will make access through this mountpoint read-only, without affecting other "
"mount points."
msgstr "будет обеспечен доступ к этой точке монтирования в режиме только для чтения, без изменения других точек монтирования."

#. type: SS
#: man-pages/man2/mount.2:433
#, no-wrap
msgid "Creating a bind mount"
msgstr "Создание привязки монтирования"

#.  since 2.4.0-test9
#. type: Plain text
#: man-pages/man2/mount.2:446
msgid ""
"If I<mountflags> includes B<MS_BIND> (available since Linux 2.4), then "
"perform a bind mount.  A bind mount makes a file or a directory subtree "
"visible at another point within the single directory hierarchy.  Bind mounts"
" may cross filesystem boundaries and span B<chroot>(2)  jails."
msgstr "Если I<mountflags> содержит B<MS_BIND> (доступен, начиная с Linux 2.4), то выполняется привязка монтирования. Привязка монтирования делает видимым файл или поддерево каталогов в другой точке внутри одной иерархии каталогов. Привязки монтирования могут быть в разных файловых системах и перекрывают заключения B<chroot>(2)."

#. type: Plain text
#: man-pages/man2/mount.2:452
msgid "The I<filesystemtype> and I<data> arguments are ignored."
msgstr "Аргументы I<filesystemtype> и I<data> игнорируются."

#. type: Plain text
#: man-pages/man2/mount.2:462
msgid ""
"The remaining bits (other than B<MS_REC>, described below) in the "
"I<mountflags> argument are also ignored.  (The bind mount has the same mount"
" options as the underlying mount point.)  However, see the discussion of "
"remounting above, for a method of making an existing bind mount read-only."
msgstr "Остальные биты (кроме B<MS_REC>, описано ниже) в аргументе I<mountflags> также игнорируются. Однако посмотрите обсуждение перемонтирования, представленное выше, о том, как сделать существующую привязку монтирования доступной только для чтения."

#. type: Plain text
#: man-pages/man2/mount.2:477
msgid ""
"By default, when a directory is bind mounted, only that directory is "
"mounted; if there are any submounts under the directory tree, they are not "
"bind mounted.  If the B<MS_REC> flag is also specified, then a recursive "
"bind mount operation is performed: all submounts under the I<source> subtree"
" (other than unbindable mounts)  are also bind mounted at the corresponding "
"location in the I<target> subtree."
msgstr "По умолчанию, когда каталогу назначена привязка монтирования, монтируется только этот каталог; если существуют другие подмонтирования в дереве каталогов, то им не назначается привязка монтирования. Если также указан флаг B<MS_REC>, то выполняется операция рекурсивной привязки монтирования: всем подмонтированиям в поддереве I<source> (отличным от непривязываемых монтирований) также назначается привязка монтирования в соответствующее расположение к поддереве I<target>."

#. type: SS
#: man-pages/man2/mount.2:477
#, no-wrap
msgid "Changing the propagation type of an existing mount"
msgstr "Изменение типа распространения существующего монтирования"

#. type: Plain text
#: man-pages/man2/mount.2:489
msgid ""
"If I<mountflags> includes one of B<MS_SHARED>, B<MS_PRIVATE>, B<MS_SLAVE>, "
"or B<MS_UNBINDABLE> (all available since Linux 2.6.15), then the propagation"
" type of an existing mount is changed.  If more than one of these flags is "
"specified, an error results."
msgstr "Если I<mountflags> содержит один из флагов B<MS_SHARED>, B<MS_PRIVATE>, B<MS_SLAVE>, или B<MS_UNBINDABLE> (все доступны начиная с Linux 2.6.15), то тип распространения существующего монтирования изменяется. Если указано сразу несколько из этих флагов, то возвращается ошибка."

#. type: Plain text
#: man-pages/man2/mount.2:496
msgid ""
"The only other flags that can be specified while changing the propagation "
"type are B<MS_REC> (described below) and B<MS_SILENT> (which is ignored)."
msgstr "При смене типа распространения можно изменять только флаги B<MS_REC> (описан ниже) и B<MS_SILENT> (игнорируется)."

#. type: Plain text
#: man-pages/man2/mount.2:503
msgid "The I<source>, I<filesystemtype>, and I<data> arguments are ignored."
msgstr "Аргументы I<source>, I<filesystemtype> и I<data> игнорируются."

#. type: Plain text
#: man-pages/man2/mount.2:505
msgid "The meanings of the propagation type flags are as follows:"
msgstr "Назначение флагов типа распространения следующее:"

#. type: Plain text
#: man-pages/man2/mount.2:514
msgid ""
"Make this mount point shared.  Mount and unmount events immediately under "
"this mount point will propagate to the other mount points that are members "
"of this mount's peer group.  Propagation here means that the same mount or "
"unmount will automatically occur under all of the other mount points in the "
"peer group.  Conversely, mount and unmount events that take place under peer"
" mount points will propagate to this mount point."
msgstr "Делает эту точку монтирования общей. События монтирования и размонтирования этой точки сразу же распространяются на другие точки монтирования, являющиеся членами её равноправной группы. Распространение здесь означает, что монтирование или размонтирование автоматически происходит и у всех остальных точек монтирования в равноправной группе. И наоборот, события монтирования и размонтирования, возникшие у точек монтирования равноправной группы, будут распространены и на эту точку монтирования."

#. type: Plain text
#: man-pages/man2/mount.2:518
msgid ""
"Make this mount point private.  Mount and unmount events do not propagate "
"into or out of this mount point."
msgstr "События монтирования и размонтирования не распространяются в эту точку и от этой точки."

#. type: Plain text
#: man-pages/man2/mount.2:525
msgid ""
"If this is a shared mount point that is a member of a peer group that "
"contains other members, convert it to a slave mount.  If this is a shared "
"mount point that is a member of a peer group that contains no other members,"
" convert it to a private mount.  Otherwise, the propagation type of the "
"mount point is left unchanged."
msgstr "Если это общая точка монтирования, которая является членом непустой равноправной группы, то она преобразуется в подчинённую точку монтирования. Если это общая точка монтирования, которая является членом пустой равноправной группы, то она преобразуется в индивидуальную точку. В противном случае тип распространения точки монтирования не изменяется."

#. type: Plain text
#: man-pages/man2/mount.2:530
msgid ""
"When a mount point is a slave, mount and unmount events propagate into this "
"mount point from the (master) shared peer group of which it was formerly a "
"member.  Mount and unmount events under this mount point do not propagate to"
" any peer."
msgstr "Если точка монтирования подчинённая, то события монтирования и размонтирования распространяются на эту точку монтирования из (главной) общей равноправной группы, в которую она раньше входила. События монтирования и размонтирования этой точки не распространяются на членов группы."

#. type: Plain text
#: man-pages/man2/mount.2:534
msgid ""
"A mount point can be the slave of another peer group while at the same time "
"sharing mount and unmount events with a peer group of which it is a member."
msgstr "Точка монтирования может быть подчинённой одной равноправной группе и в тоже время может распространять события в другую группу, где она является членом."

#. type: Plain text
#: man-pages/man2/mount.2:549
msgid ""
"Make this mount unbindable.  This is like a private mount, and in addition "
"this mount can't be bind mounted.  When a recursive bind mount (B<mount>()  "
"with the B<MS_BIND> and B<MS_REC> flags) is performed on a directory "
"subtree, any unbindable mounts within the subtree are automatically pruned "
"(i.e., not replicated)  when replicating that subtree to produce the target "
"subtree."
msgstr "Делает эту точку монтирования непривязываемой. Она подобна индивидуальной точке монтирования плюс недоступна привязка монтирования. При рекурсивной привязке (B<mount>() с флагами B<MS_BIND> и B<MS_REC>) в поддереве каталога все непривязываемые монтирования внутри поддерева автоматически удаляются (т. е., не копируются) при копировании этого поддерева для создания целевого поддерева."

#. type: Plain text
#: man-pages/man2/mount.2:560
msgid ""
"By default, changing the propagation type affects only the I<target> mount "
"point.  If the B<MS_REC> flag is also specified in I<mountflags>, then the "
"propagation type of all mount points under I<target> is also changed."
msgstr "По умолчанию, изменение типа распространения касается только I<target> точки монтирования. Если в I<mountflags> также указан флаг B<MS_REC>, то тип распространения всех точек монтирования ниже I<target> также изменяется."

#. type: Plain text
#: man-pages/man2/mount.2:565
msgid ""
"For further details regarding mount propagation types (including the default"
" propagation type assigned to new mounts), see B<mount_namespaces>(7)."
msgstr "Дополнительную информацию по типам распространения монтирования (включая тип распространения по умолчанию, назначаемый новым точкам монтирования) смотрите в B<mount_namespaces>(7)."

#. type: SS
#: man-pages/man2/mount.2:565
#, no-wrap
msgid "Moving a mount"
msgstr "Перемещение точки монтирования"

#. type: Plain text
#: man-pages/man2/mount.2:577
msgid ""
"If I<mountflags> contains the flag B<MS_MOVE> (available since Linux "
"2.4.18), then move a subtree: I<source> specifies an existing mount point "
"and I<target> specifies the new location to which that mount point is to be "
"relocated.  The move is atomic: at no point is the subtree unmounted."
msgstr "Если в I<mountflags> содержится флаг B<MS_MOVE> (доступен, начиная с Linux 2.4.18), то перемещается поддерево: в I<source> задаётся существующая точка монтирования, а I<target> указывается новое расположение, в которое будет перемещена точка монтирования. Перемещение атомарно: поддерево всегда смонтировано."

#. type: Plain text
#: man-pages/man2/mount.2:586
msgid ""
"The remaining bits in the I<mountflags> argument are ignored, as are the "
"I<filesystemtype> and I<data> arguments."
msgstr "Оставшиеся биты в аргументе I<mountflags> игнорируются, как и аргументы I<filesystemtype> и I<data>."

#. type: SS
#: man-pages/man2/mount.2:586
#, no-wrap
msgid "Creating a new mount point"
msgstr "Создание новой точки монтирования"

#. type: Plain text
#: man-pages/man2/mount.2:605
msgid ""
"If none of B<MS_REMOUNT>, B<MS_BIND>, B<MS_MOVE>, B<MS_SHARED>, "
"B<MS_PRIVATE>, B<MS_SLAVE>, or B<MS_UNBINDABLE> is specified in "
"I<mountflags>, then B<mount>()  performs its default action: creating a new "
"mount point.  I<source> specifies the source for the new mount point, and "
"I<target> specifies the directory at which to create the mount point."
msgstr "В том случае, если ни одно из значений B<MS_REMOUNT>, B<MS_BIND>, B<MS_MOVE>, B<MS_SHARED>, B<MS_PRIVATE>, B<MS_SLAVE>, или B<MS_UNBINDABLE> не указано в I<mountflags>, вызов B<mount>() выполняет действие по умолчанию: создаёт новую точку монтирования. В I<source> задаётся источник новой точки монтирования,  а значение I<target> указывает каталог, в котором будет создана точка монтирования."

#. type: Plain text
#: man-pages/man2/mount.2:614
msgid ""
"The I<filesystemtype> and I<data> arguments are employed, and further bits "
"may be specified in I<mountflags> to modify the behavior of the call."
msgstr "Используются аргументы I<filesystemtype> и I<data>, дополнительные параметры для изменения поведения могут быть указаны в I<mountflags>."

#. type: Plain text
#: man-pages/man2/mount.2:619
msgid ""
"On success, zero is returned.  On error, -1 is returned, and I<errno> is set"
" appropriately."
msgstr "При успешном выполнении возвращается 0. В случае ошибки возвращается -1, а I<errno> устанавливается в соответствующее значение."

#. type: Plain text
#: man-pages/man2/mount.2:625
msgid ""
"The error values given below result from filesystem type independent errors."
"  Each filesystem type may have its own special errors and its own special "
"behavior.  See the Linux kernel source code for details."
msgstr "Коды ошибок, описанные ниже, не зависят от типа файловой системы. У каждой файловой системы могут быть свои коды ошибок и своё собственное поведение. Подробности смотрите в исходном коде ядра Linux."

#. type: Plain text
#: man-pages/man2/mount.2:630
msgid ""
"A component of a path was not searchable.  (See also B<path_resolution>(7).)"
msgstr "Поиск запрещён из-за одной части пути, которая не доступна для просмотра и поиск (см. подробнее в B<path_resolution>(7))."

#. type: Plain text
#: man-pages/man2/mount.2:635
msgid ""
"Mounting a read-only filesystem was attempted without giving the "
"B<MS_RDONLY> flag."
msgstr "Было предпринята попытка монтирования файловой системы доступной только на чтение, но без флага B<ms_rdonly>."

#. type: Plain text
#: man-pages/man2/mount.2:644
msgid ""
"The file system may be read-only for various reasons, including: it resides "
"on a read-only optical disk; it is resides on a device with a physical "
"switch that has been set to mark the device read-only; the filesystem "
"implementation was compiled with read-only support; or errors were detected "
"when initially mounting the filesystem, so that it was marked read-only and "
"can't be remounted as read-write (until the errors are fixed)."
msgstr "Файловая система может быть доступна только для чтения по разным причинам: она расположена на оптическом диске, доступном только для чтения; она располагается на устройстве с физической коммутацией, которое было отмечено как доступное только для чтения; реализация файловой системы скомпилирована с поддержкой только на чтение; обнаружены ошибки при первоначальном монтировании файловой системы, из-за чего она была помечена как доступная только для чтения и её невозможно перемонтировать как доступную для чтения/записи (пока не будут исправлены ошибки)."

#. type: Plain text
#: man-pages/man2/mount.2:648
msgid ""
"Some filesystems instead return the error B<EROFS> on an attempt to mount a "
"read-only filesystem."
msgstr "При попытке монтирования файловой системы только для чтениянекоторые файловые системы вместо этого возвращают ошибку B<EROFS>."

#.  mtk: Probably: write permission is required for MS_BIND, with
#.  the error EPERM if not present; CAP_DAC_OVERRIDE is required.
#. type: Plain text
#: man-pages/man2/mount.2:657
msgid ""
"The block device I<source> is located on a filesystem mounted with the "
"B<MS_NODEV> option."
msgstr "Блочное устройство  I<source> расположено в файловой системе, которая смонтирована с параметром B<MS_NODEV>."

#. type: TP
#: man-pages/man2/mount.2:657 man-pages/man2/mount.2:665
#, no-wrap
msgid "B<EBUSY>"
msgstr "B<EBUSY>"

#. type: Plain text
#: man-pages/man2/mount.2:665
msgid ""
"An attempt was made to stack a new mount directly on top of an existing "
"mount point that was created in this mount namespace with the same I<source>"
" and I<target>."
msgstr "Попытка выполнить новое монтирование непосредственно поверх существующей точки монтирования, которая была создана в этом пространстве имён монтирования с тем же I<источником> и I<назначением>."

#. type: Plain text
#: man-pages/man2/mount.2:670
msgid ""
"I<source> cannot be remounted read-only, because it still holds files open "
"for writing."
msgstr "I<source> не может быть перемонтирован с доступом только на чтение, потому что он все ещё содержит файлы, открытые для записи."

#. type: Plain text
#: man-pages/man2/mount.2:673
msgid "One of the pointer arguments points outside the user address space."
msgstr "Один из аргументов-указателей указывает на каталог за пределами пользовательского адресного пространства."

#. type: Plain text
#: man-pages/man2/mount.2:677
msgid "I<source> had an invalid superblock."
msgstr "I<источник> имеет недоступный суперблок."

#. type: Plain text
#: man-pages/man2/mount.2:685
msgid ""
"A remount operation (B<MS_REMOUNT>)  was attempted, but I<source> was not "
"already mounted on I<target>."
msgstr "Была предпринята попытка перемонтирования (B<MS_REMOUNT>), но I<source> еще не был смонтирован в I<target>."

#. type: Plain text
#: man-pages/man2/mount.2:695
msgid ""
"A move operation (B<MS_MOVE>)  was attempted, but the mount tree under "
"I<source> includes unbindable mounts and I<target> is a mount point that has"
" propagation type B<MS_SHARED>."
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:703
msgid ""
"A move operation (B<MS_MOVE>)  was attempted, but the parent mount of "
"I<source> mount has propagation type B<MS_SHARED>."
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:710
msgid ""
"A move operation (B<MS_MOVE>)  was attempted, but I<source> was not a mount "
"point, or was \\(aq/\\(aq."
msgstr "Была предпринята попытка перемещения (B<MS_MOVE>), но  I<source> не являлся точкой монтирования или был \\(aq/\\(aq."

#. type: Plain text
#: man-pages/man2/mount.2:719
msgid ""
"I<mountflags> includes more than one of B<MS_SHARED>, B<MS_PRIVATE>, "
"B<MS_SLAVE>, or B<MS_UNBINDABLE>."
msgstr "I<mountflags> включает более одного значения из B<MS_SHARED>, B<MS_PRIVATE>, B<MS_SLAVE>, или B<MS_UNBINDABLE>."

#. type: Plain text
#: man-pages/man2/mount.2:732
msgid ""
"I<mountflags> includes B<MS_SHARED>, B<MS_PRIVATE>, B<MS_SLAVE>, or "
"B<MS_UNBINDABLE> and also includes a flag other than B<MS_REC> or "
"B<MS_SILENT>."
msgstr "I<mountflags> включает B<MS_SHARED>, B<MS_PRIVATE>, B<MS_SLAVE>, или B<MS_UNBINDABLE> а также включает флаг, отличный от B<MS_REC> или B<MS_SILENT>."

#. type: Plain text
#: man-pages/man2/mount.2:735
msgid "An attempt was made to bind mount an unbindable mount."
msgstr "Была попытка выполнить связанное монтирование, как несвязанное монтирование."

#. type: Plain text
#: man-pages/man2/mount.2:746
msgid ""
"In an unprivileged mount namespace (i.e., a mount namespace owned by a user "
"namespace that was created by an unprivileged user), a bind mount operation "
"(B<MS_BIND>)  was attempted without specifying (B<MS_REC>), which would have"
" revealed the filesystem tree underneath one of the submounts of the "
"directory being bound."
msgstr "В непривилегированном пространстве имён монтирования (т. е., пространстве имён монтирования, принадлежащем пространству имён пользователя, которое было создано непривилегированным пользователем) выполнялась операция связанного монтирования (B<MS_BIND>) без указания (B<MS_REC>), которая привела бы к открытию дерева файловой системы, находящемся ниже одного из подмонтирований каталога, к которому выполнялось связывание."

#. type: Plain text
#: man-pages/man2/mount.2:749
msgid "Too many links encountered during pathname resolution."
msgstr "Во время разбора имён найдено слишком много ссылок. "

#. type: Plain text
#: man-pages/man2/mount.2:755
msgid ""
"A move operation was attempted, and I<target> is a descendant of I<source>."
msgstr "Сделана попытка перемещения, но I<цель> оказалась подкаталогом I<источника>."

#. type: Plain text
#: man-pages/man2/mount.2:759
msgid ""
"(In case no block device is required:)  Table of dummy devices is full."
msgstr "(В случае, если не требуются блочные устройства): таблица фиктивных устройств переполнена."

#. type: Plain text
#: man-pages/man2/mount.2:763
msgid "A pathname was longer than B<MAXPATHLEN>."
msgstr "Значение пути длиннее чем B<MAXPATHLEN>."

#. type: Plain text
#: man-pages/man2/mount.2:767
msgid "I<filesystemtype> not configured in the kernel."
msgstr "Тип из I<filesystemtype> в ядре не настроен."

#. type: Plain text
#: man-pages/man2/mount.2:770
msgid "A pathname was empty or had a nonexistent component."
msgstr "Указан пустой путь или одна из его частей не существует."

#. type: Plain text
#: man-pages/man2/mount.2:773
msgid ""
"The kernel could not allocate a free page to copy filenames or data into."
msgstr "Ядро не может выделить свободную страницу для копирования имени файла или данных."

#. type: TP
#: man-pages/man2/mount.2:773
#, no-wrap
msgid "B<ENOTBLK>"
msgstr "B<ENOTBLK>"

#. type: Plain text
#: man-pages/man2/mount.2:777
msgid "I<source> is not a block device (and a device was required)."
msgstr "Значение I<source> не является блочным устройством (а устройство было запрошено)."

#. type: Plain text
#: man-pages/man2/mount.2:783
msgid "I<target>, or a prefix of I<source>, is not a directory."
msgstr "Значение I<target> или префикс I<source> не является каталогом."

#. type: TP
#: man-pages/man2/mount.2:783
#, no-wrap
msgid "B<ENXIO>"
msgstr "B<ENXIO>"

#. type: Plain text
#: man-pages/man2/mount.2:788
msgid "The major number of the block device I<source> is out of range."
msgstr "Старший номер блочного устройства I<source> вне допустимого диапазона."

#. type: Plain text
#: man-pages/man2/mount.2:791
msgid "The caller does not have the required privileges."
msgstr "Вызывающий процесс не имеет требуемых привилегий."

#. type: Plain text
#: man-pages/man2/mount.2:799
msgid ""
"Mounting a read-only filesystem was attempted without giving the "
"B<MS_RDONLY> flag.  See B<EACCES>, above."
msgstr "Было предпринята попытка монтирования файловой системы доступной только на чтение без флага B<MS_RDONLY>. Смотрите описание B<EACCES>, приведённое выше."

#. type: Plain text
#: man-pages/man2/mount.2:813
msgid ""
"The definitions of B<MS_DIRSYNC>, B<MS_MOVE>, B<MS_PRIVATE>, B<MS_REC>, "
"B<MS_RELATIME>, B<MS_SHARED>, B<MS_SLAVE>, B<MS_STRICTATIME>, and "
"B<MS_UNBINDABLE> were added to glibc headers in version 2.12."
msgstr "Определения B<MS_DIRSYNC>, B<MS_MOVE>, B<MS_PRIVATE>, B<MS_REC>, B<MS_RELATIME>, B<MS_SHARED>, B<MS_SLAVE>, B<MS_STRICTATIME> и B<MS_UNBINDABLE> были добавлены в заголовочные файлы glibc начиная с версии 2.12."

#. type: Plain text
#: man-pages/man2/mount.2:816
msgid ""
"This function is Linux-specific and should not be used in programs intended "
"to be portable."
msgstr "Данная функция есть только в Linux и не должна использоваться в программах, которые задуманы как переносимые."

#.  Multiple mounts on same mount point: since 2.3.99pre7.
#. type: Plain text
#: man-pages/man2/mount.2:821
msgid ""
"Since Linux 2.4 a single filesystem can be mounted at multiple mount points,"
" and multiple mounts can be stacked on the same mount point."
msgstr "Начиная с Linux 2.4 одна файловая система может быть смонтирована в множество точек монтирования, также множественное монтирование может осуществляться в одну точку."

#. type: Plain text
#: man-pages/man2/mount.2:833
msgid ""
"The I<mountflags> argument may have the magic number 0xC0ED (B<MS_MGC_VAL>)"
"  in the top 16 bits.  (All of the other flags discussed in DESCRIPTION "
"occupy the low order 16 bits of I<mountflags>.)  Specifying B<MS_MGC_VAL> "
"was required in kernel versions prior to 2.4, but since Linux 2.4 is no "
"longer required and is ignored if specified."
msgstr "В верхних 16 битах аргумента I<mountflags> может содержаться магическое число 0xC0ED (B<MS_MGC_VAL>) (все остальные флаги из ОПИСАНИЯ находятся в младших 16 битах I<mountflags>). Указание B<MS_MGC_VAL> было требованием ядра до версии 2.4, но начиная с Linux 2.4 этого больше не нужно, и число игнорируется, если указано."

#. type: Plain text
#: man-pages/man2/mount.2:842
msgid ""
"The original B<MS_SYNC> flag was renamed B<MS_SYNCHRONOUS> in 1.1.69 when a "
"different B<MS_SYNC> was added to I<E<lt>mman.hE<gt>>."
msgstr "Изначальный флаг B<MS_SYNC> был переименован в B<MS_SYNCHRONOUS> в 1.1.69, когда в I<E<lt>mman.hE<gt>> был добавлен другой флаг B<MS_SYNC>."

#.  The change is in patch-2.4.0-prerelease.
#. type: Plain text
#: man-pages/man2/mount.2:852
msgid ""
"Before Linux 2.4 an attempt to execute a set-user-ID or set-group-ID program"
" on a filesystem mounted with B<MS_NOSUID> would fail with B<EPERM>.  Since "
"Linux 2.4 the set-user-ID and set-group-ID bits are just silently ignored in"
" this case."
msgstr "До Linux 2.4 попытка выполнения программ set-UID или set-GID на файловой системе, подключённой с параметром B<MS_NOSUID>, вызывает ошибку B<EPERM>. Начиная с Linux 2.4 биты set-UID и set-GID в этом случае негласно игнорируются."

#. type: SS
#: man-pages/man2/mount.2:852
#, no-wrap
msgid "Per-process namespaces"
msgstr "Попроцессные пространства имён"

#. type: Plain text
#: man-pages/man2/mount.2:863
msgid ""
"Starting with kernel 2.4.19, Linux provides per-process mount namespaces.  A"
" mount namespace is the set of filesystem mounts that are visible to a "
"process.  Mount-point namespaces can be (and usually are)  shared between "
"multiple processes, and changes to the namespace (i.e., mounts and unmounts)"
" by one process are visible to all other processes sharing the same "
"namespace.  (The pre-2.4.19 Linux situation can be considered as one in "
"which a single namespace was shared by every process on the system.)"
msgstr "Начиная с ядра версии 2.4.19, Linux предоставляет попроцессные пространства имён монтирования. Пространство имён монтирования — это набор смонтированных файловых систем, которые видимы процессу. Пространства имён точек монтирования могут (обычно так и есть) совместно использоваться несколькими процессами, и изменение пространства имён (т.е., монтирование и размонтирование) одним процессом видимы всеми остальными процессами, использующими одно общее пространство имён. (Поведение до версии 2.4.19 в Linux можно рассматривать так, как если бы всеми процессами в системе использовалось одно пространство имён.)"

#. type: Plain text
#: man-pages/man2/mount.2:869
msgid ""
"A child process created by B<fork>(2)  shares its parent's mount namespace; "
"the mount namespace is preserved across an B<execve>(2)."
msgstr "Процесс-потомок, создаваемый B<fork>(2), использует родительское пространство имён монтирования совместно с родителем; пространство имён монтирования сохраняется при вызове B<execve>(2)."

#. type: Plain text
#: man-pages/man2/mount.2:889
msgid ""
"A process can obtain a private mount namespace if: it was created using the "
"B<clone>(2)  B<CLONE_NEWNS> flag, in which case its new namespace is "
"initialized to be a I<copy> of the namespace of the process that called "
"B<clone>(2); or it calls B<unshare>(2)  with the B<CLONE_NEWNS> flag, which "
"causes the caller's mount namespace to obtain a private copy of the "
"namespace that it was previously sharing with other processes, so that "
"future mounts and unmounts by the caller are invisible to other processes "
"(except child processes that the caller subsequently creates) and vice "
"versa."
msgstr "Процесс может получить собственное пространство имён монтирования если: он был создан с помощью B<clone>(2) с флагом B<CLONE_NEWNS>; в этом случае его новое пространство имён инициализируется I<копией> пространства имён процесса, который вызвал B<clone>(2); или он вызовет B<unshare>(2) с флагом B<CLONE_NEWNS>; в этом случае пространство имён вызвавшего получит свою копию пространства имён, которое он раньше совместно использовал с другими процессами, и дальнейшие монтирования и размонтирования вызвавшим будут невидимы другим процессам (за исключением потомков, которые вызывающий создаст позже) и наоборот."

#. type: Plain text
#: man-pages/man2/mount.2:904
msgid ""
"The Linux-specific I</proc/[pid]/mounts> file exposes the list of mount "
"points in the mount namespace of the process with the specified ID.  The "
"I</proc/[pid]/mountinfo> file exposes even more information about mount "
"points, including the propagation type and mount ID information that makes "
"it possible to discover the parental relationship between mount points.  See"
" B<proc>(5)  and B<mount_namespaces>(7)  for details of these files."
msgstr "В файле I</proc/[pid]/mounts> (имеется только в Linux) отображается список точек монтирования в пространстве имён монтирования процесса с соответствующем ID. В файле I</proc/[pid]/mountinfo> отображается дополнительная информация о точках монтирования, включая тип распространения и информационный идентификатор монтирования, который позволяет обнаруживать связи между точками монтирования. Описание этих файлов смотрите в B<proc>(5) и B<mount_namespaces>(7)."

#. type: Plain text
#: man-pages/man2/mount.2:915
msgid ""
"B<mountpoint>(1), B<chroot>(2), B<ioctl_iflags>(2), B<pivot_root>(2), "
"B<umount>(2), B<mount_namespaces>(7), B<path_resolution>(7), B<findmnt>(8), "
"B<lsblk>(8), B<mount>(8), B<umount>(8)"
msgstr ""

#. type: TH
#: man-pages/man2/msgop.2:39
#, no-wrap
msgid "MSGOP"
msgstr "MSGOP"

#. type: Plain text
#: man-pages/man2/msgop.2:42
msgid "msgrcv, msgsnd - System V message queue operations"
msgstr "msgrcv, msgsnd - операции с очередью сообщений System V"

#. type: Plain text
#: man-pages/man2/msgop.2:50
#, no-wrap
msgid ""
"B<int msgsnd(int >I<msqid>B<, const void *>I<msgp>B<, size_t >I<msgsz>B<, "
"int >I<msgflg>B<);>\n"
msgstr "B<int msgsnd(int >I<msqid>B<, const void *>I<msgp>B<, size_t >I<msgsz>B<, int >I<msgflg>B<);>\n"

#. type: Plain text
#: man-pages/man2/msgop.2:54
#, no-wrap
msgid ""
"B<ssize_t msgrcv(int >I<msqid>B<, void *>I<msgp>B<, size_t >I<msgsz>B<, long >I<msgtyp>B<,>\n"
"B<               int >I<msgflg>B<);>\n"
msgstr "B<ssize_t msgrcv(int >I<msqid>B<, void *>I<msgp>B<, size_t >I<msgsz>B<, long >I<msgtyp>B<,>\nB<               int >I<msgflg>B<);>\n"

#. type: Plain text
#: man-pages/man2/msgop.2:64
msgid ""
"The B<msgsnd>()  and B<msgrcv>()  system calls are used to send messages to,"
" and receive messages from, a System\\ V message queue.  The calling process"
" must have write permission on the message queue in order to send a message,"
" and read permission to receive a message."
msgstr "Системные вызовы B<msgsnd>() и B<msgrcv>() используются для отправки и получения сообщений из очереди сообщений System\\ V. Вызывающий процесс должен иметь права на запись в очередь сообщений, чтобы отправлять сообщения и права на чтение для получения сообщений."

#. type: Plain text
#: man-pages/man2/msgop.2:69
msgid ""
"The I<msgp> argument is a pointer to a caller-defined structure of the "
"following general form:"
msgstr "Аргумент I<msgp> представляет собой указатель на структуру, определяемую вызывающим как:"

#. type: Plain text
#: man-pages/man2/msgop.2:76
#, no-wrap
msgid ""
"struct msgbuf {\n"
"    long mtype;       /* message type, must be E<gt> 0 */\n"
"    char mtext[1];    /* message data */\n"
"};\n"
msgstr "struct msgbuf {\n    long mtype;       /* тип сообщения, значение должно быть E<gt> 0 */\n    char mtext[1];    /* данные сообщения */\n};\n"

#. type: Plain text
#: man-pages/man2/msgop.2:95
msgid ""
"The I<mtext> field is an array (or other structure) whose size is specified "
"by I<msgsz>, a nonnegative integer value.  Messages of zero length (i.e., no"
" I<mtext> field) are permitted.  The I<mtype> field must have a strictly "
"positive integer value.  This value can be used by the receiving process for"
" message selection (see the description of B<msgrcv>()  below)."
msgstr "Поле I<mtext> является массивом (или другой структурой), размер которого определяется I<msgsz> — неотрицательным целым значением. Разрешены сообщения нулевой длины (т.е. без поля I<mtext>). Поле I<mtype> должно быть только положительным целым значением. Это значение используется процессом-получателем для выбора сообщения (см. описание B<msgrcv>() далее)."

#. type: SS
#: man-pages/man2/msgop.2:95
#, no-wrap
msgid "msgsnd()"
msgstr "msgsnd()"

#. type: Plain text
#: man-pages/man2/msgop.2:103
msgid ""
"The B<msgsnd>()  system call appends a copy of the message pointed to by "
"I<msgp> to the message queue whose identifier is specified by I<msqid>."
msgstr "Системный вызов B<msgsnd>() добавляет копию сообщения, указанного I<msgp>, в очередь сообщений, идентификатор которой задаётся в I<msqid>."

#. type: Plain text
#: man-pages/man2/msgop.2:116
msgid ""
"If sufficient space is available in the queue, B<msgsnd>()  succeeds "
"immediately.  The queue capacity is governed by the I<msg_qbytes> field in "
"the associated data structure for the message queue.  During queue creation "
"this field is initialized to B<MSGMNB> bytes, but this limit can be modified"
" using B<msgctl>(2).  A message queue is considered to be full if either of "
"the following conditions is true:"
msgstr "Если в очереди достаточно места, то B<msgsnd>() сразу успешно завершается. Размер очереди управляется полем I<msg_qbytes> в связанной структуре данных очереди сообщений. При создании очереди это поле инициализируется значением B<MSGMNB> байт, но данное ограничение можно изменить с помощью B<msgctl>(2). Очередь сообщений считается заполненной при одном из следующих условий:"

#. type: Plain text
#: man-pages/man2/msgop.2:121
msgid ""
"Adding a new message to the queue would cause the total number of bytes in "
"the queue to exceed the queue's maximum size (the I<msg_qbytes> field)."
msgstr "Добавление нового сообщения привело бы к превышению общего количества байт очереди над максимальным количеством размером очереди (поле I<msg_qbytes>)."

#. type: Plain text
#: man-pages/man2/msgop.2:130
msgid ""
"Adding another message to the queue would cause the total number of messages"
" in the queue to exceed the queue's maximum size (the I<msg_qbytes> field)."
"  This check is necessary to prevent an unlimited number of zero-length "
"messages being placed on the queue.  Although such messages contain no data,"
" they nevertheless consume (locked) kernel memory."
msgstr "Добавление другого сообщения привело бы к превышению общего количества сообщений очереди над максимальным количеством размером очереди (поле I<msg_qbytes>). Эта проверка необходима для предотвращения помещения в очередь бесконечного количества сообщений нулевой длины. Хотя такие сообщения не содержат данных, тем не менее, они потребляют (блокируют) память ядра."

#. type: Plain text
#: man-pages/man2/msgop.2:141
msgid ""
"If insufficient space is available in the queue, then the default behavior "
"of B<msgsnd>()  is to block until space becomes available.  If B<IPC_NOWAIT>"
" is specified in I<msgflg>, then the call instead fails with the error "
"B<EAGAIN>."
msgstr "Если в очереди недостаточно места, то по умолчанию B<msgsnd>() блокирует выполнение до появления свободного места. Если в I<msgflg> указан B<IPC_NOWAIT>, то вызов вместо этого завершается с ошибкой B<EAGAIN>."

#. type: Plain text
#: man-pages/man2/msgop.2:145
msgid "A blocked B<msgsnd>()  call may also fail if:"
msgstr "Заблокированный вызов B<msgsnd>() может завершиться ошибкой если:"

#. type: Plain text
#: man-pages/man2/msgop.2:152
msgid ""
"the queue is removed, in which case the system call fails with I<errno> set "
"to B<EIDRM>; or"
msgstr "очередь удалена (в этом случае системный вызов выдаст ошибку, определив I<errno> в значение B<EIDRM>;"

#. type: Plain text
#: man-pages/man2/msgop.2:164
msgid ""
"a signal is caught, in which case the system call fails with I<errno> set to"
" B<EINTR>;B<see> B<signal>(7).  (B<msgsnd>()  is never automatically "
"restarted after being interrupted by a signal handler, regardless of the "
"setting of the B<SA_RESTART> flag when establishing a signal handler.)"
msgstr "пойман сигнал; в этом случае системный вызов завершается с ошибкой и присваивает I<errno> значение B<EINTR>; B<см.> B<signal>(7). Вызов B<msgsnd>() никогда не перезапускается автоматически после прерывания обработчиком сигнала, независимо от установки флага B<SA_RESTART> при настройке обработчика сигнала."

#. type: Plain text
#: man-pages/man2/msgop.2:167 man-pages/man2/msgop.2:328
msgid ""
"Upon successful completion the message queue data structure is updated as "
"follows:"
msgstr "Перед успешным завершением структура данных очереди сообщений будет обновлена следующим образом:"

#. type: Plain text
#: man-pages/man2/msgop.2:170
msgid "I<msg_lspid> is set to the process ID of the calling process."
msgstr "Значение I<msg_lspid> устанавливается равным идентификатору вызывающего процесса."

#. type: Plain text
#: man-pages/man2/msgop.2:173
msgid "I<msg_qnum> is incremented by 1."
msgstr "Значение I<msg_qnum> увеличивается на 1."

#. type: Plain text
#: man-pages/man2/msgop.2:176
msgid "I<msg_stime> is set to the current time."
msgstr "Значение I<msg_stime> присваивается значение текущего времени."

#. type: SS
#: man-pages/man2/msgop.2:176
#, no-wrap
msgid "msgrcv()"
msgstr "msgrcv()"

#. type: Plain text
#: man-pages/man2/msgop.2:184
msgid ""
"The B<msgrcv>()  system call removes a message from the queue specified by "
"I<msqid> and places it in the buffer pointed to by I<msgp>."
msgstr "Системный вызов B<msgrcv>() удаляет сообщение из очереди, указанной в I<msqid> и помещает его в буфер, указанный в I<msgp>."

#. type: Plain text
#: man-pages/man2/msgop.2:210
msgid ""
"The argument I<msgsz> specifies the maximum size in bytes for the member "
"I<mtext> of the structure pointed to by the I<msgp> argument.  If the "
"message text has length greater than I<msgsz>, then the behavior depends on "
"whether B<MSG_NOERROR> is specified in I<msgflg>.  If B<MSG_NOERROR> is "
"specified, then the message text will be truncated (and the truncated part "
"will be lost); if B<MSG_NOERROR> is not specified, then the message isn't "
"removed from the queue and the system call fails returning -1 with I<errno> "
"set to B<E2BIG>."
msgstr "Параметр I<msgsz> задаёт максимальный размер (в байтах) элемента I<mtext> структуры, находящейся по адресу, указанному в аргументе I<msgp>. Если длина текста сообщения больше чем I<msgsz>, то поведение зависит от наличия флага B<MSG_NOERROR> в I<msgflg>. Если B<MSG_NOERROR> указан, то текст сообщения будет урезан (а урезанная часть потеряна); иначе сообщение не удаляется из очереди, а системный вызов возвращает -1 и присваивает I<errno> значение B<E2BIG>."

#. type: Plain text
#: man-pages/man2/msgop.2:219
msgid ""
"Unless B<MSG_COPY> is specified in I<msgflg> (see below), the I<msgtyp> "
"argument specifies the type of message requested, as follows:"
msgstr "Если в I<msgflg> (смотрите ниже ) не указан B<MSG_COPY>, то в аргументе I<msgtyp> указывается тип запрашиваемого сообщения:"

#. type: Plain text
#: man-pages/man2/msgop.2:224
msgid "If I<msgtyp> is 0, then the first message in the queue is read."
msgstr "Если I<msgtyp> равно нулю, то читается первое сообщение в очереди."

#. type: Plain text
#: man-pages/man2/msgop.2:238
msgid ""
"If I<msgtyp> is greater than 0, then the first message in the queue of type "
"I<msgtyp> is read, unless B<MSG_EXCEPT> was specified in I<msgflg>, in which"
" case the first message in the queue of type not equal to I<msgtyp> will be "
"read."
msgstr "Если I<msgtyp> больше нуля, то из очереди читается первое сообщение с типом I<msgtyp> (если только в I<msgflg> не указан B<MSG_EXCEPT>. В этом случае из очереди читается первое сообщение, тип которого не равен I<msgtyp>)."

#. type: Plain text
#: man-pages/man2/msgop.2:246
msgid ""
"If I<msgtyp> is less than 0, then the first message in the queue with the "
"lowest type less than or equal to the absolute value of I<msgtyp> will be "
"read."
msgstr "Если I<msgtyp> меньше нуля, то из очереди читается первое сообщение со значением, меньшим или равным абсолютному значению I<msgtyp>."

#. type: Plain text
#: man-pages/man2/msgop.2:251
msgid ""
"The I<msgflg> argument is a bit mask constructed by ORing together zero or "
"more of the following flags:"
msgstr "Аргумент I<msgflg> представляет собой битовую маску из комбинации нуля или более следующих флагов:"

#. type: TP
#: man-pages/man2/msgop.2:251
#, no-wrap
msgid "B<IPC_NOWAIT>"
msgstr "B<IPC_NOWAIT>"

#. type: Plain text
#: man-pages/man2/msgop.2:258
msgid ""
"Return immediately if no message of the requested type is in the queue.  The"
" system call fails with I<errno> set to B<ENOMSG>."
msgstr "Немедленный возврат, если в очереди нет сообщений необходимого типа. При этом системный вызов возвращает ошибку, присваивая I<errno> значение B<ENOMSG>."

#. type: TP
#: man-pages/man2/msgop.2:258
#, no-wrap
msgid "B<MSG_COPY> (since Linux 3.8)"
msgstr "B<MSG_COPY> (начиная с Linux 3.8)"

#.  commit 4a674f34ba04a002244edaf891b5da7fc1473ae8
#. type: Plain text
#: man-pages/man2/msgop.2:265
msgid ""
"Nondestructively fetch a copy of the message at the ordinal position in the "
"queue specified by I<msgtyp> (messages are considered to be numbered "
"starting at 0)."
msgstr "Забирает копию сообщения без удаления из начальной позиции в очереди, заданной в I<msgtyp> (сообщения нумеруются начиная с 0)."

#. type: Plain text
#: man-pages/man2/msgop.2:279
msgid ""
"This flag must be specified in conjunction with B<IPC_NOWAIT>, with the "
"result that, if there is no message available at the given position, the "
"call fails immediately with the error B<ENOMSG>.  Because they alter the "
"meaning of I<msgtyp> in orthogonal ways, B<MSG_COPY> and B<MSG_EXCEPT> may "
"not both be specified in I<msgflg>."
msgstr "Этот флаг должен указываться вместе с B<IPC_NOWAIT>; в этом случае, если в заданной позиции сообщение отсутствует, то вызов завершается с ошибкой B<ENOMSG> немедленно. Флаги B<MSG_COPY> и B<MSG_EXCEPT> не могут указываться вместе в I<msgflg>, так как кардинально изменяют смысл I<msgtyp>."

#. type: Plain text
#: man-pages/man2/msgop.2:287
msgid ""
"The B<MSG_COPY> flag was added for the implementation of the kernel "
"checkpoint-restore facility and is available only if the kernel was built "
"with the B<CONFIG_CHECKPOINT_RESTORE> option."
msgstr "Флаг B<MSG_COPY> был добавлен для реализации способности ядра для контрольных точек/восстановления и доступен только, если ядро собрано с параметром B<CONFIG_CHECKPOINT_RESTORE>."

#. type: TP
#: man-pages/man2/msgop.2:287
#, no-wrap
msgid "B<MSG_EXCEPT>"
msgstr "B<MSG_EXCEPT>"

#. type: Plain text
#: man-pages/man2/msgop.2:295
msgid ""
"Used with I<msgtyp> greater than 0 to read the first message in the queue "
"with message type that differs from I<msgtyp>."
msgstr "Используется, если I<msgtyp> больше 0, для чтения первого сообщения в очереди с типом, отличным от I<msgtyp>."

#. type: TP
#: man-pages/man2/msgop.2:295
#, no-wrap
msgid "B<MSG_NOERROR>"
msgstr "B<MSG_NOERROR>"

#. type: Plain text
#: man-pages/man2/msgop.2:300
msgid "To truncate the message text if longer than I<msgsz> bytes."
msgstr "Используется для урезания текста сообщения, если его размер больше I<msgsz> байт."

#. type: Plain text
#: man-pages/man2/msgop.2:306
msgid ""
"If no message of the requested type is available and B<IPC_NOWAIT> isn't "
"specified in I<msgflg>, the calling process is blocked until one of the "
"following conditions occurs:"
msgstr "Если в очереди нет сообщения необходимого типа и в I<msgflg> не указан B<IPC_NOWAIT>, то вызывающий процесс будет заблокирован до тех пор, пока не произойдет одно из следующих событий:"

#. type: Plain text
#: man-pages/man2/msgop.2:308
msgid "A message of the desired type is placed in the queue."
msgstr "В очередь не будет помещено сообщение необходимого типа."

#. type: Plain text
#: man-pages/man2/msgop.2:314
msgid ""
"The message queue is removed from the system.  In this case, the system call"
" fails with I<errno> set to B<EIDRM>."
msgstr "Очередь сообщений удалена из системы. В этом случае системный вызов возвращает ошибку и присваивает I<errno> значение B<EIDRM>."

#. type: Plain text
#: man-pages/man2/msgop.2:325
msgid ""
"The calling process catches a signal.  In this case, the system call fails "
"with I<errno> set to B<EINTR>.  (B<msgrcv>()  is never automatically "
"restarted after being interrupted by a signal handler, regardless of the "
"setting of the B<SA_RESTART> flag when establishing a signal handler.)"
msgstr "Вызывающий процесс не получит сигнал, который должен обработать. В этом случае системный вызов возвращает ошибку и присваивает переменной I<errno> значение B<EINTR>. Вызов B<msgrcv>() никогда не перезапускается автоматически после прерывания обработчиком сигнала, независимо от установки флага B<SA_RESTART> при настройке обработчика сигнала."

#. type: Plain text
#: man-pages/man2/msgop.2:331
msgid "I<msg_lrpid> is set to the process ID of the calling process."
msgstr "Значение I<msg_lrpid> устанавливается равным идентификатору вызывающего процесса."

#. type: Plain text
#: man-pages/man2/msgop.2:334
msgid "I<msg_qnum> is decremented by 1."
msgstr "Значение I<msg_qnum> уменьшается на 1."

#. type: Plain text
#: man-pages/man2/msgop.2:337
msgid "I<msg_rtime> is set to the current time."
msgstr "Значение I<msg_rtime> становится равным текущему времени."

#. type: Plain text
#: man-pages/man2/msgop.2:350
msgid ""
"On failure both functions return -1 with I<errno> indicating the error, "
"otherwise B<msgsnd>()  returns 0 and B<msgrcv>()  returns the number of "
"bytes actually copied into the I<mtext> array."
msgstr "При ошибке оба вызова возвращают -1, а переменная I<errno> приобретает соответствующее значение. В противном случае B<msgsnd>() возвращает 0, а B<msgrcv>() возвращает количество байтов, скопированных в массив I<mtext>."

#. type: Plain text
#: man-pages/man2/msgop.2:356
msgid ""
"When B<msgsnd>()  fails, I<errno> will be set to one among the following "
"values:"
msgstr "Значения I<errno>, устанавливаемые при возникновении ошибок в B<msgsnd>():"

#. type: Plain text
#: man-pages/man2/msgop.2:362
msgid ""
"The calling process does not have write permission on the message queue, and"
" does not have the B<CAP_IPC_OWNER> capability in the user namespace that "
"governs its IPC namespace."
msgstr "Вызывающий процесс не имеет прав записи в очередь сообщений и не имеет мандата B<CAP_IPC_OWNER> в пользовательском пространстве имён, которое управляет его пространством имён IPC."

#. type: Plain text
#: man-pages/man2/msgop.2:370
msgid ""
"The message can't be sent due to the I<msg_qbytes> limit for the queue and "
"B<IPC_NOWAIT> was specified in I<msgflg>."
msgstr "Сообщение не может быть отправлено, так как размер очереди превысит лимит, равный I<msg_qbytes>, а в параметре I<msgflg> установлен флаг B<IPC_NOWAIT>."

#. type: Plain text
#: man-pages/man2/msgop.2:375 man-pages/man2/msgop.2:422
msgid "The address pointed to by I<msgp> isn't accessible."
msgstr "Память с адресом, указанным I<msgp>, недоступна."

#. type: TP
#: man-pages/man2/msgop.2:378 man-pages/man2/msgop.2:426
#, no-wrap
msgid "B<EINTR>"
msgstr "B<EINTR>"

#. type: Plain text
#: man-pages/man2/msgop.2:381
msgid ""
"Sleeping on a full message queue condition, the process caught a signal."
msgstr "Процесс ждал свободного места в очереди и получил сигнал, который должен обработать."

#. type: Plain text
#: man-pages/man2/msgop.2:392
msgid ""
"Invalid I<msqid> value, or nonpositive I<mtype> value, or invalid I<msgsz> "
"value (less than 0 or greater than the system value B<MSGMAX>)."
msgstr "Задано неправильное значение I<msqid>, не положительное значение I<mtype> или неправильное значение I<msgsz> (меньше 0, или больше системного лимита, заданного B<MSGMAX>)."

#. type: Plain text
#: man-pages/man2/msgop.2:397
msgid ""
"The system does not have enough memory to make a copy of the message pointed"
" to by I<msgp>."
msgstr "Недостаточно памяти в системе для копирования сообщения, указанного I<msgp>."

#. type: Plain text
#: man-pages/man2/msgop.2:403
msgid ""
"When B<msgrcv>()  fails, I<errno> will be set to one among the following "
"values:"
msgstr "Значения I<errno>, устанавливаемые при возникновении ошибок в B<msgrcv>():"

#. type: TP
#: man-pages/man2/msgop.2:403
#, no-wrap
msgid "B<E2BIG>"
msgstr "B<E2BIG>"

#. type: Plain text
#: man-pages/man2/msgop.2:411
msgid ""
"The message text length is greater than I<msgsz> and B<MSG_NOERROR> isn't "
"specified in I<msgflg>."
msgstr "Длина текста получаемого сообщения больше, чем I<msgsz>, а в поле I<msgflg> не установлен флаг B<MSG_NOERROR>."

#. type: Plain text
#: man-pages/man2/msgop.2:417
msgid ""
"The calling process does not have read permission on the message queue, and "
"does not have the B<CAP_IPC_OWNER> capability in the user namespace that "
"governs its IPC namespace."
msgstr "Вызывающий процесс не имеет прав чтобы прочитать очереди сообщений и не имеет мандата B<CAP_IPC_OWNER> в пространстве имён пользователя, который управляет его пространством имён IPC."

#. type: Plain text
#: man-pages/man2/msgop.2:426
msgid ""
"While the process was sleeping to receive a message, the message queue was "
"removed."
msgstr "Процесс ждал приёма сообщения, и в это время очередь сообщений была удалена."

#. type: Plain text
#: man-pages/man2/msgop.2:431
msgid ""
"While the process was sleeping to receive a message, the process caught a "
"signal; see B<signal>(7)."
msgstr "Во время ожидания приёма сообщения процесс получил сигнал; см. B<signal>(7)."

#. type: Plain text
#: man-pages/man2/msgop.2:437
msgid "I<msqid> was invalid, or I<msgsz> was less than 0."
msgstr "Неверное значение I<msqid> или I<msgsz> меньше 0."

#. type: TP
#: man-pages/man2/msgop.2:437 man-pages/man2/msgop.2:444
#, no-wrap
msgid "B<EINVAL> (since Linux 3.14)"
msgstr "B<EINVAL> (начиная с Linux 3.14)"

#. type: Plain text
#: man-pages/man2/msgop.2:444
msgid "I<msgflg> specified B<MSG_COPY>, but not B<IPC_NOWAIT>."
msgstr "В I<msgflg> указан флаг B<MSG_COPY>, но нет B<IPC_NOWAIT>."

#. type: Plain text
#: man-pages/man2/msgop.2:451
msgid "I<msgflg> specified both B<MSG_COPY> and B<MSG_EXCEPT>."
msgstr "В I<msgflg> указаны B<MSG_COPY> и B<MSG_EXCEPT>."

#. type: TP
#: man-pages/man2/msgop.2:451 man-pages/man2/msgop.2:457
#, no-wrap
msgid "B<ENOMSG>"
msgstr "B<ENOMSG>"

#. type: Plain text
#: man-pages/man2/msgop.2:457
msgid ""
"B<IPC_NOWAIT> was specified in I<msgflg> and no message of the requested "
"type existed on the message queue."
msgstr "В очереди нет сообщения необходимого типа, а в параметре I<msgflg> установлен флаг B<IPC_NOWAIT>."

#. type: Plain text
#: man-pages/man2/msgop.2:467
msgid ""
"B<IPC_NOWAIT> and B<MSG_COPY> were specified in I<msgflg> and the queue "
"contains less than I<msgtyp> messages."
msgstr "Флаги B<IPC_NOWAIT> и B<MSG_COPY> указаны в I<msgflg>, но в очереди содержится меньше I<msgtyp> сообщений."

#. type: TP
#: man-pages/man2/msgop.2:467
#, no-wrap
msgid "B<ENOSYS> (since Linux 3.8)"
msgstr "B<ENOSYS> (начиная с Linux 3.8)"

#. type: Plain text
#: man-pages/man2/msgop.2:474
msgid ""
"I<MSG_COPY> was specified in I<msgflg>, and this kernel was configured "
"without B<CONFIG_CHECKPOINT_RESTORE>."
msgstr "Флаг I<MSG_COPY> указан в I<msgflg>, но ядро собрано без параметра B<CONFIG_CHECKPOINT_RESTORE>."

#.  MSG_COPY since glibc 2.18
#. type: Plain text
#: man-pages/man2/msgop.2:486
msgid ""
"The B<MSG_EXCEPT> and B<MSG_COPY> flags are Linux-specific; their "
"definitions can be obtained by defining the B<_GNU_SOURCE> feature test "
"macro."
msgstr "Флаги B<MSG_EXCEPT> и B<MSG_COPY> есть только в Linux; их определения можно получить указав макрос тестирования свойств B<_GNU_SOURCE>."

#. type: Plain text
#: man-pages/man2/msgop.2:506
msgid ""
"The I<msgp> argument is declared as I<struct msgbuf\\ *> in glibc 2.0 and "
"2.1.  It is declared as I<void\\ *> in glibc 2.2 and later, as required by "
"SUSv2 and SUSv3."
msgstr "Аргумент I<msgp> в glibc 2.0 и 2.1 объявлен как I<struct msgbuf *>. В glibc 2.2 и новее, в соответствии с SUSv2 и SUSv3, он объявлен как I<void\\ *>."

#. type: Plain text
#: man-pages/man2/msgop.2:510
msgid ""
"The following limits on message queue resources affect the B<msgsnd>()  "
"call:"
msgstr "На работу системного вызова B<msgsnd>() влияют следующие системные ограничения на ресурсы очереди сообщений:"

#. type: TP
#: man-pages/man2/msgop.2:510
#, no-wrap
msgid "B<MSGMAX>"
msgstr "B<MSGMAX>"

#. type: Plain text
#: man-pages/man2/msgop.2:515
msgid ""
"Maximum size of a message text, in bytes (default value: 8192 bytes).  On "
"Linux, this limit can be read and modified via I</proc/sys/kernel/msgmax>."
msgstr "Максимальный размер текста сообщения: по умолчанию он равен 8192 байтам (в Linux это ограничение можно прочитать и изменить через I</proc/sys/kernel/msgmax>)."

#. type: TP
#: man-pages/man2/msgop.2:515
#, no-wrap
msgid "B<MSGMNB>"
msgstr "B<MSGMNB>"

#. type: Plain text
#: man-pages/man2/msgop.2:531
msgid ""
"Maximum number of bytes that can be held in a message queue (default value: "
"16384 bytes).  On Linux, this limit can be read and modified via "
"I</proc/sys/kernel/msgmnb>.  A privileged process (Linux: a process with the"
" B<CAP_SYS_RESOURCE> capability)  can increase the size of a message queue "
"beyond B<MSGMNB> using the B<msgctl>(2)  B<IPC_SET> operation."
msgstr "Максимальное количество байт, которое может храниться в очереди сообщений (по умолчанию 16384 байт). В Linux это ограничение можно прочитать и изменить через I</proc/sys/kernel/msgmnb>. Привилегированный процесс (Linux: процесс с мандатом B<CAP_SYS_RESOURCE>) может устанавливать размер очереди сообщений больше чем B<MSGMNB> при помощи вызова B<msgctl>() с операцией B<IPC_SET>."

#. type: Plain text
#: man-pages/man2/msgop.2:537
msgid ""
"The implementation has no intrinsic system-wide limits on the number of "
"message headers (B<MSGTQL>)  and the number of bytes in the message pool "
"(B<MSGPOOL>)."
msgstr "Реализация не накладывает существенных системных ограничений на максимальное количество заголовков сообщений (B<MSGTQL>) и на количество байт в пуле сообщений (B<MSGPOOL>)."

#.  http://marc.info/?l=linux-kernel&m=139048542803605&w=2
#.  commit 4f87dac386cc43d5525da7a939d4b4e7edbea22c
#. type: Plain text
#: man-pages/man2/msgop.2:557
msgid ""
"In Linux 3.13 and earlier, if B<msgrcv>()  was called with the B<MSG_COPY> "
"flag, but without B<IPC_NOWAIT>, and the message queue contained less than "
"I<msgtyp> messages, then the call would block until the next message is "
"written to the queue.  At that point, the call would return a copy of the "
"message, I<regardless> of whether that message was at the ordinal position "
"I<msgtyp>.  This bug is fixed in Linux 3.14."
msgstr "В Linux 3.13 и старее, если B<msgrcv>() был вызван с флагом B<MSG_COPY> flag, но без B<IPC_NOWAIT>, и очередь сообщений содержала менее I<msgtyp> сообщений, то вызов блокировал выполнения до тех пор, пока следующее сообщение не записывалось в очередь. written to the queue. В этот момент вызов возвращал копию сообщения, I<независимо> от того, что сообщение было в начальной позиции I<msgtyp>. Этот дефект был исправлен в Linux 3.14."

#.  http://marc.info/?l=linux-kernel&m=139048542803605&w=2
#.  commit 4f87dac386cc43d5525da7a939d4b4e7edbea22c
#. type: Plain text
#: man-pages/man2/msgop.2:573
msgid ""
"Specifying both B<MSG_COPY> and B<MSC_EXCEPT> in I<msgflg> is a logical "
"error (since these flags impose different interpretations on I<msgtyp>).  In"
" Linux 3.13 and earlier, this error was not diagnosed by B<msgrcv>().  This "
"bug is fixed in Linux 3.14."
msgstr "Указание обоих флагов B<MSG_COPY> и B<MSC_EXCEPT> в I<msgflg> является логической ошибкой (так как для флагов по-разному интерпретируется I<msgtyp>). В Linux 3.13 и старее эта ошибка не определялась B<msgrcv>(). Этот дефект был исправлен в Linux 3.14."

#. type: Plain text
#: man-pages/man2/msgop.2:578
msgid ""
"The program below demonstrates the use of B<msgsnd>()  and B<msgrcv>()."
msgstr "Представленная ниже программа показывает использование B<msgsnd>() и B<msgrcv>()."

#. type: Plain text
#: man-pages/man2/msgop.2:582
msgid ""
"The example program is first run with the B<-s> option to send a message and"
" then run again with the B<-r> option to receive a message."
msgstr "В первый раз программа запускается с параметром B<-s> для отправки сообщения, а в второй — с параметром B<-r> для получения сообщения."

#. type: Plain text
#: man-pages/man2/msgop.2:584
msgid "The following shell session shows a sample run of the program:"
msgstr "Пример сеанса работы с программой:"

#. type: Plain text
#: man-pages/man2/msgop.2:589
#, no-wrap
msgid ""
"$B< ./a.out -s>\n"
"sent: a message at Wed Mar  4 16:25:45 2015\n"
msgstr "$B< ./a.out -s>\nотправка: дата сообщения Wed Mar  4 16:25:45 2015\n"

#. type: Plain text
#: man-pages/man2/msgop.2:592
#, no-wrap
msgid ""
"$B< ./a.out -r>\n"
"message received: a message at Wed Mar  4 16:25:45 2015\n"
msgstr "$B< ./a.out -r>\nприём: дата сообщения Wed Mar  4 16:25:45 2015\n"

#. type: Plain text
#: man-pages/man2/msgop.2:606
#, no-wrap
msgid ""
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>time.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"
"#include E<lt>sys/types.hE<gt>\n"
"#include E<lt>sys/ipc.hE<gt>\n"
"#include E<lt>sys/msg.hE<gt>\n"
msgstr "#include E<lt>stdio.hE<gt>\n#include E<lt>stdlib.hE<gt>\n#include E<lt>string.hE<gt>\n#include E<lt>time.hE<gt>\n#include E<lt>unistd.hE<gt>\n#include E<lt>errno.hE<gt>\n#include E<lt>sys/types.hE<gt>\n#include E<lt>sys/ipc.hE<gt>\n#include E<lt>sys/msg.hE<gt>\n"

#. type: Plain text
#: man-pages/man2/msgop.2:611
#, no-wrap
msgid ""
"struct msgbuf {\n"
"    long mtype;\n"
"    char mtext[80];\n"
"};\n"
msgstr "struct msgbuf {\n    long mtype;\n    char mtext[80];\n};\n"

#. type: Plain text
#: man-pages/man2/msgop.2:617
#, no-wrap
msgid ""
"static void\n"
"usage(char *prog_name, char *msg)\n"
"{\n"
"    if (msg != NULL)\n"
"        fputs(msg, stderr);\n"
msgstr "static void\nusage(char *prog_name, char *msg)\n{\n    if (msg != NULL)\n        fputs(msg, stderr);\n"

#. type: Plain text
#: man-pages/man2/msgop.2:626
#, no-wrap
msgid ""
"    fprintf(stderr, \"Usage: %s [options]\\en\", prog_name);\n"
"    fprintf(stderr, \"Options are:\\en\");\n"
"    fprintf(stderr, \"-s        send message using msgsnd()\\en\");\n"
"    fprintf(stderr, \"-r        read message using msgrcv()\\en\");\n"
"    fprintf(stderr, \"-t        message type (default is 1)\\en\");\n"
"    fprintf(stderr, \"-k        message queue key (default is 1234)\\en\");\n"
"    exit(EXIT_FAILURE);\n"
"}\n"
msgstr "    fprintf(stderr, \"Использование: %s [параметры]\\en\", prog_name);\n    fprintf(stderr, \"Параметры:\\en\");\n    fprintf(stderr, \"-s        отправить сообщение с помощью msgsnd()\\en\");\n    fprintf(stderr, \"-r        прочитать сообщение с помощью msgrcv()\\en\");\n    fprintf(stderr, \"-t        тип сообщения (по умолчанию 1)\\en\");\n    fprintf(stderr, \"-k        ключ очереди сообщения (по умолчанию 1234)\\en\");\n    exit(EXIT_FAILURE);\n}\n"

#. type: Plain text
#: man-pages/man2/msgop.2:632
#, no-wrap
msgid ""
"static void\n"
"send_msg(int qid, int msgtype)\n"
"{\n"
"    struct msgbuf msg;\n"
"    time_t t;\n"
msgstr "static void\nsend_msg(int qid, int msgtype)\n{\n    struct msgbuf msg;\n    time_t t;\n"

#. type: Plain text
#: man-pages/man2/msgop.2:634
#, no-wrap
msgid "    msg.mtype = msgtype;\n"
msgstr "    msg.mtype = msgtype;\n"

#. type: Plain text
#: man-pages/man2/msgop.2:638
#, no-wrap
msgid ""
"    time(&t);\n"
"    snprintf(msg.mtext, sizeof(msg.mtext), \"a message at %s\",\n"
"            ctime(&t));\n"
msgstr "    time(&t);\n    snprintf(msg.mtext, sizeof(msg.mtext), \"дата сообщения %s\",\n            ctime(&t));\n"

#. type: Plain text
#: man-pages/man2/msgop.2:646
#, no-wrap
msgid ""
"    if (msgsnd(qid, (void *) &msg, sizeof(msg.mtext),\n"
"                IPC_NOWAIT) == -1) {\n"
"        perror(\"msgsnd error\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
"    printf(\"sent: %s\\en\", msg.mtext);\n"
"}\n"
msgstr "    if (msgsnd(qid, (void *) &msg, sizeof(msg.mtext),\n                IPC_NOWAIT) == -1) {\n        perror(\"msgsnd error\");\n        exit(EXIT_FAILURE);\n    }\n    printf(\"отправка: %s\\en\", msg.mtext);\n}\n"

#. type: Plain text
#: man-pages/man2/msgop.2:651
#, no-wrap
msgid ""
"static void\n"
"get_msg(int qid, int msgtype)\n"
"{\n"
"    struct msgbuf msg;\n"
msgstr "static void\nget_msg(int qid, int msgtype)\n{\n    struct msgbuf msg;\n"

#. type: Plain text
#: man-pages/man2/msgop.2:662
#, no-wrap
msgid ""
"    if (msgrcv(qid, (void *) &msg, sizeof(msg.mtext), msgtype,\n"
"               MSG_NOERROR | IPC_NOWAIT) == -1) {\n"
"        if (errno != ENOMSG) {\n"
"            perror(\"msgrcv\");\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"
"        printf(\"No message available for msgrcv()\\en\");\n"
"    } else\n"
"        printf(\"message received: %s\\en\", msg.mtext);\n"
"}\n"
msgstr "    if (msgrcv(qid, (void *) &msg, sizeof(msg.mtext), msgtype,\n               MSG_NOERROR | IPC_NOWAIT) == -1) {\n        if (errno != ENOMSG) {\n            perror(\"msgrcv\");\n            exit(EXIT_FAILURE);\n        }\n        printf(\"С помощью msgrcv() сообщений не получено\\en\");\n    } else\n        printf(\"приём: %s\\en\", msg.mtext);\n}\n"

#. type: Plain text
#: man-pages/man2/msgop.2:670
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int qid, opt;\n"
"    int mode = 0;               /* 1 = send, 2 = receive */\n"
"    int msgtype = 1;\n"
"    int msgkey = 1234;\n"
msgstr "int\nmain(int argc, char *argv[])\n{\n    int qid, opt;\n    int mode = 0;               /* 1 = send, 2 = receive */\n    int msgtype = 1;\n    int msgkey = 1234;\n"

#. type: Plain text
#: man-pages/man2/msgop.2:691
#, no-wrap
msgid ""
"    while ((opt = getopt(argc, argv, \"srt:k:\")) != -1) {\n"
"        switch (opt) {\n"
"        case \\(aqs\\(aq:\n"
"            mode = 1;\n"
"            break;\n"
"        case \\(aqr\\(aq:\n"
"            mode = 2;\n"
"            break;\n"
"        case \\(aqt\\(aq:\n"
"            msgtype = atoi(optarg);\n"
"            if (msgtype E<lt>= 0)\n"
"                usage(argv[0], \"-t option must be greater than 0\\en\");\n"
"            break;\n"
"        case \\(aqk\\(aq:\n"
"            msgkey = atoi(optarg);\n"
"            break;\n"
"        default:\n"
"            usage(argv[0], \"Unrecognized option\\en\");\n"
"        }\n"
"    }\n"
msgstr "    while ((opt = getopt(argc, argv, \"srt:k:\")) != -1) {\n        switch (opt) {\n        case \\(aqs\\(aq:\n            mode = 1;\n            break;\n        case \\(aqr\\(aq:\n            mode = 2;\n            break;\n        case \\(aqt\\(aq:\n            msgtype = atoi(optarg);\n            if (msgtype E<lt>= 0)\n                usage(argv[0], \"параметр -t должен быть больше 0\\en\");\n            break;\n        case \\(aqk\\(aq:\n            msgkey = atoi(optarg);\n            break;\n        default:\n            usage(argv[0], \"Неизвестный параметр\\en\");\n        }\n    }\n"

#. type: Plain text
#: man-pages/man2/msgop.2:694
#, no-wrap
msgid ""
"    if (mode == 0)\n"
"        usage(argv[0], \"must use either -s or -r option\\en\");\n"
msgstr "    if (mode == 0)\n        usage(argv[0], \"нужно указать параметр -s или -r\\en\");\n"

#. type: Plain text
#: man-pages/man2/msgop.2:696
#, no-wrap
msgid "    qid = msgget(msgkey, IPC_CREAT | 0666);\n"
msgstr "    qid = msgget(msgkey, IPC_CREAT | 0666);\n"

#. type: Plain text
#: man-pages/man2/msgop.2:701
#, no-wrap
msgid ""
"    if (qid == -1) {\n"
"        perror(\"msgget\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr "    if (qid == -1) {\n        perror(\"msgget\");\n        exit(EXIT_FAILURE);\n    }\n"

#. type: Plain text
#: man-pages/man2/msgop.2:706
#, no-wrap
msgid ""
"    if (mode == 2)\n"
"        get_msg(qid, msgtype);\n"
"    else\n"
"        send_msg(qid, msgtype);\n"
msgstr "    if (mode == 2)\n        get_msg(qid, msgtype);\n    else\n        send_msg(qid, msgtype);\n"

#. type: Plain text
#: man-pages/man2/msgop.2:715
msgid ""
"B<msgctl>(2), B<msgget>(2), B<capabilities>(7), B<mq_overview>(7), "
"B<sysvipc>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/move_pages.2:20
#, no-wrap
msgid "MOVE_PAGES"
msgstr "MOVE_PAGES"

#. type: Plain text
#: man-pages/man2/move_pages.2:23
msgid "move_pages - move individual pages of a process to another node"
msgstr "move_pages - перемещает отдельные страницы процесса на другой узел"

#. type: Plain text
#: man-pages/man2/move_pages.2:26
#, no-wrap
msgid "B<#include E<lt>numaif.hE<gt>>\n"
msgstr "B<#include E<lt>numaif.hE<gt>>\n"

#. type: Plain text
#: man-pages/man2/move_pages.2:29
#, no-wrap
msgid ""
"B<long move_pages(int >I<pid>B<, unsigned long count, void **>I<pages>B<,>\n"
"B<                const int *>I<nodes>B<, int *>I<status>B<, int >I<flags>B<);>\n"
msgstr "B<long move_pages(int >I<pid>B<, unsigned long count, void **>I<pages>B<,>\nB<                const int *>I<nodes>B<, int *>I<status>B<, int >I<flags>B<);>\n"

#. type: Plain text
#: man-pages/man2/move_pages.2:32
msgid "Link with I<-lnuma>."
msgstr "Компонуется при указании параметра I<-lnuma>."

#. type: Plain text
#: man-pages/man2/move_pages.2:45
msgid ""
"B<move_pages>()  moves the specified I<pages> of the process I<pid> to the "
"memory nodes specified by I<nodes>.  The result of the move is reflected in "
"I<status>.  The I<flags> indicate constraints on the pages to be moved."
msgstr "Вызов B<move_pages>() перемещает указанные в I<pages> страницы процесса с I<pid> в память узлов, заданных в I<nodes>. Результат перемещения отражается в I<status>. В I<flags> задаются ограничения на перемещаемые страницы."

#. type: Plain text
#: man-pages/man2/move_pages.2:53
msgid ""
"I<pid> is the ID of the process in which pages are to be moved.  If I<pid> "
"is 0, then B<move_pages>()  moves pages of the calling process."
msgstr "Значение I<pid> представляет собой идентификатор процесса, в котором перемещаются страницы. Если I<pid> равен 0, то B<move_pages>()  перемещается страницы вызывающего процесса."

#. type: Plain text
#: man-pages/man2/move_pages.2:55
msgid "To move pages in another process requires the following privileges:"
msgstr "Для перемещения страниц в другом процессе требуются следующие права:"

#. type: Plain text
#: man-pages/man2/move_pages.2:61
msgid ""
"In kernels up to and including Linux 4.12: the caller must be privileged "
"(B<CAP_SYS_NICE>)  or the real or effective user ID of the calling process "
"must match the real or saved-set user ID of the target process."
msgstr "В ядрах до Linux 4.12 включительно: вызывающий должен иметь права (B<CAP_SYS_NICE>) или реальный или эффективный пользовательский ID вызывающего процесса должен совпадать с реальным или сохранённым пользовательским ID целевого процесса."

#.  commit 197e7e521384a23b9e585178f3f11c9fa08274b9
#. type: Plain text
#: man-pages/man2/move_pages.2:73
msgid ""
"The older rules allowed the caller to discover various virtual address "
"choices made by the kernel that could lead to the defeat of address-space-"
"layout randomization for a process owned by the same UID as the caller, the "
"rules were changed starting with Linux 4.13.  Since Linux 4.13, permission "
"is governed by a ptrace access mode B<PTRACE_MODE_READ_REALCREDS> check with"
" respect to the target process; see B<ptrace>(2)."
msgstr "Старые правила позволяли вызывающему обнаруживать различные виртуальные адреса, выбранные ядром, что лишает смысла случайность расположения раскладки адресного пространства процесса, принадлежащему тому же UID что и вызывающий; правила были изменены в Linux 4.13. Начиная с Linux 4.13, права регулируются проверкой режима доступа ptrace B<PTRACE_MODE_READ_REALCREDS> целевого процесса; смотрите B<ptrace>(2)."

#. type: Plain text
#: man-pages/man2/move_pages.2:81
msgid ""
"I<count> is the number of pages to move.  It defines the size of the three "
"arrays I<pages>, I<nodes>, and I<status>."
msgstr "В аргументе I<count> задаётся количество перемещаемых страниц. Он определяет размер трёх массивов: I<pages>, I<nodes> и I<status>."

#.  FIXME Describe the result if pointers in the 'pages' array are
#.  not aligned to page boundaries
#. type: Plain text
#: man-pages/man2/move_pages.2:89
msgid ""
"I<pages> is an array of pointers to the pages that should be moved.  These "
"are pointers that should be aligned to page boundaries.  Addresses are "
"specified as seen by the process specified by I<pid>."
msgstr "Аргумент I<pages> представляет собой массив указателей на страницы, которые должны быть перемещены. Данные указатели должны быть выровнены на границу страницы. Адреса указываются в том же виде, в каком доступны процессу с заданным I<pid>."

#. type: Plain text
#: man-pages/man2/move_pages.2:102
msgid ""
"I<nodes> is an array of integers that specify the desired location for each "
"page.  Each element in the array is a node number.  I<nodes> can also be "
"NULL, in which case B<move_pages>()  does not move any pages but instead "
"will return the node where each page currently resides, in the I<status> "
"array.  Obtaining the status of each page may be necessary to determine "
"pages that need to be moved."
msgstr "Аргумент I<nodes> представляет собой массив целых, которыми задаются желаемые местоположения каждой страницы. Каждый элемент массива представляет собой номер узла. Также, значением I<nodes> может быть NULL; в этом случае B<move_pages>() не перемещает страницы, а записывает в массив I<status> номер узла, на котором расположена каждая страница в данный момент. Получение состояния каждой страницы может потребоваться для определения страниц, которые нужно переместить."

#. type: Plain text
#: man-pages/man2/move_pages.2:108
msgid ""
"I<status> is an array of integers that return the status of each page.  The "
"array contains valid values only if B<move_pages>()  did not return an "
"error."
msgstr "Аргумент I<status> представляет собой массив целых, которым определяется состояние каждой страницы. Массив содержит правильные значения только, если вызов B<move_pages>() не завершился с ошибкой."

#. type: Plain text
#: man-pages/man2/move_pages.2:120
msgid ""
"I<flags> specify what types of pages to move.  B<MPOL_MF_MOVE> means that "
"only pages that are in exclusive use by the process are to be moved.  "
"B<MPOL_MF_MOVE_ALL> means that pages shared between multiple processes can "
"also be moved.  The process must be privileged (B<CAP_SYS_NICE>)  to use "
"B<MPOL_MF_MOVE_ALL>."
msgstr "В аргументе I<flags> указываются типы перемещаемых страниц. Флаг B<MPOL_MF_MOVE> означает, что будут перемещены только страницы, которые монопольно используются процессом. Флаг B<MPOL_MF_MOVE_ALL> означает, что также будут перемещены страницы, которые используются совместно с другими процессами. Для использования флага B<MPOL_MF_MOVE_ALL> процесс должен быть привилегированным (B<CAP_SYS_NICE>)."

#. type: SS
#: man-pages/man2/move_pages.2:120
#, no-wrap
msgid "Page states in the status array"
msgstr "Состояние страницы в массиве состояний"

#. type: Plain text
#: man-pages/man2/move_pages.2:124
msgid ""
"The following values can be returned in each element of the I<status> array."
msgstr "В каждом элементе массива I<status> могут возвращаться следующие значения:"

#. type: TP
#: man-pages/man2/move_pages.2:124
#, no-wrap
msgid "B<0..MAX_NUMNODES>"
msgstr "B<0..MAX_NUMNODES>"

#. type: Plain text
#: man-pages/man2/move_pages.2:127
msgid "Identifies the node on which the page resides."
msgstr "Номер узла, в котором расположена страница."

#. type: TP
#: man-pages/man2/move_pages.2:127
#, no-wrap
msgid "B<-EACCES>"
msgstr "B<-EACCES>"

#. type: Plain text
#: man-pages/man2/move_pages.2:132
msgid ""
"The page is mapped by multiple processes and can be moved only if "
"B<MPOL_MF_MOVE_ALL> is specified."
msgstr "Страница отображается несколькими процессами и может быть перемещена только, если указан флаг B<MPOL_MF_MOVE_ALL>."

#. type: TP
#: man-pages/man2/move_pages.2:132
#, no-wrap
msgid "B<-EBUSY>"
msgstr "B<-EBUSY>"

#. type: Plain text
#: man-pages/man2/move_pages.2:138
msgid ""
"The page is currently busy and cannot be moved.  Try again later.  This "
"occurs if a page is undergoing I/O or another kernel subsystem is holding a "
"reference to the page."
msgstr "Страница в данный момент занята и не может быть перемещена. Попробуйте позднее. Такое случается, если со страницей выполняется операция ввода-вывода или другая подсистема ядра удерживается ссылку на эту страницу."

#. type: TP
#: man-pages/man2/move_pages.2:138
#, no-wrap
msgid "B<-EFAULT>"
msgstr "B<-EFAULT>"

#. type: Plain text
#: man-pages/man2/move_pages.2:141
msgid "This is a zero page or the memory area is not mapped by the process."
msgstr "Это нулевая страница или область памяти не отображена процессом."

#. type: TP
#: man-pages/man2/move_pages.2:141
#, no-wrap
msgid "B<-EIO>"
msgstr "B<-EIO>"

#. type: Plain text
#: man-pages/man2/move_pages.2:148
msgid ""
"Unable to write back a page.  The page has to be written back in order to "
"move it since the page is dirty and the filesystem does not provide a "
"migration function that would allow the move of dirty pages."
msgstr "Не удалось выполнить обратную запись на страницу. Для перемещения требуется выполнить обратную запись, так как данные страницы неактуальны (dirty), но файловая система не предоставляет функцию переноса (migration), которая позволила бы переместить неактуальные страницы."

#. type: TP
#: man-pages/man2/move_pages.2:148
#, no-wrap
msgid "B<-EINVAL>"
msgstr "B<-EINVAL>"

#. type: Plain text
#: man-pages/man2/move_pages.2:153
msgid ""
"A dirty page cannot be moved.  The filesystem does not provide a migration "
"function and has no ability to write back pages."
msgstr "Нельзя переместить неактуальные страницы. Файловая система не предоставляет функцию переноса (migration), поэтому нет возможности выполнить обратную запись на страницы."

#. type: TP
#: man-pages/man2/move_pages.2:153
#, no-wrap
msgid "B<-ENOENT>"
msgstr "B<-ENOENT>"

#. type: Plain text
#: man-pages/man2/move_pages.2:156
msgid "The page is not present."
msgstr "Страница отсутствует."

#. type: TP
#: man-pages/man2/move_pages.2:156
#, no-wrap
msgid "B<-ENOMEM>"
msgstr "B<-ENOMEM>"

#. type: Plain text
#: man-pages/man2/move_pages.2:159
msgid "Unable to allocate memory on target node."
msgstr "Не удалось выделить память на узле назначения."

#.  FIXME . Is the following quite true: does the wrapper in numactl
#.  do the right thing?
#. type: Plain text
#: man-pages/man2/move_pages.2:168
msgid ""
"On success B<move_pages>()  returns zero.  On error, it returns -1, and sets"
" I<errno> to indicate the error."
msgstr "При нормальном завершении работы B<move_pages>() возвращает ноль. В случае ошибки возвращается -1, а I<errno> устанавливается в соответствующее значение."

#. type: Plain text
#: man-pages/man2/move_pages.2:172
msgid "Too many pages to move."
msgstr "Слишком много перемещаемых страниц."

#.  FIXME Clarify "current cpuset" in the description of the EACCES error.
#.  Is that the cpuset of the caller or the target?
#. type: Plain text
#: man-pages/man2/move_pages.2:177
msgid "One of the target nodes is not allowed by the current cpuset."
msgstr "Один из узлов назначения не разрешён для текущего набора ЦП."

#. type: Plain text
#: man-pages/man2/move_pages.2:180
msgid "Parameter array could not be accessed."
msgstr "Недоступен массив параметров."

#. type: Plain text
#: man-pages/man2/move_pages.2:187
msgid ""
"Flags other than B<MPOL_MF_MOVE> and B<MPOL_MF_MOVE_ALL> was specified or an"
" attempt was made to migrate pages of a kernel thread."
msgstr "Указаны флаги, отличные от B<MPOL_MF_MOVE> и B<MPOL_MF_MOVE_ALL>, или предпринята попытка переместить (migrate) страницы нити ядра."

#. type: Plain text
#: man-pages/man2/move_pages.2:190
msgid "One of the target nodes is not online."
msgstr "Один из узлов назначения недоступен (not online)."

#. type: Plain text
#: man-pages/man2/move_pages.2:196
msgid ""
"No pages were found that require moving.  All pages are either already on "
"the target node, not present, had an invalid address or could not be moved "
"because they were mapped by multiple processes."
msgstr "Не найдены страницы, которые требуется переместить. Все страницы или уже на узле назначения, отсутствуют, имеют неправильный адрес, или не могут быть перемещены, так как отображены несколькими процессами."

#. type: Plain text
#: man-pages/man2/move_pages.2:205
msgid ""
"The caller specified B<MPOL_MF_MOVE_ALL> without sufficient privileges "
"(B<CAP_SYS_NICE>).  Or, the caller attempted to move pages of a process "
"belonging to another user but did not have privilege to do so "
"(B<CAP_SYS_NICE>)."
msgstr "Вызывающий указал флаг B<MPOL_MF_MOVE_ALL>, но у него не хватает привилегий (B<CAP_SYS_NICE>). Или вызывающий попытался переместить страницы процесса, принадлежащие другому пользователю, но не имеет привилегий для этого (B<CAP_SYS_NICE>)."

#. type: TP
#: man-pages/man2/move_pages.2:205
#, no-wrap
msgid "B<ESRCH>"
msgstr "B<ESRCH>"

#. type: Plain text
#: man-pages/man2/move_pages.2:208
msgid "Process does not exist."
msgstr "Процесс не существует."

#. type: Plain text
#: man-pages/man2/move_pages.2:211
msgid "B<move_pages>()  first appeared on Linux in version 2.6.18."
msgstr "Вызов B<move_pages>() впервые появился в Linux в ядре версии 2.6.18."

#. type: Plain text
#: man-pages/man2/move_pages.2:213
msgid "This system call is Linux-specific."
msgstr "Данный вызов есть только в Linux."

#. type: Plain text
#: man-pages/man2/move_pages.2:216
msgid "For information on library support, see B<numa>(7)."
msgstr "Информация о библиотеке доступна в B<numa>(7)."

#.  FIXME Clarify "current cpuset".  Is that the cpuset of the caller
#.  or the target?
#. type: Plain text
#: man-pages/man2/move_pages.2:227
msgid ""
"Use B<get_mempolicy>(2)  with the B<MPOL_F_MEMS_ALLOWED> flag to obtain the "
"set of nodes that are allowed by the current cpuset.  Note that this "
"information is subject to change at any time by manual or automatic "
"reconfiguration of the cpuset."
msgstr "Используйте B<get_mempolicy>(2) с флагом B<MPOL_F_MEMS_ALLOWED> для получения набора узлов, которые доступны в текущем наборе ЦП. Заметим, что эта информация может измениться в любое время вручную или при автоматической перенастройке набора ЦП."

#. type: Plain text
#: man-pages/man2/move_pages.2:237
msgid ""
"Use of this function may result in pages whose location (node) violates the "
"memory policy established for the specified addresses (See B<mbind>(2))  "
"and/or the specified process (See B<set_mempolicy>(2)).  That is, memory "
"policy does not constrain the destination nodes used by B<move_pages>()."
msgstr "Использование этого вызова может привести к тому, что расположение страниц (на узле) нарушит политику памяти, установленную для заданных адресов (см. B<mbind>(2)) и/или заданного процесса (см. B<set_mempolicy>(2)). То есть политика памяти не ограничивает узлы назначения, используемые B<move_pages>()."

#. type: Plain text
#: man-pages/man2/move_pages.2:243
msgid ""
"The I<E<lt>numaif.hE<gt>> header is not included with glibc, but requires "
"installing I<libnuma-devel> or a similar package."
msgstr "Заголовочный файл I<E<lt>numaif.hE<gt>> не включён в glibc, его можно найти в пакете с именем I<libnuma-devel> или подобным названием."

#. type: Plain text
#: man-pages/man2/move_pages.2:252
msgid ""
"B<get_mempolicy>(2), B<mbind>(2), B<set_mempolicy>(2), B<numa>(3), "
"B<numa_maps>(5), B<cpuset>(7), B<numa>(7), B<migratepages>(8), "
"B<numastat>(8)"
msgstr "B<get_mempolicy>(2), B<mbind>(2), B<set_mempolicy>(2), B<numa>(3), B<numa_maps>(5), B<cpuset>(7), B<numa>(7), B<migratepages>(8), B<numastat>(8)"

#. type: TH
#: man-pages/man2/membarrier.2:25
#, no-wrap
msgid "MEMBARRIER"
msgstr "MEMBARRIER"

#. type: TH
#: man-pages/man2/membarrier.2:25
#, no-wrap
msgid "2018-04-30"
msgstr "2018-04-30"

#. type: Plain text
#: man-pages/man2/membarrier.2:28
msgid "membarrier - issue memory barriers on a set of threads"
msgstr "membarrier - задаёт барьеры памяти в наборе нитей"

#. type: Plain text
#: man-pages/man2/membarrier.2:30
msgid "B<#include E<lt>linux/membarrier.hE<gt>>"
msgstr "B<#include E<lt>linux/membarrier.hE<gt>>"

#. type: Plain text
#: man-pages/man2/membarrier.2:32
msgid "B<int membarrier(int >I<cmd>B<, int >I<flags>B<);>"
msgstr "B<int membarrier(int >I<cmd>B<, int >I<flags>B<);>"

#. type: Plain text
#: man-pages/man2/membarrier.2:42
msgid ""
"The B<membarrier>()  system call helps reducing the overhead of the memory "
"barrier instructions required to order memory accesses on multi-core "
"systems.  However, this system call is heavier than a memory barrier, so "
"using it effectively is I<not> as simple as replacing memory barriers with "
"this system call, but requires understanding of the details below."
msgstr "Системный вызов B<membarrier>() помогает сократить накладные расходы инструкций барьера памяти, которые требуются при доступе к памяти в многоядерных системах. Однако данный системный вызов затратнее чем барьер памяти, поэтому чтобы использовать его эффективно I<недостаточно> просто заменить им барьеры памяти, требуется понимание описанного далее."

#. type: Plain text
#: man-pages/man2/membarrier.2:47
msgid ""
"Use of memory barriers needs to be done taking into account that a memory "
"barrier always needs to be either matched with its memory barrier "
"counterparts, or that the architecture's memory model doesn't require the "
"matching barriers."
msgstr "При использовании барьеров памяти нужно принимать во внимание, что барьер памяти всегда должен или иметь противоположную сторону барьера, или что модель памяти архитектуры этого не требует."

#. type: Plain text
#: man-pages/man2/membarrier.2:56
msgid ""
"There are cases where one side of the matching barriers (which we will refer"
" to as \"fast side\") is executed much more often than the other (which we "
"will refer to as \"slow side\").  This is a prime target for the use of "
"B<membarrier>().  The key idea is to replace, for these matching barriers, "
"the fast-side memory barriers by simple compiler barriers, for example:"
msgstr "При работе бывает, что одна сторона барьера (которую будем называть «быстрой стороной») применяется чаще чем другая (которую будем называть «медленной стороной»). Это основная цель использования B<membarrier>(). Основная идея в замене этих барьеров: быстрые стороны барьеров — простыми барьерами компилятора:"

#. type: Plain text
#: man-pages/man2/membarrier.2:60
#, no-wrap
msgid "asm volatile (\"\" : : : \"memory\")\n"
msgstr "asm volatile (\"\" : : : \"memory\")\n"

#. type: Plain text
#: man-pages/man2/membarrier.2:65
msgid "and replace the slow-side memory barriers by calls to B<membarrier>()."
msgstr "а медленные стороны барьеров — вызовами B<membarrier>()."

#. type: Plain text
#: man-pages/man2/membarrier.2:71
msgid ""
"This will add overhead to the slow side, and remove overhead from the fast "
"side, thus resulting in an overall performance increase as long as the slow "
"side is infrequent enough that the overhead of the B<membarrier>()  calls "
"does not outweigh the performance gain on the fast side."
msgstr "Это добавит накладных расходов к медленной стороне и удалит расходы у быстрой стороны, что в результате повысит общую производительность в зависимости от того, как часто используются вызовы B<membarrier>() у медленной стороны, из-за которой возникают издержки, и не перевесит ли это увеличение производительности быстрой стороны."

#. type: Plain text
#: man-pages/man2/membarrier.2:75
msgid "The I<cmd> argument is one of the following:"
msgstr "Аргумент I<cmd> может принимать одно из следующих значений:"

#. type: TP
#: man-pages/man2/membarrier.2:75
#, no-wrap
msgid "B<MEMBARRIER_CMD_QUERY> (since Linux 4.3)"
msgstr "B<MEMBARRIER_CMD_QUERY> (начиная с Linux 4.3)"

#. type: Plain text
#: man-pages/man2/membarrier.2:86
msgid ""
"Query the set of supported commands.  The return value of the call is a bit "
"mask of supported commands.  B<MEMBARRIER_CMD_QUERY>, which has the value 0,"
" is not itself included in this bit mask.  This command is always supported "
"(on kernels where B<membarrier>()  is provided)."
msgstr "Запросить набор поддерживаемых команд. Возвращаемое вызовом значение представляет собой битовую маску поддерживаемых команд. Сама команда B<MEMBARRIER_CMD_QUERY> имеет значение 0 и не включается в эту маску. Данная команда поддерживается всегда (в ядрах с поддержкой B<membarrier>())."

#. type: TP
#: man-pages/man2/membarrier.2:86
#, no-wrap
msgid "B<MEMBARRIER_CMD_GLOBAL> (since Linux 4.16)"
msgstr "B<MEMBARRIER_CMD_GLOBAL> (начиная с Linux 4.16)"

#. type: Plain text
#: man-pages/man2/membarrier.2:94
msgid ""
"Ensure that all threads from all processes on the system pass through a "
"state where all memory accesses to user-space addresses match program order "
"between entry to and return from the B<membarrier>()  system call.  All "
"threads on the system are targeted by this command."
msgstr "Проверить, что все потоки всех процессов в системе прошли через состояние, где все доступы к памяти по адресам пространства пользователя соответствуют программному порядку между входом и возвратом из системного вызова B<membarrier>(). Все потоки в системе являются целью этой команды."

#. type: TP
#: man-pages/man2/membarrier.2:94
#, no-wrap
msgid "B<MEMBARRIER_CMD_GLOBAL_EXPEDITED> (since Linux 4.16)"
msgstr "B<MEMBARRIER_CMD_GLOBAL_EXPEDITED> (начиная с Linux 4.16)"

#. type: Plain text
#: man-pages/man2/membarrier.2:99
msgid ""
"Execute a memory barrier on all running threads of all processes that "
"previously registered with B<MEMBARRIER_CMD_REGISTER_GLOBAL_EXPEDITED>."
msgstr "Установить барьер памяти во всех выполняющихся нитях всех процессов, которые были ранее зарегистрированы с помощью B<MEMBARRIER_CMD_REGISTER_GLOBAL_EXPEDITED>."

#. type: Plain text
#: man-pages/man2/membarrier.2:107
msgid ""
"Upon return from the system call, the calling thread has a guarantee that "
"all running threads have passed through a state where all memory accesses to"
" user-space addresses match program order between entry to and return from "
"the system call (non-running threads are de facto in such a state).  This "
"guarantee is provided only for the threads of processes that previously "
"registered with B<MEMBARRIER_CMD_REGISTER_GLOBAL_EXPEDITED>."
msgstr "После возврата из системного вызова вызвавшей нити гарантируется, что все выполняющиеся нити прошли через состояние, где все доступы к памяти по адресам пространства пользователя соответствуют программному порядку между входом и возвратом из системного вызова (не выполняющиеся нити уже в таком состоянии). Это гарантируется только для нитей процессов, которые были ранее зарегистрированы с помощью B<MEMBARRIER_CMD_REGISTER_GLOBAL_EXPEDITED>."

#. type: Plain text
#: man-pages/man2/membarrier.2:113
msgid ""
"Given that registration is about the intent to receive the barriers, it is "
"valid to invoke B<MEMBARRIER_CMD_GLOBAL_EXPEDITED> from a process that has "
"not employed B<MEMBARRIER_CMD_REGISTER_GLOBAL_EXPEDITED>."
msgstr "Учтите, что регистрация о намерении получать барьеры допускается вызовом B<MEMBARRIER_CMD_GLOBAL_EXPEDITED> только из процесса, который не использовал B<MEMBARRIER_CMD_REGISTER_GLOBAL_EXPEDITED>."

#. type: Plain text
#: man-pages/man2/membarrier.2:116 man-pages/man2/membarrier.2:136
msgid ""
"The \"expedited\" commands complete faster than the non-expedited ones; they"
" never block, but have the downside of causing extra overhead."
msgstr "«Курируемые» (expedited) команды выполняются быстрее чем не курируемые; они никогда не блокируются, но на них приходятся дополнительные издержки."

#. type: TP
#: man-pages/man2/membarrier.2:116
#, no-wrap
msgid "B<MEMBARRIER_CMD_REGISTER_GLOBAL_EXPEDITED> (since Linux 4.16)"
msgstr "B<MEMBARRIER_CMD_REGISTER_GLOBAL_EXPEDITED> (начиная с Linux 4.16)"

#. type: Plain text
#: man-pages/man2/membarrier.2:121
msgid ""
"Register the process's intent to receive B<MEMBARRIER_CMD_GLOBAL_EXPEDITED> "
"memory barriers."
msgstr "Зарегистрировать намерение процесса получать барьеры памяти B<MEMBARRIER_CMD_GLOBAL_EXPEDITED>."

#. type: TP
#: man-pages/man2/membarrier.2:121
#, no-wrap
msgid "B<MEMBARRIER_CMD_PRIVATE_EXPEDITED> (since Linux 4.14)"
msgstr "B<MEMBARRIER_CMD_PRIVATE_EXPEDITED> (начиная с Linux 4.14)"

#. type: Plain text
#: man-pages/man2/membarrier.2:125
msgid ""
"Execute a memory barrier on each running thread belonging to the same "
"process as the calling thread."
msgstr "Применить барьер памяти на все выполняющиеся нити, принадлежащие тому же процессу, что и вызвавшая нить."

#. type: Plain text
#: man-pages/man2/membarrier.2:133
msgid ""
"Upon return from the system call, the calling thread has a guarantee that "
"all its running thread siblings have passed through a state where all memory"
" accesses to user-space addresses match program order between entry to and "
"return from the system call (non-running threads are de facto in such a "
"state).  This guarantee is provided only for threads in the same process as "
"the calling thread."
msgstr "После возврата из системного вызова вызвавшей нити гарантируется, что все выполняющиеся, одноуровневые с ней нити прошли через состояние, где все доступы к памяти по адресам пространства пользователя соответствуют программному порядку между входом и возвратом из системного вызова (невыполняющиеся нити уже в таком состоянии). Это гарантируется только для нитей того же процесса, что и вызвавшая нить."

#. type: Plain text
#: man-pages/man2/membarrier.2:139
msgid ""
"A process must register its intent to use the private expedited command "
"prior to using it."
msgstr "Процессу нужно регистрировать своё намерение использовать частную курируемую команду до её использования."

#. type: TP
#: man-pages/man2/membarrier.2:139
#, no-wrap
msgid "B<MEMBARRIER_CMD_REGISTER_PRIVATE_EXPEDITED> (since Linux 4.14)"
msgstr "B<MEMBARRIER_CMD_REGISTER_PRIVATE_EXPEDITED> (начиная с Linux 4.14)"

#. type: Plain text
#: man-pages/man2/membarrier.2:143
msgid ""
"Register the process's intent to use B<MEMBARRIER_CMD_PRIVATE_EXPEDITED>."
msgstr "Зарегистрировать намерение процесса использовать B<MEMBARRIER_CMD_PRIVATE_EXPEDITED>."

#. type: TP
#: man-pages/man2/membarrier.2:143
#, no-wrap
msgid "B<MEMBARRIER_CMD_PRIVATE_EXPEDITED_SYNC_CORE> (since Linux 4.16)"
msgstr "B<MEMBARRIER_CMD_PRIVATE_EXPEDITED_SYNC_CORE> (начиная с Linux 4.16)"

#. type: Plain text
#: man-pages/man2/membarrier.2:151
msgid ""
"In addition to providing the memory ordering guarantees described in "
"B<MEMBARRIER_CMD_PRIVATE_EXPEDITED>, upon return from system call the "
"calling thread has a guarantee that all its running thread siblings have "
"executed a core serializing instruction.  This guarantee is provided only "
"for threads in the same process as the calling thread."
msgstr "В дополнении к гарантии упорядочивания памяти, описанной в B<MEMBARRIER_CMD_PRIVATE_EXPEDITED>, после возврата из системного вызова вызвавшей нити гарантируется, что все выполняющиеся, одноуровневые с ней нити выполнили ядерную инструкцию сериализации (core serializing instruction). Это гарантируется только для нитей того же процесса, что и вызвавшая нить."

#. type: Plain text
#: man-pages/man2/membarrier.2:154
msgid ""
"The \"expedited\" commands complete faster than the non-expedited ones, they"
" never block, but have the downside of causing extra overhead."
msgstr "«Курируемые» (expedited) команды выполняются быстрее чем не курируемые; они никогда не блокируются, но на них приходятся дополнительные издержки."

#. type: Plain text
#: man-pages/man2/membarrier.2:157
msgid ""
"A process must register its intent to use the private expedited sync core "
"command prior to using it."
msgstr "Процессу нужно регистрировать своё намерение использовать частную курируемую ядерную команду синхронизации до её использования."

#. type: TP
#: man-pages/man2/membarrier.2:157
#, no-wrap
msgid ""
"B<MEMBARRIER_CMD_REGISTER_PRIVATE_EXPEDITED_SYNC_CORE> (since Linux 4.16)"
msgstr "B<MEMBARRIER_CMD_REGISTER_PRIVATE_EXPEDITED_SYNC_CORE> (начиная с Linux 4.16)"

#. type: Plain text
#: man-pages/man2/membarrier.2:161
msgid ""
"Register the process's intent to use "
"B<MEMBARRIER_CMD_PRIVATE_EXPEDITED_SYNC_CORE>."
msgstr "Зарегистрировать намерение процесса использовать B<MEMBARRIER_CMD_PRIVATE_EXPEDITED_SYNC_CORE>."

#. type: TP
#: man-pages/man2/membarrier.2:161
#, no-wrap
msgid "B<MEMBARRIER_CMD_SHARED> (since Linux 4.3)"
msgstr "B<MEMBARRIER_CMD_SHARED> (начиная с Linux 4.3)"

#. type: Plain text
#: man-pages/man2/membarrier.2:166
msgid ""
"This is an alias for B<MEMBARRIER_CMD_GLOBAL> that exists for header "
"backward compatibility."
msgstr "Псевдоним B<MEMBARRIER_CMD_GLOBAL>, существует для обратной совместимости в заголовке."

#. type: Plain text
#: man-pages/man2/membarrier.2:170
msgid "The I<flags> argument is currently unused and must be specified as 0."
msgstr "В настоящее время аргумент I<flags> не используется и должен равняться 0."

#. type: Plain text
#: man-pages/man2/membarrier.2:174
msgid ""
"All memory accesses performed in program order from each targeted thread are"
" guaranteed to be ordered with respect to B<membarrier>()."
msgstr "Все доступы к памяти, выполняемые в программном порядке из каждого целевого потока, гарантированно упорядочены в отношении B<membarrier>()."

#. type: Plain text
#: man-pages/man2/membarrier.2:188
msgid ""
"If we use the semantic I<barrier()> to represent a compiler barrier forcing "
"memory accesses to be performed in program order across the barrier, and "
"I<smp_mb()> to represent explicit memory barriers forcing full memory "
"ordering across the barrier, we have the following ordering table for each "
"pairing of I<barrier()>, B<membarrier>()  and I<smp_mb()>.  The pair "
"ordering is detailed as (O: ordered, X: not ordered):"
msgstr "Если использовать семантику I<barrier()> для представления барьера компилятора, обеспечивающего доступа к памяти, выполняемого в программном порядке для пересечения барьера, и I<smp_mb()> — для представления явных барьеров памяти, обеспечивающих полный упорядоченный доступ к памяти через барьер, то получится следующая упорядочивающая таблица для каждой пары I<barrier()>, B<membarrier>() и I<smp_mb()>. Наличие порядка в паре показано знаком (O: упорядочено, X: не упорядочено):"

#. type: Plain text
#: man-pages/man2/membarrier.2:193
#, no-wrap
msgid ""
"                       barrier()  smp_mb()  membarrier()\n"
"       barrier()          X          X          O\n"
"       smp_mb()           X          O          O\n"
"       membarrier()       O          O          O\n"
msgstr "                       barrier()  smp_mb()  membarrier()\n       barrier()          X          X          O\n       smp_mb()           X          O          O\n       membarrier()       O          O          O\n"

#. type: Plain text
#: man-pages/man2/membarrier.2:210
msgid ""
"On success, the B<MEMBARRIER_CMD_QUERY> operation returns a bit mask of "
"supported commands, and the B<MEMBARRIER_CMD_GLOBAL>, "
"B<MEMBARRIER_CMD_GLOBAL_EXPEDITED>, "
"B<MEMBARRIER_CMD_REGISTER_GLOBAL_EXPEDITED>, "
"B<MEMBARRIER_CMD_PRIVATE_EXPEDITED>, "
"B<MEMBARRIER_CMD_REGISTER_PRIVATE_EXPEDITED>, "
"B<MEMBARRIER_CMD_PRIVATE_EXPEDITED_SYNC_CORE>, and "
"B<MEMBARRIER_CMD_REGISTER_PRIVATE_EXPEDITED_SYNC_CORE> operations return "
"zero.  On error, -1 is returned, and I<errno> is set appropriately."
msgstr "При успешном выполнении операции B<MEMBARRIER_CMD_QUERY> возвращается битовая маска поддерживаемых команд, а операции B<MEMBARRIER_CMD_GLOBAL>, B<MEMBARRIER_CMD_GLOBAL_EXPEDITED>, B<MEMBARRIER_CMD_REGISTER_GLOBAL_EXPEDITED>, B<MEMBARRIER_CMD_PRIVATE_EXPEDITED>, B<MEMBARRIER_CMD_REGISTER_PRIVATE_EXPEDITED>, B<MEMBARRIER_CMD_PRIVATE_EXPEDITED_SYNC_CORE> и B<MEMBARRIER_CMD_REGISTER_PRIVATE_EXPEDITED_SYNC_CORE> возвращают ноль. При ошибке возвращается -1 и в I<errno> устанавливается соответствующее значение."

#. type: Plain text
#: man-pages/man2/membarrier.2:220
msgid ""
"For a given command, with I<flags> set to 0, this system call is guaranteed "
"to always return the same value until reboot.  Further calls with the same "
"arguments will lead to the same result.  Therefore, with I<flags> set to 0, "
"error handling is required only for the first call to B<membarrier>()."
msgstr "Для данной команды, если флаг I<flags> равен 0, то системный вызов всегда гарантирует возврат одного и того же значения до перезагрузки. Последующие вызовы с теми же аргументами всегда возвращают тот же результат. Поэтому, если I<flags> равен 0, то обработка ошибок требуется только при первом вызове B<membarrier>()."

#. type: Plain text
#: man-pages/man2/membarrier.2:235
msgid ""
"I<cmd> is invalid, or I<flags> is nonzero, or the B<MEMBARRIER_CMD_GLOBAL> "
"command is disabled because the I<nohz_full> CPU parameter has been set, or "
"the B<MEMBARRIER_CMD_PRIVATE_EXPEDITED_SYNC_CORE> and "
"B<MEMBARRIER_CMD_REGISTER_PRIVATE_EXPEDITED_SYNC_CORE> commands are not "
"implemented by the architecture."
msgstr "Неверное значение I<cmd>, значение I<flags> не равно нулю, отключена команда B<MEMBARRIER_CMD_GLOBAL>, так как указан параметр ЦП I<nohz_full> или команды B<MEMBARRIER_CMD_PRIVATE_EXPEDITED_SYNC_CORE> иB<MEMBARRIER_CMD_REGISTER_PRIVATE_EXPEDITED_SYNC_CORE> не реализованы для архитектуры."

#. type: Plain text
#: man-pages/man2/membarrier.2:240
msgid "The B<membarrier>()  system call is not implemented by this kernel."
msgstr "Системный вызов B<membarrier>() не реализован в данном ядре."

#. type: Plain text
#: man-pages/man2/membarrier.2:244
msgid ""
"The current process was not registered prior to using private expedited "
"commands."
msgstr "Текущий процесс не зарегистрирован до использования частных курируемых команд."

#. type: Plain text
#: man-pages/man2/membarrier.2:249
msgid "The B<membarrier>()  system call was added in Linux 4.3."
msgstr "Системный вызов B<membarrier>()  впервые появился в Linux версии 4.3."

#.  .SH SEE ALSO
#.  FIXME See if the following syscalls make it into Linux 4.15 or later
#.  .BR cpu_opv (2),
#.  .BR rseq (2)
#. type: Plain text
#: man-pages/man2/membarrier.2:256
msgid "B<membarrier>()  is Linux-specific."
msgstr "Вызов B<membarrier>() есть только в Linux."

#. type: Plain text
#: man-pages/man2/membarrier.2:265
msgid ""
"A memory barrier instruction is part of the instruction set of architectures"
" with weakly-ordered memory models.  It orders memory accesses prior to the "
"barrier and after the barrier with respect to matching barriers on other "
"cores.  For instance, a load fence can order loads prior to and following "
"that fence with respect to stores ordered by store fences."
msgstr "Инструкция барьера памяти является частью системы команд архитектуры со слабо упорядоченными моделями памяти. Она упорядочивает доступ к памяти до барьера и после барьера в соответствии совпадающими барьерами на других ядрах. Например, загрузка барьера (fence) может упорядочить загрузку до и после этого барьера в соответствии порядком хранилища, установленного барьерами хранилища."

#. type: Plain text
#: man-pages/man2/membarrier.2:268
msgid ""
"Program order is the order in which instructions are ordered in the program "
"assembly code."
msgstr "Программный порядок — это порядок, в котором инструкции упорядочены в ассемблерном коде программы."

#. type: Plain text
#: man-pages/man2/membarrier.2:273
msgid ""
"Examples where B<membarrier>()  can be useful include implementations of "
"Read-Copy-Update libraries and garbage collectors."
msgstr "Вызов B<membarrier>() может быть полезным для реализации библиотек чтения-копирования-обновления или сборщиков мусора."

#. type: Plain text
#: man-pages/man2/membarrier.2:278
msgid ""
"Assuming a multithreaded application where \"fast_path()\" is executed very "
"frequently, and where \"slow_path()\" is executed infrequently, the "
"following code (x86) can be transformed using B<membarrier>():"
msgstr "Предполагая, что в многонитевой программе «fast_path()» выполняется очень часто, а «slow_path()» — редко, следующий код (x86) можно преобразовать используя B<membarrier>():"

#. type: Plain text
#: man-pages/man2/membarrier.2:282
#, no-wrap
msgid "#include E<lt>stdlib.hE<gt>\n"
msgstr "#include E<lt>stdlib.hE<gt>\n"

#. type: Plain text
#: man-pages/man2/membarrier.2:284 man-pages/man2/membarrier.2:342
#, no-wrap
msgid "static volatile int a, b;\n"
msgstr "static volatile int a, b;\n"

#. type: Plain text
#: man-pages/man2/membarrier.2:292
#, no-wrap
msgid ""
"static void\n"
"fast_path(int *read_b)\n"
"{\n"
"    a = 1;\n"
"    asm volatile (\"mfence\" : : : \"memory\");\n"
"    *read_b = b;\n"
"}\n"
msgstr "static void\nfast_path(int *read_b)\n{\n    a = 1;\n    asm volatile (\"mfence\" : : : \"memory\");\n    *read_b = b;\n}\n"

#. type: Plain text
#: man-pages/man2/membarrier.2:300
#, no-wrap
msgid ""
"static void\n"
"slow_path(int *read_a)\n"
"{\n"
"    b = 1;\n"
"    asm volatile (\"mfence\" : : : \"memory\");\n"
"    *read_a = a;\n"
"}\n"
msgstr "static void\nslow_path(int *read_a)\n{\n    b = 1;\n    asm volatile (\"mfence\" : : : \"memory\");\n    *read_a = a;\n}\n"

#. type: Plain text
#: man-pages/man2/membarrier.2:305 man-pages/man2/membarrier.2:391
#, no-wrap
msgid ""
"int\n"
"main(int argc, char **argv)\n"
"{\n"
"    int read_a, read_b;\n"
msgstr "int\nmain(int argc, char **argv)\n{\n    int read_a, read_b;\n"

#. type: Plain text
#: man-pages/man2/membarrier.2:311 man-pages/man2/membarrier.2:400
#, no-wrap
msgid ""
"    /*\n"
"     * Real applications would call fast_path() and slow_path()\n"
"     * from different threads. Call those from main() to keep\n"
"     * this example short.\n"
"     */\n"
msgstr "    /*\n     * В реальных приложениях вызовы fast_path() и slow_path()\n     * были бы в разных нитях. Их вызов из main() сделан только\n     * для укорачивания данного примера.\n     */\n"

#. type: Plain text
#: man-pages/man2/membarrier.2:314 man-pages/man2/membarrier.2:403
#, no-wrap
msgid ""
"    slow_path(&read_a);\n"
"    fast_path(&read_b);\n"
msgstr "    slow_path(&read_a);\n    fast_path(&read_b);\n"

#. type: Plain text
#: man-pages/man2/membarrier.2:319 man-pages/man2/membarrier.2:408
#, no-wrap
msgid ""
"    /*\n"
"     * read_b == 0 implies read_a == 1 and\n"
"     * read_a == 0 implies read_b == 1.\n"
"     */\n"
msgstr "    /*\n     * read_b == 0 подразумевает read_a == 1 и\n     * read_a == 0 подразумевает read_b == 1.\n     */\n"

#. type: Plain text
#: man-pages/man2/membarrier.2:322 man-pages/man2/membarrier.2:411
#, no-wrap
msgid ""
"    if (read_b == 0 && read_a == 0)\n"
"        abort();\n"
msgstr "    if (read_b == 0 && read_a == 0)\n        abort();\n"

#. type: Plain text
#: man-pages/man2/membarrier.2:331
msgid "The code above transformed to use B<membarrier>()  becomes:"
msgstr "Этот же код, переписанный с использованием B<membarrier>():"

#. type: Plain text
#: man-pages/man2/membarrier.2:340
#, no-wrap
msgid ""
"#define _GNU_SOURCE\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>sys/syscall.hE<gt>\n"
"#include E<lt>linux/membarrier.hE<gt>\n"
msgstr "#define _GNU_SOURCE\n#include E<lt>stdlib.hE<gt>\n#include E<lt>stdio.hE<gt>\n#include E<lt>unistd.hE<gt>\n#include E<lt>sys/syscall.hE<gt>\n#include E<lt>linux/membarrier.hE<gt>\n"

#. type: Plain text
#: man-pages/man2/membarrier.2:348
#, no-wrap
msgid ""
"static int\n"
"membarrier(int cmd, int flags)\n"
"{\n"
"    return syscall(__NR_membarrier, cmd, flags);\n"
"}\n"
msgstr "static int\nmembarrier(int cmd, int flags)\n{\n    return syscall(__NR_membarrier, cmd, flags);\n}\n"

#. type: Plain text
#: man-pages/man2/membarrier.2:353
#, no-wrap
msgid ""
"static int\n"
"init_membarrier(void)\n"
"{\n"
"    int ret;\n"
msgstr "static int\ninit_membarrier(void)\n{\n    int ret;\n"

#. type: Plain text
#: man-pages/man2/membarrier.2:355
#, no-wrap
msgid "    /* Check that membarrier() is supported. */\n"
msgstr "    /* Проверка поддержки в функции membarrier() */\n"

#. type: Plain text
#: man-pages/man2/membarrier.2:361
#, no-wrap
msgid ""
"    ret = membarrier(MEMBARRIER_CMD_QUERY, 0);\n"
"    if (ret E<lt> 0) {\n"
"        perror(\"membarrier\");\n"
"        return -1;\n"
"    }\n"
msgstr "    ret = membarrier(MEMBARRIER_CMD_QUERY, 0);\n    if (ret E<lt> 0) {\n        perror(\"membarrier\");\n        return -1;\n    }\n"

#. type: Plain text
#: man-pages/man2/membarrier.2:367
#, no-wrap
msgid ""
"    if (!(ret & MEMBARRIER_CMD_GLOBAL)) {\n"
"        fprintf(stderr,\n"
"            \"membarrier does not support MEMBARRIER_CMD_GLOBAL\\en\");\n"
"        return -1;\n"
"    }\n"
msgstr "    if (!(ret & MEMBARRIER_CMD_GLOBAL)) {\n        fprintf(stderr,\n            \"membarrier не поддерживает MEMBARRIER_CMD_GLOBAL\\en\");\n        return -1;\n    }\n"

#. type: Plain text
#: man-pages/man2/membarrier.2:370
#, no-wrap
msgid ""
"    return 0;\n"
"}\n"
msgstr "    return 0;\n}\n"

#. type: Plain text
#: man-pages/man2/membarrier.2:378
#, no-wrap
msgid ""
"static void\n"
"fast_path(int *read_b)\n"
"{\n"
"    a = 1;\n"
"    asm volatile (\"\" : : : \"memory\");\n"
"    *read_b = b;\n"
"}\n"
msgstr "static void\nfast_path(int *read_b)\n{\n    a = 1;\n    asm volatile (\"\" : : : \"memory\");\n    *read_b = b;\n}\n"

#. type: Plain text
#: man-pages/man2/membarrier.2:386
#, no-wrap
msgid ""
"static void\n"
"slow_path(int *read_a)\n"
"{\n"
"    b = 1;\n"
"    membarrier(MEMBARRIER_CMD_GLOBAL, 0);\n"
"    *read_a = a;\n"
"}\n"
msgstr "static void\nslow_path(int *read_a)\n{\n    b = 1;\n    membarrier(MEMBARRIER_CMD_GLOBAL, 0);\n    *read_a = a;\n}\n"

#. type: Plain text
#: man-pages/man2/membarrier.2:394
#, no-wrap
msgid ""
"    if (init_membarrier())\n"
"        exit(EXIT_FAILURE);\n"
msgstr "    if (init_membarrier())\n        exit(EXIT_FAILURE);\n"

#. type: TH
#: man-pages/man2/mincore.2:34
#, no-wrap
msgid "MINCORE"
msgstr "MINCORE"

#. type: Plain text
#: man-pages/man2/mincore.2:37
msgid "mincore - determine whether pages are resident in memory"
msgstr "mincore - определяет, хранятся ли страницы в памяти"

#. type: Plain text
#: man-pages/man2/mincore.2:39
msgid "B<#include E<lt>unistd.hE<gt>>"
msgstr "B<#include E<lt>unistd.hE<gt>>"

#. type: Plain text
#: man-pages/man2/mincore.2:43
msgid ""
"B<int mincore(void *>I<addr>B<, size_t >I<length>B<, unsigned char "
"*>I<vec>B<);>"
msgstr "B<int mincore(void *>I<addr>B<, size_t >I<length>B<, unsigned char *>I<vec>B<);>"

#. type: Plain text
#: man-pages/man2/mincore.2:54
#, no-wrap
msgid ""
"B<mincore>():\n"
"    Since glibc 2.19:\n"
"        _DEFAULT_SOURCE\n"
"    Glibc 2.19 and earlier:\n"
"        _BSD_SOURCE || _SVID_SOURCE\n"
msgstr "B<mincore>():\n    начиная с glibc 2.19:\n        _DEFAULT_SOURCE\n    в glibc 2.19 и старее:\n        _BSD_SOURCE || _SVID_SOURCE\n"

#. type: Plain text
#: man-pages/man2/mincore.2:65
msgid ""
"B<mincore>()  returns a vector that indicates whether pages of the calling "
"process's virtual memory are resident in core (RAM), and so will not cause a"
" disk access (page fault) if referenced.  The kernel returns residency "
"information about the pages starting at the address I<addr>, and continuing "
"for I<length> bytes."
msgstr "B<mincore>() возвращает вектор, описывающий страницы виртуальной памяти вызывающего процесса, которые находятся в физической памяти (core, RAM) и поэтому доступ к ним не приводит к обращению к дискам. Ядро возвращает информацию о страницах, которые расположены начиная с адреса I<addr> и занимают I<length> байт."

#. type: Plain text
#: man-pages/man2/mincore.2:79
msgid ""
"The I<addr> argument must be a multiple of the system page size.  The "
"I<length> argument need not be a multiple of the page size, but since "
"residency information is returned for whole pages, I<length> is effectively "
"rounded up to the next multiple of the page size.  One may obtain the page "
"size (B<PAGE_SIZE>)  using I<sysconf(_SC_PAGESIZE)>."
msgstr "Значение аргумента I<addr> должно быть кратно размеру системной страницы. Значение аргумента I<length> может быть не кратно размеру страницы, но так как возвращается информация по целым страницам, I<length> округляется до следующего значения, кратного размеру страницы. Размер страницы (B<PAGE_SIZE>) может быть получен с помощью I<sysconf(_SC_PAGESIZE)>."

#. type: Plain text
#: man-pages/man2/mincore.2:97
msgid ""
"The I<vec> argument must point to an array containing at least "
"I<(length+PAGE_SIZE-1) / PAGE_SIZE> bytes.  On return, the least significant"
" bit of each byte will be set if the corresponding page is currently "
"resident in memory, and be clear otherwise.  (The settings of the other bits"
" in each byte are undefined; these bits are reserved for possible later "
"use.)  Of course the information returned in I<vec> is only a snapshot: "
"pages that are not locked in memory can come and go at any moment, and the "
"contents of I<vec> may already be stale by the time this call returns."
msgstr "Аргумент I<vec> должен указывать на массив размером не менее I<(length+PAGE_SIZE-1) / PAGE_SIZE> байт. При возврате самый младший значимый бит каждого байта будет установлен, если соответствующая страница находится в памяти, и будет сброшен, если это не так. (Значения других битов каждого байта не определено; эти биты зарезервированы для использования в будущем.) Естественно, информация, возвращаемая в I<vec>, носит моментальный характер: страницы, которые не заблокированы в памяти, могут быть удалены из неё или добавлены в любой момент, и содержимое I<vec> может стать неактуальным уже на момент возврата из вызова."

#. type: Plain text
#: man-pages/man2/mincore.2:104
msgid ""
"On success, B<mincore>()  returns zero.  On error, -1 is returned, and "
"I<errno> is set appropriately."
msgstr "При нормальном завершении работы B<mincore>()  возвращает ноль. При ошибках возвращается -1, а переменной I<errno> присваивается соответствующее значение."

#. type: Plain text
#: man-pages/man2/mincore.2:107
msgid "B<EAGAIN> kernel is temporarily out of resources."
msgstr "B<EAGAIN> ядру временно не хватает ресурсов."

#. type: Plain text
#: man-pages/man2/mincore.2:111
msgid "I<vec> points to an invalid address."
msgstr "I<vec> указывает на неправильный адрес."

#. type: Plain text
#: man-pages/man2/mincore.2:115
msgid "I<addr> is not a multiple of the page size."
msgstr "Значение I<addr> не кратно размеру страницы."

#. type: Plain text
#: man-pages/man2/mincore.2:127
msgid ""
"I<length> is greater than (I<TASK_SIZE> - I<addr>).  (This could occur if a "
"negative value is specified for I<length>, since that value will be "
"interpreted as a large unsigned integer.)  In Linux 2.6.11 and earlier, the "
"error B<EINVAL> was returned for this condition."
msgstr "Значение I<length> больше чем (I<TASK_SIZE> - I<addr>). (Это может произойти, если в I<length> указано отрицательное значение, так как это значение воспринимается как большое беззнаковое целое.) В Linux 2.6.11 и более ранних версиях в этом случае возвращалась ошибка B<EINVAL>."

#. type: Plain text
#: man-pages/man2/mincore.2:135
msgid "I<addr> to I<addr> + I<length> contained unmapped memory."
msgstr "С адреса I<addr> по адрес I<addr> + I<length> содержится память без отображения."

#. type: Plain text
#: man-pages/man2/mincore.2:137
msgid "Available since Linux 2.3.99pre1 and glibc 2.2."
msgstr "Доступен начиная с Linux 2.3.99pre1 и glibc 2.2."

#.  It is on at least NetBSD, FreeBSD, OpenBSD, Solaris 8,
#.  AIX 5.1, SunOS 4.1
#.  .SH HISTORY
#.  The
#.  .BR mincore ()
#.  function first appeared in 4.4BSD.
#. type: Plain text
#: man-pages/man2/mincore.2:147
msgid ""
"B<mincore>()  is not specified in POSIX.1, and it is not available on all "
"UNIX implementations."
msgstr "Системный вызов B<mincore>() не определён в стандарте POSIX.1 и отсутствует во всех реализациях UNIX."

#.  Linux (up to now, 2.6.5),
#.  .B mincore
#.  does not return correct information for MAP_PRIVATE mappings:
#.  for a MAP_PRIVATE file mapping,
#.  .B mincore
#.  returns the residency of the file pages, rather than any
#.  modified process-private pages that have been copied on write;
#.  for a MAP_PRIVATE mapping of
#.  .IR /dev/zero ,
#.  .B mincore
#.  always reports pages as nonresident;
#.  and for a MAP_PRIVATE, MAP_ANONYMOUS mapping,
#.  .B mincore
#.  always fails with the error
#.  .BR ENOMEM .
#. type: Plain text
#: man-pages/man2/mincore.2:169
msgid ""
"Before kernel 2.6.21, B<mincore>()  did not return correct information for "
"B<MAP_PRIVATE> mappings, or for nonlinear mappings (established using "
"B<remap_file_pages>(2))."
msgstr "До ядра версии 2.6.21, B<mincore>() не возвращал правильные данные для отображений B<MAP_PRIVATE> или для нелинейных отображений (заданных с помощью B<remap_file_pages>(2))."

#. type: Plain text
#: man-pages/man2/mincore.2:175
msgid ""
"B<fincore>(1), B<madvise>(2), B<mlock>(2), B<mmap>(2), B<posix_fadvise>(2), "
"B<posix_madvise>(3)"
msgstr "B<fincore>(1), B<madvise>(2), B<mlock>(2), B<mmap>(2), B<posix_fadvise>(2), B<posix_madvise>(3)"

#. type: TH
#: man-pages/man2/mprotect.2:33
#, no-wrap
msgid "MPROTECT"
msgstr "MPROTECT"

#. type: Plain text
#: man-pages/man2/mprotect.2:36
msgid "mprotect, pkey_mprotect - set protection on a region of memory"
msgstr "mprotect, pkey_mprotect - контролирует доступ к области памяти"

#. type: Plain text
#: man-pages/man2/mprotect.2:41
#, no-wrap
msgid "B<int mprotect(void *>I<addr>B<, size_t >I<len>B<, int >I<prot>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/mprotect.2:44
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>             /* See feature_test_macros(7) */\n"
"B<#include E<lt>sys/mman.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/mprotect.2:46
#, no-wrap
msgid ""
"B<int pkey_mprotect(void *>I<addr>B<, size_t >I<len>B<, int >I<prot>B<, int "
">I<pkey>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/mprotect.2:54
msgid ""
"B<mprotect>()  changes the access protections for the calling process's "
"memory pages containing any part of the address range in the interval "
"[I<addr>,\\ I<addr>+I<len>-1].  I<addr> must be aligned to a page boundary."
msgstr "Вызов B<mprotect>() изменяет параметры доступа страниц памяти вызывающего процесса, которые содержатся, даже частично, в адресном диапазоне [I<addr>,\\ I<addr>+I<len>-1]. Значение I<addr> должно быть выровнено на границу страницы."

#. type: Plain text
#: man-pages/man2/mprotect.2:59
msgid ""
"If the calling process tries to access memory in a manner that violates the "
"protections, then the kernel generates a B<SIGSEGV> signal for the process."
msgstr "Если вызывающий процесс нарушает защиту доступа к памяти, то ядро посылает процессу сигнал B<SIGSEGV>."

#. type: Plain text
#: man-pages/man2/mprotect.2:64
msgid ""
"I<prot> is a combination of the following access flags: B<PROT_NONE> or a "
"bitwise-or of the other values in the following list:"
msgstr "Значение I<prot> представляет собой комбинацию следующих флагов доступа: B<PROT_NONE> или побитово сложенные другие значения из следующего списка:"

#. type: Plain text
#: man-pages/man2/mprotect.2:67
msgid "The memory cannot be accessed at all."
msgstr "Доступ к памяти запрещён."

#. type: Plain text
#: man-pages/man2/mprotect.2:70
msgid "The memory can be read."
msgstr "Память можно читать."

#. type: Plain text
#: man-pages/man2/mprotect.2:73
msgid "The memory can be modified."
msgstr "Память можно изменять."

#. type: Plain text
#: man-pages/man2/mprotect.2:76
msgid "The memory can be executed."
msgstr "Память можно выполнять."

#. type: TP
#: man-pages/man2/mprotect.2:76
#, no-wrap
msgid "B<PROT_SEM> (since Linux 2.5.7)"
msgstr "B<PROT_SEM> (начиная с Linux 2.5.7)"

#. type: Plain text
#: man-pages/man2/mprotect.2:85
msgid ""
"The memory can be used for atomic operations.  This flag was introduced as "
"part of the B<futex>(2)  implementation (in order to guarantee the ability "
"to perform atomic operations required by commands such as B<FUTEX_WAIT>), "
"but is not currently used in on any architecture."
msgstr "Память можно использовать для атомарных операций. Этот флаг появился как часть реализации B<futex>(2) (для гарантии способности выполнять атомарные операции, требуемые таким командам как B<FUTEX_WAIT>), но пока не используется ни в одной архитектуре."

#. type: TP
#: man-pages/man2/mprotect.2:85
#, no-wrap
msgid "B<PROT_SAO> (since Linux 2.6.26)"
msgstr "B<PROT_SAO> (начиная с Linux 2.6.26)"

#.  commit aba46c5027cb59d98052231b36efcbbde9c77a1d
#.  commit ef3d3246a0d06be622867d21af25f997aeeb105f
#. type: Plain text
#: man-pages/man2/mprotect.2:94
msgid ""
"The memory should have strong access ordering.  This feature is specific to "
"the PowerPC architecture (version 2.06 of the architecture specification "
"adds the SAO CPU feature, and it is available on POWER 7 or PowerPC A2, for "
"example)."
msgstr "Память должна иметь строгий порядок доступа. Это свойство есть только в архитектуре PowerPC (в спецификации архитектуры версии 2.06 добавлено свойство ЦП SAO и оно доступно, например, на POWER 7 или PowerPC A2)."

#. type: Plain text
#: man-pages/man2/mprotect.2:98
msgid ""
"Additionally (since Linux 2.6.0), I<prot> can have one of the following "
"flags set:"
msgstr "Также (начиная с Linux 2.6.0), I<prot> может содержать один из следующих установленных флагов:"

#.  mm/mmap.c:
#. 	vm_flags |= calc_vm_prot_bits(prot, pkey) | calc_vm_flag_bits(flags) |
#. 			mm->def_flags | VM_MAYREAD | VM_MAYWRITE | VM_MAYEXEC;
#.  And calc_vm_flag_bits converts only GROWSDOWN/DENYWRITE/LOCKED.
#. type: TP
#: man-pages/man2/mprotect.2:98
#, no-wrap
msgid "B<PROT_GROWSUP>"
msgstr "B<PROT_GROWSUP>"

#.  The VMA is one that was marked with VM_GROWSUP by the kernel
#.  when the stack was created. Note that (unlike VM_GROWSDOWN),
#.  there is no mmap() flag (analogous to MAP_GROWSDOWN) for
#.  creating a VMA that is marked VM_GROWSUP.
#. type: Plain text
#: man-pages/man2/mprotect.2:113
msgid ""
"Apply the protection mode up to the end of a mapping that grows upwards.  "
"(Such mappings are created for the stack area on architectures\\(emfor "
"example, HP-PARISC\\(emthat have an upwardly growing stack.)"
msgstr "Применить режим защиты до конца отображения, которое растёт вверх (такие отображения создаются для области стека например в архитектуре HP-PARISC, где стек растёт вверх)."

#. type: TP
#: man-pages/man2/mprotect.2:113
#, no-wrap
msgid "B<PROT_GROWSDOWN>"
msgstr "B<PROT_GROWSDOWN>"

#. type: Plain text
#: man-pages/man2/mprotect.2:120
msgid ""
"Apply the protection mode down to the beginning of a mapping that grows "
"downward (which should be a stack segment or a segment mapped with the "
"B<MAP_GROWSDOWN> flag set)."
msgstr "Применить режим защиты до начала отображения, которое растёт вниз (которое должно быть сегментом стека или сегментом, отображённым с установленным флагом B<MAP_GROWSDOWN>)."

#. type: Plain text
#: man-pages/man2/mprotect.2:139
msgid ""
"Like B<mprotect>(), B<pkey_mprotect>()  changes the protection on the pages "
"specified by I<addr> and I<len>.  The I<pkey> argument specifies the "
"protection key (see B<pkeys>(7))  to assign to the memory.  The protection "
"key must be allocated with B<pkey_alloc>(2)  before it is passed to "
"B<pkey_mprotect>().  For an example of the use of this system call, see "
"B<pkeys>(7)."
msgstr "Подобно B<mprotect>(), вызов B<pkey_mprotect>() изменяет защиту страниц, указанных I<addr> и I<len>. Аргумент I<pkey> содержит ключ защиты (смотрите B<pkeys>(7)), назначаемый памяти. Ключ защиты должен быть выделен с помощью B<pkey_alloc>(2) до передачи в B<pkey_mprotect>(). Пример использования этого системного вызова смотрите в B<pkeys>(7)."

#. type: Plain text
#: man-pages/man2/mprotect.2:148
msgid ""
"On success, B<mprotect>()  and B<pkey_mprotect>()  return zero.  On error, "
"these system calls return -1, and I<errno> is set appropriately."
msgstr "При успешном выполнении B<mprotect>() и B<pkey_mprotect>() возвращают 0. В случае ошибки возвращается -1, а I<errno> устанавливается в соответствующее значение."

#. type: Plain text
#: man-pages/man2/mprotect.2:158
msgid ""
"The memory cannot be given the specified access.  This can happen, for "
"example, if you B<mmap>(2)  a file to which you have read-only access, then "
"ask B<mprotect>()  to mark it B<PROT_WRITE>."
msgstr "Нельзя задать этот вид доступа. Например, это может случиться, если при вызове B<mmap>(2) файл доступен только на чтение, а запрос B<mprotect>() был B<PROT_WRITE>."

#. type: Plain text
#: man-pages/man2/mprotect.2:162
msgid ""
"I<addr> is not a valid pointer, or not a multiple of the system page size."
msgstr "Значение I<addr> не является правильным указателем или не кратен размеру системной страницы."

#. type: Plain text
#: man-pages/man2/mprotect.2:167
msgid ""
"(B<pkey_mprotect>())  I<pkey> has not been allocated with B<pkey_alloc>(2)"
msgstr "(B<pkey_mprotect>())  I<pkey> не был выделен с помощью B<pkey_alloc>(2)."

#. type: Plain text
#: man-pages/man2/mprotect.2:175
msgid "Both B<PROT_GROWSUP> and B<PROT_GROWSDOWN> were specified in I<prot>."
msgstr "В I<prot> указаны оба флага, B<PROT_GROWSUP> и B<PROT_GROWSDOWN>."

#. type: Plain text
#: man-pages/man2/mprotect.2:179
msgid "Invalid flags specified in I<prot>."
msgstr "Указано неверное значение в I<prot>."

#. type: Plain text
#: man-pages/man2/mprotect.2:186
msgid ""
"(PowerPC architecture)  B<PROT_SAO> was specified in I<prot>, but SAO "
"hardware feature is not available."
msgstr "(архитектура PowerPC ) В I<prot> указан B<PROT_SAO>, но недоступно аппаратное свойство SAO."

#. type: Plain text
#: man-pages/man2/mprotect.2:189
msgid "Internal kernel structures could not be allocated."
msgstr "Не удалось выделить место под внутренние структуры ядра."

#. type: Plain text
#: man-pages/man2/mprotect.2:199
msgid ""
"Addresses in the range [I<addr>, I<addr>+I<len>-1] are invalid for the "
"address space of the process, or specify one or more pages that are not "
"mapped.  (Before kernel 2.4.19, the error B<EFAULT> was incorrectly produced"
" for these cases.)"
msgstr "Адреса в диапазоне [I<addr>, I<addr>+I<len>-1] некорректны для адресного пространства процесса, или одна или более указанных страниц не отображена (до ядра версии 2.4.19 в этих случаях некорректно возвращалась ошибка B<EFAULT>)."

#.  I.e., the number of VMAs would exceed the 64 kB maximum
#. type: Plain text
#: man-pages/man2/mprotect.2:211
msgid ""
"Changing the protection of a memory region would result in the total number "
"of mappings with distinct attributes (e.g., read versus read/write "
"protection)  exceeding the allowed maximum.  (For example, making the "
"protection of a range B<PROT_READ> in the middle of a region currently "
"protected as B<PROT_READ|PROT_WRITE> would result in three mappings: two "
"read/write mappings at each end and a read-only mapping in the middle.)"
msgstr "Изменение защиты области памяти привело бы к превышению разрешённого максимума на количество отображений с различающимися атрибутами (защита на чтение и на чтение/запись). Например, защита диапазона B<PROT_READ> в середине области, которая сейчас защищена B<PROT_READ|PROT_WRITE>, привела бы к трём отображениям: два отображения на концах, доступных на чтение/запись и доступное только для чтение отображение посередине."

#. type: Plain text
#: man-pages/man2/mprotect.2:215
msgid ""
"B<pkey_mprotect>()  first appeared in Linux 4.9; library support was added "
"in glibc 2.27."
msgstr "Вызов B<pkey_mprotect>() впервые появился в Linux 4.9; поддержка в библиотеке glibc добавлена в версии 2.27."

#.  SVr4 defines an additional error
#.  code EAGAIN. The SVr4 error conditions don't map neatly onto Linux's.
#. type: Plain text
#: man-pages/man2/mprotect.2:225
msgid ""
"B<mprotect>(): POSIX.1-2001, POSIX.1-2008, SVr4.  POSIX says that the "
"behavior of B<mprotect>()  is unspecified if it is applied to a region of "
"memory that was not obtained via B<mmap>(2)."
msgstr "B<mprotect>(): В POSIX.1-2001, POSIX.1-2008,  SVr4 сказано, что поведение B<mprotect>() не определено, если переданная область памяти не получена через B<mmap>(2)."

#. type: Plain text
#: man-pages/man2/mprotect.2:228
msgid "B<pkey_mprotect>()  is a nonportable Linux extension."
msgstr "Вызов B<pkey_mprotect> является непереносимым расширением Linux."

#. type: Plain text
#: man-pages/man2/mprotect.2:235
msgid ""
"On Linux, it is always permissible to call B<mprotect>()  on any address in "
"a process's address space (except for the kernel vsyscall area).  In "
"particular, it can be used to change existing code mappings to be writable."
msgstr "В Linux всегда можно вызвать B<mprotect>() с любым адресом из адресного пространства процесса (за исключением области ядра vsyscall). В частности, это можно использовать для изменения отображений существующего кода на записываемые."

#. type: Plain text
#: man-pages/man2/mprotect.2:249
msgid ""
"Whether B<PROT_EXEC> has any effect different from B<PROT_READ> depends on "
"processor architecture, kernel version, and process state.  If "
"B<READ_IMPLIES_EXEC> is set in the process's personality flags (see "
"B<personality>(2)), specifying B<PROT_READ> will implicitly add "
"B<PROT_EXEC>."
msgstr "Отличается ли действие B<PROT_EXEC> от B<PROT_READ> зависит от архитектуры процессора, версии ядра и состояния процесса. Если в флагах специализаций процессора установлен B<READ_IMPLIES_EXEC> (смотрите B<personality>(2)), то указание B<PROT_READ> подразумевает добавление B<PROT_EXEC>."

#. type: Plain text
#: man-pages/man2/mprotect.2:254
msgid ""
"On some hardware architectures (e.g., i386), B<PROT_WRITE> implies "
"B<PROT_READ>."
msgstr "На некоторых аппаратных архитектурах (например, i386) B<PROT_WRITE> подразумевает B<PROT_READ>."

#. type: Plain text
#: man-pages/man2/mprotect.2:263
msgid ""
"POSIX.1 says that an implementation may permit access other than that "
"specified in I<prot>, but at a minimum can allow write access only if "
"B<PROT_WRITE> has been set, and must not allow any access if B<PROT_NONE> "
"has been set."
msgstr "В POSIX.1 сказано, что реализация может разрешить доступ отличный от указанного в I<prot>, но для доступа на запись должен быть обязательно установлен флаг B<PROT_WRITE>, и любой доступ должен быть запрещён, если установлен флаг B<PROT_NONE>."

#. type: Plain text
#: man-pages/man2/mprotect.2:276
msgid ""
"Applications should be careful when mixing use of B<mprotect>()  and "
"B<pkey_mprotect>().  On x86, when B<mprotect>()  is used with I<prot> set to"
" B<PROT_EXEC> a pkey is may be allocated and set on the memory implicitly by"
" the kernel, but only when the pkey was 0 previously."
msgstr "В приложениях нужно осторожно использовать B<mprotect>() и B<pkey_mprotect>() вместе. На x86, если B<mprotect>() используется с установленным в I<prot> значением  B<PROT_EXEC>, то pkey может быть выделен и установлен ядром в память неявным образом, но только если до этого pkey был равен 0."

#. type: Plain text
#: man-pages/man2/mprotect.2:286
msgid ""
"On systems that do not support protection keys in hardware, "
"B<pkey_mprotect>()  may still be used, but I<pkey> must be set to -1.  When "
"called this way, the operation of B<pkey_mprotect>()  is equivalent to "
"B<mprotect>()."
msgstr ""

#. type: Plain text
#: man-pages/man2/mprotect.2:294
msgid ""
"The program below demonstrates the use of B<mprotect>().  The program "
"allocates four pages of memory, makes the third of these pages read-only, "
"and then executes a loop that walks upward through the allocated region "
"modifying bytes."
msgstr "Программа, представленная далее, показывает использование B<mprotect>(). Она выделяет четыре страницы памяти, делает третью доступной только на чтение, а затем запускает цикл, который проходит по выделенной области, меняя байты."

#. type: Plain text
#: man-pages/man2/mprotect.2:297
msgid ""
"An example of what we might see when running the program is the following:"
msgstr "Результат работы программы:"

#. type: Plain text
#: man-pages/man2/mprotect.2:303
#, no-wrap
msgid ""
"$B< ./a.out>\n"
"Start of region:        0x804c000\n"
"Got SIGSEGV at address: 0x804e000\n"
msgstr "$B< ./a.out>\nНачало области:             0x804c000\nПолучен SIGSEGV при адресе: 0x804e000\n"

#. type: Plain text
#: man-pages/man2/mprotect.2:315
#, no-wrap
msgid ""
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>signal.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>malloc.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"
"#include E<lt>sys/mman.hE<gt>\n"
msgstr "#include E<lt>unistd.hE<gt>\n#include E<lt>signal.hE<gt>\n#include E<lt>stdio.hE<gt>\n#include E<lt>malloc.hE<gt>\n#include E<lt>stdlib.hE<gt>\n#include E<lt>errno.hE<gt>\n#include E<lt>sys/mman.hE<gt>\n"

#. type: Plain text
#: man-pages/man2/mprotect.2:320
#, no-wrap
msgid "static char *buffer;\n"
msgstr "static char *buffer;\n"

#. type: Plain text
#: man-pages/man2/mprotect.2:329
#, no-wrap
msgid ""
"static void\n"
"handler(int sig, siginfo_t *si, void *unused)\n"
"{\n"
"    /* Note: calling printf() from a signal handler is not safe\n"
"       (and should not be done in production programs), since\n"
"       printf() is not async-signal-safe; see signal-safety(7).\n"
"       Nevertheless, we use printf() here as a simple way of\n"
"       showing that the handler was called. */\n"
msgstr "static void\nhandler(int sig, siginfo_t *si, void *unused)\n{\n    /* Замечание: вызов printf() из обработчика сигнала небезопасен\n       (и не должен выполняться в готовых программах), так как\n       printf() не async-signal-safe; смотрите signal-safety(7).\n       Тем не менее, здесь мы используем printf(), так как это простой\n       способ показать когда вызывается обработчик. */\n"

#. type: Plain text
#: man-pages/man2/mprotect.2:334
#, no-wrap
msgid ""
"    printf(\"Got SIGSEGV at address: 0x%lx\\en\",\n"
"            (long) si-E<gt>si_addr);\n"
"    exit(EXIT_FAILURE);\n"
"}\n"
msgstr "    printf(\"Получен SIGSEGV при адресе: 0x%lx\\en\",\n            (long) si-E<gt>si_addr);\n    exit(EXIT_FAILURE);\n}\n"

#. type: Plain text
#: man-pages/man2/mprotect.2:341
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    char *p;\n"
"    int pagesize;\n"
"    struct sigaction sa;\n"
msgstr "int\nmain(int argc, char *argv[])\n{\n    char *p;\n    int pagesize;\n    struct sigaction sa;\n"

#. type: Plain text
#: man-pages/man2/mprotect.2:347
#, no-wrap
msgid ""
"    sa.sa_flags = SA_SIGINFO;\n"
"    sigemptyset(&sa.sa_mask);\n"
"    sa.sa_sigaction = handler;\n"
"    if (sigaction(SIGSEGV, &sa, NULL) == -1)\n"
"        handle_error(\"sigaction\");\n"
msgstr "    sa.sa_flags = SA_SIGINFO;\n    sigemptyset(&sa.sa_mask);\n    sa.sa_sigaction = handler;\n    if (sigaction(SIGSEGV, &sa, NULL) == -1)\n        handle_error(\"sigaction\");\n"

#. type: Plain text
#: man-pages/man2/mprotect.2:351
#, no-wrap
msgid ""
"    pagesize = sysconf(_SC_PAGE_SIZE);\n"
"    if (pagesize == -1)\n"
"        handle_error(\"sysconf\");\n"
msgstr "    pagesize = sysconf(_SC_PAGE_SIZE);\n    if (pagesize == -1)\n        handle_error(\"sysconf\");\n"

#. type: Plain text
#: man-pages/man2/mprotect.2:354
#, no-wrap
msgid ""
"    /* Allocate a buffer aligned on a page boundary;\n"
"       initial protection is PROT_READ | PROT_WRITE */\n"
msgstr "    /* выделить буфер с выравниванием на границу страницы;\n       начальная защита: PROT_READ | PROT_WRITE */\n"

#. type: Plain text
#: man-pages/man2/mprotect.2:358
#, no-wrap
msgid ""
"    buffer = memalign(pagesize, 4 * pagesize);\n"
"    if (buffer == NULL)\n"
"        handle_error(\"memalign\");\n"
msgstr "    buffer = memalign(pagesize, 4 * pagesize);\n    if (buffer == NULL)\n        handle_error(\"memalign\");\n"

#. type: Plain text
#: man-pages/man2/mprotect.2:360
#, no-wrap
msgid "    printf(\"Start of region:        0x%lx\\en\", (long) buffer);\n"
msgstr "    printf(\"Начало области:             0x%lx\\en\", (long) buffer);\n"

#. type: Plain text
#: man-pages/man2/mprotect.2:364
#, no-wrap
msgid ""
"    if (mprotect(buffer + pagesize * 2, pagesize,\n"
"                PROT_READ) == -1)\n"
"        handle_error(\"mprotect\");\n"
msgstr "    if (mprotect(buffer + pagesize * 2, pagesize,\n                PROT_READ) == -1)\n        handle_error(\"mprotect\");\n"

#. type: Plain text
#: man-pages/man2/mprotect.2:367
#, no-wrap
msgid ""
"    for (p = buffer ; ; )\n"
"        *(p++) = \\(aqa\\(aq;\n"
msgstr "    for (p = buffer ; ; )\n        *(p++) = \\(aqa\\(aq;\n"

#. type: Plain text
#: man-pages/man2/mprotect.2:371
#, no-wrap
msgid ""
"    printf(\"Loop completed\\en\");     /* Should never happen */\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr "    printf(\"Цикл завершён\\en\");     /* никогда не должно случиться */\n    exit(EXIT_SUCCESS);\n}\n"

#. type: Plain text
#: man-pages/man2/mprotect.2:375
msgid "B<mmap>(2), B<sysconf>(3), B<pkeys>(7)"
msgstr "B<mmap>(2), B<sysconf>(3), B<pkeys>(7)"

#. type: TH
#: man-pages/man2/msync.2:25
#, no-wrap
msgid "MSYNC"
msgstr "MSYNC"

#. type: Plain text
#: man-pages/man2/msync.2:28
msgid "msync - synchronize a file with a memory map"
msgstr "msync - синхронизирует содержимое файла с его отображением в памяти"

#. type: Plain text
#: man-pages/man2/msync.2:32
msgid "B<int msync(void *>I<addr>B<, size_t >I<length>B<, int >I<flags>B<);>"
msgstr "B<int msync(void *>I<addr>B<, size_t >I<length>B<, int >I<flags>B<);>"

#. type: Plain text
#: man-pages/man2/msync.2:48
msgid ""
"B<msync>()  flushes changes made to the in-core copy of a file that was "
"mapped into memory using B<mmap>(2)  back to the filesystem.  Without use of"
" this call, there is no guarantee that changes are written back before "
"B<munmap>(2)  is called.  To be more precise, the part of the file that "
"corresponds to the memory area starting at I<addr> and having length "
"I<length> is updated."
msgstr "Вызов B<msync>() сбрасывает изменения файла, который отображён в память с помощью B<mmap>(2), обратно в файловую систему. Без использования этого вызова нет никакой гарантии, что изменения будут записаны в файл до вызова B<munmap>(2). Если быть точнее, то на диск записывается часть файла, начинающаяся в памяти с адреса I<addr> длиной I<length>."

#. type: Plain text
#: man-pages/man2/msync.2:59
msgid ""
"The I<flags> argument should specify exactly one of B<MS_ASYNC> and "
"B<MS_SYNC>, and may additionally include the B<MS_INVALIDATE> bit.  These "
"bits have the following meanings:"
msgstr "В аргументе I<flags> должен быть один из флагов B<MS_ASYNC> и B<MS_SYNC>, а также дополнительно можно указать B<MS_INVALIDATE>. Данные биты имеют следующее значение:"

#. type: TP
#: man-pages/man2/msync.2:59
#, no-wrap
msgid "B<MS_ASYNC>"
msgstr "B<MS_ASYNC>"

#. type: Plain text
#: man-pages/man2/msync.2:62
msgid ""
"Specifies that an update be scheduled, but the call returns immediately."
msgstr "Запланировать обновление, но вызов завершается сразу."

#. type: TP
#: man-pages/man2/msync.2:62
#, no-wrap
msgid "B<MS_SYNC>"
msgstr "B<MS_SYNC>"

#. type: Plain text
#: man-pages/man2/msync.2:65
msgid "Requests an update and waits for it to complete."
msgstr "Запланировать обновление и ждать его завершения."

#. type: TP
#: man-pages/man2/msync.2:65
#, no-wrap
msgid "B<MS_INVALIDATE>"
msgstr "B<MS_INVALIDATE>"

#.  Since Linux 2.4, this seems to be a no-op (other than the
#.  EBUSY check for VM_LOCKED).
#. type: Plain text
#: man-pages/man2/msync.2:71
msgid ""
"Asks to invalidate other mappings of the same file (so that they can be "
"updated with the fresh values just written)."
msgstr "Считать недействительными другие отображения того же файла (для того, чтобы они могли обновиться до достоверных значений, которые запишутся)."

#. type: Plain text
#: man-pages/man2/msync.2:83
msgid ""
"B<MS_INVALIDATE> was specified in I<flags>, and a memory lock exists for the"
" specified address range."
msgstr "В I<flags> указан B<MS_INVALIDATE>, но на указанный адресный диапазон есть блокировка в памяти."

#. type: Plain text
#: man-pages/man2/msync.2:96
msgid ""
"I<addr> is not a multiple of PAGESIZE; or any bit other than B<MS_ASYNC> | "
"B<MS_INVALIDATE> | B<MS_SYNC> is set in I<flags>; or both B<MS_SYNC> and "
"B<MS_ASYNC> are set in I<flags>."
msgstr "Значение I<addr> не кратно PAGESIZE; в I<flags> установлен любой другой бит, отличный от B<MS_ASYNC> | B<MS_INVALIDATE> | B<MS_SYNC>; в I<flags> установлены сразу B<MS_SYNC> и B<MS_ASYNC>."

#. type: Plain text
#: man-pages/man2/msync.2:99
msgid "The indicated memory (or part of it) was not mapped."
msgstr "Указанная память (или её часть) не была отображена."

#. type: Plain text
#: man-pages/man2/msync.2:101
msgid "POSIX.1-2001, POSIX.1-2008."
msgstr "POSIX.1-2001, POSIX.1-2008."

#. type: Plain text
#: man-pages/man2/msync.2:108
msgid ""
"This call was introduced in Linux 1.3.21, and then used B<EFAULT> instead of"
" B<ENOMEM>.  In Linux 2.4.19, this was changed to the POSIX value B<ENOMEM>."
msgstr "Этот вызов появился в Linux 1.3.21, и в нём использовалось B<EFAULT> вместо B<ENOMEM>. В Linux 2.4.19 это было изменено на значение POSIX B<ENOMEM>."

#.  POSIX.1-2001: It shall be defined to -1 or 0 or 200112L.
#.  -1: unavailable, 0: ask using sysconf().
#.  glibc defines them to 1.
#. type: Plain text
#: man-pages/man2/msync.2:123
msgid ""
"On POSIX systems on which B<msync>()  is available, both "
"B<_POSIX_MAPPED_FILES> and B<_POSIX_SYNCHRONIZED_IO> are defined in "
"I<E<lt>unistd.hE<gt>> to a value greater than 0.  (See also B<sysconf>(3).)"
msgstr "В системах POSIX, в которых доступен B<msync>(), значения B<_POSIX_MAPPED_FILES> и B<_POSIX_SYNCHRONIZED_IO>, определённые в I<E<lt>unistd.hE<gt>>, больше нуля. (См. также B<sysconf>(3).)"

#.  commit 204ec841fbea3e5138168edbc3a76d46747cc987
#. type: Plain text
#: man-pages/man2/msync.2:150
msgid ""
"According to POSIX, either B<MS_SYNC> or B<MS_ASYNC> must be specified in "
"I<flags>, and indeed failure to include one of these flags will cause "
"B<msync>()  to fail on some systems.  However, Linux permits a call to "
"B<msync>()  that specifies neither of these flags, with semantics that are "
"(currently) equivalent to specifying B<MS_ASYNC>.  (Since Linux 2.6.19, "
"B<MS_ASYNC> is in fact a no-op, since the kernel properly tracks dirty pages"
" and flushes them to storage as necessary.)  Notwithstanding the Linux "
"behavior, portable, future-proof applications should ensure that they "
"specify either B<MS_SYNC> or B<MS_ASYNC> in I<flags>."
msgstr "Согласно POSIX, в I<flags> должен быть указан или B<MS_SYNC>, или B<MS_ASYNC> и отказ включить один из этих флагов вызывает ошибку в B<msync>() на некоторых системах. Однако Linux позволяет вызывать B<msync>() без этих флагов, используя семантику, которая (в настоящее время) эквивалентна указанию B<MS_ASYNC> (начиная с Linux 2.6.19, B<MS_ASYNC>, фактически, ничего не делает, так как ядро правильно отслеживает грязные страницы и записывает их в место хранения при необходимости). Несмотря на поведение Linux, в переносимых, ориентированных на будущее приложениях в I<flags> должен быть указан или B<MS_SYNC>, или B<MS_ASYNC>."

#. type: Plain text
#: man-pages/man2/msync.2:152
msgid "B<mmap>(2)"
msgstr "B<mmap>(2)"

#. type: TH
#: man-pages/man2/migrate_pages.2:18
#, no-wrap
msgid "MIGRATE_PAGES"
msgstr "MIGRATE_PAGES"

#. type: Plain text
#: man-pages/man2/migrate_pages.2:21
msgid "migrate_pages - move all pages in a process to another set of nodes"
msgstr "migrate_pages - переносит все страницы процесса на другой набор узлов"

#. type: Plain text
#: man-pages/man2/migrate_pages.2:28
#, no-wrap
msgid ""
"B<long migrate_pages(int >I<pid>B<, unsigned long >I<maxnode,>\n"
"B<                   const unsigned long *>I<old_nodes,>\n"
"B<                   const unsigned long *>I<new_nodes>B<);>\n"
msgstr "B<long migrate_pages(int >I<pid>B<, unsigned long >I<maxnode,>\nB<                   const unsigned long *>I<old_nodes,>\nB<                   const unsigned long *>I<new_nodes>B<);>\n"

#. type: Plain text
#: man-pages/man2/migrate_pages.2:47
msgid ""
"B<migrate_pages>()  attempts to move all pages of the process I<pid> that "
"are in memory nodes I<old_nodes> to the memory nodes in I<new_nodes>.  Pages"
" not located in any node in I<old_nodes> will not be migrated.  As far as "
"possible, the kernel maintains the relative topology relationship inside "
"I<old_nodes> during the migration to I<new_nodes>."
msgstr "Вызов B<migrate_pages>() пытается перенести все страницы процесса с идентификатором I<pid>, находящиеся в памяти узлов I<old_nodes>, в память узлов I<new_nodes>. Страницы, не расположенные в узлах I<old_nodes>, не переносятся. При переносе на I<new_nodes> ядро в максимально возможной степени поддерживает относительную топологию связи внутри I<old_nodes>."

#. type: Plain text
#: man-pages/man2/migrate_pages.2:69
msgid ""
"The I<old_nodes> and I<new_nodes> arguments are pointers to bit masks of "
"node numbers, with up to I<maxnode> bits in each mask.  These masks are "
"maintained as arrays of unsigned I<long> integers (in the last I<long> "
"integer, the bits beyond those specified by I<maxnode> are ignored).  The "
"I<maxnode> argument is the maximum node number in the bit mask plus one "
"(this is the same as in B<mbind>(2), but different from B<select>(2))."
msgstr "Аргументы I<old_nodes> и I<new_nodes> представляют собой указатели на маски битов номеров узлов, до I<maxnode> в каждой маске. Эти маски обрабатываются как массивы беззнаковых целых I<long> (в последнем целом I<long> биты, лежащие за пределом I<maxnode>, игнорируются). Аргумент I<maxnode> представляет собой максимальный номер узла в битовой маске плюс 1 (также как в B<mbind>(2), но отличается от B<select>(2))."

#. type: Plain text
#: man-pages/man2/migrate_pages.2:83
msgid ""
"The I<pid> argument is the ID of the process whose pages are to be moved.  "
"To move pages in another process, the caller must be privileged "
"(B<CAP_SYS_NICE>)  or the real or effective user ID of the calling process "
"must match the real or saved-set user ID of the target process.  If I<pid> "
"is 0, then B<migrate_pages>()  moves pages of the calling process."
msgstr "В аргументе I<pid> задаётся идентификатор процесса, чьи страницы будут перемещаться. Чтобы перемещать страницы не своего процесса, вызывающий должен быть привилегированным (B<CAP_SYS_NICE>) или реальный или эффективный ID пользователя вызывающего процесса должен совпадать с реальным или сохранённым ID пользователя процесса назначения. Если I<pid> равен 0, то B<migrate_pages>() перемещает страницы вызвавшего процесса."

#. type: Plain text
#: man-pages/man2/migrate_pages.2:88
msgid ""
"Pages shared with another process will be moved only if the initiating "
"process has the B<CAP_SYS_NICE> privilege."
msgstr "Совместно используемые с другими процессами страницы будут перемещаться только, если первоначальный процесс имеет мандат B<CAP_SYS_NICE>."

#. type: Plain text
#: man-pages/man2/migrate_pages.2:96
msgid ""
"On success B<migrate_pages>()  returns the number of pages that could not be"
" moved (i.e., a return of zero means that all pages were successfully "
"moved).  On error, it returns -1, and sets I<errno> to indicate the error."
msgstr "При нормальном завершении работы B<migrate_pages>() возвращает количество неперемещённых страниц (то есть, ноль означает, что все страницы успешно перемещены). В случае ошибки возвращается -1, а I<errno> устанавливается в соответствующее значение."

#. type: Plain text
#: man-pages/man2/migrate_pages.2:104
msgid ""
"Part or all of the memory range specified by I<old_nodes>/I<new_nodes> and "
"I<maxnode> points outside your accessible address space."
msgstr "Часть или весь диапазон памяти, заданный в I<old_nodes>/I<new_nodes> и I<maxnode>, указывает за пределы доступного адресного пространства."

#.  As at 3.5, this limit is "a page worth of bits", e.g.,
#.  8 * 4096 bits, assuming a 4kB page size.
#. type: Plain text
#: man-pages/man2/migrate_pages.2:121
msgid ""
"The value specified by I<maxnode> exceeds a kernel-imposed limit.  Or, "
"I<old_nodes> or I<new_nodes> specifies one or more node IDs that are greater"
" than the maximum supported node ID.  Or, none of the node IDs specified by "
"I<new_nodes> are on-line and allowed by the process's current cpuset "
"context, or none of the specified nodes contain memory."
msgstr "Значение I<maxnode> превышает введённое ядром ограничение. В I<old_nodes> или I<new_nodes> задан один или более ID узлов, превышающих поддерживаемый максимальный ID узла. Или ни один из ID узлов, указанных в I<new_nodes>, включен и доступен из контекста текущего набора процессоров процесса, или ни один из узлов не содержит память."

#. type: Plain text
#: man-pages/man2/migrate_pages.2:130
msgid ""
"Insufficient privilege (B<CAP_SYS_NICE>)  to move pages of the process "
"specified by I<pid>, or insufficient privilege (B<CAP_SYS_NICE>)  to access "
"the specified target nodes."
msgstr "Недостаточно прав (B<CAP_SYS_NICE>) для перемещения страниц процесса, заданного I<pid>, или недостаточно прав (B<CAP_SYS_NICE>) для доступа к указанным узлам назначения."

#.  FIXME Document the other errors that can occur for migrate_pages()
#. type: Plain text
#: man-pages/man2/migrate_pages.2:136
msgid "No process matching I<pid> could be found."
msgstr "Не найден процесс с указанным I<pid>."

#. type: Plain text
#: man-pages/man2/migrate_pages.2:140
msgid ""
"The B<migrate_pages>()  system call first appeared on Linux in version "
"2.6.16."
msgstr "Вызов B<migrate_pages>() впервые появился в Linux в ядре версии 2.6.16."

#. type: Plain text
#: man-pages/man2/migrate_pages.2:154
msgid ""
"Use B<get_mempolicy>(2)  with the B<MPOL_F_MEMS_ALLOWED> flag to obtain the "
"set of nodes that are allowed by the calling process's cpuset.  Note that "
"this information is subject to change at any time by manual or automatic "
"reconfiguration of the cpuset."
msgstr "Используйте B<get_mempolicy>(2) с флагом B<MPOL_F_MEMS_ALLOWED> для получения набора узлов, которые доступны в наборе ЦП вызывающему процессу. Заметим, что эта информация может измениться в любое время вручную или при автоматической перенастройке набора ЦП."

#. type: Plain text
#: man-pages/man2/migrate_pages.2:166
msgid ""
"Use of B<migrate_pages>()  may result in pages whose location (node) "
"violates the memory policy established for the specified addresses (see "
"B<mbind>(2))  and/or the specified process (see B<set_mempolicy>(2)).  That "
"is, memory policy does not constrain the destination nodes used by "
"B<migrate_pages>()."
msgstr "Использование B<migrate_pages>() может привести к тому, что расположение страниц (на узле) нарушит политику памяти, установленную для заданных адресов (см. B<mbind>(2)) и/или заданного процесса (см. B<set_mempolicy>(2)). То есть политика памяти не ограничивает узлы назначения, используемые B<migrate_pages>()."

#. type: Plain text
#: man-pages/man2/migrate_pages.2:184
msgid "I<Documentation/vm/page_migration.rst> in the Linux kernel source tree"
msgstr "Файл I<Documentation/vm/page_migration.rst> в дереве исходного кода ядра Linux"

#. type: TH
#: man-pages/man2/mmap2.2:29
#, no-wrap
msgid "MMAP2"
msgstr "MMAP2"

#. type: Plain text
#: man-pages/man2/mmap2.2:32
msgid "mmap2 - map files or devices into memory"
msgstr "mmap2 - отображает файлы или устройства в память"

#. type: Plain text
#: man-pages/man2/mmap2.2:38
#, no-wrap
msgid ""
"B<void *mmap2(void *>I<addr>B<, size_t >I<length>B<, int >I<prot>B<,>\n"
"B<             int >I<flags>B<, int >I<fd>B<, off_t >I<pgoffset>B<);>\n"
msgstr "B<void *mmap2(void *>I<addr>B<, size_t >I<length>B<, int >I<prot>B<,>\nB<             int >I<flags>B<, int >I<fd>B<, off_t >I<pgoffset>B<);>\n"

#. type: Plain text
#: man-pages/man2/mmap2.2:43
msgid ""
"This is probably not the system call that you are interested in; instead, "
"see B<mmap>(2), which describes the glibc wrapper function that invokes this"
" system call."
msgstr "Вероятно, вам нужен не сам системный вызов; смотрите B<mmap>(2), описывающую обёрточную функцию glibc, которая вызывает данный системный вызов."

#. type: Plain text
#: man-pages/man2/mmap2.2:54
msgid ""
"The B<mmap2>()  system call provides the same interface as B<mmap>(2), "
"except that the final argument specifies the offset into the file in "
"4096-byte units (instead of bytes, as is done by B<mmap>(2)).  This enables "
"applications that use a 32-bit I<off_t> to map large files (up to 2^44 "
"bytes)."
msgstr "Системный вызов B<mmap2>() предоставляет тот же интерфейс что и B<mmap>(2), за исключением того, что последний аргумент задаёт смещение в файле в 4096-байтовых единицах (вместо байт, как это делается в B<mmap>(2)). Это позволяет приложениям использовать 32-битное значение I<off_t> для отображения больших файлов (до 2^44 байт)."

#. type: Plain text
#: man-pages/man2/mmap2.2:61
msgid ""
"On success, B<mmap2>()  returns a pointer to the mapped area.  On error, -1 "
"is returned and I<errno> is set appropriately."
msgstr "При удачном завершении B<mmap2>() возвращает указатель на область отображения. В случае ошибки возвращается -1, а I<errno> устанавливается в соответствующее значение."

#. type: Plain text
#: man-pages/man2/mmap2.2:65
msgid "Problem with getting the data from user space."
msgstr "Проблема получения данных из пользовательского пространства."

#. type: Plain text
#: man-pages/man2/mmap2.2:70
msgid ""
"(Various platforms where the page size is not 4096 bytes.)  I<offset\\ *\\ "
"4096> is not a multiple of the system page size."
msgstr "(Различные платформы, где размер страницы не равен 4096 байтам.) Значение I<offset\\ *\\ 4096> не кратно размеру страницы системы."

#. type: Plain text
#: man-pages/man2/mmap2.2:74
msgid "B<mmap2>()  can also return any of the errors described in B<mmap>(2)."
msgstr "Вызов B<mmap2>() также может вернуть любую ошибку из описанных в B<mmap>(2)."

#. type: Plain text
#: man-pages/man2/mmap2.2:77
msgid "B<mmap2>()  is available since Linux 2.3.31."
msgstr "Вызов B<mmap2>() доступен начиная с Linux 2.3.31."

#. type: Plain text
#: man-pages/man2/mmap2.2:86
msgid ""
"On architectures where this system call is present, the glibc B<mmap>()  "
"wrapper function invokes this system call rather than the B<mmap>(2)  system"
" call."
msgstr "На архитектурах, имеющих данный системный вызов, обёрточная функция glibc B<mmap>() вызывает данный системный вызов вместо системного вызова B<mmap>(2)."

#. type: Plain text
#: man-pages/man2/mmap2.2:88
msgid "This system call does not exist on x86-64."
msgstr "Этот системный вызов отсутствует на x86-64."

#.  ia64 can have page sizes ranging from 4 kB to 64 kB.
#.  On cris, it looks like the unit might also be the page size,
#.  which is 8192 bytes. -- mtk, June 2007
#. type: Plain text
#: man-pages/man2/mmap2.2:95
msgid ""
"On ia64, the unit for I<offset> is actually the system page size, rather "
"than 4096 bytes."
msgstr "На ia64 единица I<offset> на самом деле имеет размер страницы системы, а не равна 4096 байтам."

#. type: Plain text
#: man-pages/man2/mmap2.2:100
msgid ""
"B<getpagesize>(2), B<mmap>(2), B<mremap>(2), B<msync>(2), B<shm_open>(3)"
msgstr "B<getpagesize>(2), B<mmap>(2), B<mremap>(2), B<msync>(2), B<shm_open>(3)"

#. type: TH
#: man-pages/man2/mlock.2:26
#, no-wrap
msgid "MLOCK"
msgstr "MLOCK"

#. type: TH
#: man-pages/man2/mlock.2:26
#, no-wrap
msgid "2018-02-02"
msgstr "2018-02-02"

#. type: Plain text
#: man-pages/man2/mlock.2:29
msgid "mlock, mlock2, munlock, mlockall, munlockall - lock and unlock memory"
msgstr "mlock, mlock2, munlock, mlockall, munlockall - блокируют и разблокируют память"

#. type: Plain text
#: man-pages/man2/mlock.2:36
#, no-wrap
msgid ""
"B<int mlock(const void *>I<addr>B<, size_t >I<len>B<);>\n"
"B<int mlock2(const void *>I<addr>B<, size_t >I<len>B<, int >I<flags>B<);>\n"
"B<int munlock(const void *>I<addr>B<, size_t >I<len>B<);>\n"
msgstr "B<int mlock(const void *>I<addr>B<, size_t >I<len>B<);>\nB<int mlock2(const void *>I<addr>B<, size_t >I<len>B<, int >I<flags>B<);>\nB<int munlock(const void *>I<addr>B<, size_t >I<len>B<);>\n"

#. type: Plain text
#: man-pages/man2/mlock.2:39
#, no-wrap
msgid ""
"B<int mlockall(int >I<flags>B<);>\n"
"B<int munlockall(void);>\n"
msgstr "B<int mlockall(int >I<flags>B<);>\nB<int munlockall(void);>\n"

#. type: Plain text
#: man-pages/man2/mlock.2:48
msgid ""
"B<mlock>(), B<mlock2>(), and B<mlockall>()  lock part or all of the calling "
"process's virtual address space into RAM, preventing that memory from being "
"paged to the swap area."
msgstr "Вызовы B<mlock>(), B<mlock2>() и B<mlockall>() блокируют часть или всё виртуальное адресное пространство процесса в ОЗУ, запрещая эту память перемещать в пространство подкачки."

#. type: Plain text
#: man-pages/man2/mlock.2:56
msgid ""
"B<munlock>()  and B<munlockall>()  perform the converse operation, unlocking"
" part or all of the calling process's virtual address space, so that pages "
"in the specified virtual address range may once more to be swapped out if "
"required by the kernel memory manager."
msgstr "Вызовы B<munlock>() и B<munlockall>() выполняют обратную операцию, разблокируя часть или всё виртуальное адресное пространство процесса, после чего страницы в этом диапазоне виртуальных адресов могут вытесняться в пространство подкачки, если того потребуется менеджеру памяти ядра."

#. type: Plain text
#: man-pages/man2/mlock.2:58
msgid "Memory locking and unlocking are performed in units of whole pages."
msgstr "Размер блокировки и разблокировки памяти округляется до целых страниц."

#. type: SS
#: man-pages/man2/mlock.2:58
#, no-wrap
msgid "mlock(), mlock2(), and munlock()"
msgstr "mlock(), mlock2() и munlock()"

#. type: Plain text
#: man-pages/man2/mlock.2:68
msgid ""
"B<mlock>()  locks pages in the address range starting at I<addr> and "
"continuing for I<len> bytes.  All pages that contain a part of the specified"
" address range are guaranteed to be resident in RAM when the call returns "
"successfully; the pages are guaranteed to stay in RAM until later unlocked."
msgstr "Вызов B<mlock>() блокирует страницы в адресном диапазоне, начиная с I<addr> и длиной I<len> байтов. Все страницы, попадающие, даже частично, в заданную область, будут гарантировано помещены в ОЗУ, если системный вызов выполнился успешно; страницы гарантировано останутся в ОЗУ пока не будут разблокированы."

#.  commit a8ca5d0ecbdde5cc3d7accacbd69968b0c98764e
#.  commit de60f5f10c58d4f34b68622442c0e04180367f3f
#.  commit b0f205c2a3082dd9081f9a94e50658c5fa906ff1
#. type: Plain text
#: man-pages/man2/mlock.2:82
msgid ""
"B<mlock2>()  also locks pages in the specified range starting at I<addr> and"
" continuing for I<len> bytes.  However, the state of the pages contained in "
"that range after the call returns successfully will depend on the value in "
"the I<flags> argument."
msgstr "Вызов B<mlock2>() также  блокирует страницы в адресном диапазоне, начиная с I<addr> и длиной I<len> байтов. Однако состояние страниц в этом диапазоне после успешного выполнения вызова будет зависеть от значения аргумента I<flags>."

#. type: Plain text
#: man-pages/man2/mlock.2:86
msgid "The I<flags> argument can be either 0 or the following constant:"
msgstr "Параметр I<flags> может принимать значение 0 или одну из следующих констант:"

#. type: TP
#: man-pages/man2/mlock.2:86
#, no-wrap
msgid "B<MLOCK_ONFAULT>"
msgstr "B<MLOCK_ONFAULT>"

#. type: Plain text
#: man-pages/man2/mlock.2:91
msgid ""
"Lock pages that are currently resident and mark the entire range so that the"
" remaining nonresident pages are locked when they are populated by a page "
"fault."
msgstr "Блокировать страницы, которые в настоящее время уже есть в памяти и пометить весь диапазон так, чтобы оставшиеся вне памяти страницы блокировались, когда они будут заполнены из-за страничного промаха (fault)."

#. type: Plain text
#: man-pages/man2/mlock.2:99
msgid "If I<flags> is 0, B<mlock2>()  behaves exactly the same as B<mlock>()."
msgstr "Если параметр I<flags> равен 0, то B<mlock2>() ведёт себя точно так же как B<mlock>()."

#. type: Plain text
#: man-pages/man2/mlock.2:108
msgid ""
"B<munlock>()  unlocks pages in the address range starting at I<addr> and "
"continuing for I<len> bytes.  After this call, all pages that contain a part"
" of the specified memory range can be moved to external swap space again by "
"the kernel."
msgstr "Вызов B<munlock>() разблокирует страницы в области, начинающейся с адреса I<addr> и длиной I<len> байтов. После этого вызова все страницы, попадающие, даже частично, в заданную область, снова могут быть помещены ядром во внешнее пространство подкачки."

#. type: SS
#: man-pages/man2/mlock.2:108
#, no-wrap
msgid "mlockall() and munlockall()"
msgstr "mlockall() и munlockall()"

#. type: Plain text
#: man-pages/man2/mlock.2:118
msgid ""
"B<mlockall>()  locks all pages mapped into the address space of the calling "
"process.  This includes the pages of the code, data and stack segment, as "
"well as shared libraries, user space kernel data, shared memory, and memory-"
"mapped files.  All mapped pages are guaranteed to be resident in RAM when "
"the call returns successfully; the pages are guaranteed to stay in RAM until"
" later unlocked."
msgstr "Вызов B<mlockall>() блокирует все страницы, отображённые в адресное пространство вызывающего процесса. Сюда входят страницы сегмента кода, данных и стека, а также общих библиотек, страницы с данными пользовательского пространства ядра, общей памяти и файлов, отображённых в память. Все отображённые страницы гарантировано останутся в ОЗУ, если системный вызов выполнился успешно; страницы гарантировано останутся в ОЗУ пока не будут разблокированы."

#. type: Plain text
#: man-pages/man2/mlock.2:123
msgid ""
"The I<flags> argument is constructed as the bitwise OR of one or more of the"
" following constants:"
msgstr "Аргумент I<flags> создаётся побитовым сложением одной или более следующих констант:"

#. type: TP
#: man-pages/man2/mlock.2:123
#, no-wrap
msgid "B<MCL_CURRENT>"
msgstr "B<MCL_CURRENT>"

#. type: Plain text
#: man-pages/man2/mlock.2:127
msgid ""
"Lock all pages which are currently mapped into the address space of the "
"process."
msgstr "Блокировать все страницы, которые в данный момент отображены в адресное пространство процесса."

#. type: TP
#: man-pages/man2/mlock.2:127
#, no-wrap
msgid "B<MCL_FUTURE>"
msgstr "B<MCL_FUTURE>"

#. type: Plain text
#: man-pages/man2/mlock.2:134
msgid ""
"Lock all pages which will become mapped into the address space of the "
"process in the future.  These could be, for instance, new pages required by "
"a growing heap and stack as well as new memory-mapped files or shared memory"
" regions."
msgstr "Блокировать все страницы, которые будут отображены в адресное пространство процесса в будущем. Это могут быть, например, новые страницы, затребованные для увеличения кучи и стека, а также новые отображённые в память файлы или области общей памяти."

#. type: TP
#: man-pages/man2/mlock.2:134
#, no-wrap
msgid "B<MCL_ONFAULT> (since Linux 4.4)"
msgstr "B<MCL_ONFAULT> (начиная с Linux 4.4)"

#. type: Plain text
#: man-pages/man2/mlock.2:161
msgid ""
"Used together with B<MCL_CURRENT>, B<MCL_FUTURE>, or both.  Mark all current"
" (with B<MCL_CURRENT>)  or future (with B<MCL_FUTURE>)  mappings to lock "
"pages when they are faulted in.  When used with B<MCL_CURRENT>, all present "
"pages are locked, but B<mlockall>()  will not fault in non-present pages.  "
"When used with B<MCL_FUTURE>, all future mappings will be marked to lock "
"pages when they are faulted in, but they will not be populated by the lock "
"when the mapping is created.  B<MCL_ONFAULT> must be used with either "
"B<MCL_CURRENT> or B<MCL_FUTURE> or both."
msgstr "Используется вместе с B<MCL_CURRENT>, B<MCL_FUTURE> или обоими. Пометить все текущие (с B<MCL_CURRENT>) или будущие (с B<MCL_FUTURE>) отображения для блокировки страниц, когда они получаются при сбое (faulted in). При использовании с B<MCL_CURRENT> все существующие страницы блокируются, но B<mlockall>() не будет сбоить на несуществующих страницах. При использовании с B<MCL_FUTURE> все будущие отображения будут помечены для блокировки страниц при сбое, но они не будут заполнены из-за блокировки при создании отображения. Флаг B<MCL_ONFAULT> должен использовать одновременно с B<MCL_CURRENT> или B<MCL_FUTURE> или обоими."

#. type: Plain text
#: man-pages/man2/mlock.2:174
msgid ""
"If B<MCL_FUTURE> has been specified, then a later system call (e.g., "
"B<mmap>(2), B<sbrk>(2), B<malloc>(3)), may fail if it would cause the number"
" of locked bytes to exceed the permitted maximum (see below).  In the same "
"circumstances, stack growth may likewise fail: the kernel will deny stack "
"expansion and deliver a B<SIGSEGV> signal to the process."
msgstr "Если указан флаг B<MCL_FUTURE>, то последующий системный вызов (например, B<mmap>(2), B<sbrk>(2), B<malloc>(3)), может завершиться с ошибкой, если бы его работа приводит к превышению разрешённого максимального числа блокируемых байт (см. ниже). Также этот флаг может остановить увеличение стека: ядро будет отказывать в увеличении стека и будет посылать процессу сигнал B<SIGSEGV>."

#. type: Plain text
#: man-pages/man2/mlock.2:178
msgid ""
"B<munlockall>()  unlocks all pages mapped into the address space of the "
"calling process."
msgstr "Вызов B<munlockall>() разблокирует все страницы, отображённые в адресное пространство вызывающего процесса."

#. type: Plain text
#: man-pages/man2/mlock.2:184
msgid ""
"On success, these system calls return 0.  On error, -1 is returned, I<errno>"
" is set appropriately, and no changes are made to any locks in the address "
"space of the process."
msgstr "При успешном выполнении эти системные вызовы возвращают 0. При ошибке возвращается -1, устанавливается соответствующий код ошибки в I<errno>, и никакие блокировки не изменяются в адресном пространстве процесса."

#. type: Plain text
#: man-pages/man2/mlock.2:193
msgid ""
"(Linux 2.6.9 and later) the caller had a nonzero B<RLIMIT_MEMLOCK> soft "
"resource limit, but tried to lock more memory than the limit permitted.  "
"This limit is not enforced if the process is privileged (B<CAP_IPC_LOCK>)."
msgstr "(Linux 2.6.9 и новее) У вызывающего процесса установлено ненулевое мягкое ограничение ресурса B<RLIMIT_MEMLOCK>, но он пытается заблокировать больше памяти, чем это разрешено ограничением. Данное ограничение не учитывается у привилегированных процессов (B<CAP_IPC_LOCK>)."

#.  In the case of mlock(), this check is somewhat buggy: it doesn't
#.  take into account whether the to-be-locked range overlaps with
#.  already locked pages.  Thus, suppose we allocate
#.  (num_physpages / 4 + 1) of memory, and lock those pages once using
#.  mlock(), and then lock the *same* page range a second time.
#.  In the case, the second mlock() call will fail, since the check
#.  calculates that the process is trying to lock (num_physpages / 2 + 2)
#.  pages, which of course is not true.  (MTK, Nov 04, kernel 2.4.28)
#. type: Plain text
#: man-pages/man2/mlock.2:205
msgid ""
"(Linux 2.4 and earlier) the calling process tried to lock more than half of "
"RAM."
msgstr "(Linux 2.4 и в более ранних) Вызывающий процесс пытается заблокировать более половины ОЗУ."

#. SVr4 documents an additional EAGAIN error code.
#. type: Plain text
#: man-pages/man2/mlock.2:211
msgid ""
"The caller is not privileged, but needs privilege (B<CAP_IPC_LOCK>)  to "
"perform the requested operation."
msgstr "Вызывающий не имеет прав (B<CAP_IPC_LOCK>) для выполнения запрошенной операции."

#. type: Plain text
#: man-pages/man2/mlock.2:217
msgid "For B<mlock>(), B<mlock2>(), and B<munlock>():"
msgstr "Для B<mlock>(), B<mlock2>(), и B<munlock>():"

#. type: Plain text
#: man-pages/man2/mlock.2:220
msgid "Some or all of the specified address range could not be locked."
msgstr "Невозможно заблокировать некоторую часть или весь диапазон адресов."

#. type: Plain text
#: man-pages/man2/mlock.2:227
msgid ""
"The result of the addition I<addr>+I<len> was less than I<addr> (e.g., the "
"addition may have resulted in an overflow)."
msgstr "Результат добавления I<addr>+I<len> стал меньше чем I<addr> (например, добавление могло привести к переполнению)."

#. type: Plain text
#: man-pages/man2/mlock.2:232
msgid "(Not on Linux)  I<addr> was not a multiple of the page size."
msgstr "(Не в Linux) Значение I<addr> не кратно размеру страницы."

#. type: Plain text
#: man-pages/man2/mlock.2:236
msgid ""
"Some of the specified address range does not correspond to mapped pages in "
"the address space of the process."
msgstr "Часть указанного адресного диапазона не соответствует отображённым страницам адресного пространства процесса."

#.  I.e., the number of VMAs would exceed the 64kB maximum
#. type: Plain text
#: man-pages/man2/mlock.2:245
msgid ""
"Locking or unlocking a region would result in the total number of mappings "
"with distinct attributes (e.g., locked versus unlocked)  exceeding the "
"allowed maximum.  (For example, unlocking a range in the middle of a "
"currently locked mapping would result in three mappings: two locked mappings"
" at each end and an unlocked mapping in the middle.)"
msgstr "Блокировка и разблокировка области привела бы к превышению разрешённого максимума на количество отображений с различающимися атрибутами (блокированных и разблокированных). Например, разблокировка диапазона в середине области в данный момент блокированного отображения привела бы к трём отображениям: два блокированных отображения на концах и доступное разблокированное отображение посередине."

#. type: Plain text
#: man-pages/man2/mlock.2:248
msgid "For B<mlock2>():"
msgstr "For B<mlock2>():"

#. type: Plain text
#: man-pages/man2/mlock.2:251
msgid "Unknown I<flags> were specified."
msgstr "Указан неизвестный флаг в I<flags>."

#. type: Plain text
#: man-pages/man2/mlock.2:254
msgid "For B<mlockall>():"
msgstr "У B<mlockall>():"

#. type: Plain text
#: man-pages/man2/mlock.2:262
msgid ""
"Unknown I<flags> were specified or B<MCL_ONFAULT> was specified without "
"either B<MCL_FUTURE> or B<MCL_CURRENT>."
msgstr "Неизвестное значение в I<flags> или B<MCL_ONFAULT> задан без B<MCL_FUTURE> или B<MCL_CURRENT>."

#. type: Plain text
#: man-pages/man2/mlock.2:265
msgid "For B<munlockall>():"
msgstr "У B<munlockall>():"

#. type: Plain text
#: man-pages/man2/mlock.2:269
msgid ""
"(Linux 2.6.8 and earlier) The caller was not privileged (B<CAP_IPC_LOCK>)."
msgstr "(Linux 2.6.8 и более ранних) Вызывающий процесс не имеет достаточно прав (B<CAP_IPC_LOCK>)."

#. type: Plain text
#: man-pages/man2/mlock.2:273
msgid ""
"B<mlock2>()  is available since Linux 4.4; glibc support was added in "
"version 2.27."
msgstr "Системный вызов B<mlock2>() появился в Linux 4.4; поддержка в glibc началась с версии 2.27."

#. type: Plain text
#: man-pages/man2/mlock.2:278
msgid "mlock2 ()  is Linux specific."
msgstr "Функция mlock2() , определена только в Linux."

#. type: Plain text
#: man-pages/man2/mlock.2:290
msgid ""
"On POSIX systems on which B<mlock>()  and B<munlock>()  are available, "
"B<_POSIX_MEMLOCK_RANGE> is defined in I<E<lt>unistd.hE<gt>> and the number "
"of bytes in a page can be determined from the constant B<PAGESIZE> (if "
"defined) in I<E<lt>limits.hE<gt>> or by calling I<sysconf(_SC_PAGESIZE)>."
msgstr "В POSIX-системах, в которых доступны B<mlock>() и B<munlock>(), значение B<_POSIX_MEMLOCK_RANGE> определено в I<E<lt>unistd.hE<gt>>, а количество байт в странице можно определить из константы B<PAGESIZE> (если определена) в I<E<lt>limits.hE<gt>> или вызвав I<sysconf(_SC_PAGESIZE)>."

#.  POSIX.1-2001: It shall be defined to -1 or 0 or 200112L.
#.  -1: unavailable, 0: ask using sysconf().
#.  glibc defines it to 1.
#. type: Plain text
#: man-pages/man2/mlock.2:303
msgid ""
"On POSIX systems on which B<mlockall>()  and B<munlockall>()  are available,"
" B<_POSIX_MEMLOCK> is defined in I<E<lt>unistd.hE<gt>> to a value greater "
"than 0.  (See also B<sysconf>(3).)"
msgstr "В POSIX-системах, в которых доступны B<mlockall>() и B<munlockall>(), значение B<_POSIX_MEMLOCK>, определенное в I<E<lt>unistd.hE<gt>>, больше нуля (см. также B<sysconf>(3))."

#. type: Plain text
#: man-pages/man2/mlock.2:321
msgid ""
"Memory locking has two main applications: real-time algorithms and high-"
"security data processing.  Real-time applications require deterministic "
"timing, and, like scheduling, paging is one major cause of unexpected "
"program execution delays.  Real-time applications will usually also switch "
"to a real-time scheduler with B<sched_setscheduler>(2).  Cryptographic "
"security software often handles critical bytes like passwords or secret keys"
" as data structures.  As a result of paging, these secrets could be "
"transferred onto a persistent swap store medium, where they might be "
"accessible to the enemy long after the security software has erased the "
"secrets in RAM and terminated.  (But be aware that the suspend mode on "
"laptops and some desktop computers will save a copy of the system's RAM to "
"disk, regardless of memory locks.)"
msgstr "Блокировка памяти используется, в основном, в двух случаях: в алгоритмах реального времени и при работе с секретными данными. Программам реального времени необходима предсказуемость времени выполнения, а страничный обмен (наряду с системой переключения процессов) может привести к неожиданным задержкам в работе. Такие приложения часто переключаются в режим реального времени при помощи вызовы B<sched_setscheduler>(2). Криптографические системы защиты данных очень часто содержат важные данные, например, пароли или секретные ключи, в структурах данных. В результате страничного обмена эти данные могут попасть в область подкачки, находящуюся на устройстве длительного хранения, где к этим данным после того, как они пропадут из ОЗУ, может получить доступ практически кто угодно. (Помните, что в режиме приостановки (suspend) на ноутбуках и некоторых компьютерах на жёсткий диск сохраняется копия памяти ОЗУ системы, независимо от блокировок памяти)."

#. type: Plain text
#: man-pages/man2/mlock.2:334
msgid ""
"Real-time processes that are using B<mlockall>()  to prevent delays on page "
"faults should reserve enough locked stack pages before entering the time-"
"critical section, so that no page fault can be caused by function calls.  "
"This can be achieved by calling a function that allocates a sufficiently "
"large automatic variable (an array) and writes to the memory occupied by "
"this array in order to touch these stack pages.  This way, enough pages will"
" be mapped for the stack and can be locked into RAM.  The dummy writes "
"ensure that not even copy-on-write page faults can occur in the critical "
"section."
msgstr "Процессы реального времени, использующие B<mlockall>() для устранения задержек при страничных прерываниях (page fault), должны зарезервировать достаточно заблокированных страниц стека до входа в критический ко времени участок, для того, чтобы вызов функции не мог привести к страничному прерыванию. Это можно выполнить с помощью вызова функции, которая выделит место под достаточно большую автоматическую переменную (массив) и выполнит запись в память для того, чтобы этот массив занял место в странице стека. Таким путём будет отображено достаточно страниц для стека, которые можно заблокировать в ОЗУ. Бесполезная запись нужна для того, чтобы в критическом участке не возникло страничное прерывание для копирования страницы при записи."

#. type: Plain text
#: man-pages/man2/mlock.2:349
msgid ""
"Memory locks are not inherited by a child created via B<fork>(2)  and are "
"automatically removed (unlocked) during an B<execve>(2)  or when the process"
" terminates.  The B<mlockall>()  B<MCL_FUTURE> and B<MCL_FUTURE | "
"MCL_ONFAULT> settings are not inherited by a child created via B<fork>(2)  "
"and are cleared during an B<execve>(2)."
msgstr "Блокировка памяти не наследуется дочерними процессами, созданными при помощи B<fork>(2), и автоматически удаляется (разблокируется) при выполнении B<execve>(2) или при завершении работы процесса. Установка B<MCL_FUTURE> и B<MCL_FUTURE | MCL_ONFAULT> в B<mlockall>() не наследуется потомком, созданными при помощи B<fork>(2), и автоматически стирается при выполнении B<execve>(2)."

#. type: Plain text
#: man-pages/man2/mlock.2:363
msgid ""
"Note that B<fork>(2)  will prepare the address space for a copy-on-write "
"operation.  The consequence is that any write access that follows will cause"
" a page fault that in turn may cause high latencies for a real-time process."
"  Therefore, it is crucial not to invoke B<fork>(2)  after an B<mlockall>()"
"  or B<mlock>()  operation\\(emnot even from a thread which runs at a low "
"priority within a process which also has a thread running at elevated "
"priority."
msgstr "Заметим, что that B<fork>(2) подготовит адресное пространство для операции копирования при записи. Следовательно, любой последующий доступ на запись приведёт к страничному отказу, который, в свою очередь, может привести к большим задержкам в процессах реального времени. Поэтому, существенно важно не вызывать B<fork>(2) после операции B<mlockall>() или B<mlock>() — даже для нитей, которые выполняются с низким приоритетом внутри процесса, который также имеет нить, выполняющуюся с более высоким приоритетом."

#. type: Plain text
#: man-pages/man2/mlock.2:367
msgid ""
"The memory lock on an address range is automatically removed if the address "
"range is unmapped via B<munmap>(2)."
msgstr "Блокировка памяти адресного диапазона автоматически удаляется, если этот диапазон становится неотображаемым с помощью вызова B<munmap>(2)."

#. type: Plain text
#: man-pages/man2/mlock.2:381
msgid ""
"Memory locks do not stack, that is, pages which have been locked several "
"times by calls to B<mlock>(), B<mlock2>(), or B<mlockall>()  will be "
"unlocked by a single call to B<munlock>()  for the corresponding range or by"
" B<munlockall>().  Pages which are mapped to several locations or by several"
" processes stay locked into RAM as long as they are locked at least at one "
"location or by at least one process."
msgstr "Блокировки памяти не накапливаются, то есть, если страница была заблокирована вызовами B<mlock>(), B<mlock2>() или B<mlockall>() несколько раз, то она будет разблокирована единственным вызовом B<munlock>() для соответствующего диапазона или с помощью вызова B<munlockall>(). Страницы, которые были отображены в несколько мест или несколькими процессами, останутся заблокированными в ОЗУ до тех пор, пока они блокируются хотя бы в одном месте или хотя бы в одном процессе."

#. type: Plain text
#: man-pages/man2/mlock.2:390
msgid ""
"If a call to B<mlockall>()  which uses the B<MCL_FUTURE> flag is followed by"
" another call that does not specify this flag, the changes made by the "
"B<MCL_FUTURE> call will be lost."
msgstr "Если послед вызова B<mlockall>() с флагом B<MCL_FUTURE> идёт другой вызов, у которого нет этого флага, то изменения, сделанные вызовом с B<MCL_FUTURE> будут потеряны."

#. type: Plain text
#: man-pages/man2/mlock.2:401
msgid ""
"The B<mlock2>()  B<MLOCK_ONFAULT> flag and the B<mlockall>()  B<MCL_ONFAULT>"
" flag allow efficient memory locking for applications that deal with large "
"mappings where only a (small) portion of pages in the mapping are touched.  "
"In such cases, locking all of the pages in a mapping would incur a "
"significant penalty for memory locking."
msgstr "Флаг B<MLOCK_ONFAULT> у B<mlock2>() и B<MCL_ONFAULT> у B<mlockall>() позволяют эффективно блокировать память в приложениях, которые работают с большим количеством отображений, где только задействуется часть (малая) страниц в отображении. В таких случаях блокировка всех страниц в отображении приводила бы к значительным простоям из-за блокировки памяти."

#. type: Plain text
#: man-pages/man2/mlock.2:417
msgid ""
"Under Linux, B<mlock>(), B<mlock2>(), and B<munlock>()  automatically round "
"I<addr> down to the nearest page boundary.  However, the POSIX.1 "
"specification of B<mlock>()  and B<munlock>()  allows an implementation to "
"require that I<addr> is page aligned, so portable applications should ensure"
" this."
msgstr "В Linux, B<mlock>(), B<mlock2>() и B<munlock>() автоматически округляют I<addr> в меньшую сторону к размеру границы ближайшей страницы. Однако, в POSIX.1 указано, что реализации B<mlock>() и B<munlock>() разрешено требовать, чтобы значение I<addr> было выровнено по размеру страницы, поэтому переносимые приложения должны выполнять выравнивание."

#. type: Plain text
#: man-pages/man2/mlock.2:431
msgid ""
"The I<VmLck> field of the Linux-specific I</proc/[pid]/status> file shows "
"how many kilobytes of memory the process with ID I<PID> has locked using "
"B<mlock>(), B<mlock2>(), B<mlockall>(), and B<mmap>(2)  B<MAP_LOCKED>."
msgstr "В поле I<VmLck>, имеющемся только в Linux файле I</proc/[pid]/status>, показано сколько килобайт памяти заблокировал процесс с идентификатором I<PID> с помощью B<mlock>(), B<mlock2>(), B<mlockall>() и B<mmap>(2) с флагом B<MAP_LOCKED>."

#. type: SS
#: man-pages/man2/mlock.2:431
#, no-wrap
msgid "Limits and permissions"
msgstr "Ограничения и права доступа"

#. type: Plain text
#: man-pages/man2/mlock.2:438
msgid ""
"In Linux 2.6.8 and earlier, a process must be privileged (B<CAP_IPC_LOCK>)  "
"in order to lock memory and the B<RLIMIT_MEMLOCK> soft resource limit "
"defines a limit on how much memory the process may lock."
msgstr "В Linux версии 2.6.8 и более ранних для блокировки памяти процесс должен иметь мандат (B<CAP_IPC_LOCK>), а мягкое ограничение ресурса B<RLIMIT_MEMLOCK> определяет как много памяти можно заблокировать."

#. type: Plain text
#: man-pages/man2/mlock.2:444
msgid ""
"Since Linux 2.6.9, no limits are placed on the amount of memory that a "
"privileged process can lock and the B<RLIMIT_MEMLOCK> soft resource limit "
"instead defines a limit on how much memory an unprivileged process may lock."
msgstr "Начиная с Linux 2.6.9, привилегированный процесс не имеет ограничения на ограничиваемое количество памяти, а мягкое ограничение ресурса B<RLIMIT_MEMLOCK> определяет предел ограничиваемой памяти для непривилегированных процессов."

#.  commit 0cf2f6f6dc605e587d2c1120f295934c77e810e8
#. type: Plain text
#: man-pages/man2/mlock.2:467
msgid ""
"In Linux 4.8 and earlier, a bug in the kernel's accounting of locked memory "
"for unprivileged processes (i.e., without B<CAP_IPC_LOCK>)  meant that if "
"the region specified by I<addr> and I<len> overlapped an existing lock, then"
" the already locked bytes in the overlapping region were counted twice when "
"checking against the limit.  Such double accounting could incorrectly "
"calculate a \"total locked memory\" value for the process that exceeded the "
"B<RLIMIT_MEMLOCK> limit, with the result that B<mlock>()  and B<mlock2>()  "
"would fail on requests that should have succeeded.  This bug was fixed in "
"Linux 4.9"
msgstr "В Linux 4.8 и старее имеется дефект учёта блокированной памяти непривилегированных процессов (т. е., без B<CAP_IPC_LOCK>) в ядре, состоящий в том, что если область, указанная I<addr> и I<len> перекрывает существующую блокировку, то при проверке ограничений уже заблокированные байты перекрывающей области учитываются дважды. Из-за такого двойного учёта может некорректно вычисляться значение «общего количества заблокированной памяти», и процесс, который превышает ограничение B<RLIMIT_MEMLOCK>, в результате B<mlock>() и B<mlock2>() получит ошибку при запросах, которые должны выполняться успешно. Этот дефект был исправлен в Linux 4.9."

#. type: Plain text
#: man-pages/man2/mlock.2:475
msgid ""
"In the 2.4 series Linux kernels up to and including 2.4.17, a bug caused the"
" B<mlockall>()  B<MCL_FUTURE> flag to be inherited across a B<fork>(2).  "
"This was rectified in kernel 2.4.18."
msgstr "В ветви 2.4 ядер Linux до версии 2.4.17 включительно есть дефект, из-за которого флаг B<MCL_FUTURE> у B<mlockall>() наследуется при B<fork>(2). Он устранён в версии 2.4.18."

#.  See the following LKML thread:
#.  http://marc.theaimsgroup.com/?l=linux-kernel&m=113801392825023&w=2
#.  "Rationale for RLIMIT_MEMLOCK"
#.  23 Jan 2006
#. type: Plain text
#: man-pages/man2/mlock.2:492
msgid ""
"Since kernel 2.6.9, if a privileged process calls I<mlockall(MCL_FUTURE)> "
"and later drops privileges (loses the B<CAP_IPC_LOCK> capability by, for "
"example, setting its effective UID to a nonzero value), then subsequent "
"memory allocations (e.g., B<mmap>(2), B<brk>(2))  will fail if the "
"B<RLIMIT_MEMLOCK> resource limit is encountered."
msgstr "Начиная с ядра версии 2.6.9, если привилегированный процесс вызывает I<mlockall(MCL_FUTURE)> и, позднее, отказывается от прав (теряет мандат B<CAP_IPC_LOCK>, например, устанавливая свой эффективный UID в ненулевое значение), то последующие выделения памяти (например, с помощью B<mmap>(2), B<brk>(2)) будут завершаться с ошибкой при достижении предела ресурса B<RLIMIT_MEMLOCK>."

#. type: Plain text
#: man-pages/man2/mlock.2:499
msgid ""
"B<mincore>(2), B<mmap>(2), B<setrlimit>(2), B<shmctl>(2), B<sysconf>(3), "
"B<proc>(5), B<capabilities>(7)"
msgstr "B<mincore>(2), B<mmap>(2), B<setrlimit>(2), B<shmctl>(2), B<sysconf>(3), B<proc>(5), B<capabilities>(7)"

#. type: TH
#: man-pages/man2/mremap.2:30
#, no-wrap
msgid "MREMAP"
msgstr "MREMAP"

#. type: Plain text
#: man-pages/man2/mremap.2:33
msgid "mremap - remap a virtual memory address"
msgstr "mremap - изменяет отображение адреса виртуальной памяти"

#. type: Plain text
#: man-pages/man2/mremap.2:40
#, no-wrap
msgid ""
"B<void *mremap(void *>I<old_address>B<, size_t >I<old_size>B<,>\n"
"B<             size_t >I<new_size>B<, int >I<flags>B<, ... /* void *>I<new_address>B< */);>\n"
msgstr "B<void *mremap(void *>I<old_address>B<, size_t >I<old_size>B<,>\nB<             size_t >I<new_size>B<, int >I<flags>B<, ... /* void *>I<new_address>B< */);>\n"

#. type: Plain text
#: man-pages/man2/mremap.2:46
msgid ""
"B<mremap>()  expands (or shrinks) an existing memory mapping, potentially "
"moving it at the same time (controlled by the I<flags> argument and the "
"available virtual address space)."
msgstr "Вызов B<mremap>() увеличивает (или уменьшает) размер существующего отображения памяти, при необходимости, перемещая его (это контролируется аргументом I<flags> и доступным виртуальным адресным пространством)."

#. type: Plain text
#: man-pages/man2/mremap.2:60
msgid ""
"I<old_address> is the old address of the virtual memory block that you want "
"to expand (or shrink).  Note that I<old_address> has to be page aligned.  "
"I<old_size> is the old size of the virtual memory block.  I<new_size> is the"
" requested size of the virtual memory block after the resize.  An optional "
"fifth argument, I<new_address>, may be provided; see the description of "
"B<MREMAP_FIXED> below."
msgstr "В I<old_address> указывается старый адрес блока виртуальной памяти, который вы хотите изменить. Заметим, что I<old_address> должен быть выровнен по границе страницы. В I<old_size> задаётся старый размер блока виртуальной памяти. В I<new_size> задаётся запрашиваемый размер блока виртуальной памяти после изменения. Описание необязательного пятого аргумента I<new_address> смотрите далее в параграфе о B<MREMAP_FIXED>."

#. type: Plain text
#: man-pages/man2/mremap.2:76
msgid ""
"If the value of I<old_size> is zero, and I<old_address> refers to a "
"shareable mapping (see B<mmap>(2)  B<MAP_SHARED>), then B<mremap>()  will "
"create a new mapping of the same pages.  I<new_size> will be the size of the"
" new mapping and the location of the new mapping may be specified with "
"I<new_address>; see the description of B<MREMAP_FIXED> below.  If a new "
"mapping is requested via this method, then the B<MREMAP_MAYMOVE> flag must "
"also be specified."
msgstr "Если значение I<old_size> равно нулю и I<old_address> указывает на общее отображение (смотрите B<mmap>(2)  B<MAP_SHARED>), то B<mremap>() создаст новое отображение тех же страниц.Размер нового отображения будет равен значению I<new_size>, а расположение можно указать в I<new_address>; смотрите описание B<MREMAP_FIXED> далее. Если новое отображение запрашивается через этот метод, то также должен быть указан флаг B<MREMAP_MAYMOVE>."

#. type: Plain text
#: man-pages/man2/mremap.2:88
msgid ""
"In Linux the memory is divided into pages.  A user process has (one or)  "
"several linear virtual memory segments.  Each virtual memory segment has one"
" or more mappings to real memory pages (in the page table).  Each virtual "
"memory segment has its own protection (access rights), which may cause a "
"segmentation violation if the memory is accessed incorrectly (e.g., writing "
"to a read-only segment).  Accessing virtual memory outside of the segments "
"will also cause a segmentation violation."
msgstr "В Linux память делится на страницы. Пользовательскому процессу выделяется один или несколько непрерывных сегментов виртуальной памяти. Каждый из этих сегментов имеет одно или несколько отображений в реальных страницах памяти (в таблице страниц). У каждого виртуального сегмента памяти есть своя защита (права доступа), которые можно нарушить, если произвести попытку некорректного доступа (например, записать информацию в сегмент, который доступен только для чтения). Доступ к виртуальной памяти за пределами сегментов также приводит к ошибке сегментации."

#. type: Plain text
#: man-pages/man2/mremap.2:96
msgid ""
"B<mremap>()  uses the Linux page table scheme.  B<mremap>()  changes the "
"mapping between virtual addresses and memory pages.  This can be used to "
"implement a very efficient B<realloc>(3)."
msgstr "Вызов B<mremap>() использует схему табличных страниц Linux. B<mremap>() изменяет отображение между виртуальными адресами и страницами памяти. Это можно использовать при реализации очень эффективной функции B<realloc>(3)."

#. type: Plain text
#: man-pages/man2/mremap.2:98
msgid ""
"The I<flags> bit-mask argument may be 0, or include the following flag:"
msgstr "Аргумент битовой маски I<flags> может быть равен 0 или содержать следующие флаги:"

#. type: TP
#: man-pages/man2/mremap.2:98
#, no-wrap
msgid "B<MREMAP_MAYMOVE>"
msgstr "B<MREMAP_MAYMOVE>"

#. type: Plain text
#: man-pages/man2/mremap.2:110
msgid ""
"By default, if there is not sufficient space to expand a mapping at its "
"current location, then B<mremap>()  fails.  If this flag is specified, then "
"the kernel is permitted to relocate the mapping to a new virtual address, if"
" necessary.  If the mapping is relocated, then absolute pointers into the "
"old mapping location become invalid (offsets relative to the starting "
"address of the mapping should be employed)."
msgstr "По умолчанию, если для расширения отображения недостаточно пространства в текущем расположении, то вызов B<mremap>() завершается с ошибкой. Если указан флаг, то, если нужно, ядру разрешается переместить отображение на новый виртуальный адрес. Если отображение перемещено, то абсолютные указатели в старом расположении отображения становятся недействительными (должно быть выполнено смещение относительно начального адреса отображения)."

#. type: TP
#: man-pages/man2/mremap.2:110
#, no-wrap
msgid "B<MREMAP_FIXED> (since Linux 2.3.31)"
msgstr "B<MREMAP_FIXED> (начиная с Linux 2.3.31)"

#. type: Plain text
#: man-pages/man2/mremap.2:132
msgid ""
"This flag serves a similar purpose to the B<MAP_FIXED> flag of B<mmap>(2).  "
"If this flag is specified, then B<mremap>()  accepts a fifth argument, "
"I<void\\ *new_address>, which specifies a page-aligned address to which the "
"mapping must be moved.  Any previous mapping at the address range specified "
"by I<new_address> and I<new_size> is unmapped.  If B<MREMAP_FIXED> is "
"specified, then B<MREMAP_MAYMOVE> must also be specified."
msgstr "Этот флаг играет ту же роль, что и B<MAP_FIXED> для B<mmap>(2). Если указан этот флаг, то B<mremap>() учитывает пятый аргумент I<void\\ *new_address>, в котором задан выровненный на страницу адрес, куда должно быть перемещено отображение. Все предыдущие отображения в адресном диапазоне, задаваемом I<new_address> и I<new_size>, удаляются. При указании B<MREMAP_FIXED> также должен быть указан B<MREMAP_MAYMOVE>."

#. type: Plain text
#: man-pages/man2/mremap.2:142
msgid ""
"If the memory segment specified by I<old_address> and I<old_size> is locked "
"(using B<mlock>(2)  or similar), then this lock is maintained when the "
"segment is resized and/or relocated.  As a consequence, the amount of memory"
" locked by the process may change."
msgstr "Если сегмент памяти, указанный I<old_address> и I<old_size>, заблокирован (с помощью B<mlock>(2) или подобного вызова), то эта блокировка останется при изменении/перемещении сегмента. Следовательно, количество заблокированной процессом памяти может измениться."

#. type: Plain text
#: man-pages/man2/mremap.2:150
msgid ""
"On success B<mremap>()  returns a pointer to the new virtual memory area.  "
"On error, the value B<MAP_FAILED> (that is, I<(void\\ *)\\ -1>) is returned,"
" and I<errno> is set appropriately."
msgstr "При успешном выполнении B<mremap>() возвращается указатель на новую виртуальную область памяти. При ошибке, возвращается значение B<MAP_FAILED> (то есть I<(void\\ *)\\ -1>), а I<errno> устанавливается в соответствующее значение."

#. type: Plain text
#: man-pages/man2/mremap.2:157
msgid ""
"The caller tried to expand a memory segment that is locked, but this was not"
" possible without exceeding the B<RLIMIT_MEMLOCK> resource limit."
msgstr "Вызывающий пытается расширить заблокированный сегмент памяти, но это невозможно без превышения предела ресурса B<RLIMIT_MEMLOCK>."

#. type: Plain text
#: man-pages/man2/mremap.2:166
msgid ""
"\"Segmentation fault.\" Some address in the range I<old_address> to "
"I<old_address>+I<old_size> is an invalid virtual memory address for this "
"process.  You can also get B<EFAULT> even if there exist mappings that cover"
" the whole address space requested, but those mappings are of different "
"types."
msgstr "«Ошибка сегментации (Segmentation fault).» Один из адресов в диапазоне от I<old_address> до I<old_address>+I<old_size> является некорректным адресом виртуальной памяти для этого процесса. Также вы можете получить B<EFAULT> даже если существующие отображения покрывают всё запрошенное адресное пространство, но имеют различные типы."

#. type: Plain text
#: man-pages/man2/mremap.2:170
msgid "An invalid argument was given.  Possible causes are:"
msgstr "Указан недопустимый аргумент. Возможные причины:"

#. type: Plain text
#: man-pages/man2/mremap.2:174
msgid "I<old_address> was not page aligned;"
msgstr "не выровнено значение адреса I<old_address>;"

#. type: Plain text
#: man-pages/man2/mremap.2:181
msgid ""
"a value other than B<MREMAP_MAYMOVE> or B<MREMAP_FIXED> was specified in "
"I<flags>;"
msgstr "помимо B<MREMAP_MAYMOVE> или B<MREMAP_FIXED> в I<flags> указано что-то ещё;"

#. type: Plain text
#: man-pages/man2/mremap.2:184
msgid "I<new_size> was zero;"
msgstr "значение I<new_size> равно нулю;"

#. type: Plain text
#: man-pages/man2/mremap.2:189
msgid "I<new_size> or I<new_address> was invalid;"
msgstr "некорректное значение I<new_size> или I<new_address>;"

#. type: Plain text
#: man-pages/man2/mremap.2:198
msgid ""
"the new address range specified by I<new_address> and I<new_size> overlapped"
" the old address range specified by I<old_address> and I<old_size>;"
msgstr "новый диапазон адресов, указанный I<new_address> и I<new_size>, перекрывает старый диапазон адресов, указанный I<old_address> и I<old_size>;"

#. type: Plain text
#: man-pages/man2/mremap.2:202
msgid ""
"B<MREMAP_FIXED> was specified without also specifying B<MREMAP_MAYMOVE>;"
msgstr "задан B<MREMAP_FIXED> без B<MREMAP_MAYMOVE>;"

#. type: Plain text
#: man-pages/man2/mremap.2:205
msgid ""
"I<old_size> was zero and I<old_address> does not refer to a shareable "
"mapping (but see BUGS);"
msgstr "значение I<old_size> равно нулю и I<old_address> не указывает на общее отображение (но смотрите ДЕФЕКТЫ);"

#. type: Plain text
#: man-pages/man2/mremap.2:209
msgid "I<old_size> was zero and the B<MREMAP_MAYMOVE> flag was not specified."
msgstr "значение I<old_size> равно нулю и не указан флаг B<MREMAP_MAYMOVE>."

#. type: Plain text
#: man-pages/man2/mremap.2:216
msgid ""
"The memory area cannot be expanded at the current virtual address, and the "
"B<MREMAP_MAYMOVE> flag is not set in I<flags>.  Or, there is not enough "
"(virtual) memory available."
msgstr "Область памяти не может быть расширена от текущего виртуального адреса и в I<flags> не указано значение B<MREMAP_MAYMOVE>. Или недостаточно свободной (виртуальной) памяти."

#.  4.2BSD had a (never actually implemented)
#.  .BR mremap (2)
#.  call with completely different semantics.
#. type: Plain text
#: man-pages/man2/mremap.2:222
msgid ""
"This call is Linux-specific, and should not be used in programs intended to "
"be portable."
msgstr "Данный вызов существует только в Linux и не должен использоваться в программах, которые должны быть переносимыми."

#. type: Plain text
#: man-pages/man2/mremap.2:230
msgid ""
"Prior to version 2.4, glibc did not expose the definition of "
"B<MREMAP_FIXED>, and the prototype for B<mremap>()  did not allow for the "
"I<new_address> argument."
msgstr "До версии 2.4, в glibc не был определён флаг B<MREMAP_FIXED>, а прототип B<mremap>() не позволял указывать аргумент I<new_address>."

#. type: Plain text
#: man-pages/man2/mremap.2:241
msgid ""
"If B<mremap>()  is used to move or expand an area locked with B<mlock>(2)  "
"or equivalent, the B<mremap>()  call will make a best effort to populate the"
" new area but will not fail with B<ENOMEM> if the area cannot be populated."
msgstr "Если B<mremap>() используется для перемещения или расширения области, заблокированной B<mlock>(2) или эквивалентом, то вызов B<mremap>() постарается заполнить новую область, но не завершится с ошибкой B<ENOMEM>, если область невозможно заполнить."

#.  commit dba58d3b8c5045ad89c1c95d33d01451e3964db7
#. type: Plain text
#: man-pages/man2/mremap.2:262
msgid ""
"Before Linux 4.14, if I<old_size> was zero and the mapping referred to by "
"I<old_address> was a private mapping (B<mmap>(2) B<MAP_PRIVATE>), "
"B<mremap>()  created a new private mapping unrelated to the original "
"mapping.  This behavior was unintended and probably unexpected in user-space"
" applications (since the intention of B<mremap>()  is to create a new "
"mapping based on the original mapping).  Since Linux 4.14, B<mremap>()  "
"fails with the error B<EINVAL> in this scenario."
msgstr "До Linux 4.14, если I<old_size> равно нулю и отображение, на которое указывает I<old_address> — частное отображение (B<mmap>(2) B<MAP_PRIVATE>), то вызов B<mremap>() создавал новое частное отображение, не относящееся к первоначальному отображению. Такое поведение не предусматривалось и, вероятно, не ожидается в приложениях пользовательского пространства (так предназначение B<mremap>() — создание нового отображения на основе первоначального). Начиная с Linux 4.14, в этом случае B<mremap>() завершается ошибкой B<EINVAL>."

#. type: Plain text
#: man-pages/man2/mremap.2:271
msgid ""
"B<brk>(2), B<getpagesize>(2), B<getrlimit>(2), B<mlock>(2), B<mmap>(2), "
"B<sbrk>(2), B<malloc>(3), B<realloc>(3)"
msgstr "B<brk>(2), B<getpagesize>(2), B<getrlimit>(2), B<mlock>(2), B<mmap>(2), B<sbrk>(2), B<malloc>(3), B<realloc>(3)"

#. type: Plain text
#: man-pages/man2/mremap.2:276
msgid ""
"Your favorite text book on operating systems for more information on paged "
"memory (e.g., I<Modern Operating Systems> by Andrew S.\\& Tanenbaum, "
"I<Inside Linux> by Randolf Bentson, I<The Design of the UNIX Operating "
"System> by Maurice J.\\& Bach)"
msgstr "Описание страничной памяти в вашей любимой книге по операционным системам (например, I<Современные операционные системы> Эндрю С.\\& Таненбаума, I<Внутри Linux> Рэндольфа Бентсона, I<Архитектура операционной системы UNIX > Мориса Дж.\\& Баха)"

#. type: TH
#: man-pages/man2/mbind.2:35
#, no-wrap
msgid "MBIND"
msgstr "MBIND"

#. type: Plain text
#: man-pages/man2/mbind.2:38
msgid "mbind - set memory policy for a memory range"
msgstr "mbind - устанавливает политику на область памяти"

#. type: Plain text
#: man-pages/man2/mbind.2:45
#, no-wrap
msgid ""
"B<long mbind(void *>I<addr>B<, unsigned long >I<len>B<, int >I<mode>B<,>\n"
"B<           const unsigned long *>I<nodemask>B<, unsigned long >I<maxnode>B<,>\n"
"B<           unsigned >I<flags>B<);>\n"
msgstr "B<long mbind(void *>I<addr>B<, unsigned long >I<len>B<, int >I<mode>B<,>\nB<           const unsigned long *>I<nodemask>B<, unsigned long >I<maxnode>B<,>\nB<           unsigned >I<flags>B<);>\n"

#. type: Plain text
#: man-pages/man2/mbind.2:47
#, no-wrap
msgid "Link with I<-lnuma>.\n"
msgstr "Компонуется при указании параметра I<-lnuma>.\n"

#. type: Plain text
#: man-pages/man2/mbind.2:58
msgid ""
"B<mbind>()  sets the NUMA memory policy, which consists of a policy mode and"
" zero or more nodes, for the memory range starting with I<addr> and "
"continuing for I<len> bytes.  The memory policy defines from which node "
"memory is allocated."
msgstr "Вызов B<mbind>() устанавливает политику памяти NUMA, состоящую из режима политики и нуля или более узлов, на область памяти, начинающуюся с I<addr> и длиной I<len> байт. Политикой памяти задаётся на каком узле будет выделяться память."

#. type: Plain text
#: man-pages/man2/mbind.2:80
msgid ""
"If the memory range specified by the I<addr> and I<len> arguments includes "
"an \"anonymous\" region of memory\\(emthat is a region of memory created "
"using the B<mmap>(2)  system call with the B<MAP_ANONYMOUS>\\(emor a memory-"
"mapped file, mapped using the B<mmap>(2)  system call with the "
"B<MAP_PRIVATE> flag, pages will be allocated only according to the specified"
" policy when the application writes (stores) to the page.  For anonymous "
"regions, an initial read access will use a shared page in the kernel "
"containing all zeros.  For a file mapped with B<MAP_PRIVATE>, an initial "
"read access will allocate pages according to the memory policy of the thread"
" that causes the page to be allocated.  This may not be the thread that "
"called B<mbind>()."
msgstr "Если область памяти, заданная аргументами I<addr> и I<len>, включает «анонимную» область памяти — область памяти, созданную с помощью системного вызова B<mmap>(2) с аргументом B<MAP_ANONYMOUS> — или файл, отображённый в память с помощью вызова B<mmap>(2) с флагом B<MAP_PRIVATE>, то страницы будут выделены в соответствии с указанной политикой только когда приложение выполняет запись (сохранение) страницы. Для анонимных областей при первоначальном доступе на чтение будет использоваться общая страница ядра, содержащая только нули. Для отображённого файла с флагом B<MAP_PRIVATE>, при первоначальном доступе на чтение будут выделены страницы в соответствии с политикой памяти нити, для которой происходит выделение страницы. Это может быть не та нить, которая вызвала B<mbind>()."

#. type: Plain text
#: man-pages/man2/mbind.2:88
msgid ""
"The specified policy will be ignored for any B<MAP_SHARED> mappings in the "
"specified memory range.  Rather the pages will be allocated according to the"
" memory policy of the thread that caused the page to be allocated.  Again, "
"this may not be the thread that called B<mbind>()."
msgstr "Указанная политика в заданной области памяти будет игнорироваться для всех отображений B<MAP_SHARED>. Скорее всего, страницы будут выделены согласно политике памяти нити, для которой происходит выделение страницы. Но опять таки, это может быть не та нить, которая вызвала B<mbind>()."

#. type: Plain text
#: man-pages/man2/mbind.2:105
msgid ""
"If the specified memory range includes a shared memory region created using "
"the B<shmget>(2)  system call and attached using the B<shmat>(2)  system "
"call, pages allocated for the anonymous or shared memory region will be "
"allocated according to the policy specified, regardless of which process "
"attached to the shared memory segment causes the allocation.  If, however, "
"the shared memory region was created with the B<SHM_HUGETLB> flag, the huge "
"pages will be allocated according to the policy specified only if the page "
"allocation is caused by the process that calls B<mbind>()  for that region."
msgstr "Если заданная область памяти включает общую область памяти, созданную с помощью системного вызова B<shmget>(2) и подключённую с помощью системного вызова B<shmat>(2), то страницы, выделяемые для анонимной или общей области памяти, будут выделены согласно указанной политике, независимо от того, какой процесс подключил сегмент общей памяти, что вызвало выделение. Однако, если общая область памяти была создана с флагом B<SHM_HUGETLB>, то огромные страницы будут выделяться согласно указанной политике, только если выделение страницы происходит из-за процесса, который вызвал B<mbind>() для этой области."

#. type: Plain text
#: man-pages/man2/mbind.2:116
msgid ""
"By default, B<mbind>()  has an effect only for new allocations; if the pages"
" inside the range have been already touched before setting the policy, then "
"the policy has no effect.  This default behavior may be overridden by the "
"B<MPOL_MF_MOVE> and B<MPOL_MF_MOVE_ALL> flags described below."
msgstr "По умолчанию, B<mbind>() учитывается только при новых выделениях; если страницы внутри области уже были использованы до настройки политики, то политика не применяется. Такое поведение можно изменить с помощью флагов B<MPOL_MF_MOVE> и B<MPOL_MF_MOVE_ALL>, описанных далее."

#. type: Plain text
#: man-pages/man2/mbind.2:133
msgid ""
"The I<mode> argument must specify one of B<MPOL_DEFAULT>, B<MPOL_BIND>, "
"B<MPOL_INTERLEAVE>, B<MPOL_PREFERRED>, or B<MPOL_LOCAL> (which are described"
" in detail below).  All policy modes except B<MPOL_DEFAULT> require the "
"caller to specify the node or nodes to which the mode applies, via the "
"I<nodemask> argument."
msgstr "В  аргументе I<mode> должно быть указано одно из следующих значений: B<MPOL_DEFAULT>, B<MPOL_BIND>, B<MPOL_INTERLEAVE>, B<MPOL_PREFERRED> или B<MPOL_LOCAL> (описано далее). Для всех режимов политики, за исключением B<MPOL_DEFAULT>, требуется, чтобы вызывающий указывал в аргументе I<nodemask> узел или узлы, для которых применяется режим."

#. type: Plain text
#: man-pages/man2/mbind.2:141
msgid ""
"The I<mode> argument may also include an optional I<mode flag>.  The "
"supported I<mode flags> are:"
msgstr "Аргумент I<mode> также может содержать необязательный I<флаг режима>. Поддерживаемые I<флаги режима>:"

#. type: TP
#: man-pages/man2/mbind.2:141
#, no-wrap
msgid "B<MPOL_F_STATIC_NODES> (since Linux-2.6.26)"
msgstr "B<MPOL_F_STATIC_NODES> (начиная с Linux-2.6.26)"

#. type: Plain text
#: man-pages/man2/mbind.2:151
msgid ""
"A nonempty I<nodemask> specifies physical node IDs.  Linux does not remap "
"the I<nodemask> when the thread moves to a different cpuset context, nor "
"when the set of nodes allowed by the thread's current cpuset context "
"changes."
msgstr "В аргументе I<nodemask> указываются идентификаторы физических узлов. Linux не пересоставляет I<nodemask>, если нить перемещается в другой контекст набора процессоров или когда изменяется набор узлов, который доступен нити согласно текущему контексту набора процессоров."

#. type: TP
#: man-pages/man2/mbind.2:151
#, no-wrap
msgid "B<MPOL_F_RELATIVE_NODES> (since Linux-2.6.26)"
msgstr "B<MPOL_F_RELATIVE_NODES> (начиная с Linux-2.6.26)"

#. type: Plain text
#: man-pages/man2/mbind.2:157
msgid ""
"A nonempty I<nodemask> specifies node IDs that are relative to the set of "
"node IDs allowed by the thread's current cpuset."
msgstr "В аргументе I<nodemask> указываются идентификаторы узлов из набора идентификаторов узлов, разрешённых нити текущим контекстом набора процессоров."

#. type: Plain text
#: man-pages/man2/mbind.2:185
msgid ""
"I<nodemask> points to a bit mask of nodes containing up to I<maxnode> bits."
"  The bit mask size is rounded to the next multiple of I<sizeof(unsigned "
"long)>, but the kernel will use bits only up to I<maxnode>.  A NULL value of"
" I<nodemask> or a I<maxnode> value of zero specifies the empty set of nodes."
"  If the value of I<maxnode> is zero, the I<nodemask> argument is ignored.  "
"Where a I<nodemask> is required, it must contain at least one node that is "
"on-line, allowed by the thread's current cpuset context (unless the "
"B<MPOL_F_STATIC_NODES> mode flag is specified), and contains memory."
msgstr "В I<nodemask> содержится битовая маска узлов, в которой содержится до I<maxnode> бит. Размер битовой маски округляется до следующего кратного значения I<sizeof(unsigned long)>, но ядром будет использовано только до I<maxnode> бит. Значением NULL в I<nodemask> или значением I<maxnode> равным 0 задаётся пустой набор узлов. Если значение I<maxnode> равно 0, то аргумент I<nodemask> игнорируется. Там, где требуется I<nodemask>, его значение должно содержать, как минимум, один работающий узел, который разрешён нити текущим контекстом набора процессоров (если не указан флаг B<MPOL_F_STATIC_NODES>) и у которого имеется память."

#. type: Plain text
#: man-pages/man2/mbind.2:189
msgid "The I<mode> argument must include one of the following values:"
msgstr "Аргумент I<mode> должен включать одно из следующих значений:"

#. type: TP
#: man-pages/man2/mbind.2:189
#, no-wrap
msgid "B<MPOL_DEFAULT>"
msgstr "B<MPOL_DEFAULT>"

#. type: Plain text
#: man-pages/man2/mbind.2:210
msgid ""
"This mode requests that any nondefault policy be removed, restoring default "
"behavior.  When applied to a range of memory via B<mbind>(), this means to "
"use the thread memory policy, which may have been set with "
"B<set_mempolicy>(2).  If the mode of the thread memory policy is also "
"B<MPOL_DEFAULT>, the system-wide default policy will be used.  The system-"
"wide default policy allocates pages on the node of the CPU that triggers the"
" allocation.  For B<MPOL_DEFAULT>, the I<nodemask> and I<maxnode> arguments "
"must be specify the empty set of nodes."
msgstr "Этот режим запрашивает удаление любой политики не по умолчанию и восстановление поведения по умолчанию. Если он применяется к области памяти посредством B<mbind>(), то это означает использование политики памяти нити, которая могла быть установлена с помощью B<set_mempolicy>(2). Если режим политики памяти нити также равен B<MPOL_DEFAULT>, то будет задействована системная политика по умолчанию. При системной политике по умолчанию выделяются страницы на том узле ЦП, на котором было запрошено выделение. Для B<MPOL_DEFAULT> в аргументах I<nodemask> и I<maxnode> должен быть указан пустой набор узлов."

#. type: TP
#: man-pages/man2/mbind.2:210
#, no-wrap
msgid "B<MPOL_BIND>"
msgstr "B<MPOL_BIND>"

#.  commit 19770b32609b6bf97a3dece2529089494cbfc549
#. type: Plain text
#: man-pages/man2/mbind.2:231
msgid ""
"This mode specifies a strict policy that restricts memory allocation to the "
"nodes specified in I<nodemask>.  If I<nodemask> specifies more than one "
"node, page allocations will come from the node with sufficient free memory "
"that is closest to the node where the allocation takes place.  Pages will "
"not be allocated from any node not specified in the IR nodemask .  (Before "
"Linux 2.6.26, page allocations came from the node with the lowest numeric "
"node ID first, until that node contained no free memory.  Allocations then "
"came from the node with the next highest node ID specified in I<nodemask> "
"and so forth, until none of the specified nodes contained free memory.)"
msgstr "Этот режим задаёт жёсткую политику, при которой выделение памяти ограничено узлами, заданными в I<nodemask>. Если в I<nodemask> указано более одного узла, то выделение страниц начнётся с узла с достаточным объёмом свободной памяти, который наиболее близок к узлу, где запрошено выделение. Страницы не выделяются на узлах, не указанных в IR nodemask(до Linux 2.6.26 выделение страниц происходило начиная с узла с меньшим номером идентификатора, и продолжится до тех пор, пока на нём не кончится свободная память. Затем выделение продолжится на узле со следующим большим номером идентификатора, указанного в I<nodemask>, и т.д. до тех пор, пока на всех заданных узлах не закончится свободная память)."

#. type: TP
#: man-pages/man2/mbind.2:231
#, no-wrap
msgid "B<MPOL_INTERLEAVE>"
msgstr "B<MPOL_INTERLEAVE>"

#. type: Plain text
#: man-pages/man2/mbind.2:243
msgid ""
"This mode specifies that page allocations be interleaved across the set of "
"nodes specified in I<nodemask>.  This optimizes for bandwidth instead of "
"latency by spreading out pages and memory accesses to those pages across "
"multiple nodes.  To be effective the memory area should be fairly large, at "
"least 1\\ MB or bigger with a fairly uniform access pattern.  Accesses to a "
"single page of the area will still be limited to the memory bandwidth of a "
"single node."
msgstr "Этот режим задаёт, что при выделении страниц нужно выполнять чередование узлов, которые указаны в I<nodemask>. Это оптимизирует использование полосы пропускания, но не задержку, вовлекая при доступ к страницам и памяти множество узлов. Чтобы это дало эффект, область памяти должна быть достаточно большой, не менее 1\\ МБ или более, и характер доступа должен быть достаточно равномерным. Доступ к одной странице области будет по прежнему ограничен размером полосы пропускания одного узла."

#. type: TP
#: man-pages/man2/mbind.2:243
#, no-wrap
msgid "B<MPOL_PREFERRED>"
msgstr "B<MPOL_PREFERRED>"

#. type: Plain text
#: man-pages/man2/mbind.2:259
msgid ""
"This mode sets the preferred node for allocation.  The kernel will try to "
"allocate pages from this node first and fall back to other nodes if the "
"preferred nodes is low on free memory.  If I<nodemask> specifies more than "
"one node ID, the first node in the mask will be selected as the preferred "
"node.  If the I<nodemask> and I<maxnode> arguments specify the empty set, "
"then the memory is allocated on the node of the CPU that triggered the "
"allocation."
msgstr "В этом режиме устанавливается предпочтительный узел для выделения. Ядро сначала будет пытаться выделить страницы на этом узле и перейдёт на другие узлы, если на предпочтительном узле недостаточно свободной памяти. Если в I<nodemask> задано более одного идентификатора узла, то в качестве предпочтительного будет выбран первый из маски. Если в аргументах I<nodemask> и I<maxnode> указан пустой набор, то память будет выделена на узле ЦП, на котором запросили выделение."

#. type: TP
#: man-pages/man2/mbind.2:259
#, no-wrap
msgid "B<MPOL_LOCAL> (since Linux 3.8)"
msgstr "B<MPOL_LOCAL> (начиная с Linux 3.8)"

#.  commit 479e2802d09f1e18a97262c4c6f8f17ae5884bd8
#.  commit f2a07f40dbc603c15f8b06e6ec7f768af67b424f
#. type: Plain text
#: man-pages/man2/mbind.2:283
msgid ""
"This mode specifies \"local allocation\"; the memory is allocated on the "
"node of the CPU that triggered the allocation (the \"local node\").  The "
"I<nodemask> and I<maxnode> arguments must specify the empty set.  If the "
"\"local node\" is low on free memory, the kernel will try to allocate memory"
" from other nodes.  The kernel will allocate memory from the \"local node\" "
"whenever memory for this node is available.  If the \"local node\" is not "
"allowed by the thread's current cpuset context, the kernel will try to "
"allocate memory from other nodes.  The kernel will allocate memory from the "
"\"local node\" whenever it becomes allowed by the thread's current cpuset "
"context.  By contrast, B<MPOL_DEFAULT> reverts to the memory policy of the "
"thread (which may be set via B<set_mempolicy>(2)); that policy may be "
"something other than \"local allocation\"."
msgstr "Этот режим устанавливает «локальное выделение»; памяти выделяется на узле с ЦП, на котором запросили выделение («локальный узел»). Аргументы I<nodemask> и I<maxnode> должны содержать пустой набор. Если на «локальном узле» не хватает свободной памяти, то ядро попытается выделить память на других узлах. Ядро выделит памяти на «локальном узле» сколько бы ни было на нём памяти. Если «локальный узел» не разрешён для нити текущим контекстом набора процессоров, то ядро попытается выделить память на других узлах. Ядро выделит памяти на «локальном узле» независимо от того, станет ли он разрешённым для нити текущим контекстом набора процессоров. В отличии от этого , B<MPOL_DEFAULT> восстанавливает политику памяти нити (которая может быть задана с помощью B<set_mempolicy>(2)); эта политика может быть другой, не «локальным выделением»."

#.  According to the kernel code, the following is not true
#.  --Lee Schermerhorn
#.  In 2.6.16 or later the kernel will also try to move pages
#.  to the requested node with this flag.
#. type: Plain text
#: man-pages/man2/mbind.2:299
msgid ""
"If B<MPOL_MF_STRICT> is passed in I<flags> and I<mode> is not "
"B<MPOL_DEFAULT>, then the call fails with the error B<EIO> if the existing "
"pages in the memory range don't follow the policy."
msgstr "Если в I<flags> указан B<MPOL_MF_STRICT> и I<mode> не равно B<MPOL_DEFAULT>, то вызов завершается ошибкой B<EIO>, если существующие страницы в области памяти не следуют политике."

#. type: Plain text
#: man-pages/man2/mbind.2:312
msgid ""
"If B<MPOL_MF_MOVE> is specified in I<flags>, then the kernel will attempt to"
" move all the existing pages in the memory range so that they follow the "
"policy.  Pages that are shared with other processes will not be moved.  If "
"B<MPOL_MF_STRICT> is also specified, then the call fails with the error "
"B<EIO> if some pages could not be moved."
msgstr "Если в I<flags> указан B<MPOL_MF_MOVE>, то ядро будет пытаться переместить все существующие страницы в области памяти так, чтобы они следовали политике. Страницы, используемые совместно с другими процессами, перемещаться не будут. Если также указан B<MPOL_MF_STRICT>, что вызов завершается ошибкой B<EIO>, если страницы не могут быть перемещены."

#.  ---------------------------------------------------------------
#. type: Plain text
#: man-pages/man2/mbind.2:328
msgid ""
"If B<MPOL_MF_MOVE_ALL> is passed in I<flags>, then the kernel will attempt "
"to move all existing pages in the memory range regardless of whether other "
"processes use the pages.  The calling thread must be privileged "
"(B<CAP_SYS_NICE>)  to use this flag.  If B<MPOL_MF_STRICT> is also "
"specified, then the call fails with the error B<EIO> if some pages could not"
" be moved."
msgstr "Если в I<flags> указан B<MPOL_MF_MOVE_ALL>, то ядро будет пытаться переместить все существующие страницы в области памяти независимо от того, используются ли они другими процессами. Для использования данного флага вызывающая нить должна быть привилегированной (B<CAP_SYS_NICE>). Если также указан B<MPOL_MF_STRICT>, то вызов завершается ошибкой B<EIO>, если некоторые страницы нельзя переместить."

#.  ---------------------------------------------------------------
#. type: Plain text
#: man-pages/man2/mbind.2:336
msgid ""
"On success, B<mbind>()  returns 0; on error, -1 is returned and I<errno> is "
"set to indicate the error."
msgstr "При успешном выполнении B<mbind>() возвращается 0. При ошибке возвращается -1, а в I<errno> содержится код ошибки."

#. type: Plain text
#: man-pages/man2/mbind.2:349
msgid ""
"Part or all of the memory range specified by I<nodemask> and I<maxnode> "
"points outside your accessible address space.  Or, there was an unmapped "
"hole in the specified memory range specified by I<addr> and I<len>."
msgstr "Часть или вся область памяти, заданная в I<nodemask> и I<maxnode>, указывает за пределы доступного адресного пространства. Или в области памяти, задаваемой I<addr> и I<len>, есть неотображаемая дыра (hole)."

#.  As at 2.6.23, this limit is "a page worth of bits", e.g.,
#.  8 * 4096 bits, assuming a 4kB page size.
#. type: Plain text
#: man-pages/man2/mbind.2:397
msgid ""
"An invalid value was specified for I<flags> or I<mode>; or I<addr + len> was"
" less than I<addr>; or I<addr> is not a multiple of the system page size.  "
"Or, I<mode> is B<MPOL_DEFAULT> and I<nodemask> specified a nonempty set; or "
"I<mode> is B<MPOL_BIND> or B<MPOL_INTERLEAVE> and I<nodemask> is empty.  Or,"
" I<maxnode> exceeds a kernel-imposed limit.  Or, I<nodemask> specifies one "
"or more node IDs that are greater than the maximum supported node ID.  Or, "
"none of the node IDs specified by I<nodemask> are on-line and allowed by the"
" thread's current cpuset context, or none of the specified nodes contain "
"memory.  Or, the I<mode> argument specified both B<MPOL_F_STATIC_NODES> and "
"B<MPOL_F_RELATIVE_NODES>."
msgstr "В I<flags> или I<mode> указано неправильное значение; или I<addr + len> меньше чем I<addr>; или I<addr> не кратен системному размеру страницы. Или I<mode> равен B<MPOL_DEFAULT> и в I<nodemask> задан непустой набор; или I<mode> равен B<MPOL_BIND> или B<MPOL_INTERLEAVE> и значение I<nodemask> пусто. Или значение I<maxnode> превышает устанавливаемое ядром ограничение. Или в I<nodemask> задан один или более идентификаторов узлов, номер которого больше чем максимально поддерживаемый. Или в I<nodemask> не задано ни одного идентификатора узла, включённого в данный момент и разрешённого нити текущим контекстом набора процессоров, или ни один из указанных узлов не содержит память. Или в аргументе I<mode> указаны сразу B<MPOL_F_STATIC_NODES> и B<MPOL_F_RELATIVE_NODES>."

#. type: Plain text
#: man-pages/man2/mbind.2:408
msgid ""
"B<MPOL_MF_STRICT> was specified and an existing page was already on a node "
"that does not follow the policy; or B<MPOL_MF_MOVE> or B<MPOL_MF_MOVE_ALL> "
"was specified and the kernel was unable to move all existing pages in the "
"range."
msgstr "Был указан B<MPOL_MF_STRICT> и существующая страница была уже на узле, что не следует политике; или был указан B<MPOL_MF_MOVE> или B<MPOL_MF_MOVE_ALL> и ядро не смогло переместить все существующие страницы области."

#.  ---------------------------------------------------------------
#. type: Plain text
#: man-pages/man2/mbind.2:421
msgid ""
"The I<flags> argument included the B<MPOL_MF_MOVE_ALL> flag and the caller "
"does not have the B<CAP_SYS_NICE> privilege."
msgstr "Аргумент I<flags> содержит флаг B<MPOL_MF_MOVE_ALL> и вызывающий не имеет мандата B<CAP_SYS_NICE>."

#. type: Plain text
#: man-pages/man2/mbind.2:425
msgid ""
"The B<mbind>()  system call was added to the Linux kernel in version 2.6.7."
msgstr "Системный вызов B<mbind>() был добавлен в ядро Linux версии 2.6.7."

#. type: Plain text
#: man-pages/man2/mbind.2:435
msgid ""
"NUMA policy is not supported on a memory-mapped file range that was mapped "
"with the B<MAP_SHARED> flag."
msgstr "Политика NUMA не поддерживается для области памяти отображения файла, который отображён с флагом B<MAP_SHARED>."

#. type: Plain text
#: man-pages/man2/mbind.2:469
msgid ""
"The B<MPOL_DEFAULT> mode can have different effects for B<mbind>()  and "
"B<set_mempolicy>(2).  When B<MPOL_DEFAULT> is specified for "
"B<set_mempolicy>(2), the thread's memory policy reverts to the system "
"default policy or local allocation.  When B<MPOL_DEFAULT> is specified for a"
" range of memory using B<mbind>(), any pages subsequently allocated for that"
" range will use the thread's memory policy, as set by B<set_mempolicy>(2).  "
"This effectively removes the explicit policy from the specified range, "
"\"falling back\" to a possibly nondefault policy.  To select explicit "
"\"local allocation\" for a memory range, specify a I<mode> of B<MPOL_LOCAL> "
"or B<MPOL_PREFERRED> with an empty set of nodes.  This method will work for "
"B<set_mempolicy>(2), as well."
msgstr "Режим B<MPOL_DEFAULT> может по разному влиять на B<mbind>() и B<set_mempolicy>(2). Когда указан B<MPOL_DEFAULT> для B<set_mempolicy>(2), политика памяти нити возвращается к политике по умолчанию или локальному выделению. Когда B<MPOL_DEFAULT> указан для области памяти, используемой B<mbind>(), все страницы, последовательно выделяемые для этой области, будут использовать политику памяти нити, которая задана с помощью B<set_mempolicy>(2). Это эффективно удаляет явную политику из указанной области, «откатываясь» к возможной политике не по умолчанию. Для выбора явного «локального выделения» области памяти, укажите в I<mode> значение B<MPOL_LOCAL> или B<MPOL_PREFERRED> с пустым набором узлов. Этот метод также сработает и в вызове B<set_mempolicy>(2)."

#. type: Plain text
#: man-pages/man2/mbind.2:473
msgid ""
"Support for huge page policy was added with 2.6.16.  For interleave policy "
"to be effective on huge page mappings the policied memory needs to be tens "
"of megabytes or larger."
msgstr "Поддержка политики для огромных страниц была добавлена в версию 2.6.16. Для эффективной работы политики чередования на огромных страничных отображениях, контролируемая память должна измеряться десятками мегабайт или больше."

#. type: Plain text
#: man-pages/man2/mbind.2:476
msgid "B<MPOL_MF_STRICT> is ignored on huge page mappings."
msgstr "Режим B<MPOL_MF_STRICT> игнорируется для огромных страничных отображений."

#. type: Plain text
#: man-pages/man2/mbind.2:481
msgid ""
"B<MPOL_MF_MOVE> and B<MPOL_MF_MOVE_ALL> are available only on Linux 2.6.16 "
"and later."
msgstr "Режимы B<MPOL_MF_MOVE> и B<MPOL_MF_MOVE_ALL> доступны только в Linux 2.6.16 и новее."

#. type: Plain text
#: man-pages/man2/mbind.2:491
msgid ""
"B<get_mempolicy>(2), B<getcpu>(2), B<mmap>(2), B<set_mempolicy>(2), "
"B<shmat>(2), B<shmget>(2), B<numa>(3), B<cpuset>(7), B<numa>(7), "
"B<numactl>(8)"
msgstr "B<get_mempolicy>(2), B<getcpu>(2), B<mmap>(2), B<set_mempolicy>(2), B<shmat>(2), B<shmget>(2), B<numa>(3), B<cpuset>(7), B<numa>(7), B<numactl>(8)"

#. type: TH
#: man-pages/man2/mq_getsetattr.2:26
#, no-wrap
msgid "MQ_GETSETATTR"
msgstr "MQ_GETSETATTR"

#. type: Plain text
#: man-pages/man2/mq_getsetattr.2:29
msgid "mq_getsetattr - get/set message queue attributes"
msgstr "mq_getsetattr - получить/установить атрибуты очереди сообщений"

#. type: Plain text
#: man-pages/man2/mq_getsetattr.2:33
#, no-wrap
msgid ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>mqueue.hE<gt>>\n"
msgstr "B<#include E<lt>sys/types.hE<gt>>\nB<#include E<lt>mqueue.hE<gt>>\n"

#. type: Plain text
#: man-pages/man2/mq_getsetattr.2:36
#, no-wrap
msgid ""
"B<int mq_getsetattr(mqd_t >I<mqdes>B<, struct mq_attr *>I<newattr>B<,>\n"
"B<                 struct mq_attr *>I<oldattr>B<);>\n"
msgstr "B<int mq_getsetattr(mqd_t >I<mqdes>B<, struct mq_attr *>I<newattr>B<,>\nB<                 struct mq_attr *>I<oldattr>B<);>\n"

#. type: Plain text
#: man-pages/man2/mq_getsetattr.2:42
msgid "Do not use this system call."
msgstr "Не используйте этот системный вызов."

#. type: Plain text
#: man-pages/man2/mq_getsetattr.2:50
msgid ""
"This is the low-level system call used to implement B<mq_getattr>(3)  and "
"B<mq_setattr>(3).  For an explanation of how this system call operates, see "
"the description of B<mq_setattr>(3)."
msgstr "Этот низкоуровневый системный вызов используется для реализации функций B<mq_getattr>(3) и B<mq_setattr>(3). Более подробно о работе этого системного вызова можно узнать на странице B<mq_setattr>(3)."

#. type: Plain text
#: man-pages/man2/mq_getsetattr.2:52
msgid "This interface is nonstandard; avoid its use."
msgstr "Этот интерфейс является нестандартным, не используйте его."

#. type: Plain text
#: man-pages/man2/mq_getsetattr.2:56
msgid ""
"Glibc does not provide a wrapper for this system call; call it using "
"B<syscall>(2).  (Actually, never call it unless you are writing a C "
"library!)"
msgstr "Glibc не предоставляет обертку (wrapper) для этого системного вызова; используйте B<syscall>(2). (Даже не вызывайте его, если не пишете C библиотеку!)"

#. type: Plain text
#: man-pages/man2/mq_getsetattr.2:58
msgid "B<mq_getattr>(3), B<mq_overview>(7)"
msgstr "B<mq_getattr>(3), B<mq_overview>(7)"

#. type: TH
#: man-pages/man5/motd.5:27
#, no-wrap
msgid "MOTD"
msgstr "MOTD"

#. type: TH
#: man-pages/man5/motd.5:27
#, no-wrap
msgid "1992-12-29"
msgstr "1992-12-29"

#. type: Plain text
#: man-pages/man5/motd.5:30
msgid "motd - message of the day"
msgstr "motd - сообщение дня"

#. type: Plain text
#: man-pages/man5/motd.5:36
msgid ""
"The contents of I</etc/motd> are displayed by B<login>(1)  after a "
"successful login but just before it executes the login shell."
msgstr "Содержимое файла I</etc/motd> отображается программой B<login>(1) после осуществления успешного входа в систему, перед запуском командного интерпретатора."

#. type: Plain text
#: man-pages/man5/motd.5:40
msgid ""
"The abbreviation \"motd\" stands for \"message of the day\", and this file "
"has been traditionally used for exactly that (it requires much less disk "
"space than mail to all users)."
msgstr "Сокращение \"motd\" расшифровывается как \"message of the day\" (сообщение дня), и данный файл традиционно используется именно для этой цели (он требует гораздо меньше дискового пространства, чем почтовое сообщение каждому пользователю)."

#. type: Plain text
#: man-pages/man5/motd.5:42
msgid "I</etc/motd>"
msgstr "I</etc/motd>"

#. type: Plain text
#: man-pages/man5/motd.5:44
msgid "B<login>(1), B<issue>(5)"
msgstr "B<login>(1), B<issue>(5)"

#. type: TH
#: man-pages/man3/mbtowc.3:16
#, no-wrap
msgid "MBTOWC"
msgstr "MBTOWC"

#. type: Plain text
#: man-pages/man3/mbtowc.3:19
msgid "mbtowc - convert a multibyte sequence to a wide character"
msgstr "mbtowc - преобразовывает мультибайтовую последовательность в широкий символ"

#. type: Plain text
#: man-pages/man3/mbtowc.3:22
#, no-wrap
msgid "B<#include E<lt>stdlib.hE<gt>>\n"
msgstr "B<#include E<lt>stdlib.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/mbtowc.3:24
#, no-wrap
msgid ""
"B<int mbtowc(wchar_t *>I<pwc>B<, const char *>I<s>B<, size_t >I<n>B<);>\n"
msgstr "B<int mbtowc(wchar_t *>I<pwc>B<, const char *>I<s>B<, size_t >I<n>B<);>\n"

#. type: Plain text
#: man-pages/man3/mbtowc.3:50
msgid ""
"The main case for this function is when I<s> is not NULL and I<pwc> is not "
"NULL.  In this case, the B<mbtowc>()  function inspects at most I<n> bytes "
"of the multibyte string starting at I<s>, extracts the next complete "
"multibyte character, converts it to a wide character and stores it at "
"I<*pwc>.  It updates an internal shift state known only to the B<mbtowc>()  "
"function.  If I<s> does not point to a null byte (\\(aq\\e0\\(aq), it "
"returns the number of bytes that were consumed from I<s>, otherwise it "
"returns 0."
msgstr "Обычно в эту функцию передают I<s> и I<pwc> не равные NULL. В этом случае функция B<mbtowc>() просматривает не более I<n> байт многобайтовой строки, начиная с I<s>, извлекает следующий полный многобайтовый символ, преобразует его в широкий символ и сохраняет его в I<*pwc>. Она обновляет внутренне состояние сдвига, доступное только функции B<mbtowc>(). Если I<s> не указывает на байт null (\\(aq\\e0\\(aq), то она возвращает количество байт, которые были потрачены из I<s>, в противном случае возвращается 0."

#. type: Plain text
#: man-pages/man3/mbtowc.3:64
msgid ""
"If the I<n> bytes starting at I<s> do not contain a complete multibyte "
"character, or if they contain an invalid multibyte sequence, B<mbtowc>()  "
"returns -1.  This can happen even if I<n> E<gt>= I<MB_CUR_MAX>, if the "
"multibyte string contains redundant shift sequences."
msgstr "Если в I<n> байтах, начиная с I<s>, не содержится полного многобайтового символа или если в них содержится некорректный многобайтовый символ, то B<mbtowc>() возвращает -1. Это может произойти даже если I<n> E<gt>= I<MB_CUR_MAX>, если в многобайтовой строке содержится лишние сдвиговые последовательности."

#. type: Plain text
#: man-pages/man3/mbtowc.3:74
msgid ""
"A different case is when I<s> is not NULL but I<pwc> is NULL.  In this case,"
" the B<mbtowc>()  function behaves as above, except that it does not store "
"the converted wide character in memory."
msgstr "Ещё случай, когда I<s> не равно NULL, а I<pwc> равно NULL. В этом случае функция B<mbtowc>() действует как описано выше, но не сохраняет преобразованный широкий символ в памяти."

#.  The Dinkumware doc and the Single UNIX specification say this, but
#.  glibc doesn't implement this.
#. type: Plain text
#: man-pages/man3/mbtowc.3:93
msgid ""
"A third case is when I<s> is NULL.  In this case, I<pwc> and I<n> are "
"ignored.  The B<mbtowc>()  function resets the shift state, only known to "
"this function, to the initial state, and returns nonzero if the encoding has"
" nontrivial shift state, or zero if the encoding is stateless."
msgstr "И третий вариант, когда I<s> равно NULL. В этом случае I<pwc> и I<n> игнорируются. Функция B<mbtowc>() сбрасывает состояние сдвига, известное только ей, в начальное состояние и возвращает не ноль, если кодировка имеет непростое состояние сдвига, или ноль, если кодировка не имеет состояний."

#. type: Plain text
#: man-pages/man3/mbtowc.3:105
msgid ""
"If I<s> is not NULL, the B<mbtowc>()  function returns the number of "
"consumed bytes starting at I<s>, or 0 if I<s> points to a null byte, or -1 "
"upon failure."
msgstr "Если I<s> не равно NULL, то функция B<mbtowc>() возвращает количество потраченных байт, начиная с I<s>, или 0, если I<s> указывает на байт null, или -1 — при ошибке."

#. type: Plain text
#: man-pages/man3/mbtowc.3:113
msgid ""
"If I<s> is NULL, the B<mbtowc>()  function returns nonzero if the encoding "
"has nontrivial shift state, or zero if the encoding is stateless."
msgstr "Если значение I<s> равно NULL, то функция B<mbtowc>() возвращает не ноль, если кодировка имеет необычное смещение, или ноль, если кодировка не имеет смещения."

#. type: tbl table
#: man-pages/man3/mbtowc.3:123
#, no-wrap
msgid "B<mbtowc>()"
msgstr "B<mbtowc>()"

#. type: tbl table
#: man-pages/man3/mbtowc.3:123
#, no-wrap
msgid "MT-Unsafe race"
msgstr "MT-Unsafe race"

#. type: Plain text
#: man-pages/man3/mbtowc.3:127
msgid "POSIX.1-2001, POSIX.1-2008, C99."
msgstr "POSIX.1-2001, POSIX.1-2008, C99."

#. type: Plain text
#: man-pages/man3/mbtowc.3:134
msgid ""
"The behavior of B<mbtowc>()  depends on the B<LC_CTYPE> category of the "
"current locale."
msgstr "Поведение B<mbtowc>() зависит от категории B<LC_CTYPE> текущей локали."

#. type: Plain text
#: man-pages/man3/mbtowc.3:140
msgid ""
"This function is not multithread safe.  The function B<mbrtowc>(3)  provides"
" a better interface to the same functionality."
msgstr "Данную функцию небезопасно использовать в нитях. Для этого лучше подходит функция B<mbrtowc>(3) с тем же интерфейсом."

#. type: Plain text
#: man-pages/man3/mbtowc.3:146
msgid ""
"B<MB_CUR_MAX>(3), B<mblen>(3), B<mbrtowc>(3), B<mbstowcs>(3), "
"B<wcstombs>(3), B<wctomb>(3)"
msgstr "B<MB_CUR_MAX>(3), B<mblen>(3), B<mbrtowc>(3), B<mbstowcs>(3), B<wcstombs>(3), B<wctomb>(3)"

#. type: TH
#: man-pages/man3/mq_receive.3:26
#, no-wrap
msgid "MQ_RECEIVE"
msgstr "MQ_RECEIVE"

#. type: Plain text
#: man-pages/man3/mq_receive.3:29
msgid "mq_receive, mq_timedreceive - receive a message from a message queue"
msgstr "mq_receive, mq_timedreceive - выбирают сообщения из очереди сообщений"

#. type: Plain text
#: man-pages/man3/mq_receive.3:32
#, no-wrap
msgid "B<#include E<lt>mqueue.hE<gt>>\n"
msgstr "B<#include E<lt>mqueue.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/mq_receive.3:35
#, no-wrap
msgid ""
"B<ssize_t mq_receive(mqd_t >I<mqdes>B<, char *>I<msg_ptr>B<,>\n"
"B<                   size_t >I<msg_len>B<, unsigned int *>I<msg_prio>B<);>\n"
msgstr "B<ssize_t mq_receive(mqd_t >I<mqdes>B<, char *>I<msg_ptr>B<,>\nB<                   size_t >I<msg_len>B<, unsigned int *>I<msg_prio>B<);>\n"

#. type: Plain text
#: man-pages/man3/mq_receive.3:38
#, no-wrap
msgid ""
"B<#include E<lt>time.hE<gt>>\n"
"B<#include E<lt>mqueue.hE<gt>>\n"
msgstr "B<#include E<lt>time.hE<gt>>\nB<#include E<lt>mqueue.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/mq_receive.3:42
#, no-wrap
msgid ""
"B<ssize_t mq_timedreceive(mqd_t >I<mqdes>B<, char *>I<msg_ptr>B<,>\n"
"B<                   size_t >I<msg_len>B<, unsigned int *>I<msg_prio>B<,>\n"
"B<                   const struct timespec *>I<abs_timeout>B<);>\n"
msgstr "B<ssize_t mq_timedreceive(mqd_t >I<mqdes>B<, char *>I<msg_ptr>B<,>\nB<                   size_t >I<msg_len>B<, unsigned int *>I<msg_prio>B<,>\nB<                   const struct timespec *>I<abs_timeout>B<);>\n"

#. type: Plain text
#: man-pages/man3/mq_receive.3:45
msgid "Link with I<-lrt>."
msgstr "Компонуется при указании параметра I<-lrt>."

#. type: Plain text
#: man-pages/man3/mq_receive.3:53
msgid "B<mq_timedreceive>():"
msgstr "B<mq_timedreceive>():"

#. type: Plain text
#: man-pages/man3/mq_receive.3:55
msgid "_POSIX_C_SOURCE\\ E<gt>=\\ 200112L"
msgstr "_POSIX_C_SOURCE\\ E<gt>=\\ 200112L"

#. type: Plain text
#: man-pages/man3/mq_receive.3:76
msgid ""
"B<mq_receive>()  removes the oldest message with the highest priority from "
"the message queue referred to by the message queue descriptor I<mqdes>, and "
"places it in the buffer pointed to by I<msg_ptr>.  The I<msg_len> argument "
"specifies the size of the buffer pointed to by I<msg_ptr>; this must be "
"greater than or equal to the I<mq_msgsize> attribute of the queue (see "
"B<mq_getattr>(3)).  If I<msg_prio> is not NULL, then the buffer to which it "
"points is used to return the priority associated with the received message."
msgstr "Функция B<mq_receive>() удаляет самое старое сообщение с наивысшим приоритетом из очереди сообщений, на которою указывает дескриптор очереди сообщений I<mqdes>, и помещает сообщение в буфер, на который указывает I<msg_ptr>. В аргументе I<msg_len> задаётся размер буфера, на который указывает I<msg_ptr>; он должен быть больше или равен  атрибуту очереди I<mq_msgsize> (смотрите B<mq_getattr>(3)). Если I<msg_prio> не равно NULL, то указанный в нём буфер используется для возврата приоритета, связанного с полученным сообщением."

#. type: Plain text
#: man-pages/man3/mq_receive.3:86
msgid ""
"If the queue is empty, then, by default, B<mq_receive>()  blocks until a "
"message becomes available, or the call is interrupted by a signal handler.  "
"If the B<O_NONBLOCK> flag is enabled for the message queue description, then"
" the call instead fails immediately with the error B<EAGAIN>."
msgstr "Если очередь пуста, то по умолчанию функция B<mq_receive>() блокирует выполнение до тех пор, показ не поступит сообщение или вызов не будет прерван обработчиком сигнала. Если в описании очереди сообщений включён флаг B<O_NONBLOCK>, то вызов завершается сразу же с ошибкой B<EAGAIN>."

#. type: Plain text
#: man-pages/man3/mq_receive.3:98
msgid ""
"B<mq_timedreceive>()  behaves just like B<mq_receive>(), except that if the "
"queue is empty and the B<O_NONBLOCK> flag is not enabled for the message "
"queue description, then I<abs_timeout> points to a structure which specifies"
" how long the call will block.  This value is an absolute timeout in seconds"
" and nanoseconds since the Epoch, 1970-01-01 00:00:00 +0000 (UTC), specified"
" in the following structure:"
msgstr "Функция B<mq_timedreceive>() действует подобно B<mq_receive>(), за исключением того, что если  очередь пуста и в описании очереди сообщений не установлен флаг B<O_NONBLOCK>, то I<abs_timeout> указывает на структуру, которой задаётся длительность блокировки вызова. Это абсолютное значение задаётся в секундах и наносекундах начиная с Эпохи, 1970-01-01 00:00:00 +0000 (UTC) в структуре вида:"

#. type: Plain text
#: man-pages/man3/mq_receive.3:105
#, no-wrap
msgid ""
"struct timespec {\n"
"    time_t tv_sec;        /* seconds */\n"
"    long   tv_nsec;       /* nanoseconds */\n"
"};\n"
msgstr "struct timespec {\n    time_t tv_sec;        /* секунды */\n    long   tv_nsec;       /* наносекунды */\n};\n"

#. type: Plain text
#: man-pages/man3/mq_receive.3:112
msgid ""
"If no message is available, and the timeout has already expired by the time "
"of the call, B<mq_timedreceive>()  returns immediately."
msgstr "Если сообщения нет и вышло время ожидания на момент вызова, то B<mq_timedreceive>() сразу же завершается."

#. type: Plain text
#: man-pages/man3/mq_receive.3:121
msgid ""
"On success, B<mq_receive>()  and B<mq_timedreceive>()  return the number of "
"bytes in the received message; on error, -1 is returned, with I<errno> set "
"to indicate the error."
msgstr "При успешном выполнении B<mq_receive>() и B<mq_timedreceive>()  возвращается количество байт в полученном сообщении; при ошибке возвращается -1 и в I<errno> записывается значение ошибки."

#. type: Plain text
#: man-pages/man3/mq_receive.3:128
msgid ""
"The queue was empty, and the B<O_NONBLOCK> flag was set for the message "
"queue description referred to by I<mqdes>."
msgstr "Очередь была пуста и в описании очереди сообщений, на которое ссылается I<mqdes>, указан флаг B<O_NONBLOCK>."

#. type: Plain text
#: man-pages/man3/mq_receive.3:133
msgid ""
"The descriptor specified in I<mqdes> was invalid or not opened for reading."
msgstr "В I<mqdes> указан некорректный или не открытый на чтение дескриптор."

#. type: Plain text
#: man-pages/man3/mq_receive.3:137
msgid "The call was interrupted by a signal handler; see B<signal>(7)."
msgstr "Вызов был прерван обработчиком сигнала; смотрите B<signal>(7)."

#. type: Plain text
#: man-pages/man3/mq_receive.3:146
msgid ""
"The call would have blocked, and I<abs_timeout> was invalid, either because "
"I<tv_sec> was less than zero, or because I<tv_nsec> was less than zero or "
"greater than 1000 million."
msgstr "Вызов бы заблокировался и в I<abs_timeout> указано некорректное значение, так как I<tv_sec> меньше нуля или I<tv_nsec> меньше нуля или более 1000 миллионов."

#. type: TP
#: man-pages/man3/mq_receive.3:146
#, no-wrap
msgid "B<EMSGSIZE>"
msgstr "B<EMSGSIZE>"

#. type: Plain text
#: man-pages/man3/mq_receive.3:152
msgid ""
"I<msg_len> was less than the I<mq_msgsize> attribute of the message queue."
msgstr "I<msg_len> меньше чем свойство очереди сообщений, I<mq_msgsize>."

#. type: TP
#: man-pages/man3/mq_receive.3:152
#, no-wrap
msgid "B<ETIMEDOUT>"
msgstr "B<ETIMEDOUT>"

#. type: Plain text
#: man-pages/man3/mq_receive.3:155
msgid "The call timed out before a message could be transferred."
msgstr "Истёк период ожидания в вызове, раньше появления возможности передачи сообщения."

#. type: tbl table
#: man-pages/man3/mq_receive.3:166
#, no-wrap
msgid ""
"B<mq_receive>(),\n"
"B<mq_timedreceive>()"
msgstr "B<mq_receive>(),\nB<mq_timedreceive>()"

#. type: Plain text
#: man-pages/man3/mq_receive.3:176
msgid ""
"On Linux, B<mq_timedreceive>()  is a system call, and B<mq_receive>()  is a "
"library function layered on top of that system call."
msgstr "В Linux, B<mq_receive>() является системным вызовом, а B<mq_timedreceive>() — библиотечной функцией, реализованной на основе этого системного вызова:"

#. type: Plain text
#: man-pages/man3/mq_receive.3:184
msgid ""
"B<mq_close>(3), B<mq_getattr>(3), B<mq_notify>(3), B<mq_open>(3), "
"B<mq_send>(3), B<mq_unlink>(3), B<mq_overview>(7), B<time>(7)"
msgstr "B<mq_close>(3), B<mq_getattr>(3), B<mq_notify>(3), B<mq_open>(3), B<mq_send>(3), B<mq_unlink>(3), B<mq_overview>(7), B<time>(7)"

#. type: TH
#: man-pages/man3/memcmp.3:30
#, no-wrap
msgid "MEMCMP"
msgstr "MEMCMP"

#. type: Plain text
#: man-pages/man3/memcmp.3:33
msgid "memcmp - compare memory areas"
msgstr "memcmp — сравнить области памяти"

#. type: Plain text
#: man-pages/man3/memcmp.3:36
#, no-wrap
msgid "B<#include E<lt>string.hE<gt>>\n"
msgstr "B<#include E<lt>string.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/memcmp.3:38
#, no-wrap
msgid ""
"B<int memcmp(const void *>I<s1>B<, const void *>I<s2>B<, size_t >I<n>B<);>\n"
msgstr "B<int memcmp(const void *>I<s1>B<, const void *>I<s2>B<, size_t >I<n>B<);>\n"

#. type: Plain text
#: man-pages/man3/memcmp.3:45
msgid ""
"The B<memcmp>()  function compares the first I<n> bytes (each interpreted as"
" I<unsigned char>)  of the memory areas I<s1> and I<s2>."
msgstr "Функция B<memcmp>() сравнивает первые I<n> байт (каждый как I<unsigned char>) из областей памяти I<s1> и I<s2>."

#. type: Plain text
#: man-pages/man3/memcmp.3:52
msgid ""
"The B<memcmp>()  function returns an integer less than, equal to, or greater"
" than zero if the first I<n> bytes of I<s1> is found, respectively, to be "
"less than, to match, or be greater than the first I<n> bytes of I<s2>."
msgstr "Функция B<memcmp>() возвращает целое число меньше, равное, или выше нуля если первые I<n> байт из I<s1> соответственно меньше, равны, или больше чем первые I<n> байт из I<s2>."

#. type: Plain text
#: man-pages/man3/memcmp.3:60
msgid ""
"For a nonzero return value, the sign is determined by the sign of the "
"difference between the first pair of bytes (interpreted as I<unsigned char>)"
"  that differ in I<s1> and I<s2>."
msgstr "Для возвращаемого значения, отличного от нуля, его знак определяется знаком разности первой пары байтов (которые I<unsigned char>) в I<s1> и I<s2>."

#. type: Plain text
#: man-pages/man3/memcmp.3:64
msgid "If I<n> is zero, the return value is zero."
msgstr "Если I<n> равно нулю, возвращаемое значение тоже ноль."

#. type: tbl table
#: man-pages/man3/memcmp.3:74
#, no-wrap
msgid "B<memcmp>()"
msgstr "B<memcmp>()"

#. type: Plain text
#: man-pages/man3/memcmp.3:78
msgid "POSIX.1-2001, POSIX.1-2008, C89, C99, SVr4, 4.3BSD."
msgstr "POSIX.1-2001, POSIX.1-2008, C89, C99, SVr4, 4.3BSD."

#. type: Plain text
#: man-pages/man3/memcmp.3:89
msgid ""
"Do not use B<memcmp>()  to compare security critical data, such as "
"cryptographic secrets, because the required CPU time depends on the number "
"of equal bytes.  Instead, a function that performs comparisons in constant "
"time is required.  Some operating systems provide such a function (e.g., "
"NetBSD's B<consttime_memequal>()), but no such function is specified in "
"POSIX.  On Linux, it may be necessary to implement such a function oneself."
msgstr "Не используйте B<memcmp>() для сравнения важных с точки зрения безопасности данных, как например криптографические секреты, потому что для этой функции требуемое время CPU зависит от числа одинаковых байтов. Используйте функции, производящие сравнение за constant time. (Например в NetBSD функция B<consttime_memequal>()). В POSIX подобная функция не предусмотрена."

#. type: Plain text
#: man-pages/man3/memcmp.3:97
msgid ""
"B<bcmp>(3), B<bstring>(3), B<strcasecmp>(3), B<strcmp>(3), B<strcoll>(3), "
"B<strncasecmp>(3), B<strncmp>(3), B<wmemcmp>(3)"
msgstr "B<bcmp>(3), B<bstring>(3), B<strcasecmp>(3), B<strcmp>(3), B<strcoll>(3), B<strncasecmp>(3), B<strncmp>(3), B<wmemcmp>(3)"

#. type: TH
#: man-pages/man3/matherr.3:27
#, no-wrap
msgid "MATHERR"
msgstr "MATHERR"

#. type: Plain text
#: man-pages/man3/matherr.3:30
msgid "matherr - SVID math library exception handling"
msgstr "matherr - библиотека SVID для обработки математических исключений"

#. type: Plain text
#: man-pages/man3/matherr.3:33
#, no-wrap
msgid "B<#include E<lt>math.hE<gt>>\n"
msgstr "B<#include E<lt>math.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/matherr.3:35
#, no-wrap
msgid "B<int matherr(struct exception *>I<exc>B<);>\n"
msgstr "B<int matherr(struct exception *>I<exc>B<);>\n"

#. type: Plain text
#: man-pages/man3/matherr.3:37
#, no-wrap
msgid "B<extern _LIB_VERSION_TYPE _LIB_VERSION;>\n"
msgstr "B<extern _LIB_VERSION_TYPE _LIB_VERSION;>\n"

#. type: Plain text
#: man-pages/man3/matherr.3:40
msgid "Link with I<-lm>."
msgstr "Компонуется при указании параметра I<-lm>."

#.  glibc commit 813378e9fe17e029caf627cab76fe23eb46815fa
#. type: Plain text
#: man-pages/man3/matherr.3:54
msgid ""
"I<Note>: the mechanism described in this page is no longer supported by "
"glibc.  Before glibc 2.27, it had been marked as obsolete.  Since glibc "
"2.27, the mechanism has been removed altogether.  New applications should "
"use the techniques described in B<math_error>(7)  and B<fenv>(3).  This page"
" documents the B<matherr>()  mechanism as an aid for maintaining and porting"
" older applications."
msgstr "I<Замечание>: механизм, описанный на этой странице, больше не поддерживается glibc. До glibc 2.27 он был помечен как устаревший. Начиная с glibc 2.27, механизм был полностью удалён. В новых приложениях нужно использовать методы, описанные в B<math_error>(7) и B<fenv>(3). На этой странице описан механизм B<matherr>() с целью сопровождения и переноса старых приложений."

#. type: Plain text
#: man-pages/man3/matherr.3:64
msgid ""
"The System V Interface Definition (SVID) specifies that various math "
"functions should invoke a function called B<matherr>()  if a math exception "
"is detected.  This function is called before the math function returns; "
"after B<matherr>()  returns, the system then returns to the math function, "
"which in turn returns to the caller."
msgstr "В System V Interface Definition (SVID) определено какие математические функции должны вызывать функцию B<matherr>(), если обнаруживается математическое исключение. Эта функция вызывает до возврата из самой математической функции; после возврата из B<matherr>() система возвращается в математическую функцию, которая, в свою очередь, возвращает управление вызывающему."

#. type: Plain text
#: man-pages/man3/matherr.3:77
msgid ""
"To employ B<matherr>(), the programmer must define the B<_SVID_SOURCE> "
"feature test macro (before including I<any> header files), and assign the "
"value B<_SVID_> to the external variable B<_LIB_VERSION>."
msgstr "Чтобы задействовать B<matherr>(), программист должен определить макрос тестирования свойств B<_SVID_SOURCE> (до включения I<каких-либо> заголовочных файлов) и присвоить значение B<_SVID_> внешней переменной B<_LIB_VERSION>."

#. type: Plain text
#: man-pages/man3/matherr.3:89
msgid ""
"The system provides a default version of B<matherr>().  This version does "
"nothing, and returns zero (see below for the significance of this).  The "
"default B<matherr>()  can be overridden by a programmer-defined version, "
"which will be invoked when an exception occurs.  The function is invoked "
"with one argument, a pointer to an I<exception> structure, defined as "
"follows:"
msgstr "Система предоставляет B<matherr>() как версию по умолчанию. Эта версия ничего не делает возвращает ноль (назначение этого смотрите далее). Версия по умолчанию B<matherr>() может быть перезаписана версией программиста, которая будет вызываться при возникновении исключений. Функция вызывается с одним аргументом, указателем на структуру I<exception>,  определённую следующим образом:"

#. type: Plain text
#: man-pages/man3/matherr.3:99
#, no-wrap
msgid ""
"struct exception {\n"
"    int    type;      /* Exception type */\n"
"    char  *name;      /* Name of function causing exception */\n"
"    double arg1;      /* 1st argument to function */\n"
"    double arg2;      /* 2nd argument to function */\n"
"    double retval;    /* Function return value */\n"
"}\n"
msgstr "struct exception {\n    int    type;      /* тип исключения */\n    char  *name;      /* имя функции, вызвавшей исключение */\n    double arg1;      /* 1-й аргумент функции */\n    double arg2;      /* 2-й аргумент функции */\n    double retval;    /* значение, возвращаемое функцией */\n}\n"

#. type: Plain text
#: man-pages/man3/matherr.3:105
msgid "The I<type> field has one of the following values:"
msgstr "В поле I<type> может быть одно из следующих значений:"

#. type: TP
#: man-pages/man3/matherr.3:105
#, no-wrap
msgid "B<DOMAIN>"
msgstr "B<DOMAIN>"

#. type: Plain text
#: man-pages/man3/matherr.3:113
msgid ""
"A domain error occurred (the function argument was outside the range for "
"which the function is defined).  The return value depends on the function; "
"I<errno> is set to B<EDOM>."
msgstr "Произошла ошибка области (аргумент функции вне диапазона, для которого определена функция). Возвращаемое значение зависит от функции; I<errno> присваивается B<EDOM>."

#. type: TP
#: man-pages/man3/matherr.3:113
#, no-wrap
msgid "B<SING>"
msgstr "B<SING>"

#. type: Plain text
#: man-pages/man3/matherr.3:124
msgid ""
"A pole error occurred (the function result is an infinity).  The return "
"value in most cases is B<HUGE> (the largest single precision floating-point "
"number), appropriately signed.  In most cases, I<errno> is set to B<EDOM>."
msgstr "Произошла ошибка особой точки (результат функции равен бесконечности). Возвращаемое значение, в большинстве случаев, равно B<HUGE> (самое большое число с плавающей запятой одинарной точности) с соответствующим знаком. В большинстве случаев, I<errno> присваивается B<EDOM>."

#. type: TP
#: man-pages/man3/matherr.3:124
#, no-wrap
msgid "B<OVERFLOW>"
msgstr "B<OVERFLOW>"

#. type: Plain text
#: man-pages/man3/matherr.3:133
msgid ""
"An overflow occurred.  In most cases, the value B<HUGE> is returned, and "
"I<errno> is set to B<ERANGE>."
msgstr "Возникло переполнение. В большинстве случаев, возвращается значение B<HUGE> и I<errno> присваивается B<ERANGE>."

#. type: TP
#: man-pages/man3/matherr.3:133
#, no-wrap
msgid "B<UNDERFLOW>"
msgstr "B<UNDERFLOW>"

#. type: Plain text
#: man-pages/man3/matherr.3:140
msgid ""
"An underflow occurred.  0.0 is returned, and I<errno> is set to B<ERANGE>."
msgstr "Произошла потеря значимости. Возвращается 0.0 и I<errno> присваивается B<ERANGE>."

#. type: TP
#: man-pages/man3/matherr.3:140
#, no-wrap
msgid "B<TLOSS>"
msgstr "B<TLOSS>"

#. type: Plain text
#: man-pages/man3/matherr.3:147
msgid ""
"Total loss of significance.  0.0 is returned, and I<errno> is set to "
"B<ERANGE>."
msgstr "Полная потеря значимости. Возвращается 0.0 и I<errno> присваивается B<ERANGE>."

#. type: TP
#: man-pages/man3/matherr.3:147
#, no-wrap
msgid "B<PLOSS>"
msgstr "B<PLOSS>"

#. type: Plain text
#: man-pages/man3/matherr.3:152
msgid ""
"Partial loss of significance.  This value is unused on glibc (and many other"
" systems)."
msgstr "Частичная потеря значимости. Это значение не используется в glibc (и многих других системах)."

#. type: Plain text
#: man-pages/man3/matherr.3:160
msgid ""
"The I<arg1> and I<arg2> fields are the arguments supplied to the function "
"(I<arg2> is undefined for functions that take only one argument)."
msgstr "Поля I<arg1> и I<arg2> это значения аргументов, переданных функции (I<arg2> не определено для функций, у которых только один аргумент)."

#. type: Plain text
#: man-pages/man3/matherr.3:168
msgid ""
"The I<retval> field specifies the return value that the math function will "
"return to its caller.  The programmer-defined B<matherr>()  can modify this "
"field to change the return value of the math function."
msgstr "В поле I<retval> указывается возвращаемое значение, которое математическая функция вернёт вызывающему. Написанная программистом B<matherr>() может изменить этого поле, чтобы вернуть другое значение из математической функции."

#. type: Plain text
#: man-pages/man3/matherr.3:175
msgid ""
"If the B<matherr>()  function returns zero, then the system sets I<errno> as"
" described above, and may print an error message on standard error (see "
"below)."
msgstr "Если функция B<matherr>() возвращает ноль, то система изменяет I<errno> как описано выше и может вывести сообщение об ошибке в стандартный поток ошибок (смотрите далее)."

#. type: Plain text
#: man-pages/man3/matherr.3:181
msgid ""
"If the B<matherr>()  function returns a nonzero value, then the system does "
"not set I<errno>, and doesn't print an error message."
msgstr "Если функция B<matherr>() возвращает ненулевое значение, то система не изменяет I<errno> и не печатает сообщение об ошибке."

#. type: SS
#: man-pages/man3/matherr.3:181
#, no-wrap
msgid "Math functions that employ matherr()"
msgstr "Математические функции, которые используют matherr()"

#. type: Plain text
#: man-pages/man3/matherr.3:191
msgid ""
"The table below lists the functions and circumstances in which B<matherr>()"
"  is called.  The \"Type\" column indicates the value assigned to "
"I<exc-E<gt>type> when calling B<matherr>().  The \"Result\" column is the "
"default return value assigned to I<exc-E<gt>retval>."
msgstr "В таблице далее перечислены функции и обстоятельства вызова B<matherr>(). В столбце «тип» показано значение, назначаемое I<exc-E<gt>type>, когда вызывается B<matherr>(). В столбце «результат» содержится возвращаемое значение по умолчанию. назначаемое I<exc-E<gt>retval>."

#. type: Plain text
#: man-pages/man3/matherr.3:197
msgid ""
"The \"Msg?\" and \"errno\" columns describe the default behavior if "
"B<matherr>()  returns zero.  If the \"Msg?\" columns contains \"y\", then "
"the system prints an error message on standard error."
msgstr "В столбцах «сообщение?» и «errno» описано поведение по умолчанию, если B<matherr>() возвращает ноль. Если в «сообщение?» указано «y», то система выводит сообщение об ошибке в стандартный поток ошибок."

#. type: Plain text
#: man-pages/man3/matherr.3:199
msgid "The table uses the following notations and abbreviations:"
msgstr "В таблице используются следующие обозначения и сокращения:"

#. type: Plain text
#: man-pages/man3/matherr.3:211
#, no-wrap
msgid ""
"x        first argument to function\n"
"y        second argument to function\n"
"fin      finite value for argument\n"
"neg      negative value for argument\n"
"int      integral value for argument\n"
"o/f      result overflowed\n"
"u/f      result underflowed\n"
"|x|      absolute value of x\n"
"X_TLOSS  is a constant defined in I<E<lt>math.hE<gt>>\n"
msgstr "x        первый аргумент функции\ny        второй аргумент функции\nfin      конечное значение аргумента\nneg      отрицательное значение аргумента\nint      целочисленное значение аргумента\no/f      переполнение результата\nu/f      потеря значимости результата\n|x|      абсолютное значение x\nX_TLOSS  константа, определённая в I<E<lt>math.hE<gt>>\n"

#. type: tbl table
#: man-pages/man3/matherr.3:218
#, no-wrap
msgid "Function"
msgstr "функция"

#. type: tbl table
#: man-pages/man3/matherr.3:218
#, no-wrap
msgid "Type"
msgstr "тип"

#. type: tbl table
#: man-pages/man3/matherr.3:218
#, no-wrap
msgid "Result"
msgstr "результат"

#. type: tbl table
#: man-pages/man3/matherr.3:218
#, no-wrap
msgid "Msg?"
msgstr "Сообщение?"

#. type: tbl table
#: man-pages/man3/matherr.3:218
#, no-wrap
msgid "errno"
msgstr "errno"

#. type: tbl table
#: man-pages/man3/matherr.3:219
#, no-wrap
msgid "acos(|x|E<gt>1)"
msgstr "acos(|x|E<gt>1)"

#.  retval is 0.0/0.0
#. type: tbl table
#: man-pages/man3/matherr.3:219 man-pages/man3/matherr.3:220
#: man-pages/man3/matherr.3:221 man-pages/man3/matherr.3:222
#: man-pages/man3/matherr.3:223 man-pages/man3/matherr.3:230
#: man-pages/man3/matherr.3:244 man-pages/man3/matherr.3:245
#: man-pages/man3/matherr.3:246 man-pages/man3/matherr.3:247
#: man-pages/man3/matherr.3:248 man-pages/man3/matherr.3:249
#: man-pages/man3/matherr.3:258 man-pages/man3/matherr.3:260
#: man-pages/man3/matherr.3:262 man-pages/man3/matherr.3:263
#: man-pages/man3/matherr.3:266 man-pages/man3/matherr.3:267
#: man-pages/man3/matherr.3:268 man-pages/man3/matherr.3:274
#: man-pages/man3/matherr.3:275
#, no-wrap
msgid "DOMAIN"
msgstr "DOMAIN"

#. type: tbl table
#: man-pages/man3/matherr.3:219 man-pages/man3/matherr.3:220
#: man-pages/man3/matherr.3:221 man-pages/man3/matherr.3:227
#: man-pages/man3/matherr.3:231 man-pages/man3/matherr.3:232
#: man-pages/man3/matherr.3:234 man-pages/man3/matherr.3:236
#: man-pages/man3/matherr.3:250 man-pages/man3/matherr.3:251
#: man-pages/man3/matherr.3:264
#, no-wrap
msgid "HUGE"
msgstr "HUGE"

#.  retval is 0.0/0.0
#. type: tbl table
#: man-pages/man3/matherr.3:219 man-pages/man3/matherr.3:220
#: man-pages/man3/matherr.3:221 man-pages/man3/matherr.3:222
#: man-pages/man3/matherr.3:223 man-pages/man3/matherr.3:224
#: man-pages/man3/matherr.3:230 man-pages/man3/matherr.3:238
#: man-pages/man3/matherr.3:239 man-pages/man3/matherr.3:240
#: man-pages/man3/matherr.3:241 man-pages/man3/matherr.3:242
#: man-pages/man3/matherr.3:243 man-pages/man3/matherr.3:244
#: man-pages/man3/matherr.3:245 man-pages/man3/matherr.3:246
#: man-pages/man3/matherr.3:247 man-pages/man3/matherr.3:248
#: man-pages/man3/matherr.3:249 man-pages/man3/matherr.3:251
#: man-pages/man3/matherr.3:254 man-pages/man3/matherr.3:255
#: man-pages/man3/matherr.3:257 man-pages/man3/matherr.3:258
#: man-pages/man3/matherr.3:261 man-pages/man3/matherr.3:262
#: man-pages/man3/matherr.3:263 man-pages/man3/matherr.3:267
#: man-pages/man3/matherr.3:268 man-pages/man3/matherr.3:274
#: man-pages/man3/matherr.3:275
#, no-wrap
msgid "y"
msgstr "y"

#.  retval is 0.0/0.0
#. type: tbl table
#: man-pages/man3/matherr.3:219 man-pages/man3/matherr.3:220
#: man-pages/man3/matherr.3:221 man-pages/man3/matherr.3:222
#: man-pages/man3/matherr.3:223 man-pages/man3/matherr.3:224
#: man-pages/man3/matherr.3:230 man-pages/man3/matherr.3:244
#: man-pages/man3/matherr.3:245 man-pages/man3/matherr.3:246
#: man-pages/man3/matherr.3:247 man-pages/man3/matherr.3:248
#: man-pages/man3/matherr.3:249 man-pages/man3/matherr.3:251
#: man-pages/man3/matherr.3:254 man-pages/man3/matherr.3:257
#: man-pages/man3/matherr.3:258 man-pages/man3/matherr.3:259
#: man-pages/man3/matherr.3:260 man-pages/man3/matherr.3:261
#: man-pages/man3/matherr.3:262 man-pages/man3/matherr.3:263
#: man-pages/man3/matherr.3:266 man-pages/man3/matherr.3:267
#: man-pages/man3/matherr.3:268 man-pages/man3/matherr.3:274
#: man-pages/man3/matherr.3:275
#, no-wrap
msgid "EDOM"
msgstr "EDOM"

#. type: tbl table
#: man-pages/man3/matherr.3:220
#, no-wrap
msgid "asin(|x|E<gt>1)"
msgstr "asin(|x|E<gt>1)"

#. type: tbl table
#: man-pages/man3/matherr.3:221
#, no-wrap
msgid "atan2(0,0)"
msgstr "atan2(0,0)"

#.  retval is 0.0/0.0
#. type: tbl table
#: man-pages/man3/matherr.3:222
#, no-wrap
msgid "acosh(xE<lt>1)"
msgstr "acosh(xE<lt>1)"

#.  retval is 0.0/0.0
#. type: tbl table
#: man-pages/man3/matherr.3:222 man-pages/man3/matherr.3:223
#: man-pages/man3/matherr.3:254 man-pages/man3/matherr.3:275
#, no-wrap
msgid "NAN"
msgstr "NAN"

#.  retval is 0.0/0.0
#. type: tbl table
#: man-pages/man3/matherr.3:223
#, no-wrap
msgid "atanh(|x|E<gt>1)"
msgstr "atanh(|x|E<gt>1)"

#.  retval is x/0.0
#. type: tbl table
#: man-pages/man3/matherr.3:224
#, no-wrap
msgid "atanh(|x|==1)"
msgstr "atanh(|x|==1)"

#. type: tbl table
#: man-pages/man3/matherr.3:224 man-pages/man3/matherr.3:251
#: man-pages/man3/matherr.3:254 man-pages/man3/matherr.3:255
#: man-pages/man3/matherr.3:257 man-pages/man3/matherr.3:259
#: man-pages/man3/matherr.3:261
#, no-wrap
msgid "SING"
msgstr "SING"

#.  retval is x/0.0
#. type: tbl table
#: man-pages/man3/matherr.3:224
#, no-wrap
msgid "(xE<gt>0.0)?"
msgstr "(xE<gt>0.0)?"

#. type: tbl table
#: man-pages/man3/matherr.3:225 man-pages/man3/matherr.3:226
#: man-pages/man3/matherr.3:229 man-pages/man3/matherr.3:256
#: man-pages/man3/matherr.3:270 man-pages/man3/matherr.3:271
#: man-pages/man3/matherr.3:273
#, no-wrap
msgid "\\ "
msgstr "\\ "

#. type: tbl table
#: man-pages/man3/matherr.3:225 man-pages/man3/matherr.3:270
#, no-wrap
msgid "HUGE_VAL :"
msgstr "HUGE_VAL :"

#. type: tbl table
#: man-pages/man3/matherr.3:226 man-pages/man3/matherr.3:271
#, no-wrap
msgid "-HUGE_VAL"
msgstr "-HUGE_VAL"

#. type: tbl table
#: man-pages/man3/matherr.3:227
#, no-wrap
msgid "cosh(fin) o/f"
msgstr "cosh(fin) o/f"

#. type: tbl table
#: man-pages/man3/matherr.3:227 man-pages/man3/matherr.3:228
#: man-pages/man3/matherr.3:231 man-pages/man3/matherr.3:232
#: man-pages/man3/matherr.3:234 man-pages/man3/matherr.3:236
#: man-pages/man3/matherr.3:250 man-pages/man3/matherr.3:253
#: man-pages/man3/matherr.3:264 man-pages/man3/matherr.3:269
#, no-wrap
msgid "OVERFLOW"
msgstr "OVERFLOW"

#. type: tbl table
#: man-pages/man3/matherr.3:227 man-pages/man3/matherr.3:228
#: man-pages/man3/matherr.3:231 man-pages/man3/matherr.3:232
#: man-pages/man3/matherr.3:233 man-pages/man3/matherr.3:234
#: man-pages/man3/matherr.3:235 man-pages/man3/matherr.3:236
#: man-pages/man3/matherr.3:237 man-pages/man3/matherr.3:250
#: man-pages/man3/matherr.3:253 man-pages/man3/matherr.3:259
#: man-pages/man3/matherr.3:260 man-pages/man3/matherr.3:264
#: man-pages/man3/matherr.3:265 man-pages/man3/matherr.3:266
#: man-pages/man3/matherr.3:269 man-pages/man3/matherr.3:272
#, no-wrap
msgid "n"
msgstr "n"

#. type: tbl table
#: man-pages/man3/matherr.3:227 man-pages/man3/matherr.3:228
#: man-pages/man3/matherr.3:231 man-pages/man3/matherr.3:232
#: man-pages/man3/matherr.3:233 man-pages/man3/matherr.3:234
#: man-pages/man3/matherr.3:235 man-pages/man3/matherr.3:236
#: man-pages/man3/matherr.3:237 man-pages/man3/matherr.3:238
#: man-pages/man3/matherr.3:239 man-pages/man3/matherr.3:240
#: man-pages/man3/matherr.3:241 man-pages/man3/matherr.3:242
#: man-pages/man3/matherr.3:243 man-pages/man3/matherr.3:250
#: man-pages/man3/matherr.3:253 man-pages/man3/matherr.3:255
#: man-pages/man3/matherr.3:264 man-pages/man3/matherr.3:265
#: man-pages/man3/matherr.3:269 man-pages/man3/matherr.3:272
#, no-wrap
msgid "ERANGE"
msgstr "ERANGE"

#. type: tbl table
#: man-pages/man3/matherr.3:228
#, no-wrap
msgid "sinh(fin) o/f"
msgstr "sinh(fin) o/f"

#. type: tbl table
#: man-pages/man3/matherr.3:228 man-pages/man3/matherr.3:269
#, no-wrap
msgid "(xE<gt>0.0) ?"
msgstr "(xE<gt>0.0) ?"

#. type: tbl table
#: man-pages/man3/matherr.3:229
#, no-wrap
msgid "HUGE : -HUGE"
msgstr "HUGE : -HUGE"

#. type: tbl table
#: man-pages/man3/matherr.3:230
#, no-wrap
msgid "sqrt(xE<lt>0)"
msgstr "sqrt(xE<lt>0)"

#. type: tbl table
#: man-pages/man3/matherr.3:230 man-pages/man3/matherr.3:233
#: man-pages/man3/matherr.3:235 man-pages/man3/matherr.3:237
#: man-pages/man3/matherr.3:238 man-pages/man3/matherr.3:239
#: man-pages/man3/matherr.3:240 man-pages/man3/matherr.3:241
#: man-pages/man3/matherr.3:242 man-pages/man3/matherr.3:243
#: man-pages/man3/matherr.3:263 man-pages/man3/matherr.3:265
#: man-pages/man3/matherr.3:267 man-pages/man3/matherr.3:268
#, no-wrap
msgid "0.0"
msgstr "0.0"

#. type: tbl table
#: man-pages/man3/matherr.3:231
#, no-wrap
msgid "hypot(fin,fin) o/f"
msgstr "hypot(fin,fin) o/f"

#. type: tbl table
#: man-pages/man3/matherr.3:232
#, no-wrap
msgid "exp(fin) o/f"
msgstr "exp(fin) o/f"

#. type: tbl table
#: man-pages/man3/matherr.3:233
#, no-wrap
msgid "exp(fin) u/f"
msgstr "exp(fin) u/f"

#. type: tbl table
#: man-pages/man3/matherr.3:233 man-pages/man3/matherr.3:235
#: man-pages/man3/matherr.3:237 man-pages/man3/matherr.3:265
#: man-pages/man3/matherr.3:272
#, no-wrap
msgid "UNDERFLOW"
msgstr "UNDERFLOW"

#. type: tbl table
#: man-pages/man3/matherr.3:234
#, no-wrap
msgid "exp2(fin) o/f"
msgstr "exp2(fin) o/f"

#. type: tbl table
#: man-pages/man3/matherr.3:235
#, no-wrap
msgid "exp2(fin) u/f"
msgstr "exp2(fin) u/f"

#. type: tbl table
#: man-pages/man3/matherr.3:236
#, no-wrap
msgid "exp10(fin) o/f"
msgstr "exp10(fin) o/f"

#. type: tbl table
#: man-pages/man3/matherr.3:237
#, no-wrap
msgid "exp10(fin) u/f"
msgstr "exp10(fin) u/f"

#. type: tbl table
#: man-pages/man3/matherr.3:238
#, no-wrap
msgid "j0(|x|E<gt>X_TLOSS)"
msgstr "j0(|x|E<gt>X_TLOSS)"

#. type: tbl table
#: man-pages/man3/matherr.3:238 man-pages/man3/matherr.3:239
#: man-pages/man3/matherr.3:240 man-pages/man3/matherr.3:241
#: man-pages/man3/matherr.3:242 man-pages/man3/matherr.3:243
#, no-wrap
msgid "TLOSS"
msgstr "TLOSS"

#. type: tbl table
#: man-pages/man3/matherr.3:239
#, no-wrap
msgid "j1(|x|E<gt>X_TLOSS)"
msgstr "j1(|x|E<gt>X_TLOSS)"

#. type: tbl table
#: man-pages/man3/matherr.3:240
#, no-wrap
msgid "jn(|x|E<gt>X_TLOSS)"
msgstr "jn(|x|E<gt>X_TLOSS)"

#. type: tbl table
#: man-pages/man3/matherr.3:241
#, no-wrap
msgid "y0(xE<gt>X_TLOSS)"
msgstr "y0(xE<gt>X_TLOSS)"

#. type: tbl table
#: man-pages/man3/matherr.3:242
#, no-wrap
msgid "y1(xE<gt>X_TLOSS)"
msgstr "y1(xE<gt>X_TLOSS)"

#. type: tbl table
#: man-pages/man3/matherr.3:243
#, no-wrap
msgid "yn(xE<gt>X_TLOSS)"
msgstr "yn(xE<gt>X_TLOSS)"

#. type: tbl table
#: man-pages/man3/matherr.3:244
#, no-wrap
msgid "y0(0)"
msgstr "y0(0)"

#. type: tbl table
#: man-pages/man3/matherr.3:244 man-pages/man3/matherr.3:245
#: man-pages/man3/matherr.3:246 man-pages/man3/matherr.3:247
#: man-pages/man3/matherr.3:248 man-pages/man3/matherr.3:249
#: man-pages/man3/matherr.3:257 man-pages/man3/matherr.3:258
#: man-pages/man3/matherr.3:259 man-pages/man3/matherr.3:260
#: man-pages/man3/matherr.3:261 man-pages/man3/matherr.3:262
#, no-wrap
msgid "-HUGE"
msgstr "-HUGE"

#. type: tbl table
#: man-pages/man3/matherr.3:245
#, no-wrap
msgid "y0(xE<lt>0)"
msgstr "y0(xE<lt>0)"

#. type: tbl table
#: man-pages/man3/matherr.3:246
#, no-wrap
msgid "y1(0)"
msgstr "y1(0)"

#. type: tbl table
#: man-pages/man3/matherr.3:247
#, no-wrap
msgid "y1(xE<lt>0)"
msgstr "y1(xE<lt>0)"

#. type: tbl table
#: man-pages/man3/matherr.3:248
#, no-wrap
msgid "yn(n,0)"
msgstr "yn(n,0)"

#. type: tbl table
#: man-pages/man3/matherr.3:249
#, no-wrap
msgid "yn(xE<lt>0)"
msgstr "yn(xE<lt>0)"

#. type: tbl table
#: man-pages/man3/matherr.3:250
#, no-wrap
msgid "lgamma(fin) o/f"
msgstr "lgamma(fin) o/f"

#. type: tbl table
#: man-pages/man3/matherr.3:251
#, no-wrap
msgid "lgamma(-int) or"
msgstr "lgamma(-int) или"

#. type: tbl table
#: man-pages/man3/matherr.3:252
#, no-wrap
msgid "\\ \\ lgamma(0)"
msgstr "\\ \\ lgamma(0)"

#. type: tbl table
#: man-pages/man3/matherr.3:253
#, no-wrap
msgid "tgamma(fin) o/f"
msgstr "tgamma(fin) o/f"

#. type: tbl table
#: man-pages/man3/matherr.3:253
#, no-wrap
msgid "HUGE_VAL"
msgstr "HUGE_VAL"

#. type: tbl table
#: man-pages/man3/matherr.3:254
#, no-wrap
msgid "tgamma(-int)"
msgstr "tgamma(-int)"

#. type: tbl table
#: man-pages/man3/matherr.3:255
#, no-wrap
msgid "tgamma(0)"
msgstr "tgamma(0)"

#. type: tbl table
#: man-pages/man3/matherr.3:255 man-pages/man3/matherr.3:272
#, no-wrap
msgid "copysign("
msgstr "copysign("

#. type: tbl table
#: man-pages/man3/matherr.3:256
#, no-wrap
msgid "HUGE_VAL,x)"
msgstr "HUGE_VAL,x)"

#. type: tbl table
#: man-pages/man3/matherr.3:257
#, no-wrap
msgid "log(0)"
msgstr "log(0)"

#. type: tbl table
#: man-pages/man3/matherr.3:258
#, no-wrap
msgid "log(xE<lt>0)"
msgstr "log(xE<lt>0)"

#.  different from log()
#. type: tbl table
#: man-pages/man3/matherr.3:259
#, no-wrap
msgid "log2(0)"
msgstr "log2(0)"

#.  different from log()
#. type: tbl table
#: man-pages/man3/matherr.3:260
#, no-wrap
msgid "log2(xE<lt>0)"
msgstr "log2(xE<lt>0)"

#. type: tbl table
#: man-pages/man3/matherr.3:261
#, no-wrap
msgid "log10(0)"
msgstr "log10(0)"

#. type: tbl table
#: man-pages/man3/matherr.3:262
#, no-wrap
msgid "log10(xE<lt>0)"
msgstr "log10(xE<lt>0)"

#. type: tbl table
#: man-pages/man3/matherr.3:263
#, no-wrap
msgid "pow(0.0,0.0)"
msgstr "pow(0.0,0.0)"

#. type: tbl table
#: man-pages/man3/matherr.3:264
#, no-wrap
msgid "pow(x,y) o/f"
msgstr "pow(x,y) o/f"

#. type: tbl table
#: man-pages/man3/matherr.3:265
#, no-wrap
msgid "pow(x,y) u/f"
msgstr "pow(x,y) u/f"

#. type: tbl table
#: man-pages/man3/matherr.3:266
#, no-wrap
msgid "pow(NaN,0.0)"
msgstr "pow(NaN,0.0)"

#. type: tbl table
#: man-pages/man3/matherr.3:266 man-pages/man3/matherr.3:274
#, no-wrap
msgid "x"
msgstr "x"

#.  +0 and -0
#. type: tbl table
#: man-pages/man3/matherr.3:267
#, no-wrap
msgid "0**neg"
msgstr "0**neg"

#. type: tbl table
#: man-pages/man3/matherr.3:268
#, no-wrap
msgid "neg**non-int"
msgstr "neg**non-int"

#. type: tbl table
#: man-pages/man3/matherr.3:269
#, no-wrap
msgid "scalb() o/f"
msgstr "scalb() o/f"

#. type: tbl table
#: man-pages/man3/matherr.3:272
#, no-wrap
msgid "scalb() u/f"
msgstr "scalb() u/f"

#. type: tbl table
#: man-pages/man3/matherr.3:273
#, no-wrap
msgid "\\ \\ 0.0,x)"
msgstr "\\ \\ 0.0,x)"

#. type: tbl table
#: man-pages/man3/matherr.3:274
#, no-wrap
msgid "fmod(x,0)"
msgstr "fmod(x,0)"

#.  retval is 0.0/0.0
#. type: tbl table
#: man-pages/man3/matherr.3:275
#, no-wrap
msgid "remainder(x,0)"
msgstr "remainder(x,0)"

#. type: tbl table
#: man-pages/man3/matherr.3:287
#, no-wrap
msgid "B<matherr>()"
msgstr "B<matherr>()"

#. type: Plain text
#: man-pages/man3/matherr.3:310
msgid ""
"The example program demonstrates the use of B<matherr>()  when calling "
"B<log>(3).  The program takes up to three command-line arguments.  The first"
" argument is the floating-point number to be given to B<log>(3).  If the "
"optional second argument is provided, then B<_LIB_VERSION> is set to "
"B<_SVID_> so that B<matherr>()  is called, and the integer supplied in the "
"command-line argument is used as the return value from B<matherr>().  If the"
" optional third command-line argument is supplied, then it specifies an "
"alternative return value that B<matherr>()  should assign as the return "
"value of the math function."
msgstr "В примере программы показано использование B<matherr>() при вызове B<log>(3). Программа имеет три аргумента командной строки. Первый аргумент — число с плавающей запятой, передаваемое в B<log>(3). Если указан необязательный второй аргумент, то B<_LIB_VERSION> присваивается значение B<_SVID_> для того, чтобы вызывалась B<matherr>(), и указанное в командной строке целое число используется как возвращаемое значение B<matherr>(). Если указан необязательный третий аргумент, то им определяется альтернативное возвращаемое значение, которое B<matherr>() должна вернуть как результат математической функции."

#. type: Plain text
#: man-pages/man3/matherr.3:315
msgid ""
"The following example run, where B<log>(3)  is given an argument of 0.0, "
"does not use B<matherr>():"
msgstr "Пример запуска, где в B<log>(3) передаётся аргумент 0.0 и не используется B<matherr>():"

#. type: Plain text
#: man-pages/man3/matherr.3:321
#, no-wrap
msgid ""
"$B< ./a.out 0.0>\n"
"errno: Numerical result out of range\n"
"x=-inf\n"
msgstr "$B< ./a.out 0.0>\nerrno: Числовой результат вне представимого диапазона\nx=-inf\n"

#. type: Plain text
#: man-pages/man3/matherr.3:327
msgid "In the following run, B<matherr>()  is called, and returns 0:"
msgstr "В следующем примере вызывается функция B<matherr>() и возвращает 0:"

#. type: Plain text
#: man-pages/man3/matherr.3:337
#, no-wrap
msgid ""
"$B< ./a.out 0.0 0>\n"
"matherr SING exception in log() function\n"
"        args:   0.000000, 0.000000\n"
"        retval: -340282346638528859811704183484516925440.000000\n"
"log: SING error\n"
"errno: Numerical argument out of domain\n"
"x=-340282346638528859811704183484516925440.000000\n"
msgstr "$B< ./a.out 0.0 0>\nисключение matherr SING в функции log()\n        арг:   0.000000, 0.000000\n        возвр.знач.: -340282346638528859811704183484516925440.000000\nlog: SING error\nerrno: Числовой аргумент вне области функции\nx=-340282346638528859811704183484516925440.000000\n"

#. type: Plain text
#: man-pages/man3/matherr.3:341
msgid "The message \"log: SING error\" was printed by the C library."
msgstr "Сообщение «log: SING error» выдаётся библиотекой Си."

#. type: Plain text
#: man-pages/man3/matherr.3:345
msgid ""
"In the following run, B<matherr>()  is called, and returns a nonzero value:"
msgstr "В следующем примере вызывается функция B<matherr>() и возвращается не нулевое значение:"

#. type: Plain text
#: man-pages/man3/matherr.3:353
#, no-wrap
msgid ""
"$B< ./a.out 0.0 1>\n"
"matherr SING exception in log() function\n"
"        args:   0.000000, 0.000000\n"
"        retval: -340282346638528859811704183484516925440.000000\n"
"x=-340282346638528859811704183484516925440.000000\n"
msgstr "$B< ./a.out 0.0 1>\nисключение matherr SING в функции log()\n        арг:   0.000000, 0.000000\n        возвр.знач.: -340282346638528859811704183484516925440.000000\nx=-340282346638528859811704183484516925440.000000\n"

#. type: Plain text
#: man-pages/man3/matherr.3:359
msgid ""
"In this case, the C library did not print a message, and I<errno> was not "
"set."
msgstr "В этом случае библиотека Си не печатает сообщение, и значение I<errno> не изменяется."

#. type: Plain text
#: man-pages/man3/matherr.3:364
msgid ""
"In the following run, B<matherr>()  is called, changes the return value of "
"the math function, and returns a nonzero value:"
msgstr "В следующем примере вызывается функция B<matherr>(), изменяется возвращаемое значение математической функции и возвращается ненулевое значение:"

#. type: Plain text
#: man-pages/man3/matherr.3:372
#, no-wrap
msgid ""
"$B< ./a.out 0.0 1 12345.0>\n"
"matherr SING exception in log() function\n"
"        args:   0.000000, 0.000000\n"
"        retval: -340282346638528859811704183484516925440.000000\n"
"x=12345.000000\n"
msgstr "$B< ./a.out 0.0 1 12345.0>\nисключение matherr SING в функции log()\n        арг:   0.000000, 0.000000\n        возвр.знач.: -340282346638528859811704183484516925440.000000\nx=12345.000000\n"

#. type: Plain text
#: man-pages/man3/matherr.3:382
#, no-wrap
msgid ""
"#define _SVID_SOURCE\n"
"#include E<lt>errno.hE<gt>\n"
"#include E<lt>math.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
msgstr "#define _SVID_SOURCE\n#include E<lt>errno.hE<gt>\n#include E<lt>math.hE<gt>\n#include E<lt>stdio.hE<gt>\n#include E<lt>stdlib.hE<gt>\n"

#. type: Plain text
#: man-pages/man3/matherr.3:388
#, no-wrap
msgid ""
"static int matherr_ret = 0;     /* Value that matherr()\n"
"                                   should return */\n"
"static int change_retval = 0;   /* Should matherr() change\n"
"                                   function\\(aqs return value? */\n"
"static double new_retval;       /* New function return value */\n"
msgstr "static int matherr_ret = 0;     /* значение, которое должна\n                                    вернуть matherr() */\nstatic int change_retval = 0;   /* должна ли matherr() изменять\n                                   возвращаемое функцией значение? */\nstatic double new_retval;       /* новое значение, возвращаемое\n                                   функцией */\n"

#. type: Plain text
#: man-pages/man3/matherr.3:403
#, no-wrap
msgid ""
"int\n"
"matherr(struct exception *exc)\n"
"{\n"
"    fprintf(stderr, \"matherr %s exception in %s() function\\en\",\n"
"           (exc-E<gt>type == DOMAIN) ?    \"DOMAIN\" :\n"
"           (exc-E<gt>type == OVERFLOW) ?  \"OVERFLOW\" :\n"
"           (exc-E<gt>type == UNDERFLOW) ? \"UNDERFLOW\" :\n"
"           (exc-E<gt>type == SING) ?      \"SING\" :\n"
"           (exc-E<gt>type == TLOSS) ?     \"TLOSS\" :\n"
"           (exc-E<gt>type == PLOSS) ?     \"PLOSS\" : \"???\",\n"
"            exc-E<gt>name);\n"
"    fprintf(stderr, \"        args:   %f, %f\\en\",\n"
"            exc-E<gt>arg1, exc-E<gt>arg2);\n"
"    fprintf(stderr, \"        retval: %f\\en\", exc-E<gt>retval);\n"
msgstr "int\nmatherr(struct exception *exc)\n{\n    fprintf(stderr, \"исключение matherr %s в функции %s()\\en\",\n           (exc-E<gt>type == DOMAIN) ?    \"DOMAIN\" :\n           (exc-E<gt>type == OVERFLOW) ?  \"OVERFLOW\" :\n           (exc-E<gt>type == UNDERFLOW) ? \"UNDERFLOW\" :\n           (exc-E<gt>type == SING) ?      \"SING\" :\n           (exc-E<gt>type == TLOSS) ?     \"TLOSS\" :\n           (exc-E<gt>type == PLOSS) ?     \"PLOSS\" : \"???\",\n            exc-E<gt>name);\n    fprintf(stderr, \"        арг:   %f, %f\\en\",\n            exc-E<gt>arg1, exc-E<gt>arg2);\n    fprintf(stderr, \"        возвр.знач.: %f\\en\", exc-E<gt>retval);\n"

#. type: Plain text
#: man-pages/man3/matherr.3:406
#, no-wrap
msgid ""
"    if (change_retval)\n"
"        exc-E<gt>retval = new_retval;\n"
msgstr "    if (change_retval)\n        exc-E<gt>retval = new_retval;\n"

#. type: Plain text
#: man-pages/man3/matherr.3:409
#, no-wrap
msgid ""
"    return matherr_ret;\n"
"}\n"
msgstr "    return matherr_ret;\n}\n"

#. type: Plain text
#: man-pages/man3/matherr.3:414
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    double x;\n"
msgstr "int\nmain(int argc, char *argv[])\n{\n    double x;\n"

#. type: Plain text
#: man-pages/man3/matherr.3:420
#, no-wrap
msgid ""
"    if (argc E<lt> 2) {\n"
"        fprintf(stderr, \"Usage: %s E<lt>argvalE<gt>\"\n"
"                \" [E<lt>matherr-retE<gt> [E<lt>new-func-retvalE<gt>]]\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr "    if (argc E<lt> 2) {\n        fprintf(stderr, \"Использование: %s E<lt>аргE<gt>\"\n                \" [E<lt>рез-matherrE<gt> [E<lt>рез-нов-функE<gt>]]\\en\", argv[0]);\n        exit(EXIT_FAILURE);\n    }\n"

#. type: Plain text
#: man-pages/man3/matherr.3:425
#, no-wrap
msgid ""
"    if (argc E<gt> 2) {\n"
"        _LIB_VERSION = _SVID_;\n"
"        matherr_ret = atoi(argv[2]);\n"
"    }\n"
msgstr "    if (argc E<gt> 2) {\n        _LIB_VERSION = _SVID_;\n        matherr_ret = atoi(argv[2]);\n    }\n"

#. type: Plain text
#: man-pages/man3/matherr.3:430
#, no-wrap
msgid ""
"    if (argc E<gt> 3) {\n"
"        change_retval = 1;\n"
"        new_retval = atof(argv[3]);\n"
"    }\n"
msgstr "    if (argc E<gt> 3) {\n        change_retval = 1;\n        new_retval = atof(argv[3]);\n    }\n"

#. type: Plain text
#: man-pages/man3/matherr.3:434
#, no-wrap
msgid ""
"    x = log(atof(argv[1]));\n"
"    if (errno != 0)\n"
"        perror(\"errno\");\n"
msgstr "    x = log(atof(argv[1]));\n    if (errno != 0)\n        perror(\"errno\");\n"

#. type: Plain text
#: man-pages/man3/matherr.3:438
#, no-wrap
msgid ""
"    printf(\"x=%f\\en\", x);\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr "    printf(\"x=%f\\en\", x);\n    exit(EXIT_SUCCESS);\n}\n"

#. type: Plain text
#: man-pages/man3/matherr.3:442
msgid "B<fenv>(3), B<math_error>(7), B<standards>(7)"
msgstr "B<fenv>(3), B<math_error>(7), B<standards>(7)"

#. type: TH
#: man-pages/man3/mktemp.3:34
#, no-wrap
msgid "MKTEMP"
msgstr "MKTEMP"

#. type: Plain text
#: man-pages/man3/mktemp.3:37
msgid "mktemp - make a unique temporary filename"
msgstr "mktemp - создаёт уникальное имя для временного файла"

#. type: Plain text
#: man-pages/man3/mktemp.3:42
#, no-wrap
msgid "B<char *mktemp(char *>I<template>B<);>\n"
msgstr "B<char *mktemp(char *>I<template>B<);>\n"

#. type: Plain text
#: man-pages/man3/mktemp.3:50
msgid "B<mktemp>():"
msgstr "B<mktemp>():"

#. type: TP
#: man-pages/man3/mktemp.3:53
#, no-wrap
msgid "Since glibc 2.12:"
msgstr "Начиная с glibc 2.12:"

#. type: Plain text
#: man-pages/man3/mktemp.3:58
#, no-wrap
msgid ""
"(_XOPEN_SOURCE\\ E<gt>=\\ 500) && ! (_POSIX_C_SOURCE\\ E<gt>=\\ 200112L)\n"
"    || /* Glibc since 2.19: */ _DEFAULT_SOURCE\n"
"    || /* Glibc E<lt>= 2.19: */ _SVID_SOURCE || _BSD_SOURCE\n"
msgstr "(_XOPEN_SOURCE\\ E<gt>=\\ 500) && ! (_POSIX_C_SOURCE\\ E<gt>=\\ 200112L)\n    || /* Glibc начиная с 2.19: */ _DEFAULT_SOURCE\n    || /* Glibc E<lt>= 2.19: */ _SVID_SOURCE || _BSD_SOURCE\n"

#. type: TP
#: man-pages/man3/mktemp.3:58
#, no-wrap
msgid "Before glibc 2.12:"
msgstr "До glibc 2.12:"

#.     || _XOPEN_SOURCE\ &&\ _XOPEN_SOURCE_EXTENDED
#. type: Plain text
#: man-pages/man3/mktemp.3:62
msgid "_BSD_SOURCE || _SVID_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 500"
msgstr "_BSD_SOURCE || _SVID_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 500"

#. type: Plain text
#: man-pages/man3/mktemp.3:68
msgid "I<Never use this function>; see BUGS."
msgstr "I<Никогда не используйте эту функцию>; см. ДЕФЕКТЫ"

#. type: Plain text
#: man-pages/man3/mktemp.3:79
msgid ""
"The B<mktemp>()  function generates a unique temporary filename from "
"I<template>.  The last six characters of I<template> must be XXXXXX and "
"these are replaced with a string that makes the filename unique.  Since it "
"will be modified, I<template> must not be a string constant, but should be "
"declared as a character array."
msgstr "Функция B<mktemp>() генерирует на основе шаблона I<template> уникальное имя для временного файла. Последние шесть символов I<template> должны быть равны XXXXXX, они будут заменены на строку, которая сделает имя файла уникальным. Так как I<template> будет меняться, он должен быть объявлен не строковой константой, а массивом символов."

#. type: Plain text
#: man-pages/man3/mktemp.3:90
msgid ""
"The B<mktemp>()  function always returns I<template>.  If a unique name was "
"created, the last six bytes of I<template> will have been modified in such a"
" way that the resulting name is unique (i.e., does not exist already)  If a "
"unique name could not be created, I<template> is made an empty string, and "
"I<errno> is set to indicate the error."
msgstr "Функция B<mktemp>() всегда возвращает I<template>. При создании уникального имени последние шесть байтов I<template> заменяются так, что имя становится уникальным (то есть, такого имени ещё нет). Если уникальное имя невозможно создать, I<template> будет равно пустой строке, а I<errno> будет назначен код ошибки."

#. type: Plain text
#: man-pages/man3/mktemp.3:94
msgid "The last six characters of I<template> were not XXXXXX."
msgstr "Последние шесть символов I<template> не равны XXXXXX."

#. type: tbl table
#: man-pages/man3/mktemp.3:104
#, no-wrap
msgid "B<mktemp>()"
msgstr "B<mktemp>()"

#.  .SH NOTES
#.  The prototype is in
#.  .I <unistd.h>
#.  for libc4, libc5, glibc1; glibc2 follows the Single UNIX Specification
#.  and has the prototype in
#.  .IR <stdlib.h> .
#. type: Plain text
#: man-pages/man3/mktemp.3:116
msgid ""
"4.3BSD, POSIX.1-2001.  POSIX.1-2008 removes the specification of "
"B<mktemp>()."
msgstr "4.3BSD, POSIX.1-2001. В POSIX.1-2008 спецификация B<mktemp>() удалена."

#. type: Plain text
#: man-pages/man3/mktemp.3:131
msgid ""
"Never use B<mktemp>().  Some implementations follow 4.3BSD and replace "
"XXXXXX by the current process ID and a single letter, so that at most 26 "
"different names can be returned.  Since on the one hand the names are easy "
"to guess, and on the other hand there is a race between testing whether the "
"name exists and opening the file, every use of B<mktemp>()  is a security "
"risk.  The race is avoided by B<mkstemp>(3)  and B<mkdtemp>(3)."
msgstr "Никогда не используйте B<mktemp>(). Некоторые реализации следуют 4.3BSD и заменяют XXXXXX текущим ID процесса и одним символом, поэтому может быть возвращено только 26 уникальных имен. С одной стороны такие имена легко подобрать, а с другой есть вероятность возникновения состязательности при проверке существования имени и открытия файла, поэтому каждое использование B<mktemp>() является угрозой безопасности. Состязательность не может возникнуть, если использовать функции B<mkstemp>(3) и B<mkdtemp>(3)."

#. type: Plain text
#: man-pages/man3/mktemp.3:137
msgid ""
"B<mktemp>(1), B<mkdtemp>(3), B<mkstemp>(3), B<tempnam>(3), B<tmpfile>(3), "
"B<tmpnam>(3)"
msgstr "B<mktemp>(1), B<mkdtemp>(3), B<mkstemp>(3), B<tempnam>(3), B<tmpfile>(3), B<tmpnam>(3)"

#. type: TH
#: man-pages/man3/mkdtemp.3:26
#, no-wrap
msgid "MKDTEMP"
msgstr "MKDTEMP"

#. type: TH
#: man-pages/man3/mkdtemp.3:26
#, no-wrap
msgid "2016-07-17"
msgstr "2016-07-17"

#. type: Plain text
#: man-pages/man3/mkdtemp.3:29
msgid "mkdtemp - create a unique temporary directory"
msgstr "mkdtemp - создание временного каталога с уникальным именем"

#. type: Plain text
#: man-pages/man3/mkdtemp.3:34
#, no-wrap
msgid "B<char *mkdtemp(char *>I<template>B<);>\n"
msgstr "B<char *mkdtemp(char *>I<template>B<);>\n"

#. type: Plain text
#: man-pages/man3/mkdtemp.3:42
msgid "B<mkdtemp>():"
msgstr "B<mkdtemp>():"

#. type: Plain text
#: man-pages/man3/mkdtemp.3:47
msgid "/* Since glibc 2.19: */ _DEFAULT_SOURCE"
msgstr "/* Начиная с glibc 2.19: */ _DEFAULT_SOURCE"

#. type: Plain text
#: man-pages/man3/mkdtemp.3:49
msgid "|| /* Glibc 2.19 and earlier: */ _BSD_SOURCE"
msgstr "|| /* glibc 2.19 и старше: */ _BSD_SOURCE"

#. type: Plain text
#: man-pages/man3/mkdtemp.3:52
msgid "|| /* Since glibc 2.10: */ _POSIX_C_SOURCE\\ E<gt>=\\ 200809L"
msgstr "|| /* начиная с glibc 2.10: */ _POSIX_C_SOURCE\\ E<gt>=\\ 200809L"

#. type: Plain text
#: man-pages/man3/mkdtemp.3:68
msgid ""
"The B<mkdtemp>()  function generates a uniquely named temporary directory "
"from I<template>.  The last six characters of I<template> must be XXXXXX and"
" these are replaced with a string that makes the directory name unique.  The"
" directory is then created with permissions 0700.  Since it will be "
"modified, I<template> must not be a string constant, but should be declared "
"as a character array."
msgstr "Функция B<mkdtemp>() создаёт временный каталог с уникальным именем на основе I<template>. Последние шесть символов I<template> должны быть равны XXXXXX; они будут заменены на строку, которая и сделает имя каталога уникальным. После этого будет создан каталог с правами 0700. Так как I<template> меняется, он не должен быть строковой константой, а должен быть объявлен как массив символов."

#. type: Plain text
#: man-pages/man3/mkdtemp.3:75
msgid ""
"The B<mkdtemp>()  function returns a pointer to the modified template string"
" on success, and NULL on failure, in which case I<errno> is set "
"appropriately."
msgstr "В случае успеха B<mkdtemp>() возвращает указатель на изменённую строку шаблона (template), в случае неудачи \\(em NULL, при этом I<errno> устанавливается в соответствующее значение."

#. type: Plain text
#: man-pages/man3/mkdtemp.3:80
msgid ""
"The last six characters of I<template> were not XXXXXX.  Now I<template> is "
"unchanged."
msgstr "Последние шесть символов I<template> не равны XXXXXX. I<template> не изменён."

#. type: Plain text
#: man-pages/man3/mkdtemp.3:84
msgid "Also see B<mkdir>(2)  for other possible values for I<errno>."
msgstr "См. также в B<mkdir>(2) другие возможные значения I<errno>."

#. type: Plain text
#: man-pages/man3/mkdtemp.3:86
msgid "Available since glibc 2.1.91."
msgstr "Доступна в glibc с версии 2.1.91."

#. type: tbl table
#: man-pages/man3/mkdtemp.3:96
#, no-wrap
msgid "B<mkdtemp>()"
msgstr "B<mkdtemp>()"

#.  As at 2006, this function is being considered for a revision of POSIX.1
#.  Also in NetBSD 1.4.
#. type: Plain text
#: man-pages/man3/mkdtemp.3:103
msgid "POSIX.1-2008.  This function is present on the BSDs."
msgstr "POSIX.1-2008. Данная функция есть в реализациях BSD."

#. type: Plain text
#: man-pages/man3/mkdtemp.3:110
msgid ""
"B<mktemp>(1), B<mkdir>(2), B<mkstemp>(3), B<mktemp>(3), B<tempnam>(3), "
"B<tmpfile>(3), B<tmpnam>(3)"
msgstr "B<mktemp>(1), B<mkdir>(2), B<mkstemp>(3), B<mktemp>(3), B<tempnam>(3), B<tmpfile>(3), B<tmpnam>(3)"

#. type: TH
#: man-pages/man3/mcheck.3:25
#, no-wrap
msgid "MCHECK"
msgstr "MCHECK"

#. type: Plain text
#: man-pages/man3/mcheck.3:28
msgid ""
"mcheck, mcheck_check_all, mcheck_pedantic, mprobe - heap consistency "
"checking"
msgstr "mcheck, mcheck_check_all, mcheck_pedantic, mprobe - проверяет целостность кучи"

#. type: Plain text
#: man-pages/man3/mcheck.3:31
#, no-wrap
msgid "B<#include E<lt>mcheck.hE<gt>>\n"
msgstr "B<#include E<lt>mcheck.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/mcheck.3:33
#, no-wrap
msgid ""
"B<int mcheck(void (*>I<abortfunc>B<)(enum mcheck_status >I<mstatus>B<));>\n"
msgstr "B<int mcheck(void (*>I<abortfunc>B<)(enum mcheck_status >I<mstatus>B<));>\n"

#. type: Plain text
#: man-pages/man3/mcheck.3:35
#, no-wrap
msgid ""
"B<int mcheck_pedantic(void (*>I<abortfunc>B<)(enum mcheck_status "
">I<mstatus>B<));>\n"
msgstr "B<int mcheck_pedantic(void (*>I<abortfunc>B<)(enum mcheck_status >I<mstatus>B<));>\n"

#. type: Plain text
#: man-pages/man3/mcheck.3:37
#, no-wrap
msgid "B<void mcheck_check_all(void);>\n"
msgstr "B<void mcheck_check_all(void);>\n"

#. type: Plain text
#: man-pages/man3/mcheck.3:39
#, no-wrap
msgid "B<enum mcheck_status mprobe(void *>I<ptr>B<);>\n"
msgstr "B<enum mcheck_status mprobe(void *>I<ptr>B<);>\n"

#. type: Plain text
#: man-pages/man3/mcheck.3:51
msgid ""
"The B<mcheck>()  function installs a set of debugging hooks for the "
"B<malloc>(3)  family of memory-allocation functions.  These hooks cause "
"certain consistency checks to be performed on the state of the heap.  The "
"checks can detect application errors such as freeing a block of memory more "
"than once or corrupting the bookkeeping data structures that immediately "
"precede a block of allocated memory."
msgstr "Функция B<mcheck>() устанавливает набор отладочных ловушек (hooks) на семейство функций выделения памяти B<malloc>(3). Эти ловушки выполняют определённые проверки целостности состояния кучи. Проверками обнаруживаются следующие ошибки приложения: многократное освобождение одного блока памяти, повреждение структур данных служебной информации, расположенных непосредственно перед блоком выделенной памяти."

#. type: Plain text
#: man-pages/man3/mcheck.3:63
msgid ""
"To be effective, the B<mcheck>()  function must be called before the first "
"call to B<malloc>(3)  or a related function.  In cases where this is "
"difficult to ensure, linking the program with I<-lmcheck> inserts an "
"implicit call to B<mcheck>()  (with a NULL argument)  before the first call "
"to a memory-allocation function."
msgstr "Для эффективной работы функция B<mcheck>() должна вызываться перед первым вызовом B<malloc>(3) или подобной функции. В случаях, когда это трудно проверить, компоновка программы с параметром I<-lmcheck> вставляет неявный вызов B<mcheck>() (с аргументом NULL) перед первым вызовом функции выделения памяти."

#. type: Plain text
#: man-pages/man3/mcheck.3:71
msgid ""
"The B<mcheck_pedantic>()  function is similar to B<mcheck>(), but performs "
"checks on all allocated blocks whenever one of the memory-allocation "
"functions is called.  This can be very slow!"
msgstr "Функция B<mcheck_pedantic>() похожа на B<mcheck>(), но выполняет проверку всех выделенных блоков каждый раз, когда вызывается функция выделения памяти. Она может работать очень медленно!"

#. type: Plain text
#: man-pages/man3/mcheck.3:78
msgid ""
"The B<mcheck_check_all>()  function causes an immediate check on all "
"allocated blocks.  This call is effective only if B<mcheck>()  is called "
"beforehand."
msgstr "Функция B<mcheck_check_all>() выполняет немедленную проверку всех выделенных блоков. Этот вызов эффективно работает только, если перед этим была вызвана B<mcheck>()."

#. type: Plain text
#: man-pages/man3/mcheck.3:91
msgid ""
"If the system detects an inconsistency in the heap, the caller-supplied "
"function pointed to by I<abortfunc> is invoked with a single argument, "
"I<mstatus>, that indicates what type of inconsistency was detected.  If "
"I<abortfunc> is NULL, a default function prints an error message on "
"I<stderr> and calls B<abort>(3)."
msgstr "Если система обнаруживает целостность кучи, то вызывается функция, которую указал вызывающий в I<abortfunc> с единственным аргументом I<mstatus>, который показывает, какой тип рассогласованности обнаружен. Если I<abortfunc> равно NULL, то функция по умолчанию печатает сообщение об ошибке в I<stderr> и вызывает B<abort>(3)."

#. type: Plain text
#: man-pages/man3/mcheck.3:103
msgid ""
"The B<mprobe>()  function performs a consistency check on the block of "
"allocated memory pointed to by I<ptr>.  The B<mcheck>()  function should be "
"called beforehand (otherwise B<mprobe>()  returns B<MCHECK_DISABLED>)."
msgstr "Функция B<mprobe>() выполняет проверку целостности блока выделенной памяти, на который указывает I<ptr>. Перед этим должна вызываться функция B<mcheck>() (в противном случае B<mprobe>() возвращает B<MCHECK_DISABLED>)."

#. type: Plain text
#: man-pages/man3/mcheck.3:111
msgid ""
"The following list describes the values returned by B<mprobe>()  or passed "
"as the I<mstatus> argument when I<abortfunc> is invoked:"
msgstr "Далее перечислены значения, возвращаемые B<mprobe>() или передаваемые в аргументе I<mstatus> при вызове I<abortfunc>:"

#. type: TP
#: man-pages/man3/mcheck.3:111
#, no-wrap
msgid "B<MCHECK_DISABLED> (B<mprobe>() only)"
msgstr "B<MCHECK_DISABLED> (только B<mprobe>())"

#. type: Plain text
#: man-pages/man3/mcheck.3:116
msgid ""
"B<mcheck>()  was not called before the first memory allocation function was "
"called.  Consistency checking is not possible."
msgstr "Не вызвана функция B<mcheck>() до первого вызова функции выделения памяти. Проверка несоответствий невозможна."

#. type: TP
#: man-pages/man3/mcheck.3:116
#, no-wrap
msgid "B<MCHECK_OK> (B<mprobe>() only)"
msgstr "B<MCHECK_OK> (только B<mprobe>())"

#. type: Plain text
#: man-pages/man3/mcheck.3:119
msgid "No inconsistency detected."
msgstr "Никаких несоответствий не обнаружено."

#. type: TP
#: man-pages/man3/mcheck.3:119
#, no-wrap
msgid "B<MCHECK_HEAD>"
msgstr "B<MCHECK_HEAD>"

#. type: Plain text
#: man-pages/man3/mcheck.3:122
msgid "Memory preceding an allocated block was clobbered."
msgstr "Память, предшествующая выделенному блоку, была затёрта."

#. type: TP
#: man-pages/man3/mcheck.3:122
#, no-wrap
msgid "B<MCHECK_TAIL>"
msgstr "B<MCHECK_TAIL>"

#. type: Plain text
#: man-pages/man3/mcheck.3:125
msgid "Memory following an allocated block was clobbered."
msgstr "Память после выделенного блока была затёрта."

#. type: TP
#: man-pages/man3/mcheck.3:125
#, no-wrap
msgid "B<MCHECK_FREE>"
msgstr "B<MCHECK_FREE>"

#. type: Plain text
#: man-pages/man3/mcheck.3:129
msgid "A block of memory was freed twice."
msgstr "Блок памяти был освобожден дважды."

#. type: Plain text
#: man-pages/man3/mcheck.3:134
msgid ""
"B<mcheck>()  and B<mcheck_pedantic>()  return 0 on success, or -1 on error."
msgstr "При успешном выполнении B<mcheck>()  и B<mcheck_pedantic>() возвращают 0, а в случае ошибки возвращают -1."

#. type: Plain text
#: man-pages/man3/mcheck.3:145
msgid ""
"The B<mcheck_pedantic>()  and B<mcheck_check_all>()  functions are available"
" since glibc 2.2.  The B<mcheck>()  and B<mprobe>()  functions are present "
"since at least glibc 2.0"
msgstr "Функции B<mcheck_pedantic>() и B<mcheck_check_all>() доступны начиная с glibc 2.2. Функции B<mcheck>() и B<mprobe>() появились, как минимум, начиная с glibc 2.0."

#. type: tbl table
#: man-pages/man3/mcheck.3:156
#, no-wrap
msgid ""
"B<mcheck>(),\n"
"B<mcheck_pedantic>(),\n"
msgstr "B<mcheck>(),\nB<mcheck_pedantic>(),\n"

#. type: tbl table
#: man-pages/man3/mcheck.3:156 man-pages/man3/mcheck.3:161
#, no-wrap
msgid ".br\n"
msgstr ".br\n"

#. type: tbl table
#: man-pages/man3/mcheck.3:159
#, no-wrap
msgid ""
"B<mcheck_check_all>(),\n"
"B<mprobe>()"
msgstr "B<mcheck_check_all>(),\nB<mprobe>()"

#. type: tbl table
#: man-pages/man3/mcheck.3:161
#, no-wrap
msgid "MT-Unsafe race:mcheck\n"
msgstr "MT-Unsafe race:mcheck\n"

#. type: tbl table
#: man-pages/man3/mcheck.3:163
#, no-wrap
msgid "const:malloc_hooks"
msgstr "const:malloc_hooks"

#. type: Plain text
#: man-pages/man3/mcheck.3:168
msgid "These functions are GNU extensions."
msgstr "Эти функции являются расширениями GNU."

#.  But is MALLOC_CHECK_ slower?
#. type: Plain text
#: man-pages/man3/mcheck.3:180
msgid ""
"Linking a program with I<-lmcheck> and using the B<MALLOC_CHECK_> "
"environment variable (described in B<mallopt>(3))  cause the same kinds of "
"errors to be detected.  But, using B<MALLOC_CHECK_> does not require the "
"application to be relinked."
msgstr "Компоновка программы с I<-lmcheck> и использование переменной окружения B<MALLOC_CHECK_> (описана в B<mallopt>(3)) обнаруживают ошибки схожим образом. Но при использовании B<MALLOC_CHECK_> не требуется перекомпоновывать приложение."

#. type: Plain text
#: man-pages/man3/mcheck.3:186
msgid ""
"The program below calls B<mcheck>()  with a NULL argument and then frees the"
" same block of memory twice.  The following shell session demonstrates what "
"happens when running the program:"
msgstr "Программа, представленная ниже, вызывает B<mcheck>() с аргументом NULL и затем освобождает один и тот же блок дважды. В следующем сеансе оболочки показано что случается при запуске программы:"

#. type: Plain text
#: man-pages/man3/mcheck.3:191
#, no-wrap
msgid ""
"$B< ./a.out>\n"
"About to free\n"
msgstr "$B< ./a.out>\nОсвобождаем\n"

#. type: Plain text
#: man-pages/man3/mcheck.3:195
#, no-wrap
msgid ""
"About to free a second time\n"
"block freed twice\n"
"Aborted (core dumped)\n"
msgstr "Освобождаем второй раз\nблок освобождён дважды\nAborted (core dumped)\n"

#. type: Plain text
#: man-pages/man3/mcheck.3:203
#, no-wrap
msgid ""
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>mcheck.hE<gt>\n"
msgstr "#include E<lt>stdlib.hE<gt>\n#include E<lt>stdio.hE<gt>\n#include E<lt>mcheck.hE<gt>\n"

#. type: Plain text
#: man-pages/man3/mcheck.3:208
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    char *p;\n"
msgstr "int\nmain(int argc, char *argv[])\n{\n    char *p;\n"

#. type: Plain text
#: man-pages/man3/mcheck.3:211
#, no-wrap
msgid ""
"    if (mcheck(NULL) != 0) {\n"
"        fprintf(stderr, \"mcheck() failed\\en\");\n"
msgstr "    if (mcheck(NULL) != 0) {\n        fprintf(stderr, \"ошибка mcheck()\\en\");\n"

#. type: Plain text
#: man-pages/man3/mcheck.3:214
#, no-wrap
msgid ""
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr "        exit(EXIT_FAILURE);\n    }\n"

#. type: Plain text
#: man-pages/man3/mcheck.3:216
#, no-wrap
msgid "    p = malloc(1000);\n"
msgstr "    p = malloc(1000);\n"

#. type: Plain text
#: man-pages/man3/mcheck.3:221
#, no-wrap
msgid ""
"    fprintf(stderr, \"About to free\\en\");\n"
"    free(p);\n"
"    fprintf(stderr, \"\\enAbout to free a second time\\en\");\n"
"    free(p);\n"
msgstr "    fprintf(stderr, \"Освобождаем\\en\");\n    free(p);\n    fprintf(stderr, \"\\enОсвобождаем второй раз\\en\");\n    free(p);\n"

#. type: Plain text
#: man-pages/man3/mcheck.3:228
msgid "B<malloc>(3), B<mallopt>(3), B<mtrace>(3)"
msgstr "B<malloc>(3), B<mallopt>(3), B<mtrace>(3)"

#. type: TH
#: man-pages/man3/mallopt.3:26
#, no-wrap
msgid "MALLOPT"
msgstr "MALLOPT"

#. type: Plain text
#: man-pages/man3/mallopt.3:29
msgid "mallopt - set memory allocation parameters"
msgstr "mallopt - задаёт параметры выделения памяти"

#. type: Plain text
#: man-pages/man3/mallopt.3:31
msgid "B<#include E<lt>malloc.hE<gt>>"
msgstr "B<#include E<lt>malloc.hE<gt>>"

#. type: Plain text
#: man-pages/man3/mallopt.3:33
msgid "B<int mallopt(int >I<param>B<, int >I<value>B<);>"
msgstr "B<int mallopt(int >I<param>B<, int >I<value>B<);>"

#. type: Plain text
#: man-pages/man3/mallopt.3:44
msgid ""
"The B<mallopt>()  function adjusts parameters that control the behavior of "
"the memory-allocation functions (see B<malloc>(3)).  The I<param> argument "
"specifies the parameter to be modified, and I<value> specifies the new value"
" for that parameter."
msgstr "Функция B<mallopt>() подстраивает параметры, которые управляют поведением функций выделения памяти (смотрите B<malloc>(3)). В аргументе I<param> указывается изменяемый параметр, а в I<value> — новое значение этого параметра."

#. type: Plain text
#: man-pages/man3/mallopt.3:47
msgid "The following values can be specified for I<param>:"
msgstr "В I<param> можно указать следующие значения:"

#. type: TP
#: man-pages/man3/mallopt.3:47
#, no-wrap
msgid "B<M_ARENA_MAX>"
msgstr "B<M_ARENA_MAX>"

#. type: Plain text
#: man-pages/man3/mallopt.3:59
msgid ""
"If this parameter has a nonzero value, it defines a hard limit on the "
"maximum number of arenas that can be created.  An arena represents a pool of"
" memory that can be used by B<malloc>(3)  (and similar) calls to service "
"allocation requests.  Arenas are thread safe and therefore may have multiple"
" concurrent memory requests.  The trade-off is between the number of threads"
" and the number of arenas.  The more arenas you have, the lower the per-"
"thread contention, but the higher the memory usage."
msgstr "Если этот параметр не равен нулю, то он определяет жёсткое ограничение на максимальное количество площадок (arenas), которое можно создать. Площадка представляет собой общий набор буферов (pool) памяти, который может использовать вызов B<malloc>(3) (и подобные) для обслуживания запросов выделения. Площадки безопасны в нитях и поэтому могут использоваться при одновременных запросах выделения. Нужно соблюдать соотношение между количеством нитей и количеством площадок. Чем больше площадок, тем меньше состязаний между нитями, но большее потребление памяти."

#. type: Plain text
#: man-pages/man3/mallopt.3:64
msgid ""
"The default value of this parameter is 0, meaning that the limit on the "
"number of arenas is determined according to the setting of B<M_ARENA_TEST>."
msgstr "Значение по умолчанию данного параметра равно 0, то есть ограничение на количество площадок будет определяться по B<M_ARENA_TEST>."

#. type: Plain text
#: man-pages/man3/mallopt.3:70
msgid ""
"This parameter has been available since glibc 2.10 via B<--enable-"
"experimental-malloc>, and since glibc 2.15 by default.  In some versions of "
"the allocator there was no limit on the number of created arenas (e.g., "
"CentOS 5, RHEL 5)."
msgstr "Этот параметр доступен начиная с glibc 2.10 при указании B<--enable-experimental-malloc>, и начиная с glibc 2.15 — по умолчанию. В некоторых версиях механизм выделения не имел ограничения на количество создаваемых площадок (например, в CentOS 5, RHEL 5)."

#. type: Plain text
#: man-pages/man3/mallopt.3:78
msgid ""
"When employing newer glibc versions, applications may in some cases exhibit "
"high contention when accessing arenas.  In these cases, it may be beneficial"
" to increase B<M_ARENA_MAX> to match the number of threads.  This is similar"
" in behavior to strategies taken by tcmalloc and jemalloc (e.g., per-thread "
"allocation pools)."
msgstr "При использовании более новых версий glibc приложения могут, в некоторых случаях, встретить высокую состязательность при доступе к площадкам. В этих случаях  может быть выгодно  увеличить B<M_ARENA_MAX> для соответствия количеству нитей. Такое поведение подобно стратегиям, используемым tcmalloc и jemalloc (например, общие наборы буферов выделения для каждой нити)."

#. type: TP
#: man-pages/man3/mallopt.3:78
#, no-wrap
msgid "B<M_ARENA_TEST>"
msgstr "B<M_ARENA_TEST>"

#. type: Plain text
#: man-pages/man3/mallopt.3:86
msgid ""
"This parameter specifies a value, in number of arenas created, at which "
"point the system configuration will be examined to determine a hard limit on"
" the number of created arenas.  (See B<M_ARENA_MAX> for the definition of an"
" arena.)"
msgstr "Этим параметром определяется значение на количество создаваемых площадок; в соответствии с ним будут исследоваться системные настройки для оценки жёсткого ограничения на количество создаваемых площадок (определение площадки смотрите в описании B<M_ARENA_MAX>)."

#. type: Plain text
#: man-pages/man3/mallopt.3:91
msgid ""
"The computation of the arena hard limit is implementation-defined and is "
"usually calculated as a multiple of the number of available CPUs.  Once the "
"hard limit is computed, the result is final and constrains the total number "
"of arenas."
msgstr "Вычисленное жёсткое ограничение на площадки определяется реализацией и, обычно, кратно количеству доступных ЦП. После вычисления жёсткого ограничения, результат окончательный и ограничивает общее количество площадок."

#. type: Plain text
#: man-pages/man3/mallopt.3:97
msgid ""
"The default value for the B<M_ARENA_TEST> parameter is 2 on systems where "
"I<sizeof(long)> is 4; otherwise the default value is 8."
msgstr "Значение по умолчанию для параметра B<M_ARENA_TEST> равно 2 в системах, где I<sizeof(long)> равно 4; в противном случае значение по умолчанию равно 8."

#. type: Plain text
#: man-pages/man3/mallopt.3:101
msgid ""
"This parameter has been available since glibc 2.10 via B<--enable-"
"experimental-malloc>, and since glibc 2.15 by default."
msgstr "Этот параметр доступен начиная с glibc 2.10 при указании B<--enable-experimental-malloc>, и начиная с glibc 2.15 — по умолчанию."

#. type: Plain text
#: man-pages/man3/mallopt.3:107
msgid ""
"The value of B<M_ARENA_TEST> is not used when B<M_ARENA_MAX> has a nonzero "
"value."
msgstr "Значение B<M_ARENA_TEST> не используется, если B<M_ARENA_MAX> не равно нулю."

#. type: TP
#: man-pages/man3/mallopt.3:107
#, no-wrap
msgid "B<M_CHECK_ACTION>"
msgstr "B<M_CHECK_ACTION>"

#. type: Plain text
#: man-pages/man3/mallopt.3:113
msgid ""
"Setting this parameter controls how glibc responds when various kinds of "
"programming errors are detected (e.g., freeing the same pointer twice).  The"
" 3 least significant bits (2, 1, and 0) of the value assigned to this "
"parameter determine the glibc behavior, as follows:"
msgstr "Значение данного параметра управляет тем, как glibc действует при обнаружении различных программных ошибок (например, освобождение одного указателя дважды). Поведение glibc задаётся тремя битами (2, 1 и 0) указанного значения:"

#. type: TP
#: man-pages/man3/mallopt.3:114
#, no-wrap
msgid "Bit 0"
msgstr "Бит 0"

#. type: Plain text
#: man-pages/man3/mallopt.3:124
msgid ""
"If this bit is set, then print a one-line message on I<stderr> that provides"
" details about the error.  The message starts with the string \"***\\ glibc "
"detected\\ ***\", followed by the program name, the name of the memory-"
"allocation function in which the error was detected, a brief description of "
"the error, and the memory address where the error was detected."
msgstr "Если этот бит установлен, то печатается сообщение в I<stderr> с подробностями ошибки. Сообщение начинается со строки «***\\ glibc detected\\ ***», далее идёт имя программы, имя функции выделения памяти, в которой возникла ошибка, краткое описание ошибки и адрес памяти, где обнаружена ошибка."

#. type: TP
#: man-pages/man3/mallopt.3:124
#, no-wrap
msgid "Bit 1"
msgstr "Бит 1"

#. type: Plain text
#: man-pages/man3/mallopt.3:139
msgid ""
"If this bit is set, then, after printing any error message specified by bit "
"0, the program is terminated by calling B<abort>(3).  In glibc versions "
"since 2.4, if bit 0 is also set, then, between printing the error message "
"and aborting, the program also prints a stack trace in the manner of "
"B<backtrace>(3), and prints the process's memory mapping in the style of "
"I</proc/[pid]/maps> (see B<proc>(5))."
msgstr "Если этот бит установлен, то после печати сообщения об ошибке, если указано битом 0, программа завершается вызовом B<abort>(3). В glibc с версии 2.4, если также установлен бит 0, то между печатью сообщения об ошибке и завершением программа также печатает трассировку стека подобную B<backtrace>(3), и печатает отображение памяти процесса в стиле I</proc/[pid]/maps> (смотрите B<proc>(5))."

#. type: TP
#: man-pages/man3/mallopt.3:139
#, no-wrap
msgid "Bit 2 (since glibc 2.4)"
msgstr "Бит 2 (начиная с glibc 2.4)"

#. type: Plain text
#: man-pages/man3/mallopt.3:146
msgid ""
"This bit has an effect only if bit 0 is also set.  If this bit is set, then "
"the one-line message describing the error is simplified to contain just the "
"name of the function where the error was detected and the brief description "
"of the error."
msgstr "Этот бит учитывается только если установлен бит 0. Если данный бит установлен, то выдаваемое сообщение об ошибке упрощается до имени функции, где обнаружена ошибка и короткого описания ошибки."

#. type: Plain text
#: man-pages/man3/mallopt.3:151
msgid "The remaining bits in I<value> are ignored."
msgstr "Оставшиеся биты в  I<value> игнорируются."

#. type: Plain text
#: man-pages/man3/mallopt.3:155
msgid ""
"Combining the above details, the following numeric values are meaningful for"
" B<M_CHECK_ACTION>:"
msgstr "Объединяя выше описанное, получаются следующие числовые значения, влияющие на B<M_CHECK_ACTION>:"

#. type: Plain text
#: man-pages/man3/mallopt.3:158
msgid "Ignore error conditions; continue execution (with undefined results)."
msgstr "Игнорировать условия ошибки; продолжить выполнение (с неопределенными результатами)."

#. type: Plain text
#: man-pages/man3/mallopt.3:160
msgid "Print a detailed error message and continue execution."
msgstr "Вывести подробное сообщение об ошибке и продолжить выполнение."

#. type: Plain text
#: man-pages/man3/mallopt.3:162
msgid "Abort the program."
msgstr "Прервать программу."

#. type: Plain text
#: man-pages/man3/mallopt.3:165
msgid ""
"Print detailed error message, stack trace, and memory mappings, and abort "
"the program."
msgstr "Вывести подробное сообщение об ошибке, трассировку стека и отображения памяти, а затем прервать программу."

#. type: Plain text
#: man-pages/man3/mallopt.3:167
msgid "Print a simple error message and continue execution."
msgstr "Вывести простое сообщение об ошибке и продолжить выполнение."

#. type: Plain text
#: man-pages/man3/mallopt.3:170
msgid ""
"Print simple error message, stack trace, and memory mappings, and abort the "
"program."
msgstr "Вывести простое сообщение об ошибке, трассировку стека и отображения памяти, и прервать программу."

#. type: Plain text
#: man-pages/man3/mallopt.3:176
msgid ""
"Since glibc 2.3.4, the default value for the B<M_CHECK_ACTION> parameter is "
"3.  In glibc version 2.3.3 and earlier, the default value is 1."
msgstr "Начиная с glibc 2.3.4, значение параметра B<M_CHECK_ACTION> по умолчанию равно 3. В glibc версии 2.3.3 и старее значением по умолчанию было 1."

#. type: Plain text
#: man-pages/man3/mallopt.3:181
msgid ""
"Using a nonzero B<M_CHECK_ACTION> value can be useful because otherwise a "
"crash may happen much later, and the true cause of the problem is then very "
"hard to track down."
msgstr "Использование ненулевого значения B<M_CHECK_ACTION> может быть полезно, так как в противном случае падение может случиться позднее и будет сложно отследить реальную причину проблемы."

#. type: TP
#: man-pages/man3/mallopt.3:181
#, no-wrap
msgid "B<M_MMAP_MAX>"
msgstr "B<M_MMAP_MAX>"

#.  The following text adapted from comments in the glibc source:
#. type: Plain text
#: man-pages/man3/mallopt.3:191
msgid ""
"This parameter specifies the maximum number of allocation requests that may "
"be simultaneously serviced using B<mmap>(2).  This parameter exists because "
"some systems have a limited number of internal tables for use by B<mmap>(2),"
" and using more than a few of them may degrade performance."
msgstr "Данным параметром задаётся максимальное количество запросов выделения, которые может одновременно выполнить B<mmap>(2). Этот параметр существует, так как в некоторых системах ограничено количество внутренних таблиц, используемых B<mmap>(2), и использование больше определённого количество снижает производительность."

#. type: Plain text
#: man-pages/man3/mallopt.3:198
msgid ""
"The default value is 65,536, a value which has no special significance and "
"which serves only as a safeguard.  Setting this parameter to 0 disables the "
"use of B<mmap>(2)  for servicing large allocation requests."
msgstr "По умолчанию значение равно 65536; оно не имеет какого-то специального обоснования и служит только как предохранитель. Присвоение этому параметру 0 отключает использование B<mmap>(2) для обслуживания запросов больших выделений."

#. type: TP
#: man-pages/man3/mallopt.3:198
#, no-wrap
msgid "B<M_MMAP_THRESHOLD>"
msgstr "B<M_MMAP_THRESHOLD>"

#. type: Plain text
#: man-pages/man3/mallopt.3:207
msgid ""
"For allocations greater than or equal to the limit specified (in bytes) by "
"B<M_MMAP_THRESHOLD> that can't be satisfied from the free list, the memory-"
"allocation functions employ B<mmap>(2)  instead of increasing the program "
"break using B<sbrk>(2)."
msgstr "Для выделений, которые больше или равны B<M_MMAP_THRESHOLD> (в байтах) и не могут быть получены из списка свободных, то функции выделения памяти вместо B<mmap>(2) используют B<sbrk>(2) для увеличения пространства данных программы."

#. type: Plain text
#: man-pages/man3/mallopt.3:227
msgid ""
"Allocating memory using B<mmap>(2)  has the significant advantage that the "
"allocated memory blocks can always be independently released back to the "
"system.  (By contrast, the heap can be trimmed only if memory is freed at "
"the top end.)  On the other hand, there are some disadvantages to the use of"
" B<mmap>(2): deallocated space is not placed on the free list for reuse by "
"later allocations; memory may be wasted because B<mmap>(2)  allocations must"
" be page-aligned; and the kernel must perform the expensive task of zeroing "
"out memory allocated via B<mmap>(2).  Balancing these factors leads to a "
"default setting of 128*1024 for the B<M_MMAP_THRESHOLD> parameter."
msgstr "Выделяемая с помощью B<mmap>(2) память имеет значительное преимущество в том, что выделенные блоки памяти можно всегда независимо освободить и вернуть системе (по сравнению с кучей, которую можно обрезать только, если память свободна в конце). С другой стороны, есть несколько отрицательных моментов при использовании B<mmap>(2): освобождённое пространство не возвращается в список свободного для повторного выделения позже; память может траться впустую, так как выделения B<mmap>(2) должны быть кратны размеру страницы; ядро должно выполнять ресурсоёмкую задачу по обнулению памяти, выделяемой через B<mmap>(2). Баланс этих факторов учтён в значении по умолчанию для параметра B<M_MMAP_THRESHOLD> — 128*1024."

#. type: Plain text
#: man-pages/man3/mallopt.3:234
msgid ""
"The lower limit for this parameter is 0.  The upper limit is "
"B<DEFAULT_MMAP_THRESHOLD_MAX>: 512*1024 on 32-bit systems or "
"I<4*1024*1024*sizeof(long)> on 64-bit systems."
msgstr "Нижний предел данного параметра равен 0. Верхний предел B<DEFAULT_MMAP_THRESHOLD_MAX>: 512*1024 в 32-битных системах и I<4*1024*1024*sizeof(long)> в 64-битных системах."

#. type: Plain text
#: man-pages/man3/mallopt.3:252
msgid ""
"I<Note:> Nowadays, glibc uses a dynamic mmap threshold by default.  The "
"initial value of the threshold is 128*1024, but when blocks larger than the "
"current threshold and less than or equal to B<DEFAULT_MMAP_THRESHOLD_MAX> "
"are freed, the threshold is adjusted upward to the size of the freed block."
"  When dynamic mmap thresholding is in effect, the threshold for trimming "
"the heap is also dynamically adjusted to be twice the dynamic mmap "
"threshold.  Dynamic adjustment of the mmap threshold is disabled if any of "
"the B<M_TRIM_THRESHOLD>, B<M_TOP_PAD>, B<M_MMAP_THRESHOLD>, or B<M_MMAP_MAX>"
" parameters is set."
msgstr "I<Замечание:> В настоящее время по умолчанию в glibc используется динамический порог mmap. Начальное значение порога — 128*1024, но когда освобождаются блоки больше текущего порога и меньше или равны B<DEFAULT_MMAP_THRESHOLD_MAX>, то порог увеличивается до размера свободного блока. Когда срабатывает динамический порог mmap, порог обрезки кучи также динамически корректируется на двукратное значение динамического порога mmap.Динамическая корректировка  порога mmap отключается, если задан параметр B<M_TRIM_THRESHOLD>, B<M_TOP_PAD>, B<M_MMAP_THRESHOLD> или B<M_MMAP_MAX>."

#. type: TP
#: man-pages/man3/mallopt.3:252
#, no-wrap
msgid "B<M_MXFAST> (since glibc 2.3)"
msgstr "B<M_MXFAST> (начиная с glibc 2.3)"

#.  The following text adapted from comments in the glibc sources:
#. type: Plain text
#: man-pages/man3/mallopt.3:264
msgid ""
"Set the upper limit for memory allocation requests that are satisfied using "
"\"fastbins\".  (The measurement unit for this parameter is bytes.)  Fastbins"
" are storage areas that hold deallocated blocks of memory of the same size "
"without merging adjacent free blocks.  Subsequent reallocation of blocks of "
"the same size can be handled very quickly by allocating from the fastbin, "
"although memory fragmentation and the overall memory footprint of the "
"program can increase."
msgstr "Задаёт верхний порог запросов выделения памяти, которые обрабатываются с помощью «fastbins» (значение параметра измеряется в байтах). Fastbins — это области хранилища, которые содержат освобождённые блоки памяти одного размера и не объединяют смежные свободные блоки. Последующее перераспределение блоков одного размера при выделении из fastbin может обрабатываться очень быстро, хотя из-за этого может увеличиться фрагментация памяти и общее количество памяти программы."

#. type: Plain text
#: man-pages/man3/mallopt.3:273
msgid ""
"The default value for this parameter is I<64*sizeof(size_t)/4> (i.e., 64 on "
"32-bit architectures).  The range for this parameter is 0 to "
"I<80*sizeof(size_t)/4>.  Setting B<M_MXFAST> to 0 disables the use of "
"fastbins."
msgstr "По умолчанию значение параметра равно I<64*sizeof(size_t)/4> (т. е., 64 на 32-битных архитектурах). Диапазон значений параметра: 0 - I<80*sizeof(size_t)/4>. Присваивание B<M_MXFAST> значения 0 отключает использование fastbins."

#. type: TP
#: man-pages/man3/mallopt.3:273
#, no-wrap
msgid "B<M_PERTURB> (since glibc 2.4)"
msgstr "B<M_PERTURB> (начиная с glibc 2.4)"

#. type: Plain text
#: man-pages/man3/mallopt.3:288
msgid ""
"If this parameter is set to a nonzero value, then bytes of allocated memory "
"(other than allocations via B<calloc>(3))  are initialized to the complement"
" of the value in the least significant byte of I<value>, and when allocated "
"memory is released using B<free>(3), the freed bytes are set to the least "
"significant byte of I<value>.  This can be useful for detecting errors where"
" programs incorrectly rely on allocated memory being initialized to zero, or"
" reuse values in memory that has already been freed."
msgstr "Если этому параметру присвоено ненулевое значение, то байты выделенной памяти (кроме выделенных через B<calloc>(3)) инициализируются дополнением значения в наименее значимом байте I<value>, и при освобождении памяти с помощью B<free>(3) освобождённым байтам присваивается значение наименее значимого байта I<value>. Это может быть полезно для обнаружения ошибок, когда программа некорректно полагается на то, что выделенная памяти инициализируется нулями или повторно использует значения уже освобождённой памяти."

#. type: Plain text
#: man-pages/man3/mallopt.3:290
msgid "The default value for this parameter is 0."
msgstr "Значение по умолчанию для этого параметра равно 0."

#. type: TP
#: man-pages/man3/mallopt.3:290
#, no-wrap
msgid "B<M_TOP_PAD>"
msgstr "B<M_TOP_PAD>"

#. type: Plain text
#: man-pages/man3/mallopt.3:297
msgid ""
"This parameter defines the amount of padding to employ when calling "
"B<sbrk>(2)  to modify the program break.  (The measurement unit for this "
"parameter is bytes.)  This parameter has an effect in the following "
"circumstances:"
msgstr "Данным параметром определяется количество заполнения при вызове B<sbrk>(2) для изменения пространства данных программы (измеряется в байтах). Данный параметр полезен в следующих случаях:"

#. type: Plain text
#: man-pages/man3/mallopt.3:304
msgid ""
"When the program break is increased, then B<M_TOP_PAD> bytes are added to "
"the B<sbrk>(2)  request."
msgstr "Когда пространство данных программы увеличивается, то B<M_TOP_PAD> байт добавляется к запросу B<sbrk>(2)."

#. type: Plain text
#: man-pages/man3/mallopt.3:310
msgid ""
"When the heap is trimmed as a consequence of calling B<free>(3)  (see the "
"discussion of B<M_TRIM_THRESHOLD>)  this much free space is preserved at the"
" top of the heap."
msgstr "Когда обрезается куча в следствии вызова B<free>(3) (смотрите описание B<M_TRIM_THRESHOLD>), то это количество пространства предохраняется вверху кучи."

#. type: Plain text
#: man-pages/man3/mallopt.3:314
msgid ""
"In either case, the amount of padding is always rounded to a system page "
"boundary."
msgstr "В обоих случаях, количество заполнения всегда округляется до границы системной страницы."

#. type: Plain text
#: man-pages/man3/mallopt.3:321
msgid ""
"Modifying B<M_TOP_PAD> is a trade-off between increasing the number of "
"system calls (when the parameter is set low)  and wasting unused memory at "
"the top of the heap (when the parameter is set high)."
msgstr "Изменение B<M_TOP_PAD> — компромисс между увеличением количества системных вызовов (если значение параметра занижено) и тратой неиспользуемой памяти сверху кучи (если значение параметра завышено)."

#.  DEFAULT_TOP_PAD in glibc source
#. type: Plain text
#: man-pages/man3/mallopt.3:324
msgid "The default value for this parameter is 128*1024."
msgstr "Значение по умолчанию этого параметра равно 128*1024."

#. type: TP
#: man-pages/man3/mallopt.3:324
#, no-wrap
msgid "B<M_TRIM_THRESHOLD>"
msgstr "B<M_TRIM_THRESHOLD>"

#. type: Plain text
#: man-pages/man3/mallopt.3:340
msgid ""
"When the amount of contiguous free memory at the top of the heap grows "
"sufficiently large, B<free>(3)  employs B<sbrk>(2)  to release this memory "
"back to the system.  (This can be useful in programs that continue to "
"execute for a long period after freeing a significant amount of memory.)  "
"The B<M_TRIM_THRESHOLD> parameter specifies the minimum size (in bytes) that"
" this block of memory must reach before B<sbrk>(2)  is used to trim the "
"heap."
msgstr "Когда количество непрерывной свободной памяти сверху кучи вырастает до значительных размеров функция B<free>(3) вызывает B<sbrk>(2) для освобождения этой памяти обратно в систему (это может быть полезно в программах, которые работают длительное время после освобождения значительного количества памяти). Параметром B<M_TRIM_THRESHOLD> задаётся минимальный размер (в байтах), которого должен достигнуть блок памяти, чтобы вызвался B<sbrk>(2) для обрезания кучи."

#. type: Plain text
#: man-pages/man3/mallopt.3:345
msgid ""
"The default value for this parameter is 128*1024.  Setting "
"B<M_TRIM_THRESHOLD> to -1 disables trimming completely."
msgstr "Значение по умолчанию этого параметра равно 128*1024. Установка B<M_TRIM_THRESHOLD> равным -1 отключает обрезку."

#. type: Plain text
#: man-pages/man3/mallopt.3:353
msgid ""
"Modifying B<M_TRIM_THRESHOLD> is a trade-off between increasing the number "
"of system calls (when the parameter is set low)  and wasting unused memory "
"at the top of the heap (when the parameter is set high)."
msgstr "Изменение B<M_TRIM_THRESHOLD> — компромисс между увеличением количества системных вызовов (если значение параметра занижено) и тратой неиспользуемой памяти сверху кучи (если значение параметра завышено)."

#. type: SS
#: man-pages/man3/mallopt.3:353
#, no-wrap
msgid "Environment variables"
msgstr "Переменные окружения"

#. type: Plain text
#: man-pages/man3/mallopt.3:368
msgid ""
"A number of environment variables can be defined to modify some of the same "
"parameters as are controlled by B<mallopt>().  Using these variables has the"
" advantage that the source code of the program need not be changed.  To be "
"effective, these variables must be defined before the first call to a "
"memory-allocation function.  (If the same parameters are adjusted via "
"B<mallopt>(), then the B<mallopt>()  settings take precedence.)  For "
"security reasons, these variables are ignored in set-user-ID and set-group-"
"ID programs."
msgstr "Параметры, управляющие B<mallopt>(), можно изменить и через переменные окружения. Использование этих переменных позволяет изменять работу программы без пересборки из исходного кода. В целях эффективной работы эти переменные должны быть определены до первого вызова функции выделения памяти (если этот же параметр изменяется через B<mallopt>(), то вызов B<mallopt>() имеет приоритет). В целях безопасности, эти переменные игнорируются для программ с установленными битами set-user-ID и set-group-ID."

#. type: Plain text
#: man-pages/man3/mallopt.3:371
msgid ""
"The environment variables are as follows (note the trailing underscore at "
"the end of the name of some variables):"
msgstr "Используются следующие переменные окружения (обратите внимание на подчёркивание в конце некоторых переменных):"

#. type: TP
#: man-pages/man3/mallopt.3:371
#, no-wrap
msgid "B<MALLOC_ARENA_MAX>"
msgstr "B<MALLOC_ARENA_MAX>"

#. type: Plain text
#: man-pages/man3/mallopt.3:376
msgid "Controls the same parameter as B<mallopt>()  B<M_ARENA_MAX>."
msgstr "Управляет параметром B<M_ARENA_MAX>, аналогично вызову B<mallopt>()."

#. type: TP
#: man-pages/man3/mallopt.3:376
#, no-wrap
msgid "B<MALLOC_ARENA_TEST>"
msgstr "B<MALLOC_ARENA_TEST>"

#. type: Plain text
#: man-pages/man3/mallopt.3:381
msgid "Controls the same parameter as B<mallopt>()  B<M_ARENA_TEST>."
msgstr "Управляет параметром B<M_ARENA_TEST>, аналогично вызову B<mallopt>()."

#. type: TP
#: man-pages/man3/mallopt.3:381
#, no-wrap
msgid "B<MALLOC_CHECK_>"
msgstr "B<MALLOC_CHECK_>"

#.  On glibc 2.12/x86, a simple malloc()+free() loop is about 70% slower
#.  when MALLOC_CHECK_ was set.
#. type: Plain text
#: man-pages/man3/mallopt.3:398
msgid ""
"This environment variable controls the same parameter as B<mallopt>()  "
"B<M_CHECK_ACTION>.  If this variable is set to a nonzero value, then a "
"special implementation of the memory-allocation functions is used.  (This is"
" accomplished using the B<malloc_hook>(3)  feature.)  This implementation "
"performs additional error checking, but is slower than the standard set of "
"memory-allocation functions.  (This implementation does not detect all "
"possible errors; memory leaks can still occur.)"
msgstr "Эта переменная окружения управляет тем же параметром что и B<mallopt>() B<M_CHECK_ACTION>. Если эта переменная установлена в ненулевое значение, то будет использоваться особенная реализация функций выделения памяти (это достигается использованием функции B<malloc_hook>(3)). Эта реализация выполняет дополнительные проверки ошибок, но она медленнее чем стандартный набор функций выделения памяти (эта реализация не способна обнаружить все возможные ошибки; утечки памяти всё ещё возможны)."

#. type: Plain text
#: man-pages/man3/mallopt.3:403
msgid ""
"The value assigned to this environment variable should be a single digit, "
"whose meaning is as described for B<M_CHECK_ACTION>.  Any characters beyond "
"the initial digit are ignored."
msgstr "Значение, назначенное этой переменной окружения должно быть одиночной цифрой; их значения описаны в B<M_CHECK_ACTION>. Все символы кроме первой цифры игнорируются."

#. type: Plain text
#: man-pages/man3/mallopt.3:412
msgid ""
"For security reasons, the effect of B<MALLOC_CHECK_> is disabled by default "
"for set-user-ID and set-group-ID programs.  However, if the file I</etc"
"/suid-debug> exists (the content of the file is irrelevant), then "
"B<MALLOC_CHECK_> also has an effect for set-user-ID and set-group-ID "
"programs."
msgstr "В целях безопасности по умолчанию переменная B<MALLOC_CHECK_> игнорируется для программ с установленными битами set-user-ID и set-group-ID. Однако, если существует файл I</etc/suid-debug> (содержимое файла не важно), то B<MALLOC_CHECK_> учитывается и для программ с установленными битами set-user-ID и set-group-ID."

#. type: TP
#: man-pages/man3/mallopt.3:412
#, no-wrap
msgid "B<MALLOC_MMAP_MAX_>"
msgstr "B<MALLOC_MMAP_MAX_>"

#. type: Plain text
#: man-pages/man3/mallopt.3:417
msgid "Controls the same parameter as B<mallopt>()  B<M_MMAP_MAX>."
msgstr "Управляет параметром B<M_MMAP_MAX>, аналогично вызову B<mallopt>()."

#. type: TP
#: man-pages/man3/mallopt.3:417
#, no-wrap
msgid "B<MALLOC_MMAP_THRESHOLD_>"
msgstr "B<MALLOC_MMAP_THRESHOLD_>"

#. type: Plain text
#: man-pages/man3/mallopt.3:422
msgid "Controls the same parameter as B<mallopt>()  B<M_MMAP_THRESHOLD>."
msgstr "Управляет параметром B<M_MMAP_THRESHOLD>, аналогично вызову B<mallopt>()."

#. type: TP
#: man-pages/man3/mallopt.3:422
#, no-wrap
msgid "B<MALLOC_PERTURB_>"
msgstr "B<MALLOC_PERTURB_>"

#. type: Plain text
#: man-pages/man3/mallopt.3:427
msgid "Controls the same parameter as B<mallopt>()  B<M_PERTURB>."
msgstr "Управляет параметром B<M_PERTURB>, аналогично вызову B<mallopt>()."

#. type: TP
#: man-pages/man3/mallopt.3:427
#, no-wrap
msgid "B<MALLOC_TRIM_THRESHOLD_>"
msgstr "B<MALLOC_TRIM_THRESHOLD_>"

#. type: Plain text
#: man-pages/man3/mallopt.3:432
msgid "Controls the same parameter as B<mallopt>()  B<M_TRIM_THRESHOLD>."
msgstr "Управляет параметром B<M_TRIM_THRESHOLD>, аналогично вызову B<mallopt>()."

#. type: TP
#: man-pages/man3/mallopt.3:432
#, no-wrap
msgid "B<MALLOC_TOP_PAD_>"
msgstr "B<MALLOC_TOP_PAD_>"

#. type: Plain text
#: man-pages/man3/mallopt.3:437
msgid "Controls the same parameter as B<mallopt>()  B<M_TOP_PAD>."
msgstr "Управляет параметром B<M_TOP_PAD>, аналогично вызову B<mallopt>()."

#. type: Plain text
#: man-pages/man3/mallopt.3:442
msgid "On success, B<mallopt>()  returns 1.  On error, it returns 0."
msgstr "При успешном выполнении B<mallopt>() возвращается 1. При ошибке возвращается 0."

#.  .SH VERSIONS
#.  Available already in glibc 2.0, possibly earlier
#. type: Plain text
#: man-pages/man3/mallopt.3:450
msgid "On error, I<errno> is I<not> set."
msgstr "При ошибке значение I<errno> I<не> изменяется."

#.  .SH NOTES
#. type: Plain text
#: man-pages/man3/mallopt.3:464
msgid ""
"This function is not specified by POSIX or the C standards.  A similar "
"function exists on many System V derivatives, but the range of values for "
"I<param> varies across systems.  The SVID defined options B<M_MXFAST>, "
"B<M_NLBLKS>, B<M_GRAIN>, and B<M_KEEP>, but only the first of these is "
"implemented in glibc."
msgstr "Данная функция не описана в POSIX или C. Подобная функция существует во многих ответвлениях System V, но значения I<param> не совпадают. В SVID определены параметры B<M_MXFAST>, B<M_NLBLKS>, B<M_GRAIN> и B<M_KEEP>, но только первый из них реализован в glibc."

#. type: Plain text
#: man-pages/man3/mallopt.3:468
msgid "Specifying an invalid value for I<param> does not generate an error."
msgstr "Неправильное значение I<param> не вызывает ошибки."

#.  FIXME . This looks buggy:
#.  setting the M_MXFAST limit rounds up:    (s + SIZE_SZ) &
#. ~MALLOC_ALIGN_MASK)
#.  malloc requests are rounded up:
#.     (req) + SIZE_SZ + MALLOC_ALIGN_MASK) & ~MALLOC_ALIGN_MASK
#.  http://sources.redhat.com/bugzilla/show_bug.cgi?id=12129
#. type: Plain text
#: man-pages/man3/mallopt.3:476
msgid ""
"A calculation error within the glibc implementation means that a call of the"
" form:"
msgstr "Ошибка вычисления внутри реализации glibc означает, что вызов:"

#. type: Plain text
#: man-pages/man3/mallopt.3:480
#, no-wrap
msgid "mallopt(M_MXFAST, n)\n"
msgstr "mallopt(M_MXFAST, n)\n"

#.  Bins are multiples of 2 * sizeof(size_t) + sizeof(size_t)
#. type: Plain text
#: man-pages/man3/mallopt.3:493
msgid ""
"does not result in fastbins being employed for all allocations of size up to"
" I<n>.  To ensure desired results, I<n> should be rounded up to the next "
"multiple greater than or equal to I<(2k+1)*sizeof(size_t)>, where I<k> is an"
" integer."
msgstr "не приведёт к тому, что из fastbins будет выделяться память до размера I<n>. Чтобы это сработало, I<n> должно быть округлено до следующего множителя большего или равного I<(2k+1)*sizeof(size_t)>, где I<k> — целое число."

#.  FIXME . http://sources.redhat.com/bugzilla/show_bug.cgi?id=12140
#. type: Plain text
#: man-pages/man3/mallopt.3:514
msgid ""
"If B<mallopt>()  is used to set B<M_PERTURB>, then, as expected, the bytes "
"of allocated memory are initialized to the complement of the byte in "
"I<value>, and when that memory is freed, the bytes of the region are "
"initialized to the byte specified in I<value>.  However, there is an off-"
"by-I<sizeof(size_t)> error in the implementation: instead of initializing "
"precisely the block of memory being freed by the call I<free(p)>, the block "
"starting at I<p+sizeof(size_t)> is initialized."
msgstr "Если B<mallopt>() используется для установки B<M_PERTURB>, то, как и ожидалось, байты свободной памяти инициализируются дополнением байта из I<value>, и когда эта память освобождается, байты области инициализируются байтом, указанным в I<value>. Однако, в реализации есть ошибка выхода за I<sizeof(size_t)>: вместо инициализации точного блока памяти освобождаемом вызовом I<free(p)>, блок начинает инициализироваться с I<p+sizeof(size_t)>."

#. type: Plain text
#: man-pages/man3/mallopt.3:523
msgid ""
"The program below demonstrates the use of B<M_CHECK_ACTION>.  If the program"
" is supplied with an (integer) command-line argument, then that argument is "
"used to set the B<M_CHECK_ACTION> parameter.  The program then allocates a "
"block of memory, and frees it twice (an error)."
msgstr "Представленная далее программа показывает использование B<M_CHECK_ACTION>. Если программе передаётся аргумент командной строки (целое число), то этот аргумент используется для установки значения параметра B<M_CHECK_ACTION>. При этом программа выделяет блок памяти и освобождает его дважды (ошибка)."

#. type: Plain text
#: man-pages/man3/mallopt.3:527
msgid ""
"The following shell session shows what happens when we run this program "
"under glibc, with the default value for B<M_CHECK_ACTION>:"
msgstr "Следующий сеанс в оболочке показывает работу программы с glibc и значением по умолчанию для B<M_CHECK_ACTION>:"

#. type: Plain text
#: man-pages/man3/mallopt.3:547
#, no-wrap
msgid ""
"$ B<./a.out>\n"
"main(): returned from first free() call\n"
"*** glibc detected *** ./a.out: double free or corruption (top): 0x09d30008 ***\n"
"======= Backtrace: =========\n"
"/lib/libc.so.6(+0x6c501)[0x523501]\n"
"/lib/libc.so.6(+0x6dd70)[0x524d70]\n"
"/lib/libc.so.6(cfree+0x6d)[0x527e5d]\n"
"\\&./a.out[0x80485db]\n"
"/lib/libc.so.6(__libc_start_main+0xe7)[0x4cdce7]\n"
"\\&./a.out[0x8048471]\n"
"======= Memory map: ========\n"
"001e4000-001fe000 r-xp 00000000 08:06 1083555    /lib/libgcc_s.so.1\n"
"001fe000-001ff000 r--p 00019000 08:06 1083555    /lib/libgcc_s.so.1\n"
"[some lines omitted]\n"
"b7814000-b7817000 rw-p 00000000 00:00 0\n"
"bff53000-bff74000 rw-p 00000000 00:00 0          [stack]\n"
"Aborted (core dumped)\n"
msgstr "$ B<./a.out>\nmain(): возвращение из первого вызова free()\n*** glibc detected *** ./a.out: double free or corruption (top): 0x09d30008 ***\n======= Backtrace: =========\n/lib/libc.so.6(+0x6c501)[0x523501]\n/lib/libc.so.6(+0x6dd70)[0x524d70]\n/lib/libc.so.6(cfree+0x6d)[0x527e5d]\n\\&./a.out[0x80485db]\n/lib/libc.so.6(__libc_start_main+0xe7)[0x4cdce7]\n\\&./a.out[0x8048471]\n======= Memory map: ========\n001e4000-001fe000 r-xp 00000000 08:06 1083555    /lib/libgcc_s.so.1\n001fe000-001ff000 r--p 00019000 08:06 1083555    /lib/libgcc_s.so.1\n[some lines omitted]\nb7814000-b7817000 rw-p 00000000 00:00 0\nbff53000-bff74000 rw-p 00000000 00:00 0          [stack]\nAborted (core dumped)\n"

#. type: Plain text
#: man-pages/man3/mallopt.3:552
msgid ""
"The following runs show the results when employing other values for "
"B<M_CHECK_ACTION>:"
msgstr "В этом запуске показаны результаты при других значениях B<M_CHECK_ACTION>:"

#. type: Plain text
#: man-pages/man3/mallopt.3:565
#, no-wrap
msgid ""
"$ B<./a.out 1>             # Diagnose error and continue\n"
"main(): returned from first free() call\n"
"*** glibc detected *** ./a.out: double free or corruption (top): 0x09cbe008 ***\n"
"main(): returned from second free() call\n"
"$ B<./a.out 2>             # Abort without error message\n"
"main(): returned from first free() call\n"
"Aborted (core dumped)\n"
"$ B<./a.out 0>             # Ignore error and continue\n"
"main(): returned from first free() call\n"
"main(): returned from second free() call\n"
msgstr "$ B<./a.out 1>             # показ ошибки и продолжение\nmain(): возвращение из первого вызова free()\n*** glibc detected *** ./a.out: double free or corruption (top): 0x09cbe008 ***\nmain(): возвращение из второго вызова free()\n$ B<./a.out 2>             # прерывание без показа ошибки\nmain(): возвращение из первого вызова free()\nAborted (core dumped)\n$ B<./a.out 0>             # игнорирование ошибки и продолжение\nmain(): возвращение из первого вызова free()\nmain(): возвращение из второго вызова free()\n"

#. type: Plain text
#: man-pages/man3/mallopt.3:571
msgid ""
"The next run shows how to set the same parameter using the B<MALLOC_CHECK_> "
"environment variable:"
msgstr "При этом запуске показано как изменить тот же параметр с помощью переменной окружения B<MALLOC_CHECK_>:"

#. type: Plain text
#: man-pages/man3/mallopt.3:578
#, no-wrap
msgid ""
"$ B<MALLOC_CHECK_=1 ./a.out>\n"
"main(): returned from first free() call\n"
"*** glibc detected *** ./a.out: free(): invalid pointer: 0x092c2008 ***\n"
"main(): returned from second free() call\n"
msgstr "$ B<MALLOC_CHECK_=1 ./a.out>\nmain(): возвращение из первого вызова free()\n*** glibc detected *** ./a.out: free(): invalid pointer: 0x092c2008 ***\nmain(): возвращение из второго вызова free()\n"

#. type: Plain text
#: man-pages/man3/mallopt.3:586
#, no-wrap
msgid ""
"#include E<lt>malloc.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
msgstr "#include E<lt>malloc.hE<gt>\n#include E<lt>stdio.hE<gt>\n#include E<lt>stdlib.hE<gt>\n"

#. type: Plain text
#: man-pages/man3/mallopt.3:598
#, no-wrap
msgid ""
"    if (argc E<gt> 1) {\n"
"        if (mallopt(M_CHECK_ACTION, atoi(argv[1])) != 1) {\n"
"            fprintf(stderr, \"mallopt() failed\");\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"
"    }\n"
msgstr "    if (argc E<gt> 1) {\n        if (mallopt(M_CHECK_ACTION, atoi(argv[1])) != 1) {\n            fprintf(stderr, \"mallopt() завершилась с ошибкой\");\n            exit(EXIT_FAILURE);\n        }\n    }\n"

#. type: Plain text
#: man-pages/man3/mallopt.3:604
#, no-wrap
msgid ""
"    p = malloc(1000);\n"
"    if (p == NULL) {\n"
"        fprintf(stderr, \"malloc() failed\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr "    p = malloc(1000);\n    if (p == NULL) {\n        fprintf(stderr, \"malloc() завершилась с ошибкой\");\n        exit(EXIT_FAILURE);\n    }\n"

#. type: Plain text
#: man-pages/man3/mallopt.3:607
#, no-wrap
msgid ""
"    free(p);\n"
"    printf(\"main(): returned from first free() call\\en\");\n"
msgstr "    free(p);\n    printf(\"main(): возвращение из первого вызова free()\\en\");\n"

#. type: Plain text
#: man-pages/man3/mallopt.3:610
#, no-wrap
msgid ""
"    free(p);\n"
"    printf(\"main(): returned from second free() call\\en\");\n"
msgstr "    free(p);\n    printf(\"main(): возвращение из второго вызова free()\\en\");\n"

#. type: Plain text
#: man-pages/man3/mallopt.3:627
msgid ""
"B<mmap>(2), B<sbrk>(2), B<mallinfo>(3), B<malloc>(3), B<malloc_hook>(3), "
"B<malloc_info>(3), B<malloc_stats>(3), B<malloc_trim>(3), B<mcheck>(3), "
"B<mtrace>(3), B<posix_memalign>(3)"
msgstr "B<mmap>(2), B<sbrk>(2), B<mallinfo>(3), B<malloc>(3), B<malloc_hook>(3), B<malloc_info>(3), B<malloc_stats>(3), B<malloc_trim>(3), B<mcheck>(3), B<mtrace>(3), B<posix_memalign>(3)"

#. type: TH
#: man-pages/man3/memfrob.3:30
#, no-wrap
msgid "MEMFROB"
msgstr "MEMFROB"

#. type: TH
#: man-pages/man3/memfrob.3:30
#, no-wrap
msgid "2017-03-13"
msgstr "2017-03-13"

#. type: Plain text
#: man-pages/man3/memfrob.3:33
msgid "memfrob - frobnicate (encrypt) a memory area"
msgstr "memfrob - изменяет (зашифровывает) участок памяти"

#. type: Plain text
#: man-pages/man3/memfrob.3:37
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>             /* See feature_test_macros(7) */\n"
"B<#include E<lt>string.hE<gt>>\n"
msgstr "B<#define _GNU_SOURCE>             /* смотрите feature_test_macros(7) */\nB<#include E<lt>string.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/memfrob.3:39
#, no-wrap
msgid "B<void *memfrob(void *>I<s>B<, size_t >I<n>B<);>\n"
msgstr "B<void *memfrob(void *>I<s>B<, size_t >I<n>B<);>\n"

#. type: Plain text
#: man-pages/man3/memfrob.3:50
msgid ""
"The B<memfrob>()  function encrypts the first I<n> bytes of the memory area "
"I<s> by exclusive-ORing each character with the number 42.  The effect can "
"be reversed by using B<memfrob>()  on the encrypted memory area."
msgstr "Функция B<memfrob>() шифрует первые I<n> байт участка памяти I<s> используя исключающее ИЛИ и число 42 для каждого символа. Этот же участок памяти можно привести в изначальное состояние повторно использовав B<memfrob>()."

#. type: Plain text
#: man-pages/man3/memfrob.3:53
msgid ""
"Note that this function is not a proper encryption routine as the XOR "
"constant is fixed, and is suitable only for hiding strings."
msgstr "Заметьте, что эта функция не является надежной, т. к. всегда сравнение идет с обозначенной выше константой. Она пригодна только для скрытия строк."

#. type: Plain text
#: man-pages/man3/memfrob.3:58
msgid ""
"The B<memfrob>()  function returns a pointer to the encrypted memory area."
msgstr "Функция B<memfrob>() возвращает указатель на зашифрованный участок памяти."

#. type: tbl table
#: man-pages/man3/memfrob.3:68
#, no-wrap
msgid "B<memfrob>()"
msgstr "B<memfrob>()"

#. type: Plain text
#: man-pages/man3/memfrob.3:75
msgid "The B<memfrob>()  function is unique to the GNU C Library."
msgstr "B<memfrob>() есть только в библиотеке GNU C."

#. type: Plain text
#: man-pages/man3/memfrob.3:77
msgid "B<bstring>(3), B<strfry>(3)"
msgstr "B<bstring>(3), B<strfry>(3)"

#. type: TH
#: man-pages/man3/mq_send.3:26
#, no-wrap
msgid "MQ_SEND"
msgstr "MQ_SEND"

#. type: Plain text
#: man-pages/man3/mq_send.3:29
msgid "mq_send, mq_timedsend - send a message to a message queue"
msgstr "mq_send, mq_timedsend - отправляет сообщение в очередь сообщений"

#. type: Plain text
#: man-pages/man3/mq_send.3:35
#, no-wrap
msgid ""
"B<int mq_send(mqd_t >I<mqdes>B<, const char *>I<msg_ptr>B<,>\n"
"B<              size_t >I<msg_len>B<, unsigned int >I<msg_prio>B<);>\n"
msgstr "B<int mq_send(mqd_t >I<mqdes>B<, const char *>I<msg_ptr>B<,>\nB<              size_t >I<msg_len>B<, unsigned int >I<msg_prio>B<);>\n"

#. type: Plain text
#: man-pages/man3/mq_send.3:42
#, no-wrap
msgid ""
"B<int mq_timedsend(mqd_t >I<mqdes>B<, const char *>I<msg_ptr>B<,>\n"
"B<              size_t >I<msg_len>B<, unsigned int >I<msg_prio>B<,>\n"
"B<              const struct timespec *>I<abs_timeout>B<);>\n"
msgstr "B<int mq_timedsend(mqd_t >I<mqdes>B<, const char *>I<msg_ptr>B<,>\nB<              size_t >I<msg_len>B<, unsigned int >I<msg_prio>B<,>\nB<              const struct timespec *>I<abs_timeout>B<);>\n"

#. type: Plain text
#: man-pages/man3/mq_send.3:53
msgid "B<mq_timedsend>():"
msgstr "B<mq_timedsend>():"

#. type: Plain text
#: man-pages/man3/mq_send.3:71
msgid ""
"B<mq_send>()  adds the message pointed to by I<msg_ptr> to the message queue"
" referred to by the message queue descriptor I<mqdes>.  The I<msg_len> "
"argument specifies the length of the message pointed to by I<msg_ptr>; this "
"length must be less than or equal to the queue's I<mq_msgsize> attribute.  "
"Zero-length messages are allowed."
msgstr "Функция B<mq_send>() добавляет сообщение, на которое указывает I<msg_ptr>, в очередь сообщений, на которую ссылается дескриптор очереди сообщений I<mqdes>. В аргументе I<msg_len> задаётся длина сообщения, на которое указывает I<msg_ptr>; эта длина должна быть меньше или равно атрибуту очереди I<mq_msgsize>. Допускаются сообщения нулевой длины."

#. type: Plain text
#: man-pages/man3/mq_send.3:82
msgid ""
"The I<msg_prio> argument is a nonnegative integer that specifies the "
"priority of this message.  Messages are placed on the queue in decreasing "
"order of priority, with newer messages of the same priority being placed "
"after older messages with the same priority.  See B<mq_overview>(7)  for "
"details on the range for the message priority."
msgstr "Значение аргумента I<msg_prio> представляет собой неотрицательное целое, которым определяется приоритет этого сообщения. Сообщения помещаются в очередь в порядке уменьшения приоритета, самые новые сообщения с одинаковым приоритетом размещаются после старых с тем же приоритетом. Описание диапазона приоритета сообщения смотрите в B<mq_overview>(7)."

#. type: Plain text
#: man-pages/man3/mq_send.3:95
msgid ""
"If the message queue is already full (i.e., the number of messages on the "
"queue equals the queue's I<mq_maxmsg> attribute), then, by default, "
"B<mq_send>()  blocks until sufficient space becomes available to allow the "
"message to be queued, or until the call is interrupted by a signal handler."
"  If the B<O_NONBLOCK> flag is enabled for the message queue description, "
"then the call instead fails immediately with the error B<EAGAIN>."
msgstr "Если очередь сообщений заполнена (т. е., количество сообщений в очереди равно атрибуту очереди I<mq_maxmsg>), то по умолчанию B<mq_send>() блокируется до появления места для записи сообщения, или пока вызов не будет прерван обработчиком сигнала. Если в описании очереди сообщений включён флаг B<O_NONBLOCK>, то вместо этого вызов сразу завершается с ошибкой B<EAGAIN>."

#. type: Plain text
#: man-pages/man3/mq_send.3:107
msgid ""
"B<mq_timedsend>()  behaves just like B<mq_send>(), except that if the queue "
"is full and the B<O_NONBLOCK> flag is not enabled for the message queue "
"description, then I<abs_timeout> points to a structure which specifies how "
"long the call will block.  This value is an absolute timeout in seconds and "
"nanoseconds since the Epoch, 1970-01-01 00:00:00 +0000 (UTC), specified in "
"the following structure:"
msgstr "Функция B<mq_timedsend>() действует подобно B<mq_send>(), за исключением того, что если очередь пуста и в описании очереди сообщений не установлен флаг B<O_NONBLOCK>, то I<abs_timeout> указывает на структуру, в которой задаётся длительность блокировки вызова. Это абсолютное значение задаётся в секундах и наносекундах начиная с Эпохи, 1970-01-01 00:00:00 +0000 (UTC), в структуре вида:"

#. type: Plain text
#: man-pages/man3/mq_send.3:121
msgid ""
"If the message queue is full, and the timeout has already expired by the "
"time of the call, B<mq_timedsend>()  returns immediately."
msgstr "Если очередь сообщений полна и вышло время ожидания на момент вызова, то B<mq_timedsend>() сразу же завершается."

#. type: Plain text
#: man-pages/man3/mq_send.3:129
msgid ""
"On success, B<mq_send>()  and B<mq_timedsend>()  return zero; on error, -1 "
"is returned, with I<errno> set to indicate the error."
msgstr "При успешном выполнении B<mq_send>() и B<mq_timedsend>() возвращается ноль; при ошибке возвращается -1, а в I<errno> помещается код ошибки."

#. type: Plain text
#: man-pages/man3/mq_send.3:136
msgid ""
"The queue was full, and the B<O_NONBLOCK> flag was set for the message queue"
" description referred to by I<mqdes>."
msgstr "Очередь была полна и в описании очереди сообщений, на которое ссылается I<mqdes>, указан флаг B<O_NONBLOCK>."

#. type: Plain text
#: man-pages/man3/mq_send.3:141
msgid ""
"The descriptor specified in I<mqdes> was invalid or not opened for writing."
msgstr "В I<mqdes> указан некорректный или не открытый на запись дескриптор."

#. type: Plain text
#: man-pages/man3/mq_send.3:160
msgid ""
"I<msg_len> was greater than the I<mq_msgsize> attribute of the message "
"queue."
msgstr "I<msg_len> больше, чем свойство очереди сообщений I<mq_msgsize>."

#. type: tbl table
#: man-pages/man3/mq_send.3:174
#, no-wrap
msgid ""
"B<mq_send>(),\n"
"B<mq_timedsend>()"
msgstr "B<mq_send>(),\nB<mq_timedsend>()"

#. type: Plain text
#: man-pages/man3/mq_send.3:184
msgid ""
"On Linux, B<mq_timedsend>()  is a system call, and B<mq_send>()  is a "
"library function layered on top of that system call."
msgstr "В Linux B<mq_timedsend>() является системным вызовом, а B<mq_send>() — библиотечной функцией, реализованной на основе этого системного вызова:"

#. type: Plain text
#: man-pages/man3/mq_send.3:192
msgid ""
"B<mq_close>(3), B<mq_getattr>(3), B<mq_notify>(3), B<mq_open>(3), "
"B<mq_receive>(3), B<mq_unlink>(3), B<mq_overview>(7), B<time>(7)"
msgstr "B<mq_close>(3), B<mq_getattr>(3), B<mq_notify>(3), B<mq_open>(3), B<mq_receive>(3), B<mq_unlink>(3), B<mq_overview>(7), B<time>(7)"

#. type: TH
#: man-pages/man3/mempcpy.3:10
#, no-wrap
msgid "MEMPCPY"
msgstr "MEMPCPY"

#. type: TH
#: man-pages/man3/mempcpy.3:10
#, no-wrap
msgid "2015-03-02"
msgstr "2015-03-02"

#. type: Plain text
#: man-pages/man3/mempcpy.3:13
msgid "mempcpy, wmempcpy - copy memory area"
msgstr "mempcpy, wmempcpy — копирует участок памяти"

#. type: Plain text
#: man-pages/man3/mempcpy.3:17
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>         /* See feature_test_macros(7) */\n"
"B<#include E<lt>string.hE<gt>>\n"
msgstr "B<#define _GNU_SOURCE>         /* смотрите feature_test_macros(7) */\nB<#include E<lt>string.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/mempcpy.3:19
#, no-wrap
msgid ""
"B<void *mempcpy(void *>I<dest>B<, const void *>I<src>B<, size_t >I<n>B<);>\n"
msgstr "B<void *mempcpy(void *>I<dest>B<, const void *>I<src>B<, size_t >I<n>B<);>\n"

#. type: Plain text
#: man-pages/man3/mempcpy.3:22
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>         /* See feature_test_macros(7) */\n"
"B<#include E<lt>wchar.hE<gt>>\n"
msgstr "B<#define _GNU_SOURCE>         /* смотрите feature_test_macros(7) */\nB<#include E<lt>wchar.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/mempcpy.3:24
#, no-wrap
msgid ""
"B<wchar_t *wmempcpy(wchar_t *>I<dest>B<, const wchar_t *>I<src>B<, size_t "
">I<n>B<);>\n"
msgstr "B<wchar_t *wmempcpy(wchar_t *>I<dest>B<, const wchar_t *>I<src>B<, size_t >I<n>B<);>\n"

#. type: Plain text
#: man-pages/man3/mempcpy.3:40
msgid ""
"The B<mempcpy>()  function is nearly identical to the B<memcpy>(3)  "
"function.  It copies I<n> bytes from the object beginning at I<src> into the"
" object pointed to by I<dest>.  But instead of returning the value of "
"I<dest> it returns a pointer to the byte following the last written byte."
msgstr "Функция B<mempcpy>() почти идентична B<memcpy>(3). Она копирует I<n> байт из I<src> в I<dest>, но вместо возвращения значения I<dest>, она возвращает указатель на байт, следующий за последним записанным байтом."

#. type: Plain text
#: man-pages/man3/mempcpy.3:43
msgid ""
"This function is useful in situations where a number of objects shall be "
"copied to consecutive memory positions."
msgstr "Она удобна если требуется скопировать несколько участков памяти в другой участок последовательно, чтобы они располагались в нем друг за другом."

#. type: Plain text
#: man-pages/man3/mempcpy.3:51
msgid ""
"The B<wmempcpy>()  function is identical but takes I<wchar_t> type arguments"
" and copies I<n> wide characters."
msgstr "B<wmempcpy>() делает тоже самое, но принимает I<wchar_t> тип аргументов и копирует I<n> широких символов."

#. type: Plain text
#: man-pages/man3/mempcpy.3:55
msgid "I<dest> + I<n>."
msgstr "I<dest> + I<n>."

#. type: Plain text
#: man-pages/man3/mempcpy.3:58
msgid "B<mempcpy>()  first appeared in glibc in version 2.1."
msgstr "Впервые B<mempcpy>() появилась в glibc версии 2.1."

#. type: tbl table
#: man-pages/man3/mempcpy.3:69
#, no-wrap
msgid ""
"B<mempcpy>(),\n"
"B<wmempcpy>()"
msgstr "B<mempcpy>(),\nB<wmempcpy>()"

#. type: Plain text
#: man-pages/man3/mempcpy.3:73
msgid "This function is a GNU extension."
msgstr "Эта функция является расширением GNU."

#. type: Plain text
#: man-pages/man3/mempcpy.3:83
#, no-wrap
msgid ""
"void *\n"
"combine(void *o1, size_t s1, void *o2, size_t s2)\n"
"{\n"
"    void *result = malloc(s1 + s2);\n"
"    if (result != NULL)\n"
"        mempcpy(mempcpy(result, o1, s1), o2, s2);\n"
"    return result;\n"
"}\n"
msgstr "void *\ncombine(void *o1, size_t s1, void *o2, size_t s2)\n{\n    void *result = malloc(s1 + s2);\n    if (result != NULL)\n        mempcpy(mempcpy(result, o1, s1), o2, s2);\n    return result;\n}\n"

#. type: Plain text
#: man-pages/man3/mempcpy.3:88
msgid "B<memccpy>(3), B<memcpy>(3), B<memmove>(3), B<wmemcpy>(3)"
msgstr "B<memccpy>(3), B<memcpy>(3), B<memmove>(3), B<wmemcpy>(3)"

#. type: TH
#: man-pages/man3/malloc_trim.3:26
#, no-wrap
msgid "MALLOC_TRIM"
msgstr "MALLOC_TRIM"

#. type: TH
#: man-pages/man3/malloc_trim.3:26
#, no-wrap
msgid "2019-05-09"
msgstr ""

#. type: Plain text
#: man-pages/man3/malloc_trim.3:29
msgid "malloc_trim - release free memory from the heap"
msgstr ""

#. type: Plain text
#: man-pages/man3/malloc_trim.3:33
msgid "B<int malloc_trim(size_t >I<pad>B<);>"
msgstr "B<int malloc_trim(size_t >I<pad>B<);>"

#. type: Plain text
#: man-pages/man3/malloc_trim.3:42
msgid ""
"The B<malloc_trim>()  function attempts to release free memory from the heap"
" (by calling B<sbrk>(2)  or B<madvise>(2)  with suitable arguments)."
msgstr ""

#. type: Plain text
#: man-pages/man3/malloc_trim.3:53
msgid ""
"The I<pad> argument specifies the amount of free space to leave untrimmed at"
" the top of the heap.  If this argument is 0, only the minimum amount of "
"memory is maintained at the top of the heap (i.e., one page or less).  A "
"nonzero argument can be used to maintain some trailing space at the top of "
"the heap in order to allow future allocations to be made without having to "
"extend the heap with B<sbrk>(2)."
msgstr "Аргумент I<pad> определяет размер свободного пространства, оставляемого на верху кучи. Если он 0, то поддерживается минимум памяти (одна страница или меньше). Если значение отлично от нуля, то освобождается пространство для будущего распределения без необходимости использовать B<sbrk>(2)."

#. type: Plain text
#: man-pages/man3/malloc_trim.3:58
msgid ""
"The B<malloc_trim>()  function returns 1 if memory was actually released "
"back to the system, or 0 if it was not possible to release any memory."
msgstr "B<malloc_trim>() возвращает 1 если память была освобождена, 0 если это не возможно."

#.  .SH VERSIONS
#.  Available already in glibc 2.0, possibly earlier
#. type: Plain text
#: man-pages/man3/malloc_trim.3:62
msgid "No errors are defined."
msgstr "Ошибки не установлены."

#. type: tbl table
#: man-pages/man3/malloc_trim.3:72
#, no-wrap
msgid "B<malloc_trim>()"
msgstr "B<malloc_trim>()"

#. type: Plain text
#: man-pages/man3/malloc_trim.3:86
msgid ""
"This function is automatically called by B<free>(3)  in certain "
"circumstances; see the discussion of B<M_TOP_PAD> and B<M_TRIM_THRESHOLD> in"
" B<mallopt>(3)."
msgstr "Эта функция автоматически вызывается функцией B<free>(3) в определенных обстоятельствах. Смотрите обсуждение B<M_TOP_PAD> и B<M_TRIM_THRESHOLD> в B<mallopt>(3)."

#. type: Plain text
#: man-pages/man3/malloc_trim.3:92
msgid ""
"Only the main heap (using B<sbrk>(2))  honors the I<pad> argument; thread "
"heaps do not."
msgstr ""

#.  See commit 68631c8eb92ff38d9da1ae34f6aa048539b199cc
#.  (dated 2007-12-16) which adds iteration over all
#.  arenas and frees all pages in chunks which are free.
#. type: Plain text
#: man-pages/man3/malloc_trim.3:98
msgid ""
"Since glibc 2.8 this function frees memory in all arenas and in all chunks "
"with whole free pages."
msgstr ""

#. type: Plain text
#: man-pages/man3/malloc_trim.3:101
msgid ""
"Before glibc 2.8 this function only freed memory at the top of the heap in "
"the main arena."
msgstr ""

#. type: Plain text
#: man-pages/man3/malloc_trim.3:104
msgid "B<sbrk>(2), B<malloc>(3), B<mallopt>(3)"
msgstr "B<sbrk>(2), B<malloc>(3), B<mallopt>(3)"

#. type: TH
#: man-pages/man3/mbrtowc.3:17
#, no-wrap
msgid "MBRTOWC"
msgstr "MBRTOWC"

#. type: Plain text
#: man-pages/man3/mbrtowc.3:20
msgid "mbrtowc - convert a multibyte sequence to a wide character"
msgstr "mbrtowc - преобразовывает мультибайтовую последовательность в широкий символ"

#. type: Plain text
#: man-pages/man3/mbrtowc.3:23
#, no-wrap
msgid "B<#include E<lt>wchar.hE<gt>>\n"
msgstr "B<#include E<lt>wchar.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/mbrtowc.3:26
#, no-wrap
msgid ""
"B<size_t mbrtowc(wchar_t *>I<pwc>B<, const char *>I<s>B<, size_t >I<n>B<, "
"mbstate_t *>I<ps>B<);>\n"
msgstr "B<size_t mbrtowc(wchar_t *>I<pwc>B<, const char *>I<s>B<, size_t >I<n>B<, mbstate_t *>I<ps>B<);>\n"

#. type: Plain text
#: man-pages/man3/mbrtowc.3:54
msgid ""
"The main case for this function is when I<s> is not NULL and I<pwc> is not "
"NULL.  In this case, the B<mbrtowc>()  function inspects at most I<n> bytes "
"of the multibyte string starting at I<s>, extracts the next complete "
"multibyte character, converts it to a wide character and stores it at "
"I<*pwc>.  It updates the shift state I<*ps>.  If the converted wide "
"character is not L\\(aq\\e0\\(aq (the null wide character), it returns the "
"number of bytes that were consumed from I<s>.  If the converted wide "
"character is L\\(aq\\e0\\(aq, it resets the shift state I<*ps> to the "
"initial state and returns 0."
msgstr "В основном, функция предназначена для работы, когда I<s> и I<pwc> не равны NULL. В этом случае функция B<mbrtowc>() просматривает не более I<n> байт многобайтовой строки, начинающейся с I<s>, извлекает следующий полный многобайтовый символ, преобразует его в широкий символ и сохраняет его в I<*pwc>. При этом обновляется состояние сдвига I<*ps>. Если преобразованный широкий символ не равен L\\(aq\\e0\\(aq (широкий символ null), то возвращается количество байт, которое было выбрано из I<s>. Если преобразованный широкий символ равен L\\(aq\\e0\\(aq, то состояние сдвига I<*ps> сбрасывается в начальное состояние и возвращается 0."

#. type: Plain text
#: man-pages/man3/mbrtowc.3:70
msgid ""
"If the I<n> bytes starting at I<s> do not contain a complete multibyte "
"character, B<mbrtowc>()  returns I<(size_t)\\ -2>.  This can happen even if "
"I<n> E<gt>= I<MB_CUR_MAX>, if the multibyte string contains redundant shift "
"sequences."
msgstr "Если в I<n> байтах, начиная с I<s>, не содержится полного многобайтового символа, то B<mbrtowc>() возвращает I<(size_t)\\ -2>. Это может произойти даже, если I<n> E<gt>= I<MB_CUR_MAX>, если в многобайтовой строке содержится лишние сдвиговые последовательности."

#. type: Plain text
#: man-pages/man3/mbrtowc.3:86
msgid ""
"If the multibyte string starting at I<s> contains an invalid multibyte "
"sequence before the next complete character, B<mbrtowc>()  returns "
"I<(size_t)\\ -1> and sets I<errno> to B<EILSEQ>.  In this case, the effects "
"on I<*ps> are undefined."
msgstr "Если многобайтовая строка, начинающаяся с I<s>, содержит некорректную многобайтовую последовательность до следующего полного символа, то B<mbrtowc>() возвращает I<(size_t)\\ -1> и присваивает I<errno> значение B<EILSEQ>. В этом случае влияние на I<*ps> не определено."

#. type: Plain text
#: man-pages/man3/mbrtowc.3:96
msgid ""
"A different case is when I<s> is not NULL but I<pwc> is NULL.  In this case,"
" the B<mbrtowc>()  function behaves as above, except that it does not store "
"the converted wide character in memory."
msgstr "Ещё случай, когда I<s> не равно NULL, а I<pwc> равно NULL. В этом случае функция B<mbrtowc>() действует как описано выше, но не сохраняет преобразованный широкий символ в памяти."

#. type: Plain text
#: man-pages/man3/mbrtowc.3:128
msgid ""
"A third case is when I<s> is NULL.  In this case, I<pwc> and I<n> are "
"ignored.  If the conversion state represented by I<*ps> denotes an "
"incomplete multibyte character conversion, the B<mbrtowc>()  function "
"returns I<(size_t)\\ -1>, sets I<errno> to B<EILSEQ>, and leaves I<*ps> in "
"an undefined state.  Otherwise, the B<mbrtowc>()  function puts I<*ps> in "
"the initial state and returns 0."
msgstr "И третий случай, когда I<s> равно NULL. В этом случае I<pwc> и I<n> игнорируются. Если состояние преобразования, представляемое I<*ps> означает неполный многобайтовый символ, то функция B<mbrtowc>() возвращает I<(size_t)\\ -1>, присваивает I<errno> значение B<EILSEQ> и оставляет I<*ps> в неопределённом состоянии. Иначе функция B<mbrtowc>() изменяет I<*ps> в начальное состояние и возвращает 0."

#. type: Plain text
#: man-pages/man3/mbrtowc.3:146
msgid ""
"In all of the above cases, if I<ps> is NULL, a static anonymous state known "
"only to the B<mbrtowc>()  function is used instead.  Otherwise, I<*ps> must "
"be a valid I<mbstate_t> object.  An I<mbstate_t> object I<a> can be "
"initialized to the initial state by zeroing it, for example using"
msgstr "Во всех вышеперечисленных случаях, если I<ps> равно NULL, то используется статическое анонимное состояние, известное только функции B<mbrtowc>(). Иначе I<*ps> должен быть корректным объектом I<mbstate_t>. Объект I<mbstate_t> I<a> может быть переведён в начальное состояние, если его обнулить, например с помощью"

#. type: Plain text
#: man-pages/man3/mbrtowc.3:150
#, no-wrap
msgid "memset(&a, 0, sizeof(a));\n"
msgstr "memset(&a, 0, sizeof(a));\n"

#. type: Plain text
#: man-pages/man3/mbrtowc.3:175
msgid ""
"The B<mbrtowc>()  function returns the number of bytes parsed from the "
"multibyte sequence starting at I<s>, if a non-L\\(aq\\e0\\(aq wide character"
" was recognized.  It returns 0, if a L\\(aq\\e0\\(aq wide character was "
"recognized.  It returns I<(size_t)\\ -1> and sets I<errno> to B<EILSEQ>, if "
"an invalid multibyte sequence was encountered.  It returns I<(size_t)\\ -2> "
"if it couldn't parse a complete multibyte character, meaning that I<n> "
"should be increased."
msgstr "Функция B<mbrtowc>() возвращает количество байт, просмотренных в многобайтовой последовательности, начинающейся с I<s>, если при этом был получен широкий символ не равный L\\(aq\\e0\\(aq. Она возвращает 0, если был получен широкий символ L\\(aq\\e0\\(aq. Она возвращает I<(size_t)\\ -1> и присваивает I<errno> значение B<EILSEQ>, если встречена некорректная многобайтовая последовательность. Она возвращает I<(size_t)\\ -2>, если не удалось найти полную многобайтовую последовательность, что означает, что I<n> должно быть увеличено."

#. type: tbl table
#: man-pages/man3/mbrtowc.3:185
#, no-wrap
msgid "B<mbrtowc>()"
msgstr "B<mbrtowc>()"

#. type: tbl table
#: man-pages/man3/mbrtowc.3:185
#, no-wrap
msgid "MT-Unsafe race:mbrtowc/!ps"
msgstr "MT-Unsafe race:mbrtowc/!ps"

#. type: Plain text
#: man-pages/man3/mbrtowc.3:196
msgid ""
"The behavior of B<mbrtowc>()  depends on the B<LC_CTYPE> category of the "
"current locale."
msgstr "Поведение B<mbrtowc>() зависит от категории B<LC_CTYPE> текущей локали."

#. type: Plain text
#: man-pages/man3/mbrtowc.3:198
msgid "B<mbsinit>(3), B<mbsrtowcs>(3)"
msgstr "B<mbsinit>(3), B<mbsrtowcs>(3)"

#. type: TH
#: man-pages/man3/memccpy.3:30
#, no-wrap
msgid "MEMCCPY"
msgstr "MEMCCPY"

#. type: Plain text
#: man-pages/man3/memccpy.3:33
msgid "memccpy - copy memory area"
msgstr "memccpy - копирование участка памяти"

#. type: Plain text
#: man-pages/man3/memccpy.3:38
#, no-wrap
msgid ""
"B<void *memccpy(void *>I<dest>B<, const void *>I<src>B<, int >I<c>B<, size_t"
" >I<n>B<);>\n"
msgstr "B<void *memccpy(void *>I<dest>B<, const void *>I<src>B<, int >I<c>B<, size_t >I<n>B<);>\n"

#. type: Plain text
#: man-pages/man3/memccpy.3:53
msgid ""
"The B<memccpy>()  function copies no more than I<n> bytes from memory area "
"I<src> to memory area I<dest>, stopping when the character I<c> is found."
msgstr "Функция B<memccpy>() копирует не более I<n> байт из участка памяти I<src> в участок памяти I<dest>, останавливаясь, если найдётся символ I<c>."

#. type: Plain text
#: man-pages/man3/memccpy.3:55
msgid "If the memory areas overlap, the results are undefined."
msgstr "Если области памяти перекрываются, то результаты не определены."

#. type: Plain text
#: man-pages/man3/memccpy.3:70
msgid ""
"The B<memccpy>()  function returns a pointer to the next character in "
"I<dest> after I<c>, or NULL if I<c> was not found in the first I<n> "
"characters of I<src>."
msgstr "Функция B<memccpy>() возвращает указатель на следующий символ в I<dest> после I<c>, или NULL, если I<c> не найден в первых I<n> символах I<src>."

#. type: tbl table
#: man-pages/man3/memccpy.3:80
#, no-wrap
msgid "B<memccpy>()"
msgstr "B<memccpy>()"

#. type: Plain text
#: man-pages/man3/memccpy.3:84
msgid "POSIX.1-2001, POSIX.1-2008, SVr4, 4.3BSD."
msgstr "POSIX.1-2001, POSIX.1-2008, SVr4, 4.3BSD."

#. type: Plain text
#: man-pages/man3/memccpy.3:90
msgid ""
"B<bcopy>(3), B<bstring>(3), B<memcpy>(3), B<memmove>(3), B<strcpy>(3), "
"B<strncpy>(3)"
msgstr "B<bcopy>(3), B<bstring>(3), B<memcpy>(3), B<memmove>(3), B<strcpy>(3), B<strncpy>(3)"

#. type: TH
#: man-pages/man3/mblen.3:16
#, no-wrap
msgid "MBLEN"
msgstr "MBLEN"

#. type: TH
#: man-pages/man3/mblen.3:16
#, no-wrap
msgid "2015-08-08"
msgstr "2015-08-08"

#. type: Plain text
#: man-pages/man3/mblen.3:19
msgid "mblen - determine number of bytes in next multibyte character"
msgstr "mblen - вычисляет количество байтов в следующем многобайтовом символе"

#. type: Plain text
#: man-pages/man3/mblen.3:24
#, no-wrap
msgid "B<int mblen(const char *>I<s>B<, size_t >I<n>B<);>\n"
msgstr "B<int mblen(const char *>I<s>B<, size_t >I<n>B<);>\n"

#. type: Plain text
#: man-pages/man3/mblen.3:43
msgid ""
"If I<s> is not NULL, the B<mblen>()  function inspects at most I<n> bytes of"
" the multibyte string starting at I<s> and extracts the next complete "
"multibyte character.  It uses a static anonymous shift state known only to "
"the B<mblen>()  function.  If the multibyte character is not the null wide "
"character, it returns the number of bytes that were consumed from I<s>.  If "
"the multibyte character is the null wide character, it returns 0."
msgstr "Если I<s> не равно NULL, то функция B<mblen>() просматривает не более I<n> байт в многобайтовой строке, начинающейся с I<s> и извлекает следующий полный многобайтовый символ. Изменяется анонимное состояние сдвига, известное только функции B<mblen>(). Если многобайтовый символ не является широким символом null, то возвращается количество байт, которые использовались из I<s>. Если многобайтовый символ является широким символом null, то возвращается 0."

#. type: Plain text
#: man-pages/man3/mblen.3:57
msgid ""
"If the I<n> bytes starting at I<s> do not contain a complete multibyte "
"character, B<mblen>()  returns -1.  This can happen even if I<n> is greater "
"than or equal to I<MB_CUR_MAX>, if the multibyte string contains redundant "
"shift sequences."
msgstr "Если в I<n> байтах, начиная с I<s>, не содержится полного многобайтового символа, то B<mblen>() возвращает -1. Это может произойти даже, если I<n> больше или равно I<MB_CUR_MAX>, если в многобайтовой строке содержится лишние сдвиговые последовательности."

#. type: Plain text
#: man-pages/man3/mblen.3:64
msgid ""
"If the multibyte string starting at I<s> contains an invalid multibyte "
"sequence before the next complete character, B<mblen>()  also returns -1."
msgstr "Если многобайтовая строка, начинающаяся с I<s>, содержит некорректную многобайтовую последовательность до следующего полного символа, то B<mblen>() также возвращает -1."

#.  The Dinkumware doc and the Single UNIX specification say this, but
#.  glibc doesn't implement this.
#. type: Plain text
#: man-pages/man3/mblen.3:75
msgid ""
"If I<s> is NULL, the B<mblen>()  function resets the shift state, known to "
"only this function, to the initial state, and returns nonzero if the "
"encoding has nontrivial shift state, or zero if the encoding is stateless."
msgstr "Если значение I<s> равно NULL, то функция B<mblen>() обнуляет состояние сдвига (известное только этой функции), переводя его начальное положение, и возвращает ненулевое значение, если кодировка имеет необычное состояние сдвига; ноль будет возвращён, если кодировка не имеет сдвига."

#. type: Plain text
#: man-pages/man3/mblen.3:87
msgid ""
"The B<mblen>()  function returns the number of bytes parsed from the "
"multibyte sequence starting at I<s>, if a non-null wide character was "
"recognized.  It returns 0, if a null wide character was recognized.  It "
"returns -1, if an invalid multibyte sequence was encountered or if it "
"couldn't parse a complete multibyte character."
msgstr "Функция B<mblen>() возвращает количество байт, просмотренных в многобайтовой последовательности, начинающейся с I<s>, если при этом был распознан широкий символ не равный null. Она возвращает 0, если был получен широкий символ null. Она возвращает -1, если встречена некорректная многобайтовая последовательность или если невозможно найти полный многобайтовый символ."

#. type: tbl table
#: man-pages/man3/mblen.3:97
#, no-wrap
msgid "B<mblen>()"
msgstr "B<mblen>()"

#. type: Plain text
#: man-pages/man3/mblen.3:108
msgid ""
"The behavior of B<mblen>()  depends on the B<LC_CTYPE> category of the "
"current locale."
msgstr "Поведение B<mblen>() зависит от категории B<LC_CTYPE> текущей локали."

#. type: Plain text
#: man-pages/man3/mblen.3:113
msgid ""
"The function B<mbrlen>(3)  provides a better interface to the same "
"functionality."
msgstr "Функция B<mbrlen>(3) предоставляет лучший интерфейс с теми же возможностями."

#. type: Plain text
#: man-pages/man3/mblen.3:114
msgid "B<mbrlen>(3)"
msgstr "B<mbrlen>(3)"

#. type: TH
#: man-pages/man3/mbsrtowcs.3:16
#, no-wrap
msgid "MBSRTOWCS"
msgstr "MBSRTOWCS"

#. type: Plain text
#: man-pages/man3/mbsrtowcs.3:19
msgid "mbsrtowcs - convert a multibyte string to a wide-character string"
msgstr "mbsrtowcs - преобразует многобайтовую строку в строку широких символов"

#. type: Plain text
#: man-pages/man3/mbsrtowcs.3:25
#, no-wrap
msgid ""
"B<size_t mbsrtowcs(wchar_t *>I<dest>B<, const char **>I<src>B<,>\n"
"B<                  size_t >I<len>B<, mbstate_t *>I<ps>B<);>\n"
msgstr "B<size_t mbsrtowcs(wchar_t *>I<dest>B<, const char **>I<src>B<,>\nB<                  size_t >I<len>B<, mbstate_t *>I<ps>B<);>\n"

#. type: Plain text
#: man-pages/man3/mbsrtowcs.3:55
msgid ""
"If I<dest> is not NULL, the B<mbsrtowcs>()  function converts the multibyte "
"string I<*src> to a wide-character string starting at I<dest>.  At most "
"I<len> wide characters are written to I<dest>.  The shift state I<*ps> is "
"updated.  The conversion is effectively performed by repeatedly calling "
"I<mbrtowc(dest, *src, n, ps)> where I<n> is some positive number, as long as"
" this call succeeds, and then incrementing I<dest> by one and I<*src> by the"
" number of bytes consumed.  The conversion can stop for three reasons:"
msgstr "Если I<dest> не равно NULL, то функция B<mbsrtowcs>() преобразует многобайтовую строку I<*src> в строку широких символов, начинающуюся с I<dest>. В I<dest> будет записано не более I<len> символов. Обновляется состояние сдвига I<*ps>. Эффективное выполнение преобразования осуществляется повторяющимися вызовами I<mbrtowc(dest, *src, n, ps)>, где I<n> — некое положительное число, и пока вызов завершается успешно, увеличивая I<dest> на единицу и I<*src> на количество использованных байт. Преобразование может остановиться по трём причинам:"

#. type: Plain text
#: man-pages/man3/mbsrtowcs.3:66
msgid ""
"An invalid multibyte sequence has been encountered.  In this case, I<*src> "
"is left pointing to the invalid multibyte sequence, I<(size_t)\\ -1> is "
"returned, and I<errno> is set to B<EILSEQ>."
msgstr "Во входных данных обнаружена неправильная многобайтовая последовательность. В этом случае I<*src> по-прежнему указывает на неправильную многобайтовую последовательность, возвращается I<(size_t)\\ -1> и I<errno> присваивается B<EILSEQ>."

#. type: Plain text
#: man-pages/man3/mbsrtowcs.3:77
msgid ""
"I<len> non-L\\(aq\\e0\\(aq wide characters have been stored at I<dest>.  In "
"this case, I<*src> is left pointing to the next multibyte sequence to be "
"converted, and the number of wide characters written to I<dest> is returned."
msgstr "В I<dest> было сохранено I<len> не равных L\\(aq\\e0\\(aq широких символов. В этом случае I<*src> продолжит указывать на следующую непреобразованную многобайтовую последовательность и будет возвращено количество широких символов, записанных в I<dest>."

#. type: Plain text
#: man-pages/man3/mbsrtowcs.3:90
msgid ""
"The multibyte string has been completely converted, including the "
"terminating null wide character (\\(aq\\e0\\(aq), which has the side effect "
"of bringing back I<*ps> to the initial state.  In this case, I<*src> is set "
"to NULL, and the number of wide characters written to I<dest>, excluding the"
" terminating null wide character, is returned."
msgstr "Многобайтовая строка была полностью преобразована, включая завершающий широкий символ null (\\(aq\\e0\\(aq) (побочный эффект: I<*ps> возвращается в начальное состояние). В этом случае I<*src> устанавливается равным NULL и возвращается количество широких символов, записанных в I<dest>, не считая завершающего широкого символа null."

#. type: Plain text
#: man-pages/man3/mbsrtowcs.3:99
msgid ""
"If I<dest> is NULL, I<len> is ignored, and the conversion proceeds as above,"
" except that the converted wide characters are not written out to memory, "
"and that no length limit exists."
msgstr "Если значение I<dest> равно NULL, то I<len> игнорируется и преобразование выполняется как описано выше, исключая то, что преобразованные широкие символы не записываются в память и нет ограничения по длине."

#. type: Plain text
#: man-pages/man3/mbsrtowcs.3:107
msgid ""
"In both of the above cases, if I<ps> is NULL, a static anonymous state known"
" only to the B<mbsrtowcs>()  function is used instead."
msgstr "В обоих перечисленных случаях, если I<ps> равно NULL, то используется статическое анонимное состояние, известное только функции B<mbsrtowcs>()."

#. type: Plain text
#: man-pages/man3/mbsrtowcs.3:113
msgid ""
"The programmer must ensure that there is room for at least I<len> wide "
"characters at I<dest>."
msgstr "Программист должен проверить, что в I<dest> есть место по крайней мере для I<len> широких символов."

#. type: Plain text
#: man-pages/man3/mbsrtowcs.3:126
msgid ""
"The B<mbsrtowcs>()  function returns the number of wide characters that make"
" up the converted part of the wide-character string, not including the "
"terminating null wide character.  If an invalid multibyte sequence was "
"encountered, I<(size_t)\\ -1> is returned, and I<errno> set to B<EILSEQ>."
msgstr "Функция B<mbsrtowcs>() возвращает количество широких символов, которые составили преобразованную часть широкосимвольной строки, не включая конечный широкий символ null. Если обнаружена некорректная многобайтовая последовательность, то возвращается I<(size_t)\\ -1>, а I<errno> присваивается B<EILSEQ>."

#. type: tbl table
#: man-pages/man3/mbsrtowcs.3:136
#, no-wrap
msgid "B<mbsrtowcs>()"
msgstr "B<mbsrtowcs>()"

#. type: tbl table
#: man-pages/man3/mbsrtowcs.3:136
#, no-wrap
msgid "MT-Unsafe race:mbsrtowcs/!ps"
msgstr "MT-Unsafe race:mbsrtowcs/!ps"

#. type: Plain text
#: man-pages/man3/mbsrtowcs.3:148
msgid ""
"The behavior of B<mbsrtowcs>()  depends on the B<LC_CTYPE> category of the "
"current locale."
msgstr "Поведение B<mbsrtowcs>() зависит от категории B<LC_CTYPE> текущей локали."

#. type: Plain text
#: man-pages/man3/mbsrtowcs.3:152
msgid "Passing NULL as I<ps> is not multithread safe."
msgstr "Передавать NULL в качестве I<ps> небезопасно при работе с нитями."

#. type: Plain text
#: man-pages/man3/mbsrtowcs.3:157
msgid ""
"B<iconv>(3), B<mbrtowc>(3), B<mbsinit>(3), B<mbsnrtowcs>(3), B<mbstowcs>(3)"
msgstr "B<iconv>(3), B<mbrtowc>(3), B<mbsinit>(3), B<mbsnrtowcs>(3), B<mbstowcs>(3)"

#. type: TH
#: man-pages/man3/malloc_info.3:25
#, no-wrap
msgid "MALLOC_INFO"
msgstr "MALLOC_INFO"

#. type: Plain text
#: man-pages/man3/malloc_info.3:28
msgid "malloc_info - export malloc state to a stream"
msgstr "malloc_info - экспортирует состояние malloc в поток"

#. type: Plain text
#: man-pages/man3/malloc_info.3:31
#, no-wrap
msgid "B<#include E<lt>malloc.hE<gt>>\n"
msgstr "B<#include E<lt>malloc.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/malloc_info.3:33
#, no-wrap
msgid "B<int malloc_info(int >I<options>B<, FILE *>I<stream>B<);>\n"
msgstr "B<int malloc_info(int >I<options>B<, FILE *>I<stream>B<);>\n"

#. type: Plain text
#: man-pages/man3/malloc_info.3:44
msgid ""
"The B<malloc_info>()  function exports an XML string that describes the "
"current state of the memory-allocation implementation in the caller.  The "
"string is printed on the file stream I<stream>.  The exported string "
"includes information about all arenas (see B<malloc>(3))."
msgstr "Функция B<malloc_info>() экспортирует строку XML, описывающую текущее состояние реализации выделения памяти вызывающего. Строка печатается в файловый поток I<stream>. В экспортируемой строке содержится информация о всех областях (arenas) (смотрите B<malloc>(3))."

#. type: Plain text
#: man-pages/man3/malloc_info.3:48
msgid "As currently implemented, I<options> must be zero."
msgstr "В текущей реализации значение I<options> должно быть равно нулю."

#. type: Plain text
#: man-pages/man3/malloc_info.3:55
msgid ""
"On success, B<malloc_info>()  returns 0; on error, it returns -1, with "
"I<errno> set to indicate the cause."
msgstr "При успешном выполнении B<malloc_info>() возвращается 0; при ошибке возвращается -1, а в I<errno> помещается код ошибки."

#. type: Plain text
#: man-pages/man3/malloc_info.3:60
msgid "I<options> was nonzero."
msgstr "Значение I<options> не равно."

#. type: Plain text
#: man-pages/man3/malloc_info.3:63
msgid "B<malloc_info>()  was added to glibc in version 2.10."
msgstr "Функция B<malloc_info>() впервые появилась в glibc 2.10."

#. type: tbl table
#: man-pages/man3/malloc_info.3:73
#, no-wrap
msgid "B<malloc_info>()"
msgstr "B<malloc_info>()"

#. type: Plain text
#: man-pages/man3/malloc_info.3:84
msgid ""
"The memory-allocation information is provided as an XML string (rather than "
"a C structure)  because the information may change over time (according to "
"changes in the underlying implementation).  The output XML string includes a"
" version field."
msgstr "Информация о выделении памяти предоставляется в виде строки XML (а не в структуре C), так как структура со временем может меняться (при изменении в реализации). Возвращаемая строка XML содержит поле версии."

#. type: Plain text
#: man-pages/man3/malloc_info.3:90
msgid ""
"The B<open_memstream>(3)  function can be used to send the output of "
"B<malloc_info>()  directly into a buffer in memory, rather than to a file."
msgstr "Для отправки вывода B<malloc_info>() в буфер памяти, а не в файл можно использовать функцию B<open_memstream>(3)."

#. type: Plain text
#: man-pages/man3/malloc_info.3:97
msgid ""
"The B<malloc_info>()  function is designed to address deficiencies in "
"B<malloc_stats>(3)  and B<mallinfo>(3)."
msgstr "Функция B<malloc_info>() разработана для компенсации нехватки данных из B<malloc_stats>(3) и B<mallinfo>(3)."

#. type: Plain text
#: man-pages/man3/malloc_info.3:108
msgid ""
"The program below takes up to four command-line arguments, of which the "
"first three are mandatory.  The first argument specifies the number of "
"threads that the program should create.  All of the threads, including the "
"main thread, allocate the number of blocks of memory specified by the second"
" argument.  The third argument controls the size of the blocks to be "
"allocated.  The main thread creates blocks of this size, the second thread "
"created by the program allocates blocks of twice this size, the third thread"
" allocates blocks of three times this size, and so on."
msgstr "Программа, представленная ниже, принимает до четырёх параметров командной строки, три из которых обязательны. В первом параметре задаётся количество нитей, которые должна создать программа. Все нити, включая главную нить, выделяют количество блоков памяти, заданное в втором параметре. В третьем параметре задаётся размер выделяемых блоков. Главная нить создает блоки этого размера, вторая нить создаваемая программой, выделяет блоки двукратного размера, третья нить выделяет блоки трёхкратного размера и так далее."

#. type: Plain text
#: man-pages/man3/malloc_info.3:115
msgid ""
"The program calls B<malloc_info>()  twice to display the memory-allocation "
"state.  The first call takes place before any threads are created or memory "
"allocated.  The second call is performed after all threads have allocated "
"memory."
msgstr "Чтобы показать состояние выделения памяти программа дважды вызывает B<malloc_info>(). Первый раз вызов делается до создания нитей и выделения памяти. Второй вызов выполняется после того, как все нити выделят память."

#. type: Plain text
#: man-pages/man3/malloc_info.3:123
msgid ""
"In the following example, the command-line arguments specify the creation of"
" one additional thread, and both the main thread and the additional thread "
"allocate 10000 blocks of memory.  After the blocks of memory have been "
"allocated, B<malloc_info>()  shows the state of two allocation arenas."
msgstr "В следующем примере аргументами командной строки задаётся создание одной дополнительной нити и что главная и дополнительная нить выделяют 10000 блоков памяти. После того, как блоки памяти выделены, B<malloc_info>() показывает состояние двух областей выделения."

#. type: Plain text
#: man-pages/man3/malloc_info.3:148
#, no-wrap
msgid ""
"$ B<getconf GNU_LIBC_VERSION>\n"
"glibc 2.13\n"
"$ B<./a.out 1 10000 100>\n"
"============ Before allocating blocks ============\n"
"E<lt>malloc version=\"1\"E<gt>\n"
"E<lt>heap nr=\"0\"E<gt>\n"
"E<lt>sizesE<gt>\n"
"E<lt>/sizesE<gt>\n"
"E<lt>total type=\"fast\" count=\"0\" size=\"0\"/E<gt>\n"
"E<lt>total type=\"rest\" count=\"0\" size=\"0\"/E<gt>\n"
"E<lt>system type=\"current\" size=\"135168\"/E<gt>\n"
"E<lt>system type=\"max\" size=\"135168\"/E<gt>\n"
"E<lt>aspace type=\"total\" size=\"135168\"/E<gt>\n"
"E<lt>aspace type=\"mprotect\" size=\"135168\"/E<gt>\n"
"E<lt>/heapE<gt>\n"
"E<lt>total type=\"fast\" count=\"0\" size=\"0\"/E<gt>\n"
"E<lt>total type=\"rest\" count=\"0\" size=\"0\"/E<gt>\n"
"E<lt>system type=\"current\" size=\"135168\"/E<gt>\n"
"E<lt>system type=\"max\" size=\"135168\"/E<gt>\n"
"E<lt>aspace type=\"total\" size=\"135168\"/E<gt>\n"
"E<lt>aspace type=\"mprotect\" size=\"135168\"/E<gt>\n"
"E<lt>/mallocE<gt>\n"
msgstr "$ B<getconf GNU_LIBC_VERSION>\nglibc 2.13\n$ B<./a.out 1 10000 100>\n============ до выделения блоков ============\nE<lt>malloc version=\"1\"E<gt>\nE<lt>heap nr=\"0\"E<gt>\nE<lt>sizesE<gt>\nE<lt>/sizesE<gt>\nE<lt>total type=\"fast\" count=\"0\" size=\"0\"/E<gt>\nE<lt>total type=\"rest\" count=\"0\" size=\"0\"/E<gt>\nE<lt>system type=\"current\" size=\"135168\"/E<gt>\nE<lt>system type=\"max\" size=\"135168\"/E<gt>\nE<lt>aspace type=\"total\" size=\"135168\"/E<gt>\nE<lt>aspace type=\"mprotect\" size=\"135168\"/E<gt>\nE<lt>/heapE<gt>\nE<lt>total type=\"fast\" count=\"0\" size=\"0\"/E<gt>\nE<lt>total type=\"rest\" count=\"0\" size=\"0\"/E<gt>\nE<lt>system type=\"current\" size=\"135168\"/E<gt>\nE<lt>system type=\"max\" size=\"135168\"/E<gt>\nE<lt>aspace type=\"total\" size=\"135168\"/E<gt>\nE<lt>aspace type=\"mprotect\" size=\"135168\"/E<gt>\nE<lt>/mallocE<gt>\n"

#. type: Plain text
#: man-pages/man3/malloc_info.3:178
#, no-wrap
msgid ""
"============ After allocating blocks ============\n"
"E<lt>malloc version=\"1\"E<gt>\n"
"E<lt>heap nr=\"0\"E<gt>\n"
"E<lt>sizesE<gt>\n"
"E<lt>/sizesE<gt>\n"
"E<lt>total type=\"fast\" count=\"0\" size=\"0\"/E<gt>\n"
"E<lt>total type=\"rest\" count=\"0\" size=\"0\"/E<gt>\n"
"E<lt>system type=\"current\" size=\"1081344\"/E<gt>\n"
"E<lt>system type=\"max\" size=\"1081344\"/E<gt>\n"
"E<lt>aspace type=\"total\" size=\"1081344\"/E<gt>\n"
"E<lt>aspace type=\"mprotect\" size=\"1081344\"/E<gt>\n"
"E<lt>/heapE<gt>\n"
"E<lt>heap nr=\"1\"E<gt>\n"
"E<lt>sizesE<gt>\n"
"E<lt>/sizesE<gt>\n"
"E<lt>total type=\"fast\" count=\"0\" size=\"0\"/E<gt>\n"
"E<lt>total type=\"rest\" count=\"0\" size=\"0\"/E<gt>\n"
"E<lt>system type=\"current\" size=\"1032192\"/E<gt>\n"
"E<lt>system type=\"max\" size=\"1032192\"/E<gt>\n"
"E<lt>aspace type=\"total\" size=\"1032192\"/E<gt>\n"
"E<lt>aspace type=\"mprotect\" size=\"1032192\"/E<gt>\n"
"E<lt>/heapE<gt>\n"
"E<lt>total type=\"fast\" count=\"0\" size=\"0\"/E<gt>\n"
"E<lt>total type=\"rest\" count=\"0\" size=\"0\"/E<gt>\n"
"E<lt>system type=\"current\" size=\"2113536\"/E<gt>\n"
"E<lt>system type=\"max\" size=\"2113536\"/E<gt>\n"
"E<lt>aspace type=\"total\" size=\"2113536\"/E<gt>\n"
"E<lt>aspace type=\"mprotect\" size=\"2113536\"/E<gt>\n"
"E<lt>/mallocE<gt>\n"
msgstr "============ после выделения блоков ============\nE<lt>malloc version=\"1\"E<gt>\nE<lt>heap nr=\"0\"E<gt>\nE<lt>sizesE<gt>\nE<lt>/sizesE<gt>\nE<lt>total type=\"fast\" count=\"0\" size=\"0\"/E<gt>\nE<lt>total type=\"rest\" count=\"0\" size=\"0\"/E<gt>\nE<lt>system type=\"current\" size=\"1081344\"/E<gt>\nE<lt>system type=\"max\" size=\"1081344\"/E<gt>\nE<lt>aspace type=\"total\" size=\"1081344\"/E<gt>\nE<lt>aspace type=\"mprotect\" size=\"1081344\"/E<gt>\nE<lt>/heapE<gt>\nE<lt>heap nr=\"1\"E<gt>\nE<lt>sizesE<gt>\nE<lt>/sizesE<gt>\nE<lt>total type=\"fast\" count=\"0\" size=\"0\"/E<gt>\nE<lt>total type=\"rest\" count=\"0\" size=\"0\"/E<gt>\nE<lt>system type=\"current\" size=\"1032192\"/E<gt>\nE<lt>system type=\"max\" size=\"1032192\"/E<gt>\nE<lt>aspace type=\"total\" size=\"1032192\"/E<gt>\nE<lt>aspace type=\"mprotect\" size=\"1032192\"/E<gt>\nE<lt>/heapE<gt>\nE<lt>total type=\"fast\" count=\"0\" size=\"0\"/E<gt>\nE<lt>total type=\"rest\" count=\"0\" size=\"0\"/E<gt>\nE<lt>system type=\"current\" size=\"2113536\"/E<gt>\nE<lt>system type=\"max\" size=\"2113536\"/E<gt>\nE<lt>aspace type=\"total\" size=\"2113536\"/E<gt>\nE<lt>aspace type=\"mprotect\" size=\"2113536\"/E<gt>\nE<lt>/mallocE<gt>\n"

#. type: Plain text
#: man-pages/man3/malloc_info.3:187
#, no-wrap
msgid ""
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>pthread.hE<gt>\n"
"#include E<lt>malloc.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"
msgstr "#include E<lt>unistd.hE<gt>\n#include E<lt>stdlib.hE<gt>\n#include E<lt>pthread.hE<gt>\n#include E<lt>malloc.hE<gt>\n#include E<lt>errno.hE<gt>\n"

#. type: Plain text
#: man-pages/man3/malloc_info.3:190
#, no-wrap
msgid ""
"static size_t blockSize;\n"
"static int numThreads, numBlocks;\n"
msgstr "static size_t blockSize;\nstatic int numThreads, numBlocks;\n"

#. type: Plain text
#: man-pages/man3/malloc_info.3:199
#, no-wrap
msgid ""
"static void *\n"
"thread_func(void *arg)\n"
"{\n"
"    int j;\n"
"    int tn = (int) arg;\n"
msgstr "static void *\nthread_func(void *arg)\n{\n    int j;\n    int tn = (int) arg;\n"

#. type: Plain text
#: man-pages/man3/malloc_info.3:202
#, no-wrap
msgid ""
"    /* The multiplier \\(aq(2 + tn)\\(aq ensures that each thread (including\n"
"       the main thread) allocates a different amount of memory */\n"
msgstr "    /* Множитель \\(aq(2 + tn)\\(aq для обеспечения того, что каждая\n       нить (включая главную) выделяет разное количество памяти */\n"

#. type: Plain text
#: man-pages/man3/malloc_info.3:206
#, no-wrap
msgid ""
"    for (j = 0; j E<lt> numBlocks; j++)\n"
"        if (malloc(blockSize * (2 + tn)) == NULL)\n"
"            errExit(\"malloc-thread\");\n"
msgstr "    for (j = 0; j E<lt> numBlocks; j++)\n        if (malloc(blockSize * (2 + tn)) == NULL)\n            errExit(\"malloc-thread\");\n"

#. type: Plain text
#: man-pages/man3/malloc_info.3:210
#, no-wrap
msgid ""
"    sleep(100);         /* Sleep until main thread terminates */\n"
"    return NULL;\n"
"}\n"
msgstr "    sleep(100);         /* Спим, пока главная нить не завершит работу */\n    return NULL;\n}\n"

#. type: Plain text
#: man-pages/man3/malloc_info.3:216
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int j, tn, sleepTime;\n"
"    pthread_t *thr;\n"
msgstr "int\nmain(int argc, char *argv[])\n{\n    int j, tn, sleepTime;\n    pthread_t *thr;\n"

#. type: Plain text
#: man-pages/man3/malloc_info.3:223
#, no-wrap
msgid ""
"    if (argc E<lt> 4) {\n"
"        fprintf(stderr,\n"
"                \"%s num-threads num-blocks block-size [sleep-time]\\en\",\n"
"                argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr "    if (argc E<lt> 4) {\n        fprintf(stderr,\n                \"%s num-threads num-blocks block-size [sleep-time]\\en\",\n                argv[0]);\n        exit(EXIT_FAILURE);\n    }\n"

#. type: Plain text
#: man-pages/man3/malloc_info.3:228
#, no-wrap
msgid ""
"    numThreads = atoi(argv[1]);\n"
"    numBlocks = atoi(argv[2]);\n"
"    blockSize = atoi(argv[3]);\n"
"    sleepTime = (argc E<gt> 4) ? atoi(argv[4]) : 0;\n"
msgstr "    numThreads = atoi(argv[1]);\n    numBlocks = atoi(argv[2]);\n    blockSize = atoi(argv[3]);\n    sleepTime = (argc E<gt> 4) ? atoi(argv[4]) : 0;\n"

#. type: Plain text
#: man-pages/man3/malloc_info.3:232
#, no-wrap
msgid ""
"    thr = calloc(numThreads, sizeof(pthread_t));\n"
"    if (thr == NULL)\n"
"        errExit(\"calloc\");\n"
msgstr "    thr = calloc(numThreads, sizeof(pthread_t));\n    if (thr == NULL)\n        errExit(\"calloc\");\n"

#. type: Plain text
#: man-pages/man3/malloc_info.3:235
#, no-wrap
msgid ""
"    printf(\"============ Before allocating blocks ============\\en\");\n"
"    malloc_info(0, stdout);\n"
msgstr "    printf(\"============ до выделения блоков ============\\en\");\n    malloc_info(0, stdout);\n"

#. type: Plain text
#: man-pages/man3/malloc_info.3:237
#, no-wrap
msgid "    /* Create threads that allocate different amounts of memory */\n"
msgstr "    /* Создаём нити, которые выделяют разное количество памяти  */\n"

#. type: Plain text
#: man-pages/man3/malloc_info.3:243
#, no-wrap
msgid ""
"    for (tn = 0; tn E<lt> numThreads; tn++) {\n"
"        errno = pthread_create(&thr[tn], NULL, thread_func,\n"
"                               (void *) tn);\n"
"        if (errno != 0)\n"
"            errExit(\"pthread_create\");\n"
msgstr "    for (tn = 0; tn E<lt> numThreads; tn++) {\n        errno = pthread_create(&thr[tn], NULL, thread_func,\n                               (void *) tn);\n        if (errno != 0)\n            errExit(\"pthread_create\");\n"

#. type: Plain text
#: man-pages/man3/malloc_info.3:248
#, no-wrap
msgid ""
"        /* If we add a sleep interval after the start-up of each\n"
"           thread, the threads likely won\\(aqt contend for malloc\n"
"           mutexes, and therefore additional arenas won\\(aqt be\n"
"           allocated (see malloc(3)). */\n"
msgstr "        /* если мы добавим задержку после запуска каждой нити,\n           то нити, вероятно,  не будут бороться за мьютекс malloc,\n           и поэтому дополнительные области выделены\n           не будут (смотрите malloc(3)) */\n"

#. type: Plain text
#: man-pages/man3/malloc_info.3:252
#, no-wrap
msgid ""
"        if (sleepTime E<gt> 0)\n"
"            sleep(sleepTime);\n"
"    }\n"
msgstr "        if (sleepTime E<gt> 0)\n            sleep(sleepTime);\n    }\n"

#. type: Plain text
#: man-pages/man3/malloc_info.3:254
#, no-wrap
msgid "    /* The main thread also allocates some memory */\n"
msgstr "    /* главная нить также выделяет память */\n"

#. type: Plain text
#: man-pages/man3/malloc_info.3:258
#, no-wrap
msgid ""
"    for (j = 0; j E<lt> numBlocks; j++)\n"
"        if (malloc(blockSize) == NULL)\n"
"            errExit(\"malloc\");\n"
msgstr "    for (j = 0; j E<lt> numBlocks; j++)\n        if (malloc(blockSize) == NULL)\n            errExit(\"malloc\");\n"

#. type: Plain text
#: man-pages/man3/malloc_info.3:261
#, no-wrap
msgid ""
"    sleep(2);           /* Give all threads a chance to\n"
"                           complete allocations */\n"
msgstr "    sleep(2);           /* ждём, чтобы потоки успели\n                           выделить память */\n"

#. type: Plain text
#: man-pages/man3/malloc_info.3:264
#, no-wrap
msgid ""
"    printf(\"\\en============ After allocating blocks ============\\en\");\n"
"    malloc_info(0, stdout);\n"
msgstr "    printf(\"\\en============ после выделения блоков ============\\en\");\n    malloc_info(0, stdout);\n"

#. type: Plain text
#: man-pages/man3/malloc_info.3:273
msgid ""
"B<mallinfo>(3), B<malloc>(3), B<malloc_stats>(3), B<mallopt>(3), "
"B<open_memstream>(3)"
msgstr "B<mallinfo>(3), B<malloc>(3), B<malloc_stats>(3), B<mallopt>(3), B<open_memstream>(3)"

#. type: TH
#: man-pages/man3/MB_LEN_MAX.3:17
#, no-wrap
msgid "MB_LEN_MAX"
msgstr "MB_LEN_MAX"

#. type: TH
#: man-pages/man3/MB_LEN_MAX.3:17
#, no-wrap
msgid "2015-07-23"
msgstr "2015-07-23"

#. type: Plain text
#: man-pages/man3/MB_LEN_MAX.3:20
msgid ""
"MB_LEN_MAX - maximum multibyte length of a character across all locales"
msgstr "MB_LEN_MAX - максимальная длина многобайтового символа, для всех локалей"

#. type: Plain text
#: man-pages/man3/MB_LEN_MAX.3:23
#, no-wrap
msgid "B<#include E<lt>limits.hE<gt>>\n"
msgstr "B<#include E<lt>limits.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/MB_LEN_MAX.3:29
msgid ""
"The B<MB_LEN_MAX> macro is the maximum number of bytes needed to represent a"
" single wide character, in any of the supported locales."
msgstr "Макрос B<MB_LEN_MAX> представляет собой максимальное количества байтов, необходимых для представления единственного широкого символа, в любой из поддерживаемых локалей."

#. type: Plain text
#: man-pages/man3/MB_LEN_MAX.3:31
msgid "A constant integer greater than zero."
msgstr "Это постоянное значение больше нуля."

#.  For an explanation of why the limit was raised to 16, see
#.  http://lists.gnu.org/archive/html/bug-gnulib/2015-05/msg00001.html
#.      From:    Bruno Haible
#.      Subject: Re: why is MB_LEN_MAX so large (16) on glibc
#.      Date:    Thu, 14 May 2015 02:30:14 +0200
#. type: Plain text
#: man-pages/man3/MB_LEN_MAX.3:50
msgid ""
"The entities B<MB_LEN_MAX> and I<sizeof(wchar_t)> are totally unrelated.  In"
" glibc, B<MB_LEN_MAX> is typically 16 (6 in glibc versions earlier than "
"2.2), while I<sizeof(wchar_t)> is 4."
msgstr "Элементы B<MB_LEN_MAX> и I<sizeof(wchar_t)> никак не связаны друг с другом. В glibc значение B<MB_LEN_MAX>, обычно, равно 16 (6 в glibc до версии 2.2), а I<sizeof(wchar_t)> равно 4."

#. type: Plain text
#: man-pages/man3/MB_LEN_MAX.3:51
msgid "B<MB_CUR_MAX>(3)"
msgstr "B<MB_CUR_MAX>(3)"

#. type: TH
#: man-pages/man3/MB_CUR_MAX.3:17
#, no-wrap
msgid "MB_CUR_MAX"
msgstr "MB_CUR_MAX"

#. type: Plain text
#: man-pages/man3/MB_CUR_MAX.3:20
msgid ""
"MB_CUR_MAX - maximum length of a multibyte character in the current locale"
msgstr "MB_CUR_MAX - максимальная длина многобайтового символа, для текущей локали"

#. type: Plain text
#: man-pages/man3/MB_CUR_MAX.3:31
msgid ""
"The B<MB_CUR_MAX> macro defines an integer expression giving the maximum "
"number of bytes needed to represent a single wide character in the current "
"locale.  This value is locale dependent and therefore not a compile-time "
"constant."
msgstr "Макрос  B<MB_CUR_MAX> определяет целочисленное выражение, задающее максимальное количества байтов необходимых для представления единственного широкого символа в текущей локали. Данное значение зависит от локали и поэтому не является постоянным времени-компиляции."

#. type: Plain text
#: man-pages/man3/MB_CUR_MAX.3:35
msgid ""
"An integer in the range [1, B<MB_LEN_MAX>].  The value 1 denotes traditional"
" 8-bit encoded characters."
msgstr "Целое число в диапазоне [1, B<MB_LEN_MAX>]. Значение 1 обозначает традиционное 8-разрядное кодирование символов."

#. type: Plain text
#: man-pages/man3/MB_CUR_MAX.3:43
msgid ""
"B<MB_LEN_MAX>(3), B<mblen>(3), B<mbstowcs>(3), B<mbtowc>(3), B<wcstombs>(3),"
" B<wctomb>(3)"
msgstr "B<MB_LEN_MAX>(3), B<mblen>(3), B<mbstowcs>(3), B<mbtowc>(3), B<wcstombs>(3), B<wctomb>(3)"

#. type: TH
#: man-pages/man3/memmove.3:30
#, no-wrap
msgid "MEMMOVE"
msgstr "MEMMOVE"

#. type: Plain text
#: man-pages/man3/memmove.3:33
msgid "memmove - copy memory area"
msgstr "memmove - копирует область памяти"

#. type: Plain text
#: man-pages/man3/memmove.3:38
#, no-wrap
msgid ""
"B<void *memmove(void *>I<dest>B<, const void *>I<src>B<, size_t >I<n>B<);>\n"
msgstr "B<void *memmove(void *>I<dest>B<, const void *>I<src>B<, size_t >I<n>B<);>\n"

#. type: Plain text
#: man-pages/man3/memmove.3:57
msgid ""
"The B<memmove>()  function copies I<n> bytes from memory area I<src> to "
"memory area I<dest>.  The memory areas may overlap: copying takes place as "
"though the bytes in I<src> are first copied into a temporary array that does"
" not overlap I<src> or I<dest>, and the bytes are then copied from the "
"temporary array to I<dest>."
msgstr "Функция B<memmove>() копирует I<n> байт из участка памяти I<src> в I<dest>. Адреса участков могут перекрываться — в этом случае из I<src> байты копируются во временный массив, который не пересекается с I<src> или I<dest>, после чего они копируются из него в I<dest>."

#. type: Plain text
#: man-pages/man3/memmove.3:62
msgid "The B<memmove>()  function returns a pointer to I<dest>."
msgstr "Функция B<memmove>() возвращает указатель на I<dest>."

#. type: tbl table
#: man-pages/man3/memmove.3:72
#, no-wrap
msgid "B<memmove>()"
msgstr "B<memmove>()"

#. type: Plain text
#: man-pages/man3/memmove.3:83
msgid ""
"B<bcopy>(3), B<bstring>(3), B<memccpy>(3), B<memcpy>(3), B<strcpy>(3), "
"B<strncpy>(3), B<wmemmove>(3)"
msgstr "B<bcopy>(3), B<bstring>(3), B<memccpy>(3), B<memcpy>(3), B<strcpy>(3), B<strncpy>(3), B<wmemmove>(3)"

#. type: TH
#: man-pages/man3/mbstowcs.3:18
#, no-wrap
msgid "MBSTOWCS"
msgstr "MBSTOWCS"

#. type: Plain text
#: man-pages/man3/mbstowcs.3:21
msgid "mbstowcs - convert a multibyte string to a wide-character string"
msgstr "mbstowcs - преобразует многобайтовую строку в строку широких символов"

#. type: Plain text
#: man-pages/man3/mbstowcs.3:26
#, no-wrap
msgid ""
"B<size_t mbstowcs(wchar_t *>I<dest>B<, const char *>I<src>B<, size_t "
">I<n>B<);>\n"
msgstr "B<size_t mbstowcs(wchar_t *>I<dest>B<, const char *>I<src>B<, size_t >I<n>B<);>\n"

#. type: Plain text
#: man-pages/man3/mbstowcs.3:46
msgid ""
"If I<dest> is not NULL, the B<mbstowcs>()  function converts the multibyte "
"string I<src> to a wide-character string starting at I<dest>.  At most I<n> "
"wide characters are written to I<dest>.  The sequence of characters in the "
"string I<src> shall begin in the initial shift state.  The conversion can "
"stop for three reasons:"
msgstr "Если значение I<dest> не равно NULL, то функция B<mbstowcs>() преобразует многобайтовую строку I<src> в широкосимвольную строку начиная с I<dest>. В I<dest> будет записано не более I<n> широких символов. Последовательность символов в строке I<src> должна начинаться с начального состояния. Преобразование может прекратиться по трём причинам:"

#. type: Plain text
#: man-pages/man3/mbstowcs.3:51
msgid ""
"An invalid multibyte sequence has been encountered.  In this case, "
"I<(size_t)\\ -1> is returned."
msgstr "Во входных данных находится неправильная многобайтовая последовательность. В этом случае возвращается I<(size_t)\\ -1>."

#. type: Plain text
#: man-pages/man3/mbstowcs.3:59
msgid ""
"I<n> non-L\\(aq\\e0\\(aq wide characters have been stored at I<dest>.  In "
"this case, the number of wide characters written to I<dest> is returned, but"
" the shift state at this point is lost."
msgstr "В I<dest> было сохранено I<n> не равных L\\(aq\\e0\\(aq широких символов. В этом случае будет возвращено количество широких символов, записанных в I<dest>, но состояние сдвига в этой точке теряется."

#. type: Plain text
#: man-pages/man3/mbstowcs.3:65
msgid ""
"The multibyte string has been completely converted, including the "
"terminating null character (\\(aq\\e0\\(aq).  In this case, the number of "
"wide characters written to I<dest>, excluding the terminating null wide "
"character, is returned."
msgstr "Многобайтовая строка была полностью преобразована, включая завершающий символ null (\\(aq\\e0\\(aq). В этом случае возвращается количество записанных в I<dest> широких символов, не считая завершающий широкий символ null."

#. type: Plain text
#: man-pages/man3/mbstowcs.3:71
msgid ""
"The programmer must ensure that there is room for at least I<n> wide "
"characters at I<dest>."
msgstr "Программист должен проверить, что в I<dest> есть место по крайней мере для I<n> широких символов."

#. type: Plain text
#: man-pages/man3/mbstowcs.3:79
msgid ""
"If I<dest> is NULL, I<n> is ignored, and the conversion proceeds as above, "
"except that the converted wide characters are not written out to memory, and"
" that no length limit exists."
msgstr "Если значение I<dest> равно NULL, то I<n> игнорируется и преобразование выполняется как описано выше, исключая то, что преобразованные широкие символы не записываются в память и нет ограничения по длине."

#. type: Plain text
#: man-pages/man3/mbstowcs.3:85
msgid ""
"In order to avoid the case 2 above, the programmer should make sure I<n> is "
"greater than or equal to I<mbstowcs(NULL,src,0)+1>."
msgstr "Для того, чтобы избежать ограничения пункта 2, программист должен удостовериться, что значение I<n> больше или равно I<mbstowcs(NULL,src,0)+1>."

#. type: Plain text
#: man-pages/man3/mbstowcs.3:95
msgid ""
"The B<mbstowcs>()  function returns the number of wide characters that make "
"up the converted part of the wide-character string, not including the "
"terminating null wide character.  If an invalid multibyte sequence was "
"encountered, I<(size_t)\\ -1> is returned."
msgstr "Функция B<mbstowcs>() возвращает количество широких символов, которые составили преобразованную часть широкосимвольной строки, не включая конечный широкий символ null Если обнаружена некорректная многобайтовая последовательность, то возвращается I<(size_t)\\ -1>."

#. type: tbl table
#: man-pages/man3/mbstowcs.3:105
#, no-wrap
msgid "B<mbstowcs>()"
msgstr "B<mbstowcs>()"

#. type: Plain text
#: man-pages/man3/mbstowcs.3:116
msgid ""
"The behavior of B<mbstowcs>()  depends on the B<LC_CTYPE> category of the "
"current locale."
msgstr "Поведение B<mbstowcs>() зависит от категории B<LC_CTYPE> текущей локали."

#. type: Plain text
#: man-pages/man3/mbstowcs.3:121
msgid ""
"The function B<mbsrtowcs>(3)  provides a better interface to the same "
"functionality."
msgstr "Функция B<mbsrtowcs>(3) предоставляет лучший интерфейс с теми же возможностями."

#. type: Plain text
#: man-pages/man3/mbstowcs.3:126
msgid ""
"The program below illustrates the use of B<mbstowcs>(), as well as some of "
"the wide character classification functions.  An example run is the "
"following:"
msgstr "В программе, представленной ниже, показано использование B<mbstowcs>(), а также некоторые функции классификации широких символов. Пример запуска:"

#. type: Plain text
#: man-pages/man3/mbstowcs.3:133
#, no-wrap
msgid ""
"$ ./t_mbstowcs de_DE.UTF-8 Grüße!\n"
"Length of source string (excluding terminator):\n"
"    8 bytes\n"
"    6 multibyte characters\n"
msgstr "$ ./t_mbstowcs de_DE.UTF-8 Grüße!\nДлина исходной строки (без конечного символа):\n    8 байт\n    6 многобайтовых символов\n"

#. type: Plain text
#: man-pages/man3/mbstowcs.3:141
#, no-wrap
msgid ""
"Wide character string is: Grüße! (6 characters)\n"
"    G alpha upper\n"
"    r alpha lower\n"
"    ü alpha lower\n"
"    ß alpha lower\n"
"    e alpha lower\n"
"    ! !alpha\n"
msgstr "Строка широких символов: Grüße! (6 символов)\n    G буква заглавная\n    r буква строчная\n    ü буква строчная\n    ß буква строчная\n    e буква строчная\n    ! !буква\n"

#. type: Plain text
#: man-pages/man3/mbstowcs.3:152
#, no-wrap
msgid ""
"#include E<lt>wctype.hE<gt>\n"
"#include E<lt>locale.hE<gt>\n"
"#include E<lt>wchar.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
msgstr "#include E<lt>wctype.hE<gt>\n#include E<lt>locale.hE<gt>\n#include E<lt>wchar.hE<gt>\n#include E<lt>stdio.hE<gt>\n#include E<lt>string.hE<gt>\n#include E<lt>stdlib.hE<gt>\n"

#. type: Plain text
#: man-pages/man3/mbstowcs.3:159
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    size_t mbslen;      /* Number of multibyte characters in source */\n"
"    wchar_t *wcs;       /* Pointer to converted wide character string */\n"
"    wchar_t *wp;\n"
msgstr "int\nmain(int argc, char *argv[])\n{\n    size_t mbslen;      /* количество многобайтовых символов в источнике */\n    wchar_t *wcs;       /* указатель на преобразованную строку\n                           широких символов */\n    wchar_t *wp;\n"

#. type: Plain text
#: man-pages/man3/mbstowcs.3:164
#, no-wrap
msgid ""
"    if (argc E<lt> 3) {\n"
"        fprintf(stderr, \"Usage: %s E<lt>localeE<gt> E<lt>stringE<gt>\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr "    if (argc E<lt> 3) {\n        fprintf(stderr, \"Использование: %s E<lt>локальE<gt> E<lt>строкаE<gt>\\en\", argv[0]);\n        exit(EXIT_FAILURE);\n    }\n"

#. type: Plain text
#: man-pages/man3/mbstowcs.3:166
#, no-wrap
msgid "    /* Apply the specified locale */\n"
msgstr "    /* применяем указанную локаль */\n"

#. type: Plain text
#: man-pages/man3/mbstowcs.3:171
#, no-wrap
msgid ""
"    if (setlocale(LC_ALL, argv[1]) == NULL) {\n"
"        perror(\"setlocale\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr "    if (setlocale(LC_ALL, argv[1]) == NULL) {\n        perror(\"setlocale\");\n        exit(EXIT_FAILURE);\n    }\n"

#. type: Plain text
#: man-pages/man3/mbstowcs.3:174
#, no-wrap
msgid ""
"    /* Calculate the length required to hold argv[2] converted to\n"
"       a wide character string */\n"
msgstr "    /* вычисляем длину, которая требуется для хранения argv[2],\n       преобразованной в строку широких символов */\n"

#. type: Plain text
#: man-pages/man3/mbstowcs.3:180
#, no-wrap
msgid ""
"    mbslen = mbstowcs(NULL, argv[2], 0);\n"
"    if (mbslen == (size_t) -1) {\n"
"        perror(\"mbstowcs\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr "    mbslen = mbstowcs(NULL, argv[2], 0);\n    if (mbslen == (size_t) -1) {\n        perror(\"mbstowcs\");\n        exit(EXIT_FAILURE);\n    }\n"

#. type: Plain text
#: man-pages/man3/mbstowcs.3:182
#, no-wrap
msgid "    /* Describe the source string to the user */\n"
msgstr "    /* опишем исходную строку пользователю */\n"

#. type: Plain text
#: man-pages/man3/mbstowcs.3:186
#, no-wrap
msgid ""
"    printf(\"Length of source string (excluding terminator):\\en\");\n"
"    printf(\"    %zu bytes\\en\", strlen(argv[2]));\n"
"    printf(\"    %zu multibyte characters\\en\\en\", mbslen);\n"
msgstr "    printf(\"Длина исходной строки (без конечного символа):\\en\");\n    printf(\"    %zu байт\\en\", strlen(argv[2]));\n    printf(\"    %zu многобайтовых символов\\en\\en\", mbslen);\n"

#. type: Plain text
#: man-pages/man3/mbstowcs.3:189
#, no-wrap
msgid ""
"    /* Allocate wide character string of the desired size.  Add 1\n"
"       to allow for terminating null wide character (L\\(aq\\e0\\(aq). */\n"
msgstr "    /* выделим место под строку широких символов желаемого размера.\n       Добавим 1 для конечного широкого символа null (L\\(aq\\e0\\(aq). */\n"

#. type: Plain text
#: man-pages/man3/mbstowcs.3:195
#, no-wrap
msgid ""
"    wcs = calloc(mbslen + 1, sizeof(wchar_t));\n"
"    if (wcs == NULL) {\n"
"        perror(\"calloc\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr "    wcs = calloc(mbslen + 1, sizeof(wchar_t));\n    if (wcs == NULL) {\n        perror(\"calloc\");\n        exit(EXIT_FAILURE);\n    }\n"

#. type: Plain text
#: man-pages/man3/mbstowcs.3:198
#, no-wrap
msgid ""
"    /* Convert the multibyte character string in argv[2] to a\n"
"       wide character string */\n"
msgstr "    /* преобразуем многобайтовую строку из argv[2] в\n       строку широких символов */\n"

#. type: Plain text
#: man-pages/man3/mbstowcs.3:203
#, no-wrap
msgid ""
"    if (mbstowcs(wcs, argv[2], mbslen + 1) == (size_t) -1) {\n"
"        perror(\"mbstowcs\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr "    if (mbstowcs(wcs, argv[2], mbslen + 1) == (size_t) -1) {\n        perror(\"mbstowcs\");\n        exit(EXIT_FAILURE);\n    }\n"

#. type: Plain text
#: man-pages/man3/mbstowcs.3:206
#, no-wrap
msgid ""
"    printf(\"Wide character string is: %ls (%zu characters)\\en\",\n"
"            wcs, mbslen);\n"
msgstr "    printf(\"Строка широких символов: %ls (%zu символов)\\en\",\n            wcs, mbslen);\n"

#. type: Plain text
#: man-pages/man3/mbstowcs.3:209
#, no-wrap
msgid ""
"    /* Now do some inspection of the classes of the characters in\n"
"       the wide character string */\n"
msgstr "    /* теперь посмотрим на классы символов в\n       строке широких символов */\n"

#. type: Plain text
#: man-pages/man3/mbstowcs.3:212
#, no-wrap
msgid ""
"    for (wp = wcs; *wp != 0; wp++) {\n"
"        printf(\"    %lc \", (wint_t) *wp);\n"
msgstr "    for (wp = wcs; *wp != 0; wp++) {\n        printf(\"    %lc \", (wint_t) *wp);\n"

#. type: Plain text
#: man-pages/man3/mbstowcs.3:216
#, no-wrap
msgid ""
"        if (!iswalpha(*wp))\n"
"            printf(\"!\");\n"
"        printf(\"alpha \");\n"
msgstr "        if (!iswalpha(*wp))\n            printf(\"!\");\n        printf(\"буква \");\n"

#. type: Plain text
#: man-pages/man3/mbstowcs.3:220
#, no-wrap
msgid ""
"        if (iswalpha(*wp)) {\n"
"            if (iswupper(*wp))\n"
"                printf(\"upper \");\n"
msgstr "        if (iswalpha(*wp)) {\n            if (iswupper(*wp))\n                printf(\"заглавная \");\n"

#. type: Plain text
#: man-pages/man3/mbstowcs.3:224
#, no-wrap
msgid ""
"            if (iswlower(*wp))\n"
"                printf(\"lower \");\n"
"        }\n"
msgstr "            if (iswlower(*wp))\n                printf(\"строчная \");\n        }\n"

#. type: Plain text
#: man-pages/man3/mbstowcs.3:227
#, no-wrap
msgid ""
"        putchar(\\(aq\\en\\(aq);\n"
"    }\n"
msgstr "        putchar(\\(aq\\en\\(aq);\n    }\n"

#. type: Plain text
#: man-pages/man3/mbstowcs.3:236
msgid ""
"B<mblen>(3), B<mbsrtowcs>(3), B<mbtowc>(3), B<wcstombs>(3), B<wctomb>(3)"
msgstr "B<mblen>(3), B<mbsrtowcs>(3), B<mbtowc>(3), B<wcstombs>(3), B<wctomb>(3)"

#. type: TH
#: man-pages/man3/mbsinit.3:16
#, no-wrap
msgid "MBSINIT"
msgstr "MBSINIT"

#. type: Plain text
#: man-pages/man3/mbsinit.3:19
msgid "mbsinit - test for initial shift state"
msgstr "mbsinit - проверяет начальное состояние сдвига"

#. type: Plain text
#: man-pages/man3/mbsinit.3:24
#, no-wrap
msgid "B<int mbsinit(const mbstate_t *>I<ps>B<);>\n"
msgstr "B<int mbsinit(const mbstate_t *>I<ps>B<);>\n"

#. type: Plain text
#: man-pages/man3/mbsinit.3:34
msgid ""
"Character conversion between the multibyte representation and the wide "
"character representation uses conversion state, of type I<mbstate_t>.  "
"Conversion of a string uses a finite-state machine; when it is interrupted "
"after the complete conversion of a number of characters, it may need to save"
" a state for processing the remaining characters.  Such a conversion state "
"is needed for the sake of encodings such as ISO-2022 and UTF-7."
msgstr "Преобразование многобайтового представления символов в представление в виде широких символов (и наоборот) происходит с помощью состояния преобразования (тип I<mbstate_t>). Преобразование строк происходит с помощью конечного автомата; если преобразование прерывается после некоторого количества символов, то может потребоваться сохранить состояние для обработки остальных символов. Это состояние преобразования необходимо, к примеру, для кодировок ISO-2022 и UTF-7. "

#. type: Plain text
#: man-pages/man3/mbsinit.3:46
msgid ""
"The initial state is the state at the beginning of conversion of a string.  "
"There are two kinds of state: the one used by multibyte to wide character "
"conversion functions, such as B<mbsrtowcs>(3), and the one used by wide "
"character to multibyte conversion functions, such as B<wcsrtombs>(3), but "
"they both fit in a I<mbstate_t>, and they both have the same representation "
"for an initial state."
msgstr "Начальное состояние  — это состояние в начале преобразования строки. Есть два типа состояния: первое используется функциями преобразования многобайтовых символов в широкие (B<mbsrtowcs>(3)); второе используется функциями преобразования широких символов в многобайтовые (B<wcsrtombs>(3)). Для начального состояния обоих типов используется тип I<mbstate_t>."

#. type: Plain text
#: man-pages/man3/mbsinit.3:54
msgid ""
"For 8-bit encodings, all states are equivalent to the initial state.  For "
"multibyte encodings like UTF-8, EUC-*, BIG5 or SJIS, the wide character to "
"multibyte conversion functions never produce non-initial states, but the "
"multibyte to wide-character conversion functions like B<mbrtowc>(3)  do "
"produce non-initial states when interrupted in the middle of a character."
msgstr "Все состояния 8-битных кодировок соответствуют начальному состоянию. Для многобайтовых кодировок (UTF-8, EUC-*, BIG5 или SJIS) функции преобразования широкого символа в многобайтовый никогда не создают не исходные состояния, а функции преобразования многобайтового символа в широкий (например, B<mbrtowc>(3)) создают не исходные состояния, если прерываются на середине символа."

#. type: Plain text
#: man-pages/man3/mbsinit.3:58
msgid ""
"One possible way to create an I<mbstate_t> in initial state is to set it to "
"zero:"
msgstr "Одним из способов создания I<mbstate_t> в начальном состоянии является присвоение нулевого значения:"

#. type: Plain text
#: man-pages/man3/mbsinit.3:63
#, no-wrap
msgid ""
"mbstate_t state;\n"
"memset(&state,0,sizeof(mbstate_t));\n"
msgstr "mbstate_t state;\nmemset(&state,0,sizeof(mbstate_t));\n"

#. type: Plain text
#: man-pages/man3/mbsinit.3:67
msgid ""
"On Linux, the following works as well, but might generate compiler warnings:"
msgstr "В Linux также работает и следующее, но может привести к появлению предупреждения компилятора:"

#. type: Plain text
#: man-pages/man3/mbsinit.3:71
#, no-wrap
msgid "mbstate_t state = { 0 };\n"
msgstr "mbstate_t state = { 0 };\n"

#. type: Plain text
#: man-pages/man3/mbsinit.3:80
msgid ""
"The function B<mbsinit>()  tests whether I<*ps> corresponds to an initial "
"state."
msgstr "Функция B<mbsinit>() проверяет I<*ps> на соответствие начальному состоянию."

#. type: Plain text
#: man-pages/man3/mbsinit.3:88
msgid ""
"B<mbsinit>()  returns nonzero if I<*ps> is an initial state, or if I<ps> is "
"NULL.  Otherwise, it returns 0."
msgstr "Функция B<mbsinit>() возвращает ненулевое значение, если I<*ps> находится в начальном состоянии, или если I<ps> равно NULL. В противном случае возвращается 0."

#. type: tbl table
#: man-pages/man3/mbsinit.3:98
#, no-wrap
msgid "B<mbsinit>()"
msgstr "B<mbsinit>()"

#. type: Plain text
#: man-pages/man3/mbsinit.3:109
msgid ""
"The behavior of B<mbsinit>()  depends on the B<LC_CTYPE> category of the "
"current locale."
msgstr "Поведение B<mbsinit>() зависит от категории B<LC_CTYPE> текущей локали."

#. type: Plain text
#: man-pages/man3/mbsinit.3:114
msgid ""
"B<mbrlen>(3), B<mbrtowc>(3), B<mbsrtowcs>(3), B<wcrtomb>(3), B<wcsrtombs>(3)"
msgstr "B<mbrlen>(3), B<mbrtowc>(3), B<mbsrtowcs>(3), B<wcrtomb>(3), B<wcsrtombs>(3)"

#. type: TH
#: man-pages/man3/mpool.3:36
#, no-wrap
msgid "MPOOL"
msgstr "MPOOL"

#. type: Plain text
#: man-pages/man3/mpool.3:40
msgid "mpool - shared memory buffer pool"
msgstr "mpool - общий массив буферов памяти"

#. type: Plain text
#: man-pages/man3/mpool.3:44
#, no-wrap
msgid ""
"B<#include E<lt>db.hE<gt>>\n"
"B<#include E<lt>mpool.hE<gt>>\n"
msgstr "B<#include E<lt>db.hE<gt>>\nB<#include E<lt>mpool.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/mpool.3:47
#, no-wrap
msgid ""
"B<MPOOL *mpool_open(DBT *>I<key>B<, int >I<fd>B<, pgno_t >I<pagesize>B<, "
"pgno_t >I<maxcache>B<);>\n"
msgstr "B<MPOOL *mpool_open(DBT *>I<key>B<, int >I<fd>B<, pgno_t >I<pagesize>B<, pgno_t >I<maxcache>B<);>\n"

#. type: Plain text
#: man-pages/man3/mpool.3:51
#, no-wrap
msgid ""
"B<void mpool_filter(MPOOL *>I<mp>B<, void (*pgin)(void *, pgno_t, void *),>\n"
"B<                  void (*>I<pgout>B<)(void *, pgno_t, void *),>\n"
"B<                  void *>I<pgcookie>B<);>\n"
msgstr "B<void mpool_filter(MPOOL *>I<mp>B<, void (*pgin)(void *, pgno_t, void *),>\nB<                  void (*>I<pgout>B<)(void *, pgno_t, void *),>\nB<                  void *>I<pgcookie>B<);>\n"

#. type: Plain text
#: man-pages/man3/mpool.3:53
#, no-wrap
msgid "B<void *mpool_new(MPOOL *>I<mp>B<, pgno_t *>I<pgnoaddr>B<);>\n"
msgstr "B<void *mpool_new(MPOOL *>I<mp>B<, pgno_t *>I<pgnoaddr>B<);>\n"

#. type: Plain text
#: man-pages/man3/mpool.3:55
#, no-wrap
msgid ""
"B<void *mpool_get(MPOOL *>I<mp>B<, pgno_t >I<pgno>B<, unsigned int "
">I<flags>B<);>\n"
msgstr "B<void *mpool_get(MPOOL *>I<mp>B<, pgno_t >I<pgno>B<, unsigned int >I<flags>B<);>\n"

#. type: Plain text
#: man-pages/man3/mpool.3:57
#, no-wrap
msgid ""
"B<int mpool_put(MPOOL *>I<mp>B<, void *>I<pgaddr>B<, unsigned int "
">I<flags>B<);>\n"
msgstr "B<int mpool_put(MPOOL *>I<mp>B<, void *>I<pgaddr>B<, unsigned int >I<flags>B<);>\n"

#. type: Plain text
#: man-pages/man3/mpool.3:59
#, no-wrap
msgid "B<int mpool_sync(MPOOL *>I<mp>B<);>\n"
msgstr "B<int mpool_sync(MPOOL *>I<mp>B<);>\n"

#. type: Plain text
#: man-pages/man3/mpool.3:61
#, no-wrap
msgid "B<int mpool_close(MPOOL *>I<mp>B<);>\n"
msgstr "B<int mpool_close(MPOOL *>I<mp>B<);>\n"

#. type: Plain text
#: man-pages/man3/mpool.3:69
msgid ""
"I<Note well>: This page documents interfaces provided in glibc up until "
"version 2.1.  Since version 2.2, glibc no longer provides these interfaces."
"  Probably, you are looking for the APIs provided by the I<libdb> library "
"instead."
msgstr "I<Примечание>: В этой странице описаны интерфейсы, предоставляемые glibc до версии 2.1. Начиная с версии 2.2, glibc больше не поддерживает эти интерфейсы. Вероятно, вы ищите API, предоставляемое библиотекой I<libdb>."

#. type: Plain text
#: man-pages/man3/mpool.3:74
msgid ""
"I<Mpool> is the library interface intended to provide page oriented buffer "
"management of files.  The buffers may be shared between processes."
msgstr "Целью библиотечного интерфейса I<mpool> является обеспечение управления буферными страницами файлов. Буферы могут использоваться несколькими процессами."

#. type: Plain text
#: man-pages/man3/mpool.3:95
msgid ""
"The function B<mpool_open>()  initializes a memory pool.  The I<key> "
"argument is the byte string used to negotiate between multiple processes "
"wishing to share buffers.  If the file buffers are mapped in shared memory, "
"all processes using the same key will share the buffers.  If I<key> is NULL,"
" the buffers are mapped into private memory.  The I<fd> argument is a file "
"descriptor for the underlying file, which must be seekable.  If I<key> is "
"non-NULL and matches a file already being mapped, the I<fd> argument is "
"ignored."
msgstr "Функция B<mpool_open>()  инициализирует массив памяти. Параметр I<key> является строкой байтов для согласования процессов, желающих совместно использовать буферы. Если файловые буферы отображены в общей памяти, то все процессы, использующие данный одинаковый параметр, будут совместно использовать буферы. Если параметр I<key> равен NULL, то буферы отображаются в локальной (private) памяти. Параметр I<fd> является файловым дескриптором связанного файла, который должен быть доступен для поиска. Если значение I<key> не равно NULL и совпадает с уже отображённым файлом, то параметр I<fd> игнорируется."

#. type: Plain text
#: man-pages/man3/mpool.3:106
msgid ""
"The I<pagesize> argument is the size, in bytes, of the pages into which the "
"file is broken up.  The I<maxcache> argument is the maximum number of pages "
"from the underlying file to cache at any one time.  This value is not "
"relative to the number of processes which share a file's buffers, but will "
"be the largest value specified by any of the processes sharing the file."
msgstr "В параметре I<pagesize> указывается размер (в байтах) страниц, в которых располагается файл. В параметре I<maxcache> задаётся максимальное количество страниц файла, которое можно кэшировать в любой момент времени. Это значение не связано с количеством процессов, которые совместно используют буферы файла, но будет наибольшим значением из определённых процессами, совместно использующими файл."

#. type: Plain text
#: man-pages/man3/mpool.3:122
msgid ""
"The B<mpool_filter>()  function is intended to make transparent input and "
"output processing of the pages possible.  If the I<pgin> function is "
"specified, it is called each time a buffer is read into the memory pool from"
" the backing file.  If the I<pgout> function is specified, it is called each"
" time a buffer is written into the backing file.  Both functions are called "
"with the I<pgcookie> pointer, the page number and a pointer to the page to "
"being read or written."
msgstr "Функция B<mpool_filter>() предназначена для создания прозрачной обработки операций ввода и вывода доступных страниц. Если задана функция I<pgin>, то она вызывается каждый раз, когда данные буфера считываются в память массива из внешнего файла. Если задана функция I<pgout>, то она вызывается каждый раз, когда данные буфера записываются во внешний файл. Обе функции вызываются с указателем I<pgcookie>, номером страницы и указателем на страницу, используемую для чтения или записи."

#. type: Plain text
#: man-pages/man3/mpool.3:135
msgid ""
"The function B<mpool_new>()  takes an I<MPOOL> pointer and an address as "
"arguments.  If a new page can be allocated, a pointer to the page is "
"returned and the page number is stored into the I<pgnoaddr> address.  "
"Otherwise, NULL is returned and I<errno> is set."
msgstr "Параметрами функции B<mpool_new>() являются указатель I<MPOOL> и адрес. Если может быть выделена новая страница, то возвращается указатель на страницу и номер страницы сохраняется по адресу I<pgnoaddr>. В противном случае возвращается NULL и изменяется I<errno>."

#. type: Plain text
#: man-pages/man3/mpool.3:148
msgid ""
"The function B<mpool_get>()  takes an I<MPOOL> pointer and a page number as "
"arguments.  If the page exists, a pointer to the page is returned.  "
"Otherwise, NULL is returned and I<errno> is set.  The I<flags> argument is "
"not currently used."
msgstr "Параметрами функции B<mpool_get>() являются указатель и номер страницы. Если страница существует, то возвращается указатель на страницу. Иначе возвращается NULL и меняется значение переменной I<errno>. Параметр I<flags> пока не используется."

#. type: Plain text
#: man-pages/man3/mpool.3:160
msgid ""
"The function B<mpool_put>()  unpins the page referenced by I<pgaddr>.  "
"I<pgaddr> must be an address previously returned by B<mpool_get>()  or "
"B<mpool_new>().  The flag value is specified by ORing any of the following "
"values:"
msgstr "Функция B<mpool_put>() открепляет страницу, на которую указывает I<pgaddr>. В I<pgaddr> должен быть указан адрес, который был возвращён B<mpool_get>() или B<mpool_new>() ранее. Значением флага являются любые объединённые следующие значения:"

#. type: TP
#: man-pages/man3/mpool.3:160
#, no-wrap
msgid "B<MPOOL_DIRTY>"
msgstr "B<MPOOL_DIRTY>"

#. type: Plain text
#: man-pages/man3/mpool.3:163
msgid ""
"The page has been modified and needs to be written to the backing file."
msgstr "Страница была изменена и должна быть записана обратно в файл."

#. type: Plain text
#: man-pages/man3/mpool.3:166
msgid "B<mpool_put>()  returns 0 on success and -1 if an error occurs."
msgstr "При успешном выполнении функция B<mpool_put>() возвращает 0, а при ошибках возвращает -1."

#. type: Plain text
#: man-pages/man3/mpool.3:175
msgid ""
"The function B<mpool_sync>()  writes all modified pages associated with the "
"I<MPOOL> pointer to the backing file.  B<mpool_sync>()  returns 0 on success"
" and -1 if an error occurs."
msgstr "Функция B<mpool_sync>() записывает все изменённые страницы, связанные с указателем I<MPOOL>, обратно в файл. При успешном выполнении B<mpool_sync>() возвращает 0 и -1 при ошибке."

#. type: Plain text
#: man-pages/man3/mpool.3:185
msgid ""
"The B<mpool_close>()  function free's up any allocated memory associated "
"with the memory pool cookie.  Modified pages are B<not> written to the "
"backing file.  B<mpool_close>()  returns 0 on success and -1 if an error "
"occurs."
msgstr "Функция B<mpool_close>() освобождает любую выделенную память, связанную с идентификатором массива памяти. Изменённые страницы B<не> записываются обратно в файл. При успешном выполнении B<mpool_close>() возвращает 0 и -1 при ошибке."

#. type: Plain text
#: man-pages/man3/mpool.3:192
msgid ""
"The B<mpool_open>()  function may fail and set I<errno> for any of the "
"errors specified for the library routine B<malloc>(3)."
msgstr "При ошибках функция B<mpool_open>() устанавливает значение I<errno> равным какому-либо значению из определённых в B<malloc>(3)."

#. type: Plain text
#: man-pages/man3/mpool.3:198
msgid ""
"The B<mpool_get>()  function may fail and set I<errno> for the following:"
msgstr "При ошибках функция B<mpool_get>() устанавливает значение I<errno> по следующим причинам:"

#. type: Plain text
#: man-pages/man3/mpool.3:201
msgid "The requested record doesn't exist."
msgstr "Запрошенная запись не существует."

#. type: Plain text
#: man-pages/man3/mpool.3:213
msgid ""
"The B<mpool_new>()  and B<mpool_get>()  functions may fail and set I<errno> "
"for any of the errors specified for the library routines B<read>(2), "
"B<write>(2), and B<malloc>(3)."
msgstr "При ошибках функции I<mpool_new>() и I<mpool_get> присваивают переменной I<errno> любое значение из определённых в библиотечных функциях B<read>(2), B<write>(2) и B<malloc>(3)."

#. type: Plain text
#: man-pages/man3/mpool.3:220
msgid ""
"The B<mpool_sync>()  function may fail and set I<errno> for any of the "
"errors specified for the library routine B<write>(2)."
msgstr "При ошибках функция B<mpool_sync>() устанавливает значение I<errno> равным значению ошибки из определённых в библиотеке для B<write>(2)."

#. type: Plain text
#: man-pages/man3/mpool.3:227
msgid ""
"The B<mpool_close>()  function may fail and set I<errno> for any of the "
"errors specified for the library routine B<free>(3)."
msgstr "При ошибках функция B<mpool_close>() устанавливает значение I<errno> равным значению ошибки из определённых в библиотеке для B<free>(3)."

#. type: Plain text
#: man-pages/man3/mpool.3:230
msgid "Not in POSIX.1.  Present on the BSDs."
msgstr "Не является частью POSIX.1. Присутствует в BSD."

#. type: Plain text
#: man-pages/man3/mpool.3:234
msgid "B<btree>(3), B<dbopen>(3), B<hash>(3), B<recno>(3)"
msgstr "B<btree>(3), B<dbopen>(3), B<hash>(3), B<recno>(3)"

#. type: TH
#: man-pages/man3/memset.3:30
#, no-wrap
msgid "MEMSET"
msgstr "MEMSET"

#. type: Plain text
#: man-pages/man3/memset.3:33
msgid "memset - fill memory with a constant byte"
msgstr "memset - заполнение памяти значением определённого байта"

#. type: Plain text
#: man-pages/man3/memset.3:38
#, no-wrap
msgid "B<void *memset(void *>I<s>B<, int >I<c>B<, size_t >I<n>B<);>\n"
msgstr "B<void *memset(void *>I<s>B<, int >I<c>B<, size_t >I<n>B<);>\n"

#. type: Plain text
#: man-pages/man3/memset.3:49
msgid ""
"The B<memset>()  function fills the first I<n> bytes of the memory area "
"pointed to by I<s> with the constant byte I<c>."
msgstr "Функция B<memset>() заполняет I<n> байт участка памяти, адрес начала которого находится в указателе I<s>, значением байта I<c>."

#. type: Plain text
#: man-pages/man3/memset.3:54
msgid "The B<memset>()  function returns a pointer to the memory area I<s>."
msgstr "Функция B<memset>() возвращает указатель на участок памяти I<s>."

#. type: tbl table
#: man-pages/man3/memset.3:64
#, no-wrap
msgid "B<memset>()"
msgstr "B<memset>()"

#. type: Plain text
#: man-pages/man3/memset.3:72
msgid "B<bstring>(3), B<bzero>(3), B<swab>(3), B<wmemset>(3)"
msgstr "B<bstring>(3), B<bzero>(3), B<swab>(3), B<wmemset>(3)"

#. type: TH
#: man-pages/man3/makedev.3:26
#, no-wrap
msgid "MAKEDEV"
msgstr "MAKEDEV"

#. type: Plain text
#: man-pages/man3/makedev.3:29
msgid "makedev, major, minor - manage a device number"
msgstr "makedev, major, minor - управление номером устройства"

#. type: Plain text
#: man-pages/man3/makedev.3:32
#, no-wrap
msgid "B<#include E<lt>sys/sysmacros.hE<gt>>\n"
msgstr "B<#include E<lt>sys/sysmacros.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/makedev.3:34
#, no-wrap
msgid "B<dev_t makedev(unsigned int >I<maj>B<, unsigned int >I<min>B<);>\n"
msgstr "B<dev_t makedev(unsigned int >I<maj>B<, unsigned int >I<min>B<);>\n"

#. type: Plain text
#: man-pages/man3/makedev.3:37
#, no-wrap
msgid ""
"B<unsigned int major(dev_t >I<dev>B<);>\n"
"B<unsigned int minor(dev_t >I<dev>B<);>\n"
msgstr "B<unsigned int major(dev_t >I<dev>B<);>\nB<unsigned int minor(dev_t >I<dev>B<);>\n"

#. type: Plain text
#: man-pages/man3/makedev.3:44
msgid ""
"A device ID consists of two parts: a major ID, identifying the class of the "
"device, and a minor ID, identifying a specific instance of a device in that "
"class.  A device ID is represented using the type I<dev_t>."
msgstr "Идентификатор (ID) устройства состоит из двух частей: старшего номера, определяющего класс устройства, и младшего номера, указывающего на определённый экземпляр устройства в этом классе. Для представления ID устройства используется тип I<dev_t>."

#. type: Plain text
#: man-pages/man3/makedev.3:51
msgid ""
"Given major and minor device IDs, B<makedev>()  combines these to produce a "
"device ID, returned as the function result.  This device ID can be given to "
"B<mknod>(2), for example."
msgstr "Функция B<makedev>() объединяет указанные старший и младший ID устройства, возвращая ID устройства. Этот ID может быть передан B<mknod>(2)."

#. type: Plain text
#: man-pages/man3/makedev.3:61
msgid ""
"The B<major>()  and B<minor>()  functions perform the converse task: given a"
" device ID, they return, respectively, the major and minor components.  "
"These macros can be useful to, for example, decompose the device IDs in the "
"structure returned by B<stat>(2)."
msgstr "Функции B<major>() и B<minor>() выполняют обратную задачу: по указанному ID устройства они возвращают, соответственно, старший и младший номера. Данные макросы могут пригодиться, например, для разложения ID устройства из структуры, возвращенной B<stat>(2)."

#. type: tbl table
#: man-pages/man3/makedev.3:73
#, no-wrap
msgid ""
"B<makedev>(),\n"
"B<major>(),\n"
"B<minor>()"
msgstr "B<makedev>(),\nB<major>(),\nB<minor>()"

#.  The BSDs, HP-UX, Solaris, AIX, Irix.
#.  The header location is inconsistent:
#.  Could be sys/mkdev.h, sys/sysmacros.h, or sys/types.h.
#. type: Plain text
#: man-pages/man3/makedev.3:86
msgid ""
"The B<makedev>(), B<major>(), and B<minor>()  functions are not specified in"
" POSIX.1, but are present on many other systems."
msgstr "Функции B<makedev>(), B<major>() и B<minor>() не описаны в POSIX.1, однако присутствуют во многих системах."

#. type: Plain text
#: man-pages/man3/makedev.3:95
msgid ""
"These interfaces are defined as macros.  Since glibc 2.3.3, they have been "
"aliases for three GNU-specific functions: B<gnu_dev_makedev>(), "
"B<gnu_dev_major>(), and B<gnu_dev_minor>().  The latter names are exported, "
"but the traditional names are more portable."
msgstr "Данные интерфейсы определены как макросы. Начиная с glibc 2.3.3, они являются псевдонимами для трёх GNU-функций: B<gnu_dev_makedev>(), B<gnu_dev_major>() и B<gnu_dev_minor>(). Эти имена экспортированы, однако использование традиционных имён более переносимо."

#.  glibc commit dbab6577c6684c62bd2521c1c29dc25c3cac966f
#.  glibc commit e16deca62e16f645213dffd4ecd1153c37765f17
#. type: Plain text
#: man-pages/man3/makedev.3:107
msgid ""
"The BSDs expose the definitions for these macros via "
"I<E<lt>sys/types.hE<gt>>.  Depending on the version, glibc also exposes "
"definitions for these macros from that header file if suitable feature test "
"macros are defined.  However, this behavior was deprecated in glibc 2.25, "
"and since glibc 2.28, I<E<lt>sys/types.hE<gt>> no longer provides these "
"definitions."
msgstr "В BSD определения этих макросов доступны в I<E<lt>sys/types.hE<gt>>. В зависимости от версии, в glibc они также доступны из этого заголовочного файла, если определён подходящий макрос тестирования свойств. Однако такое применение устарело в glibc 2.25, и начиная с glibc 2.28, эти определения были удалены из I<E<lt>sys/types.hE<gt>>."

#. type: Plain text
#: man-pages/man3/makedev.3:109
msgid "B<mknod>(2), B<stat>(2)"
msgstr "B<mknod>(2), B<stat>(2)"

#. type: TH
#: man-pages/man3/mq_getattr.3:26
#, no-wrap
msgid "MQ_GETATTR"
msgstr "MQ_GETATTR"

#. type: Plain text
#: man-pages/man3/mq_getattr.3:29
msgid "mq_getattr, mq_setattr - get/set message queue attributes"
msgstr "mq_getattr, mq_setattr - возвращает/изменяет атрибуты очереди сообщений"

#. type: Plain text
#: man-pages/man3/mq_getattr.3:34
#, no-wrap
msgid "B<int mq_getattr(mqd_t >I<mqdes>B<, struct mq_attr *>I<attr>B<);>\n"
msgstr "B<int mq_getattr(mqd_t >I<mqdes>B<, struct mq_attr *>I<attr>B<);>\n"

#. type: Plain text
#: man-pages/man3/mq_getattr.3:37
#, no-wrap
msgid ""
"B<int mq_setattr(mqd_t >I<mqdes>B<, const struct mq_attr *>I<newattr>B<,>\n"
"B<                 struct mq_attr *>I<oldattr>B<);>\n"
msgstr "B<int mq_setattr(mqd_t >I<mqdes>B<, const struct mq_attr *>I<newattr>B<,>\nB<                 struct mq_attr *>I<oldattr>B<);>\n"

#. type: Plain text
#: man-pages/man3/mq_getattr.3:47
msgid ""
"B<mq_getattr>()  and B<mq_setattr>()  respectively retrieve and modify "
"attributes of the message queue referred to by the message queue descriptor "
"I<mqdes>."
msgstr "Функция B<mq_getattr>() и B<mq_setattr>(), соответственно, возвращает и изменяет атрибуты очереди сообщений, на которую ссылается дескриптор очереди сообщений I<mqdes>."

#. type: Plain text
#: man-pages/man3/mq_getattr.3:54
msgid ""
"B<mq_getattr>()  returns an I<mq_attr> structure in the buffer pointed by "
"I<attr>.  This structure is defined as:"
msgstr "Функция B<mq_getattr>() возвращает структуру I<mq_attr> в буфер, указанный в I<attr>. Эта структура определена следующим образом:"

#. type: Plain text
#: man-pages/man3/mq_getattr.3:63
#, no-wrap
msgid ""
"struct mq_attr {\n"
"    long mq_flags;       /* Flags: 0 or O_NONBLOCK */\n"
"    long mq_maxmsg;      /* Max. # of messages on queue */\n"
"    long mq_msgsize;     /* Max. message size (bytes) */\n"
"    long mq_curmsgs;     /* # of messages currently in queue */\n"
"};\n"
msgstr "struct mq_attr {\n    long mq_flags;       /* флаги: 0 или O_NONBLOCK */\n    long mq_maxmsg;      /* макс. кол-во сообщений в очереди */\n    long mq_msgsize;     /* макс. размер сообщения (в байтах) */\n    long mq_curmsgs;     /* кол-во сообщений в очереди в данный момент */\n};\n"

#. type: Plain text
#: man-pages/man3/mq_getattr.3:73
msgid ""
"The I<mq_flags> field contains flags associated with the open message queue "
"description.  This field is initialized when the queue is created by "
"B<mq_open>(3).  The only flag that can appear in this field is "
"B<O_NONBLOCK>."
msgstr "В поле I<mq_flags> содержатся флаги, связанные с открытым описанием очереди сообщений. Это поле инициализируется при создании очереди с помощью B<mq_open>(3). В этом поле может содержаться только флаг B<O_NONBLOCK>."

#. type: Plain text
#: man-pages/man3/mq_getattr.3:94
msgid ""
"The I<mq_maxmsg> and I<mq_msgsize> fields are set when the message queue is "
"created by B<mq_open>(3).  The I<mq_maxmsg> field is an upper limit on the "
"number of messages that may be placed on the queue using B<mq_send>(3).  The"
" I<mq_msgsize> field is an upper limit on the size of messages that may be "
"placed on the queue.  Both of these fields must have a value greater than "
"zero.  Two I</proc> files that place ceilings on the values for these fields"
" are described in B<mq_overview>(7)."
msgstr "Поля I<mq_maxmsg> и I<mq_msgsize> заполняются при создании очереди сообщений с помощью B<mq_open>(3). В поле I<mq_maxmsg> содержится верхний предел на количество сообщений, которое может поместиться в очереди с помощью B<mq_send>(3). В поле  I<mq_msgsize> содержится верхний предел на размер сообщений, которые могут помещаться в очередь. Значение обоих полей должно быть больше нуля. Два файла в I</proc>, в которых размещаются значения этих полей, описаны в B<mq_overview>(7)."

#. type: Plain text
#: man-pages/man3/mq_getattr.3:98
msgid ""
"The I<mq_curmsgs> field returns the number of messages currently held in the"
" queue."
msgstr "В поле I<mq_curmsgs> возвращается количество сообщений в очереди в текущей момент времени."

#. type: Plain text
#: man-pages/man3/mq_getattr.3:118
msgid ""
"B<mq_setattr>()  sets message queue attributes using information supplied in"
" the I<mq_attr> structure pointed to by I<newattr>.  The only attribute that"
" can be modified is the setting of the B<O_NONBLOCK> flag in I<mq_flags>.  "
"The other fields in I<newattr> are ignored.  If the I<oldattr> field is not "
"NULL, then the buffer that it points to is used to return an I<mq_attr> "
"structure that contains the same information that is returned by "
"B<mq_getattr>()."
msgstr "Функция B<mq_setattr>() изменяет атрибуты очереди согласно информации из передаваемой структуры I<mq_attr>, на которую указывает I<newattr>. Единственным атрибутом, который можно изменить, является флаг B<O_NONBLOCK> в I<mq_flags>. Остальные поля в I<newattr> игнорируются. Если поле I<oldattr> не равно NULL, то буфер, на который оно указывает, используется для возврата структуры I<mq_attr>, с той же информацией как после вызова B<mq_getattr>()."

#. type: Plain text
#: man-pages/man3/mq_getattr.3:126
msgid ""
"On success B<mq_getattr>()  and B<mq_setattr>()  return 0; on error, -1 is "
"returned, with I<errno> set to indicate the error."
msgstr "При успешном выполнении  B<mq_getattr>() и B<mq_setattr>()  возвращается 0; при ошибке возвращается -1, а в I<errno> помещается код ошибки."

#. type: Plain text
#: man-pages/man3/mq_getattr.3:132
msgid "The message queue descriptor specified in I<mqdes> is invalid."
msgstr "В I<mqdes> размещён некорректный дескриптор очереди сообщений."

#. type: Plain text
#: man-pages/man3/mq_getattr.3:137
msgid "I<newattr-E<gt>mq_flags> contained set bits other than B<O_NONBLOCK>."
msgstr "В I<newattr-E<gt>mq_flags> содержится набор битов, отличный от B<O_NONBLOCK>."

#. type: tbl table
#: man-pages/man3/mq_getattr.3:148
#, no-wrap
msgid ""
"B<mq_getattr>(),\n"
"B<mq_setattr>()"
msgstr "B<mq_getattr>(),\nB<mq_setattr>()"

#. type: Plain text
#: man-pages/man3/mq_getattr.3:160
msgid ""
"On Linux, B<mq_getattr>()  and B<mq_setattr>()  are library functions "
"layered on top of the B<mq_getsetattr>(2)  system call."
msgstr "В Linux, B<mq_getattr>() и B<mq_setattr>()  является библиотечными функциями, реализованными на основе системного вызова B<mq_getsetattr>(2)."

#. type: Plain text
#: man-pages/man3/mq_getattr.3:171
msgid ""
"The program below can be used to show the default I<mq_maxmsg> and "
"I<mq_msgsize> values that are assigned to a message queue that is created "
"with a call to B<mq_open>(3)  in which the I<attr> argument is NULL.  Here "
"is an example run of the program:"
msgstr "Программу, представленную ниже, можно использовать для просмотра значений по умолчанию I<mq_maxmsg> и I<mq_msgsize>, которые назначаются очереди сообщений, создаваемой вызовом B<mq_open>(3) с аргументом I<attr>, равным NULL. Пример работы программы:"

#. type: Plain text
#: man-pages/man3/mq_getattr.3:177
#, no-wrap
msgid ""
"$ B<./a.out /testq>\n"
"Maximum # of messages on queue:   10\n"
"Maximum message size:             8192\n"
msgstr "$ B<./a.out /testq>\nМаксимальное количество сообщений в очереди:   10\nМаксимальный размер сообщения:             8192\n"

#. type: Plain text
#: man-pages/man3/mq_getattr.3:185
msgid ""
"Since Linux 3.5, the following I</proc> files (described in "
"B<mq_overview>(7))  can be used to control the defaults:"
msgstr "Начиная с Linux 3.5 для управления значениями по умолчанию можно использовать следующие файлы в I</proc> (описаны в B<mq_overview>(7)):"

#. type: Plain text
#: man-pages/man3/mq_getattr.3:194
#, no-wrap
msgid ""
"$ B<uname -sr>\n"
"Linux 3.8.0\n"
"$ B<cat /proc/sys/fs/mqueue/msg_default>\n"
"10\n"
"$ B<cat /proc/sys/fs/mqueue/msgsize_default>\n"
"8192\n"
msgstr "$ B<uname -sr>\nLinux 3.8.0\n$ B<cat /proc/sys/fs/mqueue/msg_default>\n10\n$ B<cat /proc/sys/fs/mqueue/msgsize_default>\n8192\n"

#. type: Plain text
#: man-pages/man3/mq_getattr.3:205
#, no-wrap
msgid ""
"#include E<lt>mqueue.hE<gt>\n"
"#include E<lt>sys/stat.hE<gt>\n"
"#include E<lt>fcntl.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
msgstr "#include E<lt>mqueue.hE<gt>\n#include E<lt>sys/stat.hE<gt>\n#include E<lt>fcntl.hE<gt>\n#include E<lt>stdio.hE<gt>\n#include E<lt>stdlib.hE<gt>\n#include E<lt>unistd.hE<gt>\n"

#. type: Plain text
#: man-pages/man3/mq_getattr.3:214
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    mqd_t mqd;\n"
"    struct mq_attr attr;\n"
msgstr "int\nmain(int argc, char *argv[])\n{\n    mqd_t mqd;\n    struct mq_attr attr;\n"

#. type: Plain text
#: man-pages/man3/mq_getattr.3:219
#, no-wrap
msgid ""
"    if (argc != 2) {\n"
"        fprintf(stderr, \"Usage: %s mq-name\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr "    if (argc != 2) {\n        fprintf(stderr, \"Использование: %s mq-name\\en\", argv[0]);\n        exit(EXIT_FAILURE);\n    }\n"

#. type: Plain text
#: man-pages/man3/mq_getattr.3:223
#, no-wrap
msgid ""
"    mqd = mq_open(argv[1], O_CREAT | O_EXCL, S_IRUSR | S_IWUSR, NULL);\n"
"    if (mqd == (mqd_t) -1)\n"
"        errExit(\"mq_open\");\n"
msgstr "    mqd = mq_open(argv[1], O_CREAT | O_EXCL, S_IRUSR | S_IWUSR, NULL);\n    if (mqd == (mqd_t) -1)\n        errExit(\"mq_open\");\n"

#. type: Plain text
#: man-pages/man3/mq_getattr.3:226
#, no-wrap
msgid ""
"    if (mq_getattr(mqd, &attr) == -1)\n"
"        errExit(\"mq_getattr\");\n"
msgstr "    if (mq_getattr(mqd, &attr) == -1)\n        errExit(\"mq_getattr\");\n"

#. type: Plain text
#: man-pages/man3/mq_getattr.3:229
#, no-wrap
msgid ""
"    printf(\"Maximum # of messages on queue:   %ld\\en\", attr.mq_maxmsg);\n"
"    printf(\"Maximum message size:             %ld\\en\", attr.mq_msgsize);\n"
msgstr "    printf(\"Максимальное количество сообщений в очереди:   %ld\\en\", attr.mq_maxmsg);\n    printf(\"Максимальный размер сообщения:             %ld\\en\", attr.mq_msgsize);\n"

#. type: Plain text
#: man-pages/man3/mq_getattr.3:232
#, no-wrap
msgid ""
"    if (mq_unlink(argv[1]) == -1)\n"
"        errExit(\"mq_unlink\");\n"
msgstr "    if (mq_unlink(argv[1]) == -1)\n        errExit(\"mq_unlink\");\n"

#. type: Plain text
#: man-pages/man3/mq_getattr.3:243
msgid ""
"B<mq_close>(3), B<mq_notify>(3), B<mq_open>(3), B<mq_receive>(3), "
"B<mq_send>(3), B<mq_unlink>(3), B<mq_overview>(7)"
msgstr "B<mq_close>(3), B<mq_notify>(3), B<mq_open>(3), B<mq_receive>(3), B<mq_send>(3), B<mq_unlink>(3), B<mq_overview>(7)"

#. type: TH
#: man-pages/man3/mq_notify.3:26
#, no-wrap
msgid "MQ_NOTIFY"
msgstr "MQ_NOTIFY"

#. type: Plain text
#: man-pages/man3/mq_notify.3:29
msgid "mq_notify - register for notification when a message is available"
msgstr "mq_notify - включает уведомление при поступлении сообщения"

#. type: Plain text
#: man-pages/man3/mq_notify.3:34
#, no-wrap
msgid ""
"B<int mq_notify(mqd_t >I<mqdes>B<, const struct sigevent *>I<sevp>B<);>\n"
msgstr "B<int mq_notify(mqd_t >I<mqdes>B<, const struct sigevent *>I<sevp>B<);>\n"

#. type: Plain text
#: man-pages/man3/mq_notify.3:43
msgid ""
"B<mq_notify>()  allows the calling process to register or unregister for "
"delivery of an asynchronous notification when a new message arrives on the "
"empty message queue referred to by the message queue descriptor I<mqdes>."
msgstr "Функция B<mq_notify>() позволяет вызывающему процессу регистрироваться или отменять регистрацию доставки анонимных уведомлений при появлении нового сообщения в пустой очереди сообщений, на которую ссылается дескриптор очереди сообщений I<mqdes>."

#. type: Plain text
#: man-pages/man3/mq_notify.3:51
msgid ""
"The I<sevp> argument is a pointer to a I<sigevent> structure.  For the "
"definition and general details of this structure, see B<sigevent>(7)."
msgstr "Аргумент I<sevp> является указателем на структуру I<sigevent>. Определение и описание структуры смотрите в B<sigevent>(7)."

#. type: Plain text
#: man-pages/man3/mq_notify.3:65
msgid ""
"If I<sevp> is a non-null pointer, then B<mq_notify>()  registers the calling"
" process to receive message notification.  The I<sigev_notify> field of the "
"I<sigevent> structure to which I<sevp> points specifies how notification is "
"to be performed.  This field has one of the following values:"
msgstr "Если I<sevp> не равен null, то B<mq_notify>() регистрирует вызывающий процесс для получения уведомлений о сообщениях. В поле I<sigev_notify> структуры I<sigevent>, на которую указывает I<sevp>, задаётся способ выполнения уведомления. Это поле может содержать одно из следующих значений:"

#. type: TP
#: man-pages/man3/mq_notify.3:65
#, no-wrap
msgid "B<SIGEV_NONE>"
msgstr "B<SIGEV_NONE>"

#.  When is SIGEV_NONE useful?
#. type: Plain text
#: man-pages/man3/mq_notify.3:70
msgid ""
"A \"null\" notification: the calling process is registered as the target for"
" notification, but when a message arrives, no notification is sent."
msgstr "«Нулевое» уведомление: хотя вызывающий процесс и регистрируется как уведомляемый, при появлении сообщения уведомление не будет отправлено."

#. type: TP
#: man-pages/man3/mq_notify.3:70
#, no-wrap
msgid "B<SIGEV_SIGNAL>"
msgstr "B<SIGEV_SIGNAL>"

#.  I don't know of other implementations that set
#.  si_pid and si_uid -- MTK
#. type: Plain text
#: man-pages/man3/mq_notify.3:90
msgid ""
"Notify the process by sending the signal specified in I<sigev_signo>.  See "
"B<sigevent>(7)  for general details.  The I<si_code> field of the "
"I<siginfo_t> structure will be set to B<SI_MESGQ>.  In addition, I<si_pid> "
"will be set to the PID of the process that sent the message, and I<si_uid> "
"will be set to the real user ID of the sending process."
msgstr "Уведомлять процесс посредством отправки сигнала, указанного в I<sigev_signo>. Подробности смотрите в B<sigevent>(7). Поле I<si_code> структуры I<siginfo_t> будет изменено на B<SI_MESGQ>. Также, значение I<si_pid> будет изменено на PID процесса, который посылается сообщение, а значение  I<si_uid> будет изменено на реальный пользовательский ID посылающего процесса."

#. type: TP
#: man-pages/man3/mq_notify.3:90
#, no-wrap
msgid "B<SIGEV_THREAD>"
msgstr "B<SIGEV_THREAD>"

#. type: Plain text
#: man-pages/man3/mq_notify.3:98
msgid ""
"Upon message delivery, invoke I<sigev_notify_function> as if it were the "
"start function of a new thread.  See B<sigevent>(7)  for details."
msgstr "При доставке сообщения вызвать I<sigev_notify_function>, как если бы это была начальная функция новой нити. Подробности смотрите в B<sigevent>(7)."

#. type: Plain text
#: man-pages/man3/mq_notify.3:101
msgid ""
"Only one process can be registered to receive notification from a message "
"queue."
msgstr "Только один процесс может быть зарегистрирован, чтобы получить уведомление из очереди сообщений."

#. type: Plain text
#: man-pages/man3/mq_notify.3:108
msgid ""
"If I<sevp> is NULL, and the calling process is currently registered to "
"receive notifications for this message queue, then the registration is "
"removed; another process can then register to receive a message notification"
" for this queue."
msgstr "Если I<sevp> равно NULL и вызывающий процесс уже зарегистрирован принимать сообщения для этой очереди сообщений, то регистрация удаляется; после этого другой процесс может зарегистрироваться для получения уведомлений о сообщениях в этой очереди."

#. type: Plain text
#: man-pages/man3/mq_notify.3:115
msgid ""
"Message notification occurs only when a new message arrives and the queue "
"was previously empty.  If the queue was not empty at the time B<mq_notify>()"
"  was called, then a notification will occur only after the queue is emptied"
" and a new message arrives."
msgstr "Уведомление о сообщение возникает только при поступлении нового сообщения и если очередь до этого была пуста. Если очередь не пуста на момент вызова B<mq_notify>(), то уведомление будет происходить только после опустошения очереди и поступлении нового сообщения."

#. type: Plain text
#: man-pages/man3/mq_notify.3:123
msgid ""
"If another process or thread is waiting to read a message from an empty "
"queue using B<mq_receive>(3), then any message notification registration is "
"ignored: the message is delivered to the process or thread calling "
"B<mq_receive>(3), and the message notification registration remains in "
"effect."
msgstr "Если другой процесс или нить ожидают чтения сообщения из пустой очереди с помощью B<mq_receive>(3), то все регистрации по уведомлению игнорируются; сообщение доставляется процесс или нити вызвавшей B<mq_receive>(3), и регистрация уведомления о сообщении остаётся как была."

#. type: Plain text
#: man-pages/man3/mq_notify.3:134
msgid ""
"Notification occurs once: after a notification is delivered, the "
"notification registration is removed, and another process can register for "
"message notification.  If the notified process wishes to receive the next "
"notification, it can use B<mq_notify>()  to request a further notification."
"  This should be done before emptying all unread messages from the queue.  "
"(Placing the queue in nonblocking mode is useful for emptying the queue of "
"messages without blocking once it is empty.)"
msgstr "Уведомление выполняется один раз: после доставки уведомления регистрация удаляется и другой процесс может зарегистрироваться для уведомления. Если уведомлённый процесс хочет получить следующее уведомление, то он может использовать B<mq_notify>() для запроса уведомления в дальнейшем. Это должно быть сделано до исчезновения всех непрочитанных сообщений из очереди (переключение очереди в неблокирующий режим полезно для опустошения очереди сообщений без блокировки, если очередь пуста)."

#. type: Plain text
#: man-pages/man3/mq_notify.3:140
msgid ""
"On success B<mq_notify>()  returns 0; on error, -1 is returned, with "
"I<errno> set to indicate the error."
msgstr "При успешном выполнении B<mq_notify>() возвращает 0; при ошибке возвращает -1, а в I<errno> помещается код ошибки."

#. type: Plain text
#: man-pages/man3/mq_notify.3:150
msgid ""
"Another process has already registered to receive notification for this "
"message queue."
msgstr "Другой процесс уже зарегистрировался, чтобы получать уведомление из этой очереди сообщений."

#. type: Plain text
#: man-pages/man3/mq_notify.3:160
msgid ""
"I<sevp-E<gt>sigev_notify> is not one of the permitted values; or "
"I<sevp-E<gt>sigev_notify> is B<SIGEV_SIGNAL> and I<sevp-E<gt>sigev_signo> is"
" not a valid signal number."
msgstr "Значение I<sevp-E<gt>sigev_notify> содержит недопустимое значение; или I<sevp-E<gt>sigev_notify> равно B<SIGEV_SIGNAL> и I<sevp-E<gt>sigev_signo> не содержит корректного номера сигнала."

#. type: Plain text
#: man-pages/man3/mq_notify.3:163
msgid "Insufficient memory."
msgstr "Недостаточно памяти."

#.  Linux does not do this
#. type: Plain text
#: man-pages/man3/mq_notify.3:174
msgid ""
"POSIX.1-2008 says that an implementation I<may> generate an B<EINVAL> error "
"if I<sevp> is NULL, and the caller is not currently registered to receive "
"notifications for the queue I<mqdes>."
msgstr "В POSIX.1-2008 сказано, что реализация I<может> генерировать ошибку B<EINVAL>, если I<sevp> равно NULL, и вызывающий ещё не зарегистрирован для получения уведомлений из очереди I<mqdes>."

#. type: tbl table
#: man-pages/man3/mq_notify.3:184
#, no-wrap
msgid "B<mq_notify>()"
msgstr "B<mq_notify>()"

#. type: Plain text
#: man-pages/man3/mq_notify.3:189
msgid "POSIX.1-2001."
msgstr "POSIX.1-2001."

#. type: Plain text
#: man-pages/man3/mq_notify.3:211
msgid ""
"In the glibc implementation, the B<mq_notify>()  library function is "
"implemented on top of the system call of the same name.  When I<sevp> is "
"NULL, or specifies a notification mechanism other than B<SIGEV_THREAD>, the "
"library function directly invokes the system call.  For B<SIGEV_THREAD>, "
"much of the implementation resides within the library, rather than the "
"kernel.  (This is necessarily so, since the thread involved in handling the "
"notification is one that must be managed by the C library POSIX threads "
"implementation.)  The implementation involves the use of a raw B<netlink>(7)"
"  socket and creates a new thread for each notification that is delivered to"
" the process."
msgstr "В glibc библиотечная функция B<mq_notify>() реализована на основе системного вызова с тем же именем. Если I<sevp> равно NULL или задаёт механизм уведомления не B<SIGEV_THREAD>, то библиотечная функция напрямую вызывает системный вызов. Большая часть реализации B<SIGEV_THREAD> располагается внутри библиотеки, а не в ядре (эта необходимость возникает из-за того, что нить, вовлечённая в обработку уведомления, должна управляться в библиотечной реализации C нитей POSIX). В реализации задействуется неструктурированный сокет B<netlink>(7) и создаётся новая нить для каждого уведомления, доставляемого процессу."

#. type: Plain text
#: man-pages/man3/mq_notify.3:217
msgid ""
"The following program registers a notification request for the message queue"
" named in its command-line argument.  Notification is performed by creating "
"a thread.  The thread executes a function which reads one message from the "
"queue and then terminates the process."
msgstr "В следующей программе показана регистрация запроса уведомления для очереди сообщений с именем, указанном в аргументе командной строки. Уведомление выполняется создаваемой нитью. Нить выполняет функцию, которая читает одно сообщение из очереди и завершает процесс."

#. type: Plain text
#: man-pages/man3/mq_notify.3:224
#, no-wrap
msgid ""
"#include E<lt>pthread.hE<gt>\n"
"#include E<lt>mqueue.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
msgstr "#include E<lt>pthread.hE<gt>\n#include E<lt>mqueue.hE<gt>\n#include E<lt>stdio.hE<gt>\n#include E<lt>stdlib.hE<gt>\n#include E<lt>unistd.hE<gt>\n"

#. type: Plain text
#: man-pages/man3/mq_notify.3:235
#, no-wrap
msgid ""
"static void                     /* Thread start function */\n"
"tfunc(union sigval sv)\n"
"{\n"
"    struct mq_attr attr;\n"
"    ssize_t nr;\n"
"    void *buf;\n"
"    mqd_t mqdes = *((mqd_t *) sv.sival_ptr);\n"
msgstr "static void                     /* начальная функция нити */\ntfunc(union sigval sv)\n{\n    struct mq_attr attr;\n    ssize_t nr;\n    void *buf;\n    mqd_t mqdes = *((mqd_t *) sv.sival_ptr);\n"

#. type: Plain text
#: man-pages/man3/mq_notify.3:237
#, no-wrap
msgid "    /* Determine max. msg size; allocate buffer to receive msg */\n"
msgstr "/* Определяем максимальный размер сообщения; выделяем буфер для принимаемого сообщения */\n"

#. type: Plain text
#: man-pages/man3/mq_notify.3:243
#, no-wrap
msgid ""
"    if (mq_getattr(mqdes, &attr) == -1)\n"
"        handle_error(\"mq_getattr\");\n"
"    buf = malloc(attr.mq_msgsize);\n"
"    if (buf == NULL)\n"
"        handle_error(\"malloc\");\n"
msgstr "    if (mq_getattr(mqdes, &attr) == -1)\n        handle_error(\"mq_getattr\");\n    buf = malloc(attr.mq_msgsize);\n    if (buf == NULL)\n        handle_error(\"malloc\");\n"

#. type: Plain text
#: man-pages/man3/mq_notify.3:247
#, no-wrap
msgid ""
"    nr = mq_receive(mqdes, buf, attr.mq_msgsize, NULL);\n"
"    if (nr == -1)\n"
"        handle_error(\"mq_receive\");\n"
msgstr "    nr = mq_receive(mqdes, buf, attr.mq_msgsize, NULL);\n    if (nr == -1)\n        handle_error(\"mq_receive\");\n"

#. type: Plain text
#: man-pages/man3/mq_notify.3:252
#, no-wrap
msgid ""
"    printf(\"Read %zd bytes from MQ\\en\", nr);\n"
"    free(buf);\n"
"    exit(EXIT_SUCCESS);         /* Terminate the process */\n"
"}\n"
msgstr "    printf(\"Read %zd bytes from MQ\\en\", nr);\n    free(buf);\n    exit(EXIT_SUCCESS);         /* Завершение процесса */\n}\n"

#. type: Plain text
#: man-pages/man3/mq_notify.3:258
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    mqd_t mqdes;\n"
"    struct sigevent sev;\n"
msgstr "int\nmain(int argc, char *argv[])\n{\n    mqd_t mqdes;\n    struct sigevent sev;\n"

#. type: Plain text
#: man-pages/man3/mq_notify.3:263
#, no-wrap
msgid ""
"    if (argc != 2) {\n"
"        fprintf(stderr, \"Usage: %s E<lt>mq-nameE<gt>\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr "    if (argc != 2) {\n        fprintf(stderr, \"Использование: %s E<lt>mq-nameE<gt>\\en\", argv[0]);\n        exit(EXIT_FAILURE);\n    }\n"

#. type: Plain text
#: man-pages/man3/mq_notify.3:267
#, no-wrap
msgid ""
"    mqdes = mq_open(argv[1], O_RDONLY);\n"
"    if (mqdes == (mqd_t) -1)\n"
"        handle_error(\"mq_open\");\n"
msgstr "    mqdes = mq_open(argv[1], O_RDONLY);\n    if (mqdes == (mqd_t) -1)\n        handle_error(\"mq_open\");\n"

#. type: Plain text
#: man-pages/man3/mq_notify.3:274
#, no-wrap
msgid ""
"    sev.sigev_notify = SIGEV_THREAD;\n"
"    sev.sigev_notify_function = tfunc;\n"
"    sev.sigev_notify_attributes = NULL;\n"
"    sev.sigev_value.sival_ptr = &mqdes;   /* Arg. to thread func. */\n"
"    if (mq_notify(mqdes, &sev) == -1)\n"
"        handle_error(\"mq_notify\");\n"
msgstr "    sev.sigev_notify = SIGEV_THREAD;\n    sev.sigev_notify_function = tfunc;\n    sev.sigev_notify_attributes = NULL;\n    sev.sigev_value.sival_ptr = &mqdes;   /* аргументы функции нити */\n    if (mq_notify(mqdes, &sev) == -1)\n        handle_error(\"mq_notify\");\n"

#. type: Plain text
#: man-pages/man3/mq_notify.3:277
#, no-wrap
msgid ""
"    pause();    /* Process will be terminated by thread function */\n"
"}\n"
msgstr "    pause();    /* процесс будет завершён из функции нити */\n}\n"

#. type: Plain text
#: man-pages/man3/mq_notify.3:286
msgid ""
"B<mq_close>(3), B<mq_getattr>(3), B<mq_open>(3), B<mq_receive>(3), "
"B<mq_send>(3), B<mq_unlink>(3), B<mq_overview>(7), B<sigevent>(7)"
msgstr "B<mq_close>(3), B<mq_getattr>(3), B<mq_open>(3), B<mq_receive>(3), B<mq_send>(3), B<mq_unlink>(3), B<mq_overview>(7), B<sigevent>(7)"

#. type: TH
#: man-pages/man3/makecontext.3:28
#, no-wrap
msgid "MAKECONTEXT"
msgstr "MAKECONTEXT"

#. type: Plain text
#: man-pages/man3/makecontext.3:31
msgid "makecontext, swapcontext - manipulate user context"
msgstr "makecontext, swapcontext - управляет пользовательским контекстом"

#. type: Plain text
#: man-pages/man3/makecontext.3:33
msgid "B<#include E<lt>ucontext.hE<gt>>"
msgstr "B<#include E<lt>ucontext.hE<gt>>"

#. type: Plain text
#: man-pages/man3/makecontext.3:36
msgid ""
"B<void makecontext(ucontext_t *>I<ucp>B<, void (*>I<func>B<)(),> B<int "
">I<argc>B<, ...);>"
msgstr "B<void makecontext(ucontext_t *>I<ucp>B<, void (*>I<func>B<)(),> B<int >I<argc>B<, ...);>"

#. type: Plain text
#: man-pages/man3/makecontext.3:38
msgid ""
"B<int swapcontext(ucontext_t *>I<oucp>B<, const ucontext_t *>I<ucp>B<);>"
msgstr "B<int swapcontext(ucontext_t *>I<oucp>B<, const ucontext_t *>I<ucp>B<);>"

#. type: Plain text
#: man-pages/man3/makecontext.3:49
msgid ""
"In a System V-like environment, one has the type I<ucontext_t> defined in "
"I<E<lt>ucontext.hE<gt>> and the four functions B<getcontext>(3), "
"B<setcontext>(3), B<makecontext>()  and B<swapcontext>()  that allow user-"
"level context switching between multiple threads of control within a "
"process."
msgstr "В окружении, подобном SysV, имеется тип данных I<mcontext_t>, определённый в файле I<E<lt>ucontext.hE<gt>>, и четыре функции — B<getcontext>(3), B<setcontext>(3), B<makecontext>() и B<swapcontext>(), которые позволяют контексту пользовательского уровня переключаться между несколькими нитями внутри одного процесса."

#. type: Plain text
#: man-pages/man3/makecontext.3:52
msgid "For the type and the first two functions, see B<getcontext>(3)."
msgstr "Описание типа и первых двух функций смотрите в B<getcontext>(3)."

#. type: Plain text
#: man-pages/man3/makecontext.3:64
msgid ""
"The B<makecontext>()  function modifies the context pointed to by I<ucp> "
"(which was obtained from a call to B<getcontext>(3)).  Before invoking "
"B<makecontext>(), the caller must allocate a new stack for this context and "
"assign its address to I<ucp-E<gt>uc_stack>, and define a successor context "
"and assign its address to I<ucp-E<gt>uc_link>."
msgstr "Функция B<makecontext>() изменяет контекст, на который указывает I<ucp> (полученный из вызова B<getcontext>(3)). Перед вызовом B<makecontext>(), вызывающий должен выделить новый стек для этого контекста и присвоить его адрес I<ucp-E<gt>uc_stack>, и определить последующий контекст и присвоить его адрес I<ucp-E<gt>uc_link>."

#. type: Plain text
#: man-pages/man3/makecontext.3:78
msgid ""
"When this context is later activated (using B<setcontext>(3)  or "
"B<swapcontext>())  the function I<func> is called, and passed the series of "
"integer (I<int>)  arguments that follow I<argc>; the caller must specify the"
" number of these arguments in I<argc>.  When this function returns, the "
"successor context is activated.  If the successor context pointer is NULL, "
"the thread exits."
msgstr "Позднее, когда этот контекст активируется (с помощью B<setcontext>(3) или B<swapcontext>()), вызывается функция I<func> и ей передаётся набор целочисленных аргументов (I<int>), указанных после I<argc>; вызывающий должен указать количество этих аргументов в I<argc>. После возврата из функции активируется последующий контекст. Если указатель последующего контекста равен NULL, то нить завершается."

#. type: Plain text
#: man-pages/man3/makecontext.3:84
msgid ""
"The B<swapcontext>()  function saves the current context in the structure "
"pointed to by I<oucp>, and then activates the context pointed to by I<ucp>."
msgstr "Функция B<swapcontext>() сохраняет текущий контекст в структуру, на которую указывает I<oucp>, и после этого активирует контекст, на который указывает I<ucp>."

#. type: Plain text
#: man-pages/man3/makecontext.3:96
msgid ""
"When successful, B<swapcontext>()  does not return.  (But we may return "
"later, in case I<oucp> is activated, in which case it looks like "
"B<swapcontext>()  returns 0.)  On error, B<swapcontext>()  returns -1 and "
"sets I<errno> appropriately."
msgstr "При успешном выполнении B<swapcontext>() не возвращает выполнение (но мы можем вернуться позднее при активации I<oucp> и это будет выглядеть как если бы B<swapcontext>() вернула 0). При ошибке B<swapcontext>() возвращает -1 и изменяет I<errno> соответствующим образом."

#. type: Plain text
#: man-pages/man3/makecontext.3:100
msgid "Insufficient stack space left."
msgstr "Осталось недостаточно стекового пространства."

#. type: Plain text
#: man-pages/man3/makecontext.3:105
msgid ""
"B<makecontext>()  and B<swapcontext>()  are provided in glibc since version "
"2.1."
msgstr "Функции B<makecontext>() и B<swapcontext>() появились в glibc начиная с версии 2.1."

#. type: tbl table
#: man-pages/man3/makecontext.3:115
#, no-wrap
msgid "B<makecontext>()"
msgstr "B<makecontext>()"

#. type: tbl table
#: man-pages/man3/makecontext.3:115
#, no-wrap
msgid "MT-Safe race:ucp"
msgstr "MT-Safe race:ucp"

#. type: tbl table
#: man-pages/man3/makecontext.3:118
#, no-wrap
msgid "B<swapcontext>()"
msgstr "B<swapcontext>()"

#. type: tbl table
#: man-pages/man3/makecontext.3:118
#, no-wrap
msgid "MT-Safe race:oucp race:ucp"
msgstr "MT-Safe race:oucp race:ucp"

#. type: Plain text
#: man-pages/man3/makecontext.3:128
msgid ""
"SUSv2, POSIX.1-2001.  POSIX.1-2008 removes the specifications of "
"B<makecontext>()  and B<swapcontext>(), citing portability issues, and "
"recommending that applications be rewritten to use POSIX threads instead."
msgstr "SUSv2, POSIX.1-2001. В POSIX.1-2008 удалены определения B<makecontext>() и B<swapcontext>() со ссылкой на проблемы с переносимостью и рекомендацией переписать приложение с использование нитей POSIX."

#. type: Plain text
#: man-pages/man3/makecontext.3:136
msgid ""
"The interpretation of I<ucp-E<gt>uc_stack> is just as in B<sigaltstack>(2), "
"namely, this struct contains the start and length of a memory area to be "
"used as the stack, regardless of the direction of growth of the stack.  "
"Thus, it is not necessary for the user program to worry about this "
"direction."
msgstr "Назначение I<ucp-E<gt>uc_stack> подобно описанному в B<sigaltstack>(2), а именно: данная структура содержит начало и размер области памяти, которая будет использоваться как стек, независимо от направления роста стека. То есть, в пользовательской программе нет необходимости учитывать это направление."

#. type: Plain text
#: man-pages/man3/makecontext.3:152
msgid ""
"On architectures where I<int> and pointer types are the same size (e.g., "
"x86-32, where both types are 32 bits), you may be able to get away with "
"passing pointers as arguments to B<makecontext>()  following I<argc>.  "
"However, doing this is not guaranteed to be portable, is undefined according"
" to the standards, and won't work on architectures where pointers are larger"
" than I<int>s.  Nevertheless, starting with version 2.8, glibc makes some "
"changes to B<makecontext>(), to permit this on some 64-bit architectures "
"(e.g., x86-64)."
msgstr "В архитектурах, где тип I<int> и указатель имеют одинаковый размер (например, x86-32, оба типа имеют размер 32 бита), вы можете передавать указатели в аргументах B<makecontext>() после I<argc>. Однако, это не гарантирует переносимость, не определено в стандарте и не работает на архитектурах, где указатели больше I<int>. Тем не менее, начиная с версии 2.8, в glibc внесены изменения в B<makecontext>(), которые позволяют это и на некоторых 64-битных архитектурах (например, x86-64)."

#. type: Plain text
#: man-pages/man3/makecontext.3:160
msgid ""
"The example program below demonstrates the use of B<getcontext>(3), "
"B<makecontext>(), and B<swapcontext>().  Running the program produces the "
"following output:"
msgstr "В программе, показанной далее, демонстрируется использование B<getcontext>(3), B<makecontext>() и B<swapcontext>(). Вот результат запуска этой программы:"

#. type: Plain text
#: man-pages/man3/makecontext.3:172
#, no-wrap
msgid ""
"$B< ./a.out>\n"
"main: swapcontext(&uctx_main, &uctx_func2)\n"
"func2: started\n"
"func2: swapcontext(&uctx_func2, &uctx_func1)\n"
"func1: started\n"
"func1: swapcontext(&uctx_func1, &uctx_func2)\n"
"func2: returning\n"
"func1: returning\n"
"main: exiting\n"
msgstr "$B< ./a.out>\nmain: swapcontext(&uctx_main, &uctx_func2)\nfunc2: запущена\nfunc2: swapcontext(&uctx_func2, &uctx_func1)\nfunc1: запущена\nfunc1: swapcontext(&uctx_func1, &uctx_func2)\nfunc2: возврат\nfunc1: возврат\nmain: выход\n"

#. type: Plain text
#: man-pages/man3/makecontext.3:180
#, no-wrap
msgid ""
"#include E<lt>ucontext.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
msgstr "#include E<lt>ucontext.hE<gt>\n#include E<lt>stdio.hE<gt>\n#include E<lt>stdlib.hE<gt>\n"

#. type: Plain text
#: man-pages/man3/makecontext.3:182
#, no-wrap
msgid "static ucontext_t uctx_main, uctx_func1, uctx_func2;\n"
msgstr "static ucontext_t uctx_main, uctx_func1, uctx_func2;\n"

#. type: Plain text
#: man-pages/man3/makecontext.3:195
#, no-wrap
msgid ""
"static void\n"
"func1(void)\n"
"{\n"
"    printf(\"func1: started\\en\");\n"
"    printf(\"func1: swapcontext(&uctx_func1, &uctx_func2)\\en\");\n"
"    if (swapcontext(&uctx_func1, &uctx_func2) == -1)\n"
"        handle_error(\"swapcontext\");\n"
"    printf(\"func1: returning\\en\");\n"
"}\n"
msgstr "static void\nfunc1(void)\n{\n    printf(\"func1: запущена\\en\");\n    printf(\"func1: swapcontext(&uctx_func1, &uctx_func2)\\en\");\n    if (swapcontext(&uctx_func1, &uctx_func2) == -1)\n        handle_error(\"swapcontext\");\n    printf(\"func1: возврат\\en\");\n}\n"

#. type: Plain text
#: man-pages/man3/makecontext.3:205
#, no-wrap
msgid ""
"static void\n"
"func2(void)\n"
"{\n"
"    printf(\"func2: started\\en\");\n"
"    printf(\"func2: swapcontext(&uctx_func2, &uctx_func1)\\en\");\n"
"    if (swapcontext(&uctx_func2, &uctx_func1) == -1)\n"
"        handle_error(\"swapcontext\");\n"
"    printf(\"func2: returning\\en\");\n"
"}\n"
msgstr "static void\nfunc2(void)\n{\n    printf(\"func2: запущена\\en\");\n    printf(\"func2: swapcontext(&uctx_func2, &uctx_func1)\\en\");\n    if (swapcontext(&uctx_func2, &uctx_func1) == -1)\n        handle_error(\"swapcontext\");\n    printf(\"func2: возврат\\en\");\n}\n"

#. type: Plain text
#: man-pages/man3/makecontext.3:211
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    char func1_stack[16384];\n"
"    char func2_stack[16384];\n"
msgstr "int\nmain(int argc, char *argv[])\n{\n    char func1_stack[16384];\n    char func2_stack[16384];\n"

#. type: Plain text
#: man-pages/man3/makecontext.3:218
#, no-wrap
msgid ""
"    if (getcontext(&uctx_func1) == -1)\n"
"        handle_error(\"getcontext\");\n"
"    uctx_func1.uc_stack.ss_sp = func1_stack;\n"
"    uctx_func1.uc_stack.ss_size = sizeof(func1_stack);\n"
"    uctx_func1.uc_link = &uctx_main;\n"
"    makecontext(&uctx_func1, func1, 0);\n"
msgstr "    if (getcontext(&uctx_func1) == -1)\n        handle_error(\"getcontext\");\n    uctx_func1.uc_stack.ss_sp = func1_stack;\n    uctx_func1.uc_stack.ss_size = sizeof(func1_stack);\n    uctx_func1.uc_link = &uctx_main;\n    makecontext(&uctx_func1, func1, 0);\n"

#. type: Plain text
#: man-pages/man3/makecontext.3:226
#, no-wrap
msgid ""
"    if (getcontext(&uctx_func2) == -1)\n"
"        handle_error(\"getcontext\");\n"
"    uctx_func2.uc_stack.ss_sp = func2_stack;\n"
"    uctx_func2.uc_stack.ss_size = sizeof(func2_stack);\n"
"    /* Successor context is f1(), unless argc E<gt> 1 */\n"
"    uctx_func2.uc_link = (argc E<gt> 1) ? NULL : &uctx_func1;\n"
"    makecontext(&uctx_func2, func2, 0);\n"
msgstr "    if (getcontext(&uctx_func2) == -1)\n        handle_error(\"getcontext\");\n    uctx_func2.uc_stack.ss_sp = func2_stack;\n    uctx_func2.uc_stack.ss_size = sizeof(func2_stack);\n    /* последующий контекст — f1(), если argc E<gt> 1 */\n    uctx_func2.uc_link = (argc E<gt> 1) ? NULL : &uctx_func1;\n    makecontext(&uctx_func2, func2, 0);\n"

#. type: Plain text
#: man-pages/man3/makecontext.3:230
#, no-wrap
msgid ""
"    printf(\"main: swapcontext(&uctx_main, &uctx_func2)\\en\");\n"
"    if (swapcontext(&uctx_main, &uctx_func2) == -1)\n"
"        handle_error(\"swapcontext\");\n"
msgstr "    printf(\"main: swapcontext(&uctx_main, &uctx_func2)\\en\");\n    if (swapcontext(&uctx_main, &uctx_func2) == -1)\n        handle_error(\"swapcontext\");\n"

#. type: Plain text
#: man-pages/man3/makecontext.3:234
#, no-wrap
msgid ""
"    printf(\"main: exiting\\en\");\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr "    printf(\"main: выход\\en\");\n    exit(EXIT_SUCCESS);\n}\n"

#. type: Plain text
#: man-pages/man3/makecontext.3:240
msgid ""
"B<sigaction>(2), B<sigaltstack>(2), B<sigprocmask>(2), B<getcontext>(3), "
"B<sigsetjmp>(3)"
msgstr "B<sigaction>(2), B<sigaltstack>(2), B<sigprocmask>(2), B<getcontext>(3), B<sigsetjmp>(3)"

#. type: TH
#: man-pages/man3/memmem.3:30
#, no-wrap
msgid "MEMMEM"
msgstr "MEMMEM"

#. type: Plain text
#: man-pages/man3/memmem.3:33
msgid "memmem - locate a substring"
msgstr "memmem - ищет подстроку"

#. type: Plain text
#: man-pages/man3/memmem.3:40
#, no-wrap
msgid ""
"B<void *memmem(const void *>I<haystack>B<, size_t >I<haystacklen>B<,>\n"
"B<             const void *>I<needle>B<, size_t >I<needlelen>B<);>\n"
msgstr "B<void *memmem(const void *>I<haystack>B<, size_t >I<haystacklen>B<,>\nB<             const void *>I<needle>B<, size_t >I<needlelen>B<);>\n"

#. type: Plain text
#: man-pages/man3/memmem.3:54
msgid ""
"The B<memmem>()  function finds the start of the first occurrence of the "
"substring I<needle> of length I<needlelen> in the memory area I<haystack> of"
" length I<haystacklen>."
msgstr "Функция B<memmem>() ищет начало первого появления подстроки I<needle> длинной I<needlelen> в области памяти I<haystack> размером I<haystacklen>."

#. type: Plain text
#: man-pages/man3/memmem.3:59
msgid ""
"The B<memmem>()  function returns a pointer to the beginning of the "
"substring, or NULL if the substring is not found."
msgstr "Функция B<memmem>() возвращает указатель на начало подстроки или NULL, если подстрока не найдена."

#. type: tbl table
#: man-pages/man3/memmem.3:69
#, no-wrap
msgid "B<memmem>()"
msgstr "B<memmem>()"

#. type: Plain text
#: man-pages/man3/memmem.3:74
msgid ""
"This function is not specified in POSIX.1, but is present on a number of "
"other systems."
msgstr "Эта функция не определена в POSIX.1, однако доступна в некоторых других системах."

#.  This function was broken in Linux libraries up to and including libc
#. 5.0.9;
#.  there the
#.  .IR needle
#.  and
#.  .I haystack
#.  arguments were interchanged,
#.  and a pointer to the end of the first occurrence of
#.  .I needle
#.  was returned.
#.  Both old and new libc's have the bug that if
#.  .I needle
#.  is empty,
#.  .I haystack\-1
#.  (instead of
#.  .IR haystack )
#.  is returned.
#. type: Plain text
#: man-pages/man3/memmem.3:99
msgid ""
"In glibc 2.0, if I<needle> is empty, B<memmem>()  returns a pointer to the "
"last byte of I<haystack>.  This is fixed in glibc 2.1."
msgstr "В glibc 2.0, если I<needle> пусто, то B<memmem>() возвращает указатель на последний байт I<haystack>. Это исправлено в glibc 2.1."

#. type: Plain text
#: man-pages/man3/memmem.3:101
msgid "B<bstring>(3), B<strstr>(3)"
msgstr "B<bstring>(3), B<strstr>(3)"

#. type: TH
#: man-pages/man3/mkstemp.3:35
#, no-wrap
msgid "MKSTEMP"
msgstr "MKSTEMP"

#. type: Plain text
#: man-pages/man3/mkstemp.3:38
msgid ""
"mkstemp, mkostemp, mkstemps, mkostemps - create a unique temporary file"
msgstr "mkstemp, mkostemp, mkstemps, mkostemps - создаёт временный файл с уникальным именем"

#. type: Plain text
#: man-pages/man3/mkstemp.3:43
#, no-wrap
msgid "B<int mkstemp(char *>I<template>B<);>\n"
msgstr "B<int mkstemp(char *>I<template>B<);>\n"

#. type: Plain text
#: man-pages/man3/mkstemp.3:45
#, no-wrap
msgid "B<int mkostemp(char *>I<template>B<, int >I<flags>B<);>\n"
msgstr "B<int mkostemp(char *>I<template>B<, int >I<flags>B<);>\n"

#. type: Plain text
#: man-pages/man3/mkstemp.3:47
#, no-wrap
msgid "B<int mkstemps(char *>I<template>B<, int >I<suffixlen>B<);>\n"
msgstr "B<int mkstemps(char *>I<template>B<, int >I<suffixlen>B<);>\n"

#. type: Plain text
#: man-pages/man3/mkstemp.3:49
#, no-wrap
msgid ""
"B<int mkostemps(char *>I<template>B<, int >I<suffixlen>B<, int "
">I<flags>B<);>\n"
msgstr "B<int mkostemps(char *>I<template>B<, int >I<suffixlen>B<, int >I<flags>B<);>\n"

#. type: Plain text
#: man-pages/man3/mkstemp.3:57
msgid "B<mkstemp>():"
msgstr "B<mkstemp>():"

#.     || _XOPEN_SOURCE\ &&\ _XOPEN_SOURCE_EXTENDED
#. type: Plain text
#: man-pages/man3/mkstemp.3:64
#, no-wrap
msgid ""
"_XOPEN_SOURCE\\ E<gt>=\\ 500\n"
"    || /* Since glibc 2.12: */ _POSIX_C_SOURCE\\ E<gt>=\\ 200809L\n"
"    || /* Glibc versions E<lt>= 2.19: */ _SVID_SOURCE || _BSD_SOURCE\n"
msgstr "_XOPEN_SOURCE\\ E<gt>=\\ 500\n    || /* начиная с glibc 2.12: */ _POSIX_C_SOURCE\\ E<gt>=\\ 200809L\n    || /* версии glibc E<lt>= 2.19: */ _SVID_SOURCE || _BSD_SOURCE\n"

#. type: Plain text
#: man-pages/man3/mkstemp.3:70
msgid "B<mkostemp>(): _GNU_SOURCE"
msgstr "B<mkostemp>(): _GNU_SOURCE"

#. type: Plain text
#: man-pages/man3/mkstemp.3:74
#, no-wrap
msgid ""
"B<mkstemps>():\n"
"    /* Glibc since 2.19: */ _DEFAULT_SOURCE\n"
"        || /* Glibc versions E<lt>= 2.19: */ _SVID_SOURCE || _BSD_SOURCE\n"
msgstr "B<mkstemps>():\n    /* glibc начиная с 2.19: */ _DEFAULT_SOURCE\n        || /* версии glibc E<lt>= 2.19: */ _SVID_SOURCE || _BSD_SOURCE\n"

#. type: Plain text
#: man-pages/man3/mkstemp.3:77
msgid "B<mkostemps>(): _GNU_SOURCE"
msgstr "B<mkostemps>(): _GNU_SOURCE"

#. type: Plain text
#: man-pages/man3/mkstemp.3:84
msgid ""
"The B<mkstemp>()  function generates a unique temporary filename from "
"I<template>, creates and opens the file, and returns an open file descriptor"
" for the file."
msgstr "Функция B<mktemp>() генерирует на основе шаблона I<template> уникальное имя для временного файла, создаёт и открывает файл, после чего возвращает дескриптор открытого файла."

#. type: Plain text
#: man-pages/man3/mkstemp.3:92
msgid ""
"The last six characters of I<template> must be \"XXXXXX\" and these are "
"replaced with a string that makes the filename unique.  Since it will be "
"modified, I<template> must not be a string constant, but should be declared "
"as a character array."
msgstr "Последние шесть символов I<template> должны быть равны \"XXXXXX\", они будут заменены на строку, которая сделает имя файла уникальным. Так как I<template> будет меняться, он должна быть объявлен не строковой константой, а массивом символов."

#. type: Plain text
#: man-pages/man3/mkstemp.3:100
msgid ""
"The file is created with permissions 0600, that is, read plus write for "
"owner only.  The returned file descriptor provides both read and write "
"access to the file.  The file is opened with the B<open>(2)  B<O_EXCL> flag,"
" guaranteeing that the caller is the process that creates the file."
msgstr "Файл создается с правами 0600, то есть читать и записывать в него может только владелец. Возвращаемый дескриптор файла предоставляет доступ к файлу как на чтение, так и на запись. Файл открывается с помощью B<open>(2) с флагом B<O_EXCL>, что гарантирует, что вызывающий является процессом, создавшим файл."

#.  Reportedly, FreeBSD
#. type: Plain text
#: man-pages/man3/mkstemp.3:131
msgid ""
"The B<mkostemp>()  function is like B<mkstemp>(), with the difference that "
"the following bits\\(emwith the same meaning as for B<open>(2)\\(emmay be "
"specified in I<flags>: B<O_APPEND>, B<O_CLOEXEC>, and B<O_SYNC>.  Note that "
"when creating the file, B<mkostemp>()  includes the values B<O_RDWR>, "
"B<O_CREAT>, and B<O_EXCL> in the I<flags> argument given to B<open>(2); "
"including these values in the I<flags> argument given to B<mkostemp>()  is "
"unnecessary, and produces errors on some systems."
msgstr "Функция B<mkostemp>() подобна B< mkstemp>(), но отличие в том, что следующие биты (с теми же значениями что и для B<open>(2)) могут быть указаны в I<flags>: B<O_APPEND>, B<O_CLOEXEC> и B<O_SYNC>. Заметим, что при создании файла B<mkostemp>() включает значения B<O_RDWR>, B<O_CREAT> и B<O_EXCL> в аргумент I<flags> при вызове B<open>(2); добавлять эти значения в аргумент I<flags> при вызове B<mkostemp>() необязательно и это приводит к ошибках в некоторых системах."

#. type: Plain text
#: man-pages/man3/mkstemp.3:147
msgid ""
"The B<mkstemps>()  function is like B<mkstemp>(), except that the string in "
"I<template> contains a suffix of I<suffixlen> characters.  Thus, I<template>"
" is of the form I<prefixXXXXXXsuffix>, and the string XXXXXX is modified as "
"for B<mkstemp>()."
msgstr "Функция B<mkstemps>() похожа на B<mkstemp>(), за исключением строки в I<template>, которая содержит символы суффикса I<suffixlen>. Таким образом, I<template> будет приобретать вид I<prefixXXXXXXsuffix>, а строка XXXXXX будет меняться так же, как и для B<mkstemp>()."

#. type: Plain text
#: man-pages/man3/mkstemp.3:156
msgid ""
"The B<mkostemps>()  function is to B<mkstemps>()  as B<mkostemp>()  is to "
"B<mkstemp>()."
msgstr "Функция B<mkostemps>() является аналогом B<mkstemps>(), подобно как B<mkostemp>() является аналогом B<mkstemp>()."

#. type: Plain text
#: man-pages/man3/mkstemp.3:162
msgid ""
"On success, these functions return the file descriptor of the temporary "
"file.  On error, -1 is returned, and I<errno> is set appropriately."
msgstr "При успешном выполнении данные функции возвращают дескриптор временного файла. В случае ошибки возвращается -1, а I<errno> устанавливается в соответствующее значение."

#. type: Plain text
#: man-pages/man3/mkstemp.3:167
msgid ""
"Could not create a unique temporary filename.  Now the contents of "
"I<template> are undefined."
msgstr "Невозможно создать уникальное имя временного файла. Содержимое I<template> теперь не определено."

#. type: Plain text
#: man-pages/man3/mkstemp.3:175
msgid ""
"For B<mkstemp>()  and B<mkostemp>(): The last six characters of I<template> "
"were not XXXXXX; now I<template> is unchanged."
msgstr "Для B<mkstemp>() и B<mkostemp>(): последние шесть символов I<template> не равны XXXXXX. I<template> не изменён."

#. type: Plain text
#: man-pages/man3/mkstemp.3:186
msgid ""
"For B<mkstemps>()  and B<mkostemps>(): I<template> is less than I<(6 + "
"suffixlen)> characters long, or the last 6 characters before the suffix in "
"I<template> were not XXXXXX."
msgstr "Для B<mkstemps>() и B<mkostemps>(): количество символов I<template> меньше, чем I<(6 + suffixlen)> или последние 6 символов до суффикса в I<template> не равны XXXXXX."

#. type: Plain text
#: man-pages/man3/mkstemp.3:189
msgid ""
"These functions may also fail with any of the errors described for "
"B<open>(2)."
msgstr "Данные функции также могут завершиться ошибками, описанными в B<open>(2)."

#. type: Plain text
#: man-pages/man3/mkstemp.3:196
msgid ""
"B<mkostemp>()  is available since glibc 2.7.  B<mkstemps>()  and "
"B<mkostemps>()  are available since glibc 2.11."
msgstr "B<mkostemp>() впервые появилась в glibc 2.7. B<mkstemps>() и B<mkostemps>() доступны в glibc с версии 2.11."

#. type: tbl table
#: man-pages/man3/mkstemp.3:207
#, no-wrap
msgid ""
"B<mkstemp>(),\n"
"B<mkostemp>(),\n"
msgstr "B<mkstemp>(),\nB<mkostemp>(),\n"

#. type: tbl table
#: man-pages/man3/mkstemp.3:210
#, no-wrap
msgid ""
"B<mkstemps>(),\n"
"B<mkostemps>()"
msgstr "B<mkstemps>(),\nB<mkostemps>()"

#. type: Plain text
#: man-pages/man3/mkstemp.3:215
msgid "B<mkstemp>(): 4.3BSD, POSIX.1-2001."
msgstr "B<mkstemp>(): 4.3BSD, POSIX.1-2001."

#.  mkstemps() appears to be at least on the BSDs, Mac OS X, Solaris,
#.  and Tru64.
#. type: Plain text
#: man-pages/man3/mkstemp.3:220
msgid "B<mkstemps>(): unstandardized, but appears on several other systems."
msgstr "B<mkstemps>() не стандартизована, однако может присутствовать на некоторых системах."

#. type: Plain text
#: man-pages/man3/mkstemp.3:225
msgid "B<mkostemp>()  and B<mkostemps>(): are glibc extensions."
msgstr "B<mkostemp>() и B<mkstemp>(): являются расширениями glibc."

#. type: Plain text
#: man-pages/man3/mkstemp.3:232
msgid ""
"In glibc versions 2.06 and earlier, the file is created with permissions "
"0666, that is, read and write for all users.  This old behavior may be a "
"security risk, especially since other UNIX flavors use 0600, and somebody "
"might overlook this detail when porting programs.  POSIX.1-2008 adds a "
"requirement that the file be created with mode 0600."
msgstr "В версиях glibc 2.06 и ниже файл создавался с правами 0666, то есть читать и записывать в него могли все пользователи. Это старое поведение может быть небезопасным, особенно когда в других UNIX используются права 0600, и кто-то может не заметить это отличие при переносе программы. В POSIX.1-2008 добавлено требование, что файл должен создаваться с правами 0600."

#.  The prototype for
#.  .BR mkstemp ()
#.  is in
#.  .I <unistd.h>
#.  for libc4, libc5, glibc1; glibc2 follows POSIX.1 and has the prototype in
#.  .IR <stdlib.h> .
#. type: Plain text
#: man-pages/man3/mkstemp.3:250
msgid ""
"More generally, the POSIX specification of B<mkstemp>()  does not say "
"anything about file modes, so the application should make sure its file mode"
" creation mask (see B<umask>(2))  is set appropriately before calling "
"B<mkstemp>()  (and B<mkostemp>())."
msgstr "В более общем смысле, в спецификации POSIX для B<mkstemp>() ничего не сказано о правах на файл, поэтому программа должна сама проверить до вызова B<mkstemp>()  (и B<mkostemp>()), что маска создания файла (смотрите B<umask>(2)) уставлена в правильное значение."

#. type: Plain text
#: man-pages/man3/mkstemp.3:255
msgid ""
"B<mkdtemp>(3), B<mktemp>(3), B<tempnam>(3), B<tmpfile>(3), B<tmpnam>(3)"
msgstr "B<mkdtemp>(3), B<mktemp>(3), B<tempnam>(3), B<tmpfile>(3), B<tmpnam>(3)"

#. type: TH
#: man-pages/man3/mq_close.3:26
#, no-wrap
msgid "MQ_CLOSE"
msgstr "MQ_CLOSE"

#. type: Plain text
#: man-pages/man3/mq_close.3:29
msgid "mq_close - close a message queue descriptor"
msgstr "mq_close - закрывает дескриптор очереди сообщений"

#. type: Plain text
#: man-pages/man3/mq_close.3:34
#, no-wrap
msgid "B<int mq_close(mqd_t >I<mqdes>B<);>\n"
msgstr "B<int mq_close(mqd_t >I<mqdes>B<);>\n"

#. type: Plain text
#: man-pages/man3/mq_close.3:41
msgid "B<mq_close>()  closes the message queue descriptor I<mqdes>."
msgstr "B<mq_close>() закрывает дескриптор очереди сообщений I<mqdes>."

#. type: Plain text
#: man-pages/man3/mq_close.3:48
msgid ""
"If the calling process has attached a notification request (see "
"(B<mq_notify>(3))  to this message queue via I<mqdes>, then this request is "
"removed, and another process can now attach a notification request."
msgstr "Если к вызывающему процессу присоединён запрос уведомления (смотрите (B<mq_notify>(3)) от этой очереди сообщений через I<mqdes>, то этот запрос удаляется, и теперь другой процесс может присоединить запрос уведомлений."

#. type: Plain text
#: man-pages/man3/mq_close.3:54
msgid ""
"On success B<mq_close>()  returns 0; on error, -1 is returned, with I<errno>"
" set to indicate the error."
msgstr "При успешном выполнении B<mq_close>() возвращается 0; при ошибке возвращается -1, а в I<errno> помещается код ошибки."

#. type: tbl table
#: man-pages/man3/mq_close.3:70
#, no-wrap
msgid "B<mq_close>()"
msgstr "B<mq_close>()"

#. type: Plain text
#: man-pages/man3/mq_close.3:78
msgid ""
"All open message queues are automatically closed on process termination, or "
"upon B<execve>(2)."
msgstr "Все открытые очереди сообщений автоматически закрываются при завершении процесса или после B<execve>(2)."

#. type: Plain text
#: man-pages/man3/mq_close.3:85
msgid ""
"B<mq_getattr>(3), B<mq_notify>(3), B<mq_open>(3), B<mq_receive>(3), "
"B<mq_send>(3), B<mq_unlink>(3), B<mq_overview>(7)"
msgstr "B<mq_getattr>(3), B<mq_notify>(3), B<mq_open>(3), B<mq_receive>(3), B<mq_send>(3), B<mq_unlink>(3), B<mq_overview>(7)"

#. type: TH
#: man-pages/man3/mq_open.3:26
#, no-wrap
msgid "MQ_OPEN"
msgstr "MQ_OPEN"

#. type: Plain text
#: man-pages/man3/mq_open.3:29
msgid "mq_open - open a message queue"
msgstr "mq_open - открывает очередь сообщений"

#. type: Plain text
#: man-pages/man3/mq_open.3:34
#, no-wrap
msgid ""
"B<#include E<lt>fcntl.hE<gt>>           /* For O_* constants */\n"
"B<#include E<lt>sys/stat.hE<gt>>        /* For mode constants */\n"
"B<#include E<lt>mqueue.hE<gt>>\n"
msgstr "B<#include E<lt>fcntl.hE<gt>>           /* Постоянные вида O_* */\nB<#include E<lt>sys/stat.hE<gt>>        /* Постоянные для mode */\nB<#include E<lt>mqueue.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/mq_open.3:38
#, no-wrap
msgid ""
"B<mqd_t mq_open(const char *>I<name>B<, int >I<oflag>B<);>\n"
"B<mqd_t mq_open(const char *>I<name>B<, int >I<oflag>B<, mode_t >I<mode>B<,>\n"
"B<              struct mq_attr *>I<attr>B<);>\n"
msgstr "B<mqd_t mq_open(const char *>I<name>B<, int >I<oflag>B<);>\nB<mqd_t mq_open(const char *>I<name>B<, int >I<oflag>B<, mode_t >I<mode>B<,>\nB<              struct mq_attr *>I<attr>B<);>\n"

#. type: Plain text
#: man-pages/man3/mq_open.3:50
msgid ""
"B<mq_open>()  creates a new POSIX message queue or opens an existing queue."
"  The queue is identified by I<name>.  For details of the construction of "
"I<name>, see B<mq_overview>(7)."
msgstr "Функция B<mq_open>() создает новую очередь сообщений POSIX или открывает существующую очередь. Очередь опознаётся по имени I<name>. Для получения дополнительной информации о создании имени I<name>, смотрите B<mq_overview>(7)."

#. type: Plain text
#: man-pages/man3/mq_open.3:58
msgid ""
"The I<oflag> argument specifies flags that control the operation of the "
"call.  (Definitions of the flags values can be obtained by including "
"I<E<lt>fcntl.hE<gt>>.)  Exactly one of the following must be specified in "
"I<oflag>:"
msgstr "В параметре I<oflag> задаются флаги, которые управляют работой вызова (значения флагов могут быть получены при включении I<E<lt>fcntl.hE<gt>>). Поместить в параметр I<oflag> можно только один из ниже приведенных флагов:"

#. type: TP
#: man-pages/man3/mq_open.3:58
#, no-wrap
msgid "B<O_RDONLY>"
msgstr "B<O_RDONLY>"

#. type: Plain text
#: man-pages/man3/mq_open.3:61
msgid "Open the queue to receive messages only."
msgstr "Открыть очередь только для получения сообщений."

#. type: TP
#: man-pages/man3/mq_open.3:61
#, no-wrap
msgid "B<O_WRONLY>"
msgstr "B<O_WRONLY>"

#. type: Plain text
#: man-pages/man3/mq_open.3:64
msgid "Open the queue to send messages only."
msgstr "Открыть очередь только для отправки сообщений."

#. type: TP
#: man-pages/man3/mq_open.3:64
#, no-wrap
msgid "B<O_RDWR>"
msgstr "B<O_RDWR>"

#. type: Plain text
#: man-pages/man3/mq_open.3:67
msgid "Open the queue to both send and receive messages."
msgstr "Открыть очередь для отправки и получения сообщений."

#. type: Plain text
#: man-pages/man3/mq_open.3:72
msgid ""
"Zero or more of the following flags can additionally be I<OR>ed in I<oflag>:"
msgstr "Также в  I<oflag> можно добавить ноль и более флагов, объединённых через ИЛИ:"

#. type: TP
#: man-pages/man3/mq_open.3:72
#, no-wrap
msgid "B<O_CLOEXEC> (since Linux 2.6.26)"
msgstr "B<O_CLOEXEC> (начиная с Linux 2.6.26)"

#.  commit 269f21344b23e552c21c9e2d7ca258479dcd7a0a
#. type: Plain text
#: man-pages/man3/mq_open.3:79
msgid ""
"Set the close-on-exec flag for the message queue descriptor.  See B<open>(2)"
"  for a discussion of why this flag is useful."
msgstr "Установить флаг close-on-exec на файловом дескрипторе очереди сообщений. Описание полезности этого флага смотрите в B<open>(2)."

#. type: TP
#: man-pages/man3/mq_open.3:79
#, no-wrap
msgid "B<O_CREAT>"
msgstr "B<O_CREAT>"

#.  In reality the filesystem IDs are used on Linux.
#. type: Plain text
#: man-pages/man3/mq_open.3:87
msgid ""
"Create the message queue if it does not exist.  The owner (user ID) of the "
"message queue is set to the effective user ID of the calling process.  The "
"group ownership (group ID) is set to the effective group ID of the calling "
"process."
msgstr "Создать очередь сообщений, если она не существует. Владельцем (ID пользователя) очереди сообщений назначается эффективный ID пользователя вызывающего процесса. Владельцем-группой (ID группы) назначается эффективный ID группы вызывающего процесса."

#. type: TP
#: man-pages/man3/mq_open.3:87
#, no-wrap
msgid "B<O_EXCL>"
msgstr "B<O_EXCL>"

#. type: Plain text
#: man-pages/man3/mq_open.3:97
msgid ""
"If B<O_CREAT> was specified in I<oflag>, and a queue with the given I<name> "
"already exists, then fail with the error B<EEXIST>."
msgstr "Если в поле I<oflag> выставлен флаг B<O_CREAT> и очередь с заданным именем I<name>  уже существует, то завершить вызов ошибкой B<EEXIST>."

#. type: TP
#: man-pages/man3/mq_open.3:97
#, no-wrap
msgid "B<O_NONBLOCK>"
msgstr "B<O_NONBLOCK>"

#. type: Plain text
#: man-pages/man3/mq_open.3:106
msgid ""
"Open the queue in nonblocking mode.  In circumstances where B<mq_receive>(3)"
"  and B<mq_send>(3)  would normally block, these functions instead fail with"
" the error B<EAGAIN>."
msgstr "Открыть очередь в неблокирующем режиме. При обстоятельствах, из-за которых B<mq_receive>(3) и B<mq_send>(3), обычно, блокируются, теперь эти функции будут завершаться ошибкой B<EAGAIN>."

#. type: Plain text
#: man-pages/man3/mq_open.3:120
msgid ""
"If B<O_CREAT> is specified in I<oflag>, then two additional arguments must "
"be supplied.  The I<mode> argument specifies the permissions to be placed on"
" the new queue, as for B<open>(2).  (Symbolic definitions for the "
"permissions bits can be obtained by including I<E<lt>sys/stat.hE<gt>>.)  The"
" permissions settings are masked against the process umask."
msgstr "Если в I<oflag> указан B<O_CREAT>, требуется задать два дополнительных аргумента. В аргументе I<mode> задаются права доступа к новой очереди, как для B<open>(2) (символические определения бит прав можно получить, включив I<E<lt>sys/stat.hE<gt>>). В настройках прав учитывается umask процесса."

#. type: Plain text
#: man-pages/man3/mq_open.3:128
msgid ""
"The fields of the I<struct mq_attr> pointed to I<attr> specify the maximum "
"number of messages and the maximum size of messages that the queue will "
"allow.  This structure is defined as follows:"
msgstr "В полях структуры I<struct mq_attr>, на которую указывает I<attr>, задаётся максимальное количество сообщений и максимальный размер сообщений, разрешённых в очереди. Эта структура определена следующим образом:"

#. type: Plain text
#: man-pages/man3/mq_open.3:139
#, no-wrap
msgid ""
"struct mq_attr {\n"
"    long mq_flags;       /* Flags (ignored for mq_open()) */\n"
"    long mq_maxmsg;      /* Max. # of messages on queue */\n"
"    long mq_msgsize;     /* Max. message size (bytes) */\n"
"    long mq_curmsgs;     /* # of messages currently in queue\n"
"                            (ignored for mq_open()) */\n"
"};\n"
msgstr "struct mq_attr {\n    long mq_flags;       /* флаги (игнорируются в mq_open()) */\n    long mq_maxmsg;      /* макс. кол-во сообщений в очереди */\n    long mq_msgsize;     /* макс. размер сообщения (в байтах) */\n    long mq_curmsgs;     /* кол-во сообщений в очереди в данный момент\n                            (игнорируется в mq_open()) */\n};\n"

#. type: Plain text
#: man-pages/man3/mq_open.3:149
msgid ""
"Only the I<mq_maxmsg> and I<mq_msgsize> fields are employed when calling "
"B<mq_open>(); the values in the remaining fields are ignored."
msgstr "В функции B<mq_open>() используются только поля I<mq_maxmsg> и I<mq_msgsize>; остальные значения полей игнорируются."

#. type: Plain text
#: man-pages/man3/mq_open.3:159
msgid ""
"If I<attr> is NULL, then the queue is created with implementation-defined "
"default attributes.  Since Linux 3.5, two I</proc> files can be used to "
"control these defaults; see B<mq_overview>(7)  for details."
msgstr "Если I<attr> равно NULL, то очередь создаётся с атрибутами по умолчанию, зависящими от реализации. Начиная с Linux 3.5, для управления атрибутами по умолчанию можно управлять через два файла в I</proc>; подробности смотрите в B<mq_overview>(7)."

#. type: Plain text
#: man-pages/man3/mq_open.3:171
msgid ""
"On success, B<mq_open>()  returns a message queue descriptor for use by "
"other message queue functions.  On error, B<mq_open>()  returns I<(mqd_t)\\ "
"-1>, with I<errno> set to indicate the error."
msgstr "При успешном выполнении B<mq_open>()  возвращает файловый дескриптор очереди для использования в других функциях работы с очередями сообщений. При ошибке B<mq_open>() возвращает I<(mqd_t)\\ -1>, а в I<errno> записывается код ошибки."

#. type: Plain text
#: man-pages/man3/mq_open.3:176
msgid ""
"The queue exists, but the caller does not have permission to open it in the "
"specified mode."
msgstr "Очередь существует, но вызывающий не имеет прав для её открытия с заданным в I<mode> режиме."

#.  Note that this isn't consistent with the same case for sem_open()
#. type: Plain text
#: man-pages/man3/mq_open.3:181
msgid "I<name> contained more than one slash."
msgstr "Поле I<name> содержит больше чем одну косую черту."

#. type: Plain text
#: man-pages/man3/mq_open.3:192
msgid ""
"Both B<O_CREAT> and B<O_EXCL> were specified in I<oflag>, but a queue with "
"this I<name> already exists."
msgstr "В I<oflag> указаны B<O_CREAT> и B<O_EXCL>, но очередь I<name> уже существует."

#.  glibc checks whether the name starts with a "/" and if not,
#.  gives this error
#. type: Plain text
#: man-pages/man3/mq_open.3:199
msgid "I<name> doesn't follow the format in B<mq_overview>(7)."
msgstr "Параметр I<name> не соответствует формату, описанному в B<mq_overview>(7)."

#. type: Plain text
#: man-pages/man3/mq_open.3:231
msgid ""
"B<O_CREAT> was specified in I<oflag>, and I<attr> was not NULL, but "
"I<attr-E<gt>mq_maxmsg> or I<attr-E<gt>mq_msqsize> was invalid.  Both of "
"these fields must be greater than zero.  In a process that is unprivileged "
"(does not have the B<CAP_SYS_RESOURCE> capability), I<attr-E<gt>mq_maxmsg> "
"must be less than or equal to the I<msg_max> limit, and "
"I<attr-E<gt>mq_msgsize> must be less than or equal to the I<msgsize_max> "
"limit.  In addition, even in a privileged process, I<attr-E<gt>mq_maxmsg> "
"cannot exceed the B<HARD_MAX> limit.  (See B<mq_overview>(7)  for details of"
" these limits.)"
msgstr "В I<oflag> указан B<O_CREAT> и I<attr> не равно NULL, но в I<attr-E<gt>mq_maxmsg> или I<attr-E<gt>mq_msqsize>  содержится некорректное значение. Оба этих поля должны быть больше нуля. Если процесс без прав (не имеет мандата B<CAP_SYS_RESOURCE>), то I<attr-E<gt>mq_maxmsg> должно быть меньше или равно ограничению I<msg_max> и I<attr-E<gt>mq_msgsize> должно быть меньше или равно ограничению I<msgsize_max>. Также, даже для привилегированных процессов, значение I<attr-E<gt>mq_maxmsg> не должно превышать ограничения B<HARD_MAX> (описание ограничений смотрите в B<mq_overview>(7))."

#. type: Plain text
#: man-pages/man3/mq_open.3:239
msgid ""
"The per-process limit on the number of open file and message queue "
"descriptors has been reached (see the description of B<RLIMIT_NOFILE> in "
"B<getrlimit>(2))."
msgstr "Было достигнуто ограничение на количество открытых дескрипторов файлов и очередей сообщений (смотрите описание B<RLIMIT_NOFILE> в B<getrlimit>(2))."

#. type: Plain text
#: man-pages/man3/mq_open.3:243
msgid "I<name> was too long."
msgstr "Слишком длинное значение аргумента I<name>."

#. type: Plain text
#: man-pages/man3/mq_open.3:247
msgid ""
"The system-wide limit on the total number of open files and message queues "
"has been reached."
msgstr "Достигнуто ограничение на общее количество открытых файлов в системе и очередей сообщений."

#. type: Plain text
#: man-pages/man3/mq_open.3:256
msgid ""
"The B<O_CREAT> flag was not specified in I<oflag>, and no queue with this "
"I<name> exists."
msgstr "В I<oflag> не указан B<O_CREAT> и не существует очередь I<name>."

#.  Note that this isn't consistent with the same case for sem_open()
#. type: Plain text
#: man-pages/man3/mq_open.3:261
msgid "I<name> was just \"/\" followed by no other characters."
msgstr "В I<name> есть только «/» и нет других символов."

#. type: Plain text
#: man-pages/man3/mq_open.3:271
msgid ""
"Insufficient space for the creation of a new message queue.  This probably "
"occurred because the I<queues_max> limit was encountered; see "
"B<mq_overview>(7)."
msgstr "Недостаточно места для создания новой очереди сообщений. Вероятно, это произошло из-за ограничения I<queues_max>; смотрите B<mq_overview>(7)."

#. type: tbl table
#: man-pages/man3/mq_open.3:281
#, no-wrap
msgid "B<mq_open>()"
msgstr "B<mq_open>()"

#. type: Plain text
#: man-pages/man3/mq_open.3:303
msgid ""
"The B<mq_open>()  library function is implemented on top of a system call of"
" the same name.  The library function performs the check that the I<name> "
"starts with a slash (/), giving the B<EINVAL> error if it does not.  The "
"kernel system call expects I<name> to contain no preceding slash, so the C "
"library function passes I<name> without the preceding slash (i.e., "
"I<name+1>)  to the system call."
msgstr "Библиотечная функция B<mq_open>() реализована поверх системного вызова с тем же именем. Библиотечная функция выполняет проверку того, что I<name> начинается с косой черты (/) и выдаёт ошибку B<EINVAL>, если это не так. Системный вызов ядра ожидает I<name> без начальной косой черты, поэтому библиотечная функция C  передаёт в системный вызов I<name> без начальной косой черты (т. е., I<name+1>)."

#. type: Plain text
#: man-pages/man3/mq_open.3:307
msgid ""
"In kernels before 2.6.14, the process umask was not applied to the "
"permissions specified in I<mode>."
msgstr "В ядрах до версии 2.6.14, значение umask процесса не накладывалось на права, указанные в I<mode>."

#. type: Plain text
#: man-pages/man3/mq_open.3:314
msgid ""
"B<mq_close>(3), B<mq_getattr>(3), B<mq_notify>(3), B<mq_receive>(3), "
"B<mq_send>(3), B<mq_unlink>(3), B<mq_overview>(7)"
msgstr "B<mq_close>(3), B<mq_getattr>(3), B<mq_notify>(3), B<mq_receive>(3), B<mq_send>(3), B<mq_unlink>(3), B<mq_overview>(7)"

#. type: TH
#: man-pages/man3/modf.3:33
#, no-wrap
msgid "MODF"
msgstr "MODF"

#. type: Plain text
#: man-pages/man3/modf.3:37
msgid ""
"modf, modff, modfl - extract signed integral and fractional values from "
"floating-point number"
msgstr "modf, modff, modfl - извлекает целое и дробное значение со знаком из числа с плавающей запятой"

#. type: Plain text
#: man-pages/man3/modf.3:44
#, no-wrap
msgid ""
"B<double modf(double >I<x>B<, double *>I<iptr>B<);>\n"
"B<float modff(float >I<x>B<, float *>I<iptr>B<);>\n"
"B<long double modfl(long double >I<x>B<, long double *>I<iptr>B<);>\n"
msgstr "B<double modf(double >I<x>B<, double *>I<iptr>B<);>\nB<float modff(float >I<x>B<, float *>I<iptr>B<);>\nB<long double modfl(long double >I<x>B<, long double *>I<iptr>B<);>\n"

#. type: Plain text
#: man-pages/man3/modf.3:56
msgid "B<modf>(), B<modfl>():"
msgstr "B<modf>(), B<modfl>():"

#. type: Plain text
#: man-pages/man3/modf.3:60
#, no-wrap
msgid ""
"_ISOC99_SOURCE || _POSIX_C_SOURCE\\ E<gt>=\\ 200112L\n"
"    || /* Since glibc 2.19: */ _DEFAULT_SOURCE\n"
"    || /* Glibc versions E<lt>= 2.19: */ _BSD_SOURCE || _SVID_SOURCE\n"
msgstr "_ISOC99_SOURCE || _POSIX_C_SOURCE\\ E<gt>=\\ 200112L\n    || /* начиная с glibc 2.19: */ _DEFAULT_SOURCE\n    || /* версии glibc E<lt>= 2.19: */ _BSD_SOURCE || _SVID_SOURCE\n"

#. type: Plain text
#: man-pages/man3/modf.3:70
msgid ""
"These functions break the argument I<x> into an integral part and a "
"fractional part, each of which has the same sign as I<x>.  The integral part"
" is stored in the location pointed to by I<iptr>."
msgstr "Эти функции разбивают аргумент I<x> на целую и дробную части, каждая из которых имеет такой же знак, как и I<x>. Целая часть сохраняется месте, на которое указывает I<iptr>."

#. type: Plain text
#: man-pages/man3/modf.3:73
msgid "These functions return the fractional part of I<x>."
msgstr "Данные функции возвращают дробную часть от I<x>."

#. type: Plain text
#: man-pages/man3/modf.3:79
msgid "If I<x> is a NaN, a NaN is returned, and I<*iptr> is set to a NaN."
msgstr "Если I<x> имеет значение NaN, будет возвращено NaN и I<*iptr> установится в NaN."

#. type: Plain text
#: man-pages/man3/modf.3:85
msgid ""
"If I<x> is positive infinity (negative infinity), +0 (-0) is returned, and "
"I<*iptr> is set to positive infinity (negative infinity)."
msgstr "Если I<x> стремится к плюс или минус бесконечности, будет возвращено значение +0 (-0) и I<*iptr> установится в плюс или минус бесконечность."

#. type: Plain text
#: man-pages/man3/modf.3:87
msgid "No errors occur."
msgstr "Ошибки не возникают."

#. type: tbl table
#: man-pages/man3/modf.3:99
#, no-wrap
msgid ""
"B<modf>(),\n"
"B<modff>(),\n"
"B<modfl>()"
msgstr "B<modf>(),\nB<modff>(),\nB<modfl>()"

#. type: Plain text
#: man-pages/man3/modf.3:103
msgid "C99, POSIX.1-2001, POSIX.1-2008."
msgstr "C99, POSIX.1-2001, POSIX.1-2008."

#. type: Plain text
#: man-pages/man3/modf.3:108
msgid "The variant returning I<double> also conforms to SVr4, 4.3BSD, C89."
msgstr "Вариант, возвращающий значение типа I<double>, также соответствует SVr4, 4.3BSD, C89."

#. type: Plain text
#: man-pages/man3/modf.3:110
msgid "B<frexp>(3), B<ldexp>(3)"
msgstr "B<frexp>(3), B<ldexp>(3)"

#. type: TH
#: man-pages/man3/mbrlen.3:16
#, no-wrap
msgid "MBRLEN"
msgstr "MBRLEN"

#. type: Plain text
#: man-pages/man3/mbrlen.3:19
msgid "mbrlen - determine number of bytes in next multibyte character"
msgstr "mbrlen - вычисляет количество байт в следующем многобайтовом символе"

#. type: Plain text
#: man-pages/man3/mbrlen.3:24
#, no-wrap
msgid ""
"B<size_t mbrlen(const char *>I<s>B<, size_t >I<n>B<, mbstate_t "
"*>I<ps>B<);>\n"
msgstr "B<size_t mbrlen(const char *>I<s>B<, size_t >I<n>B<, mbstate_t *>I<ps>B<);>\n"

#. type: Plain text
#: man-pages/man3/mbrlen.3:43
msgid ""
"The B<mbrlen>()  function inspects at most I<n> bytes of the multibyte "
"string starting at I<s> and extracts the next complete multibyte character."
"  It updates the shift state I<*ps>.  If the multibyte character is not the "
"null wide character, it returns the number of bytes that were consumed from "
"I<s>.  If the multibyte character is the null wide character, it resets the "
"shift state I<*ps> to the initial state and returns 0."
msgstr "Функция B<mbrlen>() просматривает не более I<n> байт в многобайтовой строке, начинающейся с I<s> и извлекает следующий полный многобайтовый символ. Она изменяет состояние сдвига I<*ps>. Если многобайтовый символ не является широким символом null, то возвращается количество байт, которые использовались из I<s>. Если многобайтовый символ является широким символом null, состояние сдвига I<*ps> сбрасывается в начальное и возвращается 0."

#. type: Plain text
#: man-pages/man3/mbrlen.3:59
msgid ""
"If the I<n> bytes starting at I<s> do not contain a complete multibyte "
"character, B<mbrlen>()  returns I<(size_t)\\ -2>.  This can happen even if "
"I<n> E<gt>= I<MB_CUR_MAX>, if the multibyte string contains redundant shift "
"sequences."
msgstr "Если в I<n> байтах, начиная с I<s>, не содержится полного многобайтового символа, то B<mbrlen>() возвращает I<(size_t)\\ -2>. Это может произойти даже, если I<n> E<gt>= I<MB_CUR_MAX>, если в многобайтовой строке содержится лишние сдвиговые последовательности."

#. type: Plain text
#: man-pages/man3/mbrlen.3:75
msgid ""
"If the multibyte string starting at I<s> contains an invalid multibyte "
"sequence before the next complete character, B<mbrlen>()  returns "
"I<(size_t)\\ -1> and sets I<errno> to B<EILSEQ>.  In this case, the effects "
"on I<*ps> are undefined."
msgstr "Если многобайтовая строка, начинающаяся с I<s>, содержит некорректную многобайтовую последовательность до следующего полного символа, то B<mbrlen>() возвращает I<(size_t)\\ -1> и присваивает I<errno> значение B<EILSEQ>. В этом случае влияние на I<*ps> не определено."

#. type: Plain text
#: man-pages/man3/mbrlen.3:81
msgid ""
"If I<ps> is NULL, a static anonymous state known only to the B<mbrlen>()  "
"function is used instead."
msgstr "Если I<ps> равно NULL, то используется статическое анонимное состояние, известное только функции B<mbrlen>()."

#. type: Plain text
#: man-pages/man3/mbrlen.3:104
msgid ""
"The B<mbrlen>()  function returns the number of bytes parsed from the "
"multibyte sequence starting at I<s>, if a non-null wide character was "
"recognized.  It returns 0, if a null wide character was recognized.  It "
"returns I<(size_t)\\ -1> and sets I<errno> to B<EILSEQ>, if an invalid "
"multibyte sequence was encountered.  It returns I<(size_t)\\ -2> if it "
"couldn't parse a complete multibyte character, meaning that I<n> should be "
"increased."
msgstr "Функция B<mbrlen>() возвращает количество байт, просмотренных в многобайтовой последовательности, начинающейся с I<s>, если при этом был получен широкий символ не равный null. Она возвращает 0, если был получен широкий символ null. Она возвращает I<(size_t)\\ -1> и присваивает I<errno> значение B<EILSEQ>, если встречена некорректная многобайтовая последовательность. Она возвращает I<(size_t)\\ -2>, если не удалось найти полную многобайтовую последовательность, что означает, что I<n> должно быть увеличено."

#. type: tbl table
#: man-pages/man3/mbrlen.3:114
#, no-wrap
msgid "B<mbrlen>()"
msgstr "B<mbrlen>()"

#. type: tbl table
#: man-pages/man3/mbrlen.3:114
#, no-wrap
msgid "MT-Unsafe race:mbrlen/!ps"
msgstr "MT-Unsafe race:mbrlen/!ps"

#. type: Plain text
#: man-pages/man3/mbrlen.3:125
msgid ""
"The behavior of B<mbrlen>()  depends on the B<LC_CTYPE> category of the "
"current locale."
msgstr "Поведение B<mbrlen>() зависит от категории B<LC_CTYPE> текущей локали."

#. type: Plain text
#: man-pages/man3/mbrlen.3:126
msgid "B<mbrtowc>(3)"
msgstr "B<mbrtowc>(3)"

#. type: TH
#: man-pages/man3/memcpy.3:31
#, no-wrap
msgid "MEMCPY"
msgstr "MEMCPY"

#. type: Plain text
#: man-pages/man3/memcpy.3:34
msgid "memcpy - copy memory area"
msgstr "memcpy - копирует участок памяти"

#. type: Plain text
#: man-pages/man3/memcpy.3:39
#, no-wrap
msgid ""
"B<void *memcpy(void *>I<dest>B<, const void *>I<src>B<, size_t >I<n>B<);>\n"
msgstr "B<void *memcpy(void *>I<dest>B<, const void *>I<src>B<, size_t >I<n>B<);>\n"

#. type: Plain text
#: man-pages/man3/memcpy.3:49
msgid ""
"The B<memcpy>()  function copies I<n> bytes from memory area I<src> to "
"memory area I<dest>.  The memory areas must not overlap.  Use B<memmove>(3)"
"  if the memory areas do overlap."
msgstr "Функция B<memcpy>() копирует I<n> байт из участка памяти I<src> в участок памяти I<dest>. Адреса участков памяти не должны перекрываться друг другом. Если это неизбежно, используйте B<memmove>(3)."

#. type: Plain text
#: man-pages/man3/memcpy.3:53
msgid "The B<memcpy>()  function returns a pointer to I<dest>."
msgstr "Функция B<memcpy>() возвращает указатель на I<dest>."

#. type: tbl table
#: man-pages/man3/memcpy.3:63
#, no-wrap
msgid "B<memcpy>()"
msgstr "B<memcpy>()"

#.  glibc commit 6fb8cbcb58a29fff73eb2101b34caa19a7f88eba
#.  From forward copying to backward copying
#. type: Plain text
#: man-pages/man3/memcpy.3:83
msgid ""
"Failure to observe the requirement that the memory areas do not overlap has "
"been the source of significant bugs.  (POSIX and the C standards are "
"explicit that employing B<memcpy>()  with overlapping areas produces "
"undefined behavior.)  Most notably, in glibc 2.13 a performance optimization"
" of B<memcpy>()  on some platforms (including x86-64) included changing the "
"order in which bytes were copied from I<src> to I<dest>."
msgstr "Несоблюдение требования не перекрытия областей памяти является источником серьёзных ошибок (в стандартах POSIX и C явно указано, что выполнение B<memcpy>() над перекрывающимися областями приводит к непредсказуемому поведению). Что особенно важно, в glibc 2.13 для оптимизации производительности B<memcpy>() на некоторых платформах (включая x86-64) изменён порядок копирования байт из I<src> в I<dest>."

#.  Adobe Flash player was the highest profile example:
#.    https://bugzilla.redhat.com/show_bug.cgi?id=638477
#.    Reported: 2010-09-29 02:35 EDT by JCHuynh
#.    Bug 638477 - Strange sound on mp3 flash website
#.    https://sourceware.org/bugzilla/show_bug.cgi?id=12518
#.    Bug 12518 - memcpy acts randomly (and differently) with overlapping
#. areas
#.    Reported:       2011-02-25 02:26 UTC by Linus Torvalds
#.  glibc commit 0354e355014b7bfda32622e0255399d859862fcd
#. type: Plain text
#: man-pages/man3/memcpy.3:109
msgid ""
"This change revealed breakages in a number of applications that performed "
"copying with overlapping areas.  Under the previous implementation, the "
"order in which the bytes were copied had fortuitously hidden the bug, which "
"was revealed when the copying order was reversed.  In glibc 2.14, a "
"versioned symbol was added so that old binaries (i.e., those linked against "
"glibc versions earlier than 2.14)  employed a B<memcpy>()  implementation "
"that safely handles the overlapping buffers case (by providing an \"older\" "
"B<memcpy>()  implementation that was aliased to B<memmove>(3))."
msgstr "Это изменение привело к поломкам многих приложений, которые выполняли копирование перекрывающихся областей. В предыдущей реализации порядок, в котором копировались байты, случайно скрывал ошибку, который выявилась при изменении порядка копирования. В glibc 2.14 был добавлен символ версии для того, чтобы старые двоичные файлы (т.е., скомпонованные с версиями glibc до 2.14) вызывали реализацию B<memcpy>(), которая безопасно обрабатывает случай перекрывающихся буферов (предоставляя «старую» реализацию B<memcpy>(), которая была просто ещё одним именем B<memmove>(3))."

#. type: Plain text
#: man-pages/man3/memcpy.3:117
msgid ""
"B<bcopy>(3), B<bstring>(3), B<memccpy>(3), B<memmove>(3), B<mempcpy>(3), "
"B<strcpy>(3), B<strncpy>(3), B<wmemcpy>(3)"
msgstr "B<bcopy>(3), B<bstring>(3), B<memccpy>(3), B<memmove>(3), B<mempcpy>(3), B<strcpy>(3), B<strncpy>(3), B<wmemcpy>(3)"

#. type: TH
#: man-pages/man3/memchr.3:32
#, no-wrap
msgid "MEMCHR"
msgstr "MEMCHR"

#. type: Plain text
#: man-pages/man3/memchr.3:35
msgid "memchr, memrchr, rawmemchr - scan memory for a character"
msgstr "memchr, memrchr, rawmemchr - выполняют поиск символа в памяти"

#. type: Plain text
#: man-pages/man3/memchr.3:40
#, no-wrap
msgid "B<void *memchr(const void *>I<s>B<, int >I<c>B<, size_t >I<n>B<);>\n"
msgstr "B<void *memchr(const void *>I<s>B<, int >I<c>B<, size_t >I<n>B<);>\n"

#. type: Plain text
#: man-pages/man3/memchr.3:42
#, no-wrap
msgid "B<void *memrchr(const void *>I<s>B<, int >I<c>B<, size_t >I<n>B<);>\n"
msgstr "B<void *memrchr(const void *>I<s>B<, int >I<c>B<, size_t >I<n>B<);>\n"

#. type: Plain text
#: man-pages/man3/memchr.3:44
#, no-wrap
msgid "B<void *rawmemchr(const void *>I<s>B<, int >I<c>B<);>\n"
msgstr "B<void *rawmemchr(const void *>I<s>B<, int >I<c>B<);>\n"

#. type: Plain text
#: man-pages/man3/memchr.3:54
msgid "B<memrchr>(), B<rawmemchr>(): _GNU_SOURCE"
msgstr "B<memrchr>(), B<rawmemchr>(): _GNU_SOURCE"

#. type: Plain text
#: man-pages/man3/memchr.3:70
msgid ""
"The B<memchr>()  function scans the initial I<n> bytes of the memory area "
"pointed to by I<s> for the first instance of I<c>.  Both I<c> and the bytes "
"of the memory area pointed to by I<s> are interpreted as I<unsigned char>."
msgstr "Функция B<memchr>() сканирует первые I<n> байт участка памяти, указанного в I<s>, в поисках экземпляра I<c>. Считается, что байты в памяти, указанной I<s>, и значение I<c> имеют тип I<unsigned char>."

#. type: Plain text
#: man-pages/man3/memchr.3:81
msgid ""
"The B<memrchr>()  function is like the B<memchr>()  function, except that it"
" searches backward from the end of the I<n> bytes pointed to by I<s> instead"
" of forward from the beginning."
msgstr "Функция B<memrchr>() похожа на B<memchr>(), за исключением того, что она ищет в участке I<n> байт, указанных в I<s>, не сначала, а с конца."

#. type: Plain text
#: man-pages/man3/memchr.3:99
msgid ""
"The B<rawmemchr>()  function is similar to B<memchr>(): it assumes (i.e., "
"the programmer knows for certain)  that an instance of I<c> lies somewhere "
"in the memory area starting at the location pointed to by I<s>, and so "
"performs an optimized search for I<c> (i.e., no use of a count argument to "
"limit the range of the search).  If an instance of I<c> is not found, the "
"results are unpredictable.  The following call is a fast means of locating a"
" string's terminating null byte:"
msgstr "Функция B<rawmemchr>() похожа на B<memchr>(): она подразумевает (то есть программист в этом уверен), что экземпляр I<c> точно находится где-то в памяти начало которой указано I<s>, и при это производит оптимизированный поиск символа I<c> (то есть, не используется счётчик для ограничения диапазона поиска). Если экземпляр I<c> не найден, то результат непредсказуем. Следующий вызов является примером быстрого поиска завершающего строку байта null:"

#. type: Plain text
#: man-pages/man3/memchr.3:103
#, no-wrap
msgid "char *p = rawmemchr(s,\\ \\(aq\\e0\\(aq);\n"
msgstr "char *p = rawmemchr(s,\\ \\(aq\\e0\\(aq);\n"

#. type: Plain text
#: man-pages/man3/memchr.3:113
msgid ""
"The B<memchr>()  and B<memrchr>()  functions return a pointer to the "
"matching byte or NULL if the character does not occur in the given memory "
"area."
msgstr "Функции B<memchr>() и B<memrchr>() возвращают указатель на совпавший байт, либо NULL, если в указанном участке памяти искомого байта нет."

#. type: Plain text
#: man-pages/man3/memchr.3:118
msgid ""
"The B<rawmemchr>()  function returns a pointer to the matching byte, if one "
"is found.  If no matching byte is found, the result is unspecified."
msgstr "Функция B<rawmemchr>() возвращает указатель на совпавший байт (если он был обнаружен). Если совпадений не найдено, результат не определён."

#. type: Plain text
#: man-pages/man3/memchr.3:121
msgid "B<rawmemchr>()  first appeared in glibc in version 2.1."
msgstr "Функция B<rawmemchr>() впервые появилась в glibc 2.1."

#. type: Plain text
#: man-pages/man3/memchr.3:124
msgid "B<memrchr>()  first appeared in glibc in version 2.2."
msgstr "Функция B<memrchr>() впервые появилась в glibc 2.2."

#. type: tbl table
#: man-pages/man3/memchr.3:136
#, no-wrap
msgid ""
"B<memchr>(),\n"
"B<memrchr>(),\n"
"B<rawmemchr>()"
msgstr "B<memchr>(),\nB<memrchr>(),\nB<rawmemchr>()"

#. type: Plain text
#: man-pages/man3/memchr.3:141
msgid "B<memchr>(): POSIX.1-2001, POSIX.1-2008, C89, C99, SVr4, 4.3BSD."
msgstr "B<memchr>(): POSIX.1-2001, POSIX.1-2008, C89, C99, SVr4, 4.3BSD."

#. type: Plain text
#: man-pages/man3/memchr.3:145
msgid ""
"The B<memrchr>()  function is a GNU extension, available since glibc 2.1.91."
msgstr "Функция B<memrchr>() является расширением GNU, доступным в glibc начиная с версии 2.1.91."

#. type: Plain text
#: man-pages/man3/memchr.3:149
msgid ""
"The B<rawmemchr>()  function is a GNU extension, available since glibc 2.1."
msgstr "Функция B<rawmemchr>() является расширением GNU, доступным в glibc начиная с версии 2.1."

#. type: Plain text
#: man-pages/man3/memchr.3:161
msgid ""
"B<bstring>(3), B<ffs>(3), B<index>(3), B<memmem>(3), B<rindex>(3), "
"B<strchr>(3), B<strpbrk>(3), B<strrchr>(3), B<strsep>(3), B<strspn>(3), "
"B<strstr>(3), B<wmemchr>(3)"
msgstr "B<bstring>(3), B<ffs>(3), B<index>(3), B<memmem>(3), B<rindex>(3), B<strchr>(3), B<strpbrk>(3), B<strrchr>(3), B<strsep>(3), B<strspn>(3), B<strstr>(3), B<wmemchr>(3)"

#. type: TH
#: man-pages/man3/mbsnrtowcs.3:15
#, no-wrap
msgid "MBSNRTOWCS"
msgstr "MBSNRTOWCS"

#. type: Plain text
#: man-pages/man3/mbsnrtowcs.3:18
msgid "mbsnrtowcs - convert a multibyte string to a wide-character string"
msgstr "mbsnrtowcs - преобразует многобайтовую строку в строку широких символов"

#. type: Plain text
#: man-pages/man3/mbsnrtowcs.3:24
#, no-wrap
msgid ""
"B<size_t mbsnrtowcs(wchar_t *>I<dest>B<, const char **>I<src>B<,>\n"
"B<                  size_t >I<nms>B<, size_t >I<len>B<, mbstate_t *>I<ps>B<);>\n"
msgstr "B<size_t mbsnrtowcs(wchar_t *>I<dest>B<, const char **>I<src>B<,>\nB<                  size_t >I<nms>B<, size_t >I<len>B<, mbstate_t *>I<ps>B<);>\n"

#. type: Plain text
#: man-pages/man3/mbsnrtowcs.3:32
msgid "B<mbsnrtowcs>():"
msgstr "B<mbsnrtowcs>():"

#. type: Plain text
#: man-pages/man3/mbsnrtowcs.3:41
msgid "_GNU_SOURCE"
msgstr "_GNU_SOURCE"

#. type: Plain text
#: man-pages/man3/mbsnrtowcs.3:55
msgid ""
"The B<mbsnrtowcs>()  function is like the B<mbsrtowcs>(3)  function, except "
"that the number of bytes to be converted, starting at I<*src>, is limited to"
" at most I<nms> bytes."
msgstr "Функция B<mbsnrtowcs>() похожа на функцию B<mbsrtowcs>(3), исключая то, что количество преобразуемых байт, начиная с I<*src>, ограничено I<nms> байтами."

#. type: Plain text
#: man-pages/man3/mbsnrtowcs.3:88
msgid ""
"If I<dest> is not NULL, the B<mbsnrtowcs>()  function converts at most "
"I<nms> bytes from the multibyte string I<*src> to a wide-character string "
"starting at I<dest>.  At most I<len> wide characters are written to I<dest>."
"  The shift state I<*ps> is updated.  The conversion is effectively "
"performed by repeatedly calling I<mbrtowc(dest, *src, n, ps)> where I<n> is "
"some positive number, as long as this call succeeds, and then incrementing "
"I<dest> by one and I<*src> by the number of bytes consumed.  The conversion "
"can stop for three reasons:"
msgstr "Если I<dest> не равно NULL, то функция B<mbsnrtowcs>() преобразует не более I<nms> байт многобайтовой строки I<*src> в строку широких символов, начинающуюся с I<dest>. В I<dest> будет записано не более I<len> символов. Обновляется состояние сдвига I<*ps>. Эффективное выполнение преобразования осуществляется повторяющимися вызовами I<mbrtowc(dest, *src, n, ps)>, где I<n> — некое положительное число, и пока вызов завершается успешно, увеличивая I<dest> на единицу и I<*src> на количество использованных байт. Преобразование может остановиться по трём причинам:"

#. type: Plain text
#: man-pages/man3/mbsnrtowcs.3:115
msgid ""
"The I<nms> limit forces a stop, or I<len> non-L\\(aq\\e0\\(aq wide "
"characters have been stored at I<dest>.  In this case, I<*src> is left "
"pointing to the next multibyte sequence to be converted, and the number of "
"wide characters written to I<dest> is returned."
msgstr "Остановка происходит, если достигнуто ограничение I<nms> или в I<dest> было сохранено I<len> не равных L\\(aq\\e0\\(aq широких символов. В этом случае I<*src> продолжит указывать на следующую непреобразованную многобайтовую последовательность и будет возвращено количество широких символов, записанных в I<dest>."

#. type: Plain text
#: man-pages/man3/mbsnrtowcs.3:129
msgid ""
"The multibyte string has been completely converted, including the "
"terminating null wide character (\\(aq\\e0\\(aq)  (which has the side effect"
" of bringing back I<*ps> to the initial state).  In this case, I<*src> is "
"set to NULL, and the number of wide characters written to I<dest>, excluding"
" the terminating null wide character, is returned."
msgstr "Многобайтовая строка была полностью преобразована, включая завершающий широкий символ null (\\(aq\\e0\\(aq) (побочный эффект: I<*ps> возвращается в начальное состояние). В этом случае I<*src> устанавливается равным NULL и возвращается количество широких символов, записанных в I<dest>, не считая завершающего широкого символа null."

#. type: Plain text
#: man-pages/man3/mbsnrtowcs.3:135
msgid ""
"According to POSIX.1, if the input buffer ends with an incomplete character,"
" it is unspecified whether conversion stops at the end of the previous "
"character (if any), or at the end of the input buffer.  The glibc "
"implementation adopts the former behavior."
msgstr "Если входной буфер заканчивается неполным символом, в POSIX.1 не указано где остановится преобразование — в конце предыдущего символа (если есть) или в конце входного буфера. В реализации glibc принят первый вариант."

#. type: Plain text
#: man-pages/man3/mbsnrtowcs.3:144
msgid ""
"If I<dest> is NULL, I<len> is ignored, and the conversion proceeds as above,"
" except that the converted wide characters are not written out to memory, "
"and that no destination length limit exists."
msgstr "Если значение I<dest> равно NULL, то I<len> игнорируется и преобразование выполняется как описано выше, исключая то, что преобразованные широкие символы не записываются в память и нет ограничения на длину строки назначения."

#. type: Plain text
#: man-pages/man3/mbsnrtowcs.3:151
msgid ""
"In both of the above cases, if I<ps> is NULL, a static anonymous state known"
" only to the B<mbsnrtowcs>()  function is used instead."
msgstr "В обоих перечисленных случаях, если I<ps> равно NULL, то используется статическое анонимное состояние, известное только функции B<mbsnrtowcs>()."

#. type: Plain text
#: man-pages/man3/mbsnrtowcs.3:170
msgid ""
"The B<mbsnrtowcs>()  function returns the number of wide characters that "
"make up the converted part of the wide-character string, not including the "
"terminating null wide character.  If an invalid multibyte sequence was "
"encountered, I<(size_t)\\ -1> is returned, and I<errno> set to B<EILSEQ>."
msgstr "Функция B<mbsnrtowcs>() возвращает количество широких символов, которые составили преобразованную часть широкосимвольной строки, не включая конечный широкий символ null. Если обнаружена некорректная многобайтовая последовательность, то возвращается I<(size_t)\\ -1>, а I<errno> присваивается B<EILSEQ>."

#. type: tbl table
#: man-pages/man3/mbsnrtowcs.3:180
#, no-wrap
msgid "B<mbsnrtowcs>()"
msgstr "B<mbsnrtowcs>()"

#. type: tbl table
#: man-pages/man3/mbsnrtowcs.3:180
#, no-wrap
msgid "MT-Unsafe race:mbsnrtowcs/!ps"
msgstr "MT-Unsafe race:mbsnrtowcs/!ps"

#. type: Plain text
#: man-pages/man3/mbsnrtowcs.3:185
msgid "POSIX.1-2008."
msgstr "POSIX.1-2008."

#. type: Plain text
#: man-pages/man3/mbsnrtowcs.3:192
msgid ""
"The behavior of B<mbsnrtowcs>()  depends on the B<LC_CTYPE> category of the "
"current locale."
msgstr "Поведение B<mbsnrtowcs>() зависит от категории B<LC_CTYPE> текущей локали."

#. type: Plain text
#: man-pages/man3/mbsnrtowcs.3:200
msgid "B<iconv>(3), B<mbrtowc>(3)  B<mbsinit>(3), B<mbsrtowcs>(3)"
msgstr "B<iconv>(3), B<mbrtowc>(3)  B<mbsinit>(3), B<mbsrtowcs>(3)"

#. type: TH
#: man-pages/man3/malloc_get_state.3:25
#, no-wrap
msgid "MALLOC_GET_STATE"
msgstr "MALLOC_GET_STATE"

#. type: Plain text
#: man-pages/man3/malloc_get_state.3:28
msgid ""
"malloc_get_state, malloc_set_state - record and restore state of malloc "
"implementation"
msgstr "malloc_get_state, malloc_set_state - сохраняют и восстанавливают состояние в реализации malloc"

#. type: Plain text
#: man-pages/man3/malloc_get_state.3:33
#, no-wrap
msgid "B<void* malloc_get_state(void);>\n"
msgstr "B<void* malloc_get_state(void);>\n"

#. type: Plain text
#: man-pages/man3/malloc_get_state.3:35
#, no-wrap
msgid "B<int malloc_set_state(void *>I<state>B<);>\n"
msgstr "B<int malloc_set_state(void *>I<state>B<);>\n"

#. type: Plain text
#: man-pages/man3/malloc_get_state.3:39
msgid "I<Note>: these function are removed in glibc version 2.25."
msgstr "I<Примечание>: эта функция была удалена в glibc версии 2.25."

#. type: Plain text
#: man-pages/man3/malloc_get_state.3:56
msgid ""
"The B<malloc_get_state>()  function records the current state of all "
"B<malloc>(3)  internal bookkeeping variables (but not the actual contents of"
" the heap or the state of B<malloc_hook>(3)  functions pointers).  The state"
" is recorded in a system-dependent opaque data structure dynamically "
"allocated via B<malloc>(3), and a pointer to that data structure is returned"
" as the function result.  (It is the caller's responsibility to B<free>(3)  "
"this memory.)"
msgstr "Функция B<malloc_get_state>() записывает текущее состояние всех внутренних служебных переменных B<malloc>(3) (но не фактическое содержимое кучи или состояние указателей функций B<malloc_hook>(3)). Состояние сохраняется в системно-зависимой структуре данных с закрытым форматом, динамически выделенной через B<malloc>(3), и указатель на эту структуру данных возвращается как результат функции (вызывающий является ответственным за вызов B<free>(3) для этой памяти)."

#. type: Plain text
#: man-pages/man3/malloc_get_state.3:64
msgid ""
"The B<malloc_set_state>()  function restores the state of all B<malloc>(3)  "
"internal bookkeeping variables to the values recorded in the opaque data "
"structure pointed to by I<state>."
msgstr "Функция B<malloc_set_state>()  восстанавливает значения состояния внутренних служебных переменных B<malloc>(3) из сохранённой структуры закрытого формата, на которую указывает I<state>."

#. type: Plain text
#: man-pages/man3/malloc_get_state.3:71
msgid ""
"On success, B<malloc_get_state>()  returns a pointer to a newly allocated "
"opaque data structure.  On error (for example, memory could not be allocated"
" for the data structure), B<malloc_get_state>()  returns NULL."
msgstr "При успешном выполнении B<malloc_get_state>() возвращает указатель на только что выделенную структуру с закрытым форматом. При ошибке (например, если не получилось выделить память под структуру) B<malloc_get_state>() возвращает NULL."

#.  if(ms->magic != MALLOC_STATE_MAGIC) return -1;
#.  /* Must fail if the major version is too high. */
#.  if((ms->version & ~0xffl) > (MALLOC_STATE_VERSION & ~0xffl)) return -2;
#. type: Plain text
#: man-pages/man3/malloc_get_state.3:89
msgid ""
"On success, B<malloc_set_state>()  returns 0.  If the implementation detects"
" that I<state> does not point to a correctly formed data structure, "
"B<malloc_set_state>()  returns -1.  If the implementation detects that the "
"version of the data structure referred to by I<state> is a more recent "
"version than this implementation knows about, B<malloc_set_state>()  returns"
" -2."
msgstr "При успешном выполнении B<malloc_set_state>() возвращается 0. Если реализация обнаруживает, что I<state> не указывает на корректную структуру с данными, то B<malloc_set_state>() возвращает -1. Если реализация обнаруживает, что версия структуры данных, на которую ссылается I<state>, новее чем известно реализации, то B<malloc_set_state>() возвращает -2."

#. type: tbl table
#: man-pages/man3/malloc_get_state.3:100
#, no-wrap
msgid ""
"B<malloc_get_state>(),\n"
"B<malloc_set_state>()"
msgstr "B<malloc_get_state>(),\nB<malloc_set_state>()"

#. type: Plain text
#: man-pages/man3/malloc_get_state.3:111
msgid ""
"These functions are useful when using this B<malloc>(3)  implementation as "
"part of a shared library, and the heap contents are saved/restored via some "
"other method.  This technique is used by GNU Emacs to implement its "
"\"dumping\" function."
msgstr "Эти функции полезны при использовании реализации B<malloc>(3) в виде общей библиотеки, а содержимое кучи сохраняется/восстанавливается каким-то другим способом. Это используется в GNU Emacs для реализации своей функции «выгрузки»."

#.  i.e., calls __malloc_check_init()
#.  i.e., malloc checking is not already in use
#.  and the caller requested malloc checking
#. type: Plain text
#: man-pages/man3/malloc_get_state.3:128
msgid ""
"Hook function pointers are never saved or restored by these functions, with "
"two exceptions: if malloc checking (see B<mallopt>(3))  was in use when "
"B<malloc_get_state>()  was called, then B<malloc_set_state>()  resets malloc"
" checking hooks if possible; if malloc checking was not in use in the "
"recorded state, but the caller has requested malloc checking, then the hooks"
" are reset to 0."
msgstr "Эти функции никогда не сохраняют и не восстанавливают указатели на перехватывающие функции, но есть два исключения: если вызваны проверки malloc (смотрите B<mallopt>(3)), то, если возможно, B<malloc_get_state>() сбрасывает проверки malloc перехватывающих функций; если проверки malloc не используются в сохранённом состоянии, но вызывающий их запросил, то перехватывающие функции сбрасываются в 0."

#. type: Plain text
#: man-pages/man3/malloc_get_state.3:130
msgid "B<malloc>(3), B<mallopt>(3)"
msgstr "B<malloc>(3), B<mallopt>(3)"

#. type: TH
#: man-pages/man3/malloc_hook.3:10
#, no-wrap
msgid "MALLOC_HOOK"
msgstr "MALLOC_HOOK"

#. type: Plain text
#: man-pages/man3/malloc_hook.3:15
msgid ""
"__malloc_hook, __malloc_initialize_hook, __memalign_hook, __free_hook, "
"__realloc_hook, __after_morecore_hook - malloc debugging variables"
msgstr "__malloc_hook, __malloc_initialize_hook, __memalign_hook, __free_hook, __realloc_hook, __after_morecore_hook - переменные отладки malloc"

#. type: Plain text
#: man-pages/man3/malloc_hook.3:20
#, no-wrap
msgid ""
"B<void *(*__malloc_hook)(size_t >I<size>B<, const void *>I<caller>B<);>\n"
msgstr "B<void *(*__malloc_hook)(size_t >I<size>B<, const void *>I<caller>B<);>\n"

#. type: Plain text
#: man-pages/man3/malloc_hook.3:23
#, no-wrap
msgid ""
"B<void *(*__realloc_hook)(void *>I<ptr>B<, size_t >I<size>B<, const void "
"*>I<caller>B<);>\n"
msgstr "B<void *(*__realloc_hook)(void *>I<ptr>B<, size_t >I<size>B<, const void *>I<caller>B<);>\n"

#. type: Plain text
#: man-pages/man3/malloc_hook.3:26
#, no-wrap
msgid ""
"B<void *(*__memalign_hook)(size_t >I<alignment>B<, size_t >I<size>B<,>\n"
"B<                         const void *>I<caller>B<);>\n"
msgstr "B<void *(*__memalign_hook)(size_t >I<alignment>B<, size_t >I<size>B<,>\nB<                         const void *>I<caller>B<);>\n"

#. type: Plain text
#: man-pages/man3/malloc_hook.3:28
#, no-wrap
msgid "B<void (*__free_hook)(void *>I<ptr>B<, const void *>I<caller>B<);>\n"
msgstr "B<void (*__free_hook)(void *>I<ptr>B<, const void *>I<caller>B<);>\n"

#. type: Plain text
#: man-pages/man3/malloc_hook.3:30
#, no-wrap
msgid "B<void (*__malloc_initialize_hook)(void);>\n"
msgstr "B<void (*__malloc_initialize_hook)(void);>\n"

#. type: Plain text
#: man-pages/man3/malloc_hook.3:32
#, no-wrap
msgid "B<void (*__after_morecore_hook)(void);>\n"
msgstr "B<void (*__after_morecore_hook)(void);>\n"

#. type: Plain text
#: man-pages/man3/malloc_hook.3:43
msgid ""
"The GNU C library lets you modify the behavior of B<malloc>(3), "
"B<realloc>(3), and B<free>(3)  by specifying appropriate hook functions.  "
"You can use these hooks to help you debug programs that use dynamic memory "
"allocation, for example."
msgstr "Библиотека GNU C позволяет изменить поведение B<malloc>(3), B<realoc>(3) и B<free>(3), указав соответствующие «обрабатывающие» (hook) функции. Вы можете использовать эти функции-обработчики для отладки программ, использующих динамическое выделение памяти."

#. type: Plain text
#: man-pages/man3/malloc_hook.3:50
msgid ""
"The variable B<__malloc_initialize_hook> points at a function that is called"
" once when the malloc implementation is initialized.  This is a weak "
"variable, so it can be overridden in the application with a definition like "
"the following:"
msgstr "Переменная B<__ malloc_initialize_hook> указывает на функцию, которая однократно вызывается при инициализации реализации malloc. Это — слабая переменная, поэтому она может быть переопределена в приложении как показано далее:"

#. type: Plain text
#: man-pages/man3/malloc_hook.3:54
#, no-wrap
msgid "void (*__malloc_initialize_hook)(void) = my_init_hook;\n"
msgstr "void (*__malloc_initialize_hook)(void) = my_init_hook;\n"

#. type: Plain text
#: man-pages/man3/malloc_hook.3:60
msgid ""
"Now the function I<my_init_hook>()  can do the initialization of all hooks."
msgstr "Теперь функция I<my_init_hook>() может проинициализировать все функции-обработчики."

#. type: Plain text
#: man-pages/man3/malloc_hook.3:76
msgid ""
"The four functions pointed to by B<__malloc_hook>, B<__realloc_hook>, "
"B<__memalign_hook>, B<__free_hook> have a prototype like the functions "
"B<malloc>(3), B<realloc>(3), B<memalign>(3), B<free>(3), respectively, "
"except that they have a final argument I<caller> that gives the address of "
"the caller of B<malloc>(3), etc."
msgstr "У четырёх функций, на которые указывают переменные B<__malloc_hook>, B<__realloc_hook>, B<__memalign_hook>, B<__free_hook>, имеются прототипы, подобные функциям B<malloc>(3), B<realloc>(3), B<memalign>(3), B<free>(3), соответственно, однако у них есть дополнительный последний параметр I<caller>, в который передаётся адрес вызывающего B<malloc>(3) и т.д."

#. type: Plain text
#: man-pages/man3/malloc_hook.3:82
msgid ""
"The variable B<__after_morecore_hook> points at a function that is called "
"each time after B<sbrk>(2)  was asked for more memory."
msgstr "Переменная B<__ after_morecore_hook> указывает на функцию, которая вызывается каждый раз после того, как B<sbrk>(2) просят увеличить память."

#.  https://bugzilla.redhat.com/show_bug.cgi?id=450187
#.  http://sourceware.org/bugzilla/show_bug.cgi?id=9957
#. type: Plain text
#: man-pages/man3/malloc_hook.3:94
msgid ""
"The use of these hook functions is not safe in multithreaded programs, and "
"they are now deprecated.  From glibc 2.24 onwards, the "
"B<__malloc_initialize_hook> variable has been removed from the API.  "
"Programmers should instead preempt calls to the relevant functions by "
"defining and exporting functions such as \"malloc\" and \"free\"."
msgstr "Использование этих обрабатывающих функций не безопасно в многонитевых программах, и теперь они считаются устаревшими. Начиная с glibc версии 2.24, переменная B<__ malloc_initialize_hook>  была удалена из программного интерфейса. Теперь вместо неё программисты должны подменять вызовы соответствующих функций, определяя и экспортируя такие функции как «malloc» и «free»."

#. type: Plain text
#: man-pages/man3/malloc_hook.3:96
msgid "Here is a short example of how to use these variables."
msgstr "Вот короткий пример того, как использовать эти переменные."

#. type: Plain text
#: man-pages/man3/malloc_hook.3:100
#, no-wrap
msgid ""
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>malloc.hE<gt>\n"
msgstr "#include E<lt>stdio.hE<gt>\n#include E<lt>malloc.hE<gt>\n"

#. type: Plain text
#: man-pages/man3/malloc_hook.3:104
#, no-wrap
msgid ""
"/* Prototypes for our hooks.  */\n"
"static void my_init_hook(void);\n"
"static void *my_malloc_hook(size_t, const void *);\n"
msgstr "/* прототипы наших функций */\nstatic void my_init_hook(void);\nstatic void *my_malloc_hook(size_t, const void *);\n"

#. type: Plain text
#: man-pages/man3/malloc_hook.3:107
#, no-wrap
msgid ""
"/* Variables to save original hooks. */\n"
"static void *(*old_malloc_hook)(size_t, const void *);\n"
msgstr "/* переменные для сохранения имеющихся обрабатывающих функций */\nstatic void *(*old_malloc_hook)(size_t, const void *);\n"

#. type: Plain text
#: man-pages/man3/malloc_hook.3:110
#, no-wrap
msgid ""
"/* Override initializing hook from the C library. */\n"
"void (*__malloc_initialize_hook) (void) = my_init_hook;\n"
msgstr "/* переопределяем первоначальные функции библиотеки C */\nvoid (*__malloc_initialize_hook) (void) = my_init_hook;\n"

#. type: Plain text
#: man-pages/man3/malloc_hook.3:117
#, no-wrap
msgid ""
"static void\n"
"my_init_hook(void)\n"
"{\n"
"    old_malloc_hook = __malloc_hook;\n"
"    __malloc_hook = my_malloc_hook;\n"
"}\n"
msgstr "static void\nmy_init_hook(void)\n{\n    old_malloc_hook = __malloc_hook;\n    __malloc_hook = my_malloc_hook;\n}\n"

#. type: Plain text
#: man-pages/man3/malloc_hook.3:122
#, no-wrap
msgid ""
"static void *\n"
"my_malloc_hook(size_t size, const void *caller)\n"
"{\n"
"    void *result;\n"
msgstr "static void *\nmy_malloc_hook(size_t size, const void *caller)\n{\n    void *result;\n"

#. type: Plain text
#: man-pages/man3/malloc_hook.3:125
#, no-wrap
msgid ""
"    /* Restore all old hooks */\n"
"    __malloc_hook = old_malloc_hook;\n"
msgstr "    /* Восстанавливаем старые функции */\n    __malloc_hook = old_malloc_hook;\n"

#. type: Plain text
#: man-pages/man3/malloc_hook.3:128
#, no-wrap
msgid ""
"    /* Call recursively */\n"
"    result = malloc(size);\n"
msgstr "    /* вызываем рекурсивно */\n    result = malloc(size);\n"

#. type: Plain text
#: man-pages/man3/malloc_hook.3:131
#, no-wrap
msgid ""
"    /* Save underlying hooks */\n"
"    old_malloc_hook = __malloc_hook;\n"
msgstr "    /* сохраняем нижележащие функции */\n    old_malloc_hook = __malloc_hook;\n"

#. type: Plain text
#: man-pages/man3/malloc_hook.3:135
#, no-wrap
msgid ""
"    /* printf() might call malloc(), so protect it too. */\n"
"    printf(\"malloc(%u) called from %p returns %p\\en\",\n"
"            (unsigned int) size, caller, result);\n"
msgstr "    /* printf() тоже может вызвать malloc(), поэтому его тоже надо защитить */\n    printf(\"malloc(%u) called from %p returns %p\\en\",\n            (unsigned int) size, caller, result);\n"

#. type: Plain text
#: man-pages/man3/malloc_hook.3:138
#, no-wrap
msgid ""
"    /* Restore our own hooks */\n"
"    __malloc_hook = my_malloc_hook;\n"
msgstr "    /* восстанавливаем наши функции */\n    __malloc_hook = my_malloc_hook;\n"

#. type: Plain text
#: man-pages/man3/malloc_hook.3:141
#, no-wrap
msgid ""
"    return result;\n"
"}\n"
msgstr "    return result;\n}\n"

#. type: Plain text
#: man-pages/man3/malloc_hook.3:146
msgid "B<mallinfo>(3), B<malloc>(3), B<mcheck>(3), B<mtrace>(3)"
msgstr "B<mallinfo>(3), B<malloc>(3), B<mcheck>(3), B<mtrace>(3)"

#. type: TH
#: man-pages/man3/mq_unlink.3:26
#, no-wrap
msgid "MQ_UNLINK"
msgstr "MQ_UNLINK"

#. type: Plain text
#: man-pages/man3/mq_unlink.3:29
msgid "mq_unlink - remove a message queue"
msgstr "mq_unlink - удаляет очередь сообщений"

#. type: Plain text
#: man-pages/man3/mq_unlink.3:34
#, no-wrap
msgid "B<int mq_unlink(const char *>I<name>B<);>\n"
msgstr "B<int mq_unlink(const char *>I<name>B<);>\n"

#. type: Plain text
#: man-pages/man3/mq_unlink.3:44
msgid ""
"B<mq_unlink>()  removes the specified message queue I<name>.  The message "
"queue name is removed immediately.  The queue itself is destroyed once any "
"other processes that have the queue open close their descriptors referring "
"to the queue."
msgstr "Функция B<mq_unlink>() удаляет именованную очередь сообщений с именем I<name>. Имя очереди сообщений удаляется немедленно. А очередь сообщений уничтожается после того, как все остальные процессы, в которых она открыт, закроют её."

#. type: Plain text
#: man-pages/man3/mq_unlink.3:50
msgid ""
"On success B<mq_unlink>()  returns 0; on error, -1 is returned, with "
"I<errno> set to indicate the error."
msgstr "При успешном выполнении B<mq_unlink>() возвращается 0; при ошибке возвращается -1, а в I<errno> помещается код ошибки."

#. type: Plain text
#: man-pages/man3/mq_unlink.3:54
msgid "The caller does not have permission to unlink this message queue."
msgstr "Вызывающий не имеет прав на доступ для отсоединения очереди сообщений."

#. type: Plain text
#: man-pages/man3/mq_unlink.3:62
msgid "There is no message queue with the given I<name>."
msgstr "Очередь сообщений с указанным I<name> отсутствует."

#. type: tbl table
#: man-pages/man3/mq_unlink.3:72
#, no-wrap
msgid "B<mq_unlink>()"
msgstr "B<mq_unlink>()"

#. type: Plain text
#: man-pages/man3/mq_unlink.3:83
msgid ""
"B<mq_close>(3), B<mq_getattr>(3), B<mq_notify>(3), B<mq_open>(3), "
"B<mq_receive>(3), B<mq_send>(3), B<mq_overview>(7)"
msgstr "B<mq_close>(3), B<mq_getattr>(3), B<mq_notify>(3), B<mq_open>(3), B<mq_receive>(3), B<mq_send>(3), B<mq_overview>(7)"

#. type: TH
#: man-pages/man3/malloc_usable_size.3:25
#, no-wrap
msgid "MALLOC_USABLE_SIZE"
msgstr "MALLOC_USABLE_SIZE"

#. type: Plain text
#: man-pages/man3/malloc_usable_size.3:28
msgid ""
"malloc_usable_size - obtain size of block of memory allocated from heap"
msgstr "malloc_usable_size - размер блока отданного из кучи"

#. type: Plain text
#: man-pages/man3/malloc_usable_size.3:32
msgid "B<size_t malloc_usable_size (void *>I<ptr>B<);>"
msgstr "B<size_t malloc_usable_size (void *>I<ptr>B<);>"

#. type: Plain text
#: man-pages/man3/malloc_usable_size.3:40
msgid ""
"The B<malloc_usable_size>()  function returns the number of usable bytes in "
"the block pointed to by I<ptr>, a pointer to a block of memory allocated by "
"B<malloc>(3)  or a related function."
msgstr "Функция  B<malloc_usable_size>() возвращает число байт в блоке. Вычисляет размер блока на который указывает I<ptr>. В качестве параметра следует использовать указатель полученный от функции B<malloc>(3) или от функции связанной с ней."

#. type: Plain text
#: man-pages/man3/malloc_usable_size.3:48
msgid ""
"B<malloc_usable_size>()  returns the number of usable bytes in the block of "
"allocated memory pointed to by I<ptr>.  If I<ptr> is NULL, 0 is returned."
msgstr "Функция  B<malloc_usable_size>() возвращает число байт в блоке выделенном B<malloc>(). Размер вычисляется для блока на который указывает I<ptr>. Если I<ptr> содержит NULL, то функция вернёт 0."

#. type: tbl table
#: man-pages/man3/malloc_usable_size.3:58
#, no-wrap
msgid "B<malloc_usable_size>()"
msgstr "B<malloc_usable_size>()"

#. type: Plain text
#: man-pages/man3/malloc_usable_size.3:72
msgid ""
"The value returned by B<malloc_usable_size>()  may be greater than the "
"requested size of the allocation because of alignment and minimum size "
"constraints.  Although the excess bytes can be overwritten by the "
"application without ill effects, this is not good programming practice: the "
"number of excess bytes in an allocation depends on the underlying "
"implementation."
msgstr "Значение, возвращенное B<malloc_usable_size>(), может быть больше, чем то значение которое вы указали в B<malloc>(). Это происходит из-за выравнивания и ограничений на минимальный размер блока. Хотя изменение лишних байт не может привести к ошибкам, это не хорошая практика программирования: так как наличие и число лишних байт зависит от реализации B<malloc>."

#. type: Plain text
#: man-pages/man3/malloc_usable_size.3:74
msgid "The main use of this function is for debugging and introspection."
msgstr "В основном эта функция применяется для отладки и самоанализа."

#. type: Plain text
#: man-pages/man3/malloc_usable_size.3:75
msgid "B<malloc>(3)"
msgstr "B<malloc>(3)"

#. type: TH
#: man-pages/man3/malloc_stats.3:26
#, no-wrap
msgid "MALLOC_STATS"
msgstr "MALLOC_STATS"

#. type: Plain text
#: man-pages/man3/malloc_stats.3:29
msgid "malloc_stats - print memory allocation statistics"
msgstr "malloc_stats — вывести статистику для выделенной памяти "

#. type: Plain text
#: man-pages/man3/malloc_stats.3:33
msgid "B<void malloc_stats(void);>"
msgstr "B<void malloc_stats(void);>"

#.  .SH VERSIONS
#.  Available already in glibc 2.0, possibly earlier
#. type: Plain text
#: man-pages/man3/malloc_stats.3:55
msgid ""
"The B<malloc_stats>()  function prints (on standard error) statistics about "
"memory allocated by B<malloc>(3)  and related functions.  For each arena "
"(allocation area), this function prints the total amount of memory allocated"
" and the total number of bytes consumed by in-use allocations.  (These two "
"values correspond to the I<arena> and I<uordblks> fields retrieved by "
"B<mallinfo>(3).)  In addition, the function prints the sum of these two "
"statistics for all arenas, and the maximum number of blocks and bytes that "
"were ever simultaneously allocated using B<mmap>(2)."
msgstr "Функция B<malloc_stats>() печатает (через стандартный вывод ошибок) статистику о выделенной, при помощи B<malloc>(3) или других функций, памяти. Для каждой области выделяемой памяти (арене), эта функция печатает общее количество выделенной памяти и общее число затраченных на это байт. (Эти два значения соответствуют полям I<arena> и I<uordblks> возвращаемым B<mallinfo>(3)). В дополнение, функция печатает сумму этих двух статистик для всех арен и максимальное число блоков и байт, которые когда-либо были  одновременно выделены при использовании B<mmap>(2)."

#. type: tbl table
#: man-pages/man3/malloc_stats.3:65
#, no-wrap
msgid "B<malloc_stats>()"
msgstr "B<malloc_stats>()"

#. type: Plain text
#: man-pages/man3/malloc_stats.3:74
msgid ""
"More detailed information about memory allocations in the main arena can be "
"obtained using B<mallinfo>(3)."
msgstr "Для более детальной информации о выделении памяти в главной арене используйте B<mallinfo>(3)."

#. type: Plain text
#: man-pages/man3/malloc_stats.3:79
msgid ""
"B<mmap>(2), B<mallinfo>(3), B<malloc>(3), B<malloc_info>(3), B<mallopt>(3)"
msgstr "B<mmap>(2), B<mallinfo>(3), B<malloc>(3), B<malloc_info>(3), B<mallopt>(3)"

#. type: TH
#: man-pages/man3/malloc.3:33
#, no-wrap
msgid "MALLOC"
msgstr "MALLOC"

#. type: Plain text
#: man-pages/man3/malloc.3:36
msgid "malloc, free, calloc, realloc - allocate and free dynamic memory"
msgstr "malloc, free, calloc, realloc - распределяет и освобождает динамическую память"

#. type: Plain text
#: man-pages/man3/malloc.3:45
#, no-wrap
msgid ""
"B<void *malloc(size_t >I<size>B<);>\n"
"B<void free(void >I<*ptr>B<);>\n"
"B<void *calloc(size_t >I<nmemb>B<, size_t >I<size>B<);>\n"
"B<void *realloc(void >I<*ptr>B<, size_t >I<size>B<);>\n"
"B<void *reallocarray(void >I<*ptr>B<, size_t >I<nmemb>B<, size_t >I<size>B<);>\n"
msgstr "B<void *malloc(size_t >I<size>B<);>\nB<void free(void >I<*ptr>B<);>\nB<void *calloc(size_t >I<nmemb>B<, size_t >I<size>B<);>\nB<void *realloc(void >I<*ptr>B<, size_t >I<size>B<);>\nB<void *reallocarray(void >I<*ptr>B<, size_t >I<nmemb>B<, size_t >I<size>B<);>\n"

#. type: Plain text
#: man-pages/man3/malloc.3:53
msgid "B<reallocarray>():"
msgstr "B<reallocarray>():"

#. type: Plain text
#: man-pages/man3/malloc.3:59
#, no-wrap
msgid ""
"_GNU_SOURCE\n"
"    Since glibc 2.29:\n"
"        _DEFAULT_SOURCE\n"
"    Glibc 2.28 and earlier:\n"
"        _GNU_SOURCE\n"
msgstr "_GNU_SOURCE\n    Начиная с glibc 2.29:\n        _DEFAULT_SOURCE\n    В glibc 2.28 и старее:\n        _GNU_SOURCE\n"

#.  glibc does this:
#. type: Plain text
#: man-pages/man3/malloc.3:76
msgid ""
"The B<malloc>()  function allocates I<size> bytes and returns a pointer to "
"the allocated memory.  I<The memory is not initialized>.  If I<size> is 0, "
"then B<malloc>()  returns either NULL, or a unique pointer value that can "
"later be successfully passed to B<free>()."
msgstr "Функция B<malloc>() распределяет I<size> байтов и возвращает указатель на распределённую память. I<Память при этом не инициализируется>. Если значение I<size> равно 0, то B<malloc>() возвращает или NULL, или уникальный указатель, который можно без опасений передавать B<free>()."

#. type: Plain text
#: man-pages/man3/malloc.3:92
msgid ""
"The B<free>()  function frees the memory space pointed to by I<ptr>, which "
"must have been returned by a previous call to B<malloc>(), B<calloc>(), or "
"B<realloc>().  Otherwise, or if I<free(ptr)> has already been called before,"
" undefined behavior occurs.  If I<ptr> is NULL, no operation is performed."
msgstr "Функция B<free>() освобождает место в памяти, указанное в I<ptr>, которое должно быть получено ранее вызовом функции B<malloc>(), B<calloc>() или B<realloc>(). Иначе (или если вызов I<free(ptr)> уже выполнялся) дальнейшее поведение не определено. Если значение I<ptr> равно NULL, то не выполняется никаких действий."

#.  glibc does this:
#. type: Plain text
#: man-pages/man3/malloc.3:122
msgid ""
"The B<calloc>()  function allocates memory for an array of I<nmemb> elements"
" of I<size> bytes each and returns a pointer to the allocated memory.  The "
"memory is set to zero.  If I<nmemb> or I<size> is 0, then B<calloc>()  "
"returns either NULL, or a unique pointer value that can later be "
"successfully passed to B<free>().  If the multiplication of I<nmemb> and "
"I<size> would result in integer overflow, then B<calloc>()  returns an "
"error.  By contrast, an integer overflow would not be detected in the "
"following call to B<malloc>(), with the result that an incorrectly sized "
"block of memory would be allocated:"
msgstr "Функция B<сalloc>() распределяет память для массива размером I<nmemb> элементов по I<size> байтов каждый и возвращает указатель на распределённую память. Данные в выделенной памяти при этом обнуляются. Если значение I<nmemb> или I<size> равно 0, то B<calloc>() возвращает NULL или уникальный указатель, который можно без опасений передавать B<free>(). Если перемножение I<nmemb> и I<size> приводит к целочисленному переполнению, то B<calloc>() возвращает ошибку. Это отличает её от B<malloc>(), которая не обнаруживает целочисленное переполнение и возвращает блок памяти неправильного размера:"

#. type: Plain text
#: man-pages/man3/malloc.3:126
#, no-wrap
msgid "malloc(nmemb * size);\n"
msgstr "malloc(nmemb * size);\n"

#. type: Plain text
#: man-pages/man3/malloc.3:164
msgid ""
"The B<realloc>()  function changes the size of the memory block pointed to "
"by I<ptr> to I<size> bytes.  The contents will be unchanged in the range "
"from the start of the region up to the minimum of the old and new sizes.  If"
" the new size is larger than the old size, the added memory will I<not> be "
"initialized.  If I<ptr> is NULL, then the call is equivalent to "
"I<malloc(size)>, for all values of I<size>; if I<size> is equal to zero, and"
" I<ptr> is not NULL, then the call is equivalent to I<free(ptr)>.  Unless "
"I<ptr> is NULL, it must have been returned by an earlier call to "
"B<malloc>(), B<calloc>(), or B<realloc>().  If the area pointed to was "
"moved, a I<free(ptr)> is done."
msgstr "Функция B<realloc>() меняет размер блока памяти, на который указывает I<ptr>, на размер, равный I<size> байт. Содержимое памяти не будет изменено от начала области в пределах наименьшего из старого и нового размеров. Если новый размер больше старого, то добавленная память I<не> будет инициализирована. Если значение I<ptr> равно NULL, то вызов эквивалентен I<malloc(size)> для всех значений I<size>; если значение I<size> равно нулю и I<ptr> не равно NULL, то вызов эквивалентен I<free(ptr)>. Если только значение I<ptr> не равно NULL, то должно быть возвращено ранее полученное значение от B<malloc>(), B<calloc>() или B<realloc>(). Если область была перемещена, то выполняется I<free(ptr)>."

#. type: Plain text
#: man-pages/man3/malloc.3:175
msgid ""
"The B<reallocarray>()  function changes the size of the memory block pointed"
" to by I<ptr> to be large enough for an array of I<nmemb> elements, each of "
"which is I<size> bytes.  It is equivalent to the call"
msgstr "Функция B<reallocarray>() изменяет размер блока памяти, на который указывает I<ptr>, таким образом, чтобы он смог вместить массив из I<nmemb> элементов, каждый из которых занимает I<size> байт. Она эквивалентна вызову"

#. type: Plain text
#: man-pages/man3/malloc.3:178
#, no-wrap
msgid "    realloc(ptr, nmemb * size);\n"
msgstr "    realloc(ptr, nmemb * size);\n"

#. type: Plain text
#: man-pages/man3/malloc.3:192
msgid ""
"However, unlike that B<realloc>()  call, B<reallocarray>()  fails safely in "
"the case where the multiplication would overflow.  If such an overflow "
"occurs, B<reallocarray>()  returns NULL, sets I<errno> to B<ENOMEM>, and "
"leaves the original block of memory unchanged."
msgstr "Однако в отличие от вызова B<realloc>(), функция B<reallocarray>() безопасно завершается ошибкой в случае возникновения переполнения умножения. Если это происходит, то B<reallocarray>() возвращает NULL, присваивает I<errno> значение B<ENOMEM> и оставляет первоначальный блок памяти в неизменном виде."

#. type: Plain text
#: man-pages/man3/malloc.3:212
msgid ""
"The B<malloc>()  and B<calloc>()  functions return a pointer to the "
"allocated memory, which is suitably aligned for any built-in type.  On "
"error, these functions return NULL.  NULL may also be returned by a "
"successful call to B<malloc>()  with a I<size> of zero, or by a successful "
"call to B<calloc>()  with I<nmemb> or I<size> equal to zero."
msgstr "Функции B<malloc>() и B<calloc>() возвращают указатель на распределённую память, выровненную должным образом для любого встроенного типа. При ошибке возвращается NULL. Значение NULL также может быть получено при успешной работе вызова B<malloc>(), если значение I<size> равно нулю, или B<calloc>() — если значение I<nmemb> или I<size> равно нулю."

#. type: Plain text
#: man-pages/man3/malloc.3:216
msgid "The B<free>()  function returns no value."
msgstr "Функция B<free>() ничего не возвращает."

#. type: Plain text
#: man-pages/man3/malloc.3:231
msgid ""
"The B<realloc>()  function returns a pointer to the newly allocated memory, "
"which is suitably aligned for any built-in type and may be different from "
"I<ptr>, or NULL if the request fails.  If I<size> was equal to 0, either "
"NULL or a pointer suitable to be passed to B<free>()  is returned.  If "
"B<realloc>()  fails, the original block is left untouched; it is not freed "
"or moved."
msgstr "Функция B<realloc>() возвращает указатель на новую распределённую память, выровненную должным образом для любого встроенного типа. Возвращаемый указатель может отличаться от I<ptr>, или равняться NULL, если запрос завершился с ошибкой. Если значение I<size> было равно нулю, то возвращается либо NULL, либо указатель, который может быть передан B<free>(). Если B<realloc>() завершилась с ошибкой, то начальный блок памяти остаётся нетронутым: он не освобождается или перемещается."

#. type: Plain text
#: man-pages/man3/malloc.3:237
msgid ""
"On success, the B<reallocarray>()  function returns a pointer to the newly "
"allocated memory.  On failure, it returns NULL and the original block of "
"memory is left untouched."
msgstr "При успешном выполнении функция B<reallocarray>() возвращает указатель на новую выделенную память. При ошибке возвращается NULL, а первоначальный блок памяти не изменяется."

#. type: Plain text
#: man-pages/man3/malloc.3:244
msgid ""
"B<calloc>(), B<malloc>(), B<realloc>(), and B<reallocarray>()  can fail with"
" the following error:"
msgstr "Функции B<calloc>(), B<malloc>(), B<realloc>() и B<reallocarray>() могут завершаться со следующей ошибкой:"

#. type: Plain text
#: man-pages/man3/malloc.3:253
msgid ""
"Out of memory.  Possibly, the application hit the B<RLIMIT_AS> or "
"B<RLIMIT_DATA> limit described in B<getrlimit>(2)."
msgstr "Не хватает памяти. Вероятно приложение достигнут лимит B<RLIMIT_AS> или B<RLIMIT_DATA>, описанный в B<getrlimit>(2)."

#. type: tbl table
#: man-pages/man3/malloc.3:264
#, no-wrap
msgid ""
"B<malloc>(),\n"
"B<free>(),\n"
msgstr "B<malloc>(),\nB<free>(),\n"

#. type: tbl table
#: man-pages/man3/malloc.3:267
#, no-wrap
msgid ""
"B<calloc>(),\n"
"B<realloc>()"
msgstr "B<calloc>(),\nB<realloc>()"

#. type: Plain text
#: man-pages/man3/malloc.3:275
msgid ""
"B<malloc>(), B<free>(), B<calloc>(), B<realloc>(): POSIX.1-2001, "
"POSIX.1-2008, C89, C99."
msgstr "B<malloc>(), B<free>(), B<calloc>(), B<realloc>(): POSIX.1-2001, POSIX.1-2008, C89, C99."

#. type: Plain text
#: man-pages/man3/malloc.3:278
msgid ""
"B<reallocarray>()  is a nonstandard extension that first appeared in OpenBSD"
" 5.6 and FreeBSD 11.0."
msgstr "Функция B<reallocarray>() является нестандартным расширением, впервые появилась в OpenBSD 5.6 и FreeBSD 11.0."

#. type: Plain text
#: man-pages/man3/malloc.3:294
msgid ""
"By default, Linux follows an optimistic memory allocation strategy.  This "
"means that when B<malloc>()  returns non-NULL there is no guarantee that the"
" memory really is available.  In case it turns out that the system is out of"
" memory, one or more processes will be killed by the OOM killer.  For more "
"information, see the description of I</proc/sys/vm/overcommit_memory> and "
"I</proc/sys/vm/oom_adj> in B<proc>(5), and the Linux kernel source file "
"I<Documentation/vm/overcommit-accounting.rst>."
msgstr "По умолчанию, Linux придерживается оптимистичной стратегии распределения памяти. Это означает, что когда B<malloc>() возвращает значение не NULL, то нет никаких гарантий, что память в действительности доступна. Если обнаружится, что системе не хватает памяти, то один или несколько процессов будут завершены OOM. Дополнительную информацию можно получить из описания I</proc/sys/vm/overcommit_memory> и I</proc/sys/vm/oom_adj> в B<proc>(5) и файле из исходного кода ядра Linux I<Documentation/vm/overcommit-accounting.rst>."

#. type: Plain text
#: man-pages/man3/malloc.3:317
msgid ""
"Normally, B<malloc>()  allocates memory from the heap, and adjusts the size "
"of the heap as required, using B<sbrk>(2).  When allocating blocks of memory"
" larger than B<MMAP_THRESHOLD> bytes, the glibc B<malloc>()  implementation "
"allocates the memory as a private anonymous mapping using B<mmap>(2).  "
"B<MMAP_THRESHOLD> is 128\\ kB by default, but is adjustable using "
"B<mallopt>(3).  Prior to Linux 4.7 allocations performed using B<mmap>(2)  "
"were unaffected by the B<RLIMIT_DATA> resource limit; since Linux 4.7, this "
"limit is also enforced for allocations performed using B<mmap>(2)."
msgstr "Обычно, B<malloc>() выделяет память из кучи и подгоняет размер кучи соответствующим образом с помощью B<sbrk>(2). Если выделяемый блок памяти больше чем B<MMAP_THRESHOLD> байт, то реализация B<malloc>() в glibc выделяет память с помощью B<mmap>(2) в виде частного анонимного отображения. По умолчанию, значение B<MMAP_THRESHOLD> равно 128\\ КБ, но его можно изменить с помощью B<mallopt>(3). До Linux 4.7 на выделения, выполняемые с помощью B<mmap>(2), не влияет ограничитель ресурса B<RLIMIT_DATA>; начиная с Linux 4.7 это ограничение также применяется к выделениям, созданным с помощью B<mmap>(2)."

#. type: Plain text
#: man-pages/man3/malloc.3:335
msgid ""
"To avoid corruption in multithreaded applications, mutexes are used "
"internally to protect the memory-management data structures employed by "
"these functions.  In a multithreaded application in which threads "
"simultaneously allocate and free memory, there could be contention for these"
" mutexes.  To scalably handle memory allocation in multithreaded "
"applications, glibc creates additional I<memory allocation arenas> if mutex "
"contention is detected.  Each arena is a large region of memory that is "
"internally allocated by the system (using B<brk>(2)  or B<mmap>(2)), and "
"managed with its own mutexes."
msgstr "Внутри данных функций для защиты от повреждений выделяемых структур данных управления памятью, используются мьютексы. В многонитевых приложениях, в которых нити одновременно выделяют и освобождают память, может возникнуть конфликт за обладание этими мьютексами. Чтобы расширить обработку выделения памяти в многонитевых приложениях библиотека glibc создаёт дополнительные I<области выделения памяти> (memory allocation arenas), если обнаруживается конфликт. Каждая область представляет собой большой кусок памяти, который внутренне выделен системой (с помощью B<brk>(2) или B<mmap>(2)) и управляется своими собственными мьютексами."

#. type: Plain text
#: man-pages/man3/malloc.3:353
msgid ""
"SUSv2 requires B<malloc>(), B<calloc>(), and B<realloc>()  to set I<errno> "
"to B<ENOMEM> upon failure.  Glibc assumes that this is done (and the glibc "
"versions of these routines do this); if you use a private malloc "
"implementation that does not set I<errno>, then certain library routines may"
" fail without having a reason in I<errno>."
msgstr "Стандарт SUSv2 требует, чтобы функции B<malloc>(), B<calloc>() и B<realloc>() при ошибках присваивали значение B<ENOMEM> переменной I<errno>. Glibc допускает, что это уже реализовано (и версии glibc этих функций делают это); если вы используете свою реализацию функции malloc, которая не изменяет I<errno>, то некоторые функции библиотеки могут закончить работу с ошибкой без указания причины в I<errno>."

#. type: Plain text
#: man-pages/man3/malloc.3:362
msgid ""
"Crashes in B<malloc>(), B<calloc>(), B<realloc>(), or B<free>()  are almost "
"always related to heap corruption, such as overflowing an allocated chunk or"
" freeing the same pointer twice."
msgstr "Аварийные ситуации в B<malloc>(), B<calloc>(), B<realloc>() или B<free>() почти всегда связаны с повреждением кучи, например, с переполнением больших распределённых участков памяти или освобождением одного и того же указателя дважды."

#. type: Plain text
#: man-pages/man3/malloc.3:368
msgid ""
"The B<malloc>()  implementation is tunable via environment variables; see "
"B<mallopt>(3)  for details."
msgstr "Реализация B<malloc>() настраивается с помощью переменных окружения; подробности смотрите в B<mallopt>(3)."

#. type: Plain text
#: man-pages/man3/malloc.3:393
msgid ""
"B<valgrind>(1), B<brk>(2), B<mmap>(2), B<alloca>(3), B<malloc_get_state>(3),"
" B<malloc_info>(3), B<malloc_trim>(3), B<malloc_usable_size>(3), "
"B<mallopt>(3), B<mcheck>(3), B<mtrace>(3), B<posix_memalign>(3)"
msgstr "B<valgrind>(1), B<brk>(2), B<mmap>(2), B<alloca>(3), B<malloc_get_state>(3), B<malloc_info>(3), B<malloc_trim>(3), B<malloc_usable_size>(3), B<mallopt>(3), B<mcheck>(3), B<mtrace>(3), B<posix_memalign>(3)"

#. type: Plain text
#: man-pages/man3/malloc.3:396
msgid ""
"For details of the GNU C library implementation, see E<.UR "
"https://sourceware.org/glibc/wiki/MallocInternals> E<.UE .>"
msgstr "Информацию о реализации в библиотеке GNU C смотрите в E<.UR https://sourceware.org/glibc/wiki/MallocInternals> E<.UE .>"

#. type: TH
#: man-pages/man3/mallinfo.3:26
#, no-wrap
msgid "MALLINFO"
msgstr "MALLINFO"

#. type: Plain text
#: man-pages/man3/mallinfo.3:29
msgid "mallinfo - obtain memory allocation information"
msgstr "mallinfo — возвращает информацию о выделении памяти"

#. type: Plain text
#: man-pages/man3/mallinfo.3:33
msgid "B<struct mallinfo mallinfo(void);>"
msgstr "B<struct mallinfo mallinfo(void);>"

#. type: Plain text
#: man-pages/man3/mallinfo.3:40
msgid ""
"The B<mallinfo>()  function returns a copy of a structure containing "
"information about memory allocations performed by B<malloc>(3)  and related "
"functions."
msgstr ""

#. type: Plain text
#: man-pages/man3/mallinfo.3:46
msgid ""
"Note that not all allocations are visible to B<mallinfo>(); see BUGS and "
"consider using B<malloc_info>(3)  instead."
msgstr ""

#. type: Plain text
#: man-pages/man3/mallinfo.3:48
msgid "The returned structure is defined as follows:"
msgstr ""

#. type: Plain text
#: man-pages/man3/mallinfo.3:63
#, no-wrap
msgid ""
"struct mallinfo {\n"
"    int arena;     /* Non-mmapped space allocated (bytes) */\n"
"    int ordblks;   /* Number of free chunks */\n"
"    int smblks;    /* Number of free fastbin blocks */\n"
"    int hblks;     /* Number of mmapped regions */\n"
"    int hblkhd;    /* Space allocated in mmapped regions (bytes) */\n"
"    int usmblks;   /* Maximum total allocated space (bytes) */\n"
"    int fsmblks;   /* Space in freed fastbin blocks (bytes) */\n"
"    int uordblks;  /* Total allocated space (bytes) */\n"
"    int fordblks;  /* Total free space (bytes) */\n"
"    int keepcost;  /* Top-most, releasable space (bytes) */\n"
"};\n"
msgstr "struct mallinfo {\n    int arena;     /* не размеченная область памяти выделенная под кучу (в байтах) */\n    int ordblks;   /* Количество свободных блоков */\n    int smblks;    /* Количество свободных блоков fastbin */\n    int hblks;     /* Количество размеченных областей */\n    int hblkhd;    /* Пространство, выделенное в размеченных областях (в байтах) */\n    int usmblks;   /* Максимум общей выделенной области (в байтах) */\n    int fsmblks;   /* Пространство в освобожденных fastbin блоках (в байтах) */\n    int uordblks;  /* Общее выделенное пространство (в байтах) */\n    int fordblks;  /* Общее свободное пространство (в байтах) */\n    int keepcost;  /* Верхнее пространство, которое можно освободить (в байтах) */\n};\n"

#. type: Plain text
#: man-pages/man3/mallinfo.3:69
msgid ""
"The fields of the I<mallinfo> structure contain the following information:"
msgstr "Поля структуры I<mallinfo> содержат следующую информацию:"

#. type: TP
#: man-pages/man3/mallinfo.3:69
#, no-wrap
msgid "I<arena>"
msgstr "I<arena>"

#. type: Plain text
#: man-pages/man3/mallinfo.3:75
msgid ""
"The total amount of memory allocated by means other than B<mmap>(2)  (i.e., "
"memory allocated on the heap).  This figure includes both in-use blocks and "
"blocks on the free list."
msgstr "Общее количество памяти, выделенной способами отличными от B<mmap>(2) (т. е., память, выделенная из кучи). Это значение включает используемые и свободные блоки из списка."

#. type: TP
#: man-pages/man3/mallinfo.3:75
#, no-wrap
msgid "I<ordblks>"
msgstr "I<ordblks>"

#. type: Plain text
#: man-pages/man3/mallinfo.3:78
msgid "The number of ordinary (i.e., non-fastbin) free blocks."
msgstr "Количество обычных (т. е., не fastbin) свободных блоков."

#. type: TP
#: man-pages/man3/mallinfo.3:78
#, no-wrap
msgid "I<smblks>"
msgstr "I<smblks>"

#. type: Plain text
#: man-pages/man3/mallinfo.3:82
msgid "The number of fastbin free blocks (see B<mallopt>(3))."
msgstr "Количество свободных блоков fastbin (смотрите B<mallopt>(3))."

#. type: TP
#: man-pages/man3/mallinfo.3:82
#, no-wrap
msgid "I<hblks>"
msgstr "I<hblks>"

#. type: Plain text
#: man-pages/man3/mallinfo.3:90
msgid ""
"The number of blocks currently allocated using B<mmap>(2).  (See the "
"discussion of B<M_MMAP_THRESHOLD> in B<mallopt>(3).)"
msgstr "Количество блоков, выделенных с помощью B<mmap>(2) на настоящий момент (смотрите описание B<M_MMAP_THRESHOLD> в B<mallopt>(3))."

#. type: TP
#: man-pages/man3/mallinfo.3:90
#, no-wrap
msgid "I<hblkhd>"
msgstr "I<hblkhd>"

#. type: Plain text
#: man-pages/man3/mallinfo.3:94
msgid "The number of bytes in blocks currently allocated using B<mmap>(2)."
msgstr "Количество байт в блоках, выделенных с помощью B<mmap>(2) на настоящий момент."

#. type: TP
#: man-pages/man3/mallinfo.3:94
#, no-wrap
msgid "I<usmblks>"
msgstr "I<usmblks>"

#. type: Plain text
#: man-pages/man3/mallinfo.3:99
msgid ""
"The \"highwater mark\" for allocated space\\(emthat is, the maximum amount "
"of space that was ever allocated.  This field is maintained only in "
"nonthreading environments."
msgstr "«Верхняя отметка» выделенного пространства, то есть максимальное количество места, которое когда-либо выделялось. Это поле изменяется только в окружениях без нитей."

#. type: TP
#: man-pages/man3/mallinfo.3:99
#, no-wrap
msgid "I<fsmblks>"
msgstr "I<fsmblks>"

#. type: Plain text
#: man-pages/man3/mallinfo.3:102
msgid "The total number of bytes in fastbin free blocks."
msgstr "Общее количество байт в свободных блоках fastbin."

#. type: TP
#: man-pages/man3/mallinfo.3:102
#, no-wrap
msgid "I<uordblks>"
msgstr "I<uordblks>"

#. type: Plain text
#: man-pages/man3/mallinfo.3:105
msgid "The total number of bytes used by in-use allocations."
msgstr "Общее количество байт, в используемой выделенной памяти."

#. type: TP
#: man-pages/man3/mallinfo.3:105
#, no-wrap
msgid "I<fordblks>"
msgstr "I<fordblks>"

#. type: Plain text
#: man-pages/man3/mallinfo.3:108
msgid "The total number of bytes in free blocks."
msgstr "Общее количество байт в свободных блоках."

#. type: TP
#: man-pages/man3/mallinfo.3:108
#, no-wrap
msgid "I<keepcost>"
msgstr "I<keepcost>"

#.  .SH VERSIONS
#.  Available already in glibc 2.0, possibly earlier
#. type: Plain text
#: man-pages/man3/mallinfo.3:117
msgid ""
"The total amount of releasable free space at the top of the heap.  This is "
"the maximum number of bytes that could ideally (i.e., ignoring page "
"alignment restrictions, and so on) be released by B<malloc_trim>(3)."
msgstr "Общее количество освобождаемого свободного пространства сверху кучи. Это значение является максимальным количеством байт, которое будет освобождено B<malloc_trim>(3) в идеальном случае (т. е., без учёта ограничений по выравниванию и т. п.)."

#. type: tbl table
#: man-pages/man3/mallinfo.3:127
#, no-wrap
msgid "B<mallinfo>()"
msgstr "B<mallinfo>()"

#. type: tbl table
#: man-pages/man3/mallinfo.3:127
#, no-wrap
msgid "MT-Unsafe init const:mallopt"
msgstr "MT-Unsafe init const:mallopt"

#. type: Plain text
#: man-pages/man3/mallinfo.3:143
msgid ""
"B<mallinfo>()  would access some global internal objects.  If modify them "
"with non-atomically, may get inconsistent results.  The identifier "
"I<mallopt> in I<const:mallopt> mean that B<mallopt>()  would modify the "
"global internal objects with atomics, that make sure B<mallinfo>()  is safe "
"enough, others modify with non-atomically maybe not."
msgstr "Функция B<mallinfo>() получила бы доступ к некоторым глобальным внутренним переменным. Если изменять их не атомарно, то можно нарушить целостность результатов. Идентификатор I<mallopt> в I<const:mallopt> означает, что B<mallopt>() изменяла бы глобальные внутренние переменные атомарно, что делает B<mallinfo>() достаточно безопасной, но другие изменения могут выполняться не атомарно."

#. type: Plain text
#: man-pages/man3/mallinfo.3:147
msgid ""
"This function is not specified by POSIX or the C standards.  A similar "
"function exists on many System V derivatives, and was specified in the SVID."
msgstr "Эта функция не определена в стандартах POSIX и С. Подобная функция существует на многих производных от System V и была определена в SVID."

#.  FIXME . http://sourceware.org/bugzilla/show_bug.cgi?id=208
#.  See the 24 Aug 2011 mail by Paul Pluzhnikov:
#.      "[patch] Fix mallinfo() to accumulate results for all arenas"
#.  on libc-alpha@sourceware.org
#. type: Plain text
#: man-pages/man3/mallinfo.3:159
msgid ""
"B<Information is returned for only the main memory allocation area.> "
"Allocations in other arenas are excluded.  See B<malloc_stats>(3)  and "
"B<malloc_info>(3)  for alternatives that include information about other "
"arenas."
msgstr "B<Информация возвращается только для главной области выделяемой памяти.> Выделение в других областях не учитываются. Альтернативой, возвращаемой информацию о других частях, являются B<malloc_stats>(3) и B<malloc_info>(3)."

#. type: Plain text
#: man-pages/man3/mallinfo.3:167
msgid ""
"The fields of the I<mallinfo> structure are typed as I<int>.  However, "
"because some internal bookkeeping values may be of type I<long>, the "
"reported values may wrap around zero and thus be inaccurate."
msgstr "Поля структуры I<mallinfo> имеют тип I<int>. Однако, из-за того, что некоторые внутренние значения поддержки (bookkeeping) могут иметь тип I<long>, возвращаемые значения могут быть близкими к нулю и поэтому не точны."

#. type: Plain text
#: man-pages/man3/mallinfo.3:173
msgid ""
"The program below employs B<mallinfo>()  to retrieve memory allocation "
"statistics before and after allocating and freeing some blocks of memory.  "
"The statistics are displayed on standard output."
msgstr "Программа, представленная ниже, вызывает B<mallinfo>() для получения статистики по выделенной памяти перед и после выделения и освобождения нескольких блоков памяти. Статистика выдаётся в стандартный вывод."

#. type: Plain text
#: man-pages/man3/mallinfo.3:177
msgid ""
"The first two command-line arguments specify the number and size of blocks "
"to be allocated with B<malloc>(3)."
msgstr "Первые два параметра командной строки определяют количество и размер блоков, которые будут выделены с помощью B<malloc>(3)."

#. type: Plain text
#: man-pages/man3/mallinfo.3:191
msgid ""
"The remaining three arguments specify which of the allocated blocks should "
"be freed with B<free>(3).  These three arguments are optional, and specify "
"(in order): the step size to be used in the loop that frees blocks (the "
"default is 1, meaning free all blocks in the range); the ordinal position of"
" the first block to be freed (default 0, meaning the first allocated block);"
" and a number one greater than the ordinal position of the last block to be "
"freed (default is one greater than the maximum block number).  If these "
"three arguments are omitted, then the defaults cause all allocated blocks to"
" be freed."
msgstr "В оставшихся трёх аргументах задаётся какие из выделенных блоков должны быть освобождены с помощью B<free>(3). Эти аргументы необязательны и определяют (по порядку): размер шага, используемый в цикле освобождения блоков (по умолчанию 1, что приводит к освобождению всех блоков диапазона); порядковая позиция первого освобождаемого блока (по умолчанию 0, то есть первый выделенный блок); номер, на единицу больший порядковой позиции последнего освобождаемого блока (по умолчанию, на единицу больше, чем максимальное количество блоков). Если эти аргументы не указаны, то по умолчанию освобождаются все выделенные блоки."

#. type: Plain text
#: man-pages/man3/mallinfo.3:195
msgid ""
"In the following example run of the program, 1000 allocations of 100 bytes "
"are performed, and then every second allocated block is freed:"
msgstr "Пример запуска программы, где память выделяется 1000 раз по 100 байт, а затем освобождается каждый второй выделенный блок:"

#. type: Plain text
#: man-pages/man3/mallinfo.3:210
#, no-wrap
msgid ""
"$ B<./a.out 1000 100 2>\n"
"============== Before allocating blocks ==============\n"
"Total non-mmapped bytes (arena):       0\n"
"# of free chunks (ordblks):            1\n"
"# of free fastbin blocks (smblks):     0\n"
"# of mapped regions (hblks):           0\n"
"Bytes in mapped regions (hblkhd):      0\n"
"Max. total allocated space (usmblks):  0\n"
"Free bytes held in fastbins (fsmblks): 0\n"
"Total allocated space (uordblks):      0\n"
"Total free space (fordblks):           0\n"
"Topmost releasable block (keepcost):   0\n"
msgstr "$ B<./a.out 1000 100 2>\n============== перед выделением блоков ==============\nвсего неотображённых байт (часть):       0\nкол-во свободных порций (ordblks):            1\nкол-во свободных блоков fastbin (smblks):     0\nкол-во отображённых областей (hblks):           0\nбайтов в отображённых областях (hblkhd):      0\nмаксимальное количество выделенного пространства (usmblks):  0\nсвободных байт в fastbins (fsmblks): 0\nполное выделенное пространство (uordblks):      0\nполное свободное пространство (fordblks):           0\nосвобождаемых блоков сверху (keepcost):   0\n"

#. type: Plain text
#: man-pages/man3/mallinfo.3:222
#, no-wrap
msgid ""
"============== After allocating blocks ==============\n"
"Total non-mmapped bytes (arena):       135168\n"
"# of free chunks (ordblks):            1\n"
"# of free fastbin blocks (smblks):     0\n"
"# of mapped regions (hblks):           0\n"
"Bytes in mapped regions (hblkhd):      0\n"
"Max. total allocated space (usmblks):  0\n"
"Free bytes held in fastbins (fsmblks): 0\n"
"Total allocated space (uordblks):      104000\n"
"Total free space (fordblks):           31168\n"
"Topmost releasable block (keepcost):   31168\n"
msgstr "============== после выделения блоков ==============\nвсего неотображённых байт (часть):       1\nкол-во свободных порций (ordblks):            0\nкол-во свободных блоков fastbin (smblks):     0\nкол-во отображённых областей (hblks):           0\nбайтов в отображённых областях (hblkhd):      0\nмаксимальное количество выделенного пространства (usmblks):  0\nсвободных байт в fastbins (fsmblks): 0\nполное выделенное пространство (uordblks):      104000\nполное свободное пространство (fordblks):           31168\nосвобождаемых блоков сверху (keepcost):   31168\n"

#. type: Plain text
#: man-pages/man3/mallinfo.3:234
#, no-wrap
msgid ""
"============== After freeing blocks ==============\n"
"Total non-mmapped bytes (arena):       135168\n"
"# of free chunks (ordblks):            501\n"
"# of free fastbin blocks (smblks):     0\n"
"# of mapped regions (hblks):           0\n"
"Bytes in mapped regions (hblkhd):      0\n"
"Max. total allocated space (usmblks):  0\n"
"Free bytes held in fastbins (fsmblks): 0\n"
"Total allocated space (uordblks):      52000\n"
"Total free space (fordblks):           83168\n"
"Topmost releasable block (keepcost):   31168\n"
msgstr "============== после освобождения блоков ==============\nвсего неотображённых байт (часть):       135168\nкол-во свободных порций (ordblks):            501\nкол-во свободных блоков fastbin (smblks):     0\nкол-во отображённых областей (hblks):           0\nбайтов в отображённых областях (hblkhd):      0\nмаксимальное количество выделенного пространства (usmblks):  0\nсвободных байт в fastbins (fsmblks): 0\nполное выделенное пространство (uordblks):      52000\nполное свободное пространство (fordblks):           83168\nосвобождаемых блоков сверху (keepcost):   31168\n"

#. type: Plain text
#: man-pages/man3/mallinfo.3:242
#, no-wrap
msgid ""
"#include E<lt>malloc.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
msgstr "#include E<lt>malloc.hE<gt>\n#include E<lt>stdlib.hE<gt>\n#include E<lt>string.hE<gt>\n"

#. type: Plain text
#: man-pages/man3/mallinfo.3:247
#, no-wrap
msgid ""
"static void\n"
"display_mallinfo(void)\n"
"{\n"
"    struct mallinfo mi;\n"
msgstr "static void\ndisplay_mallinfo(void)\n{\n    struct mallinfo mi;\n"

#. type: Plain text
#: man-pages/man3/mallinfo.3:249
#, no-wrap
msgid "    mi = mallinfo();\n"
msgstr "    mi = mallinfo();\n"

#. type: Plain text
#: man-pages/man3/mallinfo.3:261
#, no-wrap
msgid ""
"    printf(\"Total non-mmapped bytes (arena):       %d\\en\", mi.arena);\n"
"    printf(\"# of free chunks (ordblks):            %d\\en\", mi.ordblks);\n"
"    printf(\"# of free fastbin blocks (smblks):     %d\\en\", mi.smblks);\n"
"    printf(\"# of mapped regions (hblks):           %d\\en\", mi.hblks);\n"
"    printf(\"Bytes in mapped regions (hblkhd):      %d\\en\", mi.hblkhd);\n"
"    printf(\"Max. total allocated space (usmblks):  %d\\en\", mi.usmblks);\n"
"    printf(\"Free bytes held in fastbins (fsmblks): %d\\en\", mi.fsmblks);\n"
"    printf(\"Total allocated space (uordblks):      %d\\en\", mi.uordblks);\n"
"    printf(\"Total free space (fordblks):           %d\\en\", mi.fordblks);\n"
"    printf(\"Topmost releasable block (keepcost):   %d\\en\", mi.keepcost);\n"
"}\n"
msgstr "    printf(\"всего неотображённых байт (часть):       %d\\en\", mi.arena);\n    printf(\"кол-во свободных порций (ordblks):            %d\\en\", mi.ordblks);\n    printf(\"кол-во свободных блоков fastbin (smblks):     %d\\en\", mi.smblks);\n    printf(\"кол-во отображённых областей (hblks):           %d\\en\", mi.hblks);\n    printf(\"байтов в отображённых областях (hblkhd):      %d\\en\", mi.hblkhd);\n    printf(\"максимальное количество выделенного пространства (usmblks):  %d\\en\", mi.usmblks);\n    printf(\"свободных байт в fastbins (fsmblks): %d\\en\", mi.fsmblks);\n    printf(\"полное выделенное пространство (uordblks):      %d\\en\", mi.uordblks);\n    printf(\"полное свободное пространство (fordblks):           %d\\en\", mi.fordblks);\n    printf(\"освобождаемых блоков сверху (keepcost):   %d\\en\", mi.keepcost);\n}\n"

#. type: Plain text
#: man-pages/man3/mallinfo.3:269
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"#define MAX_ALLOCS 2000000\n"
"    char *alloc[MAX_ALLOCS];\n"
"    int numBlocks, j, freeBegin, freeEnd, freeStep;\n"
"    size_t blockSize;\n"
msgstr "int\nmain(int argc, char *argv[])\n{\n#define MAX_ALLOCS 2000000\n    char *alloc[MAX_ALLOCS];\n    int numBlocks, j, freeBegin, freeEnd, freeStep;\n    size_t blockSize;\n"

#. type: Plain text
#: man-pages/man3/mallinfo.3:275
#, no-wrap
msgid ""
"    if (argc E<lt> 3 || strcmp(argv[1], \"--help\") == 0) {\n"
"        fprintf(stderr, \"%s num-blocks block-size [free-step \"\n"
"                \"[start-free [end-free]]]\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr "    if (argc E<lt> 3 || strcmp(argv[1], \"--help\") == 0) {\n        fprintf(stderr, \"%s кол-во блоков размер блока [шаг освобождения\"\n                \"[начало освобождения [конец освобождения]]]\\en\", argv[0]);\n        exit(EXIT_FAILURE);\n    }\n"

#. type: Plain text
#: man-pages/man3/mallinfo.3:281
#, no-wrap
msgid ""
"    numBlocks = atoi(argv[1]);\n"
"    blockSize = atoi(argv[2]);\n"
"    freeStep = (argc E<gt> 3) ? atoi(argv[3]) : 1;\n"
"    freeBegin = (argc E<gt> 4) ? atoi(argv[4]) : 0;\n"
"    freeEnd = (argc E<gt> 5) ? atoi(argv[5]) : numBlocks;\n"
msgstr "    numBlocks = atoi(argv[1]);\n    blockSize = atoi(argv[2]);\n    freeStep = (argc E<gt> 3) ? atoi(argv[3]) : 1;\n    freeBegin = (argc E<gt> 4) ? atoi(argv[4]) : 0;\n    freeEnd = (argc E<gt> 5) ? atoi(argv[5]) : numBlocks;\n"

#. type: Plain text
#: man-pages/man3/mallinfo.3:284
#, no-wrap
msgid ""
"    printf(\"============== Before allocating blocks ==============\\en\");\n"
"    display_mallinfo();\n"
msgstr "    printf(\"============== перед выделением блоков ==============\\en\");\n    display_mallinfo();\n"

#. type: Plain text
#: man-pages/man3/mallinfo.3:290
#, no-wrap
msgid ""
"    for (j = 0; j E<lt> numBlocks; j++) {\n"
"        if (numBlocks E<gt>= MAX_ALLOCS) {\n"
"            fprintf(stderr, \"Too many allocations\\en\");\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"
msgstr "    for (j = 0; j E<lt> numBlocks; j++) {\n        if (numBlocks E<gt>= MAX_ALLOCS) {\n            fprintf(stderr, \"слишком много выделений\\en\");\n            exit(EXIT_FAILURE);\n        }\n"

#. type: Plain text
#: man-pages/man3/mallinfo.3:297
#, no-wrap
msgid ""
"        alloc[j] = malloc(blockSize);\n"
"        if (alloc[j] == NULL) {\n"
"            perror(\"malloc\");\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"
"    }\n"
msgstr "        alloc[j] = malloc(blockSize);\n        if (alloc[j] == NULL) {\n            perror(\"malloc\");\n            exit(EXIT_FAILURE);\n        }\n    }\n"

#. type: Plain text
#: man-pages/man3/mallinfo.3:300
#, no-wrap
msgid ""
"    printf(\"\\en============== After allocating blocks ==============\\en\");\n"
"    display_mallinfo();\n"
msgstr "    printf(\"\\en============== после выделения блоков ==============\\en\");\n    display_mallinfo();\n"

#. type: Plain text
#: man-pages/man3/mallinfo.3:303
#, no-wrap
msgid ""
"    for (j = freeBegin; j E<lt> freeEnd; j += freeStep)\n"
"        free(alloc[j]);\n"
msgstr "    for (j = freeBegin; j E<lt> freeEnd; j += freeStep)\n        free(alloc[j]);\n"

#. type: Plain text
#: man-pages/man3/mallinfo.3:306
#, no-wrap
msgid ""
"    printf(\"\\en============== After freeing blocks ==============\\en\");\n"
"    display_mallinfo();\n"
msgstr "    printf(\"\\en============== после освобождения блоков ==============\\en\");\n    display_mallinfo();\n"

#. type: Plain text
#: man-pages/man3/mallinfo.3:318
msgid ""
"B<mmap>(2), B<malloc>(3), B<malloc_info>(3), B<malloc_stats>(3), "
"B<malloc_trim>(3), B<mallopt>(3)"
msgstr "B<mmap>(2), B<malloc>(3), B<malloc_info>(3), B<malloc_stats>(3), B<malloc_trim>(3), B<mallopt>(3)"

#. type: Plain text
#: man-pages/man3/mtrace.3:28
msgid "mtrace, muntrace - malloc tracing"
msgstr "mtrace, muntrace - трассировка malloc"

#. type: Plain text
#: man-pages/man3/mtrace.3:30
msgid "B<#include E<lt>mcheck.hE<gt>>"
msgstr "B<#include E<lt>mcheck.hE<gt>>"

#. type: Plain text
#: man-pages/man3/mtrace.3:32
msgid "B<void mtrace(void);>"
msgstr "B<void mtrace(void);>"

#. type: Plain text
#: man-pages/man3/mtrace.3:34
msgid "B<void muntrace(void);>"
msgstr "B<void muntrace(void);>"

#. type: Plain text
#: man-pages/man3/mtrace.3:46
msgid ""
"The B<mtrace>()  function installs hook functions for the memory-allocation "
"functions (B<malloc>(3), B<realloc>(3)  B<memalign>(3), B<free>(3)).  These "
"hook functions record tracing information about memory allocation and "
"deallocation.  The tracing information can be used to discover memory leaks "
"and attempts to free nonallocated memory in a program."
msgstr "Функция B<mtrace>() устанавливает перехватывающие функции (hook functions) на функции выделения памяти (B<malloc>(3), B<realloc>(3), B<memalign>(3), B<free>(3)). Эти перехватывающие функции записывают трассировочную информация о выделении и освобождении памяти. Информация о трассировке может использоваться в программе для обнаружения утечек памяти и попыток освобождения не выделенной памяти."

#. type: Plain text
#: man-pages/man3/mtrace.3:57
msgid ""
"The B<muntrace>()  function disables the hook functions installed by "
"B<mtrace>(), so that tracing information is no longer recorded for the "
"memory-allocation functions.  If no hook functions were successfully "
"installed by B<mtrace>(), B<muntrace>()  does nothing."
msgstr "Функция B<muntrace>() отключает перехватывающие функции, установленные B<mtrace>() и трассировка функций выделения памяти больше не выполняется. Если B<mtrace>() не установила перехватывающие функции, то B<muntrace>() ничего не делает."

#. type: Plain text
#: man-pages/man3/mtrace.3:65
msgid ""
"When B<mtrace>()  is called, it checks the value of the environment variable"
" B<MALLOC_TRACE>, which should contain the pathname of a file in which the "
"tracing information is to be recorded.  If the pathname is successfully "
"opened, it is truncated to zero length."
msgstr "При вызове B<mtrace>() она проверяет значение переменной окружения B<MALLOC_TRACE>, в которой должен содержаться путь к файлу для записи информации о трассировке. При открытии этого файла он обрезается до нулевой длины."

#. type: Plain text
#: man-pages/man3/mtrace.3:78
msgid ""
"If B<MALLOC_TRACE> is not set, or the pathname it specifies is invalid or "
"not writable, then no hook functions are installed, and B<mtrace>()  has no "
"effect.  In set-user-ID and set-group-ID programs, B<MALLOC_TRACE> is "
"ignored, and B<mtrace>()  has no effect."
msgstr "Если B<MALLOC_TRACE> не существует или указанный путь некорректен или недоступен для записи, то перехватывающие функции не устанавливаются и B<mtrace>() ничего не делает. Для программ с установленными set-user-ID и set-group-ID переменная B<MALLOC_TRACE> игнорируется и B<mtrace>() ничего не делает."

#. type: tbl table
#: man-pages/man3/mtrace.3:89
#, no-wrap
msgid ""
"B<mtrace>(),\n"
"B<muntrace>()"
msgstr "B<mtrace>(),\nB<muntrace>()"

#. type: tbl table
#: man-pages/man3/mtrace.3:89
#, no-wrap
msgid "MT-Unsafe"
msgstr "MT-Unsafe"

#. type: Plain text
#: man-pages/man3/mtrace.3:108
msgid ""
"In normal usage, B<mtrace>()  is called once at the start of execution of a "
"program, and B<muntrace>()  is never called."
msgstr "В обычной работе B<mtrace>() вызывается один раз в начале выполнения программы, а B<muntrace>() никогда не вызывается."

#. type: Plain text
#: man-pages/man3/mtrace.3:118
msgid ""
"The tracing output produced after a call to B<mtrace>()  is textual, but not"
" designed to be human readable.  The GNU C library provides a Perl script, "
"B<mtrace>(1), that interprets the trace log and produces human-readable "
"output.  For best results, the traced program should be compiled with "
"debugging enabled, so that line-number information is recorded in the "
"executable."
msgstr "Результат трассировки после вызова B<mtrace>() имеет текстовый формат, не предназначенный для чтения человеком. В библиотеке GNU C есть сценарий Perl, B<mtrace>(1), который преобразует журнал трассировки в читаемый вид. Для лучших результатов трассируемая программа должна быть скомпилирована с включённой отладкой для того, чтобы в исполняемый файл попала информация c номерами строк."

#. type: Plain text
#: man-pages/man3/mtrace.3:124
msgid ""
"The tracing performed by B<mtrace>()  incurs a performance penalty (if "
"B<MALLOC_TRACE> points to a valid, writable pathname)."
msgstr "Трассировка, выполняемая B<mtrace>(), ухудшает производительность (если B<MALLOC_TRACE> указывает на корректный, доступный на запись файл)."

#. type: Plain text
#: man-pages/man3/mtrace.3:130
msgid ""
"The line-number information produced by B<mtrace>(1)  is not always precise:"
" the line number references may refer to the previous or following "
"(nonblank)  line of the source code."
msgstr "Информация о номере строки, выдаваемая в B<mtrace>(1), не всегда точна: номер строки может ссылаться на предыдущую или следующую (не пустую) строку исходного кода."

#. type: Plain text
#: man-pages/man3/mtrace.3:137
msgid ""
"The shell session below demonstrates the use of the B<mtrace>()  function "
"and the B<mtrace>(1)  command in a program that has memory leaks at two "
"different locations.  The demonstration uses the following program:"
msgstr "Далее представлен пример работы функции B<mtrace>() и команды B<mtrace>(1) для программы с утечкой памяти в двух местах. Для демонстрации используется следующая программа:"

#. type: Plain text
#: man-pages/man3/mtrace.3:144
#, no-wrap
msgid ""
"$ B<cat t_mtrace.c>\n"
"#include E<lt>mcheck.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
msgstr "$ B<cat t_mtrace.c>\n#include E<lt>mcheck.hE<gt>\n#include E<lt>stdlib.hE<gt>\n#include E<lt>stdio.hE<gt>\n"

#. type: Plain text
#: man-pages/man3/mtrace.3:149
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int j;\n"
msgstr "int\nmain(int argc, char *argv[])\n{\n    int j;\n"

#. type: Plain text
#: man-pages/man3/mtrace.3:151
#, no-wrap
msgid "    mtrace();\n"
msgstr "    mtrace();\n"

#. type: Plain text
#: man-pages/man3/mtrace.3:154
#, no-wrap
msgid ""
"    for (j = 0; j E<lt> 2; j++)\n"
"        malloc(100);            /* Never freed--a memory leak */\n"
msgstr "    for (j = 0; j E<lt> 2; j++)\n        malloc(100);            /* никогда не освобождается — утечка памяти */\n"

#. type: Plain text
#: man-pages/man3/mtrace.3:158
#, no-wrap
msgid ""
"    calloc(16, 16);             /* Never freed--a memory leak */\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr "    calloc(16, 16);             /* Никогда не освобождается — утечка памяти */\n    exit(EXIT_SUCCESS);\n}\n"

#. type: Plain text
#: man-pages/man3/mtrace.3:164
msgid ""
"When we run the program as follows, we see that B<mtrace>()  diagnosed "
"memory leaks at two different locations in the program:"
msgstr "При выполнении этой программы мы видим, что B<mtrace>() обнаружила утечку памяти в двух местах программы:"

#. type: Plain text
#: man-pages/man3/mtrace.3:177
#, no-wrap
msgid ""
"$ B<cc -g t_mtrace.c -o t_mtrace>\n"
"$ B<export MALLOC_TRACE=/tmp/t>\n"
"$ B<./t_mtrace>\n"
"$ B<mtrace ./t_mtrace $MALLOC_TRACE>\n"
"Memory not freed:\n"
"-----------------\n"
"   Address     Size     Caller\n"
"0x084c9378     0x64  at /home/cecilia/t_mtrace.c:12\n"
"0x084c93e0     0x64  at /home/cecilia/t_mtrace.c:12\n"
"0x084c9448    0x100  at /home/cecilia/t_mtrace.c:16\n"
msgstr "$ B<cc -g t_mtrace.c -o t_mtrace>\n$ B<export MALLOC_TRACE=/tmp/t>\n$ B<./t_mtrace>\n$ B<mtrace ./t_mtrace $MALLOC_TRACE>\nMemory not freed:\n-----------------\n   Address     Size     Caller\n0x084c9378     0x64  at /home/cecilia/t_mtrace.c:12\n0x084c93e0     0x64  at /home/cecilia/t_mtrace.c:12\n0x084c9448    0x100  at /home/cecilia/t_mtrace.c:16\n"

#. type: Plain text
#: man-pages/man3/mtrace.3:189
msgid ""
"The first two messages about unfreed memory correspond to the two "
"B<malloc>(3)  calls inside the I<for> loop.  The final message corresponds "
"to the call to B<calloc>(3)  (which in turn calls B<malloc>(3))."
msgstr "Первые два сообщения о не освобожденной памяти относятся к двум вызовам B<malloc>(3), сделанным внутри цикла I<for>. Заключительное сообщение относится к вызову B<calloc>(3) (которая, в свою очередь, вызывает B<malloc>(3))."

#. type: Plain text
#: man-pages/man3/mtrace.3:193
msgid "B<mtrace>(1), B<malloc>(3), B<malloc_hook>(3), B<mcheck>(3)"
msgstr "B<mtrace>(1), B<malloc>(3), B<malloc_hook>(3), B<mcheck>(3)"

#. type: TH
#: man-pages/man3/mkfifo.3:28
#, no-wrap
msgid "MKFIFO"
msgstr "MKFIFO"

#. type: Plain text
#: man-pages/man3/mkfifo.3:31
msgid "mkfifo, mkfifoat - make a FIFO special file (a named pipe)"
msgstr "mkfifo, mkfifoat - создают специальный файл очереди FIFO (именованный канал)"

#. type: Plain text
#: man-pages/man3/mkfifo.3:35
#, no-wrap
msgid ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>sys/stat.hE<gt>>\n"
msgstr "B<#include E<lt>sys/types.hE<gt>>\nB<#include E<lt>sys/stat.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/mkfifo.3:37
#, no-wrap
msgid "B<int mkfifo(const char *>I<pathname>B<, mode_t >I<mode>B<);>\n"
msgstr "B<int mkfifo(const char *>I<pathname>B<, mode_t >I<mode>B<);>\n"

#. type: Plain text
#: man-pages/man3/mkfifo.3:42
#, no-wrap
msgid ""
"B<int mkfifoat(int >I<dirfd>B<, const char *>I<pathname>B<, mode_t "
">I<mode>B<);>\n"
msgstr "B<int mkfifoat(int >I<dirfd>B<, const char *>I<pathname>B<, mode_t >I<mode>B<);>\n"

#. type: Plain text
#: man-pages/man3/mkfifo.3:50
msgid "B<mkfifoat>():"
msgstr "B<mkfifoat>():"

#. type: Plain text
#: man-pages/man3/mkfifo.3:69
msgid ""
"B<mkfifo>()  makes a FIFO special file with name I<pathname>.  I<mode> "
"specifies the FIFO's permissions.  It is modified by the process's B<umask> "
"in the usual way: the permissions of the created file are B<(>I<mode>B< & "
"~umask)>."
msgstr "Функция B<mkfifo>() создаёт специальный файл FIFO с именем I<pathname> и правами доступа I<mode>. Как обычно, в правах учитывается значение I<umask> процесса: права на создаваемый файл вычисляются как B<(I<mode> & ~I<umask>)>."

#. type: Plain text
#: man-pages/man3/mkfifo.3:76
msgid ""
"A FIFO special file is similar to a pipe, except that it is created in a "
"different way.  Instead of being an anonymous communications channel, a FIFO"
" special file is entered into the filesystem by calling B<mkfifo>()."
msgstr "Специальный файл FIFO подобен каналу, за исключением того, что он создаётся другим способом. Вызов B<mkfifo>() вместо безымянного канала взаимодействия создаёт специальный файл FIFO, расположенный в файловой системе."

#. type: Plain text
#: man-pages/man3/mkfifo.3:86
msgid ""
"Once you have created a FIFO special file in this way, any process can open "
"it for reading or writing, in the same way as an ordinary file.  However, it"
" has to be open at both ends simultaneously before you can proceed to do any"
" input or output operations on it.  Opening a FIFO for reading normally "
"blocks until some other process opens the same FIFO for writing, and vice "
"versa.  See B<fifo>(7)  for nonblocking handling of FIFO special files."
msgstr "После создания специального файла  FIFO, любой процесс может открывать его для чтения или записи, как если бы он открывал обычный файл. Однако прежде чем вы сможете что-либо сделать, его необходимо открыть с обоих концов, притом одновременно. Открытие FIFO для чтения обычно блокируется, пока какой-нибудь другой процесс не откроет его для записи, и наоборот. Описание работы со специальными файлами FIFO в неблокирующем режиме смотрите в B<fifo>(7)."

#. type: SS
#: man-pages/man3/mkfifo.3:86
#, no-wrap
msgid "mkfifoat()"
msgstr "mkfifoat()"

#. type: Plain text
#: man-pages/man3/mkfifo.3:92
msgid ""
"The B<mkfifoat>()  function operates in exactly the same way as B<mkfifo>(),"
" except for the differences described here."
msgstr "Функция B<mkfifoat>() работает также как как B<mkfifo>(), за исключением случаев, описанных здесь."

#. type: Plain text
#: man-pages/man3/mkfifo.3:102
msgid ""
"If the pathname given in I<pathname> is relative, then it is interpreted "
"relative to the directory referred to by the file descriptor I<dirfd> "
"(rather than relative to the current working directory of the calling "
"process, as is done by B<mkfifo>()  for a relative pathname)."
msgstr "Если в I<pathname> задан относительный путь, то он считается относительно каталога, на который ссылается файловый дескриптор I<dirfd> (а не относительно текущего рабочего каталога вызывающего процесса, как это делается в B<mkfifo>(3))."

#. type: Plain text
#: man-pages/man3/mkfifo.3:114
msgid ""
"If I<pathname> is relative and I<dirfd> is the special value B<AT_FDCWD>, "
"then I<pathname> is interpreted relative to the current working directory of"
" the calling process (like B<mkfifo>())."
msgstr "Если в I<pathname> задан относительный путь и I<dirfd> равно специальному значению B<AT_FDCWD>, то I<pathname> рассматривается относительно текущего рабочего каталога вызывающего процесса (как B<mkfifo>(3))."

#. type: Plain text
#: man-pages/man3/mkfifo.3:128
msgid ""
"On success B<mkfifo>()  and B<mkfifoat>()  return 0.  In the case of an "
"error, -1 is returned (in which case, I<errno> is set appropriately)."
msgstr "При успешном выполнении вызовы B<mkfifo>() и B<mkfifoat>() возвращают 0. В случае ошибки возвращают -1, а I<errno> устанавливается в соответствующее значение."

#. type: Plain text
#: man-pages/man3/mkfifo.3:133
msgid ""
"One of the directories in I<pathname> did not allow search (execute) "
"permission."
msgstr "Один из каталогов содержащихся в I<pathname> не позволяет выполнить поиск, так как правами запрещено исполнение."

#. type: Plain text
#: man-pages/man3/mkfifo.3:151
msgid ""
"Either the total length of I<pathname> is greater than B<PATH_MAX>, or an "
"individual filename component has a length greater than B<NAME_MAX>.  In the"
" GNU system, there is no imposed limit on overall filename length, but some "
"filesystems may place limits on the length of a component."
msgstr "Если длина полного имени файла (включая путь)  I<pathname> больше чем B<PATH_MAX> или длина имени файла больше чем B<NAME_MAX>. В общем случае в системах, соответствующих стандарту GNU, отсутствует ограничение на длину полного имени файла, однако некоторые файловые системы могут устанавливать ограничение на длину отдельного компонента."

#. type: Plain text
#: man-pages/man3/mkfifo.3:158
msgid "The directory or filesystem has no room for the new file."
msgstr "В каталоге или файловой системе закончились места для новых файлов."

#. type: Plain text
#: man-pages/man3/mkfifo.3:165
msgid "I<pathname> refers to a read-only filesystem."
msgstr "I<pathname> указывает на файловую систему, доступную только для чтения."

#. type: Plain text
#: man-pages/man3/mkfifo.3:168
msgid "The following additional errors can occur for B<mkfifoat>():"
msgstr "Следующие дополнительные ошибки могут быть характерны для  B<mkfifoat>():"

#. type: Plain text
#: man-pages/man3/mkfifo.3:178
msgid ""
"I<pathname> is a relative path and I<dirfd> is a file descriptor referring "
"to a file other than a directory."
msgstr "I<pathname> является относительным путем, а I<dirfd> является файловым дескриптором, указывающим на файл, отличный от каталога."

#. type: Plain text
#: man-pages/man3/mkfifo.3:184
msgid ""
"B<mkfifoat>()  was added to glibc in version 2.4.  It is implemented using "
"B<mknodat>(2), available on Linux since kernel 2.6.16."
msgstr "Функция B<mkfifoat>() была добавлена в glibc 2.4. Она реализована с помощью системного вызова B<mknodat>(2), доступного в ядре Linux начиная с версии 2.6.16."

#. type: tbl table
#: man-pages/man3/mkfifo.3:195
#, no-wrap
msgid ""
"B<mkfifo>(),\n"
"B<mkfifoat>()"
msgstr "B<mkfifo>(),\nB<mkfifoat>()"

#. type: Plain text
#: man-pages/man3/mkfifo.3:200
msgid "B<mkfifo>(): POSIX.1-2001, POSIX.1-2008."
msgstr "B<mkfifo>(): POSIX.1-2001, POSIX.1-2008."

#. type: Plain text
#: man-pages/man3/mkfifo.3:203
msgid "B<mkfifoat>(): POSIX.1-2008."
msgstr "B<mkfifoat>(): POSIX.1-2008."

#. type: Plain text
#: man-pages/man3/mkfifo.3:211
msgid ""
"B<mkfifo>(1), B<close>(2), B<open>(2), B<read>(2), B<stat>(2), B<umask>(2), "
"B<write>(2), B<fifo>(7)"
msgstr "B<mkfifo>(1), B<close>(2), B<open>(2), B<read>(2), B<stat>(2), B<umask>(2), B<write>(2), B<fifo>(7)"
