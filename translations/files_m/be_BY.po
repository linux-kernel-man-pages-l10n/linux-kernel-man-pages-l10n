# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# 
# Translators:
msgid ""
msgstr ""
"Project-Id-Version: translation of man-pages\n"
"POT-Creation-Date: 2019-08-26 09:26+0300\n"
"PO-Revision-Date: 2019-09-19 02:25+0000\n"
"Last-Translator: Yuri Kozlov <yuray@komyakino.ru>\n"
"Language-Team: Belarusian (Belarus) (http://www.transifex.com/kruvalig/man-pages/language/be_BY/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: be_BY\n"
"Plural-Forms: nplurals=4; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n%10<=4 && (n%100<12 || n%100>14) ? 1 : n%10==0 || (n%10>=5 && n%10<=9) || (n%100>=11 && n%100<=14)? 2 : 3);\n"

#. type: TH
#: man-pages/man4/msr.4:26
#, no-wrap
msgid "MSR"
msgstr ""

#. type: TH
#: man-pages/man4/msr.4:26
#, no-wrap
msgid "2009-03-31"
msgstr ""

#. type: TH
#: man-pages/man4/msr.4:26
#, no-wrap
msgid "Linux"
msgstr ""

#. type: TH
#: man-pages/man4/msr.4:26
#, no-wrap
msgid "Linux Programmer's Manual"
msgstr ""

#. type: SH
#: man-pages/man4/msr.4:27
#, no-wrap
msgid "NAME"
msgstr ""

#. type: Plain text
#: man-pages/man4/msr.4:29
msgid "msr - x86 CPU MSR access device"
msgstr ""

#. type: SH
#: man-pages/man4/msr.4:29
#, no-wrap
msgid "DESCRIPTION"
msgstr ""

#. type: Plain text
#: man-pages/man4/msr.4:36
msgid ""
"I</dev/cpu/CPUNUM/msr> provides an interface to read and write the model-"
"specific registers (MSRs) of an x86 CPU.  I<CPUNUM> is the number of the CPU"
" to access as listed in I</proc/cpuinfo>."
msgstr ""

#. type: Plain text
#: man-pages/man4/msr.4:42
msgid ""
"The register access is done by opening the file and seeking to the MSR "
"number as offset in the file, and then reading or writing in chunks of 8 "
"bytes.  An I/O transfer of more than 8 bytes means multiple reads or writes "
"of the same register."
msgstr ""

#. type: Plain text
#: man-pages/man4/msr.4:47
msgid ""
"This file is protected so that it can be read and written only by the user "
"I<root>, or members of the group I<root>."
msgstr ""

#. type: SH
#: man-pages/man4/msr.4:47
#, no-wrap
msgid "NOTES"
msgstr ""

#. type: Plain text
#: man-pages/man4/msr.4:53
msgid ""
"The I<msr> driver is not auto-loaded.  On modular kernels you might need to "
"use the following command to load it explicitly before use:"
msgstr ""

#. type: Plain text
#: man-pages/man4/msr.4:57
#, no-wrap
msgid "$ modprobe msr\n"
msgstr ""

#. type: SH
#: man-pages/man4/msr.4:60
#, no-wrap
msgid "SEE ALSO"
msgstr ""

#. type: Plain text
#: man-pages/man4/msr.4:63
msgid ""
"Intel Corporation Intel 64 and IA-32 Architectures Software Developer's "
"Manual Volume 3B Appendix B, for an overview of the Intel CPU MSRs."
msgstr ""

#. type: TH
#: man-pages/man4/mem.4:26
#, no-wrap
msgid "MEM"
msgstr ""

#. type: TH
#: man-pages/man4/mem.4:26
#, no-wrap
msgid "2015-01-02"
msgstr ""

#. type: Plain text
#: man-pages/man4/mem.4:29
msgid "mem, kmem, port - system memory, kernel memory and system ports"
msgstr ""

#. type: Plain text
#: man-pages/man4/mem.4:34
msgid ""
"I</dev/mem> is a character device file that is an image of the main memory "
"of the computer.  It may be used, for example, to examine (and even patch) "
"the system."
msgstr ""

#. type: Plain text
#: man-pages/man4/mem.4:39
msgid ""
"Byte addresses in I</dev/mem> are interpreted as physical memory addresses."
"  References to nonexistent locations cause errors to be returned."
msgstr ""

#. type: Plain text
#: man-pages/man4/mem.4:42
msgid ""
"Examining and patching is likely to lead to unexpected results when read-"
"only or write-only bits are present."
msgstr ""

#. type: Plain text
#: man-pages/man4/mem.4:49
msgid ""
"Since Linux 2.6.26, and depending on the architecture, the "
"B<CONFIG_STRICT_DEVMEM> kernel configuration option limits the areas which "
"can be accessed through this file.  For example: on x86, RAM access is not "
"allowed but accessing memory-mapped PCI regions is."
msgstr ""

#. type: Plain text
#: man-pages/man4/mem.4:51 man-pages/man4/mem.4:70 man-pages/man4/mem.4:84
msgid "It is typically created by:"
msgstr ""

#. type: Plain text
#: man-pages/man4/mem.4:56
#, no-wrap
msgid ""
"mknod -m 660 /dev/mem c 1 1\n"
"chown root:kmem /dev/mem\n"
msgstr ""

#. type: Plain text
#: man-pages/man4/mem.4:68
msgid ""
"The file I</dev/kmem> is the same as I</dev/mem>, except that the kernel "
"virtual memory rather than physical memory is accessed.  Since Linux 2.6.26,"
" this file is available only if the B<CONFIG_DEVKMEM> kernel configuration "
"option is enabled."
msgstr ""

#. type: Plain text
#: man-pages/man4/mem.4:75
#, no-wrap
msgid ""
"mknod -m 640 /dev/kmem c 1 2\n"
"chown root:kmem /dev/kmem\n"
msgstr ""

#. type: Plain text
#: man-pages/man4/mem.4:82
msgid ""
"I</dev/port> is similar to I</dev/mem>, but the I/O ports are accessed."
msgstr ""

#. type: Plain text
#: man-pages/man4/mem.4:89
#, no-wrap
msgid ""
"mknod -m 660 /dev/port c 1 4\n"
"chown root:kmem /dev/port\n"
msgstr ""

#. type: SH
#: man-pages/man4/mem.4:91
#, no-wrap
msgid "FILES"
msgstr ""

#. type: Plain text
#: man-pages/man4/mem.4:93
msgid "I</dev/mem>"
msgstr ""

#. type: Plain text
#: man-pages/man4/mem.4:95
msgid "I</dev/kmem>"
msgstr ""

#. type: Plain text
#: man-pages/man4/mem.4:97
msgid "I</dev/port>"
msgstr ""

#. type: Plain text
#: man-pages/man4/mem.4:100
msgid "B<chown>(1), B<mknod>(1), B<ioperm>(2)"
msgstr ""

#. type: TH
#: man-pages/man4/mouse.4:26
#, no-wrap
msgid "MOUSE"
msgstr ""

#. type: TH
#: man-pages/man4/mouse.4:26
#, no-wrap
msgid "2016-10-08"
msgstr ""

#. type: Plain text
#: man-pages/man4/mouse.4:29
msgid "mouse - serial mouse interface"
msgstr ""

#. type: SH
#: man-pages/man4/mouse.4:29
#, no-wrap
msgid "CONFIGURATION"
msgstr ""

#. type: Plain text
#: man-pages/man4/mouse.4:33
msgid ""
"Serial mice are connected to a serial RS232/V24 dialout line, see B<ttyS>(4)"
"  for a description."
msgstr ""

#. type: SS
#: man-pages/man4/mouse.4:34
#, no-wrap
msgid "Introduction"
msgstr ""

#. type: Plain text
#: man-pages/man4/mouse.4:36
msgid "The pinout of the usual 9 pin plug as used for serial mice is:"
msgstr ""

#. type: tbl table
#: man-pages/man4/mouse.4:40
#, no-wrap
msgid "pin"
msgstr ""

#. type: tbl table
#: man-pages/man4/mouse.4:40
#, no-wrap
msgid "name"
msgstr ""

#. type: tbl table
#: man-pages/man4/mouse.4:40
#, no-wrap
msgid "used for"
msgstr ""

#. type: tbl table
#: man-pages/man4/mouse.4:41 man-pages/man4/mouse.4:101
#: man-pages/man4/mouse.4:146 man-pages/man4/mouse.4:182
#, no-wrap
msgid "2"
msgstr ""

#. type: tbl table
#: man-pages/man4/mouse.4:41
#, no-wrap
msgid "RX"
msgstr ""

#. type: tbl table
#: man-pages/man4/mouse.4:41
#, no-wrap
msgid "Data"
msgstr ""

#. type: tbl table
#: man-pages/man4/mouse.4:42 man-pages/man4/mouse.4:102
#: man-pages/man4/mouse.4:147 man-pages/man4/mouse.4:183
#, no-wrap
msgid "3"
msgstr ""

#. type: tbl table
#: man-pages/man4/mouse.4:42
#, no-wrap
msgid "TX"
msgstr ""

#. type: tbl table
#: man-pages/man4/mouse.4:42
#, no-wrap
msgid "-12 V, Imax = 10 mA"
msgstr ""

#. type: tbl table
#: man-pages/man4/mouse.4:43 man-pages/man4/mouse.4:148
#, no-wrap
msgid "4"
msgstr ""

#. type: tbl table
#: man-pages/man4/mouse.4:43
#, no-wrap
msgid "DTR"
msgstr ""

#. type: tbl table
#: man-pages/man4/mouse.4:43 man-pages/man4/mouse.4:44
#, no-wrap
msgid "+12 V, Imax = 10 mA"
msgstr ""

#. type: tbl table
#: man-pages/man4/mouse.4:44
#, no-wrap
msgid "7"
msgstr ""

#. type: tbl table
#: man-pages/man4/mouse.4:44
#, no-wrap
msgid "RTS"
msgstr ""

#. type: tbl table
#: man-pages/man4/mouse.4:45 man-pages/man4/mouse.4:149
#, no-wrap
msgid "5"
msgstr ""

#. type: tbl table
#: man-pages/man4/mouse.4:45
#, no-wrap
msgid "GND"
msgstr ""

#. type: tbl table
#: man-pages/man4/mouse.4:45
#, no-wrap
msgid "Ground"
msgstr ""

#. type: Plain text
#: man-pages/man4/mouse.4:49
msgid "This is the specification, in fact 9 V suffices with most mice."
msgstr ""

#. type: Plain text
#: man-pages/man4/mouse.4:55
msgid ""
"The mouse driver can recognize a mouse by dropping RTS to low and raising it"
" again.  About 14 ms later the mouse will send 0x4D (\\(aqM\\(aq) on the "
"data line.  After a further 63 ms, a Microsoft-compatible 3-button mouse "
"will send 0x33 (\\(aq3\\(aq)."
msgstr ""

#. type: Plain text
#: man-pages/man4/mouse.4:67
msgid ""
"The relative mouse movement is sent as I<dx> (positive means right)  and "
"I<dy> (positive means down).  Various mice can operate at different speeds."
"  To select speeds, cycle through the speeds 9600, 4800, 2400, and 1200 "
"bit/s, each time writing the two characters from the table below and waiting"
" 0.1 seconds.  The following table shows available speeds and the strings "
"that select them:"
msgstr ""

#. type: tbl table
#: man-pages/man4/mouse.4:71
#, no-wrap
msgid "bit/s"
msgstr ""

#. type: tbl table
#: man-pages/man4/mouse.4:71
#, no-wrap
msgid "string"
msgstr ""

#. type: tbl table
#: man-pages/man4/mouse.4:72
#, no-wrap
msgid "9600"
msgstr ""

#. type: tbl table
#: man-pages/man4/mouse.4:72
#, no-wrap
msgid "*q"
msgstr ""

#. type: tbl table
#: man-pages/man4/mouse.4:73
#, no-wrap
msgid "4800"
msgstr ""

#. type: tbl table
#: man-pages/man4/mouse.4:73
#, no-wrap
msgid "*p"
msgstr ""

#. type: tbl table
#: man-pages/man4/mouse.4:74
#, no-wrap
msgid "2400"
msgstr ""

#. type: tbl table
#: man-pages/man4/mouse.4:74
#, no-wrap
msgid "*o"
msgstr ""

#. type: tbl table
#: man-pages/man4/mouse.4:75
#, no-wrap
msgid "1200"
msgstr ""

#. type: tbl table
#: man-pages/man4/mouse.4:75
#, no-wrap
msgid "*n"
msgstr ""

#. type: Plain text
#: man-pages/man4/mouse.4:79
msgid ""
"The first byte of a data packet can be used for synchronization purposes."
msgstr ""

#. type: SS
#: man-pages/man4/mouse.4:79
#, no-wrap
msgid "Microsoft protocol"
msgstr ""

#. type: Plain text
#: man-pages/man4/mouse.4:95
msgid ""
"The B<Microsoft> protocol uses 1 start bit, 7 data bits, no parity and one "
"stop bit at the speed of 1200 bits/sec.  Data is sent to RxD in 3-byte "
"packets.  The I<dx> and I<dy> movements are sent as two's-complement, I<lb> "
"(I<rb>)  are set when the left (right)  button is pressed:"
msgstr ""

#. type: tbl table
#: man-pages/man4/mouse.4:99 man-pages/man4/mouse.4:144
#: man-pages/man4/mouse.4:180
#, no-wrap
msgid "byte"
msgstr ""

#. type: tbl table
#: man-pages/man4/mouse.4:99 man-pages/man4/mouse.4:144
#: man-pages/man4/mouse.4:180
#, no-wrap
msgid "d6"
msgstr ""

#. type: tbl table
#: man-pages/man4/mouse.4:99 man-pages/man4/mouse.4:144
#: man-pages/man4/mouse.4:180
#, no-wrap
msgid "d5"
msgstr ""

#. type: tbl table
#: man-pages/man4/mouse.4:99 man-pages/man4/mouse.4:144
#: man-pages/man4/mouse.4:180
#, no-wrap
msgid "d4"
msgstr ""

#. type: tbl table
#: man-pages/man4/mouse.4:99 man-pages/man4/mouse.4:144
#: man-pages/man4/mouse.4:180
#, no-wrap
msgid "d3"
msgstr ""

#. type: tbl table
#: man-pages/man4/mouse.4:99 man-pages/man4/mouse.4:144
#: man-pages/man4/mouse.4:180
#, no-wrap
msgid "d2"
msgstr ""

#. type: tbl table
#: man-pages/man4/mouse.4:99 man-pages/man4/mouse.4:144
#: man-pages/man4/mouse.4:180
#, no-wrap
msgid "d1"
msgstr ""

#. type: tbl table
#: man-pages/man4/mouse.4:99 man-pages/man4/mouse.4:144
#: man-pages/man4/mouse.4:180
#, no-wrap
msgid "d0"
msgstr ""

#. type: tbl table
#: man-pages/man4/mouse.4:100 man-pages/man4/mouse.4:145
#: man-pages/man4/mouse.4:181
#, no-wrap
msgid "1"
msgstr ""

#. type: tbl table
#: man-pages/man4/mouse.4:100 man-pages/man4/mouse.4:145
#: man-pages/man4/mouse.4:181
#, no-wrap
msgid "lb"
msgstr ""

#. type: tbl table
#: man-pages/man4/mouse.4:100 man-pages/man4/mouse.4:145
#: man-pages/man4/mouse.4:181
#, no-wrap
msgid "rb"
msgstr ""

#. type: tbl table
#: man-pages/man4/mouse.4:100
#, no-wrap
msgid "dy7"
msgstr ""

#. type: tbl table
#: man-pages/man4/mouse.4:100 man-pages/man4/mouse.4:183
#, no-wrap
msgid "dy6"
msgstr ""

#. type: tbl table
#: man-pages/man4/mouse.4:100
#, no-wrap
msgid "dx7"
msgstr ""

#. type: tbl table
#: man-pages/man4/mouse.4:100 man-pages/man4/mouse.4:182
#, no-wrap
msgid "dx6"
msgstr ""

#. type: tbl table
#: man-pages/man4/mouse.4:101 man-pages/man4/mouse.4:102
#: man-pages/man4/mouse.4:145 man-pages/man4/mouse.4:146
#: man-pages/man4/mouse.4:147 man-pages/man4/mouse.4:148
#: man-pages/man4/mouse.4:149 man-pages/man4/mouse.4:181
#: man-pages/man4/mouse.4:182 man-pages/man4/mouse.4:183
#, no-wrap
msgid "0"
msgstr ""

#. type: tbl table
#: man-pages/man4/mouse.4:101 man-pages/man4/mouse.4:182
#, no-wrap
msgid "dx5"
msgstr ""

#. type: tbl table
#: man-pages/man4/mouse.4:101 man-pages/man4/mouse.4:182
#, no-wrap
msgid "dx4"
msgstr ""

#. type: tbl table
#: man-pages/man4/mouse.4:101 man-pages/man4/mouse.4:182
#, no-wrap
msgid "dx3"
msgstr ""

#. type: tbl table
#: man-pages/man4/mouse.4:101 man-pages/man4/mouse.4:182
#, no-wrap
msgid "dx2"
msgstr ""

#. type: tbl table
#: man-pages/man4/mouse.4:101 man-pages/man4/mouse.4:182
#, no-wrap
msgid "dx1"
msgstr ""

#. type: tbl table
#: man-pages/man4/mouse.4:101 man-pages/man4/mouse.4:182
#, no-wrap
msgid "dx0"
msgstr ""

#. type: tbl table
#: man-pages/man4/mouse.4:102 man-pages/man4/mouse.4:183
#, no-wrap
msgid "dy5"
msgstr ""

#. type: tbl table
#: man-pages/man4/mouse.4:102 man-pages/man4/mouse.4:183
#, no-wrap
msgid "dy4"
msgstr ""

#. type: tbl table
#: man-pages/man4/mouse.4:102 man-pages/man4/mouse.4:183
#, no-wrap
msgid "dy3"
msgstr ""

#. type: tbl table
#: man-pages/man4/mouse.4:102 man-pages/man4/mouse.4:183
#, no-wrap
msgid "dy2"
msgstr ""

#. type: tbl table
#: man-pages/man4/mouse.4:102 man-pages/man4/mouse.4:183
#, no-wrap
msgid "dy1"
msgstr ""

#. type: tbl table
#: man-pages/man4/mouse.4:102 man-pages/man4/mouse.4:183
#, no-wrap
msgid "dy0"
msgstr ""

#. type: SS
#: man-pages/man4/mouse.4:104
#, no-wrap
msgid "3-button Microsoft protocol"
msgstr ""

#. type: Plain text
#: man-pages/man4/mouse.4:113
msgid ""
"Original Microsoft mice only have two buttons.  However, there are some "
"three button mice which also use the Microsoft protocol.  Pressing or "
"releasing the middle button is reported by sending a packet with zero "
"movement and no buttons pressed.  (Thus, unlike for the other two buttons, "
"the status of the middle button is not reported in each packet.)"
msgstr ""

#. type: SS
#: man-pages/man4/mouse.4:113
#, no-wrap
msgid "Logitech protocol"
msgstr ""

#. type: Plain text
#: man-pages/man4/mouse.4:122
msgid ""
"Logitech serial 3-button mice use a different extension of the Microsoft "
"protocol: when the middle button is up, the above 3-byte packet is sent.  "
"When the middle button is down a 4-byte packet is sent, where the 4th byte "
"has value 0x20 (or at least has the 0x20 bit set).  In particular, a press "
"of the middle button is reported as 0,0,0,0x20 when no other buttons are "
"down."
msgstr ""

#. type: SS
#: man-pages/man4/mouse.4:122
#, no-wrap
msgid "Mousesystems protocol"
msgstr ""

#. type: Plain text
#: man-pages/man4/mouse.4:140
msgid ""
"The B<Mousesystems> protocol uses 1 start bit, 8 data bits, no parity and "
"two stop bits at the speed of 1200 bits/sec.  Data is sent to RxD in 5-byte "
"packets.  I<dx> is sent as the sum of the two two's-complement values, I<dy>"
" is send as negated sum of the two two's-complement values.  I<lb> (I<mb>, "
"I<rb>)  are cleared when the left (middle, right) button is pressed:"
msgstr ""

#. type: tbl table
#: man-pages/man4/mouse.4:144 man-pages/man4/mouse.4:180
#, no-wrap
msgid "d7"
msgstr ""

#. type: tbl table
#: man-pages/man4/mouse.4:145 man-pages/man4/mouse.4:181
#, no-wrap
msgid "mb"
msgstr ""

#. type: tbl table
#: man-pages/man4/mouse.4:146
#, no-wrap
msgid "dxa6"
msgstr ""

#. type: tbl table
#: man-pages/man4/mouse.4:146
#, no-wrap
msgid "dxa5"
msgstr ""

#. type: tbl table
#: man-pages/man4/mouse.4:146
#, no-wrap
msgid "dxa4"
msgstr ""

#. type: tbl table
#: man-pages/man4/mouse.4:146
#, no-wrap
msgid "dxa3"
msgstr ""

#. type: tbl table
#: man-pages/man4/mouse.4:146
#, no-wrap
msgid "dxa2"
msgstr ""

#. type: tbl table
#: man-pages/man4/mouse.4:146
#, no-wrap
msgid "dxa1"
msgstr ""

#. type: tbl table
#: man-pages/man4/mouse.4:146
#, no-wrap
msgid "dxa0"
msgstr ""

#. type: tbl table
#: man-pages/man4/mouse.4:147
#, no-wrap
msgid "dya6"
msgstr ""

#. type: tbl table
#: man-pages/man4/mouse.4:147
#, no-wrap
msgid "dya5"
msgstr ""

#. type: tbl table
#: man-pages/man4/mouse.4:147
#, no-wrap
msgid "dya4"
msgstr ""

#. type: tbl table
#: man-pages/man4/mouse.4:147
#, no-wrap
msgid "dya3"
msgstr ""

#. type: tbl table
#: man-pages/man4/mouse.4:147
#, no-wrap
msgid "dya2"
msgstr ""

#. type: tbl table
#: man-pages/man4/mouse.4:147
#, no-wrap
msgid "dya1"
msgstr ""

#. type: tbl table
#: man-pages/man4/mouse.4:147
#, no-wrap
msgid "dya0"
msgstr ""

#. type: tbl table
#: man-pages/man4/mouse.4:148
#, no-wrap
msgid "dxb6"
msgstr ""

#. type: tbl table
#: man-pages/man4/mouse.4:148
#, no-wrap
msgid "dxb5"
msgstr ""

#. type: tbl table
#: man-pages/man4/mouse.4:148
#, no-wrap
msgid "dxb4"
msgstr ""

#. type: tbl table
#: man-pages/man4/mouse.4:148
#, no-wrap
msgid "dxb3"
msgstr ""

#. type: tbl table
#: man-pages/man4/mouse.4:148
#, no-wrap
msgid "dxb2"
msgstr ""

#. type: tbl table
#: man-pages/man4/mouse.4:148
#, no-wrap
msgid "dxb1"
msgstr ""

#. type: tbl table
#: man-pages/man4/mouse.4:148
#, no-wrap
msgid "dxb0"
msgstr ""

#. type: tbl table
#: man-pages/man4/mouse.4:149
#, no-wrap
msgid "dyb6"
msgstr ""

#. type: tbl table
#: man-pages/man4/mouse.4:149
#, no-wrap
msgid "dyb5"
msgstr ""

#. type: tbl table
#: man-pages/man4/mouse.4:149
#, no-wrap
msgid "dyb4"
msgstr ""

#. type: tbl table
#: man-pages/man4/mouse.4:149
#, no-wrap
msgid "dyb3"
msgstr ""

#. type: tbl table
#: man-pages/man4/mouse.4:149
#, no-wrap
msgid "dyb2"
msgstr ""

#. type: tbl table
#: man-pages/man4/mouse.4:149
#, no-wrap
msgid "dyb1"
msgstr ""

#. type: tbl table
#: man-pages/man4/mouse.4:149
#, no-wrap
msgid "dyb0"
msgstr ""

#. type: Plain text
#: man-pages/man4/mouse.4:154
msgid ""
"Bytes 4 and 5 describe the change that occurred since bytes 2 and 3 were "
"transmitted."
msgstr ""

#. type: SS
#: man-pages/man4/mouse.4:154
#, no-wrap
msgid "Sun protocol"
msgstr ""

#. type: Plain text
#: man-pages/man4/mouse.4:159
msgid ""
"The B<Sun> protocol is the 3-byte version of the above 5-byte Mousesystems "
"protocol: the last two bytes are not sent."
msgstr ""

#. type: SS
#: man-pages/man4/mouse.4:159
#, no-wrap
msgid "MM protocol"
msgstr ""

#. type: Plain text
#: man-pages/man4/mouse.4:176
msgid ""
"The B<MM> protocol uses 1 start bit, 8 data bits, odd parity and one stop "
"bit at the speed of 1200 bits/sec.  Data is sent to RxD in 3-byte packets.  "
"I<dx> and I<dy> are sent as single signed values, the sign bit indicating a "
"negative value.  I<lb> (I<mb>, I<rb>)  are set when the left (middle, right)"
" button is pressed:"
msgstr ""

#. type: tbl table
#: man-pages/man4/mouse.4:181
#, no-wrap
msgid "dxs"
msgstr ""

#. type: tbl table
#: man-pages/man4/mouse.4:181
#, no-wrap
msgid "dys"
msgstr ""

#. type: TP
#: man-pages/man4/mouse.4:186
#, no-wrap
msgid "I</dev/mouse>"
msgstr ""

#. type: Plain text
#: man-pages/man4/mouse.4:189
msgid "A commonly used symbolic link pointing to a mouse device."
msgstr ""

#. type: Plain text
#: man-pages/man4/mouse.4:191
msgid "B<ttyS>(4), B<gpm>(8)"
msgstr ""

#. type: TH
#: man-pages/man1/memusage.1:24
#, no-wrap
msgid "MEMUSAGE"
msgstr ""

#. type: TH
#: man-pages/man1/memusage.1:24
#, no-wrap
msgid "2019-03-06"
msgstr ""

#. type: TH
#: man-pages/man1/memusage.1:24
#, no-wrap
msgid "GNU"
msgstr ""

#. type: TH
#: man-pages/man1/memusage.1:24
#, no-wrap
msgid "Linux user manual"
msgstr ""

#. type: Plain text
#: man-pages/man1/memusage.1:27
msgid "memusage - profile memory usage of a program"
msgstr ""

#. type: SH
#: man-pages/man1/memusage.1:27
#, no-wrap
msgid "SYNOPSIS"
msgstr ""

#. type: Plain text
#: man-pages/man1/memusage.1:29
msgid "B<memusage> [I<option>]... I<program> [I<programoption>]..."
msgstr ""

#. type: Plain text
#: man-pages/man1/memusage.1:53
msgid ""
"B<memusage> is a bash script which profiles memory usage of the program, "
"I<program>.  It preloads the B<libmemusage.so> library into the caller's "
"environment (via the B<LD_PRELOAD> environment variable; see B<ld.so>(8)).  "
"The B<libmemusage.so> library traces memory allocation by intercepting calls"
" to B<malloc>(3), B<calloc>(3), B<free>(3), and B<realloc>(3); optionally, "
"calls to B<mmap>(2), B<mremap>(2), and B<munmap>(2)  can also be "
"intercepted."
msgstr ""

#. type: Plain text
#: man-pages/man1/memusage.1:62
msgid ""
"B<memusage> can output the collected data in textual form, or it can use "
"B<memusagestat>(1)  (see the B<-p> option, below)  to create a PNG file "
"containing graphical representation of the collected data."
msgstr ""

#. type: SS
#: man-pages/man1/memusage.1:62
#, no-wrap
msgid "Memory usage summary"
msgstr ""

#. type: Plain text
#: man-pages/man1/memusage.1:66
msgid ""
"The \"Memory usage summary\" line output by B<memusage> contains three "
"fields:"
msgstr ""

#. type: TP
#: man-pages/man1/memusage.1:67
#, no-wrap
msgid "B<heap total>"
msgstr ""

#. type: Plain text
#: man-pages/man1/memusage.1:84
msgid ""
"Sum of I<size> arguments of all B<malloc>(3)  calls, products of arguments "
"(I<nmemb>*I<size>) of all B<calloc>(3)  calls, and sum of I<length> "
"arguments of all B<mmap>(2)  calls.  In the case of B<realloc>(3)  and "
"B<mremap>(2), if the new size of an allocation is larger than the previous "
"size, the sum of all such differences (new size minus old size) is added."
msgstr ""

#. type: TP
#: man-pages/man1/memusage.1:84
#, no-wrap
msgid "B<heap peak>"
msgstr ""

#. type: Plain text
#: man-pages/man1/memusage.1:98
msgid ""
"Maximum of all I<size> arguments of B<malloc>(3), all products of "
"I<nmemb>*I<size> of B<calloc>(3), all I<size> arguments of B<realloc>(3), "
"I<length> arguments of B<mmap>(2), and I<new_size> arguments of "
"B<mremap>(2)."
msgstr ""

#. type: TP
#: man-pages/man1/memusage.1:98
#, no-wrap
msgid "B<stack peak>"
msgstr ""

#. type: Plain text
#: man-pages/man1/memusage.1:105
msgid ""
"Before the first call to any monitored function, the stack pointer address "
"(base stack pointer) is saved.  After each function call, the actual stack "
"pointer address is read and the difference from the base stack pointer "
"computed.  The maximum of these differences is then the stack peak."
msgstr ""

#. type: Plain text
#: man-pages/man1/memusage.1:122
msgid ""
"Immediately following this summary line, a table shows the number calls, "
"total memory allocated or deallocated, and number of failed calls for each "
"intercepted function.  For B<realloc>(3)  and B<mremap>(2), the additional "
"field \"nomove\" shows reallocations that changed the address of a block, "
"and the additional \"dec\" field shows reallocations that decreased the size"
" of the block.  For B<realloc>(3), the additional field \"free\" shows "
"reallocations that caused a block to be freed (i.e., the reallocated size "
"was 0)."
msgstr ""

#. type: Plain text
#: man-pages/man1/memusage.1:131
msgid ""
"The \"realloc/total memory\" of the table output by B<memusage> does not "
"reflect cases where B<realloc>(3)  is used to reallocate a block of memory "
"to have a smaller size than previously.  This can cause sum of all \"total "
"memory\" cells (excluding \"free\")  to be larger than the \"free/total "
"memory\" cell."
msgstr ""

#. type: SS
#: man-pages/man1/memusage.1:131
#, no-wrap
msgid "Histogram for block sizes"
msgstr ""

#. type: Plain text
#: man-pages/man1/memusage.1:134
msgid ""
"The \"Histogram for block sizes\" provides a breakdown of memory allocations"
" into various bucket sizes."
msgstr ""

#. type: SH
#: man-pages/man1/memusage.1:134
#, no-wrap
msgid "OPTIONS"
msgstr ""

#. type: TP
#: man-pages/man1/memusage.1:135
#, no-wrap
msgid "B<-n\\ >I<name>,\\ B<--progname=>I<name>"
msgstr ""

#. type: Plain text
#: man-pages/man1/memusage.1:138
msgid "Name of the program file to profile."
msgstr ""

#. type: TP
#: man-pages/man1/memusage.1:138
#, no-wrap
msgid "B<-p\\ >I<file>,\\ B<--png=>I<file>"
msgstr ""

#. type: Plain text
#: man-pages/man1/memusage.1:142
msgid "Generate PNG graphic and store it in I<file>."
msgstr ""

#. type: TP
#: man-pages/man1/memusage.1:142
#, no-wrap
msgid "B<-d\\ >I<file>,\\ B<--data=>I<file>"
msgstr ""

#. type: Plain text
#: man-pages/man1/memusage.1:146
msgid "Generate binary data file and store it in I<file>."
msgstr ""

#. type: TP
#: man-pages/man1/memusage.1:146
#, no-wrap
msgid "B<-u>,\\ B<--unbuffered>"
msgstr ""

#. type: Plain text
#: man-pages/man1/memusage.1:149
msgid "Do not buffer output."
msgstr ""

#. type: TP
#: man-pages/man1/memusage.1:149
#, no-wrap
msgid "B<-b\\ >I<size>,\\ B<--buffer=>I<size>"
msgstr ""

#. type: Plain text
#: man-pages/man1/memusage.1:154
msgid "Collect I<size> entries before writing them out."
msgstr ""

#. type: TP
#: man-pages/man1/memusage.1:154
#, no-wrap
msgid "B<--no-timer>"
msgstr ""

#. type: Plain text
#: man-pages/man1/memusage.1:159
msgid "Disable timer-based (B<SIGPROF>)  sampling of stack pointer value."
msgstr ""

#. type: TP
#: man-pages/man1/memusage.1:159
#, no-wrap
msgid "B<-m>,\\ B<--mmap>"
msgstr ""

#. type: Plain text
#: man-pages/man1/memusage.1:166
msgid "Also trace B<mmap>(2), B<mremap>(2), and B<munmap>(2)."
msgstr ""

#. type: TP
#: man-pages/man1/memusage.1:166
#, no-wrap
msgid "B<-?>,\\ B<--help>"
msgstr ""

#. type: Plain text
#: man-pages/man1/memusage.1:169
msgid "Print help and exit."
msgstr ""

#. type: TP
#: man-pages/man1/memusage.1:169
#, no-wrap
msgid "B<--usage>"
msgstr ""

#. type: Plain text
#: man-pages/man1/memusage.1:172
msgid "Print a short usage message and exit."
msgstr ""

#. type: TP
#: man-pages/man1/memusage.1:172
#, no-wrap
msgid "B<-V>,\\ B<--version>"
msgstr ""

#. type: Plain text
#: man-pages/man1/memusage.1:175
msgid "Print version information and exit."
msgstr ""

#. type: TP
#: man-pages/man1/memusage.1:175
#, no-wrap
msgid "The following options apply only when generating graphical output:"
msgstr ""

#. type: TP
#: man-pages/man1/memusage.1:177
#, no-wrap
msgid "B<-t>,\\ B<--time-based>"
msgstr ""

#. type: Plain text
#: man-pages/man1/memusage.1:180
msgid ""
"Use time (rather than number of function calls) as the scale for the X axis."
msgstr ""

#. type: TP
#: man-pages/man1/memusage.1:180
#, no-wrap
msgid "B<-T>,\\ B<--total>"
msgstr ""

#. type: Plain text
#: man-pages/man1/memusage.1:183
msgid "Also draw a graph of total memory use."
msgstr ""

#. type: TP
#: man-pages/man1/memusage.1:183
#, no-wrap
msgid "B<--title=>I<name>"
msgstr ""

#. type: Plain text
#: man-pages/man1/memusage.1:188
msgid "Use I<name> as the title of the graph."
msgstr ""

#. type: TP
#: man-pages/man1/memusage.1:188
#, no-wrap
msgid "B<-x\\ >I<size>,\\ B<--x-size=>I<size>"
msgstr ""

#. type: Plain text
#: man-pages/man1/memusage.1:193
msgid "Make the graph I<size> pixels wide."
msgstr ""

#. type: TP
#: man-pages/man1/memusage.1:193
#, no-wrap
msgid "B<-y\\ >I<size>,\\ B<--y-size=>I<size>"
msgstr ""

#. type: Plain text
#: man-pages/man1/memusage.1:198
msgid "Make the graph I<size> pixels high."
msgstr ""

#. type: SH
#: man-pages/man1/memusage.1:198
#, no-wrap
msgid "EXIT STATUS"
msgstr ""

#. type: Plain text
#: man-pages/man1/memusage.1:200
msgid "Exit status is equal to the exit status of profiled program."
msgstr ""

#. type: SH
#: man-pages/man1/memusage.1:200
#, no-wrap
msgid "BUGS"
msgstr ""

#. type: Plain text
#: man-pages/man1/memusage.1:204
msgid ""
"To report bugs, see E<.UR http://www.gnu.org/software/libc/bugs.html> E<.UE>"
msgstr ""

#. type: SH
#: man-pages/man1/memusage.1:204
#, no-wrap
msgid "EXAMPLE"
msgstr ""

#. type: Plain text
#: man-pages/man1/memusage.1:211
msgid ""
"Below is a simple program that reallocates a block of memory in cycles that "
"rise to a peak before then cyclically reallocating the memory in smaller "
"blocks that return to zero.  After compiling the program and running the "
"following commands, a graph of the memory usage of the program can be found "
"in the file I<memusage.png>:"
msgstr ""

#. type: Plain text
#: man-pages/man1/memusage.1:235
#, no-wrap
msgid ""
"$ B<memusage --data=memusage.dat ./a.out>\n"
"\\&...\n"
"Memory usage summary: heap total: 45200, heap peak: 6440, stack peak: 224\n"
"        total calls  total memory  failed calls\n"
" malloc|         1           400             0\n"
"realloc|        40         44800             0  (nomove:40, dec:19, free:0)\n"
" calloc|         0             0             0\n"
"   free|         1           440\n"
"Histogram for block sizes:\n"
"  192-207             1   2% ================\n"
"\\&...\n"
" 2192-2207            1   2% ================\n"
" 2240-2255            2   4% =================================\n"
" 2832-2847            2   4% =================================\n"
" 3440-3455            2   4% =================================\n"
" 4032-4047            2   4% =================================\n"
" 4640-4655            2   4% =================================\n"
" 5232-5247            2   4% =================================\n"
" 5840-5855            2   4% =================================\n"
" 6432-6447            1   2% ================\n"
"$ B<memusagestat memusage.dat memusage.png>\n"
msgstr ""

#. type: SS
#: man-pages/man1/memusage.1:237
#, no-wrap
msgid "Program source"
msgstr ""

#. type: Plain text
#: man-pages/man1/memusage.1:241
#, no-wrap
msgid ""
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
msgstr ""

#. type: Plain text
#: man-pages/man1/memusage.1:243
#, no-wrap
msgid "#define CYCLES 20\n"
msgstr ""

#. type: Plain text
#: man-pages/man1/memusage.1:249
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"     int i, j;\n"
"     int *p;\n"
msgstr ""

#. type: Plain text
#: man-pages/man1/memusage.1:252
#, no-wrap
msgid ""
"     printf(\"malloc: %zd\\en\", sizeof(int) * 100);\n"
"     p = malloc(sizeof(int) * 100);\n"
msgstr ""

#. type: Plain text
#: man-pages/man1/memusage.1:258
#, no-wrap
msgid ""
"     for (i = 0; i E<lt> CYCLES; i++) {\n"
"         if (i E<lt> CYCLES / 2)\n"
"             j = i;\n"
"         else\n"
"             j--;\n"
msgstr ""

#. type: Plain text
#: man-pages/man1/memusage.1:261
#, no-wrap
msgid ""
"         printf(\"realloc: %zd\\en\", sizeof(int) * (j * 50 + 110));\n"
"         p = realloc(p, sizeof(int) * (j * 50 + 100));\n"
msgstr ""

#. type: Plain text
#: man-pages/man1/memusage.1:265
#, no-wrap
msgid ""
"         printf(\"realloc: %zd\\en\", sizeof(int) * ((j+1) * 150 + 110));\n"
"         p = realloc(p, sizeof(int) * ((j + 1) * 150 + 110));\n"
"     }\n"
msgstr ""

#. type: Plain text
#: man-pages/man1/memusage.1:269
#, no-wrap
msgid ""
"     free(p);\n"
"     exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man1/memusage.1:273
msgid "B<memusagestat>(1), B<mtrace>(1)  B<ld.so>(8)"
msgstr ""

#. type: TH
#: man-pages/man1/memusagestat.1:23
#, no-wrap
msgid "MEMUSAGESTAT"
msgstr ""

#. type: TH
#: man-pages/man1/memusagestat.1:23
#, no-wrap
msgid "Linux programmer's manual"
msgstr ""

#. type: Plain text
#: man-pages/man1/memusagestat.1:26
msgid "memusagestat - generate graphic from memory profiling data"
msgstr ""

#. type: Plain text
#: man-pages/man1/memusagestat.1:28
msgid "B<memusagestat> [I<option>]... I<datafile> [I<outfile>]"
msgstr ""

#. type: Plain text
#: man-pages/man1/memusagestat.1:39
msgid ""
"B<memusagestat> creates a PNG file containing a graphical representation of "
"the memory profiling data in the file I<datafile>; that file is generated "
"via the I<-d> (or I<--data>)  option of B<memusage>(1)."
msgstr ""

#. type: Plain text
#: man-pages/man1/memusagestat.1:47
msgid ""
"The red line in the graph shows the heap usage (allocated memory)  and the "
"green line shows the stack usage.  The x-scale is either the number of "
"memory-handling function calls or (if the I<-t> option is specified)  time."
msgstr ""

#. type: TP
#: man-pages/man1/memusagestat.1:48
#, no-wrap
msgid "B<-o\\ >I<file>,\\ B<--output=>I<file>"
msgstr ""

#. type: Plain text
#: man-pages/man1/memusagestat.1:51
msgid "Name of the output file."
msgstr ""

#. type: TP
#: man-pages/man1/memusagestat.1:51
#, no-wrap
msgid "B<-s\\ >I<string>,\\ B<--string=>I<string>"
msgstr ""

#. type: Plain text
#: man-pages/man1/memusagestat.1:56
msgid "Use I<string> as the title inside the output graph."
msgstr ""

#. type: TP
#: man-pages/man1/memusagestat.1:56
#, no-wrap
msgid "B<-t>,\\ B<--time>"
msgstr ""

#. type: Plain text
#: man-pages/man1/memusagestat.1:62
msgid "Also draw a graph of total memory consumption."
msgstr ""

#. type: Plain text
#: man-pages/man1/memusagestat.1:67
msgid "Make the output graph I<size> pixels wide."
msgstr ""

#. type: Plain text
#: man-pages/man1/memusagestat.1:72
msgid "Make the output graph I<size> pixels high."
msgstr ""

#. type: Plain text
#: man-pages/man1/memusagestat.1:75
msgid "Print a help message and exit."
msgstr ""

#. type: Plain text
#: man-pages/man1/memusagestat.1:88
msgid "See B<memusage>(1)."
msgstr ""

#. type: Plain text
#: man-pages/man1/memusagestat.1:90
msgid "B<memusage>(1), B<mtrace>(1)"
msgstr ""

#. type: TH
#: man-pages/man1/mtrace.1:23
#, no-wrap
msgid "MTRACE"
msgstr ""

#. type: TH
#: man-pages/man1/mtrace.1:23
#, no-wrap
msgid "2017-09-15"
msgstr ""

#. type: Plain text
#: man-pages/man1/mtrace.1:26
msgid "mtrace - interpret the malloc trace log"
msgstr ""

#. type: Plain text
#: man-pages/man1/mtrace.1:28
msgid "B<mtrace> [I<option>]... [I<binary>] I<mtracedata>"
msgstr ""

#. type: Plain text
#: man-pages/man1/mtrace.1:44
msgid ""
"B<mtrace> is a Perl script used to interpret and provide human readable "
"output of the trace log contained in the file I<mtracedata>, whose contents "
"were produced by B<mtrace>(3).  If I<binary> is provided, the output of "
"B<mtrace> also contains the source file name with line number information "
"for problem locations (assuming that I<binary> was compiled with debugging "
"information)."
msgstr ""

#. type: Plain text
#: man-pages/man1/mtrace.1:51
msgid ""
"For more information about the B<mtrace>(3)  function and B<mtrace> script "
"usage, see B<mtrace>(3)."
msgstr ""

#. type: TP
#: man-pages/man1/mtrace.1:52
#, no-wrap
msgid "B<--help>"
msgstr ""

#. type: TP
#: man-pages/man1/mtrace.1:55
#, no-wrap
msgid "B<--version>"
msgstr ""

#. type: Plain text
#: man-pages/man1/mtrace.1:62
msgid ""
"For bug reporting instructions, please see: E<.UR "
"http://www.gnu.org/software/libc/bugs.html> E<.UE .>"
msgstr ""

#. type: Plain text
#: man-pages/man1/mtrace.1:64
msgid "B<memusage>(1), B<mtrace>(3)"
msgstr ""

#. type: TH
#: man-pages/man7/mq_overview.7:26
#, no-wrap
msgid "MQ_OVERVIEW"
msgstr ""

#. type: Plain text
#: man-pages/man7/mq_overview.7:29
msgid "mq_overview - overview of POSIX message queues"
msgstr ""

#. type: Plain text
#: man-pages/man7/mq_overview.7:37
msgid ""
"POSIX message queues allow processes to exchange data in the form of "
"messages.  This API is distinct from that provided by System V message "
"queues (B<msgget>(2), B<msgsnd>(2), B<msgrcv>(2), etc.), but provides "
"similar functionality."
msgstr ""

#. type: Plain text
#: man-pages/man7/mq_overview.7:52
msgid ""
"Message queues are created and opened using B<mq_open>(3); this function "
"returns a I<message queue descriptor> (I<mqd_t>), which is used to refer to "
"the open message queue in later calls.  Each message queue is identified by "
"a name of the form I</somename>; that is, a null-terminated string of up to "
"B<NAME_MAX> (i.e., 255) characters consisting of an initial slash, followed "
"by one or more characters, none of which are slashes.  Two processes can "
"operate on the same queue by passing the same name to B<mq_open>(3)."
msgstr ""

#. type: Plain text
#: man-pages/man7/mq_overview.7:68
msgid ""
"Messages are transferred to and from a queue using B<mq_send>(3)  and "
"B<mq_receive>(3).  When a process has finished using the queue, it closes it"
" using B<mq_close>(3), and when the queue is no longer required, it can be "
"deleted using B<mq_unlink>(3).  Queue attributes can be retrieved and (in "
"some cases) modified using B<mq_getattr>(3)  and B<mq_setattr>(3).  A "
"process can request asynchronous notification of the arrival of a message on"
" a previously empty queue using B<mq_notify>(3)."
msgstr ""

#. type: Plain text
#: man-pages/man7/mq_overview.7:81
msgid ""
"A message queue descriptor is a reference to an I<open message queue "
"description> (see B<open>(2)).  After a B<fork>(2), a child inherits copies "
"of its parent's message queue descriptors, and these descriptors refer to "
"the same open message queue descriptions as the corresponding message queue "
"descriptors in the parent.  Corresponding message queue descriptors in the "
"two processes share the flags (I<mq_flags>)  that are associated with the "
"open message queue description."
msgstr ""

#. type: Plain text
#: man-pages/man7/mq_overview.7:94
msgid ""
"Each message has an associated I<priority>, and messages are always "
"delivered to the receiving process highest priority first.  Message "
"priorities range from 0 (low) to I<sysconf(_SC_MQ_PRIO_MAX)\\ -\\ 1> (high)."
"  On Linux, I<sysconf(_SC_MQ_PRIO_MAX)> returns 32768, but POSIX.1 requires "
"only that an implementation support at least priorities in the range 0 to "
"31; some implementations provide only this range."
msgstr ""

#. type: Plain text
#: man-pages/man7/mq_overview.7:97
msgid ""
"The remainder of this section describes some specific details of the Linux "
"implementation of POSIX message queues."
msgstr ""

#. type: SS
#: man-pages/man7/mq_overview.7:97
#, no-wrap
msgid "Library interfaces and system calls"
msgstr ""

#. type: Plain text
#: man-pages/man7/mq_overview.7:103
msgid ""
"In most cases the B<mq_*>()  library interfaces listed above are implemented"
" on top of underlying system calls of the same name.  Deviations from this "
"scheme are indicated in the following table:"
msgstr ""

#. type: tbl table
#: man-pages/man7/mq_overview.7:107
#, no-wrap
msgid "Library interface"
msgstr ""

#. type: tbl table
#: man-pages/man7/mq_overview.7:107
#, no-wrap
msgid "System call"
msgstr ""

#. type: tbl table
#: man-pages/man7/mq_overview.7:108
#, no-wrap
msgid "mq_close(3)"
msgstr ""

#. type: tbl table
#: man-pages/man7/mq_overview.7:108
#, no-wrap
msgid "close(2)"
msgstr ""

#. type: tbl table
#: man-pages/man7/mq_overview.7:109
#, no-wrap
msgid "mq_getattr(3)"
msgstr ""

#. type: tbl table
#: man-pages/man7/mq_overview.7:109 man-pages/man7/mq_overview.7:114
#, no-wrap
msgid "mq_getsetattr(2)"
msgstr ""

#. type: tbl table
#: man-pages/man7/mq_overview.7:110
#, no-wrap
msgid "mq_notify(3)"
msgstr ""

#. type: tbl table
#: man-pages/man7/mq_overview.7:110
#, no-wrap
msgid "mq_notify(2)"
msgstr ""

#. type: tbl table
#: man-pages/man7/mq_overview.7:111
#, no-wrap
msgid "mq_open(3)"
msgstr ""

#. type: tbl table
#: man-pages/man7/mq_overview.7:111
#, no-wrap
msgid "mq_open(2)"
msgstr ""

#. type: tbl table
#: man-pages/man7/mq_overview.7:112
#, no-wrap
msgid "mq_receive(3)"
msgstr ""

#. type: tbl table
#: man-pages/man7/mq_overview.7:112 man-pages/man7/mq_overview.7:115
#, no-wrap
msgid "mq_timedreceive(2)"
msgstr ""

#. type: tbl table
#: man-pages/man7/mq_overview.7:113
#, no-wrap
msgid "mq_send(3)"
msgstr ""

#. type: tbl table
#: man-pages/man7/mq_overview.7:113 man-pages/man7/mq_overview.7:116
#, no-wrap
msgid "mq_timedsend(2)"
msgstr ""

#. type: tbl table
#: man-pages/man7/mq_overview.7:114
#, no-wrap
msgid "mq_setattr(3)"
msgstr ""

#. type: tbl table
#: man-pages/man7/mq_overview.7:115
#, no-wrap
msgid "mq_timedreceive(3)"
msgstr ""

#. type: tbl table
#: man-pages/man7/mq_overview.7:116
#, no-wrap
msgid "mq_timedsend(3)"
msgstr ""

#. type: tbl table
#: man-pages/man7/mq_overview.7:117
#, no-wrap
msgid "mq_unlink(3)"
msgstr ""

#. type: tbl table
#: man-pages/man7/mq_overview.7:117
#, no-wrap
msgid "mq_unlink(2)"
msgstr ""

#. type: SS
#: man-pages/man7/mq_overview.7:120
#, no-wrap
msgid "Versions"
msgstr ""

#. type: Plain text
#: man-pages/man7/mq_overview.7:123
msgid ""
"POSIX message queues have been supported on Linux since kernel 2.6.6.  Glibc"
" support has been provided since version 2.3.4."
msgstr ""

#. type: SS
#: man-pages/man7/mq_overview.7:123
#, no-wrap
msgid "Kernel configuration"
msgstr ""

#. type: Plain text
#: man-pages/man7/mq_overview.7:128
msgid ""
"Support for POSIX message queues is configurable via the "
"B<CONFIG_POSIX_MQUEUE> kernel configuration option.  This option is enabled "
"by default."
msgstr ""

#. type: SS
#: man-pages/man7/mq_overview.7:128
#, no-wrap
msgid "Persistence"
msgstr ""

#. type: Plain text
#: man-pages/man7/mq_overview.7:133
msgid ""
"POSIX message queues have kernel persistence: if not removed by "
"B<mq_unlink>(3), a message queue will exist until the system is shut down."
msgstr ""

#. type: SS
#: man-pages/man7/mq_overview.7:133
#, no-wrap
msgid "Linking"
msgstr ""

#. type: Plain text
#: man-pages/man7/mq_overview.7:138
msgid ""
"Programs using the POSIX message queue API must be compiled with I<cc -lrt> "
"to link against the real-time library, I<librt>."
msgstr ""

#. type: SS
#: man-pages/man7/mq_overview.7:138
#, no-wrap
msgid "/proc interfaces"
msgstr ""

#. type: Plain text
#: man-pages/man7/mq_overview.7:142
msgid ""
"The following interfaces can be used to limit the amount of kernel memory "
"consumed by POSIX message queues and to set the default attributes for new "
"message queues:"
msgstr ""

#. type: TP
#: man-pages/man7/mq_overview.7:142
#, no-wrap
msgid "I</proc/sys/fs/mqueue/msg_default> (since Linux 3.5)"
msgstr ""

#. type: Plain text
#: man-pages/man7/mq_overview.7:166
msgid ""
"This file defines the value used for a new queue's I<mq_maxmsg> setting when"
" the queue is created with a call to B<mq_open>(3)  where I<attr> is "
"specified as NULL.  The default value for this file is 10.  The minimum and "
"maximum are as for I</proc/sys/fs/mqueue/msg_max>.  A new queue's default "
"I<mq_maxmsg> value will be the smaller of I<msg_default> and I<msg_max>.  Up"
" until Linux 2.6.28, the default I<mq_maxmsg> was 10; from Linux 2.6.28 to "
"Linux 3.4, the default was the value defined for the I<msg_max> limit."
msgstr ""

#. type: TP
#: man-pages/man7/mq_overview.7:166
#, no-wrap
msgid "I</proc/sys/fs/mqueue/msg_max>"
msgstr ""

#. type: Plain text
#: man-pages/man7/mq_overview.7:187
msgid ""
"This file can be used to view and change the ceiling value for the maximum "
"number of messages in a queue.  This value acts as a ceiling on the "
"I<attr-E<gt>mq_maxmsg> argument given to B<mq_open>(3).  The default value "
"for I<msg_max> is 10.  The minimum value is 1 (10 in kernels before 2.6.28)."
"  The upper limit is B<HARD_MSGMAX>.  The I<msg_max> limit is ignored for "
"privileged processes (B<CAP_SYS_RESOURCE>), but the B<HARD_MSGMAX> ceiling "
"is nevertheless imposed."
msgstr ""

#. type: Plain text
#: man-pages/man7/mq_overview.7:191
msgid "The definition of B<HARD_MSGMAX> has changed across kernel versions:"
msgstr ""

#. type: IP
#: man-pages/man7/mq_overview.7:192 man-pages/man7/mq_overview.7:195
#: man-pages/man7/mq_overview.7:198 man-pages/man7/mq_overview.7:246
#: man-pages/man7/mq_overview.7:249 man-pages/man7/mq_overview.7:251
#, no-wrap
msgid "*"
msgstr ""

#. type: Plain text
#: man-pages/man7/mq_overview.7:195
msgid "Up to Linux 2.6.32: I<131072\\ /\\ sizeof(void\\ *)>"
msgstr ""

#. type: Plain text
#: man-pages/man7/mq_overview.7:198
msgid "Linux 2.6.33 to 3.4: I<(32768\\ *\\ sizeof(void\\ *) / 4)>"
msgstr ""

#.  commit 5b5c4d1a1440e94994c73dddbad7be0676cd8b9a
#. type: Plain text
#: man-pages/man7/mq_overview.7:202
msgid "Since Linux 3.5: 65,536"
msgstr ""

#. type: TP
#: man-pages/man7/mq_overview.7:203
#, no-wrap
msgid "I</proc/sys/fs/mqueue/msgsize_default> (since Linux 3.5)"
msgstr ""

#. type: Plain text
#: man-pages/man7/mq_overview.7:230
msgid ""
"This file defines the value used for a new queue's I<mq_msgsize> setting "
"when the queue is created with a call to B<mq_open>(3)  where I<attr> is "
"specified as NULL.  The default value for this file is 8192 (bytes).  The "
"minimum and maximum are as for I</proc/sys/fs/mqueue/msgsize_max>.  If "
"I<msgsize_default> exceeds I<msgsize_max>, a new queue's default "
"I<mq_msgsize> value is capped to the I<msgsize_max> limit.  Up until Linux "
"2.6.28, the default I<mq_msgsize> was 8192; from Linux 2.6.28 to Linux 3.4, "
"the default was the value defined for the I<msgsize_max> limit."
msgstr ""

#. type: TP
#: man-pages/man7/mq_overview.7:230
#, no-wrap
msgid "I</proc/sys/fs/mqueue/msgsize_max>"
msgstr ""

#. type: Plain text
#: man-pages/man7/mq_overview.7:245
msgid ""
"This file can be used to view and change the ceiling on the maximum message "
"size.  This value acts as a ceiling on the I<attr-E<gt>mq_msgsize> argument "
"given to B<mq_open>(3).  The default value for I<msgsize_max> is 8192 bytes."
"  The minimum value is 128 (8192 in kernels before 2.6.28).  The upper limit"
" for I<msgsize_max> has varied across kernel versions:"
msgstr ""

#. type: Plain text
#: man-pages/man7/mq_overview.7:249
msgid "Before Linux 2.6.28, the upper limit is B<INT_MAX>."
msgstr ""

#. type: Plain text
#: man-pages/man7/mq_overview.7:251
msgid "From Linux 2.6.28 to 3.4, the limit is 1,048,576."
msgstr ""

#. type: Plain text
#: man-pages/man7/mq_overview.7:254
msgid "Since Linux 3.5, the limit is 16,777,216 (B<HARD_MSGSIZEMAX>)."
msgstr ""

#. type: Plain text
#: man-pages/man7/mq_overview.7:263
msgid ""
"The I<msgsize_max> limit is ignored for privileged process "
"(B<CAP_SYS_RESOURCE>), but, since Linux 3.5, the B<HARD_MSGSIZEMAX> ceiling "
"is enforced for privileged processes."
msgstr ""

#. type: TP
#: man-pages/man7/mq_overview.7:263
#, no-wrap
msgid "I</proc/sys/fs/mqueue/queues_max>"
msgstr ""

#. type: Plain text
#: man-pages/man7/mq_overview.7:275
msgid ""
"This file can be used to view and change the system-wide limit on the number"
" of message queues that can be created.  The default value for I<queues_max>"
" is 256.  No ceiling is imposed on the I<queues_max> limit; privileged "
"processes (B<CAP_SYS_RESOURCE>)  can exceed the limit (but see BUGS)."
msgstr ""

#. type: SS
#: man-pages/man7/mq_overview.7:275
#, no-wrap
msgid "Resource limit"
msgstr ""

#. type: Plain text
#: man-pages/man7/mq_overview.7:282
msgid ""
"The B<RLIMIT_MSGQUEUE> resource limit, which places a limit on the amount of"
" space that can be consumed by all of the message queues belonging to a "
"process's real user ID, is described in B<getrlimit>(2)."
msgstr ""

#. type: SS
#: man-pages/man7/mq_overview.7:282
#, no-wrap
msgid "Mounting the message queue filesystem"
msgstr ""

#. type: Plain text
#: man-pages/man7/mq_overview.7:288
msgid ""
"On Linux, message queues are created in a virtual filesystem.  (Other "
"implementations may also provide such a feature, but the details are likely "
"to differ.)  This filesystem can be mounted (by the superuser) using the "
"following commands:"
msgstr ""

#. type: Plain text
#: man-pages/man7/mq_overview.7:293
#, no-wrap
msgid ""
"#B< mkdir /dev/mqueue>\n"
"#B< mount -t mqueue none /dev/mqueue>\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/mq_overview.7:297
msgid "The sticky bit is automatically enabled on the mount directory."
msgstr ""

#. type: Plain text
#: man-pages/man7/mq_overview.7:304
msgid ""
"After the filesystem has been mounted, the message queues on the system can "
"be viewed and manipulated using the commands usually used for files (e.g., "
"B<ls>(1)  and B<rm>(1))."
msgstr ""

#. type: Plain text
#: man-pages/man7/mq_overview.7:307
msgid ""
"The contents of each file in the directory consist of a single line "
"containing information about the queue:"
msgstr ""

#. type: Plain text
#: man-pages/man7/mq_overview.7:312
#, no-wrap
msgid ""
"$B< cat /dev/mqueue/mymq>\n"
"QSIZE:129     NOTIFY:2    SIGNO:0    NOTIFY_PID:8260\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/mq_overview.7:316
msgid "These fields are as follows:"
msgstr ""

#. type: TP
#: man-pages/man7/mq_overview.7:316
#, no-wrap
msgid "B<QSIZE>"
msgstr ""

#. type: Plain text
#: man-pages/man7/mq_overview.7:319
msgid "Number of bytes of data in all messages in the queue (but see BUGS)."
msgstr ""

#. type: TP
#: man-pages/man7/mq_overview.7:319
#, no-wrap
msgid "B<NOTIFY_PID>"
msgstr ""

#. type: Plain text
#: man-pages/man7/mq_overview.7:325
msgid ""
"If this is nonzero, then the process with this PID has used B<mq_notify>(3)"
"  to register for asynchronous message notification, and the remaining "
"fields describe how notification occurs."
msgstr ""

#. type: TP
#: man-pages/man7/mq_overview.7:325
#, no-wrap
msgid "B<NOTIFY>"
msgstr ""

#. type: Plain text
#: man-pages/man7/mq_overview.7:335
msgid ""
"Notification method: 0 is B<SIGEV_SIGNAL>; 1 is B<SIGEV_NONE>; and 2 is "
"B<SIGEV_THREAD>."
msgstr ""

#. type: TP
#: man-pages/man7/mq_overview.7:335
#, no-wrap
msgid "B<SIGNO>"
msgstr ""

#. type: Plain text
#: man-pages/man7/mq_overview.7:339
msgid "Signal number to be used for B<SIGEV_SIGNAL>."
msgstr ""

#. type: SS
#: man-pages/man7/mq_overview.7:339
#, no-wrap
msgid "Linux implementation of message queue descriptors"
msgstr ""

#. type: Plain text
#: man-pages/man7/mq_overview.7:348
msgid ""
"On Linux, a message queue descriptor is actually a file descriptor.  (POSIX "
"does not require such an implementation.)  This means that a message queue "
"descriptor can be monitored using B<select>(2), B<poll>(2), or B<epoll>(7)."
"  This is not portable."
msgstr ""

#. type: Plain text
#: man-pages/man7/mq_overview.7:353
msgid ""
"The close-on-exec flag (see B<open>(2))  is automatically set on the file "
"descriptor returned by B<mq_open>(2)."
msgstr ""

#. type: SS
#: man-pages/man7/mq_overview.7:353
#, no-wrap
msgid "IPC namespaces"
msgstr ""

#. type: Plain text
#: man-pages/man7/mq_overview.7:357
msgid ""
"For a discussion of the interaction of POSIX message queue objects and IPC "
"namespaces, see B<ipc_namespaces>(7)."
msgstr ""

#. type: Plain text
#: man-pages/man7/mq_overview.7:367
msgid ""
"System V message queues (B<msgget>(2), B<msgsnd>(2), B<msgrcv>(2), etc.) are"
" an older API for exchanging messages between processes.  POSIX message "
"queues provide a better designed interface than System V message queues; on "
"the other hand POSIX message queues are less widely available (especially on"
" older systems) than System V message queues."
msgstr ""

#. type: Plain text
#: man-pages/man7/mq_overview.7:370
msgid ""
"Linux does not currently (2.6.26) support the use of access control lists "
"(ACLs) for POSIX message queues."
msgstr ""

#. type: Plain text
#: man-pages/man7/mq_overview.7:379
msgid ""
"In Linux versions 3.5 to 3.14, the kernel imposed a ceiling of 1024 "
"(B<HARD_QUEUESMAX>)  on the value to which the I<queues_max> limit could be "
"raised, and the ceiling was enforced even for privileged processes.  This "
"ceiling value was removed in Linux 3.14, and patches to stable kernels 3.5.x"
" to 3.13.x also removed the ceiling."
msgstr ""

#.  commit d6629859b36d
#.  commit de54b9ac253787c366bbfb28d901a31954eb3511
#. type: Plain text
#: man-pages/man7/mq_overview.7:393
msgid ""
"As originally implemented (and documented), the QSIZE field displayed the "
"total number of (user-supplied)  bytes in all messages in the message queue."
"  Some changes in Linux 3.5 inadvertently changed the behavior, so that this"
" field also included a count of kernel overhead bytes used to store the "
"messages in the queue.  This behavioral regression was rectified in Linux "
"4.2 (and earlier stable kernel series), so that the count once more included"
" just the bytes of user data in messages in the queue."
msgstr ""

#. type: Plain text
#: man-pages/man7/mq_overview.7:396
msgid ""
"An example of the use of various message queue functions is shown in "
"B<mq_notify>(3)."
msgstr ""

#. type: Plain text
#: man-pages/man7/mq_overview.7:409
msgid ""
"B<getrlimit>(2), B<mq_getsetattr>(2), B<poll>(2), B<select>(2), "
"B<mq_close>(3), B<mq_getattr>(3), B<mq_notify>(3), B<mq_open>(3), "
"B<mq_receive>(3), B<mq_send>(3), B<mq_unlink>(3), B<epoll>(7), "
"B<namespaces>(7)"
msgstr ""

#. type: TH
#: man-pages/man7/mailaddr.7:27
#, no-wrap
msgid "MAILADDR"
msgstr ""

#. type: TH
#: man-pages/man7/mailaddr.7:27
#, no-wrap
msgid "2017-05-03"
msgstr ""

#. type: TH
#: man-pages/man7/mailaddr.7:27
#, no-wrap
msgid "Linux User's Manual"
msgstr ""

#. type: Plain text
#: man-pages/man7/mailaddr.7:31
msgid "mailaddr - mail addressing description"
msgstr ""

#. type: Plain text
#: man-pages/man7/mailaddr.7:36
msgid ""
"This manual page gives a brief introduction to SMTP mail addresses, as used "
"on the Internet.  These addresses are in the general format"
msgstr ""

#. type: Plain text
#: man-pages/man7/mailaddr.7:38
msgid "  user@domain"
msgstr ""

#. type: Plain text
#: man-pages/man7/mailaddr.7:41
msgid ""
"where a domain is a hierarchical dot-separated list of subdomains.  These "
"examples are valid forms of the same address:"
msgstr ""

#. type: Plain text
#: man-pages/man7/mailaddr.7:43
msgid "  john.doe@monet.example.com"
msgstr ""

#. type: Plain text
#: man-pages/man7/mailaddr.7:45
msgid "  John Doe E<lt>john.doe@monet.example.comE<gt>"
msgstr ""

#. type: Plain text
#: man-pages/man7/mailaddr.7:47
msgid "  john.doe@monet.example.com (John Doe)"
msgstr ""

#. type: Plain text
#: man-pages/man7/mailaddr.7:51
msgid ""
"The domain part (\"monet.example.com\") is a mail-accepting domain.  It can "
"be a host and in the past it usually was, but it doesn't have to be.  The "
"domain part is not case sensitive."
msgstr ""

#. type: Plain text
#: man-pages/man7/mailaddr.7:59
msgid ""
"The local part (\"john.doe\") is often a username, but its meaning is "
"defined by the local software.  Sometimes it is case sensitive, although "
"that is unusual.  If you see a local-part that looks like garbage, it is "
"usually because of a gateway between an internal e-mail system and the net, "
"here are some examples:"
msgstr ""

#. type: Plain text
#: man-pages/man7/mailaddr.7:61
msgid "  \"surname/admd=telemail/c=us/o=hp/prmd=hp\"@some.where"
msgstr ""

#. type: Plain text
#: man-pages/man7/mailaddr.7:63
msgid "  USER%SOMETHING@some.where"
msgstr ""

#. type: Plain text
#: man-pages/man7/mailaddr.7:65
msgid "  machine!machine!name@some.where"
msgstr ""

#. type: Plain text
#: man-pages/man7/mailaddr.7:67
msgid "  I2461572@some.where"
msgstr ""

#. type: Plain text
#: man-pages/man7/mailaddr.7:71
msgid ""
"(These are, respectively, an X.400 gateway, a gateway to an arbitrary "
"internal mail system that lacks proper internet support, an UUCP gateway, "
"and the last one is just boring username policy.)"
msgstr ""

#. type: Plain text
#: man-pages/man7/mailaddr.7:77
msgid ""
"The real-name part (\"John Doe\") can either be placed before E<lt>E<gt>, or"
" in () at the end.  (Strictly speaking the two aren't the same, but the "
"difference is beyond the scope of this page.)  The name may have to be "
"quoted using \"\", for example, if it contains \".\":"
msgstr ""

#. type: Plain text
#: man-pages/man7/mailaddr.7:79
msgid "  \"John Q. Doe\" E<lt>john.doe@monet.example.comE<gt>"
msgstr ""

#. type: SS
#: man-pages/man7/mailaddr.7:79
#, no-wrap
msgid "Abbreviation"
msgstr ""

#. type: Plain text
#: man-pages/man7/mailaddr.7:87
msgid ""
"Some mail systems let users abbreviate the domain name.  For instance, users"
" at example.com may get away with \"john.doe@monet\" to send mail to John "
"Doe.  I<This behavior is deprecated.> Sometimes it works, but you should not"
" depend on it."
msgstr ""

#. type: SS
#: man-pages/man7/mailaddr.7:87
#, no-wrap
msgid "Route-addrs"
msgstr ""

#. type: Plain text
#: man-pages/man7/mailaddr.7:93
msgid ""
"In the past, sometimes one had to route a message through several hosts to "
"get it to its final destination.  Addresses which show these relays are "
"termed \"route-addrs\".  These use the syntax:"
msgstr ""

#. type: Plain text
#: man-pages/man7/mailaddr.7:95
msgid "  E<lt>@hosta,@hostb:user@hostcE<gt>"
msgstr ""

#. type: Plain text
#: man-pages/man7/mailaddr.7:99
msgid ""
"This specifies that the message should be sent to hosta, from there to "
"hostb, and finally to hostc.  Many hosts disregard route-addrs and send "
"directly to hostc."
msgstr ""

#. type: Plain text
#: man-pages/man7/mailaddr.7:104
msgid ""
"Route-addrs are very unusual now.  They occur sometimes in old mail "
"archives.  It is generally possible to ignore all but the \"user@hostc\" "
"part of the address to determine the actual address."
msgstr ""

#. type: SS
#: man-pages/man7/mailaddr.7:104
#, no-wrap
msgid "Postmaster"
msgstr ""

#. type: Plain text
#: man-pages/man7/mailaddr.7:110
msgid ""
"Every site is required to have a user or user alias designated "
"\"postmaster\" to which problems with the mail system may be addressed.  The"
" \"postmaster\" address is not case sensitive."
msgstr ""

#. type: Plain text
#: man-pages/man7/mailaddr.7:112
msgid "I</etc/aliases>"
msgstr ""

#. type: Plain text
#: man-pages/man7/mailaddr.7:114
msgid "I<~/.forward>"
msgstr ""

#. type: Plain text
#: man-pages/man7/mailaddr.7:119
msgid "B<mail>(1), B<aliases>(5), B<forward>(5), B<sendmail>(8)"
msgstr ""

#. type: Plain text
#: man-pages/man7/mailaddr.7:122
msgid "E<.UR http://www.ietf.org\\:/rfc\\:/rfc5322.txt> IETF RFC\\ 5322 E<.UE>"
msgstr ""

#. type: TH
#: man-pages/man7/mount_namespaces.7:26
#, no-wrap
msgid "MOUNT_NAMESPACES"
msgstr ""

#. type: TH
#: man-pages/man7/mount_namespaces.7:26
#, no-wrap
msgid "2019-08-02"
msgstr ""

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:29
msgid "mount_namespaces - overview of Linux mount namespaces"
msgstr ""

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:32
msgid "For an overview of namespaces, see B<namespaces>(7)."
msgstr ""

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:37
msgid ""
"Mount namespaces provide isolation of the list of mount points seen by the "
"processes in each namespace instance.  Thus, the processes in each of the "
"mount namespace instances will see distinct single-directory hierarchies."
msgstr ""

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:50
msgid ""
"The views provided by the I</proc/[pid]/mounts>, I</proc/[pid]/mountinfo>, "
"and I</proc/[pid]/mountstats> files (all described in B<proc>(5))  "
"correspond to the mount namespace in which the process with the PID I<[pid]>"
" resides.  (All of the processes that reside in the same mount namespace "
"will see the same view in these files.)"
msgstr ""

#.  ============================================================
#. type: Plain text
#: man-pages/man7/mount_namespaces.7:70
msgid ""
"When a process creates a new mount namespace using B<clone>(2)  or "
"B<unshare>(2)  with the B<CLONE_NEWNS> flag, the mount point list for the "
"new namespace is a I<copy> of the caller's mount point list.  Subsequent "
"modifications to the mount point list (B<mount>(2)  and B<umount>(2))  in "
"either mount namespace will not (by default) affect the mount point list "
"seen in the other namespace (but see the following discussion of shared "
"subtrees)."
msgstr ""

#. type: SS
#: man-pages/man7/mount_namespaces.7:70
#, no-wrap
msgid "Restrictions on mount namespaces"
msgstr ""

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:72
msgid "Note the following points with respect to mount namespaces:"
msgstr ""

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:77
msgid ""
"A mount namespace has an owner user namespace.  A mount namespace whose "
"owner user namespace is different from the owner user namespace of its "
"parent mount namespace is considered a less privileged mount namespace."
msgstr ""

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:84
msgid ""
"When creating a less privileged mount namespace, shared mounts are reduced "
"to slave mounts.  (Shared and slave mounts are discussed below.)  This "
"ensures that mappings performed in less privileged mount namespaces will not"
" propagate to more privileged mount namespaces."
msgstr ""

#.  FIXME .
#. 	What does "come as a single unit from more privileged mount" mean?
#. type: Plain text
#: man-pages/man7/mount_namespaces.7:97
msgid ""
"Mounts that come as a single unit from more privileged mount are locked "
"together and may not be separated in a less privileged mount namespace.  "
"(The B<unshare>(2)  B<CLONE_NEWNS> operation brings across all of the mounts"
" from the original mount namespace as a single unit, and recursive mounts "
"that propagate between mount namespaces propagate as a single unit.)"
msgstr ""

#.  commit 9566d6742852c527bf5af38af5cbb878dad75705
#.  Author: Eric W. Biederman <ebiederm@xmission.com>
#.  Date:   Mon Jul 28 17:26:07 2014 -0700
#.       mnt: Correct permission checks in do_remount
#. type: Plain text
#: man-pages/man7/mount_namespaces.7:118
msgid ""
"The B<mount>(2)  flags B<MS_RDONLY>, B<MS_NOSUID>, B<MS_NOEXEC>, and the "
"\"atime\" flags (B<MS_NOATIME>, B<MS_NODIRATIME>, B<MS_RELATIME>)  settings "
"become locked when propagated from a more privileged to a less privileged "
"mount namespace, and may not be changed in the less privileged mount "
"namespace."
msgstr ""

#.  (As of 3.18-rc1 (in Al Viro's 2014-08-30 vfs.git#for-next tree))
#. type: Plain text
#: man-pages/man7/mount_namespaces.7:127
msgid ""
"A file or directory that is a mount point in one namespace that is not a "
"mount point in another namespace, may be renamed, unlinked, or removed "
"(B<rmdir>(2))  in the mount namespace in which it is not a mount point "
"(subject to the usual permission checks).  Consequently, the mount point is "
"removed in the mount namespace where it was a mount point."
msgstr ""

#.  mtk: The change was in Linux 3.18, I think, with this commit:
#.      commit 8ed936b5671bfb33d89bc60bdcc7cf0470ba52fe
#.      Author: Eric W. Biederman <ebiederman@twitter.com>
#.      Date:   Tue Oct 1 18:33:48 2013 -0700
#.          vfs: Lazily remove mounts on unlinked files and directories.
#. type: Plain text
#: man-pages/man7/mount_namespaces.7:143
msgid ""
"Previously (before Linux 3.18), attempting to unlink, rename, or remove a "
"file or directory that was a mount point in another mount namespace would "
"result in the error B<EBUSY>.  That behavior had technical problems of "
"enforcement (e.g., for NFS)  and permitted denial-of-service attacks against"
" more privileged users.  (i.e., preventing individual files from being "
"updated by bind mounting on top of them)."
msgstr ""

#. type: SH
#: man-pages/man7/mount_namespaces.7:143
#, no-wrap
msgid "SHARED SUBTREES"
msgstr ""

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:158
msgid ""
"After the implementation of mount namespaces was completed, experience "
"showed that the isolation that they provided was, in some cases, too great."
"  For example, in order to make a newly loaded optical disk available in all"
" mount namespaces, a mount operation was required in each namespace.  For "
"this use case, and others, the shared subtree feature was introduced in "
"Linux 2.6.15.  This feature allows for automatic, controlled propagation of "
"mount and unmount I<events> between namespaces (or, more precisely, between "
"the members of a I<peer group> that are propagating events to one another)."
msgstr ""

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:163
msgid ""
"Each mount point is marked (via B<mount>(2))  as having one of the following"
" I<propagation types>:"
msgstr ""

#. type: TP
#: man-pages/man7/mount_namespaces.7:163
#, no-wrap
msgid "B<MS_SHARED>"
msgstr ""

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:173
msgid ""
"This mount point shares events with members of a peer group.  Mount and "
"unmount events immediately under this mount point will propagate to the "
"other mount points that are members of the peer group.  I<Propagation> here "
"means that the same mount or unmount will automatically occur under all of "
"the other mount points in the peer group.  Conversely, mount and unmount "
"events that take place under peer mount points will propagate to this mount "
"point."
msgstr ""

#. type: TP
#: man-pages/man7/mount_namespaces.7:173
#, no-wrap
msgid "B<MS_PRIVATE>"
msgstr ""

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:177
msgid ""
"This mount point is private; it does not have a peer group.  Mount and "
"unmount events do not propagate into or out of this mount point."
msgstr ""

#. type: TP
#: man-pages/man7/mount_namespaces.7:177
#, no-wrap
msgid "B<MS_SLAVE>"
msgstr ""

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:182
msgid ""
"Mount and unmount events propagate into this mount point from a (master) "
"shared peer group.  Mount and unmount events under this mount point do not "
"propagate to any peer."
msgstr ""

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:187
msgid ""
"Note that a mount point can be the slave of another peer group while at the "
"same time sharing mount and unmount events with a peer group of which it is "
"a member.  (More precisely, one peer group can be the slave of another peer "
"group.)"
msgstr ""

#. type: TP
#: man-pages/man7/mount_namespaces.7:187
#, no-wrap
msgid "B<MS_UNBINDABLE>"
msgstr ""

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:196
msgid ""
"This is like a private mount, and in addition this mount can't be bind "
"mounted.  Attempts to bind mount this mount (B<mount>(2)  with the "
"B<MS_BIND> flag) will fail."
msgstr ""

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:207
msgid ""
"When a recursive bind mount (B<mount>(2)  with the B<MS_BIND> and B<MS_REC> "
"flags) is performed on a directory subtree, any bind mounts within the "
"subtree are automatically pruned (i.e., not replicated)  when replicating "
"that subtree to produce the target subtree."
msgstr ""

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:210
msgid ""
"For a discussion of the propagation type assigned to a new mount, see NOTES."
msgstr ""

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:216
msgid ""
"The propagation type is a per-mount-point setting; some mount points may be "
"marked as shared (with each shared mount point being a member of a distinct "
"peer group), while others are private (or slaved or unbindable)."
msgstr ""

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:227
msgid ""
"Note that a mount's propagation type determines whether mounts and unmounts "
"of mount points I<immediately under> the mount point are propagated.  Thus, "
"the propagation type does not affect propagation of events for grandchildren"
" and further removed descendant mount points.  What happens if the mount "
"point itself is unmounted is determined by the propagation type that is in "
"effect for the I<parent> of the mount point."
msgstr ""

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:231
msgid ""
"Members are added to a I<peer group> when a mount point is marked as shared "
"and either:"
msgstr ""

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:233
msgid ""
"the mount point is replicated during the creation of a new mount namespace; "
"or"
msgstr ""

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:235
msgid "a new bind mount is created from the mount point."
msgstr ""

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:238
msgid ""
"In both of these cases, the new mount point joins the peer group of which "
"the existing mount point is a member."
msgstr ""

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:244
msgid ""
"A new peer group is also created when a child mount point is created under "
"an existing mount point that is marked as shared.  In this case, the new "
"child mount point is also marked as shared and the resulting peer group "
"consists of all the mount points that are replicated under the peers of "
"parent mount."
msgstr ""

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:249
msgid ""
"A mount ceases to be a member of a peer group when either the mount is "
"explicitly unmounted, or when the mount is implicitly unmounted because a "
"mount namespace is removed (because it has no more member processes)."
msgstr ""

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:258
msgid ""
"The propagation type of the mount points in a mount namespace can be "
"discovered via the \"optional fields\" exposed in I</proc/[pid]/mountinfo>."
"  (See B<proc>(5)  for details of this file.)  The following tags can appear"
" in the optional fields for a record in that file:"
msgstr ""

#. type: TP
#: man-pages/man7/mount_namespaces.7:258
#, no-wrap
msgid "I<shared:X>"
msgstr ""

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:267
msgid ""
"This mount point is shared in peer group I<X>.  Each peer group has a unique"
" ID that is automatically generated by the kernel, and all mount points in "
"the same peer group will show the same ID.  (These IDs are assigned starting"
" from the value 1, and may be recycled when a peer group ceases to have any "
"members.)"
msgstr ""

#. type: TP
#: man-pages/man7/mount_namespaces.7:267
#, no-wrap
msgid "I<master:X>"
msgstr ""

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:271
msgid "This mount is a slave to shared peer group I<X>."
msgstr ""

#. type: TP
#: man-pages/man7/mount_namespaces.7:271
#, no-wrap
msgid "I<propagate_from:X> (since Linux 2.6.26)"
msgstr ""

#.  commit 97e7e0f71d6d948c25f11f0a33878d9356d9579e
#. type: Plain text
#: man-pages/man7/mount_namespaces.7:292
msgid ""
"This mount is a slave and receives propagation from shared peer group I<X>."
"  This tag will always appear in conjunction with a I<master:X> tag.  Here, "
"I<X> is the closest dominant peer group under the process's root directory."
"  If I<X> is the immediate master of the mount, or if there is no dominant "
"peer group under the same root, then only the I<master:X> field is present "
"and not the I<propagate_from:X> field.  For further details, see below."
msgstr ""

#. type: TP
#: man-pages/man7/mount_namespaces.7:292
#, no-wrap
msgid "I<unbindable>"
msgstr ""

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:295
msgid "This is an unbindable mount."
msgstr ""

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:297
msgid "If none of the above tags is present, then this is a private mount."
msgstr ""

#. type: SS
#: man-pages/man7/mount_namespaces.7:297
#, no-wrap
msgid "MS_SHARED and MS_PRIVATE example"
msgstr ""

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:302
msgid ""
"Suppose that on a terminal in the initial mount namespace, we mark one mount"
" point as shared and another as private, and then view the mounts in "
"I</proc/self/mountinfo>:"
msgstr ""

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:310
#, no-wrap
msgid ""
"sh1# B<mount --make-shared /mntS>\n"
"sh1# B<mount --make-private /mntP>\n"
"sh1# B<cat /proc/self/mountinfo | grep \\(aq/mnt\\(aq | sed \\(aqs/ - .*//\\(aq>\n"
"77 61 8:17 / /mntS rw,relatime shared:1\n"
"83 61 8:15 / /mntP rw,relatime\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:329
msgid ""
"From the I</proc/self/mountinfo> output, we see that I</mntS> is a shared "
"mount in peer group 1, and that I</mntP> has no optional tags, indicating "
"that it is a private mount.  The first two fields in each record in this "
"file are the unique ID for this mount, and the mount ID of the parent mount."
"  We can further inspect this file to see that the parent mount point of "
"I</mntS> and I</mntP> is the root directory, I</>, which is mounted as "
"private:"
msgstr ""

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:334
#, no-wrap
msgid ""
"sh1# B<cat /proc/self/mountinfo | awk \\(aq$1 == 61\\(aq | sed \\(aqs/ - .*//\\(aq>\n"
"61 0 8:2 / / rw,relatime\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:340
msgid ""
"On a second terminal, we create a new mount namespace where we run a second "
"shell and inspect the mounts:"
msgstr ""

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:347
#, no-wrap
msgid ""
"$ B<PS1=\\(aqsh2# \\(aq sudo unshare -m --propagation unchanged sh>\n"
"sh2# B<cat /proc/self/mountinfo | grep \\(aq/mnt\\(aq | sed \\(aqs/ - .*//\\(aq>\n"
"222 145 8:17 / /mntS rw,relatime shared:1\n"
"225 145 8:15 / /mntP rw,relatime\n"
msgstr ""

#.  Since util-linux 2.27
#. type: Plain text
#: man-pages/man7/mount_namespaces.7:361
msgid ""
"The new mount namespace received a copy of the initial mount namespace's "
"mount points.  These new mount points maintain the same propagation types, "
"but have unique mount IDs.  (The I<--propagation\\ unchanged> option "
"prevents B<unshare>(1)  from marking all mounts as private when creating a "
"new mount namespace, which it does by default.)"
msgstr ""

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:367
msgid ""
"In the second terminal, we then create submounts under each of I</mntS> and "
"I</mntP> and inspect the set-up:"
msgstr ""

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:379
#, no-wrap
msgid ""
"sh2# B<mkdir /mntS/a>\n"
"sh2# B<mount /dev/sdb6 /mntS/a>\n"
"sh2# B<mkdir /mntP/b>\n"
"sh2# B<mount /dev/sdb7 /mntP/b>\n"
"sh2# B<cat /proc/self/mountinfo | grep \\(aq/mnt\\(aq | sed \\(aqs/ - .*//\\(aq>\n"
"222 145 8:17 / /mntS rw,relatime shared:1\n"
"225 145 8:15 / /mntP rw,relatime\n"
"178 222 8:22 / /mntS/a rw,relatime shared:2\n"
"230 225 8:23 / /mntP/b rw,relatime\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:387
msgid ""
"From the above, it can be seen that I</mntS/a> was created as shared "
"(inheriting this setting from its parent mount) and I</mntP/b> was created "
"as a private mount."
msgstr ""

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:395
msgid ""
"Returning to the first terminal and inspecting the set-up, we see that the "
"new mount created under the shared mount point I</mntS> propagated to its "
"peer mount (in the initial mount namespace), but the new mount created under"
" the private mount point I</mntP> did not propagate:"
msgstr ""

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:402
#, no-wrap
msgid ""
"sh1# B<cat /proc/self/mountinfo | grep \\(aq/mnt\\(aq | sed \\(aqs/ - .*//\\(aq>\n"
"77 61 8:17 / /mntS rw,relatime shared:1\n"
"83 61 8:15 / /mntP rw,relatime\n"
"179 77 8:22 / /mntS/a rw,relatime shared:2\n"
msgstr ""

#. type: SS
#: man-pages/man7/mount_namespaces.7:405
#, no-wrap
msgid "MS_SLAVE example"
msgstr ""

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:414
msgid ""
"Making a mount point a slave allows it to receive propagated mount and "
"unmount events from a master shared peer group, while preventing it from "
"propagating events to that master.  This is useful if we want to (say) "
"receive a mount event when an optical disk is mounted in the master shared "
"peer group (in another mount namespace), but want to prevent mount and "
"unmount events under the slave mount from having side effects in other "
"namespaces."
msgstr ""

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:417
msgid ""
"We can demonstrate the effect of slaving by first marking two mount points "
"as shared in the initial mount namespace:"
msgstr ""

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:425
#, no-wrap
msgid ""
"sh1# B<mount --make-shared /mntX>\n"
"sh1# B<mount --make-shared /mntY>\n"
"sh1# B<cat /proc/self/mountinfo | grep \\(aq/mnt\\(aq | sed \\(aqs/ - .*//\\(aq>\n"
"132 83 8:23 / /mntX rw,relatime shared:1\n"
"133 83 8:22 / /mntY rw,relatime shared:2\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:430
msgid ""
"On a second terminal, we create a new mount namespace and inspect the mount "
"points:"
msgstr ""

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:437
#, no-wrap
msgid ""
"sh2# B<unshare -m --propagation unchanged sh>\n"
"sh2# B<cat /proc/self/mountinfo | grep \\(aq/mnt\\(aq | sed \\(aqs/ - .*//\\(aq>\n"
"168 167 8:23 / /mntX rw,relatime shared:1\n"
"169 167 8:22 / /mntY rw,relatime shared:2\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:441
msgid ""
"In the new mount namespace, we then mark one of the mount points as a slave:"
msgstr ""

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:448
#, no-wrap
msgid ""
"sh2# B<mount --make-slave /mntY>\n"
"sh2# B<cat /proc/self/mountinfo | grep \\(aq/mnt\\(aq | sed \\(aqs/ - .*//\\(aq>\n"
"168 167 8:23 / /mntX rw,relatime shared:1\n"
"169 167 8:22 / /mntY rw,relatime master:2\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:455
msgid ""
"From the above output, we see that I</mntY> is now a slave mount that is "
"receiving propagation events from the shared peer group with the ID 2."
msgstr ""

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:460
msgid ""
"Continuing in the new namespace, we create submounts under each of I</mntX> "
"and I</mntY>:"
msgstr ""

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:467
#, no-wrap
msgid ""
"sh2# B<mkdir /mntX/a>\n"
"sh2# B<mount /dev/sda3 /mntX/a>\n"
"sh2# B<mkdir /mntY/b>\n"
"sh2# B<mount /dev/sda5 /mntY/b>\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:477
msgid ""
"When we inspect the state of the mount points in the new mount namespace, we"
" see that I</mntX/a> was created as a new shared mount (inheriting the "
"\"shared\" setting from its parent mount) and I</mntY/b> was created as a "
"private mount:"
msgstr ""

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:485
#, no-wrap
msgid ""
"sh2# B<cat /proc/self/mountinfo | grep \\(aq/mnt\\(aq | sed \\(aqs/ - .*//\\(aq>\n"
"168 167 8:23 / /mntX rw,relatime shared:1\n"
"169 167 8:22 / /mntY rw,relatime master:2\n"
"173 168 8:3 / /mntX/a rw,relatime shared:3\n"
"175 169 8:5 / /mntY/b rw,relatime\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:496
msgid ""
"Returning to the first terminal (in the initial mount namespace), we see "
"that the mount I</mntX/a> propagated to the peer (the shared I</mntX>), but "
"the mount I</mntY/b> was not propagated:"
msgstr ""

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:503
#, no-wrap
msgid ""
"sh1# B<cat /proc/self/mountinfo | grep \\(aq/mnt\\(aq | sed \\(aqs/ - .*//\\(aq>\n"
"132 83 8:23 / /mntX rw,relatime shared:1\n"
"133 83 8:22 / /mntY rw,relatime shared:2\n"
"174 132 8:3 / /mntX/a rw,relatime shared:3\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:509
msgid "Now we create a new mount point under I</mntY> in the first shell:"
msgstr ""

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:519
#, no-wrap
msgid ""
"sh1# B<mkdir /mntY/c>\n"
"sh1# B<mount /dev/sda1 /mntY/c>\n"
"sh1# B<cat /proc/self/mountinfo | grep '/mnt' | sed 's/ - .*//'>\n"
"132 83 8:23 / /mntX rw,relatime shared:1\n"
"133 83 8:22 / /mntY rw,relatime shared:2\n"
"174 132 8:3 / /mntX/a rw,relatime shared:3\n"
"178 133 8:1 / /mntY/c rw,relatime shared:4\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:526
msgid ""
"When we examine the mount points in the second mount namespace, we see that "
"in this case the new mount has been propagated to the slave mount point, and"
" that the new mount is itself a slave mount (to peer group 4):"
msgstr ""

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:535
#, no-wrap
msgid ""
"sh2# B<cat /proc/self/mountinfo | grep \\(aq/mnt\\(aq | sed \\(aqs/ - .*//\\(aq>\n"
"168 167 8:23 / /mntX rw,relatime shared:1\n"
"169 167 8:22 / /mntY rw,relatime master:2\n"
"173 168 8:3 / /mntX/a rw,relatime shared:3\n"
"175 169 8:5 / /mntY/b rw,relatime\n"
"179 169 8:1 / /mntY/c rw,relatime master:4\n"
msgstr ""

#. type: SS
#: man-pages/man7/mount_namespaces.7:538
#, no-wrap
msgid "MS_UNBINDABLE example"
msgstr ""

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:543
msgid ""
"One of the primary purposes of unbindable mounts is to avoid the \"mount "
"point explosion\" problem when repeatedly performing bind mounts of a "
"higher-level subtree at a lower-level mount point.  The problem is "
"illustrated by the following shell session."
msgstr ""

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:545
msgid "Suppose we have a system with the following mount points:"
msgstr ""

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:552
#, no-wrap
msgid ""
"# B<mount | awk \\(aq{print $1, $2, $3}\\(aq>\n"
"/dev/sda1 on /\n"
"/dev/sdb6 on /mntX\n"
"/dev/sdb7 on /mntY\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:558
msgid ""
"Suppose furthermore that we wish to recursively bind mount the root "
"directory under several users' home directories.  We do this for the first "
"user, and inspect the mount points:"
msgstr ""

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:569
#, no-wrap
msgid ""
"# B<mount --rbind / /home/cecilia/>\n"
"# B<mount | awk \\(aq{print $1, $2, $3}\\(aq>\n"
"/dev/sda1 on /\n"
"/dev/sdb6 on /mntX\n"
"/dev/sdb7 on /mntY\n"
"/dev/sda1 on /home/cecilia\n"
"/dev/sdb6 on /home/cecilia/mntX\n"
"/dev/sdb7 on /home/cecilia/mntY\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:574
msgid ""
"When we repeat this operation for the second user, we start to see the "
"explosion problem:"
msgstr ""

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:591
#, no-wrap
msgid ""
"# B<mount --rbind / /home/henry>\n"
"# B<mount | awk \\(aq{print $1, $2, $3}\\(aq>\n"
"/dev/sda1 on /\n"
"/dev/sdb6 on /mntX\n"
"/dev/sdb7 on /mntY\n"
"/dev/sda1 on /home/cecilia\n"
"/dev/sdb6 on /home/cecilia/mntX\n"
"/dev/sdb7 on /home/cecilia/mntY\n"
"/dev/sda1 on /home/henry\n"
"/dev/sdb6 on /home/henry/mntX\n"
"/dev/sdb7 on /home/henry/mntY\n"
"/dev/sda1 on /home/henry/home/cecilia\n"
"/dev/sdb6 on /home/henry/home/cecilia/mntX\n"
"/dev/sdb7 on /home/henry/home/cecilia/mntY\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:605
msgid ""
"Under I</home/henry>, we have not only recursively added the I</mntX> and "
"I</mntY> mounts, but also the recursive mounts of those directories under "
"I</home/cecilia> that were created in the previous step.  Upon repeating the"
" step for a third user, it becomes obvious that the explosion is exponential"
" in nature:"
msgstr ""

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:634
#, no-wrap
msgid ""
"# B<mount --rbind / /home/otto>\n"
"# B<mount | awk \\(aq{print $1, $2, $3}\\(aq>\n"
"/dev/sda1 on /\n"
"/dev/sdb6 on /mntX\n"
"/dev/sdb7 on /mntY\n"
"/dev/sda1 on /home/cecilia\n"
"/dev/sdb6 on /home/cecilia/mntX\n"
"/dev/sdb7 on /home/cecilia/mntY\n"
"/dev/sda1 on /home/henry\n"
"/dev/sdb6 on /home/henry/mntX\n"
"/dev/sdb7 on /home/henry/mntY\n"
"/dev/sda1 on /home/henry/home/cecilia\n"
"/dev/sdb6 on /home/henry/home/cecilia/mntX\n"
"/dev/sdb7 on /home/henry/home/cecilia/mntY\n"
"/dev/sda1 on /home/otto\n"
"/dev/sdb6 on /home/otto/mntX\n"
"/dev/sdb7 on /home/otto/mntY\n"
"/dev/sda1 on /home/otto/home/cecilia\n"
"/dev/sdb6 on /home/otto/home/cecilia/mntX\n"
"/dev/sdb7 on /home/otto/home/cecilia/mntY\n"
"/dev/sda1 on /home/otto/home/henry\n"
"/dev/sdb6 on /home/otto/home/henry/mntX\n"
"/dev/sdb7 on /home/otto/home/henry/mntY\n"
"/dev/sda1 on /home/otto/home/henry/home/cecilia\n"
"/dev/sdb6 on /home/otto/home/henry/home/cecilia/mntX\n"
"/dev/sdb7 on /home/otto/home/henry/home/cecilia/mntY\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:642
msgid ""
"The mount explosion problem in the above scenario can be avoided by making "
"each of the new mounts unbindable.  The effect of doing this is that "
"recursive mounts of the root directory will not replicate the unbindable "
"mounts.  We make such a mount for the first user:"
msgstr ""

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:646
#, no-wrap
msgid "# B<mount --rbind --make-unbindable / /home/cecilia>\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:650
msgid ""
"Before going further, we show that unbindable mounts are indeed unbindable:"
msgstr ""

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:657
#, no-wrap
msgid ""
"# B<mkdir /mntZ>\n"
"# B<mount --bind /home/cecilia /mntZ>\n"
"mount: wrong fs type, bad option, bad superblock on /home/cecilia,\n"
"       missing codepage or helper program, or other error\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:660
#, no-wrap
msgid ""
"       In some cases useful info is found in syslog - try\n"
"       dmesg | tail or so.\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:664
msgid ""
"Now we create unbindable recursive bind mounts for the other two users:"
msgstr ""

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:669
#, no-wrap
msgid ""
"# B<mount --rbind --make-unbindable / /home/henry>\n"
"# B<mount --rbind --make-unbindable / /home/otto>\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:676
msgid ""
"Upon examining the list of mount points, we see there has been no explosion "
"of mount points, because the unbindable mounts were not replicated under "
"each user's directory:"
msgstr ""

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:692
#, no-wrap
msgid ""
"# B<mount | awk \\(aq{print $1, $2, $3}\\(aq>\n"
"/dev/sda1 on /\n"
"/dev/sdb6 on /mntX\n"
"/dev/sdb7 on /mntY\n"
"/dev/sda1 on /home/cecilia\n"
"/dev/sdb6 on /home/cecilia/mntX\n"
"/dev/sdb7 on /home/cecilia/mntY\n"
"/dev/sda1 on /home/henry\n"
"/dev/sdb6 on /home/henry/mntX\n"
"/dev/sdb7 on /home/henry/mntY\n"
"/dev/sda1 on /home/otto\n"
"/dev/sdb6 on /home/otto/mntX\n"
"/dev/sdb7 on /home/otto/mntY\n"
msgstr ""

#. type: SS
#: man-pages/man7/mount_namespaces.7:695
#, no-wrap
msgid "Propagation type transitions"
msgstr ""

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:704
msgid ""
"The following table shows the effect that applying a new propagation type "
"(i.e., I<mount --make-xxxx>)  has on the existing propagation type of a "
"mount point.  The rows correspond to existing propagation types, and the "
"columns are the new propagation settings.  For reasons of space, \"private\""
" is abbreviated as \"priv\" and \"unbindable\" as \"unbind\"."
msgstr ""

#. type: tbl table
#: man-pages/man7/mount_namespaces.7:707
#, no-wrap
msgid "make-shared"
msgstr ""

#. type: tbl table
#: man-pages/man7/mount_namespaces.7:707
#, no-wrap
msgid "make-slave"
msgstr ""

#. type: tbl table
#: man-pages/man7/mount_namespaces.7:707
#, no-wrap
msgid "make-priv"
msgstr ""

#. type: tbl table
#: man-pages/man7/mount_namespaces.7:707
#, no-wrap
msgid "make-unbind"
msgstr ""

#. type: tbl table
#: man-pages/man7/mount_namespaces.7:708 man-pages/man7/mount_namespaces.7:711
#: man-pages/man7/mount_namespaces.7:712 man-pages/man7/mount_namespaces.7:756
#: man-pages/man7/mount_namespaces.7:758 man-pages/man7/mount_namespaces.7:759
#: man-pages/man7/mount_namespaces.7:800 man-pages/man7/mount_namespaces.7:802
#: man-pages/man7/mount_namespaces.7:803
#, no-wrap
msgid "shared"
msgstr ""

#. type: tbl table
#: man-pages/man7/mount_namespaces.7:708
#, no-wrap
msgid "slave/priv [1]"
msgstr ""

#. type: tbl table
#: man-pages/man7/mount_namespaces.7:708 man-pages/man7/mount_namespaces.7:709
#: man-pages/man7/mount_namespaces.7:710 man-pages/man7/mount_namespaces.7:711
#: man-pages/man7/mount_namespaces.7:712
#, no-wrap
msgid "priv"
msgstr ""

#. type: tbl table
#: man-pages/man7/mount_namespaces.7:708 man-pages/man7/mount_namespaces.7:709
#: man-pages/man7/mount_namespaces.7:710 man-pages/man7/mount_namespaces.7:711
#: man-pages/man7/mount_namespaces.7:712 man-pages/man7/mount_namespaces.7:756
#: man-pages/man7/mount_namespaces.7:800
#, no-wrap
msgid "unbind"
msgstr ""

#. type: tbl table
#: man-pages/man7/mount_namespaces.7:709 man-pages/man7/mount_namespaces.7:710
#: man-pages/man7/mount_namespaces.7:756 man-pages/man7/mount_namespaces.7:759
#: man-pages/man7/mount_namespaces.7:800 man-pages/man7/mount_namespaces.7:803
#, no-wrap
msgid "slave"
msgstr ""

#. type: tbl table
#: man-pages/man7/mount_namespaces.7:709 man-pages/man7/mount_namespaces.7:710
#: man-pages/man7/mount_namespaces.7:758 man-pages/man7/mount_namespaces.7:802
#, no-wrap
msgid "slave+shared"
msgstr ""

#. type: tbl table
#: man-pages/man7/mount_namespaces.7:709
#, no-wrap
msgid "slave [2]"
msgstr ""

#. type: tbl table
#: man-pages/man7/mount_namespaces.7:711 man-pages/man7/mount_namespaces.7:756
#: man-pages/man7/mount_namespaces.7:759 man-pages/man7/mount_namespaces.7:800
#: man-pages/man7/mount_namespaces.7:803
#, no-wrap
msgid "private"
msgstr ""

#. type: tbl table
#: man-pages/man7/mount_namespaces.7:711
#, no-wrap
msgid "priv [2]"
msgstr ""

#. type: tbl table
#: man-pages/man7/mount_namespaces.7:712 man-pages/man7/mount_namespaces.7:803
#, no-wrap
msgid "unbindable"
msgstr ""

#. type: tbl table
#: man-pages/man7/mount_namespaces.7:712
#, no-wrap
msgid "unbind [2]"
msgstr ""

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:716
msgid "Note the following details to the table:"
msgstr ""

#. type: IP
#: man-pages/man7/mount_namespaces.7:716
#, no-wrap
msgid "[1]"
msgstr ""

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:719
msgid ""
"If a shared mount is the only mount in its peer group, making it a slave "
"automatically makes it private."
msgstr ""

#. type: IP
#: man-pages/man7/mount_namespaces.7:719
#, no-wrap
msgid "[2]"
msgstr ""

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:722
msgid "Slaving a nonshared mount has no effect on the mount."
msgstr ""

#. type: SS
#: man-pages/man7/mount_namespaces.7:722
#, no-wrap
msgid "Bind (MS_BIND) semantics"
msgstr ""

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:724 man-pages/man7/mount_namespaces.7:772
msgid "Suppose that the following command is performed:"
msgstr ""

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:728
#, no-wrap
msgid "mount --bind A/a B/b\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:750
msgid ""
"Here, I<A> is the source mount point, I<B> is the destination mount point, "
"I<a> is a subdirectory path under the mount point I<A>, and I<b> is a "
"subdirectory path under the mount point I<B>.  The propagation type of the "
"resulting mount, I<B/b>, depends on the propagation types of the mount "
"points I<A> and I<B>, and is summarized in the following table."
msgstr ""

#. type: tbl table
#: man-pages/man7/mount_namespaces.7:755 man-pages/man7/mount_namespaces.7:799
#, no-wrap
msgid "source(A)"
msgstr ""

#. type: tbl table
#: man-pages/man7/mount_namespaces.7:757 man-pages/man7/mount_namespaces.7:801
#, no-wrap
msgid "_"
msgstr ""

#. type: tbl table
#: man-pages/man7/mount_namespaces.7:758 man-pages/man7/mount_namespaces.7:802
#, no-wrap
msgid "dest(B)"
msgstr ""

#. type: tbl table
#: man-pages/man7/mount_namespaces.7:758 man-pages/man7/mount_namespaces.7:802
#, no-wrap
msgid "shared    |"
msgstr ""

#. type: tbl table
#: man-pages/man7/mount_namespaces.7:758 man-pages/man7/mount_namespaces.7:759
#: man-pages/man7/mount_namespaces.7:802
#, no-wrap
msgid "invalid"
msgstr ""

#. type: tbl table
#: man-pages/man7/mount_namespaces.7:759 man-pages/man7/mount_namespaces.7:803
#, no-wrap
msgid "nonshared |"
msgstr ""

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:765
msgid ""
"Note that a recursive bind of a subtree follows the same semantics as for a "
"bind operation on each mount in the subtree.  (Unbindable mounts are "
"automatically pruned at the target mount point.)"
msgstr ""

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:770 man-pages/man7/mount_namespaces.7:812
msgid ""
"For further details, see I<Documentation/filesystems/sharedsubtree.txt> in "
"the kernel source tree."
msgstr ""

#. type: SS
#: man-pages/man7/mount_namespaces.7:770
#, no-wrap
msgid "Move (MS_MOVE) semantics"
msgstr ""

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:776
#, no-wrap
msgid "mount --move A B/b\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:794
msgid ""
"Here, I<A> is the source mount point, I<B> is the destination mount point, "
"and I<b> is a subdirectory path under the mount point I<B>.  The propagation"
" type of the resulting mount, I<B/b>, depends on the propagation types of "
"the mount points I<A> and I<B>, and is summarized in the following table."
msgstr ""

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:807
msgid "Note: moving a mount that resides under a shared mount is invalid."
msgstr ""

#. type: SS
#: man-pages/man7/mount_namespaces.7:812
#, no-wrap
msgid "Mount semantics"
msgstr ""

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:814
msgid "Suppose that we use the following command to create a mount point:"
msgstr ""

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:818
#, no-wrap
msgid "mount device B/b\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:833
msgid ""
"Here, I<B> is the destination mount point, and I<b> is a subdirectory path "
"under the mount point I<B>.  The propagation type of the resulting mount, "
"I<B/b>, follows the same rules as for a bind mount, where the propagation "
"type of the source mount is considered always to be private."
msgstr ""

#. type: SS
#: man-pages/man7/mount_namespaces.7:833
#, no-wrap
msgid "Unmount semantics"
msgstr ""

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:835
msgid "Suppose that we use the following command to tear down a mount point:"
msgstr ""

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:839
#, no-wrap
msgid "unmount A\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:860
msgid ""
"Here, I<A> is a mount point on I<B/b>, where I<B> is the parent mount and "
"I<b> is a subdirectory path under the mount point I<B>.  If B<B> is shared, "
"then all most-recently-mounted mounts at I<b> on mounts that receive "
"propagation from mount I<B> and do not have submounts under them are "
"unmounted."
msgstr ""

#. type: SS
#: man-pages/man7/mount_namespaces.7:860
#, no-wrap
msgid "The /proc/[pid]/mountinfo propagate_from tag"
msgstr ""

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:870
msgid ""
"The I<propagate_from:X> tag is shown in the optional fields of a "
"I</proc/[pid]/mountinfo> record in cases where a process can't see a slave's"
" immediate master (i.e., the pathname of the master is not reachable from "
"the filesystem root directory)  and so cannot determine the chain of "
"propagation between the mounts it can see."
msgstr ""

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:885
msgid ""
"In the following example, we first create a two-link master-slave chain "
"between the mounts I</mnt>, I</tmp/etc>, and I</mnt/tmp/etc>.  Then the "
"B<chroot>(1)  command is used to make the I</tmp/etc> mount point "
"unreachable from the root directory, creating a situation where the master "
"of I</mnt/tmp/etc> is not reachable from the (new) root directory of the "
"process."
msgstr ""

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:898
msgid ""
"First, we bind mount the root directory onto I</mnt> and then bind mount "
"I</proc> at I</mnt/proc> so that after the later B<chroot>(1)  the "
"B<proc>(5)  filesystem remains visible at the correct location in the "
"chroot-ed environment."
msgstr ""

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:904
#, no-wrap
msgid ""
"# B<mkdir -p /mnt/proc>\n"
"# B<mount --bind / /mnt>\n"
"# B<mount --bind /proc /mnt/proc>\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:910
msgid ""
"Next, we ensure that the I</mnt> mount is a shared mount in a new peer group"
" (with no peers):"
msgstr ""

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:918
#, no-wrap
msgid ""
"# B<mount --make-private /mnt>  # Isolate from any previous peer group\n"
"# B<mount --make-shared /mnt>\n"
"# B<cat /proc/self/mountinfo | grep \\(aq/mnt\\(aq | sed \\(aqs/ - .*//\\(aq>\n"
"239 61 8:2 / /mnt ... shared:102\n"
"248 239 0:4 / /mnt/proc ... shared:5\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:925
msgid "Next, we bind mount I</mnt/etc> onto I</tmp/etc>:"
msgstr ""

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:934
#, no-wrap
msgid ""
"# B<mkdir -p /tmp/etc>\n"
"# B<mount --bind /mnt/etc /tmp/etc>\n"
"# B<cat /proc/self/mountinfo | egrep \\(aq/mnt|/tmp/\\(aq | sed \\(aqs/ - .*//\\(aq>\n"
"239 61 8:2 / /mnt ... shared:102\n"
"248 239 0:4 / /mnt/proc ... shared:5\n"
"267 40 8:2 /etc /tmp/etc ... shared:102\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:946
msgid ""
"Initially, these two mount points are in the same peer group, but we then "
"make the I</tmp/etc> a slave of I</mnt/etc>, and then make I</tmp/etc> "
"shared as well, so that it can propagate events to the next slave in the "
"chain:"
msgstr ""

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:955
#, no-wrap
msgid ""
"# B<mount --make-slave /tmp/etc>\n"
"# B<mount --make-shared /tmp/etc>\n"
"# B<cat /proc/self/mountinfo | egrep \\(aq/mnt|/tmp/\\(aq | sed \\(aqs/ - .*//\\(aq>\n"
"239 61 8:2 / /mnt ... shared:102\n"
"248 239 0:4 / /mnt/proc ... shared:5\n"
"267 40 8:2 /etc /tmp/etc ... shared:105 master:102\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:967
msgid ""
"Then we bind mount I</tmp/etc> onto I</mnt/tmp/etc>.  Again, the two mount "
"points are initially in the same peer group, but we then make "
"I</mnt/tmp/etc> a slave of I</tmp/etc>:"
msgstr ""

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:978
#, no-wrap
msgid ""
"# B<mkdir -p /mnt/tmp/etc>\n"
"# B<mount --bind /tmp/etc /mnt/tmp/etc>\n"
"# B<mount --make-slave /mnt/tmp/etc>\n"
"# B<cat /proc/self/mountinfo | egrep \\(aq/mnt|/tmp/\\(aq | sed \\(aqs/ - .*//\\(aq>\n"
"239 61 8:2 / /mnt ... shared:102\n"
"248 239 0:4 / /mnt/proc ... shared:5\n"
"267 40 8:2 /etc /tmp/etc ... shared:105 master:102\n"
"273 239 8:2 /etc /mnt/tmp/etc ... master:105\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:987
msgid ""
"From the above, we see that I</mnt> is the master of the slave I</tmp/etc>, "
"which in turn is the master of the slave I</mnt/tmp/etc>."
msgstr ""

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:994
msgid ""
"We then B<chroot>(1)  to the I</mnt> directory, which renders the mount with"
" ID 267 unreachable from the (new) root directory:"
msgstr ""

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:998
#, no-wrap
msgid "# B<chroot /mnt>\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:1003
msgid ""
"When we examine the state of the mounts inside the chroot-ed environment, we"
" see the following:"
msgstr ""

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:1010
#, no-wrap
msgid ""
"# B<cat /proc/self/mountinfo | sed \\(aqs/ - .*//\\(aq>\n"
"239 61 8:2 / / ... shared:102\n"
"248 239 0:4 / /proc ... shared:5\n"
"273 239 8:2 /etc /tmp/etc ... master:105 propagate_from:102\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:1025
msgid ""
"Above, we see that the mount with ID 273 is a slave whose master is the peer"
" group 105.  The mount point for that master is unreachable, and so a "
"I<propagate_from> tag is displayed, indicating that the closest dominant "
"peer group (i.e., the nearest reachable mount in the slave chain)  is the "
"peer group with the ID 102 (corresponding to the I</mnt> mount point before "
"the B<chroot>(1)  was performed."
msgstr ""

#. type: SH
#: man-pages/man7/mount_namespaces.7:1025
#, no-wrap
msgid "VERSIONS"
msgstr ""

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:1027
msgid "Mount namespaces first appeared in Linux 2.4.19."
msgstr ""

#. type: SH
#: man-pages/man7/mount_namespaces.7:1027
#, no-wrap
msgid "CONFORMING TO"
msgstr ""

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:1030
msgid "Namespaces are a Linux-specific feature."
msgstr ""

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:1040
msgid ""
"The propagation type assigned to a new mount point depends on the "
"propagation type of the parent mount.  If the mount point has a parent "
"(i.e., it is a non-root mount point) and the propagation type of the parent "
"is B<MS_SHARED>, then the propagation type of the new mount is also "
"B<MS_SHARED>.  Otherwise, the propagation type of the new mount is "
"B<MS_PRIVATE>."
msgstr ""

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:1053
msgid ""
"Notwithstanding the fact that the default propagation type for new mount "
"points is in many cases B<MS_PRIVATE>, B<MS_SHARED> is typically more "
"useful.  For this reason, B<systemd>(1)  automatically remounts all mount "
"points as B<MS_SHARED> on system startup.  Thus, on most modern systems, the"
" default propagation type is in practice B<MS_SHARED>."
msgstr ""

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:1068
msgid ""
"Since, when one uses B<unshare>(1)  to create a mount namespace, the goal is"
" commonly to provide full isolation of the mount points in the new "
"namespace, B<unshare>(1)  (since I<util-linux> version 2.27) in turn "
"reverses the step performed by B<systemd>(1), by making all mount points "
"private in the new namespace.  That is, B<unshare>(1)  performs the "
"equivalent of the following in the new mount namespace:"
msgstr ""

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:1072
#, no-wrap
msgid "mount --make-rprivate /\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:1079
msgid ""
"To prevent this, one can use the I<--propagation\\ unchanged> option to "
"B<unshare>(1)."
msgstr ""

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:1086
msgid ""
"For a discussion of propagation types when moving mounts (B<MS_MOVE>)  and "
"creating bind mounts (B<MS_BIND>), see "
"I<Documentation/filesystems/sharedsubtree.txt>."
msgstr ""

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:1099
msgid ""
"B<unshare>(1), B<clone>(2), B<mount>(2), B<pivot_root>(2), B<setns>(2), "
"B<umount>(2), B<unshare>(2), B<proc>(5), B<namespaces>(7), "
"B<user_namespaces>(7), B<findmnt>(8), B<pivot_root>(8)"
msgstr ""

#. type: Plain text
#: man-pages/man7/mount_namespaces.7:1101
msgid ""
"I<Documentation/filesystems/sharedsubtree.txt> in the kernel source tree."
msgstr ""

#. type: TH
#: man-pages/man7/man-pages.7:30
#, no-wrap
msgid "MAN-PAGES"
msgstr ""

#. type: Plain text
#: man-pages/man7/man-pages.7:33
msgid "man-pages - conventions for writing Linux man pages"
msgstr ""

#. type: Plain text
#: man-pages/man7/man-pages.7:37
msgid "B<man> [I<section>] I<title>"
msgstr ""

#. type: Plain text
#: man-pages/man7/man-pages.7:48
msgid ""
"This page describes the conventions that should be employed when writing man"
" pages for the Linux I<man-pages> project, which documents the user-space "
"API provided by the Linux kernel and the GNU C library.  The project thus "
"provides most of the pages in Section 2, many of the pages that appear in "
"Sections 3, 4, and 7, and a few of the pages that appear in Sections 1, 5, "
"and 8 of the man pages on a Linux system.  The conventions described on this"
" page may also be useful for authors writing man pages for other projects."
msgstr ""

#. type: SS
#: man-pages/man7/man-pages.7:48
#, no-wrap
msgid "Sections of the manual pages"
msgstr ""

#. type: Plain text
#: man-pages/man7/man-pages.7:51
msgid "The manual Sections are traditionally defined as follows:"
msgstr ""

#. type: TP
#: man-pages/man7/man-pages.7:51
#, no-wrap
msgid "B<1 User commands (Programs)>"
msgstr ""

#. type: Plain text
#: man-pages/man7/man-pages.7:55
msgid "Those commands that can be executed by the user from within a shell."
msgstr ""

#. type: TP
#: man-pages/man7/man-pages.7:55
#, no-wrap
msgid "B<2 System calls>"
msgstr ""

#. type: Plain text
#: man-pages/man7/man-pages.7:58
msgid "Those functions which wrap operations performed by the kernel."
msgstr ""

#. type: TP
#: man-pages/man7/man-pages.7:58
#, no-wrap
msgid "B<3 Library calls>"
msgstr ""

#. type: Plain text
#: man-pages/man7/man-pages.7:64
msgid ""
"All library functions excluding the system call wrappers (Most of the "
"I<libc> functions)."
msgstr ""

#. type: TP
#: man-pages/man7/man-pages.7:64
#, no-wrap
msgid "B<4 Special files (devices)>"
msgstr ""

#. type: Plain text
#: man-pages/man7/man-pages.7:69
msgid ""
"Files found in I</dev> which allow to access to devices through the kernel."
msgstr ""

#. type: TP
#: man-pages/man7/man-pages.7:69
#, no-wrap
msgid "B<5 File formats and configuration files>"
msgstr ""

#. type: Plain text
#: man-pages/man7/man-pages.7:72
msgid "Describes various human-readable file formats and configuration files."
msgstr ""

#. type: TP
#: man-pages/man7/man-pages.7:72
#, no-wrap
msgid "B<6 Games>"
msgstr ""

#. type: Plain text
#: man-pages/man7/man-pages.7:75
msgid "Games and funny little programs available on the system."
msgstr ""

#. type: TP
#: man-pages/man7/man-pages.7:75
#, no-wrap
msgid "B<7 Overview, conventions, and miscellaneous>"
msgstr ""

#. type: Plain text
#: man-pages/man7/man-pages.7:80
msgid ""
"Overviews or descriptions of various topics, conventions and protocols, "
"character set standards, the standard filesystem layout, and miscellaneous "
"other things."
msgstr ""

#. type: TP
#: man-pages/man7/man-pages.7:80
#, no-wrap
msgid "B<8 System management commands>"
msgstr ""

#.  .TP
#.  .B 9 Kernel routines
#.  This is an obsolete manual section.
#.  Once it was thought a good idea to document the Linux kernel here,
#.  but in fact very little has been documented, and the documentation
#.  that exists is outdated already.
#.  There are better sources of
#.  information for kernel developers.
#. type: Plain text
#: man-pages/man7/man-pages.7:93
msgid "Commands like B<mount>(8), many of which only root can execute."
msgstr ""

#. type: SS
#: man-pages/man7/man-pages.7:93
#, no-wrap
msgid "Macro package"
msgstr ""

#. type: Plain text
#: man-pages/man7/man-pages.7:100
msgid ""
"New manual pages should be marked up using the B<groff an.tmac> package "
"described in B<man>(7).  This choice is mainly for consistency: the vast "
"majority of existing Linux manual pages are marked up using these macros."
msgstr ""

#. type: SS
#: man-pages/man7/man-pages.7:100
#, no-wrap
msgid "Conventions for source file layout"
msgstr ""

#. type: Plain text
#: man-pages/man7/man-pages.7:105
msgid ""
"Please limit source code line length to no more than about 75 characters "
"wherever possible.  This helps avoid line-wrapping in some mail clients when"
" patches are submitted inline."
msgstr ""

#. type: SS
#: man-pages/man7/man-pages.7:105
#, no-wrap
msgid "Title line"
msgstr ""

#. type: Plain text
#: man-pages/man7/man-pages.7:109
msgid "The first command in a man page should be a B<TH> command:"
msgstr ""

#. type: Plain text
#: man-pages/man7/man-pages.7:113
msgid "B<\\&.TH> I<title section date source manual>"
msgstr ""

#. type: Plain text
#: man-pages/man7/man-pages.7:116
msgid "where:"
msgstr ""

#. type: TP
#: man-pages/man7/man-pages.7:117
#, no-wrap
msgid "I<title>"
msgstr ""

#. type: Plain text
#: man-pages/man7/man-pages.7:121
msgid "The title of the man page, written in all caps (e.g., I<MAN-PAGES>)."
msgstr ""

#. type: TP
#: man-pages/man7/man-pages.7:121
#, no-wrap
msgid "I<section>"
msgstr ""

#. type: Plain text
#: man-pages/man7/man-pages.7:125
msgid ""
"The section number in which the man page should be placed (e.g., I<7>)."
msgstr ""

#. type: TP
#: man-pages/man7/man-pages.7:125
#, no-wrap
msgid "I<date>"
msgstr ""

#. type: Plain text
#: man-pages/man7/man-pages.7:134
msgid ""
"The date of the last nontrivial change that was made to the man page.  "
"(Within the I<man-pages> project, the necessary updates to these timestamps "
"are handled automatically by scripts, so there is no need to manually update"
" them as part of a patch.)  Dates should be written in the form YYYY-MM-DD."
msgstr ""

#. type: TP
#: man-pages/man7/man-pages.7:134
#, no-wrap
msgid "I<source>"
msgstr ""

#. type: Plain text
#: man-pages/man7/man-pages.7:137
msgid "The source of the command, function, or system call."
msgstr ""

#. type: Plain text
#: man-pages/man7/man-pages.7:141
msgid ""
"For those few I<man-pages> pages in Sections 1 and 8, probably you just want"
" to write I<GNU>."
msgstr ""

#. type: Plain text
#: man-pages/man7/man-pages.7:149
msgid ""
"For system calls, just write I<Linux>.  (An earlier practice was to write "
"the version number of the kernel from which the manual page was being "
"written/checked.  However, this was never done consistently, and so was "
"probably worse than including no version number.  Henceforth, avoid "
"including a version number.)"
msgstr ""

#. type: Plain text
#: man-pages/man7/man-pages.7:154
msgid ""
"For library calls that are part of glibc or one of the other common GNU "
"libraries, just use I<GNU C Library>, I<GNU>, or an empty string."
msgstr ""

#. type: Plain text
#: man-pages/man7/man-pages.7:157
msgid "For Section 4 pages, use I<Linux>."
msgstr ""

#. type: Plain text
#: man-pages/man7/man-pages.7:160
msgid "In cases of doubt, just write I<Linux>, or I<GNU>."
msgstr ""

#. type: TP
#: man-pages/man7/man-pages.7:160
#, no-wrap
msgid "I<manual>"
msgstr ""

#. type: Plain text
#: man-pages/man7/man-pages.7:165
msgid ""
"The title of the manual (e.g., for Section 2 and 3 pages in the I<man-pages>"
" package, use I<Linux Programmer's Manual>)."
msgstr ""

#. type: SS
#: man-pages/man7/man-pages.7:166
#, no-wrap
msgid "Sections within a manual page"
msgstr ""

#. type: Plain text
#: man-pages/man7/man-pages.7:173
msgid ""
"The list below shows conventional or suggested sections.  Most manual pages "
"should include at least the B<highlighted> sections.  Arrange a new manual "
"page so that sections are placed in the order shown in the list."
msgstr ""

#.  May 07: Few current man pages have an ERROR HANDLING section,,,
#.  ERROR HANDLING,
#.  May 07: Almost no current man pages have a USAGE section,,,
#.  USAGE,
#.  DIAGNOSTICS,
#.  May 07: Almost no current man pages have a SECURITY section,,,
#.  SECURITY,
#.  AUTHORS sections are discouraged
#.  AUTHORS             [Discouraged]
#. type: Plain text
#: man-pages/man7/man-pages.7:202
#, no-wrap
msgid ""
"B<NAME>\n"
"B<SYNOPSIS>\n"
"CONFIGURATION      [Normally only in Section 4]\n"
"B<DESCRIPTION>\n"
"OPTIONS            [Normally only in Sections 1, 8]\n"
"EXIT STATUS        [Normally only in Sections 1, 8]\n"
"RETURN VALUE       [Normally only in Sections 2, 3]\n"
"ERRORS             [Typically only in Sections 2, 3]\n"
"ENVIRONMENT\n"
"FILES\n"
"VERSIONS           [Normally only in Sections 2, 3]\n"
"ATTRIBUTES         [Normally only in Sections 2, 3]\n"
"CONFORMING TO\n"
"NOTES\n"
"BUGS\n"
"EXAMPLE\n"
"B<SEE ALSO>\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/man-pages.7:213
msgid ""
"I<Where a traditional heading would apply>, I<please use it>; this kind of "
"consistency can make the information easier to understand.  If you must, you"
" can create your own headings if they make things easier to understand (this"
" can be especially useful for pages in Sections 4 and 5).  However, before "
"doing this, consider whether you could use the traditional headings, with "
"some subsections (I<.SS>) within those sections."
msgstr ""

#. type: Plain text
#: man-pages/man7/man-pages.7:216
msgid ""
"The following list elaborates on the contents of each of the above sections."
msgstr ""

#. type: TP
#: man-pages/man7/man-pages.7:216
#, no-wrap
msgid "B<NAME>"
msgstr ""

#. type: Plain text
#: man-pages/man7/man-pages.7:219
msgid "The name of this manual page."
msgstr ""

#. type: Plain text
#: man-pages/man7/man-pages.7:228
msgid ""
"See B<man>(7)  for important details of the line(s) that should follow the "
"B<.SH NAME> command.  All words in this line (including the word immediately"
" following the \"\\e-\") should be in lowercase, except where English or "
"technical terminological convention dictates otherwise."
msgstr ""

#. type: TP
#: man-pages/man7/man-pages.7:228
#, no-wrap
msgid "B<SYNOPSIS>"
msgstr ""

#. type: Plain text
#: man-pages/man7/man-pages.7:231
msgid "A brief summary of the command or function's interface."
msgstr ""

#. type: Plain text
#: man-pages/man7/man-pages.7:241
msgid ""
"For commands, this shows the syntax of the command and its arguments "
"(including options); boldface is used for as-is text and italics are used to"
" indicate replaceable arguments.  Brackets ([]) surround optional arguments,"
" vertical bars (|)  separate choices, and ellipses (\\&...) can be repeated."
"  For functions, it shows any required data declarations or B<#include> "
"directives, followed by the function declaration."
msgstr ""

#.  FIXME . Say something here about compiler options
#. type: Plain text
#: man-pages/man7/man-pages.7:247
msgid ""
"Where a feature test macro must be defined in order to obtain the "
"declaration of a function (or a variable) from a header file, then the "
"SYNOPSIS should indicate this, as described in B<feature_test_macros>(7)."
msgstr ""

#. type: TP
#: man-pages/man7/man-pages.7:247
#, no-wrap
msgid "B<CONFIGURATION>"
msgstr ""

#. type: Plain text
#: man-pages/man7/man-pages.7:250
msgid "Configuration details for a device."
msgstr ""

#. type: Plain text
#: man-pages/man7/man-pages.7:252
msgid "This section normally appears only in Section 4 pages."
msgstr ""

#. type: TP
#: man-pages/man7/man-pages.7:252
#, no-wrap
msgid "B<DESCRIPTION>"
msgstr ""

#. type: Plain text
#: man-pages/man7/man-pages.7:255
msgid "An explanation of what the program, function, or format does."
msgstr ""

#.  If there is some kind of input grammar or complex set of subcommands,
#.  consider describing them in a separate
#.  .B USAGE
#.  section (and just place an overview in the
#.  .B DESCRIPTION
#.  section).
#. type: Plain text
#: man-pages/man7/man-pages.7:270
msgid ""
"Discuss how it interacts with files and standard input, and what it produces"
" on standard output or standard error.  Omit internals and implementation "
"details unless they're critical for understanding the interface.  Describe "
"the usual case; for information on command-line options of a program use the"
" B<OPTIONS> section."
msgstr ""

#. type: Plain text
#: man-pages/man7/man-pages.7:278
msgid ""
"When describing new behavior or new flags for a system call or library "
"function, be careful to note the kernel or C library version that introduced"
" the change.  The preferred method of noting this information for flags is "
"as part of a B<.TP> list, in the following form (here, for a new system call"
" flag):"
msgstr ""

#. type: TP
#: man-pages/man7/man-pages.7:279
#, no-wrap
msgid "B<XYZ_FLAG> (since Linux 3.7)"
msgstr ""

#. type: Plain text
#: man-pages/man7/man-pages.7:282
msgid "Description of flag..."
msgstr ""

#. type: Plain text
#: man-pages/man7/man-pages.7:287
msgid ""
"Including version information is especially useful to users who are "
"constrained to using older kernel or C library versions (which is typical in"
" embedded systems, for example)."
msgstr ""

#. type: TP
#: man-pages/man7/man-pages.7:287
#, no-wrap
msgid "B<OPTIONS>"
msgstr ""

#. type: Plain text
#: man-pages/man7/man-pages.7:291
msgid ""
"A description of the command-line options accepted by a program and how they"
" change its behavior."
msgstr ""

#. type: Plain text
#: man-pages/man7/man-pages.7:296 man-pages/man7/man-pages.7:302
msgid "This section should appear only for Section 1 and 8 manual pages."
msgstr ""

#. type: TP
#: man-pages/man7/man-pages.7:296
#, no-wrap
msgid "B<EXIT STATUS>"
msgstr ""

#. type: Plain text
#: man-pages/man7/man-pages.7:300
msgid ""
"A list of the possible exit status values of a program and the conditions "
"that cause these values to be returned."
msgstr ""

#. type: TP
#: man-pages/man7/man-pages.7:302
#, no-wrap
msgid "B<RETURN VALUE>"
msgstr ""

#. type: Plain text
#: man-pages/man7/man-pages.7:307
msgid ""
"For Section 2 and 3 pages, this section gives a list of the values the "
"library routine will return to the caller and the conditions that cause "
"these values to be returned."
msgstr ""

#. type: TP
#: man-pages/man7/man-pages.7:307
#, no-wrap
msgid "B<ERRORS>"
msgstr ""

#. type: Plain text
#: man-pages/man7/man-pages.7:314
msgid ""
"For Section 2 and 3 manual pages, this is a list of the values that may be "
"placed in I<errno> in the event of an error, along with information about "
"the cause of the errors."
msgstr ""

#. type: Plain text
#: man-pages/man7/man-pages.7:322
msgid ""
"Where several different conditions produce the same error, the preferred "
"approach is to create separate list entries (with duplicate error names) for"
" each of the conditions.  This makes the separate conditions clear, may make"
" the list easier to read, and allows metainformation (e.g., kernel version "
"number where the condition first became applicable)  to be more easily "
"marked for each condition."
msgstr ""

#. type: Plain text
#: man-pages/man7/man-pages.7:324
msgid "I<The error list should be in alphabetical order>."
msgstr ""

#. type: TP
#: man-pages/man7/man-pages.7:324
#, no-wrap
msgid "B<ENVIRONMENT>"
msgstr ""

#. type: Plain text
#: man-pages/man7/man-pages.7:328
msgid ""
"A list of all environment variables that affect the program or function and "
"how they affect it."
msgstr ""

#. type: TP
#: man-pages/man7/man-pages.7:328
#, no-wrap
msgid "B<FILES>"
msgstr ""

#. type: Plain text
#: man-pages/man7/man-pages.7:333
msgid ""
"A list of the files the program or function uses, such as configuration "
"files, startup files, and files the program directly operates on."
msgstr ""

#.  May 07: Almost no current man pages have a DIAGNOSTICS section;
#.          "RETURN VALUE" or "EXIT STATUS" is preferred.
#.  .TP
#.  .B DIAGNOSTICS
#.  gives an overview of the most common error messages and how to
#.  cope with them.
#.  You don't need to explain system error messages
#.  or fatal signals that can appear during execution of any program
#.  unless they're special in some way to the program.
#.  May 07: Almost no current man pages have a SECURITY section.
#. .TP
#. .B SECURITY
#. discusses security issues and implications.
#. Warn about configurations or environments that should be avoided,
#. commands that may have security implications, and so on, especially
#. if they aren't obvious.
#. Discussing security in a separate section isn't necessary;
#. if it's easier to understand, place security information in the
#. other sections (such as the
#.  .B DESCRIPTION
#.  or
#.  .B USAGE
#.  section).
#.  However, please include security information somewhere!
#. type: Plain text
#: man-pages/man7/man-pages.7:366
msgid ""
"Give the full pathname of these files, and use the installation process to "
"modify the directory part to match user preferences.  For many programs, the"
" default installation location is in I</usr/local>, so your base manual page"
" should use I</usr/local> as the base."
msgstr ""

#. type: TP
#: man-pages/man7/man-pages.7:366
#, no-wrap
msgid "B<ATTRIBUTES>"
msgstr ""

#. type: Plain text
#: man-pages/man7/man-pages.7:372
msgid ""
"A summary of various attributes of the function(s) documented on this page."
"  See B<attributes>(7)  for further details."
msgstr ""

#. type: TP
#: man-pages/man7/man-pages.7:372
#, no-wrap
msgid "B<VERSIONS>"
msgstr ""

#. type: Plain text
#: man-pages/man7/man-pages.7:377
msgid ""
"A brief summary of the Linux kernel or glibc versions where a system call or"
" library function appeared, or changed significantly in its operation."
msgstr ""

#. type: Plain text
#: man-pages/man7/man-pages.7:390
msgid ""
"As a general rule, every new interface should include a VERSIONS section in "
"its manual page.  Unfortunately, many existing manual pages don't include "
"this information (since there was no policy to do so when they were "
"written).  Patches to remedy this are welcome, but, from the perspective of "
"programmers writing new code, this information probably matters only in the "
"case of kernel interfaces that have been added in Linux 2.4 or later (i.e., "
"changes since kernel 2.2), and library functions that have been added to "
"glibc since version 2.1 (i.e., changes since glibc 2.0)."
msgstr ""

#. type: Plain text
#: man-pages/man7/man-pages.7:395
msgid ""
"The B<syscalls>(2)  manual page also provides information about kernel "
"versions in which various system calls first appeared."
msgstr ""

#. type: TP
#: man-pages/man7/man-pages.7:395
#, no-wrap
msgid "B<CONFORMING TO>"
msgstr ""

#. type: Plain text
#: man-pages/man7/man-pages.7:399
msgid ""
"A description of any standards or conventions that relate to the function or"
" command described by the manual page."
msgstr ""

#. type: Plain text
#: man-pages/man7/man-pages.7:403
msgid ""
"The preferred terms to use for the various standards are listed as headings "
"in B<standards>(7)."
msgstr ""

#. type: Plain text
#: man-pages/man7/man-pages.7:412
msgid ""
"For a page in Section 2 or 3, this section should note the POSIX.1 "
"version(s) that the call conforms to, and also whether the call is specified"
" in C99.  (Don't worry too much about other standards like SUS, SUSv2, and "
"XPG, or the SVr4 and 4.xBSD implementation standards, unless the call was "
"specified in those standards, but isn't in the current version of POSIX.1.)"
msgstr ""

#. type: Plain text
#: man-pages/man7/man-pages.7:416
msgid ""
"If the call is not governed by any standards but commonly exists on other "
"systems, note them.  If the call is Linux-specific, note this."
msgstr ""

#. type: Plain text
#: man-pages/man7/man-pages.7:420
msgid ""
"If this section consists of just a list of standards (which it commonly "
"does), terminate the list with a period (\\(aq.\\(aq)."
msgstr ""

#. type: TP
#: man-pages/man7/man-pages.7:420
#, no-wrap
msgid "B<NOTES>"
msgstr ""

#. type: Plain text
#: man-pages/man7/man-pages.7:423
msgid "Miscellaneous notes."
msgstr ""

#. type: Plain text
#: man-pages/man7/man-pages.7:426
msgid ""
"For Section 2 and 3 man pages you may find it useful to include subsections "
"(B<SS>) named I<Linux Notes> and I<Glibc Notes>."
msgstr ""

#. type: Plain text
#: man-pages/man7/man-pages.7:432
msgid ""
"In Section 2, use the heading I<C library/kernel differences> to mark off "
"notes that describe the differences (if any) between the C library wrapper "
"function for a system call and the raw system call interface provided by the"
" kernel."
msgstr ""

#. type: TP
#: man-pages/man7/man-pages.7:432
#, no-wrap
msgid "B<BUGS>"
msgstr ""

#. type: Plain text
#: man-pages/man7/man-pages.7:436
msgid ""
"A list of limitations, known defects or inconveniences, and other "
"questionable activities."
msgstr ""

#. type: TP
#: man-pages/man7/man-pages.7:436
#, no-wrap
msgid "B<EXAMPLE>"
msgstr ""

#. type: Plain text
#: man-pages/man7/man-pages.7:440
msgid ""
"One or more examples demonstrating how this function, file or command is "
"used."
msgstr ""

#. type: Plain text
#: man-pages/man7/man-pages.7:443
msgid ""
"For details on writing example programs, see I<Example programs> below."
msgstr ""

#. type: TP
#: man-pages/man7/man-pages.7:443
#, no-wrap
msgid "B<AUTHORS>"
msgstr ""

#. type: Plain text
#: man-pages/man7/man-pages.7:446
msgid "A list of authors of the documentation or program."
msgstr ""

#. type: Plain text
#: man-pages/man7/man-pages.7:454
msgid ""
"B<Use of an AUTHORS section is strongly discouraged>.  Generally, it is "
"better not to clutter every page with a list of (over time potentially "
"numerous) authors; if you write or significantly amend a page, add a "
"copyright notice as a comment in the source file.  If you are the author of "
"a device driver and want to include an address for reporting bugs, place "
"this under the BUGS section."
msgstr ""

#. type: TP
#: man-pages/man7/man-pages.7:454
#, no-wrap
msgid "B<SEE ALSO>"
msgstr ""

#. type: Plain text
#: man-pages/man7/man-pages.7:458
msgid ""
"A comma-separated list of related man pages, possibly followed by other "
"related pages or documents."
msgstr ""

#. type: Plain text
#: man-pages/man7/man-pages.7:462
msgid ""
"The list should be ordered by section number and then alphabetically by "
"name.  Do not terminate this list with a period."
msgstr ""

#. type: Plain text
#: man-pages/man7/man-pages.7:473
msgid ""
"Where the SEE ALSO list contains many long manual page names, to improve the"
" visual result of the output, it may be useful to employ the I<.ad l> (don't"
" right justify)  and I<.nh> (don't hyphenate)  directives.  Hyphenation of "
"individual page names can be prevented by preceding words with the string "
"\"\\e%\"."
msgstr ""

#. type: Plain text
#: man-pages/man7/man-pages.7:478
msgid ""
"Given the distributed, autonomous nature of FOSS projects and their "
"documentation, it is sometimes necessary\\(emand in many cases "
"desirable\\(emthat the SEE ALSO section includes references to manual pages "
"provided by other projects."
msgstr ""

#. type: SH
#: man-pages/man7/man-pages.7:478
#, no-wrap
msgid "STYLE GUIDE"
msgstr ""

#. type: Plain text
#: man-pages/man7/man-pages.7:485
msgid ""
"The following subsections describe the preferred style for the I<man-pages> "
"project.  For details not covered below, the Chicago Manual of Style is "
"usually a good source; try also grepping for preexisting usage in the "
"project source tree."
msgstr ""

#. type: SS
#: man-pages/man7/man-pages.7:485
#, no-wrap
msgid "Use of gender-neutral language"
msgstr ""

#. type: Plain text
#: man-pages/man7/man-pages.7:491
msgid ""
"As far as possible, use gender-neutral language in the text of man pages.  "
"Use of \"they\" (\"them\", \"themself\", \"their\") as a gender-neutral "
"singular pronoun is acceptable."
msgstr ""

#. type: SS
#: man-pages/man7/man-pages.7:491
#, no-wrap
msgid "Formatting conventions for manual pages describing commands"
msgstr ""

#. type: Plain text
#: man-pages/man7/man-pages.7:496
msgid ""
"For manual pages that describe a command (typically in Sections 1 and 8), "
"the arguments are always specified using italics, I<even in the SYNOPSIS "
"section>."
msgstr ""

#. type: Plain text
#: man-pages/man7/man-pages.7:500
msgid ""
"The name of the command, and its options, should always be formatted in "
"bold."
msgstr ""

#. type: SS
#: man-pages/man7/man-pages.7:500
#, no-wrap
msgid "Formatting conventions for manual pages describing functions"
msgstr ""

#. type: Plain text
#: man-pages/man7/man-pages.7:505
msgid ""
"For manual pages that describe functions (typically in Sections 2 and 3), "
"the arguments are always specified using italics, I<even in the SYNOPSIS "
"section>, where the rest of the function is specified in bold:"
msgstr ""

#. type: Plain text
#: man-pages/man7/man-pages.7:507
msgid "B< int myfunction(int >I<argc>B<, char **>I<argv>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man7/man-pages.7:509
msgid "Variable names should, like argument names, be specified in italics."
msgstr ""

#. type: Plain text
#: man-pages/man7/man-pages.7:518
msgid ""
"Any reference to the subject of the current manual page should be written "
"with the name in bold followed by a pair of parentheses in Roman (normal) "
"font.  For example, in the B<fcntl>(2)  man page, references to the subject "
"of the page would be written as: B<fcntl>().  The preferred way to write "
"this in the source file is:"
msgstr ""

#. type: Plain text
#: man-pages/man7/man-pages.7:521
#, no-wrap
msgid "    .BR fcntl ()\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/man-pages.7:526
msgid ""
"(Using this format, rather than the use of \"\\efB...\\efP()\" makes it "
"easier to write tools that parse man page source files.)"
msgstr ""

#. type: SS
#: man-pages/man7/man-pages.7:526
#, no-wrap
msgid "Use semantic newlines"
msgstr ""

#. type: Plain text
#: man-pages/man7/man-pages.7:535
msgid ""
"In the source of a manual page, new sentences should be started on new "
"lines, and long sentences should split into lines at clause breaks (commas, "
"semicolons, colons, and so on).  This convention, sometimes known as "
"\"semantic newlines\", makes it easier to see the effect of patches, which "
"often operate at the level of individual sentences or sentence clauses."
msgstr ""

#. type: SS
#: man-pages/man7/man-pages.7:535
#, no-wrap
msgid "Formatting conventions (general)"
msgstr ""

#. type: Plain text
#: man-pages/man7/man-pages.7:545
msgid ""
"Paragraphs should be separated by suitable markers (usually either I<.PP> or"
" I<.IP>).  Do I<not> separate paragraphs using blank lines, as this results "
"in poor rendering in some output formats (such as PostScript and PDF)."
msgstr ""

#. type: Plain text
#: man-pages/man7/man-pages.7:555
msgid ""
"Filenames (whether pathnames, or references to header files)  are always in "
"italics (e.g., I<E<lt>stdio.hE<gt>>), except in the SYNOPSIS section, where "
"included files are in bold (e.g., B<#include E<lt>stdio.hE<gt>>).  When "
"referring to a standard header file include, specify the header file "
"surrounded by angle brackets, in the usual C way (e.g., "
"I<E<lt>stdio.hE<gt>>)."
msgstr ""

#. type: Plain text
#: man-pages/man7/man-pages.7:559
msgid ""
"Special macros, which are usually in uppercase, are in bold (e.g., "
"B<MAXINT>).  Exception: don't boldface NULL."
msgstr ""

#. type: Plain text
#: man-pages/man7/man-pages.7:564
msgid ""
"When enumerating a list of error codes, the codes are in bold (this list "
"usually uses the B<\\&.TP> macro)."
msgstr ""

#. type: Plain text
#: man-pages/man7/man-pages.7:568
msgid ""
"Complete commands should, if long, be written as an indented line on their "
"own, with a blank line before and after the command, for example"
msgstr ""

#. type: Plain text
#: man-pages/man7/man-pages.7:572
#, no-wrap
msgid "man 7 man-pages\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/man-pages.7:582
msgid ""
"If the command is short, then it can be included inline in the text, in "
"italic format, for example, I<man 7 man-pages>.  In this case, it may be "
"worth using nonbreaking spaces (\"\\e\\ \") at suitable places in the "
"command.  Command options should be written in italics (e.g., I<-l>)."
msgstr ""

#. type: Plain text
#: man-pages/man7/man-pages.7:587
msgid ""
"Expressions, if not written on a separate indented line, should be specified"
" in italics.  Again, the use of nonbreaking spaces may be appropriate if the"
" expression is inlined with normal text."
msgstr ""

#. type: Plain text
#: man-pages/man7/man-pages.7:589
msgid ""
"When showing example shell sessions, user input should be formatted in bold,"
" for example"
msgstr ""

#. type: Plain text
#: man-pages/man7/man-pages.7:594
#, no-wrap
msgid ""
"$ B<date>\n"
"Thu Jul  7 13:01:27 CEST 2016\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/man-pages.7:606
msgid ""
"Any reference to another man page should be written with the name in bold, "
"I<always> followed by the section number, formatted in Roman (normal) font, "
"without any separating spaces (e.g., B<intro>(2)).  The preferred way to "
"write this in the source file is:"
msgstr ""

#. type: Plain text
#: man-pages/man7/man-pages.7:609
#, no-wrap
msgid "    .BR intro (2)\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/man-pages.7:614
msgid ""
"(Including the section number in cross references lets tools like "
"B<man2html>(1)  create properly hyperlinked pages.)"
msgstr ""

#. type: Plain text
#: man-pages/man7/man-pages.7:618
msgid ""
"Control characters should be written in bold face, with no quotes; for "
"example, B<^X>."
msgstr ""

#. type: SS
#: man-pages/man7/man-pages.7:618
#, no-wrap
msgid "Spelling"
msgstr ""

#. type: Plain text
#: man-pages/man7/man-pages.7:624
msgid ""
"Starting with release 2.59, I<man-pages> follows American spelling "
"conventions (previously, there was a random mix of British and American "
"spellings); please write all new pages and patches according to these "
"conventions."
msgstr ""

#. type: Plain text
#: man-pages/man7/man-pages.7:627
msgid ""
"Aside from the well-known spelling differences, there are a few other "
"subtleties to watch for:"
msgstr ""

#. type: Plain text
#: man-pages/man7/man-pages.7:631
msgid ""
"American English tends to use the forms \"backward\", \"upward\", "
"\"toward\", and so on rather than the British forms \"backwards\", "
"\"upwards\", \"towards\", and so on."
msgstr ""

#. type: SS
#: man-pages/man7/man-pages.7:631
#, no-wrap
msgid "BSD version numbers"
msgstr ""

#. type: Plain text
#: man-pages/man7/man-pages.7:639
msgid ""
"The classical scheme for writing BSD version numbers is I<x.yBSD>, where "
"I<x.y> is the version number (e.g., 4.2BSD).  Avoid forms such as I<BSD "
"4.3>."
msgstr ""

#. type: SS
#: man-pages/man7/man-pages.7:639
#, no-wrap
msgid "Capitalization"
msgstr ""

#. type: Plain text
#: man-pages/man7/man-pages.7:645
msgid ""
"In subsection (\"SS\") headings, capitalize the first word in the heading, "
"but otherwise use lowercase, except where English usage (e.g., proper nouns)"
" or programming language requirements (e.g., identifier names) dictate "
"otherwise.  For example:"
msgstr ""

#. type: Plain text
#: man-pages/man7/man-pages.7:648
#, no-wrap
msgid "    .SS Unicode under Linux\n"
msgstr ""

#. type: SS
#: man-pages/man7/man-pages.7:650
#, no-wrap
msgid "Indentation of structure definitions, shell session logs, and so on"
msgstr ""

#. type: Plain text
#: man-pages/man7/man-pages.7:665
msgid ""
"When structure definitions, shell session logs, and so on are included in "
"running text, indent them by 4 spaces (i.e., a block enclosed by I<.in\\ "
"+4n> and I<.in>), format them using the I<.EX> and I<EE> macros, and "
"surround them with suitable paragraph markers (either I<.PP> or I<.IP>).  "
"For example:"
msgstr ""

#. type: Plain text
#: man-pages/man7/man-pages.7:679
#, no-wrap
msgid ""
"    .PP\n"
"    .in +4n\n"
"    .EX\n"
"    int\n"
"    main(int argc, char *argv[])\n"
"    {\n"
"        return 0;\n"
"    }\n"
"    .EE\n"
"    .in\n"
"    .PP\n"
msgstr ""

#. type: SS
#: man-pages/man7/man-pages.7:681
#, no-wrap
msgid "Preferred terms"
msgstr ""

#. type: Plain text
#: man-pages/man7/man-pages.7:684
msgid ""
"The following table lists some preferred terms to use in man pages, mainly "
"to ensure consistency across pages."
msgstr ""

#. type: tbl table
#: man-pages/man7/man-pages.7:688
#, no-wrap
msgid "Term"
msgstr ""

#. type: tbl table
#: man-pages/man7/man-pages.7:688
#, no-wrap
msgid "Avoid using"
msgstr ""

#. type: tbl table
#: man-pages/man7/man-pages.7:688 man-pages/man7/man-pages.7:753
#, no-wrap
msgid "Notes"
msgstr ""

#. type: tbl table
#: man-pages/man7/man-pages.7:690
#, no-wrap
msgid "bit mask"
msgstr ""

#. type: tbl table
#: man-pages/man7/man-pages.7:690
#, no-wrap
msgid "bitmask"
msgstr ""

#. type: tbl table
#: man-pages/man7/man-pages.7:691
#, no-wrap
msgid "built-in"
msgstr ""

#. type: tbl table
#: man-pages/man7/man-pages.7:691
#, no-wrap
msgid "builtin"
msgstr ""

#. type: tbl table
#: man-pages/man7/man-pages.7:692
#, no-wrap
msgid "Epoch"
msgstr ""

#. type: tbl table
#: man-pages/man7/man-pages.7:692
#, no-wrap
msgid "epoch"
msgstr ""

#. type: tbl table
#: man-pages/man7/man-pages.7:694
#, no-wrap
msgid "For the UNIX Epoch (00:00:00, 1 Jan 1970 UTC)"
msgstr ""

#. type: tbl table
#: man-pages/man7/man-pages.7:695
#, no-wrap
msgid "filename"
msgstr ""

#. type: tbl table
#: man-pages/man7/man-pages.7:695
#, no-wrap
msgid "file name"
msgstr ""

#. type: tbl table
#: man-pages/man7/man-pages.7:696
#, no-wrap
msgid "filesystem"
msgstr ""

#. type: tbl table
#: man-pages/man7/man-pages.7:696
#, no-wrap
msgid "file system"
msgstr ""

#. type: tbl table
#: man-pages/man7/man-pages.7:697
#, no-wrap
msgid "hostname"
msgstr ""

#. type: tbl table
#: man-pages/man7/man-pages.7:697
#, no-wrap
msgid "host name"
msgstr ""

#. type: tbl table
#: man-pages/man7/man-pages.7:698
#, no-wrap
msgid "inode"
msgstr ""

#. type: tbl table
#: man-pages/man7/man-pages.7:698
#, no-wrap
msgid "i-node"
msgstr ""

#. type: tbl table
#: man-pages/man7/man-pages.7:699
#, no-wrap
msgid "lowercase"
msgstr ""

#. type: tbl table
#: man-pages/man7/man-pages.7:699
#, no-wrap
msgid "lower case, lower-case"
msgstr ""

#. type: tbl table
#: man-pages/man7/man-pages.7:700
#, no-wrap
msgid "nonzero"
msgstr ""

#. type: tbl table
#: man-pages/man7/man-pages.7:700
#, no-wrap
msgid "non-zero"
msgstr ""

#. type: tbl table
#: man-pages/man7/man-pages.7:701
#, no-wrap
msgid "pathname"
msgstr ""

#. type: tbl table
#: man-pages/man7/man-pages.7:701
#, no-wrap
msgid "path name"
msgstr ""

#. type: tbl table
#: man-pages/man7/man-pages.7:702 man-pages/man7/man-pages.7:770
#, no-wrap
msgid "pseudoterminal"
msgstr ""

#. type: tbl table
#: man-pages/man7/man-pages.7:702
#, no-wrap
msgid "pseudo-terminal"
msgstr ""

#. type: tbl table
#: man-pages/man7/man-pages.7:703
#, no-wrap
msgid "privileged port"
msgstr ""

#. type: tbl table
#: man-pages/man7/man-pages.7:706
#, no-wrap
msgid ""
"reserved port,\n"
"system port"
msgstr ""

#. type: tbl table
#: man-pages/man7/man-pages.7:707
#, no-wrap
msgid "real-time"
msgstr ""

#. type: tbl table
#: man-pages/man7/man-pages.7:710
#, no-wrap
msgid ""
"realtime,\n"
"real time"
msgstr ""

#. type: tbl table
#: man-pages/man7/man-pages.7:711
#, no-wrap
msgid "run time"
msgstr ""

#. type: tbl table
#: man-pages/man7/man-pages.7:711
#, no-wrap
msgid "runtime"
msgstr ""

#. type: tbl table
#: man-pages/man7/man-pages.7:712
#, no-wrap
msgid "saved set-group-ID"
msgstr ""

#. type: tbl table
#: man-pages/man7/man-pages.7:715
#, no-wrap
msgid ""
"saved group ID,\n"
"saved set-GID"
msgstr ""

#. type: tbl table
#: man-pages/man7/man-pages.7:716
#, no-wrap
msgid "saved set-user-ID"
msgstr ""

#. type: tbl table
#: man-pages/man7/man-pages.7:719
#, no-wrap
msgid ""
"saved user ID,\n"
"saved set-UID"
msgstr ""

#. type: tbl table
#: man-pages/man7/man-pages.7:720
#, no-wrap
msgid "set-group-ID"
msgstr ""

#. type: tbl table
#: man-pages/man7/man-pages.7:720
#, no-wrap
msgid "set-GID, setgid"
msgstr ""

#. type: tbl table
#: man-pages/man7/man-pages.7:721
#, no-wrap
msgid "set-user-ID"
msgstr ""

#. type: tbl table
#: man-pages/man7/man-pages.7:721
#, no-wrap
msgid "set-UID, setuid"
msgstr ""

#. type: tbl table
#: man-pages/man7/man-pages.7:722
#, no-wrap
msgid "superuser"
msgstr ""

#. type: tbl table
#: man-pages/man7/man-pages.7:725
#, no-wrap
msgid ""
"super user,\n"
"super-user"
msgstr ""

#. type: tbl table
#: man-pages/man7/man-pages.7:726
#, no-wrap
msgid "superblock"
msgstr ""

#. type: tbl table
#: man-pages/man7/man-pages.7:729
#, no-wrap
msgid ""
"super block,\n"
"super-block"
msgstr ""

#. type: tbl table
#: man-pages/man7/man-pages.7:730
#, no-wrap
msgid "timestamp"
msgstr ""

#. type: tbl table
#: man-pages/man7/man-pages.7:730
#, no-wrap
msgid "time stamp"
msgstr ""

#. type: tbl table
#: man-pages/man7/man-pages.7:731
#, no-wrap
msgid "timezone"
msgstr ""

#. type: tbl table
#: man-pages/man7/man-pages.7:731
#, no-wrap
msgid "time zone"
msgstr ""

#. type: tbl table
#: man-pages/man7/man-pages.7:732
#, no-wrap
msgid "uppercase"
msgstr ""

#. type: tbl table
#: man-pages/man7/man-pages.7:732
#, no-wrap
msgid "upper case, upper-case"
msgstr ""

#. type: tbl table
#: man-pages/man7/man-pages.7:733
#, no-wrap
msgid "usable"
msgstr ""

#. type: tbl table
#: man-pages/man7/man-pages.7:733
#, no-wrap
msgid "useable"
msgstr ""

#. type: tbl table
#: man-pages/man7/man-pages.7:734
#, no-wrap
msgid "user space"
msgstr ""

#. type: tbl table
#: man-pages/man7/man-pages.7:734
#, no-wrap
msgid "userspace"
msgstr ""

#. type: tbl table
#: man-pages/man7/man-pages.7:735
#, no-wrap
msgid "username"
msgstr ""

#. type: tbl table
#: man-pages/man7/man-pages.7:735
#, no-wrap
msgid "user name"
msgstr ""

#. type: tbl table
#: man-pages/man7/man-pages.7:736
#, no-wrap
msgid "x86-64"
msgstr ""

#. type: tbl table
#: man-pages/man7/man-pages.7:736
#, no-wrap
msgid "x86_64"
msgstr ""

#. type: tbl table
#: man-pages/man7/man-pages.7:738
#, no-wrap
msgid "Except if referring to result of \"uname\\ -m\" or similar"
msgstr ""

#. type: tbl table
#: man-pages/man7/man-pages.7:739
#, no-wrap
msgid "zeros"
msgstr ""

#. type: tbl table
#: man-pages/man7/man-pages.7:739
#, no-wrap
msgid "zeroes"
msgstr ""

#. type: Plain text
#: man-pages/man7/man-pages.7:745
msgid "See also the discussion I<Hyphenation of attributive compounds> below."
msgstr ""

#. type: SS
#: man-pages/man7/man-pages.7:745
#, no-wrap
msgid "Terms to avoid"
msgstr ""

#. type: Plain text
#: man-pages/man7/man-pages.7:749
msgid ""
"The following table lists some terms to avoid using in man pages, along with"
" some suggested alternatives, mainly to ensure consistency across pages."
msgstr ""

#. type: tbl table
#: man-pages/man7/man-pages.7:753
#, no-wrap
msgid "Avoid"
msgstr ""

#. type: tbl table
#: man-pages/man7/man-pages.7:753
#, no-wrap
msgid "Use instead"
msgstr ""

#. type: tbl table
#: man-pages/man7/man-pages.7:755
#, no-wrap
msgid "32bit"
msgstr ""

#. type: tbl table
#: man-pages/man7/man-pages.7:755
#, no-wrap
msgid "32-bit"
msgstr ""

#. type: tbl table
#: man-pages/man7/man-pages.7:757
#, no-wrap
msgid "same for 8-bit, 16-bit, etc."
msgstr ""

#. type: tbl table
#: man-pages/man7/man-pages.7:758
#, no-wrap
msgid "current process"
msgstr ""

#. type: tbl table
#: man-pages/man7/man-pages.7:758
#, no-wrap
msgid "calling process"
msgstr ""

#. type: tbl table
#: man-pages/man7/man-pages.7:760
#, no-wrap
msgid "A common mistake made by kernel programmers when writing man pages"
msgstr ""

#. type: tbl table
#: man-pages/man7/man-pages.7:761
#, no-wrap
msgid "manpage"
msgstr ""

#. type: tbl table
#: man-pages/man7/man-pages.7:763
#, no-wrap
msgid "man page, manual page"
msgstr ""

#. type: tbl table
#: man-pages/man7/man-pages.7:764
#, no-wrap
msgid "minus infinity"
msgstr ""

#. type: tbl table
#: man-pages/man7/man-pages.7:764
#, no-wrap
msgid "negative infinity"
msgstr ""

#. type: tbl table
#: man-pages/man7/man-pages.7:765
#, no-wrap
msgid "non-root"
msgstr ""

#. type: tbl table
#: man-pages/man7/man-pages.7:765 man-pages/man7/man-pages.7:766
#, no-wrap
msgid "unprivileged user"
msgstr ""

#. type: tbl table
#: man-pages/man7/man-pages.7:766
#, no-wrap
msgid "non-superuser"
msgstr ""

#. type: tbl table
#: man-pages/man7/man-pages.7:767
#, no-wrap
msgid "nonprivileged"
msgstr ""

#. type: tbl table
#: man-pages/man7/man-pages.7:767
#, no-wrap
msgid "unprivileged"
msgstr ""

#. type: tbl table
#: man-pages/man7/man-pages.7:768
#, no-wrap
msgid "OS"
msgstr ""

#. type: tbl table
#: man-pages/man7/man-pages.7:768
#, no-wrap
msgid "operating system"
msgstr ""

#. type: tbl table
#: man-pages/man7/man-pages.7:769
#, no-wrap
msgid "plus infinity"
msgstr ""

#. type: tbl table
#: man-pages/man7/man-pages.7:769
#, no-wrap
msgid "positive infinity"
msgstr ""

#. type: tbl table
#: man-pages/man7/man-pages.7:770
#, no-wrap
msgid "pty"
msgstr ""

#. type: tbl table
#: man-pages/man7/man-pages.7:771
#, no-wrap
msgid "tty"
msgstr ""

#. type: tbl table
#: man-pages/man7/man-pages.7:771
#, no-wrap
msgid "terminal"
msgstr ""

#. type: tbl table
#: man-pages/man7/man-pages.7:772
#, no-wrap
msgid "Unices"
msgstr ""

#. type: tbl table
#: man-pages/man7/man-pages.7:772 man-pages/man7/man-pages.7:773
#, no-wrap
msgid "UNIX systems"
msgstr ""

#. type: tbl table
#: man-pages/man7/man-pages.7:773
#, no-wrap
msgid "Unixes"
msgstr ""

#. type: SS
#: man-pages/man7/man-pages.7:775
#, no-wrap
msgid "Trademarks"
msgstr ""

#. type: Plain text
#: man-pages/man7/man-pages.7:779
msgid ""
"Use the correct spelling and case for trademarks.  The following is a list "
"of the correct spellings of various relevant trademarks that are sometimes "
"misspelled:"
msgstr ""

#. type: Plain text
#: man-pages/man7/man-pages.7:784
#, no-wrap
msgid ""
"     DG/UX\n"
"     HP-UX\n"
"     UNIX\n"
"     UnixWare\n"
msgstr ""

#. type: SS
#: man-pages/man7/man-pages.7:784
#, no-wrap
msgid "NULL, NUL, null pointer, and null character"
msgstr ""

#. type: Plain text
#: man-pages/man7/man-pages.7:796
msgid ""
"A I<null pointer> is a pointer that points to nothing, and is normally "
"indicated by the constant I<NULL>.  On the other hand, I<NUL> is the I<null "
"byte>, a byte with the value 0, represented in C via the character constant "
"I<\\(aq\\e0\\(aq>."
msgstr ""

#. type: Plain text
#: man-pages/man7/man-pages.7:799
msgid ""
"The preferred term for the pointer is \"null pointer\" or simply \"NULL\"; "
"avoid writing \"NULL pointer\"."
msgstr ""

#. type: Plain text
#: man-pages/man7/man-pages.7:807
msgid ""
"The preferred term for the byte is \"null byte\".  Avoid writing \"NUL\", "
"since it is too easily confused with \"NULL\".  Avoid also the terms \"zero "
"byte\" and \"null character\".  The byte that terminates a C string should "
"be described as \"the terminating null byte\"; strings may be described as "
"\"null-terminated\", but avoid the use of \"NUL-terminated\"."
msgstr ""

#. type: SS
#: man-pages/man7/man-pages.7:807
#, no-wrap
msgid "Hyperlinks"
msgstr ""

#. type: Plain text
#: man-pages/man7/man-pages.7:815
msgid ""
"For hyperlinks, use the I<.UR>/I<.UE> macro pair (see B<groff_man>(7)).  "
"This produces proper hyperlinks that can be used in a web browser, when "
"rendering a page with, say:"
msgstr ""

#. type: Plain text
#: man-pages/man7/man-pages.7:817
#, no-wrap
msgid "     BROWSER=firefox man -H pagename\n"
msgstr ""

#. type: SS
#: man-pages/man7/man-pages.7:817
#, no-wrap
msgid "Use of e.g., i.e., etc., a.k.a., and similar"
msgstr ""

#. type: Plain text
#: man-pages/man7/man-pages.7:822
msgid ""
"In general, the use of abbreviations such as \"e.g.\", \"i.e.\", \"etc.\", "
"\"cf.\", and \"a.k.a.\" should be avoided, in favor of suitable full "
"wordings (\"for example\", \"that is\", \"compare to\", \"and so on\", "
"\"also known as\")."
msgstr ""

#. type: Plain text
#: man-pages/man7/man-pages.7:826
msgid ""
"The only place where such abbreviations may be acceptable is in I<short> "
"parenthetical asides (e.g., like this one)."
msgstr ""

#. type: Plain text
#: man-pages/man7/man-pages.7:829
msgid ""
"Always include periods in such abbreviations, as shown here.  In addition, "
"\"e.g.\" and \"i.e.\" should always be followed by a comma."
msgstr ""

#. type: SS
#: man-pages/man7/man-pages.7:829
#, no-wrap
msgid "Em-dashes"
msgstr ""

#. type: Plain text
#: man-pages/man7/man-pages.7:837
msgid ""
"The way to write an em-dash\\(emthe glyph that appears at either end of this"
" subphrase\\(emin *roff is with the macro \"\\e(em\".  (On an ASCII "
"terminal, an em-dash typically renders as two hyphens, but in other "
"typographical contexts it renders as a long dash.)  Em-dashes should be "
"written I<without> surrounding spaces."
msgstr ""

#. type: SS
#: man-pages/man7/man-pages.7:837
#, no-wrap
msgid "Hyphenation of attributive compounds"
msgstr ""

#. type: Plain text
#: man-pages/man7/man-pages.7:840
msgid ""
"Compound terms should be hyphenated when used attributively (i.e., to "
"qualify a following noun). Some examples:"
msgstr ""

#. type: Plain text
#: man-pages/man7/man-pages.7:847
#, no-wrap
msgid ""
"    32-bit value\n"
"    command-line argument\n"
"    floating-point number\n"
"    run-time check\n"
"    user-space function\n"
"    wide-character string\n"
msgstr ""

#. type: SS
#: man-pages/man7/man-pages.7:847
#, no-wrap
msgid "Hyphenation with multi, non, pre, re, sub, and so on"
msgstr ""

#. type: Plain text
#: man-pages/man7/man-pages.7:853
msgid ""
"The general tendency in modern English is not to hyphenate after prefixes "
"such as \"multi\", \"non\", \"pre\", \"re\", \"sub\", and so on.  Manual "
"pages should generally follow this rule when these prefixes are used in "
"natural English constructions with simple suffixes.  The following list "
"gives some examples of the preferred forms:"
msgstr ""

#. type: Plain text
#: man-pages/man7/man-pages.7:874
#, no-wrap
msgid ""
"    interprocess\n"
"    multithreaded\n"
"    multiprocess\n"
"    nonblocking\n"
"    nondefault\n"
"    nonempty\n"
"    noninteractive\n"
"    nonnegative\n"
"    nonportable\n"
"    nonzero\n"
"    preallocated\n"
"    precreate\n"
"    prerecorded\n"
"    reestablished\n"
"    reinitialize\n"
"    rearm\n"
"    reread\n"
"    subcomponent\n"
"    subdirectory\n"
"    subsystem\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/man-pages.7:878
msgid ""
"Hyphens should be retained when the prefixes are used in nonstandard English"
" words, with trademarks, proper nouns, acronyms, or compound terms.  Some "
"examples:"
msgstr ""

#. type: Plain text
#: man-pages/man7/man-pages.7:883
#, no-wrap
msgid ""
"    non-ASCII\n"
"    non-English\n"
"    non-NULL\n"
"    non-real-time\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/man-pages.7:886
msgid ""
"Finally, note that \"re-create\" and \"recreate\" are two different verbs, "
"and the former is probably what you want."
msgstr ""

#. type: SS
#: man-pages/man7/man-pages.7:886
#, no-wrap
msgid "Real minus character"
msgstr ""

#. type: Plain text
#: man-pages/man7/man-pages.7:893
msgid ""
"Where a real minus character is required (e.g., for numbers such as -1, for "
"man page cross references such as B<utf-8>(7), or when writing options that "
"have a leading dash, such as in I<ls\\ -l>), use the following form in the "
"man page source:"
msgstr ""

#. type: Plain text
#: man-pages/man7/man-pages.7:895
#, no-wrap
msgid "    \\e-\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/man-pages.7:897
msgid "This guideline applies also to code examples."
msgstr ""

#. type: SS
#: man-pages/man7/man-pages.7:897
#, no-wrap
msgid "Character constants"
msgstr ""

#. type: Plain text
#: man-pages/man7/man-pages.7:900
msgid ""
"To produce single quotes that render well in both ASCII and UTF-8, use the "
"following form for character constants in the man page source:"
msgstr ""

#. type: Plain text
#: man-pages/man7/man-pages.7:902
#, no-wrap
msgid "    \\e(aqC\\e(aq\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/man-pages.7:907
msgid ""
"where I<C> is the quoted character.  This guideline applies also to "
"character constants used in code examples."
msgstr ""

#. type: SS
#: man-pages/man7/man-pages.7:907
#, no-wrap
msgid "Example programs and shell sessions"
msgstr ""

#. type: Plain text
#: man-pages/man7/man-pages.7:911
msgid ""
"Manual pages may include example programs demonstrating how to use a system "
"call or library function.  However, note the following:"
msgstr ""

#. type: Plain text
#: man-pages/man7/man-pages.7:913
msgid "Example programs should be written in C."
msgstr ""

#. type: Plain text
#: man-pages/man7/man-pages.7:919
msgid ""
"An example program is necessary and useful only if it demonstrates something"
" beyond what can easily be provided in a textual description of the "
"interface.  An example program that does nothing other than call an "
"interface usually serves little purpose."
msgstr ""

#. type: Plain text
#: man-pages/man7/man-pages.7:922
msgid ""
"Example programs should be fairly short (preferably less than 100 lines; "
"ideally less than 50 lines)."
msgstr ""

#. type: Plain text
#: man-pages/man7/man-pages.7:925
msgid ""
"Example programs should do error checking after system calls and library "
"function calls."
msgstr ""

#. type: Plain text
#: man-pages/man7/man-pages.7:928
msgid ""
"Example programs should be complete, and compile without warnings when "
"compiled with I<cc\\ -Wall>."
msgstr ""

#. type: Plain text
#: man-pages/man7/man-pages.7:933
msgid ""
"Where possible and appropriate, example programs should allow "
"experimentation, by varying their behavior based on inputs (ideally from "
"command-line arguments, or alternatively, via input read by the program)."
msgstr ""

#. type: Plain text
#: man-pages/man7/man-pages.7:939
msgid ""
"Example programs should be laid out according to Kernighan and Ritchie "
"style, with 4-space indents.  (Avoid the use of TAB characters in source "
"code!)  The following command can be used to format your source code to "
"something close to the preferred style:"
msgstr ""

#. type: Plain text
#: man-pages/man7/man-pages.7:941
#, no-wrap
msgid "    indent -npro -kr -i4 -ts4 -sob -l72 -ss -nut -psl prog.c\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/man-pages.7:943
msgid ""
"For consistency, all example programs should terminate using either of:"
msgstr ""

#. type: Plain text
#: man-pages/man7/man-pages.7:946
#, no-wrap
msgid ""
"     exit(EXIT_SUCCESS);\n"
"     exit(EXIT_FAILURE);\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/man-pages.7:948
msgid "Avoid using the following forms to terminate a program:"
msgstr ""

#. type: Plain text
#: man-pages/man7/man-pages.7:952
#, no-wrap
msgid ""
"    exit(0);\n"
"    exit(1);\n"
"    return n;\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/man-pages.7:958
msgid ""
"If there is extensive explanatory text before the program source code, mark "
"off the source code with a subsection heading I<Program source>, as in:"
msgstr ""

#. type: Plain text
#: man-pages/man7/man-pages.7:960
msgid ".SS Program source"
msgstr ""

#. type: Plain text
#: man-pages/man7/man-pages.7:962
msgid "Always do this if the explanatory text includes a shell session log."
msgstr ""

#. type: Plain text
#: man-pages/man7/man-pages.7:965
msgid ""
"If you include a shell session log demonstrating the use of a program or "
"other system feature:"
msgstr ""

#. type: Plain text
#: man-pages/man7/man-pages.7:967
msgid "Place the session log above the source code listing"
msgstr ""

#. type: Plain text
#: man-pages/man7/man-pages.7:969
msgid "Indent the session log by four spaces."
msgstr ""

#. type: Plain text
#: man-pages/man7/man-pages.7:972
msgid ""
"Boldface the user input text, to distinguish it from output produced by the "
"system."
msgstr ""

#. type: Plain text
#: man-pages/man7/man-pages.7:977
msgid ""
"For some examples of what example programs should look like, see B<wait>(2)"
"  and B<pipe>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man7/man-pages.7:984
msgid ""
"For canonical examples of how man pages in the I<man-pages> package should "
"look, see B<pipe>(2)  and B<fcntl>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man7/man-pages.7:991
msgid ""
"B<man>(1), B<man2html>(1), B<attributes>(7), B<groff>(7), B<groff_man>(7), "
"B<man>(7), B<mdoc>(7)"
msgstr ""

#. type: TH
#: man-pages/man7/math_error.7:26
#, no-wrap
msgid "MATH_ERROR"
msgstr ""

#. type: Plain text
#: man-pages/man7/math_error.7:29
msgid "math_error - detecting errors from mathematical functions"
msgstr ""

#. type: Plain text
#: man-pages/man7/math_error.7:34
#, no-wrap
msgid ""
"B<#include E<lt>math.hE<gt>>\n"
"B<#include E<lt>errno.hE<gt>>\n"
"B<#include E<lt>fenv.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/math_error.7:53
msgid ""
"When an error occurs, most library functions indicate this fact by returning"
" a special value (e.g., -1 or NULL).  Because they typically return a "
"floating-point number, the mathematical functions declared in "
"I<E<lt>math.hE<gt>> indicate an error using other mechanisms.  There are two"
" error-reporting mechanisms: the older one sets I<errno>; the newer one uses"
" the floating-point exception mechanism (the use of B<feclearexcept>(3)  and"
" B<fetestexcept>(3), as outlined below)  described in B<fenv>(3)."
msgstr ""

#. type: Plain text
#: man-pages/man7/math_error.7:58
msgid ""
"A portable program that needs to check for an error from a mathematical "
"function should set I<errno> to zero, and make the following call"
msgstr ""

#. type: Plain text
#: man-pages/man7/math_error.7:62
#, no-wrap
msgid "feclearexcept(FE_ALL_EXCEPT);\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/math_error.7:66
msgid "before calling a mathematical function."
msgstr ""

#. type: Plain text
#: man-pages/man7/math_error.7:72
msgid ""
"Upon return from the mathematical function, if I<errno> is nonzero, or the "
"following call (see B<fenv>(3))  returns nonzero"
msgstr ""

#. type: Plain text
#: man-pages/man7/math_error.7:77
#, no-wrap
msgid ""
"fetestexcept(FE_INVALID | FE_DIVBYZERO | FE_OVERFLOW |\n"
"             FE_UNDERFLOW);\n"
msgstr ""

#.  enum
#.  {
#.  FE_INVALID = 0x01,
#.  __FE_DENORM = 0x02,
#.  FE_DIVBYZERO = 0x04,
#.  FE_OVERFLOW = 0x08,
#.  FE_UNDERFLOW = 0x10,
#.  FE_INEXACT = 0x20
#.  };
#. type: Plain text
#: man-pages/man7/math_error.7:90
msgid "then an error occurred in the mathematical function."
msgstr ""

#. type: Plain text
#: man-pages/man7/math_error.7:93
msgid ""
"The error conditions that can occur for mathematical functions are described"
" below."
msgstr ""

#. type: SS
#: man-pages/man7/math_error.7:93
#, no-wrap
msgid "Domain error"
msgstr ""

#. type: Plain text
#: man-pages/man7/math_error.7:109
msgid ""
"A I<domain error> occurs when a mathematical function is supplied with an "
"argument whose value falls outside the domain for which the function is "
"defined (e.g., giving a negative argument to B<log>(3)).  When a domain "
"error occurs, math functions commonly return a NaN (though some functions "
"return a different value in this case); I<errno> is set to B<EDOM>, and an "
"\"invalid\" (B<FE_INVALID>)  floating-point exception is raised."
msgstr ""

#. type: SS
#: man-pages/man7/math_error.7:109
#, no-wrap
msgid "Pole error"
msgstr ""

#. type: Plain text
#: man-pages/man7/math_error.7:133
msgid ""
"A I<pole error> occurs when the mathematical result of a function is an "
"exact infinity (e.g., the logarithm of 0 is negative infinity).  When a pole"
" error occurs, the function returns the (signed) value B<HUGE_VAL>, "
"B<HUGE_VALF>, or B<HUGE_VALL>, depending on whether the function result type"
" is I<double>, I<float>, or I<long double>.  The sign of the result is that "
"which is mathematically correct for the function.  I<errno> is set to "
"B<ERANGE>, and a \"divide-by-zero\" (B<FE_DIVBYZERO>)  floating-point "
"exception is raised."
msgstr ""

#. type: SS
#: man-pages/man7/math_error.7:133
#, no-wrap
msgid "Range error"
msgstr ""

#. type: Plain text
#: man-pages/man7/math_error.7:140
msgid ""
"A I<range error> occurs when the magnitude of the function result means that"
" it cannot be represented in the result type of the function.  The return "
"value of the function depends on whether the range error was an overflow or "
"an underflow."
msgstr ""

#. type: Plain text
#: man-pages/man7/math_error.7:162
msgid ""
"A floating result I<overflows> if the result is finite, but is too large to "
"represented in the result type.  When an overflow occurs, the function "
"returns the value B<HUGE_VAL>, B<HUGE_VALF>, or B<HUGE_VALL>, depending on "
"whether the function result type is I<double>, I<float>, or I<long double>."
"  I<errno> is set to B<ERANGE>, and an \"overflow\" (B<FE_OVERFLOW>)  "
"floating-point exception is raised."
msgstr ""

#. type: Plain text
#: man-pages/man7/math_error.7:177
msgid ""
"A floating result I<underflows> if the result is too small to be represented"
" in the result type.  If an underflow occurs, a mathematical function "
"typically returns 0.0 (C99 says a function shall return \"an implementation-"
"defined value whose magnitude is no greater than the smallest normalized "
"positive number in the specified type\").  I<errno> may be set to B<ERANGE>,"
" and an \"overflow\" (B<FE_UNDERFLOW>)  floating-point exception may be "
"raised."
msgstr ""

#. type: Plain text
#: man-pages/man7/math_error.7:187
msgid ""
"Some functions deliver a range error if the supplied argument value, or the "
"correct function result, would be I<subnormal>.  A subnormal value is one "
"that is nonzero, but with a magnitude that is so small that it can't be "
"presented in normalized form (i.e., with a 1 in the most significant bit of "
"the significand).  The representation of a subnormal number will contain one"
" or more leading zeros in the significand."
msgstr ""

#.  See CONFORMANCE in the glibc 2.8 (and earlier) source.
#. type: Plain text
#: man-pages/man7/math_error.7:209
msgid ""
"The I<math_errhandling> identifier specified by C99 and POSIX.1 is not "
"supported by glibc.  This identifier is supposed to indicate which of the "
"two error-notification mechanisms (I<errno>, exceptions retrievable via "
"B<fettestexcept>(3))  is in use.  The standards require that at least one be"
" in use, but permit both to be available.  The current (version 2.8) "
"situation under glibc is messy.  Most (but not all) functions raise "
"exceptions on errors.  Some also set I<errno>.  A few functions set "
"I<errno>, but don't raise an exception.  A very few functions do neither.  "
"See the individual manual pages for details."
msgstr ""

#. http://www.securecoding.cert.org/confluence/display/seccode/FLP32-C.+Prevent+or+detect+domain+and+range+errors+in+math+functions
#. type: Plain text
#: man-pages/man7/math_error.7:222
msgid ""
"To avoid the complexities of using I<errno> and B<fetestexcept>(3)  for "
"error checking, it is often advised that one should instead check for bad "
"argument values before each call.  For example, the following code ensures "
"that B<log>(3)'s argument is not a NaN and is not zero (a pole error) or "
"less than zero (a domain error):"
msgstr ""

#. type: Plain text
#: man-pages/man7/math_error.7:226
#, no-wrap
msgid "double x, r;\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/math_error.7:230
#, no-wrap
msgid ""
"if (isnan(x) || islessequal(x, 0)) {\n"
"    /* Deal with NaN / pole error / domain error */\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/math_error.7:232
#, no-wrap
msgid "r = log(x);\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/math_error.7:240
msgid ""
"The discussion on this page does not apply to the complex mathematical "
"functions (i.e., those declared by I<E<lt>complex.hE<gt>>), which in general"
" are not required to return errors by C99 and POSIX.1."
msgstr ""

#. type: Plain text
#: man-pages/man7/math_error.7:256
msgid ""
"The B<gcc>(1)  I<-fno-math-errno> option causes the executable to employ "
"implementations of some mathematical functions that are faster than the "
"standard implementations, but do not set I<errno> on error.  (The B<gcc>(1)"
"  I<-ffast-math> option also enables I<-fno-math-errno>.)  An error can "
"still be tested for using B<fetestexcept>(3)."
msgstr ""

#. type: Plain text
#: man-pages/man7/math_error.7:265
msgid ""
"B<gcc>(1), B<errno>(3), B<fenv>(3), B<fpclassify>(3), B<INFINITY>(3), "
"B<isgreater>(3), B<matherr>(3), B<nan>(3)"
msgstr ""

#. type: Plain text
#: man-pages/man7/math_error.7:266
msgid "I<info libc>"
msgstr ""

#. type: TH
#: man-pages/man7/man.7:34
#, no-wrap
msgid "MAN"
msgstr ""

#. type: Plain text
#: man-pages/man7/man.7:37
msgid "man - macros to format man pages"
msgstr ""

#. type: Plain text
#: man-pages/man7/man.7:41
msgid "B<groff -Tascii -man> I<file> \\&..."
msgstr ""

#. type: Plain text
#: man-pages/man7/man.7:45
msgid "B<groff -Tps -man> I<file> \\&..."
msgstr ""

#. type: Plain text
#: man-pages/man7/man.7:62
msgid ""
"This manual page explains the B<groff an.tmac> macro package (often called "
"the B<man> macro package).  This macro package should be used by developers "
"when writing or porting man pages for Linux.  It is fairly compatible with "
"other versions of this macro package, so porting man pages should not be a "
"major problem (exceptions include the NET-2 BSD release, which uses a "
"totally different macro package called mdoc; see B<mdoc>(7))."
msgstr ""

#. type: Plain text
#: man-pages/man7/man.7:74
msgid ""
"Note that NET-2 BSD mdoc man pages can be used with B<groff> simply by "
"specifying the B<-mdoc> option instead of the B<-man> option.  Using the "
"B<-mandoc> option is, however, recommended, since this will automatically "
"detect which macro package is in use."
msgstr ""

#. type: Plain text
#: man-pages/man7/man.7:78
msgid ""
"For conventions that should be employed when writing man pages for the Linux"
" I<man-pages> package, see B<man-pages>(7)."
msgstr ""

#. type: Plain text
#: man-pages/man7/man.7:81
msgid ""
"The first command in a man page (after comment lines, that is, lines that "
"start with B<.\\e\">) should be"
msgstr ""

#. type: Plain text
#: man-pages/man7/man.7:91
msgid ""
"For details of the arguments that should be supplied to the B<TH> command, "
"see B<man-pages>(7)."
msgstr ""

#. type: Plain text
#: man-pages/man7/man.7:97
msgid ""
"Note that BSD mdoc-formatted pages begin with the B<Dd> command, not the "
"B<TH> command."
msgstr ""

#. type: SS
#: man-pages/man7/man.7:97
#, no-wrap
msgid "Sections"
msgstr ""

#.  The following doesn't seem to be required (see Debian bug 411303),
#.  If the name contains spaces and appears
#.  on the same line as
#.  .BR \&.SH ,
#.  then place the heading in double quotes.
#. type: Plain text
#: man-pages/man7/man.7:106
msgid "Sections are started with B<\\&.SH> followed by the heading name."
msgstr ""

#. type: Plain text
#: man-pages/man7/man.7:109
msgid ""
"The only mandatory heading is NAME, which should be the first section and be"
" followed on the next line by a one-line description of the program:"
msgstr ""

#. type: Plain text
#: man-pages/man7/man.7:112
msgid "\\&.SH NAME"
msgstr ""

#. type: Plain text
#: man-pages/man7/man.7:114
msgid "item \\e- description"
msgstr ""

#. type: Plain text
#: man-pages/man7/man.7:128
msgid ""
"It is extremely important that this format is followed, and that there is a "
"backslash before the single dash which follows the item name.  This syntax "
"is used by the B<mandb>(8)  program to create a database of short "
"descriptions for the B<whatis>(1)  and B<apropos>(1)  commands.  (See "
"B<lexgrog>(1)  for further details on the syntax of the NAME section.)"
msgstr ""

#. type: Plain text
#: man-pages/man7/man.7:131
msgid ""
"For a list of other sections that might appear in a manual page, see B<man-"
"pages>(7)."
msgstr ""

#. type: SS
#: man-pages/man7/man.7:131
#, no-wrap
msgid "Fonts"
msgstr ""

#. type: Plain text
#: man-pages/man7/man.7:133
msgid "The commands to select the type face are:"
msgstr ""

#. type: TP
#: man-pages/man7/man.7:133
#, no-wrap
msgid "B<\\&.B>"
msgstr ""

#. type: Plain text
#: man-pages/man7/man.7:136
msgid "Bold"
msgstr ""

#. type: TP
#: man-pages/man7/man.7:136
#, no-wrap
msgid "B<\\&.BI>"
msgstr ""

#. type: Plain text
#: man-pages/man7/man.7:140
msgid ""
"Bold alternating with italics (especially useful for function "
"specifications)"
msgstr ""

#. type: TP
#: man-pages/man7/man.7:140
#, no-wrap
msgid "B<\\&.BR>"
msgstr ""

#. type: Plain text
#: man-pages/man7/man.7:145
msgid ""
"Bold alternating with Roman (especially useful for referring to other manual"
" pages)"
msgstr ""

#. type: TP
#: man-pages/man7/man.7:145
#, no-wrap
msgid "B<\\&.I>"
msgstr ""

#. type: Plain text
#: man-pages/man7/man.7:148
msgid "Italics"
msgstr ""

#. type: TP
#: man-pages/man7/man.7:148
#, no-wrap
msgid "B<\\&.IB>"
msgstr ""

#. type: Plain text
#: man-pages/man7/man.7:151
msgid "Italics alternating with bold"
msgstr ""

#. type: TP
#: man-pages/man7/man.7:151
#, no-wrap
msgid "B<\\&.IR>"
msgstr ""

#. type: Plain text
#: man-pages/man7/man.7:154
msgid "Italics alternating with Roman"
msgstr ""

#. type: TP
#: man-pages/man7/man.7:154
#, no-wrap
msgid "B<\\&.RB>"
msgstr ""

#. type: Plain text
#: man-pages/man7/man.7:157
msgid "Roman alternating with bold"
msgstr ""

#. type: TP
#: man-pages/man7/man.7:157
#, no-wrap
msgid "B<\\&.RI>"
msgstr ""

#. type: Plain text
#: man-pages/man7/man.7:160
msgid "Roman alternating with italics"
msgstr ""

#. type: TP
#: man-pages/man7/man.7:160
#, no-wrap
msgid "B<\\&.SB>"
msgstr ""

#. type: Plain text
#: man-pages/man7/man.7:163
msgid "Small alternating with bold"
msgstr ""

#. type: TP
#: man-pages/man7/man.7:163
#, no-wrap
msgid "B<\\&.SM>"
msgstr ""

#. type: Plain text
#: man-pages/man7/man.7:166
msgid "Small (useful for acronyms)"
msgstr ""

#. type: Plain text
#: man-pages/man7/man.7:179
msgid ""
"Traditionally, each command can have up to six arguments, but the GNU "
"implementation removes this limitation (you might still want to limit "
"yourself to 6 arguments for portability's sake).  Arguments are delimited by"
" spaces.  Double quotes can be used to specify an argument which contains "
"spaces.  All of the arguments will be printed next to each other without "
"intervening spaces, so that the B<\\&.BR> command can be used to specify a "
"word in bold followed by a mark of punctuation in Roman.  If no arguments "
"are given, the command is applied to the following line of text."
msgstr ""

#. type: SS
#: man-pages/man7/man.7:179
#, no-wrap
msgid "Other macros and strings"
msgstr ""

#. type: Plain text
#: man-pages/man7/man.7:199
msgid ""
"Below are other relevant macros and predefined strings.  Unless noted "
"otherwise, all macros cause a break (end the current line of text).  Many of"
" these macros set or use the \"prevailing indent.\" The \"prevailing "
"indent\" value is set by any macro with the parameter I<i> below; macros may"
" omit I<i> in which case the current prevailing indent will be used.  As a "
"result, successive indented paragraphs can use the same indent without "
"respecifying the indent value.  A normal (nonindented) paragraph resets the "
"prevailing indent value to its default value (0.5 inches).  By default, a "
"given indent is measured in ens; try to use ens or ems as units for indents,"
" since these will automatically adjust to font size changes.  The other key "
"macro definitions are:"
msgstr ""

#. type: SS
#: man-pages/man7/man.7:199
#, no-wrap
msgid "Normal paragraphs"
msgstr ""

#. type: TP
#: man-pages/man7/man.7:200
#, no-wrap
msgid "B<\\&.LP>"
msgstr ""

#. type: Plain text
#: man-pages/man7/man.7:205 man-pages/man7/man.7:210
msgid "Same as B<\\&.PP> (begin a new paragraph)."
msgstr ""

#. type: TP
#: man-pages/man7/man.7:205
#, no-wrap
msgid "B<\\&.P>"
msgstr ""

#. type: TP
#: man-pages/man7/man.7:210
#, no-wrap
msgid "B<\\&.PP>"
msgstr ""

#. type: Plain text
#: man-pages/man7/man.7:213
msgid "Begin a new paragraph and reset prevailing indent."
msgstr ""

#. type: SS
#: man-pages/man7/man.7:213
#, no-wrap
msgid "Relative margin indent"
msgstr ""

#. type: TP
#: man-pages/man7/man.7:214
#, no-wrap
msgid "B<\\&.RS>I< i>"
msgstr ""

#. type: Plain text
#: man-pages/man7/man.7:225
msgid ""
"Start relative margin indent: moves the left margin I<i> to the right (if "
"I<i> is omitted, the prevailing indent value is used).  A new prevailing "
"indent is set to 0.5 inches.  As a result, all following paragraph(s) will "
"be indented until the corresponding B<\\&.RE>."
msgstr ""

#. type: TP
#: man-pages/man7/man.7:225
#, no-wrap
msgid "B<\\&.RE>"
msgstr ""

#. type: Plain text
#: man-pages/man7/man.7:229
msgid ""
"End relative margin indent and restores the previous value of the prevailing"
" indent."
msgstr ""

#. type: SS
#: man-pages/man7/man.7:229
#, no-wrap
msgid "Indented paragraph macros"
msgstr ""

#. type: TP
#: man-pages/man7/man.7:230
#, no-wrap
msgid "B<\\&.HP>I< i>"
msgstr ""

#. type: Plain text
#: man-pages/man7/man.7:235
msgid ""
"Begin paragraph with a hanging indent (the first line of the paragraph is at"
" the left margin of normal paragraphs, and the rest of the paragraph's lines"
" are indented)."
msgstr ""

#. type: TP
#: man-pages/man7/man.7:235
#, no-wrap
msgid "B<\\&.IP>I< x i>"
msgstr ""

#. type: Plain text
#: man-pages/man7/man.7:256
msgid ""
"Indented paragraph with optional hanging tag.  If the tag I<x> is omitted, "
"the entire following paragraph is indented by I<i>.  If the tag I<x> is "
"provided, it is hung at the left margin before the following indented "
"paragraph (this is just like B<\\&.TP> except the tag is included with the "
"command instead of being on the following line).  If the tag is too long, "
"the text after the tag will be moved down to the next line (text will not be"
" lost or garbled).  For bulleted lists, use this macro with \\e(bu (bullet) "
"or \\e(em (em dash)  as the tag, and for numbered lists, use the number or "
"letter followed by a period as the tag; this simplifies translation to other"
" formats."
msgstr ""

#. type: TP
#: man-pages/man7/man.7:256
#, no-wrap
msgid "B<\\&.TP>I< i>"
msgstr ""

#. type: Plain text
#: man-pages/man7/man.7:263
msgid ""
"Begin paragraph with hanging tag.  The tag is given on the next line, but "
"its results are like those of the B<\\&.IP> command."
msgstr ""

#. type: SS
#: man-pages/man7/man.7:263
#, no-wrap
msgid "Hypertext link macros"
msgstr ""

#. type: TP
#: man-pages/man7/man.7:264
#, no-wrap
msgid "B<\\&.UR>I< url>"
msgstr ""

#. type: Plain text
#: man-pages/man7/man.7:271
msgid ""
"Insert a hypertext link to the URI (URL)  I<url>, with all text up to the "
"following B<\\&.UE> macro as the link text."
msgstr ""

#. type: TP
#: man-pages/man7/man.7:271
#, no-wrap
msgid "B<\\&.UE>"
msgstr ""

#. type: Plain text
#: man-pages/man7/man.7:288
msgid ""
"[I<trailer>] Terminate the link text of the preceding B<\\&.UR> macro, with "
"the optional I<trailer> (if present, usually a closing parenthesis and/or "
"end-of-sentence punctuation) immediately following.  For non-HTML output "
"devices (e.g., B<man -Tutf8>), the link text is followed by the URL in angle"
" brackets; if there is no link text, the URL is printed as its own link "
"text, surrounded by angle brackets.  (Angle brackets may not be available on"
" all output devices.)  For the HTML output device, the link text is "
"hyperlinked to the URL; if there is no link text, the URL is printed as its "
"own link text."
msgstr ""

#. type: Plain text
#: man-pages/man7/man.7:291
msgid ""
"These macros have been supported since GNU Troff 1.20 (2009-01-05) and "
"Heirloom Doctools Troff since 160217 (2016-02-17)."
msgstr ""

#. type: SS
#: man-pages/man7/man.7:291
#, no-wrap
msgid "Miscellaneous macros"
msgstr ""

#. type: TP
#: man-pages/man7/man.7:292
#, no-wrap
msgid "B<\\&.DT>"
msgstr ""

#. type: Plain text
#: man-pages/man7/man.7:296
msgid ""
"Reset tabs to default tab values (every 0.5 inches); does not cause a break."
msgstr ""

#. type: TP
#: man-pages/man7/man.7:296
#, no-wrap
msgid "B<\\&.PD>I< d>"
msgstr ""

#. type: Plain text
#: man-pages/man7/man.7:301
msgid ""
"Set inter-paragraph vertical distance to d (if omitted, d=0.4v); does not "
"cause a break."
msgstr ""

#. type: TP
#: man-pages/man7/man.7:301
#, no-wrap
msgid "B<\\&.SS>I< t>"
msgstr ""

#. type: Plain text
#: man-pages/man7/man.7:308
msgid ""
"Subheading I<t> (like B<\\&.SH>, but used for a subsection inside a "
"section)."
msgstr ""

#. type: SS
#: man-pages/man7/man.7:308
#, no-wrap
msgid "Predefined strings"
msgstr ""

#. type: Plain text
#: man-pages/man7/man.7:312
msgid "The B<man> package has the following predefined strings:"
msgstr ""

#. type: IP
#: man-pages/man7/man.7:312
#, no-wrap
msgid "\\e*R"
msgstr ""

#. type: Plain text
#: man-pages/man7/man.7:314
msgid "Registration Symbol: \\*R"
msgstr ""

#. type: IP
#: man-pages/man7/man.7:314
#, no-wrap
msgid "\\e*S"
msgstr ""

#. type: Plain text
#: man-pages/man7/man.7:316
msgid "Change to default font size"
msgstr ""

#. type: IP
#: man-pages/man7/man.7:316
#, no-wrap
msgid "\\e*(Tm"
msgstr ""

#. type: Plain text
#: man-pages/man7/man.7:318
msgid "Trademark Symbol: \\*(Tm"
msgstr ""

#. type: IP
#: man-pages/man7/man.7:318
#, no-wrap
msgid "\\e*(lq"
msgstr ""

#. type: Plain text
#: man-pages/man7/man.7:320
msgid "Left angled double quote: ``"
msgstr ""

#. type: IP
#: man-pages/man7/man.7:320
#, no-wrap
msgid "\\e*(rq"
msgstr ""

#. type: Plain text
#: man-pages/man7/man.7:322
msgid "Right angled double quote: ''"
msgstr ""

#. type: SS
#: man-pages/man7/man.7:322
#, no-wrap
msgid "Safe subset"
msgstr ""

#. type: Plain text
#: man-pages/man7/man.7:366
msgid ""
"Although technically B<man> is a troff macro package, in reality a large "
"number of other tools process man page files that don't implement all of "
"troff's abilities.  Thus, it's best to avoid some of troff's more exotic "
"abilities where possible to permit these other tools to work correctly.  "
"Avoid using the various troff preprocessors (if you must, go ahead and use "
"B<tbl>(1), but try to use the B<IP> and B<TP> commands instead for two-"
"column tables).  Avoid using computations; most other tools can't process "
"them.  Use simple commands that are easy to translate to other formats.  The"
" following troff macros are believed to be safe (though in many cases they "
"will be ignored by translators): B<\\e\">, B<.>, B<ad>, B<bp>, B<br>, B<ce>,"
" B<de>, B<ds>, B<el>, B<ie>, B<if>, B<fi>, B<ft>, B<hy>, B<ig>, B<in>, "
"B<na>, B<ne>, B<nf>, B<nh>, B<ps>, B<so>, B<sp>, B<ti>, B<tr>."
msgstr ""

#. type: Plain text
#: man-pages/man7/man.7:389
msgid ""
"You may also use many troff escape sequences (those sequences beginning with"
" \\e).  When you need to include the backslash character as normal text, use"
" \\ee.  Other sequences you may use, where x or xx are any characters and N "
"is any digit, include: B<\\e\\(aq>, B<\\e\\(ga>, B<\\e->, B<\\e.>, B<\\e\">,"
" B<\\e%>, B<\\e*x>, B<\\e*(xx>, B<\\e(xx>, B<\\e$N>, B<\\enx>, B<\\en(xx>, "
"B<\\efx>, and B<\\ef(xx>.  Avoid using the escape sequences for drawing "
"graphics."
msgstr ""

#. type: Plain text
#: man-pages/man7/man.7:420
msgid ""
"Do not use the optional parameter for B<bp> (break page).  Use only positive"
" values for B<sp> (vertical space).  Don't define a macro (B<de>)  with the "
"same name as a macro in this or the mdoc macro package with a different "
"meaning; it's likely that such redefinitions will be ignored.  Every "
"positive indent (B<in>)  should be paired with a matching negative indent "
"(although you should be using the B<RS> and B<RE> macros instead).  The "
"condition test (B<if,ie>)  should only have \\(aqt\\(aq or \\(aqn\\(aq as "
"the condition.  Only translations (B<tr>)  that can be ignored should be "
"used.  Font changes (B<ft> and the B<\\ef> escape sequence)  should only "
"have the values 1, 2, 3, 4, R, I, B, P, or CW (the ft command may also have "
"no parameters)."
msgstr ""

#. type: Plain text
#: man-pages/man7/man.7:427
msgid ""
"If you use capabilities beyond these, check the results carefully on several"
" tools.  Once you've confirmed that the additional capability is safe, let "
"the maintainer of this document know about the safe command or sequence that"
" should be added to this list."
msgstr ""

#. type: Plain text
#: man-pages/man7/man.7:429
msgid "I</usr/share/groff/>[*/]I<tmac/an.tmac>"
msgstr ""

#. type: Plain text
#: man-pages/man7/man.7:431
msgid "I</usr/man/whatis>"
msgstr ""

#. type: Plain text
#: man-pages/man7/man.7:447
msgid ""
"By all means include full URLs (or URIs) in the text itself; some tools such"
" as B<man2html>(1)  can automatically turn them into hypertext links.  You "
"can also use the B<UR> and B<UE> macros to identify links to related "
"information.  If you include URLs, use the full URL (e.g., E<.UR "
"http://www.kernel.org> E<.UE )> to ensure that tools can automatically find "
"the URLs."
msgstr ""

#. type: Plain text
#: man-pages/man7/man.7:456
msgid ""
"Tools processing these files should open the file and examine the first "
"nonwhitespace character.  A period (.) or single quote (\\(aq) at the "
"beginning of a line indicates a troff-based file (such as man or mdoc).  A "
"left angle bracket (E<lt>) indicates an SGML/XML-based file (such as HTML or"
" Docbook).  Anything else suggests simple ASCII text (e.g., a \"catman\" "
"result)."
msgstr ""

#. type: Plain text
#: man-pages/man7/man.7:467
msgid ""
"Many man pages begin with B<\\(aq\\e\"> followed by a space and a list of "
"characters, indicating how the page is to be preprocessed.  For "
"portability's sake to non-troff translators we recommend that you avoid "
"using anything other than B<tbl>(1), and Linux can detect that "
"automatically.  However, you might want to include this information so your "
"man page can be handled by other (less capable) systems.  Here are the "
"definitions of the preprocessors invoked by these characters:"
msgstr ""

#. type: TP
#: man-pages/man7/man.7:467
#, no-wrap
msgid "B<e>"
msgstr ""

#. type: Plain text
#: man-pages/man7/man.7:470
msgid "eqn(1)"
msgstr ""

#. type: TP
#: man-pages/man7/man.7:470
#, no-wrap
msgid "B<g>"
msgstr ""

#. type: Plain text
#: man-pages/man7/man.7:473
msgid "grap(1)"
msgstr ""

#. type: TP
#: man-pages/man7/man.7:473
#, no-wrap
msgid "B<p>"
msgstr ""

#. type: Plain text
#: man-pages/man7/man.7:476
msgid "pic(1)"
msgstr ""

#. type: TP
#: man-pages/man7/man.7:476
#, no-wrap
msgid "B<r>"
msgstr ""

#. type: Plain text
#: man-pages/man7/man.7:479
msgid "refer(1)"
msgstr ""

#. type: TP
#: man-pages/man7/man.7:479
#, no-wrap
msgid "B<t>"
msgstr ""

#. type: Plain text
#: man-pages/man7/man.7:482
msgid "tbl(1)"
msgstr ""

#. type: TP
#: man-pages/man7/man.7:482
#, no-wrap
msgid "B<v>"
msgstr ""

#. type: Plain text
#: man-pages/man7/man.7:485
msgid "vgrind(1)"
msgstr ""

#. type: Plain text
#: man-pages/man7/man.7:498
msgid ""
"Most of the macros describe formatting (e.g., font type and spacing) instead"
" of marking semantic content (e.g., this text is a reference to another "
"page), compared to formats like mdoc and DocBook (even HTML has more "
"semantic markings).  This situation makes it harder to vary the B<man> "
"format for different media, to make the formatting consistent for a given "
"media, and to automatically insert cross-references.  By sticking to the "
"safe subset described above, it should be easier to automate transitioning "
"to a different reference page format in the future."
msgstr ""

#.  .SH AUTHORS
#.  .IP \(em 3m
#.  James Clark (jjc@jclark.com) wrote the implementation of the macro
#. package.
#.  .IP \(em
#.  Rickard E. Faith (faith@cs.unc.edu) wrote the initial version of
#.  this manual page.
#.  .IP \(em
#.  Jens Schweikhardt (schweikh@noc.fdn.de) wrote the Linux Man-Page Mini-
#. HOWTO
#.  (which influenced this manual page).
#.  .IP \(em
#.  David A. Wheeler (dwheeler@ida.org) heavily modified this
#.  manual page, such as adding detailed information on sections and macros.
#. type: Plain text
#: man-pages/man7/man.7:514
msgid "The Sun macro B<TX> is not implemented."
msgstr ""

#. type: Plain text
#: man-pages/man7/man.7:524
msgid ""
"B<apropos>(1), B<groff>(1), B<lexgrog>(1), B<man>(1), B<man2html>(1), "
"B<whatis>(1), B<groff_man>(7), B<groff_www>(7), B<man-pages>(7), B<mdoc>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/mkdir.2:11
#, no-wrap
msgid "MKDIR"
msgstr ""

#. type: Plain text
#: man-pages/man2/mkdir.2:14
msgid "mkdir, mkdirat - create a directory"
msgstr ""

#.  .B #include <unistd.h>
#. type: Plain text
#: man-pages/man2/mkdir.2:19
#, no-wrap
msgid ""
"B<#include E<lt>sys/stat.hE<gt>>\n"
"B<#include E<lt>sys/types.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/mkdir.2:21
#, no-wrap
msgid "B<int mkdir(const char *>I<pathname>B<, mode_t >I<mode>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/mkdir.2:24
#, no-wrap
msgid ""
"B<#include E<lt>fcntl.hE<gt>           >/* Definition of AT_* constants */\n"
"B<#include E<lt>sys/stat.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/mkdir.2:26
#, no-wrap
msgid ""
"B<int mkdirat(int >I<dirfd>B<, const char *>I<pathname>B<, mode_t "
">I<mode>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/mkdir.2:31
msgid ""
"Feature Test Macro Requirements for glibc (see B<feature_test_macros>(7)):"
msgstr ""

#. type: Plain text
#: man-pages/man2/mkdir.2:34
msgid "B<mkdirat>():"
msgstr ""

#. type: TP
#: man-pages/man2/mkdir.2:37
#, no-wrap
msgid "Since glibc 2.10:"
msgstr ""

#. type: Plain text
#: man-pages/man2/mkdir.2:40
msgid "_POSIX_C_SOURCE\\ E<gt>=\\ 200809L"
msgstr ""

#. type: TP
#: man-pages/man2/mkdir.2:40
#, no-wrap
msgid "Before glibc 2.10:"
msgstr ""

#. type: Plain text
#: man-pages/man2/mkdir.2:43
msgid "_ATFILE_SOURCE"
msgstr ""

#. type: Plain text
#: man-pages/man2/mkdir.2:50
msgid "B<mkdir>()  attempts to create a directory named I<pathname>."
msgstr ""

#. type: Plain text
#: man-pages/man2/mkdir.2:64
msgid ""
"The argument I<mode> specifies the mode for the new directory (see "
"B<inode>(7)).  It is modified by the process's I<umask> in the usual way: in"
" the absence of a default ACL, the mode of the created directory is (I<mode>"
" & ~I<umask> & 0777).  Whether other I<mode> bits are honored for the "
"created directory depends on the operating system.  For Linux, see NOTES "
"below."
msgstr ""

#. type: Plain text
#: man-pages/man2/mkdir.2:74
msgid ""
"The newly created directory will be owned by the effective user ID of the "
"process.  If the directory containing the file has the set-group-ID bit set,"
" or if the filesystem is mounted with BSD group semantics (I<mount -o "
"bsdgroups> or, synonymously I<mount -o grpid>), the new directory will "
"inherit the group ownership from its parent; otherwise it will be owned by "
"the effective group ID of the process."
msgstr ""

#. type: Plain text
#: man-pages/man2/mkdir.2:79
msgid ""
"If the parent directory has the set-group-ID bit set, then so will the newly"
" created directory."
msgstr ""

#. type: SS
#: man-pages/man2/mkdir.2:79
#, no-wrap
msgid "mkdirat()"
msgstr ""

#. type: Plain text
#: man-pages/man2/mkdir.2:85
msgid ""
"The B<mkdirat>()  system call operates in exactly the same way as "
"B<mkdir>(), except for the differences described here."
msgstr ""

#. type: Plain text
#: man-pages/man2/mkdir.2:95
msgid ""
"If the pathname given in I<pathname> is relative, then it is interpreted "
"relative to the directory referred to by the file descriptor I<dirfd> "
"(rather than relative to the current working directory of the calling "
"process, as is done by B<mkdir>()  for a relative pathname)."
msgstr ""

#. type: Plain text
#: man-pages/man2/mkdir.2:107
msgid ""
"If I<pathname> is relative and I<dirfd> is the special value B<AT_FDCWD>, "
"then I<pathname> is interpreted relative to the current working directory of"
" the calling process (like B<mkdir>())."
msgstr ""

#. type: Plain text
#: man-pages/man2/mkdir.2:113
msgid "If I<pathname> is absolute, then I<dirfd> is ignored."
msgstr ""

#. type: Plain text
#: man-pages/man2/mkdir.2:118
msgid "See B<openat>(2)  for an explanation of the need for B<mkdirat>()."
msgstr ""

#. type: SH
#: man-pages/man2/mkdir.2:118
#, no-wrap
msgid "RETURN VALUE"
msgstr ""

#. type: Plain text
#: man-pages/man2/mkdir.2:125
msgid ""
"B<mkdir>()  and B<mkdirat>()  return zero on success, or -1 if an error "
"occurred (in which case, I<errno> is set appropriately)."
msgstr ""

#. type: SH
#: man-pages/man2/mkdir.2:125
#, no-wrap
msgid "ERRORS"
msgstr ""

#. type: TP
#: man-pages/man2/mkdir.2:126
#, no-wrap
msgid "B<EACCES>"
msgstr ""

#. type: Plain text
#: man-pages/man2/mkdir.2:134
msgid ""
"The parent directory does not allow write permission to the process, or one "
"of the directories in I<pathname> did not allow search permission.  (See "
"also B<path_resolution>(7).)"
msgstr ""

#. type: TP
#: man-pages/man2/mkdir.2:134
#, no-wrap
msgid "B<EDQUOT>"
msgstr ""

#. type: Plain text
#: man-pages/man2/mkdir.2:138
msgid ""
"The user's quota of disk blocks or inodes on the filesystem has been "
"exhausted."
msgstr ""

#. type: TP
#: man-pages/man2/mkdir.2:138
#, no-wrap
msgid "B<EEXIST>"
msgstr ""

#. type: Plain text
#: man-pages/man2/mkdir.2:145
msgid ""
"I<pathname> already exists (not necessarily as a directory).  This includes "
"the case where I<pathname> is a symbolic link, dangling or not."
msgstr ""

#. type: TP
#: man-pages/man2/mkdir.2:145
#, no-wrap
msgid "B<EFAULT>"
msgstr ""

#. type: Plain text
#: man-pages/man2/mkdir.2:148
msgid "I<pathname> points outside your accessible address space."
msgstr ""

#. type: TP
#: man-pages/man2/mkdir.2:148
#, no-wrap
msgid "B<EINVAL>"
msgstr ""

#. type: Plain text
#: man-pages/man2/mkdir.2:154
msgid ""
"The final component (\"basename\") of the new directory's I<pathname> is "
"invalid (e.g., it contains characters not permitted by the underlying "
"filesystem)."
msgstr ""

#. type: TP
#: man-pages/man2/mkdir.2:154
#, no-wrap
msgid "B<ELOOP>"
msgstr ""

#. type: Plain text
#: man-pages/man2/mkdir.2:158
msgid "Too many symbolic links were encountered in resolving I<pathname>."
msgstr ""

#. type: TP
#: man-pages/man2/mkdir.2:158
#, no-wrap
msgid "B<EMLINK>"
msgstr ""

#. type: Plain text
#: man-pages/man2/mkdir.2:162
msgid "The number of links to the parent directory would exceed B<LINK_MAX>."
msgstr ""

#. type: TP
#: man-pages/man2/mkdir.2:162
#, no-wrap
msgid "B<ENAMETOOLONG>"
msgstr ""

#. type: Plain text
#: man-pages/man2/mkdir.2:165
msgid "I<pathname> was too long."
msgstr ""

#. type: TP
#: man-pages/man2/mkdir.2:165
#, no-wrap
msgid "B<ENOENT>"
msgstr ""

#. type: Plain text
#: man-pages/man2/mkdir.2:170
msgid ""
"A directory component in I<pathname> does not exist or is a dangling "
"symbolic link."
msgstr ""

#. type: TP
#: man-pages/man2/mkdir.2:170
#, no-wrap
msgid "B<ENOMEM>"
msgstr ""

#. type: Plain text
#: man-pages/man2/mkdir.2:173
msgid "Insufficient kernel memory was available."
msgstr ""

#. type: TP
#: man-pages/man2/mkdir.2:173 man-pages/man2/mkdir.2:178
#, no-wrap
msgid "B<ENOSPC>"
msgstr ""

#. type: Plain text
#: man-pages/man2/mkdir.2:178
msgid "The device containing I<pathname> has no room for the new directory."
msgstr ""

#. type: Plain text
#: man-pages/man2/mkdir.2:182
msgid ""
"The new directory cannot be created because the user's disk quota is "
"exhausted."
msgstr ""

#. type: TP
#: man-pages/man2/mkdir.2:182 man-pages/man2/mkdir.2:203
#, no-wrap
msgid "B<ENOTDIR>"
msgstr ""

#. type: Plain text
#: man-pages/man2/mkdir.2:187
msgid ""
"A component used as a directory in I<pathname> is not, in fact, a directory."
msgstr ""

#. type: TP
#: man-pages/man2/mkdir.2:187
#, no-wrap
msgid "B<EPERM>"
msgstr ""

#. type: Plain text
#: man-pages/man2/mkdir.2:192
msgid ""
"The filesystem containing I<pathname> does not support the creation of "
"directories."
msgstr ""

#. type: TP
#: man-pages/man2/mkdir.2:192
#, no-wrap
msgid "B<EROFS>"
msgstr ""

#. type: Plain text
#: man-pages/man2/mkdir.2:196
msgid "I<pathname> refers to a file on a read-only filesystem."
msgstr ""

#. type: Plain text
#: man-pages/man2/mkdir.2:199
msgid "The following additional errors can occur for B<mkdirat>():"
msgstr ""

#. type: TP
#: man-pages/man2/mkdir.2:199
#, no-wrap
msgid "B<EBADF>"
msgstr ""

#. type: Plain text
#: man-pages/man2/mkdir.2:203
msgid "I<dirfd> is not a valid file descriptor."
msgstr ""

#. type: Plain text
#: man-pages/man2/mkdir.2:209
msgid ""
"I<pathname> is relative and I<dirfd> is a file descriptor referring to a "
"file other than a directory."
msgstr ""

#. type: Plain text
#: man-pages/man2/mkdir.2:213
msgid ""
"B<mkdirat>()  was added to Linux in kernel 2.6.16; library support was added"
" to glibc in version 2.4."
msgstr ""

#.  SVr4 documents additional EIO, EMULTIHOP
#. type: Plain text
#: man-pages/man2/mkdir.2:217
msgid "B<mkdir>(): SVr4, BSD, POSIX.1-2001, POSIX.1-2008."
msgstr ""

#. type: Plain text
#: man-pages/man2/mkdir.2:220
msgid "B<mkdirat>(): POSIX.1-2008."
msgstr ""

#. type: Plain text
#: man-pages/man2/mkdir.2:225
msgid ""
"Under Linux, apart from the permission bits, the B<S_ISVTX> I<mode> bit is "
"also honored."
msgstr ""

#. type: Plain text
#: man-pages/man2/mkdir.2:229
msgid ""
"There are many infelicities in the protocol underlying NFS.  Some of these "
"affect B<mkdir>()."
msgstr ""

#. type: SS
#: man-pages/man2/mkdir.2:229
#, no-wrap
msgid "Glibc notes"
msgstr ""

#. type: Plain text
#: man-pages/man2/mkdir.2:242
msgid ""
"On older kernels where B<mkdirat>()  is unavailable, the glibc wrapper "
"function falls back to the use of B<mkdir>().  When I<pathname> is a "
"relative pathname, glibc constructs a pathname based on the symbolic link in"
" I</proc/self/fd> that corresponds to the I<dirfd> argument."
msgstr ""

#. type: Plain text
#: man-pages/man2/mkdir.2:253
msgid ""
"B<mkdir>(1), B<chmod>(2), B<chown>(2), B<mknod>(2), B<mount>(2), "
"B<rmdir>(2), B<stat>(2), B<umask>(2), B<unlink>(2), B<acl>(5)  "
"B<path_resolution>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/mmap.2:40
#, no-wrap
msgid "MMAP"
msgstr ""

#. type: TH
#: man-pages/man2/mmap.2:40
#, no-wrap
msgid "2019-02-27"
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:43
msgid "mmap, munmap - map or unmap files or devices into memory"
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:46
#, no-wrap
msgid "B<#include E<lt>sys/mman.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:51
#, no-wrap
msgid ""
"B<void *mmap(void *>I<addr>B<, size_t >I<length>B<, int >I<prot>B<, int >I<flags>B<,>\n"
"B<           int >I<fd>B<, off_t >I<offset>B<);>\n"
"B<int munmap(void *>I<addr>B<, size_t >I<length>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:54
msgid "See NOTES for information on feature test macro requirements."
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:63
msgid ""
"B<mmap>()  creates a new mapping in the virtual address space of the calling"
" process.  The starting address for the new mapping is specified in I<addr>."
"  The I<length> argument specifies the length of the mapping (which must be "
"greater than 0)."
msgstr ""

#.  Before Linux 2.6.24, the address was rounded up to the next page
#.  boundary; since 2.6.24, it is rounded down!
#. type: Plain text
#: man-pages/man2/mmap.2:83
msgid ""
"If I<addr> is NULL, then the kernel chooses the (page-aligned) address at "
"which to create the mapping; this is the most portable method of creating a "
"new mapping.  If I<addr> is not NULL, then the kernel takes it as a hint "
"about where to place the mapping; on Linux, the kernel will pick a nearby "
"page boundary (but always above or equal to the value specified by "
"I</proc/sys/vm/mmap_min_addr>)  and attempt to create the mapping there.  If"
" another mapping already exists there, the kernel picks a new address that "
"may or may not depend on the hint.  The address of the new mapping is "
"returned as the result of the call."
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:95
msgid ""
"The contents of a file mapping (as opposed to an anonymous mapping; see "
"B<MAP_ANONYMOUS> below), are initialized using I<length> bytes starting at "
"offset I<offset> in the file (or other object) referred to by the file "
"descriptor I<fd>.  I<offset> must be a multiple of the page size as returned"
" by I<sysconf(_SC_PAGE_SIZE)>."
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:101
msgid ""
"After the B<mmap>()  call has returned, the file descriptor, I<fd>, can be "
"closed immediately without invalidating the mapping."
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:109
msgid ""
"The I<prot> argument describes the desired memory protection of the mapping "
"(and must not conflict with the open mode of the file).  It is either "
"B<PROT_NONE> or the bitwise OR of one or more of the following flags:"
msgstr ""

#. type: TP
#: man-pages/man2/mmap.2:109
#, no-wrap
msgid "B<PROT_EXEC>"
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:112
msgid "Pages may be executed."
msgstr ""

#. type: TP
#: man-pages/man2/mmap.2:112
#, no-wrap
msgid "B<PROT_READ>"
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:115
msgid "Pages may be read."
msgstr ""

#. type: TP
#: man-pages/man2/mmap.2:115
#, no-wrap
msgid "B<PROT_WRITE>"
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:118
msgid "Pages may be written."
msgstr ""

#. type: TP
#: man-pages/man2/mmap.2:118
#, no-wrap
msgid "B<PROT_NONE>"
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:121
msgid "Pages may not be accessed."
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:130
msgid ""
"The I<flags> argument determines whether updates to the mapping are visible "
"to other processes mapping the same region, and whether updates are carried "
"through to the underlying file.  This behavior is determined by including "
"exactly one of the following values in I<flags>:"
msgstr ""

#. type: TP
#: man-pages/man2/mmap.2:130
#, no-wrap
msgid "B<MAP_SHARED>"
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:139
msgid ""
"Share this mapping.  Updates to the mapping are visible to other processes "
"mapping the same region, and (in the case of file-backed mappings)  are "
"carried through to the underlying file.  (To precisely control when updates "
"are carried through to the underlying file requires the use of B<msync>(2).)"
msgstr ""

#. type: TP
#: man-pages/man2/mmap.2:139
#, no-wrap
msgid "B<MAP_SHARED_VALIDATE> (since Linux 4.15)"
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:156
msgid ""
"This flag provides the same behavior as B<MAP_SHARED> except that "
"B<MAP_SHARED> mappings ignore unknown flags in I<flags>.  By contrast, when "
"creating a mapping using B<MAP_SHARED_VALIDATE>, the kernel verifies all "
"passed flags are known and fails the mapping with the error B<EOPNOTSUPP> "
"for unknown flags.  This mapping type is also required to be able to use "
"some mapping flags (e.g., B<MAP_SYNC>)."
msgstr ""

#. type: TP
#: man-pages/man2/mmap.2:156
#, no-wrap
msgid "B<MAP_PRIVATE>"
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:165
msgid ""
"Create a private copy-on-write mapping.  Updates to the mapping are not "
"visible to other processes mapping the same file, and are not carried "
"through to the underlying file.  It is unspecified whether changes made to "
"the file after the B<mmap>()  call are visible in the mapped region."
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:173
msgid ""
"Both B<MAP_SHARED> and B<MAP_PRIVATE> are described in POSIX.1-2001 and "
"POSIX.1-2008.  B<MAP_SHARED_VALIDATE> is a Linux extension."
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:176
msgid ""
"In addition, zero or more of the following values can be ORed in I<flags>:"
msgstr ""

#. type: TP
#: man-pages/man2/mmap.2:176
#, no-wrap
msgid "B<MAP_32BIT> (since Linux 2.4.20, 2.6)"
msgstr ""

#.  See http://lwn.net/Articles/294642 "Tangled up in threads", 19 Aug 08
#. type: Plain text
#: man-pages/man2/mmap.2:192
msgid ""
"Put the mapping into the first 2 Gigabytes of the process address space.  "
"This flag is supported only on x86-64, for 64-bit programs.  It was added to"
" allow thread stacks to be allocated somewhere in the first 2\\ GB of "
"memory, so as to improve context-switch performance on some early 64-bit "
"processors.  Modern x86-64 processors no longer have this performance "
"problem, so use of this flag is not required on those systems.  The "
"B<MAP_32BIT> flag is ignored when B<MAP_FIXED> is set."
msgstr ""

#. type: TP
#: man-pages/man2/mmap.2:192
#, no-wrap
msgid "B<MAP_ANON>"
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:197
msgid "Synonym for B<MAP_ANONYMOUS>.  Deprecated."
msgstr ""

#. type: TP
#: man-pages/man2/mmap.2:197
#, no-wrap
msgid "B<MAP_ANONYMOUS>"
msgstr ""

#.  See the pgoff overflow check in do_mmap().
#.  See the offset check in sys_mmap in arch/x86/kernel/sys_x86_64.c.
#. type: Plain text
#: man-pages/man2/mmap.2:222
msgid ""
"The mapping is not backed by any file; its contents are initialized to zero."
"  The I<fd> argument is ignored; however, some implementations require I<fd>"
" to be -1 if B<MAP_ANONYMOUS> (or B<MAP_ANON>)  is specified, and portable "
"applications should ensure this.  The I<offset> argument should be zero.  "
"The use of B<MAP_ANONYMOUS> in conjunction with B<MAP_SHARED> is supported "
"on Linux only since kernel 2.4."
msgstr ""

#. type: TP
#: man-pages/man2/mmap.2:222
#, no-wrap
msgid "B<MAP_DENYWRITE>"
msgstr ""

#.  Introduced in 1.1.36, removed in 1.3.24.
#. type: Plain text
#: man-pages/man2/mmap.2:230
msgid ""
"This flag is ignored.  (Long ago\\(emLinux 2.0 and earlier\\(emit signaled "
"that attempts to write to the underlying file should fail with B<ETXTBUSY>."
"  But this was a source of denial-of-service attacks.)"
msgstr ""

#. type: TP
#: man-pages/man2/mmap.2:230
#, no-wrap
msgid "B<MAP_EXECUTABLE>"
msgstr ""

#.  Introduced in 1.1.38, removed in 1.3.24. Flag tested in proc_follow_link.
#.  (Long ago, it signaled that the underlying file is an executable.
#.  However, that information was not really used anywhere.)
#.  Linus talked about DOS related to MAP_EXECUTABLE, but he was thinking of
#.  MAP_DENYWRITE?
#. type: Plain text
#: man-pages/man2/mmap.2:238
msgid "This flag is ignored."
msgstr ""

#. type: TP
#: man-pages/man2/mmap.2:238
#, no-wrap
msgid "B<MAP_FILE>"
msgstr ""

#.  On some systems, this was required as the opposite of
#.  MAP_ANONYMOUS -- mtk, 1 May 2007
#. type: Plain text
#: man-pages/man2/mmap.2:244
msgid "Compatibility flag.  Ignored."
msgstr ""

#. type: TP
#: man-pages/man2/mmap.2:244
#, no-wrap
msgid "B<MAP_FIXED>"
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:262
msgid ""
"Don't interpret I<addr> as a hint: place the mapping at exactly that "
"address.  I<addr> must be suitably aligned: for most architectures a "
"multiple of the page size is sufficient; however, some architectures may "
"impose additional restrictions.  If the memory region specified by I<addr> "
"and I<len> overlaps pages of any existing mapping(s), then the overlapped "
"part of the existing mapping(s) will be discarded.  If the specified address"
" cannot be used, B<mmap>()  will fail."
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:270
msgid ""
"Software that aspires to be portable should use the B<MAP_FIXED> flag with "
"care, keeping in mind that the exact layout of a process's memory mappings "
"is allowed to change significantly between kernel versions, C library "
"versions, and operating system releases.  I<Carefully read the discussion of"
" this flag in NOTES!>"
msgstr ""

#. type: TP
#: man-pages/man2/mmap.2:270
#, no-wrap
msgid "B<MAP_FIXED_NOREPLACE> (since Linux 4.17)"
msgstr ""

#.  commit a4ff8e8620d3f4f50ac4b41e8067b7d395056843
#. type: Plain text
#: man-pages/man2/mmap.2:286
msgid ""
"This flag provides behavior that is similar to B<MAP_FIXED> with respect to "
"the I<addr> enforcement, but differs in that B<MAP_FIXED_NOREPLACE> never "
"clobbers a preexisting mapped range.  If the requested range would collide "
"with an existing mapping, then this call fails with the error B<EEXIST.> "
"This flag can therefore be used as a way to atomically (with respect to "
"other threads) attempt to map an address range: one thread will succeed; all"
" others will report failure."
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:296
msgid ""
"Note that older kernels which do not recognize the B<MAP_FIXED_NOREPLACE> "
"flag will typically (upon detecting a collision with a preexisting mapping)"
"  fall back to a \"non-B<MAP_FIXED>\" type of behavior: they will return an "
"address that is different from the requested address.  Therefore, backward-"
"compatible software should check the returned address against the requested "
"address."
msgstr ""

#. type: TP
#: man-pages/man2/mmap.2:296
#, no-wrap
msgid "B<MAP_GROWSDOWN>"
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:310
msgid ""
"This flag is used for stacks.  It indicates to the kernel virtual memory "
"system that the mapping should extend downward in memory.  The return "
"address is one page lower than the memory area that is actually created in "
"the process's virtual address space.  Touching an address in the \"guard\" "
"page below the mapping will cause the mapping to grow by a page.  This "
"growth can be repeated until the mapping grows to within a page of the high "
"end of the next lower mapping, at which point touching the \"guard\" page "
"will result in a B<SIGSEGV> signal."
msgstr ""

#. type: TP
#: man-pages/man2/mmap.2:310
#, no-wrap
msgid "B<MAP_HUGETLB> (since Linux 2.6.32)"
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:316
msgid ""
"Allocate the mapping using \"huge pages.\" See the Linux kernel source file "
"I<Documentation/admin-guide/mm/hugetlbpage.rst> for further information, as "
"well as NOTES, below."
msgstr ""

#. type: TP
#: man-pages/man2/mmap.2:316
#, no-wrap
msgid "B<MAP_HUGE_2MB>, B<MAP_HUGE_1GB> (since Linux 3.8)"
msgstr ""

#.  See https://lwn.net/Articles/533499/
#. type: Plain text
#: man-pages/man2/mmap.2:323
msgid ""
"Used in conjunction with B<MAP_HUGETLB> to select alternative hugetlb page "
"sizes (respectively, 2\\ MB and 1\\ GB)  on systems that support multiple "
"hugetlb page sizes."
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:333
msgid ""
"More generally, the desired huge page size can be configured by encoding the"
" base-2 logarithm of the desired page size in the six bits at the offset "
"B<MAP_HUGE_SHIFT>.  (A value of zero in this bit field provides the default "
"huge page size; the default huge page size can be discovered via the "
"I<Hugepagesize> field exposed by I</proc/meminfo>.)  Thus, the above two "
"constants are defined as:"
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:338
#, no-wrap
msgid ""
"#define MAP_HUGE_2MB    (21 E<lt>E<lt> MAP_HUGE_SHIFT)\n"
"#define MAP_HUGE_1GB    (30 E<lt>E<lt> MAP_HUGE_SHIFT)\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:344
msgid ""
"The range of huge page sizes that are supported by the system can be "
"discovered by listing the subdirectories in I</sys/kernel/mm/hugepages>."
msgstr ""

#. type: TP
#: man-pages/man2/mmap.2:344
#, no-wrap
msgid "B<MAP_LOCKED> (since Linux 2.5.37)"
msgstr ""

#.  If set, the mapped pages will not be swapped out.
#. type: Plain text
#: man-pages/man2/mmap.2:365
msgid ""
"Mark the mapped region to be locked in the same way as B<mlock>(2).  This "
"implementation will try to populate (prefault) the whole range but the "
"B<mmap>()  call doesn't fail with B<ENOMEM> if this fails.  Therefore major "
"faults might happen later on.  So the semantic is not as strong as "
"B<mlock>(2).  One should use B<mmap>()  plus B<mlock>(2)  when major faults "
"are not acceptable after the initialization of the mapping.  The "
"B<MAP_LOCKED> flag is ignored in older kernels."
msgstr ""

#. type: TP
#: man-pages/man2/mmap.2:365
#, no-wrap
msgid "B<MAP_NONBLOCK> (since Linux 2.5.46)"
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:380
msgid ""
"This flag is meaningful only in conjunction with B<MAP_POPULATE>.  Don't "
"perform read-ahead: create page tables entries only for pages that are "
"already present in RAM.  Since Linux 2.6.23, this flag causes "
"B<MAP_POPULATE> to do nothing.  One day, the combination of B<MAP_POPULATE> "
"and B<MAP_NONBLOCK> may be reimplemented."
msgstr ""

#. type: TP
#: man-pages/man2/mmap.2:380
#, no-wrap
msgid "B<MAP_NORESERVE>"
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:395
msgid ""
"Do not reserve swap space for this mapping.  When swap space is reserved, "
"one has the guarantee that it is possible to modify the mapping.  When swap "
"space is not reserved one might get B<SIGSEGV> upon a write if no physical "
"memory is available.  See also the discussion of the file "
"I</proc/sys/vm/overcommit_memory> in B<proc>(5).  In kernels before 2.6, "
"this flag had effect only for private writable mappings."
msgstr ""

#. type: TP
#: man-pages/man2/mmap.2:395
#, no-wrap
msgid "B<MAP_POPULATE> (since Linux 2.5.46)"
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:402
msgid ""
"Populate (prefault) page tables for a mapping.  For a file mapping, this "
"causes read-ahead on the file.  This will help to reduce blocking on page "
"faults later.  B<MAP_POPULATE> is supported for private mappings only since "
"Linux 2.6.23."
msgstr ""

#. type: TP
#: man-pages/man2/mmap.2:402
#, no-wrap
msgid "B<MAP_STACK> (since Linux 2.6.27)"
msgstr ""

#.  See http://lwn.net/Articles/294642 "Tangled up in threads", 19 Aug 08
#.  commit cd98a04a59e2f94fa64d5bf1e26498d27427d5e7
#.  http://thread.gmane.org/gmane.linux.kernel/720412
#.  "pthread_create() slow for many threads; also time to revisit 64b
#.   context switch optimization?"
#. type: Plain text
#: man-pages/man2/mmap.2:415
msgid ""
"Allocate the mapping at an address suitable for a process or thread stack.  "
"This flag is currently a no-op, but is used in the glibc threading "
"implementation so that if some architectures require special treatment for "
"stack allocations, support can later be transparently implemented for glibc."
msgstr ""

#. type: TP
#: man-pages/man2/mmap.2:415
#, no-wrap
msgid "B<MAP_SYNC> (since Linux 4.15)"
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:428
msgid ""
"This flag is available only with the B<MAP_SHARED_VALIDATE> mapping type; "
"mappings of type B<MAP_SHARED> will silently ignore this flag.  This flag is"
" supported only for files supporting DAX (direct mapping of persistent "
"memory).  For other files, creating a mapping with this flag results in an "
"B<EOPNOTSUPP> error."
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:436
msgid ""
"Shared file mappings with this flag provide the guarantee that while some "
"memory is writably mapped in the address space of the process, it will be "
"visible in the same file at the same offset even after the system crashes or"
" is rebooted.  In conjunction with the use of appropriate CPU instructions, "
"this provides users of such mappings with a more efficient way of making "
"data modifications persistent."
msgstr ""

#. type: TP
#: man-pages/man2/mmap.2:436
#, no-wrap
msgid "B<MAP_UNINITIALIZED> (since Linux 2.6.33)"
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:446
msgid ""
"Don't clear anonymous pages.  This flag is intended to improve performance "
"on embedded devices.  This flag is honored only if the kernel was configured"
" with the B<CONFIG_MMAP_ALLOW_UNINITIALIZED> option.  Because of the "
"security implications, that option is normally enabled only on embedded "
"devices (i.e., devices where one has complete control of the contents of "
"user memory)."
msgstr ""

#.  FIXME . for later review when Issue 8 is one day released...
#.  POSIX may add MAP_ANON in the future
#.  http://austingroupbugs.net/tag_view_page.php?tag_id=8
#.  http://austingroupbugs.net/view.php?id=850
#. type: Plain text
#: man-pages/man2/mmap.2:458
msgid ""
"Of the above flags, only B<MAP_FIXED> is specified in POSIX.1-2001 and "
"POSIX.1-2008.  However, most systems also support B<MAP_ANONYMOUS> (or its "
"synonym B<MAP_ANON>)."
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:464
msgid ""
"Memory mapped by B<mmap>()  is preserved across B<fork>(2), with the same "
"attributes."
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:472
msgid ""
"A file is mapped in multiples of the page size.  For a file that is not a "
"multiple of the page size, the remaining memory is zeroed when mapped, and "
"writes to that region are not written out to the file.  The effect of "
"changing the size of the underlying file of a mapping on the pages that "
"correspond to added or removed regions of the file is unspecified."
msgstr ""

#. type: SS
#: man-pages/man2/mmap.2:472
#, no-wrap
msgid "munmap()"
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:482
msgid ""
"The B<munmap>()  system call deletes the mappings for the specified address "
"range, and causes further references to addresses within the range to "
"generate invalid memory references.  The region is also automatically "
"unmapped when the process is terminated.  On the other hand, closing the "
"file descriptor does not unmap the region."
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:494
msgid ""
"The address I<addr> must be a multiple of the page size (but I<length> need "
"not be).  All pages containing a part of the indicated range are unmapped, "
"and subsequent references to these pages will generate B<SIGSEGV>.  It is "
"not an error if the indicated range does not contain any mapped pages."
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:505
msgid ""
"On success, B<mmap>()  returns a pointer to the mapped area.  On error, the "
"value B<MAP_FAILED> (that is, I<(void\\ *)\\ -1>)  is returned, and I<errno>"
" is set to indicate the cause of the error."
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:513
msgid ""
"On success, B<munmap>()  returns 0.  On failure, it returns -1, and I<errno>"
" is set to indicate the cause of the error (probably to B<EINVAL>)."
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:532
msgid ""
"A file descriptor refers to a non-regular file.  Or a file mapping was "
"requested, but I<fd> is not open for reading.  Or B<MAP_SHARED> was "
"requested and B<PROT_WRITE> is set, but I<fd> is not open in read/write "
"(B<O_RDWR>)  mode.  Or B<PROT_WRITE> is set, but the file is append-only."
msgstr ""

#. type: TP
#: man-pages/man2/mmap.2:532
#, no-wrap
msgid "B<EAGAIN>"
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:536
msgid ""
"The file has been locked, or too much memory has been locked (see "
"B<setrlimit>(2))."
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:542
msgid ""
"I<fd> is not a valid file descriptor (and B<MAP_ANONYMOUS> was not set)."
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:552
msgid ""
"B<MAP_FIXED_NOREPLACE> was specified in I<flags>, and the range covered by "
"I<addr> and I<length> clashes with an existing mapping."
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:560
msgid ""
"We don't like I<addr>, I<length>, or I<offset> (e.g., they are too large, or"
" not aligned on a page boundary)."
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:565
msgid "(since Linux 2.6.12)  I<length> was 0."
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:573
msgid ""
"I<flags> contained none of B<MAP_PRIVATE>, B<MAP_SHARED> or "
"B<MAP_SHARED_VALIDATE>."
msgstr ""

#. type: TP
#: man-pages/man2/mmap.2:573
#, no-wrap
msgid "B<ENFILE>"
msgstr ""

#.  This is for shared anonymous segments
#.  [2.6.7] shmem_zero_setup()-->shmem_file_setup()-->get_empty_filp()
#.  .TP
#.  .B ENOEXEC
#.  A file could not be mapped for reading.
#. type: Plain text
#: man-pages/man2/mmap.2:581
msgid ""
"The system-wide limit on the total number of open files has been reached."
msgstr ""

#. type: TP
#: man-pages/man2/mmap.2:581
#, no-wrap
msgid "B<ENODEV>"
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:585
msgid ""
"The underlying filesystem of the specified file does not support memory "
"mapping."
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:588
msgid "No memory is available."
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:596
msgid ""
"The process's maximum number of mappings would have been exceeded.  This "
"error can also occur for B<munmap>(), when unmapping a region in the middle "
"of an existing mapping, since this results in two smaller mappings on either"
" side of the region being unmapped."
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:604
msgid ""
"(since Linux 4.7)  The process's B<RLIMIT_DATA> limit, described in "
"B<getrlimit>(2), would have been exceeded."
msgstr ""

#. type: TP
#: man-pages/man2/mmap.2:604
#, no-wrap
msgid "B<EOVERFLOW>"
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:616
msgid ""
"On 32-bit architecture together with the large file extension (i.e., using "
"64-bit I<off_t>): the number of pages used for I<length> plus number of "
"pages used for I<offset> would overflow I<unsigned long> (32 bits)."
msgstr ""

#.  (Since 2.4.25 / 2.6.0.)
#. type: Plain text
#: man-pages/man2/mmap.2:625
msgid ""
"The I<prot> argument asks for B<PROT_EXEC> but the mapped area belongs to a "
"file on a filesystem that was mounted no-exec."
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:629
msgid "The operation was prevented by a file seal; see B<fcntl>(2)."
msgstr ""

#. type: TP
#: man-pages/man2/mmap.2:629
#, no-wrap
msgid "B<ETXTBSY>"
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:635
msgid ""
"B<MAP_DENYWRITE> was set but the object specified by I<fd> is open for "
"writing."
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:637
msgid "Use of a mapped region can result in these signals:"
msgstr ""

#. type: TP
#: man-pages/man2/mmap.2:637
#, no-wrap
msgid "B<SIGSEGV>"
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:640
msgid "Attempted write into a region mapped as read-only."
msgstr ""

#. type: TP
#: man-pages/man2/mmap.2:640
#, no-wrap
msgid "B<SIGBUS>"
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:645
msgid ""
"Attempted access to a portion of the buffer that does not correspond to the "
"file (for example, beyond the end of the file, including the case where "
"another process has truncated the file)."
msgstr ""

#. type: SH
#: man-pages/man2/mmap.2:645
#, no-wrap
msgid "ATTRIBUTES"
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:648
msgid ""
"For an explanation of the terms used in this section, see B<attributes>(7)."
msgstr ""

#. type: tbl table
#: man-pages/man2/mmap.2:652
#, no-wrap
msgid "Interface"
msgstr ""

#. type: tbl table
#: man-pages/man2/mmap.2:652
#, no-wrap
msgid "Attribute"
msgstr ""

#. type: tbl table
#: man-pages/man2/mmap.2:652
#, no-wrap
msgid "Value"
msgstr ""

#. type: tbl table
#: man-pages/man2/mmap.2:656
#, no-wrap
msgid ""
"B<mmap>(),\n"
"B<munmap>()"
msgstr ""

#. type: tbl table
#: man-pages/man2/mmap.2:656
#, no-wrap
msgid "Thread safety"
msgstr ""

#. type: tbl table
#: man-pages/man2/mmap.2:656
#, no-wrap
msgid "MT-Safe"
msgstr ""

#.  SVr4 documents additional error codes ENXIO and ENODEV.
#.  SUSv2 documents additional error codes EMFILE and EOVERFLOW.
#. type: Plain text
#: man-pages/man2/mmap.2:662
msgid "POSIX.1-2001, POSIX.1-2008, SVr4, 4.4BSD."
msgstr ""

#. type: SH
#: man-pages/man2/mmap.2:662
#, no-wrap
msgid "AVAILABILITY"
msgstr ""

#.  POSIX.1-2001: It shall be defined to -1 or 0 or 200112L.
#.  -1: unavailable, 0: ask using sysconf().
#.  glibc defines it to 1.
#. type: Plain text
#: man-pages/man2/mmap.2:676
msgid ""
"On POSIX systems on which B<mmap>(), B<msync>(2), and B<munmap>()  are "
"available, B<_POSIX_MAPPED_FILES> is defined in I<E<lt>unistd.hE<gt>> to a "
"value greater than 0.  (See also B<sysconf>(3).)"
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:689
msgid ""
"On some hardware architectures (e.g., i386), B<PROT_WRITE> implies "
"B<PROT_READ>.  It is architecture dependent whether B<PROT_READ> implies "
"B<PROT_EXEC> or not.  Portable programs should always set B<PROT_EXEC> if "
"they intend to execute code in the new mapping."
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:704
msgid ""
"The portable way to create a mapping is to specify I<addr> as 0 (NULL), and "
"omit B<MAP_FIXED> from I<flags>.  In this case, the system chooses the "
"address for the mapping; the address is chosen so as not to conflict with "
"any existing mapping, and will not be 0.  If the B<MAP_FIXED> flag is "
"specified, and I<addr> is 0 (NULL), then the mapped address will be 0 "
"(NULL)."
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:737
msgid ""
"Certain I<flags> constants are defined only if suitable feature test macros "
"are defined (possibly by default): B<_DEFAULT_SOURCE> with glibc 2.19 or "
"later; or B<_BSD_SOURCE> or B<_SVID_SOURCE> in glibc 2.19 and earlier.  "
"(Employing B<_GNU_SOURCE> also suffices, and requiring that macro "
"specifically would have been more logical, since these flags are all Linux-"
"specific.)  The relevant flags are: B<MAP_32BIT>, B<MAP_ANONYMOUS> (and the "
"synonym B<MAP_ANON>), B<MAP_DENYWRITE>, B<MAP_EXECUTABLE>, B<MAP_FILE>, "
"B<MAP_GROWSDOWN>, B<MAP_HUGETLB>, B<MAP_LOCKED>, B<MAP_NONBLOCK>, "
"B<MAP_NORESERVE>, B<MAP_POPULATE>, and B<MAP_STACK>."
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:742
msgid ""
"An application can determine which pages of a mapping are currently resident"
" in the buffer/page cache using B<mincore>(2)."
msgstr ""

#. type: SS
#: man-pages/man2/mmap.2:742
#, no-wrap
msgid "Using MAP_FIXED safely"
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:754
msgid ""
"The only safe use for B<MAP_FIXED> is where the address range specified by "
"I<addr> and I<length> was previously reserved using another mapping; "
"otherwise, the use of B<MAP_FIXED> is hazardous because it forcibly removes "
"preexisting mappings, making it easy for a multithreaded process to corrupt "
"its own address space."
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:782
msgid ""
"For example, suppose that thread A looks through I</proc/E<lt>pidE<gt>/maps>"
" and in order to locate an unused address range that it can map using "
"B<MAP_FIXED>, while thread B simultaneously acquires part or all of that "
"same address range.  When thread A subsequently employs B<mmap(MAP_FIXED)>, "
"it will effectively clobber the mapping that thread B created.  In this "
"scenario, thread B need not create a mapping directly; simply making a "
"library call that, internally, uses B<dlopen>(3)  to load some other shared "
"library, will suffice.  The B<dlopen>(3)  call will map the library into the"
" process's address space.  Furthermore, almost any library call may be "
"implemented in a way that adds memory mappings to the address space, either "
"with this technique, or by simply allocating memory.  Examples include "
"B<brk>(2), B<malloc>(3), B<pthread_create>(3), and the PAM libraries E<.UR "
"http://www.linux-pam.org> E<.UE .>"
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:789
msgid ""
"Since Linux 4.17, a multithreaded program can use the B<MAP_FIXED_NOREPLACE>"
" flag to avoid the hazard described above when attempting to create a "
"mapping at a fixed address that has not been reserved by a preexisting "
"mapping."
msgstr ""

#. type: SS
#: man-pages/man2/mmap.2:789
#, no-wrap
msgid "Timestamps changes for file-backed mappings"
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:796
msgid ""
"For file-backed mappings, the I<st_atime> field for the mapped file may be "
"updated at any time between the B<mmap>()  and the corresponding unmapping; "
"the first reference to a mapped page will update the field if it has not "
"been already."
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:814
msgid ""
"The I<st_ctime> and I<st_mtime> field for a file mapped with B<PROT_WRITE> "
"and B<MAP_SHARED> will be updated after a write to the mapped region, and "
"before a subsequent B<msync>(2)  with the B<MS_SYNC> or B<MS_ASYNC> flag, if"
" one occurs."
msgstr ""

#. type: SS
#: man-pages/man2/mmap.2:814
#, no-wrap
msgid "Huge page (Huge TLB) mappings"
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:821
msgid ""
"For mappings that employ huge pages, the requirements for the arguments of "
"B<mmap>()  and B<munmap>()  differ somewhat from the requirements for "
"mappings that use the native system page size."
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:829
msgid ""
"For B<mmap>(), I<offset> must be a multiple of the underlying huge page "
"size.  The system automatically aligns I<length> to be a multiple of the "
"underlying huge page size."
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:837
msgid ""
"For B<munmap>(), I<addr> and I<length> must both be a multiple of the "
"underlying huge page size."
msgstr ""

#. type: SS
#: man-pages/man2/mmap.2:837
#, no-wrap
msgid "C library/kernel differences"
msgstr ""

#.  Since around glibc 2.1/2.2, depending on the platform.
#. type: Plain text
#: man-pages/man2/mmap.2:852
msgid ""
"This page describes the interface provided by the glibc B<mmap>()  wrapper "
"function.  Originally, this function invoked a system call of the same name."
"  Since kernel 2.4, that system call has been superseded by B<mmap2>(2), and"
" nowadays the glibc B<mmap>()  wrapper function invokes B<mmap2>(2)  with a "
"suitably adjusted value for I<offset>."
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:857
msgid ""
"On Linux, there are no guarantees like those suggested above under "
"B<MAP_NORESERVE>.  By default, any process can be killed at any moment when "
"the system runs out of memory."
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:864
msgid ""
"In kernels before 2.6.7, the B<MAP_POPULATE> flag has effect only if I<prot>"
" is specified as B<PROT_NONE>."
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:879
msgid ""
"SUSv3 specifies that B<mmap>()  should fail if I<length> is 0.  However, in "
"kernels before 2.6.12, B<mmap>()  succeeded in this case: no mapping was "
"created and the call returned I<addr>.  Since kernel 2.6.12, B<mmap>()  "
"fails with the error B<EINVAL> for this case."
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:896
msgid ""
"POSIX specifies that the system shall always zero fill any partial page at "
"the end of the object and that system will never write any modification of "
"the object beyond its end.  On Linux, when you write data to such partial "
"page after the end of the object, the data stays in the page cache even "
"after the file is closed and unmapped and even though the data is never "
"written to the file itself, subsequent mappings may see the modified "
"content.  In some cases, this could be fixed by calling B<msync>(2)  before "
"the unmap takes place; however, this doesn't work on B<tmpfs>(5)  (for "
"example, when using the POSIX shared memory interface documented in "
"B<shm_overview>(7))."
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:908
msgid ""
"The following program prints part of the file specified in its first "
"command-line argument to standard output.  The range of bytes to be printed "
"is specified via offset and length values in the second and third command-"
"line arguments.  The program creates a memory mapping of the required pages "
"of the file and then uses B<write>(2)  to output the desired bytes."
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:916
#, no-wrap
msgid ""
"#include E<lt>sys/mman.hE<gt>\n"
"#include E<lt>sys/stat.hE<gt>\n"
"#include E<lt>fcntl.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:919
#, no-wrap
msgid ""
"#define handle_error(msg) \\e\n"
"    do { perror(msg); exit(EXIT_FAILURE); } while (0)\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:929
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    char *addr;\n"
"    int fd;\n"
"    struct stat sb;\n"
"    off_t offset, pa_offset;\n"
"    size_t length;\n"
"    ssize_t s;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:934
#, no-wrap
msgid ""
"    if (argc E<lt> 3 || argc E<gt> 4) {\n"
"        fprintf(stderr, \"%s file offset [length]\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:938
#, no-wrap
msgid ""
"    fd = open(argv[1], O_RDONLY);\n"
"    if (fd == -1)\n"
"        handle_error(\"open\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:941
#, no-wrap
msgid ""
"    if (fstat(fd, &sb) == -1)           /* To obtain file size */\n"
"        handle_error(\"fstat\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:945
#, no-wrap
msgid ""
"    offset = atoi(argv[2]);\n"
"    pa_offset = offset & ~(sysconf(_SC_PAGE_SIZE) - 1);\n"
"        /* offset for mmap() must be page aligned */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:950
#, no-wrap
msgid ""
"    if (offset E<gt>= sb.st_size) {\n"
"        fprintf(stderr, \"offset is past end of file\\en\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:956
#, no-wrap
msgid ""
"    if (argc == 4) {\n"
"        length = atoi(argv[3]);\n"
"        if (offset + length E<gt> sb.st_size)\n"
"            length = sb.st_size - offset;\n"
"                /* Can\\(aqt display bytes past end of file */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:960
#, no-wrap
msgid ""
"    } else {    /* No length arg ==E<gt> display to end of file */\n"
"        length = sb.st_size - offset;\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:965
#, no-wrap
msgid ""
"    addr = mmap(NULL, length + offset - pa_offset, PROT_READ,\n"
"                MAP_PRIVATE, fd, pa_offset);\n"
"    if (addr == MAP_FAILED)\n"
"        handle_error(\"mmap\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:970
#, no-wrap
msgid ""
"    s = write(STDOUT_FILENO, addr + offset - pa_offset, length);\n"
"    if (s != length) {\n"
"        if (s == -1)\n"
"            handle_error(\"write\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:974
#, no-wrap
msgid ""
"        fprintf(stderr, \"partial write\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:977
#, no-wrap
msgid ""
"    munmap(addr, length + offset - pa_offset);\n"
"    close(fd);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:980
#, no-wrap
msgid ""
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:997
msgid ""
"B<ftruncate>(2), B<getpagesize>(2), B<memfd_create>(2), B<mincore>(2), "
"B<mlock>(2), B<mmap2>(2), B<mprotect>(2), B<mremap>(2), B<msync>(2), "
"B<remap_file_pages>(2), B<setrlimit>(2), B<shmat>(2), B<userfaultfd>(2), "
"B<shm_open>(3), B<shm_overview>(7)"
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:1004
msgid ""
"The descriptions of the following files in B<proc>(5): I</proc/[pid]/maps>, "
"I</proc/[pid]/map_files>, and I</proc/[pid]/smaps>."
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap.2:1005
msgid "B.O. Gallmeister, POSIX.4, O'Reilly, pp. 128\\(en129 and 389\\(en391."
msgstr ""

#. type: TH
#: man-pages/man2/msgctl.2:38
#, no-wrap
msgid "MSGCTL"
msgstr ""

#. type: Plain text
#: man-pages/man2/msgctl.2:41
msgid "msgctl - System V message control operations"
msgstr ""

#. type: Plain text
#: man-pages/man2/msgctl.2:46
#, no-wrap
msgid ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>sys/ipc.hE<gt>>\n"
"B<#include E<lt>sys/msg.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/msgctl.2:48
#, no-wrap
msgid ""
"B<int msgctl(int >I<msqid>B<, int >I<cmd>B<, struct msqid_ds *>I<buf>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/msgctl.2:55
msgid ""
"B<msgctl>()  performs the control operation specified by I<cmd> on the "
"System\\ V message queue with identifier I<msqid>."
msgstr ""

#. type: Plain text
#: man-pages/man2/msgctl.2:59
msgid ""
"The I<msqid_ds> data structure is defined in I<E<lt>sys/msg.hE<gt>> as "
"follows:"
msgstr ""

#. type: Plain text
#: man-pages/man2/msgctl.2:76
#, no-wrap
msgid ""
"struct msqid_ds {\n"
"    struct ipc_perm msg_perm;     /* Ownership and permissions */\n"
"    time_t          msg_stime;    /* Time of last msgsnd(2) */\n"
"    time_t          msg_rtime;    /* Time of last msgrcv(2) */\n"
"    time_t          msg_ctime;    /* Time of last change */\n"
"    unsigned long   __msg_cbytes; /* Current number of bytes in\n"
"                                     queue (nonstandard) */\n"
"    msgqnum_t       msg_qnum;     /* Current number of messages\n"
"                                     in queue */\n"
"    msglen_t        msg_qbytes;   /* Maximum number of bytes\n"
"                                     allowed in queue */\n"
"    pid_t           msg_lspid;    /* PID of last msgsnd(2) */\n"
"    pid_t           msg_lrpid;    /* PID of last msgrcv(2) */\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/msgctl.2:84
msgid ""
"The I<ipc_perm> structure is defined as follows (the highlighted fields are "
"settable using B<IPC_SET>):"
msgstr ""

#. type: Plain text
#: man-pages/man2/msgctl.2:96
#, no-wrap
msgid ""
"struct ipc_perm {\n"
"    key_t          __key;       /* Key supplied to msgget(2) */\n"
"    uid_t          B<uid>;         /* Effective UID of owner */\n"
"    gid_t          B<gid>;         /* Effective GID of owner */\n"
"    uid_t          cuid;        /* Effective UID of creator */\n"
"    gid_t          cgid;        /* Effective GID of creator */\n"
"    unsigned short B<mode>;        /* Permissions */\n"
"    unsigned short __seq;       /* Sequence number */\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/msgctl.2:102
msgid "Valid values for I<cmd> are:"
msgstr ""

#. type: TP
#: man-pages/man2/msgctl.2:102
#, no-wrap
msgid "B<IPC_STAT>"
msgstr ""

#. type: Plain text
#: man-pages/man2/msgctl.2:111
msgid ""
"Copy information from the kernel data structure associated with I<msqid> "
"into the I<msqid_ds> structure pointed to by I<buf>.  The caller must have "
"read permission on the message queue."
msgstr ""

#. type: TP
#: man-pages/man2/msgctl.2:111
#, no-wrap
msgid "B<IPC_SET>"
msgstr ""

#. type: Plain text
#: man-pages/man2/msgctl.2:138
msgid ""
"Write the values of some members of the I<msqid_ds> structure pointed to by "
"I<buf> to the kernel data structure associated with this message queue, "
"updating also its I<msg_ctime> member.  The following members of the "
"structure are updated: I<msg_qbytes>, I<msg_perm.uid>, I<msg_perm.gid>, and "
"(the least significant 9 bits of)  I<msg_perm.mode>.  The effective UID of "
"the calling process must match the owner (I<msg_perm.uid>)  or creator "
"(I<msg_perm.cuid>)  of the message queue, or the caller must be privileged."
"  Appropriate privilege (Linux: the B<CAP_SYS_RESOURCE> capability) is "
"required to raise the I<msg_qbytes> value beyond the system parameter "
"B<MSGMNB>."
msgstr ""

#. type: TP
#: man-pages/man2/msgctl.2:138
#, no-wrap
msgid "B<IPC_RMID>"
msgstr ""

#. type: Plain text
#: man-pages/man2/msgctl.2:152
msgid ""
"Immediately remove the message queue, awakening all waiting reader and "
"writer processes (with an error return and I<errno> set to B<EIDRM>).  The "
"calling process must have appropriate privileges or its effective user ID "
"must be either that of the creator or owner of the message queue.  The third"
" argument to B<msgctl>()  is ignored in this case."
msgstr ""

#. type: TP
#: man-pages/man2/msgctl.2:152
#, no-wrap
msgid "B<IPC_INFO> (Linux-specific)"
msgstr ""

#. type: Plain text
#: man-pages/man2/msgctl.2:165
msgid ""
"Return information about system-wide message queue limits and parameters in "
"the structure pointed to by I<buf>.  This structure is of type I<msginfo> "
"(thus, a cast is required), defined in I<E<lt>sys/msg.hE<gt>> if the "
"B<_GNU_SOURCE> feature test macro is defined:"
msgstr ""

#. type: Plain text
#: man-pages/man2/msgctl.2:189
#, no-wrap
msgid ""
"struct msginfo {\n"
"    int msgpool; /* Size in kibibytes of buffer pool\n"
"                    used to hold message data;\n"
"                    unused within kernel */\n"
"    int msgmap;  /* Maximum number of entries in message\n"
"                    map; unused within kernel */\n"
"    int msgmax;  /* Maximum number of bytes that can be\n"
"                    written in a single message */\n"
"    int msgmnb;  /* Maximum number of bytes that can be\n"
"                    written to queue; used to initialize\n"
"                    msg_qbytes during queue creation\n"
"                    (msgget(2)) */\n"
"    int msgmni;  /* Maximum number of message queues */\n"
"    int msgssz;  /* Message segment size;\n"
"                    unused within kernel */\n"
"    int msgtql;  /* Maximum number of messages on all queues\n"
"                    in system; unused within kernel */\n"
"    unsigned short int msgseg;\n"
"                 /* Maximum number of segments;\n"
"                    unused within kernel */\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/msgctl.2:202
msgid ""
"The I<msgmni>, I<msgmax>, and I<msgmnb> settings can be changed via I</proc>"
" files of the same name; see B<proc>(5)  for details."
msgstr ""

#. type: TP
#: man-pages/man2/msgctl.2:202
#, no-wrap
msgid "B<MSG_INFO> (Linux-specific)"
msgstr ""

#. type: Plain text
#: man-pages/man2/msgctl.2:219
msgid ""
"Return a I<msginfo> structure containing the same information as for "
"B<IPC_INFO>, except that the following fields are returned with information "
"about system resources consumed by message queues: the I<msgpool> field "
"returns the number of message queues that currently exist on the system; the"
" I<msgmap> field returns the total number of messages in all queues on the "
"system; and the I<msgtql> field returns the total number of bytes in all "
"messages in all queues on the system."
msgstr ""

#. type: TP
#: man-pages/man2/msgctl.2:219
#, no-wrap
msgid "B<MSG_STAT> (Linux-specific)"
msgstr ""

#. type: Plain text
#: man-pages/man2/msgctl.2:230
msgid ""
"Return a I<msqid_ds> structure as for B<IPC_STAT>.  However, the I<msqid> "
"argument is not a queue identifier, but instead an index into the kernel's "
"internal array that maintains information about all message queues on the "
"system."
msgstr ""

#. type: TP
#: man-pages/man2/msgctl.2:230
#, no-wrap
msgid "B<MSG_STAT_ANY> (Linux-specific, since Linux 4.17)"
msgstr ""

#. type: Plain text
#: man-pages/man2/msgctl.2:243
msgid ""
"Return a I<msqid_ds> structure as for B<MSG_STAT>.  However, "
"I<msg_perm.mode> is not checked for read access for I<msqid> meaning that "
"any user can employ this operation (just as any user may read "
"I</proc/sysvipc/msg> to obtain the same information)."
msgstr ""

#. type: Plain text
#: man-pages/man2/msgctl.2:268
msgid ""
"On success, B<IPC_STAT>, B<IPC_SET>, and B<IPC_RMID> return 0.  A successful"
" B<IPC_INFO> or B<MSG_INFO> operation returns the index of the highest used "
"entry in the kernel's internal array recording information about all message"
" queues.  (This information can be used with repeated B<MSG_STAT> or "
"B<MSG_STAT_ANY> operations to obtain information about all queues on the "
"system.)  A successful B<MSG_STAT> or B<MSG_STAT_ANY> operation returns the "
"identifier of the queue whose index was given in I<msqid>."
msgstr ""

#. type: Plain text
#: man-pages/man2/msgctl.2:272
msgid "On error, -1 is returned with I<errno> indicating the error."
msgstr ""

#. type: Plain text
#: man-pages/man2/msgctl.2:276
msgid "On failure, I<errno> is set to one of the following:"
msgstr ""

#. type: Plain text
#: man-pages/man2/msgctl.2:289
msgid ""
"The argument I<cmd> is equal to B<IPC_STAT> or B<MSG_STAT>, but the calling "
"process does not have read permission on the message queue I<msqid>, and "
"does not have the B<CAP_IPC_OWNER> capability in the user namespace that "
"governs its IPC namespace."
msgstr ""

#. type: Plain text
#: man-pages/man2/msgctl.2:300
msgid ""
"The argument I<cmd> has the value B<IPC_SET> or B<IPC_STAT>, but the address"
" pointed to by I<buf> isn't accessible."
msgstr ""

#. type: TP
#: man-pages/man2/msgctl.2:300
#, no-wrap
msgid "B<EIDRM>"
msgstr ""

#. type: Plain text
#: man-pages/man2/msgctl.2:303
msgid "The message queue was removed."
msgstr ""

#. type: Plain text
#: man-pages/man2/msgctl.2:314
msgid ""
"Invalid value for I<cmd> or I<msqid>.  Or: for a B<MSG_STAT> operation, the "
"index value specified in I<msqid> referred to an array slot that is "
"currently unused."
msgstr ""

#. type: Plain text
#: man-pages/man2/msgctl.2:332
msgid ""
"The argument I<cmd> has the value B<IPC_SET> or B<IPC_RMID>, but the "
"effective user ID of the calling process is not the creator (as found in "
"I<msg_perm.cuid>)  or the owner (as found in I<msg_perm.uid>)  of the "
"message queue, and the caller is not privileged (Linux: does not have the "
"B<CAP_SYS_ADMIN> capability)."
msgstr ""

#. type: Plain text
#: man-pages/man2/msgctl.2:343
msgid ""
"An attempt (B<IPC_SET>)  was made to increase I<msg_qbytes> beyond the "
"system parameter B<MSGMNB>, but the caller is not privileged (Linux: does "
"not have the B<CAP_SYS_RESOURCE> capability)."
msgstr ""

#.  SVID does not document the EIDRM error condition.
#. type: Plain text
#: man-pages/man2/msgctl.2:346
msgid "POSIX.1-2001, POSIX.1-2008, SVr4."
msgstr ""

#.  Like Linux, the FreeBSD man pages still document
#.  the inclusion of these header files.
#. type: Plain text
#: man-pages/man2/msgctl.2:359
msgid ""
"The inclusion of I<E<lt>sys/types.hE<gt>> and I<E<lt>sys/ipc.hE<gt>> isn't "
"required on Linux or by any version of POSIX.  However, some old "
"implementations required the inclusion of these header files, and the SVID "
"also documented their inclusion.  Applications intended to be portable to "
"such old systems may need to include these header files."
msgstr ""

#. type: Plain text
#: man-pages/man2/msgctl.2:371
msgid ""
"The B<IPC_INFO>, B<MSG_STAT> and B<MSG_INFO> operations are used by the "
"B<ipcs>(1)  program to provide information on allocated resources.  In the "
"future these may modified or moved to a I</proc> filesystem interface."
msgstr ""

#. type: Plain text
#: man-pages/man2/msgctl.2:385
msgid ""
"Various fields in the I<struct msqid_ds> were typed as I<short> under Linux "
"2.2 and have become I<long> under Linux 2.4.  To take advantage of this, a "
"recompilation under glibc-2.1.91 or later should suffice.  (The kernel "
"distinguishes old and new calls by an B<IPC_64> flag in I<cmd>.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/msgctl.2:391
msgid ""
"B<msgget>(2), B<msgrcv>(2), B<msgsnd>(2), B<capabilities>(7), "
"B<mq_overview>(7), B<sysvipc>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/memfd_create.2:21
#, no-wrap
msgid "MEMFD_CREATE"
msgstr ""

#. type: Plain text
#: man-pages/man2/memfd_create.2:24
msgid "memfd_create - create an anonymous file"
msgstr ""

#. type: Plain text
#: man-pages/man2/memfd_create.2:28
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>         /* See feature_test_macros(7) */\n"
"B<#include E<lt>sys/mman.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/memfd_create.2:30
#, no-wrap
msgid "B<int memfd_create(const char *>I<name>B<, unsigned int >I<flags>B<);>\n"
msgstr ""

#.  David Herrmann:
#.      memfd uses VM_NORESERVE so each page is accounted on first access.
#.      This means, the overcommit-limits (see __vm_enough_memory()) and the
#.      memory-cgroup limits (mem_cgroup_try_charge()) are applied. Note that
#.      those are accounted on "current" and "current->mm", that is, the
#.      process doing the first page access.
#. type: Plain text
#: man-pages/man2/memfd_create.2:53
msgid ""
"B<memfd_create>()  creates an anonymous file and returns a file descriptor "
"that refers to it.  The file behaves like a regular file, and so can be "
"modified, truncated, memory-mapped, and so on.  However, unlike a regular "
"file, it lives in RAM and has a volatile backing storage.  Once all "
"references to the file are dropped, it is automatically released.  Anonymous"
" memory is used for all backing pages of the file.  Therefore, files created"
" by B<memfd_create>()  have the same semantics as other anonymous memory "
"allocations such as those allocated using B<mmap>(2)  with the "
"B<MAP_ANONYMOUS> flag."
msgstr ""

#. type: Plain text
#: man-pages/man2/memfd_create.2:60
msgid ""
"The initial size of the file is set to 0.  Following the call, the file size"
" should be set using B<ftruncate>(2).  (Alternatively, the file may be "
"populated by calls to B<write>(2)  or similar.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/memfd_create.2:71
msgid ""
"The name supplied in I<name> is used as a filename and will be displayed as "
"the target of the corresponding symbolic link in the directory "
"I</proc/self/fd/>.  The displayed name is always prefixed with I<memfd:> and"
" serves only for debugging purposes.  Names do not affect the behavior of "
"the file descriptor, and as such multiple files can have the same name "
"without any side effects."
msgstr ""

#. type: Plain text
#: man-pages/man2/memfd_create.2:76
msgid ""
"The following values may be bitwise ORed in I<flags> to change the behavior "
"of B<memfd_create>():"
msgstr ""

#. type: TP
#: man-pages/man2/memfd_create.2:76
#, no-wrap
msgid "B<MFD_CLOEXEC>"
msgstr ""

#. type: Plain text
#: man-pages/man2/memfd_create.2:86
msgid ""
"Set the close-on-exec (B<FD_CLOEXEC>)  flag on the new file descriptor.  See"
" the description of the B<O_CLOEXEC> flag in B<open>(2)  for reasons why "
"this may be useful."
msgstr ""

#. type: TP
#: man-pages/man2/memfd_create.2:86
#, no-wrap
msgid "B<MFD_ALLOW_SEALING>"
msgstr ""

#.  FIXME Why is the MFD_ALLOW_SEALING behavior not simply the default?
#.  Is it worth adding some text explaining this?
#. type: Plain text
#: man-pages/man2/memfd_create.2:102
msgid ""
"Allow sealing operations on this file.  See the discussion of the "
"B<F_ADD_SEALS> and B<F_GET_SEALS> operations in B<fcntl>(2), and also NOTES,"
" below.  The initial set of seals is empty.  If this flag is not set, the "
"initial set of seals will be B<F_SEAL_SEAL>, meaning that no other seals can"
" be set on the file."
msgstr ""

#. type: TP
#: man-pages/man2/memfd_create.2:102
#, no-wrap
msgid "B<MFD_HUGETLB> (since Linux 4.14)"
msgstr ""

#.  commit 749df87bd7bee5a79cef073f5d032ddb2b211de8
#.  commit 47b9012ecdc747f6936395265e677d41e11a31ff
#. type: Plain text
#: man-pages/man2/memfd_create.2:118
msgid ""
"The anonymous file will be created in the hugetlbfs filesystem using huge "
"pages.  See the Linux kernel source file I<Documentation/admin-"
"guide/mm/hugetlbpage.rst> for more information about hugetlbfs.  Specifying "
"both B<MFD_HUGETLB> and B<MFD_ALLOW_SEALING> in I<flags> is supported since "
"Linux 4.16."
msgstr ""

#. type: TP
#: man-pages/man2/memfd_create.2:118
#, no-wrap
msgid "B<MFD_HUGE_2MB>, B<MFD_HUGE_1GB>, B<...>"
msgstr ""

#. type: Plain text
#: man-pages/man2/memfd_create.2:127
msgid ""
"Used in conjunction with B<MFD_HUGETLB> to select alternative hugetlb page "
"sizes (respectively, 2\\ MB, 1\\ GB, ...)  on systems that support multiple "
"hugetlb page sizes.  Definitions for known huge page sizes are included in "
"the header file I<E<lt>linux/memfd.hE<gt>.>"
msgstr ""

#. type: Plain text
#: man-pages/man2/memfd_create.2:131
msgid ""
"For details on encoding huge page sizes not included in the header file, see"
" the discussion of the similarly named constants in B<mmap>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/memfd_create.2:135
msgid "Unused bits in I<flags> must be 0."
msgstr ""

#. type: Plain text
#: man-pages/man2/memfd_create.2:144
msgid ""
"As its return value, B<memfd_create>()  returns a new file descriptor that "
"can be used to refer to the file.  This file descriptor is opened for both "
"reading and writing (B<O_RDWR>)  and B<O_LARGEFILE> is set for the file "
"descriptor."
msgstr ""

#. type: Plain text
#: man-pages/man2/memfd_create.2:157
msgid ""
"With respect to B<fork>(2)  and B<execve>(2), the usual semantics apply for "
"the file descriptor created by B<memfd_create>().  A copy of the file "
"descriptor is inherited by the child produced by B<fork>(2)  and refers to "
"the same file.  The file descriptor is preserved across B<execve>(2), unless"
" the close-on-exec flag has been set."
msgstr ""

#. type: Plain text
#: man-pages/man2/memfd_create.2:164
msgid ""
"On success, B<memfd_create>()  returns a new file descriptor.  On error, -1 "
"is returned and I<errno> is set to indicate the error."
msgstr ""

#. type: Plain text
#: man-pages/man2/memfd_create.2:170
msgid "The address in I<name> points to invalid memory."
msgstr ""

#. type: Plain text
#: man-pages/man2/memfd_create.2:174
msgid "I<flags> included unknown bits."
msgstr ""

#.  NAME_MAX - strlen("memfd:")
#. type: Plain text
#: man-pages/man2/memfd_create.2:181
msgid ""
"I<name> was too long.  (The limit is 249 bytes, excluding the terminating "
"null byte.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/memfd_create.2:189
msgid ""
"Both B<MFD_HUGETLB> and B<MFD_ALLOW_SEALING> were specified in I<flags>."
msgstr ""

#. type: TP
#: man-pages/man2/memfd_create.2:189
#, no-wrap
msgid "B<EMFILE>"
msgstr ""

#. type: Plain text
#: man-pages/man2/memfd_create.2:192
msgid ""
"The per-process limit on the number of open file descriptors has been "
"reached."
msgstr ""

#. type: Plain text
#: man-pages/man2/memfd_create.2:198
msgid "There was insufficient memory to create a new anonymous file."
msgstr ""

#. type: Plain text
#: man-pages/man2/memfd_create.2:203
msgid ""
"The B<memfd_create>()  system call first appeared in Linux 3.17; glibc "
"support was added in version 2.27."
msgstr ""

#. type: Plain text
#: man-pages/man2/memfd_create.2:207
msgid "The B<memfd_create>()  system call is Linux-specific."
msgstr ""

#.  See also http://lwn.net/Articles/593918/
#.  and http://lwn.net/Articles/594919/ and http://lwn.net/Articles/591108/
#. type: Plain text
#: man-pages/man2/memfd_create.2:221
msgid ""
"The B<memfd_create>()  system call provides a simple alternative to manually"
" mounting a B<tmpfs>(5)  filesystem and creating and opening a file in that "
"filesystem.  The primary purpose of B<memfd_create>()  is to create files "
"and associated file descriptors that are used with the file-sealing APIs "
"provided by B<fcntl>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/memfd_create.2:235
msgid ""
"The B<memfd_create>()  system call also has uses without file sealing (which"
" is why file-sealing is disabled, unless explicitly requested with the "
"B<MFD_ALLOW_SEALING> flag).  In particular, it can be used as an alternative"
" to creating files in I<tmp> or as an alternative to using the B<open>(2)  "
"B<O_TMPFILE> in cases where there is no intention to actually link the "
"resulting file into the filesystem."
msgstr ""

#. type: SS
#: man-pages/man2/memfd_create.2:235
#, no-wrap
msgid "File sealing"
msgstr ""

#. type: Plain text
#: man-pages/man2/memfd_create.2:253
msgid ""
"In the absence of file sealing, processes that communicate via shared memory"
" must either trust each other, or take measures to deal with the possibility"
" that an untrusted peer may manipulate the shared memory region in "
"problematic ways.  For example, an untrusted peer might modify the contents "
"of the shared memory at any time, or shrink the shared memory region.  The "
"former possibility leaves the local process vulnerable to time-of-check-to-"
"time-of-use race conditions (typically dealt with by copying data from the "
"shared memory region before checking and using it).  The latter possibility "
"leaves the local process vulnerable to B<SIGBUS> signals when an attempt is "
"made to access a now-nonexistent location in the shared memory region.  "
"(Dealing with this possibility necessitates the use of a handler for the "
"B<SIGBUS> signal.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/memfd_create.2:259
msgid ""
"Dealing with untrusted peers imposes extra complexity on code that employs "
"shared memory.  Memory sealing enables that extra complexity to be "
"eliminated, by allowing a process to operate secure in the knowledge that "
"its peer can't modify the shared memory in an undesired fashion."
msgstr ""

#. type: Plain text
#: man-pages/man2/memfd_create.2:261
msgid "An example of the usage of the sealing mechanism is as follows:"
msgstr ""

#. type: IP
#: man-pages/man2/memfd_create.2:261
#, no-wrap
msgid "1."
msgstr ""

#. type: Plain text
#: man-pages/man2/memfd_create.2:267
msgid ""
"The first process creates a B<tmpfs>(5)  file using B<memfd_create>().  The "
"call yields a file descriptor used in subsequent steps."
msgstr ""

#. type: IP
#: man-pages/man2/memfd_create.2:267
#, no-wrap
msgid "2."
msgstr ""

#. type: Plain text
#: man-pages/man2/memfd_create.2:274
msgid ""
"The first process sizes the file created in the previous step using "
"B<ftruncate>(2), maps it using B<mmap>(2), and populates the shared memory "
"with the desired data."
msgstr ""

#. type: IP
#: man-pages/man2/memfd_create.2:274
#, no-wrap
msgid "3."
msgstr ""

#. type: Plain text
#: man-pages/man2/memfd_create.2:284
msgid ""
"The first process uses the B<fcntl>(2)  B<F_ADD_SEALS> operation to place "
"one or more seals on the file, in order to restrict further modifications on"
" the file.  (If placing the seal B<F_SEAL_WRITE>, then it will be necessary "
"to first unmap the shared writable mapping created in the previous step.)"
msgstr ""

#. type: IP
#: man-pages/man2/memfd_create.2:284
#, no-wrap
msgid "4."
msgstr ""

#. type: Plain text
#: man-pages/man2/memfd_create.2:289
msgid ""
"A second process obtains a file descriptor for the B<tmpfs>(5)  file and "
"maps it.  Among the possible ways in which this could happen are the "
"following:"
msgstr ""

#. type: Plain text
#: man-pages/man2/memfd_create.2:300
msgid ""
"The process that called B<memfd_create>()  could transfer the resulting file"
" descriptor to the second process via a UNIX domain socket (see B<unix>(7)  "
"and B<cmsg>(3)).  The second process then maps the file using B<mmap>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/memfd_create.2:308
msgid ""
"The second process is created via B<fork>(2)  and thus automatically "
"inherits the file descriptor and mapping.  (Note that in this case and the "
"next, there is a natural trust relationship between the two processes, since"
" they are running under the same user ID.  Therefore, file sealing would not"
" normally be necessary.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/memfd_create.2:322
msgid ""
"The second process opens the file I</proc/E<lt>pidE<gt>/fd/E<lt>fdE<gt>>, "
"where I<E<lt>pidE<gt>> is the PID of the first process (the one that called "
"B<memfd_create>()), and I<E<lt>fdE<gt>> is the number of the file descriptor"
" returned by the call to B<memfd_create>()  in that process.  The second "
"process then maps the file using B<mmap>(2)."
msgstr ""

#. type: IP
#: man-pages/man2/memfd_create.2:323
#, no-wrap
msgid "5."
msgstr ""

#. type: Plain text
#: man-pages/man2/memfd_create.2:335
msgid ""
"The second process uses the B<fcntl>(2)  B<F_GET_SEALS> operation to "
"retrieve the bit mask of seals that has been applied to the file.  This bit "
"mask can be inspected in order to determine what kinds of restrictions have "
"been placed on file modifications.  If desired, the second process can apply"
" further seals to impose additional restrictions (so long as the "
"B<F_SEAL_SEAL> seal has not yet been applied)."
msgstr ""

#. type: Plain text
#: man-pages/man2/memfd_create.2:339
msgid ""
"Below are shown two example programs that demonstrate the use of "
"B<memfd_create>()  and the file sealing API."
msgstr ""

#. type: Plain text
#: man-pages/man2/memfd_create.2:354
msgid ""
"The first program, I<t_memfd_create.c>, creates a B<tmpfs>(5)  file using "
"B<memfd_create>(), sets a size for the file, maps it into memory, and "
"optionally places some seals on the file.  The program accepts up to three "
"command-line arguments, of which the first two are required.  The first "
"argument is the name to associate with the file, the second argument is the "
"size to be set for the file, and the optional third argument is a string of "
"characters that specify seals to be set on file."
msgstr ""

#. type: Plain text
#: man-pages/man2/memfd_create.2:360
msgid ""
"The second program, I<t_get_seals.c>, can be used to open an existing file "
"that was created via B<memfd_create>()  and inspect the set of seals that "
"have been applied to that file."
msgstr ""

#. type: Plain text
#: man-pages/man2/memfd_create.2:365
msgid ""
"The following shell session demonstrates the use of these programs.  First "
"we create a B<tmpfs>(5)  file and set some seals on it:"
msgstr ""

#. type: Plain text
#: man-pages/man2/memfd_create.2:371
#, no-wrap
msgid ""
"$ B<./t_memfd_create my_memfd_file 4096 sw &>\n"
"[1] 11775\n"
"PID: 11775; fd: 3; /proc/11775/fd/3\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/memfd_create.2:389
msgid ""
"At this point, the I<t_memfd_create> program continues to run in the "
"background.  From another program, we can obtain a file descriptor for the "
"file created by B<memfd_create>()  by opening the I</proc/[pid]/fd> file "
"that corresponds to the file descriptor opened by B<memfd_create>().  Using "
"that pathname, we inspect the content of the I</proc/[pid]/fd> symbolic "
"link, and use our I<t_get_seals> program to view the seals that have been "
"placed on the file:"
msgstr ""

#. type: Plain text
#: man-pages/man2/memfd_create.2:396
#, no-wrap
msgid ""
"$ B<readlink /proc/11775/fd/3>\n"
"/memfd:my_memfd_file (deleted)\n"
"$ B<./t_get_seals /proc/11775/fd/3>\n"
"Existing seals: WRITE SHRINK\n"
msgstr ""

#. type: SS
#: man-pages/man2/memfd_create.2:398
#, no-wrap
msgid "Program source: t_memfd_create.c"
msgstr ""

#. type: Plain text
#: man-pages/man2/memfd_create.2:408
#, no-wrap
msgid ""
"#define _GNU_SOURCE\n"
"#include E<lt>sys/mman.hE<gt>\n"
"#include E<lt>fcntl.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/memfd_create.2:411 man-pages/man2/memfd_create.2:494
#, no-wrap
msgid ""
"#define errExit(msg)    do { perror(msg); exit(EXIT_FAILURE); \\e\n"
"                        } while (0)\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/memfd_create.2:420
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int fd;\n"
"    unsigned int seals;\n"
"    char *addr;\n"
"    char *name, *seals_arg;\n"
"    ssize_t len;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/memfd_create.2:431
#, no-wrap
msgid ""
"    if (argc E<lt> 3) {\n"
"        fprintf(stderr, \"%s name size [seals]\\en\", argv[0]);\n"
"        fprintf(stderr, \"\\et\\(aqseals\\(aq can contain any of the \"\n"
"                \"following characters:\\en\");\n"
"        fprintf(stderr, \"\\et\\etg - F_SEAL_GROW\\en\");\n"
"        fprintf(stderr, \"\\et\\ets - F_SEAL_SHRINK\\en\");\n"
"        fprintf(stderr, \"\\et\\etw - F_SEAL_WRITE\\en\");\n"
"        fprintf(stderr, \"\\et\\etS - F_SEAL_SEAL\\en\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/memfd_create.2:435
#, no-wrap
msgid ""
"    name = argv[1];\n"
"    len = atoi(argv[2]);\n"
"    seals_arg = argv[3];\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/memfd_create.2:438
#, no-wrap
msgid ""
"    /* Create an anonymous file in tmpfs; allow seals to be\n"
"       placed on the file */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/memfd_create.2:442
#, no-wrap
msgid ""
"    fd = memfd_create(name, MFD_ALLOW_SEALING);\n"
"    if (fd == -1)\n"
"        errExit(\"memfd_create\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/memfd_create.2:444
#, no-wrap
msgid "    /* Size the file as specified on the command line */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/memfd_create.2:447
#, no-wrap
msgid ""
"    if (ftruncate(fd, len) == -1)\n"
"        errExit(\"truncate\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/memfd_create.2:450
#, no-wrap
msgid ""
"    printf(\"PID: %ld; fd: %d; /proc/%ld/fd/%d\\en\",\n"
"            (long) getpid(), fd, (long) getpid(), fd);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/memfd_create.2:453
#, no-wrap
msgid ""
"    /* Code to map the file and populate the mapping with data\n"
"       omitted */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/memfd_create.2:456
#, no-wrap
msgid ""
"    /* If a \\(aqseals\\(aq command-line argument was supplied, set some\n"
"       seals on the file */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/memfd_create.2:459
#, no-wrap
msgid ""
"    if (seals_arg != NULL) {\n"
"        seals = 0;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/memfd_create.2:468
#, no-wrap
msgid ""
"        if (strchr(seals_arg, \\(aqg\\(aq) != NULL)\n"
"            seals |= F_SEAL_GROW;\n"
"        if (strchr(seals_arg, \\(aqs\\(aq) != NULL)\n"
"            seals |= F_SEAL_SHRINK;\n"
"        if (strchr(seals_arg, \\(aqw\\(aq) != NULL)\n"
"            seals |= F_SEAL_WRITE;\n"
"        if (strchr(seals_arg, \\(aqS\\(aq) != NULL)\n"
"            seals |= F_SEAL_SEAL;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/memfd_create.2:472
#, no-wrap
msgid ""
"        if (fcntl(fd, F_ADD_SEALS, seals) == -1)\n"
"            errExit(\"fcntl\");\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/memfd_create.2:475
#, no-wrap
msgid ""
"    /* Keep running, so that the file created by memfd_create()\n"
"       continues to exist */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/memfd_create.2:477
#, no-wrap
msgid "    pause();\n"
msgstr ""

#. type: SS
#: man-pages/man2/memfd_create.2:481
#, no-wrap
msgid "Program source: t_get_seals.c"
msgstr ""

#. type: Plain text
#: man-pages/man2/memfd_create.2:491
#, no-wrap
msgid ""
"#define _GNU_SOURCE\n"
"#include E<lt>sys/mman.hE<gt>\n"
"#include E<lt>fcntl.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/memfd_create.2:500
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int fd;\n"
"    unsigned int seals;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/memfd_create.2:505
#, no-wrap
msgid ""
"    if (argc != 2) {\n"
"        fprintf(stderr, \"%s /proc/PID/fd/FD\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/memfd_create.2:509
#, no-wrap
msgid ""
"    fd = open(argv[1], O_RDWR);\n"
"    if (fd == -1)\n"
"        errExit(\"open\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/memfd_create.2:513
#, no-wrap
msgid ""
"    seals = fcntl(fd, F_GET_SEALS);\n"
"    if (seals == -1)\n"
"        errExit(\"fcntl\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/memfd_create.2:524
#, no-wrap
msgid ""
"    printf(\"Existing seals:\");\n"
"    if (seals & F_SEAL_SEAL)\n"
"        printf(\" SEAL\");\n"
"    if (seals & F_SEAL_GROW)\n"
"        printf(\" GROW\");\n"
"    if (seals & F_SEAL_WRITE)\n"
"        printf(\" WRITE\");\n"
"    if (seals & F_SEAL_SHRINK)\n"
"        printf(\" SHRINK\");\n"
"    printf(\"\\en\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/memfd_create.2:527
#, no-wrap
msgid ""
"    /* Code to map the file and access the contents of the\n"
"       resulting mapping omitted */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/memfd_create.2:536
msgid "B<fcntl>(2), B<ftruncate>(2), B<mmap>(2), B<shmget>(2), B<shm_open>(3)"
msgstr ""

#. type: TH
#: man-pages/man2/mknod.2:15
#, no-wrap
msgid "MKNOD"
msgstr ""

#. type: Plain text
#: man-pages/man2/mknod.2:18
msgid "mknod, mknodat - create a special or ordinary file"
msgstr ""

#. type: Plain text
#: man-pages/man2/mknod.2:24
#, no-wrap
msgid ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>sys/stat.hE<gt>>\n"
"B<#include E<lt>fcntl.hE<gt>>\n"
"B<#include E<lt>unistd.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/mknod.2:26
#, no-wrap
msgid ""
"B<int mknod(const char *>I<pathname>B<, mode_t >I<mode>B<, dev_t "
">I<dev>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/mknod.2:32
#, no-wrap
msgid ""
"B<int mknodat(int >I<dirfd>B<, const char *>I<pathname>B<, mode_t "
">I<mode>B<, dev_t >I<dev>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/mknod.2:40
msgid "B<mknod>():"
msgstr ""

#.     || _XOPEN_SOURCE\ &&\ _XOPEN_SOURCE_EXTENDED
#. type: Plain text
#: man-pages/man2/mknod.2:46
#, no-wrap
msgid ""
"_XOPEN_SOURCE\\ E<gt>=\\ 500\n"
"    || /* Since glibc 2.19: */ _DEFAULT_SOURCE\n"
"    || /* Glibc versions E<lt>= 2.19: */ _BSD_SOURCE || _SVID_SOURCE\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/mknod.2:58
msgid ""
"The system call B<mknod>()  creates a filesystem node (file, device special "
"file, or named pipe) named I<pathname>, with attributes specified by I<mode>"
" and I<dev>."
msgstr ""

#. type: Plain text
#: man-pages/man2/mknod.2:66
msgid ""
"The I<mode> argument specifies both the file mode to use and the type of "
"node to be created.  It should be a combination (using bitwise OR) of one of"
" the file types listed below and zero or more of the file mode bits listed "
"in B<inode>(7)."
msgstr ""

#. type: Plain text
#: man-pages/man2/mknod.2:72
msgid ""
"The file mode is modified by the process's I<umask> in the usual way: in the"
" absence of a default ACL, the permissions of the created node are (I<mode> "
"& ~I<umask>)."
msgstr ""

#.  (S_IFSOCK since Linux 1.2.4)
#. type: Plain text
#: man-pages/man2/mknod.2:86
msgid ""
"The file type must be one of B<S_IFREG>, B<S_IFCHR>, B<S_IFBLK>, B<S_IFIFO>,"
" or B<S_IFSOCK> to specify a regular file (which will be created empty), "
"character special file, block special file, FIFO (named pipe), or UNIX "
"domain socket, respectively.  (Zero file type is equivalent to type "
"B<S_IFREG>.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/mknod.2:99
msgid ""
"If the file type is B<S_IFCHR> or B<S_IFBLK>, then I<dev> specifies the "
"major and minor numbers of the newly created device special file "
"(B<makedev>(3)  may be useful to build the value for I<dev>); otherwise it "
"is ignored."
msgstr ""

#. type: Plain text
#: man-pages/man2/mknod.2:105
msgid ""
"If I<pathname> already exists, or is a symbolic link, this call fails with "
"an B<EEXIST> error."
msgstr ""

#. type: Plain text
#: man-pages/man2/mknod.2:114
msgid ""
"The newly created node will be owned by the effective user ID of the "
"process.  If the directory containing the node has the set-group-ID bit set,"
" or if the filesystem is mounted with BSD group semantics, the new node will"
" inherit the group ownership from its parent directory; otherwise it will be"
" owned by the effective group ID of the process."
msgstr ""

#. type: SS
#: man-pages/man2/mknod.2:114
#, no-wrap
msgid "mknodat()"
msgstr ""

#. type: Plain text
#: man-pages/man2/mknod.2:120
msgid ""
"The B<mknodat>()  system call operates in exactly the same way as "
"B<mknod>(), except for the differences described here."
msgstr ""

#. type: Plain text
#: man-pages/man2/mknod.2:130
msgid ""
"If the pathname given in I<pathname> is relative, then it is interpreted "
"relative to the directory referred to by the file descriptor I<dirfd> "
"(rather than relative to the current working directory of the calling "
"process, as is done by B<mknod>()  for a relative pathname)."
msgstr ""

#. type: Plain text
#: man-pages/man2/mknod.2:142
msgid ""
"If I<pathname> is relative and I<dirfd> is the special value B<AT_FDCWD>, "
"then I<pathname> is interpreted relative to the current working directory of"
" the calling process (like B<mknod>())."
msgstr ""

#. type: Plain text
#: man-pages/man2/mknod.2:153
msgid "See B<openat>(2)  for an explanation of the need for B<mknodat>()."
msgstr ""

#. type: Plain text
#: man-pages/man2/mknod.2:160
msgid ""
"B<mknod>()  and B<mknodat>()  return zero on success, or -1 if an error "
"occurred (in which case, I<errno> is set appropriately)."
msgstr ""

#. type: Plain text
#: man-pages/man2/mknod.2:169
msgid ""
"The parent directory does not allow write permission to the process, or one "
"of the directories in the path prefix of I<pathname> did not allow search "
"permission.  (See also B<path_resolution>(7).)"
msgstr ""

#. type: Plain text
#: man-pages/man2/mknod.2:180
msgid ""
"I<pathname> already exists.  This includes the case where I<pathname> is a "
"symbolic link, dangling or not."
msgstr ""

#. type: Plain text
#: man-pages/man2/mknod.2:188
msgid ""
"I<mode> requested creation of something other than a regular file, device "
"special file, FIFO or socket."
msgstr ""

#. type: Plain text
#: man-pages/man2/mknod.2:208
msgid "The device containing I<pathname> has no room for the new node."
msgstr ""

#.  For UNIX domain sockets and regular files, EPERM is returned only in
#.  Linux 2.2 and earlier; in Linux 2.4 and later, unprivileged can
#.  use mknod() to make these files.
#. type: Plain text
#: man-pages/man2/mknod.2:227
msgid ""
"I<mode> requested creation of something other than a regular file, FIFO "
"(named pipe), or UNIX domain socket, and the caller is not privileged "
"(Linux: does not have the B<CAP_MKNOD> capability); also returned if the "
"filesystem containing I<pathname> does not support the type of node "
"requested."
msgstr ""

#. type: Plain text
#: man-pages/man2/mknod.2:234
msgid "The following additional errors can occur for B<mknodat>():"
msgstr ""

#. type: Plain text
#: man-pages/man2/mknod.2:248
msgid ""
"B<mknodat>()  was added to Linux in kernel 2.6.16; library support was added"
" to glibc in version 2.4."
msgstr ""

#.  The Linux version differs from the SVr4 version in that it
#.  does not require root permission to create pipes, also in that no
#.  EMULTIHOP, ENOLINK, or EINTR error is documented.
#. type: Plain text
#: man-pages/man2/mknod.2:254
msgid "B<mknod>(): SVr4, 4.4BSD, POSIX.1-2001 (but see below), POSIX.1-2008."
msgstr ""

#. type: Plain text
#: man-pages/man2/mknod.2:257
msgid "B<mknodat>(): POSIX.1-2008."
msgstr ""

#. type: Plain text
#: man-pages/man2/mknod.2:275
msgid ""
"POSIX.1-2001 says: \"The only portable use of B<mknod>()  is to create a "
"FIFO-special file.  If I<mode> is not B<S_IFIFO> or I<dev> is not 0, the "
"behavior of B<mknod>()  is unspecified.\" However, nowadays one should never"
" use B<mknod>()  for this purpose; one should use B<mkfifo>(3), a function "
"especially defined for this purpose."
msgstr ""

#.  and one should make UNIX domain sockets with socket(2) and bind(2).
#. type: Plain text
#: man-pages/man2/mknod.2:282
msgid ""
"Under Linux, B<mknod>()  cannot be used to create directories.  One should "
"make directories with B<mkdir>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/mknod.2:288
msgid ""
"There are many infelicities in the protocol underlying NFS.  Some of these "
"affect B<mknod>()  and B<mknodat>()."
msgstr ""

#. type: Plain text
#: man-pages/man2/mknod.2:302
msgid ""
"B<mknod>(1), B<chmod>(2), B<chown>(2), B<fcntl>(2), B<mkdir>(2), "
"B<mount>(2), B<socket>(2), B<stat>(2), B<umask>(2), B<unlink>(2), "
"B<makedev>(3), B<mkfifo>(3), B<acl>(5)  B<path_resolution>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/madvise.2:35
#, no-wrap
msgid "MADVISE"
msgstr ""

#. type: Plain text
#: man-pages/man2/madvise.2:38
msgid "madvise - give advice about use of memory"
msgstr ""

#. type: Plain text
#: man-pages/man2/madvise.2:40
msgid "B<#include E<lt>sys/mman.hE<gt>>"
msgstr ""

#. type: Plain text
#: man-pages/man2/madvise.2:42
msgid ""
"B<int madvise(void *>I<addr>B<, size_t >I<length>B<, int >I<advice>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/madvise.2:49
msgid "B<madvise>():"
msgstr ""

#. type: TP
#: man-pages/man2/madvise.2:51
#, no-wrap
msgid "Since glibc 2.19:"
msgstr ""

#. type: Plain text
#: man-pages/man2/madvise.2:54
msgid "_DEFAULT_SOURCE"
msgstr ""

#. type: TP
#: man-pages/man2/madvise.2:54
#, no-wrap
msgid "Up to and including glibc 2.19:"
msgstr ""

#. type: Plain text
#: man-pages/man2/madvise.2:57
msgid "_BSD_SOURCE"
msgstr ""

#. type: Plain text
#: man-pages/man2/madvise.2:70
msgid ""
"The B<madvise>()  system call is used to give advice or directions to the "
"kernel about the address range beginning at address I<addr> and with size "
"I<length> bytes In most cases, the goal of such advice is to improve system "
"or application performance."
msgstr ""

#.  ======================================================================
#. type: Plain text
#: man-pages/man2/madvise.2:83
msgid ""
"Initially, the system call supported a set of \"conventional\" I<advice> "
"values, which are also available on several other implementations.  (Note, "
"though, that B<madvise>()  is not specified in POSIX.)  Subsequently, a "
"number of Linux-specific I<advice> values have been added."
msgstr ""

#. type: SS
#: man-pages/man2/madvise.2:83
#, no-wrap
msgid "Conventional advice values"
msgstr ""

#. type: Plain text
#: man-pages/man2/madvise.2:102
msgid ""
"The I<advice> values listed below allow an application to tell the kernel "
"how it expects to use some mapped or shared memory areas, so that the kernel"
" can choose appropriate read-ahead and caching techniques.  These I<advice> "
"values do not influence the semantics of the application (except in the case"
" of B<MADV_DONTNEED>), but may influence its performance.  All of the "
"I<advice> values listed here have analogs in the POSIX-specified "
"B<posix_madvise>(3)  function, and the values have the same meanings, with "
"the exception of B<MADV_DONTNEED>."
msgstr ""

#. type: Plain text
#: man-pages/man2/madvise.2:106
msgid ""
"The advice is indicated in the I<advice> argument, which is one of the "
"following:"
msgstr ""

#. type: TP
#: man-pages/man2/madvise.2:106
#, no-wrap
msgid "B<MADV_NORMAL>"
msgstr ""

#. type: Plain text
#: man-pages/man2/madvise.2:110
msgid "No special treatment.  This is the default."
msgstr ""

#. type: TP
#: man-pages/man2/madvise.2:110
#, no-wrap
msgid "B<MADV_RANDOM>"
msgstr ""

#. type: Plain text
#: man-pages/man2/madvise.2:114
msgid ""
"Expect page references in random order.  (Hence, read ahead may be less "
"useful than normally.)"
msgstr ""

#. type: TP
#: man-pages/man2/madvise.2:114
#, no-wrap
msgid "B<MADV_SEQUENTIAL>"
msgstr ""

#. type: Plain text
#: man-pages/man2/madvise.2:119
msgid ""
"Expect page references in sequential order.  (Hence, pages in the given "
"range can be aggressively read ahead, and may be freed soon after they are "
"accessed.)"
msgstr ""

#. type: TP
#: man-pages/man2/madvise.2:119
#, no-wrap
msgid "B<MADV_WILLNEED>"
msgstr ""

#. type: Plain text
#: man-pages/man2/madvise.2:123
msgid ""
"Expect access in the near future.  (Hence, it might be a good idea to read "
"some pages ahead.)"
msgstr ""

#. type: TP
#: man-pages/man2/madvise.2:123
#, no-wrap
msgid "B<MADV_DONTNEED>"
msgstr ""

#. type: Plain text
#: man-pages/man2/madvise.2:128
msgid ""
"Do not expect access in the near future.  (For the time being, the "
"application is finished with the given range, so the kernel can free "
"resources associated with it.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/madvise.2:139
msgid ""
"After a successful B<MADV_DONTNEED> operation, the semantics of memory "
"access in the specified region are changed: subsequent accesses of pages in "
"the range will succeed, but will result in either repopulating the memory "
"contents from the up-to-date contents of the underlying mapped file (for "
"shared file mappings, shared anonymous mappings, and shmem-based techniques "
"such as System V shared memory segments)  or zero-fill-on-demand pages for "
"anonymous private mappings."
msgstr ""

#. type: Plain text
#: man-pages/man2/madvise.2:146
msgid ""
"Note that, when applied to shared mappings, B<MADV_DONTNEED> might not lead "
"to immediate freeing of the pages in the range.  The kernel is free to delay"
" freeing the pages until an appropriate moment.  The resident set size (RSS)"
" of the calling process will be immediately reduced however."
msgstr ""

#.  http://lwn.net/Articles/162860/
#.  ======================================================================
#. type: Plain text
#: man-pages/man2/madvise.2:161
msgid ""
"B<MADV_DONTNEED> cannot be applied to locked pages, Huge TLB pages, or "
"B<VM_PFNMAP> pages.  (Pages marked with the kernel-internal B<VM_PFNMAP> "
"flag are special memory areas that are not managed by the virtual memory "
"subsystem.  Such pages are typically created by device drivers that map the "
"pages into user space.)"
msgstr ""

#. type: SS
#: man-pages/man2/madvise.2:161
#, no-wrap
msgid "Linux-specific advice values"
msgstr ""

#. type: Plain text
#: man-pages/man2/madvise.2:170
msgid ""
"The following Linux-specific I<advice> values have no counterparts in the "
"POSIX-specified B<posix_madvise>(3), and may or may not have counterparts in"
" the B<madvise>()  interface available on other implementations.  Note that "
"some of these operations change the semantics of memory accesses."
msgstr ""

#. type: TP
#: man-pages/man2/madvise.2:170
#, no-wrap
msgid "B<MADV_REMOVE> (since Linux 2.6.16)"
msgstr ""

#.  commit f6b3ec238d12c8cc6cc71490c6e3127988460349
#.  Databases want to use this feature to drop a section of their
#.  bufferpool (shared memory segments) - without writing back to
#.  disk/swap space.  This feature is also useful for supporting
#.  hot-plug memory on UML.
#. type: Plain text
#: man-pages/man2/madvise.2:184
msgid ""
"Free up a given range of pages and its associated backing store.  This is "
"equivalent to punching a hole in the corresponding byte range of the backing"
" store (see B<fallocate>(2)).  Subsequent accesses in the specified address "
"range will see bytes containing zero."
msgstr ""

#. type: Plain text
#: man-pages/man2/madvise.2:189
msgid ""
"The specified address range must be mapped shared and writable.  This flag "
"cannot be applied to locked pages, Huge TLB pages, or B<VM_PFNMAP> pages."
msgstr ""

#.  commit 3f31d07571eeea18a7d34db9af21d2285b807a17
#. type: Plain text
#: man-pages/man2/madvise.2:205
msgid ""
"In the initial implementation, only B<tmpfs>(5)  was supported "
"B<MADV_REMOVE>; but since Linux 3.5, any filesystem which supports the "
"B<fallocate>(2)  B<FALLOC_FL_PUNCH_HOLE> mode also supports B<MADV_REMOVE>."
"  Hugetlbfs fails with the error B<EINVAL> and other filesystems fail with "
"the error B<EOPNOTSUPP>."
msgstr ""

#. type: TP
#: man-pages/man2/madvise.2:205
#, no-wrap
msgid "B<MADV_DONTFORK> (since Linux 2.6.16)"
msgstr ""

#.  commit f822566165dd46ff5de9bf895cfa6c51f53bb0c4
#.  See http://lwn.net/Articles/171941/
#.  [PATCH] madvise MADV_DONTFORK/MADV_DOFORK
#.  Currently, copy-on-write may change the physical address of
#.  a page even if the user requested that the page is pinned in
#.  memory (either by mlock or by get_user_pages).  This happens
#.  if the process forks meanwhile, and the parent writes to that
#.  page.  As a result, the page is orphaned: in case of
#.  get_user_pages, the application will never see any data hardware
#.  DMA's into this page after the COW.  In case of mlock'd memory,
#.  the parent is not getting the realtime/security benefits of mlock.
#.  In particular, this affects the Infiniband modules which do DMA from
#.  and into user pages all the time.
#.  This patch adds madvise options to control whether memory range is
#.  inherited across fork. Useful e.g. for when hardware is doing DMA
#.  from/into these pages.  Could also be useful to an application
#.  wanting to speed up its forks by cutting large areas out of
#.  consideration.
#.  SEE ALSO: http://lwn.net/Articles/171941/
#.  "Tweaks to madvise() and posix_fadvise()", 14 Feb 2006
#. type: Plain text
#: man-pages/man2/madvise.2:237
msgid ""
"Do not make the pages in this range available to the child after a "
"B<fork>(2).  This is useful to prevent copy-on-write semantics from changing"
" the physical location of a page if the parent writes to it after a "
"B<fork>(2).  (Such page relocations cause problems for hardware that DMAs "
"into the page.)"
msgstr ""

#. type: TP
#: man-pages/man2/madvise.2:237
#, no-wrap
msgid "B<MADV_DOFORK> (since Linux 2.6.16)"
msgstr ""

#. type: Plain text
#: man-pages/man2/madvise.2:243
msgid ""
"Undo the effect of B<MADV_DONTFORK>, restoring the default behavior, whereby"
" a mapping is inherited across B<fork>(2)."
msgstr ""

#. type: TP
#: man-pages/man2/madvise.2:243
#, no-wrap
msgid "B<MADV_HWPOISON> (since Linux 2.6.32)"
msgstr ""

#.  commit 9893e49d64a4874ea67849ee2cfbf3f3d6817573
#. type: Plain text
#: man-pages/man2/madvise.2:258
msgid ""
"Poison the pages in the range specified by I<addr> and I<length> and handle "
"subsequent references to those pages like a hardware memory corruption.  "
"This operation is available only for privileged (B<CAP_SYS_ADMIN>)  "
"processes.  This operation may result in the calling process receiving a "
"B<SIGBUS> and the page being unmapped."
msgstr ""

#. type: Plain text
#: man-pages/man2/madvise.2:262 man-pages/man2/madvise.2:319
msgid ""
"This feature is intended for testing of memory error-handling code; it is "
"available only if the kernel was configured with B<CONFIG_MEMORY_FAILURE>."
msgstr ""

#. type: TP
#: man-pages/man2/madvise.2:262
#, no-wrap
msgid "B<MADV_MERGEABLE> (since Linux 2.6.32)"
msgstr ""

#.  commit f8af4da3b4c14e7267c4ffb952079af3912c51c5
#. type: Plain text
#: man-pages/man2/madvise.2:276
msgid ""
"Enable Kernel Samepage Merging (KSM) for the pages in the range specified by"
" I<addr> and I<length>.  The kernel regularly scans those areas of user "
"memory that have been marked as mergeable, looking for pages with identical "
"content.  These are replaced by a single write-protected page (which is "
"automatically copied if a process later wants to update the content of the "
"page).  KSM merges only private anonymous pages (see B<mmap>(2))."
msgstr ""

#. type: Plain text
#: man-pages/man2/madvise.2:283
msgid ""
"The KSM feature is intended for applications that generate many instances of"
" the same data (e.g., virtualization systems such as KVM).  It can consume a"
" lot of processing power; use with care.  See the Linux kernel source file "
"I<Documentation/admin-guide/mm/ksm.rst> for more details."
msgstr ""

#. type: Plain text
#: man-pages/man2/madvise.2:290
msgid ""
"The B<MADV_MERGEABLE> and B<MADV_UNMERGEABLE> operations are available only "
"if the kernel was configured with B<CONFIG_KSM>."
msgstr ""

#. type: TP
#: man-pages/man2/madvise.2:290
#, no-wrap
msgid "B<MADV_UNMERGEABLE> (since Linux 2.6.32)"
msgstr ""

#. type: Plain text
#: man-pages/man2/madvise.2:299
msgid ""
"Undo the effect of an earlier B<MADV_MERGEABLE> operation on the specified "
"address range; KSM unmerges whatever pages it had merged in the address "
"range specified by I<addr> and I<length>."
msgstr ""

#. type: TP
#: man-pages/man2/madvise.2:299
#, no-wrap
msgid "B<MADV_SOFT_OFFLINE> (since Linux 2.6.33)"
msgstr ""

#.  commit afcf938ee0aac4ef95b1a23bac704c6fbeb26de6
#. type: Plain text
#: man-pages/man2/madvise.2:315
msgid ""
"Soft offline the pages in the range specified by I<addr> and I<length>.  The"
" memory of each page in the specified range is preserved (i.e., when next "
"accessed, the same content will be visible, but in a new physical page "
"frame), and the original page is offlined (i.e., no longer used, and taken "
"out of normal memory management).  The effect of the B<MADV_SOFT_OFFLINE> "
"operation is invisible to (i.e., does not change the semantics of)  the "
"calling process."
msgstr ""

#. type: TP
#: man-pages/man2/madvise.2:319
#, no-wrap
msgid "B<MADV_HUGEPAGE> (since Linux 2.6.38)"
msgstr ""

#.  commit 0af4e98b6b095c74588af04872f83d333c958c32
#.  http://lwn.net/Articles/358904/
#.  https://lwn.net/Articles/423584/
#. type: Plain text
#: man-pages/man2/madvise.2:335
msgid ""
"Enable Transparent Huge Pages (THP) for pages in the range specified by "
"I<addr> and I<length>.  Currently, Transparent Huge Pages work only with "
"private anonymous pages (see B<mmap>(2)).  The kernel will regularly scan "
"the areas marked as huge page candidates to replace them with huge pages.  "
"The kernel will also allocate huge pages directly when the region is "
"naturally aligned to the huge page size (see B<posix_memalign>(2))."
msgstr ""

#. type: Plain text
#: man-pages/man2/madvise.2:344
msgid ""
"This feature is primarily aimed at applications that use large mappings of "
"data and access large regions of that memory at a time (e.g., virtualization"
" systems such as QEMU).  It can very easily waste memory (e.g., a 2\\ MB "
"mapping that only ever accesses 1 byte will result in 2\\ MB of wired memory"
" instead of one 4\\ KB page).  See the Linux kernel source file "
"I<Documentation/admin-guide/mm/transhuge.rst> for more details."
msgstr ""

#. type: Plain text
#: man-pages/man2/madvise.2:351
msgid ""
"The B<MADV_HUGEPAGE> and B<MADV_NOHUGEPAGE> operations are available only if"
" the kernel was configured with B<CONFIG_TRANSPARENT_HUGEPAGE>."
msgstr ""

#. type: TP
#: man-pages/man2/madvise.2:351
#, no-wrap
msgid "B<MADV_NOHUGEPAGE> (since Linux 2.6.38)"
msgstr ""

#. type: Plain text
#: man-pages/man2/madvise.2:358
msgid ""
"Ensures that memory in the address range specified by I<addr> and I<length> "
"will not be collapsed into huge pages."
msgstr ""

#. type: TP
#: man-pages/man2/madvise.2:358
#, no-wrap
msgid "B<MADV_DONTDUMP> (since Linux 3.4)"
msgstr ""

#.  commit 909af768e88867016f427264ae39d27a57b6a8ed
#.  commit accb61fe7bb0f5c2a4102239e4981650f9048519
#. type: Plain text
#: man-pages/man2/madvise.2:374
msgid ""
"Exclude from a core dump those pages in the range specified by I<addr> and "
"I<length>.  This is useful in applications that have large areas of memory "
"that are known not to be useful in a core dump.  The effect of "
"B<MADV_DONTDUMP> takes precedence over the bit mask that is set via the "
"I</proc/[pid]/coredump_filter> file (see B<core>(5))."
msgstr ""

#. type: TP
#: man-pages/man2/madvise.2:374
#, no-wrap
msgid "B<MADV_DODUMP> (since Linux 3.4)"
msgstr ""

#. type: Plain text
#: man-pages/man2/madvise.2:378
msgid "Undo the effect of an earlier B<MADV_DONTDUMP>."
msgstr ""

#. type: TP
#: man-pages/man2/madvise.2:378
#, no-wrap
msgid "B<MADV_FREE> (since Linux 4.5)"
msgstr ""

#. type: Plain text
#: man-pages/man2/madvise.2:400
msgid ""
"The application no longer requires the pages in the range specified by "
"I<addr> and I<len>.  The kernel can thus free these pages, but the freeing "
"could be delayed until memory pressure occurs.  For each of the pages that "
"has been marked to be freed but has not yet been freed, the free operation "
"will be canceled if the caller writes into the page.  After a successful "
"B<MADV_FREE> operation, any stale data (i.e., dirty, unwritten pages) will "
"be lost when the kernel frees the pages.  However, subsequent writes to "
"pages in the range will succeed and then kernel cannot free those dirtied "
"pages, so that the caller can always see just written data.  If there is no "
"subsequent write, the kernel can free the pages at any time.  Once pages in "
"the range have been freed, the caller will see zero-fill-on-demand pages "
"upon subsequent page references."
msgstr ""

#.  commit 93e06c7a645343d222c9a838834a51042eebbbf7
#. type: Plain text
#: man-pages/man2/madvise.2:411
msgid ""
"The B<MADV_FREE> operation can be applied only to private anonymous pages "
"(see B<mmap>(2)).  In Linux before version 4.12, when freeing pages on a "
"swapless system, the pages in the given range are freed instantly, "
"regardless of memory pressure."
msgstr ""

#. type: TP
#: man-pages/man2/madvise.2:411
#, no-wrap
msgid "B<MADV_WIPEONFORK> (since Linux 4.14)"
msgstr ""

#.  commit d2cd9ede6e193dd7d88b6d27399e96229a551b19
#. type: Plain text
#: man-pages/man2/madvise.2:420
msgid ""
"Present the child process with zero-filled memory in this range after a "
"B<fork>(2).  This is useful in forking servers in order to ensure that "
"sensitive per-process data (for example, PRNG seeds, cryptographic secrets, "
"and so on)  is not handed to child processes."
msgstr ""

#. type: Plain text
#: man-pages/man2/madvise.2:425
msgid ""
"The B<MADV_WIPEONFORK> operation can be applied only to private anonymous "
"pages (see B<mmap>(2))."
msgstr ""

#. type: Plain text
#: man-pages/man2/madvise.2:433
msgid ""
"Within the child created by B<fork>(2), the B<MADV_WIPEONFORK> setting "
"remains in place on the specified address range.  This setting is cleared "
"during B<execve>(2)."
msgstr ""

#. type: TP
#: man-pages/man2/madvise.2:433
#, no-wrap
msgid "B<MADV_KEEPONFORK> (since Linux 4.14)"
msgstr ""

#.  commit d2cd9ede6e193dd7d88b6d27399e96229a551b19
#. type: Plain text
#: man-pages/man2/madvise.2:438
msgid "Undo the effect of an earlier B<MADV_WIPEONFORK>."
msgstr ""

#. type: Plain text
#: man-pages/man2/madvise.2:445
msgid ""
"On success, B<madvise>()  returns zero.  On error, it returns -1 and "
"I<errno> is set appropriately."
msgstr ""

#. type: Plain text
#: man-pages/man2/madvise.2:452
msgid ""
"I<advice> is B<MADV_REMOVE>, but the specified address range is not a shared"
" writable mapping."
msgstr ""

#. type: Plain text
#: man-pages/man2/madvise.2:455
msgid "A kernel resource was temporarily unavailable."
msgstr ""

#. type: Plain text
#: man-pages/man2/madvise.2:458
msgid "The map exists, but the area maps something that isn't a file."
msgstr ""

#.  .I length
#.  is zero,
#. type: Plain text
#: man-pages/man2/madvise.2:466
msgid "I<addr> is not page-aligned or I<length> is negative."
msgstr ""

#. type: Plain text
#: man-pages/man2/madvise.2:470
msgid "I<advice> is not a valid."
msgstr ""

#. type: Plain text
#: man-pages/man2/madvise.2:480
msgid ""
"I<advice> is B<MADV_DONTNEED> or B<MADV_REMOVE> and the specified address "
"range includes locked, Huge TLB pages, or B<VM_PFNMAP> pages."
msgstr ""

#. type: Plain text
#: man-pages/man2/madvise.2:489
msgid ""
"I<advice> is B<MADV_MERGEABLE> or B<MADV_UNMERGEABLE>, but the kernel was "
"not configured with B<CONFIG_KSM>."
msgstr ""

#. type: Plain text
#: man-pages/man2/madvise.2:501
msgid ""
"I<advice> is B<MADV_FREE> or B<MADV_WIPEONFORK> but the specified address "
"range includes file, Huge TLB, B<MAP_SHARED>, or B<VM_PFNMAP> ranges."
msgstr ""

#. type: TP
#: man-pages/man2/madvise.2:501
#, no-wrap
msgid "B<EIO>"
msgstr ""

#. type: Plain text
#: man-pages/man2/madvise.2:507
msgid ""
"(for B<MADV_WILLNEED>)  Paging in this area would exceed the process's "
"maximum resident set size."
msgstr ""

#. type: Plain text
#: man-pages/man2/madvise.2:512
msgid "(for B<MADV_WILLNEED>)  Not enough memory: paging in failed."
msgstr ""

#. type: Plain text
#: man-pages/man2/madvise.2:516
msgid ""
"Addresses in the specified range are not currently mapped, or are outside "
"the address space of the process."
msgstr ""

#. type: Plain text
#: man-pages/man2/madvise.2:524
msgid ""
"I<advice> is B<MADV_HWPOISON>, but the caller does not have the "
"B<CAP_SYS_ADMIN> capability."
msgstr ""

#.  commit d3ac21cacc24790eb45d735769f35753f5b56ceb
#. type: Plain text
#: man-pages/man2/madvise.2:531
msgid ""
"Since Linux 3.18, support for this system call is optional, depending on the"
" setting of the B<CONFIG_ADVISE_SYSCALLS> configuration option."
msgstr ""

#. type: Plain text
#: man-pages/man2/madvise.2:541
msgid ""
"B<madvise>()  is not specified by any standards.  Versions of this system "
"call, implementing a wide variety of I<advice> values, exist on many other "
"implementations.  Other implementations typically implement at least the "
"flags listed above under I<Conventional advice flags>, albeit with some "
"variation in semantics."
msgstr ""

#. type: Plain text
#: man-pages/man2/madvise.2:552
msgid ""
"POSIX.1-2001 describes B<posix_madvise>(3)  with constants "
"B<POSIX_MADV_NORMAL>, B<POSIX_MADV_RANDOM>, B<POSIX_MADV_SEQUENTIAL>, "
"B<POSIX_MADV_WILLNEED>, and B<POSIX_MADV_DONTNEED>, and so on, with behavior"
" close to the similarly named flags listed above."
msgstr ""

#. type: SS
#: man-pages/man2/madvise.2:553
#, no-wrap
msgid "Linux notes"
msgstr ""

#.  .SH HISTORY
#.  The
#.  .BR madvise ()
#.  function first appeared in 4.4BSD.
#. type: Plain text
#: man-pages/man2/madvise.2:569
msgid ""
"The Linux implementation requires that the address I<addr> be page-aligned, "
"and allows I<length> to be zero.  If there are some parts of the specified "
"address range that are not mapped, the Linux version of B<madvise>()  "
"ignores them and applies the call to the rest (but returns B<ENOMEM> from "
"the system call, as it should)."
msgstr ""

#. type: Plain text
#: man-pages/man2/madvise.2:578
msgid ""
"B<getrlimit>(2), B<mincore>(2), B<mmap>(2), B<mprotect>(2), B<msync>(2), "
"B<munmap>(2), B<prctl>(2), B<posix_madvise>(3), B<core>(5)"
msgstr ""

#. type: TH
#: man-pages/man2/msgget.2:35
#, no-wrap
msgid "MSGGET"
msgstr ""

#. type: Plain text
#: man-pages/man2/msgget.2:38
msgid "msgget - get a System V message queue identifier"
msgstr ""

#. type: Plain text
#: man-pages/man2/msgget.2:45
#, no-wrap
msgid "B<int msgget(key_t >I<key>B<, int >I<msgflg>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/msgget.2:61
msgid ""
"The B<msgget>()  system call returns the System\\ V message queue identifier"
" associated with the value of the I<key> argument.  It may be used either to"
" obtain the identifier of a previously created message queue (when I<msgflg>"
" is zero and I<key> does not have the value B<IPC_PRIVATE>), or to create a "
"new set."
msgstr ""

#. type: Plain text
#: man-pages/man2/msgget.2:76
msgid ""
"A new message queue is created if I<key> has the value B<IPC_PRIVATE> or "
"I<key> isn't B<IPC_PRIVATE>, no message queue with the given key I<key> "
"exists, and B<IPC_CREAT> is specified in I<msgflg>."
msgstr ""

#. type: Plain text
#: man-pages/man2/msgget.2:95
msgid ""
"If I<msgflg> specifies both B<IPC_CREAT> and B<IPC_EXCL> and a message queue"
" already exists for I<key>, then B<msgget>()  fails with I<errno> set to "
"B<EEXIST>.  (This is analogous to the effect of the combination B<O_CREAT | "
"O_EXCL> for B<open>(2).)"
msgstr ""

#. type: Plain text
#: man-pages/man2/msgget.2:105
msgid ""
"Upon creation, the least significant bits of the argument I<msgflg> define "
"the permissions of the message queue.  These permission bits have the same "
"format and semantics as the permissions specified for the I<mode> argument "
"of B<open>(2).  (The execute permissions are not used.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/msgget.2:112
msgid ""
"If a new message queue is created, then its associated data structure "
"I<msqid_ds> (see B<msgctl>(2))  is initialized as follows:"
msgstr ""

#. type: Plain text
#: man-pages/man2/msgget.2:117
msgid ""
"I<msg_perm.cuid> and I<msg_perm.uid> are set to the effective user ID of the"
" calling process."
msgstr ""

#. type: Plain text
#: man-pages/man2/msgget.2:122
msgid ""
"I<msg_perm.cgid> and I<msg_perm.gid> are set to the effective group ID of "
"the calling process."
msgstr ""

#. type: Plain text
#: man-pages/man2/msgget.2:127
msgid ""
"The least significant 9 bits of I<msg_perm.mode> are set to the least "
"significant 9 bits of I<msgflg>."
msgstr ""

#. type: Plain text
#: man-pages/man2/msgget.2:135
msgid ""
"I<msg_qnum>, I<msg_lspid>, I<msg_lrpid>, I<msg_stime>, and I<msg_rtime> are "
"set to 0."
msgstr ""

#. type: Plain text
#: man-pages/man2/msgget.2:138
msgid "I<msg_ctime> is set to the current time."
msgstr ""

#. type: Plain text
#: man-pages/man2/msgget.2:142
msgid "I<msg_qbytes> is set to the system limit B<MSGMNB>."
msgstr ""

#. type: Plain text
#: man-pages/man2/msgget.2:146
msgid ""
"If the message queue already exists the permissions are verified, and a "
"check is made to see if it is marked for destruction."
msgstr ""

#. type: Plain text
#: man-pages/man2/msgget.2:152
msgid ""
"If successful, the return value will be the message queue identifier (a "
"nonnegative integer), otherwise -1 with I<errno> indicating the error."
msgstr ""

#. type: Plain text
#: man-pages/man2/msgget.2:156
msgid "On failure, I<errno> is set to one of the following values:"
msgstr ""

#. type: Plain text
#: man-pages/man2/msgget.2:164
msgid ""
"A message queue exists for I<key>, but the calling process does not have "
"permission to access the queue, and does not have the B<CAP_IPC_OWNER> "
"capability in the user namespace that governs its IPC namespace."
msgstr ""

#. type: Plain text
#: man-pages/man2/msgget.2:173
msgid ""
"B<IPC_CREAT> and B<IPC_EXCL> were specified in I<msgflg>, but a message "
"queue already exists for I<key>."
msgstr ""

#. type: Plain text
#: man-pages/man2/msgget.2:181
msgid ""
"No message queue exists for I<key> and I<msgflg> did not specify "
"B<IPC_CREAT>."
msgstr ""

#. type: Plain text
#: man-pages/man2/msgget.2:185
msgid ""
"A message queue has to be created but the system does not have enough memory"
" for the new data structure."
msgstr ""

#. type: Plain text
#: man-pages/man2/msgget.2:191
msgid ""
"A message queue has to be created but the system limit for the maximum "
"number of message queues (B<MSGMNI>)  would be exceeded."
msgstr ""

#. type: Plain text
#: man-pages/man2/msgget.2:216
msgid ""
"B<IPC_PRIVATE> isn't a flag field but a I<key_t> type.  If this special "
"value is used for I<key>, the system call ignores everything but the least "
"significant 9 bits of I<msgflg> and creates a new message queue (on "
"success)."
msgstr ""

#. type: Plain text
#: man-pages/man2/msgget.2:220
msgid ""
"The following is a system limit on message queue resources affecting a "
"B<msgget>()  call:"
msgstr ""

#. type: TP
#: man-pages/man2/msgget.2:220
#, no-wrap
msgid "B<MSGMNI>"
msgstr ""

#.  commit 0050ee059f7fc86b1df2527aaa14ed5dc72f9973
#. type: Plain text
#: man-pages/man2/msgget.2:230
msgid ""
"System-wide limit on the number of message queues.  Before Linux 3.19, the "
"default value for this limit was calculated using a formula based on "
"available system memory.  Since Linux 3.19, the default value is 32,000.  On"
" Linux, this limit can be read and modified via I</proc/sys/kernel/msgmni>."
msgstr ""

#. type: Plain text
#: man-pages/man2/msgget.2:236
msgid ""
"Until version 2.3.20, Linux would return B<EIDRM> for a B<msgget>()  on a "
"message queue scheduled for deletion."
msgstr ""

#. type: Plain text
#: man-pages/man2/msgget.2:242
msgid ""
"The name choice B<IPC_PRIVATE> was perhaps unfortunate, B<IPC_NEW> would "
"more clearly show its function."
msgstr ""

#. type: Plain text
#: man-pages/man2/msgget.2:249
msgid ""
"B<msgctl>(2), B<msgrcv>(2), B<msgsnd>(2), B<ftok>(3), B<capabilities>(7), "
"B<mq_overview>(7), B<sysvipc>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/modify_ldt.2:25
#, no-wrap
msgid "MODIFY_LDT"
msgstr ""

#. type: Plain text
#: man-pages/man2/modify_ldt.2:28
msgid "modify_ldt - get or set a per-process LDT entry"
msgstr ""

#. type: Plain text
#: man-pages/man2/modify_ldt.2:31
#, no-wrap
msgid "B<#include E<lt>sys/types.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/modify_ldt.2:33
#, no-wrap
msgid ""
"B<int modify_ldt(int >I<func>B<, void *>I<ptr>B<, unsigned long "
">I<bytecount>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/modify_ldt.2:37
msgid "I<Note>: There is no glibc wrapper for this system call; see NOTES."
msgstr ""

#. type: Plain text
#: man-pages/man2/modify_ldt.2:45
msgid ""
"B<modify_ldt>()  reads or writes the local descriptor table (LDT) for a "
"process.  The LDT is an array of segment descriptors that can be referenced "
"by user code.  Linux allows processes to configure a per-process (actually "
"per-mm) LDT.  For more information about the LDT, see the Intel Software "
"Developer's Manual or the AMD Architecture Programming Manual."
msgstr ""

#. type: Plain text
#: man-pages/man2/modify_ldt.2:59
msgid ""
"When I<func> is 0, B<modify_ldt>()  reads the LDT into the memory pointed to"
" by I<ptr>.  The number of bytes read is the smaller of I<bytecount> and the"
" actual size of the LDT, although the kernel may act as though the LDT is "
"padded with additional trailing zero bytes.  On success, B<modify_ldt>()  "
"will return the number of bytes read."
msgstr ""

#. type: Plain text
#: man-pages/man2/modify_ldt.2:73
msgid ""
"When I<func> is 1 or 0x11, B<modify_ldt>()  modifies the LDT entry indicated"
" by I<ptr-E<gt>entry_number>.  I<ptr> points to a I<user_desc> structure and"
" I<bytecount> must equal the size of this structure."
msgstr ""

#. type: Plain text
#: man-pages/man2/modify_ldt.2:77
msgid "The I<user_desc> structure is defined in I<E<lt>asm/ldt.hE<gt>> as:"
msgstr ""

#. type: Plain text
#: man-pages/man2/modify_ldt.2:91
#, no-wrap
msgid ""
"struct user_desc {\n"
"    unsigned int  entry_number;\n"
"    unsigned long base_addr;\n"
"    unsigned int  limit;\n"
"    unsigned int  seg_32bit:1;\n"
"    unsigned int  contents:2;\n"
"    unsigned int  read_exec_only:1;\n"
"    unsigned int  limit_in_pages:1;\n"
"    unsigned int  seg_not_present:1;\n"
"    unsigned int  useable:1;\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/modify_ldt.2:96
msgid ""
"In Linux 2.4 and earlier, this structure was named I<modify_ldt_ldt_s>."
msgstr ""

#. type: Plain text
#: man-pages/man2/modify_ldt.2:104
msgid ""
"The I<contents> field is the segment type (data, expand-down data, non-"
"conforming code, or conforming code).  The other fields match their "
"descriptions in the CPU manual, although B<modify_ldt>()  cannot set the "
"hardware-defined \"accessed\" bit described in the CPU manual."
msgstr ""

#. type: Plain text
#: man-pages/man2/modify_ldt.2:121
msgid ""
"A I<user_desc> is considered \"empty\" if I<read_exec_only> and "
"I<seg_not_present> are set to 1 and all of the other fields are 0.  An LDT "
"entry can be cleared by setting it to an \"empty\" I<user_desc> or, if "
"I<func> is 1, by setting both I<base> and I<limit> to 0."
msgstr ""

#. type: Plain text
#: man-pages/man2/modify_ldt.2:130
msgid ""
"A conforming code segment (i.e., one with I<contents==3>)  will be rejected "
"if I<func> is 1 or if I<seg_not_present> is 0."
msgstr ""

#. type: Plain text
#: man-pages/man2/modify_ldt.2:137
msgid ""
"When I<func> is 2, B<modify_ldt>()  will read zeros.  This appears to be a "
"leftover from Linux 2.4."
msgstr ""

#. type: Plain text
#: man-pages/man2/modify_ldt.2:147
msgid ""
"On success, B<modify_ldt>()  returns either the actual number of bytes read "
"(for reading)  or 0 (for writing).  On failure, B<modify_ldt>()  returns -1 "
"and sets I<errno> to indicate the error."
msgstr ""

#. type: Plain text
#: man-pages/man2/modify_ldt.2:152
msgid "I<ptr> points outside the address space."
msgstr ""

#. type: Plain text
#: man-pages/man2/modify_ldt.2:165
msgid ""
"I<ptr> is 0, or I<func> is 1 and I<bytecount> is not equal to the size of "
"the structure I<user_desc>, or I<func> is 1 or 0x11 and the new LDT entry "
"has invalid values."
msgstr ""

#. type: TP
#: man-pages/man2/modify_ldt.2:165
#, no-wrap
msgid "B<ENOSYS>"
msgstr ""

#. type: Plain text
#: man-pages/man2/modify_ldt.2:169
msgid "I<func> is neither 0, 1, 2, nor 0x11."
msgstr ""

#. type: Plain text
#: man-pages/man2/modify_ldt.2:172
msgid ""
"This call is Linux-specific and should not be used in programs intended to "
"be portable."
msgstr ""

#. type: Plain text
#: man-pages/man2/modify_ldt.2:175
msgid ""
"Glibc does not provide a wrapper for this system call; call it using "
"B<syscall>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/modify_ldt.2:185
msgid ""
"B<modify_ldt>()  should not be used for thread-local storage, as it slows "
"down context switches and only supports a limited number of threads.  "
"Threading libraries should use B<set_thread_area>(2)  or B<arch_prctl>(2)  "
"instead, except on extremely old kernels that do not support those system "
"calls."
msgstr ""

#. type: Plain text
#: man-pages/man2/modify_ldt.2:190
msgid ""
"The normal use for B<modify_ldt>()  is to run legacy 16-bit or segmented "
"32-bit code.  Not all kernels allow 16-bit segments to be installed, "
"however."
msgstr ""

#. type: Plain text
#: man-pages/man2/modify_ldt.2:198
msgid ""
"Even on 64-bit kernels, B<modify_ldt>()  cannot be used to create a long "
"mode (i.e., 64-bit) code segment.  The undocumented field \"lm\" in "
"I<user_desc> is not useful, and, despite its name, does not result in a long"
" mode segment."
msgstr ""

#.  commit e30ab185c490e9a9381385529e0fd32f0a399495
#. type: Plain text
#: man-pages/man2/modify_ldt.2:207
msgid ""
"On 64-bit kernels before Linux 3.19, setting the \"lm\" bit in I<user_desc> "
"prevents the descriptor from being considered empty.  Keep in mind that the "
"\"lm\" bit does not exist in the 32-bit headers, but these buggy kernels "
"will still notice the bit even when set in a 32-bit process."
msgstr ""

#. type: Plain text
#: man-pages/man2/modify_ldt.2:210
msgid "B<arch_prctl>(2), B<set_thread_area>(2), B<vm86>(2)"
msgstr ""

#. type: TH
#: man-pages/man2/mount.2:40
#, no-wrap
msgid "MOUNT"
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:43
msgid "mount - mount filesystem"
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:46
#, no-wrap
msgid "B<#include E<lt>sys/mount.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:50
#, no-wrap
msgid ""
"B<int mount(const char *>I<source>B<, const char *>I<target>B<,>\n"
"B<          const char *>I<filesystemtype>B<, unsigned long >I<mountflags>B<,>\n"
"B<          const void *>I<data>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:60
msgid ""
"B<mount>()  attaches the filesystem specified by I<source> (which is often a"
" pathname referring to a device, but can also be the pathname of a directory"
" or file, or a dummy string) to the location (a directory or file)  "
"specified by the pathname in I<target>."
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:64
msgid ""
"Appropriate privilege (Linux: the B<CAP_SYS_ADMIN> capability) is required "
"to mount filesystems."
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:73
msgid ""
"Values for the I<filesystemtype> argument supported by the kernel are listed"
" in I</proc/filesystems> (e.g., \"btrfs\", \"ext4\", \"jfs\", \"xfs\", "
"\"vfat\", \"fuse\", \"tmpfs\", \"cgroup\", \"proc\", \"mqueue\", \"nfs\", "
"\"cifs\", \"iso9660\").  Further types may become available when the "
"appropriate modules are loaded."
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:82
msgid ""
"The I<data> argument is interpreted by the different filesystems.  Typically"
" it is a string of comma-separated options understood by this filesystem.  "
"See B<mount>(8)  for details of the options available for each filesystem "
"type."
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:92
msgid ""
"A call to B<mount>()  performs one of a number of general types of "
"operation, depending on the bits specified in I<mountflags>.  The choice of "
"which operation to perform is determined by testing the bits set in "
"I<mountflags>, with the tests being conducted in the order listed here:"
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:97
msgid "Remount an existing mount: I<mountflags> includes B<MS_REMOUNT>."
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:102
msgid "Create a bind mount: I<mountflags> includes B<MS_BIND>."
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:111
msgid ""
"Change the propagation type of an existing mount: I<mountflags> includes one"
" of B<MS_SHARED>, B<MS_PRIVATE>, B<MS_SLAVE>, or B<MS_UNBINDABLE>."
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:116
msgid ""
"Move an existing mount to a new location: I<mountflags> includes B<MS_MOVE>."
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:120
msgid "Create a new mount: I<mountflags> includes none of the above flags."
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:128
msgid ""
"Each of these operations is detailed later in this page.  Further flags may "
"be specified in I<mountflags> to modify the behavior of B<mount>(), as "
"described below."
msgstr ""

#. type: SS
#: man-pages/man2/mount.2:128
#, no-wrap
msgid "Additional mount flags"
msgstr ""

#.  FIXME 2.6.25 Added MS_I_VERSION, which needs to be documented.
#.  commit 7a224228ed79d587ece2304869000aad1b8e97dd
#.  (This is a per-superblock flag)
#. type: Plain text
#: man-pages/man2/mount.2:138
msgid ""
"The list below describes the additional flags that can be specified in "
"I<mountflags>.  Note that some operation types ignore some or all of these "
"flags, as described later in this page."
msgstr ""

#. type: TP
#: man-pages/man2/mount.2:138
#, no-wrap
msgid "B<MS_DIRSYNC> (since Linux 2.5.19)"
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:144
msgid ""
"Make directory changes on this filesystem synchronous.  (This property can "
"be obtained for individual directories or subtrees using B<chattr>(1).)"
msgstr ""

#. type: TP
#: man-pages/man2/mount.2:144
#, no-wrap
msgid "B<MS_LAZYTIME> (since Linux 4.0)"
msgstr ""

#.  commit 0ae45f63d4ef8d8eeec49c7d8b44a1775fff13e8
#.  commit fe032c422c5ba562ba9c2d316f55e258e03259c6
#.  commit a26f49926da938f47561f386be56a83dd37a496d
#. type: Plain text
#: man-pages/man2/mount.2:152
msgid ""
"Reduce on-disk updates of inode timestamps (atime, mtime, ctime)  by "
"maintaining these changes only in memory.  The on-disk timestamps are "
"updated only when:"
msgstr ""

#. type: IP
#: man-pages/man2/mount.2:153
#, no-wrap
msgid "(a)"
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:155
msgid ""
"the inode needs to be updated for some change unrelated to file timestamps;"
msgstr ""

#. type: IP
#: man-pages/man2/mount.2:155
#, no-wrap
msgid "(b)"
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:161
msgid "the application employs B<fsync>(2), B<syncfs>(2), or B<sync>(2);"
msgstr ""

#. type: IP
#: man-pages/man2/mount.2:161
#, no-wrap
msgid "(c)"
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:163
msgid "an undeleted inode is evicted from memory; or"
msgstr ""

#. type: IP
#: man-pages/man2/mount.2:163
#, no-wrap
msgid "(d)"
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:165
msgid "more than 24 hours have passed since the inode was written to disk."
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:171
msgid ""
"This mount option significantly reduces writes needed to update the inode's "
"timestamps, especially mtime and atime.  However, in the event of a system "
"crash, the atime and mtime fields on disk might be out of date by up to 24 "
"hours."
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:185
msgid ""
"Examples of workloads where this option could be of significant benefit "
"include frequent random writes to preallocated files, as well as cases where"
" the B<MS_STRICTATIME> mount option is also enabled.  (The advantage of "
"combining B<MS_STRICTATIME> and B<MS_LAZYTIME> is that B<stat>(2)  will "
"return the correctly updated atime, but the atime updates will be flushed to"
" disk only in the cases listed above.)"
msgstr ""

#. type: TP
#: man-pages/man2/mount.2:185
#, no-wrap
msgid "B<MS_MANDLOCK>"
msgstr ""

#.  commit 95ace75414f312f9a7b93d873f386987b92a5301
#. type: Plain text
#: man-pages/man2/mount.2:198
msgid ""
"Permit mandatory locking on files in this filesystem.  (Mandatory locking "
"must still be enabled on a per-file basis, as described in B<fcntl>(2).)  "
"Since Linux 4.5, this mount option requires the B<CAP_SYS_ADMIN> capability "
"and a kernel configured with the B<CONFIG_MANDATORY_FILE_LOCKING> option."
msgstr ""

#. type: TP
#: man-pages/man2/mount.2:198
#, no-wrap
msgid "B<MS_NOATIME>"
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:201
msgid ""
"Do not update access times for (all types of) files on this filesystem."
msgstr ""

#. type: TP
#: man-pages/man2/mount.2:201
#, no-wrap
msgid "B<MS_NODEV>"
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:204
msgid "Do not allow access to devices (special files) on this filesystem."
msgstr ""

#. type: TP
#: man-pages/man2/mount.2:204
#, no-wrap
msgid "B<MS_NODIRATIME>"
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:213
msgid ""
"Do not update access times for directories on this filesystem.  This flag "
"provides a subset of the functionality provided by B<MS_NOATIME>; that is, "
"B<MS_NOATIME> implies B<MS_NODIRATIME>."
msgstr ""

#. type: TP
#: man-pages/man2/mount.2:213
#, no-wrap
msgid "B<MS_NOEXEC>"
msgstr ""

#.  (Possibly useful for a filesystem that contains non-Linux executables.
#.  Often used as a security feature, e.g., to make sure that restricted
#.  users cannot execute files uploaded using ftp or so.)
#. type: Plain text
#: man-pages/man2/mount.2:219
msgid "Do not allow programs to be executed from this filesystem."
msgstr ""

#. type: TP
#: man-pages/man2/mount.2:219
#, no-wrap
msgid "B<MS_NOSUID>"
msgstr ""

#.  (This is a security feature to prevent users executing set-user-ID and
#.  set-group-ID programs from removable disk devices.)
#. type: Plain text
#: man-pages/man2/mount.2:225
msgid ""
"Do not honor set-user-ID and set-group-ID bits or file capabilities when "
"executing programs from this filesystem."
msgstr ""

#. type: TP
#: man-pages/man2/mount.2:225
#, no-wrap
msgid "B<MS_RDONLY>"
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:228
msgid "Mount filesystem read-only."
msgstr ""

#. type: TP
#: man-pages/man2/mount.2:228
#, no-wrap
msgid "B<MS_REC> (since Linux 2.4.11)"
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:236
msgid ""
"Used in conjunction with B<MS_BIND> to create a recursive bind mount, and in"
" conjunction with the propagation type flags to recursively change the "
"propagation type of all of the mounts in a subtree.  See below for further "
"details."
msgstr ""

#. type: TP
#: man-pages/man2/mount.2:236
#, no-wrap
msgid "B<MS_RELATIME> (since Linux 2.6.20)"
msgstr ""

#.  Matthew Garrett notes in the patch that added this behavior
#.  that this lets utilities such as tmpreaper (which deletes
#.  files based on last access time) work correctly.
#. type: Plain text
#: man-pages/man2/mount.2:257
msgid ""
"When a file on this filesystem is accessed, update the file's last access "
"time (atime) only if the current value of atime is less than or equal to the"
" file's last modification time (mtime)  or last status change time (ctime)."
"  This option is useful for programs, such as B<mutt>(1), that need to know "
"when a file has been read since it was last modified.  Since Linux 2.6.30, "
"the kernel defaults to the behavior provided by this flag (unless "
"B<MS_NOATIME> was specified), and the B<MS_STRICTATIME> flag is required to "
"obtain traditional semantics.  In addition, since Linux 2.6.30, the file's "
"last access time is always updated if it is more than 1 day old."
msgstr ""

#. type: TP
#: man-pages/man2/mount.2:257
#, no-wrap
msgid "B<MS_SILENT> (since Linux 2.6.17)"
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:265
msgid ""
"Suppress the display of certain (I<printk>())  warning messages in the "
"kernel log.  This flag supersedes the misnamed and obsolete B<MS_VERBOSE> "
"flag (available since Linux 2.4.12), which has the same meaning."
msgstr ""

#. type: TP
#: man-pages/man2/mount.2:265
#, no-wrap
msgid "B<MS_STRICTATIME> (since Linux 2.6.30)"
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:275
msgid ""
"Always update the last access time (atime) when files on this filesystem are"
" accessed.  (This was the default behavior before Linux 2.6.30.)  Specifying"
" this flag overrides the effect of setting the B<MS_NOATIME> and "
"B<MS_RELATIME> flags."
msgstr ""

#. type: TP
#: man-pages/man2/mount.2:275
#, no-wrap
msgid "B<MS_SYNCHRONOUS>"
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:283
msgid ""
"Make writes on this filesystem synchronous (as though the B<O_SYNC> flag to "
"B<open>(2)  was specified for all file opens to this filesystem)."
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:289
msgid ""
"From Linux 2.4 onward, some of the above flags are settable on a per-mount "
"basis, while others apply to the superblock of the mounted filesystem, "
"meaning that all mounts of the same filesystem share those flags.  "
"(Previously, all of the flags were per-superblock.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:291
msgid "The per-mount-point flags are as follows:"
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:295
msgid ""
"Since Linux 2.4: B<MS_NODEV>, B<MS_NOEXEC>, and B<MS_NOSUID> flags are "
"settable on a per-mount-point basis."
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:300
msgid "Since Linux 2.6.16: B<MS_NOATIME> and B<MS_NODIRATIME>."
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:303
msgid "Since Linux 2.6.20: B<MS_RELATIME>."
msgstr ""

#.  And MS_I_VERSION?
#. type: Plain text
#: man-pages/man2/mount.2:319
msgid ""
"The following flags are per-superblock: B<MS_DIRSYNC>, B<MS_LAZYTIME>, "
"B<MS_MANDLOCK>, B<MS_MS_SILENT>, and B<MS_SYNCHRONOUS>.  The initial "
"settings of these flags are determined on the first mount of the filesystem,"
" and will be shared by all subsequent mounts of the same filesystem.  "
"Subsequently, the settings of the flags can be changed via a remount "
"operation (see below).  Such changes will be visible via all mount points "
"associated with the filesystem."
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:327
msgid ""
"Since Linux 2.6.16, B<MS_RDONLY> can be set or cleared on a per-mount-point "
"basis as well as on the underlying filesystem superblock.  The mounted "
"filesystem will be writable only if neither the filesystem nor the "
"mountpoint are flagged as read-only."
msgstr ""

#. type: SS
#: man-pages/man2/mount.2:327
#, no-wrap
msgid "Remounting an existing mount"
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:341
msgid ""
"An existing mount may be remounted by specifying B<MS_REMOUNT> in "
"I<mountflags>.  This allows you to change the I<mountflags> and I<data> of "
"an existing mount without having to unmount and remount the filesystem.  "
"I<target> should be the same value specified in the initial B<mount>()  "
"call."
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:347
msgid "The I<source> and I<filesystemtype> arguments are ignored."
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:355
msgid ""
"The I<mountflags> and I<data> arguments should match the values used in the "
"original B<mount>()  call, except for those parameters that are being "
"deliberately changed."
msgstr ""

#.  FIXME
#.  MS_LAZYTIME seems to be available only on a few filesystems,
#.  and on ext4, it seems (from experiment that this flag
#.  can only be enabled (but not disabled) on a remount.
#.  The following code in ext4_remount() (kernel 4.17) seems to
#.  confirm this:
#.         if (*flags & SB_LAZYTIME)
#.                 sb->s_flags |= SB_LAZYTIME;
#.  See the definition of MS_RMT_MASK in include/uapi/linux/fs.h,
#.  which excludes MS_DIRSYNC and MS_SILENT, although SB_DIRSYNC
#.  and SB_SILENT are split out as per-superblock flags in do_mount()
#.  (Linux 4.17 source code)
#. type: Plain text
#: man-pages/man2/mount.2:397
msgid ""
"The following I<mountflags> can be changed: B<MS_LAZYTIME>, B<MS_MANDLOCK>, "
"B<MS_NOATIME>, B<MS_NODEV>, B<MS_NODIRATIME>, B<MS_NOEXEC>, B<MS_NOSUID>, "
"B<MS_RELATIME>, B<MS_RDONLY>, B<MS_STRICTATIME> (whose effect is to clear "
"the B<MS_NOATIME> and B<MS_RELATIME> flags), and B<MS_SYNCHRONOUS>.  "
"Attempts to change the setting of the B<MS_DIRSYNC> and B<MS_SILENT> flags "
"during a remount are silently ignored.  Note that changes to per-superblock "
"flags are visible via all mount points of the associated filesystem (because"
" the per-superblock flags are shared by all mount points)."
msgstr ""

#.  commit ffbc6f0ead47fa5a1dc9642b0331cb75c20a640e
#. type: Plain text
#: man-pages/man2/mount.2:411
msgid ""
"Since Linux 3.17, if none of B<MS_NOATIME>, B<MS_NODIRATIME>, "
"B<MS_RELATIME>, or B<MS_STRICTATIME> is specified in I<mountflags>, then the"
" remount operation preserves the existing values of these flags (rather than"
" defaulting to B<MS_RELATIME>)."
msgstr ""

#.  See https://lwn.net/Articles/281157/
#. type: Plain text
#: man-pages/man2/mount.2:423
msgid ""
"Since Linux 2.6.26, the B<MS_REMOUNT> flag can be used with B<MS_BIND> to "
"modify only the per-mount-point flags.  This is particularly useful for "
"setting or clearing the \"read-only\" flag on a mount point without changing"
" the underlying filesystem.  Specifying I<mountflags> as:"
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:427
#, no-wrap
msgid "MS_REMOUNT | MS_BIND | MS_RDONLY\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:433
msgid ""
"will make access through this mountpoint read-only, without affecting other "
"mount points."
msgstr ""

#. type: SS
#: man-pages/man2/mount.2:433
#, no-wrap
msgid "Creating a bind mount"
msgstr ""

#.  since 2.4.0-test9
#. type: Plain text
#: man-pages/man2/mount.2:446
msgid ""
"If I<mountflags> includes B<MS_BIND> (available since Linux 2.4), then "
"perform a bind mount.  A bind mount makes a file or a directory subtree "
"visible at another point within the single directory hierarchy.  Bind mounts"
" may cross filesystem boundaries and span B<chroot>(2)  jails."
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:452
msgid "The I<filesystemtype> and I<data> arguments are ignored."
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:462
msgid ""
"The remaining bits (other than B<MS_REC>, described below) in the "
"I<mountflags> argument are also ignored.  (The bind mount has the same mount"
" options as the underlying mount point.)  However, see the discussion of "
"remounting above, for a method of making an existing bind mount read-only."
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:477
msgid ""
"By default, when a directory is bind mounted, only that directory is "
"mounted; if there are any submounts under the directory tree, they are not "
"bind mounted.  If the B<MS_REC> flag is also specified, then a recursive "
"bind mount operation is performed: all submounts under the I<source> subtree"
" (other than unbindable mounts)  are also bind mounted at the corresponding "
"location in the I<target> subtree."
msgstr ""

#. type: SS
#: man-pages/man2/mount.2:477
#, no-wrap
msgid "Changing the propagation type of an existing mount"
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:489
msgid ""
"If I<mountflags> includes one of B<MS_SHARED>, B<MS_PRIVATE>, B<MS_SLAVE>, "
"or B<MS_UNBINDABLE> (all available since Linux 2.6.15), then the propagation"
" type of an existing mount is changed.  If more than one of these flags is "
"specified, an error results."
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:496
msgid ""
"The only other flags that can be specified while changing the propagation "
"type are B<MS_REC> (described below) and B<MS_SILENT> (which is ignored)."
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:503
msgid "The I<source>, I<filesystemtype>, and I<data> arguments are ignored."
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:505
msgid "The meanings of the propagation type flags are as follows:"
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:514
msgid ""
"Make this mount point shared.  Mount and unmount events immediately under "
"this mount point will propagate to the other mount points that are members "
"of this mount's peer group.  Propagation here means that the same mount or "
"unmount will automatically occur under all of the other mount points in the "
"peer group.  Conversely, mount and unmount events that take place under peer"
" mount points will propagate to this mount point."
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:518
msgid ""
"Make this mount point private.  Mount and unmount events do not propagate "
"into or out of this mount point."
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:525
msgid ""
"If this is a shared mount point that is a member of a peer group that "
"contains other members, convert it to a slave mount.  If this is a shared "
"mount point that is a member of a peer group that contains no other members,"
" convert it to a private mount.  Otherwise, the propagation type of the "
"mount point is left unchanged."
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:530
msgid ""
"When a mount point is a slave, mount and unmount events propagate into this "
"mount point from the (master) shared peer group of which it was formerly a "
"member.  Mount and unmount events under this mount point do not propagate to"
" any peer."
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:534
msgid ""
"A mount point can be the slave of another peer group while at the same time "
"sharing mount and unmount events with a peer group of which it is a member."
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:549
msgid ""
"Make this mount unbindable.  This is like a private mount, and in addition "
"this mount can't be bind mounted.  When a recursive bind mount (B<mount>()  "
"with the B<MS_BIND> and B<MS_REC> flags) is performed on a directory "
"subtree, any unbindable mounts within the subtree are automatically pruned "
"(i.e., not replicated)  when replicating that subtree to produce the target "
"subtree."
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:560
msgid ""
"By default, changing the propagation type affects only the I<target> mount "
"point.  If the B<MS_REC> flag is also specified in I<mountflags>, then the "
"propagation type of all mount points under I<target> is also changed."
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:565
msgid ""
"For further details regarding mount propagation types (including the default"
" propagation type assigned to new mounts), see B<mount_namespaces>(7)."
msgstr ""

#. type: SS
#: man-pages/man2/mount.2:565
#, no-wrap
msgid "Moving a mount"
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:577
msgid ""
"If I<mountflags> contains the flag B<MS_MOVE> (available since Linux "
"2.4.18), then move a subtree: I<source> specifies an existing mount point "
"and I<target> specifies the new location to which that mount point is to be "
"relocated.  The move is atomic: at no point is the subtree unmounted."
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:586
msgid ""
"The remaining bits in the I<mountflags> argument are ignored, as are the "
"I<filesystemtype> and I<data> arguments."
msgstr ""

#. type: SS
#: man-pages/man2/mount.2:586
#, no-wrap
msgid "Creating a new mount point"
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:605
msgid ""
"If none of B<MS_REMOUNT>, B<MS_BIND>, B<MS_MOVE>, B<MS_SHARED>, "
"B<MS_PRIVATE>, B<MS_SLAVE>, or B<MS_UNBINDABLE> is specified in "
"I<mountflags>, then B<mount>()  performs its default action: creating a new "
"mount point.  I<source> specifies the source for the new mount point, and "
"I<target> specifies the directory at which to create the mount point."
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:614
msgid ""
"The I<filesystemtype> and I<data> arguments are employed, and further bits "
"may be specified in I<mountflags> to modify the behavior of the call."
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:619
msgid ""
"On success, zero is returned.  On error, -1 is returned, and I<errno> is set"
" appropriately."
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:625
msgid ""
"The error values given below result from filesystem type independent errors."
"  Each filesystem type may have its own special errors and its own special "
"behavior.  See the Linux kernel source code for details."
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:630
msgid ""
"A component of a path was not searchable.  (See also B<path_resolution>(7).)"
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:635
msgid ""
"Mounting a read-only filesystem was attempted without giving the "
"B<MS_RDONLY> flag."
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:644
msgid ""
"The file system may be read-only for various reasons, including: it resides "
"on a read-only optical disk; it is resides on a device with a physical "
"switch that has been set to mark the device read-only; the filesystem "
"implementation was compiled with read-only support; or errors were detected "
"when initially mounting the filesystem, so that it was marked read-only and "
"can't be remounted as read-write (until the errors are fixed)."
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:648
msgid ""
"Some filesystems instead return the error B<EROFS> on an attempt to mount a "
"read-only filesystem."
msgstr ""

#.  mtk: Probably: write permission is required for MS_BIND, with
#.  the error EPERM if not present; CAP_DAC_OVERRIDE is required.
#. type: Plain text
#: man-pages/man2/mount.2:657
msgid ""
"The block device I<source> is located on a filesystem mounted with the "
"B<MS_NODEV> option."
msgstr ""

#. type: TP
#: man-pages/man2/mount.2:657 man-pages/man2/mount.2:665
#, no-wrap
msgid "B<EBUSY>"
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:665
msgid ""
"An attempt was made to stack a new mount directly on top of an existing "
"mount point that was created in this mount namespace with the same I<source>"
" and I<target>."
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:670
msgid ""
"I<source> cannot be remounted read-only, because it still holds files open "
"for writing."
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:673
msgid "One of the pointer arguments points outside the user address space."
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:677
msgid "I<source> had an invalid superblock."
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:685
msgid ""
"A remount operation (B<MS_REMOUNT>)  was attempted, but I<source> was not "
"already mounted on I<target>."
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:695
msgid ""
"A move operation (B<MS_MOVE>)  was attempted, but the mount tree under "
"I<source> includes unbindable mounts and I<target> is a mount point that has"
" propagation type B<MS_SHARED>."
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:703
msgid ""
"A move operation (B<MS_MOVE>)  was attempted, but the parent mount of "
"I<source> mount has propagation type B<MS_SHARED>."
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:710
msgid ""
"A move operation (B<MS_MOVE>)  was attempted, but I<source> was not a mount "
"point, or was \\(aq/\\(aq."
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:719
msgid ""
"I<mountflags> includes more than one of B<MS_SHARED>, B<MS_PRIVATE>, "
"B<MS_SLAVE>, or B<MS_UNBINDABLE>."
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:732
msgid ""
"I<mountflags> includes B<MS_SHARED>, B<MS_PRIVATE>, B<MS_SLAVE>, or "
"B<MS_UNBINDABLE> and also includes a flag other than B<MS_REC> or "
"B<MS_SILENT>."
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:735
msgid "An attempt was made to bind mount an unbindable mount."
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:746
msgid ""
"In an unprivileged mount namespace (i.e., a mount namespace owned by a user "
"namespace that was created by an unprivileged user), a bind mount operation "
"(B<MS_BIND>)  was attempted without specifying (B<MS_REC>), which would have"
" revealed the filesystem tree underneath one of the submounts of the "
"directory being bound."
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:749
msgid "Too many links encountered during pathname resolution."
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:755
msgid ""
"A move operation was attempted, and I<target> is a descendant of I<source>."
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:759
msgid ""
"(In case no block device is required:)  Table of dummy devices is full."
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:763
msgid "A pathname was longer than B<MAXPATHLEN>."
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:767
msgid "I<filesystemtype> not configured in the kernel."
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:770
msgid "A pathname was empty or had a nonexistent component."
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:773
msgid ""
"The kernel could not allocate a free page to copy filenames or data into."
msgstr ""

#. type: TP
#: man-pages/man2/mount.2:773
#, no-wrap
msgid "B<ENOTBLK>"
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:777
msgid "I<source> is not a block device (and a device was required)."
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:783
msgid "I<target>, or a prefix of I<source>, is not a directory."
msgstr ""

#. type: TP
#: man-pages/man2/mount.2:783
#, no-wrap
msgid "B<ENXIO>"
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:788
msgid "The major number of the block device I<source> is out of range."
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:791
msgid "The caller does not have the required privileges."
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:799
msgid ""
"Mounting a read-only filesystem was attempted without giving the "
"B<MS_RDONLY> flag.  See B<EACCES>, above."
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:813
msgid ""
"The definitions of B<MS_DIRSYNC>, B<MS_MOVE>, B<MS_PRIVATE>, B<MS_REC>, "
"B<MS_RELATIME>, B<MS_SHARED>, B<MS_SLAVE>, B<MS_STRICTATIME>, and "
"B<MS_UNBINDABLE> were added to glibc headers in version 2.12."
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:816
msgid ""
"This function is Linux-specific and should not be used in programs intended "
"to be portable."
msgstr ""

#.  Multiple mounts on same mount point: since 2.3.99pre7.
#. type: Plain text
#: man-pages/man2/mount.2:821
msgid ""
"Since Linux 2.4 a single filesystem can be mounted at multiple mount points,"
" and multiple mounts can be stacked on the same mount point."
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:833
msgid ""
"The I<mountflags> argument may have the magic number 0xC0ED (B<MS_MGC_VAL>)"
"  in the top 16 bits.  (All of the other flags discussed in DESCRIPTION "
"occupy the low order 16 bits of I<mountflags>.)  Specifying B<MS_MGC_VAL> "
"was required in kernel versions prior to 2.4, but since Linux 2.4 is no "
"longer required and is ignored if specified."
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:842
msgid ""
"The original B<MS_SYNC> flag was renamed B<MS_SYNCHRONOUS> in 1.1.69 when a "
"different B<MS_SYNC> was added to I<E<lt>mman.hE<gt>>."
msgstr ""

#.  The change is in patch-2.4.0-prerelease.
#. type: Plain text
#: man-pages/man2/mount.2:852
msgid ""
"Before Linux 2.4 an attempt to execute a set-user-ID or set-group-ID program"
" on a filesystem mounted with B<MS_NOSUID> would fail with B<EPERM>.  Since "
"Linux 2.4 the set-user-ID and set-group-ID bits are just silently ignored in"
" this case."
msgstr ""

#. type: SS
#: man-pages/man2/mount.2:852
#, no-wrap
msgid "Per-process namespaces"
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:863
msgid ""
"Starting with kernel 2.4.19, Linux provides per-process mount namespaces.  A"
" mount namespace is the set of filesystem mounts that are visible to a "
"process.  Mount-point namespaces can be (and usually are)  shared between "
"multiple processes, and changes to the namespace (i.e., mounts and unmounts)"
" by one process are visible to all other processes sharing the same "
"namespace.  (The pre-2.4.19 Linux situation can be considered as one in "
"which a single namespace was shared by every process on the system.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:869
msgid ""
"A child process created by B<fork>(2)  shares its parent's mount namespace; "
"the mount namespace is preserved across an B<execve>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:889
msgid ""
"A process can obtain a private mount namespace if: it was created using the "
"B<clone>(2)  B<CLONE_NEWNS> flag, in which case its new namespace is "
"initialized to be a I<copy> of the namespace of the process that called "
"B<clone>(2); or it calls B<unshare>(2)  with the B<CLONE_NEWNS> flag, which "
"causes the caller's mount namespace to obtain a private copy of the "
"namespace that it was previously sharing with other processes, so that "
"future mounts and unmounts by the caller are invisible to other processes "
"(except child processes that the caller subsequently creates) and vice "
"versa."
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:904
msgid ""
"The Linux-specific I</proc/[pid]/mounts> file exposes the list of mount "
"points in the mount namespace of the process with the specified ID.  The "
"I</proc/[pid]/mountinfo> file exposes even more information about mount "
"points, including the propagation type and mount ID information that makes "
"it possible to discover the parental relationship between mount points.  See"
" B<proc>(5)  and B<mount_namespaces>(7)  for details of these files."
msgstr ""

#. type: Plain text
#: man-pages/man2/mount.2:915
msgid ""
"B<mountpoint>(1), B<chroot>(2), B<ioctl_iflags>(2), B<pivot_root>(2), "
"B<umount>(2), B<mount_namespaces>(7), B<path_resolution>(7), B<findmnt>(8), "
"B<lsblk>(8), B<mount>(8), B<umount>(8)"
msgstr ""

#. type: TH
#: man-pages/man2/msgop.2:39
#, no-wrap
msgid "MSGOP"
msgstr ""

#. type: Plain text
#: man-pages/man2/msgop.2:42
msgid "msgrcv, msgsnd - System V message queue operations"
msgstr ""

#. type: Plain text
#: man-pages/man2/msgop.2:50
#, no-wrap
msgid ""
"B<int msgsnd(int >I<msqid>B<, const void *>I<msgp>B<, size_t >I<msgsz>B<, "
"int >I<msgflg>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/msgop.2:54
#, no-wrap
msgid ""
"B<ssize_t msgrcv(int >I<msqid>B<, void *>I<msgp>B<, size_t >I<msgsz>B<, long >I<msgtyp>B<,>\n"
"B<               int >I<msgflg>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/msgop.2:64
msgid ""
"The B<msgsnd>()  and B<msgrcv>()  system calls are used to send messages to,"
" and receive messages from, a System\\ V message queue.  The calling process"
" must have write permission on the message queue in order to send a message,"
" and read permission to receive a message."
msgstr ""

#. type: Plain text
#: man-pages/man2/msgop.2:69
msgid ""
"The I<msgp> argument is a pointer to a caller-defined structure of the "
"following general form:"
msgstr ""

#. type: Plain text
#: man-pages/man2/msgop.2:76
#, no-wrap
msgid ""
"struct msgbuf {\n"
"    long mtype;       /* message type, must be E<gt> 0 */\n"
"    char mtext[1];    /* message data */\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/msgop.2:95
msgid ""
"The I<mtext> field is an array (or other structure) whose size is specified "
"by I<msgsz>, a nonnegative integer value.  Messages of zero length (i.e., no"
" I<mtext> field) are permitted.  The I<mtype> field must have a strictly "
"positive integer value.  This value can be used by the receiving process for"
" message selection (see the description of B<msgrcv>()  below)."
msgstr ""

#. type: SS
#: man-pages/man2/msgop.2:95
#, no-wrap
msgid "msgsnd()"
msgstr ""

#. type: Plain text
#: man-pages/man2/msgop.2:103
msgid ""
"The B<msgsnd>()  system call appends a copy of the message pointed to by "
"I<msgp> to the message queue whose identifier is specified by I<msqid>."
msgstr ""

#. type: Plain text
#: man-pages/man2/msgop.2:116
msgid ""
"If sufficient space is available in the queue, B<msgsnd>()  succeeds "
"immediately.  The queue capacity is governed by the I<msg_qbytes> field in "
"the associated data structure for the message queue.  During queue creation "
"this field is initialized to B<MSGMNB> bytes, but this limit can be modified"
" using B<msgctl>(2).  A message queue is considered to be full if either of "
"the following conditions is true:"
msgstr ""

#. type: Plain text
#: man-pages/man2/msgop.2:121
msgid ""
"Adding a new message to the queue would cause the total number of bytes in "
"the queue to exceed the queue's maximum size (the I<msg_qbytes> field)."
msgstr ""

#. type: Plain text
#: man-pages/man2/msgop.2:130
msgid ""
"Adding another message to the queue would cause the total number of messages"
" in the queue to exceed the queue's maximum size (the I<msg_qbytes> field)."
"  This check is necessary to prevent an unlimited number of zero-length "
"messages being placed on the queue.  Although such messages contain no data,"
" they nevertheless consume (locked) kernel memory."
msgstr ""

#. type: Plain text
#: man-pages/man2/msgop.2:141
msgid ""
"If insufficient space is available in the queue, then the default behavior "
"of B<msgsnd>()  is to block until space becomes available.  If B<IPC_NOWAIT>"
" is specified in I<msgflg>, then the call instead fails with the error "
"B<EAGAIN>."
msgstr ""

#. type: Plain text
#: man-pages/man2/msgop.2:145
msgid "A blocked B<msgsnd>()  call may also fail if:"
msgstr ""

#. type: Plain text
#: man-pages/man2/msgop.2:152
msgid ""
"the queue is removed, in which case the system call fails with I<errno> set "
"to B<EIDRM>; or"
msgstr ""

#. type: Plain text
#: man-pages/man2/msgop.2:164
msgid ""
"a signal is caught, in which case the system call fails with I<errno> set to"
" B<EINTR>;B<see> B<signal>(7).  (B<msgsnd>()  is never automatically "
"restarted after being interrupted by a signal handler, regardless of the "
"setting of the B<SA_RESTART> flag when establishing a signal handler.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/msgop.2:167 man-pages/man2/msgop.2:328
msgid ""
"Upon successful completion the message queue data structure is updated as "
"follows:"
msgstr ""

#. type: Plain text
#: man-pages/man2/msgop.2:170
msgid "I<msg_lspid> is set to the process ID of the calling process."
msgstr ""

#. type: Plain text
#: man-pages/man2/msgop.2:173
msgid "I<msg_qnum> is incremented by 1."
msgstr ""

#. type: Plain text
#: man-pages/man2/msgop.2:176
msgid "I<msg_stime> is set to the current time."
msgstr ""

#. type: SS
#: man-pages/man2/msgop.2:176
#, no-wrap
msgid "msgrcv()"
msgstr ""

#. type: Plain text
#: man-pages/man2/msgop.2:184
msgid ""
"The B<msgrcv>()  system call removes a message from the queue specified by "
"I<msqid> and places it in the buffer pointed to by I<msgp>."
msgstr ""

#. type: Plain text
#: man-pages/man2/msgop.2:210
msgid ""
"The argument I<msgsz> specifies the maximum size in bytes for the member "
"I<mtext> of the structure pointed to by the I<msgp> argument.  If the "
"message text has length greater than I<msgsz>, then the behavior depends on "
"whether B<MSG_NOERROR> is specified in I<msgflg>.  If B<MSG_NOERROR> is "
"specified, then the message text will be truncated (and the truncated part "
"will be lost); if B<MSG_NOERROR> is not specified, then the message isn't "
"removed from the queue and the system call fails returning -1 with I<errno> "
"set to B<E2BIG>."
msgstr ""

#. type: Plain text
#: man-pages/man2/msgop.2:219
msgid ""
"Unless B<MSG_COPY> is specified in I<msgflg> (see below), the I<msgtyp> "
"argument specifies the type of message requested, as follows:"
msgstr ""

#. type: Plain text
#: man-pages/man2/msgop.2:224
msgid "If I<msgtyp> is 0, then the first message in the queue is read."
msgstr ""

#. type: Plain text
#: man-pages/man2/msgop.2:238
msgid ""
"If I<msgtyp> is greater than 0, then the first message in the queue of type "
"I<msgtyp> is read, unless B<MSG_EXCEPT> was specified in I<msgflg>, in which"
" case the first message in the queue of type not equal to I<msgtyp> will be "
"read."
msgstr ""

#. type: Plain text
#: man-pages/man2/msgop.2:246
msgid ""
"If I<msgtyp> is less than 0, then the first message in the queue with the "
"lowest type less than or equal to the absolute value of I<msgtyp> will be "
"read."
msgstr ""

#. type: Plain text
#: man-pages/man2/msgop.2:251
msgid ""
"The I<msgflg> argument is a bit mask constructed by ORing together zero or "
"more of the following flags:"
msgstr ""

#. type: TP
#: man-pages/man2/msgop.2:251
#, no-wrap
msgid "B<IPC_NOWAIT>"
msgstr ""

#. type: Plain text
#: man-pages/man2/msgop.2:258
msgid ""
"Return immediately if no message of the requested type is in the queue.  The"
" system call fails with I<errno> set to B<ENOMSG>."
msgstr ""

#. type: TP
#: man-pages/man2/msgop.2:258
#, no-wrap
msgid "B<MSG_COPY> (since Linux 3.8)"
msgstr ""

#.  commit 4a674f34ba04a002244edaf891b5da7fc1473ae8
#. type: Plain text
#: man-pages/man2/msgop.2:265
msgid ""
"Nondestructively fetch a copy of the message at the ordinal position in the "
"queue specified by I<msgtyp> (messages are considered to be numbered "
"starting at 0)."
msgstr ""

#. type: Plain text
#: man-pages/man2/msgop.2:279
msgid ""
"This flag must be specified in conjunction with B<IPC_NOWAIT>, with the "
"result that, if there is no message available at the given position, the "
"call fails immediately with the error B<ENOMSG>.  Because they alter the "
"meaning of I<msgtyp> in orthogonal ways, B<MSG_COPY> and B<MSG_EXCEPT> may "
"not both be specified in I<msgflg>."
msgstr ""

#. type: Plain text
#: man-pages/man2/msgop.2:287
msgid ""
"The B<MSG_COPY> flag was added for the implementation of the kernel "
"checkpoint-restore facility and is available only if the kernel was built "
"with the B<CONFIG_CHECKPOINT_RESTORE> option."
msgstr ""

#. type: TP
#: man-pages/man2/msgop.2:287
#, no-wrap
msgid "B<MSG_EXCEPT>"
msgstr ""

#. type: Plain text
#: man-pages/man2/msgop.2:295
msgid ""
"Used with I<msgtyp> greater than 0 to read the first message in the queue "
"with message type that differs from I<msgtyp>."
msgstr ""

#. type: TP
#: man-pages/man2/msgop.2:295
#, no-wrap
msgid "B<MSG_NOERROR>"
msgstr ""

#. type: Plain text
#: man-pages/man2/msgop.2:300
msgid "To truncate the message text if longer than I<msgsz> bytes."
msgstr ""

#. type: Plain text
#: man-pages/man2/msgop.2:306
msgid ""
"If no message of the requested type is available and B<IPC_NOWAIT> isn't "
"specified in I<msgflg>, the calling process is blocked until one of the "
"following conditions occurs:"
msgstr ""

#. type: Plain text
#: man-pages/man2/msgop.2:308
msgid "A message of the desired type is placed in the queue."
msgstr ""

#. type: Plain text
#: man-pages/man2/msgop.2:314
msgid ""
"The message queue is removed from the system.  In this case, the system call"
" fails with I<errno> set to B<EIDRM>."
msgstr ""

#. type: Plain text
#: man-pages/man2/msgop.2:325
msgid ""
"The calling process catches a signal.  In this case, the system call fails "
"with I<errno> set to B<EINTR>.  (B<msgrcv>()  is never automatically "
"restarted after being interrupted by a signal handler, regardless of the "
"setting of the B<SA_RESTART> flag when establishing a signal handler.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/msgop.2:331
msgid "I<msg_lrpid> is set to the process ID of the calling process."
msgstr ""

#. type: Plain text
#: man-pages/man2/msgop.2:334
msgid "I<msg_qnum> is decremented by 1."
msgstr ""

#. type: Plain text
#: man-pages/man2/msgop.2:337
msgid "I<msg_rtime> is set to the current time."
msgstr ""

#. type: Plain text
#: man-pages/man2/msgop.2:350
msgid ""
"On failure both functions return -1 with I<errno> indicating the error, "
"otherwise B<msgsnd>()  returns 0 and B<msgrcv>()  returns the number of "
"bytes actually copied into the I<mtext> array."
msgstr ""

#. type: Plain text
#: man-pages/man2/msgop.2:356
msgid ""
"When B<msgsnd>()  fails, I<errno> will be set to one among the following "
"values:"
msgstr ""

#. type: Plain text
#: man-pages/man2/msgop.2:362
msgid ""
"The calling process does not have write permission on the message queue, and"
" does not have the B<CAP_IPC_OWNER> capability in the user namespace that "
"governs its IPC namespace."
msgstr ""

#. type: Plain text
#: man-pages/man2/msgop.2:370
msgid ""
"The message can't be sent due to the I<msg_qbytes> limit for the queue and "
"B<IPC_NOWAIT> was specified in I<msgflg>."
msgstr ""

#. type: Plain text
#: man-pages/man2/msgop.2:375 man-pages/man2/msgop.2:422
msgid "The address pointed to by I<msgp> isn't accessible."
msgstr ""

#. type: TP
#: man-pages/man2/msgop.2:378 man-pages/man2/msgop.2:426
#, no-wrap
msgid "B<EINTR>"
msgstr ""

#. type: Plain text
#: man-pages/man2/msgop.2:381
msgid ""
"Sleeping on a full message queue condition, the process caught a signal."
msgstr ""

#. type: Plain text
#: man-pages/man2/msgop.2:392
msgid ""
"Invalid I<msqid> value, or nonpositive I<mtype> value, or invalid I<msgsz> "
"value (less than 0 or greater than the system value B<MSGMAX>)."
msgstr ""

#. type: Plain text
#: man-pages/man2/msgop.2:397
msgid ""
"The system does not have enough memory to make a copy of the message pointed"
" to by I<msgp>."
msgstr ""

#. type: Plain text
#: man-pages/man2/msgop.2:403
msgid ""
"When B<msgrcv>()  fails, I<errno> will be set to one among the following "
"values:"
msgstr ""

#. type: TP
#: man-pages/man2/msgop.2:403
#, no-wrap
msgid "B<E2BIG>"
msgstr ""

#. type: Plain text
#: man-pages/man2/msgop.2:411
msgid ""
"The message text length is greater than I<msgsz> and B<MSG_NOERROR> isn't "
"specified in I<msgflg>."
msgstr ""

#. type: Plain text
#: man-pages/man2/msgop.2:417
msgid ""
"The calling process does not have read permission on the message queue, and "
"does not have the B<CAP_IPC_OWNER> capability in the user namespace that "
"governs its IPC namespace."
msgstr ""

#. type: Plain text
#: man-pages/man2/msgop.2:426
msgid ""
"While the process was sleeping to receive a message, the message queue was "
"removed."
msgstr ""

#. type: Plain text
#: man-pages/man2/msgop.2:431
msgid ""
"While the process was sleeping to receive a message, the process caught a "
"signal; see B<signal>(7)."
msgstr ""

#. type: Plain text
#: man-pages/man2/msgop.2:437
msgid "I<msqid> was invalid, or I<msgsz> was less than 0."
msgstr ""

#. type: TP
#: man-pages/man2/msgop.2:437 man-pages/man2/msgop.2:444
#, no-wrap
msgid "B<EINVAL> (since Linux 3.14)"
msgstr ""

#. type: Plain text
#: man-pages/man2/msgop.2:444
msgid "I<msgflg> specified B<MSG_COPY>, but not B<IPC_NOWAIT>."
msgstr ""

#. type: Plain text
#: man-pages/man2/msgop.2:451
msgid "I<msgflg> specified both B<MSG_COPY> and B<MSG_EXCEPT>."
msgstr ""

#. type: TP
#: man-pages/man2/msgop.2:451 man-pages/man2/msgop.2:457
#, no-wrap
msgid "B<ENOMSG>"
msgstr ""

#. type: Plain text
#: man-pages/man2/msgop.2:457
msgid ""
"B<IPC_NOWAIT> was specified in I<msgflg> and no message of the requested "
"type existed on the message queue."
msgstr ""

#. type: Plain text
#: man-pages/man2/msgop.2:467
msgid ""
"B<IPC_NOWAIT> and B<MSG_COPY> were specified in I<msgflg> and the queue "
"contains less than I<msgtyp> messages."
msgstr ""

#. type: TP
#: man-pages/man2/msgop.2:467
#, no-wrap
msgid "B<ENOSYS> (since Linux 3.8)"
msgstr ""

#. type: Plain text
#: man-pages/man2/msgop.2:474
msgid ""
"I<MSG_COPY> was specified in I<msgflg>, and this kernel was configured "
"without B<CONFIG_CHECKPOINT_RESTORE>."
msgstr ""

#.  MSG_COPY since glibc 2.18
#. type: Plain text
#: man-pages/man2/msgop.2:486
msgid ""
"The B<MSG_EXCEPT> and B<MSG_COPY> flags are Linux-specific; their "
"definitions can be obtained by defining the B<_GNU_SOURCE> feature test "
"macro."
msgstr ""

#. type: Plain text
#: man-pages/man2/msgop.2:506
msgid ""
"The I<msgp> argument is declared as I<struct msgbuf\\ *> in glibc 2.0 and "
"2.1.  It is declared as I<void\\ *> in glibc 2.2 and later, as required by "
"SUSv2 and SUSv3."
msgstr ""

#. type: Plain text
#: man-pages/man2/msgop.2:510
msgid ""
"The following limits on message queue resources affect the B<msgsnd>()  "
"call:"
msgstr ""

#. type: TP
#: man-pages/man2/msgop.2:510
#, no-wrap
msgid "B<MSGMAX>"
msgstr ""

#. type: Plain text
#: man-pages/man2/msgop.2:515
msgid ""
"Maximum size of a message text, in bytes (default value: 8192 bytes).  On "
"Linux, this limit can be read and modified via I</proc/sys/kernel/msgmax>."
msgstr ""

#. type: TP
#: man-pages/man2/msgop.2:515
#, no-wrap
msgid "B<MSGMNB>"
msgstr ""

#. type: Plain text
#: man-pages/man2/msgop.2:531
msgid ""
"Maximum number of bytes that can be held in a message queue (default value: "
"16384 bytes).  On Linux, this limit can be read and modified via "
"I</proc/sys/kernel/msgmnb>.  A privileged process (Linux: a process with the"
" B<CAP_SYS_RESOURCE> capability)  can increase the size of a message queue "
"beyond B<MSGMNB> using the B<msgctl>(2)  B<IPC_SET> operation."
msgstr ""

#. type: Plain text
#: man-pages/man2/msgop.2:537
msgid ""
"The implementation has no intrinsic system-wide limits on the number of "
"message headers (B<MSGTQL>)  and the number of bytes in the message pool "
"(B<MSGPOOL>)."
msgstr ""

#.  http://marc.info/?l=linux-kernel&m=139048542803605&w=2
#.  commit 4f87dac386cc43d5525da7a939d4b4e7edbea22c
#. type: Plain text
#: man-pages/man2/msgop.2:557
msgid ""
"In Linux 3.13 and earlier, if B<msgrcv>()  was called with the B<MSG_COPY> "
"flag, but without B<IPC_NOWAIT>, and the message queue contained less than "
"I<msgtyp> messages, then the call would block until the next message is "
"written to the queue.  At that point, the call would return a copy of the "
"message, I<regardless> of whether that message was at the ordinal position "
"I<msgtyp>.  This bug is fixed in Linux 3.14."
msgstr ""

#.  http://marc.info/?l=linux-kernel&m=139048542803605&w=2
#.  commit 4f87dac386cc43d5525da7a939d4b4e7edbea22c
#. type: Plain text
#: man-pages/man2/msgop.2:573
msgid ""
"Specifying both B<MSG_COPY> and B<MSC_EXCEPT> in I<msgflg> is a logical "
"error (since these flags impose different interpretations on I<msgtyp>).  In"
" Linux 3.13 and earlier, this error was not diagnosed by B<msgrcv>().  This "
"bug is fixed in Linux 3.14."
msgstr ""

#. type: Plain text
#: man-pages/man2/msgop.2:578
msgid ""
"The program below demonstrates the use of B<msgsnd>()  and B<msgrcv>()."
msgstr ""

#. type: Plain text
#: man-pages/man2/msgop.2:582
msgid ""
"The example program is first run with the B<-s> option to send a message and"
" then run again with the B<-r> option to receive a message."
msgstr ""

#. type: Plain text
#: man-pages/man2/msgop.2:584
msgid "The following shell session shows a sample run of the program:"
msgstr ""

#. type: Plain text
#: man-pages/man2/msgop.2:589
#, no-wrap
msgid ""
"$B< ./a.out -s>\n"
"sent: a message at Wed Mar  4 16:25:45 2015\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/msgop.2:592
#, no-wrap
msgid ""
"$B< ./a.out -r>\n"
"message received: a message at Wed Mar  4 16:25:45 2015\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/msgop.2:606
#, no-wrap
msgid ""
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>time.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"
"#include E<lt>sys/types.hE<gt>\n"
"#include E<lt>sys/ipc.hE<gt>\n"
"#include E<lt>sys/msg.hE<gt>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/msgop.2:611
#, no-wrap
msgid ""
"struct msgbuf {\n"
"    long mtype;\n"
"    char mtext[80];\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/msgop.2:617
#, no-wrap
msgid ""
"static void\n"
"usage(char *prog_name, char *msg)\n"
"{\n"
"    if (msg != NULL)\n"
"        fputs(msg, stderr);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/msgop.2:626
#, no-wrap
msgid ""
"    fprintf(stderr, \"Usage: %s [options]\\en\", prog_name);\n"
"    fprintf(stderr, \"Options are:\\en\");\n"
"    fprintf(stderr, \"-s        send message using msgsnd()\\en\");\n"
"    fprintf(stderr, \"-r        read message using msgrcv()\\en\");\n"
"    fprintf(stderr, \"-t        message type (default is 1)\\en\");\n"
"    fprintf(stderr, \"-k        message queue key (default is 1234)\\en\");\n"
"    exit(EXIT_FAILURE);\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/msgop.2:632
#, no-wrap
msgid ""
"static void\n"
"send_msg(int qid, int msgtype)\n"
"{\n"
"    struct msgbuf msg;\n"
"    time_t t;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/msgop.2:634
#, no-wrap
msgid "    msg.mtype = msgtype;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/msgop.2:638
#, no-wrap
msgid ""
"    time(&t);\n"
"    snprintf(msg.mtext, sizeof(msg.mtext), \"a message at %s\",\n"
"            ctime(&t));\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/msgop.2:646
#, no-wrap
msgid ""
"    if (msgsnd(qid, (void *) &msg, sizeof(msg.mtext),\n"
"                IPC_NOWAIT) == -1) {\n"
"        perror(\"msgsnd error\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
"    printf(\"sent: %s\\en\", msg.mtext);\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/msgop.2:651
#, no-wrap
msgid ""
"static void\n"
"get_msg(int qid, int msgtype)\n"
"{\n"
"    struct msgbuf msg;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/msgop.2:662
#, no-wrap
msgid ""
"    if (msgrcv(qid, (void *) &msg, sizeof(msg.mtext), msgtype,\n"
"               MSG_NOERROR | IPC_NOWAIT) == -1) {\n"
"        if (errno != ENOMSG) {\n"
"            perror(\"msgrcv\");\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"
"        printf(\"No message available for msgrcv()\\en\");\n"
"    } else\n"
"        printf(\"message received: %s\\en\", msg.mtext);\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/msgop.2:670
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int qid, opt;\n"
"    int mode = 0;               /* 1 = send, 2 = receive */\n"
"    int msgtype = 1;\n"
"    int msgkey = 1234;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/msgop.2:691
#, no-wrap
msgid ""
"    while ((opt = getopt(argc, argv, \"srt:k:\")) != -1) {\n"
"        switch (opt) {\n"
"        case \\(aqs\\(aq:\n"
"            mode = 1;\n"
"            break;\n"
"        case \\(aqr\\(aq:\n"
"            mode = 2;\n"
"            break;\n"
"        case \\(aqt\\(aq:\n"
"            msgtype = atoi(optarg);\n"
"            if (msgtype E<lt>= 0)\n"
"                usage(argv[0], \"-t option must be greater than 0\\en\");\n"
"            break;\n"
"        case \\(aqk\\(aq:\n"
"            msgkey = atoi(optarg);\n"
"            break;\n"
"        default:\n"
"            usage(argv[0], \"Unrecognized option\\en\");\n"
"        }\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/msgop.2:694
#, no-wrap
msgid ""
"    if (mode == 0)\n"
"        usage(argv[0], \"must use either -s or -r option\\en\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/msgop.2:696
#, no-wrap
msgid "    qid = msgget(msgkey, IPC_CREAT | 0666);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/msgop.2:701
#, no-wrap
msgid ""
"    if (qid == -1) {\n"
"        perror(\"msgget\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/msgop.2:706
#, no-wrap
msgid ""
"    if (mode == 2)\n"
"        get_msg(qid, msgtype);\n"
"    else\n"
"        send_msg(qid, msgtype);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/msgop.2:715
msgid ""
"B<msgctl>(2), B<msgget>(2), B<capabilities>(7), B<mq_overview>(7), "
"B<sysvipc>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/move_pages.2:20
#, no-wrap
msgid "MOVE_PAGES"
msgstr ""

#. type: Plain text
#: man-pages/man2/move_pages.2:23
msgid "move_pages - move individual pages of a process to another node"
msgstr ""

#. type: Plain text
#: man-pages/man2/move_pages.2:26
#, no-wrap
msgid "B<#include E<lt>numaif.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/move_pages.2:29
#, no-wrap
msgid ""
"B<long move_pages(int >I<pid>B<, unsigned long count, void **>I<pages>B<,>\n"
"B<                const int *>I<nodes>B<, int *>I<status>B<, int >I<flags>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/move_pages.2:32
msgid "Link with I<-lnuma>."
msgstr ""

#. type: Plain text
#: man-pages/man2/move_pages.2:45
msgid ""
"B<move_pages>()  moves the specified I<pages> of the process I<pid> to the "
"memory nodes specified by I<nodes>.  The result of the move is reflected in "
"I<status>.  The I<flags> indicate constraints on the pages to be moved."
msgstr ""

#. type: Plain text
#: man-pages/man2/move_pages.2:53
msgid ""
"I<pid> is the ID of the process in which pages are to be moved.  If I<pid> "
"is 0, then B<move_pages>()  moves pages of the calling process."
msgstr ""

#. type: Plain text
#: man-pages/man2/move_pages.2:55
msgid "To move pages in another process requires the following privileges:"
msgstr ""

#. type: Plain text
#: man-pages/man2/move_pages.2:61
msgid ""
"In kernels up to and including Linux 4.12: the caller must be privileged "
"(B<CAP_SYS_NICE>)  or the real or effective user ID of the calling process "
"must match the real or saved-set user ID of the target process."
msgstr ""

#.  commit 197e7e521384a23b9e585178f3f11c9fa08274b9
#. type: Plain text
#: man-pages/man2/move_pages.2:73
msgid ""
"The older rules allowed the caller to discover various virtual address "
"choices made by the kernel that could lead to the defeat of address-space-"
"layout randomization for a process owned by the same UID as the caller, the "
"rules were changed starting with Linux 4.13.  Since Linux 4.13, permission "
"is governed by a ptrace access mode B<PTRACE_MODE_READ_REALCREDS> check with"
" respect to the target process; see B<ptrace>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/move_pages.2:81
msgid ""
"I<count> is the number of pages to move.  It defines the size of the three "
"arrays I<pages>, I<nodes>, and I<status>."
msgstr ""

#.  FIXME Describe the result if pointers in the 'pages' array are
#.  not aligned to page boundaries
#. type: Plain text
#: man-pages/man2/move_pages.2:89
msgid ""
"I<pages> is an array of pointers to the pages that should be moved.  These "
"are pointers that should be aligned to page boundaries.  Addresses are "
"specified as seen by the process specified by I<pid>."
msgstr ""

#. type: Plain text
#: man-pages/man2/move_pages.2:102
msgid ""
"I<nodes> is an array of integers that specify the desired location for each "
"page.  Each element in the array is a node number.  I<nodes> can also be "
"NULL, in which case B<move_pages>()  does not move any pages but instead "
"will return the node where each page currently resides, in the I<status> "
"array.  Obtaining the status of each page may be necessary to determine "
"pages that need to be moved."
msgstr ""

#. type: Plain text
#: man-pages/man2/move_pages.2:108
msgid ""
"I<status> is an array of integers that return the status of each page.  The "
"array contains valid values only if B<move_pages>()  did not return an "
"error."
msgstr ""

#. type: Plain text
#: man-pages/man2/move_pages.2:120
msgid ""
"I<flags> specify what types of pages to move.  B<MPOL_MF_MOVE> means that "
"only pages that are in exclusive use by the process are to be moved.  "
"B<MPOL_MF_MOVE_ALL> means that pages shared between multiple processes can "
"also be moved.  The process must be privileged (B<CAP_SYS_NICE>)  to use "
"B<MPOL_MF_MOVE_ALL>."
msgstr ""

#. type: SS
#: man-pages/man2/move_pages.2:120
#, no-wrap
msgid "Page states in the status array"
msgstr ""

#. type: Plain text
#: man-pages/man2/move_pages.2:124
msgid ""
"The following values can be returned in each element of the I<status> array."
msgstr ""

#. type: TP
#: man-pages/man2/move_pages.2:124
#, no-wrap
msgid "B<0..MAX_NUMNODES>"
msgstr ""

#. type: Plain text
#: man-pages/man2/move_pages.2:127
msgid "Identifies the node on which the page resides."
msgstr ""

#. type: TP
#: man-pages/man2/move_pages.2:127
#, no-wrap
msgid "B<-EACCES>"
msgstr ""

#. type: Plain text
#: man-pages/man2/move_pages.2:132
msgid ""
"The page is mapped by multiple processes and can be moved only if "
"B<MPOL_MF_MOVE_ALL> is specified."
msgstr ""

#. type: TP
#: man-pages/man2/move_pages.2:132
#, no-wrap
msgid "B<-EBUSY>"
msgstr ""

#. type: Plain text
#: man-pages/man2/move_pages.2:138
msgid ""
"The page is currently busy and cannot be moved.  Try again later.  This "
"occurs if a page is undergoing I/O or another kernel subsystem is holding a "
"reference to the page."
msgstr ""

#. type: TP
#: man-pages/man2/move_pages.2:138
#, no-wrap
msgid "B<-EFAULT>"
msgstr ""

#. type: Plain text
#: man-pages/man2/move_pages.2:141
msgid "This is a zero page or the memory area is not mapped by the process."
msgstr ""

#. type: TP
#: man-pages/man2/move_pages.2:141
#, no-wrap
msgid "B<-EIO>"
msgstr ""

#. type: Plain text
#: man-pages/man2/move_pages.2:148
msgid ""
"Unable to write back a page.  The page has to be written back in order to "
"move it since the page is dirty and the filesystem does not provide a "
"migration function that would allow the move of dirty pages."
msgstr ""

#. type: TP
#: man-pages/man2/move_pages.2:148
#, no-wrap
msgid "B<-EINVAL>"
msgstr ""

#. type: Plain text
#: man-pages/man2/move_pages.2:153
msgid ""
"A dirty page cannot be moved.  The filesystem does not provide a migration "
"function and has no ability to write back pages."
msgstr ""

#. type: TP
#: man-pages/man2/move_pages.2:153
#, no-wrap
msgid "B<-ENOENT>"
msgstr ""

#. type: Plain text
#: man-pages/man2/move_pages.2:156
msgid "The page is not present."
msgstr ""

#. type: TP
#: man-pages/man2/move_pages.2:156
#, no-wrap
msgid "B<-ENOMEM>"
msgstr ""

#. type: Plain text
#: man-pages/man2/move_pages.2:159
msgid "Unable to allocate memory on target node."
msgstr ""

#.  FIXME . Is the following quite true: does the wrapper in numactl
#.  do the right thing?
#. type: Plain text
#: man-pages/man2/move_pages.2:168
msgid ""
"On success B<move_pages>()  returns zero.  On error, it returns -1, and sets"
" I<errno> to indicate the error."
msgstr ""

#.  commit 3140a2273009c01c27d316f35ab76a37e105fdd8
#. type: Plain text
#: man-pages/man2/move_pages.2:175
msgid ""
"Too many pages to move.  Since Linux 2.6.29, the kernel no longer generates "
"this error."
msgstr ""

#.  FIXME Clarify "current cpuset" in the description of the EACCES error.
#.  Is that the cpuset of the caller or the target?
#. type: Plain text
#: man-pages/man2/move_pages.2:180
msgid "One of the target nodes is not allowed by the current cpuset."
msgstr ""

#. type: Plain text
#: man-pages/man2/move_pages.2:183
msgid "Parameter array could not be accessed."
msgstr ""

#. type: Plain text
#: man-pages/man2/move_pages.2:190
msgid ""
"Flags other than B<MPOL_MF_MOVE> and B<MPOL_MF_MOVE_ALL> was specified or an"
" attempt was made to migrate pages of a kernel thread."
msgstr ""

#. type: Plain text
#: man-pages/man2/move_pages.2:193
msgid "One of the target nodes is not online."
msgstr ""

#. type: Plain text
#: man-pages/man2/move_pages.2:199
msgid ""
"No pages were found that require moving.  All pages are either already on "
"the target node, not present, had an invalid address or could not be moved "
"because they were mapped by multiple processes."
msgstr ""

#. type: Plain text
#: man-pages/man2/move_pages.2:208
msgid ""
"The caller specified B<MPOL_MF_MOVE_ALL> without sufficient privileges "
"(B<CAP_SYS_NICE>).  Or, the caller attempted to move pages of a process "
"belonging to another user but did not have privilege to do so "
"(B<CAP_SYS_NICE>)."
msgstr ""

#. type: TP
#: man-pages/man2/move_pages.2:208
#, no-wrap
msgid "B<ESRCH>"
msgstr ""

#. type: Plain text
#: man-pages/man2/move_pages.2:211
msgid "Process does not exist."
msgstr ""

#. type: Plain text
#: man-pages/man2/move_pages.2:214
msgid "B<move_pages>()  first appeared on Linux in version 2.6.18."
msgstr ""

#. type: Plain text
#: man-pages/man2/move_pages.2:216
msgid "This system call is Linux-specific."
msgstr ""

#. type: Plain text
#: man-pages/man2/move_pages.2:219
msgid "For information on library support, see B<numa>(7)."
msgstr ""

#.  FIXME Clarify "current cpuset".  Is that the cpuset of the caller
#.  or the target?
#. type: Plain text
#: man-pages/man2/move_pages.2:230
msgid ""
"Use B<get_mempolicy>(2)  with the B<MPOL_F_MEMS_ALLOWED> flag to obtain the "
"set of nodes that are allowed by the current cpuset.  Note that this "
"information is subject to change at any time by manual or automatic "
"reconfiguration of the cpuset."
msgstr ""

#. type: Plain text
#: man-pages/man2/move_pages.2:240
msgid ""
"Use of this function may result in pages whose location (node) violates the "
"memory policy established for the specified addresses (See B<mbind>(2))  "
"and/or the specified process (See B<set_mempolicy>(2)).  That is, memory "
"policy does not constrain the destination nodes used by B<move_pages>()."
msgstr ""

#. type: Plain text
#: man-pages/man2/move_pages.2:246
msgid ""
"The I<E<lt>numaif.hE<gt>> header is not included with glibc, but requires "
"installing I<libnuma-devel> or a similar package."
msgstr ""

#. type: Plain text
#: man-pages/man2/move_pages.2:255
msgid ""
"B<get_mempolicy>(2), B<mbind>(2), B<set_mempolicy>(2), B<numa>(3), "
"B<numa_maps>(5), B<cpuset>(7), B<numa>(7), B<migratepages>(8), "
"B<numastat>(8)"
msgstr ""

#. type: TH
#: man-pages/man2/membarrier.2:25
#, no-wrap
msgid "MEMBARRIER"
msgstr ""

#. type: TH
#: man-pages/man2/membarrier.2:25
#, no-wrap
msgid "2018-04-30"
msgstr ""

#. type: Plain text
#: man-pages/man2/membarrier.2:28
msgid "membarrier - issue memory barriers on a set of threads"
msgstr ""

#. type: Plain text
#: man-pages/man2/membarrier.2:30
msgid "B<#include E<lt>linux/membarrier.hE<gt>>"
msgstr ""

#. type: Plain text
#: man-pages/man2/membarrier.2:32
msgid "B<int membarrier(int >I<cmd>B<, int >I<flags>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/membarrier.2:42
msgid ""
"The B<membarrier>()  system call helps reducing the overhead of the memory "
"barrier instructions required to order memory accesses on multi-core "
"systems.  However, this system call is heavier than a memory barrier, so "
"using it effectively is I<not> as simple as replacing memory barriers with "
"this system call, but requires understanding of the details below."
msgstr ""

#. type: Plain text
#: man-pages/man2/membarrier.2:47
msgid ""
"Use of memory barriers needs to be done taking into account that a memory "
"barrier always needs to be either matched with its memory barrier "
"counterparts, or that the architecture's memory model doesn't require the "
"matching barriers."
msgstr ""

#. type: Plain text
#: man-pages/man2/membarrier.2:56
msgid ""
"There are cases where one side of the matching barriers (which we will refer"
" to as \"fast side\") is executed much more often than the other (which we "
"will refer to as \"slow side\").  This is a prime target for the use of "
"B<membarrier>().  The key idea is to replace, for these matching barriers, "
"the fast-side memory barriers by simple compiler barriers, for example:"
msgstr ""

#. type: Plain text
#: man-pages/man2/membarrier.2:60
#, no-wrap
msgid "asm volatile (\"\" : : : \"memory\")\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/membarrier.2:65
msgid "and replace the slow-side memory barriers by calls to B<membarrier>()."
msgstr ""

#. type: Plain text
#: man-pages/man2/membarrier.2:71
msgid ""
"This will add overhead to the slow side, and remove overhead from the fast "
"side, thus resulting in an overall performance increase as long as the slow "
"side is infrequent enough that the overhead of the B<membarrier>()  calls "
"does not outweigh the performance gain on the fast side."
msgstr ""

#. type: Plain text
#: man-pages/man2/membarrier.2:75
msgid "The I<cmd> argument is one of the following:"
msgstr ""

#. type: TP
#: man-pages/man2/membarrier.2:75
#, no-wrap
msgid "B<MEMBARRIER_CMD_QUERY> (since Linux 4.3)"
msgstr ""

#. type: Plain text
#: man-pages/man2/membarrier.2:86
msgid ""
"Query the set of supported commands.  The return value of the call is a bit "
"mask of supported commands.  B<MEMBARRIER_CMD_QUERY>, which has the value 0,"
" is not itself included in this bit mask.  This command is always supported "
"(on kernels where B<membarrier>()  is provided)."
msgstr ""

#. type: TP
#: man-pages/man2/membarrier.2:86
#, no-wrap
msgid "B<MEMBARRIER_CMD_GLOBAL> (since Linux 4.16)"
msgstr ""

#. type: Plain text
#: man-pages/man2/membarrier.2:94
msgid ""
"Ensure that all threads from all processes on the system pass through a "
"state where all memory accesses to user-space addresses match program order "
"between entry to and return from the B<membarrier>()  system call.  All "
"threads on the system are targeted by this command."
msgstr ""

#. type: TP
#: man-pages/man2/membarrier.2:94
#, no-wrap
msgid "B<MEMBARRIER_CMD_GLOBAL_EXPEDITED> (since Linux 4.16)"
msgstr ""

#. type: Plain text
#: man-pages/man2/membarrier.2:99
msgid ""
"Execute a memory barrier on all running threads of all processes that "
"previously registered with B<MEMBARRIER_CMD_REGISTER_GLOBAL_EXPEDITED>."
msgstr ""

#. type: Plain text
#: man-pages/man2/membarrier.2:107
msgid ""
"Upon return from the system call, the calling thread has a guarantee that "
"all running threads have passed through a state where all memory accesses to"
" user-space addresses match program order between entry to and return from "
"the system call (non-running threads are de facto in such a state).  This "
"guarantee is provided only for the threads of processes that previously "
"registered with B<MEMBARRIER_CMD_REGISTER_GLOBAL_EXPEDITED>."
msgstr ""

#. type: Plain text
#: man-pages/man2/membarrier.2:113
msgid ""
"Given that registration is about the intent to receive the barriers, it is "
"valid to invoke B<MEMBARRIER_CMD_GLOBAL_EXPEDITED> from a process that has "
"not employed B<MEMBARRIER_CMD_REGISTER_GLOBAL_EXPEDITED>."
msgstr ""

#. type: Plain text
#: man-pages/man2/membarrier.2:116 man-pages/man2/membarrier.2:136
msgid ""
"The \"expedited\" commands complete faster than the non-expedited ones; they"
" never block, but have the downside of causing extra overhead."
msgstr ""

#. type: TP
#: man-pages/man2/membarrier.2:116
#, no-wrap
msgid "B<MEMBARRIER_CMD_REGISTER_GLOBAL_EXPEDITED> (since Linux 4.16)"
msgstr ""

#. type: Plain text
#: man-pages/man2/membarrier.2:121
msgid ""
"Register the process's intent to receive B<MEMBARRIER_CMD_GLOBAL_EXPEDITED> "
"memory barriers."
msgstr ""

#. type: TP
#: man-pages/man2/membarrier.2:121
#, no-wrap
msgid "B<MEMBARRIER_CMD_PRIVATE_EXPEDITED> (since Linux 4.14)"
msgstr ""

#. type: Plain text
#: man-pages/man2/membarrier.2:125
msgid ""
"Execute a memory barrier on each running thread belonging to the same "
"process as the calling thread."
msgstr ""

#. type: Plain text
#: man-pages/man2/membarrier.2:133
msgid ""
"Upon return from the system call, the calling thread has a guarantee that "
"all its running thread siblings have passed through a state where all memory"
" accesses to user-space addresses match program order between entry to and "
"return from the system call (non-running threads are de facto in such a "
"state).  This guarantee is provided only for threads in the same process as "
"the calling thread."
msgstr ""

#. type: Plain text
#: man-pages/man2/membarrier.2:139
msgid ""
"A process must register its intent to use the private expedited command "
"prior to using it."
msgstr ""

#. type: TP
#: man-pages/man2/membarrier.2:139
#, no-wrap
msgid "B<MEMBARRIER_CMD_REGISTER_PRIVATE_EXPEDITED> (since Linux 4.14)"
msgstr ""

#. type: Plain text
#: man-pages/man2/membarrier.2:143
msgid ""
"Register the process's intent to use B<MEMBARRIER_CMD_PRIVATE_EXPEDITED>."
msgstr ""

#. type: TP
#: man-pages/man2/membarrier.2:143
#, no-wrap
msgid "B<MEMBARRIER_CMD_PRIVATE_EXPEDITED_SYNC_CORE> (since Linux 4.16)"
msgstr ""

#. type: Plain text
#: man-pages/man2/membarrier.2:151
msgid ""
"In addition to providing the memory ordering guarantees described in "
"B<MEMBARRIER_CMD_PRIVATE_EXPEDITED>, upon return from system call the "
"calling thread has a guarantee that all its running thread siblings have "
"executed a core serializing instruction.  This guarantee is provided only "
"for threads in the same process as the calling thread."
msgstr ""

#. type: Plain text
#: man-pages/man2/membarrier.2:154
msgid ""
"The \"expedited\" commands complete faster than the non-expedited ones, they"
" never block, but have the downside of causing extra overhead."
msgstr ""

#. type: Plain text
#: man-pages/man2/membarrier.2:157
msgid ""
"A process must register its intent to use the private expedited sync core "
"command prior to using it."
msgstr ""

#. type: TP
#: man-pages/man2/membarrier.2:157
#, no-wrap
msgid ""
"B<MEMBARRIER_CMD_REGISTER_PRIVATE_EXPEDITED_SYNC_CORE> (since Linux 4.16)"
msgstr ""

#. type: Plain text
#: man-pages/man2/membarrier.2:161
msgid ""
"Register the process's intent to use "
"B<MEMBARRIER_CMD_PRIVATE_EXPEDITED_SYNC_CORE>."
msgstr ""

#. type: TP
#: man-pages/man2/membarrier.2:161
#, no-wrap
msgid "B<MEMBARRIER_CMD_SHARED> (since Linux 4.3)"
msgstr ""

#. type: Plain text
#: man-pages/man2/membarrier.2:166
msgid ""
"This is an alias for B<MEMBARRIER_CMD_GLOBAL> that exists for header "
"backward compatibility."
msgstr ""

#. type: Plain text
#: man-pages/man2/membarrier.2:170
msgid "The I<flags> argument is currently unused and must be specified as 0."
msgstr ""

#. type: Plain text
#: man-pages/man2/membarrier.2:174
msgid ""
"All memory accesses performed in program order from each targeted thread are"
" guaranteed to be ordered with respect to B<membarrier>()."
msgstr ""

#. type: Plain text
#: man-pages/man2/membarrier.2:188
msgid ""
"If we use the semantic I<barrier()> to represent a compiler barrier forcing "
"memory accesses to be performed in program order across the barrier, and "
"I<smp_mb()> to represent explicit memory barriers forcing full memory "
"ordering across the barrier, we have the following ordering table for each "
"pairing of I<barrier()>, B<membarrier>()  and I<smp_mb()>.  The pair "
"ordering is detailed as (O: ordered, X: not ordered):"
msgstr ""

#. type: Plain text
#: man-pages/man2/membarrier.2:193
#, no-wrap
msgid ""
"                       barrier()  smp_mb()  membarrier()\n"
"       barrier()          X          X          O\n"
"       smp_mb()           X          O          O\n"
"       membarrier()       O          O          O\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/membarrier.2:210
msgid ""
"On success, the B<MEMBARRIER_CMD_QUERY> operation returns a bit mask of "
"supported commands, and the B<MEMBARRIER_CMD_GLOBAL>, "
"B<MEMBARRIER_CMD_GLOBAL_EXPEDITED>, "
"B<MEMBARRIER_CMD_REGISTER_GLOBAL_EXPEDITED>, "
"B<MEMBARRIER_CMD_PRIVATE_EXPEDITED>, "
"B<MEMBARRIER_CMD_REGISTER_PRIVATE_EXPEDITED>, "
"B<MEMBARRIER_CMD_PRIVATE_EXPEDITED_SYNC_CORE>, and "
"B<MEMBARRIER_CMD_REGISTER_PRIVATE_EXPEDITED_SYNC_CORE> operations return "
"zero.  On error, -1 is returned, and I<errno> is set appropriately."
msgstr ""

#. type: Plain text
#: man-pages/man2/membarrier.2:220
msgid ""
"For a given command, with I<flags> set to 0, this system call is guaranteed "
"to always return the same value until reboot.  Further calls with the same "
"arguments will lead to the same result.  Therefore, with I<flags> set to 0, "
"error handling is required only for the first call to B<membarrier>()."
msgstr ""

#. type: Plain text
#: man-pages/man2/membarrier.2:235
msgid ""
"I<cmd> is invalid, or I<flags> is nonzero, or the B<MEMBARRIER_CMD_GLOBAL> "
"command is disabled because the I<nohz_full> CPU parameter has been set, or "
"the B<MEMBARRIER_CMD_PRIVATE_EXPEDITED_SYNC_CORE> and "
"B<MEMBARRIER_CMD_REGISTER_PRIVATE_EXPEDITED_SYNC_CORE> commands are not "
"implemented by the architecture."
msgstr ""

#. type: Plain text
#: man-pages/man2/membarrier.2:240
msgid "The B<membarrier>()  system call is not implemented by this kernel."
msgstr ""

#. type: Plain text
#: man-pages/man2/membarrier.2:244
msgid ""
"The current process was not registered prior to using private expedited "
"commands."
msgstr ""

#. type: Plain text
#: man-pages/man2/membarrier.2:249
msgid "The B<membarrier>()  system call was added in Linux 4.3."
msgstr ""

#.  .SH SEE ALSO
#.  FIXME See if the following syscalls make it into Linux 4.15 or later
#.  .BR cpu_opv (2),
#.  .BR rseq (2)
#. type: Plain text
#: man-pages/man2/membarrier.2:256
msgid "B<membarrier>()  is Linux-specific."
msgstr ""

#. type: Plain text
#: man-pages/man2/membarrier.2:265
msgid ""
"A memory barrier instruction is part of the instruction set of architectures"
" with weakly-ordered memory models.  It orders memory accesses prior to the "
"barrier and after the barrier with respect to matching barriers on other "
"cores.  For instance, a load fence can order loads prior to and following "
"that fence with respect to stores ordered by store fences."
msgstr ""

#. type: Plain text
#: man-pages/man2/membarrier.2:268
msgid ""
"Program order is the order in which instructions are ordered in the program "
"assembly code."
msgstr ""

#. type: Plain text
#: man-pages/man2/membarrier.2:273
msgid ""
"Examples where B<membarrier>()  can be useful include implementations of "
"Read-Copy-Update libraries and garbage collectors."
msgstr ""

#. type: Plain text
#: man-pages/man2/membarrier.2:278
msgid ""
"Assuming a multithreaded application where \"fast_path()\" is executed very "
"frequently, and where \"slow_path()\" is executed infrequently, the "
"following code (x86) can be transformed using B<membarrier>():"
msgstr ""

#. type: Plain text
#: man-pages/man2/membarrier.2:282
#, no-wrap
msgid "#include E<lt>stdlib.hE<gt>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/membarrier.2:284 man-pages/man2/membarrier.2:342
#, no-wrap
msgid "static volatile int a, b;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/membarrier.2:292
#, no-wrap
msgid ""
"static void\n"
"fast_path(int *read_b)\n"
"{\n"
"    a = 1;\n"
"    asm volatile (\"mfence\" : : : \"memory\");\n"
"    *read_b = b;\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/membarrier.2:300
#, no-wrap
msgid ""
"static void\n"
"slow_path(int *read_a)\n"
"{\n"
"    b = 1;\n"
"    asm volatile (\"mfence\" : : : \"memory\");\n"
"    *read_a = a;\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/membarrier.2:305 man-pages/man2/membarrier.2:391
#, no-wrap
msgid ""
"int\n"
"main(int argc, char **argv)\n"
"{\n"
"    int read_a, read_b;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/membarrier.2:311 man-pages/man2/membarrier.2:400
#, no-wrap
msgid ""
"    /*\n"
"     * Real applications would call fast_path() and slow_path()\n"
"     * from different threads. Call those from main() to keep\n"
"     * this example short.\n"
"     */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/membarrier.2:314 man-pages/man2/membarrier.2:403
#, no-wrap
msgid ""
"    slow_path(&read_a);\n"
"    fast_path(&read_b);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/membarrier.2:319 man-pages/man2/membarrier.2:408
#, no-wrap
msgid ""
"    /*\n"
"     * read_b == 0 implies read_a == 1 and\n"
"     * read_a == 0 implies read_b == 1.\n"
"     */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/membarrier.2:322 man-pages/man2/membarrier.2:411
#, no-wrap
msgid ""
"    if (read_b == 0 && read_a == 0)\n"
"        abort();\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/membarrier.2:331
msgid "The code above transformed to use B<membarrier>()  becomes:"
msgstr ""

#. type: Plain text
#: man-pages/man2/membarrier.2:340
#, no-wrap
msgid ""
"#define _GNU_SOURCE\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>sys/syscall.hE<gt>\n"
"#include E<lt>linux/membarrier.hE<gt>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/membarrier.2:348
#, no-wrap
msgid ""
"static int\n"
"membarrier(int cmd, int flags)\n"
"{\n"
"    return syscall(__NR_membarrier, cmd, flags);\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/membarrier.2:353
#, no-wrap
msgid ""
"static int\n"
"init_membarrier(void)\n"
"{\n"
"    int ret;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/membarrier.2:355
#, no-wrap
msgid "    /* Check that membarrier() is supported. */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/membarrier.2:361
#, no-wrap
msgid ""
"    ret = membarrier(MEMBARRIER_CMD_QUERY, 0);\n"
"    if (ret E<lt> 0) {\n"
"        perror(\"membarrier\");\n"
"        return -1;\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/membarrier.2:367
#, no-wrap
msgid ""
"    if (!(ret & MEMBARRIER_CMD_GLOBAL)) {\n"
"        fprintf(stderr,\n"
"            \"membarrier does not support MEMBARRIER_CMD_GLOBAL\\en\");\n"
"        return -1;\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/membarrier.2:370
#, no-wrap
msgid ""
"    return 0;\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/membarrier.2:378
#, no-wrap
msgid ""
"static void\n"
"fast_path(int *read_b)\n"
"{\n"
"    a = 1;\n"
"    asm volatile (\"\" : : : \"memory\");\n"
"    *read_b = b;\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/membarrier.2:386
#, no-wrap
msgid ""
"static void\n"
"slow_path(int *read_a)\n"
"{\n"
"    b = 1;\n"
"    membarrier(MEMBARRIER_CMD_GLOBAL, 0);\n"
"    *read_a = a;\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/membarrier.2:394
#, no-wrap
msgid ""
"    if (init_membarrier())\n"
"        exit(EXIT_FAILURE);\n"
msgstr ""

#. type: TH
#: man-pages/man2/mincore.2:34
#, no-wrap
msgid "MINCORE"
msgstr ""

#. type: Plain text
#: man-pages/man2/mincore.2:37
msgid "mincore - determine whether pages are resident in memory"
msgstr ""

#. type: Plain text
#: man-pages/man2/mincore.2:39
msgid "B<#include E<lt>unistd.hE<gt>>"
msgstr ""

#. type: Plain text
#: man-pages/man2/mincore.2:43
msgid ""
"B<int mincore(void *>I<addr>B<, size_t >I<length>B<, unsigned char "
"*>I<vec>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/mincore.2:54
#, no-wrap
msgid ""
"B<mincore>():\n"
"    Since glibc 2.19:\n"
"        _DEFAULT_SOURCE\n"
"    Glibc 2.19 and earlier:\n"
"        _BSD_SOURCE || _SVID_SOURCE\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/mincore.2:65
msgid ""
"B<mincore>()  returns a vector that indicates whether pages of the calling "
"process's virtual memory are resident in core (RAM), and so will not cause a"
" disk access (page fault) if referenced.  The kernel returns residency "
"information about the pages starting at the address I<addr>, and continuing "
"for I<length> bytes."
msgstr ""

#. type: Plain text
#: man-pages/man2/mincore.2:79
msgid ""
"The I<addr> argument must be a multiple of the system page size.  The "
"I<length> argument need not be a multiple of the page size, but since "
"residency information is returned for whole pages, I<length> is effectively "
"rounded up to the next multiple of the page size.  One may obtain the page "
"size (B<PAGE_SIZE>)  using I<sysconf(_SC_PAGESIZE)>."
msgstr ""

#. type: Plain text
#: man-pages/man2/mincore.2:97
msgid ""
"The I<vec> argument must point to an array containing at least "
"I<(length+PAGE_SIZE-1) / PAGE_SIZE> bytes.  On return, the least significant"
" bit of each byte will be set if the corresponding page is currently "
"resident in memory, and be clear otherwise.  (The settings of the other bits"
" in each byte are undefined; these bits are reserved for possible later "
"use.)  Of course the information returned in I<vec> is only a snapshot: "
"pages that are not locked in memory can come and go at any moment, and the "
"contents of I<vec> may already be stale by the time this call returns."
msgstr ""

#. type: Plain text
#: man-pages/man2/mincore.2:104
msgid ""
"On success, B<mincore>()  returns zero.  On error, -1 is returned, and "
"I<errno> is set appropriately."
msgstr ""

#. type: Plain text
#: man-pages/man2/mincore.2:107
msgid "B<EAGAIN> kernel is temporarily out of resources."
msgstr ""

#. type: Plain text
#: man-pages/man2/mincore.2:111
msgid "I<vec> points to an invalid address."
msgstr ""

#. type: Plain text
#: man-pages/man2/mincore.2:115
msgid "I<addr> is not a multiple of the page size."
msgstr ""

#. type: Plain text
#: man-pages/man2/mincore.2:127
msgid ""
"I<length> is greater than (I<TASK_SIZE> - I<addr>).  (This could occur if a "
"negative value is specified for I<length>, since that value will be "
"interpreted as a large unsigned integer.)  In Linux 2.6.11 and earlier, the "
"error B<EINVAL> was returned for this condition."
msgstr ""

#. type: Plain text
#: man-pages/man2/mincore.2:135
msgid "I<addr> to I<addr> + I<length> contained unmapped memory."
msgstr ""

#. type: Plain text
#: man-pages/man2/mincore.2:137
msgid "Available since Linux 2.3.99pre1 and glibc 2.2."
msgstr ""

#.  It is on at least NetBSD, FreeBSD, OpenBSD, Solaris 8,
#.  AIX 5.1, SunOS 4.1
#.  .SH HISTORY
#.  The
#.  .BR mincore ()
#.  function first appeared in 4.4BSD.
#. type: Plain text
#: man-pages/man2/mincore.2:147
msgid ""
"B<mincore>()  is not specified in POSIX.1, and it is not available on all "
"UNIX implementations."
msgstr ""

#.  Linux (up to now, 2.6.5),
#.  .B mincore
#.  does not return correct information for MAP_PRIVATE mappings:
#.  for a MAP_PRIVATE file mapping,
#.  .B mincore
#.  returns the residency of the file pages, rather than any
#.  modified process-private pages that have been copied on write;
#.  for a MAP_PRIVATE mapping of
#.  .IR /dev/zero ,
#.  .B mincore
#.  always reports pages as nonresident;
#.  and for a MAP_PRIVATE, MAP_ANONYMOUS mapping,
#.  .B mincore
#.  always fails with the error
#.  .BR ENOMEM .
#. type: Plain text
#: man-pages/man2/mincore.2:169
msgid ""
"Before kernel 2.6.21, B<mincore>()  did not return correct information for "
"B<MAP_PRIVATE> mappings, or for nonlinear mappings (established using "
"B<remap_file_pages>(2))."
msgstr ""

#. type: Plain text
#: man-pages/man2/mincore.2:175
msgid ""
"B<fincore>(1), B<madvise>(2), B<mlock>(2), B<mmap>(2), B<posix_fadvise>(2), "
"B<posix_madvise>(3)"
msgstr ""

#. type: TH
#: man-pages/man2/mprotect.2:33
#, no-wrap
msgid "MPROTECT"
msgstr ""

#. type: Plain text
#: man-pages/man2/mprotect.2:36
msgid "mprotect, pkey_mprotect - set protection on a region of memory"
msgstr ""

#. type: Plain text
#: man-pages/man2/mprotect.2:41
#, no-wrap
msgid "B<int mprotect(void *>I<addr>B<, size_t >I<len>B<, int >I<prot>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/mprotect.2:44
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>             /* See feature_test_macros(7) */\n"
"B<#include E<lt>sys/mman.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/mprotect.2:46
#, no-wrap
msgid ""
"B<int pkey_mprotect(void *>I<addr>B<, size_t >I<len>B<, int >I<prot>B<, int "
">I<pkey>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/mprotect.2:54
msgid ""
"B<mprotect>()  changes the access protections for the calling process's "
"memory pages containing any part of the address range in the interval "
"[I<addr>,\\ I<addr>+I<len>-1].  I<addr> must be aligned to a page boundary."
msgstr ""

#. type: Plain text
#: man-pages/man2/mprotect.2:59
msgid ""
"If the calling process tries to access memory in a manner that violates the "
"protections, then the kernel generates a B<SIGSEGV> signal for the process."
msgstr ""

#. type: Plain text
#: man-pages/man2/mprotect.2:64
msgid ""
"I<prot> is a combination of the following access flags: B<PROT_NONE> or a "
"bitwise-or of the other values in the following list:"
msgstr ""

#. type: Plain text
#: man-pages/man2/mprotect.2:67
msgid "The memory cannot be accessed at all."
msgstr ""

#. type: Plain text
#: man-pages/man2/mprotect.2:70
msgid "The memory can be read."
msgstr ""

#. type: Plain text
#: man-pages/man2/mprotect.2:73
msgid "The memory can be modified."
msgstr ""

#. type: Plain text
#: man-pages/man2/mprotect.2:76
msgid "The memory can be executed."
msgstr ""

#. type: TP
#: man-pages/man2/mprotect.2:76
#, no-wrap
msgid "B<PROT_SEM> (since Linux 2.5.7)"
msgstr ""

#. type: Plain text
#: man-pages/man2/mprotect.2:85
msgid ""
"The memory can be used for atomic operations.  This flag was introduced as "
"part of the B<futex>(2)  implementation (in order to guarantee the ability "
"to perform atomic operations required by commands such as B<FUTEX_WAIT>), "
"but is not currently used in on any architecture."
msgstr ""

#. type: TP
#: man-pages/man2/mprotect.2:85
#, no-wrap
msgid "B<PROT_SAO> (since Linux 2.6.26)"
msgstr ""

#.  commit aba46c5027cb59d98052231b36efcbbde9c77a1d
#.  commit ef3d3246a0d06be622867d21af25f997aeeb105f
#. type: Plain text
#: man-pages/man2/mprotect.2:94
msgid ""
"The memory should have strong access ordering.  This feature is specific to "
"the PowerPC architecture (version 2.06 of the architecture specification "
"adds the SAO CPU feature, and it is available on POWER 7 or PowerPC A2, for "
"example)."
msgstr ""

#. type: Plain text
#: man-pages/man2/mprotect.2:98
msgid ""
"Additionally (since Linux 2.6.0), I<prot> can have one of the following "
"flags set:"
msgstr ""

#.  mm/mmap.c:
#. 	vm_flags |= calc_vm_prot_bits(prot, pkey) | calc_vm_flag_bits(flags) |
#. 			mm->def_flags | VM_MAYREAD | VM_MAYWRITE | VM_MAYEXEC;
#.  And calc_vm_flag_bits converts only GROWSDOWN/DENYWRITE/LOCKED.
#. type: TP
#: man-pages/man2/mprotect.2:98
#, no-wrap
msgid "B<PROT_GROWSUP>"
msgstr ""

#.  The VMA is one that was marked with VM_GROWSUP by the kernel
#.  when the stack was created. Note that (unlike VM_GROWSDOWN),
#.  there is no mmap() flag (analogous to MAP_GROWSDOWN) for
#.  creating a VMA that is marked VM_GROWSUP.
#. type: Plain text
#: man-pages/man2/mprotect.2:113
msgid ""
"Apply the protection mode up to the end of a mapping that grows upwards.  "
"(Such mappings are created for the stack area on architectures\\(emfor "
"example, HP-PARISC\\(emthat have an upwardly growing stack.)"
msgstr ""

#. type: TP
#: man-pages/man2/mprotect.2:113
#, no-wrap
msgid "B<PROT_GROWSDOWN>"
msgstr ""

#. type: Plain text
#: man-pages/man2/mprotect.2:120
msgid ""
"Apply the protection mode down to the beginning of a mapping that grows "
"downward (which should be a stack segment or a segment mapped with the "
"B<MAP_GROWSDOWN> flag set)."
msgstr ""

#. type: Plain text
#: man-pages/man2/mprotect.2:139
msgid ""
"Like B<mprotect>(), B<pkey_mprotect>()  changes the protection on the pages "
"specified by I<addr> and I<len>.  The I<pkey> argument specifies the "
"protection key (see B<pkeys>(7))  to assign to the memory.  The protection "
"key must be allocated with B<pkey_alloc>(2)  before it is passed to "
"B<pkey_mprotect>().  For an example of the use of this system call, see "
"B<pkeys>(7)."
msgstr ""

#. type: Plain text
#: man-pages/man2/mprotect.2:148
msgid ""
"On success, B<mprotect>()  and B<pkey_mprotect>()  return zero.  On error, "
"these system calls return -1, and I<errno> is set appropriately."
msgstr ""

#. type: Plain text
#: man-pages/man2/mprotect.2:158
msgid ""
"The memory cannot be given the specified access.  This can happen, for "
"example, if you B<mmap>(2)  a file to which you have read-only access, then "
"ask B<mprotect>()  to mark it B<PROT_WRITE>."
msgstr ""

#. type: Plain text
#: man-pages/man2/mprotect.2:162
msgid ""
"I<addr> is not a valid pointer, or not a multiple of the system page size."
msgstr ""

#. type: Plain text
#: man-pages/man2/mprotect.2:167
msgid ""
"(B<pkey_mprotect>())  I<pkey> has not been allocated with B<pkey_alloc>(2)"
msgstr ""

#. type: Plain text
#: man-pages/man2/mprotect.2:175
msgid "Both B<PROT_GROWSUP> and B<PROT_GROWSDOWN> were specified in I<prot>."
msgstr ""

#. type: Plain text
#: man-pages/man2/mprotect.2:179
msgid "Invalid flags specified in I<prot>."
msgstr ""

#. type: Plain text
#: man-pages/man2/mprotect.2:186
msgid ""
"(PowerPC architecture)  B<PROT_SAO> was specified in I<prot>, but SAO "
"hardware feature is not available."
msgstr ""

#. type: Plain text
#: man-pages/man2/mprotect.2:189
msgid "Internal kernel structures could not be allocated."
msgstr ""

#. type: Plain text
#: man-pages/man2/mprotect.2:199
msgid ""
"Addresses in the range [I<addr>, I<addr>+I<len>-1] are invalid for the "
"address space of the process, or specify one or more pages that are not "
"mapped.  (Before kernel 2.4.19, the error B<EFAULT> was incorrectly produced"
" for these cases.)"
msgstr ""

#.  I.e., the number of VMAs would exceed the 64 kB maximum
#. type: Plain text
#: man-pages/man2/mprotect.2:211
msgid ""
"Changing the protection of a memory region would result in the total number "
"of mappings with distinct attributes (e.g., read versus read/write "
"protection)  exceeding the allowed maximum.  (For example, making the "
"protection of a range B<PROT_READ> in the middle of a region currently "
"protected as B<PROT_READ|PROT_WRITE> would result in three mappings: two "
"read/write mappings at each end and a read-only mapping in the middle.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/mprotect.2:215
msgid ""
"B<pkey_mprotect>()  first appeared in Linux 4.9; library support was added "
"in glibc 2.27."
msgstr ""

#.  SVr4 defines an additional error
#.  code EAGAIN. The SVr4 error conditions don't map neatly onto Linux's.
#. type: Plain text
#: man-pages/man2/mprotect.2:225
msgid ""
"B<mprotect>(): POSIX.1-2001, POSIX.1-2008, SVr4.  POSIX says that the "
"behavior of B<mprotect>()  is unspecified if it is applied to a region of "
"memory that was not obtained via B<mmap>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/mprotect.2:228
msgid "B<pkey_mprotect>()  is a nonportable Linux extension."
msgstr ""

#. type: Plain text
#: man-pages/man2/mprotect.2:235
msgid ""
"On Linux, it is always permissible to call B<mprotect>()  on any address in "
"a process's address space (except for the kernel vsyscall area).  In "
"particular, it can be used to change existing code mappings to be writable."
msgstr ""

#. type: Plain text
#: man-pages/man2/mprotect.2:249
msgid ""
"Whether B<PROT_EXEC> has any effect different from B<PROT_READ> depends on "
"processor architecture, kernel version, and process state.  If "
"B<READ_IMPLIES_EXEC> is set in the process's personality flags (see "
"B<personality>(2)), specifying B<PROT_READ> will implicitly add "
"B<PROT_EXEC>."
msgstr ""

#. type: Plain text
#: man-pages/man2/mprotect.2:254
msgid ""
"On some hardware architectures (e.g., i386), B<PROT_WRITE> implies "
"B<PROT_READ>."
msgstr ""

#. type: Plain text
#: man-pages/man2/mprotect.2:263
msgid ""
"POSIX.1 says that an implementation may permit access other than that "
"specified in I<prot>, but at a minimum can allow write access only if "
"B<PROT_WRITE> has been set, and must not allow any access if B<PROT_NONE> "
"has been set."
msgstr ""

#. type: Plain text
#: man-pages/man2/mprotect.2:276
msgid ""
"Applications should be careful when mixing use of B<mprotect>()  and "
"B<pkey_mprotect>().  On x86, when B<mprotect>()  is used with I<prot> set to"
" B<PROT_EXEC> a pkey may be allocated and set on the memory implicitly by "
"the kernel, but only when the pkey was 0 previously."
msgstr ""

#. type: Plain text
#: man-pages/man2/mprotect.2:286
msgid ""
"On systems that do not support protection keys in hardware, "
"B<pkey_mprotect>()  may still be used, but I<pkey> must be set to -1.  When "
"called this way, the operation of B<pkey_mprotect>()  is equivalent to "
"B<mprotect>()."
msgstr ""

#. type: Plain text
#: man-pages/man2/mprotect.2:294
msgid ""
"The program below demonstrates the use of B<mprotect>().  The program "
"allocates four pages of memory, makes the third of these pages read-only, "
"and then executes a loop that walks upward through the allocated region "
"modifying bytes."
msgstr ""

#. type: Plain text
#: man-pages/man2/mprotect.2:297
msgid ""
"An example of what we might see when running the program is the following:"
msgstr ""

#. type: Plain text
#: man-pages/man2/mprotect.2:303
#, no-wrap
msgid ""
"$B< ./a.out>\n"
"Start of region:        0x804c000\n"
"Got SIGSEGV at address: 0x804e000\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/mprotect.2:315
#, no-wrap
msgid ""
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>signal.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>malloc.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"
"#include E<lt>sys/mman.hE<gt>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/mprotect.2:320
#, no-wrap
msgid "static char *buffer;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/mprotect.2:329
#, no-wrap
msgid ""
"static void\n"
"handler(int sig, siginfo_t *si, void *unused)\n"
"{\n"
"    /* Note: calling printf() from a signal handler is not safe\n"
"       (and should not be done in production programs), since\n"
"       printf() is not async-signal-safe; see signal-safety(7).\n"
"       Nevertheless, we use printf() here as a simple way of\n"
"       showing that the handler was called. */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/mprotect.2:334
#, no-wrap
msgid ""
"    printf(\"Got SIGSEGV at address: 0x%lx\\en\",\n"
"            (long) si-E<gt>si_addr);\n"
"    exit(EXIT_FAILURE);\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/mprotect.2:341
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    char *p;\n"
"    int pagesize;\n"
"    struct sigaction sa;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/mprotect.2:347
#, no-wrap
msgid ""
"    sa.sa_flags = SA_SIGINFO;\n"
"    sigemptyset(&sa.sa_mask);\n"
"    sa.sa_sigaction = handler;\n"
"    if (sigaction(SIGSEGV, &sa, NULL) == -1)\n"
"        handle_error(\"sigaction\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/mprotect.2:351
#, no-wrap
msgid ""
"    pagesize = sysconf(_SC_PAGE_SIZE);\n"
"    if (pagesize == -1)\n"
"        handle_error(\"sysconf\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/mprotect.2:354
#, no-wrap
msgid ""
"    /* Allocate a buffer aligned on a page boundary;\n"
"       initial protection is PROT_READ | PROT_WRITE */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/mprotect.2:358
#, no-wrap
msgid ""
"    buffer = memalign(pagesize, 4 * pagesize);\n"
"    if (buffer == NULL)\n"
"        handle_error(\"memalign\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/mprotect.2:360
#, no-wrap
msgid "    printf(\"Start of region:        0x%lx\\en\", (long) buffer);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/mprotect.2:364
#, no-wrap
msgid ""
"    if (mprotect(buffer + pagesize * 2, pagesize,\n"
"                PROT_READ) == -1)\n"
"        handle_error(\"mprotect\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/mprotect.2:367
#, no-wrap
msgid ""
"    for (p = buffer ; ; )\n"
"        *(p++) = \\(aqa\\(aq;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/mprotect.2:371
#, no-wrap
msgid ""
"    printf(\"Loop completed\\en\");     /* Should never happen */\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/mprotect.2:375
msgid "B<mmap>(2), B<sysconf>(3), B<pkeys>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/msync.2:25
#, no-wrap
msgid "MSYNC"
msgstr ""

#. type: Plain text
#: man-pages/man2/msync.2:28
msgid "msync - synchronize a file with a memory map"
msgstr ""

#. type: Plain text
#: man-pages/man2/msync.2:32
msgid "B<int msync(void *>I<addr>B<, size_t >I<length>B<, int >I<flags>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/msync.2:48
msgid ""
"B<msync>()  flushes changes made to the in-core copy of a file that was "
"mapped into memory using B<mmap>(2)  back to the filesystem.  Without use of"
" this call, there is no guarantee that changes are written back before "
"B<munmap>(2)  is called.  To be more precise, the part of the file that "
"corresponds to the memory area starting at I<addr> and having length "
"I<length> is updated."
msgstr ""

#. type: Plain text
#: man-pages/man2/msync.2:59
msgid ""
"The I<flags> argument should specify exactly one of B<MS_ASYNC> and "
"B<MS_SYNC>, and may additionally include the B<MS_INVALIDATE> bit.  These "
"bits have the following meanings:"
msgstr ""

#. type: TP
#: man-pages/man2/msync.2:59
#, no-wrap
msgid "B<MS_ASYNC>"
msgstr ""

#. type: Plain text
#: man-pages/man2/msync.2:62
msgid ""
"Specifies that an update be scheduled, but the call returns immediately."
msgstr ""

#. type: TP
#: man-pages/man2/msync.2:62
#, no-wrap
msgid "B<MS_SYNC>"
msgstr ""

#. type: Plain text
#: man-pages/man2/msync.2:65
msgid "Requests an update and waits for it to complete."
msgstr ""

#. type: TP
#: man-pages/man2/msync.2:65
#, no-wrap
msgid "B<MS_INVALIDATE>"
msgstr ""

#.  Since Linux 2.4, this seems to be a no-op (other than the
#.  EBUSY check for VM_LOCKED).
#. type: Plain text
#: man-pages/man2/msync.2:71
msgid ""
"Asks to invalidate other mappings of the same file (so that they can be "
"updated with the fresh values just written)."
msgstr ""

#. type: Plain text
#: man-pages/man2/msync.2:83
msgid ""
"B<MS_INVALIDATE> was specified in I<flags>, and a memory lock exists for the"
" specified address range."
msgstr ""

#. type: Plain text
#: man-pages/man2/msync.2:96
msgid ""
"I<addr> is not a multiple of PAGESIZE; or any bit other than B<MS_ASYNC> | "
"B<MS_INVALIDATE> | B<MS_SYNC> is set in I<flags>; or both B<MS_SYNC> and "
"B<MS_ASYNC> are set in I<flags>."
msgstr ""

#. type: Plain text
#: man-pages/man2/msync.2:99
msgid "The indicated memory (or part of it) was not mapped."
msgstr ""

#. type: Plain text
#: man-pages/man2/msync.2:101
msgid "POSIX.1-2001, POSIX.1-2008."
msgstr ""

#. type: Plain text
#: man-pages/man2/msync.2:108
msgid ""
"This call was introduced in Linux 1.3.21, and then used B<EFAULT> instead of"
" B<ENOMEM>.  In Linux 2.4.19, this was changed to the POSIX value B<ENOMEM>."
msgstr ""

#.  POSIX.1-2001: It shall be defined to -1 or 0 or 200112L.
#.  -1: unavailable, 0: ask using sysconf().
#.  glibc defines them to 1.
#. type: Plain text
#: man-pages/man2/msync.2:123
msgid ""
"On POSIX systems on which B<msync>()  is available, both "
"B<_POSIX_MAPPED_FILES> and B<_POSIX_SYNCHRONIZED_IO> are defined in "
"I<E<lt>unistd.hE<gt>> to a value greater than 0.  (See also B<sysconf>(3).)"
msgstr ""

#.  commit 204ec841fbea3e5138168edbc3a76d46747cc987
#. type: Plain text
#: man-pages/man2/msync.2:150
msgid ""
"According to POSIX, either B<MS_SYNC> or B<MS_ASYNC> must be specified in "
"I<flags>, and indeed failure to include one of these flags will cause "
"B<msync>()  to fail on some systems.  However, Linux permits a call to "
"B<msync>()  that specifies neither of these flags, with semantics that are "
"(currently) equivalent to specifying B<MS_ASYNC>.  (Since Linux 2.6.19, "
"B<MS_ASYNC> is in fact a no-op, since the kernel properly tracks dirty pages"
" and flushes them to storage as necessary.)  Notwithstanding the Linux "
"behavior, portable, future-proof applications should ensure that they "
"specify either B<MS_SYNC> or B<MS_ASYNC> in I<flags>."
msgstr ""

#. type: Plain text
#: man-pages/man2/msync.2:152
msgid "B<mmap>(2)"
msgstr ""

#. type: TH
#: man-pages/man2/migrate_pages.2:18
#, no-wrap
msgid "MIGRATE_PAGES"
msgstr ""

#. type: Plain text
#: man-pages/man2/migrate_pages.2:21
msgid "migrate_pages - move all pages in a process to another set of nodes"
msgstr ""

#. type: Plain text
#: man-pages/man2/migrate_pages.2:28
#, no-wrap
msgid ""
"B<long migrate_pages(int >I<pid>B<, unsigned long >I<maxnode,>\n"
"B<                   const unsigned long *>I<old_nodes,>\n"
"B<                   const unsigned long *>I<new_nodes>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/migrate_pages.2:47
msgid ""
"B<migrate_pages>()  attempts to move all pages of the process I<pid> that "
"are in memory nodes I<old_nodes> to the memory nodes in I<new_nodes>.  Pages"
" not located in any node in I<old_nodes> will not be migrated.  As far as "
"possible, the kernel maintains the relative topology relationship inside "
"I<old_nodes> during the migration to I<new_nodes>."
msgstr ""

#. type: Plain text
#: man-pages/man2/migrate_pages.2:69
msgid ""
"The I<old_nodes> and I<new_nodes> arguments are pointers to bit masks of "
"node numbers, with up to I<maxnode> bits in each mask.  These masks are "
"maintained as arrays of unsigned I<long> integers (in the last I<long> "
"integer, the bits beyond those specified by I<maxnode> are ignored).  The "
"I<maxnode> argument is the maximum node number in the bit mask plus one "
"(this is the same as in B<mbind>(2), but different from B<select>(2))."
msgstr ""

#. type: Plain text
#: man-pages/man2/migrate_pages.2:83
msgid ""
"The I<pid> argument is the ID of the process whose pages are to be moved.  "
"To move pages in another process, the caller must be privileged "
"(B<CAP_SYS_NICE>)  or the real or effective user ID of the calling process "
"must match the real or saved-set user ID of the target process.  If I<pid> "
"is 0, then B<migrate_pages>()  moves pages of the calling process."
msgstr ""

#. type: Plain text
#: man-pages/man2/migrate_pages.2:88
msgid ""
"Pages shared with another process will be moved only if the initiating "
"process has the B<CAP_SYS_NICE> privilege."
msgstr ""

#. type: Plain text
#: man-pages/man2/migrate_pages.2:96
msgid ""
"On success B<migrate_pages>()  returns the number of pages that could not be"
" moved (i.e., a return of zero means that all pages were successfully "
"moved).  On error, it returns -1, and sets I<errno> to indicate the error."
msgstr ""

#. type: Plain text
#: man-pages/man2/migrate_pages.2:104
msgid ""
"Part or all of the memory range specified by I<old_nodes>/I<new_nodes> and "
"I<maxnode> points outside your accessible address space."
msgstr ""

#.  As at 3.5, this limit is "a page worth of bits", e.g.,
#.  8 * 4096 bits, assuming a 4kB page size.
#. type: Plain text
#: man-pages/man2/migrate_pages.2:121
msgid ""
"The value specified by I<maxnode> exceeds a kernel-imposed limit.  Or, "
"I<old_nodes> or I<new_nodes> specifies one or more node IDs that are greater"
" than the maximum supported node ID.  Or, none of the node IDs specified by "
"I<new_nodes> are on-line and allowed by the process's current cpuset "
"context, or none of the specified nodes contain memory."
msgstr ""

#. type: Plain text
#: man-pages/man2/migrate_pages.2:130
msgid ""
"Insufficient privilege (B<CAP_SYS_NICE>)  to move pages of the process "
"specified by I<pid>, or insufficient privilege (B<CAP_SYS_NICE>)  to access "
"the specified target nodes."
msgstr ""

#.  FIXME Document the other errors that can occur for migrate_pages()
#. type: Plain text
#: man-pages/man2/migrate_pages.2:136
msgid "No process matching I<pid> could be found."
msgstr ""

#. type: Plain text
#: man-pages/man2/migrate_pages.2:140
msgid ""
"The B<migrate_pages>()  system call first appeared on Linux in version "
"2.6.16."
msgstr ""

#. type: Plain text
#: man-pages/man2/migrate_pages.2:154
msgid ""
"Use B<get_mempolicy>(2)  with the B<MPOL_F_MEMS_ALLOWED> flag to obtain the "
"set of nodes that are allowed by the calling process's cpuset.  Note that "
"this information is subject to change at any time by manual or automatic "
"reconfiguration of the cpuset."
msgstr ""

#. type: Plain text
#: man-pages/man2/migrate_pages.2:166
msgid ""
"Use of B<migrate_pages>()  may result in pages whose location (node) "
"violates the memory policy established for the specified addresses (see "
"B<mbind>(2))  and/or the specified process (see B<set_mempolicy>(2)).  That "
"is, memory policy does not constrain the destination nodes used by "
"B<migrate_pages>()."
msgstr ""

#. type: Plain text
#: man-pages/man2/migrate_pages.2:184
msgid "I<Documentation/vm/page_migration.rst> in the Linux kernel source tree"
msgstr ""

#. type: TH
#: man-pages/man2/mmap2.2:29
#, no-wrap
msgid "MMAP2"
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap2.2:32
msgid "mmap2 - map files or devices into memory"
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap2.2:38
#, no-wrap
msgid ""
"B<void *mmap2(void *>I<addr>B<, size_t >I<length>B<, int >I<prot>B<,>\n"
"B<             int >I<flags>B<, int >I<fd>B<, off_t >I<pgoffset>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap2.2:43
msgid ""
"This is probably not the system call that you are interested in; instead, "
"see B<mmap>(2), which describes the glibc wrapper function that invokes this"
" system call."
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap2.2:54
msgid ""
"The B<mmap2>()  system call provides the same interface as B<mmap>(2), "
"except that the final argument specifies the offset into the file in "
"4096-byte units (instead of bytes, as is done by B<mmap>(2)).  This enables "
"applications that use a 32-bit I<off_t> to map large files (up to 2^44 "
"bytes)."
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap2.2:61
msgid ""
"On success, B<mmap2>()  returns a pointer to the mapped area.  On error, -1 "
"is returned and I<errno> is set appropriately."
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap2.2:65
msgid "Problem with getting the data from user space."
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap2.2:70
msgid ""
"(Various platforms where the page size is not 4096 bytes.)  I<offset\\ *\\ "
"4096> is not a multiple of the system page size."
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap2.2:74
msgid "B<mmap2>()  can also return any of the errors described in B<mmap>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap2.2:77
msgid "B<mmap2>()  is available since Linux 2.3.31."
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap2.2:86
msgid ""
"On architectures where this system call is present, the glibc B<mmap>()  "
"wrapper function invokes this system call rather than the B<mmap>(2)  system"
" call."
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap2.2:88
msgid "This system call does not exist on x86-64."
msgstr ""

#.  ia64 can have page sizes ranging from 4 kB to 64 kB.
#.  On cris, it looks like the unit might also be the page size,
#.  which is 8192 bytes. -- mtk, June 2007
#. type: Plain text
#: man-pages/man2/mmap2.2:95
msgid ""
"On ia64, the unit for I<offset> is actually the system page size, rather "
"than 4096 bytes."
msgstr ""

#. type: Plain text
#: man-pages/man2/mmap2.2:100
msgid ""
"B<getpagesize>(2), B<mmap>(2), B<mremap>(2), B<msync>(2), B<shm_open>(3)"
msgstr ""

#. type: TH
#: man-pages/man2/mlock.2:26
#, no-wrap
msgid "MLOCK"
msgstr ""

#. type: TH
#: man-pages/man2/mlock.2:26
#, no-wrap
msgid "2018-02-02"
msgstr ""

#. type: Plain text
#: man-pages/man2/mlock.2:29
msgid "mlock, mlock2, munlock, mlockall, munlockall - lock and unlock memory"
msgstr ""

#. type: Plain text
#: man-pages/man2/mlock.2:36
#, no-wrap
msgid ""
"B<int mlock(const void *>I<addr>B<, size_t >I<len>B<);>\n"
"B<int mlock2(const void *>I<addr>B<, size_t >I<len>B<, int >I<flags>B<);>\n"
"B<int munlock(const void *>I<addr>B<, size_t >I<len>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/mlock.2:39
#, no-wrap
msgid ""
"B<int mlockall(int >I<flags>B<);>\n"
"B<int munlockall(void);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/mlock.2:48
msgid ""
"B<mlock>(), B<mlock2>(), and B<mlockall>()  lock part or all of the calling "
"process's virtual address space into RAM, preventing that memory from being "
"paged to the swap area."
msgstr ""

#. type: Plain text
#: man-pages/man2/mlock.2:56
msgid ""
"B<munlock>()  and B<munlockall>()  perform the converse operation, unlocking"
" part or all of the calling process's virtual address space, so that pages "
"in the specified virtual address range may once more to be swapped out if "
"required by the kernel memory manager."
msgstr ""

#. type: Plain text
#: man-pages/man2/mlock.2:58
msgid "Memory locking and unlocking are performed in units of whole pages."
msgstr ""

#. type: SS
#: man-pages/man2/mlock.2:58
#, no-wrap
msgid "mlock(), mlock2(), and munlock()"
msgstr ""

#. type: Plain text
#: man-pages/man2/mlock.2:68
msgid ""
"B<mlock>()  locks pages in the address range starting at I<addr> and "
"continuing for I<len> bytes.  All pages that contain a part of the specified"
" address range are guaranteed to be resident in RAM when the call returns "
"successfully; the pages are guaranteed to stay in RAM until later unlocked."
msgstr ""

#.  commit a8ca5d0ecbdde5cc3d7accacbd69968b0c98764e
#.  commit de60f5f10c58d4f34b68622442c0e04180367f3f
#.  commit b0f205c2a3082dd9081f9a94e50658c5fa906ff1
#. type: Plain text
#: man-pages/man2/mlock.2:82
msgid ""
"B<mlock2>()  also locks pages in the specified range starting at I<addr> and"
" continuing for I<len> bytes.  However, the state of the pages contained in "
"that range after the call returns successfully will depend on the value in "
"the I<flags> argument."
msgstr ""

#. type: Plain text
#: man-pages/man2/mlock.2:86
msgid "The I<flags> argument can be either 0 or the following constant:"
msgstr ""

#. type: TP
#: man-pages/man2/mlock.2:86
#, no-wrap
msgid "B<MLOCK_ONFAULT>"
msgstr ""

#. type: Plain text
#: man-pages/man2/mlock.2:91
msgid ""
"Lock pages that are currently resident and mark the entire range so that the"
" remaining nonresident pages are locked when they are populated by a page "
"fault."
msgstr ""

#. type: Plain text
#: man-pages/man2/mlock.2:99
msgid "If I<flags> is 0, B<mlock2>()  behaves exactly the same as B<mlock>()."
msgstr ""

#. type: Plain text
#: man-pages/man2/mlock.2:108
msgid ""
"B<munlock>()  unlocks pages in the address range starting at I<addr> and "
"continuing for I<len> bytes.  After this call, all pages that contain a part"
" of the specified memory range can be moved to external swap space again by "
"the kernel."
msgstr ""

#. type: SS
#: man-pages/man2/mlock.2:108
#, no-wrap
msgid "mlockall() and munlockall()"
msgstr ""

#. type: Plain text
#: man-pages/man2/mlock.2:118
msgid ""
"B<mlockall>()  locks all pages mapped into the address space of the calling "
"process.  This includes the pages of the code, data and stack segment, as "
"well as shared libraries, user space kernel data, shared memory, and memory-"
"mapped files.  All mapped pages are guaranteed to be resident in RAM when "
"the call returns successfully; the pages are guaranteed to stay in RAM until"
" later unlocked."
msgstr ""

#. type: Plain text
#: man-pages/man2/mlock.2:123
msgid ""
"The I<flags> argument is constructed as the bitwise OR of one or more of the"
" following constants:"
msgstr ""

#. type: TP
#: man-pages/man2/mlock.2:123
#, no-wrap
msgid "B<MCL_CURRENT>"
msgstr ""

#. type: Plain text
#: man-pages/man2/mlock.2:127
msgid ""
"Lock all pages which are currently mapped into the address space of the "
"process."
msgstr ""

#. type: TP
#: man-pages/man2/mlock.2:127
#, no-wrap
msgid "B<MCL_FUTURE>"
msgstr ""

#. type: Plain text
#: man-pages/man2/mlock.2:134
msgid ""
"Lock all pages which will become mapped into the address space of the "
"process in the future.  These could be, for instance, new pages required by "
"a growing heap and stack as well as new memory-mapped files or shared memory"
" regions."
msgstr ""

#. type: TP
#: man-pages/man2/mlock.2:134
#, no-wrap
msgid "B<MCL_ONFAULT> (since Linux 4.4)"
msgstr ""

#. type: Plain text
#: man-pages/man2/mlock.2:161
msgid ""
"Used together with B<MCL_CURRENT>, B<MCL_FUTURE>, or both.  Mark all current"
" (with B<MCL_CURRENT>)  or future (with B<MCL_FUTURE>)  mappings to lock "
"pages when they are faulted in.  When used with B<MCL_CURRENT>, all present "
"pages are locked, but B<mlockall>()  will not fault in non-present pages.  "
"When used with B<MCL_FUTURE>, all future mappings will be marked to lock "
"pages when they are faulted in, but they will not be populated by the lock "
"when the mapping is created.  B<MCL_ONFAULT> must be used with either "
"B<MCL_CURRENT> or B<MCL_FUTURE> or both."
msgstr ""

#. type: Plain text
#: man-pages/man2/mlock.2:174
msgid ""
"If B<MCL_FUTURE> has been specified, then a later system call (e.g., "
"B<mmap>(2), B<sbrk>(2), B<malloc>(3)), may fail if it would cause the number"
" of locked bytes to exceed the permitted maximum (see below).  In the same "
"circumstances, stack growth may likewise fail: the kernel will deny stack "
"expansion and deliver a B<SIGSEGV> signal to the process."
msgstr ""

#. type: Plain text
#: man-pages/man2/mlock.2:178
msgid ""
"B<munlockall>()  unlocks all pages mapped into the address space of the "
"calling process."
msgstr ""

#. type: Plain text
#: man-pages/man2/mlock.2:184
msgid ""
"On success, these system calls return 0.  On error, -1 is returned, I<errno>"
" is set appropriately, and no changes are made to any locks in the address "
"space of the process."
msgstr ""

#. type: Plain text
#: man-pages/man2/mlock.2:193
msgid ""
"(Linux 2.6.9 and later) the caller had a nonzero B<RLIMIT_MEMLOCK> soft "
"resource limit, but tried to lock more memory than the limit permitted.  "
"This limit is not enforced if the process is privileged (B<CAP_IPC_LOCK>)."
msgstr ""

#.  In the case of mlock(), this check is somewhat buggy: it doesn't
#.  take into account whether the to-be-locked range overlaps with
#.  already locked pages.  Thus, suppose we allocate
#.  (num_physpages / 4 + 1) of memory, and lock those pages once using
#.  mlock(), and then lock the *same* page range a second time.
#.  In the case, the second mlock() call will fail, since the check
#.  calculates that the process is trying to lock (num_physpages / 2 + 2)
#.  pages, which of course is not true.  (MTK, Nov 04, kernel 2.4.28)
#. type: Plain text
#: man-pages/man2/mlock.2:205
msgid ""
"(Linux 2.4 and earlier) the calling process tried to lock more than half of "
"RAM."
msgstr ""

#. SVr4 documents an additional EAGAIN error code.
#. type: Plain text
#: man-pages/man2/mlock.2:211
msgid ""
"The caller is not privileged, but needs privilege (B<CAP_IPC_LOCK>)  to "
"perform the requested operation."
msgstr ""

#. type: Plain text
#: man-pages/man2/mlock.2:217
msgid "For B<mlock>(), B<mlock2>(), and B<munlock>():"
msgstr ""

#. type: Plain text
#: man-pages/man2/mlock.2:220
msgid "Some or all of the specified address range could not be locked."
msgstr ""

#. type: Plain text
#: man-pages/man2/mlock.2:227
msgid ""
"The result of the addition I<addr>+I<len> was less than I<addr> (e.g., the "
"addition may have resulted in an overflow)."
msgstr ""

#. type: Plain text
#: man-pages/man2/mlock.2:232
msgid "(Not on Linux)  I<addr> was not a multiple of the page size."
msgstr ""

#. type: Plain text
#: man-pages/man2/mlock.2:236
msgid ""
"Some of the specified address range does not correspond to mapped pages in "
"the address space of the process."
msgstr ""

#.  I.e., the number of VMAs would exceed the 64kB maximum
#. type: Plain text
#: man-pages/man2/mlock.2:245
msgid ""
"Locking or unlocking a region would result in the total number of mappings "
"with distinct attributes (e.g., locked versus unlocked)  exceeding the "
"allowed maximum.  (For example, unlocking a range in the middle of a "
"currently locked mapping would result in three mappings: two locked mappings"
" at each end and an unlocked mapping in the middle.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/mlock.2:248
msgid "For B<mlock2>():"
msgstr ""

#. type: Plain text
#: man-pages/man2/mlock.2:251
msgid "Unknown I<flags> were specified."
msgstr ""

#. type: Plain text
#: man-pages/man2/mlock.2:254
msgid "For B<mlockall>():"
msgstr ""

#. type: Plain text
#: man-pages/man2/mlock.2:262
msgid ""
"Unknown I<flags> were specified or B<MCL_ONFAULT> was specified without "
"either B<MCL_FUTURE> or B<MCL_CURRENT>."
msgstr ""

#. type: Plain text
#: man-pages/man2/mlock.2:265
msgid "For B<munlockall>():"
msgstr ""

#. type: Plain text
#: man-pages/man2/mlock.2:269
msgid ""
"(Linux 2.6.8 and earlier) The caller was not privileged (B<CAP_IPC_LOCK>)."
msgstr ""

#. type: Plain text
#: man-pages/man2/mlock.2:273
msgid ""
"B<mlock2>()  is available since Linux 4.4; glibc support was added in "
"version 2.27."
msgstr ""

#. type: Plain text
#: man-pages/man2/mlock.2:278
msgid "mlock2 ()  is Linux specific."
msgstr ""

#. type: Plain text
#: man-pages/man2/mlock.2:290
msgid ""
"On POSIX systems on which B<mlock>()  and B<munlock>()  are available, "
"B<_POSIX_MEMLOCK_RANGE> is defined in I<E<lt>unistd.hE<gt>> and the number "
"of bytes in a page can be determined from the constant B<PAGESIZE> (if "
"defined) in I<E<lt>limits.hE<gt>> or by calling I<sysconf(_SC_PAGESIZE)>."
msgstr ""

#.  POSIX.1-2001: It shall be defined to -1 or 0 or 200112L.
#.  -1: unavailable, 0: ask using sysconf().
#.  glibc defines it to 1.
#. type: Plain text
#: man-pages/man2/mlock.2:303
msgid ""
"On POSIX systems on which B<mlockall>()  and B<munlockall>()  are available,"
" B<_POSIX_MEMLOCK> is defined in I<E<lt>unistd.hE<gt>> to a value greater "
"than 0.  (See also B<sysconf>(3).)"
msgstr ""

#. type: Plain text
#: man-pages/man2/mlock.2:321
msgid ""
"Memory locking has two main applications: real-time algorithms and high-"
"security data processing.  Real-time applications require deterministic "
"timing, and, like scheduling, paging is one major cause of unexpected "
"program execution delays.  Real-time applications will usually also switch "
"to a real-time scheduler with B<sched_setscheduler>(2).  Cryptographic "
"security software often handles critical bytes like passwords or secret keys"
" as data structures.  As a result of paging, these secrets could be "
"transferred onto a persistent swap store medium, where they might be "
"accessible to the enemy long after the security software has erased the "
"secrets in RAM and terminated.  (But be aware that the suspend mode on "
"laptops and some desktop computers will save a copy of the system's RAM to "
"disk, regardless of memory locks.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/mlock.2:334
msgid ""
"Real-time processes that are using B<mlockall>()  to prevent delays on page "
"faults should reserve enough locked stack pages before entering the time-"
"critical section, so that no page fault can be caused by function calls.  "
"This can be achieved by calling a function that allocates a sufficiently "
"large automatic variable (an array) and writes to the memory occupied by "
"this array in order to touch these stack pages.  This way, enough pages will"
" be mapped for the stack and can be locked into RAM.  The dummy writes "
"ensure that not even copy-on-write page faults can occur in the critical "
"section."
msgstr ""

#. type: Plain text
#: man-pages/man2/mlock.2:349
msgid ""
"Memory locks are not inherited by a child created via B<fork>(2)  and are "
"automatically removed (unlocked) during an B<execve>(2)  or when the process"
" terminates.  The B<mlockall>()  B<MCL_FUTURE> and B<MCL_FUTURE | "
"MCL_ONFAULT> settings are not inherited by a child created via B<fork>(2)  "
"and are cleared during an B<execve>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/mlock.2:363
msgid ""
"Note that B<fork>(2)  will prepare the address space for a copy-on-write "
"operation.  The consequence is that any write access that follows will cause"
" a page fault that in turn may cause high latencies for a real-time process."
"  Therefore, it is crucial not to invoke B<fork>(2)  after an B<mlockall>()"
"  or B<mlock>()  operation\\(emnot even from a thread which runs at a low "
"priority within a process which also has a thread running at elevated "
"priority."
msgstr ""

#. type: Plain text
#: man-pages/man2/mlock.2:367
msgid ""
"The memory lock on an address range is automatically removed if the address "
"range is unmapped via B<munmap>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/mlock.2:381
msgid ""
"Memory locks do not stack, that is, pages which have been locked several "
"times by calls to B<mlock>(), B<mlock2>(), or B<mlockall>()  will be "
"unlocked by a single call to B<munlock>()  for the corresponding range or by"
" B<munlockall>().  Pages which are mapped to several locations or by several"
" processes stay locked into RAM as long as they are locked at least at one "
"location or by at least one process."
msgstr ""

#. type: Plain text
#: man-pages/man2/mlock.2:390
msgid ""
"If a call to B<mlockall>()  which uses the B<MCL_FUTURE> flag is followed by"
" another call that does not specify this flag, the changes made by the "
"B<MCL_FUTURE> call will be lost."
msgstr ""

#. type: Plain text
#: man-pages/man2/mlock.2:401
msgid ""
"The B<mlock2>()  B<MLOCK_ONFAULT> flag and the B<mlockall>()  B<MCL_ONFAULT>"
" flag allow efficient memory locking for applications that deal with large "
"mappings where only a (small) portion of pages in the mapping are touched.  "
"In such cases, locking all of the pages in a mapping would incur a "
"significant penalty for memory locking."
msgstr ""

#. type: Plain text
#: man-pages/man2/mlock.2:417
msgid ""
"Under Linux, B<mlock>(), B<mlock2>(), and B<munlock>()  automatically round "
"I<addr> down to the nearest page boundary.  However, the POSIX.1 "
"specification of B<mlock>()  and B<munlock>()  allows an implementation to "
"require that I<addr> is page aligned, so portable applications should ensure"
" this."
msgstr ""

#. type: Plain text
#: man-pages/man2/mlock.2:431
msgid ""
"The I<VmLck> field of the Linux-specific I</proc/[pid]/status> file shows "
"how many kilobytes of memory the process with ID I<PID> has locked using "
"B<mlock>(), B<mlock2>(), B<mlockall>(), and B<mmap>(2)  B<MAP_LOCKED>."
msgstr ""

#. type: SS
#: man-pages/man2/mlock.2:431
#, no-wrap
msgid "Limits and permissions"
msgstr ""

#. type: Plain text
#: man-pages/man2/mlock.2:438
msgid ""
"In Linux 2.6.8 and earlier, a process must be privileged (B<CAP_IPC_LOCK>)  "
"in order to lock memory and the B<RLIMIT_MEMLOCK> soft resource limit "
"defines a limit on how much memory the process may lock."
msgstr ""

#. type: Plain text
#: man-pages/man2/mlock.2:444
msgid ""
"Since Linux 2.6.9, no limits are placed on the amount of memory that a "
"privileged process can lock and the B<RLIMIT_MEMLOCK> soft resource limit "
"instead defines a limit on how much memory an unprivileged process may lock."
msgstr ""

#.  commit 0cf2f6f6dc605e587d2c1120f295934c77e810e8
#. type: Plain text
#: man-pages/man2/mlock.2:467
msgid ""
"In Linux 4.8 and earlier, a bug in the kernel's accounting of locked memory "
"for unprivileged processes (i.e., without B<CAP_IPC_LOCK>)  meant that if "
"the region specified by I<addr> and I<len> overlapped an existing lock, then"
" the already locked bytes in the overlapping region were counted twice when "
"checking against the limit.  Such double accounting could incorrectly "
"calculate a \"total locked memory\" value for the process that exceeded the "
"B<RLIMIT_MEMLOCK> limit, with the result that B<mlock>()  and B<mlock2>()  "
"would fail on requests that should have succeeded.  This bug was fixed in "
"Linux 4.9"
msgstr ""

#. type: Plain text
#: man-pages/man2/mlock.2:475
msgid ""
"In the 2.4 series Linux kernels up to and including 2.4.17, a bug caused the"
" B<mlockall>()  B<MCL_FUTURE> flag to be inherited across a B<fork>(2).  "
"This was rectified in kernel 2.4.18."
msgstr ""

#.  See the following LKML thread:
#.  http://marc.theaimsgroup.com/?l=linux-kernel&m=113801392825023&w=2
#.  "Rationale for RLIMIT_MEMLOCK"
#.  23 Jan 2006
#. type: Plain text
#: man-pages/man2/mlock.2:492
msgid ""
"Since kernel 2.6.9, if a privileged process calls I<mlockall(MCL_FUTURE)> "
"and later drops privileges (loses the B<CAP_IPC_LOCK> capability by, for "
"example, setting its effective UID to a nonzero value), then subsequent "
"memory allocations (e.g., B<mmap>(2), B<brk>(2))  will fail if the "
"B<RLIMIT_MEMLOCK> resource limit is encountered."
msgstr ""

#. type: Plain text
#: man-pages/man2/mlock.2:499
msgid ""
"B<mincore>(2), B<mmap>(2), B<setrlimit>(2), B<shmctl>(2), B<sysconf>(3), "
"B<proc>(5), B<capabilities>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/mremap.2:30
#, no-wrap
msgid "MREMAP"
msgstr ""

#. type: Plain text
#: man-pages/man2/mremap.2:33
msgid "mremap - remap a virtual memory address"
msgstr ""

#. type: Plain text
#: man-pages/man2/mremap.2:40
#, no-wrap
msgid ""
"B<void *mremap(void *>I<old_address>B<, size_t >I<old_size>B<,>\n"
"B<             size_t >I<new_size>B<, int >I<flags>B<, ... /* void *>I<new_address>B< */);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/mremap.2:46
msgid ""
"B<mremap>()  expands (or shrinks) an existing memory mapping, potentially "
"moving it at the same time (controlled by the I<flags> argument and the "
"available virtual address space)."
msgstr ""

#. type: Plain text
#: man-pages/man2/mremap.2:60
msgid ""
"I<old_address> is the old address of the virtual memory block that you want "
"to expand (or shrink).  Note that I<old_address> has to be page aligned.  "
"I<old_size> is the old size of the virtual memory block.  I<new_size> is the"
" requested size of the virtual memory block after the resize.  An optional "
"fifth argument, I<new_address>, may be provided; see the description of "
"B<MREMAP_FIXED> below."
msgstr ""

#. type: Plain text
#: man-pages/man2/mremap.2:76
msgid ""
"If the value of I<old_size> is zero, and I<old_address> refers to a "
"shareable mapping (see B<mmap>(2)  B<MAP_SHARED>), then B<mremap>()  will "
"create a new mapping of the same pages.  I<new_size> will be the size of the"
" new mapping and the location of the new mapping may be specified with "
"I<new_address>; see the description of B<MREMAP_FIXED> below.  If a new "
"mapping is requested via this method, then the B<MREMAP_MAYMOVE> flag must "
"also be specified."
msgstr ""

#. type: Plain text
#: man-pages/man2/mremap.2:88
msgid ""
"In Linux the memory is divided into pages.  A user process has (one or)  "
"several linear virtual memory segments.  Each virtual memory segment has one"
" or more mappings to real memory pages (in the page table).  Each virtual "
"memory segment has its own protection (access rights), which may cause a "
"segmentation violation if the memory is accessed incorrectly (e.g., writing "
"to a read-only segment).  Accessing virtual memory outside of the segments "
"will also cause a segmentation violation."
msgstr ""

#. type: Plain text
#: man-pages/man2/mremap.2:96
msgid ""
"B<mremap>()  uses the Linux page table scheme.  B<mremap>()  changes the "
"mapping between virtual addresses and memory pages.  This can be used to "
"implement a very efficient B<realloc>(3)."
msgstr ""

#. type: Plain text
#: man-pages/man2/mremap.2:98
msgid ""
"The I<flags> bit-mask argument may be 0, or include the following flag:"
msgstr ""

#. type: TP
#: man-pages/man2/mremap.2:98
#, no-wrap
msgid "B<MREMAP_MAYMOVE>"
msgstr ""

#. type: Plain text
#: man-pages/man2/mremap.2:110
msgid ""
"By default, if there is not sufficient space to expand a mapping at its "
"current location, then B<mremap>()  fails.  If this flag is specified, then "
"the kernel is permitted to relocate the mapping to a new virtual address, if"
" necessary.  If the mapping is relocated, then absolute pointers into the "
"old mapping location become invalid (offsets relative to the starting "
"address of the mapping should be employed)."
msgstr ""

#. type: TP
#: man-pages/man2/mremap.2:110
#, no-wrap
msgid "B<MREMAP_FIXED> (since Linux 2.3.31)"
msgstr ""

#. type: Plain text
#: man-pages/man2/mremap.2:132
msgid ""
"This flag serves a similar purpose to the B<MAP_FIXED> flag of B<mmap>(2).  "
"If this flag is specified, then B<mremap>()  accepts a fifth argument, "
"I<void\\ *new_address>, which specifies a page-aligned address to which the "
"mapping must be moved.  Any previous mapping at the address range specified "
"by I<new_address> and I<new_size> is unmapped.  If B<MREMAP_FIXED> is "
"specified, then B<MREMAP_MAYMOVE> must also be specified."
msgstr ""

#. type: Plain text
#: man-pages/man2/mremap.2:142
msgid ""
"If the memory segment specified by I<old_address> and I<old_size> is locked "
"(using B<mlock>(2)  or similar), then this lock is maintained when the "
"segment is resized and/or relocated.  As a consequence, the amount of memory"
" locked by the process may change."
msgstr ""

#. type: Plain text
#: man-pages/man2/mremap.2:150
msgid ""
"On success B<mremap>()  returns a pointer to the new virtual memory area.  "
"On error, the value B<MAP_FAILED> (that is, I<(void\\ *)\\ -1>) is returned,"
" and I<errno> is set appropriately."
msgstr ""

#. type: Plain text
#: man-pages/man2/mremap.2:157
msgid ""
"The caller tried to expand a memory segment that is locked, but this was not"
" possible without exceeding the B<RLIMIT_MEMLOCK> resource limit."
msgstr ""

#. type: Plain text
#: man-pages/man2/mremap.2:166
msgid ""
"\"Segmentation fault.\" Some address in the range I<old_address> to "
"I<old_address>+I<old_size> is an invalid virtual memory address for this "
"process.  You can also get B<EFAULT> even if there exist mappings that cover"
" the whole address space requested, but those mappings are of different "
"types."
msgstr ""

#. type: Plain text
#: man-pages/man2/mremap.2:170
msgid "An invalid argument was given.  Possible causes are:"
msgstr ""

#. type: Plain text
#: man-pages/man2/mremap.2:174
msgid "I<old_address> was not page aligned;"
msgstr ""

#. type: Plain text
#: man-pages/man2/mremap.2:181
msgid ""
"a value other than B<MREMAP_MAYMOVE> or B<MREMAP_FIXED> was specified in "
"I<flags>;"
msgstr ""

#. type: Plain text
#: man-pages/man2/mremap.2:184
msgid "I<new_size> was zero;"
msgstr ""

#. type: Plain text
#: man-pages/man2/mremap.2:189
msgid "I<new_size> or I<new_address> was invalid;"
msgstr ""

#. type: Plain text
#: man-pages/man2/mremap.2:198
msgid ""
"the new address range specified by I<new_address> and I<new_size> overlapped"
" the old address range specified by I<old_address> and I<old_size>;"
msgstr ""

#. type: Plain text
#: man-pages/man2/mremap.2:202
msgid ""
"B<MREMAP_FIXED> was specified without also specifying B<MREMAP_MAYMOVE>;"
msgstr ""

#. type: Plain text
#: man-pages/man2/mremap.2:205
msgid ""
"I<old_size> was zero and I<old_address> does not refer to a shareable "
"mapping (but see BUGS);"
msgstr ""

#. type: Plain text
#: man-pages/man2/mremap.2:209
msgid "I<old_size> was zero and the B<MREMAP_MAYMOVE> flag was not specified."
msgstr ""

#. type: Plain text
#: man-pages/man2/mremap.2:216
msgid ""
"The memory area cannot be expanded at the current virtual address, and the "
"B<MREMAP_MAYMOVE> flag is not set in I<flags>.  Or, there is not enough "
"(virtual) memory available."
msgstr ""

#.  4.2BSD had a (never actually implemented)
#.  .BR mremap (2)
#.  call with completely different semantics.
#. type: Plain text
#: man-pages/man2/mremap.2:222
msgid ""
"This call is Linux-specific, and should not be used in programs intended to "
"be portable."
msgstr ""

#. type: Plain text
#: man-pages/man2/mremap.2:230
msgid ""
"Prior to version 2.4, glibc did not expose the definition of "
"B<MREMAP_FIXED>, and the prototype for B<mremap>()  did not allow for the "
"I<new_address> argument."
msgstr ""

#. type: Plain text
#: man-pages/man2/mremap.2:241
msgid ""
"If B<mremap>()  is used to move or expand an area locked with B<mlock>(2)  "
"or equivalent, the B<mremap>()  call will make a best effort to populate the"
" new area but will not fail with B<ENOMEM> if the area cannot be populated."
msgstr ""

#.  commit dba58d3b8c5045ad89c1c95d33d01451e3964db7
#. type: Plain text
#: man-pages/man2/mremap.2:262
msgid ""
"Before Linux 4.14, if I<old_size> was zero and the mapping referred to by "
"I<old_address> was a private mapping (B<mmap>(2) B<MAP_PRIVATE>), "
"B<mremap>()  created a new private mapping unrelated to the original "
"mapping.  This behavior was unintended and probably unexpected in user-space"
" applications (since the intention of B<mremap>()  is to create a new "
"mapping based on the original mapping).  Since Linux 4.14, B<mremap>()  "
"fails with the error B<EINVAL> in this scenario."
msgstr ""

#. type: Plain text
#: man-pages/man2/mremap.2:271
msgid ""
"B<brk>(2), B<getpagesize>(2), B<getrlimit>(2), B<mlock>(2), B<mmap>(2), "
"B<sbrk>(2), B<malloc>(3), B<realloc>(3)"
msgstr ""

#. type: Plain text
#: man-pages/man2/mremap.2:276
msgid ""
"Your favorite text book on operating systems for more information on paged "
"memory (e.g., I<Modern Operating Systems> by Andrew S.\\& Tanenbaum, "
"I<Inside Linux> by Randolf Bentson, I<The Design of the UNIX Operating "
"System> by Maurice J.\\& Bach)"
msgstr ""

#. type: TH
#: man-pages/man2/mbind.2:35
#, no-wrap
msgid "MBIND"
msgstr ""

#. type: Plain text
#: man-pages/man2/mbind.2:38
msgid "mbind - set memory policy for a memory range"
msgstr ""

#. type: Plain text
#: man-pages/man2/mbind.2:45
#, no-wrap
msgid ""
"B<long mbind(void *>I<addr>B<, unsigned long >I<len>B<, int >I<mode>B<,>\n"
"B<           const unsigned long *>I<nodemask>B<, unsigned long >I<maxnode>B<,>\n"
"B<           unsigned >I<flags>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/mbind.2:47
#, no-wrap
msgid "Link with I<-lnuma>.\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/mbind.2:58
msgid ""
"B<mbind>()  sets the NUMA memory policy, which consists of a policy mode and"
" zero or more nodes, for the memory range starting with I<addr> and "
"continuing for I<len> bytes.  The memory policy defines from which node "
"memory is allocated."
msgstr ""

#. type: Plain text
#: man-pages/man2/mbind.2:80
msgid ""
"If the memory range specified by the I<addr> and I<len> arguments includes "
"an \"anonymous\" region of memory\\(emthat is a region of memory created "
"using the B<mmap>(2)  system call with the B<MAP_ANONYMOUS>\\(emor a memory-"
"mapped file, mapped using the B<mmap>(2)  system call with the "
"B<MAP_PRIVATE> flag, pages will be allocated only according to the specified"
" policy when the application writes (stores) to the page.  For anonymous "
"regions, an initial read access will use a shared page in the kernel "
"containing all zeros.  For a file mapped with B<MAP_PRIVATE>, an initial "
"read access will allocate pages according to the memory policy of the thread"
" that causes the page to be allocated.  This may not be the thread that "
"called B<mbind>()."
msgstr ""

#. type: Plain text
#: man-pages/man2/mbind.2:88
msgid ""
"The specified policy will be ignored for any B<MAP_SHARED> mappings in the "
"specified memory range.  Rather the pages will be allocated according to the"
" memory policy of the thread that caused the page to be allocated.  Again, "
"this may not be the thread that called B<mbind>()."
msgstr ""

#. type: Plain text
#: man-pages/man2/mbind.2:105
msgid ""
"If the specified memory range includes a shared memory region created using "
"the B<shmget>(2)  system call and attached using the B<shmat>(2)  system "
"call, pages allocated for the anonymous or shared memory region will be "
"allocated according to the policy specified, regardless of which process "
"attached to the shared memory segment causes the allocation.  If, however, "
"the shared memory region was created with the B<SHM_HUGETLB> flag, the huge "
"pages will be allocated according to the policy specified only if the page "
"allocation is caused by the process that calls B<mbind>()  for that region."
msgstr ""

#. type: Plain text
#: man-pages/man2/mbind.2:116
msgid ""
"By default, B<mbind>()  has an effect only for new allocations; if the pages"
" inside the range have been already touched before setting the policy, then "
"the policy has no effect.  This default behavior may be overridden by the "
"B<MPOL_MF_MOVE> and B<MPOL_MF_MOVE_ALL> flags described below."
msgstr ""

#. type: Plain text
#: man-pages/man2/mbind.2:133
msgid ""
"The I<mode> argument must specify one of B<MPOL_DEFAULT>, B<MPOL_BIND>, "
"B<MPOL_INTERLEAVE>, B<MPOL_PREFERRED>, or B<MPOL_LOCAL> (which are described"
" in detail below).  All policy modes except B<MPOL_DEFAULT> require the "
"caller to specify the node or nodes to which the mode applies, via the "
"I<nodemask> argument."
msgstr ""

#. type: Plain text
#: man-pages/man2/mbind.2:141
msgid ""
"The I<mode> argument may also include an optional I<mode flag>.  The "
"supported I<mode flags> are:"
msgstr ""

#. type: TP
#: man-pages/man2/mbind.2:141
#, no-wrap
msgid "B<MPOL_F_STATIC_NODES> (since Linux-2.6.26)"
msgstr ""

#. type: Plain text
#: man-pages/man2/mbind.2:151
msgid ""
"A nonempty I<nodemask> specifies physical node IDs.  Linux does not remap "
"the I<nodemask> when the thread moves to a different cpuset context, nor "
"when the set of nodes allowed by the thread's current cpuset context "
"changes."
msgstr ""

#. type: TP
#: man-pages/man2/mbind.2:151
#, no-wrap
msgid "B<MPOL_F_RELATIVE_NODES> (since Linux-2.6.26)"
msgstr ""

#. type: Plain text
#: man-pages/man2/mbind.2:157
msgid ""
"A nonempty I<nodemask> specifies node IDs that are relative to the set of "
"node IDs allowed by the thread's current cpuset."
msgstr ""

#. type: Plain text
#: man-pages/man2/mbind.2:185
msgid ""
"I<nodemask> points to a bit mask of nodes containing up to I<maxnode> bits."
"  The bit mask size is rounded to the next multiple of I<sizeof(unsigned "
"long)>, but the kernel will use bits only up to I<maxnode>.  A NULL value of"
" I<nodemask> or a I<maxnode> value of zero specifies the empty set of nodes."
"  If the value of I<maxnode> is zero, the I<nodemask> argument is ignored.  "
"Where a I<nodemask> is required, it must contain at least one node that is "
"on-line, allowed by the thread's current cpuset context (unless the "
"B<MPOL_F_STATIC_NODES> mode flag is specified), and contains memory."
msgstr ""

#. type: Plain text
#: man-pages/man2/mbind.2:189
msgid "The I<mode> argument must include one of the following values:"
msgstr ""

#. type: TP
#: man-pages/man2/mbind.2:189
#, no-wrap
msgid "B<MPOL_DEFAULT>"
msgstr ""

#. type: Plain text
#: man-pages/man2/mbind.2:210
msgid ""
"This mode requests that any nondefault policy be removed, restoring default "
"behavior.  When applied to a range of memory via B<mbind>(), this means to "
"use the thread memory policy, which may have been set with "
"B<set_mempolicy>(2).  If the mode of the thread memory policy is also "
"B<MPOL_DEFAULT>, the system-wide default policy will be used.  The system-"
"wide default policy allocates pages on the node of the CPU that triggers the"
" allocation.  For B<MPOL_DEFAULT>, the I<nodemask> and I<maxnode> arguments "
"must be specify the empty set of nodes."
msgstr ""

#. type: TP
#: man-pages/man2/mbind.2:210
#, no-wrap
msgid "B<MPOL_BIND>"
msgstr ""

#.  commit 19770b32609b6bf97a3dece2529089494cbfc549
#. type: Plain text
#: man-pages/man2/mbind.2:231
msgid ""
"This mode specifies a strict policy that restricts memory allocation to the "
"nodes specified in I<nodemask>.  If I<nodemask> specifies more than one "
"node, page allocations will come from the node with sufficient free memory "
"that is closest to the node where the allocation takes place.  Pages will "
"not be allocated from any node not specified in the IR nodemask .  (Before "
"Linux 2.6.26, page allocations came from the node with the lowest numeric "
"node ID first, until that node contained no free memory.  Allocations then "
"came from the node with the next highest node ID specified in I<nodemask> "
"and so forth, until none of the specified nodes contained free memory.)"
msgstr ""

#. type: TP
#: man-pages/man2/mbind.2:231
#, no-wrap
msgid "B<MPOL_INTERLEAVE>"
msgstr ""

#. type: Plain text
#: man-pages/man2/mbind.2:243
msgid ""
"This mode specifies that page allocations be interleaved across the set of "
"nodes specified in I<nodemask>.  This optimizes for bandwidth instead of "
"latency by spreading out pages and memory accesses to those pages across "
"multiple nodes.  To be effective the memory area should be fairly large, at "
"least 1\\ MB or bigger with a fairly uniform access pattern.  Accesses to a "
"single page of the area will still be limited to the memory bandwidth of a "
"single node."
msgstr ""

#. type: TP
#: man-pages/man2/mbind.2:243
#, no-wrap
msgid "B<MPOL_PREFERRED>"
msgstr ""

#. type: Plain text
#: man-pages/man2/mbind.2:259
msgid ""
"This mode sets the preferred node for allocation.  The kernel will try to "
"allocate pages from this node first and fall back to other nodes if the "
"preferred nodes is low on free memory.  If I<nodemask> specifies more than "
"one node ID, the first node in the mask will be selected as the preferred "
"node.  If the I<nodemask> and I<maxnode> arguments specify the empty set, "
"then the memory is allocated on the node of the CPU that triggered the "
"allocation."
msgstr ""

#. type: TP
#: man-pages/man2/mbind.2:259
#, no-wrap
msgid "B<MPOL_LOCAL> (since Linux 3.8)"
msgstr ""

#.  commit 479e2802d09f1e18a97262c4c6f8f17ae5884bd8
#.  commit f2a07f40dbc603c15f8b06e6ec7f768af67b424f
#. type: Plain text
#: man-pages/man2/mbind.2:283
msgid ""
"This mode specifies \"local allocation\"; the memory is allocated on the "
"node of the CPU that triggered the allocation (the \"local node\").  The "
"I<nodemask> and I<maxnode> arguments must specify the empty set.  If the "
"\"local node\" is low on free memory, the kernel will try to allocate memory"
" from other nodes.  The kernel will allocate memory from the \"local node\" "
"whenever memory for this node is available.  If the \"local node\" is not "
"allowed by the thread's current cpuset context, the kernel will try to "
"allocate memory from other nodes.  The kernel will allocate memory from the "
"\"local node\" whenever it becomes allowed by the thread's current cpuset "
"context.  By contrast, B<MPOL_DEFAULT> reverts to the memory policy of the "
"thread (which may be set via B<set_mempolicy>(2)); that policy may be "
"something other than \"local allocation\"."
msgstr ""

#.  According to the kernel code, the following is not true
#.  --Lee Schermerhorn
#.  In 2.6.16 or later the kernel will also try to move pages
#.  to the requested node with this flag.
#. type: Plain text
#: man-pages/man2/mbind.2:299
msgid ""
"If B<MPOL_MF_STRICT> is passed in I<flags> and I<mode> is not "
"B<MPOL_DEFAULT>, then the call fails with the error B<EIO> if the existing "
"pages in the memory range don't follow the policy."
msgstr ""

#. type: Plain text
#: man-pages/man2/mbind.2:312
msgid ""
"If B<MPOL_MF_MOVE> is specified in I<flags>, then the kernel will attempt to"
" move all the existing pages in the memory range so that they follow the "
"policy.  Pages that are shared with other processes will not be moved.  If "
"B<MPOL_MF_STRICT> is also specified, then the call fails with the error "
"B<EIO> if some pages could not be moved."
msgstr ""

#.  ---------------------------------------------------------------
#. type: Plain text
#: man-pages/man2/mbind.2:328
msgid ""
"If B<MPOL_MF_MOVE_ALL> is passed in I<flags>, then the kernel will attempt "
"to move all existing pages in the memory range regardless of whether other "
"processes use the pages.  The calling thread must be privileged "
"(B<CAP_SYS_NICE>)  to use this flag.  If B<MPOL_MF_STRICT> is also "
"specified, then the call fails with the error B<EIO> if some pages could not"
" be moved."
msgstr ""

#.  ---------------------------------------------------------------
#. type: Plain text
#: man-pages/man2/mbind.2:336
msgid ""
"On success, B<mbind>()  returns 0; on error, -1 is returned and I<errno> is "
"set to indicate the error."
msgstr ""

#. type: Plain text
#: man-pages/man2/mbind.2:349
msgid ""
"Part or all of the memory range specified by I<nodemask> and I<maxnode> "
"points outside your accessible address space.  Or, there was an unmapped "
"hole in the specified memory range specified by I<addr> and I<len>."
msgstr ""

#.  As at 2.6.23, this limit is "a page worth of bits", e.g.,
#.  8 * 4096 bits, assuming a 4kB page size.
#. type: Plain text
#: man-pages/man2/mbind.2:397
msgid ""
"An invalid value was specified for I<flags> or I<mode>; or I<addr + len> was"
" less than I<addr>; or I<addr> is not a multiple of the system page size.  "
"Or, I<mode> is B<MPOL_DEFAULT> and I<nodemask> specified a nonempty set; or "
"I<mode> is B<MPOL_BIND> or B<MPOL_INTERLEAVE> and I<nodemask> is empty.  Or,"
" I<maxnode> exceeds a kernel-imposed limit.  Or, I<nodemask> specifies one "
"or more node IDs that are greater than the maximum supported node ID.  Or, "
"none of the node IDs specified by I<nodemask> are on-line and allowed by the"
" thread's current cpuset context, or none of the specified nodes contain "
"memory.  Or, the I<mode> argument specified both B<MPOL_F_STATIC_NODES> and "
"B<MPOL_F_RELATIVE_NODES>."
msgstr ""

#. type: Plain text
#: man-pages/man2/mbind.2:408
msgid ""
"B<MPOL_MF_STRICT> was specified and an existing page was already on a node "
"that does not follow the policy; or B<MPOL_MF_MOVE> or B<MPOL_MF_MOVE_ALL> "
"was specified and the kernel was unable to move all existing pages in the "
"range."
msgstr ""

#.  ---------------------------------------------------------------
#. type: Plain text
#: man-pages/man2/mbind.2:421
msgid ""
"The I<flags> argument included the B<MPOL_MF_MOVE_ALL> flag and the caller "
"does not have the B<CAP_SYS_NICE> privilege."
msgstr ""

#. type: Plain text
#: man-pages/man2/mbind.2:425
msgid ""
"The B<mbind>()  system call was added to the Linux kernel in version 2.6.7."
msgstr ""

#. type: Plain text
#: man-pages/man2/mbind.2:435
msgid ""
"NUMA policy is not supported on a memory-mapped file range that was mapped "
"with the B<MAP_SHARED> flag."
msgstr ""

#. type: Plain text
#: man-pages/man2/mbind.2:469
msgid ""
"The B<MPOL_DEFAULT> mode can have different effects for B<mbind>()  and "
"B<set_mempolicy>(2).  When B<MPOL_DEFAULT> is specified for "
"B<set_mempolicy>(2), the thread's memory policy reverts to the system "
"default policy or local allocation.  When B<MPOL_DEFAULT> is specified for a"
" range of memory using B<mbind>(), any pages subsequently allocated for that"
" range will use the thread's memory policy, as set by B<set_mempolicy>(2).  "
"This effectively removes the explicit policy from the specified range, "
"\"falling back\" to a possibly nondefault policy.  To select explicit "
"\"local allocation\" for a memory range, specify a I<mode> of B<MPOL_LOCAL> "
"or B<MPOL_PREFERRED> with an empty set of nodes.  This method will work for "
"B<set_mempolicy>(2), as well."
msgstr ""

#. type: Plain text
#: man-pages/man2/mbind.2:473
msgid ""
"Support for huge page policy was added with 2.6.16.  For interleave policy "
"to be effective on huge page mappings the policied memory needs to be tens "
"of megabytes or larger."
msgstr ""

#. type: Plain text
#: man-pages/man2/mbind.2:476
msgid "B<MPOL_MF_STRICT> is ignored on huge page mappings."
msgstr ""

#. type: Plain text
#: man-pages/man2/mbind.2:481
msgid ""
"B<MPOL_MF_MOVE> and B<MPOL_MF_MOVE_ALL> are available only on Linux 2.6.16 "
"and later."
msgstr ""

#. type: Plain text
#: man-pages/man2/mbind.2:491
msgid ""
"B<get_mempolicy>(2), B<getcpu>(2), B<mmap>(2), B<set_mempolicy>(2), "
"B<shmat>(2), B<shmget>(2), B<numa>(3), B<cpuset>(7), B<numa>(7), "
"B<numactl>(8)"
msgstr ""

#. type: TH
#: man-pages/man2/mq_getsetattr.2:26
#, no-wrap
msgid "MQ_GETSETATTR"
msgstr ""

#. type: Plain text
#: man-pages/man2/mq_getsetattr.2:29
msgid "mq_getsetattr - get/set message queue attributes"
msgstr ""

#. type: Plain text
#: man-pages/man2/mq_getsetattr.2:33
#, no-wrap
msgid ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>mqueue.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/mq_getsetattr.2:36
#, no-wrap
msgid ""
"B<int mq_getsetattr(mqd_t >I<mqdes>B<, struct mq_attr *>I<newattr>B<,>\n"
"B<                 struct mq_attr *>I<oldattr>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/mq_getsetattr.2:42
msgid "Do not use this system call."
msgstr ""

#. type: Plain text
#: man-pages/man2/mq_getsetattr.2:50
msgid ""
"This is the low-level system call used to implement B<mq_getattr>(3)  and "
"B<mq_setattr>(3).  For an explanation of how this system call operates, see "
"the description of B<mq_setattr>(3)."
msgstr ""

#. type: Plain text
#: man-pages/man2/mq_getsetattr.2:52
msgid "This interface is nonstandard; avoid its use."
msgstr ""

#. type: Plain text
#: man-pages/man2/mq_getsetattr.2:56
msgid ""
"Glibc does not provide a wrapper for this system call; call it using "
"B<syscall>(2).  (Actually, never call it unless you are writing a C "
"library!)"
msgstr ""

#. type: Plain text
#: man-pages/man2/mq_getsetattr.2:58
msgid "B<mq_getattr>(3), B<mq_overview>(7)"
msgstr ""

#. type: TH
#: man-pages/man5/motd.5:27
#, no-wrap
msgid "MOTD"
msgstr ""

#. type: TH
#: man-pages/man5/motd.5:27
#, no-wrap
msgid "1992-12-29"
msgstr ""

#. type: Plain text
#: man-pages/man5/motd.5:30
msgid "motd - message of the day"
msgstr ""

#. type: Plain text
#: man-pages/man5/motd.5:36
msgid ""
"The contents of I</etc/motd> are displayed by B<login>(1)  after a "
"successful login but just before it executes the login shell."
msgstr ""

#. type: Plain text
#: man-pages/man5/motd.5:40
msgid ""
"The abbreviation \"motd\" stands for \"message of the day\", and this file "
"has been traditionally used for exactly that (it requires much less disk "
"space than mail to all users)."
msgstr ""

#. type: Plain text
#: man-pages/man5/motd.5:42
msgid "I</etc/motd>"
msgstr ""

#. type: Plain text
#: man-pages/man5/motd.5:44
msgid "B<login>(1), B<issue>(5)"
msgstr ""

#. type: TH
#: man-pages/man3/mbtowc.3:16
#, no-wrap
msgid "MBTOWC"
msgstr ""

#. type: Plain text
#: man-pages/man3/mbtowc.3:19
msgid "mbtowc - convert a multibyte sequence to a wide character"
msgstr ""

#. type: Plain text
#: man-pages/man3/mbtowc.3:22
#, no-wrap
msgid "B<#include E<lt>stdlib.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/mbtowc.3:24
#, no-wrap
msgid ""
"B<int mbtowc(wchar_t *>I<pwc>B<, const char *>I<s>B<, size_t >I<n>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/mbtowc.3:50
msgid ""
"The main case for this function is when I<s> is not NULL and I<pwc> is not "
"NULL.  In this case, the B<mbtowc>()  function inspects at most I<n> bytes "
"of the multibyte string starting at I<s>, extracts the next complete "
"multibyte character, converts it to a wide character and stores it at "
"I<*pwc>.  It updates an internal shift state known only to the B<mbtowc>()  "
"function.  If I<s> does not point to a null byte (\\(aq\\e0\\(aq), it "
"returns the number of bytes that were consumed from I<s>, otherwise it "
"returns 0."
msgstr ""

#. type: Plain text
#: man-pages/man3/mbtowc.3:64
msgid ""
"If the I<n> bytes starting at I<s> do not contain a complete multibyte "
"character, or if they contain an invalid multibyte sequence, B<mbtowc>()  "
"returns -1.  This can happen even if I<n> E<gt>= I<MB_CUR_MAX>, if the "
"multibyte string contains redundant shift sequences."
msgstr ""

#. type: Plain text
#: man-pages/man3/mbtowc.3:74
msgid ""
"A different case is when I<s> is not NULL but I<pwc> is NULL.  In this case,"
" the B<mbtowc>()  function behaves as above, except that it does not store "
"the converted wide character in memory."
msgstr ""

#.  The Dinkumware doc and the Single UNIX specification say this, but
#.  glibc doesn't implement this.
#. type: Plain text
#: man-pages/man3/mbtowc.3:93
msgid ""
"A third case is when I<s> is NULL.  In this case, I<pwc> and I<n> are "
"ignored.  The B<mbtowc>()  function resets the shift state, only known to "
"this function, to the initial state, and returns nonzero if the encoding has"
" nontrivial shift state, or zero if the encoding is stateless."
msgstr ""

#. type: Plain text
#: man-pages/man3/mbtowc.3:105
msgid ""
"If I<s> is not NULL, the B<mbtowc>()  function returns the number of "
"consumed bytes starting at I<s>, or 0 if I<s> points to a null byte, or -1 "
"upon failure."
msgstr ""

#. type: Plain text
#: man-pages/man3/mbtowc.3:113
msgid ""
"If I<s> is NULL, the B<mbtowc>()  function returns nonzero if the encoding "
"has nontrivial shift state, or zero if the encoding is stateless."
msgstr ""

#. type: tbl table
#: man-pages/man3/mbtowc.3:123
#, no-wrap
msgid "B<mbtowc>()"
msgstr ""

#. type: tbl table
#: man-pages/man3/mbtowc.3:123
#, no-wrap
msgid "MT-Unsafe race"
msgstr ""

#. type: Plain text
#: man-pages/man3/mbtowc.3:127
msgid "POSIX.1-2001, POSIX.1-2008, C99."
msgstr ""

#. type: Plain text
#: man-pages/man3/mbtowc.3:134
msgid ""
"The behavior of B<mbtowc>()  depends on the B<LC_CTYPE> category of the "
"current locale."
msgstr ""

#. type: Plain text
#: man-pages/man3/mbtowc.3:140
msgid ""
"This function is not multithread safe.  The function B<mbrtowc>(3)  provides"
" a better interface to the same functionality."
msgstr ""

#. type: Plain text
#: man-pages/man3/mbtowc.3:146
msgid ""
"B<MB_CUR_MAX>(3), B<mblen>(3), B<mbrtowc>(3), B<mbstowcs>(3), "
"B<wcstombs>(3), B<wctomb>(3)"
msgstr ""

#. type: TH
#: man-pages/man3/mq_receive.3:26
#, no-wrap
msgid "MQ_RECEIVE"
msgstr ""

#. type: Plain text
#: man-pages/man3/mq_receive.3:29
msgid "mq_receive, mq_timedreceive - receive a message from a message queue"
msgstr ""

#. type: Plain text
#: man-pages/man3/mq_receive.3:32
#, no-wrap
msgid "B<#include E<lt>mqueue.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/mq_receive.3:35
#, no-wrap
msgid ""
"B<ssize_t mq_receive(mqd_t >I<mqdes>B<, char *>I<msg_ptr>B<,>\n"
"B<                   size_t >I<msg_len>B<, unsigned int *>I<msg_prio>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/mq_receive.3:38
#, no-wrap
msgid ""
"B<#include E<lt>time.hE<gt>>\n"
"B<#include E<lt>mqueue.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/mq_receive.3:42
#, no-wrap
msgid ""
"B<ssize_t mq_timedreceive(mqd_t >I<mqdes>B<, char *>I<msg_ptr>B<,>\n"
"B<                   size_t >I<msg_len>B<, unsigned int *>I<msg_prio>B<,>\n"
"B<                   const struct timespec *>I<abs_timeout>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/mq_receive.3:45
msgid "Link with I<-lrt>."
msgstr ""

#. type: Plain text
#: man-pages/man3/mq_receive.3:53
msgid "B<mq_timedreceive>():"
msgstr ""

#. type: Plain text
#: man-pages/man3/mq_receive.3:55
msgid "_POSIX_C_SOURCE\\ E<gt>=\\ 200112L"
msgstr ""

#. type: Plain text
#: man-pages/man3/mq_receive.3:76
msgid ""
"B<mq_receive>()  removes the oldest message with the highest priority from "
"the message queue referred to by the message queue descriptor I<mqdes>, and "
"places it in the buffer pointed to by I<msg_ptr>.  The I<msg_len> argument "
"specifies the size of the buffer pointed to by I<msg_ptr>; this must be "
"greater than or equal to the I<mq_msgsize> attribute of the queue (see "
"B<mq_getattr>(3)).  If I<msg_prio> is not NULL, then the buffer to which it "
"points is used to return the priority associated with the received message."
msgstr ""

#. type: Plain text
#: man-pages/man3/mq_receive.3:86
msgid ""
"If the queue is empty, then, by default, B<mq_receive>()  blocks until a "
"message becomes available, or the call is interrupted by a signal handler.  "
"If the B<O_NONBLOCK> flag is enabled for the message queue description, then"
" the call instead fails immediately with the error B<EAGAIN>."
msgstr ""

#. type: Plain text
#: man-pages/man3/mq_receive.3:98
msgid ""
"B<mq_timedreceive>()  behaves just like B<mq_receive>(), except that if the "
"queue is empty and the B<O_NONBLOCK> flag is not enabled for the message "
"queue description, then I<abs_timeout> points to a structure which specifies"
" how long the call will block.  This value is an absolute timeout in seconds"
" and nanoseconds since the Epoch, 1970-01-01 00:00:00 +0000 (UTC), specified"
" in the following structure:"
msgstr ""

#. type: Plain text
#: man-pages/man3/mq_receive.3:105
#, no-wrap
msgid ""
"struct timespec {\n"
"    time_t tv_sec;        /* seconds */\n"
"    long   tv_nsec;       /* nanoseconds */\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/mq_receive.3:112
msgid ""
"If no message is available, and the timeout has already expired by the time "
"of the call, B<mq_timedreceive>()  returns immediately."
msgstr ""

#. type: Plain text
#: man-pages/man3/mq_receive.3:121
msgid ""
"On success, B<mq_receive>()  and B<mq_timedreceive>()  return the number of "
"bytes in the received message; on error, -1 is returned, with I<errno> set "
"to indicate the error."
msgstr ""

#. type: Plain text
#: man-pages/man3/mq_receive.3:128
msgid ""
"The queue was empty, and the B<O_NONBLOCK> flag was set for the message "
"queue description referred to by I<mqdes>."
msgstr ""

#. type: Plain text
#: man-pages/man3/mq_receive.3:133
msgid ""
"The descriptor specified in I<mqdes> was invalid or not opened for reading."
msgstr ""

#. type: Plain text
#: man-pages/man3/mq_receive.3:137
msgid "The call was interrupted by a signal handler; see B<signal>(7)."
msgstr ""

#. type: Plain text
#: man-pages/man3/mq_receive.3:146
msgid ""
"The call would have blocked, and I<abs_timeout> was invalid, either because "
"I<tv_sec> was less than zero, or because I<tv_nsec> was less than zero or "
"greater than 1000 million."
msgstr ""

#. type: TP
#: man-pages/man3/mq_receive.3:146
#, no-wrap
msgid "B<EMSGSIZE>"
msgstr ""

#. type: Plain text
#: man-pages/man3/mq_receive.3:152
msgid ""
"I<msg_len> was less than the I<mq_msgsize> attribute of the message queue."
msgstr ""

#. type: TP
#: man-pages/man3/mq_receive.3:152
#, no-wrap
msgid "B<ETIMEDOUT>"
msgstr ""

#. type: Plain text
#: man-pages/man3/mq_receive.3:155
msgid "The call timed out before a message could be transferred."
msgstr ""

#. type: tbl table
#: man-pages/man3/mq_receive.3:166
#, no-wrap
msgid ""
"B<mq_receive>(),\n"
"B<mq_timedreceive>()"
msgstr ""

#. type: Plain text
#: man-pages/man3/mq_receive.3:176
msgid ""
"On Linux, B<mq_timedreceive>()  is a system call, and B<mq_receive>()  is a "
"library function layered on top of that system call."
msgstr ""

#. type: Plain text
#: man-pages/man3/mq_receive.3:184
msgid ""
"B<mq_close>(3), B<mq_getattr>(3), B<mq_notify>(3), B<mq_open>(3), "
"B<mq_send>(3), B<mq_unlink>(3), B<mq_overview>(7), B<time>(7)"
msgstr ""

#. type: TH
#: man-pages/man3/memcmp.3:30
#, no-wrap
msgid "MEMCMP"
msgstr ""

#. type: Plain text
#: man-pages/man3/memcmp.3:33
msgid "memcmp - compare memory areas"
msgstr ""

#. type: Plain text
#: man-pages/man3/memcmp.3:36
#, no-wrap
msgid "B<#include E<lt>string.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/memcmp.3:38
#, no-wrap
msgid ""
"B<int memcmp(const void *>I<s1>B<, const void *>I<s2>B<, size_t >I<n>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/memcmp.3:45
msgid ""
"The B<memcmp>()  function compares the first I<n> bytes (each interpreted as"
" I<unsigned char>)  of the memory areas I<s1> and I<s2>."
msgstr ""

#. type: Plain text
#: man-pages/man3/memcmp.3:52
msgid ""
"The B<memcmp>()  function returns an integer less than, equal to, or greater"
" than zero if the first I<n> bytes of I<s1> is found, respectively, to be "
"less than, to match, or be greater than the first I<n> bytes of I<s2>."
msgstr ""

#. type: Plain text
#: man-pages/man3/memcmp.3:60
msgid ""
"For a nonzero return value, the sign is determined by the sign of the "
"difference between the first pair of bytes (interpreted as I<unsigned char>)"
"  that differ in I<s1> and I<s2>."
msgstr ""

#. type: Plain text
#: man-pages/man3/memcmp.3:64
msgid "If I<n> is zero, the return value is zero."
msgstr ""

#. type: tbl table
#: man-pages/man3/memcmp.3:74
#, no-wrap
msgid "B<memcmp>()"
msgstr ""

#. type: Plain text
#: man-pages/man3/memcmp.3:78
msgid "POSIX.1-2001, POSIX.1-2008, C89, C99, SVr4, 4.3BSD."
msgstr ""

#. type: Plain text
#: man-pages/man3/memcmp.3:89
msgid ""
"Do not use B<memcmp>()  to compare security critical data, such as "
"cryptographic secrets, because the required CPU time depends on the number "
"of equal bytes.  Instead, a function that performs comparisons in constant "
"time is required.  Some operating systems provide such a function (e.g., "
"NetBSD's B<consttime_memequal>()), but no such function is specified in "
"POSIX.  On Linux, it may be necessary to implement such a function oneself."
msgstr ""

#. type: Plain text
#: man-pages/man3/memcmp.3:97
msgid ""
"B<bcmp>(3), B<bstring>(3), B<strcasecmp>(3), B<strcmp>(3), B<strcoll>(3), "
"B<strncasecmp>(3), B<strncmp>(3), B<wmemcmp>(3)"
msgstr ""

#. type: TH
#: man-pages/man3/matherr.3:27
#, no-wrap
msgid "MATHERR"
msgstr ""

#. type: Plain text
#: man-pages/man3/matherr.3:30
msgid "matherr - SVID math library exception handling"
msgstr ""

#. type: Plain text
#: man-pages/man3/matherr.3:33
#, no-wrap
msgid "B<#include E<lt>math.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/matherr.3:35
#, no-wrap
msgid "B<int matherr(struct exception *>I<exc>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/matherr.3:37
#, no-wrap
msgid "B<extern _LIB_VERSION_TYPE _LIB_VERSION;>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/matherr.3:40
msgid "Link with I<-lm>."
msgstr ""

#.  glibc commit 813378e9fe17e029caf627cab76fe23eb46815fa
#. type: Plain text
#: man-pages/man3/matherr.3:54
msgid ""
"I<Note>: the mechanism described in this page is no longer supported by "
"glibc.  Before glibc 2.27, it had been marked as obsolete.  Since glibc "
"2.27, the mechanism has been removed altogether.  New applications should "
"use the techniques described in B<math_error>(7)  and B<fenv>(3).  This page"
" documents the B<matherr>()  mechanism as an aid for maintaining and porting"
" older applications."
msgstr ""

#. type: Plain text
#: man-pages/man3/matherr.3:64
msgid ""
"The System V Interface Definition (SVID) specifies that various math "
"functions should invoke a function called B<matherr>()  if a math exception "
"is detected.  This function is called before the math function returns; "
"after B<matherr>()  returns, the system then returns to the math function, "
"which in turn returns to the caller."
msgstr ""

#. type: Plain text
#: man-pages/man3/matherr.3:77
msgid ""
"To employ B<matherr>(), the programmer must define the B<_SVID_SOURCE> "
"feature test macro (before including I<any> header files), and assign the "
"value B<_SVID_> to the external variable B<_LIB_VERSION>."
msgstr ""

#. type: Plain text
#: man-pages/man3/matherr.3:89
msgid ""
"The system provides a default version of B<matherr>().  This version does "
"nothing, and returns zero (see below for the significance of this).  The "
"default B<matherr>()  can be overridden by a programmer-defined version, "
"which will be invoked when an exception occurs.  The function is invoked "
"with one argument, a pointer to an I<exception> structure, defined as "
"follows:"
msgstr ""

#. type: Plain text
#: man-pages/man3/matherr.3:99
#, no-wrap
msgid ""
"struct exception {\n"
"    int    type;      /* Exception type */\n"
"    char  *name;      /* Name of function causing exception */\n"
"    double arg1;      /* 1st argument to function */\n"
"    double arg2;      /* 2nd argument to function */\n"
"    double retval;    /* Function return value */\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/matherr.3:105
msgid "The I<type> field has one of the following values:"
msgstr ""

#. type: TP
#: man-pages/man3/matherr.3:105
#, no-wrap
msgid "B<DOMAIN>"
msgstr ""

#. type: Plain text
#: man-pages/man3/matherr.3:113
msgid ""
"A domain error occurred (the function argument was outside the range for "
"which the function is defined).  The return value depends on the function; "
"I<errno> is set to B<EDOM>."
msgstr ""

#. type: TP
#: man-pages/man3/matherr.3:113
#, no-wrap
msgid "B<SING>"
msgstr ""

#. type: Plain text
#: man-pages/man3/matherr.3:124
msgid ""
"A pole error occurred (the function result is an infinity).  The return "
"value in most cases is B<HUGE> (the largest single precision floating-point "
"number), appropriately signed.  In most cases, I<errno> is set to B<EDOM>."
msgstr ""

#. type: TP
#: man-pages/man3/matherr.3:124
#, no-wrap
msgid "B<OVERFLOW>"
msgstr ""

#. type: Plain text
#: man-pages/man3/matherr.3:133
msgid ""
"An overflow occurred.  In most cases, the value B<HUGE> is returned, and "
"I<errno> is set to B<ERANGE>."
msgstr ""

#. type: TP
#: man-pages/man3/matherr.3:133
#, no-wrap
msgid "B<UNDERFLOW>"
msgstr ""

#. type: Plain text
#: man-pages/man3/matherr.3:140
msgid ""
"An underflow occurred.  0.0 is returned, and I<errno> is set to B<ERANGE>."
msgstr ""

#. type: TP
#: man-pages/man3/matherr.3:140
#, no-wrap
msgid "B<TLOSS>"
msgstr ""

#. type: Plain text
#: man-pages/man3/matherr.3:147
msgid ""
"Total loss of significance.  0.0 is returned, and I<errno> is set to "
"B<ERANGE>."
msgstr ""

#. type: TP
#: man-pages/man3/matherr.3:147
#, no-wrap
msgid "B<PLOSS>"
msgstr ""

#. type: Plain text
#: man-pages/man3/matherr.3:152
msgid ""
"Partial loss of significance.  This value is unused on glibc (and many other"
" systems)."
msgstr ""

#. type: Plain text
#: man-pages/man3/matherr.3:160
msgid ""
"The I<arg1> and I<arg2> fields are the arguments supplied to the function "
"(I<arg2> is undefined for functions that take only one argument)."
msgstr ""

#. type: Plain text
#: man-pages/man3/matherr.3:168
msgid ""
"The I<retval> field specifies the return value that the math function will "
"return to its caller.  The programmer-defined B<matherr>()  can modify this "
"field to change the return value of the math function."
msgstr ""

#. type: Plain text
#: man-pages/man3/matherr.3:175
msgid ""
"If the B<matherr>()  function returns zero, then the system sets I<errno> as"
" described above, and may print an error message on standard error (see "
"below)."
msgstr ""

#. type: Plain text
#: man-pages/man3/matherr.3:181
msgid ""
"If the B<matherr>()  function returns a nonzero value, then the system does "
"not set I<errno>, and doesn't print an error message."
msgstr ""

#. type: SS
#: man-pages/man3/matherr.3:181
#, no-wrap
msgid "Math functions that employ matherr()"
msgstr ""

#. type: Plain text
#: man-pages/man3/matherr.3:191
msgid ""
"The table below lists the functions and circumstances in which B<matherr>()"
"  is called.  The \"Type\" column indicates the value assigned to "
"I<exc-E<gt>type> when calling B<matherr>().  The \"Result\" column is the "
"default return value assigned to I<exc-E<gt>retval>."
msgstr ""

#. type: Plain text
#: man-pages/man3/matherr.3:197
msgid ""
"The \"Msg?\" and \"errno\" columns describe the default behavior if "
"B<matherr>()  returns zero.  If the \"Msg?\" columns contains \"y\", then "
"the system prints an error message on standard error."
msgstr ""

#. type: Plain text
#: man-pages/man3/matherr.3:199
msgid "The table uses the following notations and abbreviations:"
msgstr ""

#. type: Plain text
#: man-pages/man3/matherr.3:211
#, no-wrap
msgid ""
"x        first argument to function\n"
"y        second argument to function\n"
"fin      finite value for argument\n"
"neg      negative value for argument\n"
"int      integral value for argument\n"
"o/f      result overflowed\n"
"u/f      result underflowed\n"
"|x|      absolute value of x\n"
"X_TLOSS  is a constant defined in I<E<lt>math.hE<gt>>\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/matherr.3:218
#, no-wrap
msgid "Function"
msgstr ""

#. type: tbl table
#: man-pages/man3/matherr.3:218
#, no-wrap
msgid "Type"
msgstr ""

#. type: tbl table
#: man-pages/man3/matherr.3:218
#, no-wrap
msgid "Result"
msgstr ""

#. type: tbl table
#: man-pages/man3/matherr.3:218
#, no-wrap
msgid "Msg?"
msgstr ""

#. type: tbl table
#: man-pages/man3/matherr.3:218
#, no-wrap
msgid "errno"
msgstr ""

#. type: tbl table
#: man-pages/man3/matherr.3:219
#, no-wrap
msgid "acos(|x|E<gt>1)"
msgstr ""

#.  retval is 0.0/0.0
#. type: tbl table
#: man-pages/man3/matherr.3:219 man-pages/man3/matherr.3:220
#: man-pages/man3/matherr.3:221 man-pages/man3/matherr.3:222
#: man-pages/man3/matherr.3:223 man-pages/man3/matherr.3:230
#: man-pages/man3/matherr.3:244 man-pages/man3/matherr.3:245
#: man-pages/man3/matherr.3:246 man-pages/man3/matherr.3:247
#: man-pages/man3/matherr.3:248 man-pages/man3/matherr.3:249
#: man-pages/man3/matherr.3:258 man-pages/man3/matherr.3:260
#: man-pages/man3/matherr.3:262 man-pages/man3/matherr.3:263
#: man-pages/man3/matherr.3:266 man-pages/man3/matherr.3:267
#: man-pages/man3/matherr.3:268 man-pages/man3/matherr.3:274
#: man-pages/man3/matherr.3:275
#, no-wrap
msgid "DOMAIN"
msgstr ""

#. type: tbl table
#: man-pages/man3/matherr.3:219 man-pages/man3/matherr.3:220
#: man-pages/man3/matherr.3:221 man-pages/man3/matherr.3:227
#: man-pages/man3/matherr.3:231 man-pages/man3/matherr.3:232
#: man-pages/man3/matherr.3:234 man-pages/man3/matherr.3:236
#: man-pages/man3/matherr.3:250 man-pages/man3/matherr.3:251
#: man-pages/man3/matherr.3:264
#, no-wrap
msgid "HUGE"
msgstr ""

#.  retval is 0.0/0.0
#. type: tbl table
#: man-pages/man3/matherr.3:219 man-pages/man3/matherr.3:220
#: man-pages/man3/matherr.3:221 man-pages/man3/matherr.3:222
#: man-pages/man3/matherr.3:223 man-pages/man3/matherr.3:224
#: man-pages/man3/matherr.3:230 man-pages/man3/matherr.3:238
#: man-pages/man3/matherr.3:239 man-pages/man3/matherr.3:240
#: man-pages/man3/matherr.3:241 man-pages/man3/matherr.3:242
#: man-pages/man3/matherr.3:243 man-pages/man3/matherr.3:244
#: man-pages/man3/matherr.3:245 man-pages/man3/matherr.3:246
#: man-pages/man3/matherr.3:247 man-pages/man3/matherr.3:248
#: man-pages/man3/matherr.3:249 man-pages/man3/matherr.3:251
#: man-pages/man3/matherr.3:254 man-pages/man3/matherr.3:255
#: man-pages/man3/matherr.3:257 man-pages/man3/matherr.3:258
#: man-pages/man3/matherr.3:261 man-pages/man3/matherr.3:262
#: man-pages/man3/matherr.3:263 man-pages/man3/matherr.3:267
#: man-pages/man3/matherr.3:268 man-pages/man3/matherr.3:274
#: man-pages/man3/matherr.3:275
#, no-wrap
msgid "y"
msgstr ""

#.  retval is 0.0/0.0
#. type: tbl table
#: man-pages/man3/matherr.3:219 man-pages/man3/matherr.3:220
#: man-pages/man3/matherr.3:221 man-pages/man3/matherr.3:222
#: man-pages/man3/matherr.3:223 man-pages/man3/matherr.3:224
#: man-pages/man3/matherr.3:230 man-pages/man3/matherr.3:244
#: man-pages/man3/matherr.3:245 man-pages/man3/matherr.3:246
#: man-pages/man3/matherr.3:247 man-pages/man3/matherr.3:248
#: man-pages/man3/matherr.3:249 man-pages/man3/matherr.3:251
#: man-pages/man3/matherr.3:254 man-pages/man3/matherr.3:257
#: man-pages/man3/matherr.3:258 man-pages/man3/matherr.3:259
#: man-pages/man3/matherr.3:260 man-pages/man3/matherr.3:261
#: man-pages/man3/matherr.3:262 man-pages/man3/matherr.3:263
#: man-pages/man3/matherr.3:266 man-pages/man3/matherr.3:267
#: man-pages/man3/matherr.3:268 man-pages/man3/matherr.3:274
#: man-pages/man3/matherr.3:275
#, no-wrap
msgid "EDOM"
msgstr ""

#. type: tbl table
#: man-pages/man3/matherr.3:220
#, no-wrap
msgid "asin(|x|E<gt>1)"
msgstr ""

#. type: tbl table
#: man-pages/man3/matherr.3:221
#, no-wrap
msgid "atan2(0,0)"
msgstr ""

#.  retval is 0.0/0.0
#. type: tbl table
#: man-pages/man3/matherr.3:222
#, no-wrap
msgid "acosh(xE<lt>1)"
msgstr ""

#.  retval is 0.0/0.0
#. type: tbl table
#: man-pages/man3/matherr.3:222 man-pages/man3/matherr.3:223
#: man-pages/man3/matherr.3:254 man-pages/man3/matherr.3:275
#, no-wrap
msgid "NAN"
msgstr ""

#.  retval is 0.0/0.0
#. type: tbl table
#: man-pages/man3/matherr.3:223
#, no-wrap
msgid "atanh(|x|E<gt>1)"
msgstr ""

#.  retval is x/0.0
#. type: tbl table
#: man-pages/man3/matherr.3:224
#, no-wrap
msgid "atanh(|x|==1)"
msgstr ""

#. type: tbl table
#: man-pages/man3/matherr.3:224 man-pages/man3/matherr.3:251
#: man-pages/man3/matherr.3:254 man-pages/man3/matherr.3:255
#: man-pages/man3/matherr.3:257 man-pages/man3/matherr.3:259
#: man-pages/man3/matherr.3:261
#, no-wrap
msgid "SING"
msgstr ""

#.  retval is x/0.0
#. type: tbl table
#: man-pages/man3/matherr.3:224
#, no-wrap
msgid "(xE<gt>0.0)?"
msgstr ""

#. type: tbl table
#: man-pages/man3/matherr.3:225 man-pages/man3/matherr.3:226
#: man-pages/man3/matherr.3:229 man-pages/man3/matherr.3:256
#: man-pages/man3/matherr.3:270 man-pages/man3/matherr.3:271
#: man-pages/man3/matherr.3:273
#, no-wrap
msgid "\\ "
msgstr ""

#. type: tbl table
#: man-pages/man3/matherr.3:225 man-pages/man3/matherr.3:270
#, no-wrap
msgid "HUGE_VAL :"
msgstr ""

#. type: tbl table
#: man-pages/man3/matherr.3:226 man-pages/man3/matherr.3:271
#, no-wrap
msgid "-HUGE_VAL"
msgstr ""

#. type: tbl table
#: man-pages/man3/matherr.3:227
#, no-wrap
msgid "cosh(fin) o/f"
msgstr ""

#. type: tbl table
#: man-pages/man3/matherr.3:227 man-pages/man3/matherr.3:228
#: man-pages/man3/matherr.3:231 man-pages/man3/matherr.3:232
#: man-pages/man3/matherr.3:234 man-pages/man3/matherr.3:236
#: man-pages/man3/matherr.3:250 man-pages/man3/matherr.3:253
#: man-pages/man3/matherr.3:264 man-pages/man3/matherr.3:269
#, no-wrap
msgid "OVERFLOW"
msgstr ""

#. type: tbl table
#: man-pages/man3/matherr.3:227 man-pages/man3/matherr.3:228
#: man-pages/man3/matherr.3:231 man-pages/man3/matherr.3:232
#: man-pages/man3/matherr.3:233 man-pages/man3/matherr.3:234
#: man-pages/man3/matherr.3:235 man-pages/man3/matherr.3:236
#: man-pages/man3/matherr.3:237 man-pages/man3/matherr.3:250
#: man-pages/man3/matherr.3:253 man-pages/man3/matherr.3:259
#: man-pages/man3/matherr.3:260 man-pages/man3/matherr.3:264
#: man-pages/man3/matherr.3:265 man-pages/man3/matherr.3:266
#: man-pages/man3/matherr.3:269 man-pages/man3/matherr.3:272
#, no-wrap
msgid "n"
msgstr ""

#. type: tbl table
#: man-pages/man3/matherr.3:227 man-pages/man3/matherr.3:228
#: man-pages/man3/matherr.3:231 man-pages/man3/matherr.3:232
#: man-pages/man3/matherr.3:233 man-pages/man3/matherr.3:234
#: man-pages/man3/matherr.3:235 man-pages/man3/matherr.3:236
#: man-pages/man3/matherr.3:237 man-pages/man3/matherr.3:238
#: man-pages/man3/matherr.3:239 man-pages/man3/matherr.3:240
#: man-pages/man3/matherr.3:241 man-pages/man3/matherr.3:242
#: man-pages/man3/matherr.3:243 man-pages/man3/matherr.3:250
#: man-pages/man3/matherr.3:253 man-pages/man3/matherr.3:255
#: man-pages/man3/matherr.3:264 man-pages/man3/matherr.3:265
#: man-pages/man3/matherr.3:269 man-pages/man3/matherr.3:272
#, no-wrap
msgid "ERANGE"
msgstr ""

#. type: tbl table
#: man-pages/man3/matherr.3:228
#, no-wrap
msgid "sinh(fin) o/f"
msgstr ""

#. type: tbl table
#: man-pages/man3/matherr.3:228 man-pages/man3/matherr.3:269
#, no-wrap
msgid "(xE<gt>0.0) ?"
msgstr ""

#. type: tbl table
#: man-pages/man3/matherr.3:229
#, no-wrap
msgid "HUGE : -HUGE"
msgstr ""

#. type: tbl table
#: man-pages/man3/matherr.3:230
#, no-wrap
msgid "sqrt(xE<lt>0)"
msgstr ""

#. type: tbl table
#: man-pages/man3/matherr.3:230 man-pages/man3/matherr.3:233
#: man-pages/man3/matherr.3:235 man-pages/man3/matherr.3:237
#: man-pages/man3/matherr.3:238 man-pages/man3/matherr.3:239
#: man-pages/man3/matherr.3:240 man-pages/man3/matherr.3:241
#: man-pages/man3/matherr.3:242 man-pages/man3/matherr.3:243
#: man-pages/man3/matherr.3:263 man-pages/man3/matherr.3:265
#: man-pages/man3/matherr.3:267 man-pages/man3/matherr.3:268
#, no-wrap
msgid "0.0"
msgstr ""

#. type: tbl table
#: man-pages/man3/matherr.3:231
#, no-wrap
msgid "hypot(fin,fin) o/f"
msgstr ""

#. type: tbl table
#: man-pages/man3/matherr.3:232
#, no-wrap
msgid "exp(fin) o/f"
msgstr ""

#. type: tbl table
#: man-pages/man3/matherr.3:233
#, no-wrap
msgid "exp(fin) u/f"
msgstr ""

#. type: tbl table
#: man-pages/man3/matherr.3:233 man-pages/man3/matherr.3:235
#: man-pages/man3/matherr.3:237 man-pages/man3/matherr.3:265
#: man-pages/man3/matherr.3:272
#, no-wrap
msgid "UNDERFLOW"
msgstr ""

#. type: tbl table
#: man-pages/man3/matherr.3:234
#, no-wrap
msgid "exp2(fin) o/f"
msgstr ""

#. type: tbl table
#: man-pages/man3/matherr.3:235
#, no-wrap
msgid "exp2(fin) u/f"
msgstr ""

#. type: tbl table
#: man-pages/man3/matherr.3:236
#, no-wrap
msgid "exp10(fin) o/f"
msgstr ""

#. type: tbl table
#: man-pages/man3/matherr.3:237
#, no-wrap
msgid "exp10(fin) u/f"
msgstr ""

#. type: tbl table
#: man-pages/man3/matherr.3:238
#, no-wrap
msgid "j0(|x|E<gt>X_TLOSS)"
msgstr ""

#. type: tbl table
#: man-pages/man3/matherr.3:238 man-pages/man3/matherr.3:239
#: man-pages/man3/matherr.3:240 man-pages/man3/matherr.3:241
#: man-pages/man3/matherr.3:242 man-pages/man3/matherr.3:243
#, no-wrap
msgid "TLOSS"
msgstr ""

#. type: tbl table
#: man-pages/man3/matherr.3:239
#, no-wrap
msgid "j1(|x|E<gt>X_TLOSS)"
msgstr ""

#. type: tbl table
#: man-pages/man3/matherr.3:240
#, no-wrap
msgid "jn(|x|E<gt>X_TLOSS)"
msgstr ""

#. type: tbl table
#: man-pages/man3/matherr.3:241
#, no-wrap
msgid "y0(xE<gt>X_TLOSS)"
msgstr ""

#. type: tbl table
#: man-pages/man3/matherr.3:242
#, no-wrap
msgid "y1(xE<gt>X_TLOSS)"
msgstr ""

#. type: tbl table
#: man-pages/man3/matherr.3:243
#, no-wrap
msgid "yn(xE<gt>X_TLOSS)"
msgstr ""

#. type: tbl table
#: man-pages/man3/matherr.3:244
#, no-wrap
msgid "y0(0)"
msgstr ""

#. type: tbl table
#: man-pages/man3/matherr.3:244 man-pages/man3/matherr.3:245
#: man-pages/man3/matherr.3:246 man-pages/man3/matherr.3:247
#: man-pages/man3/matherr.3:248 man-pages/man3/matherr.3:249
#: man-pages/man3/matherr.3:257 man-pages/man3/matherr.3:258
#: man-pages/man3/matherr.3:259 man-pages/man3/matherr.3:260
#: man-pages/man3/matherr.3:261 man-pages/man3/matherr.3:262
#, no-wrap
msgid "-HUGE"
msgstr ""

#. type: tbl table
#: man-pages/man3/matherr.3:245
#, no-wrap
msgid "y0(xE<lt>0)"
msgstr ""

#. type: tbl table
#: man-pages/man3/matherr.3:246
#, no-wrap
msgid "y1(0)"
msgstr ""

#. type: tbl table
#: man-pages/man3/matherr.3:247
#, no-wrap
msgid "y1(xE<lt>0)"
msgstr ""

#. type: tbl table
#: man-pages/man3/matherr.3:248
#, no-wrap
msgid "yn(n,0)"
msgstr ""

#. type: tbl table
#: man-pages/man3/matherr.3:249
#, no-wrap
msgid "yn(xE<lt>0)"
msgstr ""

#. type: tbl table
#: man-pages/man3/matherr.3:250
#, no-wrap
msgid "lgamma(fin) o/f"
msgstr ""

#. type: tbl table
#: man-pages/man3/matherr.3:251
#, no-wrap
msgid "lgamma(-int) or"
msgstr ""

#. type: tbl table
#: man-pages/man3/matherr.3:252
#, no-wrap
msgid "\\ \\ lgamma(0)"
msgstr ""

#. type: tbl table
#: man-pages/man3/matherr.3:253
#, no-wrap
msgid "tgamma(fin) o/f"
msgstr ""

#. type: tbl table
#: man-pages/man3/matherr.3:253
#, no-wrap
msgid "HUGE_VAL"
msgstr ""

#. type: tbl table
#: man-pages/man3/matherr.3:254
#, no-wrap
msgid "tgamma(-int)"
msgstr ""

#. type: tbl table
#: man-pages/man3/matherr.3:255
#, no-wrap
msgid "tgamma(0)"
msgstr ""

#. type: tbl table
#: man-pages/man3/matherr.3:255 man-pages/man3/matherr.3:272
#, no-wrap
msgid "copysign("
msgstr ""

#. type: tbl table
#: man-pages/man3/matherr.3:256
#, no-wrap
msgid "HUGE_VAL,x)"
msgstr ""

#. type: tbl table
#: man-pages/man3/matherr.3:257
#, no-wrap
msgid "log(0)"
msgstr ""

#. type: tbl table
#: man-pages/man3/matherr.3:258
#, no-wrap
msgid "log(xE<lt>0)"
msgstr ""

#.  different from log()
#. type: tbl table
#: man-pages/man3/matherr.3:259
#, no-wrap
msgid "log2(0)"
msgstr ""

#.  different from log()
#. type: tbl table
#: man-pages/man3/matherr.3:260
#, no-wrap
msgid "log2(xE<lt>0)"
msgstr ""

#. type: tbl table
#: man-pages/man3/matherr.3:261
#, no-wrap
msgid "log10(0)"
msgstr ""

#. type: tbl table
#: man-pages/man3/matherr.3:262
#, no-wrap
msgid "log10(xE<lt>0)"
msgstr ""

#. type: tbl table
#: man-pages/man3/matherr.3:263
#, no-wrap
msgid "pow(0.0,0.0)"
msgstr ""

#. type: tbl table
#: man-pages/man3/matherr.3:264
#, no-wrap
msgid "pow(x,y) o/f"
msgstr ""

#. type: tbl table
#: man-pages/man3/matherr.3:265
#, no-wrap
msgid "pow(x,y) u/f"
msgstr ""

#. type: tbl table
#: man-pages/man3/matherr.3:266
#, no-wrap
msgid "pow(NaN,0.0)"
msgstr ""

#. type: tbl table
#: man-pages/man3/matherr.3:266 man-pages/man3/matherr.3:274
#, no-wrap
msgid "x"
msgstr ""

#.  +0 and -0
#. type: tbl table
#: man-pages/man3/matherr.3:267
#, no-wrap
msgid "0**neg"
msgstr ""

#. type: tbl table
#: man-pages/man3/matherr.3:268
#, no-wrap
msgid "neg**non-int"
msgstr ""

#. type: tbl table
#: man-pages/man3/matherr.3:269
#, no-wrap
msgid "scalb() o/f"
msgstr ""

#. type: tbl table
#: man-pages/man3/matherr.3:272
#, no-wrap
msgid "scalb() u/f"
msgstr ""

#. type: tbl table
#: man-pages/man3/matherr.3:273
#, no-wrap
msgid "\\ \\ 0.0,x)"
msgstr ""

#. type: tbl table
#: man-pages/man3/matherr.3:274
#, no-wrap
msgid "fmod(x,0)"
msgstr ""

#.  retval is 0.0/0.0
#. type: tbl table
#: man-pages/man3/matherr.3:275
#, no-wrap
msgid "remainder(x,0)"
msgstr ""

#. type: tbl table
#: man-pages/man3/matherr.3:287
#, no-wrap
msgid "B<matherr>()"
msgstr ""

#. type: Plain text
#: man-pages/man3/matherr.3:310
msgid ""
"The example program demonstrates the use of B<matherr>()  when calling "
"B<log>(3).  The program takes up to three command-line arguments.  The first"
" argument is the floating-point number to be given to B<log>(3).  If the "
"optional second argument is provided, then B<_LIB_VERSION> is set to "
"B<_SVID_> so that B<matherr>()  is called, and the integer supplied in the "
"command-line argument is used as the return value from B<matherr>().  If the"
" optional third command-line argument is supplied, then it specifies an "
"alternative return value that B<matherr>()  should assign as the return "
"value of the math function."
msgstr ""

#. type: Plain text
#: man-pages/man3/matherr.3:315
msgid ""
"The following example run, where B<log>(3)  is given an argument of 0.0, "
"does not use B<matherr>():"
msgstr ""

#. type: Plain text
#: man-pages/man3/matherr.3:321
#, no-wrap
msgid ""
"$B< ./a.out 0.0>\n"
"errno: Numerical result out of range\n"
"x=-inf\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/matherr.3:327
msgid "In the following run, B<matherr>()  is called, and returns 0:"
msgstr ""

#. type: Plain text
#: man-pages/man3/matherr.3:337
#, no-wrap
msgid ""
"$B< ./a.out 0.0 0>\n"
"matherr SING exception in log() function\n"
"        args:   0.000000, 0.000000\n"
"        retval: -340282346638528859811704183484516925440.000000\n"
"log: SING error\n"
"errno: Numerical argument out of domain\n"
"x=-340282346638528859811704183484516925440.000000\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/matherr.3:341
msgid "The message \"log: SING error\" was printed by the C library."
msgstr ""

#. type: Plain text
#: man-pages/man3/matherr.3:345
msgid ""
"In the following run, B<matherr>()  is called, and returns a nonzero value:"
msgstr ""

#. type: Plain text
#: man-pages/man3/matherr.3:353
#, no-wrap
msgid ""
"$B< ./a.out 0.0 1>\n"
"matherr SING exception in log() function\n"
"        args:   0.000000, 0.000000\n"
"        retval: -340282346638528859811704183484516925440.000000\n"
"x=-340282346638528859811704183484516925440.000000\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/matherr.3:359
msgid ""
"In this case, the C library did not print a message, and I<errno> was not "
"set."
msgstr ""

#. type: Plain text
#: man-pages/man3/matherr.3:364
msgid ""
"In the following run, B<matherr>()  is called, changes the return value of "
"the math function, and returns a nonzero value:"
msgstr ""

#. type: Plain text
#: man-pages/man3/matherr.3:372
#, no-wrap
msgid ""
"$B< ./a.out 0.0 1 12345.0>\n"
"matherr SING exception in log() function\n"
"        args:   0.000000, 0.000000\n"
"        retval: -340282346638528859811704183484516925440.000000\n"
"x=12345.000000\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/matherr.3:382
#, no-wrap
msgid ""
"#define _SVID_SOURCE\n"
"#include E<lt>errno.hE<gt>\n"
"#include E<lt>math.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/matherr.3:388
#, no-wrap
msgid ""
"static int matherr_ret = 0;     /* Value that matherr()\n"
"                                   should return */\n"
"static int change_retval = 0;   /* Should matherr() change\n"
"                                   function\\(aqs return value? */\n"
"static double new_retval;       /* New function return value */\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/matherr.3:403
#, no-wrap
msgid ""
"int\n"
"matherr(struct exception *exc)\n"
"{\n"
"    fprintf(stderr, \"matherr %s exception in %s() function\\en\",\n"
"           (exc-E<gt>type == DOMAIN) ?    \"DOMAIN\" :\n"
"           (exc-E<gt>type == OVERFLOW) ?  \"OVERFLOW\" :\n"
"           (exc-E<gt>type == UNDERFLOW) ? \"UNDERFLOW\" :\n"
"           (exc-E<gt>type == SING) ?      \"SING\" :\n"
"           (exc-E<gt>type == TLOSS) ?     \"TLOSS\" :\n"
"           (exc-E<gt>type == PLOSS) ?     \"PLOSS\" : \"???\",\n"
"            exc-E<gt>name);\n"
"    fprintf(stderr, \"        args:   %f, %f\\en\",\n"
"            exc-E<gt>arg1, exc-E<gt>arg2);\n"
"    fprintf(stderr, \"        retval: %f\\en\", exc-E<gt>retval);\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/matherr.3:406
#, no-wrap
msgid ""
"    if (change_retval)\n"
"        exc-E<gt>retval = new_retval;\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/matherr.3:409
#, no-wrap
msgid ""
"    return matherr_ret;\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/matherr.3:414
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    double x;\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/matherr.3:420
#, no-wrap
msgid ""
"    if (argc E<lt> 2) {\n"
"        fprintf(stderr, \"Usage: %s E<lt>argvalE<gt>\"\n"
"                \" [E<lt>matherr-retE<gt> [E<lt>new-func-retvalE<gt>]]\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/matherr.3:425
#, no-wrap
msgid ""
"    if (argc E<gt> 2) {\n"
"        _LIB_VERSION = _SVID_;\n"
"        matherr_ret = atoi(argv[2]);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/matherr.3:430
#, no-wrap
msgid ""
"    if (argc E<gt> 3) {\n"
"        change_retval = 1;\n"
"        new_retval = atof(argv[3]);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/matherr.3:434
#, no-wrap
msgid ""
"    x = log(atof(argv[1]));\n"
"    if (errno != 0)\n"
"        perror(\"errno\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/matherr.3:438
#, no-wrap
msgid ""
"    printf(\"x=%f\\en\", x);\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/matherr.3:442
msgid "B<fenv>(3), B<math_error>(7), B<standards>(7)"
msgstr ""

#. type: TH
#: man-pages/man3/mktemp.3:34
#, no-wrap
msgid "MKTEMP"
msgstr ""

#. type: Plain text
#: man-pages/man3/mktemp.3:37
msgid "mktemp - make a unique temporary filename"
msgstr ""

#. type: Plain text
#: man-pages/man3/mktemp.3:42
#, no-wrap
msgid "B<char *mktemp(char *>I<template>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/mktemp.3:50
msgid "B<mktemp>():"
msgstr ""

#. type: TP
#: man-pages/man3/mktemp.3:53
#, no-wrap
msgid "Since glibc 2.12:"
msgstr ""

#. type: Plain text
#: man-pages/man3/mktemp.3:58
#, no-wrap
msgid ""
"(_XOPEN_SOURCE\\ E<gt>=\\ 500) && ! (_POSIX_C_SOURCE\\ E<gt>=\\ 200112L)\n"
"    || /* Glibc since 2.19: */ _DEFAULT_SOURCE\n"
"    || /* Glibc E<lt>= 2.19: */ _SVID_SOURCE || _BSD_SOURCE\n"
msgstr ""

#. type: TP
#: man-pages/man3/mktemp.3:58
#, no-wrap
msgid "Before glibc 2.12:"
msgstr ""

#.     || _XOPEN_SOURCE\ &&\ _XOPEN_SOURCE_EXTENDED
#. type: Plain text
#: man-pages/man3/mktemp.3:62
msgid "_BSD_SOURCE || _SVID_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 500"
msgstr ""

#. type: Plain text
#: man-pages/man3/mktemp.3:68
msgid "I<Never use this function>; see BUGS."
msgstr ""

#. type: Plain text
#: man-pages/man3/mktemp.3:79
msgid ""
"The B<mktemp>()  function generates a unique temporary filename from "
"I<template>.  The last six characters of I<template> must be XXXXXX and "
"these are replaced with a string that makes the filename unique.  Since it "
"will be modified, I<template> must not be a string constant, but should be "
"declared as a character array."
msgstr ""

#. type: Plain text
#: man-pages/man3/mktemp.3:90
msgid ""
"The B<mktemp>()  function always returns I<template>.  If a unique name was "
"created, the last six bytes of I<template> will have been modified in such a"
" way that the resulting name is unique (i.e., does not exist already)  If a "
"unique name could not be created, I<template> is made an empty string, and "
"I<errno> is set to indicate the error."
msgstr ""

#. type: Plain text
#: man-pages/man3/mktemp.3:94
msgid "The last six characters of I<template> were not XXXXXX."
msgstr ""

#. type: tbl table
#: man-pages/man3/mktemp.3:104
#, no-wrap
msgid "B<mktemp>()"
msgstr ""

#.  .SH NOTES
#.  The prototype is in
#.  .I <unistd.h>
#.  for libc4, libc5, glibc1; glibc2 follows the Single UNIX Specification
#.  and has the prototype in
#.  .IR <stdlib.h> .
#. type: Plain text
#: man-pages/man3/mktemp.3:116
msgid ""
"4.3BSD, POSIX.1-2001.  POSIX.1-2008 removes the specification of "
"B<mktemp>()."
msgstr ""

#. type: Plain text
#: man-pages/man3/mktemp.3:131
msgid ""
"Never use B<mktemp>().  Some implementations follow 4.3BSD and replace "
"XXXXXX by the current process ID and a single letter, so that at most 26 "
"different names can be returned.  Since on the one hand the names are easy "
"to guess, and on the other hand there is a race between testing whether the "
"name exists and opening the file, every use of B<mktemp>()  is a security "
"risk.  The race is avoided by B<mkstemp>(3)  and B<mkdtemp>(3)."
msgstr ""

#. type: Plain text
#: man-pages/man3/mktemp.3:137
msgid ""
"B<mktemp>(1), B<mkdtemp>(3), B<mkstemp>(3), B<tempnam>(3), B<tmpfile>(3), "
"B<tmpnam>(3)"
msgstr ""

#. type: TH
#: man-pages/man3/mkdtemp.3:26
#, no-wrap
msgid "MKDTEMP"
msgstr ""

#. type: TH
#: man-pages/man3/mkdtemp.3:26
#, no-wrap
msgid "2016-07-17"
msgstr ""

#. type: Plain text
#: man-pages/man3/mkdtemp.3:29
msgid "mkdtemp - create a unique temporary directory"
msgstr ""

#. type: Plain text
#: man-pages/man3/mkdtemp.3:34
#, no-wrap
msgid "B<char *mkdtemp(char *>I<template>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/mkdtemp.3:42
msgid "B<mkdtemp>():"
msgstr ""

#. type: Plain text
#: man-pages/man3/mkdtemp.3:47
msgid "/* Since glibc 2.19: */ _DEFAULT_SOURCE"
msgstr ""

#. type: Plain text
#: man-pages/man3/mkdtemp.3:49
msgid "|| /* Glibc 2.19 and earlier: */ _BSD_SOURCE"
msgstr ""

#. type: Plain text
#: man-pages/man3/mkdtemp.3:52
msgid "|| /* Since glibc 2.10: */ _POSIX_C_SOURCE\\ E<gt>=\\ 200809L"
msgstr ""

#. type: Plain text
#: man-pages/man3/mkdtemp.3:68
msgid ""
"The B<mkdtemp>()  function generates a uniquely named temporary directory "
"from I<template>.  The last six characters of I<template> must be XXXXXX and"
" these are replaced with a string that makes the directory name unique.  The"
" directory is then created with permissions 0700.  Since it will be "
"modified, I<template> must not be a string constant, but should be declared "
"as a character array."
msgstr ""

#. type: Plain text
#: man-pages/man3/mkdtemp.3:75
msgid ""
"The B<mkdtemp>()  function returns a pointer to the modified template string"
" on success, and NULL on failure, in which case I<errno> is set "
"appropriately."
msgstr ""

#. type: Plain text
#: man-pages/man3/mkdtemp.3:80
msgid ""
"The last six characters of I<template> were not XXXXXX.  Now I<template> is "
"unchanged."
msgstr ""

#. type: Plain text
#: man-pages/man3/mkdtemp.3:84
msgid "Also see B<mkdir>(2)  for other possible values for I<errno>."
msgstr ""

#. type: Plain text
#: man-pages/man3/mkdtemp.3:86
msgid "Available since glibc 2.1.91."
msgstr ""

#. type: tbl table
#: man-pages/man3/mkdtemp.3:96
#, no-wrap
msgid "B<mkdtemp>()"
msgstr ""

#.  As at 2006, this function is being considered for a revision of POSIX.1
#.  Also in NetBSD 1.4.
#. type: Plain text
#: man-pages/man3/mkdtemp.3:103
msgid "POSIX.1-2008.  This function is present on the BSDs."
msgstr ""

#. type: Plain text
#: man-pages/man3/mkdtemp.3:110
msgid ""
"B<mktemp>(1), B<mkdir>(2), B<mkstemp>(3), B<mktemp>(3), B<tempnam>(3), "
"B<tmpfile>(3), B<tmpnam>(3)"
msgstr ""

#. type: TH
#: man-pages/man3/mcheck.3:25
#, no-wrap
msgid "MCHECK"
msgstr ""

#. type: Plain text
#: man-pages/man3/mcheck.3:28
msgid ""
"mcheck, mcheck_check_all, mcheck_pedantic, mprobe - heap consistency "
"checking"
msgstr ""

#. type: Plain text
#: man-pages/man3/mcheck.3:31
#, no-wrap
msgid "B<#include E<lt>mcheck.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/mcheck.3:33
#, no-wrap
msgid ""
"B<int mcheck(void (*>I<abortfunc>B<)(enum mcheck_status >I<mstatus>B<));>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/mcheck.3:35
#, no-wrap
msgid ""
"B<int mcheck_pedantic(void (*>I<abortfunc>B<)(enum mcheck_status "
">I<mstatus>B<));>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/mcheck.3:37
#, no-wrap
msgid "B<void mcheck_check_all(void);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/mcheck.3:39
#, no-wrap
msgid "B<enum mcheck_status mprobe(void *>I<ptr>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/mcheck.3:51
msgid ""
"The B<mcheck>()  function installs a set of debugging hooks for the "
"B<malloc>(3)  family of memory-allocation functions.  These hooks cause "
"certain consistency checks to be performed on the state of the heap.  The "
"checks can detect application errors such as freeing a block of memory more "
"than once or corrupting the bookkeeping data structures that immediately "
"precede a block of allocated memory."
msgstr ""

#. type: Plain text
#: man-pages/man3/mcheck.3:63
msgid ""
"To be effective, the B<mcheck>()  function must be called before the first "
"call to B<malloc>(3)  or a related function.  In cases where this is "
"difficult to ensure, linking the program with I<-lmcheck> inserts an "
"implicit call to B<mcheck>()  (with a NULL argument)  before the first call "
"to a memory-allocation function."
msgstr ""

#. type: Plain text
#: man-pages/man3/mcheck.3:71
msgid ""
"The B<mcheck_pedantic>()  function is similar to B<mcheck>(), but performs "
"checks on all allocated blocks whenever one of the memory-allocation "
"functions is called.  This can be very slow!"
msgstr ""

#. type: Plain text
#: man-pages/man3/mcheck.3:78
msgid ""
"The B<mcheck_check_all>()  function causes an immediate check on all "
"allocated blocks.  This call is effective only if B<mcheck>()  is called "
"beforehand."
msgstr ""

#. type: Plain text
#: man-pages/man3/mcheck.3:91
msgid ""
"If the system detects an inconsistency in the heap, the caller-supplied "
"function pointed to by I<abortfunc> is invoked with a single argument, "
"I<mstatus>, that indicates what type of inconsistency was detected.  If "
"I<abortfunc> is NULL, a default function prints an error message on "
"I<stderr> and calls B<abort>(3)."
msgstr ""

#. type: Plain text
#: man-pages/man3/mcheck.3:103
msgid ""
"The B<mprobe>()  function performs a consistency check on the block of "
"allocated memory pointed to by I<ptr>.  The B<mcheck>()  function should be "
"called beforehand (otherwise B<mprobe>()  returns B<MCHECK_DISABLED>)."
msgstr ""

#. type: Plain text
#: man-pages/man3/mcheck.3:111
msgid ""
"The following list describes the values returned by B<mprobe>()  or passed "
"as the I<mstatus> argument when I<abortfunc> is invoked:"
msgstr ""

#. type: TP
#: man-pages/man3/mcheck.3:111
#, no-wrap
msgid "B<MCHECK_DISABLED> (B<mprobe>() only)"
msgstr ""

#. type: Plain text
#: man-pages/man3/mcheck.3:116
msgid ""
"B<mcheck>()  was not called before the first memory allocation function was "
"called.  Consistency checking is not possible."
msgstr ""

#. type: TP
#: man-pages/man3/mcheck.3:116
#, no-wrap
msgid "B<MCHECK_OK> (B<mprobe>() only)"
msgstr ""

#. type: Plain text
#: man-pages/man3/mcheck.3:119
msgid "No inconsistency detected."
msgstr ""

#. type: TP
#: man-pages/man3/mcheck.3:119
#, no-wrap
msgid "B<MCHECK_HEAD>"
msgstr ""

#. type: Plain text
#: man-pages/man3/mcheck.3:122
msgid "Memory preceding an allocated block was clobbered."
msgstr ""

#. type: TP
#: man-pages/man3/mcheck.3:122
#, no-wrap
msgid "B<MCHECK_TAIL>"
msgstr ""

#. type: Plain text
#: man-pages/man3/mcheck.3:125
msgid "Memory following an allocated block was clobbered."
msgstr ""

#. type: TP
#: man-pages/man3/mcheck.3:125
#, no-wrap
msgid "B<MCHECK_FREE>"
msgstr ""

#. type: Plain text
#: man-pages/man3/mcheck.3:129
msgid "A block of memory was freed twice."
msgstr ""

#. type: Plain text
#: man-pages/man3/mcheck.3:134
msgid ""
"B<mcheck>()  and B<mcheck_pedantic>()  return 0 on success, or -1 on error."
msgstr ""

#. type: Plain text
#: man-pages/man3/mcheck.3:145
msgid ""
"The B<mcheck_pedantic>()  and B<mcheck_check_all>()  functions are available"
" since glibc 2.2.  The B<mcheck>()  and B<mprobe>()  functions are present "
"since at least glibc 2.0"
msgstr ""

#. type: tbl table
#: man-pages/man3/mcheck.3:156
#, no-wrap
msgid ""
"B<mcheck>(),\n"
"B<mcheck_pedantic>(),\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/mcheck.3:156 man-pages/man3/mcheck.3:161
#, no-wrap
msgid ".br\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/mcheck.3:159
#, no-wrap
msgid ""
"B<mcheck_check_all>(),\n"
"B<mprobe>()"
msgstr ""

#. type: tbl table
#: man-pages/man3/mcheck.3:161
#, no-wrap
msgid "MT-Unsafe race:mcheck\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/mcheck.3:163
#, no-wrap
msgid "const:malloc_hooks"
msgstr ""

#. type: Plain text
#: man-pages/man3/mcheck.3:168
msgid "These functions are GNU extensions."
msgstr ""

#.  But is MALLOC_CHECK_ slower?
#. type: Plain text
#: man-pages/man3/mcheck.3:180
msgid ""
"Linking a program with I<-lmcheck> and using the B<MALLOC_CHECK_> "
"environment variable (described in B<mallopt>(3))  cause the same kinds of "
"errors to be detected.  But, using B<MALLOC_CHECK_> does not require the "
"application to be relinked."
msgstr ""

#. type: Plain text
#: man-pages/man3/mcheck.3:186
msgid ""
"The program below calls B<mcheck>()  with a NULL argument and then frees the"
" same block of memory twice.  The following shell session demonstrates what "
"happens when running the program:"
msgstr ""

#. type: Plain text
#: man-pages/man3/mcheck.3:191
#, no-wrap
msgid ""
"$B< ./a.out>\n"
"About to free\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/mcheck.3:195
#, no-wrap
msgid ""
"About to free a second time\n"
"block freed twice\n"
"Aborted (core dumped)\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/mcheck.3:203
#, no-wrap
msgid ""
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>mcheck.hE<gt>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/mcheck.3:208
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    char *p;\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/mcheck.3:211
#, no-wrap
msgid ""
"    if (mcheck(NULL) != 0) {\n"
"        fprintf(stderr, \"mcheck() failed\\en\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/mcheck.3:214
#, no-wrap
msgid ""
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/mcheck.3:216
#, no-wrap
msgid "    p = malloc(1000);\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/mcheck.3:221
#, no-wrap
msgid ""
"    fprintf(stderr, \"About to free\\en\");\n"
"    free(p);\n"
"    fprintf(stderr, \"\\enAbout to free a second time\\en\");\n"
"    free(p);\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/mcheck.3:228
msgid "B<malloc>(3), B<mallopt>(3), B<mtrace>(3)"
msgstr ""

#. type: TH
#: man-pages/man3/mallopt.3:26
#, no-wrap
msgid "MALLOPT"
msgstr ""

#. type: Plain text
#: man-pages/man3/mallopt.3:29
msgid "mallopt - set memory allocation parameters"
msgstr ""

#. type: Plain text
#: man-pages/man3/mallopt.3:31
msgid "B<#include E<lt>malloc.hE<gt>>"
msgstr ""

#. type: Plain text
#: man-pages/man3/mallopt.3:33
msgid "B<int mallopt(int >I<param>B<, int >I<value>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man3/mallopt.3:44
msgid ""
"The B<mallopt>()  function adjusts parameters that control the behavior of "
"the memory-allocation functions (see B<malloc>(3)).  The I<param> argument "
"specifies the parameter to be modified, and I<value> specifies the new value"
" for that parameter."
msgstr ""

#. type: Plain text
#: man-pages/man3/mallopt.3:47
msgid "The following values can be specified for I<param>:"
msgstr ""

#. type: TP
#: man-pages/man3/mallopt.3:47
#, no-wrap
msgid "B<M_ARENA_MAX>"
msgstr ""

#. type: Plain text
#: man-pages/man3/mallopt.3:59
msgid ""
"If this parameter has a nonzero value, it defines a hard limit on the "
"maximum number of arenas that can be created.  An arena represents a pool of"
" memory that can be used by B<malloc>(3)  (and similar) calls to service "
"allocation requests.  Arenas are thread safe and therefore may have multiple"
" concurrent memory requests.  The trade-off is between the number of threads"
" and the number of arenas.  The more arenas you have, the lower the per-"
"thread contention, but the higher the memory usage."
msgstr ""

#. type: Plain text
#: man-pages/man3/mallopt.3:64
msgid ""
"The default value of this parameter is 0, meaning that the limit on the "
"number of arenas is determined according to the setting of B<M_ARENA_TEST>."
msgstr ""

#. type: Plain text
#: man-pages/man3/mallopt.3:70
msgid ""
"This parameter has been available since glibc 2.10 via B<--enable-"
"experimental-malloc>, and since glibc 2.15 by default.  In some versions of "
"the allocator there was no limit on the number of created arenas (e.g., "
"CentOS 5, RHEL 5)."
msgstr ""

#. type: Plain text
#: man-pages/man3/mallopt.3:78
msgid ""
"When employing newer glibc versions, applications may in some cases exhibit "
"high contention when accessing arenas.  In these cases, it may be beneficial"
" to increase B<M_ARENA_MAX> to match the number of threads.  This is similar"
" in behavior to strategies taken by tcmalloc and jemalloc (e.g., per-thread "
"allocation pools)."
msgstr ""

#. type: TP
#: man-pages/man3/mallopt.3:78
#, no-wrap
msgid "B<M_ARENA_TEST>"
msgstr ""

#. type: Plain text
#: man-pages/man3/mallopt.3:86
msgid ""
"This parameter specifies a value, in number of arenas created, at which "
"point the system configuration will be examined to determine a hard limit on"
" the number of created arenas.  (See B<M_ARENA_MAX> for the definition of an"
" arena.)"
msgstr ""

#. type: Plain text
#: man-pages/man3/mallopt.3:91
msgid ""
"The computation of the arena hard limit is implementation-defined and is "
"usually calculated as a multiple of the number of available CPUs.  Once the "
"hard limit is computed, the result is final and constrains the total number "
"of arenas."
msgstr ""

#. type: Plain text
#: man-pages/man3/mallopt.3:97
msgid ""
"The default value for the B<M_ARENA_TEST> parameter is 2 on systems where "
"I<sizeof(long)> is 4; otherwise the default value is 8."
msgstr ""

#. type: Plain text
#: man-pages/man3/mallopt.3:101
msgid ""
"This parameter has been available since glibc 2.10 via B<--enable-"
"experimental-malloc>, and since glibc 2.15 by default."
msgstr ""

#. type: Plain text
#: man-pages/man3/mallopt.3:107
msgid ""
"The value of B<M_ARENA_TEST> is not used when B<M_ARENA_MAX> has a nonzero "
"value."
msgstr ""

#. type: TP
#: man-pages/man3/mallopt.3:107
#, no-wrap
msgid "B<M_CHECK_ACTION>"
msgstr ""

#. type: Plain text
#: man-pages/man3/mallopt.3:113
msgid ""
"Setting this parameter controls how glibc responds when various kinds of "
"programming errors are detected (e.g., freeing the same pointer twice).  The"
" 3 least significant bits (2, 1, and 0) of the value assigned to this "
"parameter determine the glibc behavior, as follows:"
msgstr ""

#. type: TP
#: man-pages/man3/mallopt.3:114
#, no-wrap
msgid "Bit 0"
msgstr ""

#. type: Plain text
#: man-pages/man3/mallopt.3:124
msgid ""
"If this bit is set, then print a one-line message on I<stderr> that provides"
" details about the error.  The message starts with the string \"***\\ glibc "
"detected\\ ***\", followed by the program name, the name of the memory-"
"allocation function in which the error was detected, a brief description of "
"the error, and the memory address where the error was detected."
msgstr ""

#. type: TP
#: man-pages/man3/mallopt.3:124
#, no-wrap
msgid "Bit 1"
msgstr ""

#. type: Plain text
#: man-pages/man3/mallopt.3:139
msgid ""
"If this bit is set, then, after printing any error message specified by bit "
"0, the program is terminated by calling B<abort>(3).  In glibc versions "
"since 2.4, if bit 0 is also set, then, between printing the error message "
"and aborting, the program also prints a stack trace in the manner of "
"B<backtrace>(3), and prints the process's memory mapping in the style of "
"I</proc/[pid]/maps> (see B<proc>(5))."
msgstr ""

#. type: TP
#: man-pages/man3/mallopt.3:139
#, no-wrap
msgid "Bit 2 (since glibc 2.4)"
msgstr ""

#. type: Plain text
#: man-pages/man3/mallopt.3:146
msgid ""
"This bit has an effect only if bit 0 is also set.  If this bit is set, then "
"the one-line message describing the error is simplified to contain just the "
"name of the function where the error was detected and the brief description "
"of the error."
msgstr ""

#. type: Plain text
#: man-pages/man3/mallopt.3:151
msgid "The remaining bits in I<value> are ignored."
msgstr ""

#. type: Plain text
#: man-pages/man3/mallopt.3:155
msgid ""
"Combining the above details, the following numeric values are meaningful for"
" B<M_CHECK_ACTION>:"
msgstr ""

#. type: Plain text
#: man-pages/man3/mallopt.3:158
msgid "Ignore error conditions; continue execution (with undefined results)."
msgstr ""

#. type: Plain text
#: man-pages/man3/mallopt.3:160
msgid "Print a detailed error message and continue execution."
msgstr ""

#. type: Plain text
#: man-pages/man3/mallopt.3:162
msgid "Abort the program."
msgstr ""

#. type: Plain text
#: man-pages/man3/mallopt.3:165
msgid ""
"Print detailed error message, stack trace, and memory mappings, and abort "
"the program."
msgstr ""

#. type: Plain text
#: man-pages/man3/mallopt.3:167
msgid "Print a simple error message and continue execution."
msgstr ""

#. type: Plain text
#: man-pages/man3/mallopt.3:170
msgid ""
"Print simple error message, stack trace, and memory mappings, and abort the "
"program."
msgstr ""

#. type: Plain text
#: man-pages/man3/mallopt.3:176
msgid ""
"Since glibc 2.3.4, the default value for the B<M_CHECK_ACTION> parameter is "
"3.  In glibc version 2.3.3 and earlier, the default value is 1."
msgstr ""

#. type: Plain text
#: man-pages/man3/mallopt.3:181
msgid ""
"Using a nonzero B<M_CHECK_ACTION> value can be useful because otherwise a "
"crash may happen much later, and the true cause of the problem is then very "
"hard to track down."
msgstr ""

#. type: TP
#: man-pages/man3/mallopt.3:181
#, no-wrap
msgid "B<M_MMAP_MAX>"
msgstr ""

#.  The following text adapted from comments in the glibc source:
#. type: Plain text
#: man-pages/man3/mallopt.3:191
msgid ""
"This parameter specifies the maximum number of allocation requests that may "
"be simultaneously serviced using B<mmap>(2).  This parameter exists because "
"some systems have a limited number of internal tables for use by B<mmap>(2),"
" and using more than a few of them may degrade performance."
msgstr ""

#. type: Plain text
#: man-pages/man3/mallopt.3:198
msgid ""
"The default value is 65,536, a value which has no special significance and "
"which serves only as a safeguard.  Setting this parameter to 0 disables the "
"use of B<mmap>(2)  for servicing large allocation requests."
msgstr ""

#. type: TP
#: man-pages/man3/mallopt.3:198
#, no-wrap
msgid "B<M_MMAP_THRESHOLD>"
msgstr ""

#. type: Plain text
#: man-pages/man3/mallopt.3:207
msgid ""
"For allocations greater than or equal to the limit specified (in bytes) by "
"B<M_MMAP_THRESHOLD> that can't be satisfied from the free list, the memory-"
"allocation functions employ B<mmap>(2)  instead of increasing the program "
"break using B<sbrk>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man3/mallopt.3:227
msgid ""
"Allocating memory using B<mmap>(2)  has the significant advantage that the "
"allocated memory blocks can always be independently released back to the "
"system.  (By contrast, the heap can be trimmed only if memory is freed at "
"the top end.)  On the other hand, there are some disadvantages to the use of"
" B<mmap>(2): deallocated space is not placed on the free list for reuse by "
"later allocations; memory may be wasted because B<mmap>(2)  allocations must"
" be page-aligned; and the kernel must perform the expensive task of zeroing "
"out memory allocated via B<mmap>(2).  Balancing these factors leads to a "
"default setting of 128*1024 for the B<M_MMAP_THRESHOLD> parameter."
msgstr ""

#. type: Plain text
#: man-pages/man3/mallopt.3:234
msgid ""
"The lower limit for this parameter is 0.  The upper limit is "
"B<DEFAULT_MMAP_THRESHOLD_MAX>: 512*1024 on 32-bit systems or "
"I<4*1024*1024*sizeof(long)> on 64-bit systems."
msgstr ""

#. type: Plain text
#: man-pages/man3/mallopt.3:252
msgid ""
"I<Note:> Nowadays, glibc uses a dynamic mmap threshold by default.  The "
"initial value of the threshold is 128*1024, but when blocks larger than the "
"current threshold and less than or equal to B<DEFAULT_MMAP_THRESHOLD_MAX> "
"are freed, the threshold is adjusted upward to the size of the freed block."
"  When dynamic mmap thresholding is in effect, the threshold for trimming "
"the heap is also dynamically adjusted to be twice the dynamic mmap "
"threshold.  Dynamic adjustment of the mmap threshold is disabled if any of "
"the B<M_TRIM_THRESHOLD>, B<M_TOP_PAD>, B<M_MMAP_THRESHOLD>, or B<M_MMAP_MAX>"
" parameters is set."
msgstr ""

#. type: TP
#: man-pages/man3/mallopt.3:252
#, no-wrap
msgid "B<M_MXFAST> (since glibc 2.3)"
msgstr ""

#.  The following text adapted from comments in the glibc sources:
#. type: Plain text
#: man-pages/man3/mallopt.3:264
msgid ""
"Set the upper limit for memory allocation requests that are satisfied using "
"\"fastbins\".  (The measurement unit for this parameter is bytes.)  Fastbins"
" are storage areas that hold deallocated blocks of memory of the same size "
"without merging adjacent free blocks.  Subsequent reallocation of blocks of "
"the same size can be handled very quickly by allocating from the fastbin, "
"although memory fragmentation and the overall memory footprint of the "
"program can increase."
msgstr ""

#. type: Plain text
#: man-pages/man3/mallopt.3:273
msgid ""
"The default value for this parameter is I<64*sizeof(size_t)/4> (i.e., 64 on "
"32-bit architectures).  The range for this parameter is 0 to "
"I<80*sizeof(size_t)/4>.  Setting B<M_MXFAST> to 0 disables the use of "
"fastbins."
msgstr ""

#. type: TP
#: man-pages/man3/mallopt.3:273
#, no-wrap
msgid "B<M_PERTURB> (since glibc 2.4)"
msgstr ""

#. type: Plain text
#: man-pages/man3/mallopt.3:288
msgid ""
"If this parameter is set to a nonzero value, then bytes of allocated memory "
"(other than allocations via B<calloc>(3))  are initialized to the complement"
" of the value in the least significant byte of I<value>, and when allocated "
"memory is released using B<free>(3), the freed bytes are set to the least "
"significant byte of I<value>.  This can be useful for detecting errors where"
" programs incorrectly rely on allocated memory being initialized to zero, or"
" reuse values in memory that has already been freed."
msgstr ""

#. type: Plain text
#: man-pages/man3/mallopt.3:290
msgid "The default value for this parameter is 0."
msgstr ""

#. type: TP
#: man-pages/man3/mallopt.3:290
#, no-wrap
msgid "B<M_TOP_PAD>"
msgstr ""

#. type: Plain text
#: man-pages/man3/mallopt.3:297
msgid ""
"This parameter defines the amount of padding to employ when calling "
"B<sbrk>(2)  to modify the program break.  (The measurement unit for this "
"parameter is bytes.)  This parameter has an effect in the following "
"circumstances:"
msgstr ""

#. type: Plain text
#: man-pages/man3/mallopt.3:304
msgid ""
"When the program break is increased, then B<M_TOP_PAD> bytes are added to "
"the B<sbrk>(2)  request."
msgstr ""

#. type: Plain text
#: man-pages/man3/mallopt.3:310
msgid ""
"When the heap is trimmed as a consequence of calling B<free>(3)  (see the "
"discussion of B<M_TRIM_THRESHOLD>)  this much free space is preserved at the"
" top of the heap."
msgstr ""

#. type: Plain text
#: man-pages/man3/mallopt.3:314
msgid ""
"In either case, the amount of padding is always rounded to a system page "
"boundary."
msgstr ""

#. type: Plain text
#: man-pages/man3/mallopt.3:321
msgid ""
"Modifying B<M_TOP_PAD> is a trade-off between increasing the number of "
"system calls (when the parameter is set low)  and wasting unused memory at "
"the top of the heap (when the parameter is set high)."
msgstr ""

#.  DEFAULT_TOP_PAD in glibc source
#. type: Plain text
#: man-pages/man3/mallopt.3:324
msgid "The default value for this parameter is 128*1024."
msgstr ""

#. type: TP
#: man-pages/man3/mallopt.3:324
#, no-wrap
msgid "B<M_TRIM_THRESHOLD>"
msgstr ""

#. type: Plain text
#: man-pages/man3/mallopt.3:340
msgid ""
"When the amount of contiguous free memory at the top of the heap grows "
"sufficiently large, B<free>(3)  employs B<sbrk>(2)  to release this memory "
"back to the system.  (This can be useful in programs that continue to "
"execute for a long period after freeing a significant amount of memory.)  "
"The B<M_TRIM_THRESHOLD> parameter specifies the minimum size (in bytes) that"
" this block of memory must reach before B<sbrk>(2)  is used to trim the "
"heap."
msgstr ""

#. type: Plain text
#: man-pages/man3/mallopt.3:345
msgid ""
"The default value for this parameter is 128*1024.  Setting "
"B<M_TRIM_THRESHOLD> to -1 disables trimming completely."
msgstr ""

#. type: Plain text
#: man-pages/man3/mallopt.3:353
msgid ""
"Modifying B<M_TRIM_THRESHOLD> is a trade-off between increasing the number "
"of system calls (when the parameter is set low)  and wasting unused memory "
"at the top of the heap (when the parameter is set high)."
msgstr ""

#. type: SS
#: man-pages/man3/mallopt.3:353
#, no-wrap
msgid "Environment variables"
msgstr ""

#. type: Plain text
#: man-pages/man3/mallopt.3:368
msgid ""
"A number of environment variables can be defined to modify some of the same "
"parameters as are controlled by B<mallopt>().  Using these variables has the"
" advantage that the source code of the program need not be changed.  To be "
"effective, these variables must be defined before the first call to a "
"memory-allocation function.  (If the same parameters are adjusted via "
"B<mallopt>(), then the B<mallopt>()  settings take precedence.)  For "
"security reasons, these variables are ignored in set-user-ID and set-group-"
"ID programs."
msgstr ""

#. type: Plain text
#: man-pages/man3/mallopt.3:371
msgid ""
"The environment variables are as follows (note the trailing underscore at "
"the end of the name of some variables):"
msgstr ""

#. type: TP
#: man-pages/man3/mallopt.3:371
#, no-wrap
msgid "B<MALLOC_ARENA_MAX>"
msgstr ""

#. type: Plain text
#: man-pages/man3/mallopt.3:376
msgid "Controls the same parameter as B<mallopt>()  B<M_ARENA_MAX>."
msgstr ""

#. type: TP
#: man-pages/man3/mallopt.3:376
#, no-wrap
msgid "B<MALLOC_ARENA_TEST>"
msgstr ""

#. type: Plain text
#: man-pages/man3/mallopt.3:381
msgid "Controls the same parameter as B<mallopt>()  B<M_ARENA_TEST>."
msgstr ""

#. type: TP
#: man-pages/man3/mallopt.3:381
#, no-wrap
msgid "B<MALLOC_CHECK_>"
msgstr ""

#.  On glibc 2.12/x86, a simple malloc()+free() loop is about 70% slower
#.  when MALLOC_CHECK_ was set.
#. type: Plain text
#: man-pages/man3/mallopt.3:398
msgid ""
"This environment variable controls the same parameter as B<mallopt>()  "
"B<M_CHECK_ACTION>.  If this variable is set to a nonzero value, then a "
"special implementation of the memory-allocation functions is used.  (This is"
" accomplished using the B<malloc_hook>(3)  feature.)  This implementation "
"performs additional error checking, but is slower than the standard set of "
"memory-allocation functions.  (This implementation does not detect all "
"possible errors; memory leaks can still occur.)"
msgstr ""

#. type: Plain text
#: man-pages/man3/mallopt.3:403
msgid ""
"The value assigned to this environment variable should be a single digit, "
"whose meaning is as described for B<M_CHECK_ACTION>.  Any characters beyond "
"the initial digit are ignored."
msgstr ""

#. type: Plain text
#: man-pages/man3/mallopt.3:412
msgid ""
"For security reasons, the effect of B<MALLOC_CHECK_> is disabled by default "
"for set-user-ID and set-group-ID programs.  However, if the file I</etc"
"/suid-debug> exists (the content of the file is irrelevant), then "
"B<MALLOC_CHECK_> also has an effect for set-user-ID and set-group-ID "
"programs."
msgstr ""

#. type: TP
#: man-pages/man3/mallopt.3:412
#, no-wrap
msgid "B<MALLOC_MMAP_MAX_>"
msgstr ""

#. type: Plain text
#: man-pages/man3/mallopt.3:417
msgid "Controls the same parameter as B<mallopt>()  B<M_MMAP_MAX>."
msgstr ""

#. type: TP
#: man-pages/man3/mallopt.3:417
#, no-wrap
msgid "B<MALLOC_MMAP_THRESHOLD_>"
msgstr ""

#. type: Plain text
#: man-pages/man3/mallopt.3:422
msgid "Controls the same parameter as B<mallopt>()  B<M_MMAP_THRESHOLD>."
msgstr ""

#. type: TP
#: man-pages/man3/mallopt.3:422
#, no-wrap
msgid "B<MALLOC_PERTURB_>"
msgstr ""

#. type: Plain text
#: man-pages/man3/mallopt.3:427
msgid "Controls the same parameter as B<mallopt>()  B<M_PERTURB>."
msgstr ""

#. type: TP
#: man-pages/man3/mallopt.3:427
#, no-wrap
msgid "B<MALLOC_TRIM_THRESHOLD_>"
msgstr ""

#. type: Plain text
#: man-pages/man3/mallopt.3:432
msgid "Controls the same parameter as B<mallopt>()  B<M_TRIM_THRESHOLD>."
msgstr ""

#. type: TP
#: man-pages/man3/mallopt.3:432
#, no-wrap
msgid "B<MALLOC_TOP_PAD_>"
msgstr ""

#. type: Plain text
#: man-pages/man3/mallopt.3:437
msgid "Controls the same parameter as B<mallopt>()  B<M_TOP_PAD>."
msgstr ""

#. type: Plain text
#: man-pages/man3/mallopt.3:442
msgid "On success, B<mallopt>()  returns 1.  On error, it returns 0."
msgstr ""

#.  .SH VERSIONS
#.  Available already in glibc 2.0, possibly earlier
#. type: Plain text
#: man-pages/man3/mallopt.3:450
msgid "On error, I<errno> is I<not> set."
msgstr ""

#.  .SH NOTES
#. type: Plain text
#: man-pages/man3/mallopt.3:464
msgid ""
"This function is not specified by POSIX or the C standards.  A similar "
"function exists on many System V derivatives, but the range of values for "
"I<param> varies across systems.  The SVID defined options B<M_MXFAST>, "
"B<M_NLBLKS>, B<M_GRAIN>, and B<M_KEEP>, but only the first of these is "
"implemented in glibc."
msgstr ""

#. type: Plain text
#: man-pages/man3/mallopt.3:468
msgid "Specifying an invalid value for I<param> does not generate an error."
msgstr ""

#.  FIXME . This looks buggy:
#.  setting the M_MXFAST limit rounds up:    (s + SIZE_SZ) &
#. ~MALLOC_ALIGN_MASK)
#.  malloc requests are rounded up:
#.     (req) + SIZE_SZ + MALLOC_ALIGN_MASK) & ~MALLOC_ALIGN_MASK
#.  http://sources.redhat.com/bugzilla/show_bug.cgi?id=12129
#. type: Plain text
#: man-pages/man3/mallopt.3:476
msgid ""
"A calculation error within the glibc implementation means that a call of the"
" form:"
msgstr ""

#. type: Plain text
#: man-pages/man3/mallopt.3:480
#, no-wrap
msgid "mallopt(M_MXFAST, n)\n"
msgstr ""

#.  Bins are multiples of 2 * sizeof(size_t) + sizeof(size_t)
#. type: Plain text
#: man-pages/man3/mallopt.3:493
msgid ""
"does not result in fastbins being employed for all allocations of size up to"
" I<n>.  To ensure desired results, I<n> should be rounded up to the next "
"multiple greater than or equal to I<(2k+1)*sizeof(size_t)>, where I<k> is an"
" integer."
msgstr ""

#.  FIXME . http://sources.redhat.com/bugzilla/show_bug.cgi?id=12140
#. type: Plain text
#: man-pages/man3/mallopt.3:514
msgid ""
"If B<mallopt>()  is used to set B<M_PERTURB>, then, as expected, the bytes "
"of allocated memory are initialized to the complement of the byte in "
"I<value>, and when that memory is freed, the bytes of the region are "
"initialized to the byte specified in I<value>.  However, there is an off-"
"by-I<sizeof(size_t)> error in the implementation: instead of initializing "
"precisely the block of memory being freed by the call I<free(p)>, the block "
"starting at I<p+sizeof(size_t)> is initialized."
msgstr ""

#. type: Plain text
#: man-pages/man3/mallopt.3:523
msgid ""
"The program below demonstrates the use of B<M_CHECK_ACTION>.  If the program"
" is supplied with an (integer) command-line argument, then that argument is "
"used to set the B<M_CHECK_ACTION> parameter.  The program then allocates a "
"block of memory, and frees it twice (an error)."
msgstr ""

#. type: Plain text
#: man-pages/man3/mallopt.3:527
msgid ""
"The following shell session shows what happens when we run this program "
"under glibc, with the default value for B<M_CHECK_ACTION>:"
msgstr ""

#. type: Plain text
#: man-pages/man3/mallopt.3:547
#, no-wrap
msgid ""
"$ B<./a.out>\n"
"main(): returned from first free() call\n"
"*** glibc detected *** ./a.out: double free or corruption (top): 0x09d30008 ***\n"
"======= Backtrace: =========\n"
"/lib/libc.so.6(+0x6c501)[0x523501]\n"
"/lib/libc.so.6(+0x6dd70)[0x524d70]\n"
"/lib/libc.so.6(cfree+0x6d)[0x527e5d]\n"
"\\&./a.out[0x80485db]\n"
"/lib/libc.so.6(__libc_start_main+0xe7)[0x4cdce7]\n"
"\\&./a.out[0x8048471]\n"
"======= Memory map: ========\n"
"001e4000-001fe000 r-xp 00000000 08:06 1083555    /lib/libgcc_s.so.1\n"
"001fe000-001ff000 r--p 00019000 08:06 1083555    /lib/libgcc_s.so.1\n"
"[some lines omitted]\n"
"b7814000-b7817000 rw-p 00000000 00:00 0\n"
"bff53000-bff74000 rw-p 00000000 00:00 0          [stack]\n"
"Aborted (core dumped)\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/mallopt.3:552
msgid ""
"The following runs show the results when employing other values for "
"B<M_CHECK_ACTION>:"
msgstr ""

#. type: Plain text
#: man-pages/man3/mallopt.3:565
#, no-wrap
msgid ""
"$ B<./a.out 1>             # Diagnose error and continue\n"
"main(): returned from first free() call\n"
"*** glibc detected *** ./a.out: double free or corruption (top): 0x09cbe008 ***\n"
"main(): returned from second free() call\n"
"$ B<./a.out 2>             # Abort without error message\n"
"main(): returned from first free() call\n"
"Aborted (core dumped)\n"
"$ B<./a.out 0>             # Ignore error and continue\n"
"main(): returned from first free() call\n"
"main(): returned from second free() call\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/mallopt.3:571
msgid ""
"The next run shows how to set the same parameter using the B<MALLOC_CHECK_> "
"environment variable:"
msgstr ""

#. type: Plain text
#: man-pages/man3/mallopt.3:578
#, no-wrap
msgid ""
"$ B<MALLOC_CHECK_=1 ./a.out>\n"
"main(): returned from first free() call\n"
"*** glibc detected *** ./a.out: free(): invalid pointer: 0x092c2008 ***\n"
"main(): returned from second free() call\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/mallopt.3:586
#, no-wrap
msgid ""
"#include E<lt>malloc.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/mallopt.3:598
#, no-wrap
msgid ""
"    if (argc E<gt> 1) {\n"
"        if (mallopt(M_CHECK_ACTION, atoi(argv[1])) != 1) {\n"
"            fprintf(stderr, \"mallopt() failed\");\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/mallopt.3:604
#, no-wrap
msgid ""
"    p = malloc(1000);\n"
"    if (p == NULL) {\n"
"        fprintf(stderr, \"malloc() failed\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/mallopt.3:607
#, no-wrap
msgid ""
"    free(p);\n"
"    printf(\"main(): returned from first free() call\\en\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/mallopt.3:610
#, no-wrap
msgid ""
"    free(p);\n"
"    printf(\"main(): returned from second free() call\\en\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/mallopt.3:627
msgid ""
"B<mmap>(2), B<sbrk>(2), B<mallinfo>(3), B<malloc>(3), B<malloc_hook>(3), "
"B<malloc_info>(3), B<malloc_stats>(3), B<malloc_trim>(3), B<mcheck>(3), "
"B<mtrace>(3), B<posix_memalign>(3)"
msgstr ""

#. type: TH
#: man-pages/man3/memfrob.3:30
#, no-wrap
msgid "MEMFROB"
msgstr ""

#. type: TH
#: man-pages/man3/memfrob.3:30
#, no-wrap
msgid "2017-03-13"
msgstr ""

#. type: Plain text
#: man-pages/man3/memfrob.3:33
msgid "memfrob - frobnicate (encrypt) a memory area"
msgstr ""

#. type: Plain text
#: man-pages/man3/memfrob.3:37
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>             /* See feature_test_macros(7) */\n"
"B<#include E<lt>string.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/memfrob.3:39
#, no-wrap
msgid "B<void *memfrob(void *>I<s>B<, size_t >I<n>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/memfrob.3:50
msgid ""
"The B<memfrob>()  function encrypts the first I<n> bytes of the memory area "
"I<s> by exclusive-ORing each character with the number 42.  The effect can "
"be reversed by using B<memfrob>()  on the encrypted memory area."
msgstr ""

#. type: Plain text
#: man-pages/man3/memfrob.3:53
msgid ""
"Note that this function is not a proper encryption routine as the XOR "
"constant is fixed, and is suitable only for hiding strings."
msgstr ""

#. type: Plain text
#: man-pages/man3/memfrob.3:58
msgid ""
"The B<memfrob>()  function returns a pointer to the encrypted memory area."
msgstr ""

#. type: tbl table
#: man-pages/man3/memfrob.3:68
#, no-wrap
msgid "B<memfrob>()"
msgstr ""

#. type: Plain text
#: man-pages/man3/memfrob.3:75
msgid "The B<memfrob>()  function is unique to the GNU C Library."
msgstr ""

#. type: Plain text
#: man-pages/man3/memfrob.3:77
msgid "B<bstring>(3), B<strfry>(3)"
msgstr ""

#. type: TH
#: man-pages/man3/mq_send.3:26
#, no-wrap
msgid "MQ_SEND"
msgstr ""

#. type: Plain text
#: man-pages/man3/mq_send.3:29
msgid "mq_send, mq_timedsend - send a message to a message queue"
msgstr ""

#. type: Plain text
#: man-pages/man3/mq_send.3:35
#, no-wrap
msgid ""
"B<int mq_send(mqd_t >I<mqdes>B<, const char *>I<msg_ptr>B<,>\n"
"B<              size_t >I<msg_len>B<, unsigned int >I<msg_prio>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/mq_send.3:42
#, no-wrap
msgid ""
"B<int mq_timedsend(mqd_t >I<mqdes>B<, const char *>I<msg_ptr>B<,>\n"
"B<              size_t >I<msg_len>B<, unsigned int >I<msg_prio>B<,>\n"
"B<              const struct timespec *>I<abs_timeout>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/mq_send.3:53
msgid "B<mq_timedsend>():"
msgstr ""

#. type: Plain text
#: man-pages/man3/mq_send.3:71
msgid ""
"B<mq_send>()  adds the message pointed to by I<msg_ptr> to the message queue"
" referred to by the message queue descriptor I<mqdes>.  The I<msg_len> "
"argument specifies the length of the message pointed to by I<msg_ptr>; this "
"length must be less than or equal to the queue's I<mq_msgsize> attribute.  "
"Zero-length messages are allowed."
msgstr ""

#. type: Plain text
#: man-pages/man3/mq_send.3:82
msgid ""
"The I<msg_prio> argument is a nonnegative integer that specifies the "
"priority of this message.  Messages are placed on the queue in decreasing "
"order of priority, with newer messages of the same priority being placed "
"after older messages with the same priority.  See B<mq_overview>(7)  for "
"details on the range for the message priority."
msgstr ""

#. type: Plain text
#: man-pages/man3/mq_send.3:95
msgid ""
"If the message queue is already full (i.e., the number of messages on the "
"queue equals the queue's I<mq_maxmsg> attribute), then, by default, "
"B<mq_send>()  blocks until sufficient space becomes available to allow the "
"message to be queued, or until the call is interrupted by a signal handler."
"  If the B<O_NONBLOCK> flag is enabled for the message queue description, "
"then the call instead fails immediately with the error B<EAGAIN>."
msgstr ""

#. type: Plain text
#: man-pages/man3/mq_send.3:107
msgid ""
"B<mq_timedsend>()  behaves just like B<mq_send>(), except that if the queue "
"is full and the B<O_NONBLOCK> flag is not enabled for the message queue "
"description, then I<abs_timeout> points to a structure which specifies how "
"long the call will block.  This value is an absolute timeout in seconds and "
"nanoseconds since the Epoch, 1970-01-01 00:00:00 +0000 (UTC), specified in "
"the following structure:"
msgstr ""

#. type: Plain text
#: man-pages/man3/mq_send.3:121
msgid ""
"If the message queue is full, and the timeout has already expired by the "
"time of the call, B<mq_timedsend>()  returns immediately."
msgstr ""

#. type: Plain text
#: man-pages/man3/mq_send.3:129
msgid ""
"On success, B<mq_send>()  and B<mq_timedsend>()  return zero; on error, -1 "
"is returned, with I<errno> set to indicate the error."
msgstr ""

#. type: Plain text
#: man-pages/man3/mq_send.3:136
msgid ""
"The queue was full, and the B<O_NONBLOCK> flag was set for the message queue"
" description referred to by I<mqdes>."
msgstr ""

#. type: Plain text
#: man-pages/man3/mq_send.3:141
msgid ""
"The descriptor specified in I<mqdes> was invalid or not opened for writing."
msgstr ""

#. type: Plain text
#: man-pages/man3/mq_send.3:160
msgid ""
"I<msg_len> was greater than the I<mq_msgsize> attribute of the message "
"queue."
msgstr ""

#. type: tbl table
#: man-pages/man3/mq_send.3:174
#, no-wrap
msgid ""
"B<mq_send>(),\n"
"B<mq_timedsend>()"
msgstr ""

#. type: Plain text
#: man-pages/man3/mq_send.3:184
msgid ""
"On Linux, B<mq_timedsend>()  is a system call, and B<mq_send>()  is a "
"library function layered on top of that system call."
msgstr ""

#. type: Plain text
#: man-pages/man3/mq_send.3:192
msgid ""
"B<mq_close>(3), B<mq_getattr>(3), B<mq_notify>(3), B<mq_open>(3), "
"B<mq_receive>(3), B<mq_unlink>(3), B<mq_overview>(7), B<time>(7)"
msgstr ""

#. type: TH
#: man-pages/man3/mempcpy.3:10
#, no-wrap
msgid "MEMPCPY"
msgstr ""

#. type: TH
#: man-pages/man3/mempcpy.3:10
#, no-wrap
msgid "2015-03-02"
msgstr ""

#. type: Plain text
#: man-pages/man3/mempcpy.3:13
msgid "mempcpy, wmempcpy - copy memory area"
msgstr ""

#. type: Plain text
#: man-pages/man3/mempcpy.3:17
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>         /* See feature_test_macros(7) */\n"
"B<#include E<lt>string.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/mempcpy.3:19
#, no-wrap
msgid ""
"B<void *mempcpy(void *>I<dest>B<, const void *>I<src>B<, size_t >I<n>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/mempcpy.3:22
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>         /* See feature_test_macros(7) */\n"
"B<#include E<lt>wchar.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/mempcpy.3:24
#, no-wrap
msgid ""
"B<wchar_t *wmempcpy(wchar_t *>I<dest>B<, const wchar_t *>I<src>B<, size_t "
">I<n>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/mempcpy.3:40
msgid ""
"The B<mempcpy>()  function is nearly identical to the B<memcpy>(3)  "
"function.  It copies I<n> bytes from the object beginning at I<src> into the"
" object pointed to by I<dest>.  But instead of returning the value of "
"I<dest> it returns a pointer to the byte following the last written byte."
msgstr ""

#. type: Plain text
#: man-pages/man3/mempcpy.3:43
msgid ""
"This function is useful in situations where a number of objects shall be "
"copied to consecutive memory positions."
msgstr ""

#. type: Plain text
#: man-pages/man3/mempcpy.3:51
msgid ""
"The B<wmempcpy>()  function is identical but takes I<wchar_t> type arguments"
" and copies I<n> wide characters."
msgstr ""

#. type: Plain text
#: man-pages/man3/mempcpy.3:55
msgid "I<dest> + I<n>."
msgstr ""

#. type: Plain text
#: man-pages/man3/mempcpy.3:58
msgid "B<mempcpy>()  first appeared in glibc in version 2.1."
msgstr ""

#. type: tbl table
#: man-pages/man3/mempcpy.3:69
#, no-wrap
msgid ""
"B<mempcpy>(),\n"
"B<wmempcpy>()"
msgstr ""

#. type: Plain text
#: man-pages/man3/mempcpy.3:73
msgid "This function is a GNU extension."
msgstr ""

#. type: Plain text
#: man-pages/man3/mempcpy.3:83
#, no-wrap
msgid ""
"void *\n"
"combine(void *o1, size_t s1, void *o2, size_t s2)\n"
"{\n"
"    void *result = malloc(s1 + s2);\n"
"    if (result != NULL)\n"
"        mempcpy(mempcpy(result, o1, s1), o2, s2);\n"
"    return result;\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/mempcpy.3:88
msgid "B<memccpy>(3), B<memcpy>(3), B<memmove>(3), B<wmemcpy>(3)"
msgstr ""

#. type: TH
#: man-pages/man3/malloc_trim.3:26
#, no-wrap
msgid "MALLOC_TRIM"
msgstr ""

#. type: TH
#: man-pages/man3/malloc_trim.3:26
#, no-wrap
msgid "2019-05-09"
msgstr ""

#. type: Plain text
#: man-pages/man3/malloc_trim.3:29
msgid "malloc_trim - release free memory from the heap"
msgstr ""

#. type: Plain text
#: man-pages/man3/malloc_trim.3:33
msgid "B<int malloc_trim(size_t >I<pad>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man3/malloc_trim.3:42
msgid ""
"The B<malloc_trim>()  function attempts to release free memory from the heap"
" (by calling B<sbrk>(2)  or B<madvise>(2)  with suitable arguments)."
msgstr ""

#. type: Plain text
#: man-pages/man3/malloc_trim.3:53
msgid ""
"The I<pad> argument specifies the amount of free space to leave untrimmed at"
" the top of the heap.  If this argument is 0, only the minimum amount of "
"memory is maintained at the top of the heap (i.e., one page or less).  A "
"nonzero argument can be used to maintain some trailing space at the top of "
"the heap in order to allow future allocations to be made without having to "
"extend the heap with B<sbrk>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man3/malloc_trim.3:58
msgid ""
"The B<malloc_trim>()  function returns 1 if memory was actually released "
"back to the system, or 0 if it was not possible to release any memory."
msgstr ""

#.  .SH VERSIONS
#.  Available already in glibc 2.0, possibly earlier
#. type: Plain text
#: man-pages/man3/malloc_trim.3:62
msgid "No errors are defined."
msgstr ""

#. type: tbl table
#: man-pages/man3/malloc_trim.3:72
#, no-wrap
msgid "B<malloc_trim>()"
msgstr ""

#. type: Plain text
#: man-pages/man3/malloc_trim.3:86
msgid ""
"This function is automatically called by B<free>(3)  in certain "
"circumstances; see the discussion of B<M_TOP_PAD> and B<M_TRIM_THRESHOLD> in"
" B<mallopt>(3)."
msgstr ""

#. type: Plain text
#: man-pages/man3/malloc_trim.3:92
msgid ""
"Only the main heap (using B<sbrk>(2))  honors the I<pad> argument; thread "
"heaps do not."
msgstr ""

#.  See commit 68631c8eb92ff38d9da1ae34f6aa048539b199cc
#.  (dated 2007-12-16) which adds iteration over all
#.  arenas and frees all pages in chunks which are free.
#. type: Plain text
#: man-pages/man3/malloc_trim.3:98
msgid ""
"Since glibc 2.8 this function frees memory in all arenas and in all chunks "
"with whole free pages."
msgstr ""

#. type: Plain text
#: man-pages/man3/malloc_trim.3:101
msgid ""
"Before glibc 2.8 this function only freed memory at the top of the heap in "
"the main arena."
msgstr ""

#. type: Plain text
#: man-pages/man3/malloc_trim.3:104
msgid "B<sbrk>(2), B<malloc>(3), B<mallopt>(3)"
msgstr ""

#. type: TH
#: man-pages/man3/mbrtowc.3:17
#, no-wrap
msgid "MBRTOWC"
msgstr ""

#. type: Plain text
#: man-pages/man3/mbrtowc.3:20
msgid "mbrtowc - convert a multibyte sequence to a wide character"
msgstr ""

#. type: Plain text
#: man-pages/man3/mbrtowc.3:23
#, no-wrap
msgid "B<#include E<lt>wchar.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/mbrtowc.3:26
#, no-wrap
msgid ""
"B<size_t mbrtowc(wchar_t *>I<pwc>B<, const char *>I<s>B<, size_t >I<n>B<, "
"mbstate_t *>I<ps>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/mbrtowc.3:54
msgid ""
"The main case for this function is when I<s> is not NULL and I<pwc> is not "
"NULL.  In this case, the B<mbrtowc>()  function inspects at most I<n> bytes "
"of the multibyte string starting at I<s>, extracts the next complete "
"multibyte character, converts it to a wide character and stores it at "
"I<*pwc>.  It updates the shift state I<*ps>.  If the converted wide "
"character is not L\\(aq\\e0\\(aq (the null wide character), it returns the "
"number of bytes that were consumed from I<s>.  If the converted wide "
"character is L\\(aq\\e0\\(aq, it resets the shift state I<*ps> to the "
"initial state and returns 0."
msgstr ""

#. type: Plain text
#: man-pages/man3/mbrtowc.3:70
msgid ""
"If the I<n> bytes starting at I<s> do not contain a complete multibyte "
"character, B<mbrtowc>()  returns I<(size_t)\\ -2>.  This can happen even if "
"I<n> E<gt>= I<MB_CUR_MAX>, if the multibyte string contains redundant shift "
"sequences."
msgstr ""

#. type: Plain text
#: man-pages/man3/mbrtowc.3:86
msgid ""
"If the multibyte string starting at I<s> contains an invalid multibyte "
"sequence before the next complete character, B<mbrtowc>()  returns "
"I<(size_t)\\ -1> and sets I<errno> to B<EILSEQ>.  In this case, the effects "
"on I<*ps> are undefined."
msgstr ""

#. type: Plain text
#: man-pages/man3/mbrtowc.3:96
msgid ""
"A different case is when I<s> is not NULL but I<pwc> is NULL.  In this case,"
" the B<mbrtowc>()  function behaves as above, except that it does not store "
"the converted wide character in memory."
msgstr ""

#. type: Plain text
#: man-pages/man3/mbrtowc.3:128
msgid ""
"A third case is when I<s> is NULL.  In this case, I<pwc> and I<n> are "
"ignored.  If the conversion state represented by I<*ps> denotes an "
"incomplete multibyte character conversion, the B<mbrtowc>()  function "
"returns I<(size_t)\\ -1>, sets I<errno> to B<EILSEQ>, and leaves I<*ps> in "
"an undefined state.  Otherwise, the B<mbrtowc>()  function puts I<*ps> in "
"the initial state and returns 0."
msgstr ""

#. type: Plain text
#: man-pages/man3/mbrtowc.3:146
msgid ""
"In all of the above cases, if I<ps> is NULL, a static anonymous state known "
"only to the B<mbrtowc>()  function is used instead.  Otherwise, I<*ps> must "
"be a valid I<mbstate_t> object.  An I<mbstate_t> object I<a> can be "
"initialized to the initial state by zeroing it, for example using"
msgstr ""

#. type: Plain text
#: man-pages/man3/mbrtowc.3:150
#, no-wrap
msgid "memset(&a, 0, sizeof(a));\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/mbrtowc.3:175
msgid ""
"The B<mbrtowc>()  function returns the number of bytes parsed from the "
"multibyte sequence starting at I<s>, if a non-L\\(aq\\e0\\(aq wide character"
" was recognized.  It returns 0, if a L\\(aq\\e0\\(aq wide character was "
"recognized.  It returns I<(size_t)\\ -1> and sets I<errno> to B<EILSEQ>, if "
"an invalid multibyte sequence was encountered.  It returns I<(size_t)\\ -2> "
"if it couldn't parse a complete multibyte character, meaning that I<n> "
"should be increased."
msgstr ""

#. type: tbl table
#: man-pages/man3/mbrtowc.3:185
#, no-wrap
msgid "B<mbrtowc>()"
msgstr ""

#. type: tbl table
#: man-pages/man3/mbrtowc.3:185
#, no-wrap
msgid "MT-Unsafe race:mbrtowc/!ps"
msgstr ""

#. type: Plain text
#: man-pages/man3/mbrtowc.3:196
msgid ""
"The behavior of B<mbrtowc>()  depends on the B<LC_CTYPE> category of the "
"current locale."
msgstr ""

#. type: Plain text
#: man-pages/man3/mbrtowc.3:198
msgid "B<mbsinit>(3), B<mbsrtowcs>(3)"
msgstr ""

#. type: TH
#: man-pages/man3/memccpy.3:30
#, no-wrap
msgid "MEMCCPY"
msgstr ""

#. type: Plain text
#: man-pages/man3/memccpy.3:33
msgid "memccpy - copy memory area"
msgstr ""

#. type: Plain text
#: man-pages/man3/memccpy.3:38
#, no-wrap
msgid ""
"B<void *memccpy(void *>I<dest>B<, const void *>I<src>B<, int >I<c>B<, size_t"
" >I<n>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/memccpy.3:53
msgid ""
"The B<memccpy>()  function copies no more than I<n> bytes from memory area "
"I<src> to memory area I<dest>, stopping when the character I<c> is found."
msgstr ""

#. type: Plain text
#: man-pages/man3/memccpy.3:55
msgid "If the memory areas overlap, the results are undefined."
msgstr ""

#. type: Plain text
#: man-pages/man3/memccpy.3:70
msgid ""
"The B<memccpy>()  function returns a pointer to the next character in "
"I<dest> after I<c>, or NULL if I<c> was not found in the first I<n> "
"characters of I<src>."
msgstr ""

#. type: tbl table
#: man-pages/man3/memccpy.3:80
#, no-wrap
msgid "B<memccpy>()"
msgstr ""

#. type: Plain text
#: man-pages/man3/memccpy.3:84
msgid "POSIX.1-2001, POSIX.1-2008, SVr4, 4.3BSD."
msgstr ""

#. type: Plain text
#: man-pages/man3/memccpy.3:90
msgid ""
"B<bcopy>(3), B<bstring>(3), B<memcpy>(3), B<memmove>(3), B<strcpy>(3), "
"B<strncpy>(3)"
msgstr ""

#. type: TH
#: man-pages/man3/mblen.3:16
#, no-wrap
msgid "MBLEN"
msgstr ""

#. type: TH
#: man-pages/man3/mblen.3:16
#, no-wrap
msgid "2015-08-08"
msgstr ""

#. type: Plain text
#: man-pages/man3/mblen.3:19
msgid "mblen - determine number of bytes in next multibyte character"
msgstr ""

#. type: Plain text
#: man-pages/man3/mblen.3:24
#, no-wrap
msgid "B<int mblen(const char *>I<s>B<, size_t >I<n>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/mblen.3:43
msgid ""
"If I<s> is not NULL, the B<mblen>()  function inspects at most I<n> bytes of"
" the multibyte string starting at I<s> and extracts the next complete "
"multibyte character.  It uses a static anonymous shift state known only to "
"the B<mblen>()  function.  If the multibyte character is not the null wide "
"character, it returns the number of bytes that were consumed from I<s>.  If "
"the multibyte character is the null wide character, it returns 0."
msgstr ""

#. type: Plain text
#: man-pages/man3/mblen.3:57
msgid ""
"If the I<n> bytes starting at I<s> do not contain a complete multibyte "
"character, B<mblen>()  returns -1.  This can happen even if I<n> is greater "
"than or equal to I<MB_CUR_MAX>, if the multibyte string contains redundant "
"shift sequences."
msgstr ""

#. type: Plain text
#: man-pages/man3/mblen.3:64
msgid ""
"If the multibyte string starting at I<s> contains an invalid multibyte "
"sequence before the next complete character, B<mblen>()  also returns -1."
msgstr ""

#.  The Dinkumware doc and the Single UNIX specification say this, but
#.  glibc doesn't implement this.
#. type: Plain text
#: man-pages/man3/mblen.3:75
msgid ""
"If I<s> is NULL, the B<mblen>()  function resets the shift state, known to "
"only this function, to the initial state, and returns nonzero if the "
"encoding has nontrivial shift state, or zero if the encoding is stateless."
msgstr ""

#. type: Plain text
#: man-pages/man3/mblen.3:87
msgid ""
"The B<mblen>()  function returns the number of bytes parsed from the "
"multibyte sequence starting at I<s>, if a non-null wide character was "
"recognized.  It returns 0, if a null wide character was recognized.  It "
"returns -1, if an invalid multibyte sequence was encountered or if it "
"couldn't parse a complete multibyte character."
msgstr ""

#. type: tbl table
#: man-pages/man3/mblen.3:97
#, no-wrap
msgid "B<mblen>()"
msgstr ""

#. type: Plain text
#: man-pages/man3/mblen.3:108
msgid ""
"The behavior of B<mblen>()  depends on the B<LC_CTYPE> category of the "
"current locale."
msgstr ""

#. type: Plain text
#: man-pages/man3/mblen.3:113
msgid ""
"The function B<mbrlen>(3)  provides a better interface to the same "
"functionality."
msgstr ""

#. type: Plain text
#: man-pages/man3/mblen.3:114
msgid "B<mbrlen>(3)"
msgstr ""

#. type: TH
#: man-pages/man3/mbsrtowcs.3:16
#, no-wrap
msgid "MBSRTOWCS"
msgstr ""

#. type: Plain text
#: man-pages/man3/mbsrtowcs.3:19
msgid "mbsrtowcs - convert a multibyte string to a wide-character string"
msgstr ""

#. type: Plain text
#: man-pages/man3/mbsrtowcs.3:25
#, no-wrap
msgid ""
"B<size_t mbsrtowcs(wchar_t *>I<dest>B<, const char **>I<src>B<,>\n"
"B<                  size_t >I<len>B<, mbstate_t *>I<ps>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/mbsrtowcs.3:55
msgid ""
"If I<dest> is not NULL, the B<mbsrtowcs>()  function converts the multibyte "
"string I<*src> to a wide-character string starting at I<dest>.  At most "
"I<len> wide characters are written to I<dest>.  The shift state I<*ps> is "
"updated.  The conversion is effectively performed by repeatedly calling "
"I<mbrtowc(dest, *src, n, ps)> where I<n> is some positive number, as long as"
" this call succeeds, and then incrementing I<dest> by one and I<*src> by the"
" number of bytes consumed.  The conversion can stop for three reasons:"
msgstr ""

#. type: Plain text
#: man-pages/man3/mbsrtowcs.3:66
msgid ""
"An invalid multibyte sequence has been encountered.  In this case, I<*src> "
"is left pointing to the invalid multibyte sequence, I<(size_t)\\ -1> is "
"returned, and I<errno> is set to B<EILSEQ>."
msgstr ""

#. type: Plain text
#: man-pages/man3/mbsrtowcs.3:77
msgid ""
"I<len> non-L\\(aq\\e0\\(aq wide characters have been stored at I<dest>.  In "
"this case, I<*src> is left pointing to the next multibyte sequence to be "
"converted, and the number of wide characters written to I<dest> is returned."
msgstr ""

#. type: Plain text
#: man-pages/man3/mbsrtowcs.3:90
msgid ""
"The multibyte string has been completely converted, including the "
"terminating null wide character (\\(aq\\e0\\(aq), which has the side effect "
"of bringing back I<*ps> to the initial state.  In this case, I<*src> is set "
"to NULL, and the number of wide characters written to I<dest>, excluding the"
" terminating null wide character, is returned."
msgstr ""

#. type: Plain text
#: man-pages/man3/mbsrtowcs.3:99
msgid ""
"If I<dest> is NULL, I<len> is ignored, and the conversion proceeds as above,"
" except that the converted wide characters are not written out to memory, "
"and that no length limit exists."
msgstr ""

#. type: Plain text
#: man-pages/man3/mbsrtowcs.3:107
msgid ""
"In both of the above cases, if I<ps> is NULL, a static anonymous state known"
" only to the B<mbsrtowcs>()  function is used instead."
msgstr ""

#. type: Plain text
#: man-pages/man3/mbsrtowcs.3:113
msgid ""
"The programmer must ensure that there is room for at least I<len> wide "
"characters at I<dest>."
msgstr ""

#. type: Plain text
#: man-pages/man3/mbsrtowcs.3:126
msgid ""
"The B<mbsrtowcs>()  function returns the number of wide characters that make"
" up the converted part of the wide-character string, not including the "
"terminating null wide character.  If an invalid multibyte sequence was "
"encountered, I<(size_t)\\ -1> is returned, and I<errno> set to B<EILSEQ>."
msgstr ""

#. type: tbl table
#: man-pages/man3/mbsrtowcs.3:136
#, no-wrap
msgid "B<mbsrtowcs>()"
msgstr ""

#. type: tbl table
#: man-pages/man3/mbsrtowcs.3:136
#, no-wrap
msgid "MT-Unsafe race:mbsrtowcs/!ps"
msgstr ""

#. type: Plain text
#: man-pages/man3/mbsrtowcs.3:148
msgid ""
"The behavior of B<mbsrtowcs>()  depends on the B<LC_CTYPE> category of the "
"current locale."
msgstr ""

#. type: Plain text
#: man-pages/man3/mbsrtowcs.3:152
msgid "Passing NULL as I<ps> is not multithread safe."
msgstr ""

#. type: Plain text
#: man-pages/man3/mbsrtowcs.3:157
msgid ""
"B<iconv>(3), B<mbrtowc>(3), B<mbsinit>(3), B<mbsnrtowcs>(3), B<mbstowcs>(3)"
msgstr ""

#. type: TH
#: man-pages/man3/malloc_info.3:25
#, no-wrap
msgid "MALLOC_INFO"
msgstr ""

#. type: Plain text
#: man-pages/man3/malloc_info.3:28
msgid "malloc_info - export malloc state to a stream"
msgstr ""

#. type: Plain text
#: man-pages/man3/malloc_info.3:31
#, no-wrap
msgid "B<#include E<lt>malloc.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/malloc_info.3:33
#, no-wrap
msgid "B<int malloc_info(int >I<options>B<, FILE *>I<stream>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/malloc_info.3:44
msgid ""
"The B<malloc_info>()  function exports an XML string that describes the "
"current state of the memory-allocation implementation in the caller.  The "
"string is printed on the file stream I<stream>.  The exported string "
"includes information about all arenas (see B<malloc>(3))."
msgstr ""

#. type: Plain text
#: man-pages/man3/malloc_info.3:48
msgid "As currently implemented, I<options> must be zero."
msgstr ""

#. type: Plain text
#: man-pages/man3/malloc_info.3:55
msgid ""
"On success, B<malloc_info>()  returns 0; on error, it returns -1, with "
"I<errno> set to indicate the cause."
msgstr ""

#. type: Plain text
#: man-pages/man3/malloc_info.3:60
msgid "I<options> was nonzero."
msgstr ""

#. type: Plain text
#: man-pages/man3/malloc_info.3:63
msgid "B<malloc_info>()  was added to glibc in version 2.10."
msgstr ""

#. type: tbl table
#: man-pages/man3/malloc_info.3:73
#, no-wrap
msgid "B<malloc_info>()"
msgstr ""

#. type: Plain text
#: man-pages/man3/malloc_info.3:84
msgid ""
"The memory-allocation information is provided as an XML string (rather than "
"a C structure)  because the information may change over time (according to "
"changes in the underlying implementation).  The output XML string includes a"
" version field."
msgstr ""

#. type: Plain text
#: man-pages/man3/malloc_info.3:90
msgid ""
"The B<open_memstream>(3)  function can be used to send the output of "
"B<malloc_info>()  directly into a buffer in memory, rather than to a file."
msgstr ""

#. type: Plain text
#: man-pages/man3/malloc_info.3:97
msgid ""
"The B<malloc_info>()  function is designed to address deficiencies in "
"B<malloc_stats>(3)  and B<mallinfo>(3)."
msgstr ""

#. type: Plain text
#: man-pages/man3/malloc_info.3:108
msgid ""
"The program below takes up to four command-line arguments, of which the "
"first three are mandatory.  The first argument specifies the number of "
"threads that the program should create.  All of the threads, including the "
"main thread, allocate the number of blocks of memory specified by the second"
" argument.  The third argument controls the size of the blocks to be "
"allocated.  The main thread creates blocks of this size, the second thread "
"created by the program allocates blocks of twice this size, the third thread"
" allocates blocks of three times this size, and so on."
msgstr ""

#. type: Plain text
#: man-pages/man3/malloc_info.3:115
msgid ""
"The program calls B<malloc_info>()  twice to display the memory-allocation "
"state.  The first call takes place before any threads are created or memory "
"allocated.  The second call is performed after all threads have allocated "
"memory."
msgstr ""

#. type: Plain text
#: man-pages/man3/malloc_info.3:123
msgid ""
"In the following example, the command-line arguments specify the creation of"
" one additional thread, and both the main thread and the additional thread "
"allocate 10000 blocks of memory.  After the blocks of memory have been "
"allocated, B<malloc_info>()  shows the state of two allocation arenas."
msgstr ""

#. type: Plain text
#: man-pages/man3/malloc_info.3:148
#, no-wrap
msgid ""
"$ B<getconf GNU_LIBC_VERSION>\n"
"glibc 2.13\n"
"$ B<./a.out 1 10000 100>\n"
"============ Before allocating blocks ============\n"
"E<lt>malloc version=\"1\"E<gt>\n"
"E<lt>heap nr=\"0\"E<gt>\n"
"E<lt>sizesE<gt>\n"
"E<lt>/sizesE<gt>\n"
"E<lt>total type=\"fast\" count=\"0\" size=\"0\"/E<gt>\n"
"E<lt>total type=\"rest\" count=\"0\" size=\"0\"/E<gt>\n"
"E<lt>system type=\"current\" size=\"135168\"/E<gt>\n"
"E<lt>system type=\"max\" size=\"135168\"/E<gt>\n"
"E<lt>aspace type=\"total\" size=\"135168\"/E<gt>\n"
"E<lt>aspace type=\"mprotect\" size=\"135168\"/E<gt>\n"
"E<lt>/heapE<gt>\n"
"E<lt>total type=\"fast\" count=\"0\" size=\"0\"/E<gt>\n"
"E<lt>total type=\"rest\" count=\"0\" size=\"0\"/E<gt>\n"
"E<lt>system type=\"current\" size=\"135168\"/E<gt>\n"
"E<lt>system type=\"max\" size=\"135168\"/E<gt>\n"
"E<lt>aspace type=\"total\" size=\"135168\"/E<gt>\n"
"E<lt>aspace type=\"mprotect\" size=\"135168\"/E<gt>\n"
"E<lt>/mallocE<gt>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/malloc_info.3:178
#, no-wrap
msgid ""
"============ After allocating blocks ============\n"
"E<lt>malloc version=\"1\"E<gt>\n"
"E<lt>heap nr=\"0\"E<gt>\n"
"E<lt>sizesE<gt>\n"
"E<lt>/sizesE<gt>\n"
"E<lt>total type=\"fast\" count=\"0\" size=\"0\"/E<gt>\n"
"E<lt>total type=\"rest\" count=\"0\" size=\"0\"/E<gt>\n"
"E<lt>system type=\"current\" size=\"1081344\"/E<gt>\n"
"E<lt>system type=\"max\" size=\"1081344\"/E<gt>\n"
"E<lt>aspace type=\"total\" size=\"1081344\"/E<gt>\n"
"E<lt>aspace type=\"mprotect\" size=\"1081344\"/E<gt>\n"
"E<lt>/heapE<gt>\n"
"E<lt>heap nr=\"1\"E<gt>\n"
"E<lt>sizesE<gt>\n"
"E<lt>/sizesE<gt>\n"
"E<lt>total type=\"fast\" count=\"0\" size=\"0\"/E<gt>\n"
"E<lt>total type=\"rest\" count=\"0\" size=\"0\"/E<gt>\n"
"E<lt>system type=\"current\" size=\"1032192\"/E<gt>\n"
"E<lt>system type=\"max\" size=\"1032192\"/E<gt>\n"
"E<lt>aspace type=\"total\" size=\"1032192\"/E<gt>\n"
"E<lt>aspace type=\"mprotect\" size=\"1032192\"/E<gt>\n"
"E<lt>/heapE<gt>\n"
"E<lt>total type=\"fast\" count=\"0\" size=\"0\"/E<gt>\n"
"E<lt>total type=\"rest\" count=\"0\" size=\"0\"/E<gt>\n"
"E<lt>system type=\"current\" size=\"2113536\"/E<gt>\n"
"E<lt>system type=\"max\" size=\"2113536\"/E<gt>\n"
"E<lt>aspace type=\"total\" size=\"2113536\"/E<gt>\n"
"E<lt>aspace type=\"mprotect\" size=\"2113536\"/E<gt>\n"
"E<lt>/mallocE<gt>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/malloc_info.3:187
#, no-wrap
msgid ""
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>pthread.hE<gt>\n"
"#include E<lt>malloc.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/malloc_info.3:190
#, no-wrap
msgid ""
"static size_t blockSize;\n"
"static int numThreads, numBlocks;\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/malloc_info.3:199
#, no-wrap
msgid ""
"static void *\n"
"thread_func(void *arg)\n"
"{\n"
"    int j;\n"
"    int tn = (int) arg;\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/malloc_info.3:202
#, no-wrap
msgid ""
"    /* The multiplier \\(aq(2 + tn)\\(aq ensures that each thread (including\n"
"       the main thread) allocates a different amount of memory */\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/malloc_info.3:206
#, no-wrap
msgid ""
"    for (j = 0; j E<lt> numBlocks; j++)\n"
"        if (malloc(blockSize * (2 + tn)) == NULL)\n"
"            errExit(\"malloc-thread\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/malloc_info.3:210
#, no-wrap
msgid ""
"    sleep(100);         /* Sleep until main thread terminates */\n"
"    return NULL;\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/malloc_info.3:216
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int j, tn, sleepTime;\n"
"    pthread_t *thr;\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/malloc_info.3:223
#, no-wrap
msgid ""
"    if (argc E<lt> 4) {\n"
"        fprintf(stderr,\n"
"                \"%s num-threads num-blocks block-size [sleep-time]\\en\",\n"
"                argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/malloc_info.3:228
#, no-wrap
msgid ""
"    numThreads = atoi(argv[1]);\n"
"    numBlocks = atoi(argv[2]);\n"
"    blockSize = atoi(argv[3]);\n"
"    sleepTime = (argc E<gt> 4) ? atoi(argv[4]) : 0;\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/malloc_info.3:232
#, no-wrap
msgid ""
"    thr = calloc(numThreads, sizeof(pthread_t));\n"
"    if (thr == NULL)\n"
"        errExit(\"calloc\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/malloc_info.3:235
#, no-wrap
msgid ""
"    printf(\"============ Before allocating blocks ============\\en\");\n"
"    malloc_info(0, stdout);\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/malloc_info.3:237
#, no-wrap
msgid "    /* Create threads that allocate different amounts of memory */\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/malloc_info.3:243
#, no-wrap
msgid ""
"    for (tn = 0; tn E<lt> numThreads; tn++) {\n"
"        errno = pthread_create(&thr[tn], NULL, thread_func,\n"
"                               (void *) tn);\n"
"        if (errno != 0)\n"
"            errExit(\"pthread_create\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/malloc_info.3:248
#, no-wrap
msgid ""
"        /* If we add a sleep interval after the start-up of each\n"
"           thread, the threads likely won\\(aqt contend for malloc\n"
"           mutexes, and therefore additional arenas won\\(aqt be\n"
"           allocated (see malloc(3)). */\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/malloc_info.3:252
#, no-wrap
msgid ""
"        if (sleepTime E<gt> 0)\n"
"            sleep(sleepTime);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/malloc_info.3:254
#, no-wrap
msgid "    /* The main thread also allocates some memory */\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/malloc_info.3:258
#, no-wrap
msgid ""
"    for (j = 0; j E<lt> numBlocks; j++)\n"
"        if (malloc(blockSize) == NULL)\n"
"            errExit(\"malloc\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/malloc_info.3:261
#, no-wrap
msgid ""
"    sleep(2);           /* Give all threads a chance to\n"
"                           complete allocations */\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/malloc_info.3:264
#, no-wrap
msgid ""
"    printf(\"\\en============ After allocating blocks ============\\en\");\n"
"    malloc_info(0, stdout);\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/malloc_info.3:273
msgid ""
"B<mallinfo>(3), B<malloc>(3), B<malloc_stats>(3), B<mallopt>(3), "
"B<open_memstream>(3)"
msgstr ""

#. type: TH
#: man-pages/man3/MB_LEN_MAX.3:17
#, no-wrap
msgid "MB_LEN_MAX"
msgstr ""

#. type: TH
#: man-pages/man3/MB_LEN_MAX.3:17
#, no-wrap
msgid "2015-07-23"
msgstr ""

#. type: Plain text
#: man-pages/man3/MB_LEN_MAX.3:20
msgid ""
"MB_LEN_MAX - maximum multibyte length of a character across all locales"
msgstr ""

#. type: Plain text
#: man-pages/man3/MB_LEN_MAX.3:23
#, no-wrap
msgid "B<#include E<lt>limits.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/MB_LEN_MAX.3:29
msgid ""
"The B<MB_LEN_MAX> macro is the maximum number of bytes needed to represent a"
" single wide character, in any of the supported locales."
msgstr ""

#. type: Plain text
#: man-pages/man3/MB_LEN_MAX.3:31
msgid "A constant integer greater than zero."
msgstr ""

#.  For an explanation of why the limit was raised to 16, see
#.  http://lists.gnu.org/archive/html/bug-gnulib/2015-05/msg00001.html
#.      From:    Bruno Haible
#.      Subject: Re: why is MB_LEN_MAX so large (16) on glibc
#.      Date:    Thu, 14 May 2015 02:30:14 +0200
#. type: Plain text
#: man-pages/man3/MB_LEN_MAX.3:50
msgid ""
"The entities B<MB_LEN_MAX> and I<sizeof(wchar_t)> are totally unrelated.  In"
" glibc, B<MB_LEN_MAX> is typically 16 (6 in glibc versions earlier than "
"2.2), while I<sizeof(wchar_t)> is 4."
msgstr ""

#. type: Plain text
#: man-pages/man3/MB_LEN_MAX.3:51
msgid "B<MB_CUR_MAX>(3)"
msgstr ""

#. type: TH
#: man-pages/man3/MB_CUR_MAX.3:17
#, no-wrap
msgid "MB_CUR_MAX"
msgstr ""

#. type: Plain text
#: man-pages/man3/MB_CUR_MAX.3:20
msgid ""
"MB_CUR_MAX - maximum length of a multibyte character in the current locale"
msgstr ""

#. type: Plain text
#: man-pages/man3/MB_CUR_MAX.3:31
msgid ""
"The B<MB_CUR_MAX> macro defines an integer expression giving the maximum "
"number of bytes needed to represent a single wide character in the current "
"locale.  This value is locale dependent and therefore not a compile-time "
"constant."
msgstr ""

#. type: Plain text
#: man-pages/man3/MB_CUR_MAX.3:35
msgid ""
"An integer in the range [1, B<MB_LEN_MAX>].  The value 1 denotes traditional"
" 8-bit encoded characters."
msgstr ""

#. type: Plain text
#: man-pages/man3/MB_CUR_MAX.3:43
msgid ""
"B<MB_LEN_MAX>(3), B<mblen>(3), B<mbstowcs>(3), B<mbtowc>(3), B<wcstombs>(3),"
" B<wctomb>(3)"
msgstr ""

#. type: TH
#: man-pages/man3/memmove.3:30
#, no-wrap
msgid "MEMMOVE"
msgstr ""

#. type: Plain text
#: man-pages/man3/memmove.3:33
msgid "memmove - copy memory area"
msgstr ""

#. type: Plain text
#: man-pages/man3/memmove.3:38
#, no-wrap
msgid ""
"B<void *memmove(void *>I<dest>B<, const void *>I<src>B<, size_t >I<n>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/memmove.3:57
msgid ""
"The B<memmove>()  function copies I<n> bytes from memory area I<src> to "
"memory area I<dest>.  The memory areas may overlap: copying takes place as "
"though the bytes in I<src> are first copied into a temporary array that does"
" not overlap I<src> or I<dest>, and the bytes are then copied from the "
"temporary array to I<dest>."
msgstr ""

#. type: Plain text
#: man-pages/man3/memmove.3:62
msgid "The B<memmove>()  function returns a pointer to I<dest>."
msgstr ""

#. type: tbl table
#: man-pages/man3/memmove.3:72
#, no-wrap
msgid "B<memmove>()"
msgstr ""

#. type: Plain text
#: man-pages/man3/memmove.3:83
msgid ""
"B<bcopy>(3), B<bstring>(3), B<memccpy>(3), B<memcpy>(3), B<strcpy>(3), "
"B<strncpy>(3), B<wmemmove>(3)"
msgstr ""

#. type: TH
#: man-pages/man3/mbstowcs.3:18
#, no-wrap
msgid "MBSTOWCS"
msgstr ""

#. type: Plain text
#: man-pages/man3/mbstowcs.3:21
msgid "mbstowcs - convert a multibyte string to a wide-character string"
msgstr ""

#. type: Plain text
#: man-pages/man3/mbstowcs.3:26
#, no-wrap
msgid ""
"B<size_t mbstowcs(wchar_t *>I<dest>B<, const char *>I<src>B<, size_t "
">I<n>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/mbstowcs.3:46
msgid ""
"If I<dest> is not NULL, the B<mbstowcs>()  function converts the multibyte "
"string I<src> to a wide-character string starting at I<dest>.  At most I<n> "
"wide characters are written to I<dest>.  The sequence of characters in the "
"string I<src> shall begin in the initial shift state.  The conversion can "
"stop for three reasons:"
msgstr ""

#. type: Plain text
#: man-pages/man3/mbstowcs.3:51
msgid ""
"An invalid multibyte sequence has been encountered.  In this case, "
"I<(size_t)\\ -1> is returned."
msgstr ""

#. type: Plain text
#: man-pages/man3/mbstowcs.3:59
msgid ""
"I<n> non-L\\(aq\\e0\\(aq wide characters have been stored at I<dest>.  In "
"this case, the number of wide characters written to I<dest> is returned, but"
" the shift state at this point is lost."
msgstr ""

#. type: Plain text
#: man-pages/man3/mbstowcs.3:65
msgid ""
"The multibyte string has been completely converted, including the "
"terminating null character (\\(aq\\e0\\(aq).  In this case, the number of "
"wide characters written to I<dest>, excluding the terminating null wide "
"character, is returned."
msgstr ""

#. type: Plain text
#: man-pages/man3/mbstowcs.3:71
msgid ""
"The programmer must ensure that there is room for at least I<n> wide "
"characters at I<dest>."
msgstr ""

#. type: Plain text
#: man-pages/man3/mbstowcs.3:79
msgid ""
"If I<dest> is NULL, I<n> is ignored, and the conversion proceeds as above, "
"except that the converted wide characters are not written out to memory, and"
" that no length limit exists."
msgstr ""

#. type: Plain text
#: man-pages/man3/mbstowcs.3:85
msgid ""
"In order to avoid the case 2 above, the programmer should make sure I<n> is "
"greater than or equal to I<mbstowcs(NULL,src,0)+1>."
msgstr ""

#. type: Plain text
#: man-pages/man3/mbstowcs.3:95
msgid ""
"The B<mbstowcs>()  function returns the number of wide characters that make "
"up the converted part of the wide-character string, not including the "
"terminating null wide character.  If an invalid multibyte sequence was "
"encountered, I<(size_t)\\ -1> is returned."
msgstr ""

#. type: tbl table
#: man-pages/man3/mbstowcs.3:105
#, no-wrap
msgid "B<mbstowcs>()"
msgstr ""

#. type: Plain text
#: man-pages/man3/mbstowcs.3:116
msgid ""
"The behavior of B<mbstowcs>()  depends on the B<LC_CTYPE> category of the "
"current locale."
msgstr ""

#. type: Plain text
#: man-pages/man3/mbstowcs.3:121
msgid ""
"The function B<mbsrtowcs>(3)  provides a better interface to the same "
"functionality."
msgstr ""

#. type: Plain text
#: man-pages/man3/mbstowcs.3:126
msgid ""
"The program below illustrates the use of B<mbstowcs>(), as well as some of "
"the wide character classification functions.  An example run is the "
"following:"
msgstr ""

#. type: Plain text
#: man-pages/man3/mbstowcs.3:133
#, no-wrap
msgid ""
"$ ./t_mbstowcs de_DE.UTF-8 Gre!\n"
"Length of source string (excluding terminator):\n"
"    8 bytes\n"
"    6 multibyte characters\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/mbstowcs.3:141
#, no-wrap
msgid ""
"Wide character string is: Gre! (6 characters)\n"
"    G alpha upper\n"
"    r alpha lower\n"
"     alpha lower\n"
"     alpha lower\n"
"    e alpha lower\n"
"    ! !alpha\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/mbstowcs.3:152
#, no-wrap
msgid ""
"#include E<lt>wctype.hE<gt>\n"
"#include E<lt>locale.hE<gt>\n"
"#include E<lt>wchar.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/mbstowcs.3:159
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    size_t mbslen;      /* Number of multibyte characters in source */\n"
"    wchar_t *wcs;       /* Pointer to converted wide character string */\n"
"    wchar_t *wp;\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/mbstowcs.3:164
#, no-wrap
msgid ""
"    if (argc E<lt> 3) {\n"
"        fprintf(stderr, \"Usage: %s E<lt>localeE<gt> E<lt>stringE<gt>\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/mbstowcs.3:166
#, no-wrap
msgid "    /* Apply the specified locale */\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/mbstowcs.3:171
#, no-wrap
msgid ""
"    if (setlocale(LC_ALL, argv[1]) == NULL) {\n"
"        perror(\"setlocale\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/mbstowcs.3:174
#, no-wrap
msgid ""
"    /* Calculate the length required to hold argv[2] converted to\n"
"       a wide character string */\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/mbstowcs.3:180
#, no-wrap
msgid ""
"    mbslen = mbstowcs(NULL, argv[2], 0);\n"
"    if (mbslen == (size_t) -1) {\n"
"        perror(\"mbstowcs\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/mbstowcs.3:182
#, no-wrap
msgid "    /* Describe the source string to the user */\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/mbstowcs.3:186
#, no-wrap
msgid ""
"    printf(\"Length of source string (excluding terminator):\\en\");\n"
"    printf(\"    %zu bytes\\en\", strlen(argv[2]));\n"
"    printf(\"    %zu multibyte characters\\en\\en\", mbslen);\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/mbstowcs.3:189
#, no-wrap
msgid ""
"    /* Allocate wide character string of the desired size.  Add 1\n"
"       to allow for terminating null wide character (L\\(aq\\e0\\(aq). */\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/mbstowcs.3:195
#, no-wrap
msgid ""
"    wcs = calloc(mbslen + 1, sizeof(wchar_t));\n"
"    if (wcs == NULL) {\n"
"        perror(\"calloc\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/mbstowcs.3:198
#, no-wrap
msgid ""
"    /* Convert the multibyte character string in argv[2] to a\n"
"       wide character string */\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/mbstowcs.3:203
#, no-wrap
msgid ""
"    if (mbstowcs(wcs, argv[2], mbslen + 1) == (size_t) -1) {\n"
"        perror(\"mbstowcs\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/mbstowcs.3:206
#, no-wrap
msgid ""
"    printf(\"Wide character string is: %ls (%zu characters)\\en\",\n"
"            wcs, mbslen);\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/mbstowcs.3:209
#, no-wrap
msgid ""
"    /* Now do some inspection of the classes of the characters in\n"
"       the wide character string */\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/mbstowcs.3:212
#, no-wrap
msgid ""
"    for (wp = wcs; *wp != 0; wp++) {\n"
"        printf(\"    %lc \", (wint_t) *wp);\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/mbstowcs.3:216
#, no-wrap
msgid ""
"        if (!iswalpha(*wp))\n"
"            printf(\"!\");\n"
"        printf(\"alpha \");\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/mbstowcs.3:220
#, no-wrap
msgid ""
"        if (iswalpha(*wp)) {\n"
"            if (iswupper(*wp))\n"
"                printf(\"upper \");\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/mbstowcs.3:224
#, no-wrap
msgid ""
"            if (iswlower(*wp))\n"
"                printf(\"lower \");\n"
"        }\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/mbstowcs.3:227
#, no-wrap
msgid ""
"        putchar(\\(aq\\en\\(aq);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/mbstowcs.3:236
msgid ""
"B<mblen>(3), B<mbsrtowcs>(3), B<mbtowc>(3), B<wcstombs>(3), B<wctomb>(3)"
msgstr ""

#. type: TH
#: man-pages/man3/mbsinit.3:16
#, no-wrap
msgid "MBSINIT"
msgstr ""

#. type: Plain text
#: man-pages/man3/mbsinit.3:19
msgid "mbsinit - test for initial shift state"
msgstr ""

#. type: Plain text
#: man-pages/man3/mbsinit.3:24
#, no-wrap
msgid "B<int mbsinit(const mbstate_t *>I<ps>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/mbsinit.3:34
msgid ""
"Character conversion between the multibyte representation and the wide "
"character representation uses conversion state, of type I<mbstate_t>.  "
"Conversion of a string uses a finite-state machine; when it is interrupted "
"after the complete conversion of a number of characters, it may need to save"
" a state for processing the remaining characters.  Such a conversion state "
"is needed for the sake of encodings such as ISO-2022 and UTF-7."
msgstr ""

#. type: Plain text
#: man-pages/man3/mbsinit.3:46
msgid ""
"The initial state is the state at the beginning of conversion of a string.  "
"There are two kinds of state: the one used by multibyte to wide character "
"conversion functions, such as B<mbsrtowcs>(3), and the one used by wide "
"character to multibyte conversion functions, such as B<wcsrtombs>(3), but "
"they both fit in a I<mbstate_t>, and they both have the same representation "
"for an initial state."
msgstr ""

#. type: Plain text
#: man-pages/man3/mbsinit.3:54
msgid ""
"For 8-bit encodings, all states are equivalent to the initial state.  For "
"multibyte encodings like UTF-8, EUC-*, BIG5 or SJIS, the wide character to "
"multibyte conversion functions never produce non-initial states, but the "
"multibyte to wide-character conversion functions like B<mbrtowc>(3)  do "
"produce non-initial states when interrupted in the middle of a character."
msgstr ""

#. type: Plain text
#: man-pages/man3/mbsinit.3:58
msgid ""
"One possible way to create an I<mbstate_t> in initial state is to set it to "
"zero:"
msgstr ""

#. type: Plain text
#: man-pages/man3/mbsinit.3:63
#, no-wrap
msgid ""
"mbstate_t state;\n"
"memset(&state,0,sizeof(mbstate_t));\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/mbsinit.3:67
msgid ""
"On Linux, the following works as well, but might generate compiler warnings:"
msgstr ""

#. type: Plain text
#: man-pages/man3/mbsinit.3:71
#, no-wrap
msgid "mbstate_t state = { 0 };\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/mbsinit.3:80
msgid ""
"The function B<mbsinit>()  tests whether I<*ps> corresponds to an initial "
"state."
msgstr ""

#. type: Plain text
#: man-pages/man3/mbsinit.3:88
msgid ""
"B<mbsinit>()  returns nonzero if I<*ps> is an initial state, or if I<ps> is "
"NULL.  Otherwise, it returns 0."
msgstr ""

#. type: tbl table
#: man-pages/man3/mbsinit.3:98
#, no-wrap
msgid "B<mbsinit>()"
msgstr ""

#. type: Plain text
#: man-pages/man3/mbsinit.3:109
msgid ""
"The behavior of B<mbsinit>()  depends on the B<LC_CTYPE> category of the "
"current locale."
msgstr ""

#. type: Plain text
#: man-pages/man3/mbsinit.3:114
msgid ""
"B<mbrlen>(3), B<mbrtowc>(3), B<mbsrtowcs>(3), B<wcrtomb>(3), B<wcsrtombs>(3)"
msgstr ""

#. type: TH
#: man-pages/man3/mpool.3:36
#, no-wrap
msgid "MPOOL"
msgstr ""

#. type: Plain text
#: man-pages/man3/mpool.3:40
msgid "mpool - shared memory buffer pool"
msgstr ""

#. type: Plain text
#: man-pages/man3/mpool.3:44
#, no-wrap
msgid ""
"B<#include E<lt>db.hE<gt>>\n"
"B<#include E<lt>mpool.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/mpool.3:47
#, no-wrap
msgid ""
"B<MPOOL *mpool_open(DBT *>I<key>B<, int >I<fd>B<, pgno_t >I<pagesize>B<, "
"pgno_t >I<maxcache>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/mpool.3:51
#, no-wrap
msgid ""
"B<void mpool_filter(MPOOL *>I<mp>B<, void (*pgin)(void *, pgno_t, void *),>\n"
"B<                  void (*>I<pgout>B<)(void *, pgno_t, void *),>\n"
"B<                  void *>I<pgcookie>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/mpool.3:53
#, no-wrap
msgid "B<void *mpool_new(MPOOL *>I<mp>B<, pgno_t *>I<pgnoaddr>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/mpool.3:55
#, no-wrap
msgid ""
"B<void *mpool_get(MPOOL *>I<mp>B<, pgno_t >I<pgno>B<, unsigned int "
">I<flags>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/mpool.3:57
#, no-wrap
msgid ""
"B<int mpool_put(MPOOL *>I<mp>B<, void *>I<pgaddr>B<, unsigned int "
">I<flags>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/mpool.3:59
#, no-wrap
msgid "B<int mpool_sync(MPOOL *>I<mp>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/mpool.3:61
#, no-wrap
msgid "B<int mpool_close(MPOOL *>I<mp>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/mpool.3:69
msgid ""
"I<Note well>: This page documents interfaces provided in glibc up until "
"version 2.1.  Since version 2.2, glibc no longer provides these interfaces."
"  Probably, you are looking for the APIs provided by the I<libdb> library "
"instead."
msgstr ""

#. type: Plain text
#: man-pages/man3/mpool.3:74
msgid ""
"I<Mpool> is the library interface intended to provide page oriented buffer "
"management of files.  The buffers may be shared between processes."
msgstr ""

#. type: Plain text
#: man-pages/man3/mpool.3:95
msgid ""
"The function B<mpool_open>()  initializes a memory pool.  The I<key> "
"argument is the byte string used to negotiate between multiple processes "
"wishing to share buffers.  If the file buffers are mapped in shared memory, "
"all processes using the same key will share the buffers.  If I<key> is NULL,"
" the buffers are mapped into private memory.  The I<fd> argument is a file "
"descriptor for the underlying file, which must be seekable.  If I<key> is "
"non-NULL and matches a file already being mapped, the I<fd> argument is "
"ignored."
msgstr ""

#. type: Plain text
#: man-pages/man3/mpool.3:106
msgid ""
"The I<pagesize> argument is the size, in bytes, of the pages into which the "
"file is broken up.  The I<maxcache> argument is the maximum number of pages "
"from the underlying file to cache at any one time.  This value is not "
"relative to the number of processes which share a file's buffers, but will "
"be the largest value specified by any of the processes sharing the file."
msgstr ""

#. type: Plain text
#: man-pages/man3/mpool.3:122
msgid ""
"The B<mpool_filter>()  function is intended to make transparent input and "
"output processing of the pages possible.  If the I<pgin> function is "
"specified, it is called each time a buffer is read into the memory pool from"
" the backing file.  If the I<pgout> function is specified, it is called each"
" time a buffer is written into the backing file.  Both functions are called "
"with the I<pgcookie> pointer, the page number and a pointer to the page to "
"being read or written."
msgstr ""

#. type: Plain text
#: man-pages/man3/mpool.3:135
msgid ""
"The function B<mpool_new>()  takes an I<MPOOL> pointer and an address as "
"arguments.  If a new page can be allocated, a pointer to the page is "
"returned and the page number is stored into the I<pgnoaddr> address.  "
"Otherwise, NULL is returned and I<errno> is set."
msgstr ""

#. type: Plain text
#: man-pages/man3/mpool.3:148
msgid ""
"The function B<mpool_get>()  takes an I<MPOOL> pointer and a page number as "
"arguments.  If the page exists, a pointer to the page is returned.  "
"Otherwise, NULL is returned and I<errno> is set.  The I<flags> argument is "
"not currently used."
msgstr ""

#. type: Plain text
#: man-pages/man3/mpool.3:160
msgid ""
"The function B<mpool_put>()  unpins the page referenced by I<pgaddr>.  "
"I<pgaddr> must be an address previously returned by B<mpool_get>()  or "
"B<mpool_new>().  The flag value is specified by ORing any of the following "
"values:"
msgstr ""

#. type: TP
#: man-pages/man3/mpool.3:160
#, no-wrap
msgid "B<MPOOL_DIRTY>"
msgstr ""

#. type: Plain text
#: man-pages/man3/mpool.3:163
msgid ""
"The page has been modified and needs to be written to the backing file."
msgstr ""

#. type: Plain text
#: man-pages/man3/mpool.3:166
msgid "B<mpool_put>()  returns 0 on success and -1 if an error occurs."
msgstr ""

#. type: Plain text
#: man-pages/man3/mpool.3:175
msgid ""
"The function B<mpool_sync>()  writes all modified pages associated with the "
"I<MPOOL> pointer to the backing file.  B<mpool_sync>()  returns 0 on success"
" and -1 if an error occurs."
msgstr ""

#. type: Plain text
#: man-pages/man3/mpool.3:185
msgid ""
"The B<mpool_close>()  function free's up any allocated memory associated "
"with the memory pool cookie.  Modified pages are B<not> written to the "
"backing file.  B<mpool_close>()  returns 0 on success and -1 if an error "
"occurs."
msgstr ""

#. type: Plain text
#: man-pages/man3/mpool.3:192
msgid ""
"The B<mpool_open>()  function may fail and set I<errno> for any of the "
"errors specified for the library routine B<malloc>(3)."
msgstr ""

#. type: Plain text
#: man-pages/man3/mpool.3:198
msgid ""
"The B<mpool_get>()  function may fail and set I<errno> for the following:"
msgstr ""

#. type: Plain text
#: man-pages/man3/mpool.3:201
msgid "The requested record doesn't exist."
msgstr ""

#. type: Plain text
#: man-pages/man3/mpool.3:213
msgid ""
"The B<mpool_new>()  and B<mpool_get>()  functions may fail and set I<errno> "
"for any of the errors specified for the library routines B<read>(2), "
"B<write>(2), and B<malloc>(3)."
msgstr ""

#. type: Plain text
#: man-pages/man3/mpool.3:220
msgid ""
"The B<mpool_sync>()  function may fail and set I<errno> for any of the "
"errors specified for the library routine B<write>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man3/mpool.3:227
msgid ""
"The B<mpool_close>()  function may fail and set I<errno> for any of the "
"errors specified for the library routine B<free>(3)."
msgstr ""

#. type: Plain text
#: man-pages/man3/mpool.3:230
msgid "Not in POSIX.1.  Present on the BSDs."
msgstr ""

#. type: Plain text
#: man-pages/man3/mpool.3:234
msgid "B<btree>(3), B<dbopen>(3), B<hash>(3), B<recno>(3)"
msgstr ""

#. type: TH
#: man-pages/man3/memset.3:30
#, no-wrap
msgid "MEMSET"
msgstr ""

#. type: Plain text
#: man-pages/man3/memset.3:33
msgid "memset - fill memory with a constant byte"
msgstr ""

#. type: Plain text
#: man-pages/man3/memset.3:38
#, no-wrap
msgid "B<void *memset(void *>I<s>B<, int >I<c>B<, size_t >I<n>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/memset.3:49
msgid ""
"The B<memset>()  function fills the first I<n> bytes of the memory area "
"pointed to by I<s> with the constant byte I<c>."
msgstr ""

#. type: Plain text
#: man-pages/man3/memset.3:54
msgid "The B<memset>()  function returns a pointer to the memory area I<s>."
msgstr ""

#. type: tbl table
#: man-pages/man3/memset.3:64
#, no-wrap
msgid "B<memset>()"
msgstr ""

#. type: Plain text
#: man-pages/man3/memset.3:72
msgid "B<bstring>(3), B<bzero>(3), B<swab>(3), B<wmemset>(3)"
msgstr ""

#. type: TH
#: man-pages/man3/makedev.3:26
#, no-wrap
msgid "MAKEDEV"
msgstr ""

#. type: Plain text
#: man-pages/man3/makedev.3:29
msgid "makedev, major, minor - manage a device number"
msgstr ""

#. type: Plain text
#: man-pages/man3/makedev.3:32
#, no-wrap
msgid "B<#include E<lt>sys/sysmacros.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/makedev.3:34
#, no-wrap
msgid "B<dev_t makedev(unsigned int >I<maj>B<, unsigned int >I<min>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/makedev.3:37
#, no-wrap
msgid ""
"B<unsigned int major(dev_t >I<dev>B<);>\n"
"B<unsigned int minor(dev_t >I<dev>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/makedev.3:44
msgid ""
"A device ID consists of two parts: a major ID, identifying the class of the "
"device, and a minor ID, identifying a specific instance of a device in that "
"class.  A device ID is represented using the type I<dev_t>."
msgstr ""

#. type: Plain text
#: man-pages/man3/makedev.3:51
msgid ""
"Given major and minor device IDs, B<makedev>()  combines these to produce a "
"device ID, returned as the function result.  This device ID can be given to "
"B<mknod>(2), for example."
msgstr ""

#. type: Plain text
#: man-pages/man3/makedev.3:61
msgid ""
"The B<major>()  and B<minor>()  functions perform the converse task: given a"
" device ID, they return, respectively, the major and minor components.  "
"These macros can be useful to, for example, decompose the device IDs in the "
"structure returned by B<stat>(2)."
msgstr ""

#. type: tbl table
#: man-pages/man3/makedev.3:73
#, no-wrap
msgid ""
"B<makedev>(),\n"
"B<major>(),\n"
"B<minor>()"
msgstr ""

#.  The BSDs, HP-UX, Solaris, AIX, Irix.
#.  The header location is inconsistent:
#.  Could be sys/mkdev.h, sys/sysmacros.h, or sys/types.h.
#. type: Plain text
#: man-pages/man3/makedev.3:86
msgid ""
"The B<makedev>(), B<major>(), and B<minor>()  functions are not specified in"
" POSIX.1, but are present on many other systems."
msgstr ""

#. type: Plain text
#: man-pages/man3/makedev.3:95
msgid ""
"These interfaces are defined as macros.  Since glibc 2.3.3, they have been "
"aliases for three GNU-specific functions: B<gnu_dev_makedev>(), "
"B<gnu_dev_major>(), and B<gnu_dev_minor>().  The latter names are exported, "
"but the traditional names are more portable."
msgstr ""

#.  glibc commit dbab6577c6684c62bd2521c1c29dc25c3cac966f
#.  glibc commit e16deca62e16f645213dffd4ecd1153c37765f17
#. type: Plain text
#: man-pages/man3/makedev.3:107
msgid ""
"The BSDs expose the definitions for these macros via "
"I<E<lt>sys/types.hE<gt>>.  Depending on the version, glibc also exposes "
"definitions for these macros from that header file if suitable feature test "
"macros are defined.  However, this behavior was deprecated in glibc 2.25, "
"and since glibc 2.28, I<E<lt>sys/types.hE<gt>> no longer provides these "
"definitions."
msgstr ""

#. type: Plain text
#: man-pages/man3/makedev.3:109
msgid "B<mknod>(2), B<stat>(2)"
msgstr ""

#. type: TH
#: man-pages/man3/mq_getattr.3:26
#, no-wrap
msgid "MQ_GETATTR"
msgstr ""

#. type: Plain text
#: man-pages/man3/mq_getattr.3:29
msgid "mq_getattr, mq_setattr - get/set message queue attributes"
msgstr ""

#. type: Plain text
#: man-pages/man3/mq_getattr.3:34
#, no-wrap
msgid "B<int mq_getattr(mqd_t >I<mqdes>B<, struct mq_attr *>I<attr>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/mq_getattr.3:37
#, no-wrap
msgid ""
"B<int mq_setattr(mqd_t >I<mqdes>B<, const struct mq_attr *>I<newattr>B<,>\n"
"B<                 struct mq_attr *>I<oldattr>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/mq_getattr.3:47
msgid ""
"B<mq_getattr>()  and B<mq_setattr>()  respectively retrieve and modify "
"attributes of the message queue referred to by the message queue descriptor "
"I<mqdes>."
msgstr ""

#. type: Plain text
#: man-pages/man3/mq_getattr.3:54
msgid ""
"B<mq_getattr>()  returns an I<mq_attr> structure in the buffer pointed by "
"I<attr>.  This structure is defined as:"
msgstr ""

#. type: Plain text
#: man-pages/man3/mq_getattr.3:63
#, no-wrap
msgid ""
"struct mq_attr {\n"
"    long mq_flags;       /* Flags: 0 or O_NONBLOCK */\n"
"    long mq_maxmsg;      /* Max. # of messages on queue */\n"
"    long mq_msgsize;     /* Max. message size (bytes) */\n"
"    long mq_curmsgs;     /* # of messages currently in queue */\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/mq_getattr.3:73
msgid ""
"The I<mq_flags> field contains flags associated with the open message queue "
"description.  This field is initialized when the queue is created by "
"B<mq_open>(3).  The only flag that can appear in this field is "
"B<O_NONBLOCK>."
msgstr ""

#. type: Plain text
#: man-pages/man3/mq_getattr.3:94
msgid ""
"The I<mq_maxmsg> and I<mq_msgsize> fields are set when the message queue is "
"created by B<mq_open>(3).  The I<mq_maxmsg> field is an upper limit on the "
"number of messages that may be placed on the queue using B<mq_send>(3).  The"
" I<mq_msgsize> field is an upper limit on the size of messages that may be "
"placed on the queue.  Both of these fields must have a value greater than "
"zero.  Two I</proc> files that place ceilings on the values for these fields"
" are described in B<mq_overview>(7)."
msgstr ""

#. type: Plain text
#: man-pages/man3/mq_getattr.3:98
msgid ""
"The I<mq_curmsgs> field returns the number of messages currently held in the"
" queue."
msgstr ""

#. type: Plain text
#: man-pages/man3/mq_getattr.3:118
msgid ""
"B<mq_setattr>()  sets message queue attributes using information supplied in"
" the I<mq_attr> structure pointed to by I<newattr>.  The only attribute that"
" can be modified is the setting of the B<O_NONBLOCK> flag in I<mq_flags>.  "
"The other fields in I<newattr> are ignored.  If the I<oldattr> field is not "
"NULL, then the buffer that it points to is used to return an I<mq_attr> "
"structure that contains the same information that is returned by "
"B<mq_getattr>()."
msgstr ""

#. type: Plain text
#: man-pages/man3/mq_getattr.3:126
msgid ""
"On success B<mq_getattr>()  and B<mq_setattr>()  return 0; on error, -1 is "
"returned, with I<errno> set to indicate the error."
msgstr ""

#. type: Plain text
#: man-pages/man3/mq_getattr.3:132
msgid "The message queue descriptor specified in I<mqdes> is invalid."
msgstr ""

#. type: Plain text
#: man-pages/man3/mq_getattr.3:137
msgid "I<newattr-E<gt>mq_flags> contained set bits other than B<O_NONBLOCK>."
msgstr ""

#. type: tbl table
#: man-pages/man3/mq_getattr.3:148
#, no-wrap
msgid ""
"B<mq_getattr>(),\n"
"B<mq_setattr>()"
msgstr ""

#. type: Plain text
#: man-pages/man3/mq_getattr.3:160
msgid ""
"On Linux, B<mq_getattr>()  and B<mq_setattr>()  are library functions "
"layered on top of the B<mq_getsetattr>(2)  system call."
msgstr ""

#. type: Plain text
#: man-pages/man3/mq_getattr.3:171
msgid ""
"The program below can be used to show the default I<mq_maxmsg> and "
"I<mq_msgsize> values that are assigned to a message queue that is created "
"with a call to B<mq_open>(3)  in which the I<attr> argument is NULL.  Here "
"is an example run of the program:"
msgstr ""

#. type: Plain text
#: man-pages/man3/mq_getattr.3:177
#, no-wrap
msgid ""
"$ B<./a.out /testq>\n"
"Maximum # of messages on queue:   10\n"
"Maximum message size:             8192\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/mq_getattr.3:185
msgid ""
"Since Linux 3.5, the following I</proc> files (described in "
"B<mq_overview>(7))  can be used to control the defaults:"
msgstr ""

#. type: Plain text
#: man-pages/man3/mq_getattr.3:194
#, no-wrap
msgid ""
"$ B<uname -sr>\n"
"Linux 3.8.0\n"
"$ B<cat /proc/sys/fs/mqueue/msg_default>\n"
"10\n"
"$ B<cat /proc/sys/fs/mqueue/msgsize_default>\n"
"8192\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/mq_getattr.3:205
#, no-wrap
msgid ""
"#include E<lt>mqueue.hE<gt>\n"
"#include E<lt>sys/stat.hE<gt>\n"
"#include E<lt>fcntl.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/mq_getattr.3:214
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    mqd_t mqd;\n"
"    struct mq_attr attr;\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/mq_getattr.3:219
#, no-wrap
msgid ""
"    if (argc != 2) {\n"
"        fprintf(stderr, \"Usage: %s mq-name\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/mq_getattr.3:223
#, no-wrap
msgid ""
"    mqd = mq_open(argv[1], O_CREAT | O_EXCL, S_IRUSR | S_IWUSR, NULL);\n"
"    if (mqd == (mqd_t) -1)\n"
"        errExit(\"mq_open\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/mq_getattr.3:226
#, no-wrap
msgid ""
"    if (mq_getattr(mqd, &attr) == -1)\n"
"        errExit(\"mq_getattr\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/mq_getattr.3:229
#, no-wrap
msgid ""
"    printf(\"Maximum # of messages on queue:   %ld\\en\", attr.mq_maxmsg);\n"
"    printf(\"Maximum message size:             %ld\\en\", attr.mq_msgsize);\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/mq_getattr.3:232
#, no-wrap
msgid ""
"    if (mq_unlink(argv[1]) == -1)\n"
"        errExit(\"mq_unlink\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/mq_getattr.3:243
msgid ""
"B<mq_close>(3), B<mq_notify>(3), B<mq_open>(3), B<mq_receive>(3), "
"B<mq_send>(3), B<mq_unlink>(3), B<mq_overview>(7)"
msgstr ""

#. type: TH
#: man-pages/man3/mq_notify.3:26
#, no-wrap
msgid "MQ_NOTIFY"
msgstr ""

#. type: Plain text
#: man-pages/man3/mq_notify.3:29
msgid "mq_notify - register for notification when a message is available"
msgstr ""

#. type: Plain text
#: man-pages/man3/mq_notify.3:34
#, no-wrap
msgid ""
"B<int mq_notify(mqd_t >I<mqdes>B<, const struct sigevent *>I<sevp>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/mq_notify.3:43
msgid ""
"B<mq_notify>()  allows the calling process to register or unregister for "
"delivery of an asynchronous notification when a new message arrives on the "
"empty message queue referred to by the message queue descriptor I<mqdes>."
msgstr ""

#. type: Plain text
#: man-pages/man3/mq_notify.3:51
msgid ""
"The I<sevp> argument is a pointer to a I<sigevent> structure.  For the "
"definition and general details of this structure, see B<sigevent>(7)."
msgstr ""

#. type: Plain text
#: man-pages/man3/mq_notify.3:65
msgid ""
"If I<sevp> is a non-null pointer, then B<mq_notify>()  registers the calling"
" process to receive message notification.  The I<sigev_notify> field of the "
"I<sigevent> structure to which I<sevp> points specifies how notification is "
"to be performed.  This field has one of the following values:"
msgstr ""

#. type: TP
#: man-pages/man3/mq_notify.3:65
#, no-wrap
msgid "B<SIGEV_NONE>"
msgstr ""

#.  When is SIGEV_NONE useful?
#. type: Plain text
#: man-pages/man3/mq_notify.3:70
msgid ""
"A \"null\" notification: the calling process is registered as the target for"
" notification, but when a message arrives, no notification is sent."
msgstr ""

#. type: TP
#: man-pages/man3/mq_notify.3:70
#, no-wrap
msgid "B<SIGEV_SIGNAL>"
msgstr ""

#.  I don't know of other implementations that set
#.  si_pid and si_uid -- MTK
#. type: Plain text
#: man-pages/man3/mq_notify.3:90
msgid ""
"Notify the process by sending the signal specified in I<sigev_signo>.  See "
"B<sigevent>(7)  for general details.  The I<si_code> field of the "
"I<siginfo_t> structure will be set to B<SI_MESGQ>.  In addition, I<si_pid> "
"will be set to the PID of the process that sent the message, and I<si_uid> "
"will be set to the real user ID of the sending process."
msgstr ""

#. type: TP
#: man-pages/man3/mq_notify.3:90
#, no-wrap
msgid "B<SIGEV_THREAD>"
msgstr ""

#. type: Plain text
#: man-pages/man3/mq_notify.3:98
msgid ""
"Upon message delivery, invoke I<sigev_notify_function> as if it were the "
"start function of a new thread.  See B<sigevent>(7)  for details."
msgstr ""

#. type: Plain text
#: man-pages/man3/mq_notify.3:101
msgid ""
"Only one process can be registered to receive notification from a message "
"queue."
msgstr ""

#. type: Plain text
#: man-pages/man3/mq_notify.3:108
msgid ""
"If I<sevp> is NULL, and the calling process is currently registered to "
"receive notifications for this message queue, then the registration is "
"removed; another process can then register to receive a message notification"
" for this queue."
msgstr ""

#. type: Plain text
#: man-pages/man3/mq_notify.3:115
msgid ""
"Message notification occurs only when a new message arrives and the queue "
"was previously empty.  If the queue was not empty at the time B<mq_notify>()"
"  was called, then a notification will occur only after the queue is emptied"
" and a new message arrives."
msgstr ""

#. type: Plain text
#: man-pages/man3/mq_notify.3:123
msgid ""
"If another process or thread is waiting to read a message from an empty "
"queue using B<mq_receive>(3), then any message notification registration is "
"ignored: the message is delivered to the process or thread calling "
"B<mq_receive>(3), and the message notification registration remains in "
"effect."
msgstr ""

#. type: Plain text
#: man-pages/man3/mq_notify.3:134
msgid ""
"Notification occurs once: after a notification is delivered, the "
"notification registration is removed, and another process can register for "
"message notification.  If the notified process wishes to receive the next "
"notification, it can use B<mq_notify>()  to request a further notification."
"  This should be done before emptying all unread messages from the queue.  "
"(Placing the queue in nonblocking mode is useful for emptying the queue of "
"messages without blocking once it is empty.)"
msgstr ""

#. type: Plain text
#: man-pages/man3/mq_notify.3:140
msgid ""
"On success B<mq_notify>()  returns 0; on error, -1 is returned, with "
"I<errno> set to indicate the error."
msgstr ""

#. type: Plain text
#: man-pages/man3/mq_notify.3:150
msgid ""
"Another process has already registered to receive notification for this "
"message queue."
msgstr ""

#. type: Plain text
#: man-pages/man3/mq_notify.3:160
msgid ""
"I<sevp-E<gt>sigev_notify> is not one of the permitted values; or "
"I<sevp-E<gt>sigev_notify> is B<SIGEV_SIGNAL> and I<sevp-E<gt>sigev_signo> is"
" not a valid signal number."
msgstr ""

#. type: Plain text
#: man-pages/man3/mq_notify.3:163
msgid "Insufficient memory."
msgstr ""

#.  Linux does not do this
#. type: Plain text
#: man-pages/man3/mq_notify.3:174
msgid ""
"POSIX.1-2008 says that an implementation I<may> generate an B<EINVAL> error "
"if I<sevp> is NULL, and the caller is not currently registered to receive "
"notifications for the queue I<mqdes>."
msgstr ""

#. type: tbl table
#: man-pages/man3/mq_notify.3:184
#, no-wrap
msgid "B<mq_notify>()"
msgstr ""

#. type: Plain text
#: man-pages/man3/mq_notify.3:189
msgid "POSIX.1-2001."
msgstr ""

#. type: Plain text
#: man-pages/man3/mq_notify.3:211
msgid ""
"In the glibc implementation, the B<mq_notify>()  library function is "
"implemented on top of the system call of the same name.  When I<sevp> is "
"NULL, or specifies a notification mechanism other than B<SIGEV_THREAD>, the "
"library function directly invokes the system call.  For B<SIGEV_THREAD>, "
"much of the implementation resides within the library, rather than the "
"kernel.  (This is necessarily so, since the thread involved in handling the "
"notification is one that must be managed by the C library POSIX threads "
"implementation.)  The implementation involves the use of a raw B<netlink>(7)"
"  socket and creates a new thread for each notification that is delivered to"
" the process."
msgstr ""

#. type: Plain text
#: man-pages/man3/mq_notify.3:217
msgid ""
"The following program registers a notification request for the message queue"
" named in its command-line argument.  Notification is performed by creating "
"a thread.  The thread executes a function which reads one message from the "
"queue and then terminates the process."
msgstr ""

#. type: Plain text
#: man-pages/man3/mq_notify.3:224
#, no-wrap
msgid ""
"#include E<lt>pthread.hE<gt>\n"
"#include E<lt>mqueue.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/mq_notify.3:235
#, no-wrap
msgid ""
"static void                     /* Thread start function */\n"
"tfunc(union sigval sv)\n"
"{\n"
"    struct mq_attr attr;\n"
"    ssize_t nr;\n"
"    void *buf;\n"
"    mqd_t mqdes = *((mqd_t *) sv.sival_ptr);\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/mq_notify.3:237
#, no-wrap
msgid "    /* Determine max. msg size; allocate buffer to receive msg */\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/mq_notify.3:243
#, no-wrap
msgid ""
"    if (mq_getattr(mqdes, &attr) == -1)\n"
"        handle_error(\"mq_getattr\");\n"
"    buf = malloc(attr.mq_msgsize);\n"
"    if (buf == NULL)\n"
"        handle_error(\"malloc\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/mq_notify.3:247
#, no-wrap
msgid ""
"    nr = mq_receive(mqdes, buf, attr.mq_msgsize, NULL);\n"
"    if (nr == -1)\n"
"        handle_error(\"mq_receive\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/mq_notify.3:252
#, no-wrap
msgid ""
"    printf(\"Read %zd bytes from MQ\\en\", nr);\n"
"    free(buf);\n"
"    exit(EXIT_SUCCESS);         /* Terminate the process */\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/mq_notify.3:258
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    mqd_t mqdes;\n"
"    struct sigevent sev;\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/mq_notify.3:263
#, no-wrap
msgid ""
"    if (argc != 2) {\n"
"        fprintf(stderr, \"Usage: %s E<lt>mq-nameE<gt>\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/mq_notify.3:267
#, no-wrap
msgid ""
"    mqdes = mq_open(argv[1], O_RDONLY);\n"
"    if (mqdes == (mqd_t) -1)\n"
"        handle_error(\"mq_open\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/mq_notify.3:274
#, no-wrap
msgid ""
"    sev.sigev_notify = SIGEV_THREAD;\n"
"    sev.sigev_notify_function = tfunc;\n"
"    sev.sigev_notify_attributes = NULL;\n"
"    sev.sigev_value.sival_ptr = &mqdes;   /* Arg. to thread func. */\n"
"    if (mq_notify(mqdes, &sev) == -1)\n"
"        handle_error(\"mq_notify\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/mq_notify.3:277
#, no-wrap
msgid ""
"    pause();    /* Process will be terminated by thread function */\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/mq_notify.3:286
msgid ""
"B<mq_close>(3), B<mq_getattr>(3), B<mq_open>(3), B<mq_receive>(3), "
"B<mq_send>(3), B<mq_unlink>(3), B<mq_overview>(7), B<sigevent>(7)"
msgstr ""

#. type: TH
#: man-pages/man3/makecontext.3:28
#, no-wrap
msgid "MAKECONTEXT"
msgstr ""

#. type: Plain text
#: man-pages/man3/makecontext.3:31
msgid "makecontext, swapcontext - manipulate user context"
msgstr ""

#. type: Plain text
#: man-pages/man3/makecontext.3:33
msgid "B<#include E<lt>ucontext.hE<gt>>"
msgstr ""

#. type: Plain text
#: man-pages/man3/makecontext.3:36
msgid ""
"B<void makecontext(ucontext_t *>I<ucp>B<, void (*>I<func>B<)(),> B<int "
">I<argc>B<, ...);>"
msgstr ""

#. type: Plain text
#: man-pages/man3/makecontext.3:38
msgid ""
"B<int swapcontext(ucontext_t *>I<oucp>B<, const ucontext_t *>I<ucp>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man3/makecontext.3:49
msgid ""
"In a System V-like environment, one has the type I<ucontext_t> defined in "
"I<E<lt>ucontext.hE<gt>> and the four functions B<getcontext>(3), "
"B<setcontext>(3), B<makecontext>()  and B<swapcontext>()  that allow user-"
"level context switching between multiple threads of control within a "
"process."
msgstr ""

#. type: Plain text
#: man-pages/man3/makecontext.3:52
msgid "For the type and the first two functions, see B<getcontext>(3)."
msgstr ""

#. type: Plain text
#: man-pages/man3/makecontext.3:64
msgid ""
"The B<makecontext>()  function modifies the context pointed to by I<ucp> "
"(which was obtained from a call to B<getcontext>(3)).  Before invoking "
"B<makecontext>(), the caller must allocate a new stack for this context and "
"assign its address to I<ucp-E<gt>uc_stack>, and define a successor context "
"and assign its address to I<ucp-E<gt>uc_link>."
msgstr ""

#. type: Plain text
#: man-pages/man3/makecontext.3:78
msgid ""
"When this context is later activated (using B<setcontext>(3)  or "
"B<swapcontext>())  the function I<func> is called, and passed the series of "
"integer (I<int>)  arguments that follow I<argc>; the caller must specify the"
" number of these arguments in I<argc>.  When this function returns, the "
"successor context is activated.  If the successor context pointer is NULL, "
"the thread exits."
msgstr ""

#. type: Plain text
#: man-pages/man3/makecontext.3:84
msgid ""
"The B<swapcontext>()  function saves the current context in the structure "
"pointed to by I<oucp>, and then activates the context pointed to by I<ucp>."
msgstr ""

#. type: Plain text
#: man-pages/man3/makecontext.3:96
msgid ""
"When successful, B<swapcontext>()  does not return.  (But we may return "
"later, in case I<oucp> is activated, in which case it looks like "
"B<swapcontext>()  returns 0.)  On error, B<swapcontext>()  returns -1 and "
"sets I<errno> appropriately."
msgstr ""

#. type: Plain text
#: man-pages/man3/makecontext.3:100
msgid "Insufficient stack space left."
msgstr ""

#. type: Plain text
#: man-pages/man3/makecontext.3:105
msgid ""
"B<makecontext>()  and B<swapcontext>()  are provided in glibc since version "
"2.1."
msgstr ""

#. type: tbl table
#: man-pages/man3/makecontext.3:115
#, no-wrap
msgid "B<makecontext>()"
msgstr ""

#. type: tbl table
#: man-pages/man3/makecontext.3:115
#, no-wrap
msgid "MT-Safe race:ucp"
msgstr ""

#. type: tbl table
#: man-pages/man3/makecontext.3:118
#, no-wrap
msgid "B<swapcontext>()"
msgstr ""

#. type: tbl table
#: man-pages/man3/makecontext.3:118
#, no-wrap
msgid "MT-Safe race:oucp race:ucp"
msgstr ""

#. type: Plain text
#: man-pages/man3/makecontext.3:128
msgid ""
"SUSv2, POSIX.1-2001.  POSIX.1-2008 removes the specifications of "
"B<makecontext>()  and B<swapcontext>(), citing portability issues, and "
"recommending that applications be rewritten to use POSIX threads instead."
msgstr ""

#. type: Plain text
#: man-pages/man3/makecontext.3:136
msgid ""
"The interpretation of I<ucp-E<gt>uc_stack> is just as in B<sigaltstack>(2), "
"namely, this struct contains the start and length of a memory area to be "
"used as the stack, regardless of the direction of growth of the stack.  "
"Thus, it is not necessary for the user program to worry about this "
"direction."
msgstr ""

#. type: Plain text
#: man-pages/man3/makecontext.3:152
msgid ""
"On architectures where I<int> and pointer types are the same size (e.g., "
"x86-32, where both types are 32 bits), you may be able to get away with "
"passing pointers as arguments to B<makecontext>()  following I<argc>.  "
"However, doing this is not guaranteed to be portable, is undefined according"
" to the standards, and won't work on architectures where pointers are larger"
" than I<int>s.  Nevertheless, starting with version 2.8, glibc makes some "
"changes to B<makecontext>(), to permit this on some 64-bit architectures "
"(e.g., x86-64)."
msgstr ""

#. type: Plain text
#: man-pages/man3/makecontext.3:160
msgid ""
"The example program below demonstrates the use of B<getcontext>(3), "
"B<makecontext>(), and B<swapcontext>().  Running the program produces the "
"following output:"
msgstr ""

#. type: Plain text
#: man-pages/man3/makecontext.3:172
#, no-wrap
msgid ""
"$B< ./a.out>\n"
"main: swapcontext(&uctx_main, &uctx_func2)\n"
"func2: started\n"
"func2: swapcontext(&uctx_func2, &uctx_func1)\n"
"func1: started\n"
"func1: swapcontext(&uctx_func1, &uctx_func2)\n"
"func2: returning\n"
"func1: returning\n"
"main: exiting\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/makecontext.3:180
#, no-wrap
msgid ""
"#include E<lt>ucontext.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/makecontext.3:182
#, no-wrap
msgid "static ucontext_t uctx_main, uctx_func1, uctx_func2;\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/makecontext.3:195
#, no-wrap
msgid ""
"static void\n"
"func1(void)\n"
"{\n"
"    printf(\"func1: started\\en\");\n"
"    printf(\"func1: swapcontext(&uctx_func1, &uctx_func2)\\en\");\n"
"    if (swapcontext(&uctx_func1, &uctx_func2) == -1)\n"
"        handle_error(\"swapcontext\");\n"
"    printf(\"func1: returning\\en\");\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/makecontext.3:205
#, no-wrap
msgid ""
"static void\n"
"func2(void)\n"
"{\n"
"    printf(\"func2: started\\en\");\n"
"    printf(\"func2: swapcontext(&uctx_func2, &uctx_func1)\\en\");\n"
"    if (swapcontext(&uctx_func2, &uctx_func1) == -1)\n"
"        handle_error(\"swapcontext\");\n"
"    printf(\"func2: returning\\en\");\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/makecontext.3:211
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    char func1_stack[16384];\n"
"    char func2_stack[16384];\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/makecontext.3:218
#, no-wrap
msgid ""
"    if (getcontext(&uctx_func1) == -1)\n"
"        handle_error(\"getcontext\");\n"
"    uctx_func1.uc_stack.ss_sp = func1_stack;\n"
"    uctx_func1.uc_stack.ss_size = sizeof(func1_stack);\n"
"    uctx_func1.uc_link = &uctx_main;\n"
"    makecontext(&uctx_func1, func1, 0);\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/makecontext.3:226
#, no-wrap
msgid ""
"    if (getcontext(&uctx_func2) == -1)\n"
"        handle_error(\"getcontext\");\n"
"    uctx_func2.uc_stack.ss_sp = func2_stack;\n"
"    uctx_func2.uc_stack.ss_size = sizeof(func2_stack);\n"
"    /* Successor context is f1(), unless argc E<gt> 1 */\n"
"    uctx_func2.uc_link = (argc E<gt> 1) ? NULL : &uctx_func1;\n"
"    makecontext(&uctx_func2, func2, 0);\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/makecontext.3:230
#, no-wrap
msgid ""
"    printf(\"main: swapcontext(&uctx_main, &uctx_func2)\\en\");\n"
"    if (swapcontext(&uctx_main, &uctx_func2) == -1)\n"
"        handle_error(\"swapcontext\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/makecontext.3:234
#, no-wrap
msgid ""
"    printf(\"main: exiting\\en\");\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/makecontext.3:240
msgid ""
"B<sigaction>(2), B<sigaltstack>(2), B<sigprocmask>(2), B<getcontext>(3), "
"B<sigsetjmp>(3)"
msgstr ""

#. type: TH
#: man-pages/man3/memmem.3:30
#, no-wrap
msgid "MEMMEM"
msgstr ""

#. type: Plain text
#: man-pages/man3/memmem.3:33
msgid "memmem - locate a substring"
msgstr ""

#. type: Plain text
#: man-pages/man3/memmem.3:40
#, no-wrap
msgid ""
"B<void *memmem(const void *>I<haystack>B<, size_t >I<haystacklen>B<,>\n"
"B<             const void *>I<needle>B<, size_t >I<needlelen>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/memmem.3:54
msgid ""
"The B<memmem>()  function finds the start of the first occurrence of the "
"substring I<needle> of length I<needlelen> in the memory area I<haystack> of"
" length I<haystacklen>."
msgstr ""

#. type: Plain text
#: man-pages/man3/memmem.3:59
msgid ""
"The B<memmem>()  function returns a pointer to the beginning of the "
"substring, or NULL if the substring is not found."
msgstr ""

#. type: tbl table
#: man-pages/man3/memmem.3:69
#, no-wrap
msgid "B<memmem>()"
msgstr ""

#. type: Plain text
#: man-pages/man3/memmem.3:74
msgid ""
"This function is not specified in POSIX.1, but is present on a number of "
"other systems."
msgstr ""

#.  This function was broken in Linux libraries up to and including libc
#. 5.0.9;
#.  there the
#.  .IR needle
#.  and
#.  .I haystack
#.  arguments were interchanged,
#.  and a pointer to the end of the first occurrence of
#.  .I needle
#.  was returned.
#.  Both old and new libc's have the bug that if
#.  .I needle
#.  is empty,
#.  .I haystack\-1
#.  (instead of
#.  .IR haystack )
#.  is returned.
#. type: Plain text
#: man-pages/man3/memmem.3:99
msgid ""
"In glibc 2.0, if I<needle> is empty, B<memmem>()  returns a pointer to the "
"last byte of I<haystack>.  This is fixed in glibc 2.1."
msgstr ""

#. type: Plain text
#: man-pages/man3/memmem.3:101
msgid "B<bstring>(3), B<strstr>(3)"
msgstr ""

#. type: TH
#: man-pages/man3/mkstemp.3:35
#, no-wrap
msgid "MKSTEMP"
msgstr ""

#. type: Plain text
#: man-pages/man3/mkstemp.3:38
msgid ""
"mkstemp, mkostemp, mkstemps, mkostemps - create a unique temporary file"
msgstr ""

#. type: Plain text
#: man-pages/man3/mkstemp.3:43
#, no-wrap
msgid "B<int mkstemp(char *>I<template>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/mkstemp.3:45
#, no-wrap
msgid "B<int mkostemp(char *>I<template>B<, int >I<flags>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/mkstemp.3:47
#, no-wrap
msgid "B<int mkstemps(char *>I<template>B<, int >I<suffixlen>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/mkstemp.3:49
#, no-wrap
msgid ""
"B<int mkostemps(char *>I<template>B<, int >I<suffixlen>B<, int "
">I<flags>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/mkstemp.3:57
msgid "B<mkstemp>():"
msgstr ""

#.     || _XOPEN_SOURCE\ &&\ _XOPEN_SOURCE_EXTENDED
#. type: Plain text
#: man-pages/man3/mkstemp.3:64
#, no-wrap
msgid ""
"_XOPEN_SOURCE\\ E<gt>=\\ 500\n"
"    || /* Since glibc 2.12: */ _POSIX_C_SOURCE\\ E<gt>=\\ 200809L\n"
"    || /* Glibc versions E<lt>= 2.19: */ _SVID_SOURCE || _BSD_SOURCE\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/mkstemp.3:70
msgid "B<mkostemp>(): _GNU_SOURCE"
msgstr ""

#. type: Plain text
#: man-pages/man3/mkstemp.3:74
#, no-wrap
msgid ""
"B<mkstemps>():\n"
"    /* Glibc since 2.19: */ _DEFAULT_SOURCE\n"
"        || /* Glibc versions E<lt>= 2.19: */ _SVID_SOURCE || _BSD_SOURCE\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/mkstemp.3:77
msgid "B<mkostemps>(): _GNU_SOURCE"
msgstr ""

#. type: Plain text
#: man-pages/man3/mkstemp.3:84
msgid ""
"The B<mkstemp>()  function generates a unique temporary filename from "
"I<template>, creates and opens the file, and returns an open file descriptor"
" for the file."
msgstr ""

#. type: Plain text
#: man-pages/man3/mkstemp.3:92
msgid ""
"The last six characters of I<template> must be \"XXXXXX\" and these are "
"replaced with a string that makes the filename unique.  Since it will be "
"modified, I<template> must not be a string constant, but should be declared "
"as a character array."
msgstr ""

#. type: Plain text
#: man-pages/man3/mkstemp.3:100
msgid ""
"The file is created with permissions 0600, that is, read plus write for "
"owner only.  The returned file descriptor provides both read and write "
"access to the file.  The file is opened with the B<open>(2)  B<O_EXCL> flag,"
" guaranteeing that the caller is the process that creates the file."
msgstr ""

#.  Reportedly, FreeBSD
#. type: Plain text
#: man-pages/man3/mkstemp.3:131
msgid ""
"The B<mkostemp>()  function is like B<mkstemp>(), with the difference that "
"the following bits\\(emwith the same meaning as for B<open>(2)\\(emmay be "
"specified in I<flags>: B<O_APPEND>, B<O_CLOEXEC>, and B<O_SYNC>.  Note that "
"when creating the file, B<mkostemp>()  includes the values B<O_RDWR>, "
"B<O_CREAT>, and B<O_EXCL> in the I<flags> argument given to B<open>(2); "
"including these values in the I<flags> argument given to B<mkostemp>()  is "
"unnecessary, and produces errors on some systems."
msgstr ""

#. type: Plain text
#: man-pages/man3/mkstemp.3:147
msgid ""
"The B<mkstemps>()  function is like B<mkstemp>(), except that the string in "
"I<template> contains a suffix of I<suffixlen> characters.  Thus, I<template>"
" is of the form I<prefixXXXXXXsuffix>, and the string XXXXXX is modified as "
"for B<mkstemp>()."
msgstr ""

#. type: Plain text
#: man-pages/man3/mkstemp.3:156
msgid ""
"The B<mkostemps>()  function is to B<mkstemps>()  as B<mkostemp>()  is to "
"B<mkstemp>()."
msgstr ""

#. type: Plain text
#: man-pages/man3/mkstemp.3:162
msgid ""
"On success, these functions return the file descriptor of the temporary "
"file.  On error, -1 is returned, and I<errno> is set appropriately."
msgstr ""

#. type: Plain text
#: man-pages/man3/mkstemp.3:167
msgid ""
"Could not create a unique temporary filename.  Now the contents of "
"I<template> are undefined."
msgstr ""

#. type: Plain text
#: man-pages/man3/mkstemp.3:175
msgid ""
"For B<mkstemp>()  and B<mkostemp>(): The last six characters of I<template> "
"were not XXXXXX; now I<template> is unchanged."
msgstr ""

#. type: Plain text
#: man-pages/man3/mkstemp.3:186
msgid ""
"For B<mkstemps>()  and B<mkostemps>(): I<template> is less than I<(6 + "
"suffixlen)> characters long, or the last 6 characters before the suffix in "
"I<template> were not XXXXXX."
msgstr ""

#. type: Plain text
#: man-pages/man3/mkstemp.3:189
msgid ""
"These functions may also fail with any of the errors described for "
"B<open>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man3/mkstemp.3:196
msgid ""
"B<mkostemp>()  is available since glibc 2.7.  B<mkstemps>()  and "
"B<mkostemps>()  are available since glibc 2.11."
msgstr ""

#. type: tbl table
#: man-pages/man3/mkstemp.3:207
#, no-wrap
msgid ""
"B<mkstemp>(),\n"
"B<mkostemp>(),\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/mkstemp.3:210
#, no-wrap
msgid ""
"B<mkstemps>(),\n"
"B<mkostemps>()"
msgstr ""

#. type: Plain text
#: man-pages/man3/mkstemp.3:215
msgid "B<mkstemp>(): 4.3BSD, POSIX.1-2001."
msgstr ""

#.  mkstemps() appears to be at least on the BSDs, Mac OS X, Solaris,
#.  and Tru64.
#. type: Plain text
#: man-pages/man3/mkstemp.3:220
msgid "B<mkstemps>(): unstandardized, but appears on several other systems."
msgstr ""

#. type: Plain text
#: man-pages/man3/mkstemp.3:225
msgid "B<mkostemp>()  and B<mkostemps>(): are glibc extensions."
msgstr ""

#. type: Plain text
#: man-pages/man3/mkstemp.3:232
msgid ""
"In glibc versions 2.06 and earlier, the file is created with permissions "
"0666, that is, read and write for all users.  This old behavior may be a "
"security risk, especially since other UNIX flavors use 0600, and somebody "
"might overlook this detail when porting programs.  POSIX.1-2008 adds a "
"requirement that the file be created with mode 0600."
msgstr ""

#.  The prototype for
#.  .BR mkstemp ()
#.  is in
#.  .I <unistd.h>
#.  for libc4, libc5, glibc1; glibc2 follows POSIX.1 and has the prototype in
#.  .IR <stdlib.h> .
#. type: Plain text
#: man-pages/man3/mkstemp.3:250
msgid ""
"More generally, the POSIX specification of B<mkstemp>()  does not say "
"anything about file modes, so the application should make sure its file mode"
" creation mask (see B<umask>(2))  is set appropriately before calling "
"B<mkstemp>()  (and B<mkostemp>())."
msgstr ""

#. type: Plain text
#: man-pages/man3/mkstemp.3:255
msgid ""
"B<mkdtemp>(3), B<mktemp>(3), B<tempnam>(3), B<tmpfile>(3), B<tmpnam>(3)"
msgstr ""

#. type: TH
#: man-pages/man3/mq_close.3:26
#, no-wrap
msgid "MQ_CLOSE"
msgstr ""

#. type: Plain text
#: man-pages/man3/mq_close.3:29
msgid "mq_close - close a message queue descriptor"
msgstr ""

#. type: Plain text
#: man-pages/man3/mq_close.3:34
#, no-wrap
msgid "B<int mq_close(mqd_t >I<mqdes>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/mq_close.3:41
msgid "B<mq_close>()  closes the message queue descriptor I<mqdes>."
msgstr ""

#. type: Plain text
#: man-pages/man3/mq_close.3:48
msgid ""
"If the calling process has attached a notification request (see "
"(B<mq_notify>(3))  to this message queue via I<mqdes>, then this request is "
"removed, and another process can now attach a notification request."
msgstr ""

#. type: Plain text
#: man-pages/man3/mq_close.3:54
msgid ""
"On success B<mq_close>()  returns 0; on error, -1 is returned, with I<errno>"
" set to indicate the error."
msgstr ""

#. type: tbl table
#: man-pages/man3/mq_close.3:70
#, no-wrap
msgid "B<mq_close>()"
msgstr ""

#. type: Plain text
#: man-pages/man3/mq_close.3:78
msgid ""
"All open message queues are automatically closed on process termination, or "
"upon B<execve>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man3/mq_close.3:85
msgid ""
"B<mq_getattr>(3), B<mq_notify>(3), B<mq_open>(3), B<mq_receive>(3), "
"B<mq_send>(3), B<mq_unlink>(3), B<mq_overview>(7)"
msgstr ""

#. type: TH
#: man-pages/man3/mq_open.3:26
#, no-wrap
msgid "MQ_OPEN"
msgstr ""

#. type: Plain text
#: man-pages/man3/mq_open.3:29
msgid "mq_open - open a message queue"
msgstr ""

#. type: Plain text
#: man-pages/man3/mq_open.3:34
#, no-wrap
msgid ""
"B<#include E<lt>fcntl.hE<gt>>           /* For O_* constants */\n"
"B<#include E<lt>sys/stat.hE<gt>>        /* For mode constants */\n"
"B<#include E<lt>mqueue.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/mq_open.3:38
#, no-wrap
msgid ""
"B<mqd_t mq_open(const char *>I<name>B<, int >I<oflag>B<);>\n"
"B<mqd_t mq_open(const char *>I<name>B<, int >I<oflag>B<, mode_t >I<mode>B<,>\n"
"B<              struct mq_attr *>I<attr>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/mq_open.3:50
msgid ""
"B<mq_open>()  creates a new POSIX message queue or opens an existing queue."
"  The queue is identified by I<name>.  For details of the construction of "
"I<name>, see B<mq_overview>(7)."
msgstr ""

#. type: Plain text
#: man-pages/man3/mq_open.3:58
msgid ""
"The I<oflag> argument specifies flags that control the operation of the "
"call.  (Definitions of the flags values can be obtained by including "
"I<E<lt>fcntl.hE<gt>>.)  Exactly one of the following must be specified in "
"I<oflag>:"
msgstr ""

#. type: TP
#: man-pages/man3/mq_open.3:58
#, no-wrap
msgid "B<O_RDONLY>"
msgstr ""

#. type: Plain text
#: man-pages/man3/mq_open.3:61
msgid "Open the queue to receive messages only."
msgstr ""

#. type: TP
#: man-pages/man3/mq_open.3:61
#, no-wrap
msgid "B<O_WRONLY>"
msgstr ""

#. type: Plain text
#: man-pages/man3/mq_open.3:64
msgid "Open the queue to send messages only."
msgstr ""

#. type: TP
#: man-pages/man3/mq_open.3:64
#, no-wrap
msgid "B<O_RDWR>"
msgstr ""

#. type: Plain text
#: man-pages/man3/mq_open.3:67
msgid "Open the queue to both send and receive messages."
msgstr ""

#. type: Plain text
#: man-pages/man3/mq_open.3:72
msgid ""
"Zero or more of the following flags can additionally be I<OR>ed in I<oflag>:"
msgstr ""

#. type: TP
#: man-pages/man3/mq_open.3:72
#, no-wrap
msgid "B<O_CLOEXEC> (since Linux 2.6.26)"
msgstr ""

#.  commit 269f21344b23e552c21c9e2d7ca258479dcd7a0a
#. type: Plain text
#: man-pages/man3/mq_open.3:79
msgid ""
"Set the close-on-exec flag for the message queue descriptor.  See B<open>(2)"
"  for a discussion of why this flag is useful."
msgstr ""

#. type: TP
#: man-pages/man3/mq_open.3:79
#, no-wrap
msgid "B<O_CREAT>"
msgstr ""

#.  In reality the filesystem IDs are used on Linux.
#. type: Plain text
#: man-pages/man3/mq_open.3:87
msgid ""
"Create the message queue if it does not exist.  The owner (user ID) of the "
"message queue is set to the effective user ID of the calling process.  The "
"group ownership (group ID) is set to the effective group ID of the calling "
"process."
msgstr ""

#. type: TP
#: man-pages/man3/mq_open.3:87
#, no-wrap
msgid "B<O_EXCL>"
msgstr ""

#. type: Plain text
#: man-pages/man3/mq_open.3:97
msgid ""
"If B<O_CREAT> was specified in I<oflag>, and a queue with the given I<name> "
"already exists, then fail with the error B<EEXIST>."
msgstr ""

#. type: TP
#: man-pages/man3/mq_open.3:97
#, no-wrap
msgid "B<O_NONBLOCK>"
msgstr ""

#. type: Plain text
#: man-pages/man3/mq_open.3:106
msgid ""
"Open the queue in nonblocking mode.  In circumstances where B<mq_receive>(3)"
"  and B<mq_send>(3)  would normally block, these functions instead fail with"
" the error B<EAGAIN>."
msgstr ""

#. type: Plain text
#: man-pages/man3/mq_open.3:120
msgid ""
"If B<O_CREAT> is specified in I<oflag>, then two additional arguments must "
"be supplied.  The I<mode> argument specifies the permissions to be placed on"
" the new queue, as for B<open>(2).  (Symbolic definitions for the "
"permissions bits can be obtained by including I<E<lt>sys/stat.hE<gt>>.)  The"
" permissions settings are masked against the process umask."
msgstr ""

#. type: Plain text
#: man-pages/man3/mq_open.3:128
msgid ""
"The fields of the I<struct mq_attr> pointed to I<attr> specify the maximum "
"number of messages and the maximum size of messages that the queue will "
"allow.  This structure is defined as follows:"
msgstr ""

#. type: Plain text
#: man-pages/man3/mq_open.3:139
#, no-wrap
msgid ""
"struct mq_attr {\n"
"    long mq_flags;       /* Flags (ignored for mq_open()) */\n"
"    long mq_maxmsg;      /* Max. # of messages on queue */\n"
"    long mq_msgsize;     /* Max. message size (bytes) */\n"
"    long mq_curmsgs;     /* # of messages currently in queue\n"
"                            (ignored for mq_open()) */\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/mq_open.3:149
msgid ""
"Only the I<mq_maxmsg> and I<mq_msgsize> fields are employed when calling "
"B<mq_open>(); the values in the remaining fields are ignored."
msgstr ""

#. type: Plain text
#: man-pages/man3/mq_open.3:159
msgid ""
"If I<attr> is NULL, then the queue is created with implementation-defined "
"default attributes.  Since Linux 3.5, two I</proc> files can be used to "
"control these defaults; see B<mq_overview>(7)  for details."
msgstr ""

#. type: Plain text
#: man-pages/man3/mq_open.3:171
msgid ""
"On success, B<mq_open>()  returns a message queue descriptor for use by "
"other message queue functions.  On error, B<mq_open>()  returns I<(mqd_t)\\ "
"-1>, with I<errno> set to indicate the error."
msgstr ""

#. type: Plain text
#: man-pages/man3/mq_open.3:176
msgid ""
"The queue exists, but the caller does not have permission to open it in the "
"specified mode."
msgstr ""

#.  Note that this isn't consistent with the same case for sem_open()
#. type: Plain text
#: man-pages/man3/mq_open.3:181
msgid "I<name> contained more than one slash."
msgstr ""

#. type: Plain text
#: man-pages/man3/mq_open.3:192
msgid ""
"Both B<O_CREAT> and B<O_EXCL> were specified in I<oflag>, but a queue with "
"this I<name> already exists."
msgstr ""

#.  glibc checks whether the name starts with a "/" and if not,
#.  gives this error
#. type: Plain text
#: man-pages/man3/mq_open.3:199
msgid "I<name> doesn't follow the format in B<mq_overview>(7)."
msgstr ""

#. type: Plain text
#: man-pages/man3/mq_open.3:231
msgid ""
"B<O_CREAT> was specified in I<oflag>, and I<attr> was not NULL, but "
"I<attr-E<gt>mq_maxmsg> or I<attr-E<gt>mq_msqsize> was invalid.  Both of "
"these fields must be greater than zero.  In a process that is unprivileged "
"(does not have the B<CAP_SYS_RESOURCE> capability), I<attr-E<gt>mq_maxmsg> "
"must be less than or equal to the I<msg_max> limit, and "
"I<attr-E<gt>mq_msgsize> must be less than or equal to the I<msgsize_max> "
"limit.  In addition, even in a privileged process, I<attr-E<gt>mq_maxmsg> "
"cannot exceed the B<HARD_MAX> limit.  (See B<mq_overview>(7)  for details of"
" these limits.)"
msgstr ""

#. type: Plain text
#: man-pages/man3/mq_open.3:239
msgid ""
"The per-process limit on the number of open file and message queue "
"descriptors has been reached (see the description of B<RLIMIT_NOFILE> in "
"B<getrlimit>(2))."
msgstr ""

#. type: Plain text
#: man-pages/man3/mq_open.3:243
msgid "I<name> was too long."
msgstr ""

#. type: Plain text
#: man-pages/man3/mq_open.3:247
msgid ""
"The system-wide limit on the total number of open files and message queues "
"has been reached."
msgstr ""

#. type: Plain text
#: man-pages/man3/mq_open.3:256
msgid ""
"The B<O_CREAT> flag was not specified in I<oflag>, and no queue with this "
"I<name> exists."
msgstr ""

#.  Note that this isn't consistent with the same case for sem_open()
#. type: Plain text
#: man-pages/man3/mq_open.3:261
msgid "I<name> was just \"/\" followed by no other characters."
msgstr ""

#. type: Plain text
#: man-pages/man3/mq_open.3:271
msgid ""
"Insufficient space for the creation of a new message queue.  This probably "
"occurred because the I<queues_max> limit was encountered; see "
"B<mq_overview>(7)."
msgstr ""

#. type: tbl table
#: man-pages/man3/mq_open.3:281
#, no-wrap
msgid "B<mq_open>()"
msgstr ""

#. type: Plain text
#: man-pages/man3/mq_open.3:303
msgid ""
"The B<mq_open>()  library function is implemented on top of a system call of"
" the same name.  The library function performs the check that the I<name> "
"starts with a slash (/), giving the B<EINVAL> error if it does not.  The "
"kernel system call expects I<name> to contain no preceding slash, so the C "
"library function passes I<name> without the preceding slash (i.e., "
"I<name+1>)  to the system call."
msgstr ""

#. type: Plain text
#: man-pages/man3/mq_open.3:307
msgid ""
"In kernels before 2.6.14, the process umask was not applied to the "
"permissions specified in I<mode>."
msgstr ""

#. type: Plain text
#: man-pages/man3/mq_open.3:314
msgid ""
"B<mq_close>(3), B<mq_getattr>(3), B<mq_notify>(3), B<mq_receive>(3), "
"B<mq_send>(3), B<mq_unlink>(3), B<mq_overview>(7)"
msgstr ""

#. type: TH
#: man-pages/man3/modf.3:33
#, no-wrap
msgid "MODF"
msgstr ""

#. type: Plain text
#: man-pages/man3/modf.3:37
msgid ""
"modf, modff, modfl - extract signed integral and fractional values from "
"floating-point number"
msgstr ""

#. type: Plain text
#: man-pages/man3/modf.3:44
#, no-wrap
msgid ""
"B<double modf(double >I<x>B<, double *>I<iptr>B<);>\n"
"B<float modff(float >I<x>B<, float *>I<iptr>B<);>\n"
"B<long double modfl(long double >I<x>B<, long double *>I<iptr>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/modf.3:56
msgid "B<modf>(), B<modfl>():"
msgstr ""

#. type: Plain text
#: man-pages/man3/modf.3:60
#, no-wrap
msgid ""
"_ISOC99_SOURCE || _POSIX_C_SOURCE\\ E<gt>=\\ 200112L\n"
"    || /* Since glibc 2.19: */ _DEFAULT_SOURCE\n"
"    || /* Glibc versions E<lt>= 2.19: */ _BSD_SOURCE || _SVID_SOURCE\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/modf.3:70
msgid ""
"These functions break the argument I<x> into an integral part and a "
"fractional part, each of which has the same sign as I<x>.  The integral part"
" is stored in the location pointed to by I<iptr>."
msgstr ""

#. type: Plain text
#: man-pages/man3/modf.3:73
msgid "These functions return the fractional part of I<x>."
msgstr ""

#. type: Plain text
#: man-pages/man3/modf.3:79
msgid "If I<x> is a NaN, a NaN is returned, and I<*iptr> is set to a NaN."
msgstr ""

#. type: Plain text
#: man-pages/man3/modf.3:85
msgid ""
"If I<x> is positive infinity (negative infinity), +0 (-0) is returned, and "
"I<*iptr> is set to positive infinity (negative infinity)."
msgstr ""

#. type: Plain text
#: man-pages/man3/modf.3:87
msgid "No errors occur."
msgstr ""

#. type: tbl table
#: man-pages/man3/modf.3:99
#, no-wrap
msgid ""
"B<modf>(),\n"
"B<modff>(),\n"
"B<modfl>()"
msgstr ""

#. type: Plain text
#: man-pages/man3/modf.3:103
msgid "C99, POSIX.1-2001, POSIX.1-2008."
msgstr ""

#. type: Plain text
#: man-pages/man3/modf.3:108
msgid "The variant returning I<double> also conforms to SVr4, 4.3BSD, C89."
msgstr ""

#. type: Plain text
#: man-pages/man3/modf.3:110
msgid "B<frexp>(3), B<ldexp>(3)"
msgstr ""

#. type: TH
#: man-pages/man3/mbrlen.3:16
#, no-wrap
msgid "MBRLEN"
msgstr ""

#. type: Plain text
#: man-pages/man3/mbrlen.3:19
msgid "mbrlen - determine number of bytes in next multibyte character"
msgstr ""

#. type: Plain text
#: man-pages/man3/mbrlen.3:24
#, no-wrap
msgid ""
"B<size_t mbrlen(const char *>I<s>B<, size_t >I<n>B<, mbstate_t "
"*>I<ps>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/mbrlen.3:43
msgid ""
"The B<mbrlen>()  function inspects at most I<n> bytes of the multibyte "
"string starting at I<s> and extracts the next complete multibyte character."
"  It updates the shift state I<*ps>.  If the multibyte character is not the "
"null wide character, it returns the number of bytes that were consumed from "
"I<s>.  If the multibyte character is the null wide character, it resets the "
"shift state I<*ps> to the initial state and returns 0."
msgstr ""

#. type: Plain text
#: man-pages/man3/mbrlen.3:59
msgid ""
"If the I<n> bytes starting at I<s> do not contain a complete multibyte "
"character, B<mbrlen>()  returns I<(size_t)\\ -2>.  This can happen even if "
"I<n> E<gt>= I<MB_CUR_MAX>, if the multibyte string contains redundant shift "
"sequences."
msgstr ""

#. type: Plain text
#: man-pages/man3/mbrlen.3:75
msgid ""
"If the multibyte string starting at I<s> contains an invalid multibyte "
"sequence before the next complete character, B<mbrlen>()  returns "
"I<(size_t)\\ -1> and sets I<errno> to B<EILSEQ>.  In this case, the effects "
"on I<*ps> are undefined."
msgstr ""

#. type: Plain text
#: man-pages/man3/mbrlen.3:81
msgid ""
"If I<ps> is NULL, a static anonymous state known only to the B<mbrlen>()  "
"function is used instead."
msgstr ""

#. type: Plain text
#: man-pages/man3/mbrlen.3:104
msgid ""
"The B<mbrlen>()  function returns the number of bytes parsed from the "
"multibyte sequence starting at I<s>, if a non-null wide character was "
"recognized.  It returns 0, if a null wide character was recognized.  It "
"returns I<(size_t)\\ -1> and sets I<errno> to B<EILSEQ>, if an invalid "
"multibyte sequence was encountered.  It returns I<(size_t)\\ -2> if it "
"couldn't parse a complete multibyte character, meaning that I<n> should be "
"increased."
msgstr ""

#. type: tbl table
#: man-pages/man3/mbrlen.3:114
#, no-wrap
msgid "B<mbrlen>()"
msgstr ""

#. type: tbl table
#: man-pages/man3/mbrlen.3:114
#, no-wrap
msgid "MT-Unsafe race:mbrlen/!ps"
msgstr ""

#. type: Plain text
#: man-pages/man3/mbrlen.3:125
msgid ""
"The behavior of B<mbrlen>()  depends on the B<LC_CTYPE> category of the "
"current locale."
msgstr ""

#. type: Plain text
#: man-pages/man3/mbrlen.3:126
msgid "B<mbrtowc>(3)"
msgstr ""

#. type: TH
#: man-pages/man3/memcpy.3:31
#, no-wrap
msgid "MEMCPY"
msgstr ""

#. type: Plain text
#: man-pages/man3/memcpy.3:34
msgid "memcpy - copy memory area"
msgstr ""

#. type: Plain text
#: man-pages/man3/memcpy.3:39
#, no-wrap
msgid ""
"B<void *memcpy(void *>I<dest>B<, const void *>I<src>B<, size_t >I<n>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/memcpy.3:49
msgid ""
"The B<memcpy>()  function copies I<n> bytes from memory area I<src> to "
"memory area I<dest>.  The memory areas must not overlap.  Use B<memmove>(3)"
"  if the memory areas do overlap."
msgstr ""

#. type: Plain text
#: man-pages/man3/memcpy.3:53
msgid "The B<memcpy>()  function returns a pointer to I<dest>."
msgstr ""

#. type: tbl table
#: man-pages/man3/memcpy.3:63
#, no-wrap
msgid "B<memcpy>()"
msgstr ""

#.  glibc commit 6fb8cbcb58a29fff73eb2101b34caa19a7f88eba
#.  From forward copying to backward copying
#. type: Plain text
#: man-pages/man3/memcpy.3:83
msgid ""
"Failure to observe the requirement that the memory areas do not overlap has "
"been the source of significant bugs.  (POSIX and the C standards are "
"explicit that employing B<memcpy>()  with overlapping areas produces "
"undefined behavior.)  Most notably, in glibc 2.13 a performance optimization"
" of B<memcpy>()  on some platforms (including x86-64) included changing the "
"order in which bytes were copied from I<src> to I<dest>."
msgstr ""

#.  Adobe Flash player was the highest profile example:
#.    https://bugzilla.redhat.com/show_bug.cgi?id=638477
#.    Reported: 2010-09-29 02:35 EDT by JCHuynh
#.    Bug 638477 - Strange sound on mp3 flash website
#.    https://sourceware.org/bugzilla/show_bug.cgi?id=12518
#.    Bug 12518 - memcpy acts randomly (and differently) with overlapping
#. areas
#.    Reported:       2011-02-25 02:26 UTC by Linus Torvalds
#.  glibc commit 0354e355014b7bfda32622e0255399d859862fcd
#. type: Plain text
#: man-pages/man3/memcpy.3:109
msgid ""
"This change revealed breakages in a number of applications that performed "
"copying with overlapping areas.  Under the previous implementation, the "
"order in which the bytes were copied had fortuitously hidden the bug, which "
"was revealed when the copying order was reversed.  In glibc 2.14, a "
"versioned symbol was added so that old binaries (i.e., those linked against "
"glibc versions earlier than 2.14)  employed a B<memcpy>()  implementation "
"that safely handles the overlapping buffers case (by providing an \"older\" "
"B<memcpy>()  implementation that was aliased to B<memmove>(3))."
msgstr ""

#. type: Plain text
#: man-pages/man3/memcpy.3:117
msgid ""
"B<bcopy>(3), B<bstring>(3), B<memccpy>(3), B<memmove>(3), B<mempcpy>(3), "
"B<strcpy>(3), B<strncpy>(3), B<wmemcpy>(3)"
msgstr ""

#. type: TH
#: man-pages/man3/memchr.3:32
#, no-wrap
msgid "MEMCHR"
msgstr ""

#. type: Plain text
#: man-pages/man3/memchr.3:35
msgid "memchr, memrchr, rawmemchr - scan memory for a character"
msgstr ""

#. type: Plain text
#: man-pages/man3/memchr.3:40
#, no-wrap
msgid "B<void *memchr(const void *>I<s>B<, int >I<c>B<, size_t >I<n>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/memchr.3:42
#, no-wrap
msgid "B<void *memrchr(const void *>I<s>B<, int >I<c>B<, size_t >I<n>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/memchr.3:44
#, no-wrap
msgid "B<void *rawmemchr(const void *>I<s>B<, int >I<c>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/memchr.3:54
msgid "B<memrchr>(), B<rawmemchr>(): _GNU_SOURCE"
msgstr ""

#. type: Plain text
#: man-pages/man3/memchr.3:70
msgid ""
"The B<memchr>()  function scans the initial I<n> bytes of the memory area "
"pointed to by I<s> for the first instance of I<c>.  Both I<c> and the bytes "
"of the memory area pointed to by I<s> are interpreted as I<unsigned char>."
msgstr ""

#. type: Plain text
#: man-pages/man3/memchr.3:81
msgid ""
"The B<memrchr>()  function is like the B<memchr>()  function, except that it"
" searches backward from the end of the I<n> bytes pointed to by I<s> instead"
" of forward from the beginning."
msgstr ""

#. type: Plain text
#: man-pages/man3/memchr.3:99
msgid ""
"The B<rawmemchr>()  function is similar to B<memchr>(): it assumes (i.e., "
"the programmer knows for certain)  that an instance of I<c> lies somewhere "
"in the memory area starting at the location pointed to by I<s>, and so "
"performs an optimized search for I<c> (i.e., no use of a count argument to "
"limit the range of the search).  If an instance of I<c> is not found, the "
"results are unpredictable.  The following call is a fast means of locating a"
" string's terminating null byte:"
msgstr ""

#. type: Plain text
#: man-pages/man3/memchr.3:103
#, no-wrap
msgid "char *p = rawmemchr(s,\\ \\(aq\\e0\\(aq);\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/memchr.3:113
msgid ""
"The B<memchr>()  and B<memrchr>()  functions return a pointer to the "
"matching byte or NULL if the character does not occur in the given memory "
"area."
msgstr ""

#. type: Plain text
#: man-pages/man3/memchr.3:118
msgid ""
"The B<rawmemchr>()  function returns a pointer to the matching byte, if one "
"is found.  If no matching byte is found, the result is unspecified."
msgstr ""

#. type: Plain text
#: man-pages/man3/memchr.3:121
msgid "B<rawmemchr>()  first appeared in glibc in version 2.1."
msgstr ""

#. type: Plain text
#: man-pages/man3/memchr.3:124
msgid "B<memrchr>()  first appeared in glibc in version 2.2."
msgstr ""

#. type: tbl table
#: man-pages/man3/memchr.3:136
#, no-wrap
msgid ""
"B<memchr>(),\n"
"B<memrchr>(),\n"
"B<rawmemchr>()"
msgstr ""

#. type: Plain text
#: man-pages/man3/memchr.3:141
msgid "B<memchr>(): POSIX.1-2001, POSIX.1-2008, C89, C99, SVr4, 4.3BSD."
msgstr ""

#. type: Plain text
#: man-pages/man3/memchr.3:145
msgid ""
"The B<memrchr>()  function is a GNU extension, available since glibc 2.1.91."
msgstr ""

#. type: Plain text
#: man-pages/man3/memchr.3:149
msgid ""
"The B<rawmemchr>()  function is a GNU extension, available since glibc 2.1."
msgstr ""

#. type: Plain text
#: man-pages/man3/memchr.3:161
msgid ""
"B<bstring>(3), B<ffs>(3), B<index>(3), B<memmem>(3), B<rindex>(3), "
"B<strchr>(3), B<strpbrk>(3), B<strrchr>(3), B<strsep>(3), B<strspn>(3), "
"B<strstr>(3), B<wmemchr>(3)"
msgstr ""

#. type: TH
#: man-pages/man3/mbsnrtowcs.3:15
#, no-wrap
msgid "MBSNRTOWCS"
msgstr ""

#. type: Plain text
#: man-pages/man3/mbsnrtowcs.3:18
msgid "mbsnrtowcs - convert a multibyte string to a wide-character string"
msgstr ""

#. type: Plain text
#: man-pages/man3/mbsnrtowcs.3:24
#, no-wrap
msgid ""
"B<size_t mbsnrtowcs(wchar_t *>I<dest>B<, const char **>I<src>B<,>\n"
"B<                  size_t >I<nms>B<, size_t >I<len>B<, mbstate_t *>I<ps>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/mbsnrtowcs.3:32
msgid "B<mbsnrtowcs>():"
msgstr ""

#. type: Plain text
#: man-pages/man3/mbsnrtowcs.3:41
msgid "_GNU_SOURCE"
msgstr ""

#. type: Plain text
#: man-pages/man3/mbsnrtowcs.3:55
msgid ""
"The B<mbsnrtowcs>()  function is like the B<mbsrtowcs>(3)  function, except "
"that the number of bytes to be converted, starting at I<*src>, is limited to"
" at most I<nms> bytes."
msgstr ""

#. type: Plain text
#: man-pages/man3/mbsnrtowcs.3:88
msgid ""
"If I<dest> is not NULL, the B<mbsnrtowcs>()  function converts at most "
"I<nms> bytes from the multibyte string I<*src> to a wide-character string "
"starting at I<dest>.  At most I<len> wide characters are written to I<dest>."
"  The shift state I<*ps> is updated.  The conversion is effectively "
"performed by repeatedly calling I<mbrtowc(dest, *src, n, ps)> where I<n> is "
"some positive number, as long as this call succeeds, and then incrementing "
"I<dest> by one and I<*src> by the number of bytes consumed.  The conversion "
"can stop for three reasons:"
msgstr ""

#. type: Plain text
#: man-pages/man3/mbsnrtowcs.3:115
msgid ""
"The I<nms> limit forces a stop, or I<len> non-L\\(aq\\e0\\(aq wide "
"characters have been stored at I<dest>.  In this case, I<*src> is left "
"pointing to the next multibyte sequence to be converted, and the number of "
"wide characters written to I<dest> is returned."
msgstr ""

#. type: Plain text
#: man-pages/man3/mbsnrtowcs.3:129
msgid ""
"The multibyte string has been completely converted, including the "
"terminating null wide character (\\(aq\\e0\\(aq)  (which has the side effect"
" of bringing back I<*ps> to the initial state).  In this case, I<*src> is "
"set to NULL, and the number of wide characters written to I<dest>, excluding"
" the terminating null wide character, is returned."
msgstr ""

#. type: Plain text
#: man-pages/man3/mbsnrtowcs.3:135
msgid ""
"According to POSIX.1, if the input buffer ends with an incomplete character,"
" it is unspecified whether conversion stops at the end of the previous "
"character (if any), or at the end of the input buffer.  The glibc "
"implementation adopts the former behavior."
msgstr ""

#. type: Plain text
#: man-pages/man3/mbsnrtowcs.3:144
msgid ""
"If I<dest> is NULL, I<len> is ignored, and the conversion proceeds as above,"
" except that the converted wide characters are not written out to memory, "
"and that no destination length limit exists."
msgstr ""

#. type: Plain text
#: man-pages/man3/mbsnrtowcs.3:151
msgid ""
"In both of the above cases, if I<ps> is NULL, a static anonymous state known"
" only to the B<mbsnrtowcs>()  function is used instead."
msgstr ""

#. type: Plain text
#: man-pages/man3/mbsnrtowcs.3:170
msgid ""
"The B<mbsnrtowcs>()  function returns the number of wide characters that "
"make up the converted part of the wide-character string, not including the "
"terminating null wide character.  If an invalid multibyte sequence was "
"encountered, I<(size_t)\\ -1> is returned, and I<errno> set to B<EILSEQ>."
msgstr ""

#. type: tbl table
#: man-pages/man3/mbsnrtowcs.3:180
#, no-wrap
msgid "B<mbsnrtowcs>()"
msgstr ""

#. type: tbl table
#: man-pages/man3/mbsnrtowcs.3:180
#, no-wrap
msgid "MT-Unsafe race:mbsnrtowcs/!ps"
msgstr ""

#. type: Plain text
#: man-pages/man3/mbsnrtowcs.3:185
msgid "POSIX.1-2008."
msgstr ""

#. type: Plain text
#: man-pages/man3/mbsnrtowcs.3:192
msgid ""
"The behavior of B<mbsnrtowcs>()  depends on the B<LC_CTYPE> category of the "
"current locale."
msgstr ""

#. type: Plain text
#: man-pages/man3/mbsnrtowcs.3:200
msgid "B<iconv>(3), B<mbrtowc>(3)  B<mbsinit>(3), B<mbsrtowcs>(3)"
msgstr ""

#. type: TH
#: man-pages/man3/malloc_get_state.3:25
#, no-wrap
msgid "MALLOC_GET_STATE"
msgstr ""

#. type: Plain text
#: man-pages/man3/malloc_get_state.3:28
msgid ""
"malloc_get_state, malloc_set_state - record and restore state of malloc "
"implementation"
msgstr ""

#. type: Plain text
#: man-pages/man3/malloc_get_state.3:33
#, no-wrap
msgid "B<void* malloc_get_state(void);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/malloc_get_state.3:35
#, no-wrap
msgid "B<int malloc_set_state(void *>I<state>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/malloc_get_state.3:39
msgid "I<Note>: these function are removed in glibc version 2.25."
msgstr ""

#. type: Plain text
#: man-pages/man3/malloc_get_state.3:56
msgid ""
"The B<malloc_get_state>()  function records the current state of all "
"B<malloc>(3)  internal bookkeeping variables (but not the actual contents of"
" the heap or the state of B<malloc_hook>(3)  functions pointers).  The state"
" is recorded in a system-dependent opaque data structure dynamically "
"allocated via B<malloc>(3), and a pointer to that data structure is returned"
" as the function result.  (It is the caller's responsibility to B<free>(3)  "
"this memory.)"
msgstr ""

#. type: Plain text
#: man-pages/man3/malloc_get_state.3:64
msgid ""
"The B<malloc_set_state>()  function restores the state of all B<malloc>(3)  "
"internal bookkeeping variables to the values recorded in the opaque data "
"structure pointed to by I<state>."
msgstr ""

#. type: Plain text
#: man-pages/man3/malloc_get_state.3:71
msgid ""
"On success, B<malloc_get_state>()  returns a pointer to a newly allocated "
"opaque data structure.  On error (for example, memory could not be allocated"
" for the data structure), B<malloc_get_state>()  returns NULL."
msgstr ""

#.  if(ms->magic != MALLOC_STATE_MAGIC) return -1;
#.  /* Must fail if the major version is too high. */
#.  if((ms->version & ~0xffl) > (MALLOC_STATE_VERSION & ~0xffl)) return -2;
#. type: Plain text
#: man-pages/man3/malloc_get_state.3:89
msgid ""
"On success, B<malloc_set_state>()  returns 0.  If the implementation detects"
" that I<state> does not point to a correctly formed data structure, "
"B<malloc_set_state>()  returns -1.  If the implementation detects that the "
"version of the data structure referred to by I<state> is a more recent "
"version than this implementation knows about, B<malloc_set_state>()  returns"
" -2."
msgstr ""

#. type: tbl table
#: man-pages/man3/malloc_get_state.3:100
#, no-wrap
msgid ""
"B<malloc_get_state>(),\n"
"B<malloc_set_state>()"
msgstr ""

#. type: Plain text
#: man-pages/man3/malloc_get_state.3:111
msgid ""
"These functions are useful when using this B<malloc>(3)  implementation as "
"part of a shared library, and the heap contents are saved/restored via some "
"other method.  This technique is used by GNU Emacs to implement its "
"\"dumping\" function."
msgstr ""

#.  i.e., calls __malloc_check_init()
#.  i.e., malloc checking is not already in use
#.  and the caller requested malloc checking
#. type: Plain text
#: man-pages/man3/malloc_get_state.3:128
msgid ""
"Hook function pointers are never saved or restored by these functions, with "
"two exceptions: if malloc checking (see B<mallopt>(3))  was in use when "
"B<malloc_get_state>()  was called, then B<malloc_set_state>()  resets malloc"
" checking hooks if possible; if malloc checking was not in use in the "
"recorded state, but the caller has requested malloc checking, then the hooks"
" are reset to 0."
msgstr ""

#. type: Plain text
#: man-pages/man3/malloc_get_state.3:130
msgid "B<malloc>(3), B<mallopt>(3)"
msgstr ""

#. type: TH
#: man-pages/man3/malloc_hook.3:10
#, no-wrap
msgid "MALLOC_HOOK"
msgstr ""

#. type: Plain text
#: man-pages/man3/malloc_hook.3:15
msgid ""
"__malloc_hook, __malloc_initialize_hook, __memalign_hook, __free_hook, "
"__realloc_hook, __after_morecore_hook - malloc debugging variables"
msgstr ""

#. type: Plain text
#: man-pages/man3/malloc_hook.3:20
#, no-wrap
msgid ""
"B<void *(*__malloc_hook)(size_t >I<size>B<, const void *>I<caller>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/malloc_hook.3:23
#, no-wrap
msgid ""
"B<void *(*__realloc_hook)(void *>I<ptr>B<, size_t >I<size>B<, const void "
"*>I<caller>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/malloc_hook.3:26
#, no-wrap
msgid ""
"B<void *(*__memalign_hook)(size_t >I<alignment>B<, size_t >I<size>B<,>\n"
"B<                         const void *>I<caller>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/malloc_hook.3:28
#, no-wrap
msgid "B<void (*__free_hook)(void *>I<ptr>B<, const void *>I<caller>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/malloc_hook.3:30
#, no-wrap
msgid "B<void (*__malloc_initialize_hook)(void);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/malloc_hook.3:32
#, no-wrap
msgid "B<void (*__after_morecore_hook)(void);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/malloc_hook.3:43
msgid ""
"The GNU C library lets you modify the behavior of B<malloc>(3), "
"B<realloc>(3), and B<free>(3)  by specifying appropriate hook functions.  "
"You can use these hooks to help you debug programs that use dynamic memory "
"allocation, for example."
msgstr ""

#. type: Plain text
#: man-pages/man3/malloc_hook.3:50
msgid ""
"The variable B<__malloc_initialize_hook> points at a function that is called"
" once when the malloc implementation is initialized.  This is a weak "
"variable, so it can be overridden in the application with a definition like "
"the following:"
msgstr ""

#. type: Plain text
#: man-pages/man3/malloc_hook.3:54
#, no-wrap
msgid "void (*__malloc_initialize_hook)(void) = my_init_hook;\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/malloc_hook.3:60
msgid ""
"Now the function I<my_init_hook>()  can do the initialization of all hooks."
msgstr ""

#. type: Plain text
#: man-pages/man3/malloc_hook.3:76
msgid ""
"The four functions pointed to by B<__malloc_hook>, B<__realloc_hook>, "
"B<__memalign_hook>, B<__free_hook> have a prototype like the functions "
"B<malloc>(3), B<realloc>(3), B<memalign>(3), B<free>(3), respectively, "
"except that they have a final argument I<caller> that gives the address of "
"the caller of B<malloc>(3), etc."
msgstr ""

#. type: Plain text
#: man-pages/man3/malloc_hook.3:82
msgid ""
"The variable B<__after_morecore_hook> points at a function that is called "
"each time after B<sbrk>(2)  was asked for more memory."
msgstr ""

#.  https://bugzilla.redhat.com/show_bug.cgi?id=450187
#.  http://sourceware.org/bugzilla/show_bug.cgi?id=9957
#. type: Plain text
#: man-pages/man3/malloc_hook.3:94
msgid ""
"The use of these hook functions is not safe in multithreaded programs, and "
"they are now deprecated.  From glibc 2.24 onwards, the "
"B<__malloc_initialize_hook> variable has been removed from the API.  "
"Programmers should instead preempt calls to the relevant functions by "
"defining and exporting functions such as \"malloc\" and \"free\"."
msgstr ""

#. type: Plain text
#: man-pages/man3/malloc_hook.3:96
msgid "Here is a short example of how to use these variables."
msgstr ""

#. type: Plain text
#: man-pages/man3/malloc_hook.3:100
#, no-wrap
msgid ""
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>malloc.hE<gt>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/malloc_hook.3:104
#, no-wrap
msgid ""
"/* Prototypes for our hooks.  */\n"
"static void my_init_hook(void);\n"
"static void *my_malloc_hook(size_t, const void *);\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/malloc_hook.3:107
#, no-wrap
msgid ""
"/* Variables to save original hooks. */\n"
"static void *(*old_malloc_hook)(size_t, const void *);\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/malloc_hook.3:110
#, no-wrap
msgid ""
"/* Override initializing hook from the C library. */\n"
"void (*__malloc_initialize_hook) (void) = my_init_hook;\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/malloc_hook.3:117
#, no-wrap
msgid ""
"static void\n"
"my_init_hook(void)\n"
"{\n"
"    old_malloc_hook = __malloc_hook;\n"
"    __malloc_hook = my_malloc_hook;\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/malloc_hook.3:122
#, no-wrap
msgid ""
"static void *\n"
"my_malloc_hook(size_t size, const void *caller)\n"
"{\n"
"    void *result;\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/malloc_hook.3:125
#, no-wrap
msgid ""
"    /* Restore all old hooks */\n"
"    __malloc_hook = old_malloc_hook;\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/malloc_hook.3:128
#, no-wrap
msgid ""
"    /* Call recursively */\n"
"    result = malloc(size);\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/malloc_hook.3:131
#, no-wrap
msgid ""
"    /* Save underlying hooks */\n"
"    old_malloc_hook = __malloc_hook;\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/malloc_hook.3:135
#, no-wrap
msgid ""
"    /* printf() might call malloc(), so protect it too. */\n"
"    printf(\"malloc(%u) called from %p returns %p\\en\",\n"
"            (unsigned int) size, caller, result);\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/malloc_hook.3:138
#, no-wrap
msgid ""
"    /* Restore our own hooks */\n"
"    __malloc_hook = my_malloc_hook;\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/malloc_hook.3:141
#, no-wrap
msgid ""
"    return result;\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/malloc_hook.3:146
msgid "B<mallinfo>(3), B<malloc>(3), B<mcheck>(3), B<mtrace>(3)"
msgstr ""

#. type: TH
#: man-pages/man3/mq_unlink.3:26
#, no-wrap
msgid "MQ_UNLINK"
msgstr ""

#. type: Plain text
#: man-pages/man3/mq_unlink.3:29
msgid "mq_unlink - remove a message queue"
msgstr ""

#. type: Plain text
#: man-pages/man3/mq_unlink.3:34
#, no-wrap
msgid "B<int mq_unlink(const char *>I<name>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/mq_unlink.3:44
msgid ""
"B<mq_unlink>()  removes the specified message queue I<name>.  The message "
"queue name is removed immediately.  The queue itself is destroyed once any "
"other processes that have the queue open close their descriptors referring "
"to the queue."
msgstr ""

#. type: Plain text
#: man-pages/man3/mq_unlink.3:50
msgid ""
"On success B<mq_unlink>()  returns 0; on error, -1 is returned, with "
"I<errno> set to indicate the error."
msgstr ""

#. type: Plain text
#: man-pages/man3/mq_unlink.3:54
msgid "The caller does not have permission to unlink this message queue."
msgstr ""

#. type: Plain text
#: man-pages/man3/mq_unlink.3:62
msgid "There is no message queue with the given I<name>."
msgstr ""

#. type: tbl table
#: man-pages/man3/mq_unlink.3:72
#, no-wrap
msgid "B<mq_unlink>()"
msgstr ""

#. type: Plain text
#: man-pages/man3/mq_unlink.3:83
msgid ""
"B<mq_close>(3), B<mq_getattr>(3), B<mq_notify>(3), B<mq_open>(3), "
"B<mq_receive>(3), B<mq_send>(3), B<mq_overview>(7)"
msgstr ""

#. type: TH
#: man-pages/man3/malloc_usable_size.3:25
#, no-wrap
msgid "MALLOC_USABLE_SIZE"
msgstr ""

#. type: Plain text
#: man-pages/man3/malloc_usable_size.3:28
msgid ""
"malloc_usable_size - obtain size of block of memory allocated from heap"
msgstr ""

#. type: Plain text
#: man-pages/man3/malloc_usable_size.3:32
msgid "B<size_t malloc_usable_size (void *>I<ptr>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man3/malloc_usable_size.3:40
msgid ""
"The B<malloc_usable_size>()  function returns the number of usable bytes in "
"the block pointed to by I<ptr>, a pointer to a block of memory allocated by "
"B<malloc>(3)  or a related function."
msgstr ""

#. type: Plain text
#: man-pages/man3/malloc_usable_size.3:48
msgid ""
"B<malloc_usable_size>()  returns the number of usable bytes in the block of "
"allocated memory pointed to by I<ptr>.  If I<ptr> is NULL, 0 is returned."
msgstr ""

#. type: tbl table
#: man-pages/man3/malloc_usable_size.3:58
#, no-wrap
msgid "B<malloc_usable_size>()"
msgstr ""

#. type: Plain text
#: man-pages/man3/malloc_usable_size.3:72
msgid ""
"The value returned by B<malloc_usable_size>()  may be greater than the "
"requested size of the allocation because of alignment and minimum size "
"constraints.  Although the excess bytes can be overwritten by the "
"application without ill effects, this is not good programming practice: the "
"number of excess bytes in an allocation depends on the underlying "
"implementation."
msgstr ""

#. type: Plain text
#: man-pages/man3/malloc_usable_size.3:74
msgid "The main use of this function is for debugging and introspection."
msgstr ""

#. type: Plain text
#: man-pages/man3/malloc_usable_size.3:75
msgid "B<malloc>(3)"
msgstr ""

#. type: TH
#: man-pages/man3/malloc_stats.3:26
#, no-wrap
msgid "MALLOC_STATS"
msgstr ""

#. type: Plain text
#: man-pages/man3/malloc_stats.3:29
msgid "malloc_stats - print memory allocation statistics"
msgstr ""

#. type: Plain text
#: man-pages/man3/malloc_stats.3:33
msgid "B<void malloc_stats(void);>"
msgstr ""

#.  .SH VERSIONS
#.  Available already in glibc 2.0, possibly earlier
#. type: Plain text
#: man-pages/man3/malloc_stats.3:55
msgid ""
"The B<malloc_stats>()  function prints (on standard error) statistics about "
"memory allocated by B<malloc>(3)  and related functions.  For each arena "
"(allocation area), this function prints the total amount of memory allocated"
" and the total number of bytes consumed by in-use allocations.  (These two "
"values correspond to the I<arena> and I<uordblks> fields retrieved by "
"B<mallinfo>(3).)  In addition, the function prints the sum of these two "
"statistics for all arenas, and the maximum number of blocks and bytes that "
"were ever simultaneously allocated using B<mmap>(2)."
msgstr ""

#. type: tbl table
#: man-pages/man3/malloc_stats.3:65
#, no-wrap
msgid "B<malloc_stats>()"
msgstr ""

#. type: Plain text
#: man-pages/man3/malloc_stats.3:74
msgid ""
"More detailed information about memory allocations in the main arena can be "
"obtained using B<mallinfo>(3)."
msgstr ""

#. type: Plain text
#: man-pages/man3/malloc_stats.3:79
msgid ""
"B<mmap>(2), B<mallinfo>(3), B<malloc>(3), B<malloc_info>(3), B<mallopt>(3)"
msgstr ""

#. type: TH
#: man-pages/man3/malloc.3:33
#, no-wrap
msgid "MALLOC"
msgstr ""

#. type: Plain text
#: man-pages/man3/malloc.3:36
msgid "malloc, free, calloc, realloc - allocate and free dynamic memory"
msgstr ""

#. type: Plain text
#: man-pages/man3/malloc.3:45
#, no-wrap
msgid ""
"B<void *malloc(size_t >I<size>B<);>\n"
"B<void free(void >I<*ptr>B<);>\n"
"B<void *calloc(size_t >I<nmemb>B<, size_t >I<size>B<);>\n"
"B<void *realloc(void >I<*ptr>B<, size_t >I<size>B<);>\n"
"B<void *reallocarray(void >I<*ptr>B<, size_t >I<nmemb>B<, size_t >I<size>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/malloc.3:53
msgid "B<reallocarray>():"
msgstr ""

#. type: Plain text
#: man-pages/man3/malloc.3:59
#, no-wrap
msgid ""
"_GNU_SOURCE\n"
"    Since glibc 2.29:\n"
"        _DEFAULT_SOURCE\n"
"    Glibc 2.28 and earlier:\n"
"        _GNU_SOURCE\n"
msgstr ""

#.  glibc does this:
#. type: Plain text
#: man-pages/man3/malloc.3:76
msgid ""
"The B<malloc>()  function allocates I<size> bytes and returns a pointer to "
"the allocated memory.  I<The memory is not initialized>.  If I<size> is 0, "
"then B<malloc>()  returns either NULL, or a unique pointer value that can "
"later be successfully passed to B<free>()."
msgstr ""

#. type: Plain text
#: man-pages/man3/malloc.3:92
msgid ""
"The B<free>()  function frees the memory space pointed to by I<ptr>, which "
"must have been returned by a previous call to B<malloc>(), B<calloc>(), or "
"B<realloc>().  Otherwise, or if I<free(ptr)> has already been called before,"
" undefined behavior occurs.  If I<ptr> is NULL, no operation is performed."
msgstr ""

#.  glibc does this:
#. type: Plain text
#: man-pages/man3/malloc.3:122
msgid ""
"The B<calloc>()  function allocates memory for an array of I<nmemb> elements"
" of I<size> bytes each and returns a pointer to the allocated memory.  The "
"memory is set to zero.  If I<nmemb> or I<size> is 0, then B<calloc>()  "
"returns either NULL, or a unique pointer value that can later be "
"successfully passed to B<free>().  If the multiplication of I<nmemb> and "
"I<size> would result in integer overflow, then B<calloc>()  returns an "
"error.  By contrast, an integer overflow would not be detected in the "
"following call to B<malloc>(), with the result that an incorrectly sized "
"block of memory would be allocated:"
msgstr ""

#. type: Plain text
#: man-pages/man3/malloc.3:126
#, no-wrap
msgid "malloc(nmemb * size);\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/malloc.3:164
msgid ""
"The B<realloc>()  function changes the size of the memory block pointed to "
"by I<ptr> to I<size> bytes.  The contents will be unchanged in the range "
"from the start of the region up to the minimum of the old and new sizes.  If"
" the new size is larger than the old size, the added memory will I<not> be "
"initialized.  If I<ptr> is NULL, then the call is equivalent to "
"I<malloc(size)>, for all values of I<size>; if I<size> is equal to zero, and"
" I<ptr> is not NULL, then the call is equivalent to I<free(ptr)>.  Unless "
"I<ptr> is NULL, it must have been returned by an earlier call to "
"B<malloc>(), B<calloc>(), or B<realloc>().  If the area pointed to was "
"moved, a I<free(ptr)> is done."
msgstr ""

#. type: Plain text
#: man-pages/man3/malloc.3:175
msgid ""
"The B<reallocarray>()  function changes the size of the memory block pointed"
" to by I<ptr> to be large enough for an array of I<nmemb> elements, each of "
"which is I<size> bytes.  It is equivalent to the call"
msgstr ""

#. type: Plain text
#: man-pages/man3/malloc.3:178
#, no-wrap
msgid "    realloc(ptr, nmemb * size);\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/malloc.3:192
msgid ""
"However, unlike that B<realloc>()  call, B<reallocarray>()  fails safely in "
"the case where the multiplication would overflow.  If such an overflow "
"occurs, B<reallocarray>()  returns NULL, sets I<errno> to B<ENOMEM>, and "
"leaves the original block of memory unchanged."
msgstr ""

#. type: Plain text
#: man-pages/man3/malloc.3:212
msgid ""
"The B<malloc>()  and B<calloc>()  functions return a pointer to the "
"allocated memory, which is suitably aligned for any built-in type.  On "
"error, these functions return NULL.  NULL may also be returned by a "
"successful call to B<malloc>()  with a I<size> of zero, or by a successful "
"call to B<calloc>()  with I<nmemb> or I<size> equal to zero."
msgstr ""

#. type: Plain text
#: man-pages/man3/malloc.3:216
msgid "The B<free>()  function returns no value."
msgstr ""

#. type: Plain text
#: man-pages/man3/malloc.3:231
msgid ""
"The B<realloc>()  function returns a pointer to the newly allocated memory, "
"which is suitably aligned for any built-in type and may be different from "
"I<ptr>, or NULL if the request fails.  If I<size> was equal to 0, either "
"NULL or a pointer suitable to be passed to B<free>()  is returned.  If "
"B<realloc>()  fails, the original block is left untouched; it is not freed "
"or moved."
msgstr ""

#. type: Plain text
#: man-pages/man3/malloc.3:237
msgid ""
"On success, the B<reallocarray>()  function returns a pointer to the newly "
"allocated memory.  On failure, it returns NULL and the original block of "
"memory is left untouched."
msgstr ""

#. type: Plain text
#: man-pages/man3/malloc.3:244
msgid ""
"B<calloc>(), B<malloc>(), B<realloc>(), and B<reallocarray>()  can fail with"
" the following error:"
msgstr ""

#. type: Plain text
#: man-pages/man3/malloc.3:253
msgid ""
"Out of memory.  Possibly, the application hit the B<RLIMIT_AS> or "
"B<RLIMIT_DATA> limit described in B<getrlimit>(2)."
msgstr ""

#. type: tbl table
#: man-pages/man3/malloc.3:264
#, no-wrap
msgid ""
"B<malloc>(),\n"
"B<free>(),\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/malloc.3:267
#, no-wrap
msgid ""
"B<calloc>(),\n"
"B<realloc>()"
msgstr ""

#. type: Plain text
#: man-pages/man3/malloc.3:275
msgid ""
"B<malloc>(), B<free>(), B<calloc>(), B<realloc>(): POSIX.1-2001, "
"POSIX.1-2008, C89, C99."
msgstr ""

#. type: Plain text
#: man-pages/man3/malloc.3:278
msgid ""
"B<reallocarray>()  is a nonstandard extension that first appeared in OpenBSD"
" 5.6 and FreeBSD 11.0."
msgstr ""

#. type: Plain text
#: man-pages/man3/malloc.3:294
msgid ""
"By default, Linux follows an optimistic memory allocation strategy.  This "
"means that when B<malloc>()  returns non-NULL there is no guarantee that the"
" memory really is available.  In case it turns out that the system is out of"
" memory, one or more processes will be killed by the OOM killer.  For more "
"information, see the description of I</proc/sys/vm/overcommit_memory> and "
"I</proc/sys/vm/oom_adj> in B<proc>(5), and the Linux kernel source file "
"I<Documentation/vm/overcommit-accounting.rst>."
msgstr ""

#. type: Plain text
#: man-pages/man3/malloc.3:317
msgid ""
"Normally, B<malloc>()  allocates memory from the heap, and adjusts the size "
"of the heap as required, using B<sbrk>(2).  When allocating blocks of memory"
" larger than B<MMAP_THRESHOLD> bytes, the glibc B<malloc>()  implementation "
"allocates the memory as a private anonymous mapping using B<mmap>(2).  "
"B<MMAP_THRESHOLD> is 128\\ kB by default, but is adjustable using "
"B<mallopt>(3).  Prior to Linux 4.7 allocations performed using B<mmap>(2)  "
"were unaffected by the B<RLIMIT_DATA> resource limit; since Linux 4.7, this "
"limit is also enforced for allocations performed using B<mmap>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man3/malloc.3:335
msgid ""
"To avoid corruption in multithreaded applications, mutexes are used "
"internally to protect the memory-management data structures employed by "
"these functions.  In a multithreaded application in which threads "
"simultaneously allocate and free memory, there could be contention for these"
" mutexes.  To scalably handle memory allocation in multithreaded "
"applications, glibc creates additional I<memory allocation arenas> if mutex "
"contention is detected.  Each arena is a large region of memory that is "
"internally allocated by the system (using B<brk>(2)  or B<mmap>(2)), and "
"managed with its own mutexes."
msgstr ""

#. type: Plain text
#: man-pages/man3/malloc.3:353
msgid ""
"SUSv2 requires B<malloc>(), B<calloc>(), and B<realloc>()  to set I<errno> "
"to B<ENOMEM> upon failure.  Glibc assumes that this is done (and the glibc "
"versions of these routines do this); if you use a private malloc "
"implementation that does not set I<errno>, then certain library routines may"
" fail without having a reason in I<errno>."
msgstr ""

#. type: Plain text
#: man-pages/man3/malloc.3:362
msgid ""
"Crashes in B<malloc>(), B<calloc>(), B<realloc>(), or B<free>()  are almost "
"always related to heap corruption, such as overflowing an allocated chunk or"
" freeing the same pointer twice."
msgstr ""

#. type: Plain text
#: man-pages/man3/malloc.3:368
msgid ""
"The B<malloc>()  implementation is tunable via environment variables; see "
"B<mallopt>(3)  for details."
msgstr ""

#. type: Plain text
#: man-pages/man3/malloc.3:393
msgid ""
"B<valgrind>(1), B<brk>(2), B<mmap>(2), B<alloca>(3), B<malloc_get_state>(3),"
" B<malloc_info>(3), B<malloc_trim>(3), B<malloc_usable_size>(3), "
"B<mallopt>(3), B<mcheck>(3), B<mtrace>(3), B<posix_memalign>(3)"
msgstr ""

#. type: Plain text
#: man-pages/man3/malloc.3:396
msgid ""
"For details of the GNU C library implementation, see E<.UR "
"https://sourceware.org/glibc/wiki/MallocInternals> E<.UE .>"
msgstr ""

#. type: TH
#: man-pages/man3/mallinfo.3:26
#, no-wrap
msgid "MALLINFO"
msgstr ""

#. type: Plain text
#: man-pages/man3/mallinfo.3:29
msgid "mallinfo - obtain memory allocation information"
msgstr ""

#. type: Plain text
#: man-pages/man3/mallinfo.3:33
msgid "B<struct mallinfo mallinfo(void);>"
msgstr ""

#. type: Plain text
#: man-pages/man3/mallinfo.3:40
msgid ""
"The B<mallinfo>()  function returns a copy of a structure containing "
"information about memory allocations performed by B<malloc>(3)  and related "
"functions."
msgstr ""

#. type: Plain text
#: man-pages/man3/mallinfo.3:46
msgid ""
"Note that not all allocations are visible to B<mallinfo>(); see BUGS and "
"consider using B<malloc_info>(3)  instead."
msgstr ""

#. type: Plain text
#: man-pages/man3/mallinfo.3:48
msgid "The returned structure is defined as follows:"
msgstr ""

#. type: Plain text
#: man-pages/man3/mallinfo.3:63
#, no-wrap
msgid ""
"struct mallinfo {\n"
"    int arena;     /* Non-mmapped space allocated (bytes) */\n"
"    int ordblks;   /* Number of free chunks */\n"
"    int smblks;    /* Number of free fastbin blocks */\n"
"    int hblks;     /* Number of mmapped regions */\n"
"    int hblkhd;    /* Space allocated in mmapped regions (bytes) */\n"
"    int usmblks;   /* Maximum total allocated space (bytes) */\n"
"    int fsmblks;   /* Space in freed fastbin blocks (bytes) */\n"
"    int uordblks;  /* Total allocated space (bytes) */\n"
"    int fordblks;  /* Total free space (bytes) */\n"
"    int keepcost;  /* Top-most, releasable space (bytes) */\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/mallinfo.3:69
msgid ""
"The fields of the I<mallinfo> structure contain the following information:"
msgstr ""

#. type: TP
#: man-pages/man3/mallinfo.3:69
#, no-wrap
msgid "I<arena>"
msgstr ""

#. type: Plain text
#: man-pages/man3/mallinfo.3:75
msgid ""
"The total amount of memory allocated by means other than B<mmap>(2)  (i.e., "
"memory allocated on the heap).  This figure includes both in-use blocks and "
"blocks on the free list."
msgstr ""

#. type: TP
#: man-pages/man3/mallinfo.3:75
#, no-wrap
msgid "I<ordblks>"
msgstr ""

#. type: Plain text
#: man-pages/man3/mallinfo.3:78
msgid "The number of ordinary (i.e., non-fastbin) free blocks."
msgstr ""

#. type: TP
#: man-pages/man3/mallinfo.3:78
#, no-wrap
msgid "I<smblks>"
msgstr ""

#. type: Plain text
#: man-pages/man3/mallinfo.3:82
msgid "The number of fastbin free blocks (see B<mallopt>(3))."
msgstr ""

#. type: TP
#: man-pages/man3/mallinfo.3:82
#, no-wrap
msgid "I<hblks>"
msgstr ""

#. type: Plain text
#: man-pages/man3/mallinfo.3:90
msgid ""
"The number of blocks currently allocated using B<mmap>(2).  (See the "
"discussion of B<M_MMAP_THRESHOLD> in B<mallopt>(3).)"
msgstr ""

#. type: TP
#: man-pages/man3/mallinfo.3:90
#, no-wrap
msgid "I<hblkhd>"
msgstr ""

#. type: Plain text
#: man-pages/man3/mallinfo.3:94
msgid "The number of bytes in blocks currently allocated using B<mmap>(2)."
msgstr ""

#. type: TP
#: man-pages/man3/mallinfo.3:94
#, no-wrap
msgid "I<usmblks>"
msgstr ""

#. type: Plain text
#: man-pages/man3/mallinfo.3:99
msgid ""
"The \"highwater mark\" for allocated space\\(emthat is, the maximum amount "
"of space that was ever allocated.  This field is maintained only in "
"nonthreading environments."
msgstr ""

#. type: TP
#: man-pages/man3/mallinfo.3:99
#, no-wrap
msgid "I<fsmblks>"
msgstr ""

#. type: Plain text
#: man-pages/man3/mallinfo.3:102
msgid "The total number of bytes in fastbin free blocks."
msgstr ""

#. type: TP
#: man-pages/man3/mallinfo.3:102
#, no-wrap
msgid "I<uordblks>"
msgstr ""

#. type: Plain text
#: man-pages/man3/mallinfo.3:105
msgid "The total number of bytes used by in-use allocations."
msgstr ""

#. type: TP
#: man-pages/man3/mallinfo.3:105
#, no-wrap
msgid "I<fordblks>"
msgstr ""

#. type: Plain text
#: man-pages/man3/mallinfo.3:108
msgid "The total number of bytes in free blocks."
msgstr ""

#. type: TP
#: man-pages/man3/mallinfo.3:108
#, no-wrap
msgid "I<keepcost>"
msgstr ""

#.  .SH VERSIONS
#.  Available already in glibc 2.0, possibly earlier
#. type: Plain text
#: man-pages/man3/mallinfo.3:117
msgid ""
"The total amount of releasable free space at the top of the heap.  This is "
"the maximum number of bytes that could ideally (i.e., ignoring page "
"alignment restrictions, and so on) be released by B<malloc_trim>(3)."
msgstr ""

#. type: tbl table
#: man-pages/man3/mallinfo.3:127
#, no-wrap
msgid "B<mallinfo>()"
msgstr ""

#. type: tbl table
#: man-pages/man3/mallinfo.3:127
#, no-wrap
msgid "MT-Unsafe init const:mallopt"
msgstr ""

#. type: Plain text
#: man-pages/man3/mallinfo.3:143
msgid ""
"B<mallinfo>()  would access some global internal objects.  If modify them "
"with non-atomically, may get inconsistent results.  The identifier "
"I<mallopt> in I<const:mallopt> mean that B<mallopt>()  would modify the "
"global internal objects with atomics, that make sure B<mallinfo>()  is safe "
"enough, others modify with non-atomically maybe not."
msgstr ""

#. type: Plain text
#: man-pages/man3/mallinfo.3:147
msgid ""
"This function is not specified by POSIX or the C standards.  A similar "
"function exists on many System V derivatives, and was specified in the SVID."
msgstr ""

#.  FIXME . http://sourceware.org/bugzilla/show_bug.cgi?id=208
#.  See the 24 Aug 2011 mail by Paul Pluzhnikov:
#.      "[patch] Fix mallinfo() to accumulate results for all arenas"
#.  on libc-alpha@sourceware.org
#. type: Plain text
#: man-pages/man3/mallinfo.3:159
msgid ""
"B<Information is returned for only the main memory allocation area.> "
"Allocations in other arenas are excluded.  See B<malloc_stats>(3)  and "
"B<malloc_info>(3)  for alternatives that include information about other "
"arenas."
msgstr ""

#. type: Plain text
#: man-pages/man3/mallinfo.3:167
msgid ""
"The fields of the I<mallinfo> structure are typed as I<int>.  However, "
"because some internal bookkeeping values may be of type I<long>, the "
"reported values may wrap around zero and thus be inaccurate."
msgstr ""

#. type: Plain text
#: man-pages/man3/mallinfo.3:173
msgid ""
"The program below employs B<mallinfo>()  to retrieve memory allocation "
"statistics before and after allocating and freeing some blocks of memory.  "
"The statistics are displayed on standard output."
msgstr ""

#. type: Plain text
#: man-pages/man3/mallinfo.3:177
msgid ""
"The first two command-line arguments specify the number and size of blocks "
"to be allocated with B<malloc>(3)."
msgstr ""

#. type: Plain text
#: man-pages/man3/mallinfo.3:191
msgid ""
"The remaining three arguments specify which of the allocated blocks should "
"be freed with B<free>(3).  These three arguments are optional, and specify "
"(in order): the step size to be used in the loop that frees blocks (the "
"default is 1, meaning free all blocks in the range); the ordinal position of"
" the first block to be freed (default 0, meaning the first allocated block);"
" and a number one greater than the ordinal position of the last block to be "
"freed (default is one greater than the maximum block number).  If these "
"three arguments are omitted, then the defaults cause all allocated blocks to"
" be freed."
msgstr ""

#. type: Plain text
#: man-pages/man3/mallinfo.3:195
msgid ""
"In the following example run of the program, 1000 allocations of 100 bytes "
"are performed, and then every second allocated block is freed:"
msgstr ""

#. type: Plain text
#: man-pages/man3/mallinfo.3:210
#, no-wrap
msgid ""
"$ B<./a.out 1000 100 2>\n"
"============== Before allocating blocks ==============\n"
"Total non-mmapped bytes (arena):       0\n"
"# of free chunks (ordblks):            1\n"
"# of free fastbin blocks (smblks):     0\n"
"# of mapped regions (hblks):           0\n"
"Bytes in mapped regions (hblkhd):      0\n"
"Max. total allocated space (usmblks):  0\n"
"Free bytes held in fastbins (fsmblks): 0\n"
"Total allocated space (uordblks):      0\n"
"Total free space (fordblks):           0\n"
"Topmost releasable block (keepcost):   0\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/mallinfo.3:222
#, no-wrap
msgid ""
"============== After allocating blocks ==============\n"
"Total non-mmapped bytes (arena):       135168\n"
"# of free chunks (ordblks):            1\n"
"# of free fastbin blocks (smblks):     0\n"
"# of mapped regions (hblks):           0\n"
"Bytes in mapped regions (hblkhd):      0\n"
"Max. total allocated space (usmblks):  0\n"
"Free bytes held in fastbins (fsmblks): 0\n"
"Total allocated space (uordblks):      104000\n"
"Total free space (fordblks):           31168\n"
"Topmost releasable block (keepcost):   31168\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/mallinfo.3:234
#, no-wrap
msgid ""
"============== After freeing blocks ==============\n"
"Total non-mmapped bytes (arena):       135168\n"
"# of free chunks (ordblks):            501\n"
"# of free fastbin blocks (smblks):     0\n"
"# of mapped regions (hblks):           0\n"
"Bytes in mapped regions (hblkhd):      0\n"
"Max. total allocated space (usmblks):  0\n"
"Free bytes held in fastbins (fsmblks): 0\n"
"Total allocated space (uordblks):      52000\n"
"Total free space (fordblks):           83168\n"
"Topmost releasable block (keepcost):   31168\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/mallinfo.3:242
#, no-wrap
msgid ""
"#include E<lt>malloc.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/mallinfo.3:247
#, no-wrap
msgid ""
"static void\n"
"display_mallinfo(void)\n"
"{\n"
"    struct mallinfo mi;\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/mallinfo.3:249
#, no-wrap
msgid "    mi = mallinfo();\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/mallinfo.3:261
#, no-wrap
msgid ""
"    printf(\"Total non-mmapped bytes (arena):       %d\\en\", mi.arena);\n"
"    printf(\"# of free chunks (ordblks):            %d\\en\", mi.ordblks);\n"
"    printf(\"# of free fastbin blocks (smblks):     %d\\en\", mi.smblks);\n"
"    printf(\"# of mapped regions (hblks):           %d\\en\", mi.hblks);\n"
"    printf(\"Bytes in mapped regions (hblkhd):      %d\\en\", mi.hblkhd);\n"
"    printf(\"Max. total allocated space (usmblks):  %d\\en\", mi.usmblks);\n"
"    printf(\"Free bytes held in fastbins (fsmblks): %d\\en\", mi.fsmblks);\n"
"    printf(\"Total allocated space (uordblks):      %d\\en\", mi.uordblks);\n"
"    printf(\"Total free space (fordblks):           %d\\en\", mi.fordblks);\n"
"    printf(\"Topmost releasable block (keepcost):   %d\\en\", mi.keepcost);\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/mallinfo.3:269
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"#define MAX_ALLOCS 2000000\n"
"    char *alloc[MAX_ALLOCS];\n"
"    int numBlocks, j, freeBegin, freeEnd, freeStep;\n"
"    size_t blockSize;\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/mallinfo.3:275
#, no-wrap
msgid ""
"    if (argc E<lt> 3 || strcmp(argv[1], \"--help\") == 0) {\n"
"        fprintf(stderr, \"%s num-blocks block-size [free-step \"\n"
"                \"[start-free [end-free]]]\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/mallinfo.3:281
#, no-wrap
msgid ""
"    numBlocks = atoi(argv[1]);\n"
"    blockSize = atoi(argv[2]);\n"
"    freeStep = (argc E<gt> 3) ? atoi(argv[3]) : 1;\n"
"    freeBegin = (argc E<gt> 4) ? atoi(argv[4]) : 0;\n"
"    freeEnd = (argc E<gt> 5) ? atoi(argv[5]) : numBlocks;\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/mallinfo.3:284
#, no-wrap
msgid ""
"    printf(\"============== Before allocating blocks ==============\\en\");\n"
"    display_mallinfo();\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/mallinfo.3:290
#, no-wrap
msgid ""
"    for (j = 0; j E<lt> numBlocks; j++) {\n"
"        if (numBlocks E<gt>= MAX_ALLOCS) {\n"
"            fprintf(stderr, \"Too many allocations\\en\");\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/mallinfo.3:297
#, no-wrap
msgid ""
"        alloc[j] = malloc(blockSize);\n"
"        if (alloc[j] == NULL) {\n"
"            perror(\"malloc\");\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/mallinfo.3:300
#, no-wrap
msgid ""
"    printf(\"\\en============== After allocating blocks ==============\\en\");\n"
"    display_mallinfo();\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/mallinfo.3:303
#, no-wrap
msgid ""
"    for (j = freeBegin; j E<lt> freeEnd; j += freeStep)\n"
"        free(alloc[j]);\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/mallinfo.3:306
#, no-wrap
msgid ""
"    printf(\"\\en============== After freeing blocks ==============\\en\");\n"
"    display_mallinfo();\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/mallinfo.3:318
msgid ""
"B<mmap>(2), B<malloc>(3), B<malloc_info>(3), B<malloc_stats>(3), "
"B<malloc_trim>(3), B<mallopt>(3)"
msgstr ""

#. type: Plain text
#: man-pages/man3/mtrace.3:28
msgid "mtrace, muntrace - malloc tracing"
msgstr ""

#. type: Plain text
#: man-pages/man3/mtrace.3:30
msgid "B<#include E<lt>mcheck.hE<gt>>"
msgstr ""

#. type: Plain text
#: man-pages/man3/mtrace.3:32
msgid "B<void mtrace(void);>"
msgstr ""

#. type: Plain text
#: man-pages/man3/mtrace.3:34
msgid "B<void muntrace(void);>"
msgstr ""

#. type: Plain text
#: man-pages/man3/mtrace.3:46
msgid ""
"The B<mtrace>()  function installs hook functions for the memory-allocation "
"functions (B<malloc>(3), B<realloc>(3)  B<memalign>(3), B<free>(3)).  These "
"hook functions record tracing information about memory allocation and "
"deallocation.  The tracing information can be used to discover memory leaks "
"and attempts to free nonallocated memory in a program."
msgstr ""

#. type: Plain text
#: man-pages/man3/mtrace.3:57
msgid ""
"The B<muntrace>()  function disables the hook functions installed by "
"B<mtrace>(), so that tracing information is no longer recorded for the "
"memory-allocation functions.  If no hook functions were successfully "
"installed by B<mtrace>(), B<muntrace>()  does nothing."
msgstr ""

#. type: Plain text
#: man-pages/man3/mtrace.3:65
msgid ""
"When B<mtrace>()  is called, it checks the value of the environment variable"
" B<MALLOC_TRACE>, which should contain the pathname of a file in which the "
"tracing information is to be recorded.  If the pathname is successfully "
"opened, it is truncated to zero length."
msgstr ""

#. type: Plain text
#: man-pages/man3/mtrace.3:78
msgid ""
"If B<MALLOC_TRACE> is not set, or the pathname it specifies is invalid or "
"not writable, then no hook functions are installed, and B<mtrace>()  has no "
"effect.  In set-user-ID and set-group-ID programs, B<MALLOC_TRACE> is "
"ignored, and B<mtrace>()  has no effect."
msgstr ""

#. type: tbl table
#: man-pages/man3/mtrace.3:89
#, no-wrap
msgid ""
"B<mtrace>(),\n"
"B<muntrace>()"
msgstr ""

#. type: tbl table
#: man-pages/man3/mtrace.3:89
#, no-wrap
msgid "MT-Unsafe"
msgstr ""

#. type: Plain text
#: man-pages/man3/mtrace.3:108
msgid ""
"In normal usage, B<mtrace>()  is called once at the start of execution of a "
"program, and B<muntrace>()  is never called."
msgstr ""

#. type: Plain text
#: man-pages/man3/mtrace.3:118
msgid ""
"The tracing output produced after a call to B<mtrace>()  is textual, but not"
" designed to be human readable.  The GNU C library provides a Perl script, "
"B<mtrace>(1), that interprets the trace log and produces human-readable "
"output.  For best results, the traced program should be compiled with "
"debugging enabled, so that line-number information is recorded in the "
"executable."
msgstr ""

#. type: Plain text
#: man-pages/man3/mtrace.3:124
msgid ""
"The tracing performed by B<mtrace>()  incurs a performance penalty (if "
"B<MALLOC_TRACE> points to a valid, writable pathname)."
msgstr ""

#. type: Plain text
#: man-pages/man3/mtrace.3:130
msgid ""
"The line-number information produced by B<mtrace>(1)  is not always precise:"
" the line number references may refer to the previous or following "
"(nonblank)  line of the source code."
msgstr ""

#. type: Plain text
#: man-pages/man3/mtrace.3:137
msgid ""
"The shell session below demonstrates the use of the B<mtrace>()  function "
"and the B<mtrace>(1)  command in a program that has memory leaks at two "
"different locations.  The demonstration uses the following program:"
msgstr ""

#. type: Plain text
#: man-pages/man3/mtrace.3:144
#, no-wrap
msgid ""
"$ B<cat t_mtrace.c>\n"
"#include E<lt>mcheck.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/mtrace.3:149
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int j;\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/mtrace.3:151
#, no-wrap
msgid "    mtrace();\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/mtrace.3:154
#, no-wrap
msgid ""
"    for (j = 0; j E<lt> 2; j++)\n"
"        malloc(100);            /* Never freed--a memory leak */\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/mtrace.3:158
#, no-wrap
msgid ""
"    calloc(16, 16);             /* Never freed--a memory leak */\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/mtrace.3:164
msgid ""
"When we run the program as follows, we see that B<mtrace>()  diagnosed "
"memory leaks at two different locations in the program:"
msgstr ""

#. type: Plain text
#: man-pages/man3/mtrace.3:177
#, no-wrap
msgid ""
"$ B<cc -g t_mtrace.c -o t_mtrace>\n"
"$ B<export MALLOC_TRACE=/tmp/t>\n"
"$ B<./t_mtrace>\n"
"$ B<mtrace ./t_mtrace $MALLOC_TRACE>\n"
"Memory not freed:\n"
"-----------------\n"
"   Address     Size     Caller\n"
"0x084c9378     0x64  at /home/cecilia/t_mtrace.c:12\n"
"0x084c93e0     0x64  at /home/cecilia/t_mtrace.c:12\n"
"0x084c9448    0x100  at /home/cecilia/t_mtrace.c:16\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/mtrace.3:189
msgid ""
"The first two messages about unfreed memory correspond to the two "
"B<malloc>(3)  calls inside the I<for> loop.  The final message corresponds "
"to the call to B<calloc>(3)  (which in turn calls B<malloc>(3))."
msgstr ""

#. type: Plain text
#: man-pages/man3/mtrace.3:193
msgid "B<mtrace>(1), B<malloc>(3), B<malloc_hook>(3), B<mcheck>(3)"
msgstr ""

#. type: TH
#: man-pages/man3/mkfifo.3:28
#, no-wrap
msgid "MKFIFO"
msgstr ""

#. type: Plain text
#: man-pages/man3/mkfifo.3:31
msgid "mkfifo, mkfifoat - make a FIFO special file (a named pipe)"
msgstr ""

#. type: Plain text
#: man-pages/man3/mkfifo.3:35
#, no-wrap
msgid ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>sys/stat.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/mkfifo.3:37
#, no-wrap
msgid "B<int mkfifo(const char *>I<pathname>B<, mode_t >I<mode>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/mkfifo.3:42
#, no-wrap
msgid ""
"B<int mkfifoat(int >I<dirfd>B<, const char *>I<pathname>B<, mode_t "
">I<mode>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/mkfifo.3:50
msgid "B<mkfifoat>():"
msgstr ""

#. type: Plain text
#: man-pages/man3/mkfifo.3:69
msgid ""
"B<mkfifo>()  makes a FIFO special file with name I<pathname>.  I<mode> "
"specifies the FIFO's permissions.  It is modified by the process's B<umask> "
"in the usual way: the permissions of the created file are B<(>I<mode>B< & "
"~umask)>."
msgstr ""

#. type: Plain text
#: man-pages/man3/mkfifo.3:76
msgid ""
"A FIFO special file is similar to a pipe, except that it is created in a "
"different way.  Instead of being an anonymous communications channel, a FIFO"
" special file is entered into the filesystem by calling B<mkfifo>()."
msgstr ""

#. type: Plain text
#: man-pages/man3/mkfifo.3:86
msgid ""
"Once you have created a FIFO special file in this way, any process can open "
"it for reading or writing, in the same way as an ordinary file.  However, it"
" has to be open at both ends simultaneously before you can proceed to do any"
" input or output operations on it.  Opening a FIFO for reading normally "
"blocks until some other process opens the same FIFO for writing, and vice "
"versa.  See B<fifo>(7)  for nonblocking handling of FIFO special files."
msgstr ""

#. type: SS
#: man-pages/man3/mkfifo.3:86
#, no-wrap
msgid "mkfifoat()"
msgstr ""

#. type: Plain text
#: man-pages/man3/mkfifo.3:92
msgid ""
"The B<mkfifoat>()  function operates in exactly the same way as B<mkfifo>(),"
" except for the differences described here."
msgstr ""

#. type: Plain text
#: man-pages/man3/mkfifo.3:102
msgid ""
"If the pathname given in I<pathname> is relative, then it is interpreted "
"relative to the directory referred to by the file descriptor I<dirfd> "
"(rather than relative to the current working directory of the calling "
"process, as is done by B<mkfifo>()  for a relative pathname)."
msgstr ""

#. type: Plain text
#: man-pages/man3/mkfifo.3:114
msgid ""
"If I<pathname> is relative and I<dirfd> is the special value B<AT_FDCWD>, "
"then I<pathname> is interpreted relative to the current working directory of"
" the calling process (like B<mkfifo>())."
msgstr ""

#. type: Plain text
#: man-pages/man3/mkfifo.3:128
msgid ""
"On success B<mkfifo>()  and B<mkfifoat>()  return 0.  In the case of an "
"error, -1 is returned (in which case, I<errno> is set appropriately)."
msgstr ""

#. type: Plain text
#: man-pages/man3/mkfifo.3:133
msgid ""
"One of the directories in I<pathname> did not allow search (execute) "
"permission."
msgstr ""

#. type: Plain text
#: man-pages/man3/mkfifo.3:151
msgid ""
"Either the total length of I<pathname> is greater than B<PATH_MAX>, or an "
"individual filename component has a length greater than B<NAME_MAX>.  In the"
" GNU system, there is no imposed limit on overall filename length, but some "
"filesystems may place limits on the length of a component."
msgstr ""

#. type: Plain text
#: man-pages/man3/mkfifo.3:158
msgid "The directory or filesystem has no room for the new file."
msgstr ""

#. type: Plain text
#: man-pages/man3/mkfifo.3:165
msgid "I<pathname> refers to a read-only filesystem."
msgstr ""

#. type: Plain text
#: man-pages/man3/mkfifo.3:168
msgid "The following additional errors can occur for B<mkfifoat>():"
msgstr ""

#. type: Plain text
#: man-pages/man3/mkfifo.3:178
msgid ""
"I<pathname> is a relative path and I<dirfd> is a file descriptor referring "
"to a file other than a directory."
msgstr ""

#. type: Plain text
#: man-pages/man3/mkfifo.3:184
msgid ""
"B<mkfifoat>()  was added to glibc in version 2.4.  It is implemented using "
"B<mknodat>(2), available on Linux since kernel 2.6.16."
msgstr ""

#. type: tbl table
#: man-pages/man3/mkfifo.3:195
#, no-wrap
msgid ""
"B<mkfifo>(),\n"
"B<mkfifoat>()"
msgstr ""

#. type: Plain text
#: man-pages/man3/mkfifo.3:200
msgid "B<mkfifo>(): POSIX.1-2001, POSIX.1-2008."
msgstr ""

#. type: Plain text
#: man-pages/man3/mkfifo.3:203
msgid "B<mkfifoat>(): POSIX.1-2008."
msgstr ""

#. type: Plain text
#: man-pages/man3/mkfifo.3:211
msgid ""
"B<mkfifo>(1), B<close>(2), B<open>(2), B<read>(2), B<stat>(2), B<umask>(2), "
"B<write>(2), B<fifo>(7)"
msgstr ""
