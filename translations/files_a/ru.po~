# Copyright (C) 2014 Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
#
# Translators:
# Yuri Kozlov <yuray@komyakino.ru>, 2012-2014.
# Yuri Kozlov <yuray@komyakino.ru>, 2014.
msgid ""
msgstr ""
"Project-Id-Version: translation of man-pages\n"
"POT-Creation-Date: 2014-06-07 12:11+0400\n"
"PO-Revision-Date: 2014-08-17 08:34+0400\n"
"Last-Translator: Yuri Kozlov <yuray@komyakino.ru>\n"
"Language-Team: Russian <man-pages-ru-talks@lists.sourceforge.net>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ru\n"
"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n%10<"
"=4 && (n%100<10 || n%100>=20) ? 1 : 2);\n"
"X-Generator: Lokalize 1.5\n"

#. type: TH
#: man-pages/man7/aio.7:26
#, no-wrap
msgid "AIO"
msgstr "AIO"

#. type: TH
#: man-pages/man7/aio.7:26
#, no-wrap
msgid "2014-04-06"
msgstr "2014-04-06"

#. type: TH
#: man-pages/man7/aio.7:26
#, no-wrap
msgid "Linux"
msgstr "Linux"

#. type: TH
#: man-pages/man7/aio.7:26
#, no-wrap
msgid "Linux Programmer's Manual"
msgstr "Руководство программиста Linux"

#. type: SH
#: man-pages/man7/aio.7:27
#, no-wrap
msgid "NAME"
msgstr "ИМЯ"

#. type: Plain text
#: man-pages/man7/aio.7:29
msgid "aio - POSIX asynchronous I/O overview"
msgstr "aio - введение в асинхронный ввод-вывод POSIX"

#. type: SH
#: man-pages/man7/aio.7:29
#, no-wrap
msgid "DESCRIPTION"
msgstr "ОПИСАНИЕ"

#. type: Plain text
#: man-pages/man7/aio.7:37
msgid ""
"The POSIX asynchronous I/O (AIO) interface allows applications to initiate "
"one or more I/O operations that are performed asynchronously (i.e., in the "
"background).  The application can elect to be notified of completion of the "
"I/O operation in a variety of ways: by delivery of a signal, by "
"instantiation of a thread, or no notification at all."
msgstr ""
"Интерфейс асинхронного ввода-вывода POSIX (AIO) позволяет приложениям "
"запускать одну или несколько операций ввода-вывода, которые выполняются "
"асинхронно (т. е., в фоновом режиме). Приложение может выбрать каким образом "
"оно будет уведомлено о завершении операции ввода-вывода: с помощью сигнала, "
"созданием новой нити или вообще не получать уведомления."

#. type: Plain text
#: man-pages/man7/aio.7:39
msgid "The POSIX AIO interface consists of the following functions:"
msgstr "Интерфейс POSIX AIO состоит из следующих функций:"

#. type: TP
#: man-pages/man7/aio.7:39
#, no-wrap
msgid "B<aio_read>(3)"
msgstr "B<aio_read>(3)"

#. type: Plain text
#: man-pages/man7/aio.7:44
msgid "Enqueue a read request.  This is the asynchronous analog of B<read>(2)."
msgstr "Ставит запрос на чтение в очередь. Это асинхронный аналог B<read>(2)."

#. type: TP
#: man-pages/man7/aio.7:44
#, no-wrap
msgid "B<aio_write>(3)"
msgstr "B<aio_write>(3)"

#. type: Plain text
#: man-pages/man7/aio.7:49
msgid ""
"Enqueue a write request.  This is the asynchronous analog of B<write>(2)."
msgstr "Ставит запрос на запись в очередь. Это асинхронный аналог B<write>(2)."

#. type: TP
#: man-pages/man7/aio.7:49
#, no-wrap
msgid "B<aio_fsync>(3)"
msgstr "B<aio_fsync>(3)"

#. type: Plain text
#: man-pages/man7/aio.7:56
msgid ""
"Enqueue a sync request for the I/O operations on a file descriptor.  This is"
" the asynchronous analog of B<fsync>(2)  and B<fdatasync>(2)."
msgstr ""
"Ставит запрос синхронизации операций ввода-вывода над файловым дескриптором. "
"Это асинхронный аналог B<fsync>(2) и B<fdatasync>(2)."

#. type: TP
#: man-pages/man7/aio.7:56
#, no-wrap
msgid "B<aio_error>(3)"
msgstr "B<aio_error>(3)"

#. type: Plain text
#: man-pages/man7/aio.7:59
msgid "Obtain the error status of an enqueued I/O request."
msgstr ""
"Возвращает информацию о состоянии поставленного в очередь запроса "
"ввода-вывода."

#. type: TP
#: man-pages/man7/aio.7:59
#, no-wrap
msgid "B<aio_return>(3)"
msgstr "B<aio_return>(3)"

#. type: Plain text
#: man-pages/man7/aio.7:62
msgid "Obtain the return status of a completed I/O request."
msgstr "Возвращает информацию о выполненном запросе ввода-вывода."

#. type: TP
#: man-pages/man7/aio.7:62
#, no-wrap
msgid "B<aio_suspend>(3)"
msgstr "B<aio_suspend>(3)"

#. type: Plain text
#: man-pages/man7/aio.7:66
msgid ""
"Suspend the caller until one or more of a specified set of I/O requests "
"completes."
msgstr ""
"Приостанавливает вызывающего до тех пор, пока не выполнится один или более "
"указанных запросов ввода-вывода."

#. type: TP
#: man-pages/man7/aio.7:66
#, no-wrap
msgid "B<aio_cancel>(3)"
msgstr "B<aio_cancel>(3)"

#. type: Plain text
#: man-pages/man7/aio.7:70
msgid ""
"Attempt to cancel outstanding I/O requests on a specified file descriptor."
msgstr ""
"Пытается отменить ожидающие выполнения запросы ввода-вывода над заданным "
"файловым дескриптором."

#. type: TP
#: man-pages/man7/aio.7:70
#, no-wrap
msgid "B<lio_listio>(3)"
msgstr "B<lio_listio>(3)"

#. type: Plain text
#: man-pages/man7/aio.7:73
msgid "Enqueue multiple I/O requests using a single function call."
msgstr ""
"Ставит в очередь сразу несколько запросов ввода-вывода за один вызов функции."

#. type: Plain text
#: man-pages/man7/aio.7:80
msgid ""
"The I<aiocb> (\"asynchronous I/O control block\") structure defines "
"parameters that control an I/O operation.  An argument of this type is "
"employed with all of the functions listed above.  This structure has the "
"following form:"
msgstr ""
"В структуре I<aiocb> («блок управления асинхронным вводом-выводом») задаются "
"параметры, которые управляют операцией ввода-вывода. Аргумент данного типа "
"передаётся во все функции, перечисленные ранее. Данная структура имеет "
"следующий вид:"

#. type: Plain text
#: man-pages/man7/aio.7:84
#, no-wrap
msgid "#include E<lt>aiocb.hE<gt>\n"
msgstr "#include E<lt>aiocb.hE<gt>\n"

#. type: Plain text
#: man-pages/man7/aio.7:87
#, no-wrap
msgid ""
"struct aiocb {\n"
"    /* The order of these fields is implementation-dependent */\n"
msgstr ""
"struct aiocb {\n    /* Порядок данных полей определяется реализацией */\n"

#. type: Plain text
#: man-pages/man7/aio.7:96
#, no-wrap
msgid ""
"    int             aio_fildes;     /* File descriptor */\n"
"    off_t           aio_offset;     /* File offset */\n"
"    volatile void  *aio_buf;        /* Location of buffer */\n"
"    size_t          aio_nbytes;     /* Length of transfer */\n"
"    int             aio_reqprio;    /* Request priority */\n"
"    struct sigevent aio_sigevent;   /* Notification method */\n"
"    int             aio_lio_opcode; /* Operation to be performed;\n"
"                                       lio_listio() only */\n"
msgstr ""
"    int             aio_fildes;     /* файловый дескриптор */\n    off_t      "
"     aio_offset;     /* файловое смещение */\n    volatile void  *aio_buf;    "
"    /* расположение буфера */\n    size_t          aio_nbytes;     /* длина "
"передачи */\n    int             aio_reqprio;    /* приоритет запроса */\n    "
"struct sigevent aio_sigevent;   /* метод уведомления */\n    int             "
"aio_lio_opcode; /* выполняемая операция;\n                                    "
"   только в lio_listio() */\n"

#. type: Plain text
#: man-pages/man7/aio.7:99
#, no-wrap
msgid ""
"    /* Various implementation-internal fields not shown */\n"
"};\n"
msgstr "    /* Не показаны различные поля, используемые в реализациях */\n};\n"

#. type: Plain text
#: man-pages/man7/aio.7:101
#, no-wrap
msgid "/* Operation codes for \\(aqaio_lio_opcode\\(aq: */\n"
msgstr "/* Коды операций для \\(aqaio_lio_opcode\\(aq: */\n"

#. type: Plain text
#: man-pages/man7/aio.7:103
#, no-wrap
msgid "enum { LIO_READ, LIO_WRITE, LIO_NOP };\n"
msgstr "enum { LIO_READ, LIO_WRITE, LIO_NOP };\n"

#. type: Plain text
#: man-pages/man7/aio.7:107
msgid "The fields of this structure are as follows:"
msgstr "Поля этой структуры имеют следующее назначение:"

#. type: TP
#: man-pages/man7/aio.7:107
#, no-wrap
msgid "I<aio_filedes>"
msgstr "I<aio_filedes>"

#. type: Plain text
#: man-pages/man7/aio.7:110
msgid "The file descriptor on which the I/O operation is to be performed."
msgstr ""
"Файловый дескриптор, над которым будут выполняться операции ввода-вывода."

#. type: TP
#: man-pages/man7/aio.7:110
#, no-wrap
msgid "I<aio_offset>"
msgstr "I<aio_offset>"

#. type: Plain text
#: man-pages/man7/aio.7:113
msgid "This is the file offset at which the I/O operation is to be performed."
msgstr ""
"Файловое смещение, начиная с которого будут выполняться операции ввода-вывода."

#. type: TP
#: man-pages/man7/aio.7:113
#, no-wrap
msgid "I<aio_buf>"
msgstr "I<aio_buf>"

#. type: Plain text
#: man-pages/man7/aio.7:116
msgid "This is the buffer used to transfer data for a read or write operation."
msgstr ""
"Буфер, используемый для пересылки данных при операции чтения или записи."

#. type: TP
#: man-pages/man7/aio.7:116
#, no-wrap
msgid "I<aio_nbytes>"
msgstr "I<aio_nbytes>"

#. type: Plain text
#: man-pages/man7/aio.7:120
msgid "This is the size of the buffer pointed to by I<aio_buf>."
msgstr "Размер буфера, на который указывает I<aio_buf>."

#. type: TP
#: man-pages/man7/aio.7:120
#, no-wrap
msgid "I<aio_reqprio>"
msgstr "I<aio_reqprio>"

#. type: Plain text
#: man-pages/man7/aio.7:129
msgid ""
"This field specifies a value that is subtracted from the calling thread's "
"real-time priority in order to determine the priority for execution of this "
"I/O request (see B<pthread_setschedparam>(3)).  The specified value must be "
"between 0 and the value returned by I<sysconf(_SC_AIO_PRIO_DELTA_MAX)>.  "
"This field is ignored for file synchronization operations."
msgstr ""
"В этом поле задаётся значение, которое вычитается из приоритета реального "
"времени вызывающей нити, чтобы определить приоритет выполнения данного "
"запроса ввода-вывода (смотрите B<pthread_setschedparam>(3)). Указываемое "
"значение должно быть в диапазоне от 0 и до значения, возвращаемого I<"
"sysconf(_SC_AIO_PRIO_DELTA_MAX)>. Данное поле игнорируется при операциях "
"синхронизации файла."

#. type: TP
#: man-pages/man7/aio.7:129
#, no-wrap
msgid "I<aio_sigevent>"
msgstr "I<aio_sigevent>"

#. type: Plain text
#: man-pages/man7/aio.7:143
msgid ""
"This field is a structure that specifies how the caller is to be notified "
"when the asynchronous I/O operation completes.  Possible values for "
"I<aio_sigevent.sigev_notify> are B<SIGEV_NONE>, B<SIGEV_SIGNAL>, and "
"B<SIGEV_THREAD>.  See B<sigevent>(7)  for further details."
msgstr ""
"В этом поле задаётся структура, которая указывает как вызывающему должно быть "
"сообщено о завершении анонимной операции ввода-вывода. Возможные значения для "
"I<aio_sigevent.sigev_notify>: B<SIGEV_NONE>, B<SIGEV_SIGNAL> и B<SIGEV_THREAD>"
". Подробности смотрите в B<sigevent>(7)."

#. type: TP
#: man-pages/man7/aio.7:143
#, no-wrap
msgid "I<aio_lio_opcode>"
msgstr "I<aio_lio_opcode>"

#. type: Plain text
#: man-pages/man7/aio.7:147
msgid "The type of operation to be performed; used only for B<lio_listio>(3)."
msgstr ""
"Задаёт тип операции, которая будет выполнена; используется только в B<"
"lio_listio>(3)."

#. type: Plain text
#: man-pages/man7/aio.7:150
msgid ""
"In addition to the standard functions listed above, the GNU C library "
"provides the following extension to the POSIX AIO API:"
msgstr ""
"В дополнении к стандартным функциям, перечисленным ранее, в библиотеке GNU C "
"есть следующее расширение программного интерфейса POSIX AIO:"

#. type: TP
#: man-pages/man7/aio.7:150
#, no-wrap
msgid "B<aio_init>(3)"
msgstr "B<aio_init>(3)"

#. type: Plain text
#: man-pages/man7/aio.7:153
msgid ""
"Set parameters for tuning the behavior of the glibc POSIX AIO "
"implementation."
msgstr "Позволяет изменить настройки поведения реализации glibc для POSIX AIO."

#. type: SH
#: man-pages/man7/aio.7:153
#, no-wrap
msgid "ERRORS"
msgstr "ОШИБКИ"

#. type: TP
#: man-pages/man7/aio.7:154
#, no-wrap
msgid "B<EINVAL>"
msgstr "B<EINVAL>"

#. type: Plain text
#: man-pages/man7/aio.7:163
msgid ""
"The I<aio_reqprio> field of the I<aiocb> structure was less than 0, or was "
"greater than the limit returned by the call "
"I<sysconf(_SC_AIO_PRIO_DELTA_MAX)>."
msgstr ""
"Значение поля I<aio_reqprio> структуры I<aiocb> меньше 0 или больше, чем "
"значение ограничения, возвращаемое вызовом I<sysconf(_SC_AIO_PRIO_DELTA_MAX)>."

#. type: SH
#: man-pages/man7/aio.7:163
#, no-wrap
msgid "VERSIONS"
msgstr "ВЕРСИИ"

#. type: Plain text
#: man-pages/man7/aio.7:165
msgid "The POSIX AIO interfaces are provided by glibc since version 2.1."
msgstr "Интерфейсы POSIX AIO появились в glibc в версии 2.1."

#. type: SH
#: man-pages/man7/aio.7:165
#, no-wrap
msgid "CONFORMING TO"
msgstr "СООТВЕТСТВИЕ СТАНДАРТАМ"

#. type: Plain text
#: man-pages/man7/aio.7:167
msgid "POSIX.1-2001, POSIX.1-2008."
msgstr "POSIX.1-2001, POSIX.1-2008."

#. type: SH
#: man-pages/man7/aio.7:167
#, no-wrap
msgid "NOTES"
msgstr "ЗАМЕЧАНИЯ"

#. type: Plain text
#: man-pages/man7/aio.7:174
msgid ""
"It is a good idea to zero out the control block buffer before use (see "
"B<memset>(3)).  The control block buffer and the buffer pointed to by "
"I<aio_buf> must not be changed while the I/O operation is in progress.  "
"These buffers must remain valid until the I/O operation completes."
msgstr ""
"Желательно обнулять буфер блока управления перед использованием (смотрите B<"
"memset>(3)). Буфер блока управления и буфер, который задаётся в I<aio_buf>, "
"не должны изменяться во время выполнения операции ввода-вывода. Данные буферы "
"должны оставаться рабочими до завершения операции ввода-вывода."

#. type: Plain text
#: man-pages/man7/aio.7:178
msgid ""
"Simultaneous asynchronous read or write operations using the same I<aiocb> "
"structure yield undefined results."
msgstr ""
"Одновременное выполнение операций чтения или записи через совместно "
"используемую структуру I<aiocb> приводит к непредсказуемым результатам."

#.  http://lse.sourceforge.net/io/aio.html
#.  http://lse.sourceforge.net/io/aionotes.txt
#.  http://lwn.net/Articles/148755/
#. type: Plain text
#: man-pages/man7/aio.7:196
msgid ""
"The current Linux POSIX AIO implementation is provided in user space by "
"glibc.  This has a number of limitations, most notably that maintaining "
"multiple threads to perform I/O operations is expensive and scales poorly.  "
"Work has been in progress for some time on a kernel state-machine-based "
"implementation of asynchronous I/O (see B<io_submit>(2), B<io_setup>(2), "
"B<io_cancel>(2), B<io_destroy>(2), B<io_getevents>(2)), but this "
"implementation hasn't yet matured to the point where the POSIX AIO "
"implementation can be completely reimplemented using the kernel system "
"calls."
msgstr ""
"Имеющаяся реализация Linux POSIX AIO предоставляется glibc в пользовательском "
"пространстве. Она имеет ряд ограничений, наиболее существенные из которых — "
"затраты на сопровождение нескольких нитей при операциях ввода-вывода и плохое "
"масштабирование. Некогда для реализации асинхронного ввода-вывода велась "
"работа над ядерной реализацией на основе машины состояний  (смотрите B<"
"io_submit>(2), B<io_setup>(2), B<io_cancel>(2), B<io_destroy>(2), B<"
"io_getevents>(2)), но эта реализация ещё недостаточно стабильна в тех местах, "
"где POSIX AIO можно было бы полностью реализовать на системных вызовах ядра."

#. type: SH
#: man-pages/man7/aio.7:196
#, no-wrap
msgid "EXAMPLE"
msgstr "ПРИМЕР"

#. type: Plain text
#: man-pages/man7/aio.7:209
msgid ""
"The program below opens each of the files named in its command-line "
"arguments and queues a request on the resulting file descriptor using "
"B<aio_read>(3).  The program then loops, periodically monitoring each of the"
" I/O operations that is still in progress using B<aio_error>(3).  Each of "
"the I/O requests is set up to provide notification by delivery of a signal."
"  After all I/O requests have completed, the program retrieves their status "
"using B<aio_return>(3)."
msgstr ""
"Представленная далее программа открывает все файлы, указанные в параметрах "
"командной строки и ставит в очередь запрос на полученные файловые дескрипторы "
"с помощью B<aio_read>(3). Затем программа входит в цикл, в котором "
"периодически следит за всеми выполняемыми операциями ввода-вывода с помощью "
"B<aio_error>(3). Для каждого запроса ввода-вывода настроено получение "
"уведомления посредством сигнала. После завершения всех запросов ввода-вывода, "
"программа возвращает их состояние с помощью B<aio_return>(3)."

#. type: Plain text
#: man-pages/man7/aio.7:215
msgid ""
"The B<SIGQUIT> signal (generated by typing control-\\e) causes the program "
"to request cancellation of each of the outstanding requests using "
"B<aio_cancel>(3)."
msgstr ""
"Сигнал B<SIGQUIT> (генерируемый нажатием control-\\e) заставляет программу "
"отменить все невыполненные запросы с помощью B<aio_cancel>(3)."

#. type: Plain text
#: man-pages/man7/aio.7:220
msgid ""
"Here is an example of what we might see when running this program.  In this "
"example, the program queues two requests to standard input, and these are "
"satisfied by two lines of input containing \"abc\" and \"x\"."
msgstr ""
"Вот результат работы программы. В этом примере программа ставит в очередь два "
"запроса для стандартного ввода, и они отрабатываются двумя введёнными "
"строками  «abc»  и «x»."

#. type: Plain text
#: man-pages/man7/aio.7:244
#, no-wrap
msgid ""
"$ B<./a.out /dev/stdin /dev/stdin>\n"
"opened /dev/stdin on descriptor 3\n"
"opened /dev/stdin on descriptor 4\n"
"aio_error():\n"
"    for request 0 (descriptor 3): In progress\n"
"    for request 1 (descriptor 4): In progress\n"
"B<abc>\n"
"I/O completion signal received\n"
"aio_error():\n"
"    for request 0 (descriptor 3): I/O succeeded\n"
"    for request 1 (descriptor 4): In progress\n"
"aio_error():\n"
"    for request 1 (descriptor 4): In progress\n"
"B<x>\n"
"I/O completion signal received\n"
"aio_error():\n"
"    for request 1 (descriptor 4): I/O succeeded\n"
"All I/O requests completed\n"
"aio_return():\n"
"    for request 0 (descriptor 3): 4\n"
"    for request 1 (descriptor 4): 2\n"
msgstr ""
"$ B<./a.out /dev/stdin /dev/stdin>\nopened /dev/stdin on descriptor 3\nopened "
"/dev/stdin on descriptor 4\naio_error():\n    for request 0 (descriptor 3): "
"In progress\n    for request 1 (descriptor 4): In progress\nB<abc>\nI/O "
"completion signal received\naio_error():\n    for request 0 (descriptor 3): "
"I/O succeeded\n    for request 1 (descriptor 4): In progress\naio_error():\n  "
"  for request 1 (descriptor 4): In progress\nB<x>\nI/O completion signal "
"received\naio_error():\n    for request 1 (descriptor 4): I/O succeeded\nAll "
"I/O requests completed\naio_return():\n    for request 0 (descriptor 3): 4\n  "
"  for request 1 (descriptor 4): 2\n"

#. type: SS
#: man-pages/man7/aio.7:246
#, no-wrap
msgid "Program source"
msgstr "Исходный код программы"

#. type: Plain text
#: man-pages/man7/aio.7:255
#, no-wrap
msgid ""
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"
"#include E<lt>aio.hE<gt>\n"
"#include E<lt>signal.hE<gt>\n"
msgstr ""
"#include E<lt>stdlib.hE<gt>\n#include E<lt>unistd.hE<gt>\n#include E<lt>"
"stdio.hE<gt>\n#include E<lt>errno.hE<gt>\n#include E<lt>aio.hE<gt>\n#include "
"E<lt>signal.hE<gt>\n"

#. type: Plain text
#: man-pages/man7/aio.7:257
#, no-wrap
msgid "#define BUF_SIZE 20     /* Size of buffers for read operations */\n"
msgstr "#define BUF_SIZE 20     /* размер буферов для операций чтения */\n"

#. type: Plain text
#: man-pages/man7/aio.7:259
#, no-wrap
msgid ""
"#define errExit(msg) do { perror(msg); exit(EXIT_FAILURE); } while (0)\n"
msgstr ""
"#define errExit(msg) do { perror(msg); exit(EXIT_FAILURE); } while (0)\n"

#. type: Plain text
#: man-pages/man7/aio.7:261
#, no-wrap
msgid "#define errMsg(msg)  do { perror(msg); } while (0)\n"
msgstr "#define errMsg(msg)  do { perror(msg); } while (0)\n"

#. type: Plain text
#: man-pages/man7/aio.7:268
#, no-wrap
msgid ""
"struct ioRequest {      /* Application-defined structure for tracking\n"
"                           I/O requests */\n"
"    int           reqNum;\n"
"    int           status;\n"
"    struct aiocb *aiocbp;\n"
"};\n"
msgstr ""
"struct ioRequest {      /* определяемая приложением структура для \n          "
"                 слежения за запросами ввода-вывода */\n    int           "
"reqNum;\n    int           status;\n    struct aiocb *aiocbp;\n};\n"

#. type: Plain text
#: man-pages/man7/aio.7:272
#, no-wrap
msgid ""
"static volatile sig_atomic_t gotSIGQUIT = 0;\n"
"                        /* On delivery of SIGQUIT, we attempt to\n"
"                           cancel all outstanding I/O requests */\n"
msgstr ""
"static volatile sig_atomic_t gotSIGQUIT = 0;\n                        /* при "
"получении SIGQUIT мы пытаемся отменить \n                           все "
"невыполненные запросы ввода-вывода */\n"

#. type: Plain text
#: man-pages/man7/aio.7:278
#, no-wrap
msgid ""
"static void             /* Handler for SIGQUIT */\n"
"quitHandler(int sig)\n"
"{\n"
"    gotSIGQUIT = 1;\n"
"}\n"
msgstr ""
"static void             /* обработчик SIGQUIT */\nquitHandler(int sig)\n{\n   "
" gotSIGQUIT = 1;\n}\n"

#. type: Plain text
#: man-pages/man7/aio.7:280
#, no-wrap
msgid ""
"#define IO_SIGNAL SIGUSR1   /* Signal used to notify I/O completion */\n"
msgstr ""
"#define IO_SIGNAL SIGUSR1   /* сигнал, уведомляющий о завершении\n            "
"                   ввода-вывода */\n"

#. type: Plain text
#: man-pages/man7/aio.7:285
#, no-wrap
msgid ""
"static void                 /* Handler for I/O completion signal */\n"
"aioSigHandler(int sig, siginfo_t *si, void *ucontext)\n"
"{\n"
"    write(STDOUT_FILENO, \"I/O completion signal received\\en\", 31);\n"
msgstr ""
"static void                 /* обработчик завершения ввода-вывода "
"*/\naioSigHandler(int sig, siginfo_t *si, void *ucontext)\n{\n    "
"write(STDOUT_FILENO, \"I/O completion signal received\\en\", 31);\n"

#. type: Plain text
#: man-pages/man7/aio.7:291
#, no-wrap
msgid ""
"    /* The corresponding ioRequest structure would be available as\n"
"           struct ioRequest *ioReq = si-E<gt>si_value.sival_ptr;\n"
"       and the file descriptor would then be available via\n"
"           ioReq-E<gt>aiocbp-E<gt>aio_fildes */\n"
"}\n"
msgstr ""
"    /* соответствующая структура ioRequest была бы доступна как\n           "
"struct ioRequest *ioReq = si-E<gt>si_value.sival_ptr;\n       а файловый "
"дескриптор был бы доступен через\n           ioReq-E<gt>aiocbp-E<gt>"
"aio_fildes */\n}\n"

#. type: Plain text
#: man-pages/man7/aio.7:301
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    struct ioRequest *ioList;\n"
"    struct aiocb *aiocbList;\n"
"    struct sigaction sa;\n"
"    int s, j;\n"
"    int numReqs;        /* Total number of queued I/O requests */\n"
"    int openReqs;       /* Number of I/O requests still in progress */\n"
msgstr ""
"int\nmain(int argc, char *argv[])\n{\n    struct ioRequest *ioList;\n    "
"struct aiocb *aiocbList;\n    struct sigaction sa;\n    int s, j;\n    int "
"numReqs;        /* общее количество устанавливаемых в очередь\n               "
"            запросов ввода-вывода */\n    int openReqs;       /* количество "
"выполняющихся запросов\n                           ввода-вывода */\n"

#. type: Plain text
#: man-pages/man7/aio.7:307
#, no-wrap
msgid ""
"    if (argc E<lt> 2) {\n"
"        fprintf(stderr, \"Usage: %s E<lt>pathnameE<gt> E<lt>pathnameE<gt>"
"...\\en\",\n"
"                argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    if (argc E<lt> 2) {\n        fprintf(stderr, \"Использование: %s E<lt>"
"имя_файлаE<gt> E<lt>имя_файлаE<gt>...\\en\",\n                argv[0]);\n     "
"   exit(EXIT_FAILURE);\n    }\n"

#. type: Plain text
#: man-pages/man7/aio.7:309
#, no-wrap
msgid "    numReqs = argc - 1;\n"
msgstr "    numReqs = argc - 1;\n"

#. type: Plain text
#: man-pages/man7/aio.7:311
#, no-wrap
msgid "    /* Allocate our arrays */\n"
msgstr "    /* выделяем место под массивы */\n"

#. type: Plain text
#: man-pages/man7/aio.7:315
#, no-wrap
msgid ""
"    ioList = calloc(numReqs, sizeof(struct ioRequest));\n"
"    if (ioList == NULL)\n"
"        errExit(\"calloc\");\n"
msgstr ""
"    ioList = calloc(numReqs, sizeof(struct ioRequest));\n    if (ioList == "
"NULL)\n        errExit(\"calloc\");\n"

#. type: Plain text
#: man-pages/man7/aio.7:319
#, no-wrap
msgid ""
"    aiocbList = calloc(numReqs, sizeof(struct aiocb));\n"
"    if (aiocbList == NULL)\n"
"        errExit(\"calloc\");\n"
msgstr ""
"    aiocbList = calloc(numReqs, sizeof(struct aiocb));\n    if (aiocbList == "
"NULL)\n        errExit(\"calloc\");\n"

#. type: Plain text
#: man-pages/man7/aio.7:321
#, no-wrap
msgid ""
"    /* Establish handlers for SIGQUIT and the I/O completion signal */\n"
msgstr ""
"    /* указываем обработчики SIGQUIT и сигнала завершения ввода-вывода */\n"

#. type: Plain text
#: man-pages/man7/aio.7:324
#, no-wrap
msgid ""
"    sa.sa_flags = SA_RESTART;\n"
"    sigemptyset(&sa.sa_mask);\n"
msgstr "    sa.sa_flags = SA_RESTART;\n    sigemptyset(&sa.sa_mask);\n"

#. type: Plain text
#: man-pages/man7/aio.7:328
#, no-wrap
msgid ""
"    sa.sa_handler = quitHandler;\n"
"    if (sigaction(SIGQUIT, &sa, NULL) == -1)\n"
"        errExit(\"sigaction\");\n"
msgstr ""
"    sa.sa_handler = quitHandler;\n    if (sigaction(SIGQUIT, &sa, NULL) == "
"-1)\n        errExit(\"sigaction\");\n"

#. type: Plain text
#: man-pages/man7/aio.7:333
#, no-wrap
msgid ""
"    sa.sa_flags = SA_RESTART | SA_SIGINFO;\n"
"    sa.sa_sigaction = aioSigHandler;\n"
"    if (sigaction(IO_SIGNAL, &sa, NULL) == -1)\n"
"        errExit(\"sigaction\");\n"
msgstr ""
"    sa.sa_flags = SA_RESTART | SA_SIGINFO;\n    sa.sa_sigaction = "
"aioSigHandler;\n    if (sigaction(IO_SIGNAL, &sa, NULL) == -1)\n        "
"errExit(\"sigaction\");\n"

#. type: Plain text
#: man-pages/man7/aio.7:336
#, no-wrap
msgid ""
"    /* Open each file specified on the command line, and queue\n"
"       a read request on the resulting file descriptor */\n"
msgstr ""
"    /* открываем каждый файл, заданный в командной строке и ставим в\n       "
"очередь запрос на чтение полученного файлового дескриптора */\n"

#. type: Plain text
#: man-pages/man7/aio.7:341
#, no-wrap
msgid ""
"    for (j = 0; j E<lt> numReqs; j++) {\n"
"        ioList[j].reqNum = j;\n"
"        ioList[j].status = EINPROGRESS;\n"
"        ioList[j].aiocbp = &aiocbList[j];\n"
msgstr ""
"    for (j = 0; j E<lt> numReqs; j++) {\n        ioList[j].reqNum = j;\n      "
"  ioList[j].status = EINPROGRESS;\n        ioList[j].aiocbp = &aiocbList[j];\n"

#. type: Plain text
#: man-pages/man7/aio.7:347
#, no-wrap
msgid ""
"        ioList[j].aiocbp-E<gt>aio_fildes = open(argv[j + 1], O_RDONLY);\n"
"        if (ioList[j].aiocbp-E<gt>aio_fildes == -1)\n"
"            errExit(\"open\");\n"
"        printf(\"opened %s on descriptor %d\\en\", argv[j + 1],\n"
"                ioList[j].aiocbp-E<gt>aio_fildes);\n"
msgstr ""
"        ioList[j].aiocbp-E<gt>aio_fildes = open(argv[j + 1], O_RDONLY);\n     "
"   if (ioList[j].aiocbp-E<gt>aio_fildes == -1)\n            "
"errExit(\"open\");\n        printf(\"opened %s on descriptor %d\\en\", argv[j "
"+ 1],\n                ioList[j].aiocbp-E<gt>aio_fildes);\n"

#. type: Plain text
#: man-pages/man7/aio.7:351
#, no-wrap
msgid ""
"        ioList[j].aiocbp-E<gt>aio_buf = malloc(BUF_SIZE);\n"
"        if (ioList[j].aiocbp-E<gt>aio_buf == NULL)\n"
"            errExit(\"malloc\");\n"
msgstr ""
"        ioList[j].aiocbp-E<gt>aio_buf = malloc(BUF_SIZE);\n        if "
"(ioList[j].aiocbp-E<gt>aio_buf == NULL)\n            errExit(\"malloc\");\n"

#. type: Plain text
#: man-pages/man7/aio.7:359
#, no-wrap
msgid ""
"        ioList[j].aiocbp-E<gt>aio_nbytes = BUF_SIZE;\n"
"        ioList[j].aiocbp-E<gt>aio_reqprio = 0;\n"
"        ioList[j].aiocbp-E<gt>aio_offset = 0;\n"
"        ioList[j].aiocbp-E<gt>aio_sigevent.sigev_notify = SIGEV_SIGNAL;\n"
"        ioList[j].aiocbp-E<gt>aio_sigevent.sigev_signo = IO_SIGNAL;\n"
"        ioList[j].aiocbp-E<gt>aio_sigevent.sigev_value.sival_ptr =\n"
"                                &ioList[j];\n"
msgstr ""
"        ioList[j].aiocbp-E<gt>aio_nbytes = BUF_SIZE;\n        "
"ioList[j].aiocbp-E<gt>aio_reqprio = 0;\n        ioList[j].aiocbp-E<gt>"
"aio_offset = 0;\n        ioList[j].aiocbp-E<gt>aio_sigevent.sigev_notify = "
"SIGEV_SIGNAL;\n        ioList[j].aiocbp-E<gt>aio_sigevent.sigev_signo = "
"IO_SIGNAL;\n        ioList[j].aiocbp-E<gt>aio_sigevent.sigev_value.sival_ptr "
"=\n                                &ioList[j];\n"

#. type: Plain text
#: man-pages/man7/aio.7:364
#, no-wrap
msgid ""
"        s = aio_read(ioList[j].aiocbp);\n"
"        if (s == -1)\n"
"            errExit(\"aio_read\");\n"
"    }\n"
msgstr ""
"        s = aio_read(ioList[j].aiocbp);\n        if (s == -1)\n            "
"errExit(\"aio_read\");\n    }\n"

#. type: Plain text
#: man-pages/man7/aio.7:366
#, no-wrap
msgid "    openReqs = numReqs;\n"
msgstr "    openReqs = numReqs;\n"

#. type: Plain text
#: man-pages/man7/aio.7:368
#, no-wrap
msgid "    /* Loop, monitoring status of I/O requests */\n"
msgstr "    /* цикл, отслеживание состояние запросов ввода-вывода */\n"

#. type: Plain text
#: man-pages/man7/aio.7:371
#, no-wrap
msgid ""
"    while (openReqs E<gt> 0) {\n"
"        sleep(3);       /* Delay between each monitoring step */\n"
msgstr ""
"    while (openReqs E<gt> 0) {\n        sleep(3);       /* задержка между "
"проверками */\n"

#. type: Plain text
#: man-pages/man7/aio.7:373
#, no-wrap
msgid "        if (gotSIGQUIT) {\n"
msgstr "        if (gotSIGQUIT) {\n"

#. type: Plain text
#: man-pages/man7/aio.7:377
#, no-wrap
msgid ""
"            /* On receipt of SIGQUIT, attempt to cancel each of the\n"
"               outstanding I/O requests, and display status returned\n"
"               from the cancellation requests */\n"
msgstr ""
"            /* при получении SIGQUIT пытаемся отменить каждый\n               "
"невыполненный запрос ввода-вывода и показываем состояние,\n               "
"возвращаемое при отмене запроса */\n"

#. type: Plain text
#: man-pages/man7/aio.7:379
#, no-wrap
msgid "            printf(\"got SIGQUIT; canceling I/O requests: \\en\");\n"
msgstr "            printf(\"got SIGQUIT; canceling I/O requests: \\en\");\n"

#. type: Plain text
#: man-pages/man7/aio.7:396
#, no-wrap
msgid ""
"            for (j = 0; j E<lt> numReqs; j++) {\n"
"                if (ioList[j].status == EINPROGRESS) {\n"
"                    printf(\"    Request %d on descriptor %d:\", j,\n"
"                            ioList[j].aiocbp-E<gt>aio_fildes);\n"
"                    s = aio_cancel(ioList[j].aiocbp-E<gt>aio_fildes,\n"
"                            ioList[j].aiocbp);\n"
"                    if (s == AIO_CANCELED)\n"
"                        printf(\"I/O canceled\\en\");\n"
"                    else if (s == AIO_NOTCANCELED)\n"
"                            printf(\"I/O not canceled\\en\");\n"
"                    else if (s == AIO_ALLDONE)\n"
"                        printf(\"I/O all done\\en\");\n"
"                    else\n"
"                        errMsg(\"aio_cancel\");\n"
"                }\n"
"            }\n"
msgstr ""
"            for (j = 0; j E<lt> numReqs; j++) {\n                if "
"(ioList[j].status == EINPROGRESS) {\n                    printf(\"    Request "
"%d on descriptor %d:\", j,\n                            ioList[j].aiocbp-E<gt>"
"aio_fildes);\n                    s = aio_cancel(ioList[j].aiocbp-E<gt>"
"aio_fildes,\n                            ioList[j].aiocbp);\n                 "
"   if (s == AIO_CANCELED)\n                        printf(\"I/O "
"canceled\\en\");\n                    else if (s == AIO_NOTCANCELED)\n        "
"                    printf(\"I/O not canceled\\en\");\n                    "
"else if (s == AIO_ALLDONE)\n                        printf(\"I/O all "
"done\\en\");\n                    else\n                        "
"errMsg(\"aio_cancel\");\n                }\n            }\n"

#. type: Plain text
#: man-pages/man7/aio.7:399
#, no-wrap
msgid ""
"            gotSIGQUIT = 0;\n"
"        }\n"
msgstr "            gotSIGQUIT = 0;\n        }\n"

#. type: Plain text
#: man-pages/man7/aio.7:402
#, no-wrap
msgid ""
"        /* Check the status of each I/O request that is still\n"
"           in progress */\n"
msgstr ""
"        /* проверяем состояние каждого запроса ввода-вывода, которые\n        "
"   ещё не завершились */\n"

#. type: Plain text
#: man-pages/man7/aio.7:409
#, no-wrap
msgid ""
"        printf(\"aio_error():\\en\");\n"
"        for (j = 0; j E<lt> numReqs; j++) {\n"
"            if (ioList[j].status == EINPROGRESS) {\n"
"                printf(\"    for request %d (descriptor %d): \",\n"
"                        j, ioList[j].aiocbp-E<gt>aio_fildes);\n"
"                ioList[j].status = aio_error(ioList[j].aiocbp);\n"
msgstr ""
"        printf(\"aio_error():\\en\");\n        for (j = 0; j E<lt> numReqs; "
"j++) {\n            if (ioList[j].status == EINPROGRESS) {\n                "
"printf(\"    for request %d (descriptor %d): \",\n                        j, "
"ioList[j].aiocbp-E<gt>aio_fildes);\n                ioList[j].status = "
"aio_error(ioList[j].aiocbp);\n"

#. type: Plain text
#: man-pages/man7/aio.7:424
#, no-wrap
msgid ""
"                switch (ioList[j].status) {\n"
"                case 0:\n"
"                    printf(\"I/O succeeded\\en\");\n"
"                    break;\n"
"                case EINPROGRESS:\n"
"                    printf(\"In progress\\en\");\n"
"                    break;\n"
"                case ECANCELED:\n"
"                    printf(\"Canceled\\en\");\n"
"                    break;\n"
"                default:\n"
"                    errMsg(\"aio_error\");\n"
"                    break;\n"
"                }\n"
msgstr ""
"                switch (ioList[j].status) {\n                case 0:\n        "
"            printf(\"I/O succeeded\\en\");\n                    break;\n      "
"          case EINPROGRESS:\n                    printf(\"In "
"progress\\en\");\n                    break;\n                case "
"ECANCELED:\n                    printf(\"Canceled\\en\");\n                   "
" break;\n                default:\n                    "
"errMsg(\"aio_error\");\n                    break;\n                }\n"

#. type: Plain text
#: man-pages/man7/aio.7:430
#, no-wrap
msgid ""
"                if (ioList[j].status != EINPROGRESS)\n"
"                    openReqs--;\n"
"            }\n"
"        }\n"
"    }\n"
msgstr ""
"                if (ioList[j].status != EINPROGRESS)\n                    "
"openReqs--;\n            }\n        }\n    }\n"

#. type: Plain text
#: man-pages/man7/aio.7:432
#, no-wrap
msgid "    printf(\"All I/O requests completed\\en\");\n"
msgstr "    printf(\"All I/O requests completed\\en\");\n"

#. type: Plain text
#: man-pages/man7/aio.7:434
#, no-wrap
msgid "    /* Check status return of all I/O requests */\n"
msgstr ""
"    /* проверяем возвращаемое состояние всех запросов ввода-вывода */\n"

#. type: Plain text
#: man-pages/man7/aio.7:438
#, no-wrap
msgid ""
"    printf(\"aio_return():\\en\");\n"
"    for (j = 0; j E<lt> numReqs; j++) {\n"
"        ssize_t s;\n"
msgstr ""
"    printf(\"aio_return():\\en\");\n    for (j = 0; j E<lt> numReqs; j++) {\n "
"       ssize_t s;\n"

#. type: Plain text
#: man-pages/man7/aio.7:443
#, no-wrap
msgid ""
"        s = aio_return(ioList[j].aiocbp);\n"
"        printf(\"    for request %d (descriptor %d): %zd\\en\",\n"
"                j, ioList[j].aiocbp-E<gt>aio_fildes, s);\n"
"    }\n"
msgstr ""
"        s = aio_return(ioList[j].aiocbp);\n        printf(\"    for request %"
"d (descriptor %d): %zd\\en\",\n                j, ioList[j].aiocbp-E<gt>"
"aio_fildes, s);\n    }\n"

#. type: Plain text
#: man-pages/man7/aio.7:446
#, no-wrap
msgid ""
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr "    exit(EXIT_SUCCESS);\n}\n"

#. type: SH
#: man-pages/man7/aio.7:447
#, no-wrap
msgid "SEE ALSO"
msgstr "СМОТРИТЕ ТАКЖЕ"

#. type: Plain text
#: man-pages/man7/aio.7:462
msgid ""
"B<io_cancel>(2), B<io_destroy>(2), B<io_getevents>(2), B<io_setup>(2), "
"B<io_submit>(2), B<aio_cancel>(3), B<aio_error>(3), B<aio_init>(3), "
"B<aio_read>(3), B<aio_return>(3), B<aio_write>(3), B<lio_listio>(3)"
msgstr ""
"B<io_cancel>(2), B<io_destroy>(2), B<io_getevents>(2), B<io_setup>(2), B<"
"io_submit>(2), B<aio_cancel>(3), B<aio_error>(3), B<aio_init>(3), B<aio_read>"
"(3), B<aio_return>(3), B<aio_write>(3), B<lio_listio>(3)"

#. type: Plain text
#: man-pages/man7/aio.7:464
msgid ""
"E<.UR http://www.squid-cache.org\\:/~adrian\\:/Reprint-Pulavarty-"
"OLS2003.pdf> E<.UE>"
msgstr ""
"E<.UR http://www.squid-cache.org\\:/~adrian\\:/Reprint-Pulavarty-OLS2003.pdf> "
"E<.UE>"

#. type: TH
#: man-pages/man7/ascii.7:35
#, no-wrap
msgid "ASCII"
msgstr "ASCII"

#. type: TH
#: man-pages/man7/ascii.7:35
#, no-wrap
msgid "2014-02-26"
msgstr "2014-02-26"

#. type: Plain text
#: man-pages/man7/ascii.7:38
msgid "ascii - ASCII character set encoded in octal, decimal, and hexadecimal"
msgstr ""
"ascii - набор символов ASCII, представленный восьмеричным, десятичным и "
"шестнадцатеричным кодом"

#. type: Plain text
#: man-pages/man7/ascii.7:43
msgid ""
"ASCII is the American Standard Code for Information Interchange.  It is a "
"7-bit code.  Many 8-bit codes (e.g., ISO 8859-1) contain ASCII as their "
"lower half.  The international counterpart of ASCII is known as ISO 646."
msgstr ""
"ASCII — американский стандартный код для обмена информацией. Это 7-битная "
"кодировка. Многие 8-битные коды (например, ISO 8859-1) содержат ASCII в своих "
"нижних половинах таблиц. Международный аналог ASCII также известен как ISO "
"646."

#. type: Plain text
#: man-pages/man7/ascii.7:45
msgid "The following table contains the 128 ASCII characters."
msgstr "В следующей таблице содержатся 128 символов ASCII."

#. type: Plain text
#: man-pages/man7/ascii.7:47
msgid "C program CW<\\(aq\\eX\\(aq> escapes are noted."
msgstr ""
"В программах на C используют экранированные версии (CW<\\(aq\\eX\\(aq>)."

#. type: tbl table
#: man-pages/man7/ascii.7:52
#, no-wrap
msgid "Oct\tDec\tHex\tChar\tOct\tDec\tHex\tChar\n"
msgstr "Вос\tДес\tШес\tСимв\tВос\tДес\tШес\tСимв\n"

#. type: tbl table
#: man-pages/man7/ascii.7:53
#, no-wrap
msgid "_\n"
msgstr "_\n"

#. type: tbl table
#: man-pages/man7/ascii.7:54
#, no-wrap
msgid "000\t0\t00\tNUL \\(aq\\e0\\(aq\t100\t64\t40\t@\n"
msgstr "000\t0\t00\tNUL \\(aq\\e0\\(aq\t100\t64\t40\t@\n"

#. type: tbl table
#: man-pages/man7/ascii.7:55
#, no-wrap
msgid "001\t1\t01\tSOH (start of heading)\t101\t65\t41\tA\n"
msgstr "001\t1\t01\tSOH (начало заголовка)\t101\t65\t41\tA\n"

#. type: tbl table
#: man-pages/man7/ascii.7:56
#, no-wrap
msgid "002\t2\t02\tSTX (start of text)\t102\t66\t42\tB\n"
msgstr "002\t2\t02\tSTX (начало текста)\t102\t66\t42\tB\n"

#. type: tbl table
#: man-pages/man7/ascii.7:57
#, no-wrap
msgid "003\t3\t03\tETX (end of text)\t103\t67\t43\tC\n"
msgstr "003\t3\t03\tETX (конец текста)\t103\t67\t43\tC\n"

#. type: tbl table
#: man-pages/man7/ascii.7:58
#, no-wrap
msgid "004\t4\t04\tEOT (end of transmission)\t104\t68\t44\tD\n"
msgstr "004\t4\t04\tEOT (конец передачи)\t104\t68\t44\tD\n"

#. type: tbl table
#: man-pages/man7/ascii.7:59
#, no-wrap
msgid "005\t5\t05\tENQ (enquiry)\t105\t69\t45\tE\n"
msgstr "005\t5\t05\tENQ (запрос подтв.)\t105\t69\t45\tE\n"

#. type: tbl table
#: man-pages/man7/ascii.7:60
#, no-wrap
msgid "006\t6\t06\tACK (acknowledge)\t106\t70\t46\tF\n"
msgstr "006\t6\t06\tACK (подтверждение)\t106\t70\t46\tF\n"

#. type: tbl table
#: man-pages/man7/ascii.7:61
#, no-wrap
msgid "007\t7\t07\tBEL \\(aq\\ea\\(aq (bell)\t107\t71\t47\tG\n"
msgstr "007\t7\t07\tBEL \\(aq\\ea\\(aq (звонок)\t107\t71\t47\tG\n"

#. type: tbl table
#: man-pages/man7/ascii.7:62
#, no-wrap
msgid "010\t8\t08\tBS  \\(aq\\eb\\(aq (backspace)\t110\t72\t48\tH\n"
msgstr "010\t8\t08\tBS \\(aq\\eb\\(aq (забой)\t110\t72\t48\tH\n"

#. type: tbl table
#: man-pages/man7/ascii.7:63
#, no-wrap
msgid "011\t9\t09\tHT  \\(aq\\et\\(aq (horizontal tab)\t111\t73\t49\tI\n"
msgstr "011\t9\t09\tHT \\(aq\\et\\(aq (горизон. таб.)\t111\t73\t49\tI\n"

#. type: tbl table
#: man-pages/man7/ascii.7:64
#, no-wrap
msgid "012\t10\t0A\tLF  \\(aq\\en\\(aq (new line)\t112\t74\t4A\tJ\n"
msgstr "012\t10\t0A\tLF \\(aq\\en\\(aq (перевод строки)\t112\t74\t4A\tJ\n"

#. type: tbl table
#: man-pages/man7/ascii.7:65
#, no-wrap
msgid "013\t11\t0B\tVT  \\(aq\\ev\\(aq (vertical tab)\t113\t75\t4B\tK\n"
msgstr "013\t11\t0B\tVT \\(aq\\ev\\(aq (верт. таб.)\t113\t75\t4B\tK\n"

#. type: tbl table
#: man-pages/man7/ascii.7:66
#, no-wrap
msgid "014\t12\t0C\tFF  \\(aq\\ef\\(aq (form feed)\t114\t76\t4C\tL\n"
msgstr "014\t12\t0C\tFF \\(aq\\ef\\(aq (новая страница)\t114\t76\t4C\tL\n"

#. type: tbl table
#: man-pages/man7/ascii.7:67
#, no-wrap
msgid "015\t13\t0D\tCR  \\(aq\\er\\(aq (carriage ret)\t115\t77\t4D\tM\n"
msgstr "015\t13\t0D\tCR \\(aq\\er\\(aq (возвр. каретки)\t115\t77\t4D\tM\n"

#. type: tbl table
#: man-pages/man7/ascii.7:68
#, no-wrap
msgid "016\t14\t0E\tSO  (shift out)\t116\t78\t4E\tN\n"
msgstr "016\t14\t0E\tSO (смена ленты)\t116\t78\t4E\tN\n"

#. type: tbl table
#: man-pages/man7/ascii.7:69
#, no-wrap
msgid "017\t15\t0F\tSI  (shift in)\t117\t79\t4F\tO\n"
msgstr "017\t15\t0F\tSI (обр. смена ленты)\t117\t79\t4F\tO\n"

#. type: tbl table
#: man-pages/man7/ascii.7:70
#, no-wrap
msgid "020\t16\t10\tDLE (data link escape)\t120\t80\t50\tP\n"
msgstr "020\t16\t10\tDLE (нач. спец. символов)\t120\t80\t50\tP\n"

#. type: tbl table
#: man-pages/man7/ascii.7:71
#, no-wrap
msgid "021\t17\t11\tDC1 (device control 1)\t121\t81\t51\tQ\n"
msgstr "021\t17\t11\tDC1 (1 сим. упр. устр.)\t121\t81\t51\tQ\n"

#. type: tbl table
#: man-pages/man7/ascii.7:72
#, no-wrap
msgid "022\t18\t12\tDC2 (device control 2)\t122\t82\t52\tR\n"
msgstr "022\t18\t12\tDC2 (2 сим. упр. устр.)\t122\t82\t52\tR\n"

#. type: tbl table
#: man-pages/man7/ascii.7:73
#, no-wrap
msgid "023\t19\t13\tDC3 (device control 3)\t123\t83\t53\tS\n"
msgstr "023\t19\t13\tDC3 (3 сим. упр. устр.)\t123\t83\t53\tS\n"

#. type: tbl table
#: man-pages/man7/ascii.7:74
#, no-wrap
msgid "024\t20\t14\tDC4 (device control 4)\t124\t84\t54\tT\n"
msgstr "024\t20\t14\tDC4 (4 сим. упр. устр.)\t124\t84\t54\tT\n"

#. type: tbl table
#: man-pages/man7/ascii.7:75
#, no-wrap
msgid "025\t21\t15\tNAK (negative ack.)\t125\t85\t55\tU\n"
msgstr "025\t21\t15\tNAK (отказ подтверж.)\t125\t85\t55\tU\n"

#. type: tbl table
#: man-pages/man7/ascii.7:76
#, no-wrap
msgid "026\t22\t16\tSYN (synchronous idle)\t126\t86\t56\tV\n"
msgstr "026\t22\t16\tSYN (синх. ожидание)\t126\t86\t56\tV\n"

#. type: tbl table
#: man-pages/man7/ascii.7:77
#, no-wrap
msgid "027\t23\t17\tETB (end of trans. blk)\t127\t87\t57\tW\n"
msgstr "027\t23\t17\tETB (конец перед. блока)\t127\t87\t57\tW\n"

#. type: tbl table
#: man-pages/man7/ascii.7:78
#, no-wrap
msgid "030\t24\t18\tCAN (cancel)\t130\t88\t58\tX\n"
msgstr "030\t24\t18\tCAN (отмена)\t130\t88\t58\tX\n"

#. type: tbl table
#: man-pages/man7/ascii.7:79
#, no-wrap
msgid "031\t25\t19\tEM  (end of medium)\t131\t89\t59\tY\n"
msgstr "031\t25\t19\tEM (конец носителя)\t131\t89\t59\tY\n"

#. type: tbl table
#: man-pages/man7/ascii.7:80
#, no-wrap
msgid "032\t26\t1A\tSUB (substitute)\t132\t90\t5A\tZ\n"
msgstr "032\t26\t1A\tSUB (подстановка)\t132\t90\t5A\tZ\n"

#. type: tbl table
#: man-pages/man7/ascii.7:81
#, no-wrap
msgid "033\t27\t1B\tESC (escape)\t133\t91\t5B\t[\n"
msgstr "033\t27\t1B\tESC (начало спец. символа)\t133\t91\t5B\t[\n"

#. type: tbl table
#: man-pages/man7/ascii.7:82
#, no-wrap
msgid "034\t28\t1C\tFS  (file separator)\t134\t92\t5C\t\\e  \\(aq\\e\\e\\(aq\n"
msgstr ""
"034\t28\t1C\tFS (разделитель файлов)\t134\t92\t5C\t\\e  \\(aq\\e\\e\\(aq\n"

#. type: tbl table
#: man-pages/man7/ascii.7:83
#, no-wrap
msgid "035\t29\t1D\tGS  (group separator)\t135\t93\t5D\t]\n"
msgstr "035\t29\t1D\tGS (разделитель групп)\t135\t93\t5D\t]\n"

#. type: tbl table
#: man-pages/man7/ascii.7:84
#, no-wrap
msgid "036\t30\t1E\tRS  (record separator)\t136\t94\t5E\t^\n"
msgstr "036\t30\t1E\tRS (разделитель записей)\t136\t94\t5E\t^\n"

#. type: tbl table
#: man-pages/man7/ascii.7:85
#, no-wrap
msgid "037\t31\t1F\tUS  (unit separator)\t137\t95\t5F\t\\&_\n"
msgstr "037\t31\t1F\tUS (раздел. элементов)\t137\t95\t5F\t\\&_\n"

#. type: tbl table
#: man-pages/man7/ascii.7:86
#, no-wrap
msgid "040\t32\t20\tSPACE\t140\t96\t60\t\\`\n"
msgstr "040\t32\t20\tПРОБЕЛ\t140\t96\t60\t\\`\n"

#. type: tbl table
#: man-pages/man7/ascii.7:87
#, no-wrap
msgid "041\t33\t21\t!\t141\t97\t61\ta\n"
msgstr "041\t33\t21\t!\t141\t97\t61\ta\n"

#. type: tbl table
#: man-pages/man7/ascii.7:88
#, no-wrap
msgid "042\t34\t22\t\"\t142\t98\t62\tb\n"
msgstr "042\t34\t22\t\"\t142\t98\t62\tb\n"

#. type: tbl table
#: man-pages/man7/ascii.7:89
#, no-wrap
msgid "043\t35\t23\t#\t143\t99\t63\tc\n"
msgstr "043\t35\t23\t#\t143\t99\t63\tc\n"

#. type: tbl table
#: man-pages/man7/ascii.7:90
#, no-wrap
msgid "044\t36\t24\t$\t144\t100\t64\td\n"
msgstr "044\t36\t24\t$\t144\t100\t64\td\n"

#. type: tbl table
#: man-pages/man7/ascii.7:91
#, no-wrap
msgid "045\t37\t25\t%\t145\t101\t65\te\n"
msgstr "045\t37\t25\t%\t145\t101\t65\te\n"

#. type: tbl table
#: man-pages/man7/ascii.7:92
#, no-wrap
msgid "046\t38\t26\t&\t146\t102\t66\tf\n"
msgstr "046\t38\t26\t&\t146\t102\t66\tf\n"

#. type: tbl table
#: man-pages/man7/ascii.7:93
#, no-wrap
msgid "047\t39\t27\t\\(aq\t147\t103\t67\tg\n"
msgstr "047\t39\t27\t\\(aq\t147\t103\t67\tg\n"

#. type: tbl table
#: man-pages/man7/ascii.7:94
#, no-wrap
msgid "050\t40\t28\t(\t150\t104\t68\th\n"
msgstr "050\t40\t28\t(\t150\t104\t68\th\n"

#. type: tbl table
#: man-pages/man7/ascii.7:95
#, no-wrap
msgid "051\t41\t29\t)\t151\t105\t69\ti\n"
msgstr "051\t41\t29\t)\t151\t105\t69\ti\n"

#. type: tbl table
#: man-pages/man7/ascii.7:96
#, no-wrap
msgid "052\t42\t2A\t*\t152\t106\t6A\tj\n"
msgstr "052\t42\t2A\t*\t152\t106\t6A\tj\n"

#. type: tbl table
#: man-pages/man7/ascii.7:97
#, no-wrap
msgid "053\t43\t2B\t+\t153\t107\t6B\tk\n"
msgstr "053\t43\t2B\t+\t153\t107\t6B\tk\n"

#. type: tbl table
#: man-pages/man7/ascii.7:98
#, no-wrap
msgid "054\t44\t2C\t,\t154\t108\t6C\tl\n"
msgstr "054\t44\t2C\t,\t154\t108\t6C\tl\n"

#. type: tbl table
#: man-pages/man7/ascii.7:99
#, no-wrap
msgid "055\t45\t2D\t-\t155\t109\t6D\tm\n"
msgstr "055\t45\t2D\t-\t155\t109\t6D\tm\n"

#. type: tbl table
#: man-pages/man7/ascii.7:100
#, no-wrap
msgid "056\t46\t2E\t.\t156\t110\t6E\tn\n"
msgstr "056\t46\t2E\t.\t156\t110\t6E\tn\n"

#. type: tbl table
#: man-pages/man7/ascii.7:101
#, no-wrap
msgid "057\t47\t2F\t/\t157\t111\t6F\to\n"
msgstr "057\t47\t2F\t/\t157\t111\t6F\to\n"

#. type: tbl table
#: man-pages/man7/ascii.7:102
#, no-wrap
msgid "060\t48\t30\t0\t160\t112\t70\tp\n"
msgstr "060\t48\t30\t0\t160\t112\t70\tp\n"

#. type: tbl table
#: man-pages/man7/ascii.7:103
#, no-wrap
msgid "061\t49\t31\t1\t161\t113\t71\tq\n"
msgstr "061\t49\t31\t1\t161\t113\t71\tq\n"

#. type: tbl table
#: man-pages/man7/ascii.7:104
#, no-wrap
msgid "062\t50\t32\t2\t162\t114\t72\tr\n"
msgstr "062\t50\t32\t2\t162\t114\t72\tr\n"

#. type: tbl table
#: man-pages/man7/ascii.7:105
#, no-wrap
msgid "063\t51\t33\t3\t163\t115\t73\ts\n"
msgstr "063\t51\t33\t3\t163\t115\t73\ts\n"

#. type: tbl table
#: man-pages/man7/ascii.7:106
#, no-wrap
msgid "064\t52\t34\t4\t164\t116\t74\tt\n"
msgstr "064\t52\t34\t4\t164\t116\t74\tt\n"

#. type: tbl table
#: man-pages/man7/ascii.7:107
#, no-wrap
msgid "065\t53\t35\t5\t165\t117\t75\tu\n"
msgstr "065\t53\t35\t5\t165\t117\t75\tu\n"

#. type: tbl table
#: man-pages/man7/ascii.7:108
#, no-wrap
msgid "066\t54\t36\t6\t166\t118\t76\tv\n"
msgstr "066\t54\t36\t6\t166\t118\t76\tv\n"

#. type: tbl table
#: man-pages/man7/ascii.7:109
#, no-wrap
msgid "067\t55\t37\t7\t167\t119\t77\tw\n"
msgstr "067\t55\t37\t7\t167\t119\t77\tw\n"

#. type: tbl table
#: man-pages/man7/ascii.7:110
#, no-wrap
msgid "070\t56\t38\t8\t170\t120\t78\tx\n"
msgstr "070\t56\t38\t8\t170\t120\t78\tx\n"

#. type: tbl table
#: man-pages/man7/ascii.7:111
#, no-wrap
msgid "071\t57\t39\t9\t171\t121\t79\ty\n"
msgstr "071\t57\t39\t9\t171\t121\t79\ty\n"

#. type: tbl table
#: man-pages/man7/ascii.7:112
#, no-wrap
msgid "072\t58\t3A\t:\t172\t122\t7A\tz\n"
msgstr "072\t58\t3A\t:\t172\t122\t7A\tz\n"

#. type: tbl table
#: man-pages/man7/ascii.7:113
#, no-wrap
msgid "073\t59\t3B\t;\t173\t123\t7B\t{\n"
msgstr "073\t59\t3B\t;\t173\t123\t7B\t{\n"

#. type: tbl table
#: man-pages/man7/ascii.7:114
#, no-wrap
msgid "074\t60\t3C\tE<lt>\t174\t124\t7C\t|\n"
msgstr "074\t60\t3C\tE<lt>\t174\t124\t7C\t|\n"

#. type: tbl table
#: man-pages/man7/ascii.7:115
#, no-wrap
msgid "075\t61\t3D\t= \t175\t125\t7D\t}\n"
msgstr "075\t61\t3D\t= \t175\t125\t7D\t}\n"

#. type: tbl table
#: man-pages/man7/ascii.7:116
#, no-wrap
msgid "076\t62\t3E\tE<gt>\t176\t126\t7E\t~\n"
msgstr "076\t62\t3E\tE<gt>\t176\t126\t7E\t~\n"

#. type: tbl table
#: man-pages/man7/ascii.7:117
#, no-wrap
msgid "077\t63\t3F\t?\t177\t127\t7F\tDEL\n"
msgstr "077\t63\t3F\t?\t177\t127\t7F\tDEL\n"

#. type: SS
#: man-pages/man7/ascii.7:123
#, no-wrap
msgid "Tables"
msgstr "Таблицы"

#. type: Plain text
#: man-pages/man7/ascii.7:125
msgid "For convenience, let us give more compact tables in hex and decimal."
msgstr "Компактная таблица шестнадцатеричных и десятичных кодов."

#. type: Plain text
#: man-pages/man7/ascii.7:149
#, no-wrap
msgid ""
"   2 3 4 5 6 7       30 40 50 60 70 80 90 100 110 120\n"
" -------------      ---------------------------------\n"
"0:   0 @ P \\` p     0:    (  2  E<lt>  F  P  Z  d   n   x\n"
"1: ! 1 A Q a q     1:    )  3  =  G  Q  [  e   o   y\n"
"2: \" 2 B R b r     2:    *  4  E<gt>  H  R  \\e  f   p   z\n"
"3: # 3 C S c s     3: !  +  5  ?  I  S  ]  g   q   {\n"
"4: $ 4 D T d t     4: \"  ,  6  @  J  T  ^  h   r   |\n"
"5: % 5 E U e u     5: #  -  7  A  K  U  _  i   s   }\n"
"6: & 6 F V f v     6: $  .  8  B  L  V  \\`  j   t   ~\n"
"7: \\' 7 G W g w     7: %  /  9  C  M  W  a  k   u  DEL\n"
"8: ( 8 H X h x     8: &  0  :  D  N  X  b  l   v\n"
"9: ) 9 I Y i y     9: \\'  1  ;  E  O  Y  c  m   w\n"
"A: * : J Z j z\n"
"B: + ; K [ k {\n"
"C: , E<lt> L \\e l |\n"
"D: - = M ] m }\n"
"E: . E<gt> N ^ n ~\n"
"F: / ? O _ o DEL\n"
msgstr ""
"   2 3 4 5 6 7       30 40 50 60 70 80 90 100 110 120\n -------------      "
"---------------------------------\n0:   0 @ P \\` p     0:    (  2  E<lt>  F  "
"P  Z  d   n   x\n1: ! 1 A Q a q     1:    )  3  =  G  Q  [  e   o   y\n2: \" "
"2 B R b r     2:    *  4  E<gt>  H  R  \\e  f   p   z\n3: # 3 C S c s     3: "
"!  +  5  ?  I  S  ]  g   q   {\n4: $ 4 D T d t     4: \"  ,  6  @  J  T  ^  h "
"  r   |\n5: % 5 E U e u     5: #  -  7  A  K  U  _  i   s   }\n6: & 6 F V f v "
"    6: $  .  8  B  L  V  \\`  j   t   ~\n7: \\' 7 G W g w     7: %  /  9  C  "
"M  W  a  k   u  DEL\n8: ( 8 H X h x     8: &  0  :  D  N  X  b  l   v\n9: ) 9 "
"I Y i y     9: \\'  1  ;  E  O  Y  c  m   w\nA: * : J Z j z\nB: + ; K [ k "
"{\nC: , E<lt> L \\e l |\nD: - = M ] m }\nE: . E<gt> N ^ n ~\nF: / ? O _ o "
"DEL\n"

#. type: SS
#: man-pages/man7/ascii.7:155
#, no-wrap
msgid "History"
msgstr "История"

#. type: Plain text
#: man-pages/man7/ascii.7:159
msgid "An B<ascii> manual page appeared in Version 7 of AT&T UNIX."
msgstr "Справочная таблица B<ascii> впервые появилась в AT&T UNIX Version 7."

#. type: Plain text
#: man-pages/man7/ascii.7:163
msgid ""
"On older terminals, the underscore code is displayed as a left arrow, called"
" backarrow, the caret is displayed as an up-arrow and the vertical bar has a"
" hole in the middle."
msgstr ""
"На старых терминалах символ подчёркивания отображается как стрелка влево "
"(т.н. стрелка назад), каретка отображается как стрелка вверх и вертикальная "
"черта имеет пустоту в середине."

#. type: Plain text
#: man-pages/man7/ascii.7:169
msgid ""
"Uppercase and lowercase characters differ by just one bit and the ASCII "
"character 2 differs from the double quote by just one bit, too.  That made "
"it much easier to encode characters mechanically or with a non-"
"microcontroller-based electronic keyboard and that pairing was found on old "
"teletypes."
msgstr ""
"Строчные и прописные символы отличаются только одним битом и ASCII символ 2 "
"отличается от двойной кавычки тоже одним битом. Это сделано для облегчения "
"механического кодирования символов или для использования клавиатур без "
"микроконтроллеров, и такое pairing использовался на старых телетайпах."

#.  ASA was the American Standards Association and X3 was an ASA sectional
#.  committee on computers and data processing.  Its name changed to
#.  American National Standards Committee X3 (ANSC-X3) and now it is known
#.  as Accredited Standards Committee X3 (ASC X3).  It is accredited by ANSI
#.  and administered by ITI.  The subcommittee X3.2 worked on coded
#.  character sets; the task group working on ASCII appears to have been
#.  designated X3.2.4.  In 1966, ASA became the United States of America
#.  Standards Institute (USASI) and published ASCII in 1968.  It became the
#.  American National Standards Institute (ANSI) in 1969 and is the
#.  U.S. member body of ISO; private and nonprofit.
#. type: Plain text
#: man-pages/man7/ascii.7:184
msgid ""
"The ASCII standard was published by the United States of America Standards "
"Institute (USASI) in 1968."
msgstr ""
"Стандарт ASCII опубликован американским национальным институтом стандартов "
"(USASI) в 1968 году."

#. type: Plain text
#: man-pages/man7/ascii.7:200
msgid ""
"B<iso_8859-1>(7), B<iso_8859-10>(7), B<iso_8859-13>(7), B<iso_8859-14>(7), "
"B<iso_8859-15>(7), B<iso_8859-16>(7), B<iso_8859-2>(7), B<iso_8859-3>(7), "
"B<iso_8859-4>(7), B<iso_8859-5>(7), B<iso_8859-6>(7), B<iso_8859-7>(7), "
"B<iso_8859-8>(7), B<iso_8859-9>(7), B<utf-8>(7)"
msgstr ""
"B<iso_8859-1>(7), B<iso_8859-10>(7), B<iso_8859-13>(7), B<iso_8859-14>(7), B<"
"iso_8859-15>(7), B<iso_8859-16>(7), B<iso_8859-2>(7), B<iso_8859-3>(7), B<"
"iso_8859-4>(7), B<iso_8859-5>(7), B<iso_8859-6>(7), B<iso_8859-7>(7), B<"
"iso_8859-8>(7), B<iso_8859-9>(7), B<utf-8>(7)"

#. type: TH
#: man-pages/man7/armscii-8.7:26
#, no-wrap
msgid "ARMSCII-8"
msgstr "ARMSCII-8"

#. type: TH
#: man-pages/man7/armscii-8.7:26
#, no-wrap
msgid "2014-02-16"
msgstr "2014-02-16"

#. type: Plain text
#: man-pages/man7/armscii-8.7:31
msgid ""
"armscii-8 - Armenian character set encoded in octal, decimal, and "
"hexadecimal"
msgstr ""
"armscii-8 - Набор армянских символов в восьмеричной, десятичной и "
"шестнадцатеричной системах счисления"

#. type: Plain text
#: man-pages/man7/armscii-8.7:34
msgid ""
"The Armenian Standard Code for Information Interchange, 8-bit coded "
"character set."
msgstr ""
"Армянский стандартный код для обмена информацией; 8-битный набор символов."

#. type: SS
#: man-pages/man7/armscii-8.7:34
#, no-wrap
msgid "ArmSCII-8 characters"
msgstr "Символы ArmSCII-8"

#.  The fourth column will only show the proper glyphs
#.  in an environment configured for ArmSCII-8.
#. type: Plain text
#: man-pages/man7/armscii-8.7:41
msgid ""
"The following table displays the characters in ArmSCII-8, which are "
"printable and unlisted in the B<ascii>(7)  manual page."
msgstr ""
"В следующей таблице показаны символы из набора ArmSCII-8, являющиеся "
"печатными и отсутствующие в справочной странице B<ascii>(7)."

#. type: tbl table
#: man-pages/man7/armscii-8.7:43
#, no-wrap
msgid "Oct\tDec\tHex\tChar\tDescription\n"
msgstr "Вос\tДес\tШес\tСимв\tОписание\n"

#. type: tbl table
#: man-pages/man7/armscii-8.7:45
#, no-wrap
msgid "240\t160\tA0\t\\ \tNO-BREAK SPACE\n"
msgstr "240\t160\tA0\t\\ \tнеразрывный пробел\n"

#. type: tbl table
#: man-pages/man7/armscii-8.7:46
#, no-wrap
msgid "242\t162\tA2\tև\tARMENIAN SMALL LIGATURE ECH YIWN\n"
msgstr "242\t162\tA2\tև\tармянская строчная лигатура ев\n"

#. type: tbl table
#: man-pages/man7/armscii-8.7:47
#, no-wrap
msgid "243\t163\tA3\t։\tARMENIAN FULL STOP\n"
msgstr "243\t163\tA3\t։\tармянская точка\n"

#. type: tbl table
#: man-pages/man7/armscii-8.7:48
#, no-wrap
msgid "244\t164\tA4\t)\tRIGHT PARENTHESIS\n"
msgstr "244\t164\tA4\t)\tправая скобка\n"

#. type: tbl table
#: man-pages/man7/armscii-8.7:49
#, no-wrap
msgid "245\t165\tA5\t(\tLEFT PARENTHESIS\n"
msgstr "245\t165\tA5\t(\tлевая скобка\n"

#. type: tbl table
#: man-pages/man7/armscii-8.7:50
#, no-wrap
msgid "246\t166\tA6\t»\tRIGHT-POINTING DOUBLE ANGLE QUOTATION MARK\n"
msgstr "246\t166\tA6\t»\tзакрывающая французская кавычка\n"

#. type: tbl table
#: man-pages/man7/armscii-8.7:51
#, no-wrap
msgid "247\t167\tA7\t«\tLEFT-POINTING DOUBLE ANGLE QUOTATION MARK\n"
msgstr "247\t167\tA7\t«\tоткрывающая французская кавычка\n"

#. type: tbl table
#: man-pages/man7/armscii-8.7:52
#, no-wrap
msgid "250\t168\tA8\t—\tEM DASH\n"
msgstr "250\t168\tA8\t—\tдлинное тире\n"

#. type: tbl table
#: man-pages/man7/armscii-8.7:53
#, no-wrap
msgid "251\t169\tA9\t.\tFULL STOP\n"
msgstr "251\t169\tA9\t.\tточка\n"

#. type: tbl table
#: man-pages/man7/armscii-8.7:54
#, no-wrap
msgid "252\t170\tAA\t՝\tARMENIAN COMMA\n"
msgstr "252\t170\tAA\t՝\tармянский знак запятой\n"

#. type: tbl table
#: man-pages/man7/armscii-8.7:55
#, no-wrap
msgid "253\t171\tAB\t,\tCOMMA\n"
msgstr "253\t171\tAB\t,\tзапятая\n"

#. type: tbl table
#: man-pages/man7/armscii-8.7:56
#, no-wrap
msgid "254\t172\tAC\t-\tHYPHEN-MINUS\n"
msgstr "254\t172\tAC\t-\tдефис-минус\n"

#. type: tbl table
#: man-pages/man7/armscii-8.7:57
#, no-wrap
msgid "255\t173\tAD\t֊\tARMENIAN HYPHEN\n"
msgstr "255\t173\tAD\t֊\tармянский знак дефиса\n"

#. type: tbl table
#: man-pages/man7/armscii-8.7:58
#, no-wrap
msgid "256\t174\tAE\t…\tHORIZONTAL ELLIPSIS\n"
msgstr "256\t174\tAE\t…\tмноготочие\n"

#. type: tbl table
#: man-pages/man7/armscii-8.7:59
#, no-wrap
msgid "257\t175\tAF\t՜\tARMENIAN EXCLAMATION MARK\n"
msgstr "257\t175\tAF\t՜\tармянский восклицательный знак\n"

#. type: tbl table
#: man-pages/man7/armscii-8.7:60
#, no-wrap
msgid "260\t176\tB0\t՛\tARMENIAN EMPHASIS MARK\n"
msgstr "260\t176\tB0\t՛\tармянское знак ударения\n"

#. type: tbl table
#: man-pages/man7/armscii-8.7:61
#, no-wrap
msgid "261\t177\tB1\t՞\tARMENIAN QUESTION MARK\n"
msgstr "261\t177\tB1\t՞\tармянский вопросительный знак\n"

#. type: tbl table
#: man-pages/man7/armscii-8.7:62
#, no-wrap
msgid "262\t178\tB2\tԱ\tARMENIAN CAPITAL LETTER AYB\n"
msgstr "262\t178\tB2\tԱ\tармянская заглавная буква айб\n"

#. type: tbl table
#: man-pages/man7/armscii-8.7:63
#, no-wrap
msgid "263\t179\tB3\tա\tARMENIAN SMALL LETTER AYB\n"
msgstr "263\t179\tB3\tա\tармянская строчная буква айб\n"

#. type: tbl table
#: man-pages/man7/armscii-8.7:64
#, no-wrap
msgid "264\t180\tB4\tԲ\tARMENIAN CAPITAL LETTER BEN\n"
msgstr "264\t180\tB4\tԲ\tармянская заглавная буква бен\n"

#. type: tbl table
#: man-pages/man7/armscii-8.7:65
#, no-wrap
msgid "265\t181\tB5\tբ\tARMENIAN SMALL LETTER BEN\n"
msgstr "265\t181\tB5\tբ\tармянская строчная буква бен\n"

#. type: tbl table
#: man-pages/man7/armscii-8.7:66
#, no-wrap
msgid "266\t182\tB6\tԳ\tARMENIAN CAPITAL LETTER GIM\n"
msgstr "266\t182\tB6\tԳ\tармянская заглавная буква гим\n"

#. type: tbl table
#: man-pages/man7/armscii-8.7:67
#, no-wrap
msgid "267\t183\tB7\tգ\tARMENIAN SMALL LETTER GIM\n"
msgstr "267\t183\tB7\tգ\tармянская строчная буква гим\n"

#. type: tbl table
#: man-pages/man7/armscii-8.7:68
#, no-wrap
msgid "270\t184\tB8\tԴ\tARMENIAN CAPITAL LETTER DA\n"
msgstr "270\t184\tB8\tԴ\tармянская заглавная буква да\n"

#. type: tbl table
#: man-pages/man7/armscii-8.7:69
#, no-wrap
msgid "271\t185\tB9\tդ\tARMENIAN SMALL LETTER DA\n"
msgstr "271\t185\tB9\tդ\tармянская строчная буква да\n"

#. type: tbl table
#: man-pages/man7/armscii-8.7:70
#, no-wrap
msgid "272\t186\tBA\tԵ\tARMENIAN CAPITAL LETTER ECH\n"
msgstr "272\t186\tBA\tԵ\tармянская заглавная буква эдж\n"

#. type: tbl table
#: man-pages/man7/armscii-8.7:71
#, no-wrap
msgid "273\t187\tBB\tե\tARMENIAN SMALL LETTER ECH\n"
msgstr "273\t187\tBB\tե\tармянская строчная буква эдж\n"

#. type: tbl table
#: man-pages/man7/armscii-8.7:72
#, no-wrap
msgid "274\t188\tBC\tԶ\tARMENIAN CAPITAL LETTER ZA\n"
msgstr "274\t188\tBC\tԶ\tармянская заглавная буква за\n"

#. type: tbl table
#: man-pages/man7/armscii-8.7:73
#, no-wrap
msgid "275\t189\tBD\tզ\tARMENIAN SMALL LETTER ZA\n"
msgstr "275\t189\tBD\tզ\tармянская строчная буква за\n"

#. type: tbl table
#: man-pages/man7/armscii-8.7:74
#, no-wrap
msgid "276\t190\tBE\tԷ\tARMENIAN CAPITAL LETTER EH\n"
msgstr "276\t190\tBE\tԷ\tармянская заглавная буква э\n"

#. type: tbl table
#: man-pages/man7/armscii-8.7:75
#, no-wrap
msgid "277\t191\tBF\tէ\tARMENIAN SMALL LETTER EH\n"
msgstr "277\t191\tBF\tէ\tармянская строчная буква э\n"

#. type: tbl table
#: man-pages/man7/armscii-8.7:76
#, no-wrap
msgid "300\t192\tC0\tԸ\tARMENIAN CAPITAL LETTER ET\n"
msgstr "300\t192\tC0\tԸ\tармянская заглавная буква ыт\n"

#. type: tbl table
#: man-pages/man7/armscii-8.7:77
#, no-wrap
msgid "301\t193\tC1\tը\tARMENIAN SMALL LETTER ET\n"
msgstr "301\t193\tC1\tը\tармянская строчная буква ыт\n"

#. type: tbl table
#: man-pages/man7/armscii-8.7:78
#, no-wrap
msgid "302\t194\tC2\tԹ\tARMENIAN CAPITAL LETTER TO\n"
msgstr "302\t194\tC2\tԹ\tармянская заглавная буква то\n"

#. type: tbl table
#: man-pages/man7/armscii-8.7:79
#, no-wrap
msgid "303\t195\tC3\tթ\tARMENIAN SMALL LETTER TO\n"
msgstr "303\t195\tC3\tթ\tармянская строчная буква то\n"

#. type: tbl table
#: man-pages/man7/armscii-8.7:80
#, no-wrap
msgid "304\t196\tC4\tԺ\tARMENIAN CAPITAL LETTER ZHE\n"
msgstr "304\t196\tC4\tԺ\tармянская заглавная буква же\n"

#. type: tbl table
#: man-pages/man7/armscii-8.7:81
#, no-wrap
msgid "305\t197\tC5\tժ\tARMENIAN SMALL LETTER ZHE\n"
msgstr "305\t197\tC5\tժ\tармянская строчная буква же\n"

#. type: tbl table
#: man-pages/man7/armscii-8.7:82
#, no-wrap
msgid "306\t198\tC6\tԻ\tARMENIAN CAPITAL LETTER INI\n"
msgstr "306\t198\tC6\tԻ\tармянская заглавная буква ини\n"

#. type: tbl table
#: man-pages/man7/armscii-8.7:83
#, no-wrap
msgid "307\t199\tC7\tի\tARMENIAN SMALL LETTER INI\n"
msgstr "307\t199\tC7\tի\tармянская строчная буква ини\n"

#. type: tbl table
#: man-pages/man7/armscii-8.7:84
#, no-wrap
msgid "310\t200\tC8\tԼ\tARMENIAN CAPITAL LETTER LIWN\n"
msgstr "310\t200\tC8\tԼ\tармянская заглавная буква льюн\n"

#. type: tbl table
#: man-pages/man7/armscii-8.7:85
#, no-wrap
msgid "311\t201\tC9\tլ\tARMENIAN SMALL LETTER LIWN\n"
msgstr "311\t201\tC9\tլ\tармянская строчная буква льюн\n"

#. type: tbl table
#: man-pages/man7/armscii-8.7:86
#, no-wrap
msgid "312\t202\tCA\tԽ\tARMENIAN CAPITAL LETTER XEH\n"
msgstr "312\t202\tCA\tԽ\tармянская заглавная буква хе\n"

#. type: tbl table
#: man-pages/man7/armscii-8.7:87
#, no-wrap
msgid "313\t203\tCB\tխ\tARMENIAN SMALL LETTER XEH\n"
msgstr "313\t203\tCB\tխ\tармянская строчная буква хе\n"

#. type: tbl table
#: man-pages/man7/armscii-8.7:88
#, no-wrap
msgid "314\t204\tCC\tԾ\tARMENIAN CAPITAL LETTER CA\n"
msgstr "314\t204\tCC\tԾ\tармянская заглавная буква тьца\n"

#. type: tbl table
#: man-pages/man7/armscii-8.7:89
#, no-wrap
msgid "315\t205\tCD\tծ\tARMENIAN SMALL LETTER CA\n"
msgstr "315\t205\tCD\tծ\tармянская строчная буква тьца\n"

#. type: tbl table
#: man-pages/man7/armscii-8.7:90
#, no-wrap
msgid "316\t206\tCE\tԿ\tARMENIAN CAPITAL LETTER KEN\n"
msgstr "316\t206\tCE\tԿ\tармянская заглавная буква кен\n"

#. type: tbl table
#: man-pages/man7/armscii-8.7:91
#, no-wrap
msgid "317\t207\tCF\tկ\tARMENIAN SMALL LETTER KEN\n"
msgstr "317\t207\tCF\tկ\tармянская строчная буква кен\n"

#. type: tbl table
#: man-pages/man7/armscii-8.7:92
#, no-wrap
msgid "320\t208\tD0\tՀ\tARMENIAN CAPITAL LETTER HO\n"
msgstr "320\t208\tD0\tՀ\tармянская заглавная буква хо\n"

#. type: tbl table
#: man-pages/man7/armscii-8.7:93
#, no-wrap
msgid "321\t209\tD1\tհ\tARMENIAN SMALL LETTER HO\n"
msgstr "321\t209\tD1\tհ\tармянская строчная буква хо\n"

#. type: tbl table
#: man-pages/man7/armscii-8.7:94
#, no-wrap
msgid "322\t210\tD2\tՁ\tARMENIAN CAPITAL LETTER JA\n"
msgstr "322\t210\tD2\tՁ\tармянская заглавная буква дза\n"

#. type: tbl table
#: man-pages/man7/armscii-8.7:95
#, no-wrap
msgid "323\t211\tD3\tձ\tARMENIAN SMALL LETTER JA\n"
msgstr "323\t211\tD3\tձ\tармянская строчная буква дза\n"

#. type: tbl table
#: man-pages/man7/armscii-8.7:96
#, no-wrap
msgid "324\t212\tD4\tՂ\tARMENIAN CAPITAL LETTER GHAD\n"
msgstr "324\t212\tD4\tՂ\tармянская заглавная буква кхат\n"

#. type: tbl table
#: man-pages/man7/armscii-8.7:97
#, no-wrap
msgid "325\t213\tD5\tղ\tARMENIAN SMALL LETTER GHAD\n"
msgstr "325\t213\tD5\tղ\tармянская строчная буква кхат\n"

#. type: tbl table
#: man-pages/man7/armscii-8.7:98
#, no-wrap
msgid "326\t214\tD6\tՃ\tARMENIAN CAPITAL LETTER CHEH\n"
msgstr "326\t214\tD6\tՃ\tармянская заглавная буква тче\n"

#. type: tbl table
#: man-pages/man7/armscii-8.7:99
#, no-wrap
msgid "327\t215\tD7\tճ\tARMENIAN SMALL LETTER CHEH\n"
msgstr "327\t215\tD7\tճ\tармянская строчная буква тче\n"

#. type: tbl table
#: man-pages/man7/armscii-8.7:100
#, no-wrap
msgid "330\t216\tD8\tՄ\tARMENIAN CAPITAL LETTER MEN\n"
msgstr "330\t216\tD8\tՄ\tармянская заглавная буква мен\n"

#. type: tbl table
#: man-pages/man7/armscii-8.7:101
#, no-wrap
msgid "331\t217\tD9\tմ\tARMENIAN SMALL LETTER MEN\n"
msgstr "331\t217\tD9\tմ\tармянская строчная буква мен\n"

#. type: tbl table
#: man-pages/man7/armscii-8.7:102
#, no-wrap
msgid "332\t218\tDA\tՅ\tARMENIAN CAPITAL LETTER YI\n"
msgstr "332\t218\tDA\tՅ\tармянская заглавная буква йи\n"

#. type: tbl table
#: man-pages/man7/armscii-8.7:103
#, no-wrap
msgid "333\t219\tDB\tյ\tARMENIAN SMALL LETTER YI\n"
msgstr "333\t219\tDB\tյ\tармянская строчная буква йи\n"

#. type: tbl table
#: man-pages/man7/armscii-8.7:104
#, no-wrap
msgid "334\t220\tDC\tՆ\tARMENIAN CAPITAL LETTER NOW\n"
msgstr "334\t220\tDC\tՆ\tармянская заглавная буква ну\n"

#. type: tbl table
#: man-pages/man7/armscii-8.7:105
#, no-wrap
msgid "335\t221\tDD\tն\tARMENIAN SMALL LETTER NOW\n"
msgstr "335\t221\tDD\tն\tармянская строчная буква ну\n"

#. type: tbl table
#: man-pages/man7/armscii-8.7:106
#, no-wrap
msgid "336\t222\tDE\tՇ\tARMENIAN CAPITAL LETTER SHA\n"
msgstr "336\t222\tDE\tՇ\tармянская заглавная буква ша\n"

#. type: tbl table
#: man-pages/man7/armscii-8.7:107
#, no-wrap
msgid "337\t223\tDF\tշ\tARMENIAN SMALL LETTER SHA\n"
msgstr "337\t223\tDF\tշ\tармянская строчная буква ша\n"

#. type: tbl table
#: man-pages/man7/armscii-8.7:108
#, no-wrap
msgid "340\t224\tE0\tՈ\tARMENIAN CAPITAL LETTER VO\n"
msgstr "340\t224\tE0\tՈ\tармянская заглавная буква во\n"

#. type: tbl table
#: man-pages/man7/armscii-8.7:109
#, no-wrap
msgid "341\t225\tE1\tո\tARMENIAN SMALL LETTER VO\n"
msgstr "341\t225\tE1\tո\tармянская строчная буква во\n"

#. type: tbl table
#: man-pages/man7/armscii-8.7:110
#, no-wrap
msgid "342\t226\tE2\tՉ\tARMENIAN CAPITAL LETTER CHA\n"
msgstr "342\t226\tE2\tՉ\tармянская заглавная буква ча\n"

#. type: tbl table
#: man-pages/man7/armscii-8.7:111
#, no-wrap
msgid "343\t227\tE3\tչ\tARMENIAN SMALL LETTER CHA\n"
msgstr "343\t227\tE3\tչ\tармянская строчная буква ча\n"

#. type: tbl table
#: man-pages/man7/armscii-8.7:112
#, no-wrap
msgid "344\t228\tE4\tՊ\tARMENIAN CAPITAL LETTER PEH\n"
msgstr "344\t228\tE4\tՊ\tармянская заглавная буква пе\n"

#. type: tbl table
#: man-pages/man7/armscii-8.7:113
#, no-wrap
msgid "345\t229\tE5\tպ\tARMENIAN SMALL LETTER PEH\n"
msgstr "345\t229\tE5\tպ\tармянская строчная буква пе\n"

#. type: tbl table
#: man-pages/man7/armscii-8.7:114
#, no-wrap
msgid "346\t230\tE6\tՋ\tARMENIAN CAPITAL LETTER JHEH\n"
msgstr "346\t230\tE6\tՋ\tармянская заглавная буква дже\n"

#. type: tbl table
#: man-pages/man7/armscii-8.7:115
#, no-wrap
msgid "347\t231\tE7\tջ\tARMENIAN SMALL LETTER JHEH\n"
msgstr "347\t231\tE7\tջ\tармянская строчная буква дже\n"

#. type: tbl table
#: man-pages/man7/armscii-8.7:116
#, no-wrap
msgid "350\t232\tE8\tՌ\tARMENIAN CAPITAL LETTER RA\n"
msgstr "350\t232\tE8\tՌ\tармянская заглавная буква ра\n"

#. type: tbl table
#: man-pages/man7/armscii-8.7:117
#, no-wrap
msgid "351\t233\tE9\tռ\tARMENIAN SMALL LETTER RA\n"
msgstr "351\t233\tE9\tռ\tармянская строчная буква ра\n"

#. type: tbl table
#: man-pages/man7/armscii-8.7:118
#, no-wrap
msgid "352\t234\tEA\tՍ\tARMENIAN CAPITAL LETTER SEH\n"
msgstr "352\t234\tEA\tՍ\tармянская заглавная буква се\n"

#. type: tbl table
#: man-pages/man7/armscii-8.7:119
#, no-wrap
msgid "353\t235\tEB\tս\tARMENIAN SMALL LETTER SEH\n"
msgstr "353\t235\tEB\tս\tармянская строчная буква се\n"

#. type: tbl table
#: man-pages/man7/armscii-8.7:120
#, no-wrap
msgid "354\t236\tEC\tՎ\tARMENIAN CAPITAL LETTER VEW\n"
msgstr "354\t236\tEC\tՎ\tармянская заглавная буква вев\n"

#. type: tbl table
#: man-pages/man7/armscii-8.7:121
#, no-wrap
msgid "355\t237\tED\tվ\tARMENIAN SMALL LETTER VEW\n"
msgstr "355\t237\tED\tվ\tармянская строчная буква вев\n"

#. type: tbl table
#: man-pages/man7/armscii-8.7:122
#, no-wrap
msgid "356\t238\tEE\tՏ\tARMENIAN CAPITAL LETTER TIWN\n"
msgstr "356\t238\tEE\tՏ\tармянская заглавная буква тюн\n"

#. type: tbl table
#: man-pages/man7/armscii-8.7:123
#, no-wrap
msgid "357\t239\tEF\tտ\tARMENIAN SMALL LETTER TIWN\n"
msgstr "357\t239\tEF\tտ\tармянская строчная буква тюн\n"

#. type: tbl table
#: man-pages/man7/armscii-8.7:124
#, no-wrap
msgid "360\t240\tF0\tՐ\tARMENIAN CAPITAL LETTER REH\n"
msgstr "360\t240\tF0\tՐ\tармянская заглавная буква ре\n"

#. type: tbl table
#: man-pages/man7/armscii-8.7:125
#, no-wrap
msgid "361\t241\tF1\tր\tARMENIAN SMALL LETTER REH\n"
msgstr "361\t241\tF1\tր\tармянская строчная буква ре\n"

#. type: tbl table
#: man-pages/man7/armscii-8.7:126
#, no-wrap
msgid "362\t242\tF2\tՑ\tARMENIAN CAPITAL LETTER CO\n"
msgstr "362\t242\tF2\tՑ\tармянская заглавная буква цо\n"

#. type: tbl table
#: man-pages/man7/armscii-8.7:127
#, no-wrap
msgid "363\t243\tF3\tց\tARMENIAN SMALL LETTER CO\n"
msgstr "363\t243\tF3\tց\tармянская строчная буква цо\n"

#. type: tbl table
#: man-pages/man7/armscii-8.7:128
#, no-wrap
msgid "364\t244\tF4\tՒ\tARMENIAN CAPITAL LETTER YIWN\n"
msgstr "364\t244\tF4\tՒ\tармянская заглавная буква йюн\n"

#. type: tbl table
#: man-pages/man7/armscii-8.7:129
#, no-wrap
msgid "365\t245\tF5\tւ\tARMENIAN SMALL LETTER YIWN\n"
msgstr "365\t245\tF5\tւ\tармянская строчная буква йюн\n"

#. type: tbl table
#: man-pages/man7/armscii-8.7:130
#, no-wrap
msgid "366\t246\tF6\tՓ\tARMENIAN CAPITAL LETTER PIWR\n"
msgstr "366\t246\tF6\tՓ\tармянская заглавная буква пьюр\n"

#. type: tbl table
#: man-pages/man7/armscii-8.7:131
#, no-wrap
msgid "367\t247\tF7\tփ\tARMENIAN SMALL LETTER PIWR\n"
msgstr "367\t247\tF7\tփ\tармянская строчная буква пьюр\n"

#. type: tbl table
#: man-pages/man7/armscii-8.7:132
#, no-wrap
msgid "370\t248\tF8\tՔ\tARMENIAN CAPITAL LETTER KEH\n"
msgstr "370\t248\tF8\tՔ\tармянская заглавная буква ке\n"

#. type: tbl table
#: man-pages/man7/armscii-8.7:133
#, no-wrap
msgid "371\t249\tF9\tք\tARMENIAN SMALL LETTER KEH\n"
msgstr "371\t249\tF9\tք\tармянская строчная буква ке\n"

#. type: tbl table
#: man-pages/man7/armscii-8.7:134
#, no-wrap
msgid "372\t250\tFA\tՕ\tARMENIAN CAPITAL LETTER OH\n"
msgstr "372\t250\tFA\tՕ\tармянская заглавная буква о\n"

#. type: tbl table
#: man-pages/man7/armscii-8.7:135
#, no-wrap
msgid "373\t251\tFB\tօ\tARMENIAN SMALL LETTER OH\n"
msgstr "373\t251\tFB\tօ\tармянская строчная буква о\n"

#. type: tbl table
#: man-pages/man7/armscii-8.7:136
#, no-wrap
msgid "374\t252\tFC\tՖ\tARMENIAN CAPITAL LETTER FEH\n"
msgstr "374\t252\tFC\tՖ\tармянская заглавная буква фе\n"

#. type: tbl table
#: man-pages/man7/armscii-8.7:137
#, no-wrap
msgid "375\t253\tFD\tֆ\tARMENIAN SMALL LETTER FEH\n"
msgstr "375\t253\tFD\tֆ\tармянская строчная буква фе\n"

#. type: tbl table
#: man-pages/man7/armscii-8.7:138
#, no-wrap
msgid "376\t254\tFE\t՚\tARMENIAN APOSTROPHE\n"
msgstr "376\t254\tFE\t՚\tармянский знак апострофа\n"

#. type: Plain text
#: man-pages/man7/armscii-8.7:142
msgid "B<ascii>(7)"
msgstr "B<ascii>(7)"

#. type: TH
#: man-pages/man7/arp.7:13
#, no-wrap
msgid "ARP"
msgstr "ARP"

#. type: TH
#: man-pages/man7/arp.7:13
#, no-wrap
msgid "2008-11-25"
msgstr "2008-11-25"

#. type: Plain text
#: man-pages/man7/arp.7:16
msgid "arp - Linux ARP kernel module."
msgstr "arp - модуль ядра Linux для ARP"

#. type: Plain text
#: man-pages/man7/arp.7:24
msgid ""
"This kernel protocol module implements the Address Resolution Protocol "
"defined in RFC\\ 826.  It is used to convert between Layer2 hardware "
"addresses and IPv4 protocol addresses on directly connected networks.  The "
"user normally doesn't interact directly with this module except to configure"
" it; instead it provides a service for other protocols in the kernel."
msgstr ""
"Этот модуль ядра реализует Address Resolution Protocol (протокол разрешения "
"адресов), определённый в RFC\\ 826. Протокол предназначен для преобразования "
"аппаратных адресов второго уровня (Layer2) в адреса протокола IPv4 в "
"соединённых напрямую сетях. Как правило, пользователю не приходится работать "
"с этим модулем непосредственно, исключая случаи его настройки — модуль "
"используется другими протоколами ядра."

#. type: Plain text
#: man-pages/man7/arp.7:37
msgid ""
"A user process can receive ARP packets by using B<packet>(7)  sockets.  "
"There is also a mechanism for managing the ARP cache in user-space by using "
"B<netlink>(7)  sockets.  The ARP table can also be controlled via "
"B<ioctl>(2)  on any B<AF_INET> socket."
msgstr ""
"Процесс пользователя может получать пакеты ARP через сокеты B<packet>(7). "
"Кроме того, существует механизм управления кэшем ARP из пространства "
"пользователя с помощью сокетов B<netlink>(7). Таблицей ARP также можно "
"управлять с помощью B<ioctl >(2) из произвольного сокета B<AF_INET>."

#. type: Plain text
#: man-pages/man7/arp.7:49
msgid ""
"The ARP module maintains a cache of mappings between hardware addresses and "
"protocol addresses.  The cache has a limited size so old and less frequently"
" used entries are garbage-collected.  Entries which are marked as permanent "
"are never deleted by the garbage-collector.  The cache can be directly "
"manipulated by the use of ioctls and its behavior can be tuned by the "
"I</proc> interfaces described below."
msgstr ""
"Модуль ARP поддерживает кэш отображения аппаратных адресов в протокольные "
"адреса. Размер кэша ограничен, поэтому старые и мало используемые записи "
"удаляются. Записи, помеченные как постоянные, не удаляются никогда. Кэшем "
"можно управлять непосредственно, с помощью ioctl-вызовов. Работа кэша может "
"быть настроена с помощью интерфейсов I</proc>, описанных ниже."

#. type: Plain text
#: man-pages/man7/arp.7:72
msgid ""
"When there is no positive feedback for an existing mapping after some time "
"(see the I</proc> interfaces below), a neighbor cache entry is considered "
"stale.  Positive feedback can be gotten from a higher layer; for example "
"from a successful TCP ACK.  Other protocols can signal forward progress "
"using the B<MSG_CONFIRM> flag to B<sendmsg>(2).  When there is no forward "
"progress, ARP tries to reprobe.  It first tries to ask a local arp daemon "
"B<app_solicit> times for an updated MAC address.  If that fails and an old "
"MAC address is known, a unicast probe is sent B<ucast_solicit> times.  If "
"that fails too, it will broadcast a new ARP request to the network.  "
"Requests are sent only when there is data queued for sending."
msgstr ""
"Если в течение некоторого времени (см. I</proc> интерфейсы ниже) не "
"подтверждается корректность (positive feedback) существующей записи кэша, то "
"она считается устаревшей. Подтверждение может быть получено от более высокого "
"уровня, например, при получении TCP ACK. Другие протоколы могут выполнить "
"подтверждение, используя флаг B<MSG_CONFIRM> при вызове B<sendmsg>(2). Если "
"подтверждения нет, то ARP пытается повторить запрос. Сначала он пытается "
"запросить обновлённый MAC-адрес у локальной службы arp B<app_solicit> раз. "
"Если получить адрес не удалось, а старый MAC-адрес известен, то посылается "
"адресный запрос B<ucast_solicit> раз. Если и после этого адрес определить не "
"удалось, то по сети посылается новый широковещательный ARP-запрос. Запросы "
"посылаются только при наличии данных в очереди для отправки."

#. type: Plain text
#: man-pages/man7/arp.7:77
msgid ""
"Linux will automatically add a nonpermanent proxy arp entry when it receives"
" a request for an address it forwards to and proxy arp is enabled on the "
"receiving interface.  When there is a reject route for the target, no proxy "
"arp entry is added."
msgstr ""
"Linux автоматически добавляет динамическую запись proxy arp, когда система "
"получает запрос адреса, для которого она производит пересылку и если proxy "
"arp включён на принимающем интерфейсе. При наличии маршрута отказа (reject "
"route) добавление proxy arp не производится."

#. type: SS
#: man-pages/man7/arp.7:77
#, no-wrap
msgid "Ioctls"
msgstr "Вызовы ioctl"

#. type: Plain text
#: man-pages/man7/arp.7:84
msgid ""
"Three ioctls are available on all B<AF_INET> sockets.  They take a pointer "
"to a I<struct arpreq> as their argument."
msgstr ""
"Для всех сокетов B<AF_INET> доступно три ioctl-вызова. В качестве параметра "
"ожидается указатель на структуру I<struct arpreq>."

#. type: Plain text
#: man-pages/man7/arp.7:94
#, no-wrap
msgid ""
"struct arpreq {\n"
"    struct sockaddr arp_pa;      /* protocol address */\n"
"    struct sockaddr arp_ha;      /* hardware address */\n"
"    int             arp_flags;   /* flags */\n"
"    struct sockaddr arp_netmask; /* netmask of protocol address */\n"
"    char            arp_dev[16];\n"
"};\n"
msgstr ""
"struct arpreq {\n    struct sockaddr arp_pa;      /* адрес протокола */\n    "
"struct sockaddr arp_ha;      /* аппаратный адрес */\n    int             "
"arp_flags;   /* флаги */\n    struct sockaddr arp_netmask; /* сетевая маска "
"адреса протокола */\n    char            arp_dev[16];\n};\n"

#. type: Plain text
#: man-pages/man7/arp.7:103
msgid ""
"B<SIOCSARP>, B<SIOCDARP> and B<SIOCGARP> respectively set, delete and get an"
" ARP mapping.  Setting and deleting ARP maps are privileged operations and "
"may be performed only by a process with the B<CAP_NET_ADMIN> capability or "
"an effective UID of 0."
msgstr ""
"Вызовы B<SIOCSARP>, B<SIOCDARP> и B<SIOCGARP> соответственно устанавливают, "
"удаляют и считывают отображение ARP. Для установки или удаления отображений "
"ARP процесс должен иметь мандат B<CAP_NET_ADMIN> или эффективный UID, равный "
"0."

#. type: Plain text
#: man-pages/man7/arp.7:113
msgid ""
"I<arp_pa> must be an B<AF_INET> address and I<arp_ha> must have the same "
"type as the device which is specified in I<arp_dev>.  I<arp_dev> is a zero-"
"terminated string which names a device."
msgstr ""
"Поле I<arp_pa> должно быть сокетом B<AF_INET>, а I<arp_ha> должно иметь тот "
"же тип, что и тип устройства, указанный в I<arp_dev>. Поле I<arp_dev> — "
"строка с именем устройства, оканчивающаяся нулем."

#. type: tbl table
#: man-pages/man7/arp.7:118
#, no-wrap
msgid "I<arp_flags>\n"
msgstr "I<arp_flags>\n"

#. type: tbl table
#: man-pages/man7/arp.7:119
#, no-wrap
msgid "flag:meaning\n"
msgstr "флаг:значение\n"

#. type: tbl table
#: man-pages/man7/arp.7:120
#, no-wrap
msgid "ATF_COM:Lookup complete\n"
msgstr "ATF_COM:Поиск окончен\n"

#. type: tbl table
#: man-pages/man7/arp.7:121
#, no-wrap
msgid "ATF_PERM:Permanent entry\n"
msgstr "ATF_PERM:Постоянная запись\n"

#. type: tbl table
#: man-pages/man7/arp.7:122
#, no-wrap
msgid "ATF_PUBL:Publish entry\n"
msgstr "ATF_PUBL:Анонсировать запись\n"

#. type: tbl table
#: man-pages/man7/arp.7:123
#, no-wrap
msgid "ATF_USETRAILERS:Trailers requested\n"
msgstr "ATF_USETRAILERS:Требуются Trailers\n"

#. type: tbl table
#: man-pages/man7/arp.7:124
#, no-wrap
msgid "ATF_NETMASK:Use a netmask\n"
msgstr "ATF_NETMASK:Использовать маску сети\n"

#. type: tbl table
#: man-pages/man7/arp.7:125
#, no-wrap
msgid "ATF_DONTPUB:Don't answer\n"
msgstr "ATF_DONTPUB:Не отвечать\n"

#. type: Plain text
#: man-pages/man7/arp.7:138
msgid ""
"If the B<ATF_NETMASK> flag is set, then I<arp_netmask> should be valid.  "
"Linux 2.2 does not support proxy network ARP entries, so this should be set "
"to 0xffffffff, or 0 to remove an existing proxy arp entry.  "
"B<ATF_USETRAILERS> is obsolete and should not be used."
msgstr ""
"Если установлен флаг B<ATF_NETMASK>, то должно быть указано корректное "
"значение I<arp_netmask>. Linux 2.2 не поддерживает сетевые записи proxy ARP, "
"поэтому для удаления существующих записей proxy arp это значение должно быть "
"равно 0xffffffff или 0. Флаг B<ATF_USETRAILERS> считается устаревшим и не "
"должен использоваться."

#. type: SS
#: man-pages/man7/arp.7:138
#, no-wrap
msgid "/proc interfaces"
msgstr "Интерфейсы /proc"

#. type: Plain text
#: man-pages/man7/arp.7:151
msgid ""
"ARP supports a range of I</proc> interfaces to configure parameters on a "
"global or per-interface basis.  The interfaces can be accessed by reading or"
" writing the I</proc/sys/net/ipv4/neigh/*/*> files.  Each interface in the "
"system has its own directory in I</proc/sys/net/ipv4/neigh/>.  The setting "
"in the \"default\" directory is used for all newly created devices.  Unless "
"otherwise specified, time-related interfaces are specified in seconds."
msgstr ""
"ARP поддерживает I</proc> интерфейсы для настройки общих параметров или "
"параметров конкретного сетевого интерфейса. Настройка осуществляется путём "
"чтения или записи файлов I</proc/sys/net/ipv4/neigh/*/*>. Для каждого "
"сетевого интерфейса в системе существует соответствующий каталог в I<"
"/proc/sys/net/ipv4/neigh/>. Настройки в каталоге «default» используются для "
"всех новых создаваемых устройств. Если не определено явно, то считается, что "
"время указывается в секундах."

#. type: TP
#: man-pages/man7/arp.7:151
#, no-wrap
msgid "I<anycast_delay> (since Linux 2.2)"
msgstr "I<anycast_delay> (начиная с Linux 2.2)"

#.  Precisely: 2.1.79
#. type: Plain text
#: man-pages/man7/arp.7:158
msgid ""
"The maximum number of jiffies to delay before replying to a IPv6 neighbor "
"solicitation message.  Anycast support is not yet implemented.  Defaults to "
"1 second."
msgstr ""
"Максимальное значение задержки в тиках (jiffies) до ответа на сообщение об "
"объявлении соседей (neighbor solicitation message) IPv6. Поддержка anycast "
"пока не реализована. Значение по умолчанию — 1 секунда."

#. type: TP
#: man-pages/man7/arp.7:158
#, no-wrap
msgid "I<app_solicit> (since Linux 2.2)"
msgstr "I<app_solicit> (начиная с Linux 2.2)"

#.  Precisely: 2.1.79
#. type: Plain text
#: man-pages/man7/arp.7:165
msgid ""
"The maximum number of probes to send to the user space ARP daemon via "
"netlink before dropping back to multicast probes (see I<mcast_solicit>).  "
"Defaults to 0."
msgstr ""
"Максимальное количество попыток послать запрос через сетевое соединение "
"(netlink) ARP-службе в пользовательском пространстве до возврата к "
"использованию многоадресных запросов (см. I<mcast_solicit>). Значение по "
"умолчанию — 0."

#. type: TP
#: man-pages/man7/arp.7:165
#, no-wrap
msgid "I<base_reachable_time> (since Linux 2.2)"
msgstr "I<base_reachable_time> (начиная с Linux 2.2)"

#.  Precisely: 2.1.79
#. type: Plain text
#: man-pages/man7/arp.7:176
msgid ""
"Once a neighbor has been found, the entry is considered to be valid for at "
"least a random value between I<base_reachable_time>/2 and "
"3*I<base_reachable_time>/2.  An entry's validity will be extended if it "
"receives positive feedback from higher level protocols.  Defaults to 30 "
"seconds.  This file is now obsolete in favor of I<base_reachable_time_ms>."
msgstr ""
"Если адрес был найден, то значение записи в диапазоне времени между I<"
"base_reachable_time>/2 и 3*I<base_reachable_time>/2 будет считаться не "
"устаревшим. Запись будет считаться правильной более длительное время, если "
"будет получено подтверждение от протоколов более высокого уровня. Значение по "
"умолчанию — 30 секунд."

#. type: TP
#: man-pages/man7/arp.7:176
#, no-wrap
msgid "I<base_reachable_time_ms> (since Linux 2.6.12)"
msgstr "I<base_reachable_time_ms> (начиная с Linux 2.6.12)"

#. type: Plain text
#: man-pages/man7/arp.7:182
msgid ""
"As for I<base_reachable_time>, but measures time in milliseconds.  Defaults "
"to 30000 milliseconds."
msgstr ""
"Тоже, что и I<base_reachable_time>, но время задаётся в миллисекундах. "
"Значение по умолчанию — 30000 миллисекунд."

#. type: TP
#: man-pages/man7/arp.7:182
#, no-wrap
msgid "I<delay_first_probe_time> (since Linux 2.2)"
msgstr "I<delay_first_probe_time> (начиная с Linux 2.2)"

#.  Precisely: 2.1.79
#. type: Plain text
#: man-pages/man7/arp.7:188
msgid ""
"Delay before first probe after it has been decided that a neighbor is stale."
"  Defaults to 5 seconds."
msgstr ""
"Задержка до первого запроса после того, как запись стала считаться "
"устаревшей. Значение по умолчанию — 5 секунд."

#. type: TP
#: man-pages/man7/arp.7:188
#, no-wrap
msgid "I<gc_interval> (since Linux 2.2)"
msgstr "I<gc_interval> (начиная с Linux 2.2)"

#.  Precisely: 2.1.79
#. type: Plain text
#: man-pages/man7/arp.7:194
msgid ""
"How frequently the garbage collector for neighbor entries should attempt to "
"run.  Defaults to 30 seconds."
msgstr ""
"Частота очистки кэша от устаревших и некорректных записей. Значение по "
"умолчанию — 30 секунд."

#. type: TP
#: man-pages/man7/arp.7:194
#, no-wrap
msgid "I<gc_stale_time> (since Linux 2.2)"
msgstr "I<gc_stale_time> (начиная с Linux 2.2)"

#.  Precisely: 2.1.79
#. type: Plain text
#: man-pages/man7/arp.7:201
msgid ""
"Determines how often to check for stale neighbor entries.  When a neighbor "
"entry is considered stale, it is resolved again before sending data to it.  "
"Defaults to 60 seconds."
msgstr ""
"Частота проверки наличия устаревших записей. Если запись считается "
"устаревшей, то перед тем, как данные будут посланы, адрес снова проверяется. "
"Значение по умолчанию — 60 секунд."

#. type: TP
#: man-pages/man7/arp.7:201
#, no-wrap
msgid "I<gc_thresh1> (since Linux 2.2)"
msgstr "I<gc_thresh1> (начиная с Linux 2.2)"

#.  Precisely: 2.1.79
#. type: Plain text
#: man-pages/man7/arp.7:208
msgid ""
"The minimum number of entries to keep in the ARP cache.  The garbage "
"collector will not run if there are fewer than this number of entries in the"
" cache.  Defaults to 128."
msgstr ""
"Минимальное количество записей, хранимых в кэше ARP. Если количество записей "
"меньше этого значения, то очистка кэша производится не будет. Значение по "
"умолчанию — 128."

#. type: TP
#: man-pages/man7/arp.7:208
#, no-wrap
msgid "I<gc_thresh2> (since Linux 2.2)"
msgstr "I<gc_thresh2> (начиная с Linux 2.2)"

#.  Precisely: 2.1.79
#. type: Plain text
#: man-pages/man7/arp.7:215
msgid ""
"The soft maximum number of entries to keep in the ARP cache.  The garbage "
"collector will allow the number of entries to exceed this for 5 seconds "
"before collection will be performed.  Defaults to 512."
msgstr ""
"Мягкое ограничение максимального количества записей в кэше ARP. Если это "
"значение будет превышено более, чем на 5 секунд, то будет произведена очистка "
"кэша. Значение по умолчанию — 512."

#. type: TP
#: man-pages/man7/arp.7:215
#, no-wrap
msgid "I<gc_thresh3> (since Linux 2.2)"
msgstr "I<gc_thresh3> (начиная с Linux 2.2)"

#.  Precisely: 2.1.79
#. type: Plain text
#: man-pages/man7/arp.7:222
msgid ""
"The hard maximum number of entries to keep in the ARP cache.  The garbage "
"collector will always run if there are more than this number of entries in "
"the cache.  Defaults to 1024."
msgstr ""
"Жёсткое ограничение количества записей в кэше ARP. Если это значение будет "
"превышено, то будет произведена очистка кэша. Значение по умолчанию — 1024."

#. type: TP
#: man-pages/man7/arp.7:222
#, no-wrap
msgid "I<locktime> (since Linux 2.2)"
msgstr "I<locktime> (начиная с Linux 2.2)"

#.  Precisely: 2.1.79
#. type: Plain text
#: man-pages/man7/arp.7:229
msgid ""
"The minimum number of jiffies to keep an ARP entry in the cache.  This "
"prevents ARP cache thrashing if there is more than one potential mapping "
"(generally due to network misconfiguration).  Defaults to 1 second."
msgstr ""
"Минимальное время хранения записи в кэше в тиках. Предотвращает замусоривание "
"кэша при наличии более одного возможного отображения (в общем случае, из-за "
"неправильной настройки сети). Значение по умолчанию — 1 секунда."

#. type: TP
#: man-pages/man7/arp.7:229
#, no-wrap
msgid "I<mcast_solicit> (since Linux 2.2)"
msgstr "I<mcast_solicit> (начиная с Linux 2.2)"

#.  Precisely: 2.1.79
#. type: Plain text
#: man-pages/man7/arp.7:235
msgid ""
"The maximum number of attempts to resolve an address by multicast/broadcast "
"before marking the entry as unreachable.  Defaults to 3."
msgstr ""
"Максимальное количество попыток определить адрес с помощью "
"многоадресной/широковещательной передачи. Если адрес не будет обнаружен, то "
"он будет помечен как недоступный. Значение по умолчанию — 3."

#. type: TP
#: man-pages/man7/arp.7:235
#, no-wrap
msgid "I<proxy_delay> (since Linux 2.2)"
msgstr "I<proxy_delay> (начиная с Linux 2.2)"

#.  Precisely: 2.1.79
#. type: Plain text
#: man-pages/man7/arp.7:243
msgid ""
"When an ARP request for a known proxy-ARP address is received, delay up to "
"I<proxy_delay> jiffies before replying.  This is used to prevent network "
"flooding in some cases.  Defaults to 0.8 seconds."
msgstr ""
"Задержка до I<proxy_delay> тиков между получением ARP-запроса на известный "
"proxy ARP-адрес и ответом. Предназначена для предотвращения перегрузки сети. "
"Значение по умолчанию — 0.8 секунды."

#. type: TP
#: man-pages/man7/arp.7:243
#, no-wrap
msgid "I<proxy_qlen> (since Linux 2.2)"
msgstr "I<proxy_qlen> (начиная с Linux 2.2)"

#.  Precisely: 2.1.79
#. type: Plain text
#: man-pages/man7/arp.7:248
msgid ""
"The maximum number of packets which may be queued to proxy-ARP addresses.  "
"Defaults to 64."
msgstr ""
"Максимальное количество пакетов для адресов proxy ARP, которые могут быть "
"отправлены в очередь . Значение по умолчанию — 64."

#. type: TP
#: man-pages/man7/arp.7:248
#, no-wrap
msgid "I<retrans_time> (since Linux 2.2)"
msgstr "I<retrans_time> (начиная с Linux 2.2)"

#.  Precisely: 2.1.79
#. type: Plain text
#: man-pages/man7/arp.7:255
msgid ""
"The number of jiffies to delay before retransmitting a request.  Defaults to"
" 1 second.  This file is now obsolete in favor of I<retrans_time_ms>."
msgstr ""
"Задержка перед повторением запроса в тиках. Значение по умолчанию — 1 "
"секунда. Этот файл устарел, используйте I<retrans_time_ms>."

#. type: TP
#: man-pages/man7/arp.7:255
#, no-wrap
msgid "I<retrans_time_ms> (since Linux 2.6.12)"
msgstr "I<retrans_time_ms> (начиная с Linux 2.6.12)"

#. type: Plain text
#: man-pages/man7/arp.7:259
msgid ""
"The number of milliseconds to delay before retransmitting a request.  "
"Defaults to 1000 milliseconds."
msgstr ""
"Задержка перед повторением запроса в миллисекундах. Значение по умолчанию — "
"1000 миллисекунд."

#. type: TP
#: man-pages/man7/arp.7:259
#, no-wrap
msgid "I<ucast_solicit> (since Linux 2.2)"
msgstr "I<ucast_solicit> (начиная с Linux 2.2)"

#.  Precisely: 2.1.79
#. type: Plain text
#: man-pages/man7/arp.7:266
msgid ""
"The maximum number of attempts to send unicast probes before asking the ARP "
"daemon (see I<app_solicit>).  Defaults to 3."
msgstr ""
"Максимальное количество попыток послать адресный запрос перед запросом службы "
"ARP (см. I<app_solicit>). Значение по умолчанию — 3."

#. type: TP
#: man-pages/man7/arp.7:266
#, no-wrap
msgid "I<unres_qlen> (since Linux 2.2)"
msgstr "I<unres_qlen> (начиная с Linux 2.2)"

#.  Precisely: 2.1.79
#. type: Plain text
#: man-pages/man7/arp.7:272
msgid ""
"The maximum number of packets which may be queued for each unresolved "
"address by other network layers.  Defaults to 3."
msgstr ""
"Максимальное количество пакетов, которые могут быть поставлены в очередь "
"протоколами других сетевых уровней для передачи по каждому неопределённому "
"адресу. Значение по умолчанию — 3."

#. type: Plain text
#: man-pages/man7/arp.7:279
msgid ""
"The I<struct arpreq> changed in Linux 2.0 to include the I<arp_dev> member "
"and the ioctl numbers changed at the same time.  Support for the old ioctls "
"was dropped in Linux 2.2."
msgstr ""
"В Linux 2.0 в структуру I<struct arpreq> было включено поле I<arp_dev> и "
"изменены номера ioctl. Старые ioctl были удалены в Linux 2.2."

#. type: Plain text
#: man-pages/man7/arp.7:285
msgid ""
"Support for proxy arp entries for networks (netmask not equal 0xffffffff)  "
"was dropped in Linux 2.2.  It is replaced by automatic proxy arp setup by "
"the kernel for all reachable hosts on other interfaces (when forwarding and "
"proxy arp is enabled for the interface)."
msgstr ""
"Поддержка записей proxy arp для сетей (маска сети не равна 0xffffffff) "
"удалена в Linux 2.2. Вместо этого было реализовано автоматическое определение "
"ядром всех доступных узлов через другие интерфейсы (если на интерфейсе "
"включена пересылка и proxy arp)."

#. type: Plain text
#: man-pages/man7/arp.7:289
msgid "The I<neigh/*> interfaces did not exist before Linux 2.2."
msgstr "Интерфейсы I<neigh/*> не существовали до версии Linux 2.2."

#. type: SH
#: man-pages/man7/arp.7:289
#, no-wrap
msgid "BUGS"
msgstr "ДЕФЕКТЫ"

#. type: Plain text
#: man-pages/man7/arp.7:293
msgid ""
"Some timer settings are specified in jiffies, which is architecture- and "
"kernel version-dependent; see B<time>(7)."
msgstr ""
"Значения некоторых настроек указаны в тиках, длительность которых зависит от "
"архитектуры компьютера и версии ядра; смотрите B<time>(7)."

#. type: Plain text
#: man-pages/man7/arp.7:299
msgid ""
"There is no way to signal positive feedback from user space.  This means "
"connection-oriented protocols implemented in user space will generate "
"excessive ARP traffic, because ndisc will regularly reprobe the MAC address."
"  The same problem applies for some kernel protocols (e.g., NFS over UDP)."
msgstr ""
"Не существует способа отправить подтверждение из пользовательского "
"пространства. Это означает, что протоколы, ориентированные на соединения и "
"реализованные в пользовательском пространстве, будут создавать избыточный "
"ARP-трафик, так как ndisc будет вновь и вновь запрашивать MAC-адрес. То же "
"относится и к некоторым протоколам ядра (например, NFS через UDP)."

#. type: Plain text
#: man-pages/man7/arp.7:302
msgid ""
"This man page mashes together functionality that is IPv4-specific with "
"functionality that is shared between IPv4 and IPv6."
msgstr ""
"В этой странице дано описание возможностей IPv4, а также общих возможностей "
"IPv4 и IPv6."

#. type: Plain text
#: man-pages/man7/arp.7:305
msgid "B<capabilities>(7), B<ip>(7)"
msgstr "B<capabilities>(7), B<ip>(7)"

#. type: Plain text
#: man-pages/man7/arp.7:309
msgid ""
"RFC\\ 826 for a description of ARP.  RFC\\ 2461 for a description of IPv6 "
"neighbor discovery and the base algorithms used.  Linux 2.2+ IPv4 ARP uses "
"the IPv6 algorithms when applicable."
msgstr ""
"Описание ARP приведено в RFC\\ 826. Определение соседних машин согласно IPv6 "
"и основные используемые алгоритмы приведены в RFC\\ 2461. В Linux 2.2+ IPv4 "
"ARP используются алгоритмы IPv6 (если это возможно)."

#. type: TH
#: man-pages/man2/adjtimex.2:37
#, no-wrap
msgid "ADJTIMEX"
msgstr "ADJTIMEX"

#. type: TH
#: man-pages/man2/adjtimex.2:37
#, no-wrap
msgid "2014-05-28"
msgstr "2014-05-28"

#. type: Plain text
#: man-pages/man2/adjtimex.2:40
msgid "adjtimex - tune kernel clock"
msgstr "adjtimex - тонкая настройка часов в ядре"

#. type: SH
#: man-pages/man2/adjtimex.2:40
#, no-wrap
msgid "SYNOPSIS"
msgstr "ОБЗОР"

#. type: Plain text
#: man-pages/man2/adjtimex.2:44
#, no-wrap
msgid ""
"B<#define _BSD_SOURCE>      /* See feature_test_macros(7) */\n"
"B<#include E<lt>sys/timex.hE<gt>>\n"
msgstr ""
"B<#define _BSD_SOURCE>      /* Смотрите feature_test_macros(7) */\nB<#include "
"E<lt>sys/timex.hE<gt>>\n"

#. type: Plain text
#: man-pages/man2/adjtimex.2:46
#, no-wrap
msgid "B<int adjtimex(struct timex *>I<buf>B<);>\n"
msgstr "B<int adjtimex(struct timex *>I<buf>B<);>\n"

#. type: Plain text
#: man-pages/man2/adjtimex.2:57
msgid ""
"Linux uses David L. Mills' clock adjustment algorithm (see RFC\\ 1305).  The"
" system call B<adjtimex>()  reads and optionally sets adjustment parameters "
"for this algorithm.  It takes a pointer to a I<timex> structure, updates "
"kernel parameters from field values, and returns the same structure with "
"current kernel values.  This structure is declared as follows:"
msgstr ""
"В Linux для подстройки часов используется алгоритм Дэвида Л. Миллса (David L. "
"Mills) (см. RFC\\ 1305). Системный вызов B<adjtimex>() читает и "
"(необязательно) устанавливает параметры подстройки для этого алгоритма. В "
"качестве аргумента используется указатель на структуру I<timex>, по значениям "
"в полях которой осуществляется обновление параметров ядра и в этой же "
"структуре происходит возврат текущих значений параметров ядра. Данная "
"структура объявлена так:"

#.  FIXME -- what is the scaling unit?  2^16 ?
#. type: Plain text
#: man-pages/man2/adjtimex.2:75
#, no-wrap
msgid ""
"struct timex {\n"
"    int modes;           /* mode selector */\n"
"    long offset;         /* time offset (usec) */\n"
"    long freq;           /* frequency offset (scaled ppm) */\n"
"    long maxerror;       /* maximum error (usec) */\n"
"    long esterror;       /* estimated error (usec) */\n"
"    int status;          /* clock command/status */\n"
"    long constant;       /* pll time constant */\n"
"    long precision;      /* clock precision (usec) (read-only) */\n"
"    long tolerance;      /* clock frequency tolerance (ppm)\n"
"                            (read-only) */\n"
"    struct timeval time; /* current time (read-only) */\n"
"    long tick;           /* usecs between clock ticks */\n"
"};\n"
msgstr ""
"struct timex {\n    int modes;           /* выбор режима */\n    long offset; "
"        /* смещение по времени (usec) */\n    long freq;           /* частота "
"смещения (scaled ppm) */\n    long maxerror;       /* максимальная ошибка "
"(usec) */\n    long esterror;       /* ожидаемая ошибка (usec) */\n    int "
"status;          /* команда/состояние для часов */\n    long constant;       "
"/* временная константа pll */\n    long precision;      /* точность часов "
"(usec) (только чтение) */\n    long tolerance;      /* clock frequency "
"tolerance (ppm)\n                            (read-only) */\n    struct "
"timeval time; /* текущее время (только чтение) */\n    long tick;           "
"/* usecs between clock ticks */\n};\n"

#. type: Plain text
#: man-pages/man2/adjtimex.2:84
msgid ""
"The I<modes> field determines which parameters, if any, to set.  It may "
"contain a bitwise-I<or> combination of zero or more of the following bits:"
msgstr ""
"Поле I<modes> определяет какие параметры, если это необходимо, "
"устанавливаются.  Значение поля может содержать комбинации (I<or>) битовых "
"масок, значения которых следующие:"

#. type: Plain text
#: man-pages/man2/adjtimex.2:95
#, no-wrap
msgid ""
"#define ADJ_OFFSET            0x0001 /* time offset */\n"
"#define ADJ_FREQUENCY         0x0002 /* frequency offset */\n"
"#define ADJ_MAXERROR          0x0004 /* maximum time error */\n"
"#define ADJ_ESTERROR          0x0008 /* estimated time error */\n"
"#define ADJ_STATUS            0x0010 /* clock status */\n"
"#define ADJ_TIMECONST         0x0020 /* pll time constant */\n"
"#define ADJ_TICK              0x4000 /* tick value */\n"
"#define ADJ_OFFSET_SINGLESHOT 0x8001 /* old-fashioned adjtime() */\n"
msgstr ""
"#define ADJ_OFFSET            0x0001 /* смещение времени */\n#define "
"ADJ_FREQUENCY         0x0002 /* частота смещения */\n#define ADJ_MAXERROR     "
"     0x0004 /* максимальная ошибка времени */\n#define ADJ_ESTERROR          "
"0x0008 /* ожидаемая ошибка времени */\n#define ADJ_STATUS            0x0010 "
"/* состояние часов */\n#define ADJ_TIMECONST         0x0020 /* временная "
"константа pll */\n#define ADJ_TICK              0x4000 /* значение тика "
"*/\n#define ADJ_OFFSET_SINGLESHOT 0x8001 /* old-fashioned adjtime() */\n"

#. type: Plain text
#: man-pages/man2/adjtimex.2:101
msgid ""
"Ordinary users are restricted to a zero value for I<modes>.  Only the "
"superuser may set any parameters."
msgstr ""
"Обычные пользователи могут писать в I<mode> только ноль. Только "
"суперпользователь может задавать любые параметры."

#. type: SH
#: man-pages/man2/adjtimex.2:103
#, no-wrap
msgid "RETURN VALUE"
msgstr "ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ"

#. type: Plain text
#: man-pages/man2/adjtimex.2:107
msgid "On success, B<adjtimex>()  returns the clock state:"
msgstr "В случае успеха, B<adjtimex>() возвращает состояние часов:"

#. type: Plain text
#: man-pages/man2/adjtimex.2:116
#, no-wrap
msgid ""
"#define TIME_OK   0 /* clock synchronized */\n"
"#define TIME_INS  1 /* insert leap second */\n"
"#define TIME_DEL  2 /* delete leap second */\n"
"#define TIME_OOP  3 /* leap second in progress */\n"
"#define TIME_WAIT 4 /* leap second has occurred */\n"
"#define TIME_BAD  5 /* clock not synchronized */\n"
msgstr ""
"#define TIME_OK   0 /* часы синхронизированы */\n#define TIME_INS  1 /* "
"вставлена високосная секунда */\n#define TIME_DEL  2 /* удалена високосная "
"секунда */\n#define TIME_OOP  3 /* идёт високосная секунда */\n#define "
"TIME_WAIT 4 /* закончилась високосная секунда */\n#define TIME_BAD  5 /* часы "
"не синхронизированы */\n"

#. type: Plain text
#: man-pages/man2/adjtimex.2:123
msgid "On failure, B<adjtimex>()  returns -1 and sets I<errno>."
msgstr ""
"В случае неудачи, B<adjtimex>() возвращает -1 и устанавливает I<errno>."

#. type: TP
#: man-pages/man2/adjtimex.2:124
#, no-wrap
msgid "B<EFAULT>"
msgstr "B<EFAULT>"

#. type: Plain text
#: man-pages/man2/adjtimex.2:128
msgid "I<buf> does not point to writable memory."
msgstr "I<buf> не является указателем на доступную для записи область памяти."

#. type: Plain text
#: man-pages/man2/adjtimex.2:145
msgid ""
"An attempt is made to set I<buf.offset> to a value outside the range -131071"
" to +131071, or to set I<buf.status> to a value other than those listed "
"above, or to set I<buf.tick> to a value outside the range 900000/B<HZ> to "
"1100000/B<HZ>, where B<HZ> is the system timer interrupt frequency."
msgstr ""
"Попытка установить I<buf.offset> в значение, выходящее за диапазон от -131071 "
"до +131071, или установить I<buf.status> в значение отличное от перечисленных "
"выше, или установить I<buf.tick> в значение за пределами диапазона от "
"900000/B<HZ> до 1100000/B<HZ>, где B<HZ> \\(em частота прерываний системного "
"таймера."

#. type: TP
#: man-pages/man2/adjtimex.2:145
#, no-wrap
msgid "B<EPERM>"
msgstr "B<EPERM>"

#. type: Plain text
#: man-pages/man2/adjtimex.2:152
msgid ""
"I<buf.modes> is nonzero and the caller does not have sufficient privilege.  "
"Under Linux the B<CAP_SYS_TIME> capability is required."
msgstr ""
"Значение I<buf.mode> не равно нулю и вызвавший процесс не имеет необходимых "
"прав. В Linux для этого требуется мандат B<CAP_SYS_TIME>."

#. type: Plain text
#: man-pages/man2/adjtimex.2:160
msgid ""
"B<adjtimex>()  is Linux-specific and should not be used in programs intended"
" to be portable.  See B<adjtime>(3)  for a more portable, but less flexible,"
" method of adjusting the system clock."
msgstr ""
"B<adjtimex>() \\(em это специфичный для Linux системный вызов и он не должен "
"использоваться в программах, которые должны быть переносимыми. Существует "
"похожий, более переносимый, более гибкий метод настройки системных часов B<"
"adjtime>(3)."

#. type: Plain text
#: man-pages/man2/adjtimex.2:165
msgid ""
"B<settimeofday>(2), B<adjtime>(3), B<capabilities>(7), B<time>(7), "
"B<adjtimex>(8)"
msgstr ""
"B<settimeofday>(2), B<adjtime>(3), B<capabilities>(7), B<time>(7), B<adjtimex>"
"(8)"

#. type: TH
#: man-pages/man2/accept.2:41
#, no-wrap
msgid "ACCEPT"
msgstr "ACCEPT"

#. type: TH
#: man-pages/man2/accept.2:41
#, no-wrap
msgid "2010-09-10"
msgstr "2010-09-10"

#. type: Plain text
#: man-pages/man2/accept.2:44
msgid "accept, accept4 - accept a connection on a socket"
msgstr "accept, accept4 - принять соединение на сокете"

#. type: Plain text
#: man-pages/man2/accept.2:48
#, no-wrap
msgid ""
"B<#include E<lt>sys/types.hE<gt>>          /* See NOTES */\n"
"B<#include E<lt>sys/socket.hE<gt>>\n"
msgstr ""
"B<#include E<lt>sys/types.hE<gt>>          /* См. ЗАМЕЧАНИЯ */\nB<#include E<"
"lt>sys/socket.hE<gt>>\n"

#. type: Plain text
#: man-pages/man2/accept.2:50
#, no-wrap
msgid ""
"B<int accept(int >I<sockfd>B<, struct sockaddr *>I<addr>B<, socklen_t "
"*>I<addrlen>B<);>\n"
msgstr ""
"B<int accept(int >I<sockfd>B<, struct sockaddr *>I<addr>B<, socklen_t *>I<"
"addrlen>B<);>\n"

#. type: Plain text
#: man-pages/man2/accept.2:53
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>             /* See feature_test_macros(7) */\n"
"B<#include E<lt>sys/socket.hE<gt>>\n"
msgstr ""
"B<#define _GNU_SOURCE>             /* Смотрите feature_test_macros(7) */\nB<"
"#include E<lt>sys/socket.hE<gt>>\n"

#. type: Plain text
#: man-pages/man2/accept.2:56
#, no-wrap
msgid ""
"B<int accept4(int >I<sockfd>B<, struct sockaddr *>I<addr>B<,>\n"
"B<            socklen_t *>I<addrlen>B<, int >I<flags>B<);>\n"
msgstr ""
"B<int accept4(int >I<sockfd>B<, struct sockaddr *>I<addr>B<,>\nB<            "
"socklen_t *>I<addrlen>B<, int >I<flags>B<);>\n"

#. type: Plain text
#: man-pages/man2/accept.2:72
msgid ""
"The B<accept>()  system call is used with connection-based socket types "
"(B<SOCK_STREAM>, B<SOCK_SEQPACKET>).  It extracts the first connection "
"request on the queue of pending connections for the listening socket, "
"I<sockfd>, creates a new connected socket, and returns a new file descriptor"
" referring to that socket.  The newly created socket is not in the listening"
" state.  The original socket I<sockfd> is unaffected by this call."
msgstr ""
"Системный вызов B<accept>() используется с сокетами, ориентированными на "
"установление соединения (B<SOCK_STREAM>, B<SOCK_SEQPACKET>). Она извлекает "
"первый запрос на соединение из очереди ожидающих соединений прослушивающего "
"сокета, I<sockfd>, создаёт новый подключенный сокет и и возвращает новый "
"файловый дескриптор, указывающий на сокет. Новый сокет более не находится в "
"слушающем состоянии. Исходный сокет I<sockfd> не изменяется при этом вызове."

#. type: Plain text
#: man-pages/man2/accept.2:81
msgid ""
"The argument I<sockfd> is a socket that has been created with B<socket>(2), "
"bound to a local address with B<bind>(2), and is listening for connections "
"after a B<listen>(2)."
msgstr ""
"Аргумент I<sockfd> \\(em это сокет, который был создан с помощью B<socket>"
"(2), привязанный к локальному адресу с помощью B<bind>(2), и прослушивающий "
"соединения после B<listen>(2)."

#. type: Plain text
#: man-pages/man2/accept.2:99
msgid ""
"The argument I<addr> is a pointer to a I<sockaddr> structure.  This "
"structure is filled in with the address of the peer socket, as known to the "
"communications layer.  The exact format of the address returned I<addr> is "
"determined by the socket's address family (see B<socket>(2)  and the "
"respective protocol man pages).  When I<addr> is NULL, nothing is filled in;"
" in this case, I<addrlen> is not used, and should also be NULL."
msgstr ""
"Аргумент I<addr> \\(em это указатель на структуру I<sockaddr>. В эту "
"структуру помещается адрес ответной стороны в том виде, в каком он известен "
"на коммуникационном уровне. Точный формат адреса, возвращаемого в параметре "
"I<addr>, определяется семейством адресов сокета (см. B<socket>(2) и "
"справочную страницу по соответствующему протоколу). Если I<addr> равен NULL, "
"то ничего не помещается; в этом случае I<addrlen> не используется и также "
"должен быть NULL."

#. type: Plain text
#: man-pages/man2/accept.2:107
msgid ""
"The I<addrlen> argument is a value-result argument: the caller must "
"initialize it to contain the size (in bytes) of the structure pointed to by "
"I<addr>; on return it will contain the actual size of the peer address."
msgstr ""
"Через аргумент I<addrlen> осуществляется возврат результата: вызывающая "
"сторона должна указать в нём размер (в байтах) структуры, на которую "
"указывает I<addr>; при возврате он будет содержать реальный размер адреса "
"ответной стороны."

#. type: Plain text
#: man-pages/man2/accept.2:112
msgid ""
"The returned address is truncated if the buffer provided is too small; in "
"this case, I<addrlen> will return a value greater than was supplied to the "
"call."
msgstr ""
"Возвращаемый адрес обрезается, если предоставленный буфер окажется слишком "
"маленьким; в этом случае в I<addrlen> будет возвращено значение большее чем "
"было в вызове."

#. type: Plain text
#: man-pages/man2/accept.2:125
msgid ""
"If no pending connections are present on the queue, and the socket is not "
"marked as nonblocking, B<accept>()  blocks the caller until a connection is "
"present.  If the socket is marked nonblocking and no pending connections are"
" present on the queue, B<accept>()  fails with the error B<EAGAIN> or "
"B<EWOULDBLOCK>."
msgstr ""
"Если в очереди нет ожидающих запросов на соединение, и на сокет не помечен "
"как неблокирующий, то B<accept>() заблокирует вызвавшую программу до "
"появления соединения. Если сокет помечен как неблокирующий, а в очереди нет "
"запросов на соединение, то B<accept>() завершится с ошибкой B<EAGAIN> или B<"
"EWOULDBLOCK>."

#. type: Plain text
#: man-pages/man2/accept.2:139
msgid ""
"In order to be notified of incoming connections on a socket, you can use "
"B<select>(2)  or B<poll>(2).  A readable event will be delivered when a new "
"connection is attempted and you may then call B<accept>()  to get a socket "
"for that connection.  Alternatively, you can set the socket to deliver "
"B<SIGIO> when activity occurs on a socket; see B<socket>(7)  for details."
msgstr ""
"Для того, чтобы получать уведомления о входящих соединениях на сокете, можно "
"использовать B<select>(2) или B<poll>(2). В этом случае, когда придёт запрос "
"на новое соединение, будет доставлено событие \"можно читать\", и после этого "
"вы можете вызвать B<accept>() чтобы получить сокет для этого соединения. "
"Можно также настроить сокет так, чтобы он посылал сигнал B<SIGIO>, когда на "
"нём происходит какая-либо активность; см. B<socket>(7)."

#. type: Plain text
#: man-pages/man2/accept.2:152
msgid ""
"For certain protocols which require an explicit confirmation, such as "
"DECNet, B<accept>()  can be thought of as merely dequeuing the next "
"connection request and not implying confirmation.  Confirmation can be "
"implied by a normal read or write on the new file descriptor, and rejection "
"can be implied by closing the new socket.  Currently only DECNet has these "
"semantics on Linux."
msgstr ""
"Для определённых протоколов, которые требуют явного подтверждения, например, "
"DECNet, B<accept>() можно рассматривать просто как извлечение из очереди "
"следующего запроса на соединение, не подразумевающее подтверждение. "
"Подтверждение, в свою очередь, произойдет при следующем чтении или записи в "
"новом файловом дескрипторе, а отказ от соединения может произойти при "
"закрытии нового сокета. В настоящее время, под Linux такую семантику имеет "
"только DECNet."

#. type: Plain text
#: man-pages/man2/accept.2:162
msgid ""
"If I<flags> is 0, then B<accept4>()  is the same as B<accept>().  The "
"following values can be bitwise ORed in I<flags> to obtain different "
"behavior:"
msgstr ""
"Если I<flags> равно 0, то вызов B<accept4>() равнозначен B<accept>(). "
"Следующие значения могут быть побитово сложены в I<flags> для получения "
"различного поведения:"

#. type: TP
#: man-pages/man2/accept.2:162
#, no-wrap
msgid "B<SOCK_NONBLOCK>"
msgstr "B<SOCK_NONBLOCK>"

#. type: Plain text
#: man-pages/man2/accept.2:170
msgid ""
"Set the B<O_NONBLOCK> file status flag on the new open file description.  "
"Using this flag saves extra calls to B<fcntl>(2)  to achieve the same "
"result."
msgstr ""
"Устанавливает флаг состояния файла B<O_NONBLOCK> для нового открытого "
"файлового дескриптора. Использование данного флага заменяет дополнительные "
"вызовы B<fcntl>(2) для достижения того же результата."

#. type: TP
#: man-pages/man2/accept.2:170
#, no-wrap
msgid "B<SOCK_CLOEXEC>"
msgstr "B<SOCK_CLOEXEC>"

#. type: Plain text
#: man-pages/man2/accept.2:180
msgid ""
"Set the close-on-exec (B<FD_CLOEXEC>)  flag on the new file descriptor.  See"
" the description of the B<O_CLOEXEC> flag in B<open>(2)  for reasons why "
"this may be useful."
msgstr ""
"Устанавливает флаг close-on-exec (B<FD_CLOEXEC>) для нового открытого "
"файлового дескриптора. Смотрите описание флага B<O_CLOEXEC> в B<open>(2) для "
"того, чтобы узнать как это может пригодиться."

#. type: Plain text
#: man-pages/man2/accept.2:187
msgid ""
"On success, these system calls return a nonnegative integer that is a "
"descriptor for the accepted socket.  On error, -1 is returned, and I<errno> "
"is set appropriately."
msgstr ""
"При успешном выполнении данные системные вызовы возвращают неотрицательное "
"целое, являющееся дескриптором принятого сокета. В случае ошибки возвращается "
"-1, а I<errno> устанавливается в соответствующее значение."

#. type: SS
#: man-pages/man2/accept.2:187
#, no-wrap
msgid "Error handling"
msgstr "Обработка ошибок"

#. type: Plain text
#: man-pages/man2/accept.2:214
msgid ""
"Linux B<accept>()  (and B<accept4>())  passes already-pending network errors"
" on the new socket as an error code from B<accept>().  This behavior differs"
" from other BSD socket implementations.  For reliable operation the "
"application should detect the network errors defined for the protocol after "
"B<accept>()  and treat them like B<EAGAIN> by retrying.  In the case of "
"TCP/IP, these are B<ENETDOWN>, B<EPROTO>, B<ENOPROTOOPT>, B<EHOSTDOWN>, "
"B<ENONET>, B<EHOSTUNREACH>, B<EOPNOTSUPP>, and B<ENETUNREACH>."
msgstr ""
"В реализации Linux B<accept>() (и B<accept4>()) передаёт уже ожидающие "
"сетевые ошибки на новый сокет, как код ошибки из вызова B<accept>(). Это "
"поведение отличается от других реализаций BSD-сокетов. Для надёжной работы "
"приложения должны отслеживать сетевые ошибки, которые могут появиться при "
"работе с протоколом B<accept>() и обрабатывать их как B<EAGAIN> повторно "
"выполняя вызов. В случае TCP/IP такими ошибками являются B<ENETDOWN>, B<"
"EPROTO>, B<ENOPROTOOPT>, B<EHOSTDOWN>, B<ENONET>, B<EHOSTUNREACH>, B<"
"EOPNOTSUPP> и B<ENETUNREACH>."

#. type: TP
#: man-pages/man2/accept.2:215
#, no-wrap
msgid "B<EAGAIN> or B<EWOULDBLOCK>"
msgstr "B<EAGAIN> или B<EWOULDBLOCK>"

#.  Actually EAGAIN on Linux
#. type: Plain text
#: man-pages/man2/accept.2:223
msgid ""
"The socket is marked nonblocking and no connections are present to be "
"accepted.  POSIX.1-2001 allows either error to be returned for this case, "
"and does not require these constants to have the same value, so a portable "
"application should check for both possibilities."
msgstr ""
"Сокет помечен как неблокирующий и нет ни одного соединения, которое можно "
"было бы принять. POSIX.1-2001 допускает в этих случаях возврат ошибки и не "
"требует, чтобы эти константы имели одинаковое значение, поэтому переносимое "
"приложение должно проверять обе возможности."

#. type: TP
#: man-pages/man2/accept.2:223
#, no-wrap
msgid "B<EBADF>"
msgstr "B<EBADF>"

#. type: Plain text
#: man-pages/man2/accept.2:226
msgid "The descriptor is invalid."
msgstr "Неправильный дескриптор."

#. type: TP
#: man-pages/man2/accept.2:226
#, no-wrap
msgid "B<ECONNABORTED>"
msgstr "B<ECONNABORTED>"

#. type: Plain text
#: man-pages/man2/accept.2:229
msgid "A connection has been aborted."
msgstr "Соединение было прервано."

#. type: Plain text
#: man-pages/man2/accept.2:234
msgid ""
"The I<addr> argument is not in a writable part of the user address space."
msgstr ""
"Аргумент I<addr> не находится в пользовательском пространстве адресов с "
"возможностью записи."

#. type: TP
#: man-pages/man2/accept.2:234
#, no-wrap
msgid "B<EINTR>"
msgstr "B<EINTR>"

#. type: Plain text
#: man-pages/man2/accept.2:239
msgid ""
"The system call was interrupted by a signal that was caught before a valid "
"connection arrived; see B<signal>(7)."
msgstr ""
"Системный вызов прервал сигналом, который поступил до момента прихода "
"допустимого соединения; см. B<signal>(7)."

#. type: Plain text
#: man-pages/man2/accept.2:244
msgid ""
"Socket is not listening for connections, or I<addrlen> is invalid (e.g., is "
"negative)."
msgstr ""
"Сокет не слушает соединения или недопустимое значение I<addrlen> (например, "
"отрицательное)."

#. type: Plain text
#: man-pages/man2/accept.2:249
msgid "(B<accept4>())  invalid value in I<flags>."
msgstr "(B<accept4>()) недопустимое значение в I<flags>."

#. type: TP
#: man-pages/man2/accept.2:249
#, no-wrap
msgid "B<EMFILE>"
msgstr "B<EMFILE>"

#. type: Plain text
#: man-pages/man2/accept.2:252
msgid "The per-process limit of open file descriptors has been reached."
msgstr ""
"Было достигнуто ограничение по открытым файловым дескриптором на процесс."

#. type: TP
#: man-pages/man2/accept.2:252
#, no-wrap
msgid "B<ENFILE>"
msgstr "B<ENFILE>"

#. type: Plain text
#: man-pages/man2/accept.2:255
msgid "The system limit on the total number of open files has been reached."
msgstr "Достигнуто максимальное количество открытых файлов в системе."

#. type: TP
#: man-pages/man2/accept.2:255
#, no-wrap
msgid "B<ENOBUFS>, B<ENOMEM>"
msgstr "B<ENOBUFS>, B<ENOMEM>"

#. type: Plain text
#: man-pages/man2/accept.2:260
msgid ""
"Not enough free memory.  This often means that the memory allocation is "
"limited by the socket buffer limits, not by the system memory."
msgstr ""
"Не хватает свободной памяти. Это зачастую означает, что выделение памяти "
"ограничено размерами буфера сокетов, а не системной памятью."

#. type: TP
#: man-pages/man2/accept.2:260
#, no-wrap
msgid "B<ENOTSOCK>"
msgstr "B<ENOTSOCK>"

#. type: Plain text
#: man-pages/man2/accept.2:263
msgid "The descriptor references a file, not a socket."
msgstr "Дескриптор ссылается на файл, а не на сокет."

#. type: TP
#: man-pages/man2/accept.2:263
#, no-wrap
msgid "B<EOPNOTSUPP>"
msgstr "B<EOPNOTSUPP>"

#. type: Plain text
#: man-pages/man2/accept.2:267
msgid "The referenced socket is not of type B<SOCK_STREAM>."
msgstr ""
"Тип сокета, на который ссылается дескриптор, отличается от B<SOCK_STREAM>."

#. type: TP
#: man-pages/man2/accept.2:267
#, no-wrap
msgid "B<EPROTO>"
msgstr "B<EPROTO>"

#. type: Plain text
#: man-pages/man2/accept.2:270
msgid "Protocol error."
msgstr "Ошибка протокола."

#. type: Plain text
#: man-pages/man2/accept.2:274
msgid "In addition, Linux B<accept>()  may fail if:"
msgstr "Также, Linux B<accept>() может завершиться с ошибкой если:"

#. type: Plain text
#: man-pages/man2/accept.2:277
msgid "Firewall rules forbid connection."
msgstr "Правила межсетевого экрана запрещают соединение."

#. type: Plain text
#: man-pages/man2/accept.2:289
msgid ""
"In addition, network errors for the new socket and as defined for the "
"protocol may be returned.  Various Linux kernels can return other errors "
"such as B<ENOSR>, B<ESOCKTNOSUPPORT>, B<EPROTONOSUPPORT>, B<ETIMEDOUT>.  The"
" value B<ERESTARTSYS> may be seen during a trace."
msgstr ""
"Вдобавок, могут также возвращаться сетевые ошибки на новом сокете и ошибки, "
"могущие возникнуть в протоколе. Различные ядра Linux могут возвращать другие "
"ошибки, например, B<ENOSR>, B<ESOCKTNOSUPPORT>, B<EPROTONOSUPPORT>, B<"
"ETIMEDOUT>. Значение ошибки B<ERESTARTSYS> можно увидеть при трассировке."

#. type: Plain text
#: man-pages/man2/accept.2:294
msgid ""
"The B<accept4>()  system call is available starting with Linux 2.6.28; "
"support in glibc is available starting with version 2.10."
msgstr ""
"Системный вызов B<accept4>() доступен в Linux начиная с версии 2.6.28; "
"поддержка в glibc доступна начиная с версии 2.10."

#.  The BSD man page documents five possible error returns
#.  (EBADF, ENOTSOCK, EOPNOTSUPP, EWOULDBLOCK, EFAULT).
#.  POSIX.1-2001 documents errors
#.  EAGAIN, EBADF, ECONNABORTED, EINTR, EINVAL, EMFILE,
#.  ENFILE, ENOBUFS, ENOMEM, ENOTSOCK, EOPNOTSUPP, EPROTO, EWOULDBLOCK.
#.  In addition, SUSv2 documents EFAULT and ENOSR.
#. type: Plain text
#: man-pages/man2/accept.2:306
msgid ""
"B<accept>(): POSIX.1-2001, SVr4, 4.4BSD, (B<accept>()  first appeared in "
"4.2BSD)."
msgstr ""
"B<accept>(): POSIX.1-2001, SVr4, 4.4BSD, (B<accept>() впервые появился в "
"4.2BSD)."

#. type: Plain text
#: man-pages/man2/accept.2:309
msgid "B<accept4>()  is a nonstandard Linux extension."
msgstr "B<accept4>() является нестандартным расширением Linux."

#.  Some testing seems to show that Tru64 5.1 and HP-UX 11 also
#.  do not inherit file status flags -- MTK Jun 05
#. type: Plain text
#: man-pages/man2/accept.2:324
msgid ""
"On Linux, the new socket returned by B<accept>()  does I<not> inherit file "
"status flags such as B<O_NONBLOCK> and B<O_ASYNC> from the listening socket."
"  This behavior differs from the canonical BSD sockets implementation.  "
"Portable programs should not rely on inheritance or noninheritance of file "
"status flags and always explicitly set all required flags on the socket "
"returned from B<accept>()."
msgstr ""
"В Linux новый сокет, возвращаемый B<accept>(), I<не> наследует файловые флаги "
"состояния такие как B<O_NONBLOCK> и B<O_ASYNC> от прослушивающего сокета. Это "
"поведение отличается от каноническое реализации сокетов BSD. Переносимые "
"программы не должны полагаться на наследуемость файловых флагов состояния или "
"её отсутствия и всегда должны устанавливать на сокете, полученном от B<accept>"
"(), все требуемые флаги."

#. type: Plain text
#: man-pages/man2/accept.2:330
msgid ""
"POSIX.1-2001 does not require the inclusion of I<E<lt>sys/types.hE<gt>>, and"
" this header file is not required on Linux.  However, some historical (BSD) "
"implementations required this header file, and portable applications are "
"probably wise to include it."
msgstr ""
"В POSIX.1-2001 не требуется включение I<E<lt>sys/types.hE<gt>>, и этот "
"заголовочный файл не требуется в Linux. Однако, некоторые старые (BSD) "
"реализации требуют данный файл, и в переносимых приложениях для "
"предосторожности, вероятно, он будет включён."

#. type: Plain text
#: man-pages/man2/accept.2:351
msgid ""
"There may not always be a connection waiting after a B<SIGIO> is delivered "
"or B<select>(2)  or B<poll>(2)  return a readability event because the "
"connection might have been removed by an asynchronous network error or "
"another thread before B<accept>()  is called.  If this happens, then the "
"call will block waiting for the next connection to arrive.  To ensure that "
"B<accept>()  never blocks, the passed socket I<sockfd> needs to have the "
"B<O_NONBLOCK> flag set (see B<socket>(7))."
msgstr ""
"Возможно не всегда будет ожидание подключения после доставки B<SIGIO>; или B<"
"select>(2) или B<poll>(2) вернут событие доступности чтения, так как "
"подключение может быть удалено из-за асинхронной сетевой ошибкой или другая "
"нить была вызвала раньше B<accept>(). Это это случается, то вызов "
"блокируется, ожидая следующего прибытия подключения. Чтобы быть уверенным, "
"что B<accept>() никогда не заблокируется, сокету I<sockfd> необходимо "
"установить флаг B<O_NONBLOCK> (см. B<socket>(7))."

#. type: SS
#: man-pages/man2/accept.2:351
#, no-wrap
msgid "The socklen_t type"
msgstr "Тип socklen_t"

#. type: Plain text
#: man-pages/man2/accept.2:361
msgid ""
"The third argument of B<accept>()  was originally declared as an I<int *> "
"(and is that under libc4 and libc5 and on many other systems like 4.x BSD, "
"SunOS 4, SGI); a POSIX.1g draft standard wanted to change it into a I<size_t"
" *>, and that is what it is for SunOS 5.  Later POSIX drafts have "
"I<socklen_t *>, and so do the Single UNIX Specification and glibc2.  Quoting"
" Linus Torvalds:"
msgstr ""
"Третий аргумент B<accept>() первоначально объявлялся как I<int *> (и так было "
"в libc4, libc5 и многих других системах типа 4.x BSD, SunOS 4, SGI); в "
"стандарте черновика POSIX.1g захотели изменить его на I<size_t *>, и так "
"сделано в SunOS 5. Поздние черновики POSIX содержат I<socklen_t *>, и так "
"сделано в Single UNIX Specification и glibc2. Цитируя Линуса Торвальдса "
"(Linus Torvalds):"

#.  .I fails: only italicizes a single line
#. type: Plain text
#: man-pages/man2/accept.2:378
msgid ""
"\"_Any_ sane library _must_ have \"socklen_t\" be the same size as int.  "
"Anything else breaks any BSD socket layer stuff.  POSIX initially I<did> "
"make it a size_t, and I (and hopefully others, but obviously not too many) "
"complained to them very loudly indeed.  Making it a size_t is completely "
"broken, exactly because size_t very seldom is the same size as \"int\" on "
"64-bit architectures, for example.  And it I<has> to be the same size as "
"\"int\" because that's what the BSD socket interface is.  Anyway, the POSIX "
"people eventually got a clue, and created \"socklen_t\".  They shouldn't "
"have touched it in the first place, but once they did they felt it had to "
"have a named type for some unfathomable reason (probably somebody didn't "
"like losing face over having done the original stupid thing, so they "
"silently just renamed their blunder).\""
msgstr ""
"\"_Любая_ нормальная библиотека _должна_ иметь \"socklen_t\" размером с int. "
"Любой другой вариант ломает реализацию BSD-сокетов. В POSIX _сначала_ls "
"использовали size_t, но я (и, к счастью, кто-то ещё, хотя и не слишком "
"многие) очень громко пожаловались. Такая реализация вообще не работает, так "
"как size_t очень редко имеет тот же размер, что и \"int\", например, на "
"64-битных архитектурах. Это необходимо _только_ потому, что так сделано в "
"интерфейсе BSD-сокетов. В любом случае, люди из POSIX наконец поняли и "
"создали \"socklen_t\". Вообще, с самого начала они просто не должны были "
"ничего трогать, но по какой-то причине они чувствовали, что должны "
"использовать именованный тип (вероятно, они не хотели ударить в грязь лицом "
"сделав глупость, поэтому они тихо переименовали место, в котором "
"просчитались).\""

#. type: Plain text
#: man-pages/man2/accept.2:381
msgid "See B<bind>(2)."
msgstr "См. B<bind>(2)."

#. type: Plain text
#: man-pages/man2/accept.2:387
msgid ""
"B<bind>(2), B<connect>(2), B<listen>(2), B<select>(2), B<socket>(2), "
"B<socket>(7)"
msgstr ""
"B<bind>(2), B<connect>(2), B<listen>(2), B<select>(2), B<socket>(2), B<socket>"
"(7)"

#. type: TH
#: man-pages/man2/acct.2:31
#, no-wrap
msgid "ACCT"
msgstr "ACCT"

#. type: TH
#: man-pages/man2/acct.2:31
#, no-wrap
msgid "2008-06-16"
msgstr "2008-06-16"

#. type: Plain text
#: man-pages/man2/acct.2:34
msgid "acct - switch process accounting on or off"
msgstr "acct - включает или выключает учёт процессов"

#. type: Plain text
#: man-pages/man2/acct.2:38
#, no-wrap
msgid "B<#include E<lt>unistd.hE<gt>>\n"
msgstr "B<#include E<lt>unistd.hE<gt>>\n"

#. type: Plain text
#: man-pages/man2/acct.2:40
#, no-wrap
msgid "B<int acct(const char *>I<filename>B<);>\n"
msgstr "B<int acct(const char *>I<filename>B<);>\n"

#. type: Plain text
#: man-pages/man2/acct.2:46
msgid ""
"Feature Test Macro Requirements for glibc (see B<feature_test_macros>(7)):"
msgstr ""
"Требования макроса тестирования свойств для glibc (см. B<feature_test_macros>"
"(7)):"

#. type: Plain text
#: man-pages/man2/acct.2:50
msgid ""
"B<acct>(): _BSD_SOURCE || (_XOPEN_SOURCE && _XOPEN_SOURCE\\ E<lt>\\ 500)"
msgstr ""
"B<acct>(): _BSD_SOURCE || (_XOPEN_SOURCE && _XOPEN_SOURCE\\ E<lt>\\ 500)"

#. type: Plain text
#: man-pages/man2/acct.2:60
msgid ""
"The B<acct>()  system call enables or disables process accounting.  If "
"called with the name of an existing file as its argument, accounting is "
"turned on, and records for each terminating process are appended to "
"I<filename> as it terminates.  An argument of NULL causes accounting to be "
"turned off."
msgstr ""
"Системный вызов B<acct>() включает или выключает учёт процессов. Если при "
"вызове, в качестве аргумента, указывается имя существующего файла, происходит "
"включение учёта, и при завершении процесса, в файл I<filename> добавляются "
"записи для каждого завершившегося процесса. Если в качестве аргумента указан "
"NULL, то учёт выключается."

#. type: Plain text
#: man-pages/man2/acct.2:65
msgid ""
"On success, zero is returned.  On error, -1 is returned, and I<errno> is set"
" appropriately."
msgstr ""
"При успешном выполнении возвращается 0. В случае ошибки возвращается -1, а I<"
"errno> устанавливается в соответствующее значение."

#. type: TP
#: man-pages/man2/acct.2:66
#, no-wrap
msgid "B<EACCES>"
msgstr "B<EACCES>"

#. type: Plain text
#: man-pages/man2/acct.2:77
msgid ""
"Write permission is denied for the specified file, or search permission is "
"denied for one of the directories in the path prefix of I<filename> (see "
"also B<path_resolution>(7)), or I<filename> is not a regular file."
msgstr ""
"Нет прав на запись в указанный файл, или в одном из каталогов в I<pathname> "
"не разрешён поиск (см. также B<path_resolution>(7)), или I<filename> не "
"является обычным файлом."

#. type: Plain text
#: man-pages/man2/acct.2:81
msgid "I<filename> points outside your accessible address space."
msgstr ""
"Аргумент I<filename> указывает за пределы доступного адресного пространства."

#. type: TP
#: man-pages/man2/acct.2:81
#, no-wrap
msgid "B<EIO>"
msgstr "B<EIO>"

#. type: Plain text
#: man-pages/man2/acct.2:85
msgid "Error writing to the file I<filename>."
msgstr "Ошибка записи в файл I<filename>."

#. type: TP
#: man-pages/man2/acct.2:85
#, no-wrap
msgid "B<EISDIR>"
msgstr "B<EISDIR>"

#. type: Plain text
#: man-pages/man2/acct.2:89
msgid "I<filename> is a directory."
msgstr "I<filename> является каталогом."

#. type: TP
#: man-pages/man2/acct.2:89
#, no-wrap
msgid "B<ELOOP>"
msgstr "B<ELOOP>"

#. type: Plain text
#: man-pages/man2/acct.2:93
msgid "Too many symbolic links were encountered in resolving I<filename>."
msgstr ""
"Во время определения I<pathname> встретилось слишком много символьных ссылок."

#. type: TP
#: man-pages/man2/acct.2:93
#, no-wrap
msgid "B<ENAMETOOLONG>"
msgstr "B<ENAMETOOLONG>"

#. type: Plain text
#: man-pages/man2/acct.2:97
msgid "I<filename> was too long."
msgstr "Слишком длинное значение аргумента I<pathname>."

#. type: TP
#: man-pages/man2/acct.2:100
#, no-wrap
msgid "B<ENOENT>"
msgstr "B<ENOENT>"

#. type: Plain text
#: man-pages/man2/acct.2:103
msgid "The specified filename does not exist."
msgstr "Указанный файл не существует."

#. type: TP
#: man-pages/man2/acct.2:103
#, no-wrap
msgid "B<ENOMEM>"
msgstr "B<ENOMEM>"

#. type: Plain text
#: man-pages/man2/acct.2:106
msgid "Out of memory."
msgstr "Не хватает памяти."

#. type: TP
#: man-pages/man2/acct.2:106
#, no-wrap
msgid "B<ENOSYS>"
msgstr "B<ENOSYS>"

#. type: Plain text
#: man-pages/man2/acct.2:112
msgid ""
"BSD process accounting has not been enabled when the operating system kernel"
" was compiled.  The kernel configuration parameter controlling this feature "
"is B<CONFIG_BSD_PROCESS_ACCT>."
msgstr ""
"BSD учёт процессов не может быть разрешён, если эта возможность не была "
"включена при компиляции ядра операционной системы. Этой возможностью "
"управляет параметр настройки ядра B<CONFIG_BSD_PROCESS_ACCT>."

#. type: TP
#: man-pages/man2/acct.2:112
#, no-wrap
msgid "B<ENOTDIR>"
msgstr "B<ENOTDIR>"

#. type: Plain text
#: man-pages/man2/acct.2:117
msgid ""
"A component used as a directory in I<filename> is not in fact a directory."
msgstr "Компонент пути в I<pathname> в действительности не является каталогом."

#. type: Plain text
#: man-pages/man2/acct.2:123
msgid ""
"The calling process has insufficient privilege to enable process accounting."
"  On Linux the B<CAP_SYS_PACCT> capability is required."
msgstr ""
"Вызвавшему процессу не хватает прав включить учёт процессов. В Linux для "
"этого требуется мандат B<CAP_SYS_PACCT>."

#. type: TP
#: man-pages/man2/acct.2:123
#, no-wrap
msgid "B<EROFS>"
msgstr "B<EROFS>"

#. type: Plain text
#: man-pages/man2/acct.2:127
msgid "I<filename> refers to a file on a read-only filesystem."
msgstr ""
"I<filename> указывает на файл в файловой системе, доступной только для чтения."

#. type: TP
#: man-pages/man2/acct.2:127
#, no-wrap
msgid "B<EUSERS>"
msgstr "B<EUSERS>"

#. type: Plain text
#: man-pages/man2/acct.2:130
msgid "There are no more free file structures or we ran out of memory."
msgstr "Закончились свободные файловые структуры или память."

#.  SVr4 documents an EBUSY error condition, but no EISDIR or ENOSYS.
#.  Also AIX and HP-UX document EBUSY (attempt is made
#.  to enable accounting when it is already enabled), as does Solaris
#.  (attempt is made to enable accounting using the same file that is
#.  currently being used).
#. type: Plain text
#: man-pages/man2/acct.2:137
msgid "SVr4, 4.3BSD (but not POSIX)."
msgstr "SVr4, 4.3BSD (но не POSIX)."

#. type: Plain text
#: man-pages/man2/acct.2:140
msgid ""
"No accounting is produced for programs running when a system crash occurs.  "
"In particular, nonterminating processes are never accounted for."
msgstr ""
"Учёт не производится для программ, которые заканчиваются аварийно. В "
"частности, незавершаемые процессы никогда не учитываются."

#. type: Plain text
#: man-pages/man2/acct.2:143
msgid ""
"The structure of the records written to the accounting file is described in "
"B<acct>(5)."
msgstr "Структура записей, записываемых в файл учёта, описана в B<acct>(5)."

#. type: Plain text
#: man-pages/man2/acct.2:144
msgid "B<acct>(5)"
msgstr "B<acct>(5)"

#. type: TH
#: man-pages/man2/add_key.2:11
#, no-wrap
msgid "ADD_KEY"
msgstr "ADD_KEY"

#. type: TH
#: man-pages/man2/add_key.2:11
#, no-wrap
msgid "2010-02-25"
msgstr "2010-02-25"

#. type: TH
#: man-pages/man2/add_key.2:11
#, no-wrap
msgid "Linux Key Management Calls"
msgstr "Вызовы системы управления ключами Linux"

#. type: Plain text
#: man-pages/man2/add_key.2:14
msgid "add_key - add a key to the kernel's key management facility"
msgstr "add_key - добавить ключ в систему управления ключами ядра"

#. type: Plain text
#: man-pages/man2/add_key.2:17
#, no-wrap
msgid "B<#include E<lt>keyutils.hE<gt>>\n"
msgstr "B<#include E<lt>keyutils.hE<gt>>\n"

#. type: Plain text
#: man-pages/man2/add_key.2:21
#, no-wrap
msgid ""
"B<key_serial_t add_key(const char *>I<type>B<, const char *>I<description>B<,>"
"\n"
"B<                     const void *>I<payload>B<, size_t >I<plen>B<,>\n"
"B<                     key_serial_t >I<keyring>B<);>\n"
msgstr ""
"B<key_serial_t add_key(const char *>I<type>B<, const char *>I<description>B<,>"
"\nB<                     const void *>I<payload>B<, size_t >I<plen>B<,>\nB<   "
"                  key_serial_t >I<keyring>B<);>\n"

#. type: Plain text
#: man-pages/man2/add_key.2:35
msgid ""
"B<add_key>()  asks the kernel to create or update a key of the given I<type>"
" and I<description>, instantiate it with the I<payload> of length I<plen>, "
"and to attach it to the nominated I<keyring> and to return its serial "
"number."
msgstr ""
"B<add_key>() указывает ядру создать или обновить ключ заданного типа I<type> "
"с описанием I<description>, сконструировать экземпляр с дополнительными "
"данными I<payload> и длиной I<plen>, присоединить его к заданной связке "
"ключей I<keyring> и вернуть его серийный номер."

#. type: Plain text
#: man-pages/man2/add_key.2:38
msgid ""
"The key type may reject the data if it's in the wrong format or in some "
"other way invalid."
msgstr ""
"В зависимости от типа ключа данные могут быть отклонены, если они "
"представлены в неправильном формате или возникла другая ошибка."

#. type: Plain text
#: man-pages/man2/add_key.2:46
msgid ""
"If the destination I<keyring> already contains a key that matches the "
"specified I<type> and I<description,> then, if the key type supports it, "
"that key will be updated rather than a new key being created; if not, a new "
"key will be created and it will displace the link to the extant key from the"
" keyring."
msgstr ""
"Если в указываемой связке ключей I<keyring> уже есть ключ с таким же I<type> "
"и I<description> то, если тип ключа это поддерживает, ключ будет обновлён, а "
"не создан заново; если нет, то будет создан новый ключ и он вытеснит ссылку "
"на существующий ключ из связки."

#. type: Plain text
#: man-pages/man2/add_key.2:51
msgid ""
"The destination I<keyring> serial number may be that of a valid keyring to "
"which the caller has write permission, or it may be a special keyring ID:"
msgstr ""
"Связка ключей I<keyring> может задаваться серийным номером действующей связки "
"ключей, для которой у вызывающего процесса есть права на запись, или "
"специальным ID связки ключей:"

#. type: TP
#: man-pages/man2/add_key.2:51
#, no-wrap
msgid "B<KEY_SPEC_THREAD_KEYRING>"
msgstr "B<KEY_SPEC_THREAD_KEYRING>"

#. type: Plain text
#: man-pages/man2/add_key.2:54
msgid "This specifies the caller's thread-specific keyring."
msgstr "Задаёт связку ключей нити вызывающего процесса."

#. type: TP
#: man-pages/man2/add_key.2:54
#, no-wrap
msgid "B<KEY_SPEC_PROCESS_KEYRING>"
msgstr "B<KEY_SPEC_PROCESS_KEYRING>"

#. type: Plain text
#: man-pages/man2/add_key.2:57
msgid "This specifies the caller's process-specific keyring."
msgstr "Задаёт связку ключей процесса."

#. type: TP
#: man-pages/man2/add_key.2:57
#, no-wrap
msgid "B<KEY_SPEC_SESSION_KEYRING>"
msgstr "B<KEY_SPEC_SESSION_KEYRING>"

#. type: Plain text
#: man-pages/man2/add_key.2:60
msgid "This specifies the caller's session-specific keyring."
msgstr "Задаёт связку ключей сеанса вызывающего процесса."

#. type: TP
#: man-pages/man2/add_key.2:60
#, no-wrap
msgid "B<KEY_SPEC_USER_KEYRING>"
msgstr "B<KEY_SPEC_USER_KEYRING>"

#. type: Plain text
#: man-pages/man2/add_key.2:63
msgid "This specifies the caller's UID-specific keyring."
msgstr "Задаёт связку ключей по UID вызывающего процесса."

#. type: TP
#: man-pages/man2/add_key.2:63
#, no-wrap
msgid "B<KEY_SPEC_USER_SESSION_KEYRING>"
msgstr "B<KEY_SPEC_USER_SESSION_KEYRING>"

#. type: Plain text
#: man-pages/man2/add_key.2:66
msgid "This specifies the caller's UID-session keyring."
msgstr "Задаёт связку ключей по UID сеанса вызывающего процесса."

#. type: SH
#: man-pages/man2/add_key.2:66
#, no-wrap
msgid "KEY TYPES"
msgstr "ТИПЫ КЛЮЧЕЙ"

#. type: Plain text
#: man-pages/man2/add_key.2:69
msgid ""
"There are a number of key types available in the core key management code, "
"and these can be specified to this function:"
msgstr ""
"В ядре кода управления ключами есть несколько типов; они могут указываться в "
"этой функции:"

#. type: TP
#: man-pages/man2/add_key.2:69
#, no-wrap
msgid "B<``user''>"
msgstr "B<user>"

#. type: Plain text
#: man-pages/man2/add_key.2:80
msgid ""
"Keys of the user-defined key type may contain a blob of arbitrary data, and "
"the I<description> may be any valid string, though it is preferred that the "
"description be prefixed with a string representing the service to which the "
"key is of interest and a colon (for instance ``B<afs:mykey>'').  The "
"I<payload> may be empty or NULL for keys of this type."
msgstr ""
"Ключи определённых пользователем типов могут содержать двоичный набор "
"произвольных данных, а в I<description> можно указывать любую произвольную "
"строку, хотя предпочтительнее, чтобы описание начиналось со строки, "
"представляющей службу, для которой предназначен ключ, и двоеточие (например, "
"B<afs:mykey>). Для ключей этого типа значение I<payload> может быть пустым "
"или NULL."

#. type: TP
#: man-pages/man2/add_key.2:80
#, no-wrap
msgid "B<``keyring''>"
msgstr "B<keyring>"

#. type: Plain text
#: man-pages/man2/add_key.2:89
msgid ""
"Keyrings are special key types that may contain links to sequences of other "
"keys of any type.  If this interface is used to create a keyring, then a "
"NULL I<payload> should be specified, and I<plen> should be zero."
msgstr ""
"Связки ключей — это специальный тип ключей, который может содержать ссылки на "
"цепочки других ключей любого типа. Если данный интерфейс используется для "
"создания связки ключей, то I<payload> должен быть NULL, а значение I<plen> "
"должно быть равно нулю."

#. type: Plain text
#: man-pages/man2/add_key.2:95
msgid ""
"On success B<add_key>()  returns the serial number of the key it created or "
"updated.  On error, the value -1 will be returned and errno will have been "
"set to an appropriate error."
msgstr ""
"При успешном выполнении B<add_key>() возвращает серийный номер созданного или "
"обновлённого ключа. В случае возникновения ошибки возвращается -1, а в errno "
"устанавливается значение соответствующей ошибки."

#. type: TP
#: man-pages/man2/add_key.2:96
#, no-wrap
msgid "B<ENOKEY>"
msgstr "B<ENOKEY>"

#. type: Plain text
#: man-pages/man2/add_key.2:99
msgid "The keyring doesn't exist."
msgstr "Связка ключей не существует."

#. type: TP
#: man-pages/man2/add_key.2:99
#, no-wrap
msgid "B<EKEYEXPIRED>"
msgstr "B<EKEYEXPIRED>"

#. type: Plain text
#: man-pages/man2/add_key.2:102
msgid "The keyring has expired."
msgstr "Срок службы связки ключей истёк."

#. type: TP
#: man-pages/man2/add_key.2:102
#, no-wrap
msgid "B<EKEYREVOKED>"
msgstr "B<EKEYREVOKED>"

#. type: Plain text
#: man-pages/man2/add_key.2:105
msgid "The keyring has been revoked."
msgstr "Связка ключей отозвана."

#. type: Plain text
#: man-pages/man2/add_key.2:108
msgid "The payload data was invalid."
msgstr "Неправильные дополнительные данные."

#. type: Plain text
#: man-pages/man2/add_key.2:111
msgid "Insufficient memory to create a key."
msgstr "Недостаточно памяти для создания ключа."

#. type: TP
#: man-pages/man2/add_key.2:111
#, no-wrap
msgid "B<EDQUOT>"
msgstr "B<EDQUOT>"

#. type: Plain text
#: man-pages/man2/add_key.2:115
msgid ""
"The key quota for this user would be exceeded by creating this key or "
"linking it to the keyring."
msgstr ""
"Квота на ключи для данного пользователя была бы превышена, если бы этот ключ "
"создался или был бы прицеплен в связку ключей."

#. type: Plain text
#: man-pages/man2/add_key.2:118
msgid "The keyring wasn't available for modification by the user."
msgstr "Изменение связки ключей пользователю недоступно."

#. type: SH
#: man-pages/man2/add_key.2:118
#, no-wrap
msgid "LINKING"
msgstr "КОМПОНОВКА"

#. type: Plain text
#: man-pages/man2/add_key.2:126
msgid ""
"Although this is a Linux system call, it is not present in I<libc> but can "
"be found rather in I<libkeyutils>.  When linking, B<-lkeyutils> should be "
"specified to the linker."
msgstr ""
"Хотя это и системный вызов Linux, его нет в I<libc>, но его можно найти в I<"
"libkeyutils>. При сборке программы компоновщику нужно указать параметр B<"
"-lkeyutils>."

#. type: Plain text
#: man-pages/man2/add_key.2:129
msgid "B<keyctl>(1), B<keyctl>(2), B<request_key>(2)"
msgstr "B<keyctl>(1), B<keyctl>(2), B<request_key>(2)"

#. type: TH
#: man-pages/man2/access.2:43
#, no-wrap
msgid "ACCESS"
msgstr "ACCESS"

#. type: TH
#: man-pages/man2/access.2:43
#, no-wrap
msgid "2014-02-21"
msgstr "2014-02-21"

#. type: Plain text
#: man-pages/man2/access.2:46
msgid "access, faccessat - check user's permissions for a file"
msgstr "access, faccessat - проверить права доступа пользователя к файлу"

#. type: Plain text
#: man-pages/man2/access.2:51
#, no-wrap
msgid "B<int access(const char *>I<pathname>B<, int >I<mode>B<);>\n"
msgstr "B<int access(const char *>I<pathname>B<, int >I<mode>B<);>\n"

#. type: Plain text
#: man-pages/man2/access.2:54
#, no-wrap
msgid ""
"B<#include E<lt>fcntl.hE<gt>           >/* Definition of AT_* constants */\n"
"B<#include E<lt>unistd.hE<gt>>\n"
msgstr ""
"B<#include E<lt>fcntl.hE<gt>           >/* определения констант of AT_* "
"*/\nB<#include E<lt>unistd.hE<gt>>\n"

#. type: Plain text
#: man-pages/man2/access.2:57
#, no-wrap
msgid ""
"B<int faccessat(int >I<dirfd>B<, const char *>I<pathname>B<, int >I<mode>B<,"
" int >I<flags>B<);>\n"
msgstr ""
"B<int faccessat(int >I<dirfd>B<, const char *>I<pathname>B<, int >I<mode>B<, "
"int >I<flags>B<);>\n"

#. type: Plain text
#: man-pages/man2/access.2:65
msgid "B<faccessat>():"
msgstr "B<faccessat>():"

#. type: TP
#: man-pages/man2/access.2:68
#, no-wrap
msgid "Since glibc 2.10:"
msgstr "Начиная с glibc 2.10:"

#. type: Plain text
#: man-pages/man2/access.2:71
msgid "_XOPEN_SOURCE\\ E<gt>=\\ 700 || _POSIX_C_SOURCE\\ E<gt>=\\ 200809L"
msgstr "_XOPEN_SOURCE\\ E<gt>=\\ 700 || _POSIX_C_SOURCE\\ E<gt>=\\ 200809L"

#. type: TP
#: man-pages/man2/access.2:71
#, no-wrap
msgid "Before glibc 2.10:"
msgstr "До glibc 2.10:"

#. type: Plain text
#: man-pages/man2/access.2:74
msgid "_ATFILE_SOURCE"
msgstr "_ATFILE_SOURCE"

#. type: Plain text
#: man-pages/man2/access.2:85
msgid ""
"B<access>()  checks whether the calling process can access the file "
"I<pathname>.  If I<pathname> is a symbolic link, it is dereferenced."
msgstr ""
"B<access> проверяет, имеет ли вызвавший процесс права доступа к файлу I<"
"pathname>. Если I<pathname> является символьной ссылкой, то проверяются права "
"доступа к файлу, на который она ссылается."

#.  F_OK is defined as 0 on every system that I know of.
#. type: Plain text
#: man-pages/man2/access.2:99
msgid ""
"The I<mode> specifies the accessibility check(s) to be performed, and is "
"either the value B<F_OK>, or a mask consisting of the bitwise OR of one or "
"more of B<R_OK>, B<W_OK>, and B<X_OK>.  B<F_OK> tests for the existence of "
"the file.  B<R_OK>, B<W_OK>, and B<X_OK> test whether the file exists and "
"grants read, write, and execute permissions, respectively."
msgstr ""
"Аргумент I<mode> \\(em это маска выполняемых проверок доступа; может быть "
"равна значению B<F_OK>, или состоять из одного или несколько побитово "
"сложенных B<R_OK>, B<W_OK> и B<X_OK>. B<F_OK> проверяет существование файла. "
"B<R_OK>, B<W_OK> и B<X_OK> запрашивают проверку, соответственно, "
"существования файла и возможности его чтения, записи или выполнения."

#. type: Plain text
#: man-pages/man2/access.2:108
msgid ""
"The check is done using the calling process's I<real> UID and GID, rather "
"than the effective IDs as is done when actually attempting an operation "
"(e.g., B<open>(2))  on the file.  This allows set-user-ID programs to easily"
" determine the invoking user's authority."
msgstr ""
"Проверка осуществляется с использованием I<реального>, а не эффективного "
"идентификатора пользователя (UID) и группы (GID) вызвавшего процесса. "
"Эффективные идентификаторы будут использоваться при действительной попытке "
"выполнения той или иной операции с файлом (например, B<open>(2)). Это дает "
"программам с set-user-ID простой способ проверить права доступа вызвавшего "
"пользователя."

#. type: Plain text
#: man-pages/man2/access.2:114
msgid ""
"If the calling process is privileged (i.e., its real UID is zero), then an "
"B<X_OK> check is successful for a regular file if execute permission is "
"enabled for any of the file owner, group, or other."
msgstr ""
"Если вызвавший процесс имеет соответствующие привилегии (например, его "
"реальный UID равен нулю), то проверка B<X_OK> пройдёт успешно для обычного "
"файла, если у него установлено право на выполнение в любой группе бит: у "
"владельца, группы или остальных."

#. type: SS
#: man-pages/man2/access.2:114
#, no-wrap
msgid "faccessat()"
msgstr "faccessat()"

#. type: Plain text
#: man-pages/man2/access.2:120
msgid ""
"The B<faccessat>()  system call operates in exactly the same way as "
"B<access>(), except for the differences described here."
msgstr ""
"Системный вызов B<faccessat>() работает также как системный вызов B<access>"
"(), за исключением случаев, описанных здесь."

#. type: Plain text
#: man-pages/man2/access.2:130
msgid ""
"If the pathname given in I<pathname> is relative, then it is interpreted "
"relative to the directory referred to by the file descriptor I<dirfd> "
"(rather than relative to the current working directory of the calling "
"process, as is done by B<access>()  for a relative pathname)."
msgstr ""
"Если в I<pathname> задан относительный путь, то он считается относительно "
"каталога, на который ссылается файловый дескриптор I<dirfd> (а не "
"относительно текущего рабочего каталога вызывающего процесса, как это "
"делается в B<access>())."

#. type: Plain text
#: man-pages/man2/access.2:142
msgid ""
"If I<pathname> is relative and I<dirfd> is the special value B<AT_FDCWD>, "
"then I<pathname> is interpreted relative to the current working directory of"
" the calling process (like B<access>())."
msgstr ""
"Если в I<pathname> задан относительный путь и I<dirfd> равно специальному "
"значению B<AT_FDCWD>, то I<pathname> рассматривается относительно текущего "
"рабочего каталога вызывающего процесса (как B<access>())."

#. type: Plain text
#: man-pages/man2/access.2:148
msgid "If I<pathname> is absolute, then I<dirfd> is ignored."
msgstr "Если в I<pathname> задан абсолютный путь, то I<dirfd> игнорируется."

#. type: Plain text
#: man-pages/man2/access.2:151
msgid ""
"I<flags> is constructed by ORing together zero or more of the following "
"values:"
msgstr ""
"Значение I<flags> составляется из побитово сложенных следующих значений:"

#. type: TP
#: man-pages/man2/access.2:151
#, no-wrap
msgid "B<AT_EACCESS>"
msgstr "B<AT_EACCESS>"

#. type: Plain text
#: man-pages/man2/access.2:158
msgid ""
"Perform access checks using the effective user and group IDs.  By default, "
"B<faccessat>()  uses the real IDs (like B<access>())."
msgstr ""
"Выполнять проверку, доступа используя эффективный идентификатор пользователя "
"и группы. По умолчанию в B<faccessat>() используются реальные идентификаторы "
"(как в B<access>())."

#. type: TP
#: man-pages/man2/access.2:158
#, no-wrap
msgid "B<AT_SYMLINK_NOFOLLOW>"
msgstr "B<AT_SYMLINK_NOFOLLOW>"

#. type: Plain text
#: man-pages/man2/access.2:164
msgid ""
"If I<pathname> is a symbolic link, do not dereference it: instead return "
"information about the link itself."
msgstr ""
"Если значение I<pathname> является символьной ссылкой, не разыменовывать её, "
"а выдать информацию о самой ссылке."

#. type: Plain text
#: man-pages/man2/access.2:169
msgid "See B<openat>(2)  for an explanation of the need for B<faccessat>()."
msgstr "Смотрите в B<openat>(2) объяснение необходимости B<faccessat>()."

#. type: Plain text
#: man-pages/man2/access.2:185
msgid ""
"On success (all requested permissions granted, or I<mode> is B<F_OK> and the"
" file exists), zero is returned.  On error (at least one bit in I<mode> "
"asked for a permission that is denied, or I<mode> is B<F_OK> and the file "
"does not exist, or some other error occurred), -1 is returned, and I<errno> "
"is set appropriately."
msgstr ""
"При успешном выполнении (есть все запрошенные права или значение I<mode> "
"равно B<F_OK> и файл существует) возвращается нуль. При ошибке (по крайней "
"мере, одно право из I<mode> было не удовлетворено, значение I<mode> равно B<"
"F_OK> и файл не существует, или случилась другая ошибка), возвращается -1, а "
"I<errno> устанавливается должным образом."

#. type: Plain text
#: man-pages/man2/access.2:190
msgid "B<access>()  and B<faccessat>()  shall fail if:"
msgstr "Вызов B<access>() и B<faccessat>() будут завершаться с ошибкой если:"

#. type: Plain text
#: man-pages/man2/access.2:197
msgid ""
"The requested access would be denied to the file, or search permission is "
"denied for one of the directories in the path prefix of I<pathname>.  (See "
"also B<path_resolution>(7).)"
msgstr ""
"Запрошенный тип доступа не удовлетворён или в одном из каталогов в I<pathname>"
" не разрешён поиск. (См. также B<path_resolution>(7).)"

#. type: Plain text
#: man-pages/man2/access.2:201
msgid "Too many symbolic links were encountered in resolving I<pathname>."
msgstr ""
"Во время определения I<pathname> встретилось слишком много символьных ссылок."

#. type: Plain text
#: man-pages/man2/access.2:205
msgid "I<pathname> is too long."
msgstr "Слишком длинное значение аргумента I<pathname>."

#. type: Plain text
#: man-pages/man2/access.2:210
msgid ""
"A component of I<pathname> does not exist or is a dangling symbolic link."
msgstr ""
"Компонент пути I<pathname> не существует или является повисшей символьной "
"ссылкой."

#. type: Plain text
#: man-pages/man2/access.2:215
msgid ""
"A component used as a directory in I<pathname> is not, in fact, a directory."
msgstr ""
"Компонент пути, использованный как каталог в I<pathname>, в действительности "
"таковым не является."

#. type: Plain text
#: man-pages/man2/access.2:218
msgid "Write permission was requested for a file on a read-only filesystem."
msgstr ""
"Запрошено право на запись в файл, расположенный в файловой системе, доступной "
"только для чтения."

#. type: Plain text
#: man-pages/man2/access.2:223
msgid "B<access>()  and B<faccessat>()  may fail if:"
msgstr "Вызов B<access>() и B<faccessat>() могут завершиться с ошибкой, если:"

#. type: Plain text
#: man-pages/man2/access.2:227
msgid "I<pathname> points outside your accessible address space."
msgstr ""
"Аргумент I<pathname> указывает за пределы доступного адресного пространства."

#. type: Plain text
#: man-pages/man2/access.2:231
msgid "I<mode> was incorrectly specified."
msgstr "Аргумент I<mode> был задан неверно."

#. type: Plain text
#: man-pages/man2/access.2:234
msgid "An I/O error occurred."
msgstr "Произошла ошибка ввода-вывода."

#. type: Plain text
#: man-pages/man2/access.2:237
msgid "Insufficient kernel memory was available."
msgstr "Недостаточное количество памяти ядра."

#. type: TP
#: man-pages/man2/access.2:237
#, no-wrap
msgid "B<ETXTBSY>"
msgstr "B<ETXTBSY>"

#. type: Plain text
#: man-pages/man2/access.2:241
msgid "Write access was requested to an executable which is being executed."
msgstr ""
"Запрошены права на запись для исполняемого файла, который сейчас выполняется."

#. type: Plain text
#: man-pages/man2/access.2:244
msgid "The following additional errors can occur for B<faccessat>():"
msgstr "В B<faccessat>() дополнительно могут возникнуть следующие ошибки:"

#. type: Plain text
#: man-pages/man2/access.2:248
msgid "I<dirfd> is not a valid file descriptor."
msgstr "I<dirfd> не является правильным файловым дескриптором."

#. type: Plain text
#: man-pages/man2/access.2:252
msgid "Invalid flag specified in I<flags>."
msgstr "Указано неверное значение в I<flags>."

#. type: Plain text
#: man-pages/man2/access.2:258
msgid ""
"I<pathname> is relative and I<dirfd> is a file descriptor referring to a "
"file other than a directory."
msgstr ""
"Значение I<pathname> содержит относительный путь и I<dirfd> содержит файловый "
"дескриптор, указывающий на файл, а не на каталог."

#. type: Plain text
#: man-pages/man2/access.2:262
msgid ""
"B<faccessat>()  was added to Linux in kernel 2.6.16; library support was "
"added to glibc in version 2.4."
msgstr ""
"Вызов B<faccessat>() был добавлен в ядро Linux версии 2.6.16; поддержка в "
"glibc доступна с версии 2.4."

#. type: Plain text
#: man-pages/man2/access.2:265
msgid "B<access>(): SVr4, 4.3BSD, POSIX.1-2001, POSIX.1-2008."
msgstr "B<access>(): SVr4, 4.3BSD, POSIX.1-2001, POSIX.1-2008."

#. type: Plain text
#: man-pages/man2/access.2:268
msgid "B<faccessat>(): POSIX.1-2008."
msgstr "B<faccessat>(): POSIX.1-2008."

#. type: Plain text
#: man-pages/man2/access.2:281
msgid ""
"B<Warning>: Using these calls to check if a user is authorized to, for "
"example, open a file before actually doing so using B<open>(2)  creates a "
"security hole, because the user might exploit the short time interval "
"between checking and opening the file to manipulate it.  B<For this reason, "
"the use of this system call should be avoided>.  (In the example just "
"described, a safer alternative would be to temporarily switch the process's "
"effective user ID to the real ID and then call B<open>(2).)"
msgstr ""
"B<Предупреждение>: Использование этих вызовов для проверки, например, "
"разрешено ли пользователю открытие файла перед реальным выполнением B<open>"
"(2), создаёт брешь в безопасности, так как пользователь может использовать "
"короткий промежуток времени между проверкой и открытием файла для управления "
"им. B<По этой причине лучше избегать использования данного системного вызова> "
"(в только что описанном примере, безопасной альтернативой будет временное "
"переключение эффективного пользовательского идентификатора процесса на "
"реальный идентификатор и вызов B<open>(2))."

#. type: Plain text
#: man-pages/man2/access.2:288
msgid ""
"B<access>()  always dereferences symbolic links.  If you need to check the "
"permissions on a symbolic link, use B<faccessat>(2)  with the flag "
"B<AT_SYMLINK_NOFOLLOW>."
msgstr ""
"Вызов B<access>() всегда разыменовывает символьные ссылки. Если вам нужно "
"проверить права символьной ссылки, используйте вызов B<faccessat>(2) с флагом "
"B<AT_SYMLINK_NOFOLLOW>."

#. type: Plain text
#: man-pages/man2/access.2:294
msgid ""
"These calls return an error if any of the access types in I<mode> is denied,"
" even if some of the other access types in I<mode> are permitted."
msgstr ""
"Эти вызовы возвращают ошибку, если отказано в любом из типов доступа I<mode>, "
"даже если разрешены остальные типы."

#.  HPU-UX 11 and Tru64 5.1 do this.
#. type: Plain text
#: man-pages/man2/access.2:301
msgid ""
"If the calling process has appropriate privileges (i.e., is superuser), "
"POSIX.1-2001 permits an implementation to indicate success for an B<X_OK> "
"check even if none of the execute file permission bits are set.  Linux does "
"not do this."
msgstr ""
"Если вызывающий процесс имеет соответствующие привилегии (например, "
"суперпользователя), то POSIX.1-2001 разрешает реализации сообщить об успешном "
"выполнении при проверке B<X_OK> даже, если ни один из битов выполнения файла "
"не установлен. В Linux так не происходит."

#. type: Plain text
#: man-pages/man2/access.2:309
msgid ""
"A file is accessible only if the permissions on each of the directories in "
"the path prefix of I<pathname> grant search (i.e., execute) access.  If any "
"directory is inaccessible, then the B<access>()  call will fail, regardless "
"of the permissions on the file itself."
msgstr ""
"Файл доступен только в случае, если для каждого каталога в пути, указанном в "
"I<pathname>, имеется право выполнять поиск (то есть, установлен бит "
"выполнения). Если какой-то каталог недоступен, то вызов B<access>() вернёт "
"ошибку, независимо от имеющихся прав файла."

#. type: Plain text
#: man-pages/man2/access.2:317
msgid ""
"Only access bits are checked, not the file type or contents.  Therefore, if "
"a directory is found to be writable, it probably means that files can be "
"created in the directory, and not that the directory can be written as a "
"file.  Similarly, a DOS file may be found to be \"executable,\" but the "
"B<execve>(2)  call will still fail."
msgstr ""
"Проверяются только биты доступа, но не тип файла или его содержимое. Поэтому, "
"если обнаруживается, что в каталог можно писать, то это, вероятно, означает, "
"что в этом каталоге можно создавать файлы, и что в этот каталог нельзя писать "
"как в файл. Также, файл DOS может быть посчитан как \"исполняемый\", но вызов "
"B<execve>(2) всё-равно не сможет его запустить."

#. type: Plain text
#: man-pages/man2/access.2:326
msgid ""
"These calls may not work correctly on NFSv2 filesystems with UID mapping "
"enabled, because UID mapping is done on the server and hidden from the "
"client, which checks permissions.  (NFS versions 3 and higher perform the "
"check on the server.)  Similar problems can occur to FUSE mounts."
msgstr ""
"Эти вызовы B<access>() могут некорректно работать на файловых системах NFSv2 "
"со включённым преобразованием UID-ов, потому что это преобразование "
"происходит на сервере и спрятано от клиента, который пытается проверить права "
"(в NFS версии 3 и выше выполняется проверка на сервере). Похожие проблемы "
"могут возникать при монтировании FUSE."

#. type: SS
#: man-pages/man2/access.2:326
#, no-wrap
msgid "faccessat ()"
msgstr "faccessat ()"

#. type: Plain text
#: man-pages/man2/access.2:339
msgid ""
"The raw B<faccessat>()  system call takes only the first three arguments.  "
"The B<AT_EACCESS> and B<AT_SYMLINK_NOFOLLOW> flags are actually implemented "
"within the glibc wrapper function for B<faccessat>().  If either of these "
"flags is specified, then the wrapper function employs B<fstatat>(2)  to "
"determine access permissions."
msgstr ""
"Нижележащий системный вызов B<faccessat>() имеет только первые три аргумента. "
"Флаги B<AT_EACCESS> и B<AT_SYMLINK_NOFOLLOW> на самом деле реализованы внутри "
"обёрточной функции glibc B<faccessat>(). Если задан какой-то из этих флагов, "
"то обёрточная функция использует B<fstatat>(2) для определения прав доступа."

#.  This behavior appears to have been an implementation accident.
#. type: Plain text
#: man-pages/man2/access.2:362
msgid ""
"In kernel 2.4 (and earlier) there is some strangeness in the handling of "
"B<X_OK> tests for superuser.  If all categories of execute permission are "
"disabled for a nondirectory file, then the only B<access>()  test that "
"returns -1 is when I<mode> is specified as just B<X_OK>; if B<R_OK> or "
"B<W_OK> is also specified in I<mode>, then B<access>()  returns 0 for such "
"files.  Early 2.6 kernels (up to and including 2.6.3)  also behaved in the "
"same way as kernel 2.4."
msgstr ""
"В ядрах версии 2.4 (и более ранних) есть некоторая странность в работе теста "
"B<X_OK> для суперпользователя. Если для всех категорий право исполнения "
"отключено для файла-не каталога, то тест B<access>() возвращает -1 только "
"когда I<mode> задан как B<X_OK>; если в I<mode> также указан флаг B<R_OK> или "
"B<W_OK>, то B<access>() вернёт для таких файлов 0. Ранние версии ядер 2.6 (до "
"2.6.3 включительно) ведут себя также как ядра 2.4."

#. type: Plain text
#: man-pages/man2/access.2:372
msgid ""
"In kernels before 2.6.20, these calls ignored the effect of the B<MS_NOEXEC>"
" flag if it was used to B<mount>(2)  the underlying filesystem.  Since "
"kernel 2.6.20, the B<MS_NOEXEC> is honored"
msgstr ""
"В ядрах до версии 2.6.20 эти вызовы игнорировали влияние флага B<MS_NOEXEC>, "
"если он был установлен с помощью B<mount>(2) для содержащей файл файловой "
"системы. Начиная с версия ядра 2.6.20, этот флаг учитывается"

#. type: Plain text
#: man-pages/man2/access.2:382
msgid ""
"B<chmod>(2), B<chown>(2), B<open>(2), B<setgid>(2), B<setuid>(2), "
"B<stat>(2), B<euidaccess>(3), B<credentials>(7), B<path_resolution>(7), "
"B<symlink>(7)"
msgstr ""
"B<chmod>(2), B<chown>(2), B<open>(2), B<setgid>(2), B<setuid>(2), B<stat>(2), "
"B<euidaccess>(3), B<credentials>(7), B<path_resolution>(7), B<symlink>(7)"

#. type: TH
#: man-pages/man2/alarm.2:30
#, no-wrap
msgid "ALARM"
msgstr "ALARM"

#. type: TH
#: man-pages/man2/alarm.2:30
#, no-wrap
msgid "2014-02-23"
msgstr "2014-02-23"

#. type: Plain text
#: man-pages/man2/alarm.2:33
msgid "alarm - set an alarm clock for delivery of a signal"
msgstr "alarm - установка будильника для доставки сигнала"

#. type: Plain text
#: man-pages/man2/alarm.2:38
#, no-wrap
msgid "B<unsigned int alarm(unsigned int >I<seconds>B<);>\n"
msgstr "B<unsigned int alarm(unsigned int >I<seconds>B<);>\n"

#. type: Plain text
#: man-pages/man2/alarm.2:46
msgid ""
"B<alarm>()  arranges for a B<SIGALRM> signal to be delivered to the calling "
"process in I<seconds> seconds."
msgstr ""
"Системный вызов B<alarm>() размещает сигнал B<SIGALRM> для доставки "
"вызывающему процессу через I<seconds> секунд."

#. type: Plain text
#: man-pages/man2/alarm.2:50
msgid "If I<seconds> is zero, any pending alarm is canceled."
msgstr ""
"Если значение I<seconds> равно 0, то любой ожидающий будильник будет отменён."

#. type: Plain text
#: man-pages/man2/alarm.2:54
msgid "In any event any previously set B<alarm>()  is canceled."
msgstr "При любом событии ранее запланированный B<alarm>() отменяется."

#. type: Plain text
#: man-pages/man2/alarm.2:59
msgid ""
"B<alarm>()  returns the number of seconds remaining until any previously "
"scheduled alarm was due to be delivered, or zero if there was no previously "
"scheduled alarm."
msgstr ""
"B<alarm>() возвращает количество секунд, оставшихся до момента доставки "
"сигнала, запланированного ранее, или ноль, если сигнал не запланирован."

#. type: Plain text
#: man-pages/man2/alarm.2:61
msgid "SVr4, POSIX.1-2001, 4.3BSD."
msgstr "SVr4, POSIX.1-2001, 4.3BSD."

#. type: Plain text
#: man-pages/man2/alarm.2:67
msgid ""
"B<alarm>()  and B<setitimer>(2)  share the same timer; calls to one will "
"interfere with use of the other."
msgstr ""
"B<alarm>() и B<setitimer>(2) используют один и тот же таймер; они будут "
"мешать работе друг друга."

#. type: Plain text
#: man-pages/man2/alarm.2:74
msgid ""
"Alarms created by B<alarm()> are preserved across B<execve>(2)  and are not "
"inherited by children created via B<fork>(2)."
msgstr ""
"Будильники, созданные B<alarm>(), сохраняются при выполнении B<execve>(2) и "
"не наследуются потомками, созданными с помощью B<fork>(2)."

#. type: Plain text
#: man-pages/man2/alarm.2:83
msgid ""
"B<sleep>(3)  may be implemented using B<SIGALRM>; mixing calls to B<alarm>()"
"  and B<sleep>(3)  is a bad idea."
msgstr ""
"B<sleep>(3) может быть реализован через B<SIGALRM>, поэтому лучше не "
"использовать B<alarm>() и B<sleep>(3) одновременно."

#. type: Plain text
#: man-pages/man2/alarm.2:86
msgid ""
"Scheduling delays can, as ever, cause the execution of the process to be "
"delayed by an arbitrary amount of time."
msgstr ""
"Постановка сигнала в очередь может вызывать задержу выполнения вызвавшего "
"процесса на произвольное время."

#. type: Plain text
#: man-pages/man2/alarm.2:94
msgid ""
"B<gettimeofday>(2), B<pause>(2), B<select>(2), B<setitimer>(2), "
"B<sigaction>(2), B<signal>(2), B<sleep>(3), B<time>(7)"
msgstr ""
"B<gettimeofday>(2), B<pause>(2), B<select>(2), B<setitimer>(2), B<sigaction>"
"(2), B<signal>(2), B<sleep>(3), B<time>(7)"

#. type: TH
#: man-pages/man2/alloc_hugepages.2:25
#, no-wrap
msgid "ALLOC_HUGEPAGES"
msgstr "ALLOC_HUGEPAGES"

#. type: TH
#: man-pages/man2/alloc_hugepages.2:25
#, no-wrap
msgid "2007-05-31"
msgstr "2007-05-31"

#. type: Plain text
#: man-pages/man2/alloc_hugepages.2:28
msgid "alloc_hugepages, free_hugepages - allocate or free huge pages"
msgstr ""
"alloc_hugepages, free_hugepages - выделяет или освобождает огромные страницы"

#.  asmlinkage unsigned long sys_alloc_hugepages(int key, unsigned long addr,
#.  unsigned long len, int prot, int flag);
#. type: Plain text
#: man-pages/man2/alloc_hugepages.2:34
#, no-wrap
msgid ""
"B<void *alloc_hugepages(int >I<key>B<, void *>I<addr>B<, size_t >I<len>B<,>\n"
"B<                      int >I<prot>B<, int >I<flag>B<);>\n"
msgstr ""
"B<void *alloc_hugepages(int >I<key>B<, void *>I<addr>B<, size_t >I<len>B<,>"
"\nB<                      int >I<prot>B<, int >I<flag>B<);>\n"

#.  asmlinkage int sys_free_hugepages(unsigned long addr);
#. type: Plain text
#: man-pages/man2/alloc_hugepages.2:37
#, no-wrap
msgid "B<int free_hugepages(void *>I<addr>B<);>\n"
msgstr "B<int free_hugepages(void *>I<addr>B<);>\n"

#. type: Plain text
#: man-pages/man2/alloc_hugepages.2:49
msgid ""
"The system calls B<alloc_hugepages>()  and B<free_hugepages>()  were "
"introduced in Linux 2.5.36 and removed again in 2.5.54.  They existed only "
"on i386 and ia64 (when built with B<CONFIG_HUGETLB_PAGE>).  In Linux 2.4.20,"
" the syscall numbers exist, but the calls fail with the error B<ENOSYS>."
msgstr ""
"Системные вызовы B<alloc_hugepages>() и B<free_hugepages>() появились в Linux "
"2.5.36 и удалены в 2.5.54. Они существовали только на архитектурах i386 и "
"ia64 (при сборке с параметром B<CONFIG_HUGETLB_PAGE>). В Linux 2.4.20 такие "
"номера системных вызовов остались, но сами вызовы завершаются с ошибкой B<"
"ENOSYS>."

#. type: Plain text
#: man-pages/man2/alloc_hugepages.2:57
msgid ""
"On i386 the memory management hardware knows about ordinary pages (4 KiB)  "
"and huge pages (2 or 4 MiB).  Similarly ia64 knows about huge pages of "
"several sizes.  These system calls serve to map huge pages into the "
"process's memory or to free them again.  Huge pages are locked into memory, "
"and are not swapped."
msgstr ""
"На i386 аппаратура управления памятью умеет работать с обычными страницами (4 "
"КиБ) и огромными страницами (2 или 4 МиБ). Подобно этому, ia64 умеет работать "
"с огромными страницами разных размеров. Эти системные вызовы служат для "
"отображения огромных страниц в память процесса или её освобождения. Огромные "
"страницы блокируются в памяти и не могут быть вытеснены в пространство "
"подкачки."

#. type: Plain text
#: man-pages/man2/alloc_hugepages.2:66
msgid ""
"The I<key> argument is an identifier.  When zero the pages are private, and "
"not inherited by children.  When positive the pages are shared with other "
"applications using the same I<key>, and inherited by child processes."
msgstr ""
"Аргумент I<key> служит идентификатором. При нулевом значении страницы "
"считаются частными и не наследуются потомками. При положительном значении "
"страницы совместно используются несколькими приложениями посредством "
"одинакового I<key> и наследуются процессами-потомками."

#. type: Plain text
#: man-pages/man2/alloc_hugepages.2:81
msgid ""
"The I<addr> argument of B<free_hugepages>()  tells which page is being "
"freed: it was the return value of a call to B<alloc_hugepages>().  (The "
"memory is first actually freed when all users have released it.)  The "
"I<addr> argument of B<alloc_hugepages>()  is a hint, that the kernel may or "
"may not follow.  Addresses must be properly aligned."
msgstr ""
"Аргумент I<addr> в B<free_hugepages>() указывает какую страницу нужно "
"освободить: его значением является результат вызова B<alloc_hugepages>(). "
"(Память, на самом деле, освобождается только когда все пользователи её "
"освободят.) Аргумент I<addr> в B<alloc_hugepages>() \\(em это подсказка, "
"которой ядро может и не воспользоваться. Адреса должны быть выровнены "
"соответствующим образом."

#. type: Plain text
#: man-pages/man2/alloc_hugepages.2:86
msgid ""
"The I<len> argument is the length of the required segment.  It must be a "
"multiple of the huge page size."
msgstr ""
"Аргумент I<len> задаёт длину требуемого сегмент. Он должен быть кратен "
"размеру огромной страницы."

#. type: Plain text
#: man-pages/man2/alloc_hugepages.2:94
msgid ""
"The I<prot> argument specifies the memory protection of the segment.  It is "
"one of B<PROT_READ>, B<PROT_WRITE>, B<PROT_EXEC>."
msgstr ""
"Аргумент I<prot> определяет тип защиты сегмента памяти. Может быть указано "
"одно из значений: B<PROT_READ>, B<PROT_WRITE>, B<PROT_EXEC>."

#. type: Plain text
#: man-pages/man2/alloc_hugepages.2:109
msgid ""
"The I<flag> argument is ignored, unless I<key> is positive.  In that case, "
"if I<flag> is B<IPC_CREAT>, then a new huge page segment is created when "
"none with the given key existed.  If this flag is not set, then B<ENOENT> is"
" returned when no segment with the given key exists."
msgstr ""
"Аргумент I<flag> игнорируется, если I<key> не является положительным. В этом "
"случае, если I<flag> \\(em B<IPC_CREAT>, то создаётся новый сегмент огромной "
"страницы, если не существует ни один из указанных идентификаторов. Если флаг "
"не задан, то возвращается B<ENOENT>, если не существует сегмента с заданным "
"идентификатором."

#. type: Plain text
#: man-pages/man2/alloc_hugepages.2:118
msgid ""
"On success, B<alloc_hugepages>()  returns the allocated virtual address, and"
" B<free_hugepages>()  returns zero.  On error, -1 is returned, and I<errno> "
"is set appropriately."
msgstr ""
"При успешном выполнении B<alloc_hugepages>() возвращает выделенный "
"виртуальный адрес, а B<free_hugepages>() возвращает ноль. При ошибке "
"возвращается -1, а I<errno> устанавливается соответствующим образом."

#. type: Plain text
#: man-pages/man2/alloc_hugepages.2:122
msgid "The system call is not supported on this kernel."
msgstr "Системный вызов не поддерживается данным ядром."

#. type: SH
#: man-pages/man2/alloc_hugepages.2:122
#, no-wrap
msgid "FILES"
msgstr "ФАЙЛЫ"

#. type: Plain text
#: man-pages/man2/alloc_hugepages.2:126
msgid ""
"I</proc/sys/vm/nr_hugepages> Number of configured hugetlb pages.  This can "
"be read and written."
msgstr ""
"I</proc/sys/vm/nr_hugepages> Количество настроенных страниц hugetlb. Доступен "
"для чтения и записи."

#. type: Plain text
#: man-pages/man2/alloc_hugepages.2:130
msgid ""
"I</proc/meminfo> Gives info on the number of configured hugetlb pages and on"
" their size in the three variables HugePages_Total, HugePages_Free, "
"Hugepagesize."
msgstr ""
"I</proc/meminfo> Выдаёт информацию о числе настроенных страниц hugetlb и их "
"размере в трёх переменных: HugePages_Total, HugePages_Free, Hugepagesize."

#. type: Plain text
#: man-pages/man2/alloc_hugepages.2:133
msgid ""
"These calls are specific to Linux on Intel processors, and should not be "
"used in programs intended to be portable."
msgstr ""
"Эти вызовы есть только в Linux для процессоров Intel и не должны "
"использоваться в переносимых программах."

#. type: Plain text
#: man-pages/man2/alloc_hugepages.2:141
msgid ""
"These system calls are gone; they existed only in Linux 2.5.36 through to "
"2.5.54.  Now the hugetlbfs filesystem can be used instead.  Memory backed by"
" huge pages (if the CPU supports them) is obtained by using B<mmap>(2)  to "
"map files in this virtual filesystem."
msgstr ""
"Данные системные вызовы были удалены; они существуют только в ядрах Linux "
"версий с 2.5.36 по 2.5.54. Вместо них теперь можно использовать файловую "
"систему hugetlbfs. Память, поддерживаемая огромными страницами (если есть "
"поддержка в ЦП), получается с помощью B<mmap>(2) в отображаемые файлы этой "
"виртуальной файловой системе."

#. type: Plain text
#: man-pages/man2/alloc_hugepages.2:145
msgid ""
"The maximal number of huge pages can be specified using the B<hugepages=> "
"boot parameter."
msgstr ""
"Максимальное число огромных страниц можно задать в параметре загрузки ядра B<"
"hugepages=>."

#. type: TH
#: man-pages/man2/arch_prctl.2:25
#, no-wrap
msgid "ARCH_PRCTL"
msgstr "ARCH_PRCTL"

#. type: TH
#: man-pages/man2/arch_prctl.2:25
#, no-wrap
msgid "2007-12-26"
msgstr "2007-12-26"

#. type: Plain text
#: man-pages/man2/arch_prctl.2:28
msgid "arch_prctl - set architecture-specific thread state"
msgstr "arch_prctl - настроить состояние нити (зависит от архитектуры)"

#. type: Plain text
#: man-pages/man2/arch_prctl.2:31
#, no-wrap
msgid "B<#include E<lt>asm/prctl.hE<gt>>\n"
msgstr "B<#include E<lt>asm/prctl.hE<gt>>\n"

#. type: Plain text
#: man-pages/man2/arch_prctl.2:33
#, no-wrap
msgid "B<#include E<lt>sys/prctl.hE<gt>>\n"
msgstr "B<#include E<lt>sys/prctl.hE<gt>>\n"

#. type: Plain text
#: man-pages/man2/arch_prctl.2:36
#, no-wrap
msgid ""
"B<int arch_prctl(int >I<code>B<, unsigned long >I<addr>B<);>\n"
"B<int arch_prctl(int >I<code>B<, unsigned long *>I<addr>B<);>\n"
msgstr ""
"B<int arch_prctl(int >I<code>B<, unsigned long >I<addr>B<);>\nB<int "
"arch_prctl(int >I<code>B<, unsigned long *>I<addr>B<);>\n"

#. type: Plain text
#: man-pages/man2/arch_prctl.2:52
msgid ""
"The B<arch_prctl>()  function sets architecture-specific process or thread "
"state.  I<code> selects a subfunction and passes argument I<addr> to it; "
"I<addr> is interpreted as either an I<unsigned long> for the \"set\" "
"operations, or as an I<unsigned long\\ *>, for the \"get\" operations."
msgstr ""
"Функция B<arch_prctl>() задаёт состояние процесса или нити, зависящие от "
"архитектуры. В аргументе I<code> выбирается подфункция и ей передаётся "
"значение I<addr>; параметр I<addr> рассматривается либо как I<unsigned long> "
"при операциях «установки», либо как I<unsigned long\\ *> при операциях "
"«получения» значения."

#. type: Plain text
#: man-pages/man2/arch_prctl.2:54
msgid "Subfunctions for x86-64 are:"
msgstr "Подфункции для x86-64:"

#. type: TP
#: man-pages/man2/arch_prctl.2:54
#, no-wrap
msgid "B<ARCH_SET_FS>"
msgstr "B<ARCH_SET_FS>"

#. type: Plain text
#: man-pages/man2/arch_prctl.2:60
msgid "Set the 64-bit base for the I<FS> register to I<addr>."
msgstr "Установить 64-битную базу для регистра I<FS> равной I<addr>."

#. type: TP
#: man-pages/man2/arch_prctl.2:60
#, no-wrap
msgid "B<ARCH_GET_FS>"
msgstr "B<ARCH_GET_FS>"

#. type: Plain text
#: man-pages/man2/arch_prctl.2:68
msgid ""
"Return the 64-bit base value for the I<FS> register of the current thread in"
" the I<unsigned long> pointed to by I<addr>."
msgstr ""
"Вернуть значение 64-битной базы для регистра I<FS> текущей нити в ячейку "
"длинной I<unsigned long>, заданную адресом I<addr>."

#. type: TP
#: man-pages/man2/arch_prctl.2:68
#, no-wrap
msgid "B<ARCH_SET_GS>"
msgstr "B<ARCH_SET_GS>"

#. type: Plain text
#: man-pages/man2/arch_prctl.2:74
msgid "Set the 64-bit base for the I<GS> register to I<addr>."
msgstr "Установить 64-битную базу для регистра I<GS> равной I<addr>."

#. type: TP
#: man-pages/man2/arch_prctl.2:74
#, no-wrap
msgid "B<ARCH_GET_GS>"
msgstr "B<ARCH_GET_GS>"

#. type: Plain text
#: man-pages/man2/arch_prctl.2:82
msgid ""
"Return the 64-bit base value for the I<GS> register of the current thread in"
" the I<unsigned long> pointed to by I<addr>."
msgstr ""
"Вернуть значение 64-битной базы для регистра I<GS> текущей нити в ячейку "
"длинной I<unsigned long>, заданную адресом I<addr>."

#. type: Plain text
#: man-pages/man2/arch_prctl.2:88
msgid ""
"On success, B<arch_prctl>()  returns 0; on error, -1 is returned, and "
"I<errno> is set to indicate the error."
msgstr ""
"При успешном выполнении B<arch_prctl>() возвращает 0; при ошибке \\(em -1, а "
"в I<errno> задаётся причина ошибки."

#. type: Plain text
#: man-pages/man2/arch_prctl.2:93
msgid ""
"I<addr> points to an unmapped address or is outside the process address "
"space."
msgstr ""
"В I<addr> задан не выделенный адрес или вне адресного пространства процесса."

#. type: Plain text
#: man-pages/man2/arch_prctl.2:97
msgid "I<code> is not a valid subcommand."
msgstr "I<code> не является допустимой подкомандой."

#.  .SH AUTHOR
#.  Man page written by Andi Kleen.
#. type: Plain text
#: man-pages/man2/arch_prctl.2:103
msgid "I<addr> is outside the process address space."
msgstr "I<addr> лежит вне адресного пространства процесса."

#. type: Plain text
#: man-pages/man2/arch_prctl.2:107
msgid ""
"B<arch_prctl>()  is a Linux/x86-64 extension and should not be used in "
"programs intended to be portable."
msgstr ""
"B<arch_prctl>() является расширением Linux/x86-64 и не должна использоваться "
"в переносимых программах."

#. type: Plain text
#: man-pages/man2/arch_prctl.2:110
msgid ""
"B<arch_prctl>()  is supported only on Linux/x86-64 for 64-bit programs "
"currently."
msgstr ""
"В настоящее время B<arch_prctl>() поддерживается только на Linux/x86-64 для "
"64-битных программ."

#. type: Plain text
#: man-pages/man2/arch_prctl.2:112
msgid "The 64-bit base changes when a new 32-bit segment selector is loaded."
msgstr ""
"64-битная база изменяется при загрузке нового 32-битного сегментного "
"селектора."

#. type: Plain text
#: man-pages/man2/arch_prctl.2:115
msgid "B<ARCH_SET_GS> is disabled in some kernels."
msgstr "B<ARCH_SET_GS> выключена в некоторых ядрах."

#. type: Plain text
#: man-pages/man2/arch_prctl.2:130
msgid ""
"Context switches for 64-bit segment bases are rather expensive.  It may be a"
" faster alternative to set a 32-bit base using a segment selector by setting"
" up an LDT with B<modify_ldt>(2)  or using the B<set_thread_area>(2)  system"
" call in kernel 2.5 or later.  B<arch_prctl>()  is needed only when you want"
" to set bases that are larger than 4GB.  Memory in the first 2GB of address "
"space can be allocated by using B<mmap>(2)  with the B<MAP_32BIT> flag."
msgstr ""
"Переключение контекстов для 64-битных сегментных баз \\(em довольно затратная "
"операция. Может оказаться быстрее задать 32-битную базу с помощью сегментного "
"селектора, настроив LDT с помощью B<modify_ldt>(2) или используя системный "
"вызов B<set_thread_area>(2), появившийся в kernel 2.5 или новее. B<arch_prctl>"
"() нужна только когда вы хотите задать базы, которые более 4ГБ. Память в "
"первых 2ГБ адресного пространства может быть выделена через B<mmap>(2) с "
"флагом B<MAP_32BIT>."

#. type: Plain text
#: man-pages/man2/arch_prctl.2:135
msgid ""
"As of version 2.7, glibc provides no prototype for B<arch_prctl>().  You "
"have to declare it yourself for now.  This may be fixed in future glibc "
"versions."
msgstr ""
"В glibc версии 2.7 нет прототипа для B<arch_prctl>(). Вам нужно объявлять его "
"самостоятельно. Это может быть исправлено в новых версиях glibc."

#. type: Plain text
#: man-pages/man2/arch_prctl.2:138
msgid "I<FS> may be already used by the threading library."
msgstr "I<FS> уже может использоваться библиотекой нитей."

#. type: Plain text
#: man-pages/man2/arch_prctl.2:143
msgid "B<mmap>(2), B<modify_ldt>(2), B<prctl>(2), B<set_thread_area>(2)"
msgstr "B<mmap>(2), B<modify_ldt>(2), B<prctl>(2), B<set_thread_area>(2)"

#. type: Plain text
#: man-pages/man2/arch_prctl.2:144
msgid "AMD X86-64 Programmer's manual"
msgstr "Руководство программиста для AMD X86-64"

#. type: TH
#: man-pages/man5/acct.5:25
#, no-wrap
msgid "2008-06-15"
msgstr "2008-06-15"

#. type: Plain text
#: man-pages/man5/acct.5:28
msgid "acct - process accounting file"
msgstr "acct - файл учёта процессов"

#. type: Plain text
#: man-pages/man5/acct.5:30
msgid "B<#include E<lt>sys/acct.hE<gt>>"
msgstr "B<#include E<lt>sys/acct.hE<gt>>"

#. type: Plain text
#: man-pages/man5/acct.5:36
msgid ""
"If the kernel is built with the process accounting option enabled "
"(B<CONFIG_BSD_PROCESS_ACCT>), then calling B<acct>(2)  starts process "
"accounting, for example:"
msgstr ""
"Если ядро собрано с включённым параметром учёта процессов (B<"
"CONFIG_BSD_PROCESS_ACCT>), то системный вызов B<acct>(2) запустит учёт "
"процесса:"

#. type: Plain text
#: man-pages/man5/acct.5:39
msgid "acct(\"/var/log/pacct\");"
msgstr "acct(\"/var/log/pacct\");"

#. type: Plain text
#: man-pages/man5/acct.5:47
msgid ""
"When process accounting is enabled, the kernel writes a record to the "
"accounting file as each process on the system terminates.  This record "
"contains information about the terminated process, and is defined in "
"I<E<lt>sys/acct.hE<gt>> as follows:"
msgstr ""
"При включённом учёте процессов, ядро делает запись в файл учёта по каждому "
"процессу системы по его завершении. Эта запись содержит информацию о "
"завершённом процессе и определена в I<E<lt>sys/acct.hE<gt>> следующим образом:"

#. type: Plain text
#: man-pages/man5/acct.5:51
#, no-wrap
msgid "#define ACCT_COMM 16\n"
msgstr "#define ACCT_COMM 16\n"

#. type: Plain text
#: man-pages/man5/acct.5:53
#, no-wrap
msgid "typedef u_int16_t comp_t;\n"
msgstr "typedef u_int16_t comp_t;\n"

#. type: Plain text
#: man-pages/man5/acct.5:77
#, no-wrap
msgid ""
"struct acct {\n"
"    char ac_flag;           /* Accounting flags */\n"
"    u_int16_t ac_uid;       /* Accounting user ID */\n"
"    u_int16_t ac_gid;       /* Accounting group ID */\n"
"    u_int16_t ac_tty;       /* Controlling terminal */\n"
"    u_int32_t ac_btime;     /* Process creation time\n"
"                               (seconds since the Epoch) */\n"
"    comp_t    ac_utime;     /* User CPU time */\n"
"    comp_t    ac_stime;     /* System CPU time */\n"
"    comp_t    ac_etime;     /* Elapsed time */\n"
"    comp_t    ac_mem;       /* Average memory usage (kB) */\n"
"    comp_t    ac_io;        /* Characters transferred (unused) */\n"
"    comp_t    ac_rw;        /* Blocks read or written (unused) */\n"
"    comp_t    ac_minflt;    /* Minor page faults */\n"
"    comp_t    ac_majflt;    /* Major page faults */\n"
"    comp_t    ac_swaps;     /* Number of swaps (unused) */\n"
"    u_int32_t ac_exitcode;  /* Process termination status\n"
"                               (see wait(2)) */\n"
"    char      ac_comm[ACCT_COMM+1];\n"
"                            /* Command name (basename of last\n"
"                               executed command; null-terminated) */\n"
"    char      ac_pad[I<X>];    /* padding bytes */\n"
"};\n"
msgstr ""
"struct acct {\n    char ac_flag;           /* флаги учёта */\n    u_int16_t "
"ac_uid;       /* ID пользователя */\n    u_int16_t ac_gid;       /* ID группы "
"*/\n    u_int16_t ac_tty;       /* управляющий терминал */\n    u_int32_t "
"ac_btime;     /* время создания процесса\n                               (в "
"секундах с начала эпохи) */\n    comp_t    ac_utime;     /* время работы ЦП в "
"пользовательском режиме */\n    comp_t    ac_stime;     /* время работы ЦП в "
"системном режиме */\n    comp_t    ac_etime;     /* прошедшее время */\n    "
"comp_t    ac_mem;       /* среднее количество использованной памяти (КБ) */\n "
"   comp_t    ac_io;        /* передано символов (не используется) */\n    "
"comp_t    ac_rw;        /* прочитано или записано блоков (не используется) "
"*/\n    comp_t    ac_minflt;    /* промахи для вспомогательных страниц */\n   "
" comp_t    ac_majflt;    /* промахи для главных страниц */\n    comp_t    "
"ac_swaps;     /* количество подкачек (не используется) */\n    u_int32_t "
"ac_exitcode;  /* код завершения процесса\n                               (см. "
"wait(2)) */\n    char      ac_comm[ACCT_COMM+1];\n                            "
"/* имя команды (basename от последней\n                               "
"исполнявшейся команды; завершается null) */\n    char      ac_pad[I<X>];    "
"/* байты заполнения */\n};\n"

#. type: Plain text
#: man-pages/man5/acct.5:84
#, no-wrap
msgid ""
"enum {          /* Bits that may be set in ac_flag field */\n"
"    AFORK = 0x01,           /* Has executed fork, but no exec */\n"
"    ASU   = 0x02,           /* Used superuser privileges */\n"
"    ACORE = 0x08,           /* Dumped core */\n"
"    AXSIG = 0x10            /* Killed by a signal */\n"
"};\n"
msgstr ""
"enum {                      /* биты для поля ac_flag */\n    AFORK = 0x01,    "
"       /* был выполнен fork, но не exec */\n    ASU   = 0x02,           /* "
"использовались права суперпользователя */\n    ACORE = 0x08,           /* "
"создан файл core */\n    AXSIG = 0x10            /* завершён по сигналу "
"*/\n};\n"

#. type: Plain text
#: man-pages/man5/acct.5:94
msgid ""
"The I<comp_t> data type is a floating-point value consisting of a 3-bit, "
"base-8 exponent, and a 13-bit mantissa.  A value, I<c>, of this type can be "
"converted to a (long) integer as follows:"
msgstr ""
"Тип данных I<comp_t> \\(em это число с плавающей точкой, состоящее из "
"3-битной экспоненты по основанию 8 и 13-битной мантиссы. Переменная I<c> "
"этого типа может быть преобразована к целому (long) так:"

#. type: Plain text
#: man-pages/man5/acct.5:97
#, no-wrap
msgid "    v = (c & 0x1fff) E<lt>E<lt> (((c E<gt>E<gt> 13) & 0x7) * 3);\n"
msgstr "    v = (c & 0x1fff) E<lt>E<lt> (((c E<gt>E<gt> 13) & 0x7) * 3);\n"

#. type: Plain text
#: man-pages/man5/acct.5:107
msgid ""
"The I<ac_utime>, I<ac_stime>, and I<ac_etime> fields measure time in \"clock"
" ticks\"; divide these values by I<sysconf(_SC_CLK_TCK)> to convert them to "
"seconds."
msgstr ""
"Поля I<ac_utime>, I<ac_stime> и I<ac_etime> хранят время в \"тактах часов\"; "
"для преобразования в секунды нужно поделить значение на I<"
"sysconf(_SC_CLK_TCK)>."

#. type: SS
#: man-pages/man5/acct.5:107
#, no-wrap
msgid "Version 3 accounting file format"
msgstr "Формат файла учёта версии 3"

#. type: Plain text
#: man-pages/man5/acct.5:122
msgid ""
"Since kernel 2.6.8, an optional alternative version of the accounting file "
"can be produced if the B<CONFIG_BSD_PROCESS_ACCT_V3> option is set when "
"building the kernel.  With this option is set, the records written to the "
"accounting file contain additional fields, and the width of I<c_uid> and "
"I<ac_gid> fields is widened from 16 to 32 bits (in line with the increased "
"size of UID and GIDs in Linux 2.4 and later).  The records are defined as "
"follows:"
msgstr ""
"Начиная с ядра версии 2.6.8, можно создавать файл учёта альтернативной "
"версии, если задать параметр B<CONFIG_BSD_PROCESS_ACCT_V3> при сборке ядра. "
"Если этот параметр установлен, то записи, сохранённые в файле учёта, будут "
"содержать дополнительные поля, а ширина полей I<c_uid> и I<ac_gid> будет "
"расширена с 16 до 32 бит (для соответствия с увеличенным размером UID и GID в "
"Linux 2.4 и новее). Записи определены следующим образом:"

#. type: Plain text
#: man-pages/man5/acct.5:147
#, no-wrap
msgid ""
"struct acct_v3 {\n"
"    char      ac_flag;      /* Flags */\n"
"    char      ac_version;   /* Always set to ACCT_VERSION (3) */\n"
"    u_int16_t ac_tty;       /* Controlling terminal */\n"
"    u_int32_t ac_exitcode;  /* Process termination status */\n"
"    u_int32_t ac_uid;       /* Real user ID */\n"
"    u_int32_t ac_gid;       /* Real group ID */\n"
"    u_int32_t ac_pid;       /* Process ID */\n"
"    u_int32_t ac_ppid;      /* Parent process ID */\n"
"    u_int32_t ac_btime;     /* Process creation time */\n"
"    float     ac_etime;     /* Elapsed time */\n"
"    comp_t    ac_utime;     /* User CPU time */\n"
"    comp_t    ac_stime;     /* System time */\n"
"    comp_t    ac_mem;       /* Average memory usage (kB) */\n"
"    comp_t    ac_io;        /* Characters transferred (unused) */\n"
"    comp_t    ac_rw;        /* Blocks read or written\n"
"                               (unused) */\n"
"    comp_t    ac_minflt;    /* Minor page faults */\n"
"    comp_t    ac_majflt;    /* Major page faults */\n"
"    comp_t    ac_swaps;     /* Number of swaps (unused) */\n"
"    char      ac_comm[ACCT_COMM]; /* Command name */\n"
"};\n"
msgstr ""
"struct acct_v3 {\n    char      ac_flag;      /* флаги */\n    char      "
"ac_version;   /* всегда равно ACCT_VERSION (3) */\n    u_int16_t ac_tty;      "
" /* управляющий терминал */\n    u_int32_t ac_exitcode;  /* код завершения "
"процесса\n    u_int32_t ac_uid;       /* реальный ID пользователя */\n    "
"u_int32_t ac_gid;       /* реальный ID группы */\n    u_int32_t ac_pid;       "
"/* ID процесса */\n    u_int32_t ac_ppid;      /* ID родительского процесса "
"*/\n    u_int32_t ac_btime;     /* время создания процесса\n    float     "
"ac_etime;     /* прошедшее время */\n    comp_t    ac_utime;     /* время "
"работы ЦП в пользовательском режиме */\n    comp_t    ac_stime;     /* время "
"работы ЦП в системном режиме */\n    comp_t    ac_mem;       /* среднее "
"количество использованной памяти (КБ) */\n    comp_t    ac_io;        /* "
"передано символов (не используется) */\n    comp_t    ac_rw;        /* "
"прочитано или записано блоков\n                            (не используется) "
"*/\n    comp_t    ac_minflt;    /* промахи для вспомогательных страниц */\n   "
" comp_t    ac_majflt;    /* промахи для главных страниц */\n    comp_t    "
"ac_swaps;     /* количество подкачек (не используется) */\n    char      "
"ac_comm[ACCT_COMM]; /* имя команды */\n};\n"

#. type: Plain text
#: man-pages/man5/acct.5:153
msgid "The I<acct_v3> structure is defined in glibc since version 2.6."
msgstr "Структура I<acct_v3> определена в glibc начиная с версии 2.6."

#. type: Plain text
#: man-pages/man5/acct.5:157
msgid ""
"Process accounting originated on BSD.  Although it is present on most "
"systems, it is not standardized, and the details vary somewhat between "
"systems."
msgstr ""
"Учёт процессов возник в BSD. Хотя он есть в большинстве систем, он не "
"стандартизован, и параметры разнятся между системами."

#. type: Plain text
#: man-pages/man5/acct.5:160
msgid ""
"Records in the accounting file are ordered by termination time of the "
"process."
msgstr "Записи в файле учёта упорядочены по времени завершения процессов."

#. type: Plain text
#: man-pages/man5/acct.5:167
msgid ""
"In kernels up to and including 2.6.9, a separate accounting record is "
"written for each thread created using the NPTL threading library; since "
"Linux 2.6.10, a single accounting record is written for the entire process "
"on termination of the last thread in the process."
msgstr ""
"В ядрах до версии 2.6.9 включительно, с помощью библиотеки нитей NPTL для "
"каждой нити сохранялась своя запись учёта; начиная с Linux 2.6.10 отдельная "
"запись сохраняется для всего процесса при завершении работы его последней "
"нити."

#. type: Plain text
#: man-pages/man5/acct.5:174
msgid ""
"The I<proc/sys/kernel/acct> file, described in B<proc>(5), defines settings "
"that control the behavior of process accounting when disk space runs low."
msgstr ""
"В файле I<proc/sys/kernel/acct>, описанном в B<proc>(5), определены "
"настройки, которые управляют поведением учёта процессов при нехватке места на "
"диске."

#. type: Plain text
#: man-pages/man5/acct.5:178
msgid "B<lastcomm>(1), B<acct>(2), B<accton>(8), B<sa>(8)"
msgstr "B<lastcomm>(1), B<acct>(2), B<accton>(8), B<sa>(8)"

#. type: TH
#: man-pages/man3/addseverity.3:9
#, no-wrap
msgid "ADDSEVERITY"
msgstr "ADDSEVERITY"

#. type: TH
#: man-pages/man3/addseverity.3:9
#, no-wrap
msgid "2008-06-14"
msgstr "2008-06-14"

#. type: TH
#: man-pages/man3/addseverity.3:9
#, no-wrap
msgid "GNU"
msgstr "GNU"

#. type: Plain text
#: man-pages/man3/addseverity.3:12
msgid "addseverity - introduce new severity classes"
msgstr "addseverity - объявление новых классов критичности"

#. type: Plain text
#: man-pages/man3/addseverity.3:16
#, no-wrap
msgid "B<#include E<lt>fmtmsg.hE<gt>>\n"
msgstr "B<#include E<lt>fmtmsg.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/addseverity.3:18
#, no-wrap
msgid "B<int addseverity(int >I<severity>B<, const char *>I<s>B<);>\n"
msgstr "B<int addseverity(int >I<severity>B<, const char *>I<s>B<);>\n"

#. type: Plain text
#: man-pages/man3/addseverity.3:27
msgid "B<addseverity>(): _SVID_SOURCE"
msgstr "B<addseverity>(): _SVID_SOURCE"

#. type: Plain text
#: man-pages/man3/addseverity.3:49
msgid ""
"This function allows the introduction of new severity classes which can be "
"addressed by the I<severity> argument of the B<fmtmsg>(3)  function.  By "
"default that latter function only knows how to print messages for severity "
"0-4 (with strings (none), HALT, ERROR, WARNING, INFO).  This call attaches "
"the given string I<s> to the given value I<severity>.  If I<s> is NULL, the "
"severity class with the numeric value I<severity> is removed.  It is not "
"possible to overwrite or remove one of the default severity classes.  The "
"severity value must be nonnegative."
msgstr ""
"Эта функция позволяет добавить новые классы критичности (severity), которые "
"могут передаваться в аргументе I<severity> функции B<fmtmsg>(3). По "
"умолчанию, функция B<fmtmsg>(3) позволяет выводить сообщения с уровнями "
"критичности 0-4 (со строками (и без), HALT, ERROR, WARNING, INFO). "
"Описываемая здесь функция связывает указанную строку I<s> с заданным "
"значением критичности I<severity>. Если значение I<s> равно NULL, то класс "
"критичности с числовым значением I<severity> будет удалён. Невозможно "
"изменить или удалить классы критичности по умолчанию. Значение критичности "
"должно быть положительным."

#. type: Plain text
#: man-pages/man3/addseverity.3:57
msgid ""
"Upon success, the value B<MM_OK> is returned.  Upon error, the return value "
"is B<MM_NOTOK>.  Possible errors include: out of memory, attempt to remove a"
" nonexistent or default severity class."
msgstr ""
"При успешном выполнении возвращается значение B<MM_OK>. При ошибке "
"возвращаемое значение равно B<MM_NOTOK>. Возможные ошибки: нехватка памяти, "
"попытка удалить несуществующий класс или класс критичности по умолчанию."

#. type: Plain text
#: man-pages/man3/addseverity.3:60
msgid "B<addseverity>()  is provided in glibc since version 2.1."
msgstr "Функция B<addseverity>() появилась в glibc начиная с версии 2.1."

#. type: Plain text
#: man-pages/man3/addseverity.3:67
msgid ""
"This function is not specified in the X/Open Portability Guide although the "
"B<fmtmsg>(3)  function is.  It is available on System V systems."
msgstr ""
"Эта функция не определена в X/Open Portability Guide, хотя в нём есть функция "
"B<fmtmsg>(3). Она доступна в системах System V."

#. type: Plain text
#: man-pages/man3/addseverity.3:70
msgid ""
"New severity classes can also be added by setting the environment variable "
"B<SEV_LEVEL>."
msgstr ""
"Также, новые классы критичности можно добавить создав переменную окружения B<"
"SEV_LEVEL>."

#. type: Plain text
#: man-pages/man3/addseverity.3:71
msgid "B<fmtmsg>(3)"
msgstr "B<fmtmsg>(3)"

#. type: TH
#: man-pages/man3/aio_fsync.3:24
#, no-wrap
msgid "AIO_FSYNC"
msgstr "AIO_FSYNC"

#. type: TH
#: man-pages/man3/aio_fsync.3:24
#, no-wrap
msgid "2012-05-08"
msgstr "2012-05-08"

#. type: Plain text
#: man-pages/man3/aio_fsync.3:27
msgid "aio_fsync - asynchronous file synchronization"
msgstr "aio_fsync - асинхронная файловая синхронизация"

#. type: Plain text
#: man-pages/man3/aio_fsync.3:29
msgid "B<#include E<lt>aio.hE<gt>>"
msgstr "B<#include E<lt>aio.hE<gt>>"

#. type: Plain text
#: man-pages/man3/aio_fsync.3:31
msgid "B<int aio_fsync(int >I<op>B<, struct aiocb *>I<aiocbp>B<);>"
msgstr "B<int aio_fsync(int >I<op>B<, struct aiocb *>I<aiocbp>B<);>"

#. type: Plain text
#: man-pages/man3/aio_fsync.3:33
msgid "Link with I<-lrt>."
msgstr "Компонуется при указании параметра I<-lrt>."

#. type: Plain text
#: man-pages/man3/aio_fsync.3:44
msgid ""
"The B<aio_fsync>()  function does a sync on all outstanding asynchronous I/O"
" operations associated with I<aiocbp-E<gt>aio_fildes>.  (See B<aio>(7)  for "
"a description of the I<aiocb> structure.)"
msgstr ""
"Функция B<aio_fsync>() выполняет синхронизацию всех ожидающих выполнения "
"асинхронных операций ввода-вывода, связанных с I<aiocbp-E<gt>aio_fildes> "
"(описание структуры I<aiocb> смотрите в B<aio>(7))."

#. type: Plain text
#: man-pages/man3/aio_fsync.3:58
msgid ""
"More precisely, if I<op> is B<O_SYNC>, then all currently queued I/O "
"operations shall be completed as if by a call of B<fsync>(2), and if I<op> "
"is B<O_DSYNC>, this call is the asynchronous analog of B<fdatasync>(2)."
msgstr ""
"Более точно, если значение I<op> равно B<O_SYNC>, то все операции "
"ввода-вывода в очереди будут выполнены, как если бы сработал вызов B<fsync>"
"(2), а если I<op> равно B<O_DSYNC>, то данная функция является асинхронным "
"аналогом B<fdatasync>(2)."

#. type: Plain text
#: man-pages/man3/aio_fsync.3:60
msgid "Note that this is a request only; it does not wait for I/O completion."
msgstr ""
"Заметим, что это только запрос; функция не ожидает завершения выполнения "
"ввода-вывода."

#. type: Plain text
#: man-pages/man3/aio_fsync.3:73
msgid ""
"Apart from I<aio_fildes>, the only field in the structure pointed to by "
"I<aiocbp> that is used by this call is the I<aio_sigevent> field (a "
"I<sigevent> structure, described in B<sigevent>(7)), which indicates the "
"desired type of asynchronous notification at completion.  All other fields "
"are ignored."
msgstr ""
"Кроме I<aio_fildes>, в структуре I<aiocbp> используется только поле I<"
"aio_sigevent> (структура I<sigevent> описана в B<sigevent>(7)), в котором "
"указывается желаемый тип асинхронного уведомления по завершению. Все "
"остальные поля игнорируются."

#. type: Plain text
#: man-pages/man3/aio_fsync.3:79
msgid ""
"On success (the sync request was successfully queued)  this function returns"
" 0.  On error, -1 is returned, and I<errno> is set appropriately."
msgstr ""
"При успешном выполнении (запрос синхронизации добавлен в очередь) данная "
"функция возвращает 0. При ошибке возвращается -1, а значение I<errno> "
"устанавливается соответствующим образом."

#. type: TP
#: man-pages/man3/aio_fsync.3:80
#, no-wrap
msgid "B<EAGAIN>"
msgstr "B<EAGAIN>"

#. type: Plain text
#: man-pages/man3/aio_fsync.3:83
msgid "Out of resources."
msgstr "Не хватает ресурсов."

#. type: Plain text
#: man-pages/man3/aio_fsync.3:87
msgid "I<aio_fildes> is not a valid file descriptor open for writing."
msgstr ""
"Значение I<aio_fildes> не является правильным файловым дескриптором, открытым "
"для записи."

#. type: Plain text
#: man-pages/man3/aio_fsync.3:95
msgid ""
"Synchronized I/O is not supported for this file, or I<op> is not B<O_SYNC> "
"or B<O_DSYNC>."
msgstr ""
"Синхронизированный ввод-вывод не поддерживается для этого файла, или значение "
"I<op> не равно B<O_SYNC> или B<O_DSYNC>."

#. type: Plain text
#: man-pages/man3/aio_fsync.3:99
msgid "B<aio_fsync>()  is not implemented."
msgstr "Функция B<aio_fsync>() не реализована."

#. type: Plain text
#: man-pages/man3/aio_fsync.3:103
msgid "The B<aio_fsync>()  function is available since glibc 2.1."
msgstr "Функция B<aio_fsync>() доступна в glibc начиная с версии 2.1."

#. type: Plain text
#: man-pages/man3/aio_fsync.3:114
msgid ""
"B<aio_cancel>(3), B<aio_error>(3), B<aio_read>(3), B<aio_return>(3), "
"B<aio_suspend>(3), B<aio_write>(3), B<lio_listio>(3), B<aio>(7), "
"B<sigevent>(7)"
msgstr ""
"B<aio_cancel>(3), B<aio_error>(3), B<aio_read>(3), B<aio_return>(3), B<"
"aio_suspend>(3), B<aio_write>(3), B<lio_listio>(3), B<aio>(7), B<sigevent>(7)"

#. type: TH
#: man-pages/man3/aio_error.3:24
#, no-wrap
msgid "AIO_ERROR"
msgstr "AIO_ERROR"

#. type: TH
#: man-pages/man3/aio_error.3:24
#, no-wrap
msgid "2013-07-04"
msgstr "2013-07-04"

#. type: Plain text
#: man-pages/man3/aio_error.3:27
msgid "aio_error - get error status of asynchronous I/O operation"
msgstr ""
"aio_error - возвращает состояние ошибки операции асинхронного ввода/вывода"

#. type: Plain text
#: man-pages/man3/aio_error.3:31
msgid "B<int aio_error(const struct aiocb *>I<aiocbp>B<);>"
msgstr "B<int aio_error(const struct aiocb *>I<aiocbp>B<);>"

#. type: Plain text
#: man-pages/man3/aio_error.3:44
msgid ""
"The B<aio_error>()  function returns the error status for the asynchronous "
"I/O request with control block pointed to by I<aiocbp>.  (See B<aio>(7)  for"
" a description of the I<aiocb> structure.)"
msgstr ""
"Функция B<aio_error>() возвращает состояние ошибки запроса асинхронного "
"ввода-вывода для указанного блока управления I<aiocbp> (описание структуры I<"
"aiocb> смотрите в B<aio>(7))."

#. type: Plain text
#: man-pages/man3/aio_error.3:46
msgid "This function returns one of the following:"
msgstr "Функция возвращает одно из следующих значений:"

#. type: IP
#: man-pages/man3/aio_error.3:46 man-pages/man3/aio_error.3:50
#: man-pages/man3/aio_error.3:53 man-pages/man3/aio_error.3:55
#, no-wrap
msgid "*"
msgstr "*"

#. type: Plain text
#: man-pages/man3/aio_error.3:50
msgid "B<EINPROGRESS>, if the request has not been completed yet."
msgstr "B<EINPROGRESS>, если запрос ещё не выполнен."

#. type: Plain text
#: man-pages/man3/aio_error.3:53
msgid "B<ECANCELED>, if the request was canceled."
msgstr "B<ECANCELED>, если запрос отменён."

#. type: Plain text
#: man-pages/man3/aio_error.3:55
msgid "0, if the request completed successfully."
msgstr "0, если запрос выполнен без ошибок."

#. type: Plain text
#: man-pages/man3/aio_error.3:66
msgid ""
"A positive error number, if the asynchronous I/O operation failed.  This is "
"the same value that would have been stored in the I<errno> variable in the "
"case of a synchronous B<read>(2), B<write>(2), B<fsync>(2), or "
"B<fdatasync>(2)  call."
msgstr ""
"Если асинхронная операция ввода-вывода завершилась с ошибкой, то возвращается "
"положительное число. Это тоже значение, которое сохраняется в переменной I<"
"errno> при синхронном вызове B<read>(2), B<write>(2), B<fsync>(2) или B<"
"fdatasync>(2)."

#. type: Plain text
#: man-pages/man3/aio_error.3:74
msgid ""
"I<aiocbp> does not point at a control block for an asynchronous I/O request "
"of which the return status (see B<aio_return>(3))  has not been retrieved "
"yet."
msgstr ""
"Значение I<aiocbp> не указывает на блок управления запросом асинхронного "
"ввода-вывода, значение результата которого ещё не получено (смотрите B<"
"aio_return>(3))."

#. type: Plain text
#: man-pages/man3/aio_error.3:78
msgid "B<aio_error>()  is not implemented."
msgstr "Функция B<aio_error>() не реализована."

#. type: Plain text
#: man-pages/man3/aio_error.3:82
msgid "The B<aio_error>()  function is available since glibc 2.1."
msgstr "Функция B<aio_error>() доступна в glibc начиная с версии 2.1."

#. type: SH
#: man-pages/man3/aio_error.3:82
#, no-wrap
msgid "ATTRIBUTES"
msgstr "АТРИБУТЫ"

#. type: SS
#: man-pages/man3/aio_error.3:83
#, no-wrap
msgid "Multithreading (see pthreads(7))"
msgstr "Многонитевость (смотрите pthreads(7))"

#. type: Plain text
#: man-pages/man3/aio_error.3:87
msgid "The B<aio_error>()  function is thread-safe."
msgstr ""
"Функцию B<aio_error>() можно использовать в нескольких нитях одновременно."

#. type: Plain text
#: man-pages/man3/aio_error.3:92
msgid "See B<aio>(7)."
msgstr "Смотрите B<aio>(7)."

#. type: Plain text
#: man-pages/man3/aio_error.3:100
msgid ""
"B<aio_cancel>(3), B<aio_fsync>(3), B<aio_read>(3), B<aio_return>(3), "
"B<aio_suspend>(3), B<aio_write>(3), B<lio_listio>(3), B<aio>(7)"
msgstr ""
"B<aio_cancel>(3), B<aio_fsync>(3), B<aio_read>(3), B<aio_return>(3), B<"
"aio_suspend>(3), B<aio_write>(3), B<lio_listio>(3), B<aio>(7)"

#. type: TH
#: man-pages/man3/asprintf.3:27
#, no-wrap
msgid "ASPRINTF"
msgstr "ASPRINTF"

#. type: TH
#: man-pages/man3/asprintf.3:27
#, no-wrap
msgid "2013-06-21"
msgstr "2013-06-21"

#. type: Plain text
#: man-pages/man3/asprintf.3:30
msgid "asprintf, vasprintf - print to allocated string"
msgstr "asprintf, vasprintf - выводит данные в строку, выделенную в памяти"

#. type: Plain text
#: man-pages/man3/asprintf.3:32
msgid "B<#define _GNU_SOURCE> /* See feature_test_macros(7) */"
msgstr "B<#define _GNU_SOURCE> /* смотрите feature_test_macros(7) */"

#. type: Plain text
#: man-pages/man3/asprintf.3:34
msgid "B<#include E<lt>stdio.hE<gt>>"
msgstr "B<#include E<lt>stdio.hE<gt>>"

#. type: Plain text
#: man-pages/man3/asprintf.3:36
msgid "B<int asprintf(char **>I<strp>B<, const char *>I<fmt>B<, ...);>"
msgstr "B<int asprintf(char **>I<strp>B<, const char *>I<fmt>B<, ...);>"

#. type: Plain text
#: man-pages/man3/asprintf.3:38
msgid ""
"B<int vasprintf(char **>I<strp>B<, const char *>I<fmt>B<, va_list "
">I<ap>B<);>"
msgstr ""
"B<int vasprintf(char **>I<strp>B<, const char *>I<fmt>B<, va_list >I<ap>B<);>"

#. type: Plain text
#: man-pages/man3/asprintf.3:53
msgid ""
"The functions B<asprintf>()  and B<vasprintf>()  are analogs of "
"B<sprintf>(3)  and B<vsprintf>(3), except that they allocate a string large "
"enough to hold the output including the terminating null byte "
"(\\(aq\\e0\\(aq), and return a pointer to it via the first argument.  This "
"pointer should be passed to B<free>(3)  to release the allocated storage "
"when it is no longer needed."
msgstr ""
"Функции B<asprintf> и B<vasprintf> являются аналогами B<sprintf>(3) и B<"
"vsprintf>(3), отличаясь только тем, что они выделяют в памяти строку, "
"достаточную для размещения результата, включая конечный байт null "
"(\\(aq\\e0\\(aq), и возвращают указатель на эту строку через первый аргумент. "
"Для высвобождения выделенной памяти указатель должен быть передан функции B<"
"free>(3)."

#. type: Plain text
#: man-pages/man3/asprintf.3:61
msgid ""
"When successful, these functions return the number of bytes printed, just "
"like B<sprintf>(3).  If memory allocation wasn't possible, or some other "
"error occurs, these functions will return -1, and the contents of I<strp> is"
" undefined."
msgstr ""
"При успешном выполнении эти функции, подобно B<sprintf>(3), возвращают "
"количество выведенных байтов. Если выделить память не удалось или произошла "
"какая-либо другая ошибка, то эти функции возвращают -1. При этом содержимое "
"I<strp> не определено."

#. type: Plain text
#: man-pages/man3/asprintf.3:67
msgid ""
"These functions are GNU extensions, not in C or POSIX.  They are also "
"available under *BSD.  The FreeBSD implementation sets I<strp> to NULL on "
"error."
msgstr ""
"Эти функции являются расширениями GNU, они отсутствуют в C и POSIX. Также они "
"доступны в *BSD. В FreeBSD при ошибке I<strp> присваивается значение NULL."

#. type: Plain text
#: man-pages/man3/asprintf.3:70
msgid "B<free>(3), B<malloc>(3), B<printf>(3)"
msgstr "B<free>(3), B<malloc>(3), B<printf>(3)"

#. type: TH
#: man-pages/man3/aio_read.3:24
#, no-wrap
msgid "AIO_READ"
msgstr "AIO_READ"

#. type: Plain text
#: man-pages/man3/aio_read.3:27
msgid "aio_read - asynchronous read"
msgstr "aio_read - асинхронное чтение"

#. type: Plain text
#: man-pages/man3/aio_read.3:31
msgid "B<int aio_read(struct aiocb *>I<aiocbp>B<);>"
msgstr "B<int aio_read(struct aiocb *>I<aiocbp>B<);>"

#. type: Plain text
#: man-pages/man3/aio_read.3:41
msgid ""
"The B<aio_read>()  function queues the I/O request described by the buffer "
"pointed to by I<aiocbp>.  This function is the asynchronous analog of "
"B<read>(2).  The arguments of the call"
msgstr ""
"Функция B<aio_read>() ставит в очередь запрос ввода-вывода, описанный в "
"буфере, на который указывает I<aiocbp>. Эта функция является асинхронным "
"аналогом вызова B<read>(2). Аргументы функции"

#. type: Plain text
#: man-pages/man3/aio_read.3:43
#, no-wrap
msgid "    read(fd, buf, count)\n"
msgstr "    read(fd, buf, count)\n"

#. type: Plain text
#: man-pages/man3/aio_read.3:56
msgid ""
"correspond (in order) to the fields I<aio_fildes>, I<aio_buf>, and "
"I<aio_nbytes> of the structure pointed to by I<aiocbp>.  (See B<aio>(7)  for"
" a description of the I<aiocb> structure.)"
msgstr ""
"соответствуют (в указанном порядке) полям I<aio_fildes>, I<aio_buf> и I<"
"aio_nbytes> структуры, на которую указывает I<aiocbp> (описание структуры I<"
"aiocb> смотрите в B<aio>(7))."

#. type: Plain text
#: man-pages/man3/aio_read.3:62
msgid ""
"The data is read starting at the absolute file offset "
"I<aiocbp-E<gt>aio_offset>, regardless of the current file offset.  After the"
" call, the value of the current file offset is unspecified."
msgstr ""
"Чтение данных выполняется начиная с абсолютного смещения в файле I<"
"aiocbp-E<gt>aio_offset>, независимо от текущего смещения в файле. После "
"вызова значение текущего смещения в файле не определено."

#. type: Plain text
#: man-pages/man3/aio_read.3:75
msgid ""
"The \"asynchronous\" means that this call returns as soon as the request has"
" been enqueued; the read may or may not have completed when the call "
"returns.  One tests for completion using B<aio_error>(3).  The return status"
" of a completed I/O operation can be obtained by B<aio_return>(3).  "
"Asynchronous notification of I/O completion can be obtained by setting "
"I<aiocbp-E<gt>aio_sigevent> appropriately; see B<sigevent>(7)  for details."
msgstr ""
"Прилагательное «асинхронный» означает, что вызов возвращает управление сразу "
"после установки запроса в очередь; при завершении вызова чтение может уже "
"выполнится, а может и нет. Для проверки выполнения чтения используйте B<"
"aio_error>(3). Состояние возврата завершённой операции ввода-вывода можно "
"получить с помощью B<aio_return>(3). Асинхронное уведомление о выполнении "
"ввода-вывода можно получить, установив I<aiocbp-E<gt>aio_sigevent> "
"соответствующим образом; подробней смотрите в B<sigevent>(7)."

#. type: Plain text
#: man-pages/man3/aio_read.3:82
msgid ""
"If B<_POSIX_PRIORITIZED_IO> is defined, and this file supports it, then the "
"asynchronous operation is submitted at a priority equal to that of the "
"calling process minus I<aiocbp-E<gt>aio_reqprio>."
msgstr ""
"Если определён макрос B<_POSIX_PRIORITIZED_IO> и данный файл его "
"поддерживает, асинхронная операция устанавливается в очередь с приоритетом "
"вызывающего процесса минус I<aiocbp-E<gt>aio_reqprio>."

#. type: Plain text
#: man-pages/man3/aio_read.3:86
msgid "The field I<aiocbp-E<gt>aio_lio_opcode> is ignored."
msgstr "Поле I<aiocbp-E<gt>aio_lio_opcode> игнорируется."

#. type: Plain text
#: man-pages/man3/aio_read.3:88
msgid "No data is read from a regular file beyond its maximum offset."
msgstr ""
"Данные не читаются из обычного файла, если смещение превышает максимум."

#. type: Plain text
#: man-pages/man3/aio_read.3:103
msgid ""
"On success, 0 is returned.  On error, the request is not enqueued, -1 is "
"returned, and I<errno> is set appropriately.  If an error is detected only "
"later, it will be reported via B<aio_return>(3)  (returns status -1) and "
"B<aio_error>(3)  (error status\\(emwhatever one would have gotten in "
"I<errno>, such as B<EBADF>)."
msgstr ""
"При успешном выполнении возвращается 0. При ошибке запрос не устанавливается "
"в очередь, возвращается -1, I<errno> присваивается соответствующее значение. "
"Если ошибка обнаруживается не сразу, то о ней будет сообщено посредством B<"
"aio_return>(3) (возвращается состояние -1) и B<aio_error>(3) (состояние "
"ошибки — всё, что было бы в I<errno>, например B<EBADF>)."

#. type: Plain text
#: man-pages/man3/aio_read.3:111
msgid "I<aio_fildes> is not a valid file descriptor open for reading."
msgstr ""
"Значение I<aio_fildes> не является допустимым файловым дескриптором для "
"открытия на чтение."

#. type: Plain text
#: man-pages/man3/aio_read.3:119
msgid ""
"One or more of I<aio_offset>, I<aio_reqprio>, or I<aio_nbytes> are invalid."
msgstr ""
"Одно или несколько значений у I<aio_offset>, I<aio_reqprio> или I<aio_nbytes> "
"неверны."

#. type: Plain text
#: man-pages/man3/aio_read.3:123
msgid "B<aio_read>()  is not implemented."
msgstr "Функция B<aio_read>() не реализована."

#. type: TP
#: man-pages/man3/aio_read.3:123
#, no-wrap
msgid "B<EOVERFLOW>"
msgstr "B<EOVERFLOW>"

#. type: Plain text
#: man-pages/man3/aio_read.3:128
msgid ""
"The file is a regular file, we start reading before end-of-file and want at "
"least one byte, but the starting position is past the maximum offset for "
"this file."
msgstr ""
"Файл является обычным файлом, мы начинаем читать его до конца файла и хотим "
"получить не менее одного байта, но начальная позиция находится за "
"максимальным значением смещения этого файла."

#. type: Plain text
#: man-pages/man3/aio_read.3:132
msgid "The B<aio_read>()  function is available since glibc 2.1."
msgstr "Функция B<aio_read>() доступна в glibc начиная с версии 2.1."

#.  or the control block of the operation
#. type: Plain text
#: man-pages/man3/aio_read.3:142
msgid ""
"It is a good idea to zero out the control block before use.  The control "
"block must not be changed while the read operation is in progress.  The "
"buffer area being read into must not be accessed during the operation or "
"undefined results may occur.  The memory areas involved must remain valid."
msgstr ""
"Желательно обнулять буфер блока управления перед использованием. Блок "
"управления не должен изменяться во время выполнения операции чтения. Область "
"буфера, в которую выполняется чтение, должна быть недоступна во время "
"операции, иначе поведение непредсказуемо. Области памяти, с которыми "
"производится работа, должны оставаться доступными."

#. type: Plain text
#: man-pages/man3/aio_read.3:146
msgid ""
"Simultaneous I/O operations specifying the same I<aiocb> structure produce "
"undefined results."
msgstr ""
"Одновременное выполнение операций ввода-вывода через совместно используемую "
"структуру I<aiocb> приводит к непредсказуемым результатам."

#. type: Plain text
#: man-pages/man3/aio_read.3:157
msgid ""
"B<aio_cancel>(3), B<aio_error>(3), B<aio_fsync>(3), B<aio_return>(3), "
"B<aio_suspend>(3), B<aio_write>(3), B<lio_listio>(3), B<aio>(7)"
msgstr ""
"B<aio_cancel>(3), B<aio_error>(3), B<aio_fsync>(3), B<aio_return>(3), B<"
"aio_suspend>(3), B<aio_write>(3), B<lio_listio>(3), B<aio>(7)"

#. type: TH
#: man-pages/man3/aio_suspend.3:25
#, no-wrap
msgid "AIO_SUSPEND"
msgstr "AIO_SUSPEND"

#. type: Plain text
#: man-pages/man3/aio_suspend.3:28
msgid "aio_suspend - wait for asynchronous I/O operation or timeout"
msgstr ""
"aio_suspend - ожидает завершения операции ввода-вывода или истечения срока"

#. type: Plain text
#: man-pages/man3/aio_suspend.3:32
#, no-wrap
msgid "B<#include E<lt>aio.hE<gt>>\n"
msgstr "B<#include E<lt>aio.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/aio_suspend.3:34
#, no-wrap
msgid "B<int aio_suspend(const struct aiocb * const >I<aiocb_list>B<[],>\n"
msgstr "B<int aio_suspend(const struct aiocb * const >I<aiocb_list>B<[],>\n"

#. type: Plain text
#: man-pages/man3/aio_suspend.3:36
#, no-wrap
msgid ""
"B<                int >I<nitems>B<, const struct timespec "
"*>I<timeout>B<);>\n"
msgstr ""
"B<                int >I<nitems>B<, const struct timespec *>I<timeout>B<);>\n"

#. type: Plain text
#: man-pages/man3/aio_suspend.3:38
#, no-wrap
msgid "Link with I<-lrt>.\n"
msgstr "Компонуется при указании параметра I<-lrt>.\n"

#. type: Plain text
#: man-pages/man3/aio_suspend.3:43
msgid ""
"The B<aio_suspend>()  function suspends the calling thread until one of the "
"following occurs:"
msgstr ""
"Функция B<aio_suspend>() приостанавливает выполнение вызывающей нити до тех "
"пор, пока не случиться одно из следующих событий:"

#. type: Plain text
#: man-pages/man3/aio_suspend.3:47
msgid ""
"One or more of the asynchronous I/O requests in the list I<aiocb_list> has "
"completed."
msgstr ""
"Завершится один или более асинхронных запросов ввода-вывода из списка I<"
"aiocb_list>."

#. type: Plain text
#: man-pages/man3/aio_suspend.3:49
msgid "A signal is delivered."
msgstr "Будет получен сигнал."

#. type: Plain text
#: man-pages/man3/aio_suspend.3:56
msgid ""
"I<timeout> is not NULL and the specified time interval has passed.  (For "
"details of the I<timespec> structure, see B<nanosleep>(2).)"
msgstr ""
"Если значение I<timeout> не NULL и истечёт указанный срок (описание структуры "
"I<timespec> смотрите в B<nanosleep>(2))."

#. type: Plain text
#: man-pages/man3/aio_suspend.3:74
msgid ""
"The I<nitems> argument specifies the number of items in I<aiocb_list>.  Each"
" item in the list pointed to by I<aiocb_list> must be either NULL (and then "
"is ignored), or a pointer to a control block on which I/O was initiated "
"using B<aio_read>(3), B<aio_write>(3), or B<lio_listio>(3).  (See B<aio>(7)"
"  for a description of the I<aiocb> structure.)"
msgstr ""
"В аргументе I<nitems> задаётся количество элементов в I<aiocb_list>. Каждый "
"элемент в списке, который задаётся в I<aiocb_list>, должен быть равен NULL "
"(игнорируется), или указывать на управляющий блок, который создаётся при "
"создании операции ввода-вывода с помощью B<aio_read>(3), B<aio_write>(3) или "
"B<lio_listio>(3) (описание структуры I<aiocb> смотрите в B<aio>(7))."

#. type: Plain text
#: man-pages/man3/aio_suspend.3:80
msgid ""
"If B<CLOCK_MONOTONIC> is supported, this clock is used to measure the "
"timeout interval (see B<clock_gettime>(3))."
msgstr ""
"Если поддерживается B<CLOCK_MONOTONIC>, то данный таймер используется для "
"измерения периода ожидания (смотрите B<clock_gettime>(3))."

#. type: Plain text
#: man-pages/man3/aio_suspend.3:88
msgid ""
"If this function returns after completion of one of the I/O requests "
"specified in I<aiocb_list>, 0 is returned.  Otherwise, -1 is returned, and "
"I<errno> is set to indicate the error."
msgstr ""
"Если функция завершается после выполнения запроса ввода-вывода из списка I<"
"aiocb_list>, то возвращается 0. В противном случае возвращается -1, а "
"значением I<errno> определяется тип ошибки."

#. type: Plain text
#: man-pages/man3/aio_suspend.3:93
msgid ""
"The call timed out before any of the indicated operations had completed."
msgstr "Истёк период ожидания в вызове до завершения какой-либо операции."

#. type: Plain text
#: man-pages/man3/aio_suspend.3:99
msgid ""
"The call was ended by signal (possibly the completion signal of one of the "
"operations we were waiting for); see B<signal>(7)."
msgstr ""
"Вызов завершён по сигналу (возможно по сигналу, который ожидался как "
"завершение операции); смотрите B<signal>(7)."

#. type: Plain text
#: man-pages/man3/aio_suspend.3:103
msgid "B<aio_suspend>()  is not implemented."
msgstr "Функция B<aio_suspend>() не реализована."

#. type: Plain text
#: man-pages/man3/aio_suspend.3:107
msgid "The B<aio_suspend>()  function is available since glibc 2.1."
msgstr "Функция B<aio_suspend>() доступна в glibc начиная с версии 2.1."

#. type: Plain text
#: man-pages/man3/aio_suspend.3:113
msgid ""
"One can achieve polling by using a non-NULL I<timeout> that specifies a zero"
" time interval."
msgstr ""
"Можно выполнить опрос с не NULL значением I<timeout>, указав нулевой "
"временной интервал."

#. type: Plain text
#: man-pages/man3/aio_suspend.3:119
msgid ""
"If one or more of the asynchronous I/O operations specified in I<aiocb_list>"
" has already completed at the time of the call to B<aio_suspend>(), then the"
" call returns immediately."
msgstr ""
"Если одна или несколько асинхронных операций ввода-вывода, указанных в I<"
"aiocb_list>, уже завершилась на момент вызова B<aio_suspend>(), то вызов "
"сразу завершает работу."

#. type: Plain text
#: man-pages/man3/aio_suspend.3:129
msgid ""
"To determine which I/O operations have completed after a successful return "
"from B<aio_suspend>(), use B<aio_error>(3)  to scan the list of I<aiocb> "
"structures pointed to by I<aiocb_list>."
msgstr ""
"Чтобы после успешного возврата из B<aio_suspend>() определить, какие операции "
"ввода-вывода завершились, используйте B<aio_error>(3) для проверки списка "
"структур I<aiocb>, на который указывает I<aiocb_list>."

#. type: Plain text
#: man-pages/man3/aio_suspend.3:138
msgid ""
"B<aio_cancel>(3), B<aio_error>(3), B<aio_fsync>(3), B<aio_read>(3), "
"B<aio_return>(3), B<aio_write>(3), B<lio_listio>(3), B<aio>(7), B<time>(7)"
msgstr ""
"B<aio_cancel>(3), B<aio_error>(3), B<aio_fsync>(3), B<aio_read>(3), B<"
"aio_return>(3), B<aio_write>(3), B<lio_listio>(3), B<aio>(7), B<time>(7)"

#. type: TH
#: man-pages/man3/atan2.3:35
#, no-wrap
msgid "ATAN2"
msgstr "ATAN2"

#. type: TH
#: man-pages/man3/atan2.3:35
#, no-wrap
msgid "2010-09-20"
msgstr "2010-09-20"

#. type: Plain text
#: man-pages/man3/atan2.3:38
msgid "atan2, atan2f, atan2l - arc tangent function of two variables"
msgstr "atan2, atan2f, atan2l - функция вычисления арктангенcа двух переменных"

#. type: Plain text
#: man-pages/man3/atan2.3:41
#, no-wrap
msgid "B<#include E<lt>math.hE<gt>>\n"
msgstr "B<#include E<lt>math.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/atan2.3:45
#, no-wrap
msgid ""
"B<double atan2(double >I<y>B<, double >I<x>B<);>\n"
"B<float atan2f(float >I<y>B<, float >I<x>B<);>\n"
"B<long double atan2l(long double >I<y>B<, long double >I<x>B<);>\n"
msgstr ""
"B<double atan2(double >I<y>B<, double >I<x>B<);>\nB<float atan2f(float >I<y>"
"B<, float >I<x>B<);>\nB<long double atan2l(long double >I<y>B<, long double >"
"I<x>B<);>\n"

#. type: Plain text
#: man-pages/man3/atan2.3:48
msgid "Link with I<-lm>."
msgstr "Компонуется при указании параметра I<-lm>."

#. type: Plain text
#: man-pages/man3/atan2.3:57
msgid "B<atan2f>(), B<atan2l>():"
msgstr "B<atan2f>(), B<atan2l>():"

#. type: Plain text
#: man-pages/man3/atan2.3:60
msgid ""
"_BSD_SOURCE || _SVID_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 600 || "
"_ISOC99_SOURCE || _POSIX_C_SOURCE\\ E<gt>=\\ 200112L;"
msgstr ""
"_BSD_SOURCE || _SVID_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 600 || _ISOC99_SOURCE "
"|| _POSIX_C_SOURCE\\ E<gt>=\\ 200112L;"

#. type: Plain text
#: man-pages/man3/atan2.3:63
msgid "or I<cc\\ -std=c99>"
msgstr "или I<cc\\ -std=c99>"

#. type: Plain text
#: man-pages/man3/atan2.3:72
msgid ""
"The B<atan2>()  function calculates the principal value of the arc tangent "
"of I<y/x>, using the signs of the two arguments to determine the quadrant of"
" the result."
msgstr ""
"Функция B<atan2>() вычисляет арктангенс I<y/x>; знак обоих аргументов "
"используется для определения квадранта результата."

#. type: Plain text
#: man-pages/man3/atan2.3:76
msgid ""
"On success, these functions return the principal value of the arc tangent of"
" I<y/x> in radians; the return value is in the range [-pi,\\ pi]."
msgstr ""
"При успешном выполнении данные функции возвращают значение арктангенса I<y/x> "
"в радианах; возвращаемое значение находится в диапазоне [-pi,\\ pi]."

#. type: Plain text
#: man-pages/man3/atan2.3:82
msgid "If I<y> is +0 (-0) and I<x> is less than 0, +pi (-pi) is returned."
msgstr "Если I<y> равно +0 (-0) и I<x> меньше 0, то возвращается +pi (-pi)."

#. type: Plain text
#: man-pages/man3/atan2.3:88
msgid "If I<y> is +0 (-0) and I<x> is greater than 0, +0 (-0) is returned."
msgstr "Если I<y> равно +0 (-0) и I<x> больше 0, то возвращается +0 (-0)."

#. type: Plain text
#: man-pages/man3/atan2.3:94
msgid "If I<y> is less than 0 and I<x> is +0 or -0, -pi/2 is returned."
msgstr "Если I<y> меньше 0 и и I<x> равно +0 или -0, то возвращается -pi/2."

#. type: Plain text
#: man-pages/man3/atan2.3:100
msgid "If I<y> is greater than 0 and I<x> is +0 or -0, pi/2 is returned."
msgstr "Если I<y> больше 0 и и I<x> равно +0 или -0, то возвращается pi/2."

#.  POSIX.1 says:
#.  If
#.  .I x
#.  is 0, a pole error shall not occur.
#. type: Plain text
#: man-pages/man3/atan2.3:111
msgid "If either I<x> or I<y> is NaN, a NaN is returned."
msgstr "Если I<x> или I<y> равно NaN, тот возвращается NaN."

#.  POSIX.1 says:
#.  If the result underflows, a range error may occur and
#.  .I y/x
#.  should be returned.
#. type: Plain text
#: man-pages/man3/atan2.3:122
msgid "If I<y> is +0 (-0) and I<x> is -0, +pi (-pi) is returned."
msgstr "Если I<x> равно +0 (-0) и I<x> равно -0, то возвращается +pi (-pi)."

#. type: Plain text
#: man-pages/man3/atan2.3:128
msgid "If I<y> is +0 (-0) and I<x> is +0, +0 (-0) is returned."
msgstr "Если I<x> равно +0 (-0) и I<x> равно +0, то возвращается +0 (-0)."

#. type: Plain text
#: man-pages/man3/atan2.3:134
msgid ""
"If I<y> is a finite value greater (less) than 0, and I<x> is negative "
"infinity, +pi (-pi) is returned."
msgstr ""
"Если I<y> — конечное значение большее (меньшее) 0 и I<x> стремится к минус "
"бесконечности, то возвращается +pi (-pi)."

#. type: Plain text
#: man-pages/man3/atan2.3:140
msgid ""
"If I<y> is a finite value greater (less) than 0, and I<x> is positive "
"infinity, +0 (-0) is returned."
msgstr ""
"Если I<y> — конечное значение большее (меньшее) 0 и I<x> стремится к плюс "
"бесконечности, то возвращается +0 (-0)."

#. type: Plain text
#: man-pages/man3/atan2.3:147
msgid ""
"If I<y> is positive infinity (negative infinity), and I<x> is finite, pi/2 "
"(-pi/2) is returned."
msgstr ""
"Если I<y> стремится к плюс бесконечности (минус бесконечности) и I<x> имеет "
"конечное значение, то будет возвращено pi/2 (-pi/2)."

#. type: Plain text
#: man-pages/man3/atan2.3:153
msgid ""
"If I<y> is positive infinity (negative infinity) and I<x> is negative "
"infinity, +3*pi/4 (-3*pi/4) is returned."
msgstr ""
"Если I<y> стремится к плюс бесконечности (минус бесконечности) и I<x> "
"стремится к минус бесконечности, то будет возвращено +3*pi/4 (-3*pi/4)."

#.  POSIX.1 says:
#.  If both arguments are 0, a domain error shall not occur.
#. type: Plain text
#: man-pages/man3/atan2.3:162
msgid ""
"If I<y> is positive infinity (negative infinity) and I<x> is positive "
"infinity, +pi/4 (-pi/4) is returned."
msgstr ""
"Если I<y> стремится к плюс бесконечности (минус бесконечности) и I<x> "
"стремится к плюс бесконечности, то будет возвращено +pi/4 (-pi/4)."

#.  POSIX.1 documents an optional underflow error
#.  glibc 2.8 does not do this.
#. type: Plain text
#: man-pages/man3/atan2.3:166
msgid "No errors occur."
msgstr "Ошибки не возникают."

#. type: Plain text
#: man-pages/man3/atan2.3:172
msgid ""
"C99, POSIX.1-2001.  The variant returning I<double> also conforms to SVr4, "
"4.3BSD, C89."
msgstr ""
"C99, POSIX.1-2001. Вариант, возвращающий значение типа I<double>, также "
"соответствует SVr4, 4.3BSD и C89."

#. type: Plain text
#: man-pages/man3/atan2.3:179
msgid ""
"B<acos>(3), B<asin>(3), B<atan>(3), B<carg>(3), B<cos>(3), B<sin>(3), "
"B<tan>(3)"
msgstr ""
"B<acos>(3), B<asin>(3), B<atan>(3), B<carg>(3), B<cos>(3), B<sin>(3), B<tan>"
"(3)"

#. type: TH
#: man-pages/man3/atan.3:35
#, no-wrap
msgid "ATAN"
msgstr "ATAN"

#. type: TH
#: man-pages/man3/atan.3:35
#, no-wrap
msgid "2013-10-07"
msgstr "2013-10-07"

#. type: Plain text
#: man-pages/man3/atan.3:38
msgid "atan, atanf, atanl - arc tangent function"
msgstr "atan, atanf, atanl - функция вычисления арктангенса"

#. type: Plain text
#: man-pages/man3/atan.3:43
#, no-wrap
msgid "B<double atan(double >I<x>B<);>\n"
msgstr "B<double atan(double >I<x>B<);>\n"

#. type: Plain text
#: man-pages/man3/atan.3:45
#, no-wrap
msgid "B<float atanf(float >I<x>B<);>\n"
msgstr "B<float atanf(float >I<x>B<);>\n"

#. type: Plain text
#: man-pages/man3/atan.3:47
#, no-wrap
msgid "B<long double atanl( long double >I<x>B<);>\n"
msgstr "B<long double atanl( long double >I<x>B<);>\n"

#. type: Plain text
#: man-pages/man3/atan.3:59
msgid "B<atanf>(), B<atanl>():"
msgstr "B<atanf>(), B<atanl>():"

#. type: Plain text
#: man-pages/man3/atan.3:74
msgid ""
"The B<atan>()  function calculates the principal value of the arc tangent of"
" I<x>; that is the value whose tangent is I<x>."
msgstr ""
"Функция B<atan>() вычисляет арктангенс от I<x>; это значение, тангенс "
"которого равен I<x>."

#. type: Plain text
#: man-pages/man3/atan.3:78
msgid ""
"On success, these functions return the principal value of the arc tangent of"
" I<x> in radians; the return value is in the range [-pi/2,\\ pi/2]."
msgstr ""
"В случае успеха эти функции возвращают значение арктангенса от I<x> в "
"радианах; результат лежит в диапазоне значений [-pi/2,\\ pi/2]."

#. type: Plain text
#: man-pages/man3/atan.3:82
msgid "If I<x> is a NaN, a NaN is returned."
msgstr "Если I<x> равно NaN, будет возвращено NaN."

#. type: Plain text
#: man-pages/man3/atan.3:87
msgid "If I<x> is +0 (-0), +0 (-0) is returned."
msgstr "Если I<x> равно +0 (-0), будет возвращено +0 (-0)."

#.  POSIX.1-2001 documents an optional range error for subnormal x;
#.  glibc 2.8 does not do this.
#. type: Plain text
#: man-pages/man3/atan.3:94
msgid ""
"If I<x> is positive infinity (negative infinity), +pi/2 (-pi/2) is returned."
msgstr ""
"Если I<x> стремится к плюс бесконечности (минус бесконечности), то будет "
"возвращен +pi/2 (-pi/2)."

#. type: Plain text
#: man-pages/man3/atan.3:104
msgid "The B<atan>(), B<atanf>(), and B<atanl>()  functions are thread-safe."
msgstr ""
"Функции B<atan>(), B<atanf>() и B<atanl>() можно использовать в нескольких "
"нитях одновременно."

#. type: Plain text
#: man-pages/man3/atan.3:118
msgid ""
"B<acos>(3), B<asin>(3), B<atan2>(3), B<carg>(3), B<catan>(3), B<cos>(3), "
"B<sin>(3), B<tan>(3)"
msgstr ""
"B<acos>(3), B<asin>(3), B<atan2>(3), B<carg>(3), B<catan>(3), B<cos>(3), B<"
"sin>(3), B<tan>(3)"

#. type: TH
#: man-pages/man3/atexit.3:33
#, no-wrap
msgid "ATEXIT"
msgstr "ATEXIT"

#. type: TH
#: man-pages/man3/atexit.3:33
#, no-wrap
msgid "2008-12-05"
msgstr "2008-12-05"

#. type: Plain text
#: man-pages/man3/atexit.3:36
msgid "atexit - register a function to be called at normal process termination"
msgstr ""
"atexit - регистрирует функцию, вызываемую при обычном завершении программы"

#. type: Plain text
#: man-pages/man3/atexit.3:39
#, no-wrap
msgid "B<#include E<lt>stdlib.hE<gt>>\n"
msgstr "B<#include E<lt>stdlib.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/atexit.3:41
#, no-wrap
msgid "B<int atexit(void (*>I<function>B<)(void));>\n"
msgstr "B<int atexit(void (*>I<function>B<)(void));>\n"

#. type: Plain text
#: man-pages/man3/atexit.3:54
msgid ""
"The B<atexit>()  function registers the given I<function> to be called at "
"normal process termination, either via B<exit>(3)  or via return from the "
"program's I<main>().  Functions so registered are called in the reverse "
"order of their registration; no arguments are passed."
msgstr ""
"Функция B<atexit>() регистрирует передаваемую функцию I<function> в качестве "
"функции, вызываемой при нормальном завершении работы программы, например, с "
"помощью B<exit>(3), или при завершении работы функции I<main>. "
"Зарегистрированные функции вызываются в порядке, обратном регистрации; "
"никаких аргументов им не передаётся."

#. type: Plain text
#: man-pages/man3/atexit.3:57
msgid ""
"The same function may be registered multiple times: it is called once for "
"each registration."
msgstr ""
"Одна и та же функция может быть зарегистрирована несколько раз: она "
"вызывается один раз для каждой регистрации."

#. type: Plain text
#: man-pages/man3/atexit.3:63
msgid ""
"POSIX.1-2001 requires that an implementation allow at least B<ATEXIT_MAX> "
"(32) such functions to be registered.  The actual limit supported by an "
"implementation can be obtained using B<sysconf>(3)."
msgstr ""
"В POSIX.1-2001 требуется, чтобы реализация позволяла регистрировать не менее "
"B<ATEXIT_MAX> (32) таких функций. Установленный лимит, поддерживаемый "
"реализацией, можно определить с помощью B<sysconf>(3)."

#. type: Plain text
#: man-pages/man3/atexit.3:71
msgid ""
"When a child process is created via B<fork>(2), it inherits copies of its "
"parent's registrations.  Upon a successful call to one of the B<exec>(3)  "
"functions, all registrations are removed."
msgstr ""
"Когда дочерний процесс создается через B<fork>(2), он наследует копии "
"родительских регистраций. При успешном вызове к одной из функций B<exec>(3), "
"все регистрации снимаются."

#. type: Plain text
#: man-pages/man3/atexit.3:76
msgid ""
"The B<atexit>()  function returns the value 0 if successful; otherwise it "
"returns a nonzero value."
msgstr ""
"Функция B<atexit>() при успешном выполнении возвращает 0, в противном случае "
"— ненулевое значение."

#. type: Plain text
#: man-pages/man3/atexit.3:78
msgid "SVr4, 4.3BSD, C89, C99, POSIX.1-2001."
msgstr "SVr4, 4.3BSD, C89, C99, POSIX.1-2001."

#. type: Plain text
#: man-pages/man3/atexit.3:85
msgid ""
"Functions registered using B<atexit>()  (and B<on_exit>(3))  are not called "
"if a process terminates abnormally because of the delivery of a signal."
msgstr ""
"Функции, зарегистрированные с помощью B<atexit>() (и B<on_exit>(3)) не "
"вызываются, если процесс завершился некорректно, например из-за полученного "
"сигнала."

#. type: Plain text
#: man-pages/man3/atexit.3:92
msgid ""
"If one of the functions registered functions calls B<_exit>(2), then any "
"remaining functions are not invoked, and the other process termination steps"
" performed by B<exit>(3)  are not performed."
msgstr ""
"Если одна из зарегистрированных функций вызывает B<_exit>(2), то все "
"оставшиеся функции не вызываются и оставшиеся шаги завершения процесса, "
"выполняемые B<exit>(3), не выполняется."

#.  This can happen on OpenBSD 4.2 for example, and is documented
#.  as occurring on FreeBSD as well.
#.  Glibc does "the Right Thing" -- invocation of the remaining
#.  exit handlers carries on as normal.
#. type: Plain text
#: man-pages/man3/atexit.3:109
msgid ""
"POSIX.1-2001 says that the result of calling B<exit>(3)  more than once "
"(i.e., calling B<exit>(3)  within a function registered using B<atexit>())  "
"is undefined.  On some systems (but not Linux), this can result in an "
"infinite recursion; portable programs should not invoke B<exit>(3)  inside a"
" function registered using B<atexit>()."
msgstr ""
"В POSIX.1-2001 указано, что при многократном вызове B<exit>(3) (т. е., вызов "
"B<exit>(3) из функций, зарегистрированных B<atexit>()) состояние программы не "
"определено. В некоторых системах (не в Linux), это приводит к бесконечной "
"рекурсии; переносимые программы не должны вызывать B<exit>(3) из функций, "
"зарегистрированных через B<atexit>()."

#. type: Plain text
#: man-pages/man3/atexit.3:118
msgid ""
"The B<atexit>()  and B<on_exit>(3)  functions register functions on the same"
" list: at normal process termination, the registered functions are invoked "
"in reverse order of their registration by these two functions."
msgstr ""
"Функции B<atexit>() и B<on_exit>(3) регистрируют функции в едином списке: при "
"нормальном завершении процесса зарегистрированные функции вызываются в "
"порядке обратном регистрации с помощью данных функций."

#.  In glibc, things seem to be handled okay
#. type: Plain text
#: man-pages/man3/atexit.3:124
msgid ""
"POSIX.1-2001 says that the result is undefined if B<longjmp>(3)  is used to "
"terminate execution of one of the functions registered B<atexit>()."
msgstr ""
"В POSIX.1-2001 указано, что результат не определён, если для завершения "
"функции, зарегистрированной B<atexit>(), используется B<longjmp>(3)."

#. type: SS
#: man-pages/man3/atexit.3:124
#, no-wrap
msgid "Linux notes"
msgstr "Замечания для Linux"

#. type: Plain text
#: man-pages/man3/atexit.3:131
msgid ""
"Since glibc 2.2.3, B<atexit>()  (and B<on_exit>(3))  can be used within a "
"shared library to establish functions that are called when the shared "
"library is unloaded."
msgstr ""
"Начиная с glibc 2.2.3, функция B<atexit>() (и B<on_exit>(3)) может быть "
"использована в общей библиотеке для указания функций, который вызываются при "
"выгрузке общей библиотеки."

#. type: Plain text
#: man-pages/man3/atexit.3:136
#, no-wrap
msgid ""
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
msgstr ""
"#include E<lt>stdio.hE<gt>\n#include E<lt>stdlib.hE<gt>\n#include E<lt>"
"unistd.hE<gt>\n"

#. type: Plain text
#: man-pages/man3/atexit.3:142
#, no-wrap
msgid ""
"void\n"
"bye(void)\n"
"{\n"
"    printf(\"That was all, folks\\en\");\n"
"}\n"
msgstr "void\nbye(void)\n{\n    printf(\"Но вот и всё\\en\");\n}\n"

#. type: Plain text
#: man-pages/man3/atexit.3:148
#, no-wrap
msgid ""
"int\n"
"main(void)\n"
"{\n"
"    long a;\n"
"    int i;\n"
msgstr "int\nmain(void)\n{\n    long a;\n    int i;\n"

#. type: Plain text
#: man-pages/man3/atexit.3:151
#, no-wrap
msgid ""
"    a = sysconf(_SC_ATEXIT_MAX);\n"
"    printf(\"ATEXIT_MAX = %ld\\en\", a);\n"
msgstr ""
"    a = sysconf(_SC_ATEXIT_MAX);\n    printf(\"ATEXIT_MAX = %ld\\en\", a);\n"

#. type: Plain text
#: man-pages/man3/atexit.3:157
#, no-wrap
msgid ""
"    i = atexit(bye);\n"
"    if (i != 0) {\n"
"        fprintf(stderr, \"cannot set exit function\\en\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    i = atexit(bye);\n    if (i != 0) {\n        fprintf(stderr, \"не удалось "
"установить функцию при выходе\\en\");\n        exit(EXIT_FAILURE);\n    }\n"

#. type: Plain text
#: man-pages/man3/atexit.3:164
msgid "B<_exit>(2), B<exit>(3), B<on_exit>(3)"
msgstr "B<_exit>(2), B<exit>(3), B<on_exit>(3)"

#. type: TH
#: man-pages/man3/acosh.3:35
#, no-wrap
msgid "ACOSH"
msgstr "ACOSH"

#. type: Plain text
#: man-pages/man3/acosh.3:38
msgid "acosh, acoshf, acoshl - inverse hyperbolic cosine function"
msgstr ""
"acosh, acoshf, acoshl - функция вычисления обратного гиперболического косинуса"

#. type: Plain text
#: man-pages/man3/acosh.3:43
#, no-wrap
msgid "B<double acosh(double >I<x>B<);>\n"
msgstr "B<double acosh(double >I<x>B<);>\n"

#. type: Plain text
#: man-pages/man3/acosh.3:45
#, no-wrap
msgid "B<float acoshf(float >I<x>B<);>\n"
msgstr "B<float acoshf(float >I<x>B<);>\n"

#. type: Plain text
#: man-pages/man3/acosh.3:47
#, no-wrap
msgid "B<long double acoshl(long double >I<x>B<);>\n"
msgstr "B<long double acoshl(long double >I<x>B<);>\n"

#. type: Plain text
#: man-pages/man3/acosh.3:58
msgid "B<acosh>():"
msgstr "B<acosh>():"

#. type: Plain text
#: man-pages/man3/acosh.3:62
msgid ""
"_BSD_SOURCE || _SVID_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 500 || "
"_XOPEN_SOURCE\\ &&\\ _XOPEN_SOURCE_EXTENDED || _ISOC99_SOURCE || "
"_POSIX_C_SOURCE\\ E<gt>=\\ 200112L;"
msgstr ""
"_BSD_SOURCE || _SVID_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 500 || "
"_XOPEN_SOURCE\\ &&\\ _XOPEN_SOURCE_EXTENDED || _ISOC99_SOURCE || "
"_POSIX_C_SOURCE\\ E<gt>=\\ 200112L;"

#. type: Plain text
#: man-pages/man3/acosh.3:69
msgid "B<acoshf>(), B<acoshl>():"
msgstr "B<acoshf>(), B<acoshl>():"

#. type: Plain text
#: man-pages/man3/acosh.3:84
msgid ""
"The B<acosh>()  function calculates the inverse hyperbolic cosine of I<x>; "
"that is the value whose hyperbolic cosine is I<x>."
msgstr ""
"Функция B<acosh>() вычисляет обратный гиперболический косинус значения I<x>; "
"гиперболический конус результата будет равен I<x>."

#. type: Plain text
#: man-pages/man3/acosh.3:87
msgid ""
"On success, these functions return the inverse hyperbolic cosine of I<x>."
msgstr ""
"При успешном выполнении данные функции возвращают обратный гиперболический "
"косинус от I<x>."

#. type: Plain text
#: man-pages/man3/acosh.3:95
msgid "If I<x> is +1, +0 is returned."
msgstr "Если I<x> равно +1, будет возвращён +0."

#. type: Plain text
#: man-pages/man3/acosh.3:99
msgid "If I<x> is positive infinity, positive infinity is returned."
msgstr ""
"Если I<x> стремится к плюс бесконечности, то будет возвращена плюс "
"бесконечность."

#. type: Plain text
#: man-pages/man3/acosh.3:105
msgid ""
"If I<x> is less than 1, a domain error occurs, and the functions return a "
"NaN."
msgstr ""
"Если I<x> меньше 1, то будет сгенерирована ошибка выхода за пределы области, "
"а в качестве результата будет возвращено NaN."

#. type: Plain text
#: man-pages/man3/acosh.3:110
msgid ""
"See B<math_error>(7)  for information on how to determine whether an error "
"has occurred when calling these functions."
msgstr ""
"Смотрите B<math_error>(7), чтобы определить, какие ошибки могут возникать при "
"вызове этих функций."

#. type: Plain text
#: man-pages/man3/acosh.3:112
msgid "The following errors can occur:"
msgstr "Могут возникать следующие ошибки:"

#. type: TP
#: man-pages/man3/acosh.3:112
#, no-wrap
msgid "Domain error: I<x> is less than 1"
msgstr "Ошибка области: I<x> меньше 1"

#. type: Plain text
#: man-pages/man3/acosh.3:120
msgid ""
"I<errno> is set to B<EDOM>.  An invalid floating-point exception "
"(B<FE_INVALID>)  is raised."
msgstr ""
"Значение I<errno> устанавливается в B<EDOM>. Вызывается исключение "
"неправильной плавающей точки (B<FE_INVALID>)."

#. type: Plain text
#: man-pages/man3/acosh.3:132
msgid ""
"B<asinh>(3), B<atanh>(3), B<cacosh>(3), B<cosh>(3), B<sinh>(3), B<tanh>(3)"
msgstr ""
"B<asinh>(3), B<atanh>(3), B<cacosh>(3), B<cosh>(3), B<sinh>(3), B<tanh>(3)"

#. type: TH
#: man-pages/man3/adjtime.3:25
#, no-wrap
msgid "ADJTIME"
msgstr "ADJTIME"

#. type: Plain text
#: man-pages/man3/adjtime.3:28
msgid "adjtime - correct the time to synchronize the system clock"
msgstr "adjtime - корректировка времени для синхронизации с системными часами"

#. type: Plain text
#: man-pages/man3/adjtime.3:31
#, no-wrap
msgid "B<#include E<lt>sys/time.hE<gt>>\n"
msgstr "B<#include E<lt>sys/time.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/adjtime.3:33
#, no-wrap
msgid ""
"B<int adjtime(const struct timeval *>I<delta>B<, struct timeval "
"*>I<olddelta>B<);>\n"
msgstr ""
"B<int adjtime(const struct timeval *>I<delta>B<, struct timeval *>I<olddelta>"
"B<);>\n"

#. type: Plain text
#: man-pages/man3/adjtime.3:42
msgid "B<adjtime>(): _BSD_SOURCE"
msgstr "B<adjtime>(): _BSD_SOURCE"

#. type: Plain text
#: man-pages/man3/adjtime.3:51
msgid ""
"The B<adjtime>()  function gradually adjusts the system clock (as returned "
"by B<gettimeofday>(2)).  The amount of time by which the clock is to be "
"adjusted is specified in the structure pointed to by I<delta>.  This "
"structure has the following form:"
msgstr ""
"Функция B<adjtime>() постепенно подстраивает системные часы (значение которых "
"можно получить функцией B<gettimeofday>(2)). Количество времени, на которое "
"будут подстроены часы, указано в структуре, на которую указывает I<delta>. "
"Данная структура имеет следующий формат:"

#. type: Plain text
#: man-pages/man3/adjtime.3:58
#, no-wrap
msgid ""
"struct timeval {\n"
"    time_t      tv_sec;     /* seconds */\n"
"    suseconds_t tv_usec;    /* microseconds */\n"
"};\n"
msgstr ""
"struct timeval {\n    time_t      tv_sec;     /* секунды */\n    suseconds_t "
"tv_usec;    /* микросекунды */\n};\n"

#. type: Plain text
#: man-pages/man3/adjtime.3:70
msgid ""
"If the adjustment in I<delta> is positive, then the system clock is speeded "
"up by some small percentage (i.e., by adding a small amount of time to the "
"clock value in each second) until the adjustment has been completed.  If the"
" adjustment in I<delta> is negative, then the clock is slowed down in a "
"similar fashion."
msgstr ""
"Если время подстройки в I<delta> положительно, то ход системных часов "
"ускоряется на небольшой процент (то есть каждая секунда длится чуть дольше) "
"до тех пор, пока подстройка не будет завершена. Если время подстройки в I<"
"delta> отрицательно, то часы будут замедлены схожим способом."

#. type: Plain text
#: man-pages/man3/adjtime.3:80
msgid ""
"If a clock adjustment from an earlier B<adjtime>()  call is already in "
"progress at the time of a later B<adjtime>()  call, and I<delta> is not NULL"
" for the later call, then the earlier adjustment is stopped, but any already"
" completed part of that adjustment is not undone."
msgstr ""
"Если подстройка системных часов по B<adjtime>() уже производится во время "
"второго вызова B<adjtime>(), и I<delta> второго вызова не равна NULL, то "
"более ранняя подстройка останавливается, однако уже завершённая часть "
"подстройки не отменяется."

#. type: Plain text
#: man-pages/man3/adjtime.3:86
msgid ""
"If I<olddelta> is not NULL, then the buffer that it points to is used to "
"return the amount of time remaining from any previous adjustment that has "
"not yet been completed."
msgstr ""
"Если значение I<olddelta> не равно NULL, то буфер, на который оно указывает, "
"будет содержать количество оставшегося после предыдущей незавершенной "
"подстройки времени."

#. type: Plain text
#: man-pages/man3/adjtime.3:93
msgid ""
"On success, B<adjtime>()  returns 0.  On failure, -1 is returned, and "
"I<errno> is set to indicate the error."
msgstr ""
"При успешном выполнении B<adjtime>() возвращает 0. При ошибке возвращается "
"-1, I<errno> устанавливается в соответствующее значение."

#. type: Plain text
#: man-pages/man3/adjtime.3:99
msgid "The adjustment in I<delta> is outside the permitted range."
msgstr "Подстройка в I<delta> находится вне разрешённого диапазона."

#. type: Plain text
#: man-pages/man3/adjtime.3:105
msgid ""
"The caller does not have sufficient privilege to adjust the time.  Under "
"Linux, the B<CAP_SYS_TIME> capability is required."
msgstr ""
"Вызывающий не обладает нужными привилегиями для подстройки времени. В Linux "
"для этого требуется мандат B<CAP_SYS_TIME>."

#. type: Plain text
#: man-pages/man3/adjtime.3:110
msgid "The B<adjtime>()  function is thread-safe."
msgstr ""
"Функцию B<adjtime>() можно использовать в нескольких нитях одновременно."

#. type: Plain text
#: man-pages/man3/adjtime.3:112
msgid "4.3BSD, System V."
msgstr "4.3BSD, System V."

#. type: Plain text
#: man-pages/man3/adjtime.3:123
msgid ""
"The adjustment that B<adjtime>()  makes to the clock is carried out in such "
"a manner that the clock is always monotonically increasing.  Using "
"B<adjtime>()  to adjust the time prevents the problems that can be caused "
"for certain applications (e.g., B<make>(1))  by abrupt positive or negative "
"jumps in the system time."
msgstr ""
"Подстройка B<adjtime>() заставляет часы постоянно ускорять свой ход. "
"Использование B<adjtime>() для подстройки времени предотвращает проблемы, "
"которые  могут возникнуть у некоторых программ (например, B<make>(1)), если "
"происходят скачки времени вперед или назад."

#. type: Plain text
#: man-pages/man3/adjtime.3:133
msgid ""
"B<adjtime>()  is intended to be used to make small adjustments to the system"
" time.  Most systems impose a limit on the adjustment that can be specified "
"in I<delta>.  In the glibc implementation, I<delta> must be less than or "
"equal to (INT_MAX / 1000000 - 2)  and greater than or equal to (INT_MIN / "
"1000000 + 2)  (respectively 2145 and -2145 seconds on i386)."
msgstr ""
"Функция B<adjtime>() предназначена для использования подстроек системных "
"часов малыми значениями. В большинстве систем есть ограничение для времени "
"подстройки, которое можно указывать в I<delta>. В реализации glibc значение "
"I<delta> должно быть меньше либо равно (INT_MAX / 1000000 - 2) и больше либо "
"равно (INT_MIN / 1000000 + 2) (для i386 эти значения равны -2145 и 2145 "
"секунд, соответственно)."

#.  http://sourceware.org/bugzilla/show_bug?id=2449
#.  http://bugzilla.kernel.org/show_bug.cgi?id=6761
#.  Thanks to the new adjtimex() ADJ_OFFSET_SS_READ flag
#. type: Plain text
#: man-pages/man3/adjtime.3:149
msgid ""
"A longstanding bug meant that if I<delta> was specified as NULL, no valid "
"information about the outstanding clock adjustment was returned in "
"I<olddelta>.  (In this circumstance, B<adjtime>()  should return the "
"outstanding clock adjustment, without changing it.)  This bug is fixed on "
"systems with glibc 2.8 or later and Linux kernel 2.6.26 or later."
msgstr ""
"Была застарелая ошибка, при который если I<delta> была определена как NULL, "
"то информация по предыдущей подстройке в I<olddelta> не возвращалась (в "
"данном случае B<adjtime>() должна возвращать последнюю подстройку часов без "
"изменений). Эта ошибка была исправлена в системах с glibc 2.8 и выше и ядром "
"Linux 2.6.26 и выше."

#. type: Plain text
#: man-pages/man3/adjtime.3:152
msgid "B<adjtimex>(2), B<gettimeofday>(2), B<time>(7)"
msgstr "B<adjtimex>(2), B<gettimeofday>(2), B<time>(7)"

#. type: TH
#: man-pages/man3/aio_return.3:24
#, no-wrap
msgid "AIO_RETURN"
msgstr "AIO_RETURN"

#. type: Plain text
#: man-pages/man3/aio_return.3:27
msgid "aio_return - get return status of asynchronous I/O operation"
msgstr "aio_return - возвращает состояние операции асинхронного ввода-вывода"

#. type: Plain text
#: man-pages/man3/aio_return.3:31
msgid "B<ssize_t aio_return(struct aiocb *>I<aiocbp>B<);>"
msgstr "B<ssize_t aio_return(struct aiocb *>I<aiocbp>B<);>"

#. type: Plain text
#: man-pages/man3/aio_return.3:44
msgid ""
"The B<aio_return>()  function returns the final return status for the "
"asynchronous I/O request with control block pointed to by I<aiocbp>.  (See "
"B<aio>(7)  for a description of the I<aiocb> structure.)"
msgstr ""
"Функция B<aio_return>() возвращает окончательное значение завершения запроса "
"асинхронного ввода-вывода, задаваемого указателем на контрольный блок I<"
"aiocbp> (описание структуры I<aiocb> смотрите в B<aio>(7))."

#. type: Plain text
#: man-pages/man3/aio_return.3:49
msgid ""
"This function should be called only once for any given request, after "
"B<aio_error>(3)  returns something other than B<EINPROGRESS>."
msgstr ""
"Эта функция должна вызываться единожды для любого запроса в случае, если B<"
"aio_error>(3) возвращает результат, отличный от B<EINPROGRESS>."

#. type: Plain text
#: man-pages/man3/aio_return.3:58
msgid ""
"If the asynchronous I/O operation has completed, this function returns the "
"value that would have been returned in case of a synchronous B<read>(2), "
"B<write>(2), B<fsync>(2)  or B<fdatasync>(2), call."
msgstr ""
"Если операция асинхронного ввода-вывода завершена, данная функция возвращает "
"значение, которое может быть возвращено в случае запроса синхронного вызова "
"B<read>(2), B<write>(2), B<fsync>(2) или B<fdatasync>(2)."

#. type: Plain text
#: man-pages/man3/aio_return.3:63
msgid ""
"If the asynchronous I/O operation has not yet completed, the return value "
"and effect of B<aio_return>()  are undefined."
msgstr ""
"Если асинхронная операция ввода-вывода ещё не выполнена, то возвращаемое "
"значение и действие B<aio_return>() не определены."

#. type: Plain text
#: man-pages/man3/aio_return.3:69
msgid ""
"I<aiocbp> does not point at a control block for an asynchronous I/O request "
"of which the return status has not been retrieved yet."
msgstr ""
"I<aiocbp> не указывает на контрольный блок запроса асинхронного ввода-вывода, "
"значение результата которого ещё не получено."

#. type: Plain text
#: man-pages/man3/aio_return.3:73
msgid "B<aio_return>()  is not implemented."
msgstr "Функция B<aio_return>() не реализована."

#. type: Plain text
#: man-pages/man3/aio_return.3:77
msgid "The B<aio_return>()  function is available since glibc 2.1."
msgstr "Функция B<aio_return>() доступна в glibc начиная с версии 2.1."

#. type: Plain text
#: man-pages/man3/aio_return.3:82
msgid "The B<aio_return>()  function is thread-safe."
msgstr ""
"Функцию B<aio_return>() можно использовать в нескольких нитях одновременно."

#. type: Plain text
#: man-pages/man3/aio_return.3:95
msgid ""
"B<aio_cancel>(3), B<aio_error>(3), B<aio_fsync>(3), B<aio_read>(3), "
"B<aio_suspend>(3), B<aio_write>(3), B<lio_listio>(3), B<aio>(7)"
msgstr ""
"B<aio_cancel>(3), B<aio_error>(3), B<aio_fsync>(3), B<aio_read>(3), B<"
"aio_suspend>(3), B<aio_write>(3), B<lio_listio>(3), B<aio>(7)"

#. type: TH
#: man-pages/man3/aio_cancel.3:24
#, no-wrap
msgid "AIO_CANCEL"
msgstr "AIO_CANCEL"

#. type: Plain text
#: man-pages/man3/aio_cancel.3:27
msgid "aio_cancel - cancel an outstanding asynchronous I/O request"
msgstr "io_cancel - отменяет ожидающий асинхронный запрос ввода-вывода"

#. type: Plain text
#: man-pages/man3/aio_cancel.3:31
msgid "B<int aio_cancel(int >I<fd>B<, struct aiocb *>I<aiocbp>B<);>"
msgstr "B<int aio_cancel(int >I<fd>B<, struct aiocb *>I<aiocbp>B<);>"

#. type: Plain text
#: man-pages/man3/aio_cancel.3:51
msgid ""
"The B<aio_cancel>()  function attempts to cancel outstanding asynchronous "
"I/O requests for the file descriptor I<fd>.  If I<aiocbp> is NULL, all such "
"requests are canceled.  Otherwise, only the request described by the control"
" block pointed to by I<aiocbp> is canceled.  (See B<aio>(7)  for a "
"description of the I<aiocb> structure.)"
msgstr ""
"Функция B<aio_cancel>() пытается отменить ожидающие асинхронные запросы "
"ввода-вывода для файлового дескриптора I<fd>. Если значение I<aiocbp> равно "
"NULL, то отменяются все запросы. В противном случае, отменяется только "
"запрос, описанный в управляющем блоке, на который указывает значение I<aiocbp>"
" (описание структуры I<aiocb> смотрите в B<aio>(7))."

#. type: Plain text
#: man-pages/man3/aio_cancel.3:63
msgid ""
"Normal asynchronous notification occurs for canceled requests (see B<aio>(7)"
"  and B<sigevent>(7)).  The request return status (B<aio_return>(3))  is set"
" to -1, and the request error status (B<aio_error>(3))  is set to "
"B<ECANCELED>.  The control block of requests that cannot be canceled is not "
"changed."
msgstr ""
"При отмене запроса посылаются обычные асинхронные уведомления (смотрите B<aio>"
"(7) и B<sigevent>(7)). Запрос возвращает состояние (B<aio_return>(3)) равное "
"-1, а состояние ошибки (B<aio_error>(3)) устанавливается в B<ECANCELED>. "
"Управляющие блоки запросов, которые не могут быть отменены, не изменяются."

#. type: Plain text
#: man-pages/man3/aio_cancel.3:70
msgid ""
"If the request could not be canceled, then it will terminate in the usual "
"way after performing the I/O operation.  (In this case, B<aio_error>(3)  "
"will return the status B<EINPROGRESSS>.)"
msgstr ""
"Если запрос не может быть отменён, то он завершается как обычно после "
"выполнения операции ввода-вывода (в этом случае B<aio_error>(3) вернёт "
"состояние B<EINPROGRESSS>)."

#. type: Plain text
#: man-pages/man3/aio_cancel.3:77
msgid ""
"If I<aiocbp> is not NULL, and I<fd> differs from the file descriptor with "
"which the asynchronous operation was initiated, unspecified results occur."
msgstr ""
"В случае, если значение I<aiocbp> не равно NULL и I<fd> отличается от "
"файлового дескриптора, для которого создавалась асинхронная операция, то "
"поведение непредсказуемо."

#.  FreeBSD: not those on raw disk devices.
#. type: Plain text
#: man-pages/man3/aio_cancel.3:80
msgid "Which operations are cancelable is implementation-defined."
msgstr "Список операций, которые можно отменять, зависит от реализации."

#. type: Plain text
#: man-pages/man3/aio_cancel.3:84
msgid "The B<aio_cancel>()  function returns one of the following values:"
msgstr "Функция B<aio_cancel>() возвращает одно из следующих значений:"

#. type: TP
#: man-pages/man3/aio_cancel.3:84
#, no-wrap
msgid "B<AIO_CANCELED>"
msgstr "B<AIO_CANCELED>"

#. type: Plain text
#: man-pages/man3/aio_cancel.3:87
msgid "All requests were successfully canceled."
msgstr "Все запросы успешно отменены."

#. type: TP
#: man-pages/man3/aio_cancel.3:87
#, no-wrap
msgid "B<AIO_NOTCANCELED>"
msgstr "B<AIO_NOTCANCELED>"

#. type: Plain text
#: man-pages/man3/aio_cancel.3:93
msgid ""
"At least one of the requests specified was not canceled because it was in "
"progress.  In this case, one may check the status of individual requests "
"using B<aio_error>(3)."
msgstr ""
"Как минимум, один указанный запрос не отменён, так как он находится в "
"состоянии выполнения. В этом случае можно проверить состояние каждого запроса "
"с помощью B<aio_error>(3)."

#. type: TP
#: man-pages/man3/aio_cancel.3:93
#, no-wrap
msgid "B<AIO_ALLDONE>"
msgstr "B<AIO_ALLDONE>"

#. type: Plain text
#: man-pages/man3/aio_cancel.3:96
msgid "All requests had already been completed before the call."
msgstr "Все запросы выполнены ещё до вызова."

#. type: TP
#: man-pages/man3/aio_cancel.3:96
#, no-wrap
msgid "-1"
msgstr "-1"

#. type: Plain text
#: man-pages/man3/aio_cancel.3:101
msgid ""
"An error occurred.  The cause of the error can be found by inspecting "
"I<errno>."
msgstr "Произошла ошибка. Значение ошибки можно узнать из I<errno>."

#. type: Plain text
#: man-pages/man3/aio_cancel.3:106
msgid "I<fd> is not a valid file descriptor."
msgstr "Значение I<fd> не является правильным файловым дескриптором."

#. type: Plain text
#: man-pages/man3/aio_cancel.3:110
msgid "B<aio_cancel>()  is not implemented."
msgstr "Функция B<aio_cancel>() не реализована."

#. type: Plain text
#: man-pages/man3/aio_cancel.3:114
msgid "The B<aio_cancel>()  function is available since glibc 2.1."
msgstr "Функция B<aio_cancel>() доступна в glibc начиная с версии 2.1."

#. type: Plain text
#: man-pages/man3/aio_cancel.3:127
msgid ""
"B<aio_error>(3), B<aio_fsync>(3), B<aio_read>(3), B<aio_return>(3), "
"B<aio_suspend>(3), B<aio_write>(3), B<lio_listio>(3), B<aio>(7)"
msgstr ""
"B<aio_error>(3), B<aio_fsync>(3), B<aio_read>(3), B<aio_return>(3), B<"
"aio_suspend>(3), B<aio_write>(3), B<lio_listio>(3), B<aio>(7)"

#. type: TH
#: man-pages/man3/a64l.3:9
#, no-wrap
msgid "A64L"
msgstr "A64L"

#. type: Plain text
#: man-pages/man3/a64l.3:12
msgid "a64l, l64a - convert between long and base-64"
msgstr "a64l, l64a - преобразование между типами long и base-64"

#. type: Plain text
#: man-pages/man3/a64l.3:14
msgid "B<#include E<lt>stdlib.hE<gt>>"
msgstr "B<#include E<lt>stdlib.hE<gt>>"

#. type: Plain text
#: man-pages/man3/a64l.3:16
msgid "B<long a64l(const char *>I<str64>B<);>"
msgstr "B<long a64l(const char *>I<str64>B<);>"

#. type: Plain text
#: man-pages/man3/a64l.3:18
msgid "B<char *l64a(long >I<value>B<);>"
msgstr "B<char *l64a(long >I<value>B<);>"

#. type: Plain text
#: man-pages/man3/a64l.3:26
msgid "B<a64l>(), B<l64a>():"
msgstr "B<a64l>(), B<l64a>():"

#. type: Plain text
#: man-pages/man3/a64l.3:31
msgid ""
"_SVID_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 500 || _XOPEN_SOURCE\\ &&\\ "
"_XOPEN_SOURCE_EXTENDED"
msgstr ""
"_SVID_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 500 || _XOPEN_SOURCE\\ &&\\ "
"_XOPEN_SOURCE_EXTENDED"

#. type: Plain text
#: man-pages/man3/a64l.3:48
msgid ""
"These functions provide a conversion between 32-bit long integers and "
"little-endian base-64 ASCII strings (of length zero to six).  If the string "
"used as argument for B<a64l>()  has length greater than six, only the first "
"six bytes are used.  If the type I<long> has more than 32 bits, then "
"B<l64a>()  uses only the low order 32 bits of I<value>, and B<a64l>()  sign-"
"extends its 32-bit result."
msgstr ""
"Эти функции обеспечивают преобразование между 32-битными типами long integer "
"и строками little-endian base-64 ASCII (длиной от 0 до 6). Если строка, "
"используемая как аргумент для B<a64l>(), имеет длину более шести, то будут "
"использованы только первые 6 байтов. Если в типе I<long> более 32 битов, то "
"B<l64a>() будет использовать только младшие 32 бита значения I<value>, а B<"
"a64l>() расширит на знак свой 32-битный результат."

#. type: Plain text
#: man-pages/man3/a64l.3:50
msgid "The 64 digits in the base-64 system are:"
msgstr "64 цифры в системе кодирования base-64:"

#. type: Plain text
#: man-pages/man3/a64l.3:58
#, no-wrap
msgid ""
"\\&\\(aq.\\(aq\trepresents a 0\n"
"\\&\\(aq/\\(aq\trepresents a 1\n"
"0-9\trepresent  2-11\n"
"A-Z\trepresent 12-37\n"
"a-z\trepresent 38-63\n"
msgstr ""
"\\&\\(aq.\\(aq\tпредставляет 0\n\\&\\(aq/\\(aq\tпредставляет "
"1\n0-9\tпредставляет  2-11\nA-Z\tпредставляет 12-37\na-z\tпредставляет 38-63\n"

#. type: Plain text
#: man-pages/man3/a64l.3:62
msgid "So 123 = 59*64^0 + 1*64^1 = \"v/\"."
msgstr "Пример: 123 = 59*64^0 + 1*64^1 = \"v/\"."

#. type: Plain text
#: man-pages/man3/a64l.3:67
msgid "The B<l64a>()  function is not thread-safe."
msgstr "Функцию B<l64a>() нельзя использовать в нескольких нитях одновременно."

#. type: Plain text
#: man-pages/man3/a64l.3:71
msgid "The B<a64l>()  function is thread-safe."
msgstr "Функцию B<a64l>() можно использовать в нескольких нитях одновременно."

#. type: Plain text
#: man-pages/man3/a64l.3:73
msgid "POSIX.1-2001."
msgstr "POSIX.1-2001."

#. type: Plain text
#: man-pages/man3/a64l.3:78
msgid ""
"The value returned by B<l64a>()  may be a pointer to a static buffer, "
"possibly overwritten by later calls."
msgstr ""
"Значение, возвращаемое B<a64l>(), может быть указателем на статический буфер, "
"возможно перезаписываемый последующими вызовами."

#. type: Plain text
#: man-pages/man3/a64l.3:87
msgid ""
"The behavior of B<l64a>()  is undefined when I<value> is negative.  If "
"I<value> is zero, it returns an empty string."
msgstr ""
"Поведение B<l64a>() не определено, если I<value> отрицательно. Если значение "
"I<value> равно нулю, то возвращается пустая строка."

#. type: Plain text
#: man-pages/man3/a64l.3:90
msgid ""
"These functions are broken in glibc before 2.2.5 (puts most significant "
"digit first)."
msgstr ""
"Эти функции работают неправильно в glibc до версии 2.2.5 (сначала помещают "
"самые старшие разряды)."

#. type: Plain text
#: man-pages/man3/a64l.3:93
msgid "This is not the encoding used by B<uuencode>(1)."
msgstr "Это не та кодировка, которая используется в B<uuencode>(1)."

#.  .BR itoa (3),
#. type: Plain text
#: man-pages/man3/a64l.3:96
msgid "B<uuencode>(1), B<strtoul>(3)"
msgstr "B<uuencode>(1), B<strtoul>(3)"

#. type: TH
#: man-pages/man3/abs.3:34
#, no-wrap
msgid "ABS"
msgstr "ABS"

#. type: Plain text
#: man-pages/man3/abs.3:37
msgid "abs, labs, llabs, imaxabs - compute the absolute value of an integer"
msgstr ""
"abs, labs, llabs, imaxabs - вычисление абсолютного значения целого числа"

#. type: Plain text
#: man-pages/man3/abs.3:42
#, no-wrap
msgid "B<int abs(int >I<j>B<);>\n"
msgstr "B<int abs(int >I<j>B<);>\n"

#. type: Plain text
#: man-pages/man3/abs.3:44
#, no-wrap
msgid "B<long int labs(long int >I<j>B<);>\n"
msgstr "B<long int labs(long int >I<j>B<);>\n"

#. type: Plain text
#: man-pages/man3/abs.3:46
#, no-wrap
msgid "B<long long int llabs(long long int >I<j>B<);>\n"
msgstr "B<long long int llabs(long long int >I<j>B<);>\n"

#. type: Plain text
#: man-pages/man3/abs.3:48
#, no-wrap
msgid "B<#include E<lt>inttypes.hE<gt>>\n"
msgstr "B<#include E<lt>inttypes.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/abs.3:50
#, no-wrap
msgid "B<intmax_t imaxabs(intmax_t >I<j>B<);>\n"
msgstr "B<intmax_t imaxabs(intmax_t >I<j>B<);>\n"

#. type: Plain text
#: man-pages/man3/abs.3:59
msgid "B<llabs>():"
msgstr "B<llabs>():"

#. type: Plain text
#: man-pages/man3/abs.3:62
msgid ""
"_XOPEN_SOURCE\\ E<gt>=\\ 600 || _ISOC99_SOURCE || _POSIX_C_SOURCE\\ E<gt>=\\"
" 200112L;"
msgstr ""
"_XOPEN_SOURCE\\ E<gt>=\\ 600 || _ISOC99_SOURCE || _POSIX_C_SOURCE\\ E<gt>=\\ "
"200112L;"

#. type: Plain text
#: man-pages/man3/abs.3:79
msgid ""
"The B<abs>()  function computes the absolute value of the integer argument "
"I<j>.  The B<labs>(), B<llabs>()  and B<imaxabs>()  functions compute the "
"absolute value of the argument I<j> of the appropriate integer type for the "
"function."
msgstr ""
"Функция B<abs>() вычисляет абсолютное значение целого аргумента I<j>. Функции "
"B<labs>(), B<llabs>() и B<imaxabs>() вычисляют абсолютное значение аргумента "
"I<j> соответствующего типа целого."

#. type: Plain text
#: man-pages/man3/abs.3:82
msgid ""
"Returns the absolute value of the integer argument, of the appropriate "
"integer type for the function."
msgstr ""
"Возвращают абсолютное значение целого аргумента в соответствующем типе целого."

#. type: Plain text
#: man-pages/man3/abs.3:91
msgid ""
"The B<abs>(), B<labs>(), B<llabs>(), and B<imaxabs>()  functions are thread-"
"safe."
msgstr ""
"Функции B<abs>(), B<labs>(), B<llabs>() и B<imaxabs>() можно использовать в "
"нескольких нитях одновременно."

#.  POSIX.1 (1996 edition) requires only the
#.  .BR abs ()
#.  function.
#. type: Plain text
#: man-pages/man3/abs.3:106
msgid ""
"SVr4, POSIX.1-2001, 4.3BSD, C99.  C89 only includes the B<abs>()  and "
"B<labs>()  functions; the functions B<llabs>()  and B<imaxabs>()  were added"
" in C99."
msgstr ""
"SVr4, POSIX.1-2001, 4.3BSD, C99. C89 включает только функции B<abs>() и B<"
"labs>; функции B<llabs>() и B<imaxabs>() были добавлены в C99."

#. type: Plain text
#: man-pages/man3/abs.3:109
msgid ""
"Trying to take the absolute value of the most negative integer is not "
"defined."
msgstr "Абсолютное значение минимального отрицательного целого не определено."

#. type: Plain text
#: man-pages/man3/abs.3:118
msgid ""
"The B<llabs>()  function is included in glibc since version 2.0, but is not "
"in libc5 or libc4.  The B<imaxabs>()  function is included in glibc since "
"version 2.1.1."
msgstr ""
"Функция B<llabs>() включена в glibc начиная с версии 2.0, но её нет в libc5 "
"или libc4. Функция B<imaxabs>() включена в glibc начиная с версии 2.1.1."

#. type: Plain text
#: man-pages/man3/abs.3:124
msgid ""
"For B<llabs>()  to be declared, it may be necessary to define "
"B<_ISOC99_SOURCE> or B<_ISOC9X_SOURCE> (depending on the version of glibc) "
"before including any standard headers."
msgstr ""
"Чтобы объявить B<llabs>(), необходимо определить B<_ISOC99_SOURCE> или B<"
"_ISOC9X_SOURCE> (в зависимости от версии glibc) до включения любых "
"стандартных заголовочных файлов."

#. type: Plain text
#: man-pages/man3/abs.3:135
msgid ""
"GCC handles B<abs>()  and B<labs>()  as built-in functions.  GCC 3.0 also "
"handles B<llabs>()  and B<imaxabs>()  as built-ins."
msgstr ""
"В GCC B<abs>() и B<labs>() являются встроенными функциями. В GCC 3.0 B<llabs>"
"() and B<imaxabs>() также включены как встроенные."

#. type: Plain text
#: man-pages/man3/abs.3:140
msgid "B<cabs>(3), B<ceil>(3), B<fabs>(3), B<floor>(3), B<rint>(3)"
msgstr "B<cabs>(3), B<ceil>(3), B<fabs>(3), B<floor>(3), B<rint>(3)"

#. type: TH
#: man-pages/man3/aio_init.3:26
#, no-wrap
msgid "AIO_INIT"
msgstr "AIO_INIT"

#. type: TH
#: man-pages/man3/aio_init.3:26
#, no-wrap
msgid "2012-04-26"
msgstr "2012-04-26"

#. type: Plain text
#: man-pages/man3/aio_init.3:29
msgid "aio_init - asynchronous I/O initialization"
msgstr "aio_init - инициализирует асинхронный ввод-вывод"

#. type: Plain text
#: man-pages/man3/aio_init.3:33
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>         /* See feature_test_macros(7) */\n"
"B<#include E<lt>aio.hE<gt>>\n"
msgstr ""
"B<#define _GNU_SOURCE>         /* см. feature_test_macros(7) */\nB<#include "
"E<lt>aio.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/aio_init.3:35
#, no-wrap
msgid "B<void aio_init(const struct aioinit *>I<init>B<);>\n"
msgstr "B<void aio_init(const struct aioinit *>I<init>B<);>\n"

#. type: Plain text
#: man-pages/man3/aio_init.3:45
msgid ""
"The GNU-specific B<aio_init>()  function allows the caller to provide tuning"
" hints to the glibc POSIX AIO implementation.  Use of this function is "
"optional, but to be effective, it must be called before employing any other "
"functions in the POSIX AIO API."
msgstr ""
"Имеющаяся только в GNU функция B<aio_init>() позволяет вызывающему указать "
"подстроечные подсказки реализации glibc POSIX AIO. Использовать данную "
"функцию необязательно, но для эффективности её нужно вызвать перед вызовом "
"какой-либо функции программного интерфейса POSIX AIO."

#. type: Plain text
#: man-pages/man3/aio_init.3:49
msgid ""
"The tuning information is provided in the buffer pointed to by the argument "
"I<init>.  This buffer is a structure of the following form:"
msgstr ""
"Подстроечная информация передаётся в буфере, на который указывает параметр I<"
"init>. Данный буфер представляет собой следующую структуру:"

#. type: Plain text
#: man-pages/man3/aio_init.3:64
#, no-wrap
msgid ""
"struct aioinit {\n"
"    int aio_threads;    /* Maximum number of threads */\n"
"    int aio_num;        /* Number of expected simultaneous\n"
"                           requests */\n"
"    int aio_locks;      /* Not used */\n"
"    int aio_usedba;     /* Not used */\n"
"    int aio_debug;      /* Not used */\n"
"    int aio_numusers;   /* Not used */\n"
"    int aio_idle_time;  /* Number of seconds before idle thread\n"
"                           terminates (since glibc 2.2) */\n"
"    int aio_reserved;\n"
"};\n"
msgstr ""
"struct aioinit {\n    int aio_threads;    /* максимальное количество нитей "
"*/\n    int aio_num;        /* количество ожидаемых одновременных\n           "
"                запросов */\n    int aio_locks;      /* не используется */\n  "
"  int aio_usedba;     /* не используется */\n    int aio_debug;      /* не "
"используется */\n    int aio_numusers;   /* не используется */\n    int "
"aio_idle_time;  /* количество секунд перед завершением\n                      "
"     незанятой нити (начиная с glibc 2.2) */\n    int aio_reserved;\n};\n"

#. type: Plain text
#: man-pages/man3/aio_init.3:70
msgid "The following fields are used in the I<aioinit> structure:"
msgstr "В структуре I<aioinit> используются следующие поля:"

#. type: TP
#: man-pages/man3/aio_init.3:70
#, no-wrap
msgid "I<aio_threads>"
msgstr "I<aio_threads>"

#. type: Plain text
#: man-pages/man3/aio_init.3:78
msgid ""
"This field specifies the maximum number of worker threads that may be used "
"by the implementation.  If the number of outstanding I/O operations exceeds "
"this limit, then excess operations will be queued until a worker thread "
"becomes free.  If this field is specified with a value less than 1, the "
"value 1 is used.  The default value is 20."
msgstr ""
"В этом поле задаётся максимальное количество обрабатывающих (worker) нитей, "
"которые могут использоваться в реализации. Если количество ожидающих операций "
"ввода-вывода превышает это значение, то лишние операции будут в очереди до "
"тех пор, пока не освободится обрабатывающая нить. Если значение поля меньше "
"1, то используется значение 1. Значение по умолчанию равно 20."

#. type: TP
#: man-pages/man3/aio_init.3:78
#, no-wrap
msgid "I<aio_num>"
msgstr "I<aio_num>"

#.  FIXME But, if aio_num > 32, the behavior looks strange. See
#.  http://sourceware.org/bugzilla/show_bug.cgi?id=12083
#. type: Plain text
#: man-pages/man3/aio_init.3:87
msgid ""
"This field should specify the maximum number of simultaneous I/O requests "
"that the caller expects to enqueue.  If a value less than 32 is specified "
"for this field, it is rounded up to 32.  The default value is 64."
msgstr ""
"В этом поле задаётся максимальное количество одновременных запросов "
"ввода-вывода, которое вызывающий хочет видеть в очереди. Если значение поля "
"меньше 32, то оно округляется до 32. Значение по умолчанию равно 64."

#. type: TP
#: man-pages/man3/aio_init.3:87
#, no-wrap
msgid "I<aio_idle_time>"
msgstr "I<aio_idle_time>"

#. type: Plain text
#: man-pages/man3/aio_init.3:93
msgid ""
"This field specifies the amount of time in seconds that a worker thread "
"should wait for further requests before terminating, after having completed "
"a previous request.  The default value is 1."
msgstr ""
"В этом поле задаётся период времени в секундах, который обрабатывающая нить "
"должна ждать следующего запроса перед своим уничтожением, отсчитывая от "
"окончания выполнения предыдущего запроса. Значение по умолчанию равно 1."

#. type: Plain text
#: man-pages/man3/aio_init.3:97
msgid "The B<aio_init>()  function is available since glibc 2.1."
msgstr "Функция B<aio_init>() доступна в glibc начиная с версии 2.1."

#. type: Plain text
#: man-pages/man3/aio_init.3:99
msgid "This function is a GNU extension."
msgstr "Эта функция является расширением GNU."

#. type: Plain text
#: man-pages/man3/aio_init.3:100
msgid "B<aio>(7)"
msgstr "B<aio>(7)"

#. type: TH
#: man-pages/man3/atoi.3:33
#, no-wrap
msgid "ATOI"
msgstr "ATOI"

#. type: TH
#: man-pages/man3/atoi.3:33
#, no-wrap
msgid "2014-01-22"
msgstr "2014-01-22"

#. type: Plain text
#: man-pages/man3/atoi.3:36
msgid "atoi, atol, atoll, atoq - convert a string to an integer"
msgstr "atoi, atol, atoll, atoq - преобразовывает строку в целое число"

#. type: Plain text
#: man-pages/man3/atoi.3:41
#, no-wrap
msgid "B<int atoi(const char *>I<nptr>B<);>\n"
msgstr "B<int atoi(const char *>I<nptr>B<);>\n"

#. type: Plain text
#: man-pages/man3/atoi.3:43
#, no-wrap
msgid "B<long atol(const char *>I<nptr>B<);>\n"
msgstr "B<long atol(const char *>I<nptr>B<);>\n"

#. type: Plain text
#: man-pages/man3/atoi.3:45
#, no-wrap
msgid "B<long long atoll(const char *>I<nptr>B<);>\n"
msgstr "B<long long atoll(const char *>I<nptr>B<);>\n"

#. type: Plain text
#: man-pages/man3/atoi.3:47
#, no-wrap
msgid "B<long long atoq(const char *>I<nptr>B<);>\n"
msgstr "B<long long atoq(const char *>I<nptr>B<);>\n"

#. type: Plain text
#: man-pages/man3/atoi.3:56
msgid "B<atoll>():"
msgstr "B<atoll>():"

#. type: Plain text
#: man-pages/man3/atoi.3:71
msgid ""
"The B<atoi>()  function converts the initial portion of the string pointed "
"to by I<nptr> to I<int>.  The behavior is the same as"
msgstr ""
"Функция B<atoi>() преобразовывает начальную часть строки, на которую "
"указывает I<nptr>, к типу I<int>. Она действует также как"

#. type: Plain text
#: man-pages/man3/atoi.3:74
msgid "strtol(nptr, NULL, 10);"
msgstr "strtol(nptr, NULL, 10);"

#. type: Plain text
#: man-pages/man3/atoi.3:79
msgid "except that B<atoi>()  does not detect errors."
msgstr "однако B<atoi>() не определяет ошибки."

#. type: Plain text
#: man-pages/man3/atoi.3:91
msgid ""
"The B<atol>()  and B<atoll>()  functions behave the same as B<atoi>(), "
"except that they convert the initial portion of the string to their return "
"type of I<long> or I<long long>.  B<atoq>()  is an obsolete name for "
"B<atoll>()."
msgstr ""
"Функции B<atol>() и B<atoll>() ведут себя так же, как и B<atoi>(), за "
"исключением того факта, что начальная часть строки приводится к типу I<long> "
"или I<long long>. B<atoq>() является устаревшим именем для B<atoll>()."

#. type: Plain text
#: man-pages/man3/atoi.3:93
msgid "The converted value."
msgstr "Преобразованное значение."

#. type: Plain text
#: man-pages/man3/atoi.3:105
msgid ""
"The B<atoi>(), B<atol>(), and B<atoll>()  functions are thread-safe with "
"exceptions.  These functions can be safely used in multithreaded "
"applications, as long as B<setlocale>(3)  is not called to change the locale"
" during their execution."
msgstr ""
"Функции B<atoi>(), B<atol>() и B<atoll>() можно использовать в нескольких "
"нитях одновременно с несколькими исключениями. Эти функции можно использовать "
"в многонитевых приложениях, если во время их работы не вызывать B<setlocale>"
"(3)."

#. type: Plain text
#: man-pages/man3/atoi.3:115
msgid ""
"SVr4, POSIX.1-2001, 4.3BSD, C99.  C89 and POSIX.1-1996 include the functions"
" B<atoi>()  and B<atol>()  only.  B<atoq>()  is a GNU extension."
msgstr ""
"SVr4, POSIX.1-2001, 4.3BSD, C99. В C89 и POSIX.1-1996 включены только функции "
"B<atoi>() и B<atol>(). B<atoq>() является расширением GNU."

#. type: Plain text
#: man-pages/man3/atoi.3:125
msgid ""
"The nonstandard B<atoq>()  function is not present in libc 4.6.27 or glibc "
"2, but is present in libc5 and libc 4.7 (though only as an inline function "
"in I<E<lt>stdlib.hE<gt>> until libc 5.4.44).  The B<atoll>()  function is "
"present in glibc 2 since version 2.0.2, but not in libc4 or libc5."
msgstr ""
"Нестандартная функция B<atoq>() отсутствует в libc 4.6.27 или glibc 2, но "
"присутствует в libc5 и libc 4.7 (хотя только в виде встроенной функции в I<"
"E<lt>stdlib.hE<gt>> до libc 5.4.44). Функция B<atoll>() присутствует в glibc "
"2 начиная с версии 2.0.2, но отсутствует в libc4 и libc5."

#. type: Plain text
#: man-pages/man3/atoi.3:129
msgid "B<atof>(3), B<strtod>(3), B<strtol>(3), B<strtoul>(3)"
msgstr "B<atof>(3), B<strtod>(3), B<strtol>(3), B<strtoul>(3)"

#. type: TH
#: man-pages/man3/alloca.3:43
#, no-wrap
msgid "ALLOCA"
msgstr "ALLOCA"

#. type: Plain text
#: man-pages/man3/alloca.3:46
msgid "alloca - allocate memory that is automatically freed"
msgstr "alloca - выделяет память, которая будет высвобождена автоматически"

#. type: Plain text
#: man-pages/man3/alloca.3:48
msgid "B<#include E<lt>alloca.hE<gt>>"
msgstr "B<#include E<lt>alloca.hE<gt>>"

#. type: Plain text
#: man-pages/man3/alloca.3:50
msgid "B<void *alloca(size_t >I<size>B<);>"
msgstr "B<void *alloca(size_t >I<size>B<);>"

#. type: Plain text
#: man-pages/man3/alloca.3:60
msgid ""
"The B<alloca>()  function allocates I<size> bytes of space in the stack "
"frame of the caller.  This temporary space is automatically freed when the "
"function that called B<alloca>()  returns to its caller."
msgstr ""
"Функция B<alloca>() выделяет I<size> байтов памяти в стековом кадре "
"вызывающего. Это временное хранилище данных автоматически освобождается после "
"возврата из функции, вызвавшей B<alloca>()."

#. type: Plain text
#: man-pages/man3/alloca.3:65
msgid ""
"The B<alloca>()  function returns a pointer to the beginning of the "
"allocated space.  If the allocation causes stack overflow, program behavior "
"is undefined."
msgstr ""
"Функция B<alloca>() возвращает указатель на начало выделенной памяти. Если "
"выделение памяти привело к переполнению стека, то дальнейшее поведение "
"программы не определено."

#. type: Plain text
#: man-pages/man3/alloca.3:70
msgid "The B<alloca>()  function is thread-safe."
msgstr ""
"Функцию B<alloca>() можно использовать в нескольких нитях одновременно."

#. type: Plain text
#: man-pages/man3/alloca.3:72
msgid "This function is not in POSIX.1-2001."
msgstr "Данная функция отсутствует в POSIX.1-2001."

#. type: Plain text
#: man-pages/man3/alloca.3:78
msgid ""
"There is evidence that the B<alloca>()  function appeared in 32V, PWB, "
"PWB.2, 3BSD, and 4BSD.  There is a man page for it in 4.3BSD.  Linux uses "
"the GNU version."
msgstr ""
"Очевидно, что данная функция B<alloca>() существует в 32V, PWB, PWB.2, 3BSD и "
"4BSD. Это можно понять по наличию соответствующей справочной страницы в "
"4.3BSD. В Linux используется версия GNU."

#. type: Plain text
#: man-pages/man3/alloca.3:93
msgid ""
"The B<alloca>()  function is machine- and compiler-dependent.  For certain "
"applications, its use can improve efficiency compared to the use of "
"B<malloc>(3)  plus B<free>(3).  In certain cases, it can also simplify "
"memory deallocation in applications that use B<longjmp>(3)  or "
"B<siglongjmp>(3).  Otherwise, its use is discouraged."
msgstr ""
"Работа функции B<alloca>() зависит от машины и компилятора. В некоторых "
"приложениях её использование может повысить эффективность (если сравнивать с "
"B<malloc>(3) плюс B<free>(3)). В определённых случаях она также может "
"упростить высвобождение памяти в приложениях, использующих B<longjmp>(3) или "
"B<siglongjmp>(3). Но лучше её не использовать."

#. type: Plain text
#: man-pages/man3/alloca.3:102
msgid ""
"Because the space allocated by B<alloca>()  is allocated within the stack "
"frame, that space is automatically freed if the function return is jumped "
"over by a call to B<longjmp>(3)  or B<siglongjmp>(3)."
msgstr ""
"Так как пространство, выделяемое B<alloca>(), берётся из стекового кадра, то "
"оно автоматически освобождается, когда возврат из функции производится "
"вызовом B<longjmp>(3) или B<siglongjmp>(3)."

#. type: Plain text
#: man-pages/man3/alloca.3:107
msgid "Do not attempt to B<free>(3)  space allocated by B<alloca>()!"
msgstr ""
"Не пытайтесь освободить место, выделенное B<alloca>(), с помощью B<free>(3)!"

#. type: SS
#: man-pages/man3/alloca.3:107
#, no-wrap
msgid "Notes on the GNU version"
msgstr "Замечания для версии GNU"

#. type: Plain text
#: man-pages/man3/alloca.3:129
msgid ""
"Normally, B<gcc>(1)  translates calls to B<alloca>()  with inlined code.  "
"This is not done when either the I<-ansi>, I<-std=c89>, I<-std=c99>, or the "
"I<-std=c11> option is given B<and> the header I<E<lt>alloca.hE<gt>> is not "
"included.  Otherwise, (without an -ansi or -std=c* option) the glibc version"
" of I<E<lt>stdlib.hE<gt>> includes I<E<lt>alloca.hE<gt>> and that contains "
"the lines:"
msgstr ""
"Обычно, B<gcc>(1) встраивает код B<alloca>() в место вызова. Это не делается, "
"если был указан параметр I<-ansi>, I<-std=c89>, I<-std=c99> или I<-std=c11> "
"B<и> заголовочный файл I<E<lt>alloca.hE<gt>> не включается. В противном "
"случае (без параметра -ansi или -std=c*) версия glibc файла I<E<lt>stdlib.hE<"
"gt>> включает I<E<lt>alloca.hE<gt>>, который содержит строки:"

#. type: Plain text
#: man-pages/man3/alloca.3:134
#, no-wrap
msgid ""
"    #ifdef  __GNUC__\n"
"    #define alloca(size)   __builtin_alloca (size)\n"
"    #endif\n"
msgstr ""
"    #ifdef  __GNUC__\n    #define alloca(size)   __builtin_alloca (size)\n    "
"#endif\n"

#. type: Plain text
#: man-pages/man3/alloca.3:137
msgid "with messy consequences if one has a private version of this function."
msgstr ""
"что приводит к множеству неприятных последствий, если у кого-то есть своя "
"версия этой функции."

#. type: Plain text
#: man-pages/man3/alloca.3:141
msgid ""
"The fact that the code is inlined means that it is impossible to take the "
"address of this function, or to change its behavior by linking with a "
"different library."
msgstr ""
"Тот факт, что код встраивается, означает, что будет невозможно получить адрес "
"этой функции или изменить её поведение посредством компоновки с другой "
"библиотекой."

#. type: Plain text
#: man-pages/man3/alloca.3:145
msgid ""
"The inlined code often consists of a single instruction adjusting the stack "
"pointer, and does not check for stack overflow.  Thus, there is no NULL "
"error return."
msgstr ""
"Встраиваемый код часто представляет собой одну инструкцию, корректирующую "
"указатель стека и не отслеживающую переполнение стека. Поэтому при ошибке "
"невозможно получить NULL."

#. type: Plain text
#: man-pages/man3/alloca.3:150
msgid ""
"There is no error indication if the stack frame cannot be extended.  "
"(However, after a failed allocation, the program is likely to receive a "
"B<SIGSEGV> signal if it attempts to access the unallocated space.)"
msgstr ""
"Если стековый кадр не может быть расширен, то никакой ошибки также не "
"возвращается (однако, после неудачного выделения программа, вероятно, получит "
"сигнал B<SIGSEGV> при попытке доступа к не выделенному пространству)."

#. type: Plain text
#: man-pages/man3/alloca.3:158
msgid ""
"On many systems B<alloca>()  cannot be used inside the list of arguments of "
"a function call, because the stack space reserved by B<alloca>()  would "
"appear on the stack in the middle of the space for the function arguments."
msgstr ""
"Во многих системах B<alloca>() не может быть использована в списке аргументов "
"вызова функции, так как пространство под стек, зарезервированное B<alloca>(), "
"возникло бы между аргументами функции."

#. type: Plain text
#: man-pages/man3/alloca.3:161
msgid "B<brk>(2), B<longjmp>(3), B<malloc>(3)"
msgstr "B<brk>(2), B<longjmp>(3), B<malloc>(3)"

#. type: TH
#: man-pages/man3/atof.3:31
#, no-wrap
msgid "ATOF"
msgstr "ATOF"

#. type: Plain text
#: man-pages/man3/atof.3:34
msgid "atof - convert a string to a double"
msgstr "atof - преобразует строку в значение типа double"

#. type: Plain text
#: man-pages/man3/atof.3:39
#, no-wrap
msgid "B<double atof(const char *>I<nptr>B<);>\n"
msgstr "B<double atof(const char *>I<nptr>B<);>\n"

#. type: Plain text
#: man-pages/man3/atof.3:47
msgid ""
"The B<atof>()  function converts the initial portion of the string pointed "
"to by I<nptr> to I<double>.  The behavior is the same as"
msgstr ""
"Функция B<atof>() преобразовывает начальную часть строки, на которую "
"указывает I<nptr>, к типу I<double>. Она действует также как"

#. type: Plain text
#: man-pages/man3/atof.3:50
msgid "strtod(nptr, NULL);"
msgstr "strtod(nptr, NULL);"

#. type: Plain text
#: man-pages/man3/atof.3:55
msgid "except that B<atof>()  does not detect errors."
msgstr "однако B<atof>() не определяет ошибки."

#. type: Plain text
#: man-pages/man3/atof.3:65
msgid ""
"The B<atof>()  function is thread-safe with exceptions.  It can be safely "
"used in multithreaded applications, as long as B<setlocale>(3)  is not "
"called to change the locale during its execution."
msgstr ""
"Функцию B<atof>() можно использовать в нескольких нитях одновременно с "
"несколькими исключениями. Эту функцию можно использовать в многонитевых "
"приложениях, если во время её работы не вызывать B<setlocale>(3)."

#. type: Plain text
#: man-pages/man3/atof.3:67
msgid "SVr4, POSIX.1-2001, 4.3BSD, C89, C99."
msgstr "SVr4, POSIX.1-2001, 4.3BSD, C89, C99."

#. type: Plain text
#: man-pages/man3/atof.3:72
msgid "B<atoi>(3), B<atol>(3), B<strtod>(3), B<strtol>(3), B<strtoul>(3)"
msgstr "B<atoi>(3), B<atol>(3), B<strtod>(3), B<strtol>(3), B<strtoul>(3)"

#. type: TH
#: man-pages/man3/abort.3:34
#, no-wrap
msgid "ABORT"
msgstr "ABORT"

#. type: TH
#: man-pages/man3/abort.3:34
#, no-wrap
msgid "2014-03-25"
msgstr "2014-03-25"

#. type: Plain text
#: man-pages/man3/abort.3:37
msgid "abort - cause abnormal process termination"
msgstr "abort - аварийно завершает процесс"

#. type: Plain text
#: man-pages/man3/abort.3:42
#, no-wrap
msgid "B<void abort(void);>\n"
msgstr "B<void abort(void);>\n"

#. type: Plain text
#: man-pages/man3/abort.3:54
msgid ""
"The B<abort>()  first unblocks the B<SIGABRT> signal, and then raises that "
"signal for the calling process.  This results in the abnormal termination of"
" the process unless the B<SIGABRT> signal is caught and the signal handler "
"does not return (see B<longjmp>(3))."
msgstr ""
"Сначала функция B<abort>() разблокирует сигнал B<SIGABRT>, а затем генерирует "
"этот сигнал для вызывающего процесса. Это приводит к аварийному завершению "
"процесса, если сигнал B<SIGABRT> не обрабатывается и обработчик сигнала не "
"возвращает управление (см. B<longjmp>(3))."

#. type: Plain text
#: man-pages/man3/abort.3:59
msgid ""
"If the B<abort>()  function causes process termination, all open streams are"
" closed and flushed."
msgstr ""
"Если функция B<abort>() приводит к аварийному завершению процесса, то все "
"открытые потоки закрываются и сбрасываются (flushed)."

#. type: Plain text
#: man-pages/man3/abort.3:68
msgid ""
"If the B<SIGABRT> signal is ignored, or caught by a handler that returns, "
"the B<abort>()  function will still terminate the process.  It does this by "
"restoring the default disposition for B<SIGABRT> and then raising the signal"
" for a second time."
msgstr ""
"Если сигнал B<SIGABRT> игнорируется или обрабатывается обработчиком, который "
"возвращает управление, то функция B<abort>() всё равно завершит процесс. Она "
"восстанавливает обработчик B<SIGABRT> по умолчанию, а затем генерирует сигнал "
"повторно."

#. type: Plain text
#: man-pages/man3/abort.3:72
msgid "The B<abort>()  function never returns."
msgstr "Функция B<abort>() никогда не возвращает управление."

#. type: Plain text
#: man-pages/man3/abort.3:77
msgid "The B<abort>()  function is thread-safe."
msgstr "Функцию B<abort>() можно использовать в нескольких нитях одновременно."

#. type: Plain text
#: man-pages/man3/abort.3:84
msgid "B<gdb>(1), B<sigaction>(2), B<exit>(3), B<longjmp>(3), B<raise>(3)"
msgstr "B<gdb>(1), B<sigaction>(2), B<exit>(3), B<longjmp>(3), B<raise>(3)"

#. type: TH
#: man-pages/man3/asin.3:35
#, no-wrap
msgid "ASIN"
msgstr "ASIN"

#. type: Plain text
#: man-pages/man3/asin.3:38
msgid "asin, asinf, asinl - arc sine function"
msgstr "asin, asinf, asinl - функция вычисления арксинуса"

#. type: Plain text
#: man-pages/man3/asin.3:43
#, no-wrap
msgid "B<double asin(double >I<x>B<);>\n"
msgstr "B<double asin(double >I<x>B<);>\n"

#. type: Plain text
#: man-pages/man3/asin.3:45
#, no-wrap
msgid "B<float asinf(float >I<x>B<);>\n"
msgstr "B<float asinf(float >I<x>B<);>\n"

#. type: Plain text
#: man-pages/man3/asin.3:47
#, no-wrap
msgid "B<long double asinl(long double >I<x>B<);>\n"
msgstr "B<long double asinl(long double >I<x>B<);>\n"

#. type: Plain text
#: man-pages/man3/asin.3:59
msgid "B<asinf>(), B<asinl>():"
msgstr "B<asinf>(), B<asinl>():"

#. type: Plain text
#: man-pages/man3/asin.3:74
msgid ""
"The B<asin>()  function calculates the principal value of the arc sine of "
"I<x>; that is the value whose sine is I<x>."
msgstr ""
"Функция B<asin>() вычисляет арксинус от I<x>; это значение, синус которого "
"равен I<x>."

#. type: Plain text
#: man-pages/man3/asin.3:78
msgid ""
"On success, these functions return the principal value of the arc sine of "
"I<x> in radians; the return value is in the range [-pi/2,\\ pi/2]."
msgstr ""
"В случае успеха эти функции возвращают арксинус от I<x> в радианах; результат "
"лежит в диапазоне значений [-pi/2,\\ pi/2]."

#.  POSIX.1-2001 documents an optional range error for subnormal x;
#.  glibc 2.8 does not do this.
#. type: Plain text
#: man-pages/man3/asin.3:96
msgid ""
"If I<x> is outside the range [-1,\\ 1], a domain error occurs, and a NaN is "
"returned."
msgstr ""
"Если I<x> находится вне пределов [-1,\\ 1], то будет сгенерирована ошибка "
"выхода за пределы области, а в качестве результата будет возвращено значение "
"NaN."

#. type: TP
#: man-pages/man3/asin.3:103
#, no-wrap
msgid "Domain error: I<x> is outside the range [-1,\\ 1]"
msgstr "Ошибка области: I<x> находится вне диапазона [-1,\\ 1]"

#. type: Plain text
#: man-pages/man3/asin.3:124
msgid ""
"B<acos>(3), B<atan>(3), B<atan2>(3), B<casin>(3), B<cos>(3), B<sin>(3), "
"B<tan>(3)"
msgstr ""
"B<acos>(3), B<atan>(3), B<atan2>(3), B<casin>(3), B<cos>(3), B<sin>(3), B<tan>"
"(3)"

#. type: TH
#: man-pages/man3/aio_write.3:24
#, no-wrap
msgid "AIO_WRITE"
msgstr "AIO_WRITE"

#. type: Plain text
#: man-pages/man3/aio_write.3:27
msgid "aio_write - asynchronous write"
msgstr "aio_write - асинхронная запись"

#. type: Plain text
#: man-pages/man3/aio_write.3:31
msgid "B<int aio_write(struct aiocb *>I<aiocbp>B<);>"
msgstr "B<int aio_write(struct aiocb *>I<aiocbp>B<);>"

#. type: Plain text
#: man-pages/man3/aio_write.3:41
msgid ""
"The B<aio_write>()  function queues the I/O request described by the buffer "
"pointed to by I<aiocbp>.  This function is the asynchronous analog of "
"B<write>(2).  The arguments of the call"
msgstr ""
"Функция B<aio_write>() ставит в очередь запрос ввода-вывода, описанный в "
"буфере, на который указывает I<aiocbp>. Эта функция является асинхронным "
"аналогом вызова B<write>(2). Аргументы функции"

#. type: Plain text
#: man-pages/man3/aio_write.3:43
#, no-wrap
msgid "    write(fd, buf, count)\n"
msgstr "    write(fd, buf, count)\n"

#. type: Plain text
#: man-pages/man3/aio_write.3:69
msgid ""
"If B<O_APPEND> is not set, the data is written starting at the absolute file"
" offset I<aiocbp-E<gt>aio_offset>, regardless of the current file offset.  "
"If B<O_APPEND> is set, data is written at the end of the file in the same "
"order as B<aio_write>()  calls are made.  After the call, the value of the "
"current file offset is unspecified."
msgstr ""
"Если флаг B<O_APPEND> не установлен, то данные записываются начиная от "
"абсолютного смещения в файле I<aiocbp-E<gt>aio_offset>, независимо от "
"текущего смещения в файле. Если флаг B<O_APPEND> установлен, то данные "
"записываются в конец файла в том порядке, в котором запускались вызовы B<"
"aio_write>(). После вызова значение текущего смещения файла не определено."

#. type: Plain text
#: man-pages/man3/aio_write.3:82
msgid ""
"The \"asynchronous\" means that this call returns as soon as the request has"
" been enqueued; the write may or may not have completed when the call "
"returns.  One tests for completion using B<aio_error>(3).  The return status"
" of a completed I/O operation can be obtained B<aio_return>(3).  "
"Asynchronous notification of I/O completion can be obtained by setting "
"I<aiocbp-E<gt>aio_sigevent> appropriately; see B<sigevent>(7)  for details."
msgstr ""
"Прилагательное «асинхронный» означает, что вызов возвращает управление сразу "
"после установки запроса в очередь; при завершении вызова запись может уже "
"выполнится, а может и нет. Для проверки выполнения чтения используйте B<"
"aio_error>(3). Состояние возврата завершённой операции ввода-вывода можно "
"получить с помощью B<aio_return>(3). Асинхронное уведомление о выполнении "
"ввода-вывода можно получить, установив I<aiocbp-E<gt>aio_sigevent> "
"соответствующим образом; подробней смотрите в B<sigevent>(7)."

#. type: Plain text
#: man-pages/man3/aio_write.3:95
msgid "No data is written to a regular file beyond its maximum offset."
msgstr ""
"Запись не производится в обычный файл, если смещение превышает максимум."

#. type: TP
#: man-pages/man3/aio_write.3:118
#, no-wrap
msgid "B<EFBIG>"
msgstr "B<EFBIG>"

#. type: Plain text
#: man-pages/man3/aio_write.3:122
msgid ""
"The file is a regular file, we want to write at least one byte, but the "
"starting position is at or beyond the maximum offset for this file."
msgstr ""
"Файл является обычным файлом, мы хотим записать не менее одного байта, но "
"начальная позиция равна максимальному значению смещения этого файла или "
"превышает его."

#. type: Plain text
#: man-pages/man3/aio_write.3:129
msgid ""
"One or more of I<aio_offset>, I<aio_reqprio>, I<aio_nbytes> are invalid."
msgstr ""
"Одно или несколько значений у I<aio_offset>, I<aio_reqprio> или I<aio_nbytes>"
", неверны."

#. type: Plain text
#: man-pages/man3/aio_write.3:133
msgid "B<aio_write>()  is not implemented."
msgstr "Функция B<aio_write>() не реализована."

#. type: Plain text
#: man-pages/man3/aio_write.3:137
msgid "The B<aio_write>()  function is available since glibc 2.1."
msgstr "Функция B<aio_write>() доступна в glibc начиная с версии 2.1."

#.  or the control block of the operation
#. type: Plain text
#: man-pages/man3/aio_write.3:147
msgid ""
"It is a good idea to zero out the control block before use.  The control "
"block must not be changed while the write operation is in progress.  The "
"buffer area being written out must not be accessed during the operation or "
"undefined results may occur.  The memory areas involved must remain valid."
msgstr ""
"Желательно обнулять буфер блока управления перед использованием. Блок "
"управления не должен изменяться во время выполнения операции записи. Область "
"буфера, в которую выполняется запись, должна быть недоступна во время "
"операции, иначе поведение непредсказуемо. Области памяти, с которыми "
"производится работа, должны оставаться доступными."

#. type: Plain text
#: man-pages/man3/aio_write.3:159
msgid ""
"B<aio_cancel>(3), B<aio_error>(3), B<aio_fsync>(3), B<aio_read>(3), "
"B<aio_return>(3), B<aio_suspend>(3), B<lio_listio>(3), B<aio>(7)"
msgstr ""
"B<aio_cancel>(3), B<aio_error>(3), B<aio_fsync>(3), B<aio_read>(3), B<"
"aio_return>(3), B<aio_suspend>(3), B<lio_listio>(3), B<aio>(7)"

#. type: TH
#: man-pages/man3/assert.3:27
#, no-wrap
msgid "ASSERT"
msgstr "ASSERT"

#. type: TH
#: man-pages/man3/assert.3:27
#, no-wrap
msgid "2013-09-26"
msgstr "2013-09-26"

#. type: Plain text
#: man-pages/man3/assert.3:30
msgid "assert - abort the program if assertion is false"
msgstr "assert - прекращает работу программы при ложном утверждении"

#. type: Plain text
#: man-pages/man3/assert.3:33
#, no-wrap
msgid "B<#include E<lt>assert.hE<gt>>\n"
msgstr "B<#include E<lt>assert.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/assert.3:35
#, no-wrap
msgid "B<void assert(scalar >I<expression>B<);>\n"
msgstr "B<void assert(scalar >I<expression>B<);>\n"

#. type: Plain text
#: man-pages/man3/assert.3:52
msgid ""
"If the macro B<NDEBUG> was defined at the moment I<E<lt>assert.hE<gt>> was "
"last included, the macro B<assert>()  generates no code, and hence does "
"nothing at all.  Otherwise, the macro B<assert>()  prints an error message "
"to standard error and terminates the program by calling B<abort>(3)  if "
"I<expression> is false (i.e., compares equal to zero)."
msgstr ""
"Если на момент последнего включения I<E<lt>assert.hE<gt>> был определён "
"макрос B<NDEBUG>, то для макроса B<assert>() не создаётся никакого кода и, "
"соответственно, он вообще ничего не делает. В противном случае, макрос B<"
"assert>() выводит в стандартный поток ошибок сообщение об ошибке и прекращает "
"работу программы вызовом B<abort>(3), если значение I<expression> ложно (т. "
"е. при сравнении равно нулю)."

#. type: Plain text
#: man-pages/man3/assert.3:57
msgid ""
"The purpose of this macro is to help programmers find bugs in their "
"programs.  The message \"assertion failed in file foo.c, function do_bar(), "
"line 1287\" is of no help at all to a user."
msgstr ""
"Данный макрос помогает программисту находить ошибки в своих программах. Для "
"пользователя, сообщения типа «assertion failed in file foo.c, function "
"do_bar(), line 1287» бесполезны."

#. type: Plain text
#: man-pages/man3/assert.3:59
msgid "No value is returned."
msgstr "Ничего не возвращается."

#.  See Defect Report 107 for more details.
#. type: Plain text
#: man-pages/man3/assert.3:68
msgid ""
"POSIX.1-2001, C89, C99.  In C89, I<expression> is required to be of type "
"I<int> and undefined behavior results if it is not, but in C99 it may have "
"any scalar type."
msgstr ""
"POSIX.1-2001, C89, C99. В стандарте C89 указано, что значение I<expression> "
"должно иметь тип I<int>, и поведение функции непредсказуемо, если это не так; "
"согласно стандарту C99, переменная может быть любого скалярного типа."

#. type: Plain text
#: man-pages/man3/assert.3:76
msgid ""
"B<assert>()  is implemented as a macro; if the expression tested has side-"
"effects, program behavior will be different depending on whether B<NDEBUG> "
"is defined.  This may create Heisenbugs which go away when debugging is "
"turned on."
msgstr ""
"Функция B<assert>() реализована в виде макроса. Если проверка выражения "
"приводит к побочным изменениям, то поведение программы будет различным в "
"зависимости от наличия B<NDEBUG>. Это может создавать гейзенбаг, который "
"исчезает при включении отладки."

#. type: Plain text
#: man-pages/man3/assert.3:79
msgid "B<abort>(3), B<assert_perror>(3), B<exit>(3)"
msgstr "B<abort>(3), B<assert_perror>(3), B<exit>(3)"

#. type: TH
#: man-pages/man3/asinh.3:35
#, no-wrap
msgid "ASINH"
msgstr "ASINH"

#. type: TH
#: man-pages/man3/asinh.3:35
#, no-wrap
msgid "2013-10-14"
msgstr "2013-10-14"

#. type: Plain text
#: man-pages/man3/asinh.3:38
msgid "asinh, asinhf, asinhl - inverse hyperbolic sine function"
msgstr "asinh, asinhf, asinhl - функция вычисления гиперболического арксинуса"

#. type: Plain text
#: man-pages/man3/asinh.3:43
#, no-wrap
msgid "B<double asinh(double >I<x>B<);>\n"
msgstr "B<double asinh(double >I<x>B<);>\n"

#. type: Plain text
#: man-pages/man3/asinh.3:45
#, no-wrap
msgid "B<float asinhf(float >I<x>B<);>\n"
msgstr "B<float asinhf(float >I<x>B<);>\n"

#. type: Plain text
#: man-pages/man3/asinh.3:47
#, no-wrap
msgid "B<long double asinhl(long double >I<x>B<);>\n"
msgstr "B<long double asinhl(long double >I<x>B<);>\n"

#. type: Plain text
#: man-pages/man3/asinh.3:58
msgid "B<asinh>():"
msgstr "B<asinh>():"

#. type: Plain text
#: man-pages/man3/asinh.3:69
msgid "B<asinhf>(), B<asinhl>():"
msgstr "B<asinhf>(), B<asinhl>():"

#. type: Plain text
#: man-pages/man3/asinh.3:84
msgid ""
"The B<asinh>()  function calculates the inverse hyperbolic sine of I<x>; "
"that is the value whose hyperbolic sine is I<x>."
msgstr ""
"Функция B<asinh>() вычисляет гиперболический арксинус значения I<x>; "
"гиперболический синус результата будет равен I<x>."

#. type: Plain text
#: man-pages/man3/asinh.3:87
msgid "On success, these functions return the inverse hyperbolic sine of I<x>."
msgstr ""
"В случае успеха данные функции возвращают гиперболический арксинус значения "
"I<x>."

#.  POSIX.1-2001 documents an optional range error for subnormal x;
#.  glibc 2.8 does not do this.
#. type: Plain text
#: man-pages/man3/asinh.3:103
msgid ""
"If I<x> is positive infinity (negative infinity), positive infinity "
"(negative infinity) is returned."
msgstr ""
"Если I<x>  стремится к плюс или минус бесконечности, будет возвращена плюс "
"или минус бесконечность."

#. type: Plain text
#: man-pages/man3/asinh.3:113
msgid ""
"The B<asinh>(), B<asinhf>(), and B<asinhl>()  functions are thread-safe."
msgstr ""
"Функции B<asinh>(), B<asinhf>() и B<asinhl>() можно использовать в нескольких "
"нитях одновременно."

#. type: Plain text
#: man-pages/man3/asinh.3:125
msgid ""
"B<acosh>(3), B<atanh>(3), B<casinh>(3), B<cosh>(3), B<sinh>(3), B<tanh>(3)"
msgstr ""
"B<acosh>(3), B<atanh>(3), B<casinh>(3), B<cosh>(3), B<sinh>(3), B<tanh>(3)"

#. type: TH
#: man-pages/man3/atanh.3:35
#, no-wrap
msgid "ATANH"
msgstr "ATANH"

#. type: TH
#: man-pages/man3/atanh.3:35
#, no-wrap
msgid "2010-09-11"
msgstr "2010-09-11"

#. type: Plain text
#: man-pages/man3/atanh.3:38
msgid "atanh, atanhf, atanhl - inverse hyperbolic tangent function"
msgstr ""
"atanh, atanhf, atanhl - вычисление функции обратного гиперболического тангенса"

#. type: Plain text
#: man-pages/man3/atanh.3:43
#, no-wrap
msgid "B<double atanh(double >I<x>B<);>\n"
msgstr "B<double atanh(double >I<x>B<);>\n"

#. type: Plain text
#: man-pages/man3/atanh.3:45
#, no-wrap
msgid "B<float atanhf(float >I<x>B<);>\n"
msgstr "B<float atanhf(float >I<x>B<);>\n"

#. type: Plain text
#: man-pages/man3/atanh.3:47
#, no-wrap
msgid "B<long double atanhl(long double >I<x>B<);>\n"
msgstr "B<long double atanhl(long double >I<x>B<);>\n"

#. type: Plain text
#: man-pages/man3/atanh.3:58
msgid "B<atanh>():"
msgstr "B<atanh>():"

#. type: Plain text
#: man-pages/man3/atanh.3:69
msgid "B<atanhf>(), B<atanhl>():"
msgstr "B<atanhf>(), B<atanhl>():"

#. type: Plain text
#: man-pages/man3/atanh.3:84
msgid ""
"The B<atanh>()  function calculates the inverse hyperbolic tangent of I<x>; "
"that is the value whose hyperbolic tangent is I<x>."
msgstr ""
"Функция B<atanh>() вычисляет обратный гиперболический тангенс значения I<x>; "
"гиперболический тангенс результата будет равен I<x>."

#. type: Plain text
#: man-pages/man3/atanh.3:87
msgid ""
"On success, these functions return the inverse hyperbolic tangent of I<x>."
msgstr ""
"При успешном выполнении данные функции возвращают обратный гиперболический "
"тангенс от I<x>."

#. type: Plain text
#: man-pages/man3/atanh.3:106
msgid ""
"If I<x> is +1 or -1, a pole error occurs, and the functions return "
"B<HUGE_VAL>, B<HUGE_VALF>, or B<HUGE_VALL>, respectively, with the "
"mathematically correct sign."
msgstr ""
"Если I<x> равно +1 или -1, то возникает ошибка особой точки, а функции "
"возвращают B<HUGE_VAL>, B<HUGE_VALF> или B<HUGE_VALL>, соответственно, с "
"математически правильным знаком."

#.  POSIX.1-2001 documents an optional range error for subnormal x;
#.  glibc 2.8 does not do this.
#. type: Plain text
#: man-pages/man3/atanh.3:115
msgid ""
"If the absolute value of I<x> is greater than 1, a domain error occurs, and "
"a NaN is returned."
msgstr ""
"Если абсолютное значение I<x> больше 1, то будет сгенерирована ошибка выхода "
"за пределы области, а в качестве результата будет возвращено NaN."

#. type: TP
#: man-pages/man3/atanh.3:122
#, no-wrap
msgid "Domain error: I<x> less than -1 or greater than +1"
msgstr "Ошибка области: I<x> меньше -1 или больше +1"

#. type: TP
#: man-pages/man3/atanh.3:130
#, no-wrap
msgid "Pole error: I<x> is +1 or -1"
msgstr "Ошибка особой точки: I<x> равно +1 или -1"

#. type: Plain text
#: man-pages/man3/atanh.3:139
msgid ""
"I<errno> is set to B<ERANGE> (but see BUGS).  A divide-by-zero floating-"
"point exception (B<FE_DIVBYZERO>)  is raised."
msgstr ""
"Значение I<errno> устанавливается в B<ERANGE> (но смотрите ДЕФЕКТЫ). "
"Возникает исключение деления плавающей запятой на ноль (B<FE_DIVBYZERO>)."

#.  Bug: http://sources.redhat.com/bugzilla/show_bug.cgi?id=6759
#.  This can be seen in sysdeps/ieee754/k_standard.c
#. type: Plain text
#: man-pages/man3/atanh.3:156
msgid ""
"In glibc 2.9 and earlier, when a pole error occurs, I<errno> as set to "
"B<EDOM> instead of the POSIX-mandated B<ERANGE>.  Since version 2.10, glibc "
"does the right thing."
msgstr ""
"В glibc 2.9 и ранее при возникновении ошибки особой точки, значению I<errno> "
"присваивается B<EDOM> вместо B<ERANGE> согласно POSIX. Начиная с версии 2.10, "
"в glibc это исправлено."

#. type: Plain text
#: man-pages/man3/atanh.3:162
msgid ""
"B<acosh>(3), B<asinh>(3), B<catanh>(3), B<cosh>(3), B<sinh>(3), B<tanh>(3)"
msgstr ""
"B<acosh>(3), B<asinh>(3), B<catanh>(3), B<cosh>(3), B<sinh>(3), B<tanh>(3)"

#. type: TH
#: man-pages/man3/argz_add.3:10
#, no-wrap
msgid "ARGZ_ADD"
msgstr "ARGZ_ADD"

#. type: Plain text
#: man-pages/man3/argz_add.3:15
msgid ""
"argz_add, argz_add_sep, argz_append, argz_count, argz_create, "
"argz_create_sep, argz_delete, argz_extract, argz_insert, argz_next, "
"argz_replace, argz_stringify - functions to handle an argz list"
msgstr ""
"argz_add, argz_add_sep, argz_append, argz_count, argz_create, "
"argz_create_sep, argz_delete, argz_extract, argz_insert, argz_next, "
"argz_replace, argz_stringify - функции для обработки списка argz"

#. type: Plain text
#: man-pages/man3/argz_add.3:18
#, no-wrap
msgid "B<#include E<lt>argz.hE<gt>>\n"
msgstr "B<#include E<lt>argz.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/argz_add.3:21
#, no-wrap
msgid ""
"B<error_t argz_add(char **>I<argz>B<, size_t *>I<argz_len>B<, const char "
"*>I<str>B<);>\n"
msgstr ""
"B<error_t argz_add(char **>I<argz>B<, size_t *>I<argz_len>B<, const char *>I<"
"str>B<);>\n"

#. type: Plain text
#: man-pages/man3/argz_add.3:24
#, no-wrap
msgid ""
"B<error_t argz_add_sep(char **>I<argz>B<, size_t *>I<argz_len>B<,>\n"
"B<                     const char *>I<str>B<, int >I<delim>B<);>\n"
msgstr ""
"B<error_t argz_add_sep(char **>I<argz>B<, size_t *>I<argz_len>B<,>\nB<        "
"             const char *>I<str>B<, int >I<delim>B<);>\n"

#. type: Plain text
#: man-pages/man3/argz_add.3:27
#, no-wrap
msgid ""
"B<error_t argz_append(char **>I<argz>B<, size_t *>I<argz_len>B<,>\n"
"B<                     const char *>I<buf>B<, size_t >I<buf_len>B<);>\n"
msgstr ""
"B<error_t argz_append(char **>I<argz>B<, size_t *>I<argz_len>B<,>\nB<         "
"            const char *>I<buf>B<, size_t >I<buf_len>B<);>\n"

#. type: Plain text
#: man-pages/man3/argz_add.3:29
#, no-wrap
msgid "B<size_t argz_count(const char *>I<argz>B<, size_t >I<argz_len>B<);>\n"
msgstr "B<size_t argz_count(const char *>I<argz>B<, size_t >I<argz_len>B<);>\n"

#. type: Plain text
#: man-pages/man3/argz_add.3:32
#, no-wrap
msgid ""
"B<error_t argz_create(char * const >I<argv>B<[], char **>I<argz>B<,>\n"
"B<                     size_t *>I<argz_len>B<);>\n"
msgstr ""
"B<error_t argz_create(char * const >I<argv>B<[], char **>I<argz>B<,>\nB<      "
"               size_t *>I<argz_len>B<);>\n"

#. type: Plain text
#: man-pages/man3/argz_add.3:35
#, no-wrap
msgid ""
"B<error_t argz_create_sep(const char *>I<str>B<, int >I<sep>B<, char **>I<"
"argz>B<,>\n"
"B<                     size_t *>I<argz_len>B<);>\n"
msgstr ""
"B<error_t argz_create_sep(const char *>I<str>B<, int >I<sep>B<, char **>I<"
"argz>B<,>\nB<                     size_t *>I<argz_len>B<);>\n"

#. type: Plain text
#: man-pages/man3/argz_add.3:37
#, no-wrap
msgid ""
"B<void argz_delete(char **>I<argz>B<, size_t *>I<argz_len>B<, char "
"*>I<entry>B<);>\n"
msgstr ""
"B<void argz_delete(char **>I<argz>B<, size_t *>I<argz_len>B<, char *>I<entry>"
"B<);>\n"

#. type: Plain text
#: man-pages/man3/argz_add.3:39
#, no-wrap
msgid ""
"B<void argz_extract(const char *>I<argz>B<, size_t >I<argz_len>B<, char  "
"**>I<argv>B<);>\n"
msgstr ""
"B<void argz_extract(const char *>I<argz>B<, size_t >I<argz_len>B<, char  **>"
"I<argv>B<);>\n"

#. type: Plain text
#: man-pages/man3/argz_add.3:42
#, no-wrap
msgid ""
"B<error_t argz_insert(char **>I<argz>B<, size_t *>I<argz_len>B<, char *>I<"
"before>B<,>\n"
"B<                     const char *>I<entry>B<);>\n"
msgstr ""
"B<error_t argz_insert(char **>I<argz>B<, size_t *>I<argz_len>B<, char *>I<"
"before>B<,>\nB<                     const char *>I<entry>B<);>\n"

#. type: Plain text
#: man-pages/man3/argz_add.3:44
#, no-wrap
msgid ""
"B<char *argz_next(const char *>I<argz>B<, size_t >I<argz_len>B<, const char "
"*>I<entry>B<);>\n"
msgstr ""
"B<char *argz_next(const char *>I<argz>B<, size_t >I<argz_len>B<, const char *>"
"I<entry>B<);>\n"

#. type: Plain text
#: man-pages/man3/argz_add.3:48
#, no-wrap
msgid ""
"B<error_t argz_replace(char **>I<argz>B<, size_t *>I<argz_len>B<, const char "
"*>I<str>B<,>\n"
"B<                     const char *>I<with>B<, unsigned int *>I<replace_count>"
"B<);>\n"
msgstr ""
"B<error_t argz_replace(char **>I<argz>B<, size_t *>I<argz_len>B<, const char "
"*>I<str>B<,>\nB<                     const char *>I<with>B<, unsigned int *>"
"I<replace_count>B<);>\n"

#. type: Plain text
#: man-pages/man3/argz_add.3:50
#, no-wrap
msgid ""
"B<void argz_stringify(char *>I<argz>B<, size_t >I<len>B<, int >I<sep>B<);>\n"
msgstr ""
"B<void argz_stringify(char *>I<argz>B<, size_t >I<len>B<, int >I<sep>B<);>\n"

#. type: Plain text
#: man-pages/man3/argz_add.3:53
msgid "These functions are glibc-specific."
msgstr "Эти функции есть только в glibc."

#. type: Plain text
#: man-pages/man3/argz_add.3:58
msgid ""
"An argz vector is a pointer to a character buffer together with a length.  "
"The intended interpretation of the character buffer is an array of strings, "
"where the strings are separated by null bytes (\\(aq\\e0\\(aq).  If the "
"length is nonzero, the last byte of the buffer must be a null byte."
msgstr ""
"Вектор argz представляет собой указатель на символьный буфер и его длину. "
"Данный символьный буфер следует считать массивом строк, разделённых байтами "
"null (\\(aq\\e0\\(aq). Если длина ненулевая, то последний байт в буфере "
"должен быть null."

#. type: Plain text
#: man-pages/man3/argz_add.3:67
msgid ""
"These functions are for handling argz vectors.  The pair (NULL,0) is an argz"
" vector, and, conversely, argz vectors of length 0 must have null pointer.  "
"Allocation of nonempty argz vectors is done using B<malloc>(3), so that "
"B<free>(3)  can be used to dispose of them again."
msgstr ""
"Эти функции предназначены для обработки векторов argz. Пара (null,0) "
"представляет вектор argz и наоборот, векторы argz длиной 0 должны иметь "
"указатель null. Размещение непустых векторов argz осуществляется функцией B<"
"malloc>(3), а для высвобождения пространства можно использовать B<free>(3)."

#. type: Plain text
#: man-pages/man3/argz_add.3:77
msgid ""
"B<argz_add>()  adds the string I<str> at the end of the array I<*argz>, and "
"updates I<*argz> and I<*argz_len>."
msgstr ""
"Функция B<argz_add>() добавляет строку I<st>r в конец массива I<*argz>, и "
"обновляет I<*argz> и I<*argz_len>."

#. type: Plain text
#: man-pages/man3/argz_add.3:85
msgid ""
"B<argz_add_sep>()  is similar, but splits the string I<str> into substrings "
"separated by the delimiter I<delim>.  For example, one might use this on a "
"UNIX search path with delimiter \\(aq:\\(aq."
msgstr ""
"Функция B<argz_add_sep>() делает тоже самое, но разделяет строку I<str> на "
"подстроки, разделяя их символом I<delim>. Например, это можно использовать "
"при работе с путями поиска UNIX, где разделителем является \\(aq:\\(aq."

#. type: Plain text
#: man-pages/man3/argz_add.3:99
msgid ""
"B<argz_append>()  appends the argz vector (I<buf>,\\ I<buf_len>)  after "
"(I<*argz>,\\ I<*argz_len>)  and updates I<*argz> and I<*argz_len>.  (Thus, "
"I<*argz_len> will be increased by I<buf_len>.)"
msgstr ""
"Функция B<argz_append>() добавляет вектор argz (I<buf>,\\ I<buf_len>) после "
"(I<*argz>,\\ I<*argz_len>) и обновляет I<*argz> и I<*argz_len> (таким "
"образом, I<*argz_len> будет увеличено на I<buf_len>)."

#. type: Plain text
#: man-pages/man3/argz_add.3:104
msgid ""
"B<argz_count>()  counts the number of strings, that is, the number of null "
"bytes (\\(aq\\e0\\(aq), in (I<argz>,\\ I<argz_len>)."
msgstr ""
"Функция B<argz_count>() подсчитывает количество строк, то есть количество "
"байтов null в (\\(aq\\e0\\(aq), в (I<argz>,\\ I<argz_len>)."

#. type: Plain text
#: man-pages/man3/argz_add.3:112
msgid ""
"B<argz_create>()  converts a UNIX-style argument vector I<argv>, terminated "
"by I<(char\\ *)\\ 0>, into an argz vector (I<*argz>,\\ I<*argz_len>)."
msgstr ""
"Функция B<argz_create>() преобразует аргумент вектора I<argv> в стиле UNIX, "
"заканчивающийся I<(char\\ *)\\ 0>, в вектор argz (I<*argz>,\\ I<*argz_len>)."

#. type: Plain text
#: man-pages/man3/argz_add.3:120
msgid ""
"B<argz_create_sep>()  converts the null-terminated string I<str> into an "
"argz vector (I<*argz>,\\ I<*argz_len>)  by breaking it up at every "
"occurrence of the separator I<sep>."
msgstr ""
"Функция B<argz_create_sep>() преобразует строку I<str>, заканчивающуюся null, "
"в вектор argz (I<*argz>,\\ I<*argz_len>), разделяя её при каждом нахождении "
"разделителя I<sep>."

#. type: Plain text
#: man-pages/man3/argz_add.3:130
msgid ""
"B<argz_delete>()  removes the substring pointed to by I<entry> from the argz"
" vector (I<*argz>,\\ I<*argz_len>)  and updates I<*argz> and I<*argz_len>."
msgstr ""
"Функция B<argz_delete>() удаляет подстроку, на которую указывает I<entry>, из "
"вектора argz (I<*argz>,\\ I<*argz_len>) и обновляет I<*argz> и I<*argz_len>."

#. type: Plain text
#: man-pages/man3/argz_add.3:145
msgid ""
"B<argz_extract>()  is the opposite of B<argz_create>().  It takes the argz "
"vector (I<argz>,\\ I<argz_len>)  and fills the array starting at I<argv> "
"with pointers to the substrings, and a final NULL, making a UNIX-style argv "
"vector.  The array I<argv> must have room for I<argz_count>(I<argz>, "
"I<argz_len>) + 1 pointers."
msgstr ""
"Функция B<argz_extract>() является противоположностью B<argz_create>(). Она "
"берёт вектор argz (I<argz>,\\ I<argz_len>) и заполняет массив, начиная с I<"
"argv>, указателями на подстроки и завершая его NULL, тем самым создавая "
"вектор argv в стиле UNIX. Массив I<argv> должен иметь пространство для I<"
"argz_count>(I<argz>, I<argz_len>) + 1 указателей."

#. type: Plain text
#: man-pages/man3/argz_add.3:164
msgid ""
"B<argz_insert>()  is the opposite of B<argz_delete>().  It inserts the "
"argument I<entry> at position I<before> into the argz vector (I<*argz>,\\ "
"I<*argz_len>)  and updates I<*argz> and I<*argz_len>.  If I<before> is NULL,"
" then I<entry> will inserted at the end."
msgstr ""
"Функция B<argz_insert>() является противоположностью B<argz_delete>(). Она "
"вставляет аргумент I<entry> с позиции I<before> в вектор (I<*argz>,\\ I<"
"*argz_len>) и обновляет I<*argz> и I<*argz_len>. Если значение I<before> "
"равно NULL, то значение I<entry> будет вставлено в конец."

#. type: Plain text
#: man-pages/man3/argz_add.3:173
msgid ""
"B<argz_next>()  is a function to step trough the argz vector.  If I<entry> "
"is NULL, the first entry is returned.  Otherwise, the entry following is "
"returned.  It returns NULL if there is no following entry."
msgstr ""
"Функция B<argz_next>() предназначена для последовательного обхода вектора "
"argz. Если значение I<entry> равно NULL, то возвращается первый элемент. "
"Иначе возвращается следующий элемент. Если следующего элемента нет, то "
"возвращается NULL."

#. type: Plain text
#: man-pages/man3/argz_add.3:185
msgid ""
"B<argz_replace>()  replaces each occurrence of I<str> with I<with>, "
"reallocating argz as necessary.  If I<replace_count> is non-NULL, "
"I<*replace_count> will be incremented by the number of replacements."
msgstr ""
"Функция B<argz_replace>() заменяет каждую найденную строку I<str> на I<with>, "
"изменяя размер argz при необходимости. Если значение I<replace_count> не "
"равно NULL, то значение I<*replace_count> будет увеличено на число замен."

#. type: Plain text
#: man-pages/man3/argz_add.3:192
msgid ""
"B<argz_stringify>()  is the opposite of B<argz_create_sep>().  It transforms"
" the argz vector into a normal string by replacing all null bytes "
"(\\(aq\\e0\\(aq) except the last by I<sep>."
msgstr ""
"Функция B<argz_stringify>() является противоположностью B<argz_create_sep>(). "
"Она преобразует вектор argz в обычную строку, заменяя все байты null "
"(\\(aq\\e0\\(aq), за исключением последнего, значением I<sep>."

#. type: Plain text
#: man-pages/man3/argz_add.3:198
msgid ""
"All argz functions that do memory allocation have a return type of "
"I<error_t>, and return 0 for success, and B<ENOMEM> if an allocation error "
"occurs."
msgstr ""
"Все функции argz, в которых происходит выделение памяти, возвращают "
"результат, имеющий тип I<error_t>: 0 — при успешном выполнении и B<ENOMEM> — "
"при ошибке выделения памяти."

#. type: Plain text
#: man-pages/man3/argz_add.3:201
msgid "These functions are a GNU extension.  Handle with care."
msgstr "Данные функции являются расширениями GNU. Используйте с осторожностью."

#. type: Plain text
#: man-pages/man3/argz_add.3:204
msgid ""
"Argz vectors without a terminating null byte may lead to Segmentation "
"Faults."
msgstr ""
"Векторы argz без завершающего байта null могут привести к ошибкам "
"сегментирования."

#. type: Plain text
#: man-pages/man3/argz_add.3:205
msgid "B<envz_add>(3)"
msgstr "B<envz_add>(3)"

#. type: TH
#: man-pages/man3/assert_perror.3:28
#, no-wrap
msgid "ASSERT_PERROR"
msgstr "ASSERT_PERROR"

#. type: Plain text
#: man-pages/man3/assert_perror.3:31
msgid "assert_perror - test errnum and abort"
msgstr "assert_perror - проверяет errnum и прекращает выполнение программы"

#. type: Plain text
#: man-pages/man3/assert_perror.3:35
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>         /* See feature_test_macros(7) */\n"
"B<#include E<lt>assert.hE<gt>>\n"
msgstr ""
"B<#define _GNU_SOURCE>         /* Смотрите feature_test_macros(7) */\nB<"
"#include E<lt>assert.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/assert_perror.3:37
#, no-wrap
msgid "B<void assert_perror(int >I<errnum>B<);>\n"
msgstr "B<void assert_perror(int >I<errnum>B<);>\n"

#. type: Plain text
#: man-pages/man3/assert_perror.3:57
msgid ""
"If the macro B<NDEBUG> was defined at the moment I<E<lt>assert.hE<gt>> was "
"last included, the macro B<assert_perror>()  generates no code, and hence "
"does nothing at all.  Otherwise, the macro B<assert_perror>()  prints an "
"error message to standard error and terminates the program by calling "
"B<abort>(3)  if I<errnum> is nonzero.  The message contains the filename, "
"function name and line number of the macro call, and the output of "
"I<strerror(errnum)>."
msgstr ""
"Если на момент последнего включения I<E<lt>assert.hE<gt>> был определён "
"макрос B<NDEBUG>, то для макроса B<assert_perror>() не создаётся никакого "
"кода и, соответственно, он вообще ничего не делает. В противном случае, "
"макрос B<assert_perror>() выводит в стандартный поток ошибок сообщение об "
"ошибке и прекращает работу программы вызовом B<abort>(3), если значение I<"
"errnum> не равно нулю. В сообщении содержится имя файла, имя функции и номер "
"строки вызова макроса, а также результат вызова I<strerror(errnum)>."

#. type: Plain text
#: man-pages/man3/assert_perror.3:61
msgid "This is a GNU extension."
msgstr "Это расширение GNU."

#. type: Plain text
#: man-pages/man3/assert_perror.3:71
msgid ""
"The purpose of the assert macros is to help programmers find bugs in their "
"programs, things that cannot happen unless there was a coding mistake.  "
"However, with system or library calls the situation is rather different, and"
" error returns can happen, and will happen, and should be tested for.  Not "
"by an assert, where the test goes away when B<NDEBUG> is defined, but by "
"proper error handling code.  Never use this macro."
msgstr ""
"Целью макроса assert является оказание помощи программистам в поиске ошибок в "
"программах — таких сбоев, которые не могут случиться, если только не была "
"допущена ошибка в коде программы. Однако, с системными или библиотечными "
"вызовами ситуация немного отличается, и возврат ошибки может произойти и, "
"собственно, произойдёт и должен может быть проверен, но не через assert, где "
"проверка не получится, если определено B<NDEBUG>, а правильным кодом "
"обработки ошибок. Никогда не используйте этот макрос."

#. type: Plain text
#: man-pages/man3/assert_perror.3:75
msgid "B<abort>(3), B<assert>(3), B<exit>(3), B<strerror>(3)"
msgstr "B<abort>(3), B<assert>(3), B<exit>(3), B<strerror>(3)"

#. type: TH
#: man-pages/man3/acos.3:35
#, no-wrap
msgid "ACOS"
msgstr "ACOS"

#. type: Plain text
#: man-pages/man3/acos.3:38
msgid "acos, acosf, acosl - arc cosine function"
msgstr "cos, cosf, cosl - функция вычисления арккосинуса"

#. type: Plain text
#: man-pages/man3/acos.3:45
#, no-wrap
msgid ""
"B<double acos(double >I<x>B<);>\n"
"B<float acosf(float >I<x>B<);>\n"
"B<long double acosl(long double >I<x>B<);>\n"
msgstr ""
"B<double acos(double >I<x>B<);>\nB<float acosf(float >I<x>B<);>\nB<long "
"double acosl(long double >I<x>B<);>\n"

#. type: Plain text
#: man-pages/man3/acos.3:57
msgid "B<acosf>(), B<acosl>():"
msgstr "B<acosf>(), B<acosl>():"

#. type: Plain text
#: man-pages/man3/acos.3:73
msgid ""
"The B<acos>()  function calculates the arc cosine of I<x>; that is the value"
" whose cosine is I<x>."
msgstr ""
"Функция B<acos>() вычисляет арккосинус от I<x>; это значение, косинус "
"которого равен I<x>."

#. type: Plain text
#: man-pages/man3/acos.3:77
msgid ""
"On success, these functions return the arc cosine of I<x> in radians; the "
"return value is in the range [0,\\ pi]."
msgstr ""
"В случае успеха эти функции возвращают арккосинус от I<x> в радианах; "
"результат находится в диапазоне значений [0,\\ pi]."

#. type: Plain text
#: man-pages/man3/acos.3:92
msgid ""
"If I<x> is positive infinity or negative infinity, a domain error occurs, "
"and a NaN is returned."
msgstr ""
"Если I<x> стремится к плюс бесконечности или минус бесконечности, то будет "
"сгенерирована ошибка выхода за пределы области, а в качестве результата будет "
"возвращено NaN."

#. type: Plain text
#: man-pages/man3/acos.3:126
msgid ""
"B<asin>(3), B<atan>(3), B<atan2>(3), B<cacos>(3), B<cos>(3), B<sin>(3), "
"B<tan>(3)"
msgstr ""
"B<asin>(3), B<atan>(3), B<atan2>(3), B<cacos>(3), B<cos>(3), B<sin>(3), B<tan>"
"(3)"

