# Copyright (C) 2019 Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
#
# Translators:
# Azamat Hackimov <azamat.hackimov@gmail.com>, 2012.
# Yuri Kozlov <yuray@komyakino.ru>, 2011-2018.
# Yuri Kozlov <yuray@komyakino.ru>, 2014, 2019.
# Иван Павлов <pavia00@gmail.com>, 2017.
msgid ""
msgstr ""
"Project-Id-Version: translation of man-pages\n"
"POT-Creation-Date: 2019-08-26 09:25+0300\n"
"PO-Revision-Date: 2019-08-29 10:25+0300\n"
"Last-Translator: Yuri Kozlov <yuray@komyakino.ru>\n"
"Language-Team: Russian <man-pages-ru-talks@lists.sourceforge.net>\n"
"Language: ru\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=4; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n"
"%10<=4 && (n%100<12 || n%100>14) ? 1 : n%10==0 || (n%10>=5 && n%10<=9) || (n"
"%100>=11 && n%100<=14)? 2 : 3);\n"
"X-Generator: Lokalize 2.0\n"

#. type: TH
#: man-pages/man7/environ.7:34
#, no-wrap
msgid "ENVIRON"
msgstr "ENVIRON"

#. type: TH
#: man-pages/man7/environ.7:34
#, no-wrap
msgid "2017-09-15"
msgstr "2017-09-15"

#. type: TH
#: man-pages/man7/environ.7:34
#, no-wrap
msgid "Linux"
msgstr "Linux"

#. type: TH
#: man-pages/man7/environ.7:34
#, no-wrap
msgid "Linux Programmer's Manual"
msgstr "Руководство программиста Linux"

#. type: SH
#: man-pages/man7/environ.7:35
#, no-wrap
msgid "NAME"
msgstr "ИМЯ"

#. type: Plain text
#: man-pages/man7/environ.7:37
msgid "environ - user environment"
msgstr "environ - пользовательское окружение"

#. type: SH
#: man-pages/man7/environ.7:37
#, no-wrap
msgid "SYNOPSIS"
msgstr "ОБЗОР"

#. type: Plain text
#: man-pages/man7/environ.7:40
#, no-wrap
msgid "B<extern char **>I<environ>B<;>\n"
msgstr "B<extern char **>I<environ>B<;>\n"

#. type: SH
#: man-pages/man7/environ.7:41
#, no-wrap
msgid "DESCRIPTION"
msgstr "ОПИСАНИЕ"

#. type: Plain text
#: man-pages/man7/environ.7:60
msgid ""
"The variable I<environ> points to an array of pointers to strings called the "
"\"environment\".  The last pointer in this array has the value NULL.  (This "
"variable must be declared in the user program, but is declared in the header "
"file I<E<lt>unistd.hE<gt>> if the B<_GNU_SOURCE> feature test macro is "
"defined.)  This array of strings is made available to the process by the "
"B<exec>(3)  call that started the process.  When a child process is created "
"via B<fork>(2), it inherits a I<copy> of its parent's environment."
msgstr ""
"Переменная I<environ> указывает на массив указателей на строки, который "
"называют «окружением» (environment). Последний указатель в этом массиве "
"имеет значение NULL (данная переменная должна быть объявлена в программе "
"пользователя, а кроме того она объявлена в заголовочном файле I<E<lt>unistd."
"hE<gt>>, если определён макрос тестирования свойств B<_GNU_SOURCE>). "
"Указанный массив строк, становится доступным процессу после вызова "
"B<exec>(3), которая запускает процесс. Если дочерний процесс создаётся с "
"помощью B<fork>(2), то он наследует I<копию> окружения своего родителя."

#. type: Plain text
#: man-pages/man7/environ.7:65
msgid ""
"By convention the strings in I<environ> have the form \"I<name>B<=>I<value>"
"\".  Common examples are:"
msgstr ""
"По договорённости, строки в I<environ> имеют вид «I<имя>B<=>I<значение>». "
"Вот некоторые примеры:"

#. type: TP
#: man-pages/man7/environ.7:65
#, no-wrap
msgid "B<USER>"
msgstr "B<USER>"

#. type: Plain text
#: man-pages/man7/environ.7:68
msgid "The name of the logged-in user (used by some BSD-derived programs)."
msgstr ""
"Имя пользователя, зарегистрированного в системе (используется некоторыми "
"программами, написанными для BSD)."

#. type: TP
#: man-pages/man7/environ.7:68
#, no-wrap
msgid "B<LOGNAME>"
msgstr "B<LOGNAME>"

#. type: Plain text
#: man-pages/man7/environ.7:71
msgid ""
"The name of the logged-in user (used by some System-V derived programs)."
msgstr ""
"Имя пользователя, зарегистрированного в системе (используется некоторыми "
"программами, написанными для System-V)."

#. type: TP
#: man-pages/man7/environ.7:71
#, no-wrap
msgid "B<HOME>"
msgstr "B<HOME>"

#. type: Plain text
#: man-pages/man7/environ.7:77
msgid ""
"A user's login directory, set by B<login>(1)  from the password file "
"B<passwd>(5)."
msgstr ""
"Домашний каталог пользователя, устанавливается программой B<login>(1) "
"согласно значению из файла паролей B<passwd>(5)."

#. type: TP
#: man-pages/man7/environ.7:77
#, no-wrap
msgid "B<LANG>"
msgstr "B<LANG>"

#. type: Plain text
#: man-pages/man7/environ.7:95
msgid ""
"The name of a locale to use for locale categories when not overridden by "
"B<LC_ALL> or more specific environment variables such as B<LC_COLLATE>, "
"B<LC_CTYPE>, B<LC_MESSAGES>, B<LC_MONETARY>, B<LC_NUMERIC>, and B<LC_TIME> "
"(see B<locale>(7)  for further details of the B<LC_*> environment variables)."
msgstr ""
"Имя локали используется для категорий локали, если не заменено значением "
"B<LC_ALL> или более специфичными переменными окружения, такими как "
"B<LC_COLLATE>, B<LC_CTYPE>, B<LC_MESSAGES>, B<LC_MONETARY>, B<LC_NUMERIC> и "
"B<LC_TIME> (подробней смотрите описание переменных окружения B<LC_*> в "
"B<locale>(7))."

#. type: TP
#: man-pages/man7/environ.7:95
#, no-wrap
msgid "B<PATH>"
msgstr "B<PATH>"

#. type: Plain text
#: man-pages/man7/environ.7:110
msgid ""
"The sequence of directory prefixes that B<sh>(1)  and many other programs "
"apply in searching for a file known by an incomplete pathname.  The prefixes "
"are separated by \\(aqB<:>\\(aq.  (Similarly one has B<CDPATH> used by some "
"shells to find the target of a change directory command, B<MANPATH> used by "
"B<man>(1)  to find manual pages, and so on)"
msgstr ""
"Последовательность каталогов, которые B<sh>(1) и многие другие программы "
"будут применять в качестве префикса при поиске файла, если он задан неполным "
"именем Каталоги разделяются «B<:>» (похожим образом переменная B<CDPATH> "
"используется некоторыми командными оболочками для поиска каталога, в который "
"нужно перейти, B<MANPATH> используется командой B<man>(1) для поиска "
"справочных страниц и т. д.)."

#. type: TP
#: man-pages/man7/environ.7:110
#, no-wrap
msgid "B<PWD>"
msgstr "B<PWD>"

#. type: Plain text
#: man-pages/man7/environ.7:114
msgid "The current working directory.  Set by some shells."
msgstr ""
"Текущий рабочий каталог. Устанавливается некоторыми командными оболочками."

#. type: TP
#: man-pages/man7/environ.7:114
#, no-wrap
msgid "B<SHELL>"
msgstr "B<SHELL>"

#. type: Plain text
#: man-pages/man7/environ.7:117
msgid "The pathname of the user's login shell."
msgstr "Имя регистрационной командной оболочки пользователя."

#. type: TP
#: man-pages/man7/environ.7:117
#, no-wrap
msgid "B<TERM>"
msgstr "B<TERM>"

#. type: Plain text
#: man-pages/man7/environ.7:120
msgid "The terminal type for which output is to be prepared."
msgstr "Тип терминала, для которого будет подготавливаться вывод."

#. type: TP
#: man-pages/man7/environ.7:120
#, no-wrap
msgid "B<PAGER>"
msgstr "B<PAGER>"

#. type: Plain text
#: man-pages/man7/environ.7:123
msgid "The user's preferred utility to display text files."
msgstr "Предпочитаемая пользователем утилита просмотра текстовых файлов."

#. type: TP
#: man-pages/man7/environ.7:123
#, no-wrap
msgid "B<EDITOR>/B<VISUAL>"
msgstr "B<EDITOR>/B<VISUAL>"

#.  .TP
#.  .B BROWSER
#.  The user's preferred utility to browse URLs. Sequence of colon-separated
#.  browser commands. See http://www.catb.org/~esr/BROWSER/ .
#. type: Plain text
#: man-pages/man7/environ.7:130
msgid "The user's preferred utility to edit text files."
msgstr "Предпочитаемая пользователем утилита редактирования текстовых файлов."

#. type: Plain text
#: man-pages/man7/environ.7:139
msgid ""
"Names may be placed in the shell's environment by the I<export> command in "
"B<sh>(1), or by the I<setenv> command if you use B<csh>(1)."
msgstr ""
"Имена можно помещать в окружение оболочки с помощью команды I<export> в "
"B<sh>(1) или командой I<setenv>, если используется B<csh>(1)."

#. type: Plain text
#: man-pages/man7/environ.7:152
msgid ""
"The initial environment of the shell is populated in various ways, such as "
"definitions from I</etc/environment> that are processed by B<pam_env>(8)  "
"for all users at login time (on systems that employ B<pam>(8)).  In "
"addition, various shell initialization scripts, such as the system-wide I</"
"etc/profile> script and per-user initializations script may include commands "
"that add variables to the shell's environment; see the manual page of your "
"preferred shell for details."
msgstr ""
"Начальное окружение оболочки создаётся различными путями, например из файла "
"I</etc/environment>, который обрабатывается B<pam_env>(8) при входе любого "
"пользователя (в системах с B<pam>(8)). Также, различные сценарии "
"инициализации оболочки, такие как системный сценарий I</etc/profile> и "
"локальный пользовательский сценарий инициализации могут содержать команды, "
"могут добавлять переменные в окружение оболочки; подробности смотрите в "
"справочной странице на предпочитаемую оболочку."

#. type: Plain text
#: man-pages/man7/environ.7:154
msgid "Bourne-style shells support the syntax"
msgstr "Оболочки, подобные Bourne, поддерживают синтаксис"

#. type: Plain text
#: man-pages/man7/environ.7:156
#, no-wrap
msgid "    NAME=value command\n"
msgstr "    ИМЯ=значение команда\n"

#. type: Plain text
#: man-pages/man7/environ.7:162
msgid ""
"to create an environment variable definition only in the scope of the "
"process that executes I<command>.  Multiple variable definitions, separated "
"by white space, may precede I<command>."
msgstr ""
"для создания определения переменной окружения только в процессе, который "
"выполняет I<команду>. Перед I<командой> можно указывать несколько "
"определений переменных, разделяя их пробельным символом."

#. type: Plain text
#: man-pages/man7/environ.7:172
msgid ""
"Arguments may also be placed in the environment at the point of an "
"B<exec>(3).  A C program can manipulate its environment using the functions "
"B<getenv>(3), B<putenv>(3), B<setenv>(3), and B<unsetenv>(3)."
msgstr ""
"При вызове B<exec>(3) в окружение также могут быть помещены и аргументы. "
"Программа, написанная на языке C, может изменять своё окружение с помощью "
"функций B<getenv>(3), B<putenv>(3), B<setenv>(3) и B<unsetenv>(3)."

#. type: Plain text
#: man-pages/man7/environ.7:176
msgid ""
"Note that the behavior of many programs and library routines is influenced "
"by the presence or value of certain environment variables.  Examples include "
"the following:"
msgstr ""
"Заметим, что наличие или значения определённых переменных окружения может "
"отказывать влияние на поведение многих программ и библиотечных процедур. "
"Примеры:"

#. type: IP
#: man-pages/man7/environ.7:176 man-pages/man7/environ.7:185
#: man-pages/man7/environ.7:192 man-pages/man7/environ.7:197
#: man-pages/man7/environ.7:201 man-pages/man7/environ.7:207
#: man-pages/man7/environ.7:213 man-pages/man7/environ.7:224
#: man-pages/man7/environ.7:228 man-pages/man7/environ.7:231
#, no-wrap
msgid "*"
msgstr "*"

#. type: Plain text
#: man-pages/man7/environ.7:185
msgid ""
"The variables B<LANG>, B<LANGUAGE>, B<NLSPATH>, B<LOCPATH>, B<LC_ALL>, "
"B<LC_MESSAGES>, and so on influence locale handling; see B<catopen>(3), "
"B<gettext>(3), and B<locale>(7)."
msgstr ""
"Переменные  B<LANG>, B<LANGUAGE>, B<NLSPATH>, B<LOCPATH>, B<LC_ALL>, "
"B<LC_MESSAGES> и т. д. влияют на работу с локалью; смотрите B<catopen>(3), "
"B<gettext>(3) и B<locale>(7)."

#. type: Plain text
#: man-pages/man7/environ.7:192
msgid ""
"B<TMPDIR> influences the path prefix of names created by B<tempnam>(3)  and "
"other routines, and the temporary directory used by B<sort>(1)  and other "
"programs."
msgstr ""
"Переменная B<TMPDIR> влияет на путь файлов, создаваемых B<tempnam>(3) и "
"некоторыми другими процедурами, а также на временный каталог, который "
"используется B<sort>(1) и некоторыми другими программами."

#. type: Plain text
#: man-pages/man7/environ.7:197
msgid ""
"B<LD_LIBRARY_PATH>, B<LD_PRELOAD>, and other B<LD_*> variables influence the "
"behavior of the dynamic loader/linker."
msgstr ""
"Переменные B<LD_LIBRARY_PATH>, B<LD_PRELOAD> и другие B<LD_*> влияют на "
"поведение динамического загрузчика/компоновщика."

#. type: Plain text
#: man-pages/man7/environ.7:201
msgid ""
"B<POSIXLY_CORRECT> makes certain programs and library routines follow the "
"prescriptions of POSIX."
msgstr ""
"Переменная B<POSIXLY_CORRECT> влияет на определённые программы и "
"библиотечные вызовы таким образом, что они включают режим соответствия POSIX."

#. type: Plain text
#: man-pages/man7/environ.7:207
msgid "The behavior of B<malloc>(3)  is influenced by B<MALLOC_*> variables."
msgstr "На поведение B<malloc>(3) оказывают влияние переменные B<MALLOC_*>."

#. type: Plain text
#: man-pages/man7/environ.7:213
msgid ""
"The variable B<HOSTALIASES> gives the name of a file containing aliases to "
"be used with B<gethostbyname>(3)."
msgstr ""
"В переменной B<HOSTALIASES> задаётся имя файла, содержащего псевдонимы имени "
"узла, которые будут использованы в функции B<gethostbyname>(3)."

#. type: Plain text
#: man-pages/man7/environ.7:224
msgid ""
"B<TZ> and B<TZDIR> give timezone information used by B<tzset>(3)  and "
"through that by functions like B<ctime>(3), B<localtime>(3), B<mktime>(3), "
"B<strftime>(3).  See also B<tzselect>(8)."
msgstr ""
"В переменных B<TZ> и B<TZDIR> указывается информация о часовом поясе; они "
"используются в функциях B<tzset>(3), B<ctime>(3), B<localtime>(3), "
"B<mktime>(3), B<strftime>(3). Смотрите также B<tzselect>(8)."

#. type: Plain text
#: man-pages/man7/environ.7:228
msgid ""
"B<TERMCAP> gives information on how to address a given terminal (or gives "
"the name of a file containing such information)."
msgstr ""
"В переменной B<TERMCAP> указывается информация по работе с терминалом (можно "
"указать имя файла, содержащего такую информацию)."

#. type: Plain text
#: man-pages/man7/environ.7:231
msgid ""
"B<COLUMNS> and B<LINES> tell applications about the window size, possibly "
"overriding the actual size."
msgstr ""
"Через переменные B<COLUMNS> и B<LINES> приложение может узнать о размере "
"окна (возможно указать ненастоящий размер)."

#. type: Plain text
#: man-pages/man7/environ.7:236
msgid ""
"B<PRINTER> or B<LPDEST> may specify the desired printer to use.  See "
"B<lpr>(1)."
msgstr ""
"В переменной B<PRINTER> или B<LPDEST> можно указать предпочтительный для "
"печати принтер. Смотрите B<lpr>(1)."

#. type: SH
#: man-pages/man7/environ.7:236
#, no-wrap
msgid "NOTES"
msgstr "ЗАМЕЧАНИЯ"

#. type: Plain text
#: man-pages/man7/environ.7:243
msgid ""
"The B<prctl>(2)  B<PR_SET_MM_ENV_START> and B<PR_SET_MM_ENV_END> operations "
"can be used to control the location of the process's environment."
msgstr ""
"Операции B<prctl>(2)  B<PR_SET_MM_ENV_START> и B<PR_SET_MM_ENV_END> можно "
"использовать для управления расположением окружения процесса."

#. type: SH
#: man-pages/man7/environ.7:243
#, no-wrap
msgid "BUGS"
msgstr "ДЕФЕКТЫ"

#. type: Plain text
#: man-pages/man7/environ.7:248
msgid ""
"Clearly there is a security risk here.  Many a system command has been "
"tricked into mischief by a user who specified unusual values for B<IFS> or "
"B<LD_LIBRARY_PATH>."
msgstr ""
"Честно говоря, использование переменных окружения таит в себе проблемы с "
"безопасностью. Многие системные команды могут неправильно работать, если "
"пользователь укажет неправильные значения для переменной B<IFS> или "
"B<LD_LIBRARY_PATH>."

#. type: Plain text
#: man-pages/man7/environ.7:281
msgid ""
"There is also the risk of name space pollution.  Programs like I<make> and "
"I<autoconf> allow overriding of default utility names from the environment "
"with similarly named variables in all caps.  Thus one uses B<CC> to select "
"the desired C compiler (and similarly B<MAKE>, B<AR>, B<AS>, B<FC>, B<LD>, "
"B<LEX>, B<RM>, B<YACC>, etc.).  However, in some traditional uses such an "
"environment variable gives options for the program instead of a pathname.  "
"Thus, one has B<MORE>, B<LESS>, and B<GZIP>.  Such usage is considered "
"mistaken, and to be avoided in new programs.  The authors of I<gzip> should "
"consider renaming their option to B<GZIP_OPT>."
msgstr ""
"Также есть риск засорения пространства имен. Такие программы как I<make> и "
"I<autoconf> позволяют заменять имена используемых по умолчанию утилит через "
"переменные окружения. Например, переменная B<CC> используется для выбора "
"нужного C-компилятора (и, похожим образом, можно использовать переменные "
"B<MAKE>, B<AR>, B<AS>, B<FC>, B<LD>, B<LEX>, B<RM>, B<YACC> и т.д.). Однако, "
"есть случаи, когда в переменных окружения задают параметры программ, а не их "
"имена (например, B<MORE>, B<LESS> и B<GZIP>). Использование таких имён для "
"переменных окружения является ошибочным и не должно применяться в новых "
"программах. Авторы I<gzip> должны бы переименовать переменную в B<GZIP_OPT>."

#. type: SH
#: man-pages/man7/environ.7:281
#, no-wrap
msgid "SEE ALSO"
msgstr "СМОТРИТЕ ТАКЖЕ"

#. type: Plain text
#: man-pages/man7/environ.7:298
msgid ""
"B<bash>(1), B<csh>(1), B<env>(1), B<login>(1), B<printenv>(1), B<sh>(1), "
"B<tcsh>(1), B<execve>(2), B<clearenv>(3), B<exec>(3), B<getenv>(3), "
"B<putenv>(3), B<setenv>(3), B<unsetenv>(3), B<locale>(7), B<ld.so>(8), "
"B<pam_env>(8)"
msgstr ""
"B<bash>(1), B<csh>(1), B<env>(1), B<login>(1), B<printenv>(1), B<sh>(1), "
"B<tcsh>(1), B<execve>(2), B<clearenv>(3), B<exec>(3), B<getenv>(3), "
"B<putenv>(3), B<setenv>(3), B<unsetenv>(3), B<locale>(7), B<ld.so>(8), "
"B<pam_env>(8)"

#. type: TH
#: man-pages/man7/epoll.7:21
#, no-wrap
msgid "EPOLL"
msgstr "EPOLL"

#. type: TH
#: man-pages/man7/epoll.7:21
#, no-wrap
msgid "2019-03-06"
msgstr "2019-03-06"

#. type: Plain text
#: man-pages/man7/epoll.7:24
msgid "epoll - I/O event notification facility"
msgstr "epoll - средство уведомления о событии ввода-вывода"

#. type: Plain text
#: man-pages/man7/epoll.7:26
msgid "B<#include E<lt>sys/epoll.hE<gt>>"
msgstr "B<#include E<lt>sys/epoll.hE<gt>>"

#. type: Plain text
#: man-pages/man7/epoll.7:36
msgid ""
"The B<epoll> API performs a similar task to B<poll>(2): monitoring multiple "
"file descriptors to see if I/O is possible on any of them.  The B<epoll> API "
"can be used either as an edge-triggered or a level-triggered interface and "
"scales well to large numbers of watched file descriptors."
msgstr ""
"Программный интерфейс B<epoll> выполняется схожую с B<poll>(2) задачу: "
"следит за несколькими файловыми дескрипторами и ждёт, когда станет возможен "
"ввод-вывод для одного из них. Программный интерфейс B<epoll> можно "
"использовать либо в режиме edge-triggered, либо в level-triggered и "
"применять для слежения за достаточно большим количеством файловых "
"дескрипторов."

#. type: Plain text
#: man-pages/man7/epoll.7:44
msgid ""
"The central concept of the B<epoll> API is the B<epoll> I<instance>, an in-"
"kernel data structure which, from a user-space perspective, can be "
"considered as a container for two lists:"
msgstr ""
"Центральным элементом программного интерфейса B<epoll> является I<экземпляр> "
"B<epoll> — структура данных ядра, которая с точки зрения пользовательского "
"пространства может рассматриваться как контейнер с двумя списками:"

#. type: Plain text
#: man-pages/man7/epoll.7:51
msgid ""
"The I<interest> list (sometimes also called the B<epoll> set): the set of "
"file descriptors that the process has registered an interest in monitoring."
msgstr ""
"Список I<interest> (иногда также называемый набором B<epoll>): набор "
"файловых дескрипторов, которые зарегистрировал процесс для слежения."

#. type: Plain text
#: man-pages/man7/epoll.7:59
msgid ""
"The I<ready> list: the set of file descriptors that are \"ready\" for I/O.  "
"The ready list is a subset of (or, more precisely, a set of references to)  "
"the file descriptors in the interest list that is dynamically populated by "
"the kernel as a result of I/O activity on those file descriptors."
msgstr ""
"Список I<ready>: набор файловых дескрипторов, которые «готовы» для "
"проведения операций ввода-вывода. Список ready — это часть набора (точнее, "
"набор ссылок) файловых дескрипторов из списка interest, он динамически "
"заполняется ядром в результате действий ввода-вывода с этими файловыми "
"дескрипторами."

#. type: Plain text
#: man-pages/man7/epoll.7:64
msgid ""
"The following system calls are provided to create and manage an B<epoll> "
"instance:"
msgstr ""
"Для создания и управления экземпляром B<epoll> служат следующие системные "
"вызовы:"

#. type: Plain text
#: man-pages/man7/epoll.7:73
msgid ""
"B<epoll_create>(2)  creates a new B<epoll> instance and returns a file "
"descriptor referring to that instance.  (The more recent "
"B<epoll_create1>(2)  extends the functionality of B<epoll_create>(2).)"
msgstr ""
"Вызов B<epoll_create>(2) создаёт экземпляр новый B<epoll> и возвращает "
"файловый дескриптор, указывающий на этот экземпляр (более новый "
"B<epoll_create1>(2) расширяет возможности B<epoll_create>(2))."

#. type: Plain text
#: man-pages/man7/epoll.7:79
msgid ""
"Interest in particular file descriptors is then registered via "
"B<epoll_ctl>(2), which adds items to the interest list of the B<epoll> "
"instance."
msgstr ""
"Затем с помощью B<epoll_ctl>(2) регистрируются интересующие файловые "
"дескрипторы, который добавляет их в список interest экземпляра I<epoll>."

#. type: Plain text
#: man-pages/man7/epoll.7:88
msgid ""
"B<epoll_wait>(2)  waits for I/O events, blocking the calling thread if no "
"events are currently available.  (This system call can be thought of as "
"fetching items from the ready list of the B<epoll> instance.)"
msgstr ""
"Вызов B<epoll_wait>(2) ждёт наступления событий ввода-вывода, блокируя "
"вызывающую нить, если события пока недоступны (данный системный вызов можно "
"рассматривать как выборщике элементов из списка готовности экземпляра "
"B<epoll>)."

#. type: SS
#: man-pages/man7/epoll.7:88
#, no-wrap
msgid "Level-triggered and edge-triggered"
msgstr "Режимы level-triggered и edge-triggered"

#. type: Plain text
#: man-pages/man7/epoll.7:97
msgid ""
"The B<epoll> event distribution interface is able to behave both as edge-"
"triggered (ET) and as level-triggered (LT).  The difference between the two "
"mechanisms can be described as follows.  Suppose that this scenario happens:"
msgstr ""
"Существует два режима выдачи событий B<epoll>: edge-triggered (ET) и level-"
"triggered (LT). Разницу между ними можно описать так. Предположим, что "
"реализован следующий сценарий событий:"

#. type: IP
#: man-pages/man7/epoll.7:97 man-pages/man7/epoll.7:381
#, no-wrap
msgid "1."
msgstr "1."

#. type: Plain text
#: man-pages/man7/epoll.7:103
msgid ""
"The file descriptor that represents the read side of a pipe (I<rfd>)  is "
"registered on the B<epoll> instance."
msgstr ""
"Файловый дескриптор, представляющий читающую сторону канала (I<rfd>), "
"регистрируется в экземпляре B<epoll>."

#. type: IP
#: man-pages/man7/epoll.7:103 man-pages/man7/epoll.7:415
#, no-wrap
msgid "2."
msgstr "2."

#. type: Plain text
#: man-pages/man7/epoll.7:105
msgid "A pipe writer writes 2\\ kB of data on the write side of the pipe."
msgstr ""
"Пишущая сторона канала записывает 2\\ КБ данных на записываемой стороне "
"канала."

#. type: IP
#: man-pages/man7/epoll.7:105 man-pages/man7/epoll.7:425
#, no-wrap
msgid "3."
msgstr "3."

#. type: Plain text
#: man-pages/man7/epoll.7:111
msgid ""
"A call to B<epoll_wait>(2)  is done that will return I<rfd> as a ready file "
"descriptor."
msgstr ""
"Вызов B<epoll_wait>(2) завершается и возвращает I<rfd> как готовый файловый "
"дескриптор."

#. type: IP
#: man-pages/man7/epoll.7:111 man-pages/man7/epoll.7:435
#, no-wrap
msgid "4."
msgstr "4."

#. type: Plain text
#: man-pages/man7/epoll.7:114
msgid "The pipe reader reads 1\\ kB of data from I<rfd>."
msgstr "Читающая сторона канала считывает 1\\ КБ данных из I<rfd>."

#. type: IP
#: man-pages/man7/epoll.7:114 man-pages/man7/epoll.7:449
#, no-wrap
msgid "5."
msgstr "5."

#. type: Plain text
#: man-pages/man7/epoll.7:118
msgid "A call to B<epoll_wait>(2)  is done."
msgstr "Вызов B<epoll_wait>(2) завершается."

#. type: Plain text
#: man-pages/man7/epoll.7:153
msgid ""
"If the I<rfd> file descriptor has been added to the B<epoll> interface using "
"the B<EPOLLET> (edge-triggered)  flag, the call to B<epoll_wait>(2)  done in "
"step B<5> will probably hang despite the available data still present in the "
"file input buffer; meanwhile the remote peer might be expecting a response "
"based on the data it already sent.  The reason for this is that edge-"
"triggered mode delivers events only when changes occur on the monitored file "
"descriptor.  So, in step B<5> the caller might end up waiting for some data "
"that is already present inside the input buffer.  In the above example, an "
"event on I<rfd> will be generated because of the write done in B<2> and the "
"event is consumed in B<3>.  Since the read operation done in B<4> does not "
"consume the whole buffer data, the call to B<epoll_wait>(2)  done in step "
"B<5> might block indefinitely."
msgstr ""
"Если файловый дескриптор I<rfd> добавлен к экземпляру B<epoll> с указанным "
"флагом B<EPOLLET> (edge-triggered), то вызов B<epoll_wait>(2) на шаге 5, "
"вероятно, повиснет, несмотря на имеющие данные в буфере ввода; в это же "
"время удалённая сторона может ожидать подтверждения приёма уже отправленных "
"данных. Причиной этого является то, что в режиме edge-triggered события "
"доставляются только когда происходит изменение состояния отслеживаемого "
"файлового дескриптора. Поэтому в шаге B<5> вызывающий может бесконечно ждать "
"появления данных, хотя они уже есть в буфере ввода. В приведённом выше "
"примере событие для I<rfd> будет сгенерировано из-за операции записи, "
"сделанной в шаге B<2>, и это событие будет обработано в шаге B<3>. Так как "
"операция в шаге B<4>, не прочитала все данные из буфера, вызов "
"B<epoll_wait>(2) в шаге B<5> может заблокироваться навсегда."

#. type: Plain text
#: man-pages/man7/epoll.7:163
msgid ""
"An application that employs the B<EPOLLET> flag should use nonblocking file "
"descriptors to avoid having a blocking read or write starve a task that is "
"handling multiple file descriptors.  The suggested way to use B<epoll> as an "
"edge-triggered (B<EPOLLET>)  interface is as follows:"
msgstr ""
"Приложение, которое применяет флаг B<EPOLLET>, должно использовать "
"неблокирующие файловые дескрипторы, чтобы избежать приостановки задания, "
"обрабатывающего множество файловых дескрипторов, из-за блокировок чтения или "
"записи. Предлагаемый способ использования B<epoll> с интерфейсом Edge "
"Triggered (B<EPOLLET>):"

#. type: TP
#: man-pages/man7/epoll.7:164
#, no-wrap
msgid "B<i>"
msgstr "B<i>"

#. type: Plain text
#: man-pages/man7/epoll.7:167
msgid "with nonblocking file descriptors; and"
msgstr "неблокирующие файловые дескрипторы; и"

#. type: TP
#: man-pages/man7/epoll.7:167
#, no-wrap
msgid "B<ii>"
msgstr "B<ii>"

#. type: Plain text
#: man-pages/man7/epoll.7:175
msgid ""
"by waiting for an event only after B<read>(2)  or B<write>(2)  return "
"B<EAGAIN>."
msgstr ""
"ожидание события только после того, как B<read>(2) или B<write>(2) возвратят "
"B<EAGAIN>."

#. type: Plain text
#: man-pages/man7/epoll.7:186
msgid ""
"By contrast, when used as a level-triggered interface (the default, when "
"B<EPOLLET> is not specified), B<epoll> is simply a faster B<poll>(2), and "
"can be used wherever the latter is used since it shares the same semantics."
msgstr ""
"Напротив, при использовании интерфейса level-triggered (по умолчанию, если "
"не указан B<EPOLLET>) B<epoll> проще и быстрее B<poll>(2), и может быть "
"использован везде, где используется последний, так как имеет ту же семантику."

#. type: Plain text
#: man-pages/man7/epoll.7:203
msgid ""
"Since even with edge-triggered B<epoll>, multiple events can be generated "
"upon receipt of multiple chunks of data, the caller has the option to "
"specify the B<EPOLLONESHOT> flag, to tell B<epoll> to disable the associated "
"file descriptor after the receipt of an event with B<epoll_wait>(2).  When "
"the B<EPOLLONESHOT> flag is specified, it is the caller's responsibility to "
"rearm the file descriptor using B<epoll_ctl>(2)  with B<EPOLL_CTL_MOD>."
msgstr ""
"Так как даже с edge-triggered B<epoll> при получении нескольких порций "
"данных могут генерироваться множественные события, вызывающий может задать "
"флаг B<EPOLLONESHOT>, который указывает B<epoll> отключить связанный "
"файловый дескриптор после приёма события с помощью B<epoll_wait>(2). Если "
"указан флаг B<EPOLLONESHOT>, то вызывающий должен переустановить файловый "
"дескриптор с помощью B<epoll_ctl>(2) с флагом B<EPOLL_CTL_MOD>."

#. type: Plain text
#: man-pages/man7/epoll.7:220
msgid ""
"If multiple threads (or processes, if child processes have inherited the "
"B<epoll> file descriptor across B<fork>(2))  are blocked in "
"B<epoll_wait>(2)  waiting on the same the same epoll file descriptor and a "
"file descriptor in the interest list that is marked for edge-triggered "
"(B<EPOLLET>)  notification becomes ready, just one of the threads (or "
"processes) is awoken from B<epoll_wait>(2).  This provides a useful "
"optimization for avoiding \"thundering herd\" wake-ups in some scenarios."
msgstr ""
"Если несколько нитей (или процессов, если дочерние процессы унаследовали "
"файловый дескриптор B<epoll> при B<fork>(2)) блокируются в ожидании "
"B<epoll_wait>(2) одного и того же файлового дескриптора и файловый "
"дескриптор в списке interest, помеченный для уведомления edge-triggered "
"(B<EPOLLET>), становится готовым, то только одна из нитей (или процессов) "
"пробуждается из B<epoll_wait>(2). Такая полезная оптимизация в некоторых "
"случаях помогает избежать «лавины» пробуждений."

#. type: SS
#: man-pages/man7/epoll.7:220
#, no-wrap
msgid "Interaction with autosleep"
msgstr "Взаимодействие с autosleep"

#. type: Plain text
#: man-pages/man7/epoll.7:232
msgid ""
"If the system is in B<autosleep> mode via I</sys/power/autosleep> and an "
"event happens which wakes the device from sleep, the device driver will keep "
"the device awake only until that event is queued.  To keep the device awake "
"until the event has been processed, it is necessary to use the "
"B<epoll_ctl>(2)  B<EPOLLWAKEUP> flag."
msgstr ""
"Если система в режиме B<autosleep> посредством I</sys/power/autosleep> и "
"происходит событие, которое пробуждает устройство, то драйвер устройства "
"держит устройство проснувшимся только, пока событие ставится в очередь. "
"Чтобы устройство не заснуло пока не обработает событие, необходимо "
"использовать флаг B<epoll_ctl>(2) B<EPOLLWAKEUP>."

#. type: Plain text
#: man-pages/man7/epoll.7:251
msgid ""
"When the B<EPOLLWAKEUP> flag is set in the B<events> field for a I<struct "
"epoll_event>, the system will be kept awake from the moment the event is "
"queued, through the B<epoll_wait>(2)  call which returns the event until the "
"subsequent B<epoll_wait>(2)  call.  If the event should keep the system "
"awake beyond that time, then a separate I<wake_lock> should be taken before "
"the second B<epoll_wait>(2)  call."
msgstr ""
"Флаг B<EPOLLWAKEUP> задаётся в поле B<events> для I<struct epoll_event>; "
"система будет оставаться разбуженной с момента когда событие поступает в "
"очередь, пока не закончится работа вызова B<epoll_wait>(2), возвращающий "
"событие, и до последующего вызова B<epoll_wait>(2). Если событие должно "
"держать систему разбуженной дольше, то нужно применить отдельный "
"I<wake_lock> перед вторым вызовом B<epoll_wait>(2)."

#. type: SS
#: man-pages/man7/epoll.7:251
#, no-wrap
msgid "/proc interfaces"
msgstr "Интерфейсы /proc"

#.  Following was added in 2.6.28, but them removed in 2.6.29
#.  .TP
#.  .IR /proc/sys/fs/epoll/max_user_instances " (since Linux 2.6.28)"
#.  This specifies an upper limit on the number of epoll instances
#.  that can be created per real user ID.
#. type: Plain text
#: man-pages/man7/epoll.7:259
msgid ""
"The following interfaces can be used to limit the amount of kernel memory "
"consumed by epoll:"
msgstr ""
"Для ограничения потребления epoll памяти ядра, можно использовать следующие "
"интерфейсы:"

#. type: TP
#: man-pages/man7/epoll.7:259
#, no-wrap
msgid "I</proc/sys/fs/epoll/max_user_watches> (since Linux 2.6.28)"
msgstr "I</proc/sys/fs/epoll/max_user_watches> (начиная с Linux 2.6.28)"

#.  2.6.29 (in 2.6.28, the default was 1/32 of lowmem)
#. type: Plain text
#: man-pages/man7/epoll.7:273
msgid ""
"This specifies a limit on the total number of file descriptors that a user "
"can register across all epoll instances on the system.  The limit is per "
"real user ID.  Each registered file descriptor costs roughly 90 bytes on a "
"32-bit kernel, and roughly 160 bytes on a 64-bit kernel.  Currently, the "
"default value for I<max_user_watches> is 1/25 (4%) of the available low "
"memory, divided by the registration cost in bytes."
msgstr ""
"Задаёт ограничение на общее количество файловых дескрипторов, которые "
"пользователь может зарегистрировать во всех экземплярах epoll в системе. "
"Ограничение привязывается к реальному идентификатору пользователя. Каждый "
"зарезервированный файловый дескриптор занимает, приблизительно, 90 байт в 32-"
"битном ядре, и, приблизительно, 160 байт в 64-битном ядре. В настоящее "
"время, значение по умолчанию для I<max_user_watches> равно 1/25 (4%) "
"доступной памяти ядра (low memory), поделённое на значение размера "
"дескриптора в байтах."

#. type: SS
#: man-pages/man7/epoll.7:273
#, no-wrap
msgid "Example for suggested usage"
msgstr "Примеры использования"

#. type: Plain text
#: man-pages/man7/epoll.7:302
msgid ""
"While the usage of B<epoll> when employed as a level-triggered interface "
"does have the same semantics as B<poll>(2), the edge-triggered usage "
"requires more clarification to avoid stalls in the application event loop.  "
"In this example, listener is a nonblocking socket on which B<listen>(2)  has "
"been called.  The function I<do_use_fd()> uses the new ready file descriptor "
"until B<EAGAIN> is returned by either B<read>(2)  or B<write>(2).  An event-"
"driven state machine application should, after having received B<EAGAIN>, "
"record its current state so that at the next call to I<do_use_fd()> it will "
"continue to B<read>(2)  or B<write>(2)  from where it stopped before."
msgstr ""
"При применении B<epoll> с интерфейсом level-triggered он имеет ту же "
"семантику что и B<poll>(2), а при edge-triggered требует больших проверок "
"для избежания зависаний приложения в событийном цикле. В этом примере, "
"слушающим является неблокирующий сокет, для которого был вызван "
"B<listen>(2). Функция I<do_use_fd>() использует новый готовый файловый "
"дескриптор до тех пор, пока не возвратится B<EAGAIN> от B<read>(2) или "
"B<write>(2). Приложение на основе машины состояний должно после получения "
"B<EAGAIN> записать своё текущее состояние так, чтобы последующий вызов "
"I<do_use_fd>() продолжил выполнять B<read>(2) или B<write>(2) с места "
"остановки."

#. type: Plain text
#: man-pages/man7/epoll.7:308
#, no-wrap
msgid ""
"#define MAX_EVENTS 10\n"
"struct epoll_event ev, events[MAX_EVENTS];\n"
"int listen_sock, conn_sock, nfds, epollfd;\n"
msgstr ""
"#define MAX_EVENTS 10\n"
"struct epoll_event ev, events[MAX_EVENTS];\n"
"int listen_sock, conn_sock, nfds, epollfd;\n"

#. type: Plain text
#: man-pages/man7/epoll.7:311
#, no-wrap
msgid ""
"/* Code to set up listening socket, \\(aqlisten_sock\\(aq,\n"
"   (socket(), bind(), listen()) omitted */\n"
msgstr ""
"/* Код для настройки слушающего сокета, \\(aqlisten_sock\\(aq,\n"
"   (socket(), bind(), listen()) не показаны */\n"

#. type: Plain text
#: man-pages/man7/epoll.7:317
#, no-wrap
msgid ""
"epollfd = epoll_create1(0);\n"
"if (epollfd == -1) {\n"
"    perror(\"epoll_create1\");\n"
"    exit(EXIT_FAILURE);\n"
"}\n"
msgstr ""
"epollfd = epoll_create1(0);\n"
"if (epollfd == -1) {\n"
"    perror(\"epoll_create1\");\n"
"    exit(EXIT_FAILURE);\n"
"}\n"

#. type: Plain text
#: man-pages/man7/epoll.7:324
#, no-wrap
msgid ""
"ev.events = EPOLLIN;\n"
"ev.data.fd = listen_sock;\n"
"if (epoll_ctl(epollfd, EPOLL_CTL_ADD, listen_sock, &ev) == -1) {\n"
"    perror(\"epoll_ctl: listen_sock\");\n"
"    exit(EXIT_FAILURE);\n"
"}\n"
msgstr ""
"ev.events = EPOLLIN;\n"
"ev.data.fd = listen_sock;\n"
"if (epoll_ctl(epollfd, EPOLL_CTL_ADD, listen_sock, &ev) == -1) {\n"
"    perror(\"epoll_ctl: listen_sock\");\n"
"    exit(EXIT_FAILURE);\n"
"}\n"

#. type: Plain text
#: man-pages/man7/epoll.7:331
#, no-wrap
msgid ""
"for (;;) {\n"
"    nfds = epoll_wait(epollfd, events, MAX_EVENTS, -1);\n"
"    if (nfds == -1) {\n"
"        perror(\"epoll_wait\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"for (;;) {\n"
"    nfds = epoll_wait(epollfd, events, MAX_EVENTS, -1);\n"
"    if (nfds == -1) {\n"
"        perror(\"epoll_wait\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: man-pages/man7/epoll.7:353
#, no-wrap
msgid ""
"    for (n = 0; n E<lt> nfds; ++n) {\n"
"        if (events[n].data.fd == listen_sock) {\n"
"            conn_sock = accept(listen_sock,\n"
"                               (struct sockaddr *) &addr, &addrlen);\n"
"            if (conn_sock == -1) {\n"
"                perror(\"accept\");\n"
"                exit(EXIT_FAILURE);\n"
"            }\n"
"            setnonblocking(conn_sock);\n"
"            ev.events = EPOLLIN | EPOLLET;\n"
"            ev.data.fd = conn_sock;\n"
"            if (epoll_ctl(epollfd, EPOLL_CTL_ADD, conn_sock,\n"
"                        &ev) == -1) {\n"
"                perror(\"epoll_ctl: conn_sock\");\n"
"                exit(EXIT_FAILURE);\n"
"            }\n"
"        } else {\n"
"            do_use_fd(events[n].data.fd);\n"
"        }\n"
"    }\n"
"}\n"
msgstr ""
"    for (n = 0; n E<lt> nfds; ++n) {\n"
"        if (events[n].data.fd == listen_sock) {\n"
"            conn_sock = accept(listen_sock,\n"
"                               (struct sockaddr *) &addr, &addrlen);\n"
"            if (conn_sock == -1) {\n"
"                perror(\"accept\");\n"
"                exit(EXIT_FAILURE);\n"
"            }\n"
"            setnonblocking(conn_sock);\n"
"            ev.events = EPOLLIN | EPOLLET;\n"
"            ev.data.fd = conn_sock;\n"
"            if (epoll_ctl(epollfd, EPOLL_CTL_ADD, conn_sock,\n"
"                        &ev) == -1) {\n"
"                perror(\"epoll_ctl: conn_sock\");\n"
"                exit(EXIT_FAILURE);\n"
"            }\n"
"        } else {\n"
"            do_use_fd(events[n].data.fd);\n"
"        }\n"
"    }\n"
"}\n"

#. type: Plain text
#: man-pages/man7/epoll.7:372
msgid ""
"When used as an edge-triggered interface, for performance reasons, it is "
"possible to add the file descriptor inside the B<epoll> interface "
"(B<EPOLL_CTL_ADD>)  once by specifying (B<EPOLLIN>|B<EPOLLOUT>).  This "
"allows you to avoid continuously switching between B<EPOLLIN> and "
"B<EPOLLOUT> calling B<epoll_ctl>(2)  with B<EPOLL_CTL_MOD>."
msgstr ""
"При использовании интерфейса edge-triggered для большей производительности "
"можно однократно добавить файловый дескриптор внутрь интерфейса B<epoll> "
"(B<EPOLL_CTL_ADD>), указав (B<EPOLLIN>|B<EPOLLOUT>). Это позволит вам "
"избежать постоянного переключения между B<EPOLLIN> и B<EPOLLOUT>, "
"вызывающими B<epoll_ctl>(2) c B<EPOLL_CTL_MOD>."

#. type: SS
#: man-pages/man7/epoll.7:372
#, no-wrap
msgid "Questions and answers"
msgstr "Вопросы и ответы"

#. type: IP
#: man-pages/man7/epoll.7:373
#, no-wrap
msgid "0."
msgstr "0."

#. type: Plain text
#: man-pages/man7/epoll.7:376
msgid ""
"What is the key used to distinguish the file descriptors registered in an "
"interest list?"
msgstr ""
"По какому ключу различать зарегистрированные файловые дескрипторы в списке "
"interest?"

#. type: Plain text
#: man-pages/man7/epoll.7:381
msgid ""
"The key is the combination of the file descriptor number and the open file "
"description (also known as an \"open file handle\", the kernel's internal "
"representation of an open file)."
msgstr ""
"Уникальной комбинацией является номер файлового дескриптора и описание "
"открытого файла (так называемый «описатель открытого файла» — внутреннее "
"представление открытого файла в ядре)."

#. type: Plain text
#: man-pages/man7/epoll.7:385
msgid ""
"What happens if you register the same file descriptor on an B<epoll> "
"instance twice?"
msgstr ""
"Что случится, если зарегистрировать один файловый дескриптор в экземпляре "
"B<epoll> дважды?"

#.  But a file descriptor duplicated by fork(2) can't be added to the
#.  set, because the [file *, fd] pair is already in the epoll set.
#.  That is a somewhat ugly inconsistency.  On the one hand, a child process
#.  cannot add the duplicate file descriptor to the epoll set.  (In every
#.  other case that I can think of, file descriptors duplicated by fork have
#.  similar semantics to file descriptors duplicated by dup() and friends.)  On
#.  the other hand, the very fact that the child has a duplicate of the
#.  file descriptor means that even if the parent closes its file descriptor,
#.  then epoll_wait() in the parent will continue to receive notifications for
#.  that file descriptor because of the duplicated file descriptor in the child.
#.  See http://thread.gmane.org/gmane.linux.kernel/596462/
#.  "epoll design problems with common fork/exec patterns"
#.  mtk, Feb 2008
#. type: Plain text
#: man-pages/man7/epoll.7:415
msgid ""
"You will probably get B<EEXIST>.  However, it is possible to add a duplicate "
"(B<dup>(2), B<dup2>(2), B<fcntl>(2)  B<F_DUPFD>)  file descriptor to the "
"same B<epoll> instance.  This can be a useful technique for filtering "
"events, if the duplicate file descriptors are registered with different "
"I<events> masks."
msgstr ""
"Вероятно, вы получите B<EEXIST>. Однако возможно добавить дубликат файлового "
"дескриптора (B<dup>(2), B<dup2>(2), B<fcntl>(2)  B<F_DUPFD>) в тот же "
"экземпляр B<epoll>. Это может быть полезно для фильтрующих событий, если "
"дубликаты файловых дескрипторов регистрируются с разными масками I<events>."

#. type: Plain text
#: man-pages/man7/epoll.7:422
msgid ""
"Can two B<epoll> instances wait for the same file descriptor? If so, are "
"events reported to both B<epoll> file descriptors?"
msgstr ""
"Могут ли два экземпляра B<epoll> ожидать один файловый дескриптор? Если да, "
"то сообщаются ли события в оба файловых дескриптора B<epoll>?"

#. type: Plain text
#: man-pages/man7/epoll.7:425
msgid ""
"Yes, and events would be reported to both.  However, careful programming may "
"be needed to do this correctly."
msgstr ""
"Да, и события будут доходить в оба. Однако, чтобы сделать это правильно, "
"нужна внимательность к деталям."

#. type: Plain text
#: man-pages/man7/epoll.7:429
msgid "Is the B<epoll> file descriptor itself poll/epoll/selectable?"
msgstr ""
"Могут ли операции poll/epoll/select применяться к самому файловому "
"дескриптору B<epoll>?"

#. type: Plain text
#: man-pages/man7/epoll.7:435
msgid ""
"Yes.  If an B<epoll> file descriptor has events waiting, then it will "
"indicate as being readable."
msgstr ""
"Да. Если файловый дескриптор B<epoll> имеет ожидающие события, то он будет "
"помечен как доступный для чтения."

#. type: Plain text
#: man-pages/man7/epoll.7:439
msgid ""
"What happens if one attempts to put an B<epoll> file descriptor into its own "
"file descriptor set?"
msgstr ""
"Что случится, если попытаться поместить файловый дескриптор B<epoll> в свой "
"собственный набор файловых дескрипторов?"

#. type: Plain text
#: man-pages/man7/epoll.7:449
msgid ""
"The B<epoll_ctl>(2)  call fails (B<EINVAL>).  However, you can add an "
"B<epoll> file descriptor inside another B<epoll> file descriptor set."
msgstr ""
"Вызов B<epoll_ctl>(2) завершается ошибкой (B<EINVAL>). Однако вы можете "
"добавить файловый дескриптор B<epoll> внутрь другого набора файлового "
"дескриптора B<epoll>."

#. type: Plain text
#: man-pages/man7/epoll.7:453
msgid ""
"Can I send an B<epoll> file descriptor over a UNIX domain socket to another "
"process?"
msgstr ""
"Можно ли отправить файловый дескриптор B<epoll> через доменный сокет UNIX "
"другому процессу?"

#. type: Plain text
#: man-pages/man7/epoll.7:456
msgid ""
"Yes, but it does not make sense to do this, since the receiving process "
"would not have copies of the file descriptors in the interest list."
msgstr ""
"Да, но это не имеет смысла, так как принимающий процесс не имеет копий "
"файловых дескрипторов в списке interest."

#. type: IP
#: man-pages/man7/epoll.7:456
#, no-wrap
msgid "6."
msgstr "6."

#. type: Plain text
#: man-pages/man7/epoll.7:460
msgid ""
"Will closing a file descriptor cause it to be removed from all B<epoll> "
"interest lists?"
msgstr ""
"Приводит ли закрытие файлового дескриптора к его удалению из всех списков "
"interest B<epoll>?"

#. type: Plain text
#: man-pages/man7/epoll.7:475
msgid ""
"Yes, but be aware of the following point.  A file descriptor is a reference "
"to an open file description (see B<open>(2)).  Whenever a file descriptor is "
"duplicated via B<dup>(2), B<dup2>(2), B<fcntl>(2)  B<F_DUPFD>, or "
"B<fork>(2), a new file descriptor referring to the same open file "
"description is created.  An open file description continues to exist until "
"all file descriptors referring to it have been closed."
msgstr ""
"Да, но учтите следующий момент. Файловый дескриптор является ссылкой на "
"открытое файловое описание (смотрите B<open>(2)). При создании дубля "
"файлового дескриптора с помощью B<dup>(2), B<dup2>(2), B<fcntl>(2) "
"B<F_DUPFD> или B<fork>(2) созданный новый файловый дескриптор указывает на "
"то же открытое файловое описание. Открытое файловое описание продолжает "
"существовать до тех пор, пока все указывающие на него файловые дескрипторы "
"не будут закрыты."

#. type: Plain text
#: man-pages/man7/epoll.7:495
msgid ""
"A file descriptor is removed from an interest list only after all the file "
"descriptors referring to the underlying open file description have been "
"closed.  This means that even after a file descriptor that is part of an "
"interest list has been closed, events may be reported for that file "
"descriptor if other file descriptors referring to the same underlying file "
"description remain open.  To prevent this happening, the file descriptor "
"must be explicitly removed from the interest list (using B<epoll_ctl>(2)  "
"B<EPOLL_CTL_DEL>)  before it is duplicated.  Alternatively, the application "
"must ensure that all file descriptors are closed (which may be difficult if "
"file descriptors were duplicated behind the scenes by library functions that "
"used B<dup>(2)  or B<fork>(2))."
msgstr ""
"Файловый дескриптор удаляется из списка interest только после того, как "
"будут закрыты все файловые дескрипторы, ссылающиеся на открытое файловое "
"описание. Это означает, что даже после закрытия файлового дескриптора, "
"являющегося частью списка interest, могут поступать события от файлового "
"дескриптора, если остались открытыми другие файловые дескрипторы, "
"ссылающиеся на тоже файловое описание. Чтобы такого не случалось, файловый "
"дескриптор должен быть удалён из списка interest явным образом (с помощью "
"B<epoll_ctl>(2) B<EPOLL_CTL_DEL>) до создания его дубликата. Или же "
"приложение может проверить,что закрыты все файловые дескрипторы (что может "
"быть трудно, если дубли файлового дескриптора неявно создавались где-то в "
"библиотечных функциях с помощью B<dup>(2) или B<fork>(2))."

#. type: IP
#: man-pages/man7/epoll.7:495
#, no-wrap
msgid "7."
msgstr "7."

#. type: Plain text
#: man-pages/man7/epoll.7:499
msgid ""
"If more than one event occurs between B<epoll_wait>(2)  calls, are they "
"combined or reported separately?"
msgstr ""
"Если между вызовами B<epoll_wait>(2) придёт более одного события, то они "
"будут объединены или о них будет сообщено по отдельности?"

#. type: Plain text
#: man-pages/man7/epoll.7:501
msgid "They will be combined."
msgstr "Они будут объединены."

#. type: IP
#: man-pages/man7/epoll.7:501
#, no-wrap
msgid "8."
msgstr "8."

#. type: Plain text
#: man-pages/man7/epoll.7:504
msgid ""
"Does an operation on a file descriptor affect the already collected but not "
"yet reported events?"
msgstr ""
"Влияет ли операция над файловым дескриптором на уже собранные, но пока ещё "
"не сообщенные события?"

#. type: Plain text
#: man-pages/man7/epoll.7:509
msgid ""
"You can do two operations on an existing file descriptor.  Remove would be "
"meaningless for this case.  Modify will reread available I/O."
msgstr ""
"Вы можете выполнить две операции на существующем файловом дескрипторе. "
"Удаление в этом случае бессмысленно. Изменение приведёт к повторному чтению "
"доступного ввода/вывода."

#. type: IP
#: man-pages/man7/epoll.7:509
#, no-wrap
msgid "9."
msgstr "9."

#. type: Plain text
#: man-pages/man7/epoll.7:516
msgid ""
"Do I need to continuously read/write a file descriptor until B<EAGAIN> when "
"using the B<EPOLLET> flag (edge-triggered behavior)?"
msgstr ""
"Должен ли я читать/записывать файловый дескриптор до пор пока, не получу "
"B<EAGAIN> при использовании флага B<EPOLLET> (поведение edge-triggered)?"

#. type: Plain text
#: man-pages/man7/epoll.7:525
msgid ""
"Receiving an event from B<epoll_wait>(2)  should suggest to you that such "
"file descriptor is ready for the requested I/O operation.  You must consider "
"it ready until the next (nonblocking)  read/write yields B<EAGAIN>.  When "
"and how you will use the file descriptor is entirely up to you."
msgstr ""
"Получение события от B<epoll_wait>(2) должно сообщить вам, что файловый "
"дескриптор готов для запрошенной операции ввода/вывода. Вы должны "
"предполагать, что он готов до тех пор, пока вы не получите следующий "
"B<EAGAIN> от (неблокирующего) чтения/записи. Когда и как вы будете "
"использовать файловый дескриптор — полностью зависит от вас."

#. type: Plain text
#: man-pages/man7/epoll.7:531
msgid ""
"For packet/token-oriented files (e.g., datagram socket, terminal in "
"canonical mode), the only way to detect the end of the read/write I/O space "
"is to continue to read/write until B<EAGAIN>."
msgstr ""
"Для пакетных/метко ориентированных файлов (например, датаграмных сокетов, "
"терминал в каноническом режиме) единственным способом обнаружить конец "
"чтения/записи пространства ввода-вывода — это продолжать чтение/записи до "
"получения B<EAGAIN>."

#. type: Plain text
#: man-pages/man7/epoll.7:547
msgid ""
"For stream-oriented files (e.g., pipe, FIFO, stream socket), the condition "
"that the read/write I/O space is exhausted can also be detected by checking "
"the amount of data read from / written to the target file descriptor.  For "
"example, if you call B<read>(2)  by asking to read a certain amount of data "
"and B<read>(2)  returns a lower number of bytes, you can be sure of having "
"exhausted the read I/O space for the file descriptor.  The same is true when "
"writing using B<write>(2).  (Avoid this latter technique if you cannot "
"guarantee that the monitored file descriptor always refers to a stream-"
"oriented file.)"
msgstr ""
"Для потокоориентированных файлов (например, каналы, FIFO, потоковые сокеты) "
"условие, при которых чтение/запись пространства ввода/вывода закончилось, "
"может быть определено проверкой количества считанных/записанных данных из/в "
"целевого файлового дескриптора. Например, если вы вызвали B<read>(2) для "
"чтения определённого количества данных и B<read>(2) вернул меньшее "
"количество байтов, то можно быть уверенным, что пространство чтения ввода/"
"вывода этого файлового дескриптора закончилось. То же самое справедливо для "
"записи посредством B<write>(2) (не используйте последнее, если вы не можете "
"гарантировать, что отслеживаемый файловый дескриптор всегда ссылается на "
"потокоориентированный файл)."

#. type: SS
#: man-pages/man7/epoll.7:547
#, no-wrap
msgid "Possible pitfalls and ways to avoid them"
msgstr "Возможные ловушки и способы их обхода"

#. type: TP
#: man-pages/man7/epoll.7:548
#, no-wrap
msgid "B<o Starvation (edge-triggered)>"
msgstr "B<o Информационный голод (edge-triggered)>"

#. type: Plain text
#: man-pages/man7/epoll.7:556
msgid ""
"If there is a large amount of I/O space, it is possible that by trying to "
"drain it the other files will not get processed causing starvation.  (This "
"problem is not specific to B<epoll>.)"
msgstr ""
"Если существует большое пространство ввода/вывода, то возможно, что пока вы "
"его читаете, другие файлы не будут обрабатываться и возникнет недостаток "
"данных (этого, обычно, не происходит с B<epoll>)."

#. type: Plain text
#: man-pages/man7/epoll.7:564
msgid ""
"The solution is to maintain a ready list and mark the file descriptor as "
"ready in its associated data structure, thereby allowing the application to "
"remember which files need to be processed but still round robin amongst all "
"the ready files.  This also supports ignoring subsequent events you receive "
"for file descriptors that are already ready."
msgstr ""
"Решением будет поддержка списка готовности и маркировка файлового "
"дескриптора как готового в связанной с ним структуре данных, тем самым "
"позволяя приложению запоминать какие файлы требуют обработки, но всё ещё не "
"обработанных среди уже готовых файлов. Это также поддерживает игнорирование "
"последующих событий готовности файловых дескрипторов, получаемых вами."

#. type: TP
#: man-pages/man7/epoll.7:564
#, no-wrap
msgid "B<o If using an event cache...>"
msgstr "B<o Если использовать кэш событий…>"

#. type: Plain text
#: man-pages/man7/epoll.7:580
msgid ""
"If you use an event cache or store all the file descriptors returned from "
"B<epoll_wait>(2), then make sure to provide a way to mark its closure "
"dynamically (i.e., caused by a previous event's processing).  Suppose you "
"receive 100 events from B<epoll_wait>(2), and in event #47 a condition "
"causes event #13 to be closed.  If you remove the structure and B<close>(2)  "
"the file descriptor for event #13, then your event cache might still say "
"there are events waiting for that file descriptor causing confusion."
msgstr ""
"Если вы используете кэш событий или храните все файловые дескрипторы, "
"возвращённые от B<epoll_wait>(2), то убедитесь, что вы обеспечили способ его "
"динамического закрытия (например, вызванное обработкой предыдущего события). "
"Предположим, что вы получили 100 событий от B<epoll_wait>(2), и что в "
"событии №47 некоторое условие определяет, что событие №13 должно быть "
"закрыто. Если вы удалите структуру и выполните B<close>(2) файлового "
"дескриптора для события №13, то кэш событий всё ещё может сообщать о том, "
"что есть ожидаемые события для этого файлового дескриптора, что приводит к "
"путнице."

#. type: Plain text
#: man-pages/man7/epoll.7:591
msgid ""
"One solution for this is to call, during the processing of event 47, "
"B<epoll_ctl>(B<EPOLL_CTL_DEL>)  to delete file descriptor 13 and "
"B<close>(2), then mark its associated data structure as removed and link it "
"to a cleanup list.  If you find another event for file descriptor 13 in your "
"batch processing, you will discover the file descriptor had been previously "
"removed and there will be no confusion."
msgstr ""
"Одним из решений будет вызов, во время обработки события №47, "
"B<epoll_ctl>(B<EPOLL_CTL_DEL>) для удаления файлового дескриптора 13 и вызов "
"B<close>(2), а затем маркировка связанной с ним структуры данных как "
"удалённой и связки его со списком очистки. Если при пакетной обработке "
"найдется другое событие для файлового дескриптора 13, то обнаружится, что "
"файловый дескриптор уже был удалён и конфликтов не будет."

#. type: SH
#: man-pages/man7/epoll.7:591
#, no-wrap
msgid "VERSIONS"
msgstr "ВЕРСИИ"

#.  Its interface should be finalized in Linux kernel 2.5.66.
#. type: Plain text
#: man-pages/man7/epoll.7:597
msgid ""
"The B<epoll> API was introduced in Linux kernel 2.5.44.  Support was added "
"to glibc in version 2.3.2."
msgstr ""
"Программный интерфейс B<epoll> был добавлен в ядро Linux версии 2.5.44. "
"Поддержка в glibc доступна с версии 2.3.2."

#. type: SH
#: man-pages/man7/epoll.7:597
#, no-wrap
msgid "CONFORMING TO"
msgstr "СООТВЕТСТВИЕ СТАНДАРТАМ"

#. type: Plain text
#: man-pages/man7/epoll.7:606
msgid ""
"The B<epoll> API is Linux-specific.  Some other systems provide similar "
"mechanisms, for example, FreeBSD has I<kqueue>, and Solaris has I</dev/poll>."
msgstr ""
"Программный интерфейс B<epoll> есть только в Linux. В некоторых других "
"системах есть подобные механизмы, например, в FreeBSD есть I<kqueue>, а в "
"Solaris — I</dev/poll>."

#. type: Plain text
#: man-pages/man7/epoll.7:615
msgid ""
"The set of file descriptors that is being monitored via an epoll file "
"descriptor can be viewed via the entry for the epoll file descriptor in the "
"process's I</proc/[pid]/fdinfo> directory.  See B<proc>(5)  for further "
"details."
msgstr ""
"Набор файловых дескрипторов, которые отслеживаются через файловый дескриптор "
"epoll, можно найти в записи для файлового дескриптора epoll в каталоге "
"процесса I</proc/[pid]/fdinfo>. Подробности смотрите в B<proc>(5)."

#. type: Plain text
#: man-pages/man7/epoll.7:621
msgid ""
"The B<kcmp>(2)  B<KCMP_EPOLL_TFD> operation can be used to test whether a "
"file descriptor is present in an epoll instance."
msgstr ""
"Вызов The B<kcmp>(2) с операцией B<KCMP_EPOLL_TFD> можно использовать для "
"проверки, что файловый дескриптор присутствует в экземпляре epoll."

#. type: Plain text
#: man-pages/man7/epoll.7:627
msgid ""
"B<epoll_create>(2), B<epoll_create1>(2), B<epoll_ctl>(2), B<epoll_wait>(2), "
"B<poll>(2), B<select>(2)"
msgstr ""
"B<epoll_create>(2), B<epoll_create1>(2), B<epoll_ctl>(2), B<epoll_wait>(2), "
"B<poll>(2), B<select>(2)"

#. type: TH
#: man-pages/man2/eventfd.2:22
#, no-wrap
msgid "EVENTFD"
msgstr "EVENTFD"

#. type: Plain text
#: man-pages/man2/eventfd.2:25
msgid "eventfd - create a file descriptor for event notification"
msgstr "eventfd - создаёт файловый дескриптор для уведомления о событиях"

#. type: Plain text
#: man-pages/man2/eventfd.2:27
msgid "B<#include E<lt>sys/eventfd.hE<gt>>"
msgstr "B<#include E<lt>sys/eventfd.hE<gt>>"

#. type: Plain text
#: man-pages/man2/eventfd.2:29
msgid "B<int eventfd(unsigned int >I<initval>B<, int >I<flags>B<);>"
msgstr "B<int eventfd(unsigned int >I<initval>B<, int >I<flags>B<);>"

#. type: Plain text
#: man-pages/man2/eventfd.2:39
msgid ""
"B<eventfd>()  creates an \"eventfd object\" that can be used as an event "
"wait/notify mechanism by user-space applications, and by the kernel to "
"notify user-space applications of events.  The object contains an unsigned "
"64-bit integer (I<uint64_t>)  counter that is maintained by the kernel.  "
"This counter is initialized with the value specified in the argument "
"I<initval>."
msgstr ""
"Вызов B<eventfd>() создаёт «объект eventfd», который можно использовать в "
"качестве механизма ожидания/уведомления о событиях в приложениях "
"пространства пользователя и ядра. Объект содержит беззнаковое 64-битный "
"(I<uint64_t>) счётчик, обслуживаемый ядром. Этот счётчик инициализируется "
"значением, указанным в аргументе I<initval>."

#. type: Plain text
#: man-pages/man2/eventfd.2:44
msgid ""
"As its return value, B<eventfd>()  returns a new file descriptor that can be "
"used to refer to the eventfd object."
msgstr ""
"При завершении работы B<eventfd>() возвращает новый файловый дескриптор, "
"который можно использовать для ссылки на объект eventfd."

#. type: Plain text
#: man-pages/man2/eventfd.2:49
msgid ""
"The following values may be bitwise ORed in I<flags> to change the behavior "
"of B<eventfd>():"
msgstr ""
"Для изменения поведения B<eventfd>() можно использовать следующие значения "
"I<flags> (через OR):"

#. type: TP
#: man-pages/man2/eventfd.2:49
#, no-wrap
msgid "B<EFD_CLOEXEC> (since Linux 2.6.27)"
msgstr "B<EFD_CLOEXEC> (начиная с Linux 2.6.27)"

#. type: Plain text
#: man-pages/man2/eventfd.2:59
msgid ""
"Set the close-on-exec (B<FD_CLOEXEC>)  flag on the new file descriptor.  See "
"the description of the B<O_CLOEXEC> flag in B<open>(2)  for reasons why this "
"may be useful."
msgstr ""
"Устанавливает флаг close-on-exec (B<FD_CLOEXEC>) для нового открытого "
"файлового дескриптора. Смотрите описание флага B<O_CLOEXEC> в B<open>(2) для "
"того, чтобы узнать как это может пригодиться."

#. type: TP
#: man-pages/man2/eventfd.2:59
#, no-wrap
msgid "B<EFD_NONBLOCK> (since Linux 2.6.27)"
msgstr "B<EFD_NONBLOCK> (начиная с Linux 2.6.27)"

#. type: Plain text
#: man-pages/man2/eventfd.2:69
msgid ""
"Set the B<O_NONBLOCK> file status flag on the open file description (see "
"B<open>(2))  referred to by the new file descriptor.  Using this flag saves "
"extra calls to B<fcntl>(2)  to achieve the same result."
msgstr ""
"Устанавливает флаг состояния файла B<O_NONBLOCK> для нового открытого "
"файлового описания (смотрите B<open>(2)), на которое ссылается новый "
"файловый дескриптор. Использование данного флага делает ненужными "
"дополнительные вызовы B<fcntl>(2) для достижения того же результата."

#. type: TP
#: man-pages/man2/eventfd.2:69
#, no-wrap
msgid "B<EFD_SEMAPHORE> (since Linux 2.6.30)"
msgstr "B<EFD_SEMAPHORE> (начиная с Linux 2.6.30)"

#. type: Plain text
#: man-pages/man2/eventfd.2:73
msgid ""
"Provide semaphore-like semantics for reads from the new file descriptor.  "
"See below."
msgstr ""
"Предоставляет семафоро-подобную семантику для чтения из нового файлового "
"дескриптора. Смотрите ниже."

#. type: Plain text
#: man-pages/man2/eventfd.2:77
msgid ""
"In Linux up to version 2.6.26, the I<flags> argument is unused, and must be "
"specified as zero."
msgstr ""
"До версии Linux 2.6.26 аргумент I<flags> не использовался, и должен быть "
"равен нулю."

#. type: Plain text
#: man-pages/man2/eventfd.2:80
msgid ""
"The following operations can be performed on the file descriptor returned by "
"B<eventfd>():"
msgstr ""
"Следующие операции могут выполняться над полученным файловым дескриптором "
"B<eventfd>():"

#. type: TP
#: man-pages/man2/eventfd.2:80
#, no-wrap
msgid "B<read>(2)"
msgstr "B<read>(2)"

#. type: Plain text
#: man-pages/man2/eventfd.2:90
msgid ""
"Each successful B<read>(2)  returns an 8-byte integer.  A B<read>(2)  fails "
"with the error B<EINVAL> if the size of the supplied buffer is less than 8 "
"bytes."
msgstr ""
"Каждый завершившийся без ошибок вызов B<read>(2) возвращает 8-байтное целое. "
"Вызов B<read>(2) завершается с ошибкой B<EINVAL>, если размер указанного "
"буфера меньше 8 байт."

#. type: Plain text
#: man-pages/man2/eventfd.2:95
msgid ""
"The value returned by B<read>(2)  is in host byte order\\(emthat is, the "
"native byte order for integers on the host machine."
msgstr ""
"Возвращаемое B<read>(2) значение имеет порядок байт узла, т. е., "
"используемый порядок байт для целых на машине узла."

#. type: Plain text
#: man-pages/man2/eventfd.2:102
msgid ""
"The semantics of B<read>(2)  depend on whether the eventfd counter currently "
"has a nonzero value and whether the B<EFD_SEMAPHORE> flag was specified when "
"creating the eventfd file descriptor:"
msgstr ""
"Семантика B<read>(2) зависит от значения счётчика eventfd — равно оно нулю "
"или нет, и был ли указан флаг B<EFD_SEMAPHORE> при создании файлового "
"дескриптора eventfd:"

#. type: Plain text
#: man-pages/man2/eventfd.2:110
msgid ""
"If B<EFD_SEMAPHORE> was not specified and the eventfd counter has a nonzero "
"value, then a B<read>(2)  returns 8 bytes containing that value, and the "
"counter's value is reset to zero."
msgstr ""
"Если флаг B<EFD_SEMAPHORE> не указан и счётчик eventfd не равен нулю, то "
"B<read>(2) возвращает 8 байт с его значением и значение счётчика "
"сбрасывается в ноль."

#. type: Plain text
#: man-pages/man2/eventfd.2:117
msgid ""
"If B<EFD_SEMAPHORE> was specified and the eventfd counter has a nonzero "
"value, then a B<read>(2)  returns 8 bytes containing the value 1, and the "
"counter's value is decremented by 1."
msgstr ""
"Если флаг B<EFD_SEMAPHORE> задан указан и счётчик eventfd не равен нулю, то "
"B<read>(2) возвращает 8 байт, содержащие значение 1, и значение счётчика "
"уменьшается на 1."

#. type: Plain text
#: man-pages/man2/eventfd.2:127
msgid ""
"If the eventfd counter is zero at the time of the call to B<read>(2), then "
"the call either blocks until the counter becomes nonzero (at which time, the "
"B<read>(2)  proceeds as described above)  or fails with the error B<EAGAIN> "
"if the file descriptor has been made nonblocking."
msgstr ""
"Если счётчик eventfd равен нулю во время вызова B<read>(2), то вызов "
"блокируется до тех пор, пока счётчик станет не равным нулю (время работы "
"B<read>(2) описано выше) или завершается с ошибкой B<EAGAIN>, если файловый "
"дескриптор создан неблокируемым."

#. type: TP
#: man-pages/man2/eventfd.2:128
#, no-wrap
msgid "B<write>(2)"
msgstr "B<write>(2)"

#. type: Plain text
#: man-pages/man2/eventfd.2:145
msgid ""
"A B<write>(2)  call adds the 8-byte integer value supplied in its buffer to "
"the counter.  The maximum value that may be stored in the counter is the "
"largest unsigned 64-bit value minus 1 (i.e., 0xfffffffffffffffe).  If the "
"addition would cause the counter's value to exceed the maximum, then the "
"B<write>(2)  either blocks until a B<read>(2)  is performed on the file "
"descriptor, or fails with the error B<EAGAIN> if the file descriptor has "
"been made nonblocking."
msgstr ""
"При вызове B<write>(2) из его буфера к счётчику добавляется 8-байтовое целое "
"значение. Максимальное значение, которое может храниться в счётчике, равно "
"наибольшему 64-битному беззнаковому значению минус 1 (т.е., "
"0xfffffffffffffffe). Если при добавлении значение счётчика превысит "
"максимум, то B<write>(2) заблокируется до тех пор, пока для файлового "
"дескриптора не будет выполнен вызов B<read>(2), или завершится с ошибкой "
"B<EAGAIN>, если файловый дескриптор создан неблокируемым."

#. type: Plain text
#: man-pages/man2/eventfd.2:152
msgid ""
"A B<write>(2)  fails with the error B<EINVAL> if the size of the supplied "
"buffer is less than 8 bytes, or if an attempt is made to write the value "
"0xffffffffffffffff."
msgstr ""
"Вызов B<write>(2) завершается с ошибкой B<EINVAL>, если размер указанного "
"буфера меньше 8 байт, или если попытаться записать значение "
"0xffffffffffffffff."

#. type: TP
#: man-pages/man2/eventfd.2:152
#, no-wrap
msgid "B<poll>(2), B<select>(2) (and similar)"
msgstr "B<poll>(2), B<select>(2) (и подобные)"

#. type: Plain text
#: man-pages/man2/eventfd.2:161
msgid ""
"The returned file descriptor supports B<poll>(2)  (and analogously "
"B<epoll>(7))  and B<select>(2), as follows:"
msgstr ""
"Возвращённый файловый дескриптор поддерживает B<poll>(2) (и, аналогично, "
"B<epoll>(7)) и B<select>(2) следующим образом:"

#. type: Plain text
#: man-pages/man2/eventfd.2:172
msgid ""
"The file descriptor is readable (the B<select>(2)  I<readfds> argument; the "
"B<poll>(2)  B<POLLIN> flag)  if the counter has a value greater than 0."
msgstr ""
"Файловый дескриптор доступен для чтения (в B<select>(2) аргумент I<readfds>; "
"в B<poll>(2) флаг B<POLLIN>), если счётчик больше 0."

#. type: Plain text
#: man-pages/man2/eventfd.2:182
msgid ""
"The file descriptor is writable (the B<select>(2)  I<writefds> argument; the "
"B<poll>(2)  B<POLLOUT> flag)  if it is possible to write a value of at least "
"\"1\" without blocking."
msgstr ""
"Файловый дескриптор доступен для записи (в B<select>(2) аргумент "
"I<writefds>; в B<poll>(2) флаг B<POLLOUT>), если можно записать значение "
"равное, как минимум, \"1\" без блокировки."

#. type: Plain text
#: man-pages/man2/eventfd.2:202
msgid ""
"If an overflow of the counter value was detected, then B<select>(2)  "
"indicates the file descriptor as being both readable and writable, and "
"B<poll>(2)  returns a B<POLLERR> event.  As noted above, B<write>(2)  can "
"never overflow the counter.  However an overflow can occur if 2^64 eventfd "
"\"signal posts\" were performed by the KAIO subsystem (theoretically "
"possible, but practically unlikely).  If an overflow has occurred, then "
"B<read>(2)  will return that maximum I<uint64_t> value (i.e., "
"0xffffffffffffffff)."
msgstr ""
"Если обнаружено переполнение счётчика, то B<select>(2) указывает на файловый "
"дескриптор, доступный на чтение и запись, и B<poll>(2) возвращает событие "
"B<POLLERR>. Как упоминалось ранее, B<write>(2) никогда не может вызвать "
"переполнение счётчика. Однако переполнение может произойти, если подсистемой "
"KAIO выполнится (возможно теоретически) 2^64 \"передач сигналов\" eventfd. "
"Если переполнение произошло, то B<read>(2) вернёт максимальное значение типа "
"I<uint64_t> (т.е., 0xffffffffffffffff)."

#. type: Plain text
#: man-pages/man2/eventfd.2:209
msgid ""
"The eventfd file descriptor also supports the other file-descriptor "
"multiplexing APIs: B<pselect>(2)  and B<ppoll>(2)."
msgstr ""
"Файловый дескриптор eventfd также поддерживает другие мультиплексные "
"программные интерфейсы: B<pselect>(2) и B<ppoll>(2)."

#. type: TP
#: man-pages/man2/eventfd.2:209
#, no-wrap
msgid "B<close>(2)"
msgstr "B<close>(2)"

#. type: Plain text
#: man-pages/man2/eventfd.2:214
msgid ""
"When the file descriptor is no longer required it should be closed.  When "
"all file descriptors associated with the same eventfd object have been "
"closed, the resources for object are freed by the kernel."
msgstr ""
"Если файловый дескриптор больше не требуется, его нужно закрыть. Когда все "
"файловые дескрипторы, связанные с одним объектом eventfd, будут закрыты, "
"ядро освобождает ресурсы объекта."

#. type: Plain text
#: man-pages/man2/eventfd.2:226
msgid ""
"A copy of the file descriptor created by B<eventfd>()  is inherited by the "
"child produced by B<fork>(2).  The duplicate file descriptor is associated "
"with the same eventfd object.  File descriptors created by B<eventfd>()  are "
"preserved across B<execve>(2), unless the close-on-exec flag has been set."
msgstr ""
"Копия файлового дескриптора, созданного B<eventfd>(), наследуется потомком, "
"созданным с помощью B<fork>(2). Копия файлового дескриптора связывается с "
"тем же объектом eventfd. Файловые дескрипторы, созданные B<eventfd>(), "
"сохраняются при вызове B<execve>(2), если не указан флаг close-on-exec."

#. type: SH
#: man-pages/man2/eventfd.2:226
#, no-wrap
msgid "RETURN VALUE"
msgstr "ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ"

#. type: Plain text
#: man-pages/man2/eventfd.2:233
msgid ""
"On success, B<eventfd>()  returns a new eventfd file descriptor.  On error, "
"-1 is returned and I<errno> is set to indicate the error."
msgstr ""
"При успешном выполнении B<eventfd>() возвращает новый файловый дескриптор "
"eventfd. При ошибке возвращается -1, и I<errno> устанавливается в "
"соответствующее значение."

#. type: SH
#: man-pages/man2/eventfd.2:233
#, no-wrap
msgid "ERRORS"
msgstr "ОШИБКИ"

#. type: TP
#: man-pages/man2/eventfd.2:234
#, no-wrap
msgid "B<EINVAL>"
msgstr "B<EINVAL>"

#. type: Plain text
#: man-pages/man2/eventfd.2:238
msgid "An unsupported value was specified in I<flags>."
msgstr "В I<flags> указано неподдерживаемое значение."

#. type: TP
#: man-pages/man2/eventfd.2:238
#, no-wrap
msgid "B<EMFILE>"
msgstr "B<EMFILE>"

#. type: Plain text
#: man-pages/man2/eventfd.2:241
msgid ""
"The per-process limit on the number of open file descriptors has been "
"reached."
msgstr ""
"Было достигнуто ограничение по количеству открытых файловых дескрипторов на "
"процесс."

#. type: TP
#: man-pages/man2/eventfd.2:241
#, no-wrap
msgid "B<ENFILE>"
msgstr "B<ENFILE>"

#. type: Plain text
#: man-pages/man2/eventfd.2:245
msgid ""
"The system-wide limit on the total number of open files has been reached."
msgstr "Достигнуто максимальное количество открытых файлов в системе."

#. type: TP
#: man-pages/man2/eventfd.2:245
#, no-wrap
msgid "B<ENODEV>"
msgstr "B<ENODEV>"

#.  Note from Davide:
#.  The ENODEV error is basically never going to happen if
#.  the kernel boots correctly. That error happen only if during
#.  the kernel initialization, some error occur in the anonymous
#.  inode source initialization.
#. type: Plain text
#: man-pages/man2/eventfd.2:253
msgid "Could not mount (internal) anonymous inode device."
msgstr "Не удалось смонтировать (внутреннее) безымянное устройство inode."

#. type: TP
#: man-pages/man2/eventfd.2:253
#, no-wrap
msgid "B<ENOMEM>"
msgstr "B<ENOMEM>"

#. type: Plain text
#: man-pages/man2/eventfd.2:257
msgid "There was insufficient memory to create a new eventfd file descriptor."
msgstr "Недостаточно памяти для создания нового файлового дескриптора eventfd."

#.  eventfd() is in glibc 2.7, but reportedly does not build
#. type: Plain text
#: man-pages/man2/eventfd.2:270
msgid ""
"B<eventfd>()  is available on Linux since kernel 2.6.22.  Working support is "
"provided in glibc since version 2.8.  The B<eventfd2>()  system call (see "
"NOTES) is available on Linux since kernel 2.6.27.  Since version 2.9, the "
"glibc B<eventfd>()  wrapper will employ the B<eventfd2>()  system call, if "
"it is supported by the kernel."
msgstr ""
"Вызов B<eventfd>() доступен в Linux начиная с ядра 2.6.22. Поддержка в glibc "
"появилась в версии 2.8. Системный вызов B<eventfd2>() (см. ЗАМЕЧАНИЯ) "
"доступен в Linux начиная с ядра 2.6.27. В glibc версии 2.9 в обёртке "
"B<eventfd>() используется системный вызов B<eventfd2>(), если он "
"поддерживается ядром."

#. type: SH
#: man-pages/man2/eventfd.2:270
#, no-wrap
msgid "ATTRIBUTES"
msgstr "АТРИБУТЫ"

#. type: Plain text
#: man-pages/man2/eventfd.2:273
msgid ""
"For an explanation of the terms used in this section, see B<attributes>(7)."
msgstr "Описание терминов данного раздела смотрите в B<attributes>(7)."

#. type: tbl table
#: man-pages/man2/eventfd.2:277
#, no-wrap
msgid "Interface"
msgstr "Интерфейс"

#. type: tbl table
#: man-pages/man2/eventfd.2:277
#, no-wrap
msgid "Attribute"
msgstr "Атрибут"

#. type: tbl table
#: man-pages/man2/eventfd.2:277
#, no-wrap
msgid "Value"
msgstr "Значение"

#. type: tbl table
#: man-pages/man2/eventfd.2:280
#, no-wrap
msgid "B<eventfd>()"
msgstr "B<eventfd>()"

#. type: tbl table
#: man-pages/man2/eventfd.2:280
#, no-wrap
msgid "Thread safety"
msgstr "Безвредность в нитях"

#. type: tbl table
#: man-pages/man2/eventfd.2:280
#, no-wrap
msgid "MT-Safe"
msgstr "MT-Safe"

#. type: Plain text
#: man-pages/man2/eventfd.2:288
msgid "B<eventfd>()  and B<eventfd2>()  are Linux-specific."
msgstr "Вызовы B<eventfd>() и B<eventfd2>() есть только в Linux."

#. type: Plain text
#: man-pages/man2/eventfd.2:296
msgid ""
"Applications can use an eventfd file descriptor instead of a pipe (see "
"B<pipe>(2))  in all cases where a pipe is used simply to signal events.  The "
"kernel overhead of an eventfd file descriptor is much lower than that of a "
"pipe, and only one file descriptor is required (versus the two required for "
"a pipe)."
msgstr ""
"Приложения могут использовать файловый дескриптор eventfd вместо канала (см. "
"B<pipe>(2)) во всех случаях, когда канал используется только для "
"сигнализации о событиях. Издержки ядра по файловому дескриптору eventfd "
"намного меньше, чем по каналу и требуется только один файловый дескриптор "
"(против двух, при использовании канала)."

#.  or eventually syslets/threadlets
#. type: Plain text
#: man-pages/man2/eventfd.2:302
msgid ""
"When used in the kernel, an eventfd file descriptor can provide a bridge "
"from kernel to user space, allowing, for example, functionalities like KAIO "
"(kernel AIO)  to signal to a file descriptor that some operation is complete."
msgstr ""
"При использовании в ядре файловый дескриптор eventfd может предоставлять "
"мост из ядерного в пользовательское пространство, позволяя например "
"работать, подобно KAIO ( ядерный AIO), сигнализируя, что завершена какая-то "
"операция над файловым дескриптором."

#. type: Plain text
#: man-pages/man2/eventfd.2:319
msgid ""
"A key point about an eventfd file descriptor is that it can be monitored "
"just like any other file descriptor using B<select>(2), B<poll>(2), or "
"B<epoll>(7).  This means that an application can simultaneously monitor the "
"readiness of \"traditional\" files and the readiness of other kernel "
"mechanisms that support the eventfd interface.  (Without the B<eventfd>()  "
"interface, these mechanisms could not be multiplexed via B<select>(2), "
"B<poll>(2), or B<epoll>(7).)"
msgstr ""
"Важным моментом файлового дескриптора eventfd является то, что за ним можно "
"следить как за обычным файловым дескриптором с помощью B<select>(2), "
"B<poll>(2) или B<epoll>(7). Это означает, что приложение может одновременно "
"отслеживать готовность \"обычных\" файлов и готовность других механизмов "
"ядра, которые поддерживают интерфейс eventfd. (Без интерфейса B<eventfd>() "
"эти механизмы невозможно мультиплексировать через B<select>(2), B<poll>(2) "
"или B<epoll>(7).)"

#. type: Plain text
#: man-pages/man2/eventfd.2:328
msgid ""
"The current value of an eventfd counter can be viewed via the entry for the "
"corresponding file descriptor in the process's I</proc/[pid]/fdinfo> "
"directory.  See B<proc>(5)  for further details."
msgstr ""
"Текущее значение счётчика eventfd можно найти в записи для соответствующего "
"файлового дескриптора в каталоге процесса I</proc/[pid]/fdinfo>. Подробности "
"смотрите в B<proc>(5)."

#. type: SS
#: man-pages/man2/eventfd.2:328
#, no-wrap
msgid "C library/kernel differences"
msgstr "Отличия между библиотекой C и ядром"

#. type: Plain text
#: man-pages/man2/eventfd.2:342
msgid ""
"There are two underlying Linux system calls: B<eventfd>()  and the more "
"recent B<eventfd2>().  The former system call does not implement a I<flags> "
"argument.  The latter system call implements the I<flags> values described "
"above.  The glibc wrapper function will use B<eventfd2>()  where it is "
"available."
msgstr ""
"Основу составляют два системных вызова Linux: B<eventfd>() и более новый "
"B<eventfd2>(). В первом системном вызове не реализован аргумент I<flags>. "
"Последний системный вызов использует значения I<flags>, которые были описаны "
"ранее. Обёрточная функция glibc использует B<eventfd2>(), если он доступен."

#. type: SS
#: man-pages/man2/eventfd.2:342
#, no-wrap
msgid "Additional glibc features"
msgstr "Дополнительные возможности glibc"

#. type: Plain text
#: man-pages/man2/eventfd.2:346
msgid ""
"The GNU C library defines an additional type, and two functions that attempt "
"to abstract some of the details of reading and writing on an eventfd file "
"descriptor:"
msgstr ""
"В библиотеке GNU C определён дополнительный тип и две функции, которые "
"пытаются устранить сложности чтения и записи из файлового дескриптора "
"eventfd:"

#. type: Plain text
#: man-pages/man2/eventfd.2:350
#, no-wrap
msgid "typedef uint64_t eventfd_t;\n"
msgstr "typedef uint64_t eventfd_t;\n"

#. type: Plain text
#: man-pages/man2/eventfd.2:353
#, no-wrap
msgid ""
"int eventfd_read(int fd, eventfd_t *value);\n"
"int eventfd_write(int fd, eventfd_t value);\n"
msgstr ""
"int eventfd_read(int fd, eventfd_t *value);\n"
"int eventfd_write(int fd, eventfd_t value);\n"

#. type: Plain text
#: man-pages/man2/eventfd.2:360
msgid ""
"The functions perform the read and write operations on an eventfd file "
"descriptor, returning 0 if the correct number of bytes was transferred, or "
"-1 otherwise."
msgstr ""
"Функции выполняют операции чтения и записи из файлового дескриптора eventfd, "
"и возвращают 0, если передано правильное количество байт и -1 в противном "
"случае."

#. type: SH
#: man-pages/man2/eventfd.2:360
#, no-wrap
msgid "EXAMPLE"
msgstr "ПРИМЕР"

#. type: Plain text
#: man-pages/man2/eventfd.2:369
msgid ""
"The following program creates an eventfd file descriptor and then forks to "
"create a child process.  While the parent briefly sleeps, the child writes "
"each of the integers supplied in the program's command-line arguments to the "
"eventfd file descriptor.  When the parent has finished sleeping, it reads "
"from the eventfd file descriptor."
msgstr ""
"Следующая программа создаёт файловый дескриптор eventfd и затем создаёт "
"дочерний процесс. Пока родительский процесс на короткое время засыпает, "
"потомок пишет все числа, переданные в командной строке программы, в файловый "
"дескриптор eventfd. Когда родитель просыпается, он читает их из файлового "
"дескриптора eventfd."

#. type: Plain text
#: man-pages/man2/eventfd.2:371
msgid "The following shell session shows a sample run of the program:"
msgstr "Пример сеанса работы с программой:"

#. type: Plain text
#: man-pages/man2/eventfd.2:383
#, no-wrap
msgid ""
"$B< ./a.out 1 2 4 7 14>\n"
"Child writing 1 to efd\n"
"Child writing 2 to efd\n"
"Child writing 4 to efd\n"
"Child writing 7 to efd\n"
"Child writing 14 to efd\n"
"Child completed write loop\n"
"Parent about to read\n"
"Parent read 28 (0x1c) from efd\n"
msgstr ""
"$B< ./a.out 1 2 4 7 14>\n"
"Child writing 1 to efd\n"
"Child writing 2 to efd\n"
"Child writing 4 to efd\n"
"Child writing 7 to efd\n"
"Child writing 14 to efd\n"
"Child completed write loop\n"
"Parent about to read\n"
"Parent read 28 (0x1c) from efd\n"

#. type: SS
#: man-pages/man2/eventfd.2:385
#, no-wrap
msgid "Program source"
msgstr "Исходный код программы"

#. type: Plain text
#: man-pages/man2/eventfd.2:393
#, no-wrap
msgid ""
"#include E<lt>sys/eventfd.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdint.hE<gt>             /* Definition of uint64_t */\n"
msgstr ""
"#include E<lt>sys/eventfd.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdint.hE<gt>             /* определение uint64_t */\n"

#. type: Plain text
#: man-pages/man2/eventfd.2:396
#, no-wrap
msgid ""
"#define handle_error(msg) \\e\n"
"    do { perror(msg); exit(EXIT_FAILURE); } while (0)\n"
msgstr ""
"#define handle_error(msg) \\e\n"
"    do { perror(msg); exit(EXIT_FAILURE); } while (0)\n"

#. type: Plain text
#: man-pages/man2/eventfd.2:403
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int efd, j;\n"
"    uint64_t u;\n"
"    ssize_t s;\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int efd, j;\n"
"    uint64_t u;\n"
"    ssize_t s;\n"

#. type: Plain text
#: man-pages/man2/eventfd.2:408
#, no-wrap
msgid ""
"    if (argc E<lt> 2) {\n"
"        fprintf(stderr, \"Usage: %s E<lt>numE<gt>...\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    if (argc E<lt> 2) {\n"
"        fprintf(stderr, \"Использование: %s E<lt>numE<gt>...\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: man-pages/man2/eventfd.2:412
#, no-wrap
msgid ""
"    efd = eventfd(0, 0);\n"
"    if (efd == -1)\n"
"        handle_error(\"eventfd\");\n"
msgstr ""
"    efd = eventfd(0, 0);\n"
"    if (efd == -1)\n"
"        handle_error(\"eventfd\");\n"

#. type: Plain text
#: man-pages/man2/eventfd.2:424
#, no-wrap
msgid ""
"    switch (fork()) {\n"
"    case 0:\n"
"        for (j = 1; j E<lt> argc; j++) {\n"
"            printf(\"Child writing %s to efd\\en\", argv[j]);\n"
"            u = strtoull(argv[j], NULL, 0);\n"
"                    /* strtoull() allows various bases */\n"
"            s = write(efd, &u, sizeof(uint64_t));\n"
"            if (s != sizeof(uint64_t))\n"
"                handle_error(\"write\");\n"
"        }\n"
"        printf(\"Child completed write loop\\en\");\n"
msgstr ""
"    switch (fork()) {\n"
"    case 0:\n"
"        for (j = 1; j E<lt> argc; j++) {\n"
"            printf(\"Child writing %s to efd\\en\", argv[j]);\n"
"            u = strtoull(argv[j], NULL, 0);\n"
"                    /* в strtoull() разрешены различные основания */\n"
"            s = write(efd, &u, sizeof(uint64_t));\n"
"            if (s != sizeof(uint64_t))\n"
"                handle_error(\"write\");\n"
"        }\n"
"        printf(\"Child completed write loop\\en\");\n"

#. type: Plain text
#: man-pages/man2/eventfd.2:426
#, no-wrap
msgid "        exit(EXIT_SUCCESS);\n"
msgstr "        exit(EXIT_SUCCESS);\n"

#. type: Plain text
#: man-pages/man2/eventfd.2:429
#, no-wrap
msgid ""
"    default:\n"
"        sleep(2);\n"
msgstr ""
"    default:\n"
"        sleep(2);\n"

#. type: Plain text
#: man-pages/man2/eventfd.2:437
#, no-wrap
msgid ""
"        printf(\"Parent about to read\\en\");\n"
"        s = read(efd, &u, sizeof(uint64_t));\n"
"        if (s != sizeof(uint64_t))\n"
"            handle_error(\"read\");\n"
"        printf(\"Parent read %llu (0x%llx) from efd\\en\",\n"
"                (unsigned long long) u, (unsigned long long) u);\n"
"        exit(EXIT_SUCCESS);\n"
msgstr ""
"        printf(\"Parent about to read\\en\");\n"
"        s = read(efd, &u, sizeof(uint64_t));\n"
"        if (s != sizeof(uint64_t))\n"
"            handle_error(\"read\");\n"
"        printf(\"Parent read %llu (0x%llx) from efd\\en\",\n"
"                (unsigned long long) u, (unsigned long long) u);\n"
"        exit(EXIT_SUCCESS);\n"

#. type: Plain text
#: man-pages/man2/eventfd.2:442
#, no-wrap
msgid ""
"    case -1:\n"
"        handle_error(\"fork\");\n"
"    }\n"
"}\n"
msgstr ""
"    case -1:\n"
"        handle_error(\"fork\");\n"
"    }\n"
"}\n"

#. type: Plain text
#: man-pages/man2/eventfd.2:453
msgid ""
"B<futex>(2), B<pipe>(2), B<poll>(2), B<read>(2), B<select>(2), "
"B<signalfd>(2), B<timerfd_create>(2), B<write>(2), B<epoll>(7), "
"B<sem_overview>(7)"
msgstr ""
"B<futex>(2), B<pipe>(2), B<poll>(2), B<read>(2), B<select>(2), "
"B<signalfd>(2), B<timerfd_create>(2), B<write>(2), B<epoll>(7), "
"B<sem_overview>(7)"

#. type: TH
#: man-pages/man2/execveat.2:26
#, no-wrap
msgid "EXECVEAT"
msgstr "EXECVEAT"

#. type: Plain text
#: man-pages/man2/execveat.2:29
msgid "execveat - execute program relative to a directory file descriptor"
msgstr ""
"execveat - выполняет программу, определяемую относительно файлового "
"дескриптора каталога"

#. type: Plain text
#: man-pages/man2/execveat.2:31
msgid "B<#include E<lt>unistd.hE<gt>>"
msgstr "B<#include E<lt>unistd.hE<gt>>"

#. type: Plain text
#: man-pages/man2/execveat.2:33
msgid "B<int execveat(int >I<dirfd>B<, const char *>I<pathname>B<,>"
msgstr "B<int execveat(int >I<dirfd>B<, const char *>I<pathname>B<,>"

#. type: Plain text
#: man-pages/man2/execveat.2:35
msgid "B< char *const >I<argv>B<[], char *const >I<envp>B<[],>"
msgstr "B< char *const >I<argv>B<[], char *const >I<envp>B<[],>"

#. type: Plain text
#: man-pages/man2/execveat.2:37
msgid "B< int >I<flags>B<);>"
msgstr "B< int >I<flags>B<);>"

#.  commit 51f39a1f0cea1cacf8c787f652f26dfee9611874
#. type: Plain text
#: man-pages/man2/execveat.2:48
msgid ""
"The B<execveat>()  system call executes the program referred to by the "
"combination of I<dirfd> and I<pathname>.  It operates in exactly the same "
"way as B<execve>(2), except for the differences described in this manual "
"page."
msgstr ""
"Системный вызов B<execveat>() выполняет программу, на которую ссылается "
"комбинация I<dirfd> и I<pathname>. Он работает также как системный вызов "
"B<execve>(2), за исключением случаев, описанных в данной справочной странице."

#. type: Plain text
#: man-pages/man2/execveat.2:58
msgid ""
"If the pathname given in I<pathname> is relative, then it is interpreted "
"relative to the directory referred to by the file descriptor I<dirfd> "
"(rather than relative to the current working directory of the calling "
"process, as is done by B<execve>(2)  for a relative pathname)."
msgstr ""
"Если в I<pathname> задан относительный путь, то он считается относительно "
"каталога, на который ссылается файловый дескриптор I<dirfd> (а не "
"относительно текущего рабочего каталога вызывающего процесса, как это "
"делается в B<execve>(2))."

#. type: Plain text
#: man-pages/man2/execveat.2:70
msgid ""
"If I<pathname> is relative and I<dirfd> is the special value B<AT_FDCWD>, "
"then I<pathname> is interpreted relative to the current working directory of "
"the calling process (like B<execve>(2))."
msgstr ""
"Если в I<pathname> задан относительный путь и I<dirfd> равно специальному "
"значению B<AT_FDCWD>, то I<pathname> рассматривается относительно текущего "
"рабочего каталога вызывающего процесса (как B<execve>(2))."

#. type: Plain text
#: man-pages/man2/execveat.2:76
msgid "If I<pathname> is absolute, then I<dirfd> is ignored."
msgstr "Если в I<pathname> задан абсолютный путь, то I<dirfd> игнорируется."

#. type: Plain text
#: man-pages/man2/execveat.2:86
msgid ""
"If I<pathname> is an empty string and the B<AT_EMPTY_PATH> flag is "
"specified, then the file descriptor I<dirfd> specifies the file to be "
"executed (i.e., I<dirfd> refers to an executable file, rather than a "
"directory)."
msgstr ""
"Если I<pathname> — пустая строка и указан флаг B<AT_EMPTY_PATH>, то файловым "
"дескриптором I<dirfd> задаётся выполняемый файл (т. е., I<dirfd> ссылается "
"на исполняемый файл, а не на каталог)."

#. type: Plain text
#: man-pages/man2/execveat.2:90
msgid ""
"The I<flags> argument is a bit mask that can include zero or more of the "
"following flags:"
msgstr ""
"Аргумент I<flags> является битовой маской, которая может включать ноль или "
"более следующих флагов:"

#. type: TP
#: man-pages/man2/execveat.2:90
#, no-wrap
msgid "B<AT_EMPTY_PATH>"
msgstr "B<AT_EMPTY_PATH>"

#. type: Plain text
#: man-pages/man2/execveat.2:100
msgid ""
"If I<pathname> is an empty string, operate on the file referred to by "
"I<dirfd> (which may have been obtained using the B<open>(2)  B<O_PATH> flag)."
msgstr ""
"Если значение I<pathname> равно пустой строке, то вызов выполняет действие с "
"файлом, на который ссылается I<dirfd> (может быть получен с помощью "
"B<open>(2) с флагом B<O_PATH>)."

#. type: TP
#: man-pages/man2/execveat.2:100
#, no-wrap
msgid "B<AT_SYMLINK_NOFOLLOW>"
msgstr "B<AT_SYMLINK_NOFOLLOW>"

#. type: Plain text
#: man-pages/man2/execveat.2:108
msgid ""
"If the file identified by I<dirfd> and a non-NULL I<pathname> is a symbolic "
"link, then the call fails with the error B<ELOOP>."
msgstr ""
"Если файл задаётся I<dirfd> и I<pathname> — символическая ссылка (не NULL), "
"то вызов завершается с ошибкой B<ELOOP>."

#. type: Plain text
#: man-pages/man2/execveat.2:115
msgid ""
"On success, B<execveat>()  does not return.  On error, -1 is returned, and "
"I<errno> is set appropriately."
msgstr ""
"При успешном выполнении B<execveat>() не возвращает управление. В случае "
"ошибки возвращается -1, а I<errno> устанавливается в соответствующее "
"значение."

#. type: Plain text
#: man-pages/man2/execveat.2:122
msgid ""
"The same errors that occur for B<execve>(2)  can also occur for "
"B<execveat>().  The following additional errors can occur for B<execveat>():"
msgstr ""
"В B<execveat>() могут возникнуть те же ошибки, что и в B<execve>(). Также, в "
"B<execveat>() могут возникнуть следующие ошибки:"

#. type: TP
#: man-pages/man2/execveat.2:122
#, no-wrap
msgid "B<EBADF>"
msgstr "B<EBADF>"

#. type: Plain text
#: man-pages/man2/execveat.2:126
msgid "I<dirfd> is not a valid file descriptor."
msgstr "I<dirfd> не является правильным файловым дескриптором."

#. type: Plain text
#: man-pages/man2/execveat.2:130
msgid "Invalid flag specified in I<flags>."
msgstr "Указано неверное значение в I<flags>."

#. type: TP
#: man-pages/man2/execveat.2:130
#, no-wrap
msgid "B<ELOOP>"
msgstr "B<ELOOP>"

#. type: Plain text
#: man-pages/man2/execveat.2:140
msgid ""
"I<flags> includes B<AT_SYMLINK_NOFOLLOW> and the file identified by I<dirfd> "
"and a non-NULL I<pathname> is a symbolic link."
msgstr ""
"Значение I<flags> содержит B<AT_SYMLINK_NOFOLLOW> и файл задаётся I<dirfd>, "
"а I<pathname> — символическая ссылка (не NULL)."

#. type: TP
#: man-pages/man2/execveat.2:140
#, no-wrap
msgid "B<ENOENT>"
msgstr "B<ENOENT>"

#. type: Plain text
#: man-pages/man2/execveat.2:154
msgid ""
"The program identified by I<dirfd> and I<pathname> requires the use of an "
"interpreter program (such as a script starting with \"#!\"), but the file "
"descriptor I<dirfd> was opened with the B<O_CLOEXEC> flag, with the result "
"that the program file is inaccessible to the launched interpreter.  See BUGS."
msgstr ""
"Программа задаётся I<dirfd> и по I<pathname> требуется использовать "
"интерпретирующую программу (то есть сценарий, начинающийся с «#!»), но "
"файловый дескриптор I<dirfd> открыт с флагом B<O_CLOEXEC>, что приводит к "
"недоступности файла программы запускаемому интерпретатору. Смотрите ДЕФЕКТЫ."

#. type: TP
#: man-pages/man2/execveat.2:154
#, no-wrap
msgid "B<ENOTDIR>"
msgstr "B<ENOTDIR>"

#. type: Plain text
#: man-pages/man2/execveat.2:160
msgid ""
"I<pathname> is relative and I<dirfd> is a file descriptor referring to a "
"file other than a directory."
msgstr ""
"Значение I<pathname> содержит относительный путь и I<dirfd> содержит "
"файловый дескриптор, указывающий на файл, а не на каталог."

#.  FIXME . check for glibc support in a future release
#. type: Plain text
#: man-pages/man2/execveat.2:165
msgid ""
"B<execveat>()  was added to Linux in kernel 3.19.  GNU C library support is "
"pending."
msgstr ""
"Вызов B<execveat>() был добавлен в ядро Linux версии 3.19; поддержки в "
"библиотеке GNU C пока нет."

#. type: Plain text
#: man-pages/man2/execveat.2:169
msgid "The B<execveat>()  system call is Linux-specific."
msgstr "Системный вызов B<execveat>() есть только в Linux."

#. type: Plain text
#: man-pages/man2/execveat.2:179
msgid ""
"In addition to the reasons explained in B<openat>(2), the B<execveat>()  "
"system call is also needed to allow B<fexecve>(3)  to be implemented on "
"systems that do not have the I</proc> filesystem mounted."
msgstr ""
"В дополнении к причинам, описанным в B<openat>(2), системному вызову "
"B<execveat>() также требуется разрешить B<fexecve>(3) для реализации в "
"системах, у которых не смонтированной файловой системы I</proc>."

#. type: Plain text
#: man-pages/man2/execveat.2:202
msgid ""
"When asked to execute a script file, the I<argv[0]> that is passed to the "
"script interpreter is a string of the form I</dev/fd/N> or I</dev/fd/N/P>, "
"where I<N> is the number of the file descriptor passed via the I<dirfd> "
"argument.  A string of the first form occurs when B<AT_EMPTY_PATH> is "
"employed.  A string of the second form occurs when the script is specified "
"via both I<dirfd> and I<pathname>; in this case, I<P> is the value given in "
"I<pathname>."
msgstr ""
"При запросе запуска файла сценария, значение I<argv[0]>, передаваемое в "
"интерпретатор сценарий, является строкой в виде I</dev/fd/N> или I</dev/fd/N/"
"P>, где I<N> — номер файлового дескриптора, передаваемого через аргумент "
"I<dirfd>. Строка в первом формате встречается, когда указан "
"B<AT_EMPTY_PATH>. Строка во втором формате встречается, когда сценарий "
"задаётся сразу через I<dirfd> и I<pathname>; в этом случае I<P> — это "
"значение, указанное в I<pathname>."

#. type: Plain text
#: man-pages/man2/execveat.2:210
msgid ""
"For the same reasons described in B<fexecve>(3), the natural idiom when "
"using B<execveat>()  is to set the close-on-exec flag on I<dirfd>.  (But see "
"BUGS.)"
msgstr ""
"По причинам, описанным в B<fexecve>(3), естественным подходом является "
"использование B<execveat>() с установленным флагом close-on-exec у I<dirfd> "
"(но смотрите ДЕФЕКТЫ)."

#. type: Plain text
#: man-pages/man2/execveat.2:215
msgid ""
"The B<ENOENT> error described above means that it is not possible to set the "
"close-on-exec flag on the file descriptor given to a call of the form:"
msgstr ""
"Ошибка B<ENOENT>, описанная выше, означает, что невозможно установить флаг "
"close-on-exec у файлового дескриптора, переданного вызову в виде:"

#. type: Plain text
#: man-pages/man2/execveat.2:217
#, no-wrap
msgid "    execveat(fd, \"\", argv, envp, AT_EMPTY_PATH);\n"
msgstr "    execveat(fd, \"\", argv, envp, AT_EMPTY_PATH);\n"

#.  For an example, see Michael Kerrisk's 2015-01-10 reply in this LKML
#.  thread (http://thread.gmane.org/gmane.linux.kernel/1836105/focus=20229):
#.      Subject: [PATCHv10 man-pages 5/5] execveat.2: initial man page.\"                        for execveat(2
#.      Date: Mon, 24 Nov 2014 11:53:59 +0000
#. type: Plain text
#: man-pages/man2/execveat.2:229
msgid ""
"However, the inability to set the close-on-exec flag means that a file "
"descriptor referring to the script leaks through to the script itself.  As "
"well as wasting a file descriptor, this leakage can lead to file-descriptor "
"exhaustion in scenarios where scripts recursively employ B<execveat>()."
msgstr ""
"Однако неспособность установить флаг close-on-exec означает утечку файловых "
"дескрипторов, через ссылку сценария на самого себя. Помимо траты файлового "
"дескриптора, это может привести к исчерпанию файловых дескрипторов, если "
"сценарии рекурсивно вызывают B<execveat>()."

#. type: Plain text
#: man-pages/man2/execveat.2:232
msgid "B<execve>(2), B<openat>(2), B<fexecve>(3)"
msgstr "B<execve>(2), B<openat>(2), B<fexecve>(3)"

#. type: TH
#: man-pages/man2/execve.2:37
#, no-wrap
msgid "EXECVE"
msgstr "EXECVE"

#. type: TH
#: man-pages/man2/execve.2:37
#, no-wrap
msgid "2019-05-09"
msgstr "2019-05-09"

#. type: Plain text
#: man-pages/man2/execve.2:40
msgid "execve - execute program"
msgstr "execve - выполнить программу"

#. type: Plain text
#: man-pages/man2/execve.2:44
msgid "B<int execve(const char *>I<pathname>B<, char *const >I<argv>B<[], >"
msgstr "B<int execve(const char *>I<pathname>B<, char *const >I<argv>B<[], >"

#. type: Plain text
#: man-pages/man2/execve.2:46
msgid "B< char *const >I<envp>B<[]);>"
msgstr "B< char *const >I<envp>B<[]);>"

#. type: Plain text
#: man-pages/man2/execve.2:52
msgid ""
"B<execve>()  executes the program referred to by I<pathname>.  This causes "
"the program that is currently being run by the calling process to be "
"replaced with a new program, with newly initialized stack, heap, and "
"(initialized and uninitialized) data segments."
msgstr ""
"Вызов B<execve> выполняет программу, задаваемую I<pathname>. При этом "
"программа, выполняющаяся вызвавшим процессом, замещается новой программой, "
"заново инициализируется стек, куча и сегменты данных (инициализированные и "
"не инициализированные)."

#. type: Plain text
#: man-pages/man2/execve.2:55
msgid ""
"I<pathname> must be either a binary executable, or a script starting with a "
"line of the form:"
msgstr ""
"В I<pathname> должно быть указано имя двоичного исполняемого файла или "
"сценарий, начинающийся со строки вида:"

#. type: Plain text
#: man-pages/man2/execve.2:59 man-pages/man2/execve.2:305
#, no-wrap
msgid "B<#!>I<interpreter >[optional-arg]\n"
msgstr "B<#!>I<интерпретатор >[необязательный параметр]\n"

#. type: Plain text
#: man-pages/man2/execve.2:63
msgid "For details of the latter case, see \"Interpreter scripts\" below."
msgstr "Подробней о сценариях написано далее в «Интерпретируемые сценарии»."

#. type: Plain text
#: man-pages/man2/execve.2:72
msgid ""
"I<argv> is an array of argument strings passed to the new program.  By "
"convention, the first of these strings (i.e., I<argv[0]>)  should contain "
"the filename associated with the file being executed.  I<envp> is an array "
"of strings, conventionally of the form B<key=value>, which are passed as "
"environment to the new program.  The I<argv> and I<envp> arrays must each "
"include a null pointer at the end of the array."
msgstr ""
"I<argv> — это массив строковых параметров, передаваемых новой программе. По "
"соглашению, в первой строке (т. е., I<argv[0]>) должно содержаться имя "
"файла, относящееся к запускаемой программе. I<envp> — это массив строк в "
"формате B<ключ=значение>, которые передаются новой программе в качестве "
"окружения (environment). Оба массива I<argv> и I<envp> завершаются "
"указателем null."

#. type: Plain text
#: man-pages/man2/execve.2:75
msgid ""
"The argument vector and environment can be accessed by the called program's "
"main function, when it is defined as:"
msgstr ""
"К массиву параметров и окружению можно обратиться из вызываемой программой "
"главной функции, если она определена как:"

#. type: Plain text
#: man-pages/man2/execve.2:79
#, no-wrap
msgid "int main(int argc, char *argv[], char *envp[])\n"
msgstr "int main(int argc, char *argv[], char *envp[])\n"

#. type: Plain text
#: man-pages/man2/execve.2:87
msgid ""
"Note, however, that the use of a third argument to the main function is not "
"specified in POSIX.1; according to POSIX.1, the environment should be "
"accessed via the external variable B<environ>(7)."
msgstr ""
"Однако заметим, что использование третьего аргумента главной функции не "
"определено в POSIX.1; согласно POSIX.1, окружение должно быть доступно через "
"внешнюю переменную B<environ>(7)."

#. type: Plain text
#: man-pages/man2/execve.2:92
msgid ""
"B<execve>()  does not return on success, and the text, initialized data, "
"uninitialized data (bss), and stack of the calling process are overwritten "
"according to the contents of the newly loaded program."
msgstr ""
"При успешном выполнении B<execve>() управление не возвращается, а код, "
"инициализированные данные, неинициализированные данные (bss) и стек "
"вызвавшего процесса перезаписываются содержимым загруженной программы."

#. type: Plain text
#: man-pages/man2/execve.2:96
msgid ""
"If the current program is being ptraced, a B<SIGTRAP> signal is sent to it "
"after a successful B<execve>()."
msgstr ""
"Если текущая программа выполнялась под управлением ptrace, то после "
"успешного вызова B<execve>() ей посылается сигнал B<SIGTRAP>."

#. type: Plain text
#: man-pages/man2/execve.2:104
msgid ""
"If the set-user-ID bit is set on the program file referred to by "
"I<pathname>, then the effective user ID of the calling process is changed to "
"that of the owner of the program file.  Similarly, when the set-group-ID bit "
"of the program file is set the effective group ID of the calling process is "
"set to the group of the program file."
msgstr ""
"Если у файла программы, на который ссылается I<pathname>, установлен бит set-"
"user-ID, то фактический идентификатор пользователя вызывающего процесса "
"меняется на идентификатор владельца файла программы. Точно также, если на "
"файле программы установлен бит set-group-ID, то фактический идентификатор "
"группы вызывающего процесса становится равным группе, которой принадлежит "
"файл программы."

#. type: Plain text
#: man-pages/man2/execve.2:109
msgid ""
"The aforementioned transformations of the effective IDs are I<not> performed "
"(i.e., the set-user-ID and set-group-ID bits are ignored)  if any of the "
"following is true:"
msgstr ""
"Вышеупомянутые преобразования эффективных IDs I<не> выполняются (т. е., биты "
"set-user-ID и set-group-ID игнорируются), если что-либо из следующего "
"истинно:"

#. type: Plain text
#: man-pages/man2/execve.2:114
msgid ""
"the I<no_new_privs> attribute is set for the calling thread (see "
"B<prctl>(2));"
msgstr ""
"установлен атрибут I<no_new_privs> для вызывающей нити (смотрите "
"B<prctl>(2));"

#. type: Plain text
#: man-pages/man2/execve.2:122
msgid ""
"the underlying filesystem is mounted I<nosuid> (the B<MS_NOSUID> flag for "
"B<mount>(2)); or"
msgstr ""
"подлежащая файловая система смонтирована с I<nosuid> (флаг B<MS_NOSUID> для "
"B<mount>(2)); или"

#. type: Plain text
#: man-pages/man2/execve.2:124
msgid "the calling process is being ptraced."
msgstr "вызывающий процесс выполняется под контролем ptrace."

#. type: Plain text
#: man-pages/man2/execve.2:128
msgid ""
"The capabilities of the program file (see B<capabilities>(7))  are also "
"ignored if any of the above are true."
msgstr ""
"Также игнорируются мандаты файла программы (смотрите B<capabilities>(7)), "
"если что-то из вышеперечисленного истинно."

#. type: Plain text
#: man-pages/man2/execve.2:133
msgid ""
"The effective user ID of the process is copied to the saved set-user-ID; "
"similarly, the effective group ID is copied to the saved set-group-ID.  This "
"copying takes place after any effective ID changes that occur because of the "
"set-user-ID and set-group-ID mode bits."
msgstr ""
"Фактический идентификатор пользователя процесса копируется в сохранённый "
"идентификатор пользователя (set-user-ID), также фактический идентификатор "
"группы копируется в сохранённый идентификатор группы (set-group-ID). Это "
"копирование выполняется после изменения любого фактического идентификатора, "
"которое происходит из-за выставленных бит режима set-user-ID и set-group-ID."

#. type: Plain text
#: man-pages/man2/execve.2:137
msgid ""
"The process's real UID and real GID, as well its supplementary group IDs, "
"are unchanged by a call to B<execve>()."
msgstr ""
"Реальные UID и GID процесса, а также его дополнительные ID групп не "
"изменяются при вызове B<execve>()."

#. type: Plain text
#: man-pages/man2/execve.2:145
msgid ""
"If the executable is an a.out dynamically linked binary executable "
"containing shared-library stubs, the Linux dynamic linker B<ld.so>(8)  is "
"called at the start of execution to bring needed shared objects into memory "
"and link the executable with them."
msgstr ""
"Если исполняемый файл является динамически-скомпонованным файлом в формате a."
"out, содержащим заглушки для динамических библиотек, то в начале выполнения "
"этого файла вызывается динамический компоновщик Linux B<ld.so>(8), который "
"начинает выполнение с загрузки общих объектов в память и компонует их с "
"исполняемым файлом."

#. type: Plain text
#: man-pages/man2/execve.2:153
msgid ""
"If the executable is a dynamically linked ELF executable, the interpreter "
"named in the PT_INTERP segment is used to load the needed shared objects.  "
"This interpreter is typically I</lib/ld-linux.so.2> for binaries linked with "
"glibc (see B<ld-linux.so>(8))."
msgstr ""
"Если исполняемый файл является динамически компонуемым файлом в формате ELF, "
"то для загрузки необходимых общих объектов используется интерпретатор, "
"указанный в сегменте PT_INTERP. Для программ, скомпонованных с glibc, обычно "
"это I</lib/ld-linux.so.2> (смотрите B<ld-linux.so>(8))."

#. type: Plain text
#: man-pages/man2/execve.2:157
msgid ""
"All process attributes are preserved during an B<execve>(), except the "
"following:"
msgstr ""
"При вызове B<execve>() сохраняются все свойства процесса, за исключением:"

#. type: Plain text
#: man-pages/man2/execve.2:161
msgid ""
"The dispositions of any signals that are being caught are reset to the "
"default (B<signal>(7))."
msgstr ""
"Значения обработчиков всех захватываемых сигналов сбрасываются в значения по "
"умолчанию (B<signal>(7))."

#. type: Plain text
#: man-pages/man2/execve.2:164
msgid "Any alternate signal stack is not preserved (B<sigaltstack>(2))."
msgstr "Любой альтернативный стек сигнала не сохраняется (B<sigaltstack>(2))."

#. type: Plain text
#: man-pages/man2/execve.2:167
msgid "Memory mappings are not preserved (B<mmap>(2))."
msgstr "Проецирование памяти не сохраняется (B<mmap>(2))."

#. type: Plain text
#: man-pages/man2/execve.2:170
msgid "Attached System\\ V shared memory segments are detached (B<shmat>(2))."
msgstr ""
"Подключённые общие сегменты памяти System\\ V отключаются (B<shmat>(2))."

#. type: Plain text
#: man-pages/man2/execve.2:173
msgid "POSIX shared memory regions are unmapped (B<shm_open>(3))."
msgstr ""
"Области общей памяти POSIX становятся неспроецированными (B<shm_open>(3))."

#. type: Plain text
#: man-pages/man2/execve.2:176
msgid "Open POSIX message queue descriptors are closed (B<mq_overview>(7))."
msgstr ""
"Открытые дескрипторы в очереди сообщений POSIX закрываются "
"(B<mq_overview>(7))."

#. type: Plain text
#: man-pages/man2/execve.2:179
msgid "Any open POSIX named semaphores are closed (B<sem_overview>(7))."
msgstr "Все открытые именные семафоры POSIX закрываются (B<sem_overview>(7))."

#. type: Plain text
#: man-pages/man2/execve.2:182
msgid "POSIX timers are not preserved (B<timer_create>(2))."
msgstr "Таймеры POSIX не сохраняются (B<timer_create>(2))."

#. type: Plain text
#: man-pages/man2/execve.2:185
msgid "Any open directory streams are closed (B<opendir>(3))."
msgstr ""
"Все открытые потоки каталогов (directory streams) закрываются "
"(B<opendir>(3))."

#. type: Plain text
#: man-pages/man2/execve.2:189
msgid "Memory locks are not preserved (B<mlock>(2), B<mlockall>(2))."
msgstr "Блокировки памяти не сохраняются (B<mlock>(2), B<mlockall>(2))."

#. type: Plain text
#: man-pages/man2/execve.2:193
msgid "Exit handlers are not preserved (B<atexit>(3), B<on_exit>(3))."
msgstr ""
"Обработчики завершения работы (exit handlers) не сохраняются (B<atexit>(3), "
"B<on_exit>(3))."

#. type: Plain text
#: man-pages/man2/execve.2:196
msgid ""
"The floating-point environment is reset to the default (see B<fenv>(3))."
msgstr ""
"Окружения плавающей точки сбрасываются в настройки по умолчанию (B<fenv>(3))."

#. type: Plain text
#: man-pages/man2/execve.2:202
msgid ""
"The process attributes in the preceding list are all specified in POSIX.1.  "
"The following Linux-specific process attributes are also not preserved "
"during an B<execve>():"
msgstr ""
"В POSIX.1 определён список сохраняемых свойств процесса. Следующие свойства "
"процесса, имеющиеся только в Linux, также не сохраняются при B<execve>():"

#. type: Plain text
#: man-pages/man2/execve.2:209
msgid ""
"The B<prctl>(2)  B<PR_SET_DUMPABLE> flag is set, unless a set-user-ID or set-"
"group ID program is being executed, in which case it is cleared."
msgstr ""
"Устанавливается флаг B<PR_SET_DUMPABLE> (B<prctl>(2)), если выполняемая "
"программа не имеет установленных бит set-user-ID или set-group-ID; в "
"противном случае он очищается."

#. type: Plain text
#: man-pages/man2/execve.2:214
msgid "The B<prctl>(2)  B<PR_SET_KEEPCAPS> flag is cleared."
msgstr "Флаг B<PR_SET_KEEPCAPS> (B<prctl>(2)) очищается."

#. type: Plain text
#: man-pages/man2/execve.2:221
msgid ""
"(Since Linux 2.4.36 / 2.6.23)  If a set-user-ID or set-group-ID program is "
"being executed, then the parent death signal set by B<prctl>(2)  "
"B<PR_SET_PDEATHSIG> flag is cleared."
msgstr ""
"(Начиная с Linux 2.4.36 / 2.6.23) Если выполняется программа с установленным "
"битом set-user-ID или set-group-ID, то сигнал о смерти родителя, "
"установленный B<prctl>(2) с флагом B<PR_SET_PDEATHSIG>, очищается."

#. type: Plain text
#: man-pages/man2/execve.2:228
msgid ""
"The process name, as set by B<prctl>(2)  B<PR_SET_NAME> (and displayed by "
"I<ps\\ -o comm>), is reset to the name of the new executable file."
msgstr ""
"Имя процесса, установленное через B<prctl>(2) B<PR_SET_NAME> (и отображаемое "
"I<ps\\ -o comm>), изменяется на имя нового исполняемого файла."

#. type: Plain text
#: man-pages/man2/execve.2:235
msgid ""
"The B<SECBIT_KEEP_CAPS> I<securebits> flag is cleared.  See "
"B<capabilities>(7)."
msgstr ""
"Флаг B<SECBIT_KEEP_CAPS> I<securebits> очищается. Смотрите "
"B<capabilities>(7)."

#. type: Plain text
#: man-pages/man2/execve.2:240
msgid "The termination signal is reset to B<SIGCHLD> (see B<clone>(2))."
msgstr ""
"Сигнал завершения (termination signal) устанавливается в B<SIGCHLD> "
"(B<clone>(2))."

#. type: Plain text
#: man-pages/man2/execve.2:245
msgid ""
"The file descriptor table is unshared, undoing the effect of the "
"B<CLONE_FILES> flag of B<clone>(2)."
msgstr ""
"Таблица файловых дескрипторов не является общей, отменяется действие флага "
"B<CLONE_FILES> у B<clone>(2)."

#. type: Plain text
#: man-pages/man2/execve.2:247
msgid "Note the following further points:"
msgstr "Также стоит учитывать следующее:"

#. type: Plain text
#: man-pages/man2/execve.2:251
msgid ""
"All threads other than the calling thread are destroyed during an "
"B<execve>().  Mutexes, condition variables, and other pthreads objects are "
"not preserved."
msgstr ""
"Все нити (threads), отличные от вызывающей, уничтожаются B<execve>(). "
"Мьютексы, условные переменные и другие объекты pthreads не сохраняются."

#. type: Plain text
#: man-pages/man2/execve.2:254
msgid ""
"The equivalent of I<setlocale(LC_ALL, \"C\")> is executed at program start-"
"up."
msgstr ""
"При запуске программы выполняется эквивалент I<setlocale(LC_ALL, \"C\")>."

#. type: Plain text
#: man-pages/man2/execve.2:262
msgid ""
"POSIX.1 specifies that the dispositions of any signals that are ignored or "
"set to the default are left unchanged.  POSIX.1 specifies one exception: if "
"B<SIGCHLD> is being ignored, then an implementation may leave the "
"disposition unchanged or reset it to the default; Linux does the former."
msgstr ""
"В POSIX.1 указано, что действия по отношению к любым игнорируемым или "
"имеющим настройку по умолчанию сигналам, остаются неизменными. В POSIX.1 "
"есть одно исключение: если B<SIGCHLD> игнорируется, то реализация может "
"оставить обработку сигнала (disposition) неизменной или вернуть настройку по "
"умолчанию; в Linux используется первое."

#. type: Plain text
#: man-pages/man2/execve.2:266
msgid ""
"Any outstanding asynchronous I/O operations are canceled (B<aio_read>(3), "
"B<aio_write>(3))."
msgstr ""
"Все ожидающие выполнения асинхронные операции ввода-вывод отменяются "
"(B<aio_read>(3), B<aio_write>(3))."

#. type: Plain text
#: man-pages/man2/execve.2:271
msgid ""
"For the handling of capabilities during B<execve>(), see B<capabilities>(7)."
msgstr ""
"Как происходит обработка мандатов (capabilities) при вызове B<execve>(), см. "
"B<capabilities>(7)."

#.  On Linux it appears that these file descriptors are
#.  always open after an execve(), and it looks like
#.  Solaris 8 and FreeBSD 6.1 are the same. -- mtk, 30 Apr 2007
#. type: Plain text
#: man-pages/man2/execve.2:298
msgid ""
"By default, file descriptors remain open across an B<execve>().  File "
"descriptors that are marked close-on-exec are closed; see the description of "
"B<FD_CLOEXEC> in B<fcntl>(2).  (If a file descriptor is closed, this will "
"cause the release of all record locks obtained on the underlying file by "
"this process.  See B<fcntl>(2)  for details.)  POSIX.1 says that if file "
"descriptors 0, 1, and 2 would otherwise be closed after a successful "
"B<execve>(), and the process would gain privilege because the set-user-ID or "
"set-group_ID mode bit was set on the executed file, then the system may open "
"an unspecified file for each of these file descriptors.  As a general "
"principle, no portable program, whether privileged or not, can assume that "
"these three file descriptors will remain closed across an B<execve>()."
msgstr ""
"По умолчанию, после B<execve>() файловые дескрипторы остаются открытыми. "
"Файловые дескрипторы, помеченные как close-on-exec (закрывать при запуске), "
"закрываются; смотрите описание B<FD_CLOEXEC> в B<fcntl>(2) (если файловый "
"дескриптор закрыт, это приводит к освобождению всех имеющихся блокировок, "
"полученных на соответствующий файл данным процессом. Подробней смотрите "
"B<fcntl>(2)). В POSIX.1 сказано, что если бы файловые дескрипторы 0, 1 и 2 "
"были закрыты после успешного вызова B<execve>(), и процесс получил бы "
"привилегии из-за установленных битов режима set-user-ID или set-group_ID на "
"исполняемом файле, то система смогла бы открыть произвольный файл для "
"каждого из этих дескрипторов. Считается, что переносимая программа, с "
"привилегиями или без, не может рассчитывать, что эти три файловых "
"дескриптора будут оставаться закрытыми после B<execve>()."

#. type: SS
#: man-pages/man2/execve.2:298 man-pages/man2/execve.2:628
#, no-wrap
msgid "Interpreter scripts"
msgstr "Интерпретируемые сценарии"

#. type: Plain text
#: man-pages/man2/execve.2:301
msgid ""
"An interpreter script is a text file that has execute permission enabled and "
"whose first line is of the form:"
msgstr ""
"Интерпретируемый сценарий \\(em это текстовый файл, у которого установлен "
"бит выполнения и первая строка имеет вид:"

#. type: Plain text
#: man-pages/man2/execve.2:311
msgid "The I<interpreter> must be a valid pathname for an executable file."
msgstr "В поле I<интерпретатор> должно быть указано имя файла запуска."

#. type: Plain text
#: man-pages/man2/execve.2:319
msgid ""
"If the I<pathname> argument of B<execve>()  specifies an interpreter script, "
"then I<interpreter> will be invoked with the following arguments:"
msgstr ""
"Если в аргументе I<pathname> для B<execve>() указан интерпретируемый "
"сценарий, то I<интерпретатор> будет вызван со следующими параметрами:"

#. type: Plain text
#: man-pages/man2/execve.2:323
#, no-wrap
msgid "I<interpreter> [optional-arg] I<pathname> arg...\n"
msgstr "I<интерпретатор> [необязательный параметр] I<pathname> параметр…\n"

#.  See the P - preserve-argv[0] option.
#.  Documentation/admin-guide/binfmt-misc.rst
#.  https://www.kernel.org/doc/html/latest/admin-guide/binfmt-misc.html
#. type: Plain text
#: man-pages/man2/execve.2:346
msgid ""
"where I<pathname> is the absolute pathname of the file specified as the "
"first argument of B<execve>(), and I<arg...> is the series of words pointed "
"to by the I<argv> argument of B<execve>(), starting at I<argv>[1].  Note "
"that there is no way to get the I<argv[0]> that was passed to the "
"B<execve>()  call."
msgstr ""
"где I<pathname> — абсолютный путь к файлу, указанному в первом аргументе "
"B<execve>() и I<параметр...> — последовательность слов, указываемых "
"аргументом I<argv> в B<execve>() начиная с I<argv>[1]. Заметим, что нельзя "
"получить I<argv[0]>, переданный в вызов B<execve>()."

#. type: Plain text
#: man-pages/man2/execve.2:351
msgid ""
"For portable use, I<optional-arg> should either be absent, or be specified "
"as a single word (i.e., it should not contain white space); see NOTES below."
msgstr ""
"В целях переносимости, I<необязательный параметр> должен быть или пустым, "
"или задаваться одним словом (т.е., не должен содержать пробельных символов); "
"см. ЗАМЕЧАНИЯ далее."

#.  commit bf2a9a39639b8b51377905397a5005f444e9a892
#. type: Plain text
#: man-pages/man2/execve.2:358
msgid ""
"Since Linux 2.6.28, the kernel permits the interpreter of a script to itself "
"be a script.  This permission is recursive, up to a limit of four "
"recursions, so that the interpreter may be a script which is interpreted by "
"a script, and so on."
msgstr ""
"Начиная с Linux 2.6.28 ядро позволяет интерпретатору сценария самому быть "
"сценарием. Это разрешение рекурсивно (до четырёх раз), поэтому сценарий "
"может быть сценарием, который интерпретируется сценарием и т. д."

#. type: SS
#: man-pages/man2/execve.2:358
#, no-wrap
msgid "Limits on size of arguments and environment"
msgstr "Ограничения на размер параметров и окружения"

#. type: Plain text
#: man-pages/man2/execve.2:371
msgid ""
"Most UNIX implementations impose some limit on the total size of the command-"
"line argument (I<argv>)  and environment (I<envp>)  strings that may be "
"passed to a new program.  POSIX.1 allows an implementation to advertise this "
"limit using the B<ARG_MAX> constant (either defined in I<E<lt>limits.hE<gt>> "
"or available at run time using the call I<sysconf(_SC_ARG_MAX)>)."
msgstr ""
"Большинство реализаций UNIX накладывает некоторые ограничения на полный "
"размер параметра командной строки (I<argv>) и окружения (I<envp>), которые "
"можно передать новой программе. POSIX.1 позволяет реализации объявить это "
"ограничение через константу B<ARG_MAX> (определённую в I<E<lt>limits.hE<gt>> "
"или сделать её доступной во время выполнения через вызов "
"I<sysconf(_SC_ARG_MAX)>)."

#. type: Plain text
#: man-pages/man2/execve.2:378
msgid ""
"On Linux prior to kernel 2.6.23, the memory used to store the environment "
"and argument strings was limited to 32 pages (defined by the kernel constant "
"B<MAX_ARG_PAGES>).  On architectures with a 4-kB page size, this yields a "
"maximum size of 128\\ kB."
msgstr ""
"В ядре Linux до версии 2.6.23 размер памяти, используемый для хранения "
"окружения и строк параметров, был ограничен 32 страницами (определялся "
"ядерной константой B<MAX_ARG_PAGES>). На архитектурах с 4-КиБ размером "
"страницы это давало максимальный размер в 128\\ КиБ."

#.  For some background on the changes to ARG_MAX in kernels 2.6.23 and
#.  2.6.25, see:
#.      http://sourceware.org/bugzilla/show_bug.cgi?id=5786
#.      http://bugzilla.kernel.org/show_bug.cgi?id=10095
#.      http://thread.gmane.org/gmane.linux.kernel/646709/focus=648101,
#.      checked into 2.6.25 as commit a64e715fc74b1a7dcc5944f848acc38b2c4d4ee2.
#.  Ollie: That doesn't include the lists of pointers, though,
#.  so the actual usage is a bit higher (1 pointer per argument).
#. type: Plain text
#: man-pages/man2/execve.2:418
msgid ""
"On kernel 2.6.23 and later, most architectures support a size limit derived "
"from the soft B<RLIMIT_STACK> resource limit (see B<getrlimit>(2))  that is "
"in force at the time of the B<execve>()  call.  (Architectures with no "
"memory management unit are excepted: they maintain the limit that was in "
"effect before kernel 2.6.23.)  This change allows programs to have a much "
"larger argument and/or environment list.  For these architectures, the total "
"size is limited to 1/4 of the allowed stack size.  (Imposing the 1/4-limit "
"ensures that the new program always has some stack space.)  Additionally, "
"the total size is limited to 3/4 of the value of the kernel constant "
"B<_STK_LIM> (8 Mibibytes).  Since Linux 2.6.25, the kernel also places a "
"floor of 32 pages on this size limit, so that, even when B<RLIMIT_STACK> is "
"set very low, applications are guaranteed to have at least as much argument "
"and environment space as was provided by Linux 2.6.23 and earlier.  (This "
"guarantee was not provided in Linux 2.6.23 and 2.6.24.)  Additionally, the "
"limit per string is 32 pages (the kernel constant B<MAX_ARG_STRLEN>), and "
"the maximum number of strings is 0x7FFFFFFF."
msgstr ""
"Начиная с ядра версии 2.6.23, большинство архитектур поддерживают предельный "
"размер, высчитываемый от мягкого ограничения ресурса B<RLIMIT_STACK> (см. "
"B<getrlimit>(2)), который действует во время вызова B<execve>(). (Исключение "
"составляют архитектуры без механизма управления памятью: в них ограничение "
"рассчитывается как и до версии 2.6.23.) Это изменение позволяет программам "
"иметь больший список параметров и/или окружения. Для этих архитектур полный "
"размер ограничен до 1/4 разрешённого размера стека. (Накладываемое "
"ограничение в 1/4 позволяет новой программе всегда иметь некоторое "
"пространство под стек.) Кроме того, полный размер ограничен 3/4 значения "
"ядерной константы B<_STK_LIM> (8 мибибайт). Начиная с Linux версии 2.6.25, "
"ядро также отводит нижние 32 страницы для этого предельного размера, "
"поэтому, даже когда B<RLIMIT_STACK> задан слишком низко, приложения "
"гарантированно получат, по крайней мере, столько же пространства под "
"параметры и окружение, сколько бы они получили при работе с Linux 2.6.23 и "
"ранее. (Это гарантия не обеспечивалась в Linux 2.6.23 и 2.6.24.) Также, "
"размер строки ограничен 32 страницами (ядерная константа B<MAX_ARG_STRLEN>), "
"а максимальное число строк может быть 0x7FFFFFFF."

#. type: Plain text
#: man-pages/man2/execve.2:424
msgid ""
"On success, B<execve>()  does not return, on error -1 is returned, and "
"I<errno> is set appropriately."
msgstr ""
"При успешном выполнении B<execve>() не возвращает управление. В случае "
"ошибки возвращается -1, а I<errno> устанавливается в соответствующее "
"значение."

#. type: TP
#: man-pages/man2/execve.2:425
#, no-wrap
msgid "B<E2BIG>"
msgstr "B<E2BIG>"

#. type: Plain text
#: man-pages/man2/execve.2:432
msgid ""
"The total number of bytes in the environment (I<envp>)  and argument list "
"(I<argv>)  is too large."
msgstr ""
"Слишком большое общее количество байт для окружения (I<envp>) и списка "
"параметров (I<argv>)."

#. type: TP
#: man-pages/man2/execve.2:432 man-pages/man2/execve.2:439
#: man-pages/man2/execve.2:442 man-pages/man2/execve.2:445
#, no-wrap
msgid "B<EACCES>"
msgstr "B<EACCES>"

#. type: Plain text
#: man-pages/man2/execve.2:439
msgid ""
"Search permission is denied on a component of the path prefix of I<pathname> "
"or the name of a script interpreter.  (See also B<path_resolution>(7).)"
msgstr ""
"В одном из каталогов префикса I<pathname> или интерпретатора не разрешён "
"поиск (смотрите также B<path_resolution>(7))."

#. type: Plain text
#: man-pages/man2/execve.2:442
msgid "The file or a script interpreter is not a regular file."
msgstr "Файл или интерпретатор не являются обычным файлом."

#. type: Plain text
#: man-pages/man2/execve.2:445
msgid ""
"Execute permission is denied for the file or a script or ELF interpreter."
msgstr ""
"Не установлен бит выполнения на файле или сценарии или интерпретаторе ELF."

#. type: Plain text
#: man-pages/man2/execve.2:449
msgid "The filesystem is mounted I<noexec>."
msgstr "Файловая система смонтирована с I<noexec>."

#. type: TP
#: man-pages/man2/execve.2:449
#, no-wrap
msgid "B<EAGAIN> (since Linux 3.1)"
msgstr "B<EAGAIN> (начиная с Linux 3.1)"

#.  commit 72fa59970f8698023045ab0713d66f3f4f96945c
#. type: Plain text
#: man-pages/man2/execve.2:459
msgid ""
"Having changed its real UID using one of the B<set*uid>()  calls, the caller "
"was\\(emand is now still\\(emabove its B<RLIMIT_NPROC> resource limit (see "
"B<setrlimit>(2)).  For a more detailed explanation of this error, see NOTES."
msgstr ""
"Из-за изменения реального UID одним из вызовов B<set*uid>() ранее, "
"вызывающий всё ещё превышает ограничитель ресурса B<RLIMIT_NPROC> (смотрите "
"B<setrlimit>(2)). Подробное объяснение этой ошибки смотрите в ЗАМЕЧАНИЯХ."

#. type: TP
#: man-pages/man2/execve.2:459
#, no-wrap
msgid "B<EFAULT>"
msgstr "B<EFAULT>"

#. type: Plain text
#: man-pages/man2/execve.2:467
msgid ""
"I<pathname> or one of the pointers in the vectors I<argv> or I<envp> points "
"outside your accessible address space."
msgstr ""
"Значение I<pathname> или один из указателей в векторах I<argv> или I<envp> "
"указывает за пределы доступного адресного пространства."

#. type: Plain text
#: man-pages/man2/execve.2:471
msgid ""
"An ELF executable had more than one PT_INTERP segment (i.e., tried to name "
"more than one interpreter)."
msgstr ""
"Исполняемый ELF-файл содержит более одного сегмента PT_INTERP (т.е., в нём "
"указано более одного интерпретатора)."

#. type: TP
#: man-pages/man2/execve.2:471
#, no-wrap
msgid "B<EIO>"
msgstr "B<EIO>"

#. type: Plain text
#: man-pages/man2/execve.2:474
msgid "An I/O error occurred."
msgstr "Произошла ошибка ввода-вывода."

#. type: TP
#: man-pages/man2/execve.2:474
#, no-wrap
msgid "B<EISDIR>"
msgstr "B<EISDIR>"

#. type: Plain text
#: man-pages/man2/execve.2:477
msgid "An ELF interpreter was a directory."
msgstr "Интерпретатор ELF является каталогом."

#. type: TP
#: man-pages/man2/execve.2:477
#, no-wrap
msgid "B<ELIBBAD>"
msgstr "B<ELIBBAD>"

#. type: Plain text
#: man-pages/man2/execve.2:480
msgid "An ELF interpreter was not in a recognized format."
msgstr "Не распознан формат интерпретатора ELF."

#. type: Plain text
#: man-pages/man2/execve.2:485
msgid ""
"Too many symbolic links were encountered in resolving I<pathname> or the "
"name of a script or ELF interpreter."
msgstr ""
"Во время определения I<pathname>, имени сценария или интерпретатора ELF "
"встретилось слишком много символьных ссылок."

#.  commit d740269867021faf4ce38a449353d2b986c34a67
#. type: Plain text
#: man-pages/man2/execve.2:493
msgid ""
"The maximum recursion limit was reached during recursive script "
"interpretation (see \"Interpreter scripts\", above).  Before Linux 3.8, the "
"error produced for this case was B<ENOEXEC>."
msgstr ""
"Достигнут предел количества рекурсий при интерпретации сценария (смотрите "
"«Интерпретируемые сценарии» выше). До Linux 3.8 для этого случая "
"возвращалась ошибка B<ENOEXEC>."

#. type: TP
#: man-pages/man2/execve.2:496
#, no-wrap
msgid "B<ENAMETOOLONG>"
msgstr "B<ENAMETOOLONG>"

#. type: Plain text
#: man-pages/man2/execve.2:500
msgid "I<pathname> is too long."
msgstr "Слишком длинное значение аргумента I<pathname>."

#.  FIXME but see http://sourceware.org/bugzilla/show_bug.cgi?id=12241
#. type: Plain text
#: man-pages/man2/execve.2:510
msgid ""
"The file I<pathname> or a script or ELF interpreter does not exist, or a "
"shared library needed for the file or interpreter cannot be found."
msgstr ""
"Файл I<pathname>, сценарий или интерпретатор ELF не существует, или не "
"найдена динамическая библиотека, необходимая для файлового интерпретатора."

#. type: TP
#: man-pages/man2/execve.2:510
#, no-wrap
msgid "B<ENOEXEC>"
msgstr "B<ENOEXEC>"

#. type: Plain text
#: man-pages/man2/execve.2:515
msgid ""
"An executable is not in a recognized format, is for the wrong architecture, "
"or has some other format error that means it cannot be executed."
msgstr ""
"Не распознан формат исполняемого файла, он не подходит для архитектуры, или "
"имеет ошибки в формате, из-за чего не может быть выполнен."

#. type: Plain text
#: man-pages/man2/execve.2:518
msgid "Insufficient kernel memory was available."
msgstr "Недостаточное количество памяти ядра."

#. type: Plain text
#: man-pages/man2/execve.2:523
msgid ""
"A component of the path prefix of I<pathname> or a script or ELF interpreter "
"is not a directory."
msgstr ""
"Компонент пути в I<pathname>, сценарии или интерпретаторе ELF в "
"действительности не является каталогом."

#. type: TP
#: man-pages/man2/execve.2:523 man-pages/man2/execve.2:529
#: man-pages/man2/execve.2:533
#, no-wrap
msgid "B<EPERM>"
msgstr "B<EPERM>"

#. type: Plain text
#: man-pages/man2/execve.2:529
msgid ""
"The filesystem is mounted I<nosuid>, the user is not the superuser, and the "
"file has the set-user-ID or set-group-ID bit set."
msgstr ""
"Файловая система смонтирована с I<nosuid>, пользователь не является "
"суперпользователем, а на файле установлен бит set-user-ID или set-group-ID."

#. type: Plain text
#: man-pages/man2/execve.2:533
msgid ""
"The process is being traced, the user is not the superuser and the file has "
"the set-user-ID or set-group-ID bit set."
msgstr ""
"Над процессом выполняется трассировка, пользователь не имеет прав "
"суперпользователя, а у файла установлен бит set-user-ID или set-group-ID."

#. type: Plain text
#: man-pages/man2/execve.2:539
msgid ""
"A \"capability-dumb\" applications would not obtain the full set of "
"permitted capabilities granted by the executable file.  See "
"B<capabilities>(7)."
msgstr ""
"Приложение «с недоработанными мандатами» (capability-dumb) не получило бы "
"полный набор ограничивающих мандатов, разрешаемых исполняемым файлом. "
"Смотрите B<capabilities>(7)."

#. type: TP
#: man-pages/man2/execve.2:539
#, no-wrap
msgid "B<ETXTBSY>"
msgstr "B<ETXTBSY>"

#. type: Plain text
#: man-pages/man2/execve.2:542
msgid "The specified executable was open for writing by one or more processes."
msgstr ""
"Заданный исполняемый файл был открыт на запись одним или более процессов."

#.  SVr4 documents additional error
#.  conditions EAGAIN, EINTR, ELIBACC, ENOLINK, EMULTIHOP; POSIX does not
#.  document ETXTBSY, EPERM, EFAULT, ELOOP, EIO, ENFILE, EMFILE, EINVAL,
#.  EISDIR or ELIBBAD error conditions.
#. type: Plain text
#: man-pages/man2/execve.2:550
msgid ""
"POSIX.1-2001, POSIX.1-2008, SVr4, 4.3BSD.  POSIX does not document the #! "
"behavior, but it exists (with some variations) on other UNIX systems."
msgstr ""
"POSIX.1-2001, POSIX.1-2008, SVr4, 4.3BSD. В POSIX не описано поведение #!, "
"но это существует (в нескольких вариантах) в других системах UNIX."

#. type: Plain text
#: man-pages/man2/execve.2:566
msgid ""
"One sometimes sees B<execve>()  (and the related functions described in "
"B<exec>(3))  described as \"executing a I<new> process\" (or similar).  This "
"is a highly misleading description: there is no new process; many attributes "
"of the calling process remain unchanged (in particular, its PID).  All that "
"B<execve>(2)  does is arrange for an existing process (the calling process)  "
"to execute a new program."
msgstr ""
"Иногда, про B<execve>() (и подобные функции, описанные в B<exec>(3)) "
"говорят, что он «выполняет I<новый> процесс». Это крайне некорректная фраза "
"— не появляется нового процесса; много атрибутов вызывающего процесса "
"остаются неизменными (в частности, его PID). Всё, что делает B<execve>(2), "
"это перестраивает существующий процесс (вызывавший процесс) под выполнение "
"новой программы."

#. type: Plain text
#: man-pages/man2/execve.2:569
msgid "Set-user-ID and set-group-ID processes can not be B<ptrace>(2)d."
msgstr ""
"Над процессами с установленными set-user-ID и set-group-ID не может "
"выполняться B<ptrace>(2)."

#. type: Plain text
#: man-pages/man2/execve.2:580
msgid ""
"The result of mounting a filesystem I<nosuid> varies across Linux kernel "
"versions: some will refuse execution of set-user-ID and set-group-ID "
"executables when this would give the user powers they did not have already "
"(and return B<EPERM>), some will just ignore the set-user-ID and set-group-"
"ID bits and B<exec>()  successfully."
msgstr ""
"Результат работы при монтировании файловой системы с параметром I<nosuid> "
"различается в разных версиях ядра Linux: некоторые будут отказывать в "
"запуске исполняемых файлов с установленными битами set-user-ID и set-group-"
"ID, если это дало бы пользователю больше прав чем уже есть (и возвращать "
"B<EPERM>), другие просто проигнорируют биты set-user-ID и set-group-ID и "
"успешно выполнят B<exec>()."

#.  e.g., EFAULT on Solaris 8 and FreeBSD 6.1; but
#.  HP-UX 11 is like Linux -- mtk, Apr 2007
#.  Bug filed 30 Apr 2007: http://bugzilla.kernel.org/show_bug.cgi?id=8408
#.  Bug rejected (because fix would constitute an ABI change).
#. type: Plain text
#: man-pages/man2/execve.2:602
msgid ""
"On Linux, I<argv> and I<envp> can be specified as NULL.  In both cases, this "
"has the same effect as specifying the argument as a pointer to a list "
"containing a single null pointer.  B<Do not take advantage of this "
"nonstandard and nonportable misfeature!> On many other UNIX systems, "
"specifying I<argv> as NULL will result in an error (B<EFAULT>).  I<Some> "
"other UNIX systems treat the I<envp==NULL> case the same as Linux."
msgstr ""
"В Linux значения I<argv> и I<envp> могут быть равны NULL. В обоих случаях, "
"это работает также, как если аргумент бы содержал указатель на список с "
"единственным указателем null. B<Не пользуйтесь преимуществом данной "
"нестандартной и непереносимой возможностью!> В многих других системах UNIX "
"указание I<argv> равным NULL приводит к ошибке (B<EFAULT>). I<Некоторые> "
"другие системы UNIX при I<envp==NULL> работают также как Linux."

#. type: Plain text
#: man-pages/man2/execve.2:613
msgid ""
"POSIX.1 says that values returned by B<sysconf>(3)  should be invariant over "
"the lifetime of a process.  However, since Linux 2.6.23, if the "
"B<RLIMIT_STACK> resource limit changes, then the value reported by "
"B<_SC_ARG_MAX> will also change, to reflect the fact that the limit on space "
"for holding command-line arguments and environment variables has changed."
msgstr ""
"В POSIX.1 указано, что значения, возвращаемые B<sysconf>(3), должны быть "
"неизменны в течении существования процесса. Однако, начиная с версии Linux "
"2.6.23, если изменяется ограничение ресурса B<RLIMIT_STACK>, то значение, "
"возвращаемое для B<_SC_ARG_MAX>, также будет изменено, чтобы отразить, что "
"ограничение на пространство для хранения параметров командной строки и "
"окружения было изменено."

#. type: Plain text
#: man-pages/man2/execve.2:628
msgid ""
"In most cases where B<execve>()  fails, control returns to the original "
"executable image, and the caller of B<execve>()  can then handle the error.  "
"However, in (rare) cases (typically caused by resource exhaustion), failure "
"may occur past the point of no return: the original executable image has "
"been torn down, but the new image could not be completely built.  In such "
"cases, the kernel kills the process with a B<SIGKILL> signal."
msgstr ""
"В большинстве случаев отказа B<execve>() управление возвращается в "
"первоначально исполняемый образ и вызывающий B<execve>() может обработать "
"ошибку. Однако в (редких) случаях (обычно вызванных отсутствием ресурсов), "
"ошибка может возникнуть после точки невозврата: первоначально исполняемый "
"образ уже разрушен, а новый образ ещё сознан не полностью. В таких случаях "
"ядро убивает процесс сигналом B<SIGKILL>."

#.  commit 6eb3c3d0a52dca337e327ae8868ca1f44a712e02
#. type: Plain text
#: man-pages/man2/execve.2:636
msgid ""
"The kernel imposes a maximum length on the text that follows the \"#!\" "
"characters at the start of a script; characters beyond the limit are "
"ignored.  Before Linux 5.1, the limit is 127 characters.  Since Linux 5.1, "
"the limit is 255 characters."
msgstr ""
"Ядро накладывает ограничение на максимальную длину текста после символов "
"«#!» в начале сценария; символы за пределами границ игнорируются. До Linux "
"5.1 было ограничение в 127 символов. Начиная с Linux 5.1 ограничение "
"установлено в 255 символов."

#.  e.g., Solaris 8
#.  e.g., FreeBSD before 6.0, but not FreeBSD 6.0 onward
#. type: Plain text
#: man-pages/man2/execve.2:655
msgid ""
"The semantics of the I<optional-arg> argument of an interpreter script vary "
"across implementations.  On Linux, the entire string following the "
"I<interpreter> name is passed as a single argument to the interpreter, and "
"this string can include white space.  However, behavior differs on some "
"other systems.  Some systems use the first white space to terminate "
"I<optional-arg>.  On some systems, an interpreter script can have multiple "
"arguments, and white spaces in I<optional-arg> are used to delimit the "
"arguments."
msgstr ""
"Семантика I<необязательного параметра> интерпретатора сценариев различна в "
"разных реализациях. В Linux, вся строка после имени I<интерпретатора> "
"передаётся интерпретатору как единый параметр, и эта строка может содержать "
"пробельные символы. Однако, такое поведение отличается от других систем. "
"Некоторые системы используют первый пробел в качестве признака окончания "
"I<необязательного параметра>. В других системах, интерпретатор сценариев "
"может иметь несколько параметров, и пробелы в I<необязательном параметре> "
"используются для их разграничения."

#.  .SH BUGS
#.  Some Linux versions have failed to check permissions on ELF
#.  interpreters.  This is a security hole, because it allows users to
#.  open any file, such as a rewinding tape device, for reading.  Some
#.  Linux versions have also had other security holes in
#.  .BR execve ()
#.  that could be exploited for denial of service by a suitably crafted
#.  ELF binary. There are no known problems with 2.0.34 or 2.2.15.
#. type: Plain text
#: man-pages/man2/execve.2:667
msgid ""
"Linux (like most other modern UNIX systems)  ignores the set-user-ID and set-"
"group-ID bits on scripts."
msgstr ""
"На файлах со сценариями в Linux (как и большинстве других современных "
"системах UNIX) игнорируются биты set-user-ID и set-group-ID."

#. type: SS
#: man-pages/man2/execve.2:667
#, no-wrap
msgid "execve() and EAGAIN"
msgstr "execve() и EAGAIN"

#. type: Plain text
#: man-pages/man2/execve.2:673
msgid ""
"A more detailed explanation of the B<EAGAIN> error that can occur (since "
"Linux 3.1) when calling B<execve>()  is as follows."
msgstr ""
"Это более подробное объяснение ошибки B<EAGAIN>, которая возвращается "
"(начиная с Linux 3.1) при вызове B<execve>()."

#.  commit 909cc4ae86f3380152a18e2a3c44523893ee11c4
#. type: Plain text
#: man-pages/man2/execve.2:695
msgid ""
"The B<EAGAIN> error can occur when a I<preceding> call to B<setuid>(2), "
"B<setreuid>(2), or B<setresuid>(2)  caused the real user ID of the process "
"to change, and that change caused the process to exceed its B<RLIMIT_NPROC> "
"resource limit (i.e., the number of processes belonging to the new real UID "
"exceeds the resource limit).  From Linux 2.6.0 to 3.0, this caused the "
"B<set*uid>()  call to fail.  (Prior to 2.6, the resource limit was not "
"imposed on processes that changed their user IDs.)"
msgstr ""
"Ошибка B<EAGAIN> может возникать, когда I<предшествующий> вызов "
"B<setuid>(2), B<setreuid>(2) или B<setresuid>(2) приводит к изменению у "
"процесса реального идентификатора пользователя и это изменение приводит к "
"тому, что процесс превышает свой ограничитель ресурса B<RLIMIT_NPROC> (т. "
"е., количество процессов, принадлежащих новому реальному UID, превышает "
"ограничитель ресурса). В версиях Linux с 2.6.0 по 3.0, это приводит к ошибке "
"вызова B<set*uid>() (до версии 2.6 ограничитель ресурса не учитывался для "
"процессов, которые изменили идентификатор пользователя)."

#. type: Plain text
#: man-pages/man2/execve.2:726
msgid ""
"Since Linux 3.1, the scenario just described no longer causes the "
"B<set*uid>()  call to fail, because it too often led to security holes where "
"buggy applications didn't check the return status and assumed that\\(emif "
"the caller had root privileges\\(emthe call would always succeed.  Instead, "
"the B<set*uid>()  calls now successfully change the real UID, but the kernel "
"sets an internal flag, named B<PF_NPROC_EXCEEDED>, to note that the "
"B<RLIMIT_NPROC> resource limit has been exceeded.  If the "
"B<PF_NPROC_EXCEEDED> flag is set and the resource limit is still exceeded at "
"the time of a subsequent B<execve>()  call, that call fails with the error "
"B<EAGAIN>.  This kernel logic ensures that the B<RLIMIT_NPROC> resource "
"limit is still enforced for the common privileged daemon workflow"
"\\(emnamely, B<fork>(2)  + B<set*uid>()  + B<execve>()."
msgstr ""
"Начиная с Linux 3.1, описанный сценарий больше не приводит к ошибке в вызове "
"B<set*uid>(), так как это слишком часто приводило к дырам в безопасности, "
"когда некорректное приложение не проверяет возвращаемое состояние и "
"предполагает, что если вызывающий имеет права root, то вызов всегда "
"выполняется успешно. Вместо этого вызов B<set*uid>() теперь успешно изменяет "
"реальный UID, но ядро устанавливает внутренний флаг с именем "
"B<PF_NPROC_EXCEEDED>, который означает, что был превышен ограничитель "
"ресурса B<RLIMIT_NPROC>. Если флаг B<PF_NPROC_EXCEEDED> установлен и "
"ограничитель ресурса всё ещё превышен на момент последующего вызова "
"B<execve>(), то вызов завершается с ошибкой B<EAGAIN>. Такая логика ядра "
"гарантирует, что ограничитель ресурса B<RLIMIT_NPROC> будет учтён при "
"обычной последовательности действий для привилегированных служб, а именно — "
"B<fork>(2)  + B<set*uid>()  + B<execve>()."

#. type: Plain text
#: man-pages/man2/execve.2:742
msgid ""
"If the resource limit was not still exceeded at the time of the B<execve>()  "
"call (because other processes belonging to this real UID terminated between "
"the B<set*uid>()  call and the B<execve>()  call), then the B<execve>()  "
"call succeeds and the kernel clears the B<PF_NPROC_EXCEEDED> process flag.  "
"The flag is also cleared if a subsequent call to B<fork>(2)  by this process "
"succeeds."
msgstr ""
"Если ограничитель ресурса был не превышен на момент вызова B<execve>() (так "
"как другие процессы, принадлежащие этому реальному UID завершили работу "
"между вызовом B<set*uid>() и B<execve>()), то вызов B<execve>() выполнится "
"успешно и ядро очистит флаг B<PF_NPROC_EXCEEDED> у процесса. Флаг также "
"очищается, если при успешном выполнении процессом последующего вызова "
"B<fork>(2)."

#. type: SS
#: man-pages/man2/execve.2:742
#, no-wrap
msgid "Historical"
msgstr "Историческая справка"

#.  .SH BUGS
#.  Some Linux versions have failed to check permissions on ELF
#.  interpreters.  This is a security hole, because it allows users to
#.  open any file, such as a rewinding tape device, for reading.  Some
#.  Linux versions have also had other security holes in
#.  .BR execve ()
#.  that could be exploited for denial of service by a suitably crafted
#.  ELF binary. There are no known problems with 2.0.34 or 2.2.15.
#. type: Plain text
#: man-pages/man2/execve.2:762
msgid ""
"With UNIX\\ V6, the argument list of an B<exec>()  call was ended by 0, "
"while the argument list of I<main> was ended by -1.  Thus, this argument "
"list was not directly usable in a further B<exec>()  call.  Since UNIX\\ V7, "
"both are NULL."
msgstr ""
"В UNIX\\ V6 список аргументов вызова B<exec>() заканчивался 0, а список "
"аргументов I<main> заканчивался -1. Поэтому, этот список аргументов не мог "
"быть использован напрямую в последующем вызове B<exec>(). Начиная с UNIX\\ "
"V7 оба списка стали оканчиваться NULL."

#. type: Plain text
#: man-pages/man2/execve.2:765
msgid ""
"The following program is designed to be execed by the second program below.  "
"It just echoes its command-line arguments, one per line."
msgstr ""
"Данная программа запускается второй программой, представленной ниже. Она "
"просто выводит свои параметры командной строки по одному на строку."

#. type: Plain text
#: man-pages/man2/execve.2:769
#, no-wrap
msgid "/* myecho.c */\n"
msgstr "/* myecho.c */\n"

#. type: Plain text
#: man-pages/man2/execve.2:772
#, no-wrap
msgid ""
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
msgstr ""
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"

#. type: Plain text
#: man-pages/man2/execve.2:777
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int j;\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int j;\n"

#. type: Plain text
#: man-pages/man2/execve.2:780
#, no-wrap
msgid ""
"    for (j = 0; j E<lt> argc; j++)\n"
"        printf(\"argv[%d]: %s\\en\", j, argv[j]);\n"
msgstr ""
"    for (j = 0; j E<lt> argc; j++)\n"
"        printf(\"argv[%d]: %s\\en\", j, argv[j]);\n"

#. type: Plain text
#: man-pages/man2/execve.2:783
#, no-wrap
msgid ""
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""
"    exit(EXIT_SUCCESS);\n"
"}\n"

#. type: Plain text
#: man-pages/man2/execve.2:788
msgid ""
"This program can be used to exec the program named in its command-line "
"argument:"
msgstr ""
"Эта программа может использоваться для запуска программы, чьё имя указано в "
"параметре командной строки."

#. type: Plain text
#: man-pages/man2/execve.2:792
#, no-wrap
msgid "/* execve.c */\n"
msgstr "/* execve.c */\n"

#. type: Plain text
#: man-pages/man2/execve.2:796
#, no-wrap
msgid ""
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
msgstr ""
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"

#. type: Plain text
#: man-pages/man2/execve.2:802
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    char *newargv[] = { NULL, \"hello\", \"world\", NULL };\n"
"    char *newenviron[] = { NULL };\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    char *newargv[] = { NULL, \"hello\", \"world\", NULL };\n"
"    char *newenviron[] = { NULL };\n"

#. type: Plain text
#: man-pages/man2/execve.2:807
#, no-wrap
msgid ""
"    if (argc != 2) {\n"
"        fprintf(stderr, \"Usage: %s E<lt>file-to-execE<gt>\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    if (argc != 2) {\n"
"        fprintf(stderr, \"Использование: %s E<lt>file-to-execE<gt>\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: man-pages/man2/execve.2:809
#, no-wrap
msgid "    newargv[0] = argv[1];\n"
msgstr "    newargv[0] = argv[1];\n"

#. type: Plain text
#: man-pages/man2/execve.2:814
#, no-wrap
msgid ""
"    execve(argv[1], newargv, newenviron);\n"
"    perror(\"execve\");   /* execve() returns only on error */\n"
"    exit(EXIT_FAILURE);\n"
"}\n"
msgstr ""
"    execve(argv[1], newargv, newenviron);\n"
"    perror(\"execve\");   /* execve() возвращается только при ошибке */\n"
"    exit(EXIT_FAILURE);\n"
"}\n"

#. type: Plain text
#: man-pages/man2/execve.2:818
msgid "We can use the second program to exec the first as follows:"
msgstr "Мы можем использовать вторую программу для запуска первой:"

#. type: Plain text
#: man-pages/man2/execve.2:827
#, no-wrap
msgid ""
"$B< cc myecho.c -o myecho>\n"
"$B< cc execve.c -o execve>\n"
"$B< ./execve ./myecho>\n"
"argv[0]: ./myecho\n"
"argv[1]: hello\n"
"argv[2]: world\n"
msgstr ""
"$B< cc myecho.c -o myecho>\n"
"$B< cc execve.c -o execve>\n"
"$B< ./execve ./myecho>\n"
"argv[0]: ./myecho\n"
"argv[1]: hello\n"
"argv[2]: world\n"

#. type: Plain text
#: man-pages/man2/execve.2:835
msgid ""
"We can also use these programs to demonstrate the use of a script "
"interpreter.  To do this we create a script whose \"interpreter\" is our "
"I<myecho> program:"
msgstr ""
"Также мы можем использовать эти программы для демонстрации использования "
"интерпретатора сценариев. Для этого создадим сценарий, чей \"интерпретатор\" "
"указывает на нашу программу I<myecho>:"

#. type: Plain text
#: man-pages/man2/execve.2:842
#, no-wrap
msgid ""
"$B< cat E<gt> script>\n"
"B<#!./myecho script-arg>\n"
"B<^D>\n"
"$B< chmod +x script>\n"
msgstr ""
"$B< cat E<gt> script>\n"
"B<#!./myecho script-arg>\n"
"B<^D>\n"
"$B< chmod +x script>\n"

#. type: Plain text
#: man-pages/man2/execve.2:846
msgid "We can then use our program to exec the script:"
msgstr "Теперь мы можем использовать нашу программу для запуска сценария:"

#. type: Plain text
#: man-pages/man2/execve.2:855
#, no-wrap
msgid ""
"$B< ./execve ./script>\n"
"argv[0]: ./myecho\n"
"argv[1]: script-arg\n"
"argv[2]: ./script\n"
"argv[3]: hello\n"
"argv[4]: world\n"
msgstr ""
"$B< ./execve ./script>\n"
"argv[0]: ./myecho\n"
"argv[1]: script-arg\n"
"argv[2]: ./script\n"
"argv[3]: hello\n"
"argv[4]: world\n"

#. type: Plain text
#: man-pages/man2/execve.2:870
msgid ""
"B<chmod>(2), B<execveat>(2), B<fork>(2), B<get_robust_list>(2), "
"B<ptrace>(2), B<exec>(3), B<fexecve>(3), B<getopt>(3), B<system>(3), "
"B<credentials>(7), B<environ>(7), B<path_resolution>(7), B<ld.so>(8)"
msgstr ""
"B<chmod>(2), B<execveat>(2), B<fork>(2), B<get_robust_list>(2), "
"B<ptrace>(2), B<exec>(3), B<fexecve>(3), B<getopt>(3), B<system>(3), "
"B<credentials>(7), B<environ>(7), B<path_resolution>(7), B<ld.so>(8)"

#. type: TH
#: man-pages/man2/exit_group.2:25
#, no-wrap
msgid "EXIT_GROUP"
msgstr "EXIT_GROUP"

#. type: TH
#: man-pages/man2/exit_group.2:25
#, no-wrap
msgid "2008-11-27"
msgstr "2008-11-27"

#. type: Plain text
#: man-pages/man2/exit_group.2:28
msgid "exit_group - exit all threads in a process"
msgstr "exit_group - Завершает все нити в процессе"

#. type: Plain text
#: man-pages/man2/exit_group.2:31
#, no-wrap
msgid "B<#include E<lt>linux/unistd.hE<gt>>\n"
msgstr "B<#include E<lt>linux/unistd.hE<gt>>\n"

#. type: Plain text
#: man-pages/man2/exit_group.2:33
#, no-wrap
msgid "B<void exit_group(int >I<status>B<);>\n"
msgstr "B<void exit_group(int >I<status>B<);>\n"

#. type: Plain text
#: man-pages/man2/exit_group.2:39
msgid ""
"This system call is equivalent to B<_exit>(2)  except that it terminates not "
"only the calling thread, but all threads in the calling process's thread "
"group."
msgstr ""
"Данный системный вызов эквивалентен B<_exit>(2) за исключением того, что "
"завершает не только вызвавшую нить, то и всю группу нитей вызвавшего "
"процесса."

#. type: Plain text
#: man-pages/man2/exit_group.2:41
msgid "This system call does not return."
msgstr "Данный системный вызов не возвращает результат."

#. type: Plain text
#: man-pages/man2/exit_group.2:43
msgid "This call is present since Linux 2.5.35."
msgstr "Данный вызов появился в Linux 2.5.35."

#. type: Plain text
#: man-pages/man2/exit_group.2:45
msgid "This call is Linux-specific."
msgstr "Данный вызов существует только в Linux."

#. type: Plain text
#: man-pages/man2/exit_group.2:49
msgid ""
"Since glibc 2.3, this is the system call invoked when the B<_exit>(2)  "
"wrapper function is called."
msgstr ""
"Начиная с glibc версии 2.3, данный системный вызов выполняется при запуске "
"обёрточной функции к B<_exit>(2)."

#. type: Plain text
#: man-pages/man2/exit_group.2:50
msgid "B<exit>(2)"
msgstr "B<exit>(2)"

#. type: TH
#: man-pages/man2/epoll_ctl.2:20
#, no-wrap
msgid "EPOLL_CTL"
msgstr "EPOLL_CTL"

#. type: Plain text
#: man-pages/man2/epoll_ctl.2:23
msgid "epoll_ctl - control interface for an epoll file descriptor"
msgstr "epoll_ctl - интерфейс управления файловым дескриптором epoll"

#. type: Plain text
#: man-pages/man2/epoll_ctl.2:28
msgid ""
"B<int epoll_ctl(int >I<epfd>B<, int >I<op>B<, int >I<fd>B<, struct "
"epoll_event *>I<event>B<);>"
msgstr ""
"B<int epoll_ctl(int >I<epfd>B<, int >I<op>B<, int >I<fd>B<, struct "
"epoll_event *>I<event>B<);>"

#. type: Plain text
#: man-pages/man2/epoll_ctl.2:39
msgid ""
"This system call is used to add, modify, or remove entries in the interest "
"list of the B<epoll>(7)  instance referred to by the file descriptor "
"I<epfd>.  It requests that the operation I<op> be performed for the target "
"file descriptor, I<fd>."
msgstr ""
"Данный системный вызов, используется для добавления, изменения или удаления "
"записей в списке interest экземпляра B<epoll>(7), на который указывает "
"файловый дескриптор I<epfd>. Он запрашивает выполнение операции I<op> для "
"файлового дескриптора назначения I<fd>."

#. type: Plain text
#: man-pages/man2/epoll_ctl.2:43
msgid "Valid values for the I<op> argument are:"
msgstr "Допустимые значения аргумента I<op>:"

#. type: TP
#: man-pages/man2/epoll_ctl.2:43
#, no-wrap
msgid "B<EPOLL_CTL_ADD>"
msgstr "B<EPOLL_CTL_ADD>"

#. type: Plain text
#: man-pages/man2/epoll_ctl.2:52
msgid ""
"Add I<fd> to the interest list and associate the settings specified in "
"I<event> with the internal file linked to I<fd>."
msgstr ""
"Добавить I<fd> в список interest и связать настройки, указанные в I<event>, "
"с внутренним файлом, связанным с I<fd>."

#. type: TP
#: man-pages/man2/epoll_ctl.2:52
#, no-wrap
msgid "B<EPOLL_CTL_MOD>"
msgstr "B<EPOLL_CTL_MOD>"

#. type: Plain text
#: man-pages/man2/epoll_ctl.2:58
msgid ""
"Change the settings associated with I<fd> in the interest list to the new "
"settings specified in I<event>."
msgstr ""
"Изменить настройки, связанные с I<fd> в списке interest, на новые, указанные "
"в I<event>."

#. type: TP
#: man-pages/man2/epoll_ctl.2:58
#, no-wrap
msgid "B<EPOLL_CTL_DEL>"
msgstr "B<EPOLL_CTL_DEL>"

#. type: Plain text
#: man-pages/man2/epoll_ctl.2:66
msgid ""
"Remove (deregister) the target file descriptor I<fd> from the interest "
"list.  The I<event> argument is ignored and can be NULL (but see BUGS below)."
msgstr ""
"Удалить (отменить регистрацию) файлового дескриптора назначения I<fd> из "
"списка interest. Значение I<event> игнорируется и может быть NULL (но "
"смотрите ДЕФЕКТЫ далее)."

#. type: Plain text
#: man-pages/man2/epoll_ctl.2:74
msgid ""
"The I<event> argument describes the object linked to the file descriptor "
"I<fd>.  The I<struct epoll_event> is defined as:"
msgstr ""
"Аргумент I<event> описывает объект, связанный с файловым дескриптором I<fd>. "
"Структура I<struct epoll_event> определена так:"

#. type: Plain text
#: man-pages/man2/epoll_ctl.2:83
#, no-wrap
msgid ""
"typedef union epoll_data {\n"
"    void        *ptr;\n"
"    int          fd;\n"
"    uint32_t     u32;\n"
"    uint64_t     u64;\n"
"} epoll_data_t;\n"
msgstr ""
"typedef union epoll_data {\n"
"    void        *ptr;\n"
"    int          fd;\n"
"    uint32_t     u32;\n"
"    uint64_t     u64;\n"
"} epoll_data_t;\n"

#. type: Plain text
#: man-pages/man2/epoll_ctl.2:88
#, no-wrap
msgid ""
"struct epoll_event {\n"
"    uint32_t     events;      /* Epoll events */\n"
"    epoll_data_t data;        /* User data variable */\n"
"};\n"
msgstr ""
"struct epoll_event {\n"
"    uint32_t     events;      /* События epoll */\n"
"    epoll_data_t data;        /* Переменная для данных пользователя */\n"
"};\n"

#. type: Plain text
#: man-pages/man2/epoll_ctl.2:95
msgid ""
"The I<events> member is a bit mask composed by ORing together zero or more "
"of the following available event types:"
msgstr ""
"Поле I<events> является битовой маской, составляемой из объединяемых (OR) "
"нуля и более следующих возможных типов событий:"

#. type: TP
#: man-pages/man2/epoll_ctl.2:95
#, no-wrap
msgid "B<EPOLLIN>"
msgstr "B<EPOLLIN>"

#. type: Plain text
#: man-pages/man2/epoll_ctl.2:100
msgid "The associated file is available for B<read>(2)  operations."
msgstr "Связанный файл доступен для чтения с помощью B<read>(2)."

#. type: TP
#: man-pages/man2/epoll_ctl.2:100
#, no-wrap
msgid "B<EPOLLOUT>"
msgstr "B<EPOLLOUT>"

#. type: Plain text
#: man-pages/man2/epoll_ctl.2:105
msgid "The associated file is available for B<write>(2)  operations."
msgstr "Связанный файл доступен для записи с помощью B<write>(2)."

#. type: TP
#: man-pages/man2/epoll_ctl.2:105
#, no-wrap
msgid "B<EPOLLRDHUP> (since Linux 2.6.17)"
msgstr "B<EPOLLRDHUP> (начиная с Linux 2.6.17)"

#. type: Plain text
#: man-pages/man2/epoll_ctl.2:111
msgid ""
"Stream socket peer closed connection, or shut down writing half of "
"connection.  (This flag is especially useful for writing simple code to "
"detect peer shutdown when using Edge Triggered monitoring.)"
msgstr ""
"Одна из сторон потокового сокета закрыла соединение или выключила "
"записывающую часть соединения (этот флаг особенно полезен при написании "
"простого кода для обнаружения отключения стороны с помощью слежения Edge "
"Triggered)."

#. type: TP
#: man-pages/man2/epoll_ctl.2:111
#, no-wrap
msgid "B<EPOLLPRI>"
msgstr "B<EPOLLPRI>"

#. type: Plain text
#: man-pages/man2/epoll_ctl.2:118
msgid ""
"There is an exceptional condition on the file descriptor.  See the "
"discussion of B<POLLPRI> in B<poll>(2)."
msgstr ""
"Исключительное состояние файлового дескриптора. Смотрите описание B<POLLPRI> "
"в B<poll>(2)."

#. type: TP
#: man-pages/man2/epoll_ctl.2:118
#, no-wrap
msgid "B<EPOLLERR>"
msgstr "B<EPOLLERR>"

#. type: Plain text
#: man-pages/man2/epoll_ctl.2:126
msgid ""
"Error condition happened on the associated file descriptor.  This event is "
"also reported for the write end of a pipe when the read end has been "
"closed.  B<epoll_wait>(2)  will always report for this event; it is not "
"necessary to set it in I<events>."
msgstr ""
"Возникло ошибочное состояние связанного файлового дескриптора. Это событие "
"также возникает на пишущей стороне канала, когда читающий конец закрылся. "
"Вызов B<epoll_wait>(2) всегда будет сообщать об этом событии; его не нужно "
"устанавливать в I<events>."

#. type: TP
#: man-pages/man2/epoll_ctl.2:126
#, no-wrap
msgid "B<EPOLLHUP>"
msgstr "B<EPOLLHUP>"

#. type: Plain text
#: man-pages/man2/epoll_ctl.2:132
msgid ""
"Hang up happened on the associated file descriptor.  B<epoll_wait>(2)  will "
"always wait for this event; it is not necessary to set it in I<events>."
msgstr ""
"Произошло зависание связанного файлового дескриптора. Вызов B<epoll_wait>(2) "
"будет всегда ждать этого события; его не нужно указывать в I<events>."

#. type: Plain text
#: man-pages/man2/epoll_ctl.2:137
msgid ""
"Note that when reading from a channel such as a pipe or a stream socket, "
"this event merely indicates that the peer closed its end of the channel.  "
"Subsequent reads from the channel will return 0 (end of file)  only after "
"all outstanding data in the channel has been consumed."
msgstr ""
"Заметим, что при чтении из канала, такого как канал (pipe) или потоковый "
"сокет, это событие всего-навсего показывает, что партнёр закрыл канал со "
"своего конца. Дальнейшее чтение из канала будет возвращать 0 (конец файла) "
"только после потребления всех неполученных данных в канале."

#. type: TP
#: man-pages/man2/epoll_ctl.2:137
#, no-wrap
msgid "B<EPOLLET>"
msgstr "B<EPOLLET>"

#. type: Plain text
#: man-pages/man2/epoll_ctl.2:147
msgid ""
"Sets the Edge Triggered behavior for the associated file descriptor.  The "
"default behavior for B<epoll> is Level Triggered.  See B<epoll>(7)  for more "
"detailed information about Edge and Level Triggered event distribution "
"architectures."
msgstr ""
"Установить поведение Edge Triggered для связанного файлового дескриптора. "
"Поведение по умолчанию для B<epoll> равно Level Triggered. Более подробное "
"описание архитектуры распределения событий Edge и Level Triggered смотрите в "
"B<epoll>(7)."

#. type: TP
#: man-pages/man2/epoll_ctl.2:147
#, no-wrap
msgid "B<EPOLLONESHOT> (since Linux 2.6.2)"
msgstr "B<EPOLLONESHOT> (начиная с Linux 2.6.2)"

#. type: Plain text
#: man-pages/man2/epoll_ctl.2:161
msgid ""
"Sets the one-shot behavior for the associated file descriptor.  This means "
"that after an event is pulled out with B<epoll_wait>(2)  the associated file "
"descriptor is internally disabled and no other events will be reported by "
"the B<epoll> interface.  The user must call B<epoll_ctl>()  with "
"B<EPOLL_CTL_MOD> to rearm the file descriptor with a new event mask."
msgstr ""
"Установить однократное получение для связанного файлового дескриптора. Это "
"означает, что после извлечения события с помощью B<epoll_wait>(2) со "
"связанным дескриптором приём отключается и о других событиях интерфейс "
"B<epoll> сообщать не будет. Пользователь должен вызвать B<epoll_ctl>() с "
"операцией B<EPOLL_CTL_MOD> для переустановки новой маски событий для "
"файлового дескриптора."

#. type: TP
#: man-pages/man2/epoll_ctl.2:161
#, no-wrap
msgid "B<EPOLLWAKEUP> (since Linux 3.5)"
msgstr "B<EPOLLWAKEUP> (начиная с Linux 3.5)"

#.  commit 4d7e30d98939a0340022ccd49325a3d70f7e0238
#. type: Plain text
#: man-pages/man2/epoll_ctl.2:189
msgid ""
"If B<EPOLLONESHOT> and B<EPOLLET> are clear and the process has the "
"B<CAP_BLOCK_SUSPEND> capability, ensure that the system does not enter "
"\"suspend\" or \"hibernate\" while this event is pending or being "
"processed.  The event is considered as being \"processed\" from the time "
"when it is returned by a call to B<epoll_wait>(2)  until the next call to "
"B<epoll_wait>(2)  on the same B<epoll>(7)  file descriptor, the closure of "
"that file descriptor, the removal of the event file descriptor with "
"B<EPOLL_CTL_DEL>, or the clearing of B<EPOLLWAKEUP> for the event file "
"descriptor with B<EPOLL_CTL_MOD>.  See also BUGS."
msgstr ""
"Если флаги B<EPOLLONESHOT> и B<EPOLLET> сброшены и процесс имеет мандат "
"B<CAP_BLOCK_SUSPEND>, то убедитесь, что система не находится в режиме "
"«suspend» или «hibernate», пока это событие ожидает обработки или "
"обрабатывается. Событие считается «обрабатывающимся» начиная с момента, "
"когда оно возвращается вызовом B<epoll_wait>(2) и до следующего вызова "
"B<epoll_wait>(2) для того же файлового дескриптора B<epoll>(7), закрытия "
"этого файлового дескриптора, удаление файлового дескриптора события с "
"помощью B<EPOLL_CTL_DEL> или сброс B<EPOLLWAKEUP> для файлового дескриптора "
"события с помощью B<EPOLL_CTL_MOD>. Также смотрите ДЕФЕКТЫ."

#. type: TP
#: man-pages/man2/epoll_ctl.2:189
#, no-wrap
msgid "B<EPOLLEXCLUSIVE> (since Linux 4.5)"
msgstr "B<EPOLLEXCLUSIVE> (начиная с Linux 4.5)"

#. type: Plain text
#: man-pages/man2/epoll_ctl.2:204
msgid ""
"Sets an exclusive wakeup mode for the epoll file descriptor that is being "
"attached to the target file descriptor, I<fd>.  When a wakeup event occurs "
"and multiple epoll file descriptors are attached to the same target file "
"using B<EPOLLEXCLUSIVE>, one or more of the epoll file descriptors will "
"receive an event with B<epoll_wait>(2).  The default in this scenario (when "
"B<EPOLLEXCLUSIVE> is not set) is for all epoll file descriptors to receive "
"an event.  B<EPOLLEXCLUSIVE> is thus useful for avoiding thundering herd "
"problems in certain scenarios."
msgstr ""
"Установить единоличный режим пробуждения файлового дескриптора epoll, "
"присоединённого к целевому файловому дескриптору I<fd>. При появлении "
"события пробуждения и к целевому файлу присоединены несколько файловых "
"дескрипторов epoll с помощью B<EPOLLEXCLUSIVE>, то события получат один или "
"несколько файловых дескрипторов epoll через B<epoll_wait>(2). По умолчанию в "
"этом случае (если B<EPOLLEXCLUSIVE> не установлен) все файловые дескрипторы "
"epoll получают событие. Таким образом B<EPOLLEXCLUSIVE> в некоторых случаях "
"помогает избежать проблем стадной работы."

#. type: Plain text
#: man-pages/man2/epoll_ctl.2:213
msgid ""
"If the same file descriptor is in multiple epoll instances, some with the "
"B<EPOLLEXCLUSIVE> flag, and others without, then events will be provided to "
"all epoll instances that did not specify B<EPOLLEXCLUSIVE>, and at least one "
"of the epoll instances that did specify B<EPOLLEXCLUSIVE>."
msgstr ""
"Если один файловый дескриптор указан в нескольких экземплярах epoll, и одни "
"имеют флаг B<EPOLLEXCLUSIVE>, а другие нет, то события получат все "
"экземпляры epoll, у которых не указан B<EPOLLEXCLUSIVE>, и, как минимум, "
"один экземпляр epoll, у которого есть задан B<EPOLLEXCLUSIVE>."

#. type: Plain text
#: man-pages/man2/epoll_ctl.2:232
msgid ""
"The following values may be specified in conjunction with B<EPOLLEXCLUSIVE>: "
"B<EPOLLIN>, B<EPOLLOUT>, B<EPOLLWAKEUP>, and B<EPOLLET>.  B<EPOLLHUP> and "
"B<EPOLLERR> can also be specified, but this is not required: as usual, these "
"events are always reported if they occur, regardless of whether they are "
"specified in I<events>.  Attempts to specify other values in I<events> yield "
"the error B<EINVAL>."
msgstr ""
"Следующие значения можно указывать вместе с B<EPOLLEXCLUSIVE>: B<EPOLLIN>, "
"B<EPOLLOUT>, B<EPOLLWAKEUP> и B<EPOLLET>. Также можно указывать B<EPOLLHUP> "
"и B<EPOLLERR>, но они не обязательны: как обычно, события всегда приходят, "
"если они возникают, независимо указаны ли они в I<events>. При указании "
"других значений в I<events> возникает ошибка B<EINVAL>."

#. type: Plain text
#: man-pages/man2/epoll_ctl.2:259
msgid ""
"B<EPOLLEXCLUSIVE> may be used only in an B<EPOLL_CTL_ADD> operation; "
"attempts to employ it with B<EPOLL_CTL_MOD> yield an error.  If "
"B<EPOLLEXCLUSIVE> has been set using B<epoll_ctl>(), then a subsequent "
"B<EPOLL_CTL_MOD> on the same I<epfd>,\\ I<fd> pair yields an error.  A call "
"to B<epoll_ctl>()  that specifies B<EPOLLEXCLUSIVE> in I<events> and "
"specifies the target file descriptor I<fd> as an epoll instance will "
"likewise fail.  The error in all of these cases is B<EINVAL>."
msgstr ""
"B<EPOLLEXCLUSIVE> можно использовать только в операции B<EPOLL_CTL_ADD>; "
"попытка использовать его в B<EPOLL_CTL_MOD> вызывает ошибку. Если "
"B<EPOLLEXCLUSIVE> установлен с помощью B<epoll_ctl>(), то последующая "
"B<EPOLL_CTL_MOD> с той же парой I<epfd>,\\ I<fd> вызывает ошибку. Вызов "
"B<epoll_ctl>(), в котором указан B<EPOLLEXCLUSIVE> в I<events> и целевой "
"файловый дескриптор I<fd> в качестве экземпляра epoll, также вызывает "
"ошибку. Во всех случаях возникает ошибка B<EINVAL>."

#. type: Plain text
#: man-pages/man2/epoll_ctl.2:268
msgid ""
"When successful, B<epoll_ctl>()  returns zero.  When an error occurs, "
"B<epoll_ctl>()  returns -1 and I<errno> is set appropriately."
msgstr ""
"При успешном выполнении B<epoll_ctl>() возвращается ноль. При возникновении "
"ошибок B<epoll_ctl>() возвращает -1 и устанавливает I<errno> в "
"соответствующее значение."

#. type: Plain text
#: man-pages/man2/epoll_ctl.2:275
msgid "I<epfd> or I<fd> is not a valid file descriptor."
msgstr ""
"Значение I<epfd> или I<fd> не является правильным файловым дескриптором."

#. type: TP
#: man-pages/man2/epoll_ctl.2:275
#, no-wrap
msgid "B<EEXIST>"
msgstr "B<EEXIST>"

#. type: Plain text
#: man-pages/man2/epoll_ctl.2:283
msgid ""
"I<op> was B<EPOLL_CTL_ADD>, and the supplied file descriptor I<fd> is "
"already registered with this epoll instance."
msgstr ""
"Значение I<op> равно B<EPOLL_CTL_ADD>, и указанный файловый дескриптор I<fd> "
"уже зарегистрирован в данном экземпляре epoll."

#. type: Plain text
#: man-pages/man2/epoll_ctl.2:296
msgid ""
"I<epfd> is not an B<epoll> file descriptor, or I<fd> is the same as I<epfd>, "
"or the requested operation I<op> is not supported by this interface."
msgstr ""
"Значение I<epfd> не является файловым дескриптором B<epoll>, или значение "
"I<fd> равно I<epfd>, или запрашиваемая операция I<op> не поддерживается "
"данным интерфейсом."

#. type: Plain text
#: man-pages/man2/epoll_ctl.2:302
msgid ""
"An invalid event type was specified along with B<EPOLLEXCLUSIVE> in "
"I<events>."
msgstr ""
"Указан недопустимый тип события, так как в I<events> установлен "
"B<EPOLLEXCLUSIVE>."

#. type: Plain text
#: man-pages/man2/epoll_ctl.2:311
msgid "I<op> was B<EPOLL_CTL_MOD> and I<events> included B<EPOLLEXCLUSIVE>."
msgstr ""
"Значение I<op> равно B<EPOLL_CTL_MOD> и I<events> содержит B<EPOLLEXCLUSIVE>."

#. type: Plain text
#: man-pages/man2/epoll_ctl.2:321
msgid ""
"I<op> was B<EPOLL_CTL_MOD> and the B<EPOLLEXCLUSIVE> flag has previously "
"been applied to this I<epfd>,\\ I<fd> pair."
msgstr ""
"Значение I<op> равно B<EPOLL_CTL_MOD>, а ранее для этой пары I<epfd>,\\ "
"I<fd> был применён флаг B<EPOLLEXCLUSIVE>."

#. type: Plain text
#: man-pages/man2/epoll_ctl.2:329
msgid ""
"B<EPOLLEXCLUSIVE> was specified in I<event> and I<fd> refers to an epoll "
"instance."
msgstr ""
"Флаг B<EPOLLEXCLUSIVE> указан в I<event> и I<fd> ссылается на экземпляр "
"epoll."

#. type: Plain text
#: man-pages/man2/epoll_ctl.2:336
msgid ""
"I<fd> refers to an epoll instance and this B<EPOLL_CTL_ADD> operation would "
"result in a circular loop of epoll instances monitoring one another."
msgstr ""
"Значение I<fd> ссылается на экземпляр epoll и эта операция B<EPOLL_CTL_ADD> "
"привела бы к зацикливанию экземпляров epoll, отслеживающих один другого."

#. type: Plain text
#: man-pages/man2/epoll_ctl.2:346
msgid ""
"I<op> was B<EPOLL_CTL_MOD> or B<EPOLL_CTL_DEL>, and I<fd> is not registered "
"with this epoll instance."
msgstr ""
"В I<op> было указано B<EPOLL_CTL_MOD> или B<EPOLL_CTL_DEL>, а I<fd> не было "
"зарегистрировано в данном экземпляре epoll."

#. type: Plain text
#: man-pages/man2/epoll_ctl.2:351
msgid ""
"There was insufficient memory to handle the requested I<op> control "
"operation."
msgstr ""
"Недостаточно памяти для обработки запрошенной управляющей операции I<op>."

#. type: TP
#: man-pages/man2/epoll_ctl.2:351
#, no-wrap
msgid "B<ENOSPC>"
msgstr "B<ENOSPC>"

#. type: Plain text
#: man-pages/man2/epoll_ctl.2:361
msgid ""
"The limit imposed by I</proc/sys/fs/epoll/max_user_watches> was encountered "
"while trying to register (B<EPOLL_CTL_ADD>)  a new file descriptor on an "
"epoll instance.  See B<epoll>(7)  for further details."
msgstr ""
"При попытке регистрации (B<EPOLL_CTL_ADD>) нового файлового дескриптора в "
"экземпляре достигнут предел, накладываемый I</proc/sys/fs/epoll/"
"max_user_watches>. Подробней см. в B<epoll>(7)."

#. type: Plain text
#: man-pages/man2/epoll_ctl.2:370
msgid ""
"The target file I<fd> does not support B<epoll>.  This error can occur if "
"I<fd> refers to, for example, a regular file or a directory."
msgstr ""
"Файл назначения I<fd> не поддерживает B<epoll>. Эта ошибка может возникнуть, "
"если I<fd> ссылается на, например, обычный файл или каталог."

#.  To be precise: kernel 2.5.44.
#.  The interface should be finalized by Linux kernel 2.5.66.
#. type: Plain text
#: man-pages/man2/epoll_ctl.2:375
msgid "B<epoll_ctl>()  was added to the kernel in version 2.6."
msgstr "Системный вызов B<epoll_ctl>() был добавлен в ядро версии 2.6."

#. type: Plain text
#: man-pages/man2/epoll_ctl.2:379
msgid ""
"B<epoll_ctl>()  is Linux-specific.  Library support is provided in glibc "
"starting with version 2.3.2."
msgstr ""
"Вызов B<epoll_ctl>() есть только в Linux. В glibc соответствующая функция "
"появилась в версии 2.3.2."

#. type: Plain text
#: man-pages/man2/epoll_ctl.2:384
msgid ""
"The B<epoll> interface supports all file descriptors that support B<poll>(2)."
msgstr ""
"Интерфейс B<epoll> поддерживает все файловые дескрипторы, которые "
"поддерживает B<poll>(2)."

#. type: Plain text
#: man-pages/man2/epoll_ctl.2:398
msgid ""
"In kernel versions before 2.6.9, the B<EPOLL_CTL_DEL> operation required a "
"non-null pointer in I<event>, even though this argument is ignored.  Since "
"Linux 2.6.9, I<event> can be specified as NULL when using B<EPOLL_CTL_DEL>.  "
"Applications that need to be portable to kernels before 2.6.9 should specify "
"a non-null pointer in I<event>."
msgstr ""
"В ядрах до версии 2.6.9 для операции B<EPOLL_CTL_DEL> в I<event> требовался "
"указатель со значением не равным null, хотя этот аргумент игнорировался. "
"Начиная с Linux 2.6.9, при B<EPOLL_CTL_DEL> в I<event> можно указывать NULL. "
"В переносимых приложениях, которые должны быть работоспособными в системах "
"на ядрах до 2.6.9, в I<event> нужно указывать указатель со значением не "
"равным null."

#.  commit a8159414d7e3af7233e7a5a82d1c5d85379bd75c (behavior change)
#.  https://lwn.net/Articles/520198/
#. type: Plain text
#: man-pages/man2/epoll_ctl.2:425
msgid ""
"If B<EPOLLWAKEUP> is specified in I<flags>, but the caller does not have the "
"B<CAP_BLOCK_SUSPEND> capability, then the B<EPOLLWAKEUP> flag is I<silently "
"ignored>.  This unfortunate behavior is necessary because no validity checks "
"were performed on the I<flags> argument in the original implementation, and "
"the addition of the B<EPOLLWAKEUP> with a check that caused the call to fail "
"if the caller did not have the B<CAP_BLOCK_SUSPEND> capability caused a "
"breakage in at least one existing user-space application that happened to "
"randomly (and uselessly) specify this bit.  A robust application should "
"therefore double check that it has the B<CAP_BLOCK_SUSPEND> capability if "
"attempting to use the B<EPOLLWAKEUP> flag."
msgstr ""
"Если в I<flags> указан B<EPOLLWAKEUP>, но вызывающий не имеет мандата "
"B<CAP_BLOCK_SUSPEND>, то флаг B<EPOLLWAKEUP> I<просто игнорируется>. Такое "
"неуместное поведение необходимо, так как в первоначальной реализации не "
"выполнялась проверка корректности аргумента I<flags>, и добавление "
"B<EPOLLWAKEUP> с проверкой того, что вызов завершился с ошибкой, если "
"вызывающий не имеет мандата B<CAP_BLOCK_SUSPEND>, привело к поломке не "
"одного существующего пользовательского приложения, которое произвольно "
"устанавливало (и зря) этот бит. Корректное приложение должно дважды "
"проверить, что имеет мандат B<CAP_BLOCK_SUSPEND>, если пытается использовать "
"флаг B<EPOLLWAKEUP>."

#. type: Plain text
#: man-pages/man2/epoll_ctl.2:429
msgid "B<epoll_create>(2), B<epoll_wait>(2), B<poll>(2), B<epoll>(7)"
msgstr "B<epoll_create>(2), B<epoll_wait>(2), B<poll>(2), B<epoll>(7)"

#. type: TH
#: man-pages/man2/epoll_create.2:24
#, no-wrap
msgid "EPOLL_CREATE"
msgstr "EPOLL_CREATE"

#. type: Plain text
#: man-pages/man2/epoll_create.2:27
msgid "epoll_create, epoll_create1 - open an epoll file descriptor"
msgstr "epoll_create, epoll_create1 - открывает файловый дескриптор epoll"

#. type: Plain text
#: man-pages/man2/epoll_create.2:30
#, no-wrap
msgid "B<#include E<lt>sys/epoll.hE<gt>>\n"
msgstr "B<#include E<lt>sys/epoll.hE<gt>>\n"

#. type: Plain text
#: man-pages/man2/epoll_create.2:33
#, no-wrap
msgid ""
"B<int epoll_create(int >I<size>B<);>\n"
"B<int epoll_create1(int >I<flags>B<);>\n"
msgstr ""
"B<int epoll_create(int >I<size>B<);>\n"
"B<int epoll_create1(int >I<flags>B<);>\n"

#. type: Plain text
#: man-pages/man2/epoll_create.2:42
msgid ""
"B<epoll_create>()  creates a new B<epoll>(7)  instance.  Since Linux 2.6.8, "
"the I<size> argument is ignored, but must be greater than zero; see NOTES "
"below."
msgstr ""
"Вызов B<epoll_create>() создаёт новый экземпляр B<epoll>(7). Начиная с Linux "
"2.6.8 аргумент I<size> игнорируется, но должен быть больше нуля; смотрите "
"ЗАМЕЧАНИЯ далее."

#. type: Plain text
#: man-pages/man2/epoll_create.2:55
msgid ""
"B<epoll_create>()  returns a file descriptor referring to the new epoll "
"instance.  This file descriptor is used for all the subsequent calls to the "
"B<epoll> interface.  When no longer required, the file descriptor returned "
"by B<epoll_create>()  should be closed by using B<close>(2).  When all file "
"descriptors referring to an epoll instance have been closed, the kernel "
"destroys the instance and releases the associated resources for reuse."
msgstr ""
"B<epoll_create>() возвращает дескриптор файла, указывающий на новый "
"экземпляр epoll. Он используется для всех последующих вызовов к интерфейсу "
"B<epoll>. По окончанию использования дескриптор файла, возвращаемый "
"B<epoll_create>(), должен быть закрыт с помощью B<close>(2). Когда все "
"файловые дескрипторы, указывающие на экземпляр epoll, будут закрыты, ядро "
"уничтожит экземпляр и освободит связанные с ним ресурсы для повторного "
"использования."

#. type: SS
#: man-pages/man2/epoll_create.2:55
#, no-wrap
msgid "epoll_create1()"
msgstr "epoll_create1()"

#. type: Plain text
#: man-pages/man2/epoll_create.2:67
msgid ""
"If I<flags> is 0, then, other than the fact that the obsolete I<size> "
"argument is dropped, B<epoll_create1>()  is the same as B<epoll_create>().  "
"The following value can be included in I<flags> to obtain different behavior:"
msgstr ""
"Если I<flags> равно 0, то, если не учитывать, что устаревший аргумент "
"I<size> не используется, B<epoll_create1>() выполняет тоже что и "
"B<epoll_create>(). Для различного поведения во I<flags> могут включаться:"

#. type: TP
#: man-pages/man2/epoll_create.2:67
#, no-wrap
msgid "B<EPOLL_CLOEXEC>"
msgstr "B<EPOLL_CLOEXEC>"

#. type: Plain text
#: man-pages/man2/epoll_create.2:84
msgid ""
"On success, these system calls return a nonnegative file descriptor.  On "
"error, -1 is returned, and I<errno> is set to indicate the error."
msgstr ""
"При успешном выполнении данные системные вызовы возвращают неотрицательный "
"файловый дескриптор. При ошибке возвращается -1 и I<errno> устанавливается в "
"соответствующее значение."

#. type: Plain text
#: man-pages/man2/epoll_create.2:89
msgid "I<size> is not positive."
msgstr "Аргумент I<size> содержит отрицательное значение."

#. type: Plain text
#: man-pages/man2/epoll_create.2:94
msgid "(B<epoll_create1>())  Invalid value specified in I<flags>."
msgstr "(B<epoll_create1>()) Указано неверное значение в I<flags>."

#. type: Plain text
#: man-pages/man2/epoll_create.2:102
msgid ""
"The per-user limit on the number of epoll instances imposed by I</proc/sys/"
"fs/epoll/max_user_instances> was encountered.  See B<epoll>(7)  for further "
"details."
msgstr ""
"Был достигнут пользовательский предел на количество экземпляров epoll, "
"налагаемый I</proc/sys/fs/epoll/max_user_instances>. Подробней см. в "
"B<epoll>(7)."

#. type: Plain text
#: man-pages/man2/epoll_create.2:111
msgid "There was insufficient memory to create the kernel object."
msgstr "Недостаточно памяти для создания объекта ядра."

#. type: Plain text
#: man-pages/man2/epoll_create.2:115
msgid ""
"B<epoll_create>()  was added to the kernel in version 2.6.  Library support "
"is provided in glibc starting with version 2.3.2."
msgstr ""
"Вызов B<epoll_create>() был добавлен в ядро версии 2.6. В glibc "
"соответствующая функция появилась в версии 2.3.2."

#.  To be precise: kernel 2.5.44.
#.  The interface should be finalized by Linux kernel 2.5.66.
#. type: Plain text
#: man-pages/man2/epoll_create.2:121
msgid ""
"B<epoll_create1>()  was added to the kernel in version 2.6.27.  Library "
"support is provided in glibc starting with version 2.9."
msgstr ""
"Вызов B<epoll_create1>() был добавлен в ядро версии 2.6.27. В glibc "
"соответствующая функция появилась в версии 2.9."

#. type: Plain text
#: man-pages/man2/epoll_create.2:124
msgid "B<epoll_create>()  is Linux-specific."
msgstr "Вызов B<epoll_create>() есть только в Linux."

#. type: Plain text
#: man-pages/man2/epoll_create.2:147
msgid ""
"In the initial B<epoll_create>()  implementation, the I<size> argument "
"informed the kernel of the number of file descriptors that the caller "
"expected to add to the B<epoll> instance.  The kernel used this information "
"as a hint for the amount of space to initially allocate in internal data "
"structures describing events.  (If necessary, the kernel would allocate more "
"space if the caller's usage exceeded the hint given in I<size>.)  Nowadays, "
"this hint is no longer required (the kernel dynamically sizes the required "
"data structures without needing the hint), but I<size> must still be greater "
"than zero, in order to ensure backward compatibility when new B<epoll> "
"applications are run on older kernels."
msgstr ""
"В первоначальной реализации B<epoll_create>() аргумент I<size> уведомлял "
"ядро о количестве файловых дескрипторов, которые вызывающий предполагал "
"добавить в экземпляр B<epoll>. Ядро использовало эту информацию для оценки "
"требуемого количества памяти при начальном размещении внутренних структур "
"данных, описывающих события (если требовалось, ядро выделяло больше места, "
"если вызывающий превышал значение, указанное в I<size>). Сейчас, эта оценка "
"больше не требуется (ядро динамически выделяет место под структуры данных), "
"но значение I<size> всё равно должно быть больше нуля — для обеспечения "
"обратной совместимости приложений с новым B<epoll> для работы на старых "
"ядрах."

#. type: Plain text
#: man-pages/man2/epoll_create.2:151
msgid "B<close>(2), B<epoll_ctl>(2), B<epoll_wait>(2), B<epoll>(7)"
msgstr "B<close>(2), B<epoll_ctl>(2), B<epoll_wait>(2), B<epoll>(7)"

#. type: TH
#: man-pages/man2/epoll_wait.2:22
#, no-wrap
msgid "EPOLL_WAIT"
msgstr "EPOLL_WAIT"

#. type: Plain text
#: man-pages/man2/epoll_wait.2:25
msgid ""
"epoll_wait, epoll_pwait - wait for an I/O event on an epoll file descriptor"
msgstr ""
"epoll_wait, epoll_pwait - ждать события ввода/вывода на файловом дескрипторе "
"epoll"

#. type: Plain text
#: man-pages/man2/epoll_wait.2:34
#, no-wrap
msgid ""
"B<int epoll_wait(int >I<epfd>B<, struct epoll_event *>I<events>B<,>\n"
"B<               int >I<maxevents>B<, int >I<timeout>B<);>\n"
"B<int epoll_pwait(int >I<epfd>B<, struct epoll_event *>I<events>B<,>\n"
"B<               int >I<maxevents>B<, int >I<timeout>B<,>\n"
"B<               const sigset_t *>I<sigmask>B<);>\n"
msgstr ""
"B<int epoll_wait(int >I<epfd>B<, struct epoll_event *>I<events>B<,>\n"
"B<               int >I<maxevents>B<, int >I<timeout>B<);>\n"
"B<int epoll_pwait(int >I<epfd>B<, struct epoll_event *>I<events>B<,>\n"
"B<               int >I<maxevents>B<, int >I<timeout>B<,>\n"
"B<               const sigset_t *>I<sigmask>B<);>\n"

#. type: Plain text
#: man-pages/man2/epoll_wait.2:52
msgid ""
"The B<epoll_wait>()  system call waits for events on the B<epoll>(7)  "
"instance referred to by the file descriptor I<epfd>.  The memory area "
"pointed to by I<events> will contain the events that will be available for "
"the caller.  Up to I<maxevents> are returned by B<epoll_wait>().  The "
"I<maxevents> argument must be greater than zero."
msgstr ""
"Системный вызов B<epoll_wait>() ожидает события на экземпляре B<epoll>(7), "
"на который указывает файловый дескриптор I<epfd>. Область памяти, на которую "
"указывает I<events>, будет содержать события, доступные для вызываемого. "
"Вызов B<epoll_wait>() может вернуть до I<maxevents> событий. Параметр "
"I<maxevents> должен быть больше нуля."

#. type: Plain text
#: man-pages/man2/epoll_wait.2:62
msgid ""
"The I<timeout> argument specifies the number of milliseconds that "
"B<epoll_wait>()  will block.  Time is measured against the "
"B<CLOCK_MONOTONIC> clock.  The call will block until either:"
msgstr ""
"В аргументе I<timeout> указывается количество миллисекунд, на которые будет "
"заблокирован B<epoll_wait>(). Время отслеживается по часам "
"B<CLOCK_MONOTONIC>. Вызов будет заблокирован пока:"

#. type: Plain text
#: man-pages/man2/epoll_wait.2:64
msgid "a file descriptor delivers an event;"
msgstr "событие не будет доставлено в файловый дескриптор;"

#. type: Plain text
#: man-pages/man2/epoll_wait.2:66
msgid "the call is interrupted by a signal handler; or"
msgstr "вызов не прервётся обработчиком сигнала;"

#. type: Plain text
#: man-pages/man2/epoll_wait.2:68
msgid "the timeout expires."
msgstr "не истечёт время ожидания."

#. type: Plain text
#: man-pages/man2/epoll_wait.2:83
msgid ""
"Note that the I<timeout> interval will be rounded up to the system clock "
"granularity, and kernel scheduling delays mean that the blocking interval "
"may overrun by a small amount.  Specifying a I<timeout> of -1 causes "
"B<epoll_wait>()  to block indefinitely, while specifying a I<timeout> equal "
"to zero cause B<epoll_wait>()  to return immediately, even if no events are "
"available."
msgstr ""
"Заметим, что интервал I<timeout> будет округлён в соответствии с точностью "
"системных часов, а задержки ядерного планирования приведут к тому, что "
"интервал блокировки может быть немного больше. Если присвоить I<timeout> "
"значение -1, то B<epoll_wait>() блокируется навсегда; если значение "
"I<timeout> равно 0, то B<epoll_wait>() сразу завершает работу, даже если "
"никаких событий не произошло."

#. type: Plain text
#: man-pages/man2/epoll_wait.2:87
msgid "The I<struct epoll_event> is defined as:"
msgstr "Структура I<struct epoll_event> определена так:"

#. type: Plain text
#: man-pages/man2/epoll_wait.2:96
#, no-wrap
msgid ""
"typedef union epoll_data {\n"
"    void    *ptr;\n"
"    int      fd;\n"
"    uint32_t u32;\n"
"    uint64_t u64;\n"
"} epoll_data_t;\n"
msgstr ""
"typedef union epoll_data {\n"
"    void    *ptr;\n"
"    int      fd;\n"
"    uint32_t u32;\n"
"    uint64_t u64;\n"
"} epoll_data_t;\n"

#. type: Plain text
#: man-pages/man2/epoll_wait.2:101
#, no-wrap
msgid ""
"struct epoll_event {\n"
"    uint32_t     events;    /* Epoll events */\n"
"    epoll_data_t data;      /* User data variable */\n"
"};\n"
msgstr ""
"struct epoll_event {\n"
"    uint32_t     events;    /* События epoll */\n"
"    epoll_data_t data;      /* Переменная для данных пользователя */\n"
"};\n"

#. type: Plain text
#: man-pages/man2/epoll_wait.2:114
msgid ""
"The I<data> field of each returned structure contains the same data as was "
"specified in the most recent call to B<epoll_ctl>(2)  (B<EPOLL_CTL_ADD>, "
"B<EPOLL_CTL_MOD>)  for the corresponding open file description.  The "
"I<events> field contains the returned event bit field."
msgstr ""
"Поле I<data> в каждой возвращаемой структуре содержит те же данные, которые "
"были указаны в самом последнем вызове B<epoll_ctl>(2) (B<EPOLL_CTL_ADD>, "
"B<EPOLL_CTL_MOD>) для соответствующего открытого описания файла. В поле "
"I<events> содержится битовое поле возвращаемого события."

#. type: SS
#: man-pages/man2/epoll_wait.2:114
#, no-wrap
msgid "epoll_pwait()"
msgstr "epoll_pwait()"

#. type: Plain text
#: man-pages/man2/epoll_wait.2:128
msgid ""
"The relationship between B<epoll_wait>()  and B<epoll_pwait>()  is analogous "
"to the relationship between B<select>(2)  and B<pselect>(2): like "
"B<pselect>(2), B<epoll_pwait>()  allows an application to safely wait until "
"either a file descriptor becomes ready or until a signal is caught."
msgstr ""
"Отношения между B<epoll_wait>() и B<epoll_pwait>() аналогичны родству "
"B<select>(2) и B<pselect>(2): как B<pselect>(2), B<epoll_pwait>() позволяет "
"приложению безопасно ждать, пока файловый дескриптор не станет готов или "
"пока не будет получен сигнал."

#. type: Plain text
#: man-pages/man2/epoll_wait.2:132
msgid "The following B<epoll_pwait>()  call:"
msgstr "Вызов B<epoll_pwait>():"

#. type: Plain text
#: man-pages/man2/epoll_wait.2:136
#, no-wrap
msgid "ready = epoll_pwait(epfd, &events, maxevents, timeout, &sigmask);\n"
msgstr "ready = epoll_pwait(epfd, &events, maxevents, timeout, &sigmask);\n"

#. type: Plain text
#: man-pages/man2/epoll_wait.2:142
msgid "is equivalent to I<atomically> executing the following calls:"
msgstr "эквивалентен I<атомарному> выполнению следующих вызовов:"

#. type: Plain text
#: man-pages/man2/epoll_wait.2:146
#, no-wrap
msgid "sigset_t origmask;\n"
msgstr "sigset_t origmask;\n"

#. type: Plain text
#: man-pages/man2/epoll_wait.2:150
#, no-wrap
msgid ""
"pthread_sigmask(SIG_SETMASK, &sigmask, &origmask);\n"
"ready = epoll_wait(epfd, &events, maxevents, timeout);\n"
"pthread_sigmask(SIG_SETMASK, &origmask, NULL);\n"
msgstr ""
"pthread_sigmask(SIG_SETMASK, &sigmask, &origmask);\n"
"ready = epoll_wait(epfd, &events, maxevents, timeout);\n"
"pthread_sigmask(SIG_SETMASK, &origmask, NULL);\n"

#. type: Plain text
#: man-pages/man2/epoll_wait.2:159
msgid ""
"The I<sigmask> argument may be specified as NULL, in which case "
"B<epoll_pwait>()  is equivalent to B<epoll_wait>()."
msgstr ""
"Аргумент I<sigmask> может быть равен NULL \\(em в этом случае "
"B<epoll_pwait>() эквивалентен B<epoll_wait>()."

#. type: Plain text
#: man-pages/man2/epoll_wait.2:171
msgid ""
"When successful, B<epoll_wait>()  returns the number of file descriptors "
"ready for the requested I/O, or zero if no file descriptor became ready "
"during the requested I<timeout> milliseconds.  When an error occurs, "
"B<epoll_wait>()  returns -1 and I<errno> is set appropriately."
msgstr ""
"При нормальном выполнении B<epoll_wait>() возвращает количество файловых "
"дескрипторов, готовых для запросов ввода-вывода, или ноль, если ни один "
"файловый дескриптор не стал готов за отведённые I<timeout> миллисекунд. При "
"возникновении ошибки B<epoll_wait>() возвращает -1 и устанавливает I<errno> "
"в соответствующее значение."

#. type: Plain text
#: man-pages/man2/epoll_wait.2:176
msgid "I<epfd> is not a valid file descriptor."
msgstr "Значение I<epfd> не является правильным файловым дескриптором."

#. type: Plain text
#: man-pages/man2/epoll_wait.2:181
msgid ""
"The memory area pointed to by I<events> is not accessible with write "
"permissions."
msgstr "Память, указанная I<events>, недоступна на запись из-за прав доступа."

#. type: TP
#: man-pages/man2/epoll_wait.2:181
#, no-wrap
msgid "B<EINTR>"
msgstr "B<EINTR>"

#. type: Plain text
#: man-pages/man2/epoll_wait.2:188
msgid ""
"The call was interrupted by a signal handler before either (1) any of the "
"requested events occurred or (2) the I<timeout> expired; see B<signal>(7)."
msgstr ""
"Вызов был прерван обработчиком сигнала до возникновения любого из "
"запрошенных событий или истечения I<timeout>; см. B<signal>(7)."

#. type: Plain text
#: man-pages/man2/epoll_wait.2:196
msgid ""
"I<epfd> is not an B<epoll> file descriptor, or I<maxevents> is less than or "
"equal to zero."
msgstr ""
"I<epfd> не является файловым дескриптором B<epoll>, или I<maxevents> меньше "
"или равно нулю."

#.  To be precise: kernel 2.5.44.
#.  The interface should be finalized by Linux kernel 2.5.66.
#. type: Plain text
#: man-pages/man2/epoll_wait.2:202
msgid ""
"B<epoll_wait>()  was added to the kernel in version 2.6.  Library support is "
"provided in glibc starting with version 2.3.2."
msgstr ""
"Вызов B<epoll_wait>() был добавлен в ядро версии 2.6. В glibc "
"соответствующая функция появилась в версии 2.3.2."

#. type: Plain text
#: man-pages/man2/epoll_wait.2:206
msgid ""
"B<epoll_pwait>()  was added to Linux in kernel 2.6.19.  Library support is "
"provided in glibc starting with version 2.6."
msgstr ""
"Вызов B<epoll_pwait>() был добавлен в ядро Linux 2.6.19. В glibc "
"соответствующая функция появилась в версии 2.6."

#. type: Plain text
#: man-pages/man2/epoll_wait.2:209
msgid "B<epoll_wait>()  is Linux-specific."
msgstr "Вызов B<epoll_wait>() есть только в Linux."

#. type: Plain text
#: man-pages/man2/epoll_wait.2:219
msgid ""
"While one thread is blocked in a call to B<epoll_pwait>(), it is possible "
"for another thread to add a file descriptor to the waited-upon B<epoll> "
"instance.  If the new file descriptor becomes ready, it will cause the "
"B<epoll_wait>()  call to unblock."
msgstr ""
"Пока одна нить блокирована в вызове B<epoll_pwait>(), в другой нити возможно "
"добавить файловый дескриптор, который будет ожидаться экземпляром B<epoll>. "
"Как только новый файловый дескриптор станет готовым, это разблокирует вызов "
"B<epoll_wait>()."

#. type: Plain text
#: man-pages/man2/epoll_wait.2:231
msgid ""
"If more than I<maxevents> file descriptors are ready when B<epoll_wait>()  "
"is called, then successive B<epoll_wait>()  calls will round robin through "
"the set of ready file descriptors.  This behavior helps avoid starvation "
"scenarios, where a process fails to notice that additional file descriptors "
"are ready because it focuses on a set of file descriptors that are already "
"known to be ready."
msgstr ""
"Если готово более I<maxevents> файловых дескрипторов при вызове "
"B<epoll_wait>(), то последующие вызовы B<epoll_wait>() циклически обработают "
"весь набор готовых файловых дескрипторов. Такое поведение помогает избежать "
"голодания — когда процесс не уведомляется, что дополнительные файловые "
"дескрипторы готовы, так как он нацелен на набор файловых дескрипторов, про "
"которые уже известно об их готовности."

#. type: Plain text
#: man-pages/man2/epoll_wait.2:241
msgid ""
"Note that it is possible to call B<epoll_wait>()  on an B<epoll> instance "
"whose interest list is currently empty (or whose interest list becomes empty "
"because file descriptors are closed or removed from the interest in another "
"thread).  The call will block until some file descriptor is later added to "
"the interest list (in another thread) and that file descriptor becomes ready."
msgstr ""
"Заметим, что возможно вызвать B<epoll_wait>() для экземпляра B<epoll>, чей "
"список interest ещё пуст (или чей список interest станет пустым, так как "
"файловые дескрипторы закрыты или удалены из interest в другой нити). Вызов "
"будет заблокирован до тех пор, пока какой-нибудь файловый дескриптор не "
"будет добавлен в список interest (в другой нити) и этот файлоый дескриптор "
"не станет готовым."

#. type: Plain text
#: man-pages/man2/epoll_wait.2:253
msgid ""
"In kernels before 2.6.37, a I<timeout> value larger than approximately "
"I<LONG_MAX / HZ> milliseconds is treated as -1 (i.e., infinity).  Thus, for "
"example, on a system where I<sizeof(long)> is 4 and the kernel I<HZ> value "
"is 1000, this means that timeouts greater than 35.79 minutes are treated as "
"infinity."
msgstr ""
"В ядрах до версии 2.6.37, если значение I<timeout> больше чем "
"приблизительное I<LONG_MAX / HZ> секунд, то оно воспринимается как -1 (т.е., "
"бесконечность). То есть, например, в системе, где I<sizeof(long)> равно 4 и "
"значение ядра I<HZ> равно 1000, задержка более 35,79 минут считается "
"бесконечностью."

#. type: Plain text
#: man-pages/man2/epoll_wait.2:266
msgid ""
"The raw B<epoll_pwait>()  system call has a sixth argument, I<size_t "
"sigsetsize>, which specifies the size in bytes of the I<sigmask> argument.  "
"The glibc B<epoll_pwait>()  wrapper function specifies this argument as a "
"fixed value (equal to I<sizeof(sigset_t)>)."
msgstr ""
"Ядерный системный вызов B<epoll_pwait>() имеет шестой аргумент, I<size_t "
"sigsetsize>, в котором указывается размер аргумента I<sigmask> в байтах. В "
"обёрточной функции glibc B<epoll_pwait>() в этом аргументе передаётся "
"постоянная величина (равная I<sizeof(sigset_t)>)."

#. type: Plain text
#: man-pages/man2/epoll_wait.2:269
msgid "B<epoll_create>(2), B<epoll_ctl>(2), B<epoll>(7)"
msgstr "B<epoll_create>(2), B<epoll_ctl>(2), B<epoll>(7)"

#. type: TH
#: man-pages/man5/elf.5:35
#, no-wrap
msgid "ELF"
msgstr "ELF"

#. type: Plain text
#: man-pages/man5/elf.5:38
msgid "elf - format of Executable and Linking Format (ELF) files"
msgstr "elf - формат исполняемых и компонуемых файлов (ELF)"

#.  .B #include <elf_abi.h>
#. type: Plain text
#: man-pages/man5/elf.5:42
#, no-wrap
msgid "B<#include E<lt>elf.hE<gt>>\n"
msgstr "B<#include E<lt>elf.hE<gt>>\n"

#. type: Plain text
#: man-pages/man5/elf.5:50
msgid ""
"The header file I<E<lt>elf.hE<gt>> defines the format of ELF executable "
"binary files.  Amongst these files are normal executable files, relocatable "
"object files, core files, and shared objects."
msgstr ""
"В заголовочном файле I<E<lt>elf.hE<gt>> определён формат ELF для исполняемых "
"двоичных файлов. К таким файлам относятся обычные исполняемые файлы, "
"перемещаемые объектные файлы, core-файлы и общие объекты."

#. type: Plain text
#: man-pages/man5/elf.5:59
msgid ""
"An executable file using the ELF file format consists of an ELF header, "
"followed by a program header table or a section header table, or both.  The "
"ELF header is always at offset zero of the file.  The program header table "
"and the section header table's offset in the file are defined in the ELF "
"header.  The two tables describe the rest of the particularities of the file."
msgstr ""
"Исполняемый файл в формате ELF состоит из заголовка ELF, таблицы заголовков "
"программы или таблицы заголовков разделов (или обеих таблиц). Заголовок ELF "
"всегда расположен в начале файла. Расположение таблицы заголовков программы "
"и таблицы заголовков разделов задаётся в заголовке ELF. В этих двух таблицах "
"описывается всё остальное содержимое файла."

#.  Applications which wish to process ELF binary files for their native
#.  architecture only should include
#.  .I <elf_abi.h>
#.  in their source code.
#.  These applications should need to refer to
#.  all the types and structures by their generic names
#.  "Elf_xxx"
#.  and to the macros by
#.  ELF_xxx".
#.  Applications written this way can be compiled on any architecture,
#.  regardless of whether the host is 32-bit or 64-bit.
#.  .PP
#.  Should an application need to process ELF files of an unknown
#.  architecture, then the application needs to explicitly use either
#.  "Elf32_xxx"
#.  or
#.  "Elf64_xxx"
#.  type and structure names.
#.  Likewise, the macros need to be identified by
#.  "ELF32_xxx"
#.  or
#.  "ELF64_xxx".
#.  .PP
#. type: Plain text
#: man-pages/man5/elf.5:87
msgid ""
"This header file describes the above mentioned headers as C structures and "
"also includes structures for dynamic sections, relocation sections and "
"symbol tables."
msgstr ""
"Данный заголовочный файл описывает вышеупомянутые заголовки в виде структур "
"C, а также включает описание структур динамических разделов, разделов "
"перемещений и таблиц символов."

#. type: SS
#: man-pages/man5/elf.5:87
#, no-wrap
msgid "Basic types"
msgstr "Базовые типы"

#. type: Plain text
#: man-pages/man5/elf.5:99
msgid ""
"The following types are used for N-bit architectures (N=32,64, I<ElfN> "
"stands for I<Elf32> or I<Elf64>, I<uintN_t> stands for I<uint32_t> or "
"I<uint64_t>):"
msgstr ""
"Для каждой N-битной архитектуры используются следующие типы (N=32,64; "
"I<ElfN> может быть I<Elf32> или I<Elf64>; I<uintN_t> может быть I<uint32_t> "
"или I<uint64_t>):"

#.  Elf32_Size  Unsigned object size
#. type: Plain text
#: man-pages/man5/elf.5:113
#, no-wrap
msgid ""
"ElfN_Addr       Unsigned program address, uintN_t\n"
"ElfN_Off        Unsigned file offset, uintN_t\n"
"ElfN_Section    Unsigned section index, uint16_t\n"
"ElfN_Versym     Unsigned version symbol information, uint16_t\n"
"Elf_Byte        unsigned char\n"
"ElfN_Half       uint16_t\n"
"ElfN_Sword      int32_t\n"
"ElfN_Word       uint32_t\n"
"ElfN_Sxword     int64_t\n"
"ElfN_Xword      uint64_t\n"
msgstr ""
"ElfN_Addr       Беззнаковый адрес программы, uintN_t\n"
"ElfN_Off        Беззнаковое смещение в файле, uintN_t\n"
"ElfN_Section    Беззнаковый индекс раздела, uint16_t\n"
"ElfN_Versym     Беззнаковые данные о версии символа, uint16_t\n"
"Elf_Byte        unsigned char\n"
"ElfN_Half       uint16_t\n"
"ElfN_Sword      int32_t\n"
"ElfN_Word       uint32_t\n"
"ElfN_Sxword     int64_t\n"
"ElfN_Xword      uint64_t\n"

#. type: Plain text
#: man-pages/man5/elf.5:128
msgid ""
"(Note: the *BSD terminology is a bit different.  There, I<Elf64_Half> is "
"twice as large as I<Elf32_Half>, and I<Elf64Quarter> is used for "
"I<uint16_t>.  In order to avoid confusion these types are replaced by "
"explicit ones in the below.)"
msgstr ""
"(Замечание: В *BSD используется немного другая терминология. Так, "
"I<Elf64_Half> — удвоенный I<Elf32_Half>, а I<Elf64Quarter> — I<uint16_t>. "
"Чтобы не путаться, далее эти типы заменены на их явные типы.)"

#. type: Plain text
#: man-pages/man5/elf.5:136
msgid ""
"All data structures that the file format defines follow the \"natural\" size "
"and alignment guidelines for the relevant class.  If necessary, data "
"structures contain explicit padding to ensure 4-byte alignment for 4-byte "
"objects, to force structure sizes to a multiple of 4, and so on."
msgstr ""
"Все структуры данных этого формата файлов следуют «естественному» размеру и "
"принципам выравнивания соответствующего класса. Если требуется, структуры "
"данных содержат явно указанные заполнители (padding) для выравнивания по 4-м "
"байтам для 4-байтовых объектов, для доведения размера структур до кратного 4-"
"м и т. д."

#. type: SS
#: man-pages/man5/elf.5:136
#, no-wrap
msgid "ELF header (Ehdr)"
msgstr "Заголовок ELF (Ehdr)"

#. type: Plain text
#: man-pages/man5/elf.5:141
msgid "The ELF header is described by the type I<Elf32_Ehdr> or I<Elf64_Ehdr>:"
msgstr "Заголовок ELF описывается типом I<Elf32_Ehdr> или I<Elf64_Ehdr>:"

#. type: Plain text
#: man-pages/man5/elf.5:145
#, no-wrap
msgid "#define EI_NIDENT 16\n"
msgstr "#define EI_NIDENT 16\n"

#. type: Plain text
#: man-pages/man5/elf.5:162
#, no-wrap
msgid ""
"typedef struct {\n"
"    unsigned char e_ident[EI_NIDENT];\n"
"    uint16_t      e_type;\n"
"    uint16_t      e_machine;\n"
"    uint32_t      e_version;\n"
"    ElfN_Addr     e_entry;\n"
"    ElfN_Off      e_phoff;\n"
"    ElfN_Off      e_shoff;\n"
"    uint32_t      e_flags;\n"
"    uint16_t      e_ehsize;\n"
"    uint16_t      e_phentsize;\n"
"    uint16_t      e_phnum;\n"
"    uint16_t      e_shentsize;\n"
"    uint16_t      e_shnum;\n"
"    uint16_t      e_shstrndx;\n"
"} ElfN_Ehdr;\n"
msgstr ""
"typedef struct {\n"
"    unsigned char e_ident[EI_NIDENT];\n"
"    uint16_t      e_type;\n"
"    uint16_t      e_machine;\n"
"    uint32_t      e_version;\n"
"    ElfN_Addr     e_entry;\n"
"    ElfN_Off      e_phoff;\n"
"    ElfN_Off      e_shoff;\n"
"    uint32_t      e_flags;\n"
"    uint16_t      e_ehsize;\n"
"    uint16_t      e_phentsize;\n"
"    uint16_t      e_phnum;\n"
"    uint16_t      e_shentsize;\n"
"    uint16_t      e_shnum;\n"
"    uint16_t      e_shstrndx;\n"
"} ElfN_Ehdr;\n"

#. type: Plain text
#: man-pages/man5/elf.5:167
msgid "The fields have the following meanings:"
msgstr "Значения полей:"

#. type: TP
#: man-pages/man5/elf.5:169
#, no-wrap
msgid "I<e_ident>"
msgstr "I<e_ident>"

#. type: Plain text
#: man-pages/man5/elf.5:179
msgid ""
"This array of bytes specifies how to interpret the file, independent of the "
"processor or the file's remaining contents.  Within this array everything is "
"named by macros, which start with the prefix B<EI_> and may contain values "
"which start with the prefix B<ELF>.  The following macros are defined:"
msgstr ""
"Массив байт, описывающий как воспринимать файл, не зависит от типа "
"процессора или остального содержимого файла. Всё в массиве описывается "
"макросами, начинающимися с префикса B<EI_>, которые могут иметь значения, "
"начинающиеся с префикса B<ELF>. Определены следующие макросы:"

#. type: TP
#: man-pages/man5/elf.5:180
#, no-wrap
msgid "B<EI_MAG0>"
msgstr "B<EI_MAG0>"

#. type: Plain text
#: man-pages/man5/elf.5:186
msgid ""
"The first byte of the magic number.  It must be filled with B<ELFMAG0>.  (0: "
"0x7f)"
msgstr ""
"Первый байт отличительного (magic) числа. Должен быть заполнен B<ELFMAG0>. "
"(0: 0x7f)"

#. type: TP
#: man-pages/man5/elf.5:186
#, no-wrap
msgid "B<EI_MAG1>"
msgstr "B<EI_MAG1>"

#. type: Plain text
#: man-pages/man5/elf.5:192
msgid ""
"The second byte of the magic number.  It must be filled with B<ELFMAG1>.  "
"(1: \\(aqE\\(aq)"
msgstr ""
"Второй байт отличительного числа. Должен быть заполнен B<ELFMAG1>. (1: \\(aqE"
"\\(aq)"

#. type: TP
#: man-pages/man5/elf.5:192
#, no-wrap
msgid "B<EI_MAG2>"
msgstr "B<EI_MAG2>"

#. type: Plain text
#: man-pages/man5/elf.5:198
msgid ""
"The third byte of the magic number.  It must be filled with B<ELFMAG2>.  (2: "
"\\(aqL\\(aq)"
msgstr ""
"Третий байт отличительного числа. Должен быть заполнен B<ELFMAG2>. (2: \\(aqL"
"\\(aq)"

#. type: TP
#: man-pages/man5/elf.5:198
#, no-wrap
msgid "B<EI_MAG3>"
msgstr "B<EI_MAG3>"

#. type: Plain text
#: man-pages/man5/elf.5:204
msgid ""
"The fourth byte of the magic number.  It must be filled with B<ELFMAG3>.  "
"(3: \\(aqF\\(aq)"
msgstr ""
"Четвёртый байт отличительного числа. Должен быть заполнен B<ELFMAG3>. (3: "
"\\(aqF\\(aq)"

#. type: TP
#: man-pages/man5/elf.5:204
#, no-wrap
msgid "B<EI_CLASS>"
msgstr "B<EI_CLASS>"

#. type: Plain text
#: man-pages/man5/elf.5:207
msgid "The fifth byte identifies the architecture for this binary:"
msgstr "В пятом байте задаётся архитектура двоичного файла:"

#. type: TP
#: man-pages/man5/elf.5:208
#, no-wrap
msgid "B<ELFCLASSNONE>"
msgstr "B<ELFCLASSNONE>"

#. type: Plain text
#: man-pages/man5/elf.5:212
msgid "This class is invalid."
msgstr "Неправильный класс."

#. type: TP
#: man-pages/man5/elf.5:212
#, no-wrap
msgid "B<ELFCLASS32>"
msgstr "B<ELFCLASS32>"

#. type: Plain text
#: man-pages/man5/elf.5:217
msgid ""
"This defines the 32-bit architecture.  It supports machines with files and "
"virtual address spaces up to 4 Gigabytes."
msgstr ""
"32-битная архитектура. Поддерживаются машины с файлами и виртуальным "
"адресным пространством до 4 гигабайт."

#. type: TP
#: man-pages/man5/elf.5:217
#, no-wrap
msgid "B<ELFCLASS64>"
msgstr "B<ELFCLASS64>"

#. type: Plain text
#: man-pages/man5/elf.5:220
msgid "This defines the 64-bit architecture."
msgstr "64-битная архитектура."

#. type: TP
#: man-pages/man5/elf.5:222
#, no-wrap
msgid "B<EI_DATA>"
msgstr "B<EI_DATA>"

#. type: Plain text
#: man-pages/man5/elf.5:227
msgid ""
"The sixth byte specifies the data encoding of the processor-specific data in "
"the file.  Currently, these encodings are supported:"
msgstr ""
"В шестом байте задаётся порядок кодирования данных в файле, используемый в "
"процессоре. В настоящее время поддерживаются:"

#. type: TP
#: man-pages/man5/elf.5:228
#, no-wrap
msgid "B<ELFDATANONE>"
msgstr "B<ELFDATANONE>"

#. type: Plain text
#: man-pages/man5/elf.5:232
msgid "Unknown data format."
msgstr "Неизвестный формат данных."

#. type: TP
#: man-pages/man5/elf.5:232
#, no-wrap
msgid "B<ELFDATA2LSB>"
msgstr "B<ELFDATA2LSB>"

#. type: Plain text
#: man-pages/man5/elf.5:235
msgid "Two's complement, little-endian."
msgstr "Обратный порядок байт (little-endian) в дополнительном коде."

#. type: TP
#: man-pages/man5/elf.5:235
#, no-wrap
msgid "B<ELFDATA2MSB>"
msgstr "B<ELFDATA2MSB>"

#. type: Plain text
#: man-pages/man5/elf.5:238
msgid "Two's complement, big-endian."
msgstr "Прямой порядок байт (big-endian) в дополнительном коде."

#. type: TP
#: man-pages/man5/elf.5:240
#, no-wrap
msgid "B<EI_VERSION>"
msgstr "B<EI_VERSION>"

#. type: Plain text
#: man-pages/man5/elf.5:243
msgid "The seventh byte is the version number of the ELF specification:"
msgstr "В седьмом байте указывается номер версии спецификации ELF:"

#. type: TP
#: man-pages/man5/elf.5:246 man-pages/man5/elf.5:492
#, no-wrap
msgid "B<EV_NONE>"
msgstr "B<EV_NONE>"

#. type: Plain text
#: man-pages/man5/elf.5:249
msgid "Invalid version."
msgstr "Неправильный номер версии."

#. type: TP
#: man-pages/man5/elf.5:249 man-pages/man5/elf.5:496
#, no-wrap
msgid "B<EV_CURRENT>"
msgstr "B<EV_CURRENT>"

#. type: Plain text
#: man-pages/man5/elf.5:252
msgid "Current version."
msgstr "Текущая версия."

#. type: TP
#: man-pages/man5/elf.5:255
#, no-wrap
msgid "B<EI_OSABI>"
msgstr "B<EI_OSABI>"

#. type: Plain text
#: man-pages/man5/elf.5:263
msgid ""
"The eighth byte identifies the operating system and ABI to which the object "
"is targeted.  Some fields in other ELF structures have flags and values that "
"have platform-specific meanings; the interpretation of those fields is "
"determined by the value of this byte.  For example:"
msgstr ""
"В восьмом байте указывается тип операционной системы и двоичного интерфейса "
"приложений (ABI), для которой предназначен объект. Некоторые поля в других "
"структурах ELF имеют флаги и значения, зависящие от платформы; интерпретация "
"таких полей определяется значением данного байта. Пример:"

#. type: TP
#: man-pages/man5/elf.5:264
#, no-wrap
msgid "B<ELFOSABI_NONE>"
msgstr "B<ELFOSABI_NONE>"

#.  0
#. type: Plain text
#: man-pages/man5/elf.5:269
msgid "Same as ELFOSABI_SYSV"
msgstr "Тоже что и ELFOSABI_SYSV."

#. type: TP
#: man-pages/man5/elf.5:269
#, no-wrap
msgid "B<ELFOSABI_SYSV>"
msgstr "B<ELFOSABI_SYSV>"

#.  0
#.  synonym: ELFOSABI_NONE
#. type: Plain text
#: man-pages/man5/elf.5:274
msgid "UNIX System V ABI"
msgstr "UNIX System V ABI"

#. type: TP
#: man-pages/man5/elf.5:274
#, no-wrap
msgid "B<ELFOSABI_HPUX>"
msgstr "B<ELFOSABI_HPUX>"

#.  1
#. type: Plain text
#: man-pages/man5/elf.5:278
msgid "HP-UX ABI"
msgstr "HP-UX ABI"

#. type: TP
#: man-pages/man5/elf.5:278
#, no-wrap
msgid "B<ELFOSABI_NETBSD>"
msgstr "B<ELFOSABI_NETBSD>"

#.  2
#. type: Plain text
#: man-pages/man5/elf.5:282
msgid "NetBSD ABI"
msgstr "NetBSD ABI"

#. type: TP
#: man-pages/man5/elf.5:282
#, no-wrap
msgid "B<ELFOSABI_LINUX>"
msgstr "B<ELFOSABI_LINUX>"

#.  3
#.  .TP
#.  .BR ELFOSABI_HURD
#.  Hurd ABI
#.  4
#.  .TP
#.  .BR ELFOSABI_86OPEN
#.  86Open Common IA32 ABI
#.  5
#. type: Plain text
#: man-pages/man5/elf.5:294
msgid "Linux ABI"
msgstr "Linux ABI"

#. type: TP
#: man-pages/man5/elf.5:294
#, no-wrap
msgid "B<ELFOSABI_SOLARIS>"
msgstr "B<ELFOSABI_SOLARIS>"

#.  6
#.  .TP
#.  .BR ELFOSABI_MONTEREY
#.  Monterey project ABI
#.  Now replaced by
#.  ELFOSABI_AIX
#.  7
#. type: Plain text
#: man-pages/man5/elf.5:304
msgid "Solaris ABI"
msgstr "Solaris ABI"

#. type: TP
#: man-pages/man5/elf.5:304
#, no-wrap
msgid "B<ELFOSABI_IRIX>"
msgstr "B<ELFOSABI_IRIX>"

#.  8
#. type: Plain text
#: man-pages/man5/elf.5:308
msgid "IRIX ABI"
msgstr "IRIX ABI"

#. type: TP
#: man-pages/man5/elf.5:308
#, no-wrap
msgid "B<ELFOSABI_FREEBSD>"
msgstr "B<ELFOSABI_FREEBSD>"

#.  9
#. type: Plain text
#: man-pages/man5/elf.5:312
msgid "FreeBSD ABI"
msgstr "FreeBSD ABI"

#. type: TP
#: man-pages/man5/elf.5:312
#, no-wrap
msgid "B<ELFOSABI_TRU64>"
msgstr "B<ELFOSABI_TRU64>"

#.  10
#.  ELFOSABI_MODESTO
#.  11
#.  ELFOSABI_OPENBSD
#.  12
#. type: Plain text
#: man-pages/man5/elf.5:320
msgid "TRU64 UNIX ABI"
msgstr "TRU64 UNIX ABI"

#. type: TP
#: man-pages/man5/elf.5:320
#, no-wrap
msgid "B<ELFOSABI_ARM>"
msgstr "B<ELFOSABI_ARM>"

#.  97
#. type: Plain text
#: man-pages/man5/elf.5:324
msgid "ARM architecture ABI"
msgstr "ABI архитектуры ARM"

#. type: TP
#: man-pages/man5/elf.5:324
#, no-wrap
msgid "B<ELFOSABI_STANDALONE>"
msgstr "B<ELFOSABI_STANDALONE>"

#.  255
#. type: Plain text
#: man-pages/man5/elf.5:328
msgid "Stand-alone (embedded) ABI"
msgstr "Автономный (встраиваемый) ABI"

#. type: TP
#: man-pages/man5/elf.5:330
#, no-wrap
msgid "B<EI_ABIVERSION>"
msgstr "B<EI_ABIVERSION>"

#. type: Plain text
#: man-pages/man5/elf.5:340
msgid ""
"The ninth byte identifies the version of the ABI to which the object is "
"targeted.  This field is used to distinguish among incompatible versions of "
"an ABI.  The interpretation of this version number is dependent on the ABI "
"identified by the B<EI_OSABI> field.  Applications conforming to this "
"specification use the value 0."
msgstr ""
"В девятом байте указывается версия ABI, для которой предназначен объект. Это "
"поле используется для разграничения несовместимых версий ABI. Интерпретация "
"данного номера версии зависит от ABI, указанного в поле B<EI_OSABI>. В "
"приложениях, удовлетворяющих данной спецификации, используется значение 0."

#. type: TP
#: man-pages/man5/elf.5:340
#, no-wrap
msgid "B<EI_PAD>"
msgstr "B<EI_PAD>"

#.  As reported by Yuri Kozlov and confirmed by Mike Frysinger, EI_BRAND is
#.  not in GABI (http://www.sco.com/developers/gabi/latest/ch4.eheader.html)
#.  It looks to be a BSDism
#.  .TP
#.  .BR EI_BRAND
#.  Start of architecture identification.
#. type: Plain text
#: man-pages/man5/elf.5:356
msgid ""
"Start of padding.  These bytes are reserved and set to zero.  Programs which "
"read them should ignore them.  The value for B<EI_PAD> will change in the "
"future if currently unused bytes are given meanings."
msgstr ""
"Начало заполнителя. Эти байты зарезервированы и устанавливаются в ноль. "
"Программы, читающие заголовок, должны игнорировать их. Значение B<EI_PAD> "
"будет изменено, если понадобится задействовать неиспользуемые в данный "
"момент байты."

#. type: TP
#: man-pages/man5/elf.5:356
#, no-wrap
msgid "B<EI_NIDENT>"
msgstr "B<EI_NIDENT>"

#. type: Plain text
#: man-pages/man5/elf.5:361
msgid "The size of the I<e_ident> array."
msgstr "Размер массива I<e_ident>."

#. type: TP
#: man-pages/man5/elf.5:362
#, no-wrap
msgid "I<e_type>"
msgstr "I<e_type>"

#. type: Plain text
#: man-pages/man5/elf.5:365
msgid "This member of the structure identifies the object file type:"
msgstr "В этом поле структуры содержится тип объектного файла:"

#. type: TP
#: man-pages/man5/elf.5:366
#, no-wrap
msgid "B<ET_NONE>"
msgstr "B<ET_NONE>"

#. type: Plain text
#: man-pages/man5/elf.5:370
msgid "An unknown type."
msgstr "Неизвестный тип."

#. type: TP
#: man-pages/man5/elf.5:370
#, no-wrap
msgid "B<ET_REL>"
msgstr "B<ET_REL>"

#. type: Plain text
#: man-pages/man5/elf.5:373
msgid "A relocatable file."
msgstr "Перемещаемый файл."

#. type: TP
#: man-pages/man5/elf.5:373
#, no-wrap
msgid "B<ET_EXEC>"
msgstr "B<ET_EXEC>"

#. type: Plain text
#: man-pages/man5/elf.5:376
msgid "An executable file."
msgstr "Исполняемый файл."

#. type: TP
#: man-pages/man5/elf.5:376
#, no-wrap
msgid "B<ET_DYN>"
msgstr "B<ET_DYN>"

#. type: Plain text
#: man-pages/man5/elf.5:379
msgid "A shared object."
msgstr "Динамический объект."

#. type: TP
#: man-pages/man5/elf.5:379
#, no-wrap
msgid "B<ET_CORE>"
msgstr "B<ET_CORE>"

#. type: Plain text
#: man-pages/man5/elf.5:382
msgid "A core file."
msgstr "Файл типа core."

#. type: TP
#: man-pages/man5/elf.5:384
#, no-wrap
msgid "I<e_machine>"
msgstr "I<e_machine>"

#. type: Plain text
#: man-pages/man5/elf.5:388
msgid ""
"This member specifies the required architecture for an individual file.  For "
"example:"
msgstr ""
"В этом поле содержится значение требуемой для файла архитектуры. Пример:"

#. type: TP
#: man-pages/man5/elf.5:389
#, no-wrap
msgid "B<EM_NONE>"
msgstr "B<EM_NONE>"

#.  0
#. type: Plain text
#: man-pages/man5/elf.5:394
msgid "An unknown machine"
msgstr "Неизвестная машинная архитектура"

#. type: TP
#: man-pages/man5/elf.5:394
#, no-wrap
msgid "B<EM_M32>"
msgstr "B<EM_M32>"

#.  1
#. type: Plain text
#: man-pages/man5/elf.5:398
msgid "AT&T WE 32100"
msgstr "AT&T WE 32100"

#. type: TP
#: man-pages/man5/elf.5:398
#, no-wrap
msgid "B<EM_SPARC>"
msgstr "B<EM_SPARC>"

#.  2
#. type: Plain text
#: man-pages/man5/elf.5:402
msgid "Sun Microsystems SPARC"
msgstr "Sun Microsystems SPARC"

#. type: TP
#: man-pages/man5/elf.5:402
#, no-wrap
msgid "B<EM_386>"
msgstr "B<EM_386>"

#.  3
#. type: Plain text
#: man-pages/man5/elf.5:406
msgid "Intel 80386"
msgstr "Intel 80386"

#. type: TP
#: man-pages/man5/elf.5:406
#, no-wrap
msgid "B<EM_68K>"
msgstr "B<EM_68K>"

#.  4
#. type: Plain text
#: man-pages/man5/elf.5:410
msgid "Motorola 68000"
msgstr "Motorola 68000"

#. type: TP
#: man-pages/man5/elf.5:410
#, no-wrap
msgid "B<EM_88K>"
msgstr "B<EM_88K>"

#.  5
#.  .TP
#.  .BR EM_486
#.  Intel 80486
#.  6
#. type: Plain text
#: man-pages/man5/elf.5:418
msgid "Motorola 88000"
msgstr "Motorola 88000"

#. type: TP
#: man-pages/man5/elf.5:418
#, no-wrap
msgid "B<EM_860>"
msgstr "B<EM_860>"

#.  7
#. type: Plain text
#: man-pages/man5/elf.5:422
msgid "Intel 80860"
msgstr "Intel 80860"

#. type: TP
#: man-pages/man5/elf.5:422
#, no-wrap
msgid "B<EM_MIPS>"
msgstr "B<EM_MIPS>"

#.  8
#.  EM_S370
#.  9
#.  .TP
#.  .BR EM_MIPS_RS4_BE
#.  MIPS RS4000 (big-endian only). Deprecated
#.  10
#.  EM_MIPS_RS3_LE (MIPS R3000 little-endian)
#.  10
#. type: Plain text
#: man-pages/man5/elf.5:434
msgid "MIPS RS3000 (big-endian only)"
msgstr "MIPS RS3000 (только с прямым порядком байт)"

#. type: TP
#: man-pages/man5/elf.5:434
#, no-wrap
msgid "B<EM_PARISC>"
msgstr "B<EM_PARISC>"

#.  15
#. type: Plain text
#: man-pages/man5/elf.5:438
msgid "HP/PA"
msgstr "HP/PA"

#. type: TP
#: man-pages/man5/elf.5:438
#, no-wrap
msgid "B<EM_SPARC32PLUS>"
msgstr "B<EM_SPARC32PLUS>"

#.  18
#. type: Plain text
#: man-pages/man5/elf.5:442
msgid "SPARC with enhanced instruction set"
msgstr "SPARC с расширенным набором инструкций"

#. type: TP
#: man-pages/man5/elf.5:442
#, no-wrap
msgid "B<EM_PPC>"
msgstr "B<EM_PPC>"

#.  20
#. type: Plain text
#: man-pages/man5/elf.5:446
msgid "PowerPC"
msgstr "PowerPC"

#. type: TP
#: man-pages/man5/elf.5:446
#, no-wrap
msgid "B<EM_PPC64>"
msgstr "B<EM_PPC64>"

#.  21
#. type: Plain text
#: man-pages/man5/elf.5:450
msgid "PowerPC 64-bit"
msgstr "PowerPC, 64-битная"

#. type: TP
#: man-pages/man5/elf.5:450
#, no-wrap
msgid "B<EM_S390>"
msgstr "B<EM_S390>"

#.  22
#. type: Plain text
#: man-pages/man5/elf.5:454
msgid "IBM S/390"
msgstr "IBM S/390."

#. type: TP
#: man-pages/man5/elf.5:454
#, no-wrap
msgid "B<EM_ARM>"
msgstr "B<EM_ARM>"

#.  40
#. type: Plain text
#: man-pages/man5/elf.5:458
msgid "Advanced RISC Machines"
msgstr "Advanced RISC Machines."

#. type: TP
#: man-pages/man5/elf.5:458
#, no-wrap
msgid "B<EM_SH>"
msgstr "B<EM_SH>"

#.  42
#. type: Plain text
#: man-pages/man5/elf.5:462
msgid "Renesas SuperH"
msgstr "Renesas SuperH."

#. type: TP
#: man-pages/man5/elf.5:462
#, no-wrap
msgid "B<EM_SPARCV9>"
msgstr "B<EM_SPARCV9>"

#.  43
#. type: Plain text
#: man-pages/man5/elf.5:466
msgid "SPARC v9 64-bit"
msgstr "SPARC v9, 64-битная"

#. type: TP
#: man-pages/man5/elf.5:466
#, no-wrap
msgid "B<EM_IA_64>"
msgstr "B<EM_IA_64>"

#.  50
#. type: Plain text
#: man-pages/man5/elf.5:470
msgid "Intel Itanium"
msgstr "Intel Itanium."

#. type: TP
#: man-pages/man5/elf.5:470
#, no-wrap
msgid "B<EM_X86_64>"
msgstr "B<EM_X86_64>"

#.  62
#. type: Plain text
#: man-pages/man5/elf.5:474
msgid "AMD x86-64"
msgstr "AMD x86-64."

#. type: TP
#: man-pages/man5/elf.5:474
#, no-wrap
msgid "B<EM_VAX>"
msgstr "B<EM_VAX>"

#.  75
#.  EM_CRIS
#.  76
#.  .TP
#.  .BR EM_ALPHA
#.  Compaq [DEC] Alpha
#.  .TP
#.  .BR EM_ALPHA_EXP
#.  Compaq [DEC] Alpha with enhanced instruction set
#. type: Plain text
#: man-pages/man5/elf.5:486
msgid "DEC Vax"
msgstr "DEC Vax"

#. type: TP
#: man-pages/man5/elf.5:488
#, no-wrap
msgid "I<e_version>"
msgstr "I<e_version>"

#. type: Plain text
#: man-pages/man5/elf.5:491
msgid "This member identifies the file version:"
msgstr "В этом поле содержится версия файла:"

#. type: Plain text
#: man-pages/man5/elf.5:496
msgid "Invalid version"
msgstr "Неправильный номер версии"

#. type: Plain text
#: man-pages/man5/elf.5:499
msgid "Current version"
msgstr "Текущая версия"

#. type: TP
#: man-pages/man5/elf.5:501
#, no-wrap
msgid "I<e_entry>"
msgstr "I<e_entry>"

#. type: Plain text
#: man-pages/man5/elf.5:507
msgid ""
"This member gives the virtual address to which the system first transfers "
"control, thus starting the process.  If the file has no associated entry "
"point, this member holds zero."
msgstr ""
"В этом поле содержится виртуальный адрес, по которому система должна "
"передать управление для запуска процесса. Если в файле нет такой точки "
"входа, то значение поля равно 0."

#. type: TP
#: man-pages/man5/elf.5:507
#, no-wrap
msgid "I<e_phoff>"
msgstr "I<e_phoff>"

#. type: Plain text
#: man-pages/man5/elf.5:512
msgid ""
"This member holds the program header table's file offset in bytes.  If the "
"file has no program header table, this member holds zero."
msgstr ""
"В этом поле содержится файловое смещение в байтах для таблицы заголовков "
"программы. Если в файле нет таблицы заголовков программы, то значение поля "
"равно 0."

#. type: TP
#: man-pages/man5/elf.5:512
#, no-wrap
msgid "I<e_shoff>"
msgstr "I<e_shoff>"

#. type: Plain text
#: man-pages/man5/elf.5:517
msgid ""
"This member holds the section header table's file offset in bytes.  If the "
"file has no section header table, this member holds zero."
msgstr ""
"В этом поле содержится файловое смещение в байтах для таблицы заголовков "
"разделов. Если в файле нет таблицы заголовков разделов, то значение поля "
"равно 0."

#. type: TP
#: man-pages/man5/elf.5:517
#, no-wrap
msgid "I<e_flags>"
msgstr "I<e_flags>"

#. type: Plain text
#: man-pages/man5/elf.5:522
msgid ""
"This member holds processor-specific flags associated with the file.  Flag "
"names take the form EF_`machine_flag'.  Currently, no flags have been "
"defined."
msgstr ""
"В этом поле содержатся специфичные для процессора флаги, относящиеся к "
"файлу. Имена флагов имеют вид: EF_машинный_флаг. В настоящее время нет ни "
"одного предопределённого флага."

#. type: TP
#: man-pages/man5/elf.5:522
#, no-wrap
msgid "I<e_ehsize>"
msgstr "I<e_ehsize>"

#. type: Plain text
#: man-pages/man5/elf.5:525
msgid "This member holds the ELF header's size in bytes."
msgstr "В этом поле содержится размер заголовка ELF в байтах."

#. type: TP
#: man-pages/man5/elf.5:525
#, no-wrap
msgid "I<e_phentsize>"
msgstr "I<e_phentsize>"

#. type: Plain text
#: man-pages/man5/elf.5:529
msgid ""
"This member holds the size in bytes of one entry in the file's program "
"header table; all entries are the same size."
msgstr ""
"В этом поле содержится размер в байтах одного элемента таблицы заголовков "
"программы в файле; все элементы имеют одинаковый размер."

#. type: TP
#: man-pages/man5/elf.5:529
#, no-wrap
msgid "I<e_phnum>"
msgstr "I<e_phnum>"

#. type: Plain text
#: man-pages/man5/elf.5:542
msgid ""
"This member holds the number of entries in the program header table.  Thus "
"the product of I<e_phentsize> and I<e_phnum> gives the table's size in "
"bytes.  If a file has no program header, I<e_phnum> holds the value zero."
msgstr ""
"В этом поле содержится количество элементов в таблице заголовков программы. "
"Таким образом, произведение I<e_phentsize> и I<e_phnum> даёт размер таблицы "
"в байтах. Если в файле нет заголовков программы, то I<e_phnum> содержит 0."

#.  This is a Linux extension, added in Linux 2.6.34.
#. type: Plain text
#: man-pages/man5/elf.5:556
msgid ""
"If the number of entries in the program header table is larger than or equal "
"to B<PN_XNUM> (0xffff), this member holds B<PN_XNUM> (0xffff) and the real "
"number of entries in the program header table is held in the I<sh_info> "
"member of the initial entry in section header table.  Otherwise, the "
"I<sh_info> member of the initial entry contains the value zero."
msgstr ""
"Если количество элементов в таблице заголовков программы больше или равно "
"B<PN_XNUM> (0xffff), это поле  содержит значение B<PN_XNUM> (0xffff) и "
"реальное количество элементов таблицы заголовков программы хранится в поле "
"I<sh_info> начального элемента таблицы заголовков разделов. Иначе поле "
"I<sh_info> начального элемента содержит ноль."

#. type: TP
#: man-pages/man5/elf.5:557
#, no-wrap
msgid "B<PN_XNUM>"
msgstr "B<PN_XNUM>"

#. type: Plain text
#: man-pages/man5/elf.5:562
msgid ""
"This is defined as 0xffff, the largest number I<e_phnum> can have, "
"specifying where the actual number of program headers is assigned."
msgstr ""
"Имеет значение 0xffff, самое большое количество, которое может иметь "
"I<e_phnum>, показывает, где расположено реальное количество заголовков "
"программы."

#. type: TP
#: man-pages/man5/elf.5:565
#, no-wrap
msgid "I<e_shentsize>"
msgstr "I<e_shentsize>"

#. type: Plain text
#: man-pages/man5/elf.5:570
msgid ""
"This member holds a sections header's size in bytes.  A section header is "
"one entry in the section header table; all entries are the same size."
msgstr ""
"В этом поле содержится размер в байтах одного элемента таблицы заголовков "
"разделов; все элементы имеют одинаковый размер."

#. type: TP
#: man-pages/man5/elf.5:570
#, no-wrap
msgid "I<e_shnum>"
msgstr "I<e_shnum>"

#. type: Plain text
#: man-pages/man5/elf.5:583
msgid ""
"This member holds the number of entries in the section header table.  Thus "
"the product of I<e_shentsize> and I<e_shnum> gives the section header "
"table's size in bytes.  If a file has no section header table, I<e_shnum> "
"holds the value of zero."
msgstr ""
"В этом поле содержится количество элементов в таблице заголовков разделов. "
"Таким образом, произведение I<e_shentsize> и I<e_shnum> даёт размер таблицы "
"разделов в байтах. Если в файле нет заголовков разделов, то I<e_shnum> "
"содержит 0."

#. type: Plain text
#: man-pages/man5/elf.5:597
msgid ""
"If the number of entries in the section header table is larger than or equal "
"to B<SHN_LORESERVE> (0xff00), I<e_shnum> holds the value zero and the real "
"number of entries in the section header table is held in the I<sh_size> "
"member of the initial entry in section header table.  Otherwise, the "
"I<sh_size> member of the initial entry in the section header table holds the "
"value zero."
msgstr ""
"Если количество элементов в таблице заголовков разделов больше или равно "
"B<SHN_LORESERVE> (0xff00), то значение I<e_shnum> равно и реальное "
"количество элементов таблицы заголовков разделов хранится в поле I<sh_size> "
"начального элемента таблицы заголовков разделов. Иначе поле I<sh_size> "
"начального элемента таблицы заголовков разделов имеет значение ноль."

#. type: TP
#: man-pages/man5/elf.5:597
#, no-wrap
msgid "I<e_shstrndx>"
msgstr "I<e_shstrndx>"

#. type: Plain text
#: man-pages/man5/elf.5:604
msgid ""
"This member holds the section header table index of the entry associated "
"with the section name string table.  If the file has no section name string "
"table, this member holds the value B<SHN_UNDEF>."
msgstr ""
"В этом поле содержится индекс элемента в таблице заголовков разделов, "
"указывающий на строковую таблицу названий разделов. Если в файле нет "
"строковой таблицы названий разделов, то это поле содержит значение "
"B<SHN_UNDEF>."

#. type: Plain text
#: man-pages/man5/elf.5:618
msgid ""
"If the index of section name string table section is larger than or equal to "
"B<SHN_LORESERVE> (0xff00), this member holds B<SHN_XINDEX> (0xffff) and the "
"real index of the section name string table section is held in the "
"I<sh_link> member of the initial entry in section header table.  Otherwise, "
"the I<sh_link> member of the initial entry in section header table contains "
"the value zero."
msgstr ""
"Если индекс строки имён разделов в таблице разделов больше или равен "
"B<SHN_LORESERVE> (0xff00), то в этом поле содержится значение B<SHN_XINDEX> "
"(0xffff) и реальный индекс строки имён разделов в таблице разделов хранится "
"в поле I<sh_link> начального элемента таблицы заголовков разделов. Иначе "
"поле I<sh_link> начального элемента таблицы заголовков разделов имеет "
"значение ноль."

#. type: SS
#: man-pages/man5/elf.5:618
#, no-wrap
msgid "Program header (Phdr)"
msgstr "Заголовок программы (Phdr)"

#. type: Plain text
#: man-pages/man5/elf.5:637
msgid ""
"An executable or shared object file's program header table is an array of "
"structures, each describing a segment or other information the system needs "
"to prepare the program for execution.  An object file I<segment> contains "
"one or more I<sections>.  Program headers are meaningful only for executable "
"and shared object files.  A file specifies its own program header size with "
"the ELF header's I<e_phentsize> and I<e_phnum> members.  The ELF program "
"header is described by the type I<Elf32_Phdr> or I<Elf64_Phdr> depending on "
"the architecture:"
msgstr ""
"Таблица заголовков программы исполняемого или совместно используемого "
"объектного файла представляет собой массив структур, каждая из которых "
"описывает сегмент или содержит другую информацию, необходимую системе для "
"подготовки программы к выполнению. I<Сегмент> объектного файла содержит один "
"или более I<разделов>. Заголовки программы нужны только для исполняемых и "
"совместно используемых объектных файлов. Размер заголовков программы "
"указывается в файле в заголовке ELF в полях I<e_phentsize> и I<e_phnum>. "
"Заголовок программы ELF описывается типом I<Elf32_Phdr> или I<Elf64_Phdr>, в "
"зависимости от архитектуры:"

#. type: Plain text
#: man-pages/man5/elf.5:650
#, no-wrap
msgid ""
"typedef struct {\n"
"    uint32_t   p_type;\n"
"    Elf32_Off  p_offset;\n"
"    Elf32_Addr p_vaddr;\n"
"    Elf32_Addr p_paddr;\n"
"    uint32_t   p_filesz;\n"
"    uint32_t   p_memsz;\n"
"    uint32_t   p_flags;\n"
"    uint32_t   p_align;\n"
"} Elf32_Phdr;\n"
msgstr ""
"typedef struct {\n"
"    uint32_t   p_type;\n"
"    Elf32_Off  p_offset;\n"
"    Elf32_Addr p_vaddr;\n"
"    Elf32_Addr p_paddr;\n"
"    uint32_t   p_filesz;\n"
"    uint32_t   p_memsz;\n"
"    uint32_t   p_flags;\n"
"    uint32_t   p_align;\n"
"} Elf32_Phdr;\n"

#. type: Plain text
#: man-pages/man5/elf.5:665
#, no-wrap
msgid ""
"typedef struct {\n"
"    uint32_t   p_type;\n"
"    uint32_t   p_flags;\n"
"    Elf64_Off  p_offset;\n"
"    Elf64_Addr p_vaddr;\n"
"    Elf64_Addr p_paddr;\n"
"    uint64_t   p_filesz;\n"
"    uint64_t   p_memsz;\n"
"    uint64_t   p_align;\n"
"} Elf64_Phdr;\n"
msgstr ""
"typedef struct {\n"
"    uint32_t   p_type;\n"
"    uint32_t   p_flags;\n"
"    Elf64_Off  p_offset;\n"
"    Elf64_Addr p_vaddr;\n"
"    Elf64_Addr p_paddr;\n"
"    uint64_t   p_filesz;\n"
"    uint64_t   p_memsz;\n"
"    uint64_t   p_align;\n"
"} Elf64_Phdr;\n"

#. type: Plain text
#: man-pages/man5/elf.5:672
msgid ""
"The main difference between the 32-bit and the 64-bit program header lies in "
"the location of the I<p_flags> member in the total struct."
msgstr ""
"Основным отличием между 32-битным и 64-битным программным заголовком в "
"структуре является расположение поля I<p_flags>."

#. type: TP
#: man-pages/man5/elf.5:672
#, no-wrap
msgid "I<p_type>"
msgstr "I<p_type>"

#. type: Plain text
#: man-pages/man5/elf.5:676
msgid ""
"This member of the structure indicates what kind of segment this array "
"element describes or how to interpret the array element's information."
msgstr ""
"Это поле структуры определяет, какой тип сегмента описывает этот элемент "
"массива или как воспринимать информацию данного элемента массива."

#. type: TP
#: man-pages/man5/elf.5:677
#, no-wrap
msgid "B<PT_NULL>"
msgstr "B<PT_NULL>"

#. type: Plain text
#: man-pages/man5/elf.5:681
msgid ""
"The array element is unused and the other members' values are undefined.  "
"This lets the program header have ignored entries."
msgstr ""
"Элемент массива не используется и значения других полей не определены. Это "
"позволяет иметь в заголовке программы игнорируемые элементы."

#. type: TP
#: man-pages/man5/elf.5:681
#, no-wrap
msgid "B<PT_LOAD>"
msgstr "B<PT_LOAD>"

#. type: Plain text
#: man-pages/man5/elf.5:702
msgid ""
"The array element specifies a loadable segment, described by I<p_filesz> and "
"I<p_memsz>.  The bytes from the file are mapped to the beginning of the "
"memory segment.  If the segment's memory size I<p_memsz> is larger than the "
"file size I<p_filesz>, the \"extra\" bytes are defined to hold the value 0 "
"and to follow the segment's initialized area.  The file size may not be "
"larger than the memory size.  Loadable segment entries in the program header "
"table appear in ascending order, sorted on the I<p_vaddr> member."
msgstr ""
"Элемент массива определяет загружаемый сегмент, описываемый I<p_filesz> и "
"I<p_memsz>. Байты из файла проецируются в начало сегмента памяти. Если "
"размер сегмента памяти I<p_memsz> больше чем размер файла I<p_filesz>, то "
"определяются \"дополнительные\" байты, содержащие значение 0, и их "
"располагают за инициализированной областью сегмента. Размер файла не может "
"быть больше размера памяти. Элементы загружаемых сегментов в таблице "
"заголовков программы располагаются в порядке возрастания, их сортируют по "
"полю I<p_vaddr>."

#. type: TP
#: man-pages/man5/elf.5:702
#, no-wrap
msgid "B<PT_DYNAMIC>"
msgstr "B<PT_DYNAMIC>"

#. type: Plain text
#: man-pages/man5/elf.5:705
msgid "The array element specifies dynamic linking information."
msgstr ""
"Элемент массива указывает на данные с информацией по динамической компоновке."

#. type: TP
#: man-pages/man5/elf.5:705
#, no-wrap
msgid "B<PT_INTERP>"
msgstr "B<PT_INTERP>"

#. type: Plain text
#: man-pages/man5/elf.5:713
msgid ""
"The array element specifies the location and size of a null-terminated "
"pathname to invoke as an interpreter.  This segment type is meaningful only "
"for executable files (though it may occur for shared objects).  However it "
"may not occur more than once in a file.  If it is present, it must precede "
"any loadable segment entry."
msgstr ""
"Элемент массива указывает на данные о расположении и размере пути "
"(завершается null) вызываемого интерпретатора. Этот тип сегмента имеет смысл "
"только для исполняемых файлов (хотя может быть и в динамических объектных "
"файлах). Однако, в файле он не может указываться более одного раза. Если он "
"задан, то должен находиться перед всеми элементами загружаемых сегментов."

#. type: TP
#: man-pages/man5/elf.5:713
#, no-wrap
msgid "B<PT_NOTE>"
msgstr "B<PT_NOTE>"

#. type: Plain text
#: man-pages/man5/elf.5:716
msgid "The array element specifies the location of notes (ElfN_Nhdr)."
msgstr "Элемент массива указывает на расположение заметок (ElfN_Nhdr)."

#. type: TP
#: man-pages/man5/elf.5:716
#, no-wrap
msgid "B<PT_SHLIB>"
msgstr "B<PT_SHLIB>"

#. type: Plain text
#: man-pages/man5/elf.5:721
msgid ""
"This segment type is reserved but has unspecified semantics.  Programs that "
"contain an array element of this type do not conform to the ABI."
msgstr ""
"Данный тип сегмента зарезервирован, но имеет неопределённую семантику. "
"Программы, в которых есть элемент массива такого типа, не соответствуют ABI."

#. type: TP
#: man-pages/man5/elf.5:721
#, no-wrap
msgid "B<PT_PHDR>"
msgstr "B<PT_PHDR>"

#. type: Plain text
#: man-pages/man5/elf.5:731
msgid ""
"The array element, if present, specifies the location and size of the "
"program header table itself, both in the file and in the memory image of the "
"program.  This segment type may not occur more than once in a file.  "
"Moreover, it may occur only if the program header table is part of the "
"memory image of the program.  If it is present, it must precede any loadable "
"segment entry."
msgstr ""
"Элемент массива, если есть, указывает на расположение и размер самой таблицы "
"заголовков программы, и в файле и в образе программы в памяти. Данный тип "
"сегмента не может встречаться в файле более одного раза. Кроме того, он "
"может задаваться только если таблица заголовков программы является частью "
"образа программы в памяти. Если он задан, то должен находиться до элементов "
"загружаемых сегментов."

#. type: TP
#: man-pages/man5/elf.5:731
#, no-wrap
msgid "B<PT_LOPROC>, B<PT_HIPROC>"
msgstr "B<PT_LOPROC>, B<PT_HIPROC>"

#. type: Plain text
#: man-pages/man5/elf.5:736
msgid ""
"Values in the inclusive range [B<PT_LOPROC>, B<PT_HIPROC>] are reserved for "
"processor-specific semantics."
msgstr ""
"Значения из диапазона [B<PT_LOPROC>, B<PT_HIPROC>] (не включая) "
"зарезервированы для процессорно-ориентированной семантики."

#. type: TP
#: man-pages/man5/elf.5:736
#, no-wrap
msgid "B<PT_GNU_STACK>"
msgstr "B<PT_GNU_STACK>"

#. type: Plain text
#: man-pages/man5/elf.5:742
msgid ""
"GNU extension which is used by the Linux kernel to control the state of the "
"stack via the flags set in the I<p_flags> member."
msgstr ""
"Расширение GNU, используемое ядром Linux для управления состоянием стека "
"через флаги, настраивается в поле I<p_flags>."

#. type: TP
#: man-pages/man5/elf.5:743
#, no-wrap
msgid "I<p_offset>"
msgstr "I<p_offset>"

#. type: Plain text
#: man-pages/man5/elf.5:747
msgid ""
"This member holds the offset from the beginning of the file at which the "
"first byte of the segment resides."
msgstr ""
"Это поле содержит смещение от начала файла, по которому располагается первый "
"байт сегмента."

#. type: TP
#: man-pages/man5/elf.5:747
#, no-wrap
msgid "I<p_vaddr>"
msgstr "I<p_vaddr>"

#. type: Plain text
#: man-pages/man5/elf.5:751
msgid ""
"This member holds the virtual address at which the first byte of the segment "
"resides in memory."
msgstr ""
"Это поле содержит виртуальный адрес, по которому располагается первый байт "
"сегмента в памяти."

#. type: TP
#: man-pages/man5/elf.5:751
#, no-wrap
msgid "I<p_paddr>"
msgstr "I<p_paddr>"

#. type: Plain text
#: man-pages/man5/elf.5:759
msgid ""
"On systems for which physical addressing is relevant, this member is "
"reserved for the segment's physical address.  Under BSD this member is not "
"used and must be zero."
msgstr ""
"В системах, для которых важна физическая адресация, это поле зарезервировано "
"для физического адреса сегмента. В BSD это поле не используется и должно "
"быть равно нулю."

#. type: TP
#: man-pages/man5/elf.5:759
#, no-wrap
msgid "I<p_filesz>"
msgstr "I<p_filesz>"

#. type: Plain text
#: man-pages/man5/elf.5:763
msgid ""
"This member holds the number of bytes in the file image of the segment.  It "
"may be zero."
msgstr ""
"В этом поле содержится число байт занимаемое сегментом в файле. Оно может "
"быть равно нулю."

#. type: TP
#: man-pages/man5/elf.5:763
#, no-wrap
msgid "I<p_memsz>"
msgstr "I<p_memsz>"

#. type: Plain text
#: man-pages/man5/elf.5:767
msgid ""
"This member holds the number of bytes in the memory image of the segment.  "
"It may be zero."
msgstr ""
"В этом поле содержится число байт занимаемое сегментом в памяти. Оно может "
"быть равно нулю."

#. type: TP
#: man-pages/man5/elf.5:767
#, no-wrap
msgid "I<p_flags>"
msgstr "I<p_flags>"

#. type: Plain text
#: man-pages/man5/elf.5:770
msgid "This member holds a bit mask of flags relevant to the segment:"
msgstr "В этом поле содержится битовая маска флагов соответствующего сегмента:"

#. type: TP
#: man-pages/man5/elf.5:771
#, no-wrap
msgid "B<PF_X>"
msgstr "B<PF_X>"

#. type: Plain text
#: man-pages/man5/elf.5:775
msgid "An executable segment."
msgstr "Исполняемый сегмент."

#. type: TP
#: man-pages/man5/elf.5:775
#, no-wrap
msgid "B<PF_W>"
msgstr "B<PF_W>"

#. type: Plain text
#: man-pages/man5/elf.5:778
msgid "A writable segment."
msgstr "Сегмент доступен для записи."

#. type: TP
#: man-pages/man5/elf.5:778
#, no-wrap
msgid "B<PF_R>"
msgstr "B<PF_R>"

#. type: Plain text
#: man-pages/man5/elf.5:781
msgid "A readable segment."
msgstr "Сегмент доступен для чтения."

#. type: Plain text
#: man-pages/man5/elf.5:792
msgid ""
"A text segment commonly has the flags B<PF_X> and B<PF_R>.  A data segment "
"commonly has B<PF_W> and B<PF_R>."
msgstr ""
"Сегмента кода (text segment) обычно имеет флаги B<PF_X> и B<PF_R>. Сегмент "
"данных обычно имеет флаги B<PF_W> и B<PF_R>."

#. type: TP
#: man-pages/man5/elf.5:792
#, no-wrap
msgid "I<p_align>"
msgstr "I<p_align>"

#. type: Plain text
#: man-pages/man5/elf.5:811
msgid ""
"This member holds the value to which the segments are aligned in memory and "
"in the file.  Loadable process segments must have congruent values for "
"I<p_vaddr> and I<p_offset>, modulo the page size.  Values of zero and one "
"mean no alignment is required.  Otherwise, I<p_align> should be a positive, "
"integral power of two, and I<p_vaddr> should equal I<p_offset>, modulo "
"I<p_align>."
msgstr ""
"В этом поле содержится значение согласно которому сегменты выровнены в "
"памяти и в файле. У загружаемых сегментов процесса значения I<p_vaddr> и "
"I<p_offset> должны быть кратны размеру страницы. Величины ноль и один "
"означают, что выравнивание не требуется. В противном случае значение "
"I<p_align> должно быть положительным числом кратным степени двойки, а "
"значение I<p_vaddr> должно быть равно I<p_offset> и кратным I<p_align>."

#. type: SS
#: man-pages/man5/elf.5:811
#, no-wrap
msgid "Section header (Shdr)"
msgstr "Заголовок раздела (Shdr)"

#. type: Plain text
#: man-pages/man5/elf.5:828
msgid ""
"A file's section header table lets one locate all the file's sections.  The "
"section header table is an array of I<Elf32_Shdr> or I<Elf64_Shdr> "
"structures.  The ELF header's I<e_shoff> member gives the byte offset from "
"the beginning of the file to the section header table.  I<e_shnum> holds the "
"number of entries the section header table contains.  I<e_shentsize> holds "
"the size in bytes of each entry."
msgstr ""
"По таблице заголовков разделов можно найти расположение всех разделов в "
"файле. Она представляет собой массив структур I<Elf32_Shdr> или "
"I<Elf64_Shdr>. На начало таблицы заголовков разделов в файле указывает поле "
"I<e_shoff> заголовка ELF (в байтах). В I<e_shnum> содержится количество "
"элементов таблицы заголовков разделов. В I<e_shentsize> содержится размер "
"каждого элемента в байтах."

#. type: Plain text
#: man-pages/man5/elf.5:844
msgid ""
"A section header table index is a subscript into this array.  Some section "
"header table indices are reserved: the initial entry and the indices between "
"B<SHN_LORESERVE> and B<SHN_HIRESERVE>.  The initial entry is used in ELF "
"extensions for I<e_phnum>, I<e_shnum> and I<e_strndx>; in other cases, each "
"field in the initial entry is set to zero.  An object file does not have "
"sections for these special indices:"
msgstr ""
"Индекс элемента в таблице заголовков разделов указывает в этот массив. "
"Некоторые индексы элемента в таблице заголовков разделов зарезервированы: "
"начальный элемент и индексы от B<SHN_LORESERVE> и до B<SHN_HIRESERVE>. "
"Начальный элемент используется в расширениях ELF для I<e_phnum>, I<e_shnum> "
"and I<e_strndx>; в других случаях, каждое поле начального элемента равно "
"нулю. В объектном файле нет разделов с этими специальными индексами:"

#. type: TP
#: man-pages/man5/elf.5:844
#, no-wrap
msgid "B<SHN_UNDEF>"
msgstr "B<SHN_UNDEF>"

#. type: Plain text
#: man-pages/man5/elf.5:848
msgid ""
"This value marks an undefined, missing, irrelevant, or otherwise meaningless "
"section reference."
msgstr ""
"Этим значением помечается неопределённая, отсутствующая, неприменимая, или "
"другая нецелесообразная ссылка на раздел."

#. type: TP
#: man-pages/man5/elf.5:848
#, no-wrap
msgid "B<SHN_LORESERVE>"
msgstr "B<SHN_LORESERVE>"

#. type: Plain text
#: man-pages/man5/elf.5:851
msgid "This value specifies the lower bound of the range of reserved indices."
msgstr ""
"Это значение задаёт нижнюю границу диапазона зарезервированных индексов."

#. type: TP
#: man-pages/man5/elf.5:851
#, no-wrap
msgid "B<SHN_LOPROC>, B<SHN_HIPROC>"
msgstr "B<SHN_LOPROC>, B<SHN_HIPROC>"

#. type: Plain text
#: man-pages/man5/elf.5:856
msgid ""
"Values greater in the inclusive range [B<SHN_LOPROC>, B<SHN_HIPROC>] are "
"reserved for processor-specific semantics."
msgstr ""
"Значения, больше диапазона [B<PT_LOPROC>, B<PT_HIPROC>] (включительно) "
"зарезервированы для процессорно-ориентированной семантики."

#. type: TP
#: man-pages/man5/elf.5:856
#, no-wrap
msgid "B<SHN_ABS>"
msgstr "B<SHN_ABS>"

#. type: Plain text
#: man-pages/man5/elf.5:863
msgid ""
"This value specifies the absolute value for the corresponding reference.  "
"For example, a symbol defined relative to section number B<SHN_ABS> has an "
"absolute value and is not affected by relocation."
msgstr ""
"Это значение указывает на абсолютное значение соответствующей ссылки. "
"Например, символы, определённые относительно раздела с номером B<SHN_ABS>, "
"имеют абсолютные значения и не подвержены перемещению."

#. type: TP
#: man-pages/man5/elf.5:863
#, no-wrap
msgid "B<SHN_COMMON>"
msgstr "B<SHN_COMMON>"

#. type: Plain text
#: man-pages/man5/elf.5:867
msgid ""
"Symbols defined relative to this section are common symbols, such as FORTRAN "
"COMMON or unallocated C external variables."
msgstr ""
"Символы, определённые относительно такого раздела, являются общими "
"символами, такими как Fortran COMMON или нераспределённые внешние переменные "
"C."

#. type: TP
#: man-pages/man5/elf.5:867
#, no-wrap
msgid "B<SHN_HIRESERVE>"
msgstr "B<SHN_HIRESERVE>"

#. type: Plain text
#: man-pages/man5/elf.5:878
msgid ""
"This value specifies the upper bound of the range of reserved indices.  The "
"system reserves indices between B<SHN_LORESERVE> and B<SHN_HIRESERVE>, "
"inclusive.  The section header table does not contain entries for the "
"reserved indices."
msgstr ""
"Этим значением определяется верхняя граница диапазона зарезервированных "
"индексов. В системе зарезервированы индексы между B<SHN_LORESERVE> и "
"B<SHN_HIRESERVE> включительно. В таблице заголовков разделов нет элементов с "
"зарезервированными индексами."

#. type: Plain text
#: man-pages/man5/elf.5:880
msgid "The section header has the following structure:"
msgstr "Заголовок раздела имеет следующую структуру:"

#. type: Plain text
#: man-pages/man5/elf.5:895
#, no-wrap
msgid ""
"typedef struct {\n"
"    uint32_t   sh_name;\n"
"    uint32_t   sh_type;\n"
"    uint32_t   sh_flags;\n"
"    Elf32_Addr sh_addr;\n"
"    Elf32_Off  sh_offset;\n"
"    uint32_t   sh_size;\n"
"    uint32_t   sh_link;\n"
"    uint32_t   sh_info;\n"
"    uint32_t   sh_addralign;\n"
"    uint32_t   sh_entsize;\n"
"} Elf32_Shdr;\n"
msgstr ""
"typedef struct {\n"
"    uint32_t   sh_name;\n"
"    uint32_t   sh_type;\n"
"    uint32_t   sh_flags;\n"
"    Elf32_Addr sh_addr;\n"
"    Elf32_Off  sh_offset;\n"
"    uint32_t   sh_size;\n"
"    uint32_t   sh_link;\n"
"    uint32_t   sh_info;\n"
"    uint32_t   sh_addralign;\n"
"    uint32_t   sh_entsize;\n"
"} Elf32_Shdr;\n"

#. type: Plain text
#: man-pages/man5/elf.5:912
#, no-wrap
msgid ""
"typedef struct {\n"
"    uint32_t   sh_name;\n"
"    uint32_t   sh_type;\n"
"    uint64_t   sh_flags;\n"
"    Elf64_Addr sh_addr;\n"
"    Elf64_Off  sh_offset;\n"
"    uint64_t   sh_size;\n"
"    uint32_t   sh_link;\n"
"    uint32_t   sh_info;\n"
"    uint64_t   sh_addralign;\n"
"    uint64_t   sh_entsize;\n"
"} Elf64_Shdr;\n"
msgstr ""
"typedef struct {\n"
"    uint32_t   sh_name;\n"
"    uint32_t   sh_type;\n"
"    uint64_t   sh_flags;\n"
"    Elf64_Addr sh_addr;\n"
"    Elf64_Off  sh_offset;\n"
"    uint64_t   sh_size;\n"
"    uint32_t   sh_link;\n"
"    uint32_t   sh_info;\n"
"    uint64_t   sh_addralign;\n"
"    uint64_t   sh_entsize;\n"
"} Elf64_Shdr;\n"

#. type: Plain text
#: man-pages/man5/elf.5:916
msgid ""
"No real differences exist between the 32-bit and 64-bit section headers."
msgstr ""
"Существенной разницы между 32-битными и 64-битными заголовками разделов нет."

#. type: TP
#: man-pages/man5/elf.5:916
#, no-wrap
msgid "I<sh_name>"
msgstr "I<sh_name>"

#. type: Plain text
#: man-pages/man5/elf.5:922
msgid ""
"This member specifies the name of the section.  Its value is an index into "
"the section header string table section, giving the location of a null-"
"terminated string."
msgstr ""
"В этом поле указывается название раздела. Его значением является индекс в "
"строковой таблице заголовков разделов, дающий расположение строки, "
"заканчивающейся null."

#. type: TP
#: man-pages/man5/elf.5:922
#, no-wrap
msgid "I<sh_type>"
msgstr "I<sh_type>"

#. type: Plain text
#: man-pages/man5/elf.5:925
msgid "This member categorizes the section's contents and semantics."
msgstr "В этом поле содержится тип содержимого раздела, определяющий смысл."

#. type: TP
#: man-pages/man5/elf.5:926
#, no-wrap
msgid "B<SHT_NULL>"
msgstr "B<SHT_NULL>"

#. type: Plain text
#: man-pages/man5/elf.5:933
msgid ""
"This value marks the section header as inactive.  It does not have an "
"associated section.  Other members of the section header have undefined "
"values."
msgstr ""
"Этим значением помечают неактивные разделы в заголовке. У такого элемента "
"нет привязанного раздела. Значения других полей заголовка раздела не "
"определены."

#. type: TP
#: man-pages/man5/elf.5:933
#, no-wrap
msgid "B<SHT_PROGBITS>"
msgstr "B<SHT_PROGBITS>"

#. type: Plain text
#: man-pages/man5/elf.5:937
msgid ""
"This section holds information defined by the program, whose format and "
"meaning are determined solely by the program."
msgstr ""
"Этот раздел содержит информацию, задаваемую программой; её формат и смысл "
"полностью определяется программой."

#. type: TP
#: man-pages/man5/elf.5:937
#, no-wrap
msgid "B<SHT_SYMTAB>"
msgstr "B<SHT_SYMTAB>"

#. type: Plain text
#: man-pages/man5/elf.5:950
msgid ""
"This section holds a symbol table.  Typically, B<SHT_SYMTAB> provides "
"symbols for link editing, though it may also be used for dynamic linking.  "
"As a complete symbol table, it may contain many symbols unnecessary for "
"dynamic linking.  An object file can also contain a B<SHT_DYNSYM> section."
msgstr ""
"В этом разделе содержится таблица символов. Обычно, раздел B<SHT_SYMTAB> "
"предоставляет символы для редактирования связей, хотя также может "
"использоваться при динамической компоновке. Являясь полной таблицей символов "
"может содержать символы, не требуемые для динамической компоновки. Объектный "
"файл также может содержать раздел B<SHT_DYNSYM>."

#. type: TP
#: man-pages/man5/elf.5:950
#, no-wrap
msgid "B<SHT_STRTAB>"
msgstr "B<SHT_STRTAB>"

#. type: Plain text
#: man-pages/man5/elf.5:955
msgid ""
"This section holds a string table.  An object file may have multiple string "
"table sections."
msgstr ""
"В этом разделе содержится таблица строк. В объектном файле может быть "
"несколько разделов с таблицами строк."

#. type: TP
#: man-pages/man5/elf.5:955
#, no-wrap
msgid "B<SHT_RELA>"
msgstr "B<SHT_RELA>"

#. type: Plain text
#: man-pages/man5/elf.5:963
msgid ""
"This section holds relocation entries with explicit addends, such as type "
"I<Elf32_Rela> for the 32-bit class of object files.  An object may have "
"multiple relocation sections."
msgstr ""
"В этом разделе содержатся элементы перемещения с явными добавками, такими "
"как тип I<Elf32_Rela> для 32-битного класса объектных файлов. Объектный файл "
"может иметь несколько разделов перемещений."

#. type: TP
#: man-pages/man5/elf.5:963
#, no-wrap
msgid "B<SHT_HASH>"
msgstr "B<SHT_HASH>"

#. type: Plain text
#: man-pages/man5/elf.5:970
msgid ""
"This section holds a symbol hash table.  An object participating in dynamic "
"linking must contain a symbol hash table.  An object file may have only one "
"hash table."
msgstr ""
"В этом разделе содержится хэш-таблица символов. Объект, участвующий в "
"динамической компоновке, должен иметь хэш-таблицу символов. В объектном "
"файле должна быть только одна хэш-таблица."

#. type: TP
#: man-pages/man5/elf.5:970
#, no-wrap
msgid "B<SHT_DYNAMIC>"
msgstr "B<SHT_DYNAMIC>"

#. type: Plain text
#: man-pages/man5/elf.5:975
msgid ""
"This section holds information for dynamic linking.  An object file may have "
"only one dynamic section."
msgstr ""
"В этом разделе содержится информация по динамической компоновке. В объектном "
"файле должен быть только один динамический раздел."

#. type: TP
#: man-pages/man5/elf.5:975
#, no-wrap
msgid "B<SHT_NOTE>"
msgstr "B<SHT_NOTE>"

#. type: Plain text
#: man-pages/man5/elf.5:978
msgid "This section holds notes (ElfN_Nhdr)."
msgstr "В этом разделе содержатся заметки (ElfN_Nhdr)."

#. type: TP
#: man-pages/man5/elf.5:978
#, no-wrap
msgid "B<SHT_NOBITS>"
msgstr "B<SHT_NOBITS>"

#. type: Plain text
#: man-pages/man5/elf.5:986
msgid ""
"A section of this type occupies no space in the file but otherwise resembles "
"B<SHT_PROGBITS>.  Although this section contains no bytes, the I<sh_offset> "
"member contains the conceptual file offset."
msgstr ""
"Разделы этого типа не занимают пространства в файле, но слегка напоминают "
"B<SHT_PROGBITS>. Несмотря на то, что байт в нём нет, поле I<sh_offset> "
"содержит умозрительное файловое смещение."

#. type: TP
#: man-pages/man5/elf.5:986
#, no-wrap
msgid "B<SHT_REL>"
msgstr "B<SHT_REL>"

#. type: Plain text
#: man-pages/man5/elf.5:994
msgid ""
"This section holds relocation offsets without explicit addends, such as type "
"I<Elf32_Rel> for the 32-bit class of object files.  An object file may have "
"multiple relocation sections."
msgstr ""
"В этом разделе содержатся элементы перемещения без явных добавок, таких как "
"тип I<Elf32_Rela> для 32-битного класса объектных файлов. Объектный файл "
"может иметь несколько разделов перемещений."

#. type: TP
#: man-pages/man5/elf.5:994
#, no-wrap
msgid "B<SHT_SHLIB>"
msgstr "B<SHT_SHLIB>"

#. type: Plain text
#: man-pages/man5/elf.5:997
msgid "This section is reserved but has unspecified semantics."
msgstr "Данный тип сегмента зарезервирован, но имеет неопределённую семантику."

#. type: TP
#: man-pages/man5/elf.5:997
#, no-wrap
msgid "B<SHT_DYNSYM>"
msgstr "B<SHT_DYNSYM>"

#. type: Plain text
#: man-pages/man5/elf.5:1004
msgid ""
"This section holds a minimal set of dynamic linking symbols.  An object file "
"can also contain a B<SHT_SYMTAB> section."
msgstr ""
"В этом разделе содержится минимальный набор символов для динамической "
"компоновки. В объектном файле также может быть раздел B<SHT_SYMTAB>."

#. type: TP
#: man-pages/man5/elf.5:1004
#, no-wrap
msgid "B<SHT_LOPROC>, B<SHT_HIPROC>"
msgstr "B<SHT_LOPROC>, B<SHT_HIPROC>"

#. type: Plain text
#: man-pages/man5/elf.5:1009
msgid ""
"Values in the inclusive range [B<SHT_LOPROC>, B<SHT_HIPROC>] are reserved "
"for processor-specific semantics."
msgstr ""
"Значения из диапазона B<SHT_LOPROC>, B<SHT_HIPROC>] (включительно) "
"зарезервированы для процессорно-ориентированной семантики."

#. type: TP
#: man-pages/man5/elf.5:1009
#, no-wrap
msgid "B<SHT_LOUSER>"
msgstr "B<SHT_LOUSER>"

#. type: Plain text
#: man-pages/man5/elf.5:1013
msgid ""
"This value specifies the lower bound of the range of indices reserved for "
"application programs."
msgstr ""
"Это значение указывает на нижнюю границу диапазона индексов, "
"зарезервированного для пользовательских программ."

#. type: TP
#: man-pages/man5/elf.5:1013
#, no-wrap
msgid "B<SHT_HIUSER>"
msgstr "B<SHT_HIUSER>"

#. type: Plain text
#: man-pages/man5/elf.5:1023
msgid ""
"This value specifies the upper bound of the range of indices reserved for "
"application programs.  Section types between B<SHT_LOUSER> and B<SHT_HIUSER> "
"may be used by the application, without conflicting with current or future "
"system-defined section types."
msgstr ""
"Это значение указывает на нижнюю границу диапазона индексов, "
"зарезервированного для пользовательских программ. Разделы с типами, имеющими "
"значение между B<SHT_LOUSER> и B<SHT_HIUSER>, могут использоваться "
"приложениями не конфликтуя с имеющимися или будущими типами разделов, "
"определяемых системой."

#. type: TP
#: man-pages/man5/elf.5:1024
#, no-wrap
msgid "I<sh_flags>"
msgstr "I<sh_flags>"

#. type: Plain text
#: man-pages/man5/elf.5:1036
msgid ""
"Sections support one-bit flags that describe miscellaneous attributes.  If a "
"flag bit is set in I<sh_flags>, the attribute is \"on\" for the section.  "
"Otherwise, the attribute is \"off\" or does not apply.  Undefined attributes "
"are set to zero."
msgstr ""
"В этом поле указываются различные атрибуты раздела, задаваемые в виде "
"однобитных флагов. Если бит флага установлен в I<sh_flags>, то атрибут "
"\"активен\" для раздела. Иначе атрибут \"выключен\" или не применяется. Не "
"указанные атрибуты сбрасываются в ноль."

#. type: TP
#: man-pages/man5/elf.5:1037
#, no-wrap
msgid "B<SHF_WRITE>"
msgstr "B<SHF_WRITE>"

#. type: Plain text
#: man-pages/man5/elf.5:1041
msgid ""
"This section contains data that should be writable during process execution."
msgstr ""
"В разделе содержатся данные, к которым при работе процесса нужен доступ на "
"запись."

#. type: TP
#: man-pages/man5/elf.5:1041
#, no-wrap
msgid "B<SHF_ALLOC>"
msgstr "B<SHF_ALLOC>"

#. type: Plain text
#: man-pages/man5/elf.5:1048
msgid ""
"This section occupies memory during process execution.  Some control "
"sections do not reside in the memory image of an object file.  This "
"attribute is off for those sections."
msgstr ""
"Этот раздел занимает память при работе процесса. Некоторые управляющие "
"разделы не располагаются в образе памяти объектного файла. Этот атрибут "
"выключен у таких разделов."

#. type: TP
#: man-pages/man5/elf.5:1048
#, no-wrap
msgid "B<SHF_EXECINSTR>"
msgstr "B<SHF_EXECINSTR>"

#. type: Plain text
#: man-pages/man5/elf.5:1051
msgid "This section contains executable machine instructions."
msgstr "Этот раздел содержит исполняемые машинные инструкции."

#. type: TP
#: man-pages/man5/elf.5:1051
#, no-wrap
msgid "B<SHF_MASKPROC>"
msgstr "B<SHF_MASKPROC>"

#. type: Plain text
#: man-pages/man5/elf.5:1055
msgid ""
"All bits included in this mask are reserved for processor-specific semantics."
msgstr ""
"Все биты этой маски зарезервированы для процессорно-ориентированной "
"семантики."

#. type: TP
#: man-pages/man5/elf.5:1056
#, no-wrap
msgid "I<sh_addr>"
msgstr "I<sh_addr>"

#. type: Plain text
#: man-pages/man5/elf.5:1061
msgid ""
"If this section appears in the memory image of a process, this member holds "
"the address at which the section's first byte should reside.  Otherwise, the "
"member contains zero."
msgstr ""
"Если этот раздел появляется в образе памяти процесса, то это поле содержит "
"адрес, по которому должен располагаться первый байт раздела. Иначе поле "
"содержит ноль."

#. type: TP
#: man-pages/man5/elf.5:1061
#, no-wrap
msgid "I<sh_offset>"
msgstr "I<sh_offset>"

#. type: Plain text
#: man-pages/man5/elf.5:1070
msgid ""
"This member's value holds the byte offset from the beginning of the file to "
"the first byte in the section.  One section type, B<SHT_NOBITS>, occupies no "
"space in the file, and its I<sh_offset> member locates the conceptual "
"placement in the file."
msgstr ""
"В этом поле содержится смещение в байтах от начала файла до первого байта "
"раздела. Раздел типа B<SHT_NOBITS> не занимает места в файле и его поле "
"I<sh_offset> содержит умозрительное размещение в файле."

#. type: TP
#: man-pages/man5/elf.5:1070
#, no-wrap
msgid "I<sh_size>"
msgstr "I<sh_size>"

#. type: Plain text
#: man-pages/man5/elf.5:1082
msgid ""
"This member holds the section's size in bytes.  Unless the section type is "
"B<SHT_NOBITS>, the section occupies I<sh_size> bytes in the file.  A section "
"of type B<SHT_NOBITS> may have a nonzero size, but it occupies no space in "
"the file."
msgstr ""
"В этом поле содержится размер раздела в байтах. За исключением раздела с "
"типом B<SHT_NOBITS>, все разделы занимают I<sh_size> байт в файле. Раздел с "
"типом B<SHT_NOBITS> может иметь ненулевой размер, но места в файле не "
"занимает."

#. type: TP
#: man-pages/man5/elf.5:1082
#, no-wrap
msgid "I<sh_link>"
msgstr "I<sh_link>"

#. type: Plain text
#: man-pages/man5/elf.5:1086
msgid ""
"This member holds a section header table index link, whose interpretation "
"depends on the section type."
msgstr ""
"В этом поле содержится ссылка-индекс в таблицу заголовков раздела, а "
"интерпретация зависит от типа раздела."

#. type: TP
#: man-pages/man5/elf.5:1086
#, no-wrap
msgid "I<sh_info>"
msgstr "I<sh_info>"

#. type: Plain text
#: man-pages/man5/elf.5:1090
msgid ""
"This member holds extra information, whose interpretation depends on the "
"section type."
msgstr ""
"В этом поле содержится дополнительная информация, чья интерпретация зависит "
"от типа раздела."

#. type: TP
#: man-pages/man5/elf.5:1090
#, no-wrap
msgid "I<sh_addralign>"
msgstr "I<sh_addralign>"

#. type: Plain text
#: man-pages/man5/elf.5:1102
msgid ""
"Some sections have address alignment constraints.  If a section holds a "
"doubleword, the system must ensure doubleword alignment for the entire "
"section.  That is, the value of I<sh_addr> must be congruent to zero, modulo "
"the value of I<sh_addralign>.  Only zero and positive integral powers of two "
"are allowed.  The value 0 or 1 means that the section has no alignment "
"constraints."
msgstr ""
"Некоторые разделы имеют требования по выравниванию адресов. Если раздел "
"содержит двойное слово, то система должна произвести выравнивание по "
"двойному слову всего раздела. То есть, значение I<sh_addr> должно быть "
"таким, чтобы при делении по модулю I<sh_addralign> получался ноль. Разрешены "
"только ноль и положительные степени двойки. Значение 0 или 1 означают, что "
"раздел не имеет требований по выравниванию."

#. type: TP
#: man-pages/man5/elf.5:1102
#, no-wrap
msgid "I<sh_entsize>"
msgstr "I<sh_entsize>"

#. type: Plain text
#: man-pages/man5/elf.5:1108
msgid ""
"Some sections hold a table of fixed-sized entries, such as a symbol table.  "
"For such a section, this member gives the size in bytes for each entry.  "
"This member contains zero if the section does not hold a table of fixed-size "
"entries."
msgstr ""
"В некоторых разделах содержатся таблицы с элементами одинакового размера, "
"например, таблица символов. Для таких разделов в данном поле указывается "
"размер в байтах каждого элемента. Если раздел содержит таблицу с элементами "
"разного размера, то это поле равно нулю."

#. type: Plain text
#: man-pages/man5/elf.5:1110
msgid "Various sections hold program and control information:"
msgstr "Программа и управляющая информация содержится в различных разделах:"

#. type: TP
#: man-pages/man5/elf.5:1110
#, no-wrap
msgid "I<.bss>"
msgstr "I<.bss>"

#. type: Plain text
#: man-pages/man5/elf.5:1122
msgid ""
"This section holds uninitialized data that contributes to the program's "
"memory image.  By definition, the system initializes the data with zeros "
"when the program begins to run.  This section is of type B<SHT_NOBITS>.  The "
"attribute types are B<SHF_ALLOC> and B<SHF_WRITE>."
msgstr ""
"В этом разделе содержатся неинициализированные данные, которые вносятся в "
"образ программы в памяти. По определению, в начале выполнения программы "
"система инициализирует эти данные нулями. Этот раздел имеет тип "
"B<SHT_NOBITS> и атрибуты B<SHF_ALLOC> и B<SHF_WRITE>."

#. type: TP
#: man-pages/man5/elf.5:1122
#, no-wrap
msgid "I<.comment>"
msgstr "I<.comment>"

#. type: Plain text
#: man-pages/man5/elf.5:1128
msgid ""
"This section holds version control information.  This section is of type "
"B<SHT_PROGBITS>.  No attribute types are used."
msgstr ""
"В этом разделе содержится управляющая информация о версии. Он имеет тип "
"B<SHT_PROGBITS> и не имеет атрибутов."

#. type: TP
#: man-pages/man5/elf.5:1128
#, no-wrap
msgid "I<.ctors>"
msgstr "I<.ctors>"

#. type: Plain text
#: man-pages/man5/elf.5:1137
msgid ""
"This section holds initialized pointers to the C++ constructor functions.  "
"This section is of type B<SHT_PROGBITS>.  The attribute types are "
"B<SHF_ALLOC> and B<SHF_WRITE>."
msgstr ""
"В этом разделе содержатся инициализированные указатели функций-конструкторов "
"C++. Он имеет тип B<SHT_PROGBITS> и атрибуты B<SHF_ALLOC> и B<SHF_WRITE>."

#. type: TP
#: man-pages/man5/elf.5:1137
#, no-wrap
msgid "I<.data>"
msgstr "I<.data>"

#. type: Plain text
#: man-pages/man5/elf.5:1147 man-pages/man5/elf.5:1157
msgid ""
"This section holds initialized data that contribute to the program's memory "
"image.  This section is of type B<SHT_PROGBITS>.  The attribute types are "
"B<SHF_ALLOC> and B<SHF_WRITE>."
msgstr ""
"В этом разделе содержатся инициализированные данные, которые вносятся в "
"образ программы в памяти. Он имеет тип B<SHT_PROGBITS> и атрибуты "
"B<SHF_ALLOC> и B<SHF_WRITE>."

#. type: TP
#: man-pages/man5/elf.5:1147
#, no-wrap
msgid "I<.data1>"
msgstr "I<.data1>"

#. type: TP
#: man-pages/man5/elf.5:1157
#, no-wrap
msgid "I<.debug>"
msgstr "I<.debug>"

#. type: Plain text
#: man-pages/man5/elf.5:1165
msgid ""
"This section holds information for symbolic debugging.  The contents are "
"unspecified.  This section is of type B<SHT_PROGBITS>.  No attribute types "
"are used."
msgstr ""
"В этом разделе содержится информация для символьной отладки. Формат "
"содержимого не определён. Этот раздел имеет тип B<SHT_PROGBITS> и не имеет "
"атрибутов."

#. type: TP
#: man-pages/man5/elf.5:1165
#, no-wrap
msgid "I<.dtors>"
msgstr "I<.dtors>"

#. type: Plain text
#: man-pages/man5/elf.5:1174
msgid ""
"This section holds initialized pointers to the C++ destructor functions.  "
"This section is of type B<SHT_PROGBITS>.  The attribute types are "
"B<SHF_ALLOC> and B<SHF_WRITE>."
msgstr ""
"В этом разделе содержатся инициализированные указатели функций-деструкторов C"
"++. Он имеет тип B<SHT_PROGBITS> и атрибуты B<SHF_ALLOC> и B<SHF_WRITE>."

#. type: TP
#: man-pages/man5/elf.5:1174
#, no-wrap
msgid "I<.dynamic>"
msgstr "I<.dynamic>"

#. type: Plain text
#: man-pages/man5/elf.5:1187
msgid ""
"This section holds dynamic linking information.  The section's attributes "
"will include the B<SHF_ALLOC> bit.  Whether the B<SHF_WRITE> bit is set is "
"processor-specific.  This section is of type B<SHT_DYNAMIC>.  See the "
"attributes above."
msgstr ""
"В этом разделе содержится информация о динамической компоновке. К атрибутам "
"раздела будет добавлен бит B<SHF_ALLOC>. В зависимости от процессора может "
"быть установлен бит B<SHF_WRITE>. Этот раздел имеет тип B<SHT_DYNAMIC>."

#. type: TP
#: man-pages/man5/elf.5:1187
#, no-wrap
msgid "I<.dynstr>"
msgstr "I<.dynstr>"

#. type: Plain text
#: man-pages/man5/elf.5:1195
msgid ""
"This section holds strings needed for dynamic linking, most commonly the "
"strings that represent the names associated with symbol table entries.  This "
"section is of type B<SHT_STRTAB>.  The attribute type used is B<SHF_ALLOC>."
msgstr ""
"В этом разделе содержатся строки, необходимые для динамической компоновки; "
"чаще всего это строки, представляющие имена, связанные с элементами таблицы "
"символов. Этот раздел имеет тип B<SHT_STRTAB> и атрибут B<SHF_ALLOC>."

#. type: TP
#: man-pages/man5/elf.5:1195
#, no-wrap
msgid "I<.dynsym>"
msgstr "I<.dynsym>"

#. type: Plain text
#: man-pages/man5/elf.5:1202
msgid ""
"This section holds the dynamic linking symbol table.  This section is of "
"type B<SHT_DYNSYM>.  The attribute used is B<SHF_ALLOC>."
msgstr ""
"В этом разделе содержится таблица символов для динамической компоновки. Этот "
"раздел имеет тип B<SHT_DYNSYM> и атрибут B<SHF_ALLOC>."

#. type: TP
#: man-pages/man5/elf.5:1202
#, no-wrap
msgid "I<.fini>"
msgstr "I<.fini>"

#. type: Plain text
#: man-pages/man5/elf.5:1214
msgid ""
"This section holds executable instructions that contribute to the process "
"termination code.  When a program exits normally the system arranges to "
"execute the code in this section.  This section is of type B<SHT_PROGBITS>.  "
"The attributes used are B<SHF_ALLOC> and B<SHF_EXECINSTR>."
msgstr ""
"В этом разделе содержатся исполняемые инструкции, которые вносятся в код "
"завершения процесса. При нормальном завершении программы система передаёт "
"выполнение коду из этого раздела. Этот раздел имеет тип B<SHT_PROGBITS> и "
"атрибуты B<SHF_ALLOC> и B<SHF_EXECINSTR>."

#. type: TP
#: man-pages/man5/elf.5:1214
#, no-wrap
msgid "I<.gnu.version>"
msgstr "I<.gnu.version>"

#. type: Plain text
#: man-pages/man5/elf.5:1223
msgid ""
"This section holds the version symbol table, an array of I<ElfN_Half> "
"elements.  This section is of type B<SHT_GNU_versym>.  The attribute type "
"used is B<SHF_ALLOC>."
msgstr ""
"В этом разделе содержится таблица версий символов, массив элементов "
"I<ElfN_Half>. Данный раздел имеет тип B<SHT_GNU_versym> и атрибут "
"B<SHF_ALLOC>."

#. type: TP
#: man-pages/man5/elf.5:1223
#, no-wrap
msgid "I<.gnu.version_d>"
msgstr "I<.gnu.version_d>"

#. type: Plain text
#: man-pages/man5/elf.5:1232
msgid ""
"This section holds the version symbol definitions, a table of I<ElfN_Verdef> "
"structures.  This section is of type B<SHT_GNU_verdef>.  The attribute type "
"used is B<SHF_ALLOC>."
msgstr ""
"В этом разделе содержатся определения версий символов, таблица структур "
"I<ElfN_Verdef>. Данный раздел имеет тип B<SHT_GNU_verdef> и атрибут "
"B<SHF_ALLOC>."

#. type: TP
#: man-pages/man5/elf.5:1232
#, no-wrap
msgid "I<.gnu.version_r>"
msgstr "I<.gnu.version_r>"

#. type: Plain text
#: man-pages/man5/elf.5:1242
msgid ""
"This section holds the version symbol needed elements, a table of "
"I<ElfN_Verneed> structures.  This section is of type B<SHT_GNU_versym>.  The "
"attribute type used is B<SHF_ALLOC>."
msgstr ""
"В этом разделе содержатся версии символов необходимых элементов, таблица "
"структур I<ElfN_Verneed>. Данный раздел имеет тип B<SHT_GNU_versym> и "
"атрибут B<SHF_ALLOC>."

#. type: TP
#: man-pages/man5/elf.5:1242
#, no-wrap
msgid "I<.got>"
msgstr "I<.got>"

#. type: Plain text
#: man-pages/man5/elf.5:1248
msgid ""
"This section holds the global offset table.  This section is of type "
"B<SHT_PROGBITS>.  The attributes are processor-specific."
msgstr ""
"В этом разделе содержится таблица глобальных перемещений. Он имеет тип "
"B<SHT_PROGBITS>. Набор используемых атрибутов зависит от процессора."

#. type: TP
#: man-pages/man5/elf.5:1248
#, no-wrap
msgid "I<.hash>"
msgstr "I<.hash>"

#. type: Plain text
#: man-pages/man5/elf.5:1255
msgid ""
"This section holds a symbol hash table.  This section is of type "
"B<SHT_HASH>.  The attribute used is B<SHF_ALLOC>."
msgstr ""
"В этом разделе содержится хэш-таблица символов. Он имеет тип B<SHT_HASH> и "
"атрибут B<SHF_ALLOC>."

#. type: TP
#: man-pages/man5/elf.5:1255
#, no-wrap
msgid "I<.init>"
msgstr "I<.init>"

#. type: Plain text
#: man-pages/man5/elf.5:1267
msgid ""
"This section holds executable instructions that contribute to the process "
"initialization code.  When a program starts to run the system arranges to "
"execute the code in this section before calling the main program entry "
"point.  This section is of type B<SHT_PROGBITS>.  The attributes used are "
"B<SHF_ALLOC> and B<SHF_EXECINSTR>."
msgstr ""
"В этом разделе содержатся исполняемые инструкции, которые вносятся в код "
"инициализации процесса. Когда программа запускается, система передаёт "
"выполнение коду из этого раздела до вызова основной программы. Данный раздел "
"имеет тип B<SHT_PROGBITS> и атрибуты B<SHF_ALLOC> и B<SHF_EXECINSTR>."

#. type: TP
#: man-pages/man5/elf.5:1267
#, no-wrap
msgid "I<.interp>"
msgstr "I<.interp>"

#. type: Plain text
#: man-pages/man5/elf.5:1278
msgid ""
"This section holds the pathname of a program interpreter.  If the file has a "
"loadable segment that includes the section, the section's attributes will "
"include the B<SHF_ALLOC> bit.  Otherwise, that bit will be off.  This "
"section is of type B<SHT_PROGBITS>."
msgstr ""
"В этом разделе содержится путь к интерпретатору программы. Если файл имеет "
"загружаемый сегмент, который включает раздел, то в атрибуты раздела будет "
"добавлен бит B<SHF_ALLOC>. Иначе этот бит будет обнулён. Данный раздел имеет "
"тип B<SHT_PROGBITS>."

#. type: TP
#: man-pages/man5/elf.5:1278
#, no-wrap
msgid "I<.line>"
msgstr "I<.line>"

#. type: Plain text
#: man-pages/man5/elf.5:1287
msgid ""
"This section holds line number information for symbolic debugging, which "
"describes the correspondence between the program source and the machine "
"code.  The contents are unspecified.  This section is of type "
"B<SHT_PROGBITS>.  No attribute types are used."
msgstr ""
"В этом разделе содержатся информация о номерах строк для символьной отладки, "
"которая описывает соответствие между исходным кодом программы и машинным "
"кодом. Формат содержимого не определён. Данный раздел имеет тип "
"B<SHT_PROGBITS> и не имеет атрибутов."

#. type: TP
#: man-pages/man5/elf.5:1287
#, no-wrap
msgid "I<.note>"
msgstr "I<.note>"

#. type: Plain text
#: man-pages/man5/elf.5:1293
msgid ""
"This section holds various notes.  This section is of type B<SHT_NOTE>.  No "
"attribute types are used."
msgstr ""
"В этом разделе содержатся различные заметки. Он имеет тип B<SHT_NOTE>. Типы "
"атрибутов атрибутов не используются."

#. type: TP
#: man-pages/man5/elf.5:1293
#, no-wrap
msgid "I<.note.ABI-tag>"
msgstr "I<.note.ABI-tag>"

#. type: Plain text
#: man-pages/man5/elf.5:1301
msgid ""
"This section is used to declare the expected run-time ABI of the ELF image.  "
"It may include the operating system name and its run-time versions.  This "
"section is of type B<SHT_NOTE>.  The only attribute used is B<SHF_ALLOC>."
msgstr ""
"Этот раздел используется для объявления ожидаемой образом ELF среды "
"выполнения (run-time) ABI. Здесь может указываться имя операционной системы "
"и её версии среды выполнения. Данный раздел имеет тип B<SHT_NOTE>. "
"Используется только атрибут B<SHF_ALLOC>."

#. type: TP
#: man-pages/man5/elf.5:1301
#, no-wrap
msgid "I<.note.gnu.build-id>"
msgstr "I<.note.gnu.build-id>"

#. type: Plain text
#: man-pages/man5/elf.5:1314
msgid ""
"This section is used to hold an ID that uniquely identifies the contents of "
"the ELF image.  Different files with the same build ID should contain the "
"same executable content.  See the B<--build-id> option to the GNU linker "
"(B<ld> (1)) for more details.  This section is of type B<SHT_NOTE>.  The "
"only attribute used is B<SHF_ALLOC>."
msgstr ""
"Данный раздел используется для хранения ID, который уникально отождествляет "
"содержимое образа ELF. Разные файлы с одинаковым ID сборки должны содержать "
"одинаковое исполняемого содержимое. Подробней смотрите в описании параметра "
"B<--build-id> компоновщика GNU (B<ld> (1)). Данный раздел имеет тип "
"B<SHT_NOTE>. Используется только атрибут B<SHF_ALLOC>."

#. type: TP
#: man-pages/man5/elf.5:1314
#, no-wrap
msgid "I<.note.GNU-stack>"
msgstr "I<.note.GNU-stack>"

#. type: Plain text
#: man-pages/man5/elf.5:1323
msgid ""
"This section is used in Linux object files for declaring stack attributes.  "
"This section is of type B<SHT_PROGBITS>.  The only attribute used is "
"B<SHF_EXECINSTR>.  This indicates to the GNU linker that the object file "
"requires an executable stack."
msgstr ""
"Этот раздел используется в объектных файлах Linux для объявления атрибутов "
"стека. Данный раздел имеет тип B<SHT_PROGBITS> и единственный атрибут "
"B<SHF_EXECINSTR>. Он указывает компоновщику GNU на необходимость объектного "
"файла иметь исполняемый стек."

#. type: TP
#: man-pages/man5/elf.5:1323
#, no-wrap
msgid "I<.note.openbsd.ident>"
msgstr "I<.note.openbsd.ident>"

#. type: Plain text
#: man-pages/man5/elf.5:1328
msgid ""
"OpenBSD native executables usually contain this section to identify "
"themselves so the kernel can bypass any compatibility ELF binary emulation "
"tests when loading the file."
msgstr ""
"Обычно, этот раздел содержится а собственных исполняемых файлах OpenBSD для "
"их идентификации, что используется ядром для пропуска тестирования на "
"необходимость эмуляции двоичных файлов ELF при загрузке файла."

#. type: TP
#: man-pages/man5/elf.5:1328
#, no-wrap
msgid "I<.plt>"
msgstr "I<.plt>"

#. type: Plain text
#: man-pages/man5/elf.5:1334
msgid ""
"This section holds the procedure linkage table.  This section is of type "
"B<SHT_PROGBITS>.  The attributes are processor-specific."
msgstr ""
"В этом разделе содержится таблица компоновки процедур. Он имеет тип "
"B<SHT_PROGBITS>. Набор используемых атрибутов зависит от процессора."

#. type: TP
#: man-pages/man5/elf.5:1334
#, no-wrap
msgid "I<.relNAME>"
msgstr "I<.relИМЯ>"

#. type: Plain text
#: man-pages/man5/elf.5:1353
msgid ""
"This section holds relocation information as described below.  If the file "
"has a loadable segment that includes relocation, the section's attributes "
"will include the B<SHF_ALLOC> bit.  Otherwise, the bit will be off.  By "
"convention, \"NAME\" is supplied by the section to which the relocations "
"apply.  Thus a relocation section for B<.text> normally would have the name "
"B<.rel.text>.  This section is of type B<SHT_REL>."
msgstr ""
"В этом разделе содержится информация о перемещениях, описываемая далее. Если "
"файл имеет загружаемый сегмент, включающий перемещение, то в атрибуты "
"раздела добавится бит B<SHF_ALLOC>. Иначе этот бит будет обнулён. По "
"соглашению, «ИМЯ» указывает на раздел, к которому применяются перемещения. "
"То есть раздел перемещений для B<.text> обычно называется B<.rel.text>. "
"Данный раздел имеет тип B<SHT_REL>."

#. type: TP
#: man-pages/man5/elf.5:1353
#, no-wrap
msgid "I<.relaNAME>"
msgstr "I<.relaNAME>"

#. type: Plain text
#: man-pages/man5/elf.5:1372
msgid ""
"This section holds relocation information as described below.  If the file "
"has a loadable segment that includes relocation, the section's attributes "
"will include the B<SHF_ALLOC> bit.  Otherwise, the bit will be off.  By "
"convention, \"NAME\" is supplied by the section to which the relocations "
"apply.  Thus a relocation section for B<.text> normally would have the name "
"B<.rela.text>.  This section is of type B<SHT_RELA>."
msgstr ""
"В этом разделе содержится информация о перемещениях, описываемая далее. Если "
"файл имеет загружаемый сегмент, включающий перемещение, то в атрибуты "
"раздела добавится бит B<SHF_ALLOC>. Иначе этот бит будет обнулён. По "
"соглашению, «ИМЯ» указывает на раздел, к которому применяются перемещения. "
"То есть раздел перемещений для B<.text> обычно называется B<.rela.text>. "
"Данный раздел имеет тип B<SHT_RELA>."

#. type: TP
#: man-pages/man5/elf.5:1372
#, no-wrap
msgid "I<.rodata>"
msgstr "I<.rodata>"

#. type: Plain text
#: man-pages/man5/elf.5:1380 man-pages/man5/elf.5:1388
msgid ""
"This section holds read-only data that typically contributes to a "
"nonwritable segment in the process image.  This section is of type "
"B<SHT_PROGBITS>.  The attribute used is B<SHF_ALLOC>."
msgstr ""
"В этом разделе содержатся данные, доступные только для чтения, которые "
"обычно вносятся в недоступный для записи сегмент образа процесса. Этот "
"раздел имеет тип B<SHT_PROGBITS> и атрибут B<SHF_ALLOC>."

#. type: TP
#: man-pages/man5/elf.5:1380
#, no-wrap
msgid "I<.rodata1>"
msgstr "I<.rodata1>"

#. type: TP
#: man-pages/man5/elf.5:1388
#, no-wrap
msgid "I<.shstrtab>"
msgstr "I<.shstrtab>"

#. type: Plain text
#: man-pages/man5/elf.5:1394
msgid ""
"This section holds section names.  This section is of type B<SHT_STRTAB>.  "
"No attribute types are used."
msgstr ""
"В этом разделе содержатся имена разделов. Он имеет тип B<SHT_STRTAB> и не "
"имеет атрибутов."

#. type: TP
#: man-pages/man5/elf.5:1394
#, no-wrap
msgid "I<.strtab>"
msgstr "I<.strtab>"

#. type: Plain text
#: man-pages/man5/elf.5:1406
msgid ""
"This section holds strings, most commonly the strings that represent the "
"names associated with symbol table entries.  If the file has a loadable "
"segment that includes the symbol string table, the section's attributes will "
"include the B<SHF_ALLOC> bit.  Otherwise, the bit will be off.  This section "
"is of type B<SHT_STRTAB>."
msgstr ""
"В этом разделе содержатся строки, чаще всего представляющие имена, связанные "
"с элементами таблицы символов. Если файл имеет загружаемый сегмент, который "
"включает таблицу строк символов, то к разделу атрибутов будет добавлен бит "
"B<SHF_ALLOC>. Иначе этот бит будет обнулён. Данный раздел имеет тип "
"B<SHT_STRTAB>."

#. type: TP
#: man-pages/man5/elf.5:1406
#, no-wrap
msgid "I<.symtab>"
msgstr "I<.symtab>"

#. type: Plain text
#: man-pages/man5/elf.5:1417
msgid ""
"This section holds a symbol table.  If the file has a loadable segment that "
"includes the symbol table, the section's attributes will include the "
"B<SHF_ALLOC> bit.  Otherwise, the bit will be off.  This section is of type "
"B<SHT_SYMTAB>."
msgstr ""
"В этом разделе содержится таблица символов. Если файл имеет загружаемый "
"сегмент, который включает таблицу символов, то к разделу атрибутов будет "
"добавлен бит B<SHF_ALLOC>. Иначе этот бит будет обнулён. Данный раздел имеет "
"тип B<SHT_SYMTAB>."

#. type: TP
#: man-pages/man5/elf.5:1417
#, no-wrap
msgid "I<.text>"
msgstr "I<.text>"

#. type: Plain text
#: man-pages/man5/elf.5:1429
msgid ""
"This section holds the \"text\", or executable instructions, of a program.  "
"This section is of type B<SHT_PROGBITS>.  The attributes used are "
"B<SHF_ALLOC> and B<SHF_EXECINSTR>."
msgstr ""
"В этом разделе содержится \"код (text)\", то есть исполняемые инструкции "
"программы. Он имеет тип B<SHT_PROGBITS> и атрибуты B<SHF_ALLOC> и "
"B<SHF_EXECINSTR>."

#. type: SS
#: man-pages/man5/elf.5:1429
#, no-wrap
msgid "String and symbol tables"
msgstr "Таблицы строк и символов"

#. type: Plain text
#: man-pages/man5/elf.5:1440
msgid ""
"String table sections hold null-terminated character sequences, commonly "
"called strings.  The object file uses these strings to represent symbol and "
"section names.  One references a string as an index into the string table "
"section.  The first byte, which is index zero, is defined to hold a null "
"byte (\\(aq\\e0\\(aq).  Similarly, a string table's last byte is defined to "
"hold a null byte, ensuring null termination for all strings."
msgstr ""
"В разделах с таблицами строк содержатся символьные последовательности, "
"завершающиеся null, которые обычно называются строками. Объектный файл "
"использует эти строки для имён символов и разделов. Он ссылается на строку "
"посредством индекса в разделе таблицы строк. В первом байте с нулевым "
"индексом задаётся байт null (\\(aq\\e0\\(aq). Подобно этому, для обеспечения "
"завершения null всех строк последний байт таблицы строк также содержит байт "
"null."

#. type: Plain text
#: man-pages/man5/elf.5:1445
msgid ""
"An object file's symbol table holds information needed to locate and "
"relocate a program's symbolic definitions and references.  A symbol table "
"index is a subscript into this array."
msgstr ""
"В таблице символов объектного файла содержится информация, необходимая для "
"обнаружения и перемещения определённых в программе символов и ссылок. Индекс "
"таблицы символов указывает на элемент из этого массива."

#. type: Plain text
#: man-pages/man5/elf.5:1456
#, no-wrap
msgid ""
"typedef struct {\n"
"    uint32_t      st_name;\n"
"    Elf32_Addr    st_value;\n"
"    uint32_t      st_size;\n"
"    unsigned char st_info;\n"
"    unsigned char st_other;\n"
"    uint16_t      st_shndx;\n"
"} Elf32_Sym;\n"
msgstr ""
"typedef struct {\n"
"    uint32_t      st_name;\n"
"    Elf32_Addr    st_value;\n"
"    uint32_t      st_size;\n"
"    unsigned char st_info;\n"
"    unsigned char st_other;\n"
"    uint16_t      st_shndx;\n"
"} Elf32_Sym;\n"

#. type: Plain text
#: man-pages/man5/elf.5:1469
#, no-wrap
msgid ""
"typedef struct {\n"
"    uint32_t      st_name;\n"
"    unsigned char st_info;\n"
"    unsigned char st_other;\n"
"    uint16_t      st_shndx;\n"
"    Elf64_Addr    st_value;\n"
"    uint64_t      st_size;\n"
"} Elf64_Sym;\n"
msgstr ""
"typedef struct {\n"
"    uint32_t      st_name;\n"
"    unsigned char st_info;\n"
"    unsigned char st_other;\n"
"    uint16_t      st_shndx;\n"
"    Elf64_Addr    st_value;\n"
"    uint64_t      st_size;\n"
"} Elf64_Sym;\n"

#. type: Plain text
#: man-pages/man5/elf.5:1474
msgid ""
"The 32-bit and 64-bit versions have the same members, just in a different "
"order."
msgstr ""
"32-битная и 64-битная версии имеют одинаковые поля, различен только их "
"порядок."

#. type: TP
#: man-pages/man5/elf.5:1474
#, no-wrap
msgid "I<st_name>"
msgstr "I<st_name>"

#. type: Plain text
#: man-pages/man5/elf.5:1482
msgid ""
"This member holds an index into the object file's symbol string table, which "
"holds character representations of the symbol names.  If the value is "
"nonzero, it represents a string table index that gives the symbol name.  "
"Otherwise, the symbol has no name."
msgstr ""
"В этом поле содержится индекс на элемент в таблице строк символов объектного "
"файла, которая содержит символьное представление имён символов. Если "
"значение не равно нулю, то это индекс таблицы строк, по которому "
"определяется имя символа. Иначе символ не имеет имени."

#. type: TP
#: man-pages/man5/elf.5:1482
#, no-wrap
msgid "I<st_value>"
msgstr "I<st_value>"

#. type: Plain text
#: man-pages/man5/elf.5:1485
msgid "This member gives the value of the associated symbol."
msgstr "В этом поле содержится значение соответствующего символа."

#. type: TP
#: man-pages/man5/elf.5:1485
#, no-wrap
msgid "I<st_size>"
msgstr "I<st_size>"

#. type: Plain text
#: man-pages/man5/elf.5:1490
msgid ""
"Many symbols have associated sizes.  This member holds zero if the symbol "
"has no size or an unknown size."
msgstr ""
"Со многими символами связываются определённые размеры. Это поле имеет "
"значение ноль, если символ не имеет размера или его размер неизвестен."

#. type: TP
#: man-pages/man5/elf.5:1490
#, no-wrap
msgid "I<st_info>"
msgstr "I<st_info>"

#. type: Plain text
#: man-pages/man5/elf.5:1493
msgid "This member specifies the symbol's type and binding attributes:"
msgstr "В этом поле задаётся тип символа и атрибуты привязки:"

#. type: TP
#: man-pages/man5/elf.5:1494
#, no-wrap
msgid "B<STT_NOTYPE>"
msgstr "B<STT_NOTYPE>"

#. type: Plain text
#: man-pages/man5/elf.5:1497
msgid "The symbol's type is not defined."
msgstr "Тип символа не определён."

#. type: TP
#: man-pages/man5/elf.5:1497
#, no-wrap
msgid "B<STT_OBJECT>"
msgstr "B<STT_OBJECT>"

#. type: Plain text
#: man-pages/man5/elf.5:1500
msgid "The symbol is associated with a data object."
msgstr "Символу соответствует объект данных."

#. type: TP
#: man-pages/man5/elf.5:1500
#, no-wrap
msgid "B<STT_FUNC>"
msgstr "B<STT_FUNC>"

#. type: Plain text
#: man-pages/man5/elf.5:1503
msgid "The symbol is associated with a function or other executable code."
msgstr "Символу соответствует функция или другой исполняемый код."

#. type: TP
#: man-pages/man5/elf.5:1503
#, no-wrap
msgid "B<STT_SECTION>"
msgstr "B<STT_SECTION>"

#. type: Plain text
#: man-pages/man5/elf.5:1510
msgid ""
"The symbol is associated with a section.  Symbol table entries of this type "
"exist primarily for relocation and normally have B<STB_LOCAL> bindings."
msgstr ""
"Символу соответствует раздел. Элементы таблицы символов этого типа "
"существуют, прежде всего, для перемещения и обычно имеют привязки "
"B<STB_LOCAL>."

#. type: TP
#: man-pages/man5/elf.5:1510
#, no-wrap
msgid "B<STT_FILE>"
msgstr "B<STT_FILE>"

#. type: Plain text
#: man-pages/man5/elf.5:1521
msgid ""
"By convention, the symbol's name gives the name of the source file "
"associated with the object file.  A file symbol has B<STB_LOCAL> bindings, "
"its section index is B<SHN_ABS>, and it precedes the other B<STB_LOCAL> "
"symbols of the file, if it is present."
msgstr ""
"По соглашению, имя символа назначается согласно имени файла исходного кода "
"для соответствующего объектного файла. Файловый символ имеет привязки "
"B<STB_LOCAL>, его индекс раздела B<SHN_ABS>, и он предваряется другим "
"символом B<STB_LOCAL> файла, если он есть."

#. type: TP
#: man-pages/man5/elf.5:1521
#, no-wrap
msgid "B<STT_LOPROC>, B<STT_HIPROC>"
msgstr "B<STT_LOPROC>, B<STT_HIPROC>"

#. type: Plain text
#: man-pages/man5/elf.5:1526
msgid ""
"Values in the inclusive range [B<STT_LOPROC>, B<STT_HIPROC>] are reserved "
"for processor-specific semantics."
msgstr ""
"Значения из диапазона [B<STT_LOPROC>, B<STT_HIPROC>] (включительно) "
"зарезервированы для процессорно-ориентированной семантики."

#. type: TP
#: man-pages/man5/elf.5:1526
#, no-wrap
msgid "B<STB_LOCAL>"
msgstr "B<STB_LOCAL>"

#. type: Plain text
#: man-pages/man5/elf.5:1532
msgid ""
"Local symbols are not visible outside the object file containing their "
"definition.  Local symbols of the same name may exist in multiple files "
"without interfering with each other."
msgstr ""
"Локальные символы невидимы вне объектного файла, содержащего их определения. "
"Локальные символы с теми же именами могут существовать в нескольких файлах "
"не мешая друг другу."

#. type: TP
#: man-pages/man5/elf.5:1532
#, no-wrap
msgid "B<STB_GLOBAL>"
msgstr "B<STB_GLOBAL>"

#. type: Plain text
#: man-pages/man5/elf.5:1538
msgid ""
"Global symbols are visible to all object files being combined.  One file's "
"definition of a global symbol will satisfy another file's undefined "
"reference to the same symbol."
msgstr ""
"Глобальные символы видимы во всех объектных файлах после объединения. "
"Определение глобального символа в одном файле будет разрешать неопределённую "
"ссылку в другом файле для того же символа."

#. type: TP
#: man-pages/man5/elf.5:1538
#, no-wrap
msgid "B<STB_WEAK>"
msgstr "B<STB_WEAK>"

#. type: Plain text
#: man-pages/man5/elf.5:1542
msgid ""
"Weak symbols resemble global symbols, but their definitions have lower "
"precedence."
msgstr ""
"Слабые символы (weak symbols) похожи на глобальные символы, но их "
"определения имеют меньший приоритет."

#. type: TP
#: man-pages/man5/elf.5:1542
#, no-wrap
msgid "B<STB_LOPROC>, B<STB_HIPROC>"
msgstr "B<STB_LOPROC>, B<STB_HIPROC>"

#. type: Plain text
#: man-pages/man5/elf.5:1547
msgid ""
"Values in the inclusive range [B<STB_LOPROC>, B<STB_HIPROC>] are reserved "
"for processor-specific semantics."
msgstr ""
"Значения из диапазона [B<STB_LOPROC>, B<STB_HIPROC>] (включительно) "
"зарезервированы для процессорно-ориентированной семантики."

#. type: Plain text
#: man-pages/man5/elf.5:1550
msgid "There are macros for packing and unpacking the binding and type fields:"
msgstr "Макросы для упаковки и распаковки полей привязки и типа:"

#. type: TP
#: man-pages/man5/elf.5:1551
#, no-wrap
msgid "B<ELF32_ST_BIND(>I<info>B<)>, B<ELF64_ST_BIND(>I<info>B<)>"
msgstr "B<ELF32_ST_BIND(>I<info>B<)>, B<ELF64_ST_BIND(>I<info>B<)>"

#. type: Plain text
#: man-pages/man5/elf.5:1556
msgid "Extract a binding from an I<st_info> value."
msgstr "Извлекают привязку из значения I<st_info>."

#. type: TP
#: man-pages/man5/elf.5:1556
#, no-wrap
msgid "B<ELF32_ST_TYPE(>I<info>B<)>, B<ELF64_ST_TYPE(>I<info>B<)>"
msgstr "B<ELF32_ST_TYPE(>I<info>B<)>, B<ELF64_ST_TYPE(>I<info>B<)>"

#. type: Plain text
#: man-pages/man5/elf.5:1561
msgid "Extract a type from an I<st_info> value."
msgstr "Извлекают тип из значения I<st_info>."

#. type: TP
#: man-pages/man5/elf.5:1561
#, no-wrap
msgid "B<ELF32_ST_INFO(>I<bind>B<, >I<type>B<)>, B<ELF64_ST_INFO(>I<bind>B<, >I<type>B<)>"
msgstr "B<ELF32_ST_INFO(>I<bind>B<, >I<type>B<)>, B<ELF64_ST_INFO(>I<bind>B<, >I<type>B<)>"

#. type: Plain text
#: man-pages/man5/elf.5:1567
msgid "Convert a binding and a type into an I<st_info> value."
msgstr "Преобразуют привязку и тип в значение I<st_info>."

#. type: TP
#: man-pages/man5/elf.5:1568
#, no-wrap
msgid "I<st_other>"
msgstr "I<st_other>"

#. type: Plain text
#: man-pages/man5/elf.5:1571
msgid "This member defines the symbol visibility."
msgstr "Этим полем определяется видимость символа."

#. type: TP
#: man-pages/man5/elf.5:1572
#, no-wrap
msgid "B<STV_DEFAULT>"
msgstr "B<STV_DEFAULT>"

#. type: Plain text
#: man-pages/man5/elf.5:1579
msgid ""
"Default symbol visibility rules.  Global and weak symbols are available to "
"other modules; references in the local module can be interposed by "
"definitions in other modules."
msgstr ""
"Правила видимости символов по умолчанию. Глобальные и слабые символы "
"доступны в других модулях; ссылки в локальном модуле могут помещаться "
"определениями в других модулях."

#. type: TP
#: man-pages/man5/elf.5:1579
#, no-wrap
msgid "B<STV_INTERNAL>"
msgstr "B<STV_INTERNAL>"

#. type: Plain text
#: man-pages/man5/elf.5:1582
msgid "Processor-specific hidden class."
msgstr "Скрытый класс, зависящий от процессора."

#. type: TP
#: man-pages/man5/elf.5:1582
#, no-wrap
msgid "B<STV_HIDDEN>"
msgstr "B<STV_HIDDEN>"

#. type: Plain text
#: man-pages/man5/elf.5:1587
msgid ""
"Symbol is unavailable to other modules; references in the local module "
"always resolve to the local symbol (i.e., the symbol can't be interposed by "
"definitions in other modules)."
msgstr ""
"Символ недоступен в других модулях; ссылки в локальном модуле всегда "
"указывают на локальный символ (то есть, символ не может помещаться "
"определениями в других модулях)."

#. type: TP
#: man-pages/man5/elf.5:1587
#, no-wrap
msgid "B<STV_PROTECTED>"
msgstr "B<STV_PROTECTED>"

#. type: Plain text
#: man-pages/man5/elf.5:1591
msgid ""
"Symbol is available to other modules, but references in the local module "
"always resolve to the local symbol."
msgstr ""
"Символ доступен в других модулях, то ссылки в локальном модуле всегда "
"указывают на локальный символ."

#. type: Plain text
#: man-pages/man5/elf.5:1594
msgid "There are macros for extracting the visibility type:"
msgstr "Эти макросы служат для извлечения типа видимости:"

#. type: Plain text
#: man-pages/man5/elf.5:1598
msgid "B<ELF32_ST_VISIBILITY>(other)  or B<ELF64_ST_VISIBILITY>(other)"
msgstr "B<ELF32_ST_VISIBILITY>(other) или B<ELF64_ST_VISIBILITY>(other)"

#. type: TP
#: man-pages/man5/elf.5:1599
#, no-wrap
msgid "I<st_shndx>"
msgstr "I<st_shndx>"

#. type: Plain text
#: man-pages/man5/elf.5:1607
msgid ""
"Every symbol table entry is \"defined\" in relation to some section.  This "
"member holds the relevant section header table index."
msgstr ""
"Каждый элемент таблицы символов «определён» в отношении к некоторому "
"разделу. Это поле содержит соответствующий индекс таблицы заголовков "
"разделов."

#. type: SS
#: man-pages/man5/elf.5:1607
#, no-wrap
msgid "Relocation entries (Rel & Rela)"
msgstr "Элементы перемещений (Rel & Rela)"

#. type: Plain text
#: man-pages/man5/elf.5:1615
msgid ""
"Relocation is the process of connecting symbolic references with symbolic "
"definitions.  Relocatable files must have information that describes how to "
"modify their section contents, thus allowing executable and shared object "
"files to hold the right information for a process's program image.  "
"Relocation entries are these data."
msgstr ""
"Перемещение \\(em это процесс соединения символьных ссылок с символьными "
"определениями. Перемещаемые файлы должны иметь информацию, которая описывает "
"как нужно изменить их содержимое разделов, чтобы позволить исполняемым и "
"динамическим объектным файлам содержать корректную информацию для образа "
"процесса программы. Для этого существуют перемещения."

#. type: Plain text
#: man-pages/man5/elf.5:1617
msgid "Relocation structures that do not need an addend:"
msgstr "Перемещаемые структуры, которым не нужна добавка:"

#. type: Plain text
#: man-pages/man5/elf.5:1624
#, no-wrap
msgid ""
"typedef struct {\n"
"    Elf32_Addr r_offset;\n"
"    uint32_t   r_info;\n"
"} Elf32_Rel;\n"
msgstr ""
"typedef struct {\n"
"    Elf32_Addr r_offset;\n"
"    uint32_t   r_info;\n"
"} Elf32_Rel;\n"

#. type: Plain text
#: man-pages/man5/elf.5:1633
#, no-wrap
msgid ""
"typedef struct {\n"
"    Elf64_Addr r_offset;\n"
"    uint64_t   r_info;\n"
"} Elf64_Rel;\n"
msgstr ""
"typedef struct {\n"
"    Elf64_Addr r_offset;\n"
"    uint64_t   r_info;\n"
"} Elf64_Rel;\n"

#. type: Plain text
#: man-pages/man5/elf.5:1637
msgid "Relocation structures that need an addend:"
msgstr "Перемещаемые структуры, которым нужна добавка:"

#. type: Plain text
#: man-pages/man5/elf.5:1645
#, no-wrap
msgid ""
"typedef struct {\n"
"    Elf32_Addr r_offset;\n"
"    uint32_t   r_info;\n"
"    int32_t    r_addend;\n"
"} Elf32_Rela;\n"
msgstr ""
"typedef struct {\n"
"    Elf32_Addr r_offset;\n"
"    uint32_t   r_info;\n"
"    int32_t    r_addend;\n"
"} Elf32_Rela;\n"

#. type: Plain text
#: man-pages/man5/elf.5:1655
#, no-wrap
msgid ""
"typedef struct {\n"
"    Elf64_Addr r_offset;\n"
"    uint64_t   r_info;\n"
"    int64_t    r_addend;\n"
"} Elf64_Rela;\n"
msgstr ""
"typedef struct {\n"
"    Elf64_Addr r_offset;\n"
"    uint64_t   r_info;\n"
"    int64_t    r_addend;\n"
"} Elf64_Rela;\n"

#. type: TP
#: man-pages/man5/elf.5:1657
#, no-wrap
msgid "I<r_offset>"
msgstr "I<r_offset>"

#. type: Plain text
#: man-pages/man5/elf.5:1665
msgid ""
"This member gives the location at which to apply the relocation action.  For "
"a relocatable file, the value is the byte offset from the beginning of the "
"section to the storage unit affected by the relocation.  For an executable "
"file or shared object, the value is the virtual address of the storage unit "
"affected by the relocation."
msgstr ""
"В этом поле задаётся расположение, по которому применяется действие по "
"перемещению. Для файла, допускающего перемещения, значением является "
"байтовое смещение от начала раздела до хранимого элемента, подвергаемого "
"перемещению. Для исполняемого файла или динамического объекта значением "
"является виртуальный адрес хранимого элемента, подвергаемого перемещению."

#. type: TP
#: man-pages/man5/elf.5:1665
#, no-wrap
msgid "I<r_info>"
msgstr "I<r_info>"

#. type: Plain text
#: man-pages/man5/elf.5:1680
msgid ""
"This member gives both the symbol table index with respect to which the "
"relocation must be made and the type of relocation to apply.  Relocation "
"types are processor-specific.  When the text refers to a relocation entry's "
"relocation type or symbol table index, it means the result of applying "
"B<ELF[32|64]_R_TYPE> or B<ELF[32|64]_R_SYM>, respectively, to the entry's "
"I<r_info> member."
msgstr ""
"В этом поле указывается индекс таблицы символов с соблюдением того, что "
"нужно выполнить перемещение и тип применяемого перемещения. Типы перемещений "
"зависят от архитектуры процессора. Когда в коде есть ссылка на тип "
"перемещения элемента перемещения или индекс таблицы символов, то имеется в "
"виду результат применения B<ELF[32|64]_R_TYPE> или B<ELF[32|64]_R_SYM>, "
"соответственно, к полю I<r_info>."

#. type: TP
#: man-pages/man5/elf.5:1680
#, no-wrap
msgid "I<r_addend>"
msgstr "I<r_addend>"

#. type: Plain text
#: man-pages/man5/elf.5:1685
msgid ""
"This member specifies a constant addend used to compute the value to be "
"stored into the relocatable field."
msgstr ""
"В этом поле указывается константа-добавка, используемая для вычисления "
"значения, хранимого в поле перемещения."

#. type: SS
#: man-pages/man5/elf.5:1685
#, no-wrap
msgid "Dynamic tags (Dyn)"
msgstr "Динамические метки (Dyn)"

#. type: Plain text
#: man-pages/man5/elf.5:1695
msgid ""
"The I<.dynamic> section contains a series of structures that hold relevant "
"dynamic linking information.  The I<d_tag> member controls the "
"interpretation of I<d_un>."
msgstr ""
"В разделе I<.dynamic> содержится несколько структур, в которых содержится "
"информация по динамической компоновке. Полем I<d_tag> контролируется "
"интерпретация I<d_un>."

#. type: Plain text
#: man-pages/man5/elf.5:1706
#, no-wrap
msgid ""
"typedef struct {\n"
"    Elf32_Sword    d_tag;\n"
"    union {\n"
"        Elf32_Word d_val;\n"
"        Elf32_Addr d_ptr;\n"
"    } d_un;\n"
"} Elf32_Dyn;\n"
"extern Elf32_Dyn _DYNAMIC[];\n"
msgstr ""
"typedef struct {\n"
"    Elf32_Sword    d_tag;\n"
"    union {\n"
"        Elf32_Word d_val;\n"
"        Elf32_Addr d_ptr;\n"
"    } d_un;\n"
"} Elf32_Dyn;\n"
"extern Elf32_Dyn _DYNAMIC[];\n"

#. type: Plain text
#: man-pages/man5/elf.5:1719
#, no-wrap
msgid ""
"typedef struct {\n"
"    Elf64_Sxword    d_tag;\n"
"    union {\n"
"        Elf64_Xword d_val;\n"
"        Elf64_Addr  d_ptr;\n"
"    } d_un;\n"
"} Elf64_Dyn;\n"
"extern Elf64_Dyn _DYNAMIC[];\n"
msgstr ""
"typedef struct {\n"
"    Elf64_Sxword    d_tag;\n"
"    union {\n"
"        Elf64_Xword d_val;\n"
"        Elf64_Addr  d_ptr;\n"
"    } d_un;\n"
"} Elf64_Dyn;\n"
"extern Elf64_Dyn _DYNAMIC[];\n"

#. type: TP
#: man-pages/man5/elf.5:1721
#, no-wrap
msgid "I<d_tag>"
msgstr "I<d_tag>"

#. type: Plain text
#: man-pages/man5/elf.5:1724
msgid "This member may have any of the following values:"
msgstr "В этом поле могут содержаться следующие значения:"

#. type: TP
#: man-pages/man5/elf.5:1725
#, no-wrap
msgid "B<DT_NULL>"
msgstr "B<DT_NULL>"

#. type: Plain text
#: man-pages/man5/elf.5:1728
msgid "Marks end of dynamic section"
msgstr "Этим значением помечается конец динамического раздела"

#. type: TP
#: man-pages/man5/elf.5:1728
#, no-wrap
msgid "B<DT_NEEDED>"
msgstr "B<DT_NEEDED>"

#. type: Plain text
#: man-pages/man5/elf.5:1731
msgid "String table offset to name of a needed library"
msgstr "Смещение в таблице строк на имя необходимой библиотеки"

#. type: TP
#: man-pages/man5/elf.5:1731
#, no-wrap
msgid "B<DT_PLTRELSZ>"
msgstr "B<DT_PLTRELSZ>"

#. type: Plain text
#: man-pages/man5/elf.5:1734
msgid "Size in bytes of PLT relocation entries"
msgstr "Размер в байтах элементов перемещений PLT"

#. type: TP
#: man-pages/man5/elf.5:1734
#, no-wrap
msgid "B<DT_PLTGOT>"
msgstr "B<DT_PLTGOT>"

#. type: Plain text
#: man-pages/man5/elf.5:1737
msgid "Address of PLT and/or GOT"
msgstr "Адрес PLT и/или GOT"

#. type: TP
#: man-pages/man5/elf.5:1737
#, no-wrap
msgid "B<DT_HASH>"
msgstr "B<DT_HASH>"

#. type: Plain text
#: man-pages/man5/elf.5:1740
msgid "Address of symbol hash table"
msgstr "Адрес хэш-таблицы символов"

#. type: TP
#: man-pages/man5/elf.5:1740
#, no-wrap
msgid "B<DT_STRTAB>"
msgstr "B<DT_STRTAB>"

#. type: Plain text
#: man-pages/man5/elf.5:1743
msgid "Address of string table"
msgstr "Адрес таблицы строк"

#. type: TP
#: man-pages/man5/elf.5:1743
#, no-wrap
msgid "B<DT_SYMTAB>"
msgstr "B<DT_SYMTAB>"

#. type: Plain text
#: man-pages/man5/elf.5:1746
msgid "Address of symbol table"
msgstr "Адрес таблицы символов"

#. type: TP
#: man-pages/man5/elf.5:1746
#, no-wrap
msgid "B<DT_RELA>"
msgstr "B<DT_RELA>"

#. type: Plain text
#: man-pages/man5/elf.5:1749
msgid "Address of Rela relocation table"
msgstr "Адрес таблицы перемещений Rela"

#. type: TP
#: man-pages/man5/elf.5:1749
#, no-wrap
msgid "B<DT_RELASZ>"
msgstr "B<DT_RELASZ>"

#. type: Plain text
#: man-pages/man5/elf.5:1752
msgid "Size in bytes of the Rela relocation table"
msgstr "Размер в байтах таблицы перемещений Rela"

#. type: TP
#: man-pages/man5/elf.5:1752
#, no-wrap
msgid "B<DT_RELAENT>"
msgstr "B<DT_RELAENT>"

#. type: Plain text
#: man-pages/man5/elf.5:1755
msgid "Size in bytes of a Rela relocation table entry"
msgstr "Размер в байтах элемента таблицы перемещений Rela"

#. type: TP
#: man-pages/man5/elf.5:1755
#, no-wrap
msgid "B<DT_STRSZ>"
msgstr "B<DT_STRSZ>"

#. type: Plain text
#: man-pages/man5/elf.5:1758
msgid "Size in bytes of string table"
msgstr "Размер в байтах таблицы строк"

#. type: TP
#: man-pages/man5/elf.5:1758
#, no-wrap
msgid "B<DT_SYMENT>"
msgstr "B<DT_SYMENT>"

#. type: Plain text
#: man-pages/man5/elf.5:1761
msgid "Size in bytes of a symbol table entry"
msgstr "Размер в байтах элемента таблицы строк"

#. type: TP
#: man-pages/man5/elf.5:1761
#, no-wrap
msgid "B<DT_INIT>"
msgstr "B<DT_INIT>"

#. type: Plain text
#: man-pages/man5/elf.5:1764
msgid "Address of the initialization function"
msgstr "Адрес функции инициализации"

#. type: TP
#: man-pages/man5/elf.5:1764
#, no-wrap
msgid "B<DT_FINI>"
msgstr "B<DT_FINI>"

#. type: Plain text
#: man-pages/man5/elf.5:1767
msgid "Address of the termination function"
msgstr "Адрес функции окончания"

#. type: TP
#: man-pages/man5/elf.5:1767
#, no-wrap
msgid "B<DT_SONAME>"
msgstr "B<DT_SONAME>"

#. type: Plain text
#: man-pages/man5/elf.5:1770
msgid "String table offset to name of shared object"
msgstr "Смещение в таблице строк для имени динамического объекта"

#. type: TP
#: man-pages/man5/elf.5:1770
#, no-wrap
msgid "B<DT_RPATH>"
msgstr "B<DT_RPATH>"

#. type: Plain text
#: man-pages/man5/elf.5:1773
msgid "String table offset to library search path (deprecated)"
msgstr "Смещение в таблице строк для пути поиска (устарело)"

#. type: TP
#: man-pages/man5/elf.5:1773
#, no-wrap
msgid "B<DT_SYMBOLIC>"
msgstr "B<DT_SYMBOLIC>"

#. type: Plain text
#: man-pages/man5/elf.5:1776
msgid ""
"Alert linker to search this shared object before the executable for symbols"
msgstr ""
"Уведомление для компоновщика, что нужно искать этот динамический объект до "
"поиска символов в исполняемом файле"

#. type: TP
#: man-pages/man5/elf.5:1776
#, no-wrap
msgid "B<DT_REL>"
msgstr "B<DT_REL>"

#. type: Plain text
#: man-pages/man5/elf.5:1779
msgid "Address of Rel relocation table"
msgstr "Адрес таблицы перемещений Rel"

#. type: TP
#: man-pages/man5/elf.5:1779
#, no-wrap
msgid "B<DT_RELSZ>"
msgstr "B<DT_RELSZ>"

#. type: Plain text
#: man-pages/man5/elf.5:1782
msgid "Size in bytes of Rel relocation table"
msgstr "Размер в байтах таблицы перемещений Rel"

#. type: TP
#: man-pages/man5/elf.5:1782
#, no-wrap
msgid "B<DT_RELENT>"
msgstr "B<DT_RELENT>"

#. type: Plain text
#: man-pages/man5/elf.5:1785
msgid "Size in bytes of a Rel table entry"
msgstr "Размер в байтах элемента таблицы Rel"

#. type: TP
#: man-pages/man5/elf.5:1785
#, no-wrap
msgid "B<DT_PLTREL>"
msgstr "B<DT_PLTREL>"

#. type: Plain text
#: man-pages/man5/elf.5:1788
msgid "Type of relocation entry to which the PLT refers (Rela or Rel)"
msgstr "Тип элемента перемещения, на который ссылается PLT (Rela или Rel)"

#. type: TP
#: man-pages/man5/elf.5:1788
#, no-wrap
msgid "B<DT_DEBUG>"
msgstr "B<DT_DEBUG>"

#. type: Plain text
#: man-pages/man5/elf.5:1791
msgid "Undefined use for debugging"
msgstr "Не определено, используется для отладки"

#. type: TP
#: man-pages/man5/elf.5:1791
#, no-wrap
msgid "B<DT_TEXTREL>"
msgstr "B<DT_TEXTREL>"

#. type: Plain text
#: man-pages/man5/elf.5:1795
msgid ""
"Absence of this entry indicates that no relocation entries should apply to a "
"nonwritable segment"
msgstr ""
"Отсутствие этого элемента указывает, что перемещения не должны применяться к "
"сегменту, недоступному на запись"

#. type: TP
#: man-pages/man5/elf.5:1795
#, no-wrap
msgid "B<DT_JMPREL>"
msgstr "B<DT_JMPREL>"

#. type: Plain text
#: man-pages/man5/elf.5:1798
msgid "Address of relocation entries associated solely with the PLT"
msgstr "Адрес элементов перемещений, связанных исключительно с PLT"

#. type: TP
#: man-pages/man5/elf.5:1798
#, no-wrap
msgid "B<DT_BIND_NOW>"
msgstr "B<DT_BIND_NOW>"

#. type: Plain text
#: man-pages/man5/elf.5:1802
msgid ""
"Instruct dynamic linker to process all relocations before transferring "
"control to the executable"
msgstr ""
"Указать динамическому компоновщику, что нужно обработать все перемещения до "
"передачи управления исполняемому файлу"

#. type: TP
#: man-pages/man5/elf.5:1802
#, no-wrap
msgid "B<DT_RUNPATH>"
msgstr "B<DT_RUNPATH>"

#. type: Plain text
#: man-pages/man5/elf.5:1805
msgid "String table offset to library search path"
msgstr "Смещение в таблице строк для пути поиска библиотек"

#. type: TP
#: man-pages/man5/elf.5:1805
#, no-wrap
msgid "B<DT_LOPROC>, B<DT_HIPROC>"
msgstr "B<DT_LOPROC>, B<DT_HIPROC>"

#. type: Plain text
#: man-pages/man5/elf.5:1810
msgid ""
"Values in the inclusive range [B<DT_LOPROC>, B<DT_HIPROC>] are reserved for "
"processor-specific semantics"
msgstr ""
"Значения из диапазона [B<DT_LOPROC>, B<DT_HIPROC>] (включительно) "
"зарезервированы для процессорно-ориентированной семантики"

#. type: TP
#: man-pages/man5/elf.5:1811
#, no-wrap
msgid "I<d_val>"
msgstr "I<d_val>"

#. type: Plain text
#: man-pages/man5/elf.5:1814
msgid "This member represents integer values with various interpretations."
msgstr "В этом поле указываются целые (integer) значения различного смысла."

#. type: TP
#: man-pages/man5/elf.5:1814
#, no-wrap
msgid "I<d_ptr>"
msgstr "I<d_ptr>"

#. type: Plain text
#: man-pages/man5/elf.5:1822
msgid ""
"This member represents program virtual addresses.  When interpreting these "
"addresses, the actual address should be computed based on the original file "
"value and memory base address.  Files do not contain relocation entries to "
"fixup these addresses."
msgstr ""
"В этом поле указываются программные виртуальные адреса. При интерпретации "
"данных адресов, реальные адреса должны вычисляться на основе оригинального "
"значения из файла и базового адреса памяти. Файлы не содержат перемещаемых "
"элементов для местоположения этих адресов."

#. type: TP
#: man-pages/man5/elf.5:1822
#, no-wrap
msgid "I<_DYNAMIC>"
msgstr "I<_DYNAMIC>"

#.  GABI ELF Reference for Note Sections:
#.  http://www.sco.com/developers/gabi/latest/ch5.pheader.html#note_section
#.  Note that it implies the sizes and alignments of notes depend on the ELF
#.  size (e.g. 32-bit ELFs have three 4-byte words and use 4-byte alignment
#.  while 64-bit ELFs use 8-byte words & alignment), but that is not the case
#.  in the real world.  Notes always have three 4-byte words as can be seen
#.  in the source links below (remember that Elf64_Word is a 32-bit quantity).
#.  glibc:    https://sourceware.org/git/?p=glibc.git;a=blob;f=elf/elf.h;h=9e59b3275917549af0cebe1f2de9ded3b7b10bf2#l1173
#.  binutils: https://sourceware.org/git/?p=binutils-gdb.git;a=blob;f=binutils/readelf.c;h=274ddd17266aef6e4ad1f67af8a13a21500ff2af#l15943
#.  Linux:    https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/include/uapi/linux/elf.h?h=v4.8#n422
#.  Solaris:  https://docs.oracle.com/cd/E23824_01/html/819-0690/chapter6-18048.html
#.  FreeBSD:  https://svnweb.freebsd.org/base/head/sys/sys/elf_common.h?revision=303677&view=markup#l33
#.  NetBSD:   https://www.netbsd.org/docs/kernel/elf-notes.html
#.  OpenBSD:  https://github.com/openbsd/src/blob/master/sys/sys/exec_elf.h#L533
#. type: Plain text
#: man-pages/man5/elf.5:1844
msgid ""
"Array containing all the dynamic structures in the I<.dynamic> section.  "
"This is automatically populated by the linker."
msgstr ""
"Массив, содержащий все динамические структуры в разделе I<.dynamic>. "
"Автоматически заполняется компоновщиком."

#. type: SS
#: man-pages/man5/elf.5:1844
#, no-wrap
msgid "Notes (Nhdr)"
msgstr "Заметки (Nhdr)"

#. type: Plain text
#: man-pages/man5/elf.5:1854
msgid ""
"ELF notes allow for appending arbitrary information for the system to use.  "
"They are largely used by core files (I<e_type> of B<ET_CORE>), but many "
"projects define their own set of extensions.  For example, the GNU tool "
"chain uses ELF notes to pass information from the linker to the C library."
msgstr ""
"В заметки ELF можно добавлять произвольную информацию для использования в "
"системе. В основном, это используется в файлах core (I<e_type> равно "
"B<ET_CORE>), но многие проекты определяют свои собственные наборы "
"расширений. Например, набор инструментов GNU использует заметки ELF для "
"передачи информации компоновщика в библиотеку C."

#. type: Plain text
#: man-pages/man5/elf.5:1862
msgid ""
"Note sections contain a series of notes (see the I<struct> definitions "
"below).  Each note is followed by the name field (whose length is defined in "
"I<n_namesz>) and then by the descriptor field (whose length is defined in "
"I<n_descsz>) and whose starting address has a 4 byte alignment.  Neither "
"field is defined in the note struct due to their arbitrary lengths."
msgstr ""
"В разделах заметок содержатся последовательности заметки (смотрите "
"определение I<struct> далее). Каждая заметка сопровождается полем имени "
"(длина определяется в  I<n_namesz>) и полем дескриптора (длина задаётся в "
"I<n_descsz>) и начинается с адреса, кратного 4 байтам. Оба поля не "
"определены в структуре из-за их произвольной длины."

#. type: Plain text
#: man-pages/man5/elf.5:1865
msgid ""
"An example for parsing out two consecutive notes should clarify their layout "
"in memory:"
msgstr ""
"Пример разбора двух последовательных заметок должен разъяснить их "
"расположение в памяти:"

#. type: Plain text
#: man-pages/man5/elf.5:1870
#, no-wrap
msgid ""
"void *memory, *name, *desc;\n"
"Elf64_Nhdr *note, *next_note;\n"
msgstr ""
"void *memory, *name, *desc;\n"
"Elf64_Nhdr *note, *next_note;\n"

#. type: Plain text
#: man-pages/man5/elf.5:1873
#, no-wrap
msgid ""
"/* The buffer is pointing to the start of the section/segment */\n"
"note = memory;\n"
msgstr ""
"/* буфер, указывающий на начало раздела/сегмента */\n"
"note = memory;\n"

#. type: Plain text
#: man-pages/man5/elf.5:1876
#, no-wrap
msgid ""
"/* If the name is defined, it follows the note */\n"
"name = note-E<gt>n_namesz == 0 ? NULL : memory + sizeof(*note);\n"
msgstr ""
"/* если имя определено, то после него идёт заметка */\n"
"name = note-E<gt>n_namesz == 0 ? NULL : memory + sizeof(*note);\n"

#. type: Plain text
#: man-pages/man5/elf.5:1879
#, no-wrap
msgid ""
"/* If the descriptor is defined, it follows the name\n"
"   (with alignment) */\n"
msgstr ""
"/* если дескриптор определён, то за ним идёт имя\n"
"   (выровненное) */\n"

#. type: Plain text
#: man-pages/man5/elf.5:1882
#, no-wrap
msgid ""
"desc = note-E<gt>n_descsz == 0 ? NULL :\n"
"       memory + sizeof(*note) + ALIGN_UP(note-E<gt>n_namesz, 4);\n"
msgstr ""
"desc = note-E<gt>n_descsz == 0 ? NULL :\n"
"       memory + sizeof(*note) + ALIGN_UP(note-E<gt>n_namesz, 4);\n"

#. type: Plain text
#: man-pages/man5/elf.5:1887
#, no-wrap
msgid ""
"/* The next note follows both (with alignment) */\n"
"next_note = memory + sizeof(*note) +\n"
"                     ALIGN_UP(note-E<gt>n_namesz, 4) +\n"
"                     ALIGN_UP(note-E<gt>n_descsz, 4);\n"
msgstr ""
"/* следующая заметка с обоими полями (с выравниванием) */\n"
"next_note = memory + sizeof(*note) +\n"
"                     ALIGN_UP(note-E<gt>n_namesz, 4) +\n"
"                     ALIGN_UP(note-E<gt>n_descsz, 4);\n"

#. type: Plain text
#: man-pages/man5/elf.5:1901
msgid ""
"Keep in mind that the interpretation of I<n_type> depends on the namespace "
"defined by the I<n_namesz> field.  If the I<n_namesz> field is not set (e."
"g., is 0), then there are two sets of notes: one for core files and one for "
"all other ELF types.  If the namespace is unknown, then tools will usually "
"fallback to these sets of notes as well."
msgstr ""
"Следует иметь в виду, что интерпретация I<n_type> зависит от пространства "
"имён, определённого в поле I<n_namesz> field. Если поле I<n_namesz> не "
"задано (например, равно 0), то есть два набора заметок: один для файлов core "
"files и другой для всех остальных типов ELF. Если пространство имён "
"неизвестно, то инструменты, обычно, по умолчанию также используют эти наборы "
"заметок."

#. type: Plain text
#: man-pages/man5/elf.5:1909
#, no-wrap
msgid ""
"typedef struct {\n"
"    Elf32_Word n_namesz;\n"
"    Elf32_Word n_descsz;\n"
"    Elf32_Word n_type;\n"
"} Elf32_Nhdr;\n"
msgstr ""
"typedef struct {\n"
"    Elf32_Word n_namesz;\n"
"    Elf32_Word n_descsz;\n"
"    Elf32_Word n_type;\n"
"} Elf32_Nhdr;\n"

#. type: Plain text
#: man-pages/man5/elf.5:1919
#, no-wrap
msgid ""
"typedef struct {\n"
"    Elf64_Word n_namesz;\n"
"    Elf64_Word n_descsz;\n"
"    Elf64_Word n_type;\n"
"} Elf64_Nhdr;\n"
msgstr ""
"typedef struct {\n"
"    Elf64_Word n_namesz;\n"
"    Elf64_Word n_descsz;\n"
"    Elf64_Word n_type;\n"
"} Elf64_Nhdr;\n"

#. type: TP
#: man-pages/man5/elf.5:1921
#, no-wrap
msgid "I<n_namesz>"
msgstr "I<n_namesz>"

#. type: Plain text
#: man-pages/man5/elf.5:1929
msgid ""
"The length of the name field in bytes.  The contents will immediately follow "
"this note in memory.  The name is null terminated.  For example, if the name "
"is \"GNU\", then I<n_namesz> will be set to 4."
msgstr ""
"Длина имени поля в байтах. Содержимое идёт в памяти сразу за заметкой. Имя "
"заканчивается null. Например, если имя «GNU», то I<n_namesz> будет равно 4."

#. type: TP
#: man-pages/man5/elf.5:1929
#, no-wrap
msgid "I<n_descsz>"
msgstr "I<n_descsz>"

#. type: Plain text
#: man-pages/man5/elf.5:1933
msgid ""
"The length of the descriptor field in bytes.  The contents will immediately "
"follow the name field in memory."
msgstr ""
"Длина дескриптора поля в байтах. Содержимое идёт в памяти сразу за именем "
"поля."

#. type: TP
#: man-pages/man5/elf.5:1933
#, no-wrap
msgid "I<n_type>"
msgstr "I<n_type>"

#. type: Plain text
#: man-pages/man5/elf.5:1937
msgid ""
"Depending on the value of the name field, this member may have any of the "
"following values:"
msgstr ""
"В зависимости от значения имени поля, этот член может содержать следующие "
"значения:"

#. type: TP
#: man-pages/man5/elf.5:1938
#, no-wrap
msgid "B<Core files (e_type = ET_CORE)>"
msgstr "B<Файлы core (e_type = ET_CORE)>"

#. type: Plain text
#: man-pages/man5/elf.5:1946
msgid ""
"Notes used by all core files.  These are highly operating system or "
"architecture specific and often require close coordination with kernels, C "
"libraries, and debuggers.  These are used when the namespace is the default "
"(i.e., I<n_namesz> will be set to 0), or a fallback when the namespace is "
"unknown."
msgstr ""
"Заметки используются всеми файлами core. Их формат определяется ОС или "
"архитектурой и часто требует плотного взаимодействия ядра, библиотек C и "
"отладчиков. Они используются при умолчательном пространстве имён (т. е., "
"I<n_namesz> равно 0) или когда пространство имён неизвестно."

#. type: TP
#: man-pages/man5/elf.5:1947
#, no-wrap
msgid "B<NT_PRSTATUS>"
msgstr "B<NT_PRSTATUS>"

#. type: Plain text
#: man-pages/man5/elf.5:1951
msgid "prstatus struct"
msgstr "структура prstatus"

#. type: TP
#: man-pages/man5/elf.5:1951
#, no-wrap
msgid "B<NT_FPREGSET>"
msgstr "B<NT_FPREGSET>"

#. type: Plain text
#: man-pages/man5/elf.5:1954
msgid "fpregset struct"
msgstr "структура fpregset"

#. type: TP
#: man-pages/man5/elf.5:1954
#, no-wrap
msgid "B<NT_PRPSINFO>"
msgstr "B<NT_PRPSINFO>"

#. type: Plain text
#: man-pages/man5/elf.5:1957
msgid "prpsinfo struct"
msgstr "структура prpsinfo"

#. type: TP
#: man-pages/man5/elf.5:1957
#, no-wrap
msgid "B<NT_PRXREG>"
msgstr "B<NT_PRXREG>"

#. type: Plain text
#: man-pages/man5/elf.5:1960
msgid "prxregset struct"
msgstr "структура prxregset"

#. type: TP
#: man-pages/man5/elf.5:1960
#, no-wrap
msgid "B<NT_TASKSTRUCT>"
msgstr "B<NT_TASKSTRUCT>"

#. type: Plain text
#: man-pages/man5/elf.5:1963
msgid "task structure"
msgstr "структура задачи"

#. type: TP
#: man-pages/man5/elf.5:1963
#, no-wrap
msgid "B<NT_PLATFORM>"
msgstr "B<NT_PLATFORM>"

#. type: Plain text
#: man-pages/man5/elf.5:1966
msgid "String from sysinfo(SI_PLATFORM)"
msgstr "Строка из sysinfo(SI_PLATFORM)"

#. type: TP
#: man-pages/man5/elf.5:1966
#, no-wrap
msgid "B<NT_AUXV>"
msgstr "B<NT_AUXV>"

#. type: Plain text
#: man-pages/man5/elf.5:1969
msgid "auxv array"
msgstr "массив auxv"

#. type: TP
#: man-pages/man5/elf.5:1969
#, no-wrap
msgid "B<NT_GWINDOWS>"
msgstr "B<NT_GWINDOWS>"

#. type: Plain text
#: man-pages/man5/elf.5:1972
msgid "gwindows struct"
msgstr "структура gwindows"

#. type: TP
#: man-pages/man5/elf.5:1972
#, no-wrap
msgid "B<NT_ASRS>"
msgstr "B<NT_ASRS>"

#. type: Plain text
#: man-pages/man5/elf.5:1975
msgid "asrset struct"
msgstr "структура asrset"

#. type: TP
#: man-pages/man5/elf.5:1975
#, no-wrap
msgid "B<NT_PSTATUS>"
msgstr "B<NT_PSTATUS>"

#. type: Plain text
#: man-pages/man5/elf.5:1978
msgid "pstatus struct"
msgstr "структура pstatus"

#. type: TP
#: man-pages/man5/elf.5:1978
#, no-wrap
msgid "B<NT_PSINFO>"
msgstr "B<NT_PSINFO>"

#. type: Plain text
#: man-pages/man5/elf.5:1981
msgid "psinfo struct"
msgstr "структура psinfo"

#. type: TP
#: man-pages/man5/elf.5:1981
#, no-wrap
msgid "B<NT_PRCRED>"
msgstr "B<NT_PRCRED>"

#. type: Plain text
#: man-pages/man5/elf.5:1984
msgid "prcred struct"
msgstr "структура prcred"

#. type: TP
#: man-pages/man5/elf.5:1984
#, no-wrap
msgid "B<NT_UTSNAME>"
msgstr "B<NT_UTSNAME>"

#. type: Plain text
#: man-pages/man5/elf.5:1987
msgid "utsname struct"
msgstr "структура utsname"

#. type: TP
#: man-pages/man5/elf.5:1987
#, no-wrap
msgid "B<NT_LWPSTATUS>"
msgstr "B<NT_LWPSTATUS>"

#. type: Plain text
#: man-pages/man5/elf.5:1990
msgid "lwpstatus struct"
msgstr "структура lwpstatus"

#. type: TP
#: man-pages/man5/elf.5:1990
#, no-wrap
msgid "B<NT_LWPSINFO>"
msgstr "B<NT_LWPSINFO>"

#. type: Plain text
#: man-pages/man5/elf.5:1993
msgid "lwpinfo struct"
msgstr "структура lwpinfo"

#. type: TP
#: man-pages/man5/elf.5:1993
#, no-wrap
msgid "B<NT_PRFPXREG>"
msgstr "B<NT_PRFPXREG>"

#. type: Plain text
#: man-pages/man5/elf.5:1996
msgid "fprxregset struct"
msgstr "структура fprxregset"

#. type: TP
#: man-pages/man5/elf.5:1996
#, no-wrap
msgid "B<NT_SIGINFO>"
msgstr "B<NT_SIGINFO>"

#. type: Plain text
#: man-pages/man5/elf.5:1999
msgid "siginfo_t (size might increase over time)"
msgstr "siginfo_t (в дальнейшем, размер может увеличиться)"

#. type: TP
#: man-pages/man5/elf.5:1999
#, no-wrap
msgid "B<NT_FILE>"
msgstr "B<NT_FILE>"

#. type: Plain text
#: man-pages/man5/elf.5:2002
msgid "Contains information about mapped files"
msgstr "Содержит информацию об отображённых файлах"

#. type: TP
#: man-pages/man5/elf.5:2002
#, no-wrap
msgid "B<NT_PRXFPREG>"
msgstr "B<NT_PRXFPREG>"

#. type: Plain text
#: man-pages/man5/elf.5:2005
msgid "user_fxsr_struct"
msgstr "user_fxsr_struct"

#. type: TP
#: man-pages/man5/elf.5:2005
#, no-wrap
msgid "B<NT_PPC_VMX>"
msgstr "B<NT_PPC_VMX>"

#. type: Plain text
#: man-pages/man5/elf.5:2008
msgid "PowerPC Altivec/VMX registers"
msgstr "Регистры PowerPC Altivec/VMX"

#. type: TP
#: man-pages/man5/elf.5:2008
#, no-wrap
msgid "B<NT_PPC_SPE>"
msgstr "B<NT_PPC_SPE>"

#. type: Plain text
#: man-pages/man5/elf.5:2011
msgid "PowerPC SPE/EVR registers"
msgstr "Регистры PowerPC SPE/EVR"

#. type: TP
#: man-pages/man5/elf.5:2011
#, no-wrap
msgid "B<NT_PPC_VSX>"
msgstr "B<NT_PPC_VSX>"

#. type: Plain text
#: man-pages/man5/elf.5:2014
msgid "PowerPC VSX registers"
msgstr "Регистры PowerPC VSX"

#. type: TP
#: man-pages/man5/elf.5:2014
#, no-wrap
msgid "B<NT_386_TLS>"
msgstr "B<NT_386_TLS>"

#. type: Plain text
#: man-pages/man5/elf.5:2017
msgid "i386 TLS slots (struct user_desc)"
msgstr "слоты TLS в i386  (struct user_desc)"

#. type: TP
#: man-pages/man5/elf.5:2017
#, no-wrap
msgid "B<NT_386_IOPERM>"
msgstr "B<NT_386_IOPERM>"

#. type: Plain text
#: man-pages/man5/elf.5:2020
msgid "x86 io permission bitmap (1=deny)"
msgstr "битовая карта ввода-вывода в x86 (1=запрещено)"

#. type: TP
#: man-pages/man5/elf.5:2020
#, no-wrap
msgid "B<NT_X86_XSTATE>"
msgstr "B<NT_X86_XSTATE>"

#. type: Plain text
#: man-pages/man5/elf.5:2023
msgid "x86 extended state using xsave"
msgstr "расширенное состояние x86, использующее xsave"

#. type: TP
#: man-pages/man5/elf.5:2023
#, no-wrap
msgid "B<NT_S390_HIGH_GPRS>"
msgstr "B<NT_S390_HIGH_GPRS>"

#. type: Plain text
#: man-pages/man5/elf.5:2026
msgid "s390 upper register halves"
msgstr "верхние половинки регистров s390"

#. type: TP
#: man-pages/man5/elf.5:2026
#, no-wrap
msgid "B<NT_S390_TIMER>"
msgstr "B<NT_S390_TIMER>"

#. type: Plain text
#: man-pages/man5/elf.5:2029
msgid "s390 timer register"
msgstr "регистр таймера s390"

#. type: TP
#: man-pages/man5/elf.5:2029
#, no-wrap
msgid "B<NT_S390_TODCMP>"
msgstr "B<NT_S390_TODCMP>"

#. type: Plain text
#: man-pages/man5/elf.5:2032
msgid "s390 time-of-day (TOD) clock comparator register"
msgstr "регистр сравнивателя часов time-of-day (TOD) s390"

#. type: TP
#: man-pages/man5/elf.5:2032
#, no-wrap
msgid "B<NT_S390_TODPREG>"
msgstr "B<NT_S390_TODPREG>"

#. type: Plain text
#: man-pages/man5/elf.5:2035
msgid "s390 time-of-day (TOD) programmable register"
msgstr "программируемый регистр time-of-day (TOD) s390"

#. type: TP
#: man-pages/man5/elf.5:2035
#, no-wrap
msgid "B<NT_S390_CTRS>"
msgstr "B<NT_S390_CTRS>"

#. type: Plain text
#: man-pages/man5/elf.5:2038
msgid "s390 control registers"
msgstr "управляющие регистры s390"

#. type: TP
#: man-pages/man5/elf.5:2038
#, no-wrap
msgid "B<NT_S390_PREFIX>"
msgstr "B<NT_S390_PREFIX>"

#. type: Plain text
#: man-pages/man5/elf.5:2041
msgid "s390 prefix register"
msgstr "регистр префикса s390"

#. type: TP
#: man-pages/man5/elf.5:2041
#, no-wrap
msgid "B<NT_S390_LAST_BREAK>"
msgstr "B<NT_S390_LAST_BREAK>"

#. type: Plain text
#: man-pages/man5/elf.5:2044
msgid "s390 breaking event address"
msgstr "адрес прерывающего события s390"

#. type: TP
#: man-pages/man5/elf.5:2044
#, no-wrap
msgid "B<NT_S390_SYSTEM_CALL>"
msgstr "B<NT_S390_SYSTEM_CALL>"

#. type: Plain text
#: man-pages/man5/elf.5:2047
msgid "s390 system call restart data"
msgstr "данные системного вызова перезапуска s390"

#. type: TP
#: man-pages/man5/elf.5:2047
#, no-wrap
msgid "B<NT_S390_TDB>"
msgstr "B<NT_S390_TDB>"

#. type: Plain text
#: man-pages/man5/elf.5:2050
msgid "s390 transaction diagnostic block"
msgstr "блок диагностики транзакции s390"

#. type: TP
#: man-pages/man5/elf.5:2050
#, no-wrap
msgid "B<NT_ARM_VFP>"
msgstr "B<NT_ARM_VFP>"

#. type: Plain text
#: man-pages/man5/elf.5:2053
msgid "ARM VFP/NEON registers"
msgstr "регистры VFP/NEON в ARM"

#. type: TP
#: man-pages/man5/elf.5:2053
#, no-wrap
msgid "B<NT_ARM_TLS>"
msgstr "B<NT_ARM_TLS>"

#. type: Plain text
#: man-pages/man5/elf.5:2056
msgid "ARM TLS register"
msgstr "регистр TLS в ARM"

#. type: TP
#: man-pages/man5/elf.5:2056
#, no-wrap
msgid "B<NT_ARM_HW_BREAK>"
msgstr "B<NT_ARM_HW_BREAK>"

#. type: Plain text
#: man-pages/man5/elf.5:2059
msgid "ARM hardware breakpoint registers"
msgstr "регистры аппаратного прерывания в ARM"

#. type: TP
#: man-pages/man5/elf.5:2059
#, no-wrap
msgid "B<NT_ARM_HW_WATCH>"
msgstr "B<NT_ARM_HW_WATCH>"

#. type: Plain text
#: man-pages/man5/elf.5:2062
msgid "ARM hardware watchpoint registers"
msgstr "регистры аппаратного слежения в ARM"

#. type: TP
#: man-pages/man5/elf.5:2062
#, no-wrap
msgid "B<NT_ARM_SYSTEM_CALL>"
msgstr "B<NT_ARM_SYSTEM_CALL>"

#. type: Plain text
#: man-pages/man5/elf.5:2065
msgid "ARM system call number"
msgstr "Номер системного вызова ARM"

#. type: TP
#: man-pages/man5/elf.5:2067
#, no-wrap
msgid "B<n_name = GNU>"
msgstr "B<n_name = GNU>"

#. type: Plain text
#: man-pages/man5/elf.5:2070
msgid "Extensions used by the GNU tool chain."
msgstr "Расширения, используемый инструментами GNU."

#. type: TP
#: man-pages/man5/elf.5:2071
#, no-wrap
msgid "B<NT_GNU_ABI_TAG>"
msgstr "B<NT_GNU_ABI_TAG>"

#. type: Plain text
#: man-pages/man5/elf.5:2075
msgid "Operating system (OS) ABI information.  The desc field will be 4 words:"
msgstr ""
"Информация ABI операционной системы (OS). Поле дескриптора содержит 4 слова:"

#. type: IP
#: man-pages/man5/elf.5:2078 man-pages/man5/elf.5:2081
#: man-pages/man5/elf.5:2083 man-pages/man5/elf.5:2085
#: man-pages/man5/elf.5:2096 man-pages/man5/elf.5:2098
#, no-wrap
msgid "\\(bu"
msgstr "\\(bu"

#. type: Plain text
#: man-pages/man5/elf.5:2081
msgid ""
"word 0: OS descriptor (B<ELF_NOTE_OS_LINUX>, B<ELF_NOTE_OS_GNU>, and so on)`"
msgstr ""
"слово 0: дескриптор ОС (B<ELF_NOTE_OS_LINUX>, B<ELF_NOTE_OS_GNU> и так "
"далее)`"

#. type: Plain text
#: man-pages/man5/elf.5:2083
msgid "word 1: major version of the ABI"
msgstr "слово 1: основной номер версии ABI"

#. type: Plain text
#: man-pages/man5/elf.5:2085
msgid "word 2: minor version of the ABI"
msgstr "слово 2: вспомогательный номер версии ABI"

#. type: Plain text
#: man-pages/man5/elf.5:2087
msgid "word 3: subminor version of the ABI"
msgstr "слово 3: дополнение к вспомогательному номеру версии ABI"

#. type: TP
#: man-pages/man5/elf.5:2089
#, no-wrap
msgid "B<NT_GNU_HWCAP>"
msgstr "B<NT_GNU_HWCAP>"

#. type: Plain text
#: man-pages/man5/elf.5:2093
msgid "Synthetic hwcap information.  The desc field begins with two words:"
msgstr "Синтетическая информация hwcap. Поле дескриптора начинается 2 словами:"

#. type: Plain text
#: man-pages/man5/elf.5:2098
msgid "word 0: number of entries"
msgstr "слово 0: количество элементов"

#. type: Plain text
#: man-pages/man5/elf.5:2100
msgid "word 1: bit mask of enabled entries"
msgstr "слово 1: битовая маска включённых элементов"

#. type: Plain text
#: man-pages/man5/elf.5:2106
msgid ""
"Then follow variable-length entries, one byte followed by a null-terminated "
"hwcap name string.  The byte gives the bit number to test if enabled, (1U "
"E<lt>E<lt> bit) & bit mask."
msgstr ""
"Далее следуют элементы произвольной длины и один байт после строки имени "
"hwcap, заканчивающейся null. В байте определён номер бита, который нужно "
"тестировать для проверки включённости, (1U E<lt>E<lt> бит) & битовая маска."

#. type: TP
#: man-pages/man5/elf.5:2106
#, no-wrap
msgid "B<NT_GNU_BUILD_ID>"
msgstr "B<NT_GNU_BUILD_ID>"

#. type: Plain text
#: man-pages/man5/elf.5:2113
msgid ""
"Unique build ID as generated by the GNU B<ld>(1)  B<--build-id> option.  The "
"desc consists of any nonzero number of bytes."
msgstr ""
"Уникальный идентификатор сборки, генерируемый GNU B<ld>(1), запущенной с "
"параметром B<--build-id>. Дескриптор содержит произвольное ненулевое "
"количество байт."

#. type: TP
#: man-pages/man5/elf.5:2113
#, no-wrap
msgid "B<NT_GNU_GOLD_VERSION>"
msgstr "B<NT_GNU_GOLD_VERSION>"

#. type: Plain text
#: man-pages/man5/elf.5:2116
msgid "The desc contains the GNU Gold linker version used."
msgstr ""
"В поле дескриптора записывается использованная версия компоновщика GNU Gold."

#. type: TP
#: man-pages/man5/elf.5:2117
#, no-wrap
msgid "B<Default/unknown namespace (e_type != ET_CORE)>"
msgstr "B<Умолчательное/неизвестное пространство имён (e_type != ET_CORE)>"

#. type: Plain text
#: man-pages/man5/elf.5:2122
msgid ""
"These are used when the namespace is the default (i.e., I<n_namesz> will be "
"set to 0), or a fallback when the namespace is unknown."
msgstr ""
"Они используются при умолчательном пространстве имён (т. е., I<n_namesz> "
"равно 0) или когда пространство имён неизвестно."

#. type: TP
#: man-pages/man5/elf.5:2123
#, no-wrap
msgid "B<NT_VERSION>"
msgstr "B<NT_VERSION>"

#. type: Plain text
#: man-pages/man5/elf.5:2127
msgid "A version string of some sort."
msgstr "Строка версии неопределённого вида"

#. type: TP
#: man-pages/man5/elf.5:2127
#, no-wrap
msgid "B<NT_ARCH>"
msgstr "B<NT_ARCH>"

#. type: Plain text
#: man-pages/man5/elf.5:2130
msgid "Architecture information."
msgstr "Информация об архитектуре"

#.  OpenBSD
#.  ELF support first appeared in
#.  OpenBSD 1.2,
#.  although not all supported platforms use it as the native
#.  binary file format.
#. type: Plain text
#: man-pages/man5/elf.5:2143
msgid "ELF first appeared in System V.  The ELF format is an adopted standard."
msgstr ""
"Впервые ELF появился в System V. Формат ELF является утверждённым стандартом."

#.  .SH AUTHORS
#.  The original version of this manual page was written by
#.  .An Jeroen Ruigrok van der Werven
#.  .Aq asmodai@FreeBSD.org
#.  with inspiration from BSDi's
#.  .Bsx
#.  .Nm elf
#.  man page.
#. type: Plain text
#: man-pages/man5/elf.5:2161
msgid ""
"The extensions for I<e_phnum>, I<e_shnum> and I<e_strndx> respectively are "
"Linux extensions.  Sun, BSD and AMD64 also support them; for further "
"information, look under SEE ALSO."
msgstr ""
"Расширения для I<e_phnum>, I<e_shnum> и I<e_strndx> соответствующих "
"расширений Linux. Также они поддерживаются в Sun, BSD и AMD64; "
"дополнительную информацию смотрите в разделе \"СМОТРИТЕ ТАКЖЕ\"."

#. type: Plain text
#: man-pages/man5/elf.5:2177
msgid ""
"B<as>(1), B<elfedit>(1), B<gdb>(1), B<ld>(1), B<nm>(1), B<objdump>(1), "
"B<patchelf>(1), B<readelf>(1), B<size>(1), B<strings>(1), B<strip>(1), "
"B<execve>(2), B<dl_iterate_phdr>(3), B<core>(5), B<ld.so>(8)"
msgstr ""
"B<as>(1), B<elfedit>(1), B<gdb>(1), B<ld>(1), B<nm>(1), B<objdump>(1), "
"B<patchelf>(1), B<readelf>(1), B<size>(1), B<strings>(1), B<strip>(1), "
"B<execve>(2), B<dl_iterate_phdr>(3), B<core>(5), B<ld.so>(8)"

#. type: Plain text
#: man-pages/man5/elf.5:2180
msgid "Hewlett-Packard, I<Elf-64 Object File Format>."
msgstr "Hewlett-Packard, I<Формат объектных файлов Elf-64>."

#. type: Plain text
#: man-pages/man5/elf.5:2183
msgid "Santa Cruz Operation, I<System V Application Binary Interface>."
msgstr "Santa Cruz Operation, I<Двоичный интерфейс приложений System V>."

#. type: Plain text
#: man-pages/man5/elf.5:2187
msgid ""
"UNIX System Laboratories, \"Object Files\", I<Executable and Linking Format "
"(ELF)>."
msgstr ""
"UNIX System Laboratories, «Объектные файлы», I<Формат исполняемых и "
"компонуемых файлов (ELF)>."

#. type: Plain text
#: man-pages/man5/elf.5:2190
msgid "Sun Microsystems, I<Linker and Libraries Guide>."
msgstr ""
"Sun Microsystems, I<Руководстве по компоновщику и библиотекам> (I<Linker and "
"Libraries Guide>)."

#. type: Plain text
#: man-pages/man5/elf.5:2193
msgid ""
"AMD64 ABI Draft, I<System V Application Binary Interface AMD64 Architecture "
"Processor Supplement>."
msgstr ""
"черновик ABI AMD64, I<Дополнение к двоичному интерфейсу приложений System V "
"процессорной архитектуры AMD64> (I<System V Application Binary Interface "
"AMD64 Architecture Processor Supplement>)."

#. type: TH
#: man-pages/man3/err.3:39
#, no-wrap
msgid "ERR"
msgstr "ERR"

#. type: Plain text
#: man-pages/man3/err.3:42
msgid ""
"err, verr, errx, verrx, warn, vwarn, warnx, vwarnx - formatted error messages"
msgstr ""
"err, verr, errx, verrx, warn, vwarn, warnx, vwarnx - форматирует сообщения "
"об ошибках"

#. type: Plain text
#: man-pages/man3/err.3:45
#, no-wrap
msgid "B<#include E<lt>err.hE<gt>>\n"
msgstr "B<#include E<lt>err.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/err.3:47
#, no-wrap
msgid "B<void err(int >I<eval>B<, const char *>I<fmt>B<, ...);>\n"
msgstr "B<void err(int >I<eval>B<, const char *>I<fmt>B<, ...);>\n"

#. type: Plain text
#: man-pages/man3/err.3:49
#, no-wrap
msgid "B<void errx(int >I<eval>B<, const char *>I<fmt>B<, ...);>\n"
msgstr "B<void errx(int >I<eval>B<, const char *>I<fmt>B<, ...);>\n"

#. type: Plain text
#: man-pages/man3/err.3:51
#, no-wrap
msgid "B<void warn(const char *>I<fmt>B<, ...);>\n"
msgstr "B<void warn(const char *>I<fmt>B<, ...);>\n"

#. type: Plain text
#: man-pages/man3/err.3:53
#, no-wrap
msgid "B<void warnx(const char *>I<fmt>B<, ...);>\n"
msgstr "B<void warnx(const char *>I<fmt>B<, ...);>\n"

#. type: Plain text
#: man-pages/man3/err.3:55
#, no-wrap
msgid "B<#include E<lt>stdarg.hE<gt>>\n"
msgstr "B<#include E<lt>stdarg.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/err.3:57
#, no-wrap
msgid "B<void verr(int >I<eval>B<, const char *>I<fmt>B<, va_list >I<args>B<);>\n"
msgstr "B<void verr(int >I<eval>B<, const char *>I<fmt>B<, va_list >I<args>B<);>\n"

#. type: Plain text
#: man-pages/man3/err.3:59
#, no-wrap
msgid "B<void verrx(int >I<eval>B<, const char *>I<fmt>B<, va_list >I<args>B<);>\n"
msgstr "B<void verrx(int >I<eval>B<, const char *>I<fmt>B<, va_list >I<args>B<);>\n"

#. type: Plain text
#: man-pages/man3/err.3:61
#, no-wrap
msgid "B<void vwarn(const char *>I<fmt>B<, va_list >I<args>B<);>\n"
msgstr "B<void vwarn(const char *>I<fmt>B<, va_list >I<args>B<);>\n"

#. type: Plain text
#: man-pages/man3/err.3:63
#, no-wrap
msgid "B<void vwarnx(const char *>I<fmt>B<, va_list >I<args>B<);>\n"
msgstr "B<void vwarnx(const char *>I<fmt>B<, va_list >I<args>B<);>\n"

#. type: Plain text
#: man-pages/man3/err.3:79
msgid ""
"The B<err>()  and B<warn>()  family of functions display a formatted error "
"message on the standard error output.  In all cases, the last component of "
"the program name, a colon character, and a space are output.  If the I<fmt> "
"argument is not NULL, the B<printf>(3)-like formatted error message is "
"output.  The output is terminated by a newline character."
msgstr ""
"Семейства функций B<err>() и B<warn>() выводят форматированное сообщение об "
"ошибке в стандартный поток ошибок. При выводе всегда показывается последний "
"компонент имени программы, двоеточие и пробел. Если значение I<fmt> не равно "
"NULL, то выводится сообщение об ошибке, отформатированное согласно "
"B<printf>(3). Вывод завершается символом новой строки."

#. type: Plain text
#: man-pages/man3/err.3:94
msgid ""
"The B<err>(), B<verr>(), B<warn>(), and B<vwarn>()  functions append an "
"error message obtained from B<strerror>(3)  based on the global variable "
"I<errno>, preceded by another colon and space unless the I<fmt> argument is "
"NULL."
msgstr ""
"Функции B<err>(), B<verr>(), B<warn>() и B<vwarn>() добавляют сообщение об "
"ошибке, полученное от B<strerror>(3) для значения глобальной переменной "
"I<errno>, начиная его с двоеточия и пробела, если значение I<fmt> равно NULL."

#. type: Plain text
#: man-pages/man3/err.3:100
msgid ""
"The B<errx>()  and B<warnx>()  functions do not append an error message."
msgstr "Функции B<errx>() и B<warnx>() не добавляют сообщение об ошибке."

#. type: Plain text
#: man-pages/man3/err.3:109
msgid ""
"The B<err>(), B<verr>(), B<errx>(), and B<verrx>()  functions do not return, "
"but exit with the value of the argument I<eval>."
msgstr ""
"Функции B<err>(), B<verr>(), B<errx>() и B<verrx>() не возвращают управление "
"в программу, а завершают её с кодом выхода, равным значению I<eval>."

#. type: tbl table
#: man-pages/man3/err.3:120
#, no-wrap
msgid ""
"B<err>(),\n"
"B<errx>(),\n"
msgstr ""
"B<err>(),\n"
"B<errx>(),\n"

#. type: tbl table
#: man-pages/man3/err.3:120 man-pages/man3/err.3:123 man-pages/man3/err.3:126
#, no-wrap
msgid ".br\n"
msgstr ".br\n"

#. type: tbl table
#: man-pages/man3/err.3:123
#, no-wrap
msgid ""
"B<warn>(),\n"
"B<warnx>(),\n"
msgstr ""
"B<warn>(),\n"
"B<warnx>(),\n"

#. type: tbl table
#: man-pages/man3/err.3:126
#, no-wrap
msgid ""
"B<verr>(),\n"
"B<verrx>(),\n"
msgstr ""
"B<verr>(),\n"
"B<verrx>(),\n"

#. type: tbl table
#: man-pages/man3/err.3:129
#, no-wrap
msgid ""
"B<vwarn>(),\n"
"B<vwarnx>()"
msgstr ""
"B<vwarn>(),\n"
"B<vwarnx>()"

#. type: tbl table
#: man-pages/man3/err.3:129
#, no-wrap
msgid "MT-Safe locale"
msgstr "MT-Safe locale"

#.  .SH HISTORY
#.  The
#.  .BR err ()
#.  and
#.  .BR warn ()
#.  functions first appeared in
#.  4.4BSD.
#. type: Plain text
#: man-pages/man3/err.3:141
msgid "These functions are nonstandard BSD extensions."
msgstr "Эти функции являются расширениями BSD."

#. type: Plain text
#: man-pages/man3/err.3:145
msgid "Display the current I<errno> information string and exit:"
msgstr "Показать строку с информацией о текущем I<errno> и закончить работу:"

#. type: Plain text
#: man-pages/man3/err.3:154
#, no-wrap
msgid ""
"p = malloc(size);\n"
"if (p == NULL)\n"
"    err(1, NULL);\n"
"fd = open(file_name, O_RDONLY, 0);\n"
"if (fd == -1)\n"
"    err(1, \"%s\", file_name);\n"
msgstr ""
"p = malloc(size);\n"
"if (p == NULL)\n"
"    err(1, NULL);\n"
"fd = open(file_name, O_RDONLY, 0);\n"
"if (fd == -1)\n"
"    err(1, \"%s\", file_name);\n"

#. type: Plain text
#: man-pages/man3/err.3:158
msgid "Display an error message and exit:"
msgstr "Показать сообщение об ошибке и закончить работу:"

#. type: Plain text
#: man-pages/man3/err.3:163
#, no-wrap
msgid ""
"if (tm.tm_hour E<lt> START_TIME)\n"
"    errx(1, \"too early, wait until %s\", start_time_string);\n"
msgstr ""
"if (tm.tm_hour E<lt> START_TIME)\n"
"    errx(1, \"слишком рано, ждём до %s\", start_time_string);\n"

#. type: Plain text
#: man-pages/man3/err.3:167
msgid "Warn of an error:"
msgstr "Предупреждение об ошибке:"

#. type: Plain text
#: man-pages/man3/err.3:177
#, no-wrap
msgid ""
"fd = open(raw_device, O_RDONLY, 0);\n"
"if (fd == -1)\n"
"    warnx(\"%s: %s: trying the block device\",\n"
"            raw_device, strerror(errno));\n"
"fd = open(block_device, O_RDONLY, 0);\n"
"if (fd == -1)\n"
"    err(1, \"%s\", block_device);\n"
msgstr ""
"fd = open(raw_device, O_RDONLY, 0);\n"
"if (fd == -1)\n"
"    warnx(\"%s: %s: пробуем блочное устройство\",\n"
"            raw_device, strerror(errno));\n"
"fd = open(block_device, O_RDONLY, 0);\n"
"if (fd == -1)\n"
"    err(1, \"%s\", block_device);\n"

#. type: Plain text
#: man-pages/man3/err.3:184
msgid "B<error>(3), B<exit>(3), B<perror>(3), B<printf>(3), B<strerror>(3)"
msgstr "B<error>(3), B<exit>(3), B<perror>(3), B<printf>(3), B<strerror>(3)"

#. type: TH
#: man-pages/man3/exp2.3:36
#, no-wrap
msgid "EXP2"
msgstr "EXP2"

#. type: Plain text
#: man-pages/man3/exp2.3:39
msgid "exp2, exp2f, exp2l - base-2 exponential function"
msgstr "exp2, exp2f, exp2l - функция степени по основанию 2"

#. type: Plain text
#: man-pages/man3/exp2.3:42
#, no-wrap
msgid "B<#include E<lt>math.hE<gt>>\n"
msgstr "B<#include E<lt>math.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/exp2.3:46
#, no-wrap
msgid ""
"B<double exp2(double >I<x>B<);>\n"
"B<float exp2f(float >I<x>B<);>\n"
"B<long double exp2l(long double >I<x>B<);>\n"
msgstr ""
"B<double exp2(double >I<x>B<);>\n"
"B<float exp2f(float >I<x>B<);>\n"
"B<long double exp2l(long double >I<x>B<);>\n"

#. type: Plain text
#: man-pages/man3/exp2.3:49
msgid "Link with I<-lm>."
msgstr "Компонуется при указании параметра I<-lm>."

#. type: Plain text
#: man-pages/man3/exp2.3:53
msgid ""
"Feature Test Macro Requirements for glibc (see B<feature_test_macros>(7)):"
msgstr ""
"Требования макроса тестирования свойств для glibc (см. "
"B<feature_test_macros>(7)):"

#. type: Plain text
#: man-pages/man3/exp2.3:59
msgid "B<exp2>(), B<exp2f>(), B<exp2l>():"
msgstr "B<exp2>(), B<exp2f>(), B<exp2l>():"

#. type: Plain text
#: man-pages/man3/exp2.3:61
msgid "_ISOC99_SOURCE || _POSIX_C_SOURCE\\ E<gt>=\\ 200112L"
msgstr "_ISOC99_SOURCE || _POSIX_C_SOURCE\\ E<gt>=\\ 200112L"

#. type: Plain text
#: man-pages/man3/exp2.3:66
msgid "These functions return the value of 2 raised to the power of I<x>."
msgstr "Данные функции возвращают значение 2, возведённое в степень I<x>."

#. type: Plain text
#: man-pages/man3/exp2.3:69
msgid ""
"On success, these functions return the base-2 exponential value of I<x>."
msgstr "При успешном выполнении данные функции возвращают 2 в степени I<x>."

#. type: Plain text
#: man-pages/man3/exp2.3:73
msgid ""
"For various special cases, including the handling of infinity and NaN, as "
"well as overflows and underflows, see B<exp>(3)."
msgstr ""
"Описание работы со специальными значениями, такими как бесконечность и NaN, "
"а также при превышении и исчерпании степени смотрите в B<exp>(3)."

#. type: Plain text
#: man-pages/man3/exp2.3:78
msgid ""
"See B<math_error>(7)  for information on how to determine whether an error "
"has occurred when calling these functions."
msgstr ""
"Смотрите B<math_error>(7), чтобы определить, какие ошибки могут возникать "
"при вызове этих функций."

#. type: Plain text
#: man-pages/man3/exp2.3:81
msgid ""
"For a discussion of the errors that can occur for these functions, see "
"B<exp>(3)."
msgstr "Обсуждение возникающих ошибок этих функций смотрите в B<exp>(3)."

#. type: Plain text
#: man-pages/man3/exp2.3:83
msgid "These functions first appeared in glibc in version 2.1."
msgstr "Эти функции впервые появились в glibc 2.1."

#. type: tbl table
#: man-pages/man3/exp2.3:95
#, no-wrap
msgid ""
"B<exp2>(),\n"
"B<exp2f>(),\n"
"B<exp2l>()"
msgstr ""
"B<exp2>(),\n"
"B<exp2f>(),\n"
"B<exp2l>()"

#. type: Plain text
#: man-pages/man3/exp2.3:99
msgid "C99, POSIX.1-2001, POSIX.1-2008."
msgstr "C99, POSIX.1-2001, POSIX.1-2008."

#. type: Plain text
#: man-pages/man3/exp2.3:104
msgid "The variant returning I<double> also conforms to SVr4, 4.3BSD."
msgstr ""
"Вариант, возвращающий значение типа I<double>, также соответствует SVr4, "
"4.3BSD."

#. type: Plain text
#: man-pages/man3/exp2.3:109
msgid "B<cbrt>(3), B<cexp2>(3), B<exp>(3), B<exp10>(3), B<sqrt>(3)"
msgstr "B<cbrt>(3), B<cexp2>(3), B<exp>(3), B<exp10>(3), B<sqrt>(3)"

#. type: TH
#: man-pages/man3/ecvt.3:32
#, no-wrap
msgid "ECVT"
msgstr "ECVT"

#. type: TH
#: man-pages/man3/ecvt.3:32
#, no-wrap
msgid "2016-03-15"
msgstr "2016-03-15"

#. type: Plain text
#: man-pages/man3/ecvt.3:35
msgid "ecvt, fcvt - convert a floating-point number to a string"
msgstr "ecvt, fcvt - преобразование числа с плавающей точкой в строку"

#. type: Plain text
#: man-pages/man3/ecvt.3:37
msgid "B<#include E<lt>stdlib.hE<gt>>"
msgstr "B<#include E<lt>stdlib.hE<gt>>"

#. type: Plain text
#: man-pages/man3/ecvt.3:40
msgid ""
"B<char *ecvt(double >I<number>B<, int >I<ndigits>B<, int *>I<decpt>B<,> "
"B<int *>I<sign>B<);>"
msgstr ""
"B<char *ecvt(double >I<number>B<, int >I<ndigits>B<, int *>I<decpt>B<,> "
"B<int *>I<sign>B<);>"

#. type: Plain text
#: man-pages/man3/ecvt.3:43
msgid ""
"B<char *fcvt(double >I<number>B<, int >I<ndigits>B<, int *>I<decpt>B<,> "
"B<int *>I<sign>B<);>"
msgstr ""
"B<char *fcvt(double >I<number>B<, int >I<ndigits>B<, int *>I<decpt>B<,> "
"B<int *>I<sign>B<);>"

#. type: Plain text
#: man-pages/man3/ecvt.3:51
msgid "B<ecvt>(), B<fcvt>():"
msgstr "B<ecvt>(), B<fcvt>():"

#. type: TP
#: man-pages/man3/ecvt.3:54
#, no-wrap
msgid "Since glibc 2.12:"
msgstr "Начиная с glibc 2.12:"

#. type: Plain text
#: man-pages/man3/ecvt.3:60
#, no-wrap
msgid ""
"(_XOPEN_SOURCE\\ E<gt>=\\ 500) ! (_POSIX_C_SOURCE\\ E<gt>=\\ 200112L)\n"
"    || /* Glibc since 2.19: */ _DEFAULT_SOURCE\n"
"    || /* Glibc versions E<lt>= 2.19: */ _SVID_SOURCE\n"
msgstr ""
"(_XOPEN_SOURCE\\ E<gt>=\\ 500) ! (_POSIX_C_SOURCE\\ E<gt>=\\ 200112L)\n"
"    || /* начиная с glibc 2.19: */ _DEFAULT_SOURCE\n"
"    || /* в версии glibc E<lt>= 2.19: */ _SVID_SOURCE\n"

#. type: TP
#: man-pages/man3/ecvt.3:61
#, no-wrap
msgid "Before glibc 2.12:"
msgstr "До glibc 2.12:"

#.     || _XOPEN_SOURCE\ &&\ _XOPEN_SOURCE_EXTENDED
#. type: Plain text
#: man-pages/man3/ecvt.3:65
msgid "_SVID_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 500"
msgstr "_SVID_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 500"

#. type: Plain text
#: man-pages/man3/ecvt.3:91
msgid ""
"The B<ecvt>()  function converts I<number> to a null-terminated string of "
"I<ndigits> digits (where I<ndigits> is reduced to a system-specific limit "
"determined by the precision of a I<double>), and returns a pointer to the "
"string.  The high-order digit is nonzero, unless I<number> is zero.  The low "
"order digit is rounded.  The string itself does not contain a decimal point; "
"however, the position of the decimal point relative to the start of the "
"string is stored in I<*decpt>.  A negative value for I<*decpt> means that "
"the decimal point is to the left of the start of the string.  If the sign of "
"I<number> is negative, I<*sign> is set to a nonzero value, otherwise it is "
"set to 0.  If I<number> is zero, it is unspecified whether I<*decpt> is 0 or "
"1."
msgstr ""
"Функция B<ecvt>() преобразует I<number> в строку с завершающим null-символом "
"I<ndigits> цифр (количество I<ndigits> усекается до пределов точности, "
"определённых форматом I<double>) и возвращает указатель на строку. Самый "
"старший разряд полученного числа не будет равен нулю, если только само число "
"I<number> не равно нулю. Самый младший разряд округляется. Строка сама по "
"себе не содержит разделителя целой и дробной части, однако позиция "
"разделителя относительно начала строки сохраняется в I<*decpt>. "
"Отрицательное значение I<*decpt> означает, что разделитель находится слева "
"от начала строки. Если число I<number> отрицательное, то I<*sign> "
"устанавливается в ненулевое значение, иначе равно нулю. Если I<number> равно "
"нулю, то не определено, равен ли I<*decpt> 0 или 1."

#. type: Plain text
#: man-pages/man3/ecvt.3:98
msgid ""
"The B<fcvt>()  function is identical to B<ecvt>(), except that I<ndigits> "
"specifies the number of digits after the decimal point."
msgstr ""
"Функция B<fcvt>() аналогична B<ecvt>(), за исключением того, что I<ndigits> "
"указывает число цифр после разделителя."

#. type: Plain text
#: man-pages/man3/ecvt.3:109
msgid ""
"Both the B<ecvt>()  and B<fcvt>()  functions return a pointer to a static "
"string containing the ASCII representation of I<number>.  The static string "
"is overwritten by each call to B<ecvt>()  or B<fcvt>()."
msgstr ""
"Обе функции, B<ecvt>() и B<fcvt>(), возвращают указатель на статическую "
"строку, содержащую ASCII-представление I<number>. Статическая строка "
"перезаписывается каждый раз при вызове B<ecvt>() или B<fcvt>()."

#. type: tbl table
#: man-pages/man3/ecvt.3:119
#, no-wrap
msgid "B<ecvt>()"
msgstr "B<ecvt>()"

#. type: tbl table
#: man-pages/man3/ecvt.3:119
#, no-wrap
msgid "MT-Unsafe race:ecvt"
msgstr "MT-Unsafe race:ecvt"

#. type: tbl table
#: man-pages/man3/ecvt.3:122
#, no-wrap
msgid "B<fcvt>()"
msgstr "B<fcvt>()"

#. type: tbl table
#: man-pages/man3/ecvt.3:122
#, no-wrap
msgid "MT-Unsafe race:fcvt"
msgstr "MT-Unsafe race:fcvt"

#. type: Plain text
#: man-pages/man3/ecvt.3:136
msgid ""
"SVr2; marked as LEGACY in POSIX.1-2001.  POSIX.1-2008 removes the "
"specifications of B<ecvt>()  and B<fcvt>(), recommending the use of "
"B<sprintf>(3)  instead (though B<snprintf>(3)  may be preferable)."
msgstr ""
"SVr2; отмечены в POSIX.1-2001 как УСТАРЕВШИЕ. В POSIX.1-2008 спецификации "
"B<ecvt>() и B<fcvt>() удалены, вместо них рекомендуется использовать "
"B<sprintf>(3) (однако B<snprintf>(3) может быть предпочтительнее)."

#.  Linux libc4 and libc5 specified the type of
#.  .I ndigits
#.  as
#.  .IR size_t .
#. type: Plain text
#: man-pages/man3/ecvt.3:142
msgid "Not all locales use a point as the radix character (\"decimal point\")."
msgstr ""
"Не все локали используют точку в качестве разделителя целой и дробной части "
"(«десятичная точка»)."

#. type: Plain text
#: man-pages/man3/ecvt.3:147
msgid "B<ecvt_r>(3), B<gcvt>(3), B<qecvt>(3), B<setlocale>(3), B<sprintf>(3)"
msgstr "B<ecvt_r>(3), B<gcvt>(3), B<qecvt>(3), B<setlocale>(3), B<sprintf>(3)"

#. type: TH
#: man-pages/man3/end.3:26
#, no-wrap
msgid "END"
msgstr "END"

#. type: TH
#: man-pages/man3/end.3:26
#, no-wrap
msgid "GNU"
msgstr "GNU"

#. type: Plain text
#: man-pages/man3/end.3:29
msgid "etext, edata, end - end of program segments"
msgstr "etext, edata, end - конец программных сегментов"

#. type: Plain text
#: man-pages/man3/end.3:34
#, no-wrap
msgid ""
"B<extern>I< etext>B<;>\n"
"B<extern>I< edata>B<;>\n"
"B<extern>I< end>B<;>\n"
msgstr ""
"B<extern>I< etext>B<;>\n"
"B<extern>I< edata>B<;>\n"
"B<extern>I< end>B<;>\n"

#. type: Plain text
#: man-pages/man3/end.3:38
msgid ""
"The addresses of these symbols indicate the end of various program segments:"
msgstr ""
"Адреса этих символов соответствуют концам различных программных сегментов:"

#. type: TP
#: man-pages/man3/end.3:38
#, no-wrap
msgid "I<etext>"
msgstr "I<etext>"

#. type: Plain text
#: man-pages/man3/end.3:42
msgid ""
"This is the first address past the end of the text segment (the program "
"code)."
msgstr "Первый адрес за концом сегмента текста (кода программы)."

#. type: TP
#: man-pages/man3/end.3:42
#, no-wrap
msgid "I<edata>"
msgstr "I<edata>"

#. type: Plain text
#: man-pages/man3/end.3:46
msgid "This is the first address past the end of the initialized data segment."
msgstr "Первый адрес за концом сегмента инициализированных данных."

#. type: TP
#: man-pages/man3/end.3:46
#, no-wrap
msgid "I<end>"
msgstr "I<end>"

#. type: Plain text
#: man-pages/man3/end.3:50
msgid ""
"This is the first address past the end of the uninitialized data segment "
"(also known as the BSS segment)."
msgstr ""
"Первый адрес за концом сегмента неинициализированных данных (сегмента BSS)."

#. type: Plain text
#: man-pages/man3/end.3:53
msgid ""
"Although these symbols have long been provided on most UNIX systems, they "
"are not standardized; use with caution."
msgstr ""
"Хотя эти символы уже давно присутствуют в большинстве систем UNIX, они не "
"стандартизованы. Используйте осторожно."

#. type: Plain text
#: man-pages/man3/end.3:56
msgid ""
"The program must explicitly declare these symbols; they are not defined in "
"any header file."
msgstr ""
"Программа должна явно объявлять эти символы; они не определены в "
"заголовочных файлах."

#. type: Plain text
#: man-pages/man3/end.3:64
msgid ""
"On some systems the names of these symbols are preceded by underscores, "
"thus: I<_etext>, I<_edata>, and I<_end>.  These symbols are also defined for "
"programs compiled on Linux."
msgstr ""
"В некоторых системах имена этих символов начинаются с подчёркивания: "
"I<_etext>, I<_edata> и I<_end>. Эти символы также определены в программах, "
"скомпонованных на Linux."

#. type: Plain text
#: man-pages/man3/end.3:76
msgid ""
"At the start of program execution, the program break will be somewhere near "
"I<&end> (perhaps at the start of the following page).  However, the break "
"will change as memory is allocated via B<brk>(2)  or B<malloc>(3).  Use "
"B<sbrk>(2)  with an argument of zero to find the current value of the "
"program break."
msgstr ""
"В начале выполнения программы, повреждение программы будет где-нибудь рядом "
"c I<&end> (возможно, в начале следующей страницы). Однако, поломка изменяет "
"память как при выделении с помощью B<brk>(2) или B<malloc>(3). Используйте "
"B<sbrk>(2) с аргументом 0 для поиска текущего значения поломки программы."

#. type: Plain text
#: man-pages/man3/end.3:78
msgid "When run, the program below produces output such as the following:"
msgstr "Нижеследующая программа выдает такие результаты:"

#. type: Plain text
#: man-pages/man3/end.3:86
#, no-wrap
msgid ""
"$B< ./a.out>\n"
"First address past:\n"
"    program text (etext)       0x8048568\n"
"    initialized data (edata)   0x804a01c\n"
"    uninitialized data (end)   0x804a024\n"
msgstr ""
"$B< ./a.out>\n"
"First address past:\n"
"    program text (etext)       0x8048568\n"
"    initialized data (edata)   0x804a01c\n"
"    uninitialized data (end)   0x804a024\n"

#. type: Plain text
#: man-pages/man3/end.3:96
#, no-wrap
msgid ""
"extern char etext, edata, end; /* The symbols must have some type,\n"
"                                   or \"gcc -Wall\" complains */\n"
msgstr ""
"extern char etext, edata, end; /* Символы должны иметь какой-то тип,\n"
"                                   иначе предупреждения от «gcc -Wall» */\n"

#. type: Plain text
#: man-pages/man3/end.3:104
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    printf(\"First address past:\\en\");\n"
"    printf(\"    program text (etext)      %10p\\en\", &etext);\n"
"    printf(\"    initialized data (edata)  %10p\\en\", &edata);\n"
"    printf(\"    uninitialized data (end)  %10p\\en\", &end);\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    printf(\"First address past:\\en\");\n"
"    printf(\"    program text (etext)      %10p\\en\", &etext);\n"
"    printf(\"    initialized data (edata)  %10p\\en\", &edata);\n"
"    printf(\"    uninitialized data (end)  %10p\\en\", &end);\n"

#. type: Plain text
#: man-pages/man3/end.3:112
msgid "B<objdump>(1), B<readelf>(1), B<sbrk>(2), B<elf>(5)"
msgstr "B<objdump>(1), B<readelf>(1), B<sbrk>(2), B<elf>(5)"

#. type: TH
#: man-pages/man3/exit.3:29
#, no-wrap
msgid "EXIT"
msgstr "EXIT"

#. type: Plain text
#: man-pages/man3/exit.3:32
msgid "exit - cause normal process termination"
msgstr "exit - вызывает нормальное завершение процесса"

#. type: Plain text
#: man-pages/man3/exit.3:35
#, no-wrap
msgid "B<#include E<lt>stdlib.hE<gt>>\n"
msgstr "B<#include E<lt>stdlib.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/exit.3:37
#, no-wrap
msgid "B<void exit(int >I<status>B<);>\n"
msgstr "B<void exit(int >I<status>B<);>\n"

#. type: Plain text
#: man-pages/man3/exit.3:45
msgid ""
"The B<exit>()  function causes normal process termination and the value of "
"I<status & 0377> is returned to the parent (see B<wait>(2))."
msgstr ""
"Функция B<exit>() выполняет нормальное завершение процесса и возвращает "
"значение I<status & 0377> породившему процессу (смотрите B<wait>(2))."

#. type: Plain text
#: man-pages/man3/exit.3:72
msgid ""
"All functions registered with B<atexit>(3)  and B<on_exit>(3)  are called, "
"in the reverse order of their registration.  (It is possible for one of "
"these functions to use B<atexit>(3)  or B<on_exit>(3)  to register an "
"additional function to be executed during exit processing; the new "
"registration is added to the front of the list of functions that remain to "
"be called.)  If one of these functions does not return (e.g., it calls "
"B<_exit>(2), or kills itself with a signal), then none of the remaining "
"functions is called, and further exit processing (in particular, flushing of "
"B<stdio>(3)  streams) is abandoned.  If a function has been registered "
"multiple times using B<atexit>(3)  or B<on_exit>(3), then it is called as "
"many times as it was registered."
msgstr ""
"Вызываются все функции, зарегистрированные с помощью B<atexit>(3) и "
"B<on_exit>(3), в обратном по отношению к регистрации порядке (в этих "
"функциях возможно использовать B<atexit>(3) или B<on_exit>(3) для "
"регистрации дополнительной функции, которая будет также вызвана при выходе; "
"при этом она добавляется в начало списка функций, которые осталось вызвать). "
"Если из одной из функций не происходит возврат (например, она вызывает "
"B<_exit>(2) или завершает себя по сигналу), то оставшиеся функции не "
"вызываются, и дальнейший процесс выхода прекращается (в частности, запись "
"потоков B<stdio>(3)). Если функция зарегистрирована с помощью B<atexit>(3) "
"или B<on_exit>(3) несколько раз, то она вызывается столько раз, сколько "
"зарегистрирована."

#. type: Plain text
#: man-pages/man3/exit.3:79
msgid ""
"All open B<stdio>(3)  streams are flushed and closed.  Files created by "
"B<tmpfile>(3)  are removed."
msgstr ""
"Все открытые потоки B<stdio>(3) записываются и закрываются. Файлы, созданные "
"B<tmpfile>(3), удаляются."

#. type: Plain text
#: man-pages/man3/exit.3:86
msgid ""
"The C standard specifies two constants, B<EXIT_SUCCESS> and B<EXIT_FAILURE>, "
"that may be passed to B<exit>()  to indicate successful or unsuccessful "
"termination, respectively."
msgstr ""
"В стандарте Си определены две константы, B<EXIT_SUCCESS> и B<EXIT_FAILURE>, "
"которые можно передавать B<exit>() для указания корректности или "
"некорректности завершения, соответственно."

#. type: Plain text
#: man-pages/man3/exit.3:90
msgid "The B<exit>()  function does not return."
msgstr "Функция B<exit>() не возвращает выполнение."

#. type: tbl table
#: man-pages/man3/exit.3:100
#, no-wrap
msgid "B<exit>()"
msgstr "B<exit>()"

#. type: tbl table
#: man-pages/man3/exit.3:100
#, no-wrap
msgid "MT-Unsafe race:exit"
msgstr "MT-Unsafe race:exit"

#. type: Plain text
#: man-pages/man3/exit.3:107
msgid ""
"The B<exit>()  function uses a global variable that is not protected, so it "
"is not thread-safe."
msgstr ""
"Функция B<exit>() использует глобальную незащищённую переменную, поэтому "
"функцию нельзя использовать в нескольких нитях одновременно."

#. type: Plain text
#: man-pages/man3/exit.3:109
msgid "POSIX.1-2001, POSIX.1-2008, C89, C99, SVr4, 4.3BSD."
msgstr "POSIX.1-2001, POSIX.1-2008, C89, C99, SVr4, 4.3BSD."

#. type: Plain text
#: man-pages/man3/exit.3:125
msgid ""
"The behavior is undefined if one of the functions registered using "
"B<atexit>(3)  and B<on_exit>(3)  calls either B<exit>()  or B<longjmp>(3).  "
"Note that a call to B<execve>(2)  removes registrations created using "
"B<atexit>(3)  and B<on_exit>(3)."
msgstr ""
"Поведение не определено, если одна из функций, зарегистрированных с помощью "
"B<atexit>(3) и B<on_exit>(3), вызовет B<exit>() или B<longjmp>(3). Заметим, "
"что вызов B<execve>(2) удаляет регистрацию функций, сделанную с помощью "
"B<atexit>(3) и B<on_exit>(3)."

#. type: Plain text
#: man-pages/man3/exit.3:134
msgid ""
"The use of B<EXIT_SUCCESS> and B<EXIT_FAILURE> is slightly more portable (to "
"non-UNIX environments) than the use of 0 and some nonzero value like 1 or "
"-1.  In particular, VMS uses a different convention."
msgstr ""
"Использование B<EXIT_SUCCESS> и B<EXIT_FAILURE> является более переносимым "
"методом (в не-UNIX окружения), чем указание 0 и какого-то ненулевого "
"значения (например, 1 или -1). В частности, в VMS используется другое "
"соглашение."

#. type: Plain text
#: man-pages/man3/exit.3:139
msgid ""
"BSD has attempted to standardize exit codes (which some C libraries such as "
"the GNU C library have also adopted); see the file I<E<lt>sysexits.hE<gt>>."
msgstr ""
"В BSD пытались стандартизовать коды завершения (которые также были взяты и "
"другие библиотеки Си, например  GNU C); смотрите файл I<E<lt>sysexits."
"hE<gt>>."

#. type: Plain text
#: man-pages/man3/exit.3:145
msgid ""
"After B<exit>(), the exit status must be transmitted to the parent process.  "
"There are three cases:"
msgstr ""
"После B<exit>() код выхода должен быть передан родительскому процессу. Есть "
"три варианта:"

#. type: Plain text
#: man-pages/man3/exit.3:153
msgid ""
"If the parent has set B<SA_NOCLDWAIT>, or has set the B<SIGCHLD> handler to "
"B<SIG_IGN>, the status is discarded and the child dies immediately."
msgstr ""
"Если родитель установил обработчик B<SA_NOCLDWAIT> или B<SIGCHLD> равным "
"B<SIG_IGN>, то код выхода отбрасывается и потомок завершается сразу."

#. type: Plain text
#: man-pages/man3/exit.3:156
msgid ""
"If the parent was waiting on the child, it is notified of the exit status "
"and the child dies immediately."
msgstr ""
"Если родитель ожидает завершения потомка, то он получает код выхода и "
"потомок сразу завершается."

#. type: Plain text
#: man-pages/man3/exit.3:166
msgid ""
"Otherwise, the child becomes a \"zombie\" process: most of the process "
"resources are recycled, but a slot containing minimal information about the "
"child process (termination status, resource usage statistics) is retained in "
"process table.  This allows the parent to subsequently use B<waitpid>(2)  "
"(or similar) to learn the termination status of the child; at that point the "
"zombie process slot is released."
msgstr ""
"Иначе потомок становится процессом «зомби»: большинство ресурсов процесс "
"задействуется вторично, но слот с минимумом информации о процессе-потомке "
"(код завершения, статистика по использованию ресурсов) остаётся в таблице "
"процессов. Это позволяет родителю в дальнейшем использовать B<waitpid>(2) "
"(или подобный) для получения кода завершения потомка; после этого слот под "
"процесс-зомби освобождается."

#. type: Plain text
#: man-pages/man3/exit.3:177
msgid ""
"If the implementation supports the B<SIGCHLD> signal, this signal is sent to "
"the parent.  If the parent has set B<SA_NOCLDWAIT>, it is undefined whether "
"a B<SIGCHLD> signal is sent."
msgstr ""
"Если в реализации поддерживается сигнал B<SIGCHLD>, то он посылается "
"родителю. Если родитель установил флаг B<SA_NOCLDWAIT>, то поведение при "
"сигнале B<SIGCHLD> не определено."

#. type: SS
#: man-pages/man3/exit.3:177
#, no-wrap
msgid "Signals sent to other processes"
msgstr "Сигналы, посылаемые другим процессам"

#. type: Plain text
#: man-pages/man3/exit.3:186
msgid ""
"If the exiting process is a session leader and its controlling terminal is "
"the controlling terminal of the session, then each process in the foreground "
"process group of this controlling terminal is sent a B<SIGHUP> signal, and "
"the terminal is disassociated from this session, allowing it to be acquired "
"by a new controlling process."
msgstr ""
"Если существующий процесс является лидером сеанса и управляющим терминала "
"сеанса, то каждому процессу из группы фонового режима этого управляющего "
"терминала посылается сигнал B<SIGHUP>, и терминал отключается от сеанса, "
"чтобы его можно было захватить новому управляющему процессу."

#. type: Plain text
#: man-pages/man3/exit.3:198
msgid ""
"If the exit of the process causes a process group to become orphaned, and if "
"any member of the newly orphaned process group is stopped, then a B<SIGHUP> "
"signal followed by a B<SIGCONT> signal will be sent to each process in this "
"process group.  See B<setpgid>(2)  for an explanation of orphaned process "
"groups."
msgstr ""
"Если завершение процесса приводит к осиротению группы процессов, и если "
"любой член только что осиротевшей группы останавливается, то каждому "
"процессу этой группы после сигнала B<SIGHUP> будет послан сигнал B<SIGCONT>. "
"Описание процесса осиротения группы смотрите в B<setpgid>(2)."

#. type: Plain text
#: man-pages/man3/exit.3:208
msgid ""
"Except in the above cases, where the signalled processes may be children of "
"the terminating process, termination of a process does I<not> in general "
"cause a signal to be sent to children of that process.  However, a process "
"can use the B<prctl>(2)  B<PR_SET_PDEATHSIG> operation to arrange that it "
"receives a signal if its parent terminates."
msgstr ""
"За исключением описанные выше случаев, когда процессы, куда посылается "
"сигнал, могут быть потомками завершающегося процесса, завершение процесса, "
"обычно, I<не> приводит к отправке сигнала потомкам этого процесса. Однако, "
"процесс может вызвать B<prctl>(2) с операцией B<PR_SET_PDEATHSIG>, чтобы "
"подготовиться к получению сигнала, если его родитель завершает работу."

#. type: Plain text
#: man-pages/man3/exit.3:215
msgid ""
"B<_exit>(2), B<get_robust_list>(2), B<setpgid>(2), B<wait>(2), B<atexit>(3), "
"B<on_exit>(3), B<tmpfile>(3)"
msgstr ""
"B<_exit>(2), B<get_robust_list>(2), B<setpgid>(2), B<wait>(2), B<atexit>(3), "
"B<on_exit>(3), B<tmpfile>(3)"

#. type: TH
#: man-pages/man3/endian.3:28
#, no-wrap
msgid "ENDIAN"
msgstr "ENDIAN"

#. type: Plain text
#: man-pages/man3/endian.3:33
msgid ""
"htobe16, htole16, be16toh, le16toh, htobe32, htole32, be32toh, le32toh, "
"htobe64, htole64, be64toh, le64toh - convert values between host and big-/"
"little-endian byte order"
msgstr ""
"htobe16, htole16, be16toh, le16toh, htobe32, htole32, be32toh, le32toh, "
"htobe64, htole64, be64toh, le64toh - изменяет порядок байт у целого числа"

#. type: Plain text
#: man-pages/man3/endian.3:36
#, no-wrap
msgid "B<#include E<lt>endian.hE<gt>>\n"
msgstr "B<#include E<lt>endian.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/endian.3:41
#, no-wrap
msgid ""
"B<uint16_t htobe16(uint16_t >I<host_16bits>B<);>\n"
"B<uint16_t htole16(uint16_t >I<host_16bits>B<);>\n"
"B<uint16_t be16toh(uint16_t >I<big_endian_16bits>B<);>\n"
"B<uint16_t le16toh(uint16_t >I<little_endian_16bits>B<);>\n"
msgstr ""
"B<uint16_t htobe16(uint16_t >I<host_16bits>B<);>\n"
"B<uint16_t htole16(uint16_t >I<host_16bits>B<);>\n"
"B<uint16_t be16toh(uint16_t >I<big_endian_16bits>B<);>\n"
"B<uint16_t le16toh(uint16_t >I<little_endian_16bits>B<);>\n"

#. type: Plain text
#: man-pages/man3/endian.3:46
#, no-wrap
msgid ""
"B<uint32_t htobe32(uint32_t >I<host_32bits>B<);>\n"
"B<uint32_t htole32(uint32_t >I<host_32bits>B<);>\n"
"B<uint32_t be32toh(uint32_t >I<big_endian_32bits>B<);>\n"
"B<uint32_t le32toh(uint32_t >I<little_endian_32bits>B<);>\n"
msgstr ""
"B<uint32_t htobe32(uint32_t >I<host_32bits>B<);>\n"
"B<uint32_t htole32(uint32_t >I<host_32bits>B<);>\n"
"B<uint32_t be32toh(uint32_t >I<big_endian_32bits>B<);>\n"
"B<uint32_t le32toh(uint32_t >I<little_endian_32bits>B<);>\n"

#. type: Plain text
#: man-pages/man3/endian.3:51
#, no-wrap
msgid ""
"B<uint64_t htobe64(uint64_t >I<host_64bits>B<);>\n"
"B<uint64_t htole64(uint64_t >I<host_64bits>B<);>\n"
"B<uint64_t be64toh(uint64_t >I<big_endian_64bits>B<);>\n"
"B<uint64_t le64toh(uint64_t >I<little_endian_64bits>B<);>\n"
msgstr ""
"B<uint64_t htobe64(uint64_t >I<host_64bits>B<);>\n"
"B<uint64_t htole64(uint64_t >I<host_64bits>B<);>\n"
"B<uint64_t be64toh(uint64_t >I<big_endian_64bits>B<);>\n"
"B<uint64_t le64toh(uint64_t >I<little_endian_64bits>B<);>\n"

#. type: Plain text
#: man-pages/man3/endian.3:70
msgid ""
"B<htobe16>(), B<htole16>(), B<be16toh>(), B<le16toh>(), B<htobe32>(), "
"B<htole32>(), B<be32toh>(), B<le32toh>(), B<htobe64>(), B<htole64>(), "
"B<be64toh>(), B<le64toh>():"
msgstr ""
"B<htobe16>(), B<htole16>(), B<be16toh>(), B<le16toh>(), B<htobe32>(), "
"B<htole32>(), B<be32toh>(), B<le32toh>(), B<htobe64>(), B<htole64>(), "
"B<be64toh>(), B<le64toh>():"

#. type: Plain text
#: man-pages/man3/endian.3:75
#, no-wrap
msgid ""
"    Since glibc 2.19:\n"
"        _DEFAULT_SOURCE\n"
"    In glibc up to and including 2.19:\n"
"        _BSD_SOURCE\n"
msgstr ""
"    начиная с glibc 2.19:\n"
"        _DEFAULT_SOURCE\n"
"    в glibc до версии 2.19 включительно:\n"
"        _BSD_SOURCE\n"

#. type: Plain text
#: man-pages/man3/endian.3:80
msgid ""
"These functions convert the byte encoding of integer values from the byte "
"order that the current CPU (the \"host\") uses, to and from little-endian "
"and big-endian byte order."
msgstr ""
"Эти функции преобразуют кодирование байт целых значений из/в порядок байт, "
"используемом в работающем ЦП («порядок байт узла»), от младшего к старшему "
"(little-endian) и от старшего к младшему (big-endian)."

#. type: Plain text
#: man-pages/man3/endian.3:85
msgid ""
"The number, I<nn>, in the name of each function indicates the size of "
"integer handled by the function, either 16, 32, or 64 bits."
msgstr ""
"Число I<nn> в имени каждой функции показывает размер целого, с которым "
"работает функция — может быть 16, 32 или 64 бита."

#. type: Plain text
#: man-pages/man3/endian.3:88
msgid ""
"The functions with names of the form \"htobeI<nn>\" convert from host byte "
"order to big-endian order."
msgstr ""
"Функции с именами вида «htobeI<nn>» преобразуют число с порядком байт узла в "
"число с порядком байт от старшего к младшему."

#. type: Plain text
#: man-pages/man3/endian.3:91
msgid ""
"The functions with names of the form \"htoleI<nn>\" convert from host byte "
"order to little-endian order."
msgstr ""
"Функции с именами вида «htoleI<nn>» преобразуют число с порядком байт узла в "
"число с порядком байт от младшего к старшему."

#. type: Plain text
#: man-pages/man3/endian.3:94
msgid ""
"The functions with names of the form \"beI<nn>toh\" convert from big-endian "
"order to host byte order."
msgstr ""
"Функции с именами вида «beI<nn>toh» преобразуют число с порядком байт от "
"старшего к младшему в число с порядком байт узла."

#. type: Plain text
#: man-pages/man3/endian.3:97
msgid ""
"The functions with names of the form \"leI<nn>toh\" convert from little-"
"endian order to host byte order."
msgstr ""
"Функции с именами вида «leI<nn>toh» преобразуют число с порядком байт от "
"младшего к старшему в число с порядком байт узла."

#. type: Plain text
#: man-pages/man3/endian.3:99
msgid "These functions were added to glibc in version 2.9."
msgstr "Эти функции добавлены в glibc версии 2.9."

#. type: Plain text
#: man-pages/man3/endian.3:114
msgid ""
"These functions are nonstandard.  Similar functions are present on the BSDs, "
"where the required header file is I<E<lt>sys/endian.hE<gt>> instead of "
"I<E<lt>endian.hE<gt>>.  Unfortunately, NetBSD, FreeBSD, and glibc haven't "
"followed the original OpenBSD naming convention for these functions, whereby "
"the I<nn> component always appears at the end of the function name (thus, "
"for example, in NetBSD, FreeBSD, and glibc, the equivalent of OpenBSDs "
"\"betoh32\" is \"be32toh\")."
msgstr ""
"Это нестандартные функции. Подобные функции есть в BSD, где вместо "
"I<E<lt>endian.hE<gt>> для них требуется заголовочный файл I<E<lt>sys/endian."
"hE<gt>>. К сожалению, NetBSD, FreeBSD и glibc не следуют изначальному "
"соглашению об именах функций в OpenBSD, где часть I<nn> всегда находится в "
"конце имени функции (то есть, например, в NetBSD, FreeBSD и glibc "
"используется «be32toh» вместо эквивалентной «betoh32» из OpenBSD)."

#. type: Plain text
#: man-pages/man3/endian.3:122
msgid ""
"These functions are similar to the older B<byteorder>(3)  family of "
"functions.  For example, B<be32toh>()  is identical to B<ntohl>()."
msgstr ""
"Данные функции похожи на функции старого семейства B<byteorder>(3). "
"Например, B<be32toh>() идентична B<ntohl>()."

#. type: Plain text
#: man-pages/man3/endian.3:130
msgid ""
"The advantage of the B<byteorder>(3)  functions is that they are standard "
"functions available on all UNIX systems.  On the other hand, the fact that "
"they were designed for use in the context of TCP/IP means that they lack the "
"64-bit and little-endian variants described in this page."
msgstr ""
"Преимущество функций B<byteorder>(3) в том, что они являются стандартными и "
"доступны во всех системах UNIX. С другой стороны, тот факт, что они "
"разрабатывались для использования в контексте TCP/IP означает, что среди них "
"нет функций для 64-битных значений и чисел с порядком байт от младшего к "
"старшему, описанных в этой странице."

#. type: Plain text
#: man-pages/man3/endian.3:137
msgid ""
"The program below display the results of converting an integer from host "
"byte order to both little-endian and big-endian byte order.  Since host byte "
"order is either little-endian or big-endian, only one of these conversions "
"will have an effect.  When we run this program on a little-endian system "
"such as x86-32, we see the following:"
msgstr ""
"Ниже представлена программа, которая выводит результаты преобразования "
"целого с порядком байт узла в целое с порядком байт от младшего к старшему и "
"от старшего к младшему. Так как порядок байт узла будет эквивалентен порядку "
"от младшего к старшему или от старшего к младшему, то реально выполняется "
"только одно преобразование. Если эта программа запускается на системе с "
"порядком байт от младшего к старшему, например x86-32, то мы увидим "
"следующее:"

#. type: Plain text
#: man-pages/man3/endian.3:144
#, no-wrap
msgid ""
"$ B<./a.out>\n"
"x.u32 = 0x44332211\n"
"htole32(x.u32) = 0x44332211\n"
"htobe32(x.u32) = 0x11223344\n"
msgstr ""
"$ B<./a.out>\n"
"x.u32 = 0x44332211\n"
"htole32(x.u32) = 0x44332211\n"
"htobe32(x.u32) = 0x11223344\n"

#. type: Plain text
#: man-pages/man3/endian.3:153
#, no-wrap
msgid ""
"#include E<lt>endian.hE<gt>\n"
"#include E<lt>stdint.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
msgstr ""
"#include E<lt>endian.hE<gt>\n"
"#include E<lt>stdint.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"

#. type: Plain text
#: man-pages/man3/endian.3:161
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    union {\n"
"        uint32_t u32;\n"
"        uint8_t arr[4];\n"
"    } x;\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    union {\n"
"        uint32_t u32;\n"
"        uint8_t arr[4];\n"
"    } x;\n"

#. type: Plain text
#: man-pages/man3/endian.3:166
#, no-wrap
msgid ""
"    x.arr[0] = 0x11;\t/* Lowest-address byte */\n"
"    x.arr[1] = 0x22;\n"
"    x.arr[2] = 0x33;\n"
"    x.arr[3] = 0x44;\t/* Highest-address byte */\n"
msgstr ""
"    x.arr[0] = 0x11;\t/* низший адресуемый байт */\n"
"    x.arr[1] = 0x22;\n"
"    x.arr[2] = 0x33;\n"
"    x.arr[3] = 0x44;\t/* высший адресуемый байт */\n"

#. type: Plain text
#: man-pages/man3/endian.3:170
#, no-wrap
msgid ""
"    printf(\"x.u32 = 0x%x\\en\", x.u32);\n"
"    printf(\"htole32(x.u32) = 0x%x\\en\", htole32(x.u32));\n"
"    printf(\"htobe32(x.u32) = 0x%x\\en\", htobe32(x.u32));\n"
msgstr ""
"    printf(\"x.u32 = 0x%x\\en\", x.u32);\n"
"    printf(\"htole32(x.u32) = 0x%x\\en\", htole32(x.u32));\n"
"    printf(\"htobe32(x.u32) = 0x%x\\en\", htobe32(x.u32));\n"

#. type: Plain text
#: man-pages/man3/endian.3:176
msgid "B<bswap>(3), B<byteorder>(3)"
msgstr "B<bswap>(3), B<byteorder>(3)"

#. type: TH
#: man-pages/man3/encrypt.3:30
#, no-wrap
msgid "ENCRYPT"
msgstr "ENCRYPT"

#. type: TH
#: man-pages/man3/encrypt.3:30
#, no-wrap
msgid "2018-04-30"
msgstr "2018-04-30"

#. type: Plain text
#: man-pages/man3/encrypt.3:33
msgid "encrypt, setkey, encrypt_r, setkey_r - encrypt 64-bit messages"
msgstr "encrypt, setkey, encrypt_r, setkey_r - шифрование 64-битных сообщений"

#. type: Plain text
#: man-pages/man3/encrypt.3:37
#, no-wrap
msgid ""
"B<#define _XOPEN_SOURCE>       /* See feature_test_macros(7) */\n"
"B<#include E<lt>unistd.hE<gt>>\n"
msgstr ""
"B<#define _XOPEN_SOURCE>       /* См. feature_test_macros(7) */\n"
"B<#include E<lt>unistd.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/encrypt.3:39
#, no-wrap
msgid "B<void encrypt(char >I<block>B<[64], int >I<edflag>B<);>\n"
msgstr "B<void encrypt(char >I<block>B<[64], int >I<edflag>B<);>\n"

#. type: Plain text
#: man-pages/man3/encrypt.3:42
#, no-wrap
msgid ""
"B<#define _XOPEN_SOURCE>       /* See feature_test_macros(7) */\n"
"B<#include E<lt>stdlib.hE<gt>>\n"
msgstr ""
"B<#define _XOPEN_SOURCE>       /* смотрите feature_test_macros(7) */\n"
"B<#include E<lt>stdlib.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/encrypt.3:44
#, no-wrap
msgid "B<void setkey(const char *>I<key>B<);>\n"
msgstr "B<void setkey(const char *>I<key>B<);>\n"

#. type: Plain text
#: man-pages/man3/encrypt.3:47
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>         /* See feature_test_macros(7) */\n"
"B<#include E<lt>crypt.hE<gt>>\n"
msgstr ""
"B<#define _GNU_SOURCE>         /* смотрите feature_test_macros(7) */\n"
"B<#include E<lt>crypt.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/encrypt.3:51
#, no-wrap
msgid ""
"B<void setkey_r(const char *>I<key>B<, struct crypt_data *>I<data>B<);>\n"
"B<void encrypt_r(char *>I<block>B<, int >I<edflag>B<, struct crypt_data *>I<data>B<);>\n"
msgstr ""
"B<void setkey_r(const char *>I<key>B<, struct crypt_data *>I<data>B<);>\n"
"B<void encrypt_r(char *>I<block>B<, int >I<edflag>B<, struct crypt_data *>I<data>B<);>\n"

#. type: Plain text
#: man-pages/man3/encrypt.3:54
msgid "Each of these requires linking with I<-lcrypt>."
msgstr "Для любой функции требуется компоновка с параметром I<-lcrypt>."

#. type: Plain text
#: man-pages/man3/encrypt.3:66
msgid ""
"These functions encrypt and decrypt 64-bit messages.  The B<setkey>()  "
"function sets the key used by B<encrypt>().  The I<key> argument used here "
"is an array of 64 bytes, each of which has numerical value 1 or 0.  The "
"bytes key[n] where n=8*i-1 are ignored, so that the effective key length is "
"56 bits."
msgstr ""
"Эти функции кодируют и декодируют 64-битные сообщения. Функцией B<setkey>() "
"задаётся ключ, который затем используется B<encrypt>(). Параметр I<key> "
"является массивом из 64 байтов, каждый из которых имеет значение 1 или 0. "
"Байты key[n], где n=8*i-1 — игнорируются, так что действительная длина ключа "
"равна 56 битам."

#. type: Plain text
#: man-pages/man3/encrypt.3:78
msgid ""
"The B<encrypt>()  function modifies the passed buffer, encoding if I<edflag> "
"is 0, and decoding if 1 is being passed.  Like the I<key> argument, also "
"I<block> is a bit vector representation of the actual value that is "
"encoded.  The result is returned in that same vector."
msgstr ""
"Функция B<encrypt>() изменяет переданный буфер и, если значение I<edflag> "
"равно 0, то кодирует его, а если равно 1 — то декодирует. Как и параметр "
"I<key>, аргумент I<block> также является представлением битового вектора "
"действительного кодируемого значения. Результат возвращается в этом же "
"векторе."

#. type: Plain text
#: man-pages/man3/encrypt.3:88
msgid ""
"These two functions are not reentrant, that is, the key data is kept in "
"static storage.  The functions B<setkey_r>()  and B<encrypt_r>()  are the "
"reentrant versions.  They use the following structure to hold the key data:"
msgstr ""
"Эти две функции не являются повторно используемыми, то есть данные ключа "
"хранятся в статическом хранилище. Функции B<setkey_r>() и B<encrypt_r>() "
"являются повторно используемыми версиями. Они используют следующую структуру "
"для хранения данных ключа:"

#. type: Plain text
#: man-pages/man3/encrypt.3:103
#, no-wrap
msgid ""
"struct crypt_data {\n"
"    char     keysched[16 * 8];\n"
"    char     sb0[32768];\n"
"    char     sb1[32768];\n"
"    char     sb2[32768];\n"
"    char     sb3[32768];\n"
"    char     crypt_3_buf[14];\n"
"    char     current_salt[2];\n"
"    long int current_saltbits;\n"
"    int      direction;\n"
"    int      initialized;\n"
"};\n"
msgstr ""
"struct crypt_data {\n"
"    char     keysched[16 * 8];\n"
"    char     sb0[32768];\n"
"    char     sb1[32768];\n"
"    char     sb2[32768];\n"
"    char     sb3[32768];\n"
"    char     crypt_3_buf[14];\n"
"    char     current_salt[2];\n"
"    long int current_saltbits;\n"
"    int      direction;\n"
"    int      initialized;\n"
"};\n"

#. type: Plain text
#: man-pages/man3/encrypt.3:111
msgid "Before calling B<setkey_r>()  set I<data-E<gt>initialized> to zero."
msgstr "Перед вызовом B<setkey_r>() обнулите I<data-E<gt>initialized>."

#. type: Plain text
#: man-pages/man3/encrypt.3:113
msgid "These functions do not return any value."
msgstr "Данные функции не возвращают никаких значений."

#. type: Plain text
#: man-pages/man3/encrypt.3:118
msgid ""
"Set I<errno> to zero before calling the above functions.  On success, it is "
"unchanged."
msgstr ""
"Установите переменную I<errno> в ноль перед вызовом этих функций. При "
"нормальном завершении работы её значение не изменится."

#. type: TP
#: man-pages/man3/encrypt.3:118
#, no-wrap
msgid "B<ENOSYS>"
msgstr "B<ENOSYS>"

#. type: Plain text
#: man-pages/man3/encrypt.3:122
msgid ""
"The function is not provided.  (For example because of former USA export "
"restrictions.)"
msgstr ""
"Функция не предусмотрена (например, из-за старых запретов США на экспорт)."

#. type: Plain text
#: man-pages/man3/encrypt.3:133
msgid ""
"Because they employ the DES block cipher, which is no longer considered "
"secure, B<crypt>(), B<crypt_r>(), B<setkey>(), and B<setkey_r>()  were "
"removed in glibc 2.28.  Applications should switch to a modern cryptography "
"library, such as B<libgcrypt>."
msgstr ""
"Функции B<crypt>(), B<crypt_r>(), B<setkey>() и B<setkey_r>() удалены из "
"glibc 2.28, так как они используют блочный шифр DES, который теперь "
"считается небезопасным. В приложениях следует использовать современную "
"библиотеку шифрования, например B<libgcrypt>."

#. type: tbl table
#: man-pages/man3/encrypt.3:144
#, no-wrap
msgid ""
"B<encrypt>(),\n"
"B<setkey>()"
msgstr ""
"B<encrypt>(),\n"
"B<setkey>()"

#. type: tbl table
#: man-pages/man3/encrypt.3:144
#, no-wrap
msgid "MT-Unsafe race:crypt"
msgstr "MT-Unsafe race:crypt"

#. type: tbl table
#: man-pages/man3/encrypt.3:148
#, no-wrap
msgid ""
"B<encrypt_r>(),\n"
"B<setkey_r>()"
msgstr ""
"B<encrypt_r>(),\n"
"B<setkey_r>()"

#. type: Plain text
#: man-pages/man3/encrypt.3:154
msgid "B<encrypt>(), B<setkey>(): POSIX.1-2001, POSIX.1-2008, SUS, SVr4."
msgstr "B<encrypt>(), B<setkey>(): POSIX.1-2001, POSIX.1-2008, SUS, SVr4."

#. type: Plain text
#: man-pages/man3/encrypt.3:160
msgid "The functions B<encrypt_r>()  and B<setkey_r>()  are GNU extensions."
msgstr "Функции B<encrypt_r>() и B<setkey_r>() являются расширениями GNU."

#. type: SS
#: man-pages/man3/encrypt.3:161
#, no-wrap
msgid "Availability in glibc"
msgstr "Доступность в glibc"

#. type: Plain text
#: man-pages/man3/encrypt.3:164
msgid "See B<crypt>(3)."
msgstr "Смотрите B<crypt>(3)."

#. type: SS
#: man-pages/man3/encrypt.3:164
#, no-wrap
msgid "Features in glibc"
msgstr "Свойства в glibc"

#. type: Plain text
#: man-pages/man3/encrypt.3:166
msgid "In glibc 2.2, these functions use the DES algorithm."
msgstr "В glibc 2.2 в данных функциях используется алгоритм DES."

#. type: Plain text
#: man-pages/man3/encrypt.3:173
#, no-wrap
msgid ""
"#define _XOPEN_SOURCE\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>crypt.hE<gt>\n"
msgstr ""
"#define _XOPEN_SOURCE\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>crypt.hE<gt>\n"

#. type: Plain text
#: man-pages/man3/encrypt.3:182
#, no-wrap
msgid ""
"int\n"
"main(void)\n"
"{\n"
"    char key[64];\n"
"    char orig[9] = \"eggplant\";\n"
"    char buf[64];\n"
"    char txt[9];\n"
"    int i, j;\n"
msgstr ""
"int\n"
"main(void)\n"
"{\n"
"    char key[64];\n"
"    char orig[9] = \"eggplant\";\n"
"    char buf[64];\n"
"    char txt[9];\n"
"    int i, j;\n"

#. type: Plain text
#: man-pages/man3/encrypt.3:186
#, no-wrap
msgid ""
"    for (i = 0; i E<lt> 64; i++) {\n"
"        key[i] = rand() & 1;\n"
"    }\n"
msgstr ""
"    for (i = 0; i E<lt> 64; i++) {\n"
"        key[i] = rand() & 1;\n"
"    }\n"

#. type: Plain text
#: man-pages/man3/encrypt.3:194
#, no-wrap
msgid ""
"    for (i = 0; i E<lt> 8; i++) {\n"
"        for (j = 0; j E<lt> 8; j++) {\n"
"            buf[i * 8 + j] = orig[i] E<gt>E<gt> j & 1;\n"
"        }\n"
"        setkey(key);\n"
"    }\n"
"    printf(\"Before encrypting: %s\\en\", orig);\n"
msgstr ""
"    for (i = 0; i E<lt> 8; i++) {\n"
"        for (j = 0; j E<lt> 8; j++) {\n"
"            buf[i * 8 + j] = orig[i] E<gt>E<gt> j & 1;\n"
"        }\n"
"        setkey(key);\n"
"    }\n"
"    printf(\"До шифрования: %s\\en\", orig);\n"

#. type: Plain text
#: man-pages/man3/encrypt.3:203
#, no-wrap
msgid ""
"    encrypt(buf, 0);\n"
"    for (i = 0; i E<lt> 8; i++) {\n"
"        for (j = 0, txt[i] = \\(aq\\e0\\(aq; j E<lt> 8; j++) {\n"
"            txt[i] |= buf[i * 8 + j] E<lt>E<lt> j;\n"
"        }\n"
"        txt[8] = \\(aq\\e0\\(aq;\n"
"    }\n"
"    printf(\"After encrypting:  %s\\en\", txt);\n"
msgstr ""
"    encrypt(buf, 0);\n"
"    for (i = 0; i E<lt> 8; i++) {\n"
"        for (j = 0, txt[i] = \\(aq\\e0\\(aq; j E<lt> 8; j++) {\n"
"            txt[i] |= buf[i * 8 + j] E<lt>E<lt> j;\n"
"        }\n"
"        txt[8] = \\(aq\\e0\\(aq;\n"
"    }\n"
"    printf(\"После шифрования:  %s\\en\", txt);\n"

#. type: Plain text
#: man-pages/man3/encrypt.3:214
#, no-wrap
msgid ""
"    encrypt(buf, 1);\n"
"    for (i = 0; i E<lt> 8; i++) {\n"
"        for (j = 0, txt[i] = \\(aq\\e0\\(aq; j E<lt> 8; j++) {\n"
"            txt[i] |= buf[i * 8 + j] E<lt>E<lt> j;\n"
"        }\n"
"        txt[8] = \\(aq\\e0\\(aq;\n"
"    }\n"
"    printf(\"After decrypting:  %s\\en\", txt);\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""
"    encrypt(buf, 1);\n"
"    for (i = 0; i E<lt> 8; i++) {\n"
"        for (j = 0, txt[i] = \\(aq\\e0\\(aq; j E<lt> 8; j++) {\n"
"            txt[i] |= buf[i * 8 + j] E<lt>E<lt> j;\n"
"        }\n"
"        txt[8] = \\(aq\\e0\\(aq;\n"
"    }\n"
"    printf(\"После расшифровки:  %s\\en\", txt);\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"

#. type: Plain text
#: man-pages/man3/encrypt.3:218
msgid "B<cbc_crypt>(3), B<crypt>(3), B<ecb_crypt>(3),"
msgstr "B<cbc_crypt>(3), B<crypt>(3), B<ecb_crypt>(3),"

#. type: TH
#: man-pages/man3/ether_aton.3:31
#, no-wrap
msgid "ETHER_ATON"
msgstr "ETHER_ATON"

#. type: Plain text
#: man-pages/man3/ether_aton.3:35
msgid ""
"ether_aton, ether_ntoa, ether_ntohost, ether_hostton, ether_line, "
"ether_ntoa_r, ether_aton_r - Ethernet address manipulation routines"
msgstr ""
"ether_aton, ether_ntoa, ether_ntohost, ether_hostton, ether_line, "
"ether_ntoa_r, ether_aton_r - процедуры для работы с адресами ethernet"

#. type: Plain text
#: man-pages/man3/ether_aton.3:38
#, no-wrap
msgid "B<#include E<lt>netinet/ether.hE<gt>>\n"
msgstr "B<#include E<lt>netinet/ether.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/ether_aton.3:40
#, no-wrap
msgid "B<char *ether_ntoa(const struct ether_addr *>I<addr>B<);>\n"
msgstr "B<char *ether_ntoa(const struct ether_addr *>I<addr>B<);>\n"

#. type: Plain text
#: man-pages/man3/ether_aton.3:42
#, no-wrap
msgid "B<struct ether_addr *ether_aton(const char *>I<asc>B<);>\n"
msgstr "B<struct ether_addr *ether_aton(const char *>I<asc>B<);>\n"

#. type: Plain text
#: man-pages/man3/ether_aton.3:44
#, no-wrap
msgid "B<int ether_ntohost(char *>I<hostname>B<, const struct ether_addr *>I<addr>B<);>\n"
msgstr "B<int ether_ntohost(char *>I<hostname>B<, const struct ether_addr *>I<addr>B<);>\n"

#. type: Plain text
#: man-pages/man3/ether_aton.3:46
#, no-wrap
msgid "B<int ether_hostton(const char *>I<hostname>B<, struct ether_addr *>I<addr>B<);>\n"
msgstr "B<int ether_hostton(const char *>I<hostname>B<, struct ether_addr *>I<addr>B<);>\n"

#. type: Plain text
#: man-pages/man3/ether_aton.3:49
#, no-wrap
msgid ""
"B<int ether_line(const char *>I<line>B<, struct ether_addr *>I<addr>B<,>\n"
"B<               char *>I<hostname>B<);>\n"
msgstr ""
"B<int ether_line(const char *>I<line>B<, struct ether_addr *>I<addr>B<,>\n"
"B<               char *>I<hostname>B<);>\n"

#. type: Plain text
#: man-pages/man3/ether_aton.3:51
#, no-wrap
msgid "/* GNU extensions */\n"
msgstr "/* расширения GNU */\n"

#. type: Plain text
#: man-pages/man3/ether_aton.3:53
#, no-wrap
msgid "B<char *ether_ntoa_r(const struct ether_addr *>I<addr>B<, char *>I<buf>B<);>\n"
msgstr "B<char *ether_ntoa_r(const struct ether_addr *>I<addr>B<, char *>I<buf>B<);>\n"

#. type: Plain text
#: man-pages/man3/ether_aton.3:56
#, no-wrap
msgid ""
"B<struct ether_addr *ether_aton_r(const char *>I<asc>B<,>\n"
"B<                                struct ether_addr *>I<addr>B<);>\n"
msgstr ""
"B<struct ether_addr *ether_aton_r(const char *>I<asc>B<,>\n"
"B<                                struct ether_addr *>I<addr>B<);>\n"

#. type: Plain text
#: man-pages/man3/ether_aton.3:67
msgid ""
"B<ether_aton>()  converts the 48-bit Ethernet host address I<asc> from the "
"standard hex-digits-and-colons notation into binary data in network byte "
"order and returns a pointer to it in a statically allocated buffer, which "
"subsequent calls will overwrite.  B<ether_aton>()  returns NULL if the "
"address is invalid."
msgstr ""
"Функция B<ether_aton>() преобразует 48-битный адрес узла Ethernet I<asc> из "
"стандартной записи в виде шестнадцатеричных-символов-и-двоеточий в двоичный "
"код с сетевым порядком расположения байтов и возвращает указатель на него в "
"статически выделенном буфере, который могут изменить любые последующие "
"вызовы. Функция B<ether_aton>() возвращает NULL, если адрес некорректен."

#. type: Plain text
#: man-pages/man3/ether_aton.3:76
msgid ""
"The B<ether_ntoa>()  function converts the Ethernet host address I<addr> "
"given in network byte order to a string in standard hex-digits-and-colons "
"notation, omitting leading zeros.  The string is returned in a statically "
"allocated buffer, which subsequent calls will overwrite."
msgstr ""
"Функция B<ether_ntoa>() преобразует адрес узла Ethernet I<addr>, заданный "
"значением с сетевым порядком байтов, в строку в стандартной форме записи в "
"виде шестнадцатеричных-символов-и-двоеточий. Строка возвращается в "
"статически выделяемом буфере, который перезаписывается при последующих "
"вызовах."

#. type: Plain text
#: man-pages/man3/ether_aton.3:83
msgid ""
"The B<ether_ntohost>()  function maps an Ethernet address to the "
"corresponding hostname in I</etc/ethers> and returns nonzero if it cannot be "
"found."
msgstr ""
"Функция B<ether_ntohost>() для заданного адреса Ethernet ищет "
"соответствующее имя узла в файле I</etc/ethers> и возвращает ненулевое "
"значение, если оно не может быть найдено."

#. type: Plain text
#: man-pages/man3/ether_aton.3:90
msgid ""
"The B<ether_hostton>()  function maps a hostname to the corresponding "
"Ethernet address in I</etc/ethers> and returns nonzero if it cannot be found."
msgstr ""
"Функция B<ether_hostton>() для заданного имени узла ищет соответствующий "
"адрес Ethernet в файле I</etc/ethers> и возвращает ненулевое значение, если "
"он не может быть найден."

#. type: Plain text
#: man-pages/man3/ether_aton.3:102
msgid ""
"The B<ether_line>()  function parses a line in I</etc/ethers> format "
"(ethernet address followed by whitespace followed by hostname; \\(aq#\\(aq "
"introduces a comment) and returns an address and hostname pair, or nonzero "
"if it cannot be parsed.  The buffer pointed to by I<hostname> must be "
"sufficiently long, for example, have the same length as I<line>."
msgstr ""
"Функция B<ether_line>() обрабатывает строку в формате файла I</etc/ethers> "
"(адрес Ethernet, пробельный символ, имя узла; комментарий начинается с \\(aq#"
"\\(aq) и возвращает пару адрес/имя узла, или ненулевое значение, если строка "
"не может быть обработана. Буфер, на который указывает I<hostname>, должен "
"быть достаточно большим, чтобы вместить, например, строку I<line>."

#. type: Plain text
#: man-pages/man3/ether_aton.3:113
msgid ""
"The functions B<ether_ntoa_r>()  and B<ether_aton_r>()  are reentrant thread-"
"safe versions of B<ether_ntoa>()  and B<ether_aton>()  respectively, and do "
"not use static buffers."
msgstr ""
"Функции B<ether_ntoa_r>() и B<ether_aton_r>() являются безопасными для "
"использования в нитях аналогами B<ether_ntoa>() и B<ether_aton>() "
"соответственно, и не используют статических буферов."

#. type: Plain text
#: man-pages/man3/ether_aton.3:119
msgid ""
"The structure I<ether_addr> is defined in I<E<lt>net/ethernet.hE<gt>> as:"
msgstr "Структура I<ether_addr> определена в I<E<lt>net/ethernet.hE<gt>>:"

#. type: Plain text
#: man-pages/man3/ether_aton.3:125
#, no-wrap
msgid ""
"struct ether_addr {\n"
"    uint8_t ether_addr_octet[6];\n"
"}\n"
msgstr ""
"struct ether_addr {\n"
"    uint8_t ether_addr_octet[6];\n"
"}\n"

#. type: tbl table
#: man-pages/man3/ether_aton.3:139
#, no-wrap
msgid ""
"B<ether_aton>(),\n"
"B<ether_ntoa>()"
msgstr ""
"B<ether_aton>(),\n"
"B<ether_ntoa>()"

#. type: tbl table
#: man-pages/man3/ether_aton.3:139
#, no-wrap
msgid "MT-Unsafe"
msgstr "MT-Unsafe"

#. type: tbl table
#: man-pages/man3/ether_aton.3:146
#, no-wrap
msgid ""
"B<ether_ntohost>(),\n"
"B<ether_hostton>(),\n"
"B<ether_line>(),\n"
"B<ether_ntoa_r>(),\n"
"B<ether_aton_r>()"
msgstr ""
"B<ether_ntohost>(),\n"
"B<ether_hostton>(),\n"
"B<ether_line>(),\n"
"B<ether_ntoa_r>(),\n"
"B<ether_aton_r>()"

#. type: Plain text
#: man-pages/man3/ether_aton.3:151
msgid "4.3BSD, SunOS."
msgstr "4.3BSD, SunOS."

#.  The fix was presumably commit c0a0f9a32c8baa6ab93d00eb42d92c02e9e146d7
#.  which was in glibc 2.3
#. type: Plain text
#: man-pages/man3/ether_aton.3:157
msgid ""
"In glibc 2.2.5 and earlier, the implementation of B<ether_line>()  is broken."
msgstr "В glibc 2.2.5 и старее реализация B<ether_line>() некорректна."

#. type: Plain text
#: man-pages/man3/ether_aton.3:158
msgid "B<ethers>(5)"
msgstr "B<ethers>(5)"

#. type: TH
#: man-pages/man3/ecvt_r.3:30
#, no-wrap
msgid "ECVT_R"
msgstr "ECVT_R"

#. type: Plain text
#: man-pages/man3/ecvt_r.3:33
msgid ""
"ecvt_r, fcvt_r, qecvt_r, qfcvt_r - convert a floating-point number to a "
"string"
msgstr ""
"ecvt_r, fcvt_r, qecvt_r, qfcvt_r - преобразует число с плавающей запятой в "
"строку"

#. type: Plain text
#: man-pages/man3/ecvt_r.3:39
#, no-wrap
msgid ""
"B<int ecvt_r(double >I<number>B<, int >I<ndigits>B<, int *>I<decpt>B<,>\n"
"B<           int *>I<sign>B<, char *>I<buf>B<, size_t >I<len>B<);>\n"
msgstr ""
"B<int ecvt_r(double >I<number>B<, int >I<ndigits>B<, int *>I<decpt>B<,>\n"
"B<           int *>I<sign>B<, char *>I<buf>B<, size_t >I<len>B<);>\n"

#. type: Plain text
#: man-pages/man3/ecvt_r.3:42
#, no-wrap
msgid ""
"B<int fcvt_r(double >I<number>B<, int >I<ndigits>B<, int *>I<decpt>B<,>\n"
"B<           int *>I<sign>B<, char *>I<buf>B<, size_t >I<len>B<);>\n"
msgstr ""
"B<int fcvt_r(double >I<number>B<, int >I<ndigits>B<, int *>I<decpt>B<,>\n"
"B<           int *>I<sign>B<, char *>I<buf>B<, size_t >I<len>B<);>\n"

#. type: Plain text
#: man-pages/man3/ecvt_r.3:45
#, no-wrap
msgid ""
"B<int qecvt_r(long double >I<number>B<, int >I<ndigits>B<, int *>I<decpt>B<,>\n"
"B<           int *>I<sign>B<, char *>I<buf>B<, size_t >I<len>B<);>\n"
msgstr ""
"B<int qecvt_r(long double >I<number>B<, int >I<ndigits>B<, int *>I<decpt>B<,>\n"
"B<           int *>I<sign>B<, char *>I<buf>B<, size_t >I<len>B<);>\n"

#. type: Plain text
#: man-pages/man3/ecvt_r.3:48
#, no-wrap
msgid ""
"B<int qfcvt_r(long double >I<number>B<, int >I<ndigits>B<, int *>I<decpt>B<,>\n"
"B<           int *>I<sign>B<, char *>I<buf>B<, size_t >I<len>B<);>\n"
msgstr ""
"B<int qfcvt_r(long double >I<number>B<, int >I<ndigits>B<, int *>I<decpt>B<,>\n"
"B<           int *>I<sign>B<, char *>I<buf>B<, size_t >I<len>B<);>\n"

#. type: Plain text
#: man-pages/man3/ecvt_r.3:60
msgid "B<ecvt_r>(), B<fcvt_r>(), B<qecvt_r>(), B<qfcvt_r>():"
msgstr "B<ecvt_r>(), B<fcvt_r>(), B<qecvt_r>(), B<qfcvt_r>():"

#. type: Plain text
#: man-pages/man3/ecvt_r.3:63
#, no-wrap
msgid ""
"/* Glibc since 2.19: */ _DEFAULT_SOURCE\n"
"    || /* Glibc versions E<lt>= 2.19: */ _SVID_SOURCE || _BSD_SOURCE\n"
msgstr ""
"/* начиная с glibc 2.19: */ _DEFAULT_SOURCE\n"
"    || /* в версиях glibc E<lt>= 2.19: */ _SVID_SOURCE || _BSD_SOURCE\n"

#. type: Plain text
#: man-pages/man3/ecvt_r.3:87
msgid ""
"The functions B<ecvt_r>(), B<fcvt_r>(), B<qecvt_r>(), and B<qfcvt_r>()  are "
"identical to B<ecvt>(3), B<fcvt>(3), B<qecvt>(3), and B<qfcvt>(3), "
"respectively, except that they do not return their result in a static "
"buffer, but instead use the supplied I<buf> of size I<len>.  See B<ecvt>(3)  "
"and B<qecvt>(3)."
msgstr ""
"Функции B<ecvt_r>(), B<fcvt_r>(), B<qecvt_r>() и B<qfcvt_r>() идентичны "
"функциям B<ecvt>(3), B<fcvt>(3), B<qecvt>(3) и B<qfcvt>(3), соответственно, "
"за исключением того, что они не возвращают результаты в статическом буфере, "
"а вместо этого используют указанный I<buf> размером I<len>. Смотрите "
"B<ecvt>(3) и B<qecvt>(3)."

#. type: Plain text
#: man-pages/man3/ecvt_r.3:89
msgid "These functions return 0 on success, and -1 otherwise."
msgstr "При успешном выполнении эти функции возвращают 0 и -1 при ошибке."

#. type: tbl table
#: man-pages/man3/ecvt_r.3:100
#, no-wrap
msgid ""
"B<ecvt_r>(),\n"
"B<fcvt_r>(),\n"
msgstr ""
"B<ecvt_r>(),\n"
"B<fcvt_r>(),\n"

#. type: tbl table
#: man-pages/man3/ecvt_r.3:103
#, no-wrap
msgid ""
"B<qecvt_r>(),\n"
"B<qfcvt_r>()"
msgstr ""
"B<qecvt_r>(),\n"
"B<qfcvt_r>()"

#. type: Plain text
#: man-pages/man3/ecvt_r.3:107
msgid "These functions are GNU extensions."
msgstr "Эти функции являются расширениями GNU."

#. type: Plain text
#: man-pages/man3/ecvt_r.3:112
msgid "These functions are obsolete.  Instead, B<sprintf>(3)  is recommended."
msgstr ""
"Данные функции устарели. Вместо них рекомендуется использовать B<sprintf>(3)."

#. type: Plain text
#: man-pages/man3/ecvt_r.3:115
msgid "B<ecvt>(3), B<qecvt>(3), B<sprintf>(3)"
msgstr "B<ecvt>(3), B<qecvt>(3), B<sprintf>(3)"

#. type: TH
#: man-pages/man3/exec.3:41
#, no-wrap
msgid "EXEC"
msgstr "EXEC"

#. type: TH
#: man-pages/man3/exec.3:41
#, no-wrap
msgid "2019-08-02"
msgstr "2019-08-02"

#. type: Plain text
#: man-pages/man3/exec.3:44
msgid "execl, execlp, execle, execv, execvp, execvpe - execute a file"
msgstr ""
"execl, execlp, execle, execv, execvp, execvpe - запуск файла на исполнение"

#. type: Plain text
#: man-pages/man3/exec.3:47
#, no-wrap
msgid "B<#include E<lt>unistd.hE<gt>>\n"
msgstr "B<#include E<lt>unistd.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/exec.3:49
#, no-wrap
msgid "B<extern char **environ;>\n"
msgstr "B<extern char **environ;>\n"

#. type: Plain text
#: man-pages/man3/exec.3:60
#, no-wrap
msgid ""
"B<int execl(const char *>I<pathname>B<, const char *>I<arg>B<, ...>\n"
"B</* (char  *) NULL */);>\n"
"B<int execlp(const char *>I<file>B<, const char *>I<arg>B<, ...>\n"
"B</* (char  *) NULL */);>\n"
"B<int execle(const char *>I<pathname>B<, const char *>I<arg>B<, ...>\n"
"B<                /*, (char *) NULL, char * const >I<envp>B<[] */);>\n"
"B<int execv(const char *>I<pathname>B<, char *const >I<argv>B<[]);>\n"
"B<int execvp(const char *>I<file>B<, char *const >I<argv>B<[]);>\n"
"B<int execvpe(const char *>I<file>B<, char *const >I<argv>B<[],>\n"
"B<                char *const >I<envp>B<[]);>\n"
msgstr ""
"B<int execl(const char *>I<pathname>B<, const char *>I<arg>B<, ...>\n"
"B</* (char  *) NULL */);>\n"
"B<int execlp(const char *>I<file>B<, const char *>I<arg>B<, ...>\n"
"B</* (char  *) NULL */);>\n"
"B<int execle(const char *>I<pathname>B<, const char *>I<arg>B<, ...>\n"
"B<                /*, (char *) NULL, char * const >I<envp>B<[] */);>\n"
"B<int execv(const char *>I<pathname>B<, char *const >I<argv>B<[]);>\n"
"B<int execvp(const char *>I<file>B<, char *const >I<argv>B<[]);>\n"
"B<int execvpe(const char *>I<file>B<, char *const >I<argv>B<[],>\n"
"B<                char *const >I<envp>B<[]);>\n"

#. type: Plain text
#: man-pages/man3/exec.3:69
msgid "B<execvpe>(): _GNU_SOURCE"
msgstr "B<execvpe>(): _GNU_SOURCE"

#. type: Plain text
#: man-pages/man3/exec.3:79
msgid ""
"The B<exec>()  family of functions replaces the current process image with a "
"new process image.  The functions described in this manual page are front-"
"ends for B<execve>(2).  (See the manual page for B<execve>(2)  for further "
"details about the replacement of the current process image.)"
msgstr ""
"Семейство функций B<exec>() заменяет текущий образ процесса новым. Описанные "
"в данной справочной странице функции являются оберткой для B<execve>(2) "
"(подробней о см. замене текущего смотрите в справочной странице "
"B<execve>(2))."

#. type: Plain text
#: man-pages/man3/exec.3:82
msgid ""
"The initial argument for these functions is the name of a file that is to be "
"executed."
msgstr "Первый аргумент этих функций - имя исполняемого файла."

#. type: Plain text
#: man-pages/man3/exec.3:85
msgid ""
"The functions can be grouped based on the letters following the \"exec\" "
"prefix."
msgstr "Функции можно сгруппировать по символам после префикса «exec»."

#. type: SS
#: man-pages/man3/exec.3:85
#, no-wrap
msgid "l - execl(), execlp(), execle()"
msgstr "l - execl(), execlp(), execle()"

#. type: Plain text
#: man-pages/man3/exec.3:103
msgid ""
"The I<const char\\ *arg> and subsequent ellipses can be thought of as "
"I<arg0>, I<arg1>, \\&..., I<argn>.  Together they describe a list of one or "
"more pointers to null-terminated strings that represent the argument list "
"available to the executed program.  The first argument, by convention, "
"should point to the filename associated with the file being executed.  The "
"list of arguments I<must> be terminated by a null pointer, and, since these "
"are variadic functions, this pointer must be cast I<(char\\ *) NULL>."
msgstr ""
"Параметр I<const char\\ *arg> и последующие параметры можно воспринимать как "
"параметры I<arg0>, I<arg1>, \\&..., I<argn>. Все вместе они описывают список "
"из одного или нескольких указателей на строки (заканчивающиеся null), "
"который представляет собой список параметров, доступных исполняемой "
"программе. Первый параметр, по соглашению, должен указывать на имя, "
"ассоциированное с файлом, который надо запустить. Список параметров "
"I<должен> заканчиваться указателем null и, так как это функция с переменным "
"числом аргументов, этот указатель должен приводиться к I<(char\\ *) NULL>."

#. type: Plain text
#: man-pages/man3/exec.3:107
msgid ""
"By contrast with the 'l' functions, the 'v' functions (below) specify the "
"command-line arguments of the executed program as a vector."
msgstr ""
"В отличии от функций «l», функции «v» (далее) передают аргументы командной "
"строки исполняемой программе в виде вектора."

#. type: SS
#: man-pages/man3/exec.3:107
#, no-wrap
msgid "v - execv(), execvp(), execvpe()"
msgstr "v - execv(), execvp(), execvpe()"

#. type: Plain text
#: man-pages/man3/exec.3:118
msgid ""
"The I<char\\ *const argv[]> argument is an array of pointers to null-"
"terminated strings that represent the argument list available to the new "
"program.  The first argument, by convention, should point to the filename "
"associated with the file being executed.  The array of pointers I<must> be "
"terminated by a null pointer."
msgstr ""
"Аргумент I<char\\ *const argv[]> — это массив указателей на строки, "
"заканчивающиеся null, которые представляют список аргументов, доступный "
"новой программе. Первый аргумент, по соглашению, должен указать на имя, "
"ассоциированное с файлом, который необходимо запустить. Массив указателей "
"I<должен> заканчиваться указателем null."

#. type: SS
#: man-pages/man3/exec.3:118
#, no-wrap
msgid "e - execle(), execvpe()"
msgstr "e - execle(), execvpe()"

#. type: Plain text
#: man-pages/man3/exec.3:127
msgid ""
"The environment of the caller is specified via the argument I<envp>.  The "
"I<envp> argument is an array of pointers to null-terminated strings and "
"I<must> be terminated by a null pointer."
msgstr ""
"Окружение вызывающего задаётся через аргумент I<envp>. Аргумент I<envp> — "
"это массив указателей на строки с null в конце, который I<должен> "
"заканчиваться указателем null."

#. type: Plain text
#: man-pages/man3/exec.3:135
msgid ""
"All other B<exec>()  functions (which do not include 'e' in the suffix)  "
"take the environment for the new process image from the external variable "
"I<environ> in the calling process."
msgstr ""
"Все остальные функции B<exec>() (без «e» в суффиксе) строят окружение нового "
"образа процесса из внешней переменной I<environ> вызывающего процесса."

#. type: SS
#: man-pages/man3/exec.3:135
#, no-wrap
msgid "p - execlp(), execvp(), execvpe()"
msgstr "p - execlp(), execvp(), execvpe()"

#. type: Plain text
#: man-pages/man3/exec.3:150
msgid ""
"These functions duplicate the actions of the shell in searching for an "
"executable file if the specified filename does not contain a slash (/) "
"character.  The file is sought in the colon-separated list of directory "
"pathnames specified in the B<PATH> environment variable.  If this variable "
"isn't defined, the path list defaults to a list that includes the "
"directories returned by I<confstr(_CS_PATH)> (which typically returns the "
"value \"/bin:/usr/bin\")  and possibly also the current working directory; "
"see NOTES for further details."
msgstr ""
"Это функции повторяют действия оболочки, относящиеся к поиску исполняемого "
"файла, если указанное имя исполняемого файла не содержит символ черты (/). "
"Путь поиска задаётся в переменной окружения B<PATH> (список каталогов, "
"перечисленных через двоеточие). Если эта переменная не определена, то список "
"по по умолчанию состоит из списка каталогов, возвращаемых "
"I<confstr(_CS_PATH)> (обычно возвращает значение «/bin:/usr/bin») и, "
"возможно, текущего рабочего каталога; подробности смотрите в ЗАМЕЧАНИЯХ."

#. type: Plain text
#: man-pages/man3/exec.3:154
msgid ""
"If the specified filename includes a slash character, then B<PATH> is "
"ignored, and the file at the specified pathname is executed."
msgstr ""
"Если указанное имя файла содержит в себе символ косой черты, переменная "
"B<PATH> будет проигнорирована, и будет запущен файл по указанному пути."

#. type: Plain text
#: man-pages/man3/exec.3:156
msgid "In addition, certain errors are treated specially."
msgstr "Кроме этого, есть отличия в обработке некоторых ошибок."

#. type: Plain text
#: man-pages/man3/exec.3:167
msgid ""
"If permission is denied for a file (the attempted B<execve>(2)  failed with "
"the error B<EACCES>), these functions will continue searching the rest of "
"the search path.  If no other file is found, however, they will return with "
"I<errno> set to B<EACCES>."
msgstr ""
"Если доступ к файлу запрещён (при попытке исполнения B<execve>(2) "
"возвращается ошибка B<EACCES>), то эти функции будут продолжать поиск в "
"оставшихся путях. Однако, если больше никаких файлов не найдено, то они "
"присваивают значение глобальной переменной I<errno> равным B<EACCES>."

#. type: Plain text
#: man-pages/man3/exec.3:176
msgid ""
"If the header of a file isn't recognized (the attempted B<execve>(2)  failed "
"with the error B<ENOEXEC>), these functions will execute the shell (I</bin/"
"sh>)  with the path of the file as its first argument.  (If this attempt "
"fails, no further searching is done.)"
msgstr ""
"Если заголовок файла не распознаётся (при попытке выполнения B<execve>(2) "
"возвращает B<ENOEXEC>), то эти функции запускают оболочку (I</bin/sh>) с "
"полным именем файла в качестве первого параметра (если это тоже приводит к "
"ошибке, то поиск останавливается)."

#. type: Plain text
#: man-pages/man3/exec.3:182
msgid ""
"All other B<exec>()  functions (which do not include 'p' in the suffix)  "
"take as their first argument a (relative or absolute) pathname that "
"identifies the program to be executed."
msgstr ""
"Все остальные функции B<exec>() (без «p» в суффиксе) в качестве первого "
"аргумента используют путь (относительный или абсолютный) к будущей "
"исполняемой программе."

#. type: Plain text
#: man-pages/man3/exec.3:189
msgid ""
"The B<exec>()  functions return only if an error has occurred.  The return "
"value is -1, and I<errno> is set to indicate the error."
msgstr ""
"Функции B<exec>() возвращают значение только при возникновении ошибки. При "
"этом возвращается -1, а I<errno> присваивается код ошибки."

#. type: Plain text
#: man-pages/man3/exec.3:194
msgid ""
"All of these functions may fail and set I<errno> for any of the errors "
"specified for B<execve>(2)."
msgstr ""
"Все функции могут завершиться с ошибкой и присвоить I<errno> значения любых "
"ошибок B<execve>(2)."

#. type: Plain text
#: man-pages/man3/exec.3:198
msgid "The B<execvpe>()  function first appeared in glibc 2.11."
msgstr "Функция B<execvpe>() впервые появилась в glibc 2.11."

#. type: tbl table
#: man-pages/man3/exec.3:210
#, no-wrap
msgid ""
"B<execl>(),\n"
"B<execle>(),\n"
"B<execv>()"
msgstr ""
"B<execl>(),\n"
"B<execle>(),\n"
"B<execv>()"

#. type: tbl table
#: man-pages/man3/exec.3:215
#, no-wrap
msgid ""
"B<execlp>(),\n"
"B<execvp>(),\n"
"B<execvpe>()"
msgstr ""
"B<execlp>(),\n"
"B<execvp>(),\n"
"B<execvpe>()"

#. type: tbl table
#: man-pages/man3/exec.3:215
#, no-wrap
msgid "MT-Safe env"
msgstr "MT-Safe env"

#. type: Plain text
#: man-pages/man3/exec.3:219
msgid "POSIX.1-2001, POSIX.1-2008."
msgstr "POSIX.1-2001, POSIX.1-2008."

#. type: Plain text
#: man-pages/man3/exec.3:223
msgid "The B<execvpe>()  function is a GNU extension."
msgstr "Функция B<execvpe>() является расширением GNU."

#.  glibc commit 1eb8930608705702d5746e5491bab4e4429fcb83
#. type: Plain text
#: man-pages/man3/exec.3:245
msgid ""
"The default search path (used when the environment does not contain the "
"variable B<PATH>)  shows some variation across systems.  It generally "
"includes I</bin> and I</usr/bin> (in that order) and may also include the "
"current working directory.  On some other systems, the current working is "
"included after I</bin> and I</usr/bin>, as an anti-Trojan-horse measure.  "
"The glibc implementation long followed the traditional default where the "
"current working directory is included at the start of the search path.  "
"However, some code refactoring during the development of glibc 2.24 caused "
"the current working directory to be dropped altogether from the default "
"search path.  This accidental behavior change is considered mildly "
"beneficial, and won't be reverted."
msgstr ""
"Путь поиска по умолчанию (используемый, если в окружении отсутствует "
"переменная B<PATH>) в разных системах отличается. Обычно, он содержит I</"
"bin> и I</usr/bin> (в таком порядке), а также может содержать текущий "
"рабочий каталог. В некоторых системах текущий рабочий каталог добавляется "
"после I</bin> и I</usr/bin>, чтобы не запустить подложенную программу "
"«троянского коня». В реализации glibc долгое время придерживались традиции, "
"где текущий рабочий каталог включался в начало пути поиска. Однако, в "
"результате переработки кода при разработке glibc 2.24 в путь поиска по "
"умолчанию текущий рабочий каталог больше не стали добавлять совсем. Такое "
"несущественное изменение посчитали преимуществом и не стали возвращать всё "
"назад."

#. type: Plain text
#: man-pages/man3/exec.3:259
msgid ""
"The behavior of B<execlp>()  and B<execvp>()  when errors occur while "
"attempting to execute the file is historic practice, but has not "
"traditionally been documented and is not specified by the POSIX standard.  "
"BSD (and possibly other systems) do an automatic sleep and retry if "
"B<ETXTBSY> is encountered.  Linux treats it as a hard error and returns "
"immediately."
msgstr ""
"Поведение функций B<execlp>() и B<execvp>() при ошибках во время попыток "
"исполнения файла сложилось исторически, но при этом оно не описано и не "
"определено в стандарте POSIX. В BSD (и, возможно, других системах) "
"выполняется автоматическое ожидание и повтор, если возникает ошибка "
"B<ETXTBSY>. В Linux это воспринимается как невосстановимая ошибка, и она "
"сразу возвращается."

#. type: Plain text
#: man-pages/man3/exec.3:271
msgid ""
"Traditionally, the functions B<execlp>()  and B<execvp>()  ignored all "
"errors except for the ones described above and B<ENOMEM> and B<E2BIG>, upon "
"which they returned.  They now return if any error other than the ones "
"described above occurs."
msgstr ""
"Традиционно, функции B<execlp>() и B<execvp>() игнорировали все ошибки за "
"исключением описанных выше, а также B<ENOMEM> и B<E2BIG>, которые они "
"возвращают. В Linux эти функции возвращают любую ошибку, помимо "
"перечисленных ранее."

#.  https://sourceware.org/bugzilla/show_bug.cgi?id=19534
#. type: Plain text
#: man-pages/man3/exec.3:283
msgid ""
"Before glibc 2.24, B<execl>()  and B<execle>()  employed B<realloc>(3)  "
"internally and were consequently not async-signal-safe, in violation of the "
"requirements of POSIX.1.  This was fixed in glibc 2.24."
msgstr ""
"До glibc 2.24, B<execl>() и B<execle>() использовали B<realloc>(3) и поэтому "
"были не безопасны для асинхронных сигналов, что нарушало требования POSIX.1. "
"Это было исправлено в glibc 2.24."

#. type: SS
#: man-pages/man3/exec.3:283
#, no-wrap
msgid "Architecture-specific details"
msgstr "Специфика некоторых архитектур"

#. type: Plain text
#: man-pages/man3/exec.3:294
msgid ""
"On sparc and sparc64, B<execv>()  is provided as a system call by the kernel "
"(with the prototype shown above)  for compatibility with SunOS.  This "
"function is I<not> employed by the B<execv>()  wrapper function on those "
"architectures."
msgstr ""
"Для совместимости с SunOS на sparc и sparc64, B<execv>() предоставляется как "
"системный вызов ядра (с прототипом, показанным выше). Он I<не> применяется в "
"обёрточной функции B<execv>() на этих архитектурах."

#. type: Plain text
#: man-pages/man3/exec.3:302
msgid ""
"B<sh>(1), B<execve>(2), B<execveat>(2), B<fork>(2), B<ptrace>(2), "
"B<fexecve>(3), B<system>(3), B<environ>(7)"
msgstr ""
"B<sh>(1), B<execve>(2), B<execveat>(2), B<fork>(2), B<ptrace>(2), "
"B<fexecve>(3), B<system>(3), B<environ>(7)"

#. type: TH
#: man-pages/man3/exp.3:36
#, no-wrap
msgid "EXP"
msgstr "EXP"

#. type: Plain text
#: man-pages/man3/exp.3:39
msgid "exp, expf, expl - base-e exponential function"
msgstr "exp, expf, expl - функция вычисления экспоненты"

#. type: Plain text
#: man-pages/man3/exp.3:46
#, no-wrap
msgid ""
"B<double exp(double >I<x>B<);>\n"
"B<float expf(float >I<x>B<);>\n"
"B<long double expl(long double >I<x>B<);>\n"
msgstr ""
"B<double exp(double >I<x>B<);>\n"
"B<float expf(float >I<x>B<);>\n"
"B<long double expl(long double >I<x>B<);>\n"

#. type: Plain text
#: man-pages/man3/exp.3:58
msgid "B<expf>(), B<expl>():"
msgstr "B<expf>(), B<expl>():"

#. type: Plain text
#: man-pages/man3/exp.3:62
#, no-wrap
msgid ""
"_ISOC99_SOURCE || _POSIX_C_SOURCE\\ E<gt>=\\ 200112L\n"
"    || /* Since glibc 2.19: */ _DEFAULT_SOURCE\n"
"    || /* Glibc versions E<lt>= 2.19: */ _BSD_SOURCE || _SVID_SOURCE\n"
msgstr ""
"_ISOC99_SOURCE || _POSIX_C_SOURCE\\ E<gt>=\\ 200112L\n"
"    || /* начиная с glibc 2.19: */ _DEFAULT_SOURCE\n"
"    || /* версии glibc E<lt>= 2.19: */ _BSD_SOURCE || _SVID_SOURCE\n"

#. type: Plain text
#: man-pages/man3/exp.3:68
msgid ""
"These functions return the value of e (the base of natural logarithms) "
"raised to the power of I<x>."
msgstr ""
"Эти функции возвращают значение e (основание натурального логарифма), "
"возведённое в степень I<x>."

#. type: Plain text
#: man-pages/man3/exp.3:71
msgid "On success, these functions return the exponential value of I<x>."
msgstr ""
"При успешном выполнении данные функции возвращают экспоненту от числа I<x>."

#. type: Plain text
#: man-pages/man3/exp.3:76
msgid "If I<x> is a NaN, a NaN is returned."
msgstr "Если I<x> имеет значение NaN, будет возвращено NaN."

#. type: Plain text
#: man-pages/man3/exp.3:81
msgid "If I<x> is positive infinity, positive infinity is returned."
msgstr ""
"Если I<x> стремится к плюс бесконечности, то будет возвращена плюс "
"бесконечность."

#. type: Plain text
#: man-pages/man3/exp.3:86
msgid "If I<x> is negative infinity, +0 is returned."
msgstr "Если I<x> равно минус бесконечности, возвращается +0."

#. type: Plain text
#: man-pages/man3/exp.3:90
msgid "If the result underflows, a range error occurs, and zero is returned."
msgstr ""
"Если в результате исчерпана степень числа, то возникает ошибка диапазона и "
"возвращается ноль."

#. type: Plain text
#: man-pages/man3/exp.3:99
msgid ""
"If the result overflows, a range error occurs, and the functions return "
"+B<HUGE_VAL>, +B<HUGE_VALF>, or +B<HUGE_VALL>, respectively."
msgstr ""
"Если в результате превышена разрядность, то возникает ошибка диапазона и "
"функции возвращают +B<HUGE_VAL>, +B<HUGE_VALF> или +B<HUGE_VALL>, "
"соответственно."

#. type: Plain text
#: man-pages/man3/exp.3:106
msgid "The following errors can occur:"
msgstr "Могут возникать следующие ошибки:"

#. type: TP
#: man-pages/man3/exp.3:106
#, no-wrap
msgid "Range error, overflow"
msgstr "Ошибка диапазона, переполнение"

#. type: Plain text
#: man-pages/man3/exp.3:114
msgid ""
"I<errno> is set to B<ERANGE>.  An overflow floating-point exception "
"(B<FE_OVERFLOW>)  is raised."
msgstr ""
"Значение I<errno> устанавливается в B<ERANGE>. Возникает исключение "
"переполнения плавающей точки (B<FE_OVERFLOW>)."

#. type: TP
#: man-pages/man3/exp.3:114
#, no-wrap
msgid "Range error, underflow"
msgstr "Ошибка диапазона, исчерпана степень"

#. type: Plain text
#: man-pages/man3/exp.3:122
msgid ""
"I<errno> is set to B<ERANGE>.  An underflow floating-point exception "
"(B<FE_UNDERFLOW>)  is raised."
msgstr ""
"Значение I<errno> устанавливается в B<ERANGE>. Возникает исключение "
"исчерпания степени плавающей точки (B<FE_UNDERFLOW>)."

#. type: tbl table
#: man-pages/man3/exp.3:134
#, no-wrap
msgid ""
"B<exp>(),\n"
"B<expf>(),\n"
"B<expl>()"
msgstr ""
"B<exp>(),\n"
"B<expf>(),\n"
"B<expl>()"

#. type: Plain text
#: man-pages/man3/exp.3:143
msgid "The variant returning I<double> also conforms to SVr4, 4.3BSD, C89."
msgstr ""
"Вариант, возвращающий значение типа I<double>, также соответствует SVr4, "
"4.3BSD, C89."

#. type: Plain text
#: man-pages/man3/exp.3:149
msgid ""
"B<cbrt>(3), B<cexp>(3), B<exp10>(3), B<exp2>(3), B<expm1>(3), B<sqrt>(3)"
msgstr ""
"B<cbrt>(3), B<cexp>(3), B<exp10>(3), B<exp2>(3), B<expm1>(3), B<sqrt>(3)"

#. type: TH
#: man-pages/man3/envz_add.3:10
#, no-wrap
msgid "ENVZ_ADD"
msgstr "ENVZ_ADD"

#. type: Plain text
#: man-pages/man3/envz_add.3:14
msgid ""
"envz_add, envz_entry, envz_get, envz_merge, envz_remove, envz_strip - "
"environment string support"
msgstr ""
"envz_add, envz_entry, envz_get, envz_merge, envz_remove, envz_strip - "
"поддержка строк окружения"

#. type: Plain text
#: man-pages/man3/envz_add.3:17
#, no-wrap
msgid "B<#include E<lt>envz.hE<gt>>\n"
msgstr "B<#include E<lt>envz.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/envz_add.3:20
#, no-wrap
msgid ""
"B<error_t envz_add(char **>I<envz>B<, size_t *>I<envz_len>B<,>\n"
"B<                 const char *>I<name>B<, const char *>I<value>B<);>\n"
msgstr ""
"B<error_t envz_add(char **>I<envz>B<, size_t *>I<envz_len>B<,>\n"
"B<                 const char *>I<name>B<, const char *>I<value>B<);>\n"

#. type: Plain text
#: man-pages/man3/envz_add.3:23
#, no-wrap
msgid "B<char *envz_entry(const char *>I<envz>B<, size_t >I<envz_len>B<, const char *>I<name>B<);>\n"
msgstr "B<char *envz_entry(const char *>I<envz>B<, size_t >I<envz_len>B<, const char *>I<name>B<);>\n"

#. type: Plain text
#: man-pages/man3/envz_add.3:26
#, no-wrap
msgid "B<char *envz_get(const char *>I<envz>B<, size_t >I<envz_len>B<, const char *>I<name>B<);>\n"
msgstr "B<char *envz_get(const char *>I<envz>B<, size_t >I<envz_len>B<, const char *>I<name>B<);>\n"

#. type: Plain text
#: man-pages/man3/envz_add.3:30
#, no-wrap
msgid ""
"B<error_t envz_merge(char **>I<envz>B<, size_t *>I<envz_len>B<,>\n"
"B<                   const char *>I<envz2>B<, size_t >I<envz2_len>B<, int >I<override>B<);>\n"
msgstr ""
"B<error_t envz_merge(char **>I<envz>B<, size_t *>I<envz_len>B<,>\n"
"B<                   const char *>I<envz2>B<, size_t >I<envz2_len>B<, int >I<override>B<);>\n"

#. type: Plain text
#: man-pages/man3/envz_add.3:33
#, no-wrap
msgid "B<void envz_remove(char **>I<envz>B<, size_t *>I<envz_len>B<, const char *>I<name>B<);>\n"
msgstr "B<void envz_remove(char **>I<envz>B<, size_t *>I<envz_len>B<, const char *>I<name>B<);>\n"

#. type: Plain text
#: man-pages/man3/envz_add.3:35
#, no-wrap
msgid "B<void envz_strip(char **>I<envz>B<, size_t *>I<envz_len>B<);>\n"
msgstr "B<void envz_strip(char **>I<envz>B<, size_t *>I<envz_len>B<);>\n"

#. type: Plain text
#: man-pages/man3/envz_add.3:38
msgid "These functions are glibc-specific."
msgstr "Эти функции есть только в glibc."

#. type: Plain text
#: man-pages/man3/envz_add.3:48
msgid ""
"An argz vector is a pointer to a character buffer together with a length, "
"see B<argz_add>(3).  An envz vector is a special argz vector, namely one "
"where the strings have the form \"name=value\".  Everything after the first "
"\\(aq=\\(aq is considered to be the value.  If there is no \\(aq=\\(aq, the "
"value is taken to be NULL.  (While the value in case of a trailing \\(aq="
"\\(aq is the empty string \"\".)"
msgstr ""
"Вектор argz представляет собой указатель на символьный буфер и его длину "
"(смотрите B<argz_add>(3)). Вектор envz является особым вектором argz, в нём "
"содержатся строки вида «имя=значение». Всё, что расположено за первым \\(aq="
"\\(aq, считается значением. Если \\(aq=\\(aq отсутствует, то значение "
"считается равным NULL (если \\(aq=\\(aq указано в конце, то значение равно "
"пустой строке \"\")."

#. type: Plain text
#: man-pages/man3/envz_add.3:50
msgid "These functions are for handling envz vectors."
msgstr "Эти функции предназначены для работы с векторами envz."

#. type: Plain text
#: man-pages/man3/envz_add.3:69
msgid ""
"B<envz_add>()  adds the string \"I<name>=I<value>\" (in case I<value> is non-"
"NULL) or \"I<name>\" (in case I<value> is NULL) to the envz vector (I<*envz>,"
"\\ I<*envz_len>)  and updates I<*envz> and I<*envz_len>.  If an entry with "
"the same I<name> existed, it is removed."
msgstr ""
"Функция B<envz_add>() добавляет строку \"I<name>=I<value>\" (если I<name> не "
"равно NULL) или \"I<name>\" (если I<value> равно NULL) в вектор envz "
"(I<*envz>,\\ I<*envz_len>) и обновляет I<*envz> и I<*envz_len>. Если запись "
"с таким значением I<name> уже существует, то она удаляется."

#. type: Plain text
#: man-pages/man3/envz_add.3:76
msgid ""
"B<envz_entry>()  looks for I<name> in the envz vector (I<envz>,\\ "
"I<envz_len>)  and returns the entry if found, or NULL if not."
msgstr ""
"Функция B<envz_entry>() ищет значение I<name> в векторе envz (I<envz>,\\ "
"I<envz_len>) и возвращает запись, если такое имя найдено, и NULL, если не "
"найдено."

#. type: Plain text
#: man-pages/man3/envz_add.3:87
msgid ""
"B<envz_get>()  looks for I<name> in the envz vector (I<envz>,\\ "
"I<envz_len>)  and returns the value if found, or NULL if not.  (Note that "
"the value can also be NULL, namely when there is an entry for I<name> "
"without \\(aq=\\(aq sign.)"
msgstr ""
"Функция B<envz_get>() ищет значение I<name> в векторе envz (I<envz>,\\ "
"I<envz_len>) и возвращает значение, если такое имя найдено, и NULL, если не "
"найдено (заметим, что значение само по себе может быть равно NULL, особенно, "
"если есть запись для I<name> без знака \\(aq=\\(aq)."

#. type: Plain text
#: man-pages/man3/envz_add.3:102
msgid ""
"B<envz_merge>()  adds each entry in I<envz2> to I<*envz>, as if with "
"B<envz_add>().  If I<override> is true, then values in I<envz2> will "
"supersede those with the same name in I<*envz>, otherwise not."
msgstr ""
"Функция B<envz_merge>() добавляет все записи из I<envz2> в I<*envz>, как "
"если бы это делалось с помощью B<envz_add>(). Если значение I<override> "
"истинно, то значения в I<envz2> будут заменять значения с такими же именами "
"в I<*envz>, иначе — нет."

#. type: Plain text
#: man-pages/man3/envz_add.3:109
msgid ""
"B<envz_remove>()  removes the entry for I<name> from (I<*envz>,\\ "
"I<*envz_len>)  if there was one."
msgstr ""
"Функция B<envz_remove>() удаляет запись для I<name> из (I<*envz>,\\ "
"I<*envz_len>), если она есть."

#. type: Plain text
#: man-pages/man3/envz_add.3:112
msgid "B<envz_strip>()  removes all entries with value NULL."
msgstr "Функция B<envz_strip>() удаляет все записи со значением NULL."

#. type: Plain text
#: man-pages/man3/envz_add.3:118
msgid ""
"All envz functions that do memory allocation have a return type of "
"I<error_t>, and return 0 for success, and B<ENOMEM> if an allocation error "
"occurs."
msgstr ""
"Все функции envz, в которых происходит выделение памяти, возвращают "
"результат, имеющий тип I<error_t>: 0 — при успешном выполнении и B<ENOMEM> — "
"при ошибке выделения памяти."

#. type: tbl table
#: man-pages/man3/envz_add.3:129
#, no-wrap
msgid ""
"B<envz_add>(),\n"
"B<envz_entry>(),\n"
msgstr ""
"B<envz_add>(),\n"
"B<envz_entry>(),\n"

#. type: tbl table
#: man-pages/man3/envz_add.3:132
#, no-wrap
msgid ""
"B<envz_get>(),\n"
"B<envz_merge>(),\n"
msgstr ""
"B<envz_get>(),\n"
"B<envz_merge>(),\n"

#. type: tbl table
#: man-pages/man3/envz_add.3:135
#, no-wrap
msgid ""
"B<envz_remove>(),\n"
"B<envz_strip>()"
msgstr ""
"B<envz_remove>(),\n"
"B<envz_strip>()"

#. type: Plain text
#: man-pages/man3/envz_add.3:141
msgid "These functions are a GNU extension.  Handle with care."
msgstr "Данные функции являются расширениями GNU. Используйте с осторожностью."

#. type: Plain text
#: man-pages/man3/envz_add.3:146
#, no-wrap
msgid ""
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>envz.hE<gt>\n"
msgstr ""
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>envz.hE<gt>\n"

#. type: Plain text
#: man-pages/man3/envz_add.3:152
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[], char *envp[])\n"
"{\n"
"    int i, e_len = 0;\n"
"    char *str;\n"
msgstr ""
"int\n"
"main(int argc, char *argv[], char *envp[])\n"
"{\n"
"    int i, e_len = 0;\n"
"    char *str;\n"

#. type: Plain text
#: man-pages/man3/envz_add.3:155
#, no-wrap
msgid ""
"    for (i = 0; envp[i] != NULL; i++)\n"
"        e_len += strlen(envp[i]) + 1;\n"
msgstr ""
"    for (i = 0; envp[i] != NULL; i++)\n"
"        e_len += strlen(envp[i]) + 1;\n"

#. type: Plain text
#: man-pages/man3/envz_add.3:162
#, no-wrap
msgid ""
"    str = envz_entry(*envp, e_len, \"HOME\");\n"
"    printf(\"%s\\en\", str);\n"
"    str = envz_get(*envp, e_len, \"HOME\");\n"
"    printf(\"%s\\en\", str);\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""
"    str = envz_entry(*envp, e_len, \"HOME\");\n"
"    printf(\"%s\\en\", str);\n"
"    str = envz_get(*envp, e_len, \"HOME\");\n"
"    printf(\"%s\\en\", str);\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"

#. type: Plain text
#: man-pages/man3/envz_add.3:164
msgid "B<argz_add>(3)"
msgstr "B<argz_add>(3)"

#. type: TH
#: man-pages/man3/error.3:27
#, no-wrap
msgid "ERROR"
msgstr "ERROR"

#. type: Plain text
#: man-pages/man3/error.3:31
msgid ""
"error, error_at_line, error_message_count, error_one_per_line, "
"error_print_progname - glibc error reporting functions"
msgstr ""
"error, error_at_line, error_message_count, error_one_per_line, "
"error_print_progname - функции вывода ошибок glibc"

#. type: Plain text
#: man-pages/man3/error.3:34
#, no-wrap
msgid "B<#include E<lt>error.hE<gt>>\n"
msgstr "B<#include E<lt>error.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/error.3:36
#, no-wrap
msgid "B<void error(int >I<status>B<, int >I<errnum>B<, const char *>I<format>B<, ...);>\n"
msgstr "B<void error(int >I<status>B<, int >I<errnum>B<, const char *>I<format>B<, ...);>\n"

#. type: Plain text
#: man-pages/man3/error.3:39
#, no-wrap
msgid ""
"B<void error_at_line(int >I<status>B<, int >I<errnum>B<, const char *>I<filename>B<,>\n"
"B<                   unsigned int >I<linenum>B<, const char *>I<format>B<, ...);>\n"
msgstr ""
"B<void error_at_line(int >I<status>B<, int >I<errnum>B<, const char *>I<filename>B<,>\n"
"B<                   unsigned int >I<linenum>B<, const char *>I<format>B<, ...);>\n"

#. type: Plain text
#: man-pages/man3/error.3:41
#, no-wrap
msgid "B<extern unsigned int >I<error_message_count>B<;>\n"
msgstr "B<extern unsigned int >I<error_message_count>B<;>\n"

#. type: Plain text
#: man-pages/man3/error.3:43
#, no-wrap
msgid "B<extern int >I<error_one_per_line>B<;>\n"
msgstr "B<extern int >I<error_one_per_line>B<;>\n"

#. type: Plain text
#: man-pages/man3/error.3:45
#, no-wrap
msgid "B<extern void (*>I<error_print_progname>B<) (void);>\n"
msgstr "B<extern void (*>I<error_print_progname>B<) (void);>\n"

#. type: Plain text
#: man-pages/man3/error.3:64
msgid ""
"B<error>()  is a general error-reporting function.  It flushes I<stdout>, "
"and then outputs to I<stderr> the program name, a colon and a space, the "
"message specified by the B<printf>(3)-style format string I<format>, and, if "
"I<errnum> is nonzero, a second colon and a space followed by the string "
"given by I<strerror(errnum)>.  Any arguments required for I<format> should "
"follow I<format> in the argument list.  The output is terminated by a "
"newline character."
msgstr ""
"Функция B<error>() предназначена для сообщения об ошибках разного рода. Она "
"сбрасывает I<stdout>, а затем выводит в I<stderr> имя программы, двоеточие, "
"пробел, сообщение, задаваемое строкой I<format> в формате B<printf>(3) и, "
"если значение I<errnum> не равно нулю, второе двоеточие и пробел, за "
"которыми выводится строка, возвращаемая вызовом I<strerror(errnum)>. Все "
"аргументы, необходимые для I<format>, должны указываться в списке аргументов "
"после I<format>. Вывод завершается символом новой строки."

#. type: Plain text
#: man-pages/man3/error.3:75
msgid ""
"The program name printed by B<error>()  is the value of the global variable "
"B<program_invocation_name>(3).  I<program_invocation_name> initially has the "
"same value as I<main>()'s I<argv[0]>.  The value of this variable can be "
"modified to change the output of B<error>()."
msgstr ""
"Имя программы, выводимое B<error>(), представляет собой значение глобальной "
"переменной B<program_invocation_name>(3). Первоначально, переменная "
"I<program_invocation_name> имеет то же значение что и I<argv[0]> в функции "
"I<main>(). Значение этой переменной может быть изменено для показа в выводе "
"B<error>()."

#. type: Plain text
#: man-pages/man3/error.3:81
msgid ""
"If I<status> has a nonzero value, then B<error>()  calls B<exit>(3)  to "
"terminate the program using the given value as the exit status."
msgstr ""
"Если значение I<status> не равно нулю, то B<error>() вызывает B<exit>(3) для "
"завершения программы и это значение используется как код выхода."

#. type: Plain text
#: man-pages/man3/error.3:101
msgid ""
"The B<error_at_line>()  function is exactly the same as B<error>(), except "
"for the addition of the arguments I<filename> and I<linenum>.  The output "
"produced is as for B<error>(), except that after the program name are "
"written: a colon, the value of I<filename>, a colon, and the value of "
"I<linenum>.  The preprocessor values B<__LINE__> and B<__FILE__> may be "
"useful when calling B<error_at_line>(), but other values can also be used.  "
"For example, these arguments could refer to a location in an input file."
msgstr ""
"Функция B<error_at_line>() делает то же что и B<error>(), но имеет "
"дополнительные аргументы I<filename> и I<linenum>. Вывод аналогичен "
"B<error>(), но после имени программы записывается: двоеточие, значение "
"I<filename>, двоеточие и значение I<linenum>. При вызове B<error_at_line>() "
"могут быть полезны значения препроцессора B<__LINE__> и B<__FILE__>, но "
"можно использовать и другие значения. Например, эти аргументы могут "
"указывать на место во входном файле."

#. type: Plain text
#: man-pages/man3/error.3:108
msgid ""
"If the global variable I<error_one_per_line> is set nonzero, a sequence of "
"B<error_at_line>()  calls with the same value of I<filename> and I<linenum> "
"will result in only one message (the first) being output."
msgstr ""
"Если значение глобальной переменной I<error_one_per_line> не равно нулю, то "
"последовательность вызовов B<error_at_line>() с тем же значением I<filename> "
"и I<linenum> выводит только одно сообщение (первое)."

#. type: Plain text
#: man-pages/man3/error.3:114
msgid ""
"The global variable I<error_message_count> counts the number of messages "
"that have been output by B<error>()  and B<error_at_line>()."
msgstr ""
"В глобальной переменной I<error_message_count> подсчитывается количество "
"сообщений, которые были показаны с помощью B<error>() и B<error_at_line>()."

#. type: Plain text
#: man-pages/man3/error.3:121
msgid ""
"If the global variable I<error_print_progname> is assigned the address of a "
"function (i.e., is not NULL), then that function is called instead of "
"prefixing the message with the program name and colon.  The function should "
"print a suitable string to I<stderr>."
msgstr ""
"Если глобальной переменной I<error_print_progname> назначен адрес функции (т."
"е., её значение не равно NULL), то вместо показа в начале сообщения имени "
"программы и двоеточия вызывается эта функция. Функция должна вывести нужную "
"строку в I<stderr>."

#. type: tbl table
#: man-pages/man3/error.3:132
#, no-wrap
msgid "B<error>()"
msgstr "B<error>()"

#. type: tbl table
#: man-pages/man3/error.3:135
#, no-wrap
msgid "B<error_at_line>()"
msgstr "B<error_at_line>()"

#. type: tbl table
#: man-pages/man3/error.3:137
#, no-wrap
msgid "MT-Unsafe\\ race: error_at_line/error_one_per_line locale"
msgstr "MT-Unsafe\\ race: error_at_line/error_one_per_line locale"

#. type: Plain text
#: man-pages/man3/error.3:156
msgid ""
"The internal I<error_one_per_line> variable is accessed (without any form of "
"synchronization, but since it's an I<int> used once, it should be safe "
"enough) and, if I<error_one_per_line> is set nonzero, the internal static "
"variables (not exposed to users)  used to hold the last printed filename and "
"line number are accessed and modified without synchronization; the update is "
"not atomic and it occurs before disabling cancellation, so it can be "
"interrupted only after one of the two variables is modified.  After that, "
"B<error_at_line>()  is very much like B<error>()."
msgstr ""
"Доступна внутренняя переменная I<error_one_per_line> (нет никакой "
"синхронизации, но так как этот I<int> используется только один раз, это не "
"проблема) и, если I<error_one_per_line> установлена в ненулевое значение, то "
"становятся доступны для чтения и изменения без синхронизации внутренние "
"статические переменные (невидимые пользователю), которые используются для "
"хранения последнего напечатанного имени файла и номера строки; обновление не "
"атомарно и происходит прежде, чем отключить отмену, поэтому может быть "
"прервано только после того, как одна из этих двух переменных изменена. После "
"этого B<error_at_line>() очень похожа на B<error>()."

#. type: Plain text
#: man-pages/man3/error.3:159
msgid ""
"These functions and variables are GNU extensions, and should not be used in "
"programs intended to be portable."
msgstr ""
"Эти функции и глобальные переменные являются расширениями GNU, и они не "
"должны использоваться в переносимых программах."

#. type: Plain text
#: man-pages/man3/error.3:165
msgid ""
"B<err>(3), B<errno>(3), B<exit>(3), B<perror>(3), "
"B<program_invocation_name>(3), B<strerror>(3)"
msgstr ""
"B<err>(3), B<errno>(3), B<exit>(3), B<perror>(3), "
"B<program_invocation_name>(3), B<strerror>(3)"

#. type: TH
#: man-pages/man3/errno.3:31
#, no-wrap
msgid "ERRNO"
msgstr "ERRNO"

#. type: Plain text
#: man-pages/man3/errno.3:34
msgid "errno - number of last error"
msgstr "errno - код последней ошибки"

#. .PP
#. .BI "extern int " errno ;
#. type: Plain text
#: man-pages/man3/errno.3:38
msgid "B<#include E<lt>errno.hE<gt>>"
msgstr "B<#include E<lt>errno.hE<gt>>"

#. type: Plain text
#: man-pages/man3/errno.3:46
msgid ""
"The I<E<lt>errno.hE<gt>> header file defines the integer variable I<errno>, "
"which is set by system calls and some library functions in the event of an "
"error to indicate what went wrong."
msgstr ""
"В заголовочном файле I<E<lt>errno.hE<gt>> определяется целочисленная "
"переменная I<errno>, которая используется системными вызовами и некоторыми "
"библиотечными функциями при ошибках для указания того, что именно произошло."

#. type: SS
#: man-pages/man3/errno.3:46
#, no-wrap
msgid "errno"
msgstr "errno"

#. type: Plain text
#: man-pages/man3/errno.3:60
msgid ""
"The value in I<errno> is significant only when the return value of the call "
"indicated an error (i.e., -1 from most system calls; -1 or NULL from most "
"library functions); a function that succeeds I<is> allowed to change "
"I<errno>.  The value of I<errno> is never set to zero by any system call or "
"library function."
msgstr ""
"Значение I<errno> имеет смысл только тогда, когда вызов возвратил ошибку (а "
"именно: -1 — для большинства системных вызовов; NULL — для большинства "
"библиотечных функций); при успешном выполнении функции также I<могут> менять "
"значение I<errno>. Системные вызовы и библиотечные функции никогда не "
"присваивают I<errno> значение нуля."

#. type: Plain text
#: man-pages/man3/errno.3:72
msgid ""
"For some system calls and library functions (e.g., B<getpriority>(2)), -1 is "
"a valid return on success.  In such cases, a successful return can be "
"distinguished from an error return by setting I<errno> to zero before the "
"call, and then, if the call returns a status that indicates that an error "
"may have occurred, checking to see if I<errno> has a nonzero value."
msgstr ""
"Некоторые системные вызовы или библиотечные функции (например, "
"B<getpriority>(2)), при успешном выполнении возвращают -1. В этих случаях "
"успешность выполнения можно отличить от ошибки присвоив I<errno> значение "
"нуля перед вызовом, и затем, если вызов вернул состояние, которое может "
"указывать на ошибку, проверить, равно ли I<errno> ненулевому значению."

#. type: Plain text
#: man-pages/man3/errno.3:84
msgid ""
"I<errno> is defined by the ISO C standard to be a modifiable lvalue of type "
"I<int>, and must not be explicitly declared; I<errno> may be a macro.  "
"I<errno> is thread-local; setting it in one thread does not affect its value "
"in any other thread."
msgstr ""
"Переменная I<errno> определена в стандарте ISO C как изменяемое lvalue "
"I<int> и не объявляемая явно; I<errno> может быть и макросом. Переменная "
"I<errno> является локальным значением нити; её изменение в одной нити не "
"влияет на её значение в другой нити."

#. type: SS
#: man-pages/man3/errno.3:84
#, no-wrap
msgid "Error numbers and names"
msgstr "Номера и имена ошибок"

#. type: Plain text
#: man-pages/man3/errno.3:91
msgid ""
"Valid error numbers are all positive numbers.  The I<E<lt>errno.hE<gt>> "
"header file defines symbolic names for each of the possible error numbers "
"that may appear in I<errno>."
msgstr ""
"Все положительные числа считаются допустимыми номерами ошибок. В "
"заголовочном файле I<E<lt>errno.hE<gt>> определены символические имена для "
"каждого номера возможной ошибки, который может появиться в I<errno>."

#. type: Plain text
#: man-pages/man3/errno.3:98
msgid ""
"All the error names specified by POSIX.1 must have distinct values, with the "
"exception of B<EAGAIN> and B<EWOULDBLOCK>, which may be the same."
msgstr ""
"Всем названиям ошибок, определённым в POSIX.1, должны соответствовать разные "
"значения, за исключением B<EAGAIN> и B<EWOULDBLOCK>, которые могут быть "
"одинаковыми."

#. type: Plain text
#: man-pages/man3/errno.3:110
msgid ""
"The error numbers that correspond to each symbolic name vary across UNIX "
"systems, and even across different architectures on Linux.  Therefore, "
"numeric values are not included as part of the list of error names below.  "
"The B<perror>(3)  and B<strerror>(3)  functions can be used to convert these "
"names to corresponding textual error messages."
msgstr ""
"В разных системах UNIX символическим именам ошибок назначены разные номера, "
"и это верно даже в Linux для разных архитектур. Поэтому числовые значение не "
"указаны в представленном далее списке имён ошибок. Для преобразования этих "
"имён в текстовые сообщения об ошибках можно использовать функции "
"B<perror>(3) и B<strerror>(3)."

#. type: Plain text
#: man-pages/man3/errno.3:118
msgid ""
"On any particular Linux system, one can obtain a list of all symbolic error "
"names and the corresponding error numbers using the B<errno>(1)  command "
"(part of the I<moreutils> package):"
msgstr ""
"В любой системе Linux можно получить список всех символических имён ошибок и "
"соответствующие им номера с помощью команды B<errno>(1)) (является частью "
"пакета I<moreutils>):"

#. type: Plain text
#: man-pages/man3/errno.3:128
#, no-wrap
msgid ""
"$ B<errno -l>\n"
"EPERM 1 Operation not permitted\n"
"ENOENT 2 No such file or directory\n"
"ESRCH 3 No such process\n"
"EINTR 4 Interrupted system call\n"
"EIO 5 Input/output error\n"
"\\&...\n"
msgstr ""
"$ B<errno -l>\n"
"EPERM 1 Операция не позволена\n"
"ENOENT 2 Нет такого файла или каталога\n"
"ESRCH 3 Нет такого процесса\n"
"EINTR 4 Прерван системный вызов\n"
"EIO 5 Ошибка ввода/вывода\n"
"\\&...\n"

#. type: Plain text
#: man-pages/man3/errno.3:136
msgid ""
"The B<errno>(1)  command can also be used to look up individual error "
"numbers and names, and to search for errors using strings from the error "
"description, as in the following examples:"
msgstr ""
"Команду B<errno>(1) также можно использовать для поиска ошибок по имени или "
"номеру, а также по строке, входящей в описание ошибки:"

#. type: Plain text
#: man-pages/man3/errno.3:145
#, no-wrap
msgid ""
"$ B<errno 2>\n"
"ENOENT 2 No such file or directory\n"
"$ B<errno ESRCH>\n"
"ESRCH 3 No such process\n"
"$ B<errno -s permission>\n"
"EACCES 13 Permission denied\n"
msgstr ""
"$ B<errno 2>\n"
"ENOENT 2 Нет такого файла или каталога\n"
"$ B<errno ESRCH>\n"
"ESRCH 3 Нет такого процесса\n"
"$ B<errno -s permission>\n"
"EACCES 13 Отказано в доступе\n"

#.  POSIX.1 (2001 edition) lists the following symbolic error names.  Of
#.  these, \fBEDOM\fP and \fBERANGE\fP are in the ISO C standard.  ISO C
#.  Amendment 1 defines the additional error number \fBEILSEQ\fP for
#.  coding errors in multibyte or wide characters.
#. type: SS
#: man-pages/man3/errno.3:153
#, no-wrap
msgid "List of error names"
msgstr "Список имён ошибок"

#. type: Plain text
#: man-pages/man3/errno.3:156
msgid ""
"In the list of the symbolic error names below, various names are marked as "
"follows:"
msgstr ""
"В представленном далее списки символических имён ошибок у некоторых есть "
"некоторые примечания:"

#. type: Plain text
#: man-pages/man3/errno.3:160
msgid ""
"I<POSIX.1-2001>: The name is defined by POSIX.1-2001, and is defined in "
"later POSIX.1 versions, unless otherwise indicated."
msgstr ""
"I<POSIX.1-2001>: Имя определено в POSIX.1-2001, а также, если не указано "
"обратного, в новых версиях POSIX.1."

#. type: Plain text
#: man-pages/man3/errno.3:164
msgid ""
"I<POSIX.1-2008>: The name is defined in POSIX.1-2008, but was not present in "
"earlier POSIX.1 standards."
msgstr ""
"I<POSIX.1-2008>: Имя определено в POSIX.1-2008, но отсутствует в более "
"старых версиях POSIX.1."

#. type: Plain text
#: man-pages/man3/errno.3:168
msgid ""
"I<C99>: The name is defined by C99.  Below is a list of the symbolic error "
"names that are defined on Linux:"
msgstr ""
"I<C99>: Имя определено в C99. Ниже представлен список символических имён "
"ошибок, определённых в Linux:"

#. type: Plain text
#: man-pages/man3/errno.3:171
msgid "Argument list too long (POSIX.1-2001)."
msgstr "Слишком длинный список параметров (POSIX.1-2001)."

#. type: Plain text
#: man-pages/man3/errno.3:174
msgid "Permission denied (POSIX.1-2001)."
msgstr "Доступ запрещён (POSIX.1-2001)."

#. type: TP
#: man-pages/man3/errno.3:174
#, no-wrap
msgid "B<EADDRINUSE>"
msgstr "B<EADDRINUSE>"

#. type: Plain text
#: man-pages/man3/errno.3:177
msgid "Address already in use (POSIX.1-2001)."
msgstr "Адрес уже используется (POSIX.1-2001)."

#. type: TP
#: man-pages/man3/errno.3:177
#, no-wrap
msgid "B<EADDRNOTAVAIL>"
msgstr "B<EADDRNOTAVAIL>"

#.  EADV is only an error on HURD(?)
#. type: Plain text
#: man-pages/man3/errno.3:181
msgid "Address not available (POSIX.1-2001)."
msgstr "Адрес недоступен (POSIX.1-2001)."

#. type: TP
#: man-pages/man3/errno.3:181
#, no-wrap
msgid "B<EAFNOSUPPORT>"
msgstr "B<EAFNOSUPPORT>"

#. type: Plain text
#: man-pages/man3/errno.3:184
msgid "Address family not supported (POSIX.1-2001)."
msgstr "Семейство адресов не поддерживается (POSIX.1-2001)."

#. type: TP
#: man-pages/man3/errno.3:184
#, no-wrap
msgid "B<EAGAIN>"
msgstr "B<EAGAIN>"

#. type: Plain text
#: man-pages/man3/errno.3:189
msgid ""
"Resource temporarily unavailable (may be the same value as B<EWOULDBLOCK>)  "
"(POSIX.1-2001)."
msgstr ""
"Ресурс временно недоступен (значение может быть равным B<EWOULDBLOCK>) "
"(POSIX.1-2001)."

#. type: TP
#: man-pages/man3/errno.3:189
#, no-wrap
msgid "B<EALREADY>"
msgstr "B<EALREADY>"

#. type: Plain text
#: man-pages/man3/errno.3:192
msgid "Connection already in progress (POSIX.1-2001)."
msgstr "Соединение уже выполняется (POSIX.1-2001)."

#. type: TP
#: man-pages/man3/errno.3:192
#, no-wrap
msgid "B<EBADE>"
msgstr "B<EBADE>"

#. type: Plain text
#: man-pages/man3/errno.3:195
msgid "Invalid exchange."
msgstr "Некорректный обмен."

#. type: Plain text
#: man-pages/man3/errno.3:198
msgid "Bad file descriptor (POSIX.1-2001)."
msgstr "Неправильный дескриптор файла (POSIX.1-2001)."

#. type: TP
#: man-pages/man3/errno.3:198
#, no-wrap
msgid "B<EBADFD>"
msgstr "B<EBADFD>"

#. type: Plain text
#: man-pages/man3/errno.3:201
msgid "File descriptor in bad state."
msgstr "Некорректное состояние дескриптора файла."

#. type: TP
#: man-pages/man3/errno.3:201
#, no-wrap
msgid "B<EBADMSG>"
msgstr "B<EBADMSG>"

#. type: Plain text
#: man-pages/man3/errno.3:204
msgid "Bad message (POSIX.1-2001)."
msgstr "Неправильное сообщение (POSIX.1-2001)."

#. type: TP
#: man-pages/man3/errno.3:204
#, no-wrap
msgid "B<EBADR>"
msgstr "B<EBADR>"

#. type: Plain text
#: man-pages/man3/errno.3:207
msgid "Invalid request descriptor."
msgstr "Неверный дескриптор запроса."

#. type: TP
#: man-pages/man3/errno.3:207
#, no-wrap
msgid "B<EBADRQC>"
msgstr "B<EBADRQC>"

#. type: Plain text
#: man-pages/man3/errno.3:210
msgid "Invalid request code."
msgstr "Неверный код запроса."

#. type: TP
#: man-pages/man3/errno.3:210
#, no-wrap
msgid "B<EBADSLT>"
msgstr "B<EBADSLT>"

#.  EBFONT is defined but appears not to be used by kernel or glibc.
#. type: Plain text
#: man-pages/man3/errno.3:214
msgid "Invalid slot."
msgstr "Некорректный слот."

#. type: TP
#: man-pages/man3/errno.3:214
#, no-wrap
msgid "B<EBUSY>"
msgstr "B<EBUSY>"

#. type: Plain text
#: man-pages/man3/errno.3:217
msgid "Device or resource busy (POSIX.1-2001)."
msgstr "Устройство или ресурс заняты (POSIX.1-2001)."

#. type: TP
#: man-pages/man3/errno.3:217
#, no-wrap
msgid "B<ECANCELED>"
msgstr "B<ECANCELED>"

#. type: Plain text
#: man-pages/man3/errno.3:220
msgid "Operation canceled (POSIX.1-2001)."
msgstr "Операция отменена (POSIX.1-2001)."

#. type: TP
#: man-pages/man3/errno.3:220
#, no-wrap
msgid "B<ECHILD>"
msgstr "B<ECHILD>"

#. type: Plain text
#: man-pages/man3/errno.3:223
msgid "No child processes (POSIX.1-2001)."
msgstr "Отсутствуют дочерние процессы (POSIX.1-2001)."

#. type: TP
#: man-pages/man3/errno.3:223
#, no-wrap
msgid "B<ECHRNG>"
msgstr "B<ECHRNG>"

#. type: Plain text
#: man-pages/man3/errno.3:226
msgid "Channel number out of range."
msgstr "Номер канала вне диапазона."

#. type: TP
#: man-pages/man3/errno.3:226
#, no-wrap
msgid "B<ECOMM>"
msgstr "B<ECOMM>"

#. type: Plain text
#: man-pages/man3/errno.3:229
msgid "Communication error on send."
msgstr "Ошибка связи при отправке."

#. type: TP
#: man-pages/man3/errno.3:229
#, no-wrap
msgid "B<ECONNABORTED>"
msgstr "B<ECONNABORTED>"

#. type: Plain text
#: man-pages/man3/errno.3:232
msgid "Connection aborted (POSIX.1-2001)."
msgstr "Соединение было прервано (POSIX.1-2001)."

#. type: TP
#: man-pages/man3/errno.3:232
#, no-wrap
msgid "B<ECONNREFUSED>"
msgstr "B<ECONNREFUSED>"

#. type: Plain text
#: man-pages/man3/errno.3:235
msgid "Connection refused (POSIX.1-2001)."
msgstr "В соединении отказано (POSIX.1-2001)."

#. type: TP
#: man-pages/man3/errno.3:235
#, no-wrap
msgid "B<ECONNRESET>"
msgstr "B<ECONNRESET>"

#. type: Plain text
#: man-pages/man3/errno.3:238
msgid "Connection reset (POSIX.1-2001)."
msgstr "Соединение сброшено другой стороной (POSIX.1-2001)."

#. type: TP
#: man-pages/man3/errno.3:238
#, no-wrap
msgid "B<EDEADLK>"
msgstr "B<EDEADLK>"

#. type: Plain text
#: man-pages/man3/errno.3:241
msgid "Resource deadlock avoided (POSIX.1-2001)."
msgstr ""
"Предотвращена тупиковая ситуация при обращении к ресурсу (POSIX.1-2001)."

#. type: TP
#: man-pages/man3/errno.3:241
#, no-wrap
msgid "B<EDEADLOCK>"
msgstr "B<EDEADLOCK>"

#. type: Plain text
#: man-pages/man3/errno.3:245
msgid "Synonym for B<EDEADLK>."
msgstr "Синоним B<EDEADLK>."

#. type: TP
#: man-pages/man3/errno.3:245
#, no-wrap
msgid "B<EDESTADDRREQ>"
msgstr "B<EDESTADDRREQ>"

#. type: Plain text
#: man-pages/man3/errno.3:248
msgid "Destination address required (POSIX.1-2001)."
msgstr "Требуется указать адрес назначения (POSIX.1-2001)."

#. type: TP
#: man-pages/man3/errno.3:248
#, no-wrap
msgid "B<EDOM>"
msgstr "B<EDOM>"

#.  EDOTDOT is defined but appears to be unused
#. type: Plain text
#: man-pages/man3/errno.3:252
msgid "Mathematics argument out of domain of function (POSIX.1, C99)."
msgstr ""
"Математический аргумент вне области определения функции (POSIX.1, C99)."

#. type: TP
#: man-pages/man3/errno.3:252
#, no-wrap
msgid "B<EDQUOT>"
msgstr "B<EDQUOT>"

#.  POSIX just says "Reserved"
#. type: Plain text
#: man-pages/man3/errno.3:256
msgid "Disk quota exceeded (POSIX.1-2001)."
msgstr "Превышена дисковая квота (POSIX.1-2001)."

#. type: Plain text
#: man-pages/man3/errno.3:259
msgid "File exists (POSIX.1-2001)."
msgstr "Файл существует (POSIX.1-2001)."

#. type: Plain text
#: man-pages/man3/errno.3:262
msgid "Bad address (POSIX.1-2001)."
msgstr "Неправильный адрес (POSIX.1-2001)."

#. type: TP
#: man-pages/man3/errno.3:262
#, no-wrap
msgid "B<EFBIG>"
msgstr "B<EFBIG>"

#. type: Plain text
#: man-pages/man3/errno.3:265
msgid "File too large (POSIX.1-2001)."
msgstr "Файл слишком велик (POSIX.1-2001)."

#. type: TP
#: man-pages/man3/errno.3:265
#, no-wrap
msgid "B<EHOSTDOWN>"
msgstr "B<EHOSTDOWN>"

#. type: Plain text
#: man-pages/man3/errno.3:268
msgid "Host is down."
msgstr "Узел выключен."

#. type: TP
#: man-pages/man3/errno.3:268
#, no-wrap
msgid "B<EHOSTUNREACH>"
msgstr "B<EHOSTUNREACH>"

#. type: Plain text
#: man-pages/man3/errno.3:271
msgid "Host is unreachable (POSIX.1-2001)."
msgstr "Узел недоступен (POSIX.1-2001)."

#. type: TP
#: man-pages/man3/errno.3:271
#, no-wrap
msgid "B<EHWPOISON>"
msgstr "B<EHWPOISON>"

#. type: Plain text
#: man-pages/man3/errno.3:274
msgid "Memory page has hardware error."
msgstr "В странице памяти аппаратная ошибка."

#. type: TP
#: man-pages/man3/errno.3:274
#, no-wrap
msgid "B<EIDRM>"
msgstr "B<EIDRM>"

#. type: Plain text
#: man-pages/man3/errno.3:277
msgid "Identifier removed (POSIX.1-2001)."
msgstr "Идентификатор удалён (POSIX.1-2001)."

#. type: TP
#: man-pages/man3/errno.3:277
#, no-wrap
msgid "B<EILSEQ>"
msgstr "B<EILSEQ>"

#. type: Plain text
#: man-pages/man3/errno.3:280
msgid "Invalid or incomplete multibyte or wide character (POSIX.1, C99)."
msgstr "Неверный или неполный мультибайтный или широкий символ (POSIX.1, C99)."

#. type: Plain text
#: man-pages/man3/errno.3:283
msgid ""
"The text shown here is the glibc error description; in POSIX.1, this error "
"is described as \"Illegal byte sequence\"."
msgstr ""
"Этот текст взят из описания ошибки glibc; в POSIX.1 эта ошибка звучит как "
"«Недопустимая последовательность байт»."

#. type: TP
#: man-pages/man3/errno.3:283
#, no-wrap
msgid "B<EINPROGRESS>"
msgstr "B<EINPROGRESS>"

#. type: Plain text
#: man-pages/man3/errno.3:286
msgid "Operation in progress (POSIX.1-2001)."
msgstr "Операция выполняется (POSIX.1-2001)."

#. type: Plain text
#: man-pages/man3/errno.3:290
msgid "Interrupted function call (POSIX.1-2001); see B<signal>(7)."
msgstr "Прерванный вызов функции (POSIX.1-2001); смотрите B<signal>(7)."

#. type: Plain text
#: man-pages/man3/errno.3:293
msgid "Invalid argument (POSIX.1-2001)."
msgstr "Неверный аргумент (POSIX.1-2001)."

#. type: Plain text
#: man-pages/man3/errno.3:296
msgid "Input/output error (POSIX.1-2001)."
msgstr "Ошибка ввода/вывода (POSIX.1-2001)."

#. type: TP
#: man-pages/man3/errno.3:296
#, no-wrap
msgid "B<EISCONN>"
msgstr "B<EISCONN>"

#. type: Plain text
#: man-pages/man3/errno.3:299
msgid "Socket is connected (POSIX.1-2001)."
msgstr "Сокет подключён (POSIX.1-2001)."

#. type: Plain text
#: man-pages/man3/errno.3:302
msgid "Is a directory (POSIX.1-2001)."
msgstr "Это каталог (POSIX.1-2001)."

#. type: TP
#: man-pages/man3/errno.3:302
#, no-wrap
msgid "B<EISNAM>"
msgstr "B<EISNAM>"

#. type: Plain text
#: man-pages/man3/errno.3:305
msgid "Is a named type file."
msgstr "Является файлом именованного типа."

#. type: TP
#: man-pages/man3/errno.3:305
#, no-wrap
msgid "B<EKEYEXPIRED>"
msgstr "B<EKEYEXPIRED>"

#. type: Plain text
#: man-pages/man3/errno.3:308
msgid "Key has expired."
msgstr "Ключ с истёкшим сроком."

#. type: TP
#: man-pages/man3/errno.3:308
#, no-wrap
msgid "B<EKEYREJECTED>"
msgstr "B<EKEYREJECTED>"

#. type: Plain text
#: man-pages/man3/errno.3:311
msgid "Key was rejected by service."
msgstr "Ключ был отвергнут службой."

#. type: TP
#: man-pages/man3/errno.3:311
#, no-wrap
msgid "B<EKEYREVOKED>"
msgstr "B<EKEYREVOKED>"

#. type: Plain text
#: man-pages/man3/errno.3:314
msgid "Key has been revoked."
msgstr "Ключ был отозван."

#. type: TP
#: man-pages/man3/errno.3:314
#, no-wrap
msgid "B<EL2HLT>"
msgstr "B<EL2HLT>"

#. type: Plain text
#: man-pages/man3/errno.3:317
msgid "Level 2 halted."
msgstr "Уровень 2 остановлен."

#. type: TP
#: man-pages/man3/errno.3:317
#, no-wrap
msgid "B<EL2NSYNC>"
msgstr "B<EL2NSYNC>"

#. type: Plain text
#: man-pages/man3/errno.3:320
msgid "Level 2 not synchronized."
msgstr "Уровень 2 не синхронизирован."

#. type: TP
#: man-pages/man3/errno.3:320
#, no-wrap
msgid "B<EL3HLT>"
msgstr "B<EL3HLT>"

#. type: Plain text
#: man-pages/man3/errno.3:323
msgid "Level 3 halted."
msgstr "Уровень 3 остановлен."

#. type: TP
#: man-pages/man3/errno.3:323
#, no-wrap
msgid "B<EL3RST>"
msgstr "B<EL3RST>"

#. type: Plain text
#: man-pages/man3/errno.3:326
msgid "Level 3 reset."
msgstr "Уровень 3 сброшен."

#. type: TP
#: man-pages/man3/errno.3:326
#, no-wrap
msgid "B<ELIBACC>"
msgstr "B<ELIBACC>"

#. type: Plain text
#: man-pages/man3/errno.3:329
msgid "Cannot access a needed shared library."
msgstr "Невозможно получить доступ к нужной общей библиотеке."

#. type: Plain text
#: man-pages/man3/errno.3:332
msgid "Accessing a corrupted shared library."
msgstr "Обращение к повреждённой общей библиотеке."

#. type: TP
#: man-pages/man3/errno.3:332
#, no-wrap
msgid "B<ELIBMAX>"
msgstr "B<ELIBMAX>"

#. type: Plain text
#: man-pages/man3/errno.3:335
msgid "Attempting to link in too many shared libraries."
msgstr "Попытка компоновки с слишком большим количеством общих библиотек."

#. type: TP
#: man-pages/man3/errno.3:335
#, no-wrap
msgid "B<ELIBSCN>"
msgstr "B<ELIBSCN>"

#. type: Plain text
#: man-pages/man3/errno.3:338
msgid "\\&.lib section in a.out corrupted"
msgstr "Секция \\&.lib в a.out повреждена"

#. type: TP
#: man-pages/man3/errno.3:338
#, no-wrap
msgid "B<ELIBEXEC>"
msgstr "B<ELIBEXEC>"

#. type: Plain text
#: man-pages/man3/errno.3:341
msgid "Cannot exec a shared library directly."
msgstr "Невозможно непосредственно выполнить общую библиотеку."

#. type: TP
#: man-pages/man3/errno.3:341
#, no-wrap
msgid "B<ELNRANGE>"
msgstr "B<ELNRANGE>"

#.  ELNRNG appears to be used by a few drivers
#. type: Plain text
#: man-pages/man3/errno.3:345
msgid "Link number out of range."
msgstr "Число ссылок вне допустимого диапазона."

#. type: Plain text
#: man-pages/man3/errno.3:348
msgid "Too many levels of symbolic links (POSIX.1-2001)."
msgstr "Слишком много уровней символьных ссылок (POSIX.1-2001)."

#. type: TP
#: man-pages/man3/errno.3:348
#, no-wrap
msgid "B<EMEDIUMTYPE>"
msgstr "B<EMEDIUMTYPE>"

#. type: Plain text
#: man-pages/man3/errno.3:351
msgid "Wrong medium type."
msgstr "Неправильный тип носителя."

#. type: Plain text
#: man-pages/man3/errno.3:358
msgid ""
"Too many open files (POSIX.1-2001).  Commonly caused by exceeding the "
"B<RLIMIT_NOFILE> resource limit described in B<getrlimit>(2)."
msgstr ""
"Слишком много открытых файлов (POSIX.1-2001). Обычно, это происходит из-за "
"превышения ограничения ресурса B<RLIMIT_NOFILE>, описанного в "
"B<getrlimit>(2)."

#. type: TP
#: man-pages/man3/errno.3:358
#, no-wrap
msgid "B<EMLINK>"
msgstr "B<EMLINK>"

#. type: Plain text
#: man-pages/man3/errno.3:361
msgid "Too many links (POSIX.1-2001)."
msgstr "Слишком много ссылок (POSIX.1-2001)."

#. type: TP
#: man-pages/man3/errno.3:361
#, no-wrap
msgid "B<EMSGSIZE>"
msgstr "B<EMSGSIZE>"

#. type: Plain text
#: man-pages/man3/errno.3:364
msgid "Message too long (POSIX.1-2001)."
msgstr "Сообщение слишком длинное (POSIX.1-2001)."

#. type: TP
#: man-pages/man3/errno.3:364
#, no-wrap
msgid "B<EMULTIHOP>"
msgstr "B<EMULTIHOP>"

#.  POSIX says "Reserved"
#. type: Plain text
#: man-pages/man3/errno.3:368
msgid "Multihop attempted (POSIX.1-2001)."
msgstr "Попытка Multihop (POSIX.1-2001)."

#.  ENAVAIL is defined, but appears not to be used
#. type: Plain text
#: man-pages/man3/errno.3:372
msgid "Filename too long (POSIX.1-2001)."
msgstr "Слишком длинное название файла (POSIX.1-2001)."

#. type: TP
#: man-pages/man3/errno.3:372
#, no-wrap
msgid "B<ENETDOWN>"
msgstr "B<ENETDOWN>"

#. type: Plain text
#: man-pages/man3/errno.3:375
msgid "Network is down (POSIX.1-2001)."
msgstr "Сеть не работает (POSIX.1-2001)."

#. type: TP
#: man-pages/man3/errno.3:375
#, no-wrap
msgid "B<ENETRESET>"
msgstr "B<ENETRESET>"

#. type: Plain text
#: man-pages/man3/errno.3:378
msgid "Connection aborted by network (POSIX.1-2001)."
msgstr "Соединение прервано из-за сети (POSIX.1-2001)."

#. type: TP
#: man-pages/man3/errno.3:378
#, no-wrap
msgid "B<ENETUNREACH>"
msgstr "B<ENETUNREACH>"

#. type: Plain text
#: man-pages/man3/errno.3:381
msgid "Network unreachable (POSIX.1-2001)."
msgstr "Сеть недоступна (POSIX.1-2001)."

#. type: Plain text
#: man-pages/man3/errno.3:388
msgid ""
"Too many open files in system (POSIX.1-2001).  On Linux, this is probably a "
"result of encountering the I</proc/sys/fs/file-max> limit (see B<proc>(5))."
msgstr ""
"Слишком много открытых файлов в системе (POSIX.1-2001). В Linux это, "
"вероятно, результат достижения ограничения I</proc/sys/fs/file-max> "
"(смотрите B<proc>(5))."

#. type: TP
#: man-pages/man3/errno.3:388
#, no-wrap
msgid "B<ENOANO>"
msgstr "B<ENOANO>"

#.  ENOANO appears to be used by a few drivers
#. type: Plain text
#: man-pages/man3/errno.3:392
msgid "No anode."
msgstr "Не anode."

#. type: TP
#: man-pages/man3/errno.3:392
#, no-wrap
msgid "B<ENOBUFS>"
msgstr "B<ENOBUFS>"

#.  ENOCSI is defined but appears to be unused.
#. type: Plain text
#: man-pages/man3/errno.3:396
msgid "No buffer space available (POSIX.1 (XSI STREAMS option))."
msgstr "Недостаточно буферного пространства (POSIX.1 (часть XSI STREAMS))."

#. type: TP
#: man-pages/man3/errno.3:396
#, no-wrap
msgid "B<ENODATA>"
msgstr "B<ENODATA>"

#. type: Plain text
#: man-pages/man3/errno.3:399
msgid "No message is available on the STREAM head read queue (POSIX.1-2001)."
msgstr "Сообщение в голове очереди чтения STREAM отсутствует (POSIX.1-2001)."

#. type: Plain text
#: man-pages/man3/errno.3:402
msgid "No such device (POSIX.1-2001)."
msgstr "Нет такого устройства (POSIX.1-2001)."

#. type: Plain text
#: man-pages/man3/errno.3:405
msgid "No such file or directory (POSIX.1-2001)."
msgstr "Нет такого файла или каталога (POSIX.1-2001)."

#. type: Plain text
#: man-pages/man3/errno.3:409
msgid ""
"Typically, this error results when a specified pathname does not exist, or "
"one of the components in the directory prefix of a pathname does not exist, "
"or the specified pathname is a dangling symbolic link."
msgstr ""
"Обычно, эта ошибка является результатом указания несуществующего пути или "
"отсутствия одного из компонентов каталогов пути, или указанный путь является "
"символической ссылкой на несуществующий объект."

#. type: Plain text
#: man-pages/man3/errno.3:412
msgid "Exec format error (POSIX.1-2001)."
msgstr "Ошибка формата выполняемого файла (POSIX.1-2001)."

#. type: TP
#: man-pages/man3/errno.3:412
#, no-wrap
msgid "B<ENOKEY>"
msgstr "B<ENOKEY>"

#. type: Plain text
#: man-pages/man3/errno.3:415
msgid "Required key not available."
msgstr "Требуемый ключ недоступен."

#. type: TP
#: man-pages/man3/errno.3:415
#, no-wrap
msgid "B<ENOLCK>"
msgstr "B<ENOLCK>"

#. type: Plain text
#: man-pages/man3/errno.3:418
msgid "No locks available (POSIX.1-2001)."
msgstr "Нет доступных блокировок (POSIX.1-2001)."

#. type: TP
#: man-pages/man3/errno.3:418
#, no-wrap
msgid "B<ENOLINK>"
msgstr "B<ENOLINK>"

#.  POSIX says "Reserved"
#. type: Plain text
#: man-pages/man3/errno.3:422
msgid "Link has been severed (POSIX.1-2001)."
msgstr "Соединение было разорвано (POSIX.1-2001)."

#. type: TP
#: man-pages/man3/errno.3:422
#, no-wrap
msgid "B<ENOMEDIUM>"
msgstr "B<ENOMEDIUM>"

#. type: Plain text
#: man-pages/man3/errno.3:425
msgid "No medium found."
msgstr "Носитель не найден."

#. type: Plain text
#: man-pages/man3/errno.3:428
msgid "Not enough space/cannot allocate memory (POSIX.1-2001)."
msgstr "Недостаточно места/невозможно выделить память (POSIX.1-2001)."

#. type: TP
#: man-pages/man3/errno.3:428
#, no-wrap
msgid "B<ENOMSG>"
msgstr "B<ENOMSG>"

#. type: Plain text
#: man-pages/man3/errno.3:431
msgid "No message of the desired type (POSIX.1-2001)."
msgstr "Нет сообщения желаемого типа (POSIX.1-2001)."

#. type: TP
#: man-pages/man3/errno.3:431
#, no-wrap
msgid "B<ENONET>"
msgstr "B<ENONET>"

#. type: Plain text
#: man-pages/man3/errno.3:434
msgid "Machine is not on the network."
msgstr "Машина не в сети."

#. type: TP
#: man-pages/man3/errno.3:434
#, no-wrap
msgid "B<ENOPKG>"
msgstr "B<ENOPKG>"

#. type: Plain text
#: man-pages/man3/errno.3:437
msgid "Package not installed."
msgstr "Пакет не установлен."

#. type: TP
#: man-pages/man3/errno.3:437
#, no-wrap
msgid "B<ENOPROTOOPT>"
msgstr "B<ENOPROTOOPT>"

#. type: Plain text
#: man-pages/man3/errno.3:440
msgid "Protocol not available (POSIX.1-2001)."
msgstr "Протокол недоступен (POSIX.1-2001)."

#. type: Plain text
#: man-pages/man3/errno.3:443
msgid "No space left on device (POSIX.1-2001)."
msgstr "На устройстве не осталось места (POSIX.1-2001)."

#. type: TP
#: man-pages/man3/errno.3:443
#, no-wrap
msgid "B<ENOSR>"
msgstr "B<ENOSR>"

#. type: Plain text
#: man-pages/man3/errno.3:446
msgid "No STREAM resources (POSIX.1 (XSI STREAMS option))."
msgstr "Отсутствую ресурсы STREAM (POSIX.1 (часть XSI STREAMS))."

#. type: TP
#: man-pages/man3/errno.3:446
#, no-wrap
msgid "B<ENOSTR>"
msgstr "B<ENOSTR>"

#. type: Plain text
#: man-pages/man3/errno.3:449
msgid "Not a STREAM (POSIX.1 (XSI STREAMS option))."
msgstr "Нет STREAM (POSIX.1 (часть XSI STREAMS))."

#. type: Plain text
#: man-pages/man3/errno.3:452
msgid "Function not implemented (POSIX.1-2001)."
msgstr "Функция не реализована (POSIX.1-2001)."

#. type: TP
#: man-pages/man3/errno.3:452
#, no-wrap
msgid "B<ENOTBLK>"
msgstr "B<ENOTBLK>"

#. type: Plain text
#: man-pages/man3/errno.3:455
msgid "Block device required."
msgstr "Требуется блочное устройство."

#. type: TP
#: man-pages/man3/errno.3:455
#, no-wrap
msgid "B<ENOTCONN>"
msgstr "B<ENOTCONN>"

#. type: Plain text
#: man-pages/man3/errno.3:458
msgid "The socket is not connected (POSIX.1-2001)."
msgstr "Сокет не подключён (POSIX.1-2001)."

#. type: Plain text
#: man-pages/man3/errno.3:461
msgid "Not a directory (POSIX.1-2001)."
msgstr "Не каталог (POSIX.1-2001)."

#. type: TP
#: man-pages/man3/errno.3:461
#, no-wrap
msgid "B<ENOTEMPTY>"
msgstr "B<ENOTEMPTY>"

#.  ENOTNAM is defined but appears to be unused.
#. type: Plain text
#: man-pages/man3/errno.3:465
msgid "Directory not empty (POSIX.1-2001)."
msgstr "Каталог не пуст (POSIX.1-2001)."

#. type: TP
#: man-pages/man3/errno.3:465
#, no-wrap
msgid "B<ENOTRECOVERABLE>"
msgstr "B<ENOTRECOVERABLE>"

#. type: Plain text
#: man-pages/man3/errno.3:468
msgid "State not recoverable (POSIX.1-2008)."
msgstr "Состояние нельзя восстановить (POSIX.1-2008)."

#. type: TP
#: man-pages/man3/errno.3:468
#, no-wrap
msgid "B<ENOTSOCK>"
msgstr "B<ENOTSOCK>"

#. type: Plain text
#: man-pages/man3/errno.3:471
msgid "Not a socket (POSIX.1-2001)."
msgstr "Не сокет (POSIX.1-2001)."

#. type: TP
#: man-pages/man3/errno.3:471
#, no-wrap
msgid "B<ENOTSUP>"
msgstr "B<ENOTSUP>"

#. type: Plain text
#: man-pages/man3/errno.3:474
msgid "Operation not supported (POSIX.1-2001)."
msgstr "Операция не поддерживается (POSIX.1-2001)."

#. type: TP
#: man-pages/man3/errno.3:474
#, no-wrap
msgid "B<ENOTTY>"
msgstr "B<ENOTTY>"

#. type: Plain text
#: man-pages/man3/errno.3:477
msgid "Inappropriate I/O control operation (POSIX.1-2001)."
msgstr "Неподходящая операция управления вводом/выводом (POSIX.1-2001)."

#. type: TP
#: man-pages/man3/errno.3:477
#, no-wrap
msgid "B<ENOTUNIQ>"
msgstr "B<ENOTUNIQ>"

#. type: Plain text
#: man-pages/man3/errno.3:480
msgid "Name not unique on network."
msgstr "Имя не уникально в сети."

#. type: TP
#: man-pages/man3/errno.3:480
#, no-wrap
msgid "B<ENXIO>"
msgstr "B<ENXIO>"

#. type: Plain text
#: man-pages/man3/errno.3:483
msgid "No such device or address (POSIX.1-2001)."
msgstr "Нет такого устройства или адреса (POSIX.1-2001)."

#. type: TP
#: man-pages/man3/errno.3:483
#, no-wrap
msgid "B<EOPNOTSUPP>"
msgstr "B<EOPNOTSUPP>"

#. type: Plain text
#: man-pages/man3/errno.3:486
msgid "Operation not supported on socket (POSIX.1-2001)."
msgstr "Операция не поддерживается на сокете (POSIX.1-2001)."

#. type: Plain text
#: man-pages/man3/errno.3:492
msgid ""
"(B<ENOTSUP> and B<EOPNOTSUPP> have the same value on Linux, but according to "
"POSIX.1 these error values should be distinct.)"
msgstr ""
"(B<ENOTSUP> и B<EOPNOTSUPP> в Linux имеют одинаковые значения, но согласно "
"POSIX.1 значения этих ошибок должны различаться.)"

#. type: TP
#: man-pages/man3/errno.3:492
#, no-wrap
msgid "B<EOVERFLOW>"
msgstr "B<EOVERFLOW>"

#. type: Plain text
#: man-pages/man3/errno.3:495
msgid "Value too large to be stored in data type (POSIX.1-2001)."
msgstr ""
"Значение слишком велико для хранения в таком типе данных (POSIX.1-2001)."

#. type: TP
#: man-pages/man3/errno.3:495
#, no-wrap
msgid "B<EOWNERDEAD>"
msgstr "B<EOWNERDEAD>"

#.  Used at least by the user-space side of rubost mutexes
#. type: Plain text
#: man-pages/man3/errno.3:499
msgid "Owner died (POSIX.1-2008)."
msgstr "Владелец умер (POSIX.1-2008)."

#. type: Plain text
#: man-pages/man3/errno.3:502
msgid "Operation not permitted (POSIX.1-2001)."
msgstr "Операция не позволена (POSIX.1-2001)."

#. type: TP
#: man-pages/man3/errno.3:502
#, no-wrap
msgid "B<EPFNOSUPPORT>"
msgstr "B<EPFNOSUPPORT>"

#. type: Plain text
#: man-pages/man3/errno.3:505
msgid "Protocol family not supported."
msgstr "Семейство протоколов не поддерживается."

#. type: TP
#: man-pages/man3/errno.3:505
#, no-wrap
msgid "B<EPIPE>"
msgstr "B<EPIPE>"

#. type: Plain text
#: man-pages/man3/errno.3:508
msgid "Broken pipe (POSIX.1-2001)."
msgstr "Обрыв канала (POSIX.1-2001)."

#. type: TP
#: man-pages/man3/errno.3:508
#, no-wrap
msgid "B<EPROTO>"
msgstr "B<EPROTO>"

#. type: Plain text
#: man-pages/man3/errno.3:511
msgid "Protocol error (POSIX.1-2001)."
msgstr "Ошибка протокола (POSIX.1-2001)."

#. type: TP
#: man-pages/man3/errno.3:511
#, no-wrap
msgid "B<EPROTONOSUPPORT>"
msgstr "B<EPROTONOSUPPORT>"

#. type: Plain text
#: man-pages/man3/errno.3:514
msgid "Protocol not supported (POSIX.1-2001)."
msgstr "Протокол не поддерживается (POSIX.1-2001)."

#. type: TP
#: man-pages/man3/errno.3:514
#, no-wrap
msgid "B<EPROTOTYPE>"
msgstr "B<EPROTOTYPE>"

#. type: Plain text
#: man-pages/man3/errno.3:517
msgid "Protocol wrong type for socket (POSIX.1-2001)."
msgstr "Неверный тип протокола для сокета (POSIX.1-2001)."

#. type: TP
#: man-pages/man3/errno.3:517
#, no-wrap
msgid "B<ERANGE>"
msgstr "B<ERANGE>"

#. type: Plain text
#: man-pages/man3/errno.3:520
msgid "Result too large (POSIX.1, C99)."
msgstr "Результат слишком большой (POSIX.1, C99)."

#. type: TP
#: man-pages/man3/errno.3:520
#, no-wrap
msgid "B<EREMCHG>"
msgstr "B<EREMCHG>"

#. type: Plain text
#: man-pages/man3/errno.3:523
msgid "Remote address changed."
msgstr "Удалённый адрес был изменён."

#. type: TP
#: man-pages/man3/errno.3:523
#, no-wrap
msgid "B<EREMOTE>"
msgstr "B<EREMOTE>"

#. type: Plain text
#: man-pages/man3/errno.3:526
msgid "Object is remote."
msgstr "Это удалённый объект."

#. type: TP
#: man-pages/man3/errno.3:526
#, no-wrap
msgid "B<EREMOTEIO>"
msgstr "B<EREMOTEIO>"

#. type: Plain text
#: man-pages/man3/errno.3:529
msgid "Remote I/O error."
msgstr "Ошибка удалённого ввода/вывода."

#. type: TP
#: man-pages/man3/errno.3:529
#, no-wrap
msgid "B<ERESTART>"
msgstr "B<ERESTART>"

#. type: Plain text
#: man-pages/man3/errno.3:532
msgid "Interrupted system call should be restarted."
msgstr "Прерванный системный вызов следует перезапустить."

#. type: TP
#: man-pages/man3/errno.3:532
#, no-wrap
msgid "B<ERFKILL>"
msgstr "B<ERFKILL>"

#.  ERFKILL appears to be used by various drivers
#. type: Plain text
#: man-pages/man3/errno.3:536
msgid "Operation not possible due to RF-kill."
msgstr "Операция не позволяется из-за RF-kill."

#. type: TP
#: man-pages/man3/errno.3:536
#, no-wrap
msgid "B<EROFS>"
msgstr "B<EROFS>"

#. type: Plain text
#: man-pages/man3/errno.3:539
msgid "Read-only filesystem (POSIX.1-2001)."
msgstr "Файловая система доступна только для чтения (POSIX.1-2001)."

#. type: TP
#: man-pages/man3/errno.3:539
#, no-wrap
msgid "B<ESHUTDOWN>"
msgstr "B<ESHUTDOWN>"

#. type: Plain text
#: man-pages/man3/errno.3:542
msgid "Cannot send after transport endpoint shutdown."
msgstr "Невозможно отправить данные после выключения конечной точки передачи."

#. type: TP
#: man-pages/man3/errno.3:542
#, no-wrap
msgid "B<ESPIPE>"
msgstr "B<ESPIPE>"

#. type: Plain text
#: man-pages/man3/errno.3:545
msgid "Invalid seek (POSIX.1-2001)."
msgstr "Недопустимое перемещение (POSIX.1-2001)."

#. type: TP
#: man-pages/man3/errno.3:545
#, no-wrap
msgid "B<ESOCKTNOSUPPORT>"
msgstr "B<ESOCKTNOSUPPORT>"

#. type: Plain text
#: man-pages/man3/errno.3:548
msgid "Socket type not supported."
msgstr "Тип сокета не поддерживается."

#. type: TP
#: man-pages/man3/errno.3:548
#, no-wrap
msgid "B<ESRCH>"
msgstr "B<ESRCH>"

#.  ESRMNT is defined but appears not to be used
#. type: Plain text
#: man-pages/man3/errno.3:552
msgid "No such process (POSIX.1-2001)."
msgstr "Нет такого процесса (POSIX.1-2001)."

#. type: TP
#: man-pages/man3/errno.3:552
#, no-wrap
msgid "B<ESTALE>"
msgstr "B<ESTALE>"

#. type: Plain text
#: man-pages/man3/errno.3:555
msgid "Stale file handle (POSIX.1-2001)."
msgstr "Неактуальный дескриптор файла (POSIX.1-2001)."

#. type: Plain text
#: man-pages/man3/errno.3:557
msgid "This error can occur for NFS and for other filesystems."
msgstr "Эта ошибка может возникать в NFS и других файловых системах."

#. type: TP
#: man-pages/man3/errno.3:557
#, no-wrap
msgid "B<ESTRPIPE>"
msgstr "B<ESTRPIPE>"

#. type: Plain text
#: man-pages/man3/errno.3:560
msgid "Streams pipe error."
msgstr "Ошибка потоков канала."

#. type: TP
#: man-pages/man3/errno.3:560
#, no-wrap
msgid "B<ETIME>"
msgstr "B<ETIME>"

#. type: Plain text
#: man-pages/man3/errno.3:564
msgid "Timer expired (POSIX.1 (XSI STREAMS option))."
msgstr "Таймер истёк (POSIX.1 (часть XSI STREAMS))."

#. type: Plain text
#: man-pages/man3/errno.3:568
msgid "(POSIX.1 says \"STREAM B<ioctl>(2)  timeout\".)"
msgstr ""
"(в POSIX.1 описывается как «в B<ioctl>(2) истекло время ожидания STREAM»)"

#. type: TP
#: man-pages/man3/errno.3:568
#, no-wrap
msgid "B<ETIMEDOUT>"
msgstr "B<ETIMEDOUT>"

#. type: Plain text
#: man-pages/man3/errno.3:571
msgid "Connection timed out (POSIX.1-2001)."
msgstr "Время ожидания соединения истекло (POSIX.1-2001)."

#. type: TP
#: man-pages/man3/errno.3:571
#, no-wrap
msgid "B<ETOOMANYREFS>"
msgstr "B<ETOOMANYREFS>"

#.  ETOOMANYREFS seems to be used in net/unix/af_unix.c
#. type: Plain text
#: man-pages/man3/errno.3:575
msgid "Too many references: cannot splice."
msgstr "Слишком много ссылок: невозможно объединить."

#. type: Plain text
#: man-pages/man3/errno.3:578
msgid "Text file busy (POSIX.1-2001)."
msgstr "Текстовый файл занят (POSIX.1-2001)."

#. type: TP
#: man-pages/man3/errno.3:578
#, no-wrap
msgid "B<EUCLEAN>"
msgstr "B<EUCLEAN>"

#. type: Plain text
#: man-pages/man3/errno.3:581
msgid "Structure needs cleaning."
msgstr "Структуру необходимо очистить."

#. type: TP
#: man-pages/man3/errno.3:581
#, no-wrap
msgid "B<EUNATCH>"
msgstr "B<EUNATCH>"

#. type: Plain text
#: man-pages/man3/errno.3:584
msgid "Protocol driver not attached."
msgstr "Драйвер протокола не подсоединён."

#. type: TP
#: man-pages/man3/errno.3:584
#, no-wrap
msgid "B<EUSERS>"
msgstr "B<EUSERS>"

#. type: Plain text
#: man-pages/man3/errno.3:587
msgid "Too many users."
msgstr "Слишком много пользователей."

#. type: TP
#: man-pages/man3/errno.3:587
#, no-wrap
msgid "B<EWOULDBLOCK>"
msgstr "B<EWOULDBLOCK>"

#. type: Plain text
#: man-pages/man3/errno.3:592
msgid "Operation would block (may be same value as B<EAGAIN>)  (POSIX.1-2001)."
msgstr ""
"Операция приведёт к блокировке (значение может быть равно B<EAGAIN>) "
"(POSIX.1-2001)."

#. type: TP
#: man-pages/man3/errno.3:592
#, no-wrap
msgid "B<EXDEV>"
msgstr "B<EXDEV>"

#. type: Plain text
#: man-pages/man3/errno.3:595
msgid "Improper link (POSIX.1-2001)."
msgstr "Некорректная ссылка (POSIX.1-2001)."

#. type: TP
#: man-pages/man3/errno.3:595
#, no-wrap
msgid "B<EXFULL>"
msgstr "B<EXFULL>"

#. type: Plain text
#: man-pages/man3/errno.3:598
msgid "Exchange full."
msgstr "Обмен полон."

#. type: Plain text
#: man-pages/man3/errno.3:600
msgid "A common mistake is to do"
msgstr "Распространённая ошибка:"

#. type: Plain text
#: man-pages/man3/errno.3:607
#, no-wrap
msgid ""
"if (somecall() == -1) {\n"
"    printf(\"somecall() failed\\en\");\n"
"    if (errno == ...) { ... }\n"
"}\n"
msgstr ""
"if (somecall() == -1) {\n"
"    printf(\"somecall() failed\\en\");\n"
"    if (errno == ...) { ... }\n"
"}\n"

#. type: Plain text
#: man-pages/man3/errno.3:619
msgid ""
"where I<errno> no longer needs to have the value it had upon return from "
"I<somecall>()  (i.e., it may have been changed by the B<printf>(3)).  If the "
"value of I<errno> should be preserved across a library call, it must be "
"saved:"
msgstr ""
"Здесь I<errno> может больше не иметь значение результата последнего вызова "
"I<somecall>() (т.е., значение может измениться из-за B<printf>(3)). Если "
"значение I<errno> важно, то его нужно сохранять между библиотечными вызовами:"

#. type: Plain text
#: man-pages/man3/errno.3:627
#, no-wrap
msgid ""
"if (somecall() == -1) {\n"
"    int errsv = errno;\n"
"    printf(\"somecall() failed\\en\");\n"
"    if (errsv == ...) { ... }\n"
"}\n"
msgstr ""
"if (somecall() == -1) {\n"
"    int errsv = errno;\n"
"    printf(\"somecall() failed\\en\");\n"
"    if (errsv == ...) { ... }\n"
"}\n"

#. type: Plain text
#: man-pages/man3/errno.3:642
msgid ""
"On some ancient systems, I<E<lt>errno.hE<gt>> was not present or did not "
"declare I<errno>, so that it was necessary to declare I<errno> manually (i."
"e., I<extern int errno>).  B<Do not do this>.  It long ago ceased to be "
"necessary, and it will cause problems with modern versions of the C library."
msgstr ""
"В некоторых древних системах файл I<E<lt>errno.hE<gt>> отсутствовал или не "
"объявлял I<errno>, поэтому это нужно было делать вручную (например, I<extern "
"int errno>). B<Не делайте этого>. Это давно уже не нужно, и вызовет проблемы "
"с современными версиями библиотеки C."

#.  In the moreutils package
#. type: Plain text
#: man-pages/man3/errno.3:647
msgid "B<errno>(1), B<err>(3), B<error>(3), B<perror>(3), B<strerror>(3)"
msgstr "B<errno>(1), B<err>(3), B<error>(3), B<perror>(3), B<strerror>(3)"

#. type: TH
#: man-pages/man3/erfc.3:26
#, no-wrap
msgid "ERFC"
msgstr "ERFC"

#. type: Plain text
#: man-pages/man3/erfc.3:29
msgid "erfc, erfcf, erfcl - complementary error function"
msgstr "erfc, erfcf, erfcl - дополнительная функция ошибки"

#. type: Plain text
#: man-pages/man3/erfc.3:36
#, no-wrap
msgid ""
"B<double erfc(double >I<x>B<);>\n"
"B<float erfcf(float >I<x>B<);>\n"
"B<long double erfcl(long double >I<x>B<);>\n"
msgstr ""
"B<double erfc(double >I<x>B<);>\n"
"B<float erfcf(float >I<x>B<);>\n"
"B<long double erfcl(long double >I<x>B<);>\n"

#. type: Plain text
#: man-pages/man3/erfc.3:47
msgid "B<erfc>():"
msgstr "B<erfc>():"

#. type: Plain text
#: man-pages/man3/erfc.3:51
#, no-wrap
msgid ""
"_ISOC99_SOURCE || _POSIX_C_SOURCE\\ E<gt>=\\ 200112L || _XOPEN_SOURCE\n"
"    || /* Since glibc 2.19: */ _DEFAULT_SOURCE\n"
"    || /* Glibc versions E<lt>= 2.19: */ _BSD_SOURCE || _SVID_SOURCE\n"
msgstr ""
"_ISOC99_SOURCE || _POSIX_C_SOURCE\\ E<gt>=\\ 200112L || _XOPEN_SOURCE\n"
"    || /* начиная с glibc 2.19: */ _DEFAULT_SOURCE\n"
"    || /* в версии glibc E<lt>= 2.19: */ _BSD_SOURCE || _SVID_SOURCE\n"

#. type: Plain text
#: man-pages/man3/erfc.3:55
msgid "B<erfcf>(), B<erfcl>():"
msgstr "B<erfcf>(), B<erfcl>():"

#. type: Plain text
#: man-pages/man3/erfc.3:65
msgid ""
"These functions return the complementary error function of I<x>, that is, "
"1.0 - erf(x)."
msgstr ""
"Эти функции возвращают дополнительную функцию ошибки от I<x>, то есть 1.0 - "
"erf(x)."

#. type: Plain text
#: man-pages/man3/erfc.3:69
msgid ""
"On success, these functions return the complementary error function of I<x>, "
"a value in the range [0,2]."
msgstr ""
"При успешном выполнении эти функции возвращают дополнительную функцию ошибки "
"от I<x>, значение в диапазоне [0,2]."

#. type: Plain text
#: man-pages/man3/erfc.3:77
msgid "If I<x> is +0 or -0, 1 is returned."
msgstr "Если I<x> равен +0 или -0, возвращается -1."

#. type: Plain text
#: man-pages/man3/erfc.3:82
msgid "If I<x> is positive infinity, +0 is returned."
msgstr "Если I<x> стремится к плюс бесконечности, то будет возвращено +0."

#. type: Plain text
#: man-pages/man3/erfc.3:87
msgid "If I<x> is negative infinity, +2 is returned."
msgstr "Если I<x> равно минус бесконечности, возвращается +2."

#. type: Plain text
#: man-pages/man3/erfc.3:90
msgid ""
"If the function result underflows and produces an unrepresentable value, the "
"return value is 0.0."
msgstr ""
"Если результат функции исчерпал степень, что грозит созданием "
"непредставимого числа, то возвращается значение 0.0."

#.  e.g., erfc(27) on x86-32
#. type: Plain text
#: man-pages/man3/erfc.3:96
msgid ""
"If the function result underflows but produces a representable (i.e., "
"subnormal) value, that value is returned, and a range error occurs."
msgstr ""
"Если в результате функции исчерпана степень, но значение представимо (т.е. "
"субнормально), то возвращается это значение и возникает ошибка диапазона."

#. type: TP
#: man-pages/man3/erfc.3:103
#, no-wrap
msgid "Range error: result underflow (result is subnormal)"
msgstr "Ошибка диапазона: результат исчерпал степень(результат субнормален)"

#.  .I errno
#.  is set to
#.  .BR ERANGE .
#. type: Plain text
#: man-pages/man3/erfc.3:111
msgid "An underflow floating-point exception (B<FE_UNDERFLOW>)  is raised."
msgstr ""
"Возникает исключение исчерпания степени чисел с плавающей запятой "
"(B<FE_UNDERFLOW>)."

#.  FIXME . Is it intentional that these functions do not set errno?
#.  Bug raised: http://sources.redhat.com/bugzilla/show_bug.cgi?id=6785
#. type: Plain text
#: man-pages/man3/erfc.3:116
msgid "These functions do not set I<errno>."
msgstr "Эти функции не изменяют I<errno>."

#. type: tbl table
#: man-pages/man3/erfc.3:128
#, no-wrap
msgid ""
"B<erfc>(),\n"
"B<erfcf>(),\n"
"B<erfcl>()"
msgstr ""
"B<erfc>(),\n"
"B<erfcf>(),\n"
"B<erfcl>()"

#. type: Plain text
#: man-pages/man3/erfc.3:147
msgid ""
"The B<erfc>(), B<erfcf>(), and B<erfcl>()  functions are provided to avoid "
"the loss accuracy that would occur for the calculation 1-erf(x) for large "
"values of I<x> (for which the value of erf(x) approaches 1)."
msgstr ""
"Функции B<erfc>(), B<erfcf>() и B<erfcl>() созданы с целью избежания потери "
"точности, которая возникает при вычислении 1-erf(x) для больших значений "
"I<x> (для которых значение erf(x) стремится к 1)."

#. type: Plain text
#: man-pages/man3/erfc.3:150
msgid "B<cerf>(3), B<erf>(3), B<exp>(3)"
msgstr "B<cerf>(3), B<erf>(3), B<exp>(3)"

#. type: TH
#: man-pages/man3/exp10.3:35
#, no-wrap
msgid "EXP10"
msgstr "EXP10"

#. type: Plain text
#: man-pages/man3/exp10.3:38
msgid "exp10, exp10f, exp10l - base-10 exponential function"
msgstr "exp10, exp10f, exp10l - функция степени по основанию 10"

#. type: Plain text
#: man-pages/man3/exp10.3:42
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>         /* See feature_test_macros(7) */\n"
"B<#include E<lt>math.hE<gt>>\n"
msgstr ""
"B<#define _GNU_SOURCE>         /* смотрите feature_test_macros(7) */\n"
"B<#include E<lt>math.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/exp10.3:46
#, no-wrap
msgid ""
"B<double exp10(double >I<x>B<);>\n"
"B<float exp10f(float >I<x>B<);>\n"
"B<long double exp10l(long double >I<x>B<);>\n"
msgstr ""
"B<double exp10(double >I<x>B<);>\n"
"B<float exp10f(float >I<x>B<);>\n"
"B<long double exp10l(long double >I<x>B<);>\n"

#. type: Plain text
#: man-pages/man3/exp10.3:53
msgid "These functions return the value of 10 raised to the power of I<x>."
msgstr "Данные функции возвращают значение 10, возведённое в степень I<x>."

#. type: Plain text
#: man-pages/man3/exp10.3:56
msgid ""
"On success, these functions return the base-10 exponential value of I<x>."
msgstr "При успешной работе эти функции возвращают 10 в степени I<x>."

#. type: tbl table
#: man-pages/man3/exp10.3:82
#, no-wrap
msgid ""
"B<exp10>(),\n"
"B<exp10f>(),\n"
"B<exp10l>()"
msgstr ""
"B<exp10>(),\n"
"B<exp10f>(),\n"
"B<exp10l>()"

#.  http://sources.redhat.com/bugzilla/show_bug.cgi?id=6787
#. type: Plain text
#: man-pages/man3/exp10.3:93
msgid ""
"Prior to version 2.19, the glibc implementation of these functions did not "
"set I<errno> to B<ERANGE> when an underflow error occurred."
msgstr ""
"До версии 2.19 в реализации glibc при возникновении ошибки исчерпания "
"степени I<errno> не устанавливалось в значение B<ERANGE>."

#. type: Plain text
#: man-pages/man3/exp10.3:98
msgid "B<cbrt>(3), B<exp>(3), B<exp2>(3), B<log10>(3), B<sqrt>(3)"
msgstr "B<cbrt>(3), B<exp>(3), B<exp2>(3), B<log10>(3), B<sqrt>(3)"

#. type: TH
#: man-pages/man3/expm1.3:30
#, no-wrap
msgid "EXPM1"
msgstr "EXPM1"

#. type: Plain text
#: man-pages/man3/expm1.3:33
msgid "expm1, expm1f, expm1l - exponential minus 1"
msgstr "expm1, expm1f, expm1l - экспоненциальный минус 1"

#. type: Plain text
#: man-pages/man3/expm1.3:40
#, no-wrap
msgid ""
"B<double expm1(double >I<x>B<);>\n"
"B<float expm1f(float >I<x>B<);>\n"
"B<long double expm1l(long double >I<x>B<);>\n"
msgstr ""
"B<double expm1(double >I<x>B<);>\n"
"B<float expm1f(float >I<x>B<);>\n"
"B<long double expm1l(long double >I<x>B<);>\n"

#. type: Plain text
#: man-pages/man3/expm1.3:51
msgid "B<expm1>():"
msgstr "B<expm1>():"

#.     || _XOPEN_SOURCE\ &&\ _XOPEN_SOURCE_EXTENDED
#. type: Plain text
#: man-pages/man3/expm1.3:57
#, no-wrap
msgid ""
"_ISOC99_SOURCE || _POSIX_C_SOURCE\\ E<gt>=\\ 200112L\n"
"    || _XOPEN_SOURCE\\ E<gt>=\\ 500\n"
"    || /* Since glibc 2.19: */ _DEFAULT_SOURCE\n"
"    || /* Glibc versions E<lt>= 2.19: */ _BSD_SOURCE || _SVID_SOURCE\n"
msgstr ""
"_ISOC99_SOURCE || _POSIX_C_SOURCE\\ E<gt>=\\ 200112L\n"
"    || _XOPEN_SOURCE\\ E<gt>=\\ 500\n"
"    || /* начиная с glibc 2.19: */ _DEFAULT_SOURCE\n"
"    || /* версии glibc E<lt>= 2.19: */ _BSD_SOURCE || _SVID_SOURCE\n"

#. type: Plain text
#: man-pages/man3/expm1.3:61
msgid "B<expm1f>(), B<expm1l>():"
msgstr "B<expm1f>(), B<expm1l>():"

#. type: Plain text
#: man-pages/man3/expm1.3:69
msgid "These functions return a value equivalent to"
msgstr "Данные функции возвращают значение эквивалентное"

#. type: Plain text
#: man-pages/man3/expm1.3:72
#, no-wrap
msgid "    exp(x) - 1\n"
msgstr "    exp(x) - 1\n"

#. type: Plain text
#: man-pages/man3/expm1.3:81
msgid ""
"The result is computed in a way that is accurate even if the value of I<x> "
"is near zero\\(ema case where I<exp(x) - 1> would be inaccurate due to "
"subtraction of two numbers that are nearly equal."
msgstr ""
"Результат вычисляется методом, выдающим точные значения, даже если значение "
"I<x> близко к нулю — случай, где I<exp(x) - 1> было бы неточно из-за "
"вычитания практически одинаковых чисел."

#. type: Plain text
#: man-pages/man3/expm1.3:84
msgid "On success, these functions return I<exp(x)\\ -\\ 1>."
msgstr "При успешном выполнении данные функции возвращают I<exp(x)\\ -\\ 1>."

#. type: Plain text
#: man-pages/man3/expm1.3:94
msgid "If I<x> is +0 (-0), +0 (-0) is returned."
msgstr "Если I<x> равно +0 (-0), будет возвращено +0 (-0)."

#. type: Plain text
#: man-pages/man3/expm1.3:102
msgid "If I<x> is negative infinity, -1 is returned."
msgstr "Если I<x> равно минус бесконечности, возвращается -1."

#. type: Plain text
#: man-pages/man3/expm1.3:110
msgid ""
"If the result overflows, a range error occurs, and the functions return -"
"B<HUGE_VAL>, -B<HUGE_VALF>, or -B<HUGE_VALL>, respectively."
msgstr ""
"Если в результате превышена разрядность, то возникает ошибка диапазона и "
"функции возвращают -B<HUGE_VAL>, -B<HUGE_VALF> или -B<HUGE_VALL>, "
"соответственно."

#.  POSIX.1 specifies an optional range error (underflow) if
#.  x is subnormal.  Glibc does not implement this.
#. type: Plain text
#: man-pages/man3/expm1.3:129
msgid ""
"I<errno> is set to B<ERANGE> (but see BUGS).  An overflow floating-point "
"exception (B<FE_OVERFLOW>)  is raised."
msgstr ""
"Значение I<errno> устанавливается в B<ERANGE> (но см. ДЕФЕКТЫ). Возникает "
"исключение переполнения плавающей точки (B<FE_OVERFLOW>)."

#. type: tbl table
#: man-pages/man3/expm1.3:141
#, no-wrap
msgid ""
"B<expm1>(),\n"
"B<expm1f>(),\n"
"B<expm1l>()"
msgstr ""
"B<expm1>(),\n"
"B<expm1f>(),\n"
"B<expm1l>()"

#.  FIXME .
#.  Bug raised: http://sources.redhat.com/bugzilla/show_bug.cgi?id=6778
#. type: Plain text
#: man-pages/man3/expm1.3:154
msgid ""
"For some large negative I<x> values (where the function result approaches "
"-1), B<expm1>()  raises a bogus underflow floating-point exception."
msgstr ""
"Для некоторых огромных отрицательных значений I<x> (где возвращаемое "
"значение функции близко к -1), B<expm1>() приводит к некорректному "
"исключению исчерпания чисел с плавающей запятой."

#.  FIXME .
#.  Bug raised: http://sources.redhat.com/bugzilla/show_bug.cgi?id=6814
#.  e.g., expm1(1e5) through expm1(1.00199970127e5),
#.  but not expm1(1.00199970128e5) and beyond.
#. type: Plain text
#: man-pages/man3/expm1.3:165
msgid ""
"For some large positive I<x> values, B<expm1>()  raises a bogus invalid "
"floating-point exception in addition to the expected overflow exception, and "
"returns a NaN instead of positive infinity."
msgstr ""
"Для некоторых огромных положительных значений I<x> кроме ожидаемого "
"исключения переполнения возникает некорректное исключение плавающей точки и "
"возвращается NaN вместо плюс бесконечности."

#.  It looks like the fix was in 2.11, or possibly 2.12.
#.  I have no test system for 2.11, but 2.12 passes.
#.  From the source (sysdeps/i386/fpu/s_expm1.S) it looks
#.  like the changes were in 2.11.
#.  http://sources.redhat.com/bugzilla/show_bug.cgi?id=6788
#. type: Plain text
#: man-pages/man3/expm1.3:177
msgid ""
"Before version 2.11, the glibc implementation did not set I<errno> to "
"B<ERANGE> when a range error occurred."
msgstr ""
"До версии 2.11 в реализации glibc при возникновении ошибки диапазона "
"I<errno> не устанавливалось в значение B<ERANGE>."

#. type: Plain text
#: man-pages/man3/expm1.3:180
msgid "B<exp>(3), B<log>(3), B<log1p>(3)"
msgstr "B<exp>(3), B<log>(3), B<log1p>(3)"

#. type: TH
#: man-pages/man3/euidaccess.3:25
#, no-wrap
msgid "EUIDACCESS"
msgstr "EUIDACCESS"

#. type: Plain text
#: man-pages/man3/euidaccess.3:28
msgid "euidaccess, eaccess - check effective user's permissions for a file"
msgstr "euidaccess, eaccess - проверяет эффективные права пользователя на файл"

#. type: Plain text
#: man-pages/man3/euidaccess.3:32
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>             /* See feature_test_macros(7) */\n"
"B<#include E<lt>unistd.hE<gt>>\n"
msgstr ""
"B<#define _GNU_SOURCE>             /* Смотрите feature_test_macros(7) */\n"
"B<#include E<lt>unistd.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/euidaccess.3:35
#, no-wrap
msgid ""
"B<int euidaccess(const char *>I<pathname>B<, int >I<mode>B<);>\n"
"B<int eaccess(const char *>I<pathname>B<, int >I<mode>B<);>\n"
msgstr ""
"B<int euidaccess(const char *>I<pathname>B<, int >I<mode>B<);>\n"
"B<int eaccess(const char *>I<pathname>B<, int >I<mode>B<);>\n"

#. type: Plain text
#: man-pages/man3/euidaccess.3:47
msgid ""
"Like B<access>(2), B<euidaccess>()  checks permissions and existence of the "
"file identified by its argument I<pathname>.  However, whereas B<access>(2)  "
"performs checks using the real user and group identifiers of the process, "
"B<euidaccess>()  uses the effective identifiers."
msgstr ""
"Подобно B<access>(2), B<euidaccess>() проверяет права и существование файла, "
"указанного в аргументе I<pathname>. Однако, если B<access>(2) выполняет "
"проверку для реального идентификатора пользователя и группы процесса, то "
"B<euidaccess>() использует эффективные идентификаторы."

#. type: Plain text
#: man-pages/man3/euidaccess.3:53
msgid ""
"I<mode> is a mask consisting of one or more of B<R_OK>, B<W_OK>, B<X_OK>, "
"and B<F_OK>, with the same meanings as for B<access>(2)."
msgstr ""
"Значение I<mode> представляет собой маску, состоящую из одного и более "
"флагов B<R_OK>, B<W_OK>, B<X_OK> и B<F_OK> (значение описано в B<access>(2))."

#. type: Plain text
#: man-pages/man3/euidaccess.3:58
msgid ""
"B<eaccess>()  is a synonym for B<euidaccess>(), provided for compatibility "
"with some other systems."
msgstr ""
"Функция B<eaccess>() — ещё одно название B<euidaccess>(), предоставляется "
"для совместимости с некоторыми другими системами."

#. type: Plain text
#: man-pages/man3/euidaccess.3:66
msgid ""
"On success (all requested permissions granted), zero is returned.  On error "
"(at least one bit in I<mode> asked for a permission that is denied, or some "
"other error occurred), -1 is returned, and I<errno> is set appropriately."
msgstr ""
"При успешном выполнении (есть все запрошенные права) возвращается ноль. При "
"ошибке (по крайней мере, один флаг из I<mode> был не удовлетворён, или "
"произошла другая ошибка), возвращается -1, а I<errno> устанавливается "
"должным образом."

#. type: Plain text
#: man-pages/man3/euidaccess.3:69
msgid "As for B<access>(2)."
msgstr "Аналогичны B<access>(2)."

#. type: Plain text
#: man-pages/man3/euidaccess.3:73
msgid "The B<eaccess>()  function was added to glibc in version 2.4."
msgstr "Функция B<eaccess>() впервые появилась в glibc 2.4."

#. type: tbl table
#: man-pages/man3/euidaccess.3:84
#, no-wrap
msgid ""
"B<euidaccess>(),\n"
"B<eaccess>()"
msgstr ""
"B<euidaccess>(),\n"
"B<eaccess>()"

#.  e.g., FreeBSD 6.1.
#. type: Plain text
#: man-pages/man3/euidaccess.3:92
msgid ""
"These functions are nonstandard.  Some other systems have an B<eaccess>()  "
"function."
msgstr ""
"Эти функции являются нестандартными. В некоторых системах есть функция "
"B<eaccess>()."

#. type: Plain text
#: man-pages/man3/euidaccess.3:99
msgid ""
"I<Warning>: Using this function to check a process's permissions on a file "
"before performing some operation based on that information leads to race "
"conditions: the file permissions may change between the two steps.  "
"Generally, it is safer just to attempt the desired operation and handle any "
"permission error that occurs."
msgstr ""
"I<Предупреждение>: Использование этой функции для проверки прав процесса на "
"файл перед выполнением какой-то операции на основе этой информации приводит "
"к состоянию состязательности: права на файл могут измениться между двумя "
"этими шагами. Обычно, безопасней просто попытаться выполнить желаемую "
"операцию и что-то предпринять при возникновении ошибки с правами."

#. type: Plain text
#: man-pages/man3/euidaccess.3:107
msgid ""
"This function always dereferences symbolic links.  If you need to check the "
"permissions on a symbolic link, use B<faccessat>(2)  with the flags "
"B<AT_EACCESS> and B<AT_SYMLINK_NOFOLLOW>."
msgstr ""
"Эта функция всегда разыменовывает символьные ссылки. Если вам нужно "
"проверить права символьной ссылки, используйте вызов B<faccessat>(2) с "
"флагами B<AT_EACCESS> и B<AT_SYMLINK_NOFOLLOW>."

#. type: Plain text
#: man-pages/man3/euidaccess.3:117
msgid ""
"B<access>(2), B<chmod>(2), B<chown>(2), B<faccessat>(2), B<open>(2), "
"B<setgid>(2), B<setuid>(2), B<stat>(2), B<credentials>(7), "
"B<path_resolution>(7)"
msgstr ""
"B<access>(2), B<chmod>(2), B<chown>(2), B<faccessat>(2), B<open>(2), "
"B<setgid>(2), B<setuid>(2), B<stat>(2), B<credentials>(7), "
"B<path_resolution>(7)"

#. type: TH
#: man-pages/man3/erf.3:35
#, no-wrap
msgid "ERF"
msgstr "ERF"

#. type: Plain text
#: man-pages/man3/erf.3:38
msgid "erf, erff, erfl, - error function"
msgstr "erf, erff, erfl - функция ошибки"

#. type: Plain text
#: man-pages/man3/erf.3:45
#, no-wrap
msgid ""
"B<double erf(double >I<x>B<);>\n"
"B<float erff(float >I<x>B<);>\n"
"B<long double erfl(long double >I<x>B<);>\n"
msgstr ""
"B<double erf(double >I<x>B<);>\n"
"B<float erff(float >I<x>B<);>\n"
"B<long double erfl(long double >I<x>B<);>\n"

#. type: Plain text
#: man-pages/man3/erf.3:56
msgid "B<erf>():"
msgstr "B<erf>():"

#. type: Plain text
#: man-pages/man3/erf.3:64
msgid "B<erff>(), B<erfl>():"
msgstr "B<erff>(), B<erfl>():"

#. type: Plain text
#: man-pages/man3/erf.3:74
msgid "These functions return the error function of I<x>, defined as"
msgstr "Эти функции возвращают функцию ошибки от I<x>, определённую как"

#. type: TP
#: man-pages/man3/erf.3:74
#, no-wrap
msgid "    erf(x) = 2/sqrt(pi)* integral from 0 to x of exp(-t*t) dt"
msgstr "    erf(x) = 2/sqrt(pi)* интеграл от 0 до x по exp(-t*t) dt"

#. type: Plain text
#: man-pages/man3/erf.3:80
msgid ""
"On success, these functions return the error function of I<x>, a value in "
"the range [-1,\\ 1]."
msgstr ""
"При успешном выполнении эти функции возвращают функцию ошибки от I<x>, "
"значение в диапазоне [-1,\\ 1]."

#. type: Plain text
#: man-pages/man3/erf.3:93
msgid "If I<x> is positive infinity (negative infinity), +1 (-1) is returned."
msgstr ""
"Если I<x> стремится к плюс или минус бесконечности, то будет возвращено +1 "
"или -1."

#. type: Plain text
#: man-pages/man3/erf.3:99
msgid ""
"If I<x> is subnormal, a range error occurs, and the return value is 2*x/"
"sqrt(pi)."
msgstr ""
"Если значение I<x> субнормально, то генерируется ошибка диапазона и "
"возвращается значение 2*x/sqrt(pi)."

#. type: TP
#: man-pages/man3/erf.3:106
#, no-wrap
msgid "Range error: result underflow (I<x> is subnormal)"
msgstr "Ошибка диапазона: результат исчерпал степень(число I<x> субнормально)"

#. type: tbl table
#: man-pages/man3/erf.3:131
#, no-wrap
msgid ""
"B<erf>(),\n"
"B<erff>(),\n"
"B<erfl>()"
msgstr ""
"B<erf>(),\n"
"B<erff>(),\n"
"B<erfl>()"

#. type: Plain text
#: man-pages/man3/erf.3:143
msgid "B<cerf>(3), B<erfc>(3), B<exp>(3)"
msgstr "B<cerf>(3), B<erfc>(3), B<exp>(3)"
