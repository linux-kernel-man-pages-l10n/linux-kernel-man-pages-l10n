# Copyright (C) 2014 Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
#
# Translators:
# Azamat Hackimov <azamat.hackimov@gmail.com>, 2012.
# Yuri Kozlov <yuray@komyakino.ru>, 2011-2014.
# Yuri Kozlov <yuray@komyakino.ru>, 2014.
msgid ""
msgstr ""
"Project-Id-Version: translation of man-pages\n"
"POT-Creation-Date: 2014-08-17 08:29+0400\n"
"PO-Revision-Date: 2014-09-10 13:50+0400\n"
"Last-Translator: Yuri Kozlov <yuray@komyakino.ru>\n"
"Language-Team: Russian <man-pages-ru-talks@lists.sourceforge.net>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ru\n"
"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n%10<"
"=4 && (n%100<10 || n%100>=20) ? 1 : 2);\n"
"X-Generator: Lokalize 1.5\n"

#. type: TH
#: man-pages/man7/environ.7:34
#, no-wrap
msgid "ENVIRON"
msgstr "ENVIRON"

#. type: TH
#: man-pages/man7/environ.7:34
#, no-wrap
msgid "2014-06-13"
msgstr "2014-06-13"

#. type: TH
#: man-pages/man7/environ.7:34
#, no-wrap
msgid "Linux"
msgstr "Linux"

#. type: TH
#: man-pages/man7/environ.7:34
#, no-wrap
msgid "Linux Programmer's Manual"
msgstr "Руководство программиста Linux"

#. type: SH
#: man-pages/man7/environ.7:35
#, no-wrap
msgid "NAME"
msgstr "ИМЯ"

#. type: Plain text
#: man-pages/man7/environ.7:37
msgid "environ - user environment"
msgstr "environ - пользовательское окружение"

#. type: SH
#: man-pages/man7/environ.7:37
#, no-wrap
msgid "SYNOPSIS"
msgstr "ОБЗОР"

#. type: Plain text
#: man-pages/man7/environ.7:40
#, no-wrap
msgid "B<extern char **>I<environ>B<;>\n"
msgstr "B<extern char **>I<environ>B<;>\n"

#. type: SH
#: man-pages/man7/environ.7:42
#, no-wrap
msgid "DESCRIPTION"
msgstr "ОПИСАНИЕ"

#. type: Plain text
#: man-pages/man7/environ.7:57
msgid ""
"The variable I<environ> points to an array of pointers to strings called the"
" \"environment\".  The last pointer in this array has the value NULL.  (This"
" variable must be declared in the user program, but is declared in the "
"header file I<E<lt>unistd.hE<gt>> in case the header files came from libc4 "
"or libc5, and in case they came from glibc and B<_GNU_SOURCE> was defined.)"
"  This array of strings is made available to the process by the B<exec>(3)  "
"call that started the process."
msgstr ""
"Переменная I<environ> указывает на массив указателей на строки, который "
"называют «окружением» (environment). Последний указатель в этом массиве имеет "
"значение NULL (данная переменная должна быть объявлена в программе "
"пользователя, а кроме того она объявлена в заголовочном файле I<E<lt>"
"unistd.hE<gt>> из библиотек libc4 или libc5, и из glibc, если определён "
"макрос B<_GNU_SOURCE>). Указанный массив строк, становится доступным процессу "
"функцией B<exec>(3), которая запускает процесс."

#. type: Plain text
#: man-pages/man7/environ.7:62
msgid ""
"By convention the strings in I<environ> have the form "
"\"I<name>B<=>I<value>\".  Common examples are:"
msgstr ""
"По договорённости, строки в I<environ> имеют вид «I<имя>B<=>I<значение>». Вот "
"некоторые примеры:"

#. type: TP
#: man-pages/man7/environ.7:62
#, no-wrap
msgid "B<USER>"
msgstr "B<USER>"

#. type: Plain text
#: man-pages/man7/environ.7:65
msgid "The name of the logged-in user (used by some BSD-derived programs)."
msgstr ""
"Имя пользователя, зарегистрированного в системе (используется некоторыми "
"программами, написанными для BSD)."

#. type: TP
#: man-pages/man7/environ.7:65
#, no-wrap
msgid "B<LOGNAME>"
msgstr "B<LOGNAME>"

#. type: Plain text
#: man-pages/man7/environ.7:68
msgid ""
"The name of the logged-in user (used by some System-V derived programs)."
msgstr ""
"Имя пользователя, зарегистрированного в системе (используется некоторыми "
"программами, написанными для System-V)."

#. type: TP
#: man-pages/man7/environ.7:68
#, no-wrap
msgid "B<HOME>"
msgstr "B<HOME>"

#. type: Plain text
#: man-pages/man7/environ.7:74
msgid ""
"A user's login directory, set by B<login>(1)  from the password file "
"B<passwd>(5)."
msgstr ""
"Домашний каталог пользователя, устанавливается программой B<login>(1) "
"согласно значению из файла паролей B<passwd>(5)."

#. type: TP
#: man-pages/man7/environ.7:74
#, no-wrap
msgid "B<LANG>"
msgstr "B<LANG>"

#. type: Plain text
#: man-pages/man7/environ.7:92
msgid ""
"The name of a locale to use for locale categories when not overridden by "
"B<LC_ALL> or more specific environment variables such as B<LC_COLLATE>, "
"B<LC_CTYPE>, B<LC_MESSAGES>, B<LC_MONETARY>, B<LC_NUMERIC>, and B<LC_TIME> "
"(see B<locale>(7)  for further details of the B<LC_*> environment "
"variables)."
msgstr ""
"Имя локали используется для категорий локали, если не заменено значением B<"
"LC_ALL> или более специфичными переменными окружения, такими как B<LC_COLLATE>"
", B<LC_CTYPE>, B<LC_MESSAGES>, B<LC_MONETARY>, B<LC_NUMERIC> и B<LC_TIME> "
"(подробней смотрите описание переменных окружения B<LC_*> в B<locale>(7))."

#. type: TP
#: man-pages/man7/environ.7:92
#, no-wrap
msgid "B<PATH>"
msgstr "B<PATH>"

#. type: Plain text
#: man-pages/man7/environ.7:107
msgid ""
"The sequence of directory prefixes that B<sh>(1)  and many other programs "
"apply in searching for a file known by an incomplete pathname.  The prefixes"
" are separated by \\(aqB<:>\\(aq.  (Similarly one has B<CDPATH> used by some"
" shells to find the target of a change directory command, B<MANPATH> used by"
" B<man>(1)  to find manual pages, and so on)"
msgstr ""
"Последовательность каталогов, которые B<sh>(1) и многие другие программы "
"будут применять в качестве префикса при поиске файла, если он задан неполным "
"именем Каталоги разделяются «B<:>» (похожим образом переменная B<CDPATH> "
"используется некоторыми командными оболочками для поиска каталога, в который "
"нужно перейти, B<MANPATH> используется командой B<man>(1) для поиска "
"справочных страниц и т. д.)."

#. type: TP
#: man-pages/man7/environ.7:107
#, no-wrap
msgid "B<PWD>"
msgstr "B<PWD>"

#. type: Plain text
#: man-pages/man7/environ.7:111
msgid "The current working directory.  Set by some shells."
msgstr ""
"Текущий рабочий каталог. Устанавливается некоторыми командными оболочками."

#. type: TP
#: man-pages/man7/environ.7:111
#, no-wrap
msgid "B<SHELL>"
msgstr "B<SHELL>"

#. type: Plain text
#: man-pages/man7/environ.7:114
msgid "The pathname of the user's login shell."
msgstr "Имя регистрационной командной оболочки пользователя."

#. type: TP
#: man-pages/man7/environ.7:114
#, no-wrap
msgid "B<TERM>"
msgstr "B<TERM>"

#. type: Plain text
#: man-pages/man7/environ.7:117
msgid "The terminal type for which output is to be prepared."
msgstr "Тип терминала, для которого будет подготавливаться вывод."

#. type: TP
#: man-pages/man7/environ.7:117
#, no-wrap
msgid "B<PAGER>"
msgstr "B<PAGER>"

#. type: Plain text
#: man-pages/man7/environ.7:120
msgid "The user's preferred utility to display text files."
msgstr "Предпочитаемая пользователем утилита просмотра текстовых файлов."

#. type: TP
#: man-pages/man7/environ.7:120
#, no-wrap
msgid "B<EDITOR>/B<VISUAL>"
msgstr "B<EDITOR>/B<VISUAL>"

#.  .TP
#.  .B BROWSER
#.  The user's preferred utility to browse URLs. Sequence of colon-separated
#.  browser commands. See http://www.catb.org/~esr/BROWSER/ .
#. type: Plain text
#: man-pages/man7/environ.7:127
msgid "The user's preferred utility to edit text files."
msgstr "Предпочитаемая пользователем утилита редактирования текстовых файлов."

#. type: Plain text
#: man-pages/man7/environ.7:145
msgid ""
"Further names may be placed in the environment by the I<export> command and "
"\"name=value\" in B<sh>(1), or by the I<setenv> command if you use "
"B<csh>(1).  Arguments may also be placed in the environment at the point of "
"an B<exec>(3).  A C program can manipulate its environment using the "
"functions B<getenv>(3), B<putenv>(3), B<setenv>(3), and B<unsetenv>(3)."
msgstr ""
"Вышеуказанные имена переменных могут быть помещены в окружение B<sh>(1) "
"командой I<export> и «имя=значение», или командой I<setenv>, если "
"используется B<csh>(1). При вызове B<exec>(3) в окружение также могут быть "
"помещены и аргументы. Программа, написанная на языке C, может изменять своё "
"окружение с помощью функций B<getenv>(3), B<putenv>(3), B<setenv>(3) и B<"
"unsetenv>(3)."

#. type: Plain text
#: man-pages/man7/environ.7:149
msgid ""
"Note that the behavior of many programs and library routines is influenced "
"by the presence or value of certain environment variables.  A random "
"collection:"
msgstr ""
"Заметим, что наличие или значения определённых переменных окружения может "
"отказывать влияние на поведение многих программ и библиотечных процедур. Вот "
"случайная подборка:"

#. type: Plain text
#: man-pages/man7/environ.7:158
msgid ""
"The variables B<LANG>, B<LANGUAGE>, B<NLSPATH>, B<LOCPATH>, B<LC_ALL>, "
"B<LC_MESSAGES>, and so on influence locale handling; see B<catopen>(3), "
"B<gettext>(3), and B<locale>(7)."
msgstr ""
"Переменные  B<LANG>, B<LANGUAGE>, B<NLSPATH>, B<LOCPATH>, B<LC_ALL>, B<"
"LC_MESSAGES> и т. д. влияют на работу с локалью; смотрите B<catopen>(3), B<"
"gettext>(3) и B<locale>(7)."

#. type: Plain text
#: man-pages/man7/environ.7:165
msgid ""
"B<TMPDIR> influences the path prefix of names created by B<tmpnam>(3)  and "
"other routines, and the temporary directory used by B<sort>(1)  and other "
"programs."
msgstr ""
"Переменная B<TMPDIR> влияет на путь файлов, создаваемых B<tmpnam>(3) и "
"некоторыми другими процедурами, а также на временный каталог, который "
"используется B<sort>(1) и некоторыми другими программами."

#. type: Plain text
#: man-pages/man7/environ.7:169
msgid ""
"B<LD_LIBRARY_PATH>, B<LD_PRELOAD> and other LD_* variables influence the "
"behavior of the dynamic loader/linker."
msgstr ""
"Переменные B<LD_LIBRARY_PATH>, B<LD_PRELOAD> и другие LD_* влияют на "
"поведение динамического загрузчика/компоновщика."

#. type: Plain text
#: man-pages/man7/environ.7:173
msgid ""
"B<POSIXLY_CORRECT> makes certain programs and library routines follow the "
"prescriptions of POSIX."
msgstr ""
"Переменная B<POSIXLY_CORRECT> влияет на определённые программы и библиотечные "
"вызовы таким образом, что они включают режим соответствия POSIX."

#. type: Plain text
#: man-pages/man7/environ.7:179
msgid "The behavior of B<malloc>(3)  is influenced by B<MALLOC_*> variables."
msgstr "На поведение B<malloc>(3) оказывают влияние переменные B<MALLOC_*>."

#. type: Plain text
#: man-pages/man7/environ.7:185
msgid ""
"The variable B<HOSTALIASES> gives the name of a file containing aliases to "
"be used with B<gethostbyname>(3)."
msgstr ""
"В переменной B<HOSTALIASES> задаётся имя файла, содержащего псевдонимы имени "
"узла, которые будут использованы в функции B<gethostbyname>(3)."

#. type: Plain text
#: man-pages/man7/environ.7:196
msgid ""
"B<TZ> and B<TZDIR> give timezone information used by B<tzset>(3)  and "
"through that by functions like B<ctime>(3), B<localtime>(3), B<mktime>(3), "
"B<strftime>(3).  See also B<tzselect>(8)."
msgstr ""
"В переменных B<TZ> и B<TZDIR> указывается информация о часовом поясе; они "
"используются в функциях B<tzset>(3), B<ctime>(3), B<localtime>(3), B<mktime>"
"(3), B<strftime>(3). Смотрите также B<tzselect>(8)."

#. type: Plain text
#: man-pages/man7/environ.7:200
msgid ""
"B<TERMCAP> gives information on how to address a given terminal (or gives "
"the name of a file containing such information)."
msgstr ""
"В переменной B<TERMCAP> указывается информация по работе с терминалом (можно "
"указать имя файла, содержащего такую информацию)."

#. type: Plain text
#: man-pages/man7/environ.7:203
msgid ""
"B<COLUMNS> and B<LINES> tell applications about the window size, possibly "
"overriding the actual size."
msgstr ""
"Через переменные B<COLUMNS> и B<LINES> приложение может узнать о размере окна "
"(возможно указать ненастоящий размер)."

#. type: Plain text
#: man-pages/man7/environ.7:208
msgid ""
"B<PRINTER> or B<LPDEST> may specify the desired printer to use.  See "
"B<lpr>(1)."
msgstr ""
"В переменной B<PRINTER> или B<LPDEST> можно указать предпочтительный для "
"печати принтер. Смотрите B<lpr>(1)."

#. type: Plain text
#: man-pages/man7/environ.7:210
msgid "Etc."
msgstr "и т.д."

#. type: SH
#: man-pages/man7/environ.7:210
#, no-wrap
msgid "BUGS"
msgstr "ДЕФЕКТЫ"

#. type: Plain text
#: man-pages/man7/environ.7:215
msgid ""
"Clearly there is a security risk here.  Many a system command has been "
"tricked into mischief by a user who specified unusual values for B<IFS> or "
"B<LD_LIBRARY_PATH>."
msgstr ""
"Честно говоря, использование переменных окружения таит в себе проблемы с "
"безопасностью. Многие системные команды могут неправильно работать, если "
"пользователь укажет неправильные значения для переменной B<IFS> или B<"
"LD_LIBRARY_PATH>."

#. type: Plain text
#: man-pages/man7/environ.7:248
msgid ""
"There is also the risk of name space pollution.  Programs like I<make> and "
"I<autoconf> allow overriding of default utility names from the environment "
"with similarly named variables in all caps.  Thus one uses B<CC> to select "
"the desired C compiler (and similarly B<MAKE>, B<AR>, B<AS>, B<FC>, B<LD>, "
"B<LEX>, B<RM>, B<YACC>, etc.).  However, in some traditional uses such an "
"environment variable gives options for the program instead of a pathname.  "
"Thus, one has B<MORE>, B<LESS>, and B<GZIP>.  Such usage is considered "
"mistaken, and to be avoided in new programs.  The authors of I<gzip> should "
"consider renaming their option to B<GZIP_OPT>."
msgstr ""
"Также есть риск засорения пространства имен. Такие программы как I<make> и I<"
"autoconf> позволяют заменять имена используемых по умолчанию утилит через "
"переменные окружения. Например, переменная B<CC> используется для выбора "
"нужного C-компилятора (и, похожим образом, можно использовать переменные B<"
"MAKE>, B<AR>, B<AS>, B<FC>, B<LD>, B<LEX>, B<RM>, B<YACC> и т.д.). Однако, "
"есть случаи, когда в переменных окружения задают параметры программ, а не их "
"имена (например, B<MORE>, B<LESS> и B<GZIP>). Использование таких имён для "
"переменных окружения является ошибочным и не должно применяться в новых "
"программах. Авторы I<gzip> должны бы переименовать переменную в B<GZIP_OPT>."

#. type: SH
#: man-pages/man7/environ.7:248
#, no-wrap
msgid "SEE ALSO"
msgstr "СМОТРИТЕ ТАКЖЕ"

#. type: Plain text
#: man-pages/man7/environ.7:264
msgid ""
"B<env>(1), B<bash>(1), B<csh>(1), B<login>(1), B<printenv>(1), B<sh>(1), "
"B<tcsh>(1), B<execve>(2), B<clearenv>(3), B<exec>(3), B<getenv>(3), "
"B<putenv>(3), B<setenv>(3), B<unsetenv>(3), B<locale>(7), B<ld.so>(8)"
msgstr ""
"B<env>(1), B<bash>(1), B<csh>(1), B<login>(1), B<printenv>(1), B<sh>(1), "
"B<tcsh>(1), B<execve>(2), B<clearenv>(3), B<exec>(3), B<getenv>(3), "
"B<putenv>(3), B<setenv>(3), B<unsetenv>(3), B<locale>(7), B<ld.so>(8)"

#. type: TH
#: man-pages/man7/epoll.7:21
#, no-wrap
msgid "EPOLL"
msgstr "EPOLL"

#. type: TH
#: man-pages/man7/epoll.7:21
#, no-wrap
msgid "2014-07-08"
msgstr "2014-07-08"

#. type: Plain text
#: man-pages/man7/epoll.7:24
msgid "epoll - I/O event notification facility"
msgstr "epoll - средство уведомления о событии ввода-вывода"

#. type: Plain text
#: man-pages/man7/epoll.7:26
msgid "B<#include E<lt>sys/epoll.hE<gt>>"
msgstr "B<#include E<lt>sys/epoll.hE<gt>>"

#. type: Plain text
#: man-pages/man7/epoll.7:40
msgid ""
"The B<epoll> API performs a similar task to B<poll>(2): monitoring multiple "
"file descriptors to see if I/O is possible on any of them.  The B<epoll> API"
" can be used either as an edge-triggered or a level-triggered interface and "
"scales well to large numbers of watched file descriptors.  The following "
"system calls are provided to create and manage an B<epoll> instance:"
msgstr ""
"Программный интерфейс B<epoll> выполняется схожую с B<poll>(2) задачу: следит "
"за несколькими файловыми дескрипторами и ждёт, когда станет возможен "
"ввод-вывод с одним из них. Программный интерфейс B<epoll> можно использовать "
"либо в режиме edge-triggered, либо в level-triggered и применять для слежения "
"за достаточно большим количеством файловых дескрипторов. Для создания и "
"управления экземпляром B<epoll> служат следующие системные вызовы:"

#. type: IP
#: man-pages/man7/epoll.7:40 man-pages/man7/epoll.7:49
#: man-pages/man7/epoll.7:57
#, no-wrap
msgid "*"
msgstr "*"

#. type: Plain text
#: man-pages/man7/epoll.7:49
msgid ""
"B<epoll_create>(2)  creates an B<epoll> instance and returns a file "
"descriptor referring to that instance.  (The more recent B<epoll_create1>(2)"
"  extends the functionality of B<epoll_create>(2).)"
msgstr ""
"Вызов B<epoll_create>(2) создаёт экземпляр B<epoll> и возвращает файловый "
"дескриптор, указывающий на этот экземпляр (более новый B<epoll_create1>(2) "
"расширяет возможности B<epoll_create>(2))."

#. type: Plain text
#: man-pages/man7/epoll.7:57
msgid ""
"Interest in particular file descriptors is then registered via "
"B<epoll_ctl>(2).  The set of file descriptors currently registered on an "
"B<epoll> instance is sometimes called an I<epoll> set."
msgstr ""
"Затем с помощью B<epoll_ctl>(2) регистрируются интересующие файловые "
"дескрипторы. Список зарегистрированных в экземпляре B<epoll> файловых "
"дескрипторов называется набором I<epoll>."

#. type: Plain text
#: man-pages/man7/epoll.7:61
msgid ""
"B<epoll_wait>(2)  waits for I/O events, blocking the calling thread if no "
"events are currently available."
msgstr ""
"Вызов B<epoll_wait>(2) ждёт наступления событий ввода-вывода, блокируя "
"вызывающую нить, если событий уже не произошло."

#. type: SS
#: man-pages/man7/epoll.7:61
#, no-wrap
msgid "Level-triggered and edge-triggered"
msgstr "Режимы level-triggered и edge-triggered"

#. type: Plain text
#: man-pages/man7/epoll.7:70
msgid ""
"The B<epoll> event distribution interface is able to behave both as edge-"
"triggered (ET) and as level-triggered (LT).  The difference between the two "
"mechanisms can be described as follows.  Suppose that this scenario happens:"
msgstr ""
"Существует два режима выдачи событий B<epoll>: edge-triggered (ET) и "
"level-triggered (LT). Разницу между ними можно описать так. Предположим, что "
"реализован следующий сценарий событий:"

#. type: IP
#: man-pages/man7/epoll.7:70
#, no-wrap
msgid "1."
msgstr "1."

#. type: Plain text
#: man-pages/man7/epoll.7:76
msgid ""
"The file descriptor that represents the read side of a pipe (I<rfd>)  is "
"registered on the B<epoll> instance."
msgstr ""
"Файловый дескриптор, представляющий читающую сторону канала (I<rfd>), "
"регистрируется в экземпляре B<epoll>."

#. type: IP
#: man-pages/man7/epoll.7:76
#, no-wrap
msgid "2."
msgstr "2."

#. type: Plain text
#: man-pages/man7/epoll.7:78
msgid "A pipe writer writes 2 kB of data on the write side of the pipe."
msgstr ""
"Пишущая сторона канала записывает 2КБ данных на записываемой стороне канала."

#. type: IP
#: man-pages/man7/epoll.7:78
#, no-wrap
msgid "3."
msgstr "3."

#. type: Plain text
#: man-pages/man7/epoll.7:84
msgid ""
"A call to B<epoll_wait>(2)  is done that will return I<rfd> as a ready file "
"descriptor."
msgstr ""
"Вызов B<epoll_wait>(2) завершается и возвращает I<rfd> как готовый файловый "
"дескриптор."

#. type: IP
#: man-pages/man7/epoll.7:84
#, no-wrap
msgid "4."
msgstr "4."

#. type: Plain text
#: man-pages/man7/epoll.7:87
msgid "The pipe reader reads 1 kB of data from I<rfd>."
msgstr "Читающая сторона канала считывает 1КБ данных из I<rfd>."

#. type: IP
#: man-pages/man7/epoll.7:87
#, no-wrap
msgid "5."
msgstr "5."

#. type: Plain text
#: man-pages/man7/epoll.7:91
msgid "A call to B<epoll_wait>(2)  is done."
msgstr "Вызов B<epoll_wait>(2) завершается."

#. type: Plain text
#: man-pages/man7/epoll.7:126
msgid ""
"If the I<rfd> file descriptor has been added to the B<epoll> interface using"
" the B<EPOLLET> (edge-triggered)  flag, the call to B<epoll_wait>(2)  done "
"in step B<5> will probably hang despite the available data still present in "
"the file input buffer; meanwhile the remote peer might be expecting a "
"response based on the data it already sent.  The reason for this is that "
"edge-triggered mode delivers events only when changes occur on the monitored"
" file descriptor.  So, in step B<5> the caller might end up waiting for some"
" data that is already present inside the input buffer.  In the above "
"example, an event on I<rfd> will be generated because of the write done in "
"B<2> and the event is consumed in B<3>.  Since the read operation done in "
"B<4> does not consume the whole buffer data, the call to B<epoll_wait>(2)  "
"done in step B<5> might block indefinitely."
msgstr ""
"Если файловый дескриптор I<rfd> добавлен к экземпляру B<epoll> с указанным "
"флагом B<EPOLLET> (edge-triggered), то вызов B<epoll_wait>(2) на шаге 5, "
"вероятно, повиснет, несмотря на имеющие данные в буфере ввода; в это же время "
"удалённая сторона может ожидать подтверждения приёма уже отправленных данных. "
"Причиной этого является то, что в режиме edge-triggered события доставляются "
"только когда происходит изменение состояния отслеживаемого файлового "
"дескриптора. Поэтому в шаге B<5> вызывающий может бесконечно ждать появления "
"данных, хотя они уже есть в буфере ввода. В приведённом выше примере событие "
"для I<rfd> будет сгенерировано из-за операции записи, сделанной в шаге B<2>, "
"и это событие будет обработано в шаге B<3>. Так как операция в шаге B<4>, не "
"прочитала все данные из буфера, вызов B<epoll_wait>(2) в шаге B<5> может "
"заблокироваться навсегда."

#. type: Plain text
#: man-pages/man7/epoll.7:136
msgid ""
"An application that employs the B<EPOLLET> flag should use nonblocking file "
"descriptors to avoid having a blocking read or write starve a task that is "
"handling multiple file descriptors.  The suggested way to use B<epoll> as an"
" edge-triggered (B<EPOLLET>)  interface is as follows:"
msgstr ""
"Приложение, которое применяет флаг B<EPOLLET>, должно использовать "
"неблокирующие файловые дескрипторы, чтобы избежать приостановки задания, "
"обрабатывающего множество файловых дескрипторов, из-за блокировок чтения или "
"записи. Предлагаемый способ использования B<epoll> с интерфейсом Edge "
"Triggered (B<EPOLLET>):"

#. type: TP
#: man-pages/man7/epoll.7:137
#, no-wrap
msgid "B<i>"
msgstr "B<i>"

#. type: Plain text
#: man-pages/man7/epoll.7:140
msgid "with nonblocking file descriptors; and"
msgstr "неблокирующие файловые дескрипторы; и"

#. type: TP
#: man-pages/man7/epoll.7:140
#, no-wrap
msgid "B<ii>"
msgstr "B<ii>"

#. type: Plain text
#: man-pages/man7/epoll.7:148
msgid ""
"by waiting for an event only after B<read>(2)  or B<write>(2)  return "
"B<EAGAIN>."
msgstr ""
"ожидание события только после того, как B<read>(2) или B<write>(2) возвратят "
"B<EAGAIN>."

#. type: Plain text
#: man-pages/man7/epoll.7:159
msgid ""
"By contrast, when used as a level-triggered interface (the default, when "
"B<EPOLLET> is not specified), B<epoll> is simply a faster B<poll>(2), and "
"can be used wherever the latter is used since it shares the same semantics."
msgstr ""
"Напротив, при использовании интерфейса level-triggered (по умолчанию, если не "
"указан B<EPOLLET>) B<epoll> проще и быстрее B<poll>(2), и может быть "
"использован везде, где используется последний, так как имеет ту же семантику."

#. type: Plain text
#: man-pages/man7/epoll.7:176
msgid ""
"Since even with edge-triggered B<epoll>, multiple events can be generated "
"upon receipt of multiple chunks of data, the caller has the option to "
"specify the B<EPOLLONESHOT> flag, to tell B<epoll> to disable the associated"
" file descriptor after the receipt of an event with B<epoll_wait>(2).  When "
"the B<EPOLLONESHOT> flag is specified, it is the caller's responsibility to "
"rearm the file descriptor using B<epoll_ctl>(2)  with B<EPOLL_CTL_MOD>."
msgstr ""
"Так как даже с edge-triggered B<epoll> при получении нескольких порций данных "
"могут генерироваться множественные события, вызывающий может задать флаг B<"
"EPOLLONESHOT>, который указывает B<epoll> отключить связанный файловый "
"дескриптор после приёма события с помощью B<epoll_wait>(2). Если указан флаг "
"B<EPOLLONESHOT>, то вызывающий должен переустановить файловый дескриптор с "
"помощью B<epoll_ctl>(2) с флагом B<EPOLL_CTL_MOD>."

#. type: SS
#: man-pages/man7/epoll.7:176
#, no-wrap
msgid "Interaction with autosleep"
msgstr "Взаимодействие с autosleep"

#. type: Plain text
#: man-pages/man7/epoll.7:188
msgid ""
"If the system is in B<autosleep> mode via I</sys/power/autosleep> and an "
"event happens which wakes the device from sleep, the device driver will only"
" keep the device awake until that event is queued.  To keep the device awake"
" until the event has been processed, it is necessary to use the B<epoll>(7)"
"  B<EPOLLWAKEUP> flag."
msgstr ""
"Если система в режиме B<autosleep> посредством I</sys/power/autosleep> и "
"происходит событие, которое пробуждает устройство, то драйвер устройства "
"держит устройство проснувшимся только, пока событие ставится в очередь. "
"Чтобы устройство не заснуло пока не обработает событие, необходимо "
"использовать флаг B<epoll>(7) B<EPOLLWAKEUP>."

#. type: Plain text
#: man-pages/man7/epoll.7:207
msgid ""
"When the B<EPOLLWAKEUP> flag is set in the B<events> field for a I<struct "
"epoll_event>, the system will be kept awake from the moment the event is "
"queued, through the B<epoll_wait>(2)  call which returns the event until the"
" subsequent B<epoll_wait>(2)  call.  If the event should keep the system "
"awake beyond that time, then a separate I<wake_lock> should be taken before "
"the second B<epoll_wait>(2)  call."
msgstr ""
"Флаг B<EPOLLWAKEUP> задаётся в поле B<events> для I<struct "
"epoll_event>; система будет оставаться разбуженной с момента когда "
"событие поступает в очередь, пока не закончится работа вызова "
"B<epoll_wait>(2), возвращающий событие, и до последующего вызова "
"B<epoll_wait>(2). "
"Если событие должно держать систему разбуженной дольше, то "
"нужно применить отдельный I<wake_lock> перед вторым вызовом "
"B<epoll_wait>(2)."

#. type: SS
#: man-pages/man7/epoll.7:207
#, no-wrap
msgid "/proc interfaces"
msgstr "Интерфейсы /proc"

#.  Following was added in 2.6.28, but them removed in 2.6.29
#.  .TP
#.  .IR /proc/sys/fs/epoll/max_user_instances " (since Linux 2.6.28)"
#.  This specifies an upper limit on the number of epoll instances
#.  that can be created per real user ID.
#. type: Plain text
#: man-pages/man7/epoll.7:215
msgid ""
"The following interfaces can be used to limit the amount of kernel memory "
"consumed by epoll:"
msgstr ""
"Для ограничения потребления epoll памяти ядра, можно использовать следующие "
"интерфейсы:"

#. type: TP
#: man-pages/man7/epoll.7:215
#, no-wrap
msgid "I</proc/sys/fs/epoll/max_user_watches> (since Linux 2.6.28)"
msgstr "I</proc/sys/fs/epoll/max_user_watches> (начиная с Linux 2.6.28)"

#.  2.6.29 (in 2.6.28, the default was 1/32 of lowmem)
#. type: Plain text
#: man-pages/man7/epoll.7:229
msgid ""
"This specifies a limit on the total number of file descriptors that a user "
"can register across all epoll instances on the system.  The limit is per "
"real user ID.  Each registered file descriptor costs roughly 90 bytes on a "
"32-bit kernel, and roughly 160 bytes on a 64-bit kernel.  Currently, the "
"default value for I<max_user_watches> is 1/25 (4%) of the available low "
"memory, divided by the registration cost in bytes."
msgstr ""
"Задаёт ограничение на общее количество файловых дескрипторов, которые "
"пользователь может зарегистрировать во всех экземплярах epoll в системе. "
"Ограничение привязывается к реальному идентификатору пользователя. Каждый "
"зарезервированный файловый дескриптор занимает, приблизительно, 90 байт в "
"32-битном ядре, и, приблизительно, 160 байт в 64-битном ядре. В настоящее "
"время, значение по умолчанию для I<max_user_watches> равно 1/25 (4%) "
"доступной памяти ядра (low memory), поделённое на значение размера "
"дескриптора в байтах."

#. type: SS
#: man-pages/man7/epoll.7:229
#, no-wrap
msgid "Example for suggested usage"
msgstr "Примеры использования"

#. type: Plain text
#: man-pages/man7/epoll.7:258
msgid ""
"While the usage of B<epoll> when employed as a level-triggered interface "
"does have the same semantics as B<poll>(2), the edge-triggered usage "
"requires more clarification to avoid stalls in the application event loop.  "
"In this example, listener is a nonblocking socket on which B<listen>(2)  has"
" been called.  The function I<do_use_fd()> uses the new ready file "
"descriptor until B<EAGAIN> is returned by either B<read>(2)  or B<write>(2)."
"  An event-driven state machine application should, after having received "
"B<EAGAIN>, record its current state so that at the next call to "
"I<do_use_fd()> it will continue to B<read>(2)  or B<write>(2)  from where it"
" stopped before."
msgstr ""
"При применении B<epoll> с интерфейсом  level-triggered он имеет ту же "
"семантику что и B<poll>(2), а при edge-triggered требует больших проверок для "
"избежания зависаний приложения в событийном цикле. В этом примере, слушающим "
"является неблокирующий сокет, для которого был вызван B<listen>(2). Функция "
"I<do_use_fd>() использует новый готовый файловый дескриптор до тех пор, пока "
"не возвратится B<EAGAIN> от B<read>(2) или B<write>(2). Приложение на основе "
"машины состояний должно после получения B<EAGAIN> записать своё текущее "
"состояние так, чтобы последующий вызов I<do_use_fd>() продолжил выполнять B<"
"read>(2) или B<write>(2) с места остановки."

#. type: Plain text
#: man-pages/man7/epoll.7:264
#, no-wrap
msgid ""
"#define MAX_EVENTS 10\n"
"struct epoll_event ev, events[MAX_EVENTS];\n"
"int listen_sock, conn_sock, nfds, epollfd;\n"
msgstr ""
"#define MAX_EVENTS 10\nstruct epoll_event ev, events[MAX_EVENTS];\nint "
"listen_sock, conn_sock, nfds, epollfd;\n"

#. type: Plain text
#: man-pages/man7/epoll.7:267
#, no-wrap
msgid ""
"/* Set up listening socket, \\(aqlisten_sock\\(aq (socket(),\n"
"   bind(), listen()) */\n"
msgstr ""
"/* Настройка слушающего сокета, \\(aqlisten_sock\\(aq (socket(),\n   bind(), "
"listen()) */\n"

#. type: Plain text
#: man-pages/man7/epoll.7:273
#, no-wrap
msgid ""
"epollfd = epoll_create(10);\n"
"if (epollfd == -1) {\n"
"    perror(\"epoll_create\");\n"
"    exit(EXIT_FAILURE);\n"
"}\n"
msgstr ""
"epollfd = epoll_create(10);\nif (epollfd == -1) {\n    "
"perror(\"epoll_create\");\n    exit(EXIT_FAILURE);\n}\n"

#. type: Plain text
#: man-pages/man7/epoll.7:280
#, no-wrap
msgid ""
"ev.events = EPOLLIN;\n"
"ev.data.fd = listen_sock;\n"
"if (epoll_ctl(epollfd, EPOLL_CTL_ADD, listen_sock, &ev) == -1) {\n"
"    perror(\"epoll_ctl: listen_sock\");\n"
"    exit(EXIT_FAILURE);\n"
"}\n"
msgstr ""
"ev.events = EPOLLIN;\nev.data.fd = listen_sock;\nif (epoll_ctl(epollfd, "
"EPOLL_CTL_ADD, listen_sock, &ev) == -1) {\n    perror(\"epoll_ctl: "
"listen_sock\");\n    exit(EXIT_FAILURE);\n}\n"

#. type: Plain text
#: man-pages/man7/epoll.7:287
#, no-wrap
msgid ""
"for (;;) {\n"
"    nfds = epoll_wait(epollfd, events, MAX_EVENTS, -1);\n"
"    if (nfds == -1) {\n"
"        perror(\"epoll_pwait\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"for (;;) {\n    nfds = epoll_wait(epollfd, events, MAX_EVENTS, -1);\n    if "
"(nfds == -1) {\n        perror(\"epoll_pwait\");\n        "
"exit(EXIT_FAILURE);\n    }\n"

#. type: Plain text
#: man-pages/man7/epoll.7:309
#, no-wrap
msgid ""
"    for (n = 0; n E<lt> nfds; ++n) {\n"
"        if (events[n].data.fd == listen_sock) {\n"
"            conn_sock = accept(listen_sock,\n"
"                            (struct sockaddr *) &local, &addrlen);\n"
"            if (conn_sock == -1) {\n"
"                perror(\"accept\");\n"
"                exit(EXIT_FAILURE);\n"
"            }\n"
"            setnonblocking(conn_sock);\n"
"            ev.events = EPOLLIN | EPOLLET;\n"
"            ev.data.fd = conn_sock;\n"
"            if (epoll_ctl(epollfd, EPOLL_CTL_ADD, conn_sock,\n"
"                        &ev) == -1) {\n"
"                perror(\"epoll_ctl: conn_sock\");\n"
"                exit(EXIT_FAILURE);\n"
"            }\n"
"        } else {\n"
"            do_use_fd(events[n].data.fd);\n"
"        }\n"
"    }\n"
"}\n"
msgstr ""
"    for (n = 0; n E<lt> nfds; ++n) {\n        if (events[n].data.fd == "
"listen_sock) {\n            conn_sock = accept(listen_sock,\n                 "
"           (struct sockaddr *) &local, &addrlen);\n            if (conn_sock "
"== -1) {\n                perror(\"accept\");\n                "
"exit(EXIT_FAILURE);\n            }\n            setnonblocking(conn_sock);\n  "
"          ev.events = EPOLLIN | EPOLLET;\n            ev.data.fd = "
"conn_sock;\n            if (epoll_ctl(epollfd, EPOLL_CTL_ADD, conn_sock,\n    "
"                    &ev) == -1) {\n                perror(\"epoll_ctl: "
"conn_sock\");\n                exit(EXIT_FAILURE);\n            }\n        } "
"else {\n            do_use_fd(events[n].data.fd);\n        }\n    }\n}\n"

#. type: Plain text
#: man-pages/man7/epoll.7:328
msgid ""
"When used as an edge-triggered interface, for performance reasons, it is "
"possible to add the file descriptor inside the B<epoll> interface "
"(B<EPOLL_CTL_ADD>)  once by specifying (B<EPOLLIN>|B<EPOLLOUT>).  This "
"allows you to avoid continuously switching between B<EPOLLIN> and "
"B<EPOLLOUT> calling B<epoll_ctl>(2)  with B<EPOLL_CTL_MOD>."
msgstr ""
"При использовании интерфейса edge-triggered для большей производительности "
"можно однократно добавить файловый дескриптор внутрь интерфейса B<epoll> (B<"
"EPOLL_CTL_ADD>), указав (B<EPOLLIN>|B<EPOLLOUT>). Это позволит вам избежать "
"постоянного переключения между B<EPOLLIN> и B<EPOLLOUT>, вызывающими B<"
"epoll_ctl>(2) c B<EPOLL_CTL_MOD>."

#. type: SS
#: man-pages/man7/epoll.7:328
#, no-wrap
msgid "Questions and answers"
msgstr "Вопросы и ответы"

#. type: TP
#: man-pages/man7/epoll.7:329
#, no-wrap
msgid "B<Q0>"
msgstr "B<Q0>"

#. type: Plain text
#: man-pages/man7/epoll.7:334
msgid ""
"What is the key used to distinguish the file descriptors registered in an "
"B<epoll> set?"
msgstr ""
"Как различать зарегистрированные файловые дескрипторы в наборе B<epoll>?"

#. type: TP
#: man-pages/man7/epoll.7:334
#, no-wrap
msgid "B<A0>"
msgstr "B<A0>"

#. type: Plain text
#: man-pages/man7/epoll.7:340
msgid ""
"The key is the combination of the file descriptor number and the open file "
"description (also known as an \"open file handle\", the kernel's internal "
"representation of an open file)."
msgstr ""
"Уникальной комбинацией является номер файлового дескриптора и описание "
"открытого файла (так называемый «описатель открытого файла» — внутреннее "
"представление открытого файла в ядре)."

#. type: TP
#: man-pages/man7/epoll.7:340
#, no-wrap
msgid "B<Q1>"
msgstr "B<Q1>"

#. type: Plain text
#: man-pages/man7/epoll.7:345
msgid ""
"What happens if you register the same file descriptor on an B<epoll> "
"instance twice?"
msgstr ""
"Что случится, если зарегистрировать один файловый дескриптор в экземпляре B<"
"epoll> дважды?"

#. type: TP
#: man-pages/man7/epoll.7:345
#, no-wrap
msgid "B<A1>"
msgstr "B<A1>"

#.  But a descriptor duplicated by fork(2) can't be added to the
#.  set, because the [file *, fd] pair is already in the epoll set.
#.  That is a somewhat ugly inconsistency.  On the one hand, a child process
#.  cannot add the duplicate file descriptor to the epoll set.  (In every
#.  other case that I can think of, descriptors duplicated by fork have
#.  similar semantics to descriptors duplicated by dup() and friends.)  On
#.  the other hand, the very fact that the child has a duplicate of the
#.  descriptor means that even if the parent closes its descriptor, then
#.  epoll_wait() in the parent will continue to receive notifications for
#.  that descriptor because of the duplicated descriptor in the child.
#.  See http://thread.gmane.org/gmane.linux.kernel/596462/
#.  "epoll design problems with common fork/exec patterns"
#.  mtk, Feb 2008
#. type: Plain text
#: man-pages/man7/epoll.7:376
msgid ""
"You will probably get B<EEXIST>.  However, it is possible to add a duplicate"
" (B<dup>(2), B<dup2>(2), B<fcntl>(2)  B<F_DUPFD>)  descriptor to the same "
"B<epoll> instance.  This can be a useful technique for filtering events, if "
"the duplicate file descriptors are registered with different I<events> "
"masks."
msgstr ""
"Вероятно, вы получите B<EEXIST>. Однако возможно добавить дубликат "
"дескриптора (B<dup>(2), B<dup2>(2), B<fcntl>(2)  B<F_DUPFD>) в тот же "
"экземпляр B<epoll>. Это может быть полезно для фильтрующих событий, если "
"дубликаты файловых дескрипторов регистрируются с разными масками I<events>."

#. type: TP
#: man-pages/man7/epoll.7:376
#, no-wrap
msgid "B<Q2>"
msgstr "B<Q2>"

#. type: Plain text
#: man-pages/man7/epoll.7:384
msgid ""
"Can two B<epoll> instances wait for the same file descriptor? If so, are "
"events reported to both B<epoll> file descriptors?"
msgstr ""
"Могут ли два экземпляра B<epoll> ожидать один файловый дескриптор? Если да, "
"то сообщаются ли события в оба файловых дескриптора B<epoll>?"

#. type: TP
#: man-pages/man7/epoll.7:384
#, no-wrap
msgid "B<A2>"
msgstr "B<A2>"

#. type: Plain text
#: man-pages/man7/epoll.7:388
msgid ""
"Yes, and events would be reported to both.  However, careful programming may"
" be needed to do this correctly."
msgstr ""
"Да, и события будут доходить в оба. Однако, чтобы сделать это правильно, "
"нужна внимательность к деталям."

#. type: TP
#: man-pages/man7/epoll.7:388
#, no-wrap
msgid "B<Q3>"
msgstr "B<Q3>"

#. type: Plain text
#: man-pages/man7/epoll.7:393
msgid "Is the B<epoll> file descriptor itself poll/epoll/selectable?"
msgstr ""
"Могут ли операции poll/epoll/select применяться к самому файловому "
"дескриптору B<epoll>?"

#. type: TP
#: man-pages/man7/epoll.7:393
#, no-wrap
msgid "B<A3>"
msgstr "B<A3>"

#. type: Plain text
#: man-pages/man7/epoll.7:400
msgid ""
"Yes.  If an B<epoll> file descriptor has events waiting, then it will "
"indicate as being readable."
msgstr ""
"Да. Если файловый дескриптор B<epoll> имеет ожидающие события, то он будет "
"помечен как доступный для чтения."

#. type: TP
#: man-pages/man7/epoll.7:400
#, no-wrap
msgid "B<Q4>"
msgstr "B<Q4>"

#. type: Plain text
#: man-pages/man7/epoll.7:405
msgid ""
"What happens if one attempts to put an B<epoll> file descriptor into its own"
" file descriptor set?"
msgstr ""
"Что случится, если попытаться поместить файловый дескриптор B<epoll> в свой "
"собственный набор файловых дескрипторов?"

#. type: TP
#: man-pages/man7/epoll.7:405
#, no-wrap
msgid "B<A4>"
msgstr "B<A4>"

#. type: Plain text
#: man-pages/man7/epoll.7:416
msgid ""
"The B<epoll_ctl>(2)  call will fail (B<EINVAL>).  However, you can add an "
"B<epoll> file descriptor inside another B<epoll> file descriptor set."
msgstr ""
"Вызов B<epoll_ctl>(2) завершится ошибкой (B<EINVAL>). Однако вы можете "
"добавлять файловый дескриптор B<epoll> внутрь другого набора файлового "
"дескриптора B<epoll>."

#. type: TP
#: man-pages/man7/epoll.7:416
#, no-wrap
msgid "B<Q5>"
msgstr "B<Q5>"

#. type: Plain text
#: man-pages/man7/epoll.7:421
msgid ""
"Can I send an B<epoll> file descriptor over a UNIX domain socket to another "
"process?"
msgstr ""
"Можно ли отправить файловый дескриптор B<epoll> через доменный сокет UNIX "
"другому процессу?"

#. type: TP
#: man-pages/man7/epoll.7:421
#, no-wrap
msgid "B<A5>"
msgstr "B<A5>"

#. type: Plain text
#: man-pages/man7/epoll.7:427
msgid ""
"Yes, but it does not make sense to do this, since the receiving process "
"would not have copies of the file descriptors in the B<epoll> set."
msgstr ""
"Да, но это не имеет смысла, так как принимающий процесс не имеет копий "
"файловых дескрипторов в наборе B<epoll>."

#. type: TP
#: man-pages/man7/epoll.7:427
#, no-wrap
msgid "B<Q6>"
msgstr "B<Q6>"

#. type: Plain text
#: man-pages/man7/epoll.7:432
msgid ""
"Will closing a file descriptor cause it to be removed from all B<epoll> sets"
" automatically?"
msgstr ""
"Приводит ли закрытие файлового дескриптора к его автоматическому удалению из "
"всех наборов B<epoll>?"

#. type: TP
#: man-pages/man7/epoll.7:432
#, no-wrap
msgid "B<A6>"
msgstr "B<A6>"

#. type: Plain text
#: man-pages/man7/epoll.7:460
msgid ""
"Yes, but be aware of the following point.  A file descriptor is a reference "
"to an open file description (see B<open>(2)).  Whenever a descriptor is "
"duplicated via B<dup>(2), B<dup2>(2), B<fcntl>(2)  B<F_DUPFD>, or "
"B<fork>(2), a new file descriptor referring to the same open file "
"description is created.  An open file description continues to exist until "
"all file descriptors referring to it have been closed.  A file descriptor is"
" removed from an B<epoll> set only after all the file descriptors referring "
"to the underlying open file description have been closed (or before if the "
"descriptor is explicitly removed using B<epoll_ctl>(2)  B<EPOLL_CTL_DEL>).  "
"This means that even after a file descriptor that is part of an B<epoll> set"
" has been closed, events may be reported for that file descriptor if other "
"file descriptors referring to the same underlying file description remain "
"open."
msgstr ""
"Да, но учтите следующее. Файловый дескриптор — это ссылка на описание "
"открытого файла (смотрите B<open>(2)). Чем бы не была сделана копия "
"дескриптора — B<dup>(2), B<dup2>(2), B<fcntl>(2)  B<F_DUPFD> или B<fork>(2) — "
"новый файловый дескриптор ссылается на одно и же созданное когда-то описание "
"открытого файла. Описание открытого файла продолжает существовать до тех пор, "
"пока все ссылающиеся на него файловые дескрипторы не будут закрыты. Файловый "
"дескриптор удаляется из набора B<epoll> только после того, как все файловые "
"дескрипторы, ссылающиеся на нижележащее описание открытого файла, будут "
"закрыты (или раньше, если дескриптор явно удаляется с помощью B<epoll_ctl>(2) "
" B<EPOLL_CTL_DEL>). Это означает, что даже после того, как файловый "
"дескриптор — часть набора B<epoll> — был закрыт, события по этому файловому "
"дескриптору могут продолжать приходить, если другие файловые дескрипторы "
"ссылаются на то же нижележащее описание файла, оставшегося открытым."

#. type: TP
#: man-pages/man7/epoll.7:460
#, no-wrap
msgid "B<Q7>"
msgstr "B<Q7>"

#. type: Plain text
#: man-pages/man7/epoll.7:465
msgid ""
"If more than one event occurs between B<epoll_wait>(2)  calls, are they "
"combined or reported separately?"
msgstr ""
"Если между вызовами B<epoll_wait>(2) придёт более одного события, то они "
"будут объединены или о них будет сообщено по отдельности?"

#. type: TP
#: man-pages/man7/epoll.7:465
#, no-wrap
msgid "B<A7>"
msgstr "B<A7>"

#. type: Plain text
#: man-pages/man7/epoll.7:468
msgid "They will be combined."
msgstr "Они будут объединены."

#. type: TP
#: man-pages/man7/epoll.7:468
#, no-wrap
msgid "B<Q8>"
msgstr "B<Q8>"

#. type: Plain text
#: man-pages/man7/epoll.7:472
msgid ""
"Does an operation on a file descriptor affect the already collected but not "
"yet reported events?"
msgstr ""
"Влияет ли операция над файловым дескриптором на уже собранные, но пока ещё не "
"сообщенные события?"

#. type: TP
#: man-pages/man7/epoll.7:472
#, no-wrap
msgid "B<A8>"
msgstr "B<A8>"

#. type: Plain text
#: man-pages/man7/epoll.7:478
msgid ""
"You can do two operations on an existing file descriptor.  Remove would be "
"meaningless for this case.  Modify will reread available I/O."
msgstr ""
"Вы можете выполнить две операции на существующем файловом дескрипторе. "
"Удаление в этом случае бессмысленно. Изменение приведёт к повторному чтению "
"доступного ввода/вывода."

#. type: TP
#: man-pages/man7/epoll.7:478
#, no-wrap
msgid "B<Q9>"
msgstr "B<Q9>"

#. type: Plain text
#: man-pages/man7/epoll.7:486
msgid ""
"Do I need to continuously read/write a file descriptor until B<EAGAIN> when "
"using the B<EPOLLET> flag (edge-triggered behavior) ?"
msgstr ""
"Должен ли я читать/записывать файловый дескриптор до пор пока, не получу B<"
"EAGAIN> при использовании флага B<EPOLLET> (поведение edge-triggered)?"

#. type: TP
#: man-pages/man7/epoll.7:486
#, no-wrap
msgid "B<A9>"
msgstr "B<A9>"

#. type: Plain text
#: man-pages/man7/epoll.7:496
msgid ""
"Receiving an event from B<epoll_wait>(2)  should suggest to you that such "
"file descriptor is ready for the requested I/O operation.  You must consider"
" it ready until the next (nonblocking)  read/write yields B<EAGAIN>.  When "
"and how you will use the file descriptor is entirely up to you."
msgstr ""
"Получение события от B<epoll_wait>(2) должно сообщить вам, что файловый "
"дескриптор готов для запрошенной операции ввода/вывода. Вы должны "
"предполагать, что он готов до тех пор, пока вы не получите следующий B<EAGAIN>"
" от (неблокирующего) чтения/записи. Когда и как вы будете использовать "
"файловый дескриптор — полностью зависит от вас."

#. type: Plain text
#: man-pages/man7/epoll.7:502
msgid ""
"For packet/token-oriented files (e.g., datagram socket, terminal in "
"canonical mode), the only way to detect the end of the read/write I/O space "
"is to continue to read/write until B<EAGAIN>."
msgstr ""
"Для пакетных/метко ориентированных файлов (например, датаграмных сокетов, "
"терминал в каноническом режиме) единственным способом обнаружить конец "
"чтения/записи пространства ввода-вывода — это продолжать чтение/записи до "
"получения B<EAGAIN>."

#. type: Plain text
#: man-pages/man7/epoll.7:518
msgid ""
"For stream-oriented files (e.g., pipe, FIFO, stream socket), the condition "
"that the read/write I/O space is exhausted can also be detected by checking "
"the amount of data read from / written to the target file descriptor.  For "
"example, if you call B<read>(2)  by asking to read a certain amount of data "
"and B<read>(2)  returns a lower number of bytes, you can be sure of having "
"exhausted the read I/O space for the file descriptor.  The same is true when"
" writing using B<write>(2).  (Avoid this latter technique if you cannot "
"guarantee that the monitored file descriptor always refers to a stream-"
"oriented file.)"
msgstr ""
"Для потокоориентированных файлов (например, каналы, FIFO, потоковые сокеты) "
"условие, при которых чтение/запись пространства ввода/вывода закончилось, "
"может быть определено проверкой количества считанных/записанных данных из/в "
"целевого файлового дескриптора. Например, если вы вызвали B<read>(2) для "
"чтения определённого количества данных и B<read>(2) вернул меньшее количество "
"байтов, то можно быть уверенным, что пространство чтения ввода/вывода этого "
"файлового дескриптора закончилось. То же самое справедливо для записи "
"посредством B<write>(2) (не используйте последнее, если вы не можете "
"гарантировать, что отслеживаемый файловый дескриптор всегда ссылается на "
"потокоориентированный файл)."

#. type: SS
#: man-pages/man7/epoll.7:518
#, no-wrap
msgid "Possible pitfalls and ways to avoid them"
msgstr "Возможные ловушки и способы их обхода"

#. type: TP
#: man-pages/man7/epoll.7:519
#, no-wrap
msgid "B<o Starvation (edge-triggered)>"
msgstr "B<o Информационный голод (edge-triggered)>"

#. type: Plain text
#: man-pages/man7/epoll.7:527
msgid ""
"If there is a large amount of I/O space, it is possible that by trying to "
"drain it the other files will not get processed causing starvation.  (This "
"problem is not specific to B<epoll>.)"
msgstr ""
"Если существует большое пространство ввода/вывода, то возможно, что пока "
"выего читаете, другие файлы не будут обрабатываться и возникнет недостаток "
"данных (этого, обычно, не происходит с B<epoll>)."

#. type: Plain text
#: man-pages/man7/epoll.7:535
msgid ""
"The solution is to maintain a ready list and mark the file descriptor as "
"ready in its associated data structure, thereby allowing the application to "
"remember which files need to be processed but still round robin amongst all "
"the ready files.  This also supports ignoring subsequent events you receive "
"for file descriptors that are already ready."
msgstr ""
"Решением будет поддержка списка готовности и маркировка файлового дескриптора "
"как готового в связанной с ним структуре данных, тем самым позволяя "
"приложению запоминать какие файлы требуют обработки, но всё ещё не "
"обработанных среди уже готовых файлов. Это также поддерживает игнорирование "
"последующих событий готовности файловых дескрипторов, получаемых вами."

#. type: TP
#: man-pages/man7/epoll.7:535
#, no-wrap
msgid "B<o If using an event cache...>"
msgstr "B<o Если использовать кэш событий…>"

#. type: Plain text
#: man-pages/man7/epoll.7:551
msgid ""
"If you use an event cache or store all the file descriptors returned from "
"B<epoll_wait>(2), then make sure to provide a way to mark its closure "
"dynamically (i.e., caused by a previous event's processing).  Suppose you "
"receive 100 events from B<epoll_wait>(2), and in event #47 a condition "
"causes event #13 to be closed.  If you remove the structure and B<close>(2)"
"  the file descriptor for event #13, then your event cache might still say "
"there are events waiting for that file descriptor causing confusion."
msgstr ""
"Если вы используете кэш событий или храните все файловые дескрипторы, "
"возвращённые от B<epoll_wait>(2), то убедитесь, что вы обеспечили способ его "
"динамического закрытия (например, вызванное обработкой предыдущего события). "
"Предположим, что вы получили 100 событий от B<epoll_wait>(2), и что в событии "
"№47 некоторое условие определяет, что событие №13 должно быть закрыто. Если "
"вы удалите структуру и выполните B<close>(2) файлового дескриптора для "
"события №13, то кэш событий всё ещё может сообщать о том, что есть ожидаемые "
"события для этого файлового дескриптора, что приводит к путнице."

#. type: Plain text
#: man-pages/man7/epoll.7:562
msgid ""
"One solution for this is to call, during the processing of event 47, "
"B<epoll_ctl>(B<EPOLL_CTL_DEL>)  to delete file descriptor 13 and "
"B<close>(2), then mark its associated data structure as removed and link it "
"to a cleanup list.  If you find another event for file descriptor 13 in your"
" batch processing, you will discover the file descriptor had been previously"
" removed and there will be no confusion."
msgstr ""
"Одним из решений будет вызов, во время обработки события №47, B<epoll_ctl>(B<"
"EPOLL_CTL_DEL>) для удаления файлового дескриптора 13 и вызов B<close>(2), а "
"затем маркировка связанной с ним структуры данных как удалённой и связки его "
"со списком очистки. Если при пакетной обработке найдется другое событие для "
"файлового дескриптора 13, то обнаружится, что файловый дескриптор уже был "
"удалён и конфликтов не будет."

#. type: SH
#: man-pages/man7/epoll.7:562
#, no-wrap
msgid "VERSIONS"
msgstr "ВЕРСИИ"

#.  Its interface should be finalized in Linux kernel 2.5.66.
#. type: Plain text
#: man-pages/man7/epoll.7:568
msgid ""
"The B<epoll> API was introduced in Linux kernel 2.5.44.  Support was added "
"to glibc in version 2.3.2."
msgstr ""
"Программный интерфейс B<epoll> был добавлен в ядро Linux версии 2.5.44. "
"Поддержка в glibc доступна с версии 2.3.2."

#. type: SH
#: man-pages/man7/epoll.7:568
#, no-wrap
msgid "CONFORMING TO"
msgstr "СООТВЕТСТВИЕ СТАНДАРТАМ"

#. type: Plain text
#: man-pages/man7/epoll.7:577
msgid ""
"The B<epoll> API is Linux-specific.  Some other systems provide similar "
"mechanisms, for example, FreeBSD has I<kqueue>, and Solaris has "
"I</dev/poll>."
msgstr ""
"Программный интерфейс B<epoll> есть только в Linux. В некоторых других "
"системах есть подобные механизмы, например, в FreeBSD есть I<kqueue>, а в "
"Solaris — I</dev/poll>."

#. type: Plain text
#: man-pages/man7/epoll.7:581
msgid ""
"B<epoll_create>(2), B<epoll_create1>(2), B<epoll_ctl>(2), B<epoll_wait>(2)"
msgstr ""
"B<epoll_create>(2), B<epoll_create1>(2), B<epoll_ctl>(2), B<epoll_wait>(2)"

#. type: TH
#: man-pages/man2/eventfd.2:22
#, no-wrap
msgid "EVENTFD"
msgstr "EVENTFD"

#. type: Plain text
#: man-pages/man2/eventfd.2:25
msgid "eventfd - create a file descriptor for event notification"
msgstr "eventfd - создаёт файловый дескриптор для уведомления о событиях"

#. type: Plain text
#: man-pages/man2/eventfd.2:27
msgid "B<#include E<lt>sys/eventfd.hE<gt>>"
msgstr "B<#include E<lt>sys/eventfd.hE<gt>>"

#. type: Plain text
#: man-pages/man2/eventfd.2:29
msgid "B<int eventfd(unsigned int >I<initval>B<, int >I<flags>B<);>"
msgstr "B<int eventfd(unsigned int >I<initval>B<, int >I<flags>B<);>"

#. type: Plain text
#: man-pages/man2/eventfd.2:39
msgid ""
"B<eventfd>()  creates an \"eventfd object\" that can be used as an event "
"wait/notify mechanism by user-space applications, and by the kernel to "
"notify user-space applications of events.  The object contains an unsigned "
"64-bit integer (I<uint64_t>)  counter that is maintained by the kernel.  "
"This counter is initialized with the value specified in the argument "
"I<initval>."
msgstr ""
"Вызов B<eventfd>() создаёт «объект eventfd», который можно использовать в "
"качестве механизма ожидания/уведомления о событиях в приложениях пространства "
"пользователя и ядра. Объект содержит беззнаковое 64-битный (I<uint64_t>) "
"счётчик, обслуживаемый ядром. Этот счётчик инициализируется значением, "
"указанным в аргументе I<initval>."

#. type: Plain text
#: man-pages/man2/eventfd.2:44
msgid ""
"The following values may be bitwise ORed in I<flags> to change the behavior "
"of B<eventfd>():"
msgstr ""
"Для изменения поведения B<eventfd>() можно использовать следующие значения "
"I<flags> (через OR):"

#. type: TP
#: man-pages/man2/eventfd.2:44
#, no-wrap
msgid "B<EFD_CLOEXEC> (since Linux 2.6.27)"
msgstr "B<EFD_CLOEXEC> (начиная с Linux 2.6.27)"

#. type: Plain text
#: man-pages/man2/eventfd.2:54
msgid ""
"Set the close-on-exec (B<FD_CLOEXEC>)  flag on the new file descriptor.  See"
" the description of the B<O_CLOEXEC> flag in B<open>(2)  for reasons why "
"this may be useful."
msgstr ""
"Устанавливает флаг close-on-exec (B<FD_CLOEXEC>) для нового открытого "
"файлового дескриптора. Смотрите описание флага B<O_CLOEXEC> в B<open>(2) для "
"того, чтобы узнать как это может пригодиться."

#. type: TP
#: man-pages/man2/eventfd.2:54
#, no-wrap
msgid "B<EFD_NONBLOCK> (since Linux 2.6.27)"
msgstr "B<EFD_NONBLOCK> (начиная с Linux 2.6.27)"

#. type: Plain text
#: man-pages/man2/eventfd.2:62
msgid ""
"Set the B<O_NONBLOCK> file status flag on the new open file description.  "
"Using this flag saves extra calls to B<fcntl>(2)  to achieve the same "
"result."
msgstr ""
"Устанавливает флаг состояния файла B<O_NONBLOCK> для нового открытого "
"файлового дескриптора. Использование данного флага заменяет дополнительные "
"вызовы B<fcntl>(2) для достижения того же результата."

#. type: TP
#: man-pages/man2/eventfd.2:62
#, no-wrap
msgid "B<EFD_SEMAPHORE> (since Linux 2.6.30)"
msgstr "B<EFD_SEMAPHORE> (начиная с Linux 2.6.30)"

#. type: Plain text
#: man-pages/man2/eventfd.2:66
msgid ""
"Provide semaphore-like semantics for reads from the new file descriptor.  "
"See below."
msgstr ""
"Предоставляет семафоро-подобную семантику для чтения из нового файлового "
"дескриптора. Смотрите ниже."

#. type: Plain text
#: man-pages/man2/eventfd.2:70
msgid ""
"In Linux up to version 2.6.26, the I<flags> argument is unused, and must be "
"specified as zero."
msgstr ""
"До версии Linux 2.6.26 аргумент I<flags> не использовался, и должен быть "
"равен нулю."

#. type: Plain text
#: man-pages/man2/eventfd.2:76
msgid ""
"As its return value, B<eventfd>()  returns a new file descriptor that can be"
" used to refer to the eventfd object.  The following operations can be "
"performed on the file descriptor:"
msgstr ""
"При завершении работы B<eventfd>() возвращает новый файловый дескриптор, "
"который можно использовать для ссылки на объект eventfd. Над этим файловым "
"дескриптором можно выполнять следующие операции:"

#. type: TP
#: man-pages/man2/eventfd.2:76
#, no-wrap
msgid "B<read>(2)"
msgstr "B<read>(2)"

#. type: Plain text
#: man-pages/man2/eventfd.2:86
msgid ""
"Each successful B<read>(2)  returns an 8-byte integer.  A B<read>(2)  will "
"fail with the error B<EINVAL> if the size of the supplied buffer is less "
"than 8 bytes."
msgstr ""
"Каждый выполнившийся вызов B<read>(2) возвращает 8-байтное целое. Вызов B<"
"read>(2) завершится с ошибкой B<EINVAL>, если размер указанного буфера будет "
"меньше 8 байт."

#. type: Plain text
#: man-pages/man2/eventfd.2:91
msgid ""
"The value returned by B<read>(2)  is in host byte order\\(emthat is, the "
"native byte order for integers on the host machine."
msgstr ""
"Возвращаемое B<read>(2) значение имеет порядок байт узла, т. е., используемый "
"порядок байт для целых на машине узла."

#. type: Plain text
#: man-pages/man2/eventfd.2:98
msgid ""
"The semantics of B<read>(2)  depend on whether the eventfd counter currently"
" has a nonzero value and whether the B<EFD_SEMAPHORE> flag was specified "
"when creating the eventfd file descriptor:"
msgstr ""
"Семантика B<read>(2) зависит от значения счётчика eventfd — равно оно нулю "
"или нет, и был ли указан флаг B<EFD_SEMAPHORE> при создании файлового "
"дескриптора eventfd:"

#. type: Plain text
#: man-pages/man2/eventfd.2:106
msgid ""
"If B<EFD_SEMAPHORE> was not specified and the eventfd counter has a nonzero "
"value, then a B<read>(2)  returns 8 bytes containing that value, and the "
"counter's value is reset to zero."
msgstr ""
"Если флаг B<EFD_SEMAPHORE> не указан и счётчик eventfd не равен нулю, то B<"
"read>(2) возвращает 8 байт с его значением и значение счётчика сбрасывается в "
"ноль."

#. type: Plain text
#: man-pages/man2/eventfd.2:113
msgid ""
"If B<EFD_SEMAPHORE> was specified and the eventfd counter has a nonzero "
"value, then a B<read>(2)  returns 8 bytes containing the value 1, and the "
"counter's value is decremented by 1."
msgstr ""
"Если флаг B<EFD_SEMAPHORE> задан указан и счётчик eventfd не равен нулю, то "
"B<read>(2) возвращает 8 байт, содержащие значение 1, и значение счётчика "
"уменьшается на 1."

#. type: Plain text
#: man-pages/man2/eventfd.2:123
msgid ""
"If the eventfd counter is zero at the time of the call to B<read>(2), then "
"the call either blocks until the counter becomes nonzero (at which time, the"
" B<read>(2)  proceeds as described above)  or fails with the error B<EAGAIN>"
" if the file descriptor has been made nonblocking."
msgstr ""
"Если счётчик eventfd равен нулю во время вызова B<read>(2), то вызов "
"блокируется до тех пор, пока счётчик станет не равным нулю (время работы B<"
"read>(2) описано выше) или завершается с ошибкой B<EAGAIN>, если файловый "
"дескриптор создан неблокируемым."

#. type: TP
#: man-pages/man2/eventfd.2:124
#, no-wrap
msgid "B<write>(2)"
msgstr "B<write>(2)"

#. type: Plain text
#: man-pages/man2/eventfd.2:141
msgid ""
"A B<write>(2)  call adds the 8-byte integer value supplied in its buffer to "
"the counter.  The maximum value that may be stored in the counter is the "
"largest unsigned 64-bit value minus 1 (i.e., 0xfffffffffffffffe).  If the "
"addition would cause the counter's value to exceed the maximum, then the "
"B<write>(2)  either blocks until a B<read>(2)  is performed on the file "
"descriptor, or fails with the error B<EAGAIN> if the file descriptor has "
"been made nonblocking."
msgstr ""
"При вызове B<write>(2) из его буфера к счётчику добавляется 8-байтовое целое "
"значение. Максимальное значение, которое может храниться в счётчике, равно "
"наибольшему 64-битному беззнаковому значению минус 1 (т.е., "
"0xfffffffffffffffe). Если при добавлении значение счётчика превысит максимум, "
"то B<write>(2) заблокируется до тех пор, пока для файлового дескриптора не "
"будет выполнен вызов B<read>(2), или завершится с ошибкой B<EAGAIN>, если "
"файловый дескриптор создан неблокируемым."

#. type: Plain text
#: man-pages/man2/eventfd.2:148
msgid ""
"A B<write>(2)  will fail with the error B<EINVAL> if the size of the "
"supplied buffer is less than 8 bytes, or if an attempt is made to write the "
"value 0xffffffffffffffff."
msgstr ""
"Вызов B<write>(2) завершится с ошибкой B<EINVAL>, если размер указанного "
"буфера меньше 8 байт, или если попытаться записать значение "
"0xffffffffffffffff."

#. type: TP
#: man-pages/man2/eventfd.2:148
#, no-wrap
msgid "B<poll>(2), B<select>(2) (and similar)"
msgstr "B<poll>(2), B<select>(2) (и подобные)"

#. type: Plain text
#: man-pages/man2/eventfd.2:157
msgid ""
"The returned file descriptor supports B<poll>(2)  (and analogously "
"B<epoll>(7))  and B<select>(2), as follows:"
msgstr ""
"Возвращённый файловый дескриптор поддерживает B<poll>(2) (и, аналогично, B<"
"epoll>(7)) и B<select>(2) следующим образом:"

#. type: Plain text
#: man-pages/man2/eventfd.2:168
msgid ""
"The file descriptor is readable (the B<select>(2)  I<readfds> argument; the "
"B<poll>(2)  B<POLLIN> flag)  if the counter has a value greater than 0."
msgstr ""
"Файловый дескриптор доступен для чтения (в B<select>(2) аргумент I<readfds>; "
"в B<poll>(2) флаг B<POLLIN>), если счётчик больше 0."

#. type: Plain text
#: man-pages/man2/eventfd.2:178
msgid ""
"The file descriptor is writable (the B<select>(2)  I<writefds> argument; the"
" B<poll>(2)  B<POLLOUT> flag)  if it is possible to write a value of at "
"least \"1\" without blocking."
msgstr ""
"Файловый дескриптор доступен для записи (в B<select>(2) аргумент I<writefds>; "
"в B<poll>(2) флаг B<POLLOUT>), если можно записать значение равное, как "
"минимум, \"1\" без блокировки."

#. type: Plain text
#: man-pages/man2/eventfd.2:198
msgid ""
"If an overflow of the counter value was detected, then B<select>(2)  "
"indicates the file descriptor as being both readable and writable, and "
"B<poll>(2)  returns a B<POLLERR> event.  As noted above, B<write>(2)  can "
"never overflow the counter.  However an overflow can occur if 2^64 eventfd "
"\"signal posts\" were performed by the KAIO subsystem (theoretically "
"possible, but practically unlikely).  If an overflow has occurred, then "
"B<read>(2)  will return that maximum I<uint64_t> value (i.e., "
"0xffffffffffffffff)."
msgstr ""
"Если обнаружено переполнение счётчика, то B<select>(2) указывает на файловый "
"дескриптор, доступный на чтение и запись, и B<poll>(2) возвращает событие B<"
"POLLERR>. Как упоминалось ранее, B<write>(2) никогда не может вызвать "
"переполнение счётчика. Однако переполнение может произойти, если подсистемой "
"KAIO выполнится (возможно теоретически) 2^64 \"передач сигналов\" eventfd. "
"Если переполнение произошло, то B<read>(2) вернёт максимальное значение типа "
"I<uint64_t> (т.е., 0xffffffffffffffff)."

#. type: Plain text
#: man-pages/man2/eventfd.2:205
msgid ""
"The eventfd file descriptor also supports the other file-descriptor "
"multiplexing APIs: B<pselect>(2)  and B<ppoll>(2)."
msgstr ""
"Файловый дескриптор eventfd также поддерживает другие мультиплексные "
"программные интерфейсы: B<pselect>(2) и B<ppoll>(2)."

#. type: TP
#: man-pages/man2/eventfd.2:205
#, no-wrap
msgid "B<close>(2)"
msgstr "B<close>(2)"

#. type: Plain text
#: man-pages/man2/eventfd.2:210
msgid ""
"When the file descriptor is no longer required it should be closed.  When "
"all file descriptors associated with the same eventfd object have been "
"closed, the resources for object are freed by the kernel."
msgstr ""
"Если файловый дескриптор больше не требуется, его нужно закрыть. Когда все "
"файловые дескрипторы, связанные с одним объектом eventfd, будут закрыты, ядро "
"освобождает ресурсы объекта."

#. type: Plain text
#: man-pages/man2/eventfd.2:222
msgid ""
"A copy of the file descriptor created by B<eventfd>()  is inherited by the "
"child produced by B<fork>(2).  The duplicate file descriptor is associated "
"with the same eventfd object.  File descriptors created by B<eventfd>()  are"
" preserved across B<execve>(2), unless the close-on-exec flag has been set."
msgstr ""
"Копия файлового дескриптора, созданного B<eventfd>(), наследуется потомком, "
"созданным с помощью B<fork>(2). Копия файлового дескриптора связывается с тем "
"же объектом eventfd. Файловые дескрипторы, созданные B<eventfd>(), "
"сохраняются при вызове B<execve>(2), если не указан флаг закрытия-при-exec."

#. type: SH
#: man-pages/man2/eventfd.2:222
#, no-wrap
msgid "RETURN VALUE"
msgstr "ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ"

#. type: Plain text
#: man-pages/man2/eventfd.2:229
msgid ""
"On success, B<eventfd>()  returns a new eventfd file descriptor.  On error, "
"-1 is returned and I<errno> is set to indicate the error."
msgstr ""
"При успешном выполнении B<eventfd>() возвращает новый файловый дескриптор "
"eventfd. При ошибке возвращается -1, и I<errno> устанавливается в "
"соответствующее значение."

#. type: SH
#: man-pages/man2/eventfd.2:229
#, no-wrap
msgid "ERRORS"
msgstr "ОШИБКИ"

#. type: TP
#: man-pages/man2/eventfd.2:230
#, no-wrap
msgid "B<EINVAL>"
msgstr "B<EINVAL>"

#. type: Plain text
#: man-pages/man2/eventfd.2:234
msgid "An unsupported value was specified in I<flags>."
msgstr "В I<flags> указано неподдерживаемое значение."

#. type: TP
#: man-pages/man2/eventfd.2:234
#, no-wrap
msgid "B<EMFILE>"
msgstr "B<EMFILE>"

#. type: Plain text
#: man-pages/man2/eventfd.2:237
msgid "The per-process limit on open file descriptors has been reached."
msgstr ""
"Было достигнуто ограничение по открытым файловым дескриптором на процесс."

#. type: TP
#: man-pages/man2/eventfd.2:237
#, no-wrap
msgid "B<ENFILE>"
msgstr "B<ENFILE>"

#. type: Plain text
#: man-pages/man2/eventfd.2:241
msgid ""
"The system-wide limit on the total number of open files has been reached."
msgstr "Достигнуто максимальное количество открытых файлов в системе."

#. type: TP
#: man-pages/man2/eventfd.2:241
#, no-wrap
msgid "B<ENODEV>"
msgstr "B<ENODEV>"

#.  Note from Davide:
#.  The ENODEV error is basically never going to happen if
#.  the kernel boots correctly. That error happen only if during
#.  the kernel initialization, some error occur in the anonymous
#.  inode source initialization.
#. type: Plain text
#: man-pages/man2/eventfd.2:249
msgid "Could not mount (internal) anonymous inode device."
msgstr "Не удалось смонтировать (внутреннее) безымянное устройство inode."

#. type: TP
#: man-pages/man2/eventfd.2:249
#, no-wrap
msgid "B<ENOMEM>"
msgstr "B<ENOMEM>"

#. type: Plain text
#: man-pages/man2/eventfd.2:253
msgid "There was insufficient memory to create a new eventfd file descriptor."
msgstr "Недостаточно памяти для создания нового файлового дескриптора eventfd."

#.  eventfd() is in glibc 2.7, but reportedly does not build
#. type: Plain text
#: man-pages/man2/eventfd.2:266
msgid ""
"B<eventfd>()  is available on Linux since kernel 2.6.22.  Working support is"
" provided in glibc since version 2.8.  The B<eventfd2>()  system call (see "
"NOTES) is available on Linux since kernel 2.6.27.  Since version 2.9, the "
"glibc B<eventfd>()  wrapper will employ the B<eventfd2>()  system call, if "
"it is supported by the kernel."
msgstr ""
"Вызов B<eventfd>() доступен в Linux начиная с ядра 2.6.22. Поддержка в glibc "
"появилась в версии 2.8. Системный вызов B<eventfd2>() (см. ЗАМЕЧАНИЯ) "
"доступен в Linux начиная с ядра 2.6.27. В glibc версии 2.9 в обёртке B<"
"eventfd>() используется системный вызов B<eventfd2>(), если он поддерживается "
"ядром."

#. type: Plain text
#: man-pages/man2/eventfd.2:271
msgid "B<eventfd>()  and B<eventfd2>()  are Linux-specific."
msgstr "Вызовы B<eventfd>() и B<eventfd2>() есть только в Linux."

#. type: SH
#: man-pages/man2/eventfd.2:271
#, no-wrap
msgid "NOTES"
msgstr "ЗАМЕЧАНИЯ"

#. type: Plain text
#: man-pages/man2/eventfd.2:279
msgid ""
"Applications can use an eventfd file descriptor instead of a pipe (see "
"B<pipe>(2))  in all cases where a pipe is used simply to signal events.  The"
" kernel overhead of an eventfd file descriptor is much lower than that of a "
"pipe, and only one file descriptor is required (versus the two required for "
"a pipe)."
msgstr ""
"Приложения могут использовать файловый дескриптор eventfd вместо канала (см. "
"B<pipe>(2)) во всех случаях, когда канал используется только для сигнализации "
"о событиях. Издержки ядра по файловому дескриптору eventfd намного меньше, "
"чем по каналу и требуется только один файловый дескриптор (против двух, при "
"использовании канала)."

#.  or eventually syslets/threadlets
#. type: Plain text
#: man-pages/man2/eventfd.2:285
msgid ""
"When used in the kernel, an eventfd file descriptor can provide a bridge "
"from kernel to user space, allowing, for example, functionalities like KAIO "
"(kernel AIO)  to signal to a file descriptor that some operation is "
"complete."
msgstr ""
"При использовании в ядре файловый дескриптор eventfd может предоставлять мост "
"из ядерного в пользовательское пространство, позволяя например работать, "
"подобно KAIO ( ядерный AIO), сигнализируя, что завершена какая-то операция "
"над файловым дескриптором."

#. type: Plain text
#: man-pages/man2/eventfd.2:302
msgid ""
"A key point about an eventfd file descriptor is that it can be monitored "
"just like any other file descriptor using B<select>(2), B<poll>(2), or "
"B<epoll>(7).  This means that an application can simultaneously monitor the "
"readiness of \"traditional\" files and the readiness of other kernel "
"mechanisms that support the eventfd interface.  (Without the B<eventfd>()  "
"interface, these mechanisms could not be multiplexed via B<select>(2), "
"B<poll>(2), or B<epoll>(7).)"
msgstr ""
"Важным моментом файлового дескриптора eventfd является то, что за ним можно "
"следить как за обычным файловым дескриптором с помощью B<select>(2), B<poll>"
"(2) или B<epoll>(7). Это означает, что приложение может одновременно "
"отслеживать готовность \"обычных\" файлов и готовность других механизмов "
"ядра, которые поддерживают интерфейс eventfd. (Без интерфейса B<eventfd>() "
"эти механизмы невозможно мультиплексировать через B<select>(2), B<poll>(2) "
"или B<epoll>(7).)"

#. type: SS
#: man-pages/man2/eventfd.2:302
#, no-wrap
msgid "Underlying Linux system calls"
msgstr "Системные вызовы Linux, лежащие в основе"

#. type: Plain text
#: man-pages/man2/eventfd.2:316
msgid ""
"There are two underlying Linux system calls: B<eventfd>()  and the more "
"recent B<eventfd2>().  The former system call does not implement a I<flags> "
"argument.  The latter system call implements the I<flags> values described "
"above.  The glibc wrapper function will use B<eventfd2>()  where it is "
"available."
msgstr ""
"Основу составляют два системных вызова Linux: B<eventfd>() и более новый B<"
"eventfd2>(). В первом системном вызове не реализован аргумент I<flags>. "
"Последний системный вызов использует значения I<flags>, которые были описаны "
"ранее. Обёрточная функция glibc использует B<eventfd2>(), если он доступен."

#. type: SS
#: man-pages/man2/eventfd.2:316
#, no-wrap
msgid "Additional glibc features"
msgstr "Дополнительные возможности glibc"

#. type: Plain text
#: man-pages/man2/eventfd.2:320
msgid ""
"The GNU C library defines an additional type, and two functions that attempt"
" to abstract some of the details of reading and writing on an eventfd file "
"descriptor:"
msgstr ""
"В библиотеке GNU C определён дополнительный тип и две функции, которые "
"пытаются устранить сложности чтения и записи из файлового дескриптора eventfd:"

#. type: Plain text
#: man-pages/man2/eventfd.2:324
#, no-wrap
msgid "typedef uint64_t eventfd_t;\n"
msgstr "typedef uint64_t eventfd_t;\n"

#. type: Plain text
#: man-pages/man2/eventfd.2:327
#, no-wrap
msgid ""
"int eventfd_read(int fd, eventfd_t *value);\n"
"int eventfd_write(int fd, eventfd_t value);\n"
msgstr ""
"int eventfd_read(int fd, eventfd_t *value);\nint eventfd_write(int fd, "
"eventfd_t value);\n"

#. type: Plain text
#: man-pages/man2/eventfd.2:334
msgid ""
"The functions perform the read and write operations on an eventfd file "
"descriptor, returning 0 if the correct number of bytes was transferred, or "
"-1 otherwise."
msgstr ""
"Функции выполняют операции чтения и записи из файлового дескриптора eventfd, "
"и возвращают 0, если передано правильное количество байт и -1 в противном "
"случае."

#. type: SH
#: man-pages/man2/eventfd.2:334
#, no-wrap
msgid "EXAMPLE"
msgstr "ПРИМЕР"

#. type: Plain text
#: man-pages/man2/eventfd.2:343
msgid ""
"The following program creates an eventfd file descriptor and then forks to "
"create a child process.  While the parent briefly sleeps, the child writes "
"each of the integers supplied in the program's command-line arguments to the"
" eventfd file descriptor.  When the parent has finished sleeping, it reads "
"from the eventfd file descriptor."
msgstr ""
"Следующая программа создаёт файловый дескриптор eventfd и затем создаёт "
"дочерний процесс. Пока родительский процесс на короткое время засыпает, "
"потомок пишет все числа, переданные в командной строке программы, в файловый "
"дескриптор eventfd. Когда родитель просыпается, он читает их из файлового "
"дескриптора eventfd."

#. type: Plain text
#: man-pages/man2/eventfd.2:345
msgid "The following shell session shows a sample run of the program:"
msgstr "Пример сеанса работы с программой:"

#. type: Plain text
#: man-pages/man2/eventfd.2:357
#, no-wrap
msgid ""
"$B< ./a.out 1 2 4 7 14>\n"
"Child writing 1 to efd\n"
"Child writing 2 to efd\n"
"Child writing 4 to efd\n"
"Child writing 7 to efd\n"
"Child writing 14 to efd\n"
"Child completed write loop\n"
"Parent about to read\n"
"Parent read 28 (0x1c) from efd\n"
msgstr ""
"$B< ./a.out 1 2 4 7 14>\nChild writing 1 to efd\nChild writing 2 to "
"efd\nChild writing 4 to efd\nChild writing 7 to efd\nChild writing 14 to "
"efd\nChild completed write loop\nParent about to read\nParent read 28 (0x1c) "
"from efd\n"

#. type: SS
#: man-pages/man2/eventfd.2:359
#, no-wrap
msgid "Program source"
msgstr "Исходный код программы"

#. type: Plain text
#: man-pages/man2/eventfd.2:367
#, no-wrap
msgid ""
"#include E<lt>sys/eventfd.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdint.hE<gt>             /* Definition of uint64_t */\n"
msgstr ""
"#include E<lt>sys/eventfd.hE<gt>\n#include E<lt>unistd.hE<gt>\n#include E<lt>"
"stdlib.hE<gt>\n#include E<lt>stdio.hE<gt>\n#include E<lt>stdint.hE<gt>        "
"     /* определение uint64_t */\n"

#. type: Plain text
#: man-pages/man2/eventfd.2:370
#, no-wrap
msgid ""
"#define handle_error(msg) \\e\n"
"    do { perror(msg); exit(EXIT_FAILURE); } while (0)\n"
msgstr ""
"#define handle_error(msg) \\e\n    do { perror(msg); exit(EXIT_FAILURE); } "
"while (0)\n"

#. type: Plain text
#: man-pages/man2/eventfd.2:377
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int efd, j;\n"
"    uint64_t u;\n"
"    ssize_t s;\n"
msgstr ""
"int\nmain(int argc, char *argv[])\n{\n    int efd, j;\n    uint64_t u;\n    "
"ssize_t s;\n"

#. type: Plain text
#: man-pages/man2/eventfd.2:382
#, no-wrap
msgid ""
"    if (argc E<lt> 2) {\n"
"        fprintf(stderr, \"Usage: %s E<lt>numE<gt>...\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    if (argc E<lt> 2) {\n        fprintf(stderr, \"Использование: %s E<lt>"
"numE<gt>...\\en\", argv[0]);\n        exit(EXIT_FAILURE);\n    }\n"

#. type: Plain text
#: man-pages/man2/eventfd.2:386
#, no-wrap
msgid ""
"    efd = eventfd(0, 0);\n"
"    if (efd == -1)\n"
"        handle_error(\"eventfd\");\n"
msgstr ""
"    efd = eventfd(0, 0);\n    if (efd == -1)\n        "
"handle_error(\"eventfd\");\n"

#. type: Plain text
#: man-pages/man2/eventfd.2:398
#, no-wrap
msgid ""
"    switch (fork()) {\n"
"    case 0:\n"
"        for (j = 1; j E<lt> argc; j++) {\n"
"            printf(\"Child writing %s to efd\\en\", argv[j]);\n"
"            u = strtoull(argv[j], NULL, 0);\n"
"                    /* strtoull() allows various bases */\n"
"            s = write(efd, &u, sizeof(uint64_t));\n"
"            if (s != sizeof(uint64_t))\n"
"                handle_error(\"write\");\n"
"        }\n"
"        printf(\"Child completed write loop\\en\");\n"
msgstr ""
"    switch (fork()) {\n    case 0:\n        for (j = 1; j E<lt> argc; j++) "
"{\n            printf(\"Child writing %s to efd\\en\", argv[j]);\n            "
"u = strtoull(argv[j], NULL, 0);\n                    /* в strtoull() "
"разрешены различные основания */\n            s = write(efd, &u, "
"sizeof(uint64_t));\n            if (s != sizeof(uint64_t))\n                "
"handle_error(\"write\");\n        }\n        printf(\"Child completed write "
"loop\\en\");\n"

#. type: Plain text
#: man-pages/man2/eventfd.2:400
#, no-wrap
msgid "        exit(EXIT_SUCCESS);\n"
msgstr "        exit(EXIT_SUCCESS);\n"

#. type: Plain text
#: man-pages/man2/eventfd.2:403
#, no-wrap
msgid ""
"    default:\n"
"        sleep(2);\n"
msgstr "    default:\n        sleep(2);\n"

#. type: Plain text
#: man-pages/man2/eventfd.2:411
#, no-wrap
msgid ""
"        printf(\"Parent about to read\\en\");\n"
"        s = read(efd, &u, sizeof(uint64_t));\n"
"        if (s != sizeof(uint64_t))\n"
"            handle_error(\"read\");\n"
"        printf(\"Parent read %llu (0x%llx) from efd\\en\",\n"
"                (unsigned long long) u, (unsigned long long) u);\n"
"        exit(EXIT_SUCCESS);\n"
msgstr ""
"        printf(\"Parent about to read\\en\");\n        s = read(efd, &u, "
"sizeof(uint64_t));\n        if (s != sizeof(uint64_t))\n            "
"handle_error(\"read\");\n        printf(\"Parent read %llu (0x%llx) from "
"efd\\en\",\n                (unsigned long long) u, (unsigned long long) "
"u);\n        exit(EXIT_SUCCESS);\n"

#. type: Plain text
#: man-pages/man2/eventfd.2:416
#, no-wrap
msgid ""
"    case -1:\n"
"        handle_error(\"fork\");\n"
"    }\n"
"}\n"
msgstr "    case -1:\n        handle_error(\"fork\");\n    }\n}\n"

#. type: Plain text
#: man-pages/man2/eventfd.2:427
msgid ""
"B<futex>(2), B<pipe>(2), B<poll>(2), B<read>(2), B<select>(2), "
"B<signalfd>(2), B<timerfd_create>(2), B<write>(2), B<epoll>(7), "
"B<sem_overview>(7)"
msgstr ""
"B<futex>(2), B<pipe>(2), B<poll>(2), B<read>(2), B<select>(2), B<signalfd>"
"(2), B<timerfd_create>(2), B<write>(2), B<epoll>(7), B<sem_overview>(7)"

#. type: TH
#: man-pages/man2/execve.2:37
#, no-wrap
msgid "EXECVE"
msgstr "EXECVE"

#. type: Plain text
#: man-pages/man2/execve.2:40
msgid "execve - execute program"
msgstr "execve - выполнить программу"

#. type: Plain text
#: man-pages/man2/execve.2:42
msgid "B<#include E<lt>unistd.hE<gt>>"
msgstr "B<#include E<lt>unistd.hE<gt>>"

#. type: Plain text
#: man-pages/man2/execve.2:44
msgid "B<int execve(const char *>I<filename>B<, char *const >I<argv>B<[], >"
msgstr "B<int execve(const char *>I<filename>B<, char *const >I<argv>B<[], >"

#. type: Plain text
#: man-pages/man2/execve.2:46
msgid "B< char *const >I<envp>B<[]);>"
msgstr "B< char *const >I<envp>B<[]);>"

#. type: Plain text
#: man-pages/man2/execve.2:51
msgid ""
"B<execve>()  executes the program pointed to by I<filename>.  I<filename> "
"must be either a binary executable, or a script starting with a line of the "
"form:"
msgstr ""
"B<execve>() выполняет программу, задаваемую аргументом I<filename>. В I<"
"filename> должно быть указано имя двоичного исполняемого файла или сценарий, "
"начинающийся со строки вида:"

#. type: Plain text
#: man-pages/man2/execve.2:55 man-pages/man2/execve.2:267
#, no-wrap
msgid "B<#!> I<interpreter >[optional-arg]\n"
msgstr "B<#!> I<интерпретатор >[необязательные параметры]\n"

#. type: Plain text
#: man-pages/man2/execve.2:59
msgid "For details of the latter case, see \"Interpreter scripts\" below."
msgstr "Подробней о сценариях написано далее в \"Интерпретируемые сценарии\"."

#. type: Plain text
#: man-pages/man2/execve.2:68
msgid ""
"I<argv> is an array of argument strings passed to the new program.  By "
"convention, the first of these strings should contain the filename "
"associated with the file being executed.  I<envp> is an array of strings, "
"conventionally of the form B<key=value>, which are passed as environment to "
"the new program.  Both I<argv> and I<envp> must be terminated by a null "
"pointer.  The argument vector and environment can be accessed by the called "
"program's main function, when it is defined as:"
msgstr ""
"I<argv> — это массив строковых параметров, передаваемых новой программе. По "
"соглашению, в первой строке должно содержаться имя файла, относящееся к "
"запускаемой программе. I<envp> — это массив строк в формате B<ключ=значение>, "
"которые передаются новой программе в качестве окружения (environment). Оба "
"массива I<argv> и I<envp> завершаются указателем null. К массиву параметров и "
"окружению можно обратиться из вызываемой программой функции main, если она "
"определена как:"

#. type: Plain text
#: man-pages/man2/execve.2:72
#, no-wrap
msgid "int main(int argc, char *argv[], char *envp[])\n"
msgstr "int main(int argc, char *argv[], char *envp[])\n"

#. type: Plain text
#: man-pages/man2/execve.2:79
msgid ""
"B<execve>()  does not return on success, and the text, data, bss, and stack "
"of the calling process are overwritten by that of the program loaded."
msgstr ""
"При успешном выполнении B<execve>() управление не возвращается, а код, "
"данные, bss и стек вызвавшего процесса перезаписываются загруженной "
"программой."

#. type: Plain text
#: man-pages/man2/execve.2:83
msgid ""
"If the current program is being ptraced, a B<SIGTRAP> is sent to it after a "
"successful B<execve>()."
msgstr ""
"Если текущая программа выполнялась под управлением ptrace, то после успешного "
"вызова B<execve>() ей посылается сигнал B<SIGTRAP>."

#. type: Plain text
#: man-pages/man2/execve.2:98
msgid ""
"If the set-user-ID bit is set on the program file pointed to by I<filename>,"
" and the underlying filesystem is not mounted I<nosuid> (the B<MS_NOSUID> "
"flag for B<mount>(2)), and the calling process is not being ptraced, then "
"the effective user ID of the calling process is changed to that of the owner"
" of the program file.  Similarly, when the set-group-ID bit of the program "
"file is set the effective group ID of the calling process is set to the "
"group of the program file."
msgstr ""
"Если у файла программы, указанного в I<filename>, установлен бит set-user-ID "
"и файловая система, в которой он хранится, не смонтирована с параметром I<"
"nosuid> (флаг B<MS_NOSUID> у B<mount>(2)), и вызывающий процесс не "
"выполняется под управлением ptrace, то фактический идентификатор пользователя "
"вызывающего процесса меняется на идентификатор владельца файла программы. "
"Точно также, если на файле программы установлен бит set-group-ID, то "
"фактический идентификатор группы вызывающего процесса становится равным "
"группе, которой принадлежит файл программы."

#. type: Plain text
#: man-pages/man2/execve.2:103
msgid ""
"The effective user ID of the process is copied to the saved set-user-ID; "
"similarly, the effective group ID is copied to the saved set-group-ID.  This"
" copying takes place after any effective ID changes that occur because of "
"the set-user-ID and set-group-ID permission bits."
msgstr ""
"Фактический идентификатор пользователя процесса копируется в сохранённый "
"идентификатор пользователя (set-user-ID), также фактический идентификатор "
"группы копируется в сохранённый идентификатор группы (set-group-ID). Это "
"копирование выполняется после изменения любого фактического идентификатора, "
"которое происходит из-за выставленных бит прав set-user-ID и set-group-ID."

#. type: Plain text
#: man-pages/man2/execve.2:111
msgid ""
"If the executable is an a.out dynamically linked binary executable "
"containing shared-library stubs, the Linux dynamic linker B<ld.so>(8)  is "
"called at the start of execution to bring needed shared libraries into "
"memory and link the executable with them."
msgstr ""
"Если исполняемый файл является динамически-скомпонованным файлом в формате "
"a.out, содержащим заглушки для динамических библиотек, то в начале выполнения "
"этого файла вызывается динамический компоновщик Linux \\(em B<ld.so>(8), "
"который загружает библиотеки в память и компонует их с исполняемым файлом."

#. type: Plain text
#: man-pages/man2/execve.2:120
msgid ""
"If the executable is a dynamically linked ELF executable, the interpreter "
"named in the PT_INTERP segment is used to load the needed shared libraries."
"  This interpreter is typically I</lib/ld-linux.so.2> for binaries linked "
"with glibc 2.  (For binaries linked with the old Linux libc5, the "
"interpreter was typically I</lib/ld-linux.so.1>.)"
msgstr ""
"Если исполняемый файл является динамически-скомпонованным файлом в формате "
"ELF, то для загрузки необходимых динамических библиотек используется "
"интерпретатор, указанный в сегменте PT_INTERP. Обычно, это I<"
"/lib/ld-linux.so.2> для программ, скомпонованных с glibc 2. (для программ, "
"скомпонованных со старой Linux libc5, обычно это I</lib/ld-linux.so.1>)."

#. type: Plain text
#: man-pages/man2/execve.2:124
msgid ""
"All process attributes are preserved during an B<execve>(), except the "
"following:"
msgstr ""
"При вызове B<execve>() сохраняются все свойства процесса, за исключением:"

#. type: Plain text
#: man-pages/man2/execve.2:128
msgid ""
"The dispositions of any signals that are being caught are reset to the "
"default (B<signal>(7))."
msgstr ""
"Значения обработчиков всех захватываемых сигналов сбрасываются в значения по "
"умолчанию (B<signal>(7))."

#. type: Plain text
#: man-pages/man2/execve.2:131
msgid "Any alternate signal stack is not preserved (B<sigaltstack>(2))."
msgstr "Любой альтернативный стек сигнала не сохраняется (B<sigaltstack>(2))."

#. type: Plain text
#: man-pages/man2/execve.2:134
msgid "Memory mappings are not preserved (B<mmap>(2))."
msgstr "Проецирование памяти не сохраняется (B<mmap>(2))."

#. type: Plain text
#: man-pages/man2/execve.2:137
msgid "Attached System\\ V shared memory segments are detached (B<shmat>(2))."
msgstr ""
"Подключённые общие сегменты памяти System\\ V отключаются (B<shmat>(2))."

#. type: Plain text
#: man-pages/man2/execve.2:140
msgid "POSIX shared memory regions are unmapped (B<shm_open>(3))."
msgstr ""
"Области общей памяти POSIX становятся неспроецированными (B<shm_open>(3))."

#. type: Plain text
#: man-pages/man2/execve.2:143
msgid "Open POSIX message queue descriptors are closed (B<mq_overview>(7))."
msgstr ""
"Открытые дескрипторы в очереди сообщений POSIX закрываются (B<mq_overview>"
"(7))."

#. type: Plain text
#: man-pages/man2/execve.2:146
msgid "Any open POSIX named semaphores are closed (B<sem_overview>(7))."
msgstr "Все открытые именные семафоры POSIX закрываются (B<sem_overview>(7))."

#. type: Plain text
#: man-pages/man2/execve.2:149
msgid "POSIX timers are not preserved (B<timer_create>(2))."
msgstr "Таймеры POSIX не сохраняются (B<timer_create>(2))."

#. type: Plain text
#: man-pages/man2/execve.2:152
msgid "Any open directory streams are closed (B<opendir>(3))."
msgstr ""
"Все открытые потоки каталогов (directory streams) закрываются (B<opendir>(3))."

#. type: Plain text
#: man-pages/man2/execve.2:156
msgid "Memory locks are not preserved (B<mlock>(2), B<mlockall>(2))."
msgstr "Блокировки памяти не сохраняются (B<mlock>(2), B<mlockall>(2))."

#. type: Plain text
#: man-pages/man2/execve.2:160
msgid "Exit handlers are not preserved (B<atexit>(3), B<on_exit>(3))."
msgstr ""
"Обработчики завершения работы (exit handlers) не сохраняются (B<atexit>(3), "
"B<on_exit>(3))."

#. type: Plain text
#: man-pages/man2/execve.2:163
msgid ""
"The floating-point environment is reset to the default (see B<fenv>(3))."
msgstr ""
"Окружения плавающей точки сбрасываются в настройки по умолчанию (B<fenv>(3))."

#. type: Plain text
#: man-pages/man2/execve.2:169
msgid ""
"The process attributes in the preceding list are all specified in "
"POSIX.1-2001.  The following Linux-specific process attributes are also not "
"preserved during an B<execve>():"
msgstr ""
"В POSIX.1-2001 определён список сохраняемых свойств процесса. Следующие "
"свойства процесса, имеющиеся только в Linux, также не сохраняются при B<"
"execve>():"

#. type: Plain text
#: man-pages/man2/execve.2:176
msgid ""
"The B<prctl>(2)  B<PR_SET_DUMPABLE> flag is set, unless a set-user-ID or "
"set-group ID program is being executed, in which case it is cleared."
msgstr ""
"Устанавливается флаг B<PR_SET_DUMPABLE> (B<prctl>(2)), если выполняемая "
"программа не имеет установленных бит set-user-ID или set-group-ID; в "
"противном случае он очищается."

#. type: Plain text
#: man-pages/man2/execve.2:181
msgid "The B<prctl>(2)  B<PR_SET_KEEPCAPS> flag is cleared."
msgstr "Флаг B<PR_SET_KEEPCAPS> (B<prctl>(2)) очищается."

#. type: Plain text
#: man-pages/man2/execve.2:188
msgid ""
"(Since Linux 2.4.36 / 2.6.23)  If a set-user-ID or set-group-ID program is "
"being executed, then the parent death signal set by B<prctl>(2)  "
"B<PR_SET_PDEATHSIG> flag is cleared."
msgstr ""
"(Начиная с Linux 2.4.36 / 2.6.23) Если выполняется программа с установленным "
"битом set-user-ID или set-group-ID, то сигнал о смерти родителя, "
"установленный B<prctl>(2) с флагом B<PR_SET_PDEATHSIG>, очищается."

#. type: Plain text
#: man-pages/man2/execve.2:195
msgid ""
"The process name, as set by B<prctl>(2)  B<PR_SET_NAME> (and displayed by "
"I<ps\\ -o comm>), is reset to the name of the new executable file."
msgstr ""
"Имя процесса, установленное через B<prctl>(2) B<PR_SET_NAME> (и отображаемое "
"I<ps\\ -o comm>), изменяется на имя нового исполняемого файла."

#. type: Plain text
#: man-pages/man2/execve.2:202
msgid ""
"The B<SECBIT_KEEP_CAPS> I<securebits> flag is cleared.  See "
"B<capabilities>(7)."
msgstr ""
"Флаг B<SECBIT_KEEP_CAPS> I<securebits> очищается. Смотрите B<capabilities>(7)."

#. type: Plain text
#: man-pages/man2/execve.2:207
msgid "The termination signal is reset to B<SIGCHLD> (see B<clone>(2))."
msgstr ""
"Сигнал завершения (termination signal) устанавливается в B<SIGCHLD> (B<clone>"
"(2))."

#. type: Plain text
#: man-pages/man2/execve.2:209
msgid "Note the following further points:"
msgstr "Также стоит учитывать следующее:"

#. type: Plain text
#: man-pages/man2/execve.2:213
msgid ""
"All threads other than the calling thread are destroyed during an "
"B<execve>().  Mutexes, condition variables, and other pthreads objects are "
"not preserved."
msgstr ""
"Все нити (threads), отличные от вызывающей, уничтожаются B<execve>(). "
"Мьютексы, условные переменные и другие объекты pthreads не сохраняются."

#. type: Plain text
#: man-pages/man2/execve.2:216
msgid ""
"The equivalent of I<setlocale(LC_ALL, \"C\")> is executed at program start-"
"up."
msgstr ""
"При запуске программы выполняется эквивалент I<setlocale(LC_ALL, \"C\")>."

#. type: Plain text
#: man-pages/man2/execve.2:224
msgid ""
"POSIX.1-2001 specifies that the dispositions of any signals that are ignored"
" or set to the default are left unchanged.  POSIX.1-2001 specifies one "
"exception: if B<SIGCHLD> is being ignored, then an implementation may leave "
"the disposition unchanged or reset it to the default; Linux does the former."
msgstr ""
"В POSIX.1-2001 указано, что действия по отношению к любым игнорируемым или "
"имеющим настройку по умолчанию сигналам, остаются неизменными. В POSIX.1-2001 "
"есть одно исключение: если B<SIGCHLD> игнорируется, то реализация может "
"оставить обработку сигнала (disposition) неизменной или вернуть настройку по "
"умолчанию; в Linux используется первое."

#. type: Plain text
#: man-pages/man2/execve.2:228
msgid ""
"Any outstanding asynchronous I/O operations are canceled (B<aio_read>(3), "
"B<aio_write>(3))."
msgstr ""
"Все ожидающие выполнения асинхронные операции ввода-вывод отменяются (B<"
"aio_read>(3), B<aio_write>(3))."

#. type: Plain text
#: man-pages/man2/execve.2:233
msgid ""
"For the handling of capabilities during B<execve>(), see B<capabilities>(7)."
msgstr ""
"Как происходит обработка мандатов (capabilities) при вызове B<execve>(), см. "
"B<capabilities>(7)."

#.  On Linux it appears that these file descriptors are
#.  always open after an execve(), and it looks like
#.  Solaris 8 and FreeBSD 6.1 are the same. -- mtk, 30 Apr 2007
#. type: Plain text
#: man-pages/man2/execve.2:260
msgid ""
"By default, file descriptors remain open across an B<execve>().  File "
"descriptors that are marked close-on-exec are closed; see the description of"
" B<FD_CLOEXEC> in B<fcntl>(2).  (If a file descriptor is closed, this will "
"cause the release of all record locks obtained on the underlying file by "
"this process.  See B<fcntl>(2)  for details.)  POSIX.1-2001 says that if "
"file descriptors 0, 1, and 2 would otherwise be closed after a successful "
"B<execve>(), and the process would gain privilege because the set-user_ID or"
" set-group_ID permission bit was set on the executed file, then the system "
"may open an unspecified file for each of these file descriptors.  As a "
"general principle, no portable program, whether privileged or not, can "
"assume that these three file descriptors will remain closed across an "
"B<execve>()."
msgstr ""
"По умолчанию, файловые дескрипторы остаются открытыми после B<execve>(). "
"Файловые дескрипторы, помеченные как close-on-exec (закрывать при запуске), "
"закрываются; см. описание B<FD_CLOEXEC> в B<fcntl>(2). (Если файловый "
"дескриптор закрыт, это приводит к освобождению всех имеющихся блокировок, "
"полученных на соответствующий файл данным процессом. Подробней см. B<fcntl>"
"(2).) В POSIX.1-2001 сказано, что если бы файловые дескрипторы 0, 1 и 2 были "
"закрыты после успешного вызова B<execve>(), и процесс получил бы привилегии "
"из-за установленных битов set-user_ID или set-group_ID на исполняемом файле, "
"то система смогла бы открыть произвольный файл для каждого из этих "
"дескрипторов. Считается, что переносимая программа, с привилегиями или без, "
"не может рассчитывать, что эти три файловых дескриптора будут оставаться "
"закрытыми после B<execve>()."

#. type: SS
#: man-pages/man2/execve.2:260 man-pages/man2/execve.2:530
#, no-wrap
msgid "Interpreter scripts"
msgstr "Интерпретируемые сценарии"

#. type: Plain text
#: man-pages/man2/execve.2:263
msgid ""
"An interpreter script is a text file that has execute permission enabled and"
" whose first line is of the form:"
msgstr ""
"Интерпретируемый сценарий \\(em это текстовый файл, у которого установлен бит "
"выполнения и первая строка имеет вид:"

#. type: Plain text
#: man-pages/man2/execve.2:281
msgid ""
"The I<interpreter> must be a valid pathname for an executable which is not "
"itself a script.  If the I<filename> argument of B<execve>()  specifies an "
"interpreter script, then I<interpreter> will be invoked with the following "
"arguments:"
msgstr ""
"В поле I<интерпретатор> должно быть указано имя файла запуска, это не имя "
"самого файла сценария. Если в аргументе I<filename> для B<execve>() указан "
"интерпретируемый сценарий, то I<интерпретатор> будет вызван со следующими "
"параметрами:"

#. type: Plain text
#: man-pages/man2/execve.2:285
#, no-wrap
msgid "I<interpreter> [optional-arg] I<filename> arg...\n"
msgstr "I<интерпретатор> [необязательный параметр] I<имя файла> параметр...\n"

#. type: Plain text
#: man-pages/man2/execve.2:296
msgid ""
"where I<arg...> is the series of words pointed to by the I<argv> argument of"
" B<execve>(), starting at I<argv>[1]."
msgstr ""
"где I<параметр...> — последовательность слов, указываемых аргументом I<argv> "
"в B<execve>() начиная с I<argv>[1]."

#. type: Plain text
#: man-pages/man2/execve.2:301
msgid ""
"For portable use, I<optional-arg> should either be absent, or be specified "
"as a single word (i.e., it should not contain white space); see NOTES below."
msgstr ""
"В целях переносимости, I<необязательный параметр> должен быть или пустым, или "
"задаваться одним словом (т.е., не должен содержать пробельных символов); см. "
"ЗАМЕЧАНИЯ далее."

#. type: SS
#: man-pages/man2/execve.2:301
#, no-wrap
msgid "Limits on size of arguments and environment"
msgstr "Ограничения на размер параметров и окружения"

#. type: Plain text
#: man-pages/man2/execve.2:314
msgid ""
"Most UNIX implementations impose some limit on the total size of the "
"command-line argument (I<argv>)  and environment (I<envp>)  strings that may"
" be passed to a new program.  POSIX.1 allows an implementation to advertise "
"this limit using the B<ARG_MAX> constant (either defined in "
"I<E<lt>limits.hE<gt>> or available at run time using the call "
"I<sysconf(_SC_ARG_MAX)>)."
msgstr ""
"Большинство реализаций UNIX накладывает некоторые ограничения на полный "
"размер параметра командной строки (I<argv>) и окружения (I<envp>), которые "
"можно передать новой программе. POSIX.1 позволяет реализации объявить это "
"ограничение через константу B<ARG_MAX> (определённую в I<E<lt>limits.hE<gt>> "
"или сделать её доступной во время выполнения через вызов I<"
"sysconf(_SC_ARG_MAX)>)."

#. type: Plain text
#: man-pages/man2/execve.2:321
msgid ""
"On Linux prior to kernel 2.6.23, the memory used to store the environment "
"and argument strings was limited to 32 pages (defined by the kernel constant"
" B<MAX_ARG_PAGES>).  On architectures with a 4-kB page size, this yields a "
"maximum size of 128 kB."
msgstr ""
"В ядре Linux до версии 2.6.23 размер памяти, используемый для хранения "
"окружения и строк параметров, был ограничен 32 страницами (определялся "
"ядерной константой B<MAX_ARG_PAGES>). На архитектурах с 4-КиБ размером "
"страницы это давало максимальный размер в 128 КиБ."

#.  For some background on the changes to ARG_MAX in kernels 2.6.23 and
#.  2.6.25, see:
#.      http://sourceware.org/bugzilla/show_bug.cgi?id=5786
#.      http://bugzilla.kernel.org/show_bug.cgi?id=10095
#.      http://thread.gmane.org/gmane.linux.kernel/646709/focus=648101,
#.      checked into 2.6.25 as commit
#. a64e715fc74b1a7dcc5944f848acc38b2c4d4ee2.
#.  Ollie: That doesn't include the lists of pointers, though,
#.  so the actual usage is a bit higher (1 pointer per argument).
#. type: Plain text
#: man-pages/man2/execve.2:357
msgid ""
"On kernel 2.6.23 and later, most architectures support a size limit derived "
"from the soft B<RLIMIT_STACK> resource limit (see B<getrlimit>(2))  that is "
"in force at the time of the B<execve>()  call.  (Architectures with no "
"memory management unit are excepted: they maintain the limit that was in "
"effect before kernel 2.6.23.)  This change allows programs to have a much "
"larger argument and/or environment list.  For these architectures, the total"
" size is limited to 1/4 of the allowed stack size.  (Imposing the 1/4-limit "
"ensures that the new program always has some stack space.)  Since Linux "
"2.6.25, the kernel places a floor of 32 pages on this size limit, so that, "
"even when B<RLIMIT_STACK> is set very low, applications are guaranteed to "
"have at least as much argument and environment space as was provided by "
"Linux 2.6.23 and earlier.  (This guarantee was not provided in Linux 2.6.23 "
"and 2.6.24.)  Additionally, the limit per string is 32 pages (the kernel "
"constant B<MAX_ARG_STRLEN>), and the maximum number of strings is "
"0x7FFFFFFF."
msgstr ""
"Начиная с ядра версии 2.6.23, большинство архитектур поддерживают предельный "
"размер, высчитываемый от мягкого ограничения ресурса B<RLIMIT_STACK> (см. B<"
"getrlimit>(2)), который действует во время вызова B<execve>(). (Исключение "
"составляют архитектуры без механизма управления памятью: в них ограничение "
"рассчитывается как и до версии 2.6.23.) Это изменение позволяет программам "
"иметь больший список параметров и/или окружения. Для этих архитектур полный "
"размер ограничен до 1/4 разрешённого размера стека. (Накладываемое "
"ограничение в 1/4 позволяет новой программе всегда иметь некоторое "
"пространство под стек.) Начиная с Linux версии 2.6.25, ядро отводит нижние 32 "
"страницы для этого предельного размера, поэтому, даже когда B<RLIMIT_STACK> "
"задан слишком низко, приложения гарантированно получат, по крайней мере, "
"столько же пространства под параметры и окружение, сколько бы они получили "
"при работе с Linux 2.6.23 и ранее. (Это гарантия не обеспечивалась в Linux "
"2.6.23 и 2.6.24.) Также, размер строки ограничен 32 страницами (ядерная "
"константа B<MAX_ARG_STRLEN>), а максимальное число строк может быть "
"0x7FFFFFFF."

#. type: Plain text
#: man-pages/man2/execve.2:363
msgid ""
"On success, B<execve>()  does not return, on error -1 is returned, and "
"I<errno> is set appropriately."
msgstr ""
"При успешном выполнении B<execve>() не возвращает управление. В случае ошибки "
"возвращается -1, а I<errno> устанавливается в соответствующее значение."

#. type: TP
#: man-pages/man2/execve.2:364
#, no-wrap
msgid "B<E2BIG>"
msgstr "B<E2BIG>"

#. type: Plain text
#: man-pages/man2/execve.2:371
msgid ""
"The total number of bytes in the environment (I<envp>)  and argument list "
"(I<argv>)  is too large."
msgstr ""
"Слишком большое общее количество байт для окружения (I<envp>) и списка "
"параметров (I<argv>)."

#. type: TP
#: man-pages/man2/execve.2:371 man-pages/man2/execve.2:378
#: man-pages/man2/execve.2:381 man-pages/man2/execve.2:384
#, no-wrap
msgid "B<EACCES>"
msgstr "B<EACCES>"

#. type: Plain text
#: man-pages/man2/execve.2:378
msgid ""
"Search permission is denied on a component of the path prefix of I<filename>"
" or the name of a script interpreter.  (See also B<path_resolution>(7).)"
msgstr ""
"В одном из каталогов префикса I<filename> или интерпретатора не разрешён "
"поиск. (см. также B<path_resolution>(7))"

#. type: Plain text
#: man-pages/man2/execve.2:381
msgid "The file or a script interpreter is not a regular file."
msgstr "Файл или интерпретатор не являются обычным файлом."

#. type: Plain text
#: man-pages/man2/execve.2:384
msgid ""
"Execute permission is denied for the file or a script or ELF interpreter."
msgstr ""
"Не установлен бит выполнения на файле или сценарии или интерпретаторе ELF."

#. type: Plain text
#: man-pages/man2/execve.2:388
msgid "The filesystem is mounted I<noexec>."
msgstr "Файловая система смонтирована с I<noexec>."

#. type: TP
#: man-pages/man2/execve.2:388
#, no-wrap
msgid "B<EAGAIN> (since Linux 3.1)"
msgstr "B<EAGAIN> (начиная с Linux 3.1)"

#.  commit 72fa59970f8698023045ab0713d66f3f4f96945c
#. type: Plain text
#: man-pages/man2/execve.2:398
msgid ""
"Having changed its real UID using one of the B<set*uid>()  calls, the caller"
" was\\(emand is now still\\(emabove its B<RLIMIT_NPROC> resource limit (see "
"B<setrlimit>(2)).  For a more detailed explanation of this error, see NOTES."
msgstr ""
"Из-за изменения реального UID одним из вызовов B<set*uid>() ранее, вызывающий "
"всё ещё превышает ограничитель ресурса B<RLIMIT_NPROC> (смотрите B<setrlimit>"
"(2)). Подробное объяснение этой ошибки смотрите в ЗАМЕЧАНИЯХ."

#. type: TP
#: man-pages/man2/execve.2:398
#, no-wrap
msgid "B<EFAULT>"
msgstr "B<EFAULT>"

#. type: Plain text
#: man-pages/man2/execve.2:406
msgid ""
"I<filename> or one of the pointers in the vectors I<argv> or I<envp> points "
"outside your accessible address space."
msgstr ""
"Значение I<filename> или один из указателей в векторах I<argv> или I<envp> "
"указывает за пределы доступного адресного пространства."

#. type: Plain text
#: man-pages/man2/execve.2:410
msgid ""
"An ELF executable had more than one PT_INTERP segment (i.e., tried to name "
"more than one interpreter)."
msgstr ""
"Исполняемый ELF-файл содержит более одного сегмента PT_INTERP (т.е., в нём "
"указано более одного интерпретатора)."

#. type: TP
#: man-pages/man2/execve.2:410
#, no-wrap
msgid "B<EIO>"
msgstr "B<EIO>"

#. type: Plain text
#: man-pages/man2/execve.2:413
msgid "An I/O error occurred."
msgstr "Произошла ошибка ввода-вывода."

#. type: TP
#: man-pages/man2/execve.2:413
#, no-wrap
msgid "B<EISDIR>"
msgstr "B<EISDIR>"

#. type: Plain text
#: man-pages/man2/execve.2:416
msgid "An ELF interpreter was a directory."
msgstr "Интерпретатор ELF является каталогом."

#. type: TP
#: man-pages/man2/execve.2:416
#, no-wrap
msgid "B<ELIBBAD>"
msgstr "B<ELIBBAD>"

#. type: Plain text
#: man-pages/man2/execve.2:419
msgid "An ELF interpreter was not in a recognized format."
msgstr "Не распознан формат интерпретатора ELF."

#. type: TP
#: man-pages/man2/execve.2:419
#, no-wrap
msgid "B<ELOOP>"
msgstr "B<ELOOP>"

#. type: Plain text
#: man-pages/man2/execve.2:424
msgid ""
"Too many symbolic links were encountered in resolving I<filename> or the "
"name of a script or ELF interpreter."
msgstr ""
"Во время определения I<filename>, имени сценария или интерпретатора ELF "
"встретилось слишком много символьных ссылок."

#. type: Plain text
#: man-pages/man2/execve.2:427
msgid "The process has the maximum number of files open."
msgstr ""
"Было достигнуто ограничение по открытым файловым дескрипторам на процесс."

#. type: TP
#: man-pages/man2/execve.2:427
#, no-wrap
msgid "B<ENAMETOOLONG>"
msgstr "B<ENAMETOOLONG>"

#. type: Plain text
#: man-pages/man2/execve.2:431
msgid "I<filename> is too long."
msgstr "Слишком длинное значение аргумента I<filename>."

#. type: Plain text
#: man-pages/man2/execve.2:434
msgid "The system limit on the total number of open files has been reached."
msgstr "Достигнуто максимальное количество открытых файлов в системе."

#. type: TP
#: man-pages/man2/execve.2:434
#, no-wrap
msgid "B<ENOENT>"
msgstr "B<ENOENT>"

#. type: Plain text
#: man-pages/man2/execve.2:440
msgid ""
"The file I<filename> or a script or ELF interpreter does not exist, or a "
"shared library needed for file or interpreter cannot be found."
msgstr ""
"Файл I<filename>, сценарий или интерпретатор ELF не существует, или не "
"найдена динамическая библиотека, необходимая для файлового интерпретатора."

#. type: TP
#: man-pages/man2/execve.2:440
#, no-wrap
msgid "B<ENOEXEC>"
msgstr "B<ENOEXEC>"

#. type: Plain text
#: man-pages/man2/execve.2:445
msgid ""
"An executable is not in a recognized format, is for the wrong architecture, "
"or has some other format error that means it cannot be executed."
msgstr ""
"Не распознан формат исполняемого файла, он не подходит для архитектуры, или "
"имеет ошибки в формате, из-за чего не может быть выполнен."

#. type: Plain text
#: man-pages/man2/execve.2:448
msgid "Insufficient kernel memory was available."
msgstr "Недостаточное количество памяти ядра."

#. type: TP
#: man-pages/man2/execve.2:448
#, no-wrap
msgid "B<ENOTDIR>"
msgstr "B<ENOTDIR>"

#. type: Plain text
#: man-pages/man2/execve.2:453
msgid ""
"A component of the path prefix of I<filename> or a script or ELF interpreter"
" is not a directory."
msgstr ""
"Компонент пути в I<filename>, сценарии или интерпретаторе ELF в "
"действительности не является каталогом."

#. type: TP
#: man-pages/man2/execve.2:453 man-pages/man2/execve.2:459
#, no-wrap
msgid "B<EPERM>"
msgstr "B<EPERM>"

#. type: Plain text
#: man-pages/man2/execve.2:459
msgid ""
"The filesystem is mounted I<nosuid>, the user is not the superuser, and the "
"file has the set-user-ID or set-group-ID bit set."
msgstr ""
"Файловая система смонтирована с I<nosuid>, пользователь не является "
"суперпользователем, а на файле установлен бит set-user-ID или set-group-ID."

#. type: Plain text
#: man-pages/man2/execve.2:463
msgid ""
"The process is being traced, the user is not the superuser and the file has "
"the set-user-ID or set-group-ID bit set."
msgstr ""
"Над процессом выполняется трассировка, пользователь не имеет прав "
"суперпользователя, а у файла установлен бит set-user-ID или set-group-ID."

#. type: TP
#: man-pages/man2/execve.2:463
#, no-wrap
msgid "B<ETXTBSY>"
msgstr "B<ETXTBSY>"

#. type: Plain text
#: man-pages/man2/execve.2:466
msgid "Executable was open for writing by one or more processes."
msgstr "Исполняемый файл был открыт на запись одним или более процессов."

#.  SVr4 documents additional error
#.  conditions EAGAIN, EINTR, ELIBACC, ENOLINK, EMULTIHOP; POSIX does not
#.  document ETXTBSY, EPERM, EFAULT, ELOOP, EIO, ENFILE, EMFILE, EINVAL,
#.  EISDIR or ELIBBAD error conditions.
#. type: Plain text
#: man-pages/man2/execve.2:474
msgid ""
"SVr4, 4.3BSD, POSIX.1-2001.  POSIX.1-2001 does not document the #! behavior "
"but is otherwise compatible."
msgstr ""
"SVr4, 4.3BSD, POSIX.1-2001. В POSIX.1-2001 не описано поведение #!, но в "
"остальном совместимость есть."

#. type: Plain text
#: man-pages/man2/execve.2:477
msgid "Set-user-ID and set-group-ID processes can not be B<ptrace>(2)d."
msgstr ""
"Над процессами с установленными set-user-ID и set-group-ID не может "
"выполняться B<ptrace>(2)."

#.  e.g., EFAULT on Solaris 8 and FreeBSD 6.1; but
#.  HP-UX 11 is like Linux -- mtk, Apr 2007
#.  Bug filed 30 Apr 2007: http://bugzilla.kernel.org/show_bug.cgi?id=8408
#.  Bug rejected (because fix would constitute an ABI change).
#. type: Plain text
#: man-pages/man2/execve.2:504
msgid ""
"The result of mounting a filesystem I<nosuid> varies across Linux kernel "
"versions: some will refuse execution of set-user-ID and set-group-ID "
"executables when this would give the user powers she did not have already "
"(and return B<EPERM>), some will just ignore the set-user-ID and set-group-"
"ID bits and B<exec>()  successfully.  On Linux, I<argv> and I<envp> can be "
"specified as NULL.  In both cases, this has the same effect as specifying "
"the argument as a pointer to a list containing a single null pointer.  B<Do "
"not take advantage of this misfeature!> It is nonstandard and nonportable: "
"on most other UNIX systems doing this will result in an error (B<EFAULT>)."
msgstr ""
"Результат монтирования файловой системы с I<nosuid> различается в разных "
"версиях ядра Linux: некоторые не будут запускать исполняемые файлы с "
"установленным битом set-user-ID и set-group-ID, если это дало бы пользователю "
"права, которыми он ещё не владеет (и возвращают B<EPERM>), другие просто "
"игнорируют биты set-user-ID и set-group-ID bits и выполняют B<exec>(). В "
"Linux, значения I<argv> и I<envp> могут быть указаны как NULL. В обоих "
"случаях, это вызовет тот же эффект, как при указании аргумента как указателя "
"на список, содержащий один указатель null. B<Не пользуйтесь этим!> Это "
"нестандартно и не переносимо: в большинстве других системах UNIX это приводит "
"к ошибке (B<EFAULT>)."

#. type: Plain text
#: man-pages/man2/execve.2:515
msgid ""
"POSIX.1-2001 says that values returned by B<sysconf>(3)  should be invariant"
" over the lifetime of a process.  However, since Linux 2.6.23, if the "
"B<RLIMIT_STACK> resource limit changes, then the value reported by "
"B<_SC_ARG_MAX> will also change, to reflect the fact that the limit on space"
" for holding command-line arguments and environment variables has changed."
msgstr ""
"В POSIX.1-2001 указано, что значения, возвращаемые B<sysconf>(3), должны быть "
"неизменны в течении существования процесса. Однако, начиная с версии Linux "
"2.6.23, если изменяется ограничение ресурса B<RLIMIT_STACK>, то значение, "
"возвращаемое для B<_SC_ARG_MAX>, также будет изменено, чтобы отразить, что "
"ограничение на пространство для хранения параметров командной строки и "
"окружения было изменено."

#. type: Plain text
#: man-pages/man2/execve.2:530
msgid ""
"In most cases where B<execve>()  fails, control returns to the original "
"executable image, and the caller of B<execve>()  can then handle the error."
"  However, in (rare) cases (typically caused by resource exhaustion), "
"failure may occur past the point of no return: the original executable image"
" has been torn down, but the new image could not be completely built.  In "
"such cases, the kernel kills the process with a B<SIGKILL> signal."
msgstr ""
"В большинстве случаев отказа B<execve>() управление возвращается в "
"первоначально исполняемый образ и вызывающий B<execve>() может обработать "
"ошибку. Однако в (редких) случаях (обычно вызванных отсутствием ресурсов), "
"ошибка может возникнуть после точки невозврата: первоначально исполняемый "
"образ уже разрушен, а новый образ ещё сознан не полностью. В таких случаях "
"ядро убивает процесс сигналом B<SIGKILL>."

#. type: Plain text
#: man-pages/man2/execve.2:533
msgid ""
"A maximum line length of 127 characters is allowed for the first line in an "
"interpreter scripts."
msgstr ""
"Максимальная длина первой строки с указанным интерпретатором сценариев — 127 "
"символов."

#.  e.g., Solaris 8
#.  e.g., FreeBSD before 6.0, but not FreeBSD 6.0 onward
#. type: Plain text
#: man-pages/man2/execve.2:552
msgid ""
"The semantics of the I<optional-arg> argument of an interpreter script vary "
"across implementations.  On Linux, the entire string following the "
"I<interpreter> name is passed as a single argument to the interpreter, and "
"this string can include white space.  However, behavior differs on some "
"other systems.  Some systems use the first white space to terminate I"
"<optional-arg>.  On some systems, an interpreter script can have multiple "
"arguments, and white spaces in I<optional-arg> are used to delimit the "
"arguments."
msgstr ""
"Семантика I<необязательного параметра> интерпретатора сценариев различна в "
"разных реализациях. В Linux, вся строка после имени I<интерпретатора> "
"передаётся интерпретатору как единый параметр, и эта строка может содержать "
"пробельные символы. Однако, такое поведение отличается от других систем. "
"Некоторые системы используют первый пробел в качестве признака окончания I<"
"необязательного параметра>. В других системах, интерпретатор сценариев может "
"иметь несколько параметров, и пробелы в I<необязательном параметре> "
"используются для их разграничения."

#.  .SH BUGS
#.  Some Linux versions have failed to check permissions on ELF
#.  interpreters.  This is a security hole, because it allows users to
#.  open any file, such as a rewinding tape device, for reading.  Some
#.  Linux versions have also had other security holes in
#.  .BR execve ()
#.  that could be exploited for denial of service by a suitably crafted
#.  ELF binary. There are no known problems with 2.0.34 or 2.2.15.
#. type: Plain text
#: man-pages/man2/execve.2:563
msgid "Linux ignores the set-user-ID and set-group-ID bits on scripts."
msgstr ""
"В Linux игнорируются биты set-user-ID и set-group-ID на файлах со сценариями."

#. type: SS
#: man-pages/man2/execve.2:563
#, no-wrap
msgid "execve() and EAGAIN"
msgstr "execve() и EAGAIN"

#. type: Plain text
#: man-pages/man2/execve.2:569
msgid ""
"A more detailed explanation of the B<EAGAIN> error that can occur (since "
"Linux 3.1) when calling B<execve>()  is as follows."
msgstr ""
"Это более подробное объяснение ошибки B<EAGAIN>, которая возвращается "
"(начиная с Linux 3.1) при вызове B<execve>()."

#.  commit 909cc4ae86f3380152a18e2a3c44523893ee11c4
#. type: Plain text
#: man-pages/man2/execve.2:591
msgid ""
"The B<EAGAIN> error can occur when a I<preceding> call to B<setuid>(2), "
"B<setreuid>(2), or B<setresuid>(2)  caused the real user ID of the process "
"to change, and that change caused the process to exceed its B<RLIMIT_NPROC> "
"resource limit (i.e., the number of processes belonging to the new real UID "
"exceeds the resource limit).  From Linux 2.6.0 to 3.0, this caused the "
"B<set*uid>()  call to fail.  (Prior to 2.6, the resource limit was not "
"imposed on processes that changed their user IDs.)"
msgstr ""
"Ошибка B<EAGAIN> может возникать, когда I<предшествующий> вызов B<setuid>(2), "
"B<setreuid>(2) или B<setresuid>(2) приводит к изменению у процесса реального "
"идентификатора пользователя и это изменение приводит к тому, что процесс "
"превышает свой ограничитель ресурса B<RLIMIT_NPROC> (т. е., количество "
"процессов, принадлежащих новому реальному UID, превышает ограничитель "
"ресурса). В версиях Linux с 2.6.0 по 3.0, это приводит к ошибке вызова B<"
"set*uid>() (до версии 2.6 ограничитель ресурса не учитывался для процессов, "
"которые изменили идентификатор пользователя)."

#. type: Plain text
#: man-pages/man2/execve.2:622
msgid ""
"Since Linux 3.1, the scenario just described no longer causes the "
"B<set*uid>()  call to fail, because it too often led to security holes where"
" buggy applications didn't check the return status and assumed that\\(emif "
"the caller had root privileges\\(emthe call would always succeed.  Instead, "
"the B<set*uid>()  calls now successfully change the real UID, but the kernel"
" sets an internal flag, named B<PF_NPROC_EXCEEDED>, to note that the "
"B<RLIMIT_NPROC> resource limit has been exceeded.  If the "
"B<PF_NPROC_EXCEEDED> flag is set and the resource limit is still exceeded at"
" the time of a subsequent B<execve>()  call, that call fails with the error "
"B<EAGAIN>.  This kernel logic ensures that the B<RLIMIT_NPROC> resource "
"limit is still enforced for the common privileged daemon "
"workflow\\(emnamely, B<fork>(2)  + B<set*uid>()  + B<execve>()."
msgstr ""
"Начиная с Linux 3.1, описанный сценарий больше не приводит к ошибке в вызове "
"B<set*uid>(), так как это слишком часто приводило к дырам в безопасности, "
"когда некорректное приложение не проверяет возвращаемое состояние и "
"предполагает, что если вызывающий имеет права root, то вызов всегда "
"выполняется успешно. Вместо этого вызов B<set*uid>() теперь успешно изменяет "
"реальный UID, но ядро устанавливает внутренний флаг с именем B<"
"PF_NPROC_EXCEEDED>, который означает, что был превышен ограничитель ресурса "
"B<RLIMIT_NPROC>. Если флаг B<PF_NPROC_EXCEEDED> установлен и ограничитель "
"ресурса всё ещё превышен на момент последующего вызова B<execve>(), то вызов "
"завершается с ошибкой B<EAGAIN>. Такая логика ядра гарантирует, что "
"ограничитель ресурса B<RLIMIT_NPROC> будет учтён при обычной "
"последовательности действий для привилегированных служб, а именно — B<fork>"
"(2)  + B<set*uid>()  + B<execve>()."

#. type: Plain text
#: man-pages/man2/execve.2:638
msgid ""
"If the resource limit was not still exceeded at the time of the B<execve>()"
"  call (because other processes belonging to this real UID terminated "
"between the B<set*uid()> call and the B<execve>()  call), then the "
"B<execve>()  call succeeds and the kernel clears the B<PF_NPROC_EXCEEDED> "
"process flag.  The flag is also cleared if a subsequent call to B<fork>(2)  "
"by this process succeeds."
msgstr ""
"Если ограничитель ресурса был не превышен на момент вызова B<execve>() (так "
"как другие процессы, принадлежащие этому реальному UID завершили работу между "
"вызовом B<set*uid()> и B<execve>()), то вызов B<execve>() выполнится успешно "
"и ядро очистит флаг B<PF_NPROC_EXCEEDED> у процесса. Флаг также очищается, "
"если при успешном выполнении процессом последующего вызова B<fork>(2)."

#. type: SS
#: man-pages/man2/execve.2:638
#, no-wrap
msgid "Historical"
msgstr "Историческая справка"

#.  .SH BUGS
#.  Some Linux versions have failed to check permissions on ELF
#.  interpreters.  This is a security hole, because it allows users to
#.  open any file, such as a rewinding tape device, for reading.  Some
#.  Linux versions have also had other security holes in
#.  .BR execve ()
#.  that could be exploited for denial of service by a suitably crafted
#.  ELF binary. There are no known problems with 2.0.34 or 2.2.15.
#. type: Plain text
#: man-pages/man2/execve.2:658
msgid ""
"With UNIX\\ V6, the argument list of an B<exec>()  call was ended by 0, "
"while the argument list of I<main> was ended by -1.  Thus, this argument "
"list was not directly usable in a further B<exec>()  call.  Since UNIX\\ V7,"
" both are NULL."
msgstr ""
"В UNIX\\ V6 список аргументов вызова B<exec>() заканчивался 0, а список "
"аргументов I<main> заканчивался -1. Поэтому, этот список аргументов не мог "
"быть использован напрямую в последующем вызове B<exec>(). Начиная с UNIX\\ V7 "
"оба списка стали оканчиваться NULL."

#. type: Plain text
#: man-pages/man2/execve.2:661
msgid ""
"The following program is designed to be execed by the second program below."
"  It just echoes its command-line arguments, one per line."
msgstr ""
"Данная программа запускается второй программой, представленной ниже. Она "
"просто выводит свои параметры командной строки по одному на строку."

#. type: Plain text
#: man-pages/man2/execve.2:665
#, no-wrap
msgid "/* myecho.c */\n"
msgstr "/* myecho.c */\n"

#. type: Plain text
#: man-pages/man2/execve.2:668
#, no-wrap
msgid ""
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
msgstr "#include E<lt>stdio.hE<gt>\n#include E<lt>stdlib.hE<gt>\n"

#. type: Plain text
#: man-pages/man2/execve.2:673
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int j;\n"
msgstr "int\nmain(int argc, char *argv[])\n{\n    int j;\n"

#. type: Plain text
#: man-pages/man2/execve.2:676
#, no-wrap
msgid ""
"    for (j = 0; j E<lt> argc; j++)\n"
"        printf(\"argv[%d]: %s\\en\", j, argv[j]);\n"
msgstr ""
"    for (j = 0; j E<lt> argc; j++)\n        printf(\"argv[%d]: %s\\en\", j, "
"argv[j]);\n"

#. type: Plain text
#: man-pages/man2/execve.2:679
#, no-wrap
msgid ""
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr "    exit(EXIT_SUCCESS);\n}\n"

#. type: Plain text
#: man-pages/man2/execve.2:684
msgid ""
"This program can be used to exec the program named in its command-line "
"argument:"
msgstr ""
"Эта программа может использоваться для запуска программы, чьё имя указано в "
"параметре командной строки."

#. type: Plain text
#: man-pages/man2/execve.2:688
#, no-wrap
msgid "/* execve.c */\n"
msgstr "/* execve.c */\n"

#. type: Plain text
#: man-pages/man2/execve.2:692
#, no-wrap
msgid ""
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
msgstr ""
"#include E<lt>stdio.hE<gt>\n#include E<lt>stdlib.hE<gt>\n#include E<lt>"
"unistd.hE<gt>\n"

#. type: Plain text
#: man-pages/man2/execve.2:698
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    char *newargv[] = { NULL, \"hello\", \"world\", NULL };\n"
"    char *newenviron[] = { NULL };\n"
msgstr ""
"int\nmain(int argc, char *argv[])\n{\n    char *newargv[] = { NULL, "
"\"hello\", \"world\", NULL };\n    char *newenviron[] = { NULL };\n"

#. type: Plain text
#: man-pages/man2/execve.2:703
#, no-wrap
msgid ""
"    if (argc != 2) {\n"
"        fprintf(stderr, \"Usage: %s E<lt>file-to-execE<gt>\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    if (argc != 2) {\n        fprintf(stderr, \"Использование: %s E<lt>"
"file-to-execE<gt>\\en\", argv[0]);\n        exit(EXIT_FAILURE);\n    }\n"

#. type: Plain text
#: man-pages/man2/execve.2:705
#, no-wrap
msgid "    newargv[0] = argv[1];\n"
msgstr "    newargv[0] = argv[1];\n"

#. type: Plain text
#: man-pages/man2/execve.2:710
#, no-wrap
msgid ""
"    execve(argv[1], newargv, newenviron);\n"
"    perror(\"execve\");   /* execve() only returns on error */\n"
"    exit(EXIT_FAILURE);\n"
"}\n"
msgstr ""
"    execve(argv[1], newargv, newenviron);\n    perror(\"execve\");   /* "
"execve() возвращается только при ошибке */\n    exit(EXIT_FAILURE);\n}\n"

#. type: Plain text
#: man-pages/man2/execve.2:714
msgid "We can use the second program to exec the first as follows:"
msgstr "Мы можем использовать вторую программу для запуска первой:"

#. type: Plain text
#: man-pages/man2/execve.2:723
#, no-wrap
msgid ""
"$B< cc myecho.c -o myecho>\n"
"$B< cc execve.c -o execve>\n"
"$B< ./execve ./myecho>\n"
"argv[0]: ./myecho\n"
"argv[1]: hello\n"
"argv[2]: world\n"
msgstr ""
"$B< cc myecho.c -o myecho>\n$B< cc execve.c -o execve>\n$B< ./execve ./myecho>"
"\nargv[0]: ./myecho\nargv[1]: hello\nargv[2]: world\n"

#. type: Plain text
#: man-pages/man2/execve.2:731
msgid ""
"We can also use these programs to demonstrate the use of a script "
"interpreter.  To do this we create a script whose \"interpreter\" is our "
"I<myecho> program:"
msgstr ""
"Также мы можем использовать эти программы для демонстрации использования "
"интерпретатора сценариев. Для этого создадим сценарий, чей \"интерпретатор\" "
"указывает на нашу программу I<myecho>:"

#. type: Plain text
#: man-pages/man2/execve.2:738
#, no-wrap
msgid ""
"$B< cat E<gt> script.sh>\n"
"B<#! ./myecho script-arg>\n"
"B<^D>\n"
"$B< chmod +x script.sh>\n"
msgstr ""
"$B< cat E<gt> script.sh>\nB<#! ./myecho script-arg>\nB<^D>\n$B< chmod +x "
"script.sh>\n"

#. type: Plain text
#: man-pages/man2/execve.2:742
msgid "We can then use our program to exec the script:"
msgstr "Теперь мы можем использовать нашу программу для запуска сценария:"

#. type: Plain text
#: man-pages/man2/execve.2:751
#, no-wrap
msgid ""
"$B< ./execve ./script.sh>\n"
"argv[0]: ./myecho\n"
"argv[1]: script-arg\n"
"argv[2]: ./script.sh\n"
"argv[3]: hello\n"
"argv[4]: world\n"
msgstr ""
"$B< ./execve ./script.sh>\nargv[0]: ./myecho\nargv[1]: script-arg\nargv[2]: "
"./script.sh\nargv[3]: hello\nargv[4]: world\n"

#. type: Plain text
#: man-pages/man2/execve.2:763
msgid ""
"B<chmod>(2), B<fork>(2), B<ptrace>(2), B<execl>(3), B<fexecve>(3), "
"B<getopt>(3), B<credentials>(7), B<environ>(7), B<path_resolution>(7), "
"B<ld.so>(8)"
msgstr ""
"B<chmod>(2), B<fork>(2), B<ptrace>(2), B<execl>(3), B<fexecve>(3), B<getopt>"
"(3), B<credentials>(7), B<environ>(7), B<path_resolution>(7), B<ld.so>(8)"

#. type: TH
#: man-pages/man2/exit_group.2:25
#, no-wrap
msgid "EXIT_GROUP"
msgstr "EXIT_GROUP"

#. type: TH
#: man-pages/man2/exit_group.2:25
#, no-wrap
msgid "2008-11-27"
msgstr "2008-11-27"

#. type: Plain text
#: man-pages/man2/exit_group.2:28
msgid "exit_group - exit all threads in a process"
msgstr "exit_group - Завершает все нити в процессе"

#. type: Plain text
#: man-pages/man2/exit_group.2:31
#, no-wrap
msgid "B<#include E<lt>linux/unistd.hE<gt>>\n"
msgstr "B<#include E<lt>linux/unistd.hE<gt>>\n"

#. type: Plain text
#: man-pages/man2/exit_group.2:33
#, no-wrap
msgid "B<void exit_group(int >I<status>B<);>\n"
msgstr "B<void exit_group(int >I<status>B<);>\n"

#. type: Plain text
#: man-pages/man2/exit_group.2:39
msgid ""
"This system call is equivalent to B<exit>(2)  except that it terminates not "
"only the calling thread, but all threads in the calling process's thread "
"group."
msgstr ""
"Данный системный вызов эквивалентен B<exit>(2) за исключением того, что "
"завершает не только вызвавшую нить, то и всю группу нитей вызвавшего процесса."

#. type: Plain text
#: man-pages/man2/exit_group.2:41
msgid "This system call does not return."
msgstr "Данный системный вызов не возвращает результат."

#. type: Plain text
#: man-pages/man2/exit_group.2:43
msgid "This call is present since Linux 2.5.35."
msgstr "Данный вызов появился в Linux 2.5.35."

#. type: Plain text
#: man-pages/man2/exit_group.2:45
msgid "This call is Linux-specific."
msgstr "Данный вызов существует только в Linux."

#. type: Plain text
#: man-pages/man2/exit_group.2:49
msgid ""
"Since glibc 2.3, this is the system call invoked when the B<exit>(2)  "
"wrapper function is called."
msgstr ""
"Начиная с glibc версии 2.3, данный системный вызов выполняется при запуске "
"обёрточной функции к B<exit>(2)."

#. type: Plain text
#: man-pages/man2/exit_group.2:50
msgid "B<exit>(2)"
msgstr "B<exit>(2)"

#. type: TH
#: man-pages/man2/epoll_ctl.2:20
#, no-wrap
msgid "EPOLL_CTL"
msgstr "EPOLL_CTL"

#. type: Plain text
#: man-pages/man2/epoll_ctl.2:23
msgid "epoll_ctl - control interface for an epoll descriptor"
msgstr "epoll_ctl - интерфейс управления дескриптором epoll"

#. type: Plain text
#: man-pages/man2/epoll_ctl.2:28
msgid ""
"B<int epoll_ctl(int >I<epfd>B<, int >I<op>B<, int >I<fd>B<, struct "
"epoll_event *>I<event>B<);>"
msgstr ""
"B<int epoll_ctl(int >I<epfd>B<, int >I<op>B<, int >I<fd>B<, struct "
"epoll_event *>I<event>B<);>"

#. type: Plain text
#: man-pages/man2/epoll_ctl.2:38
msgid ""
"This system call performs control operations on the B<epoll>(7)  instance "
"referred to by the file descriptor I<epfd>.  It requests that the operation "
"I<op> be performed for the target file descriptor, I<fd>."
msgstr ""
"Данный системный вызов выполняет операции управления экземпляром B<epoll>(7), "
"на который указывает файловый дескриптор I<epfd>. Он запрашивает выполнение "
"операции I<op> для файлового дескриптора назначения I<fd>."

#. type: Plain text
#: man-pages/man2/epoll_ctl.2:42
msgid "Valid values for the I<op> argument are :"
msgstr "Допустимые значения аргумента I<op>:"

#. type: TP
#: man-pages/man2/epoll_ctl.2:42
#, no-wrap
msgid "B<EPOLL_CTL_ADD>"
msgstr "B<EPOLL_CTL_ADD>"

#. type: Plain text
#: man-pages/man2/epoll_ctl.2:54
msgid ""
"Register the target file descriptor I<fd> on the B<epoll> instance referred "
"to by the file descriptor I<epfd> and associate the event I<event> with the "
"internal file linked to I<fd>."
msgstr ""
"Зарегистрировать файловый дескриптор назначения I<fd> в экземпляре B<epoll>, "
"на который указывает файловый дескриптор I<epfd>, и связать событие I<event> "
"с внутренним файлом, указывающим на I<fd>."

#. type: TP
#: man-pages/man2/epoll_ctl.2:54
#, no-wrap
msgid "B<EPOLL_CTL_MOD>"
msgstr "B<EPOLL_CTL_MOD>"

#. type: Plain text
#: man-pages/man2/epoll_ctl.2:60
msgid ""
"Change the event I<event> associated with the target file descriptor I<fd>."
msgstr ""
"Изменить событие I<event>, связанное с файловым дескриптором назначения I<fd>."

#. type: TP
#: man-pages/man2/epoll_ctl.2:60
#, no-wrap
msgid "B<EPOLL_CTL_DEL>"
msgstr "B<EPOLL_CTL_DEL>"

#. type: Plain text
#: man-pages/man2/epoll_ctl.2:71
msgid ""
"Remove (deregister) the target file descriptor I<fd> from the B<epoll> "
"instance referred to by I<epfd>.  The I<event> is ignored and can be NULL "
"(but see BUGS below)."
msgstr ""
"Удалить (отменить регистрацию) файлового дескриптора назначения I<fd> из "
"экземпляра B<epoll>, на который указывает I<epfd>. Значение I<event> "
"игнорируется и может быть NULL (но см. ДЕФЕКТЫ далее)."

#. type: Plain text
#: man-pages/man2/epoll_ctl.2:79
msgid ""
"The I<event> argument describes the object linked to the file descriptor "
"I<fd>.  The I<struct epoll_event> is defined as :"
msgstr ""
"Аргумент I<event> описывает объект, связанный с файловым дескриптором I<fd>. "
"Структура I<struct epoll_event> определена так:"

#. type: Plain text
#: man-pages/man2/epoll_ctl.2:88
#, no-wrap
msgid ""
"typedef union epoll_data {\n"
"    void        *ptr;\n"
"    int          fd;\n"
"    uint32_t     u32;\n"
"    uint64_t     u64;\n"
"} epoll_data_t;\n"
msgstr ""
"typedef union epoll_data {\n    void        *ptr;\n    int          fd;\n    "
"uint32_t     u32;\n    uint64_t     u64;\n} epoll_data_t;\n"

#. type: Plain text
#: man-pages/man2/epoll_ctl.2:93
#, no-wrap
msgid ""
"struct epoll_event {\n"
"    uint32_t     events;      /* Epoll events */\n"
"    epoll_data_t data;        /* User data variable */\n"
"};\n"
msgstr ""
"struct epoll_event {\n    uint32_t     events;      /* События epoll */\n    "
"epoll_data_t data;        /* Переменная для данных пользователя */\n};\n"

#. type: Plain text
#: man-pages/man2/epoll_ctl.2:100
msgid ""
"The I<events> member is a bit set composed using the following available "
"event types:"
msgstr ""
"Поле I<events> является набором битов, составляемое из следующих возможных "
"типов событий:"

#. type: TP
#: man-pages/man2/epoll_ctl.2:100
#, no-wrap
msgid "B<EPOLLIN>"
msgstr "B<EPOLLIN>"

#. type: Plain text
#: man-pages/man2/epoll_ctl.2:105
msgid "The associated file is available for B<read>(2)  operations."
msgstr "Связанный файл доступен для чтения с помощью B<read>(2)."

#. type: TP
#: man-pages/man2/epoll_ctl.2:105
#, no-wrap
msgid "B<EPOLLOUT>"
msgstr "B<EPOLLOUT>"

#. type: Plain text
#: man-pages/man2/epoll_ctl.2:110
msgid "The associated file is available for B<write>(2)  operations."
msgstr "Связанный файл доступен для записи с помощью B<write>(2)."

#. type: TP
#: man-pages/man2/epoll_ctl.2:110
#, no-wrap
msgid "B<EPOLLRDHUP> (since Linux 2.6.17)"
msgstr "B<EPOLLRDHUP> (начиная с Linux 2.6.17)"

#. type: Plain text
#: man-pages/man2/epoll_ctl.2:116
msgid ""
"Stream socket peer closed connection, or shut down writing half of "
"connection.  (This flag is especially useful for writing simple code to "
"detect peer shutdown when using Edge Triggered monitoring.)"
msgstr ""
"Одна из сторон потокового сокета закрыла соединение, или выключила "
"записывающую часть соединения. (Этот флаг особенно полезен при написании "
"простого кода для обнаружения отключения стороны с помощью слежения Edge "
"Triggered.)"

#. type: TP
#: man-pages/man2/epoll_ctl.2:116
#, no-wrap
msgid "B<EPOLLPRI>"
msgstr "B<EPOLLPRI>"

#. type: Plain text
#: man-pages/man2/epoll_ctl.2:121
msgid "There is urgent data available for B<read>(2)  operations."
msgstr "Для операций B<read>(2) есть срочные данные."

#. type: TP
#: man-pages/man2/epoll_ctl.2:121
#, no-wrap
msgid "B<EPOLLERR>"
msgstr "B<EPOLLERR>"

#. type: Plain text
#: man-pages/man2/epoll_ctl.2:127
msgid ""
"Error condition happened on the associated file descriptor.  "
"B<epoll_wait>(2)  will always wait for this event; it is not necessary to "
"set it in I<events>."
msgstr ""
"Произошла ошибка со связанным файловым дескриптором. B<epoll_wait>(2) всегда "
"будет ждать этого события; его не нужно устанавливать в I<events>."

#. type: TP
#: man-pages/man2/epoll_ctl.2:127
#, no-wrap
msgid "B<EPOLLHUP>"
msgstr "B<EPOLLHUP>"

#. type: Plain text
#: man-pages/man2/epoll_ctl.2:133
msgid ""
"Hang up happened on the associated file descriptor.  B<epoll_wait>(2)  will "
"always wait for this event; it is not necessary to set it in I<events>."
msgstr ""
"Произошло зависание связанного файлового дескриптора. Вызов B<epoll_wait>(2) "
"будет всегда ждать этого события; его не нужно указывать в I<events>."

#. type: TP
#: man-pages/man2/epoll_ctl.2:133
#, no-wrap
msgid "B<EPOLLET>"
msgstr "B<EPOLLET>"

#. type: Plain text
#: man-pages/man2/epoll_ctl.2:143
msgid ""
"Sets the Edge Triggered behavior for the associated file descriptor.  The "
"default behavior for B<epoll> is Level Triggered.  See B<epoll>(7)  for more"
" detailed information about Edge and Level Triggered event distribution "
"architectures."
msgstr ""
"Установить поведение Edge Triggered для связанного файлового дескриптора. "
"Поведение по умолчанию для B<epoll> равно Level Triggered. Более подробное "
"описание архитектуры распределения событий Edge и Level Triggered смотрите в "
"B<epoll>(7)."

#. type: TP
#: man-pages/man2/epoll_ctl.2:143
#, no-wrap
msgid "B<EPOLLONESHOT> (since Linux 2.6.2)"
msgstr "B<EPOLLONESHOT> (начиная с Linux 2.6.2)"

#. type: Plain text
#: man-pages/man2/epoll_ctl.2:157
msgid ""
"Sets the one-shot behavior for the associated file descriptor.  This means "
"that after an event is pulled out with B<epoll_wait>(2)  the associated file"
" descriptor is internally disabled and no other events will be reported by "
"the B<epoll> interface.  The user must call B<epoll_ctl>()  with "
"B<EPOLL_CTL_MOD> to rearm the file descriptor with a new event mask."
msgstr ""
"Установить однократное получение для связанного файлового дескриптора. Это "
"означает, что после извлечения события с помощью B<epoll_wait>(2) со "
"связанным дескриптором приём отключается и о других событиях интерфейс B<"
"epoll> сообщать не будет. Пользователь должен вызвать B<epoll_ctl>() с "
"операцией B<EPOLL_CTL_MOD> для переустановки новой маски событий для "
"файлового дескриптора."

#. type: TP
#: man-pages/man2/epoll_ctl.2:157
#, no-wrap
msgid "B<EPOLLWAKEUP> (since Linux 3.5)"
msgstr "B<EPOLLWAKEUP> (начиная с Linux 3.5)"

#.  commit 4d7e30d98939a0340022ccd49325a3d70f7e0238
#. type: Plain text
#: man-pages/man2/epoll_ctl.2:185
msgid ""
"If B<EPOLLONESHOT> and B<EPOLLET> are clear and the process has the "
"B<CAP_BLOCK_SUSPEND> capability, ensure that the system does not enter "
"\"suspend\" or \"hibernate\" while this event is pending or being processed."
"  The event is considered as being \"processed\" from the time when it is "
"returned by a call to B<epoll_wait>(2)  until the next call to "
"B<epoll_wait>(2)  on the same B<epoll>(7)  file descriptor, the closure of "
"that file descriptor, the removal of the event file descriptor with "
"B<EPOLL_CTL_DEL>, or the clearing of B<EPOLLWAKEUP> for the event file "
"descriptor with B<EPOLL_CTL_MOD>.  See also BUGS."
msgstr ""
"Если флаги B<EPOLLONESHOT> и B<EPOLLET> сброшены и процесс имеет мандат "
"B<CAP_BLOCK_SUSPEND>, то убедитесь, что система не находится в режиме "
"«suspend» или «hibernate», пока это событие ожидает обработки или "
"обрабатывается. "
"Событие считается «обрабатывающимся» начиная с момента, когда оно "
"возвращается "
"вызовом B<epoll_wait>(2) и до следующего вызова "
"B<epoll_wait>(2) для того же файлового дескриптора B<epoll>(7), закрытия "
"этого "
"файлового дескриптора, удаление файлового дескриптора события с помощью "
"B<EPOLL_CTL_DEL> или сброс B<EPOLLWAKEUP> для файлового дескриптора события "
"с помощью B<EPOLL_CTL_MOD>. Также смотрите ДЕФЕКТЫ."

#. type: Plain text
#: man-pages/man2/epoll_ctl.2:194
msgid ""
"When successful, B<epoll_ctl>()  returns zero.  When an error occurs, "
"B<epoll_ctl>()  returns -1 and I<errno> is set appropriately."
msgstr ""
"При успешном выполнении B<epoll_ctl>() возвращается ноль. При возникновении "
"ошибок B<epoll_ctl>() возвращает -1 и устанавливает I<errno> в "
"соответствующее значение."

#. type: TP
#: man-pages/man2/epoll_ctl.2:195
#, no-wrap
msgid "B<EBADF>"
msgstr "B<EBADF>"

#. type: Plain text
#: man-pages/man2/epoll_ctl.2:201
msgid "I<epfd> or I<fd> is not a valid file descriptor."
msgstr ""
"Значение I<epfd> или I<fd> не является правильным файловым дескриптором."

#. type: TP
#: man-pages/man2/epoll_ctl.2:201
#, no-wrap
msgid "B<EEXIST>"
msgstr "B<EEXIST>"

#. type: Plain text
#: man-pages/man2/epoll_ctl.2:209
msgid ""
"I<op> was B<EPOLL_CTL_ADD>, and the supplied file descriptor I<fd> is "
"already registered with this epoll instance."
msgstr ""
"Значение I<op> равно B<EPOLL_CTL_ADD>, и указанный файловый дескриптор I<fd> "
"уже зарегистрирован в данном экземпляре epoll."

#. type: Plain text
#: man-pages/man2/epoll_ctl.2:222
msgid ""
"I<epfd> is not an B<epoll> file descriptor, or I<fd> is the same as I<epfd>,"
" or the requested operation I<op> is not supported by this interface."
msgstr ""
"Значение I<epfd> не является файловым дескриптором B<epoll>, или значение I<"
"fd> равно I<epfd>, или запрашиваемая операция I<op> не поддерживается данным "
"интерфейсом."

#. type: Plain text
#: man-pages/man2/epoll_ctl.2:232
msgid ""
"I<op> was B<EPOLL_CTL_MOD> or B<EPOLL_CTL_DEL>, and I<fd> is not registered "
"with this epoll instance."
msgstr ""
"В I<op> было указано B<EPOLL_CTL_MOD> или B<EPOLL_CTL_DEL>, а I<fd> не было "
"зарегистрировано в данном экземпляре epoll."

#. type: Plain text
#: man-pages/man2/epoll_ctl.2:237
msgid ""
"There was insufficient memory to handle the requested I<op> control "
"operation."
msgstr ""
"Недостаточно памяти для обработки запрошенной управляющей операции I<op>."

#. type: TP
#: man-pages/man2/epoll_ctl.2:237
#, no-wrap
msgid "B<ENOSPC>"
msgstr "B<ENOSPC>"

#. type: Plain text
#: man-pages/man2/epoll_ctl.2:247
msgid ""
"The limit imposed by I</proc/sys/fs/epoll/max_user_watches> was encountered "
"while trying to register (B<EPOLL_CTL_ADD>)  a new file descriptor on an "
"epoll instance.  See B<epoll>(7)  for further details."
msgstr ""
"При попытке регистрации (B<EPOLL_CTL_ADD>) нового файлового дескриптора в "
"экземпляре достигнут предел, накладываемый I<"
"/proc/sys/fs/epoll/max_user_watches>. Подробней см. в B<epoll>(7)."

#. type: Plain text
#: man-pages/man2/epoll_ctl.2:253
msgid "The target file I<fd> does not support B<epoll>."
msgstr "Файл назначения I<fd> не поддерживает B<epoll>."

#.  To be precise: kernel 2.5.44.
#.  The interface should be finalized by Linux kernel 2.5.66.
#. type: Plain text
#: man-pages/man2/epoll_ctl.2:258
msgid "B<epoll_ctl>()  was added to the kernel in version 2.6."
msgstr "Системный вызов B<epoll_ctl>() был добавлен в ядро версии 2.6."

#. type: Plain text
#: man-pages/man2/epoll_ctl.2:262
msgid ""
"B<epoll_ctl>()  is Linux-specific.  Library support is provided in glibc "
"starting with version 2.3.2."
msgstr ""
"Вызов B<epoll_ctl>() есть только в Linux. В glibc соответствующая функция "
"появилась в версии 2.3.2."

#. type: Plain text
#: man-pages/man2/epoll_ctl.2:267
msgid ""
"The B<epoll> interface supports all file descriptors that support "
"B<poll>(2)."
msgstr ""
"Интерфейс B<epoll> поддерживает все файловые дескрипторы, которые "
"поддерживает B<poll>(2)."

#. type: Plain text
#: man-pages/man2/epoll_ctl.2:281
msgid ""
"In kernel versions before 2.6.9, the B<EPOLL_CTL_DEL> operation required a "
"non-null pointer in I<event>, even though this argument is ignored.  Since "
"Linux 2.6.9, I<event> can be specified as NULL when using B<EPOLL_CTL_DEL>."
"  Applications that need to be portable to kernels before 2.6.9 should "
"specify a non-null pointer in I<event>."
msgstr ""
"В ядрах до версии 2.6.9 для операции B<EPOLL_CTL_DEL> в I<event> требовался "
"указатель со значением не равным null, хотя этот аргумент игнорировался. "
"Начиная с Linux 2.6.9, при B<EPOLL_CTL_DEL> в I<event> можно указывать NULL. "
"В переносимых приложениях, которые должны быть работоспособными в системах на "
"ядрах до 2.6.9, в I<event> нужно указывать указатель со значением не равным "
"null."

#.  commit a8159414d7e3af7233e7a5a82d1c5d85379bd75c (behavior change)
#.  https://lwn.net/Articles/520198/
#. type: Plain text
#: man-pages/man2/epoll_ctl.2:308
msgid ""
"If B<EPOLLWAKEUP> is specified in I<flags>, but the caller does not have the"
" B<CAP_BLOCK_SUSPEND> capability, then the B<EPOLLWAKEUP> flag is I<silently"
" ignored>.  This unfortunate behavior is necessary because no validity "
"checks were performed on the I<flags> argument in the original "
"implementation, and the addition of the B<EPOLLWAKEUP> with a check that "
"caused the call to fail if the caller did not have the B<CAP_BLOCK_SUSPEND> "
"capability caused a breakage in at least one existing user-space application"
" that happened to randomly (and uselessly) specify this bit.  A robust "
"application should therefore double check that it has the "
"B<CAP_BLOCK_SUSPEND> capability if attempting to use the B<EPOLLWAKEUP> "
"flag."
msgstr ""
"Если в I<flags> указан B<EPOLLWAKEUP>, но вызывающий не имеет мандата "
"B<CAP_BLOCK_SUSPEND>, то флаг B<EPOLLWAKEUP> I<просто игнорируется>. "
"Такое неуместное поведение необходимо, так как в первоначальной реализации "
"не выполнялась проверка корректности аргумента I<flags>, и "
"добавление B<EPOLLWAKEUP> с проверкой того, что вызов завершился "
"с ошибкой, если вызывающий не имеет мандата B<CAP_BLOCK_SUSPEND>, "
"привело к поломке не одного существующего пользовательского приложения, "
"которое произвольно устанавливало (и зря) этот бит. "
"Корректное приложение должно дважды проверить, что имеет мандат "
"B<CAP_BLOCK_SUSPEND>, если пытается использовать флаг "
"B<EPOLLWAKEUP>."

#. type: Plain text
#: man-pages/man2/epoll_ctl.2:312
msgid "B<epoll_create>(2), B<epoll_wait>(2), B<poll>(2), B<epoll>(7)"
msgstr "B<epoll_create>(2), B<epoll_wait>(2), B<poll>(2), B<epoll>(7)"

#. type: TH
#: man-pages/man2/epoll_create.2:24
#, no-wrap
msgid "EPOLL_CREATE"
msgstr "EPOLL_CREATE"

#. type: TH
#: man-pages/man2/epoll_create.2:24
#, no-wrap
msgid "2012-04-15"
msgstr "2012-04-15"

#. type: Plain text
#: man-pages/man2/epoll_create.2:27
msgid "epoll_create, epoll_create1 - open an epoll file descriptor"
msgstr "epoll_create, epoll_create1 - открывает файловый дескриптор epoll"

#. type: Plain text
#: man-pages/man2/epoll_create.2:30
#, no-wrap
msgid "B<#include E<lt>sys/epoll.hE<gt>>\n"
msgstr "B<#include E<lt>sys/epoll.hE<gt>>\n"

#. type: Plain text
#: man-pages/man2/epoll_create.2:33
#, no-wrap
msgid ""
"B<int epoll_create(int >I<size>B<);>\n"
"B<int epoll_create1(int >I<flags>B<);>\n"
msgstr ""
"B<int epoll_create(int >I<size>B<);>\nB<int epoll_create1(int >I<flags>B<);>\n"

#. type: Plain text
#: man-pages/man2/epoll_create.2:42
msgid ""
"B<epoll_create>()  creates an B<epoll>(7)  instance.  Since Linux 2.6.8, the"
" I<size> argument is ignored, but must be greater than zero; see NOTES "
"below."
msgstr ""
"Вызов B<epoll_create>() создаёт экземпляр B<epoll>(7). Начиная с Linux 2.6.8 "
"аргумент I<size> игнорируется, но должен быть больше нуля; смотрите ЗАМЕЧАНИЯ "
"далее."

#. type: Plain text
#: man-pages/man2/epoll_create.2:55
msgid ""
"B<epoll_create>()  returns a file descriptor referring to the new epoll "
"instance.  This file descriptor is used for all the subsequent calls to the "
"B<epoll> interface.  When no longer required, the file descriptor returned "
"by B<epoll_create>()  should be closed by using B<close>(2).  When all file "
"descriptors referring to an epoll instance have been closed, the kernel "
"destroys the instance and releases the associated resources for reuse."
msgstr ""
"B<epoll_create>() возвращает дескриптор файла, указывающий на новый экземпляр "
"epoll. Он используется для всех последующих вызовов к интерфейсу B<epoll>. По "
"окончанию использования дескриптор файла, возвращаемый B<epoll_create>(), "
"должен быть закрыт с помощью B<close>(2). Когда все файловые дескрипторы, "
"указывающие на экземпляр epoll, будут закрыты, ядро уничтожит экземпляр и "
"освободит связанные с ним ресурсы для повторного использования."

#. type: SS
#: man-pages/man2/epoll_create.2:55
#, no-wrap
msgid "epoll_create1()"
msgstr "epoll_create1()"

#. type: Plain text
#: man-pages/man2/epoll_create.2:67
msgid ""
"If I<flags> is 0, then, other than the fact that the obsolete I<size> "
"argument is dropped, B<epoll_create1>()  is the same as B<epoll_create>().  "
"The following value can be included in I<flags> to obtain different "
"behavior:"
msgstr ""
"Если I<flags> равно 0, то, если не учитывать, что устаревший аргумент I<size> "
"не используется, B<epoll_create1>() выполняет тоже что и B<epoll_create>(). "
"Для различного поведения во I<flags> могут включаться:"

#. type: TP
#: man-pages/man2/epoll_create.2:67
#, no-wrap
msgid "B<EPOLL_CLOEXEC>"
msgstr "B<EPOLL_CLOEXEC>"

#. type: Plain text
#: man-pages/man2/epoll_create.2:84
msgid ""
"On success, these system calls return a nonnegative file descriptor.  On "
"error, -1 is returned, and I<errno> is set to indicate the error."
msgstr ""
"При успешном выполнении данные системные вызовы возвращают неотрицательный "
"файловый дескриптор. При ошибке возвращается -1 и I<errno> устанавливается в "
"соответствующее значение."

#. type: Plain text
#: man-pages/man2/epoll_create.2:89
msgid "I<size> is not positive."
msgstr "Аргумент I<size> содержит отрицательное значение."

#. type: Plain text
#: man-pages/man2/epoll_create.2:94
msgid "(B<epoll_create1>())  Invalid value specified in I<flags>."
msgstr "(B<epoll_create1>()) Указано неверное значение в I<flags>."

#. type: Plain text
#: man-pages/man2/epoll_create.2:102
msgid ""
"The per-user limit on the number of epoll instances imposed by "
"I</proc/sys/fs/epoll/max_user_instances> was encountered.  See B<epoll>(7)  "
"for further details."
msgstr ""
"Был достигнут пользовательский предел на количество экземпляров epoll, "
"налагаемый I</proc/sys/fs/epoll/max_user_instances>. Подробней см. в B<epoll>"
"(7)."

#. type: Plain text
#: man-pages/man2/epoll_create.2:108
msgid "There was insufficient memory to create the kernel object."
msgstr "Недостаточно памяти для создания объекта ядра."

#. type: Plain text
#: man-pages/man2/epoll_create.2:112
msgid ""
"B<epoll_create>()  was added to the kernel in version 2.6.  Library support "
"is provided in glibc starting with version 2.3.2."
msgstr ""
"Вызов B<epoll_create>() был добавлен в ядро версии 2.6. В glibc "
"соответствующая функция появилась в версии 2.3.2."

#.  To be precise: kernel 2.5.44.
#.  The interface should be finalized by Linux kernel 2.5.66.
#. type: Plain text
#: man-pages/man2/epoll_create.2:118
msgid ""
"B<epoll_create1>()  was added to the kernel in version 2.6.27.  Library "
"support is provided in glibc starting with version 2.9."
msgstr ""
"Вызов B<epoll_create1>() был добавлен в ядро версии 2.6.27. В glibc "
"соответствующая функция появилась в версии 2.9."

#. type: Plain text
#: man-pages/man2/epoll_create.2:121
msgid "B<epoll_create>()  is Linux-specific."
msgstr "Вызов B<epoll_create>() есть только в Linux."

#. type: Plain text
#: man-pages/man2/epoll_create.2:144
msgid ""
"In the initial B<epoll_create>()  implementation, the I<size> argument "
"informed the kernel of the number of file descriptors that the caller "
"expected to add to the B<epoll> instance.  The kernel used this information "
"as a hint for the amount of space to initially allocate in internal data "
"structures describing events.  (If necessary, the kernel would allocate more"
" space if the caller's usage exceeded the hint given in I<size>.)  Nowadays,"
" this hint is no longer required (the kernel dynamically sizes the required "
"data structures without needing the hint), but I<size> must still be greater"
" than zero, in order to ensure backward compatibility when new B<epoll> "
"applications are run on older kernels."
msgstr ""
"В первоначальной реализации B<epoll_create>() аргумент I<size> уведомлял ядро "
"о количестве файловых дескрипторов, которые вызывающий предполагал добавить в "
"экземпляр B<epoll>. Ядро использовало эту информацию для оценки требуемого "
"количества памяти при начальном размещении внутренних структур данных, "
"описывающих события (если требовалось, ядро выделяло больше места, если "
"вызывающий превышал значение, указанное в I<size>). Сейчас, эта оценка больше "
"не требуется (ядро динамически выделяет место под структуры данных), но "
"значение I<size> всё равно должно быть больше нуля — для обеспечения обратной "
"совместимости приложений с новым B<epoll> для работы на старых ядрах."

#. type: Plain text
#: man-pages/man2/epoll_create.2:148
msgid "B<close>(2), B<epoll_ctl>(2), B<epoll_wait>(2), B<epoll>(7)"
msgstr "B<close>(2), B<epoll_ctl>(2), B<epoll_wait>(2), B<epoll>(7)"

#. type: TH
#: man-pages/man2/epoll_wait.2:22
#, no-wrap
msgid "EPOLL_WAIT"
msgstr "EPOLL_WAIT"

#. type: TH
#: man-pages/man2/epoll_wait.2:22
#, no-wrap
msgid "2014-01-31"
msgstr "2014-01-31"

#. type: Plain text
#: man-pages/man2/epoll_wait.2:25
msgid ""
"epoll_wait, epoll_pwait - wait for an I/O event on an epoll file descriptor"
msgstr ""
"epoll_wait, epoll_pwait - ждать события ввода/вывода на файловом дескрипторе "
"epoll"

#. type: Plain text
#: man-pages/man2/epoll_wait.2:34
#, no-wrap
msgid ""
"B<int epoll_wait(int >I<epfd>B<, struct epoll_event *>I<events>B<,>\n"
"B<               int >I<maxevents>B<, int >I<timeout>B<);>\n"
"B<int epoll_pwait(int >I<epfd>B<, struct epoll_event *>I<events>B<,>\n"
"B<               int >I<maxevents>B<, int >I<timeout>B<,>\n"
"B<               const sigset_t *>I<sigmask>B<);>\n"
msgstr ""
"B<int epoll_wait(int >I<epfd>B<, struct epoll_event *>I<events>B<,>\nB<       "
"        int >I<maxevents>B<, int >I<timeout>B<);>\nB<int epoll_pwait(int >I<"
"epfd>B<, struct epoll_event *>I<events>B<,>\nB<               int >I<"
"maxevents>B<, int >I<timeout>B<,>\nB<               const sigset_t *>I<"
"sigmask>B<);>\n"

#. type: Plain text
#: man-pages/man2/epoll_wait.2:52
msgid ""
"The B<epoll_wait>()  system call waits for events on the B<epoll>(7)  "
"instance referred to by the file descriptor I<epfd>.  The memory area "
"pointed to by I<events> will contain the events that will be available for "
"the caller.  Up to I<maxevents> are returned by B<epoll_wait>().  The "
"I<maxevents> argument must be greater than zero."
msgstr ""
"Системный вызов B<epoll_wait>() ожидает события на экземпляре B<epoll>(7), на "
"который указывает файловый дескриптор I<epfd>. Область памяти, на которую "
"указывает I<events>, будет содержать события, доступные для вызываемого. "
"Вызов B<epoll_wait>() может вернуть до I<maxevents> событий. Параметр I<"
"maxevents> должен быть больше нуля."

#. type: Plain text
#: man-pages/man2/epoll_wait.2:59
msgid ""
"The I<timeout> argument specifies the number of milliseconds that "
"B<epoll_wait>()  will block.  The call will block until either:"
msgstr ""
"В аргументе I<timeout> указывается количество миллисекунд, на которые "
"блокируется B<epoll_wait>(). Вызов будет заблокирован пока:"

#. type: Plain text
#: man-pages/man2/epoll_wait.2:61
msgid "a file descriptor delivers an event;"
msgstr "событие не будет доставлено в файловый дескриптор;"

#. type: Plain text
#: man-pages/man2/epoll_wait.2:63
msgid "the call is interrupted by a signal handler; or"
msgstr "вызов не прервётся обработчиком сигнала;"

#. type: Plain text
#: man-pages/man2/epoll_wait.2:65
msgid "the timeout expires."
msgstr "не истечёт время ожидания."

#. type: Plain text
#: man-pages/man2/epoll_wait.2:80
msgid ""
"Note that the I<timeout> interval will be rounded up to the system clock "
"granularity, and kernel scheduling delays mean that the blocking interval "
"may overrun by a small amount.  Specifying a I<timeout> of -1 causes "
"B<epoll_wait>()  to block indefinitely, while specifying a I<timeout> equal "
"to zero cause B<epoll_wait>()  to return immediately, even if no events are "
"available."
msgstr ""
"Заметим, что интервал I<timeout> будет округлён в соответствии с точностью "
"системных часов, а задержки ядерного планирования приведут к тому, что "
"интервал блокировки может быть немного больше. Если присвоить I<timeout> "
"значение -1, то B<epoll_wait>() блокируется навсегда; если значение I<timeout>"
" равно 0, то B<epoll_wait>() сразу завершает работу, даже если никаких "
"событий не произошло."

#. type: Plain text
#: man-pages/man2/epoll_wait.2:84
msgid "The I<struct epoll_event> is defined as :"
msgstr "Структура I<struct epoll_event> определена так:"

#. type: Plain text
#: man-pages/man2/epoll_wait.2:93
#, no-wrap
msgid ""
"typedef union epoll_data {\n"
"    void    *ptr;\n"
"    int      fd;\n"
"    uint32_t u32;\n"
"    uint64_t u64;\n"
"} epoll_data_t;\n"
msgstr ""
"typedef union epoll_data {\n    void    *ptr;\n    int      fd;\n    uint32_t "
"u32;\n    uint64_t u64;\n} epoll_data_t;\n"

#. type: Plain text
#: man-pages/man2/epoll_wait.2:98
#, no-wrap
msgid ""
"struct epoll_event {\n"
"    uint32_t     events;    /* Epoll events */\n"
"    epoll_data_t data;      /* User data variable */\n"
"};\n"
msgstr ""
"struct epoll_event {\n    uint32_t     events;    /* События epoll */\n    "
"epoll_data_t data;      /* Переменная для данных пользователя */\n};\n"

#. type: Plain text
#: man-pages/man2/epoll_wait.2:109
msgid ""
"The I<data> of each returned structure will contain the same data the user "
"set with an B<epoll_ctl>(2)  (B<EPOLL_CTL_ADD>, B<EPOLL_CTL_MOD>)  while the"
" I<events> member will contain the returned event bit field."
msgstr ""
"Поле I<data> в каждой возвращаемой структуре будет содержать данные "
"пользователя, установленные с помощью B<epoll_ctl>(2) (B<EPOLL_CTL_ADD>, B<"
"EPOLL_CTL_MOD>), а в поле I<events> будет содержаться битовое поле "
"возвращаемого события."

#. type: SS
#: man-pages/man2/epoll_wait.2:109
#, no-wrap
msgid "epoll_pwait()"
msgstr "epoll_pwait()"

#. type: Plain text
#: man-pages/man2/epoll_wait.2:123
msgid ""
"The relationship between B<epoll_wait>()  and B<epoll_pwait>()  is analogous"
" to the relationship between B<select>(2)  and B<pselect>(2): like "
"B<pselect>(2), B<epoll_pwait>()  allows an application to safely wait until "
"either a file descriptor becomes ready or until a signal is caught."
msgstr ""
"Отношения между B<epoll_wait>() и B<epoll_pwait>() аналогичны родству B<"
"select>(2) и B<pselect>(2): как B<pselect>(2), B<epoll_pwait>() позволяет "
"приложению безопасно ждать, пока файловый дескриптор не станет готов или пока "
"не будет получен сигнал."

#. type: Plain text
#: man-pages/man2/epoll_wait.2:127
msgid "The following B<epoll_pwait>()  call:"
msgstr "Вызов B<epoll_pwait>():"

#. type: Plain text
#: man-pages/man2/epoll_wait.2:130
#, no-wrap
msgid "    ready = epoll_pwait(epfd, &events, maxevents, timeout, &sigmask);\n"
msgstr ""
"    ready = epoll_pwait(epfd, &events, maxevents, timeout, &sigmask);\n"

#. type: Plain text
#: man-pages/man2/epoll_wait.2:135
msgid "is equivalent to I<atomically> executing the following calls:"
msgstr "эквивалентен I<атомарному> выполнению следующих вызовов:"

#. type: Plain text
#: man-pages/man2/epoll_wait.2:138
#, no-wrap
msgid "    sigset_t origmask;\n"
msgstr "    sigset_t origmask;\n"

#. type: Plain text
#: man-pages/man2/epoll_wait.2:142
#, no-wrap
msgid ""
"    sigprocmask(SIG_SETMASK, &sigmask, &origmask);\n"
"    ready = epoll_wait(epfd, &events, maxevents, timeout);\n"
"    sigprocmask(SIG_SETMASK, &origmask, NULL);\n"
msgstr ""
"    sigprocmask(SIG_SETMASK, &sigmask, &origmask);\n    ready = "
"epoll_wait(epfd, &events, maxevents, timeout);\n    sigprocmask(SIG_SETMASK, "
"&origmask, NULL);\n"

#. type: Plain text
#: man-pages/man2/epoll_wait.2:150
msgid ""
"The I<sigmask> argument may be specified as NULL, in which case "
"B<epoll_pwait>()  is equivalent to B<epoll_wait>()."
msgstr ""
"Аргумент I<sigmask> может быть равен NULL \\(em в этом случае B<epoll_pwait>"
"() эквивалентен B<epoll_wait>()."

#. type: Plain text
#: man-pages/man2/epoll_wait.2:162
msgid ""
"When successful, B<epoll_wait>()  returns the number of file descriptors "
"ready for the requested I/O, or zero if no file descriptor became ready "
"during the requested I<timeout> milliseconds.  When an error occurs, "
"B<epoll_wait>()  returns -1 and I<errno> is set appropriately."
msgstr ""
"При нормальном выполнении B<epoll_wait>() возвращает количество файловых "
"дескрипторов, готовых для запросов ввода-вывода, или ноль, если ни один "
"файловый дескриптор не стал готов за отведённые I<timeout> миллисекунд. При "
"возникновении ошибки B<epoll_wait>() возвращает -1 и устанавливает I<errno> в "
"соответствующее значение."

#. type: Plain text
#: man-pages/man2/epoll_wait.2:167
msgid "I<epfd> is not a valid file descriptor."
msgstr "Значение I<epfd> не является правильным файловым дескриптором."

#. type: Plain text
#: man-pages/man2/epoll_wait.2:172
msgid ""
"The memory area pointed to by I<events> is not accessible with write "
"permissions."
msgstr "Память, указанная I<events>, недоступна на запись из-за прав доступа."

#. type: TP
#: man-pages/man2/epoll_wait.2:172
#, no-wrap
msgid "B<EINTR>"
msgstr "B<EINTR>"

#. type: Plain text
#: man-pages/man2/epoll_wait.2:179
msgid ""
"The call was interrupted by a signal handler before either (1) any of the "
"requested events occurred or (2) the I<timeout> expired; see B<signal>(7)."
msgstr ""
"Вызов был прерван обработчиком сигнала до возникновения любого из запрошенных "
"событий или истечения I<timeout>; см. B<signal>(7)."

#. type: Plain text
#: man-pages/man2/epoll_wait.2:187
msgid ""
"I<epfd> is not an B<epoll> file descriptor, or I<maxevents> is less than or "
"equal to zero."
msgstr ""
"I<epfd> не является файловым дескриптором B<epoll>, или I<maxevents> меньше "
"или равно нулю."

#.  To be precise: kernel 2.5.44.
#.  The interface should be finalized by Linux kernel 2.5.66.
#. type: Plain text
#: man-pages/man2/epoll_wait.2:193
msgid ""
"B<epoll_wait>()  was added to the kernel in version 2.6.  Library support is"
" provided in glibc starting with version 2.3.2."
msgstr ""
"Вызов B<epoll_wait>() был добавлен в ядро версии 2.6. В glibc соответствующая "
"функция появилась в версии 2.3.2."

#. type: Plain text
#: man-pages/man2/epoll_wait.2:197
msgid ""
"B<epoll_pwait>()  was added to Linux in kernel 2.6.19.  Library support is "
"provided in glibc starting with version 2.6."
msgstr ""
"Вызов B<epoll_pwait>() был добавлен в ядро Linux 2.6.19. В glibc "
"соответствующая функция появилась в версии 2.6."

#. type: Plain text
#: man-pages/man2/epoll_wait.2:200
msgid "B<epoll_wait>()  is Linux-specific."
msgstr "Вызов B<epoll_wait>() есть только в Linux."

#. type: Plain text
#: man-pages/man2/epoll_wait.2:210
msgid ""
"While one thread is blocked in a call to B<epoll_pwait>(), it is possible "
"for another thread to add a file descriptor to the waited-upon B<epoll> "
"instance.  If the new file descriptor becomes ready, it will cause the "
"B<epoll_wait>()  call to unblock."
msgstr ""
"Пока одна нить блокирована в вызове B<epoll_pwait>(), в другой нити возможно "
"добавить файловый дескриптор, который будет ожидаться экземпляром B<epoll>. "
"Как только новый файловый дескриптор станет готовым, это разблокирует вызов "
"B<epoll_wait>()."

#. type: Plain text
#: man-pages/man2/epoll_wait.2:217
msgid ""
"For a discussion of what may happen if a file descriptor in an B<epoll> "
"instance being monitored by B<epoll_wait>()  is closed in another thread, "
"see B<select>(2)."
msgstr ""
"Обсуждение того, что может случиться, если файловый дескриптор в экземпляре "
"B<epoll> отслеживается B<epoll_wait>() и при этом закрывается в другой нити, "
"смотрите в B<select>(2)."

#. type: Plain text
#: man-pages/man2/epoll_wait.2:229
msgid ""
"In kernels before 2.6.37, a I<timeout> value larger than approximately "
"I<LONG_MAX / HZ> milliseconds is treated as -1 (i.e., infinity).  Thus, for "
"example, on a system where the I<sizeof(long)> is 4 and the kernel I<HZ> "
"value is 1000, this means that timeouts greater than 35.79 minutes are "
"treated as infinity."
msgstr ""
"В ядрах до версии 2.6.37, если значение I<timeout> больше чем приблизительное "
"I<LONG_MAX / HZ> секунд, то оно воспринимается как -1 (т.е., бесконечность). "
"То есть, например, в системе, где I<sizeof(long)> равно 4 и значение ядра I<"
"HZ> равно 1000, задержка более 35,79 минут считается бесконечностью."

#. type: Plain text
#: man-pages/man2/epoll_wait.2:232
msgid "B<epoll_create>(2), B<epoll_ctl>(2), B<epoll>(7)"
msgstr "B<epoll_create>(2), B<epoll_ctl>(2), B<epoll>(7)"

#. type: TH
#: man-pages/man5/elf.5:35
#, no-wrap
msgid "ELF"
msgstr "ELF"

#. type: TH
#: man-pages/man5/elf.5:35
#, no-wrap
msgid "2013-04-17"
msgstr "2013-04-17"

#. type: Plain text
#: man-pages/man5/elf.5:38
msgid "elf - format of Executable and Linking Format (ELF) files"
msgstr "elf - формат исполняемых и компонуемых файлов (ELF)"

#.  .B #include <elf_abi.h>
#. type: Plain text
#: man-pages/man5/elf.5:42
#, no-wrap
msgid "B<#include E<lt>elf.hE<gt>>\n"
msgstr "B<#include E<lt>elf.hE<gt>>\n"

#. type: Plain text
#: man-pages/man5/elf.5:50
msgid ""
"The header file I<E<lt>elf.hE<gt>> defines the format of ELF executable "
"binary files.  Amongst these files are normal executable files, relocatable "
"object files, core files and shared libraries."
msgstr ""
"В заголовочном файле I<E<lt>elf.hE<gt>> определён формат ELF для исполняемых "
"двоичных файлов. К таким файлам относятся обычные исполняемые файлы, "
"перемещаемые объектные файлы, core-файлы и динамические библиотеки."

#. type: Plain text
#: man-pages/man5/elf.5:59
msgid ""
"An executable file using the ELF file format consists of an ELF header, "
"followed by a program header table or a section header table, or both.  The "
"ELF header is always at offset zero of the file.  The program header table "
"and the section header table's offset in the file are defined in the ELF "
"header.  The two tables describe the rest of the particularities of the "
"file."
msgstr ""
"Исполняемый файл в формате ELF состоит из заголовка ELF, таблицы заголовков "
"программы или таблицы заголовков разделов (или обеих таблиц). Заголовок ELF "
"всегда расположен в начале файла. Расположение таблицы заголовков программы и "
"таблицы заголовков разделов задаётся в заголовке ELF. В этих двух таблицах "
"описывается всё остальное содержимое файла."

#.  Applications which wish to process ELF binary files for their native
#.  architecture only should include
#.  .I <elf_abi.h>
#.  in their source code.
#.  These applications should need to refer to
#.  all the types and structures by their generic names
#.  "Elf_xxx"
#.  and to the macros by
#.  ELF_xxx".
#.  Applications written this way can be compiled on any architecture,
#.  regardless of whether the host is 32-bit or 64-bit.
#.  .PP
#.  Should an application need to process ELF files of an unknown
#.  architecture, then the application needs to explicitly use either
#.  "Elf32_xxx"
#.  or
#.  "Elf64_xxx"
#.  type and structure names.
#.  Likewise, the macros need to be identified by
#.  "ELF32_xxx"
#.  or
#.  "ELF64_xxx".
#.  .PP
#. type: Plain text
#: man-pages/man5/elf.5:86
msgid ""
"This header file describes the above mentioned headers as C structures and "
"also includes structures for dynamic sections, relocation sections and "
"symbol tables."
msgstr ""
"Данный заголовочный файл описывает вышеупомянутые заголовки в виде структур "
"C, а также включает описание структур динамических разделов, разделов "
"перемещений и таблиц символов."

#. type: Plain text
#: man-pages/man5/elf.5:98
msgid ""
"The following types are used for N-bit architectures (N=32,64, I<ElfN> "
"stands for I<Elf32> or I<Elf64>, I<uintN_t> stands for I<uint32_t> or "
"I<uint64_t>):"
msgstr ""
"Для каждой N-битной архитектуры используется соответствующий тип (N=32,64; I<"
"ElfN> может быть I<Elf32> или I<Elf64>; I<uintN_t> может быть I<uint32_t> или "
"I<uint64_t>):"

#.  Elf32_Size  Unsigned object size
#. type: Plain text
#: man-pages/man5/elf.5:112
#, no-wrap
msgid ""
"ElfN_Addr       Unsigned program address, uintN_t\n"
"ElfN_Off        Unsigned file offset, uintN_t\n"
"ElfN_Section    Unsigned section index, uint16_t\n"
"ElfN_Versym     Unsigned version symbol information, uint16_t\n"
"Elf_Byte        unsigned char\n"
"ElfN_Half       uint16_t\n"
"ElfN_Sword      int32_t\n"
"ElfN_Word       uint32_t\n"
"ElfN_Sxword     int64_t\n"
"ElfN_Xword      uint64_t\n"
msgstr ""
"ElfN_Addr       Беззнаковый адрес программы, uintN_t\nElfN_Off        "
"Беззнаковое смещение в файле, uintN_t\nElfN_Section    Беззнаковый индекс "
"раздела, uint16_t\nElfN_Versym     Беззнаковые данные о версии символа, "
"uint16_t\nElf_Byte        unsigned char\nElfN_Half       uint16_t\nElfN_Sword "
"     int32_t\nElfN_Word       uint32_t\nElfN_Sxword     int64_t\nElfN_Xword   "
"   uint64_t\n"

#. type: Plain text
#: man-pages/man5/elf.5:127
msgid ""
"(Note: The *BSD terminology is a bit different.  There I<Elf64_Half> is "
"twice as large as I<Elf32_Half>, and I<Elf64Quarter> is used for "
"I<uint16_t>.  In order to avoid confusion these types are replaced by "
"explicit ones in the below.)"
msgstr ""
"(Замечание: В *BSD используется немного другая терминология. Так, I<"
"Elf64_Half> \\(em удвоенный I<Elf32_Half>, а I<Elf64Quarter> \\(em I<uint16_t>"
". Чтобы не путаться, далее эти типы заменены на их явные типы.)"

#. type: Plain text
#: man-pages/man5/elf.5:134
msgid ""
"All data structures that the file format defines follow the \"natural\" size"
" and alignment guidelines for the relevant class.  If necessary, data "
"structures contain explicit padding to ensure 4-byte alignment for 4-byte "
"objects, to force structure sizes to a multiple of 4, and so on."
msgstr ""
"Все структуры данных этого формата файлов следуют «естественному» размеру и "
"принципам выравнивания соответствующего класса. Если требуется, структуры "
"данных содержат явно указанные заполнители (padding) для выравнивания по 4-м "
"байтам для 4-байтовых объектов, для доведения размера структур до кратного "
"4-м и т. д."

#. type: Plain text
#: man-pages/man5/elf.5:139
msgid "The ELF header is described by the type I<Elf32_Ehdr> or I<Elf64_Ehdr>:"
msgstr "Заголовок ELF описывается типом I<Elf32_Ehdr> или I<Elf64_Ehdr>:"

#. type: Plain text
#: man-pages/man5/elf.5:143
#, no-wrap
msgid "#define EI_NIDENT 16\n"
msgstr "#define EI_NIDENT 16\n"

#. type: Plain text
#: man-pages/man5/elf.5:160
#, no-wrap
msgid ""
"typedef struct {\n"
"    unsigned char e_ident[EI_NIDENT];\n"
"    uint16_t      e_type;\n"
"    uint16_t      e_machine;\n"
"    uint32_t      e_version;\n"
"    ElfN_Addr     e_entry;\n"
"    ElfN_Off      e_phoff;\n"
"    ElfN_Off      e_shoff;\n"
"    uint32_t      e_flags;\n"
"    uint16_t      e_ehsize;\n"
"    uint16_t      e_phentsize;\n"
"    uint16_t      e_phnum;\n"
"    uint16_t      e_shentsize;\n"
"    uint16_t      e_shnum;\n"
"    uint16_t      e_shstrndx;\n"
"} ElfN_Ehdr;\n"
msgstr ""
"typedef struct {\n    unsigned char e_ident[EI_NIDENT];\n    uint16_t      "
"e_type;\n    uint16_t      e_machine;\n    uint32_t      e_version;\n    "
"ElfN_Addr     e_entry;\n    ElfN_Off      e_phoff;\n    ElfN_Off      "
"e_shoff;\n    uint32_t      e_flags;\n    uint16_t      e_ehsize;\n    "
"uint16_t      e_phentsize;\n    uint16_t      e_phnum;\n    uint16_t      "
"e_shentsize;\n    uint16_t      e_shnum;\n    uint16_t      e_shstrndx;\n} "
"ElfN_Ehdr;\n"

#.  .Bl -tag -width "e_phentsize"
#. type: Plain text
#: man-pages/man5/elf.5:165
msgid "The fields have the following meanings:"
msgstr "Значения полей:"

#. type: TP
#: man-pages/man5/elf.5:165
#, no-wrap
msgid "I<e_ident>"
msgstr "I<e_ident>"

#. type: Plain text
#: man-pages/man5/elf.5:175
msgid ""
"This array of bytes specifies to interpret the file, independent of the "
"processor or the file's remaining contents.  Within this array everything is"
" named by macros, which start with the prefix B<EI_> and may contain values "
"which start with the prefix B<ELF>.  The following macros are defined:"
msgstr ""
"Массив байт, описывающий как воспринимать файл, не зависит от типа процессора "
"или остального содержимого файла. Всё в массиве описывается макросами, "
"начинающимися с префикса B<EI_>, которые могут иметь значения, начинающиеся с "
"префикса B<ELF>. Определены следующие макросы:"

#. type: TP
#: man-pages/man5/elf.5:177
#, no-wrap
msgid "B<EI_MAG0>"
msgstr "B<EI_MAG0>"

#. type: Plain text
#: man-pages/man5/elf.5:183
msgid ""
"The first byte of the magic number.  It must be filled with B<ELFMAG0>.  (0:"
" 0x7f)"
msgstr ""
"Первый байт отличительного (magic) числа. Должен быть заполнен B<ELFMAG0>. "
"(0: 0x7f)"

#. type: TP
#: man-pages/man5/elf.5:183
#, no-wrap
msgid "B<EI_MAG1>"
msgstr "B<EI_MAG1>"

#. type: Plain text
#: man-pages/man5/elf.5:189
msgid ""
"The second byte of the magic number.  It must be filled with B<ELFMAG1>.  "
"(1: \\(aqE\\(aq)"
msgstr ""
"Второй байт отличительного числа. Должен быть заполнен B<ELFMAG1>. (1: "
"\\(aqE\\(aq)"

#. type: TP
#: man-pages/man5/elf.5:189
#, no-wrap
msgid "B<EI_MAG2>"
msgstr "B<EI_MAG2>"

#. type: Plain text
#: man-pages/man5/elf.5:195
msgid ""
"The third byte of the magic number.  It must be filled with B<ELFMAG2>.  (2:"
" \\(aqL\\(aq)"
msgstr ""
"Третий байт отличительного числа. Должен быть заполнен B<ELFMAG2>. (2: "
"\\(aqL\\(aq)"

#. type: TP
#: man-pages/man5/elf.5:195
#, no-wrap
msgid "B<EI_MAG3>"
msgstr "B<EI_MAG3>"

#. type: Plain text
#: man-pages/man5/elf.5:201
msgid ""
"The fourth byte of the magic number.  It must be filled with B<ELFMAG3>.  "
"(3: \\(aqF\\(aq)"
msgstr ""
"Четвёртый байт отличительного числа. Должен быть заполнен B<ELFMAG3>. (3: "
"\\(aqF\\(aq)"

#. type: TP
#: man-pages/man5/elf.5:201
#, no-wrap
msgid "B<EI_CLASS>"
msgstr "B<EI_CLASS>"

#. type: Plain text
#: man-pages/man5/elf.5:204
msgid "The fifth byte identifies the architecture for this binary:"
msgstr "В пятом байте задаётся архитектура двоичного файла:"

#. type: TP
#: man-pages/man5/elf.5:206
#, no-wrap
msgid "B<ELFCLASSNONE>"
msgstr "B<ELFCLASSNONE>"

#. type: Plain text
#: man-pages/man5/elf.5:210
msgid "This class is invalid."
msgstr "Неправильный класс."

#. type: TP
#: man-pages/man5/elf.5:210
#, no-wrap
msgid "B<ELFCLASS32>"
msgstr "B<ELFCLASS32>"

#. type: Plain text
#: man-pages/man5/elf.5:215
msgid ""
"This defines the 32-bit architecture.  It supports machines with files and "
"virtual address spaces up to 4 Gigabytes."
msgstr ""
"32-битная архитектура. Поддерживаются машины с файлами и виртуальным адресным "
"пространством до 4 гигабайт."

#. type: TP
#: man-pages/man5/elf.5:215
#, no-wrap
msgid "B<ELFCLASS64>"
msgstr "B<ELFCLASS64>"

#. type: Plain text
#: man-pages/man5/elf.5:218
msgid "This defines the 64-bit architecture."
msgstr "64-битная архитектура."

#. type: TP
#: man-pages/man5/elf.5:221
#, no-wrap
msgid "B<EI_DATA>"
msgstr "B<EI_DATA>"

#.  .Bl -tag -width "ELFDATA2LSB" -compact
#. type: Plain text
#: man-pages/man5/elf.5:227
msgid ""
"The sixth byte specifies the data encoding of the processor-specific data in"
" the file.  Currently these encodings are supported:"
msgstr ""
"В шестом байте задаётся порядок кодирования данных в файле, используемый в "
"процессоре. В настоящее время поддерживаются:"

#. type: TP
#: man-pages/man5/elf.5:228
#, no-wrap
msgid "B<ELFDATANONE>"
msgstr "B<ELFDATANONE>"

#. type: Plain text
#: man-pages/man5/elf.5:232
msgid "Unknown data format."
msgstr "Неизвестный формат данных."

#. type: TP
#: man-pages/man5/elf.5:232
#, no-wrap
msgid "B<ELFDATA2LSB>"
msgstr "B<ELFDATA2LSB>"

#. type: Plain text
#: man-pages/man5/elf.5:235
msgid "Two's complement, little-endian."
msgstr "Обратный порядок байт (little-endian) в дополнительном коде."

#. type: TP
#: man-pages/man5/elf.5:235
#, no-wrap
msgid "B<ELFDATA2MSB>"
msgstr "B<ELFDATA2MSB>"

#. type: Plain text
#: man-pages/man5/elf.5:238
msgid "Two's complement, big-endian."
msgstr "Прямой порядок байт (big-endian) в дополнительном коде."

#. type: TP
#: man-pages/man5/elf.5:241
#, no-wrap
msgid "B<EI_VERSION>"
msgstr "B<EI_VERSION>"

#.  .Bl -tag -width "EV_CURRENT" -compact
#. type: Plain text
#: man-pages/man5/elf.5:246
msgid "The seventh byte is the version number of the ELF specification:"
msgstr "В седьмом байте указывается номер версии спецификации ELF:"

#. type: TP
#: man-pages/man5/elf.5:247 man-pages/man5/elf.5:501
#, no-wrap
msgid "B<EV_NONE>"
msgstr "B<EV_NONE>"

#. type: Plain text
#: man-pages/man5/elf.5:250 man-pages/man5/elf.5:505
msgid "Invalid version."
msgstr "Неправильный номер версии."

#. type: TP
#: man-pages/man5/elf.5:250 man-pages/man5/elf.5:505
#, no-wrap
msgid "B<EV_CURRENT>"
msgstr "B<EV_CURRENT>"

#.  .El
#. type: Plain text
#: man-pages/man5/elf.5:253 man-pages/man5/elf.5:509
msgid "Current version."
msgstr "Текущая версия."

#. type: TP
#: man-pages/man5/elf.5:256
#, no-wrap
msgid "B<EI_OSABI>"
msgstr "B<EI_OSABI>"

#.  .Bl -tag -width "ELFOSABI_STANDALONE" -compact
#. type: Plain text
#: man-pages/man5/elf.5:265
msgid ""
"The eighth byte identifies the operating system and ABI to which the object "
"is targeted.  Some fields in other ELF structures have flags and values that"
" have platform-specific meanings; the interpretation of those fields is "
"determined by the value of this byte.  For example:"
msgstr ""
"В восьмом байте указывается тип операционной системы и двоичного интерфейса "
"приложений (ABI), для которой предназначен объект. Некоторые поля в других "
"структурах ELF имеют флаги и значения, зависящие от платформы; интерпретация "
"таких полей определяется значением данного байта. Пример:"

#. type: TP
#: man-pages/man5/elf.5:266
#, no-wrap
msgid "B<ELFOSABI_NONE>"
msgstr "B<ELFOSABI_NONE>"

#.  0
#. type: Plain text
#: man-pages/man5/elf.5:271
msgid "Same as ELFOSABI_SYSV"
msgstr "Тоже что и ELFOSABI_SYSV."

#. type: TP
#: man-pages/man5/elf.5:271
#, no-wrap
msgid "B<ELFOSABI_SYSV>"
msgstr "B<ELFOSABI_SYSV>"

#.  0
#.  synonym: ELFOSABI_NONE
#. type: Plain text
#: man-pages/man5/elf.5:276
msgid "UNIX System V ABI."
msgstr "UNIX System V ABI."

#. type: TP
#: man-pages/man5/elf.5:276
#, no-wrap
msgid "B<ELFOSABI_HPUX>"
msgstr "B<ELFOSABI_HPUX>"

#.  1
#. type: Plain text
#: man-pages/man5/elf.5:280
msgid "HP-UX ABI."
msgstr "HP-UX ABI."

#. type: TP
#: man-pages/man5/elf.5:280
#, no-wrap
msgid "B<ELFOSABI_NETBSD>"
msgstr "B<ELFOSABI_NETBSD>"

#.  2
#. type: Plain text
#: man-pages/man5/elf.5:284
msgid "NetBSD ABI."
msgstr "NetBSD ABI."

#. type: TP
#: man-pages/man5/elf.5:284
#, no-wrap
msgid "B<ELFOSABI_LINUX>"
msgstr "B<ELFOSABI_LINUX>"

#.  3
#.  .TP
#.  .BR ELFOSABI_HURD
#.  Hurd ABI.
#.  4
#.  .TP
#.  .BR ELFOSABI_86OPEN
#.  86Open Common IA32 ABI.
#.  5
#. type: Plain text
#: man-pages/man5/elf.5:296
msgid "Linux ABI."
msgstr "Linux ABI."

#. type: TP
#: man-pages/man5/elf.5:296
#, no-wrap
msgid "B<ELFOSABI_SOLARIS>"
msgstr "B<ELFOSABI_SOLARIS>"

#.  6
#.  .TP
#.  .BR ELFOSABI_MONTEREY
#.  Monterey project ABI.
#.  Now replaced by
#.  ELFOSABI_AIX
#.  7
#. type: Plain text
#: man-pages/man5/elf.5:306
msgid "Solaris ABI."
msgstr "Solaris ABI."

#. type: TP
#: man-pages/man5/elf.5:306
#, no-wrap
msgid "B<ELFOSABI_IRIX>"
msgstr "B<ELFOSABI_IRIX>"

#.  8
#. type: Plain text
#: man-pages/man5/elf.5:310
msgid "IRIX ABI."
msgstr "IRIX ABI."

#. type: TP
#: man-pages/man5/elf.5:310
#, no-wrap
msgid "B<ELFOSABI_FREEBSD>"
msgstr "B<ELFOSABI_FREEBSD>"

#.  9
#. type: Plain text
#: man-pages/man5/elf.5:314
msgid "FreeBSD ABI."
msgstr "FreeBSD ABI."

#. type: TP
#: man-pages/man5/elf.5:314
#, no-wrap
msgid "B<ELFOSABI_TRU64>"
msgstr "B<ELFOSABI_TRU64>"

#.  10
#.  ELFOSABI_MODESTO
#.  11
#.  ELFOSABI_OPENBSD
#.  12
#. type: Plain text
#: man-pages/man5/elf.5:322
msgid "TRU64 UNIX ABI."
msgstr "TRU64 UNIX ABI."

#. type: TP
#: man-pages/man5/elf.5:322
#, no-wrap
msgid "B<ELFOSABI_ARM>"
msgstr "B<ELFOSABI_ARM>"

#.  97
#. type: Plain text
#: man-pages/man5/elf.5:326
msgid "ARM architecture ABI."
msgstr "ABI архитектуры ARM."

#. type: TP
#: man-pages/man5/elf.5:326
#, no-wrap
msgid "B<ELFOSABI_STANDALONE>"
msgstr "B<ELFOSABI_STANDALONE>"

#.  255
#.  .El
#. type: Plain text
#: man-pages/man5/elf.5:331
msgid "Stand-alone (embedded) ABI."
msgstr "Автономный (встраиваемый) ABI."

#. type: TP
#: man-pages/man5/elf.5:333
#, no-wrap
msgid "B<EI_ABIVERSION>"
msgstr "B<EI_ABIVERSION>"

#. type: Plain text
#: man-pages/man5/elf.5:343
msgid ""
"The ninth byte identifies the version of the ABI to which the object is "
"targeted.  This field is used to distinguish among incompatible versions of "
"an ABI.  The interpretation of this version number is dependent on the ABI "
"identified by the B<EI_OSABI> field.  Applications conforming to this "
"specification use the value 0."
msgstr ""
"В девятом байте указывается версия ABI, для которой предназначен объект. Это "
"поле используется для разграничения несовместимых версий ABI. Интерпретация "
"данного номера версии зависит от ABI, указанного в поле B<EI_OSABI>. В "
"приложениях, удовлетворяющих данной спецификации, используется значение 0."

#. type: TP
#: man-pages/man5/elf.5:343
#, no-wrap
msgid "B<EI_PAD>"
msgstr "B<EI_PAD>"

#.  As reported by Yuri Kozlov and confirmed by Mike Frysinger, EI_BRAND is
#.  not in GABI (http://www.sco.com/developers/gabi/latest/ch4.eheader.html)
#.  It looks to be a BSDism
#.  .TP
#.  .BR EI_BRAND
#.  Start of architecture identification.
#. type: Plain text
#: man-pages/man5/elf.5:359
msgid ""
"Start of padding.  These bytes are reserved and set to zero.  Programs which"
" read them should ignore them.  The value for B<EI_PAD> will change in the "
"future if currently unused bytes are given meanings."
msgstr ""
"Начало заполнителя. Эти байты зарезервированы и устанавливаются в ноль. "
"Программы, читающие заголовок, должны игнорировать их. Значение B<EI_PAD> "
"будет изменено, если понадобится задействовать неиспользуемые в данный момент "
"байты."

#. type: TP
#: man-pages/man5/elf.5:359
#, no-wrap
msgid "B<EI_NIDENT>"
msgstr "B<EI_NIDENT>"

#.  .El
#. type: Plain text
#: man-pages/man5/elf.5:365
msgid "The size of the I<e_ident> array."
msgstr "Размер массива I<e_ident>."

#. type: TP
#: man-pages/man5/elf.5:366
#, no-wrap
msgid "I<e_type>"
msgstr "I<e_type>"

#. type: Plain text
#: man-pages/man5/elf.5:369
msgid "This member of the structure identifies the object file type:"
msgstr "В этом поле структуры содержится тип объектного файла:"

#. type: TP
#: man-pages/man5/elf.5:371
#, no-wrap
msgid "B<ET_NONE>"
msgstr "B<ET_NONE>"

#. type: Plain text
#: man-pages/man5/elf.5:375
msgid "An unknown type."
msgstr "Неизвестный тип."

#. type: TP
#: man-pages/man5/elf.5:375
#, no-wrap
msgid "B<ET_REL>"
msgstr "B<ET_REL>"

#. type: Plain text
#: man-pages/man5/elf.5:378
msgid "A relocatable file."
msgstr "Перемещаемый файл."

#. type: TP
#: man-pages/man5/elf.5:378
#, no-wrap
msgid "B<ET_EXEC>"
msgstr "B<ET_EXEC>"

#. type: Plain text
#: man-pages/man5/elf.5:381
msgid "An executable file."
msgstr "Исполняемый файл."

#. type: TP
#: man-pages/man5/elf.5:381
#, no-wrap
msgid "B<ET_DYN>"
msgstr "B<ET_DYN>"

#. type: Plain text
#: man-pages/man5/elf.5:384
msgid "A shared object."
msgstr "Динамический объект."

#. type: TP
#: man-pages/man5/elf.5:384
#, no-wrap
msgid "B<ET_CORE>"
msgstr "B<ET_CORE>"

#. type: Plain text
#: man-pages/man5/elf.5:387
msgid "A core file."
msgstr "Файл типа core."

#. type: TP
#: man-pages/man5/elf.5:390
#, no-wrap
msgid "I<e_machine>"
msgstr "I<e_machine>"

#. type: Plain text
#: man-pages/man5/elf.5:394
msgid ""
"This member specifies the required architecture for an individual file.  For"
" example:"
msgstr ""
"В этом поле содержится значение требуемой для файла архитектуры. Пример:"

#. type: TP
#: man-pages/man5/elf.5:396
#, no-wrap
msgid "B<EM_NONE>"
msgstr "B<EM_NONE>"

#.  0
#. type: Plain text
#: man-pages/man5/elf.5:401
msgid "An unknown machine."
msgstr "Неизвестная машинная архитектура."

#. type: TP
#: man-pages/man5/elf.5:401
#, no-wrap
msgid "B<EM_M32>"
msgstr "B<EM_M32>"

#.  1
#. type: Plain text
#: man-pages/man5/elf.5:405
msgid "AT&T WE 32100."
msgstr "AT&T WE 32100."

#. type: TP
#: man-pages/man5/elf.5:405
#, no-wrap
msgid "B<EM_SPARC>"
msgstr "B<EM_SPARC>"

#.  2
#. type: Plain text
#: man-pages/man5/elf.5:409
msgid "Sun Microsystems SPARC."
msgstr "Sun Microsystems SPARC."

#. type: TP
#: man-pages/man5/elf.5:409
#, no-wrap
msgid "B<EM_386>"
msgstr "B<EM_386>"

#.  3
#. type: Plain text
#: man-pages/man5/elf.5:413
msgid "Intel 80386."
msgstr "Intel 80386."

#. type: TP
#: man-pages/man5/elf.5:413
#, no-wrap
msgid "B<EM_68K>"
msgstr "B<EM_68K>"

#.  4
#. type: Plain text
#: man-pages/man5/elf.5:417
msgid "Motorola 68000."
msgstr "Motorola 68000."

#. type: TP
#: man-pages/man5/elf.5:417
#, no-wrap
msgid "B<EM_88K>"
msgstr "B<EM_88K>"

#.  5
#.  .TP
#.  .BR EM_486
#.  Intel 80486.
#.  6
#. type: Plain text
#: man-pages/man5/elf.5:425
msgid "Motorola 88000."
msgstr "Motorola 88000."

#. type: TP
#: man-pages/man5/elf.5:425
#, no-wrap
msgid "B<EM_860>"
msgstr "B<EM_860>"

#.  7
#. type: Plain text
#: man-pages/man5/elf.5:429
msgid "Intel 80860."
msgstr "Intel 80860."

#. type: TP
#: man-pages/man5/elf.5:429
#, no-wrap
msgid "B<EM_MIPS>"
msgstr "B<EM_MIPS>"

#.  8
#.  EM_S370
#.  9
#.  .TP
#.  .BR EM_MIPS_RS4_BE
#.  MIPS RS4000 (big-endian only). Deprecated.
#.  10
#.  EM_MIPS_RS3_LE (MIPS R3000 little-endian)
#.  10
#. type: Plain text
#: man-pages/man5/elf.5:441
msgid "MIPS RS3000 (big-endian only)."
msgstr "MIPS RS3000 (только с прямым порядком байт)."

#. type: TP
#: man-pages/man5/elf.5:441
#, no-wrap
msgid "B<EM_PARISC>"
msgstr "B<EM_PARISC>"

#.  15
#. type: Plain text
#: man-pages/man5/elf.5:445
msgid "HP/PA."
msgstr "HP/PA."

#. type: TP
#: man-pages/man5/elf.5:445
#, no-wrap
msgid "B<EM_SPARC32PLUS>"
msgstr "B<EM_SPARC32PLUS>"

#.  18
#. type: Plain text
#: man-pages/man5/elf.5:449
msgid "SPARC with enhanced instruction set."
msgstr "SPARC с расширенным набором инструкций."

#. type: TP
#: man-pages/man5/elf.5:449
#, no-wrap
msgid "B<EM_PPC>"
msgstr "B<EM_PPC>"

#.  20
#. type: Plain text
#: man-pages/man5/elf.5:453
msgid "PowerPC."
msgstr "PowerPC."

#. type: TP
#: man-pages/man5/elf.5:453
#, no-wrap
msgid "B<EM_PPC64>"
msgstr "B<EM_PPC64>"

#.  21
#. type: Plain text
#: man-pages/man5/elf.5:457
msgid "PowerPC 64-bit."
msgstr "PowerPC, 64-битная."

#. type: TP
#: man-pages/man5/elf.5:457
#, no-wrap
msgid "B<EM_S390>"
msgstr "B<EM_S390>"

#.  22
#. type: Plain text
#: man-pages/man5/elf.5:461
msgid "IBM S/390"
msgstr "IBM S/390."

#. type: TP
#: man-pages/man5/elf.5:461
#, no-wrap
msgid "B<EM_ARM>"
msgstr "B<EM_ARM>"

#.  40
#. type: Plain text
#: man-pages/man5/elf.5:465
msgid "Advanced RISC Machines"
msgstr "Advanced RISC Machines."

#. type: TP
#: man-pages/man5/elf.5:465
#, no-wrap
msgid "B<EM_SH>"
msgstr "B<EM_SH>"

#.  42
#. type: Plain text
#: man-pages/man5/elf.5:469
msgid "Renesas SuperH"
msgstr "Renesas SuperH."

#. type: TP
#: man-pages/man5/elf.5:469
#, no-wrap
msgid "B<EM_SPARCV9>"
msgstr "B<EM_SPARCV9>"

#.  43
#. type: Plain text
#: man-pages/man5/elf.5:473
msgid "SPARC v9 64-bit."
msgstr "SPARC v9, 64-битная."

#. type: TP
#: man-pages/man5/elf.5:473
#, no-wrap
msgid "B<EM_IA_64>"
msgstr "B<EM_IA_64>"

#.  50
#. type: Plain text
#: man-pages/man5/elf.5:477
msgid "Intel Itanium"
msgstr "Intel Itanium."

#. type: TP
#: man-pages/man5/elf.5:477
#, no-wrap
msgid "B<EM_X86_64>"
msgstr "B<EM_X86_64>"

#.  62
#. type: Plain text
#: man-pages/man5/elf.5:481
msgid "AMD x86-64"
msgstr "AMD x86-64."

#. type: TP
#: man-pages/man5/elf.5:481
#, no-wrap
msgid "B<EM_VAX>"
msgstr "B<EM_VAX>"

#.  75
#.  EM_CRIS
#.  76
#.  .TP
#.  .BR EM_ALPHA
#.  Compaq [DEC] Alpha.
#.  .TP
#.  .BR EM_ALPHA_EXP
#.  Compaq [DEC] Alpha with enhanced instruction set.
#. type: Plain text
#: man-pages/man5/elf.5:493
msgid "DEC Vax."
msgstr "DEC Vax."

#. type: TP
#: man-pages/man5/elf.5:496
#, no-wrap
msgid "I<e_version>"
msgstr "I<e_version>"

#.  .Bl -tag -width "EV_CURRENT" -compact
#. type: Plain text
#: man-pages/man5/elf.5:500
msgid "This member identifies the file version:"
msgstr "В этом поле содержится версия файла:"

#. type: TP
#: man-pages/man5/elf.5:511
#, no-wrap
msgid "I<e_entry>"
msgstr "I<e_entry>"

#. type: Plain text
#: man-pages/man5/elf.5:517
msgid ""
"This member gives the virtual address to which the system first transfers "
"control, thus starting the process.  If the file has no associated entry "
"point, this member holds zero."
msgstr ""
"В этом поле содержится виртуальный адрес, по которому система должна передать "
"управление для запуска процесса. Если в файле нет такой точки входа, то "
"значение поля равно 0."

#. type: TP
#: man-pages/man5/elf.5:517
#, no-wrap
msgid "I<e_phoff>"
msgstr "I<e_phoff>"

#. type: Plain text
#: man-pages/man5/elf.5:522
msgid ""
"This member holds the program header table's file offset in bytes.  If the "
"file has no program header table, this member holds zero."
msgstr ""
"В этом поле содержится файловое смещение в байтах для таблицы заголовков "
"программы. Если в файле нет таблицы заголовков программы, то значение поля "
"равно 0."

#. type: TP
#: man-pages/man5/elf.5:522
#, no-wrap
msgid "I<e_shoff>"
msgstr "I<e_shoff>"

#. type: Plain text
#: man-pages/man5/elf.5:527
msgid ""
"This member holds the section header table's file offset in bytes.  If the "
"file has no section header table, this member holds zero."
msgstr ""
"В этом поле содержится файловое смещение в байтах для таблицы заголовков "
"разделов. Если в файле нет таблицы заголовков разделов, то значение поля "
"равно 0."

#. type: TP
#: man-pages/man5/elf.5:527
#, no-wrap
msgid "I<e_flags>"
msgstr "I<e_flags>"

#. type: Plain text
#: man-pages/man5/elf.5:532
msgid ""
"This member holds processor-specific flags associated with the file.  Flag "
"names take the form EF_`machine_flag'.  Currently no flags have been "
"defined."
msgstr ""
"В этом поле содержатся специфичные для процессора флаги, относящиеся к файлу. "
"Имена флагов имеют вид: EF_машинный_флаг. В настоящее время нет ни одного "
"предопределённого флага."

#. type: TP
#: man-pages/man5/elf.5:532
#, no-wrap
msgid "I<e_ehsize>"
msgstr "I<e_ehsize>"

#. type: Plain text
#: man-pages/man5/elf.5:535
msgid "This member holds the ELF header's size in bytes."
msgstr "В этом поле содержится размер заголовка ELF в байтах."

#. type: TP
#: man-pages/man5/elf.5:535
#, no-wrap
msgid "I<e_phentsize>"
msgstr "I<e_phentsize>"

#. type: Plain text
#: man-pages/man5/elf.5:539
msgid ""
"This member holds the size in bytes of one entry in the file's program "
"header table; all entries are the same size."
msgstr ""
"В этом поле содержится размер в байтах одного элемента таблицы заголовков "
"программы в файле; все элементы имеют одинаковый размер."

#. type: TP
#: man-pages/man5/elf.5:539
#, no-wrap
msgid "I<e_phnum>"
msgstr "I<e_phnum>"

#. type: Plain text
#: man-pages/man5/elf.5:552
msgid ""
"This member holds the number of entries in the program header table.  Thus "
"the product of I<e_phentsize> and I<e_phnum> gives the table's size in "
"bytes.  If a file has no program header, I<e_phnum> holds the value zero."
msgstr ""
"В этом поле содержится количество элементов в таблице заголовков программы. "
"Таким образом, произведение I<e_phentsize> и I<e_phnum> даёт размер таблицы в "
"байтах. Если в файле нет заголовков программы, то I<e_phnum> содержит 0."

#.  This is a Linux extension, added in Linux 2.6.34.
#.  .Bl -tag -width "PN_XNUM"
#. type: Plain text
#: man-pages/man5/elf.5:566
msgid ""
"If the number of entries in the program header table is larger than or equal"
" to B<PN_XNUM> (0xffff), this member holds B<PN_XNUM> (0xffff) and the real "
"number of entries in the program header table is held in the I<sh_info> "
"member of the initial entry in section header table.  Otherwise, the "
"I<sh_info> member of the initial entry contains the value zero."
msgstr ""
"Если количество элементов в таблице заголовков программы больше или равно B<"
"PN_XNUM> (0xffff), это поле  содержит значение B<PN_XNUM> (0xffff) и реальное "
"количество элементов таблицы заголовков программы хранится в поле I<sh_info> "
"начального элемента таблицы заголовков разделов. Иначе поле I<sh_info> "
"начального элемента содержит ноль."

#. type: TP
#: man-pages/man5/elf.5:567
#, no-wrap
msgid "B<PN_XNUM>"
msgstr "B<PN_XNUM>"

#. type: Plain text
#: man-pages/man5/elf.5:572
msgid ""
"This is defined as 0xffff, the largest number I<e_phnum> can have, "
"specifying where the actual number of program headers is assigned."
msgstr ""
"Имеет значение 0xffff, самое большое количество, которое может иметь I<"
"e_phnum>, показывает, где расположено реальное количество заголовков "
"программы."

#. type: TP
#: man-pages/man5/elf.5:576
#, no-wrap
msgid "I<e_shentsize>"
msgstr "I<e_shentsize>"

#. type: Plain text
#: man-pages/man5/elf.5:581
msgid ""
"This member holds a sections header's size in bytes.  A section header is "
"one entry in the section header table; all entries are the same size."
msgstr ""
"В этом поле содержится размер в байтах одного элемента таблицы заголовков "
"разделов; все элементы имеют одинаковый размер."

#. type: TP
#: man-pages/man5/elf.5:581
#, no-wrap
msgid "I<e_shnum>"
msgstr "I<e_shnum>"

#. type: Plain text
#: man-pages/man5/elf.5:594
msgid ""
"This member holds the number of entries in the section header table.  Thus "
"the product of I<e_shentsize> and I<e_shnum> gives the section header "
"table's size in bytes.  If a file has no section header table, I<e_shnum> "
"holds the value of zero."
msgstr ""
"В этом поле содержится количество элементов в таблице заголовков разделов. "
"Таким образом, произведение I<e_shentsize> и I<e_shnum> даёт размер таблицы "
"разделов в байтах. Если в файле нет заголовков разделов, то I<e_shnum> "
"содержит 0."

#. type: Plain text
#: man-pages/man5/elf.5:606
msgid ""
"If the number of entries in the section header table is larger than or equal"
" to B<SHN_LORESERVE> (0xff00), I<e_shnum> holds the value zero and the real "
"number of entries in the section header table is held in the I<sh_size> "
"member of the initial entry in section header table.  Otherwise, the "
"I<sh_size> member of the initial entry in the section header table holds the"
" value zero."
msgstr ""
"Если количество элементов в таблице заголовков разделов больше или равно B<"
"SHN_LORESERVE> (0xff00), то значение I<e_shnum> равно и реальное количество "
"элементов таблицы заголовков разделов хранится в поле I<sh_size> начального "
"элемента таблицы заголовков разделов. Иначе поле I<sh_size> начального "
"элемента таблицы заголовков разделов имеет значение ноль."

#. type: TP
#: man-pages/man5/elf.5:606
#, no-wrap
msgid "I<e_shstrndx>"
msgstr "I<e_shstrndx>"

#. type: Plain text
#: man-pages/man5/elf.5:613
msgid ""
"This member holds the section header table index of the entry associated "
"with the section name string table.  If the file has no section name string "
"table, this member holds the value B<SHN_UNDEF>."
msgstr ""
"В этом поле содержится индекс элемента в таблице заголовков разделов, "
"указывающий на строковую таблицу названий разделов. Если в файле нет "
"строковой таблицы названий разделов, то это поле содержит значение B<"
"SHN_UNDEF>."

#. type: Plain text
#: man-pages/man5/elf.5:625
msgid ""
"If the index of section name string table section is larger than or equal to"
" B<SHN_LORESERVE> (0xff00), this member holds B<SHN_XINDEX> (0xffff) and the"
" real index of the section name string table section is held in the "
"I<sh_link> member of the initial entry in section header table.  Otherwise, "
"the I<sh_link> member of the initial entry in section header table contains "
"the value zero."
msgstr ""
"Если индекс строки имён разделов в таблице разделов больше или равен B<"
"SHN_LORESERVE> (0xff00), то в этом поле содержится значение B<SHN_XINDEX> "
"(0xffff) и реальный индекс строки имён разделов в таблице разделов хранится в "
"поле I<sh_link> начального элемента таблицы заголовков разделов. Иначе поле "
"I<sh_link> начального элемента таблицы заголовков разделов имеет значение "
"ноль."

#. type: TP
#: man-pages/man5/elf.5:627 man-pages/man5/elf.5:914
#, no-wrap
msgid "B<SHN_UNDEF>"
msgstr "B<SHN_UNDEF>"

#. type: Plain text
#: man-pages/man5/elf.5:636
msgid ""
"This value marks an undefined, missing, irrelevant, or otherwise meaningless"
" section reference.  For example, a symbol \"defined\" relative to section "
"number B<SHN_UNDEF> is an undefined symbol."
msgstr ""
"Этим значением помечается неопределённая, отсутствующая, неприменимая или "
"другая нецелесообразная ссылка на раздел. Например, символ, \"определённый\" "
"в разделе с номером B<SHN_UNDEF>, является неопределённым символом."

#. type: TP
#: man-pages/man5/elf.5:636 man-pages/man5/elf.5:918
#, no-wrap
msgid "B<SHN_LORESERVE>"
msgstr "B<SHN_LORESERVE>"

#. type: Plain text
#: man-pages/man5/elf.5:639 man-pages/man5/elf.5:921
msgid "This value specifies the lower bound of the range of reserved indices."
msgstr ""
"Это значение задаёт нижнюю границу диапазона зарезервированных индексов."

#. type: TP
#: man-pages/man5/elf.5:639 man-pages/man5/elf.5:921
#, no-wrap
msgid "B<SHN_LOPROC>"
msgstr "B<SHN_LOPROC>"

#. type: Plain text
#: man-pages/man5/elf.5:644 man-pages/man5/elf.5:926
msgid ""
"Values greater than or equal to B<SHN_HIPROC> are reserved for processor-"
"specific semantics."
msgstr ""
"Значения больше данного или равные B<SHN_HIPROC> зарезервированы для "
"процессорно-ориентированной семантики."

#. type: TP
#: man-pages/man5/elf.5:644 man-pages/man5/elf.5:926
#, no-wrap
msgid "B<SHN_HIPROC>"
msgstr "B<SHN_HIPROC>"

#. type: Plain text
#: man-pages/man5/elf.5:649 man-pages/man5/elf.5:931
msgid ""
"Values less than or equal to B<SHN_LOPROC> are reserved for processor-"
"specific semantics."
msgstr ""
"Значения меньше данного или равные B<SHN_LOPROC> зарезервированы для "
"процессорно-ориентированной семантики."

#. type: TP
#: man-pages/man5/elf.5:649 man-pages/man5/elf.5:931
#, no-wrap
msgid "B<SHN_ABS>"
msgstr "B<SHN_ABS>"

#. type: Plain text
#: man-pages/man5/elf.5:656
msgid ""
"This value specifies absolute values for the corresponding reference.  For "
"example, symbols defined relative to section number B<SHN_ABS> have absolute"
" values and are not affected by relocation."
msgstr ""
"Это значение указывает на абсолютное значение соответствующей ссылки. "
"Например, символы, определённые в разделе с номером B<SHN_ABS>, имеют "
"абсолютные значения и не подвержены перемещению."

#. type: TP
#: man-pages/man5/elf.5:656 man-pages/man5/elf.5:938
#, no-wrap
msgid "B<SHN_COMMON>"
msgstr "B<SHN_COMMON>"

#. type: Plain text
#: man-pages/man5/elf.5:660
msgid ""
"Symbols defined relative to this section are common symbols, such as Fortran"
" COMMON or unallocated C external variables."
msgstr ""
"Символы, определённые в разделе этого типа, являются общими символами, такими "
"как Fortran COMMON или нераспределённые внешние переменные C."

#. type: TP
#: man-pages/man5/elf.5:660 man-pages/man5/elf.5:942
#, no-wrap
msgid "B<SHN_HIRESERVE>"
msgstr "B<SHN_HIRESERVE>"

#. type: Plain text
#: man-pages/man5/elf.5:673
msgid ""
"This value specifies the upper bound of the range of reserved indices "
"between B<SHN_LORESERVE> and B<SHN_HIRESERVE>, inclusive; the values do not "
"reference the section header table.  That is, the section header table does "
"I<not> contain entries for the reserved indices."
msgstr ""
"Это значение задаёт верхнюю границу диапазона зарезервированных индексов "
"между B<SHN_LORESERVE> и B<SHN_HIRESERVE> включительно; для значений из "
"диапазона нет ссылок в таблице заголовков разделов. То есть, таблица "
"заголовков разделов I<не> содержит элементы по зарезервированным индексам."

#. type: Plain text
#: man-pages/man5/elf.5:695
msgid ""
"An executable or shared object file's program header table is an array of "
"structures, each describing a segment or other information the system needs "
"to prepare the program for execution.  An object file I<segment> contains "
"one or more I<sections>.  Program headers are meaningful only for executable"
" and shared object files.  A file specifies its own program header size with"
" the ELF header's I<e_phentsize> and I<e_phnum> members.  The ELF program "
"header is described by the type I<Elf32_Phdr> or I<Elf64_Phdr> depending on "
"the architecture:"
msgstr ""
"Таблица заголовков программы исполняемого или совместно используемого "
"объектного файла представляет собой массив структур, каждая из которых "
"описывает сегмент или содержит другую информацию, необходимую системе для "
"подготовки программы к выполнению. I<Сегмент> объектного файла содержит один "
"или более I<разделов>. Заголовки программы нужны только для исполняемых и "
"совместно используемых объектных файлов. Размер заголовков программы "
"указывается в файле в заголовке ELF в полях I<e_phentsize> и I<e_phnum>. "
"Заголовок программы ELF описывается типом I<Elf32_Phdr> или I<Elf64_Phdr>, в "
"зависимости от архитектуры:"

#. type: Plain text
#: man-pages/man5/elf.5:708
#, no-wrap
msgid ""
"typedef struct {\n"
"    uint32_t   p_type;\n"
"    Elf32_Off  p_offset;\n"
"    Elf32_Addr p_vaddr;\n"
"    Elf32_Addr p_paddr;\n"
"    uint32_t   p_filesz;\n"
"    uint32_t   p_memsz;\n"
"    uint32_t   p_flags;\n"
"    uint32_t   p_align;\n"
"} Elf32_Phdr;\n"
msgstr ""
"typedef struct {\n    uint32_t   p_type;\n    Elf32_Off  p_offset;\n    "
"Elf32_Addr p_vaddr;\n    Elf32_Addr p_paddr;\n    uint32_t   p_filesz;\n    "
"uint32_t   p_memsz;\n    uint32_t   p_flags;\n    uint32_t   p_align;\n} "
"Elf32_Phdr;\n"

#. type: Plain text
#: man-pages/man5/elf.5:723
#, no-wrap
msgid ""
"typedef struct {\n"
"    uint32_t   p_type;\n"
"    uint32_t   p_flags;\n"
"    Elf64_Off  p_offset;\n"
"    Elf64_Addr p_vaddr;\n"
"    Elf64_Addr p_paddr;\n"
"    uint64_t   p_filesz;\n"
"    uint64_t   p_memsz;\n"
"    uint64_t   p_align;\n"
"} Elf64_Phdr;\n"
msgstr ""
"typedef struct {\n    uint32_t   p_type;\n    uint32_t   p_flags;\n    "
"Elf64_Off  p_offset;\n    Elf64_Addr p_vaddr;\n    Elf64_Addr p_paddr;\n    "
"uint64_t   p_filesz;\n    uint64_t   p_memsz;\n    uint64_t   p_align;\n} "
"Elf64_Phdr;\n"

#.  .Bl -tag -width "p_offset"
#. type: Plain text
#: man-pages/man5/elf.5:731
msgid ""
"The main difference between the 32-bit and the 64-bit program header lies in"
" the location of the I<p_flags> member in the total struct."
msgstr ""
"Основным отличием между 32-битным и 64-битным программным заголовком в "
"структуре является расположение поля I<p_flags>."

#. type: TP
#: man-pages/man5/elf.5:731
#, no-wrap
msgid "I<p_type>"
msgstr "I<p_type>"

#.  .Bl -tag -width "PT_DYNAMIC"
#. type: Plain text
#: man-pages/man5/elf.5:736
msgid ""
"This member of the Phdr struct tells what kind of segment this array element"
" describes or how to interpret the array element's information."
msgstr ""
"Это поле структуры Phdr определяет, какой тип сегмента описывает этот элемент "
"массива или как воспринимать информацию данного элемента массива."

#. type: TP
#: man-pages/man5/elf.5:737
#, no-wrap
msgid "B<PT_NULL>"
msgstr "B<PT_NULL>"

#. type: Plain text
#: man-pages/man5/elf.5:741
msgid ""
"The array element is unused and the other members' values are undefined.  "
"This lets the program header have ignored entries."
msgstr ""
"Элемент массива не используется и значения других полей не определены. Это "
"позволяет иметь в заголовке программы игнорируемые элементы."

#. type: TP
#: man-pages/man5/elf.5:741
#, no-wrap
msgid "B<PT_LOAD>"
msgstr "B<PT_LOAD>"

#. type: Plain text
#: man-pages/man5/elf.5:762
msgid ""
"The array element specifies a loadable segment, described by I<p_filesz> and"
" I<p_memsz>.  The bytes from the file are mapped to the beginning of the "
"memory segment.  If the segment's memory size I<p_memsz> is larger than the "
"file size I<p_filesz>, the \"extra\" bytes are defined to hold the value 0 "
"and to follow the segment's initialized area.  The file size may not be "
"larger than the memory size.  Loadable segment entries in the program header"
" table appear in ascending order, sorted on the I<p_vaddr> member."
msgstr ""
"Элемент массива определяет загружаемый сегмент, описываемый I<p_filesz> и I<"
"p_memsz>. Байты из файла проецируются в начало сегмента памяти. Если размер "
"сегмента памяти I<p_memsz> больше чем размер файла I<p_filesz>, то "
"определяются \"дополнительные\" байты, содержащие значение 0, и их "
"располагают за инициализированной областью сегмента. Размер файла не может "
"быть больше размера памяти. Элементы загружаемых сегментов в таблице "
"заголовков программы располагаются в порядке возрастания, их сортируют по "
"полю I<p_vaddr>."

#. type: TP
#: man-pages/man5/elf.5:762
#, no-wrap
msgid "B<PT_DYNAMIC>"
msgstr "B<PT_DYNAMIC>"

#. type: Plain text
#: man-pages/man5/elf.5:765
msgid "The array element specifies dynamic linking information."
msgstr ""
"Элемент массива указывает на данные с информацией по динамической компоновке."

#. type: TP
#: man-pages/man5/elf.5:765
#, no-wrap
msgid "B<PT_INTERP>"
msgstr "B<PT_INTERP>"

#. type: Plain text
#: man-pages/man5/elf.5:773
msgid ""
"The array element specifies the location and size of a null-terminated "
"pathname to invoke as an interpreter.  This segment type is meaningful only "
"for executable files (though it may occur for shared objects).  However it "
"may not occur more than once in a file.  If it is present, it must precede "
"any loadable segment entry."
msgstr ""
"Элемент массива указывает на данные о расположении и размере пути "
"(завершается null) вызываемого интерпретатора. Этот тип сегмента имеет смысл "
"только для исполняемых файлов (хотя может быть и в динамических объектных "
"файлах). Однако, в файле он не может указываться более одного раза. Если он "
"задан, то должен находиться перед всеми элементами загружаемых сегментов."

#. type: TP
#: man-pages/man5/elf.5:773
#, no-wrap
msgid "B<PT_NOTE>"
msgstr "B<PT_NOTE>"

#. type: Plain text
#: man-pages/man5/elf.5:776
msgid ""
"The array element specifies the location and size for auxiliary information."
msgstr ""
"Элемент массива указывает на расположение и размер вспомогательной информации."

#. type: TP
#: man-pages/man5/elf.5:776
#, no-wrap
msgid "B<PT_SHLIB>"
msgstr "B<PT_SHLIB>"

#. type: Plain text
#: man-pages/man5/elf.5:781
msgid ""
"This segment type is reserved but has unspecified semantics.  Programs that "
"contain an array element of this type do not conform to the ABI."
msgstr ""
"Данный тип сегмента зарезервирован, но имеет неопределённую семантику. "
"Программы, в которых есть элемент массива такого типа, не соответствуют ABI."

#. type: TP
#: man-pages/man5/elf.5:781
#, no-wrap
msgid "B<PT_PHDR>"
msgstr "B<PT_PHDR>"

#. type: Plain text
#: man-pages/man5/elf.5:790
msgid ""
"The array element, if present, specifies the location and size of the "
"program header table itself, both in the file and in the memory image of the"
" program.  This segment type may not occur more than once in a file.  "
"Moreover, it may occur only if the program header table is part of the "
"memory image of the program.  If it is present, it must precede any loadable"
" segment entry."
msgstr ""
"Элемент массива, если есть, указывает на расположение и размер самой таблицы "
"заголовков программы, и в файле и в образе программы в памяти. Данный тип "
"сегмента не может встречаться в файле более одного раза. Кроме того, он может "
"задаваться только если таблица заголовков программы является частью образа "
"программы в памяти. Если он задан, то должен находиться до элементов "
"загружаемых сегментов."

#. type: TP
#: man-pages/man5/elf.5:790
#, no-wrap
msgid "B<PT_LOPROC>"
msgstr "B<PT_LOPROC>"

#. type: Plain text
#: man-pages/man5/elf.5:795
msgid ""
"Values greater than or equal to B<PT_HIPROC> are reserved for processor-"
"specific semantics."
msgstr ""
"Значения, больше данного или равные B<PT_HIPROC>, зарезервированы для "
"процессорно-ориентированной семантики."

#. type: TP
#: man-pages/man5/elf.5:795
#, no-wrap
msgid "B<PT_HIPROC>"
msgstr "B<PT_HIPROC>"

#. type: Plain text
#: man-pages/man5/elf.5:800
msgid ""
"Values less than or equal to B<PT_LOPROC> are reserved for processor-"
"specific semantics."
msgstr ""
"Значения меньше данного или равные B<PT_LOPROC> зарезервированы для "
"процессорно-ориентированной семантики."

#. type: TP
#: man-pages/man5/elf.5:800
#, no-wrap
msgid "B<PT_GNU_STACK>"
msgstr "B<PT_GNU_STACK>"

#.  .El
#. type: Plain text
#: man-pages/man5/elf.5:807
msgid ""
"GNU extension which is used by the Linux kernel to control the state of the "
"stack via the flags set in the I<p_flags> member."
msgstr ""
"Расширение GNU, используемое ядром Linux для управления состоянием стека "
"через флаги, настраивается в поле I<p_flags>."

#. type: TP
#: man-pages/man5/elf.5:808
#, no-wrap
msgid "I<p_offset>"
msgstr "I<p_offset>"

#. type: Plain text
#: man-pages/man5/elf.5:812
msgid ""
"This member holds the offset from the beginning of the file at which the "
"first byte of the segment resides."
msgstr ""
"Это поле содержит смещение от начала файла, по которому располагается первый "
"байт сегмента."

#. type: TP
#: man-pages/man5/elf.5:812
#, no-wrap
msgid "I<p_vaddr>"
msgstr "I<p_vaddr>"

#. type: Plain text
#: man-pages/man5/elf.5:816
msgid ""
"This member holds the virtual address at which the first byte of the segment"
" resides in memory."
msgstr ""
"Это поле содержит виртуальный адрес, по которому располагается первый байт "
"сегмента в памяти."

#. type: TP
#: man-pages/man5/elf.5:816
#, no-wrap
msgid "I<p_paddr>"
msgstr "I<p_paddr>"

#. type: Plain text
#: man-pages/man5/elf.5:824
msgid ""
"On systems for which physical addressing is relevant, this member is "
"reserved for the segment's physical address.  Under BSD this member is not "
"used and must be zero."
msgstr ""
"В системах, для которых важна физическая адресация, это поле зарезервировано "
"для физического адреса сегмента. В BSD это поле не используется и должно быть "
"равно нулю."

#. type: TP
#: man-pages/man5/elf.5:824
#, no-wrap
msgid "I<p_filesz>"
msgstr "I<p_filesz>"

#. type: Plain text
#: man-pages/man5/elf.5:828
msgid ""
"This member holds the number of bytes in the file image of the segment.  It "
"may be zero."
msgstr ""
"В этом поле содержится число байт занимаемое сегментом в файле. Оно может "
"быть равно нулю."

#. type: TP
#: man-pages/man5/elf.5:828
#, no-wrap
msgid "I<p_memsz>"
msgstr "I<p_memsz>"

#. type: Plain text
#: man-pages/man5/elf.5:832
msgid ""
"This member holds the number of bytes in the memory image of the segment.  "
"It may be zero."
msgstr ""
"В этом поле содержится число байт занимаемое сегментом в памяти. Оно может "
"быть равно нулю."

#. type: TP
#: man-pages/man5/elf.5:832
#, no-wrap
msgid "I<p_flags>"
msgstr "I<p_flags>"

#.  .Bl -tag -width "PF_X" -compact
#. type: Plain text
#: man-pages/man5/elf.5:836
msgid "This member holds a bit mask of flags relevant to the segment:"
msgstr "В этом поле содержится битовая маска флагов соответствующего сегмента:"

#. type: TP
#: man-pages/man5/elf.5:837
#, no-wrap
msgid "B<PF_X>"
msgstr "B<PF_X>"

#. type: Plain text
#: man-pages/man5/elf.5:841
msgid "An executable segment."
msgstr "Исполняемый сегмент."

#. type: TP
#: man-pages/man5/elf.5:841
#, no-wrap
msgid "B<PF_W>"
msgstr "B<PF_W>"

#. type: Plain text
#: man-pages/man5/elf.5:844
msgid "A writable segment."
msgstr "Сегмент доступен для записи."

#. type: TP
#: man-pages/man5/elf.5:844
#, no-wrap
msgid "B<PF_R>"
msgstr "B<PF_R>"

#. type: Plain text
#: man-pages/man5/elf.5:847
msgid "A readable segment."
msgstr "Сегмент доступен для чтения."

#. type: Plain text
#: man-pages/man5/elf.5:860
msgid ""
"A text segment commonly has the flags B<PF_X> and B<PF_R>.  A data segment "
"commonly has B<PF_X>, B<PF_W> and B<PF_R>."
msgstr ""
"Сегмента кода (text segment) обычно имеет флаги B<PF_X> и B<PF_R>. Сегмент "
"данных обычно имеет флаги B<PF_X>, B<PF_W> и B<PF_R>."

#. type: TP
#: man-pages/man5/elf.5:860
#, no-wrap
msgid "I<p_align>"
msgstr "I<p_align>"

#.  .El
#. type: Plain text
#: man-pages/man5/elf.5:879
msgid ""
"This member holds the value to which the segments are aligned in memory and "
"in the file.  Loadable process segments must have congruent values for "
"I<p_vaddr> and I<p_offset>, modulo the page size.  Values of zero and one "
"mean no alignment is required.  Otherwise, I<p_align> should be a positive, "
"integral power of two, and I<p_vaddr> should equal I<p_offset>, modulo "
"I<p_align>."
msgstr ""
"В этом поле содержится значение согласно которому сегменты выровнены в памяти "
"и в файле. У загружаемых сегментов процесса значения I<p_vaddr> и I<p_offset> "
"должны быть кратны размеру страницы. Величины ноль и один означают, что "
"выравнивание не требуется. В противном случае значение I<p_align> должно быть "
"положительным числом кратным степени двойки, а значение I<p_vaddr> должно "
"быть равно I<p_offset> и кратным I<p_align>."

#. type: Plain text
#: man-pages/man5/elf.5:896
msgid ""
"A file's section header table lets one locate all the file's sections.  The "
"section header table is an array of I<Elf32_Shdr> or I<Elf64_Shdr> "
"structures.  The ELF header's I<e_shoff> member gives the byte offset from "
"the beginning of the file to the section header table.  I<e_shnum> holds the"
" number of entries the section header table contains.  I<e_shentsize> holds "
"the size in bytes of each entry."
msgstr ""
"По таблице заголовков разделов можно найти расположение всех разделов в "
"файле. Она представляет собой массив структур I<Elf32_Shdr> или I<Elf64_Shdr>"
". На начало таблицы заголовков разделов в файле указывает поле I<e_shoff> "
"заголовка ELF (в байтах). В I<e_shnum> содержится количество элементов "
"таблицы заголовков разделов. В I<e_shentsize> содержится размер каждого "
"элемента в байтах."

#.  .Bl -tag -width "SHN_LORESERVE"
#. type: Plain text
#: man-pages/man5/elf.5:913
msgid ""
"A section header table index is a subscript into this array.  Some section "
"header table indices are reserved: the initial entry and the indices between"
" B<SHN_LORESERVE> and B<SHN_HIRESERVE>.  The initial entry is used in ELF "
"extensions for I<e_phnum>, I<e_shnum> and I<e_strndx>; in other cases, each "
"field in the initial entry is set to zero.  An object file does not have "
"sections for these special indices:"
msgstr ""
"Индекс элемента в таблице заголовков разделов указывает в этот массив. "
"Некоторые индексы элемента в таблице заголовков разделов зарезервированы: "
"начальный элемент и индексы от B<SHN_LORESERVE> и до B<SHN_HIRESERVE>. "
"Начальный элемент используется в расширениях ELF для I<e_phnum>, I<e_shnum> "
"and I<e_strndx>; в других случаях, каждое поле начального элемента равно "
"нулю. В объектном файле нет разделов с этими специальными индексами:"

#. type: Plain text
#: man-pages/man5/elf.5:918
msgid ""
"This value marks an undefined, missing, irrelevant, or otherwise meaningless"
" section reference."
msgstr ""
"Этим значением помечается неопределённая, отсутствующая, неприменимая, или "
"другая нецелесообразная ссылка на раздел."

#. type: Plain text
#: man-pages/man5/elf.5:938
msgid ""
"This value specifies the absolute value for the corresponding reference.  "
"For example, a symbol defined relative to section number B<SHN_ABS> has an "
"absolute value and is not affected by relocation."
msgstr ""
"Это значение указывает на абсолютное значение соответствующей ссылки. "
"Например, символы, определённые относительно раздела с номером B<SHN_ABS>, "
"имеют абсолютные значения и не подвержены перемещению."

#. type: Plain text
#: man-pages/man5/elf.5:942
msgid ""
"Symbols defined relative to this section are common symbols, such as FORTRAN"
" COMMON or unallocated C external variables."
msgstr ""
"Символы, определённые относительно такого раздела, являются общими символами, "
"такими как Fortran COMMON или нераспределённые внешние переменные C."

#. type: Plain text
#: man-pages/man5/elf.5:953
msgid ""
"This value specifies the upper bound of the range of reserved indices.  The "
"system reserves indices between B<SHN_LORESERVE> and B<SHN_HIRESERVE>, "
"inclusive.  The section header table does not contain entries for the "
"reserved indices."
msgstr ""
"Этим значением определяется верхняя граница диапазона зарезервированных "
"индексов. В системе зарезервированы индексы между B<SHN_LORESERVE> и B<"
"SHN_HIRESERVE> включительно. В таблице заголовков разделов нет элементов с "
"зарезервированными индексами."

#. type: Plain text
#: man-pages/man5/elf.5:957
msgid "The section header has the following structure:"
msgstr "Заголовок раздела имеет следующую структуру:"

#. type: Plain text
#: man-pages/man5/elf.5:972
#, no-wrap
msgid ""
"typedef struct {\n"
"    uint32_t   sh_name;\n"
"    uint32_t   sh_type;\n"
"    uint32_t   sh_flags;\n"
"    Elf32_Addr sh_addr;\n"
"    Elf32_Off  sh_offset;\n"
"    uint32_t   sh_size;\n"
"    uint32_t   sh_link;\n"
"    uint32_t   sh_info;\n"
"    uint32_t   sh_addralign;\n"
"    uint32_t   sh_entsize;\n"
"} Elf32_Shdr;\n"
msgstr ""
"typedef struct {\n    uint32_t   sh_name;\n    uint32_t   sh_type;\n    "
"uint32_t   sh_flags;\n    Elf32_Addr sh_addr;\n    Elf32_Off  sh_offset;\n    "
"uint32_t   sh_size;\n    uint32_t   sh_link;\n    uint32_t   sh_info;\n    "
"uint32_t   sh_addralign;\n    uint32_t   sh_entsize;\n} Elf32_Shdr;\n"

#. type: Plain text
#: man-pages/man5/elf.5:989
#, no-wrap
msgid ""
"typedef struct {\n"
"    uint32_t   sh_name;\n"
"    uint32_t   sh_type;\n"
"    uint64_t   sh_flags;\n"
"    Elf64_Addr sh_addr;\n"
"    Elf64_Off  sh_offset;\n"
"    uint64_t   sh_size;\n"
"    uint32_t   sh_link;\n"
"    uint32_t   sh_info;\n"
"    uint64_t   sh_addralign;\n"
"    uint64_t   sh_entsize;\n"
"} Elf64_Shdr;\n"
msgstr ""
"typedef struct {\n    uint32_t   sh_name;\n    uint32_t   sh_type;\n    "
"uint64_t   sh_flags;\n    Elf64_Addr sh_addr;\n    Elf64_Off  sh_offset;\n    "
"uint64_t   sh_size;\n    uint32_t   sh_link;\n    uint32_t   sh_info;\n    "
"uint64_t   sh_addralign;\n    uint64_t   sh_entsize;\n} Elf64_Shdr;\n"

#.  .Bl -tag -width "sh_addralign"
#. type: Plain text
#: man-pages/man5/elf.5:994
msgid ""
"No real differences exist between the 32-bit and 64-bit section headers."
msgstr ""
"Существенной разницы между 32-битными и 64-битными заголовками разделов нет."

#. type: TP
#: man-pages/man5/elf.5:994
#, no-wrap
msgid "I<sh_name>"
msgstr "I<sh_name>"

#. type: Plain text
#: man-pages/man5/elf.5:1000
msgid ""
"This member specifies the name of the section.  Its value is an index into "
"the section header string table section, giving the location of a null-"
"terminated string."
msgstr ""
"В этом поле указывается название раздела. Его значением является индекс в "
"строковой таблице заголовков разделов, дающий расположение строки, "
"заканчивающейся null."

#. type: TP
#: man-pages/man5/elf.5:1000
#, no-wrap
msgid "I<sh_type>"
msgstr "I<sh_type>"

#.  .Bl -tag -width "SHT_PROGBITS"
#. type: Plain text
#: man-pages/man5/elf.5:1004
msgid "This member categorizes the section's contents and semantics."
msgstr "В этом поле содержится тип содержимого раздела, определящий смысл."

#. type: TP
#: man-pages/man5/elf.5:1005
#, no-wrap
msgid "B<SHT_NULL>"
msgstr "B<SHT_NULL>"

#. type: Plain text
#: man-pages/man5/elf.5:1012
msgid ""
"This value marks the section header as inactive.  It does not have an "
"associated section.  Other members of the section header have undefined "
"values."
msgstr ""
"Этим значением помечают неактивные разделы в заголовке. У такого элемента "
"нетпривязанного раздела. Значения других полей заголовка раздела не "
"определены."

#. type: TP
#: man-pages/man5/elf.5:1012
#, no-wrap
msgid "B<SHT_PROGBITS>"
msgstr "B<SHT_PROGBITS>"

#. type: Plain text
#: man-pages/man5/elf.5:1016
msgid ""
"This section holds information defined by the program, whose format and "
"meaning are determined solely by the program."
msgstr ""
"Этот раздел содержит информацию, задаваемую программой; её формат и смысл "
"полностью определяется программой."

#. type: TP
#: man-pages/man5/elf.5:1016
#, no-wrap
msgid "B<SHT_SYMTAB>"
msgstr "B<SHT_SYMTAB>"

#. type: Plain text
#: man-pages/man5/elf.5:1029
msgid ""
"This section holds a symbol table.  Typically, B<SHT_SYMTAB> provides "
"symbols for link editing, though it may also be used for dynamic linking.  "
"As a complete symbol table, it may contain many symbols unnecessary for "
"dynamic linking.  An object file can also contain a B<SHT_DYNSYM> section."
msgstr ""
"В этом разделе содержится таблица символов. Обычно, раздел B<SHT_SYMTAB> "
"предоставляет символы для редактирования связей, хотя также может "
"использоваться при динамической компоновке. Являясь полной таблицей символов "
"может содержать символы, не требуемые для динамической компоновки. Объектный "
"файл также может содержать раздел B<SHT_DYNSYM>."

#. type: TP
#: man-pages/man5/elf.5:1029
#, no-wrap
msgid "B<SHT_STRTAB>"
msgstr "B<SHT_STRTAB>"

#. type: Plain text
#: man-pages/man5/elf.5:1034
msgid ""
"This section holds a string table.  An object file may have multiple string "
"table sections."
msgstr ""
"В этом разделе содержится таблица строк. В объектном файле может быть "
"несколько разделов с таблицами строк."

#. type: TP
#: man-pages/man5/elf.5:1034
#, no-wrap
msgid "B<SHT_RELA>"
msgstr "B<SHT_RELA>"

#. type: Plain text
#: man-pages/man5/elf.5:1042
msgid ""
"This section holds relocation entries with explicit addends, such as type "
"I<Elf32_Rela> for the 32-bit class of object files.  An object may have "
"multiple relocation sections."
msgstr ""
"В этом разделе содержатся элементы перемещения с явными добавками, такими как "
"тип I<Elf32_Rela> для 32-битного класса объектных файлов. Объектный файл "
"может иметь несколько разделов перемещений."

#. type: TP
#: man-pages/man5/elf.5:1042
#, no-wrap
msgid "B<SHT_HASH>"
msgstr "B<SHT_HASH>"

#. type: Plain text
#: man-pages/man5/elf.5:1049
msgid ""
"This section holds a symbol hash table.  An object participating in dynamic "
"linking must contain a symbol hash table.  An object file may have only one "
"hash table."
msgstr ""
"В этом разделе содержится хэш-таблица символов. Объект, участвующий в "
"динамической компоновке, должен иметь хэш-таблицу символов. В объектном файле "
"должна быть только одна хэш-таблица."

#. type: TP
#: man-pages/man5/elf.5:1049
#, no-wrap
msgid "B<SHT_DYNAMIC>"
msgstr "B<SHT_DYNAMIC>"

#. type: Plain text
#: man-pages/man5/elf.5:1054
msgid ""
"This section holds information for dynamic linking.  An object file may have"
" only one dynamic section."
msgstr ""
"В этом разделе содержится информация по динамической компоновке. В объектном "
"файле должен быть только один динамический раздел."

#. type: TP
#: man-pages/man5/elf.5:1054
#, no-wrap
msgid "B<SHT_NOTE>"
msgstr "B<SHT_NOTE>"

#. type: Plain text
#: man-pages/man5/elf.5:1057
msgid "This section holds information that marks the file in some way."
msgstr ""
"В этом разделе содержится информация, которая позволяет как-то описать данный "
"файл."

#. type: TP
#: man-pages/man5/elf.5:1057
#, no-wrap
msgid "B<SHT_NOBITS>"
msgstr "B<SHT_NOBITS>"

#. type: Plain text
#: man-pages/man5/elf.5:1065
msgid ""
"A section of this type occupies no space in the file but otherwise resembles"
" B<SHT_PROGBITS>.  Although this section contains no bytes, the I<sh_offset>"
" member contains the conceptual file offset."
msgstr ""
"Разделы этого типа не занимают пространства в файле, но слегка напоминают B<"
"SHT_PROGBITS>. Несмотря на то, что байт в нём нет, поле I<sh_offset> содержит "
"умозрительное файловое смещение."

#. type: TP
#: man-pages/man5/elf.5:1065
#, no-wrap
msgid "B<SHT_REL>"
msgstr "B<SHT_REL>"

#. type: Plain text
#: man-pages/man5/elf.5:1073
msgid ""
"This section holds relocation offsets without explicit addends, such as type"
" I<Elf32_Rel> for the 32-bit class of object files.  An object file may have"
" multiple relocation sections."
msgstr ""
"В этом разделе содержатся элементы перемещения без явных добавок, таких как "
"тип I<Elf32_Rela> для 32-битного класса объектных файлов. Объектный файл "
"может иметь несколько разделов перемещений."

#. type: TP
#: man-pages/man5/elf.5:1073
#, no-wrap
msgid "B<SHT_SHLIB>"
msgstr "B<SHT_SHLIB>"

#. type: Plain text
#: man-pages/man5/elf.5:1076
msgid "This section is reserved but has unspecified semantics."
msgstr "Данный тип сегмента зарезервирован, но имеет неопределённую семантику."

#. type: TP
#: man-pages/man5/elf.5:1076
#, no-wrap
msgid "B<SHT_DYNSYM>"
msgstr "B<SHT_DYNSYM>"

#. type: Plain text
#: man-pages/man5/elf.5:1083
msgid ""
"This section holds a minimal set of dynamic linking symbols.  An object file"
" can also contain a B<SHT_SYMTAB> section."
msgstr ""
"В этом разделе содержится минимальный набор символов для динамической "
"компоновки. В объектном файле также может быть раздел B<SHT_SYMTAB>."

#. type: TP
#: man-pages/man5/elf.5:1083
#, no-wrap
msgid "B<SHT_LOPROC>"
msgstr "B<SHT_LOPROC>"

#. type: Plain text
#: man-pages/man5/elf.5:1088
msgid ""
"This value up to and including B<SHT_HIPROC> is reserved for processor-"
"specific semantics."
msgstr ""
"Все значения, начиная с этого и больше, по B<SHT_HIPROC> включительно, "
"зарезервированы для процессорно-ориентированной семантики."

#. type: TP
#: man-pages/man5/elf.5:1088
#, no-wrap
msgid "B<SHT_HIPROC>"
msgstr "B<SHT_HIPROC>"

#. type: Plain text
#: man-pages/man5/elf.5:1093
msgid ""
"This value down to and including B<SHT_LOPROC> is reserved for processor-"
"specific semantics."
msgstr ""
"Все значения, начиная с этого и меньше, по B<SHT_LOPROC> включительно, "
"зарезервированы для процессорно-ориентированной семантики."

#. type: TP
#: man-pages/man5/elf.5:1093
#, no-wrap
msgid "B<SHT_LOUSER>"
msgstr "B<SHT_LOUSER>"

#. type: Plain text
#: man-pages/man5/elf.5:1097
msgid ""
"This value specifies the lower bound of the range of indices reserved for "
"application programs."
msgstr ""
"Это значение указывает на нижнюю границу диапазона индексов, "
"зарезервированного для пользовательских программ."

#. type: TP
#: man-pages/man5/elf.5:1097
#, no-wrap
msgid "B<SHT_HIUSER>"
msgstr "B<SHT_HIUSER>"

#.  .El
#. type: Plain text
#: man-pages/man5/elf.5:1108
msgid ""
"This value specifies the upper bound of the range of indices reserved for "
"application programs.  Section types between B<SHT_LOUSER> and B<SHT_HIUSER>"
" may be used by the application, without conflicting with current or future "
"system-defined section types."
msgstr ""
"Это значение указывает на нижнюю границу диапазона индексов, "
"зарезервированного для пользовательских программ. Разделы с типами, имеющими "
"значение между B<SHT_LOUSER> и B<SHT_HIUSER>, могут использоваться "
"приложениями не конфликтуя с имеющимися или будущими типами разделов, "
"определяемых системой."

#. type: TP
#: man-pages/man5/elf.5:1109
#, no-wrap
msgid "I<sh_flags>"
msgstr "I<sh_flags>"

#.  .Bl -tag -width "SHF_EXECINSTR" -compact
#. type: Plain text
#: man-pages/man5/elf.5:1122
msgid ""
"Sections support one-bit flags that describe miscellaneous attributes.  If a"
" flag bit is set in I<sh_flags>, the attribute is \"on\" for the section.  "
"Otherwise, the attribute is \"off\" or does not apply.  Undefined attributes"
" are set to zero."
msgstr ""
"В этом поле указываются различные атрибуты раздела, задаваемые в виде "
"однобитных флагов. Если бит флага установлен в I<sh_flags>, то атрибут "
"\"активен\" для раздела. Иначе атрибут \"выключен\" или не применяется. Не "
"указанные атрибуты сбрасываются в ноль."

#. type: TP
#: man-pages/man5/elf.5:1123
#, no-wrap
msgid "B<SHF_WRITE>"
msgstr "B<SHF_WRITE>"

#. type: Plain text
#: man-pages/man5/elf.5:1127
msgid ""
"This section contains data that should be writable during process execution."
msgstr ""
"В разделе содержатся данные, к которым при работе процесса нужен доступ на "
"запись."

#. type: TP
#: man-pages/man5/elf.5:1127
#, no-wrap
msgid "B<SHF_ALLOC>"
msgstr "B<SHF_ALLOC>"

#. type: Plain text
#: man-pages/man5/elf.5:1134
msgid ""
"This section occupies memory during process execution.  Some control "
"sections do not reside in the memory image of an object file.  This "
"attribute is off for those sections."
msgstr ""
"Этот раздел занимает память при работе процесса. Некоторые управляющие "
"разделы не располагаются в образе памяти объектного файла. Этот атрибут "
"выключен у таких разделов."

#. type: TP
#: man-pages/man5/elf.5:1134
#, no-wrap
msgid "B<SHF_EXECINSTR>"
msgstr "B<SHF_EXECINSTR>"

#. type: Plain text
#: man-pages/man5/elf.5:1137
msgid "This section contains executable machine instructions."
msgstr "Этот раздел содержит исполняемые машинные инструкции."

#. type: TP
#: man-pages/man5/elf.5:1137
#, no-wrap
msgid "B<SHF_MASKPROC>"
msgstr "B<SHF_MASKPROC>"

#. type: Plain text
#: man-pages/man5/elf.5:1141
msgid ""
"All bits included in this mask are reserved for processor-specific "
"semantics."
msgstr ""
"Все биты этой маски зарезервированы для процессорно-ориентированной семантики."

#. type: TP
#: man-pages/man5/elf.5:1143
#, no-wrap
msgid "I<sh_addr>"
msgstr "I<sh_addr>"

#. type: Plain text
#: man-pages/man5/elf.5:1148
msgid ""
"If this section appears in the memory image of a process, this member holds "
"the address at which the section's first byte should reside.  Otherwise, the"
" member contains zero."
msgstr ""
"Если этот раздел появляется в образе памяти процесса, то это поле содержит "
"адрес, по которому должен располагаться первый байт раздела. Иначе поле "
"содержит ноль."

#. type: TP
#: man-pages/man5/elf.5:1148
#, no-wrap
msgid "I<sh_offset>"
msgstr "I<sh_offset>"

#. type: Plain text
#: man-pages/man5/elf.5:1157
msgid ""
"This member's value holds the byte offset from the beginning of the file to "
"the first byte in the section.  One section type, B<SHT_NOBITS>, occupies no"
" space in the file, and its I<sh_offset> member locates the conceptual "
"placement in the file."
msgstr ""
"В этом поле содержится смещение в байтах от начала файла до первого байта "
"раздела. Раздел типа B<SHT_NOBITS> не занимает места в файле и его поле I<"
"sh_offset> содержит умозрительное размещение в файле."

#. type: TP
#: man-pages/man5/elf.5:1157
#, no-wrap
msgid "I<sh_size>"
msgstr "I<sh_size>"

#. type: Plain text
#: man-pages/man5/elf.5:1169
msgid ""
"This member holds the section's size in bytes.  Unless the section type is "
"B<SHT_NOBITS>, the section occupies I<sh_size> bytes in the file.  A section"
" of type B<SHT_NOBITS> may have a nonzero size, but it occupies no space in "
"the file."
msgstr ""
"В этом поле содержится размер раздела в байтах. За исключением раздела с "
"типом B<SHT_NOBITS>, все разделы занимают I<sh_size> байт в файле. Раздел с "
"типом B<SHT_NOBITS> может иметь ненулевой размер, но места в файле не "
"занимает."

#. type: TP
#: man-pages/man5/elf.5:1169
#, no-wrap
msgid "I<sh_link>"
msgstr "I<sh_link>"

#. type: Plain text
#: man-pages/man5/elf.5:1173
msgid ""
"This member holds a section header table index link, whose interpretation "
"depends on the section type."
msgstr ""
"В этом поле содержится ссылка-индекс в таблицу заголовков раздела, а "
"интерпретация зависит от типа раздела."

#. type: TP
#: man-pages/man5/elf.5:1173
#, no-wrap
msgid "I<sh_info>"
msgstr "I<sh_info>"

#. type: Plain text
#: man-pages/man5/elf.5:1177
msgid ""
"This member holds extra information, whose interpretation depends on the "
"section type."
msgstr ""
"В этом поле содержится дополнительная информация, чья интерпретация зависит "
"от типа раздела."

#. type: TP
#: man-pages/man5/elf.5:1177
#, no-wrap
msgid "I<sh_addralign>"
msgstr "I<sh_addralign>"

#. type: Plain text
#: man-pages/man5/elf.5:1190
msgid ""
"Some sections have address alignment constraints.  If a section holds a "
"doubleword, the system must ensure doubleword alignment for the entire "
"section.  That is, the value of I<sh_addr> must be congruent to zero, modulo"
" the value of I<sh_addralign>.  Only zero and positive integral powers of "
"two are allowed.  Values of zero or one mean the section has no alignment "
"constraints."
msgstr ""
"Некоторые разделы имеют ограничения по выравниванию адресов. Если раздел "
"содержит двойное слово, то система должна произвести выравнивание по двойному "
"слову всего раздела. То есть, значение I<sh_addr> должно быть таким, чтобы "
"при делении по модулю I<sh_addralign> получался ноль. Разрешены только ноль и "
"положительные степени двойки. Величины ноль или один означают, что раздел не "
"имеет ограничений по выравниванию."

#. type: TP
#: man-pages/man5/elf.5:1190
#, no-wrap
msgid "I<sh_entsize>"
msgstr "I<sh_entsize>"

#.  .El
#. type: Plain text
#: man-pages/man5/elf.5:1197
msgid ""
"Some sections hold a table of fixed-sized entries, such as a symbol table.  "
"For such a section, this member gives the size in bytes for each entry.  "
"This member contains zero if the section does not hold a table of fixed-size"
" entries."
msgstr ""
"В некоторых разделах содержатся таблицы с элементами одинакового размера, "
"например, таблица символов. Для таких разделов в данном поле указывается "
"размер в байтах каждого элемента. Если раздел содержит таблицу с элементами "
"разного размера, то это поле равно нулю."

#.  .Bl -tag -width ".shstrtab"
#. type: Plain text
#: man-pages/man5/elf.5:1200
msgid "Various sections hold program and control information:"
msgstr "Программа и управляющая информация содержится в различных разделах:"

#. type: TP
#: man-pages/man5/elf.5:1200
#, no-wrap
msgid "I<.bss>"
msgstr "I<.bss>"

#. type: Plain text
#: man-pages/man5/elf.5:1212
msgid ""
"This section holds uninitialized data that contributes to the program's "
"memory image.  By definition, the system initializes the data with zeros "
"when the program begins to run.  This section is of type B<SHT_NOBITS>.  The"
" attribute types are B<SHF_ALLOC> and B<SHF_WRITE>."
msgstr ""
"В этом разделе содержатся неинициализированные данные, которые вносятся в "
"образ программы в памяти. По определению, в начале выполнения программы "
"система инициализирует эти данные нулями. Этот раздел имеет тип B<SHT_NOBITS> "
"и атрибуты B<SHF_ALLOC> и B<SHF_WRITE>."

#. type: TP
#: man-pages/man5/elf.5:1212
#, no-wrap
msgid "I<.comment>"
msgstr "I<.comment>"

#. type: Plain text
#: man-pages/man5/elf.5:1218
msgid ""
"This section holds version control information.  This section is of type "
"B<SHT_PROGBITS>.  No attribute types are used."
msgstr ""
"В этом разделе содержится управляющая информация о версии. Он имеет тип B<"
"SHT_PROGBITS> и не имеет атрибутов."

#. type: TP
#: man-pages/man5/elf.5:1218
#, no-wrap
msgid "I<.ctors>"
msgstr "I<.ctors>"

#. type: Plain text
#: man-pages/man5/elf.5:1227
msgid ""
"This section holds initialized pointers to the C++ constructor functions.  "
"This section is of type B<SHT_PROGBITS>.  The attribute types are "
"B<SHF_ALLOC> and B<SHF_WRITE>."
msgstr ""
"В этом разделе содержатся инициализированные указатели функций-конструкторов "
"C++. Он имеет тип B<SHT_PROGBITS> и атрибуты B<SHF_ALLOC> и B<SHF_WRITE>."

#. type: TP
#: man-pages/man5/elf.5:1227
#, no-wrap
msgid "I<.data>"
msgstr "I<.data>"

#. type: Plain text
#: man-pages/man5/elf.5:1237 man-pages/man5/elf.5:1247
msgid ""
"This section holds initialized data that contribute to the program's memory "
"image.  This section is of type B<SHT_PROGBITS>.  The attribute types are "
"B<SHF_ALLOC> and B<SHF_WRITE>."
msgstr ""
"В этом разделе содержатся инициализированные данные, которые вносятся в образ "
"программы в памяти. Он имеет тип B<SHT_PROGBITS> и атрибуты B<SHF_ALLOC> и B<"
"SHF_WRITE>."

#. type: TP
#: man-pages/man5/elf.5:1237
#, no-wrap
msgid "I<.data1>"
msgstr "I<.data1>"

#. type: TP
#: man-pages/man5/elf.5:1247
#, no-wrap
msgid "I<.debug>"
msgstr "I<.debug>"

#. type: Plain text
#: man-pages/man5/elf.5:1255
msgid ""
"This section holds information for symbolic debugging.  The contents are "
"unspecified.  This section is of type B<SHT_PROGBITS>.  No attribute types "
"are used."
msgstr ""
"В этом разделе содержится информация для символьной отладки. Формат "
"содержимого не определён. Этот раздел имеет тип B<SHT_PROGBITS> и не имеет "
"атрибутов."

#. type: TP
#: man-pages/man5/elf.5:1255
#, no-wrap
msgid "I<.dtors>"
msgstr "I<.dtors>"

#. type: Plain text
#: man-pages/man5/elf.5:1264
msgid ""
"This section holds initialized pointers to the C++ destructor functions.  "
"This section is of type B<SHT_PROGBITS>.  The attribute types are "
"B<SHF_ALLOC> and B<SHF_WRITE>."
msgstr ""
"В этом разделе содержатся инициализированные указатели функций-деструкторов "
"C++. Он имеет тип B<SHT_PROGBITS> и атрибуты B<SHF_ALLOC> и B<SHF_WRITE>."

#. type: TP
#: man-pages/man5/elf.5:1264
#, no-wrap
msgid "I<.dynamic>"
msgstr "I<.dynamic>"

#. type: Plain text
#: man-pages/man5/elf.5:1277
msgid ""
"This section holds dynamic linking information.  The section's attributes "
"will include the B<SHF_ALLOC> bit.  Whether the B<SHF_WRITE> bit is set is "
"processor-specific.  This section is of type B<SHT_DYNAMIC>.  See the "
"attributes above."
msgstr ""
"В этом разделе содержится информация о динамической компоновке. К атрибутам "
"раздела будет добавлен бит B<SHF_ALLOC>. В зависимости от процессора может "
"быть установлен бит B<SHF_WRITE>. Этот раздел имеет тип B<SHT_DYNAMIC>."

#. type: TP
#: man-pages/man5/elf.5:1277
#, no-wrap
msgid "I<.dynstr>"
msgstr "I<.dynstr>"

#. type: Plain text
#: man-pages/man5/elf.5:1285
msgid ""
"This section holds strings needed for dynamic linking, most commonly the "
"strings that represent the names associated with symbol table entries.  This"
" section is of type B<SHT_STRTAB>.  The attribute type used is B<SHF_ALLOC>."
msgstr ""
"В этом разделе содержатся строки, необходимые для динамической компоновки; "
"чаще всего это строки, представляющие имена, связанные с элементами таблицы "
"символов. Этот раздел имеет тип B<SHT_STRTAB> и атрибут B<SHF_ALLOC>."

#. type: TP
#: man-pages/man5/elf.5:1285
#, no-wrap
msgid "I<.dynsym>"
msgstr "I<.dynsym>"

#. type: Plain text
#: man-pages/man5/elf.5:1292
msgid ""
"This section holds the dynamic linking symbol table.  This section is of "
"type B<SHT_DYNSYM>.  The attribute used is B<SHF_ALLOC>."
msgstr ""
"В этом разделе содержится таблица символов для динамической компоновки. Этот "
"раздел имеет тип B<SHT_DYNSYM> и атрибут B<SHF_ALLOC>."

#. type: TP
#: man-pages/man5/elf.5:1292
#, no-wrap
msgid "I<.fini>"
msgstr "I<.fini>"

#. type: Plain text
#: man-pages/man5/elf.5:1304
msgid ""
"This section holds executable instructions that contribute to the process "
"termination code.  When a program exits normally the system arranges to "
"execute the code in this section.  This section is of type B<SHT_PROGBITS>."
"  The attributes used are B<SHF_ALLOC> and B<SHF_EXECINSTR>."
msgstr ""
"В этом разделе содержатся исполняемые инструкции, которые вносятся в код "
"завершения процесса. При нормальном завершении программы система передаёт "
"выполнение коду из этого раздела. Этот раздел имеет тип B<SHT_PROGBITS> и "
"атрибуты B<SHF_ALLOC> и B<SHF_EXECINSTR>."

#. type: TP
#: man-pages/man5/elf.5:1304
#, no-wrap
msgid "I<.gnu.version>"
msgstr "I<.gnu.version>"

#. type: Plain text
#: man-pages/man5/elf.5:1313
msgid ""
"This section holds the version symbol table, an array of I<ElfN_Half> "
"elements.  This section is of type B<SHT_GNU_versym>.  The attribute type "
"used is B<SHF_ALLOC>."
msgstr ""
"В этом разделе содержится таблица версий символов, массив элементов I<"
"ElfN_Half>. Данный раздел имеет тип B<SHT_GNU_versym> и атрибут B<SHF_ALLOC>."

#. type: TP
#: man-pages/man5/elf.5:1313
#, no-wrap
msgid "I<.gnu.version_d>"
msgstr "I<.gnu.version_d>"

#. type: Plain text
#: man-pages/man5/elf.5:1322
msgid ""
"This section holds the version symbol definitions, a table of I<ElfN_Verdef>"
" structures.  This section is of type B<SHT_GNU_verdef>.  The attribute type"
" used is B<SHF_ALLOC>."
msgstr ""
"В этом разделе содержатся определения версий символов, таблица структур I<"
"ElfN_Verdef>. Данный раздел имеет тип B<SHT_GNU_verdef> и атрибут B<SHF_ALLOC>"
"."

#. type: TP
#: man-pages/man5/elf.5:1322
#, no-wrap
msgid "I<.gnu.version_r>"
msgstr "I<.gnu.version_r>"

#. type: Plain text
#: man-pages/man5/elf.5:1332
msgid ""
"This section holds the version symbol needed elements, a table of "
"I<ElfN_Verneed> structures.  This section is of type B<SHT_GNU_versym>.  The"
" attribute type used is B<SHF_ALLOC>."
msgstr ""
"В этом разделе содержатся версии символов необходимых элементов, таблица "
"структур I<ElfN_Verneed>. Данный раздел имеет тип B<SHT_GNU_versym> и атрибут "
"B<SHF_ALLOC>."

#. type: TP
#: man-pages/man5/elf.5:1332
#, no-wrap
msgid "I<.got>"
msgstr "I<.got>"

#. type: Plain text
#: man-pages/man5/elf.5:1338
msgid ""
"This section holds the global offset table.  This section is of type "
"B<SHT_PROGBITS>.  The attributes are processor-specific."
msgstr ""
"В этом разделе содержится таблица глобальных перемещений. Он имеет тип B<"
"SHT_PROGBITS>. Набор используемых атрибутов зависит от процессора."

#. type: TP
#: man-pages/man5/elf.5:1338
#, no-wrap
msgid "I<.hash>"
msgstr "I<.hash>"

#. type: Plain text
#: man-pages/man5/elf.5:1345
msgid ""
"This section holds a symbol hash table.  This section is of type "
"B<SHT_HASH>.  The attribute used is B<SHF_ALLOC>."
msgstr ""
"В этом разделе содержится хэш-таблица символов. Он имеет тип B<SHT_HASH> и "
"атрибут B<SHF_ALLOC>."

#. type: TP
#: man-pages/man5/elf.5:1345
#, no-wrap
msgid "I<.init>"
msgstr "I<.init>"

#. type: Plain text
#: man-pages/man5/elf.5:1357
msgid ""
"This section holds executable instructions that contribute to the process "
"initialization code.  When a program starts to run the system arranges to "
"execute the code in this section before calling the main program entry "
"point.  This section is of type B<SHT_PROGBITS>.  The attributes used are "
"B<SHF_ALLOC> and B<SHF_EXECINSTR>."
msgstr ""
"В этом разделе содержатся исполняемые инструкции, которые вносятся в код "
"инициализации процесса. Когда программа запускается, система передаёт "
"выполнение коду из этого раздела до вызова основной программы. Данный раздел "
"имеет тип B<SHT_PROGBITS> и атрибуты B<SHF_ALLOC> и B<SHF_EXECINSTR>."

#. type: TP
#: man-pages/man5/elf.5:1357
#, no-wrap
msgid "I<.interp>"
msgstr "I<.interp>"

#. type: Plain text
#: man-pages/man5/elf.5:1368
msgid ""
"This section holds the pathname of a program interpreter.  If the file has a"
" loadable segment that includes the section, the section's attributes will "
"include the B<SHF_ALLOC> bit.  Otherwise, that bit will be off.  This "
"section is of type B<SHT_PROGBITS>."
msgstr ""
"В этом разделе содержится путь к интерпретатору программы. Если файл имеет "
"загружаемый сегмент, который включает раздел, то в атрибуты раздела будет "
"добавлен бит B<SHF_ALLOC>. Иначе этот бит будет обнулён. Данный раздел имеет "
"тип B<SHT_PROGBITS>."

#. type: TP
#: man-pages/man5/elf.5:1368
#, no-wrap
msgid "I<.line>"
msgstr "I<.line>"

#. type: Plain text
#: man-pages/man5/elf.5:1376
msgid ""
"This section holds line number information for symbolic debugging, which "
"describes the correspondence between the program source and the machine "
"code.  The contents are unspecified.  This section is of type "
"B<SHT_PROGBITS>.  No attribute types are used."
msgstr ""
"В этом разделе содержатся информация о номерах строк для символьной отладки, "
"которая описывает соответствие между исходным кодом программы и машинным "
"кодом. Формат содержимого не определён. Данный раздел имеет тип B<"
"SHT_PROGBITS> и не имеет атрибутов."

#. type: TP
#: man-pages/man5/elf.5:1376
#, no-wrap
msgid "I<.note>"
msgstr "I<.note>"

#. type: Plain text
#: man-pages/man5/elf.5:1389
msgid ""
"This section holds information in the \"Note Section\" format.  This section"
" is of type B<SHT_NOTE>.  No attribute types are used.  OpenBSD native "
"executables usually contain a I<.note.openbsd.ident> section to identify "
"themselves, for the kernel to bypass any compatibility ELF binary emulation "
"tests when loading the file."
msgstr ""
"В этом разделе содержится информация в формате \"Note Section\". Данный "
"раздел имеет тип B<SHT_NOTE>. Типы атрибутов не используются. В \"родных\" "
"исполняемых файлах OpenBSD обычно содержится раздел I<.note.openbsd.ident> "
"для их идентификации, что используется ядром для пропуска тестирования на "
"необходимость эмуляции двоичных файлов ELF при загрузке файла."

#. type: TP
#: man-pages/man5/elf.5:1389
#, no-wrap
msgid "I<.note.GNU-stack>"
msgstr "I<.note.GNU-stack>"

#. type: Plain text
#: man-pages/man5/elf.5:1398
msgid ""
"This section is used in Linux object files for declaring stack attributes.  "
"This section is of type B<SHT_PROGBITS>.  The only attribute used is "
"B<SHF_EXECINSTR>.  This indicates to the GNU linker that the object file "
"requires an executable stack."
msgstr ""
"Этот раздел используется в объектных файлах Linux для объявления атрибутов "
"стека. Данный раздел имеет тип B<SHT_PROGBITS> и единственный атрибут B<"
"SHF_EXECINSTR>. Он указывает компоновщику GNU на необходимость объектного "
"файла иметь исполняемый стек."

#. type: TP
#: man-pages/man5/elf.5:1398
#, no-wrap
msgid "I<.plt>"
msgstr "I<.plt>"

#. type: Plain text
#: man-pages/man5/elf.5:1404
msgid ""
"This section holds the procedure linkage table.  This section is of type "
"B<SHT_PROGBITS>.  The attributes are processor-specific."
msgstr ""
"В этом разделе содержится таблица компоновки процедур. Он имеет тип B<"
"SHT_PROGBITS>. Набор используемых атрибутов зависит от процессора."

#. type: TP
#: man-pages/man5/elf.5:1404
#, no-wrap
msgid "I<.relNAME>"
msgstr "I<.relИМЯ>"

#. type: Plain text
#: man-pages/man5/elf.5:1423
msgid ""
"This section holds relocation information as described below.  If the file "
"has a loadable segment that includes relocation, the section's attributes "
"will include the B<SHF_ALLOC> bit.  Otherwise, the bit will be off.  By "
"convention, \"NAME\" is supplied by the section to which the relocations "
"apply.  Thus a relocation section for B<.text> normally would have the name "
"B<.rel.text>.  This section is of type B<SHT_REL>."
msgstr ""
"В этом разделе содержится информация о перемещениях, описываемая далее. Если "
"файл имеет загружаемый сегмент, включающий перемещение, то в атрибуты раздела "
"добавится бит B<SHF_ALLOC>. Иначе этот бит будет обнулён. По соглашению, "
"«ИМЯ» указывает на раздел, к которому применяются перемещения. То есть раздел "
"перемещений для B<.text> обычно называется B<.rel.text>. Данный раздел имеет "
"тип B<SHT_REL>."

#. type: TP
#: man-pages/man5/elf.5:1423
#, no-wrap
msgid "I<.relaNAME>"
msgstr "I<.relaNAME>"

#. type: Plain text
#: man-pages/man5/elf.5:1442
msgid ""
"This section holds relocation information as described below.  If the file "
"has a loadable segment that includes relocation, the section's attributes "
"will include the B<SHF_ALLOC> bit.  Otherwise, the bit will be off.  By "
"convention, \"NAME\" is supplied by the section to which the relocations "
"apply.  Thus a relocation section for B<.text> normally would have the name "
"B<.rela.text>.  This section is of type B<SHT_RELA>."
msgstr ""
"В этом разделе содержится информация о перемещениях, описываемая далее. Если "
"файл имеет загружаемый сегмент, включающий перемещение, то в атрибуты раздела "
"добавится бит B<SHF_ALLOC>. Иначе этот бит будет обнулён. По соглашению, "
"«ИМЯ» указывает на раздел, к которому применяются перемещения. То есть раздел "
"перемещений для B<.text> обычно называется B<.rela.text>. Данный раздел имеет "
"тип B<SHT_RELA>."

#. type: TP
#: man-pages/man5/elf.5:1442
#, no-wrap
msgid "I<.rodata>"
msgstr "I<.rodata>"

#. type: Plain text
#: man-pages/man5/elf.5:1450 man-pages/man5/elf.5:1458
msgid ""
"This section holds read-only data that typically contributes to a "
"nonwritable segment in the process image.  This section is of type "
"B<SHT_PROGBITS>.  The attribute used is B<SHF_ALLOC>."
msgstr ""
"В этом разделе содержатся данные, доступные только для чтения, которые обычно "
"вносятся в недоступный для записи сегмент образа процесса. Этот раздел имеет "
"тип B<SHT_PROGBITS> и атрибут B<SHF_ALLOC>."

#. type: TP
#: man-pages/man5/elf.5:1450
#, no-wrap
msgid "I<.rodata1>"
msgstr "I<.rodata1>"

#. type: TP
#: man-pages/man5/elf.5:1458
#, no-wrap
msgid "I<.shstrtab>"
msgstr "I<.shstrtab>"

#. type: Plain text
#: man-pages/man5/elf.5:1464
msgid ""
"This section holds section names.  This section is of type B<SHT_STRTAB>.  "
"No attribute types are used."
msgstr ""
"В этом разделе содержатся имена разделов. Он имеет тип B<SHT_STRTAB> и не "
"имеет атрибутов."

#. type: TP
#: man-pages/man5/elf.5:1464
#, no-wrap
msgid "I<.strtab>"
msgstr "I<.strtab>"

#. type: Plain text
#: man-pages/man5/elf.5:1476
msgid ""
"This section holds strings, most commonly the strings that represent the "
"names associated with symbol table entries.  If the file has a loadable "
"segment that includes the symbol string table, the section's attributes will"
" include the B<SHF_ALLOC> bit.  Otherwise, the bit will be off.  This "
"section is of type B<SHT_STRTAB>."
msgstr ""
"В этом разделе содержатся строки, чаще всего представляющие имена, связанные "
"с элементами таблицы символов. Если файл имеет загружаемый сегмент, который "
"включает таблицу строк символов, то к разделу атрибутов будет добавлен бит B<"
"SHF_ALLOC>. Иначе этот бит будет обнулён. Данный раздел имеет тип B<"
"SHT_STRTAB>."

#. type: TP
#: man-pages/man5/elf.5:1476
#, no-wrap
msgid "I<.symtab>"
msgstr "I<.symtab>"

#. type: Plain text
#: man-pages/man5/elf.5:1487
msgid ""
"This section holds a symbol table.  If the file has a loadable segment that "
"includes the symbol table, the section's attributes will include the "
"B<SHF_ALLOC> bit.  Otherwise, the bit will be off.  This section is of type "
"B<SHT_SYMTAB>."
msgstr ""
"В этом разделе содержится таблица символов. Если файл имеет загружаемый "
"сегмент, который включает таблицу символов, то к разделу атрибутов будет "
"добавлен бит B<SHF_ALLOC>. Иначе этот бит будет обнулён. Данный раздел имеет "
"тип B<SHT_SYMTAB>."

#. type: TP
#: man-pages/man5/elf.5:1487
#, no-wrap
msgid "I<.text>"
msgstr "I<.text>"

#.  .El
#. type: Plain text
#: man-pages/man5/elf.5:1499
msgid ""
"This section holds the \"text\", or executable instructions, of a program.  "
"This section is of type B<SHT_PROGBITS>.  The attributes used are "
"B<SHF_ALLOC> and B<SHF_EXECINSTR>."
msgstr ""
"В этом разделе содержится \"код (text)\", то есть исполняемые инструкции "
"программы. Он имеет тип B<SHT_PROGBITS> и атрибуты B<SHF_ALLOC> и B<"
"SHF_EXECINSTR>."

#. type: Plain text
#: man-pages/man5/elf.5:1510
msgid ""
"String table sections hold null-terminated character sequences, commonly "
"called strings.  The object file uses these strings to represent symbol and "
"section names.  One references a string as an index into the string table "
"section.  The first byte, which is index zero, is defined to hold a null "
"byte (\\(aq\\e0\\(aq).  Similarly, a string table's last byte is defined to "
"hold a null byte, ensuring null termination for all strings."
msgstr ""
"В разделах с таблицами строк содержатся символьные последовательности, "
"завершающиеся null, которые обычно называются строками. Объектный файл "
"использует эти строки для имён символов и разделов. Он ссылается на строку "
"посредством индекса в разделе таблицы строк. В первом байте с нулевым "
"индексом задаётся байт null (\\(aq\\e0\\(aq). Подобно этому, для обеспечения "
"завершения null всех строк последний байт таблицы строк также содержит байт "
"null."

#. type: Plain text
#: man-pages/man5/elf.5:1515
msgid ""
"An object file's symbol table holds information needed to locate and "
"relocate a program's symbolic definitions and references.  A symbol table "
"index is a subscript into this array."
msgstr ""
"В таблице символов объектного файла содержится информация, необходимая для "
"обнаружения и перемещения определённых в программе символов и ссылок. Индекс "
"таблицы символов указывает на элемент из этого массива."

#. type: Plain text
#: man-pages/man5/elf.5:1526
#, no-wrap
msgid ""
"typedef struct {\n"
"    uint32_t      st_name;\n"
"    Elf32_Addr    st_value;\n"
"    uint32_t      st_size;\n"
"    unsigned char st_info;\n"
"    unsigned char st_other;\n"
"    uint16_t      st_shndx;\n"
"} Elf32_Sym;\n"
msgstr ""
"typedef struct {\n    uint32_t      st_name;\n    Elf32_Addr    st_value;\n   "
" uint32_t      st_size;\n    unsigned char st_info;\n    unsigned char "
"st_other;\n    uint16_t      st_shndx;\n} Elf32_Sym;\n"

#. type: Plain text
#: man-pages/man5/elf.5:1539
#, no-wrap
msgid ""
"typedef struct {\n"
"    uint32_t      st_name;\n"
"    unsigned char st_info;\n"
"    unsigned char st_other;\n"
"    uint16_t      st_shndx;\n"
"    Elf64_Addr    st_value;\n"
"    uint64_t      st_size;\n"
"} Elf64_Sym;\n"
msgstr ""
"typedef struct {\n    uint32_t      st_name;\n    unsigned char st_info;\n    "
"unsigned char st_other;\n    uint16_t      st_shndx;\n    Elf64_Addr    "
"st_value;\n    uint64_t      st_size;\n} Elf64_Sym;\n"

#.  .Bl -tag -width "st_value"
#. type: Plain text
#: man-pages/man5/elf.5:1545
msgid ""
"The 32-bit and 64-bit versions have the same members, just in a different "
"order."
msgstr ""
"32-битная и 64-битная версии имеют одинаковые поля, различен только их "
"порядок."

#. type: TP
#: man-pages/man5/elf.5:1545
#, no-wrap
msgid "I<st_name>"
msgstr "I<st_name>"

#. type: Plain text
#: man-pages/man5/elf.5:1553
msgid ""
"This member holds an index into the object file's symbol string table, which"
" holds character representations of the symbol names.  If the value is "
"nonzero, it represents a string table index that gives the symbol name.  "
"Otherwise, the symbol table has no name."
msgstr ""
"В этом поле содержится индекс на элемент в таблице строк символов объектного "
"файла, которая содержит символьное представление имён символов. Если значение "
"не равно нулю, то это индекс таблицы строк, по которому определяется имя "
"символа. Иначе таблица символов не имеет имени."

#. type: TP
#: man-pages/man5/elf.5:1553
#, no-wrap
msgid "I<st_value>"
msgstr "I<st_value>"

#. type: Plain text
#: man-pages/man5/elf.5:1556
msgid "This member gives the value of the associated symbol."
msgstr "В этом поле содержится значение соответствующего символа."

#. type: TP
#: man-pages/man5/elf.5:1556
#, no-wrap
msgid "I<st_size>"
msgstr "I<st_size>"

#. type: Plain text
#: man-pages/man5/elf.5:1561
msgid ""
"Many symbols have associated sizes.  This member holds zero if the symbol "
"has no size or an unknown size."
msgstr ""
"Со многими символами связываются определённые размеры. Это поле имеет "
"значение ноль, если символ не имеет размера или его размер неизвестен."

#. type: TP
#: man-pages/man5/elf.5:1561
#, no-wrap
msgid "I<st_info>"
msgstr "I<st_info>"

#.  .Bl -tag -width "STT_SECTION"
#. type: Plain text
#: man-pages/man5/elf.5:1565
msgid "This member specifies the symbol's type and binding attributes:"
msgstr "В этом поле задаётся тип символа и атрибуты привязки:"

#. type: TP
#: man-pages/man5/elf.5:1566
#, no-wrap
msgid "B<STT_NOTYPE>"
msgstr "B<STT_NOTYPE>"

#. type: Plain text
#: man-pages/man5/elf.5:1569
msgid "The symbol's type is not defined."
msgstr "Тип символа не определён."

#. type: TP
#: man-pages/man5/elf.5:1569
#, no-wrap
msgid "B<STT_OBJECT>"
msgstr "B<STT_OBJECT>"

#. type: Plain text
#: man-pages/man5/elf.5:1572
msgid "The symbol is associated with a data object."
msgstr "Символу соответствует объект данных."

#. type: TP
#: man-pages/man5/elf.5:1572
#, no-wrap
msgid "B<STT_FUNC>"
msgstr "B<STT_FUNC>"

#. type: Plain text
#: man-pages/man5/elf.5:1575
msgid "The symbol is associated with a function or other executable code."
msgstr "Символу соответствует функция или другой исполняемый код."

#. type: TP
#: man-pages/man5/elf.5:1575
#, no-wrap
msgid "B<STT_SECTION>"
msgstr "B<STT_SECTION>"

#. type: Plain text
#: man-pages/man5/elf.5:1582
msgid ""
"The symbol is associated with a section.  Symbol table entries of this type "
"exist primarily for relocation and normally have B<STB_LOCAL> bindings."
msgstr ""
"Символу соответствует раздел. Элементы таблицы символов этого типа "
"существуют, прежде всего, для перемещения и обычно имеют привязки B<STB_LOCAL>"
"."

#. type: TP
#: man-pages/man5/elf.5:1582
#, no-wrap
msgid "B<STT_FILE>"
msgstr "B<STT_FILE>"

#. type: Plain text
#: man-pages/man5/elf.5:1593
msgid ""
"By convention, the symbol's name gives the name of the source file "
"associated with the object file.  A file symbol has B<STB_LOCAL> bindings, "
"its section index is B<SHN_ABS>, and it precedes the other B<STB_LOCAL> "
"symbols of the file, if it is present."
msgstr ""
"По соглашению, имя символа назначается согласно имени файла исходного кода "
"для соответствующего объектного файла. Файловый символ имеет привязки B<"
"STB_LOCAL>, его индекс раздела B<SHN_ABS>, и он предваряется другим символом "
"B<STB_LOCAL> файла, если он есть."

#. type: TP
#: man-pages/man5/elf.5:1593
#, no-wrap
msgid "B<STT_LOPROC>"
msgstr "B<STT_LOPROC>"

#. type: Plain text
#: man-pages/man5/elf.5:1598
msgid ""
"This value up to and including B<STT_HIPROC> is reserved for processor-"
"specific semantics."
msgstr ""
"Все значения, начиная с этого и больше, по B<STT_HIPROC> включительно, "
"зарезервированы для процессорно-ориентированной семантики."

#. type: TP
#: man-pages/man5/elf.5:1598
#, no-wrap
msgid "B<STT_HIPROC>"
msgstr "B<STT_HIPROC>"

#.  .El
#.  .Bl -tag -width "STB_GLOBAL"
#. type: Plain text
#: man-pages/man5/elf.5:1605
msgid ""
"This value down to and including B<STT_LOPROC> is reserved for processor-"
"specific semantics."
msgstr ""
"Все значения, начиная с этого и меньше, по B<STT_LOPROC> включительно, "
"зарезервированы для процессорно-ориентированной семантики."

#. type: TP
#: man-pages/man5/elf.5:1605
#, no-wrap
msgid "B<STB_LOCAL>"
msgstr "B<STB_LOCAL>"

#. type: Plain text
#: man-pages/man5/elf.5:1611
msgid ""
"Local symbols are not visible outside the object file containing their "
"definition.  Local symbols of the same name may exist in multiple files "
"without interfering with each other."
msgstr ""
"Локальные символы невидимы вне объектного файла, содержащего их определения. "
"Локальные символы с теми же именами могут существовать в нескольких файлах не "
"мешая друг другу."

#. type: TP
#: man-pages/man5/elf.5:1611
#, no-wrap
msgid "B<STB_GLOBAL>"
msgstr "B<STB_GLOBAL>"

#. type: Plain text
#: man-pages/man5/elf.5:1617
msgid ""
"Global symbols are visible to all object files being combined.  One file's "
"definition of a global symbol will satisfy another file's undefined "
"reference to the same symbol."
msgstr ""
"Глобальные символы видимы во всех объектных файлах после объединения. "
"Определение глобального символа в одном файле будет разрешать неопределённую "
"ссылку в другом файле для того же символа."

#. type: TP
#: man-pages/man5/elf.5:1617
#, no-wrap
msgid "B<STB_WEAK>"
msgstr "B<STB_WEAK>"

#. type: Plain text
#: man-pages/man5/elf.5:1621
msgid ""
"Weak symbols resemble global symbols, but their definitions have lower "
"precedence."
msgstr ""
"Слабые символы (weak symbols) похожи на глобальные символы, но их определения "
"имеют меньший приоритет."

#. type: TP
#: man-pages/man5/elf.5:1621
#, no-wrap
msgid "B<STB_LOPROC>"
msgstr "B<STB_LOPROC>"

#. type: Plain text
#: man-pages/man5/elf.5:1626
msgid ""
"This value up to and including B<STB_HIPROC> is reserved for processor-"
"specific semantics."
msgstr ""
"Все значения, начиная с этого и больше, по B<STB_HIPROC> включительно, "
"зарезервированы для процессорно-ориентированной семантики."

#. type: TP
#: man-pages/man5/elf.5:1626
#, no-wrap
msgid "B<STB_HIPROC>"
msgstr "B<STB_HIPROC>"

#. type: Plain text
#: man-pages/man5/elf.5:1631
msgid ""
"This value down to and including B<STB_LOPROC> is reserved for processor-"
"specific semantics."
msgstr ""
"Все значения, начиная с этого и меньше, по B<STB_LOPROC> включительно, "
"зарезервированы для процессорно-ориентированной семантики."

#. type: Plain text
#: man-pages/man5/elf.5:1633
msgid "There are macros for packing and unpacking the binding and type fields:"
msgstr "Макросы для упаковки и распаковки полей привязки и типа:"

#. type: Plain text
#: man-pages/man5/elf.5:1640
msgid ""
"B<ELF32_ST_BIND>(info)  or B<ELF64_ST_BIND>(info)  extract a binding from an"
" I<st_info> value."
msgstr ""
"B<ELF32_ST_BIND>(info) или B<ELF64_ST_BIND>(info) извлекают привязку из "
"значения I<st_info>."

#. type: Plain text
#: man-pages/man5/elf.5:1644
msgid "B<ELF32_ST_TYPE>(info)  or B<ELF64_ST_TYPE>(info)"
msgstr "B<ELF32_ST_TYPE>(info) или B<ELF64_ST_TYPE>(info)"

#. type: Plain text
#: man-pages/man5/elf.5:1648
msgid "extract a type from an I<st_info> value."
msgstr "извлекают тип из значения I<st_info>."

#. type: Plain text
#: man-pages/man5/elf.5:1652
msgid "B<ELF32_ST_INFO>(bind, type)  or B<ELF64_ST_INFO>(bind, type)"
msgstr "B<ELF32_ST_INFO>(bind, type) или B<ELF64_ST_INFO>(bind, type)"

#. type: Plain text
#: man-pages/man5/elf.5:1656
msgid "convert a binding and a type into an I<st_info> value."
msgstr "преобразуют привязку и тип в значение I<st_info>."

#. type: TP
#: man-pages/man5/elf.5:1658
#, no-wrap
msgid "I<st_other>"
msgstr "I<st_other>"

#.  .Bl -tag -width "STV_PROTECTED"
#. type: Plain text
#: man-pages/man5/elf.5:1662
msgid "This member defines the symbol visibility."
msgstr "Этим полем определяется видимость символа."

#. type: TP
#: man-pages/man5/elf.5:1663
#, no-wrap
msgid "B<STV_DEFAULT>"
msgstr "B<STV_DEFAULT>"

#. type: Plain text
#: man-pages/man5/elf.5:1667
msgid "Default symbol visibility rules."
msgstr "Правила видимости символов по умолчанию."

#. type: TP
#: man-pages/man5/elf.5:1667
#, no-wrap
msgid "B<STV_INTERNAL>"
msgstr "B<STV_INTERNAL>"

#. type: Plain text
#: man-pages/man5/elf.5:1670
msgid "Processor-specific hidden class."
msgstr "Скрытый класс, зависящий от процессора."

#. type: TP
#: man-pages/man5/elf.5:1670
#, no-wrap
msgid "B<STV_HIDDEN>"
msgstr "B<STV_HIDDEN>"

#. type: Plain text
#: man-pages/man5/elf.5:1673
msgid "Symbol is unavailable in other modules."
msgstr "Символ недоступен в других модулях."

#. type: TP
#: man-pages/man5/elf.5:1673
#, no-wrap
msgid "B<STV_PROTECTED>"
msgstr "B<STV_PROTECTED>"

#. type: Plain text
#: man-pages/man5/elf.5:1676
msgid "Not preemptible, not exported."
msgstr "Невыгружаемый, не экспортируется."

#. type: Plain text
#: man-pages/man5/elf.5:1679
msgid "There are macros for extracting the visibility type:"
msgstr "Эти макросы служат для извлечения типа видимости:"

#. type: Plain text
#: man-pages/man5/elf.5:1683
msgid "B<ELF32_ST_VISIBILITY>(other)  or B<ELF64_ST_VISIBILITY>(other)"
msgstr "B<ELF32_ST_VISIBILITY>(other) или B<ELF64_ST_VISIBILITY>(other)"

#. type: TP
#: man-pages/man5/elf.5:1685
#, no-wrap
msgid "I<st_shndx>"
msgstr "I<st_shndx>"

#.  .El
#. type: Plain text
#: man-pages/man5/elf.5:1693
msgid ""
"Every symbol table entry is \"defined\" in relation to some section.  This "
"member holds the relevant section header table index."
msgstr ""
"Каждый элемент таблицы символов \"определён\" в отношении к некоторому "
"разделу. Это поле содержит соответствующий индекс таблицы заголовков разделов."

#. type: Plain text
#: man-pages/man5/elf.5:1701
msgid ""
"Relocation is the process of connecting symbolic references with symbolic "
"definitions.  Relocatable files must have information that describes how to "
"modify their section contents, thus allowing executable and shared object "
"files to hold the right information for a process's program image.  "
"Relocation entries are these data."
msgstr ""
"Перемещение \\(em это процесс соединения символьных ссылок с символьными "
"определениями. Перемещаемые файлы должны иметь информацию, которая описывает "
"как нужно изменить их содержимое разделов, чтобы позволить исполняемым и "
"динамическим объектным файлам содержать корректную информацию для образа "
"процесса программы. Для этого существуют перемещения."

#. type: Plain text
#: man-pages/man5/elf.5:1703
msgid "Relocation structures that do not need an addend:"
msgstr "Перемещаемые структуры, которым не нужна добавка:"

#. type: Plain text
#: man-pages/man5/elf.5:1710
#, no-wrap
msgid ""
"typedef struct {\n"
"    Elf32_Addr r_offset;\n"
"    uint32_t   r_info;\n"
"} Elf32_Rel;\n"
msgstr ""
"typedef struct {\n    Elf32_Addr r_offset;\n    uint32_t   r_info;\n} "
"Elf32_Rel;\n"

#. type: Plain text
#: man-pages/man5/elf.5:1719
#, no-wrap
msgid ""
"typedef struct {\n"
"    Elf64_Addr r_offset;\n"
"    uint64_t   r_info;\n"
"} Elf64_Rel;\n"
msgstr ""
"typedef struct {\n    Elf64_Addr r_offset;\n    uint64_t   r_info;\n} "
"Elf64_Rel;\n"

#. type: Plain text
#: man-pages/man5/elf.5:1723
msgid "Relocation structures that need an addend:"
msgstr "Перемещаемые структуры, которым нужна добавка:"

#. type: Plain text
#: man-pages/man5/elf.5:1731
#, no-wrap
msgid ""
"typedef struct {\n"
"    Elf32_Addr r_offset;\n"
"    uint32_t   r_info;\n"
"    int32_t    r_addend;\n"
"} Elf32_Rela;\n"
msgstr ""
"typedef struct {\n    Elf32_Addr r_offset;\n    uint32_t   r_info;\n    "
"int32_t    r_addend;\n} Elf32_Rela;\n"

#. type: Plain text
#: man-pages/man5/elf.5:1741
#, no-wrap
msgid ""
"typedef struct {\n"
"    Elf64_Addr r_offset;\n"
"    uint64_t   r_info;\n"
"    int64_t    r_addend;\n"
"} Elf64_Rela;\n"
msgstr ""
"typedef struct {\n    Elf64_Addr r_offset;\n    uint64_t   r_info;\n    "
"int64_t    r_addend;\n} Elf64_Rela;\n"

#. type: TP
#: man-pages/man5/elf.5:1744
#, no-wrap
msgid "I<r_offset>"
msgstr "I<r_offset>"

#. type: Plain text
#: man-pages/man5/elf.5:1752
msgid ""
"This member gives the location at which to apply the relocation action.  For"
" a relocatable file, the value is the byte offset from the beginning of the "
"section to the storage unit affected by the relocation.  For an executable "
"file or shared object, the value is the virtual address of the storage unit "
"affected by the relocation."
msgstr ""
"В этом поле задаётся расположение, по которому применяется действие по "
"перемещению. Для файла, допускающего перемещения, значением является байтовое "
"смещение от начала раздела до хранимого элемента, подвергаемого перемещению. "
"Для исполняемого файла или динамического объекта значением является "
"виртуальный адрес хранимого элемента, подвергаемого перемещению."

#. type: TP
#: man-pages/man5/elf.5:1752
#, no-wrap
msgid "I<r_info>"
msgstr "I<r_info>"

#. type: Plain text
#: man-pages/man5/elf.5:1767
msgid ""
"This member gives both the symbol table index with respect to which the "
"relocation must be made and the type of relocation to apply.  Relocation "
"types are processor-specific.  When the text refers to a relocation entry's "
"relocation type or symbol table index, it means the result of applying "
"B<ELF[32|64]_R_TYPE> or B<ELF[32|64]_R_SYM>, respectively, to the entry's "
"I<r_info> member."
msgstr ""
"В этом поле указывается индекс таблицы символов с соблюдением того, что нужно "
"выполнить перемещение и тип применяемого перемещения. Типы перемещений "
"зависят от архитектуры процессора. Когда в коде есть ссылка на тип "
"перемещения элемента перемещения или индекс таблицы символов, то имеется в "
"виду результат применения B<ELF[32|64]_R_TYPE> или B<ELF[32|64]_R_SYM>, "
"соответственно, к полю I<r_info>."

#. type: TP
#: man-pages/man5/elf.5:1767
#, no-wrap
msgid "I<r_addend>"
msgstr "I<r_addend>"

#.  .El
#. type: Plain text
#: man-pages/man5/elf.5:1772
msgid ""
"This member specifies a constant addend used to compute the value to be "
"stored into the relocatable field."
msgstr ""
"В этом поле указывается константа-добавка, используемая для вычисления "
"значения, хранимого в поле перемещения."

#. type: Plain text
#: man-pages/man5/elf.5:1777
msgid ""
"The .dynamic section contains a series of structures that hold relevant "
"dynamic linking information.  The d_tag member controls the interpretation "
"of d_un."
msgstr ""
"В разделе .dynamic содержится несколько структур, в которых содержится "
"информация по динамической компоновке. Полем d_tag контролируется "
"интерпретация d_un."

#. type: Plain text
#: man-pages/man5/elf.5:1788
#, no-wrap
msgid ""
"typedef struct {\n"
"    Elf32_Sword    d_tag;\n"
"    union {\n"
"        Elf32_Word d_val;\n"
"        Elf32_Addr d_ptr;\n"
"    } d_un;\n"
"} Elf32_Dyn;\n"
"extern Elf32_Dyn _DYNAMIC[];\n"
msgstr ""
"typedef struct {\n    Elf32_Sword    d_tag;\n    union {\n        Elf32_Word "
"d_val;\n        Elf32_Addr d_ptr;\n    } d_un;\n} Elf32_Dyn;\nextern "
"Elf32_Dyn _DYNAMIC[];\n"

#. type: Plain text
#: man-pages/man5/elf.5:1801
#, no-wrap
msgid ""
"typedef struct {\n"
"    Elf64_Sxword    d_tag;\n"
"    union {\n"
"        Elf64_Xword d_val;\n"
"        Elf64_Addr  d_ptr;\n"
"    } d_un;\n"
"} Elf64_Dyn;\n"
"extern Elf64_Dyn _DYNAMIC[];\n"
msgstr ""
"typedef struct {\n    Elf64_Sxword    d_tag;\n    union {\n        "
"Elf64_Xword d_val;\n        Elf64_Addr  d_ptr;\n    } d_un;\n} "
"Elf64_Dyn;\nextern Elf64_Dyn _DYNAMIC[];\n"

#. type: TP
#: man-pages/man5/elf.5:1804
#, no-wrap
msgid "I<d_tag>"
msgstr "I<d_tag>"

#.  .Bl -tag -width "DT_SYMBOLIC"
#. type: Plain text
#: man-pages/man5/elf.5:1808
msgid "This member may have any of the following values:"
msgstr "В этом поле могут содержаться следующие значения:"

#. type: TP
#: man-pages/man5/elf.5:1809
#, no-wrap
msgid "B<DT_NULL>"
msgstr "B<DT_NULL>"

#. type: Plain text
#: man-pages/man5/elf.5:1812
msgid "Marks end of dynamic section"
msgstr "Этим значением помечается конец динамического раздела"

#. type: TP
#: man-pages/man5/elf.5:1812
#, no-wrap
msgid "B<DT_NEEDED>"
msgstr "B<DT_NEEDED>"

#. type: Plain text
#: man-pages/man5/elf.5:1815
msgid "String table offset to name of a needed library"
msgstr "Смещение в таблице строк на имя необходимой библиотеки"

#. type: TP
#: man-pages/man5/elf.5:1815
#, no-wrap
msgid "B<DT_PLTRELSZ>"
msgstr "B<DT_PLTRELSZ>"

#. type: Plain text
#: man-pages/man5/elf.5:1818
msgid "Size in bytes of PLT relocs"
msgstr "Размер в байтах перемещений PLT"

#. type: TP
#: man-pages/man5/elf.5:1818
#, no-wrap
msgid "B<DT_PLTGOT>"
msgstr "B<DT_PLTGOT>"

#. type: Plain text
#: man-pages/man5/elf.5:1821
msgid "Address of PLT and/or GOT"
msgstr "Адрес PLT и/или GOT"

#. type: TP
#: man-pages/man5/elf.5:1821
#, no-wrap
msgid "B<DT_HASH>"
msgstr "B<DT_HASH>"

#. type: Plain text
#: man-pages/man5/elf.5:1824
msgid "Address of symbol hash table"
msgstr "Адрес хэш-таблицы символов"

#. type: TP
#: man-pages/man5/elf.5:1824
#, no-wrap
msgid "B<DT_STRTAB>"
msgstr "B<DT_STRTAB>"

#. type: Plain text
#: man-pages/man5/elf.5:1827
msgid "Address of string table"
msgstr "Адрес таблицы строк"

#. type: TP
#: man-pages/man5/elf.5:1827
#, no-wrap
msgid "B<DT_SYMTAB>"
msgstr "B<DT_SYMTAB>"

#. type: Plain text
#: man-pages/man5/elf.5:1830
msgid "Address of symbol table"
msgstr "Адрес таблицы символов"

#. type: TP
#: man-pages/man5/elf.5:1830
#, no-wrap
msgid "B<DT_RELA>"
msgstr "B<DT_RELA>"

#. type: Plain text
#: man-pages/man5/elf.5:1833
msgid "Address of Rela relocs table"
msgstr "Адрес таблицы перемещений Rela"

#. type: TP
#: man-pages/man5/elf.5:1833
#, no-wrap
msgid "B<DT_RELASZ>"
msgstr "B<DT_RELASZ>"

#. type: Plain text
#: man-pages/man5/elf.5:1836
msgid "Size in bytes of Rela table"
msgstr "Размер в байтах таблицы Rela"

#. type: TP
#: man-pages/man5/elf.5:1836
#, no-wrap
msgid "B<DT_RELAENT>"
msgstr "B<DT_RELAENT>"

#. type: Plain text
#: man-pages/man5/elf.5:1839
msgid "Size in bytes of a Rela table entry"
msgstr "Размер в байтах элемента таблицы Rela"

#. type: TP
#: man-pages/man5/elf.5:1839
#, no-wrap
msgid "B<DT_STRSZ>"
msgstr "B<DT_STRSZ>"

#. type: Plain text
#: man-pages/man5/elf.5:1842
msgid "Size in bytes of string table"
msgstr "Размер в байтах таблицы строк"

#. type: TP
#: man-pages/man5/elf.5:1842
#, no-wrap
msgid "B<DT_SYMENT>"
msgstr "B<DT_SYMENT>"

#. type: Plain text
#: man-pages/man5/elf.5:1845
msgid "Size in bytes of a symbol table entry"
msgstr "Размер в байтах элемента таблицы строк"

#. type: TP
#: man-pages/man5/elf.5:1845
#, no-wrap
msgid "B<DT_INIT>"
msgstr "B<DT_INIT>"

#. type: Plain text
#: man-pages/man5/elf.5:1848
msgid "Address of the initialization function"
msgstr "Адрес функции инициализации"

#. type: TP
#: man-pages/man5/elf.5:1848
#, no-wrap
msgid "B<DT_FINI>"
msgstr "B<DT_FINI>"

#. type: Plain text
#: man-pages/man5/elf.5:1851
msgid "Address of the termination function"
msgstr "Адрес функции окончания"

#. type: TP
#: man-pages/man5/elf.5:1851
#, no-wrap
msgid "B<DT_SONAME>"
msgstr "B<DT_SONAME>"

#. type: Plain text
#: man-pages/man5/elf.5:1854
msgid "String table offset to name of shared object"
msgstr "Смещение в таблице строк для имени динамического объекта"

#. type: TP
#: man-pages/man5/elf.5:1854
#, no-wrap
msgid "B<DT_RPATH>"
msgstr "B<DT_RPATH>"

#. type: Plain text
#: man-pages/man5/elf.5:1857
msgid "String table offset to library search path (deprecated)"
msgstr "Смещение в таблице строк для пути поиска (устарело)"

#. type: TP
#: man-pages/man5/elf.5:1857
#, no-wrap
msgid "B<DT_SYMBOLIC>"
msgstr "B<DT_SYMBOLIC>"

#. type: Plain text
#: man-pages/man5/elf.5:1860
msgid ""
"Alert linker to search this shared object before the executable for symbols"
msgstr ""
"Уведомление для компоновщика, что нужно искать этот динамический объект до "
"поиска символов в исполняемом файле"

#. type: TP
#: man-pages/man5/elf.5:1860
#, no-wrap
msgid "B<DT_REL>"
msgstr "B<DT_REL>"

#. type: Plain text
#: man-pages/man5/elf.5:1863
msgid "Address of Rel relocs table"
msgstr "Адрес таблицы перемещений Rel"

#. type: TP
#: man-pages/man5/elf.5:1863
#, no-wrap
msgid "B<DT_RELSZ>"
msgstr "B<DT_RELSZ>"

#. type: Plain text
#: man-pages/man5/elf.5:1866
msgid "Size in bytes of Rel table"
msgstr "Размер в байтах таблицы Rel"

#. type: TP
#: man-pages/man5/elf.5:1866
#, no-wrap
msgid "B<DT_RELENT>"
msgstr "B<DT_RELENT>"

#. type: Plain text
#: man-pages/man5/elf.5:1869
msgid "Size in bytes of a Rel table entry"
msgstr "Размер в байтах элемента таблицы Rel"

#. type: TP
#: man-pages/man5/elf.5:1869
#, no-wrap
msgid "B<DT_PLTREL>"
msgstr "B<DT_PLTREL>"

#. type: Plain text
#: man-pages/man5/elf.5:1872
msgid "Type of reloc the PLT refers (Rela or Rel)"
msgstr "Тип перемещения ссылок PLT (Rela или Rel)"

#. type: TP
#: man-pages/man5/elf.5:1872
#, no-wrap
msgid "B<DT_DEBUG>"
msgstr "B<DT_DEBUG>"

#. type: Plain text
#: man-pages/man5/elf.5:1875
msgid "Undefined use for debugging"
msgstr "Не определено, используется для отладки"

#. type: TP
#: man-pages/man5/elf.5:1875
#, no-wrap
msgid "B<DT_TEXTREL>"
msgstr "B<DT_TEXTREL>"

#. type: Plain text
#: man-pages/man5/elf.5:1878
msgid ""
"Absence of this indicates no relocs should apply to a nonwritable segment"
msgstr ""
"Отсутствие указывает, что перемещения не должны применяться к сегменту, "
"недоступному на запись"

#. type: TP
#: man-pages/man5/elf.5:1878
#, no-wrap
msgid "B<DT_JMPREL>"
msgstr "B<DT_JMPREL>"

#. type: Plain text
#: man-pages/man5/elf.5:1881
msgid "Address of reloc entries solely for the PLT"
msgstr "Адрес элементов перемещений исключительно для PLT"

#. type: TP
#: man-pages/man5/elf.5:1881
#, no-wrap
msgid "B<DT_BIND_NOW>"
msgstr "B<DT_BIND_NOW>"

#. type: Plain text
#: man-pages/man5/elf.5:1885
msgid ""
"Instruct dynamic linker to process all relocs before transferring control to"
" the executable"
msgstr ""
"Указать динамическому компоновщику, что нужно обработать все перемещения до "
"передачи управления исполняемому файлу"

#. type: TP
#: man-pages/man5/elf.5:1885
#, no-wrap
msgid "B<DT_RUNPATH>"
msgstr "B<DT_RUNPATH>"

#. type: Plain text
#: man-pages/man5/elf.5:1888
msgid "String table offset to library search path"
msgstr "Смещение в таблице строк для пути поиска библиотек"

#. type: TP
#: man-pages/man5/elf.5:1888
#, no-wrap
msgid "B<DT_LOPROC>"
msgstr "B<DT_LOPROC>"

#. type: Plain text
#: man-pages/man5/elf.5:1891
msgid "Start of processor-specific semantics"
msgstr "Начало процессорно-ориентированной семантики"

#. type: TP
#: man-pages/man5/elf.5:1891
#, no-wrap
msgid "B<DT_HIPROC>"
msgstr "B<DT_HIPROC>"

#. type: Plain text
#: man-pages/man5/elf.5:1894
msgid "End of processor-specific semantics"
msgstr "Конец процессорно-ориентированной семантики"

#. type: TP
#: man-pages/man5/elf.5:1896
#, no-wrap
msgid "I<d_val>"
msgstr "I<d_val>"

#. type: Plain text
#: man-pages/man5/elf.5:1899
msgid "This member represents integer values with various interpretations."
msgstr "В этом поле указываются целые (integer) значения различного смысла."

#. type: TP
#: man-pages/man5/elf.5:1899
#, no-wrap
msgid "I<d_ptr>"
msgstr "I<d_ptr>"

#. type: Plain text
#: man-pages/man5/elf.5:1907
msgid ""
"This member represents program virtual addresses.  When interpreting these "
"addresses, the actual address should be computed based on the original file "
"value and memory base address.  Files do not contain relocation entries to "
"fixup these addresses."
msgstr ""
"В этом поле указываются программные виртуальные адреса. При интерпретации "
"данных адресов, реальные адреса должны вычисляться на основе оригинального "
"значения из файла и базового адреса памяти. Файлы не содержат перемещаемых "
"элементов для местоположения этих адресов."

#. type: TP
#: man-pages/man5/elf.5:1907
#, no-wrap
msgid "I<_DYNAMIC>"
msgstr "I<_DYNAMIC>"

#.  .El
#. type: Plain text
#: man-pages/man5/elf.5:1912
msgid ""
"Array containing all the dynamic structures in the .dynamic section.  This "
"is automatically populated by the linker."
msgstr ""
"Массив, содержащий все динамические структуры в разделе .dynamic. "
"Автоматически заполняется компоновщиком."

#.  OpenBSD
#.  ELF support first appeared in
#.  OpenBSD 1.2,
#.  although not all supported platforms use it as the native
#.  binary file format.
#. type: Plain text
#: man-pages/man5/elf.5:1921
msgid "ELF first appeared in System V.  The ELF format is an adopted standard."
msgstr ""
"Впервые ELF появился в System V. Формат ELF является утверждённым стандартом."

#.  .SH AUTHORS
#.  The original version of this manual page was written by
#.  .An Jeroen Ruigrok van der Werven
#.  .Aq asmodai@FreeBSD.org
#.  with inspiration from BSDi's
#.  .Bsx
#.  .Nm elf
#.  man page.
#. type: Plain text
#: man-pages/man5/elf.5:1939
msgid ""
"The extensions for I<e_phnum>, I<e_shnum> and I<e_strndx> respectively are "
"Linux extensions.  Sun, BSD and AMD64 also support them; for further "
"information, look under SEE ALSO."
msgstr ""
"Расширения для I<e_phnum>, I<e_shnum> и I<e_strndx> соответствующих "
"расширений Linux. Также они поддерживаются в Sun, BSD и AMD64; дополнительную "
"информацию смотрите в разделе \"СМОТРИТЕ ТАКЖЕ\"."

#. type: Plain text
#: man-pages/man5/elf.5:1946
msgid "B<as>(1), B<gdb>(1), B<ld>(1), B<objdump>(1), B<execve>(2), B<core>(5)"
msgstr "B<as>(1), B<gdb>(1), B<ld>(1), B<objdump>(1), B<execve>(2), B<core>(5)"

#. type: Plain text
#: man-pages/man5/elf.5:1949
msgid "Hewlett-Packard, I<Elf-64 Object File Format>."
msgstr "Hewlett-Packard, I<Формат объектных файлов Elf-64>."

#. type: Plain text
#: man-pages/man5/elf.5:1952
msgid "Santa Cruz Operation, I<System V Application Binary Interface>."
msgstr "Santa Cruz Operation, I<Двоичный интерфейс приложений System V>."

#. type: Plain text
#: man-pages/man5/elf.5:1956
msgid ""
"UNIX System Laboratories, \"Object Files\", I<Executable and Linking Format "
"(ELF)>."
msgstr ""
"UNIX System Laboratories, «Объектные файлы», I<Формат исполняемых и "
"компонуемых файлов (ELF)>."

#. type: Plain text
#: man-pages/man5/elf.5:1959
msgid "Sun Microsystems, I<Linker and Libraries Guide>."
msgstr ""
"Sun Microsystems, I<Руководстве по компоновщику и библиотекам> (I<Linker and "
"Libraries Guide>)."

#. type: Plain text
#: man-pages/man5/elf.5:1962
msgid ""
"AMD64 ABI Draft, I<System V Application Binary Interface AMD64 Architecture "
"Processor Supplement>."
msgstr ""
"черновик ABI AMD64, I<Дополнение к двоичному интерфейсу приложений System V "
"процессорной архитектуры AMD64> (I<System V Application Binary Interface "
"AMD64 Architecture Processor Supplement>)."

#. type: TH
#: man-pages/man3/err.3:39
#, no-wrap
msgid "ERR"
msgstr "ERR"

#. type: TH
#: man-pages/man3/err.3:39
#, no-wrap
msgid "2013-12-30"
msgstr "2013-12-30"

#. type: Plain text
#: man-pages/man3/err.3:42
msgid ""
"err, verr, errx, verrx, warn, vwarn, warnx, vwarnx - formatted error "
"messages"
msgstr ""
"err, verr, errx, verrx, warn, vwarn, warnx, vwarnx - форматирует сообщения об "
"ошибках"

#. type: Plain text
#: man-pages/man3/err.3:45
#, no-wrap
msgid "B<#include E<lt>err.hE<gt>>\n"
msgstr "B<#include E<lt>err.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/err.3:47
#, no-wrap
msgid "B<void err(int >I<eval>B<, const char *>I<fmt>B<, ...);>\n"
msgstr "B<void err(int >I<eval>B<, const char *>I<fmt>B<, ...);>\n"

#. type: Plain text
#: man-pages/man3/err.3:49
#, no-wrap
msgid "B<void errx(int >I<eval>B<, const char *>I<fmt>B<, ...);>\n"
msgstr "B<void errx(int >I<eval>B<, const char *>I<fmt>B<, ...);>\n"

#. type: Plain text
#: man-pages/man3/err.3:51
#, no-wrap
msgid "B<void warn(const char *>I<fmt>B<, ...);>\n"
msgstr "B<void warn(const char *>I<fmt>B<, ...);>\n"

#. type: Plain text
#: man-pages/man3/err.3:53
#, no-wrap
msgid "B<void warnx(const char *>I<fmt>B<, ...);>\n"
msgstr "B<void warnx(const char *>I<fmt>B<, ...);>\n"

#. type: Plain text
#: man-pages/man3/err.3:55
#, no-wrap
msgid "B<#include E<lt>stdarg.hE<gt>>\n"
msgstr "B<#include E<lt>stdarg.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/err.3:57
#, no-wrap
msgid ""
"B<void verr(int >I<eval>B<, const char *>I<fmt>B<, va_list >I<args>B<);>\n"
msgstr ""
"B<void verr(int >I<eval>B<, const char *>I<fmt>B<, va_list >I<args>B<);>\n"

#. type: Plain text
#: man-pages/man3/err.3:59
#, no-wrap
msgid ""
"B<void verrx(int >I<eval>B<, const char *>I<fmt>B<, va_list >I<args>B<);>\n"
msgstr ""
"B<void verrx(int >I<eval>B<, const char *>I<fmt>B<, va_list >I<args>B<);>\n"

#. type: Plain text
#: man-pages/man3/err.3:61
#, no-wrap
msgid "B<void vwarn(const char *>I<fmt>B<, va_list >I<args>B<);>\n"
msgstr "B<void vwarn(const char *>I<fmt>B<, va_list >I<args>B<);>\n"

#. type: Plain text
#: man-pages/man3/err.3:63
#, no-wrap
msgid "B<void vwarnx(const char *>I<fmt>B<, va_list >I<args>B<);>\n"
msgstr "B<void vwarnx(const char *>I<fmt>B<, va_list >I<args>B<);>\n"

#. type: Plain text
#: man-pages/man3/err.3:79
msgid ""
"The B<err>()  and B<warn>()  family of functions display a formatted error "
"message on the standard error output.  In all cases, the last component of "
"the program name, a colon character, and a space are output.  If the I<fmt> "
"argument is not NULL, the B<printf>(3)-like formatted error message is "
"output.  The output is terminated by a newline character."
msgstr ""
"Семейства функций B<err>() и B<warn>() выводят форматированное сообщение об "
"ошибке в стандартный поток ошибок. При выводе всегда показывается последний "
"компонент имени программы, двоеточие и пробел. Если значение I<fmt> не равно "
"NULL, то выводится сообщение об ошибке, отформатированное согласно B<printf>"
"(3). Вывод завершается символом новой строки."

#. type: Plain text
#: man-pages/man3/err.3:94
msgid ""
"The B<err>(), B<verr>(), B<warn>(), and B<vwarn>()  functions append an "
"error message obtained from B<strerror>(3)  based on the global variable "
"I<errno>, preceded by another colon and space unless the I<fmt> argument is "
"NULL."
msgstr ""
"Функции B<err>(), B<verr>(), B<warn>() и B<vwarn>() добавляют сообщение об "
"ошибке, полученное от B<strerror>(3) для значения глобальной переменной I<"
"errno>, начиная его с двоеточия и пробела, если значение I<fmt> равно NULL."

#. type: Plain text
#: man-pages/man3/err.3:100
msgid ""
"The B<errx>()  and B<warnx>()  functions do not append an error message."
msgstr "Функции B<errx>() и B<warnx>() не добавляют сообщение об ошибке."

#. type: Plain text
#: man-pages/man3/err.3:109
msgid ""
"The B<err>(), B<verr>(), B<errx>(), and B<verrx>()  functions do not return,"
" but exit with the value of the argument I<eval>."
msgstr ""
"Функции B<err>(), B<verr>(), B<errx>() и B<verrx>() не возвращают управление "
"в программу, а завершают её с кодом выхода, равным значению I<eval>."

#.  .SH HISTORY
#.  The
#.  .BR err ()
#.  and
#.  .BR warn ()
#.  functions first appeared in
#.  4.4BSD.
#. type: Plain text
#: man-pages/man3/err.3:118
msgid "These functions are nonstandard BSD extensions."
msgstr "Эти функции являются расширениями BSD."

#. type: Plain text
#: man-pages/man3/err.3:122
msgid "Display the current I<errno> information string and exit:"
msgstr "Показать строку с информацией о текущем I<errno> и закончить работу:"

#. type: Plain text
#: man-pages/man3/err.3:131
#, no-wrap
msgid ""
"p = malloc(size);\n"
"if (p == NULL)\n"
"    err(1, NULL);\n"
"fd = open(file_name, O_RDONLY, 0);\n"
"if (fd == -1)\n"
"    err(1, \"%s\", file_name);\n"
msgstr ""
"p = malloc(size);\nif (p == NULL)\n    err(1, NULL);\nfd = open(file_name, "
"O_RDONLY, 0);\nif (fd == -1)\n    err(1, \"%s\", file_name);\n"

#. type: Plain text
#: man-pages/man3/err.3:135
msgid "Display an error message and exit:"
msgstr "Показать сообщение об ошибке и закончить работу:"

#. type: Plain text
#: man-pages/man3/err.3:140
#, no-wrap
msgid ""
"if (tm.tm_hour E<lt> START_TIME)\n"
"    errx(1, \"too early, wait until %s\", start_time_string);\n"
msgstr ""
"if (tm.tm_hour E<lt> START_TIME)\n    errx(1, \"слишком рано, ждём до %s\", "
"start_time_string);\n"

#. type: Plain text
#: man-pages/man3/err.3:144
msgid "Warn of an error:"
msgstr "Предупреждение об ошибке:"

#. type: Plain text
#: man-pages/man3/err.3:154
#, no-wrap
msgid ""
"fd = open(raw_device, O_RDONLY, 0);\n"
"if (fd == -1)\n"
"    warnx(\"%s: %s: trying the block device\",\n"
"            raw_device, strerror(errno));\n"
"fd = open(block_device, O_RDONLY, 0);\n"
"if (fd == -1)\n"
"    err(1, \"%s\", block_device);\n"
msgstr ""
"fd = open(raw_device, O_RDONLY, 0);\nif (fd == -1)\n    warnx(\"%s: %s: "
"пробуем блочное устройство\",\n            raw_device, strerror(errno));\nfd "
"= open(block_device, O_RDONLY, 0);\nif (fd == -1)\n    err(1, \"%s\", "
"block_device);\n"

#. type: Plain text
#: man-pages/man3/err.3:161
msgid "B<error>(3), B<exit>(3), B<perror>(3), B<printf>(3), B<strerror>(3)"
msgstr "B<error>(3), B<exit>(3), B<perror>(3), B<printf>(3), B<strerror>(3)"

#. type: TH
#: man-pages/man3/exp2.3:36
#, no-wrap
msgid "EXP2"
msgstr "EXP2"

#. type: TH
#: man-pages/man3/exp2.3:36
#, no-wrap
msgid "2010-09-20"
msgstr "2010-09-20"

#. type: Plain text
#: man-pages/man3/exp2.3:39
msgid "exp2, exp2f, exp2l - base-2 exponential function"
msgstr "exp2, exp2f, exp2l - функция степени по основанию 2"

#. type: Plain text
#: man-pages/man3/exp2.3:42
#, no-wrap
msgid "B<#include E<lt>math.hE<gt>>\n"
msgstr "B<#include E<lt>math.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/exp2.3:44
#, no-wrap
msgid "B<double exp2(double >I<x>B<);>\n"
msgstr "B<double exp2(double >I<x>B<);>\n"

#. type: Plain text
#: man-pages/man3/exp2.3:46
#, no-wrap
msgid "B<float exp2f(float >I<x>B<);>\n"
msgstr "B<float exp2f(float >I<x>B<);>\n"

#. type: Plain text
#: man-pages/man3/exp2.3:48
#, no-wrap
msgid "B<long double exp2l(long double >I<x>B<);>\n"
msgstr "B<long double exp2l(long double >I<x>B<);>\n"

#. type: Plain text
#: man-pages/man3/exp2.3:51
msgid "Link with I<-lm>."
msgstr "Компонуется при указании параметра I<-lm>."

#. type: Plain text
#: man-pages/man3/exp2.3:55
msgid ""
"Feature Test Macro Requirements for glibc (see B<feature_test_macros>(7)):"
msgstr ""
"Требования макроса тестирования свойств для glibc (см. B<feature_test_macros>"
"(7)):"

#. type: Plain text
#: man-pages/man3/exp2.3:61
msgid "B<exp2>(), B<exp2f>(), B<exp2l>():"
msgstr "B<exp2>(), B<exp2f>(), B<exp2l>():"

#. type: Plain text
#: man-pages/man3/exp2.3:63
msgid ""
"_XOPEN_SOURCE\\ E<gt>=\\ 600 || _ISOC99_SOURCE || _POSIX_C_SOURCE\\ E<gt>=\\"
" 200112L;"
msgstr ""
"_XOPEN_SOURCE\\ E<gt>=\\ 600 || _ISOC99_SOURCE || _POSIX_C_SOURCE\\ E<gt>=\\ "
"200112L;"

#. type: Plain text
#: man-pages/man3/exp2.3:66
msgid "or I<cc\\ -std=c99>"
msgstr "или I<cc\\ -std=c99>"

#. type: Plain text
#: man-pages/man3/exp2.3:74
msgid ""
"The B<exp2>()  function returns the value of 2 raised to the power of I<x>."
msgstr ""
"Функция B<exp2>() возвращает значение числа 2, возведенное в степень I<x>."

#. type: Plain text
#: man-pages/man3/exp2.3:77
msgid ""
"On success, these functions return the base-2 exponential value of I<x>."
msgstr "При успешном выполнении данные функции возвращают 2 в степени I<x>."

#. type: Plain text
#: man-pages/man3/exp2.3:81
msgid ""
"For various special cases, including the handling of infinity and NaN, as "
"well as overflows and underflows, see B<exp>(3)."
msgstr ""
"Описание работы со специальными значениями, такими как бесконечность и NaN, а "
"также при привышении и потере разрядности смотрите в B<exp>(3)."

#. type: Plain text
#: man-pages/man3/exp2.3:86
msgid ""
"See B<math_error>(7)  for information on how to determine whether an error "
"has occurred when calling these functions."
msgstr ""
"Смотрите B<math_error>(7), чтобы определить, какие ошибки могут возникать при "
"вызове этих функций."

#. type: Plain text
#: man-pages/man3/exp2.3:89
msgid ""
"For a discussion of the errors that can occur for these functions, see "
"B<exp>(3)."
msgstr "Обсуждение возникающих ошибок этих функций смотрите в B<exp>(3)."

#. type: Plain text
#: man-pages/man3/exp2.3:91
msgid "These functions first appeared in glibc in version 2.1."
msgstr "Эти функции впервые появились в glibc 2.1."

#. type: Plain text
#: man-pages/man3/exp2.3:97
msgid ""
"C99, POSIX.1-2001.  The variant returning I<double> also conforms to SVr4, "
"4.3BSD, C89."
msgstr ""
"C99, POSIX.1-2001. Вариант, возвращающий значение типа I<double>, также "
"соответствует SVr4, 4.3BSD и C89."

#. type: Plain text
#: man-pages/man3/exp2.3:102
msgid "B<cbrt>(3), B<cexp2>(3), B<exp>(3), B<exp10>(3), B<sqrt>(3)"
msgstr "B<cbrt>(3), B<cexp2>(3), B<exp>(3), B<exp10>(3), B<sqrt>(3)"

#. type: TH
#: man-pages/man3/ecvt.3:32
#, no-wrap
msgid "ECVT"
msgstr "ECVT"

#. type: TH
#: man-pages/man3/ecvt.3:32
#, no-wrap
msgid "2013-07-04"
msgstr "2013-07-04"

#. type: Plain text
#: man-pages/man3/ecvt.3:35
msgid "ecvt, fcvt - convert a floating-point number to a string"
msgstr "ecvt, fcvt - преобразование числа с плавающей точкой в строку"

#. type: Plain text
#: man-pages/man3/ecvt.3:37
msgid "B<#include E<lt>stdlib.hE<gt>>"
msgstr "B<#include E<lt>stdlib.hE<gt>>"

#. type: Plain text
#: man-pages/man3/ecvt.3:40
msgid ""
"B<char *ecvt(double >I<number>B<, int >I<ndigits>B<, int *>I<decpt>B<,> "
"B<int *>I<sign>B<);>"
msgstr ""
"B<char *ecvt(double >I<number>B<, int >I<ndigits>B<, int *>I<decpt>B<,> B<int "
"*>I<sign>B<);>"

#. type: Plain text
#: man-pages/man3/ecvt.3:43
msgid ""
"B<char *fcvt(double >I<number>B<, int >I<ndigits>B<, int *>I<decpt>B<,> "
"B<int *>I<sign>B<);>"
msgstr ""
"B<char *fcvt(double >I<number>B<, int >I<ndigits>B<, int *>I<decpt>B<,> B<int "
"*>I<sign>B<);>"

#. type: Plain text
#: man-pages/man3/ecvt.3:51
msgid "B<ecvt>(), B<fcvt>():"
msgstr "B<ecvt>(), B<fcvt>():"

#. type: TP
#: man-pages/man3/ecvt.3:54
#, no-wrap
msgid "Since glibc 2.12:"
msgstr "Начиная с glibc 2.12:"

#. type: Plain text
#: man-pages/man3/ecvt.3:61
#, no-wrap
msgid ""
"_SVID_SOURCE ||\n"
"    (_XOPEN_SOURCE\\ E<gt>=\\ 500 ||\n"
"        _XOPEN_SOURCE\\ &&\\ _XOPEN_SOURCE_EXTENDED) &&\n"
"    !(_POSIX_C_SOURCE\\ E<gt>=\\ 200112L || _XOPEN_SOURCE\\ E<gt>=\\ 600)\n"
msgstr ""
"_SVID_SOURCE ||\n    (_XOPEN_SOURCE\\ E<gt>=\\ 500 ||\n        "
"_XOPEN_SOURCE\\ &&\\ _XOPEN_SOURCE_EXTENDED) &&\n    !(_POSIX_C_SOURCE\\ E<gt>"
"=\\ 200112L || _XOPEN_SOURCE\\ E<gt>=\\ 600)\n"

#. type: TP
#: man-pages/man3/ecvt.3:62
#, no-wrap
msgid "Before glibc 2.12:"
msgstr "До glibc 2.12:"

#. type: Plain text
#: man-pages/man3/ecvt.3:66
msgid ""
"_SVID_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 500 || _XOPEN_SOURCE\\ &&\\ "
"_XOPEN_SOURCE_EXTENDED"
msgstr ""
"_SVID_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 500 || _XOPEN_SOURCE\\ &&\\ "
"_XOPEN_SOURCE_EXTENDED"

#. type: Plain text
#: man-pages/man3/ecvt.3:92
msgid ""
"The B<ecvt>()  function converts I<number> to a null-terminated string of "
"I<ndigits> digits (where I<ndigits> is reduced to a system-specific limit "
"determined by the precision of a I<double>), and returns a pointer to the "
"string.  The high-order digit is nonzero, unless I<number> is zero.  The low"
" order digit is rounded.  The string itself does not contain a decimal "
"point; however, the position of the decimal point relative to the start of "
"the string is stored in I<*decpt>.  A negative value for I<*decpt> means "
"that the decimal point is to the left of the start of the string.  If the "
"sign of I<number> is negative, I<*sign> is set to a nonzero value, otherwise"
" it is set to 0.  If I<number> is zero, it is unspecified whether I<*decpt> "
"is 0 or 1."
msgstr ""
"Функция B<ecvt>() преобразует I<number> в строку с завершающим null-символом "
"I<ndigits> цифр (количество I<ndigits> усекается до пределов точности, "
"определённых форматом I<double>) и возвращает указатель на строку. Самый "
"старший разряд полученного числа не будет равен нулю, если только само число "
"I<number> не равно нулю. Самый младший разряд округляется. Строка сама по "
"себе не содержит разделителя целой и дробной части, однако позиция "
"разделителя относительно начала строки сохраняется в I<*decpt>. Отрицательное "
"значение I<*decpt> означает, что разделитель находится слева от начала "
"строки. Если число I<number> отрицательное, то I<*sign> устанавливается в "
"ненулевое значение, иначе равно нулю. Если I<number> равно нулю, то не "
"определено, равен ли I<*decpt> 0 или 1."

#. type: Plain text
#: man-pages/man3/ecvt.3:99
msgid ""
"The B<fcvt>()  function is identical to B<ecvt>(), except that I<ndigits> "
"specifies the number of digits after the decimal point."
msgstr ""
"Функция B<fcvt>() аналогична B<ecvt>(), за исключением того, что I<ndigits> "
"указывает число цифр после разделителя."

#. type: Plain text
#: man-pages/man3/ecvt.3:110
msgid ""
"Both the B<ecvt>()  and B<fcvt>()  functions return a pointer to a static "
"string containing the ASCII representation of I<number>.  The static string "
"is overwritten by each call to B<ecvt>()  or B<fcvt>()."
msgstr ""
"Обе функции, B<ecvt>() и B<fcvt>(), возвращают указатель на статическую "
"строку, содержащую ASCII-представление I<number>. Статическая строка "
"перезаписывается каждый раз при вызове B<ecvt>() или B<fcvt>()."

#. type: SH
#: man-pages/man3/ecvt.3:110
#, no-wrap
msgid "ATTRIBUTES"
msgstr "АТРИБУТЫ"

#. type: SS
#: man-pages/man3/ecvt.3:111
#, no-wrap
msgid "Multithreading (see pthreads(7))"
msgstr "Многонитевость (смотрите pthreads(7))"

#. type: Plain text
#: man-pages/man3/ecvt.3:117
msgid "The B<ecvt>()  and B<fcvt>()  functions are not thread-safe."
msgstr ""
"Функции B<ecvt>() и B<fcvt>() нельзя использовать в нескольких нитях "
"одновременно."

#. type: Plain text
#: man-pages/man3/ecvt.3:129
msgid ""
"SVr2; marked as LEGACY in POSIX.1-2001.  POSIX.1-2008 removes the "
"specifications of B<ecvt>()  and B<fcvt>(), recommending the use of "
"B<sprintf>(3)  instead (though B<snprintf>(3)  may be preferable)."
msgstr ""
"SVr2; отмечены как УНАСЛЕДОВАННЫЕ в POSIX.1-2001. В POSIX.1-2008 спецификации "
"B<ecvt>() и B<fcvt>() удалены, вместо них рекомендуется использовать B<"
"sprintf>(3) (однако B<snprintf>(3) может быть предпочтительнее)."

#. type: Plain text
#: man-pages/man3/ecvt.3:135
msgid ""
"Linux libc4 and libc5 specified the type of I<ndigits> as I<size_t>.  Not "
"all locales use a point as the radix character (\"decimal point\")."
msgstr ""
"В Linux libc4 и libc5 тип I<ndigits> указан как I<size_t>. Не все локали "
"используют точку в качестве разделителя целой и дробной части («десятичная "
"точка»)."

#. type: Plain text
#: man-pages/man3/ecvt.3:140
msgid "B<ecvt_r>(3), B<gcvt>(3), B<qecvt>(3), B<setlocale>(3), B<sprintf>(3)"
msgstr "B<ecvt_r>(3), B<gcvt>(3), B<qecvt>(3), B<setlocale>(3), B<sprintf>(3)"

#. type: TH
#: man-pages/man3/end.3:26
#, no-wrap
msgid "END"
msgstr "END"

#. type: TH
#: man-pages/man3/end.3:26
#, no-wrap
msgid "2008-07-17"
msgstr "2008-07-17"

#. type: TH
#: man-pages/man3/end.3:26
#, no-wrap
msgid "GNU"
msgstr "GNU"

#. type: Plain text
#: man-pages/man3/end.3:29
msgid "etext, edata, end - end of program segments"
msgstr "etext, edata, end - конец программных сегментов"

#. type: Plain text
#: man-pages/man3/end.3:34
#, no-wrap
msgid ""
"B<extern>I< etext>B<;>\n"
"B<extern>I< edata>B<;>\n"
"B<extern>I< end>B<;>\n"
msgstr "B<extern>I< etext>B<;>\nB<extern>I< edata>B<;>\nB<extern>I< end>B<;>\n"

#. type: Plain text
#: man-pages/man3/end.3:38
msgid ""
"The addresses of these symbols indicate the end of various program segments:"
msgstr ""
"Адреса этих символов соответствуют концам различных программных сегментов:"

#. type: TP
#: man-pages/man3/end.3:38
#, no-wrap
msgid "I<etext>"
msgstr "I<etext>"

#. type: Plain text
#: man-pages/man3/end.3:42
msgid ""
"This is the first address past the end of the text segment (the program "
"code)."
msgstr "Первый адрес за концом сегмента текста (кода программы)."

#. type: TP
#: man-pages/man3/end.3:42
#, no-wrap
msgid "I<edata>"
msgstr "I<edata>"

#. type: Plain text
#: man-pages/man3/end.3:46
msgid "This is the first address past the end of the initialized data segment."
msgstr "Первый адрес за концом сегмента инициализированных данных."

#. type: TP
#: man-pages/man3/end.3:46
#, no-wrap
msgid "I<end>"
msgstr "I<end>"

#. type: Plain text
#: man-pages/man3/end.3:50
msgid ""
"This is the first address past the end of the uninitialized data segment "
"(also known as the BSS segment)."
msgstr ""
"Первый адрес за концом сегмента неинициализированных данных (сегмента BSS)."

#. type: Plain text
#: man-pages/man3/end.3:53
msgid ""
"Although these symbols have long been provided on most UNIX systems, they "
"are not standardized; use with caution."
msgstr ""
"Хотя эти символы уже давно присутствуют в большинстве систем UNIX, они не "
"стандартизованы. Используйте осторожно."

#. type: Plain text
#: man-pages/man3/end.3:56
msgid ""
"The program must explicitly declare these symbols; they are not defined in "
"any header file."
msgstr ""
"Программа должна явно объявлять эти символы; они не определены в заголовочных "
"файлах."

#. type: Plain text
#: man-pages/man3/end.3:64
msgid ""
"On some systems the names of these symbols are preceded by underscores, "
"thus: I<_etext>, I<_edata>, and I<_end>.  These symbols are also defined for"
" programs compiled on Linux."
msgstr ""
"В некоторых системах имена этих символов начинаются с подчёркивания: I<_etext>"
", I<_edata> и I<_end>. Эти символы также определены в программах, "
"скомпонованных на Linux."

#. type: Plain text
#: man-pages/man3/end.3:76
msgid ""
"At the start of program execution, the program break will be somewhere near "
"I<&end> (perhaps at the start of the following page).  However, the break "
"will change as memory is allocated via B<brk>(2)  or B<malloc>(3).  Use "
"B<sbrk>(2)  with an argument of zero to find the current value of the "
"program break."
msgstr ""
"В начале выполнения программы, повреждение программы будет где-нибудь рядом c "
"I<&end> (возможно, в начале следующей страницы). Однако, поломка изменяет "
"память как при выделении с помощью B<brk>(2) или B<malloc>(3). Используйте B<"
"sbrk>(2) с аргументом 0 для поиска текущего значения поломки программы."

#. type: Plain text
#: man-pages/man3/end.3:78
msgid "When run, the program below produces output such as the following:"
msgstr "Нижеследующая программа выдает такие результаты:"

#. type: Plain text
#: man-pages/man3/end.3:86
#, no-wrap
msgid ""
"$B< ./a.out>\n"
"First address past:\n"
"    program text (etext)       0x8048568\n"
"    initialized data (edata)   0x804a01c\n"
"    uninitialized data (end)   0x804a024\n"
msgstr ""
"$B< ./a.out>\nFirst address past:\n    program text (etext)       0x8048568\n "
"   initialized data (edata)   0x804a01c\n    uninitialized data (end)   "
"0x804a024\n"

#. type: Plain text
#: man-pages/man3/end.3:96
#, no-wrap
msgid ""
"extern char etext, edata, end; /* The symbols must have some type,\n"
"                                   or \"gcc -Wall\" complains */\n"
msgstr ""
"extern char etext, edata, end; /* Символы должны иметь какой-то тип,\n        "
"                           иначе предупреждения от «gcc -Wall» */\n"

#. type: Plain text
#: man-pages/man3/end.3:104
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    printf(\"First address past:\\en\");\n"
"    printf(\"    program text (etext)      %10p\\en\", &etext);\n"
"    printf(\"    initialized data (edata)  %10p\\en\", &edata);\n"
"    printf(\"    uninitialized data (end)  %10p\\en\", &end);\n"
msgstr ""
"int\nmain(int argc, char *argv[])\n{\n    printf(\"First address "
"past:\\en\");\n    printf(\"    program text (etext)      %10p\\en\", "
"&etext);\n    printf(\"    initialized data (edata)  %10p\\en\", &edata);\n   "
" printf(\"    uninitialized data (end)  %10p\\en\", &end);\n"

#. type: Plain text
#: man-pages/man3/end.3:112
msgid "B<objdump>(1), B<readelf>(1), B<sbrk>(2), B<elf>(5)"
msgstr "B<objdump>(1), B<readelf>(1), B<sbrk>(2), B<elf>(5)"

#. type: TH
#: man-pages/man3/exit.3:29
#, no-wrap
msgid "EXIT"
msgstr "EXIT"

#. type: TH
#: man-pages/man3/exit.3:29
#, no-wrap
msgid "2014-03-25"
msgstr "2014-03-25"

#. type: Plain text
#: man-pages/man3/exit.3:32
msgid "exit - cause normal process termination"
msgstr "exit - вызывает нормальное завершение процесса"

#. type: Plain text
#: man-pages/man3/exit.3:35
#, no-wrap
msgid "B<#include E<lt>stdlib.hE<gt>>\n"
msgstr "B<#include E<lt>stdlib.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/exit.3:37
#, no-wrap
msgid "B<void exit(int >I<status>B<);>\n"
msgstr "B<void exit(int >I<status>B<);>\n"

#. type: Plain text
#: man-pages/man3/exit.3:45
msgid ""
"The B<exit>()  function causes normal process termination and the value of "
"I<status & 0377> is returned to the parent (see B<wait>(2))."
msgstr ""
"Функция B<exit>() выполняет нормальное завершение процесса и возвращает "
"значение I<status & 0377> породившему процессу (смотрите B<wait>(2))."

#. type: Plain text
#: man-pages/man3/exit.3:72
msgid ""
"All functions registered with B<atexit>(3)  and B<on_exit>(3)  are called, "
"in the reverse order of their registration.  (It is possible for one of "
"these functions to use B<atexit>(3)  or B<on_exit>(3)  to register an "
"additional function to be executed during exit processing; the new "
"registration is added to the front of the list of functions that remain to "
"be called.)  If one of these functions does not return (e.g., it calls "
"B<_exit>(2), or kills itself with a signal), then none of the remaining "
"functions is called, and further exit processing (in particular, flushing of"
" B<stdio>(3)  streams) is abandoned.  If a function has been registered "
"multiple times using B<atexit>(3)  or B<on_exit>(3), then it is called as "
"many times as it was registered."
msgstr ""
"Вызываются все функции, зарегистрированные с помощью B<atexit>(3) и B<on_exit>"
"(3), в обратном по отношению к регистрации порядке (в этих функциях возможно "
"использовать B<atexit>(3) или B<on_exit>(3) для регистрации дополнительной "
"функции, которая будет также вызвана при выходе; при этом она добавляется в "
"начало списка функций, которые осталось вызвать). Если из одной из функций не "
"происходит возврат (например, она вызывает B<_exit>(2) или завершает себя по "
"сигналу), то оставшиеся функции не вызываются, и дальнейший процесс выхода "
"прекращается (в частности, запись потоков B<stdio>(3)). Если функция "
"зарегистрирована с помощью B<atexit>(3) или B<on_exit>(3) несколько раз, то "
"она вызывается столько раз, сколько зарегистрирована."

#. type: Plain text
#: man-pages/man3/exit.3:79
msgid ""
"All open B<stdio>(3)  streams are flushed and closed.  Files created by "
"B<tmpfile>(3)  are removed."
msgstr ""
"Все открытые потоки B<stdio>(3) записываются и закрываются. Файлы, созданные "
"B<tmpfile>(3), удаляются."

#. type: Plain text
#: man-pages/man3/exit.3:86
msgid ""
"The C standard specifies two constants, B<EXIT_SUCCESS> and B<EXIT_FAILURE>,"
" that may be passed to B<exit>()  to indicate successful or unsuccessful "
"termination, respectively."
msgstr ""
"В стандарте Си определены две константы, B<EXIT_SUCCESS> и B<EXIT_FAILURE>, "
"которые можно передавать B<exit>() для указания корректности или "
"некорректности завершения, соответственно."

#. type: Plain text
#: man-pages/man3/exit.3:90
msgid "The B<exit>()  function does not return."
msgstr "Функция B<exit>() не возвращает выполнение."

#. type: Plain text
#: man-pages/man3/exit.3:96
msgid ""
"The B<exit>()  function uses a global variable that is not protected, so it "
"is not thread-safe."
msgstr ""
"Функция B<exit>() использует глобальную незащищённую переменную, поэтому "
"функцию нельзя использовать в нескольких нитях одновременно."

#. type: Plain text
#: man-pages/man3/exit.3:98
msgid "SVr4, 4.3BSD, POSIX.1-2001, C89, C99."
msgstr "SVr4, 4.3BSD, POSIX.1-2001, C89, C99."

#. type: Plain text
#: man-pages/man3/exit.3:115
msgid ""
"It is undefined what happens if one of the functions registered using "
"B<atexit>(3)  and B<on_exit>(3)  calls either B<exit>()  or B<longjmp>(3).  "
"Note that a call to B<execve>(2)  removes registrations created using "
"B<atexit>(3)  and B<on_exit>(3)."
msgstr ""
"Нигде не определено, что должно случиться, если одна из функций, "
"зарегистрированных с помощью B<atexit>(3) и B<on_exit>(3), вызовет B<exit>() "
"или B<longjmp>(3). Заметим, что вызов B<execve>(2) удаляет регистрацию "
"функций, сделанную с помощью B<atexit>(3) и B<on_exit>(3)."

#. type: Plain text
#: man-pages/man3/exit.3:124
msgid ""
"The use of B<EXIT_SUCCESS> and B<EXIT_FAILURE> is slightly more portable (to"
" non-UNIX environments) than the use of 0 and some nonzero value like 1 or "
"-1.  In particular, VMS uses a different convention."
msgstr ""
"Использование B<EXIT_SUCCESS> и B<EXIT_FAILURE> является более переносимым "
"методом (в не-UNIX окружения), чем указание 0 и какого-то ненулевого значения "
"(например, 1 или -1). В частности, в VMS используется другое соглашение."

#. type: Plain text
#: man-pages/man3/exit.3:127
msgid ""
"BSD has attempted to standardize exit codes; see the file "
"I<E<lt>sysexits.hE<gt>>."
msgstr ""
"В BSD пытались стандартизовать коды завершения; смотрите файл I<E<lt>"
"sysexits.hE<gt>>."

#. type: Plain text
#: man-pages/man3/exit.3:152
msgid ""
"After B<exit>(), the exit status must be transmitted to the parent process."
"  There are three cases.  If the parent has set B<SA_NOCLDWAIT>, or has set "
"the B<SIGCHLD> handler to B<SIG_IGN>, the status is discarded.  If the "
"parent was waiting on the child, it is notified of the exit status.  In both"
" cases the exiting process dies immediately.  If the parent has not "
"indicated that it is not interested in the exit status, but is not waiting, "
"the exiting process turns into a \"zombie\" process (which is nothing but a "
"container for the single byte representing the exit status) so that the "
"parent can learn the exit status when it later calls one of the B<wait>(2)  "
"functions."
msgstr ""
"После B<exit>() код завершения должен передаваться родительскому процессу. "
"Есть три случая. Если родитель установил флаг B<SA_NOCLDWAIT> или задал "
"обработчик B<SIGCHLD> равным B<SIG_IGN>, то код отбрасывается. Если родитель "
"ждал потомка, то ему возвращается код завершения. В обоих случаях процесс в "
"стадии выхода сразу завершается. Если родитель не указал, что ему не нужен "
"код завершения, и он не выполняет ожидание, то завершающийся процесс "
"превращается в «зомби» (который ничего не делает, но хранит один байт с кодом "
"завершения) для того, чтобы родитель мог прочитать код завершения позднее с "
"помощью одного из вызовов B<wait>(2)."

#. type: Plain text
#: man-pages/man3/exit.3:162
msgid ""
"If the implementation supports the B<SIGCHLD> signal, this signal is sent to"
" the parent.  If the parent has set B<SA_NOCLDWAIT>, it is undefined whether"
" a B<SIGCHLD> signal is sent."
msgstr ""
"Если в реализации поддерживается сигнал B<SIGCHLD>, то он посылается "
"родителю. Если родитель установил флаг B<SA_NOCLDWAIT>, то поведение при "
"сигнале B<SIGCHLD> не определено."

#. type: Plain text
#: man-pages/man3/exit.3:171
msgid ""
"If the process is a session leader and its controlling terminal is the "
"controlling terminal of the session, then each process in the foreground "
"process group of this controlling terminal is sent a B<SIGHUP> signal, and "
"the terminal is disassociated from this session, allowing it to be acquired "
"by a new controlling process."
msgstr ""
"Если процесс является лидером сеанса и управляющим терминала сеанса, то "
"каждому процессу из группы фонового режима этого управляющего терминала "
"посылается сигнал B<SIGHUP>, и терминал отключается от сеанса, чтобы его "
"можно было захватить новому управляющему процессу."

#. type: Plain text
#: man-pages/man3/exit.3:183
msgid ""
"If the exit of the process causes a process group to become orphaned, and if"
" any member of the newly orphaned process group is stopped, then a B<SIGHUP>"
" signal followed by a B<SIGCONT> signal will be sent to each process in this"
" process group.  See B<setpgid>(2)  for an explanation of orphaned process "
"groups."
msgstr ""
"Если завершение процесса приводит к осиротению группы процессов, и если любой "
"член только что осиротевшей группы останавливается, то каждому процессу этой "
"группы после сигнала B<SIGHUP> будет послан сигнал B<SIGCONT>. Описание "
"процесса осиротения группы смотрите в B<setpgid>(2)."

#. type: Plain text
#: man-pages/man3/exit.3:189
msgid ""
"B<_exit>(2), B<setpgid>(2), B<wait>(2), B<atexit>(3), B<on_exit>(3), "
"B<tmpfile>(3)"
msgstr ""
"B<_exit>(2), B<setpgid>(2), B<wait>(2), B<atexit>(3), B<on_exit>(3), B<"
"tmpfile>(3)"

#. type: TH
#: man-pages/man3/endian.3:28
#, no-wrap
msgid "ENDIAN"
msgstr "ENDIAN"

#. type: TH
#: man-pages/man3/endian.3:28
#, no-wrap
msgid "2010-09-10"
msgstr "2010-09-10"

#. type: Plain text
#: man-pages/man3/endian.3:33
msgid ""
"htobe16, htole16, be16toh, le16toh, htobe32, htole32, be32toh, le32toh, "
"htobe64, htole64, be64toh, le64toh - convert values between host and big"
"-/little-endian byte order"
msgstr ""
"htobe16, htole16, be16toh, le16toh, htobe32, htole32, be32toh, le32toh, "
"htobe64, htole64, be64toh, le64toh - изменяет порядок байт у целого числа"

#. type: Plain text
#: man-pages/man3/endian.3:37
#, no-wrap
msgid ""
"B<#define _BSD_SOURCE>             /* See feature_test_macros(7) */\n"
"B<#include E<lt>endian.hE<gt>>\n"
msgstr ""
"B<#define _BSD_SOURCE>             /* См. feature_test_macros(7) */\nB<"
"#include E<lt>endian.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/endian.3:42
#, no-wrap
msgid ""
"B<uint16_t htobe16(uint16_t >I<host_16bits>B<);>\n"
"B<uint16_t htole16(uint16_t >I<host_16bits>B<);>\n"
"B<uint16_t be16toh(uint16_t >I<big_endian_16bits>B<);>\n"
"B<uint16_t le16toh(uint16_t >I<little_endian_16bits>B<);>\n"
msgstr ""
"B<uint16_t htobe16(uint16_t >I<host_16bits>B<);>\nB<uint16_t htole16(uint16_t "
">I<host_16bits>B<);>\nB<uint16_t be16toh(uint16_t >I<big_endian_16bits>B<);>"
"\nB<uint16_t le16toh(uint16_t >I<little_endian_16bits>B<);>\n"

#. type: Plain text
#: man-pages/man3/endian.3:47
#, no-wrap
msgid ""
"B<uint32_t htobe32(uint32_t >I<host_32bits>B<);>\n"
"B<uint32_t htole32(uint32_t >I<host_32bits>B<);>\n"
"B<uint32_t be32toh(uint32_t >I<big_endian_32bits>B<);>\n"
"B<uint32_t le32toh(uint32_t >I<little_endian_32bits>B<);>\n"
msgstr ""
"B<uint32_t htobe32(uint32_t >I<host_32bits>B<);>\nB<uint32_t htole32(uint32_t "
">I<host_32bits>B<);>\nB<uint32_t be32toh(uint32_t >I<big_endian_32bits>B<);>"
"\nB<uint32_t le32toh(uint32_t >I<little_endian_32bits>B<);>\n"

#. type: Plain text
#: man-pages/man3/endian.3:52
#, no-wrap
msgid ""
"B<uint64_t htobe64(uint64_t >I<host_64bits>B<);>\n"
"B<uint64_t htole64(uint64_t >I<host_64bits>B<);>\n"
"B<uint64_t be64toh(uint64_t >I<big_endian_64bits>B<);>\n"
"B<uint64_t le64toh(uint64_t >I<little_endian_64bits>B<);>\n"
msgstr ""
"B<uint64_t htobe64(uint64_t >I<host_64bits>B<);>\nB<uint64_t htole64(uint64_t "
">I<host_64bits>B<);>\nB<uint64_t be64toh(uint64_t >I<big_endian_64bits>B<);>"
"\nB<uint64_t le64toh(uint64_t >I<little_endian_64bits>B<);>\n"

#. type: Plain text
#: man-pages/man3/endian.3:57
msgid ""
"These functions convert the byte encoding of integer values from the byte "
"order that the current CPU (the \"host\") uses, to and from little-endian "
"and big-endian byte order."
msgstr ""
"Эти функции преобразуют кодирование байт целых значений из/в порядок байт, "
"используемом в работающем ЦП («порядок байт узла»), от младшего к старшему "
"(little-endian) и от старшего к младшему (big-endian)."

#. type: Plain text
#: man-pages/man3/endian.3:62
msgid ""
"The number, I<nn>, in the name of each function indicates the size of "
"integer handled by the function, either 16, 32, or 64 bits."
msgstr ""
"Число I<nn> в имени каждой функции показывает размер целого, с которым "
"работает функция — может быть 16, 32 или 64 бита."

#. type: Plain text
#: man-pages/man3/endian.3:65
msgid ""
"The functions with names of the form \"htobeI<nn>\" convert from host byte "
"order to big-endian order."
msgstr ""
"Функции с именами вида «htobeI<nn>» преобразуют число с порядком байт узла в "
"число с порядком байт от старшего к младшему."

#. type: Plain text
#: man-pages/man3/endian.3:68
msgid ""
"The functions with names of the form \"htoleI<nn>\" convert from host byte "
"order to little-endian order."
msgstr ""
"Функции с именами вида «htoleI<nn>» преобразуют число с порядком байт узла в "
"число с порядком байт от младшего к старшему."

#. type: Plain text
#: man-pages/man3/endian.3:71
msgid ""
"The functions with names of the form \"beI<nn>toh\" convert from big-endian "
"order to host byte order."
msgstr ""
"Функции с именами вида «beI<nn>toh» преобразуют число с порядком байт от "
"старшего к младшему в число с порядком байт узла."

#. type: Plain text
#: man-pages/man3/endian.3:74
msgid ""
"The functions with names of the form \"leI<nn>toh\" convert from little-"
"endian order to host byte order."
msgstr ""
"Функции с именами вида «leI<nn>toh» преобразуют число с порядком байт от "
"младшего к старшему в число с порядком байт узла."

#. type: Plain text
#: man-pages/man3/endian.3:76
msgid "These functions were added to glibc in version 2.9."
msgstr "Эти функции добавлены в glibc версии 2.9."

#. type: Plain text
#: man-pages/man3/endian.3:91
msgid ""
"These functions are nonstandard.  Similar functions are present on the BSDs,"
" where the required header file is I<E<lt>sys/endian.hE<gt>> instead of "
"I<E<lt>endian.hE<gt>>.  Unfortunately, NetBSD, FreeBSD, and glibc haven't "
"followed the original OpenBSD naming convention for these functions, whereby"
" the I<nn> component always appears at the end of the function name (thus, "
"for example, in NetBSD, FreeBSD, and glibc, the equivalent of OpenBSDs "
"\"betoh32\" is \"be32toh\")."
msgstr ""
"Это нестандартные функции. Подобные функции есть в BSD, где вместо I<E<lt>"
"endian.hE<gt>> для них требуется заголовочный файл I<E<lt>sys/endian.hE<gt>>. "
"К сожалению, NetBSD, FreeBSD и glibc не следуют изначальному соглашению об "
"именах функций в OpenBSD, где часть I<nn> всегда находится в конце имени "
"функции (то есть, например, в NetBSD, FreeBSD и glibc используется «be32toh» "
"вместо эквивалентной «betoh32» из OpenBSD)."

#. type: Plain text
#: man-pages/man3/endian.3:99
msgid ""
"These functions are similar to the older B<byteorder>(3)  family of "
"functions.  For example, B<be32toh>()  is identical to B<ntohl>()."
msgstr ""
"Данные функции похожи на функции старого семейства B<byteorder>(3). Например, "
"B<be32toh>() идентична B<ntohl>()."

#. type: Plain text
#: man-pages/man3/endian.3:107
msgid ""
"The advantage of the B<byteorder>(3)  functions is that they are standard "
"functions available on all UNIX systems.  On the other hand, the fact that "
"they were designed for use in the context of TCP/IP means that they lack the"
" 64-bit and little-endian variants described in this page."
msgstr ""
"Преимущество функций B<byteorder>(3) в том, что они являются стандартными и "
"доступны во всех системах UNIX. С другой стороны, тот факт, что они "
"разрабатывались для использования в контексте TCP/IP означает, что среди них "
"нет функций для 64-битных значений и чисел с порядком байт от младшего к "
"старшему, описанных в этой странице."

#. type: Plain text
#: man-pages/man3/endian.3:114
msgid ""
"The program below display the results of converting an integer from host "
"byte order to both little-endian and big-endian byte order.  Since host byte"
" order is either little-endian or big-endian, only one of these conversions "
"will have an effect.  When we run this program on a little-endian system "
"such as x86-32, we see the following:"
msgstr ""
"Ниже представлена программа, которая выводит результаты преобразования целого "
"с порядком байт узла в целое с порядком байт от младшего к старшему и от "
"старшего к младшему. Так как порядок байт узла будет эквивалентен порядку от "
"младшего к старшему или от старшего к младшему, то реально выполняется только "
"одно преобразование. Если эта программа запускается на системе с порядком "
"байт от младшего к старшему, например x86-32, то мы увидим следующее:"

#. type: Plain text
#: man-pages/man3/endian.3:121
#, no-wrap
msgid ""
"$ B<./a.out>\n"
"x.u32 = 0x44332211\n"
"htole32(x.u32) = 0x44332211\n"
"htobe32(x.u32) = 0x11223344\n"
msgstr ""
"$ B<./a.out>\nx.u32 = 0x44332211\nhtole32(x.u32) = 0x44332211\nhtobe32(x.u32) "
"= 0x11223344\n"

#. type: Plain text
#: man-pages/man3/endian.3:130
#, no-wrap
msgid ""
"#include E<lt>endian.hE<gt>\n"
"#include E<lt>stdint.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
msgstr ""
"#include E<lt>endian.hE<gt>\n#include E<lt>stdint.hE<gt>\n#include E<lt>"
"stdio.hE<gt>\n#include E<lt>stdlib.hE<gt>\n"

#. type: Plain text
#: man-pages/man3/endian.3:138
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    union {\n"
"        uint32_t u32;\n"
"        uint8_t arr[4];\n"
"    } x;\n"
msgstr ""
"int\nmain(int argc, char *argv[])\n{\n    union {\n        uint32_t u32;\n    "
"    uint8_t arr[4];\n    } x;\n"

#. type: Plain text
#: man-pages/man3/endian.3:143
#, no-wrap
msgid ""
"    x.arr[0] = 0x11;\t/* Lowest-address byte */\n"
"    x.arr[1] = 0x22;\n"
"    x.arr[2] = 0x33;\n"
"    x.arr[3] = 0x44;\t/* Highest-address byte */\n"
msgstr ""
"    x.arr[0] = 0x11;\t/* низший адресуемый байт */\n    x.arr[1] = 0x22;\n    "
"x.arr[2] = 0x33;\n    x.arr[3] = 0x44;\t/* высший адресуемый байт */\n"

#. type: Plain text
#: man-pages/man3/endian.3:147
#, no-wrap
msgid ""
"    printf(\"x.u32 = 0x%x\\en\", x.u32);\n"
"    printf(\"htole32(x.u32) = 0x%x\\en\", htole32(x.u32));\n"
"    printf(\"htobe32(x.u32) = 0x%x\\en\", htobe32(x.u32));\n"
msgstr ""
"    printf(\"x.u32 = 0x%x\\en\", x.u32);\n    printf(\"htole32(x.u32) = 0x%"
"x\\en\", htole32(x.u32));\n    printf(\"htobe32(x.u32) = 0x%x\\en\", "
"htobe32(x.u32));\n"

#. type: Plain text
#: man-pages/man3/endian.3:152
msgid "B<byteorder>(3)"
msgstr "B<byteorder>(3)"

#. type: TH
#: man-pages/man3/encrypt.3:30
#, no-wrap
msgid "ENCRYPT"
msgstr "ENCRYPT"

#. type: TH
#: man-pages/man3/encrypt.3:30
#, no-wrap
msgid "2013-07-22"
msgstr "2013-07-22"

#. type: Plain text
#: man-pages/man3/encrypt.3:33
msgid "encrypt, setkey, encrypt_r, setkey_r - encrypt 64-bit messages"
msgstr "encrypt, setkey, encrypt_r, setkey_r - шифрование 64-битных сообщений"

#. type: Plain text
#: man-pages/man3/encrypt.3:35 man-pages/man3/encrypt.3:41
msgid "B<#define _XOPEN_SOURCE> /* See feature_test_macros(7) */"
msgstr "B<#define _XOPEN_SOURCE> /* См. feature_test_macros(7) */"

#. type: Plain text
#: man-pages/man3/encrypt.3:39
msgid "B<void encrypt(char >I<block>B<[64], int >I<edflag>B<);>"
msgstr "B<void encrypt(char >I<block>B<[64], int >I<edflag>B<);>"

#. type: Plain text
#: man-pages/man3/encrypt.3:45
msgid "B<void setkey(const char *>I<key>B<);>"
msgstr "B<void setkey(const char *>I<key>B<);>"

#. type: Plain text
#: man-pages/man3/encrypt.3:47
msgid "B<#define _GNU_SOURCE> /* See feature_test_macros(7) */"
msgstr "B<#define _GNU_SOURCE> /* смотрите feature_test_macros(7) */"

#. type: Plain text
#: man-pages/man3/encrypt.3:49
msgid "B<#include E<lt>crypt.hE<gt>>"
msgstr "B<#include E<lt>crypt.hE<gt>>"

#. type: Plain text
#: man-pages/man3/encrypt.3:51
msgid "B<void setkey_r(const char *>I<key>B<, struct crypt_data *>I<data>B<);>"
msgstr ""
"B<void setkey_r(const char *>I<key>B<, struct crypt_data *>I<data>B<);>"

#. type: Plain text
#: man-pages/man3/encrypt.3:54
msgid ""
"B<void encrypt_r(char *>I<block>B<, int >I<edflag>B<, struct crypt_data "
"*>I<data>B<);>"
msgstr ""
"B<void encrypt_r(char *>I<block>B<, int >I<edflag>B<, struct crypt_data *>I<"
"data>B<);>"

#. type: Plain text
#: man-pages/man3/encrypt.3:56
msgid "Each of these requires linking with I<-lcrypt>."
msgstr "Для любой функции требуется компоновка с параметром I<-lcrypt>."

#. type: Plain text
#: man-pages/man3/encrypt.3:68
msgid ""
"These functions encrypt and decrypt 64-bit messages.  The B<setkey>()  "
"function sets the key used by B<encrypt>().  The I<key> argument used here "
"is an array of 64 bytes, each of which has numerical value 1 or 0.  The "
"bytes key[n] where n=8*i-1 are ignored, so that the effective key length is "
"56 bits."
msgstr ""
"Эти функции кодируют и декодируют 64-битные сообщения. Функцией B<setkey>() "
"задаётся ключ, который затем используется B<encrypt>(). Параметр I<key> "
"является массивом из 64 байтов, каждый из которых имеет значение 1 или 0. "
"Байты key[n], где n=8*i-1 — игнорируются, так что действительная длина ключа "
"равна 56 битам."

#. type: Plain text
#: man-pages/man3/encrypt.3:80
msgid ""
"The B<encrypt>()  function modifies the passed buffer, encoding if I<edflag>"
" is 0, and decoding if 1 is being passed.  Like the I<key> argument, also "
"I<block> is a bit vector representation of the actual value that is encoded."
"  The result is returned in that same vector."
msgstr ""
"Функция B<encrypt>() изменяет переданный буфер и, если значение I<edflag> "
"равно 0, то кодирует его, а если равно 1 — то декодирует. Как и параметр I<"
"key>, аргумент I<block> также является представлением битового вектора "
"действительного кодируемого значения. Результат возвращается в этом же "
"векторе."

#. type: Plain text
#: man-pages/man3/encrypt.3:90
msgid ""
"These two functions are not reentrant, that is, the key data is kept in "
"static storage.  The functions B<setkey_r>()  and B<encrypt_r>()  are the "
"reentrant versions.  They use the following structure to hold the key data:"
msgstr ""
"Эти две функции не являются повторно используемыми, то есть данные ключа "
"хранятся в статическом хранилище. Функции B<setkey_r>() и B<encrypt_r>() "
"являются повторно используемыми версиями. Они используют следующую структуру "
"для хранения данных ключа:"

#. type: Plain text
#: man-pages/man3/encrypt.3:105
#, no-wrap
msgid ""
"struct crypt_data {\n"
"    char     keysched[16 * 8];\n"
"    char     sb0[32768];\n"
"    char     sb1[32768];\n"
"    char     sb2[32768];\n"
"    char     sb3[32768];\n"
"    char     crypt_3_buf[14];\n"
"    char     current_salt[2];\n"
"    long int current_saltbits;\n"
"    int      direction;\n"
"    int      initialized;\n"
"};\n"
msgstr ""
"struct crypt_data {\n    char     keysched[16 * 8];\n    char     "
"sb0[32768];\n    char     sb1[32768];\n    char     sb2[32768];\n    char     "
"sb3[32768];\n    char     crypt_3_buf[14];\n    char     current_salt[2];\n   "
" long int current_saltbits;\n    int      direction;\n    int      "
"initialized;\n};\n"

#. type: Plain text
#: man-pages/man3/encrypt.3:113
msgid "Before calling B<setkey_r>()  set I<data-E<gt>initialized> to zero."
msgstr "Перед вызовом B<setkey_r>() обнулите I<data-E<gt>initialized>."

#. type: Plain text
#: man-pages/man3/encrypt.3:115
msgid "These functions do not return any value."
msgstr "Данные функции не возвращают никаких значений."

#. type: Plain text
#: man-pages/man3/encrypt.3:120
msgid ""
"Set I<errno> to zero before calling the above functions.  On success, it is "
"unchanged."
msgstr ""
"Установите переменную I<errno> в ноль перед вызовом этих функций. При "
"нормальном завершении работы её значение не изменится."

#. type: TP
#: man-pages/man3/encrypt.3:120
#, no-wrap
msgid "B<ENOSYS>"
msgstr "B<ENOSYS>"

#. type: Plain text
#: man-pages/man3/encrypt.3:124
msgid ""
"The function is not provided.  (For example because of former USA export "
"restrictions.)"
msgstr ""
"Функция не предусмотрена (например, из-за старых запретов США на экспорт)."

#. type: Plain text
#: man-pages/man3/encrypt.3:131
msgid "The B<encrypt>()  and B<setkey>()  functions are not thread-safe."
msgstr ""
"Функции B<encrypt>() и B<setkey>() нельзя использовать в нескольких нитях "
"одновременно."

#. type: Plain text
#: man-pages/man3/encrypt.3:137
msgid "The B<encrypt_r>()  and B<setkey_r>()  functions are thread-safe."
msgstr ""
"Функции B<encrypt_r>() и B<setkey_r>()можно использовать в нескольких нитях "
"одновременно."

#. type: Plain text
#: man-pages/man3/encrypt.3:148
msgid ""
"The functions B<encrypt>()  and B<setkey>()  conform to SVr4, SUSv2, and "
"POSIX.1-2001.  The functions B<encrypt_r>()  and B<setkey_r>()  are GNU "
"extensions."
msgstr ""
"Функции B<encrypt>() и B<setkey>() соответствуют SVr4, SUSv2 и POSIX.1-2001. "
"Функции B<encrypt_r>() и B<setkey_r>() являются расширениями GNU."

#. type: Plain text
#: man-pages/man3/encrypt.3:150
msgid "In glibc 2.2, these functions use the DES algorithm."
msgstr "В glibc 2.2 в данных функциях используется алгоритм DES."

#. type: Plain text
#: man-pages/man3/encrypt.3:157
msgid ""
"You need to link with libcrypt to compile this example with glibc.  To do "
"useful work, the I<key[]> and I<txt[]> arrays must be filled with a useful "
"bit pattern."
msgstr ""
"Чтобы собрать данный пример с glibc необходима компоновка с libcrypt. Для "
"правильной работы массивы I<key[]> и I<txt[]> должны быть заполнены полезным "
"битовым шаблоном."

#. type: Plain text
#: man-pages/man3/encrypt.3:162
#, no-wrap
msgid ""
"#define _XOPEN_SOURCE\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
msgstr ""
"#define _XOPEN_SOURCE\n#include E<lt>unistd.hE<gt>\n#include E<lt>stdlib.hE<"
"gt>\n"

#. type: Plain text
#: man-pages/man3/encrypt.3:168
#, no-wrap
msgid ""
"int\n"
"main(void)\n"
"{\n"
"    char key[64];      /* bit pattern for key */\n"
"    char txt[64];      /* bit pattern for messages */\n"
msgstr ""
"int\nmain(void)\n{\n    char key[64];      /* битовый шаблон для ключа */\n   "
" char txt[64];      /* битовый шаблон для сообщений */\n"

#. type: Plain text
#: man-pages/man3/encrypt.3:173
#, no-wrap
msgid ""
"    setkey(key);\n"
"    encrypt(txt, 0);   /* encode */\n"
"    encrypt(txt, 1);   /* decode */\n"
"}\n"
msgstr ""
"    setkey(key);\n    encrypt(txt, 0);   /* шифровать */\n    encrypt(txt, "
"1);   /* расшифровать */\n}\n"

#. type: Plain text
#: man-pages/man3/encrypt.3:177
msgid "B<cbc_crypt>(3), B<crypt>(3), B<ecb_crypt>(3),"
msgstr "B<cbc_crypt>(3), B<crypt>(3), B<ecb_crypt>(3),"

#. type: TH
#: man-pages/man3/ether_aton.3:31
#, no-wrap
msgid "ETHER_ATON"
msgstr "ETHER_ATON"

#. type: Plain text
#: man-pages/man3/ether_aton.3:35
msgid ""
"ether_aton, ether_ntoa, ether_ntohost, ether_hostton, ether_line, "
"ether_ntoa_r, ether_aton_r - Ethernet address manipulation routines"
msgstr ""
"ether_aton, ether_ntoa, ether_ntohost, ether_hostton, ether_line, "
"ether_ntoa_r, ether_aton_r - процедуры для работы с адресами ethernet"

#. type: Plain text
#: man-pages/man3/ether_aton.3:38
#, no-wrap
msgid "B<#include E<lt>netinet/ether.hE<gt>>\n"
msgstr "B<#include E<lt>netinet/ether.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/ether_aton.3:40
#, no-wrap
msgid "B<char *ether_ntoa(const struct ether_addr *>I<addr>B<);>\n"
msgstr "B<char *ether_ntoa(const struct ether_addr *>I<addr>B<);>\n"

#. type: Plain text
#: man-pages/man3/ether_aton.3:42
#, no-wrap
msgid "B<struct ether_addr *ether_aton(const char *>I<asc>B<);>\n"
msgstr "B<struct ether_addr *ether_aton(const char *>I<asc>B<);>\n"

#. type: Plain text
#: man-pages/man3/ether_aton.3:44
#, no-wrap
msgid ""
"B<int ether_ntohost(char *>I<hostname>B<, const struct ether_addr "
"*>I<addr>B<);>\n"
msgstr ""
"B<int ether_ntohost(char *>I<hostname>B<, const struct ether_addr *>I<addr>B<"
");>\n"

#. type: Plain text
#: man-pages/man3/ether_aton.3:46
#, no-wrap
msgid ""
"B<int ether_hostton(const char *>I<hostname>B<, struct ether_addr "
"*>I<addr>B<);>\n"
msgstr ""
"B<int ether_hostton(const char *>I<hostname>B<, struct ether_addr *>I<addr>B<"
");>\n"

#. type: Plain text
#: man-pages/man3/ether_aton.3:49
#, no-wrap
msgid ""
"B<int ether_line(const char *>I<line>B<, struct ether_addr *>I<addr>B<,>\n"
"B<               char *>I<hostname>B<);>\n"
msgstr ""
"B<int ether_line(const char *>I<line>B<, struct ether_addr *>I<addr>B<,>\nB<  "
"             char *>I<hostname>B<);>\n"

#. type: Plain text
#: man-pages/man3/ether_aton.3:51
#, no-wrap
msgid "/* GNU extensions */\n"
msgstr "/* расширения GNU */\n"

#. type: Plain text
#: man-pages/man3/ether_aton.3:53
#, no-wrap
msgid ""
"B<char *ether_ntoa_r(const struct ether_addr *>I<addr>B<, char "
"*>I<buf>B<);>\n"
msgstr ""
"B<char *ether_ntoa_r(const struct ether_addr *>I<addr>B<, char *>I<buf>B<);>\n"

#. type: Plain text
#: man-pages/man3/ether_aton.3:56
#, no-wrap
msgid ""
"B<struct ether_addr *ether_aton_r(const char *>I<asc>B<,>\n"
"B<                                struct ether_addr *>I<addr>B<);>\n"
msgstr ""
"B<struct ether_addr *ether_aton_r(const char *>I<asc>B<,>\nB<                 "
"               struct ether_addr *>I<addr>B<);>\n"

#. type: Plain text
#: man-pages/man3/ether_aton.3:67
msgid ""
"B<ether_aton>()  converts the 48-bit Ethernet host address I<asc> from the "
"standard hex-digits-and-colons notation into binary data in network byte "
"order and returns a pointer to it in a statically allocated buffer, which "
"subsequent calls will overwrite.  B<ether_aton>()  returns NULL if the "
"address is invalid."
msgstr ""
"Функция B<ether_aton>() преобразует 48-битный адрес узла Ethernet I<asc> из "
"стандартной записи в виде шестнадцатеричных-символов-и-двоеточий в двоичный "
"код с сетевым порядком расположения байтов и возвращает указатель на него в "
"статически выделенном буфере, который могут изменить любые последующие "
"вызовы. Функция B<ether_aton>() возвращает NULL, если адрес некорректен."

#. type: Plain text
#: man-pages/man3/ether_aton.3:76
msgid ""
"The B<ether_ntoa>()  function converts the Ethernet host address I<addr> "
"given in network byte order to a string in standard hex-digits-and-colons "
"notation, omitting leading zeros.  The string is returned in a statically "
"allocated buffer, which subsequent calls will overwrite."
msgstr ""
"Функция B<ether_ntoa>() преобразует адрес узла Ethernet I<addr>, заданный "
"значением с сетевым порядком байтов, в строку в стандартной форме записи в "
"виде шестнадцатеричных-символов-и-двоеточий. Строка возвращается в статически "
"выделяемом буфере, который перезаписывается при последующих вызовах."

#. type: Plain text
#: man-pages/man3/ether_aton.3:83
msgid ""
"The B<ether_ntohost>()  function maps an Ethernet address to the "
"corresponding hostname in I</etc/ethers> and returns nonzero if it cannot be"
" found."
msgstr ""
"Функция B<ether_ntohost>() для заданного адреса Ethernet ищет соответствующее "
"имя узла в файле I</etc/ethers> и возвращает ненулевое значение, если оно не "
"может быть найдено."

#. type: Plain text
#: man-pages/man3/ether_aton.3:90
msgid ""
"The B<ether_hostton>()  function maps a hostname to the corresponding "
"Ethernet address in I</etc/ethers> and returns nonzero if it cannot be "
"found."
msgstr ""
"Функция B<ether_hostton>() для заданного имени узла ищет соответствующий "
"адрес Ethernet в файле I</etc/ethers> и возвращает ненулевое значение, если "
"он не может быть найден."

#. type: Plain text
#: man-pages/man3/ether_aton.3:102
msgid ""
"The B<ether_line>()  function parses a line in I</etc/ethers> format "
"(ethernet address followed by whitespace followed by hostname; \\(aq#\\(aq "
"introduces a comment) and returns an address and hostname pair, or nonzero "
"if it cannot be parsed.  The buffer pointed to by I<hostname> must be "
"sufficiently long, for example, have the same length as I<line>."
msgstr ""
"Функция B<ether_line>() обрабатывает строку в формате файла I</etc/ethers> "
"(адрес Ethernet, пробельный символ, имя узла; комментарий начинается с "
"\\(aq#\\(aq) и возвращает пару адрес/имя узла, или ненулевое значение, если "
"строка не может быть обработана. Буфер, на который указывает I<hostname>, "
"должен быть достаточно большим, чтобы вместить, например, строку I<line>."

#. type: Plain text
#: man-pages/man3/ether_aton.3:113
msgid ""
"The functions B<ether_ntoa_r>()  and B<ether_aton_r>()  are reentrant "
"thread-safe versions of B<ether_ntoa>()  and B<ether_aton>()  respectively, "
"and do not use static buffers."
msgstr ""
"Функции B<ether_ntoa_r>() и B<ether_aton_r>() являются безопасными для "
"использования в нитях аналогами B<ether_ntoa>() и B<ether_aton>() "
"соответственно, и не используют статических буферов."

#. type: Plain text
#: man-pages/man3/ether_aton.3:119
msgid ""
"The structure I<ether_addr> is defined in I<E<lt>net/ethernet.hE<gt>> as:"
msgstr "Структура I<ether_addr> определена в I<E<lt>net/ethernet.hE<gt>>:"

#. type: Plain text
#: man-pages/man3/ether_aton.3:125
#, no-wrap
msgid ""
"struct ether_addr {\n"
"    uint8_t ether_addr_octet[6];\n"
"}\n"
msgstr "struct ether_addr {\n    uint8_t ether_addr_octet[6];\n}\n"

#. type: Plain text
#: man-pages/man3/ether_aton.3:130
msgid ""
"For an explanation of the terms used in this section, see B<attributes>(7)."
msgstr "Описание терминов данного раздела смотрите в B<attributes>(7)."

#. type: tbl table
#: man-pages/man3/ether_aton.3:135
#, no-wrap
msgid "Interface\tAttribute\tValue\n"
msgstr "Интерфейс\tАтрибут\tЗначение\n"

#. type: tbl table
#: man-pages/man3/ether_aton.3:136 man-pages/man3/ether_aton.3:140
#, no-wrap
msgid "T{\n"
msgstr "T{\n"

#. type: tbl table
#: man-pages/man3/ether_aton.3:137
#, no-wrap
msgid "B<ether_aton>(),\n"
msgstr "B<ether_aton>(),\n"

#. type: tbl table
#: man-pages/man3/ether_aton.3:138
#, no-wrap
msgid "B<ether_ntoa>()\n"
msgstr "B<ether_ntoa>()\n"

#. type: tbl table
#: man-pages/man3/ether_aton.3:139
#, no-wrap
msgid "T}\tThread safety\tMT-Unsafe\n"
msgstr "T}\tбезвредность в нитях\tнебезопасно (MT-Unsafe)\n"

#. type: tbl table
#: man-pages/man3/ether_aton.3:141
#, no-wrap
msgid "B<ether_ntohost>(),\n"
msgstr "B<ether_ntohost>(),\n"

#. type: tbl table
#: man-pages/man3/ether_aton.3:142
#, no-wrap
msgid "B<ether_hostton>(),\n"
msgstr "B<ether_hostton>(),\n"

#. type: tbl table
#: man-pages/man3/ether_aton.3:143
#, no-wrap
msgid "B<ether_line>(),\n"
msgstr "B<ether_line>(),\n"

#. type: tbl table
#: man-pages/man3/ether_aton.3:144
#, no-wrap
msgid "B<ether_ntoa_r>(),\n"
msgstr "B<ether_ntoa_r>(),\n"

#. type: tbl table
#: man-pages/man3/ether_aton.3:145
#, no-wrap
msgid "B<ether_aton_r>()\n"
msgstr "B<ether_aton_r>()\n"

#. type: tbl table
#: man-pages/man3/ether_aton.3:146
#, no-wrap
msgid "T}\tThread safety\tMT-Safe\n"
msgstr "T}\tбезвредность в нитях\tбезвредно (MT-Safe)\n"

#. type: Plain text
#: man-pages/man3/ether_aton.3:151
msgid "4.3BSD, SunOS."
msgstr "4.3BSD, SunOS."

#.  The fix was presumably commit c0a0f9a32c8baa6ab93d00eb42d92c02e9e146d7
#.  which was in glibc 2.3
#. type: Plain text
#: man-pages/man3/ether_aton.3:157
msgid ""
"In glibc 2.2.5 and earlier, the implementation of B<ether_line>()  is "
"broken."
msgstr "В glibc 2.2.5 и старее реализация B<ether_line>() некорректна."

#. type: Plain text
#: man-pages/man3/ether_aton.3:158
msgid "B<ethers>(5)"
msgstr "B<ethers>(5)"

#. type: TH
#: man-pages/man3/ecvt_r.3:30
#, no-wrap
msgid "ECVT_R"
msgstr "ECVT_R"

#. type: TH
#: man-pages/man3/ecvt_r.3:30
#, no-wrap
msgid "2007-07-26"
msgstr "2007-07-26"

#. type: Plain text
#: man-pages/man3/ecvt_r.3:33
msgid ""
"ecvt_r, fcvt_r, qecvt_r, qfcvt_r - convert a floating-point number to a "
"string"
msgstr ""
"ecvt_r, fcvt_r, qecvt_r, qfcvt_r - преобразует число с плавающей запятой в "
"строку"

#. type: Plain text
#: man-pages/man3/ecvt_r.3:39
#, no-wrap
msgid ""
"B<int ecvt_r(double >I<number>B<, int >I<ndigits>B<, int *>I<decpt>B<,>\n"
"B<           int *>I<sign>B<, char *>I<buf>B<, size_t >I<len>B<);>\n"
msgstr ""
"B<int ecvt_r(double >I<number>B<, int >I<ndigits>B<, int *>I<decpt>B<,>\nB<   "
"        int *>I<sign>B<, char *>I<buf>B<, size_t >I<len>B<);>\n"

#. type: Plain text
#: man-pages/man3/ecvt_r.3:42
#, no-wrap
msgid ""
"B<int fcvt_r(double >I<number>B<, int >I<ndigits>B<, int *>I<decpt>B<,>\n"
"B<           int *>I<sign>B<, char *>I<buf>B<, size_t >I<len>B<);>\n"
msgstr ""
"B<int fcvt_r(double >I<number>B<, int >I<ndigits>B<, int *>I<decpt>B<,>\nB<   "
"        int *>I<sign>B<, char *>I<buf>B<, size_t >I<len>B<);>\n"

#. type: Plain text
#: man-pages/man3/ecvt_r.3:45
#, no-wrap
msgid ""
"B<int qecvt_r(long double >I<number>B<, int >I<ndigits>B<, int *>I<decpt>B<,>"
"\n"
"B<           int *>I<sign>B<, char *>I<buf>B<, size_t >I<len>B<);>\n"
msgstr ""
"B<int qecvt_r(long double >I<number>B<, int >I<ndigits>B<, int *>I<decpt>B<,>"
"\nB<           int *>I<sign>B<, char *>I<buf>B<, size_t >I<len>B<);>\n"

#. type: Plain text
#: man-pages/man3/ecvt_r.3:48
#, no-wrap
msgid ""
"B<int qfcvt_r(long double >I<number>B<, int >I<ndigits>B<, int *>I<decpt>B<,>"
"\n"
"B<           int *>I<sign>B<, char *>I<buf>B<, size_t >I<len>B<);>\n"
msgstr ""
"B<int qfcvt_r(long double >I<number>B<, int >I<ndigits>B<, int *>I<decpt>B<,>"
"\nB<           int *>I<sign>B<, char *>I<buf>B<, size_t >I<len>B<);>\n"

#. type: Plain text
#: man-pages/man3/ecvt_r.3:60
msgid "B<ecvt_r>(), B<fcvt_r>(), B<qecvt_r>(), B<qfcvt_r>():"
msgstr "B<ecvt_r>(), B<fcvt_r>(), B<qecvt_r>(), B<qfcvt_r>():"

#. type: Plain text
#: man-pages/man3/ecvt_r.3:62
msgid "_SVID_SOURCE || _BSD_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 500"
msgstr "_SVID_SOURCE || _BSD_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 500"

#. type: Plain text
#: man-pages/man3/ecvt_r.3:86
msgid ""
"The functions B<ecvt_r>(), B<fcvt_r>(), B<qecvt_r>()  and B<qfcvt_r>()  are "
"identical to B<ecvt>(3), B<fcvt>(3), B<qecvt>(3)  and B<qfcvt>(3), "
"respectively, except that they do not return their result in a static "
"buffer, but instead use the supplied I<buf> of size I<len>.  See B<ecvt>(3)"
"  and B<qecvt>(3)."
msgstr ""
"Функции B<ecvt_r>(), B<fcvt_r>(), B<qecvt_r>() и B<qfcvt_r>() идентичны "
"функциям B<ecvt>(3), B<fcvt>(3), B<qecvt>(3) и B<qfcvt>(3), соответственно, "
"за исключением того, что они не возвращают результаты в статическом буфере, а "
"вместо этого используют указанный I<buf> размером I<len>. Смотрите B<ecvt>(3) "
"и B<qecvt>(3)."

#. type: Plain text
#: man-pages/man3/ecvt_r.3:88
msgid "These functions return 0 on success, and -1 otherwise."
msgstr "При успешном выполнении эти функции возвращают 0 и 1 при ошибке."

#. type: Plain text
#: man-pages/man3/ecvt_r.3:90
msgid "These functions are GNU extensions."
msgstr "Эти функции являются расширениями GNU."

#. type: Plain text
#: man-pages/man3/ecvt_r.3:95
msgid "These functions are obsolete.  Instead, B<sprintf>(3)  is recommended."
msgstr ""
"Данные функции устарели. Вместо них рекомендуется использовать B<sprintf>(3)."

#. type: Plain text
#: man-pages/man3/ecvt_r.3:98
msgid "B<ecvt>(3), B<qecvt>(3), B<sprintf>(3)"
msgstr "B<ecvt>(3), B<qecvt>(3), B<sprintf>(3)"

#. type: TH
#: man-pages/man3/exec.3:41
#, no-wrap
msgid "EXEC"
msgstr "EXEC"

#. type: TH
#: man-pages/man3/exec.3:41
#, no-wrap
msgid "2010-09-25"
msgstr "2010-09-25"

#. type: Plain text
#: man-pages/man3/exec.3:44
msgid "execl, execlp, execle, execv, execvp, execvpe - execute a file"
msgstr ""
"execl, execlp, execle, execv, execvp, execvpe - запуск файла на исполнение"

#. type: Plain text
#: man-pages/man3/exec.3:48
msgid "B<extern char **environ;>"
msgstr "B<extern char **environ;>"

#. type: Plain text
#: man-pages/man3/exec.3:50
msgid "B<int execl(const char *>I<path>B<, const char *>I<arg>B<, ...);>"
msgstr "B<int execl(const char *>I<path>B<, const char *>I<arg>B<, ...);>"

#. type: Plain text
#: man-pages/man3/exec.3:52
msgid "B<int execlp(const char *>I<file>B<, const char *>I<arg>B<, ...);>"
msgstr "B<int execlp(const char *>I<file>B<, const char *>I<arg>B<, ...);>"

#. type: Plain text
#: man-pages/man3/exec.3:54
msgid "B<int execle(const char *>I<path>B<, const char *>I<arg>B<,>"
msgstr "B<int execle(const char *>I<path>B<, const char *>I<arg>B<,>"

#. type: Plain text
#: man-pages/man3/exec.3:56
msgid "B< ..., char * const >I<envp>B<[]);>"
msgstr "B< ..., char * const >I<envp>B<[]);>"

#. type: Plain text
#: man-pages/man3/exec.3:58
msgid "B<int execv(const char *>I<path>B<, char *const >I<argv>B<[]);>"
msgstr "B<int execv(const char *>I<path>B<, char *const >I<argv>B<[]);>"

#. type: Plain text
#: man-pages/man3/exec.3:60
msgid "B<int execvp(const char *>I<file>B<, char *const >I<argv>B<[]);>"
msgstr "B<int execvp(const char *>I<file>B<, char *const >I<argv>B<[]);>"

#. type: Plain text
#: man-pages/man3/exec.3:62
msgid "B<int execvpe(const char *>I<file>B<, char *const >I<argv>B<[],>"
msgstr "B<int execvpe(const char *>I<file>B<, char *const >I<argv>B<[],>"

#. type: Plain text
#: man-pages/man3/exec.3:72
msgid "B<execvpe>(): _GNU_SOURCE"
msgstr "B<execvpe>(): _GNU_SOURCE"

#. type: Plain text
#: man-pages/man3/exec.3:82
msgid ""
"The B<exec>()  family of functions replaces the current process image with a"
" new process image.  The functions described in this manual page are front-"
"ends for B<execve>(2).  (See the manual page for B<execve>(2)  for further "
"details about the replacement of the current process image.)"
msgstr ""
"Семейство функций B<exec>() заменяет текущий образ процесса новым. Описанные "
"в данной справочной странице функции являются оберткой для B<execve>(2) "
"(подробней о см. замене текущего смотрите в справочной странице B<execve>(2))."

#. type: Plain text
#: man-pages/man3/exec.3:85
msgid ""
"The initial argument for these functions is the name of a file that is to be"
" executed."
msgstr "Первый аргумент этих функций - имя исполняемого файла."

#. type: Plain text
#: man-pages/man3/exec.3:107
msgid ""
"The I<const char\\ *arg> and subsequent ellipses in the B<execl>(), "
"B<execlp>(), and B<execle>()  functions can be thought of as I<arg0>, "
"I<arg1>, \\&..., I<argn>.  Together they describe a list of one or more "
"pointers to null-terminated strings that represent the argument list "
"available to the executed program.  The first argument, by convention, "
"should point to the filename associated with the file being executed.  The "
"list of arguments I<must> be terminated by a null pointer, and, since these "
"are variadic functions, this pointer must be cast I<(char\\ *) NULL>."
msgstr ""
"Параметр I<const char\\ *arg> и последующие параметры в функциях B<execl>(), "
"B<execlp>() и B<execle>() можно воспринимать как параметры I<arg0>, I<arg1>, "
"\\&..., I<argn>. Все вместе они описывают список из одного или нескольких "
"указателей на строки (заканчивающиеся null), который представляет собой "
"список параметров, доступных исполняемой программе. Первый параметр, по "
"соглашению, должен указывать на имя, ассоциированное с файлом, который надо "
"запустить. Список параметров I<должен> заканчиваться указателем null и, так "
"как это функция с переменным числом аргументов, этот указатель должен "
"приводиться к I<(char\\ *) NULL>."

#. type: Plain text
#: man-pages/man3/exec.3:120
msgid ""
"The B<execv>(), B<execvp>(), and B<execvpe>()  functions provide an array of"
" pointers to null-terminated strings that represent the argument list "
"available to the new program.  The first argument, by convention, should "
"point to the filename associated with the file being executed.  The array of"
" pointers I<must> be terminated by a null pointer."
msgstr ""
"Функции B<execv>(), B<execvp>() и B<execvpe>() предоставляют новой программе "
"список аргументов в виде массива указателей на строки, заканчивающиеся null. "
"Первый аргумент, по соглашению, должен указать на имя, ассоциированное с "
"файлом, который необходимо запустить. Массив указателей I<должен> "
"заканчиваться указателем null."

#. type: Plain text
#: man-pages/man3/exec.3:137
msgid ""
"The B<execle>()  and B<execvpe>()  functions allow the caller to specify the"
" environment of the executed program via the argument I<envp>.  The I<envp> "
"argument is an array of pointers to null-terminated strings and I<must> be "
"terminated by a null pointer.  The other functions take the environment for "
"the new process image from the external variable I<environ> in the calling "
"process."
msgstr ""
"Функции B<execle>() и B<execvpe>() позволяют вызывающему назначить окружение "
"исполняемой программе через параметр I<envp>. Аргумент I<envp> является "
"массивом указателей на строки (завершающиеся null), он I<должен> "
"заканчиваться указателем null. Остальные функции извлекают окружение для "
"нового образа процесса из внешней переменной I<environ> вызвавшего процесса."

#. type: SS
#: man-pages/man3/exec.3:137
#, no-wrap
msgid "Special semantics for execlp() and execvp()"
msgstr "Особая семантика execlp() и execvp()"

#. type: Plain text
#: man-pages/man3/exec.3:157
msgid ""
"The B<execlp>(), B<execvp>(), and B<execvpe>()  functions duplicate the "
"actions of the shell in searching for an executable file if the specified "
"filename does not contain a slash (/) character.  The file is sought in the "
"colon-separated list of directory pathnames specified in the B<PATH> "
"environment variable.  If this variable isn't defined, the path list "
"defaults to the current directory followed by the list of directories "
"returned by I<confstr(_CS_PATH)>.  (This B<confstr>(3)  call typically "
"returns the value \"/bin:/usr/bin\".)"
msgstr ""
"Функции B<execlp>(), B<execvp>() и B<execvpe>() дублируют действия оболочки, "
"относящиеся к поиску исполняемого файла, если указанное имя файла не содержит "
"символ черты (/). Путь поиска задаётся в переменной окружения B<PATH> (список "
"каталогов, перечисленных через двоеточие). Если эта переменная не определена, "
"то по умолчанию к текущему каталогу добавляется список каталогов, "
"возвращаемый I<confstr(_CS_PATH)> (вызов B<confstr>(3) обычно возвращает "
"значение «/bin:/usr/bin»)."

#. type: Plain text
#: man-pages/man3/exec.3:161
msgid ""
"If the specified filename includes a slash character, then B<PATH> is "
"ignored, and the file at the specified pathname is executed."
msgstr ""
"Если указанное имя файла содержит в себе символ косой черты, переменная B<"
"PATH> будет проигнорирована, и будет запущен файл по указанному пути."

#. type: Plain text
#: man-pages/man3/exec.3:163
msgid "In addition, certain errors are treated specially."
msgstr "Кроме этого, есть отличия в обработке некоторых ошибок."

#. type: Plain text
#: man-pages/man3/exec.3:174
msgid ""
"If permission is denied for a file (the attempted B<execve>(2)  failed with "
"the error B<EACCES>), these functions will continue searching the rest of "
"the search path.  If no other file is found, however, they will return with "
"I<errno> set to B<EACCES>."
msgstr ""
"Если доступ к файлу запрещён (при попытке исполнения B<execve>(2) "
"возвращается ошибка B<EACCES>), то эти функции будут продолжать поиск в "
"оставшихся путях. Однако, если больше никаких файлов не найдено, то они "
"присваивают значение глобальной переменной I<errno> равным B<EACCES>."

#. type: Plain text
#: man-pages/man3/exec.3:183
msgid ""
"If the header of a file isn't recognized (the attempted B<execve>(2)  failed"
" with the error B<ENOEXEC>), these functions will execute the shell "
"(I</bin/sh>)  with the path of the file as its first argument.  (If this "
"attempt fails, no further searching is done.)"
msgstr ""
"Если заголовок файла не распознаётся (при попытке выполнения B<execve>(2) "
"возвращает B<ENOEXEC>), то эти функции запускают оболочку (I</bin/sh>) с "
"полным именем файла в качестве первого параметра (если это тоже приводит к "
"ошибке, то поиск останавливается)."

#. type: Plain text
#: man-pages/man3/exec.3:190
msgid ""
"The B<exec>()  functions return only if an error has occurred.  The return "
"value is -1, and I<errno> is set to indicate the error."
msgstr ""
"Функции B<exec>() возвращают значение только при возникновении ошибки. При "
"этом возвращается -1, а I<errno> присваивается код ошибки."

#. type: Plain text
#: man-pages/man3/exec.3:195
msgid ""
"All of these functions may fail and set I<errno> for any of the errors "
"specified for B<execve>(2)."
msgstr ""
"Все функции могут завершиться с ошибкой и присвоить I<errno> значения любых "
"ошибок B<execve>(2)."

#. type: Plain text
#: man-pages/man3/exec.3:199
msgid "The B<execvpe>()  function first appeared in glibc 2.11."
msgstr "Функция B<execvpe>() впервые появилась в glibc 2.11."

#. type: Plain text
#: man-pages/man3/exec.3:201
msgid "POSIX.1-2001, POSIX.1-2008."
msgstr "POSIX.1-2001, POSIX.1-2008."

#. type: Plain text
#: man-pages/man3/exec.3:205
msgid "The B<execvpe>()  function is a GNU extension."
msgstr "Функция B<execvpe>() является расширением GNU."

#. type: Plain text
#: man-pages/man3/exec.3:215
msgid ""
"On some other systems, the default path (used when the environment does not "
"contain the variable B<PATH>) has the current working directory listed after"
" I</bin> and I</usr/bin>, as an anti-Trojan-horse measure.  Linux uses here "
"the traditional \"current directory first\" default path."
msgstr ""
"В некоторых системах путь поиска по умолчанию (используемый, когда в "
"окружении нет переменной B<PATH>) начинается c каталогов I</bin> и I</usr/bin>"
", а затем поиск проводится в текущем каталоге (чтобы не запустить подложенную "
"программу «троянского коня»). В Linux используется традиционный метод: поиск "
"начинается с текущего каталога."

#. type: Plain text
#: man-pages/man3/exec.3:229
msgid ""
"The behavior of B<execlp>()  and B<execvp>()  when errors occur while "
"attempting to execute the file is historic practice, but has not "
"traditionally been documented and is not specified by the POSIX standard.  "
"BSD (and possibly other systems) do an automatic sleep and retry if "
"B<ETXTBSY> is encountered.  Linux treats it as a hard error and returns "
"immediately."
msgstr ""
"Поведение функций B<execlp>() и B<execvp>() при ошибках во время попыток "
"исполнения файла сложилось исторически, но при этом оно не описано и не "
"определено в стандарте POSIX. В BSD (и, возможно, других системах) "
"выполняется автоматическое ожидание и повтор, если возникает ошибка B<ETXTBSY>"
". В Linux это воспринимается как невосстановимая ошибка, и она сразу "
"возвращается."

#. type: Plain text
#: man-pages/man3/exec.3:241
msgid ""
"Traditionally, the functions B<execlp>()  and B<execvp>()  ignored all "
"errors except for the ones described above and B<ENOMEM> and B<E2BIG>, upon "
"which they returned.  They now return if any error other than the ones "
"described above occurs."
msgstr ""
"Традиционно, функции B<execlp>() и B<execvp>() игнорировали все ошибки за "
"исключением описанных выше, а также B<ENOMEM> и B<E2BIG>, которые они "
"возвращают. В Linux эти функции возвращают любую ошибку, помимо перечисленных "
"ранее."

#. type: Plain text
#: man-pages/man3/exec.3:247
msgid ""
"B<sh>(1), B<execve>(2), B<fork>(2), B<ptrace>(2), B<fexecve>(3), "
"B<environ>(7)"
msgstr ""
"B<sh>(1), B<execve>(2), B<fork>(2), B<ptrace>(2), B<fexecve>(3), B<environ>(7)"

#. type: TH
#: man-pages/man3/exp.3:36
#, no-wrap
msgid "EXP"
msgstr "EXP"

#. type: Plain text
#: man-pages/man3/exp.3:39
msgid "exp, expf, expl - base-e exponential function"
msgstr "exp, expf, expl - функция вычисления экспоненты"

#. type: Plain text
#: man-pages/man3/exp.3:44
#, no-wrap
msgid "B<double exp(double >I<x>B<);>\n"
msgstr "B<double exp(double >I<x>B<);>\n"

#. type: Plain text
#: man-pages/man3/exp.3:46
#, no-wrap
msgid "B<float expf(float >I<x>B<);>\n"
msgstr "B<float expf(float >I<x>B<);>\n"

#. type: Plain text
#: man-pages/man3/exp.3:48
#, no-wrap
msgid "B<long double expl(long double >I<x>B<);>\n"
msgstr "B<long double expl(long double >I<x>B<);>\n"

#. type: Plain text
#: man-pages/man3/exp.3:60
msgid "B<expf>(), B<expl>():"
msgstr "B<expf>(), B<expl>():"

#. type: Plain text
#: man-pages/man3/exp.3:63
msgid ""
"_BSD_SOURCE || _SVID_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 600 || "
"_ISOC99_SOURCE || _POSIX_C_SOURCE\\ E<gt>=\\ 200112L;"
msgstr ""
"_BSD_SOURCE || _SVID_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 600 || _ISOC99_SOURCE "
"|| _POSIX_C_SOURCE\\ E<gt>=\\ 200112L;"

#. type: Plain text
#: man-pages/man3/exp.3:74
msgid ""
"The B<exp>()  function returns the value of e (the base of natural "
"logarithms) raised to the power of I<x>."
msgstr ""
"Функция B<exp>() возвращает значение e (основание натурального логарифма), "
"возведённое в степень I<x>."

#. type: Plain text
#: man-pages/man3/exp.3:77
msgid "On success, these functions return the exponential value of I<x>."
msgstr ""
"При успешном выполнении данные функции возвращают экспоненту от числа I<x>."

#. type: Plain text
#: man-pages/man3/exp.3:82
msgid "If I<x> is a NaN, a NaN is returned."
msgstr "Если I<x> имеет значение NaN, будет возвращено NaN."

#. type: Plain text
#: man-pages/man3/exp.3:87
msgid "If I<x> is positive infinity, positive infinity is returned."
msgstr ""
"Если I<x> стремится к плюс бесконечности, то будет возвращена плюс "
"бесконечность."

#. type: Plain text
#: man-pages/man3/exp.3:92
msgid "If I<x> is negative infinity, +0 is returned."
msgstr "Если I<x> равно минус бесконечности, возвращается +0."

#. type: Plain text
#: man-pages/man3/exp.3:96
msgid "If the result underflows, a range error occurs, and zero is returned."
msgstr ""
"Если в результате исчезает порядок числа, возникает ошибка диапазона и "
"возвращается ноль."

#. type: Plain text
#: man-pages/man3/exp.3:105
msgid ""
"If the result overflows, a range error occurs, and the functions return "
"+B<HUGE_VAL>, +B<HUGE_VALF>, or +B<HUGE_VALL>, respectively."
msgstr ""
"Если в результате превышена разрядность, то возникает ошибка диапазона и "
"функции возвращают +B<HUGE_VAL>, +B<HUGE_VALF> или +B<HUGE_VALL>, "
"соответственно."

#. type: Plain text
#: man-pages/man3/exp.3:112
msgid "The following errors can occur:"
msgstr "Могут возникать следующие ошибки:"

#. type: TP
#: man-pages/man3/exp.3:112
#, no-wrap
msgid "Range error, overflow"
msgstr "Ошибка диапазона, переполнение"

#. type: Plain text
#: man-pages/man3/exp.3:120
msgid ""
"I<errno> is set to B<ERANGE>.  An overflow floating-point exception "
"(B<FE_OVERFLOW>)  is raised."
msgstr ""
"Значение I<errno> устанавливается в B<ERANGE>. Возникает исключение "
"переполнения плавающей точки (B<FE_OVERFLOW>)."

#. type: TP
#: man-pages/man3/exp.3:120
#, no-wrap
msgid "Range error, underflow"
msgstr "Ошибка диапазона, исчезновение порядка"

#. type: Plain text
#: man-pages/man3/exp.3:128
msgid ""
"I<errno> is set to B<ERANGE>.  An underflow floating-point exception "
"(B<FE_UNDERFLOW>)  is raised."
msgstr ""
"Значение I<errno> устанавливается в B<ERANGE>. Возникает исключение "
"исчезновение порядка плавающей точки (B<FE_UNDERFLOW>)."

#. type: Plain text
#: man-pages/man3/exp.3:139
msgid "B<cbrt>(3), B<cexp>(3), B<exp10>(3), B<exp2>(3), B<sqrt>(3)"
msgstr "B<cbrt>(3), B<cexp>(3), B<exp10>(3), B<exp2>(3), B<sqrt>(3)"

#. type: TH
#: man-pages/man3/envz_add.3:10
#, no-wrap
msgid "ENVZ_ADD"
msgstr "ENVZ_ADD"

#. type: TH
#: man-pages/man3/envz_add.3:10
#, no-wrap
msgid "2014-05-28"
msgstr "2014-05-28"

#. type: Plain text
#: man-pages/man3/envz_add.3:14
msgid ""
"envz_add, envz_entry, envz_get, envz_merge, envz_remove, envz_strip - "
"environment string support"
msgstr ""
"envz_add, envz_entry, envz_get, envz_merge, envz_remove, envz_strip - "
"поддержка строк окружения"

#. type: Plain text
#: man-pages/man3/envz_add.3:17
#, no-wrap
msgid "B<#include E<lt>envz.hE<gt>>\n"
msgstr "B<#include E<lt>envz.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/envz_add.3:20
#, no-wrap
msgid ""
"B<error_t envz_add(char **>I<envz>B<, size_t *>I<envz_len>B<,>\n"
"B<                 const char *>I<name>B<, const char *>I<value>B<);>\n"
msgstr ""
"B<error_t envz_add(char **>I<envz>B<, size_t *>I<envz_len>B<,>\nB<            "
"     const char *>I<name>B<, const char *>I<value>B<);>\n"

#. type: Plain text
#: man-pages/man3/envz_add.3:23
#, no-wrap
msgid ""
"B<char *envz_entry(const char *>I<envz>B<, size_t >I<envz_len>B<, const char"
" *>I<name>B<);>\n"
msgstr ""
"B<char *envz_entry(const char *>I<envz>B<, size_t >I<envz_len>B<, const char "
"*>I<name>B<);>\n"

#. type: Plain text
#: man-pages/man3/envz_add.3:26
#, no-wrap
msgid ""
"B<char *envz_get(const char *>I<envz>B<, size_t >I<envz_len>B<, const char "
"*>I<name>B<);>\n"
msgstr ""
"B<char *envz_get(const char *>I<envz>B<, size_t >I<envz_len>B<, const char *>"
"I<name>B<);>\n"

#. type: Plain text
#: man-pages/man3/envz_add.3:30
#, no-wrap
msgid ""
"B<error_t envz_merge(char **>I<envz>B<, size_t *>I<envz_len>B<,>\n"
"B<                   const char *>I<envz2>B<, size_t >I<envz2_len>B<, int >I<"
"override>B<);>\n"
msgstr ""
"B<error_t envz_merge(char **>I<envz>B<, size_t *>I<envz_len>B<,>\nB<          "
"         const char *>I<envz2>B<, size_t >I<envz2_len>B<, int >I<override>B<"
");>\n"

#. type: Plain text
#: man-pages/man3/envz_add.3:33
#, no-wrap
msgid ""
"B<void envz_remove(char **>I<envz>B<, size_t *>I<envz_len>B<, const char "
"*>I<name>B<);>\n"
msgstr ""
"B<void envz_remove(char **>I<envz>B<, size_t *>I<envz_len>B<, const char *>I<"
"name>B<);>\n"

#. type: Plain text
#: man-pages/man3/envz_add.3:35
#, no-wrap
msgid "B<void envz_strip(char **>I<envz>B<, size_t *>I<envz_len>B<);>\n"
msgstr "B<void envz_strip(char **>I<envz>B<, size_t *>I<envz_len>B<);>\n"

#. type: Plain text
#: man-pages/man3/envz_add.3:38
msgid "These functions are glibc-specific."
msgstr "Эти функции есть только в glibc."

#. type: Plain text
#: man-pages/man3/envz_add.3:48
msgid ""
"An argz vector is a pointer to a character buffer together with a length, "
"see B<argz_add>(3).  An envz vector is a special argz vector, namely one "
"where the strings have the form \"name=value\".  Everything after the first "
"\\(aq=\\(aq is considered to be the value.  If there is no \\(aq=\\(aq, the "
"value is taken to be NULL.  (While the value in case of a trailing "
"\\(aq=\\(aq is the empty string \"\".)"
msgstr ""
"Вектор argz представляет собой указатель на символьный буфер и его длину "
"(смотрите B<argz_add>(3)). Вектор envz является особым вектором argz, в нём "
"содержатся строки вида «имя=значение». Всё, что расположено за первым "
"\\(aq=\\(aq, считается значением. Если \\(aq=\\(aq отсутствует, то значение "
"считается равным NULL (если \\(aq=\\(aq указано в конце, то значение равно "
"пустой строке \"\")."

#. type: Plain text
#: man-pages/man3/envz_add.3:50
msgid "These functions are for handling envz vectors."
msgstr "Эти функции предназначены для работы с векторами envz."

#. type: Plain text
#: man-pages/man3/envz_add.3:69
msgid ""
"B<envz_add>()  adds the string \"I<name>=I<value>\" (in case I<value> is "
"non-NULL) or \"I<name>\" (in case I<value> is NULL) to the envz vector "
"(I<*envz>,\\ I<*envz_len>)  and updates I<*envz> and I<*envz_len>.  If an "
"entry with the same I<name> existed, it is removed."
msgstr ""
"Функция B<envz_add>() добавляет строку \"I<name>=I<value>\" (если I<name> не "
"равно NULL) или \"I<name>\" (если I<value> равно NULL) в вектор envz (I<*envz>"
",\\ I<*envz_len>) и обновляет I<*envz> и I<*envz_len>. Если запись с таким "
"значением I<name> уже существует, то она удаляется."

#. type: Plain text
#: man-pages/man3/envz_add.3:76
msgid ""
"B<envz_entry>()  looks for I<name> in the envz vector (I<envz>,\\ "
"I<envz_len>)  and returns the entry if found, or NULL if not."
msgstr ""
"Функция B<envz_entry>() ищет значение I<name> в векторе envz (I<envz>,\\ I<"
"envz_len>) и возвращает запись, если такое имя найдено, и NULL, если не "
"найдено."

#. type: Plain text
#: man-pages/man3/envz_add.3:87
msgid ""
"B<envz_get>()  looks for I<name> in the envz vector (I<envz>,\\ I<envz_len>)"
"  and returns the value if found, or NULL if not.  (Note that the value can "
"also be NULL, namely when there is an entry for I<name> without \\(aq=\\(aq "
"sign.)"
msgstr ""
"Функция B<envz_get>() ищет значение I<name> в векторе envz (I<envz>,\\ I<"
"envz_len>) и возвращает значение, если такое имя найдено, и NULL, если не "
"найдено (заметим, что значение само по себе может быть равно NULL, особенно, "
"если есть запись для I<name> без знака \\(aq=\\(aq)."

#. type: Plain text
#: man-pages/man3/envz_add.3:102
msgid ""
"B<envz_merge>()  adds each entry in I<envz2> to I<*envz>, as if with "
"B<envz_add>().  If I<override> is true, then values in I<envz2> will "
"supersede those with the same name in I<*envz>, otherwise not."
msgstr ""
"Функция B<envz_merge>() добавляет все записи из I<envz2> в I<*envz>, как если "
"бы это делалось с помощью B<envz_add>(). Если значение I<override> истинно, "
"то значения в I<envz2> будут заменять значения с такими же именами в I<*envz>"
", иначе — нет."

#. type: Plain text
#: man-pages/man3/envz_add.3:109
msgid ""
"B<envz_remove>()  removes the entry for I<name> from (I<*envz>,\\ "
"I<*envz_len>)  if there was one."
msgstr ""
"Функция B<envz_remove>() удаляет запись для I<name> из (I<*envz>,\\ I<"
"*envz_len>), если она есть."

#. type: Plain text
#: man-pages/man3/envz_add.3:112
msgid "B<envz_strip>()  removes all entries with value NULL."
msgstr "Функция B<envz_strip>() удаляет все записи со значением NULL."

#. type: Plain text
#: man-pages/man3/envz_add.3:118
msgid ""
"All envz functions that do memory allocation have a return type of "
"I<error_t>, and return 0 for success, and B<ENOMEM> if an allocation error "
"occurs."
msgstr ""
"Все функции envz, в которых происходит выделение памяти, возвращают "
"результат, имеющий тип I<error_t>: 0 — при успешном выполнении и B<ENOMEM> — "
"при ошибке выделения памяти."

#. type: Plain text
#: man-pages/man3/envz_add.3:121
msgid "These functions are a GNU extension.  Handle with care."
msgstr "Данные функции являются расширениями GNU. Используйте с осторожностью."

#. type: Plain text
#: man-pages/man3/envz_add.3:126
#, no-wrap
msgid ""
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>envz.hE<gt>\n"
msgstr ""
"#include E<lt>stdio.hE<gt>\n#include E<lt>stdlib.hE<gt>\n#include E<lt>"
"envz.hE<gt>\n"

#. type: Plain text
#: man-pages/man3/envz_add.3:132
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[], char *envp[])\n"
"{\n"
"    int i, e_len = 0;\n"
"    char *str;\n"
msgstr ""
"int\nmain(int argc, char *argv[], char *envp[])\n{\n    int i, e_len = 0;\n   "
" char *str;\n"

#. type: Plain text
#: man-pages/man3/envz_add.3:135
#, no-wrap
msgid ""
"    for (i = 0; envp[i] != NULL; i++)\n"
"        e_len += strlen(envp[i]) + 1;\n"
msgstr ""
"    for (i = 0; envp[i] != NULL; i++)\n        e_len += strlen(envp[i]) + 1;\n"

#. type: Plain text
#: man-pages/man3/envz_add.3:142
#, no-wrap
msgid ""
"    str = envz_entry(*envp, e_len, \"HOME\");\n"
"    printf(\"%s\\en\", str);\n"
"    str = envz_get(*envp, e_len, \"HOME\");\n"
"    printf(\"%s\\en\", str);\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""
"    str = envz_entry(*envp, e_len, \"HOME\");\n    printf(\"%s\\en\", str);\n "
"   str = envz_get(*envp, e_len, \"HOME\");\n    printf(\"%s\\en\", str);\n    "
"exit(EXIT_SUCCESS);\n}\n"

#. type: Plain text
#: man-pages/man3/envz_add.3:144
msgid "B<argz_add>(3)"
msgstr "B<argz_add>(3)"

#. type: TH
#: man-pages/man3/error.3:27
#, no-wrap
msgid "ERROR"
msgstr "ERROR"

#. type: TH
#: man-pages/man3/error.3:27
#, no-wrap
msgid "2010-08-29"
msgstr "2010-08-29"

#. type: Plain text
#: man-pages/man3/error.3:31
msgid ""
"error, error_at_line, error_message_count, error_one_per_line, "
"error_print_progname - glibc error reporting functions"
msgstr ""
"error, error_at_line, error_message_count, error_one_per_line, "
"error_print_progname - функции вывода ошибок glibc"

#. type: Plain text
#: man-pages/man3/error.3:34
#, no-wrap
msgid "B<#include E<lt>error.hE<gt>>\n"
msgstr "B<#include E<lt>error.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/error.3:36
#, no-wrap
msgid ""
"B<void error(int >I<status>B<, int >I<errnum>B<, const char *>I<format>B<, "
"...);>\n"
msgstr ""
"B<void error(int >I<status>B<, int >I<errnum>B<, const char *>I<format>B<, "
"...);>\n"

#. type: Plain text
#: man-pages/man3/error.3:39
#, no-wrap
msgid ""
"B<void error_at_line(int >I<status>B<, int >I<errnum>B<, const char *>I<"
"filename>B<,>\n"
"B<                   unsigned int >I<linenum>B<, const char *>I<format>B<, "
"...);>\n"
msgstr ""
"B<void error_at_line(int >I<status>B<, int >I<errnum>B<, const char *>I<"
"filename>B<,>\nB<                   unsigned int >I<linenum>B<, const char *>"
"I<format>B<, ...);>\n"

#. type: Plain text
#: man-pages/man3/error.3:41
#, no-wrap
msgid "B<extern unsigned int >I<error_message_count>B<;>\n"
msgstr "B<extern unsigned int >I<error_message_count>B<;>\n"

#. type: Plain text
#: man-pages/man3/error.3:43
#, no-wrap
msgid "B<extern int >I<error_one_per_line>B<;>\n"
msgstr "B<extern int >I<error_one_per_line>B<;>\n"

#. type: Plain text
#: man-pages/man3/error.3:45
#, no-wrap
msgid "B<extern void (*>I<error_print_progname>B<) (void);>\n"
msgstr "B<extern void (*>I<error_print_progname>B<) (void);>\n"

#. type: Plain text
#: man-pages/man3/error.3:64
msgid ""
"B<error>()  is a general error-reporting function.  It flushes I<stdout>, "
"and then outputs to I<stderr> the program name, a colon and a space, the "
"message specified by the B<printf>(3)-style format string I<format>, and, if"
" I<errnum> is nonzero, a second colon and a space followed by the string "
"given by I<strerror(errnum)>.  Any arguments required for I<format> should "
"follow I<format> in the argument list.  The output is terminated by a "
"newline character."
msgstr ""
"Функция B<error>() предназначена для сообщения об ошибках разного рода. Она "
"сбрасывает I<stdout>, а затем выводит в I<stderr> имя программы, двоеточие, "
"пробел, сообщение, задаваемое строкой I<format> в формате B<printf>(3) и, "
"если значение I<errnum> не равно нулю, второе двоеточие и пробел, за которыми "
"выводится строка, возвращаемая вызовом I<strerror(errnum)>. Все аргументы, "
"необходимые для I<format>, должны указываться в списке аргументов после I<"
"format>. Вывод завершается символом новой строки."

#. type: Plain text
#: man-pages/man3/error.3:75
msgid ""
"The program name printed by B<error>()  is the value of the global variable "
"B<program_invocation_name>(3).  I<program_invocation_name> initially has the"
" same value as I<main>()'s I<argv[0]>.  The value of this variable can be "
"modified to change the output of B<error>()."
msgstr ""
"Имя программы, выводимое B<error>(), представляет собой значение глобальной "
"переменной B<program_invocation_name>(3). Первоначально, переменная I<"
"program_invocation_name> имеет то же значение что и I<argv[0]> в функции I<"
"main>(). Значение этой переменной может быть изменено для показа в выводе B<"
"error>()."

#. type: Plain text
#: man-pages/man3/error.3:81
msgid ""
"If I<status> has a nonzero value, then B<error>()  calls B<exit>(3)  to "
"terminate the program using the given value as the exit status."
msgstr ""
"Если значение I<status> не равно нулю, то B<error>() вызывает B<exit>(3) для "
"завершения программы и это значение используется как код выхода."

#. type: Plain text
#: man-pages/man3/error.3:101
msgid ""
"The B<error_at_line>()  function is exactly the same as B<error>(), except "
"for the addition of the arguments I<filename> and I<linenum>.  The output "
"produced is as for B<error>(), except that after the program name are "
"written: a colon, the value of I<filename>, a colon, and the value of "
"I<linenum>.  The preprocessor values B<__LINE__> and B<__FILE__> may be "
"useful when calling B<error_at_line>(), but other values can also be used.  "
"For example, these arguments could refer to a location in an input file."
msgstr ""
"Функция B<error_at_line>() делает то же что и B<error>(), но имеет "
"дополнительные аргументы I<filename> и I<linenum>. Вывод аналогичен B<error>"
"(), но после имени программы записывается: двоеточие, значение I<filename>, "
"двоеточие и значение I<linenum>. При вызове B<error_at_line>() могут быть "
"полезны значения препроцессора B<__LINE__> и B<__FILE__>, но можно "
"использовать и другие значения. Например, эти аргументы могут указывать на "
"место во входном файле."

#. type: Plain text
#: man-pages/man3/error.3:108
msgid ""
"If the global variable I<error_one_per_line> is set nonzero, a sequence of "
"B<error_at_line>()  calls with the same value of I<filename> and I<linenum> "
"will result in only one message (the first) being output."
msgstr ""
"Если значение глобальной переменной I<error_one_per_line> не равно нулю, то "
"последовательность вызовов B<error_at_line>() с тем же значением I<filename> "
"и I<linenum> выводит только одно сообщение (первое)."

#. type: Plain text
#: man-pages/man3/error.3:114
msgid ""
"The global variable I<error_message_count> counts the number of messages "
"that have been output by B<error>()  and B<error_at_line>()."
msgstr ""
"В глобальной переменной I<error_message_count> подсчитывается количество "
"сообщений, которые были показаны с помощью B<error>() и B<error_at_line>()."

#. type: Plain text
#: man-pages/man3/error.3:121
msgid ""
"If the global variable I<error_print_progname> is assigned the address of a "
"function (i.e., is not NULL), then that function is called instead of "
"prefixing the message with the program name and colon.  The function should "
"print a suitable string to I<stderr>."
msgstr ""
"Если глобальной переменной I<error_print_progname> назначен адрес функции "
"(т.е., её значение не равно NULL), то вместо показа в начале сообщения имени "
"программы и двоеточия вызывается эта функция. Функция должна вывести нужную "
"строку в I<stderr>."

#. type: Plain text
#: man-pages/man3/error.3:124
msgid ""
"These functions and variables are GNU extensions, and should not be used in "
"programs intended to be portable."
msgstr ""
"Эти функции и глобальные переменные являются расширениями GNU, и они не "
"должны использоваться в переносимых программах."

#. type: Plain text
#: man-pages/man3/error.3:130
msgid ""
"B<err>(3), B<errno>(3), B<exit>(3), B<perror>(3), "
"B<program_invocation_name>(3), B<strerror>(3)"
msgstr ""
"B<err>(3), B<errno>(3), B<exit>(3), B<perror>(3), B<program_invocation_name>"
"(3), B<strerror>(3)"

#. type: TH
#: man-pages/man3/errno.3:31
#, no-wrap
msgid "ERRNO"
msgstr "ERRNO"

#. type: TH
#: man-pages/man3/errno.3:31
#, no-wrap
msgid "2008-07-09"
msgstr "2008-07-09"

#. type: Plain text
#: man-pages/man3/errno.3:34
msgid "errno - number of last error"
msgstr "errno - код последней ошибки"

#. .sp
#. .BI "extern int " errno ;
#. type: Plain text
#: man-pages/man3/errno.3:38
msgid "B<#include E<lt>errno.hE<gt>>"
msgstr "B<#include E<lt>errno.hE<gt>>"

#. type: Plain text
#: man-pages/man3/errno.3:53
msgid ""
"The I<E<lt>errno.hE<gt>> header file defines the integer variable I<errno>, "
"which is set by system calls and some library functions in the event of an "
"error to indicate what went wrong.  Its value is significant only when the "
"return value of the call indicated an error (i.e., -1 from most system "
"calls; -1 or NULL from most library functions); a function that succeeds "
"I<is> allowed to change I<errno>."
msgstr ""
"В заголовочном файле I<E<lt>errno.hE<gt>> определяется целочисленная "
"переменная I<errno>, которая используется системными вызовами и некоторыми "
"библиотечными функциями при ошибках для указания того, что именно произошло. "
"Её значение имеет смысл только тогда, когда вызов возвратил ошибку (т.е., -1 "
"для большинства системных вызовов или NULL — для большинства библиотечных "
"функций); при успешном выполнении функции также I<могут> менять значение I<"
"errno>."

#. type: Plain text
#: man-pages/man3/errno.3:58
msgid ""
"Valid error numbers are all nonzero; I<errno> is never set to zero by any "
"system call or library function."
msgstr ""
"Допускаемые номера ошибок не равны нулю; значение I<errno> никогда не "
"устанавливается в ноль какими-либо системными вызовами или библиотечными "
"функциями."

#. type: Plain text
#: man-pages/man3/errno.3:70
msgid ""
"For some system calls and library functions (e.g., B<getpriority>(2)), -1 is"
" a valid return on success.  In such cases, a successful return can be "
"distinguished from an error return by setting I<errno> to zero before the "
"call, and then, if the call returns a status that indicates that an error "
"may have occurred, checking to see if I<errno> has a nonzero value."
msgstr ""
"Некоторые системные вызовы или библиотечные функции (например, B<getpriority>"
"(2)), при успешном выполнении возвращают -1. В этих случаях успешность "
"выполнения можно отличить от ошибки присвоив I<errno> значение нуля перед "
"вызовом, и затем, если вызов вернул состояние, которое может указывать на "
"ошибку, проверить, равно ли I<errno> ненулевому значению."

#. type: Plain text
#: man-pages/man3/errno.3:81
msgid ""
"I<errno> is defined by the ISO C standard to be a modifiable lvalue of type "
"I<int>, and must not be explicitly declared; I<errno> may be a macro.  "
"I<errno> is thread-local; setting it in one thread does not affect its value"
" in any other thread."
msgstr ""
"Переменная I<errno> определена в стандарте ISO C как изменяемое lvalue I<int> "
"и не объявляемая явно; I<errno> может быть и макросом. Переменная I<errno> "
"является локальным значением нити; её изменение в одной нити не влияет на её "
"значение в другой нити."

#. type: Plain text
#: man-pages/man3/errno.3:88
msgid ""
"All the error names specified by POSIX.1 must have distinct values, with the"
" exception of B<EAGAIN> and B<EWOULDBLOCK>, which may be the same."
msgstr ""
"Всем названиям ошибок, определённым в POSIX.1, должны соответствовать разные "
"значения, за исключением B<EAGAIN> и B<EWOULDBLOCK>, которые могут быть "
"одинаковыми."

#.  The following is now
#.  POSIX.1 (2001 edition) lists the following symbolic error names.  Of
#.  these, \fBEDOM\fP and \fBERANGE\fP are in the ISO C standard.  ISO C
#.  Amendment 1 defines the additional error number \fBEILSEQ\fP for
#.  coding errors in multibyte or wide characters.
#. type: Plain text
#: man-pages/man3/errno.3:101
msgid ""
"Below is a list of the symbolic error names that are defined on Linux.  Some"
" of these are marked I<POSIX.1>, indicating that the name is defined by "
"POSIX.1-2001, or I<C99>, indicating that the name is defined by C99."
msgstr ""
"Далее приведён список символических имён ошибок, определённых в Linux. "
"Некоторые из них, отмеченные как I<POSIX.1>, определены в POSIX.1-2001, а "
"отмеченные как I<C99> — определены в C99."

#. type: Plain text
#: man-pages/man3/errno.3:104
msgid "Argument list too long (POSIX.1)"
msgstr "Слишком длинный список параметров (POSIX.1)"

#. type: Plain text
#: man-pages/man3/errno.3:107
msgid "Permission denied (POSIX.1)"
msgstr "Доступ запрещён (POSIX.1)"

#. type: TP
#: man-pages/man3/errno.3:107
#, no-wrap
msgid "B<EADDRINUSE>"
msgstr "B<EADDRINUSE>"

#. type: Plain text
#: man-pages/man3/errno.3:110
msgid "Address already in use (POSIX.1)"
msgstr "Адрес уже используется (POSIX.1)"

#. type: TP
#: man-pages/man3/errno.3:110
#, no-wrap
msgid "B<EADDRNOTAVAIL>"
msgstr "B<EADDRNOTAVAIL>"

#.  EADV is only an error on HURD(?)
#. type: Plain text
#: man-pages/man3/errno.3:114
msgid "Address not available (POSIX.1)"
msgstr "Адрес недоступен (POSIX.1)"

#. type: TP
#: man-pages/man3/errno.3:114
#, no-wrap
msgid "B<EAFNOSUPPORT>"
msgstr "B<EAFNOSUPPORT>"

#. type: Plain text
#: man-pages/man3/errno.3:117
msgid "Address family not supported (POSIX.1)"
msgstr "Семейство адресов не поддерживается (POSIX.1)"

#. type: TP
#: man-pages/man3/errno.3:117
#, no-wrap
msgid "B<EAGAIN>"
msgstr "B<EAGAIN>"

#. type: Plain text
#: man-pages/man3/errno.3:122
msgid ""
"Resource temporarily unavailable (may be the same value as B<EWOULDBLOCK>)  "
"(POSIX.1)"
msgstr ""
"Ресурс временно недоступен (значение может быть равным B<EWOULDBLOCK>) "
"(POSIX.1)"

#. type: TP
#: man-pages/man3/errno.3:122
#, no-wrap
msgid "B<EALREADY>"
msgstr "B<EALREADY>"

#. type: Plain text
#: man-pages/man3/errno.3:125
msgid "Connection already in progress (POSIX.1)"
msgstr "Соединение уже выполняется (POSIX.1)"

#. type: TP
#: man-pages/man3/errno.3:125
#, no-wrap
msgid "B<EBADE>"
msgstr "B<EBADE>"

#. type: Plain text
#: man-pages/man3/errno.3:128
msgid "Invalid exchange"
msgstr "Некорректный обмен"

#. type: Plain text
#: man-pages/man3/errno.3:131
msgid "Bad file descriptor (POSIX.1)"
msgstr "Неправильный дескриптор файла (POSIX.1)"

#. type: TP
#: man-pages/man3/errno.3:131
#, no-wrap
msgid "B<EBADFD>"
msgstr "B<EBADFD>"

#. type: Plain text
#: man-pages/man3/errno.3:134
msgid "File descriptor in bad state"
msgstr "Некорректное состояние дескриптора файла"

#. type: TP
#: man-pages/man3/errno.3:134
#, no-wrap
msgid "B<EBADMSG>"
msgstr "B<EBADMSG>"

#. type: Plain text
#: man-pages/man3/errno.3:137
msgid "Bad message (POSIX.1)"
msgstr "Неправильное сообщение (POSIX.1)"

#. type: TP
#: man-pages/man3/errno.3:137
#, no-wrap
msgid "B<EBADR>"
msgstr "B<EBADR>"

#. type: Plain text
#: man-pages/man3/errno.3:140
msgid "Invalid request descriptor"
msgstr "Неверный дескриптор запроса"

#. type: TP
#: man-pages/man3/errno.3:140
#, no-wrap
msgid "B<EBADRQC>"
msgstr "B<EBADRQC>"

#. type: Plain text
#: man-pages/man3/errno.3:143
msgid "Invalid request code"
msgstr "Неверный код запроса"

#. type: TP
#: man-pages/man3/errno.3:143
#, no-wrap
msgid "B<EBADSLT>"
msgstr "B<EBADSLT>"

#.  EBFONT is defined but appears not to be used by kernel or glibc.
#. type: Plain text
#: man-pages/man3/errno.3:147
msgid "Invalid slot"
msgstr "Некорректный слот"

#. type: TP
#: man-pages/man3/errno.3:147
#, no-wrap
msgid "B<EBUSY>"
msgstr "B<EBUSY>"

#. type: Plain text
#: man-pages/man3/errno.3:150
msgid "Device or resource busy (POSIX.1)"
msgstr "Устройство или ресурс занято (POSIX.1)"

#. type: TP
#: man-pages/man3/errno.3:150
#, no-wrap
msgid "B<ECANCELED>"
msgstr "B<ECANCELED>"

#. type: Plain text
#: man-pages/man3/errno.3:153
msgid "Operation canceled (POSIX.1)"
msgstr "Операция отменена (POSIX.1)"

#. type: TP
#: man-pages/man3/errno.3:153
#, no-wrap
msgid "B<ECHILD>"
msgstr "B<ECHILD>"

#. type: Plain text
#: man-pages/man3/errno.3:156
msgid "No child processes (POSIX.1)"
msgstr "Отсутствуют дочерние процессы (POSIX.1)"

#. type: TP
#: man-pages/man3/errno.3:156
#, no-wrap
msgid "B<ECHRNG>"
msgstr "B<ECHRNG>"

#. type: Plain text
#: man-pages/man3/errno.3:159
msgid "Channel number out of range"
msgstr "Номер канала вне диапазона"

#. type: TP
#: man-pages/man3/errno.3:159
#, no-wrap
msgid "B<ECOMM>"
msgstr "B<ECOMM>"

#. type: Plain text
#: man-pages/man3/errno.3:162
msgid "Communication error on send"
msgstr "Ошибка связи при отправке"

#. type: TP
#: man-pages/man3/errno.3:162
#, no-wrap
msgid "B<ECONNABORTED>"
msgstr "B<ECONNABORTED>"

#. type: Plain text
#: man-pages/man3/errno.3:165
msgid "Connection aborted (POSIX.1)"
msgstr "Соединение было прервано (POSIX.1)"

#. type: TP
#: man-pages/man3/errno.3:165
#, no-wrap
msgid "B<ECONNREFUSED>"
msgstr "B<ECONNREFUSED>"

#. type: Plain text
#: man-pages/man3/errno.3:168
msgid "Connection refused (POSIX.1)"
msgstr "В соединении отказано (POSIX.1)"

#. type: TP
#: man-pages/man3/errno.3:168
#, no-wrap
msgid "B<ECONNRESET>"
msgstr "B<ECONNRESET>"

#. type: Plain text
#: man-pages/man3/errno.3:171
msgid "Connection reset (POSIX.1)"
msgstr "Соединение сброшено другой стороной (POSIX.1)"

#. type: TP
#: man-pages/man3/errno.3:171
#, no-wrap
msgid "B<EDEADLK>"
msgstr "B<EDEADLK>"

#. type: Plain text
#: man-pages/man3/errno.3:174
msgid "Resource deadlock avoided (POSIX.1)"
msgstr "Предотвращена тупиковая ситуация при обращении к ресурсу (POSIX.1)"

#. type: TP
#: man-pages/man3/errno.3:174
#, no-wrap
msgid "B<EDEADLOCK>"
msgstr "B<EDEADLOCK>"

#. type: Plain text
#: man-pages/man3/errno.3:178
msgid "Synonym for B<EDEADLK>"
msgstr "Синоним B<EDEADLK>"

#. type: TP
#: man-pages/man3/errno.3:178
#, no-wrap
msgid "B<EDESTADDRREQ>"
msgstr "B<EDESTADDRREQ>"

#. type: Plain text
#: man-pages/man3/errno.3:181
msgid "Destination address required (POSIX.1)"
msgstr "Требуется указать адрес назначения (POSIX.1)"

#. type: TP
#: man-pages/man3/errno.3:181
#, no-wrap
msgid "B<EDOM>"
msgstr "B<EDOM>"

#.  EDOTDOT is defined but appears to be unused
#. type: Plain text
#: man-pages/man3/errno.3:185
msgid "Mathematics argument out of domain of function (POSIX.1, C99)"
msgstr "Математический аргумент вне области определения функции (POSIX.1, C99)"

#. type: TP
#: man-pages/man3/errno.3:185
#, no-wrap
msgid "B<EDQUOT>"
msgstr "B<EDQUOT>"

#.  POSIX just says "Reserved"
#. type: Plain text
#: man-pages/man3/errno.3:189
msgid "Disk quota exceeded (POSIX.1)"
msgstr "Превышена дисковая квота (POSIX.1)"

#. type: Plain text
#: man-pages/man3/errno.3:192
msgid "File exists (POSIX.1)"
msgstr "Файл существует (POSIX.1)"

#. type: Plain text
#: man-pages/man3/errno.3:195
msgid "Bad address (POSIX.1)"
msgstr "Неправильный адрес (POSIX.1)"

#. type: TP
#: man-pages/man3/errno.3:195
#, no-wrap
msgid "B<EFBIG>"
msgstr "B<EFBIG>"

#. type: Plain text
#: man-pages/man3/errno.3:198
msgid "File too large (POSIX.1)"
msgstr "Файл слишком велик (POSIX.1)"

#. type: TP
#: man-pages/man3/errno.3:198
#, no-wrap
msgid "B<EHOSTDOWN>"
msgstr "B<EHOSTDOWN>"

#. type: Plain text
#: man-pages/man3/errno.3:201
msgid "Host is down"
msgstr "Узел выключен"

#. type: TP
#: man-pages/man3/errno.3:201
#, no-wrap
msgid "B<EHOSTUNREACH>"
msgstr "B<EHOSTUNREACH>"

#. type: Plain text
#: man-pages/man3/errno.3:204
msgid "Host is unreachable (POSIX.1)"
msgstr "Узел недоступен (POSIX.1)"

#. type: TP
#: man-pages/man3/errno.3:204
#, no-wrap
msgid "B<EIDRM>"
msgstr "B<EIDRM>"

#. type: Plain text
#: man-pages/man3/errno.3:207
msgid "Identifier removed (POSIX.1)"
msgstr "Идентификатор удалён (POSIX.1)"

#. type: TP
#: man-pages/man3/errno.3:207
#, no-wrap
msgid "B<EILSEQ>"
msgstr "B<EILSEQ>"

#. type: Plain text
#: man-pages/man3/errno.3:210
msgid "Illegal byte sequence (POSIX.1, C99)"
msgstr "Недопустимая последовательность байт (POSIX.1, C99)"

#. type: TP
#: man-pages/man3/errno.3:210
#, no-wrap
msgid "B<EINPROGRESS>"
msgstr "B<EINPROGRESS>"

#. type: Plain text
#: man-pages/man3/errno.3:213
msgid "Operation in progress (POSIX.1)"
msgstr "Операция выполняется (POSIX.1)"

#. type: Plain text
#: man-pages/man3/errno.3:217
msgid "Interrupted function call (POSIX.1); see B<signal>(7)."
msgstr "Прерванный вызов функции (POSIX.1); смотрите B<signal>(7)."

#. type: Plain text
#: man-pages/man3/errno.3:220
msgid "Invalid argument (POSIX.1)"
msgstr "Неверный аргумент (POSIX.1)"

#. type: Plain text
#: man-pages/man3/errno.3:223
msgid "Input/output error (POSIX.1)"
msgstr "Ошибка ввода/вывода (POSIX.1)"

#. type: TP
#: man-pages/man3/errno.3:223
#, no-wrap
msgid "B<EISCONN>"
msgstr "B<EISCONN>"

#. type: Plain text
#: man-pages/man3/errno.3:226
msgid "Socket is connected (POSIX.1)"
msgstr "Сокет подключён (POSIX.1)"

#. type: Plain text
#: man-pages/man3/errno.3:229
msgid "Is a directory (POSIX.1)"
msgstr "Это каталог (POSIX.1)"

#. type: TP
#: man-pages/man3/errno.3:229
#, no-wrap
msgid "B<EISNAM>"
msgstr "B<EISNAM>"

#. type: Plain text
#: man-pages/man3/errno.3:232
msgid "Is a named type file"
msgstr "Является файлом именованного типа"

#. type: TP
#: man-pages/man3/errno.3:232
#, no-wrap
msgid "B<EKEYEXPIRED>"
msgstr "B<EKEYEXPIRED>"

#. type: Plain text
#: man-pages/man3/errno.3:235
msgid "Key has expired"
msgstr "Ключ с истёкшим сроком"

#. type: TP
#: man-pages/man3/errno.3:235
#, no-wrap
msgid "B<EKEYREJECTED>"
msgstr "B<EKEYREJECTED>"

#. type: Plain text
#: man-pages/man3/errno.3:238
msgid "Key was rejected by service"
msgstr "Ключ был отвергнут службой"

#. type: TP
#: man-pages/man3/errno.3:238
#, no-wrap
msgid "B<EKEYREVOKED>"
msgstr "B<EKEYREVOKED>"

#. type: Plain text
#: man-pages/man3/errno.3:241
msgid "Key has been revoked"
msgstr "Ключ был отозван"

#. type: TP
#: man-pages/man3/errno.3:241
#, no-wrap
msgid "B<EL2HLT>"
msgstr "B<EL2HLT>"

#. type: Plain text
#: man-pages/man3/errno.3:244
msgid "Level 2 halted"
msgstr "Уровень 2 остановлен"

#. type: TP
#: man-pages/man3/errno.3:244
#, no-wrap
msgid "B<EL2NSYNC>"
msgstr "B<EL2NSYNC>"

#. type: Plain text
#: man-pages/man3/errno.3:247
msgid "Level 2 not synchronized"
msgstr "Уровень 2 не синхронизирован"

#. type: TP
#: man-pages/man3/errno.3:247
#, no-wrap
msgid "B<EL3HLT>"
msgstr "B<EL3HLT>"

#. type: Plain text
#: man-pages/man3/errno.3:250 man-pages/man3/errno.3:253
msgid "Level 3 halted"
msgstr "Уровень 3 остановлен"

#. type: TP
#: man-pages/man3/errno.3:250
#, no-wrap
msgid "B<EL3RST>"
msgstr "B<EL3RST>"

#. type: TP
#: man-pages/man3/errno.3:253
#, no-wrap
msgid "B<ELIBACC>"
msgstr "B<ELIBACC>"

#. type: Plain text
#: man-pages/man3/errno.3:256
msgid "Cannot access a needed shared library"
msgstr "Невозможно получить доступ к нужной общей библиотеке"

#. type: Plain text
#: man-pages/man3/errno.3:259
msgid "Accessing a corrupted shared library"
msgstr "Обращение к повреждённой общей библиотеке"

#. type: TP
#: man-pages/man3/errno.3:259
#, no-wrap
msgid "B<ELIBMAX>"
msgstr "B<ELIBMAX>"

#. type: Plain text
#: man-pages/man3/errno.3:262
msgid "Attempting to link in too many shared libraries"
msgstr "Попытка компоновки с слишком большим количеством общих библиотек"

#. type: TP
#: man-pages/man3/errno.3:262
#, no-wrap
msgid "B<ELIBSCN>"
msgstr "B<ELIBSCN>"

#. type: Plain text
#: man-pages/man3/errno.3:265
msgid "lib section in a.out corrupted"
msgstr "Секция lib в a.out повреждена"

#. type: TP
#: man-pages/man3/errno.3:265
#, no-wrap
msgid "B<ELIBEXEC>"
msgstr "B<ELIBEXEC>"

#. type: Plain text
#: man-pages/man3/errno.3:268
msgid "Cannot exec a shared library directly"
msgstr "Невозможно непосредственно выполнить общую библиотеку"

#.  ELNRNG is defined but appears to be unused
#. type: Plain text
#: man-pages/man3/errno.3:272
msgid "Too many levels of symbolic links (POSIX.1)"
msgstr "Слишком много уровней символьных ссылок (POSIX.1)"

#. type: TP
#: man-pages/man3/errno.3:272
#, no-wrap
msgid "B<EMEDIUMTYPE>"
msgstr "B<EMEDIUMTYPE>"

#. type: Plain text
#: man-pages/man3/errno.3:275
msgid "Wrong medium type"
msgstr "Неправильный тип носителя"

#. type: Plain text
#: man-pages/man3/errno.3:278
msgid "Too many open files (POSIX.1)"
msgstr "Слишком много открытых файлов (POSIX.1)"

#. type: TP
#: man-pages/man3/errno.3:278
#, no-wrap
msgid "B<EMLINK>"
msgstr "B<EMLINK>"

#. type: Plain text
#: man-pages/man3/errno.3:281
msgid "Too many links (POSIX.1)"
msgstr "Слишком много ссылок (POSIX.1)"

#. type: TP
#: man-pages/man3/errno.3:281
#, no-wrap
msgid "B<EMSGSIZE>"
msgstr "B<EMSGSIZE>"

#. type: Plain text
#: man-pages/man3/errno.3:284
msgid "Message too long (POSIX.1)"
msgstr "Сообщение слишком длинное (POSIX.1)"

#. type: TP
#: man-pages/man3/errno.3:284
#, no-wrap
msgid "B<EMULTIHOP>"
msgstr "B<EMULTIHOP>"

#.  POSIX says "Reserved"
#. type: Plain text
#: man-pages/man3/errno.3:288
msgid "Multihop attempted (POSIX.1)"
msgstr "Попытка Multihop (POSIX.1)"

#.  ENAVAIL is defined, but appears not to be used
#. type: Plain text
#: man-pages/man3/errno.3:292
msgid "Filename too long (POSIX.1)"
msgstr "Название файла слишком длинное (POSIX.1)"

#. type: TP
#: man-pages/man3/errno.3:292
#, no-wrap
msgid "B<ENETDOWN>"
msgstr "B<ENETDOWN>"

#. type: Plain text
#: man-pages/man3/errno.3:295
msgid "Network is down (POSIX.1)"
msgstr "Сеть не работает (POSIX.1)"

#. type: TP
#: man-pages/man3/errno.3:295
#, no-wrap
msgid "B<ENETRESET>"
msgstr "B<ENETRESET>"

#. type: Plain text
#: man-pages/man3/errno.3:298
msgid "Connection aborted by network (POSIX.1)"
msgstr "Соединение прервано из-за сети (POSIX.1)"

#. type: TP
#: man-pages/man3/errno.3:298
#, no-wrap
msgid "B<ENETUNREACH>"
msgstr "B<ENETUNREACH>"

#. type: Plain text
#: man-pages/man3/errno.3:301
msgid "Network unreachable (POSIX.1)"
msgstr "Сеть недоступна (POSIX.1)"

#.  ENOANO is defined but appears to be unused.
#. type: Plain text
#: man-pages/man3/errno.3:305
msgid "Too many open files in system (POSIX.1)"
msgstr "Слишком много открытых файлов в системе (POSIX.1)"

#. type: TP
#: man-pages/man3/errno.3:305
#, no-wrap
msgid "B<ENOBUFS>"
msgstr "B<ENOBUFS>"

#.  ENOCSI is defined but appears to be unused.
#. type: Plain text
#: man-pages/man3/errno.3:309
msgid "No buffer space available (POSIX.1 (XSI STREAMS option))"
msgstr "Недостаточно буферного пространства (POSIX.1 (часть XSI STREAMS))"

#. type: TP
#: man-pages/man3/errno.3:309
#, no-wrap
msgid "B<ENODATA>"
msgstr "B<ENODATA>"

#. type: Plain text
#: man-pages/man3/errno.3:312
msgid "No message is available on the STREAM head read queue (POSIX.1)"
msgstr "Сообщение в голове очереди чтения STREAM отсутствует (POSIX.1)"

#. type: Plain text
#: man-pages/man3/errno.3:315
msgid "No such device (POSIX.1)"
msgstr "Нет такого устройства (POSIX.1)"

#. type: Plain text
#: man-pages/man3/errno.3:318
msgid "No such file or directory (POSIX.1)"
msgstr "Нет такого файла или каталога (POSIX.1)"

#. type: Plain text
#: man-pages/man3/errno.3:321
msgid "Exec format error (POSIX.1)"
msgstr "Ошибка формата выполняемого файла (POSIX.1)"

#. type: TP
#: man-pages/man3/errno.3:321
#, no-wrap
msgid "B<ENOKEY>"
msgstr "B<ENOKEY>"

#. type: Plain text
#: man-pages/man3/errno.3:324
msgid "Required key not available"
msgstr "Требуемый ключ недоступен"

#. type: TP
#: man-pages/man3/errno.3:324
#, no-wrap
msgid "B<ENOLCK>"
msgstr "B<ENOLCK>"

#. type: Plain text
#: man-pages/man3/errno.3:327
msgid "No locks available (POSIX.1)"
msgstr "Нет доступных блокировок (POSIX.1)"

#. type: TP
#: man-pages/man3/errno.3:327
#, no-wrap
msgid "B<ENOLINK>"
msgstr "B<ENOLINK>"

#.  POSIX says "Reserved"
#. type: Plain text
#: man-pages/man3/errno.3:331
msgid "Link has been severed (POSIX.1)"
msgstr "Соединение было разорвано (POSIX.1)"

#. type: TP
#: man-pages/man3/errno.3:331
#, no-wrap
msgid "B<ENOMEDIUM>"
msgstr "B<ENOMEDIUM>"

#. type: Plain text
#: man-pages/man3/errno.3:334
msgid "No medium found"
msgstr "Носитель не найден"

#. type: Plain text
#: man-pages/man3/errno.3:337
msgid "Not enough space (POSIX.1)"
msgstr "Недостаточно места (POSIX.1)"

#. type: TP
#: man-pages/man3/errno.3:337
#, no-wrap
msgid "B<ENOMSG>"
msgstr "B<ENOMSG>"

#. type: Plain text
#: man-pages/man3/errno.3:340
msgid "No message of the desired type (POSIX.1)"
msgstr "Нет сообщения желаемого типа (POSIX.1)"

#. type: TP
#: man-pages/man3/errno.3:340
#, no-wrap
msgid "B<ENONET>"
msgstr "B<ENONET>"

#. type: Plain text
#: man-pages/man3/errno.3:343
msgid "Machine is not on the network"
msgstr "Машина не в сети"

#. type: TP
#: man-pages/man3/errno.3:343
#, no-wrap
msgid "B<ENOPKG>"
msgstr "B<ENOPKG>"

#. type: Plain text
#: man-pages/man3/errno.3:346
msgid "Package not installed"
msgstr "Пакет не установлен"

#. type: TP
#: man-pages/man3/errno.3:346
#, no-wrap
msgid "B<ENOPROTOOPT>"
msgstr "B<ENOPROTOOPT>"

#. type: Plain text
#: man-pages/man3/errno.3:349
msgid "Protocol not available (POSIX.1)"
msgstr "Протокол недоступен (POSIX.1)"

#. type: Plain text
#: man-pages/man3/errno.3:352
msgid "No space left on device (POSIX.1)"
msgstr "На устройстве не осталось места (POSIX.1)"

#. type: TP
#: man-pages/man3/errno.3:352
#, no-wrap
msgid "B<ENOSR>"
msgstr "B<ENOSR>"

#. type: Plain text
#: man-pages/man3/errno.3:355
msgid "No STREAM resources (POSIX.1 (XSI STREAMS option))"
msgstr "Отсутствую ресурсы STREAM (POSIX.1 (часть XSI STREAMS))"

#. type: TP
#: man-pages/man3/errno.3:355
#, no-wrap
msgid "B<ENOSTR>"
msgstr "B<ENOSTR>"

#. type: Plain text
#: man-pages/man3/errno.3:358
msgid "Not a STREAM (POSIX.1 (XSI STREAMS option))"
msgstr "Нет STREAM (POSIX.1 (часть XSI STREAMS))"

#. type: Plain text
#: man-pages/man3/errno.3:361
msgid "Function not implemented (POSIX.1)"
msgstr "Функция не реализована (POSIX.1)"

#. type: TP
#: man-pages/man3/errno.3:361
#, no-wrap
msgid "B<ENOTBLK>"
msgstr "B<ENOTBLK>"

#. type: Plain text
#: man-pages/man3/errno.3:364
msgid "Block device required"
msgstr "Требуется блочное устройство"

#. type: TP
#: man-pages/man3/errno.3:364
#, no-wrap
msgid "B<ENOTCONN>"
msgstr "B<ENOTCONN>"

#. type: Plain text
#: man-pages/man3/errno.3:367
msgid "The socket is not connected (POSIX.1)"
msgstr "Сокет не подключён (POSIX.1)"

#. type: Plain text
#: man-pages/man3/errno.3:370
msgid "Not a directory (POSIX.1)"
msgstr "Не каталог (POSIX.1)"

#. type: TP
#: man-pages/man3/errno.3:370
#, no-wrap
msgid "B<ENOTEMPTY>"
msgstr "B<ENOTEMPTY>"

#.  ENOTNAM is defined but appears to be unused.
#. type: Plain text
#: man-pages/man3/errno.3:374
msgid "Directory not empty (POSIX.1)"
msgstr "Каталог не пуст (POSIX.1)"

#. type: TP
#: man-pages/man3/errno.3:374
#, no-wrap
msgid "B<ENOTSOCK>"
msgstr "B<ENOTSOCK>"

#. type: Plain text
#: man-pages/man3/errno.3:377
msgid "Not a socket (POSIX.1)"
msgstr "Не сокет (POSIX.1)"

#. type: TP
#: man-pages/man3/errno.3:377
#, no-wrap
msgid "B<ENOTSUP>"
msgstr "B<ENOTSUP>"

#. type: Plain text
#: man-pages/man3/errno.3:380
msgid "Operation not supported (POSIX.1)"
msgstr "Неподдерживаемая операция (POSIX.1)"

#. type: TP
#: man-pages/man3/errno.3:380
#, no-wrap
msgid "B<ENOTTY>"
msgstr "B<ENOTTY>"

#. type: Plain text
#: man-pages/man3/errno.3:383
msgid "Inappropriate I/O control operation (POSIX.1)"
msgstr "Неподходящая операция управления вводом/выводом (POSIX.1)"

#. type: TP
#: man-pages/man3/errno.3:383
#, no-wrap
msgid "B<ENOTUNIQ>"
msgstr "B<ENOTUNIQ>"

#. type: Plain text
#: man-pages/man3/errno.3:386
msgid "Name not unique on network"
msgstr "Имя не уникально в сети"

#. type: TP
#: man-pages/man3/errno.3:386
#, no-wrap
msgid "B<ENXIO>"
msgstr "B<ENXIO>"

#. type: Plain text
#: man-pages/man3/errno.3:389
msgid "No such device or address (POSIX.1)"
msgstr "Нет такого устройства или адреса (POSIX.1)"

#. type: TP
#: man-pages/man3/errno.3:389
#, no-wrap
msgid "B<EOPNOTSUPP>"
msgstr "B<EOPNOTSUPP>"

#. type: Plain text
#: man-pages/man3/errno.3:392
msgid "Operation not supported on socket (POSIX.1)"
msgstr "Операция не поддерживается на сокете (POSIX.1)"

#. type: Plain text
#: man-pages/man3/errno.3:398
msgid ""
"(B<ENOTSUP> and B<EOPNOTSUPP> have the same value on Linux, but according to"
" POSIX.1 these error values should be distinct.)"
msgstr ""
"(B<ENOTSUP> и B<EOPNOTSUPP> в Linux имеют одинаковые значения, но согласно "
"POSIX.1 значения этих ошибок должны различаться.)"

#. type: TP
#: man-pages/man3/errno.3:398
#, no-wrap
msgid "B<EOVERFLOW>"
msgstr "B<EOVERFLOW>"

#. type: Plain text
#: man-pages/man3/errno.3:401
msgid "Value too large to be stored in data type (POSIX.1)"
msgstr "Значение слишком велико для хранения в таком типе данных (POSIX.1)"

#. type: Plain text
#: man-pages/man3/errno.3:404
msgid "Operation not permitted (POSIX.1)"
msgstr "Операция не позволена (POSIX.1)"

#. type: TP
#: man-pages/man3/errno.3:404
#, no-wrap
msgid "B<EPFNOSUPPORT>"
msgstr "B<EPFNOSUPPORT>"

#. type: Plain text
#: man-pages/man3/errno.3:407
msgid "Protocol family not supported"
msgstr "Неподдерживаемое семейство протоколов"

#. type: TP
#: man-pages/man3/errno.3:407
#, no-wrap
msgid "B<EPIPE>"
msgstr "B<EPIPE>"

#. type: Plain text
#: man-pages/man3/errno.3:410
msgid "Broken pipe (POSIX.1)"
msgstr "Обрыв канала (POSIX.1)"

#. type: TP
#: man-pages/man3/errno.3:410
#, no-wrap
msgid "B<EPROTO>"
msgstr "B<EPROTO>"

#. type: Plain text
#: man-pages/man3/errno.3:413
msgid "Protocol error (POSIX.1)"
msgstr "Ошибка протокола (POSIX.1)"

#. type: TP
#: man-pages/man3/errno.3:413
#, no-wrap
msgid "B<EPROTONOSUPPORT>"
msgstr "B<EPROTONOSUPPORT>"

#. type: Plain text
#: man-pages/man3/errno.3:416
msgid "Protocol not supported (POSIX.1)"
msgstr "Протокол не поддерживается (POSIX.1)"

#. type: TP
#: man-pages/man3/errno.3:416
#, no-wrap
msgid "B<EPROTOTYPE>"
msgstr "B<EPROTOTYPE>"

#. type: Plain text
#: man-pages/man3/errno.3:419
msgid "Protocol wrong type for socket (POSIX.1)"
msgstr "Неподдерживаемый тип протокола для сокета (POSIX.1)"

#. type: TP
#: man-pages/man3/errno.3:419
#, no-wrap
msgid "B<ERANGE>"
msgstr "B<ERANGE>"

#. type: Plain text
#: man-pages/man3/errno.3:422
msgid "Result too large (POSIX.1, C99)"
msgstr "Результат слишком большой (POSIX.1, C99)"

#. type: TP
#: man-pages/man3/errno.3:422
#, no-wrap
msgid "B<EREMCHG>"
msgstr "B<EREMCHG>"

#. type: Plain text
#: man-pages/man3/errno.3:425
msgid "Remote address changed"
msgstr "Удалённый адрес был изменён"

#. type: TP
#: man-pages/man3/errno.3:425
#, no-wrap
msgid "B<EREMOTE>"
msgstr "B<EREMOTE>"

#. type: Plain text
#: man-pages/man3/errno.3:428
msgid "Object is remote"
msgstr "Это удалённый объект"

#. type: TP
#: man-pages/man3/errno.3:428
#, no-wrap
msgid "B<EREMOTEIO>"
msgstr "B<EREMOTEIO>"

#. type: Plain text
#: man-pages/man3/errno.3:431
msgid "Remote I/O error"
msgstr "Ошибка удалённого ввода/вывода"

#. type: TP
#: man-pages/man3/errno.3:431
#, no-wrap
msgid "B<ERESTART>"
msgstr "B<ERESTART>"

#. type: Plain text
#: man-pages/man3/errno.3:434
msgid "Interrupted system call should be restarted"
msgstr "Прерванный системный вызов следует перезапустить"

#. type: TP
#: man-pages/man3/errno.3:434
#, no-wrap
msgid "B<EROFS>"
msgstr "B<EROFS>"

#. type: Plain text
#: man-pages/man3/errno.3:437
msgid "Read-only filesystem (POSIX.1)"
msgstr "Файловая система, доступная только для чтения (POSIX.1)"

#. type: TP
#: man-pages/man3/errno.3:437
#, no-wrap
msgid "B<ESHUTDOWN>"
msgstr "B<ESHUTDOWN>"

#. type: Plain text
#: man-pages/man3/errno.3:440
msgid "Cannot send after transport endpoint shutdown"
msgstr "Невозможно отправить данные после выключения конечной точки передачи"

#. type: TP
#: man-pages/man3/errno.3:440
#, no-wrap
msgid "B<ESPIPE>"
msgstr "B<ESPIPE>"

#. type: Plain text
#: man-pages/man3/errno.3:443
msgid "Invalid seek (POSIX.1)"
msgstr "Недопустимое перемещение (POSIX.1)"

#. type: TP
#: man-pages/man3/errno.3:443
#, no-wrap
msgid "B<ESOCKTNOSUPPORT>"
msgstr "B<ESOCKTNOSUPPORT>"

#. type: Plain text
#: man-pages/man3/errno.3:446
msgid "Socket type not supported"
msgstr "Неподдерживаемый тип сокета"

#. type: TP
#: man-pages/man3/errno.3:446
#, no-wrap
msgid "B<ESRCH>"
msgstr "B<ESRCH>"

#.  ESRMNT is defined but appears not to be used
#. type: Plain text
#: man-pages/man3/errno.3:450
msgid "No such process (POSIX.1)"
msgstr "Нет такого процесса (POSIX.1)"

#. type: TP
#: man-pages/man3/errno.3:450
#, no-wrap
msgid "B<ESTALE>"
msgstr "B<ESTALE>"

#. type: Plain text
#: man-pages/man3/errno.3:453
msgid "Stale file handle (POSIX.1)"
msgstr "Неактуальный дескриптор файла (POSIX.1)"

#. type: Plain text
#: man-pages/man3/errno.3:455
msgid "This error can occur for NFS and for other filesystems"
msgstr "Эта ошибка может возникать в NFS и других файловых системах"

#. type: TP
#: man-pages/man3/errno.3:455
#, no-wrap
msgid "B<ESTRPIPE>"
msgstr "B<ESTRPIPE>"

#. type: Plain text
#: man-pages/man3/errno.3:458
msgid "Streams pipe error"
msgstr "Ошибка потоков канала"

#. type: TP
#: man-pages/man3/errno.3:458
#, no-wrap
msgid "B<ETIME>"
msgstr "B<ETIME>"

#. type: Plain text
#: man-pages/man3/errno.3:462
msgid "Timer expired (POSIX.1 (XSI STREAMS option))"
msgstr "Таймер истёк (POSIX.1 (часть XSI STREAMS))"

#. type: Plain text
#: man-pages/man3/errno.3:466
msgid "(POSIX.1 says \"STREAM B<ioctl>(2)  timeout\")"
msgstr ""
"(в POSIX.1 описывается как «в B<ioctl>(2) истекло время ожидания STREAM»)"

#. type: TP
#: man-pages/man3/errno.3:466
#, no-wrap
msgid "B<ETIMEDOUT>"
msgstr "B<ETIMEDOUT>"

#.  ETOOMANYREFS is defined, but appears not to be used.
#. type: Plain text
#: man-pages/man3/errno.3:470
msgid "Connection timed out (POSIX.1)"
msgstr "Время ожидания соединения истекло (POSIX.1)"

#. type: Plain text
#: man-pages/man3/errno.3:473
msgid "Text file busy (POSIX.1)"
msgstr "Текстовый файл занят (POSIX.1)"

#. type: TP
#: man-pages/man3/errno.3:473
#, no-wrap
msgid "B<EUCLEAN>"
msgstr "B<EUCLEAN>"

#. type: Plain text
#: man-pages/man3/errno.3:476
msgid "Structure needs cleaning"
msgstr "Структуру необходимо почистить"

#. type: TP
#: man-pages/man3/errno.3:476
#, no-wrap
msgid "B<EUNATCH>"
msgstr "B<EUNATCH>"

#. type: Plain text
#: man-pages/man3/errno.3:479
msgid "Protocol driver not attached"
msgstr "Драйвер протокола не подсоединён"

#. type: TP
#: man-pages/man3/errno.3:479
#, no-wrap
msgid "B<EUSERS>"
msgstr "B<EUSERS>"

#. type: Plain text
#: man-pages/man3/errno.3:482
msgid "Too many users"
msgstr "Слишком много пользователей"

#. type: TP
#: man-pages/man3/errno.3:482
#, no-wrap
msgid "B<EWOULDBLOCK>"
msgstr "B<EWOULDBLOCK>"

#. type: Plain text
#: man-pages/man3/errno.3:487
msgid "Operation would block (may be same value as B<EAGAIN>)  (POSIX.1)"
msgstr ""
"Операция приведёт к блокировке (значение может быть равным B<EAGAIN>) "
"(POSIX.1)"

#. type: TP
#: man-pages/man3/errno.3:487
#, no-wrap
msgid "B<EXDEV>"
msgstr "B<EXDEV>"

#. type: Plain text
#: man-pages/man3/errno.3:490
msgid "Improper link (POSIX.1)"
msgstr "Некорректная ссылка (POSIX.1)"

#. type: TP
#: man-pages/man3/errno.3:490
#, no-wrap
msgid "B<EXFULL>"
msgstr "B<EXFULL>"

#. type: Plain text
#: man-pages/man3/errno.3:493
msgid "Exchange full"
msgstr "Обмен полон"

#. type: Plain text
#: man-pages/man3/errno.3:495
msgid "A common mistake is to do"
msgstr "Распространённая ошибка:"

#. type: Plain text
#: man-pages/man3/errno.3:502
#, no-wrap
msgid ""
"if (somecall() == -1) {\n"
"    printf(\"somecall() failed\\en\");\n"
"    if (errno == ...) { ... }\n"
"}\n"
msgstr ""
"if (somecall() == -1) {\n    printf(\"somecall() failed\\en\");\n    if "
"(errno == ...) { ... }\n}\n"

#. type: Plain text
#: man-pages/man3/errno.3:514
msgid ""
"where I<errno> no longer needs to have the value it had upon return from "
"I<somecall>()  (i.e., it may have been changed by the B<printf>(3)).  If the"
" value of I<errno> should be preserved across a library call, it must be "
"saved:"
msgstr ""
"Здесь I<errno> может больше не иметь значение результата последнего вызова I<"
"somecall>() (т.е., значение может измениться из-за B<printf>(3)). Если "
"значение I<errno> важно, то его нужно сохранять между библиотечными вызовами:"

#. type: Plain text
#: man-pages/man3/errno.3:522
#, no-wrap
msgid ""
"if (somecall() == -1) {\n"
"    int errsv = errno;\n"
"    printf(\"somecall() failed\\en\");\n"
"    if (errsv == ...) { ... }\n"
"}\n"
msgstr ""
"if (somecall() == -1) {\n    int errsv = errno;\n    printf(\"somecall() "
"failed\\en\");\n    if (errsv == ...) { ... }\n}\n"

#. type: Plain text
#: man-pages/man3/errno.3:537
msgid ""
"It was common in traditional C to declare I<errno> manually (i.e., I<extern "
"int errno>)  instead of including I<E<lt>errno.hE<gt>>.  B<Do not do this>."
"  It will not work with modern versions of the C library.  However, on "
"(very) old UNIX systems, there may be no I<E<lt>errno.hE<gt>> and the "
"declaration is needed."
msgstr ""
"Раньше в Си было распространена практика определения I<errno> вручную (т.е., "
"I<extern int errno>), вместо включения файла I<E<lt>errno.hE<gt>>. B<Не "
"делайте этого>. Это не будет работать с современными версиями библиотеки Си. "
"Однако, на (очень) старых системах UNIX файл I<E<lt>errno.hE<gt>> может "
"отсутствовать и определение необходимо."

#. type: Plain text
#: man-pages/man3/errno.3:541
msgid "B<err>(3), B<error>(3), B<perror>(3), B<strerror>(3)"
msgstr "B<err>(3), B<error>(3), B<perror>(3), B<strerror>(3)"

#. type: TH
#: man-pages/man3/erfc.3:26
#, no-wrap
msgid "ERFC"
msgstr "ERFC"

#. type: TH
#: man-pages/man3/erfc.3:26
#, no-wrap
msgid "2013-10-29"
msgstr "2013-10-29"

#. type: Plain text
#: man-pages/man3/erfc.3:29
msgid "erfc, erfcf, erfcl - complementary error function"
msgstr "erfc, erfcf, erfcl - дополнительная функция ошибки"

#. type: Plain text
#: man-pages/man3/erfc.3:36
#, no-wrap
msgid ""
"B<double erfc(double >I<x>B<);>\n"
"B<float erfcf(float >I<x>B<);>\n"
"B<long double erfcl(long double >I<x>B<);>\n"
msgstr ""
"B<double erfc(double >I<x>B<);>\nB<float erfcf(float >I<x>B<);>\nB<long "
"double erfcl(long double >I<x>B<);>\n"

#. type: Plain text
#: man-pages/man3/erfc.3:47
msgid "B<erfc>():"
msgstr "B<erfc>():"

#. type: Plain text
#: man-pages/man3/erfc.3:50
msgid ""
"_BSD_SOURCE || _SVID_SOURCE || _XOPEN_SOURCE || _ISOC99_SOURCE || "
"_POSIX_C_SOURCE\\ E<gt>=\\ 200112L;"
msgstr ""
"_BSD_SOURCE || _SVID_SOURCE || _XOPEN_SOURCE || _ISOC99_SOURCE || "
"_POSIX_C_SOURCE\\ E<gt>=\\ 200112L;"

#. type: Plain text
#: man-pages/man3/erfc.3:57
msgid "B<erfcf>(), B<erfcl>():"
msgstr "B<erfcf>(), B<erfcl>():"

#. type: Plain text
#: man-pages/man3/erfc.3:60
msgid ""
"_BSD_SOURCE || _SVID_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 600|| _ISOC99_SOURCE"
" || _POSIX_C_SOURCE\\ E<gt>=\\ 200112L;"
msgstr ""
"_BSD_SOURCE || _SVID_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 600|| _ISOC99_SOURCE "
"|| _POSIX_C_SOURCE\\ E<gt>=\\ 200112L;"

#. type: Plain text
#: man-pages/man3/erfc.3:71
msgid ""
"The B<erfc>()  function returns the complementary error function of I<x>, "
"that is, 1.0 - erf(x)."
msgstr ""
"Функция B<erfc>() возвращает дополнительную функцию ошибки от I<x>, т.е. 1.0 "
"- erf(x)."

#. type: Plain text
#: man-pages/man3/erfc.3:75
msgid ""
"On success, these functions return the complementary error function of I<x>,"
" a value in the range [0,2]."
msgstr ""
"При успешном выполнении эти функции возвращают дополнительную функцию ошибки "
"от I<x>, значение в диапазоне [0,2]."

#. type: Plain text
#: man-pages/man3/erfc.3:83
msgid "If I<x> is +0 or -0, 1 is returned."
msgstr "Если I<x> равен +0 или -0, возвращается -1."

#. type: Plain text
#: man-pages/man3/erfc.3:88
msgid "If I<x> is positive infinity, +0 is returned."
msgstr "Если I<x> стремится к плюс бесконечности, то будет возвращено +0."

#. type: Plain text
#: man-pages/man3/erfc.3:93
msgid "If I<x> is negative infinity, +2 is returned."
msgstr "Если I<x> равно минус бесконечности, возвращается +2."

#. type: Plain text
#: man-pages/man3/erfc.3:96
msgid ""
"If the function result underflows and produces an unrepresentable value, the"
" return value is 0.0."
msgstr ""
"Если результат функции теряет разрядность и создаётся непредставимое "
"значение, то возвращается значение 0.0."

#.  e.g., erfc(27) on x86-32
#. type: Plain text
#: man-pages/man3/erfc.3:102
msgid ""
"If the function result underflows but produces a representable (i.e., "
"subnormal) value, that value is returned, and a range error occurs."
msgstr ""
"Если в результате функции исчезает порядок числа, но значение представимо "
"(т.е. субнормально), то возвращается это значение и возникает ошибка "
"диапазона."

#. type: TP
#: man-pages/man3/erfc.3:109
#, no-wrap
msgid "Range error: result underflow (result is subnormal)"
msgstr ""
"Ошибка диапазона: результат потерял разрядность (результат субнормален)"

#.  .I errno
#.  is set to
#.  .BR ERANGE .
#. type: Plain text
#: man-pages/man3/erfc.3:117
msgid "An underflow floating-point exception (B<FE_UNDERFLOW>)  is raised."
msgstr ""
"Возникает исключение исчезновение порядка плавающей запятой (B<FE_UNDERFLOW>)."

#.  FIXME . Is it intentional that these functions do not set errno?
#.  Bug raised: http://sources.redhat.com/bugzilla/show_bug.cgi?id=6785
#. type: Plain text
#: man-pages/man3/erfc.3:122
msgid "These functions do not set I<errno>."
msgstr "Эти функции не изменяют I<errno>."

#. type: Plain text
#: man-pages/man3/erfc.3:130
msgid "The B<erfc>(), B<erfcf>(), and B<erfcl>()  functions are thread-safe."
msgstr ""
"Функции B<erfc>(), B<erfcf>() и B<erfcl>() можно использовать в нескольких "
"нитях одновременно."

#. type: Plain text
#: man-pages/man3/erfc.3:136
msgid ""
"C99, POSIX.1-2001.  The variant returning I<double> also conforms to SVr4, "
"4.3BSD."
msgstr ""
"C99, POSIX.1-2001. Вариант, возвращающий значение типа I<double>, также "
"соответствует SVr4 и 4.3BSD."

#. type: Plain text
#: man-pages/man3/erfc.3:146
msgid ""
"The B<erfc>(), B<erfcf>(), and B<erfcl>()  functions are provided to avoid "
"the loss accuracy that would occur for the calculation 1-erf(x) for large "
"values of I<x> (for which the value of erf(x) approaches 1)."
msgstr ""
"Функции B<erfc>(), B<erfcf>() и B<erfcl>() созданы с целью избежания потери "
"точности, которая возникает при вычислении 1-erf(x) для больших значений I<x> "
"(для которых значение erf(x) стремится к 1)."

#. type: Plain text
#: man-pages/man3/erfc.3:149
msgid "B<cerf>(3), B<erf>(3), B<exp>(3)"
msgstr "B<cerf>(3), B<erf>(3), B<exp>(3)"

#. type: TH
#: man-pages/man3/exp10.3:35
#, no-wrap
msgid "EXP10"
msgstr "EXP10"

#. type: TH
#: man-pages/man3/exp10.3:35
#, no-wrap
msgid "2008-08-11"
msgstr "2008-08-11"

#. type: Plain text
#: man-pages/man3/exp10.3:38
msgid "exp10, exp10f, exp10l - base-10 exponential function"
msgstr "exp10, exp10f, exp10l - функция степени по основанию 10"

#. type: Plain text
#: man-pages/man3/exp10.3:41
#, no-wrap
msgid "B<#define _GNU_SOURCE>         /* See feature_test_macros(7) */\n"
msgstr "B<#define _GNU_SOURCE>         /* см. feature_test_macros(7) */\n"

#. type: Plain text
#: man-pages/man3/exp10.3:45
#, no-wrap
msgid "B<double exp10(double >I<x>B<);>\n"
msgstr "B<double exp10(double >I<x>B<);>\n"

#. type: Plain text
#: man-pages/man3/exp10.3:47
#, no-wrap
msgid "B<float exp10f(float >I<x>B<);>\n"
msgstr "B<float exp10f(float >I<x>B<);>\n"

#. type: Plain text
#: man-pages/man3/exp10.3:49
#, no-wrap
msgid "B<long double exp10l(long double >I<x>B<);>\n"
msgstr "B<long double exp10l(long double >I<x>B<);>\n"

#. type: Plain text
#: man-pages/man3/exp10.3:58
msgid ""
"The B<exp10>()  function returns the value of 10 raised to the power of "
"I<x>."
msgstr ""
"Функция B<exp10>() возвращает значение числа 10, возведённое в степень I<x>."

#. type: Plain text
#: man-pages/man3/exp10.3:61
msgid ""
"On success, these functions return the base-10 exponential value of I<x>."
msgstr "При успешной работе эти функции возвращают 10 в степени I<x>."

#. type: Plain text
#: man-pages/man3/exp10.3:84
msgid "B<cbrt>(3), B<exp>(3), B<exp2>(3), B<log10>(3), B<sqrt>(3)"
msgstr "B<cbrt>(3), B<exp>(3), B<exp2>(3), B<log10>(3), B<sqrt>(3)"

#. type: TH
#: man-pages/man3/expm1.3:30
#, no-wrap
msgid "EXPM1"
msgstr "EXPM1"

#. type: TH
#: man-pages/man3/expm1.3:30
#, no-wrap
msgid "2013-10-14"
msgstr "2013-10-14"

#. type: Plain text
#: man-pages/man3/expm1.3:33
msgid "expm1, expm1f, expm1l - exponential minus 1"
msgstr "expm1, expm1f, expm1l - экспоненциальный минус 1"

#. type: Plain text
#: man-pages/man3/expm1.3:38
#, no-wrap
msgid "B<double expm1(double >I<x>B<);>\n"
msgstr "B<double expm1(double >I<x>B<);>\n"

#. type: Plain text
#: man-pages/man3/expm1.3:40
#, no-wrap
msgid "B<float expm1f(float >I<x>B<);>\n"
msgstr "B<float expm1f(float >I<x>B<);>\n"

#. type: Plain text
#: man-pages/man3/expm1.3:42
#, no-wrap
msgid "B<long double expm1l(long double >I<x>B<);>\n"
msgstr "B<long double expm1l(long double >I<x>B<);>\n"

#. type: Plain text
#: man-pages/man3/expm1.3:53
msgid "B<expm1>():"
msgstr "B<expm1>():"

#. type: Plain text
#: man-pages/man3/expm1.3:57
msgid ""
"_BSD_SOURCE || _SVID_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 500 || "
"_XOPEN_SOURCE\\ &&\\ _XOPEN_SOURCE_EXTENDED || _ISOC99_SOURCE || "
"_POSIX_C_SOURCE\\ E<gt>=\\ 200112L;"
msgstr ""
"_BSD_SOURCE || _SVID_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 500 || "
"_XOPEN_SOURCE\\ &&\\ _XOPEN_SOURCE_EXTENDED || _ISOC99_SOURCE || "
"_POSIX_C_SOURCE\\ E<gt>=\\ 200112L;"

#. type: Plain text
#: man-pages/man3/expm1.3:64
msgid "B<expm1f>(), B<expm1l>():"
msgstr "B<expm1f>(), B<expm1l>():"

#. type: Plain text
#: man-pages/man3/expm1.3:75
msgid "I<expm1(x)> returns a value equivalent to"
msgstr "Функция I<expm1(x)> возвращает значение, эквивалентное"

#. type: Plain text
#: man-pages/man3/expm1.3:78
#, no-wrap
msgid "    exp(x) - 1\n"
msgstr "    exp(x) - 1\n"

#. type: Plain text
#: man-pages/man3/expm1.3:88
msgid ""
"It is computed in a way that is accurate even if the value of I<x> is near "
"zero\\(ema case where I<exp(x) - 1> would be inaccurate due to subtraction "
"of two numbers that are nearly equal."
msgstr ""
"Оно вычисляется методом, выдающим точные значения, даже если значение I<x> "
"близко к нулю — случай, где I<exp(x) - 1> было бы неточно из-за вычитания "
"практически одинаковых чисел."

#. type: Plain text
#: man-pages/man3/expm1.3:91
msgid "On success, these functions return I<exp(x)\\ -\\ 1>."
msgstr "При успешном выполнении данные функции возвращают I<exp(x)\\ -\\ 1>."

#. type: Plain text
#: man-pages/man3/expm1.3:101
msgid "If I<x> is +0 (-0), +0 (-0) is returned."
msgstr "Если I<x> равно +0 (-0), будет возвращено +0 (-0)."

#. type: Plain text
#: man-pages/man3/expm1.3:109
msgid "If I<x> is negative infinity, -1 is returned."
msgstr "Если I<x> равно минус бесконечности, возвращается -1."

#. type: Plain text
#: man-pages/man3/expm1.3:117
msgid ""
"If the result overflows, a range error occurs, and the functions return "
"-B<HUGE_VAL>, -B<HUGE_VALF>, or -B<HUGE_VALL>, respectively."
msgstr ""
"Если в результате превышена разрядность, то возникает ошибка диапазона и "
"функции возвращают -B<HUGE_VAL>, -B<HUGE_VALF> или -B<HUGE_VALL>, "
"соответственно."

#.  POSIX.1 specifies an optional range error (underflow) if
#.  x is subnormal.  Glibc does not implement this.
#. type: Plain text
#: man-pages/man3/expm1.3:136
msgid ""
"I<errno> is set to B<ERANGE> (but see BUGS).  An overflow floating-point "
"exception (B<FE_OVERFLOW>)  is raised."
msgstr ""
"Значение I<errno> устанавливается в B<ERANGE> (но см. ДЕФЕКТЫ). Возникает "
"исключение переполнения плавающей точки (B<FE_OVERFLOW>)."

#. type: Plain text
#: man-pages/man3/expm1.3:144
msgid ""
"The B<expm1>(), B<expm1f>(), and B<expm1l>()  functions are thread-safe."
msgstr ""
"Функции B<expm1>(), B<expm1f>() и B<expm1l>() можно использовать в нескольких "
"нитях одновременно."

#.  BSD.
#. type: Plain text
#: man-pages/man3/expm1.3:147
msgid "C99, POSIX.1-2001."
msgstr "C99, POSIX.1-2001."

#.  FIXME .
#.  Bug raised: http://sources.redhat.com/bugzilla/show_bug.cgi?id=6778
#. type: Plain text
#: man-pages/man3/expm1.3:155
msgid ""
"For some large negative I<x> values (where the function result approaches "
"-1), B<expm1>()  raises a bogus underflow floating-point exception."
msgstr ""
"Для некоторых огромных отрицательных значений I<x> (где возвращаемое значение "
"функции близко к -1), B<expm1>() приводит к некорректному исключению "
"исчезновения порядка плавающей точки."

#.  FIXME .
#.  Bug raised: http://sources.redhat.com/bugzilla/show_bug.cgi?id=6814
#.  e.g., expm1(1e5) through expm1(1.00199970127e5),
#.  but not expm1(1.00199970128e5) and beyond.
#. type: Plain text
#: man-pages/man3/expm1.3:166
msgid ""
"For some large positive I<x> values, B<expm1>()  raises a bogus invalid "
"floating-point exception in addition to the expected overflow exception, and"
" returns a NaN instead of positive infinity."
msgstr ""
"Для некоторых огромных положительных значений I<x> кроме ожидаемого "
"исключения переполнения возникает некорректное исключение плавающей точки и "
"возвращается NaN вместо плюс бесконечности."

#.  It looks like the fix was in 2.11, or possibly 2.12.
#.  I have no test system for 2.11, but 2.12 passes.
#.  From the source (sysdeps/i386/fpu/s_expm1.S) it looks
#.  like the changes were in 2.11.
#.  http://sources.redhat.com/bugzilla/show_bug.cgi?id=6788
#. type: Plain text
#: man-pages/man3/expm1.3:178
msgid ""
"Before version 2.11, the glibc implementation did not set I<errno> to "
"B<ERANGE> when a range error occurred."
msgstr ""
"До версии 2.11 в реализации glibc при возникновении ошибки диапазона I<errno> "
"не устанавливалось в значение B<ERANGE>."

#. type: Plain text
#: man-pages/man3/expm1.3:181
msgid "B<exp>(3), B<log>(3), B<log1p>(3)"
msgstr "B<exp>(3), B<log>(3), B<log1p>(3)"

#. type: TH
#: man-pages/man3/euidaccess.3:25
#, no-wrap
msgid "EUIDACCESS"
msgstr "EUIDACCESS"

#. type: TH
#: man-pages/man3/euidaccess.3:25
#, no-wrap
msgid "2013-09-25"
msgstr "2013-09-25"

#. type: Plain text
#: man-pages/man3/euidaccess.3:28
msgid "euidaccess, eaccess - check effective user's permissions for a file"
msgstr "euidaccess, eaccess - проверяет эффективные права пользователя на файл"

#. type: Plain text
#: man-pages/man3/euidaccess.3:32
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>             /* See feature_test_macros(7) */\n"
"B<#include E<lt>unistd.hE<gt>>\n"
msgstr ""
"B<#define _GNU_SOURCE>             /* Смотрите feature_test_macros(7) */\nB<"
"#include E<lt>unistd.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/euidaccess.3:35
#, no-wrap
msgid ""
"B<int euidaccess(const char *>I<pathname>B<, int >I<mode>B<);>\n"
"B<int eaccess(const char *>I<pathname>B<, int >I<mode>B<);>\n"
msgstr ""
"B<int euidaccess(const char *>I<pathname>B<, int >I<mode>B<);>\nB<int "
"eaccess(const char *>I<pathname>B<, int >I<mode>B<);>\n"

#. type: Plain text
#: man-pages/man3/euidaccess.3:47
msgid ""
"Like B<access>(2), B<euidaccess>()  checks permissions and existence of the "
"file identified by its argument I<pathname>.  However, whereas B<access>(2),"
" performs checks using the real user and group identifiers of the process, "
"B<euidaccess>()  uses the effective identifiers."
msgstr ""
"Подобно B<access>(2), B<euidaccess>() проверяет права и существование файла, "
"указанного в аргументе I<pathname>. Однако, если B<access>(2) выполняет "
"проверку для реального идентификатора пользователя и группы процесса, то B<"
"euidaccess>() использует эффективные идентификаторы."

#. type: Plain text
#: man-pages/man3/euidaccess.3:53
msgid ""
"I<mode> is a mask consisting of one or more of B<R_OK>, B<W_OK>, B<X_OK>, "
"and B<F_OK>, with the same meanings as for B<access>(2)."
msgstr ""
"Значение I<mode> представляет собой маску, состоящую из одного и более флагов "
"B<R_OK>, B<W_OK>, B<X_OK> и B<F_OK> (значение описано в B<access>(2))."

#. type: Plain text
#: man-pages/man3/euidaccess.3:58
msgid ""
"B<eaccess>()  is a synonym for B<euidaccess>(), provided for compatibility "
"with some other systems."
msgstr ""
"Функция B<eaccess>() — ещё одно название B<euidaccess>(), предоставляется для "
"совместимости с некоторыми другими системами."

#. type: Plain text
#: man-pages/man3/euidaccess.3:66
msgid ""
"On success (all requested permissions granted), zero is returned.  On error "
"(at least one bit in I<mode> asked for a permission that is denied, or some "
"other error occurred), -1 is returned, and I<errno> is set appropriately."
msgstr ""
"При успешном выполнении (есть все запрошенные права) возвращается нуль. При "
"ошибке (по крайней мере, один флаг из I<mode> был не удовлетворён, или "
"произошла другая ошибка), возвращается -1, а I<errno> устанавливается должным "
"образом."

#. type: Plain text
#: man-pages/man3/euidaccess.3:69
msgid "As for B<access>(2)."
msgstr "Аналогичны B<access>(2)."

#. type: Plain text
#: man-pages/man3/euidaccess.3:73
msgid "The B<eaccess>()  function was added to glibc in version 2.4."
msgstr "Функция B<eaccess>() впервые появилась в glibc 2.4."

#. type: Plain text
#: man-pages/man3/euidaccess.3:80
msgid "The B<euidaccess>()  and B<eaccess>()  functions are thread-safe."
msgstr ""
"Функции B<eeuidaccess>() и B<eaccess>()можно использовать в нескольких нитях "
"одновременно."

#.  e.g., FreeBSD 6.1.
#. type: Plain text
#: man-pages/man3/euidaccess.3:86
msgid ""
"These functions are nonstandard.  Some other systems have an B<eaccess>()  "
"function."
msgstr ""
"Эти функции являются нестандартными. В некоторых системах есть функция B<"
"eaccess>()."

#. type: Plain text
#: man-pages/man3/euidaccess.3:93
msgid ""
"I<Warning>: Using this function to check a process's permissions on a file "
"before performing some operation based on that information leads to race "
"conditions: the file permissions may change between the two steps.  "
"Generally, it is safer just to attempt the desired operation and handle any "
"permission error that occurs."
msgstr ""
"I<Предупреждение>: Использование этой функции для проверки прав процесса на "
"файл перед выполнением какой-то операции на основе этой информации приводит к "
"состоянию состязательности: права на файл могут измениться между двумя этими "
"шагами. Обычно, безопасней просто попытаться выполнить желаемую операцию и "
"что-то предпринять при возникновении ошибки с правами."

#. type: Plain text
#: man-pages/man3/euidaccess.3:101
msgid ""
"This function always dereferences symbolic links.  If you need to check the "
"permissions on a symbolic link, use B<faccessat>(2)  with the flags "
"B<AT_EACCESS> and B<AT_SYMLINK_NOFOLLOW>."
msgstr ""
"Эта функция всегда разыменовывает символьные ссылки. Если вам нужно проверить "
"права символьной ссылки, используйте вызов B<faccessat>(2) с флагами B<"
"AT_EACCESS> и B<AT_SYMLINK_NOFOLLOW>."

#. type: Plain text
#: man-pages/man3/euidaccess.3:111
msgid ""
"B<access>(2), B<chmod>(2), B<chown>(2), B<faccessat>(2), B<open>(2), "
"B<setgid>(2), B<setuid>(2), B<stat>(2), B<credentials>(7), "
"B<path_resolution>(7)"
msgstr ""
"B<access>(2), B<chmod>(2), B<chown>(2), B<faccessat>(2), B<open>(2), B<setgid>"
"(2), B<setuid>(2), B<stat>(2), B<credentials>(7), B<path_resolution>(7)"

#. type: TH
#: man-pages/man3/erf.3:35
#, no-wrap
msgid "ERF"
msgstr "ERF"

#. type: Plain text
#: man-pages/man3/erf.3:38
msgid "erf, erff, erfl, - error function"
msgstr "erf, erff, erfl - функция ошибки"

#. type: Plain text
#: man-pages/man3/erf.3:45
#, no-wrap
msgid ""
"B<double erf(double >I<x>B<);>\n"
"B<float erff(float >I<x>B<);>\n"
"B<long double erfl(long double >I<x>B<);>\n"
msgstr ""
"B<double erf(double >I<x>B<);>\nB<float erff(float >I<x>B<);>\nB<long double "
"erfl(long double >I<x>B<);>\n"

#. type: Plain text
#: man-pages/man3/erf.3:56
msgid "B<erf>():"
msgstr "B<erf>():"

#. type: Plain text
#: man-pages/man3/erf.3:66
msgid "B<erff>(), B<erfl>():"
msgstr "B<erff>(), B<erfl>():"

#. type: Plain text
#: man-pages/man3/erf.3:81
msgid "The B<erf>()  function returns the error function of I<x>, defined as"
msgstr ""
"Функция B<erf>() возвращает функцию ошибки от I<x>, определяемую следующим "
"образом:"

#. type: TP
#: man-pages/man3/erf.3:81
#, no-wrap
msgid "    erf(x) = 2/sqrt(pi)* integral from 0 to x of exp(-t*t) dt"
msgstr "    erf(x) = 2/sqrt(pi)* интеграл от 0 до x по exp(-t*t) dt"

#. type: Plain text
#: man-pages/man3/erf.3:87
msgid ""
"On success, these functions return the error function of I<x>, a value in "
"the range [-1,\\ 1]."
msgstr ""
"При успешном выполнении эти функции возвращают функцию ошибки от I<x>, "
"значение в диапазоне [-1,\\ 1]."

#. type: Plain text
#: man-pages/man3/erf.3:100
msgid "If I<x> is positive infinity (negative infinity), +1 (-1) is returned."
msgstr ""
"Если I<x> стремится к плюс или минус бесконечности, то будет возвращено +1 "
"или -1."

#. type: Plain text
#: man-pages/man3/erf.3:106
msgid ""
"If I<x> is subnormal, a range error occurs, and the return value is "
"2*x/sqrt(pi)."
msgstr ""
"Если значение I<x> субнормально, то генерируется ошибка диапазона и "
"возвращается значение 2*x/sqrt(pi)."

#. type: TP
#: man-pages/man3/erf.3:113
#, no-wrap
msgid "Range error: result underflow (I<x> is subnormal)"
msgstr "Ошибка диапазона: результат потерял разрядность (I<x> субнормально)"

#. type: Plain text
#: man-pages/man3/erf.3:134
msgid "The B<erf>(), B<erff>(), and B<erfl>()  functions are thread-safe."
msgstr ""
"Функции B<erf>(), B<erff>() и B<erfl>() можно использовать в нескольких нитях "
"одновременно."

#. type: Plain text
#: man-pages/man3/erf.3:143
msgid "B<cerf>(3), B<erfc>(3), B<exp>(3)"
msgstr "B<cerf>(3), B<erfc>(3), B<exp>(3)"


