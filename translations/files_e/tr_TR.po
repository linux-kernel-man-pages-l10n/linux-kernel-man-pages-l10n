# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# 
# Translators:
msgid ""
msgstr ""
"Project-Id-Version: translation of man-pages\n"
"POT-Creation-Date: 2017-10-19 18:56+0300\n"
"PO-Revision-Date: 2019-04-02 15:54+0000\n"
"Last-Translator: Yuri Kozlov <yuray@komyakino.ru>\n"
"Language-Team: Turkish (Turkey) (http://www.transifex.com/kruvalig/man-pages/language/tr_TR/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: tr_TR\n"
"Plural-Forms: nplurals=2; plural=(n > 1);\n"

#. type: TH
#: man-pages/man7/environ.7:34
#, no-wrap
msgid "ENVIRON"
msgstr ""

#. type: TH
#: man-pages/man7/environ.7:34
#, no-wrap
msgid "2017-09-15"
msgstr ""

#. type: TH
#: man-pages/man7/environ.7:34
#, no-wrap
msgid "Linux"
msgstr ""

#. type: TH
#: man-pages/man7/environ.7:34
#, no-wrap
msgid "Linux Programmer's Manual"
msgstr ""

#. type: SH
#: man-pages/man7/environ.7:35
#, no-wrap
msgid "NAME"
msgstr ""

#. type: Plain text
#: man-pages/man7/environ.7:37
msgid "environ - user environment"
msgstr ""

#. type: SH
#: man-pages/man7/environ.7:37
#, no-wrap
msgid "SYNOPSIS"
msgstr ""

#. type: Plain text
#: man-pages/man7/environ.7:40
#, no-wrap
msgid "B<extern char **>I<environ>B<;>\n"
msgstr ""

#. type: SH
#: man-pages/man7/environ.7:41
#, no-wrap
msgid "DESCRIPTION"
msgstr ""

#. type: Plain text
#: man-pages/man7/environ.7:60
msgid ""
"The variable I<environ> points to an array of pointers to strings called the"
" \"environment\".  The last pointer in this array has the value NULL.  (This"
" variable must be declared in the user program, but is declared in the "
"header file I<E<lt>unistd.hE<gt>> if the B<_GNU_SOURCE> feature test macro "
"is defined.)  This array of strings is made available to the process by the "
"B<exec>(3)  call that started the process.  When a child process is created "
"via B<fork>(2), it inherits a I<copy> of its parent's environment."
msgstr ""

#. type: Plain text
#: man-pages/man7/environ.7:65
msgid ""
"By convention the strings in I<environ> have the form "
"\"I<name>B<=>I<value>\".  Common examples are:"
msgstr ""

#. type: TP
#: man-pages/man7/environ.7:65
#, no-wrap
msgid "B<USER>"
msgstr ""

#. type: Plain text
#: man-pages/man7/environ.7:68
msgid "The name of the logged-in user (used by some BSD-derived programs)."
msgstr ""

#. type: TP
#: man-pages/man7/environ.7:68
#, no-wrap
msgid "B<LOGNAME>"
msgstr ""

#. type: Plain text
#: man-pages/man7/environ.7:71
msgid ""
"The name of the logged-in user (used by some System-V derived programs)."
msgstr ""

#. type: TP
#: man-pages/man7/environ.7:71
#, no-wrap
msgid "B<HOME>"
msgstr ""

#. type: Plain text
#: man-pages/man7/environ.7:77
msgid ""
"A user's login directory, set by B<login>(1)  from the password file "
"B<passwd>(5)."
msgstr ""

#. type: TP
#: man-pages/man7/environ.7:77
#, no-wrap
msgid "B<LANG>"
msgstr ""

#. type: Plain text
#: man-pages/man7/environ.7:95
msgid ""
"The name of a locale to use for locale categories when not overridden by "
"B<LC_ALL> or more specific environment variables such as B<LC_COLLATE>, "
"B<LC_CTYPE>, B<LC_MESSAGES>, B<LC_MONETARY>, B<LC_NUMERIC>, and B<LC_TIME> "
"(see B<locale>(7)  for further details of the B<LC_*> environment "
"variables)."
msgstr ""

#. type: TP
#: man-pages/man7/environ.7:95
#, no-wrap
msgid "B<PATH>"
msgstr ""

#. type: Plain text
#: man-pages/man7/environ.7:110
msgid ""
"The sequence of directory prefixes that B<sh>(1)  and many other programs "
"apply in searching for a file known by an incomplete pathname.  The prefixes"
" are separated by \\(aqB<:>\\(aq.  (Similarly one has B<CDPATH> used by some"
" shells to find the target of a change directory command, B<MANPATH> used by"
" B<man>(1)  to find manual pages, and so on)"
msgstr ""

#. type: TP
#: man-pages/man7/environ.7:110
#, no-wrap
msgid "B<PWD>"
msgstr ""

#. type: Plain text
#: man-pages/man7/environ.7:114
msgid "The current working directory.  Set by some shells."
msgstr ""

#. type: TP
#: man-pages/man7/environ.7:114
#, no-wrap
msgid "B<SHELL>"
msgstr ""

#. type: Plain text
#: man-pages/man7/environ.7:117
msgid "The pathname of the user's login shell."
msgstr ""

#. type: TP
#: man-pages/man7/environ.7:117
#, no-wrap
msgid "B<TERM>"
msgstr ""

#. type: Plain text
#: man-pages/man7/environ.7:120
msgid "The terminal type for which output is to be prepared."
msgstr ""

#. type: TP
#: man-pages/man7/environ.7:120
#, no-wrap
msgid "B<PAGER>"
msgstr ""

#. type: Plain text
#: man-pages/man7/environ.7:123
msgid "The user's preferred utility to display text files."
msgstr ""

#. type: TP
#: man-pages/man7/environ.7:123
#, no-wrap
msgid "B<EDITOR>/B<VISUAL>"
msgstr ""

#.  .TP
#.  .B BROWSER
#.  The user's preferred utility to browse URLs. Sequence of colon-separated
#.  browser commands. See http://www.catb.org/~esr/BROWSER/ .
#. type: Plain text
#: man-pages/man7/environ.7:130
msgid "The user's preferred utility to edit text files."
msgstr ""

#. type: Plain text
#: man-pages/man7/environ.7:139
msgid ""
"Names may be placed in the shell's environment by the I<export> command in "
"B<sh>(1), or by the I<setenv> command if you use B<csh>(1)."
msgstr ""

#. type: Plain text
#: man-pages/man7/environ.7:152
msgid ""
"The initial environment of the shell is populated in various ways, such as "
"definitions from I</etc/environment> that are processed by B<pam_env>(8)  "
"for all users at login time (on systems that employ B<pam>(8)).  In "
"addition, various shell initialization scripts, such as the system-wide "
"I</etc/profile> script and per-user initializations script may include "
"commands that add variables to the shell's environment; see the manual page "
"of your preferred shell for details."
msgstr ""

#. type: Plain text
#: man-pages/man7/environ.7:154
msgid "Bourne-style shells support the syntax"
msgstr ""

#. type: Plain text
#: man-pages/man7/environ.7:156
#, no-wrap
msgid "    NAME=value command\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/environ.7:162
msgid ""
"to create an environment variable definition only in the scope of the "
"process that executes I<command>.  Multiple variable definitions, separated "
"by white space, may precede I<command>."
msgstr ""

#. type: Plain text
#: man-pages/man7/environ.7:172
msgid ""
"Arguments may also be placed in the environment at the point of an "
"B<exec>(3).  A C program can manipulate its environment using the functions "
"B<getenv>(3), B<putenv>(3), B<setenv>(3), and B<unsetenv>(3)."
msgstr ""

#. type: Plain text
#: man-pages/man7/environ.7:176
msgid ""
"Note that the behavior of many programs and library routines is influenced "
"by the presence or value of certain environment variables.  Examples include"
" the following:"
msgstr ""

#. type: IP
#: man-pages/man7/environ.7:176 man-pages/man7/environ.7:185
#: man-pages/man7/environ.7:192 man-pages/man7/environ.7:197
#: man-pages/man7/environ.7:201 man-pages/man7/environ.7:207
#: man-pages/man7/environ.7:213 man-pages/man7/environ.7:224
#: man-pages/man7/environ.7:228 man-pages/man7/environ.7:231
#, no-wrap
msgid "*"
msgstr ""

#. type: Plain text
#: man-pages/man7/environ.7:185
msgid ""
"The variables B<LANG>, B<LANGUAGE>, B<NLSPATH>, B<LOCPATH>, B<LC_ALL>, "
"B<LC_MESSAGES>, and so on influence locale handling; see B<catopen>(3), "
"B<gettext>(3), and B<locale>(7)."
msgstr ""

#. type: Plain text
#: man-pages/man7/environ.7:192
msgid ""
"B<TMPDIR> influences the path prefix of names created by B<tempnam>(3)  and "
"other routines, and the temporary directory used by B<sort>(1)  and other "
"programs."
msgstr ""

#. type: Plain text
#: man-pages/man7/environ.7:197
msgid ""
"B<LD_LIBRARY_PATH>, B<LD_PRELOAD>, and other B<LD_*> variables influence the"
" behavior of the dynamic loader/linker."
msgstr ""

#. type: Plain text
#: man-pages/man7/environ.7:201
msgid ""
"B<POSIXLY_CORRECT> makes certain programs and library routines follow the "
"prescriptions of POSIX."
msgstr ""

#. type: Plain text
#: man-pages/man7/environ.7:207
msgid "The behavior of B<malloc>(3)  is influenced by B<MALLOC_*> variables."
msgstr ""

#. type: Plain text
#: man-pages/man7/environ.7:213
msgid ""
"The variable B<HOSTALIASES> gives the name of a file containing aliases to "
"be used with B<gethostbyname>(3)."
msgstr ""

#. type: Plain text
#: man-pages/man7/environ.7:224
msgid ""
"B<TZ> and B<TZDIR> give timezone information used by B<tzset>(3)  and "
"through that by functions like B<ctime>(3), B<localtime>(3), B<mktime>(3), "
"B<strftime>(3).  See also B<tzselect>(8)."
msgstr ""

#. type: Plain text
#: man-pages/man7/environ.7:228
msgid ""
"B<TERMCAP> gives information on how to address a given terminal (or gives "
"the name of a file containing such information)."
msgstr ""

#. type: Plain text
#: man-pages/man7/environ.7:231
msgid ""
"B<COLUMNS> and B<LINES> tell applications about the window size, possibly "
"overriding the actual size."
msgstr ""

#. type: Plain text
#: man-pages/man7/environ.7:236
msgid ""
"B<PRINTER> or B<LPDEST> may specify the desired printer to use.  See "
"B<lpr>(1)."
msgstr ""

#. type: SH
#: man-pages/man7/environ.7:236
#, no-wrap
msgid "NOTES"
msgstr ""

#. type: Plain text
#: man-pages/man7/environ.7:243
msgid ""
"The B<prctl>(2)  B<PR_SET_MM_ENV_START> and B<PR_SET_MM_ENV_END> operations "
"can be used to control the location of the process's environment."
msgstr ""

#. type: SH
#: man-pages/man7/environ.7:243
#, no-wrap
msgid "BUGS"
msgstr ""

#. type: Plain text
#: man-pages/man7/environ.7:248
msgid ""
"Clearly there is a security risk here.  Many a system command has been "
"tricked into mischief by a user who specified unusual values for B<IFS> or "
"B<LD_LIBRARY_PATH>."
msgstr ""

#. type: Plain text
#: man-pages/man7/environ.7:281
msgid ""
"There is also the risk of name space pollution.  Programs like I<make> and "
"I<autoconf> allow overriding of default utility names from the environment "
"with similarly named variables in all caps.  Thus one uses B<CC> to select "
"the desired C compiler (and similarly B<MAKE>, B<AR>, B<AS>, B<FC>, B<LD>, "
"B<LEX>, B<RM>, B<YACC>, etc.).  However, in some traditional uses such an "
"environment variable gives options for the program instead of a pathname.  "
"Thus, one has B<MORE>, B<LESS>, and B<GZIP>.  Such usage is considered "
"mistaken, and to be avoided in new programs.  The authors of I<gzip> should "
"consider renaming their option to B<GZIP_OPT>."
msgstr ""

#. type: SH
#: man-pages/man7/environ.7:281
#, no-wrap
msgid "SEE ALSO"
msgstr ""

#. type: Plain text
#: man-pages/man7/environ.7:298
msgid ""
"B<bash>(1), B<csh>(1), B<env>(1), B<login>(1), B<printenv>(1), B<sh>(1), "
"B<tcsh>(1), B<execve>(2), B<clearenv>(3), B<exec>(3), B<getenv>(3), "
"B<putenv>(3), B<setenv>(3), B<unsetenv>(3), B<locale>(7), B<ld.so>(8), "
"B<pam_env>(8)"
msgstr ""

#. type: TH
#: man-pages/man7/epoll.7:21
#, no-wrap
msgid "EPOLL"
msgstr ""

#. type: TH
#: man-pages/man7/epoll.7:21
#, no-wrap
msgid "2019-03-06"
msgstr ""

#. type: Plain text
#: man-pages/man7/epoll.7:24
msgid "epoll - I/O event notification facility"
msgstr ""

#. type: Plain text
#: man-pages/man7/epoll.7:26
msgid "B<#include E<lt>sys/epoll.hE<gt>>"
msgstr ""

#. type: Plain text
#: man-pages/man7/epoll.7:36
msgid ""
"The B<epoll> API performs a similar task to B<poll>(2): monitoring multiple "
"file descriptors to see if I/O is possible on any of them.  The B<epoll> API"
" can be used either as an edge-triggered or a level-triggered interface and "
"scales well to large numbers of watched file descriptors."
msgstr ""

#. type: Plain text
#: man-pages/man7/epoll.7:44
msgid ""
"The central concept of the B<epoll> API is the B<epoll> I<instance>, an in-"
"kernel data structure which, from a user-space perspective, can be "
"considered as a container for two lists:"
msgstr ""

#. type: Plain text
#: man-pages/man7/epoll.7:51
msgid ""
"The I<interest> list (sometimes also called the B<epoll> set): the set of "
"file descriptors that the process has registered an interest in monitoring."
msgstr ""

#. type: Plain text
#: man-pages/man7/epoll.7:59
msgid ""
"The I<ready> list: the set of file descriptors that are \"ready\" for I/O.  "
"The ready list is a subset of (or, more precisely, a set of references to)  "
"the file descriptors in the interest list that is dynamically populated by "
"the kernel as a result of I/O activity on those file descriptors."
msgstr ""

#. type: Plain text
#: man-pages/man7/epoll.7:64
msgid ""
"The following system calls are provided to create and manage an B<epoll> "
"instance:"
msgstr ""

#. type: Plain text
#: man-pages/man7/epoll.7:73
msgid ""
"B<epoll_create>(2)  creates a new B<epoll> instance and returns a file "
"descriptor referring to that instance.  (The more recent B<epoll_create1>(2)"
"  extends the functionality of B<epoll_create>(2).)"
msgstr ""

#. type: Plain text
#: man-pages/man7/epoll.7:79
msgid ""
"Interest in particular file descriptors is then registered via "
"B<epoll_ctl>(2), which adds items to the interest list of the B<epoll> "
"instance."
msgstr ""

#. type: Plain text
#: man-pages/man7/epoll.7:88
msgid ""
"B<epoll_wait>(2)  waits for I/O events, blocking the calling thread if no "
"events are currently available.  (This system call can be thought of as "
"fetching items from the ready list of the B<epoll> instance.)"
msgstr ""

#. type: SS
#: man-pages/man7/epoll.7:88
#, no-wrap
msgid "Level-triggered and edge-triggered"
msgstr ""

#. type: Plain text
#: man-pages/man7/epoll.7:97
msgid ""
"The B<epoll> event distribution interface is able to behave both as edge-"
"triggered (ET) and as level-triggered (LT).  The difference between the two "
"mechanisms can be described as follows.  Suppose that this scenario happens:"
msgstr ""

#. type: IP
#: man-pages/man7/epoll.7:97 man-pages/man7/epoll.7:381
#, no-wrap
msgid "1."
msgstr ""

#. type: Plain text
#: man-pages/man7/epoll.7:103
msgid ""
"The file descriptor that represents the read side of a pipe (I<rfd>)  is "
"registered on the B<epoll> instance."
msgstr ""

#. type: IP
#: man-pages/man7/epoll.7:103 man-pages/man7/epoll.7:415
#, no-wrap
msgid "2."
msgstr ""

#. type: Plain text
#: man-pages/man7/epoll.7:105
msgid "A pipe writer writes 2\\ kB of data on the write side of the pipe."
msgstr ""

#. type: IP
#: man-pages/man7/epoll.7:105 man-pages/man7/epoll.7:425
#, no-wrap
msgid "3."
msgstr ""

#. type: Plain text
#: man-pages/man7/epoll.7:111
msgid ""
"A call to B<epoll_wait>(2)  is done that will return I<rfd> as a ready file "
"descriptor."
msgstr ""

#. type: IP
#: man-pages/man7/epoll.7:111 man-pages/man7/epoll.7:435
#, no-wrap
msgid "4."
msgstr ""

#. type: Plain text
#: man-pages/man7/epoll.7:114
msgid "The pipe reader reads 1\\ kB of data from I<rfd>."
msgstr ""

#. type: IP
#: man-pages/man7/epoll.7:114 man-pages/man7/epoll.7:449
#, no-wrap
msgid "5."
msgstr ""

#. type: Plain text
#: man-pages/man7/epoll.7:118
msgid "A call to B<epoll_wait>(2)  is done."
msgstr ""

#. type: Plain text
#: man-pages/man7/epoll.7:153
msgid ""
"If the I<rfd> file descriptor has been added to the B<epoll> interface using"
" the B<EPOLLET> (edge-triggered)  flag, the call to B<epoll_wait>(2)  done "
"in step B<5> will probably hang despite the available data still present in "
"the file input buffer; meanwhile the remote peer might be expecting a "
"response based on the data it already sent.  The reason for this is that "
"edge-triggered mode delivers events only when changes occur on the monitored"
" file descriptor.  So, in step B<5> the caller might end up waiting for some"
" data that is already present inside the input buffer.  In the above "
"example, an event on I<rfd> will be generated because of the write done in "
"B<2> and the event is consumed in B<3>.  Since the read operation done in "
"B<4> does not consume the whole buffer data, the call to B<epoll_wait>(2)  "
"done in step B<5> might block indefinitely."
msgstr ""

#. type: Plain text
#: man-pages/man7/epoll.7:163
msgid ""
"An application that employs the B<EPOLLET> flag should use nonblocking file "
"descriptors to avoid having a blocking read or write starve a task that is "
"handling multiple file descriptors.  The suggested way to use B<epoll> as an"
" edge-triggered (B<EPOLLET>)  interface is as follows:"
msgstr ""

#. type: TP
#: man-pages/man7/epoll.7:164
#, no-wrap
msgid "B<i>"
msgstr ""

#. type: Plain text
#: man-pages/man7/epoll.7:167
msgid "with nonblocking file descriptors; and"
msgstr ""

#. type: TP
#: man-pages/man7/epoll.7:167
#, no-wrap
msgid "B<ii>"
msgstr ""

#. type: Plain text
#: man-pages/man7/epoll.7:175
msgid ""
"by waiting for an event only after B<read>(2)  or B<write>(2)  return "
"B<EAGAIN>."
msgstr ""

#. type: Plain text
#: man-pages/man7/epoll.7:186
msgid ""
"By contrast, when used as a level-triggered interface (the default, when "
"B<EPOLLET> is not specified), B<epoll> is simply a faster B<poll>(2), and "
"can be used wherever the latter is used since it shares the same semantics."
msgstr ""

#. type: Plain text
#: man-pages/man7/epoll.7:203
msgid ""
"Since even with edge-triggered B<epoll>, multiple events can be generated "
"upon receipt of multiple chunks of data, the caller has the option to "
"specify the B<EPOLLONESHOT> flag, to tell B<epoll> to disable the associated"
" file descriptor after the receipt of an event with B<epoll_wait>(2).  When "
"the B<EPOLLONESHOT> flag is specified, it is the caller's responsibility to "
"rearm the file descriptor using B<epoll_ctl>(2)  with B<EPOLL_CTL_MOD>."
msgstr ""

#. type: Plain text
#: man-pages/man7/epoll.7:220
msgid ""
"If multiple threads (or processes, if child processes have inherited the "
"B<epoll> file descriptor across B<fork>(2))  are blocked in B<epoll_wait>(2)"
"  waiting on the same the same epoll file descriptor and a file descriptor "
"in the interest list that is marked for edge-triggered (B<EPOLLET>)  "
"notification becomes ready, just one of the threads (or processes) is awoken"
" from B<epoll_wait>(2).  This provides a useful optimization for avoiding "
"\"thundering herd\" wake-ups in some scenarios."
msgstr ""

#. type: SS
#: man-pages/man7/epoll.7:220
#, no-wrap
msgid "Interaction with autosleep"
msgstr ""

#. type: Plain text
#: man-pages/man7/epoll.7:232
msgid ""
"If the system is in B<autosleep> mode via I</sys/power/autosleep> and an "
"event happens which wakes the device from sleep, the device driver will keep"
" the device awake only until that event is queued.  To keep the device awake"
" until the event has been processed, it is necessary to use the "
"B<epoll_ctl>(2)  B<EPOLLWAKEUP> flag."
msgstr ""

#. type: Plain text
#: man-pages/man7/epoll.7:251
msgid ""
"When the B<EPOLLWAKEUP> flag is set in the B<events> field for a I<struct "
"epoll_event>, the system will be kept awake from the moment the event is "
"queued, through the B<epoll_wait>(2)  call which returns the event until the"
" subsequent B<epoll_wait>(2)  call.  If the event should keep the system "
"awake beyond that time, then a separate I<wake_lock> should be taken before "
"the second B<epoll_wait>(2)  call."
msgstr ""

#. type: SS
#: man-pages/man7/epoll.7:251
#, no-wrap
msgid "/proc interfaces"
msgstr ""

#.  Following was added in 2.6.28, but them removed in 2.6.29
#.  .TP
#.  .IR /proc/sys/fs/epoll/max_user_instances " (since Linux 2.6.28)"
#.  This specifies an upper limit on the number of epoll instances
#.  that can be created per real user ID.
#. type: Plain text
#: man-pages/man7/epoll.7:259
msgid ""
"The following interfaces can be used to limit the amount of kernel memory "
"consumed by epoll:"
msgstr ""

#. type: TP
#: man-pages/man7/epoll.7:259
#, no-wrap
msgid "I</proc/sys/fs/epoll/max_user_watches> (since Linux 2.6.28)"
msgstr ""

#.  2.6.29 (in 2.6.28, the default was 1/32 of lowmem)
#. type: Plain text
#: man-pages/man7/epoll.7:273
msgid ""
"This specifies a limit on the total number of file descriptors that a user "
"can register across all epoll instances on the system.  The limit is per "
"real user ID.  Each registered file descriptor costs roughly 90 bytes on a "
"32-bit kernel, and roughly 160 bytes on a 64-bit kernel.  Currently, the "
"default value for I<max_user_watches> is 1/25 (4%) of the available low "
"memory, divided by the registration cost in bytes."
msgstr ""

#. type: SS
#: man-pages/man7/epoll.7:273
#, no-wrap
msgid "Example for suggested usage"
msgstr ""

#. type: Plain text
#: man-pages/man7/epoll.7:302
msgid ""
"While the usage of B<epoll> when employed as a level-triggered interface "
"does have the same semantics as B<poll>(2), the edge-triggered usage "
"requires more clarification to avoid stalls in the application event loop.  "
"In this example, listener is a nonblocking socket on which B<listen>(2)  has"
" been called.  The function I<do_use_fd()> uses the new ready file "
"descriptor until B<EAGAIN> is returned by either B<read>(2)  or B<write>(2)."
"  An event-driven state machine application should, after having received "
"B<EAGAIN>, record its current state so that at the next call to "
"I<do_use_fd()> it will continue to B<read>(2)  or B<write>(2)  from where it"
" stopped before."
msgstr ""

#. type: Plain text
#: man-pages/man7/epoll.7:308
#, no-wrap
msgid ""
"#define MAX_EVENTS 10\n"
"struct epoll_event ev, events[MAX_EVENTS];\n"
"int listen_sock, conn_sock, nfds, epollfd;\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/epoll.7:311
#, no-wrap
msgid ""
"/* Code to set up listening socket, \\(aqlisten_sock\\(aq,\n"
"   (socket(), bind(), listen()) omitted */\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/epoll.7:317
#, no-wrap
msgid ""
"epollfd = epoll_create1(0);\n"
"if (epollfd == -1) {\n"
"    perror(\"epoll_create1\");\n"
"    exit(EXIT_FAILURE);\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/epoll.7:324
#, no-wrap
msgid ""
"ev.events = EPOLLIN;\n"
"ev.data.fd = listen_sock;\n"
"if (epoll_ctl(epollfd, EPOLL_CTL_ADD, listen_sock, &ev) == -1) {\n"
"    perror(\"epoll_ctl: listen_sock\");\n"
"    exit(EXIT_FAILURE);\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/epoll.7:331
#, no-wrap
msgid ""
"for (;;) {\n"
"    nfds = epoll_wait(epollfd, events, MAX_EVENTS, -1);\n"
"    if (nfds == -1) {\n"
"        perror(\"epoll_wait\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/epoll.7:353
#, no-wrap
msgid ""
"    for (n = 0; n E<lt> nfds; ++n) {\n"
"        if (events[n].data.fd == listen_sock) {\n"
"            conn_sock = accept(listen_sock,\n"
"                               (struct sockaddr *) &addr, &addrlen);\n"
"            if (conn_sock == -1) {\n"
"                perror(\"accept\");\n"
"                exit(EXIT_FAILURE);\n"
"            }\n"
"            setnonblocking(conn_sock);\n"
"            ev.events = EPOLLIN | EPOLLET;\n"
"            ev.data.fd = conn_sock;\n"
"            if (epoll_ctl(epollfd, EPOLL_CTL_ADD, conn_sock,\n"
"                        &ev) == -1) {\n"
"                perror(\"epoll_ctl: conn_sock\");\n"
"                exit(EXIT_FAILURE);\n"
"            }\n"
"        } else {\n"
"            do_use_fd(events[n].data.fd);\n"
"        }\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/epoll.7:372
msgid ""
"When used as an edge-triggered interface, for performance reasons, it is "
"possible to add the file descriptor inside the B<epoll> interface "
"(B<EPOLL_CTL_ADD>)  once by specifying (B<EPOLLIN>|B<EPOLLOUT>).  This "
"allows you to avoid continuously switching between B<EPOLLIN> and "
"B<EPOLLOUT> calling B<epoll_ctl>(2)  with B<EPOLL_CTL_MOD>."
msgstr ""

#. type: SS
#: man-pages/man7/epoll.7:372
#, no-wrap
msgid "Questions and answers"
msgstr ""

#. type: IP
#: man-pages/man7/epoll.7:373
#, no-wrap
msgid "0."
msgstr ""

#. type: Plain text
#: man-pages/man7/epoll.7:376
msgid ""
"What is the key used to distinguish the file descriptors registered in an "
"interest list?"
msgstr ""

#. type: Plain text
#: man-pages/man7/epoll.7:381
msgid ""
"The key is the combination of the file descriptor number and the open file "
"description (also known as an \"open file handle\", the kernel's internal "
"representation of an open file)."
msgstr ""

#. type: Plain text
#: man-pages/man7/epoll.7:385
msgid ""
"What happens if you register the same file descriptor on an B<epoll> "
"instance twice?"
msgstr ""

#.  But a file descriptor duplicated by fork(2) can't be added to the
#.  set, because the [file *, fd] pair is already in the epoll set.
#.  That is a somewhat ugly inconsistency.  On the one hand, a child process
#.  cannot add the duplicate file descriptor to the epoll set.  (In every
#.  other case that I can think of, file descriptors duplicated by fork have
#.  similar semantics to file descriptors duplicated by dup() and friends.)
#. On
#.  the other hand, the very fact that the child has a duplicate of the
#.  file descriptor means that even if the parent closes its file descriptor,
#.  then epoll_wait() in the parent will continue to receive notifications for
#.  that file descriptor because of the duplicated file descriptor in the
#. child.
#.  See http://thread.gmane.org/gmane.linux.kernel/596462/
#.  "epoll design problems with common fork/exec patterns"
#.  mtk, Feb 2008
#. type: Plain text
#: man-pages/man7/epoll.7:415
msgid ""
"You will probably get B<EEXIST>.  However, it is possible to add a duplicate"
" (B<dup>(2), B<dup2>(2), B<fcntl>(2)  B<F_DUPFD>)  file descriptor to the "
"same B<epoll> instance.  This can be a useful technique for filtering "
"events, if the duplicate file descriptors are registered with different "
"I<events> masks."
msgstr ""

#. type: Plain text
#: man-pages/man7/epoll.7:422
msgid ""
"Can two B<epoll> instances wait for the same file descriptor? If so, are "
"events reported to both B<epoll> file descriptors?"
msgstr ""

#. type: Plain text
#: man-pages/man7/epoll.7:425
msgid ""
"Yes, and events would be reported to both.  However, careful programming may"
" be needed to do this correctly."
msgstr ""

#. type: Plain text
#: man-pages/man7/epoll.7:429
msgid "Is the B<epoll> file descriptor itself poll/epoll/selectable?"
msgstr ""

#. type: Plain text
#: man-pages/man7/epoll.7:435
msgid ""
"Yes.  If an B<epoll> file descriptor has events waiting, then it will "
"indicate as being readable."
msgstr ""

#. type: Plain text
#: man-pages/man7/epoll.7:439
msgid ""
"What happens if one attempts to put an B<epoll> file descriptor into its own"
" file descriptor set?"
msgstr ""

#. type: Plain text
#: man-pages/man7/epoll.7:449
msgid ""
"The B<epoll_ctl>(2)  call fails (B<EINVAL>).  However, you can add an "
"B<epoll> file descriptor inside another B<epoll> file descriptor set."
msgstr ""

#. type: Plain text
#: man-pages/man7/epoll.7:453
msgid ""
"Can I send an B<epoll> file descriptor over a UNIX domain socket to another "
"process?"
msgstr ""

#. type: Plain text
#: man-pages/man7/epoll.7:456
msgid ""
"Yes, but it does not make sense to do this, since the receiving process "
"would not have copies of the file descriptors in the interest list."
msgstr ""

#. type: IP
#: man-pages/man7/epoll.7:456
#, no-wrap
msgid "6."
msgstr ""

#. type: Plain text
#: man-pages/man7/epoll.7:460
msgid ""
"Will closing a file descriptor cause it to be removed from all B<epoll> "
"interest lists?"
msgstr ""

#. type: Plain text
#: man-pages/man7/epoll.7:475
msgid ""
"Yes, but be aware of the following point.  A file descriptor is a reference "
"to an open file description (see B<open>(2)).  Whenever a file descriptor is"
" duplicated via B<dup>(2), B<dup2>(2), B<fcntl>(2)  B<F_DUPFD>, or "
"B<fork>(2), a new file descriptor referring to the same open file "
"description is created.  An open file description continues to exist until "
"all file descriptors referring to it have been closed."
msgstr ""

#. type: Plain text
#: man-pages/man7/epoll.7:495
msgid ""
"A file descriptor is removed from an interest list only after all the file "
"descriptors referring to the underlying open file description have been "
"closed.  This means that even after a file descriptor that is part of an "
"interest list has been closed, events may be reported for that file "
"descriptor if other file descriptors referring to the same underlying file "
"description remain open.  To prevent this happening, the file descriptor "
"must be explicitly removed from the interest list (using B<epoll_ctl>(2)  "
"B<EPOLL_CTL_DEL>)  before it is duplicated.  Alternatively, the application "
"must ensure that all file descriptors are closed (which may be difficult if "
"file descriptors were duplicated behind the scenes by library functions that"
" used B<dup>(2)  or B<fork>(2))."
msgstr ""

#. type: IP
#: man-pages/man7/epoll.7:495
#, no-wrap
msgid "7."
msgstr ""

#. type: Plain text
#: man-pages/man7/epoll.7:499
msgid ""
"If more than one event occurs between B<epoll_wait>(2)  calls, are they "
"combined or reported separately?"
msgstr ""

#. type: Plain text
#: man-pages/man7/epoll.7:501
msgid "They will be combined."
msgstr ""

#. type: IP
#: man-pages/man7/epoll.7:501
#, no-wrap
msgid "8."
msgstr ""

#. type: Plain text
#: man-pages/man7/epoll.7:504
msgid ""
"Does an operation on a file descriptor affect the already collected but not "
"yet reported events?"
msgstr ""

#. type: Plain text
#: man-pages/man7/epoll.7:509
msgid ""
"You can do two operations on an existing file descriptor.  Remove would be "
"meaningless for this case.  Modify will reread available I/O."
msgstr ""

#. type: IP
#: man-pages/man7/epoll.7:509
#, no-wrap
msgid "9."
msgstr ""

#. type: Plain text
#: man-pages/man7/epoll.7:516
msgid ""
"Do I need to continuously read/write a file descriptor until B<EAGAIN> when "
"using the B<EPOLLET> flag (edge-triggered behavior)?"
msgstr ""

#. type: Plain text
#: man-pages/man7/epoll.7:525
msgid ""
"Receiving an event from B<epoll_wait>(2)  should suggest to you that such "
"file descriptor is ready for the requested I/O operation.  You must consider"
" it ready until the next (nonblocking)  read/write yields B<EAGAIN>.  When "
"and how you will use the file descriptor is entirely up to you."
msgstr ""

#. type: Plain text
#: man-pages/man7/epoll.7:531
msgid ""
"For packet/token-oriented files (e.g., datagram socket, terminal in "
"canonical mode), the only way to detect the end of the read/write I/O space "
"is to continue to read/write until B<EAGAIN>."
msgstr ""

#. type: Plain text
#: man-pages/man7/epoll.7:547
msgid ""
"For stream-oriented files (e.g., pipe, FIFO, stream socket), the condition "
"that the read/write I/O space is exhausted can also be detected by checking "
"the amount of data read from / written to the target file descriptor.  For "
"example, if you call B<read>(2)  by asking to read a certain amount of data "
"and B<read>(2)  returns a lower number of bytes, you can be sure of having "
"exhausted the read I/O space for the file descriptor.  The same is true when"
" writing using B<write>(2).  (Avoid this latter technique if you cannot "
"guarantee that the monitored file descriptor always refers to a stream-"
"oriented file.)"
msgstr ""

#. type: SS
#: man-pages/man7/epoll.7:547
#, no-wrap
msgid "Possible pitfalls and ways to avoid them"
msgstr ""

#. type: TP
#: man-pages/man7/epoll.7:548
#, no-wrap
msgid "B<o Starvation (edge-triggered)>"
msgstr ""

#. type: Plain text
#: man-pages/man7/epoll.7:556
msgid ""
"If there is a large amount of I/O space, it is possible that by trying to "
"drain it the other files will not get processed causing starvation.  (This "
"problem is not specific to B<epoll>.)"
msgstr ""

#. type: Plain text
#: man-pages/man7/epoll.7:564
msgid ""
"The solution is to maintain a ready list and mark the file descriptor as "
"ready in its associated data structure, thereby allowing the application to "
"remember which files need to be processed but still round robin amongst all "
"the ready files.  This also supports ignoring subsequent events you receive "
"for file descriptors that are already ready."
msgstr ""

#. type: TP
#: man-pages/man7/epoll.7:564
#, no-wrap
msgid "B<o If using an event cache...>"
msgstr ""

#. type: Plain text
#: man-pages/man7/epoll.7:580
msgid ""
"If you use an event cache or store all the file descriptors returned from "
"B<epoll_wait>(2), then make sure to provide a way to mark its closure "
"dynamically (i.e., caused by a previous event's processing).  Suppose you "
"receive 100 events from B<epoll_wait>(2), and in event #47 a condition "
"causes event #13 to be closed.  If you remove the structure and B<close>(2)"
"  the file descriptor for event #13, then your event cache might still say "
"there are events waiting for that file descriptor causing confusion."
msgstr ""

#. type: Plain text
#: man-pages/man7/epoll.7:591
msgid ""
"One solution for this is to call, during the processing of event 47, "
"B<epoll_ctl>(B<EPOLL_CTL_DEL>)  to delete file descriptor 13 and "
"B<close>(2), then mark its associated data structure as removed and link it "
"to a cleanup list.  If you find another event for file descriptor 13 in your"
" batch processing, you will discover the file descriptor had been previously"
" removed and there will be no confusion."
msgstr ""

#. type: SH
#: man-pages/man7/epoll.7:591
#, no-wrap
msgid "VERSIONS"
msgstr ""

#.  Its interface should be finalized in Linux kernel 2.5.66.
#. type: Plain text
#: man-pages/man7/epoll.7:597
msgid ""
"The B<epoll> API was introduced in Linux kernel 2.5.44.  Support was added "
"to glibc in version 2.3.2."
msgstr ""

#. type: SH
#: man-pages/man7/epoll.7:597
#, no-wrap
msgid "CONFORMING TO"
msgstr ""

#. type: Plain text
#: man-pages/man7/epoll.7:606
msgid ""
"The B<epoll> API is Linux-specific.  Some other systems provide similar "
"mechanisms, for example, FreeBSD has I<kqueue>, and Solaris has "
"I</dev/poll>."
msgstr ""

#. type: Plain text
#: man-pages/man7/epoll.7:615
msgid ""
"The set of file descriptors that is being monitored via an epoll file "
"descriptor can be viewed via the entry for the epoll file descriptor in the "
"process's I</proc/[pid]/fdinfo> directory.  See B<proc>(5)  for further "
"details."
msgstr ""

#. type: Plain text
#: man-pages/man7/epoll.7:621
msgid ""
"The B<kcmp>(2)  B<KCMP_EPOLL_TFD> operation can be used to test whether a "
"file descriptor is present in an epoll instance."
msgstr ""

#. type: Plain text
#: man-pages/man7/epoll.7:627
msgid ""
"B<epoll_create>(2), B<epoll_create1>(2), B<epoll_ctl>(2), B<epoll_wait>(2), "
"B<poll>(2), B<select>(2)"
msgstr ""

#. type: TH
#: man-pages/man2/eventfd.2:22
#, no-wrap
msgid "EVENTFD"
msgstr ""

#. type: Plain text
#: man-pages/man2/eventfd.2:25
msgid "eventfd - create a file descriptor for event notification"
msgstr ""

#. type: Plain text
#: man-pages/man2/eventfd.2:27
msgid "B<#include E<lt>sys/eventfd.hE<gt>>"
msgstr ""

#. type: Plain text
#: man-pages/man2/eventfd.2:29
msgid "B<int eventfd(unsigned int >I<initval>B<, int >I<flags>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/eventfd.2:39
msgid ""
"B<eventfd>()  creates an \"eventfd object\" that can be used as an event "
"wait/notify mechanism by user-space applications, and by the kernel to "
"notify user-space applications of events.  The object contains an unsigned "
"64-bit integer (I<uint64_t>)  counter that is maintained by the kernel.  "
"This counter is initialized with the value specified in the argument "
"I<initval>."
msgstr ""

#. type: Plain text
#: man-pages/man2/eventfd.2:44
msgid ""
"As its return value, B<eventfd>()  returns a new file descriptor that can be"
" used to refer to the eventfd object."
msgstr ""

#. type: Plain text
#: man-pages/man2/eventfd.2:49
msgid ""
"The following values may be bitwise ORed in I<flags> to change the behavior "
"of B<eventfd>():"
msgstr ""

#. type: TP
#: man-pages/man2/eventfd.2:49
#, no-wrap
msgid "B<EFD_CLOEXEC> (since Linux 2.6.27)"
msgstr ""

#. type: Plain text
#: man-pages/man2/eventfd.2:59
msgid ""
"Set the close-on-exec (B<FD_CLOEXEC>)  flag on the new file descriptor.  See"
" the description of the B<O_CLOEXEC> flag in B<open>(2)  for reasons why "
"this may be useful."
msgstr ""

#. type: TP
#: man-pages/man2/eventfd.2:59
#, no-wrap
msgid "B<EFD_NONBLOCK> (since Linux 2.6.27)"
msgstr ""

#. type: Plain text
#: man-pages/man2/eventfd.2:69
msgid ""
"Set the B<O_NONBLOCK> file status flag on the open file description (see "
"B<open>(2))  referred to by the new file descriptor.  Using this flag saves "
"extra calls to B<fcntl>(2)  to achieve the same result."
msgstr ""

#. type: TP
#: man-pages/man2/eventfd.2:69
#, no-wrap
msgid "B<EFD_SEMAPHORE> (since Linux 2.6.30)"
msgstr ""

#. type: Plain text
#: man-pages/man2/eventfd.2:73
msgid ""
"Provide semaphore-like semantics for reads from the new file descriptor.  "
"See below."
msgstr ""

#. type: Plain text
#: man-pages/man2/eventfd.2:77
msgid ""
"In Linux up to version 2.6.26, the I<flags> argument is unused, and must be "
"specified as zero."
msgstr ""

#. type: Plain text
#: man-pages/man2/eventfd.2:80
msgid ""
"The following operations can be performed on the file descriptor returned by"
" B<eventfd>():"
msgstr ""

#. type: TP
#: man-pages/man2/eventfd.2:80
#, no-wrap
msgid "B<read>(2)"
msgstr ""

#. type: Plain text
#: man-pages/man2/eventfd.2:90
msgid ""
"Each successful B<read>(2)  returns an 8-byte integer.  A B<read>(2)  fails "
"with the error B<EINVAL> if the size of the supplied buffer is less than 8 "
"bytes."
msgstr ""

#. type: Plain text
#: man-pages/man2/eventfd.2:95
msgid ""
"The value returned by B<read>(2)  is in host byte order\\(emthat is, the "
"native byte order for integers on the host machine."
msgstr ""

#. type: Plain text
#: man-pages/man2/eventfd.2:102
msgid ""
"The semantics of B<read>(2)  depend on whether the eventfd counter currently"
" has a nonzero value and whether the B<EFD_SEMAPHORE> flag was specified "
"when creating the eventfd file descriptor:"
msgstr ""

#. type: Plain text
#: man-pages/man2/eventfd.2:110
msgid ""
"If B<EFD_SEMAPHORE> was not specified and the eventfd counter has a nonzero "
"value, then a B<read>(2)  returns 8 bytes containing that value, and the "
"counter's value is reset to zero."
msgstr ""

#. type: Plain text
#: man-pages/man2/eventfd.2:117
msgid ""
"If B<EFD_SEMAPHORE> was specified and the eventfd counter has a nonzero "
"value, then a B<read>(2)  returns 8 bytes containing the value 1, and the "
"counter's value is decremented by 1."
msgstr ""

#. type: Plain text
#: man-pages/man2/eventfd.2:127
msgid ""
"If the eventfd counter is zero at the time of the call to B<read>(2), then "
"the call either blocks until the counter becomes nonzero (at which time, the"
" B<read>(2)  proceeds as described above)  or fails with the error B<EAGAIN>"
" if the file descriptor has been made nonblocking."
msgstr ""

#. type: TP
#: man-pages/man2/eventfd.2:128
#, no-wrap
msgid "B<write>(2)"
msgstr ""

#. type: Plain text
#: man-pages/man2/eventfd.2:145
msgid ""
"A B<write>(2)  call adds the 8-byte integer value supplied in its buffer to "
"the counter.  The maximum value that may be stored in the counter is the "
"largest unsigned 64-bit value minus 1 (i.e., 0xfffffffffffffffe).  If the "
"addition would cause the counter's value to exceed the maximum, then the "
"B<write>(2)  either blocks until a B<read>(2)  is performed on the file "
"descriptor, or fails with the error B<EAGAIN> if the file descriptor has "
"been made nonblocking."
msgstr ""

#. type: Plain text
#: man-pages/man2/eventfd.2:152
msgid ""
"A B<write>(2)  fails with the error B<EINVAL> if the size of the supplied "
"buffer is less than 8 bytes, or if an attempt is made to write the value "
"0xffffffffffffffff."
msgstr ""

#. type: TP
#: man-pages/man2/eventfd.2:152
#, no-wrap
msgid "B<poll>(2), B<select>(2) (and similar)"
msgstr ""

#. type: Plain text
#: man-pages/man2/eventfd.2:161
msgid ""
"The returned file descriptor supports B<poll>(2)  (and analogously "
"B<epoll>(7))  and B<select>(2), as follows:"
msgstr ""

#. type: Plain text
#: man-pages/man2/eventfd.2:172
msgid ""
"The file descriptor is readable (the B<select>(2)  I<readfds> argument; the "
"B<poll>(2)  B<POLLIN> flag)  if the counter has a value greater than 0."
msgstr ""

#. type: Plain text
#: man-pages/man2/eventfd.2:182
msgid ""
"The file descriptor is writable (the B<select>(2)  I<writefds> argument; the"
" B<poll>(2)  B<POLLOUT> flag)  if it is possible to write a value of at "
"least \"1\" without blocking."
msgstr ""

#. type: Plain text
#: man-pages/man2/eventfd.2:202
msgid ""
"If an overflow of the counter value was detected, then B<select>(2)  "
"indicates the file descriptor as being both readable and writable, and "
"B<poll>(2)  returns a B<POLLERR> event.  As noted above, B<write>(2)  can "
"never overflow the counter.  However an overflow can occur if 2^64 eventfd "
"\"signal posts\" were performed by the KAIO subsystem (theoretically "
"possible, but practically unlikely).  If an overflow has occurred, then "
"B<read>(2)  will return that maximum I<uint64_t> value (i.e., "
"0xffffffffffffffff)."
msgstr ""

#. type: Plain text
#: man-pages/man2/eventfd.2:209
msgid ""
"The eventfd file descriptor also supports the other file-descriptor "
"multiplexing APIs: B<pselect>(2)  and B<ppoll>(2)."
msgstr ""

#. type: TP
#: man-pages/man2/eventfd.2:209
#, no-wrap
msgid "B<close>(2)"
msgstr ""

#. type: Plain text
#: man-pages/man2/eventfd.2:214
msgid ""
"When the file descriptor is no longer required it should be closed.  When "
"all file descriptors associated with the same eventfd object have been "
"closed, the resources for object are freed by the kernel."
msgstr ""

#. type: Plain text
#: man-pages/man2/eventfd.2:226
msgid ""
"A copy of the file descriptor created by B<eventfd>()  is inherited by the "
"child produced by B<fork>(2).  The duplicate file descriptor is associated "
"with the same eventfd object.  File descriptors created by B<eventfd>()  are"
" preserved across B<execve>(2), unless the close-on-exec flag has been set."
msgstr ""

#. type: SH
#: man-pages/man2/eventfd.2:226
#, no-wrap
msgid "RETURN VALUE"
msgstr ""

#. type: Plain text
#: man-pages/man2/eventfd.2:233
msgid ""
"On success, B<eventfd>()  returns a new eventfd file descriptor.  On error, "
"-1 is returned and I<errno> is set to indicate the error."
msgstr ""

#. type: SH
#: man-pages/man2/eventfd.2:233
#, no-wrap
msgid "ERRORS"
msgstr ""

#. type: TP
#: man-pages/man2/eventfd.2:234
#, no-wrap
msgid "B<EINVAL>"
msgstr ""

#. type: Plain text
#: man-pages/man2/eventfd.2:238
msgid "An unsupported value was specified in I<flags>."
msgstr ""

#. type: TP
#: man-pages/man2/eventfd.2:238
#, no-wrap
msgid "B<EMFILE>"
msgstr ""

#. type: Plain text
#: man-pages/man2/eventfd.2:241
msgid ""
"The per-process limit on the number of open file descriptors has been "
"reached."
msgstr ""

#. type: TP
#: man-pages/man2/eventfd.2:241
#, no-wrap
msgid "B<ENFILE>"
msgstr ""

#. type: Plain text
#: man-pages/man2/eventfd.2:245
msgid ""
"The system-wide limit on the total number of open files has been reached."
msgstr ""

#. type: TP
#: man-pages/man2/eventfd.2:245
#, no-wrap
msgid "B<ENODEV>"
msgstr ""

#.  Note from Davide:
#.  The ENODEV error is basically never going to happen if
#.  the kernel boots correctly. That error happen only if during
#.  the kernel initialization, some error occur in the anonymous
#.  inode source initialization.
#. type: Plain text
#: man-pages/man2/eventfd.2:253
msgid "Could not mount (internal) anonymous inode device."
msgstr ""

#. type: TP
#: man-pages/man2/eventfd.2:253
#, no-wrap
msgid "B<ENOMEM>"
msgstr ""

#. type: Plain text
#: man-pages/man2/eventfd.2:257
msgid "There was insufficient memory to create a new eventfd file descriptor."
msgstr ""

#.  eventfd() is in glibc 2.7, but reportedly does not build
#. type: Plain text
#: man-pages/man2/eventfd.2:270
msgid ""
"B<eventfd>()  is available on Linux since kernel 2.6.22.  Working support is"
" provided in glibc since version 2.8.  The B<eventfd2>()  system call (see "
"NOTES) is available on Linux since kernel 2.6.27.  Since version 2.9, the "
"glibc B<eventfd>()  wrapper will employ the B<eventfd2>()  system call, if "
"it is supported by the kernel."
msgstr ""

#. type: SH
#: man-pages/man2/eventfd.2:270
#, no-wrap
msgid "ATTRIBUTES"
msgstr ""

#. type: Plain text
#: man-pages/man2/eventfd.2:273
msgid ""
"For an explanation of the terms used in this section, see B<attributes>(7)."
msgstr ""

#. type: tbl table
#: man-pages/man2/eventfd.2:277
#, no-wrap
msgid "Interface"
msgstr ""

#. type: tbl table
#: man-pages/man2/eventfd.2:277
#, no-wrap
msgid "Attribute"
msgstr ""

#. type: tbl table
#: man-pages/man2/eventfd.2:277
#, no-wrap
msgid "Value"
msgstr ""

#. type: tbl table
#: man-pages/man2/eventfd.2:280
#, no-wrap
msgid "B<eventfd>()"
msgstr ""

#. type: tbl table
#: man-pages/man2/eventfd.2:280
#, no-wrap
msgid "Thread safety"
msgstr ""

#. type: tbl table
#: man-pages/man2/eventfd.2:280
#, no-wrap
msgid "MT-Safe"
msgstr ""

#. type: Plain text
#: man-pages/man2/eventfd.2:288
msgid "B<eventfd>()  and B<eventfd2>()  are Linux-specific."
msgstr ""

#. type: Plain text
#: man-pages/man2/eventfd.2:296
msgid ""
"Applications can use an eventfd file descriptor instead of a pipe (see "
"B<pipe>(2))  in all cases where a pipe is used simply to signal events.  The"
" kernel overhead of an eventfd file descriptor is much lower than that of a "
"pipe, and only one file descriptor is required (versus the two required for "
"a pipe)."
msgstr ""

#.  or eventually syslets/threadlets
#. type: Plain text
#: man-pages/man2/eventfd.2:302
msgid ""
"When used in the kernel, an eventfd file descriptor can provide a bridge "
"from kernel to user space, allowing, for example, functionalities like KAIO "
"(kernel AIO)  to signal to a file descriptor that some operation is "
"complete."
msgstr ""

#. type: Plain text
#: man-pages/man2/eventfd.2:319
msgid ""
"A key point about an eventfd file descriptor is that it can be monitored "
"just like any other file descriptor using B<select>(2), B<poll>(2), or "
"B<epoll>(7).  This means that an application can simultaneously monitor the "
"readiness of \"traditional\" files and the readiness of other kernel "
"mechanisms that support the eventfd interface.  (Without the B<eventfd>()  "
"interface, these mechanisms could not be multiplexed via B<select>(2), "
"B<poll>(2), or B<epoll>(7).)"
msgstr ""

#. type: Plain text
#: man-pages/man2/eventfd.2:328
msgid ""
"The current value of an eventfd counter can be viewed via the entry for the "
"corresponding file descriptor in the process's I</proc/[pid]/fdinfo> "
"directory.  See B<proc>(5)  for further details."
msgstr ""

#. type: SS
#: man-pages/man2/eventfd.2:328
#, no-wrap
msgid "C library/kernel differences"
msgstr ""

#. type: Plain text
#: man-pages/man2/eventfd.2:342
msgid ""
"There are two underlying Linux system calls: B<eventfd>()  and the more "
"recent B<eventfd2>().  The former system call does not implement a I<flags> "
"argument.  The latter system call implements the I<flags> values described "
"above.  The glibc wrapper function will use B<eventfd2>()  where it is "
"available."
msgstr ""

#. type: SS
#: man-pages/man2/eventfd.2:342
#, no-wrap
msgid "Additional glibc features"
msgstr ""

#. type: Plain text
#: man-pages/man2/eventfd.2:346
msgid ""
"The GNU C library defines an additional type, and two functions that attempt"
" to abstract some of the details of reading and writing on an eventfd file "
"descriptor:"
msgstr ""

#. type: Plain text
#: man-pages/man2/eventfd.2:350
#, no-wrap
msgid "typedef uint64_t eventfd_t;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/eventfd.2:353
#, no-wrap
msgid ""
"int eventfd_read(int fd, eventfd_t *value);\n"
"int eventfd_write(int fd, eventfd_t value);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/eventfd.2:360
msgid ""
"The functions perform the read and write operations on an eventfd file "
"descriptor, returning 0 if the correct number of bytes was transferred, or "
"-1 otherwise."
msgstr ""

#. type: SH
#: man-pages/man2/eventfd.2:360
#, no-wrap
msgid "EXAMPLE"
msgstr ""

#. type: Plain text
#: man-pages/man2/eventfd.2:369
msgid ""
"The following program creates an eventfd file descriptor and then forks to "
"create a child process.  While the parent briefly sleeps, the child writes "
"each of the integers supplied in the program's command-line arguments to the"
" eventfd file descriptor.  When the parent has finished sleeping, it reads "
"from the eventfd file descriptor."
msgstr ""

#. type: Plain text
#: man-pages/man2/eventfd.2:371
msgid "The following shell session shows a sample run of the program:"
msgstr ""

#. type: Plain text
#: man-pages/man2/eventfd.2:383
#, no-wrap
msgid ""
"$B< ./a.out 1 2 4 7 14>\n"
"Child writing 1 to efd\n"
"Child writing 2 to efd\n"
"Child writing 4 to efd\n"
"Child writing 7 to efd\n"
"Child writing 14 to efd\n"
"Child completed write loop\n"
"Parent about to read\n"
"Parent read 28 (0x1c) from efd\n"
msgstr ""

#. type: SS
#: man-pages/man2/eventfd.2:385
#, no-wrap
msgid "Program source"
msgstr ""

#. type: Plain text
#: man-pages/man2/eventfd.2:393
#, no-wrap
msgid ""
"#include E<lt>sys/eventfd.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdint.hE<gt>             /* Definition of uint64_t */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/eventfd.2:396
#, no-wrap
msgid ""
"#define handle_error(msg) \\e\n"
"    do { perror(msg); exit(EXIT_FAILURE); } while (0)\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/eventfd.2:403
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int efd, j;\n"
"    uint64_t u;\n"
"    ssize_t s;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/eventfd.2:408
#, no-wrap
msgid ""
"    if (argc E<lt> 2) {\n"
"        fprintf(stderr, \"Usage: %s E<lt>numE<gt>...\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/eventfd.2:412
#, no-wrap
msgid ""
"    efd = eventfd(0, 0);\n"
"    if (efd == -1)\n"
"        handle_error(\"eventfd\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/eventfd.2:424
#, no-wrap
msgid ""
"    switch (fork()) {\n"
"    case 0:\n"
"        for (j = 1; j E<lt> argc; j++) {\n"
"            printf(\"Child writing %s to efd\\en\", argv[j]);\n"
"            u = strtoull(argv[j], NULL, 0);\n"
"                    /* strtoull() allows various bases */\n"
"            s = write(efd, &u, sizeof(uint64_t));\n"
"            if (s != sizeof(uint64_t))\n"
"                handle_error(\"write\");\n"
"        }\n"
"        printf(\"Child completed write loop\\en\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/eventfd.2:426
#, no-wrap
msgid "        exit(EXIT_SUCCESS);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/eventfd.2:429
#, no-wrap
msgid ""
"    default:\n"
"        sleep(2);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/eventfd.2:437
#, no-wrap
msgid ""
"        printf(\"Parent about to read\\en\");\n"
"        s = read(efd, &u, sizeof(uint64_t));\n"
"        if (s != sizeof(uint64_t))\n"
"            handle_error(\"read\");\n"
"        printf(\"Parent read %llu (0x%llx) from efd\\en\",\n"
"                (unsigned long long) u, (unsigned long long) u);\n"
"        exit(EXIT_SUCCESS);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/eventfd.2:442
#, no-wrap
msgid ""
"    case -1:\n"
"        handle_error(\"fork\");\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/eventfd.2:453
msgid ""
"B<futex>(2), B<pipe>(2), B<poll>(2), B<read>(2), B<select>(2), "
"B<signalfd>(2), B<timerfd_create>(2), B<write>(2), B<epoll>(7), "
"B<sem_overview>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/execveat.2:26
#, no-wrap
msgid "EXECVEAT"
msgstr ""

#. type: Plain text
#: man-pages/man2/execveat.2:29
msgid "execveat - execute program relative to a directory file descriptor"
msgstr ""

#. type: Plain text
#: man-pages/man2/execveat.2:31
msgid "B<#include E<lt>unistd.hE<gt>>"
msgstr ""

#. type: Plain text
#: man-pages/man2/execveat.2:33
msgid "B<int execveat(int >I<dirfd>B<, const char *>I<pathname>B<,>"
msgstr ""

#. type: Plain text
#: man-pages/man2/execveat.2:35
msgid "B< char *const >I<argv>B<[], char *const >I<envp>B<[],>"
msgstr ""

#. type: Plain text
#: man-pages/man2/execveat.2:37
msgid "B< int >I<flags>B<);>"
msgstr ""

#.  commit 51f39a1f0cea1cacf8c787f652f26dfee9611874
#. type: Plain text
#: man-pages/man2/execveat.2:48
msgid ""
"The B<execveat>()  system call executes the program referred to by the "
"combination of I<dirfd> and I<pathname>.  It operates in exactly the same "
"way as B<execve>(2), except for the differences described in this manual "
"page."
msgstr ""

#. type: Plain text
#: man-pages/man2/execveat.2:58
msgid ""
"If the pathname given in I<pathname> is relative, then it is interpreted "
"relative to the directory referred to by the file descriptor I<dirfd> "
"(rather than relative to the current working directory of the calling "
"process, as is done by B<execve>(2)  for a relative pathname)."
msgstr ""

#. type: Plain text
#: man-pages/man2/execveat.2:70
msgid ""
"If I<pathname> is relative and I<dirfd> is the special value B<AT_FDCWD>, "
"then I<pathname> is interpreted relative to the current working directory of"
" the calling process (like B<execve>(2))."
msgstr ""

#. type: Plain text
#: man-pages/man2/execveat.2:76
msgid "If I<pathname> is absolute, then I<dirfd> is ignored."
msgstr ""

#. type: Plain text
#: man-pages/man2/execveat.2:86
msgid ""
"If I<pathname> is an empty string and the B<AT_EMPTY_PATH> flag is "
"specified, then the file descriptor I<dirfd> specifies the file to be "
"executed (i.e., I<dirfd> refers to an executable file, rather than a "
"directory)."
msgstr ""

#. type: Plain text
#: man-pages/man2/execveat.2:90
msgid ""
"The I<flags> argument is a bit mask that can include zero or more of the "
"following flags:"
msgstr ""

#. type: TP
#: man-pages/man2/execveat.2:90
#, no-wrap
msgid "B<AT_EMPTY_PATH>"
msgstr ""

#. type: Plain text
#: man-pages/man2/execveat.2:100
msgid ""
"If I<pathname> is an empty string, operate on the file referred to by "
"I<dirfd> (which may have been obtained using the B<open>(2)  B<O_PATH> "
"flag)."
msgstr ""

#. type: TP
#: man-pages/man2/execveat.2:100
#, no-wrap
msgid "B<AT_SYMLINK_NOFOLLOW>"
msgstr ""

#. type: Plain text
#: man-pages/man2/execveat.2:108
msgid ""
"If the file identified by I<dirfd> and a non-NULL I<pathname> is a symbolic "
"link, then the call fails with the error B<ELOOP>."
msgstr ""

#. type: Plain text
#: man-pages/man2/execveat.2:115
msgid ""
"On success, B<execveat>()  does not return.  On error, -1 is returned, and "
"I<errno> is set appropriately."
msgstr ""

#. type: Plain text
#: man-pages/man2/execveat.2:122
msgid ""
"The same errors that occur for B<execve>(2)  can also occur for "
"B<execveat>().  The following additional errors can occur for B<execveat>():"
msgstr ""

#. type: TP
#: man-pages/man2/execveat.2:122
#, no-wrap
msgid "B<EBADF>"
msgstr ""

#. type: Plain text
#: man-pages/man2/execveat.2:126
msgid "I<dirfd> is not a valid file descriptor."
msgstr ""

#. type: Plain text
#: man-pages/man2/execveat.2:130
msgid "Invalid flag specified in I<flags>."
msgstr ""

#. type: TP
#: man-pages/man2/execveat.2:130
#, no-wrap
msgid "B<ELOOP>"
msgstr ""

#. type: Plain text
#: man-pages/man2/execveat.2:140
msgid ""
"I<flags> includes B<AT_SYMLINK_NOFOLLOW> and the file identified by I<dirfd>"
" and a non-NULL I<pathname> is a symbolic link."
msgstr ""

#. type: TP
#: man-pages/man2/execveat.2:140
#, no-wrap
msgid "B<ENOENT>"
msgstr ""

#. type: Plain text
#: man-pages/man2/execveat.2:154
msgid ""
"The program identified by I<dirfd> and I<pathname> requires the use of an "
"interpreter program (such as a script starting with \"#!\"), but the file "
"descriptor I<dirfd> was opened with the B<O_CLOEXEC> flag, with the result "
"that the program file is inaccessible to the launched interpreter.  See "
"BUGS."
msgstr ""

#. type: TP
#: man-pages/man2/execveat.2:154
#, no-wrap
msgid "B<ENOTDIR>"
msgstr ""

#. type: Plain text
#: man-pages/man2/execveat.2:160
msgid ""
"I<pathname> is relative and I<dirfd> is a file descriptor referring to a "
"file other than a directory."
msgstr ""

#.  FIXME . check for glibc support in a future release
#. type: Plain text
#: man-pages/man2/execveat.2:165
msgid ""
"B<execveat>()  was added to Linux in kernel 3.19.  GNU C library support is "
"pending."
msgstr ""

#. type: Plain text
#: man-pages/man2/execveat.2:169
msgid "The B<execveat>()  system call is Linux-specific."
msgstr ""

#. type: Plain text
#: man-pages/man2/execveat.2:179
msgid ""
"In addition to the reasons explained in B<openat>(2), the B<execveat>()  "
"system call is also needed to allow B<fexecve>(3)  to be implemented on "
"systems that do not have the I</proc> filesystem mounted."
msgstr ""

#. type: Plain text
#: man-pages/man2/execveat.2:202
msgid ""
"When asked to execute a script file, the I<argv[0]> that is passed to the "
"script interpreter is a string of the form I</dev/fd/N> or I</dev/fd/N/P>, "
"where I<N> is the number of the file descriptor passed via the I<dirfd> "
"argument.  A string of the first form occurs when B<AT_EMPTY_PATH> is "
"employed.  A string of the second form occurs when the script is specified "
"via both I<dirfd> and I<pathname>; in this case, I<P> is the value given in "
"I<pathname>."
msgstr ""

#. type: Plain text
#: man-pages/man2/execveat.2:210
msgid ""
"For the same reasons described in B<fexecve>(3), the natural idiom when "
"using B<execveat>()  is to set the close-on-exec flag on I<dirfd>.  (But see"
" BUGS.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/execveat.2:215
msgid ""
"The B<ENOENT> error described above means that it is not possible to set the"
" close-on-exec flag on the file descriptor given to a call of the form:"
msgstr ""

#. type: Plain text
#: man-pages/man2/execveat.2:217
#, no-wrap
msgid "    execveat(fd, \"\", argv, envp, AT_EMPTY_PATH);\n"
msgstr ""

#.  For an example, see Michael Kerrisk's 2015-01-10 reply in this LKML
#.  thread (http://thread.gmane.org/gmane.linux.kernel/1836105/focus=20229):
#.      Subject: [PATCHv10 man-pages 5/5] execveat.2: initial man page.\"
#. for execveat(2
#.      Date: Mon, 24 Nov 2014 11:53:59 +0000
#. type: Plain text
#: man-pages/man2/execveat.2:229
msgid ""
"However, the inability to set the close-on-exec flag means that a file "
"descriptor referring to the script leaks through to the script itself.  As "
"well as wasting a file descriptor, this leakage can lead to file-descriptor "
"exhaustion in scenarios where scripts recursively employ B<execveat>()."
msgstr ""

#. type: Plain text
#: man-pages/man2/execveat.2:232
msgid "B<execve>(2), B<openat>(2), B<fexecve>(3)"
msgstr ""

#. type: TH
#: man-pages/man2/execve.2:37
#, no-wrap
msgid "EXECVE"
msgstr ""

#. type: TH
#: man-pages/man2/execve.2:37
#, no-wrap
msgid "2018-04-30"
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:40
msgid "execve - execute program"
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:44
msgid "B<int execve(const char *>I<pathname>B<, char *const >I<argv>B<[], >"
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:46
msgid "B< char *const >I<envp>B<[]);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:52
msgid ""
"B<execve>()  executes the program referred to by I<pathname>.  This causes "
"the program that is currently being run by the calling process to be "
"replaced with a new program, with newly initialized stack, heap, and "
"(initialized and uninitialized) data segments."
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:55
msgid ""
"I<pathname> must be either a binary executable, or a script starting with a "
"line of the form:"
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:59 man-pages/man2/execve.2:305
#, no-wrap
msgid "B<#!> I<interpreter >[optional-arg]\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:63
msgid "For details of the latter case, see \"Interpreter scripts\" below."
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:72
msgid ""
"I<argv> is an array of argument strings passed to the new program.  By "
"convention, the first of these strings (i.e., I<argv[0]>)  should contain "
"the filename associated with the file being executed.  I<envp> is an array "
"of strings, conventionally of the form B<key=value>, which are passed as "
"environment to the new program.  The I<argv> and I<envp> arrays must each "
"include a null pointer at the end of the array."
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:75
msgid ""
"The argument vector and environment can be accessed by the called program's "
"main function, when it is defined as:"
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:79
#, no-wrap
msgid "int main(int argc, char *argv[], char *envp[])\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:87
msgid ""
"Note, however, that the use of a third argument to the main function is not "
"specified in POSIX.1; according to POSIX.1, the environment should be "
"accessed via the external variable B<environ>(7)."
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:92
msgid ""
"B<execve>()  does not return on success, and the text, initialized data, "
"uninitialized data (bss), and stack of the calling process are overwritten "
"according to the contents of the newly loaded program."
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:96
msgid ""
"If the current program is being ptraced, a B<SIGTRAP> signal is sent to it "
"after a successful B<execve>()."
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:104
msgid ""
"If the set-user-ID bit is set on the program file referred to by "
"I<pathname>, then the effective user ID of the calling process is changed to"
" that of the owner of the program file.  Similarly, when the set-group-ID "
"bit of the program file is set the effective group ID of the calling process"
" is set to the group of the program file."
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:109
msgid ""
"The aforementioned transformations of the effective IDs are I<not> performed"
" (i.e., the set-user-ID and set-group-ID bits are ignored)  if any of the "
"following is true:"
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:114
msgid ""
"the I<no_new_privs> attribute is set for the calling thread (see "
"B<prctl>(2));"
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:122
msgid ""
"the underlying filesystem is mounted I<nosuid> (the B<MS_NOSUID> flag for "
"B<mount>(2)); or"
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:124
msgid "the calling process is being ptraced."
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:128
msgid ""
"The capabilities of the program file (see B<capabilities>(7))  are also "
"ignored if any of the above are true."
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:133
msgid ""
"The effective user ID of the process is copied to the saved set-user-ID; "
"similarly, the effective group ID is copied to the saved set-group-ID.  This"
" copying takes place after any effective ID changes that occur because of "
"the set-user-ID and set-group-ID mode bits."
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:137
msgid ""
"The process's real UID and real GID, as well its supplementary group IDs, "
"are unchanged by a call to B<execve>()."
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:145
msgid ""
"If the executable is an a.out dynamically linked binary executable "
"containing shared-library stubs, the Linux dynamic linker B<ld.so>(8)  is "
"called at the start of execution to bring needed shared objects into memory "
"and link the executable with them."
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:153
msgid ""
"If the executable is a dynamically linked ELF executable, the interpreter "
"named in the PT_INTERP segment is used to load the needed shared objects.  "
"This interpreter is typically I</lib/ld-linux.so.2> for binaries linked with"
" glibc (see B<ld-linux.so>(8))."
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:157
msgid ""
"All process attributes are preserved during an B<execve>(), except the "
"following:"
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:161
msgid ""
"The dispositions of any signals that are being caught are reset to the "
"default (B<signal>(7))."
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:164
msgid "Any alternate signal stack is not preserved (B<sigaltstack>(2))."
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:167
msgid "Memory mappings are not preserved (B<mmap>(2))."
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:170
msgid "Attached System\\ V shared memory segments are detached (B<shmat>(2))."
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:173
msgid "POSIX shared memory regions are unmapped (B<shm_open>(3))."
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:176
msgid "Open POSIX message queue descriptors are closed (B<mq_overview>(7))."
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:179
msgid "Any open POSIX named semaphores are closed (B<sem_overview>(7))."
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:182
msgid "POSIX timers are not preserved (B<timer_create>(2))."
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:185
msgid "Any open directory streams are closed (B<opendir>(3))."
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:189
msgid "Memory locks are not preserved (B<mlock>(2), B<mlockall>(2))."
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:193
msgid "Exit handlers are not preserved (B<atexit>(3), B<on_exit>(3))."
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:196
msgid ""
"The floating-point environment is reset to the default (see B<fenv>(3))."
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:202
msgid ""
"The process attributes in the preceding list are all specified in POSIX.1.  "
"The following Linux-specific process attributes are also not preserved "
"during an B<execve>():"
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:209
msgid ""
"The B<prctl>(2)  B<PR_SET_DUMPABLE> flag is set, unless a set-user-ID or "
"set-group ID program is being executed, in which case it is cleared."
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:214
msgid "The B<prctl>(2)  B<PR_SET_KEEPCAPS> flag is cleared."
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:221
msgid ""
"(Since Linux 2.4.36 / 2.6.23)  If a set-user-ID or set-group-ID program is "
"being executed, then the parent death signal set by B<prctl>(2)  "
"B<PR_SET_PDEATHSIG> flag is cleared."
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:228
msgid ""
"The process name, as set by B<prctl>(2)  B<PR_SET_NAME> (and displayed by "
"I<ps\\ -o comm>), is reset to the name of the new executable file."
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:235
msgid ""
"The B<SECBIT_KEEP_CAPS> I<securebits> flag is cleared.  See "
"B<capabilities>(7)."
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:240
msgid "The termination signal is reset to B<SIGCHLD> (see B<clone>(2))."
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:245
msgid ""
"The file descriptor table is unshared, undoing the effect of the "
"B<CLONE_FILES> flag of B<clone>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:247
msgid "Note the following further points:"
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:251
msgid ""
"All threads other than the calling thread are destroyed during an "
"B<execve>().  Mutexes, condition variables, and other pthreads objects are "
"not preserved."
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:254
msgid ""
"The equivalent of I<setlocale(LC_ALL, \"C\")> is executed at program start-"
"up."
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:262
msgid ""
"POSIX.1 specifies that the dispositions of any signals that are ignored or "
"set to the default are left unchanged.  POSIX.1 specifies one exception: if "
"B<SIGCHLD> is being ignored, then an implementation may leave the "
"disposition unchanged or reset it to the default; Linux does the former."
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:266
msgid ""
"Any outstanding asynchronous I/O operations are canceled (B<aio_read>(3), "
"B<aio_write>(3))."
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:271
msgid ""
"For the handling of capabilities during B<execve>(), see B<capabilities>(7)."
msgstr ""

#.  On Linux it appears that these file descriptors are
#.  always open after an execve(), and it looks like
#.  Solaris 8 and FreeBSD 6.1 are the same. -- mtk, 30 Apr 2007
#. type: Plain text
#: man-pages/man2/execve.2:298
msgid ""
"By default, file descriptors remain open across an B<execve>().  File "
"descriptors that are marked close-on-exec are closed; see the description of"
" B<FD_CLOEXEC> in B<fcntl>(2).  (If a file descriptor is closed, this will "
"cause the release of all record locks obtained on the underlying file by "
"this process.  See B<fcntl>(2)  for details.)  POSIX.1 says that if file "
"descriptors 0, 1, and 2 would otherwise be closed after a successful "
"B<execve>(), and the process would gain privilege because the set-user-ID or"
" set-group_ID mode bit was set on the executed file, then the system may "
"open an unspecified file for each of these file descriptors.  As a general "
"principle, no portable program, whether privileged or not, can assume that "
"these three file descriptors will remain closed across an B<execve>()."
msgstr ""

#. type: SS
#: man-pages/man2/execve.2:298 man-pages/man2/execve.2:611
#, no-wrap
msgid "Interpreter scripts"
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:301
msgid ""
"An interpreter script is a text file that has execute permission enabled and"
" whose first line is of the form:"
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:318
msgid ""
"The I<interpreter> must be a valid pathname for an executable file.  If the "
"I<pathname> argument of B<execve>()  specifies an interpreter script, then "
"I<interpreter> will be invoked with the following arguments:"
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:322
#, no-wrap
msgid "I<interpreter> [optional-arg] I<pathname> arg...\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:333
msgid ""
"where I<arg...> is the series of words pointed to by the I<argv> argument of"
" B<execve>(), starting at I<argv>[1]."
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:338
msgid ""
"For portable use, I<optional-arg> should either be absent, or be specified "
"as a single word (i.e., it should not contain white space); see NOTES below."
msgstr ""

#.  commit bf2a9a39639b8b51377905397a5005f444e9a892
#. type: Plain text
#: man-pages/man2/execve.2:345
msgid ""
"Since Linux 2.6.28, the kernel permits the interpreter of a script to itself"
" be a script.  This permission is recursive, up to a limit of four "
"recursions, so that the interpreter may be a script which is interpreted by "
"a script, and so on."
msgstr ""

#. type: SS
#: man-pages/man2/execve.2:345
#, no-wrap
msgid "Limits on size of arguments and environment"
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:358
msgid ""
"Most UNIX implementations impose some limit on the total size of the "
"command-line argument (I<argv>)  and environment (I<envp>)  strings that may"
" be passed to a new program.  POSIX.1 allows an implementation to advertise "
"this limit using the B<ARG_MAX> constant (either defined in "
"I<E<lt>limits.hE<gt>> or available at run time using the call "
"I<sysconf(_SC_ARG_MAX)>)."
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:365
msgid ""
"On Linux prior to kernel 2.6.23, the memory used to store the environment "
"and argument strings was limited to 32 pages (defined by the kernel constant"
" B<MAX_ARG_PAGES>).  On architectures with a 4-kB page size, this yields a "
"maximum size of 128\\ kB."
msgstr ""

#.  For some background on the changes to ARG_MAX in kernels 2.6.23 and
#.  2.6.25, see:
#.      http://sourceware.org/bugzilla/show_bug.cgi?id=5786
#.      http://bugzilla.kernel.org/show_bug.cgi?id=10095
#.      http://thread.gmane.org/gmane.linux.kernel/646709/focus=648101,
#.      checked into 2.6.25 as commit
#. a64e715fc74b1a7dcc5944f848acc38b2c4d4ee2.
#.  Ollie: That doesn't include the lists of pointers, though,
#.  so the actual usage is a bit higher (1 pointer per argument).
#. type: Plain text
#: man-pages/man2/execve.2:401
msgid ""
"On kernel 2.6.23 and later, most architectures support a size limit derived "
"from the soft B<RLIMIT_STACK> resource limit (see B<getrlimit>(2))  that is "
"in force at the time of the B<execve>()  call.  (Architectures with no "
"memory management unit are excepted: they maintain the limit that was in "
"effect before kernel 2.6.23.)  This change allows programs to have a much "
"larger argument and/or environment list.  For these architectures, the total"
" size is limited to 1/4 of the allowed stack size.  (Imposing the 1/4-limit "
"ensures that the new program always has some stack space.)  Since Linux "
"2.6.25, the kernel places a floor of 32 pages on this size limit, so that, "
"even when B<RLIMIT_STACK> is set very low, applications are guaranteed to "
"have at least as much argument and environment space as was provided by "
"Linux 2.6.23 and earlier.  (This guarantee was not provided in Linux 2.6.23 "
"and 2.6.24.)  Additionally, the limit per string is 32 pages (the kernel "
"constant B<MAX_ARG_STRLEN>), and the maximum number of strings is "
"0x7FFFFFFF."
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:407
msgid ""
"On success, B<execve>()  does not return, on error -1 is returned, and "
"I<errno> is set appropriately."
msgstr ""

#. type: TP
#: man-pages/man2/execve.2:408
#, no-wrap
msgid "B<E2BIG>"
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:415
msgid ""
"The total number of bytes in the environment (I<envp>)  and argument list "
"(I<argv>)  is too large."
msgstr ""

#. type: TP
#: man-pages/man2/execve.2:415 man-pages/man2/execve.2:422
#: man-pages/man2/execve.2:425 man-pages/man2/execve.2:428
#, no-wrap
msgid "B<EACCES>"
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:422
msgid ""
"Search permission is denied on a component of the path prefix of I<pathname>"
" or the name of a script interpreter.  (See also B<path_resolution>(7).)"
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:425
msgid "The file or a script interpreter is not a regular file."
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:428
msgid ""
"Execute permission is denied for the file or a script or ELF interpreter."
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:432
msgid "The filesystem is mounted I<noexec>."
msgstr ""

#. type: TP
#: man-pages/man2/execve.2:432
#, no-wrap
msgid "B<EAGAIN> (since Linux 3.1)"
msgstr ""

#.  commit 72fa59970f8698023045ab0713d66f3f4f96945c
#. type: Plain text
#: man-pages/man2/execve.2:442
msgid ""
"Having changed its real UID using one of the B<set*uid>()  calls, the caller"
" was\\(emand is now still\\(emabove its B<RLIMIT_NPROC> resource limit (see "
"B<setrlimit>(2)).  For a more detailed explanation of this error, see NOTES."
msgstr ""

#. type: TP
#: man-pages/man2/execve.2:442
#, no-wrap
msgid "B<EFAULT>"
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:450
msgid ""
"I<pathname> or one of the pointers in the vectors I<argv> or I<envp> points "
"outside your accessible address space."
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:454
msgid ""
"An ELF executable had more than one PT_INTERP segment (i.e., tried to name "
"more than one interpreter)."
msgstr ""

#. type: TP
#: man-pages/man2/execve.2:454
#, no-wrap
msgid "B<EIO>"
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:457
msgid "An I/O error occurred."
msgstr ""

#. type: TP
#: man-pages/man2/execve.2:457
#, no-wrap
msgid "B<EISDIR>"
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:460
msgid "An ELF interpreter was a directory."
msgstr ""

#. type: TP
#: man-pages/man2/execve.2:460
#, no-wrap
msgid "B<ELIBBAD>"
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:463
msgid "An ELF interpreter was not in a recognized format."
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:468
msgid ""
"Too many symbolic links were encountered in resolving I<pathname> or the "
"name of a script or ELF interpreter."
msgstr ""

#.  commit d740269867021faf4ce38a449353d2b986c34a67
#. type: Plain text
#: man-pages/man2/execve.2:476
msgid ""
"The maximum recursion limit was reached during recursive script "
"interpretation (see \"Interpreter scripts\", above).  Before Linux 3.8, the "
"error produced for this case was B<ENOEXEC>."
msgstr ""

#. type: TP
#: man-pages/man2/execve.2:479
#, no-wrap
msgid "B<ENAMETOOLONG>"
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:483
msgid "I<pathname> is too long."
msgstr ""

#.  FIXME but see http://sourceware.org/bugzilla/show_bug.cgi?id=12241
#. type: Plain text
#: man-pages/man2/execve.2:493
msgid ""
"The file I<pathname> or a script or ELF interpreter does not exist, or a "
"shared library needed for the file or interpreter cannot be found."
msgstr ""

#. type: TP
#: man-pages/man2/execve.2:493
#, no-wrap
msgid "B<ENOEXEC>"
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:498
msgid ""
"An executable is not in a recognized format, is for the wrong architecture, "
"or has some other format error that means it cannot be executed."
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:501
msgid "Insufficient kernel memory was available."
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:506
msgid ""
"A component of the path prefix of I<pathname> or a script or ELF interpreter"
" is not a directory."
msgstr ""

#. type: TP
#: man-pages/man2/execve.2:506 man-pages/man2/execve.2:512
#: man-pages/man2/execve.2:516
#, no-wrap
msgid "B<EPERM>"
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:512
msgid ""
"The filesystem is mounted I<nosuid>, the user is not the superuser, and the "
"file has the set-user-ID or set-group-ID bit set."
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:516
msgid ""
"The process is being traced, the user is not the superuser and the file has "
"the set-user-ID or set-group-ID bit set."
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:522
msgid ""
"A \"capability-dumb\" applications would not obtain the full set of "
"permitted capabilities granted by the executable file.  See "
"B<capabilities>(7)."
msgstr ""

#. type: TP
#: man-pages/man2/execve.2:522
#, no-wrap
msgid "B<ETXTBSY>"
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:525
msgid ""
"The specified executable was open for writing by one or more processes."
msgstr ""

#.  SVr4 documents additional error
#.  conditions EAGAIN, EINTR, ELIBACC, ENOLINK, EMULTIHOP; POSIX does not
#.  document ETXTBSY, EPERM, EFAULT, ELOOP, EIO, ENFILE, EMFILE, EINVAL,
#.  EISDIR or ELIBBAD error conditions.
#. type: Plain text
#: man-pages/man2/execve.2:533
msgid ""
"POSIX.1-2001, POSIX.1-2008, SVr4, 4.3BSD.  POSIX does not document the #! "
"behavior, but it exists (with some variations) on other UNIX systems."
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:549
msgid ""
"One sometimes sees B<execve>()  (and the related functions described in "
"B<exec>(3))  described as \"executing a I<new> process\" (or similar).  This"
" is a highly misleading description: there is no new process; many "
"attributes of the calling process remain unchanged (in particular, its PID)."
"  All that B<execve>(2)  does is arrange for an existing process (the "
"calling process)  to execute a new program."
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:552
msgid "Set-user-ID and set-group-ID processes can not be B<ptrace>(2)d."
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:563
msgid ""
"The result of mounting a filesystem I<nosuid> varies across Linux kernel "
"versions: some will refuse execution of set-user-ID and set-group-ID "
"executables when this would give the user powers she did not have already "
"(and return B<EPERM>), some will just ignore the set-user-ID and set-group-"
"ID bits and B<exec>()  successfully."
msgstr ""

#.  e.g., EFAULT on Solaris 8 and FreeBSD 6.1; but
#.  HP-UX 11 is like Linux -- mtk, Apr 2007
#.  Bug filed 30 Apr 2007: http://bugzilla.kernel.org/show_bug.cgi?id=8408
#.  Bug rejected (because fix would constitute an ABI change).
#. type: Plain text
#: man-pages/man2/execve.2:585
msgid ""
"On Linux, I<argv> and I<envp> can be specified as NULL.  In both cases, this"
" has the same effect as specifying the argument as a pointer to a list "
"containing a single null pointer.  B<Do not take advantage of this "
"nonstandard and nonportable misfeature!> On many other UNIX systems, "
"specifying I<argv> as NULL will result in an error (B<EFAULT>).  I<Some> "
"other UNIX systems treat the I<envp==NULL> case the same as Linux."
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:596
msgid ""
"POSIX.1 says that values returned by B<sysconf>(3)  should be invariant over"
" the lifetime of a process.  However, since Linux 2.6.23, if the "
"B<RLIMIT_STACK> resource limit changes, then the value reported by "
"B<_SC_ARG_MAX> will also change, to reflect the fact that the limit on space"
" for holding command-line arguments and environment variables has changed."
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:611
msgid ""
"In most cases where B<execve>()  fails, control returns to the original "
"executable image, and the caller of B<execve>()  can then handle the error."
"  However, in (rare) cases (typically caused by resource exhaustion), "
"failure may occur past the point of no return: the original executable image"
" has been torn down, but the new image could not be completely built.  In "
"such cases, the kernel kills the process with a B<SIGKILL> signal."
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:614
msgid ""
"A maximum line length of 127 characters is allowed for the first line in an "
"interpreter script."
msgstr ""

#.  e.g., Solaris 8
#.  e.g., FreeBSD before 6.0, but not FreeBSD 6.0 onward
#. type: Plain text
#: man-pages/man2/execve.2:633
msgid ""
"The semantics of the I<optional-arg> argument of an interpreter script vary "
"across implementations.  On Linux, the entire string following the "
"I<interpreter> name is passed as a single argument to the interpreter, and "
"this string can include white space.  However, behavior differs on some "
"other systems.  Some systems use the first white space to terminate I"
"<optional-arg>.  On some systems, an interpreter script can have multiple "
"arguments, and white spaces in I<optional-arg> are used to delimit the "
"arguments."
msgstr ""

#.  .SH BUGS
#.  Some Linux versions have failed to check permissions on ELF
#.  interpreters.  This is a security hole, because it allows users to
#.  open any file, such as a rewinding tape device, for reading.  Some
#.  Linux versions have also had other security holes in
#.  .BR execve ()
#.  that could be exploited for denial of service by a suitably crafted
#.  ELF binary. There are no known problems with 2.0.34 or 2.2.15.
#. type: Plain text
#: man-pages/man2/execve.2:644
msgid "Linux ignores the set-user-ID and set-group-ID bits on scripts."
msgstr ""

#. type: SS
#: man-pages/man2/execve.2:644
#, no-wrap
msgid "execve() and EAGAIN"
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:650
msgid ""
"A more detailed explanation of the B<EAGAIN> error that can occur (since "
"Linux 3.1) when calling B<execve>()  is as follows."
msgstr ""

#.  commit 909cc4ae86f3380152a18e2a3c44523893ee11c4
#. type: Plain text
#: man-pages/man2/execve.2:672
msgid ""
"The B<EAGAIN> error can occur when a I<preceding> call to B<setuid>(2), "
"B<setreuid>(2), or B<setresuid>(2)  caused the real user ID of the process "
"to change, and that change caused the process to exceed its B<RLIMIT_NPROC> "
"resource limit (i.e., the number of processes belonging to the new real UID "
"exceeds the resource limit).  From Linux 2.6.0 to 3.0, this caused the "
"B<set*uid>()  call to fail.  (Prior to 2.6, the resource limit was not "
"imposed on processes that changed their user IDs.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:703
msgid ""
"Since Linux 3.1, the scenario just described no longer causes the "
"B<set*uid>()  call to fail, because it too often led to security holes where"
" buggy applications didn't check the return status and assumed that\\(emif "
"the caller had root privileges\\(emthe call would always succeed.  Instead, "
"the B<set*uid>()  calls now successfully change the real UID, but the kernel"
" sets an internal flag, named B<PF_NPROC_EXCEEDED>, to note that the "
"B<RLIMIT_NPROC> resource limit has been exceeded.  If the "
"B<PF_NPROC_EXCEEDED> flag is set and the resource limit is still exceeded at"
" the time of a subsequent B<execve>()  call, that call fails with the error "
"B<EAGAIN>.  This kernel logic ensures that the B<RLIMIT_NPROC> resource "
"limit is still enforced for the common privileged daemon "
"workflow\\(emnamely, B<fork>(2)  + B<set*uid>()  + B<execve>()."
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:719
msgid ""
"If the resource limit was not still exceeded at the time of the B<execve>()"
"  call (because other processes belonging to this real UID terminated "
"between the B<set*uid>()  call and the B<execve>()  call), then the "
"B<execve>()  call succeeds and the kernel clears the B<PF_NPROC_EXCEEDED> "
"process flag.  The flag is also cleared if a subsequent call to B<fork>(2)  "
"by this process succeeds."
msgstr ""

#. type: SS
#: man-pages/man2/execve.2:719
#, no-wrap
msgid "Historical"
msgstr ""

#.  .SH BUGS
#.  Some Linux versions have failed to check permissions on ELF
#.  interpreters.  This is a security hole, because it allows users to
#.  open any file, such as a rewinding tape device, for reading.  Some
#.  Linux versions have also had other security holes in
#.  .BR execve ()
#.  that could be exploited for denial of service by a suitably crafted
#.  ELF binary. There are no known problems with 2.0.34 or 2.2.15.
#. type: Plain text
#: man-pages/man2/execve.2:739
msgid ""
"With UNIX\\ V6, the argument list of an B<exec>()  call was ended by 0, "
"while the argument list of I<main> was ended by -1.  Thus, this argument "
"list was not directly usable in a further B<exec>()  call.  Since UNIX\\ V7,"
" both are NULL."
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:742
msgid ""
"The following program is designed to be execed by the second program below."
"  It just echoes its command-line arguments, one per line."
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:746
#, no-wrap
msgid "/* myecho.c */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:749
#, no-wrap
msgid ""
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:754
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int j;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:757
#, no-wrap
msgid ""
"    for (j = 0; j E<lt> argc; j++)\n"
"        printf(\"argv[%d]: %s\\en\", j, argv[j]);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:760
#, no-wrap
msgid ""
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:765
msgid ""
"This program can be used to exec the program named in its command-line "
"argument:"
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:769
#, no-wrap
msgid "/* execve.c */\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:773
#, no-wrap
msgid ""
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:779
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    char *newargv[] = { NULL, \"hello\", \"world\", NULL };\n"
"    char *newenviron[] = { NULL };\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:784
#, no-wrap
msgid ""
"    if (argc != 2) {\n"
"        fprintf(stderr, \"Usage: %s E<lt>file-to-execE<gt>\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:786
#, no-wrap
msgid "    newargv[0] = argv[1];\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:791
#, no-wrap
msgid ""
"    execve(argv[1], newargv, newenviron);\n"
"    perror(\"execve\");   /* execve() returns only on error */\n"
"    exit(EXIT_FAILURE);\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:795
msgid "We can use the second program to exec the first as follows:"
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:804
#, no-wrap
msgid ""
"$B< cc myecho.c -o myecho>\n"
"$B< cc execve.c -o execve>\n"
"$B< ./execve ./myecho>\n"
"argv[0]: ./myecho\n"
"argv[1]: hello\n"
"argv[2]: world\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:812
msgid ""
"We can also use these programs to demonstrate the use of a script "
"interpreter.  To do this we create a script whose \"interpreter\" is our "
"I<myecho> program:"
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:819
#, no-wrap
msgid ""
"$B< cat E<gt> script>\n"
"B<#!./myecho script-arg>\n"
"B<^D>\n"
"$B< chmod +x script>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:823
msgid "We can then use our program to exec the script:"
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:832
#, no-wrap
msgid ""
"$B< ./execve ./script>\n"
"argv[0]: ./myecho\n"
"argv[1]: script-arg\n"
"argv[2]: ./script\n"
"argv[3]: hello\n"
"argv[4]: world\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/execve.2:847
msgid ""
"B<chmod>(2), B<execveat>(2), B<fork>(2), B<get_robust_list>(2), "
"B<ptrace>(2), B<exec>(3), B<fexecve>(3), B<getopt>(3), B<system>(3), "
"B<credentials>(7), B<environ>(7), B<path_resolution>(7), B<ld.so>(8)"
msgstr ""

#. type: TH
#: man-pages/man2/exit_group.2:25
#, no-wrap
msgid "EXIT_GROUP"
msgstr ""

#. type: TH
#: man-pages/man2/exit_group.2:25
#, no-wrap
msgid "2008-11-27"
msgstr ""

#. type: Plain text
#: man-pages/man2/exit_group.2:28
msgid "exit_group - exit all threads in a process"
msgstr ""

#. type: Plain text
#: man-pages/man2/exit_group.2:31
#, no-wrap
msgid "B<#include E<lt>linux/unistd.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/exit_group.2:33
#, no-wrap
msgid "B<void exit_group(int >I<status>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/exit_group.2:39
msgid ""
"This system call is equivalent to B<_exit>(2)  except that it terminates not"
" only the calling thread, but all threads in the calling process's thread "
"group."
msgstr ""

#. type: Plain text
#: man-pages/man2/exit_group.2:41
msgid "This system call does not return."
msgstr ""

#. type: Plain text
#: man-pages/man2/exit_group.2:43
msgid "This call is present since Linux 2.5.35."
msgstr ""

#. type: Plain text
#: man-pages/man2/exit_group.2:45
msgid "This call is Linux-specific."
msgstr ""

#. type: Plain text
#: man-pages/man2/exit_group.2:49
msgid ""
"Since glibc 2.3, this is the system call invoked when the B<_exit>(2)  "
"wrapper function is called."
msgstr ""

#. type: Plain text
#: man-pages/man2/exit_group.2:50
msgid "B<exit>(2)"
msgstr ""

#. type: TH
#: man-pages/man2/epoll_ctl.2:20
#, no-wrap
msgid "EPOLL_CTL"
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_ctl.2:23
msgid "epoll_ctl - control interface for an epoll file descriptor"
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_ctl.2:28
msgid ""
"B<int epoll_ctl(int >I<epfd>B<, int >I<op>B<, int >I<fd>B<, struct "
"epoll_event *>I<event>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_ctl.2:39
msgid ""
"This system call is used to add, modify, or remove entries in the interest "
"list of the B<epoll>(7)  instance referred to by the file descriptor "
"I<epfd>.  It requests that the operation I<op> be performed for the target "
"file descriptor, I<fd>."
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_ctl.2:43
msgid "Valid values for the I<op> argument are:"
msgstr ""

#. type: TP
#: man-pages/man2/epoll_ctl.2:43
#, no-wrap
msgid "B<EPOLL_CTL_ADD>"
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_ctl.2:52
msgid ""
"Add I<fd> to the interest list and associate the settings specified in "
"I<event> with the internal file linked to I<fd>."
msgstr ""

#. type: TP
#: man-pages/man2/epoll_ctl.2:52
#, no-wrap
msgid "B<EPOLL_CTL_MOD>"
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_ctl.2:58
msgid ""
"Change the settings associated with I<fd> in the interest list to the new "
"settings specified in I<event>."
msgstr ""

#. type: TP
#: man-pages/man2/epoll_ctl.2:58
#, no-wrap
msgid "B<EPOLL_CTL_DEL>"
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_ctl.2:66
msgid ""
"Remove (deregister) the target file descriptor I<fd> from the interest list."
"  The I<event> argument is ignored and can be NULL (but see BUGS below)."
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_ctl.2:74
msgid ""
"The I<event> argument describes the object linked to the file descriptor "
"I<fd>.  The I<struct epoll_event> is defined as:"
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_ctl.2:83
#, no-wrap
msgid ""
"typedef union epoll_data {\n"
"    void        *ptr;\n"
"    int          fd;\n"
"    uint32_t     u32;\n"
"    uint64_t     u64;\n"
"} epoll_data_t;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_ctl.2:88
#, no-wrap
msgid ""
"struct epoll_event {\n"
"    uint32_t     events;      /* Epoll events */\n"
"    epoll_data_t data;        /* User data variable */\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_ctl.2:95
msgid ""
"The I<events> member is a bit mask composed by ORing together zero or more "
"of the following available event types:"
msgstr ""

#. type: TP
#: man-pages/man2/epoll_ctl.2:95
#, no-wrap
msgid "B<EPOLLIN>"
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_ctl.2:100
msgid "The associated file is available for B<read>(2)  operations."
msgstr ""

#. type: TP
#: man-pages/man2/epoll_ctl.2:100
#, no-wrap
msgid "B<EPOLLOUT>"
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_ctl.2:105
msgid "The associated file is available for B<write>(2)  operations."
msgstr ""

#. type: TP
#: man-pages/man2/epoll_ctl.2:105
#, no-wrap
msgid "B<EPOLLRDHUP> (since Linux 2.6.17)"
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_ctl.2:111
msgid ""
"Stream socket peer closed connection, or shut down writing half of "
"connection.  (This flag is especially useful for writing simple code to "
"detect peer shutdown when using Edge Triggered monitoring.)"
msgstr ""

#. type: TP
#: man-pages/man2/epoll_ctl.2:111
#, no-wrap
msgid "B<EPOLLPRI>"
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_ctl.2:118
msgid ""
"There is an exceptional condition on the file descriptor.  See the "
"discussion of B<POLLPRI> in B<poll>(2)."
msgstr ""

#. type: TP
#: man-pages/man2/epoll_ctl.2:118
#, no-wrap
msgid "B<EPOLLERR>"
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_ctl.2:126
msgid ""
"Error condition happened on the associated file descriptor.  This event is "
"also reported for the write end of a pipe when the read end has been closed."
"  B<epoll_wait>(2)  will always report for this event; it is not necessary "
"to set it in I<events>."
msgstr ""

#. type: TP
#: man-pages/man2/epoll_ctl.2:126
#, no-wrap
msgid "B<EPOLLHUP>"
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_ctl.2:132
msgid ""
"Hang up happened on the associated file descriptor.  B<epoll_wait>(2)  will "
"always wait for this event; it is not necessary to set it in I<events>."
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_ctl.2:137
msgid ""
"Note that when reading from a channel such as a pipe or a stream socket, "
"this event merely indicates that the peer closed its end of the channel.  "
"Subsequent reads from the channel will return 0 (end of file)  only after "
"all outstanding data in the channel has been consumed."
msgstr ""

#. type: TP
#: man-pages/man2/epoll_ctl.2:137
#, no-wrap
msgid "B<EPOLLET>"
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_ctl.2:147
msgid ""
"Sets the Edge Triggered behavior for the associated file descriptor.  The "
"default behavior for B<epoll> is Level Triggered.  See B<epoll>(7)  for more"
" detailed information about Edge and Level Triggered event distribution "
"architectures."
msgstr ""

#. type: TP
#: man-pages/man2/epoll_ctl.2:147
#, no-wrap
msgid "B<EPOLLONESHOT> (since Linux 2.6.2)"
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_ctl.2:161
msgid ""
"Sets the one-shot behavior for the associated file descriptor.  This means "
"that after an event is pulled out with B<epoll_wait>(2)  the associated file"
" descriptor is internally disabled and no other events will be reported by "
"the B<epoll> interface.  The user must call B<epoll_ctl>()  with "
"B<EPOLL_CTL_MOD> to rearm the file descriptor with a new event mask."
msgstr ""

#. type: TP
#: man-pages/man2/epoll_ctl.2:161
#, no-wrap
msgid "B<EPOLLWAKEUP> (since Linux 3.5)"
msgstr ""

#.  commit 4d7e30d98939a0340022ccd49325a3d70f7e0238
#. type: Plain text
#: man-pages/man2/epoll_ctl.2:189
msgid ""
"If B<EPOLLONESHOT> and B<EPOLLET> are clear and the process has the "
"B<CAP_BLOCK_SUSPEND> capability, ensure that the system does not enter "
"\"suspend\" or \"hibernate\" while this event is pending or being processed."
"  The event is considered as being \"processed\" from the time when it is "
"returned by a call to B<epoll_wait>(2)  until the next call to "
"B<epoll_wait>(2)  on the same B<epoll>(7)  file descriptor, the closure of "
"that file descriptor, the removal of the event file descriptor with "
"B<EPOLL_CTL_DEL>, or the clearing of B<EPOLLWAKEUP> for the event file "
"descriptor with B<EPOLL_CTL_MOD>.  See also BUGS."
msgstr ""

#. type: TP
#: man-pages/man2/epoll_ctl.2:189
#, no-wrap
msgid "B<EPOLLEXCLUSIVE> (since Linux 4.5)"
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_ctl.2:204
msgid ""
"Sets an exclusive wakeup mode for the epoll file descriptor that is being "
"attached to the target file descriptor, I<fd>.  When a wakeup event occurs "
"and multiple epoll file descriptors are attached to the same target file "
"using B<EPOLLEXCLUSIVE>, one or more of the epoll file descriptors will "
"receive an event with B<epoll_wait>(2).  The default in this scenario (when "
"B<EPOLLEXCLUSIVE> is not set) is for all epoll file descriptors to receive "
"an event.  B<EPOLLEXCLUSIVE> is thus useful for avoiding thundering herd "
"problems in certain scenarios."
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_ctl.2:213
msgid ""
"If the same file descriptor is in multiple epoll instances, some with the "
"B<EPOLLEXCLUSIVE> flag, and others without, then events will be provided to "
"all epoll instances that did not specify B<EPOLLEXCLUSIVE>, and at least one"
" of the epoll instances that did specify B<EPOLLEXCLUSIVE>."
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_ctl.2:232
msgid ""
"The following values may be specified in conjunction with B<EPOLLEXCLUSIVE>:"
" B<EPOLLIN>, B<EPOLLOUT>, B<EPOLLWAKEUP>, and B<EPOLLET>.  B<EPOLLHUP> and "
"B<EPOLLERR> can also be specified, but this is not required: as usual, these"
" events are always reported if they occur, regardless of whether they are "
"specified in I<events>.  Attempts to specify other values in I<events> yield"
" the error B<EINVAL>."
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_ctl.2:259
msgid ""
"B<EPOLLEXCLUSIVE> may be used only in an B<EPOLL_CTL_ADD> operation; "
"attempts to employ it with B<EPOLL_CTL_MOD> yield an error.  If "
"B<EPOLLEXCLUSIVE> has been set using B<epoll_ctl>(), then a subsequent "
"B<EPOLL_CTL_MOD> on the same I<epfd>,\\ I<fd> pair yields an error.  A call "
"to B<epoll_ctl>()  that specifies B<EPOLLEXCLUSIVE> in I<events> and "
"specifies the target file descriptor I<fd> as an epoll instance will "
"likewise fail.  The error in all of these cases is B<EINVAL>."
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_ctl.2:268
msgid ""
"When successful, B<epoll_ctl>()  returns zero.  When an error occurs, "
"B<epoll_ctl>()  returns -1 and I<errno> is set appropriately."
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_ctl.2:275
msgid "I<epfd> or I<fd> is not a valid file descriptor."
msgstr ""

#. type: TP
#: man-pages/man2/epoll_ctl.2:275
#, no-wrap
msgid "B<EEXIST>"
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_ctl.2:283
msgid ""
"I<op> was B<EPOLL_CTL_ADD>, and the supplied file descriptor I<fd> is "
"already registered with this epoll instance."
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_ctl.2:296
msgid ""
"I<epfd> is not an B<epoll> file descriptor, or I<fd> is the same as I<epfd>,"
" or the requested operation I<op> is not supported by this interface."
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_ctl.2:302
msgid ""
"An invalid event type was specified along with B<EPOLLEXCLUSIVE> in "
"I<events>."
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_ctl.2:311
msgid "I<op> was B<EPOLL_CTL_MOD> and I<events> included B<EPOLLEXCLUSIVE>."
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_ctl.2:321
msgid ""
"I<op> was B<EPOLL_CTL_MOD> and the B<EPOLLEXCLUSIVE> flag has previously "
"been applied to this I<epfd>,\\ I<fd> pair."
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_ctl.2:329
msgid ""
"B<EPOLLEXCLUSIVE> was specified in I<event> and I<fd> refers to an epoll "
"instance."
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_ctl.2:336
msgid ""
"I<fd> refers to an epoll instance and this B<EPOLL_CTL_ADD> operation would "
"result in a circular loop of epoll instances monitoring one another."
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_ctl.2:346
msgid ""
"I<op> was B<EPOLL_CTL_MOD> or B<EPOLL_CTL_DEL>, and I<fd> is not registered "
"with this epoll instance."
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_ctl.2:351
msgid ""
"There was insufficient memory to handle the requested I<op> control "
"operation."
msgstr ""

#. type: TP
#: man-pages/man2/epoll_ctl.2:351
#, no-wrap
msgid "B<ENOSPC>"
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_ctl.2:361
msgid ""
"The limit imposed by I</proc/sys/fs/epoll/max_user_watches> was encountered "
"while trying to register (B<EPOLL_CTL_ADD>)  a new file descriptor on an "
"epoll instance.  See B<epoll>(7)  for further details."
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_ctl.2:370
msgid ""
"The target file I<fd> does not support B<epoll>.  This error can occur if "
"I<fd> refers to, for example, a regular file or a directory."
msgstr ""

#.  To be precise: kernel 2.5.44.
#.  The interface should be finalized by Linux kernel 2.5.66.
#. type: Plain text
#: man-pages/man2/epoll_ctl.2:375
msgid "B<epoll_ctl>()  was added to the kernel in version 2.6."
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_ctl.2:379
msgid ""
"B<epoll_ctl>()  is Linux-specific.  Library support is provided in glibc "
"starting with version 2.3.2."
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_ctl.2:384
msgid ""
"The B<epoll> interface supports all file descriptors that support "
"B<poll>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_ctl.2:398
msgid ""
"In kernel versions before 2.6.9, the B<EPOLL_CTL_DEL> operation required a "
"non-null pointer in I<event>, even though this argument is ignored.  Since "
"Linux 2.6.9, I<event> can be specified as NULL when using B<EPOLL_CTL_DEL>."
"  Applications that need to be portable to kernels before 2.6.9 should "
"specify a non-null pointer in I<event>."
msgstr ""

#.  commit a8159414d7e3af7233e7a5a82d1c5d85379bd75c (behavior change)
#.  https://lwn.net/Articles/520198/
#. type: Plain text
#: man-pages/man2/epoll_ctl.2:425
msgid ""
"If B<EPOLLWAKEUP> is specified in I<flags>, but the caller does not have the"
" B<CAP_BLOCK_SUSPEND> capability, then the B<EPOLLWAKEUP> flag is I<silently"
" ignored>.  This unfortunate behavior is necessary because no validity "
"checks were performed on the I<flags> argument in the original "
"implementation, and the addition of the B<EPOLLWAKEUP> with a check that "
"caused the call to fail if the caller did not have the B<CAP_BLOCK_SUSPEND> "
"capability caused a breakage in at least one existing user-space application"
" that happened to randomly (and uselessly) specify this bit.  A robust "
"application should therefore double check that it has the "
"B<CAP_BLOCK_SUSPEND> capability if attempting to use the B<EPOLLWAKEUP> "
"flag."
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_ctl.2:429
msgid "B<epoll_create>(2), B<epoll_wait>(2), B<poll>(2), B<epoll>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/epoll_create.2:24
#, no-wrap
msgid "EPOLL_CREATE"
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_create.2:27
msgid "epoll_create, epoll_create1 - open an epoll file descriptor"
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_create.2:30
#, no-wrap
msgid "B<#include E<lt>sys/epoll.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_create.2:33
#, no-wrap
msgid ""
"B<int epoll_create(int >I<size>B<);>\n"
"B<int epoll_create1(int >I<flags>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_create.2:42
msgid ""
"B<epoll_create>()  creates a new B<epoll>(7)  instance.  Since Linux 2.6.8, "
"the I<size> argument is ignored, but must be greater than zero; see NOTES "
"below."
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_create.2:55
msgid ""
"B<epoll_create>()  returns a file descriptor referring to the new epoll "
"instance.  This file descriptor is used for all the subsequent calls to the "
"B<epoll> interface.  When no longer required, the file descriptor returned "
"by B<epoll_create>()  should be closed by using B<close>(2).  When all file "
"descriptors referring to an epoll instance have been closed, the kernel "
"destroys the instance and releases the associated resources for reuse."
msgstr ""

#. type: SS
#: man-pages/man2/epoll_create.2:55
#, no-wrap
msgid "epoll_create1()"
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_create.2:67
msgid ""
"If I<flags> is 0, then, other than the fact that the obsolete I<size> "
"argument is dropped, B<epoll_create1>()  is the same as B<epoll_create>().  "
"The following value can be included in I<flags> to obtain different "
"behavior:"
msgstr ""

#. type: TP
#: man-pages/man2/epoll_create.2:67
#, no-wrap
msgid "B<EPOLL_CLOEXEC>"
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_create.2:84
msgid ""
"On success, these system calls return a nonnegative file descriptor.  On "
"error, -1 is returned, and I<errno> is set to indicate the error."
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_create.2:89
msgid "I<size> is not positive."
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_create.2:94
msgid "(B<epoll_create1>())  Invalid value specified in I<flags>."
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_create.2:102
msgid ""
"The per-user limit on the number of epoll instances imposed by "
"I</proc/sys/fs/epoll/max_user_instances> was encountered.  See B<epoll>(7)  "
"for further details."
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_create.2:111
msgid "There was insufficient memory to create the kernel object."
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_create.2:115
msgid ""
"B<epoll_create>()  was added to the kernel in version 2.6.  Library support "
"is provided in glibc starting with version 2.3.2."
msgstr ""

#.  To be precise: kernel 2.5.44.
#.  The interface should be finalized by Linux kernel 2.5.66.
#. type: Plain text
#: man-pages/man2/epoll_create.2:121
msgid ""
"B<epoll_create1>()  was added to the kernel in version 2.6.27.  Library "
"support is provided in glibc starting with version 2.9."
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_create.2:124
msgid "B<epoll_create>()  is Linux-specific."
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_create.2:147
msgid ""
"In the initial B<epoll_create>()  implementation, the I<size> argument "
"informed the kernel of the number of file descriptors that the caller "
"expected to add to the B<epoll> instance.  The kernel used this information "
"as a hint for the amount of space to initially allocate in internal data "
"structures describing events.  (If necessary, the kernel would allocate more"
" space if the caller's usage exceeded the hint given in I<size>.)  Nowadays,"
" this hint is no longer required (the kernel dynamically sizes the required "
"data structures without needing the hint), but I<size> must still be greater"
" than zero, in order to ensure backward compatibility when new B<epoll> "
"applications are run on older kernels."
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_create.2:151
msgid "B<close>(2), B<epoll_ctl>(2), B<epoll_wait>(2), B<epoll>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/epoll_wait.2:22
#, no-wrap
msgid "EPOLL_WAIT"
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_wait.2:25
msgid ""
"epoll_wait, epoll_pwait - wait for an I/O event on an epoll file descriptor"
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_wait.2:34
#, no-wrap
msgid ""
"B<int epoll_wait(int >I<epfd>B<, struct epoll_event *>I<events>B<,>\n"
"B<               int >I<maxevents>B<, int >I<timeout>B<);>\n"
"B<int epoll_pwait(int >I<epfd>B<, struct epoll_event *>I<events>B<,>\n"
"B<               int >I<maxevents>B<, int >I<timeout>B<,>\n"
"B<               const sigset_t *>I<sigmask>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_wait.2:52
msgid ""
"The B<epoll_wait>()  system call waits for events on the B<epoll>(7)  "
"instance referred to by the file descriptor I<epfd>.  The memory area "
"pointed to by I<events> will contain the events that will be available for "
"the caller.  Up to I<maxevents> are returned by B<epoll_wait>().  The "
"I<maxevents> argument must be greater than zero."
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_wait.2:62
msgid ""
"The I<timeout> argument specifies the number of milliseconds that "
"B<epoll_wait>()  will block.  Time is measured against the "
"B<CLOCK_MONOTONIC> clock.  The call will block until either:"
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_wait.2:64
msgid "a file descriptor delivers an event;"
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_wait.2:66
msgid "the call is interrupted by a signal handler; or"
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_wait.2:68
msgid "the timeout expires."
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_wait.2:83
msgid ""
"Note that the I<timeout> interval will be rounded up to the system clock "
"granularity, and kernel scheduling delays mean that the blocking interval "
"may overrun by a small amount.  Specifying a I<timeout> of -1 causes "
"B<epoll_wait>()  to block indefinitely, while specifying a I<timeout> equal "
"to zero cause B<epoll_wait>()  to return immediately, even if no events are "
"available."
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_wait.2:87
msgid "The I<struct epoll_event> is defined as:"
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_wait.2:96
#, no-wrap
msgid ""
"typedef union epoll_data {\n"
"    void    *ptr;\n"
"    int      fd;\n"
"    uint32_t u32;\n"
"    uint64_t u64;\n"
"} epoll_data_t;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_wait.2:101
#, no-wrap
msgid ""
"struct epoll_event {\n"
"    uint32_t     events;    /* Epoll events */\n"
"    epoll_data_t data;      /* User data variable */\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_wait.2:114
msgid ""
"The I<data> field of each returned structure contains the same data as was "
"specified in the most recent call to B<epoll_ctl>(2)  (B<EPOLL_CTL_ADD>, "
"B<EPOLL_CTL_MOD>)  for the corresponding open file description.  The "
"I<events> field contains the returned event bit field."
msgstr ""

#. type: SS
#: man-pages/man2/epoll_wait.2:114
#, no-wrap
msgid "epoll_pwait()"
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_wait.2:128
msgid ""
"The relationship between B<epoll_wait>()  and B<epoll_pwait>()  is analogous"
" to the relationship between B<select>(2)  and B<pselect>(2): like "
"B<pselect>(2), B<epoll_pwait>()  allows an application to safely wait until "
"either a file descriptor becomes ready or until a signal is caught."
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_wait.2:132
msgid "The following B<epoll_pwait>()  call:"
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_wait.2:136
#, no-wrap
msgid "ready = epoll_pwait(epfd, &events, maxevents, timeout, &sigmask);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_wait.2:142
msgid "is equivalent to I<atomically> executing the following calls:"
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_wait.2:146
#, no-wrap
msgid "sigset_t origmask;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_wait.2:150
#, no-wrap
msgid ""
"pthread_sigmask(SIG_SETMASK, &sigmask, &origmask);\n"
"ready = epoll_wait(epfd, &events, maxevents, timeout);\n"
"pthread_sigmask(SIG_SETMASK, &origmask, NULL);\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_wait.2:159
msgid ""
"The I<sigmask> argument may be specified as NULL, in which case "
"B<epoll_pwait>()  is equivalent to B<epoll_wait>()."
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_wait.2:171
msgid ""
"When successful, B<epoll_wait>()  returns the number of file descriptors "
"ready for the requested I/O, or zero if no file descriptor became ready "
"during the requested I<timeout> milliseconds.  When an error occurs, "
"B<epoll_wait>()  returns -1 and I<errno> is set appropriately."
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_wait.2:176
msgid "I<epfd> is not a valid file descriptor."
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_wait.2:181
msgid ""
"The memory area pointed to by I<events> is not accessible with write "
"permissions."
msgstr ""

#. type: TP
#: man-pages/man2/epoll_wait.2:181
#, no-wrap
msgid "B<EINTR>"
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_wait.2:188
msgid ""
"The call was interrupted by a signal handler before either (1) any of the "
"requested events occurred or (2) the I<timeout> expired; see B<signal>(7)."
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_wait.2:196
msgid ""
"I<epfd> is not an B<epoll> file descriptor, or I<maxevents> is less than or "
"equal to zero."
msgstr ""

#.  To be precise: kernel 2.5.44.
#.  The interface should be finalized by Linux kernel 2.5.66.
#. type: Plain text
#: man-pages/man2/epoll_wait.2:202
msgid ""
"B<epoll_wait>()  was added to the kernel in version 2.6.  Library support is"
" provided in glibc starting with version 2.3.2."
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_wait.2:206
msgid ""
"B<epoll_pwait>()  was added to Linux in kernel 2.6.19.  Library support is "
"provided in glibc starting with version 2.6."
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_wait.2:209
msgid "B<epoll_wait>()  is Linux-specific."
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_wait.2:219
msgid ""
"While one thread is blocked in a call to B<epoll_pwait>(), it is possible "
"for another thread to add a file descriptor to the waited-upon B<epoll> "
"instance.  If the new file descriptor becomes ready, it will cause the "
"B<epoll_wait>()  call to unblock."
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_wait.2:231
msgid ""
"If more than I<maxevents> file descriptors are ready when B<epoll_wait>()  "
"is called, then successive B<epoll_wait>()  calls will round robin through "
"the set of ready file descriptors.  This behavior helps avoid starvation "
"scenarios, where a process fails to notice that additional file descriptors "
"are ready because it focuses on a set of file descriptors that are already "
"known to be ready."
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_wait.2:241
msgid ""
"Note that it is possible to call B<epoll_wait>()  on an B<epoll> instance "
"whose interest list is currently empty (or whose interest list becomes empty"
" because file descriptors are closed or removed from the interest in another"
" thread).  The call will block until some file descriptor is later added to "
"the interest list (in another thread) and that file descriptor becomes "
"ready."
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_wait.2:253
msgid ""
"In kernels before 2.6.37, a I<timeout> value larger than approximately "
"I<LONG_MAX / HZ> milliseconds is treated as -1 (i.e., infinity).  Thus, for "
"example, on a system where I<sizeof(long)> is 4 and the kernel I<HZ> value "
"is 1000, this means that timeouts greater than 35.79 minutes are treated as "
"infinity."
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_wait.2:266
msgid ""
"The raw B<epoll_pwait>()  system call has a sixth argument, I<size_t "
"sigsetsize>, which specifies the size in bytes of the I<sigmask> argument.  "
"The glibc B<epoll_pwait>()  wrapper function specifies this argument as a "
"fixed value (equal to I<sizeof(sigset_t)>)."
msgstr ""

#. type: Plain text
#: man-pages/man2/epoll_wait.2:269
msgid "B<epoll_create>(2), B<epoll_ctl>(2), B<epoll>(7)"
msgstr ""

#. type: TH
#: man-pages/man5/elf.5:35
#, no-wrap
msgid "ELF"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:38
msgid "elf - format of Executable and Linking Format (ELF) files"
msgstr ""

#.  .B #include <elf_abi.h>
#. type: Plain text
#: man-pages/man5/elf.5:42
#, no-wrap
msgid "B<#include E<lt>elf.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:50
msgid ""
"The header file I<E<lt>elf.hE<gt>> defines the format of ELF executable "
"binary files.  Amongst these files are normal executable files, relocatable "
"object files, core files, and shared objects."
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:59
msgid ""
"An executable file using the ELF file format consists of an ELF header, "
"followed by a program header table or a section header table, or both.  The "
"ELF header is always at offset zero of the file.  The program header table "
"and the section header table's offset in the file are defined in the ELF "
"header.  The two tables describe the rest of the particularities of the "
"file."
msgstr ""

#.  Applications which wish to process ELF binary files for their native
#.  architecture only should include
#.  .I <elf_abi.h>
#.  in their source code.
#.  These applications should need to refer to
#.  all the types and structures by their generic names
#.  "Elf_xxx"
#.  and to the macros by
#.  ELF_xxx".
#.  Applications written this way can be compiled on any architecture,
#.  regardless of whether the host is 32-bit or 64-bit.
#.  .PP
#.  Should an application need to process ELF files of an unknown
#.  architecture, then the application needs to explicitly use either
#.  "Elf32_xxx"
#.  or
#.  "Elf64_xxx"
#.  type and structure names.
#.  Likewise, the macros need to be identified by
#.  "ELF32_xxx"
#.  or
#.  "ELF64_xxx".
#.  .PP
#. type: Plain text
#: man-pages/man5/elf.5:87
msgid ""
"This header file describes the above mentioned headers as C structures and "
"also includes structures for dynamic sections, relocation sections and "
"symbol tables."
msgstr ""

#. type: SS
#: man-pages/man5/elf.5:87
#, no-wrap
msgid "Basic types"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:99
msgid ""
"The following types are used for N-bit architectures (N=32,64, I<ElfN> "
"stands for I<Elf32> or I<Elf64>, I<uintN_t> stands for I<uint32_t> or "
"I<uint64_t>):"
msgstr ""

#.  Elf32_Size  Unsigned object size
#. type: Plain text
#: man-pages/man5/elf.5:113
#, no-wrap
msgid ""
"ElfN_Addr       Unsigned program address, uintN_t\n"
"ElfN_Off        Unsigned file offset, uintN_t\n"
"ElfN_Section    Unsigned section index, uint16_t\n"
"ElfN_Versym     Unsigned version symbol information, uint16_t\n"
"Elf_Byte        unsigned char\n"
"ElfN_Half       uint16_t\n"
"ElfN_Sword      int32_t\n"
"ElfN_Word       uint32_t\n"
"ElfN_Sxword     int64_t\n"
"ElfN_Xword      uint64_t\n"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:128
msgid ""
"(Note: the *BSD terminology is a bit different.  There, I<Elf64_Half> is "
"twice as large as I<Elf32_Half>, and I<Elf64Quarter> is used for "
"I<uint16_t>.  In order to avoid confusion these types are replaced by "
"explicit ones in the below.)"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:136
msgid ""
"All data structures that the file format defines follow the \"natural\" size"
" and alignment guidelines for the relevant class.  If necessary, data "
"structures contain explicit padding to ensure 4-byte alignment for 4-byte "
"objects, to force structure sizes to a multiple of 4, and so on."
msgstr ""

#. type: SS
#: man-pages/man5/elf.5:136
#, no-wrap
msgid "ELF header (Ehdr)"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:141
msgid ""
"The ELF header is described by the type I<Elf32_Ehdr> or I<Elf64_Ehdr>:"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:145
#, no-wrap
msgid "#define EI_NIDENT 16\n"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:162
#, no-wrap
msgid ""
"typedef struct {\n"
"    unsigned char e_ident[EI_NIDENT];\n"
"    uint16_t      e_type;\n"
"    uint16_t      e_machine;\n"
"    uint32_t      e_version;\n"
"    ElfN_Addr     e_entry;\n"
"    ElfN_Off      e_phoff;\n"
"    ElfN_Off      e_shoff;\n"
"    uint32_t      e_flags;\n"
"    uint16_t      e_ehsize;\n"
"    uint16_t      e_phentsize;\n"
"    uint16_t      e_phnum;\n"
"    uint16_t      e_shentsize;\n"
"    uint16_t      e_shnum;\n"
"    uint16_t      e_shstrndx;\n"
"} ElfN_Ehdr;\n"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:167
msgid "The fields have the following meanings:"
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:169
#, no-wrap
msgid "I<e_ident>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:179
msgid ""
"This array of bytes specifies how to interpret the file, independent of the "
"processor or the file's remaining contents.  Within this array everything is"
" named by macros, which start with the prefix B<EI_> and may contain values "
"which start with the prefix B<ELF>.  The following macros are defined:"
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:180
#, no-wrap
msgid "B<EI_MAG0>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:186
msgid ""
"The first byte of the magic number.  It must be filled with B<ELFMAG0>.  (0:"
" 0x7f)"
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:186
#, no-wrap
msgid "B<EI_MAG1>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:192
msgid ""
"The second byte of the magic number.  It must be filled with B<ELFMAG1>.  "
"(1: \\(aqE\\(aq)"
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:192
#, no-wrap
msgid "B<EI_MAG2>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:198
msgid ""
"The third byte of the magic number.  It must be filled with B<ELFMAG2>.  (2:"
" \\(aqL\\(aq)"
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:198
#, no-wrap
msgid "B<EI_MAG3>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:204
msgid ""
"The fourth byte of the magic number.  It must be filled with B<ELFMAG3>.  "
"(3: \\(aqF\\(aq)"
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:204
#, no-wrap
msgid "B<EI_CLASS>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:207
msgid "The fifth byte identifies the architecture for this binary:"
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:208
#, no-wrap
msgid "B<ELFCLASSNONE>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:212
msgid "This class is invalid."
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:212
#, no-wrap
msgid "B<ELFCLASS32>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:217
msgid ""
"This defines the 32-bit architecture.  It supports machines with files and "
"virtual address spaces up to 4 Gigabytes."
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:217
#, no-wrap
msgid "B<ELFCLASS64>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:220
msgid "This defines the 64-bit architecture."
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:222
#, no-wrap
msgid "B<EI_DATA>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:227
msgid ""
"The sixth byte specifies the data encoding of the processor-specific data in"
" the file.  Currently, these encodings are supported:"
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:228
#, no-wrap
msgid "B<ELFDATANONE>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:232
msgid "Unknown data format."
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:232
#, no-wrap
msgid "B<ELFDATA2LSB>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:235
msgid "Two's complement, little-endian."
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:235
#, no-wrap
msgid "B<ELFDATA2MSB>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:238
msgid "Two's complement, big-endian."
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:240
#, no-wrap
msgid "B<EI_VERSION>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:243
msgid "The seventh byte is the version number of the ELF specification:"
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:246 man-pages/man5/elf.5:492
#, no-wrap
msgid "B<EV_NONE>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:249
msgid "Invalid version."
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:249 man-pages/man5/elf.5:496
#, no-wrap
msgid "B<EV_CURRENT>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:252
msgid "Current version."
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:255
#, no-wrap
msgid "B<EI_OSABI>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:263
msgid ""
"The eighth byte identifies the operating system and ABI to which the object "
"is targeted.  Some fields in other ELF structures have flags and values that"
" have platform-specific meanings; the interpretation of those fields is "
"determined by the value of this byte.  For example:"
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:264
#, no-wrap
msgid "B<ELFOSABI_NONE>"
msgstr ""

#.  0
#. type: Plain text
#: man-pages/man5/elf.5:269
msgid "Same as ELFOSABI_SYSV"
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:269
#, no-wrap
msgid "B<ELFOSABI_SYSV>"
msgstr ""

#.  0
#.  synonym: ELFOSABI_NONE
#. type: Plain text
#: man-pages/man5/elf.5:274
msgid "UNIX System V ABI"
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:274
#, no-wrap
msgid "B<ELFOSABI_HPUX>"
msgstr ""

#.  1
#. type: Plain text
#: man-pages/man5/elf.5:278
msgid "HP-UX ABI"
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:278
#, no-wrap
msgid "B<ELFOSABI_NETBSD>"
msgstr ""

#.  2
#. type: Plain text
#: man-pages/man5/elf.5:282
msgid "NetBSD ABI"
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:282
#, no-wrap
msgid "B<ELFOSABI_LINUX>"
msgstr ""

#.  3
#.  .TP
#.  .BR ELFOSABI_HURD
#.  Hurd ABI
#.  4
#.  .TP
#.  .BR ELFOSABI_86OPEN
#.  86Open Common IA32 ABI
#.  5
#. type: Plain text
#: man-pages/man5/elf.5:294
msgid "Linux ABI"
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:294
#, no-wrap
msgid "B<ELFOSABI_SOLARIS>"
msgstr ""

#.  6
#.  .TP
#.  .BR ELFOSABI_MONTEREY
#.  Monterey project ABI
#.  Now replaced by
#.  ELFOSABI_AIX
#.  7
#. type: Plain text
#: man-pages/man5/elf.5:304
msgid "Solaris ABI"
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:304
#, no-wrap
msgid "B<ELFOSABI_IRIX>"
msgstr ""

#.  8
#. type: Plain text
#: man-pages/man5/elf.5:308
msgid "IRIX ABI"
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:308
#, no-wrap
msgid "B<ELFOSABI_FREEBSD>"
msgstr ""

#.  9
#. type: Plain text
#: man-pages/man5/elf.5:312
msgid "FreeBSD ABI"
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:312
#, no-wrap
msgid "B<ELFOSABI_TRU64>"
msgstr ""

#.  10
#.  ELFOSABI_MODESTO
#.  11
#.  ELFOSABI_OPENBSD
#.  12
#. type: Plain text
#: man-pages/man5/elf.5:320
msgid "TRU64 UNIX ABI"
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:320
#, no-wrap
msgid "B<ELFOSABI_ARM>"
msgstr ""

#.  97
#. type: Plain text
#: man-pages/man5/elf.5:324
msgid "ARM architecture ABI"
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:324
#, no-wrap
msgid "B<ELFOSABI_STANDALONE>"
msgstr ""

#.  255
#. type: Plain text
#: man-pages/man5/elf.5:328
msgid "Stand-alone (embedded) ABI"
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:330
#, no-wrap
msgid "B<EI_ABIVERSION>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:340
msgid ""
"The ninth byte identifies the version of the ABI to which the object is "
"targeted.  This field is used to distinguish among incompatible versions of "
"an ABI.  The interpretation of this version number is dependent on the ABI "
"identified by the B<EI_OSABI> field.  Applications conforming to this "
"specification use the value 0."
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:340
#, no-wrap
msgid "B<EI_PAD>"
msgstr ""

#.  As reported by Yuri Kozlov and confirmed by Mike Frysinger, EI_BRAND is
#.  not in GABI (http://www.sco.com/developers/gabi/latest/ch4.eheader.html)
#.  It looks to be a BSDism
#.  .TP
#.  .BR EI_BRAND
#.  Start of architecture identification.
#. type: Plain text
#: man-pages/man5/elf.5:356
msgid ""
"Start of padding.  These bytes are reserved and set to zero.  Programs which"
" read them should ignore them.  The value for B<EI_PAD> will change in the "
"future if currently unused bytes are given meanings."
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:356
#, no-wrap
msgid "B<EI_NIDENT>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:361
msgid "The size of the I<e_ident> array."
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:362
#, no-wrap
msgid "I<e_type>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:365
msgid "This member of the structure identifies the object file type:"
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:366
#, no-wrap
msgid "B<ET_NONE>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:370
msgid "An unknown type."
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:370
#, no-wrap
msgid "B<ET_REL>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:373
msgid "A relocatable file."
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:373
#, no-wrap
msgid "B<ET_EXEC>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:376
msgid "An executable file."
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:376
#, no-wrap
msgid "B<ET_DYN>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:379
msgid "A shared object."
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:379
#, no-wrap
msgid "B<ET_CORE>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:382
msgid "A core file."
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:384
#, no-wrap
msgid "I<e_machine>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:388
msgid ""
"This member specifies the required architecture for an individual file.  For"
" example:"
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:389
#, no-wrap
msgid "B<EM_NONE>"
msgstr ""

#.  0
#. type: Plain text
#: man-pages/man5/elf.5:394
msgid "An unknown machine"
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:394
#, no-wrap
msgid "B<EM_M32>"
msgstr ""

#.  1
#. type: Plain text
#: man-pages/man5/elf.5:398
msgid "AT&T WE 32100"
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:398
#, no-wrap
msgid "B<EM_SPARC>"
msgstr ""

#.  2
#. type: Plain text
#: man-pages/man5/elf.5:402
msgid "Sun Microsystems SPARC"
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:402
#, no-wrap
msgid "B<EM_386>"
msgstr ""

#.  3
#. type: Plain text
#: man-pages/man5/elf.5:406
msgid "Intel 80386"
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:406
#, no-wrap
msgid "B<EM_68K>"
msgstr ""

#.  4
#. type: Plain text
#: man-pages/man5/elf.5:410
msgid "Motorola 68000"
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:410
#, no-wrap
msgid "B<EM_88K>"
msgstr ""

#.  5
#.  .TP
#.  .BR EM_486
#.  Intel 80486
#.  6
#. type: Plain text
#: man-pages/man5/elf.5:418
msgid "Motorola 88000"
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:418
#, no-wrap
msgid "B<EM_860>"
msgstr ""

#.  7
#. type: Plain text
#: man-pages/man5/elf.5:422
msgid "Intel 80860"
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:422
#, no-wrap
msgid "B<EM_MIPS>"
msgstr ""

#.  8
#.  EM_S370
#.  9
#.  .TP
#.  .BR EM_MIPS_RS4_BE
#.  MIPS RS4000 (big-endian only). Deprecated
#.  10
#.  EM_MIPS_RS3_LE (MIPS R3000 little-endian)
#.  10
#. type: Plain text
#: man-pages/man5/elf.5:434
msgid "MIPS RS3000 (big-endian only)"
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:434
#, no-wrap
msgid "B<EM_PARISC>"
msgstr ""

#.  15
#. type: Plain text
#: man-pages/man5/elf.5:438
msgid "HP/PA"
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:438
#, no-wrap
msgid "B<EM_SPARC32PLUS>"
msgstr ""

#.  18
#. type: Plain text
#: man-pages/man5/elf.5:442
msgid "SPARC with enhanced instruction set"
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:442
#, no-wrap
msgid "B<EM_PPC>"
msgstr ""

#.  20
#. type: Plain text
#: man-pages/man5/elf.5:446
msgid "PowerPC"
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:446
#, no-wrap
msgid "B<EM_PPC64>"
msgstr ""

#.  21
#. type: Plain text
#: man-pages/man5/elf.5:450
msgid "PowerPC 64-bit"
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:450
#, no-wrap
msgid "B<EM_S390>"
msgstr ""

#.  22
#. type: Plain text
#: man-pages/man5/elf.5:454
msgid "IBM S/390"
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:454
#, no-wrap
msgid "B<EM_ARM>"
msgstr ""

#.  40
#. type: Plain text
#: man-pages/man5/elf.5:458
msgid "Advanced RISC Machines"
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:458
#, no-wrap
msgid "B<EM_SH>"
msgstr ""

#.  42
#. type: Plain text
#: man-pages/man5/elf.5:462
msgid "Renesas SuperH"
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:462
#, no-wrap
msgid "B<EM_SPARCV9>"
msgstr ""

#.  43
#. type: Plain text
#: man-pages/man5/elf.5:466
msgid "SPARC v9 64-bit"
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:466
#, no-wrap
msgid "B<EM_IA_64>"
msgstr ""

#.  50
#. type: Plain text
#: man-pages/man5/elf.5:470
msgid "Intel Itanium"
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:470
#, no-wrap
msgid "B<EM_X86_64>"
msgstr ""

#.  62
#. type: Plain text
#: man-pages/man5/elf.5:474
msgid "AMD x86-64"
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:474
#, no-wrap
msgid "B<EM_VAX>"
msgstr ""

#.  75
#.  EM_CRIS
#.  76
#.  .TP
#.  .BR EM_ALPHA
#.  Compaq [DEC] Alpha
#.  .TP
#.  .BR EM_ALPHA_EXP
#.  Compaq [DEC] Alpha with enhanced instruction set
#. type: Plain text
#: man-pages/man5/elf.5:486
msgid "DEC Vax"
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:488
#, no-wrap
msgid "I<e_version>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:491
msgid "This member identifies the file version:"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:496
msgid "Invalid version"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:499
msgid "Current version"
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:501
#, no-wrap
msgid "I<e_entry>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:507
msgid ""
"This member gives the virtual address to which the system first transfers "
"control, thus starting the process.  If the file has no associated entry "
"point, this member holds zero."
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:507
#, no-wrap
msgid "I<e_phoff>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:512
msgid ""
"This member holds the program header table's file offset in bytes.  If the "
"file has no program header table, this member holds zero."
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:512
#, no-wrap
msgid "I<e_shoff>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:517
msgid ""
"This member holds the section header table's file offset in bytes.  If the "
"file has no section header table, this member holds zero."
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:517
#, no-wrap
msgid "I<e_flags>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:522
msgid ""
"This member holds processor-specific flags associated with the file.  Flag "
"names take the form EF_`machine_flag'.  Currently, no flags have been "
"defined."
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:522
#, no-wrap
msgid "I<e_ehsize>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:525
msgid "This member holds the ELF header's size in bytes."
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:525
#, no-wrap
msgid "I<e_phentsize>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:529
msgid ""
"This member holds the size in bytes of one entry in the file's program "
"header table; all entries are the same size."
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:529
#, no-wrap
msgid "I<e_phnum>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:542
msgid ""
"This member holds the number of entries in the program header table.  Thus "
"the product of I<e_phentsize> and I<e_phnum> gives the table's size in "
"bytes.  If a file has no program header, I<e_phnum> holds the value zero."
msgstr ""

#.  This is a Linux extension, added in Linux 2.6.34.
#. type: Plain text
#: man-pages/man5/elf.5:556
msgid ""
"If the number of entries in the program header table is larger than or equal"
" to B<PN_XNUM> (0xffff), this member holds B<PN_XNUM> (0xffff) and the real "
"number of entries in the program header table is held in the I<sh_info> "
"member of the initial entry in section header table.  Otherwise, the "
"I<sh_info> member of the initial entry contains the value zero."
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:557
#, no-wrap
msgid "B<PN_XNUM>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:562
msgid ""
"This is defined as 0xffff, the largest number I<e_phnum> can have, "
"specifying where the actual number of program headers is assigned."
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:565
#, no-wrap
msgid "I<e_shentsize>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:570
msgid ""
"This member holds a sections header's size in bytes.  A section header is "
"one entry in the section header table; all entries are the same size."
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:570
#, no-wrap
msgid "I<e_shnum>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:583
msgid ""
"This member holds the number of entries in the section header table.  Thus "
"the product of I<e_shentsize> and I<e_shnum> gives the section header "
"table's size in bytes.  If a file has no section header table, I<e_shnum> "
"holds the value of zero."
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:597
msgid ""
"If the number of entries in the section header table is larger than or equal"
" to B<SHN_LORESERVE> (0xff00), I<e_shnum> holds the value zero and the real "
"number of entries in the section header table is held in the I<sh_size> "
"member of the initial entry in section header table.  Otherwise, the "
"I<sh_size> member of the initial entry in the section header table holds the"
" value zero."
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:597
#, no-wrap
msgid "I<e_shstrndx>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:604
msgid ""
"This member holds the section header table index of the entry associated "
"with the section name string table.  If the file has no section name string "
"table, this member holds the value B<SHN_UNDEF>."
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:618
msgid ""
"If the index of section name string table section is larger than or equal to"
" B<SHN_LORESERVE> (0xff00), this member holds B<SHN_XINDEX> (0xffff) and the"
" real index of the section name string table section is held in the "
"I<sh_link> member of the initial entry in section header table.  Otherwise, "
"the I<sh_link> member of the initial entry in section header table contains "
"the value zero."
msgstr ""

#. type: SS
#: man-pages/man5/elf.5:618
#, no-wrap
msgid "Program header (Phdr)"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:637
msgid ""
"An executable or shared object file's program header table is an array of "
"structures, each describing a segment or other information the system needs "
"to prepare the program for execution.  An object file I<segment> contains "
"one or more I<sections>.  Program headers are meaningful only for executable"
" and shared object files.  A file specifies its own program header size with"
" the ELF header's I<e_phentsize> and I<e_phnum> members.  The ELF program "
"header is described by the type I<Elf32_Phdr> or I<Elf64_Phdr> depending on "
"the architecture:"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:650
#, no-wrap
msgid ""
"typedef struct {\n"
"    uint32_t   p_type;\n"
"    Elf32_Off  p_offset;\n"
"    Elf32_Addr p_vaddr;\n"
"    Elf32_Addr p_paddr;\n"
"    uint32_t   p_filesz;\n"
"    uint32_t   p_memsz;\n"
"    uint32_t   p_flags;\n"
"    uint32_t   p_align;\n"
"} Elf32_Phdr;\n"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:665
#, no-wrap
msgid ""
"typedef struct {\n"
"    uint32_t   p_type;\n"
"    uint32_t   p_flags;\n"
"    Elf64_Off  p_offset;\n"
"    Elf64_Addr p_vaddr;\n"
"    Elf64_Addr p_paddr;\n"
"    uint64_t   p_filesz;\n"
"    uint64_t   p_memsz;\n"
"    uint64_t   p_align;\n"
"} Elf64_Phdr;\n"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:672
msgid ""
"The main difference between the 32-bit and the 64-bit program header lies in"
" the location of the I<p_flags> member in the total struct."
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:672
#, no-wrap
msgid "I<p_type>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:676
msgid ""
"This member of the structure indicates what kind of segment this array "
"element describes or how to interpret the array element's information."
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:677
#, no-wrap
msgid "B<PT_NULL>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:681
msgid ""
"The array element is unused and the other members' values are undefined.  "
"This lets the program header have ignored entries."
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:681
#, no-wrap
msgid "B<PT_LOAD>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:702
msgid ""
"The array element specifies a loadable segment, described by I<p_filesz> and"
" I<p_memsz>.  The bytes from the file are mapped to the beginning of the "
"memory segment.  If the segment's memory size I<p_memsz> is larger than the "
"file size I<p_filesz>, the \"extra\" bytes are defined to hold the value 0 "
"and to follow the segment's initialized area.  The file size may not be "
"larger than the memory size.  Loadable segment entries in the program header"
" table appear in ascending order, sorted on the I<p_vaddr> member."
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:702
#, no-wrap
msgid "B<PT_DYNAMIC>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:705
msgid "The array element specifies dynamic linking information."
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:705
#, no-wrap
msgid "B<PT_INTERP>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:713
msgid ""
"The array element specifies the location and size of a null-terminated "
"pathname to invoke as an interpreter.  This segment type is meaningful only "
"for executable files (though it may occur for shared objects).  However it "
"may not occur more than once in a file.  If it is present, it must precede "
"any loadable segment entry."
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:713
#, no-wrap
msgid "B<PT_NOTE>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:716
msgid "The array element specifies the location of notes (ElfN_Nhdr)."
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:716
#, no-wrap
msgid "B<PT_SHLIB>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:721
msgid ""
"This segment type is reserved but has unspecified semantics.  Programs that "
"contain an array element of this type do not conform to the ABI."
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:721
#, no-wrap
msgid "B<PT_PHDR>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:731
msgid ""
"The array element, if present, specifies the location and size of the "
"program header table itself, both in the file and in the memory image of the"
" program.  This segment type may not occur more than once in a file.  "
"Moreover, it may occur only if the program header table is part of the "
"memory image of the program.  If it is present, it must precede any loadable"
" segment entry."
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:731
#, no-wrap
msgid "B<PT_LOPROC>, B<PT_HIPROC>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:736
msgid ""
"Values in the inclusive range [B<PT_LOPROC>, B<PT_HIPROC>] are reserved for "
"processor-specific semantics."
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:736
#, no-wrap
msgid "B<PT_GNU_STACK>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:742
msgid ""
"GNU extension which is used by the Linux kernel to control the state of the "
"stack via the flags set in the I<p_flags> member."
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:743
#, no-wrap
msgid "I<p_offset>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:747
msgid ""
"This member holds the offset from the beginning of the file at which the "
"first byte of the segment resides."
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:747
#, no-wrap
msgid "I<p_vaddr>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:751
msgid ""
"This member holds the virtual address at which the first byte of the segment"
" resides in memory."
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:751
#, no-wrap
msgid "I<p_paddr>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:759
msgid ""
"On systems for which physical addressing is relevant, this member is "
"reserved for the segment's physical address.  Under BSD this member is not "
"used and must be zero."
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:759
#, no-wrap
msgid "I<p_filesz>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:763
msgid ""
"This member holds the number of bytes in the file image of the segment.  It "
"may be zero."
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:763
#, no-wrap
msgid "I<p_memsz>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:767
msgid ""
"This member holds the number of bytes in the memory image of the segment.  "
"It may be zero."
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:767
#, no-wrap
msgid "I<p_flags>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:770
msgid "This member holds a bit mask of flags relevant to the segment:"
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:771
#, no-wrap
msgid "B<PF_X>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:775
msgid "An executable segment."
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:775
#, no-wrap
msgid "B<PF_W>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:778
msgid "A writable segment."
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:778
#, no-wrap
msgid "B<PF_R>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:781
msgid "A readable segment."
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:793
msgid ""
"A text segment commonly has the flags B<PF_X> and B<PF_R>.  A data segment "
"commonly has B<PF_X>, B<PF_W>, and B<PF_R>."
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:793
#, no-wrap
msgid "I<p_align>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:812
msgid ""
"This member holds the value to which the segments are aligned in memory and "
"in the file.  Loadable process segments must have congruent values for "
"I<p_vaddr> and I<p_offset>, modulo the page size.  Values of zero and one "
"mean no alignment is required.  Otherwise, I<p_align> should be a positive, "
"integral power of two, and I<p_vaddr> should equal I<p_offset>, modulo "
"I<p_align>."
msgstr ""

#. type: SS
#: man-pages/man5/elf.5:812
#, no-wrap
msgid "Section header (Shdr)"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:829
msgid ""
"A file's section header table lets one locate all the file's sections.  The "
"section header table is an array of I<Elf32_Shdr> or I<Elf64_Shdr> "
"structures.  The ELF header's I<e_shoff> member gives the byte offset from "
"the beginning of the file to the section header table.  I<e_shnum> holds the"
" number of entries the section header table contains.  I<e_shentsize> holds "
"the size in bytes of each entry."
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:845
msgid ""
"A section header table index is a subscript into this array.  Some section "
"header table indices are reserved: the initial entry and the indices between"
" B<SHN_LORESERVE> and B<SHN_HIRESERVE>.  The initial entry is used in ELF "
"extensions for I<e_phnum>, I<e_shnum> and I<e_strndx>; in other cases, each "
"field in the initial entry is set to zero.  An object file does not have "
"sections for these special indices:"
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:845
#, no-wrap
msgid "B<SHN_UNDEF>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:849
msgid ""
"This value marks an undefined, missing, irrelevant, or otherwise meaningless"
" section reference."
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:849
#, no-wrap
msgid "B<SHN_LORESERVE>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:852
msgid "This value specifies the lower bound of the range of reserved indices."
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:852
#, no-wrap
msgid "B<SHN_LOPROC>, B<SHN_HIPROC>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:857
msgid ""
"Values greater in the inclusive range [B<SHN_LOPROC>, B<SHN_HIPROC>] are "
"reserved for processor-specific semantics."
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:857
#, no-wrap
msgid "B<SHN_ABS>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:864
msgid ""
"This value specifies the absolute value for the corresponding reference.  "
"For example, a symbol defined relative to section number B<SHN_ABS> has an "
"absolute value and is not affected by relocation."
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:864
#, no-wrap
msgid "B<SHN_COMMON>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:868
msgid ""
"Symbols defined relative to this section are common symbols, such as FORTRAN"
" COMMON or unallocated C external variables."
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:868
#, no-wrap
msgid "B<SHN_HIRESERVE>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:879
msgid ""
"This value specifies the upper bound of the range of reserved indices.  The "
"system reserves indices between B<SHN_LORESERVE> and B<SHN_HIRESERVE>, "
"inclusive.  The section header table does not contain entries for the "
"reserved indices."
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:881
msgid "The section header has the following structure:"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:896
#, no-wrap
msgid ""
"typedef struct {\n"
"    uint32_t   sh_name;\n"
"    uint32_t   sh_type;\n"
"    uint32_t   sh_flags;\n"
"    Elf32_Addr sh_addr;\n"
"    Elf32_Off  sh_offset;\n"
"    uint32_t   sh_size;\n"
"    uint32_t   sh_link;\n"
"    uint32_t   sh_info;\n"
"    uint32_t   sh_addralign;\n"
"    uint32_t   sh_entsize;\n"
"} Elf32_Shdr;\n"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:913
#, no-wrap
msgid ""
"typedef struct {\n"
"    uint32_t   sh_name;\n"
"    uint32_t   sh_type;\n"
"    uint64_t   sh_flags;\n"
"    Elf64_Addr sh_addr;\n"
"    Elf64_Off  sh_offset;\n"
"    uint64_t   sh_size;\n"
"    uint32_t   sh_link;\n"
"    uint32_t   sh_info;\n"
"    uint64_t   sh_addralign;\n"
"    uint64_t   sh_entsize;\n"
"} Elf64_Shdr;\n"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:917
msgid ""
"No real differences exist between the 32-bit and 64-bit section headers."
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:917
#, no-wrap
msgid "I<sh_name>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:923
msgid ""
"This member specifies the name of the section.  Its value is an index into "
"the section header string table section, giving the location of a null-"
"terminated string."
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:923
#, no-wrap
msgid "I<sh_type>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:926
msgid "This member categorizes the section's contents and semantics."
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:927
#, no-wrap
msgid "B<SHT_NULL>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:934
msgid ""
"This value marks the section header as inactive.  It does not have an "
"associated section.  Other members of the section header have undefined "
"values."
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:934
#, no-wrap
msgid "B<SHT_PROGBITS>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:938
msgid ""
"This section holds information defined by the program, whose format and "
"meaning are determined solely by the program."
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:938
#, no-wrap
msgid "B<SHT_SYMTAB>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:951
msgid ""
"This section holds a symbol table.  Typically, B<SHT_SYMTAB> provides "
"symbols for link editing, though it may also be used for dynamic linking.  "
"As a complete symbol table, it may contain many symbols unnecessary for "
"dynamic linking.  An object file can also contain a B<SHT_DYNSYM> section."
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:951
#, no-wrap
msgid "B<SHT_STRTAB>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:956
msgid ""
"This section holds a string table.  An object file may have multiple string "
"table sections."
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:956
#, no-wrap
msgid "B<SHT_RELA>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:964
msgid ""
"This section holds relocation entries with explicit addends, such as type "
"I<Elf32_Rela> for the 32-bit class of object files.  An object may have "
"multiple relocation sections."
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:964
#, no-wrap
msgid "B<SHT_HASH>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:971
msgid ""
"This section holds a symbol hash table.  An object participating in dynamic "
"linking must contain a symbol hash table.  An object file may have only one "
"hash table."
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:971
#, no-wrap
msgid "B<SHT_DYNAMIC>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:976
msgid ""
"This section holds information for dynamic linking.  An object file may have"
" only one dynamic section."
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:976
#, no-wrap
msgid "B<SHT_NOTE>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:979
msgid "This section holds notes (ElfN_Nhdr)."
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:979
#, no-wrap
msgid "B<SHT_NOBITS>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:987
msgid ""
"A section of this type occupies no space in the file but otherwise resembles"
" B<SHT_PROGBITS>.  Although this section contains no bytes, the I<sh_offset>"
" member contains the conceptual file offset."
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:987
#, no-wrap
msgid "B<SHT_REL>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:995
msgid ""
"This section holds relocation offsets without explicit addends, such as type"
" I<Elf32_Rel> for the 32-bit class of object files.  An object file may have"
" multiple relocation sections."
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:995
#, no-wrap
msgid "B<SHT_SHLIB>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:998
msgid "This section is reserved but has unspecified semantics."
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:998
#, no-wrap
msgid "B<SHT_DYNSYM>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:1005
msgid ""
"This section holds a minimal set of dynamic linking symbols.  An object file"
" can also contain a B<SHT_SYMTAB> section."
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:1005
#, no-wrap
msgid "B<SHT_LOPROC>, B<SHT_HIPROC>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:1010
msgid ""
"Values in the inclusive range [B<SHT_LOPROC>, B<SHT_HIPROC>] are reserved "
"for processor-specific semantics."
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:1010
#, no-wrap
msgid "B<SHT_LOUSER>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:1014
msgid ""
"This value specifies the lower bound of the range of indices reserved for "
"application programs."
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:1014
#, no-wrap
msgid "B<SHT_HIUSER>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:1024
msgid ""
"This value specifies the upper bound of the range of indices reserved for "
"application programs.  Section types between B<SHT_LOUSER> and B<SHT_HIUSER>"
" may be used by the application, without conflicting with current or future "
"system-defined section types."
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:1025
#, no-wrap
msgid "I<sh_flags>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:1037
msgid ""
"Sections support one-bit flags that describe miscellaneous attributes.  If a"
" flag bit is set in I<sh_flags>, the attribute is \"on\" for the section.  "
"Otherwise, the attribute is \"off\" or does not apply.  Undefined attributes"
" are set to zero."
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:1038
#, no-wrap
msgid "B<SHF_WRITE>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:1042
msgid ""
"This section contains data that should be writable during process execution."
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:1042
#, no-wrap
msgid "B<SHF_ALLOC>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:1049
msgid ""
"This section occupies memory during process execution.  Some control "
"sections do not reside in the memory image of an object file.  This "
"attribute is off for those sections."
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:1049
#, no-wrap
msgid "B<SHF_EXECINSTR>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:1052
msgid "This section contains executable machine instructions."
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:1052
#, no-wrap
msgid "B<SHF_MASKPROC>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:1056
msgid ""
"All bits included in this mask are reserved for processor-specific "
"semantics."
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:1057
#, no-wrap
msgid "I<sh_addr>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:1062
msgid ""
"If this section appears in the memory image of a process, this member holds "
"the address at which the section's first byte should reside.  Otherwise, the"
" member contains zero."
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:1062
#, no-wrap
msgid "I<sh_offset>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:1071
msgid ""
"This member's value holds the byte offset from the beginning of the file to "
"the first byte in the section.  One section type, B<SHT_NOBITS>, occupies no"
" space in the file, and its I<sh_offset> member locates the conceptual "
"placement in the file."
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:1071
#, no-wrap
msgid "I<sh_size>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:1083
msgid ""
"This member holds the section's size in bytes.  Unless the section type is "
"B<SHT_NOBITS>, the section occupies I<sh_size> bytes in the file.  A section"
" of type B<SHT_NOBITS> may have a nonzero size, but it occupies no space in "
"the file."
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:1083
#, no-wrap
msgid "I<sh_link>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:1087
msgid ""
"This member holds a section header table index link, whose interpretation "
"depends on the section type."
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:1087
#, no-wrap
msgid "I<sh_info>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:1091
msgid ""
"This member holds extra information, whose interpretation depends on the "
"section type."
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:1091
#, no-wrap
msgid "I<sh_addralign>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:1103
msgid ""
"Some sections have address alignment constraints.  If a section holds a "
"doubleword, the system must ensure doubleword alignment for the entire "
"section.  That is, the value of I<sh_addr> must be congruent to zero, modulo"
" the value of I<sh_addralign>.  Only zero and positive integral powers of "
"two are allowed.  The value 0 or 1 means that the section has no alignment "
"constraints."
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:1103
#, no-wrap
msgid "I<sh_entsize>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:1109
msgid ""
"Some sections hold a table of fixed-sized entries, such as a symbol table.  "
"For such a section, this member gives the size in bytes for each entry.  "
"This member contains zero if the section does not hold a table of fixed-size"
" entries."
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:1111
msgid "Various sections hold program and control information:"
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:1111
#, no-wrap
msgid "I<.bss>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:1123
msgid ""
"This section holds uninitialized data that contributes to the program's "
"memory image.  By definition, the system initializes the data with zeros "
"when the program begins to run.  This section is of type B<SHT_NOBITS>.  The"
" attribute types are B<SHF_ALLOC> and B<SHF_WRITE>."
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:1123
#, no-wrap
msgid "I<.comment>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:1129
msgid ""
"This section holds version control information.  This section is of type "
"B<SHT_PROGBITS>.  No attribute types are used."
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:1129
#, no-wrap
msgid "I<.ctors>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:1138
msgid ""
"This section holds initialized pointers to the C++ constructor functions.  "
"This section is of type B<SHT_PROGBITS>.  The attribute types are "
"B<SHF_ALLOC> and B<SHF_WRITE>."
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:1138
#, no-wrap
msgid "I<.data>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:1148 man-pages/man5/elf.5:1158
msgid ""
"This section holds initialized data that contribute to the program's memory "
"image.  This section is of type B<SHT_PROGBITS>.  The attribute types are "
"B<SHF_ALLOC> and B<SHF_WRITE>."
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:1148
#, no-wrap
msgid "I<.data1>"
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:1158
#, no-wrap
msgid "I<.debug>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:1166
msgid ""
"This section holds information for symbolic debugging.  The contents are "
"unspecified.  This section is of type B<SHT_PROGBITS>.  No attribute types "
"are used."
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:1166
#, no-wrap
msgid "I<.dtors>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:1175
msgid ""
"This section holds initialized pointers to the C++ destructor functions.  "
"This section is of type B<SHT_PROGBITS>.  The attribute types are "
"B<SHF_ALLOC> and B<SHF_WRITE>."
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:1175
#, no-wrap
msgid "I<.dynamic>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:1188
msgid ""
"This section holds dynamic linking information.  The section's attributes "
"will include the B<SHF_ALLOC> bit.  Whether the B<SHF_WRITE> bit is set is "
"processor-specific.  This section is of type B<SHT_DYNAMIC>.  See the "
"attributes above."
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:1188
#, no-wrap
msgid "I<.dynstr>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:1196
msgid ""
"This section holds strings needed for dynamic linking, most commonly the "
"strings that represent the names associated with symbol table entries.  This"
" section is of type B<SHT_STRTAB>.  The attribute type used is B<SHF_ALLOC>."
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:1196
#, no-wrap
msgid "I<.dynsym>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:1203
msgid ""
"This section holds the dynamic linking symbol table.  This section is of "
"type B<SHT_DYNSYM>.  The attribute used is B<SHF_ALLOC>."
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:1203
#, no-wrap
msgid "I<.fini>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:1215
msgid ""
"This section holds executable instructions that contribute to the process "
"termination code.  When a program exits normally the system arranges to "
"execute the code in this section.  This section is of type B<SHT_PROGBITS>."
"  The attributes used are B<SHF_ALLOC> and B<SHF_EXECINSTR>."
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:1215
#, no-wrap
msgid "I<.gnu.version>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:1224
msgid ""
"This section holds the version symbol table, an array of I<ElfN_Half> "
"elements.  This section is of type B<SHT_GNU_versym>.  The attribute type "
"used is B<SHF_ALLOC>."
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:1224
#, no-wrap
msgid "I<.gnu.version_d>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:1233
msgid ""
"This section holds the version symbol definitions, a table of I<ElfN_Verdef>"
" structures.  This section is of type B<SHT_GNU_verdef>.  The attribute type"
" used is B<SHF_ALLOC>."
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:1233
#, no-wrap
msgid "I<.gnu.version_r>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:1243
msgid ""
"This section holds the version symbol needed elements, a table of "
"I<ElfN_Verneed> structures.  This section is of type B<SHT_GNU_versym>.  The"
" attribute type used is B<SHF_ALLOC>."
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:1243
#, no-wrap
msgid "I<.got>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:1249
msgid ""
"This section holds the global offset table.  This section is of type "
"B<SHT_PROGBITS>.  The attributes are processor-specific."
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:1249
#, no-wrap
msgid "I<.hash>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:1256
msgid ""
"This section holds a symbol hash table.  This section is of type "
"B<SHT_HASH>.  The attribute used is B<SHF_ALLOC>."
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:1256
#, no-wrap
msgid "I<.init>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:1268
msgid ""
"This section holds executable instructions that contribute to the process "
"initialization code.  When a program starts to run the system arranges to "
"execute the code in this section before calling the main program entry "
"point.  This section is of type B<SHT_PROGBITS>.  The attributes used are "
"B<SHF_ALLOC> and B<SHF_EXECINSTR>."
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:1268
#, no-wrap
msgid "I<.interp>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:1279
msgid ""
"This section holds the pathname of a program interpreter.  If the file has a"
" loadable segment that includes the section, the section's attributes will "
"include the B<SHF_ALLOC> bit.  Otherwise, that bit will be off.  This "
"section is of type B<SHT_PROGBITS>."
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:1279
#, no-wrap
msgid "I<.line>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:1288
msgid ""
"This section holds line number information for symbolic debugging, which "
"describes the correspondence between the program source and the machine "
"code.  The contents are unspecified.  This section is of type "
"B<SHT_PROGBITS>.  No attribute types are used."
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:1288
#, no-wrap
msgid "I<.note>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:1294
msgid ""
"This section holds various notes.  This section is of type B<SHT_NOTE>.  No "
"attribute types are used."
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:1294
#, no-wrap
msgid "I<.note.ABI-tag>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:1302
msgid ""
"This section is used to declare the expected run-time ABI of the ELF image."
"  It may include the operating system name and its run-time versions.  This "
"section is of type B<SHT_NOTE>.  The only attribute used is B<SHF_ALLOC>."
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:1302
#, no-wrap
msgid "I<.note.gnu.build-id>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:1315
msgid ""
"This section is used to hold an ID that uniquely identifies the contents of "
"the ELF image.  Different files with the same build ID should contain the "
"same executable content.  See the B<--build-id> option to the GNU linker "
"(B<ld> (1)) for more details.  This section is of type B<SHT_NOTE>.  The "
"only attribute used is B<SHF_ALLOC>."
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:1315
#, no-wrap
msgid "I<.note.GNU-stack>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:1324
msgid ""
"This section is used in Linux object files for declaring stack attributes.  "
"This section is of type B<SHT_PROGBITS>.  The only attribute used is "
"B<SHF_EXECINSTR>.  This indicates to the GNU linker that the object file "
"requires an executable stack."
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:1324
#, no-wrap
msgid "I<.note.openbsd.ident>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:1329
msgid ""
"OpenBSD native executables usually contain this section to identify "
"themselves so the kernel can bypass any compatibility ELF binary emulation "
"tests when loading the file."
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:1329
#, no-wrap
msgid "I<.plt>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:1335
msgid ""
"This section holds the procedure linkage table.  This section is of type "
"B<SHT_PROGBITS>.  The attributes are processor-specific."
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:1335
#, no-wrap
msgid "I<.relNAME>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:1354
msgid ""
"This section holds relocation information as described below.  If the file "
"has a loadable segment that includes relocation, the section's attributes "
"will include the B<SHF_ALLOC> bit.  Otherwise, the bit will be off.  By "
"convention, \"NAME\" is supplied by the section to which the relocations "
"apply.  Thus a relocation section for B<.text> normally would have the name "
"B<.rel.text>.  This section is of type B<SHT_REL>."
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:1354
#, no-wrap
msgid "I<.relaNAME>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:1373
msgid ""
"This section holds relocation information as described below.  If the file "
"has a loadable segment that includes relocation, the section's attributes "
"will include the B<SHF_ALLOC> bit.  Otherwise, the bit will be off.  By "
"convention, \"NAME\" is supplied by the section to which the relocations "
"apply.  Thus a relocation section for B<.text> normally would have the name "
"B<.rela.text>.  This section is of type B<SHT_RELA>."
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:1373
#, no-wrap
msgid "I<.rodata>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:1381 man-pages/man5/elf.5:1389
msgid ""
"This section holds read-only data that typically contributes to a "
"nonwritable segment in the process image.  This section is of type "
"B<SHT_PROGBITS>.  The attribute used is B<SHF_ALLOC>."
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:1381
#, no-wrap
msgid "I<.rodata1>"
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:1389
#, no-wrap
msgid "I<.shstrtab>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:1395
msgid ""
"This section holds section names.  This section is of type B<SHT_STRTAB>.  "
"No attribute types are used."
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:1395
#, no-wrap
msgid "I<.strtab>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:1407
msgid ""
"This section holds strings, most commonly the strings that represent the "
"names associated with symbol table entries.  If the file has a loadable "
"segment that includes the symbol string table, the section's attributes will"
" include the B<SHF_ALLOC> bit.  Otherwise, the bit will be off.  This "
"section is of type B<SHT_STRTAB>."
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:1407
#, no-wrap
msgid "I<.symtab>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:1418
msgid ""
"This section holds a symbol table.  If the file has a loadable segment that "
"includes the symbol table, the section's attributes will include the "
"B<SHF_ALLOC> bit.  Otherwise, the bit will be off.  This section is of type "
"B<SHT_SYMTAB>."
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:1418
#, no-wrap
msgid "I<.text>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:1430
msgid ""
"This section holds the \"text\", or executable instructions, of a program.  "
"This section is of type B<SHT_PROGBITS>.  The attributes used are "
"B<SHF_ALLOC> and B<SHF_EXECINSTR>."
msgstr ""

#. type: SS
#: man-pages/man5/elf.5:1430
#, no-wrap
msgid "String and symbol tables"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:1441
msgid ""
"String table sections hold null-terminated character sequences, commonly "
"called strings.  The object file uses these strings to represent symbol and "
"section names.  One references a string as an index into the string table "
"section.  The first byte, which is index zero, is defined to hold a null "
"byte (\\(aq\\e0\\(aq).  Similarly, a string table's last byte is defined to "
"hold a null byte, ensuring null termination for all strings."
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:1446
msgid ""
"An object file's symbol table holds information needed to locate and "
"relocate a program's symbolic definitions and references.  A symbol table "
"index is a subscript into this array."
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:1457
#, no-wrap
msgid ""
"typedef struct {\n"
"    uint32_t      st_name;\n"
"    Elf32_Addr    st_value;\n"
"    uint32_t      st_size;\n"
"    unsigned char st_info;\n"
"    unsigned char st_other;\n"
"    uint16_t      st_shndx;\n"
"} Elf32_Sym;\n"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:1470
#, no-wrap
msgid ""
"typedef struct {\n"
"    uint32_t      st_name;\n"
"    unsigned char st_info;\n"
"    unsigned char st_other;\n"
"    uint16_t      st_shndx;\n"
"    Elf64_Addr    st_value;\n"
"    uint64_t      st_size;\n"
"} Elf64_Sym;\n"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:1475
msgid ""
"The 32-bit and 64-bit versions have the same members, just in a different "
"order."
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:1475
#, no-wrap
msgid "I<st_name>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:1483
msgid ""
"This member holds an index into the object file's symbol string table, which"
" holds character representations of the symbol names.  If the value is "
"nonzero, it represents a string table index that gives the symbol name.  "
"Otherwise, the symbol has no name."
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:1483
#, no-wrap
msgid "I<st_value>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:1486
msgid "This member gives the value of the associated symbol."
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:1486
#, no-wrap
msgid "I<st_size>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:1491
msgid ""
"Many symbols have associated sizes.  This member holds zero if the symbol "
"has no size or an unknown size."
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:1491
#, no-wrap
msgid "I<st_info>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:1494
msgid "This member specifies the symbol's type and binding attributes:"
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:1495
#, no-wrap
msgid "B<STT_NOTYPE>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:1498
msgid "The symbol's type is not defined."
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:1498
#, no-wrap
msgid "B<STT_OBJECT>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:1501
msgid "The symbol is associated with a data object."
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:1501
#, no-wrap
msgid "B<STT_FUNC>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:1504
msgid "The symbol is associated with a function or other executable code."
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:1504
#, no-wrap
msgid "B<STT_SECTION>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:1511
msgid ""
"The symbol is associated with a section.  Symbol table entries of this type "
"exist primarily for relocation and normally have B<STB_LOCAL> bindings."
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:1511
#, no-wrap
msgid "B<STT_FILE>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:1522
msgid ""
"By convention, the symbol's name gives the name of the source file "
"associated with the object file.  A file symbol has B<STB_LOCAL> bindings, "
"its section index is B<SHN_ABS>, and it precedes the other B<STB_LOCAL> "
"symbols of the file, if it is present."
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:1522
#, no-wrap
msgid "B<STT_LOPROC>, B<STT_HIPROC>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:1527
msgid ""
"Values in the inclusive range [B<STT_LOPROC>, B<STT_HIPROC>] are reserved "
"for processor-specific semantics."
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:1527
#, no-wrap
msgid "B<STB_LOCAL>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:1533
msgid ""
"Local symbols are not visible outside the object file containing their "
"definition.  Local symbols of the same name may exist in multiple files "
"without interfering with each other."
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:1533
#, no-wrap
msgid "B<STB_GLOBAL>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:1539
msgid ""
"Global symbols are visible to all object files being combined.  One file's "
"definition of a global symbol will satisfy another file's undefined "
"reference to the same symbol."
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:1539
#, no-wrap
msgid "B<STB_WEAK>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:1543
msgid ""
"Weak symbols resemble global symbols, but their definitions have lower "
"precedence."
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:1543
#, no-wrap
msgid "B<STB_LOPROC>, B<STB_HIPROC>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:1548
msgid ""
"Values in the inclusive range [B<STB_LOPROC>, B<STB_HIPROC>] are reserved "
"for processor-specific semantics."
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:1551
msgid ""
"There are macros for packing and unpacking the binding and type fields:"
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:1552
#, no-wrap
msgid "B<ELF32_ST_BIND(>I<info>B<)>, B<ELF64_ST_BIND(>I<info>B<)>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:1557
msgid "Extract a binding from an I<st_info> value."
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:1557
#, no-wrap
msgid "B<ELF32_ST_TYPE(>I<info>B<)>, B<ELF64_ST_TYPE(>I<info>B<)>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:1562
msgid "Extract a type from an I<st_info> value."
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:1562
#, no-wrap
msgid ""
"B<ELF32_ST_INFO(>I<bind>B<, >I<type>B<)>, B<ELF64_ST_INFO(>I<bind>B<, "
">I<type>B<)>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:1568
msgid "Convert a binding and a type into an I<st_info> value."
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:1569
#, no-wrap
msgid "I<st_other>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:1572
msgid "This member defines the symbol visibility."
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:1573
#, no-wrap
msgid "B<STV_DEFAULT>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:1580
msgid ""
"Default symbol visibility rules.  Global and weak symbols are available to "
"other modules; references in the local module can be interposed by "
"definitions in other modules."
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:1580
#, no-wrap
msgid "B<STV_INTERNAL>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:1583
msgid "Processor-specific hidden class."
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:1583
#, no-wrap
msgid "B<STV_HIDDEN>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:1588
msgid ""
"Symbol is unavailable to other modules; references in the local module "
"always resolve to the local symbol (i.e., the symbol can't be interposed by "
"definitions in other modules)."
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:1588
#, no-wrap
msgid "B<STV_PROTECTED>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:1592
msgid ""
"Symbol is available to other modules, but references in the local module "
"always resolve to the local symbol."
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:1595
msgid "There are macros for extracting the visibility type:"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:1599
msgid "B<ELF32_ST_VISIBILITY>(other)  or B<ELF64_ST_VISIBILITY>(other)"
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:1600
#, no-wrap
msgid "I<st_shndx>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:1608
msgid ""
"Every symbol table entry is \"defined\" in relation to some section.  This "
"member holds the relevant section header table index."
msgstr ""

#. type: SS
#: man-pages/man5/elf.5:1608
#, no-wrap
msgid "Relocation entries (Rel & Rela)"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:1616
msgid ""
"Relocation is the process of connecting symbolic references with symbolic "
"definitions.  Relocatable files must have information that describes how to "
"modify their section contents, thus allowing executable and shared object "
"files to hold the right information for a process's program image.  "
"Relocation entries are these data."
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:1618
msgid "Relocation structures that do not need an addend:"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:1625
#, no-wrap
msgid ""
"typedef struct {\n"
"    Elf32_Addr r_offset;\n"
"    uint32_t   r_info;\n"
"} Elf32_Rel;\n"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:1634
#, no-wrap
msgid ""
"typedef struct {\n"
"    Elf64_Addr r_offset;\n"
"    uint64_t   r_info;\n"
"} Elf64_Rel;\n"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:1638
msgid "Relocation structures that need an addend:"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:1646
#, no-wrap
msgid ""
"typedef struct {\n"
"    Elf32_Addr r_offset;\n"
"    uint32_t   r_info;\n"
"    int32_t    r_addend;\n"
"} Elf32_Rela;\n"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:1656
#, no-wrap
msgid ""
"typedef struct {\n"
"    Elf64_Addr r_offset;\n"
"    uint64_t   r_info;\n"
"    int64_t    r_addend;\n"
"} Elf64_Rela;\n"
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:1658
#, no-wrap
msgid "I<r_offset>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:1666
msgid ""
"This member gives the location at which to apply the relocation action.  For"
" a relocatable file, the value is the byte offset from the beginning of the "
"section to the storage unit affected by the relocation.  For an executable "
"file or shared object, the value is the virtual address of the storage unit "
"affected by the relocation."
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:1666
#, no-wrap
msgid "I<r_info>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:1681
msgid ""
"This member gives both the symbol table index with respect to which the "
"relocation must be made and the type of relocation to apply.  Relocation "
"types are processor-specific.  When the text refers to a relocation entry's "
"relocation type or symbol table index, it means the result of applying "
"B<ELF[32|64]_R_TYPE> or B<ELF[32|64]_R_SYM>, respectively, to the entry's "
"I<r_info> member."
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:1681
#, no-wrap
msgid "I<r_addend>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:1686
msgid ""
"This member specifies a constant addend used to compute the value to be "
"stored into the relocatable field."
msgstr ""

#. type: SS
#: man-pages/man5/elf.5:1686
#, no-wrap
msgid "Dynamic tags (Dyn)"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:1696
msgid ""
"The I<.dynamic> section contains a series of structures that hold relevant "
"dynamic linking information.  The I<d_tag> member controls the "
"interpretation of I<d_un>."
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:1707
#, no-wrap
msgid ""
"typedef struct {\n"
"    Elf32_Sword    d_tag;\n"
"    union {\n"
"        Elf32_Word d_val;\n"
"        Elf32_Addr d_ptr;\n"
"    } d_un;\n"
"} Elf32_Dyn;\n"
"extern Elf32_Dyn _DYNAMIC[];\n"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:1720
#, no-wrap
msgid ""
"typedef struct {\n"
"    Elf64_Sxword    d_tag;\n"
"    union {\n"
"        Elf64_Xword d_val;\n"
"        Elf64_Addr  d_ptr;\n"
"    } d_un;\n"
"} Elf64_Dyn;\n"
"extern Elf64_Dyn _DYNAMIC[];\n"
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:1722
#, no-wrap
msgid "I<d_tag>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:1725
msgid "This member may have any of the following values:"
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:1726
#, no-wrap
msgid "B<DT_NULL>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:1729
msgid "Marks end of dynamic section"
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:1729
#, no-wrap
msgid "B<DT_NEEDED>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:1732
msgid "String table offset to name of a needed library"
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:1732
#, no-wrap
msgid "B<DT_PLTRELSZ>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:1735
msgid "Size in bytes of PLT relocation entries"
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:1735
#, no-wrap
msgid "B<DT_PLTGOT>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:1738
msgid "Address of PLT and/or GOT"
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:1738
#, no-wrap
msgid "B<DT_HASH>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:1741
msgid "Address of symbol hash table"
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:1741
#, no-wrap
msgid "B<DT_STRTAB>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:1744
msgid "Address of string table"
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:1744
#, no-wrap
msgid "B<DT_SYMTAB>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:1747
msgid "Address of symbol table"
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:1747
#, no-wrap
msgid "B<DT_RELA>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:1750
msgid "Address of Rela relocation table"
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:1750
#, no-wrap
msgid "B<DT_RELASZ>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:1753
msgid "Size in bytes of the Rela relocation table"
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:1753
#, no-wrap
msgid "B<DT_RELAENT>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:1756
msgid "Size in bytes of a Rela relocation table entry"
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:1756
#, no-wrap
msgid "B<DT_STRSZ>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:1759
msgid "Size in bytes of string table"
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:1759
#, no-wrap
msgid "B<DT_SYMENT>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:1762
msgid "Size in bytes of a symbol table entry"
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:1762
#, no-wrap
msgid "B<DT_INIT>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:1765
msgid "Address of the initialization function"
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:1765
#, no-wrap
msgid "B<DT_FINI>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:1768
msgid "Address of the termination function"
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:1768
#, no-wrap
msgid "B<DT_SONAME>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:1771
msgid "String table offset to name of shared object"
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:1771
#, no-wrap
msgid "B<DT_RPATH>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:1774
msgid "String table offset to library search path (deprecated)"
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:1774
#, no-wrap
msgid "B<DT_SYMBOLIC>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:1777
msgid ""
"Alert linker to search this shared object before the executable for symbols"
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:1777
#, no-wrap
msgid "B<DT_REL>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:1780
msgid "Address of Rel relocation table"
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:1780
#, no-wrap
msgid "B<DT_RELSZ>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:1783
msgid "Size in bytes of Rel relocation table"
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:1783
#, no-wrap
msgid "B<DT_RELENT>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:1786
msgid "Size in bytes of a Rel table entry"
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:1786
#, no-wrap
msgid "B<DT_PLTREL>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:1789
msgid "Type of relocation entry to which the PLT refers (Rela or Rel)"
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:1789
#, no-wrap
msgid "B<DT_DEBUG>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:1792
msgid "Undefined use for debugging"
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:1792
#, no-wrap
msgid "B<DT_TEXTREL>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:1796
msgid ""
"Absence of this entry indicates that no relocation entries should apply to a"
" nonwritable segment"
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:1796
#, no-wrap
msgid "B<DT_JMPREL>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:1799
msgid "Address of relocation entries associated solely with the PLT"
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:1799
#, no-wrap
msgid "B<DT_BIND_NOW>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:1803
msgid ""
"Instruct dynamic linker to process all relocations before transferring "
"control to the executable"
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:1803
#, no-wrap
msgid "B<DT_RUNPATH>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:1806
msgid "String table offset to library search path"
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:1806
#, no-wrap
msgid "B<DT_LOPROC>, B<DT_HIPROC>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:1811
msgid ""
"Values in the inclusive range [B<DT_LOPROC>, B<DT_HIPROC>] are reserved for "
"processor-specific semantics"
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:1812
#, no-wrap
msgid "I<d_val>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:1815
msgid "This member represents integer values with various interpretations."
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:1815
#, no-wrap
msgid "I<d_ptr>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:1823
msgid ""
"This member represents program virtual addresses.  When interpreting these "
"addresses, the actual address should be computed based on the original file "
"value and memory base address.  Files do not contain relocation entries to "
"fixup these addresses."
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:1823
#, no-wrap
msgid "I<_DYNAMIC>"
msgstr ""

#.  GABI ELF Reference for Note Sections:
#.  http://www.sco.com/developers/gabi/latest/ch5.pheader.html#note_section
#.  Note that it implies the sizes and alignments of notes depend on the ELF
#.  size (e.g. 32-bit ELFs have three 4-byte words and use 4-byte alignment
#.  while 64-bit ELFs use 8-byte words & alignment), but that is not the case
#.  in the real world.  Notes always have three 4-byte words as can be seen
#.  in the source links below (remember that Elf64_Word is a 32-bit quantity).
#.  glibc:
#. https://sourceware.org/git/?p=glibc.git;a=blob;f=elf/elf.h;h=9e59b3275917549af0cebe1f2de9ded3b7b10bf2#l1173
#.  binutils: https://sourceware.org/git/?p=binutils-
#. gdb.git;a=blob;f=binutils/readelf.c;h=274ddd17266aef6e4ad1f67af8a13a21500ff2af#l15943
#.  Linux:
#. https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/include/uapi/linux/elf.h?h=v4.8#n422
#.  Solaris:
#. https://docs.oracle.com/cd/E23824_01/html/819-0690/chapter6-18048.html
#.  FreeBSD:
#. https://svnweb.freebsd.org/base/head/sys/sys/elf_common.h?revision=303677&view=markup#l33
#.  NetBSD:   https://www.netbsd.org/docs/kernel/elf-notes.html
#.  OpenBSD:
#. https://github.com/openbsd/src/blob/master/sys/sys/exec_elf.h#L533
#. type: Plain text
#: man-pages/man5/elf.5:1845
msgid ""
"Array containing all the dynamic structures in the I<.dynamic> section.  "
"This is automatically populated by the linker."
msgstr ""

#. type: SS
#: man-pages/man5/elf.5:1845
#, no-wrap
msgid "Notes (Nhdr)"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:1855
msgid ""
"ELF notes allow for appending arbitrary information for the system to use.  "
"They are largely used by core files (I<e_type> of B<ET_CORE>), but many "
"projects define their own set of extensions.  For example, the GNU tool "
"chain uses ELF notes to pass information from the linker to the C library."
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:1863
msgid ""
"Note sections contain a series of notes (see the I<struct> definitions "
"below).  Each note is followed by the name field (whose length is defined in"
" I<n_namesz>) and then by the descriptor field (whose length is defined in "
"I<n_descsz>) and whose starting address has a 4 byte alignment.  Neither "
"field is defined in the note struct due to their arbitrary lengths."
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:1866
msgid ""
"An example for parsing out two consecutive notes should clarify their layout"
" in memory:"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:1871
#, no-wrap
msgid ""
"void *memory, *name, *desc;\n"
"Elf64_Nhdr *note, *next_note;\n"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:1874
#, no-wrap
msgid ""
"/* The buffer is pointing to the start of the section/segment */\n"
"note = memory;\n"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:1877
#, no-wrap
msgid ""
"/* If the name is defined, it follows the note */\n"
"name = note-E<gt>n_namesz == 0 ? NULL : memory + sizeof(*note);\n"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:1880
#, no-wrap
msgid ""
"/* If the descriptor is defined, it follows the name\n"
"   (with alignment) */\n"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:1883
#, no-wrap
msgid ""
"desc = note-E<gt>n_descsz == 0 ? NULL :\n"
"       memory + sizeof(*note) + ALIGN_UP(note-E<gt>n_namesz, 4);\n"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:1888
#, no-wrap
msgid ""
"/* The next note follows both (with alignment) */\n"
"next_note = memory + sizeof(*note) +\n"
"                     ALIGN_UP(note-E<gt>n_namesz, 4) +\n"
"                     ALIGN_UP(note-E<gt>n_descsz, 4);\n"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:1902
msgid ""
"Keep in mind that the interpretation of I<n_type> depends on the namespace "
"defined by the I<n_namesz> field.  If the I<n_namesz> field is not set "
"(e.g., is 0), then there are two sets of notes: one for core files and one "
"for all other ELF types.  If the namespace is unknown, then tools will "
"usually fallback to these sets of notes as well."
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:1910
#, no-wrap
msgid ""
"typedef struct {\n"
"    Elf32_Word n_namesz;\n"
"    Elf32_Word n_descsz;\n"
"    Elf32_Word n_type;\n"
"} Elf32_Nhdr;\n"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:1920
#, no-wrap
msgid ""
"typedef struct {\n"
"    Elf64_Word n_namesz;\n"
"    Elf64_Word n_descsz;\n"
"    Elf64_Word n_type;\n"
"} Elf64_Nhdr;\n"
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:1922
#, no-wrap
msgid "I<n_namesz>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:1930
msgid ""
"The length of the name field in bytes.  The contents will immediately follow"
" this note in memory.  The name is null terminated.  For example, if the "
"name is \"GNU\", then I<n_namesz> will be set to 4."
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:1930
#, no-wrap
msgid "I<n_descsz>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:1934
msgid ""
"The length of the descriptor field in bytes.  The contents will immediately "
"follow the name field in memory."
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:1934
#, no-wrap
msgid "I<n_type>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:1938
msgid ""
"Depending on the value of the name field, this member may have any of the "
"following values:"
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:1939
#, no-wrap
msgid "B<Core files (e_type = ET_CORE)>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:1947
msgid ""
"Notes used by all core files.  These are highly operating system or "
"architecture specific and often require close coordination with kernels, C "
"libraries, and debuggers.  These are used when the namespace is the default "
"(i.e., I<n_namesz> will be set to 0), or a fallback when the namespace is "
"unknown."
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:1948
#, no-wrap
msgid "B<NT_PRSTATUS>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:1952
msgid "prstatus struct"
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:1952
#, no-wrap
msgid "B<NT_FPREGSET>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:1955
msgid "fpregset struct"
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:1955
#, no-wrap
msgid "B<NT_PRPSINFO>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:1958
msgid "prpsinfo struct"
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:1958
#, no-wrap
msgid "B<NT_PRXREG>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:1961
msgid "prxregset struct"
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:1961
#, no-wrap
msgid "B<NT_TASKSTRUCT>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:1964
msgid "task structure"
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:1964
#, no-wrap
msgid "B<NT_PLATFORM>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:1967
msgid "String from sysinfo(SI_PLATFORM)"
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:1967
#, no-wrap
msgid "B<NT_AUXV>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:1970
msgid "auxv array"
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:1970
#, no-wrap
msgid "B<NT_GWINDOWS>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:1973
msgid "gwindows struct"
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:1973
#, no-wrap
msgid "B<NT_ASRS>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:1976
msgid "asrset struct"
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:1976
#, no-wrap
msgid "B<NT_PSTATUS>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:1979
msgid "pstatus struct"
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:1979
#, no-wrap
msgid "B<NT_PSINFO>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:1982
msgid "psinfo struct"
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:1982
#, no-wrap
msgid "B<NT_PRCRED>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:1985
msgid "prcred struct"
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:1985
#, no-wrap
msgid "B<NT_UTSNAME>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:1988
msgid "utsname struct"
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:1988
#, no-wrap
msgid "B<NT_LWPSTATUS>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:1991
msgid "lwpstatus struct"
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:1991
#, no-wrap
msgid "B<NT_LWPSINFO>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:1994
msgid "lwpinfo struct"
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:1994
#, no-wrap
msgid "B<NT_PRFPXREG>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:1997
msgid "fprxregset struct"
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:1997
#, no-wrap
msgid "B<NT_SIGINFO>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:2000
msgid "siginfo_t (size might increase over time)"
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:2000
#, no-wrap
msgid "B<NT_FILE>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:2003
msgid "Contains information about mapped files"
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:2003
#, no-wrap
msgid "B<NT_PRXFPREG>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:2006
msgid "user_fxsr_struct"
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:2006
#, no-wrap
msgid "B<NT_PPC_VMX>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:2009
msgid "PowerPC Altivec/VMX registers"
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:2009
#, no-wrap
msgid "B<NT_PPC_SPE>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:2012
msgid "PowerPC SPE/EVR registers"
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:2012
#, no-wrap
msgid "B<NT_PPC_VSX>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:2015
msgid "PowerPC VSX registers"
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:2015
#, no-wrap
msgid "B<NT_386_TLS>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:2018
msgid "i386 TLS slots (struct user_desc)"
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:2018
#, no-wrap
msgid "B<NT_386_IOPERM>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:2021
msgid "x86 io permission bitmap (1=deny)"
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:2021
#, no-wrap
msgid "B<NT_X86_XSTATE>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:2024
msgid "x86 extended state using xsave"
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:2024
#, no-wrap
msgid "B<NT_S390_HIGH_GPRS>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:2027
msgid "s390 upper register halves"
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:2027
#, no-wrap
msgid "B<NT_S390_TIMER>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:2030
msgid "s390 timer register"
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:2030
#, no-wrap
msgid "B<NT_S390_TODCMP>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:2033
msgid "s390 time-of-day (TOD) clock comparator register"
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:2033
#, no-wrap
msgid "B<NT_S390_TODPREG>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:2036
msgid "s390 time-of-day (TOD) programmable register"
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:2036
#, no-wrap
msgid "B<NT_S390_CTRS>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:2039
msgid "s390 control registers"
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:2039
#, no-wrap
msgid "B<NT_S390_PREFIX>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:2042
msgid "s390 prefix register"
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:2042
#, no-wrap
msgid "B<NT_S390_LAST_BREAK>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:2045
msgid "s390 breaking event address"
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:2045
#, no-wrap
msgid "B<NT_S390_SYSTEM_CALL>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:2048
msgid "s390 system call restart data"
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:2048
#, no-wrap
msgid "B<NT_S390_TDB>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:2051
msgid "s390 transaction diagnostic block"
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:2051
#, no-wrap
msgid "B<NT_ARM_VFP>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:2054
msgid "ARM VFP/NEON registers"
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:2054
#, no-wrap
msgid "B<NT_ARM_TLS>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:2057
msgid "ARM TLS register"
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:2057
#, no-wrap
msgid "B<NT_ARM_HW_BREAK>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:2060
msgid "ARM hardware breakpoint registers"
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:2060
#, no-wrap
msgid "B<NT_ARM_HW_WATCH>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:2063
msgid "ARM hardware watchpoint registers"
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:2063
#, no-wrap
msgid "B<NT_ARM_SYSTEM_CALL>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:2066
msgid "ARM system call number"
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:2068
#, no-wrap
msgid "B<n_name = GNU>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:2071
msgid "Extensions used by the GNU tool chain."
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:2072
#, no-wrap
msgid "B<NT_GNU_ABI_TAG>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:2076
msgid ""
"Operating system (OS) ABI information.  The desc field will be 4 words:"
msgstr ""

#. type: IP
#: man-pages/man5/elf.5:2079 man-pages/man5/elf.5:2082
#: man-pages/man5/elf.5:2084 man-pages/man5/elf.5:2086
#: man-pages/man5/elf.5:2097 man-pages/man5/elf.5:2099
#, no-wrap
msgid "\\(bu"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:2082
msgid ""
"word 0: OS descriptor (B<ELF_NOTE_OS_LINUX>, B<ELF_NOTE_OS_GNU>, and so on)`"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:2084
msgid "word 1: major version of the ABI"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:2086
msgid "word 2: minor version of the ABI"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:2088
msgid "word 3: subminor version of the ABI"
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:2090
#, no-wrap
msgid "B<NT_GNU_HWCAP>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:2094
msgid "Synthetic hwcap information.  The desc field begins with two words:"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:2099
msgid "word 0: number of entries"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:2101
msgid "word 1: bit mask of enabled entries"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:2107
msgid ""
"Then follow variable-length entries, one byte followed by a null-terminated "
"hwcap name string.  The byte gives the bit number to test if enabled, (1U "
"E<lt>E<lt> bit) & bit mask."
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:2107
#, no-wrap
msgid "B<NT_GNU_BUILD_ID>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:2114
msgid ""
"Unique build ID as generated by the GNU B<ld>(1)  B<--build-id> option.  The"
" desc consists of any nonzero number of bytes."
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:2114
#, no-wrap
msgid "B<NT_GNU_GOLD_VERSION>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:2117
msgid "The desc contains the GNU Gold linker version used."
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:2118
#, no-wrap
msgid "B<Default/unknown namespace (e_type != ET_CORE)>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:2123
msgid ""
"These are used when the namespace is the default (i.e., I<n_namesz> will be "
"set to 0), or a fallback when the namespace is unknown."
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:2124
#, no-wrap
msgid "B<NT_VERSION>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:2128
msgid "A version string of some sort."
msgstr ""

#. type: TP
#: man-pages/man5/elf.5:2128
#, no-wrap
msgid "B<NT_ARCH>"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:2131
msgid "Architecture information."
msgstr ""

#.  OpenBSD
#.  ELF support first appeared in
#.  OpenBSD 1.2,
#.  although not all supported platforms use it as the native
#.  binary file format.
#. type: Plain text
#: man-pages/man5/elf.5:2144
msgid ""
"ELF first appeared in System V.  The ELF format is an adopted standard."
msgstr ""

#.  .SH AUTHORS
#.  The original version of this manual page was written by
#.  .An Jeroen Ruigrok van der Werven
#.  .Aq asmodai@FreeBSD.org
#.  with inspiration from BSDi's
#.  .Bsx
#.  .Nm elf
#.  man page.
#. type: Plain text
#: man-pages/man5/elf.5:2162
msgid ""
"The extensions for I<e_phnum>, I<e_shnum> and I<e_strndx> respectively are "
"Linux extensions.  Sun, BSD and AMD64 also support them; for further "
"information, look under SEE ALSO."
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:2177
msgid ""
"B<as>(1), B<elfedit>(1), B<gdb>(1), B<ld>(1), B<nm>(1), B<objdump>(1), "
"B<patchelf>(1), B<readelf>(1), B<size>(1), B<strings>(1), B<strip>(1), "
"B<execve>(2), B<dl_iterate_phdr>(3), B<core>(5)"
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:2180
msgid "Hewlett-Packard, I<Elf-64 Object File Format>."
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:2183
msgid "Santa Cruz Operation, I<System V Application Binary Interface>."
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:2187
msgid ""
"UNIX System Laboratories, \"Object Files\", I<Executable and Linking Format "
"(ELF)>."
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:2190
msgid "Sun Microsystems, I<Linker and Libraries Guide>."
msgstr ""

#. type: Plain text
#: man-pages/man5/elf.5:2193
msgid ""
"AMD64 ABI Draft, I<System V Application Binary Interface AMD64 Architecture "
"Processor Supplement>."
msgstr ""

#. type: TH
#: man-pages/man3/err.3:39
#, no-wrap
msgid "ERR"
msgstr ""

#. type: Plain text
#: man-pages/man3/err.3:42
msgid ""
"err, verr, errx, verrx, warn, vwarn, warnx, vwarnx - formatted error "
"messages"
msgstr ""

#. type: Plain text
#: man-pages/man3/err.3:45
#, no-wrap
msgid "B<#include E<lt>err.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/err.3:47
#, no-wrap
msgid "B<void err(int >I<eval>B<, const char *>I<fmt>B<, ...);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/err.3:49
#, no-wrap
msgid "B<void errx(int >I<eval>B<, const char *>I<fmt>B<, ...);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/err.3:51
#, no-wrap
msgid "B<void warn(const char *>I<fmt>B<, ...);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/err.3:53
#, no-wrap
msgid "B<void warnx(const char *>I<fmt>B<, ...);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/err.3:55
#, no-wrap
msgid "B<#include E<lt>stdarg.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/err.3:57
#, no-wrap
msgid ""
"B<void verr(int >I<eval>B<, const char *>I<fmt>B<, va_list >I<args>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/err.3:59
#, no-wrap
msgid ""
"B<void verrx(int >I<eval>B<, const char *>I<fmt>B<, va_list >I<args>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/err.3:61
#, no-wrap
msgid "B<void vwarn(const char *>I<fmt>B<, va_list >I<args>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/err.3:63
#, no-wrap
msgid "B<void vwarnx(const char *>I<fmt>B<, va_list >I<args>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/err.3:79
msgid ""
"The B<err>()  and B<warn>()  family of functions display a formatted error "
"message on the standard error output.  In all cases, the last component of "
"the program name, a colon character, and a space are output.  If the I<fmt> "
"argument is not NULL, the B<printf>(3)-like formatted error message is "
"output.  The output is terminated by a newline character."
msgstr ""

#. type: Plain text
#: man-pages/man3/err.3:94
msgid ""
"The B<err>(), B<verr>(), B<warn>(), and B<vwarn>()  functions append an "
"error message obtained from B<strerror>(3)  based on the global variable "
"I<errno>, preceded by another colon and space unless the I<fmt> argument is "
"NULL."
msgstr ""

#. type: Plain text
#: man-pages/man3/err.3:100
msgid ""
"The B<errx>()  and B<warnx>()  functions do not append an error message."
msgstr ""

#. type: Plain text
#: man-pages/man3/err.3:109
msgid ""
"The B<err>(), B<verr>(), B<errx>(), and B<verrx>()  functions do not return,"
" but exit with the value of the argument I<eval>."
msgstr ""

#. type: tbl table
#: man-pages/man3/err.3:120
#, no-wrap
msgid ""
"B<err>(),\n"
"B<errx>(),\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/err.3:120 man-pages/man3/err.3:123 man-pages/man3/err.3:126
#, no-wrap
msgid ".br\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/err.3:123
#, no-wrap
msgid ""
"B<warn>(),\n"
"B<warnx>(),\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/err.3:126
#, no-wrap
msgid ""
"B<verr>(),\n"
"B<verrx>(),\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/err.3:129
#, no-wrap
msgid ""
"B<vwarn>(),\n"
"B<vwarnx>()"
msgstr ""

#. type: tbl table
#: man-pages/man3/err.3:129
#, no-wrap
msgid "MT-Safe locale"
msgstr ""

#.  .SH HISTORY
#.  The
#.  .BR err ()
#.  and
#.  .BR warn ()
#.  functions first appeared in
#.  4.4BSD.
#. type: Plain text
#: man-pages/man3/err.3:141
msgid "These functions are nonstandard BSD extensions."
msgstr ""

#. type: Plain text
#: man-pages/man3/err.3:145
msgid "Display the current I<errno> information string and exit:"
msgstr ""

#. type: Plain text
#: man-pages/man3/err.3:154
#, no-wrap
msgid ""
"p = malloc(size);\n"
"if (p == NULL)\n"
"    err(1, NULL);\n"
"fd = open(file_name, O_RDONLY, 0);\n"
"if (fd == -1)\n"
"    err(1, \"%s\", file_name);\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/err.3:158
msgid "Display an error message and exit:"
msgstr ""

#. type: Plain text
#: man-pages/man3/err.3:163
#, no-wrap
msgid ""
"if (tm.tm_hour E<lt> START_TIME)\n"
"    errx(1, \"too early, wait until %s\", start_time_string);\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/err.3:167
msgid "Warn of an error:"
msgstr ""

#. type: Plain text
#: man-pages/man3/err.3:177
#, no-wrap
msgid ""
"fd = open(raw_device, O_RDONLY, 0);\n"
"if (fd == -1)\n"
"    warnx(\"%s: %s: trying the block device\",\n"
"            raw_device, strerror(errno));\n"
"fd = open(block_device, O_RDONLY, 0);\n"
"if (fd == -1)\n"
"    err(1, \"%s\", block_device);\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/err.3:184
msgid "B<error>(3), B<exit>(3), B<perror>(3), B<printf>(3), B<strerror>(3)"
msgstr ""

#. type: TH
#: man-pages/man3/exp2.3:36
#, no-wrap
msgid "EXP2"
msgstr ""

#. type: Plain text
#: man-pages/man3/exp2.3:39
msgid "exp2, exp2f, exp2l - base-2 exponential function"
msgstr ""

#. type: Plain text
#: man-pages/man3/exp2.3:42
#, no-wrap
msgid "B<#include E<lt>math.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/exp2.3:46
#, no-wrap
msgid ""
"B<double exp2(double >I<x>B<);>\n"
"B<float exp2f(float >I<x>B<);>\n"
"B<long double exp2l(long double >I<x>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/exp2.3:49
msgid "Link with I<-lm>."
msgstr ""

#. type: Plain text
#: man-pages/man3/exp2.3:53
msgid ""
"Feature Test Macro Requirements for glibc (see B<feature_test_macros>(7)):"
msgstr ""

#. type: Plain text
#: man-pages/man3/exp2.3:59
msgid "B<exp2>(), B<exp2f>(), B<exp2l>():"
msgstr ""

#. type: Plain text
#: man-pages/man3/exp2.3:61
msgid "_ISOC99_SOURCE || _POSIX_C_SOURCE\\ E<gt>=\\ 200112L"
msgstr ""

#. type: Plain text
#: man-pages/man3/exp2.3:66
msgid "These functions return the value of 2 raised to the power of I<x>."
msgstr ""

#. type: Plain text
#: man-pages/man3/exp2.3:69
msgid ""
"On success, these functions return the base-2 exponential value of I<x>."
msgstr ""

#. type: Plain text
#: man-pages/man3/exp2.3:73
msgid ""
"For various special cases, including the handling of infinity and NaN, as "
"well as overflows and underflows, see B<exp>(3)."
msgstr ""

#. type: Plain text
#: man-pages/man3/exp2.3:78
msgid ""
"See B<math_error>(7)  for information on how to determine whether an error "
"has occurred when calling these functions."
msgstr ""

#. type: Plain text
#: man-pages/man3/exp2.3:81
msgid ""
"For a discussion of the errors that can occur for these functions, see "
"B<exp>(3)."
msgstr ""

#. type: Plain text
#: man-pages/man3/exp2.3:83
msgid "These functions first appeared in glibc in version 2.1."
msgstr ""

#. type: tbl table
#: man-pages/man3/exp2.3:95
#, no-wrap
msgid ""
"B<exp2>(),\n"
"B<exp2f>(),\n"
"B<exp2l>()"
msgstr ""

#. type: Plain text
#: man-pages/man3/exp2.3:99
msgid "C99, POSIX.1-2001, POSIX.1-2008."
msgstr ""

#. type: Plain text
#: man-pages/man3/exp2.3:104
msgid "The variant returning I<double> also conforms to SVr4, 4.3BSD."
msgstr ""

#. type: Plain text
#: man-pages/man3/exp2.3:109
msgid "B<cbrt>(3), B<cexp2>(3), B<exp>(3), B<exp10>(3), B<sqrt>(3)"
msgstr ""

#. type: TH
#: man-pages/man3/ecvt.3:32
#, no-wrap
msgid "ECVT"
msgstr ""

#. type: TH
#: man-pages/man3/ecvt.3:32
#, no-wrap
msgid "2016-03-15"
msgstr ""

#. type: Plain text
#: man-pages/man3/ecvt.3:35
msgid "ecvt, fcvt - convert a floating-point number to a string"
msgstr ""

#. type: Plain text
#: man-pages/man3/ecvt.3:37
msgid "B<#include E<lt>stdlib.hE<gt>>"
msgstr ""

#. type: Plain text
#: man-pages/man3/ecvt.3:40
msgid ""
"B<char *ecvt(double >I<number>B<, int >I<ndigits>B<, int *>I<decpt>B<,> "
"B<int *>I<sign>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man3/ecvt.3:43
msgid ""
"B<char *fcvt(double >I<number>B<, int >I<ndigits>B<, int *>I<decpt>B<,> "
"B<int *>I<sign>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man3/ecvt.3:51
msgid "B<ecvt>(), B<fcvt>():"
msgstr ""

#. type: TP
#: man-pages/man3/ecvt.3:54
#, no-wrap
msgid "Since glibc 2.12:"
msgstr ""

#. type: Plain text
#: man-pages/man3/ecvt.3:60
#, no-wrap
msgid ""
"(_XOPEN_SOURCE\\ E<gt>=\\ 500) ! (_POSIX_C_SOURCE\\ E<gt>=\\ 200112L)\n"
"    || /* Glibc since 2.19: */ _DEFAULT_SOURCE\n"
"    || /* Glibc versions E<lt>= 2.19: */ _SVID_SOURCE\n"
msgstr ""

#. type: TP
#: man-pages/man3/ecvt.3:61
#, no-wrap
msgid "Before glibc 2.12:"
msgstr ""

#.     || _XOPEN_SOURCE\ &&\ _XOPEN_SOURCE_EXTENDED
#. type: Plain text
#: man-pages/man3/ecvt.3:65
msgid "_SVID_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 500"
msgstr ""

#. type: Plain text
#: man-pages/man3/ecvt.3:91
msgid ""
"The B<ecvt>()  function converts I<number> to a null-terminated string of "
"I<ndigits> digits (where I<ndigits> is reduced to a system-specific limit "
"determined by the precision of a I<double>), and returns a pointer to the "
"string.  The high-order digit is nonzero, unless I<number> is zero.  The low"
" order digit is rounded.  The string itself does not contain a decimal "
"point; however, the position of the decimal point relative to the start of "
"the string is stored in I<*decpt>.  A negative value for I<*decpt> means "
"that the decimal point is to the left of the start of the string.  If the "
"sign of I<number> is negative, I<*sign> is set to a nonzero value, otherwise"
" it is set to 0.  If I<number> is zero, it is unspecified whether I<*decpt> "
"is 0 or 1."
msgstr ""

#. type: Plain text
#: man-pages/man3/ecvt.3:98
msgid ""
"The B<fcvt>()  function is identical to B<ecvt>(), except that I<ndigits> "
"specifies the number of digits after the decimal point."
msgstr ""

#. type: Plain text
#: man-pages/man3/ecvt.3:109
msgid ""
"Both the B<ecvt>()  and B<fcvt>()  functions return a pointer to a static "
"string containing the ASCII representation of I<number>.  The static string "
"is overwritten by each call to B<ecvt>()  or B<fcvt>()."
msgstr ""

#. type: tbl table
#: man-pages/man3/ecvt.3:119
#, no-wrap
msgid "B<ecvt>()"
msgstr ""

#. type: tbl table
#: man-pages/man3/ecvt.3:119
#, no-wrap
msgid "MT-Unsafe race:ecvt"
msgstr ""

#. type: tbl table
#: man-pages/man3/ecvt.3:122
#, no-wrap
msgid "B<fcvt>()"
msgstr ""

#. type: tbl table
#: man-pages/man3/ecvt.3:122
#, no-wrap
msgid "MT-Unsafe race:fcvt"
msgstr ""

#. type: Plain text
#: man-pages/man3/ecvt.3:136
msgid ""
"SVr2; marked as LEGACY in POSIX.1-2001.  POSIX.1-2008 removes the "
"specifications of B<ecvt>()  and B<fcvt>(), recommending the use of "
"B<sprintf>(3)  instead (though B<snprintf>(3)  may be preferable)."
msgstr ""

#.  Linux libc4 and libc5 specified the type of
#.  .I ndigits
#.  as
#.  .IR size_t .
#. type: Plain text
#: man-pages/man3/ecvt.3:142
msgid "Not all locales use a point as the radix character (\"decimal point\")."
msgstr ""

#. type: Plain text
#: man-pages/man3/ecvt.3:147
msgid "B<ecvt_r>(3), B<gcvt>(3), B<qecvt>(3), B<setlocale>(3), B<sprintf>(3)"
msgstr ""

#. type: TH
#: man-pages/man3/end.3:26
#, no-wrap
msgid "END"
msgstr ""

#. type: TH
#: man-pages/man3/end.3:26
#, no-wrap
msgid "GNU"
msgstr ""

#. type: Plain text
#: man-pages/man3/end.3:29
msgid "etext, edata, end - end of program segments"
msgstr ""

#. type: Plain text
#: man-pages/man3/end.3:34
#, no-wrap
msgid ""
"B<extern>I< etext>B<;>\n"
"B<extern>I< edata>B<;>\n"
"B<extern>I< end>B<;>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/end.3:38
msgid ""
"The addresses of these symbols indicate the end of various program segments:"
msgstr ""

#. type: TP
#: man-pages/man3/end.3:38
#, no-wrap
msgid "I<etext>"
msgstr ""

#. type: Plain text
#: man-pages/man3/end.3:42
msgid ""
"This is the first address past the end of the text segment (the program "
"code)."
msgstr ""

#. type: TP
#: man-pages/man3/end.3:42
#, no-wrap
msgid "I<edata>"
msgstr ""

#. type: Plain text
#: man-pages/man3/end.3:46
msgid ""
"This is the first address past the end of the initialized data segment."
msgstr ""

#. type: TP
#: man-pages/man3/end.3:46
#, no-wrap
msgid "I<end>"
msgstr ""

#. type: Plain text
#: man-pages/man3/end.3:50
msgid ""
"This is the first address past the end of the uninitialized data segment "
"(also known as the BSS segment)."
msgstr ""

#. type: Plain text
#: man-pages/man3/end.3:53
msgid ""
"Although these symbols have long been provided on most UNIX systems, they "
"are not standardized; use with caution."
msgstr ""

#. type: Plain text
#: man-pages/man3/end.3:56
msgid ""
"The program must explicitly declare these symbols; they are not defined in "
"any header file."
msgstr ""

#. type: Plain text
#: man-pages/man3/end.3:64
msgid ""
"On some systems the names of these symbols are preceded by underscores, "
"thus: I<_etext>, I<_edata>, and I<_end>.  These symbols are also defined for"
" programs compiled on Linux."
msgstr ""

#. type: Plain text
#: man-pages/man3/end.3:76
msgid ""
"At the start of program execution, the program break will be somewhere near "
"I<&end> (perhaps at the start of the following page).  However, the break "
"will change as memory is allocated via B<brk>(2)  or B<malloc>(3).  Use "
"B<sbrk>(2)  with an argument of zero to find the current value of the "
"program break."
msgstr ""

#. type: Plain text
#: man-pages/man3/end.3:78
msgid "When run, the program below produces output such as the following:"
msgstr ""

#. type: Plain text
#: man-pages/man3/end.3:86
#, no-wrap
msgid ""
"$B< ./a.out>\n"
"First address past:\n"
"    program text (etext)       0x8048568\n"
"    initialized data (edata)   0x804a01c\n"
"    uninitialized data (end)   0x804a024\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/end.3:96
#, no-wrap
msgid ""
"extern char etext, edata, end; /* The symbols must have some type,\n"
"                                   or \"gcc -Wall\" complains */\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/end.3:104
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    printf(\"First address past:\\en\");\n"
"    printf(\"    program text (etext)      %10p\\en\", &etext);\n"
"    printf(\"    initialized data (edata)  %10p\\en\", &edata);\n"
"    printf(\"    uninitialized data (end)  %10p\\en\", &end);\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/end.3:112
msgid "B<objdump>(1), B<readelf>(1), B<sbrk>(2), B<elf>(5)"
msgstr ""

#. type: TH
#: man-pages/man3/exit.3:29
#, no-wrap
msgid "EXIT"
msgstr ""

#. type: Plain text
#: man-pages/man3/exit.3:32
msgid "exit - cause normal process termination"
msgstr ""

#. type: Plain text
#: man-pages/man3/exit.3:35
#, no-wrap
msgid "B<#include E<lt>stdlib.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/exit.3:37
#, no-wrap
msgid "B<void exit(int >I<status>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/exit.3:45
msgid ""
"The B<exit>()  function causes normal process termination and the value of "
"I<status & 0377> is returned to the parent (see B<wait>(2))."
msgstr ""

#. type: Plain text
#: man-pages/man3/exit.3:72
msgid ""
"All functions registered with B<atexit>(3)  and B<on_exit>(3)  are called, "
"in the reverse order of their registration.  (It is possible for one of "
"these functions to use B<atexit>(3)  or B<on_exit>(3)  to register an "
"additional function to be executed during exit processing; the new "
"registration is added to the front of the list of functions that remain to "
"be called.)  If one of these functions does not return (e.g., it calls "
"B<_exit>(2), or kills itself with a signal), then none of the remaining "
"functions is called, and further exit processing (in particular, flushing of"
" B<stdio>(3)  streams) is abandoned.  If a function has been registered "
"multiple times using B<atexit>(3)  or B<on_exit>(3), then it is called as "
"many times as it was registered."
msgstr ""

#. type: Plain text
#: man-pages/man3/exit.3:79
msgid ""
"All open B<stdio>(3)  streams are flushed and closed.  Files created by "
"B<tmpfile>(3)  are removed."
msgstr ""

#. type: Plain text
#: man-pages/man3/exit.3:86
msgid ""
"The C standard specifies two constants, B<EXIT_SUCCESS> and B<EXIT_FAILURE>,"
" that may be passed to B<exit>()  to indicate successful or unsuccessful "
"termination, respectively."
msgstr ""

#. type: Plain text
#: man-pages/man3/exit.3:90
msgid "The B<exit>()  function does not return."
msgstr ""

#. type: tbl table
#: man-pages/man3/exit.3:100
#, no-wrap
msgid "B<exit>()"
msgstr ""

#. type: tbl table
#: man-pages/man3/exit.3:100
#, no-wrap
msgid "MT-Unsafe race:exit"
msgstr ""

#. type: Plain text
#: man-pages/man3/exit.3:107
msgid ""
"The B<exit>()  function uses a global variable that is not protected, so it "
"is not thread-safe."
msgstr ""

#. type: Plain text
#: man-pages/man3/exit.3:109
msgid "POSIX.1-2001, POSIX.1-2008, C89, C99, SVr4, 4.3BSD."
msgstr ""

#. type: Plain text
#: man-pages/man3/exit.3:125
msgid ""
"The behavior is undefined if one of the functions registered using "
"B<atexit>(3)  and B<on_exit>(3)  calls either B<exit>()  or B<longjmp>(3).  "
"Note that a call to B<execve>(2)  removes registrations created using "
"B<atexit>(3)  and B<on_exit>(3)."
msgstr ""

#. type: Plain text
#: man-pages/man3/exit.3:134
msgid ""
"The use of B<EXIT_SUCCESS> and B<EXIT_FAILURE> is slightly more portable (to"
" non-UNIX environments) than the use of 0 and some nonzero value like 1 or "
"-1.  In particular, VMS uses a different convention."
msgstr ""

#. type: Plain text
#: man-pages/man3/exit.3:139
msgid ""
"BSD has attempted to standardize exit codes (which some C libraries such as "
"the GNU C library have also adopted); see the file I<E<lt>sysexits.hE<gt>>."
msgstr ""

#. type: Plain text
#: man-pages/man3/exit.3:145
msgid ""
"After B<exit>(), the exit status must be transmitted to the parent process."
"  There are three cases:"
msgstr ""

#. type: Plain text
#: man-pages/man3/exit.3:153
msgid ""
"If the parent has set B<SA_NOCLDWAIT>, or has set the B<SIGCHLD> handler to "
"B<SIG_IGN>, the status is discarded and the child dies immediately."
msgstr ""

#. type: Plain text
#: man-pages/man3/exit.3:156
msgid ""
"If the parent was waiting on the child, it is notified of the exit status "
"and the child dies immediately."
msgstr ""

#. type: Plain text
#: man-pages/man3/exit.3:166
msgid ""
"Otherwise, the child becomes a \"zombie\" process: most of the process "
"resources are recycled, but a slot containing minimal information about the "
"child process (termination status, resource usage statistics) is retained in"
" process table.  This allows the parent to subsequently use B<waitpid>(2)  "
"(or similar) to learn the termination status of the child; at that point the"
" zombie process slot is released."
msgstr ""

#. type: Plain text
#: man-pages/man3/exit.3:177
msgid ""
"If the implementation supports the B<SIGCHLD> signal, this signal is sent to"
" the parent.  If the parent has set B<SA_NOCLDWAIT>, it is undefined whether"
" a B<SIGCHLD> signal is sent."
msgstr ""

#. type: SS
#: man-pages/man3/exit.3:177
#, no-wrap
msgid "Signals sent to other processes"
msgstr ""

#. type: Plain text
#: man-pages/man3/exit.3:186
msgid ""
"If the exiting process is a session leader and its controlling terminal is "
"the controlling terminal of the session, then each process in the foreground"
" process group of this controlling terminal is sent a B<SIGHUP> signal, and "
"the terminal is disassociated from this session, allowing it to be acquired "
"by a new controlling process."
msgstr ""

#. type: Plain text
#: man-pages/man3/exit.3:198
msgid ""
"If the exit of the process causes a process group to become orphaned, and if"
" any member of the newly orphaned process group is stopped, then a B<SIGHUP>"
" signal followed by a B<SIGCONT> signal will be sent to each process in this"
" process group.  See B<setpgid>(2)  for an explanation of orphaned process "
"groups."
msgstr ""

#. type: Plain text
#: man-pages/man3/exit.3:208
msgid ""
"Except in the above cases, where the signalled processes may be children of "
"the terminating process, termination of a process does I<not> in general "
"cause a signal to be sent to children of that process.  However, a process "
"can use the B<prctl>(2)  B<PR_SET_PDEATHSIG> operation to arrange that it "
"receives a signal if its parent terminates."
msgstr ""

#. type: Plain text
#: man-pages/man3/exit.3:215
msgid ""
"B<_exit>(2), B<get_robust_list>(2), B<setpgid>(2), B<wait>(2), B<atexit>(3),"
" B<on_exit>(3), B<tmpfile>(3)"
msgstr ""

#. type: TH
#: man-pages/man3/endian.3:28
#, no-wrap
msgid "ENDIAN"
msgstr ""

#. type: Plain text
#: man-pages/man3/endian.3:33
msgid ""
"htobe16, htole16, be16toh, le16toh, htobe32, htole32, be32toh, le32toh, "
"htobe64, htole64, be64toh, le64toh - convert values between host and big"
"-/little-endian byte order"
msgstr ""

#. type: Plain text
#: man-pages/man3/endian.3:36
#, no-wrap
msgid "B<#include E<lt>endian.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/endian.3:41
#, no-wrap
msgid ""
"B<uint16_t htobe16(uint16_t >I<host_16bits>B<);>\n"
"B<uint16_t htole16(uint16_t >I<host_16bits>B<);>\n"
"B<uint16_t be16toh(uint16_t >I<big_endian_16bits>B<);>\n"
"B<uint16_t le16toh(uint16_t >I<little_endian_16bits>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/endian.3:46
#, no-wrap
msgid ""
"B<uint32_t htobe32(uint32_t >I<host_32bits>B<);>\n"
"B<uint32_t htole32(uint32_t >I<host_32bits>B<);>\n"
"B<uint32_t be32toh(uint32_t >I<big_endian_32bits>B<);>\n"
"B<uint32_t le32toh(uint32_t >I<little_endian_32bits>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/endian.3:51
#, no-wrap
msgid ""
"B<uint64_t htobe64(uint64_t >I<host_64bits>B<);>\n"
"B<uint64_t htole64(uint64_t >I<host_64bits>B<);>\n"
"B<uint64_t be64toh(uint64_t >I<big_endian_64bits>B<);>\n"
"B<uint64_t le64toh(uint64_t >I<little_endian_64bits>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/endian.3:70
msgid ""
"B<htobe16>(), B<htole16>(), B<be16toh>(), B<le16toh>(), B<htobe32>(), "
"B<htole32>(), B<be32toh>(), B<le32toh>(), B<htobe64>(), B<htole64>(), "
"B<be64toh>(), B<le64toh>():"
msgstr ""

#. type: Plain text
#: man-pages/man3/endian.3:75
#, no-wrap
msgid ""
"    Since glibc 2.19:\n"
"        _DEFAULT_SOURCE\n"
"    In glibc up to and including 2.19:\n"
"        _BSD_SOURCE\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/endian.3:80
msgid ""
"These functions convert the byte encoding of integer values from the byte "
"order that the current CPU (the \"host\") uses, to and from little-endian "
"and big-endian byte order."
msgstr ""

#. type: Plain text
#: man-pages/man3/endian.3:85
msgid ""
"The number, I<nn>, in the name of each function indicates the size of "
"integer handled by the function, either 16, 32, or 64 bits."
msgstr ""

#. type: Plain text
#: man-pages/man3/endian.3:88
msgid ""
"The functions with names of the form \"htobeI<nn>\" convert from host byte "
"order to big-endian order."
msgstr ""

#. type: Plain text
#: man-pages/man3/endian.3:91
msgid ""
"The functions with names of the form \"htoleI<nn>\" convert from host byte "
"order to little-endian order."
msgstr ""

#. type: Plain text
#: man-pages/man3/endian.3:94
msgid ""
"The functions with names of the form \"beI<nn>toh\" convert from big-endian "
"order to host byte order."
msgstr ""

#. type: Plain text
#: man-pages/man3/endian.3:97
msgid ""
"The functions with names of the form \"leI<nn>toh\" convert from little-"
"endian order to host byte order."
msgstr ""

#. type: Plain text
#: man-pages/man3/endian.3:99
msgid "These functions were added to glibc in version 2.9."
msgstr ""

#. type: Plain text
#: man-pages/man3/endian.3:114
msgid ""
"These functions are nonstandard.  Similar functions are present on the BSDs,"
" where the required header file is I<E<lt>sys/endian.hE<gt>> instead of "
"I<E<lt>endian.hE<gt>>.  Unfortunately, NetBSD, FreeBSD, and glibc haven't "
"followed the original OpenBSD naming convention for these functions, whereby"
" the I<nn> component always appears at the end of the function name (thus, "
"for example, in NetBSD, FreeBSD, and glibc, the equivalent of OpenBSDs "
"\"betoh32\" is \"be32toh\")."
msgstr ""

#. type: Plain text
#: man-pages/man3/endian.3:122
msgid ""
"These functions are similar to the older B<byteorder>(3)  family of "
"functions.  For example, B<be32toh>()  is identical to B<ntohl>()."
msgstr ""

#. type: Plain text
#: man-pages/man3/endian.3:130
msgid ""
"The advantage of the B<byteorder>(3)  functions is that they are standard "
"functions available on all UNIX systems.  On the other hand, the fact that "
"they were designed for use in the context of TCP/IP means that they lack the"
" 64-bit and little-endian variants described in this page."
msgstr ""

#. type: Plain text
#: man-pages/man3/endian.3:137
msgid ""
"The program below display the results of converting an integer from host "
"byte order to both little-endian and big-endian byte order.  Since host byte"
" order is either little-endian or big-endian, only one of these conversions "
"will have an effect.  When we run this program on a little-endian system "
"such as x86-32, we see the following:"
msgstr ""

#. type: Plain text
#: man-pages/man3/endian.3:144
#, no-wrap
msgid ""
"$ B<./a.out>\n"
"x.u32 = 0x44332211\n"
"htole32(x.u32) = 0x44332211\n"
"htobe32(x.u32) = 0x11223344\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/endian.3:153
#, no-wrap
msgid ""
"#include E<lt>endian.hE<gt>\n"
"#include E<lt>stdint.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/endian.3:161
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    union {\n"
"        uint32_t u32;\n"
"        uint8_t arr[4];\n"
"    } x;\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/endian.3:166
#, no-wrap
msgid ""
"    x.arr[0] = 0x11;\t/* Lowest-address byte */\n"
"    x.arr[1] = 0x22;\n"
"    x.arr[2] = 0x33;\n"
"    x.arr[3] = 0x44;\t/* Highest-address byte */\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/endian.3:170
#, no-wrap
msgid ""
"    printf(\"x.u32 = 0x%x\\en\", x.u32);\n"
"    printf(\"htole32(x.u32) = 0x%x\\en\", htole32(x.u32));\n"
"    printf(\"htobe32(x.u32) = 0x%x\\en\", htobe32(x.u32));\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/endian.3:176
msgid "B<bswap>(3), B<byteorder>(3)"
msgstr ""

#. type: TH
#: man-pages/man3/encrypt.3:30
#, no-wrap
msgid "ENCRYPT"
msgstr ""

#. type: Plain text
#: man-pages/man3/encrypt.3:33
msgid "encrypt, setkey, encrypt_r, setkey_r - encrypt 64-bit messages"
msgstr ""

#. type: Plain text
#: man-pages/man3/encrypt.3:37
#, no-wrap
msgid ""
"B<#define _XOPEN_SOURCE>       /* See feature_test_macros(7) */\n"
"B<#include E<lt>unistd.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/encrypt.3:39
#, no-wrap
msgid "B<void encrypt(char >I<block>B<[64], int >I<edflag>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/encrypt.3:42
#, no-wrap
msgid ""
"B<#define _XOPEN_SOURCE>       /* See feature_test_macros(7) */\n"
"B<#include E<lt>stdlib.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/encrypt.3:44
#, no-wrap
msgid "B<void setkey(const char *>I<key>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/encrypt.3:47
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>         /* See feature_test_macros(7) */\n"
"B<#include E<lt>crypt.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/encrypt.3:51
#, no-wrap
msgid ""
"B<void setkey_r(const char *>I<key>B<, struct crypt_data *>I<data>B<);>\n"
"B<void encrypt_r(char *>I<block>B<, int >I<edflag>B<, struct crypt_data *>I<data>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/encrypt.3:54
msgid "Each of these requires linking with I<-lcrypt>."
msgstr ""

#. type: Plain text
#: man-pages/man3/encrypt.3:66
msgid ""
"These functions encrypt and decrypt 64-bit messages.  The B<setkey>()  "
"function sets the key used by B<encrypt>().  The I<key> argument used here "
"is an array of 64 bytes, each of which has numerical value 1 or 0.  The "
"bytes key[n] where n=8*i-1 are ignored, so that the effective key length is "
"56 bits."
msgstr ""

#. type: Plain text
#: man-pages/man3/encrypt.3:78
msgid ""
"The B<encrypt>()  function modifies the passed buffer, encoding if I<edflag>"
" is 0, and decoding if 1 is being passed.  Like the I<key> argument, also "
"I<block> is a bit vector representation of the actual value that is encoded."
"  The result is returned in that same vector."
msgstr ""

#. type: Plain text
#: man-pages/man3/encrypt.3:88
msgid ""
"These two functions are not reentrant, that is, the key data is kept in "
"static storage.  The functions B<setkey_r>()  and B<encrypt_r>()  are the "
"reentrant versions.  They use the following structure to hold the key data:"
msgstr ""

#. type: Plain text
#: man-pages/man3/encrypt.3:103
#, no-wrap
msgid ""
"struct crypt_data {\n"
"    char     keysched[16 * 8];\n"
"    char     sb0[32768];\n"
"    char     sb1[32768];\n"
"    char     sb2[32768];\n"
"    char     sb3[32768];\n"
"    char     crypt_3_buf[14];\n"
"    char     current_salt[2];\n"
"    long int current_saltbits;\n"
"    int      direction;\n"
"    int      initialized;\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/encrypt.3:111
msgid "Before calling B<setkey_r>()  set I<data-E<gt>initialized> to zero."
msgstr ""

#. type: Plain text
#: man-pages/man3/encrypt.3:113
msgid "These functions do not return any value."
msgstr ""

#. type: Plain text
#: man-pages/man3/encrypt.3:118
msgid ""
"Set I<errno> to zero before calling the above functions.  On success, it is "
"unchanged."
msgstr ""

#. type: TP
#: man-pages/man3/encrypt.3:118
#, no-wrap
msgid "B<ENOSYS>"
msgstr ""

#. type: Plain text
#: man-pages/man3/encrypt.3:122
msgid ""
"The function is not provided.  (For example because of former USA export "
"restrictions.)"
msgstr ""

#. type: Plain text
#: man-pages/man3/encrypt.3:133
msgid ""
"Because they employ the DES block cipher, which is no longer considered "
"secure, B<crypt>(), B<crypt_r>(), B<setkey>(), and B<setkey_r>()  were "
"removed in glibc 2.28.  Applications should switch to a modern cryptography "
"library, such as B<libgcrypt>."
msgstr ""

#. type: tbl table
#: man-pages/man3/encrypt.3:144
#, no-wrap
msgid ""
"B<encrypt>(),\n"
"B<setkey>()"
msgstr ""

#. type: tbl table
#: man-pages/man3/encrypt.3:144
#, no-wrap
msgid "MT-Unsafe race:crypt"
msgstr ""

#. type: tbl table
#: man-pages/man3/encrypt.3:148
#, no-wrap
msgid ""
"B<encrypt_r>(),\n"
"B<setkey_r>()"
msgstr ""

#. type: Plain text
#: man-pages/man3/encrypt.3:154
msgid "B<encrypt>(), B<setkey>(): POSIX.1-2001, POSIX.1-2008, SUS, SVr4."
msgstr ""

#. type: Plain text
#: man-pages/man3/encrypt.3:160
msgid "The functions B<encrypt_r>()  and B<setkey_r>()  are GNU extensions."
msgstr ""

#. type: SS
#: man-pages/man3/encrypt.3:161
#, no-wrap
msgid "Availability in glibc"
msgstr ""

#. type: Plain text
#: man-pages/man3/encrypt.3:164
msgid "See B<crypt>(3)."
msgstr ""

#. type: SS
#: man-pages/man3/encrypt.3:164
#, no-wrap
msgid "Features in glibc"
msgstr ""

#. type: Plain text
#: man-pages/man3/encrypt.3:166
msgid "In glibc 2.2, these functions use the DES algorithm."
msgstr ""

#. type: Plain text
#: man-pages/man3/encrypt.3:173
#, no-wrap
msgid ""
"#define _XOPEN_SOURCE\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>crypt.hE<gt>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/encrypt.3:182
#, no-wrap
msgid ""
"int\n"
"main(void)\n"
"{\n"
"    char key[64];\n"
"    char orig[9] = \"eggplant\";\n"
"    char buf[64];\n"
"    char txt[9];\n"
"    int i, j;\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/encrypt.3:186
#, no-wrap
msgid ""
"    for (i = 0; i E<lt> 64; i++) {\n"
"        key[i] = rand() & 1;\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/encrypt.3:194
#, no-wrap
msgid ""
"    for (i = 0; i E<lt> 8; i++) {\n"
"        for (j = 0; j E<lt> 8; j++) {\n"
"            buf[i * 8 + j] = orig[i] E<gt>E<gt> j & 1;\n"
"        }\n"
"        setkey(key);\n"
"    }\n"
"    printf(\"Before encrypting: %s\\en\", orig);\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/encrypt.3:203
#, no-wrap
msgid ""
"    encrypt(buf, 0);\n"
"    for (i = 0; i E<lt> 8; i++) {\n"
"        for (j = 0, txt[i] = \\(aq\\e0\\(aq; j E<lt> 8; j++) {\n"
"            txt[i] |= buf[i * 8 + j] E<lt>E<lt> j;\n"
"        }\n"
"        txt[8] = \\(aq\\e0\\(aq;\n"
"    }\n"
"    printf(\"After encrypting:  %s\\en\", txt);\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/encrypt.3:214
#, no-wrap
msgid ""
"    encrypt(buf, 1);\n"
"    for (i = 0; i E<lt> 8; i++) {\n"
"        for (j = 0, txt[i] = \\(aq\\e0\\(aq; j E<lt> 8; j++) {\n"
"            txt[i] |= buf[i * 8 + j] E<lt>E<lt> j;\n"
"        }\n"
"        txt[8] = \\(aq\\e0\\(aq;\n"
"    }\n"
"    printf(\"After decrypting:  %s\\en\", txt);\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/encrypt.3:218
msgid "B<cbc_crypt>(3), B<crypt>(3), B<ecb_crypt>(3),"
msgstr ""

#. type: TH
#: man-pages/man3/ether_aton.3:31
#, no-wrap
msgid "ETHER_ATON"
msgstr ""

#. type: Plain text
#: man-pages/man3/ether_aton.3:35
msgid ""
"ether_aton, ether_ntoa, ether_ntohost, ether_hostton, ether_line, "
"ether_ntoa_r, ether_aton_r - Ethernet address manipulation routines"
msgstr ""

#. type: Plain text
#: man-pages/man3/ether_aton.3:38
#, no-wrap
msgid "B<#include E<lt>netinet/ether.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/ether_aton.3:40
#, no-wrap
msgid "B<char *ether_ntoa(const struct ether_addr *>I<addr>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/ether_aton.3:42
#, no-wrap
msgid "B<struct ether_addr *ether_aton(const char *>I<asc>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/ether_aton.3:44
#, no-wrap
msgid ""
"B<int ether_ntohost(char *>I<hostname>B<, const struct ether_addr "
"*>I<addr>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/ether_aton.3:46
#, no-wrap
msgid ""
"B<int ether_hostton(const char *>I<hostname>B<, struct ether_addr "
"*>I<addr>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/ether_aton.3:49
#, no-wrap
msgid ""
"B<int ether_line(const char *>I<line>B<, struct ether_addr *>I<addr>B<,>\n"
"B<               char *>I<hostname>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/ether_aton.3:51
#, no-wrap
msgid "/* GNU extensions */\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/ether_aton.3:53
#, no-wrap
msgid ""
"B<char *ether_ntoa_r(const struct ether_addr *>I<addr>B<, char "
"*>I<buf>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/ether_aton.3:56
#, no-wrap
msgid ""
"B<struct ether_addr *ether_aton_r(const char *>I<asc>B<,>\n"
"B<                                struct ether_addr *>I<addr>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/ether_aton.3:67
msgid ""
"B<ether_aton>()  converts the 48-bit Ethernet host address I<asc> from the "
"standard hex-digits-and-colons notation into binary data in network byte "
"order and returns a pointer to it in a statically allocated buffer, which "
"subsequent calls will overwrite.  B<ether_aton>()  returns NULL if the "
"address is invalid."
msgstr ""

#. type: Plain text
#: man-pages/man3/ether_aton.3:76
msgid ""
"The B<ether_ntoa>()  function converts the Ethernet host address I<addr> "
"given in network byte order to a string in standard hex-digits-and-colons "
"notation, omitting leading zeros.  The string is returned in a statically "
"allocated buffer, which subsequent calls will overwrite."
msgstr ""

#. type: Plain text
#: man-pages/man3/ether_aton.3:83
msgid ""
"The B<ether_ntohost>()  function maps an Ethernet address to the "
"corresponding hostname in I</etc/ethers> and returns nonzero if it cannot be"
" found."
msgstr ""

#. type: Plain text
#: man-pages/man3/ether_aton.3:90
msgid ""
"The B<ether_hostton>()  function maps a hostname to the corresponding "
"Ethernet address in I</etc/ethers> and returns nonzero if it cannot be "
"found."
msgstr ""

#. type: Plain text
#: man-pages/man3/ether_aton.3:102
msgid ""
"The B<ether_line>()  function parses a line in I</etc/ethers> format "
"(ethernet address followed by whitespace followed by hostname; \\(aq#\\(aq "
"introduces a comment) and returns an address and hostname pair, or nonzero "
"if it cannot be parsed.  The buffer pointed to by I<hostname> must be "
"sufficiently long, for example, have the same length as I<line>."
msgstr ""

#. type: Plain text
#: man-pages/man3/ether_aton.3:113
msgid ""
"The functions B<ether_ntoa_r>()  and B<ether_aton_r>()  are reentrant "
"thread-safe versions of B<ether_ntoa>()  and B<ether_aton>()  respectively, "
"and do not use static buffers."
msgstr ""

#. type: Plain text
#: man-pages/man3/ether_aton.3:119
msgid ""
"The structure I<ether_addr> is defined in I<E<lt>net/ethernet.hE<gt>> as:"
msgstr ""

#. type: Plain text
#: man-pages/man3/ether_aton.3:125
#, no-wrap
msgid ""
"struct ether_addr {\n"
"    uint8_t ether_addr_octet[6];\n"
"}\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/ether_aton.3:139
#, no-wrap
msgid ""
"B<ether_aton>(),\n"
"B<ether_ntoa>()"
msgstr ""

#. type: tbl table
#: man-pages/man3/ether_aton.3:139
#, no-wrap
msgid "MT-Unsafe"
msgstr ""

#. type: tbl table
#: man-pages/man3/ether_aton.3:146
#, no-wrap
msgid ""
"B<ether_ntohost>(),\n"
"B<ether_hostton>(),\n"
"B<ether_line>(),\n"
"B<ether_ntoa_r>(),\n"
"B<ether_aton_r>()"
msgstr ""

#. type: Plain text
#: man-pages/man3/ether_aton.3:151
msgid "4.3BSD, SunOS."
msgstr ""

#.  The fix was presumably commit c0a0f9a32c8baa6ab93d00eb42d92c02e9e146d7
#.  which was in glibc 2.3
#. type: Plain text
#: man-pages/man3/ether_aton.3:157
msgid ""
"In glibc 2.2.5 and earlier, the implementation of B<ether_line>()  is "
"broken."
msgstr ""

#. type: Plain text
#: man-pages/man3/ether_aton.3:158
msgid "B<ethers>(5)"
msgstr ""

#. type: TH
#: man-pages/man3/ecvt_r.3:30
#, no-wrap
msgid "ECVT_R"
msgstr ""

#. type: Plain text
#: man-pages/man3/ecvt_r.3:33
msgid ""
"ecvt_r, fcvt_r, qecvt_r, qfcvt_r - convert a floating-point number to a "
"string"
msgstr ""

#. type: Plain text
#: man-pages/man3/ecvt_r.3:39
#, no-wrap
msgid ""
"B<int ecvt_r(double >I<number>B<, int >I<ndigits>B<, int *>I<decpt>B<,>\n"
"B<           int *>I<sign>B<, char *>I<buf>B<, size_t >I<len>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/ecvt_r.3:42
#, no-wrap
msgid ""
"B<int fcvt_r(double >I<number>B<, int >I<ndigits>B<, int *>I<decpt>B<,>\n"
"B<           int *>I<sign>B<, char *>I<buf>B<, size_t >I<len>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/ecvt_r.3:45
#, no-wrap
msgid ""
"B<int qecvt_r(long double >I<number>B<, int >I<ndigits>B<, int *>I<decpt>B<,>\n"
"B<           int *>I<sign>B<, char *>I<buf>B<, size_t >I<len>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/ecvt_r.3:48
#, no-wrap
msgid ""
"B<int qfcvt_r(long double >I<number>B<, int >I<ndigits>B<, int *>I<decpt>B<,>\n"
"B<           int *>I<sign>B<, char *>I<buf>B<, size_t >I<len>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/ecvt_r.3:60
msgid "B<ecvt_r>(), B<fcvt_r>(), B<qecvt_r>(), B<qfcvt_r>():"
msgstr ""

#. type: Plain text
#: man-pages/man3/ecvt_r.3:63
#, no-wrap
msgid ""
"/* Glibc since 2.19: */ _DEFAULT_SOURCE\n"
"    || /* Glibc versions E<lt>= 2.19: */ _SVID_SOURCE || _BSD_SOURCE\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/ecvt_r.3:87
msgid ""
"The functions B<ecvt_r>(), B<fcvt_r>(), B<qecvt_r>(), and B<qfcvt_r>()  are "
"identical to B<ecvt>(3), B<fcvt>(3), B<qecvt>(3), and B<qfcvt>(3), "
"respectively, except that they do not return their result in a static "
"buffer, but instead use the supplied I<buf> of size I<len>.  See B<ecvt>(3)"
"  and B<qecvt>(3)."
msgstr ""

#. type: Plain text
#: man-pages/man3/ecvt_r.3:89
msgid "These functions return 0 on success, and -1 otherwise."
msgstr ""

#. type: tbl table
#: man-pages/man3/ecvt_r.3:100
#, no-wrap
msgid ""
"B<ecvt_r>(),\n"
"B<fcvt_r>(),\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/ecvt_r.3:103
#, no-wrap
msgid ""
"B<qecvt_r>(),\n"
"B<qfcvt_r>()"
msgstr ""

#. type: Plain text
#: man-pages/man3/ecvt_r.3:107
msgid "These functions are GNU extensions."
msgstr ""

#. type: Plain text
#: man-pages/man3/ecvt_r.3:112
msgid "These functions are obsolete.  Instead, B<sprintf>(3)  is recommended."
msgstr ""

#. type: Plain text
#: man-pages/man3/ecvt_r.3:115
msgid "B<ecvt>(3), B<qecvt>(3), B<sprintf>(3)"
msgstr ""

#. type: TH
#: man-pages/man3/exec.3:41
#, no-wrap
msgid "EXEC"
msgstr ""

#. type: Plain text
#: man-pages/man3/exec.3:44
msgid "execl, execlp, execle, execv, execvp, execvpe - execute a file"
msgstr ""

#. type: Plain text
#: man-pages/man3/exec.3:47
#, no-wrap
msgid "B<#include E<lt>unistd.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/exec.3:49
#, no-wrap
msgid "B<extern char **environ;>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/exec.3:60
#, no-wrap
msgid ""
"B<int execl(const char *>I<pathname>B<, const char *>I<arg>B<, ...>\n"
"B</* (char  *) NULL */);>\n"
"B<int execlp(const char *>I<file>B<, const char *>I<arg>B<, ...>\n"
"B</* (char  *) NULL */);>\n"
"B<int execle(const char *>I<pathname>B<, const char *>I<arg>B<, ...>\n"
"B<                /*, (char *) NULL, char * const >I<envp>B<[] */);>\n"
"B<int execv(const char *>I<pathname>B<, char *const >I<argv>B<[]);>\n"
"B<int execvp(const char *>I<file>B<, char *const >I<argv>B<[]);>\n"
"B<int execvpe(const char *>I<file>B<, char *const >I<argv>B<[],>\n"
"B<                char *const >I<envp>B<[]);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/exec.3:69
msgid "B<execvpe>(): _GNU_SOURCE"
msgstr ""

#. type: Plain text
#: man-pages/man3/exec.3:79
msgid ""
"The B<exec>()  family of functions replaces the current process image with a"
" new process image.  The functions described in this manual page are front-"
"ends for B<execve>(2).  (See the manual page for B<execve>(2)  for further "
"details about the replacement of the current process image.)"
msgstr ""

#. type: Plain text
#: man-pages/man3/exec.3:82
msgid ""
"The initial argument for these functions is the name of a file that is to be"
" executed."
msgstr ""

#. type: Plain text
#: man-pages/man3/exec.3:104
msgid ""
"The I<const char\\ *arg> and subsequent ellipses in the B<execl>(), "
"B<execlp>(), and B<execle>()  functions can be thought of as I<arg0>, "
"I<arg1>, \\&..., I<argn>.  Together they describe a list of one or more "
"pointers to null-terminated strings that represent the argument list "
"available to the executed program.  The first argument, by convention, "
"should point to the filename associated with the file being executed.  The "
"list of arguments I<must> be terminated by a null pointer, and, since these "
"are variadic functions, this pointer must be cast I<(char\\ *) NULL>."
msgstr ""

#. type: Plain text
#: man-pages/man3/exec.3:117
msgid ""
"The B<execv>(), B<execvp>(), and B<execvpe>()  functions provide an array of"
" pointers to null-terminated strings that represent the argument list "
"available to the new program.  The first argument, by convention, should "
"point to the filename associated with the file being executed.  The array of"
" pointers I<must> be terminated by a null pointer."
msgstr ""

#. type: Plain text
#: man-pages/man3/exec.3:134
msgid ""
"The B<execle>()  and B<execvpe>()  functions allow the caller to specify the"
" environment of the executed program via the argument I<envp>.  The I<envp> "
"argument is an array of pointers to null-terminated strings and I<must> be "
"terminated by a null pointer.  The other functions take the environment for "
"the new process image from the external variable I<environ> in the calling "
"process."
msgstr ""

#. type: SS
#: man-pages/man3/exec.3:134
#, no-wrap
msgid "Special semantics for execlp(), execvp(), and execvpe()"
msgstr ""

#. type: Plain text
#: man-pages/man3/exec.3:154
msgid ""
"The B<execlp>(), B<execvp>(), and B<execvpe>()  functions duplicate the "
"actions of the shell in searching for an executable file if the specified "
"filename does not contain a slash (/) character.  The file is sought in the "
"colon-separated list of directory pathnames specified in the B<PATH> "
"environment variable.  If this variable isn't defined, the path list "
"defaults to a list that includes the directories returned by "
"I<confstr(_CS_PATH)> (which typically returns the value \"/bin:/usr/bin\")  "
"and possibly also the current working directory; see NOTES for further "
"details."
msgstr ""

#. type: Plain text
#: man-pages/man3/exec.3:158
msgid ""
"If the specified filename includes a slash character, then B<PATH> is "
"ignored, and the file at the specified pathname is executed."
msgstr ""

#. type: Plain text
#: man-pages/man3/exec.3:160
msgid "In addition, certain errors are treated specially."
msgstr ""

#. type: Plain text
#: man-pages/man3/exec.3:171
msgid ""
"If permission is denied for a file (the attempted B<execve>(2)  failed with "
"the error B<EACCES>), these functions will continue searching the rest of "
"the search path.  If no other file is found, however, they will return with "
"I<errno> set to B<EACCES>."
msgstr ""

#. type: Plain text
#: man-pages/man3/exec.3:180
msgid ""
"If the header of a file isn't recognized (the attempted B<execve>(2)  failed"
" with the error B<ENOEXEC>), these functions will execute the shell "
"(I</bin/sh>)  with the path of the file as its first argument.  (If this "
"attempt fails, no further searching is done.)"
msgstr ""

#. type: Plain text
#: man-pages/man3/exec.3:187
msgid ""
"The B<exec>()  functions return only if an error has occurred.  The return "
"value is -1, and I<errno> is set to indicate the error."
msgstr ""

#. type: Plain text
#: man-pages/man3/exec.3:192
msgid ""
"All of these functions may fail and set I<errno> for any of the errors "
"specified for B<execve>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man3/exec.3:196
msgid "The B<execvpe>()  function first appeared in glibc 2.11."
msgstr ""

#. type: tbl table
#: man-pages/man3/exec.3:208
#, no-wrap
msgid ""
"B<execl>(),\n"
"B<execle>(),\n"
"B<execv>()"
msgstr ""

#. type: tbl table
#: man-pages/man3/exec.3:213
#, no-wrap
msgid ""
"B<execlp>(),\n"
"B<execvp>(),\n"
"B<execvpe>()"
msgstr ""

#. type: tbl table
#: man-pages/man3/exec.3:213
#, no-wrap
msgid "MT-Safe env"
msgstr ""

#. type: Plain text
#: man-pages/man3/exec.3:217
msgid "POSIX.1-2001, POSIX.1-2008."
msgstr ""

#. type: Plain text
#: man-pages/man3/exec.3:221
msgid "The B<execvpe>()  function is a GNU extension."
msgstr ""

#.  glibc commit 1eb8930608705702d5746e5491bab4e4429fcb83
#. type: Plain text
#: man-pages/man3/exec.3:243
msgid ""
"The default search path (used when the environment does not contain the "
"variable B<PATH>)  shows some variation across systems.  It generally "
"includes I</bin> and I</usr/bin> (in that order) and may also include the "
"current working directory.  On some other systems, the current working is "
"included after I</bin> and I</usr/bin>, as an anti-Trojan-horse measure.  "
"The glibc implementation long followed the traditional default where the "
"current working directory is included at the start of the search path.  "
"However, some code refactoring during the development of glibc 2.24 caused "
"the current working directory to be dropped altogether from the default "
"search path.  This accidental behavior change is considered mildly "
"beneficial, and won't be reverted."
msgstr ""

#. type: Plain text
#: man-pages/man3/exec.3:257
msgid ""
"The behavior of B<execlp>()  and B<execvp>()  when errors occur while "
"attempting to execute the file is historic practice, but has not "
"traditionally been documented and is not specified by the POSIX standard.  "
"BSD (and possibly other systems) do an automatic sleep and retry if "
"B<ETXTBSY> is encountered.  Linux treats it as a hard error and returns "
"immediately."
msgstr ""

#. type: Plain text
#: man-pages/man3/exec.3:269
msgid ""
"Traditionally, the functions B<execlp>()  and B<execvp>()  ignored all "
"errors except for the ones described above and B<ENOMEM> and B<E2BIG>, upon "
"which they returned.  They now return if any error other than the ones "
"described above occurs."
msgstr ""

#.  https://sourceware.org/bugzilla/show_bug.cgi?id=19534
#. type: Plain text
#: man-pages/man3/exec.3:281
msgid ""
"Before glibc 2.24, B<execl>()  and B<execle>()  employed B<realloc>(3)  "
"internally and were consequently not async-signal-safe, in violation of the "
"requirements of POSIX.1.  This was fixed in glibc 2.24."
msgstr ""

#. type: SS
#: man-pages/man3/exec.3:281
#, no-wrap
msgid "Architecture-specific details"
msgstr ""

#. type: Plain text
#: man-pages/man3/exec.3:292
msgid ""
"On sparc and sparc64, B<execv>()  is provided as a system call by the kernel"
" (with the prototype shown above)  for compatibility with SunOS.  This "
"function is I<not> employed by the B<execv>()  wrapper function on those "
"architectures."
msgstr ""

#. type: Plain text
#: man-pages/man3/exec.3:300
msgid ""
"B<sh>(1), B<execve>(2), B<execveat>(2), B<fork>(2), B<ptrace>(2), "
"B<fexecve>(3), B<system>(3), B<environ>(7)"
msgstr ""

#. type: TH
#: man-pages/man3/exp.3:36
#, no-wrap
msgid "EXP"
msgstr ""

#. type: Plain text
#: man-pages/man3/exp.3:39
msgid "exp, expf, expl - base-e exponential function"
msgstr ""

#. type: Plain text
#: man-pages/man3/exp.3:46
#, no-wrap
msgid ""
"B<double exp(double >I<x>B<);>\n"
"B<float expf(float >I<x>B<);>\n"
"B<long double expl(long double >I<x>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/exp.3:58
msgid "B<expf>(), B<expl>():"
msgstr ""

#. type: Plain text
#: man-pages/man3/exp.3:62
#, no-wrap
msgid ""
"_ISOC99_SOURCE || _POSIX_C_SOURCE\\ E<gt>=\\ 200112L\n"
"    || /* Since glibc 2.19: */ _DEFAULT_SOURCE\n"
"    || /* Glibc versions E<lt>= 2.19: */ _BSD_SOURCE || _SVID_SOURCE\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/exp.3:68
msgid ""
"These functions return the value of e (the base of natural logarithms) "
"raised to the power of I<x>."
msgstr ""

#. type: Plain text
#: man-pages/man3/exp.3:71
msgid "On success, these functions return the exponential value of I<x>."
msgstr ""

#. type: Plain text
#: man-pages/man3/exp.3:76
msgid "If I<x> is a NaN, a NaN is returned."
msgstr ""

#. type: Plain text
#: man-pages/man3/exp.3:81
msgid "If I<x> is positive infinity, positive infinity is returned."
msgstr ""

#. type: Plain text
#: man-pages/man3/exp.3:86
msgid "If I<x> is negative infinity, +0 is returned."
msgstr ""

#. type: Plain text
#: man-pages/man3/exp.3:90
msgid "If the result underflows, a range error occurs, and zero is returned."
msgstr ""

#. type: Plain text
#: man-pages/man3/exp.3:99
msgid ""
"If the result overflows, a range error occurs, and the functions return "
"+B<HUGE_VAL>, +B<HUGE_VALF>, or +B<HUGE_VALL>, respectively."
msgstr ""

#. type: Plain text
#: man-pages/man3/exp.3:106
msgid "The following errors can occur:"
msgstr ""

#. type: TP
#: man-pages/man3/exp.3:106
#, no-wrap
msgid "Range error, overflow"
msgstr ""

#. type: Plain text
#: man-pages/man3/exp.3:114
msgid ""
"I<errno> is set to B<ERANGE>.  An overflow floating-point exception "
"(B<FE_OVERFLOW>)  is raised."
msgstr ""

#. type: TP
#: man-pages/man3/exp.3:114
#, no-wrap
msgid "Range error, underflow"
msgstr ""

#. type: Plain text
#: man-pages/man3/exp.3:122
msgid ""
"I<errno> is set to B<ERANGE>.  An underflow floating-point exception "
"(B<FE_UNDERFLOW>)  is raised."
msgstr ""

#. type: tbl table
#: man-pages/man3/exp.3:134
#, no-wrap
msgid ""
"B<exp>(),\n"
"B<expf>(),\n"
"B<expl>()"
msgstr ""

#. type: Plain text
#: man-pages/man3/exp.3:143
msgid "The variant returning I<double> also conforms to SVr4, 4.3BSD, C89."
msgstr ""

#. type: Plain text
#: man-pages/man3/exp.3:149
msgid ""
"B<cbrt>(3), B<cexp>(3), B<exp10>(3), B<exp2>(3), B<expm1>(3), B<sqrt>(3)"
msgstr ""

#. type: TH
#: man-pages/man3/envz_add.3:10
#, no-wrap
msgid "ENVZ_ADD"
msgstr ""

#. type: Plain text
#: man-pages/man3/envz_add.3:14
msgid ""
"envz_add, envz_entry, envz_get, envz_merge, envz_remove, envz_strip - "
"environment string support"
msgstr ""

#. type: Plain text
#: man-pages/man3/envz_add.3:17
#, no-wrap
msgid "B<#include E<lt>envz.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/envz_add.3:20
#, no-wrap
msgid ""
"B<error_t envz_add(char **>I<envz>B<, size_t *>I<envz_len>B<,>\n"
"B<                 const char *>I<name>B<, const char *>I<value>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/envz_add.3:23
#, no-wrap
msgid ""
"B<char *envz_entry(const char *>I<envz>B<, size_t >I<envz_len>B<, const char"
" *>I<name>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/envz_add.3:26
#, no-wrap
msgid ""
"B<char *envz_get(const char *>I<envz>B<, size_t >I<envz_len>B<, const char "
"*>I<name>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/envz_add.3:30
#, no-wrap
msgid ""
"B<error_t envz_merge(char **>I<envz>B<, size_t *>I<envz_len>B<,>\n"
"B<                   const char *>I<envz2>B<, size_t >I<envz2_len>B<, int >I<override>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/envz_add.3:33
#, no-wrap
msgid ""
"B<void envz_remove(char **>I<envz>B<, size_t *>I<envz_len>B<, const char "
"*>I<name>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/envz_add.3:35
#, no-wrap
msgid "B<void envz_strip(char **>I<envz>B<, size_t *>I<envz_len>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/envz_add.3:38
msgid "These functions are glibc-specific."
msgstr ""

#. type: Plain text
#: man-pages/man3/envz_add.3:48
msgid ""
"An argz vector is a pointer to a character buffer together with a length, "
"see B<argz_add>(3).  An envz vector is a special argz vector, namely one "
"where the strings have the form \"name=value\".  Everything after the first "
"\\(aq=\\(aq is considered to be the value.  If there is no \\(aq=\\(aq, the "
"value is taken to be NULL.  (While the value in case of a trailing "
"\\(aq=\\(aq is the empty string \"\".)"
msgstr ""

#. type: Plain text
#: man-pages/man3/envz_add.3:50
msgid "These functions are for handling envz vectors."
msgstr ""

#. type: Plain text
#: man-pages/man3/envz_add.3:69
msgid ""
"B<envz_add>()  adds the string \"I<name>=I<value>\" (in case I<value> is "
"non-NULL) or \"I<name>\" (in case I<value> is NULL) to the envz vector "
"(I<*envz>,\\ I<*envz_len>)  and updates I<*envz> and I<*envz_len>.  If an "
"entry with the same I<name> existed, it is removed."
msgstr ""

#. type: Plain text
#: man-pages/man3/envz_add.3:76
msgid ""
"B<envz_entry>()  looks for I<name> in the envz vector (I<envz>,\\ "
"I<envz_len>)  and returns the entry if found, or NULL if not."
msgstr ""

#. type: Plain text
#: man-pages/man3/envz_add.3:87
msgid ""
"B<envz_get>()  looks for I<name> in the envz vector (I<envz>,\\ I<envz_len>)"
"  and returns the value if found, or NULL if not.  (Note that the value can "
"also be NULL, namely when there is an entry for I<name> without \\(aq=\\(aq "
"sign.)"
msgstr ""

#. type: Plain text
#: man-pages/man3/envz_add.3:102
msgid ""
"B<envz_merge>()  adds each entry in I<envz2> to I<*envz>, as if with "
"B<envz_add>().  If I<override> is true, then values in I<envz2> will "
"supersede those with the same name in I<*envz>, otherwise not."
msgstr ""

#. type: Plain text
#: man-pages/man3/envz_add.3:109
msgid ""
"B<envz_remove>()  removes the entry for I<name> from (I<*envz>,\\ "
"I<*envz_len>)  if there was one."
msgstr ""

#. type: Plain text
#: man-pages/man3/envz_add.3:112
msgid "B<envz_strip>()  removes all entries with value NULL."
msgstr ""

#. type: Plain text
#: man-pages/man3/envz_add.3:118
msgid ""
"All envz functions that do memory allocation have a return type of "
"I<error_t>, and return 0 for success, and B<ENOMEM> if an allocation error "
"occurs."
msgstr ""

#. type: tbl table
#: man-pages/man3/envz_add.3:129
#, no-wrap
msgid ""
"B<envz_add>(),\n"
"B<envz_entry>(),\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/envz_add.3:132
#, no-wrap
msgid ""
"B<envz_get>(),\n"
"B<envz_merge>(),\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/envz_add.3:135
#, no-wrap
msgid ""
"B<envz_remove>(),\n"
"B<envz_strip>()"
msgstr ""

#. type: Plain text
#: man-pages/man3/envz_add.3:141
msgid "These functions are a GNU extension.  Handle with care."
msgstr ""

#. type: Plain text
#: man-pages/man3/envz_add.3:146
#, no-wrap
msgid ""
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>envz.hE<gt>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/envz_add.3:152
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[], char *envp[])\n"
"{\n"
"    int i, e_len = 0;\n"
"    char *str;\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/envz_add.3:155
#, no-wrap
msgid ""
"    for (i = 0; envp[i] != NULL; i++)\n"
"        e_len += strlen(envp[i]) + 1;\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/envz_add.3:162
#, no-wrap
msgid ""
"    str = envz_entry(*envp, e_len, \"HOME\");\n"
"    printf(\"%s\\en\", str);\n"
"    str = envz_get(*envp, e_len, \"HOME\");\n"
"    printf(\"%s\\en\", str);\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/envz_add.3:164
msgid "B<argz_add>(3)"
msgstr ""

#. type: TH
#: man-pages/man3/error.3:27
#, no-wrap
msgid "ERROR"
msgstr ""

#. type: Plain text
#: man-pages/man3/error.3:31
msgid ""
"error, error_at_line, error_message_count, error_one_per_line, "
"error_print_progname - glibc error reporting functions"
msgstr ""

#. type: Plain text
#: man-pages/man3/error.3:34
#, no-wrap
msgid "B<#include E<lt>error.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/error.3:36
#, no-wrap
msgid ""
"B<void error(int >I<status>B<, int >I<errnum>B<, const char *>I<format>B<, "
"...);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/error.3:39
#, no-wrap
msgid ""
"B<void error_at_line(int >I<status>B<, int >I<errnum>B<, const char *>I<filename>B<,>\n"
"B<                   unsigned int >I<linenum>B<, const char *>I<format>B<, ...);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/error.3:41
#, no-wrap
msgid "B<extern unsigned int >I<error_message_count>B<;>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/error.3:43
#, no-wrap
msgid "B<extern int >I<error_one_per_line>B<;>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/error.3:45
#, no-wrap
msgid "B<extern void (*>I<error_print_progname>B<) (void);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/error.3:64
msgid ""
"B<error>()  is a general error-reporting function.  It flushes I<stdout>, "
"and then outputs to I<stderr> the program name, a colon and a space, the "
"message specified by the B<printf>(3)-style format string I<format>, and, if"
" I<errnum> is nonzero, a second colon and a space followed by the string "
"given by I<strerror(errnum)>.  Any arguments required for I<format> should "
"follow I<format> in the argument list.  The output is terminated by a "
"newline character."
msgstr ""

#. type: Plain text
#: man-pages/man3/error.3:75
msgid ""
"The program name printed by B<error>()  is the value of the global variable "
"B<program_invocation_name>(3).  I<program_invocation_name> initially has the"
" same value as I<main>()'s I<argv[0]>.  The value of this variable can be "
"modified to change the output of B<error>()."
msgstr ""

#. type: Plain text
#: man-pages/man3/error.3:81
msgid ""
"If I<status> has a nonzero value, then B<error>()  calls B<exit>(3)  to "
"terminate the program using the given value as the exit status."
msgstr ""

#. type: Plain text
#: man-pages/man3/error.3:101
msgid ""
"The B<error_at_line>()  function is exactly the same as B<error>(), except "
"for the addition of the arguments I<filename> and I<linenum>.  The output "
"produced is as for B<error>(), except that after the program name are "
"written: a colon, the value of I<filename>, a colon, and the value of "
"I<linenum>.  The preprocessor values B<__LINE__> and B<__FILE__> may be "
"useful when calling B<error_at_line>(), but other values can also be used.  "
"For example, these arguments could refer to a location in an input file."
msgstr ""

#. type: Plain text
#: man-pages/man3/error.3:108
msgid ""
"If the global variable I<error_one_per_line> is set nonzero, a sequence of "
"B<error_at_line>()  calls with the same value of I<filename> and I<linenum> "
"will result in only one message (the first) being output."
msgstr ""

#. type: Plain text
#: man-pages/man3/error.3:114
msgid ""
"The global variable I<error_message_count> counts the number of messages "
"that have been output by B<error>()  and B<error_at_line>()."
msgstr ""

#. type: Plain text
#: man-pages/man3/error.3:121
msgid ""
"If the global variable I<error_print_progname> is assigned the address of a "
"function (i.e., is not NULL), then that function is called instead of "
"prefixing the message with the program name and colon.  The function should "
"print a suitable string to I<stderr>."
msgstr ""

#. type: tbl table
#: man-pages/man3/error.3:132
#, no-wrap
msgid "B<error>()"
msgstr ""

#. type: tbl table
#: man-pages/man3/error.3:135
#, no-wrap
msgid "B<error_at_line>()"
msgstr ""

#. type: tbl table
#: man-pages/man3/error.3:137
#, no-wrap
msgid "MT-Unsafe\\ race: error_at_line/error_one_per_line locale"
msgstr ""

#. type: Plain text
#: man-pages/man3/error.3:156
msgid ""
"The internal I<error_one_per_line> variable is accessed (without any form of"
" synchronization, but since it's an I<int> used once, it should be safe "
"enough) and, if I<error_one_per_line> is set nonzero, the internal static "
"variables (not exposed to users)  used to hold the last printed filename and"
" line number are accessed and modified without synchronization; the update "
"is not atomic and it occurs before disabling cancellation, so it can be "
"interrupted only after one of the two variables is modified.  After that, "
"B<error_at_line>()  is very much like B<error>()."
msgstr ""

#. type: Plain text
#: man-pages/man3/error.3:159
msgid ""
"These functions and variables are GNU extensions, and should not be used in "
"programs intended to be portable."
msgstr ""

#. type: Plain text
#: man-pages/man3/error.3:165
msgid ""
"B<err>(3), B<errno>(3), B<exit>(3), B<perror>(3), "
"B<program_invocation_name>(3), B<strerror>(3)"
msgstr ""

#. type: TH
#: man-pages/man3/errno.3:31
#, no-wrap
msgid "ERRNO"
msgstr ""

#. type: Plain text
#: man-pages/man3/errno.3:34
msgid "errno - number of last error"
msgstr ""

#. .PP
#. .BI "extern int " errno ;
#. type: Plain text
#: man-pages/man3/errno.3:38
msgid "B<#include E<lt>errno.hE<gt>>"
msgstr ""

#. type: Plain text
#: man-pages/man3/errno.3:46
msgid ""
"The I<E<lt>errno.hE<gt>> header file defines the integer variable I<errno>, "
"which is set by system calls and some library functions in the event of an "
"error to indicate what went wrong."
msgstr ""

#. type: SS
#: man-pages/man3/errno.3:46
#, no-wrap
msgid "errno"
msgstr ""

#. type: Plain text
#: man-pages/man3/errno.3:60
msgid ""
"The value in I<errno> is significant only when the return value of the call "
"indicated an error (i.e., -1 from most system calls; -1 or NULL from most "
"library functions); a function that succeeds I<is> allowed to change "
"I<errno>.  The value of I<errno> is never set to zero by any system call or "
"library function."
msgstr ""

#. type: Plain text
#: man-pages/man3/errno.3:72
msgid ""
"For some system calls and library functions (e.g., B<getpriority>(2)), -1 is"
" a valid return on success.  In such cases, a successful return can be "
"distinguished from an error return by setting I<errno> to zero before the "
"call, and then, if the call returns a status that indicates that an error "
"may have occurred, checking to see if I<errno> has a nonzero value."
msgstr ""

#. type: Plain text
#: man-pages/man3/errno.3:84
msgid ""
"I<errno> is defined by the ISO C standard to be a modifiable lvalue of type "
"I<int>, and must not be explicitly declared; I<errno> may be a macro.  "
"I<errno> is thread-local; setting it in one thread does not affect its value"
" in any other thread."
msgstr ""

#. type: SS
#: man-pages/man3/errno.3:84
#, no-wrap
msgid "Error numbers and names"
msgstr ""

#. type: Plain text
#: man-pages/man3/errno.3:91
msgid ""
"Valid error numbers are all positive numbers.  The I<E<lt>errno.hE<gt>> "
"header file defines symbolic names for each of the possible error numbers "
"that may appear in I<errno>."
msgstr ""

#. type: Plain text
#: man-pages/man3/errno.3:98
msgid ""
"All the error names specified by POSIX.1 must have distinct values, with the"
" exception of B<EAGAIN> and B<EWOULDBLOCK>, which may be the same."
msgstr ""

#. type: Plain text
#: man-pages/man3/errno.3:110
msgid ""
"The error numbers that correspond to each symbolic name vary across UNIX "
"systems, and even across different architectures on Linux.  Therefore, "
"numeric values are not included as part of the list of error names below.  "
"The B<perror>(3)  and B<strerror>(3)  functions can be used to convert these"
" names to corresponding textual error messages."
msgstr ""

#. type: Plain text
#: man-pages/man3/errno.3:118
msgid ""
"On any particular Linux system, one can obtain a list of all symbolic error "
"names and the corresponding error numbers using the B<errno>(1)  command "
"(part of the I<moreutils> package):"
msgstr ""

#. type: Plain text
#: man-pages/man3/errno.3:128
#, no-wrap
msgid ""
"$ B<errno -l>\n"
"EPERM 1 Operation not permitted\n"
"ENOENT 2 No such file or directory\n"
"ESRCH 3 No such process\n"
"EINTR 4 Interrupted system call\n"
"EIO 5 Input/output error\n"
"\\&...\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/errno.3:136
msgid ""
"The B<errno>(1)  command can also be used to look up individual error "
"numbers and names, and to search for errors using strings from the error "
"description, as in the following examples:"
msgstr ""

#. type: Plain text
#: man-pages/man3/errno.3:145
#, no-wrap
msgid ""
"$ B<errno 2>\n"
"ENOENT 2 No such file or directory\n"
"$ B<errno ESRCH>\n"
"ESRCH 3 No such process\n"
"$ B<errno -s permission>\n"
"EACCES 13 Permission denied\n"
msgstr ""

#.  POSIX.1 (2001 edition) lists the following symbolic error names.  Of
#.  these, \fBEDOM\fP and \fBERANGE\fP are in the ISO C standard.  ISO C
#.  Amendment 1 defines the additional error number \fBEILSEQ\fP for
#.  coding errors in multibyte or wide characters.
#. type: SS
#: man-pages/man3/errno.3:153
#, no-wrap
msgid "List of error names"
msgstr ""

#. type: Plain text
#: man-pages/man3/errno.3:156
msgid ""
"In the list of the symbolic error names below, various names are marked as "
"follows:"
msgstr ""

#. type: Plain text
#: man-pages/man3/errno.3:160
msgid ""
"I<POSIX.1-2001>: The name is defined by POSIX.1-2001, and is defined in "
"later POSIX.1 versions, unless otherwise indicated."
msgstr ""

#. type: Plain text
#: man-pages/man3/errno.3:164
msgid ""
"I<POSIX.1-2008>: The name is defined in POSIX.1-2008, but was not present in"
" earlier POSIX.1 standards."
msgstr ""

#. type: Plain text
#: man-pages/man3/errno.3:168
msgid ""
"I<C99>: The name is defined by C99.  Below is a list of the symbolic error "
"names that are defined on Linux:"
msgstr ""

#. type: Plain text
#: man-pages/man3/errno.3:171
msgid "Argument list too long (POSIX.1-2001)."
msgstr ""

#. type: Plain text
#: man-pages/man3/errno.3:174
msgid "Permission denied (POSIX.1-2001)."
msgstr ""

#. type: TP
#: man-pages/man3/errno.3:174
#, no-wrap
msgid "B<EADDRINUSE>"
msgstr ""

#. type: Plain text
#: man-pages/man3/errno.3:177
msgid "Address already in use (POSIX.1-2001)."
msgstr ""

#. type: TP
#: man-pages/man3/errno.3:177
#, no-wrap
msgid "B<EADDRNOTAVAIL>"
msgstr ""

#.  EADV is only an error on HURD(?)
#. type: Plain text
#: man-pages/man3/errno.3:181
msgid "Address not available (POSIX.1-2001)."
msgstr ""

#. type: TP
#: man-pages/man3/errno.3:181
#, no-wrap
msgid "B<EAFNOSUPPORT>"
msgstr ""

#. type: Plain text
#: man-pages/man3/errno.3:184
msgid "Address family not supported (POSIX.1-2001)."
msgstr ""

#. type: TP
#: man-pages/man3/errno.3:184
#, no-wrap
msgid "B<EAGAIN>"
msgstr ""

#. type: Plain text
#: man-pages/man3/errno.3:189
msgid ""
"Resource temporarily unavailable (may be the same value as B<EWOULDBLOCK>)  "
"(POSIX.1-2001)."
msgstr ""

#. type: TP
#: man-pages/man3/errno.3:189
#, no-wrap
msgid "B<EALREADY>"
msgstr ""

#. type: Plain text
#: man-pages/man3/errno.3:192
msgid "Connection already in progress (POSIX.1-2001)."
msgstr ""

#. type: TP
#: man-pages/man3/errno.3:192
#, no-wrap
msgid "B<EBADE>"
msgstr ""

#. type: Plain text
#: man-pages/man3/errno.3:195
msgid "Invalid exchange."
msgstr ""

#. type: Plain text
#: man-pages/man3/errno.3:198
msgid "Bad file descriptor (POSIX.1-2001)."
msgstr ""

#. type: TP
#: man-pages/man3/errno.3:198
#, no-wrap
msgid "B<EBADFD>"
msgstr ""

#. type: Plain text
#: man-pages/man3/errno.3:201
msgid "File descriptor in bad state."
msgstr ""

#. type: TP
#: man-pages/man3/errno.3:201
#, no-wrap
msgid "B<EBADMSG>"
msgstr ""

#. type: Plain text
#: man-pages/man3/errno.3:204
msgid "Bad message (POSIX.1-2001)."
msgstr ""

#. type: TP
#: man-pages/man3/errno.3:204
#, no-wrap
msgid "B<EBADR>"
msgstr ""

#. type: Plain text
#: man-pages/man3/errno.3:207
msgid "Invalid request descriptor."
msgstr ""

#. type: TP
#: man-pages/man3/errno.3:207
#, no-wrap
msgid "B<EBADRQC>"
msgstr ""

#. type: Plain text
#: man-pages/man3/errno.3:210
msgid "Invalid request code."
msgstr ""

#. type: TP
#: man-pages/man3/errno.3:210
#, no-wrap
msgid "B<EBADSLT>"
msgstr ""

#.  EBFONT is defined but appears not to be used by kernel or glibc.
#. type: Plain text
#: man-pages/man3/errno.3:214
msgid "Invalid slot."
msgstr ""

#. type: TP
#: man-pages/man3/errno.3:214
#, no-wrap
msgid "B<EBUSY>"
msgstr ""

#. type: Plain text
#: man-pages/man3/errno.3:217
msgid "Device or resource busy (POSIX.1-2001)."
msgstr ""

#. type: TP
#: man-pages/man3/errno.3:217
#, no-wrap
msgid "B<ECANCELED>"
msgstr ""

#. type: Plain text
#: man-pages/man3/errno.3:220
msgid "Operation canceled (POSIX.1-2001)."
msgstr ""

#. type: TP
#: man-pages/man3/errno.3:220
#, no-wrap
msgid "B<ECHILD>"
msgstr ""

#. type: Plain text
#: man-pages/man3/errno.3:223
msgid "No child processes (POSIX.1-2001)."
msgstr ""

#. type: TP
#: man-pages/man3/errno.3:223
#, no-wrap
msgid "B<ECHRNG>"
msgstr ""

#. type: Plain text
#: man-pages/man3/errno.3:226
msgid "Channel number out of range."
msgstr ""

#. type: TP
#: man-pages/man3/errno.3:226
#, no-wrap
msgid "B<ECOMM>"
msgstr ""

#. type: Plain text
#: man-pages/man3/errno.3:229
msgid "Communication error on send."
msgstr ""

#. type: TP
#: man-pages/man3/errno.3:229
#, no-wrap
msgid "B<ECONNABORTED>"
msgstr ""

#. type: Plain text
#: man-pages/man3/errno.3:232
msgid "Connection aborted (POSIX.1-2001)."
msgstr ""

#. type: TP
#: man-pages/man3/errno.3:232
#, no-wrap
msgid "B<ECONNREFUSED>"
msgstr ""

#. type: Plain text
#: man-pages/man3/errno.3:235
msgid "Connection refused (POSIX.1-2001)."
msgstr ""

#. type: TP
#: man-pages/man3/errno.3:235
#, no-wrap
msgid "B<ECONNRESET>"
msgstr ""

#. type: Plain text
#: man-pages/man3/errno.3:238
msgid "Connection reset (POSIX.1-2001)."
msgstr ""

#. type: TP
#: man-pages/man3/errno.3:238
#, no-wrap
msgid "B<EDEADLK>"
msgstr ""

#. type: Plain text
#: man-pages/man3/errno.3:241
msgid "Resource deadlock avoided (POSIX.1-2001)."
msgstr ""

#. type: TP
#: man-pages/man3/errno.3:241
#, no-wrap
msgid "B<EDEADLOCK>"
msgstr ""

#. type: Plain text
#: man-pages/man3/errno.3:245
msgid "Synonym for B<EDEADLK>."
msgstr ""

#. type: TP
#: man-pages/man3/errno.3:245
#, no-wrap
msgid "B<EDESTADDRREQ>"
msgstr ""

#. type: Plain text
#: man-pages/man3/errno.3:248
msgid "Destination address required (POSIX.1-2001)."
msgstr ""

#. type: TP
#: man-pages/man3/errno.3:248
#, no-wrap
msgid "B<EDOM>"
msgstr ""

#.  EDOTDOT is defined but appears to be unused
#. type: Plain text
#: man-pages/man3/errno.3:252
msgid "Mathematics argument out of domain of function (POSIX.1, C99)."
msgstr ""

#. type: TP
#: man-pages/man3/errno.3:252
#, no-wrap
msgid "B<EDQUOT>"
msgstr ""

#.  POSIX just says "Reserved"
#. type: Plain text
#: man-pages/man3/errno.3:256
msgid "Disk quota exceeded (POSIX.1-2001)."
msgstr ""

#. type: Plain text
#: man-pages/man3/errno.3:259
msgid "File exists (POSIX.1-2001)."
msgstr ""

#. type: Plain text
#: man-pages/man3/errno.3:262
msgid "Bad address (POSIX.1-2001)."
msgstr ""

#. type: TP
#: man-pages/man3/errno.3:262
#, no-wrap
msgid "B<EFBIG>"
msgstr ""

#. type: Plain text
#: man-pages/man3/errno.3:265
msgid "File too large (POSIX.1-2001)."
msgstr ""

#. type: TP
#: man-pages/man3/errno.3:265
#, no-wrap
msgid "B<EHOSTDOWN>"
msgstr ""

#. type: Plain text
#: man-pages/man3/errno.3:268
msgid "Host is down."
msgstr ""

#. type: TP
#: man-pages/man3/errno.3:268
#, no-wrap
msgid "B<EHOSTUNREACH>"
msgstr ""

#. type: Plain text
#: man-pages/man3/errno.3:271
msgid "Host is unreachable (POSIX.1-2001)."
msgstr ""

#. type: TP
#: man-pages/man3/errno.3:271
#, no-wrap
msgid "B<EHWPOISON>"
msgstr ""

#. type: Plain text
#: man-pages/man3/errno.3:274
msgid "Memory page has hardware error."
msgstr ""

#. type: TP
#: man-pages/man3/errno.3:274
#, no-wrap
msgid "B<EIDRM>"
msgstr ""

#. type: Plain text
#: man-pages/man3/errno.3:277
msgid "Identifier removed (POSIX.1-2001)."
msgstr ""

#. type: TP
#: man-pages/man3/errno.3:277
#, no-wrap
msgid "B<EILSEQ>"
msgstr ""

#. type: Plain text
#: man-pages/man3/errno.3:280
msgid "Invalid or incomplete multibyte or wide character (POSIX.1, C99)."
msgstr ""

#. type: Plain text
#: man-pages/man3/errno.3:283
msgid ""
"The text shown here is the glibc error description; in POSIX.1, this error "
"is described as \"Illegal byte sequence\"."
msgstr ""

#. type: TP
#: man-pages/man3/errno.3:283
#, no-wrap
msgid "B<EINPROGRESS>"
msgstr ""

#. type: Plain text
#: man-pages/man3/errno.3:286
msgid "Operation in progress (POSIX.1-2001)."
msgstr ""

#. type: Plain text
#: man-pages/man3/errno.3:290
msgid "Interrupted function call (POSIX.1-2001); see B<signal>(7)."
msgstr ""

#. type: Plain text
#: man-pages/man3/errno.3:293
msgid "Invalid argument (POSIX.1-2001)."
msgstr ""

#. type: Plain text
#: man-pages/man3/errno.3:296
msgid "Input/output error (POSIX.1-2001)."
msgstr ""

#. type: TP
#: man-pages/man3/errno.3:296
#, no-wrap
msgid "B<EISCONN>"
msgstr ""

#. type: Plain text
#: man-pages/man3/errno.3:299
msgid "Socket is connected (POSIX.1-2001)."
msgstr ""

#. type: Plain text
#: man-pages/man3/errno.3:302
msgid "Is a directory (POSIX.1-2001)."
msgstr ""

#. type: TP
#: man-pages/man3/errno.3:302
#, no-wrap
msgid "B<EISNAM>"
msgstr ""

#. type: Plain text
#: man-pages/man3/errno.3:305
msgid "Is a named type file."
msgstr ""

#. type: TP
#: man-pages/man3/errno.3:305
#, no-wrap
msgid "B<EKEYEXPIRED>"
msgstr ""

#. type: Plain text
#: man-pages/man3/errno.3:308
msgid "Key has expired."
msgstr ""

#. type: TP
#: man-pages/man3/errno.3:308
#, no-wrap
msgid "B<EKEYREJECTED>"
msgstr ""

#. type: Plain text
#: man-pages/man3/errno.3:311
msgid "Key was rejected by service."
msgstr ""

#. type: TP
#: man-pages/man3/errno.3:311
#, no-wrap
msgid "B<EKEYREVOKED>"
msgstr ""

#. type: Plain text
#: man-pages/man3/errno.3:314
msgid "Key has been revoked."
msgstr ""

#. type: TP
#: man-pages/man3/errno.3:314
#, no-wrap
msgid "B<EL2HLT>"
msgstr ""

#. type: Plain text
#: man-pages/man3/errno.3:317
msgid "Level 2 halted."
msgstr ""

#. type: TP
#: man-pages/man3/errno.3:317
#, no-wrap
msgid "B<EL2NSYNC>"
msgstr ""

#. type: Plain text
#: man-pages/man3/errno.3:320
msgid "Level 2 not synchronized."
msgstr ""

#. type: TP
#: man-pages/man3/errno.3:320
#, no-wrap
msgid "B<EL3HLT>"
msgstr ""

#. type: Plain text
#: man-pages/man3/errno.3:323
msgid "Level 3 halted."
msgstr ""

#. type: TP
#: man-pages/man3/errno.3:323
#, no-wrap
msgid "B<EL3RST>"
msgstr ""

#. type: Plain text
#: man-pages/man3/errno.3:326
msgid "Level 3 reset."
msgstr ""

#. type: TP
#: man-pages/man3/errno.3:326
#, no-wrap
msgid "B<ELIBACC>"
msgstr ""

#. type: Plain text
#: man-pages/man3/errno.3:329
msgid "Cannot access a needed shared library."
msgstr ""

#. type: Plain text
#: man-pages/man3/errno.3:332
msgid "Accessing a corrupted shared library."
msgstr ""

#. type: TP
#: man-pages/man3/errno.3:332
#, no-wrap
msgid "B<ELIBMAX>"
msgstr ""

#. type: Plain text
#: man-pages/man3/errno.3:335
msgid "Attempting to link in too many shared libraries."
msgstr ""

#. type: TP
#: man-pages/man3/errno.3:335
#, no-wrap
msgid "B<ELIBSCN>"
msgstr ""

#. type: Plain text
#: man-pages/man3/errno.3:338
msgid "\\&.lib section in a.out corrupted"
msgstr ""

#. type: TP
#: man-pages/man3/errno.3:338
#, no-wrap
msgid "B<ELIBEXEC>"
msgstr ""

#. type: Plain text
#: man-pages/man3/errno.3:341
msgid "Cannot exec a shared library directly."
msgstr ""

#. type: TP
#: man-pages/man3/errno.3:341
#, no-wrap
msgid "B<ELNRANGE>"
msgstr ""

#.  ELNRNG appears to be used by a few drivers
#. type: Plain text
#: man-pages/man3/errno.3:345
msgid "Link number out of range."
msgstr ""

#. type: Plain text
#: man-pages/man3/errno.3:348
msgid "Too many levels of symbolic links (POSIX.1-2001)."
msgstr ""

#. type: TP
#: man-pages/man3/errno.3:348
#, no-wrap
msgid "B<EMEDIUMTYPE>"
msgstr ""

#. type: Plain text
#: man-pages/man3/errno.3:351
msgid "Wrong medium type."
msgstr ""

#. type: Plain text
#: man-pages/man3/errno.3:358
msgid ""
"Too many open files (POSIX.1-2001).  Commonly caused by exceeding the "
"B<RLIMIT_NOFILE> resource limit described in B<getrlimit>(2)."
msgstr ""

#. type: TP
#: man-pages/man3/errno.3:358
#, no-wrap
msgid "B<EMLINK>"
msgstr ""

#. type: Plain text
#: man-pages/man3/errno.3:361
msgid "Too many links (POSIX.1-2001)."
msgstr ""

#. type: TP
#: man-pages/man3/errno.3:361
#, no-wrap
msgid "B<EMSGSIZE>"
msgstr ""

#. type: Plain text
#: man-pages/man3/errno.3:364
msgid "Message too long (POSIX.1-2001)."
msgstr ""

#. type: TP
#: man-pages/man3/errno.3:364
#, no-wrap
msgid "B<EMULTIHOP>"
msgstr ""

#.  POSIX says "Reserved"
#. type: Plain text
#: man-pages/man3/errno.3:368
msgid "Multihop attempted (POSIX.1-2001)."
msgstr ""

#.  ENAVAIL is defined, but appears not to be used
#. type: Plain text
#: man-pages/man3/errno.3:372
msgid "Filename too long (POSIX.1-2001)."
msgstr ""

#. type: TP
#: man-pages/man3/errno.3:372
#, no-wrap
msgid "B<ENETDOWN>"
msgstr ""

#. type: Plain text
#: man-pages/man3/errno.3:375
msgid "Network is down (POSIX.1-2001)."
msgstr ""

#. type: TP
#: man-pages/man3/errno.3:375
#, no-wrap
msgid "B<ENETRESET>"
msgstr ""

#. type: Plain text
#: man-pages/man3/errno.3:378
msgid "Connection aborted by network (POSIX.1-2001)."
msgstr ""

#. type: TP
#: man-pages/man3/errno.3:378
#, no-wrap
msgid "B<ENETUNREACH>"
msgstr ""

#. type: Plain text
#: man-pages/man3/errno.3:381
msgid "Network unreachable (POSIX.1-2001)."
msgstr ""

#. type: Plain text
#: man-pages/man3/errno.3:388
msgid ""
"Too many open files in system (POSIX.1-2001).  On Linux, this is probably a "
"result of encountering the I</proc/sys/fs/file-max> limit (see B<proc>(5))."
msgstr ""

#. type: TP
#: man-pages/man3/errno.3:388
#, no-wrap
msgid "B<ENOANO>"
msgstr ""

#.  ENOANO appears to be used by a few drivers
#. type: Plain text
#: man-pages/man3/errno.3:392
msgid "No anode."
msgstr ""

#. type: TP
#: man-pages/man3/errno.3:392
#, no-wrap
msgid "B<ENOBUFS>"
msgstr ""

#.  ENOCSI is defined but appears to be unused.
#. type: Plain text
#: man-pages/man3/errno.3:396
msgid "No buffer space available (POSIX.1 (XSI STREAMS option))."
msgstr ""

#. type: TP
#: man-pages/man3/errno.3:396
#, no-wrap
msgid "B<ENODATA>"
msgstr ""

#. type: Plain text
#: man-pages/man3/errno.3:399
msgid "No message is available on the STREAM head read queue (POSIX.1-2001)."
msgstr ""

#. type: Plain text
#: man-pages/man3/errno.3:402
msgid "No such device (POSIX.1-2001)."
msgstr ""

#. type: Plain text
#: man-pages/man3/errno.3:405
msgid "No such file or directory (POSIX.1-2001)."
msgstr ""

#. type: Plain text
#: man-pages/man3/errno.3:409
msgid ""
"Typically, this error results when a specified pathname does not exist, or "
"one of the components in the directory prefix of a pathname does not exist, "
"or the specified pathname is a dangling symbolic link."
msgstr ""

#. type: Plain text
#: man-pages/man3/errno.3:412
msgid "Exec format error (POSIX.1-2001)."
msgstr ""

#. type: TP
#: man-pages/man3/errno.3:412
#, no-wrap
msgid "B<ENOKEY>"
msgstr ""

#. type: Plain text
#: man-pages/man3/errno.3:415
msgid "Required key not available."
msgstr ""

#. type: TP
#: man-pages/man3/errno.3:415
#, no-wrap
msgid "B<ENOLCK>"
msgstr ""

#. type: Plain text
#: man-pages/man3/errno.3:418
msgid "No locks available (POSIX.1-2001)."
msgstr ""

#. type: TP
#: man-pages/man3/errno.3:418
#, no-wrap
msgid "B<ENOLINK>"
msgstr ""

#.  POSIX says "Reserved"
#. type: Plain text
#: man-pages/man3/errno.3:422
msgid "Link has been severed (POSIX.1-2001)."
msgstr ""

#. type: TP
#: man-pages/man3/errno.3:422
#, no-wrap
msgid "B<ENOMEDIUM>"
msgstr ""

#. type: Plain text
#: man-pages/man3/errno.3:425
msgid "No medium found."
msgstr ""

#. type: Plain text
#: man-pages/man3/errno.3:428
msgid "Not enough space/cannot allocate memory (POSIX.1-2001)."
msgstr ""

#. type: TP
#: man-pages/man3/errno.3:428
#, no-wrap
msgid "B<ENOMSG>"
msgstr ""

#. type: Plain text
#: man-pages/man3/errno.3:431
msgid "No message of the desired type (POSIX.1-2001)."
msgstr ""

#. type: TP
#: man-pages/man3/errno.3:431
#, no-wrap
msgid "B<ENONET>"
msgstr ""

#. type: Plain text
#: man-pages/man3/errno.3:434
msgid "Machine is not on the network."
msgstr ""

#. type: TP
#: man-pages/man3/errno.3:434
#, no-wrap
msgid "B<ENOPKG>"
msgstr ""

#. type: Plain text
#: man-pages/man3/errno.3:437
msgid "Package not installed."
msgstr ""

#. type: TP
#: man-pages/man3/errno.3:437
#, no-wrap
msgid "B<ENOPROTOOPT>"
msgstr ""

#. type: Plain text
#: man-pages/man3/errno.3:440
msgid "Protocol not available (POSIX.1-2001)."
msgstr ""

#. type: Plain text
#: man-pages/man3/errno.3:443
msgid "No space left on device (POSIX.1-2001)."
msgstr ""

#. type: TP
#: man-pages/man3/errno.3:443
#, no-wrap
msgid "B<ENOSR>"
msgstr ""

#. type: Plain text
#: man-pages/man3/errno.3:446
msgid "No STREAM resources (POSIX.1 (XSI STREAMS option))."
msgstr ""

#. type: TP
#: man-pages/man3/errno.3:446
#, no-wrap
msgid "B<ENOSTR>"
msgstr ""

#. type: Plain text
#: man-pages/man3/errno.3:449
msgid "Not a STREAM (POSIX.1 (XSI STREAMS option))."
msgstr ""

#. type: Plain text
#: man-pages/man3/errno.3:452
msgid "Function not implemented (POSIX.1-2001)."
msgstr ""

#. type: TP
#: man-pages/man3/errno.3:452
#, no-wrap
msgid "B<ENOTBLK>"
msgstr ""

#. type: Plain text
#: man-pages/man3/errno.3:455
msgid "Block device required."
msgstr ""

#. type: TP
#: man-pages/man3/errno.3:455
#, no-wrap
msgid "B<ENOTCONN>"
msgstr ""

#. type: Plain text
#: man-pages/man3/errno.3:458
msgid "The socket is not connected (POSIX.1-2001)."
msgstr ""

#. type: Plain text
#: man-pages/man3/errno.3:461
msgid "Not a directory (POSIX.1-2001)."
msgstr ""

#. type: TP
#: man-pages/man3/errno.3:461
#, no-wrap
msgid "B<ENOTEMPTY>"
msgstr ""

#.  ENOTNAM is defined but appears to be unused.
#. type: Plain text
#: man-pages/man3/errno.3:465
msgid "Directory not empty (POSIX.1-2001)."
msgstr ""

#. type: TP
#: man-pages/man3/errno.3:465
#, no-wrap
msgid "B<ENOTRECOVERABLE>"
msgstr ""

#. type: Plain text
#: man-pages/man3/errno.3:468
msgid "State not recoverable (POSIX.1-2008)."
msgstr ""

#. type: TP
#: man-pages/man3/errno.3:468
#, no-wrap
msgid "B<ENOTSOCK>"
msgstr ""

#. type: Plain text
#: man-pages/man3/errno.3:471
msgid "Not a socket (POSIX.1-2001)."
msgstr ""

#. type: TP
#: man-pages/man3/errno.3:471
#, no-wrap
msgid "B<ENOTSUP>"
msgstr ""

#. type: Plain text
#: man-pages/man3/errno.3:474
msgid "Operation not supported (POSIX.1-2001)."
msgstr ""

#. type: TP
#: man-pages/man3/errno.3:474
#, no-wrap
msgid "B<ENOTTY>"
msgstr ""

#. type: Plain text
#: man-pages/man3/errno.3:477
msgid "Inappropriate I/O control operation (POSIX.1-2001)."
msgstr ""

#. type: TP
#: man-pages/man3/errno.3:477
#, no-wrap
msgid "B<ENOTUNIQ>"
msgstr ""

#. type: Plain text
#: man-pages/man3/errno.3:480
msgid "Name not unique on network."
msgstr ""

#. type: TP
#: man-pages/man3/errno.3:480
#, no-wrap
msgid "B<ENXIO>"
msgstr ""

#. type: Plain text
#: man-pages/man3/errno.3:483
msgid "No such device or address (POSIX.1-2001)."
msgstr ""

#. type: TP
#: man-pages/man3/errno.3:483
#, no-wrap
msgid "B<EOPNOTSUPP>"
msgstr ""

#. type: Plain text
#: man-pages/man3/errno.3:486
msgid "Operation not supported on socket (POSIX.1-2001)."
msgstr ""

#. type: Plain text
#: man-pages/man3/errno.3:492
msgid ""
"(B<ENOTSUP> and B<EOPNOTSUPP> have the same value on Linux, but according to"
" POSIX.1 these error values should be distinct.)"
msgstr ""

#. type: TP
#: man-pages/man3/errno.3:492
#, no-wrap
msgid "B<EOVERFLOW>"
msgstr ""

#. type: Plain text
#: man-pages/man3/errno.3:495
msgid "Value too large to be stored in data type (POSIX.1-2001)."
msgstr ""

#. type: TP
#: man-pages/man3/errno.3:495
#, no-wrap
msgid "B<EOWNERDEAD>"
msgstr ""

#.  Used at least by the user-space side of rubost mutexes
#. type: Plain text
#: man-pages/man3/errno.3:499
msgid "Owner died (POSIX.1-2008)."
msgstr ""

#. type: Plain text
#: man-pages/man3/errno.3:502
msgid "Operation not permitted (POSIX.1-2001)."
msgstr ""

#. type: TP
#: man-pages/man3/errno.3:502
#, no-wrap
msgid "B<EPFNOSUPPORT>"
msgstr ""

#. type: Plain text
#: man-pages/man3/errno.3:505
msgid "Protocol family not supported."
msgstr ""

#. type: TP
#: man-pages/man3/errno.3:505
#, no-wrap
msgid "B<EPIPE>"
msgstr ""

#. type: Plain text
#: man-pages/man3/errno.3:508
msgid "Broken pipe (POSIX.1-2001)."
msgstr ""

#. type: TP
#: man-pages/man3/errno.3:508
#, no-wrap
msgid "B<EPROTO>"
msgstr ""

#. type: Plain text
#: man-pages/man3/errno.3:511
msgid "Protocol error (POSIX.1-2001)."
msgstr ""

#. type: TP
#: man-pages/man3/errno.3:511
#, no-wrap
msgid "B<EPROTONOSUPPORT>"
msgstr ""

#. type: Plain text
#: man-pages/man3/errno.3:514
msgid "Protocol not supported (POSIX.1-2001)."
msgstr ""

#. type: TP
#: man-pages/man3/errno.3:514
#, no-wrap
msgid "B<EPROTOTYPE>"
msgstr ""

#. type: Plain text
#: man-pages/man3/errno.3:517
msgid "Protocol wrong type for socket (POSIX.1-2001)."
msgstr ""

#. type: TP
#: man-pages/man3/errno.3:517
#, no-wrap
msgid "B<ERANGE>"
msgstr ""

#. type: Plain text
#: man-pages/man3/errno.3:520
msgid "Result too large (POSIX.1, C99)."
msgstr ""

#. type: TP
#: man-pages/man3/errno.3:520
#, no-wrap
msgid "B<EREMCHG>"
msgstr ""

#. type: Plain text
#: man-pages/man3/errno.3:523
msgid "Remote address changed."
msgstr ""

#. type: TP
#: man-pages/man3/errno.3:523
#, no-wrap
msgid "B<EREMOTE>"
msgstr ""

#. type: Plain text
#: man-pages/man3/errno.3:526
msgid "Object is remote."
msgstr ""

#. type: TP
#: man-pages/man3/errno.3:526
#, no-wrap
msgid "B<EREMOTEIO>"
msgstr ""

#. type: Plain text
#: man-pages/man3/errno.3:529
msgid "Remote I/O error."
msgstr ""

#. type: TP
#: man-pages/man3/errno.3:529
#, no-wrap
msgid "B<ERESTART>"
msgstr ""

#. type: Plain text
#: man-pages/man3/errno.3:532
msgid "Interrupted system call should be restarted."
msgstr ""

#. type: TP
#: man-pages/man3/errno.3:532
#, no-wrap
msgid "B<ERFKILL>"
msgstr ""

#.  ERFKILL appears to be used by various drivers
#. type: Plain text
#: man-pages/man3/errno.3:536
msgid "Operation not possible due to RF-kill."
msgstr ""

#. type: TP
#: man-pages/man3/errno.3:536
#, no-wrap
msgid "B<EROFS>"
msgstr ""

#. type: Plain text
#: man-pages/man3/errno.3:539
msgid "Read-only filesystem (POSIX.1-2001)."
msgstr ""

#. type: TP
#: man-pages/man3/errno.3:539
#, no-wrap
msgid "B<ESHUTDOWN>"
msgstr ""

#. type: Plain text
#: man-pages/man3/errno.3:542
msgid "Cannot send after transport endpoint shutdown."
msgstr ""

#. type: TP
#: man-pages/man3/errno.3:542
#, no-wrap
msgid "B<ESPIPE>"
msgstr ""

#. type: Plain text
#: man-pages/man3/errno.3:545
msgid "Invalid seek (POSIX.1-2001)."
msgstr ""

#. type: TP
#: man-pages/man3/errno.3:545
#, no-wrap
msgid "B<ESOCKTNOSUPPORT>"
msgstr ""

#. type: Plain text
#: man-pages/man3/errno.3:548
msgid "Socket type not supported."
msgstr ""

#. type: TP
#: man-pages/man3/errno.3:548
#, no-wrap
msgid "B<ESRCH>"
msgstr ""

#.  ESRMNT is defined but appears not to be used
#. type: Plain text
#: man-pages/man3/errno.3:552
msgid "No such process (POSIX.1-2001)."
msgstr ""

#. type: TP
#: man-pages/man3/errno.3:552
#, no-wrap
msgid "B<ESTALE>"
msgstr ""

#. type: Plain text
#: man-pages/man3/errno.3:555
msgid "Stale file handle (POSIX.1-2001)."
msgstr ""

#. type: Plain text
#: man-pages/man3/errno.3:557
msgid "This error can occur for NFS and for other filesystems."
msgstr ""

#. type: TP
#: man-pages/man3/errno.3:557
#, no-wrap
msgid "B<ESTRPIPE>"
msgstr ""

#. type: Plain text
#: man-pages/man3/errno.3:560
msgid "Streams pipe error."
msgstr ""

#. type: TP
#: man-pages/man3/errno.3:560
#, no-wrap
msgid "B<ETIME>"
msgstr ""

#. type: Plain text
#: man-pages/man3/errno.3:564
msgid "Timer expired (POSIX.1 (XSI STREAMS option))."
msgstr ""

#. type: Plain text
#: man-pages/man3/errno.3:568
msgid "(POSIX.1 says \"STREAM B<ioctl>(2)  timeout\".)"
msgstr ""

#. type: TP
#: man-pages/man3/errno.3:568
#, no-wrap
msgid "B<ETIMEDOUT>"
msgstr ""

#. type: Plain text
#: man-pages/man3/errno.3:571
msgid "Connection timed out (POSIX.1-2001)."
msgstr ""

#. type: TP
#: man-pages/man3/errno.3:571
#, no-wrap
msgid "B<ETOOMANYREFS>"
msgstr ""

#.  ETOOMANYREFS seems to be used in net/unix/af_unix.c
#. type: Plain text
#: man-pages/man3/errno.3:575
msgid "Too many references: cannot splice."
msgstr ""

#. type: Plain text
#: man-pages/man3/errno.3:578
msgid "Text file busy (POSIX.1-2001)."
msgstr ""

#. type: TP
#: man-pages/man3/errno.3:578
#, no-wrap
msgid "B<EUCLEAN>"
msgstr ""

#. type: Plain text
#: man-pages/man3/errno.3:581
msgid "Structure needs cleaning."
msgstr ""

#. type: TP
#: man-pages/man3/errno.3:581
#, no-wrap
msgid "B<EUNATCH>"
msgstr ""

#. type: Plain text
#: man-pages/man3/errno.3:584
msgid "Protocol driver not attached."
msgstr ""

#. type: TP
#: man-pages/man3/errno.3:584
#, no-wrap
msgid "B<EUSERS>"
msgstr ""

#. type: Plain text
#: man-pages/man3/errno.3:587
msgid "Too many users."
msgstr ""

#. type: TP
#: man-pages/man3/errno.3:587
#, no-wrap
msgid "B<EWOULDBLOCK>"
msgstr ""

#. type: Plain text
#: man-pages/man3/errno.3:592
msgid ""
"Operation would block (may be same value as B<EAGAIN>)  (POSIX.1-2001)."
msgstr ""

#. type: TP
#: man-pages/man3/errno.3:592
#, no-wrap
msgid "B<EXDEV>"
msgstr ""

#. type: Plain text
#: man-pages/man3/errno.3:595
msgid "Improper link (POSIX.1-2001)."
msgstr ""

#. type: TP
#: man-pages/man3/errno.3:595
#, no-wrap
msgid "B<EXFULL>"
msgstr ""

#. type: Plain text
#: man-pages/man3/errno.3:598
msgid "Exchange full."
msgstr ""

#. type: Plain text
#: man-pages/man3/errno.3:600
msgid "A common mistake is to do"
msgstr ""

#. type: Plain text
#: man-pages/man3/errno.3:607
#, no-wrap
msgid ""
"if (somecall() == -1) {\n"
"    printf(\"somecall() failed\\en\");\n"
"    if (errno == ...) { ... }\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/errno.3:619
msgid ""
"where I<errno> no longer needs to have the value it had upon return from "
"I<somecall>()  (i.e., it may have been changed by the B<printf>(3)).  If the"
" value of I<errno> should be preserved across a library call, it must be "
"saved:"
msgstr ""

#. type: Plain text
#: man-pages/man3/errno.3:627
#, no-wrap
msgid ""
"if (somecall() == -1) {\n"
"    int errsv = errno;\n"
"    printf(\"somecall() failed\\en\");\n"
"    if (errsv == ...) { ... }\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/errno.3:642
msgid ""
"On some ancient systems, I<E<lt>errno.hE<gt>> was not present or did not "
"declare I<errno>, so that it was necessary to declare I<errno> manually "
"(i.e., I<extern int errno>).  B<Do not do this>.  It long ago ceased to be "
"necessary, and it will cause problems with modern versions of the C library."
msgstr ""

#.  In the moreutils package
#. type: Plain text
#: man-pages/man3/errno.3:647
msgid "B<errno>(1), B<err>(3), B<error>(3), B<perror>(3), B<strerror>(3)"
msgstr ""

#. type: TH
#: man-pages/man3/erfc.3:26
#, no-wrap
msgid "ERFC"
msgstr ""

#. type: Plain text
#: man-pages/man3/erfc.3:29
msgid "erfc, erfcf, erfcl - complementary error function"
msgstr ""

#. type: Plain text
#: man-pages/man3/erfc.3:36
#, no-wrap
msgid ""
"B<double erfc(double >I<x>B<);>\n"
"B<float erfcf(float >I<x>B<);>\n"
"B<long double erfcl(long double >I<x>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/erfc.3:47
msgid "B<erfc>():"
msgstr ""

#. type: Plain text
#: man-pages/man3/erfc.3:51
#, no-wrap
msgid ""
"_ISOC99_SOURCE || _POSIX_C_SOURCE\\ E<gt>=\\ 200112L || _XOPEN_SOURCE\n"
"    || /* Since glibc 2.19: */ _DEFAULT_SOURCE\n"
"    || /* Glibc versions E<lt>= 2.19: */ _BSD_SOURCE || _SVID_SOURCE\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/erfc.3:55
msgid "B<erfcf>(), B<erfcl>():"
msgstr ""

#. type: Plain text
#: man-pages/man3/erfc.3:65
msgid ""
"These functions return the complementary error function of I<x>, that is, "
"1.0 - erf(x)."
msgstr ""

#. type: Plain text
#: man-pages/man3/erfc.3:69
msgid ""
"On success, these functions return the complementary error function of I<x>,"
" a value in the range [0,2]."
msgstr ""

#. type: Plain text
#: man-pages/man3/erfc.3:77
msgid "If I<x> is +0 or -0, 1 is returned."
msgstr ""

#. type: Plain text
#: man-pages/man3/erfc.3:82
msgid "If I<x> is positive infinity, +0 is returned."
msgstr ""

#. type: Plain text
#: man-pages/man3/erfc.3:87
msgid "If I<x> is negative infinity, +2 is returned."
msgstr ""

#. type: Plain text
#: man-pages/man3/erfc.3:90
msgid ""
"If the function result underflows and produces an unrepresentable value, the"
" return value is 0.0."
msgstr ""

#.  e.g., erfc(27) on x86-32
#. type: Plain text
#: man-pages/man3/erfc.3:96
msgid ""
"If the function result underflows but produces a representable (i.e., "
"subnormal) value, that value is returned, and a range error occurs."
msgstr ""

#. type: TP
#: man-pages/man3/erfc.3:103
#, no-wrap
msgid "Range error: result underflow (result is subnormal)"
msgstr ""

#.  .I errno
#.  is set to
#.  .BR ERANGE .
#. type: Plain text
#: man-pages/man3/erfc.3:111
msgid "An underflow floating-point exception (B<FE_UNDERFLOW>)  is raised."
msgstr ""

#.  FIXME . Is it intentional that these functions do not set errno?
#.  Bug raised: http://sources.redhat.com/bugzilla/show_bug.cgi?id=6785
#. type: Plain text
#: man-pages/man3/erfc.3:116
msgid "These functions do not set I<errno>."
msgstr ""

#. type: tbl table
#: man-pages/man3/erfc.3:128
#, no-wrap
msgid ""
"B<erfc>(),\n"
"B<erfcf>(),\n"
"B<erfcl>()"
msgstr ""

#. type: Plain text
#: man-pages/man3/erfc.3:147
msgid ""
"The B<erfc>(), B<erfcf>(), and B<erfcl>()  functions are provided to avoid "
"the loss accuracy that would occur for the calculation 1-erf(x) for large "
"values of I<x> (for which the value of erf(x) approaches 1)."
msgstr ""

#. type: Plain text
#: man-pages/man3/erfc.3:150
msgid "B<cerf>(3), B<erf>(3), B<exp>(3)"
msgstr ""

#. type: TH
#: man-pages/man3/exp10.3:35
#, no-wrap
msgid "EXP10"
msgstr ""

#. type: Plain text
#: man-pages/man3/exp10.3:38
msgid "exp10, exp10f, exp10l - base-10 exponential function"
msgstr ""

#. type: Plain text
#: man-pages/man3/exp10.3:42
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>         /* See feature_test_macros(7) */\n"
"B<#include E<lt>math.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/exp10.3:46
#, no-wrap
msgid ""
"B<double exp10(double >I<x>B<);>\n"
"B<float exp10f(float >I<x>B<);>\n"
"B<long double exp10l(long double >I<x>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/exp10.3:53
msgid "These functions return the value of 10 raised to the power of I<x>."
msgstr ""

#. type: Plain text
#: man-pages/man3/exp10.3:56
msgid ""
"On success, these functions return the base-10 exponential value of I<x>."
msgstr ""

#. type: tbl table
#: man-pages/man3/exp10.3:82
#, no-wrap
msgid ""
"B<exp10>(),\n"
"B<exp10f>(),\n"
"B<exp10l>()"
msgstr ""

#.  http://sources.redhat.com/bugzilla/show_bug.cgi?id=6787
#. type: Plain text
#: man-pages/man3/exp10.3:93
msgid ""
"Prior to version 2.19, the glibc implementation of these functions did not "
"set I<errno> to B<ERANGE> when an underflow error occurred."
msgstr ""

#. type: Plain text
#: man-pages/man3/exp10.3:98
msgid "B<cbrt>(3), B<exp>(3), B<exp2>(3), B<log10>(3), B<sqrt>(3)"
msgstr ""

#. type: TH
#: man-pages/man3/expm1.3:30
#, no-wrap
msgid "EXPM1"
msgstr ""

#. type: Plain text
#: man-pages/man3/expm1.3:33
msgid "expm1, expm1f, expm1l - exponential minus 1"
msgstr ""

#. type: Plain text
#: man-pages/man3/expm1.3:40
#, no-wrap
msgid ""
"B<double expm1(double >I<x>B<);>\n"
"B<float expm1f(float >I<x>B<);>\n"
"B<long double expm1l(long double >I<x>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/expm1.3:51
msgid "B<expm1>():"
msgstr ""

#.     || _XOPEN_SOURCE\ &&\ _XOPEN_SOURCE_EXTENDED
#. type: Plain text
#: man-pages/man3/expm1.3:57
#, no-wrap
msgid ""
"_ISOC99_SOURCE || _POSIX_C_SOURCE\\ E<gt>=\\ 200112L\n"
"    || _XOPEN_SOURCE\\ E<gt>=\\ 500\n"
"    || /* Since glibc 2.19: */ _DEFAULT_SOURCE\n"
"    || /* Glibc versions E<lt>= 2.19: */ _BSD_SOURCE || _SVID_SOURCE\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/expm1.3:61
msgid "B<expm1f>(), B<expm1l>():"
msgstr ""

#. type: Plain text
#: man-pages/man3/expm1.3:69
msgid "These functions return a value equivalent to"
msgstr ""

#. type: Plain text
#: man-pages/man3/expm1.3:72
#, no-wrap
msgid "    exp(x) - 1\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/expm1.3:81
msgid ""
"The result is computed in a way that is accurate even if the value of I<x> "
"is near zero\\(ema case where I<exp(x) - 1> would be inaccurate due to "
"subtraction of two numbers that are nearly equal."
msgstr ""

#. type: Plain text
#: man-pages/man3/expm1.3:84
msgid "On success, these functions return I<exp(x)\\ -\\ 1>."
msgstr ""

#. type: Plain text
#: man-pages/man3/expm1.3:94
msgid "If I<x> is +0 (-0), +0 (-0) is returned."
msgstr ""

#. type: Plain text
#: man-pages/man3/expm1.3:102
msgid "If I<x> is negative infinity, -1 is returned."
msgstr ""

#. type: Plain text
#: man-pages/man3/expm1.3:110
msgid ""
"If the result overflows, a range error occurs, and the functions return "
"-B<HUGE_VAL>, -B<HUGE_VALF>, or -B<HUGE_VALL>, respectively."
msgstr ""

#.  POSIX.1 specifies an optional range error (underflow) if
#.  x is subnormal.  Glibc does not implement this.
#. type: Plain text
#: man-pages/man3/expm1.3:129
msgid ""
"I<errno> is set to B<ERANGE> (but see BUGS).  An overflow floating-point "
"exception (B<FE_OVERFLOW>)  is raised."
msgstr ""

#. type: tbl table
#: man-pages/man3/expm1.3:141
#, no-wrap
msgid ""
"B<expm1>(),\n"
"B<expm1f>(),\n"
"B<expm1l>()"
msgstr ""

#.  FIXME .
#.  Bug raised: http://sources.redhat.com/bugzilla/show_bug.cgi?id=6778
#. type: Plain text
#: man-pages/man3/expm1.3:154
msgid ""
"For some large negative I<x> values (where the function result approaches "
"-1), B<expm1>()  raises a bogus underflow floating-point exception."
msgstr ""

#.  FIXME .
#.  Bug raised: http://sources.redhat.com/bugzilla/show_bug.cgi?id=6814
#.  e.g., expm1(1e5) through expm1(1.00199970127e5),
#.  but not expm1(1.00199970128e5) and beyond.
#. type: Plain text
#: man-pages/man3/expm1.3:165
msgid ""
"For some large positive I<x> values, B<expm1>()  raises a bogus invalid "
"floating-point exception in addition to the expected overflow exception, and"
" returns a NaN instead of positive infinity."
msgstr ""

#.  It looks like the fix was in 2.11, or possibly 2.12.
#.  I have no test system for 2.11, but 2.12 passes.
#.  From the source (sysdeps/i386/fpu/s_expm1.S) it looks
#.  like the changes were in 2.11.
#.  http://sources.redhat.com/bugzilla/show_bug.cgi?id=6788
#. type: Plain text
#: man-pages/man3/expm1.3:177
msgid ""
"Before version 2.11, the glibc implementation did not set I<errno> to "
"B<ERANGE> when a range error occurred."
msgstr ""

#. type: Plain text
#: man-pages/man3/expm1.3:180
msgid "B<exp>(3), B<log>(3), B<log1p>(3)"
msgstr ""

#. type: TH
#: man-pages/man3/euidaccess.3:25
#, no-wrap
msgid "EUIDACCESS"
msgstr ""

#. type: Plain text
#: man-pages/man3/euidaccess.3:28
msgid "euidaccess, eaccess - check effective user's permissions for a file"
msgstr ""

#. type: Plain text
#: man-pages/man3/euidaccess.3:32
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>             /* See feature_test_macros(7) */\n"
"B<#include E<lt>unistd.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/euidaccess.3:35
#, no-wrap
msgid ""
"B<int euidaccess(const char *>I<pathname>B<, int >I<mode>B<);>\n"
"B<int eaccess(const char *>I<pathname>B<, int >I<mode>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/euidaccess.3:47
msgid ""
"Like B<access>(2), B<euidaccess>()  checks permissions and existence of the "
"file identified by its argument I<pathname>.  However, whereas B<access>(2)"
"  performs checks using the real user and group identifiers of the process, "
"B<euidaccess>()  uses the effective identifiers."
msgstr ""

#. type: Plain text
#: man-pages/man3/euidaccess.3:53
msgid ""
"I<mode> is a mask consisting of one or more of B<R_OK>, B<W_OK>, B<X_OK>, "
"and B<F_OK>, with the same meanings as for B<access>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man3/euidaccess.3:58
msgid ""
"B<eaccess>()  is a synonym for B<euidaccess>(), provided for compatibility "
"with some other systems."
msgstr ""

#. type: Plain text
#: man-pages/man3/euidaccess.3:66
msgid ""
"On success (all requested permissions granted), zero is returned.  On error "
"(at least one bit in I<mode> asked for a permission that is denied, or some "
"other error occurred), -1 is returned, and I<errno> is set appropriately."
msgstr ""

#. type: Plain text
#: man-pages/man3/euidaccess.3:69
msgid "As for B<access>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man3/euidaccess.3:73
msgid "The B<eaccess>()  function was added to glibc in version 2.4."
msgstr ""

#. type: tbl table
#: man-pages/man3/euidaccess.3:84
#, no-wrap
msgid ""
"B<euidaccess>(),\n"
"B<eaccess>()"
msgstr ""

#.  e.g., FreeBSD 6.1.
#. type: Plain text
#: man-pages/man3/euidaccess.3:92
msgid ""
"These functions are nonstandard.  Some other systems have an B<eaccess>()  "
"function."
msgstr ""

#. type: Plain text
#: man-pages/man3/euidaccess.3:99
msgid ""
"I<Warning>: Using this function to check a process's permissions on a file "
"before performing some operation based on that information leads to race "
"conditions: the file permissions may change between the two steps.  "
"Generally, it is safer just to attempt the desired operation and handle any "
"permission error that occurs."
msgstr ""

#. type: Plain text
#: man-pages/man3/euidaccess.3:107
msgid ""
"This function always dereferences symbolic links.  If you need to check the "
"permissions on a symbolic link, use B<faccessat>(2)  with the flags "
"B<AT_EACCESS> and B<AT_SYMLINK_NOFOLLOW>."
msgstr ""

#. type: Plain text
#: man-pages/man3/euidaccess.3:117
msgid ""
"B<access>(2), B<chmod>(2), B<chown>(2), B<faccessat>(2), B<open>(2), "
"B<setgid>(2), B<setuid>(2), B<stat>(2), B<credentials>(7), "
"B<path_resolution>(7)"
msgstr ""

#. type: TH
#: man-pages/man3/erf.3:35
#, no-wrap
msgid "ERF"
msgstr ""

#. type: Plain text
#: man-pages/man3/erf.3:38
msgid "erf, erff, erfl, - error function"
msgstr ""

#. type: Plain text
#: man-pages/man3/erf.3:45
#, no-wrap
msgid ""
"B<double erf(double >I<x>B<);>\n"
"B<float erff(float >I<x>B<);>\n"
"B<long double erfl(long double >I<x>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/erf.3:56
msgid "B<erf>():"
msgstr ""

#. type: Plain text
#: man-pages/man3/erf.3:64
msgid "B<erff>(), B<erfl>():"
msgstr ""

#. type: Plain text
#: man-pages/man3/erf.3:74
msgid "These functions return the error function of I<x>, defined as"
msgstr ""

#. type: TP
#: man-pages/man3/erf.3:74
#, no-wrap
msgid "    erf(x) = 2/sqrt(pi)* integral from 0 to x of exp(-t*t) dt"
msgstr ""

#. type: Plain text
#: man-pages/man3/erf.3:80
msgid ""
"On success, these functions return the error function of I<x>, a value in "
"the range [-1,\\ 1]."
msgstr ""

#. type: Plain text
#: man-pages/man3/erf.3:93
msgid "If I<x> is positive infinity (negative infinity), +1 (-1) is returned."
msgstr ""

#. type: Plain text
#: man-pages/man3/erf.3:99
msgid ""
"If I<x> is subnormal, a range error occurs, and the return value is "
"2*x/sqrt(pi)."
msgstr ""

#. type: TP
#: man-pages/man3/erf.3:106
#, no-wrap
msgid "Range error: result underflow (I<x> is subnormal)"
msgstr ""

#. type: tbl table
#: man-pages/man3/erf.3:131
#, no-wrap
msgid ""
"B<erf>(),\n"
"B<erff>(),\n"
"B<erfl>()"
msgstr ""

#. type: Plain text
#: man-pages/man3/erf.3:143
msgid "B<cerf>(3), B<erfc>(3), B<exp>(3)"
msgstr ""
