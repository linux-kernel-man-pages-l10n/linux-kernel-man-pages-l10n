# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# 
# Translators:
# Azamat Hackimov <azamat.hackimov@gmail.com>, 2016
# Dmitriy Ovchinnikov <dmitriyxt5@gmail.com>, 2012
# Dmitry Bolkhovskikh <d20052005@yandex.ru>, 2017
# Katrin Kutepova <blackkatelv@gmail.com>, 2018
# Yuri Kozlov <yuray@komyakino.ru>, 2012-2019
# Yuri Kozlov <yuray@komyakino.ru>, 2014
# Иван Павлов <pavia00@gmail.com>, 2019
msgid ""
msgstr ""
"Project-Id-Version: translation of man-pages\n"
"POT-Creation-Date: 2019-08-26 09:27+0300\n"
"PO-Revision-Date: 2019-08-26 06:22+0000\n"
"Last-Translator: Yuri Kozlov <yuray@komyakino.ru>\n"
"Language-Team: Russian (http://www.transifex.com/kruvalig/man-pages/language/ru/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ru\n"
"Plural-Forms: nplurals=4; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n%10<=4 && (n%100<12 || n%100>14) ? 1 : n%10==0 || (n%10>=5 && n%10<=9) || (n%100>=11 && n%100<=14)? 2 : 3);\n"

#. type: TH
#: man-pages/man4/vcs.4:29
#, no-wrap
msgid "VCS"
msgstr "VCS"

#. type: TH
#: man-pages/man4/vcs.4:29
#, no-wrap
msgid "2019-03-06"
msgstr "2019-03-06"

#. type: TH
#: man-pages/man4/vcs.4:29
#, no-wrap
msgid "Linux"
msgstr "Linux"

#. type: TH
#: man-pages/man4/vcs.4:29
#, no-wrap
msgid "Linux Programmer's Manual"
msgstr "Руководство программиста Linux"

#. type: SH
#: man-pages/man4/vcs.4:30
#, no-wrap
msgid "NAME"
msgstr "ИМЯ"

#. type: Plain text
#: man-pages/man4/vcs.4:32
msgid "vcs, vcsa - virtual console memory"
msgstr "vcs, vcsa - память виртуальной консоли"

#. type: SH
#: man-pages/man4/vcs.4:32
#, no-wrap
msgid "DESCRIPTION"
msgstr "ОПИСАНИЕ"

#. type: Plain text
#: man-pages/man4/vcs.4:38
msgid ""
"I</dev/vcs0> is a character device with major number 7 and minor number 0, "
"usually with mode 0644 and ownership root:tty.  It refers to the memory of "
"the currently displayed virtual console terminal."
msgstr "I</dev/vcs0> представляет собой символьное устройство со старшим номером 7 и младшим 0, обычно имеет права доступа 0644 и принадлежит root:tty. Устройство указывает на память отображаемого в данный момент виртуального консольного терминала."

#. type: Plain text
#: man-pages/man4/vcs.4:58
msgid ""
"I</dev/vcs[1-63]> are character devices for virtual console terminals, they "
"have major number 7 and minor number 1 to 63, usually mode 0644 and "
"ownership root:tty.  I</dev/vcsa[0-63]> are the same, but using I<unsigned "
"short>s (in host byte order) that include attributes, and prefixed with four"
" bytes giving the screen dimensions and cursor position: I<lines>, "
"I<columns>, I<x>, I<y>.  (I<x> = I<y> = 0 at the top left corner of the "
"screen.)"
msgstr "I</dev/vcs[1-63]> представляют собой символьные устройства виртуальных консольных терминалов, имеют старший номер 7 и младшие от 1 до 63, обычно имеют права доступа 0644 и принадлежат root:tty. I</dev/vcsa[0-63]> представляют собой  те же устройства, но имеют атрибуты в виде чисел типа I<unsigned short> (с порядком байт узла) и приставкой из четырех байтов, задающих размеры экрана и положение курсора: I<lines>, I<columns>, I<x>, I<y>.  (I<x> = I<y> = 0 означает верхний левый угол экрана.)"

#. type: Plain text
#: man-pages/man4/vcs.4:72
msgid ""
"When a 512-character font is loaded, the 9th bit position can be fetched by "
"applying the B<ioctl>(2)  B<VT_GETHIFONTMASK> operation (available in Linux "
"kernels 2.6.18 and above)  on I</dev/tty[1-63]>; the value is returned in "
"the I<unsigned short> pointed to by the third B<ioctl>(2)  argument."
msgstr "При загрузке шрифта с 512 символами значение 9-го бита можно получить через B<ioctl>(2) с помощью операции B<VT_GETHIFONTMASK> (доступна в ядрах Linux версии 2.6.18 и новее) над I</dev/tty[1-63]>; третий аргумент B<ioctl>(2) содержит указатель на I<unsigned short>, куда возвращается результат."

#. type: Plain text
#: man-pages/man4/vcs.4:79
msgid ""
"These devices replace the screendump B<ioctl>(2)  operations of "
"B<ioctl_console>(2), so the system administrator can control access using "
"filesystem permissions."
msgstr "Эти устройства заменяют операции B<ioctl>(2) по снятию снимка экрана B<ioctl_console>(2), и позволяют системному администратору контролировать доступ с помощью файловой системы."

#. type: Plain text
#: man-pages/man4/vcs.4:81
msgid "The devices for the first eight virtual consoles may be created by:"
msgstr "Устройства для первых восьми виртуальных консолей могут быть созданы с помощью следующих команд:"

#. type: Plain text
#: man-pages/man4/vcs.4:89
#, no-wrap
msgid ""
"for x in 0 1 2 3 4 5 6 7 8; do\n"
"    mknod -m 644 /dev/vcs$x c 7 $x;\n"
"    mknod -m 644 /dev/vcsa$x c 7 $[$x+128];\n"
"done\n"
"chown root:tty /dev/vcs*\n"
msgstr "for x in 0 1 2 3 4 5 6 7 8; do\n    mknod -m 644 /dev/vcs$x c 7 $x;\n    mknod -m 644 /dev/vcsa$x c 7 $[$x+128];\ndone\nchown root:tty /dev/vcs*\n"

#. type: Plain text
#: man-pages/man4/vcs.4:95
msgid "No B<ioctl>(2)  requests are supported."
msgstr "Запросы B<ioctl>(2) не поддерживаются."

#. type: SH
#: man-pages/man4/vcs.4:95
#, no-wrap
msgid "FILES"
msgstr "ФАЙЛЫ"

#. type: Plain text
#: man-pages/man4/vcs.4:97
msgid "I</dev/vcs[0-63]>"
msgstr "|</dev/vcs[0-63]>"

#.  .SH AUTHOR
#.  Andries Brouwer <aeb@cwi.nl>
#. type: Plain text
#: man-pages/man4/vcs.4:101
msgid "I</dev/vcsa[0-63]>"
msgstr "|</dev/vcsa[0-63]>"

#. type: SH
#: man-pages/man4/vcs.4:101
#, no-wrap
msgid "VERSIONS"
msgstr "ВЕРСИИ"

#. type: Plain text
#: man-pages/man4/vcs.4:103
msgid "Introduced with version 1.1.92 of the Linux kernel."
msgstr "Впервые появились в версии ядра Linux 1.1.92."

#. type: SH
#: man-pages/man4/vcs.4:103
#, no-wrap
msgid "EXAMPLE"
msgstr "ПРИМЕР"

#. type: Plain text
#: man-pages/man4/vcs.4:105
msgid "You may do a screendump on vt3 by switching to vt1 and typing"
msgstr "Вы можете сделать снимок экрана vt3, переключившись на vt1 и написав"

#. type: Plain text
#: man-pages/man4/vcs.4:109
#, no-wrap
msgid "cat /dev/vcs3 E<gt>foo\n"
msgstr "cat /dev/vcs3 E<gt>foo\n"

#. type: Plain text
#: man-pages/man4/vcs.4:115
msgid ""
"Note that the output does not contain newline characters, so some processing"
" may be required, like in"
msgstr "Заметим, что вывод не будет содержать символов новой строки, поэтому может потребоваться дополнительная обработка, например"

#. type: Plain text
#: man-pages/man4/vcs.4:119
#, no-wrap
msgid "fold -w 81 /dev/vcs3 | lpr\n"
msgstr "fold -w 81 /dev/vcs3 | lpr\n"

#. type: Plain text
#: man-pages/man4/vcs.4:123
msgid "or (horrors)"
msgstr "или (жуть)"

#. type: Plain text
#: man-pages/man4/vcs.4:127
#, no-wrap
msgid "setterm -dump 3 -file /proc/self/fd/1\n"
msgstr "setterm -dump 3 -file /proc/self/fd/1\n"

#. type: Plain text
#: man-pages/man4/vcs.4:133
msgid "The I</dev/vcsa0> device is used for Braille support."
msgstr "Устройство I</dev/vcsa0> используется для поддержки дисплея Брайля."

#. type: Plain text
#: man-pages/man4/vcs.4:137
msgid ""
"This program displays the character and screen attributes under the cursor "
"of the second virtual console, then changes the background color there:"
msgstr "Эта программа выводит символ и атрибуты экрана, находящиеся под курсором на второй виртуальной консоли, и затем меняет цвет фона в том же месте."

#. type: Plain text
#: man-pages/man4/vcs.4:145
#, no-wrap
msgid ""
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>fcntl.hE<gt>\n"
"#include E<lt>sys/ioctl.hE<gt>\n"
"#include E<lt>linux/vt.hE<gt>\n"
msgstr "#include E<lt>unistd.hE<gt>\n#include E<lt>stdlib.hE<gt>\n#include E<lt>stdio.hE<gt>\n#include E<lt>fcntl.hE<gt>\n#include E<lt>sys/ioctl.hE<gt>\n#include E<lt>linux/vt.hE<gt>\n"

#. type: Plain text
#: man-pages/man4/vcs.4:157
#, no-wrap
msgid ""
"int\n"
"main(void)\n"
"{\n"
"    int fd;\n"
"    char *device = \"/dev/vcsa2\";\n"
"    char *console = \"/dev/tty2\";\n"
"    struct {unsigned char lines, cols, x, y;} scrn;\n"
"    unsigned short s;\n"
"    unsigned short mask;\n"
"    unsigned char attrib;\n"
"    int ch;\n"
msgstr "int\nmain(void)\n{\n    int fd;\n    char *device = \"/dev/vcsa2\";\n    char *console = \"/dev/tty2\";\n    struct {unsigned char lines, cols, x, y;} scrn;\n    unsigned short s;\n    unsigned short mask;\n    unsigned char attrib;\n    int ch;\n"

#. type: Plain text
#: man-pages/man4/vcs.4:186
#, no-wrap
msgid ""
"    fd = open(console, O_RDWR);\n"
"    if (fd E<lt> 0) {\n"
"        perror(console);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
"    if (ioctl(fd, VT_GETHIFONTMASK, &mask) E<lt> 0) {\n"
"        perror(\"VT_GETHIFONTMASK\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
"    (void) close(fd);\n"
"    fd = open(device, O_RDWR);\n"
"    if (fd E<lt> 0) {\n"
"        perror(device);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
"    (void) read(fd, &scrn, 4);\n"
"    (void) lseek(fd, 4 + 2*(scrn.y*scrn.cols + scrn.x), SEEK_SET);\n"
"    (void) read(fd, &s, 2);\n"
"    ch = s & 0xff;\n"
"    if (s & mask)\n"
"        ch |= 0x100;\n"
"    attrib = ((s & ~mask) E<gt>E<gt> 8);\n"
"    printf(\"ch=0x%03x attrib=0x%02x\\en\", ch, attrib);\n"
"    s ^= 0x1000;\n"
"    (void) lseek(fd, -2, SEEK_CUR);\n"
"    (void) write(fd, &s, 2);\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr "    fd = open(console, O_RDWR);\n    if (fd E<lt> 0) {\n        perror(console);\n        exit(EXIT_FAILURE);\n    }\n    if (ioctl(fd, VT_GETHIFONTMASK, &mask) E<lt> 0) {\n        perror(\"VT_GETHIFONTMASK\");\n        exit(EXIT_FAILURE);\n    }\n    (void) close(fd);\n    fd = open(device, O_RDWR);\n    if (fd E<lt> 0) {\n        perror(device);\n        exit(EXIT_FAILURE);\n    }\n    (void) read(fd, &scrn, 4);\n    (void) lseek(fd, 4 + 2*(scrn.y*scrn.cols + scrn.x), SEEK_SET);\n    (void) read(fd, &s, 2);\n    ch = s & 0xff;\n    if (s & mask)\n        ch |= 0x100;\n    attrib = ((s & ~mask) E<gt>E<gt> 8);\n    printf(\"ch=0x%03x attrib=0x%02x\\en\", ch, attrib);\n    s ^= 0x1000;\n    (void) lseek(fd, -2, SEEK_CUR);\n    (void) write(fd, &s, 2);\n    exit(EXIT_SUCCESS);\n}\n"

#. type: SH
#: man-pages/man4/vcs.4:187
#, no-wrap
msgid "SEE ALSO"
msgstr "СМОТРИТЕ ТАКЖЕ"

#. type: Plain text
#: man-pages/man4/vcs.4:191
msgid "B<ioctl_console>(2), B<tty>(4), B<ttyS>(4), B<gpm>(8)"
msgstr "B<ioctl_console>(2), B<tty>(4), B<ttyS>(4), B<gpm>(8)"

#. type: TH
#: man-pages/man4/veth.4:28
#, no-wrap
msgid "veth"
msgstr "veth"

#. type: TH
#: man-pages/man4/veth.4:28
#, no-wrap
msgid "2018-02-02"
msgstr "2018-02-02"

#. type: Plain text
#: man-pages/man4/veth.4:31
msgid "veth - Virtual Ethernet Device"
msgstr "veth - виртуальное устройство Ethernet"

#. type: Plain text
#: man-pages/man4/veth.4:38
msgid ""
"The B<veth> devices are virtual Ethernet devices.  They can act as tunnels "
"between network namespaces to create a bridge to a physical network device "
"in another namespace, but can also be used as standalone network devices."
msgstr "Устройства B<veth> — это виртуальные устройства Ethernet. Они могут служить туннелями между сетевыми пространствами имён для создания моста к физическому сетевому устройству в другом пространстве имён, а также использоваться как самостоятельные сетевые устройства."

#. type: Plain text
#: man-pages/man4/veth.4:42
msgid ""
"B<veth> devices are always created in interconnected pairs.  A pair can be "
"created using the command:"
msgstr "Устройства B<veth> всегда создаются парами. Пара может быть создана с помощью команды:"

#. type: Plain text
#: man-pages/man4/veth.4:46
#, no-wrap
msgid "# ip link add E<lt>p1-nameE<gt> type veth peer name E<lt>p2-nameE<gt>\n"
msgstr "# ip link add E<lt>имя-p1E<gt> type veth peer name E<lt>имя-p2E<gt>\n"

#. type: Plain text
#: man-pages/man4/veth.4:54
msgid ""
"In the above, I<p1-name> and I<p2-name> are the names assigned to the two "
"connected end points."
msgstr "Здесь I<имя-p1> и I<имя-p2> это имена, назначенные двум соединённым конечным точкам."

#. type: Plain text
#: man-pages/man4/veth.4:58
msgid ""
"Packets transmitted on one device in the pair are immediately received on "
"the other device.  When either devices is down the link state of the pair is"
" down."
msgstr "Пакеты, переданные в одно устройство пары сразу же принимаются другим устройством. Если у какого-то устройства выключается связь (down), то то выключается пара целиком."

#. type: Plain text
#: man-pages/man4/veth.4:69
msgid ""
"B<veth> device pairs are useful for combining the network facilities of the "
"kernel together in interesting ways.  A particularly interesting use case is"
" to place one end of a B<veth> pair in one network namespace and the other "
"end in another network namespace, thus allowing communication between "
"network namespaces.  To do this, one first creates the B<veth> device as "
"above and then moves one side of the pair to the other namespace:"
msgstr "Пары устройств B<veth> полезны для объединения сетевых свойств ядра разными интересными способами. В частности, можно поместить один конец пары B<veth> в одно сетевое пространство имён, а другой конец в другое сетевое пространство имён; таким способом установится связь между сетевыми пространствами имён. Для этого сначала создайте устройство B<veth> как описано выше, а затем поместите один конец пары в другое пространство имён:"

#. type: Plain text
#: man-pages/man4/veth.4:73
#, no-wrap
msgid "# ip link set E<lt>p2-nameE<gt> netns E<lt>p2-namespaceE<gt>\n"
msgstr "# ip link set E<lt>имя-p2E<gt> netns E<lt>пространство-имён-p2E<gt>\n"

#. type: Plain text
#: man-pages/man4/veth.4:80
msgid ""
"B<ethtool>(8)  can be used to find the peer of a B<veth> network interface, "
"using commands something like:"
msgstr "Для нахождения конца сетевого интерфейса B<veth> можно использовать B<ethtool>(8) следующим образом:"

#. type: Plain text
#: man-pages/man4/veth.4:89
#, no-wrap
msgid ""
"# B<ip link add ve_A type veth peer name ve_B>   # Create veth pair\n"
"# B<ethtool -S ve_A>         # Discover interface index of peer\n"
"NIC statistics:\n"
"     peer_ifindex: 16\n"
"# B<ip link | grep '^16:'>   # Look up interface\n"
"16: ve_B@ve_A: E<lt>BROADCAST,MULTICAST,M-DOWNE<gt> mtu 1500 qdisc ...\n"
msgstr "# B<ip link add ve_A type veth peer name ve_B>   # создаём пару veth\n# B<ethtool -S ve_A>         # находим индекс интерфейса\nстатистики NIC:\n     peer_ifindex: 16\n# B<ip link | grep '^16:'>   # ищем интерфейс\n16: ve_B@ve_A: E<lt>BROADCAST,MULTICAST,M-DOWNE<gt> mtu 1500 qdisc ...\n"

#. type: Plain text
#: man-pages/man4/veth.4:97
msgid ""
"B<clone>(2), B<network_namespaces>(7), B<ip>(8), B<ip-link>(8), B<ip-"
"netns>(8)"
msgstr "B<clone>(2), B<network_namespaces>(7), B<ip>(8), B<ip-link>(8), B<ip-netns>(8)"

#. type: TH
#: man-pages/man7/vdso.7:13
#, no-wrap
msgid "VDSO"
msgstr "VDSO"

#. type: TH
#: man-pages/man7/vdso.7:13
#, no-wrap
msgid "2019-08-02"
msgstr ""

#. type: Plain text
#: man-pages/man7/vdso.7:16
msgid "vdso - overview of the virtual ELF dynamic shared object"
msgstr "vdso - обзор виртуального динамически компонуемого общего объекта ELF"

#. type: SH
#: man-pages/man7/vdso.7:16
#, no-wrap
msgid "SYNOPSIS"
msgstr "ОБЗОР"

#. type: Plain text
#: man-pages/man7/vdso.7:18
msgid "B<#include E<lt>sys/auxv.hE<gt>>"
msgstr "B<#include E<lt>sys/auxv.hE<gt>>"

#. type: Plain text
#: man-pages/man7/vdso.7:20
msgid "B<void *vdso = (uintptr_t) getauxval(AT_SYSINFO_EHDR);>"
msgstr "B<void *vdso = (uintptr_t) getauxval(AT_SYSINFO_EHDR);>"

#. type: Plain text
#: man-pages/man7/vdso.7:29
msgid ""
"The \"vDSO\" (virtual dynamic shared object) is a small shared library that "
"the kernel automatically maps into the address space of all user-space "
"applications.  Applications usually do not need to concern themselves with "
"these details as the vDSO is most commonly called by the C library.  This "
"way you can code in the normal way using standard functions and the C "
"library will take care of using any functionality that is available via the "
"vDSO."
msgstr "«vDSO» (virtual dynamic shared object, виртуальный динамический общий объект) — это маленькая общая библиотека, которую ядро автоматически отображает в адресное пространство всех приложений пользовательского пространства. Обычно, приложениям она не нужна, так как vDSO, чаще всего, вызывается из библиотеки C. Вы можете использовать стандартные функции как обычно, а библиотека C самостоятельно позаботится об использовании возможностей vDSO."

#. type: Plain text
#: man-pages/man7/vdso.7:37
msgid ""
"Why does the vDSO exist at all? There are some system calls the kernel "
"provides that user-space code ends up using frequently, to the point that "
"such calls can dominate overall performance.  This is due both to the "
"frequency of the call as well as the context-switch overhead that results "
"from exiting user space and entering the kernel."
msgstr "И всё же, зачем нужна vDSO? Есть несколько системных вызовов ядра, которые используются в пользовательском коде настолько часто, что это сильно влияет на общую производительность. Это происходит из-за частого повторения вызовов, а также затрат на переключение контекста, которые возникают при выходе из пользовательского пространства и входа в ядро."

#. type: Plain text
#: man-pages/man7/vdso.7:42
msgid ""
"The rest of this documentation is geared toward the curious and/or C library"
" writers rather than general developers.  If you're trying to call the vDSO "
"in your own application rather than using the C library, you're most likely "
"doing it wrong."
msgstr "Оставшаяся часть этой документации предназначена для любопытных и/или авторов библиотеки C, а не для обычных разработчиков. Если вы попытаетесь вызвать vDSO в своём приложении не через библиотеку C, то, наиболее вероятно, сделаете это неправильно."

#. type: SS
#: man-pages/man7/vdso.7:42
#, no-wrap
msgid "Example background"
msgstr "В качестве примера"

#. type: Plain text
#: man-pages/man7/vdso.7:56
msgid ""
"Making system calls can be slow.  In x86 32-bit systems, you can trigger a "
"software interrupt (I<int $0x80>)  to tell the kernel you wish to make a "
"system call.  However, this instruction is expensive: it goes through the "
"full interrupt-handling paths in the processor's microcode as well as in the"
" kernel.  Newer processors have faster (but backward incompatible) "
"instructions to initiate system calls.  Rather than require the C library to"
" figure out if this functionality is available at run time, the C library "
"can use functions provided by the kernel in the vDSO."
msgstr "Выполнение системных вызовов может быть медленным. В 32-битных системах x86 вы можете использовать программное прерывание (I<int $0x80>), чтобы заставить ядро выполнить системный вызов. Однако, эта инструкция очень затратна: она проходит по полному маршруту обработки прерываний в микрокоде процессора, а также в ядре. Новые процессоры содержат более быстрые инструкции (но обратно совместимые) для запуска системных вызовов. Вместо того, чтобы требовать от библиотеки C выяснения во время выполнения есть ли такая возможность, библиотека C может использовать функции, предоставляемые ядром в vDSO."

#. type: Plain text
#: man-pages/man7/vdso.7:63
msgid ""
"Note that the terminology can be confusing.  On x86 systems, the vDSO "
"function used to determine the preferred method of making a system call is "
"named \"__kernel_vsyscall\", but on x86-64, the term \"vsyscall\" also "
"refers to an obsolete way to ask the kernel what time it is or what CPU the "
"caller is on."
msgstr "Заметим, что можно запутаться в терминологии. В системах x86 функция vDSO, используемая для определения предпочтительного метода выполнения системного вызова, называется «__kernel_vsyscall», но в x86-64 термин «vsyscall» также ссылается на устаревший метод запроса ядра о времени или на каком ЦП выполняется вызывающий."

#. type: Plain text
#: man-pages/man7/vdso.7:79
msgid ""
"One frequently used system call is B<gettimeofday>(2).  This system call is "
"called both directly by user-space applications as well as indirectly by the"
" C library.  Think timestamps or timing loops or polling\\(emall of these "
"frequently need to know what time it is right now.  This information is also"
" not secret\\(emany application in any privilege mode (root or any "
"unprivileged user) will get the same answer.  Thus the kernel arranges for "
"the information required to answer this question to be placed in memory the "
"process can access.  Now a call to B<gettimeofday>(2)  changes from a system"
" call to a normal function call and a few memory accesses."
msgstr "Одним из наиболее часто используемых системных вызовов является B<gettimeofday>(2). Данный вызов используется прямо в приложениях, а также неявно из библиотеки C. Метка времени, временной цикл или опрос — для всего этого часто нужно знать сколько времени в данный момент. Также, это информация не секретна — многие приложения с любыми правами (root или любого не привилегированного пользователя) получат одинаковый ответ. Поэтому ядро размещает информацию, требуемую для ответа на этот вопрос, в памяти процесса. Теперь системный вызов B<gettimeofday>(2) заменяется на вызов обычной функции и доступ к памяти."

#. type: SS
#: man-pages/man7/vdso.7:79
#, no-wrap
msgid "Finding the vDSO"
msgstr "Нахождение vDSO"

#. type: Plain text
#: man-pages/man7/vdso.7:86
msgid ""
"The base address of the vDSO (if one exists) is passed by the kernel to each"
" program in the initial auxiliary vector (see B<getauxval>(3)), via the "
"B<AT_SYSINFO_EHDR> tag."
msgstr "Базовый адрес vDSO (если есть) передаётся ядром каждой программе во вспомогательном векторе инициализации (смотрите B<getauxval>(3)) через тег B<AT_SYSINFO_EHDR>."

#. type: Plain text
#: man-pages/man7/vdso.7:95
msgid ""
"You must not assume the vDSO is mapped at any particular location in the "
"user's memory map.  The base address will usually be randomized at run time "
"every time a new process image is created (at B<execve>(2)  time).  This is "
"done for security reasons, to prevent \"return-to-libc\" attacks."
msgstr "Вы не должны рассчитывать на то, что vDSO отображается в каком-то определённом месте карты пользовательской памяти. Обычно, базовый адрес во время выполнения выбирается произвольным образом каждый раз при создании нового образа процесса (с помощью B<execve>(2)). Это делается в целях безопасности для предотвращения атак «возврат в libc»."

#. type: Plain text
#: man-pages/man7/vdso.7:104
msgid ""
"For some architectures, there is also an B<AT_SYSINFO> tag.  This is used "
"only for locating the vsyscall entry point and is frequently omitted or set "
"to 0 (meaning it's not available).  This tag is a throwback to the initial "
"vDSO work (see I<History> below) and its use should be avoided."
msgstr "Для некоторых архитектур также существует тег B<AT_SYSINFO>. Он используется только для нахождения точки входа vsyscall и часто отсутствует или равен 0 (то есть недоступен). Этот тег — атавизм первых версий vDSO (смотрите I<История> ниже) и не должен использоваться."

#. type: SS
#: man-pages/man7/vdso.7:104
#, no-wrap
msgid "File format"
msgstr "Формат файла"

#. type: Plain text
#: man-pages/man7/vdso.7:111
msgid ""
"Since the vDSO is a fully formed ELF image, you can do symbol lookups on it."
"  This allows new symbols to be added with newer kernel releases, and allows"
" the C library to detect available functionality at run time when running "
"under different kernel versions.  Oftentimes the C library will do detection"
" with the first call and then cache the result for subsequent calls."
msgstr "Так как vDSO — полноценный образ ELF, вы можете искать в нём символы. Это позволяет добавлять новые символы в новых версиях ядра и библиотеке C находить доступные свойства во время выполнения с различными версиями ядер. Зачастую, библиотека C выполняет обнаружение при первом вызове и затем кэширует результат для последующих вызовов."

#. type: Plain text
#: man-pages/man7/vdso.7:120
msgid ""
"All symbols are also versioned (using the GNU version format).  This allows "
"the kernel to update the function signature without breaking backward "
"compatibility.  This means changing the arguments that the function accepts "
"as well as the return value.  Thus, when looking up a symbol in the vDSO, "
"you must always include the version to match the ABI you expect."
msgstr "Все символы имеют версии (в формате версий GNU). Это позволяет ядру обновлять сигнатуру функции без нарушения обратной совместимости. Смена версии означает изменение аргументов функции или возвращаемого значения. Таким образом, при поиске символа в vDSO, вы всегда должны включать версию для нахождения ожидаемого ABI."

#. type: Plain text
#: man-pages/man7/vdso.7:125
msgid ""
"Typically the vDSO follows the naming convention of prefixing all symbols "
"with \"__vdso_\" or \"__kernel_\" so as to distinguish them from other "
"standard symbols.  For example, the \"gettimeofday\" function is named "
"\"__vdso_gettimeofday\"."
msgstr "Обычно, vDSO удовлетворяет соглашению об именовании, начиная все символы с «__vdso_» или «__kernel_», для их выделения среди других стандартных символов. Например, функция «gettimeofday» называется «__vdso_gettimeofday»."

#. type: Plain text
#: man-pages/man7/vdso.7:129
msgid ""
"You use the standard C calling conventions when calling any of these "
"functions.  No need to worry about weird register or stack behavior."
msgstr "Для вызова этих функций используйте стандартные соглашения о вызове языка Си. Учитывать поведение регистров и стека не требуется."

#. type: SH
#: man-pages/man7/vdso.7:129
#, no-wrap
msgid "NOTES"
msgstr "ЗАМЕЧАНИЯ"

#. type: SS
#: man-pages/man7/vdso.7:130
#, no-wrap
msgid "Source"
msgstr "Исходный код"

#. type: Plain text
#: man-pages/man7/vdso.7:134
msgid ""
"When you compile the kernel, it will automatically compile and link the vDSO"
" code for you.  You will frequently find it under the architecture-specific "
"directory:"
msgstr "Код vDSO автоматически компилируется и компонуется при сборке ядра. Обычно, его можно найти в каталоге соответствующей архитектуры:"

#. type: Plain text
#: man-pages/man7/vdso.7:137
#, no-wrap
msgid "    find arch/$ARCH/ -name \\(aq*vdso*.so*\\(aq -o -name \\(aq*gate*.so*\\(aq\n"
msgstr "    find arch/$ARCH/ -name \\(aq*vdso*.so*\\(aq -o -name \\(aq*gate*.so*\\(aq\n"

#. type: SS
#: man-pages/man7/vdso.7:137
#, no-wrap
msgid "vDSO names"
msgstr "Имена vDSO"

#. type: Plain text
#: man-pages/man7/vdso.7:143
msgid ""
"The name of the vDSO varies across architectures.  It will often show up in "
"things like glibc's B<ldd>(1)  output.  The exact name should not matter to "
"any code, so do not hardcode it."
msgstr "Имя vDSO отличается на разных архитектурах. Часто его можно увидеть в выводе утилит, подобных B<ldd>(1) из glibc. Точное имя не должно влиять на код, поэтому жёстко оно нигде не задаётся."

#. type: Plain text
#: man-pages/man7/vdso.7:146 man-pages/man7/vdso.7:196
#: man-pages/man7/vdso.7:225 man-pages/man7/vdso.7:262
#: man-pages/man7/vdso.7:280 man-pages/man7/vdso.7:308
#: man-pages/man7/vdso.7:344 man-pages/man7/vdso.7:366
#: man-pages/man7/vdso.7:405 man-pages/man7/vdso.7:443
#: man-pages/man7/vdso.7:464 man-pages/man7/vdso.7:482
#: man-pages/man7/vdso.7:500 man-pages/man7/vdso.7:518
#: man-pages/man7/vdso.7:543 man-pages/man7/vdso.7:562
msgid "CW<\\}>"
msgstr "CW<\\}>"

#. type: tbl table
#: man-pages/man7/vdso.7:148
#, no-wrap
msgid "CW<user ABI>"
msgstr "CW<ABI пользователя>"

#. type: tbl table
#: man-pages/man7/vdso.7:148
#, no-wrap
msgid "CW<vDSO name>"
msgstr "CW<имя vDSO>"

#. type: tbl table
#: man-pages/man7/vdso.7:149 man-pages/man7/vdso.7:199
#: man-pages/man7/vdso.7:228 man-pages/man7/vdso.7:265
#: man-pages/man7/vdso.7:283 man-pages/man7/vdso.7:311
#: man-pages/man7/vdso.7:347 man-pages/man7/vdso.7:369
#: man-pages/man7/vdso.7:408 man-pages/man7/vdso.7:446
#: man-pages/man7/vdso.7:467 man-pages/man7/vdso.7:485
#: man-pages/man7/vdso.7:503 man-pages/man7/vdso.7:521
#: man-pages/man7/vdso.7:546 man-pages/man7/vdso.7:565
#, no-wrap
msgid "CW<_>"
msgstr "CW<_>"

#. type: tbl table
#: man-pages/man7/vdso.7:150
#, no-wrap
msgid "CW<aarch64>"
msgstr "CW<aarch64>"

#. type: tbl table
#: man-pages/man7/vdso.7:150 man-pages/man7/vdso.7:151
#: man-pages/man7/vdso.7:153 man-pages/man7/vdso.7:156
#: man-pages/man7/vdso.7:161 man-pages/man7/vdso.7:162
#, no-wrap
msgid "CW<linux-vdso.so.1>"
msgstr "CW<linux-vdso.so.1>"

#. type: tbl table
#: man-pages/man7/vdso.7:151
#, no-wrap
msgid "CW<arm>"
msgstr "CW<arm>"

#. type: tbl table
#: man-pages/man7/vdso.7:152
#, no-wrap
msgid "CW<ia64>"
msgstr "CW<ia64>"

#. type: tbl table
#: man-pages/man7/vdso.7:152 man-pages/man7/vdso.7:159
#: man-pages/man7/vdso.7:160
#, no-wrap
msgid "CW<linux-gate.so.1>"
msgstr "CW<linux-gate.so.1>"

#. type: tbl table
#: man-pages/man7/vdso.7:153
#, no-wrap
msgid "CW<mips>"
msgstr "CW<mips>"

#. type: tbl table
#: man-pages/man7/vdso.7:154
#, no-wrap
msgid "CW<ppc/32>"
msgstr "CW<ppc/32>"

#. type: tbl table
#: man-pages/man7/vdso.7:154 man-pages/man7/vdso.7:157
#, no-wrap
msgid "CW<linux-vdso32.so.1>"
msgstr "CW<linux-vdso32.so.1>"

#. type: tbl table
#: man-pages/man7/vdso.7:155
#, no-wrap
msgid "CW<ppc/64>"
msgstr "CW<ppc/64>"

#. type: tbl table
#: man-pages/man7/vdso.7:155 man-pages/man7/vdso.7:158
#, no-wrap
msgid "CW<linux-vdso64.so.1>"
msgstr "CW<linux-vdso64.so.1>"

#. type: tbl table
#: man-pages/man7/vdso.7:156
#, no-wrap
msgid "CW<riscv>"
msgstr ""

#. type: tbl table
#: man-pages/man7/vdso.7:157
#, no-wrap
msgid "CW<s390>"
msgstr "CW<s390>"

#. type: tbl table
#: man-pages/man7/vdso.7:158
#, no-wrap
msgid "CW<s390x>"
msgstr "CW<s390x>"

#. type: tbl table
#: man-pages/man7/vdso.7:159
#, no-wrap
msgid "CW<sh>"
msgstr "CW<sh>"

#. type: tbl table
#: man-pages/man7/vdso.7:160
#, no-wrap
msgid "CW<i386>"
msgstr "CW<i386>"

#. type: tbl table
#: man-pages/man7/vdso.7:161
#, no-wrap
msgid "CW<x86-64>"
msgstr "CW<x86-64>"

#. type: tbl table
#: man-pages/man7/vdso.7:162
#, no-wrap
msgid "CW<x86/x32>"
msgstr "CW<x86/x32>"

#. type: Plain text
#: man-pages/man7/vdso.7:168 man-pages/man7/vdso.7:207
#: man-pages/man7/vdso.7:238 man-pages/man7/vdso.7:273
#: man-pages/man7/vdso.7:292 man-pages/man7/vdso.7:323
#: man-pages/man7/vdso.7:356 man-pages/man7/vdso.7:424
#: man-pages/man7/vdso.7:458 man-pages/man7/vdso.7:476
#: man-pages/man7/vdso.7:494 man-pages/man7/vdso.7:512
#: man-pages/man7/vdso.7:535 man-pages/man7/vdso.7:556
#: man-pages/man7/vdso.7:575
msgid "\\}"
msgstr "\\}"

#. type: SS
#: man-pages/man7/vdso.7:168
#, no-wrap
msgid "strace(1), seccomp(2), and the vDSO"
msgstr "strace(1), seccomp(2) и vDSO"

#. type: Plain text
#: man-pages/man7/vdso.7:177
msgid ""
"When tracing systems calls with B<strace>(1), symbols (system calls) that "
"are exported by the vDSO will I<not> appear in the trace output.  Those "
"system calls will likewise not be visible to B<seccomp>(2)  filters."
msgstr "При трассировке системных вызовов с помощью B<strace>(1), символы (системные вызовы), экспортируемые vDSO, I<не> показываются в результате трассировки. Также данные системные вызовы будут невидимы в фильтрах B<seccomp>(2)."

#. type: SH
#: man-pages/man7/vdso.7:177
#, no-wrap
msgid "ARCHITECTURE-SPECIFIC NOTES"
msgstr "ЗАМЕЧАНИЯ ДЛЯ РАЗЛИЧНЫХ АРХИТЕКТУР"

#. type: Plain text
#: man-pages/man7/vdso.7:180
msgid "The subsections below provide architecture-specific notes on the vDSO."
msgstr "Далее приведены замечания по vDSO для различных архитектур."

#. type: Plain text
#: man-pages/man7/vdso.7:189
msgid ""
"Note that the vDSO that is used is based on the ABI of your user-space code "
"and not the ABI of the kernel.  Thus, for example, when you run an i386 "
"32-bit ELF binary, you'll get the same vDSO regardless of whether you run it"
" under an i386 32-bit kernel or under an x86-64 64-bit kernel.  Therefore, "
"the name of the user-space ABI should be used to determine which of the "
"sections below is relevant."
msgstr "Заметим, что используемая vDSO основывается на ABI вашего кода пользовательского пространства, а не на ABI ядра. Например, когда вы запускаете 32-битный исполняемый файл ELF на i386, то вы получаете ту же vDSO независимо от того, выполняете ли вы его под 32-битном ядром на i386 или под 64-битном ядром под x86-64. Таким образом, для определения нужного раздела ниже нужно использовать имя ABI пользовательского пространства."

#. type: SS
#: man-pages/man7/vdso.7:189
#, no-wrap
msgid "ARM functions"
msgstr "Функции на ARM"

#.  See linux/arch/x86/vdso/vdso32.lds.S
#. type: Plain text
#: man-pages/man7/vdso.7:193 man-pages/man7/vdso.7:222
#: man-pages/man7/vdso.7:259 man-pages/man7/vdso.7:277
#: man-pages/man7/vdso.7:402 man-pages/man7/vdso.7:440
#: man-pages/man7/vdso.7:461 man-pages/man7/vdso.7:479
#: man-pages/man7/vdso.7:497 man-pages/man7/vdso.7:515
#: man-pages/man7/vdso.7:559
msgid "The table below lists the symbols exported by the vDSO."
msgstr "В таблице ниже перечислены символы, экспортируемые vDSO."

#. type: tbl table
#: man-pages/man7/vdso.7:198 man-pages/man7/vdso.7:227
#: man-pages/man7/vdso.7:264 man-pages/man7/vdso.7:282
#: man-pages/man7/vdso.7:368 man-pages/man7/vdso.7:407
#: man-pages/man7/vdso.7:445 man-pages/man7/vdso.7:466
#: man-pages/man7/vdso.7:484 man-pages/man7/vdso.7:502
#: man-pages/man7/vdso.7:520 man-pages/man7/vdso.7:545
#: man-pages/man7/vdso.7:564
#, no-wrap
msgid "CW<symbol>"
msgstr "CW<символ>"

#. type: tbl table
#: man-pages/man7/vdso.7:198 man-pages/man7/vdso.7:227
#: man-pages/man7/vdso.7:264 man-pages/man7/vdso.7:282
#: man-pages/man7/vdso.7:368 man-pages/man7/vdso.7:407
#: man-pages/man7/vdso.7:445 man-pages/man7/vdso.7:466
#: man-pages/man7/vdso.7:484 man-pages/man7/vdso.7:502
#: man-pages/man7/vdso.7:520 man-pages/man7/vdso.7:545
#: man-pages/man7/vdso.7:564
#, no-wrap
msgid "CW<version>"
msgstr "CW<версия>"

#. type: tbl table
#: man-pages/man7/vdso.7:200 man-pages/man7/vdso.7:528
#: man-pages/man7/vdso.7:549 man-pages/man7/vdso.7:568
#, no-wrap
msgid "CW<__vdso_gettimeofday>"
msgstr "CW<__vdso_gettimeofday>"

#. type: tbl table
#: man-pages/man7/vdso.7:200 man-pages/man7/vdso.7:201
#, no-wrap
msgid "CW<LINUX_2.6 (exported since Linux 4.1)>"
msgstr "CW<LINUX_2.6 (экспортируется начиная с Linux 4.1)>"

#. type: tbl table
#: man-pages/man7/vdso.7:201 man-pages/man7/vdso.7:527
#: man-pages/man7/vdso.7:547 man-pages/man7/vdso.7:566
#, no-wrap
msgid "CW<__vdso_clock_gettime>"
msgstr "CW<__vdso_clock_gettime>"

#.  See linux/arch/arm/kernel/entry-armv.S
#.  See linux/Documentation/arm/kernel_user_helpers.txt
#. type: Plain text
#: man-pages/man7/vdso.7:214
msgid ""
"Additionally, the ARM port has a code page full of utility functions.  Since"
" it's just a raw page of code, there is no ELF information for doing symbol "
"lookups or versioning.  It does provide support for different versions "
"though."
msgstr "Также, перенос ARM содержит страницу кода со вспомогательными функциями. Так как это просто страница с кодом, информация ELF отсутствует и поиск функций невозможен и неизвестны их версии. Хотя в коде есть функции нескольких версий."

#. type: Plain text
#: man-pages/man7/vdso.7:219
msgid ""
"For information on this code page, it's best to refer to the kernel "
"documentation as it's extremely detailed and covers everything you need to "
"know: I<Documentation/arm/kernel_user_helpers.txt>."
msgstr "Эта страница с кодом хорошо описана в документации к ядру и в ней есть всё, что вам нужно знать: I<Documentation/arm/kernel_user_helpers.txt>."

#. type: SS
#: man-pages/man7/vdso.7:219
#, no-wrap
msgid "aarch64 functions"
msgstr "Функции на aarch64"

#. type: tbl table
#: man-pages/man7/vdso.7:229 man-pages/man7/vdso.7:447
#: man-pages/man7/vdso.7:504 man-pages/man7/vdso.7:523
#, no-wrap
msgid "CW<__kernel_rt_sigreturn>"
msgstr "CW<__kernel_rt_sigreturn>"

#. type: tbl table
#: man-pages/man7/vdso.7:229 man-pages/man7/vdso.7:230
#: man-pages/man7/vdso.7:231 man-pages/man7/vdso.7:232
#, no-wrap
msgid "CW<LINUX_2.6.39>"
msgstr "CW<LINUX_2.6.39>"

#. type: tbl table
#: man-pages/man7/vdso.7:230 man-pages/man7/vdso.7:266
#: man-pages/man7/vdso.7:415 man-pages/man7/vdso.7:448
#: man-pages/man7/vdso.7:470 man-pages/man7/vdso.7:488
#, no-wrap
msgid "CW<__kernel_gettimeofday>"
msgstr "CW<__kernel_gettimeofday>"

#. type: tbl table
#: man-pages/man7/vdso.7:231 man-pages/man7/vdso.7:267
#: man-pages/man7/vdso.7:371 man-pages/man7/vdso.7:410
#: man-pages/man7/vdso.7:449 man-pages/man7/vdso.7:469
#: man-pages/man7/vdso.7:487
#, no-wrap
msgid "CW<__kernel_clock_gettime>"
msgstr "CW<__kernel_clock_gettime>"

#. type: tbl table
#: man-pages/man7/vdso.7:232 man-pages/man7/vdso.7:370
#: man-pages/man7/vdso.7:409 man-pages/man7/vdso.7:450
#: man-pages/man7/vdso.7:468 man-pages/man7/vdso.7:486
#, no-wrap
msgid "CW<__kernel_clock_getres>"
msgstr "CW<__kernel_clock_getres>"

#. type: SS
#: man-pages/man7/vdso.7:238
#, no-wrap
msgid "bfin (Blackfin) functions (port removed in Linux 4.17)"
msgstr ""

#.  See linux/arch/blackfin/kernel/fixed_code.S
#.  See http://docs.blackfin.uclinux.org/doku.php?id=linux-kernel:fixed-code
#. type: Plain text
#: man-pages/man7/vdso.7:250
msgid ""
"As this CPU lacks a memory management unit (MMU), it doesn't set up a vDSO "
"in the normal sense.  Instead, it maps at boot time a few raw functions into"
" a fixed location in memory.  User-space applications then call directly "
"into that region.  There is no provision for backward compatibility beyond "
"sniffing raw opcodes, but as this is an embedded CPU, it can get away with "
"things\\(emsome of the object formats it runs aren't even ELF based (they're"
" bFLT/FLAT)."
msgstr "Так как в этом ЦП отсутствует устройство управления памятью (MMU), на данной архитектуре не создаётся vDSO в обычном понимании. Вместо этого, ядро отображает несколько функций в постоянное расположение в памяти. Приложения пользовательского пространства могут вызывать их из этой области напрямую. Здесь отсутствует обратная совместимость кроме как слежение за кодами операций (sniffing raw opcodes), но для таких встраиваемых ЦП это нормально — некоторые форматы объектов, запускаемых на нём, даже не основаны на ELF (например, bFLT/FLAT)."

#. type: Plain text
#: man-pages/man7/vdso.7:253
msgid ""
"For information on this code page, it's best to refer to the public "
"documentation:"
msgstr "Эта страница с кодом хорошо описана в открытой документации:"

#. type: Plain text
#: man-pages/man7/vdso.7:255
msgid "http://docs.blackfin.uclinux.org/doku.php?id=linux-kernel:fixed-code"
msgstr "http://docs.blackfin.uclinux.org/doku.php?id=linux-kernel:fixed-code"

#. type: SS
#: man-pages/man7/vdso.7:255
#, no-wrap
msgid "mips functions"
msgstr "Функции на mips"

#. type: tbl table
#: man-pages/man7/vdso.7:266 man-pages/man7/vdso.7:267
#, no-wrap
msgid "CW<LINUX_2.6 (exported since Linux 4.4)>"
msgstr "CW<LINUX_2.6 (экспортируется начиная с Linux 4.4)>"

#. type: SS
#: man-pages/man7/vdso.7:273
#, no-wrap
msgid "ia64 (Itanium) functions"
msgstr "Функции на ia64 (Itanium)"

#. type: tbl table
#: man-pages/man7/vdso.7:284
#, no-wrap
msgid "CW<__kernel_sigtramp>"
msgstr "CW<__kernel_sigtramp>"

#. type: tbl table
#: man-pages/man7/vdso.7:284 man-pages/man7/vdso.7:285
#: man-pages/man7/vdso.7:286 man-pages/man7/vdso.7:522
#: man-pages/man7/vdso.7:523 man-pages/man7/vdso.7:524
#, no-wrap
msgid "CW<LINUX_2.5>"
msgstr "CW<LINUX_2.5>"

#. type: tbl table
#: man-pages/man7/vdso.7:285
#, no-wrap
msgid "CW<__kernel_syscall_via_break>"
msgstr "CW<__kernel_syscall_via_break>"

#. type: tbl table
#: man-pages/man7/vdso.7:286
#, no-wrap
msgid "CW<__kernel_syscall_via_epc>"
msgstr "CW<__kernel_syscall_via_epc>"

#. type: Plain text
#: man-pages/man7/vdso.7:305
msgid ""
"The Itanium port is somewhat tricky.  In addition to the vDSO above, it also"
" has \"light-weight system calls\" (also known as \"fast syscalls\" or "
"\"fsys\").  You can invoke these via the I<__kernel_syscall_via_epc> vDSO "
"helper.  The system calls listed here have the same semantics as if you "
"called them directly via B<syscall>(2), so refer to the relevant "
"documentation for each.  The table below lists the functions available via "
"this mechanism."
msgstr "Перенос на Itanium, в некоторой степени, неоднозначный. Кроме vDSO, показанной выше, также есть «легковесные системные вызовы» (также называемые как «быстрые syscall» или «fsys»). Вы можете вызвать их через вспомогательную функцию vDSO I<__kernel_syscall_via_epc>. Перечисленные здесь системные вызовы имеют ту же семантику, как если бы вызывались напрямую через B<syscall>(2), поэтому обратитесь к соответствующей документации по каждому из них. В таблице ниже перечислены функции, доступные через этот механизм."

#. type: tbl table
#: man-pages/man7/vdso.7:310 man-pages/man7/vdso.7:346
#, no-wrap
msgid "CW<function>"
msgstr "CW<функция>"

#. type: tbl table
#: man-pages/man7/vdso.7:312
#, no-wrap
msgid "CW<clock_gettime>"
msgstr "CW<clock_gettime>"

#. type: tbl table
#: man-pages/man7/vdso.7:313
#, no-wrap
msgid "CW<getcpu>"
msgstr "CW<getcpu>"

#. type: tbl table
#: man-pages/man7/vdso.7:314
#, no-wrap
msgid "CW<getpid>"
msgstr "CW<getpid>"

#. type: tbl table
#: man-pages/man7/vdso.7:315
#, no-wrap
msgid "CW<getppid>"
msgstr "CW<getppid>"

#. type: tbl table
#: man-pages/man7/vdso.7:316
#, no-wrap
msgid "CW<gettimeofday>"
msgstr "CW<gettimeofday>"

#. type: tbl table
#: man-pages/man7/vdso.7:317
#, no-wrap
msgid "CW<set_tid_address>"
msgstr "CW<set_tid_address>"

#. type: SS
#: man-pages/man7/vdso.7:323
#, no-wrap
msgid "parisc (hppa) functions"
msgstr "Функции на parisc (hppa)"

#.  See linux/arch/parisc/kernel/syscall.S
#.  See linux/Documentation/parisc/registers
#. type: Plain text
#: man-pages/man7/vdso.7:334
msgid ""
"The parisc port has a code page with utility functions called a gateway "
"page.  Rather than use the normal ELF auxiliary vector approach, it passes "
"the address of the page to the process via the SR2 register.  The "
"permissions on the page are such that merely executing those addresses "
"automatically executes with kernel privileges and not in user space.  This "
"is done to match the way HP-UX works."
msgstr "Перенос parisc содержит страницу кода со вспомогательными функциями, называемую шлюзовой (gateway) страницей. Вместо того, чтобы использовать обычный вспомогательный вектор ELF, передаётся адрес страницы для обработки через регистр SR2. Права на страницу таковы, что простое выполнение этих адресов автоматически выполняется с правами ядра и не в пространстве пользователя. Подобный способ применяется в HP-UX."

#. type: Plain text
#: man-pages/man7/vdso.7:339
msgid ""
"Since it's just a raw page of code, there is no ELF information for doing "
"symbol lookups or versioning.  Simply call into the appropriate offset via "
"the branch instruction, for example:"
msgstr "Так как это просто страница с кодом, информация ELF отсутствует и поиск функций невозможен и неизвестны их версии. Просто вызывайте функцию по соответствующему смещению через инструкцию ветвления, например:"

#. type: Plain text
#: man-pages/man7/vdso.7:341
#, no-wrap
msgid "    ble E<lt>offsetE<gt>(%sr2, %r0)\n"
msgstr "    ble E<lt>смещениеE<gt>(%sr2, %r0)\n"

#. type: tbl table
#: man-pages/man7/vdso.7:346
#, no-wrap
msgid "CW<offset>"
msgstr "CW<смещение>"

#. type: tbl table
#: man-pages/man7/vdso.7:348
#, no-wrap
msgid "CW<00b0>"
msgstr "CW<00b0>"

#. type: tbl table
#: man-pages/man7/vdso.7:348
#, no-wrap
msgid "CW<lws_entry (CAS operations)>"
msgstr "CW<lws_entry (операции CAS)>"

#. type: tbl table
#: man-pages/man7/vdso.7:349
#, no-wrap
msgid "CW<00e0>"
msgstr "CW<00e0>"

#. type: tbl table
#: man-pages/man7/vdso.7:349
#, no-wrap
msgid "CW<set_thread_pointer (used by glibc)>"
msgstr "CW<set_thread_pointer (используется в glibc)>"

#. type: tbl table
#: man-pages/man7/vdso.7:350
#, no-wrap
msgid "CW<0100>"
msgstr "CW<0100>"

#. type: tbl table
#: man-pages/man7/vdso.7:350
#, no-wrap
msgid "CW<linux_gateway_entry (syscall)>"
msgstr "CW<linux_gateway_entry (syscall)>"

#. type: SS
#: man-pages/man7/vdso.7:356
#, no-wrap
msgid "ppc/32 functions"
msgstr "Функции на ppc/32"

#.  See linux/arch/powerpc/kernel/vdso32/vdso32.lds.S
#. type: Plain text
#: man-pages/man7/vdso.7:363
msgid ""
"The table below lists the symbols exported by the vDSO.  The functions "
"marked with a I<*> are available only when the kernel is a PowerPC64 "
"(64-bit) kernel."
msgstr "В таблице ниже перечислены символы, экспортируемые vDSO. Функции, помеченные I<*>, доступны только в ядре PowerPC64 (64-бита)."

#. type: tbl table
#: man-pages/man7/vdso.7:370 man-pages/man7/vdso.7:371
#: man-pages/man7/vdso.7:372 man-pages/man7/vdso.7:373
#: man-pages/man7/vdso.7:374 man-pages/man7/vdso.7:409
#: man-pages/man7/vdso.7:410 man-pages/man7/vdso.7:411
#: man-pages/man7/vdso.7:412 man-pages/man7/vdso.7:413
#: man-pages/man7/vdso.7:414 man-pages/man7/vdso.7:415
#: man-pages/man7/vdso.7:416 man-pages/man7/vdso.7:417
#: man-pages/man7/vdso.7:418
#, no-wrap
msgid "CW<LINUX_2.6.15>"
msgstr "CW<LINUX_2.6.15>"

#. type: tbl table
#: man-pages/man7/vdso.7:372 man-pages/man7/vdso.7:411
#, no-wrap
msgid "CW<__kernel_datapage_offset>"
msgstr "CW<__kernel_datapage_offset>"

#. type: tbl table
#: man-pages/man7/vdso.7:373 man-pages/man7/vdso.7:412
#, no-wrap
msgid "CW<__kernel_get_syscall_map>"
msgstr "CW<__kernel_get_syscall_map>"

#. type: tbl table
#: man-pages/man7/vdso.7:374 man-pages/man7/vdso.7:413
#, no-wrap
msgid "CW<__kernel_get_tbfreq>"
msgstr "CW<__kernel_get_tbfreq>"

#. type: tbl table
#: man-pages/man7/vdso.7:375
#, no-wrap
msgid "CW<__kernel_getcpu >I<*>"
msgstr "CW<__kernel_getcpu >I<*>"

#. type: tbl table
#: man-pages/man7/vdso.7:375 man-pages/man7/vdso.7:376
#: man-pages/man7/vdso.7:377 man-pages/man7/vdso.7:378
#: man-pages/man7/vdso.7:379 man-pages/man7/vdso.7:380
#, no-wrap
msgid "LINUX_2.6.15"
msgstr "LINUX_2.6.15"

#. type: tbl table
#: man-pages/man7/vdso.7:376
#, no-wrap
msgid "__kernel_gettimeofday"
msgstr "__kernel_gettimeofday"

#. type: tbl table
#: man-pages/man7/vdso.7:377
#, no-wrap
msgid "__kernel_sigtramp_rt32"
msgstr "__kernel_sigtramp_rt32"

#. type: tbl table
#: man-pages/man7/vdso.7:378
#, no-wrap
msgid "__kernel_sigtramp32"
msgstr "__kernel_sigtramp32"

#. type: tbl table
#: man-pages/man7/vdso.7:379
#, no-wrap
msgid "__kernel_sync_dicache"
msgstr "__kernel_sync_dicache"

#. type: tbl table
#: man-pages/man7/vdso.7:380
#, no-wrap
msgid "__kernel_sync_dicache_p5"
msgstr "__kernel_sync_dicache_p5"

#. type: Plain text
#: man-pages/man7/vdso.7:386
msgid "I<\\}>"
msgstr "I<\\}>"

#. type: Plain text
#: man-pages/man7/vdso.7:399 man-pages/man7/vdso.7:437
msgid ""
"The B<CLOCK_REALTIME_COARSE> and B<CLOCK_MONOTONIC_COARSE> clocks are I<not>"
" supported by the I<__kernel_clock_getres> and I<__kernel_clock_gettime> "
"interfaces; the kernel falls back to the real system call."
msgstr "Часы B<CLOCK_REALTIME_COARSE> и B<CLOCK_MONOTONIC_COARSE> I<не поддерживаются> в интерфейсах I<__kernel_clock_getres> и I<__kernel_clock_gettime>; ядро вернется к использованию реального системного вызова."

#. type: SS
#: man-pages/man7/vdso.7:399
#, no-wrap
msgid "ppc/64 functions"
msgstr "Функции на ppc/64"

#. type: tbl table
#: man-pages/man7/vdso.7:414 man-pages/man7/vdso.7:451
#, no-wrap
msgid "CW<__kernel_getcpu>"
msgstr "CW<__kernel_getcpu>"

#. type: tbl table
#: man-pages/man7/vdso.7:416
#, no-wrap
msgid "CW<__kernel_sigtramp_rt64>"
msgstr "CW<__kernel_sigtramp_rt64>"

#. type: tbl table
#: man-pages/man7/vdso.7:417
#, no-wrap
msgid "CW<__kernel_sync_dicache>"
msgstr "CW<__kernel_sync_dicache>"

#. type: tbl table
#: man-pages/man7/vdso.7:418
#, no-wrap
msgid "CW<__kernel_sync_dicache_p5>"
msgstr "CW<__kernel_sync_dicache_p5>"

#. type: SS
#: man-pages/man7/vdso.7:437
#, no-wrap
msgid "riscv functions"
msgstr ""

#. type: tbl table
#: man-pages/man7/vdso.7:447 man-pages/man7/vdso.7:448
#: man-pages/man7/vdso.7:449 man-pages/man7/vdso.7:450
#: man-pages/man7/vdso.7:451 man-pages/man7/vdso.7:452
#, no-wrap
msgid "CW<LINUX_4.15>"
msgstr ""

#. type: tbl table
#: man-pages/man7/vdso.7:452
#, no-wrap
msgid "CW<__kernel_flush_icache>"
msgstr ""

#. type: SS
#: man-pages/man7/vdso.7:458
#, no-wrap
msgid "s390 functions"
msgstr "Функции на s390"

#. type: tbl table
#: man-pages/man7/vdso.7:468 man-pages/man7/vdso.7:469
#: man-pages/man7/vdso.7:470 man-pages/man7/vdso.7:486
#: man-pages/man7/vdso.7:487 man-pages/man7/vdso.7:488
#, no-wrap
msgid "CW<LINUX_2.6.29>"
msgstr "CW<LINUX_2.6.29>"

#. type: SS
#: man-pages/man7/vdso.7:476
#, no-wrap
msgid "s390x functions"
msgstr "Функции на s390x"

#. type: SS
#: man-pages/man7/vdso.7:494
#, no-wrap
msgid "sh (SuperH) functions"
msgstr "Функции на sh (SuperH)"

#. type: tbl table
#: man-pages/man7/vdso.7:504 man-pages/man7/vdso.7:505
#: man-pages/man7/vdso.7:506 man-pages/man7/vdso.7:547
#: man-pages/man7/vdso.7:548 man-pages/man7/vdso.7:549
#: man-pages/man7/vdso.7:550 man-pages/man7/vdso.7:566
#: man-pages/man7/vdso.7:567 man-pages/man7/vdso.7:568
#: man-pages/man7/vdso.7:569
#, no-wrap
msgid "CW<LINUX_2.6>"
msgstr "CW<LINUX_2.6>"

#. type: tbl table
#: man-pages/man7/vdso.7:505 man-pages/man7/vdso.7:522
#, no-wrap
msgid "CW<__kernel_sigreturn>"
msgstr "CW<__kernel_sigreturn>"

#. type: tbl table
#: man-pages/man7/vdso.7:506 man-pages/man7/vdso.7:524
#, no-wrap
msgid "CW<__kernel_vsyscall>"
msgstr "CW<__kernel_vsyscall>"

#. type: SS
#: man-pages/man7/vdso.7:512
#, no-wrap
msgid "i386 functions"
msgstr "Функции на i386"

#. type: tbl table
#: man-pages/man7/vdso.7:527 man-pages/man7/vdso.7:528
#: man-pages/man7/vdso.7:529
#, no-wrap
msgid "CW<LINUX_2.6 (exported since Linux 3.15)>"
msgstr "CW<LINUX_2.6 (экспортируется начиная с Linux 3.15)>"

#. type: tbl table
#: man-pages/man7/vdso.7:529 man-pages/man7/vdso.7:550
#: man-pages/man7/vdso.7:569
#, no-wrap
msgid "CW<__vdso_time>"
msgstr "CW<__vdso_time>"

#. type: SS
#: man-pages/man7/vdso.7:535
#, no-wrap
msgid "x86-64 functions"
msgstr "Функции x86-64"

#.  See linux/arch/x86/vdso/vdso.lds.S
#. type: Plain text
#: man-pages/man7/vdso.7:540
msgid ""
"The table below lists the symbols exported by the vDSO.  All of these "
"symbols are also available without the \"__vdso_\" prefix, but you should "
"ignore those and stick to the names below."
msgstr "В таблице ниже перечислены символы, экспортируемые vDSO. Все эти символы также доступны без префикса «__vdso_», но вы не должны пользоваться этим, применяйте имена, перечисленные ниже."

#. type: tbl table
#: man-pages/man7/vdso.7:548 man-pages/man7/vdso.7:567
#, no-wrap
msgid "CW<__vdso_getcpu>"
msgstr "CW<__vdso_getcpu>"

#. type: SS
#: man-pages/man7/vdso.7:556
#, no-wrap
msgid "x86/x32 functions"
msgstr "Функции на x86/x32"

#. type: SS
#: man-pages/man7/vdso.7:575
#, no-wrap
msgid "History"
msgstr "История"

#. type: Plain text
#: man-pages/man7/vdso.7:582
msgid ""
"The vDSO was originally just a single function\\(emthe vsyscall.  In older "
"kernels, you might see that name in a process's memory map rather than "
"\"vdso\".  Over time, people realized that this mechanism was a great way to"
" pass more functionality to user space, so it was reconceived as a vDSO in "
"the current format."
msgstr "Первоначально vDSO представляла собой одну функцию — vsyscall. В старых ядрах вы можете видеть это имя в карте памяти процесса вместо «vdso». Со временем, люди поняли, что этот механизм является отличным способом перенести больше возможностей в пользовательское пространство, результатом чего стала vDSO в текущем виде."

#. type: Plain text
#: man-pages/man7/vdso.7:586
msgid "B<syscalls>(2), B<getauxval>(3), B<proc>(5)"
msgstr "B<syscalls>(2), B<getauxval>(3), B<proc>(5)"

#. type: Plain text
#: man-pages/man7/vdso.7:588
msgid ""
"The documents, examples, and source code in the Linux source code tree:"
msgstr "Документация, примеры и исходный код в дереве исходного кода Linux:"

#. type: Plain text
#: man-pages/man7/vdso.7:594
#, no-wrap
msgid ""
"Documentation/ABI/stable/vdso\n"
"Documentation/ia64/fsys.txt\n"
"Documentation/vDSO/* (includes examples of using the vDSO)\n"
msgstr "Documentation/ABI/stable/vdso\nDocumentation/ia64/fsys.txt\nDocumentation/vDSO/* (содержит примеры использования vDSO)\n"

#. type: Plain text
#: man-pages/man7/vdso.7:596
#, no-wrap
msgid "find arch/ -iname \\(aq*vdso*\\(aq -o -iname \\(aq*gate*\\(aq\n"
msgstr "find arch/ -iname \\(aq*vdso*\\(aq -o -iname \\(aq*gate*\\(aq\n"

#. type: TH
#: man-pages/man7/vsock.7:25
#, no-wrap
msgid "VSOCK"
msgstr "VSOCK"

#. type: TH
#: man-pages/man7/vsock.7:25
#, no-wrap
msgid "2017-11-30"
msgstr "2017-11-30"

#. type: Plain text
#: man-pages/man7/vsock.7:28
msgid "vsock - Linux VSOCK address family"
msgstr "vsock - семейство адресов Linux VSOCK"

#. type: Plain text
#: man-pages/man7/vsock.7:30
msgid "B<#include E<lt>sys/socket.hE<gt>>"
msgstr "B<#include E<lt>sys/socket.hE<gt>>"

#. type: Plain text
#: man-pages/man7/vsock.7:32
msgid "B<#include E<lt>linux/vm_sockets.hE<gt>>"
msgstr "B<#include E<lt>linux/vm_sockets.hE<gt>>"

#. type: Plain text
#: man-pages/man7/vsock.7:34
msgid "I<stream_socket>B< = socket(AF_VSOCK, SOCK_STREAM, 0);>"
msgstr "I<stream_socket>B< = socket(AF_VSOCK, SOCK_STREAM, 0);>"

#. type: Plain text
#: man-pages/man7/vsock.7:36
msgid "I<datagram_socket>B< = socket(AF_VSOCK, SOCK_DGRAM, 0);>"
msgstr "I<datagram_socket>B< = socket(AF_VSOCK, SOCK_DGRAM, 0);>"

#. type: Plain text
#: man-pages/man7/vsock.7:42
msgid ""
"The VSOCK address family facilitates communication between virtual machines "
"and the host they are running on.  This address family is used by guest "
"agents and hypervisor services that need a communications channel that is "
"independent of virtual machine network configuration."
msgstr "Семейство адресов VSOCK обеспечивают взаимодействие между виртуальными машинами и узлом, на котором они выполняются. Данное адресное семейство используется гостевыми агентами и службами супервизора, которым необходим канал связи, не зависящий от настроек сети виртуальной машины."

#. type: Plain text
#: man-pages/man7/vsock.7:54
msgid ""
"Valid socket types are B<SOCK_STREAM> and B<SOCK_DGRAM>.  B<SOCK_STREAM> "
"provides connection-oriented byte streams with guaranteed, in-order "
"delivery.  B<SOCK_DGRAM> provides a connectionless datagram packet service "
"with best-effort delivery and best-effort ordering.  Availability of these "
"socket types is dependent on the underlying hypervisor."
msgstr "Возможные типы сокета: B<SOCK_STREAM> и B<SOCK_DGRAM>. Тип B<SOCK_STREAM> предоставляет байтовые потоки с установлением соединения и упорядоченной доставкой. Тип B<SOCK_DGRAM> предоставляет службу датаграмных пакетов без установления соединения и  негарантированной доставкой и порядком. Доступность типов сокета зависит от используемого супервизора."

#. type: Plain text
#: man-pages/man7/vsock.7:56
msgid "A new socket is created with"
msgstr "Новый сокет создаётся с помощью вызова"

#. type: Plain text
#: man-pages/man7/vsock.7:60
#, no-wrap
msgid "socket(AF_VSOCK, socket_type, 0);\n"
msgstr "socket(AF_VSOCK, socket_type, 0);\n"

#. type: Plain text
#: man-pages/man7/vsock.7:67
msgid ""
"When a process wants to establish a connection, it calls B<connect>(2)  with"
" a given destination socket address.  The socket is automatically bound to a"
" free port if unbound."
msgstr "Когда процесс хочет установить соединение, он вызывает B<connect>(2) с нужным адресом сокета назначения. Сокет автоматически привязывается к свободному порту, если этого ещё не было."

#. type: Plain text
#: man-pages/man7/vsock.7:73
msgid ""
"A process can listen for incoming connections by first binding to a socket "
"address using B<bind>(2)  and then calling B<listen>(2)."
msgstr "Процесс может слушать входящие соединения на привязанном первым адресе сокета с помощью B<bind>(2) и вызвав после этого B<listen>(2)."

#. type: Plain text
#: man-pages/man7/vsock.7:83
msgid ""
"Data is transmitted using the B<send>(2)  or B<write>(2)  families of system"
" calls and data is received using the B<recv>(2)  or B<read>(2)  families of"
" system calls."
msgstr "Данные передаются с помощью семейств системных вызовов B<send>(2) или B<write>(2), а  принимаются семействами системных вызовов B<recv>(2) или B<read>(2)."

#. type: SS
#: man-pages/man7/vsock.7:83
#, no-wrap
msgid "Address format"
msgstr "Формат адреса"

#. type: Plain text
#: man-pages/man7/vsock.7:90
msgid ""
"A socket address is defined as a combination of a 32-bit Context Identifier "
"(CID) and a 32-bit port number.  The CID identifies the source or "
"destination, which is either a virtual machine or the host.  The port number"
" differentiates between multiple services running on a single machine."
msgstr "Адрес сокета определяется как комбинация 32-битного идентификатора контекста (CID) и 32-битного номера порта. В CID задаётся источник или назначение, то есть виртуальная машина или узел. Номер порта определяет службу, выполняемую в определённой машине."

#. type: Plain text
#: man-pages/man7/vsock.7:99
#, no-wrap
msgid ""
"struct sockaddr_vm {\n"
"    sa_family_t    svm_family;     /* Address family: AF_VSOCK */\n"
"    unsigned short svm_reserved1;\n"
"    unsigned int   svm_port;       /* Port # in host byte order */\n"
"    unsigned int   svm_cid;        /* Address in host byte order */\n"
"};\n"
msgstr "struct sockaddr_vm {\n    sa_family_t    svm_family;     /* семейство адресов: AF_VSOCK */\n    unsigned short svm_reserved1;\n    unsigned int   svm_port;       /* номер порта в порядке байт узла */\n    unsigned int   svm_cid;        /* адрес в порядке байт узла */\n};\n"

#. type: Plain text
#: man-pages/man7/vsock.7:116
msgid ""
"I<svm_family> is always set to B<AF_VSOCK>.  I<svm_reserved1> is always set "
"to 0.  I<svm_port> contains the port number in host byte order.  The port "
"numbers below 1024 are called I<privileged ports>.  Only a process with the "
"B<CAP_NET_BIND_SERVICE> capability may B<bind>(2)  to these port numbers."
msgstr "Значение I<svm_family> всегда равно B<AF_VSOCK>. Значение I<svm_reserved1> всегда равно to 0. Значение I<svm_port> содержит номер порта в порядке байт узла. Номера портов меньше 1024 называются I<привилегированными портами>.  Только процесс с мандатом B<CAP_NET_BIND_SERVICE> может вызывать B<bind>(2) с такими номерами."

#. type: Plain text
#: man-pages/man7/vsock.7:128
msgid ""
"There are several special addresses: B<VMADDR_CID_ANY> (-1U)  means any "
"address for binding; B<VMADDR_CID_HYPERVISOR> (0) is reserved for services "
"built into the hypervisor; B<VMADDR_CID_RESERVED> (1) must not be used; "
"B<VMADDR_CID_HOST> (2)  is the well-known address of the host."
msgstr "Существует несколько специальных адресов: B<VMADDR_CID_ANY> (-1U) означает любой адрес при привязывании; B<VMADDR_CID_HYPERVISOR> (0) зарезервирован для служб встроенных в супервизор; B<VMADDR_CID_RESERVED> (1) не должен использоваться; B<VMADDR_CID_HOST> (2) общеизвестный (well-known) адрес узла."

#. type: Plain text
#: man-pages/man7/vsock.7:133
msgid ""
"The special constant B<VMADDR_PORT_ANY> (-1U)  means any port number for "
"binding."
msgstr "Специальная константа B<VMADDR_PORT_ANY> (-1U) означает любой порт для связывания."

#. type: SS
#: man-pages/man7/vsock.7:133
#, no-wrap
msgid "Live migration"
msgstr "Живая миграция"

#. type: Plain text
#: man-pages/man7/vsock.7:139
msgid ""
"Sockets are affected by live migration of virtual machines.  Connected "
"B<SOCK_STREAM> sockets become disconnected when the virtual machine migrates"
" to a new host.  Applications must reconnect when this happens."
msgstr "На сокеты действует живая миграния виртуальных машин. Соединённые сокеты B<SOCK_STREAM> становятся отключёнными, если виртуальная машина мигрирует на новый узел. Когда это происходит приложения должны выполнить переподключение."

#. type: Plain text
#: man-pages/man7/vsock.7:143
msgid ""
"The local CID may change across live migration if the old CID is not "
"available on the new host.  Bound sockets are automatically updated to the "
"new CID."
msgstr "Локальный CID при живой миграции может измениться, если старый CID недоступен на новом узле. Привязанные сокеты автоматически обновляются новым CID."

#. type: SS
#: man-pages/man7/vsock.7:143
#, no-wrap
msgid "Ioctls"
msgstr "Вызовы ioctl"

#. type: TP
#: man-pages/man7/vsock.7:144
#, no-wrap
msgid "B<IOCTL_VM_SOCKETS_GET_LOCAL_CID>"
msgstr "B<IOCTL_VM_SOCKETS_GET_LOCAL_CID>"

#. type: Plain text
#: man-pages/man7/vsock.7:149
msgid ""
"Get the CID of the local machine.  The argument is a pointer to an "
"I<unsigned int>."
msgstr "Получить CID локальной машины. Аргументом является указатель на I<unsigned int>."

#. type: Plain text
#: man-pages/man7/vsock.7:153
#, no-wrap
msgid "ioctl(socket, IOCTL_VM_SOCKETS_GET_LOCAL_CID, &cid);\n"
msgstr "ioctl(socket, IOCTL_VM_SOCKETS_GET_LOCAL_CID, &cid);\n"

#. type: Plain text
#: man-pages/man7/vsock.7:160
msgid ""
"Consider using B<VMADDR_CID_ANY> when binding instead of getting the local "
"CID with B<IOCTL_VM_SOCKETS_GET_LOCAL_CID>."
msgstr "Рассматривать использование B<VMADDR_CID_ANY> при привязывании, вместо получения локального CID с помощью B<IOCTL_VM_SOCKETS_GET_LOCAL_CID>."

#. type: SH
#: man-pages/man7/vsock.7:160
#, no-wrap
msgid "ERRORS"
msgstr "ОШИБКИ"

#. type: TP
#: man-pages/man7/vsock.7:161
#, no-wrap
msgid "B<EACCES>"
msgstr "B<EACCES>"

#. type: Plain text
#: man-pages/man7/vsock.7:166
msgid ""
"Unable to bind to a privileged port without the B<CAP_NET_BIND_SERVICE> "
"capability."
msgstr "Невозможно привязаться к привилегированному порту не имея мандата B<CAP_NET_BIND_SERVICE>."

#. type: TP
#: man-pages/man7/vsock.7:166
#, no-wrap
msgid "B<EADDRINUSE>"
msgstr "B<EADDRINUSE>"

#. type: Plain text
#: man-pages/man7/vsock.7:169
msgid "Unable to bind to a port that is already in use."
msgstr "Не могу привязаться к порту, который уже используется."

#. type: TP
#: man-pages/man7/vsock.7:169
#, no-wrap
msgid "B<EADDRNOTAVAIL>"
msgstr "B<EADDRNOTAVAIL>"

#. type: Plain text
#: man-pages/man7/vsock.7:172
msgid ""
"Unable to find a free port for binding or unable to bind to a nonlocal CID."
msgstr "Не удалось найти свободный порт для привязки или невозможно привязаться к нелокальному CID."

#. type: TP
#: man-pages/man7/vsock.7:172
#, no-wrap
msgid "B<EINVAL>"
msgstr "B<EINVAL>"

#. type: Plain text
#: man-pages/man7/vsock.7:179
msgid ""
"Invalid parameters.  This includes: attempting to bind a socket that is "
"already bound, providing an invalid struct I<sockaddr_vm>, and other input "
"validation errors."
msgstr "Некорректные параметры. Сюда относятся: попытка привязать уже привязанный сокет, указание некорректной структуры I<sockaddr_vm> и ошибки проверки правильности входных данных."

#. type: TP
#: man-pages/man7/vsock.7:179
#, no-wrap
msgid "B<ENOPROTOOPT>"
msgstr "B<ENOPROTOOPT>"

#. type: Plain text
#: man-pages/man7/vsock.7:185
msgid "Invalid socket option in B<setsockopt>(2)  or B<getsockopt>(2)."
msgstr "Недопустимый параметр сокета в B<setsockopt>(2) или B<getsockopt>(2)."

#. type: TP
#: man-pages/man7/vsock.7:185
#, no-wrap
msgid "B<ENOTCONN>"
msgstr "B<ENOTCONN>"

#. type: Plain text
#: man-pages/man7/vsock.7:188
msgid "Unable to perform operation on an unconnected socket."
msgstr "Невозможно выполнить действие с неподключённым сокетом."

#. type: TP
#: man-pages/man7/vsock.7:188
#, no-wrap
msgid "B<EOPNOTSUPP>"
msgstr "B<EOPNOTSUPP>"

#. type: Plain text
#: man-pages/man7/vsock.7:201
msgid ""
"Operation not supported.  This includes: the B<MSG_OOB> flag that is not "
"implemented for the B<send>(2)  family of syscalls and B<MSG_PEEK> for the "
"B<recv>(2)  family of syscalls."
msgstr "Операция не поддерживается. Сюда относятся: флаг B<MSG_OOB>, не реализованный для семейства вызовов B<send>(2), и B<MSG_PEEK> для семейства вызовов B<recv>(2)."

#. type: TP
#: man-pages/man7/vsock.7:201
#, no-wrap
msgid "B<EPROTONOSUPPORT>"
msgstr "B<EPROTONOSUPPORT>"

#. type: Plain text
#: man-pages/man7/vsock.7:205
msgid "Invalid socket protocol number.  The protocol should always be 0."
msgstr "Некорректный номер протокола сокета. Протокол всегда должен быть равен 0."

#. type: TP
#: man-pages/man7/vsock.7:205
#, no-wrap
msgid "B<ESOCKTNOSUPPORT>"
msgstr "B<ESOCKTNOSUPPORT>"

#. type: Plain text
#: man-pages/man7/vsock.7:214
msgid ""
"Unsupported socket type in B<socket>(2).  Only B<SOCK_STREAM> and "
"B<SOCK_DGRAM> are valid."
msgstr "Неподдерживаемый тип сокета в B<socket>(2). Допускаются только B<SOCK_STREAM> и B<SOCK_DGRAM>."

#. type: Plain text
#: man-pages/man7/vsock.7:218
msgid ""
"Support for VMware (VMCI) has been available since Linux 3.9.  KVM (virtio) "
"is supported since Linux 4.8.  Hyper-V is supported since Linux 4.14."
msgstr "Поддержка для VMware (VMCI) доступна начиная с Linux 3.9. KVM (virtio) поддерживается начиная с Linux 4.8. Hyper-V поддерживается начиная с Linux 4.14."

#. type: Plain text
#: man-pages/man7/vsock.7:225
msgid ""
"B<bind>(2), B<connect>(2), B<listen>(2), B<recv>(2), B<send>(2), "
"B<socket>(2), B<capabilities>(7)"
msgstr "B<bind>(2), B<connect>(2), B<listen>(2), B<recv>(2), B<send>(2), B<socket>(2), B<capabilities>(7)"

#. type: TH
#: man-pages/man2/vmsplice.2:26
#, no-wrap
msgid "VMSPLICE"
msgstr "VMSPLICE"

#. type: Plain text
#: man-pages/man2/vmsplice.2:29
msgid "vmsplice - splice user pages to/from a pipe"
msgstr "vmsplice - соединяет пользовательские страницы памяти с каналом"

#. type: Plain text
#: man-pages/man2/vmsplice.2:34
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>         /* See feature_test_macros(7) */\n"
"B<#include E<lt>fcntl.hE<gt>>\n"
"B<#include E<lt>sys/uio.hE<gt>>\n"
msgstr "B<#define _GNU_SOURCE>         /* см. feature_test_macros(7) */\nB<#include E<lt>fcntl.hE<gt>>\nB<#include E<lt>sys/uio.hE<gt>>\n"

#. type: Plain text
#: man-pages/man2/vmsplice.2:37
#, no-wrap
msgid ""
"B<ssize_t vmsplice(int >I<fd>B<, const struct iovec *>I<iov>B<,>\n"
"B<                 unsigned long >I<nr_segs>B<, unsigned int >I<flags>B<);>\n"
msgstr "B<ssize_t vmsplice(int >I<fd>B<, const struct iovec *>I<iov>B<,>\nB<                 unsigned long >I<nr_segs>B<, unsigned int >I<flags>B<);>\n"

#.  Linus: vmsplice() system call to basically do a "write to
#.  the buffer", but using the reference counting and VM traversal
#.  to actually fill the buffer. This means that the user needs to
#.  be careful not to reuse the user-space buffer it spliced into
#.  the kernel-space one (contrast this to "write()", which copies
#.  the actual data, and you can thus reuse the buffer immediately
#.  after a successful write), but that is often easy to do.
#.  Since Linux 2.6.23
#.  commit 6a14b90bb6bc7cd83e2a444bf457a2ea645cbfe7
#. type: Plain text
#: man-pages/man2/vmsplice.2:71
msgid ""
"If I<fd> is opened for writing, the B<vmsplice>()  system call maps "
"I<nr_segs> ranges of user memory described by I<iov> into a pipe.  If I<fd> "
"is opened for reading, the B<vmsplice>()  system call fills I<nr_segs> "
"ranges of user memory described by I<iov> from a pipe.  The file descriptor "
"I<fd> must refer to a pipe."
msgstr "Если I<fd> открыт для записи, то системный вызов B<vmsplice>() отображает I<nr_segs> областей пользовательской памяти, описанных I<iov>, в канал. Если I<fd> открыт для чтения, то системный вызов B<vmsplice>() заполняет I<nr_segs> областей пользовательской памяти, описанных I<iov>, из канала. Файловый дескриптор I<fd> должен указывать на канал."

#. type: Plain text
#: man-pages/man2/vmsplice.2:78
msgid ""
"The pointer I<iov> points to an array of I<iovec> structures as defined in "
"I<E<lt>sys/uio.hE<gt>>:"
msgstr "Указатель I<iov> указывает на массив структур I<iovec>, определённых в I<E<lt>sys/uio.hE<gt>>:"

#. type: Plain text
#: man-pages/man2/vmsplice.2:85
#, no-wrap
msgid ""
"struct iovec {\n"
"    void  *iov_base;        /* Starting address */\n"
"    size_t iov_len;         /* Number of bytes */\n"
"};\n"
msgstr "struct iovec {\n    void  *iov_base;        /* начальный адрес */\n    size_t iov_len;         /* количество байт */\n};\n"

#. type: Plain text
#: man-pages/man2/vmsplice.2:92
msgid ""
"The I<flags> argument is a bit mask that is composed by ORing together zero "
"or more of the following values:"
msgstr "Аргумент I<flags> представляет собой битовую маску, которая составляется логическим сложением (OR) следующих значений:"

#. type: TP
#: man-pages/man2/vmsplice.2:92
#, no-wrap
msgid "B<SPLICE_F_MOVE>"
msgstr "B<SPLICE_F_MOVE>"

#. type: Plain text
#: man-pages/man2/vmsplice.2:98
msgid "Unused for B<vmsplice>(); see B<splice>(2)."
msgstr "Не используется в B<vmsplice>(); см. B<splice>(2)."

#. type: TP
#: man-pages/man2/vmsplice.2:98
#, no-wrap
msgid "B<SPLICE_F_NONBLOCK>"
msgstr "B<SPLICE_F_NONBLOCK>"

#.  Not used for vmsplice
#.  May be in the future -- therefore EAGAIN
#. type: Plain text
#: man-pages/man2/vmsplice.2:105
msgid "Do not block on I/O; see B<splice>(2)  for further details."
msgstr "Не блокировать ввод-вывод; подробности в B<splice>(2)."

#. type: TP
#: man-pages/man2/vmsplice.2:105
#, no-wrap
msgid "B<SPLICE_F_MORE>"
msgstr "B<SPLICE_F_MORE>"

#. type: Plain text
#: man-pages/man2/vmsplice.2:111
msgid ""
"Currently has no effect for B<vmsplice>(), but may be implemented in the "
"future; see B<splice>(2)."
msgstr "В данный момент никак не влияет при указании в B<vmsplice>(), но это может измениться; см. B<splice>(2)."

#. type: TP
#: man-pages/man2/vmsplice.2:111
#, no-wrap
msgid "B<SPLICE_F_GIFT>"
msgstr "B<SPLICE_F_GIFT>"

#.  FIXME . Explain the following line in a little more detail:
#.  FIXME
#.  It looks like the page-alignment requirement went away with
#.  commit bd1a68b59c8e3bce45fb76632c64e1e063c3962d
#.  .... if we expect to later SPLICE_F_MOVE to the cache.
#. type: Plain text
#: man-pages/man2/vmsplice.2:131
msgid ""
"The user pages are a gift to the kernel.  The application may not modify "
"this memory ever, otherwise the page cache and on-disk data may differ.  "
"Gifting pages to the kernel means that a subsequent B<splice>(2)  "
"B<SPLICE_F_MOVE> can successfully move the pages; if this flag is not "
"specified, then a subsequent B<splice>(2)  B<SPLICE_F_MOVE> must copy the "
"pages.  Data must also be properly page aligned, both in memory and length."
msgstr "Предоставить ядру пользовательские страницы. Приложение, возможно, не изменяло эту память, иначе страничный кэш и данные на диске будут различны. Передача страниц ядру означает, что последующий вызов B<splice>(2) с флагом B<SPLICE_F_MOVE> сможет переместить страницы; если этот флаг не указан, то последующий B<splice>(2) с флагом B<SPLICE_F_MOVE> должен скопировать страницы. Также, данные должны быть выровнены по странице: по адресам памяти и размеру."

#. type: SH
#: man-pages/man2/vmsplice.2:131
#, no-wrap
msgid "RETURN VALUE"
msgstr "ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ"

#. type: Plain text
#: man-pages/man2/vmsplice.2:140
msgid ""
"Upon successful completion, B<vmsplice>()  returns the number of bytes "
"transferred to the pipe.  On error, B<vmsplice>()  returns -1 and I<errno> "
"is set to indicate the error."
msgstr "При успешном выполнении B<vmsplice>() возвращается количество байт, переданных в канал. При ошибке B<vmsplice>() возвращает -1, а I<errno> устанавливается в соответствующее значение."

#. type: TP
#: man-pages/man2/vmsplice.2:141
#, no-wrap
msgid "B<EAGAIN>"
msgstr "B<EAGAIN>"

#. type: Plain text
#: man-pages/man2/vmsplice.2:147
msgid ""
"B<SPLICE_F_NONBLOCK> was specified in I<flags>, and the operation would "
"block."
msgstr "В указан I<flags> B<SPLICE_F_NONBLOCK>, и операция вызвала бы блокировку."

#. type: TP
#: man-pages/man2/vmsplice.2:147
#, no-wrap
msgid "B<EBADF>"
msgstr "B<EBADF>"

#. type: Plain text
#: man-pages/man2/vmsplice.2:151
msgid "I<fd> either not valid, or doesn't refer to a pipe."
msgstr "Неправильное значение I<fd> или оно не указывает на канал."

#. type: Plain text
#: man-pages/man2/vmsplice.2:159
msgid ""
"I<nr_segs> is greater than B<IOV_MAX>; or memory not aligned if "
"B<SPLICE_F_GIFT> set."
msgstr "Значение I<nr_segs> больше B<IOV_MAX>; или, если задан B<SPLICE_F_GIFT>, не выровнена память."

#. type: TP
#: man-pages/man2/vmsplice.2:159
#, no-wrap
msgid "B<ENOMEM>"
msgstr "B<ENOMEM>"

#. type: Plain text
#: man-pages/man2/vmsplice.2:162
msgid "Out of memory."
msgstr "Не хватает памяти."

#. type: Plain text
#: man-pages/man2/vmsplice.2:167
msgid ""
"The B<vmsplice>()  system call first appeared in Linux 2.6.17; library "
"support was added to glibc in version 2.5."
msgstr "Системный вызов B<vmsplice>() впервые появился в Linux 2.6.17; поддержка в glibc добавлена в версии 2.5."

#. type: SH
#: man-pages/man2/vmsplice.2:167
#, no-wrap
msgid "CONFORMING TO"
msgstr "СООТВЕТСТВИЕ СТАНДАРТАМ"

#. type: Plain text
#: man-pages/man2/vmsplice.2:169
msgid "This system call is Linux-specific."
msgstr "Данный вызов есть только в Linux."

#.  UIO_MAXIOV in kernel source
#. type: Plain text
#: man-pages/man2/vmsplice.2:180
msgid ""
"B<vmsplice>()  follows the other vectorized read/write type functions when "
"it comes to limitations on the number of segments being passed in.  This "
"limit is B<IOV_MAX> as defined in I<E<lt>limits.hE<gt>>.  Currently, this "
"limit is 1024."
msgstr "Вызов B<vmsplice>() следует другим функциям векторизованного чтения/записи при возникновении ограничений на количество передаваемых сегментов. Это ограничение равно B<IOV_MAX>, определяемое в I<E<lt>limits.hE<gt>>. Сейчас это значение равно 1024."

#.  commit 6a14b90bb6bc7cd83e2a444bf457a2ea645cbfe7
#. type: Plain text
#: man-pages/man2/vmsplice.2:188
msgid ""
"B<vmsplice>()  really supports true splicing only from user memory to a "
"pipe.  In the opposite direction, it actually just copies the data to "
"userspace.  But this makes the interface nice and symmetric and enables "
"people to build on B<vmsplice>()  with room for future improvement in "
"performance."
msgstr "Настоящую стыковку B<vmsplice>() поддерживает только для отображения пользовательской памяти в канал. В обратном направлении, в действительности, он просто копирует данные в пользовательское пространство. Но это делает интерфейс приятным и симметричным, и позволяет людям строить на B<vmsplice>() с пространством будущего улучшения производительности."

#. type: Plain text
#: man-pages/man2/vmsplice.2:191
msgid "B<splice>(2), B<tee>(2), B<pipe>(7)"
msgstr "B<splice>(2), B<tee>(2), B<pipe>(7)"

#. type: TH
#: man-pages/man2/vhangup.2:28
#, no-wrap
msgid "VHANGUP"
msgstr "VHANGUP"

#. type: TH
#: man-pages/man2/vhangup.2:28
#, no-wrap
msgid "2016-03-15"
msgstr "2016-03-15"

#. type: Plain text
#: man-pages/man2/vhangup.2:31
msgid "vhangup - virtually hangup the current terminal"
msgstr "vhangup - имитирует прекращение работы текущего терминала"

#. type: Plain text
#: man-pages/man2/vhangup.2:33
msgid "B<#include E<lt>unistd.hE<gt>>"
msgstr "B<#include E<lt>unistd.hE<gt>>"

#. type: Plain text
#: man-pages/man2/vhangup.2:35
msgid "B<int vhangup(void);>"
msgstr "B<int vhangup(void);>"

#. type: Plain text
#: man-pages/man2/vhangup.2:39
msgid ""
"Feature Test Macro Requirements for glibc (see B<feature_test_macros>(7)):"
msgstr "Требования макроса тестирования свойств для glibc (см. B<feature_test_macros>(7)):"

#. type: Plain text
#: man-pages/man2/vhangup.2:43
msgid "B<vhangup>():"
msgstr "B<vhangup>():"

#. 		commit 266865c0e7b79d4196e2cc393693463f03c90bd8
#. type: Plain text
#: man-pages/man2/vhangup.2:51
#, no-wrap
msgid ""
"    Since glibc 2.21:\n"
"        _DEFAULT_SOURCE\n"
"    In glibc 2.19 and 2.20:\n"
"        _DEFAULT_SOURCE || (_XOPEN_SOURCE && _XOPEN_SOURCE\\ E<lt>\\ 500)\n"
"    Up to and including glibc 2.19:\n"
"        _BSD_SOURCE || (_XOPEN_SOURCE && _XOPEN_SOURCE\\ E<lt>\\ 500)\n"
msgstr "    начиная с glibc 2.21:\n        _DEFAULT_SOURCE\n    в glibc 2.19 и 2.20:\n        _DEFAULT_SOURCE || (_XOPEN_SOURCE && _XOPEN_SOURCE\\ E<lt>\\ 500)\n    до glibc 2.19 включительно:\n        _BSD_SOURCE || (_XOPEN_SOURCE && _XOPEN_SOURCE\\ E<lt>\\ 500)\n"

#. type: Plain text
#: man-pages/man2/vhangup.2:58
msgid ""
"B<vhangup>()  simulates a hangup on the current terminal.  This call "
"arranges for other users to have a ``clean'' terminal at login time."
msgstr "B<vhangup>() имитирует прекращение работы на текущем терминале. Этот вызов выполняет действия, необходимые для очистки терминала перед приглашением ко входу."

#. type: Plain text
#: man-pages/man2/vhangup.2:63
msgid ""
"On success, zero is returned.  On error, -1 is returned, and I<errno> is set"
" appropriately."
msgstr "При успешном выполнении возвращается 0. В случае ошибки возвращается -1, а I<errno> устанавливается в соответствующее значение."

#. type: TP
#: man-pages/man2/vhangup.2:64
#, no-wrap
msgid "B<EPERM>"
msgstr "B<EPERM>"

#. type: Plain text
#: man-pages/man2/vhangup.2:71
msgid ""
"The calling process has insufficient privilege to call B<vhangup>(); the "
"B<CAP_SYS_TTY_CONFIG> capability is required."
msgstr "Вызывающий процесс не имеет достаточно прав для вызова B<vhangup>(); требуется мандат B<CAP_SYS_TTY_CONFIG>."

#. type: Plain text
#: man-pages/man2/vhangup.2:74
msgid ""
"This call is Linux-specific, and should not be used in programs intended to "
"be portable."
msgstr "Данный вызов существует только в Linux и не должен использоваться в программах, которые должны быть переносимыми."

#. type: Plain text
#: man-pages/man2/vhangup.2:76
msgid "B<init>(1), B<capabilities>(7)"
msgstr "B<init>(1), B<capabilities>(7)"

#. type: TH
#: man-pages/man2/vfork.2:29
#, no-wrap
msgid "VFORK"
msgstr "VFORK"

#. type: TH
#: man-pages/man2/vfork.2:29
#, no-wrap
msgid "2017-09-15"
msgstr "2017-09-15"

#. type: Plain text
#: man-pages/man2/vfork.2:32
msgid "vfork - create a child process and block parent"
msgstr "vfork - создаёт дочерний процесс и блокирует родительский"

#. type: Plain text
#: man-pages/man2/vfork.2:34
msgid "B<#include E<lt>sys/types.hE<gt>>"
msgstr "B<#include E<lt>sys/types.hE<gt>>"

#. type: Plain text
#: man-pages/man2/vfork.2:38
msgid "B<pid_t vfork(void);>"
msgstr "B<pid_t vfork(void);>"

#. type: Plain text
#: man-pages/man2/vfork.2:45
msgid "B<vfork>():"
msgstr "B<vfork>():"

#. type: TP
#: man-pages/man2/vfork.2:48
#, no-wrap
msgid "Since glibc 2.12:"
msgstr "Начиная с glibc 2.12:"

#. type: Plain text
#: man-pages/man2/vfork.2:54
#, no-wrap
msgid ""
"(_XOPEN_SOURCE\\ E<gt>=\\ 500) && ! (_POSIX_C_SOURCE\\ E<gt>=\\ 200809L)\n"
"    || /* Since glibc 2.19: */ _DEFAULT_SOURCE\n"
"    || /* Glibc versions E<lt>= 2.19: */ _BSD_SOURCE\n"
msgstr "(_XOPEN_SOURCE\\ E<gt>=\\ 500) && ! (_POSIX_C_SOURCE\\ E<gt>=\\ 200809L)\n    || /* начиная с glibc 2.19: */ _DEFAULT_SOURCE\n    || /* в версиях glibc E<lt>= 2.19: */ _BSD_SOURCE\n"

#.      || _XOPEN_SOURCE\ &&\ _XOPEN_SOURCE_EXTENDED
#. type: Plain text
#: man-pages/man2/vfork.2:59
msgid "Before glibc 2.12: _BSD_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 500"
msgstr "до glibc 2.12: _BSD_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 500"

#. type: SS
#: man-pages/man2/vfork.2:63
#, no-wrap
msgid "Standard description"
msgstr "Описание в стандарте"

#. type: Plain text
#: man-pages/man2/vfork.2:82
msgid ""
"(From POSIX.1)  The B<vfork>()  function has the same effect as B<fork>(2), "
"except that the behavior is undefined if the process created by B<vfork>()  "
"either modifies any data other than a variable of type I<pid_t> used to "
"store the return value from B<vfork>(), or returns from the function in "
"which B<vfork>()  was called, or calls any other function before "
"successfully calling B<_exit>(2)  or one of the B<exec>(3)  family of "
"functions."
msgstr "(Из POSIX) Функция B<vfork>() аналогична B<fork>(2) за тем исключением, что поведение не определено, если процесс, созданный B<vfork>(), изменяет любые данные, кроме переменной типа I<pid_t>, используемой в качестве значения, возвращаемого B<vfork>(), или возвращается из функции, из которой была вызвана функция B<vfork>(), или вызывает любую функцию до удачного исполнения B<_exit>(2) или одной из функций семейства B<exec>(3)."

#. type: SS
#: man-pages/man2/vfork.2:82
#, no-wrap
msgid "Linux description"
msgstr "Описание в Linux"

#. type: Plain text
#: man-pages/man2/vfork.2:89
msgid ""
"B<vfork>(), just like B<fork>(2), creates a child process of the calling "
"process.  For details and return value and errors, see B<fork>(2)."
msgstr "B<vfork>(), так же как и B<fork>(2), создаёт дочерний процесс для вызывающего процесса. Подробности, возвращаемые значения и ошибки смотрите в  B<fork>(2)."

#. type: Plain text
#: man-pages/man2/vfork.2:98
msgid ""
"B<vfork>()  is a special case of B<clone>(2).  It is used to create new "
"processes without copying the page tables of the parent process.  It may be "
"useful in performance-sensitive applications where a child is created which "
"then immediately issues an B<execve>(2)."
msgstr "B<vfork>() \\(em это специальный вариант B<clone>(2). Он используется для создания новых процессов без копирования таблиц страниц родительского процесса. Это может использоваться в приложениях, критичных к производительности, для создания дочерних процессов, сразу же запускающих B<execve>(2)."

#. type: Plain text
#: man-pages/man2/vfork.2:118
msgid ""
"B<vfork>()  differs from B<fork>(2)  in that the calling thread is suspended"
" until the child terminates (either normally, by calling B<_exit>(2), or "
"abnormally, after delivery of a fatal signal), or it makes a call to "
"B<execve>(2).  Until that point, the child shares all memory with its "
"parent, including the stack.  The child must not return from the current "
"function or call B<exit>(3)  (which would have the effect of calling exit "
"handlers established by the parent process and flushing the parent's "
"B<stdio>(3)  buffers), but may call B<_exit>(2)."
msgstr "Вызов B<vfork>() отличается от B<fork>(2) тем, что вызывающая нить блокируется до тех пор, пока не завершится потомок (обычно, вызовом B<_exit>(2) или, что ненормально, из-за принятого необработанного сигнала) или не выполнит B<execve>(2). До этих пор потомок имеет общую память с родителем, включая стек. Потомок не должен выходить из текущей функции или вызывать B<exit>(3) (что приводит к вызовы обработчиков выхода, настроенных родительским процессом и сбрасывает буферы B<stdio>(3) родителя), но может вызвать B<_exit>(2)."

#. type: Plain text
#: man-pages/man2/vfork.2:129
msgid ""
"As with B<fork>(2), the child process created by B<vfork>()  inherits copies"
" of various of the caller's process attributes (e.g., file descriptors, "
"signal dispositions, and current working directory); the B<vfork>()  call "
"differs only in the treatment of the virtual address space, as described "
"above."
msgstr "Как и у B<fork>(2), дочерний процесс, созданный B<vfork>(), наследует копии различных атрибутов вызвавшего процесса (например, дескрипторы файлов, обработчики сигналов и текущий рабочий каталог); вызов B<vfork>() отличается только в применении виртуального адресного пространства (как описывалось выше)."

#. type: Plain text
#: man-pages/man2/vfork.2:135
msgid ""
"Signals sent to the parent arrive after the child releases the parent's "
"memory (i.e., after the child terminates or calls B<execve>(2))."
msgstr "Сигналы передаются родителю после того, как потомок разблокирует его память (т.е. после того, как потомок завершится или вызовет B<execve>(2))."

#. type: SS
#: man-pages/man2/vfork.2:135
#, no-wrap
msgid "Historic description"
msgstr "Историческое описание"

#. type: Plain text
#: man-pages/man2/vfork.2:162
msgid ""
"Under Linux, B<fork>(2)  is implemented using copy-on-write pages, so the "
"only penalty incurred by B<fork>(2)  is the time and memory required to "
"duplicate the parent's page tables, and to create a unique task structure "
"for the child.  However, in the bad old days a B<fork>(2)  would require "
"making a complete copy of the caller's data space, often needlessly, since "
"usually immediately afterward an B<exec>(3)  is done.  Thus, for greater "
"efficiency, BSD introduced the B<vfork>()  system call, which did not fully "
"copy the address space of the parent process, but borrowed the parent's "
"memory and thread of control until a call to B<execve>(2)  or an exit "
"occurred.  The parent process was suspended while the child was using its "
"resources.  The use of B<vfork>()  was tricky: for example, not modifying "
"data in the parent process depended on knowing which variables were held in "
"a register."
msgstr "В Linux вызов B<fork>(2) реализован при помощи страниц, «копируемых при записи» (copy-on-write), поэтому единственная задержка, возникающая при вызове B<fork>(2) \\(em это время, необходимое для создания копии таблиц страниц родительского процесса и уникальной структуры описания задачи дочернего процесса. Однако, в прошлом для B<fork>(2) могло требоваться создание полной копии пространства данных вызывающего процесса, что часто было ненужно, так как в потомке сразу следовал запуск функции B<exec>(3). Поэтому для большей эффективности в BSD был предложен системный вызов B<vfork>(), который не копировал адресное пространство процесса, а использовал то же самое пространство и управления нитью, блокируя родительский процесс до вызова B<execve>(2) или до прекращения работы потомка. Родительский процесс останавливался до тех пор, пока потомок использовал его ресурсы. Использование B<vfork>() было ненадёжно: например, сохранность данных родительского процесса зависела от того, хранились ли на тот момент переменные в регистрах."

#. type: Plain text
#: man-pages/man2/vfork.2:166
msgid ""
"4.3BSD; POSIX.1-2001 (but marked OBSOLETE).  POSIX.1-2008 removes the "
"specification of B<vfork>()."
msgstr "4.3BSD; POSIX.1-2001 (помечен как УСТАРЕВШИЙ). Из POSIX.1-2008 описание B<vfork>() было удалено."

#.  In AIXv3.1 vfork is equivalent to fork.
#. type: Plain text
#: man-pages/man2/vfork.2:177
msgid ""
"The requirements put on B<vfork>()  by the standards are weaker than those "
"put on B<fork>(2), so an implementation where the two are synonymous is "
"compliant.  In particular, the programmer cannot rely on the parent "
"remaining blocked until the child either terminates or calls B<execve>(2), "
"and cannot rely on any specific behavior with respect to shared memory."
msgstr "Требования, предъявляемые стандартами к B<vfork>(), не такие жёсткие как те, которые предъявляются к B<fork>(2), поэтому в реализации достаточно просто сделать их синонимами. В частности, программист не может полагаться на блокировку родителя до завершения потомка или до вызова им B<execve>(2), и не может полагаться на специфическое поведение возникновения общей памяти."

#. type: Plain text
#: man-pages/man2/vfork.2:196
msgid ""
"Some consider the semantics of B<vfork>()  to be an architectural blemish, "
"and the 4.2BSD man page stated: \"This system call will be eliminated when "
"proper system sharing mechanisms are implemented.  Users should not depend "
"on the memory sharing semantics of B<vfork>()  as it will, in that case, be "
"made synonymous to B<fork>(2).\" However, even though modern memory "
"management hardware has decreased the performance difference between "
"B<fork>(2)  and B<vfork>(), there are various reasons why Linux and other "
"systems have retained B<vfork>():"
msgstr "Некоторые считают, что в семантике B<vfork>() есть архитектурный недостаток, а в справочной странице BSD написано следующее: «Данный системный вызов будет удалён после того, как будут правильно реализованы соответствующие механизмы разделения ресурсов системы. Пользователи не должны опираться на существующую семантику общей памяти B<vfork>(), то есть программа должна быть аналогична программе с B<fork>(2)». Однако, даже при том, что современные аппаратные средства управления памятью уменьшили разницу в производительности между B<fork>(2) и B<vfork>(), есть другие причины почему в Linux и других операционных системах B<vfork>() ещё существует:"

#. type: IP
#: man-pages/man2/vfork.2:196 man-pages/man2/vfork.2:200
#: man-pages/man2/vfork.2:217
#, no-wrap
msgid "*"
msgstr "*"

#. type: Plain text
#: man-pages/man2/vfork.2:200
msgid ""
"Some performance-critical applications require the small performance "
"advantage conferred by B<vfork>()."
msgstr "Для некоторых критичных к производительности приложений очень важна та маленькая прибавка к производительности, предоставляемая B<vfork>()."

#.  http://stackoverflow.com/questions/4259629/what-is-the-difference-between-
#. fork-and-vfork
#.  http://developers.sun.com/solaris/articles/subprocess/subprocess.html
#.  http://mailman.uclinux.org/pipermail/uclinux-dev/2009-April/000684.html
#. type: Plain text
#: man-pages/man2/vfork.2:217
msgid ""
"B<vfork>()  can be implemented on systems that lack a memory-management unit"
" (MMU), but B<fork>(2)  can't be implemented on such systems.  (POSIX.1-2008"
" removed B<vfork>()  from the standard; the POSIX rationale for the "
"B<posix_spawn>(3)  function notes that that function, which provides "
"functionality equivalent to B<fork>(2)+B<exec>(3), is designed to be "
"implementable on systems that lack an MMU.)"
msgstr "Вызов B<vfork>() может быть реализован в системах, у которых нет блока управления памятью (MMU), а B<fork>(2) невозможно реализовать на таких системах (из POSIX.1-2008 вызов B<vfork>() удалён; для реализации эквивалента B<fork>(2)+B<exec>(3) в системах без MMU в POSIX предлагается использовать функцию B<posix_spawn>(3))."

#. type: Plain text
#: man-pages/man2/vfork.2:234
msgid ""
"On systems where memory is constrained, B<vfork>()  avoids the need to "
"temporarily commit memory (see the description of "
"I</proc/sys/vm/overcommit_memory> in B<proc>(5))  in order to execute a new "
"program.  (This can be especially beneficial where a large parent process "
"wishes to execute a small helper program in a child process.)  By contrast, "
"using B<fork>(2)  in this scenario requires either committing an amount of "
"memory equal to the size of the parent process (if strict overcommitting is "
"in force)  or overcommitting memory with the risk that a process is "
"terminated by the out-of-memory (OOM) killer."
msgstr "В системах с малым количеством памяти B<vfork>() при запуске новой программы не выполняет временное выделение памяти (смотрите описание I</proc/sys/vm/overcommit_memory> в B<proc>(5)) (это особенно полезно, если огромный родительский процесс хочет выполнить маленькую вспомогательную программу в дочернем процессе). Вызов B<fork>(2) в этом случае или потребуется выделения количества памяти как у родительского процесса (если включён жёсткий учёт обязательств) или перерасходует память с риском завершения процесса посредством сторожа расходования памяти ядра (OOM)."

#. type: SS
#: man-pages/man2/vfork.2:234
#, no-wrap
msgid "Caveats"
msgstr "Предостережения"

#. type: Plain text
#: man-pages/man2/vfork.2:245
msgid ""
"The child process should take care not to modify the memory in unintended "
"ways, since such changes will be seen by the parent process once the child "
"terminates or executes another program.  In this regard, signal handlers can"
" be especially problematic: if a signal handler that is invoked in the child"
" of B<vfork>()  changes memory, those changes may result in an inconsistent "
"process state from the perspective of the parent process (e.g., memory "
"changes would be visible in the parent, but changes to the state of open "
"file descriptors would not be visible)."
msgstr "Потомок не должен изменять память не ожидаемым образом, так как такие изменения будут видны родительскому процессу после завершения потомка или выполнении другой программы. При таком отношении особенно остро стоит проблема в обработчиках сигналов: если обработчик сигналов, вызванный в потомке (созданном B<vfork>()), изменяет память, то эти изменения могут привести к нарушению целостности состояния процесса с точки зрения родителя (например, изменения памяти были бы видны родителю, а изменения состояния открытых файловых дескрипторов не видны)."

#. type: Plain text
#: man-pages/man2/vfork.2:271
msgid ""
"When B<vfork>()  is called in a multithreaded process, only the calling "
"thread is suspended until the child terminates or executes a new program.  "
"This means that the child is sharing an address space with other running "
"code.  This can be dangerous if another thread in the parent process changes"
" credentials (using B<setuid>(2)  or similar), since there are now two "
"processes with different privilege levels running in the same address space."
"  As an example of the dangers, suppose that a multithreaded program running"
" as root creates a child using B<vfork>().  After the B<vfork>(), a thread "
"in the parent process drops the process to an unprivileged user in order to "
"run some untrusted code (e.g., perhaps via plug-in opened with "
"B<dlopen>(3)).  In this case, attacks are possible where the parent process "
"uses B<mmap>(2)  to map in code that will be executed by the privileged "
"child process."
msgstr "Если B<vfork>() вызывается многонитиевом процессе, то в ожидании завершения процесса или запуска новой программы приостанавливается только вызывающая нить. Это означает, что потомок совместно использует адресное пространство другим выполняющимся кодом. Это может быть опасно, если другая нить в родительском процессе изменяет полномочия (с помощью B<setuid>(2) и подобных), так как теперь есть два процесса с разным уровнем прав, выполняемых в одном адресном пространстве. Как пример представим, что многонитиевая программа, работающая с правами суперпользователя, создаёт потомка с помощью B<vfork>(). После B<vfork>() нить в родительском процессе понижает права процесса до непривилегированных, чтобы выполнить некий недоверенный код (например, модуль, открытый через B<dlopen>(3)). В этом случае появляется уязвимость, если родительский процесс использует B<mmap>(2) для отображения кода, то он будет выполнен в привилегированном дочернем процессе."

#. type: SS
#: man-pages/man2/vfork.2:271
#, no-wrap
msgid "Linux notes"
msgstr "Замечания, касающиеся Linux"

#. type: Plain text
#: man-pages/man2/vfork.2:282
msgid ""
"Fork handlers established using B<pthread_atfork>(3)  are not called when a "
"multithreaded program employing the NPTL threading library calls B<vfork>()."
"  Fork handlers are called in this case in a program using the LinuxThreads "
"threading library.  (See B<pthreads>(7)  for a description of Linux "
"threading libraries.)"
msgstr "Обработчики fork, установленные с помощью B<pthread_atfork>(3), не вызываются когда многонитиевая программа использует вызовы библиотеки нитей NPTL B<vfork>(). Обработчики fork вызываются в этом случае в программе, в которой используется библиотека нитей LinuxThreads. (См. в B<pthreads>(7) описание библиотек нитей Linux.)"

#. type: Plain text
#: man-pages/man2/vfork.2:290
msgid ""
"A call to B<vfork>()  is equivalent to calling B<clone>(2)  with I<flags> "
"specified as:"
msgstr "Вызов B<vfork>() эквивалентен вызову B<clone>(2) со следующим значением I<flags>:"

#. type: Plain text
#: man-pages/man2/vfork.2:292
#, no-wrap
msgid "     CLONE_VM | CLONE_VFORK | SIGCHLD\n"
msgstr "     CLONE_VM | CLONE_VFORK | SIGCHLD\n"

#.  In the release notes for 4.2BSD Sam Leffler wrote: `vfork: Is still
#.  present, but definitely on its way out'.
#. type: Plain text
#: man-pages/man2/vfork.2:310
msgid ""
"The B<vfork>()  system call appeared in 3.0BSD.  In 4.4BSD it was made "
"synonymous to B<fork>(2)  but NetBSD introduced it again; see E<.UR "
"http://www.netbsd.org\\:/Documentation\\:/kernel\\:/vfork.html> E<.UE .> In "
"Linux, it has been equivalent to B<fork>(2)  until 2.2.0-pre6 or so.  Since "
"2.2.0-pre9 (on i386, somewhat later on other architectures) it is an "
"independent system call.  Support was added in glibc 2.0.112."
msgstr "Системный вызов B<vfork>() впервые появился в 30BSD. В 4.4BSD он стал синонимом B<fork>(2), но в NetBSD он был введён снова; смотрите E<.UR http://www.netbsd.org\\:/Documentation\\:/kernel\\:/vfork.html> E<.UE .> В Linux этот системный вызов был эквивалентом B<fork>(2), примерно, до ядра 2.2.0-pre6. Начиная с 2.2.0-pre9 (на i386 и немного позже на других архитектурах), он стал независимым системным вызовом. Его поддержка была добавлена в glibc 2.0.112."

#. type: SH
#: man-pages/man2/vfork.2:310
#, no-wrap
msgid "BUGS"
msgstr "ДЕФЕКТЫ"

#.  As far as I can tell, the following is not true in 2.6.19:
#.  Currently (Linux 2.3.25),
#.  .BR strace (1)
#.  cannot follow
#.  .BR vfork ()
#.  and requires a kernel patch.
#. type: Plain text
#: man-pages/man2/vfork.2:331
msgid ""
"Details of the signal handling are obscure and differ between systems.  The "
"BSD man page states: \"To avoid a possible deadlock situation, processes "
"that are children in the middle of a B<vfork>()  are never sent B<SIGTTOU> "
"or B<SIGTTIN> signals; rather, output or I<ioctl>s are allowed and input "
"attempts result in an end-of-file indication.\""
msgstr "Обработка сигналов ещё более запутана и различается от системы к системе. В справочной странице BSD написано следующее: «Для исключения возможности взаимных блокировок процессы, находящиеся в середине исполнения B<vfork>(), никогда не получат сигналов B<SIGTTOU> или B<SIGTTIN>, хотя вывод или I<ioctl> всегда разрешены, а попытки ввода приводят к ситуации появления конца файла»."

#. type: Plain text
#: man-pages/man2/vfork.2:337
msgid ""
"B<clone>(2), B<execve>(2), B<_exit>(2), B<fork>(2), B<unshare>(2), "
"B<wait>(2)"
msgstr "B<clone>(2), B<execve>(2), B<_exit>(2), B<fork>(2), B<unshare>(2), B<wait>(2)"

#. type: TH
#: man-pages/man2/vm86.2:26
#, no-wrap
msgid "VM86"
msgstr "VM86"

#. type: TH
#: man-pages/man2/vm86.2:26
#, no-wrap
msgid "2009-02-20"
msgstr "2009-02-20"

#. type: Plain text
#: man-pages/man2/vm86.2:29
msgid "vm86old, vm86 - enter virtual 8086 mode"
msgstr "vm86old, vm86 - войти в виртуальный режим 8086  "

#. type: Plain text
#: man-pages/man2/vm86.2:31
msgid "B<#include E<lt>sys/vm86.hE<gt>>"
msgstr "B<#include E<lt>sys/vm86.hE<gt>>"

#. type: Plain text
#: man-pages/man2/vm86.2:33
msgid "B<int vm86old(struct vm86_struct *>I<info>B<);>"
msgstr "B<int vm86old(struct vm86_struct *>I<info>B<);>"

#. type: Plain text
#: man-pages/man2/vm86.2:35
msgid ""
"B<int vm86(unsigned long >I<fn>B<, struct vm86plus_struct *>I<v86>B<);>"
msgstr "B<int vm86(unsigned long >I<fn>B<, struct vm86plus_struct *>I<v86>B<);>"

#. type: Plain text
#: man-pages/man2/vm86.2:48
msgid ""
"The system call B<vm86>()  was introduced in Linux 0.97p2.  In Linux 2.1.15 "
"and 2.0.28, it was renamed to B<vm86old>(), and a new B<vm86>()  was "
"introduced.  The definition of I<struct vm86_struct> was changed in 1.1.8 "
"and 1.1.9."
msgstr "Системный вызов B<vm86>() был введён в Linux 0.97p2. В Linux 2.1.15 и 2.0.28 он был переименован в B<vm86old>() и был введён новый B<vm86>(). Описание структуры I<struct vm86_struct> было изменено в 1.1.8 и 1.1.9."

#. type: Plain text
#: man-pages/man2/vm86.2:52
msgid ""
"These calls cause the process to enter VM86 mode (virtual-8086 in Intel "
"literature), and are used by B<dosemu>."
msgstr "Данные вызовы заставляют вызывающий процесс войти в режим VM86 (виртуальный режим 8086 в литературе по Intel) и используются B<dosemu>."

#. type: Plain text
#: man-pages/man2/vm86.2:54
msgid "VM86 mode is an emulation of real mode within a protected mode task."
msgstr "Режим VM86 \\(em это эмуляция реального режима внутри задачи, которая работает в защищённом режиме."

#. type: TP
#: man-pages/man2/vm86.2:60
#, no-wrap
msgid "B<EFAULT>"
msgstr "B<EFAULT>"

#. type: Plain text
#: man-pages/man2/vm86.2:64
msgid ""
"This return value is specific to i386 and indicates a problem with getting "
"user-space data."
msgstr "Возвращённое значение является есть только для i386 и указывает на проблему получения данных из пространства пользователя."

#. type: TP
#: man-pages/man2/vm86.2:64
#, no-wrap
msgid "B<ENOSYS>"
msgstr "B<ENOSYS>"

#. type: Plain text
#: man-pages/man2/vm86.2:68
msgid ""
"This return value indicates the call is not implemented on the present "
"architecture."
msgstr "Возвращённое значение указывает, что вызов не реализован на данной архитектуре."

#. type: Plain text
#: man-pages/man2/vm86.2:73
msgid ""
"Saved kernel stack exists.  (This is a kernel sanity check; the saved stack "
"should exist only within vm86 mode itself.)"
msgstr "Существует сохранённый стек ядра (это проверка ядра; сохранённый стек должен существовать только внутри самого режима vm86)."

#. type: Plain text
#: man-pages/man2/vm86.2:75
msgid ""
"This call is specific to Linux on 32-bit Intel processors, and should not be"
" used in programs intended to be portable."
msgstr "Данный вызов является специфичным для Linux на 32-битных процессорах Intel и не должен использоваться в программах, которые задумываются как переносимые на другие платформы.  "
