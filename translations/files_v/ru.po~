# Copyright (C) 2014 Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
#
# Translators:
# Dmitriy Ovchinnikov <dmitriyxt5@gmail.com>, 2012.
# Yuri Kozlov <yuray@komyakino.ru>, 2012-2014.
# Yuri Kozlov <yuray@komyakino.ru>, 2014.
msgid ""
msgstr ""
"Project-Id-Version: translation of man-pages\n"
"POT-Creation-Date: 2013-10-12 09:15+0400\n"
"PO-Revision-Date: 2014-08-17 08:45+0400\n"
"Last-Translator: Yuri Kozlov <yuray@komyakino.ru>\n"
"Language-Team: Russian <man-pages-ru-talks@lists.sourceforge.net>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ru\n"
"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n%10<"
"=4 && (n%100<10 || n%100>=20) ? 1 : 2);\n"
"X-Generator: Lokalize 1.5\n"

#. type: TH
#: man-pages/man4/vcs.4:29
#, no-wrap
msgid "VCS"
msgstr "VCS"

#. type: TH
#: man-pages/man4/vcs.4:29
#, no-wrap
msgid "2007-12-17"
msgstr "2007-12-17"

#. type: TH
#: man-pages/man4/vcs.4:29
#, no-wrap
msgid "Linux"
msgstr "Linux"

#. type: TH
#: man-pages/man4/vcs.4:29
#, no-wrap
msgid "Linux Programmer's Manual"
msgstr "Руководство программиста Linux"

#. type: SH
#: man-pages/man4/vcs.4:30
#, no-wrap
msgid "NAME"
msgstr "ИМЯ"

#. type: Plain text
#: man-pages/man4/vcs.4:32
msgid "vcs, vcsa - virtual console memory"
msgstr "vcs, vcsa - память виртуальной консоли"

#. type: SH
#: man-pages/man4/vcs.4:32
#, no-wrap
msgid "DESCRIPTION"
msgstr "ОПИСАНИЕ"

#. type: Plain text
#: man-pages/man4/vcs.4:38
msgid ""
"I</dev/vcs0> is a character device with major number 7 and minor number 0, "
"usually of mode 0644 and owner root.tty.  It refers to the memory of the "
"currently displayed virtual console terminal."
msgstr ""
"I</dev/vcs0> представляет собой символьное устройство со старшим номером 7 и "
"младшим 0, обычно имеет права доступа 0644 и принадлежит root.tty. Устройство "
"указывает на память отображаемого в данный момент виртуального консольного "
"терминала."

#. type: Plain text
#: man-pages/man4/vcs.4:58
msgid ""
"I</dev/vcs[1-63]> are character devices for virtual console terminals, they "
"have major number 7 and minor number 1 to 63, usually mode 0644 and owner "
"root.tty.  I</dev/vcsa[0-63]> are the same, but using I<unsigned short>s (in"
" host byte order) that include attributes, and prefixed with four bytes "
"giving the screen dimensions and cursor position: I<lines>, I<columns>, "
"I<x>, I<y>.  (I<x> = I<y> = 0 at the top left corner of the screen.)"
msgstr ""
"I</dev/vcs[1-63]> представляют собой символьные устройства виртуальных "
"консольных терминалов, имеют старший номер 7 и младшие от 1 до 63, обычно "
"имеют права доступа 0644 и принадлежат root.tty. I</dev/vcsa[0-63]> "
"представляют собой  те же устройства, но имеют атрибуты в виде чисел типа I<"
"unsigned short> (с порядком байт узла) и приставкой из четырех байтов, "
"задающих размеры экрана и положение курсора: I<lines>, I<columns>, I<x>, I<y>"
".  (I<x> = I<y> = 0 означает верхний левый угол экрана.)"

#. type: Plain text
#: man-pages/man4/vcs.4:72
msgid ""
"When a 512-character font is loaded, the 9th bit position can be fetched by "
"applying the B<ioctl>(2)  B<VT_GETHIFONTMASK> operation (available in Linux "
"kernels 2.6.18 and above)  on I</dev/tty[1-63]>; the value is returned in "
"the I<unsigned short> pointed to by the third B<ioctl>(2)  argument."
msgstr ""
"При загрузке шрифта с 512 символами значение 9-го бита можно получить через "
"B<ioctl>(2) с помощью операции B<VT_GETHIFONTMASK> (доступна в ядрах Linux "
"версии 2.6.18 и новее) над I</dev/tty[1-63]>; третий аргумент B<ioctl>(2) "
"содержит указатель на I<unsigned short>, куда возвращается результат."

#. type: Plain text
#: man-pages/man4/vcs.4:79
msgid ""
"These devices replace the screendump B<ioctl>(2)  operations of "
"B<console>(4), so the system administrator can control access using "
"filesystem permissions."
msgstr ""
"Эти устройства заменяют операции B<ioctl>(2) по снятию снимка экрана "
"(console(4)), и позволяют системному администратору контролировать доступ с "
"помощью файловой системы."

#. type: Plain text
#: man-pages/man4/vcs.4:81
msgid "The devices for the first eight virtual consoles may be created by:"
msgstr ""
"Устройства для первых восьми виртуальных консолей могут быть созданы с "
"помощью следующих команд:"

#. type: Plain text
#: man-pages/man4/vcs.4:88
#, no-wrap
msgid ""
"    for x in 0 1 2 3 4 5 6 7 8; do\n"
"        mknod -m 644 /dev/vcs$x c 7 $x;\n"
"        mknod -m 644 /dev/vcsa$x c 7 $[$x+128];\n"
"    done\n"
"    chown root:tty /dev/vcs*\n"
msgstr ""
"    for x in 0 1 2 3 4 5 6 7 8; do\n        mknod -m 644 /dev/vcs$x c 7 $x;\n "
"       mknod -m 644 /dev/vcsa$x c 7 $[$x+128];\n    done\n    chown root:tty "
"/dev/vcs*\n"

#. type: Plain text
#: man-pages/man4/vcs.4:93
msgid "No B<ioctl>(2)  requests are supported."
msgstr "Запросы B<ioctl>(2) не поддерживаются."

#. type: SH
#: man-pages/man4/vcs.4:93
#, no-wrap
msgid "FILES"
msgstr "ФАЙЛЫ"

#. type: Plain text
#: man-pages/man4/vcs.4:95
msgid "/dev/vcs[0-63]"
msgstr "/dev/vcs[0-63]"

#.  .SH AUTHOR
#.  Andries Brouwer <aeb@cwi.nl>
#. type: Plain text
#: man-pages/man4/vcs.4:99
msgid "/dev/vcsa[0-63]"
msgstr "/dev/vcsa[0-63]"

#. type: SH
#: man-pages/man4/vcs.4:99
#, no-wrap
msgid "VERSIONS"
msgstr "ВЕРСИИ"

#. type: Plain text
#: man-pages/man4/vcs.4:101
msgid "Introduced with version 1.1.92 of the Linux kernel."
msgstr "Впервые появились в версии ядра Linux 1.1.92."

#. type: SH
#: man-pages/man4/vcs.4:101
#, no-wrap
msgid "EXAMPLE"
msgstr "ПРИМЕР"

#. type: Plain text
#: man-pages/man4/vcs.4:103
msgid "You may do a screendump on vt3 by switching to vt1 and typing"
msgstr "Вы можете сделать снимок экрана vt3, переключившись на vt1 и написав"

#. type: Plain text
#: man-pages/man4/vcs.4:105
#, no-wrap
msgid "    cat /dev/vcs3 E<gt>foo\n"
msgstr "    cat /dev/vcs3 E<gt>foo\n"

#. type: Plain text
#: man-pages/man4/vcs.4:109
msgid ""
"Note that the output does not contain newline characters, so some processing"
" may be required, like in"
msgstr ""
"Заметим, что вывод не будет содержать символов новой строки, поэтому может "
"потребоваться дополнительная обработка, например"

#. type: Plain text
#: man-pages/man4/vcs.4:111
#, no-wrap
msgid "    old -w 81 /dev/vcs3 | lpr\n"
msgstr "    old -w 81 /dev/vcs3 | lpr\n"

#. type: Plain text
#: man-pages/man4/vcs.4:113
msgid "or (horrors)"
msgstr "или (жуть)"

#. type: Plain text
#: man-pages/man4/vcs.4:115
#, no-wrap
msgid "    xetterm -dump 3 -file /proc/self/fd/1\n"
msgstr "    xetterm -dump 3 -file /proc/self/fd/1\n"

#. type: Plain text
#: man-pages/man4/vcs.4:120
msgid "The I</dev/vcsa0> device is used for Braille support."
msgstr "Устройство I</dev/vcsa0> используется для поддержки дисплея Брайля."

#. type: Plain text
#: man-pages/man4/vcs.4:124
msgid ""
"This program displays the character and screen attributes under the cursor "
"of the second virtual console, then changes the background color there:"
msgstr ""
"Эта программа выводит символ и атрибуты экрана, находящиеся под курсором на "
"второй виртуальной консоли, и затем меняет цвет фона в том же месте."

#. type: Plain text
#: man-pages/man4/vcs.4:132
#, no-wrap
msgid ""
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>fcntl.hE<gt>\n"
"#include E<lt>sys/ioctl.hE<gt>\n"
"#include E<lt>linux/vt.hE<gt>\n"
msgstr ""
"#include E<lt>unistd.hE<gt>\n#include E<lt>stdlib.hE<gt>\n#include E<lt>"
"stdio.hE<gt>\n#include E<lt>fcntl.hE<gt>\n#include E<lt>sys/ioctl.hE<gt>"
"\n#include E<lt>linux/vt.hE<gt>\n"

#. type: Plain text
#: man-pages/man4/vcs.4:143
#, no-wrap
msgid ""
"int\n"
"main(void)\n"
"{\n"
"    int fd;\n"
"    char *device = \"/dev/vcsa2\";\n"
"    char *console = \"/dev/tty2\";\n"
"    struct {unsigned char lines, cols, x, y;} scrn;\n"
"    unsigned short s;\n"
"    unsigned short mask;\n"
"    unsigned char ch, attrib;\n"
msgstr ""
"int\nmain(void)\n{\n    int fd;\n    char *device = \"/dev/vcsa2\";\n    char "
"*console = \"/dev/tty2\";\n    struct {unsigned char lines, cols, x, y;} "
"scrn;\n    unsigned short s;\n    unsigned short mask;\n    unsigned char ch, "
"attrib;\n"

#. type: Plain text
#: man-pages/man4/vcs.4:172
#, no-wrap
msgid ""
"    fd = open(console, O_RDWR);\n"
"    if (fd E<lt> 0) {\n"
"        perror(console);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
"    if (ioctl(fd, VT_GETHIFONTMASK, &mask) E<lt> 0) {\n"
"        perror(\"VT_GETHIFONTMASK\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
"    (void) close(fd);\n"
"    fd = open(device, O_RDWR);\n"
"    if (fd E<lt> 0) {\n"
"        perror(device);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
"    (void) read(fd, &scrn, 4);\n"
"    (void) lseek(fd, 4 + 2*(scrn.y*scrn.cols + scrn.x), 0);\n"
"    (void) read(fd, &s, 2);\n"
"    ch = s & 0xff;\n"
"    if (attrib & mask)\n"
"        ch |= 0x100;\n"
"    attrib = ((s & ~mask) E<gt>E<gt> 8);\n"
"    printf(\"ch=\\(aq%c\\(aq attrib=0x%02x\\en\", ch, attrib);\n"
"    attrib ^= 0x10;\n"
"    (void) lseek(fd, -1, 1);\n"
"    (void) write(fd, &attrib, 1);\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""
"    fd = open(console, O_RDWR);\n    if (fd E<lt> 0) {\n        "
"perror(console);\n        exit(EXIT_FAILURE);\n    }\n    if (ioctl(fd, "
"VT_GETHIFONTMASK, &mask) E<lt> 0) {\n        perror(\"VT_GETHIFONTMASK\");\n  "
"      exit(EXIT_FAILURE);\n    }\n    (void) close(fd);\n    fd = "
"open(device, O_RDWR);\n    if (fd E<lt> 0) {\n        perror(device);\n       "
" exit(EXIT_FAILURE);\n    }\n    (void) read(fd, &scrn, 4);\n    (void) "
"lseek(fd, 4 + 2*(scrn.y*scrn.cols + scrn.x), 0);\n    (void) read(fd, &s, "
"2);\n    ch = s & 0xff;\n    if (attrib & mask)\n        ch |= 0x100;\n    "
"attrib = ((s & ~mask) E<gt>E<gt> 8);\n    printf(\"ch=\\(aq%c\\(aq attrib=0x%"
"02x\\en\", ch, attrib);\n    attrib ^= 0x10;\n    (void) lseek(fd, -1, 1);\n  "
"  (void) write(fd, &attrib, 1);\n    exit(EXIT_SUCCESS);\n}\n"

#. type: SH
#: man-pages/man4/vcs.4:173
#, no-wrap
msgid "SEE ALSO"
msgstr "СМОТРИТЕ ТАКЖЕ"

#. type: Plain text
#: man-pages/man4/vcs.4:177
msgid "B<console>(4), B<tty>(4), B<ttyS>(4), B<gpm>(8)"
msgstr "B<console>(4), B<tty>(4), B<ttyS>(4), B<gpm>(8)"

#. type: TH
#: man-pages/man7/vdso.7:13
#, no-wrap
msgid "VDSO"
msgstr "VDSO"

#. type: TH
#: man-pages/man7/vdso.7:13
#, no-wrap
msgid "2014-02-01"
msgstr "2014-02-01"

#. type: Plain text
#: man-pages/man7/vdso.7:16
msgid "vDSO - overview of the virtual ELF dynamic shared object"
msgstr "vDSO - обзор виртуального динамически компонуемого общего объекта ELF"

#. type: SH
#: man-pages/man7/vdso.7:16
#, no-wrap
msgid "SYNOPSIS"
msgstr "ОБЗОР"

#. type: Plain text
#: man-pages/man7/vdso.7:18
msgid "B<#include E<lt>sys/auxv.hE<gt>>"
msgstr "B<#include E<lt>sys/auxv.hE<gt>>"

#. type: Plain text
#: man-pages/man7/vdso.7:20
msgid "B<void *vdso = (uintptr_t) getauxval(AT_SYSINFO_EHDR);>"
msgstr "B<void *vdso = (uintptr_t) getauxval(AT_SYSINFO_EHDR);>"

#. type: Plain text
#: man-pages/man7/vdso.7:29
msgid ""
"The \"vDSO\" (virtual dynamic shared object) is a small shared library that "
"the kernel automatically maps into the address space of all user-space "
"applications.  Applications usually do not need to concern themselves with "
"these details as the vDSO is most commonly called by the C library.  This "
"way you can code in the normal way using standard functions and the C "
"library will take care of using any functionality that is available via the "
"vDSO."
msgstr ""
"«vDSO» (virtual dynamic shared object, виртуальный динамический общий объект) "
"— это маленькая общая библиотека, которую ядро автоматически отображает в "
"адресное пространство всех приложений пользовательского пространства. Обычно, "
"приложениям она не нужна, так как vDSO, чаще всего, вызывается из библиотеки "
"C. Вы можете использовать стандартные функции как обычно, а библиотека C "
"самостоятельно позаботится об использовании возможностей vDSO."

#. type: Plain text
#: man-pages/man7/vdso.7:37
msgid ""
"Why does the vDSO exist at all? There are some system calls the kernel "
"provides that user-space code ends up using frequently, to the point that "
"such calls can dominate overall performance.  This is due both to the "
"frequency of the call as well as the context-switch overhead that results "
"from exiting user space and entering the kernel."
msgstr ""
"И всё же, зачем нужна vDSO? Есть несколько системных вызовов ядра, которые "
"используются в пользовательском коде настолько часто, что это сильно влияет "
"на общую производительность. Это происходит из-за частого повторения вызовов, "
"а также затрат на переключение контекста, которые возникают при выходе из "
"пользовательского пространства и входа в ядро."

#. type: Plain text
#: man-pages/man7/vdso.7:42
msgid ""
"The rest of this documentation is geared toward the curious and/or C library"
" writers rather than general developers.  If you're trying to call the vDSO "
"in your own application rather than using the C library, you're most likely "
"doing it wrong."
msgstr ""
"Оставшаяся часть этой документации предназначена для любопытных и/или авторов "
"библиотеки C, а не для обычных разработчиков. Если вы попытаетесь вызвать "
"vDSO в своём приложении не через библиотеку C, то, наиболее вероятно, "
"сделаете это неправильно."

#. type: SS
#: man-pages/man7/vdso.7:42
#, no-wrap
msgid "Example background"
msgstr "В качестве примера"

#. type: Plain text
#: man-pages/man7/vdso.7:56
msgid ""
"Making system calls can be slow.  In x86 32-bit systems, you can trigger a "
"software interrupt (I<int $0x80>)  to tell the kernel you wish to make a "
"system call.  However, this instruction is expensive: it goes through the "
"full interrupt-handling paths in the processor's microcode as well as in the"
" kernel.  Newer processors have faster (but backward incompatible) "
"instructions to initiate system calls.  Rather than require the C library to"
" figure out if this functionality is available at run time, the C library "
"can use functions provided by the kernel in the vDSO."
msgstr ""
"Выполнение системных вызовов может быть медленным. В 32-битных системах x86 "
"вы можете использовать программное прерывание (I<int $0x80>), чтобы заставить "
"ядро выполнить системный вызов. Однако, эта инструкция очень затратна: она "
"проходит по полному маршруту обработки прерываний в микрокоде процессора, а "
"также в ядре. Новые процессоры содержат более быстрые инструкции (но обратно "
"совместимые) для запуска системных вызовов. Вместо того, чтобы требовать от "
"библиотеки C выяснения во время выполнения есть ли такая возможность, "
"библиотека C может использовать функции, предоставляемые ядром в vDSO."

#. type: Plain text
#: man-pages/man7/vdso.7:63
msgid ""
"Note that the terminology can be confusing.  On x86 systems, the vDSO "
"function used to determine the preferred method of making a system call is "
"named \"__kernel_vsyscall\", but on x86_64, the term \"vsyscall\" also "
"refers to an obsolete way to ask the kernel what time it is or what CPU the "
"caller is on."
msgstr ""
"Заметим, что можно запутаться в терминологии. В системах x86 функция vDSO, "
"используемая для определения предпочтительного метода выполнения системного "
"вызова, называется «__kernel_vsyscall», но в x86_64 термин «vsyscall» также "
"ссылается на устаревший метод запроса ядра о времени или на каком ЦП "
"выполняется вызывающий."

#. type: Plain text
#: man-pages/man7/vdso.7:79
msgid ""
"One frequently used system call is B<gettimeofday>(2).  This system call is "
"called both directly by user-space applications as well as indirectly by the"
" C library.  Think timestamps or timing loops or polling\\(emall of these "
"frequently need to know what time it is right now.  This information is also"
" not secret\\(emany application in any privilege mode (root or any "
"unprivileged user) will get the same answer.  Thus the kernel arranges for "
"the information required to answer this question to be placed in memory the "
"process can access.  Now a call to B<gettimeofday>(2)  changes from a system"
" call to a normal function call and a few memory accesses."
msgstr ""
"Одним из наиболее часто используемых системных вызовов является B<"
"gettimeofday>(2). Данный вызов используется прямо в приложениях, а также "
"неявно из библиотеки C. Метка времени, временной цикл или опрос — для всего "
"этого часто нужно знать сколько времени в данный момент. Также, это "
"информация не секретна — многие приложения с любыми правами (root или любого "
"не привилегированного пользователя) получат одинаковый ответ. Поэтому ядро "
"размещает информацию, требуемую для ответа на этот вопрос, в памяти процесса. "
"Теперь системный вызов B<gettimeofday>(2) заменяется на вызов обычной функции "
"и доступ к памяти."

#. type: SS
#: man-pages/man7/vdso.7:79
#, no-wrap
msgid "Finding the vDSO"
msgstr "Нахождение vDSO"

#. type: Plain text
#: man-pages/man7/vdso.7:86
msgid ""
"The base address of the vDSO (if one exists) is passed by the kernel to each"
" program in the initial auxiliary vector (see B<getauxval>(3)), via the "
"B<AT_SYSINFO_EHDR> tag."
msgstr ""
"Базовый адрес vDSO (если есть) передаётся ядром каждой программе во "
"вспомогательном векторе инициализации (смотрите B<getauxval>(3)) через тег B<"
"AT_SYSINFO_EHDR>."

#. type: Plain text
#: man-pages/man7/vdso.7:95
msgid ""
"You must not assume the vDSO is mapped at any particular location in the "
"user's memory map.  The base address will usually be randomized at run time "
"every time a new process image is created (at B<execve>(2)  time).  This is "
"done for security reasons, to prevent \"return-to-libc\" attacks."
msgstr ""
"Вы не должны рассчитывать на то, что vDSO отображается в каком-то "
"определённом месте карты пользовательской памяти. Обычно, базовый адрес во "
"время выполнения выбирается произвольным образом каждый раз при создании "
"нового образа процесса (с помощью B<execve>(2)). Это делается в целях "
"безопасности для предотвращения атак «возврат в libc»."

#. type: Plain text
#: man-pages/man7/vdso.7:104
msgid ""
"For some architectures, there is also an B<AT_SYSINFO> tag.  This is used "
"only for locating the vsyscall entry point and is frequently omitted or set "
"to 0 (meaning it's not available).  This tag is a throwback to the initial "
"vDSO work (see I<History> below) and its use should be avoided."
msgstr ""
"Для некоторых архитектур также существует тег B<AT_SYSINFO>. Он используется "
"только для нахождения точки входа vsyscall и часто отсутствует или равен 0 "
"(то есть недоступен). Этот тег — атавизм первых версий vDSO (смотрите I<"
"История> ниже) и не должен использоваться."

#. type: SS
#: man-pages/man7/vdso.7:104
#, no-wrap
msgid "File format"
msgstr "Формат файла"

#. type: Plain text
#: man-pages/man7/vdso.7:111
msgid ""
"Since the vDSO is a fully formed ELF image, you can do symbol lookups on it."
"  This allows new symbols to be added with newer kernel releases, and allows"
" the C library to detect available functionality at run time when running "
"under different kernel versions.  Oftentimes the C library will do detection"
" with the first call and then cache the result for subsequent calls."
msgstr ""
"Так как vDSO — полноценный образ ELF, вы можете искать в нём символы. Это "
"позволяет добавлять новые символы в новых версиях ядра и библиотеке C "
"находить доступные свойства во время выполнения с различными версиями ядер. "
"Зачастую, библиотека C выполняет обнаружение при первом вызове и затем "
"кэширует результат для последующих вызовов."

#. type: Plain text
#: man-pages/man7/vdso.7:120
msgid ""
"All symbols are also versioned (using the GNU version format).  This allows "
"the kernel to update the function signature without breaking backward "
"compatibility.  This means changing the arguments that the function accepts "
"as well as the return value.  Thus, when looking up a symbol in the vDSO, "
"you must always include the version to match the ABI you expect."
msgstr ""
"Все символы имеют версии (в формате версий GNU). Это позволяет ядру обновлять "
"сигнатуру функции без нарушения обратной совместимости. Смена версии означает "
"изменение аргументов функции или возвращаемого значения. Таким образом, при "
"поиске символа в vDSO, вы всегда должны включать версию для нахождения "
"ожидаемого ABI."

#. type: Plain text
#: man-pages/man7/vdso.7:125
msgid ""
"Typically the vDSO follows the naming convention of prefixing all symbols "
"with \"__vdso_\" or \"__kernel_\" so as to distinguish them from other "
"standard symbols.  For example, the \"gettimeofday\" function is named "
"\"__vdso_gettimeofday\"."
msgstr ""
"Обычно, vDSO удовлетворяет соглашению об именовании, начиная все символы с "
"«__vdso_» или «__kernel_», для их выделения среди других стандартных "
"символов. Например, функция «gettimeofday» называется «__vdso_gettimeofday»."

#. type: Plain text
#: man-pages/man7/vdso.7:129
msgid ""
"You use the standard C calling conventions when calling any of these "
"functions.  No need to worry about weird register or stack behavior."
msgstr ""
"Для вызова этих функций используйте стандартные соглашения о вызове языка Си. "
"Учитывать поведение регистров и стека не требуется."

#. type: SH
#: man-pages/man7/vdso.7:129
#, no-wrap
msgid "NOTES"
msgstr "ЗАМЕЧАНИЯ"

#. type: SS
#: man-pages/man7/vdso.7:130
#, no-wrap
msgid "Source"
msgstr "Исходный код"

#. type: Plain text
#: man-pages/man7/vdso.7:134
msgid ""
"When you compile the kernel, it will automatically compile and link the vDSO"
" code for you.  You will frequently find it under the architecture-specific "
"directory:"
msgstr ""
"Код vDSO автоматически компилируется и компонуется при сборке ядра. Обычно, "
"его можно найти в каталоге соответствующей архитектуры:"

#. type: Plain text
#: man-pages/man7/vdso.7:136
#, no-wrap
msgid "    find arch/$ARCH/ -name '*vdso*.so*' -o -name '*gate*.so*'\n"
msgstr "    find arch/$ARCH/ -name '*vdso*.so*' -o -name '*gate*.so*'\n"

#. type: SS
#: man-pages/man7/vdso.7:137
#, no-wrap
msgid "vDSO names"
msgstr "Имена vDSO"

#. type: Plain text
#: man-pages/man7/vdso.7:143
msgid ""
"The name of the vDSO varies across architectures.  It will often show up in "
"things like glibc's B<ldd>(1)  output.  The exact name should not matter to "
"any code, so do not hardcode it."
msgstr ""
"Имя vDSO отличается на разных архитектурах. Часто его можно увидеть в выводе "
"утилит, подобных B<ldd>(1) из glibc. Точное имя не должно влиять на код, "
"поэтому жёстко оно нигде не задаётся."

#. type: Plain text
#: man-pages/man7/vdso.7:146 man-pages/man7/vdso.7:195
#: man-pages/man7/vdso.7:232 man-pages/man7/vdso.7:260
#: man-pages/man7/vdso.7:296 man-pages/man7/vdso.7:330
#: man-pages/man7/vdso.7:356 man-pages/man7/vdso.7:381
#: man-pages/man7/vdso.7:399 man-pages/man7/vdso.7:417
#: man-pages/man7/vdso.7:435 man-pages/man7/vdso.7:455
#: man-pages/man7/vdso.7:474
msgid "CW<\\}>"
msgstr "CW<\\}>"

#. type: tbl table
#: man-pages/man7/vdso.7:148
#, no-wrap
msgid "CW<user ABI\tvDSO name>\n"
msgstr "CW<Пользовательский ABI\tИмя vDSO>\n"

#. type: tbl table
#: man-pages/man7/vdso.7:149 man-pages/man7/vdso.7:198
#: man-pages/man7/vdso.7:235 man-pages/man7/vdso.7:263
#: man-pages/man7/vdso.7:299 man-pages/man7/vdso.7:333
#: man-pages/man7/vdso.7:359 man-pages/man7/vdso.7:384
#: man-pages/man7/vdso.7:402 man-pages/man7/vdso.7:420
#: man-pages/man7/vdso.7:438 man-pages/man7/vdso.7:458
#: man-pages/man7/vdso.7:477
#, no-wrap
msgid "CW<_>\n"
msgstr "CW<_>\n"

#. type: tbl table
#: man-pages/man7/vdso.7:150
#, no-wrap
msgid "CW<aarch64\tlinux-vdso.so.1>\n"
msgstr "CW<aarch64\tlinux-vdso.so.1>\n"

#. type: tbl table
#: man-pages/man7/vdso.7:151
#, no-wrap
msgid "CW<ia64\tlinux-gate.so.1>\n"
msgstr "CW<ia64\tlinux-gate.so.1>\n"

#. type: tbl table
#: man-pages/man7/vdso.7:152
#, no-wrap
msgid "CW<ppc/32\tlinux-vdso32.so.1>\n"
msgstr "CW<ppc/32\tlinux-vdso32.so.1>\n"

#. type: tbl table
#: man-pages/man7/vdso.7:153
#, no-wrap
msgid "CW<ppc/64\tlinux-vdso64.so.1>\n"
msgstr "CW<ppc/64\tlinux-vdso64.so.1>\n"

#. type: tbl table
#: man-pages/man7/vdso.7:154
#, no-wrap
msgid "CW<s390\tlinux-vdso32.so.1>\n"
msgstr "CW<s390\tlinux-vdso32.so.1>\n"

#. type: tbl table
#: man-pages/man7/vdso.7:155
#, no-wrap
msgid "CW<s390x\tlinux-vdso64.so.1>\n"
msgstr "CW<s390x\tlinux-vdso64.so.1>\n"

#. type: tbl table
#: man-pages/man7/vdso.7:156
#, no-wrap
msgid "CW<sh\tlinux-gate.so.1>\n"
msgstr "CW<sh\tlinux-gate.so.1>\n"

#. type: tbl table
#: man-pages/man7/vdso.7:157
#, no-wrap
msgid "CW<i386\tlinux-gate.so.1>\n"
msgstr "CW<i386\tlinux-gate.so.1>\n"

#. type: tbl table
#: man-pages/man7/vdso.7:158
#, no-wrap
msgid "CW<x86_64\tlinux-vdso.so.1>\n"
msgstr "CW<x86_64\tlinux-vdso.so.1>\n"

#. type: tbl table
#: man-pages/man7/vdso.7:159
#, no-wrap
msgid "CW<x86/x32\tlinux-vdso.so.1>\n"
msgstr "CW<x86/x32\tlinux-vdso.so.1>\n"

#. type: Plain text
#: man-pages/man7/vdso.7:165 man-pages/man7/vdso.7:208
#: man-pages/man7/vdso.7:244 man-pages/man7/vdso.7:275
#: man-pages/man7/vdso.7:320 man-pages/man7/vdso.7:375
#: man-pages/man7/vdso.7:393 man-pages/man7/vdso.7:411
#: man-pages/man7/vdso.7:429 man-pages/man7/vdso.7:447
#: man-pages/man7/vdso.7:468 man-pages/man7/vdso.7:487
msgid "\\}"
msgstr "\\}"

#. type: SH
#: man-pages/man7/vdso.7:165
#, no-wrap
msgid "ARCHITECTURE-SPECIFIC NOTES"
msgstr "ЗАМЕЧАНИЯ ДЛЯ РАЗЛИЧНЫХ АРХИТЕКТУР"

#. type: Plain text
#: man-pages/man7/vdso.7:168
msgid "The subsections below provide architecture-specific notes on the vDSO."
msgstr "Далее приведены замечания по vDSO для различных архитектур."

#. type: Plain text
#: man-pages/man7/vdso.7:177
msgid ""
"Note that the vDSO that is used is based on the ABI of your user-space code "
"and not the ABI of the kernel.  Thus, for example, when you run an i386 "
"32-bit ELF binary, you'll get the same vDSO regardless of whether you run it"
" under an i386 32-bit kernel or under an x86_64 64-bit kernel.  Therefore, "
"the name of the user-space ABI should be used to determine which of the "
"sections below is relevant."
msgstr ""
"Заметим, что используемая vDSO основывается на ABI вашего кода "
"пользовательского пространства, а не на ABI ядра. Например, когда вы "
"запускаете 32-битный исполняемый файл ELF на i386, то вы получаете ту же vDSO "
"независимо от того, запускаете ли вы его на 32-битном ядре i386 или на "
"64-битном ядре x86_64. Таким образом, для определения нужного раздела ниже "
"нужно использовать имя ABI пользовательского пространства."

#. type: SS
#: man-pages/man7/vdso.7:177
#, no-wrap
msgid "ARM functions"
msgstr "Функции на ARM"

#.  See linux/arch/arm/kernel/entry-armv.S
#.  See linux/Documentation/arm/kernel_user_helpers.txt
#. type: Plain text
#: man-pages/man7/vdso.7:184
msgid ""
"The ARM port has a code page full of utility functions.  Since it's just a "
"raw page of code, there is no ELF information for doing symbol lookups or "
"versioning.  It does provide support for different versions though."
msgstr ""
"Перенос ARM содержит страницу кода со вспомогательными функциями. Так как это "
"просто страница с кодом, информация ELF отсутствует и поиск функций "
"невозможен и неизвестны их версии. Хотя в коде есть функции нескольких версий."

#. type: Plain text
#: man-pages/man7/vdso.7:189
msgid ""
"For information on this code page, it's best to refer to the kernel "
"documentation as it's extremely detailed and covers everything you need to "
"know: I<Documentation/arm/kernel_user_helpers.txt>."
msgstr ""
"Эта страница с кодом хорошо описана в документации к ядру и в ней есть всё, "
"что вам нужно знать: I<Documentation/arm/kernel_user_helpers.txt>."

#. type: SS
#: man-pages/man7/vdso.7:189
#, no-wrap
msgid "aarch64 functions"
msgstr "Функции на aarch64"

#.  See linux/arch/x86/vdso/vdso32.lds.S
#. type: Plain text
#: man-pages/man7/vdso.7:192 man-pages/man7/vdso.7:229
#: man-pages/man7/vdso.7:353 man-pages/man7/vdso.7:378
#: man-pages/man7/vdso.7:396 man-pages/man7/vdso.7:414
#: man-pages/man7/vdso.7:432 man-pages/man7/vdso.7:471
msgid "The table below lists the symbols exported by the vDSO."
msgstr "В таблице ниже перечислены символы, экспортируемые vDSO."

#. type: tbl table
#: man-pages/man7/vdso.7:197 man-pages/man7/vdso.7:234
#: man-pages/man7/vdso.7:332 man-pages/man7/vdso.7:358
#: man-pages/man7/vdso.7:383 man-pages/man7/vdso.7:401
#: man-pages/man7/vdso.7:419 man-pages/man7/vdso.7:437
#: man-pages/man7/vdso.7:457 man-pages/man7/vdso.7:476
#, no-wrap
msgid "CW<symbol\tversion>\n"
msgstr "CW<Символ\tВерсия>\n"

#. type: tbl table
#: man-pages/man7/vdso.7:199
#, no-wrap
msgid "CW<__kernel_rt_sigreturn\tLINUX_2.6.39>\n"
msgstr "CW<__kernel_rt_sigreturn\tLINUX_2.6.39>\n"

#. type: tbl table
#: man-pages/man7/vdso.7:200
#, no-wrap
msgid "CW<__kernel_gettimeofday\tLINUX_2.6.39>\n"
msgstr "CW<__kernel_gettimeofday\tLINUX_2.6.39>\n"

#. type: tbl table
#: man-pages/man7/vdso.7:201
#, no-wrap
msgid "CW<__kernel_clock_gettime\tLINUX_2.6.39>\n"
msgstr "CW<__kernel_clock_gettime\tLINUX_2.6.39>\n"

#. type: tbl table
#: man-pages/man7/vdso.7:202
#, no-wrap
msgid "CW<__kernel_clock_getres\tLINUX_2.6.39>\n"
msgstr "CW<__kernel_clock_getres\tLINUX_2.6.39>\n"

#. type: SS
#: man-pages/man7/vdso.7:208
#, no-wrap
msgid "bfin (Blackfin) functions"
msgstr "Функции на bfin (Blackfin)"

#.  See linux/arch/blackfin/kernel/fixed_code.S
#.  See http://docs.blackfin.uclinux.org/doku.php?id=linux-kernel:fixed-code
#. type: Plain text
#: man-pages/man7/vdso.7:220
msgid ""
"As this CPU lacks a memory management unit (MMU), it doesn't set up a vDSO "
"in the normal sense.  Instead, it maps at boot time a few raw functions into"
" a fixed location in memory.  User-space applications then call directly "
"into that region.  There is no provision for backward compatibility beyond "
"sniffing raw opcodes, but as this is an embedded CPU, it can get away with "
"things\\(emsome of the object formats it runs aren't even ELF based (they're"
" bFLT/FLAT)."
msgstr ""
"Так как в этом ЦП отсутствует устройство управления памятью (MMU), на данной "
"архитектуре не создаётся vDSO в обычном понимании. Вместо этого, ядро "
"отображает несколько функций в постоянное расположение в памяти. Приложения "
"пользовательского пространства могут вызывать их из этой области напрямую. "
"Здесь отсутствует обратная совместимость кроме как слежение за кодами "
"операций (sniffing raw opcodes), но для таких встраиваемых ЦП это нормально — "
"некоторые форматы объектов, запускаемых на нём, даже не основаны на ELF "
"(например, bFLT/FLAT)."

#. type: Plain text
#: man-pages/man7/vdso.7:223
msgid ""
"For information on this code page, it's best to refer to the public "
"documentation:"
msgstr "Эта страница с кодом хорошо описана в открытой документации:"

#. type: Plain text
#: man-pages/man7/vdso.7:225
msgid "http://docs.blackfin.uclinux.org/doku.php?id=linux-kernel:fixed-code"
msgstr "http://docs.blackfin.uclinux.org/doku.php?id=linux-kernel:fixed-code"

#. type: SS
#: man-pages/man7/vdso.7:225
#, no-wrap
msgid "ia64 (Itanium) functions"
msgstr "Функции на ia64 (Itanium)"

#. type: tbl table
#: man-pages/man7/vdso.7:236
#, no-wrap
msgid "CW<__kernel_sigtramp\tLINUX_2.5>\n"
msgstr "CW<__kernel_sigtramp\tLINUX_2.5>\n"

#. type: tbl table
#: man-pages/man7/vdso.7:237
#, no-wrap
msgid "CW<__kernel_syscall_via_break\tLINUX_2.5>\n"
msgstr "CW<__kernel_syscall_via_break\tLINUX_2.5>\n"

#. type: tbl table
#: man-pages/man7/vdso.7:238
#, no-wrap
msgid "CW<__kernel_syscall_via_epc\tLINUX_2.5>\n"
msgstr "CW<__kernel_syscall_via_epc\tLINUX_2.5>\n"

#. type: Plain text
#: man-pages/man7/vdso.7:257
msgid ""
"The Itanium port is somewhat tricky.  In addition to the vDSO above, it also"
" has \"light-weight system calls\" (also known as \"fast syscalls\" or "
"\"fsys\").  You can invoke these via the I<__kernel_syscall_via_epc> vDSO "
"helper.  The system calls listed here have the same semantics as if you "
"called them directly via B<syscall>(2), so refer to the relevant "
"documentation for each.  The table below lists the functions available via "
"this mechanism."
msgstr ""
"Перенос на Itanium, в некоторой степени, неоднозначный. Кроме vDSO, "
"показанной выше, также есть «легковесные системные вызовы» (также называемые "
"как «быстрые syscall» или «fsys»). Вы можете вызвать их через вспомогательную "
"функцию vDSO I<__kernel_syscall_via_epc>. Перечисленные здесь системные "
"вызовы имеют ту же семантику, как если бы вызывались напрямую через B<syscall>"
"(2), поэтому обратитесь к соответствующей документации по каждому из них. В "
"таблице ниже перечислены функции, доступные через этот механизм."

#. type: tbl table
#: man-pages/man7/vdso.7:262
#, no-wrap
msgid "CW<function>\n"
msgstr "CW<Функция>\n"

#. type: tbl table
#: man-pages/man7/vdso.7:264
#, no-wrap
msgid "CW<clock_gettime>\n"
msgstr "CW<clock_gettime>\n"

#. type: tbl table
#: man-pages/man7/vdso.7:265
#, no-wrap
msgid "CW<getcpu>\n"
msgstr "CW<getcpu>\n"

#. type: tbl table
#: man-pages/man7/vdso.7:266
#, no-wrap
msgid "CW<getpid>\n"
msgstr "CW<getpid>\n"

#. type: tbl table
#: man-pages/man7/vdso.7:267
#, no-wrap
msgid "CW<getppid>\n"
msgstr "CW<getppid>\n"

#. type: tbl table
#: man-pages/man7/vdso.7:268
#, no-wrap
msgid "CW<gettimeofday>\n"
msgstr "CW<gettimeofday>\n"

#. type: tbl table
#: man-pages/man7/vdso.7:269
#, no-wrap
msgid "CW<set_tid_address>\n"
msgstr "CW<set_tid_address>\n"

#. type: SS
#: man-pages/man7/vdso.7:275
#, no-wrap
msgid "parisc (hppa) functions"
msgstr "Функции на parisc (hppa)"

#.  See linux/arch/parisc/kernel/syscall.S
#.  See linux/Documentation/parisc/registers
#. type: Plain text
#: man-pages/man7/vdso.7:286
msgid ""
"The parisc port has a code page full of utility functions called a gateway "
"page.  Rather than use the normal ELF auxiliary vector approach, it passes "
"the address of the page to the process via the SR2 register.  The "
"permissions on the page are such that merely executing those addresses "
"automatically executes with kernel privileges and not in user space.  This "
"is done to match the way HP-UX works."
msgstr ""
"Перенос parisc содержит страницу кода со вспомогательными функциями, "
"называемую шлюзовой (gateway) страницей. Вместо того, чтобы использовать "
"обычный вспомогательный вектор ELF, передаётся адрес страницы для обработки "
"через регистр SR2. Права на страницу таковы, что простое выполнение этих "
"адресов автоматически выполняется с правами ядра и не в пространстве "
"пользователя. Подобный способ применяется в HP-UX."

#. type: Plain text
#: man-pages/man7/vdso.7:291
msgid ""
"Since it's just a raw page of code, there is no ELF information for doing "
"symbol lookups or versioning.  Simply call into the appropriate offset via "
"the branch instruction, for example:"
msgstr ""
"Так как это просто страница с кодом, информация ELF отсутствует и поиск "
"функций невозможен и неизвестны их версии. Просто вызывайте функцию по "
"соответствующему смещению через инструкцию ветвления, например:"

#. type: Plain text
#: man-pages/man7/vdso.7:293
#, no-wrap
msgid "    ble E<lt>offsetE<gt>(%sr2, %r0)\n"
msgstr "    ble E<lt>смещениеE<gt>(%sr2, %r0)\n"

#. type: tbl table
#: man-pages/man7/vdso.7:298
#, no-wrap
msgid "CW<offset\tfunction>\n"
msgstr "CW<Смещение\tФункция>\n"

#. type: tbl table
#: man-pages/man7/vdso.7:300
#, no-wrap
msgid "CW<00b0\tlws_entry>\n"
msgstr "CW<00b0\tlws_entry>\n"

#. type: tbl table
#: man-pages/man7/vdso.7:301
#, no-wrap
msgid "CW<00e0\tset_thread_pointer>\n"
msgstr "CW<00e0\tset_thread_pointer>\n"

#. type: tbl table
#: man-pages/man7/vdso.7:302
#, no-wrap
msgid "CW<0100\tlinux_gateway_entry (syscall)>\n"
msgstr "CW<0100\tlinux_gateway_entry (syscall)>\n"

#. type: tbl table
#: man-pages/man7/vdso.7:303
#, no-wrap
msgid "CW<0268\tsyscall_nosys>\n"
msgstr "CW<0268\tsyscall_nosys>\n"

#. type: tbl table
#: man-pages/man7/vdso.7:304
#, no-wrap
msgid "CW<0274\ttracesys>\n"
msgstr "CW<0274\ttracesys>\n"

#. type: tbl table
#: man-pages/man7/vdso.7:305
#, no-wrap
msgid "CW<0324\ttracesys_next>\n"
msgstr "CW<0324\ttracesys_next>\n"

#. type: tbl table
#: man-pages/man7/vdso.7:306
#, no-wrap
msgid "CW<0368\ttracesys_exit>\n"
msgstr "CW<0368\ttracesys_exit>\n"

#. type: tbl table
#: man-pages/man7/vdso.7:307
#, no-wrap
msgid "CW<03a0\ttracesys_sigexit>\n"
msgstr "CW<03a0\ttracesys_sigexit>\n"

#. type: tbl table
#: man-pages/man7/vdso.7:308
#, no-wrap
msgid "CW<03b8\tlws_start>\n"
msgstr "CW<03b8\tlws_start>\n"

#. type: tbl table
#: man-pages/man7/vdso.7:309
#, no-wrap
msgid "CW<03dc\tlws_exit_nosys>\n"
msgstr "CW<03dc\tlws_exit_nosys>\n"

#. type: tbl table
#: man-pages/man7/vdso.7:310
#, no-wrap
msgid "CW<03e0\tlws_exit>\n"
msgstr "CW<03e0\tlws_exit>\n"

#. type: tbl table
#: man-pages/man7/vdso.7:311
#, no-wrap
msgid "CW<03e4\tlws_compare_and_swap64>\n"
msgstr "CW<03e4\tlws_compare_and_swap64>\n"

#. type: tbl table
#: man-pages/man7/vdso.7:312
#, no-wrap
msgid "CW<03e8\tlws_compare_and_swap>\n"
msgstr "CW<03e8\tlws_compare_and_swap>\n"

#. type: tbl table
#: man-pages/man7/vdso.7:313
#, no-wrap
msgid "CW<0404\tcas_wouldblock>\n"
msgstr "CW<0404\tcas_wouldblock>\n"

#. type: tbl table
#: man-pages/man7/vdso.7:314
#, no-wrap
msgid "CW<0410\tcas_action>\n"
msgstr "CW<0410\tcas_action>\n"

#. type: SS
#: man-pages/man7/vdso.7:320
#, no-wrap
msgid "ppc/32 functions"
msgstr "Функции на ppc/32"

#.  See linux/arch/powerpc/kernel/vdso32/vdso32.lds.S
#. type: Plain text
#: man-pages/man7/vdso.7:327
msgid ""
"The table below lists the symbols exported by the vDSO.  The functions "
"marked with a I<*> are available only when the kernel is a PowerPC64 "
"(64-bit) kernel."
msgstr ""
"В таблице ниже перечислены символы, экспортируемые vDSO. Функции, помеченные "
"I<*>, доступны только в ядре PowerPC64 (64-бита)."

#. type: tbl table
#: man-pages/man7/vdso.7:334 man-pages/man7/vdso.7:360
#, no-wrap
msgid "CW<__kernel_clock_getres\tLINUX_2.6.15>\n"
msgstr "CW<__kernel_clock_getres\tLINUX_2.6.15>\n"

#. type: tbl table
#: man-pages/man7/vdso.7:335 man-pages/man7/vdso.7:361
#, no-wrap
msgid "CW<__kernel_clock_gettime\tLINUX_2.6.15>\n"
msgstr "CW<__kernel_clock_gettime\tLINUX_2.6.15>\n"

#. type: tbl table
#: man-pages/man7/vdso.7:336 man-pages/man7/vdso.7:362
#, no-wrap
msgid "CW<__kernel_datapage_offset\tLINUX_2.6.15>\n"
msgstr "CW<__kernel_datapage_offset\tLINUX_2.6.15>\n"

#. type: tbl table
#: man-pages/man7/vdso.7:337 man-pages/man7/vdso.7:363
#, no-wrap
msgid "CW<__kernel_get_syscall_map\tLINUX_2.6.15>\n"
msgstr "CW<__kernel_get_syscall_map\tLINUX_2.6.15>\n"

#. type: tbl table
#: man-pages/man7/vdso.7:338 man-pages/man7/vdso.7:364
#, no-wrap
msgid "CW<__kernel_get_tbfreq\tLINUX_2.6.15>\n"
msgstr "CW<__kernel_get_tbfreq\tLINUX_2.6.15>\n"

#. type: tbl table
#: man-pages/man7/vdso.7:339
#, no-wrap
msgid "CW<__kernel_getcpu >I<*>\tLINUX_2.6.15\n"
msgstr "CW<__kernel_getcpu >I<*>\tLINUX_2.6.15\n"

#. type: tbl table
#: man-pages/man7/vdso.7:340
#, no-wrap
msgid "__kernel_gettimeofday\tLINUX_2.6.15\n"
msgstr "__kernel_gettimeofday\tLINUX_2.6.15\n"

#. type: tbl table
#: man-pages/man7/vdso.7:341
#, no-wrap
msgid "__kernel_sigtramp_rt32\tLINUX_2.6.15\n"
msgstr "__kernel_sigtramp_rt32\tLINUX_2.6.15\n"

#. type: tbl table
#: man-pages/man7/vdso.7:342
#, no-wrap
msgid "__kernel_sigtramp32\tLINUX_2.6.15\n"
msgstr "__kernel_sigtramp32\tLINUX_2.6.15\n"

#. type: tbl table
#: man-pages/man7/vdso.7:343
#, no-wrap
msgid "__kernel_sync_dicache\tLINUX_2.6.15\n"
msgstr "__kernel_sync_dicache\tLINUX_2.6.15\n"

#. type: tbl table
#: man-pages/man7/vdso.7:344
#, no-wrap
msgid "__kernel_sync_dicache_p5\tLINUX_2.6.15\n"
msgstr "__kernel_sync_dicache_p5\tLINUX_2.6.15\n"

#. type: Plain text
#: man-pages/man7/vdso.7:350
msgid "I<\\}>"
msgstr "I<\\}>"

#. type: SS
#: man-pages/man7/vdso.7:350
#, no-wrap
msgid "ppc/64 functions"
msgstr "Функции на ppc/64"

#. type: tbl table
#: man-pages/man7/vdso.7:365
#, no-wrap
msgid "CW<__kernel_getcpu\tLINUX_2.6.15>\n"
msgstr "CW<__kernel_getcpu\tLINUX_2.6.15>\n"

#. type: tbl table
#: man-pages/man7/vdso.7:366
#, no-wrap
msgid "CW<__kernel_gettimeofday\tLINUX_2.6.15>\n"
msgstr "CW<__kernel_gettimeofday\tLINUX_2.6.15>\n"

#. type: tbl table
#: man-pages/man7/vdso.7:367
#, no-wrap
msgid "CW<__kernel_sigtramp_rt64\tLINUX_2.6.15>\n"
msgstr "CW<__kernel_sigtramp_rt64\tLINUX_2.6.15>\n"

#. type: tbl table
#: man-pages/man7/vdso.7:368
#, no-wrap
msgid "CW<__kernel_sync_dicache\tLINUX_2.6.15>\n"
msgstr "CW<__kernel_sync_dicache\tLINUX_2.6.15>\n"

#. type: tbl table
#: man-pages/man7/vdso.7:369
#, no-wrap
msgid "CW<__kernel_sync_dicache_p5\tLINUX_2.6.15>\n"
msgstr "CW<__kernel_sync_dicache_p5\tLINUX_2.6.15>\n"

#. type: SS
#: man-pages/man7/vdso.7:375
#, no-wrap
msgid "s390 functions"
msgstr "Функции на s390"

#. type: tbl table
#: man-pages/man7/vdso.7:385 man-pages/man7/vdso.7:403
#, no-wrap
msgid "CW<__kernel_clock_getres\tLINUX_2.6.29>\n"
msgstr "CW<__kernel_clock_getres\tLINUX_2.6.29>\n"

#. type: tbl table
#: man-pages/man7/vdso.7:386 man-pages/man7/vdso.7:404
#, no-wrap
msgid "CW<__kernel_clock_gettime\tLINUX_2.6.29>\n"
msgstr "CW<__kernel_clock_gettime\tLINUX_2.6.29>\n"

#. type: tbl table
#: man-pages/man7/vdso.7:387 man-pages/man7/vdso.7:405
#, no-wrap
msgid "CW<__kernel_gettimeofday\tLINUX_2.6.29>\n"
msgstr "CW<__kernel_gettimeofday\tLINUX_2.6.29>\n"

#. type: SS
#: man-pages/man7/vdso.7:393
#, no-wrap
msgid "s390x functions"
msgstr "Функции на s390x"

#. type: SS
#: man-pages/man7/vdso.7:411
#, no-wrap
msgid "sh (SuperH) functions"
msgstr "Функции на sh (SuperH)"

#. type: tbl table
#: man-pages/man7/vdso.7:421
#, no-wrap
msgid "CW<__kernel_rt_sigreturn\tLINUX_2.6>\n"
msgstr "CW<__kernel_rt_sigreturn\tLINUX_2.6>\n"

#. type: tbl table
#: man-pages/man7/vdso.7:422
#, no-wrap
msgid "CW<__kernel_sigreturn\tLINUX_2.6>\n"
msgstr "CW<__kernel_sigreturn\tLINUX_2.6>\n"

#. type: tbl table
#: man-pages/man7/vdso.7:423
#, no-wrap
msgid "CW<__kernel_vsyscall\tLINUX_2.6>\n"
msgstr "CW<__kernel_vsyscall\tLINUX_2.6>\n"

#. type: SS
#: man-pages/man7/vdso.7:429
#, no-wrap
msgid "i386 functions"
msgstr "Функции на i386"

#. type: tbl table
#: man-pages/man7/vdso.7:439
#, no-wrap
msgid "CW<__kernel_sigreturn\tLINUX_2.5>\n"
msgstr "CW<__kernel_sigreturn\tLINUX_2.5>\n"

#. type: tbl table
#: man-pages/man7/vdso.7:440
#, no-wrap
msgid "CW<__kernel_rt_sigreturn\tLINUX_2.5>\n"
msgstr "CW<__kernel_rt_sigreturn\tLINUX_2.5>\n"

#. type: tbl table
#: man-pages/man7/vdso.7:441
#, no-wrap
msgid "CW<__kernel_vsyscall\tLINUX_2.5>\n"
msgstr "CW<__kernel_vsyscall\tLINUX_2.5>\n"

#. type: SS
#: man-pages/man7/vdso.7:447
#, no-wrap
msgid "x86_64 functions"
msgstr "Функции на x86_64"

#.  See linux/arch/x86/vdso/vdso.lds.S
#. type: Plain text
#: man-pages/man7/vdso.7:452
msgid ""
"The table below lists the symbols exported by the vDSO.  All of these "
"symbols are also available without the \"__vdso_\" prefix, but you should "
"ignore those and stick to the names below."
msgstr ""
"В таблице ниже перечислены символы, экспортируемые vDSO. Все эти символы "
"также доступны без префикса «__vdso_», но вы не должны пользоваться этим, "
"применяйте имена, перечисленные ниже."

#. type: tbl table
#: man-pages/man7/vdso.7:459 man-pages/man7/vdso.7:478
#, no-wrap
msgid "CW<__vdso_clock_gettime\tLINUX_2.6>\n"
msgstr "CW<__vdso_clock_gettime\tLINUX_2.6>\n"

#. type: tbl table
#: man-pages/man7/vdso.7:460 man-pages/man7/vdso.7:479
#, no-wrap
msgid "CW<__vdso_getcpu\tLINUX_2.6>\n"
msgstr "CW<__vdso_getcpu\tLINUX_2.6>\n"

#. type: tbl table
#: man-pages/man7/vdso.7:461 man-pages/man7/vdso.7:480
#, no-wrap
msgid "CW<__vdso_gettimeofday\tLINUX_2.6>\n"
msgstr "CW<__vdso_gettimeofday\tLINUX_2.6>\n"

#. type: tbl table
#: man-pages/man7/vdso.7:462 man-pages/man7/vdso.7:481
#, no-wrap
msgid "CW<__vdso_time\tLINUX_2.6>\n"
msgstr "CW<__vdso_time\tLINUX_2.6>\n"

#. type: SS
#: man-pages/man7/vdso.7:468
#, no-wrap
msgid "x86/x32 functions"
msgstr "Функции на x86/x32"

#. type: SS
#: man-pages/man7/vdso.7:487
#, no-wrap
msgid "History"
msgstr "История"

#. type: Plain text
#: man-pages/man7/vdso.7:494
msgid ""
"The vDSO was originally just a single function\\(emthe vsyscall.  In older "
"kernels, you might see that name in a process's memory map rather than "
"\"vdso\".  Over time, people realized that this mechanism was a great way to"
" pass more functionality to user space, so it was reconceived as a vDSO in "
"the current format."
msgstr ""
"Первоначально vDSO представляла собой одну функцию — vsyscall. В старых ядрах "
"вы можете видеть это имя в карте памяти процесса вместо «vdso». Со временем, "
"люди поняли, что этот механизм является отличным способом перенести больше "
"возможностей в пользовательское пространство, результатом чего стала vDSO в "
"текущем виде."

#. type: Plain text
#: man-pages/man7/vdso.7:498
msgid "B<syscalls>(2), B<getauxval>(3), B<proc>(5)"
msgstr "B<syscalls>(2), B<getauxval>(3), B<proc>(5)"

#. type: Plain text
#: man-pages/man7/vdso.7:500
msgid "The documents, examples, and source code in the Linux source code tree:"
msgstr "Документация, примеры и исходный код в дереве исходного кода Linux:"

#. type: Plain text
#: man-pages/man7/vdso.7:506
#, no-wrap
msgid ""
"Documentation/ABI/stable/vdso\n"
"Documentation/ia64/fsys.txt\n"
"Documentation/vDSO/* (includes examples of using the vDSO)\n"
msgstr ""
"Documentation/ABI/stable/vdso\nDocumentation/ia64/fsys.txt\nDocumentation/vDSO"
"/* (содержит примеры использования vDSO)\n"

#. type: Plain text
#: man-pages/man7/vdso.7:508
#, no-wrap
msgid "find arch/ -iname '*vdso*' -o -iname '*gate*'\n"
msgstr "find arch/ -iname '*vdso*' -o -iname '*gate*'\n"

#. type: TH
#: man-pages/man2/vmsplice.2:26
#, no-wrap
msgid "VMSPLICE"
msgstr "VMSPLICE"

#. type: TH
#: man-pages/man2/vmsplice.2:26
#, no-wrap
msgid "2014-07-08"
msgstr "2014-07-08"

#. type: Plain text
#: man-pages/man2/vmsplice.2:29
msgid "vmsplice - splice user pages into a pipe"
msgstr "vmsplice - соединяет пользовательские страницы памяти с каналом"

#. type: Plain text
#: man-pages/man2/vmsplice.2:34
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>         /* See feature_test_macros(7) */\n"
"B<#include E<lt>fcntl.hE<gt>>\n"
"B<#include E<lt>sys/uio.hE<gt>>\n"
msgstr ""
"B<#define _GNU_SOURCE>         /* см. feature_test_macros(7) */\nB<#include "
"E<lt>fcntl.hE<gt>>\nB<#include E<lt>sys/uio.hE<gt>>\n"

#. type: Plain text
#: man-pages/man2/vmsplice.2:37
#, no-wrap
msgid ""
"B<ssize_t vmsplice(int >I<fd>B<, const struct iovec *>I<iov>B<,>\n"
"B<                 unsigned long >I<nr_segs>B<, unsigned int >I<flags>B<);>\n"
msgstr ""
"B<ssize_t vmsplice(int >I<fd>B<, const struct iovec *>I<iov>B<,>\nB<          "
"       unsigned long >I<nr_segs>B<, unsigned int >I<flags>B<);>\n"

#.  Linus: vmsplice() system call to basically do a "write to
#.  the buffer", but using the reference counting and VM traversal
#.  to actually fill the buffer. This means that the user needs to
#.  be careful not to reuse the user-space buffer it spliced into
#.  the kernel-space one (contrast this to "write()", which copies
#.  the actual data, and you can thus reuse the buffer immediately
#.  after a successful write), but that is often easy to do.
#. type: Plain text
#: man-pages/man2/vmsplice.2:57
msgid ""
"The B<vmsplice>()  system call maps I<nr_segs> ranges of user memory "
"described by I<iov> into a pipe.  The file descriptor I<fd> must refer to a "
"pipe."
msgstr ""
"Системный вызов B<vmsplice>() отображает I<nr_segs> областей  "
"пользовательской памяти, описанных I<iov>, в канал. Файловый дескриптор I<fd> "
"должен указывать на канал."

#. type: Plain text
#: man-pages/man2/vmsplice.2:64
msgid ""
"The pointer I<iov> points to an array of I<iovec> structures as defined in "
"I<E<lt>sys/uio.hE<gt>>:"
msgstr ""
"Указатель I<iov> указывает на массив структур I<iovec>, определённых в I<E<lt>"
"sys/uio.hE<gt>>:"

#. type: Plain text
#: man-pages/man2/vmsplice.2:71
#, no-wrap
msgid ""
"struct iovec {\n"
"    void  *iov_base;            /* Starting address */\n"
"    size_t iov_len;             /* Number of bytes */\n"
"};\n"
msgstr ""
"struct iovec {\n    void  *iov_base;            /* начальный адрес */\n    "
"size_t iov_len;             /* количество байт */\n};\n"

#. type: Plain text
#: man-pages/man2/vmsplice.2:78
msgid ""
"The I<flags> argument is a bit mask that is composed by ORing together zero "
"or more of the following values:"
msgstr ""
"Аргумент I<flags> представляет собой битовую маску, которая составляется "
"логическим сложением (OR) следующих значений:"

#. type: TP
#: man-pages/man2/vmsplice.2:78
#, no-wrap
msgid "B<SPLICE_F_MOVE>"
msgstr "B<SPLICE_F_MOVE>"

#. type: Plain text
#: man-pages/man2/vmsplice.2:84
msgid "Unused for B<vmsplice>(); see B<splice>(2)."
msgstr "Не используется в B<vmsplice>(); см. B<splice>(2)."

#. type: TP
#: man-pages/man2/vmsplice.2:84
#, no-wrap
msgid "B<SPLICE_F_NONBLOCK>"
msgstr "B<SPLICE_F_NONBLOCK>"

#.  Not used for vmsplice
#.  May be in the future -- therefore EAGAIN
#. type: Plain text
#: man-pages/man2/vmsplice.2:91
msgid "Do not block on I/O; see B<splice>(2)  for further details."
msgstr "Не блокировать ввод-вывод; подробности в B<splice>(2)."

#. type: TP
#: man-pages/man2/vmsplice.2:91
#, no-wrap
msgid "B<SPLICE_F_MORE>"
msgstr "B<SPLICE_F_MORE>"

#. type: Plain text
#: man-pages/man2/vmsplice.2:97
msgid ""
"Currently has no effect for B<vmsplice>(), but may be implemented in the "
"future; see B<splice>(2)."
msgstr ""
"В данный момент никак не влияет при указании в B<vmsplice>(), но это может "
"измениться; см. B<splice>(2)."

#. type: TP
#: man-pages/man2/vmsplice.2:97
#, no-wrap
msgid "B<SPLICE_F_GIFT>"
msgstr "B<SPLICE_F_GIFT>"

#.  FIXME Explain the following line in a little more detail:
#.  .... if we expect to later SPLICE_F_MOVE to the cache.
#. type: Plain text
#: man-pages/man2/vmsplice.2:113
msgid ""
"The user pages are a gift to the kernel.  The application may not modify "
"this memory ever, or page cache and on-disk data may differ.  Gifting pages "
"to the kernel means that a subsequent B<splice>(2)  B<SPLICE_F_MOVE> can "
"successfully move the pages; if this flag is not specified, then a "
"subsequent B<splice>(2)  B<SPLICE_F_MOVE> must copy the pages.  Data must "
"also be properly page aligned, both in memory and length."
msgstr ""
"Предоставить ядру пользовательские страницы. Приложение, возможно, не "
"изменяло эту память, иначе страничный кэш и данные на диске будут различны. "
"Передача страниц ядру означает, что последующий вызов B<splice>(2) с флагом "
"B<SPLICE_F_MOVE> сможет переместить страницы; если этот флаг не указан, то "
"последующий B<splice>(2) с флагом B<SPLICE_F_MOVE> должен скопировать "
"страницы. Также, данные должны быть выровнены по странице: по адресам памяти "
"и размеру."

#. type: SH
#: man-pages/man2/vmsplice.2:113
#, no-wrap
msgid "RETURN VALUE"
msgstr "ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ"

#. type: Plain text
#: man-pages/man2/vmsplice.2:122
msgid ""
"Upon successful completion, B<vmsplice>()  returns the number of bytes "
"transferred to the pipe.  On error, B<vmsplice>()  returns -1 and I<errno> "
"is set to indicate the error."
msgstr ""
"При успешном выполнении B<vmsplice>() возвращается количество байт, "
"переданных в канал. При ошибке B<vmsplice>() возвращает -1, а I<errno> "
"устанавливается в соответствующее значение."

#. type: SH
#: man-pages/man2/vmsplice.2:122
#, no-wrap
msgid "ERRORS"
msgstr "ОШИБКИ"

#. type: TP
#: man-pages/man2/vmsplice.2:123
#, no-wrap
msgid "B<EAGAIN>"
msgstr "B<EAGAIN>"

#. type: Plain text
#: man-pages/man2/vmsplice.2:129
msgid ""
"B<SPLICE_F_NONBLOCK> was specified in I<flags>, and the operation would "
"block."
msgstr ""
"В указан I<flags> B<SPLICE_F_NONBLOCK>, и операция вызвала бы блокировку."

#. type: TP
#: man-pages/man2/vmsplice.2:129
#, no-wrap
msgid "B<EBADF>"
msgstr "B<EBADF>"

#. type: Plain text
#: man-pages/man2/vmsplice.2:133
msgid "I<fd> either not valid, or doesn't refer to a pipe."
msgstr "Неправильное значение I<fd> или оно не указывает на канал."

#. type: TP
#: man-pages/man2/vmsplice.2:133
#, no-wrap
msgid "B<EINVAL>"
msgstr "B<EINVAL>"

#. type: Plain text
#: man-pages/man2/vmsplice.2:141
msgid ""
"I<nr_segs> is 0 or greater than B<IOV_MAX>; or memory not aligned if "
"B<SPLICE_F_GIFT> set."
msgstr ""
"Значение I<nr_segs> равно 0 или больше чем B<IOV_MAX>; или, если задан B<"
"SPLICE_F_GIFT>, не выровнена память."

#. type: TP
#: man-pages/man2/vmsplice.2:141
#, no-wrap
msgid "B<ENOMEM>"
msgstr "B<ENOMEM>"

#. type: Plain text
#: man-pages/man2/vmsplice.2:144
msgid "Out of memory."
msgstr "Не хватает памяти."

#. type: Plain text
#: man-pages/man2/vmsplice.2:149
msgid ""
"The B<vmsplice>()  system call first appeared in Linux 2.6.17; library "
"support was added to glibc in version 2.5."
msgstr ""
"Системный вызов B<vmsplice>() впервые появился в Linux 2.6.17; поддержка в "
"glibc добавлена в версии 2.5."

#. type: SH
#: man-pages/man2/vmsplice.2:149
#, no-wrap
msgid "CONFORMING TO"
msgstr "СООТВЕТСТВИЕ СТАНДАРТАМ"

#. type: Plain text
#: man-pages/man2/vmsplice.2:151
msgid "This system call is Linux-specific."
msgstr "Данный вызов есть только в Linux."

#. type: Plain text
#: man-pages/man2/vmsplice.2:160
msgid ""
"B<vmsplice>()  follows the other vectorized read/write type functions when "
"it comes to limitations on number of segments being passed in.  This limit "
"is B<IOV_MAX> as defined in I<E<lt>limits.hE<gt>>.  At the time of this "
"writing, that limit is 1024."
msgstr ""
"Вызов B<vmsplice>() следует другим функциям векторизованного чтения/записи "
"при возникновении ограничений на количество передаваемых сегментов. Это "
"ограничение равно B<IOV_MAX>, определяемое в I<E<lt>limits.hE<gt>>. На момент "
"написания страницы его значение равнялось 1024."

#. type: Plain text
#: man-pages/man2/vmsplice.2:162
msgid "B<splice>(2), B<tee>(2)"
msgstr "B<splice>(2), B<tee>(2)"

#. type: TH
#: man-pages/man2/vhangup.2:28
#, no-wrap
msgid "VHANGUP"
msgstr "VHANGUP"

#. type: TH
#: man-pages/man2/vhangup.2:28
#, no-wrap
msgid "2007-07-26"
msgstr "2007-07-26"

#. type: Plain text
#: man-pages/man2/vhangup.2:31
msgid "vhangup - virtually hangup the current terminal"
msgstr "vhangup - имитирует прекращение работы текущего терминала"

#. type: Plain text
#: man-pages/man2/vhangup.2:33
msgid "B<#include E<lt>unistd.hE<gt>>"
msgstr "B<#include E<lt>unistd.hE<gt>>"

#. type: Plain text
#: man-pages/man2/vhangup.2:35
msgid "B<int vhangup(void);>"
msgstr "B<int vhangup(void);>"

#. type: Plain text
#: man-pages/man2/vhangup.2:39
msgid ""
"Feature Test Macro Requirements for glibc (see B<feature_test_macros>(7)):"
msgstr ""
"Требования макроса тестирования свойств для glibc (см. B<feature_test_macros>"
"(7)):"

#. type: Plain text
#: man-pages/man2/vhangup.2:44
msgid ""
"B<vhangup>(): _BSD_SOURCE || (_XOPEN_SOURCE && _XOPEN_SOURCE\\ E<lt>\\ 500)"
msgstr ""
"B<vhangup>(): _BSD_SOURCE || (_XOPEN_SOURCE && _XOPEN_SOURCE\\ E<lt>\\ 500)"

#. type: Plain text
#: man-pages/man2/vhangup.2:50
msgid ""
"B<vhangup>()  simulates a hangup on the current terminal.  This call "
"arranges for other users to have a ``clean'' terminal at login time."
msgstr ""
"B<vhangup>() имитирует прекращение работы на текущем терминале. Этот вызов "
"выполняет действия, необходимые для очистки терминала перед приглашением ко "
"входу."

#. type: Plain text
#: man-pages/man2/vhangup.2:55
msgid ""
"On success, zero is returned.  On error, -1 is returned, and I<errno> is set"
" appropriately."
msgstr ""
"При успешном выполнении возвращается 0. В случае ошибки возвращается -1, а I<"
"errno> устанавливается в соответствующее значение."

#. type: TP
#: man-pages/man2/vhangup.2:56
#, no-wrap
msgid "B<EPERM>"
msgstr "B<EPERM>"

#. type: Plain text
#: man-pages/man2/vhangup.2:63
msgid ""
"The calling process has insufficient privilege to call B<vhangup>(); the "
"B<CAP_SYS_TTY_CONFIG> capability is required."
msgstr ""
"Вызывающий процесс не имеет достаточно прав для вызова B<vhangup>(); "
"требуется мандат B<CAP_SYS_TTY_CONFIG>."

#. type: Plain text
#: man-pages/man2/vhangup.2:66
msgid ""
"This call is Linux-specific, and should not be used in programs intended to "
"be portable."
msgstr ""
"Данный вызов существует только в Linux и не должен использоваться в "
"программах, которые должны быть переносимыми."

#. type: Plain text
#: man-pages/man2/vhangup.2:68
msgid "B<capabilities>(7), B<init>(8)"
msgstr "B<capabilities>(7), B<init>(8)"

#. type: TH
#: man-pages/man2/vfork.2:28
#, no-wrap
msgid "VFORK"
msgstr "VFORK"

#. type: TH
#: man-pages/man2/vfork.2:28
#, no-wrap
msgid "2012-08-05"
msgstr "2012-08-05"

#. type: Plain text
#: man-pages/man2/vfork.2:31
msgid "vfork - create a child process and block parent"
msgstr "vfork - создаёт дочерний процесс и блокирует родительский"

#. type: Plain text
#: man-pages/man2/vfork.2:33
msgid "B<#include E<lt>sys/types.hE<gt>>"
msgstr "B<#include E<lt>sys/types.hE<gt>>"

#. type: Plain text
#: man-pages/man2/vfork.2:37
msgid "B<pid_t vfork(void);>"
msgstr "B<pid_t vfork(void);>"

#. type: Plain text
#: man-pages/man2/vfork.2:44
msgid "B<vfork>():"
msgstr "B<vfork>():"

#. type: TP
#: man-pages/man2/vfork.2:47
#, no-wrap
msgid "Since glibc 2.12:"
msgstr "Начиная с glibc 2.12:"

#. type: Plain text
#: man-pages/man2/vfork.2:54
#, no-wrap
msgid ""
"_BSD_SOURCE ||\n"
"    (_XOPEN_SOURCE\\ E<gt>=\\ 500 ||\n"
"        _XOPEN_SOURCE\\ &&\\ _XOPEN_SOURCE_EXTENDED) &&\n"
"    !(_POSIX_C_SOURCE\\ E<gt>=\\ 200809L || _XOPEN_SOURCE\\ E<gt>=\\ 700)\n"
msgstr ""
"_BSD_SOURCE ||\n    (_XOPEN_SOURCE\\ E<gt>=\\ 500 ||\n        _XOPEN_SOURCE\\ "
"&&\\ _XOPEN_SOURCE_EXTENDED) &&\n    !(_POSIX_C_SOURCE\\ E<gt>=\\ 200809L || "
"_XOPEN_SOURCE\\ E<gt>=\\ 700)\n"

#. type: Plain text
#: man-pages/man2/vfork.2:59
msgid ""
"Before glibc 2.12: _BSD_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 500 || "
"_XOPEN_SOURCE\\ &&\\ _XOPEN_SOURCE_EXTENDED"
msgstr ""
"До glibc 2.12: _BSD_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 500 || _XOPEN_SOURCE\\ "
"&&\\ _XOPEN_SOURCE_EXTENDED"

#. type: SS
#: man-pages/man2/vfork.2:63
#, no-wrap
msgid "Standard description"
msgstr "Описание в стандарте"

#. type: Plain text
#: man-pages/man2/vfork.2:82
msgid ""
"(From POSIX.1)  The B<vfork>()  function has the same effect as B<fork>(2), "
"except that the behavior is undefined if the process created by B<vfork>()  "
"either modifies any data other than a variable of type I<pid_t> used to "
"store the return value from B<vfork>(), or returns from the function in "
"which B<vfork>()  was called, or calls any other function before "
"successfully calling B<_exit>(2)  or one of the B<exec>(3)  family of "
"functions."
msgstr ""
"(Из POSIX) Функция B<vfork>() аналогична B<fork>(2) за тем исключением, что "
"поведение не определено, если процесс, созданный B<vfork>(), изменяет любые "
"данные, кроме переменной типа I<pid_t>, используемой в качестве значения, "
"возвращаемого B<vfork>(), или возвращается из функции, из которой была "
"вызвана функция B<vfork>(), или вызывает любую функцию до удачного исполнения "
"B<_exit>(2) или одной из функций семейства B<exec>(3)."

#. type: SS
#: man-pages/man2/vfork.2:82
#, no-wrap
msgid "Linux description"
msgstr "Описание в Linux"

#. type: Plain text
#: man-pages/man2/vfork.2:89
msgid ""
"B<vfork>(), just like B<fork>(2), creates a child process of the calling "
"process.  For details and return value and errors, see B<fork>(2)."
msgstr ""
"B<vfork>(), так же как и B<fork>(2), создаёт дочерний процесс для вызывающего "
"процесса. Подробности, возвращаемые значения и ошибки смотрите в  B<fork>(2)."

#. type: Plain text
#: man-pages/man2/vfork.2:98
msgid ""
"B<vfork>()  is a special case of B<clone>(2).  It is used to create new "
"processes without copying the page tables of the parent process.  It may be "
"useful in performance-sensitive applications where a child is created which "
"then immediately issues an B<execve>(2)."
msgstr ""
"B<vfork>() \\(em это специальный вариант B<clone>(2). Он используется для "
"создания новых процессов без копирования таблиц страниц родительского "
"процесса. Это может использоваться в приложениях, критичных к "
"производительности, для создания дочерних процессов, сразу же запускающих B<"
"execve>(2)."

#. type: Plain text
#: man-pages/man2/vfork.2:115
msgid ""
"B<vfork>()  differs from B<fork>(2)  in that the calling thread is suspended"
" until the child terminates (either normally, by calling B<_exit>(2), or "
"abnormally, after delivery of a fatal signal), or it makes a call to "
"B<execve>(2).  Until that point, the child shares all memory with its "
"parent, including the stack.  The child must not return from the current "
"function or call B<exit>(3), but may call B<_exit>(2)."
msgstr ""
"Вызов B<vfork>() отличается от B<fork>(2) тем, что вызывающая нить "
"блокируется до тех пор, пока не завершится потомок (обычно, вызвав B<_exit>"
"(2) или, что ненормально, из-за принятого необработанного сигнала) или не "
"выполнит B<execve>(2). До этих пор потомок имеет общую память с родителем, "
"включая стек. Потомок не должен выходить из текущей функции или вызывать B<"
"exit>(3), но может вызвать B<_exit>(2)."

#. type: Plain text
#: man-pages/man2/vfork.2:126
msgid ""
"As with B<fork>(2), the child process created by B<vfork>()  inherits copies"
" of various of the caller's process attributes (e.g., file descriptors, "
"signal dispositions, and current working directory); the B<vfork>()  call "
"differs only in the treatment of the virtual address space, as described "
"above."
msgstr ""
"Как и у B<fork>(2), дочерний процесс, созданный B<vfork>(), наследует копии "
"различных атрибутов вызвавшего процесса (например, дескрипторы файлов, "
"обработчики сигналов и текущий рабочий каталог); вызов B<vfork>() отличается "
"только в применении виртуального адресного пространства (как описывалось "
"выше)."

#. type: Plain text
#: man-pages/man2/vfork.2:132
msgid ""
"Signals sent to the parent arrive after the child releases the parent's "
"memory (i.e., after the child terminates or calls B<execve>(2))."
msgstr ""
"Сигналы передаются родителю после того, как потомок разблокирует его память "
"(т.е. после того, как потомок завершится или вызовет B<execve>(2))."

#. type: SS
#: man-pages/man2/vfork.2:132
#, no-wrap
msgid "Historic description"
msgstr "Историческое описание"

#. type: Plain text
#: man-pages/man2/vfork.2:159
msgid ""
"Under Linux, B<fork>(2)  is implemented using copy-on-write pages, so the "
"only penalty incurred by B<fork>(2)  is the time and memory required to "
"duplicate the parent's page tables, and to create a unique task structure "
"for the child.  However, in the bad old days a B<fork>(2)  would require "
"making a complete copy of the caller's data space, often needlessly, since "
"usually immediately afterward an B<exec>(3)  is done.  Thus, for greater "
"efficiency, BSD introduced the B<vfork>()  system call, which did not fully "
"copy the address space of the parent process, but borrowed the parent's "
"memory and thread of control until a call to B<execve>(2)  or an exit "
"occurred.  The parent process was suspended while the child was using its "
"resources.  The use of B<vfork>()  was tricky: for example, not modifying "
"data in the parent process depended on knowing which variables were held in "
"a register."
msgstr ""
"В Linux вызов B<fork>(2) реализован при помощи страниц, «копируемых при "
"записи» (copy-on-write), поэтому единственная задержка, возникающая при "
"вызове B<fork>(2) \\(em это время, необходимое для создания копии таблиц "
"страниц родительского процесса и уникальной структуры описания задачи "
"дочернего процесса. Однако, в прошлом для B<fork>(2) могло требоваться "
"создание полной копии пространства данных вызывающего процесса, что часто "
"было ненужно, так как в потомке сразу следовал запуск функции B<exec>(3). "
"Поэтому для большей эффективности в BSD был предложен системный вызов B<vfork>"
"(), который не копировал адресное пространство процесса, а использовал то же "
"самое пространство и управления нитью, блокируя родительский процесс до "
"вызова B<execve>(2) или до прекращения работы потомка. Родительский процесс "
"останавливался до тех пор, пока потомок использовал его ресурсы. "
"Использование B<vfork>() было ненадёжно: например, сохранность данных "
"родительского процесса зависела от того, хранились ли на тот момент "
"переменные в регистрах."

#. type: Plain text
#: man-pages/man2/vfork.2:163
msgid ""
"4.3BSD; POSIX.1-2001 (but marked OBSOLETE).  POSIX.1-2008 removes the "
"specification of B<vfork>()."
msgstr ""
"4.3BSD; POSIX.1-2001 (помечен как УСТАРЕВШИЙ). Из POSIX.1-2008 описание B<"
"vfork>() было удалено."

#.  In AIXv3.1 vfork is equivalent to fork.
#. type: Plain text
#: man-pages/man2/vfork.2:174
msgid ""
"The requirements put on B<vfork>()  by the standards are weaker than those "
"put on B<fork>(2), so an implementation where the two are synonymous is "
"compliant.  In particular, the programmer cannot rely on the parent "
"remaining blocked until the child either terminates or calls B<execve>(2), "
"and cannot rely on any specific behavior with respect to shared memory."
msgstr ""
"Требования, предъявляемые стандартами к B<vfork>(), не такие жёсткие как те, "
"которые предъявляются к B<fork>(2), поэтому в реализации достаточно просто "
"сделать их синонимами. В частности, программист не может полагаться на "
"блокировку родителя до завершения потомка или до вызова им B<execve>(2), и не "
"может полагаться на специфическое поведение возникновения общей памяти."

#. type: Plain text
#: man-pages/man2/vfork.2:193
msgid ""
"Some consider the semantics of B<vfork>()  to be an architectural blemish, "
"and the 4.2BSD man page stated: \"This system call will be eliminated when "
"proper system sharing mechanisms are implemented.  Users should not depend "
"on the memory sharing semantics of B<vfork>()  as it will, in that case, be "
"made synonymous to B<fork>(2).\" However, even though modern memory "
"management hardware has decreased the performance difference between "
"B<fork>(2)  and B<vfork>(), there are various reasons why Linux and other "
"systems have retained B<vfork>():"
msgstr ""
"Некоторые считают, что в семантике B<vfork>() есть архитектурный недостаток, "
"а в справочной странице BSD написано следующее: «Данный системный вызов будет "
"удалён после того, как будут правильно реализованы соответствующие механизмы "
"разделения ресурсов системы. Пользователи не должны опираться на существующую "
"семантику общей памяти B<vfork>(), то есть программа должна быть аналогична "
"программе с B<fork>(2)». Однако, даже при том, что современные аппаратные "
"средства управления памятью уменьшили разницу в производительности между B<"
"fork>(2) и B<vfork>(), есть другие причины почему в Linux и других "
"операционных системах B<vfork>() ещё существует:"

#. type: IP
#: man-pages/man2/vfork.2:193 man-pages/man2/vfork.2:197
#, no-wrap
msgid "*"
msgstr "*"

#. type: Plain text
#: man-pages/man2/vfork.2:197
msgid ""
"Some performance-critical applications require the small performance "
"advantage conferred by B<vfork>()."
msgstr ""
"Для некоторых критичных к производительности приложений очень важна та "
"маленькая прибавка к производительности, предоставляемая B<vfork>()."

#.  http://stackoverflow.com/questions/4259629/what-is-the-difference-between-
#. fork-and-vfork
#.  http://developers.sun.com/solaris/articles/subprocess/subprocess.html
#.  http://mailman.uclinux.org/pipermail/uclinux-dev/2009-April/000684.html
#. type: Plain text
#: man-pages/man2/vfork.2:213
msgid ""
"B<vfork>()  can be implemented on systems that lack a memory-management unit"
" (MMU), but B<fork>(2)  can't be implemented on such systems.  (POSIX.1-2008"
" removed B<vfork>()  from the standard; the POSIX rationale for the "
"B<posix_spawn>(3)  function notes that that function, which provides "
"functionality equivalent to B<fork>(2)+B<exec>(3), is designed to be "
"implementable on systems that lack an MMU.)"
msgstr ""
"Вызов B<vfork>() может быть реализован в системах, у которых нет блока "
"управления памятью (MMU), а B<fork>(2) невозможно реализовать на таких "
"системах (из POSIX.1-2008 вызов B<vfork>() удалён; для реализации эквивалента "
"B<fork>(2)+B<exec>(3) в системах без MMU в POSIX предлагается использовать "
"функцию B<posix_spawn>(3))."

#. type: SS
#: man-pages/man2/vfork.2:213
#, no-wrap
msgid "Linux notes"
msgstr "Замечания, касающиеся Linux"

#. type: Plain text
#: man-pages/man2/vfork.2:224
msgid ""
"Fork handlers established using B<pthread_atfork>(3)  are not called when a "
"multithreaded program employing the NPTL threading library calls B<vfork>()."
"  Fork handlers are called in this case in a program using the LinuxThreads "
"threading library.  (See B<pthreads>(7)  for a description of Linux "
"threading libraries.)"
msgstr ""
"Обработчики fork, установленные с помощью B<pthread_atfork>(3), не вызываются "
"когда многонитиевая программа использует вызовы библиотеки нитей NPTL B<vfork>"
"(). Обработчики fork вызываются в этом случае в программе, в которой "
"используется библиотека нитей LinuxThreads. (См. в B<pthreads>(7) описание "
"библиотек нитей Linux.)"

#. type: Plain text
#: man-pages/man2/vfork.2:232
msgid ""
"A call to B<vfork>()  is equivalent to calling B<clone>(2)  with I<flags> "
"specified as:"
msgstr ""
"Вызов B<vfork>() эквивалентен вызову B<clone>(2) со следующим значением I<"
"flags>:"

#. type: Plain text
#: man-pages/man2/vfork.2:234
#, no-wrap
msgid "     CLONE_VM | CLONE_VFORK | SIGCHLD\n"
msgstr "     CLONE_VM | CLONE_VFORK | SIGCHLD\n"

#.  In the release notes for 4.2BSD Sam Leffler wrote: `vfork: Is still
#.  present, but definitely on its way out'.
#. type: Plain text
#: man-pages/man2/vfork.2:252
msgid ""
"The B<vfork>()  system call appeared in 3.0BSD.  In 4.4BSD it was made "
"synonymous to B<fork>(2)  but NetBSD introduced it again, cf.  E<.UR "
"http://www.netbsd.org\\:/Documentation\\:/kernel\\:/vfork.html> E<.UE .> In "
"Linux, it has been equivalent to B<fork>(2)  until 2.2.0-pre6 or so.  Since "
"2.2.0-pre9 (on i386, somewhat later on other architectures) it is an "
"independent system call.  Support was added in glibc 2.0.112."
msgstr ""
"Системный вызов B<vfork>() впервые появился в 3.0BSD. В 4.4BSD он стал "
"синонимом B<fork>(2), но в NetBSD он был введён снова E<.UR "
"http://www.netbsd.org\\:/Documentation\\:/kernel\\:/vfork.html> E<.UE>. В "
"Linux этот системный вызов был эквивалентом B<fork>(2), примерно, до ядра "
"2.2.0-pre6. Начиная с 2.2.0-pre9 (на i386 и немного позже на других "
"архитектурах), он стал независимым системным вызовом. Его поддержка была "
"добавлена в glibc 2.0.112."

#. type: SH
#: man-pages/man2/vfork.2:252
#, no-wrap
msgid "BUGS"
msgstr "ДЕФЕКТЫ"

#.  As far as I can tell, the following is not true in 2.6.19:
#.  Currently (Linux 2.3.25),
#.  .BR strace (1)
#.  cannot follow
#.  .BR vfork ()
#.  and requires a kernel patch.
#. type: Plain text
#: man-pages/man2/vfork.2:273
msgid ""
"Details of the signal handling are obscure and differ between systems.  The "
"BSD man page states: \"To avoid a possible deadlock situation, processes "
"that are children in the middle of a B<vfork>()  are never sent B<SIGTTOU> "
"or B<SIGTTIN> signals; rather, output or I<ioctl>s are allowed and input "
"attempts result in an end-of-file indication.\""
msgstr ""
"Обработка сигналов ещё более запутана и различается от системы к системе. В "
"справочной странице BSD написано следующее: «Для исключения возможности "
"взаимных блокировок процессы, находящиеся в середине исполнения B<vfork>(), "
"никогда не получат сигналов B<SIGTTOU> или B<SIGTTIN>, хотя вывод или I<ioctl>"
" всегда разрешены, а попытки ввода приводят к ситуации появления конца файла»."

#. type: Plain text
#: man-pages/man2/vfork.2:278
msgid "B<clone>(2), B<execve>(2), B<fork>(2), B<unshare>(2), B<wait>(2)"
msgstr "B<clone>(2), B<execve>(2), B<fork>(2), B<unshare>(2), B<wait>(2)"

#. type: TH
#: man-pages/man2/vm86.2:26
#, no-wrap
msgid "VM86"
msgstr "VM86"

#. type: TH
#: man-pages/man2/vm86.2:26
#, no-wrap
msgid "2009-02-20"
msgstr "2009-02-20"

#. type: Plain text
#: man-pages/man2/vm86.2:29
msgid "vm86old, vm86 - enter virtual 8086 mode"
msgstr "vm86old, vm86 - войти в виртуальный режим 8086  "

#. type: Plain text
#: man-pages/man2/vm86.2:31
msgid "B<#include E<lt>sys/vm86.hE<gt>>"
msgstr "B<#include E<lt>sys/vm86.hE<gt>>"

#. type: Plain text
#: man-pages/man2/vm86.2:33
msgid "B<int vm86old(struct vm86_struct *>I<info>B<);>"
msgstr "B<int vm86old(struct vm86_struct *>I<info>B<);>"

#. type: Plain text
#: man-pages/man2/vm86.2:35
msgid "B<int vm86(unsigned long >I<fn>B<, struct vm86plus_struct *>I<v86>B<);>"
msgstr ""
"B<int vm86(unsigned long >I<fn>B<, struct vm86plus_struct *>I<v86>B<);>"

#. type: Plain text
#: man-pages/man2/vm86.2:48
msgid ""
"The system call B<vm86>()  was introduced in Linux 0.97p2.  In Linux 2.1.15 "
"and 2.0.28, it was renamed to B<vm86old>(), and a new B<vm86>()  was "
"introduced.  The definition of I<struct vm86_struct> was changed in 1.1.8 "
"and 1.1.9."
msgstr ""
"Системный вызов B<vm86>() был введён в Linux 0.97p2. В Linux 2.1.15 и 2.0.28 "
"он был переименован в B<vm86old>() и был введён новый B<vm86>(). Описание "
"структуры I<struct vm86_struct> было изменено в 1.1.8 и 1.1.9."

#. type: Plain text
#: man-pages/man2/vm86.2:52
msgid ""
"These calls cause the process to enter VM86 mode (virtual-8086 in Intel "
"literature), and are used by B<dosemu>."
msgstr ""
"Данные вызовы заставляют вызывающий процесс войти в режим VM86 (виртуальный "
"режим 8086 в литературе по Intel) и используются B<dosemu>."

#. type: Plain text
#: man-pages/man2/vm86.2:54
msgid "VM86 mode is an emulation of real mode within a protected mode task."
msgstr ""
"Режим VM86 \\(em это эмуляция реального режима внутри задачи, которая "
"работает в защищённом режиме."

#. type: TP
#: man-pages/man2/vm86.2:60
#, no-wrap
msgid "B<EFAULT>"
msgstr "B<EFAULT>"

#. type: Plain text
#: man-pages/man2/vm86.2:64
msgid ""
"This return value is specific to i386 and indicates a problem with getting "
"user-space data."
msgstr ""
"Возвращённое значение является есть только для i386 и указывает на проблему "
"получения данных из пространства пользователя."

#. type: TP
#: man-pages/man2/vm86.2:64
#, no-wrap
msgid "B<ENOSYS>"
msgstr "B<ENOSYS>"

#. type: Plain text
#: man-pages/man2/vm86.2:68
msgid ""
"This return value indicates the call is not implemented on the present "
"architecture."
msgstr ""
"Возвращённое значение указывает, что вызов не реализован на данной "
"архитектуре."

#. type: Plain text
#: man-pages/man2/vm86.2:73
msgid ""
"Saved kernel stack exists.  (This is a kernel sanity check; the saved stack "
"should exist only within vm86 mode itself.)"
msgstr ""
"Существует сохранённый стек ядра (это проверка ядра; сохранённый стек должен "
"существовать только внутри самого режима vm86)."

#. type: Plain text
#: man-pages/man2/vm86.2:75
msgid ""
"This call is specific to Linux on 32-bit Intel processors, and should not be"
" used in programs intended to be portable."
msgstr ""
"Данный вызов является специфичным для Linux на 32-битных процессорах Intel и "
"не должен использоваться в программах, которые задумываются как переносимые "
"на другие платформы.  "

