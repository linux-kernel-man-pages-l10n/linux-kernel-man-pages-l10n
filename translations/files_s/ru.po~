# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# 
# Translators:
# Azamat Hackimov <azamat.hackimov@gmail.com>, 2011,2014
# Yuri Kozlov <yuray@komyakino.ru>, 2011-2014
# Yuri Kozlov <yuray@komyakino.ru>, 2013
msgid ""
msgstr ""
"Project-Id-Version: translation of man-pages\n"
"POT-Creation-Date: 2014-06-08 09:39+0400\n"
"PO-Revision-Date: 2014-08-17 04:32+0000\n"
"Last-Translator: Yuri Kozlov <yuray@komyakino.ru>\n"
"Language-Team: Russian (http://www.transifex.com/projects/p/man-pages/language/ru/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ru\n"
"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2);\n"

#. type: TH
#: man-pages/man4/sk98lin.4:27
#, no-wrap
msgid "SK98LIN"
msgstr "SK98LIN"

#. type: TH
#: man-pages/man4/sk98lin.4:27
#, no-wrap
msgid "2012-08-05"
msgstr "2012-08-05"

#. type: TH
#: man-pages/man4/sk98lin.4:27
#, no-wrap
msgid "Linux"
msgstr "Linux"

#. type: TH
#: man-pages/man4/sk98lin.4:27
#, no-wrap
msgid "Linux Programmer's Manual"
msgstr "Руководство программиста Linux"

#. type: SH
#: man-pages/man4/sk98lin.4:28
#, no-wrap
msgid "NAME"
msgstr "ИМЯ"

#. type: Plain text
#: man-pages/man4/sk98lin.4:30
msgid "sk98lin - Marvell/SysKonnect Gigabit Ethernet driver v6.21"
msgstr "sk98lin - драйвер Marvell/SysKonnect Gigabit Ethernet, версия 6.21"

#. type: SH
#: man-pages/man4/sk98lin.4:30
#, no-wrap
msgid "SYNOPSIS"
msgstr "ОБЗОР"

#. type: Plain text
#: man-pages/man4/sk98lin.4:62
msgid ""
"B<insmod sk98lin.o> [B<Speed_A=>I<i,j,...>] [B<Speed_B=>I<i,j,...>] "
"[B<AutoNeg_A=>I<i,j,...>] [B<AutoNeg_B=>I<i,j,...>] [B<DupCap_A=>I<i,j,...>]"
" [B<DupCap_B=>I<i,j,...>] [B<FlowCtrl_A=>I<i,j,...>] "
"[B<FlowCtrl_B=>I<i,j,...>] [B<Role_A=>I<i,j,...>] [B<Role_B=>I<i,j,...>] "
"[B<ConType=>I<i,j,...>] [B<Moderation=>I<i,j,...>] "
"[B<IntsPerSec=>I<i,j,...>] [B<PrefPort=>I<i,j,...>] [B<RlmtMode=>I<i,j,...>]"
msgstr "B<insmod sk98lin.o> [B<Speed_A=>I<i,j,...>] [B<Speed_B=>I<i,j,...>] [B<AutoNeg_A=>I<i,j,...>] [B<AutoNeg_B=>I<i,j,...>] [B<DupCap_A=>I<i,j,...>] [B<DupCap_B=>I<i,j,...>] [B<FlowCtrl_A=>I<i,j,...>] [B<FlowCtrl_B=>I<i,j,...>] [B<Role_A=>I<i,j,...>] [B<Role_B=>I<i,j,...>] [B<ConType=>I<i,j,...>] [B<Moderation=>I<i,j,...>] [B<IntsPerSec=>I<i,j,...>] [B<PrefPort=>I<i,j,...>] [B<RlmtMode=>I<i,j,...>]"

#. type: SH
#: man-pages/man4/sk98lin.4:62
#, no-wrap
msgid "DESCRIPTION"
msgstr "ОПИСАНИЕ"

#. type: Plain text
#: man-pages/man4/sk98lin.4:67
msgid ""
"B<Note>: This obsolete driver was removed from the kernel in version 2.6.26."
msgstr "B<Замечание>: Данный устаревший драйвер был удалён из ядра версии 2.6.26."

#. type: Plain text
#: man-pages/man4/sk98lin.4:74
msgid ""
"B<sk98lin> is the Gigabit Ethernet driver for Marvell and SysKonnect network"
" adapter cards.  It supports SysKonnect SK-98xx/SK-95xx compliant Gigabit "
"Ethernet Adapter and any Yukon compliant chipset."
msgstr "B<sk98lin> — это драйвер Gigabit Ethernet для сетевых адаптеров Marvell и SysKonnect. Он поддерживает SysKonnect SK-98xx/SK-95xx-совместимые адаптеры Gigabit Ethernet и любые карты с Yukon-совместимым чипсетом."

#. type: Plain text
#: man-pages/man4/sk98lin.4:81
msgid ""
"When loading the driver using insmod, parameters for the network adapter "
"cards might be stated as a sequence of comma separated commands.  If for "
"instance two network adapters are installed and AutoNegotiation on Port A of"
" the first adapter should be ON, but on the Port A of the second adapter "
"switched OFF, one must enter:"
msgstr "При загрузке драйвера с помощью insmod, параметры сетевого адаптера можно указать в командной строке через запятую. Если, например, установлено два сетевых адаптера и AutoNegotiation на порту A первого адаптера нужно включить, а на порту A второго адаптера — выключить, то введите следующее:"

#. type: Plain text
#: man-pages/man4/sk98lin.4:83
#, no-wrap
msgid "   insmod sk98lin.o AutoNeg_A=On,Off\n"
msgstr "   insmod sk98lin.o AutoNeg_A=On,Off\n"

#. type: Plain text
#: man-pages/man4/sk98lin.4:98
msgid ""
"After B<sk98lin> is bound to one or more adapter cards and the I</proc> "
"filesystem is mounted on your system, a dedicated statistics file will be "
"created in the folder I</proc/net/sk98lin> for all ports of the installed "
"network adapter cards.  Those files are named I<eth[x]>, where I<x> is the "
"number of the interface that has been assigned to a dedicated port by the "
"system."
msgstr "После того как B<sk98lin> подхватит один или более адаптер и будет смонтирована файловая система I</proc>, будут созданы отдельные файлы статистики в каталоге I</proc/net/sk98lin> для каждого  порта установленных сетевых адаптеров. Эти файлы будут называться I<eth[x]>, где I<x> — номер интерфейса, который был назначен каждому порту в системе."

#. type: Plain text
#: man-pages/man4/sk98lin.4:108
msgid ""
"If loading is finished, any desired IP address can be assigned to the "
"respective I<eth[x]> interface using the B<ifconfig>(8)  command.  This "
"causes the adapter to connect to the Ethernet and to display a status "
"message on the console saying \"ethx: network connection up using port y\" "
"followed by the configured or detected connection parameters."
msgstr "После завершения загрузки каждому I<eth[x]> может быть назначен желаемый IP-адрес с помощью команды B<ifconfig>(8). Это заставит адаптер подключиться к Ethernet и вывести сообщение на консоль: \"ethx: network connection up using port y\" с настроенными или определёнными параметрами подключения."

#. type: Plain text
#: man-pages/man4/sk98lin.4:124
msgid ""
"The B<sk98lin> also supports large frames (also called jumbo frames).  Using"
" jumbo frames can improve throughput tremendously when transferring large "
"amounts of data.  To enable large frames, the MTU (maximum transfer unit) "
"size for an interface is to be set to a high value.  The default MTU size is"
" 1500 and can be changed up to 9000 (bytes).  Setting the MTU size can be "
"done when assigning the IP address to the interface or later by using the "
"B<ifconfig>(8)  command with the mtu parameter.  If for instance eth0 needs "
"an IP address and a large frame MTU size, the following two commands might "
"be used:"
msgstr "Драйвер B<sk98lin> также поддерживает большие фреймы (также называемые jumbo фреймами). С помощью jumbo-фреймов можно очень сильно увеличить пропускную способность при передаче больших объёмов данных. Чтобы включить большие фреймы, нужно на интерфейсе установить большое значение MTU (максимальная единица передачи). Значение MTU по умолчанию равно 1500 и может быть увеличено до 9000 (байт). Установку размера MTU можно выполнить при назначении IP-адреса интерфейсу или позднее с помощью команды B<ifconfig>(8) с параметром mtu. Если, например, eth0 нужно назначить IP-адрес и большой размер фрейма MTU, то это можно сделать с помощью следующих двух команд:"

#. type: Plain text
#: man-pages/man4/sk98lin.4:127
#, no-wrap
msgid ""
"    ifconfig eth0 10.1.1.1\n"
"    ifconfig eth0 mtu 9000\n"
msgstr "    ifconfig eth0 10.1.1.1\n    ifconfig eth0 mtu 9000\n"

#. type: Plain text
#: man-pages/man4/sk98lin.4:129
msgid "Those two commands might even be combined into one:"
msgstr "Эти две команды можно объединить в одну:"

#. type: Plain text
#: man-pages/man4/sk98lin.4:131
#, no-wrap
msgid "    ifconfig eth0 10.1.1.1 mtu 9000\n"
msgstr "    ifconfig eth0 10.1.1.1 mtu 9000\n"

#. type: Plain text
#: man-pages/man4/sk98lin.4:144
msgid ""
"Note that large frames can be used only if permitted by your network "
"infrastructure.  This means, that any switch being used in your Ethernet "
"must also support large frames.  Quite some switches support large frames, "
"but need to be configured to do so.  Most of the times, their default "
"setting is to support only standard frames with an MTU size of 1500 (bytes)."
"  In addition to the switches inside the network, all network adapters that "
"are to be used must also be enabled regarding jumbo frames.  If an adapter "
"is not set to receive large frames, it will simply drop them."
msgstr "Заметим, что большие фреймы можно использовать только, если эта позволяет ваша сетевая инфраструктура. Это означает, что все коммутаторы сети Ethernet  также должны поддерживать большие фреймы. Довольно много коммутаторов поддерживают большие фреймы, но для этого их нужно настроить. В большинстве случаев, в настройках по умолчанию используются только стандартные фреймы с размером MTU равным 1500 (байт). Помимо коммутатором сети, все используемые сетевые адаптеры также должны принимать jumbo-фреймы. Если адаптер не настроен для приёма больших фреймов, то он их просто отбрасывает."

#. type: Plain text
#: man-pages/man4/sk98lin.4:148
msgid ""
"Switching back to the standard Ethernet frame size can be done by using the "
"B<ifconfig>(8)  command again:"
msgstr "Для переключения обратно к стандартному размеру фрейма Ethernet можно использовать такую команду B<ifconfig>(8):"

#. type: Plain text
#: man-pages/man4/sk98lin.4:150
#, no-wrap
msgid "    ifconfig eth0 mtu 1500\n"
msgstr "    ifconfig eth0 mtu 1500\n"

#. type: Plain text
#: man-pages/man4/sk98lin.4:156
msgid ""
"The Marvell/SysKonnect Gigabit Ethernet driver for Linux is able to support "
"VLAN and Link Aggregation according to IEEE standards 802.1, 802.1q, and "
"802.3ad.  Those features are available only after installation of open "
"source modules which can be found on the Internet:"
msgstr "Драйвер Marvell/SysKonnect Gigabit Ethernet для Linux поддерживает VLAN и объединение каналов в соответствии со стандартами IEEE 802.1, 802.1q и 802.3ad. Эти свойства доступны только после установки открытых модулей, которые можно найти в Интернет:"

#. type: Plain text
#: man-pages/man4/sk98lin.4:161
msgid "I<VLAN>: E<.UR http://www.candelatech.com\\:/~greear\\:/vlan.html> E<.UE>"
msgstr "I<VLAN>: E<.UR http://www.candelatech.com\\:/~greear\\:/vlan.html> E<.UE>"

#. type: Plain text
#: man-pages/man4/sk98lin.4:167
msgid "I<Link> I<Aggregation>: E<.UR http://www.st.rim.or.jp\\:/~yumo> E<.UE>"
msgstr "I<Link> I<Aggregation>: E<.UR http://www.st.rim.or.jp\\:/~yumo> E<.UE>"

#. type: Plain text
#: man-pages/man4/sk98lin.4:172
msgid ""
"Note that Marvell/SysKonnect does not offer any support for these open "
"source modules and does not take the responsibility for any kind of failures"
" or problems arising when using these modules."
msgstr "Заметим, что Marvell/SysKonnect не предлагает поддержку этих открытых модулей и не несёт ответственности при отказах и проблемах, связанных с использованием этих модулей."

#. type: SS
#: man-pages/man4/sk98lin.4:172
#, no-wrap
msgid "Parameters"
msgstr "Параметры"

#. type: TP
#: man-pages/man4/sk98lin.4:173
#, no-wrap
msgid "B<Speed_A=>I<i,j,...>"
msgstr "B<Speed_A=>I<i,j,...>"

#. type: Plain text
#: man-pages/man4/sk98lin.4:190
msgid ""
"This parameter is used to set the speed capabilities of port A of an adapter"
" card.  It is valid only for Yukon copper adapters.  Possible values are: "
"I<10>, I<100>, I<1000>, or I<Auto>; I<Auto> is the default.  Usually, the "
"speed is negotiated between the two ports during link establishment.  If "
"this fails, a port can be forced to a specific setting with this parameter."
msgstr "Этот параметр используется для задания скорости порта A. Работает только для адаптеров Yukon с медным интерфейсом. Возможные значения: I<10>, I<100>, I<1000> или I<Auto>; по умолчанию задано I<Auto>. Обычно, скорость согласуется между двумя портами во время установки связи. Если процедура завершается неудачно, то порт можно принудительно перевести на нужную скорость с помощью этого параметра."

#. type: TP
#: man-pages/man4/sk98lin.4:190
#, no-wrap
msgid "B<Speed_B=>I<i,j,...>"
msgstr "B<Speed_B=>I<i,j,...>"

#. type: Plain text
#: man-pages/man4/sk98lin.4:207
msgid ""
"This parameter is used to set the speed capabilities of port B of an adapter"
" card.  It is valid only for Yukon copper adapters.  Possible values are: "
"I<10>, I<100>, I<1000>, or I<Auto>; I<Auto> is the default.  Usually, the "
"speed is negotiated between the two ports during link establishment.  If "
"this fails, a port can be forced to a specific setting with this parameter."
msgstr "Этот параметр используется для задания скорости порта B. Работает только для адаптеров Yukon с медным интерфейсом. Возможные значения: I<10>, I<100>, I<1000> или I<Auto>; по умолчанию задано I<Auto>. Обычно, скорость согласуется между двумя портами во время установки связи. Если процедура завершается неудачно, то порт можно принудительно перевести на нужную скорость с помощью этого параметра."

#. type: TP
#: man-pages/man4/sk98lin.4:207
#, no-wrap
msgid "B<AutoNeg_A=>I<i,j,...>"
msgstr "B<AutoNeg_A=>I<i,j,...>"

#. type: Plain text
#: man-pages/man4/sk98lin.4:221
msgid ""
"Enables or disables the use of autonegotiation of port A of an adapter card."
"  Possible values are: I<On>, I<Off>, or I<Sense>; I<On> is the default.  "
"The I<Sense> mode automatically detects whether the link partner supports "
"auto-negotiation or not."
msgstr "Включение или выключение автосогласования на порту A. Возможные значения: I<On>, I<Off> или I<Sense>; по умолчанию задано I<On>. В режиме I<Sense> выполняется автоматическое обнаружение поддержки автосогласования у партнёра по связи."

#. type: TP
#: man-pages/man4/sk98lin.4:221
#, no-wrap
msgid "B<AutoNeg_B=>I<i,j,...>"
msgstr "B<AutoNeg_B=>I<i,j,...>"

#. type: Plain text
#: man-pages/man4/sk98lin.4:235
msgid ""
"Enables or disables the use of autonegotiation of port B of an adapter card."
"  Possible values are: I<On>, I<Off>, or I<Sense>; I<On> is the default.  "
"The I<Sense> mode automatically detects whether the link partner supports "
"auto-negotiation or not."
msgstr "Включение или выключение автосогласования на порту B. Возможные значения: I<On>, I<Off> или I<Sense>; по умолчанию задано I<On>. В режиме I<Sense> выполняется автоматическое обнаружение поддержки автосогласования у партнёра по связи."

#. type: TP
#: man-pages/man4/sk98lin.4:235
#, no-wrap
msgid "B<DupCap_A=>I<i,j,...>"
msgstr "B<DupCap_A=>I<i,j,...>"

#. type: Plain text
#: man-pages/man4/sk98lin.4:265
msgid ""
"This parameter indicates the duplex mode to be used for port A of an adapter"
" card.  Possible values are: I<Half>, I<Full>, or I<Both>; I<Both> is the "
"default.  This parameter is relevant only if AutoNeg_A of port A is not set "
"to I<Sense>.  If AutoNeg_A is set to I<On>, all three values of DupCap_A ( "
"I<Half>, I<Full> or I<Both>)  might be stated.  If AutoNeg_A is set to "
"I<Off>, only DupCap_A values I<Full> and I<Half> are allowed.  This DupCap_A"
" parameter is useful if your link partner does not support all possible "
"duplex combinations."
msgstr "Этот параметр используется для задания режима дуплекса на порту A. Возможные значения: I<Half>, I<Full> или I<Both>; по умолчанию задано I<Both>. Этот параметр учитывается только, если AutoNeg_A для порта A не установлено в I<Sense>. Если значение AutoNeg_A равно I<On>, то может быть указано любое из трёх значений DupCap_A ( I<Half>, I<Full> или I<Both>). Если AutoNeg_A равно I<Off>, то значениями DupCap_A могут быть только I<Full> и I<Half>. Параметр DupCap_A полезен, если партнёр по связи не поддерживает все возможные комбинации дуплекса."

#. type: TP
#: man-pages/man4/sk98lin.4:265
#, no-wrap
msgid "B<DupCap_B=>I<i,j,...>"
msgstr "B<DupCap_B=>I<i,j,...>"

#. type: Plain text
#: man-pages/man4/sk98lin.4:295
msgid ""
"This parameter indicates the duplex mode to be used for port B of an adapter"
" card.  Possible values are: I<Half>, I<Full>, or I<Both>; I<Both> is the "
"default.  This parameter is relevant only if AutoNeg_B of port B is not set "
"to I<Sense>.  If AutoNeg_B is set to I<On>, all three values of DupCap_B ( "
"I<Half>, I<Full> or I<Both>)  might be stated.  If AutoNeg_B is set to "
"I<Off>, only DupCap_B values I<Full> and I<Half> are allowed.  This DupCap_B"
" parameter is useful if your link partner does not support all possible "
"duplex combinations."
msgstr "Этот параметр используется для задания режима дуплекса на порту B. Возможные значения: I<Half>, I<Full> или I<Both>; по умолчанию задано I<Both>. Этот параметр учитывается только, если AutoNeg_B для порта B не установлено в I<Sense>. Если значение AutoNeg_B равно I<On>, то может быть указано любое из трёх значений  DupCap_B ( I<Half>, I<Full> или I<Both>). Если AutoNeg_B равно I<Off>, то значениями DupCap_B могут быть только I<Full> и I<Half>. Параметр DupCap_B полезен, если партнёр по связи не поддерживает все возможные комбинации дуплекса."

#. type: TP
#: man-pages/man4/sk98lin.4:295
#, no-wrap
msgid "B<FlowCtrl_A=>I<i,j,...>"
msgstr "B<FlowCtrl_A=>I<i,j,...>"

#. type: Plain text
#: man-pages/man4/sk98lin.4:308 man-pages/man4/sk98lin.4:341
msgid ""
"This parameter can be used to set the flow control capabilities the port "
"reports during auto-negotiation.  Possible values are: I<Sym>, I<SymOrRem>, "
"I<LocSend>, or I<None>; I<SymOrRem> is the default.  The different modes "
"have the following meaning:"
msgstr "Этот параметр используется для задания свойств управления потоком, которые анонсируются портом при автосогласовании. Возможные значения: I<Sym>, I<SymOrRem>, I<LocSend> или I<None>; по умолчанию задано I<SymOrRem>. Назначение режимов:"

#. type: Plain text
#: man-pages/man4/sk98lin.4:313 man-pages/man4/sk98lin.4:345
#, no-wrap
msgid ""
"I<Sym>\n"
"= Symmetric\n"
" both link partners are allowed to send PAUSE frames\n"
msgstr "I<Sym>\n= Symmetric\n Оба партнёра по связи позволяют посылать фреймы PAUSE.\n"

#. type: Plain text
#: man-pages/man4/sk98lin.4:317 man-pages/man4/sk98lin.4:349
#, no-wrap
msgid ""
"I<SymOrRem>\n"
"= SymmetricOrRemote\n"
" both or only remote partner are allowed to send PAUSE frames\n"
msgstr "I<SymOrRem>\n= SymmetricOrRemote\n Оба или только один партнёр по связи позволяет посылать фреймы PAUSE.\n"

#. type: Plain text
#: man-pages/man4/sk98lin.4:321 man-pages/man4/sk98lin.4:353
#, no-wrap
msgid ""
"I<LocSend>\n"
"= LocalSend\n"
" only local link partner is allowed to send PAUSE frames\n"
msgstr "I<LocSend>\n= LocalSend\n Только локальная связь партнёра позволяет посылать фреймы PAUSE.\n"

#. type: Plain text
#: man-pages/man4/sk98lin.4:325 man-pages/man4/sk98lin.4:357
#, no-wrap
msgid ""
"I<None>\n"
"= None\n"
" no link partner is allowed to send PAUSE frames\n"
msgstr "I<None>\n= None\n  Партнёры по связи не позволяют посылать фреймы PAUSE.\n"

#. type: Plain text
#: man-pages/man4/sk98lin.4:328
msgid "Note that this parameter is ignored if AutoNeg_A is set to I<Off>."
msgstr "Заметим, что этот параметр игнорируется, если значение AutoNeg_A равно I<Off>."

#. type: TP
#: man-pages/man4/sk98lin.4:328
#, no-wrap
msgid "B<FlowCtrl_B=>I<i,j,...>"
msgstr "B<FlowCtrl_B=>I<i,j,...>"

#. type: Plain text
#: man-pages/man4/sk98lin.4:361
msgid "Note that this parameter is ignored if AutoNeg_B is set to I<Off>."
msgstr "Заметим, что этот параметр игнорируется, если значение AutoNeg_B равно I<Off>."

#. type: TP
#: man-pages/man4/sk98lin.4:361
#, no-wrap
msgid "B<Role_A=>I<i,j,...>"
msgstr "B<Role_A=>I<i,j,...>"

#. type: Plain text
#: man-pages/man4/sk98lin.4:377
msgid ""
"This parameter is valid only for 1000Base-T adapter cards.  For two "
"1000Base-T ports to communicate, one must take the role of the master "
"(providing timing information), while the other must be the slave.  Possible"
" values are: I<Auto>, I<Master>, or I<Slave>; I<Auto> is the default.  "
"Usually, the role of a port is negotiated between two ports during link "
"establishment, but if that fails the port A of an adapter card can be forced"
" to a specific setting with this parameter."
msgstr "Этот параметр доступен только для адаптеров 1000Base-T. При организации связи между двумя портами 1000Base-T один должен играть роль основного (предоставлять синхронизацию), другой — подчинённого. Возможные значения: I<Auto>, I<Master> или I<Slave>; по умолчанию задано I<Auto>. Обычно, роль порта согласуется во время установления связи, но если этого достичь не удалось, с помощью этого параметра порту A можно принудительно назначить нужное значение."

#. type: TP
#: man-pages/man4/sk98lin.4:377
#, no-wrap
msgid "B<Role_B=>I<i,j,...>"
msgstr "B<Role_B=>I<i,j,...>"

#. type: Plain text
#: man-pages/man4/sk98lin.4:394
msgid ""
"This parameter is valid only for 1000Base-T adapter cards.  For two "
"1000Base-T ports to communicate, one must take the role of the master "
"(providing timing information), while the other must be the slave.  Possible"
" values are: I<Auto>, I<Master>, or I<Slave>; I<Auto> is the default.  "
"Usually, the role of a port is negotiated between two ports during link "
"establishment, but if that fails the port B of an adapter card can be forced"
" to a specific setting with this parameter."
msgstr "Этот параметр доступен только для адаптеров 1000Base-T. При организации связи между двумя портами 1000Base-T один должен играть роль основного (предоставлять синхронизацию), другой — подчинённого. Возможные значения: I<Auto>, I<Master> или I<Slave>; по умолчанию задано I<Auto>. Обычно, роль порта согласуется во время установления связи, но если этого достичь не удалось, с помощью этого параметра порту B можно принудительно назначить нужное значение."

#. type: TP
#: man-pages/man4/sk98lin.4:394
#, no-wrap
msgid "B<ConType=>I<i,j,...>"
msgstr "B<ConType=>I<i,j,...>"

#. type: Plain text
#: man-pages/man4/sk98lin.4:402
msgid ""
"This parameter is a combination of all five per-port parameters within one "
"single parameter.  This simplifies the configuration of both ports of an "
"adapter card.  The different values of this variable reflect the most "
"meaningful combinations of port parameters.  Possible values and their "
"corresponding combination of per-port parameters:"
msgstr "Этот параметр представляет собой комбинацию всех пяти параметров порта. Он упрощает настройку обоих портов адаптера. Различные значения этой переменной отражают большую часть важных комбинаций параметров порта. Возможные значения и их соответствующие комбинации параметров портов:"

#. type: Plain text
#: man-pages/man4/sk98lin.4:407
#, no-wrap
msgid ""
"ConType | DupCap   AutoNeg   FlowCtrl   Role   Speed\n"
"--------+-------------------------------------------\n"
"I<Auto>    |  Both      On      SymOrRem   Auto   Auto\n"
msgstr "ConType | DupCap   AutoNeg   FlowCtrl   Role   Speed\n--------+-------------------------------------------\nI<Auto>    |  Both      On      SymOrRem   Auto   Auto\n"

#. type: Plain text
#: man-pages/man4/sk98lin.4:409
#, no-wrap
msgid "I<100FD>   |  Full      Off       None     Auto   100\n"
msgstr "I<100FD>   |  Full      Off       None     Auto   100\n"

#. type: Plain text
#: man-pages/man4/sk98lin.4:411
#, no-wrap
msgid "I<100HD>   |  Half      Off       None     Auto   100\n"
msgstr "I<100HD>   |  Half      Off       None     Auto   100\n"

#. type: Plain text
#: man-pages/man4/sk98lin.4:413
#, no-wrap
msgid "I<10FD>    |  Full      Off       None     Auto   10\n"
msgstr "I<10FD>    |  Full      Off       None     Auto   10\n"

#. type: Plain text
#: man-pages/man4/sk98lin.4:415
#, no-wrap
msgid "I<10HD>    |  Half      Off       None     Auto   10\n"
msgstr "I<10HD>    |  Half      Off       None     Auto   10\n"

#. type: Plain text
#: man-pages/man4/sk98lin.4:425
msgid ""
"Stating any other port parameter together with this I<ConType> parameter "
"will result in a merged configuration of those settings.  This is due to the"
" fact, that the per-port parameters (e.g., I<Speed_A>)  have a higher "
"priority than the combined variable I<ConType>."
msgstr "Задание любого другого параметра порта вместе с I<ConType> приводит к объединению обеих настроек. Одиночные параметры порта (например, I<Speed_A>) имеют больший приоритет чем значение переменной I<ConType>."

#. type: TP
#: man-pages/man4/sk98lin.4:425
#, no-wrap
msgid "B<Moderation=>I<i,j,...>"
msgstr "B<Moderation=>I<i,j,...>"

#. type: Plain text
#: man-pages/man4/sk98lin.4:442
msgid ""
"Interrupt moderation is employed to limit the maximum number of interrupts "
"the driver has to serve.  That is, one or more interrupts (which indicate "
"any transmit or receive packet to be processed) are queued until the driver "
"processes them.  When queued interrupts are to be served, is determined by "
"the I<IntsPerSec> parameter, which is explained later below.  Possible "
"moderation modes are: I<None>, I<Static>, or I<Dynamic>; I<None> is the "
"default.  The different modes have the following meaning:"
msgstr "Регулирование прерываний используется для ограничения максимального количества прерываний, которое может обработать драйвер. То есть одно и более прерываний (которые означают обработку передачи или приёма пакета) ставится в очередь для ожидания обработки драйвером. Параметр I<IntsPerSec> определяет когда обслуживается очередь (см. далее). Возможные режимы регулирования: I<None>, I<Static> или I<Dynamic>; по умолчанию задано I<None>. Назначение режимов:"

#. type: Plain text
#: man-pages/man4/sk98lin.4:447
msgid ""
"I<None> No interrupt moderation is applied on the adapter card.  Therefore, "
"each transmit or receive interrupt is served immediately as soon as it "
"appears on the interrupt line of the adapter card."
msgstr "I<None> Не выполнять регулирование прерываний для адаптера. Следовательно, каждое прерывания по передаче или приёму будет обработано немедленно, сразу после появления на линии прерывания адаптера."

#. type: Plain text
#: man-pages/man4/sk98lin.4:462
msgid ""
"I<Static> Interrupt moderation is applied on the adapter card.  All transmit"
" and receive interrupts are queued until a complete moderation interval "
"ends.  If such a moderation interval ends, all queued interrupts are "
"processed in one big bunch without any delay.  The term I<Static> reflects "
"the fact, that interrupt moderation is always enabled, regardless how much "
"network load is currently passing via a particular interface.  In addition, "
"the duration of the moderation interval has a fixed length that never "
"changes while the driver is operational."
msgstr "I<Static> Выполнять регулирование прерываний для адаптера. Все прерывания по передаче и приёму ставятся в очередь в ожидании завершения интервала регулирования. После окончания интервала все прерывания в очереди обрабатываются одним большим заданием без задержки. Термин I<Static> отражает тот факт, что регулирование прерываний всегда включено, независимо от сетевой загрузки на определённом интерфейсе в данный момент. Кроме того, длительность интервала регулирования прерываний  имеет постоянную величину, которая при работающем драйвере никогда не меняется."

#. type: Plain text
#: man-pages/man4/sk98lin.4:473
msgid ""
"I<Dynamic> Interrupt moderation might be applied on the adapter card, "
"depending on the load of the system.  If the driver detects that the system "
"load is too high, the driver tries to shield the system against too much "
"network load by enabling interrupt moderation.  If\\(emat a later "
"time\\(emthe CPU utilization decreases again (or if the network load is "
"negligible), the interrupt moderation will automatically be disabled."
msgstr "I<Dynamic> Регулирование прерываний может применяться к адаптеру в зависимости от загрузки системы. Если драйвер обнаруживает, что система очень загружена, то он попытается оградить систему от излишней сетевой нагрузки, включив регулирование прерываний. Если позднее нагрузка на ЦП снизится (или если сетевая загрузка станет очень маленькой), то регулирование прерываний будет автоматически выключено."

#. type: Plain text
#: man-pages/man4/sk98lin.4:479
msgid ""
"Interrupt moderation should be used when the driver has to handle one or "
"more interfaces with a high network load, which\\(emas a "
"consequence\\(emleads also to a high CPU utilization.  When moderation is "
"applied in such high network load situations, CPU load might be reduced by "
"20-30% on slow computers."
msgstr "Регулирование прерываний должно использоваться, когда драйвер обрабатывает много трафика на одном или более интерфейсах, который, как следствие, также приводит большой нагрузке на ЦП. Применение регулирования при большой сетевой нагрузке на медленных компьютерах может понизить загрузку ЦП на 20-30%."

#. type: Plain text
#: man-pages/man4/sk98lin.4:483
msgid ""
"Note that the drawback of using interrupt moderation is an increase of the "
"round-trip-time (RTT), due to the queuing and serving of interrupts at "
"dedicated moderation times."
msgstr "Заметим, что отрицательной стороной регулирования прерываний является увеличение времени на передачу и подтверждение (round-trip-time, RTT), так как постановка в очередь и обслуживание прерываний происходит только через определённые интервалы."

#. type: TP
#: man-pages/man4/sk98lin.4:483
#, no-wrap
msgid "B<IntsPerSec=>I<i,j,...>"
msgstr "B<IntsPerSec=>I<i,j,...>"

#. type: Plain text
#: man-pages/man4/sk98lin.4:493
msgid ""
"This parameter determines the length of any interrupt moderation interval.  "
"Assuming that static interrupt moderation is to be used, an I<IntsPerSec> "
"parameter value of 2000 will lead to an interrupt moderation interval of 500"
" microseconds.  Possible values for this parameter are in the range of "
"30...40000 (interrupts per second).  The default value is 2000."
msgstr "Этот параметр определяет длительность любого интервала регулирования прерываний. Предполагая, что используется регулирование прерываний, при значении параметра I<IntsPerSec> равном 2000, получается интервал регулирования прерываний в 500 микросекунд. Возможные значения этого параметра находятся в диапазоне 30...40000 (прерываний в секунду). Значение по умолчанию равно 2000."

#. type: Plain text
#: man-pages/man4/sk98lin.4:497
msgid ""
"This parameter is used only if either static or dynamic interrupt moderation"
" is enabled on a network adapter card.  This parameter is ignored if no "
"moderation is applied."
msgstr "Этот параметр используется только, если для сетевого адаптера включено статическое или динамическое регулирование прерываний. Если регулирование не применяется, то параметр игнорируется."

#. type: Plain text
#: man-pages/man4/sk98lin.4:504
msgid ""
"Note that the duration of the moderation interval is to be chosen with care."
"  At first glance, selecting a very long duration (e.g., only 100 interrupts"
" per second) seems to be meaningful, but the increase of packet-processing "
"delay is tremendous.  On the other hand, selecting a very short moderation "
"time might compensate the use of any moderation being applied."
msgstr "Заметим, что длительность интервала регулирования прерываний нужно выбирать с осторожностью. На первый взгляд, выбор очень большой длительности (например, только 100 прерываний в секунду) кажется осмысленным, но это колоссально увеличит задержку в обработке. С другой стороны, выбор очень короткого интервала регулирования мог бы компенсировать использование любого применяемого регулирования."

#. type: TP
#: man-pages/man4/sk98lin.4:504
#, no-wrap
msgid "B<PrefPort=>I<i,j,...>"
msgstr "B<PrefPort=>I<i,j,...>"

#. type: Plain text
#: man-pages/man4/sk98lin.4:516
msgid ""
"This parameter is used to force the preferred port to A or B (on dual-port "
"network adapters).  The preferred port is the one that is used if both ports"
" A and B are detected as fully functional.  Possible values are: I<A> or "
"I<B>; I<A> is the default."
msgstr "Этот параметр используется для принудительного задания предпочтительного порта: A или B (на двухпортовых адаптерах). Предпочтительный порт будет использован когда оба порта, A и B, считаются полностью взаимозаменяемыми. Возможные значения: I<A> или I<B>; по умолчанию задано I<A>."

#. type: TP
#: man-pages/man4/sk98lin.4:516
#, no-wrap
msgid "B<RlmtMode=>I<i,j,...>"
msgstr "B<RlmtMode=>I<i,j,...>"

#. type: Plain text
#: man-pages/man4/sk98lin.4:532
msgid ""
"RLMT monitors the status of the port.  If the link of the active port fails,"
" RLMT switches immediately to the standby link.  The virtual link is "
"maintained as long as at least one \"physical\" link is up.  This parameters"
" states how RLMT should monitor both ports.  Possible values are: "
"I<CheckLinkState>, I<CheckLocalPort>, I<CheckSeg>, or I<DualNet>; "
"I<CheckLinkState> is the default.  The different modes have the following "
"meaning:"
msgstr "RLMT-слежение за состоянием порта. Если связь на активном порту пропадает, то RLMT сразу переключает работу на резервную связь. Виртуальная связь поддерживается так долго, пока есть не менее одной работающей «физической» связи. Этот параметр определяет как RLMT должен отслеживать состояние портов. Возможные значения: I<CheckLinkState>, I<CheckLocalPort>, I<CheckSeg> или I<DualNet>; по умолчанию задано I<CheckLinkState>. Назначение режимов:"

#. type: Plain text
#: man-pages/man4/sk98lin.4:537
msgid ""
"I<CheckLinkState> Check link state only: RLMT uses the link state reported "
"by the adapter hardware for each individual port to determine whether a port"
" can be used for all network traffic or not."
msgstr "I<CheckLinkState> Проверять только состояние связи: RLMT использует состояние связи, сообщаемое аппаратурой адаптера для каждого порта, для определения, можно ли использовать порт для передачи данных в сеть или нет."

#. type: Plain text
#: man-pages/man4/sk98lin.4:545
msgid ""
"I<CheckLocalPort> In this mode, RLMT monitors the network path between the "
"two ports of an adapter by regularly exchanging packets between them.  This "
"mode requires a network configuration in which the two ports are able to "
"\"see\" each other (i.e., there must not be any router between the ports)."
msgstr "I<CheckLocalPort> В этом режиме RLMT отслеживает сетевой путь между двумя портами адаптера, периодически пересылая пакеты между ними. Для работы этого режима требуется настройка сети, при которой два порта смогли бы \"видеть\" друг друга (то есть, между ними не должно быть маршрутизатора)."

#. type: Plain text
#: man-pages/man4/sk98lin.4:554
msgid ""
"I<CheckSeg> Check local port and segmentation: This mode supports the same "
"functions as the CheckLocalPort mode and additionally checks network "
"segmentation between the ports.  Therefore, this mode is to be used only if "
"Gigabit Ethernet switches are installed on the network that have been "
"configured to use the Spanning Tree protocol."
msgstr "I<CheckSeg> Проверять локальный порт и сегментирование: Этот режим поддерживает те же функции что и CheckLocalPort и вдобавок проверяет сегментирование сети между портами. Поэтому этот режим может использоваться только, если в сети установлены коммутаторы Gigabit Ethernet, на которых  настроен протокол Spanning Tree."

#. type: Plain text
#: man-pages/man4/sk98lin.4:565
msgid ""
"I<DualNet> In this mode, ports A and B are used as separate devices.  If you"
" have a dual port adapter, port A will be configured as I<eth[x]> and port B"
" as I<eth[x+1]>.  Both ports can be used independently with distinct IP "
"addresses.  The preferred port setting is not used.  RLMT is turned off."
msgstr "I<DualNet> В этом режиме порты A и B используются как раздельные устройства. Если у вас адаптер с двумя портами, то порт A будет настроен как I<eth[x]>, а порт B как I<eth[x+1]>. Оба порта можно использовать независимо с различающимися IP-адресами. Настройка выбора предпочтительного порта не используется. RLMT выключено."

#. type: Plain text
#: man-pages/man4/sk98lin.4:574
msgid ""
"Note that RLMT modes I<CheckLocalPort> and I<CheckLinkState> are designed to"
" operate in configurations where a network path between the ports on one "
"adapter exists.  Moreover, they are not designed to work where adapters are "
"connected back-to-back."
msgstr "Заметим, что RLMT-режимы I<CheckLocalPort> и I<CheckLinkState> предназначены для работы в условиях, где сетевой путь между портами существует на одном адаптере. Более того, они не работают, если адаптеры соединены друг с другом."

#. type: SH
#: man-pages/man4/sk98lin.4:574
#, no-wrap
msgid "FILES"
msgstr "ФАЙЛЫ"

#. type: TP
#: man-pages/man4/sk98lin.4:575
#, no-wrap
msgid "I</proc/net/sk98lin/eth[x]>"
msgstr "I</proc/net/sk98lin/eth[x]>"

#. type: Plain text
#: man-pages/man4/sk98lin.4:581
msgid ""
"The statistics file of a particular interface of an adapter card.  It "
"contains generic information about the adapter card plus a detailed summary "
"of all transmit and receive counters."
msgstr "Файлы статистики для определённого интерфейса адаптера. Содержит общую информацию о карте адаптера и подробную сводку по всем счётчикам передачи и приёма."

#. type: TP
#: man-pages/man4/sk98lin.4:581
#, no-wrap
msgid "I</usr/src/linux/Documentation/networking/sk98lin.txt>"
msgstr "I</usr/src/linux/Documentation/networking/sk98lin.txt>"

#. type: Plain text
#: man-pages/man4/sk98lin.4:592
msgid ""
"This is the I<README> file of the I<sk98lin> driver.  It contains a detailed"
" installation HOWTO and describes all parameters of the driver.  It denotes "
"also common problems and provides the solution to them."
msgstr "Это файл I<README> от драйвера I<sk98lin>. В нём содержится подробная инструкция по установке и описание всех параметров драйвера. Также отмечены общие проблемы и их решения."

#. type: SH
#: man-pages/man4/sk98lin.4:592
#, no-wrap
msgid "BUGS"
msgstr "ДЕФЕКТЫ"

#.  .SH AUTHORS
#.  Ralph Roesler \(em rroesler@syskonnect.de
#.  .br
#.  Mirko Lindner \(em mlindner@syskonnect.de
#. type: Plain text
#: man-pages/man4/sk98lin.4:598
msgid "Report any bugs to linux@syskonnect.de"
msgstr "О дефектах сообщайте по адресу: linux@syskonnect.de"

#. type: SH
#: man-pages/man4/sk98lin.4:598
#, no-wrap
msgid "SEE ALSO"
msgstr "СМОТРИТЕ ТАКЖЕ"

#. type: Plain text
#: man-pages/man4/sk98lin.4:601
msgid "B<ifconfig>(8), B<insmod>(8), B<modprobe>(8)"
msgstr "B<ifconfig>(8), B<insmod>(8), B<modprobe>(8)"

#. type: TH
#: man-pages/man4/st.4:25
#, no-wrap
msgid "ST"
msgstr "ST"

#. type: TH
#: man-pages/man4/st.4:25
#, no-wrap
msgid "2010-09-04"
msgstr "2010-09-04"

#. type: Plain text
#: man-pages/man4/st.4:28
msgid "st - SCSI tape device"
msgstr "st - ленточный накопитель SCSI"

#. type: Plain text
#: man-pages/man4/st.4:31
#, no-wrap
msgid "B<#include E<lt>sys/mtio.hE<gt>>\n"
msgstr "B<#include E<lt>sys/mtio.hE<gt>>\n"

#. type: Plain text
#: man-pages/man4/st.4:36
#, no-wrap
msgid ""
"B<int ioctl(int >I<fd>B<, int >I<request>B< [, (void *)>I<arg3>B<]);>\n"
"B<int ioctl(int >I<fd>B<, MTIOCTOP, (struct mtop *)>I<mt_cmd>B<);>\n"
"B<int ioctl(int >I<fd>B<, MTIOCGET, (struct mtget *)>I<mt_status>B<);>\n"
"B<int ioctl(int >I<fd>B<, MTIOCPOS, (struct mtpos *)>I<mt_pos>B<);>\n"
msgstr "B<int ioctl(int >I<fd>B<, int >I<request>B< [, (void *)>I<arg3>B<]);>\nB<int ioctl(int >I<fd>B<, MTIOCTOP, (struct mtop *)>I<mt_cmd>B<);>\nB<int ioctl(int >I<fd>B<, MTIOCGET, (struct mtget *)>I<mt_status>B<);>\nB<int ioctl(int >I<fd>B<, MTIOCPOS, (struct mtpos *)>I<mt_pos>B<);>\n"

#. type: Plain text
#: man-pages/man4/st.4:46
msgid ""
"The B<st> driver provides the interface to a variety of SCSI tape devices.  "
"Currently, the driver takes control of all detected devices of type "
"\\(lqsequential-access\\(rq.  The B<st> driver uses major device number 9."
msgstr "Драйвер B<st> предоставляет интерфейс к различным ленточным накопителям SCSI. В настоящее время драйвер позволяет управлять любыми устройствами \"последовательного доступа\". Драйвер B<st> использует для устройств старший номер 9."

#. type: Plain text
#: man-pages/man4/st.4:66
msgid ""
"Each device uses eight minor device numbers.  The lowermost five bits in the"
" minor numbers are assigned sequentially in the order of detection.  In the "
"2.6 kernel, the bits above the eight lowermost bits are concatenated to the "
"five lowermost bits to form the tape number.  The minor numbers can be "
"grouped into two sets of four numbers: the principal (auto-rewind) minor "
"device numbers, I<n>, and the \\(lqno-rewind\\(rq device numbers, (I<n> + "
"128).  Devices opened using the principal device number will be sent a "
"B<REWIND> command when they are closed.  Devices opened using the \\(lqno-"
"rewind\\(rq device number will not.  (Note that using an auto-rewind device "
"for positioning the tape with, for instance, mt does not lead to the desired"
" result: the tape is rewound after the mt command and the next command "
"starts from the beginning of the tape)."
msgstr "Для каждого устройства есть восемь младших номеров. Первые пять битов в младших номерах определяют последовательность обнаружения. В ядрах 2.6 первые восемь битов объединяются с первыми пятью битами для создания номера ленты. Младшие номера могут быть сгруппированы в два набора из четырех чисел: основные младшие номера для устройств (I<n>) с автоперемоткой и номера устройств без автоперемотки (I<n> + 128). При открытии устройства с основным младшим номером, будет послана команда B<REWIND>. При открытии с использованием устройства без автоперемотки этого произведено не будет. (Заметим, что использование устройства с автоперемоткой для установки ленты в определённое положение, например, mt, не даст желаемого результата: лента перемотается после команды mt, и следующая команда будет выполняться с начала ленты)."

#. type: Plain text
#: man-pages/man4/st.4:80
msgid ""
"Within each group, four minor numbers are available to define devices with "
"different characteristics (block size, compression, density, etc.)  When the"
" system starts up, only the first device is available.  The other three are "
"activated when the default characteristics are defined (see below).  (By "
"changing compile-time constants, it is possible to change the balance "
"between the maximum number of tape drives and the number of minor numbers "
"for each drive.  The default allocation allows control of 32 tape drives.  "
"For instance, it is possible to control up to 64 tape drives with two minor "
"numbers for different options.)"
msgstr "В каждой группе четыре младших номера доступны для определения устройств с особыми характеристиками (такими как: размер блока, сжатие, плотность и другое). Когда система запускается, доступно только первое устройство. Другие три приводятся в действие, когда определены некоторые их характеристики (смотрите ниже). Путем изменения константы при компиляции возможно изменение баланса между максимальным числом ленточных накопителей и числом из младших номеров каждого накопителя. Начальное значение позволяет контролировать 32 ленточных устройства. Например, возможно контролировать до 64-х ленточных устройств с двумя младшими номерами для различных параметров."

#. type: Plain text
#: man-pages/man4/st.4:82
msgid "Devices are typically created by:"
msgstr "Устройства обычно создаются так:"

#. type: Plain text
#: man-pages/man4/st.4:93
#, no-wrap
msgid ""
"mknod -m 666 /dev/st0 c 9 0\n"
"mknod -m 666 /dev/st0l c 9 32\n"
"mknod -m 666 /dev/st0m c 9 64\n"
"mknod -m 666 /dev/st0a c 9 96\n"
"mknod -m 666 /dev/nst0 c 9 128\n"
"mknod -m 666 /dev/nst0l c 9 160\n"
"mknod -m 666 /dev/nst0m c 9 192\n"
"mknod -m 666 /dev/nst0a c 9 224\n"
msgstr "mknod -m 666 /dev/st0 c 9 0\nmknod -m 666 /dev/st0l c 9 32\nmknod -m 666 /dev/st0m c 9 64\nmknod -m 666 /dev/st0a c 9 96\nmknod -m 666 /dev/nst0 c 9 128\nmknod -m 666 /dev/nst0l c 9 160\nmknod -m 666 /dev/nst0m c 9 192\nmknod -m 666 /dev/nst0a c 9 224\n"

#. type: Plain text
#: man-pages/man4/st.4:97
msgid "There is no corresponding block device."
msgstr "Соответствующее блочное устройство отсутствует."

#. type: Plain text
#: man-pages/man4/st.4:112
msgid ""
"The driver uses an internal buffer that has to be large enough to hold at "
"least one tape block.  In kernels before 2.1.121, the buffer is allocated as"
" one contiguous block.  This limits the block size to the largest contiguous"
" block of memory the kernel allocator can provide.  The limit is currently "
"128 kB for 32-bit architectures and 256 kB for 64-bit architectures.  In "
"newer kernels the driver allocates the buffer in several parts if necessary."
"  By default, the maximum number of parts is 16.  This means that the "
"maximum block size is very large (2 MB if allocation of 16 blocks of 128 kB "
"succeeds)."
msgstr "Драйвер использует внутренний буфер, которого достаточно для сохранения, как минимум, одного блока ленты. В ядре до версии 2.1.121 буфер выделялся как один непрерывный блок. Это ограничивало размер блока самым большим непрерывным участком памяти, которое может выделить ядро. Ограничение в настоящее время составляет: 128 Кбайт для 32-битной и 256 Кбайт для 64-битной архитектуры. В новейших ядрах драйвер располагает буфер в нескольких частях, если это необходимо. По умолчанию максимальное число частей \\(em 16. Таким способом можно сделать максимальный размер блока очень большим (2МБ, если выделяется 16 блоков по 128 Кбайт)."

#. type: Plain text
#: man-pages/man4/st.4:121
msgid ""
"The driver's internal buffer size is determined by a compile-time constant "
"which can be overridden with a kernel startup option.  In addition to this, "
"the driver tries to allocate a larger temporary buffer at run time if "
"necessary.  However, run-time allocation of large contiguous blocks of "
"memory may fail and it is advisable not to rely too much on dynamic buffer "
"allocation with kernels older than 2.1.121 (this applies also to demand-"
"loading the driver with kerneld or kmod)."
msgstr "Размер внутреннего буфера драйвера определяется константой при сборке; эта константа может быть изменена при загрузке ядра. Вдобавок к этому, драйвер пытается разместить больший временный буфер во время запуска, если это необходимо. Тем не менее, размещение во время запуска больших блоков памяти может завершиться неудачно, и лучше не полагаться на динамическое размещение буфера в ядре до версии 2.1.121 (это применяется также при загрузке драйвера по требованию с помощью kerneld или kmod)."

#. type: Plain text
#: man-pages/man4/st.4:134
msgid ""
"The driver does not specifically support any tape drive brand or model.  "
"After system start-up the tape device options are defined by the drive "
"firmware.  For example, if the drive firmware selects fixed-block mode, the "
"tape device uses fixed-block mode.  The options can be changed with explicit"
" B<ioctl>(2)  calls and remain in effect when the device is closed and "
"reopened.  Setting the options affects both the auto-rewind and the "
"nonrewind device."
msgstr "В драйвере нет специальной поддержки для устройств определённых производителей или моделей. После старта системы параметры ленточного устройства определяются микропрограммой устройства. Для примера, если микропрограмма выбирает режим с блоками одинакового размера, то ленточное устройство использует этот режим. Параметры могут быть изменены вызовами B<ioctl>(2) и действуют до тех пор, пока устройство не закрыто и потом не открыто вновь. Установка параметров влияет на оба устройства (с автоперемоткой и без автоперемотки)."

#. type: Plain text
#: man-pages/man4/st.4:143
msgid ""
"Different options can be specified for the different devices within the "
"subgroup of four.  The options take effect when the device is opened.  For "
"example, the system administrator can define one device that writes in "
"fixed-block mode with a certain block size, and one which writes in "
"variable-block mode (if the drive supports both modes)."
msgstr "Внутри подгруппы четырёх устройств для каждого могут быть заданы особые параметры. Параметры начинают работать, когда устройство открывается. Для примера, системный администратор может определить одно устройство, которое записывает данные в режиме блоков одинакового размера с задаваемым размером и другое, которое записывает данные в режиме блоков с разным размером (если накопитель поддерживает оба режима)."

#. type: Plain text
#: man-pages/man4/st.4:166
msgid ""
"The driver supports B<tape partitions> if they are supported by the drive.  "
"(Note that the tape partitions have nothing to do with disk partitions.  A "
"partitioned tape can be seen as several logical tapes within one medium.)  "
"Partition support has to be enabled with an B<ioctl>(2).  The tape location "
"is preserved within each partition across partition changes.  The partition "
"used for subsequent tape operations is selected with an B<ioctl>(2).  The "
"partition switch is executed together with the next tape operation in order "
"to avoid unnecessary tape movement.  The maximum number of partitions on a "
"tape is defined by a compile-time constant (originally four).  The driver "
"contains an B<ioctl>(2)  that can format a tape with either one or two "
"partitions."
msgstr "Драйвер поддерживает B<ленточные разделы>, но только если их поддерживает само устройство. Заметим, что ленточные разделы не имеют ничего общего с разделами диска. Размеченная лента одного носителя может выглядеть как несколько логических лент. Поддержка разделов включается с помощью B<ioctl>(2). Местоположение ленты зафиксировано внутри каждого раздела. При последующих ленточных операциях используется нужный раздел, выбранный с помощью B<ioctl>(2). Переключение раздела выполняется вместе со следующей операцией с лентой во избежании ненужной перемотки. Максимальное число разделов на ленте определяется константой при компиляции (изначально оно равно четырём). Драйвер содержит вызов B<ioctl>(2), который позволяет форматировать ленту с одним или двумя разделами."

#. type: Plain text
#: man-pages/man4/st.4:171
msgid ""
"Device I</dev/tape> is usually created as a hard or soft link to the default"
" tape device on the system."
msgstr "Обычно, в системе создаётся устройство I</dev/tape> в виде жёсткой или символьной ссылки на ленточное устройство по умолчанию."

#. type: Plain text
#: man-pages/man4/st.4:175
msgid ""
"Starting from kernel 2.6.2, the driver exports in the sysfs directory "
"I</sys/class/scsi_tape> the attached devices and some parameters assigned to"
" the devices."
msgstr "Начиная с ядра 2.6.2, драйвер экспортирует в каталог sysfs в файл I</sys/class/scsi_tape> подключённые устройства и некоторые их параметры."

#. type: SS
#: man-pages/man4/st.4:175
#, no-wrap
msgid "Data transfer"
msgstr "Передача данных"

#. type: Plain text
#: man-pages/man4/st.4:188
msgid ""
"The driver supports operation in both fixed-block mode and variable-block "
"mode (if supported by the drive).  In fixed-block mode the drive writes "
"blocks of the specified size and the block size is not dependent on the byte"
" counts of the write system calls.  In variable-block mode one tape block is"
" written for each write call and the byte count determines the size of the "
"corresponding tape block.  Note that the blocks on the tape don't contain "
"any information about the writing mode: when reading, the only important "
"thing is to use commands that accept the block sizes on the tape."
msgstr "Драйвер поддерживает операции в обоих режимах: с постоянным и переменным размером блоков (только если оба режима поддерживает само устройство). В режиме с постоянным размером блока устройство выполняет запись блоками заданного размера, и размер блока не зависит от количества байтов, которые записываются системными вызовами. В режиме с переменным размером блока один блок ленты записывается при каждом вызове записи, и размер соответствующего блока ленты определяется в соответствии с количеством записываемых байт. Заметим, что блоки ленты не содержат информации о режиме записи: при чтении единственно важной вещью является использование нужных команд, которые принимают размеры блоков ленты."

#. type: Plain text
#: man-pages/man4/st.4:197
msgid ""
"In variable-block mode the read byte count does not have to match the tape "
"block size exactly.  If the byte count is larger than the next block on "
"tape, the driver returns the data and the function returns the actual block "
"size.  If the block size is larger than the byte count, the requested amount"
" of data from the start of the block is returned and the rest of the block "
"is discarded."
msgstr "В режиме с переменным размером блока при чтении количество байтов не совпадает точно с размером блока ленты. Если количество байтов больше, чем в следующем блоке ленты, драйвер возвращает данные, а функция возвращает реальный размер блока. Если размер блока больше, чем количество байтов, то возвращается только запрашиваемое количество данных с начала блока, а остаток блока отбрасывается."

#. type: Plain text
#: man-pages/man4/st.4:206
msgid ""
"In fixed-block mode the read byte counts can be arbitrary if buffering is "
"enabled, or a multiple of the tape block size if buffering is disabled.  "
"Kernels before 2.1.121 allow writes with arbitrary byte count if buffering "
"is enabled.  In all other cases (kernel before 2.1.121 with buffering "
"disabled or newer kernel) the write byte count must be a multiple of the "
"tape block size."
msgstr "При чтении в режиме с постоянным размером блока количества байтов может быть произвольным, если включена буферизация, или пропорциональным размеру блока ленты, если буферизация выключена. Ядра версий до 2.1.121, позволяли записывать произвольное количество байтов, если включена буферизация. Во всех других случаях (ядра до 2.1.121 с выключенной буферизацией и новые ядра) количество байтов должно быть пропорциональным размеру блока ленты."

#. type: Plain text
#: man-pages/man4/st.4:215
msgid ""
"In the 2.6 kernel, the driver tries to use direct transfers between the user"
" buffer and the device.  If this is not possible, the driver's internal "
"buffer is used.  The reasons for not using direct transfers include improper"
" alignment of the user buffer (default is 512 bytes but this can be changed "
"by the HBA driver), one or more pages of the user buffer not reachable by "
"the SCSI adapter, and so on."
msgstr "В ядрах 2.6 драйвер пытается использовать прямую пересылку между пользовательским буфером и устройством. Если это невозможно, то используется внутренний буфер драйвера. Причинами отказа от использования прямой пересылки может быть включение неправильного выравнивания пользовательского буфера (по умолчанию 512 байт, но может быть изменено драйвером HBA), одна или более страниц пользовательского буфера недостижима из адаптера SCSI и т. п."

#. type: Plain text
#: man-pages/man4/st.4:218
msgid ""
"A filemark is automatically written to tape if the last tape operation "
"before close was a write."
msgstr "Маркер файла автоматически записывается на ленту, если последней операцией до закрытия была запись."

#. type: Plain text
#: man-pages/man4/st.4:230
msgid ""
"When a filemark is encountered while reading, the following happens.  If "
"there are data remaining in the buffer when the filemark is found, the "
"buffered data is returned.  The next read returns zero bytes.  The following"
" read returns data from the next file.  The end of recorded data is signaled"
" by returning zero bytes for two consecutive read calls.  The third read "
"returns an error."
msgstr "Когда при чтении обнаруживается маркер файла, происходит следующее. Если при обнаружении маркера есть данные в буфере, то возвращаются данные буфера. Следующее чтение вернёт ноль байтов. Затем вернёт данные из следующего файла. О конце записанных данных будет сообщено возвращением нуля байтов в двух операциях чтения подряд. И, наконец, третье чтение вернёт ошибку."

#. type: SS
#: man-pages/man4/st.4:230
#, no-wrap
msgid "Ioctls"
msgstr "Вызовы ioctl"

#. type: Plain text
#: man-pages/man4/st.4:241
msgid ""
"The driver supports three B<ioctl>(2)  requests.  Requests not recognized by"
" the B<st> driver are passed to the B<SCSI> driver.  The definitions below "
"are from I</usr/include/linux/mtio.h>:"
msgstr "Драйвер поддерживает три запроса B<ioctl>(2). Запросы, не опознанные драйвером B<st>, пропускаются в драйвер B<SCSI>. Определения, приведённые далее, взяты из I</usr/include/linux/mtio.h>:"

#. type: SS
#: man-pages/man4/st.4:241
#, no-wrap
msgid "MTIOCTOP \\(em perform a tape operation"
msgstr "MTIOCTOP \\(em выполнение операций с лентой"

#. type: Plain text
#: man-pages/man4/st.4:249
msgid ""
"This request takes an argument of type I<(struct mtop\\ *)>.  Not all drives"
" support all operations.  The driver returns an B<EIO> error if the drive "
"rejects an operation."
msgstr "Для этого запроса требуется аргумент с типом I<(struct mtop\\ *)>. Не все устройства поддерживает все операции. Драйвер возвращает ошибку B<EIO>, если устройство не выполнило операцию."

#. type: Plain text
#: man-pages/man4/st.4:257
#, no-wrap
msgid ""
"/* Structure for MTIOCTOP - mag tape op command: */\n"
"struct mtop {\n"
"    short   mt_op;       /* operations defined below */\n"
"    int     mt_count;    /* how many of them */\n"
"};\n"
msgstr "/* Структура для MTIOCTOP - операция с маг. лентой */\nstruct mtop {\n    short   mt_op;       /* операции перечислены далее */\n    int     mt_count;    /* их количество */\n};\n"

#. type: Plain text
#: man-pages/man4/st.4:261
msgid "Magnetic Tape operations for normal tape use:"
msgstr "Операции с магнитной лентой для обычного использования:"

#. type: TP
#: man-pages/man4/st.4:261
#, no-wrap
msgid "B<MTBSF>"
msgstr "B<MTBSF>"

#. type: Plain text
#: man-pages/man4/st.4:266
msgid "Backward space over I<mt_count> filemarks."
msgstr "Перемотка ленты на I<mt_count> файловых маркеров назад."

#. type: TP
#: man-pages/man4/st.4:266
#, no-wrap
msgid "B<MTBSFM>"
msgstr "B<MTBSFM>"

#. type: Plain text
#: man-pages/man4/st.4:272
msgid ""
"Backward space over I<mt_count> filemarks.  Reposition the tape to the EOT "
"side of the last filemark."
msgstr "Перемотка ленты на I<mt_count> файловых маркеров назад. Перемотка ленты на сторону EOT последнего маркера файла."

#. type: TP
#: man-pages/man4/st.4:272
#, no-wrap
msgid "B<MTBSR>"
msgstr "B<MTBSR>"

#. type: Plain text
#: man-pages/man4/st.4:277
msgid "Backward space over I<mt_count> records (tape blocks)."
msgstr "Перемотка ленты на I<mt_count> записей назад (блоков ленты)."

#. type: TP
#: man-pages/man4/st.4:277
#, no-wrap
msgid "B<MTBSS>"
msgstr "B<MTBSS>"

#. type: Plain text
#: man-pages/man4/st.4:282
msgid "Backward space over I<mt_count> setmarks."
msgstr "Перемотка ленты на I<mt_count> сборочных маркеров (setmarks) назад."

#. type: TP
#: man-pages/man4/st.4:282
#, no-wrap
msgid "B<MTCOMPRESSION>"
msgstr "B<MTCOMPRESSION>"

#. type: Plain text
#: man-pages/man4/st.4:290
msgid ""
"Enable compression of tape data within the drive if I<mt_count> is nonzero "
"and disable compression if I<mt_count> is zero.  This command uses the MODE "
"page 15 supported by most DATs."
msgstr "Включение режима сжатия данных на ленте устройства, если I<mt_count> не равно 0, и отключение сжатия, если I<mt_count> равно 0. Эта команда использует MODE page 15, поддерживаемую многими DAT-устройствами."

#. type: TP
#: man-pages/man4/st.4:290
#, no-wrap
msgid "B<MTEOM>"
msgstr "B<MTEOM>"

#. type: Plain text
#: man-pages/man4/st.4:293
msgid "Go to the end of the recorded media (for appending files)."
msgstr "Переход в конец записанных на носителе данных (для добавления файлов)."

#. type: TP
#: man-pages/man4/st.4:293
#, no-wrap
msgid "B<MTERASE>"
msgstr "B<MTERASE>"

#. type: Plain text
#: man-pages/man4/st.4:299
msgid ""
"Erase tape.  With 2.6 kernel, short erase (mark tape empty) is performed if "
"the argument is zero.  Otherwise, long erase (erase all) is done."
msgstr "Стирание ленты. В ядре 2.6 выполняется быстрое стирание (удаление маркера ленты), если аргумент равен 0. В противном случае выполняется полное стирание."

#. type: TP
#: man-pages/man4/st.4:299
#, no-wrap
msgid "B<MTFSF>"
msgstr "B<MTFSF>"

#. type: Plain text
#: man-pages/man4/st.4:304
msgid "Forward space over I<mt_count> filemarks."
msgstr "Перемотка ленты на I<mt_count> файловых маркеров вперёд."

#. type: TP
#: man-pages/man4/st.4:304
#, no-wrap
msgid "B<MTFSFM>"
msgstr "B<MTFSFM>"

#. type: Plain text
#: man-pages/man4/st.4:310
msgid ""
"Forward space over I<mt_count> filemarks.  Reposition the tape to the BOT "
"side of the last filemark."
msgstr "Перемотка ленты на I<mt_count> файловых маркеров вперёд. Перемотка ленты на сторону BOT последнего маркера файла."

#. type: TP
#: man-pages/man4/st.4:310
#, no-wrap
msgid "B<MTFSR>"
msgstr "B<MTFSR>"

#. type: Plain text
#: man-pages/man4/st.4:315
msgid "Forward space over I<mt_count> records (tape blocks)."
msgstr "Перемотка ленты на I<mt_count> записей вперёд (блоков ленты)."

#. type: TP
#: man-pages/man4/st.4:315
#, no-wrap
msgid "B<MTFSS>"
msgstr "B<MTFSS>"

#. type: Plain text
#: man-pages/man4/st.4:320
msgid "Forward space over I<mt_count> setmarks."
msgstr "Перемотка ленты на I<mt_count> сборочных маркеров вперёд."

#. type: TP
#: man-pages/man4/st.4:320
#, no-wrap
msgid "B<MTLOAD>"
msgstr "B<MTLOAD>"

#. type: Plain text
#: man-pages/man4/st.4:331
msgid ""
"Execute the SCSI load command.  A special case is available for some HP "
"autoloaders.  If I<mt_count> is the constant B<MT_ST_HPLOADER_OFFSET> plus a"
" number, the number is sent to the drive to control the autoloader."
msgstr "Выполнение SCSI-команды загрузки. Для некоторых автозагрузчиков HP выполняется особое действие. Если I<mt_count> равно константе B<MT_ST_HPLOADER_OFFSET> плюс  некоторое число, то это значение передаётся устройству для управления автозагрузчиком."

#. type: TP
#: man-pages/man4/st.4:331
#, no-wrap
msgid "B<MTLOCK>"
msgstr "B<MTLOCK>"

#. type: Plain text
#: man-pages/man4/st.4:334
msgid "Lock the tape drive door."
msgstr "Блокирование дверцы ленточного устройства."

#. type: TP
#: man-pages/man4/st.4:334
#, no-wrap
msgid "B<MTMKPART>"
msgstr "B<MTMKPART>"

#. type: Plain text
#: man-pages/man4/st.4:348
msgid ""
"Format the tape into one or two partitions.  If I<mt_count> is nonzero, it "
"gives the size of the first partition and the second partition contains the "
"rest of the tape.  If I<mt_count> is zero, the tape is formatted into one "
"partition.  This command is not allowed for a drive unless the partition "
"support is enabled for the drive (see B<MT_ST_CAN_PARTITIONS> below)."
msgstr "Форматирование ленты на один или два раздела. Если I<mt_count> не равно 0, то оно определяет размер первого раздела, а второй раздел займёт остаток ленты. Если I<mt_count> равно 0, то лента форматируется с одним разделом. Эта команда запрещена для устройств, не поддерживающих разделы (см. B<MT_ST_CAN_PARTITIONS> далее)."

#. type: TP
#: man-pages/man4/st.4:348
#, no-wrap
msgid "B<MTNOP>"
msgstr "B<MTNOP>"

#. type: Plain text
#: man-pages/man4/st.4:353
msgid ""
"No op\\(emflushes the driver's buffer as a side effect.  Should be used "
"before reading status with B<MTIOCGET>."
msgstr "Нет операции, как побочный эффект — сброс буфера устройства. Операция должна выполняться до чтения состояния с помощью B<MTIOCGET>."

#. type: TP
#: man-pages/man4/st.4:353
#, no-wrap
msgid "B<MTOFFL>"
msgstr "B<MTOFFL>"

#. type: Plain text
#: man-pages/man4/st.4:356
msgid "Rewind and put the drive off line."
msgstr "Перемотка ленты и отключение устройства."

#. type: TP
#: man-pages/man4/st.4:356
#, no-wrap
msgid "B<MTRESET>"
msgstr "B<MTRESET>"

#. type: Plain text
#: man-pages/man4/st.4:359
msgid "Reset drive."
msgstr "Возврат устройства в исходное состояние."

#. type: TP
#: man-pages/man4/st.4:359
#, no-wrap
msgid "B<MTRETEN>"
msgstr "B<MTRETEN>"

#. type: Plain text
#: man-pages/man4/st.4:362
msgid "Re-tension tape."
msgstr "Подтягивание ленты."

#. type: TP
#: man-pages/man4/st.4:362
#, no-wrap
msgid "B<MTREW>"
msgstr "B<MTREW>"

#. type: Plain text
#: man-pages/man4/st.4:365
msgid "Rewind."
msgstr "Перемотка ленты назад."

#. type: TP
#: man-pages/man4/st.4:365
#, no-wrap
msgid "B<MTSEEK>"
msgstr "B<MTSEEK>"

#. type: Plain text
#: man-pages/man4/st.4:377
msgid ""
"Seek to the tape block number specified in I<mt_count>.  This operation "
"requires either a SCSI-2 drive that supports the B<LOCATE> command (device-"
"specific address)  or a Tandberg-compatible SCSI-1 drive (Tandberg, Archive "
"Viper, Wangtek, ...).  The block number should be one that was previously "
"returned by B<MTIOCPOS> if device-specific addresses are used."
msgstr "Переход к блоку ленты с номером I<mt_count>. Эта операция требует устройства SCSI-2, поддерживающего команду B<LOCATE> (адрес, определяемый устройством),  или Tandberg-совместимого устройства SCSI-1 (Tandberg, Archive Viper, Wangtek, ... ). Номер блока должен быть равен значению, которое было получено ранее с помощью B<MTIOCPOS>, если используется адрес, определяемый устройством."

#. type: TP
#: man-pages/man4/st.4:377
#, no-wrap
msgid "B<MTSETBLK>"
msgstr "B<MTSETBLK>"

#. type: Plain text
#: man-pages/man4/st.4:382
msgid ""
"Set the drive's block length to the value specified in I<mt_count>.  A block"
" length of zero sets the drive to variable block size mode."
msgstr "Задание размера блока устройства равному I<mt_count>. Нулевое значение включает режим с переменным размером блоков."

#. type: TP
#: man-pages/man4/st.4:382
#, no-wrap
msgid "B<MTSETDENSITY>"
msgstr "B<MTSETDENSITY>"

#. type: Plain text
#: man-pages/man4/st.4:388
msgid ""
"Set the tape density to the code in I<mt_count>.  The density codes "
"supported by a drive can be found from the drive documentation."
msgstr "Задание плотности данных на ленте равной I<mt_count>. Коды плотности данных, поддерживаемые устройством, можно найти в документации к устройству."

#. type: TP
#: man-pages/man4/st.4:388
#, no-wrap
msgid "B<MTSETPART>"
msgstr "B<MTSETPART>"

#. type: Plain text
#: man-pages/man4/st.4:397
msgid ""
"The active partition is switched to I<mt_count>.  The partitions are "
"numbered from zero.  This command is not allowed for a drive unless the "
"partition support is enabled for the drive (see B<MT_ST_CAN_PARTITIONS> "
"below)."
msgstr "Переключение активного раздела на номер I<mt_count>. Разделы нумеруются начиная с нуля. Эта команда только для устройств с включённой поддержкой разделов (см. B<MT_ST_CAN_PARTITIONS> далее)."

#. type: TP
#: man-pages/man4/st.4:397
#, no-wrap
msgid "B<MTUNLOAD>"
msgstr "B<MTUNLOAD>"

#. type: Plain text
#: man-pages/man4/st.4:400
msgid "Execute the SCSI unload command (does not eject the tape)."
msgstr "Выполнение SCSI-команды выгрузки (но лента не выталкивается)."

#. type: TP
#: man-pages/man4/st.4:400
#, no-wrap
msgid "B<MTUNLOCK>"
msgstr "B<MTUNLOCK>"

#. type: Plain text
#: man-pages/man4/st.4:403
msgid "Unlock the tape drive door."
msgstr "Разблокирование дверцы ленточного устройства."

#. type: TP
#: man-pages/man4/st.4:403
#, no-wrap
msgid "B<MTWEOF>"
msgstr "B<MTWEOF>"

#. type: Plain text
#: man-pages/man4/st.4:408
msgid "Write I<mt_count> filemarks."
msgstr "Запись I<mt_count> маркеров файлов."

#. type: TP
#: man-pages/man4/st.4:408
#, no-wrap
msgid "B<MTWSM>"
msgstr "B<MTWSM>"

#. type: Plain text
#: man-pages/man4/st.4:413
msgid "Write I<mt_count> setmarks."
msgstr "Запись I<mt_count> сборочных маркеров."

#. type: Plain text
#: man-pages/man4/st.4:415
msgid ""
"Magnetic Tape operations for setting of device options (by the superuser):"
msgstr "Операции с магнитной лентой по установке параметров устройства (для суперпользователя):"

#. type: TP
#: man-pages/man4/st.4:415
#, no-wrap
msgid "B<MTSETDRVBUFFER>"
msgstr "B<MTSETDRVBUFFER>"

#. type: Plain text
#: man-pages/man4/st.4:424
msgid ""
"Set various drive and driver options according to bits encoded in "
"I<mt_count>.  These consist of the drive's buffering mode, a set of Boolean "
"driver options, the buffer write threshold, defaults for the block size and "
"density, and timeouts (only in kernels 2.1 and later).  A single operation "
"can affect only one item in the list above (the Booleans counted as one "
"item.)"
msgstr "Установка различных параметров устройства и драйвера согласно битам I<mt_count>. Задаётся режим буферизации устройства, набор логических параметров драйвера, порог буфера записи, значения по умолчанию для размера блока, плотности и время ожидания (только для ядра версии 2.1 или более поздних). Одна операция может присваивать значение только одного пункта из списка выше (логические параметры считаются за одну)."

#. type: Plain text
#: man-pages/man4/st.4:428
msgid ""
"A value having zeros in the high-order 4 bits will be used to set the "
"drive's buffering mode.  The buffering modes are:"
msgstr "Нулевое значение старших 4-х битов будет использовано для установки режима буферизации устройства. Режимы буферизации:"

#. type: IP
#: man-pages/man4/st.4:429
#, no-wrap
msgid "0"
msgstr "0"

#. type: Plain text
#: man-pages/man4/st.4:434
msgid ""
"The drive will not report B<GOOD> status on write commands until the data "
"blocks are actually written to the medium."
msgstr "Устройство не сообщит, что запись прошла успешно (B<GOOD>) до тех пор, пока блоки данных фактически не будут записаны на носитель."

#. type: IP
#: man-pages/man4/st.4:434
#, no-wrap
msgid "1"
msgstr "1"

#. type: Plain text
#: man-pages/man4/st.4:439
msgid ""
"The drive may report B<GOOD> status on write commands as soon as all the "
"data has been transferred to the drive's internal buffer."
msgstr "Устройство может сообщить, что запись прошла успешно после того, как все данные будут перемещены во внутренний буфер устройства."

#. type: IP
#: man-pages/man4/st.4:439
#, no-wrap
msgid "2"
msgstr "2"

#. type: Plain text
#: man-pages/man4/st.4:446
msgid ""
"The drive may report B<GOOD> status on write commands as soon as (a) all the"
" data has been transferred to the drive's internal buffer, and (b) all "
"buffered data from different initiators has been successfully written to the"
" medium."
msgstr "Устройство может сообщить, что запись прошла успешно после того, как: (а) все данные будут перемещены во внутренний буфер устройства и (б) все буферизованные данные из различных источников были успешно записаны на носитель."

#. type: Plain text
#: man-pages/man4/st.4:457
msgid ""
"To control the write threshold the value in I<mt_count> must include the "
"constant B<MT_ST_WRITE_THRESHOLD> bitwise ORed with a block count in the low"
" 28 bits.  The block count refers to 1024-byte blocks, not the physical "
"block size on the tape.  The threshold cannot exceed the driver's internal "
"buffer size (see DESCRIPTION, above)."
msgstr "Для контроля записи пороговое значение I<mt_count> должно включать в себя константу B<MT_ST_WRITE_THRESHOLD> побитно сложенную (OR) с счётчиком  блоков в первых 28-и битах. Счётчик блоков содержит количество блоков по 1024 байта, а не физических блоков на ленте. Пороговое значение не может превышать размер внутреннего буфера устройства. (см. ОПИСАНИЕ выше)."

#. type: Plain text
#: man-pages/man4/st.4:478
msgid ""
"To set and clear the Boolean options the value in I<mt_count> must include "
"one of the constants B<MT_ST_BOOLEANS>, B<MT_ST_SETBOOLEANS>, "
"B<MT_ST_CLEARBOOLEANS>, or B<MT_ST_DEFBOOLEANS> bitwise ORed with whatever "
"combination of the following options is desired.  Using B<MT_ST_BOOLEANS> "
"the options can be set to the values defined in the corresponding bits.  "
"With B<MT_ST_SETBOOLEANS> the options can be selectively set and with "
"B<MT_ST_DEFBOOLEANS> selectively cleared."
msgstr "Для установки и очистки логических параметров значение I<mt_count> должно включать в себя одну из констант: B<MT_ST_BOOLEANS>, B<MT_ST_SETBOOLEANS>, B<MT_ST_CLEARBOOLEANS>, B<MT_ST_DEFBOOLEANS>  или любую их побитно сложенную комбинацию. Используя параметры B<MT_ST_BOOLEANS> можно задать значения соответствующими битами. С помощью параметров B<MT_ST_SETBOOLEANS> можно выборочно установить, а с помощью B<MT_ST_DEFBOOLEANS> \\(em выборочно сбросить некоторые биты."

#. type: Plain text
#: man-pages/man4/st.4:486
msgid ""
"The default options for a tape device are set with B<MT_ST_DEFBOOLEANS>.  A "
"nonactive tape device (e.g., device with minor 32 or 160) is activated when "
"the default options for it are defined the first time.  An activated device "
"inherits from the device activated at start-up the options not set "
"explicitly."
msgstr "Параметры по умолчанию для ленточного устройства устанавливаются с помощью B<MT_ST_DEFBOOLEANS>. Неактивное ленточное устройство (например, устройство с младшим номером 32 или 160) активируется когда для него назначаются параметры по умолчанию в первый раз. Активированное устройство наследует параметры, которые не заданы явно, от устройства, активированного при загрузке ОС."

#. type: Plain text
#: man-pages/man4/st.4:488
msgid "The Boolean options are:"
msgstr "Логические параметры:"

#. type: TP
#: man-pages/man4/st.4:489
#, no-wrap
msgid "B<MT_ST_BUFFER_WRITES> (Default: true)"
msgstr "B<MT_ST_BUFFER_WRITES> (по умолчанию true)"

#. type: Plain text
#: man-pages/man4/st.4:495
msgid ""
"Buffer all write operations in fixed-block mode.  If this option is false "
"and the drive uses a fixed block size, then all write operations must be for"
" a multiple of the block size.  This option must be set false to write "
"reliable multivolume archives."
msgstr "Выполнять буферизацию чтения и опережающее чтение в режиме с постоянным размером блока. Если значение параметра равно false и устройство использует режим с постоянным размером блока, то во всех операциях чтения должны использоваться блоки кратной длины. Для надёжной записи многотомных архивов значение этого параметра должно быть равно false."

#. type: TP
#: man-pages/man4/st.4:495
#, no-wrap
msgid "B<MT_ST_ASYNC_WRITES> (Default: true)"
msgstr "B<MT_ST_ASYNC_WRITES> (по умолчанию true)"

#. type: Plain text
#: man-pages/man4/st.4:505
msgid ""
"When this option is true, write operations return immediately without "
"waiting for the data to be transferred to the drive if the data fits into "
"the driver's buffer.  The write threshold determines how full the buffer "
"must be before a new SCSI write command is issued.  Any errors reported by "
"the drive will be held until the next operation.  This option must be set "
"false to write reliable multivolume archives."
msgstr "Когда значение этого параметра равно true, то операции записи сразу завершаются, не дожидаясь пока данные переместятся в устройство, если данные помещаются в буфер драйвера. Порог записи определяет, насколько должен быть заполнен буфер до ввода новых SCSI-команд. Любые ошибки, возвращённые устройством, хранятся до следующей операции. Для надёжной записи многотомных архивов значение этого параметра должно быть равно false."

#. type: TP
#: man-pages/man4/st.4:505
#, no-wrap
msgid "B<MT_ST_READ_AHEAD> (Default: true)"
msgstr "B<MT_ST_READ_AHEAD> (по умолчанию true)"

#. type: Plain text
#: man-pages/man4/st.4:511
msgid ""
"This option causes the driver to provide read buffering and read-ahead in "
"fixed-block mode.  If this option is false and the drive uses a fixed block "
"size, then all read operations must be for a multiple of the block size."
msgstr "Этот параметр указывает драйверу выполнять буферизацию чтения и опережающее чтение в режиме с постоянным размером блока. Если значение параметра равно false и устройство использует режим с постоянным размером блока, то во всех операциях чтения должны использоваться блоки кратной длины."

#. type: TP
#: man-pages/man4/st.4:511
#, no-wrap
msgid "B<MT_ST_TWO_FM> (Default: false)"
msgstr "B<MT_ST_TWO_FM> (по умолчанию false)"

#. type: Plain text
#: man-pages/man4/st.4:517
msgid ""
"This option modifies the driver behavior when a file is closed.  The normal "
"action is to write a single filemark.  If the option is true, the driver "
"will write two filemarks and backspace over the second one."
msgstr "Этот параметр изменяет поведение драйвера после закрытия файла. По умолчанию драйвер записывает один маркер файла. Если значение параметра равно true, то драйвер запишет два маркера файла и вернётся на место второго."

#. type: Plain text
#: man-pages/man4/st.4:526
msgid ""
"Note: This option should not be set true for QIC tape drives since they are "
"unable to overwrite a filemark.  These drives detect the end of recorded "
"data by testing for blank tape rather than two consecutive filemarks.  Most "
"other current drives also detect the end of recorded data and using two "
"filemarks is usually necessary only when interchanging tapes with some other"
" systems."
msgstr "Замечание: этому параметру не может быть присвоено значение true для ленточных устройств QIC, так как  они не могут перезаписать маркер файла. Они находят конец записанных данных ища пустое место на ленте, а не два последовательных маркера файла. Многие современные устройства также находят конец записанных данных, и использование двух меток файла обычно необходимо только при одновременном использовании лент в нескольких разных системах."

#. type: TP
#: man-pages/man4/st.4:526
#, no-wrap
msgid "B<MT_ST_DEBUGGING> (Default: false)"
msgstr "B<MT_ST_DEBUGGING> (по умолчанию false)"

#. type: Plain text
#: man-pages/man4/st.4:532
msgid ""
"This option turns on various debugging messages from the driver (effective "
"only if the driver was compiled with B<DEBUG> defined nonzero)."
msgstr "Этот параметр включает вывод отладочных сообщений драйвера (работает только в том случае, если драйвер был собран с ненулевым значением B<DEBUG>)."

#. type: TP
#: man-pages/man4/st.4:532
#, no-wrap
msgid "B<MT_ST_FAST_EOM> (Default: false)"
msgstr "B<MT_ST_FAST_EOM> (по умолчанию false)"

#. type: Plain text
#: man-pages/man4/st.4:546
msgid ""
"This option causes the B<MTEOM> operation to be sent directly to the drive, "
"potentially speeding up the operation but causing the driver to lose track "
"of the current file number normally returned by the B<MTIOCGET> request.  If"
" B<MT_ST_FAST_EOM> is false, the driver will respond to an B<MTEOM> request "
"by forward spacing over files."
msgstr "Этот параметр заставляет посылать операцию B<MTEOM> непосредственно устройству, потенциально увеличивая скорость операций, но возникает опасность потерять дорожку текущего файла, номер которой обычно возвращается по запросу B<MTIOCGET>. Если значение параметра B<MT_ST_FAST_EOM> равно false, то драйвер отвечает на запрос B<MTEOM>, перематывая ленту к концу записанных файлов."

#. type: TP
#: man-pages/man4/st.4:546
#, no-wrap
msgid "B<MT_ST_AUTO_LOCK> (Default: false)"
msgstr "B<MT_ST_AUTO_LOCK> (по умолчанию false)"

#. type: Plain text
#: man-pages/man4/st.4:550
msgid ""
"When this option is true, the drive door is locked when the device is opened"
" and unlocked when it is closed."
msgstr "Когда этому параметру присвоено значение true, дверца блокируется, если устройство открыто, и дверца разблокируется, когда устройство закрыто."

#. type: TP
#: man-pages/man4/st.4:550
#, no-wrap
msgid "B<MT_ST_DEF_WRITES> (Default: false)"
msgstr "B<MT_ST_DEF_WRITES> (по умолчанию false)"

#. type: Plain text
#: man-pages/man4/st.4:567
msgid ""
"The tape options (block size, mode, compression, etc.) may change when "
"changing from one device linked to a drive to another device linked to the "
"same drive depending on how the devices are defined.  This option defines "
"when the changes are enforced by the driver using SCSI-commands and when the"
" drives auto-detection capabilities are relied upon.  If this option is "
"false, the driver sends the SCSI-commands immediately when the device is "
"changed.  If the option is true, the SCSI-commands are not sent until a "
"write is requested.  In this case, the drive firmware is allowed to detect "
"the tape structure when reading and the SCSI-commands are used only to make "
"sure that a tape is written according to the correct specification."
msgstr "Параметры ленты (размер блока, режим, сжатие и т.д.) могут изменяться, когда выполняется переход от одного устройства к другому устройству, которое связано с тем же устройством, в зависимости от того, как определяются устройства. Этот параметр определяет, будут ли применяться изменения через драйвер при помощи команд SCSI, или устройство само определит возможности, которые будут использоваться. Если значение параметра равно false, то драйвер будет посылать команды SCSI сразу после смены устройства. Если значение параметра равно true, команды SCSI не отправляются до запроса записи. В этом случае микропрограмма устройства позволяет выполнить обнаружение структуры ленты во время чтения, а команды SCSI используются только для проверки правильности записи на ленту в соответствии со спецификацией."

#. type: TP
#: man-pages/man4/st.4:567
#, no-wrap
msgid "B<MT_ST_CAN_BSR> (Default: false)"
msgstr "B<MT_ST_CAN_BSR> (по умолчанию false)"

#. type: Plain text
#: man-pages/man4/st.4:580
msgid ""
"When read-ahead is used, the tape must sometimes be spaced backward to the "
"correct position when the device is closed and the SCSI command to space "
"backward over records is used for this purpose.  Some older drives can't "
"process this command reliably and this option can be used to instruct the "
"driver not to use the command.  The end result is that, with read-ahead and "
"fixed-block mode, the tape may not be correctly positioned within a file "
"when the device is closed.  With 2.6 kernel, the default is true for drives "
"supporting SCSI-3."
msgstr "Если используется упреждающее чтение, лента должна быть иногда перемотана назад для правильного её размещения при закрытом устройстве. Для перемотки ленты назад используется команда SCSI. Некоторые старые устройства не могут правильно обрабатывать эту команду, и этот параметр может использоваться для того, чтобы указать драйверу не применять данную команду. В конечном итоге, с упреждающим чтением и в режиме с постоянным размером блока может быть неверно определено местоположение файла при закрытом устройстве. В ядре 2.6 значение параметра равно true для устройств с поддержкой SCSI-3."

#. type: TP
#: man-pages/man4/st.4:580
#, no-wrap
msgid "B<MT_ST_NO_BLKLIMS> (Default: false)"
msgstr "B<MT_ST_NO_BLKLIMS> (по умолчанию false)"

#. type: Plain text
#: man-pages/man4/st.4:589
msgid ""
"Some drives don't accept the B<READ BLOCK LIMITS> SCSI command.  If this is "
"used, the driver does not use the command.  The drawback is that the driver "
"can't check before sending commands if the selected block size is acceptable"
" to the drive."
msgstr "Некоторые устройства не понимают SCSI-команду B<READ BLOCK LIMITS>. Если параметр установлен, то драйвер не исполняет эту команду. Недостатком этого является невозможность проверки драйвером до отправки команд, поддерживается ли устройством выбранный размер блока."

#. type: TP
#: man-pages/man4/st.4:589
#, no-wrap
msgid "B<MT_ST_CAN_PARTITIONS> (Default: false)"
msgstr "B<MT_ST_CAN_PARTITIONS> (по умолчанию false)"

#. type: Plain text
#: man-pages/man4/st.4:594
msgid ""
"This option enables support for several partitions within a tape.  The "
"option applies to all devices linked to a drive."
msgstr "Этот параметр даёт возможность поддерживать несколько разделов на ленте. Он применяется ко всем файлам устройств, связанным с устройством."

#. type: TP
#: man-pages/man4/st.4:594
#, no-wrap
msgid "B<MT_ST_SCSI2LOGICAL> (Default: false)"
msgstr "B<MT_ST_SCSI2LOGICAL> (по умолчанию false)"

#. type: Plain text
#: man-pages/man4/st.4:609
msgid ""
"This option instructs the driver to use the logical block addresses defined "
"in the SCSI-2 standard when performing the seek and tell operations (both "
"with B<MTSEEK> and B<MTIOCPOS> commands and when changing tape partition).  "
"Otherwise, the device-specific addresses are used.  It is highly advisable "
"to set this option if the drive supports the logical addresses because they "
"count also filemarks.  There are some drives that support only the logical "
"block addresses."
msgstr "Этот параметр заставляет драйвер использовать адресацию логических блоков, определённую в стандарте SCSI-2 для выполнения операций поиска и пересчёта (с командами B<MTSEEK> и B<MTIOCPOS> и в том случае, когда изменяются разделы ленты). Желательно установить этот параметр, если устройство поддерживает логические адреса, потому что они рассчитывают также и маркеры файлов. Некоторые устройства поддерживают только адресацию логических блоков."

#. type: TP
#: man-pages/man4/st.4:609
#, no-wrap
msgid "B<MT_ST_SYSV> (Default: false)"
msgstr "B<MT_ST_SYSV> (по умолчанию false)"

#. type: Plain text
#: man-pages/man4/st.4:620
msgid ""
"When this option is enabled, the tape devices use the SystemV semantics.  "
"Otherwise, the BSD semantics are used.  The most important difference "
"between the semantics is what happens when a device used for reading is "
"closed: in System V semantics the tape is spaced forward past the next "
"filemark if this has not happened while using the device.  In BSD semantics "
"the tape position is not changed."
msgstr "Когда этот параметр установлен, ленточные устройства используют семантику SystemV. В других случаях используется семантика BSD. Основное  различие между ними (когда устройство, используемое для чтения, закрыто) состоит в следующем: по семантике SYSV лента перематывается вперед за следующий маркер файла, если этого не произошло во время использования устройства. В семантике BSD позиция на ленте не меняется."

#. type: TP
#: man-pages/man4/st.4:620
#, no-wrap
msgid "B<MT_NO_WAIT> (Default: false)"
msgstr "B<MT_NO_WAIT> (по умолчанию false)"

#. type: Plain text
#: man-pages/man4/st.4:624
msgid ""
"Enables immediate mode (i.e., don't wait for the command to finish) for some"
" commands (e.g., rewind)."
msgstr "Включает режим без задержки (т.е., не ждать завершения работы команды) для некоторых команд (например, rewind)."

#. type: Plain text
#: man-pages/man4/st.4:626
msgid "An example:"
msgstr "Пример:"

#. type: Plain text
#: man-pages/man4/st.4:634
#, no-wrap
msgid ""
"struct mtop mt_cmd;\n"
"mt_cmd.mt_op = MTSETDRVBUFFER;\n"
"mt_cmd.mt_count = MT_ST_BOOLEANS |\n"
"        MT_ST_BUFFER_WRITES | MT_ST_ASYNC_WRITES;\n"
"ioctl(fd, MTIOCTOP, mt_cmd);\n"
msgstr "struct mtop mt_cmd;\nmt_cmd.mt_op = MTSETDRVBUFFER;\nmt_cmd.mt_count = MT_ST_BOOLEANS |\n        MT_ST_BUFFER_WRITES | MT_ST_ASYNC_WRITES;\nioctl(fd, MTIOCTOP, mt_cmd);\n"

#. type: Plain text
#: man-pages/man4/st.4:644
msgid ""
"The default block size for a device can be set with B<MT_ST_DEF_BLKSIZE> and"
" the default density code can be set with B<MT_ST_DEFDENSITY>.  The values "
"for the parameters are or'ed with the operation code."
msgstr "Размер блока по умолчанию для устройства может быть установлен с помощью B<MT_ST_DEF_BLKSIZE>, а плотность данных по умолчанию может быть установлена с помощью B<MT_ST_DEFDENSITY>. Значения параметров логически складываются с кодом операции."

#. type: Plain text
#: man-pages/man4/st.4:661
msgid ""
"With kernels 2.1.x and later, the timeout values can be set with the "
"subcommand B<MT_ST_SET_TIMEOUT> ORed with the timeout in seconds.  The long "
"timeout (used for rewinds and other commands that may take a long time) can "
"be set with B<MT_ST_SET_LONG_TIMEOUT>.  The kernel defaults are very long to"
" make sure that a successful command is not timed out with any drive.  "
"Because of this the driver may seem stuck even if it is only waiting for the"
" timeout.  These commands can be used to set more practical values for a "
"specific drive.  The timeouts set for one device apply for all devices "
"linked to the same drive."
msgstr "В ядре версии 2.1.x и более поздних время ожидания может быть установлено подкомандой B<MT_ST_SET_TIMEOUT> логически сложенной со значением ожидания. Долгое время ожидания (используется при перемотке и выполнении других команд, занимающих длительное время) может быть установлено с помощью B<MT_ST_SET_LONG_TIMEOUT>. Значения, используемые в ядре по умолчанию, слишком велики, для уверенности в том, время ожидания не истечёт. Из-за этого драйвер может надолго застрять в ожидании. Эти команды могут быть использованы для установки оптимальных для значений различных устройств. Установка времени ожидания для одного устройства применяется для всех файлов устройств, связанных с этим устройством."

#. type: Plain text
#: man-pages/man4/st.4:682
msgid ""
"Starting from kernels 2.4.19 and 2.5.43, the driver supports a status bit "
"which indicates whether the drive requests cleaning.  The method used by the"
" drive to return cleaning information is set using the B<MT_ST_SEL_CLN> "
"subcommand.  If the value is zero, the cleaning bit is always zero.  If the "
"value is one, the TapeAlert data defined in the SCSI-3 standard is used (not"
" yet implemented).  Values 2-17 are reserved.  If the lowest eight bits are "
"E<gt>= 18, bits from the extended sense data are used.  The bits 9-16 "
"specify a mask to select the bits to look at and the bits 17-23 specify the "
"bit pattern to look for.  If the bit pattern is zero, one or more bits under"
" the mask indicate the cleaning request.  If the pattern is nonzero, the "
"pattern must match the masked sense data byte."
msgstr "Начиная с ядер 2.4.19 и 2.5.43, в драйвере появился бит состояния, который показывает, была ли запрошена очистка у устройства. Метод, используемый устройством для возврата информации об очистке, задаётся с помощью подкоманды B<MT_ST_SEL_CLN>. Если значение равно 0, то бит очистки всегда ноль. Если значение равно 1, то используются данные TapeAlert, определённые в стандарте SCSI-3 (пока не реализовано). Значения 2-17 зарезервированы. Если самые младшие восемь бит E<gt>= 18, то используются биты из расширенных данных уточнённого состояния (extended sense data). Биты 9-16 задаёт маску для выбора бит, которые должны просматриваться, а биты 17-23 задают битовый шаблон поиска. Если битовый шаблон равен 0, то один или более бит в маске указывают на запрос очистки. Если шаблон не равен нулю, то шаблон должен совпадать с байтом уточнённого состояния согласно маске."

#. type: SS
#: man-pages/man4/st.4:682
#, no-wrap
msgid "MTIOCGET \\(em get status"
msgstr "MTIOCGET \\(em получение состояния ленты"

#. type: Plain text
#: man-pages/man4/st.4:686
msgid "This request takes an argument of type I<(struct mtget\\ *)>."
msgstr "Для этого запроса требуется аргумент с типом I<(struct mtget\\ *)>."

#. type: Plain text
#: man-pages/man4/st.4:701
#, no-wrap
msgid ""
"/* structure for MTIOCGET - mag tape get status command */\n"
"struct mtget {\n"
"    long     mt_type;\n"
"    long     mt_resid;\n"
"    /* the following registers are device dependent */\n"
"    long     mt_dsreg;\n"
"    long     mt_gstat;\n"
"    long     mt_erreg;\n"
"    /* The next two fields are not always used */\n"
"    daddr_t  mt_fileno;\n"
"    daddr_t  mt_blkno;\n"
"};\n"
msgstr "/* структура для MTIOCGET - команда получения состояния ленты */\nstruct mtget {\n    long     mt_type;\n    long     mt_resid;\n    /* следующие регистры зависят от устройства */\n    long     mt_dsreg;\n    long     mt_gstat;\n    long     mt_erreg;\n    /* следующие два поля используются не всегда */\n    daddr_t  mt_fileno;\n    daddr_t  mt_blkno;\n};\n"

#. type: IP
#: man-pages/man4/st.4:703
#, no-wrap
msgid "I<mt_type>"
msgstr "I<mt_type>"

#. type: Plain text
#: man-pages/man4/st.4:712
msgid ""
"The header file defines many values for I<mt_type>, but the current driver "
"reports only the generic types B<MT_ISSCSI1> (Generic SCSI-1 tape)  and "
"B<MT_ISSCSI2> (Generic SCSI-2 tape)."
msgstr "В заголовочном файле определено множество значений I<mt_type>, но текущий драйвер сообщает только об общих типах B<MT_ISSCSI1> (лента общего типа SCSI-1) и B<MT_ISSCSI2> (лента общего типа SCSI-2)."

#. type: IP
#: man-pages/man4/st.4:712
#, no-wrap
msgid "I<mt_resid>"
msgstr "I<mt_resid>"

#. type: Plain text
#: man-pages/man4/st.4:714
msgid "contains the current tape partition number."
msgstr "Содержит номер текущего раздела ленты."

#. type: IP
#: man-pages/man4/st.4:714
#, no-wrap
msgid "I<mt_dsreg>"
msgstr "I<mt_dsreg>"

#. type: Plain text
#: man-pages/man4/st.4:723
msgid ""
"reports the drive's current settings for block size (in the low 24 bits) and"
" density (in the high 8 bits).  These fields are defined by "
"B<MT_ST_BLKSIZE_SHIFT>, B<MT_ST_BLKSIZE_MASK>, B<MT_ST_DENSITY_SHIFT>, and "
"B<MT_ST_DENSITY_MASK>."
msgstr "Содержит текущие настройки размера блока устройства (в младших 24-х битах) и плотность (в старших 8-х битах). Эти поля определяются с помощью B<MT_ST_BLKSIZE_SHIFT>, B<MT_ST_BLKSIZE_MASK>, B<MT_ST_DENSITY_SHIFT> и B<MT_ST_DENSITY_MASK>."

#. type: IP
#: man-pages/man4/st.4:723
#, no-wrap
msgid "I<mt_gstat>"
msgstr "I<mt_gstat>"

#. type: Plain text
#: man-pages/man4/st.4:726
msgid ""
"reports generic (device independent) status information.  The header file "
"defines macros for testing these status bits:"
msgstr "Содержит общую (независимую от устройства) информацию о состоянии. В заголовочном файле определены макросы для тестирования бит:"

#. type: Plain text
#: man-pages/man4/st.4:733
msgid ""
"B<GMT_EOF>(I<x>): The tape is positioned just after a filemark (always false"
" after an B<MTSEEK> operation)."
msgstr "B<GMT_EOF>(I<x>): Текущая позиция сразу после маркера файла (всегда false после выполнения операции B<MTSEEK>)."

#. type: Plain text
#: man-pages/man4/st.4:739
msgid ""
"B<GMT_BOT>(I<x>): The tape is positioned at the beginning of the first file "
"(always false after an B<MTSEEK> operation)."
msgstr "B<GMT_BOT>(I<x>): Текущая позиция на начале первого файла (всегда false после операции B<MTSEEK>)."

#. type: Plain text
#: man-pages/man4/st.4:742
msgid ""
"B<GMT_EOT>(I<x>): A tape operation has reached the physical End Of Tape."
msgstr "B<GMT_EOT>(I<x>): Текущая позиция у физического конца ленты."

#. type: Plain text
#: man-pages/man4/st.4:748
msgid ""
"B<GMT_SM>(I<x>): The tape is currently positioned at a setmark (always false"
" after an B<MTSEEK> operation)."
msgstr "B<GMT_SM>(I<x>): Текущая позиция на сборочном маркере (всегда false после выполнения операции B<MTSEEK>)."

#. type: Plain text
#: man-pages/man4/st.4:751
msgid "B<GMT_EOD>(I<x>): The tape is positioned at the end of recorded data."
msgstr "B<GMT_EOD>(I<x>): Текущая позиция в конце записанных данных."

#. type: Plain text
#: man-pages/man4/st.4:756
msgid ""
"B<GMT_WR_PROT>(I<x>): The drive is write-protected.  For some drives this "
"can also mean that the drive does not support writing on the current medium "
"type."
msgstr "B<GMT_WR_PROT>(I<x>): Устройство защищено от записи. Для некоторых устройств это может означать, что они не поддерживают запись на установленный носитель (неподдерживаемый тип)."

#. type: Plain text
#: man-pages/man4/st.4:761
msgid ""
"B<GMT_ONLINE>(I<x>): The last B<open>(2)  found the drive with a tape in "
"place and ready for operation."
msgstr "B<GMT_ONLINE>(I<x>): Последний вызов B<open>(2) привёл к тому, что лента в нужном месте и устройство готово к работе."

#. type: Plain text
#: man-pages/man4/st.4:765
msgid ""
"B<GMT_D_6250>(I<x>), B<GMT_D_1600>(I<x>), B<GMT_D_800>(I<x>): This "
"\\(lqgeneric\\(rq status information reports the current density setting for"
" 9-track \\(12\" tape drives only."
msgstr "B<GMT_D_6250>(I<x>), B<GMT_D_1600>(I<x>), B<GMT_D_800>(I<x>): \"Общая\" информация о текущей плотности только для 9-дорожечных \\(12\" устройств."

#. type: Plain text
#: man-pages/man4/st.4:768
msgid "B<GMT_DR_OPEN>(I<x>): The drive does not have a tape in place."
msgstr "B<GMT_DR_OPEN>(I<x>): Нет ленты в устройстве."

#. type: Plain text
#: man-pages/man4/st.4:776
msgid ""
"B<GMT_IM_REP_EN>(I<x>): Immediate report mode.  This bit is set if there are"
" no guarantees that the data has been physically written to the tape when "
"the write call returns.  It is set zero only when the driver does not buffer"
" data and the drive is set not to buffer data."
msgstr "B<GMT_IM_REP_EN>(I<x>): Сообщает о режиме. Этот бит устанавливается, если нет гарантии, что данные были правильно физически записаны на ленту после возврата из функции записи. Этот бит приобретает нулевое значение, когда драйвер не записывает данные в буфер и устройство не настроено на буферизацию данных."

#. type: Plain text
#: man-pages/man4/st.4:780
msgid ""
"B<GMT_CLN>(I<x>): The drive has requested cleaning.  Implemented in kernels "
"since 2.4.19 and 2.5.43."
msgstr "B<GMT_CLN>(I<x>): У устройства запросили очистку. Реализовано в ядрах, начиная с 2.4.19 и 2.5.43."

#. type: IP
#: man-pages/man4/st.4:781
#, no-wrap
msgid "I<mt_erreg>"
msgstr "I<mt_erreg>"

#. type: Plain text
#: man-pages/man4/st.4:791
msgid ""
"The only field defined in I<mt_erreg> is the recovered error count in the "
"low 16 bits (as defined by B<MT_ST_SOFTERR_SHIFT> and B<MT_ST_SOFTERR_MASK>."
"  Due to inconsistencies in the way drives report recovered errors, this "
"count is often not maintained (most drives do not by default report soft "
"errors but this can be changed with a SCSI MODE SELECT command)."
msgstr "Содержит счётчик (младшие 16 бит) исправленных ошибок, определяемых с помощью B<MT_ST_SOFTERR_SHIFT> и B<MT_ST_SOFTERR_MASK>. Из-за противоречивости способов сообщения об исправленных ошибках устройствами, часто этот счётчик не ведётся (большинство устройств по умолчанию не сообщают об исправленных ошибках, это можно изменить с помощью SCSI-команды MODE SELECT)."

#. type: IP
#: man-pages/man4/st.4:791
#, no-wrap
msgid "I<mt_fileno>"
msgstr "I<mt_fileno>"

#. type: Plain text
#: man-pages/man4/st.4:797
msgid ""
"reports the current file number (zero-based).  This value is set to -1 when "
"the file number is unknown (e.g., after B<MTBSS> or B<MTSEEK>)."
msgstr "Содержит текущий номер файла (отсчёт ведётся с 0). Если номер файла неизвестен, то значение равно -1 (например, после B<MTBSS> или B<MTSEEK>)."

#. type: IP
#: man-pages/man4/st.4:797
#, no-wrap
msgid "I<mt_blkno>"
msgstr "I<mt_blkno>"

#. type: Plain text
#: man-pages/man4/st.4:804
msgid ""
"reports the block number (zero-based) within the current file.  This value "
"is set to -1 when the block number is unknown (e.g., after B<MTBSF>, "
"B<MTBSS>, or B<MTSEEK>)."
msgstr "Содержит номер блока (отсчёт ведётся с 0) в пределах текущего файла. Если номер блока неизвестен, то значение равно -1 (например, после B<MTBSF>, B<MTBSS> или B<MTSEEK>)."

#. type: SS
#: man-pages/man4/st.4:804
#, no-wrap
msgid "MTIOCPOS \\(em get tape position"
msgstr "MTIOCPOS \\(em получение текущей позиции ленты"

#. type: Plain text
#: man-pages/man4/st.4:818
msgid ""
"This request takes an argument of type I<(struct mtpos\\ *)> and reports the"
" drive's notion of the current tape block number, which is not the same as "
"I<mt_blkno> returned by B<MTIOCGET>.  This drive must be a SCSI-2 drive that"
" supports the B<READ POSITION> command (device-specific address)  or a "
"Tandberg-compatible SCSI-1 drive (Tandberg, Archive Viper, Wangtek, ... )."
msgstr "Для этого запроса требуется аргумент с типом I<(struct mtpos\\ *)>. Он возвращает текущий номер блока ленты, который необязательно совпадает со значением I<mt_blkno>, возвращаемым B<MTIOCGET>. Устройство должен быть SCSI-2, чтобы поддерживать команду B<READ POSITION> (адрес, определяемый устройством), или Tandberg-совместимым устройством SCSI-1 (Tandberg, Archive Viper, Wangtek, …)."

#. type: Plain text
#: man-pages/man4/st.4:825
#, no-wrap
msgid ""
"/* structure for MTIOCPOS - mag tape get position command */\n"
"struct mtpos {\n"
"    long mt_blkno;    /* current block number */\n"
"};\n"
msgstr "/* структура для MTIOCPOS - команда получения позиции на ленте */\nstruct mtpos {\n    long mt_blkno;    /* текущий номер блока */\n};\n"

#. type: SH
#: man-pages/man4/st.4:827
#, no-wrap
msgid "RETURN VALUE"
msgstr "ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ"

#. type: TP
#: man-pages/man4/st.4:829
#, no-wrap
msgid "B<EACCES>"
msgstr "B<EACCES>"

#. type: Plain text
#: man-pages/man4/st.4:834
msgid ""
"An attempt was made to write or erase a write-protected tape.  (This error "
"is not detected during B<open>(2).)"
msgstr "Попытка записать или стереть ленту, защищённую от записи. (Эта ошибка не возникает при B<open>(2).)"

#. type: TP
#: man-pages/man4/st.4:834
#, no-wrap
msgid "B<EBUSY>"
msgstr "B<EBUSY>"

#. type: Plain text
#: man-pages/man4/st.4:838
msgid ""
"The device is already in use or the driver was unable to allocate a buffer."
msgstr "Устройство уже используется, или драйвер не способен выделить буфер."

#. type: TP
#: man-pages/man4/st.4:838
#, no-wrap
msgid "B<EFAULT>"
msgstr "B<EFAULT>"

#. type: Plain text
#: man-pages/man4/st.4:842
msgid ""
"The command parameters point to memory not belonging to the calling process."
msgstr "Параметры команды указывают на память, не принадлежащую вызывающему процессу."

#. type: TP
#: man-pages/man4/st.4:842
#, no-wrap
msgid "B<EINVAL>"
msgstr "B<EINVAL>"

#. type: Plain text
#: man-pages/man4/st.4:847
msgid ""
"An B<ioctl>(2)  had an invalid argument, or a requested block size was "
"invalid."
msgstr "Вызову B<ioctl>(2) был передан неверный аргумент, или запрошен неправильный размер блока."

#. type: TP
#: man-pages/man4/st.4:847
#, no-wrap
msgid "B<EIO>"
msgstr "B<EIO>"

#. type: Plain text
#: man-pages/man4/st.4:850
msgid "The requested operation could not be completed."
msgstr "Запрошенные операции не могут быть завершены."

#. type: TP
#: man-pages/man4/st.4:850
#, no-wrap
msgid "B<ENOMEM>"
msgstr "B<ENOMEM>"

#. type: Plain text
#: man-pages/man4/st.4:857
msgid ""
"The byte count in B<read>(2)  is smaller than the next physical block on the"
" tape.  (Before 2.2.18 and 2.4.0-test6 the extra bytes have been silently "
"ignored.)"
msgstr "Счётчик байт в B<read>(2) меньше чем следующий физический блок ленты. (До 2.2.18 и 2.4.0-test6 лишние байты просто игнорировались.)"

#. type: TP
#: man-pages/man4/st.4:857
#, no-wrap
msgid "B<ENOSPC>"
msgstr "B<ENOSPC>"

#. type: Plain text
#: man-pages/man4/st.4:861
msgid ""
"A write operation could not be completed because the tape reached end-of-"
"medium."
msgstr "Операция записи не может завершиться, потому что лента закончилась."

#. type: TP
#: man-pages/man4/st.4:861
#, no-wrap
msgid "B<ENOSYS>"
msgstr "B<ENOSYS>"

#. type: Plain text
#: man-pages/man4/st.4:865
msgid "Unknown B<ioctl>(2)."
msgstr "Неизвестный вызов B<ioctl>(2)."

#. type: TP
#: man-pages/man4/st.4:865
#, no-wrap
msgid "B<ENXIO>"
msgstr "B<ENXIO>"

#. type: Plain text
#: man-pages/man4/st.4:868
msgid "During opening, the tape device does not exist."
msgstr "Во время открытия обнаружено, что ленточного устройства не существует."

#. type: TP
#: man-pages/man4/st.4:868
#, no-wrap
msgid "B<EOVERFLOW>"
msgstr "B<EOVERFLOW>"

#. type: Plain text
#: man-pages/man4/st.4:872
msgid ""
"An attempt was made to read or write a variable-length block that is larger "
"than the driver's internal buffer."
msgstr "Попытка чтения или записи блоков переменной длины, больших, чем внутренний буфер драйвера."

#. type: TP
#: man-pages/man4/st.4:872
#, no-wrap
msgid "B<EROFS>"
msgstr "B<EROFS>"

#. type: Plain text
#: man-pages/man4/st.4:879
msgid ""
"Open is attempted with B<O_WRONLY> or B<O_RDWR> when the tape in the drive "
"is write-protected."
msgstr "Попытка открытия с параметром B<O_WRONLY> или B<O_RDWR>, но лента в устройстве защищена от записи."

#. type: TP
#: man-pages/man4/st.4:880
#, no-wrap
msgid "I</dev/st*>"
msgstr "I</dev/st*>"

#. type: Plain text
#: man-pages/man4/st.4:883
msgid "the auto-rewind SCSI tape devices"
msgstr "ленточные устройства SCSI с автоперемоткой"

#. type: TP
#: man-pages/man4/st.4:883
#, no-wrap
msgid "I</dev/nst*>"
msgstr "I</dev/nst*>"

#.  .SH AUTHOR
#.  The driver has been written by Kai M\(:akisara (Kai.Makisara@metla.fi)
#.  starting from a driver written by Dwayne Forsyth.
#.  Several other
#.  people have also contributed to the driver.
#. type: Plain text
#: man-pages/man4/st.4:891
msgid "the nonrewind SCSI tape devices"
msgstr "ленточные устройства SCSI без автоперемотки"

#. type: SH
#: man-pages/man4/st.4:891
#, no-wrap
msgid "NOTES"
msgstr "ЗАМЕЧАНИЯ"

#. type: IP
#: man-pages/man4/st.4:892
#, no-wrap
msgid "1."
msgstr "1."

#. type: Plain text
#: man-pages/man4/st.4:912
msgid ""
"When exchanging data between systems, both systems have to agree on the "
"physical tape block size.  The parameters of a drive after startup are often"
" not the ones most operating systems use with these devices.  Most systems "
"use drives in variable-block mode if the drive supports that mode.  This "
"applies to most modern drives, including DATs, 8mm helical scan drives, "
"DLTs, etc.  It may be advisable to use these drives in variable-block mode "
"also in Linux (i.e., use B<MTSETBLK> or B<MTSETDEFBLK> at system startup to "
"set the mode), at least when exchanging data with a foreign system.  The "
"drawback of this is that a fairly large tape block size has to be used to "
"get acceptable data transfer rates on the SCSI bus."
msgstr "При обмене данными между системами в них должен быть согласован физический размер блока ленты. Параметры устройства после загрузки часто не являются теми, которые использует большинство операционных систем, работающих с этими устройствами. Большинство систем используют устройства в режиме с переменным размером блока, если этот режим поддерживается устройством. Это применимо к большинству современных  устройств, включая DAT, DLT и т.д. Возможно, целесообразно использовать эти устройства в режиме с переменным размером блока также и в Linux (т.е., используйте B<MTSETBLK> или B<MTSETDEFBLK> при запуске системы для установки необходимого режима), по крайней мере при обмене данными с другими системами. Недостатком этого является довольно большой размер блока ленты, который нужно использовать для работы на приемлемой скорости при передаче данных по шине SCSI."

#. type: IP
#: man-pages/man4/st.4:912
#, no-wrap
msgid "2."
msgstr "2."

#. type: Plain text
#: man-pages/man4/st.4:919
msgid ""
"Many programs (e.g., B<tar>(1))  allow the user to specify the blocking "
"factor on the command line.  Note that this determines the physical block "
"size on tape only in variable-block mode."
msgstr "Многие программы (например, B<tar>(1)) позволяют пользователю задать  размер блока в командной строке. Заметим, что это помогает определить размер физического блока на ленте, но только в режиме с переменным размером блока."

#. type: IP
#: man-pages/man4/st.4:919
#, no-wrap
msgid "3."
msgstr "3."

#. type: Plain text
#: man-pages/man4/st.4:926
msgid ""
"In order to use SCSI tape drives, the basic SCSI driver, a SCSI-adapter "
"driver and the SCSI tape driver must be either configured into the kernel or"
" loaded as modules.  If the SCSI-tape driver is not present, the drive is "
"recognized but the tape support described in this page is not available."
msgstr "Для использования ленточных устройств SCSI, базовый драйвер SCSI, драйвер SCSI-адаптера и драйвер ленты SCSI должны быть включены в ядро или загружаться как модули. Если драйвер SCSI-ленты отсутствует, то устройство считается распознанным, но поддержка работы с лентой, описанная здесь, будет недоступна."

#. type: IP
#: man-pages/man4/st.4:926
#, no-wrap
msgid "4."
msgstr "4."

#. type: Plain text
#: man-pages/man4/st.4:931
msgid ""
"The driver writes error messages to the console/log.  The SENSE codes "
"written into some messages are automatically translated to text if verbose "
"SCSI messages are enabled in kernel configuration."
msgstr "Драйвер записывает сообщения об ошибках в консоль/журнал. Коды SENSE, содержащиеся в некоторых сообщениях, автоматически транслируются в текст, если в ядре включён параметр подробного вывода сообщений SCSI."

#. type: IP
#: man-pages/man4/st.4:931
#, no-wrap
msgid "5."
msgstr "5."

#.  .SH COPYRIGHT
#.  Copyright \(co 1995 Robert K. Nichols.
#.  .br
#.  Copyright \(co 1999-2005 Kai M\(:akisara.
#.  .PP
#.  %%%LICENSE_START(VERBATIM)
#.  Permission is granted to make and distribute verbatim copies of this
#.  manual provided the copyright notice and this permission notice are
#.  preserved on all copies.
#.  Additional permissions are contained in the header of the source file.
#. type: Plain text
#: man-pages/man4/st.4:954
msgid ""
"The driver's internal buffering allows good throughput in fixed-block mode "
"also with small B<read>(2)  and B<write>(2)  byte counts.  With direct "
"transfers this is not possible and may cause a surprise when moving to the "
"2.6 kernel.  The solution is to tell the software to use larger transfers "
"(often telling it to use larger blocks).  If this is not possible, direct "
"transfers can be disabled."
msgstr "Использование внутреннего буфера драйвера позволяет достичь хорошей пропускной способности в режиме с постоянным размером блока даже с маленьким числом байт в B<read>(2) и B<write>(2). Прямой обмен для этого невозможен и может привести к неожиданностям при переходе на ядро 2.6. В качестве решения предлагается указать ПО использовать больший обмен передачи (часто, указав использовать больший размер блоков). Если это невозможно, то прямой обмен может быть выключен."

#. type: Plain text
#: man-pages/man4/st.4:956
msgid "B<mt>(1)"
msgstr "B<mt>(1)"

#. type: Plain text
#: man-pages/man4/st.4:963
msgid ""
"The file I<drivers/scsi/README.st> or I<Documentation/scsi/st.txt> (kernel "
"E<gt>= 2.6) in the Linux kernel source tree contains the most recent "
"information about the driver and its configuration possibilities"
msgstr "Файл I<drivers/scsi/README.st> или I<Documentation/scsi/st.txt> (ядро E<gt>= 2.6) из дерева исходного кода ядра Linux содержит самую последнюю информацию о драйвере и его возможностях настройки"

#. type: TH
#: man-pages/man4/sd.4:26
#, no-wrap
msgid "SD"
msgstr "SD"

#. type: TH
#: man-pages/man4/sd.4:26
#, no-wrap
msgid "2012-05-03"
msgstr "2012-05-03"

#. type: Plain text
#: man-pages/man4/sd.4:29
msgid "sd - driver for SCSI disk drives"
msgstr "sd - драйвер для дисковых накопителей SCSI"

#. type: Plain text
#: man-pages/man4/sd.4:33
#, no-wrap
msgid ""
"B<#include E<lt>linux/hdreg.hE<gt>        >/* for HDIO_GETGEO */\n"
"B<#include E<lt>linux/fs.hE<gt>           >/* for BLKGETSIZE and BLKRRPART */\n"
msgstr "B<#include E<lt>linux/hdreg.hE<gt>        >/* для HDIO_GETGEO */\nB<#include E<lt>linux/fs.hE<gt>           >/* для BLKGETSIZE и BLKRRPART */\n"

#. type: SH
#: man-pages/man4/sd.4:34
#, no-wrap
msgid "CONFIGURATION"
msgstr "НАСТРОЙКА"

#. type: Plain text
#: man-pages/man4/sd.4:45
msgid ""
"The block device name has the following form: B<sd>I<lp,> where I<l> is a "
"letter denoting the physical drive, and I<p> is a number denoting the "
"partition on that physical drive.  Often, the partition number, I<p>, will "
"be left off when the device corresponds to the whole drive."
msgstr "Эти блочные устройства именуются согласно следующему формату: B<sd>I<lp,> где I<l> \\(em буква, обозначающая физический накопитель, а I<p> \\(em номер раздела на этом физическом накопителе. Часто номер раздела I<p> бывает пропущен, тогда устройство соответствует полностью всему накопителю."

#. type: Plain text
#: man-pages/man4/sd.4:54
msgid ""
"SCSI disks have a major device number of 8, and a minor device number of the"
" form (16 * I<drive_number>) + I<partition_number>, where I<drive_number> is"
" the number of the physical drive in order of detection, and "
"I<partition_number> is as follows:"
msgstr "Файлам устройств дисков SCSI присвоен старший номер 8, а младшие номера устройств рассчитываются как (16 * I<номер_накопителя>) + I<номер_раздела>, где I<номер_накопителя> \\(em это номер физического накопителя в порядке обнаружения, а I<номер_раздела>:"

#. type: Plain text
#: man-pages/man4/sd.4:56
msgid "partition 0 is the whole drive"
msgstr "раздел 0 \\(em накопитель полностью"

#. type: Plain text
#: man-pages/man4/sd.4:58
msgid "partitions 1-4 are the DOS \"primary\" partitions"
msgstr "разделы 1-4 \\(em \"первичные\" разделы DOS"

#. type: Plain text
#: man-pages/man4/sd.4:60
msgid "partitions 5-8 are the DOS \"extended\" (or \"logical\") partitions"
msgstr "разделы 5-8 \\(em \"расширенные\" (или \"логические\") разделы DOS"

#. type: Plain text
#: man-pages/man4/sd.4:68
msgid ""
"For example, I</dev/sda> will have major 8, minor 0, and will refer to all "
"of the first SCSI drive in the system; and I</dev/sdb3> will have major 8, "
"minor 19, and will refer to the third DOS \"primary\" partition on the "
"second SCSI drive in the system."
msgstr "Например, устройство I</dev/sda> будет иметь старший номер 8, младший 0 и указывать на первый накопитель SCSI в системе; устройство I</dev/sdb3> будет иметь старший номер 8, младший 19 и указывать на третий \"первичный\" раздел DOS на втором накопителе SCSI."

#. type: Plain text
#: man-pages/man4/sd.4:71
msgid ""
"At this time, only block devices are provided.  Raw devices have not yet "
"been implemented."
msgstr "В настоящий момент поддерживаются только блочные устройства. Устройства для прямого доступа (raw) пока не реализованы."

#. type: Plain text
#: man-pages/man4/sd.4:75
msgid "The following I<ioctl>s are provided:"
msgstr "Доступны следующие вызовы I<ioctl>:"

#. type: TP
#: man-pages/man4/sd.4:75
#, no-wrap
msgid "B<HDIO_GETGEO>"
msgstr "B<HDIO_GETGEO>"

#. type: Plain text
#: man-pages/man4/sd.4:79
msgid "Returns the BIOS disk parameters in the following structure:"
msgstr "Возвращает параметры диска из BIOS в виде следующей структуры:"

#. type: Plain text
#: man-pages/man4/sd.4:88
#, no-wrap
msgid ""
"struct hd_geometry {\n"
"    unsigned char  heads;\n"
"    unsigned char  sectors;\n"
"    unsigned short cylinders;\n"
"    unsigned long  start;\n"
"};\n"
msgstr "struct hd_geometry {\n    unsigned char  heads;\n    unsigned char  sectors;\n    unsigned short cylinders;\n    unsigned long  start;\n};\n"

#. type: Plain text
#: man-pages/man4/sd.4:94
msgid "A pointer to this structure is passed as the B<ioctl>(2)  parameter."
msgstr "Указатель на эту структуру передаётся ioctl(2) в виде параметра."

#. type: Plain text
#: man-pages/man4/sd.4:109
msgid ""
"The information returned in the parameter is the disk geometry of the drive "
"I<as understood by DOS!> This geometry is I<not> the physical geometry of "
"the drive.  It is used when constructing the drive's partition table, "
"however, and is needed for convenient operation of B<fdisk>(1), "
"B<efdisk>(1), and B<lilo>(1).  If the geometry information is not available,"
" zero will be returned for all of the parameters."
msgstr "Информация, возвращаемая в параметре, представляет собой геометрию дискового накопителя I<как это понимается в DOS!> Эта геометрия I<не> является физической геометрией накопителя. Однако, она используется при составлении таблицы разделов накопителя, и требуется для удобства при работе с B<fdisk>(1), B<efdisk>(1) и B<lilo>(1). Если информация о геометрии диска недоступна, все поля структуры равны нулю."

#. type: TP
#: man-pages/man4/sd.4:110
#, no-wrap
msgid "B<BLKGETSIZE>"
msgstr "B<BLKGETSIZE>"

#. type: Plain text
#: man-pages/man4/sd.4:117
msgid ""
"Returns the device size in sectors.  The B<ioctl>(2)  parameter should be a "
"pointer to a I<long>."
msgstr "Возвращает размер устройства в секторах. Параметр B<ioctl>(2) должен быть указателем на I<long>."

#. type: TP
#: man-pages/man4/sd.4:117
#, no-wrap
msgid "B<BLKRRPART>"
msgstr "B<BLKRRPART>"

#. type: Plain text
#: man-pages/man4/sd.4:121
msgid ""
"Forces a reread of the SCSI disk partition tables.  No parameter is needed."
msgstr "Заставляет перечитать таблицы разделов на диске SCSI. Используется без параметра."

#. type: Plain text
#: man-pages/man4/sd.4:131
msgid ""
"The SCSI B<ioctl>(2)  operations are also supported.  If the B<ioctl>(2)  "
"parameter is required, and it is NULL, then B<ioctl>(2)  will fail with the "
"error B<EINVAL>."
msgstr "Также поддерживаются операции SCSI через B<ioctl>(2). Если B<ioctl>(2) требуется параметр и он равен NULL, то B<ioctl>(2) завершится с ошибкой B<EINVAL>."

#. type: Plain text
#: man-pages/man4/sd.4:133
msgid "/dev/sd[a-h]: the whole device"
msgstr "/dev/sd[a-h]: устройство целиком"

#. type: Plain text
#: man-pages/man4/sd.4:134
msgid "/dev/sd[a-h][0-8]: individual block partitions"
msgstr "/dev/sd[a-h][0-8]: отдельные блочные разделы"

#. type: TH
#: man-pages/man8/sln.8:25
#, no-wrap
msgid "SLN"
msgstr "SLN"

#. type: TH
#: man-pages/man8/sln.8:25
#, no-wrap
msgid "2013-02-10"
msgstr "2013-02-10"

#. type: TH
#: man-pages/man8/sln.8:25
#, no-wrap
msgid "GNU"
msgstr "GNU"

#. type: Plain text
#: man-pages/man8/sln.8:28
msgid "sln - create symbolic links"
msgstr "sln - создаёт символьные ссылки"

#. type: Plain text
#: man-pages/man8/sln.8:30
msgid "B<sln>I< source dest>"
msgstr "B<sln>I< source dest>"

#. type: Plain text
#: man-pages/man8/sln.8:32
msgid "B<sln>I< filelist>"
msgstr "B<sln>I< filelist>"

#. type: Plain text
#: man-pages/man8/sln.8:42
msgid ""
"The B<sln> program creates symbolic links.  Unlike the B<ln>(1)  program, it"
" is statically linked.  This means that if for some reason the dynamic "
"linker is not working, B<sln> can be used to make symbolic links to dynamic "
"libraries."
msgstr ""

#. type: Plain text
#: man-pages/man8/sln.8:48
msgid ""
"The command line has two forms.  In the first form, it creates I<dest> as a "
"new symbolic link to I<source>."
msgstr ""

#. type: Plain text
#: man-pages/man8/sln.8:56
msgid ""
"In the second form, I<filelist> is a list of space-separated pathname pairs,"
" and the effect is as if B<sln> was executed once for each line of the file,"
" with the two pathnames as the arguments."
msgstr ""

#. type: Plain text
#: man-pages/man8/sln.8:60
msgid "The B<sln> program supports no command-line options."
msgstr ""

#. type: Plain text
#: man-pages/man8/sln.8:63
msgid "B<ln>(1), B<ldconfig>(8), B<ld.so>(8)"
msgstr "B<ln>(1), B<ldconfig>(8), B<ld.so>(8)"

#. type: TH
#: man-pages/man1/sprof.1:25
#, no-wrap
msgid "SPROF"
msgstr ""

#. type: TH
#: man-pages/man1/sprof.1:25
#, no-wrap
msgid "2014-06-24"
msgstr ""

#. type: TH
#: man-pages/man1/sprof.1:25
#, no-wrap
msgid "Linux User Manual"
msgstr ""

#. type: Plain text
#: man-pages/man1/sprof.1:28
msgid "sprof - read and display shared object profiling data"
msgstr ""

#. type: Plain text
#: man-pages/man1/sprof.1:31
#, no-wrap
msgid "B<sprof> [OPTION]... SHARED-OBJECT-PATH [PROFILE-DATA-PATH]\n"
msgstr ""

#. type: Plain text
#: man-pages/man1/sprof.1:45
msgid ""
"The B<sprof> command displays a profiling summary for the shared object "
"specified as its first command-line argument.  The profiling summary is "
"created using previously generated profiling data in the (optional) second "
"command-line argument.  If the profiling data pathname is omitted, then "
"B<sprof> will attempt to deduce it using the soname of the shared object, "
"looking for a file with the name I<E<lt>sonameE<gt>.profile> in the current "
"directory."
msgstr ""

#. type: SH
#: man-pages/man1/sprof.1:45
#, no-wrap
msgid "OPTIONS"
msgstr ""

#. type: Plain text
#: man-pages/man1/sprof.1:48
msgid ""
"The following command-line options specify the profile output to be "
"produced:"
msgstr ""

#. type: TP
#: man-pages/man1/sprof.1:48
#, no-wrap
msgid "B<-c>, B<--call-pairs>"
msgstr ""

#. type: Plain text
#: man-pages/man1/sprof.1:53
msgid ""
"Print a list of pairs of call paths for the interfaces exported by the "
"shared object, along with the number of times each path is used."
msgstr ""

#. type: TP
#: man-pages/man1/sprof.1:53
#, no-wrap
msgid "B<-p>, B<--flat-profile>"
msgstr ""

#. type: Plain text
#: man-pages/man1/sprof.1:57
msgid ""
"Generate a flat profile of all of the functions in the monitored object, "
"with counts and ticks."
msgstr ""

#. type: TP
#: man-pages/man1/sprof.1:57
#, no-wrap
msgid "B<-q>, B<--graph>"
msgstr ""

#. type: Plain text
#: man-pages/man1/sprof.1:60
msgid "Generate a call graph."
msgstr ""

#. type: Plain text
#: man-pages/man1/sprof.1:63
msgid ""
"If none of the above options is specified, then the default behavior is to "
"display a flat profile and a call graph."
msgstr ""

#. type: Plain text
#: man-pages/man1/sprof.1:65
msgid "The following additional command-line options are available:"
msgstr ""

#. type: TP
#: man-pages/man1/sprof.1:65
#, no-wrap
msgid "B<-?>, B<--help>"
msgstr ""

#. type: Plain text
#: man-pages/man1/sprof.1:68
msgid "Display a summary of command-line options and arguments and exit."
msgstr ""

#. type: TP
#: man-pages/man1/sprof.1:68
#, no-wrap
msgid "B<--usage>"
msgstr ""

#. type: Plain text
#: man-pages/man1/sprof.1:71
msgid "Display a short usage message and exit."
msgstr ""

#. type: TP
#: man-pages/man1/sprof.1:71
#, no-wrap
msgid "B<-V>, B<--version>"
msgstr ""

#. type: Plain text
#: man-pages/man1/sprof.1:74
msgid "Display the program version and exit."
msgstr ""

#. type: SH
#: man-pages/man1/sprof.1:74
#, no-wrap
msgid "CONFORMING TO"
msgstr "СООТВЕТСТВИЕ СТАНДАРТАМ"

#. type: Plain text
#: man-pages/man1/sprof.1:78
msgid "The B<sprof> command is a GNU extension, not present in POSIX.1."
msgstr ""

#. type: SH
#: man-pages/man1/sprof.1:78
#, no-wrap
msgid "EXAMPLE"
msgstr "ПРИМЕР"

#. type: Plain text
#: man-pages/man1/sprof.1:84
msgid ""
"The following example demonstrates the use of B<sprof>.  The example "
"consists of a main program that calls two functions in a shared library.  "
"First, the code of the main program:"
msgstr ""

#. type: Plain text
#: man-pages/man1/sprof.1:89
#, no-wrap
msgid ""
"$ B<cat prog.c>\n"
"#include E<lt>stdlib.hE<gt>\n"
msgstr ""

#. type: Plain text
#: man-pages/man1/sprof.1:92
#, no-wrap
msgid ""
"void x1(void);\n"
"void x2(void);\n"
msgstr ""

#. type: Plain text
#: man-pages/man1/sprof.1:100
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    x1();\n"
"    x2();\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man1/sprof.1:109
msgid ""
"The functions I<x1()> and I<x2()> are defined in the following source file "
"that is used to construct the shared library:"
msgstr ""

#. type: Plain text
#: man-pages/man1/sprof.1:114
#, no-wrap
msgid ""
"$ B<cat libdemo.c>\n"
"#include E<lt>unistd.hE<gt>\n"
msgstr ""

#. type: Plain text
#: man-pages/man1/sprof.1:119
#, no-wrap
msgid ""
"void\n"
"consumeCpu1(int lim)\n"
"{\n"
"    int j;\n"
msgstr ""

#. type: Plain text
#: man-pages/man1/sprof.1:123 man-pages/man1/sprof.1:140
#, no-wrap
msgid ""
"    for (j = 0; j E<lt> lim; j++)\n"
"\tgetppid();\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man1/sprof.1:127
#, no-wrap
msgid ""
"void\n"
"x1(void) {\n"
"    int j;\n"
msgstr ""

#. type: Plain text
#: man-pages/man1/sprof.1:131
#, no-wrap
msgid ""
"    for (j = 0; j E<lt> 100; j++)\n"
"\tconsumeCpu1(200000);\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man1/sprof.1:136
#, no-wrap
msgid ""
"void\n"
"consumeCpu2(int lim)\n"
"{\n"
"    int j;\n"
msgstr ""

#. type: Plain text
#: man-pages/man1/sprof.1:145
#, no-wrap
msgid ""
"void\n"
"x2(void)\n"
"{\n"
"    int j;\n"
msgstr ""

#. type: Plain text
#: man-pages/man1/sprof.1:149
#, no-wrap
msgid ""
"    for (j = 0; j E<lt> 1000; j++)\n"
"\tconsumeCpu2(10000);\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man1/sprof.1:156
msgid ""
"Now we construct the shared library with the real name I<libdemo.so.1.0.1>, "
"and the soname I<libdemo.so.1>:"
msgstr ""

#. type: Plain text
#: man-pages/man1/sprof.1:161
#, no-wrap
msgid ""
"$ B<cc -g -fPIC -shared -Wl,-soname,libdemo.so.1 \\e>\n"
"        B<-o libdemo.so.1.0.1 libdemo.c>\n"
msgstr ""

#. type: Plain text
#: man-pages/man1/sprof.1:166
msgid ""
"Then we construct symbolic links for the library soname and the library "
"linker name:"
msgstr ""

#. type: Plain text
#: man-pages/man1/sprof.1:171
#, no-wrap
msgid ""
"$ B<ln -sf libdemo.so.1.0.1 libdemo.so.1>\n"
"$ B<ln -sf libdemo.so.1 libdemo.so>\n"
msgstr ""

#. type: Plain text
#: man-pages/man1/sprof.1:176
msgid ""
"Next, we compile the main program, linking it against the shared library, "
"and then list the dynamic dependencies of the program:"
msgstr ""

#. type: Plain text
#: man-pages/man1/sprof.1:185
#, no-wrap
msgid ""
"$ B<cc -g -o prog prog.c -L. -ldemo>\n"
"$ B<ldd prog>\n"
"\tlinux-vdso.so.1 =E<gt>  (0x00007fff86d66000)\n"
"\tlibdemo.so.1 =E<gt> not found\n"
"\tlibc.so.6 =E<gt> /lib64/libc.so.6 (0x00007fd4dc138000)\n"
"\t/lib64/ld-linux-x86-64.so.2 (0x00007fd4dc51f000)\n"
msgstr ""

#. type: Plain text
#: man-pages/man1/sprof.1:192
msgid ""
"In order to get profiling information for the shared library, we define the "
"environment variable B<LD_PROFILE> with the soname of the library:"
msgstr ""

#. type: Plain text
#: man-pages/man1/sprof.1:196
#, no-wrap
msgid "$ B<export LD_PROFILE=libdemo.so.1>\n"
msgstr ""

#. type: Plain text
#: man-pages/man1/sprof.1:203
msgid ""
"We then define the environment variable B<LD_PROFILE_OUTPUT> with the "
"pathname of the directory where profile output should be written, and create"
" that directory if it does not exist already:"
msgstr ""

#. type: Plain text
#: man-pages/man1/sprof.1:208
#, no-wrap
msgid ""
"$ B<export LD_PROFILE_OUTPUT=$(pwd)/prof_data>\n"
"$ B<mkdir -p $LD_PROFILE_OUTPUT>\n"
msgstr ""

#. type: Plain text
#: man-pages/man1/sprof.1:216
msgid ""
"B<LD_PROFILE> causes profiling output to be I<appended> to the output file "
"if it already exists, so we ensure that there is no preexisting profiling "
"data:"
msgstr ""

#. type: Plain text
#: man-pages/man1/sprof.1:220
#, no-wrap
msgid "$ B<rm -f $LD_PROFILE_OUTPUT/$LD_PROFILE.profile>\n"
msgstr ""

#. type: Plain text
#: man-pages/man1/sprof.1:226
msgid ""
"We then run the program to produce the profiling output, which is written to"
" a file in the directory specified in B<LD_PROFILE_OUTPUT>:"
msgstr ""

#. type: Plain text
#: man-pages/man1/sprof.1:232
#, no-wrap
msgid ""
"$ B<LD_LIBRARY_PATH=. ./prog>\n"
"$ B<ls prof_data>\n"
"libdemo.so.1.profile\n"
msgstr ""

#. type: Plain text
#: man-pages/man1/sprof.1:238
msgid ""
"We then use the B<sprof -p> option to generate a flat profile with counts "
"and ticks:"
msgstr ""

#. type: Plain text
#: man-pages/man1/sprof.1:243
#, no-wrap
msgid ""
"$ B<sprof -p libdemo.so.1 $LD_PROFILE_OUTPUT/libdemo.so.1.profile>\n"
"Flat profile:\n"
msgstr ""

#. type: Plain text
#: man-pages/man1/sprof.1:251
#, no-wrap
msgid ""
"Each sample counts as 0.01 seconds.\n"
"  %   cumulative   self              self     total\n"
" time   seconds   seconds    calls  us/call  us/call  name\n"
" 60.00      0.06     0.06      100   600.00           consumeCpu1\n"
" 40.00      0.10     0.04     1000    40.00           consumeCpu2\n"
"  0.00      0.10     0.00        1     0.00           x1\n"
"  0.00      0.10     0.00        1     0.00           x2\n"
msgstr ""

#. type: Plain text
#: man-pages/man1/sprof.1:257
msgid "The B<sprof -q> option generates a call graph:"
msgstr ""

#. type: Plain text
#: man-pages/man1/sprof.1:261
#, no-wrap
msgid "$ B<sprof -q libdemo.so.1 $LD_PROFILE_OUTPUT/libdemo.so.1.profile>\n"
msgstr ""

#. type: Plain text
#: man-pages/man1/sprof.1:263
#, no-wrap
msgid "index % time    self  children    called     name\n"
msgstr ""

#. type: Plain text
#: man-pages/man1/sprof.1:278
#, no-wrap
msgid ""
"                0.00    0.00      100/100         x1 [1]\n"
"[0]    100.0    0.00    0.00      100         consumeCpu1 [0]\n"
"-----------------------------------------------\n"
"                0.00    0.00        1/1           E<lt>UNKNOWNE<gt>\n"
"[1]      0.0    0.00    0.00        1         x1 [1]\n"
"                0.00    0.00      100/100         consumeCpu1 [0]\n"
"-----------------------------------------------\n"
"                0.00    0.00     1000/1000        x2 [3]\n"
"[2]      0.0    0.00    0.00     1000         consumeCpu2 [2]\n"
"-----------------------------------------------\n"
"                0.00    0.00        1/1           E<lt>UNKNOWNE<gt>\n"
"[3]      0.0    0.00    0.00        1         x2 [3]\n"
"                0.00    0.00     1000/1000        consumeCpu2 [2]\n"
"-----------------------------------------------\n"
msgstr ""

#. type: Plain text
#: man-pages/man1/sprof.1:284
msgid ""
"Above and below, the \"E<lt>UNKNOWNE<gt>\" strings represent identifiers "
"that are outside of the profiled object (in this example, these are "
"instances of I<main()>)."
msgstr ""

#. type: Plain text
#: man-pages/man1/sprof.1:288
msgid ""
"The B<sprof -c> option generates a list of call pairs and the number of "
"their occurrences:"
msgstr ""

#. type: Plain text
#: man-pages/man1/sprof.1:296
#, no-wrap
msgid ""
"$ B<sprof -c libdemo.so.1 $LD_PROFILE_OUTPUT/libdemo.so.1.profile>\n"
"E<lt>UNKNOWNE<gt>                  x1                                 1\n"
"x1                         consumeCpu1                      100\n"
"E<lt>UNKNOWNE<gt>                  x2                                 1\n"
"x2                         consumeCpu2                     1000\n"
msgstr ""

#. type: Plain text
#: man-pages/man1/sprof.1:301
msgid "B<gprof>(1), B<ldd>(1), B<ld.so>(8)"
msgstr ""

#. type: TH
#: man-pages/man7/svipc.7:40
#, no-wrap
msgid "SVIPC"
msgstr "SVIPC"

#. type: TH
#: man-pages/man7/svipc.7:40
#, no-wrap
msgid "2013-02-12"
msgstr "2013-02-12"

#. type: Plain text
#: man-pages/man7/svipc.7:43
msgid "svipc - System V interprocess communication mechanisms"
msgstr "svipc - механизмы межпроцессного взаимодействия System V"

#. type: Plain text
#: man-pages/man7/svipc.7:48
#, no-wrap
msgid ""
"B<#include E<lt>sys/msg.hE<gt>>\n"
"B<#include E<lt>sys/sem.hE<gt>>\n"
"B<#include E<lt>sys/shm.hE<gt>>\n"
msgstr "B<#include E<lt>sys/msg.hE<gt>>\nB<#include E<lt>sys/sem.hE<gt>>\nB<#include E<lt>sys/shm.hE<gt>>\n"

#. type: Plain text
#: man-pages/man7/svipc.7:56
msgid ""
"This manual page refers to the Linux implementation of the System V "
"interprocess communication (IPC) mechanisms: message queues, semaphore sets,"
" and shared memory segments.  In the following, the word I<resource> means "
"an instantiation of one among such mechanisms."
msgstr "Данная справочная страница описывает реализацию механизмов межпроцессного взаимодействия (IPC) System V в Linux: очереди сообщений, наборы семафоров и сегменты разделяемой памяти.  В дальнейшем под словом  I<ресурс> будет подразумеваться экземпляр одного из этих механизмов."

#. type: SS
#: man-pages/man7/svipc.7:56
#, no-wrap
msgid "Resource access permissions"
msgstr "Права доступа к ресурсу"

#. type: Plain text
#: man-pages/man7/svipc.7:64
msgid ""
"For each resource, the system uses a common structure of type I<struct "
"ipc_perm> to store information needed in determining permissions to perform "
"an IPC operation.  The I<ipc_perm> structure includes the following members:"
msgstr "Для каждого ресурса система использует общую структуру типа I<struct ipc_perm>, хранящую необходимую информацию о правах для проведения IPC-операции. Структура I<ipc_perm> включает следующие поля:"

#. type: Plain text
#: man-pages/man7/svipc.7:74
#, no-wrap
msgid ""
"struct ipc_perm {\n"
"    uid_t          cuid;   /* creator user ID */\n"
"    gid_t          cgid;   /* creator group ID */\n"
"    uid_t          uid;    /* owner user ID */\n"
"    gid_t          gid;    /* owner group ID */\n"
"    unsigned short mode;   /* r/w permissions */\n"
"};\n"
msgstr "struct ipc_perm {\n    uid_t          cuid;   /* ID пользователя создателя */\n    gid_t          cgid;   /* ID группы создателя */\n    uid_t          uid;    /* ID пользователя владельца */\n    gid_t          gid;    /* ID группы владельца */\n    unsigned short mode;   /* права для чтения-записи */\n};\n"

#. type: Plain text
#: man-pages/man7/svipc.7:84
msgid ""
"The I<mode> member of the I<ipc_perm> structure defines, with its lower 9 "
"bits, the access permissions to the resource for a process executing an IPC "
"system call.  The permissions are interpreted as follows:"
msgstr "Поле I<mode> из структуры I<ipc_perm> определяет в нижних 9 битах права доступа к ресурсу для вызвавшего системный вызов IPC процесса. Права определены следующим образом:"

#. type: Plain text
#: man-pages/man7/svipc.7:88
#, no-wrap
msgid ""
"    0400    Read by user.\n"
"    0200    Write by user.\n"
msgstr "    0400    Чтение пользователем.\n    0200    Запись пользователем.\n"

#. type: Plain text
#: man-pages/man7/svipc.7:91
#, no-wrap
msgid ""
"    0040    Read by group.\n"
"    0020    Write by group.\n"
msgstr "    0040    Чтение группой.\n    0020    Запись группой.\n"

#. type: Plain text
#: man-pages/man7/svipc.7:94
#, no-wrap
msgid ""
"    0004    Read by others.\n"
"    0002    Write by others.\n"
msgstr "    0004    Чтение остальными.\n    0002    Запись остальными.\n"

#. type: Plain text
#: man-pages/man7/svipc.7:102
msgid ""
"Bits 0100, 0010, and 0001 (the execute bits) are unused by the system.  "
"Furthermore, \"write\" effectively means \"alter\" for a semaphore set."
msgstr "Биты 0100, 0010 и 0001 (биты запуска) системой не используется. Кроме того, «запись» для набора семафоров на самом деле означает «изменение»."

#. type: Plain text
#: man-pages/man7/svipc.7:105
msgid ""
"The same system header file also defines the following symbolic constants:"
msgstr "Тот же системный заголовочный файл определяет следующие символические константы:"

#. type: TP
#: man-pages/man7/svipc.7:105
#, no-wrap
msgid "B<IPC_CREAT>"
msgstr "B<IPC_CREAT>"

#. type: Plain text
#: man-pages/man7/svipc.7:108
msgid "Create entry if key doesn't exist."
msgstr "Создать запись, если ключ не существует."

#. type: TP
#: man-pages/man7/svipc.7:108
#, no-wrap
msgid "B<IPC_EXCL>"
msgstr "B<IPC_EXCL>"

#. type: Plain text
#: man-pages/man7/svipc.7:111
msgid "Fail if key exists."
msgstr "Завершиться ошибкой, если ключ существует."

#. type: TP
#: man-pages/man7/svipc.7:111
#, no-wrap
msgid "B<IPC_NOWAIT>"
msgstr "B<IPC_NOWAIT>"

#. type: Plain text
#: man-pages/man7/svipc.7:114
msgid "Error if request must wait."
msgstr "Ошибка, если запрос должен ждать."

#. type: TP
#: man-pages/man7/svipc.7:114
#, no-wrap
msgid "B<IPC_PRIVATE>"
msgstr "B<IPC_PRIVATE>"

#. type: Plain text
#: man-pages/man7/svipc.7:117
msgid "Private key."
msgstr "Частный ключ."

#. type: TP
#: man-pages/man7/svipc.7:117
#, no-wrap
msgid "B<IPC_RMID>"
msgstr "B<IPC_RMID>"

#. type: Plain text
#: man-pages/man7/svipc.7:120
msgid "Remove resource."
msgstr "Удалить ресурс."

#. type: TP
#: man-pages/man7/svipc.7:120
#, no-wrap
msgid "B<IPC_SET>"
msgstr "B<IPC_SET>"

#. type: Plain text
#: man-pages/man7/svipc.7:123
msgid "Set resource options."
msgstr "Установить параметры ресурса."

#. type: TP
#: man-pages/man7/svipc.7:123
#, no-wrap
msgid "B<IPC_STAT>"
msgstr "B<IPC_STAT>"

#. type: Plain text
#: man-pages/man7/svipc.7:126
msgid "Get resource options."
msgstr "Получить параметры ресурса."

#. type: Plain text
#: man-pages/man7/svipc.7:135
msgid ""
"Note that B<IPC_PRIVATE> is a I<key_t> type, while all the other symbolic "
"constants are flag fields and can be OR'ed into an I<int> type variable."
msgstr "Заметьте, что B<IPC_PRIVATE> является типом I<key_t>, когда как остальные символические константы являются флагами и могут быть объединены с помощью логического ИЛИ в переменную типа I<int>."

#. type: SS
#: man-pages/man7/svipc.7:135
#, no-wrap
msgid "Message queues"
msgstr "Очереди сообщений"

#. type: Plain text
#: man-pages/man7/svipc.7:143
msgid ""
"A message queue is uniquely identified by a positive integer (its I<msqid>)"
"  and has an associated data structure of type I<struct msqid_ds>, defined "
"in I<E<lt>sys/msg.hE<gt>>, containing the following members:"
msgstr "Очередь сообщений уникально идентифицируется положительным целым (I<msqid>) и имеет связанную структуру данных I<struct msqid_ds>, определенную в I<E<lt>sys/msg.hE<gt>> и содержащую следующие поля:"

#. type: Plain text
#: man-pages/man7/svipc.7:156
#, no-wrap
msgid ""
"struct msqid_ds {\n"
"    struct ipc_perm msg_perm;\n"
"    msgqnum_t       msg_qnum;    /* no of messages on queue */\n"
"    msglen_t        msg_qbytes;  /* bytes max on a queue */\n"
"    pid_t           msg_lspid;   /* PID of last msgsnd(2) call */\n"
"    pid_t           msg_lrpid;   /* PID of last msgrcv(2) call */\n"
"    time_t          msg_stime;   /* last msgsnd(2) time */\n"
"    time_t          msg_rtime;   /* last msgrcv(2) time */\n"
"    time_t          msg_ctime;   /* last change time */\n"
"};\n"
msgstr "struct msqid_ds {\n    struct ipc_perm msg_perm;\n    msgqnum_t       msg_qnum;    /* в очереди не сообщений */\n    msglen_t        msg_qbytes;  /* макс. байт в очереди */\n    pid_t           msg_lspid;   /* PID последнего вызова  msgsnd(2) */\n    pid_t           msg_lrpid;   /* PID последнего вызова msgrcv(2) */\n    time_t          msg_stime;   /* время последнего msgsnd(2) */\n    time_t          msg_rtime;   /* время последнего  msgrcv(2) */\n    time_t          msg_ctime;   /* последнее время изменения */\n};\n"

#. type: TP
#: man-pages/man7/svipc.7:158
#, no-wrap
msgid "I<msg_perm>"
msgstr "I<msg_perm>"

#. type: Plain text
#: man-pages/man7/svipc.7:163
msgid ""
"I<ipc_perm> structure that specifies the access permissions on the message "
"queue."
msgstr "Структура I<ipc_perm>, определяющая права доступа к очереди сообщений."

#. type: TP
#: man-pages/man7/svipc.7:163
#, no-wrap
msgid "I<msg_qnum>"
msgstr "I<msg_qnum>"

#. type: Plain text
#: man-pages/man7/svipc.7:166
msgid "Number of messages currently on the message queue."
msgstr "Число сообщений, находящихся в данный момент в очереди сообщений."

#. type: TP
#: man-pages/man7/svipc.7:166
#, no-wrap
msgid "I<msg_qbytes>"
msgstr "I<msg_qbytes>"

#. type: Plain text
#: man-pages/man7/svipc.7:170
msgid "Maximum number of bytes of message text allowed on the message queue."
msgstr "Максимальная длина сообщения в байтах, разрешенная в очереди сообщений."

#. type: TP
#: man-pages/man7/svipc.7:170
#, no-wrap
msgid "I<msg_lspid>"
msgstr "I<msg_lspid>"

#. type: Plain text
#: man-pages/man7/svipc.7:175
msgid "ID of the process that performed the last B<msgsnd>(2)  system call."
msgstr "ID процесса, выполнившего последний системный вызов B<msgsnd>(2)."

#. type: TP
#: man-pages/man7/svipc.7:175
#, no-wrap
msgid "I<msg_lrpid>"
msgstr "I<msg_lrpid>"

#. type: Plain text
#: man-pages/man7/svipc.7:180
msgid "ID of the process that performed the last B<msgrcv>(2)  system call."
msgstr "ID процесса, выполнившего последний системный вызов B<msgrcv>(2)."

#. type: TP
#: man-pages/man7/svipc.7:180
#, no-wrap
msgid "I<msg_stime>"
msgstr "I<msg_stime>"

#. type: Plain text
#: man-pages/man7/svipc.7:185
msgid "Time of the last B<msgsnd>(2)  system call."
msgstr "Время последнего вызова B<msgsnd>(2)."

#. type: TP
#: man-pages/man7/svipc.7:185
#, no-wrap
msgid "I<msg_rtime>"
msgstr "I<msg_rtime>"

#. type: Plain text
#: man-pages/man7/svipc.7:190
msgid "Time of the last B<msgrcv>(2)  system call."
msgstr "Время последнего вызова B<msgrcv>(2)."

#. type: TP
#: man-pages/man7/svipc.7:190
#, no-wrap
msgid "I<msg_ctime>"
msgstr "I<msg_ctime>"

#. type: Plain text
#: man-pages/man7/svipc.7:196
msgid ""
"Time of the last system call that changed a member of the I<msqid_ds> "
"structure."
msgstr "Время последнего системного вызова, изменившего поля структуры I<msgid_ds>."

#. type: SS
#: man-pages/man7/svipc.7:196
#, no-wrap
msgid "Semaphore sets"
msgstr "Наборы семафоров"

#. type: Plain text
#: man-pages/man7/svipc.7:204
msgid ""
"A semaphore set is uniquely identified by a positive integer (its I<semid>)"
"  and has an associated data structure of type I<struct semid_ds>, defined "
"in I<E<lt>sys/sem.hE<gt>>, containing the following members:"
msgstr "Набор семафора уникально идентифицируется положительным целым (I<semid>) и имеет связанную структуру типа I<struct semid_ds>, определенную в I<E<lt>sys/sem.hE<gt>> и содержащую следующие поля:"

#. type: Plain text
#: man-pages/man7/svipc.7:213
#, no-wrap
msgid ""
"struct semid_ds {\n"
"    struct ipc_perm sem_perm;\n"
"    time_t          sem_otime;   /* last operation time */\n"
"    time_t          sem_ctime;   /* last change time */\n"
"    unsigned long   sem_nsems;   /* count of sems in set */\n"
"};\n"
msgstr "struct semid_ds {\n    struct ipc_perm sem_perm;\n    time_t          sem_otime;   /* время последней операции */\n    time_t          sem_ctime;   /* время последнего изменения */\n    unsigned long   sem_nsems;   /* число семафоров в наборе */\n};\n"

#. type: TP
#: man-pages/man7/svipc.7:215
#, no-wrap
msgid "I<sem_perm>"
msgstr "I<sem_perm>"

#. type: Plain text
#: man-pages/man7/svipc.7:220
msgid ""
"I<ipc_perm> structure that specifies the access permissions on the semaphore"
" set."
msgstr "Структура I<ipc_perm>, определяющая права доступа к набору семафоров."

#. type: TP
#: man-pages/man7/svipc.7:220
#, no-wrap
msgid "I<sem_otime>"
msgstr "I<sem_otime>"

#. type: Plain text
#: man-pages/man7/svipc.7:225
msgid "Time of last B<semop>(2)  system call."
msgstr "Время последнего системного вызова B<semop>(2)."

#. type: TP
#: man-pages/man7/svipc.7:225
#, no-wrap
msgid "I<sem_ctime>"
msgstr "I<sem_ctime>"

#. type: Plain text
#: man-pages/man7/svipc.7:231
msgid ""
"Time of last B<semctl>(2)  system call that changed a member of the above "
"structure or of one semaphore belonging to the set."
msgstr "Время последнего системного вызова B<semctl>(2), который изменил поле указанной структуры или один из семафоров, принадлежащих набору."

#. type: TP
#: man-pages/man7/svipc.7:231
#, no-wrap
msgid "I<sem_nsems>"
msgstr "I<sem_nsems>"

#. type: Plain text
#: man-pages/man7/svipc.7:239
msgid ""
"Number of semaphores in the set.  Each semaphore of the set is referenced by"
" a nonnegative integer ranging from B<0> to I<sem_nsems-1>."
msgstr "Число семафоров в наборе. Каждый семафор описывается неотрицательным целым числом от  B<0> до I<sem_nsems-1>."

#. type: Plain text
#: man-pages/man7/svipc.7:243
msgid ""
"A semaphore is a data structure of type I<struct sem> containing the "
"following members:"
msgstr "Семафор является структурой данных типа I<struct sem>, содержащие следующие поля:"

#.     unsigned short semncnt; /* nr awaiting semval to increase */
#.     unsigned short semzcnt; /* nr awaiting semval = 0 */
#. type: Plain text
#: man-pages/man7/svipc.7:252
#, no-wrap
msgid ""
"struct sem {\n"
"    int semval;  /* semaphore value */\n"
"    int sempid;  /* PID for last operation */\n"
"};\n"
msgstr "struct sem {\n    int semval;  /* значение семафора */\n    int sempid;  /* PID последней операции */\n};\n"

#. type: TP
#: man-pages/man7/svipc.7:254
#, no-wrap
msgid "I<semval>"
msgstr "I<semval>"

#. type: Plain text
#: man-pages/man7/svipc.7:257
msgid "Semaphore value: a nonnegative integer."
msgstr "Значение семафора, неотрицательное целое."

#. type: TP
#: man-pages/man7/svipc.7:257
#, no-wrap
msgid "I<sempid>"
msgstr "I<sempid>"

#. .TP
#. .I semncnt
#. Number of processes suspended awaiting for
#. .I semval
#. to increase.
#. .TP
#. .I semznt
#. Number of processes suspended awaiting for
#. .I semval
#. to become zero.
#. type: Plain text
#: man-pages/man7/svipc.7:271
msgid ""
"ID of the last process that performed a semaphore operation on this "
"semaphore."
msgstr "ID последнего процесса, выполнявшего операцию над семафором."

#. type: SS
#: man-pages/man7/svipc.7:271
#, no-wrap
msgid "Shared memory segments"
msgstr "Сегменты общей памяти"

#. type: Plain text
#: man-pages/man7/svipc.7:279
msgid ""
"A shared memory segment is uniquely identified by a positive integer (its "
"I<shmid>)  and has an associated data structure of type I<struct shmid_ds>, "
"defined in I<E<lt>sys/shm.hE<gt>>, containing the following members:"
msgstr "Сегмент общей памяти уникально идентифицируется положительным целым (I<shmid>) и имеет связанную структуру данных  I<struct shmid_ds>, определённую в I<E<lt>sys/shm.hE<gt>> и содержащую следующие поля:"

#. type: Plain text
#: man-pages/man7/svipc.7:292
#, no-wrap
msgid ""
"struct shmid_ds {\n"
"    struct ipc_perm shm_perm;\n"
"    size_t          shm_segsz;   /* size of segment */\n"
"    pid_t           shm_cpid;    /* PID of creator */\n"
"    pid_t           shm_lpid;    /* PID, last operation */\n"
"    shmatt_t        shm_nattch;  /* no. of current attaches */\n"
"    time_t          shm_atime;   /* time of last attach */\n"
"    time_t          shm_dtime;   /* time of last detach */\n"
"    time_t          shm_ctime;   /* time of last change */\n"
"};\n"
msgstr "struct shmid_ds {\n    struct ipc_perm shm_perm;\n    size_t          shm_segsz;   /* размер сегмента */\n    pid_t           shm_cpid;    /* PID создателя */\n    pid_t           shm_lpid;    /* PID последней операции */\n    shmatt_t        shm_nattch;  /* число текущих подключений */\n    time_t          shm_atime;   /* время последнего подключения */\n    time_t          shm_dtime;   /* время последнего отключения */\n    time_t          shm_ctime;   /* время последнего изменения */\n};\n"

#. type: TP
#: man-pages/man7/svipc.7:294
#, no-wrap
msgid "I<shm_perm>"
msgstr "I<shm_perm>"

#. type: Plain text
#: man-pages/man7/svipc.7:299
msgid ""
"I<ipc_perm> structure that specifies the access permissions on the shared "
"memory segment."
msgstr "Структура I<ipc_perm>, описывающая права доступа к сегменту общей памяти."

#. type: TP
#: man-pages/man7/svipc.7:299
#, no-wrap
msgid "I<shm_segsz>"
msgstr "I<shm_segsz>"

#. type: Plain text
#: man-pages/man7/svipc.7:302
msgid "Size in bytes of the shared memory segment."
msgstr "Размер в байтах сегмента общей памяти."

#. type: TP
#: man-pages/man7/svipc.7:302
#, no-wrap
msgid "I<shm_cpid>"
msgstr "I<shm_cpid>"

#. type: Plain text
#: man-pages/man7/svipc.7:305
msgid "ID of the process that created the shared memory segment."
msgstr "ID процесса, создавшего сегмент общей памяти."

#. type: TP
#: man-pages/man7/svipc.7:305
#, no-wrap
msgid "I<shm_lpid>"
msgstr "I<shm_lpid>"

#. type: Plain text
#: man-pages/man7/svipc.7:312
msgid ""
"ID of the last process that executed a B<shmat>(2)  or B<shmdt>(2)  system "
"call."
msgstr "ID последнего процесса, выполнившего системный вызов B<shmat>(2) или B<shmdt>(2)."

#. type: TP
#: man-pages/man7/svipc.7:312
#, no-wrap
msgid "I<shm_nattch>"
msgstr "I<shm_nattch>"

#. type: Plain text
#: man-pages/man7/svipc.7:315
msgid "Number of current alive attaches for this shared memory segment."
msgstr "Количество текущих подключений для данного сегмента общей памяти."

#. type: TP
#: man-pages/man7/svipc.7:315
#, no-wrap
msgid "I<shm_atime>"
msgstr "I<shm_atime>"

#. type: Plain text
#: man-pages/man7/svipc.7:320
msgid "Time of the last B<shmat>(2)  system call."
msgstr "Время последнего системного вызова B<shmat>(2)."

#. type: TP
#: man-pages/man7/svipc.7:320
#, no-wrap
msgid "I<shm_dtime>"
msgstr "I<shm_dtime>"

#. type: Plain text
#: man-pages/man7/svipc.7:325
msgid "Time of the last B<shmdt>(2)  system call."
msgstr "Время последнего системного вызова B<shmdt>(2)."

#. type: TP
#: man-pages/man7/svipc.7:325
#, no-wrap
msgid "I<shm_ctime>"
msgstr "I<shm_ctime>"

#. type: Plain text
#: man-pages/man7/svipc.7:331
msgid "Time of the last B<shmctl>(2)  system call that changed I<shmid_ds>."
msgstr "Время последнего системного вызова B<shmctl>(2), изменившего I<shmid_ds>."

#. type: Plain text
#: man-pages/man7/svipc.7:347
msgid ""
"B<ipcmk>(1), B<ipcrm>(1), B<ipcs>(1), B<ipc>(2), B<msgctl>(2), B<msgget>(2),"
" B<msgrcv>(2), B<msgsnd>(2), B<semctl>(2), B<semget>(2), B<semop>(2), "
"B<shmat>(2), B<shmctl>(2), B<shmdt>(2), B<shmget>(2), B<ftok>(3)"
msgstr "B<ipcmk>(1), B<ipcrm>(1), B<ipcs>(1), B<ipc>(2), B<msgctl>(2), B<msgget>(2), B<msgrcv>(2), B<msgsnd>(2), B<semctl>(2), B<semget>(2), B<semop>(2), B<shmat>(2), B<shmctl>(2), B<shmdt>(2), B<shmget>(2), B<ftok>(3)"

#. type: TH
#: man-pages/man7/signal.7:46
#, no-wrap
msgid "SIGNAL"
msgstr "SIGNAL"

#. type: TH
#: man-pages/man7/signal.7:46
#, no-wrap
msgid "2014-06-13"
msgstr ""

#. type: Plain text
#: man-pages/man7/signal.7:49
msgid "signal - overview of signals"
msgstr "signal - обзор сигналов"

#. type: Plain text
#: man-pages/man7/signal.7:52
msgid ""
"Linux supports both POSIX reliable signals (hereinafter \"standard "
"signals\") and POSIX real-time signals."
msgstr "В Linux поддерживаются надёжные (reliable) сигналы POSIX (далее, «стандартные сигналы») и сигналы реального времени POSIX."

#. type: SS
#: man-pages/man7/signal.7:52
#, no-wrap
msgid "Signal dispositions"
msgstr "Обработчики сигнала"

#. type: Plain text
#: man-pages/man7/signal.7:57
msgid ""
"Each signal has a current I<disposition>, which determines how the process "
"behaves when it is delivered the signal."
msgstr "Каждый сигнал имеет текущий I<обработчик>, который определяет, что будет делать процесс при поступлении сигнала."

#. type: Plain text
#: man-pages/man7/signal.7:60
msgid ""
"The entries in the \"Action\" column of the tables below specify the default"
" disposition for each signal, as follows:"
msgstr "В таблицах далее есть столбец «Действие», в котором указан обработчик по умолчанию для каждого сигнала:"

#. type: IP
#: man-pages/man7/signal.7:60
#, no-wrap
msgid "Term"
msgstr "Term"

#. type: Plain text
#: man-pages/man7/signal.7:62
msgid "Default action is to terminate the process."
msgstr "Действие по умолчанию — завершение процесса."

#. type: IP
#: man-pages/man7/signal.7:62
#, no-wrap
msgid "Ign"
msgstr "Ign"

#. type: Plain text
#: man-pages/man7/signal.7:64
msgid "Default action is to ignore the signal."
msgstr "Действие по умолчанию — игнорирование сигнала."

#. type: IP
#: man-pages/man7/signal.7:64
#, no-wrap
msgid "Core"
msgstr "Core"

#. type: Plain text
#: man-pages/man7/signal.7:67
msgid ""
"Default action is to terminate the process and dump core (see B<core>(5))."
msgstr "Действие по умолчанию — завершение процесса и вывод дампа в файл (смотрите B<core>(5))."

#. type: IP
#: man-pages/man7/signal.7:67
#, no-wrap
msgid "Stop"
msgstr "Stop"

#. type: Plain text
#: man-pages/man7/signal.7:69
msgid "Default action is to stop the process."
msgstr "Действие по умолчанию — остановка процесса."

#. type: IP
#: man-pages/man7/signal.7:69
#, no-wrap
msgid "Cont"
msgstr "Cont"

#. type: Plain text
#: man-pages/man7/signal.7:71
msgid "Default action is to continue the process if it is currently stopped."
msgstr "Действие по умолчанию — продолжение работы процесса, если он в данный момент остановлен."

#. type: Plain text
#: man-pages/man7/signal.7:93
msgid ""
"A process can change the disposition of a signal using B<sigaction>(2)  or "
"B<signal>(2).  (The latter is less portable when establishing a signal "
"handler; see B<signal>(2)  for details.)  Using these system calls, a "
"process can elect one of the following behaviors to occur on delivery of the"
" signal: perform the default action; ignore the signal; or catch the signal "
"with a I<signal handler>, a programmer-defined function that is "
"automatically invoked when the signal is delivered.  (By default, the signal"
" handler is invoked on the normal process stack.  It is possible to arrange "
"that the signal handler uses an alternate stack; see B<sigaltstack>(2)  for "
"a discussion of how to do this and when it might be useful.)"
msgstr "Процесс может изменить обработчик сигнала с помощью B<sigaction>(2) или B<signal>(2) (менее переносим; дополнительную информацию смотрите в B<signal>(2)). Используя данные системные вызовы процесс может выбрать одно из следующих действий при получении сигнала: выполнить действие по умолчанию, игнорировать сигнал, поймать сигнал I<обработчиком сигнала> — функцией, задаваемой программистом, которая автоматически вызывается при получении сигнала (по умолчанию обработчик сигнала использует обычный стек процесса. Возможно сделать так, чтобы обработчик сигнала использовал альтернативный стек; как это делается и когда это может быть полезно смотрите в B<sigaltstack>(2))."

#. type: Plain text
#: man-pages/man7/signal.7:97
msgid ""
"The signal disposition is a per-process attribute: in a multithreaded "
"application, the disposition of a particular signal is the same for all "
"threads."
msgstr "Реакция на сигналы является атрибутом процесса: в многонитиевом приложении реакция на определённый сигнал одинакова для всех нитей."

#. type: Plain text
#: man-pages/man7/signal.7:105
msgid ""
"A child created via B<fork>(2)  inherits a copy of its parent's signal "
"dispositions.  During an B<execve>(2), the dispositions of handled signals "
"are reset to the default; the dispositions of ignored signals are left "
"unchanged."
msgstr "Потомок, созданный с помощью B<fork>(2), наследует реакцию на сигналы от своего родителя. При B<execve>(2) реакция на сигналы устанавливается в значение по умолчанию; реакция на игнорируемые сигналы не изменяется."

#. type: SS
#: man-pages/man7/signal.7:105
#, no-wrap
msgid "Sending a signal"
msgstr "Отправка сигнала"

#. type: Plain text
#: man-pages/man7/signal.7:108
msgid ""
"The following system calls and library functions allow the caller to send a "
"signal:"
msgstr "Для отправки сигнала можно использовать следующие системные вызовы и библиотечные функции:"

#. type: TP
#: man-pages/man7/signal.7:108
#, no-wrap
msgid "B<raise>(3)"
msgstr "B<raise>(3)"

#. type: Plain text
#: man-pages/man7/signal.7:111
msgid "Sends a signal to the calling thread."
msgstr "Посылает сигнал вызвавшей нити."

#. type: TP
#: man-pages/man7/signal.7:111
#, no-wrap
msgid "B<kill>(2)"
msgstr "B<kill>(2)"

#. type: Plain text
#: man-pages/man7/signal.7:116
msgid ""
"Sends a signal to a specified process, to all members of a specified process"
" group, or to all processes on the system."
msgstr "Посылает сигнал указанному процессу, всем членам указанной группы процессов или всем процессам в системе."

#. type: TP
#: man-pages/man7/signal.7:116
#, no-wrap
msgid "B<killpg>(2)"
msgstr "B<killpg>(2)"

#. type: Plain text
#: man-pages/man7/signal.7:119
msgid "Sends a signal to all of the members of a specified process group."
msgstr "Посылает сигнал всем членам указанной группы процессов."

#. type: TP
#: man-pages/man7/signal.7:119
#, no-wrap
msgid "B<pthread_kill>(3)"
msgstr "B<pthread_kill>(3)"

#. type: Plain text
#: man-pages/man7/signal.7:123
msgid ""
"Sends a signal to a specified POSIX thread in the same process as the "
"caller."
msgstr "Посылает сигнал указанной нити POSIX в том же процессе, что и вызывающий."

#. type: TP
#: man-pages/man7/signal.7:123
#, no-wrap
msgid "B<tgkill>(2)"
msgstr "B<tgkill>(2)"

#. type: Plain text
#: man-pages/man7/signal.7:128
msgid ""
"Sends a signal to a specified thread within a specific process.  (This is "
"the system call used to implement B<pthread_kill>(3).)"
msgstr "Посылает сигнал указанной нити в указанном процессе (данный системный вызов используется в реализации B<pthread_kill>(3))."

#. type: TP
#: man-pages/man7/signal.7:128
#, no-wrap
msgid "B<sigqueue>(3)"
msgstr "B<sigqueue>(3)"

#. type: Plain text
#: man-pages/man7/signal.7:131
msgid ""
"Sends a real-time signal with accompanying data to a specified process."
msgstr "Посылает сигнал реального времени указанному процессу с сопроводительными данными."

#. type: SS
#: man-pages/man7/signal.7:131
#, no-wrap
msgid "Waiting for a signal to be caught"
msgstr "Ожидание сигнала для обработки"

#. type: Plain text
#: man-pages/man7/signal.7:135
msgid ""
"The following system calls suspend execution of the calling process or "
"thread until a signal is caught (or an unhandled signal terminates the "
"process):"
msgstr "Следующие системные вызовы приостанавливают выполнение вызывающего процесса или нити до тех пор, пока не будет пойман сигнал (или необработанный сигнал не завершит процесс):"

#. type: TP
#: man-pages/man7/signal.7:135
#, no-wrap
msgid "B<pause>(2)"
msgstr "B<pause>(2)"

#. type: Plain text
#: man-pages/man7/signal.7:138
msgid "Suspends execution until any signal is caught."
msgstr "Приостанавливает выполнение до тех пор, пока не будет пойман любой сигнал."

#. type: TP
#: man-pages/man7/signal.7:138
#, no-wrap
msgid "B<sigsuspend>(2)"
msgstr "B<sigsuspend>(2)"

#. type: Plain text
#: man-pages/man7/signal.7:142
msgid ""
"Temporarily changes the signal mask (see below) and suspends execution until"
" one of the unmasked signals is caught."
msgstr "Временно изменяет маску сигналов (смотрите далее) и приостанавливает выполнение до получения одного из незамаскированных сигналов."

#. type: SS
#: man-pages/man7/signal.7:142
#, no-wrap
msgid "Synchronously accepting a signal"
msgstr "Синхронный приём сигнала"

#. type: Plain text
#: man-pages/man7/signal.7:149
msgid ""
"Rather than asynchronously catching a signal via a signal handler, it is "
"possible to synchronously accept the signal, that is, to block execution "
"until the signal is delivered, at which point the kernel returns information"
" about the signal to the caller.  There are two general ways to do this:"
msgstr "В отличие от асинхронного получения сигнала через обработчик, возможно синхронно получить сигнал, то есть блокировать выполнение до поступления сигнала в некоторой точке, в которой ядро вернёт информацию о сигнале вызывающему. Для этого существует два пути:"

#. type: IP
#: man-pages/man7/signal.7:149 man-pages/man7/signal.7:157
#: man-pages/man7/signal.7:615 man-pages/man7/signal.7:617
#: man-pages/man7/signal.7:638 man-pages/man7/signal.7:653
#: man-pages/man7/signal.7:657 man-pages/man7/signal.7:664
#: man-pages/man7/signal.7:682 man-pages/man7/signal.7:688
#: man-pages/man7/signal.7:695 man-pages/man7/signal.7:700
#: man-pages/man7/signal.7:719 man-pages/man7/signal.7:733
#: man-pages/man7/signal.7:744 man-pages/man7/signal.7:751
#: man-pages/man7/signal.7:760 man-pages/man7/signal.7:768
#: man-pages/man7/signal.7:774 man-pages/man7/signal.7:779
#: man-pages/man7/signal.7:799 man-pages/man7/signal.7:813
#: man-pages/man7/signal.7:827 man-pages/man7/signal.7:830
#: man-pages/man7/signal.7:833 man-pages/man7/signal.7:836
#: man-pages/man7/signal.7:841 man-pages/man7/signal.7:847
#: man-pages/man7/signal.7:851
#, no-wrap
msgid "*"
msgstr "*"

#. type: Plain text
#: man-pages/man7/signal.7:157
msgid ""
"B<sigwaitinfo>(2), B<sigtimedwait>(2), and B<sigwait>(3)  suspend execution "
"until one of the signals in a specified set is delivered.  Each of these "
"calls returns information about the delivered signal."
msgstr "С помощью B<sigwaitinfo>(2), B<sigtimedwait>(2) и B<sigwait>(3). Они приостанавливают выполнение до поступления одного из заданного набора сигналов. Каждый из этих вызовов возвращает информацию о полученном сигнале."

#. type: Plain text
#: man-pages/man7/signal.7:170
msgid ""
"B<signalfd>(2)  returns a file descriptor that can be used to read "
"information about signals that are delivered to the caller.  Each B<read>(2)"
"  from this file descriptor blocks until one of the signals in the set "
"specified in the B<signalfd>(2)  call is delivered to the caller.  The "
"buffer returned by B<read>(2)  contains a structure describing the signal."
msgstr "С помощью B<signalfd>(2). Данный вызов возвращает файловый дескриптор, который можно использовать для чтения информации о сигналах, доставляемых вызывающему. Каждое выполнение B<read>(2) с этим файловым дескриптором блокируется до тех пор, пока один из сигналов набора, указанного в вызове B<signalfd>(2), не будет послан вызывающему. В возвращаемом B<read>(2) буфере содержится структура, описывающая сигнал."

#. type: SS
#: man-pages/man7/signal.7:170
#, no-wrap
msgid "Signal mask and pending signals"
msgstr "Сигнальная маска и ожидающие сигналы"

#. type: Plain text
#: man-pages/man7/signal.7:177
msgid ""
"A signal may be I<blocked>, which means that it will not be delivered until "
"it is later unblocked.  Between the time when it is generated and when it is"
" delivered a signal is said to be I<pending>."
msgstr "Сигнал может быть I<заблокирован>. Это означает, что он не будет доставлен до тех пор, пока не будет разблокирован. В промежуток времени от генерации сигнала и до его доставки о сигнале говорят как об I<ожидающем>."

#. type: Plain text
#: man-pages/man7/signal.7:186
msgid ""
"Each thread in a process has an independent I<signal mask>, which indicates "
"the set of signals that the thread is currently blocking.  A thread can "
"manipulate its signal mask using B<pthread_sigmask>(3).  In a traditional "
"single-threaded application, B<sigprocmask>(2)  can be used to manipulate "
"the signal mask."
msgstr "В каждой нити процесса имеется независимая I<сигнальная маска>, определяющая набор сигналов, которые нить, в данный момент, блокирует. Нить может управлять сигнальной маской с помощью B<pthread_sigmask>(3). В обычном однонитиевом приложении для работы с сигнальной маской можно использовать вызов B<sigprocmask>(2)."

#. type: Plain text
#: man-pages/man7/signal.7:192
msgid ""
"A child created via B<fork>(2)  inherits a copy of its parent's signal mask;"
" the signal mask is preserved across B<execve>(2)."
msgstr "Потомок, создаваемый с помощью B<fork>(2), наследует копию родительской маски сигналов; маска сигналов сохраняется при вызове B<execve>(2)."

#. type: Plain text
#: man-pages/man7/signal.7:209
msgid ""
"A signal may be generated (and thus pending)  for a process as a whole "
"(e.g., when sent using B<kill>(2))  or for a specific thread (e.g., certain "
"signals, such as B<SIGSEGV> and B<SIGFPE>, generated as a consequence of "
"executing a specific machine-language instruction are thread directed, as "
"are signals targeted at a specific thread using B<pthread_kill>(3)).  A "
"process-directed signal may be delivered to any one of the threads that does"
" not currently have the signal blocked.  If more than one of the threads has"
" the signal unblocked, then the kernel chooses an arbitrary thread to which "
"to deliver the signal."
msgstr "Сигнал может быть сгенерирован (а значит и стать ожидающим) как для всего процесса (например, при отправке с помощью B<kill>(2)) так и для отдельной нити (например, некоторые сигналы, такие как B<SIGSEGV> и B<SIGFPE>, сгенерированные в следствии выполнения определённой инструкции на машинном языке в самой нити, или сигналы, направленные определённой нити с помощью B<pthread_kill>(3)). Направленный процессу сигнал может быть доставлен в любую из нитей, у которых сигнал не заблокирован. Если имеется несколько таких нитей, то ядро выбирает произвольную нить, которой и доставит сигнал."

#. type: Plain text
#: man-pages/man7/signal.7:216
msgid ""
"A thread can obtain the set of signals that it currently has pending using "
"B<sigpending>(2).  This set will consist of the union of the set of pending "
"process-directed signals and the set of signals pending for the calling "
"thread."
msgstr "Нить может получить набор сигналов, которые находятся в состоянии ожидания с помощью вызова B<sigpending>(2). Этот набор будет состоять из объединения набора ожидающих сигналов, направленных процессу, и набора ожидающих сигналов для вызвавшей нити."

#. type: Plain text
#: man-pages/man7/signal.7:222
msgid ""
"A child created via B<fork>(2)  initially has an empty pending signal set; "
"the pending signal set is preserved across an B<execve>(2)."
msgstr "Потомок, созданный с помощью B<fork>(2), первоначально имеет пустой набор ожидающих сигналов; набор ожидающих сигналов сохраняется при вызове B<execve>(2)."

#. type: SS
#: man-pages/man7/signal.7:222
#, no-wrap
msgid "Standard signals"
msgstr "Стандартные сигналы"

#. type: Plain text
#: man-pages/man7/signal.7:234
msgid ""
"Linux supports the standard signals listed below.  Several signal numbers "
"are architecture-dependent, as indicated in the \"Value\" column.  (Where "
"three values are given, the first one is usually valid for alpha and sparc, "
"the middle one for x86, arm, and most other architectures, and the last one "
"for mips.  (Values for parisc are I<not> shown; see the Linux kernel source "
"for signal numbering on that architecture.)  A - denotes that a signal is "
"absent on the corresponding architecture.)"
msgstr "Linux поддерживает стандартные сигналы, перечисленные далее. Номера некоторых сигналов зависят от используемой архитектуры, это указано в столбце «Номер» (если указано три значения, то первое, обычно, применяется в alpha и sparc, второе — в x86, arm и в большинстве других архитектур, и третье — в  mips. Номера для parisc I<не> показаны; номера для этой архитектуры смотрите в исходном коде ядра Linux. Символ A означает, что сигнал отсутствует в соответствующей архитектуре)."

#. type: Plain text
#: man-pages/man7/signal.7:236
msgid "First the signals described in the original POSIX.1-1990 standard."
msgstr "Сначала рассмотрим сигналы, описанные в стандарте POSIX.1-1990."

#. type: tbl table
#: man-pages/man7/signal.7:240 man-pages/man7/signal.7:276
#: man-pages/man7/signal.7:305
#, no-wrap
msgid "Signal\tValue\tAction\tComment\n"
msgstr "Сигнал\tНомер\tДействие\tКомментарий\n"

#. type: tbl table
#: man-pages/man7/signal.7:241
#, no-wrap
msgid "SIGHUP\t\\01\tTerm\tHangup detected on controlling terminal\n"
msgstr "SIGHUP\t\\01\tTerm\tОбнаружен обрыв связи с управляющим\n"

#. type: tbl table
#: man-pages/man7/signal.7:242
#, no-wrap
msgid "\t\t\tor death of controlling process\n"
msgstr "\t\t\tтерминалом, либо завершение управляющего\n\t\t\tтерминалом процесса\n"

#. type: tbl table
#: man-pages/man7/signal.7:243
#, no-wrap
msgid "SIGINT\t\\02\tTerm\tInterrupt from keyboard\n"
msgstr "SIGINT\t\\02\tTerm\tПрерывание с клавиатуры\n"

#. type: tbl table
#: man-pages/man7/signal.7:244
#, no-wrap
msgid "SIGQUIT\t\\03\tCore\tQuit from keyboard\n"
msgstr "SIGQUIT\t\\03\tCore\tВыход с клавиатуры\n"

#. type: tbl table
#: man-pages/man7/signal.7:245
#, no-wrap
msgid "SIGILL\t\\04\tCore\tIllegal Instruction\n"
msgstr "SIGILL\t\\04\tCore\tНесуществующая инструкция\n"

#. type: tbl table
#: man-pages/man7/signal.7:246
#, no-wrap
msgid "SIGABRT\t\\06\tCore\tAbort signal from B<abort>(3)\n"
msgstr "SIGABRT\t\\06\tCore\tСигнал аварии (abort), посланный\n\t\t\tB<abort>(3)\n"

#. type: tbl table
#: man-pages/man7/signal.7:247
#, no-wrap
msgid "SIGFPE\t\\08\tCore\tFloating point exception\n"
msgstr "SIGFPE\t\\08\tCore\tОшибка операций с плавающей запятой\n"

#. type: tbl table
#: man-pages/man7/signal.7:248
#, no-wrap
msgid "SIGKILL\t\\09\tTerm\tKill signal\n"
msgstr "SIGKILL\t\\09\tTerm\tKill-сигнал\n"

#. type: tbl table
#: man-pages/man7/signal.7:249
#, no-wrap
msgid "SIGSEGV\t11\tCore\tInvalid memory reference\n"
msgstr "SIGSEGV\t11\tCore\tНекорректная ссылка в память\n"

#. type: tbl table
#: man-pages/man7/signal.7:250
#, no-wrap
msgid "SIGPIPE\t13\tTerm\tBroken pipe: write to pipe with no\n"
msgstr "SIGPIPE\t13\tTerm\tОборванный канал: запись в канал,\n"

#. type: tbl table
#: man-pages/man7/signal.7:251
#, no-wrap
msgid "\t\t\treaders\n"
msgstr "\t\t\tиз которого не читают\n"

#. type: tbl table
#: man-pages/man7/signal.7:252
#, no-wrap
msgid "SIGALRM\t14\tTerm\tTimer signal from B<alarm>(2)\n"
msgstr "SIGALRM\t14\tTerm\tСигнал таймера, посланный B<alarm>(2)\n"

#. type: tbl table
#: man-pages/man7/signal.7:253
#, no-wrap
msgid "SIGTERM\t15\tTerm\tTermination signal\n"
msgstr "SIGTERM\t15\tTerm\tСигнал завершения\n"

#. type: tbl table
#: man-pages/man7/signal.7:254
#, no-wrap
msgid "SIGUSR1\t30,10,16\tTerm\tUser-defined signal 1\n"
msgstr "SIGUSR1\t30,10,16\tTerm\tПервый сигнал, определяемый\n\t\t\tпользователем\n"

#. type: tbl table
#: man-pages/man7/signal.7:255
#, no-wrap
msgid "SIGUSR2\t31,12,17\tTerm\tUser-defined signal 2\n"
msgstr "SIGUSR2\t31,12,17\tTerm\tВторой сигнал, определяемый\n\t\t\tпользователем\n"

#. type: tbl table
#: man-pages/man7/signal.7:256
#, no-wrap
msgid "SIGCHLD\t20,17,18\tIgn\tChild stopped or terminated\n"
msgstr "SIGCHLD\t20,17,18\tIgn\tПотомок остановлен или прекратил\n\t\t\tвыполнение\n"

#. type: tbl table
#: man-pages/man7/signal.7:257
#, no-wrap
msgid "SIGCONT\t19,18,25\tCont\tContinue if stopped\n"
msgstr "SIGCONT\t19,18,25\tCont\tПродолжить выполнение, если остановлен\n"

#. type: tbl table
#: man-pages/man7/signal.7:258
#, no-wrap
msgid "SIGSTOP\t17,19,23\tStop\tStop process\n"
msgstr "SIGSTOP\t17,19,23\tStop\tОстановить выполнение процесса\n"

#. type: tbl table
#: man-pages/man7/signal.7:259
#, no-wrap
msgid "SIGTSTP\t18,20,24\tStop\tStop typed at terminal\n"
msgstr "SIGTSTP\t18,20,24\tStop\tОстанов введён с терминала\n"

#. type: tbl table
#: man-pages/man7/signal.7:260
#, no-wrap
msgid "SIGTTIN\t21,21,26\tStop\tTerminal input for background process\n"
msgstr "SIGTTIN\t21,21,26\tStop\tВвод с терминала у фонового процесса\n"

#. type: tbl table
#: man-pages/man7/signal.7:261
#, no-wrap
msgid "SIGTTOU\t22,22,27\tStop\tTerminal output for background process\n"
msgstr "SIGTTOU\t22,22,27\tStop\tВывод на терминал у фонового процесса\n"

#. type: Plain text
#: man-pages/man7/signal.7:269
msgid ""
"The signals B<SIGKILL> and B<SIGSTOP> cannot be caught, blocked, or ignored."
msgstr "Сигналы B<SIGKILL> и B<SIGSTOP> нельзя поймать, заблокировать или проигнорировать."

#. type: Plain text
#: man-pages/man7/signal.7:272
msgid ""
"Next the signals not in the POSIX.1-1990 standard but described in SUSv2 and"
" POSIX.1-2001."
msgstr "Далее приведены сигналы, не входящие в POSIX.1-1990, но описанные в SUSv2 и POSIX.1-2001."

#. type: tbl table
#: man-pages/man7/signal.7:277
#, no-wrap
msgid "SIGBUS\t10,7,10\tCore\tBus error (bad memory access)\n"
msgstr "SIGBUS\t10,7,10\tCore\tОшибка шины (некорректный адрес\n\t\t\tдоступа)\n"

#. type: tbl table
#: man-pages/man7/signal.7:278
#, no-wrap
msgid "SIGPOLL\t\tTerm\tPollable event (Sys V).\n"
msgstr "SIGPOLL\t\tTerm\tСобытие опроса (Sys V).\n"

#. type: tbl table
#: man-pages/man7/signal.7:279
#, no-wrap
msgid "\t\t\tSynonym for B<SIGIO>\n"
msgstr "\t\t\tСиноним B<SIGIO>\n"

#. type: tbl table
#: man-pages/man7/signal.7:280
#, no-wrap
msgid "SIGPROF\t27,27,29\tTerm\tProfiling timer expired\n"
msgstr "SIGPROF\t27,27,29\tTerm\tЗакончилось время профилирующего\n\t\t\tтаймера\n"

#. type: tbl table
#: man-pages/man7/signal.7:281
#, no-wrap
msgid "SIGSYS\t12,31,12\tCore\tBad argument to routine (SVr4)\n"
msgstr "SIGSYS\t12,31,12\tCore\tНедопустимый аргумент для процедуры\n\t\t\t(SVr4)\n"

#. type: tbl table
#: man-pages/man7/signal.7:282
#, no-wrap
msgid "SIGTRAP\t5\tCore\tTrace/breakpoint trap\n"
msgstr "SIGTRAP\t5\tCore\tЛовушка трассировки/отладки\n"

#. type: tbl table
#: man-pages/man7/signal.7:283
#, no-wrap
msgid "SIGURG\t16,23,21\tIgn\tUrgent condition on socket (4.2BSD)\n"
msgstr "SIGURG\t16,23,21\tIgn\tПриоритетное состояние у сокета\n\t\t\t(4.2BSD)\n"

#. type: tbl table
#: man-pages/man7/signal.7:284
#, no-wrap
msgid "SIGVTALRM\t26,26,28\tTerm\tVirtual alarm clock (4.2BSD)\n"
msgstr "SIGVTALRM\t26,26,28\tTerm\tВиртуальный таймер (4.2BSD)\n"

#. type: tbl table
#: man-pages/man7/signal.7:285
#, no-wrap
msgid "SIGXCPU\t24,24,30\tCore\tCPU time limit exceeded (4.2BSD)\n"
msgstr "SIGXCPU\t24,24,30\tCore\tПревышено время работы на ЦП (4.2BSD)\n"

#. type: tbl table
#: man-pages/man7/signal.7:286
#, no-wrap
msgid "SIGXFSZ\t25,25,31\tCore\tFile size limit exceeded (4.2BSD)\n"
msgstr "SIGXFSZ\t25,25,31\tCore\tПревышен размер файла (4.2BSD)\n"

#. type: Plain text
#: man-pages/man7/signal.7:299
msgid ""
"Up to and including Linux 2.2, the default behavior for B<SIGSYS>, "
"B<SIGXCPU>, B<SIGXFSZ>, and (on architectures other than SPARC and MIPS)  "
"B<SIGBUS> was to terminate the process (without a core dump).  (On some "
"other UNIX systems the default action for B<SIGXCPU> and B<SIGXFSZ> is to "
"terminate the process without a core dump.)  Linux 2.4 conforms to the "
"POSIX.1-2001 requirements for these signals, terminating the process with a "
"core dump."
msgstr "В Linux до версии 2.2 включительно поведением по умолчанию для сигналов B<SIGSYS>, B<SIGXCPU>, B<SIGXFSZ> и B<SIGBUS> (на всех архитектурах кроме SPARC и MIPS) было завершение процесса без создания дампа (в некоторых системах UNIX действием по умолчанию для B<SIGXCPU> и B<SIGXFSZ> является завершение процесса без создания дампа). Linux версии 2.4 соответствует требованиям POSIX.1-2001 для этих сигналов и завершает процесс с созданием дампа."

#. type: Plain text
#: man-pages/man7/signal.7:301
msgid "Next various other signals."
msgstr "Некоторые другие сигналы."

#. type: tbl table
#: man-pages/man7/signal.7:306
#, no-wrap
msgid "SIGIOT\t6\tCore\tIOT trap. A synonym for B<SIGABRT>\n"
msgstr "SIGIOT\t6\tCore\tЛовушка IOT. Синоним B<SIGABRT>\n"

#. type: tbl table
#: man-pages/man7/signal.7:307
#, no-wrap
msgid "SIGEMT\t7,-,7\tTerm\n"
msgstr "SIGEMT\t7,-,7\tTerm\n"

#. type: tbl table
#: man-pages/man7/signal.7:308
#, no-wrap
msgid "SIGSTKFLT\t-,16,-\tTerm\tStack fault on coprocessor (unused)\n"
msgstr "SIGSTKFLT\t-,16,-\tTerm\tОшибка стека на сопроцессоре\n\t\t\t(не используется)\n"

#. type: tbl table
#: man-pages/man7/signal.7:309
#, no-wrap
msgid "SIGIO\t23,29,22\tTerm\tI/O now possible (4.2BSD)\n"
msgstr "SIGIO\t23,29,22\tTerm\tТеперь возможен ввод/вывод (4.2BSD)\n"

#. type: tbl table
#: man-pages/man7/signal.7:310
#, no-wrap
msgid "SIGCLD\t-,-,18\tIgn\tA synonym for B<SIGCHLD>\n"
msgstr "SIGCLD\t-,-,18\tIgn\tСиноним B<SIGCHLD>\n"

#. type: tbl table
#: man-pages/man7/signal.7:311
#, no-wrap
msgid "SIGPWR\t29,30,19\tTerm\tPower failure (System V)\n"
msgstr "SIGPWR\t29,30,19\tTerm\tОтказ системы питания (System V)\n"

#. type: tbl table
#: man-pages/man7/signal.7:312
#, no-wrap
msgid "SIGINFO\t29,-,-\t\tA synonym for B<SIGPWR>\n"
msgstr "SIGINFO\t29,-,-\t\tСиноним B<SIGPWR>\n"

#. type: tbl table
#: man-pages/man7/signal.7:313
#, no-wrap
msgid "SIGLOST\t-,-,-\tTerm\tFile lock lost (unused)\n"
msgstr "SIGLOST\t-,-,-\tTerm\tУтрачена блокировка файла (не используется)\n"

#. type: tbl table
#: man-pages/man7/signal.7:314
#, no-wrap
msgid "SIGWINCH\t28,28,20\tIgn\tWindow resize signal (4.3BSD, Sun)\n"
msgstr "SIGWINCH\t28,28,20\tIgn\tСигнал изменения размера окна\n\t\t\t(4.3BSD, Sun)\n"

#. type: tbl table
#: man-pages/man7/signal.7:315
#, no-wrap
msgid "SIGUNUSED\t-,31,-\tCore\tSynonymous with B<SIGSYS>\n"
msgstr "SIGUNUSED\t-,31,-\tCore\tСиноним B<SIGSYS>\n"

#. type: Plain text
#: man-pages/man7/signal.7:325
msgid ""
"(Signal 29 is B<SIGINFO> / B<SIGPWR> on an alpha but B<SIGLOST> on a sparc.)"
msgstr "Сигнал с номером 29 на alpha соответствует B<SIGINFO> / B<SIGPWR>, а на sparc соответствует B<SIGLOST>."

#. type: Plain text
#: man-pages/man7/signal.7:331
msgid ""
"B<SIGEMT> is not specified in POSIX.1-2001, but nevertheless appears on most"
" other UNIX systems, where its default action is typically to terminate the "
"process with a core dump."
msgstr "Сигнал B<SIGEMT> не определён в POSIX.1-2001, но, тем не менее, появляется почти во всех системах UNIX, где действием по умолчанию для него является завершение процесса с созданием дампа."

#. type: Plain text
#: man-pages/man7/signal.7:335
msgid ""
"B<SIGPWR> (which is not specified in POSIX.1-2001) is typically ignored by "
"default on those other UNIX systems where it appears."
msgstr "Сигнал B<SIGPWR> (не определён в POSIX.1-2001) по умолчанию, обычно, игнорируется (в других системах UNIX)."

#. type: Plain text
#: man-pages/man7/signal.7:339
msgid ""
"B<SIGIO> (which is not specified in POSIX.1-2001) is ignored by default on "
"several other UNIX systems."
msgstr "Для сигнала B<SIGIO> (не определён в POSIX.1-2001) в других системах UNIX действием по умолчанию является игнорирование."

#.  parisc is the only exception: SIGSYS is 12, SIGUNUSED is 31
#. type: Plain text
#: man-pages/man7/signal.7:346
msgid ""
"Where defined, B<SIGUNUSED> is synonymous with B<SIGSYS> on most "
"architectures."
msgstr "Если определён сигнал B<SIGUNUSED>, то он является синонимом B<SIGSYS> для большинства архитектур."

#. type: SS
#: man-pages/man7/signal.7:346
#, no-wrap
msgid "Real-time signals"
msgstr "Сигналы реального времени"

#. type: Plain text
#: man-pages/man7/signal.7:356
msgid ""
"Linux supports real-time signals as originally defined in the POSIX.1b real-"
"time extensions (and now included in POSIX.1-2001).  The range of supported "
"real-time signals is defined by the macros B<SIGRTMIN> and B<SIGRTMAX>.  "
"POSIX.1-2001 requires that an implementation support at least "
"B<_POSIX_RTSIG_MAX> (8) real-time signals."
msgstr "Linux поддерживает сигналы реального времени согласно первоначальному описанию расширений реального времени в POSIX.1b (теперь включено в POSIX.1-2001). Диапазон поддерживаемых сигналов реального времени определяется макросами B<SIGRTMIN> и B<SIGRTMAX>. Согласно POSIX.1-2001 требуется, чтобы реализация поддерживала не менее B<_POSIX_RTSIG_MAX> (8) сигналов реального времени."

#. type: Plain text
#: man-pages/man7/signal.7:378
msgid ""
"The Linux kernel supports a range of 32 different real-time signals, "
"numbered 33 to 64.  However, the glibc POSIX threads implementation "
"internally uses two (for NPTL) or three (for LinuxThreads) real-time signals"
" (see B<pthreads>(7)), and adjusts the value of B<SIGRTMIN> suitably (to 34 "
"or 35).  Because the range of available real-time signals varies according "
"to the glibc threading implementation (and this variation can occur at run "
"time according to the available kernel and glibc), and indeed the range of "
"real-time signals varies across UNIX systems, programs should I<never refer "
"to real-time signals using hard-coded numbers>, but instead should always "
"refer to real-time signals using the notation B<SIGRTMIN>+n, and include "
"suitable (run-time) checks that B<SIGRTMIN>+n does not exceed B<SIGRTMAX>."
msgstr "Ядро Linux поддерживает 32 таких сигнала, начиная с номера 32 до номера 63. Однако внутри реализации нитей POSIX в glibc используется два (для NPTL) или три (для LinuxThreads) сигнала реального времени (смотрите B<pthreads>(7)), а значение B<SIGRTMIN> корректируется должным образом (до 34 или 35). Так как диапазон доступных сигналов реального времени различается в зависимости от реализации нитей в glibc (и это может происходить во время выполнения при смене ядра и glibc), и, более того, диапазон сигналов реального времени различен в разных системах UNIX, то программы I<никогда не должны задавать сигналы реального времени по номерам>, а вместо этого всегда должны записывать их в виде B<SIGRTMIN>+n и выполнять проверку (во время выполнения), что B<SIGRTMIN>+n не превышает B<SIGRTMAX>."

#. type: Plain text
#: man-pages/man7/signal.7:382
msgid ""
"Unlike standard signals, real-time signals have no predefined meanings: the "
"entire set of real-time signals can be used for application-defined "
"purposes."
msgstr "В отличие от стандартных сигналов, сигналы реального времени не имеют предопределенного назначения: весь набор сигналов реального времени приложения могут использовать так, как им нужно."

#. type: Plain text
#: man-pages/man7/signal.7:385
msgid ""
"The default action for an unhandled real-time signal is to terminate the "
"receiving process."
msgstr "Действием по умолчанию для необработанных сигналов реального времени является завершение процесса (terminate)."

#. type: Plain text
#: man-pages/man7/signal.7:387
msgid "Real-time signals are distinguished by the following:"
msgstr "Сигналы реального времени отличаются от обычных в следующем:"

#. type: Plain text
#: man-pages/man7/signal.7:391
msgid ""
"Multiple instances of real-time signals can be queued.  By contrast, if "
"multiple instances of a standard signal are delivered while that signal is "
"currently blocked, then only one instance is queued."
msgstr "В очередь можно добавлять несколько экземпляров одного сигнала реального времени. В случае со стандартными сигналами, если доставляется несколько экземпляров сигнала, в то время как этот тип сигнала в данный момент заблокирован, то только один экземпляр будет добавлен в очередь."

#. type: Plain text
#: man-pages/man7/signal.7:411
msgid ""
"If the signal is sent using B<sigqueue>(3), an accompanying value (either an"
" integer or a pointer) can be sent with the signal.  If the receiving "
"process establishes a handler for this signal using the B<SA_SIGINFO> flag "
"to B<sigaction>(2), then it can obtain this data via the I<si_value> field "
"of the I<siginfo_t> structure passed as the second argument to the handler."
"  Furthermore, the I<si_pid> and I<si_uid> fields of this structure can be "
"used to obtain the PID and real user ID of the process sending the signal."
msgstr "Если сигнал отправляется с помощью B<sigqueue>(3), то с сигналом может быть отправлено некоторое значение (целочисленное, либо указатель). Если принимающий процесс устанавливает обработчик для сигнала, используя флаг B<SA_SIGINFO> и вызов B<sigaction>(2), то он может получить это значение через поле I<si_value> структуры I<siginfo_t>, переданной обработчику в виде второго аргумента. Кроме этого, поля I<si_pid> и I<si_uid> данной структуры можно использовать для получения идентификатора процесса и реального идентификатора пользователя, отправившего сигнал."

#. type: Plain text
#: man-pages/man7/signal.7:420
msgid ""
"Real-time signals are delivered in a guaranteed order.  Multiple real-time "
"signals of the same type are delivered in the order they were sent.  If "
"different real-time signals are sent to a process, they are delivered "
"starting with the lowest-numbered signal.  (I.e., low-numbered signals have "
"highest priority.)  By contrast, if multiple standard signals are pending "
"for a process, the order in which they are delivered is unspecified."
msgstr "Сигналы реального времени доставляются точно в порядке поступления. Несколько сигналов одного типа доставляются в порядке, определяемых их отправлением. Если процессу отправлено несколько разных сигналов реального времени, то порядок их доставки начинается с сигнала с наименьшим номером (то есть сигналы с наименьшим номером имеют наивысший приоритет). Порядок же для стандартных сигналов в такой ситуации не определён."

#. type: Plain text
#: man-pages/man7/signal.7:425
msgid ""
"If both standard and real-time signals are pending for a process, POSIX "
"leaves it unspecified which is delivered first.  Linux, like many other "
"implementations, gives priority to standard signals in this case."
msgstr "Если процессу передан и стандартный сигнал, и сигнал реального времени, то в POSIX однозначно не определено, какой из них будет доставлен первым. В Linux, как и во многих других реализациях в таких случаях, отдан приоритет стандартным сигналам."

#. type: Plain text
#: man-pages/man7/signal.7:448
msgid ""
"According to POSIX, an implementation should permit at least "
"B<_POSIX_SIGQUEUE_MAX> (32) real-time signals to be queued to a process.  "
"However, Linux does things differently.  In kernels up to and including "
"2.6.7, Linux imposes a system-wide limit on the number of queued real-time "
"signals for all processes.  This limit can be viewed and (with privilege) "
"changed via the I</proc/sys/kernel/rtsig-max> file.  A related file, "
"I</proc/sys/kernel/rtsig-nr>, can be used to find out how many real-time "
"signals are currently queued.  In Linux 2.6.8, these I</proc> interfaces "
"were replaced by the B<RLIMIT_SIGPENDING> resource limit, which specifies a "
"per-user limit for queued signals; see B<setrlimit>(2)  for further details."
msgstr "В соответствии с POSIX, реализация должна позволять ставить в очередь процесса как минимум B<_POSIX_SIGQUEUE_MAX> (32) сигнала. Однако в Linux это делается по-другому. В ядрах до версии 2.6.7 включительно, Linux накладывает общесистемный лимит на количество сигналов режима реального времени в очереди для всех процессов. Этот лимит может быть получен и изменён (если есть права) через файл I</proc/sys/kernel/rtsig-max>. Текущее количество сигналов режима реального времени в очереди можно получить из файла I</proc/sys/kernel/rtsig-nr>. В Linux 2.6.8 данные интерфейсы I</proc> были заменены на ограничение ресурса B<RLIMIT_SIGPENDING>, которое устанавливает ограничение на очередь сигналов на каждого пользователя отдельно; дополнительную информацию можно найти в B<setrlimit>(2)."

#. type: SS
#: man-pages/man7/signal.7:448
#, no-wrap
msgid "Async-signal-safe functions"
msgstr "Безопасные асинхронные функции при работе с сигналами"

#. type: Plain text
#: man-pages/man7/signal.7:457
msgid ""
"A signal handler function must be very careful, since processing elsewhere "
"may be interrupted at some arbitrary point in the execution of the program."
"  POSIX has the concept of \"safe function\".  If a signal interrupts the "
"execution of an unsafe function, and I<handler> calls an unsafe function, "
"then the behavior of the program is undefined."
msgstr "Функция обработки сигнала должна быть написана очень аккуратно, так как она может быть вызвана в любом месте работы программы. В POSIX есть понятие «безопасной функции». Если сигнал прерывает выполнение небезопасной функции или I<обработчик> вызывает небезопасную функцию, то поведение программы не определено."

#. type: Plain text
#: man-pages/man7/signal.7:461
msgid ""
"POSIX.1-2004 (also known as POSIX.1-2001 Technical Corrigendum 2)  requires "
"an implementation to guarantee that the following functions can be safely "
"called inside a signal handler:"
msgstr "Согласно POSIX.1-2004 (также называемом POSIX.1-2001 Technical Corrigendum 2) от реализации требуется гарантировать, что следующие функции можно безопасно вызывать из обработчика сигнала:"

#. type: Plain text
#: man-pages/man7/signal.7:582
#, no-wrap
msgid ""
"_Exit()\n"
"_exit()\n"
"abort()\n"
"accept()\n"
"access()\n"
"aio_error()\n"
"aio_return()\n"
"aio_suspend()\n"
"alarm()\n"
"bind()\n"
"cfgetispeed()\n"
"cfgetospeed()\n"
"cfsetispeed()\n"
"cfsetospeed()\n"
"chdir()\n"
"chmod()\n"
"chown()\n"
"clock_gettime()\n"
"close()\n"
"connect()\n"
"creat()\n"
"dup()\n"
"dup2()\n"
"execle()\n"
"execve()\n"
"fchmod()\n"
"fchown()\n"
"fcntl()\n"
"fdatasync()\n"
"fork()\n"
"fpathconf()\n"
"fstat()\n"
"fsync()\n"
"ftruncate()\n"
"getegid()\n"
"geteuid()\n"
"getgid()\n"
"getgroups()\n"
"getpeername()\n"
"getpgrp()\n"
"getpid()\n"
"getppid()\n"
"getsockname()\n"
"getsockopt()\n"
"getuid()\n"
"kill()\n"
"link()\n"
"listen()\n"
"lseek()\n"
"lstat()\n"
"mkdir()\n"
"mkfifo()\n"
"open()\n"
"pathconf()\n"
"pause()\n"
"pipe()\n"
"poll()\n"
"posix_trace_event()\n"
"pselect()\n"
"raise()\n"
"read()\n"
"readlink()\n"
"recv()\n"
"recvfrom()\n"
"recvmsg()\n"
"rename()\n"
"rmdir()\n"
"select()\n"
"sem_post()\n"
"send()\n"
"sendmsg()\n"
"sendto()\n"
"setgid()\n"
"setpgid()\n"
"setsid()\n"
"setsockopt()\n"
"setuid()\n"
"shutdown()\n"
"sigaction()\n"
"sigaddset()\n"
"sigdelset()\n"
"sigemptyset()\n"
"sigfillset()\n"
"sigismember()\n"
"signal()\n"
"sigpause()\n"
"sigpending()\n"
"sigprocmask()\n"
"sigqueue()\n"
"sigset()\n"
"sigsuspend()\n"
"sleep()\n"
"sockatmark()\n"
"socket()\n"
"socketpair()\n"
"stat()\n"
"symlink()\n"
"sysconf()\n"
"tcdrain()\n"
"tcflow()\n"
"tcflush()\n"
"tcgetattr()\n"
"tcgetpgrp()\n"
"tcsendbreak()\n"
"tcsetattr()\n"
"tcsetpgrp()\n"
"time()\n"
"timer_getoverrun()\n"
"timer_gettime()\n"
"timer_settime()\n"
"times()\n"
"umask()\n"
"uname()\n"
"unlink()\n"
"utime()\n"
"wait()\n"
"waitpid()\n"
"write()\n"
msgstr "_Exit()\n_exit()\nabort()\naccept()\naccess()\naio_error()\naio_return()\naio_suspend()\nalarm()\nbind()\ncfgetispeed()\ncfgetospeed()\ncfsetispeed()\ncfsetospeed()\nchdir()\nchmod()\nchown()\nclock_gettime()\nclose()\nconnect()\ncreat()\ndup()\ndup2()\nexecle()\nexecve()\nfchmod()\nfchown()\nfcntl()\nfdatasync()\nfork()\nfpathconf()\nfstat()\nfsync()\nftruncate()\ngetegid()\ngeteuid()\ngetgid()\ngetgroups()\ngetpeername()\ngetpgrp()\ngetpid()\ngetppid()\ngetsockname()\ngetsockopt()\ngetuid()\nkill()\nlink()\nlisten()\nlseek()\nlstat()\nmkdir()\nmkfifo()\nopen()\npathconf()\npause()\npipe()\npoll()\nposix_trace_event()\npselect()\nraise()\nread()\nreadlink()\nrecv()\nrecvfrom()\nrecvmsg()\nrename()\nrmdir()\nselect()\nsem_post()\nsend()\nsendmsg()\nsendto()\nsetgid()\nsetpgid()\nsetsid()\nsetsockopt()\nsetuid()\nshutdown()\nsigaction()\nsigaddset()\nsigdelset()\nsigemptyset()\nsigfillset()\nsigismember()\nsignal()\nsigpause()\nsigpending()\nsigprocmask()\nsigqueue()\nsigset()\nsigsuspend()\nsleep()\nsockatmark()\nsocket()\nsocketpair()\nstat()\nsymlink()\nsysconf()\ntcdrain()\ntcflow()\ntcflush()\ntcgetattr()\ntcgetpgrp()\ntcsendbreak()\ntcsetattr()\ntcsetpgrp()\ntime()\ntimer_getoverrun()\ntimer_gettime()\ntimer_settime()\ntimes()\numask()\nuname()\nunlink()\nutime()\nwait()\nwaitpid()\nwrite()\n"

#. type: Plain text
#: man-pages/man7/signal.7:587
msgid ""
"POSIX.1-2008 removes fpathconf(), pathconf(), and sysconf()  from the above "
"list, and adds the following functions:"
msgstr "В POSIX.1-2008 из списка выше удалены функции fpathconf(), pathconf() и sysconf() и добавлены следующие:"

#. type: Plain text
#: man-pages/man7/signal.7:610
#, no-wrap
msgid ""
"execl()\n"
"execv()\n"
"faccessat()\n"
"fchmodat()\n"
"fchownat()\n"
"fexecve()\n"
"fstatat()\n"
"futimens()\n"
"linkat()\n"
"mkdirat()\n"
"mkfifoat()\n"
"mknod()\n"
"mknodat()\n"
"openat()\n"
"readlinkat()\n"
"renameat()\n"
"symlinkat()\n"
"unlinkat()\n"
"utimensat()\n"
"utimes()\n"
msgstr "execl()\nexecv()\nfaccessat()\nfchmodat()\nfchownat()\nfexecve()\nfstatat()\nfutimens()\nlinkat()\nmkdirat()\nmkfifoat()\nmknod()\nmknodat()\nopenat()\nreadlinkat()\nrenameat()\nsymlinkat()\nunlinkat()\nutimensat()\nutimes()\n"

#. type: SS
#: man-pages/man7/signal.7:612
#, no-wrap
msgid "Interruption of system calls and library functions by signal handlers"
msgstr "Прерывание системных вызовов и библиотечных функций обработчиками сигналов"

#. type: Plain text
#: man-pages/man7/signal.7:615
msgid ""
"If a signal handler is invoked while a system call or library function call "
"is blocked, then either:"
msgstr "Если обработчик сигнала вызван во время заблокированного системного вызова или библиотечной функции, то может произойти следующее:"

#. type: Plain text
#: man-pages/man7/signal.7:617
msgid ""
"the call is automatically restarted after the signal handler returns; or"
msgstr "вызов автоматически перезапускается после возврата из обработчика сигнала; или"

#. type: Plain text
#: man-pages/man7/signal.7:620
msgid "the call fails with the error B<EINTR>."
msgstr "вызов завершается с ошибкой B<EINTR>."

#. type: Plain text
#: man-pages/man7/signal.7:628
msgid ""
"Which of these two behaviors occurs depends on the interface and whether or "
"not the signal handler was established using the B<SA_RESTART> flag (see "
"B<sigaction>(2)).  The details vary across UNIX systems; below, the details "
"for Linux."
msgstr "Выбираемое поведение зависит от интерфейса и от того, был ли обработчик сигнала установлен с флагом B<SA_RESTART> (смотрите B<sigaction>(2)). Но в различных системах UNIX есть другие различия; далее описаны подробности для Linux."

#.  The following system calls use ERESTARTSYS,
#.  so that they are restartable
#. type: Plain text
#: man-pages/man7/signal.7:637
msgid ""
"If a blocked call to one of the following interfaces is interrupted by a "
"signal handler, then the call will be automatically restarted after the "
"signal handler returns if the B<SA_RESTART> flag was used; otherwise the "
"call will fail with the error B<EINTR>:"
msgstr "Если заблокированный вызов к одному из следующих интерфейсов прерван обработчиком сигнала, то вызов будет автоматически перезапущен после завершения обработчика сигнала, если задействован флаг B<SA_RESTART>; иначе вызов завершается с ошибкой B<EINTR>:"

#. type: Plain text
#: man-pages/man7/signal.7:653
msgid ""
"B<read>(2), B<readv>(2), B<write>(2), B<writev>(2), and B<ioctl>(2)  calls "
"on \"slow\" devices.  A \"slow\" device is one where the I/O call may block "
"for an indefinite time, for example, a terminal, pipe, or socket.  (A disk "
"is not a slow device according to this definition.)  If an I/O call on a "
"slow device has already transferred some data by the time it is interrupted "
"by a signal handler, then the call will return a success status (normally, "
"the number of bytes transferred)."
msgstr "Вызовы B<read>(2), B<readv>(2), B<write>(2), B<writev>(2) и B<ioctl>(2) для «медленных» устройств. Устройство считается «медленным», если его ввод-вывод может выполнять блокировку на неопределённое время; к таким устройствам относятся терминалы, каналы или сокеты (диск не является медленным устройством согласно этому определению). Если вызов ввода-вывода на медленном устройстве уже передал какие-то данные до того как был прерван обработчиком сигнала, то вызов завершится без ошибки (обычно, при этом возвращается количество переданных байт)."

#. type: Plain text
#: man-pages/man7/signal.7:657
msgid ""
"B<open>(2), if it can block (e.g., when opening a FIFO; see B<fifo>(7))."
msgstr "Вызов B<open>(2), если он может выполнить блокировку (например, при открытии FIFO; смотрите B<fifo>(7))."

#. type: Plain text
#: man-pages/man7/signal.7:664
msgid "B<wait>(2), B<wait3>(2), B<wait4>(2), B<waitid>(2), and B<waitpid>(2)."
msgstr "Вызовы B<wait>(2), B<wait3>(2), B<wait4>(2), B<waitid>(2) и B<waitpid>(2)."

#.  If a timeout (setsockopt()) is in effect on the socket, then these
#.  system calls switch to using EINTR.  Consequently, they and are not
#.  automatically restarted, and they show the stop/cont behavior
#.  described below.  (Verified from 2.6.26 source, and by experiment; mtk)
#.  FIXME What about sendmmsg()?
#. type: Plain text
#: man-pages/man7/signal.7:682
msgid ""
"Socket interfaces: B<accept>(2), B<connect>(2), B<recv>(2), B<recvfrom>(2), "
"B<recvmmsg>(2), B<recvmsg>(2), B<send>(2), B<sendto>(2), and B<sendmsg>(2), "
"unless a timeout has been set on the socket (see below)."
msgstr "Интерфейсы сокетов: B<accept>(2), B<connect>(2), B<recv>(2), B<recvfrom>(2), B<recvmmsg>(2), B<recvmsg>(2), B<send>(2), B<sendto>(2) и B<sendmsg>(2), если для сокета не указано время ожидания (смотрите далее)."

#. type: Plain text
#: man-pages/man7/signal.7:688
msgid "File locking interfaces: B<flock>(2)  and B<fcntl>(2)  B<F_SETLKW>."
msgstr "Интерфейсы файловой блокировки: B<flock>(2) и B<fcntl>(2) с B<F_SETLKW>."

#. type: Plain text
#: man-pages/man7/signal.7:695
msgid ""
"POSIX message queue interfaces: B<mq_receive>(3), B<mq_timedreceive>(3), "
"B<mq_send>(3), and B<mq_timedsend>(3)."
msgstr "Интерфейсы очереди сообщений POSIX: B<mq_receive>(3), B<mq_timedreceive>(3), B<mq_send>(3) и B<mq_timedsend>(3)."

#. type: Plain text
#: man-pages/man7/signal.7:700
msgid ""
"B<futex>(2)  B<FUTEX_WAIT> (since Linux 2.6.22; beforehand, always failed "
"with B<EINTR>)."
msgstr "Вызов B<futex>(2) с B<FUTEX_WAIT> (начиная с Linux 2.6.22; до этой версии вызов завершался с ошибкой B<EINTR>)."

#. type: Plain text
#: man-pages/man7/signal.7:707
msgid ""
"POSIX semaphore interfaces: B<sem_wait>(3)  and B<sem_timedwait>(3)  (since "
"Linux 2.6.22; beforehand, always failed with B<EINTR>)."
msgstr "Интерфейсы семафоров POSIX: B<sem_wait>(3) и B<sem_timedwait>(3) (начиная с Linux 2.6.22; до этой версии вызовы завершались с ошибкой B<EINTR>)."

#.  These are the system calls that give EINTR or ERESTARTNOHAND
#.  on interruption by a signal handler.
#. type: Plain text
#: man-pages/man7/signal.7:718
msgid ""
"The following interfaces are never restarted after being interrupted by a "
"signal handler, regardless of the use of B<SA_RESTART>; they always fail "
"with the error B<EINTR> when interrupted by a signal handler:"
msgstr "Следующие интерфейсы никогда не перезапускаются после прерывания обработчиком сигнала независимо от наличия B<SA_RESTART>; они всегда завершаются с ошибкой B<EINTR>, если прерываются обработчиком сигнала:"

#. type: Plain text
#: man-pages/man7/signal.7:733 man-pages/man7/signal.7:813
msgid ""
"\"Input\" socket interfaces, when a timeout (B<SO_RCVTIMEO>)  has been set "
"on the socket using B<setsockopt>(2): B<accept>(2), B<recv>(2), "
"B<recvfrom>(2), B<recvmmsg>(2)  (also with a non-NULL I<timeout> argument), "
"and B<recvmsg>(2)."
msgstr "«Входные» интерфейсы сокетов, если установлен таймаут (B<SO_RCVTIMEO>) на сокете с помощью B<setsockopt>(2): B<accept>(2), B<recv>(2), B<recvfrom>(2), B<recvmmsg>(2) (также с аргументом I<timeout>, не равным NULL) и B<recvmsg>(2)."

#.  FIXME What about sendmmsg()?
#. type: Plain text
#: man-pages/man7/signal.7:744
msgid ""
"\"Output\" socket interfaces, when a timeout (B<SO_RCVTIMEO>)  has been set "
"on the socket using B<setsockopt>(2): B<connect>(2), B<send>(2), "
"B<sendto>(2), and B<sendmsg>(2)."
msgstr "«Выходные» интерфейсы сокетов, если установлен таймаут (B<SO_RCVTIMEO>) на сокете с помощью B<setsockopt>(2): B<connect>(2), B<send>(2), B<sendto>(2) и B<sendmsg>(2)."

#. type: Plain text
#: man-pages/man7/signal.7:751
msgid ""
"Interfaces used to wait for signals: B<pause>(2), B<sigsuspend>(2), "
"B<sigtimedwait>(2), and B<sigwaitinfo>(2)."
msgstr "Интерфейсы, используемые для ожидания сигналов: B<pause>(2), B<sigsuspend>(2), B<sigtimedwait>(2) и B<sigwaitinfo>(2)."

#. type: Plain text
#: man-pages/man7/signal.7:760
msgid ""
"File descriptor multiplexing interfaces: B<epoll_wait>(2), "
"B<epoll_pwait>(2), B<poll>(2), B<ppoll>(2), B<select>(2), and B<pselect>(2)."
msgstr "Интерфейсы комбинирования (multiplexing) файловых дескрипторов: B<epoll_wait>(2), B<epoll_pwait>(2), B<poll>(2), B<ppoll>(2), B<select>(2) и B<pselect>(2)."

#.  On some other systems, SA_RESTART does restart these system calls
#. type: Plain text
#: man-pages/man7/signal.7:768
msgid ""
"System V IPC interfaces: B<msgrcv>(2), B<msgsnd>(2), B<semop>(2), and "
"B<semtimedop>(2)."
msgstr "IPC-интерфейсы System V: B<msgrcv>(2), B<msgsnd>(2), B<semop>(2) и B<semtimedop>(2)."

#. type: Plain text
#: man-pages/man7/signal.7:774
msgid ""
"Sleep interfaces: B<clock_nanosleep>(2), B<nanosleep>(2), and B<usleep>(3)."
msgstr "Интерфейсы сна: B<clock_nanosleep>(2), B<nanosleep>(2) и B<usleep>(3)."

#. type: Plain text
#: man-pages/man7/signal.7:779 man-pages/man7/signal.7:841
msgid "B<read>(2)  from an B<inotify>(7)  file descriptor."
msgstr "B<read>(2) из файлового дескриптора B<inotify>(7)."

#. type: Plain text
#: man-pages/man7/signal.7:781
msgid "B<io_getevents>(2)."
msgstr "B<io_getevents>(2)."

#. type: Plain text
#: man-pages/man7/signal.7:787
msgid ""
"The B<sleep>(3)  function is also never restarted if interrupted by a "
"handler, but gives a success return: the number of seconds remaining to "
"sleep."
msgstr "Функция B<sleep>(3) также никогда не перезапускается, если прервана обработчиком сигнала, но сообщает об успешном выполнении: возвращает количество оставшиеся для сна секунд."

#. type: SS
#: man-pages/man7/signal.7:787
#, no-wrap
msgid "Interruption of system calls and library functions by stop signals"
msgstr "Прерывание системных вызовов и библиотечных функций сигналами останова"

#. type: Plain text
#: man-pages/man7/signal.7:796
msgid ""
"On Linux, even in the absence of signal handlers, certain blocking "
"interfaces can fail with the error B<EINTR> after the process is stopped by "
"one of the stop signals and then resumed via B<SIGCONT>.  This behavior is "
"not sanctioned by POSIX.1, and doesn't occur on other systems."
msgstr "В Linux, даже в отсутствии обработчиков сигнала, некоторые блокирующие интерфейсы могут завершаться с ошибкой B<EINTR>, если процесс останавливается одним из сигналов останова и затем возобновляет работу при получении сигнала B<SIGCONT>. Такое поведение не предусмотрено POSIX.1 и в других системах отсутствует."

#. type: Plain text
#: man-pages/man7/signal.7:798
msgid "The Linux interfaces that display this behavior are:"
msgstr "Интерфейсы Linux, к которым это относится:"

#.  FIXME What about sendmmsg()?
#. type: Plain text
#: man-pages/man7/signal.7:827
msgid ""
"\"Output\" socket interfaces, when a timeout (B<SO_RCVTIMEO>)  has been set "
"on the socket using B<setsockopt>(2): B<connect>(2), B<send>(2), "
"B<sendto>(2), and B<sendmsg>(2), if a send timeout (B<SO_SNDTIMEO>)  has "
"been set."
msgstr "«Выходные» интерфейсы сокетов, если установлен таймаут (B<SO_RCVTIMEO>) на сокете с помощью B<setsockopt>(2): B<connect>(2), B<send>(2), B<sendto>(2) и B<sendmsg>(2), если установлен таймаут отправления (B<SO_SNDTIMEO>)."

#. type: Plain text
#: man-pages/man7/signal.7:830
msgid "B<epoll_wait>(2), B<epoll_pwait>(2)."
msgstr "B<epoll_wait>(2), B<epoll_pwait>(2)."

#. type: Plain text
#: man-pages/man7/signal.7:833
msgid "B<semop>(2), B<semtimedop>(2)."
msgstr "B<semop>(2), B<semtimedop>(2)."

#. type: Plain text
#: man-pages/man7/signal.7:836
msgid "B<sigtimedwait>(2), B<sigwaitinfo>(2)."
msgstr "B<sigtimedwait>(2), B<sigwaitinfo>(2)."

#. type: Plain text
#: man-pages/man7/signal.7:847
msgid ""
"Linux 2.6.21 and earlier: B<futex>(2)  B<FUTEX_WAIT>, B<sem_timedwait>(3), "
"B<sem_wait>(3)."
msgstr "Linux версии 2.6.21 и более ранних: B<futex>(2)  B<FUTEX_WAIT>, B<sem_timedwait>(3), B<sem_wait>(3)."

#. type: Plain text
#: man-pages/man7/signal.7:851
msgid "Linux 2.6.8 and earlier: B<msgrcv>(2), B<msgsnd>(2)."
msgstr "Linux версии 2.6.8 и более ранних: B<msgrcv>(2), B<msgsnd>(2)."

#. type: Plain text
#: man-pages/man7/signal.7:854
msgid "Linux 2.4 and earlier: B<nanosleep>(2)."
msgstr "Linux версии 2.4 и более ранних: B<nanosleep>(2)."

#.  It must be a *very* long time since this was true:
#.  .SH BUGS
#.  .B SIGIO
#.  and
#.  .B SIGLOST
#.  have the same value.
#.  The latter is commented out in the kernel source, but
#.  the build process of some software still thinks that
#.  signal 29 is
#.  .BR SIGLOST .
#. type: Plain text
#: man-pages/man7/signal.7:867
msgid "POSIX.1, except as noted."
msgstr "POSIX.1, кроме описанных исключений."

#. type: Plain text
#: man-pages/man7/signal.7:900
msgid ""
"B<kill>(1), B<getrlimit>(2), B<kill>(2), B<killpg>(2), "
"B<restart_syscall>(2), B<rt_sigqueueinfo>(2), B<setitimer>(2), "
"B<setrlimit>(2), B<sgetmask>(2), B<sigaction>(2), B<sigaltstack>(2), "
"B<signal>(2), B<signalfd>(2), B<sigpending>(2), B<sigprocmask>(2), "
"B<sigsuspend>(2), B<sigwaitinfo>(2), B<abort>(3), B<bsd_signal>(3), "
"B<longjmp>(3), B<raise>(3), B<pthread_sigqueue>(3), B<sigqueue>(3), "
"B<sigset>(3), B<sigsetops>(3), B<sigvec>(3), B<sigwait>(3), B<strsignal>(3),"
" B<sysv_signal>(3), B<core>(5), B<proc>(5), B<pthreads>(7), B<sigevent>(7)"
msgstr "B<kill>(1), B<getrlimit>(2), B<kill>(2), B<killpg>(2), B<restart_syscall>(2), B<rt_sigqueueinfo>(2), B<setitimer>(2), B<setrlimit>(2), B<sgetmask>(2), B<sigaction>(2), B<sigaltstack>(2), B<signal>(2), B<signalfd>(2), B<sigpending>(2), B<sigprocmask>(2), B<sigsuspend>(2), B<sigwaitinfo>(2), B<abort>(3), B<bsd_signal>(3), B<longjmp>(3), B<raise>(3), B<pthread_sigqueue>(3), B<sigqueue>(3), B<sigset>(3), B<sigsetops>(3), B<sigvec>(3), B<sigwait>(3), B<strsignal>(3), B<sysv_signal>(3), B<core>(5), B<proc>(5), B<pthreads>(7), B<sigevent>(7)"

#. type: TH
#: man-pages/man7/sigevent.7:26
#, no-wrap
msgid "SIGEVENT"
msgstr "SIGEVENT"

#. type: TH
#: man-pages/man7/sigevent.7:26
#, no-wrap
msgid "2011-09-09"
msgstr "2011-09-09"

#. type: Plain text
#: man-pages/man7/sigevent.7:29
msgid "sigevent - structure for notification from asynchronous routines"
msgstr "sigevent - структура для уведомления из асинхронных процедур"

#. type: Plain text
#: man-pages/man7/sigevent.7:36
#, no-wrap
msgid ""
"union sigval {          /* Data passed with notification */\n"
"    int     sival_int;         /* Integer value */\n"
"    void   *sival_ptr;         /* Pointer value */\n"
"};\n"
msgstr "union sigval {          /* Данные, передаваемые с уведомлением */\n    int     sival_int;         /* целое */\n    void   *sival_ptr;         /* указатель */\n};\n"

#. type: Plain text
#: man-pages/man7/sigevent.7:51
#, no-wrap
msgid ""
"struct sigevent {\n"
"    int          sigev_notify; /* Notification method */\n"
"    int          sigev_signo;  /* Notification signal */\n"
"    union sigval sigev_value;  /* Data passed with\n"
"                                  notification */\n"
"    void       (*sigev_notify_function) (union sigval);\n"
"                     /* Function used for thread\n"
"                        notification (SIGEV_THREAD) */\n"
"    void        *sigev_notify_attributes;\n"
"                     /* Attributes for notification thread\n"
"                        (SIGEV_THREAD) */\n"
"    pid_t        sigev_notify_thread_id;\n"
"                     /* ID of thread to signal (SIGEV_THREAD_ID) */\n"
"};\n"
msgstr "struct sigevent {\n    int          sigev_notify; /* метод уведомления */\n    int          sigev_signo;  /* сигнал уведомления */\n    union sigval sigev_value;  /* данные, передаваемые\n                                  с уведомлением */\n    void       (*sigev_notify_function) (union sigval);\n                     /* функция, используемая для нити\n                        notification (SIGEV_THREAD) */\n    void        *sigev_notify_attributes;\n                     /* атрибуты для уведомления нити\n                        (SIGEV_THREAD) */\n    pid_t        sigev_notify_thread_id;\n                     /* ID нити для уведомления (SIGEV_THREAD_ID) */\n};\n"

#. type: Plain text
#: man-pages/man7/sigevent.7:60
msgid ""
"The I<sigevent> structure is used by various APIs to describe the way a "
"process is to be notified about an event (e.g., completion of an "
"asynchronous request, expiration of a timer, or the arrival of a message)."
msgstr ""

#. type: Plain text
#: man-pages/man7/sigevent.7:68
msgid ""
"The definition shown in the SYNOPSIS is approximate: some of the fields in "
"the I<sigevent> structure may be defined as part of a union.  Programs "
"should employ only those fields relevant to the value specified in "
"I<sigev_notify>."
msgstr ""

#. type: Plain text
#: man-pages/man7/sigevent.7:73
msgid ""
"The I<sigev_notify> field specifies how notification is to be performed.  "
"This field can have one of the following values:"
msgstr ""

#. type: TP
#: man-pages/man7/sigevent.7:73
#, no-wrap
msgid "B<SIGEV_NONE>"
msgstr "B<SIGEV_NONE>"

#. type: Plain text
#: man-pages/man7/sigevent.7:76
msgid "A \"null\" notification: don't do anything when the event occurs."
msgstr "«Пустое» уведомление: ничего не делать при возникновении события."

#. type: TP
#: man-pages/man7/sigevent.7:76
#, no-wrap
msgid "B<SIGEV_SIGNAL>"
msgstr "B<SIGEV_SIGNAL>"

#. type: Plain text
#: man-pages/man7/sigevent.7:80
msgid "Notify the process by sending the signal specified in I<sigev_signo>."
msgstr "Уведомить процесс, отправив сигнал, указанный в I<sigev_signo>."

#. type: Plain text
#: man-pages/man7/sigevent.7:87
msgid ""
"If the signal is caught with a signal handler that was registered using the "
"B<sigaction>(2)  B<SA_SIGINFO> flag, then the following fields are set in "
"the I<siginfo_t> structure that is passed as the second argument of the "
"handler:"
msgstr ""

#. type: TP
#: man-pages/man7/sigevent.7:88
#, no-wrap
msgid "I<si_code>"
msgstr "I<si_code>"

#. type: Plain text
#: man-pages/man7/sigevent.7:92
msgid ""
"This field is set to a value that depends on the API delivering the "
"notification."
msgstr ""

#. type: TP
#: man-pages/man7/sigevent.7:92
#, no-wrap
msgid "I<si_signo>"
msgstr "I<si_signo>"

#. type: Plain text
#: man-pages/man7/sigevent.7:96
msgid ""
"This field is set to the signal number (i.e., the same value as in "
"I<sigev_signo>)."
msgstr ""

#. type: TP
#: man-pages/man7/sigevent.7:96
#, no-wrap
msgid "I<si_value>"
msgstr "I<si_value>"

#. type: Plain text
#: man-pages/man7/sigevent.7:100
msgid "This field is set to the value specified in I<sigev_value>."
msgstr ""

#. type: Plain text
#: man-pages/man7/sigevent.7:105
msgid ""
"Depending on the API, other fields may also be set in the I<siginfo_t> "
"structure."
msgstr ""

#. type: Plain text
#: man-pages/man7/sigevent.7:108
msgid ""
"The same information is also available if the signal is accepted using "
"B<sigwaitinfo>(2)."
msgstr ""

#. type: TP
#: man-pages/man7/sigevent.7:108
#, no-wrap
msgid "B<SIGEV_THREAD>"
msgstr "B<SIGEV_THREAD>"

#. type: Plain text
#: man-pages/man7/sigevent.7:125
msgid ""
"Notify the process by invoking I<sigev_notify_function> \"as if\" it were "
"the start function of a new thread.  (Among the implementation possibilities"
" here are that each timer notification could result in the creation of a new"
" thread, or that a single thread is created to receive all notifications.)  "
"The function is invoked with I<sigev_value> as its sole argument.  If "
"I<sigev_notify_attributes> is not NULL, it should point to a "
"I<pthread_attr_t> structure that defines attributes for the new thread (see "
"B<pthread_attr_init>(3))."
msgstr ""

#. type: TP
#: man-pages/man7/sigevent.7:125
#, no-wrap
msgid "B<SIGEV_THREAD_ID> (Linux-specific)"
msgstr "B<SIGEV_THREAD_ID> (есть только в Linux)"

#.  | SIGEV_SIGNAL vs not?
#. type: Plain text
#: man-pages/man7/sigevent.7:130
msgid "Currently used only by POSIX timers; see B<timer_create>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man7/sigevent.7:132
msgid "POSIX.1-2001."
msgstr "POSIX.1-2001."

#. type: Plain text
#: man-pages/man7/sigevent.7:141
msgid ""
"B<timer_create>(2), B<aio_fsync>(3), B<aio_read>(3), B<aio_write>(3), "
"B<getaddrinfo_a>(3), B<lio_listio>(3), B<mq_notify>(3), B<aio>(7), "
"B<pthreads>(7)"
msgstr "B<timer_create>(2), B<aio_fsync>(3), B<aio_read>(3), B<aio_write>(3), B<getaddrinfo_a>(3), B<lio_listio>(3), B<mq_notify>(3), B<aio>(7), B<pthreads>(7)"

#. type: TH
#: man-pages/man7/standards.7:24
#, no-wrap
msgid "STANDARDS"
msgstr "STANDARDS"

#. type: TH
#: man-pages/man7/standards.7:24
#, no-wrap
msgid "2014-01-15"
msgstr "2014-01-15"

#. type: Plain text
#: man-pages/man7/standards.7:27
msgid "standards - C and UNIX Standards"
msgstr "standards - стандарты C и UNIX"

#. type: Plain text
#: man-pages/man7/standards.7:31
msgid ""
"The CONFORMING TO section that appears in many manual pages identifies "
"various standards to which the documented interface conforms.  The following"
" list briefly describes these standards."
msgstr ""

#. type: TP
#: man-pages/man7/standards.7:31
#, no-wrap
msgid "B<V7>"
msgstr "B<V7>"

#. type: Plain text
#: man-pages/man7/standards.7:37
msgid ""
"Version 7 (also known as Seventh Edition) UNIX, released by AT&T/Bell Labs "
"in 1979.  After this point, UNIX systems diverged into two main dialects: "
"BSD and System V."
msgstr ""

#. type: TP
#: man-pages/man7/standards.7:37
#, no-wrap
msgid "B<4.2BSD>"
msgstr "B<4.2BSD>"

#. type: Plain text
#: man-pages/man7/standards.7:46
msgid ""
"This is an implementation standard defined by the 4.2 release of the "
"I<Berkeley Software Distribution>, released by the University of California "
"at Berkeley.  This was the first Berkeley release that contained a TCP/IP "
"stack and the sockets API.  4.2BSD was released in 1983."
msgstr ""

#. type: Plain text
#: man-pages/man7/standards.7:55
msgid ""
"Earlier major BSD releases included I<3BSD> (1980), I<4BSD> (1980), and "
"I<4.1BSD> (1981)."
msgstr ""

#. type: TP
#: man-pages/man7/standards.7:55
#, no-wrap
msgid "B<4.3BSD>"
msgstr "B<4.3BSD>"

#. type: Plain text
#: man-pages/man7/standards.7:58
msgid "The successor to 4.2BSD, released in 1986."
msgstr ""

#. type: TP
#: man-pages/man7/standards.7:58
#, no-wrap
msgid "B<4.4BSD>"
msgstr "B<4.4BSD>"

#. type: Plain text
#: man-pages/man7/standards.7:62
msgid ""
"The successor to 4.3BSD, released in 1993.  This was the last major Berkeley"
" release."
msgstr ""

#. type: TP
#: man-pages/man7/standards.7:62
#, no-wrap
msgid "B<System V>"
msgstr "B<System V>"

#. type: Plain text
#: man-pages/man7/standards.7:69
msgid ""
"This is an implementation standard defined by AT&T's milestone 1983 release "
"of its commercial System V (five) release.  The previous major AT&T release "
"was I<System III>, released in 1981."
msgstr ""

#. type: TP
#: man-pages/man7/standards.7:69
#, no-wrap
msgid "B<System V release 2 (SVr2)>"
msgstr "B<System V release 2 (SVr2)>"

#. type: Plain text
#: man-pages/man7/standards.7:76
msgid ""
"This was the next System V release, made in 1985.  The SVr2 was formally "
"described in the I<System V Interface Definition version 1> (I<SVID 1>)  "
"published in 1985."
msgstr ""

#. type: TP
#: man-pages/man7/standards.7:76
#, no-wrap
msgid "B<System V release 3 (SVr3)>"
msgstr "B<System V release 3 (SVr3)>"

#. type: Plain text
#: man-pages/man7/standards.7:82
msgid ""
"This was the successor to SVr2, released in 1986.  This release was formally"
" described in the I<System V Interface Definition version 2> (I<SVID 2>)."
msgstr ""

#. type: TP
#: man-pages/man7/standards.7:82
#, no-wrap
msgid "B<System V release 4 (SVr4)>"
msgstr "B<System V release 4 (SVr4)>"

#. type: Plain text
#: man-pages/man7/standards.7:92
msgid ""
"This was the successor to SVr3, released in 1989.  This version of System V "
"is described in the \"Programmer's Reference Manual: Operating System API "
"(Intel processors)\" (Prentice-Hall 1992, ISBN 0-13-951294-2)  This release "
"was formally described in the I<System V Interface Definition version 3> "
"(I<SVID 3>), and is considered the definitive System V release."
msgstr ""

#. type: TP
#: man-pages/man7/standards.7:92
#, no-wrap
msgid "B<SVID 4>"
msgstr "B<SVID 4>"

#. type: Plain text
#: man-pages/man7/standards.7:96
msgid ""
"System V Interface Definition version 4, issued in 1995.  Available online "
"at"
msgstr ""

#. type: UR
#: man-pages/man7/standards.7:96
#, no-wrap
msgid "http://www.sco.com\\:/developers\\:/devspecs/"
msgstr "http://www.sco.com\\:/developers\\:/devspecs/"

#. type: TP
#: man-pages/man7/standards.7:98
#, no-wrap
msgid "B<C89>"
msgstr "B<C89>"

#. type: Plain text
#: man-pages/man7/standards.7:112
msgid ""
"This was the first C language standard, ratified by ANSI (American National "
"Standards Institute) in 1989 (I<X3.159-1989>).  Sometimes this is known as "
"I<ANSI C>, but since C99 is also an ANSI standard, this term is ambiguous.  "
"This standard was also ratified by ISO (International Standards "
"Organization) in 1990 (I<ISO/IEC 9899:1990>), and is thus occasionally "
"referred to as I<ISO C90>."
msgstr ""

#. type: TP
#: man-pages/man7/standards.7:112
#, no-wrap
msgid "B<C99>"
msgstr "B<C99>"

#. type: Plain text
#: man-pages/man7/standards.7:117
msgid ""
"This revision of the C language standard was ratified by ISO in 1999 "
"(I<ISO/IEC 9899:1999>).  Available online at"
msgstr ""

#. type: UR
#: man-pages/man7/standards.7:117
#, no-wrap
msgid "http://www.open-std.org\\:/jtc1\\:/sc22\\:/wg14\\:/www\\:/standards"
msgstr "http://www.open-std.org\\:/jtc1\\:/sc22\\:/wg14\\:/www\\:/standards"

#. type: TP
#: man-pages/man7/standards.7:119
#, no-wrap
msgid "B<C11>"
msgstr "B<C11>"

#. type: Plain text
#: man-pages/man7/standards.7:123
msgid ""
"This revision of the C language standard was ratified by ISO in 2011 "
"(I<ISO/IEC 9899:2011>)."
msgstr ""

#. type: TP
#: man-pages/man7/standards.7:123
#, no-wrap
msgid "B<POSIX.1-1990>"
msgstr "B<POSIX.1-1990>"

#. type: Plain text
#: man-pages/man7/standards.7:129
msgid ""
"\"Portable Operating System Interface for Computing Environments\".  IEEE "
"1003.1-1990 part 1, ratified by ISO in 1990 (I<ISO/IEC 9945-1:1990>).  The "
"term \"POSIX\" was coined by Richard Stallman."
msgstr ""

#. type: TP
#: man-pages/man7/standards.7:129
#, no-wrap
msgid "B<POSIX.2>"
msgstr "B<POSIX.2>"

#. type: Plain text
#: man-pages/man7/standards.7:134
msgid ""
"IEEE Std 1003.2-1992, describing commands and utilities, ratified by ISO in "
"1993 (I<ISO/IEC 9945-2:1993>)."
msgstr ""

#. type: TP
#: man-pages/man7/standards.7:134
#, no-wrap
msgid "B<POSIX.1b> (formerly known as I<POSIX.4>)"
msgstr "B<POSIX.1b> (ранее известен как I<POSIX.4>)"

#. type: Plain text
#: man-pages/man7/standards.7:140
msgid ""
"IEEE Std 1003.1b-1993, describing real-time facilities for portable "
"operating systems, ratified by ISO in 1996 (I<ISO/IEC 9945-1:1996>)."
msgstr ""

#. type: TP
#: man-pages/man7/standards.7:140
#, no-wrap
msgid "B<POSIX.1c>"
msgstr "B<POSIX.1c>"

#. type: Plain text
#: man-pages/man7/standards.7:143
msgid "IEEE Std 1003.1c-1995, which describes the POSIX threads interfaces."
msgstr ""

#. type: TP
#: man-pages/man7/standards.7:143
#, no-wrap
msgid "B<POSIX.1d>"
msgstr "B<POSIX.1d>"

#. type: Plain text
#: man-pages/man7/standards.7:146
msgid ""
"IEEE Std 1003.1c-1999, which describes additional real-time extensions."
msgstr ""

#. type: TP
#: man-pages/man7/standards.7:146
#, no-wrap
msgid "B<POSIX.1g>"
msgstr "B<POSIX.1g>"

#. type: Plain text
#: man-pages/man7/standards.7:149
msgid ""
"IEEE Std 1003.1g-2000, which describes networking APIs (including sockets)."
msgstr ""

#. type: TP
#: man-pages/man7/standards.7:149
#, no-wrap
msgid "B<POSIX.1j>"
msgstr "B<POSIX.1j>"

#. type: Plain text
#: man-pages/man7/standards.7:152
msgid "IEEE Std 1003.1j-2000, which describes advanced real-time extensions."
msgstr ""

#. type: TP
#: man-pages/man7/standards.7:152
#, no-wrap
msgid "B<POSIX.1-1996>"
msgstr "B<POSIX.1-1996>"

#. type: Plain text
#: man-pages/man7/standards.7:155
msgid "A 1996 revision of POSIX.1 which incorporated POSIX.1b and POSIX.1c."
msgstr "Ревизия POSIX.1 1996 года, включенная в POSIX.1b и POSIX.1c."

#. type: TP
#: man-pages/man7/standards.7:155
#, no-wrap
msgid "B<XPG3>"
msgstr "B<XPG3>"

#. type: Plain text
#: man-pages/man7/standards.7:162
msgid ""
"Released in 1989, this was the first significant release of the I<X/Open "
"Portability Guide>, produced by the X/Open Company, a multivendor "
"consortium.  This multivolume guide was based on the POSIX standards."
msgstr ""

#. type: TP
#: man-pages/man7/standards.7:162
#, no-wrap
msgid "B<XPG4>"
msgstr "B<XPG4>"

#. type: Plain text
#: man-pages/man7/standards.7:165
msgid "A revision of the X/Open Portability Guide, released in 1992."
msgstr "Ревизия X/Open Portability Guide, выпущенная в 1992 году."

#. type: TP
#: man-pages/man7/standards.7:165
#, no-wrap
msgid "B<XPG4v2>"
msgstr "B<XPG4v2>"

#. type: Plain text
#: man-pages/man7/standards.7:172
msgid ""
"A 1994 revision of XPG4.  This is also referred to as I<Spec 1170>, where "
"1170 referred to the number of interfaces defined by this standard."
msgstr ""

#. type: TP
#: man-pages/man7/standards.7:172
#, no-wrap
msgid "B<SUS (SUSv1)>"
msgstr "B<SUS (SUSv1)>"

#. type: Plain text
#: man-pages/man7/standards.7:180
msgid ""
"Single UNIX Specification.  This was a repackaging of XPG4v2 and other "
"X/Open standards (X/Open Curses Issue 4 version 2, X/Open Networking Service"
" (XNS) Issue 4).  Systems conforming to this standard can be branded I<UNIX "
"95>."
msgstr ""

#. type: TP
#: man-pages/man7/standards.7:180
#, no-wrap
msgid "B<SUSv2>"
msgstr "B<SUSv2>"

#. type: Plain text
#: man-pages/man7/standards.7:189
msgid ""
"Single UNIX Specification version 2.  Sometimes also referred to as I<XPG5>."
"  This standard appeared in 1997.  Systems conforming to this standard can "
"be branded I<UNIX 98>.  See also"
msgstr ""

#. type: UR
#: man-pages/man7/standards.7:189
#, no-wrap
msgid "http://www.UNIX-systems.org\\:/version2/"
msgstr "http://www.UNIX-systems.org\\:/version2/"

#. type: TP
#: man-pages/man7/standards.7:191
#, no-wrap
msgid "B<POSIX.1-2001, SUSv3>"
msgstr "B<POSIX.1-2001, SUSv3>"

#. type: Plain text
#: man-pages/man7/standards.7:196
msgid ""
"This was a 2001 revision and consolidation of the POSIX.1, POSIX.2, and SUS "
"standards into a single document, conducted under the auspices of the Austin"
" group"
msgstr ""

#. type: UR
#: man-pages/man7/standards.7:196 man-pages/man7/standards.7:275
#, no-wrap
msgid "http://www.opengroup.org\\:/austin/"
msgstr "http://www.opengroup.org\\:/austin/"

#. type: Plain text
#: man-pages/man7/standards.7:199
msgid "The standard is available online at"
msgstr ""

#. type: UR
#: man-pages/man7/standards.7:199
#, no-wrap
msgid "http://www.unix-systems.org\\:/version3/"
msgstr "http://www.unix-systems.org\\:/version3/"

#. type: Plain text
#: man-pages/man7/standards.7:203
msgid ""
"and the interfaces that it describes are also available in the Linux manual "
"pages package under sections 1p and 3p (e.g., \"man 3p open\")."
msgstr ""

#. type: Plain text
#: man-pages/man7/standards.7:216
msgid ""
"The standard defines two levels of conformance: I<POSIX conformance>, which "
"is a baseline set of interfaces required of a conforming system; and I<XSI "
"Conformance>, which additionally mandates a set of interfaces (the \"XSI "
"extension\") which are only optional for POSIX conformance.  XSI-conformant "
"systems can be branded I<UNIX 03>.  (XSI conformance constitutes the "
"I<Single UNIX Specification version 3> (I<SUSv3>).)"
msgstr ""

#. type: Plain text
#: man-pages/man7/standards.7:218
msgid "The POSIX.1-2001 document is broken into four parts:"
msgstr "Документ POSIX.1-2001 разделен на четыре части:"

#. type: Plain text
#: man-pages/man7/standards.7:221
msgid "B<XBD>: Definitions, terms and concepts, header file specifications."
msgstr ""

#. type: Plain text
#: man-pages/man7/standards.7:225
msgid ""
"B<XSH>: Specifications of functions (i.e., system calls and library "
"functions in actual implementations)."
msgstr ""

#. type: Plain text
#: man-pages/man7/standards.7:229
msgid ""
"B<XCU>: Specifications of commands and utilities (i.e., the area formerly "
"described by POSIX.2)."
msgstr ""

#. type: Plain text
#: man-pages/man7/standards.7:232
msgid "B<XRAT>: Informative text on the other parts of the standard."
msgstr ""

#. type: Plain text
#: man-pages/man7/standards.7:236
msgid ""
"POSIX.1-2001 is aligned with C99, so that all of the library functions "
"standardized in C99 are also standardized in POSIX.1-2001."
msgstr ""

#. type: Plain text
#: man-pages/man7/standards.7:243
msgid ""
"Two Technical Corrigenda (minor fixes and improvements)  of the original "
"2001 standard have occurred: TC1 in 2003 (referred to as I<POSIX.1-2003>), "
"and TC2 in 2004 (referred to as I<POSIX.1-2004>)."
msgstr ""

#. type: TP
#: man-pages/man7/standards.7:243
#, no-wrap
msgid "B<POSIX.1-2008, SUSv4>"
msgstr "B<POSIX.1-2008, SUSv4>"

#. type: Plain text
#: man-pages/man7/standards.7:247
msgid ""
"Work on the next revision of POSIX.1/SUS was completed and ratified in 2008."
msgstr ""

#. type: Plain text
#: man-pages/man7/standards.7:256
msgid ""
"The changes in this revision are not as large as those that occurred for "
"POSIX.1-2001/SUSv3, but a number of new interfaces are added and various "
"details of existing specifications are modified.  Many of the interfaces "
"that were optional in POSIX.1-2001 become mandatory in the 2008 revision of "
"the standard.  A few interfaces that are present in POSIX.1-2001 are marked "
"as obsolete in POSIX.1-2008, or removed from the standard altogether."
msgstr ""

#. type: Plain text
#: man-pages/man7/standards.7:264
msgid ""
"The revised standard is broken into the same four parts as POSIX.1-2001, and"
" again there are two levels of conformance: the baseline I<POSIX "
"Conformance>, and I<XSI Conformance>, which mandates an additional set of "
"interfaces beyond those in the base specification."
msgstr ""

#. type: Plain text
#: man-pages/man7/standards.7:268
msgid ""
"In general, where the CONFORMING TO section of a manual page lists "
"POSIX.1-2001, it can be assumed that the interface also conforms to "
"POSIX.1-2008, unless otherwise noted."
msgstr ""

#. type: Plain text
#: man-pages/man7/standards.7:273
msgid ""
"Technical Corrigendum 1 (minor fixes and improvements)  of this standard was"
" released in 2013 (referred to as I<POSIX.1-2013>)."
msgstr ""

#. type: Plain text
#: man-pages/man7/standards.7:275
msgid "Further information can be found on the Austin group web site,"
msgstr ""

#. type: Plain text
#: man-pages/man7/standards.7:280
msgid "B<feature_test_macros>(7), B<libc>(7), B<posixoptions>(7)"
msgstr "B<feature_test_macros>(7), B<libc>(7), B<posixoptions>(7)"

#. type: TH
#: man-pages/man7/suffixes.7:39
#, no-wrap
msgid "SUFFIXES"
msgstr "SUFFIXES"

#. type: TH
#: man-pages/man7/suffixes.7:39
#, no-wrap
msgid "2000-11-16"
msgstr "2000-11-16"

#. type: Plain text
#: man-pages/man7/suffixes.7:42
msgid "suffixes - list of file suffixes"
msgstr ""

#. type: Plain text
#: man-pages/man7/suffixes.7:50
msgid ""
"It is customary to indicate the contents of a file with the file suffix, "
"which consists of a period, followed by one or more letters.  Many standard "
"utilities, such as compilers, use this to recognize the type of file they "
"are dealing with.  The B<make>(1)  utility is driven by rules based on file "
"suffix."
msgstr ""

#. type: Plain text
#: man-pages/man7/suffixes.7:53
msgid ""
"Following is a list of suffixes which are likely to be found on a Linux "
"system."
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:58
#, no-wrap
msgid "Suffix\tFile type\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:59
#, no-wrap
msgid " ,v\tfiles for RCS (Revision Control System)\n"
msgstr " ,v\tфайлы для RCS (Revision Control System)\n"

#. type: tbl table
#: man-pages/man7/suffixes.7:60
#, no-wrap
msgid " -\tbackup file\n"
msgstr " -\tрезервная копия файла\n"

#. type: tbl table
#: man-pages/man7/suffixes.7:61
#, no-wrap
msgid " .C\tC++ source code, equivalent to I<.cc>\n"
msgstr " .C\tисходный код C++, эквивалент I<.cc>\n"

#. type: tbl table
#: man-pages/man7/suffixes.7:62
#, no-wrap
msgid " .F\tFortran source with B<cpp>(1) directives\n"
msgstr " .F\tисходный код Fortran с директивами B<cpp>(1)\n"

#. type: tbl table
#: man-pages/man7/suffixes.7:63
#, no-wrap
msgid "\tor file compressed using freeze\n"
msgstr "\tили файл, сжатый с помощью freeze\n"

#. type: tbl table
#: man-pages/man7/suffixes.7:64
#, no-wrap
msgid " .S\tassembler source with B<cpp>(1) directives\n"
msgstr " .S\tисходный код ассемблера с директивами B<cpp>(1)\n"

#. type: tbl table
#: man-pages/man7/suffixes.7:65
#, no-wrap
msgid " .Y\tfile compressed using yabba\n"
msgstr " .Y\tфайл, сжатый с помощью yabba\n"

#. type: tbl table
#: man-pages/man7/suffixes.7:66
#, no-wrap
msgid " .Z\tfile compressed using B<compress>(1)\n"
msgstr " .Z\tфайл, сжатый с помощью B<compress>(1)\n"

#. type: tbl table
#: man-pages/man7/suffixes.7:67
#, no-wrap
msgid " .[0-9]+gf\tTeX generic font files\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:68
#, no-wrap
msgid " .[0-9]+pk\tTeX packed font files\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:69
#, no-wrap
msgid " .[1-9]\tmanual page for the corresponding section\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:70
#, no-wrap
msgid " .[1-9][a-z]\tmanual page for section plus subsection\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:71
#, no-wrap
msgid " .a\tstatic object code library\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:72
#, no-wrap
msgid " .ad\tX application default resource file\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:73
#, no-wrap
msgid " .ada\tAda source (may be body, spec, or combination)\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:74
#, no-wrap
msgid " .adb\tAda body source\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:75
#, no-wrap
msgid " .ads\tAda spec source\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:76
#, no-wrap
msgid " .afm\tPostScript font metrics\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:77
#, no-wrap
msgid " .al\tPerl autoload file\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:78
#, no-wrap
msgid " .am\tB<automake>(1) input file\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:79
#, no-wrap
msgid " .arc\tB<arc>(1) archive\n"
msgstr " .arc\tархив B<arc>(1)\n"

#. type: tbl table
#: man-pages/man7/suffixes.7:80
#, no-wrap
msgid " .arj\tB<arj>(1) archive\n"
msgstr " .arj\tархив B<arj>(1)\n"

#. type: tbl table
#: man-pages/man7/suffixes.7:81
#, no-wrap
msgid " .asc\tPGP ASCII-armored data\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:82
#, no-wrap
msgid " .asm\t(GNU) assembler source file\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:83
#, no-wrap
msgid " .au\tAudio sound file\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:84
#, no-wrap
msgid " .aux\tLaTeX auxiliary file\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:85
#, no-wrap
msgid " .avi\t(msvideo) movie\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:86
#, no-wrap
msgid " .awk\tAWK language program\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:87
#, no-wrap
msgid " .b\tLILO boot loader image\n"
msgstr " .b\tобраз загрузчика LILO\n"

#. type: tbl table
#: man-pages/man7/suffixes.7:88
#, no-wrap
msgid " .bak\tbackup file\n"
msgstr " .bak\tрезервная копия файла\n"

#. type: tbl table
#: man-pages/man7/suffixes.7:89
#, no-wrap
msgid " .bash\tB<bash>(1) shell script\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:90
#, no-wrap
msgid " .bb\tbasic block list data produced by\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:91 man-pages/man7/suffixes.7:93
#, no-wrap
msgid "\tgcc -ftest-coverage\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:92
#, no-wrap
msgid " .bbg\tbasic block graph data produced by\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:94
#, no-wrap
msgid " .bbl\tBibTeX output\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:95
#, no-wrap
msgid " .bdf\tX font file\n"
msgstr " .bdf\tфайл шрифта X\n"

#. type: tbl table
#: man-pages/man7/suffixes.7:96
#, no-wrap
msgid " .bib\tTeX bibliographic database, BibTeX input\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:97
#, no-wrap
msgid " .bm\tbitmap source\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:98
#, no-wrap
msgid " .bmp\tbitmap\n"
msgstr " .bmp\tточечный рисунок\n"

#. type: tbl table
#: man-pages/man7/suffixes.7:99
#, no-wrap
msgid " .bz2\tfile compressed using B<bzip2>(1)\n"
msgstr " .Z\tфайл, сжатый с помощью B<bzip2>(1)\n"

#. type: tbl table
#: man-pages/man7/suffixes.7:100
#, no-wrap
msgid " .c\tC source\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:101
#, no-wrap
msgid " .cat\tmessage catalog files\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:102
#, no-wrap
msgid " .cc\tC++ source\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:103
#, no-wrap
msgid " .cf\tconfiguration file\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:104
#, no-wrap
msgid " .cfg\tconfiguration file\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:105
#, no-wrap
msgid " .cgi\tWWW content generating script or program\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:106
#, no-wrap
msgid " .cls\tLaTeX Class definition\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:107
#, no-wrap
msgid " .class\tJava compiled byte-code\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:108
#, no-wrap
msgid " .conf\tconfiguration file\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:109
#, no-wrap
msgid " .config\tconfiguration file\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:110
#, no-wrap
msgid " .cpp\tequivalent to I<.cc>\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:111
#, no-wrap
msgid " .csh\tB<csh>(1) shell script\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:112
#, no-wrap
msgid " .cxx\tequivalent to I<.cc>\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:113
#, no-wrap
msgid " .dat\tdata file\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:114
#, no-wrap
msgid " .deb\tDebian software package\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:115
#, no-wrap
msgid " .def\tModula-2 source for definition modules\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:116
#, no-wrap
msgid " .def\tother definition files\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:117
#, no-wrap
msgid " .desc\tinitial part of mail message unpacked with\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:118
#, no-wrap
msgid "\tB<munpack>(1)\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:119
#, no-wrap
msgid " .diff\tfile differences (B<diff>(1) command output)\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:120
#, no-wrap
msgid " .dir\tdbm data base directory file\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:121
#, no-wrap
msgid " .doc\tdocumentation file\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:122
#, no-wrap
msgid " .dsc\tDebian Source Control (source package)\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:123
#, no-wrap
msgid " .dtx\tLaTeX package source file\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:124
#, no-wrap
msgid " .dvi\tTeX's device independent output\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:125
#, no-wrap
msgid " .el\tEmacs-Lisp source\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:126
#, no-wrap
msgid " .elc\tcompiled Emacs-Lisp source\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:127
#, no-wrap
msgid " .eps\tencapsulated PostScript\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:128
#, no-wrap
msgid " .exp\tExpect source code\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:129
#, no-wrap
msgid " .f\tFortran source\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:130
#, no-wrap
msgid " .f77\tFortran 77 source\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:131
#, no-wrap
msgid " .f90\tFortran 90 source\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:132
#, no-wrap
msgid " .fas\tprecompiled Common-Lisp\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:133
#, no-wrap
msgid " .fi\tFortran include files\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:134
#, no-wrap
msgid " .fig\tFIG image file (used by B<xfig>(1))\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:135
#, no-wrap
msgid " .fmt\tTeX format file\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:136
#, no-wrap
msgid " .gif\tCompuserve Graphics Image File format\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:137
#, no-wrap
msgid " .gmo\tGNU format message catalog\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:138
#, no-wrap
msgid " .gsf\tGhostscript fonts\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:139
#, no-wrap
msgid " .gz\tfile compressed using B<gzip>(1)\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:140
#, no-wrap
msgid " .h\tC or C++ header files\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:141
#, no-wrap
msgid " .help\thelp file\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:142
#, no-wrap
msgid " .hf\tequivalent to I<.help>\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:143
#, no-wrap
msgid " .hlp\tequivalent to I<.help>\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:144
#, no-wrap
msgid " .htm\tpoor man's I<.html>\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:145
#, no-wrap
msgid " .html\tHTML document used with the World Wide Web\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:146
#, no-wrap
msgid " .hqx\t7-bit encoded Macintosh file\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:147
#, no-wrap
msgid " .i\tC source after preprocessing\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:148
#, no-wrap
msgid " .icon\tbitmap source\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:149
#, no-wrap
msgid " .idx\treference or datum-index file for hypertext\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:150
#, no-wrap
msgid "\tor database system\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:151
#, no-wrap
msgid " .image\tbitmap source\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:152
#, no-wrap
msgid " .in\tconfiguration template, especially for GNU Autoconf\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:153
#, no-wrap
msgid " .info\tfiles for the Emacs info browser\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:154
#, no-wrap
msgid " .info-[0-9]+\tsplit info files\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:155
#, no-wrap
msgid " .ins\tLaTeX package install file for docstrip\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:156
#, no-wrap
msgid " .itcl\titcl source code;\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:157
#, no-wrap
msgid "\titcl ([incr Tcl]) is an OO extension of tcl\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:158
#, no-wrap
msgid " .java\ta Java source file\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:159
#, no-wrap
msgid " .jpeg\tJoint Photographic Experts Group format\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:160
#, no-wrap
msgid " .jpg\tpoor man's I<.jpeg>\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:161
#, no-wrap
msgid " .kmap\tB<lyx>(1) keymap\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:162
#, no-wrap
msgid " .l\tequivalent to I<.lex> or I<.lisp>\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:163
#, no-wrap
msgid " .lex\tB<lex>(1) or B<flex>(1) files\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:164
#, no-wrap
msgid " .lha\tlharc archive\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:165
#, no-wrap
msgid " .lib\tCommon-Lisp library\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:166
#, no-wrap
msgid " .lisp\tLisp source\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:167
#, no-wrap
msgid " .ln\tfiles for use with B<lint>(1)\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:168
#, no-wrap
msgid " .log\tlog file, in particular produced by TeX\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:169
#, no-wrap
msgid " .lsm\tLinux Software Map entry\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:170
#, no-wrap
msgid " .lsp\tCommon-Lisp source\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:171
#, no-wrap
msgid " .lzh\tlharc archive\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:172
#, no-wrap
msgid " .m\tObjective-C source code\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:173
#, no-wrap
msgid " .m4\tB<m4>(1) source\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:174
#, no-wrap
msgid " .mac\tmacro files for various programs\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:175
#, no-wrap
msgid " .man\tmanual page (usually source rather than formatted)\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:176
#, no-wrap
msgid " .map\tmap files for various programs\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:177
#, no-wrap
msgid " .me\tNroff source using the me macro package\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:178
#, no-wrap
msgid " .mf\tMetafont (font generator for TeX) source\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:179
#, no-wrap
msgid " .mgp\tMagicPoint file\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:180
#, no-wrap
msgid " .mm\tsources for B<groff>(1) in mm - format\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:181
#, no-wrap
msgid " .mo\tMessage catalog binary file\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:182
#, no-wrap
msgid " .mod\tModula-2 source for implementation modules\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:183
#, no-wrap
msgid " .mov\t(quicktime) movie\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:184
#, no-wrap
msgid " .mp\tMetapost source\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:185
#, no-wrap
msgid " .mp2\tMPEG Layer 2 (audio) file\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:186
#, no-wrap
msgid " .mp3\tMPEG Layer 3 (audio) file\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:187
#, no-wrap
msgid " .mpeg\tmovie file\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:188
#, no-wrap
msgid " .o\tobject file\n"
msgstr " .o\tобъектный файл\n"

#. type: tbl table
#: man-pages/man7/suffixes.7:189
#, no-wrap
msgid " .old\told or backup file\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:190
#, no-wrap
msgid " .orig\tbackup (original) version of a file, from B<patch>(1)\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:191
#, no-wrap
msgid " .out\toutput file, often executable program (a.out)\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:192
#, no-wrap
msgid " .p\tPascal source\n"
msgstr " .p\tисходный код Pascal\n"

#. type: tbl table
#: man-pages/man7/suffixes.7:193
#, no-wrap
msgid " .pag\tdbm data base data file\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:194
#, no-wrap
msgid " .patch\tfile differences for B<patch>(1)\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:195
#, no-wrap
msgid " .pbm\tportable bitmap format\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:196
#, no-wrap
msgid " .pcf\tX11 font files\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:197
#, no-wrap
msgid " .pdf\tAdobe Portable Data Format\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:198
#, no-wrap
msgid "\t(use Acrobat/B<acroread> or B<xpdf>)\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:199
#, no-wrap
msgid " .perl\tPerl source (see .ph, .pl and .pm)\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:200
#, no-wrap
msgid " .pfa\tPostScript font definition files, ASCII format\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:201
#, no-wrap
msgid " .pfb\tPostScript font definition files, binary format\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:202
#, no-wrap
msgid " .pgm\tportable greymap format\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:203
#, no-wrap
msgid " .pgp\tPGP binary data\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:204
#, no-wrap
msgid " .ph\tPerl header file\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:205
#, no-wrap
msgid " .php\tPHP program file\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:206
#, no-wrap
msgid " .php3\tPHP3 program file\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:207
#, no-wrap
msgid " .pid\tFile to store daemon PID (e.g., crond.pid)\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:208
#, no-wrap
msgid " .pl\tTeX property list file or Perl library file\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:209
#, no-wrap
msgid " .pm\tPerl module\n"
msgstr " .pm\tмодуль Perl\n"

#. type: tbl table
#: man-pages/man7/suffixes.7:210
#, no-wrap
msgid " .png\tPortable Network Graphics file\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:211
#, no-wrap
msgid " .po\tMessage catalog source\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:212
#, no-wrap
msgid " .pod\tB<perldoc>(1) file\n"
msgstr " .pod\tфайл B<perldoc>(1)\n"

#. type: tbl table
#: man-pages/man7/suffixes.7:213
#, no-wrap
msgid " .ppm\tportable pixmap format\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:214
#, no-wrap
msgid " .pr\tbitmap source\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:215
#, no-wrap
msgid " .ps\tPostScript file\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:216
#, no-wrap
msgid " .py\tPython source\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:217
#, no-wrap
msgid " .pyc\tcompiled python\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:218
#, no-wrap
msgid " .qt\tquicktime movie\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:219
#, no-wrap
msgid " .r\tRATFOR source (obsolete)\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:220
#, no-wrap
msgid " .rej\tpatches that B<patch>(1) couldn't apply\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:221
#, no-wrap
msgid " .rpm\tRPM software package\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:222
#, no-wrap
msgid " .rtf\tRich Text Format file\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:223
#, no-wrap
msgid " .rules\trules for something\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:224
#, no-wrap
msgid " .s\tassembler source\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:225
#, no-wrap
msgid " .sa\tstub libraries for a.out shared libraries\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:226
#, no-wrap
msgid " .sc\tB<sc>(1) spreadsheet commands\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:227
#, no-wrap
msgid " .scm\tScheme source code\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:228
#, no-wrap
msgid " .sed\tsed source file\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:229
#, no-wrap
msgid " .sgml\tSGML source file\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:230
#, no-wrap
msgid " .sh\tB<sh>(1) scripts\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:231
#, no-wrap
msgid " .shar\tarchive created by the B<shar>(1) utility\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:232
#, no-wrap
msgid " .so\tShared library or dynamically loadable object\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:233
#, no-wrap
msgid " .sql\tSQL source\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:234
#, no-wrap
msgid " .sqml\tSQML schema or query program\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:235
#, no-wrap
msgid " .sty\tLaTeX style files\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:236
#, no-wrap
msgid " .sym\tModula-2 compiled definition modules\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:237
#, no-wrap
msgid " .tar\tarchive created by the B<tar>(1) utility\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:238
#, no-wrap
msgid " .tar.Z\ttar(1) archive compressed with B<compress>(1)\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:239
#, no-wrap
msgid " .tar.bz2\ttar(1) archive compressed with B<bzip2>(1)\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:240
#, no-wrap
msgid " .tar.gz\ttar(1) archive compressed with B<gzip>(1)\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:241
#, no-wrap
msgid " .taz\ttar(1) archive compressed with B<compress>(1)\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:242
#, no-wrap
msgid " .tcl\ttcl source code\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:243
#, no-wrap
msgid " .tex\tTeX or LaTeX source\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:244
#, no-wrap
msgid " .texi\tequivalent to I<.texinfo>\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:245
#, no-wrap
msgid " .texinfo\tTexinfo documentation source\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:246
#, no-wrap
msgid " .text\ttext file\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:247
#, no-wrap
msgid " .tfm\tTeX font metric file\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:248
#, no-wrap
msgid " .tgz\ttar archive compressed with B<gzip>(1)\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:249
#, no-wrap
msgid " .tif\tpoor man's I<.tiff>\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:250
#, no-wrap
msgid " .tiff\tTagged Image File Format\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:251
#, no-wrap
msgid " .tk\ttcl/tk script\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:252
#, no-wrap
msgid " .tmp\ttemporary file\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:253
#, no-wrap
msgid " .tmpl\ttemplate files\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:254
#, no-wrap
msgid " .txt\tequivalent to I<.text>\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:255
#, no-wrap
msgid " .uu\tequivalent to I<.uue>\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:256
#, no-wrap
msgid " .uue\tbinary file encoded with B<uuencode>(1)\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:257
#, no-wrap
msgid " .vf\tTeX virtual font file\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:258
#, no-wrap
msgid " .vpl\tTeX virtual property list file\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:259
#, no-wrap
msgid " .w\tSilvio Levi's CWEB\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:260
#, no-wrap
msgid " .wav\twave sound file\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:261
#, no-wrap
msgid " .web\tDonald Knuth's WEB\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:262
#, no-wrap
msgid " .wml\tSource file for Web Meta Language\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:263
#, no-wrap
msgid " .xbm\tX11 bitmap source\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:264
#, no-wrap
msgid " .xcf\tGIMP graphic\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:265
#, no-wrap
msgid " .xml\teXtended Markup Language file\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:266
#, no-wrap
msgid " .xpm\tX11 pixmap source\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:267
#, no-wrap
msgid " .xs\tPerl xsub file produced by h2xs\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:268
#, no-wrap
msgid " .xsl\tXSL stylesheet\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:269
#, no-wrap
msgid " .y\tB<yacc>(1) or B<bison>(1) (parser generator) files\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:270
#, no-wrap
msgid " .z\tFile compressed using B<pack>(1) (or an old B<gzip>(1))\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:271
#, no-wrap
msgid " .zip\tB<zip>(1) archive\n"
msgstr " .zip\tархив B<zip>(1)\n"

#. type: tbl table
#: man-pages/man7/suffixes.7:272
#, no-wrap
msgid " .zoo\tB<zoo>(1) archive\n"
msgstr " .zoo\tархив B<zoo>(1)\n"

#. type: tbl table
#: man-pages/man7/suffixes.7:273
#, no-wrap
msgid " ~\tEmacs or B<patch>(1) backup file\n"
msgstr ""

#. type: tbl table
#: man-pages/man7/suffixes.7:274
#, no-wrap
msgid " rc\tstartup (`run control') file, e.g., I<.newsrc>\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/suffixes.7:278
msgid "General UNIX conventions."
msgstr ""

#. type: Plain text
#: man-pages/man7/suffixes.7:280
msgid "This list is not exhaustive."
msgstr ""

#. type: Plain text
#: man-pages/man7/suffixes.7:282
msgid "B<file>(1), B<make>(1)"
msgstr "B<file>(1), B<make>(1)"

#. type: TH
#: man-pages/man7/symlink.7:37
#, no-wrap
msgid "SYMLINK"
msgstr "SYMLINK"

#. type: TH
#: man-pages/man7/symlink.7:37
#, no-wrap
msgid "2014-04-06"
msgstr "2014-04-06"

#. type: Plain text
#: man-pages/man7/symlink.7:40
msgid "symlink - symbolic link handling"
msgstr ""

#. type: Plain text
#: man-pages/man7/symlink.7:44
msgid ""
"Symbolic links are files that act as pointers to other files.  To understand"
" their behavior, you must first understand how hard links work."
msgstr ""

#. type: Plain text
#: man-pages/man7/symlink.7:60
msgid ""
"A hard link to a file is indistinguishable from the original file because it"
" is a reference to the object underlying the original filename.  (To be "
"precise: each of the hard links to a file is a reference to the same "
"I<i-node number>, where an i-node number is an index into the i-node table, "
"which contains metadata about all files on a filesystem.  See B<stat>(2).)  "
"Changes to a file are independent of the name used to reference the file.  "
"Hard links may not refer to directories (to prevent the possibility of loops"
" within the filesystem tree, which would confuse many programs)  and may not"
" refer to files on different filesystems (because i-node numbers are not "
"unique across filesystems)."
msgstr ""

#. type: Plain text
#: man-pages/man7/symlink.7:69
msgid ""
"A symbolic link is a special type of file whose contents are a string that "
"is the pathname of another file, the file to which the link refers.  (The "
"contents of a symbolic link can be read using B<readlink>(2).)  In other "
"words, a symbolic link is a pointer to another name, and not to an "
"underlying object.  For this reason, symbolic links may refer to directories"
" and may cross filesystem boundaries."
msgstr ""

#. type: Plain text
#: man-pages/man7/symlink.7:75
msgid ""
"There is no requirement that the pathname referred to by a symbolic link "
"should exist.  A symbolic link that refers to a pathname that does not exist"
" is said to be a I<dangling link>."
msgstr ""

#. type: Plain text
#: man-pages/man7/symlink.7:87
msgid ""
"Because a symbolic link and its referenced object coexist in the filesystem "
"name space, confusion can arise in distinguishing between the link itself "
"and the referenced object.  On historical systems, commands and system calls"
" adopted their own link-following conventions in a somewhat ad-hoc fashion."
"  Rules for a more uniform approach, as they are implemented on Linux and "
"other systems, are outlined here.  It is important that site-local "
"applications also conform to these rules, so that the user interface can be "
"as consistent as possible."
msgstr ""

#. type: SS
#: man-pages/man7/symlink.7:87
#, no-wrap
msgid "Symbolic link ownership, permissions, and timestamps"
msgstr ""

#. type: Plain text
#: man-pages/man7/symlink.7:95
msgid ""
"The owner and group of an existing symbolic link can be changed using "
"B<lchown>(2).  The only time that the ownership of a symbolic link matters "
"is when the link is being removed or renamed in a directory that has the "
"sticky bit set (see B<stat>(2))."
msgstr ""

#. type: Plain text
#: man-pages/man7/symlink.7:101
msgid ""
"The last access and last modification timestamps of a symbolic link can be "
"changed using B<utimensat>(2)  or B<lutimes>(3)."
msgstr ""

#.  Linux does not currently implement an lchmod(2).
#.  The
#.  4.4BSD
#.  system differs from historical
#.  4BSD
#.  systems in that the system call
#.  .BR chown (2)
#.  has been changed to follow symbolic links.
#.  The
#.  .BR lchown (2)
#.  system call was added later when the limitations of the new
#.  .BR chown (2)
#.  became apparent.
#. type: Plain text
#: man-pages/man7/symlink.7:120
msgid ""
"On Linux, the permissions of a symbolic link are not used in any operations;"
" the permissions are always 0777 (read, write, and execute for all user "
"categories), and can't be changed."
msgstr ""

#. type: SS
#: man-pages/man7/symlink.7:120
#, no-wrap
msgid "Obtaining a file descriptor that refers to a symbolic link"
msgstr ""

#. type: Plain text
#: man-pages/man7/symlink.7:138
msgid ""
"Using the combination of the B<O_PATH> and B<O_NOFOLLOW> flags to B<open>(2)"
"  yields a file descriptor that can be passed as the I<dirfd> argument in "
"system calls such as B<fstatat>(2), B<fchownat>(2), B<fchmodat>(2), "
"B<linkat>(2), and B<readlinkat>(2), in order to operate on the symbolic link"
" itself (rather than the file to which it refers)."
msgstr ""

#. type: Plain text
#: man-pages/man7/symlink.7:154
msgid ""
"By default (i.e., if the B<AT_SYMLINK_FOLLOW> flag is not specified), if "
"B<name_to_handle_at>(2)  is applied to a symbolic link, it yields a handle "
"for the symbolic link (rather than the file to which it refers).  One can "
"then obtain a file descriptor for the symbolic link (rather than the file to"
" which it refers)  by specifying the B<O_PATH> flag in a subsequent call to "
"B<open_by_handle_at>(2).  Again, that file descriptor can be used in the "
"aforementioned system calls to operate on the symbolic link itself."
msgstr ""

#. type: SS
#: man-pages/man7/symlink.7:154
#, no-wrap
msgid "Handling of symbolic links by system calls and commands"
msgstr ""

#. type: Plain text
#: man-pages/man7/symlink.7:169
msgid ""
"Symbolic links are handled either by operating on the link itself, or by "
"operating on the object referred to by the link.  In the latter case, an "
"application or system call is said to I<follow> the link.  Symbolic links "
"may refer to other symbolic links, in which case the links are dereferenced "
"until an object that is not a symbolic link is found, a symbolic link that "
"refers to a file which does not exist is found, or a loop is detected.  "
"(Loop detection is done by placing an upper limit on the number of links "
"that may be followed, and an error results if this limit is exceeded.)"
msgstr ""

#. type: Plain text
#: man-pages/man7/symlink.7:172
msgid ""
"There are three separate areas that need to be discussed.  They are as "
"follows:"
msgstr ""

#. type: Plain text
#: man-pages/man7/symlink.7:174
msgid "Symbolic links used as filename arguments for system calls."
msgstr ""

#. type: Plain text
#: man-pages/man7/symlink.7:177
msgid ""
"Symbolic links specified as command-line arguments to utilities that are not"
" traversing a file tree."
msgstr ""

#. type: Plain text
#: man-pages/man7/symlink.7:181
msgid ""
"Symbolic links encountered by utilities that are traversing a file tree "
"(either specified on the command line or encountered as part of the file "
"hierarchy walk)."
msgstr ""

#. type: SS
#: man-pages/man7/symlink.7:181
#, no-wrap
msgid "System calls"
msgstr "Системные вызовы"

#. type: Plain text
#: man-pages/man7/symlink.7:184
msgid ""
"The first area is symbolic links used as filename arguments for system "
"calls."
msgstr ""

#. type: Plain text
#: man-pages/man7/symlink.7:194
msgid ""
"Except as noted below, all system calls follow symbolic links.  For example,"
" if there were a symbolic link I<slink> which pointed to a file named "
"I<afile>, the system call I<open(\"slink\" ...\\&)> would return a file "
"descriptor referring to the file I<afile>."
msgstr ""

#. type: Plain text
#: man-pages/man7/symlink.7:209
msgid ""
"Various system calls do not follow links, and operate on the symbolic link "
"itself.  They are: B<lchown>(2), B<lgetxattr>(2), B<llistxattr>(2), "
"B<lremovexattr>(2), B<lsetxattr>(2), B<lstat>(2), B<readlink>(2), "
"B<rename>(2), B<rmdir>(2), and B<unlink>(2)."
msgstr ""

#.  Maybe one day: .BR fchownat (2)
#. type: Plain text
#: man-pages/man7/symlink.7:233
msgid ""
"Certain other system calls optionally follow symbolic links.  They are: "
"B<faccessat>(2), B<fchownat>(2), B<fstatat>(2), B<linkat>(2), "
"B<name_to_handle_at>(2), B<open>(2), B<openat>(2), B<open_by_handle_at>(2), "
"and B<utimensat>(2); see their manual pages for details.  Because "
"B<remove>(3)  is an alias for B<unlink>(2), that library function also does "
"not follow symbolic links.  When B<rmdir>(2)  is applied to a symbolic link,"
" it fails with the error B<ENOTDIR>."
msgstr ""

#. type: Plain text
#: man-pages/man7/symlink.7:248
msgid ""
"The B<link>(2)  warrants special discussion.  POSIX.1-2001 specifies that "
"B<link>(2)  should dereference I<oldpath> if it is a symbolic link.  "
"However, Linux does not do this.  (By default Solaris is the same, but the "
"POSIX.1-2001 specified behavior can be obtained with suitable compiler "
"options.)  The upcoming POSIX.1 revision changes the specification to allow "
"either behavior in an implementation."
msgstr ""

#. type: SS
#: man-pages/man7/symlink.7:248
#, no-wrap
msgid "Commands not traversing a file tree"
msgstr ""

#. type: Plain text
#: man-pages/man7/symlink.7:251
msgid ""
"The second area is symbolic links, specified as command-line filename "
"arguments, to commands which are not traversing a file tree."
msgstr ""

#. type: Plain text
#: man-pages/man7/symlink.7:262
msgid ""
"Except as noted below, commands follow symbolic links named as command-line "
"arguments.  For example, if there were a symbolic link I<slink> which "
"pointed to a file named I<afile>, the command I<cat slink> would display the"
" contents of the file I<afile>."
msgstr ""

#. type: Plain text
#: man-pages/man7/symlink.7:270
msgid ""
"It is important to realize that this rule includes commands which may "
"optionally traverse file trees; for example, the command I<chown file> is "
"included in this rule, while the command I<chown\\ -R file>, which performs "
"a tree traversal, is not.  (The latter is described in the third area, "
"below.)"
msgstr ""

#. type: Plain text
#: man-pages/man7/symlink.7:288
msgid ""
"If it is explicitly intended that the command operate on the symbolic link "
"instead of following the symbolic link\\(emfor example, it is desired that "
"I<chown slink> change the ownership of the file that I<slink> is, whether it"
" is a symbolic link or not\\(emthe I<-h> option should be used.  In the "
"above example, I<chown root slink> would change the ownership of the file "
"referred to by I<slink>, while I<chown\\ -h root slink> would change the "
"ownership of I<slink> itself."
msgstr ""

#. type: Plain text
#: man-pages/man7/symlink.7:290
msgid "There are some exceptions to this rule:"
msgstr ""

#. type: Plain text
#: man-pages/man7/symlink.7:300
msgid ""
"The B<mv>(1)  and B<rm>(1)  commands do not follow symbolic links named as "
"arguments, but respectively attempt to rename and delete them.  (Note, if "
"the symbolic link references a file via a relative path, moving it to "
"another directory may very well cause it to stop working, since the path may"
" no longer be correct.)"
msgstr ""

#. type: Plain text
#: man-pages/man7/symlink.7:330
msgid ""
"The B<ls>(1)  command is also an exception to this rule.  For compatibility "
"with historic systems (when B<ls>(1)  is not doing a tree walk\\(emthat is, "
"I<-R> option is not specified), the B<ls>(1)  command follows symbolic links"
" named as arguments if the I<-H> or I<-L> option is specified, or if the "
"I<-F>, I<-d>, or I<-l> options are not specified.  (The B<ls>(1)  command is"
" the only command where the I<-H> and I<-L> options affect its behavior even"
" though it is not doing a walk of a file tree.)"
msgstr ""

#. The 4.4BSD system differs from historical 4BSD systems in that the
#. .BR chown (1)
#. and
#. .BR chgrp (1)
#. commands follow symbolic links specified on the command line.
#. type: Plain text
#: man-pages/man7/symlink.7:348
msgid ""
"The B<file>(1)  command is also an exception to this rule.  The B<file>(1)  "
"command does not follow symbolic links named as argument by default.  The "
"B<file>(1)  command does follow symbolic links named as argument if the "
"I<-L> option is specified."
msgstr ""

#. type: SS
#: man-pages/man7/symlink.7:348
#, no-wrap
msgid "Commands traversing a file tree"
msgstr ""

#. type: Plain text
#: man-pages/man7/symlink.7:361
msgid ""
"The following commands either optionally or always traverse file trees: "
"B<chgrp>(1), B<chmod>(1), B<chown>(1), B<cp>(1), B<du>(1), B<find>(1), "
"B<ls>(1), B<pax>(1), B<rm>(1), and B<tar>(1)."
msgstr ""

#. type: Plain text
#: man-pages/man7/symlink.7:365
msgid ""
"It is important to realize that the following rules apply equally to "
"symbolic links encountered during the file tree traversal and symbolic links"
" listed as command-line arguments."
msgstr ""

#. type: Plain text
#: man-pages/man7/symlink.7:370
msgid ""
"The I<first rule> applies to symbolic links that reference files other than "
"directories.  Operations that apply to symbolic links are performed on the "
"links themselves, but otherwise the links are ignored."
msgstr ""

#. type: Plain text
#: man-pages/man7/symlink.7:382
msgid ""
"The command I<rm\\ -r slink directory> will remove I<slink>, as well as any "
"symbolic links encountered in the tree traversal of I<directory>, because "
"symbolic links may be removed.  In no case will B<rm>(1)  affect the file "
"referred to by I<slink>."
msgstr ""

#. type: Plain text
#: man-pages/man7/symlink.7:387
msgid ""
"The I<second rule> applies to symbolic links that refer to directories.  "
"Symbolic links that refer to directories are never followed by default.  "
"This is often referred to as a \"physical\" walk, as opposed to a "
"\"logical\" walk (where symbolic links the refer to directories are "
"followed)."
msgstr ""

#. type: Plain text
#: man-pages/man7/symlink.7:390
msgid ""
"Certain conventions are (should be) followed as consistently as possible by "
"commands that perform file tree walks:"
msgstr ""

#. type: Plain text
#: man-pages/man7/symlink.7:403
msgid ""
"A command can be made to follow any symbolic links named on the command "
"line, regardless of the type of file they reference, by specifying the I<-H>"
" (for \"half-logical\") flag.  This flag is intended to make the command-"
"line name space look like the logical name space.  (Note, for commands that "
"do not always do file tree traversals, the I<-H> flag will be ignored if the"
" I<-R> flag is not also specified.)"
msgstr ""

#. type: Plain text
#: man-pages/man7/symlink.7:419
msgid ""
"For example, the command I<chown\\ -HR user slink> will traverse the file "
"hierarchy rooted in the file pointed to by I<slink>.  Note, the I<-H> is not"
" the same as the previously discussed I<-h> flag.  The I<-H> flag causes "
"symbolic links specified on the command line to be dereferenced for the "
"purposes of both the action to be performed and the tree walk, and it is as "
"if the user had specified the name of the file to which the symbolic link "
"pointed."
msgstr ""

#. type: Plain text
#: man-pages/man7/symlink.7:433
msgid ""
"A command can be made to follow any symbolic links named on the command "
"line, as well as any symbolic links encountered during the traversal, "
"regardless of the type of file they reference, by specifying the I<-L> (for "
"\"logical\") flag.  This flag is intended to make the entire name space look"
" like the logical name space.  (Note, for commands that do not always do "
"file tree traversals, the I<-L> flag will be ignored if the I<-R> flag is "
"not also specified.)"
msgstr ""

#. type: Plain text
#: man-pages/man7/symlink.7:448
msgid ""
"For example, the command I<chown\\ -LR user slink> will change the owner of "
"the file referred to by I<slink>.  If I<slink> refers to a directory, "
"B<chown> will traverse the file hierarchy rooted in the directory that it "
"references.  In addition, if any symbolic links are encountered in any file "
"tree that B<chown> traverses, they will be treated in the same fashion as "
"I<slink>."
msgstr ""

#. type: Plain text
#: man-pages/man7/symlink.7:455
msgid ""
"A command can be made to provide the default behavior by specifying the "
"I<-P> (for \"physical\") flag.  This flag is intended to make the entire "
"name space look like the physical name space."
msgstr ""

#. type: Plain text
#: man-pages/man7/symlink.7:473
msgid ""
"For commands that do not by default do file tree traversals, the I<-H>, "
"I<-L>, and I<-P> flags are ignored if the I<-R> flag is not also specified."
"  In addition, you may specify the I<-H>, I<-L>, and I<-P> options more than"
" once; the last one specified determines the command's behavior.  This is "
"intended to permit you to alias commands to behave one way or the other, and"
" then override that behavior on the command line."
msgstr ""

#. type: Plain text
#: man-pages/man7/symlink.7:479
msgid "The B<ls>(1)  and B<rm>(1)  commands have exceptions to these rules:"
msgstr ""

#. type: Plain text
#: man-pages/man7/symlink.7:492
msgid ""
"The B<rm>(1)  command operates on the symbolic link, and not the file it "
"references, and therefore never follows a symbolic link.  The B<rm>(1)  "
"command does not support the I<-H>, I<-L>, or I<-P> options."
msgstr ""

#. type: Plain text
#: man-pages/man7/symlink.7:512
msgid ""
"To maintain compatibility with historic systems, the B<ls>(1)  command acts "
"a little differently.  If you do not specify the I<-F>, I<-d> or I<-l> "
"options, B<ls>(1)  will follow symbolic links specified on the command line."
"  If the I<-L> flag is specified, B<ls>(1)  follows all symbolic links, "
"regardless of their type, whether specified on the command line or "
"encountered in the tree walk."
msgstr ""

#. type: Plain text
#: man-pages/man7/symlink.7:529
msgid ""
"B<chgrp>(1), B<chmod>(1), B<find>(1), B<ln>(1), B<ls>(1), B<mv>(1), "
"B<rm>(1), B<lchown>(2), B<link>(2), B<lstat>(2), B<readlink>(2), "
"B<rename>(2), B<symlink>(2), B<unlink>(2), B<utimensat>(2), B<lutimes>(3), "
"B<path_resolution>(7)"
msgstr ""

#. type: TH
#: man-pages/man7/spufs.7:27
#, no-wrap
msgid "SPUFS"
msgstr "SPUFS"

#. type: TH
#: man-pages/man7/spufs.7:27
#, no-wrap
msgid "2007-12-20"
msgstr "2007-12-20"

#. type: Plain text
#: man-pages/man7/spufs.7:30
msgid "spufs - SPU filesystem"
msgstr ""

#. type: Plain text
#: man-pages/man7/spufs.7:34
msgid ""
"The SPU filesystem is used on PowerPC machines that implement the Cell "
"Broadband Engine Architecture in order to access Synergistic Processor Units"
" (SPUs)."
msgstr ""

#. type: Plain text
#: man-pages/man7/spufs.7:43
msgid ""
"The filesystem provides a name space similar to POSIX shared memory or "
"message queues.  Users that have write permissions on the filesystem can use"
" B<spu_create>(2)  to establish SPU contexts under the B<spufs> root "
"directory."
msgstr ""

#. type: Plain text
#: man-pages/man7/spufs.7:50
msgid ""
"Every SPU context is represented by a directory containing a predefined set "
"of files.  These files can be used for manipulating the state of the logical"
" SPU.  Users can change permissions on the files, but can't add or remove "
"files."
msgstr ""

#. type: SS
#: man-pages/man7/spufs.7:50
#, no-wrap
msgid "Mount options"
msgstr "Параметры монтирования"

#. type: TP
#: man-pages/man7/spufs.7:51
#, no-wrap
msgid "B<uid=E<lt>uidE<gt>>"
msgstr "B<uid=E<lt>uidE<gt>>"

#. type: Plain text
#: man-pages/man7/spufs.7:54
msgid "Set the user owning the mount point; the default is 0 (root)."
msgstr ""

#. type: TP
#: man-pages/man7/spufs.7:54
#, no-wrap
msgid "B<gid=E<lt>gidE<gt>>"
msgstr "B<gid=E<lt>gidE<gt>>"

#. type: Plain text
#: man-pages/man7/spufs.7:57
msgid "Set the group owning the mount point; the default is 0 (root)."
msgstr ""

#. type: TP
#: man-pages/man7/spufs.7:57
#, no-wrap
msgid "B<mode=E<lt>modeE<gt>>"
msgstr "B<mode=E<lt>modeE<gt>>"

#. type: Plain text
#: man-pages/man7/spufs.7:63
msgid ""
"Set the mode of the top-level directory in B<spufs>, as an octal mode "
"string.  The default is 0775."
msgstr ""

#. type: SS
#: man-pages/man7/spufs.7:63
#, no-wrap
msgid "Files"
msgstr "Файлы"

#. type: Plain text
#: man-pages/man7/spufs.7:75
msgid ""
"The files in B<spufs> mostly follow the standard behavior for regular system"
" calls like B<read>(2)  or B<write>(2), but often support only a subset of "
"the operations supported on regular filesystems.  This list details the "
"supported operations and the deviations from the standard behavior described"
" in the respective man pages."
msgstr ""

#. type: Plain text
#: man-pages/man7/spufs.7:97
msgid ""
"All files that support the B<read>(2)  operation also support B<readv>(2)  "
"and all files that support the B<write>(2)  operation also support "
"B<writev>(2).  All files support the B<access>(2)  and B<stat>(2)  family of"
" operations, but for the latter call, the only fields of the returned "
"I<stat> structure that contain reliable information are I<st_mode>, "
"I<st_nlink>, I<st_uid>, and I<st_gid>."
msgstr ""

#. type: Plain text
#: man-pages/man7/spufs.7:106
msgid ""
"All files support the B<chmod>(2)/B<fchmod>(2)  and B<chown>(2)/B<fchown>(2)"
"  operations, but will not be able to grant permissions that contradict the "
"possible operations (e.g., read access on the I<wbox> file)."
msgstr ""

#. type: Plain text
#: man-pages/man7/spufs.7:108
msgid "The current set of files is:"
msgstr ""

#. type: TP
#: man-pages/man7/spufs.7:108
#, no-wrap
msgid "I</capabilities>"
msgstr ""

#. type: Plain text
#: man-pages/man7/spufs.7:113
msgid ""
"Contains a comma-delimited string representing the capabilities of this SPU "
"context.  Possible capabilities are:"
msgstr ""

#. type: TP
#: man-pages/man7/spufs.7:114
#, no-wrap
msgid "B<sched>"
msgstr "B<sched>"

#. type: Plain text
#: man-pages/man7/spufs.7:117
msgid "This context may be scheduled."
msgstr ""

#. type: TP
#: man-pages/man7/spufs.7:117
#, no-wrap
msgid "B<step>"
msgstr "B<step>"

#. type: Plain text
#: man-pages/man7/spufs.7:120
msgid "This context can be run in single-step mode, for debugging."
msgstr ""

#. type: Plain text
#: man-pages/man7/spufs.7:122
msgid "New capabilities flags may be added in the future."
msgstr ""

#. type: TP
#: man-pages/man7/spufs.7:123
#, no-wrap
msgid "I</mem>"
msgstr "I</mem>"

#. type: Plain text
#: man-pages/man7/spufs.7:132
msgid ""
"the contents of the local storage memory of the SPU.  This can be accessed "
"like a regular shared memory file and contains both code and data in the "
"address space of the SPU.  The possible operations on an open I<mem> file "
"are:"
msgstr ""

#. type: TP
#: man-pages/man7/spufs.7:133
#, no-wrap
msgid "B<read>(2), B<pread>(2), B<write>(2), B<pwrite>(2), B<lseek>(2)"
msgstr ""

#. type: Plain text
#: man-pages/man7/spufs.7:144
msgid ""
"These operate as usual, with the exception that B<lseek>(2), B<write>(2), "
"and B<pwrite>(2)  are not supported beyond the end of the file.  The file "
"size is the size of the local storage of the SPU, which is normally 256 "
"kilobytes."
msgstr ""

#. type: TP
#: man-pages/man7/spufs.7:144 man-pages/man7/spufs.7:706
#: man-pages/man7/spufs.7:725
#, no-wrap
msgid "B<mmap>(2)"
msgstr "B<mmap>(2)"

#. type: Plain text
#: man-pages/man7/spufs.7:153
msgid ""
"Mapping I<mem> into the process address space provides access to the SPU "
"local storage within the process address space.  Only B<MAP_SHARED> mappings"
" are allowed."
msgstr ""

#. type: TP
#: man-pages/man7/spufs.7:154
#, no-wrap
msgid "I</regs>"
msgstr "I</regs>"

#. type: Plain text
#: man-pages/man7/spufs.7:161
msgid ""
"Contains the saved general-purpose registers of the SPU context.  This file "
"contains the 128-bit values of each register, from register 0 to register "
"127, in order.  This allows the general-purpose registers to be inspected "
"for debugging."
msgstr ""

#. type: Plain text
#: man-pages/man7/spufs.7:165
msgid ""
"Reading to or writing from this file requires that the context is scheduled "
"out, so use of this file is not recommended in normal program operation."
msgstr ""

#. type: Plain text
#: man-pages/man7/spufs.7:171
msgid ""
"The I<regs> file is not present on contexts that have been created with the "
"B<SPU_CREATE_NOSCHED> flag."
msgstr ""

#. type: TP
#: man-pages/man7/spufs.7:171
#, no-wrap
msgid "I</mbox>"
msgstr "I</mbox>"

#. type: Plain text
#: man-pages/man7/spufs.7:181
msgid ""
"The first SPU-to-CPU communication mailbox.  This file is read-only and can "
"be read in units of 4 bytes.  The file can be used only in nonblocking mode "
"- even B<poll>(2)  cannot be used to block on this file.  The only possible "
"operation on an open I<mbox> file is:"
msgstr ""

#. type: TP
#: man-pages/man7/spufs.7:182 man-pages/man7/spufs.7:222
#: man-pages/man7/spufs.7:317 man-pages/man7/spufs.7:381
#: man-pages/man7/spufs.7:418 man-pages/man7/spufs.7:463
#: man-pages/man7/spufs.7:517 man-pages/man7/spufs.7:632
#: man-pages/man7/spufs.7:676 man-pages/man7/spufs.7:754
#, no-wrap
msgid "B<read>(2)"
msgstr "B<read>(2)"

#. type: Plain text
#: man-pages/man7/spufs.7:200
msgid ""
"If I<count> is smaller than four, B<read>(2)  returns -1 and sets I<errno> "
"to B<EINVAL>.  If there is no data available in the mailbox (i.e., the SPU "
"has not sent a mailbox message), the return value is set to -1 and I<errno> "
"is set to B<EAGAIN>.  When data has been read successfully, four bytes are "
"placed in the data buffer and the value four is returned."
msgstr ""

#. type: TP
#: man-pages/man7/spufs.7:201
#, no-wrap
msgid "I</ibox>"
msgstr "I</ibox>"

#. type: Plain text
#: man-pages/man7/spufs.7:217
msgid ""
"The second SPU-to-CPU communication mailbox.  This file is similar to the "
"first mailbox file, but can be read in blocking I/O mode, thus calling "
"B<read>(2)  on an open I<ibox> file will block until the SPU has written "
"data to its interrupt mailbox channel (unless the file has been opened with "
"B<O_NONBLOCK>, see below).  Also, B<poll>(2)  and similar system calls can "
"be used to monitor for the presence of mailbox data."
msgstr ""

#. type: Plain text
#: man-pages/man7/spufs.7:221
msgid "The possible operations on an open I<ibox> file are:"
msgstr ""

#. type: Plain text
#: man-pages/man7/spufs.7:239
msgid ""
"If I<count> is smaller than four, B<read>(2)  returns -1 and sets I<errno> "
"to B<EINVAL>.  If there is no data available in the mailbox and the file "
"descriptor has been opened with B<O_NONBLOCK>, the return value is set to -1"
" and I<errno> is set to B<EAGAIN>."
msgstr ""

#. type: Plain text
#: man-pages/man7/spufs.7:247
msgid ""
"If there is no data available in the mailbox and the file descriptor has "
"been opened without B<O_NONBLOCK>, the call will block until the SPU writes "
"to its interrupt mailbox channel.  When data has been read successfully, "
"four bytes are placed in the data buffer and the value four is returned."
msgstr ""

#. type: TP
#: man-pages/man7/spufs.7:247 man-pages/man7/spufs.7:295
#: man-pages/man7/spufs.7:685
#, no-wrap
msgid "B<poll>(2)"
msgstr "B<poll>(2)"

#. type: Plain text
#: man-pages/man7/spufs.7:254
msgid ""
"Poll on the I<ibox> file returns I<(POLLIN | POLLRDNORM)> whenever data is "
"available for reading."
msgstr ""

#. type: TP
#: man-pages/man7/spufs.7:255
#, no-wrap
msgid "I</wbox>"
msgstr "I</wbox>"

#. type: Plain text
#: man-pages/man7/spufs.7:267
msgid ""
"The CPU-to-SPU communication mailbox.  It is write-only and can be written "
"in units of four bytes.  If the mailbox is full, B<write>(2)  will block, "
"and B<poll>(2)  can be used to block until the mailbox is available for "
"writing again.  The possible operations on an open I<wbox> file are:"
msgstr ""

#. type: TP
#: man-pages/man7/spufs.7:268 man-pages/man7/spufs.7:392
#: man-pages/man7/spufs.7:432 man-pages/man7/spufs.7:476
#: man-pages/man7/spufs.7:527 man-pages/man7/spufs.7:638
#: man-pages/man7/spufs.7:652 man-pages/man7/spufs.7:749
#, no-wrap
msgid "B<write>(2)"
msgstr "B<write>(2)"

#. type: Plain text
#: man-pages/man7/spufs.7:286
msgid ""
"If I<count> is smaller than four, B<write>(2)  returns -1 and sets I<errno> "
"to B<EINVAL>.  If there is no space available in the mailbox and the file "
"descriptor has been opened with B<O_NONBLOCK>, the return value is set to -1"
" and I<errno> is set to B<EAGAIN>."
msgstr ""

#. type: Plain text
#: man-pages/man7/spufs.7:295
msgid ""
"If there is no space available in the mailbox and the file descriptor has "
"been opened without B<O_NONBLOCK>, the call will block until the SPU reads "
"from its PPE (PowerPC Processing Element)  mailbox channel.  When data has "
"been written successfully, the system call returns four as its function "
"result."
msgstr ""

#. type: Plain text
#: man-pages/man7/spufs.7:302
msgid ""
"A poll on the I<wbox> file returns I<(POLLOUT | POLLWRNORM)> whenever space "
"is available for writing."
msgstr ""

#. type: TP
#: man-pages/man7/spufs.7:303
#, no-wrap
msgid "I</mbox_stat>, I</ibox_stat>, I</wbox_stat>"
msgstr "I</mbox_stat>, I</ibox_stat>, I</wbox_stat>"

#. type: Plain text
#: man-pages/man7/spufs.7:316
msgid ""
"These are read-only files that contain the length of the current queue of "
"each mailbox\\(emthat is, how many words can be read from I<mbox> or I<ibox>"
" or how many words can be written to I<wbox> without blocking.  The files "
"can be read only in four-byte units and return a big-endian binary integer "
"number.  The only possible operation on an open I<*box_stat> file is:"
msgstr ""

#. type: Plain text
#: man-pages/man7/spufs.7:337
msgid ""
"If I<count> is smaller than four, B<read>(2)  returns -1 and sets I<errno> "
"to B<EINVAL>.  Otherwise, a four-byte value is placed in the data buffer.  "
"This value is the number of elements that can be read from (for I<mbox_stat>"
" and I<ibox_stat>)  or written to (for I<wbox_stat>)  the respective mailbox"
" without blocking or returning an B<EAGAIN> error."
msgstr ""

#. type: TP
#: man-pages/man7/spufs.7:338
#, no-wrap
msgid ""
"I</npc>, I</decr>, I</decr_status>, I</spu_tag_mask>, I</event_mask>, "
"I</event_status>, I</srr0>, I</lslr>"
msgstr "I</npc>, I</decr>, I</decr_status>, I</spu_tag_mask>, I</event_mask>, I</event_status>, I</srr0>, I</lslr>"

#. type: Plain text
#: man-pages/man7/spufs.7:350
msgid ""
"Internal registers of the SPU.  These files contain an ASCII string "
"representing the hex value of the specified register.  Reads and writes on "
"these files (except for I<npc>, see below) require that the SPU context be "
"scheduled out, so frequent access to these files is not recommended for "
"normal program operation."
msgstr ""

#. type: Plain text
#: man-pages/man7/spufs.7:352
msgid "The contents of these files are:"
msgstr ""

#. type: TP
#: man-pages/man7/spufs.7:353
#, no-wrap
msgid "I<npc>"
msgstr "I<npc>"

#. type: Plain text
#: man-pages/man7/spufs.7:356
msgid "Next Program Counter - valid only when the SPU is in a stopped state."
msgstr ""

#. type: TP
#: man-pages/man7/spufs.7:356
#, no-wrap
msgid "I<decr>"
msgstr "I<decr>"

#. type: Plain text
#: man-pages/man7/spufs.7:359
msgid "SPU Decrementer"
msgstr ""

#. type: TP
#: man-pages/man7/spufs.7:359
#, no-wrap
msgid "I<decr_status>"
msgstr "I<decr_status>"

#. type: Plain text
#: man-pages/man7/spufs.7:362
msgid "Decrementer Status"
msgstr ""

#. type: TP
#: man-pages/man7/spufs.7:362
#, no-wrap
msgid "I<spu_tag_mask>"
msgstr "I<spu_tag_mask>"

#. type: Plain text
#: man-pages/man7/spufs.7:365
msgid "MFC tag mask for SPU DMA"
msgstr ""

#. type: TP
#: man-pages/man7/spufs.7:365
#, no-wrap
msgid "I<event_mask>"
msgstr "I<event_mask>"

#. type: Plain text
#: man-pages/man7/spufs.7:368
msgid "Event mask for SPU interrupts"
msgstr ""

#. type: TP
#: man-pages/man7/spufs.7:368
#, no-wrap
msgid "I<event_status>"
msgstr "I<event_status>"

#. type: Plain text
#: man-pages/man7/spufs.7:371
msgid "Number of SPU events pending (read-only)"
msgstr ""

#. type: TP
#: man-pages/man7/spufs.7:371
#, no-wrap
msgid "I<srr0>"
msgstr "I<srr0>"

#. type: Plain text
#: man-pages/man7/spufs.7:374
msgid "Interrupt Return address register"
msgstr ""

#. type: TP
#: man-pages/man7/spufs.7:374
#, no-wrap
msgid "I<lslr>"
msgstr "I<lslr>"

#. type: Plain text
#: man-pages/man7/spufs.7:377
msgid "Local Store Limit Register"
msgstr ""

#. type: Plain text
#: man-pages/man7/spufs.7:380
msgid "The possible operations on these files are:"
msgstr ""

#. type: Plain text
#: man-pages/man7/spufs.7:388
msgid ""
"Reads the current register value.  If the register value is larger than the "
"buffer passed to the B<read>(2)  system call, subsequent reads will continue"
" reading from the same buffer, until the end of the buffer is reached."
msgstr ""

#. type: Plain text
#: man-pages/man7/spufs.7:392
msgid ""
"When a complete string has been read, all subsequent read operations will "
"return zero bytes and a new file descriptor needs to be opened to read a new"
" value."
msgstr ""

#. type: Plain text
#: man-pages/man7/spufs.7:402 man-pages/man7/spufs.7:537
msgid ""
"A B<write>(2)  operation on the file sets the register to the value given in"
" the string.  The string is parsed from the beginning until the first "
"nonnumeric character or the end of the buffer.  Subsequent writes to the "
"same file descriptor overwrite the previous setting."
msgstr ""

#. type: Plain text
#: man-pages/man7/spufs.7:409
msgid ""
"Except for the I<npc> file, these files are not present on contexts that "
"have been created with the B<SPU_CREATE_NOSCHED> flag."
msgstr ""

#. type: TP
#: man-pages/man7/spufs.7:410
#, no-wrap
msgid "I</fpcr>"
msgstr "I</fpcr>"

#. type: Plain text
#: man-pages/man7/spufs.7:417
msgid ""
"This file provides access to the Floating Point Status and Control Register "
"(fcpr) as a binary, four-byte file.  The operations on the I<fpcr> file are:"
msgstr ""

#. type: Plain text
#: man-pages/man7/spufs.7:432
msgid ""
"If I<count> is smaller than four, B<read>(2)  returns -1 and sets I<errno> "
"to B<EINVAL>.  Otherwise, a four-byte value is placed in the data buffer; "
"this is the current value of the I<fpcr> register."
msgstr ""

#. type: Plain text
#: man-pages/man7/spufs.7:446
msgid ""
"If I<count> is smaller than four, B<write>(2)  returns -1 and sets I<errno> "
"to B<EINVAL>.  Otherwise, a four-byte value is copied from the data buffer, "
"updating the value of the I<fpcr> register."
msgstr ""

#. type: TP
#: man-pages/man7/spufs.7:447
#, no-wrap
msgid "I</signal1>, I</signal2>"
msgstr "I</signal1>, I</signal2>"

#. type: Plain text
#: man-pages/man7/spufs.7:462
msgid ""
"The files provide access to the two signal notification channels of an SPU."
"  These are read-write files that operate on four-byte words.  Writing to "
"one of these files triggers an interrupt on the SPU.  The value written to "
"the signal files can be read from the SPU through a channel read or from "
"host user space through the file.  After the value has been read by the SPU,"
" it is reset to zero.  The possible operations on an open I<signal1> or "
"I<signal2> file are:"
msgstr ""

#. type: Plain text
#: man-pages/man7/spufs.7:476
msgid ""
"If I<count> is smaller than four, B<read>(2)  returns -1 and sets I<errno> "
"to B<EINVAL>.  Otherwise, a four-byte value is placed in the data buffer; "
"this is the current value of the specified signal notification register."
msgstr ""

#. type: Plain text
#: man-pages/man7/spufs.7:497
msgid ""
"If I<count> is smaller than four, B<write>(2)  returns -1 and sets I<errno> "
"to B<EINVAL>.  Otherwise, a four-byte value is copied from the data buffer, "
"updating the value of the specified signal notification register.  The "
"signal notification register will either be replaced with the input data or "
"will be updated to the bitwise OR operation of the old value and the input "
"data, depending on the contents of the I<signal1_type> or I<signal2_type> "
"files respectively."
msgstr ""

#. type: TP
#: man-pages/man7/spufs.7:498
#, no-wrap
msgid "I</signal1_type>, I</signal2_type>"
msgstr "I</signal1_type>, I</signal2_type>"

#. type: Plain text
#: man-pages/man7/spufs.7:516
msgid ""
"These two files change the behavior of the I<signal1> and I<signal2> "
"notification files.  They contain a numeric ASCII string which is read as "
"either \"1\" or \"0\".  In mode 0 (overwrite), the hardware replaces the "
"contents of the signal channel with the data that is written to it.  In mode"
" 1 (logical OR), the hardware accumulates the bits that are subsequently "
"written to it.  The possible operations on an open I<signal1_type> or "
"I<signal2_type> file are:"
msgstr ""

#. type: Plain text
#: man-pages/man7/spufs.7:527
msgid ""
"When the count supplied to the B<read>(2)  call is shorter than the required"
" length for the digit (plus a newline character), subsequent reads from the "
"same file descriptor will complete the string.  When a complete string has "
"been read, all subsequent read operations will return zero bytes and a new "
"file descriptor needs to be opened to read the value again."
msgstr ""

#. type: TP
#: man-pages/man7/spufs.7:538
#, no-wrap
msgid ""
"I</mbox_info>, I</ibox_info>, I</wbox_info>, I</dma_into>, I</proxydma_info>"
msgstr "I</mbox_info>, I</ibox_info>, I</wbox_info>, I</dma_into>, I</proxydma_info>"

#. type: Plain text
#: man-pages/man7/spufs.7:557
msgid ""
"Read-only files that contain the saved state of the SPU mailboxes and DMA "
"queues.  This allows the SPU status to be inspected, mainly for debugging.  "
"The I<mbox_info> and I<ibox_info> files each contain the four-byte mailbox "
"message that has been written by the SPU.  If no message has been written to"
" these mailboxes, then contents of these files is undefined.  The "
"I<mbox_stat>, I<ibox_stat> and I<wbox_stat> files contain the available "
"message count."
msgstr ""

#. type: Plain text
#: man-pages/man7/spufs.7:566
msgid ""
"The I<wbox_info> file contains an array of four-byte mailbox messages, which"
" have been sent to the SPU.  With current CBEA machines, the array is four "
"items in length, so up to 4 * 4 = 16 bytes can be read from this file.  If "
"any mailbox queue entry is empty, then the bytes read at the corresponding "
"location are undefined."
msgstr ""

#. type: Plain text
#: man-pages/man7/spufs.7:571
msgid ""
"The I<dma_info> file contains the contents of the SPU MFC DMA queue, "
"represented as the following structure:"
msgstr ""

#. type: Plain text
#: man-pages/man7/spufs.7:582
#, no-wrap
msgid ""
"struct spu_dma_info {\n"
"    uint64_t         dma_info_type;\n"
"    uint64_t         dma_info_mask;\n"
"    uint64_t         dma_info_status;\n"
"    uint64_t         dma_info_stall_and_notify;\n"
"    uint64_t         dma_info_atomic_command_status;\n"
"    struct mfc_cq_sr dma_info_command_data[16];\n"
"};\n"
msgstr "struct spu_dma_info {\n    uint64_t         dma_info_type;\n    uint64_t         dma_info_mask;\n    uint64_t         dma_info_status;\n    uint64_t         dma_info_stall_and_notify;\n    uint64_t         dma_info_atomic_command_status;\n    struct mfc_cq_sr dma_info_command_data[16];\n};\n"

#. type: Plain text
#: man-pages/man7/spufs.7:590
msgid ""
"The last member of this data structure is the actual DMA queue, containing "
"16 entries.  The I<mfc_cq_sr> structure is defined as:"
msgstr ""

#. type: Plain text
#: man-pages/man7/spufs.7:599
#, no-wrap
msgid ""
"struct mfc_cq_sr {\n"
"    uint64_t mfc_cq_data0_RW;\n"
"    uint64_t mfc_cq_data1_RW;\n"
"    uint64_t mfc_cq_data2_RW;\n"
"    uint64_t mfc_cq_data3_RW;\n"
"};\n"
msgstr "struct mfc_cq_sr {\n    uint64_t mfc_cq_data0_RW;\n    uint64_t mfc_cq_data1_RW;\n    uint64_t mfc_cq_data2_RW;\n    uint64_t mfc_cq_data3_RW;\n};\n"

#. type: Plain text
#: man-pages/man7/spufs.7:607
msgid ""
"The I<proxydma_info> file contains similar information, but describes the "
"proxy DMA queue (i.e., DMAs initiated by entities outside the SPU) instead."
"  The file is in the following format:"
msgstr ""

#. type: Plain text
#: man-pages/man7/spufs.7:616
#, no-wrap
msgid ""
"struct spu_proxydma_info {\n"
"    uint64_t         proxydma_info_type;\n"
"    uint64_t         proxydma_info_mask;\n"
"    uint64_t         proxydma_info_status;\n"
"    struct mfc_cq_sr proxydma_info_command_data[8];\n"
"};\n"
msgstr "struct spu_proxydma_info {\n    uint64_t         proxydma_info_type;\n    uint64_t         proxydma_info_mask;\n    uint64_t         proxydma_info_status;\n    struct mfc_cq_sr proxydma_info_command_data[8];\n};\n"

#. type: Plain text
#: man-pages/man7/spufs.7:622
msgid ""
"Accessing these files requires that the SPU context is scheduled out - "
"frequent use can be inefficient.  These files should not be used for normal "
"program operation."
msgstr ""

#. type: Plain text
#: man-pages/man7/spufs.7:626
msgid ""
"These files are not present on contexts that have been created with the "
"B<SPU_CREATE_NOSCHED> flag."
msgstr ""

#. type: TP
#: man-pages/man7/spufs.7:626
#, no-wrap
msgid "I</cntl>"
msgstr "I</cntl>"

#. type: Plain text
#: man-pages/man7/spufs.7:631
msgid ""
"This file provides access to the SPU Run Control and SPU status registers, "
"as an ASCII string.  The following operations are supported:"
msgstr ""

#. type: Plain text
#: man-pages/man7/spufs.7:638
msgid ""
"Reads from the I<cntl> file will return an ASCII string with the hex value "
"of the SPU Status register."
msgstr ""

#. type: Plain text
#: man-pages/man7/spufs.7:643
msgid ""
"Writes to the I<cntl> file will set the context's SPU Run Control register."
msgstr ""

#. type: TP
#: man-pages/man7/spufs.7:644
#, no-wrap
msgid "I</mfc>"
msgstr "I</mfc>"

#. type: Plain text
#: man-pages/man7/spufs.7:651
msgid ""
"Provides access to the Memory Flow Controller of the SPU.  Reading from the "
"file returns the contents of the SPU's MFC Tag Status register, and writing "
"to the file initiates a DMA from the MFC.  The following operations are "
"supported:"
msgstr ""

#. type: Plain text
#: man-pages/man7/spufs.7:656
msgid ""
"Writes to this file need to be in the format of a MFC DMA command, defined "
"as follows:"
msgstr ""

#. type: Plain text
#: man-pages/man7/spufs.7:668
#, no-wrap
msgid ""
"struct mfc_dma_command {\n"
"    int32_t  pad;    /* reserved */\n"
"    uint32_t lsa;    /* local storage address */\n"
"    uint64_t ea;     /* effective address */\n"
"    uint16_t size;   /* transfer size */\n"
"    uint16_t tag;    /* command tag */\n"
"    uint16_t class;  /* class ID */\n"
"    uint16_t cmd;    /* command opcode */\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/spufs.7:676
msgid ""
"Writes are required to be exactly I<sizeof(struct mfc_dma_command)> bytes in"
" size.  The command will be sent to the SPU's MFC proxy queue, and the tag "
"stored in the kernel (see below)."
msgstr ""

#. type: Plain text
#: man-pages/man7/spufs.7:685
msgid ""
"Reads the contents of the tag status register.  If the file is opened in "
"blocking mode (i.e., without B<O_NONBLOCK>), then the read will block until "
"a DMA tag (as performed by a previous write) is complete.  In nonblocking "
"mode, the MFC tag status register will be returned without waiting."
msgstr ""

#. type: Plain text
#: man-pages/man7/spufs.7:698
msgid ""
"Calling B<poll>(2)  on the I<mfc> file will block until a new DMA can be "
"started (by checking for B<POLLOUT>)  or until a previously started DMA (by "
"checking for B<POLLIN>)  has been completed."
msgstr ""

#. type: Plain text
#: man-pages/man7/spufs.7:704
msgid ""
"I</mss> Provides access to the MFC MultiSource Synchronization (MSS) "
"facility.  By B<mmap>(2)-ing this file, processes can access the MSS area of"
" the SPU."
msgstr ""

#. type: Plain text
#: man-pages/man7/spufs.7:706 man-pages/man7/spufs.7:724
msgid "The following operations are supported:"
msgstr ""

#. type: Plain text
#: man-pages/man7/spufs.7:715
msgid ""
"Mapping B<mss> into the process address space gives access to the SPU MSS "
"area within the process address space.  Only B<MAP_SHARED> mappings are "
"allowed."
msgstr ""

#. type: TP
#: man-pages/man7/spufs.7:716
#, no-wrap
msgid "I</psmap>"
msgstr "I</psmap>"

#. type: Plain text
#: man-pages/man7/spufs.7:722
msgid ""
"Provides access to the whole problem-state mapping of the SPU.  Applications"
" can use this area to interface to the SPU, rather than writing to "
"individual register files in B<spufs>."
msgstr ""

#. type: Plain text
#: man-pages/man7/spufs.7:733
msgid ""
"Mapping B<psmap> gives a process a direct map of the SPU problem state area."
"  Only B<MAP_SHARED> mappings are supported."
msgstr ""

#. type: TP
#: man-pages/man7/spufs.7:734
#, no-wrap
msgid "I</phys-id>"
msgstr "I</phys-id>"

#. type: Plain text
#: man-pages/man7/spufs.7:740
msgid ""
"Read-only file containing the physical SPU number that the SPU context is "
"running on.  When the context is not running, this file contains the string "
"\"-1\"."
msgstr ""

#. type: Plain text
#: man-pages/man7/spufs.7:742
msgid "The physical SPU number is given by an ASCII hex string."
msgstr ""

#. type: TP
#: man-pages/man7/spufs.7:742
#, no-wrap
msgid "I</object-id>"
msgstr "I</object-id>"

#. type: Plain text
#: man-pages/man7/spufs.7:748
msgid ""
"Allows applications to store (or retrieve) a single 64-bit ID into the "
"context.  This ID is later used by profiling tools to uniquely identify the "
"context."
msgstr ""

#. type: Plain text
#: man-pages/man7/spufs.7:754
msgid ""
"By writing an ASCII hex value into this file, applications can set the "
"object ID of the SPU context.  Any previous value of the object ID is "
"overwritten."
msgstr ""

#. type: Plain text
#: man-pages/man7/spufs.7:758
msgid ""
"Reading this file gives an ASCII hex string representing the object ID for "
"this SPU context."
msgstr ""

#. type: TP
#: man-pages/man7/spufs.7:760
#, no-wrap
msgid "I</etc/fstab>  entry"
msgstr "запись в I</etc/fstab>"

#.  .SH AUTHORS
#.  Arnd Bergmann <arndb@de.ibm.com>, Mark Nutter <mnutter@us.ibm.com>,
#.  Ulrich Weigand <Ulrich.Weigand@de.ibm.com>, Jeremy Kerr <jk@ozlabs.org>
#. type: Plain text
#: man-pages/man7/spufs.7:766
msgid "none \t/spu \tspufs \tgid=spu \t0\t0"
msgstr "none \t/spu \tspufs \tgid=spu \t0\t0"

#. type: Plain text
#: man-pages/man7/spufs.7:771
msgid "B<close>(2), B<spu_create>(2), B<spu_run>(2), B<capabilities>(7)"
msgstr "B<close>(2), B<spu_create>(2), B<spu_run>(2), B<capabilities>(7)"

#. type: Plain text
#: man-pages/man7/spufs.7:772
msgid "I<The Cell Broadband Engine Architecture (CBEA) specification>"
msgstr ""

#. type: TH
#: man-pages/man7/sched.7:32
#, no-wrap
msgid "SCHED"
msgstr ""

#. type: TH
#: man-pages/man7/sched.7:32
#, no-wrap
msgid "2014-07-08"
msgstr ""

#. type: Plain text
#: man-pages/man7/sched.7:35
msgid "sched - overview of scheduling APIs"
msgstr ""

#. type: SS
#: man-pages/man7/sched.7:36
#, no-wrap
msgid "API summary"
msgstr ""

#. type: Plain text
#: man-pages/man7/sched.7:38
msgid "The Linux scheduling APIs are as follows:"
msgstr ""

#. type: TP
#: man-pages/man7/sched.7:38
#, no-wrap
msgid "B<sched_setscheduler>(2)"
msgstr ""

#. type: Plain text
#: man-pages/man7/sched.7:41
msgid "Set the scheduling policy and parameters of a specified thread."
msgstr ""

#. type: TP
#: man-pages/man7/sched.7:41
#, no-wrap
msgid "B<sched_getscheduler>(2)"
msgstr ""

#. type: Plain text
#: man-pages/man7/sched.7:44
msgid "Return the scheduling policy of a specified thread."
msgstr ""

#. type: TP
#: man-pages/man7/sched.7:44
#, no-wrap
msgid "B<sched_setparam>(2)"
msgstr ""

#. type: Plain text
#: man-pages/man7/sched.7:47
msgid "Set the scheduling parameters of a specified thread."
msgstr ""

#. type: TP
#: man-pages/man7/sched.7:47
#, no-wrap
msgid "B<sched_getparam>(2)"
msgstr ""

#. type: Plain text
#: man-pages/man7/sched.7:50
msgid "Fetch the scheduling parameters of a specified thread."
msgstr ""

#. type: TP
#: man-pages/man7/sched.7:50
#, no-wrap
msgid "B<sched_get_priority_max>(2)"
msgstr ""

#. type: Plain text
#: man-pages/man7/sched.7:53
msgid ""
"Return the minimum priority available in a specified scheduling policy."
msgstr ""

#. type: TP
#: man-pages/man7/sched.7:53
#, no-wrap
msgid "B<sched_get_priority_min>(2)"
msgstr ""

#. type: Plain text
#: man-pages/man7/sched.7:56
msgid ""
"Return the maximum priority available in a specified scheduling policy."
msgstr ""

#. type: TP
#: man-pages/man7/sched.7:56
#, no-wrap
msgid "B<sched_rr_get_interval>(2)"
msgstr ""

#. type: Plain text
#: man-pages/man7/sched.7:60
msgid ""
"Fetch the quantum used for threads that are scheduled under the \"round-"
"robin\" scheduling policy."
msgstr ""

#. type: TP
#: man-pages/man7/sched.7:60
#, no-wrap
msgid "B<sched_yield>(2)"
msgstr ""

#. type: Plain text
#: man-pages/man7/sched.7:64
msgid ""
"Cause the caller to relinquish the CPU, so that some other thread be "
"executed."
msgstr ""

#. type: TP
#: man-pages/man7/sched.7:64
#, no-wrap
msgid "B<sched_setaffinity>(2)"
msgstr ""

#. type: Plain text
#: man-pages/man7/sched.7:68
msgid "(Linux-specific)  Set the CPU affinity of a specified thread."
msgstr ""

#. type: TP
#: man-pages/man7/sched.7:68
#, no-wrap
msgid "B<sched_getaffinity>(2)"
msgstr ""

#. type: Plain text
#: man-pages/man7/sched.7:72
msgid "(Linux-specific)  Get the CPU affinity of a specified thread."
msgstr ""

#. type: TP
#: man-pages/man7/sched.7:72
#, no-wrap
msgid "B<sched_setattr>(2)"
msgstr ""

#. type: Plain text
#: man-pages/man7/sched.7:79
msgid ""
"Set the scheduling policy and parameters of a specified thread.  This "
"(Linux-specific) system call provides a superset of the functionality of "
"B<sched_setscheduler>(2)  and B<sched_setparam>(2)."
msgstr ""

#. type: TP
#: man-pages/man7/sched.7:79
#, no-wrap
msgid "B<sched_getattr>(2)"
msgstr ""

#. type: Plain text
#: man-pages/man7/sched.7:87
msgid ""
"Fetch the scheduling policy and parameters of a specified thread.  This "
"(Linux-specific) system call provides a superset of the functionality of "
"B<sched_getscheduler>(2)  and B<sched_getparam>(2)."
msgstr ""

#. type: SS
#: man-pages/man7/sched.7:87
#, no-wrap
msgid "Scheduling policies"
msgstr "Алгоритмы планирования"

#. type: Plain text
#: man-pages/man7/sched.7:95
msgid ""
"The scheduler is the kernel component that decides which runnable thread "
"will be executed by the CPU next.  Each thread has an associated scheduling "
"policy and a I<static> scheduling priority, I<sched_priority>.  The "
"scheduler makes its decisions based on knowledge of the scheduling policy "
"and static priority of all threads on the system."
msgstr ""

#. type: Plain text
#: man-pages/man7/sched.7:100
msgid ""
"For threads scheduled under one of the normal scheduling policies "
"(B<SCHED_OTHER>, B<SCHED_IDLE>, B<SCHED_BATCH>), I<sched_priority> is not "
"used in scheduling decisions (it must be specified as 0)."
msgstr "Для нитей, которые планируются одним из обычных алгоритмом планирования (B<SCHED_OTHER>, B<SCHED_IDLE>, B<SCHED_BATCH>), значение I<sched_priority> при принятии решения не используется (должен быть указан 0)."

#. type: Plain text
#: man-pages/man7/sched.7:114
msgid ""
"Processes scheduled under one of the real-time policies (B<SCHED_FIFO>, "
"B<SCHED_RR>) have a I<sched_priority> value in the range 1 (low) to 99 "
"(high).  (As the numbers imply, real-time threads always have higher "
"priority than normal threads.)  Note well: POSIX.1-2001 requires an "
"implementation to support only a minimum 32 distinct priority levels for the"
" real-time policies, and some systems supply just this minimum.  Portable "
"programs should use B<sched_get_priority_min>(2)  and "
"B<sched_get_priority_max>(2)  to find the range of priorities supported for "
"a particular policy."
msgstr "Для процессов, которые планируются одним из алгоритмов реального времени (B<SCHED_FIFO>, B<SCHED_RR>), значение приоритета I<sched_priority> лежит в диапазоне от 1 (низкий) до 99 (высокий) Как и числовые значения, нити реального времени всегда имеют более высокий приоритет чем обычные нити. Но заметим: согласно POSIX.1-2001 от реализации для алгоритмов реального времени требуется поддержка только 32 различных уровней приоритета, и в некоторых системах обеспечивается только этот минимум. В переносимых программах нужно использовать вызовы B<sched_get_priority_min>(2) и B<sched_get_priority_max>(2) для для определения диапазона приоритетов, поддерживаемых определённым алгоритмом."

#. type: Plain text
#: man-pages/man7/sched.7:120
msgid ""
"Conceptually, the scheduler maintains a list of runnable threads for each "
"possible I<sched_priority> value.  In order to determine which thread runs "
"next, the scheduler looks for the nonempty list with the highest static "
"priority and selects the thread at the head of this list."
msgstr "По существу, планировщик хранит в памяти списки всех работающих нитей для каждого возможного значения I<sched_priority>. Чтобы определить какую нить выполнять следующей, планировщик ищет непустой список с самым высоким статическим приоритетом и выбирает нить из начала списка."

#. type: Plain text
#: man-pages/man7/sched.7:124
msgid ""
"A thread's scheduling policy determines where it will be inserted into the "
"list of threads with equal static priority and how it will move inside this "
"list."
msgstr "Алгоритм планирования определяет, в какое место списка будет добавлена нить с тем же статическим приоритетом и как она будет перемещаться внутри этого списка."

#. type: Plain text
#: man-pages/man7/sched.7:132
msgid ""
"All scheduling is preemptive: if a thread with a higher static priority "
"becomes ready to run, the currently running thread will be preempted and "
"returned to the wait list for its static priority level.  The scheduling "
"policy determines the ordering only within the list of runnable threads with"
" equal static priority."
msgstr "Всё планирование основано на вытеснении: если нить с высшим статическим приоритетом готова к выполнению, текущая выполняющаяся нить будет вытеснена и возвращена в список ожидания согласно своему уровню статического приоритета. Алгоритм выполнения определяет порядок только внутри списка готовых к выполнению нитей с одинаковым статическим приоритетом."

#. type: SS
#: man-pages/man7/sched.7:132
#, no-wrap
msgid "SCHED_FIFO: First in-first out scheduling"
msgstr "SCHED_FIFO: планировщик «первым вошёл — первым вышел»"

#. type: Plain text
#: man-pages/man7/sched.7:141
msgid ""
"B<SCHED_FIFO> can be used only with static priorities higher than 0, which "
"means that when a B<SCHED_FIFO> threads becomes runnable, it will always "
"immediately preempt any currently running B<SCHED_OTHER>, B<SCHED_BATCH>, or"
" B<SCHED_IDLE> thread.  B<SCHED_FIFO> is a simple scheduling algorithm "
"without time slicing.  For threads scheduled under the B<SCHED_FIFO> policy,"
" the following rules apply:"
msgstr "Алгоритм B<SCHED_FIFO> можно использовать только со значениями статического приоритета большими нуля. Это означает, что если нить с B<SCHED_FIFO> готова к работе, то она сразу запустится, а все обычные нити с B<SCHED_OTHER>, B<SCHED_BATCH> или B<SCHED_IDLE> будут приостановлены. B<SCHED_FIFO> — это простой алгоритм планирования без квантования времени. Нити, работающие согласно алгоритму B<SCHED_FIFO>, подчиняются следующим правилам:"

#. type: Plain text
#: man-pages/man7/sched.7:146
msgid ""
"A B<SCHED_FIFO> thread that has been preempted by another thread of higher "
"priority will stay at the head of the list for its priority and will resume "
"execution as soon as all threads of higher priority are blocked again."
msgstr "Нить с алгоритмом B<SCHED_FIFO>, приостановленная другой нитью с большим приоритетом, останется в начале списка нитей с равным приоритетом, и её исполнение будет продолжено сразу после того, как закончатся нити с большими приоритетами."

#. type: Plain text
#: man-pages/man7/sched.7:149
msgid ""
"When a B<SCHED_FIFO> thread becomes runnable, it will be inserted at the end"
" of the list for its priority."
msgstr "Когда нить с алгоритмом B<SCHED_FIFO> готова к работе, она помещается в конец списка нитей с тем же приоритетом."

#.  In 2.2.x and 2.4.x, the thread is placed at the front of the queue
#.  In 2.0.x, the Right Thing happened: the thread went to the back -- MTK
#. type: Plain text
#: man-pages/man7/sched.7:164
msgid ""
"A call to B<sched_setscheduler>(2), B<sched_setparam>(2), or "
"B<sched_setattr>(2)  will put the B<SCHED_FIFO> (or B<SCHED_RR>) thread "
"identified by I<pid> at the start of the list if it was runnable.  As a "
"consequence, it may preempt the currently running thread if it has the same "
"priority.  (POSIX.1-2001 specifies that the thread should go to the end of "
"the list.)"
msgstr ""

#. type: Plain text
#: man-pages/man7/sched.7:168
msgid ""
"A thread calling B<sched_yield>(2)  will be put at the end of the list."
msgstr "Нить, вызывающая B<sched_yield>(2), будет помещена в конец списка."

#. type: Plain text
#: man-pages/man7/sched.7:172
msgid ""
"No other events will move a thread scheduled under the B<SCHED_FIFO> policy "
"in the wait list of runnable threads with equal static priority."
msgstr "Других событий для перемещения нити с алгоритмом B<SCHED_FIFO> в списке ожидания запускаемых нитей с одинаковым статическим приоритетом не существует."

#. type: Plain text
#: man-pages/man7/sched.7:177
msgid ""
"A B<SCHED_FIFO> thread runs until either it is blocked by an I/O request, it"
" is preempted by a higher priority thread, or it calls B<sched_yield>(2)."
msgstr "Нить с алгоритмом B<SCHED_FIFO> выполняется до тех пор, пока не будет заблокирована запросом ввода/вывода, вытеснена нитью с большим приоритетом или пока не вызовет B<sched_yield>(2)."

#. type: SS
#: man-pages/man7/sched.7:177
#, no-wrap
msgid "SCHED_RR: Round-robin scheduling"
msgstr "SCHED_RR: планирование выполнения по циклу"

#.  On Linux 2.4, the length of the RR interval is influenced
#.  by the process nice value -- MTK
#. type: Plain text
#: man-pages/man7/sched.7:196
msgid ""
"B<SCHED_RR> is a simple enhancement of B<SCHED_FIFO>.  Everything described "
"above for B<SCHED_FIFO> also applies to B<SCHED_RR>, except that each thread"
" is allowed to run only for a maximum time quantum.  If a B<SCHED_RR> thread"
" has been running for a time period equal to or longer than the time "
"quantum, it will be put at the end of the list for its priority.  A "
"B<SCHED_RR> thread that has been preempted by a higher priority thread and "
"subsequently resumes execution as a running thread will complete the "
"unexpired portion of its round-robin time quantum.  The length of the time "
"quantum can be retrieved using B<sched_rr_get_interval>(2)."
msgstr "B<SCHED_RR> — это просто улучшение B<SCHED_FIFO>. Всё, относящееся к B<SCHED_FIFO>, справедливо и для B<SCHED_RR> за исключением того, что каждой нити разрешено работать непрерывно не дольше максимального кванта времени. Если нить с алгоритмом B<SCHED_RR> работала столько же или дольше, чем квант, то она помещается в конец списка с тем же приоритетом. Нить с алгоритмом B<SCHED_RR>, вытесненная нитью с большим приоритетом, возобновляя работу, использует остаток своего кванта из старого цикла. Длину этого кванта можно узнать, вызвав B<sched_rr_get_interval>(2)."

#. type: SS
#: man-pages/man7/sched.7:196
#, no-wrap
msgid "SCHED_DEADLINE: Sporadic task model deadline scheduling"
msgstr ""

#. type: Plain text
#: man-pages/man7/sched.7:208
msgid ""
"Since version 3.14, Linux provides a deadline scheduling policy "
"(B<SCHED_DEADLINE>).  This policy is currently implemented using GEDF "
"(Global Earliest Deadline First)  in conjunction with CBS (Constant "
"Bandwidth Server).  To set and fetch this policy and associated attributes, "
"one must use the Linux-specific B<sched_setattr>(2)  and B<sched_getattr>(2)"
"  system calls."
msgstr ""

#. type: Plain text
#: man-pages/man7/sched.7:226
msgid ""
"A sporadic task is one that has a sequence of jobs, where each job is "
"activated at most once per period.  Each job also has a I<relative "
"deadline>, before which it should finish execution, and a I<computation "
"time>, which is the CPU time necessary for executing the job.  The moment "
"when a task wakes up because a new job has to be executed is called the "
"I<arrival time> (also referred to as the request time or release time).  The"
" I<start time> is the time at which a task starts its execution.  The "
"I<absolute deadline> is thus obtained by adding the relative deadline to the"
" arrival time."
msgstr ""

#. type: Plain text
#: man-pages/man7/sched.7:228
msgid "The following diagram clarifies these terms:"
msgstr ""

#. type: Plain text
#: man-pages/man7/sched.7:239
#, no-wrap
msgid ""
"arrival/wakeup                    absolute deadline\n"
"     |    start time                    |\n"
"     |        |                         |\n"
"     v        v                         v\n"
"-----x--------xooooooooooooooooo--------x--------x---\n"
"              |E<lt>- comp. time -E<gt>|\n"
"     |E<lt>------- relative deadline ------E<gt>|\n"
"     |E<lt>-------------- period -------------------E<gt>|\n"
msgstr ""

#. type: Plain text
#: man-pages/man7/sched.7:258
msgid ""
"When setting a B<SCHED_DEADLINE> policy for a thread using "
"B<sched_setattr>(2), one can specify three parameters: I<Runtime>, "
"I<Deadline>, and I<Period>.  These parameters do not necessarily correspond "
"to the aforementioned terms: usual practice is to set Runtime to something "
"bigger than the average computation time (or worst-case execution time for "
"hard real-time tasks), Deadline to the relative deadline, and Period to the "
"period of the task.  Thus, for B<SCHED_DEADLINE> scheduling, we have:"
msgstr ""

#. type: Plain text
#: man-pages/man7/sched.7:269
#, no-wrap
msgid ""
"arrival/wakeup                    absolute deadline\n"
"     |    start time                    |\n"
"     |        |                         |\n"
"     v        v                         v\n"
"-----x--------xooooooooooooooooo--------x--------x---\n"
"              |E<lt>-- Runtime -------E<gt>|\n"
"     |E<lt>----------- Deadline -----------E<gt>|\n"
"     |E<lt>-------------- Period -------------------E<gt>|\n"
msgstr ""

#.  FIXME It looks as though specifying sched_period as 0 means
#.        "make sched_period the same as sched_deadline", right?
#.        This needs to be documented.
#. type: Plain text
#: man-pages/man7/sched.7:289
msgid ""
"The three deadline-scheduling parameters correspond to the I<sched_runtime>,"
" I<sched_deadline>, and I<sched_period> fields of the I<sched_attr> "
"structure; see B<sched_setattr>(2).  These fields express value in "
"nanoseconds.  If I<sched_period> is specified as 0, then it is made the same"
" as I<sched_deadline>."
msgstr ""

#. type: Plain text
#: man-pages/man7/sched.7:291
msgid "The kernel requires that:"
msgstr ""

#. type: Plain text
#: man-pages/man7/sched.7:293
#, no-wrap
msgid "    sched_runtime E<lt>= sched_deadline E<lt>= sched_period\n"
msgstr ""

#.  See __checkparam_dl in kernel/sched/core.c
#. type: Plain text
#: man-pages/man7/sched.7:303
msgid ""
"In addition, under the current implementation, all of the parameter values "
"must be at least 1024 (i.e., just over one microsecond, which is the "
"resolution of the implementation), and less than 2^63.  If any of these "
"checks fails, B<sched_setattr>(2)  fails with the error B<EINVAL>."
msgstr ""

#. type: Plain text
#: man-pages/man7/sched.7:306
msgid ""
"The CBS guarantees non-interference between tasks, by throttling threads "
"that attempt to over-run their specified Runtime."
msgstr ""

#. type: Plain text
#: man-pages/man7/sched.7:319
msgid ""
"To ensure deadline scheduling guarantees, the kernel must prevent situations"
" where the set of B<SCHED_DEADLINE> threads is not feasible (schedulable) "
"within the given constraints.  The kernel thus performs an admittance test "
"when setting or changing B<SCHED_DEADLINE> policy and attributes.  This "
"admission test calculates whether the change is feasible; if it is not "
"B<sched_setattr>(2)  fails with the error B<EBUSY>."
msgstr ""

#. type: Plain text
#: man-pages/man7/sched.7:325
msgid ""
"For example, it is required (but not necessarily sufficient) for the total "
"utilization to be less than or equal to the total number of CPUs available, "
"where, since each thread can maximally run for Runtime per Period, that "
"thread's utilization is its Runtime divided by its Period."
msgstr ""

#. type: Plain text
#: man-pages/man7/sched.7:336
msgid ""
"In order to fulfil the guarantees that are made when a thread is admitted to"
" the B<SCHED_DEADLINE> policy, B<SCHED_DEADLINE> threads are the highest "
"priority (user controllable) threads in the system; if any B<SCHED_DEADLINE>"
" thread is runnable, it will preempt any thread scheduled under one of the "
"other policies."
msgstr ""

#. type: Plain text
#: man-pages/man7/sched.7:344
msgid ""
"A call to B<fork>(2)  by a thread scheduled under the B<SCHED_DEADLINE> "
"policy will fail with the error B<EAGAIN>, unless the thread has its reset-"
"on-fork flag set (see below)."
msgstr ""

#.  FIXME Calling sched_getparam() on a SCHED_DEADLINE thread
#.        fails with EINVAL, but sched_getscheduler() succeeds.
#.        Is that intended? (Why?)
#. type: Plain text
#: man-pages/man7/sched.7:356
msgid ""
"A B<SCHED_DEADLINE> thread that calls B<sched_yield>(2)  will yield the "
"current job and wait for a new period to begin."
msgstr ""

#. type: SS
#: man-pages/man7/sched.7:356
#, no-wrap
msgid "SCHED_OTHER: Default Linux time-sharing scheduling"
msgstr "SCHED_OTHER: планирование с разделение времени (по умолчанию в Linux)"

#. type: Plain text
#: man-pages/man7/sched.7:373
msgid ""
"B<SCHED_OTHER> can be used at only static priority 0.  B<SCHED_OTHER> is the"
" standard Linux time-sharing scheduler that is intended for all threads that"
" do not require the special real-time mechanisms.  The thread to run is "
"chosen from the static priority 0 list based on a I<dynamic> priority that "
"is determined only inside this list.  The dynamic priority is based on the "
"nice value (set by B<nice>(2), B<setpriority>(2), or B<sched_setattr>(2))  "
"and increased for each time quantum the thread is ready to run, but denied "
"to run by the scheduler.  This ensures fair progress among all "
"B<SCHED_OTHER> threads."
msgstr ""

#. type: SS
#: man-pages/man7/sched.7:373
#, no-wrap
msgid "SCHED_BATCH: Scheduling batch processes"
msgstr "SCHED_BATCH: планирование для пакетных процессов"

#. type: Plain text
#: man-pages/man7/sched.7:385
msgid ""
"(Since Linux 2.6.16.)  B<SCHED_BATCH> can be used only at static priority 0."
"  This policy is similar to B<SCHED_OTHER> in that it schedules the thread "
"according to its dynamic priority (based on the nice value).  The difference"
" is that this policy will cause the scheduler to always assume that the "
"thread is CPU-intensive.  Consequently, the scheduler will apply a small "
"scheduling penalty with respect to wakeup behavior, so that this thread is "
"mildly disfavored in scheduling decisions."
msgstr ""

#.  The following paragraph is drawn largely from the text that
#.  accompanied Ingo Molnar's patch for the implementation of
#.  SCHED_BATCH.
#.  commit b0a9499c3dd50d333e2aedb7e894873c58da3785
#. type: Plain text
#: man-pages/man7/sched.7:395
msgid ""
"This policy is useful for workloads that are noninteractive, but do not want"
" to lower their nice value, and for workloads that want a deterministic "
"scheduling policy without interactivity causing extra preemptions (between "
"the workload's tasks)."
msgstr "Этот алгоритм полезен при нагрузках неинтерактивными задачами, но когда нежелательно понижать их значение nice и для задач, которым требуется предсказуемый алгоритм планирования без интерактивности, который приводит к дополнительным вытеснениям (между задачами нагрузки)."

#. type: SS
#: man-pages/man7/sched.7:395
#, no-wrap
msgid "SCHED_IDLE: Scheduling very low priority jobs"
msgstr "SCHED_IDLE: планирование заданий с очень низким приоритетом"

#. type: Plain text
#: man-pages/man7/sched.7:399
msgid ""
"(Since Linux 2.6.23.)  B<SCHED_IDLE> can be used only at static priority 0; "
"the process nice value has no influence for this policy."
msgstr "(начиная с Linux 2.6.23)  B<SCHED_IDLE> можно использовать только с статическим приоритетом равным нулю; значение nice не учитывает в этом алгоритме."

#. type: Plain text
#: man-pages/man7/sched.7:407
msgid ""
"This policy is intended for running jobs at extremely low priority (lower "
"even than a +19 nice value with the B<SCHED_OTHER> or B<SCHED_BATCH> "
"policies)."
msgstr "Данный алгоритм предназначен для выполнения заданий с чрезвычайно низким приоритетом (даже ниже чем значение nice +19 в алгоритме B<SCHED_OTHER> или B<SCHED_BATCH>)."

#. type: SS
#: man-pages/man7/sched.7:407
#, no-wrap
msgid "Resetting scheduling policy for child processes"
msgstr "Сброс алгоритма планирования у дочерних процессов"

#. type: Plain text
#: man-pages/man7/sched.7:413
msgid ""
"Each thread has a reset-on-fork scheduling flag.  When this flag is set, "
"children created by B<fork>(2)  do not inherit privileged scheduling "
"policies.  The reset-on-fork flag can be set by either:"
msgstr ""

#. type: Plain text
#: man-pages/man7/sched.7:422
msgid ""
"ORing the B<SCHED_RESET_ON_FORK> flag into the I<policy> argument when "
"calling B<sched_setscheduler>(2)  (since Linux 2.6.32); or"
msgstr ""

#. type: Plain text
#: man-pages/man7/sched.7:429
msgid ""
"specifying the B<SCHED_FLAG_RESET_ON_FORK> flag in I<attr.sched_flags> when "
"calling B<sched_setattr>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man7/sched.7:435
msgid ""
"Note that the constants used with these two APIs have different names.  The "
"state of the reset-on-fork flag can analogously be retrieved using "
"B<sched_getscheduler>(2)  and B<sched_getattr>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man7/sched.7:442
msgid ""
"The reset-on-fork feature is intended for media-playback applications, and "
"can be used to prevent applications evading the B<RLIMIT_RTTIME> resource "
"limit (see B<getrlimit>(2))  by creating multiple child processes."
msgstr ""

#. type: Plain text
#: man-pages/man7/sched.7:445
msgid ""
"More precisely, if the reset-on-fork flag is set, the following rules apply "
"for subsequently created children:"
msgstr ""

#. type: Plain text
#: man-pages/man7/sched.7:453
msgid ""
"If the calling thread has a scheduling policy of B<SCHED_FIFO> or "
"B<SCHED_RR>, the policy is reset to B<SCHED_OTHER> in child processes."
msgstr "Если вызывающая нить имеет алгоритм планирования B<SCHED_FIFO> или B<SCHED_RR>, то у потомков алгоритм сбрасывается в B<SCHED_OTHER>."

#. type: Plain text
#: man-pages/man7/sched.7:456
msgid ""
"If the calling process has a negative nice value, the nice value is reset to"
" zero in child processes."
msgstr "Если у вызывающего процесса значение nice отрицательно, то у потомков значение nice сбрасывается в ноль."

#. type: Plain text
#: man-pages/man7/sched.7:464
msgid ""
"After the reset-on-fork flag has been enabled, it can be reset only if the "
"thread has the B<CAP_SYS_NICE> capability.  This flag is disabled in child "
"processes created by B<fork>(2)."
msgstr ""

#. type: SS
#: man-pages/man7/sched.7:464
#, no-wrap
msgid "Privileges and resource limits"
msgstr "Привилегии и ограничения по ресурсам"

#. type: Plain text
#: man-pages/man7/sched.7:476
msgid ""
"In Linux kernels before 2.6.12, only privileged (B<CAP_SYS_NICE>)  threads "
"can set a nonzero static priority (i.e., set a real-time scheduling policy)."
"  The only change that an unprivileged thread can make is to set the "
"B<SCHED_OTHER> policy, and this can be done only if the effective user ID of"
" the caller matches the real or effective user ID of the target thread "
"(i.e., the thread specified by I<pid>)  whose policy is being changed."
msgstr ""

#. type: Plain text
#: man-pages/man7/sched.7:482
msgid ""
"A thread must be privileged (B<CAP_SYS_NICE>)  in order to set or modify a "
"B<SCHED_DEADLINE> policy."
msgstr ""

#. type: Plain text
#: man-pages/man7/sched.7:492
msgid ""
"Since Linux 2.6.12, the B<RLIMIT_RTPRIO> resource limit defines a ceiling on"
" an unprivileged thread's static priority for the B<SCHED_RR> and "
"B<SCHED_FIFO> policies.  The rules for changing scheduling policy and "
"priority are as follows:"
msgstr "Начиная с Linux 2.6.12, ограничитель ресурса B<RLIMIT_RTPRIO> определяет максимум статического приоритета непривилегированной нити для алгоритмов B<SCHED_RR> и B<SCHED_FIFO>. Правила для изменения алгоритма планирования и приоритета:"

#. type: Plain text
#: man-pages/man7/sched.7:500
msgid ""
"If an unprivileged thread has a nonzero B<RLIMIT_RTPRIO> soft limit, then it"
" can change its scheduling policy and priority, subject to the restriction "
"that the priority cannot be set to a value higher than the maximum of its "
"current priority and its B<RLIMIT_RTPRIO> soft limit."
msgstr "Если непривилегированная нить имеет ненулевое значение мягкого ограничения B<RLIMIT_RTPRIO>, то она может изменять свой алгоритм планирования и приоритет, но при этом значение приоритета не может быть больше чем максимальное значение её текущего приоритета и его мягкого ограничения B<RLIMIT_RTPRIO>."

#. type: Plain text
#: man-pages/man7/sched.7:505
msgid ""
"If the B<RLIMIT_RTPRIO> soft limit is 0, then the only permitted changes are"
" to lower the priority, or to switch to a non-real-time policy."
msgstr "Если мягкое ограничение B<RLIMIT_RTPRIO> равно 0, то разрешается только снижать приоритет или переключиться на алгоритм выполнения не реального времени."

#. type: Plain text
#: man-pages/man7/sched.7:510
msgid ""
"Subject to the same rules, another unprivileged thread can also make these "
"changes, as long as the effective user ID of the thread making the change "
"matches the real or effective user ID of the target thread."
msgstr "Согласно тем же самым правилам другая непривилегированная нить может также сделать эти изменения, пока эффективный идентификатор пользователя нити, производящей изменение, совпадает с реальным или эффективным идентификатором пользователя изменяемой нити."

#.  commit c02aa73b1d18e43cfd79c2f193b225e84ca497c8
#. type: Plain text
#: man-pages/man7/sched.7:529
msgid ""
"Special rules apply for the B<SCHED_IDLE> policy.  In Linux kernels before "
"2.6.39, an unprivileged thread operating under this policy cannot change its"
" policy, regardless of the value of its B<RLIMIT_RTPRIO> resource limit.  In"
" Linux kernels since 2.6.39, an unprivileged thread can switch to either the"
" B<SCHED_BATCH> or the B<SCHED_NORMAL> policy so long as its nice value "
"falls within the range permitted by its B<RLIMIT_NICE> resource limit (see "
"B<getrlimit>(2))."
msgstr ""

#. type: Plain text
#: man-pages/man7/sched.7:540
msgid ""
"Privileged (B<CAP_SYS_NICE>)  threads ignore the B<RLIMIT_RTPRIO> limit; as "
"with older kernels, they can make arbitrary changes to scheduling policy and"
" priority.  See B<getrlimit>(2)  for further information on "
"B<RLIMIT_RTPRIO>."
msgstr "Для привилегированных (B<CAP_SYS_NICE>) нитей ограничение B<RLIMIT_RTPRIO> игнорируется; как в старых ядрах, они могут произвольно менять алгоритм планирования и приоритет. Подробней смотрите в B<getrlimit>(2) про B<RLIMIT_RTPRIO>."

#. type: SS
#: man-pages/man7/sched.7:540
#, no-wrap
msgid "Limiting the CPU usage of real-time and deadline processes"
msgstr ""

#. type: Plain text
#: man-pages/man7/sched.7:553
msgid ""
"A nonblocking infinite loop in a thread scheduled under the B<SCHED_FIFO>, "
"B<SCHED_RR>, or B<SCHED_DEADLINE> policy will block all threads with lower "
"priority forever.  Prior to Linux 2.6.25, the only way of preventing a "
"runaway real-time process from freezing the system was to run (at the "
"console)  a shell scheduled under a higher static priority than the tested "
"application.  This allows an emergency kill of tested real-time applications"
" that do not block or terminate as expected."
msgstr ""

#. type: Plain text
#: man-pages/man7/sched.7:563
msgid ""
"Since Linux 2.6.25, there are other techniques for dealing with runaway "
"real-time and deadline processes.  One of these is to use the "
"B<RLIMIT_RTTIME> resource limit to set a ceiling on the CPU time that a "
"real-time process may consume.  See B<getrlimit>(2)  for details."
msgstr ""

#. type: Plain text
#: man-pages/man7/sched.7:571
msgid ""
"Since version 2.6.25, Linux also provides two I</proc> files that can be "
"used to reserve a certain amount of CPU time to be used by non-real-time "
"processes.  Reserving some CPU time in this fashion allows some CPU time to "
"be allocated to (say) a root shell that can be used to kill a runaway "
"process.  Both of these files specify time values in microseconds:"
msgstr ""

#. type: TP
#: man-pages/man7/sched.7:571
#, no-wrap
msgid "I</proc/sys/kernel/sched_rt_period_us>"
msgstr ""

#. type: Plain text
#: man-pages/man7/sched.7:579
msgid ""
"This file specifies a scheduling period that is equivalent to 100% CPU "
"bandwidth.  The value in this file can range from 1 to B<INT_MAX>, giving an"
" operating range of 1 microsecond to around 35 minutes.  The default value "
"in this file is 1,000,000 (1 second)."
msgstr ""

#. type: TP
#: man-pages/man7/sched.7:579
#, no-wrap
msgid "I</proc/sys/kernel/sched_rt_runtime_us>"
msgstr ""

#. type: Plain text
#: man-pages/man7/sched.7:592
msgid ""
"The value in this file specifies how much of the \"period\" time can be used"
" by all real-time and deadline scheduled processes on the system.  The value"
" in this file can range from -1 to B<INT_MAX>-1.  Specifying -1 makes the "
"runtime the same as the period; that is, no CPU time is set aside for non-"
"real-time processes (which was the Linux behavior before kernel 2.6.25).  "
"The default value in this file is 950,000 (0.95 seconds), meaning that 5% of"
" the CPU time is reserved for processes that don't run under a real-time or "
"deadline scheduling policy."
msgstr ""

#. type: SS
#: man-pages/man7/sched.7:593
#, no-wrap
msgid "Response time"
msgstr "Время ответа"

#.  as described in
#.  .BR request_irq (9).
#. type: Plain text
#: man-pages/man7/sched.7:601
msgid ""
"A blocked high priority thread waiting for I/O has a certain response time "
"before it is scheduled again.  The device driver writer can greatly reduce "
"this response time by using a \"slow interrupt\" interrupt handler."
msgstr ""

#. type: SS
#: man-pages/man7/sched.7:601
#, no-wrap
msgid "Miscellaneous"
msgstr "Разное"

#. type: Plain text
#: man-pages/man7/sched.7:606
msgid ""
"Child processes inherit the scheduling policy and parameters across a "
"B<fork>(2).  The scheduling policy and parameters are preserved across "
"B<execve>(2)."
msgstr "Дочерние процессы наследуют алгоритм планирования и его параметры после B<fork>(2). Алгоритм планирования и параметры сохраняются при вызове B<execve>(2)."

#. type: Plain text
#: man-pages/man7/sched.7:612
msgid ""
"Memory locking is usually needed for real-time processes to avoid paging "
"delays; this can be done with B<mlock>(2)  or B<mlockall>(2)."
msgstr "Обычно, процессам реального времени необходимо блокировать память для того, чтобы избежать задержек при страничном обмене. Это можно сделать при помощи вызова B<mlock>(2) или B<mlockall>(2)."

#. type: Plain text
#: man-pages/man7/sched.7:623
msgid ""
"Originally, Standard Linux was intended as a general-purpose operating "
"system being able to handle background processes, interactive applications, "
"and less demanding real-time applications (applications that need to usually"
" meet timing deadlines).  Although the Linux kernel 2.6 allowed for kernel "
"preemption and the newly introduced O(1) scheduler ensures that the time "
"needed to schedule is fixed and deterministic irrespective of the number of "
"active tasks, true real-time computing was not possible up to kernel version"
" 2.6.17."
msgstr "Изначально стандартный Linux представлял собой операционную систему общего назначения для выполнения как фоновых процессов, так и интерактивных приложений, а также нетребовательных приложений реального времени (приложений, которым желательно, чтобы задержки и интервалы времени выдерживались). Хотя ядро Linux 2.6 позволяет вытеснение и новый планировщик O(1) обеспечивает необходимое постоянство планирования и предсказуемое независимое количество активных задач, настоящая работа в реальном времени стала доступна начиная с версии ядра 2.6.17."

#. type: SS
#: man-pages/man7/sched.7:623
#, no-wrap
msgid "Real-time features in the mainline Linux kernel"
msgstr "Возможности выполнения в реальном времени из оригинальной версии Linux"

#.  FIXME . Probably this text will need some minor tweaking
#.  by about the time of 2.6.30; ask Carsten Emde about this then.
#. type: Plain text
#: man-pages/man7/sched.7:637
msgid ""
"From kernel version 2.6.18 onward, however, Linux is gradually becoming "
"equipped with real-time capabilities, most of which are derived from the "
"former I<realtime-preempt> patches developed by Ingo Molnar, Thomas "
"Gleixner, Steven Rostedt, and others.  Until the patches have been "
"completely merged into the mainline kernel (this is expected to be around "
"kernel version 2.6.30), they must be installed to achieve the best real-time"
" performance.  These patches are named:"
msgstr "Начиная с версии 2.6.18 Linux постепенно обрастает возможностями выполнения в реальном времени, большая часть которых взята из ранних заплаток I<realtime-preempt>, разработанных Ingo Molnar, Thomas Gleixner, Steven Rostedt и другими. Пока заплатки полностью не вошли в оригинальное ядро (ожидается к версии 2.6.30), они должны быть установлены отдельно. Файлы заплаток называются"

#. type: Plain text
#: man-pages/man7/sched.7:641
#, no-wrap
msgid "patch-I<kernelversion>-rtI<patchversion>\n"
msgstr "patch-I<версия_ядра>-rtI<версия_заплатки>\n"

#. type: Plain text
#: man-pages/man7/sched.7:647
msgid ""
"and can be downloaded from E<.UR "
"http://www.kernel.org\\:/pub\\:/linux\\:/kernel\\:/projects\\:/rt/> E<.UE .>"
msgstr ""

#. type: Plain text
#: man-pages/man7/sched.7:656
msgid ""
"Without the patches and prior to their full inclusion into the mainline "
"kernel, the kernel configuration offers only the three preemption classes "
"B<CONFIG_PREEMPT_NONE>, B<CONFIG_PREEMPT_VOLUNTARY>, and "
"B<CONFIG_PREEMPT_DESKTOP> which respectively provide no, some, and "
"considerable reduction of the worst-case scheduling latency."
msgstr "Без заплаток и до их полного включения в оригинальное ядро, через параметры ядра предлагается только три класса вытеснения: B<CONFIG_PREEMPT_NONE>, B<CONFIG_PREEMPT_VOLUNTARY> и B<CONFIG_PREEMPT_DESKTOP>, которые, соответственно, не сокращают, частично сокращают и значительно сокращают задержку планирования при наихудшем случае."

#. type: Plain text
#: man-pages/man7/sched.7:665
msgid ""
"With the patches applied or after their full inclusion into the mainline "
"kernel, the additional configuration item B<CONFIG_PREEMPT_RT> becomes "
"available.  If this is selected, Linux is transformed into a regular real-"
"time operating system.  The FIFO and RR scheduling policies are then used to"
" run a thread with true real-time priority and a minimum worst-case "
"scheduling latency."
msgstr ""

#. type: Plain text
#: man-pages/man7/sched.7:691
msgid ""
"B<chrt>(1), B<getpriority>(2), B<mlock>(2), B<mlockall>(2), B<munlock>(2), "
"B<munlockall>(2), B<nice>(2), B<sched_get_priority_max>(2), "
"B<sched_get_priority_min>(2), B<sched_getscheduler>(2), "
"B<sched_getaffinity>(2), B<sched_getparam>(2), B<sched_rr_get_interval>(2), "
"B<sched_setaffinity>(2), B<sched_setscheduler>(2), B<sched_setparam>(2), "
"B<sched_yield>(2), B<setpriority>(2), B<pthread_getaffinity_np>(3), "
"B<pthread_setaffinity_np>(3), B<sched_getcpu>(3), B<capabilities>(7), "
"B<cpuset>(7)"
msgstr ""

#. type: Plain text
#: man-pages/man7/sched.7:695
msgid ""
"I<Programming for the real world - POSIX.4> by Bill O. Gallmeister, O'Reilly"
" & Associates, Inc., ISBN 1-56592-074-0."
msgstr "I<Programming for the real world - POSIX.4> by Bill O. Gallmeister, O'Reilly & Associates, Inc., ISBN 1-56592-074-0."

#. type: Plain text
#: man-pages/man7/sched.7:701
msgid ""
"The Linux kernel source files I<Documentation/scheduler/sched-deadline.txt>,"
" I<Documentation/scheduler/sched-rt-group.txt>, I<Documentation/scheduler"
"/sched-design-CFS.txt>, and I<Documentation/scheduler/sched-nice-design.txt>"
msgstr ""

#. type: TH
#: man-pages/man7/socket.7:56
#, no-wrap
msgid "SOCKET"
msgstr "SOCKET"

#. type: Plain text
#: man-pages/man7/socket.7:59
msgid "socket - Linux socket interface"
msgstr "socket - интерфейс сокетов Linux"

#. type: Plain text
#: man-pages/man7/socket.7:61
msgid "B<#include E<lt>sys/socket.hE<gt>>"
msgstr "B<#include E<lt>sys/socket.hE<gt>>"

#. type: Plain text
#: man-pages/man7/socket.7:63
msgid ""
"I<sockfd>B< = socket(int >I<socket_family>B<, int >I<socket_type>B<, int "
">I<protocol>B<);>"
msgstr "I<sockfd>B< = socket(int >I<socket_family>B<, int >I<socket_type>B<, int >I<protocol>B<);>"

#. type: Plain text
#: man-pages/man7/socket.7:82
msgid ""
"This manual page describes the Linux networking socket layer user interface."
"  The BSD compatible sockets are the uniform interface between the user "
"process and the network protocol stacks in the kernel.  The protocol modules"
" are grouped into I<protocol families> such as B<AF_INET>, B<AF_IPX>, and "
"B<AF_PACKET>, and I<socket types> such as B<SOCK_STREAM> or B<SOCK_DGRAM>.  "
"See B<socket>(2)  for more information on families and types."
msgstr "В этой справочной странице описывается пользовательский интерфейс уровня сетевых сокетов Linux. Совместимый с сокетами BSD, он предоставляет унифицированный интерфейс между пользовательскими процессами и стеком сетевых протоколов в ядре. Модули протоколов группируются по I<семействам протоколов>, такими, как B<AF_INET>, B<AF_IPX> и B<AF_PACKET>, и I<типам сокетов>, такими, как B<SOCK_STREAM> или B<SOCK_DGRAM>. Более подробная информация о семействах и типах приведена в B<socket>(2)."

#. type: SS
#: man-pages/man7/socket.7:82
#, no-wrap
msgid "Socket-layer functions"
msgstr "Функции уровня сокетов"

#. type: Plain text
#: man-pages/man7/socket.7:86
msgid ""
"These functions are used by the user process to send or receive packets and "
"to do other socket operations.  For more information see their respective "
"manual pages."
msgstr "Эти функции используются пользовательскими процессами для отправки или приёма пакетов и выполнения других операций над сокетами. Более подробная информация приведена в соответствующих справочных страницах."

#. type: Plain text
#: man-pages/man7/socket.7:102
msgid ""
"B<socket>(2)  creates a socket, B<connect>(2)  connects a socket to a remote"
" socket address, the B<bind>(2)  function binds a socket to a local socket "
"address, B<listen>(2)  tells the socket that new connections shall be "
"accepted, and B<accept>(2)  is used to get a new socket with a new incoming "
"connection.  B<socketpair>(2)  returns two connected anonymous sockets "
"(implemented only for a few local families like B<AF_UNIX>)"
msgstr "Вызов B<socket>(2) создаёт сокет, B<connect>(2) соединяет сокет с удалённым сокетным адресом, B<bind>(2) привязывает сокет к локальному адресу, B<listen>(2) сообщает сокету, что должны приниматься новые соединения, а B<accept>(2) используется для получения нового сокета для нового входящего соединения. Вызов B<socketpair>(2) возвращает два соединённых анонимных сокета (реализовано только для некоторых локальных семейств, например B<AF_UNIX>)."

#. type: Plain text
#: man-pages/man7/socket.7:124
msgid ""
"B<send>(2), B<sendto>(2), and B<sendmsg>(2)  send data over a socket, and "
"B<recv>(2), B<recvfrom>(2), B<recvmsg>(2)  receive data from a socket.  "
"B<poll>(2)  and B<select>(2)  wait for arriving data or a readiness to send "
"data.  In addition, the standard I/O operations like B<write>(2), "
"B<writev>(2), B<sendfile>(2), B<read>(2), and B<readv>(2)  can be used to "
"read and write data."
msgstr "Вызовы B<send>(2), B<sendto>(2) и B<sendmsg>(2) отправляют данные через сокет, а B<recv>(2), B<recvfrom>(2) и B<recvmsg>(2) принимают данные из сокета. Вызовы B<poll>(2) и B<select>(2) ожидают поступления данных или готовятся к передаче данных. Кроме того, для чтения и записи данных могут использоваться стандартные операции ввода-вывода: B<write>(2), B<writev>(2), B<sendfile>(2), B<read>(2) и B<readv>(2)."

#. type: Plain text
#: man-pages/man7/socket.7:135
msgid ""
"B<getsockname>(2)  returns the local socket address and B<getpeername>(2)  "
"returns the remote socket address.  B<getsockopt>(2)  and B<setsockopt>(2)  "
"are used to set or get socket layer or protocol options.  B<ioctl>(2)  can "
"be used to set or read some other options."
msgstr "Вызов B<getsockname>(2) возвращает адрес локального сокета, а B<getpeername>(2) возвращает адрес удалённого сокета. Вызовы B<getsockopt>(2) и B<setsockopt>(2) используются для установки или считывания параметров протокола или уровня сокетов. Вызов B<ioctl>(2) может быть использован для установки или чтения некоторых других параметров."

#. type: Plain text
#: man-pages/man7/socket.7:140
msgid ""
"B<close>(2)  is used to close a socket.  B<shutdown>(2)  closes parts of a "
"full-duplex socket connection."
msgstr "Вызов B<close>(2) используется для закрытия сокета. Вызов B<shutdown>(2) закрывает части полнодуплексного сокетного соединения."

#. type: Plain text
#: man-pages/man7/socket.7:146
msgid ""
"Seeking, or calling B<pread>(2)  or B<pwrite>(2)  with a nonzero position is"
" not supported on sockets."
msgstr "Перемещение (seeking), или вызовы B<pread>(2) и B<pwrite>(2) с ненулевой позицией, для сокетов не поддерживается."

#. type: Plain text
#: man-pages/man7/socket.7:163
msgid ""
"It is possible to do nonblocking I/O on sockets by setting the B<O_NONBLOCK>"
" flag on a socket file descriptor using B<fcntl>(2).  Then all operations "
"that would block will (usually)  return with B<EAGAIN> (operation should be "
"retried later); B<connect>(2)  will return B<EINPROGRESS> error.  The user "
"can then wait for various events via B<poll>(2)  or B<select>(2)."
msgstr "Для сокетов возможно создание неблокирующего ввода/вывода путём установки в файловый дескриптор сокета флага B<O_NONBLOCK> с помощью вызова B<fcntl>(2). При этом все блокировавшие раньше операции, будут возвращать B<EAGAIN> (операция должна быть повторена позднее); B<connect>(2) возвратит ошибку B<EINPROGRESS>. Пользователь может подождать наступления различных событий через B<poll>(2) или B<select>(2)."

#. type: tbl table
#: man-pages/man7/socket.7:167
#, no-wrap
msgid "I/O events\n"
msgstr "События ввода-вывода\n"

#. type: tbl table
#: man-pages/man7/socket.7:168
#, no-wrap
msgid "Event:Poll flag:Occurrence\n"
msgstr "Событие:Флаг poll:Когда происходит\n"

#. type: tbl table
#: man-pages/man7/socket.7:169 man-pages/man7/socket.7:172
#, no-wrap
msgid "Read:POLLIN:T{\n"
msgstr "Чтение:POLLIN:T{\n"

#. type: tbl table
#: man-pages/man7/socket.7:170
#, no-wrap
msgid "New data arrived.\n"
msgstr "Поступили новые данные\n"

#. type: tbl table
#: man-pages/man7/socket.7:171 man-pages/man7/socket.7:175
#: man-pages/man7/socket.7:178 man-pages/man7/socket.7:184
#: man-pages/man7/socket.7:187 man-pages/man7/socket.7:196
#: man-pages/man7/socket.7:203
#, no-wrap
msgid "T}\n"
msgstr "T}\n"

#. type: tbl table
#: man-pages/man7/socket.7:173
#, no-wrap
msgid "A connection setup has been completed\n"
msgstr "Установка соединения выполнена\n"

#. type: tbl table
#: man-pages/man7/socket.7:174
#, no-wrap
msgid "(for connection-oriented sockets)\n"
msgstr "(для сокетов, ориентированных на соединение)\n"

#. type: tbl table
#: man-pages/man7/socket.7:176 man-pages/man7/socket.7:179
#, no-wrap
msgid "Read:POLLHUP:T{\n"
msgstr "Чтение:POLLHUP:T{\n"

#. type: tbl table
#: man-pages/man7/socket.7:177
#, no-wrap
msgid "A disconnection request has been initiated by the other end.\n"
msgstr "Другая сторона инициировала запрос на разъединение\n"

#. type: tbl table
#: man-pages/man7/socket.7:180
#, no-wrap
msgid "A connection is broken (only for connection-oriented protocols).\n"
msgstr "Соединение разорвано (только для протоколов, ориентированных на соединение).\n"

#. type: tbl table
#: man-pages/man7/socket.7:181
#, no-wrap
msgid "When the socket is written\n"
msgstr "Если производится запись в сокет, то также посылается сигнал\n"

#. type: tbl table
#: man-pages/man7/socket.7:182
#, no-wrap
msgid "B<SIGPIPE>\n"
msgstr "B<SIGPIPE>\n"

#. type: tbl table
#: man-pages/man7/socket.7:183
#, no-wrap
msgid "is also sent.\n"
msgstr ".\n"

#. type: tbl table
#: man-pages/man7/socket.7:185
#, no-wrap
msgid "Write:POLLOUT:T{\n"
msgstr "Запись:POLLOUT:T{\n"

#. type: tbl table
#: man-pages/man7/socket.7:186
#, no-wrap
msgid "Socket has enough send buffer space for writing new data.\n"
msgstr "Сокет имеет достаточно места в буфере отправки для записи в него новых данных\n"

#. type: tbl table
#: man-pages/man7/socket.7:188
#, no-wrap
msgid "Read/Write:T{\n"
msgstr "Чтение/Запись:T{\n"

#. type: tbl table
#: man-pages/man7/socket.7:189
#, no-wrap
msgid "POLLIN|\n"
msgstr "POLLIN|\n"

#. type: tbl table
#: man-pages/man7/socket.7:190
#, no-wrap
msgid ".br\n"
msgstr ".br\n"

#. type: tbl table
#: man-pages/man7/socket.7:191
#, no-wrap
msgid "POLLOUT\n"
msgstr "POLLOUT\n"

#. type: tbl table
#: man-pages/man7/socket.7:192
#, no-wrap
msgid "T}:T{\n"
msgstr "T}:T{\n"

#. type: tbl table
#: man-pages/man7/socket.7:193
#, no-wrap
msgid "An outgoing\n"
msgstr "Исходящий вызов\n"

#. type: tbl table
#: man-pages/man7/socket.7:194
#, no-wrap
msgid "B<connect>(2)\n"
msgstr "B<connect>(2)\n"

#. type: tbl table
#: man-pages/man7/socket.7:195
#, no-wrap
msgid "finished.\n"
msgstr "завершён\n"

#. type: tbl table
#: man-pages/man7/socket.7:197
#, no-wrap
msgid "Read/Write:POLLERR:An asynchronous error occurred.\n"
msgstr "Чтение/Запись:POLLERR:Произошла асинхронная ошибка\n"

#. type: tbl table
#: man-pages/man7/socket.7:198
#, no-wrap
msgid "Read/Write:POLLHUP:The other end has shut down one direction.\n"
msgstr "Чтение/Запись:POLLHUP:Другая сторона закрыла (shut down) одно направление\n"

#. type: tbl table
#: man-pages/man7/socket.7:199
#, no-wrap
msgid "Exception:POLLPRI:T{\n"
msgstr "Исключение:POLLPRI:T{\n"

#. type: tbl table
#: man-pages/man7/socket.7:200
#, no-wrap
msgid "Urgent data arrived.\n"
msgstr "Пришли неотложные данные. При этом посылается сигнал\n"

#. type: tbl table
#: man-pages/man7/socket.7:201
#, no-wrap
msgid "B<SIGURG>\n"
msgstr "B<SIGURG>\n"

#. type: tbl table
#: man-pages/man7/socket.7:202
#, no-wrap
msgid "is sent then.\n"
msgstr ".\n"

#. type: Plain text
#: man-pages/man7/socket.7:231
msgid ""
"An alternative to B<poll>(2)  and B<select>(2)  is to let the kernel inform "
"the application about events via a B<SIGIO> signal.  For that the B<O_ASYNC>"
" flag must be set on a socket file descriptor via B<fcntl>(2)  and a valid "
"signal handler for B<SIGIO> must be installed via B<sigaction>(2).  See the "
"I<Signals> discussion below."
msgstr "Альтернативе B<poll>(2) и B<select>(2) в ядре существует возможность информировать приложение о событиях с помощью сигнала B<SIGIO>. Для этого необходимо установить с помощью B<fcntl>(2) в файловом дескрипторе сокета флаг B<O_ASYNC>, а также назначить с помощью B<sigaction>(2) корректный обработчик сигнала B<SIGIO>. Смотрите ниже раздел I<Сигналы>."

#. type: SS
#: man-pages/man7/socket.7:231
#, no-wrap
msgid "Socket address structures"
msgstr "Структуры адреса сокета"

#. type: Plain text
#: man-pages/man7/socket.7:247
msgid ""
"Each socket domain has its own format for socket addresses, with a domain-"
"specific address structure.  Each of these structures begins with an integer"
" \"family\" field (typed as I<sa_family_t>)  that indicates the type of the "
"address structure.  This allows the various system calls (e.g., "
"B<connect>(2), B<bind>(2), B<accept>(2), B<getsockname>(2), "
"B<getpeername>(2)), which are generic to all socket domains, to determine "
"the domain of a particular socket address."
msgstr "Каждый сокетный домен имеет свой формат для сокетных адресов, выраженный в отдельной адресной структуре. Каждая из этих структур начинается с целочисленного поля «семейства» (с именем I<sa_family_t>), в котором указывается тип адресной структуры. Это позволяет различным системным вызовам (например, B<connect>(2), B<bind>(2), B<accept>(2), B<getsockname>(2), B<getpeername>(2)), которые являются общими для всех сокетов, определить домен конкретного сокетного адреса."

#. type: Plain text
#: man-pages/man7/socket.7:257
msgid ""
"To allow any type of socket address to be passed to interfaces in the "
"sockets API, the type I<struct sockaddr> is defined.  The purpose of this "
"type is purely to allow casting of domain-specific socket address types to a"
" \"generic\" type, so as to avoid compiler warnings about type mismatches in"
" calls to the sockets API."
msgstr "Для передачи сокетного адреса любого типа через программный интерфейс сокетов служит тип I<struct sockaddr>. Целью данного типа является приведение типов сокетных адресов определённого домена к «общему» типу, что позволяет избежать предупреждений компилятора о несовпадении типов в вызовах API сокетов."

#. type: Plain text
#: man-pages/man7/socket.7:267
msgid ""
"In addition, the sockets API provides the data type I<struct "
"sockaddr_storage>.  This type is suitable to accommodate all supported "
"domain-specific socket address structures; it is large enough and is aligned"
" properly.  (In particular, it is large enough to hold IPv6 socket "
"addresses.)  The structure includes the following field, which can be used "
"to identify the type of socket address actually stored in the structure:"
msgstr "Также, программный интерфейс сокетов предоставляет тип данных I<struct sockaddr_storage>. Данный тип удобен для размещения всех поддерживаемых структур сокетных адресов определённого домена; он достаточно большой и имеет корректное выравнивание (в частности, он позволяет хранить сокетные адреса IPv6). Для определения типа сокетного адреса, который хранится в структуре, служит следующее поле:"

#. type: Plain text
#: man-pages/man7/socket.7:271
#, no-wrap
msgid "    sa_family_t ss_family;\n"
msgstr "    sa_family_t ss_family;\n"

#. type: Plain text
#: man-pages/man7/socket.7:279
msgid ""
"The I<sockaddr_storage> structure is useful in programs that must handle "
"socket addresses in a generic way (e.g., programs that must deal with both "
"IPv4 and IPv6 socket addresses)."
msgstr "Структура I<sockaddr_storage> полезна для программ, которые должны работать с сокетными адресами единообразно (например, в программах, использующих одновременно сокетные адреса IPv4 и IPv6)."

#. type: SS
#: man-pages/man7/socket.7:279
#, no-wrap
msgid "Socket options"
msgstr "Параметры сокетов"

#.  FIXME
#.  In the list below, the text used to describe argument types
#.  for each socket option should be more consistent
#.  SO_ACCEPTCONN is in POSIX.1-2001, and its origin is explained in
#.  W R Stevens, UNPv1
#. type: Plain text
#: man-pages/man7/socket.7:297
msgid ""
"The socket options listed below can be set by using B<setsockopt>(2)  and "
"read with B<getsockopt>(2)  with the socket level set to B<SOL_SOCKET> for "
"all sockets.  Unless otherwise noted, I<optval> is a pointer to an I<int>."
msgstr "Следующие параметры сокета могут быть установлены с помощью B<setsockopt>(2) или считаны с помощью B<getsockopt>(2) с уровнем сокета, равным B<SOL_SOCKET> для всех сокетов:"

#. type: TP
#: man-pages/man7/socket.7:297
#, no-wrap
msgid "B<SO_ACCEPTCONN>"
msgstr "B<SO_ACCEPTCONN>"

#. type: Plain text
#: man-pages/man7/socket.7:305
msgid ""
"Returns a value indicating whether or not this socket has been marked to "
"accept connections with B<listen>(2).  The value 0 indicates that this is "
"not a listening socket, the value 1 indicates that this is a listening "
"socket.  This socket option is read-only."
msgstr "Определить, был или не был данный сокет помечен для прослушивания и приёма соединений с помощью B<listen>(2). Возвращаемое значение 0 обозначает, что это не прослушивающий сокет. Значение 1 обозначает, что это прослушивающий сокет. Данный параметр сокета доступен только для чтения."

#. type: TP
#: man-pages/man7/socket.7:305
#, no-wrap
msgid "B<SO_BINDTODEVICE>"
msgstr "B<SO_BINDTODEVICE>"

#. type: Plain text
#: man-pages/man7/socket.7:324
msgid ""
"Bind this socket to a particular device like \\(lqeth0\\(rq, as specified in"
" the passed interface name.  If the name is an empty string or the option "
"length is zero, the socket device binding is removed.  The passed option is "
"a variable-length null-terminated interface name string with the maximum "
"size of B<IFNAMSIZ>.  If a socket is bound to an interface, only packets "
"received from that particular interface are processed by the socket.  Note "
"that this works only for some socket types, particularly B<AF_INET> sockets."
"  It is not supported for packet sockets (use normal B<bind>(2)  there)."
msgstr "Привязать сокет к определённому устройству, например, к \\(lqeth0\\(rq, в соответствии с переданным именем интерфейса. Если имя является пустой строкой или длина параметра равна нулю, то привязка сокета к устройству будет удалена. В качестве параметра передаётся оканчивающаяся null строка переменной длины с именем интерфейса, максимальная длина которой не превышает B<IFNAMSIZ>. Если сокет привязан к интерфейсу, то сокетом обрабатываются только пакеты этого интерфейса. Заметим, что это работает только для некоторых типов сокетов, в частности, для сокетов B<AF_INET>. Это не поддерживается для сокетов пакетной передачи (для них используйте обычный B<bind>(2))."

#. type: Plain text
#: man-pages/man7/socket.7:338
msgid ""
"Before Linux 3.8, this socket option could be set, but could not retrieved "
"with B<getsockopt>(2).  Since Linux 3.8, it is readable.  The I<optlen> "
"argument should contain the buffer size available to receive the device name"
" and is recommended to be B<IFNAMSZ> bytes.  The real device name length is "
"reported back in the I<optlen> argument."
msgstr "До Linux 3.8, данный параметр сокета можно было устанавливать, но нельзя прочитать с помощью B<getsockopt>(2). Начиная с Linux 3.8 он доступен для чтения. Аргумент I<optlen> должен содержать размер буфера, способного разместить имя устройства; рекомендуемое значение — B<IFNAMSZ> байт. Реальная длина имени устройства возвращается обратно через аргумент I<optlen>."

#. type: TP
#: man-pages/man7/socket.7:338
#, no-wrap
msgid "B<SO_BROADCAST>"
msgstr "B<SO_BROADCAST>"

#. type: Plain text
#: man-pages/man7/socket.7:344
msgid ""
"Set or get the broadcast flag.  When enabled, datagram sockets are allowed "
"to send packets to a broadcast address.  This option has no effect on "
"stream-oriented sockets."
msgstr "Задать или считать флаг широковещания. Если он установлен, то через датаграммные сокеты разрешено отправлять пакеты на широковещательный адрес. Этот параметр не действует на потоковые сокеты."

#. type: TP
#: man-pages/man7/socket.7:344
#, no-wrap
msgid "B<SO_BSDCOMPAT>"
msgstr "B<SO_BSDCOMPAT>"

#. type: Plain text
#: man-pages/man7/socket.7:356
msgid ""
"Enable BSD bug-to-bug compatibility.  This is used by the UDP protocol "
"module in Linux 2.0 and 2.2.  If enabled, ICMP errors received for a UDP "
"socket will not be passed to the user program.  In later kernel versions, "
"support for this option has been phased out: Linux 2.4 silently ignores it, "
"and Linux 2.6 generates a kernel warning (printk()) if a program uses this "
"option.  Linux 2.0 also enabled BSD bug-to-bug compatibility options (random"
" header changing, skipping of the broadcast flag) for raw sockets with this "
"option, but that was removed in Linux 2.2."
msgstr "Разрешить совместимость по ошибкам с BSD. Используется модулем протокола UDP в Linux версии 2.0 и 2.2. Если включено, то полученные UDP-сокетом ошибки ICMP не будут передаваться пользовательской программе. В последний версиях ядер поддержка этого параметра удалена: в Linux 2.4 он игнорируется, а в Linux 2.6 при использовании в программе для него генерируется предупреждение ядра (printk()). В Linux 2.0 также включён параметр совместимости по ошибкам с BSD и для неструктурированных сокетов (произвольное изменение заголовка, пропуск флага широковещательной передачи), но в Linux 2.2 это было удалено."

#. type: TP
#: man-pages/man7/socket.7:356
#, no-wrap
msgid "B<SO_DEBUG>"
msgstr "B<SO_DEBUG>"

#. type: Plain text
#: man-pages/man7/socket.7:362
msgid ""
"Enable socket debugging.  Only allowed for processes with the "
"B<CAP_NET_ADMIN> capability or an effective user ID of 0."
msgstr "Включить отладку сокета. Разрешено только процессам с мандатом B<CAP_NET_ADMIN> или имеющим нулевой идентификатор эффективного пользователя."

#. type: TP
#: man-pages/man7/socket.7:362
#, no-wrap
msgid "B<SO_DOMAIN> (since Linux 2.6.32)"
msgstr "B<SO_DOMAIN> (начиная с Linux 2.6.32)"

#. type: Plain text
#: man-pages/man7/socket.7:370
msgid ""
"Retrieves the socket domain as an integer, returning a value such as "
"B<AF_INET6>.  See B<socket>(2)  for details.  This socket option is read-"
"only."
msgstr "Получить доменный сокет в виде целого числа; пример возвращаемого значения: B<AF_INET6>. Подробней смотрите в B<socket>(2). Этот параметр сокета доступен только для чтения."

#. type: TP
#: man-pages/man7/socket.7:370
#, no-wrap
msgid "B<SO_ERROR>"
msgstr "B<SO_ERROR>"

#. type: Plain text
#: man-pages/man7/socket.7:375
msgid ""
"Get and clear the pending socket error.  This socket option is read-only.  "
"Expects an integer."
msgstr "Получить и очистить ожидающую обработки ошибку сокета. Этот параметр сокета доступен только для чтения. Ожидает целое число."

#. type: TP
#: man-pages/man7/socket.7:375
#, no-wrap
msgid "B<SO_DONTROUTE>"
msgstr "B<SO_DONTROUTE>"

#. type: Plain text
#: man-pages/man7/socket.7:384
msgid ""
"Don't send via a gateway, send only to directly connected hosts.  The same "
"effect can be achieved by setting the B<MSG_DONTROUTE> flag on a socket "
"B<send>(2)  operation.  Expects an integer boolean flag."
msgstr "Не выполнять отправку через шлюз, посылать только на машины, соединенные напрямую. Тот же эффект может быть достигнут путём установки для сокета флага B<MSG_DONTROUTE> во время вызова B<send>(2). В качестве параметра ожидается целочисленный логический флаг."

#. type: TP
#: man-pages/man7/socket.7:384
#, no-wrap
msgid "B<SO_KEEPALIVE>"
msgstr "B<SO_KEEPALIVE>"

#. type: Plain text
#: man-pages/man7/socket.7:388
msgid ""
"Enable sending of keep-alive messages on connection-oriented sockets.  "
"Expects an integer boolean flag."
msgstr "Включить отправку «поддерживающих» (keep-alive) сообщений для сокетов, ориентированных на соединение. Ожидается целочисленный логический флаг."

#. type: TP
#: man-pages/man7/socket.7:388
#, no-wrap
msgid "B<SO_LINGER>"
msgstr "B<SO_LINGER>"

#. type: Plain text
#: man-pages/man7/socket.7:396
msgid ""
"Sets or gets the B<SO_LINGER> option.  The argument is a I<linger> "
"structure."
msgstr "Задать или считать параметр B<SO_LINGER>. Аргументом является структура I<linger>."

#. type: Plain text
#: man-pages/man7/socket.7:403
#, no-wrap
msgid ""
"struct linger {\n"
"    int l_onoff;    /* linger active */\n"
"    int l_linger;   /* how many seconds to linger for */\n"
"};\n"
msgstr "struct linger {\n    int l_onoff;    /* задержка активна */\n    int l_linger;   /* величина задержки в секундах */\n};\n"

#. type: Plain text
#: man-pages/man7/socket.7:417
msgid ""
"When enabled, a B<close>(2)  or B<shutdown>(2)  will not return until all "
"queued messages for the socket have been successfully sent or the linger "
"timeout has been reached.  Otherwise, the call returns immediately and the "
"closing is done in the background.  When the socket is closed as part of "
"B<exit>(2), it always lingers in the background."
msgstr "Если этот параметр установлен, то B<close>(2) или B<shutdown>(2) не вернут управление до тех пор, пока не будут отправлены все сообщения в очереди сокета или до истечения времени задержки (linger). В противном случае вызовы вернут управление немедленно и закрытие будет произведено в фоновом режиме. Если сокет закрывается как часть вызова B<exit>(2), то задержка всегда происходит в фоновом режиме."

#. type: TP
#: man-pages/man7/socket.7:417
#, no-wrap
msgid "B<SO_MARK> (since Linux 2.6.25)"
msgstr "B<SO_MARK> (начиная с Linux 2.6.25)"

#.  commit 4a19ec5800fc3bb64e2d87c4d9fdd9e636086fe0
#.  and    914a9ab386a288d0f22252fc268ecbc048cdcbd5
#. type: Plain text
#: man-pages/man7/socket.7:428
msgid ""
"Set the mark for each packet sent through this socket (similar to the "
"netfilter MARK target but socket-based).  Changing the mark can be used for "
"mark-based routing without netfilter or for packet filtering.  Setting this "
"option requires the B<CAP_NET_ADMIN> capability."
msgstr "Устанавливать метку на каждый пакет, отправленный через сокет (похоже на цель netfilter MARK, но для сокетов). Изменение метки можно использовать для маршрутизации на основе меток не задействуя netfilter или для фильтрации пакетов. Для установки этого параметра требуется мандат B<CAP_NET_ADMIN>."

#. type: TP
#: man-pages/man7/socket.7:428
#, no-wrap
msgid "B<SO_OOBINLINE>"
msgstr "B<SO_OOBINLINE>"

#.  don't document it because it can do too much harm.
#. .B SO_NO_CHECK
#. type: Plain text
#: man-pages/man7/socket.7:437
msgid ""
"If this option is enabled, out-of-band data is directly placed into the "
"receive data stream.  Otherwise, out-of-band data is passed only when the "
"B<MSG_OOB> flag is set during receiving."
msgstr "Если включён этот параметр, то внепоточные данные помещаются непосредственно во входной поток данных. В противном случае внепоточные данные передаются только, если во время приёма установлен флаг B<MSG_OOB>."

#. type: TP
#: man-pages/man7/socket.7:437
#, no-wrap
msgid "B<SO_PASSCRED>"
msgstr "B<SO_PASSCRED>"

#.  FIXME Document SO_PASSSEC, added in 2.6.18; there is some info
#.  in the 2.6.18 ChangeLog
#. type: Plain text
#: man-pages/man7/socket.7:446
msgid ""
"Enable or disable the receiving of the B<SCM_CREDENTIALS> control message.  "
"For more information see B<unix>(7)."
msgstr "Включить или выключить приём управляющего сообщения B<SCM_CREDENTIALS>. Подробней смотрите в B<unix>(7)."

#. type: TP
#: man-pages/man7/socket.7:446
#, no-wrap
msgid "B<SO_PEEK_OFF> (since Linux 3.4)"
msgstr "B<SO_PEEK_OFF> (начиная с Linux 3.4)"

#.  commit ef64a54f6e558155b4f149bb10666b9e914b6c54
#. type: Plain text
#: man-pages/man7/socket.7:456
msgid ""
"This option, which is currently supported only for B<unix>(7)  sockets, sets"
" the value of the \"peek offset\" for the B<recv>(2)  system call when used "
"with B<MSG_PEEK> flag."
msgstr "Этот параметр, который пока поддерживается только для сокетов B<unix>(7), устанавливает значение «смещения выборки» (peek offset) для системного вызова B<recv(2)>, когда он используется с флагом B<MSG_PEEK>."

#. type: Plain text
#: man-pages/man7/socket.7:464
msgid ""
"When this option is set to a negative value (it is set to -1 for all new "
"sockets), traditional behavior is provided: B<recv>(2)  with the B<MSG_PEEK>"
" flag will peek data from the front of the queue."
msgstr "Если этому параметру присваивается отрицательное значение (равен -1 для всех новых сокетов), то действует обычное правило: B<recv(2)> с флагом B<MSG_PEEK> выбирает данные из начала (front) очереди."

#. type: Plain text
#: man-pages/man7/socket.7:471
msgid ""
"When the option is set to a value greater than or equal to zero, then the "
"next peek at data queued in the socket will occur at the byte offset "
"specified by the option value.  At the same time, the \"peek offset\" will "
"be incremented by the number of bytes that were peeked from the queue, so "
"that a subsequent peek will return the next data in the queue."
msgstr "Если этому параметру присваивается положительное значение или ноль, то следующая выборка данных из очереди сокета произойдёт по байтовому смещению, определяемому значением этого параметра. В то же время, «смещение выборки» будет увеличено на количество байт, выбранных из очереди, то есть последовательные операции выборки возвращают следующие данные из очереди."

#. type: Plain text
#: man-pages/man7/socket.7:483
msgid ""
"If data is removed from the front of the queue via a call to B<recv>(2)  (or"
" similar) without the B<MSG_PEEK> flag, the \"peek offset\" will be "
"decreased by the number of bytes removed.  In other words, receiving data "
"without the B<MSG_PEEK> flag will cause the \"peek offset\" to be adjusted "
"to maintain the correct relative position in the queued data, so that a "
"subsequent peek will retrieve the data that would have been retrieved had "
"the data not been removed."
msgstr "Если данные удалены из начала очереди с помощью вызова B<recv>(2) (или подобного) без флага B<MSG_PEEK>, то «смещение выборки» будет уменьшено на количество удалённых байт. Другими словами, приём данных без флага B<MSG_PEEK> корректирует «смещение выборки»  относительно поддерживаемого относительного положения данных в очереди, и последующая выборка возвратит данные, которые были бы получены, если бы данные не удалялись."

#. type: Plain text
#: man-pages/man7/socket.7:488
msgid ""
"For datagram sockets, if the \"peek offset\" points to the middle of a "
"packet, the data returned will be marked with the B<MSG_TRUNC> flag."
msgstr "Для датаграммных сокетов, если «смещение выборки» указывает в середину пакета, то возвращаемые данные маркируются флагом B<MSG_TRUNC>."

#. type: Plain text
#: man-pages/man7/socket.7:492
msgid ""
"The following example serves to illustrate the use of B<SO_PEEK_OFF>.  "
"Suppose a stream socket has the following queued input data:"
msgstr "В следующем примере показано использование B<SO_PEEK_OFF>. Предположим, в очереди потокового сокета есть входные данные:"

#. type: Plain text
#: man-pages/man7/socket.7:494
#, no-wrap
msgid "    aabbccddeeff\n"
msgstr "    aabbccddeeff\n"

#. type: Plain text
#: man-pages/man7/socket.7:499
msgid ""
"The following sequence of B<recv>(2)  calls would have the effect noted in "
"the comments:"
msgstr "Следующая последовательность вызовов B<recv>(2) выполнила бы то, что описано в комментариях:"

#. type: Plain text
#: man-pages/man7/socket.7:504
#, no-wrap
msgid ""
"int ov = 4;                  // Set peek offset to 4\n"
"setsockopt(fd, SOL_SOCKET, SO_PEEK_OFF, &ov, sizeof(ov));\n"
msgstr "int ov = 4;        // установка смещения выборки равной 4\nsetsockopt(fd, SOL_SOCKET, SO_PEEK_OFF, &ov, sizeof(ov));\n"

#. type: Plain text
#: man-pages/man7/socket.7:509
#, no-wrap
msgid ""
"recv(fd, buf, 2, MSG_PEEK);  // Peeks \"cc\"; offset set to 6\n"
"recv(fd, buf, 2, MSG_PEEK);  // Peeks \"dd\"; offset set to 8\n"
"recv(fd, buf, 2, 0);         // Reads \"aa\"; offset set to 6\n"
"recv(fd, buf, 2, MSG_PEEK);  // Peeks \"ee\"; offset set to 8\n"
msgstr "recv(fd, buf, 2, MSG_PEEK);  // выборка «cc»; смещение 6\nrecv(fd, buf, 2, MSG_PEEK);  // выборка «dd»; смещение 8\nrecv(fd, buf, 2, 0);         // выборка «aa»; смещение 6\nrecv(fd, buf, 2, MSG_PEEK);  // выборка «ee»; смещение 8\n"

#. type: TP
#: man-pages/man7/socket.7:511
#, no-wrap
msgid "B<SO_PEERCRED>"
msgstr "B<SO_PEERCRED>"

#. type: Plain text
#: man-pages/man7/socket.7:534
msgid ""
"Return the credentials of the foreign process connected to this socket.  "
"This is possible only for connected B<AF_UNIX> stream sockets and B<AF_UNIX>"
" stream and datagram socket pairs created using B<socketpair>(2); see "
"B<unix>(7).  The returned credentials are those that were in effect at the "
"time of the call to B<connect>(2)  or B<socketpair>(2).  The argument is a "
"I<ucred> structure; define the B<_GNU_SOURCE> feature test macro to obtain "
"the definition of that structure from I<E<lt>sys/socket.hE<gt>>.  This "
"socket option is read-only."
msgstr "Получить учётные данные (credentials) стороннего процесса, соединённого с сокетом. Работает только для соединённых потоковых сокетов B<AF_UNIX>, потоков B<AF_UNIX> и датаграммных сокетных пар, созданных с помощью B<socketpair>(2); смотрите B<unix>(7). Возвращаются данные, которые были действительными на момент вызова B<connect>(2) или B<socketpair>(2). Аргументом является структура I<ucred>; определите макрос тестирования свойств B<_GNU_SOURCE> для получения определения этой структуры из I<E<lt>sys/socket.hE<gt>>. Данный параметр сокета доступен только для чтения."

#. type: TP
#: man-pages/man7/socket.7:534
#, no-wrap
msgid "B<SO_PRIORITY>"
msgstr "B<SO_PRIORITY>"

#. type: Plain text
#: man-pages/man7/socket.7:547
msgid ""
"Set the protocol-defined priority for all packets to be sent on this socket."
"  Linux uses this value to order the networking queues: packets with a "
"higher priority may be processed first depending on the selected device "
"queueing discipline.  For B<ip>(7), this also sets the IP type-of-service "
"(TOS) field for outgoing packets.  Setting a priority outside the range 0 to"
" 6 requires the B<CAP_NET_ADMIN> capability."
msgstr "Установить определяемый протоколом приоритет для всех пакетов, отправляемых из этого сокета. Linux использует это значение для управления сетевыми очередями: пакеты с более высоким приоритетом могут быть обработаны раньше (в зависимости от выбранного для устройства способа постановки в очередь). Для B<ip>(7) этот параметр также устанавливает поле IP type-of-service (TOS - тип службы) исходящих пакетов. Установка значения приоритета не из диапазона 0 до 6 требует мандата B<CAP_NET_ADMIN>."

#. type: TP
#: man-pages/man7/socket.7:547
#, no-wrap
msgid "B<SO_PROTOCOL> (since Linux 2.6.32)"
msgstr "B<SO_PROTOCOL> (начиная с Linux 2.6.32)"

#. type: Plain text
#: man-pages/man7/socket.7:555
msgid ""
"Retrieves the socket protocol as an integer, returning a value such as "
"B<IPPROTO_SCTP>.  See B<socket>(2)  for details.  This socket option is "
"read-only."
msgstr "Получить протокол сокета в виде целого числа; пример возвращаемого значения: B<IPPROTO_SCTP>. Подробней смотрите в B<socket>(2). Этот параметр сокета доступен только для чтения."

#. type: TP
#: man-pages/man7/socket.7:555
#, no-wrap
msgid "B<SO_RCVBUF>"
msgstr "B<SO_RCVBUF>"

#.  Most (all?) other implementations do not do this -- MTK, Dec 05
#.  The following thread on LMKL is quite informative:
#.  getsockopt/setsockopt with SO_RCVBUF and SO_SNDBUF "non-standard" behavior
#.  17 July 2012
#.  http://thread.gmane.org/gmane.linux.kernel/1328935
#. type: Plain text
#: man-pages/man7/socket.7:574
msgid ""
"Sets or gets the maximum socket receive buffer in bytes.  The kernel doubles"
" this value (to allow space for bookkeeping overhead)  when it is set using "
"B<setsockopt>(2), and this doubled value is returned by B<getsockopt>(2).  "
"The default value is set by the I</proc/sys/net/core/rmem_default> file, and"
" the maximum allowed value is set by the I</proc/sys/net/core/rmem_max> "
"file.  The minimum (doubled) value for this option is 256."
msgstr "Задать или получить максимальный размер буфера приёма сокета (в байтах). Ядро удваивает это значение (для пространства под учёт ресурсов (bookkeeping overhead)) при установке этого параметра с помощью B<setsockopt>(2), и это удвоенное значение возвращается B<getsockopt>(2). Значение по умолчанию устанавливается через файл I</proc/sys/net/core/rmem_default>, а максимальное возможное значение устанавливается через файл I</proc/sys/net/core/rmem_max>. Минимальное (удвоенное) значение для этого параметра равно 256."

#. type: TP
#: man-pages/man7/socket.7:574
#, no-wrap
msgid "B<SO_RCVBUFFORCE> (since Linux 2.6.14)"
msgstr "B<SO_RCVBUFFORCE> (начиная с Linux 2.6.14)"

#. type: Plain text
#: man-pages/man7/socket.7:583
msgid ""
"Using this socket option, a privileged (B<CAP_NET_ADMIN>)  process can "
"perform the same task as B<SO_RCVBUF>, but the I<rmem_max> limit can be "
"overridden."
msgstr "С помощью этого параметра сокета привилегированный (B<CAP_NET_ADMIN>) процесс может выполнить ту же работу, что и с помощью B<SO_RCVBUF>, но возможно превысить ограничение I<rmem_max>."

#. type: TP
#: man-pages/man7/socket.7:583
#, no-wrap
msgid "B<SO_RCVLOWAT> and B<SO_SNDLOWAT>"
msgstr "B<SO_RCVLOWAT> и B<SO_SNDLOWAT>"

#.  See http://marc.theaimsgroup.com/?l=linux-kernel&m=111049368106984&w=2
#.  Tested on kernel 2.6.14 -- mtk, 30 Nov 05
#. type: Plain text
#: man-pages/man7/socket.7:612
msgid ""
"Specify the minimum number of bytes in the buffer until the socket layer "
"will pass the data to the protocol (B<SO_SNDLOWAT>)  or the user on "
"receiving (B<SO_RCVLOWAT>).  These two values are initialized to 1.  "
"B<SO_SNDLOWAT> is not changeable on Linux (B<setsockopt>(2)  fails with the "
"error B<ENOPROTOOPT>).  B<SO_RCVLOWAT> is changeable only since Linux 2.4.  "
"The B<select>(2)  and B<poll>(2)  system calls currently do not respect the "
"B<SO_RCVLOWAT> setting on Linux, and mark a socket readable when even a "
"single byte of data is available.  A subsequent read from the socket will "
"block until B<SO_RCVLOWAT> bytes are available."
msgstr "Задать минимальное количество байт в буфере до которого уровень сокета будет отправлять данные протоколу (B<SO_SNDLOWAT>) или получать их от пользователя (B<SO_RCVLOWAT>). Начальное значение этих двух элементов равно 1. Для B<SO_SNDLOWAT> значение в Linux изменить нельзя (B<setsockopt>(2) завершает выполнение с ошибкой B<ENOPROTOOPT>). Значение для B<SO_RCVLOWAT> можно изменить начиная с Linux версии 2.4. Системные вызовы B<select>(2) и B<poll>(2) пока не учитывают настройку B<SO_RCVLOWAT> в Linux, и помечают сокет как доступный для чтения даже когда доступен только 1 байт данных. Последующее чтение из сокета будет заблокировано до тех пор, пока не будет доступно B<SO_RCVLOWAT> байт."

#. type: TP
#: man-pages/man7/socket.7:612
#, no-wrap
msgid "B<SO_RCVTIMEO> and B<SO_SNDTIMEO>"
msgstr "B<SO_RCVTIMEO> и B<SO_SNDTIMEO>"

#.  Not implemented in 2.0.
#.  Implemented in 2.1.11 for getsockopt: always return a zero struct.
#.  Implemented in 2.3.41 for setsockopt, and actually used.
#.  in fact to EAGAIN
#. type: Plain text
#: man-pages/man7/socket.7:647
msgid ""
"Specify the receiving or sending timeouts until reporting an error.  The "
"argument is a I<struct timeval>.  If an input or output function blocks for "
"this period of time, and data has been sent or received, the return value of"
" that function will be the amount of data transferred; if no data has been "
"transferred and the timeout has been reached, then -1 is returned with "
"I<errno> set to B<EAGAIN> or B<EWOULDBLOCK>, or B<EINPROGRESS> (for "
"B<connect>(2))  just as if the socket was specified to be nonblocking.  If "
"the timeout is set to zero (the default), then the operation will never "
"timeout.  Timeouts only have effect for system calls that perform socket I/O"
" (e.g., B<read>(2), B<recvmsg>(2), B<send>(2), B<sendmsg>(2)); timeouts have"
" no effect for B<select>(2), B<poll>(2), B<epoll_wait>(2), and so on."
msgstr "Задать время ожидания (при отправке или приёме) до генерации сообщения об ошибке. Аргументом является структура I<struct timeval>. Если вводящая или выводящая функция блокируется на этот период времени, и данные был отправлены или получены, то возвращаемое значение этой функции будет равно количеству переданных данных; если данные не проходили и время ожидания истекло, то возвращается -1 и I<errno> устанавливается в B<EAGAIN>, B<EWOULDBLOCK> или B<EINPROGRESS> (для B<connect>(2)) — также как, если был сокет был заблокирован. Если время ожидания установлено в 0 (по умолчанию), то операция не будет ждать. Время ожидания учитывается только в системных вызовах, которые выполняют ввод-вывод из сокета (например, B<read>(2), B<recvmsg>(2), B<send>(2), B<sendmsg>(2)); время ожидания не учитывается в B<select>(2), B<poll>(2), B<epoll_wait>(2) и подобных."

#. type: TP
#: man-pages/man7/socket.7:647
#, no-wrap
msgid "B<SO_REUSEADDR>"
msgstr "B<SO_REUSEADDR>"

#. type: Plain text
#: man-pages/man7/socket.7:662
msgid ""
"Indicates that the rules used in validating addresses supplied in a "
"B<bind>(2)  call should allow reuse of local addresses.  For B<AF_INET> "
"sockets this means that a socket may bind, except when there is an active "
"listening socket bound to the address.  When the listening socket is bound "
"to B<INADDR_ANY> with a specific port then it is not possible to bind to "
"this port for any local address.  Argument is an integer boolean flag."
msgstr "Указать, что правила проверки адресов, передаваемых с помощью вызова B<bind>(2), должны позволять повторное использование локальных адресов. В случае с сокетами B<AF_INET> это означает, что сокет может быть привязан (bind), за исключением случаев, когда активному слушающему сокету присвоен адрес. Если слушающий сокет привязан к B<INADDR_ANY> с определённым портом, то к этому порту невозможно будет привязать любой локальный адрес. Аргументом является целочисленный логический флаг."

#. type: TP
#: man-pages/man7/socket.7:662
#, no-wrap
msgid "B<SO_RXQ_OVFL> (since Linux 2.6.33)"
msgstr "B<SO_RXQ_OVFL> (начиная с Linux 2.6.33)"

#.  commit 3b885787ea4112eaa80945999ea0901bf742707f
#. type: Plain text
#: man-pages/man7/socket.7:669
msgid ""
"Indicates that an unsigned 32-bit value ancillary message (cmsg)  should be "
"attached to received skbs indicating the number of packets dropped by the "
"socket between the last received packet and this received packet."
msgstr ""

#. type: TP
#: man-pages/man7/socket.7:669
#, no-wrap
msgid "B<SO_SNDBUF>"
msgstr "B<SO_SNDBUF>"

#.  Most (all?) other implementations do not do this -- MTK, Dec 05
#.  See also the comment to SO_RCVBUF (17 Jul 2012 LKML mail)
#. type: Plain text
#: man-pages/man7/socket.7:685
msgid ""
"Sets or gets the maximum socket send buffer in bytes.  The kernel doubles "
"this value (to allow space for bookkeeping overhead)  when it is set using "
"B<setsockopt>(2), and this doubled value is returned by B<getsockopt>(2).  "
"The default value is set by the I</proc/sys/net/core/wmem_default> file and "
"the maximum allowed value is set by the I</proc/sys/net/core/wmem_max> file."
"  The minimum (doubled) value for this option is 2048."
msgstr "Задать или считать максимальный размер буфера отправки сокета (в байтах). Ядро удваивает это значение (для пространства под учёт ресурсов (bookkeeping overhead)) при установке этого параметра с помощью B<setsockopt>(2), и это удвоенное значение возвращается B<getsockopt>(2). Значение по умолчанию устанавливается через файл I</proc/sys/net/core/wmem_default>, а максимальное возможное значение устанавливается через файл I</proc/sys/net/core/wmem_max>. Минимальное (удвоенное) значение для этого параметра равно 2048."

#. type: TP
#: man-pages/man7/socket.7:685
#, no-wrap
msgid "B<SO_SNDBUFFORCE> (since Linux 2.6.14)"
msgstr "B<SO_SNDBUFFORCE> (начиная Linux 2.6.14)"

#. type: Plain text
#: man-pages/man7/socket.7:694
msgid ""
"Using this socket option, a privileged (B<CAP_NET_ADMIN>)  process can "
"perform the same task as B<SO_SNDBUF>, but the I<wmem_max> limit can be "
"overridden."
msgstr "С помощью этого параметра сокета привилегированный (B<CAP_NET_ADMIN>) процесс может выполнить ту же работу, что и с помощью B<SO_SNDBUF>, но возможно превысить ограничение I<wmem_max>."

#. type: TP
#: man-pages/man7/socket.7:694
#, no-wrap
msgid "B<SO_TIMESTAMP>"
msgstr "B<SO_TIMESTAMP>"

#. type: Plain text
#: man-pages/man7/socket.7:710
msgid ""
"Enable or disable the receiving of the B<SO_TIMESTAMP> control message.  The"
" timestamp control message is sent with level B<SOL_SOCKET> and the "
"I<cmsg_data> field is a I<struct timeval> indicating the reception time of "
"the last packet passed to the user in this call.  See B<cmsg>(3)  for "
"details on control messages."
msgstr "Включить или выключить приём управляющего сообщения B<SO_TIMESTAMP>. Управляющее сообщение метки времени посылается с уровнем B<SOL_SOCKET>, а поле I<cmsg_data> выражено структурой I<struct timeval>, обозначающей время приёма последнего пакета, переданного пользователю в этом вызове. Подробней об управляющих сообщениях смотрите в B<cmsg>(3)."

#. type: TP
#: man-pages/man7/socket.7:710
#, no-wrap
msgid "B<SO_TYPE>"
msgstr "B<SO_TYPE>"

#. type: Plain text
#: man-pages/man7/socket.7:715
msgid ""
"Gets the socket type as an integer (e.g., B<SOCK_STREAM>).  This socket "
"option is read-only."
msgstr "Получить тип сокета в виде целого числа (например, B<SOCK_STREAM>). Этот параметр сокета доступен только для чтения."

#. type: TP
#: man-pages/man7/socket.7:715
#, no-wrap
msgid "B<SO_BUSY_POLL> (since Linux 3.11)"
msgstr "B<SO_BUSY_POLL> (начиная с Linux 3.11)"

#. type: Plain text
#: man-pages/man7/socket.7:724
msgid ""
"Sets the approximate time in microseconds to busy poll on a blocking receive"
" when there is no data.  Increasing this value requires B<CAP_NET_ADMIN>.  "
"The default for this option is controlled by the "
"I</proc/sys/net/core/busy_read> file."
msgstr ""

#. type: Plain text
#: man-pages/man7/socket.7:734
msgid ""
"The value in the I</proc/sys/net/core/busy_poll> file determines how long "
"B<select>(2)  and B<poll>(2)  will busy poll when they operate on sockets "
"with B<SO_BUSY_POLL> set and no events to report are found."
msgstr ""

#. type: Plain text
#: man-pages/man7/socket.7:738
msgid ""
"In both cases, busy polling will only be done when the socket last received "
"data from a network device that supports this option."
msgstr ""

#. type: Plain text
#: man-pages/man7/socket.7:742
msgid ""
"While busy polling may improve latency of some applications, care must be "
"taken when using it since this will increase both CPU utilization and power "
"usage."
msgstr ""

#. type: SS
#: man-pages/man7/socket.7:742
#, no-wrap
msgid "Signals"
msgstr "Сигналы"

#. type: Plain text
#: man-pages/man7/socket.7:753
msgid ""
"When writing onto a connection-oriented socket that has been shut down (by "
"the local or the remote end)  B<SIGPIPE> is sent to the writing process and "
"B<EPIPE> is returned.  The signal is not sent when the write call specified "
"the B<MSG_NOSIGNAL> flag."
msgstr "При записи в сокет, ориентированный на соединение, который был выключен (shutdown) локальной или удалённой стороной, записывающему процессу посылается сигнал B<SIGPIPE> и возвращается B<EPIPE>. Сигнал не посылается, если вызов записи был сделан с флагом B<MSG_NOSIGNAL>."

#. type: Plain text
#: man-pages/man7/socket.7:778
msgid ""
"When requested with the B<FIOSETOWN> B<fcntl>(2)  or B<SIOCSPGRP> "
"B<ioctl>(2), B<SIGIO> is sent when an I/O event occurs.  It is possible to "
"use B<poll>(2)  or B<select>(2)  in the signal handler to find out which "
"socket the event occurred on.  An alternative (in Linux 2.2) is to set a "
"real-time signal using the B<F_SETSIG> B<fcntl>(2); the handler of the real "
"time signal will be called with the file descriptor in the I<si_fd> field of"
" its I<siginfo_t>.  See B<fcntl>(2)  for more information."
msgstr "Если был произведён вызов B<fcntl>(2) с B<FIOSETOWN> или B<ioctl>(2) с B<SIOCSPGRP>, то при появлении событий ввода/вывода посылается сигнал B<SIGIO>. Для определения сокета, в котором произошло событие, в обработчике можно воспользоваться вызовом B<poll>(2) или B<select>(2). Альтернативным способом (в Linux 2.2) является установка сигнала реального времени с помощью вызова B<fcntl>(2) с B<F_SETSIG>; будет вызван обработчик сигнала реального времени и в его структуре I<siginfo_t> поле I<si_fd> будет содержать значение файлового дескриптора. Дополнительная информация приведена в B<fcntl>(2)."

#.  .SS Ancillary messages
#. type: Plain text
#: man-pages/man7/socket.7:786
msgid ""
"Under some circumstances (e.g., multiple processes accessing a single "
"socket), the condition that caused the B<SIGIO> may have already disappeared"
" when the process reacts to the signal.  If this happens, the process should"
" wait again because Linux will resend the signal later."
msgstr "В некоторых случаях (например, при наличии доступа нескольких процессов к одному сокету) условие, вызвавшее B<SIGIO>, может исчезнуть на момент обработки процессом сигнала. Если это происходит, то процесс должен подождать сигнала ещё какое-то время, так как Linux снова пошлёт его позже."

#. type: SS
#: man-pages/man7/socket.7:786
#, no-wrap
msgid "/proc interfaces"
msgstr "Интерфейсы /proc"

#. type: Plain text
#: man-pages/man7/socket.7:790
msgid ""
"The core socket networking parameters can be accessed via files in the "
"directory I</proc/sys/net/core/>."
msgstr "Основные сетевые параметры сокета доступны через файлы в каталоге I</proc/sys/net/core/>."

#. type: TP
#: man-pages/man7/socket.7:790
#, no-wrap
msgid "I<rmem_default>"
msgstr "I<rmem_default>"

#. type: Plain text
#: man-pages/man7/socket.7:793
msgid "contains the default setting in bytes of the socket receive buffer."
msgstr "устанавливаемый по умолчанию размер буфера приёма сокета (в байтах)"

#. type: TP
#: man-pages/man7/socket.7:793
#, no-wrap
msgid "I<rmem_max>"
msgstr "I<rmem_max>"

#. type: Plain text
#: man-pages/man7/socket.7:799
msgid ""
"contains the maximum socket receive buffer size in bytes which a user may "
"set by using the B<SO_RCVBUF> socket option."
msgstr "максимальный размер буфера приёма сокета (в байтах), который может установить пользователь с помощью параметра сокета B<SO_RCVBUF>"

#. type: TP
#: man-pages/man7/socket.7:799
#, no-wrap
msgid "I<wmem_default>"
msgstr "I<wmem_default>"

#. type: Plain text
#: man-pages/man7/socket.7:802
msgid "contains the default setting in bytes of the socket send buffer."
msgstr "устанавливаемый по умолчанию размер буфера отправки сокета (в байтах)"

#. type: TP
#: man-pages/man7/socket.7:802
#, no-wrap
msgid "I<wmem_max>"
msgstr "I<wmem_max>"

#. type: Plain text
#: man-pages/man7/socket.7:808
msgid ""
"contains the maximum socket send buffer size in bytes which a user may set "
"by using the B<SO_SNDBUF> socket option."
msgstr "максимальный размер буфера отправки сокета (в байтах), который может установить пользователь с помощью параметра сокета B<SO_SNDBUF>"

#. type: TP
#: man-pages/man7/socket.7:808
#, no-wrap
msgid "I<message_cost> and I<message_burst>"
msgstr "I<message_cost> и I<message_burst>"

#. type: Plain text
#: man-pages/man7/socket.7:812
msgid ""
"configure the token bucket filter used to load limit warning messages caused"
" by external network events."
msgstr "фильтр корзины токенов, используемый для ограничения нагрузки сети предупреждающими сообщениями, вызванными внешними сетевыми событиями"

#. type: TP
#: man-pages/man7/socket.7:812
#, no-wrap
msgid "I<netdev_max_backlog>"
msgstr "I<netdev_max_backlog>"

#. type: Plain text
#: man-pages/man7/socket.7:815
msgid "Maximum number of packets in the global input queue."
msgstr "максимальное количество пакетов в глобальной входящей очереди"

#. type: TP
#: man-pages/man7/socket.7:815
#, no-wrap
msgid "I<optmem_max>"
msgstr "I<optmem_max>"

#.  netdev_fastroute is not documented because it is experimental
#. type: Plain text
#: man-pages/man7/socket.7:820
msgid ""
"Maximum length of ancillary data and user control data like the iovecs per "
"socket."
msgstr "максимальная длина вспомогательных данных и управляющих данных пользователя, таких, как iovec (для каждого сокета)"

#. type: Plain text
#: man-pages/man7/socket.7:823
msgid "These operations can be accessed using B<ioctl>(2):"
msgstr "Следующие операции доступны через B<ioctl>(2):"

#. type: Plain text
#: man-pages/man7/socket.7:827
#, no-wrap
msgid ""
"I<error>B< = ioctl(>I<ip_socket>B<, >I<ioctl_type>B<, "
">I<&value_result>B<);>\n"
msgstr "I<error>B< = ioctl(>I<ip_socket>B<, >I<ioctl_type>B<, >I<&value_result>B<);>\n"

#. type: TP
#: man-pages/man7/socket.7:829
#, no-wrap
msgid "B<SIOCGSTAMP>"
msgstr "B<SIOCGSTAMP>"

#. type: Plain text
#: man-pages/man7/socket.7:853
msgid ""
"Return a I<struct timeval> with the receive timestamp of the last packet "
"passed to the user.  This is useful for accurate round trip time "
"measurements.  See B<setitimer>(2)  for a description of I<struct timeval>."
"  This ioctl should be used only if the socket option B<SO_TIMESTAMP> is not"
" set on the socket.  Otherwise, it returns the timestamp of the last packet "
"that was received while B<SO_TIMESTAMP> was not set, or it fails if no such "
"packet has been received, (i.e., B<ioctl>(2)  returns -1 with I<errno> set "
"to B<ENOENT>)."
msgstr "Возвращает структуру I<struct timeval> с меткой времени принятого последнего пакета, переданного пользователю. Это полезно для точного вычисления времени. Описание I<struct timeval> приведено в B<setitimer>(2). Данный ioctl нужно использовать только, если для сокета не задан параметр B<SO_TIMESTAMP>. В противном случае возвращается метка времени последнего пакета, который был получен в то время, когда не был установлен B<SO_TIMESTAMP>, или возвращается ошибка, если такой пакет вообще никогда не принимался (т.е. B<ioctl>(2) возвращает -1 и устанавливает I<errno> равной B<ENOENT>)."

#. type: TP
#: man-pages/man7/socket.7:853
#, no-wrap
msgid "B<SIOCSPGRP>"
msgstr "B<SIOCSPGRP>"

#. type: Plain text
#: man-pages/man7/socket.7:872
msgid ""
"Set the process or process group to send B<SIGIO> or B<SIGURG> signals to "
"when an asynchronous I/O operation has finished or urgent data is available."
"  The argument is a pointer to a I<pid_t>.  If the argument is positive, "
"send the signals to that process.  If the argument is negative, send the "
"signals to the process group with the ID of the absolute value of the "
"argument.  The process may only choose itself or its own process group to "
"receive signals unless it has the B<CAP_KILL> capability or an effective UID"
" of 0."
msgstr "Назначает процесс или группу процессов, которым будут посылаться сигналы B<SIGIO> или B<SIGURG> по окончании выполнения асинхронной операции или при появлении срочных данных. Аргумент является указателем на I<pid_t>. Если аргумент отрицателен, то сигналы будут посылаться группе процессов c идентификатором, равным абсолютному значению аргумента. Если процесс не имеет мандата B<CAP_KILL> или его эффективный идентификатор не равен нулю, то он может указывать только на себя или свою группу процессов."

#. type: TP
#: man-pages/man7/socket.7:872
#, no-wrap
msgid "B<FIOASYNC>"
msgstr "B<FIOASYNC>"

#. type: Plain text
#: man-pages/man7/socket.7:882
msgid ""
"Change the B<O_ASYNC> flag to enable or disable asynchronous I/O mode of the"
" socket.  Asynchronous I/O mode means that the B<SIGIO> signal or the signal"
" set with B<F_SETSIG> is raised when a new I/O event occurs."
msgstr "Изменяет флаг B<O_ASYNC> для включения или отключения асинхронного режима ввода/вывода сокета. В асинхронном режиме при появлении событий ввода/вывода посылается сигнал B<SIGIO> или сигнал, установленный с помощью B<F_SETSIG>."

#. type: Plain text
#: man-pages/man7/socket.7:890
msgid ""
"Argument is an integer boolean flag.  (This operation is synonymous with the"
" use of B<fcntl>(2)  to set the B<O_ASYNC> flag.)"
msgstr "Аргументом является целочисленный логический флаг. Данная операция аналогична вызову B<fcntl>(2) с установленным флагом B<O_ASYNC>."

#. type: TP
#: man-pages/man7/socket.7:890
#, no-wrap
msgid "B<SIOCGPGRP>"
msgstr "B<SIOCGPGRP>"

#. type: Plain text
#: man-pages/man7/socket.7:899
msgid ""
"Get the current process or process group that receives B<SIGIO> or B<SIGURG>"
" signals, or 0 when none is set."
msgstr "Возвращает процесс или группу процессов, получающих сигналы B<SIGIO> или B<SIGURG>. Если такой процесс не задан, то возвращается нулевое значение."

#. type: Plain text
#: man-pages/man7/socket.7:903
msgid "Valid B<fcntl>(2)  operations:"
msgstr "Возможные операции B<fcntl>(2):"

#. type: TP
#: man-pages/man7/socket.7:903
#, no-wrap
msgid "B<FIOGETOWN>"
msgstr "B<FIOGETOWN>"

#. type: Plain text
#: man-pages/man7/socket.7:908
msgid "The same as the B<SIOCGPGRP> B<ioctl>(2)."
msgstr "То же, что и вызов B<ioctl>(2) B<SIOCGPGRP>."

#. type: TP
#: man-pages/man7/socket.7:908
#, no-wrap
msgid "B<FIOSETOWN>"
msgstr "B<FIOSETOWN>"

#. type: Plain text
#: man-pages/man7/socket.7:913
msgid "The same as the B<SIOCSPGRP> B<ioctl>(2)."
msgstr "То же, что и вызов B<ioctl>(2) B<SIOCSPGRP>."

#. type: SH
#: man-pages/man7/socket.7:913
#, no-wrap
msgid "VERSIONS"
msgstr "ВЕРСИИ"

#. type: Plain text
#: man-pages/man7/socket.7:927
msgid ""
"B<SO_BINDTODEVICE> was introduced in Linux 2.0.30.  B<SO_PASSCRED> is new in"
" Linux 2.2.  The I</proc> interfaces was introduced in Linux 2.2.  "
"B<SO_RCVTIMEO> and B<SO_SNDTIMEO> are supported since Linux 2.3.41.  "
"Earlier, timeouts were fixed to a protocol-specific setting, and could not "
"be read or written."
msgstr "Параметр B<SO_BINDTODEVICE> появился в Linux 2.0.30. Параметр B<SO_PASSCRED> появился в Linux 2.2. Интерфейсы I</proc> появились в Linux 2.2. Параметры B<SO_RCVTIMEO> и B<SO_SNDTIMEO> начали поддерживаться в Linux 2.3.41. До этого, времена ожидания были жёстко прописаны в настройках протокола и недоступны для чтения или записи."

#. type: Plain text
#: man-pages/man7/socket.7:932
msgid ""
"Linux assumes that half of the send/receive buffer is used for internal "
"kernel structures; thus the values in the corresponding I</proc> files are "
"twice what can be observed on the wire."
msgstr "В Linux предполагается, что половина буфера приёма/передачи используется для размещения внутренних структур ядра; поэтому соответствующие файлы I</proc> в два раза больше, чем кажутся."

#. type: Plain text
#: man-pages/man7/socket.7:945
msgid ""
"Linux will only allow port reuse with the B<SO_REUSEADDR> option when this "
"option was set both in the previous program that performed a B<bind>(2)  to "
"the port and in the program that wants to reuse the port.  This differs from"
" some implementations (e.g., FreeBSD)  where only the later program needs to"
" set the B<SO_REUSEADDR> option.  Typically this difference is invisible, "
"since, for example, a server program is designed to always set this option."
msgstr "В Linux разрешено повторное использование порта с параметром B<SO_REUSEADDR> только, когда этот параметр установлен и в программе, уже выполнившей B<bind>(2) и в программе, которая хочет использовать порт. Такое поведение отличается от некоторых реализаций (например, FreeBSD), в которых только последняя программа должна устанавливать параметр B<SO_REUSEADDR>. Обычно, это отличие незаметно, так как, например, в серверных программах всегда устанавливают этот параметр."

#.  FIXME Document SO_ATTACH_FILTER and SO_DETACH_FILTER
#.  .SH AUTHORS
#.  This man page was written by Andi Kleen.
#. type: Plain text
#: man-pages/man7/socket.7:958
msgid ""
"The B<CONFIG_FILTER> socket options B<SO_ATTACH_FILTER> and "
"B<SO_DETACH_FILTER> are not documented.  The suggested interface to use them"
" is via the libpcap library."
msgstr "Параметры B<SO_ATTACH_FILTER> и B<SO_DETACH_FILTER> сокета B<CONFIG_FILTER> не описаны. Рекомендуется использовать их с помощью библиотеки libpcap."

#. type: Plain text
#: man-pages/man7/socket.7:969
msgid ""
"B<connect>(2), B<getsockopt>(2), B<setsockopt>(2), B<socket>(2), "
"B<capabilities>(7), B<ddp>(7), B<ip>(7), B<packet>(7), B<tcp>(7), B<udp>(7),"
" B<unix>(7)"
msgstr "B<connect>(2), B<getsockopt>(2), B<setsockopt>(2), B<socket>(2), B<capabilities>(7), B<ddp>(7), B<ip>(7), B<packet>(7), B<tcp>(7), B<udp>(7), B<unix>(7)"

#. type: TH
#: man-pages/man7/shm_overview.7:27
#, no-wrap
msgid "SHM_OVERVIEW"
msgstr "SHM_OVERVIEW"

#. type: TH
#: man-pages/man7/shm_overview.7:27
#, no-wrap
msgid "2010-09-10"
msgstr "2010-09-10"

#. type: Plain text
#: man-pages/man7/shm_overview.7:30
msgid "shm_overview - overview of POSIX shared memory"
msgstr ""

#. type: Plain text
#: man-pages/man7/shm_overview.7:33
msgid ""
"The POSIX shared memory API allows processes to communicate information by "
"sharing a region of memory."
msgstr ""

#. type: Plain text
#: man-pages/man7/shm_overview.7:35
msgid "The interfaces employed in the API are:"
msgstr ""

#. type: TP
#: man-pages/man7/shm_overview.7:35
#, no-wrap
msgid "B<shm_open>(3)"
msgstr "B<shm_open>(3)"

#. type: Plain text
#: man-pages/man7/shm_overview.7:42
msgid ""
"Create and open a new object, or open an existing object.  This is analogous"
" to B<open>(2).  The call returns a file descriptor for use by the other "
"interfaces listed below."
msgstr ""

#. type: TP
#: man-pages/man7/shm_overview.7:42
#, no-wrap
msgid "B<ftruncate>(2)"
msgstr "B<ftruncate>(2)"

#. type: Plain text
#: man-pages/man7/shm_overview.7:46
msgid ""
"Set the size of the shared memory object.  (A newly created shared memory "
"object has a length of zero.)"
msgstr ""

#. type: Plain text
#: man-pages/man7/shm_overview.7:50
msgid ""
"Map the shared memory object into the virtual address space of the calling "
"process."
msgstr ""

#. type: TP
#: man-pages/man7/shm_overview.7:50
#, no-wrap
msgid "B<munmap>(2)"
msgstr "B<munmap>(2)"

#. type: Plain text
#: man-pages/man7/shm_overview.7:54
msgid ""
"Unmap the shared memory object from the virtual address space of the calling"
" process."
msgstr ""

#. type: TP
#: man-pages/man7/shm_overview.7:54
#, no-wrap
msgid "B<shm_unlink>(3)"
msgstr ""

#. type: Plain text
#: man-pages/man7/shm_overview.7:57
msgid "Remove a shared memory object name."
msgstr ""

#. type: TP
#: man-pages/man7/shm_overview.7:57
#, no-wrap
msgid "B<close>(2)"
msgstr "B<close>(2)"

#. type: Plain text
#: man-pages/man7/shm_overview.7:62
msgid ""
"Close the file descriptor allocated by B<shm_open>(3)  when it is no longer "
"needed."
msgstr ""

#. type: TP
#: man-pages/man7/shm_overview.7:62
#, no-wrap
msgid "B<fstat>(2)"
msgstr "B<fstat>(2)"

#. type: Plain text
#: man-pages/man7/shm_overview.7:76
msgid ""
"Obtain a I<stat> structure that describes the shared memory object.  Among "
"the information returned by this call are the object's size (I<st_size>), "
"permissions (I<st_mode>), owner (I<st_uid>), and group (I<st_gid>)."
msgstr ""

#. type: TP
#: man-pages/man7/shm_overview.7:76
#, no-wrap
msgid "B<fchown>(2)"
msgstr "B<fchown>(2)"

#. type: Plain text
#: man-pages/man7/shm_overview.7:79
msgid "To change the ownership of a shared memory object."
msgstr ""

#. type: TP
#: man-pages/man7/shm_overview.7:79
#, no-wrap
msgid "B<fchmod>(2)"
msgstr "B<fchmod>(2)"

#. type: Plain text
#: man-pages/man7/shm_overview.7:82
msgid "To change the permissions of a shared memory object."
msgstr ""

#. type: SS
#: man-pages/man7/shm_overview.7:82
#, no-wrap
msgid "Versions"
msgstr ""

#. type: Plain text
#: man-pages/man7/shm_overview.7:84
msgid "POSIX shared memory is supported since Linux 2.4 and glibc 2.2."
msgstr ""

#. type: SS
#: man-pages/man7/shm_overview.7:84
#, no-wrap
msgid "Persistence"
msgstr ""

#. type: Plain text
#: man-pages/man7/shm_overview.7:89
msgid ""
"POSIX shared memory objects have kernel persistence: a shared memory object "
"will exist until the system is shut down, or until all processes have "
"unmapped the object and it has been deleted with B<shm_unlink>(3)"
msgstr ""

#. type: SS
#: man-pages/man7/shm_overview.7:89
#, no-wrap
msgid "Linking"
msgstr ""

#. type: Plain text
#: man-pages/man7/shm_overview.7:94
msgid ""
"Programs using the POSIX shared memory API must be compiled with I<cc -lrt> "
"to link against the real-time library, I<librt>."
msgstr ""

#. type: SS
#: man-pages/man7/shm_overview.7:94
#, no-wrap
msgid "Accessing shared memory objects via the filesystem"
msgstr ""

#. type: Plain text
#: man-pages/man7/shm_overview.7:101
msgid ""
"On Linux, shared memory objects are created in a (I<tmpfs>)  virtual "
"filesystem, normally mounted under I</dev/shm>.  Since kernel 2.6.19, Linux "
"supports the use of access control lists (ACLs)  to control the permissions "
"of objects in the virtual filesystem."
msgstr ""

#. type: Plain text
#: man-pages/man7/shm_overview.7:106
msgid ""
"Typically, processes must synchronize their access to a shared memory "
"object, using, for example, POSIX semaphores."
msgstr ""

#. type: Plain text
#: man-pages/man7/shm_overview.7:114
msgid ""
"System V shared memory (B<shmget>(2), B<shmop>(2), etc.) is an older shared "
"memory API.  POSIX shared memory provides a simpler, and better designed "
"interface; on the other hand POSIX shared memory is somewhat less widely "
"available (especially on older systems) than System V shared memory."
msgstr ""

#. type: Plain text
#: man-pages/man7/shm_overview.7:126
msgid ""
"B<fchmod>(2), B<fchown>(2), B<fstat>(2), B<ftruncate>(2), B<mmap>(2), "
"B<mprotect>(2), B<munmap>(2), B<shmget>(2), B<shmop>(2), B<shm_open>(3), "
"B<shm_unlink>(3), B<sem_overview>(7)"
msgstr "B<fchmod>(2), B<fchown>(2), B<fstat>(2), B<ftruncate>(2), B<mmap>(2), B<mprotect>(2), B<munmap>(2), B<shmget>(2), B<shmop>(2), B<shm_open>(3), B<shm_unlink>(3), B<sem_overview>(7)"

#. type: TH
#: man-pages/man7/sem_overview.7:26
#, no-wrap
msgid "SEM_OVERVIEW"
msgstr "SEM_OVERVIEW"

#. type: TH
#: man-pages/man7/sem_overview.7:26
#, no-wrap
msgid "2012-05-13"
msgstr "2012-05-13"

#. type: Plain text
#: man-pages/man7/sem_overview.7:29
msgid "sem_overview - overview of POSIX semaphores"
msgstr ""

#. type: Plain text
#: man-pages/man7/sem_overview.7:31
msgid ""
"POSIX semaphores allow processes and threads to synchronize their actions."
msgstr ""

#. type: Plain text
#: man-pages/man7/sem_overview.7:41
msgid ""
"A semaphore is an integer whose value is never allowed to fall below zero.  "
"Two operations can be performed on semaphores: increment the semaphore value"
" by one (B<sem_post>(3)); and decrement the semaphore value by one "
"(B<sem_wait>(3)).  If the value of a semaphore is currently zero, then a "
"B<sem_wait>(3)  operation will block until the value becomes greater than "
"zero."
msgstr ""

#. type: Plain text
#: man-pages/man7/sem_overview.7:44
msgid ""
"POSIX semaphores come in two forms: named semaphores and unnamed semaphores."
msgstr ""

#. type: TP
#: man-pages/man7/sem_overview.7:44
#, no-wrap
msgid "B<Named semaphores>"
msgstr ""

#.  glibc allows the initial slash to be omitted, and makes
#.  multiple initial slashes equivalent to a single slash.
#.  This differs from the implementation of POSIX message queues.
#.  glibc allows subdirectory components in the name, in which
#.  case the subdirectory tree must exist under /dev/shm, and
#.  the fist subdirectory component must exist as the name
#.  sem.name, and all of the subdirectory components must allow the
#.  required permissions if a user wants to create a semaphore
#.  object in a subdirectory.
#. type: Plain text
#: man-pages/man7/sem_overview.7:64
msgid ""
"A named semaphore is identified by a name of the form I</somename>; that is,"
" a null-terminated string of up to B<NAME_MAX>I<-4> (i.e., 251) characters "
"consisting of an initial slash, followed by one or more characters, none of "
"which are slashes.  Two processes can operate on the same named semaphore by"
" passing the same name to B<sem_open>(3)."
msgstr ""

#. type: Plain text
#: man-pages/man7/sem_overview.7:79
msgid ""
"The B<sem_open>(3)  function creates a new named semaphore or opens an "
"existing named semaphore.  After the semaphore has been opened, it can be "
"operated on using B<sem_post>(3)  and B<sem_wait>(3).  When a process has "
"finished using the semaphore, it can use B<sem_close>(3)  to close the "
"semaphore.  When all processes have finished using the semaphore, it can be "
"removed from the system using B<sem_unlink>(3)."
msgstr ""

#. type: TP
#: man-pages/man7/sem_overview.7:79
#, no-wrap
msgid "B<Unnamed semaphores (memory-based semaphores)>"
msgstr ""

#. type: Plain text
#: man-pages/man7/sem_overview.7:94
msgid ""
"An unnamed semaphore does not have a name.  Instead the semaphore is placed "
"in a region of memory that is shared between multiple threads (a I<thread-"
"shared semaphore>)  or processes (a I<process-shared semaphore>).  A thread-"
"shared semaphore is placed in an area of memory shared between the threads "
"of a process, for example, a global variable.  A process-shared semaphore "
"must be placed in a shared memory region (e.g., a System V shared memory "
"segment created using B<shmget>(2), or a POSIX shared memory object built "
"created using B<shm_open>(3))."
msgstr ""

#. type: Plain text
#: man-pages/man7/sem_overview.7:105
msgid ""
"Before being used, an unnamed semaphore must be initialized using "
"B<sem_init>(3).  It can then be operated on using B<sem_post>(3)  and "
"B<sem_wait>(3).  When the semaphore is no longer required, and before the "
"memory in which it is located is deallocated, the semaphore should be "
"destroyed using B<sem_destroy>(3)."
msgstr ""

#. type: Plain text
#: man-pages/man7/sem_overview.7:108
msgid ""
"The remainder of this section describes some specific details of the Linux "
"implementation of POSIX semaphores."
msgstr ""

#. type: Plain text
#: man-pages/man7/sem_overview.7:114
msgid ""
"Prior to kernel 2.6, Linux supported only unnamed, thread-shared semaphores."
"  On a system with Linux 2.6 and a glibc that provides the NPTL threading "
"implementation, a complete implementation of POSIX semaphores is provided."
msgstr ""

#. type: Plain text
#: man-pages/man7/sem_overview.7:119
msgid ""
"POSIX named semaphores have kernel persistence: if not removed by "
"B<sem_unlink>(3), a semaphore will exist until the system is shut down."
msgstr ""

#. type: Plain text
#: man-pages/man7/sem_overview.7:124
msgid ""
"Programs using the POSIX semaphores API must be compiled with I<cc -pthread>"
" to link against the real-time library, I<librt>."
msgstr ""

#. type: SS
#: man-pages/man7/sem_overview.7:124
#, no-wrap
msgid "Accessing named semaphores via the filesystem"
msgstr ""

#. type: Plain text
#: man-pages/man7/sem_overview.7:135
msgid ""
"On Linux, named semaphores are created in a virtual filesystem, normally "
"mounted under I</dev/shm>, with names of the form B<sem.>I<somename>.  (This"
" is the reason that semaphore names are limited to B<NAME_MAX>I<-4> rather "
"than B<NAME_MAX> characters.)"
msgstr ""

#. type: Plain text
#: man-pages/man7/sem_overview.7:138
msgid ""
"Since Linux 2.6.19, ACLs can be placed on files under this directory, to "
"control object permissions on a per-user and per-group basis."
msgstr ""

#. type: Plain text
#: man-pages/man7/sem_overview.7:149
msgid ""
"System V semaphores (B<semget>(2), B<semop>(2), etc.) are an older semaphore"
" API.  POSIX semaphores provide a simpler, and better designed interface "
"than System V semaphores; on the other hand POSIX semaphores are less widely"
" available (especially on older systems) than System V semaphores."
msgstr ""

#. type: Plain text
#: man-pages/man7/sem_overview.7:152
msgid ""
"An example of the use of various POSIX semaphore functions is shown in "
"B<sem_wait>(3)."
msgstr ""

#. type: Plain text
#: man-pages/man7/sem_overview.7:161
msgid ""
"B<sem_close>(3), B<sem_destroy>(3), B<sem_getvalue>(3), B<sem_init>(3), "
"B<sem_open>(3), B<sem_post>(3), B<sem_unlink>(3), B<sem_wait>(3), "
"B<pthreads>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/set_thread_area.2:8
#, no-wrap
msgid "SET_THREAD_AREA"
msgstr "SET_THREAD_AREA"

#. type: TH
#: man-pages/man2/set_thread_area.2:8
#, no-wrap
msgid "2012-07-13"
msgstr "2012-07-13"

#. type: Plain text
#: man-pages/man2/set_thread_area.2:11
msgid "set_thread_area - set a thread local storage (TLS) area"
msgstr "set_thread_area - назначение области локального хранилища нити (TLS)"

#. type: Plain text
#: man-pages/man2/set_thread_area.2:13
msgid "B<#include E<lt>linux/unistd.hE<gt>>"
msgstr "B<#include E<lt>linux/unistd.hE<gt>>"

#. type: Plain text
#: man-pages/man2/set_thread_area.2:15
msgid "B<#include E<lt>asm/ldt.hE<gt>>"
msgstr "B<#include E<lt>asm/ldt.hE<gt>>"

#. type: Plain text
#: man-pages/man2/set_thread_area.2:17
msgid "B<int set_thread_area(struct user_desc *>I<u_info>B<);>"
msgstr "B<int set_thread_area(struct user_desc *>I<u_info>B<);>"

#. type: Plain text
#: man-pages/man2/set_thread_area.2:20
msgid "I<Note>: There is no glibc wrapper for this system call; see NOTES."
msgstr "I<Замечание>:В glibc нет обёрточной функции для данного системного вызова; смотрите ЗАМЕЧАНИЯ."

#. type: Plain text
#: man-pages/man2/set_thread_area.2:33
msgid ""
"B<set_thread_area>()  sets an entry in the current thread's thread-local "
"storage (TLS) array.  The TLS array entry set by B<set_thread_area>()  "
"corresponds to the value of I<u_info-E<gt>entry_number> passed in by the "
"user.  If this value is in bounds, B<set_thread_area>()  copies the TLS "
"descriptor pointed to by I<u_info> into the thread's TLS array."
msgstr "B<set_thread_area>() устанавливает элемент в массиве области локального хранилища текущей нити (TLS, Thread Local Storage). Индекс элемента массива TLS, устанавливаемого B<set_thread_area>(), соответствует значению I<u_info-E<gt>entry_number>, переданного пользователем. Если это значение находится в допустимых пределах, то B<set_thread_area>() копирует соответствующий описатель, на который указывает I<u_info>, в массив TLS нити."

#. type: Plain text
#: man-pages/man2/set_thread_area.2:44
msgid ""
"When B<set_thread_area>()  is passed an I<entry_number> of -1, it uses a "
"free TLS entry.  If B<set_thread_area>()  finds a free TLS entry, the value "
"of I<u_info-E<gt>entry_number> is set upon return to show which entry was "
"changed."
msgstr "Когда B<set_thread_area>() передаётся I<entry_number> со значением -1, то используется свободный элемент TLS. Если B<set_thread_area>() находит свободный элемент TLS, то значение I<u_info-E<gt>entry_number> устанавливается после возврата для показа того, какой же элемент был изменён."

#. type: Plain text
#: man-pages/man2/set_thread_area.2:49
msgid ""
"B<set_thread_area>()  returns 0 on success, and -1 on failure, with I<errno>"
" set appropriately."
msgstr "При нормальном завершении работы B<set_thread_area>() возвращает 0 и -1 в случае проблем, а также присваивает I<errno> соответствующее значение."

#. type: SH
#: man-pages/man2/set_thread_area.2:49
#, no-wrap
msgid "ERRORS"
msgstr "ОШИБКИ"

#. type: Plain text
#: man-pages/man2/set_thread_area.2:53
msgid "I<u_info-E<gt>entry_number> is out of bounds."
msgstr "I<u_info-E<gt>entry_number> вне допустимых границ."

#. type: Plain text
#: man-pages/man2/set_thread_area.2:56
msgid "I<u_info> is an invalid pointer."
msgstr "I<u_info> является некорректным указателем."

#. type: TP
#: man-pages/man2/set_thread_area.2:56
#, no-wrap
msgid "B<ESRCH>"
msgstr "B<ESRCH>"

#. type: Plain text
#: man-pages/man2/set_thread_area.2:59
msgid "A free TLS entry could not be located."
msgstr "Невозможно найти свободный элемент TLS."

#. type: Plain text
#: man-pages/man2/set_thread_area.2:63
msgid "A version of B<set_thread_area>()  first appeared in Linux 2.5.29."
msgstr "Вызов B<set_thread_area>() впервые появился в Linux 2.5.29."

#. type: Plain text
#: man-pages/man2/set_thread_area.2:67
msgid ""
"B<set_thread_area>()  is Linux-specific and should not be used in programs "
"that are intended to be portable."
msgstr "B<set_thread_area>() есть только в Linux, и он не должен использоваться в переносимых программах."

#. type: Plain text
#: man-pages/man2/set_thread_area.2:72
msgid ""
"Glibc does not provide a wrapper for this system call, since it is generally"
" intended only for use by threading libraries.  In the unlikely event that "
"you want to call it directly, use B<syscall>(2)."
msgstr "В glibc нет обёрточной функции для этого системного вызова, так как он предназначен только для использования в библиотеках нитей. Если вам всё-таки нужно его вызвать, используйте B<syscall>(2)."

#. type: Plain text
#: man-pages/man2/set_thread_area.2:73
msgid "B<get_thread_area>(2)"
msgstr "B<get_thread_area>(2)"

#. type: TH
#: man-pages/man2/shutdown.2:40
#, no-wrap
msgid "SHUTDOWN"
msgstr "SHUTDOWN"

#. type: TH
#: man-pages/man2/shutdown.2:40
#, no-wrap
msgid "2012-09-06"
msgstr "2012-09-06"

#. type: Plain text
#: man-pages/man2/shutdown.2:43
msgid "shutdown - shut down part of a full-duplex connection"
msgstr "shutdown - закрывает часть полнодуплексного соединения"

#. type: Plain text
#: man-pages/man2/shutdown.2:47
msgid "B<int shutdown(int >I<sockfd>B<, int >I<how>B<);>"
msgstr "B<int shutdown(int >I<sockfd>B<, int >I<how>B<);>"

#. type: Plain text
#: man-pages/man2/shutdown.2:69
msgid ""
"The B<shutdown>()  call causes all or part of a full-duplex connection on "
"the socket associated with I<sockfd> to be shut down.  If I<how> is "
"B<SHUT_RD>, further receptions will be disallowed.  If I<how> is B<SHUT_WR>,"
" further transmissions will be disallowed.  If I<how> is B<SHUT_RDWR>, "
"further receptions and transmissions will be disallowed."
msgstr "Вызов B<shutdown>() приводит к закрытию всего полнодуплексного соединения или его части в сокете, связанном с I<sockfd>. Если значение I<how> равно B<SHUT_RD>, то дальнейший приём данных будет запрещён. Если значение I<how> равно B<SHUT_WR>, то дальнейшая передача данных будет запрещена. Если значение I<how> равно B<SHUT_RDWR>, то дальнейший приём и передача данных будут запрещены."

#. type: Plain text
#: man-pages/man2/shutdown.2:74
msgid ""
"On success, zero is returned.  On error, -1 is returned, and I<errno> is set"
" appropriately."
msgstr "При успешном выполнении возвращается 0. В случае ошибки возвращается -1, а I<errno> устанавливается в соответствующее значение."

#. type: TP
#: man-pages/man2/shutdown.2:75
#, no-wrap
msgid "B<EBADF>"
msgstr "B<EBADF>"

#. type: Plain text
#: man-pages/man2/shutdown.2:79
msgid "I<sockfd> is not a valid descriptor."
msgstr "I<sockfd> не является правильным дескриптором."

#. type: Plain text
#: man-pages/man2/shutdown.2:84
msgid "An invalid value was specified in I<how> (but see BUGS)."
msgstr "Указано неверное значение в I<how> (но смотрите ДЕФЕКТЫ)."

#. type: TP
#: man-pages/man2/shutdown.2:84
#, no-wrap
msgid "B<ENOTCONN>"
msgstr "B<ENOTCONN>"

#. type: Plain text
#: man-pages/man2/shutdown.2:87
msgid "The specified socket is not connected."
msgstr "Указанный сокет не подключён."

#. type: TP
#: man-pages/man2/shutdown.2:87
#, no-wrap
msgid "B<ENOTSOCK>"
msgstr "B<ENOTSOCK>"

#. type: Plain text
#: man-pages/man2/shutdown.2:91
msgid "I<sockfd> is a file, not a socket."
msgstr "Значение I<sockfd> является файлом, а не сокетом."

#. type: Plain text
#: man-pages/man2/shutdown.2:95
msgid ""
"POSIX.1-2001, 4.4BSD (the B<shutdown>()  function call first appeared in "
"4.2BSD)."
msgstr "POSIX.1-2001, 4.4BSD (системный вызов B<shutdown>() впервые появился в 4.2BSD)."

#. type: Plain text
#: man-pages/man2/shutdown.2:104
msgid ""
"The constants B<SHUT_RD>, B<SHUT_WR>, B<SHUT_RDWR> have the value 0, 1, 2, "
"respectively, and are defined in I<E<lt>sys/socket.hE<gt>> since "
"glibc-2.1.91."
msgstr "Константы B<SHUT_RD>, B<SHUT_WR>, B<SHUT_RDWR> имеют значения 0, 1, 2, соответственно, и определены в I<E<lt>sys/socket.hE<gt>> начиная с glibc-2.1.91."

#.  FIXME
#.  https://bugzilla.kernel.org/show_bug.cgi?id=47111
#. type: Plain text
#: man-pages/man2/shutdown.2:113
msgid ""
"As currently implemented, checks for the validity of I<how> are done in "
"domain-specific code, and not all domains perform these checks.  Most "
"notably, UNIX domain sockets simply ignore invalid values; this may change "
"in the future."
msgstr "В имеющейся реализации, проверки на корректность I<how> выполняются в коде определённого домена, но не все домены выполняют эти проверки. В частности, в доменных сокетах UNIX неправильные значения просто игнорируются; в будущем это может измениться."

#. type: Plain text
#: man-pages/man2/shutdown.2:116
msgid "B<connect>(2), B<socket>(2), B<socket>(7)"
msgstr "B<connect>(2), B<socket>(2), B<socket>(7)"

#. type: TH
#: man-pages/man2/shmctl.2:45
#, no-wrap
msgid "SHMCTL"
msgstr "SHMCTL"

#. type: TH
#: man-pages/man2/shmctl.2:45
#, no-wrap
msgid "2014-02-07"
msgstr "2014-02-07"

#. type: Plain text
#: man-pages/man2/shmctl.2:48
msgid "shmctl - System V shared memory control"
msgstr "shmctl - управление общей памятью System V"

#. type: Plain text
#: man-pages/man2/shmctl.2:51
msgid "B<#include E<lt>sys/ipc.hE<gt>>"
msgstr "B<#include E<lt>sys/ipc.hE<gt>>"

#. type: Plain text
#: man-pages/man2/shmctl.2:53
msgid "B<#include E<lt>sys/shm.hE<gt>>"
msgstr "B<#include E<lt>sys/shm.hE<gt>>"

#. type: Plain text
#: man-pages/man2/shmctl.2:55
msgid ""
"B<int shmctl(int >I<shmid>B<, int >I<cmd>B<, struct shmid_ds *>I<buf>B<);>"
msgstr "B<int shmctl(int >I<shmid>B<, int >I<cmd>B<, struct shmid_ds *>I<buf>B<);>"

#. type: Plain text
#: man-pages/man2/shmctl.2:62
msgid ""
"B<shmctl>()  performs the control operation specified by I<cmd> on the "
"System\\ V shared memory segment whose identifier is given in I<shmid>."
msgstr "Вызов B<shmctl>() выполняет управляющую операцию, указанную в I<cmd>, над общим сегментом памяти System\\ V, чей идентификатор задан в I<shmid>."

#. type: Plain text
#: man-pages/man2/shmctl.2:67
msgid ""
"The I<buf> argument is a pointer to a I<shmid_ds> structure, defined in "
"I<E<lt>sys/shm.hE<gt>> as follows:"
msgstr "В аргументе I<buf> содержится указатель на структуру I<shmid_ds>, определённую в I<E<lt>sys/shm.hE<gt>> следующим образом:"

#. type: Plain text
#: man-pages/man2/shmctl.2:81
#, no-wrap
msgid ""
"struct shmid_ds {\n"
"    struct ipc_perm shm_perm;    /* Ownership and permissions */\n"
"    size_t          shm_segsz;   /* Size of segment (bytes) */\n"
"    time_t          shm_atime;   /* Last attach time */\n"
"    time_t          shm_dtime;   /* Last detach time */\n"
"    time_t          shm_ctime;   /* Last change time */\n"
"    pid_t           shm_cpid;    /* PID of creator */\n"
"    pid_t           shm_lpid;    /* PID of last shmat(2)/shmdt(2) */\n"
"    shmatt_t        shm_nattch;  /* No. of current attaches */\n"
"    ...\n"
"};\n"
msgstr "struct shmid_ds {\n    struct ipc_perm shm_perm;    /* владелец и права */\n    size_t          shm_segsz;   /* размер сегмента (байты) */\n    time_t          shm_atime;   /* время последнего подключения */\n    time_t          shm_dtime;   /* время последнего отключения */\n    time_t          shm_ctime;   /* время последнего изменения */\n    pid_t           shm_cpid;    /* PID создателя */\n    pid_t           shm_lpid;    /* PID последнего выполнявшего \n                                    shmat(2)/shmdt(2) */\n    shmatt_t        shm_nattch;  /* текущее количество подключений */\n    ...\n};\n"

#. type: Plain text
#: man-pages/man2/shmctl.2:89
msgid ""
"The I<ipc_perm> structure is defined as follows (the highlighted fields are "
"settable using B<IPC_SET>):"
msgstr "Структура I<ipc_perm> определена следующим образом (значения полей устанавливаются с помощью B<IPC_SET>):"

#. type: Plain text
#: man-pages/man2/shmctl.2:102
#, no-wrap
msgid ""
"struct ipc_perm {\n"
"    key_t          __key;    /* Key supplied to shmget(2) */\n"
"    uid_t          B<uid>;      /* Effective UID of owner */\n"
"    gid_t          B<gid>;      /* Effective GID of owner */\n"
"    uid_t          cuid;     /* Effective UID of creator */\n"
"    gid_t          cgid;     /* Effective GID of creator */\n"
"    unsigned short B<mode>;     /* B<Permissions> + SHM_DEST and\n"
"                                SHM_LOCKED flags */\n"
"    unsigned short __seq;    /* Sequence number */\n"
"};\n"
msgstr "struct ipc_perm {\n    key_t          __key;    /* ключ, передаваемый в shmget(2) */\n    uid_t          B<uid>;      /* эффективный UID владельца */\n    gid_t          B<gid>;      /* эффективный GID владельца */\n    uid_t          cuid;     /* эффективный UID создателя */\n    gid_t          cgid;     /* эффективный GID создателя */\n    unsigned short B<mode>;     /* B<права> + флаги SHM_DEST и\n                                SHM_LOCKED */\n    unsigned short __seq;    /* порядковый номер */\n};\n"

#. type: Plain text
#: man-pages/man2/shmctl.2:108
msgid "Valid values for I<cmd> are:"
msgstr "Возможные значения I<cmd>:"

#. type: Plain text
#: man-pages/man2/shmctl.2:118
msgid ""
"Copy information from the kernel data structure associated with I<shmid> "
"into the I<shmid_ds> structure pointed to by I<buf>.  The caller must have "
"read permission on the shared memory segment."
msgstr "Копирует информацию из структуры данных ядра, связанной с I<shmid>, в структуру I<shsid_ds>, расположенную по адресу I<buf>. Вызывающий должен иметь права на чтение общего сегмента памяти."

#. type: Plain text
#: man-pages/man2/shmctl.2:136
msgid ""
"Write the values of some members of the I<shmid_ds> structure pointed to by "
"I<buf> to the kernel data structure associated with this shared memory "
"segment, updating also its I<shm_ctime> member.  The following fields can be"
" changed: I<shm_perm.uid>, I<shm_perm.gid>, and (the least significant 9 "
"bits of) I<shm_perm.mode>.  The effective UID of the calling process must "
"match the owner (I<shm_perm.uid>)  or creator (I<shm_perm.cuid>)  of the "
"shared memory segment, or the caller must be privileged."
msgstr "Записывает значения некоторых полей структуры I<shmid_ds>, указанной в I<buf>, в структуру данных ядра, связанную с общим сегментом памяти, обновляя при этом поле I<shm_ctime>. Могут измениться следующие поля: I<shm_perm.uid>, I<shm_perm.gid> и I<shm_perm.mode> (младшие 9 битов). Эффективный UID вызывающего процесса должен совпадать с UID владельца (I<shm_perm.uid>) или создателя (I<shm_perm.cuid>) общего сегмента памяти, или вызывающий должен иметь привилегии."

#. type: Plain text
#: man-pages/man2/shmctl.2:149
msgid ""
"Mark the segment to be destroyed.  The segment will only actually be "
"destroyed after the last process detaches it (i.e., when the I<shm_nattch> "
"member of the associated structure I<shmid_ds> is zero).  The caller must be"
" the owner or creator of the segment, or be privileged.  The I<buf> argument"
" is ignored."
msgstr "Помечает сегмент как удалённый. Сегмент будет удалён только после того как от него отключится последний процесс (т.е. когда поле I<shm_nattch> из связанной структуры I<shmid_ds> станет равно нулю). Вызывающий должен быть владельцем, создателем или иметь соответствующие привилегии. Аргумент I<buf> игнорируется."

#. type: Plain text
#: man-pages/man2/shmctl.2:157
msgid ""
"If a segment has been marked for destruction, then the (nonstandard)  "
"B<SHM_DEST> flag of the I<shm_perm.mode> field in the associated data "
"structure retrieved by B<IPC_STAT> will be set."
msgstr "Если сегмент помечен на удаление, то в поле I<shm_perm.mode> устанавливается (нестандартный) флаг B<SHM_DEST> в связанной структуре данных, которая возвращается при операции B<IPC_STAT>."

#. type: Plain text
#: man-pages/man2/shmctl.2:160
msgid ""
"The caller I<must> ensure that a segment is eventually destroyed; otherwise "
"its pages that were faulted in will remain in memory or swap."
msgstr "Вызывающий I<должен> удостовериться, что сегмент в конечном итоге удалён; иначе ошибочные страницы останутся в памяти или в пространстве подкачки."

#. type: Plain text
#: man-pages/man2/shmctl.2:165
msgid ""
"See also the description of I</proc/sys/kernel/shm_rmid_forced> in "
"B<proc>(5)."
msgstr "Смотрите также описание I</proc/sys/kernel/shm_rmid_forced> в B<proc>(5)."

#. type: TP
#: man-pages/man2/shmctl.2:165
#, no-wrap
msgid "B<IPC_INFO> (Linux-specific)"
msgstr "B<IPC_INFO> (есть только в Linux)"

#. type: Plain text
#: man-pages/man2/shmctl.2:178
msgid ""
"Return information about system-wide shared memory limits and parameters in "
"the structure pointed to by I<buf>.  This structure is of type I<shminfo> "
"(thus, a cast is required), defined in I<E<lt>sys/shm.hE<gt>> if the "
"B<_GNU_SOURCE> feature test macro is defined:"
msgstr "Возвращает параметры и информацию о системных максимальных значениях общей памяти в структуре, указанной в I<buf>. Данная структура имеет тип I<shminfo> (то есть, требуется приведение типов) и определена в I<E<lt>sys/shm.hE<gt>>, если определён макрос тестирования свойств B<_GNU_SOURCE>:"

#. type: Plain text
#: man-pages/man2/shmctl.2:192
#, no-wrap
msgid ""
"struct shminfo {\n"
"    unsigned long shmmax; /* Maximum segment size */\n"
"    unsigned long shmmin; /* Minimum segment size;\n"
"                             always 1 */\n"
"    unsigned long shmmni; /* Maximum number of segments */\n"
"    unsigned long shmseg; /* Maximum number of segments\n"
"                             that a process can attach;\n"
"                             unused within kernel */\n"
"    unsigned long shmall; /* Maximum number of pages of\n"
"                             shared memory, system-wide */\n"
"};\n"
msgstr "struct shminfo {\n    unsigned long shmmax; /* максимальный размер\n                             сегмента */\n    unsigned long shmmin; /* минимальный размер сегмента;\n                             всегда 1 */\n    unsigned long shmmni; /* максимальное количество\n                             сегментов */\n    unsigned long shmseg; /* максимальное количество\n                             сегментов, к которому может\n                             подключиться; процесс\n                             не используется в ядре */\n    unsigned long shmall; /* макс. количество страниц\n                             общей памяти в системе */\n};\n"

#. type: Plain text
#: man-pages/man2/shmctl.2:205
msgid ""
"The I<shmmni>, I<shmmax>, and I<shmall> settings can be changed via I</proc>"
" files of the same name; see B<proc>(5)  for details."
msgstr "Значения I<shmmni>, I<shmmax> и I<shmall> можно изменить с помощью файлов в I</proc> с теми же именами; подробней см. B<proc>(5)."

#. type: TP
#: man-pages/man2/shmctl.2:205
#, no-wrap
msgid "B<SHM_INFO> (Linux-specific)"
msgstr "B<SHM_INFO> (есть только в Linux)"

#. type: Plain text
#: man-pages/man2/shmctl.2:216
msgid ""
"Return a I<shm_info> structure whose fields contain information about system"
" resources consumed by shared memory.  This structure is defined in "
"I<E<lt>sys/shm.hE<gt>> if the B<_GNU_SOURCE> feature test macro is defined:"
msgstr "Возвращает структуру I<shm_info>, чьи поля содержат информацию о системных ресурсах, использованных общей памятью. Эта структура определена в I<E<lt>sys/shm.hE<gt>>, если определён макрос тестирования свойств B<_GNU_SOURCE>:"

#. type: Plain text
#: man-pages/man2/shmctl.2:233
#, no-wrap
msgid ""
"struct shm_info {\n"
"    int           used_ids; /* # of currently existing\n"
"                               segments */\n"
"    unsigned long shm_tot;  /* Total number of shared\n"
"                               memory pages */\n"
"    unsigned long shm_rss;  /* # of resident shared\n"
"                               memory pages */\n"
"    unsigned long shm_swp;  /* # of swapped shared\n"
"                               memory pages */\n"
"    unsigned long swap_attempts;\n"
"                            /* Unused since Linux 2.4 */\n"
"    unsigned long swap_successes;\n"
"                            /* Unused since Linux 2.4 */\n"
"};\n"
msgstr "struct shm_info {\n    int           used_ids; /* количество используемых в\n                               данный момент сегментов */\n    unsigned long shm_tot;  /* общее количество общих\n                               страниц памяти */\n    unsigned long shm_rss;  /* количество общих страниц, \n                               находящихся в памяти */\n    unsigned long shm_swp;  /* количество страниц памяти в \n                               пространстве подкачки */\n    unsigned long swap_attempts; /* не используется,\n                                    начиная с Linux 2.4 */\n    unsigned long swap_successes; /* не используется,\n                                     начиная с Linux 2.4 */\n};\n"

#. type: TP
#: man-pages/man2/shmctl.2:235
#, no-wrap
msgid "B<SHM_STAT> (Linux-specific)"
msgstr "B<SHM_STAT> (есть только в Linux)"

#. type: Plain text
#: man-pages/man2/shmctl.2:246
msgid ""
"Return a I<shmid_ds> structure as for B<IPC_STAT>.  However, the I<shmid> "
"argument is not a segment identifier, but instead an index into the kernel's"
" internal array that maintains information about all shared memory segments "
"on the system."
msgstr "Возвращает структуру I<shmid_ds> как в операции B<IPC_STAT>. Однако аргумент I<shmid> является не идентификатором сегмента, а индексом во внутреннем массиве ядра, в котором содержится информации о всех общих сегментов памяти в системе."

#. type: Plain text
#: man-pages/man2/shmctl.2:249
msgid ""
"The caller can prevent or allow swapping of a shared memory segment with the"
" following I<cmd> values:"
msgstr "Вызывающий может запретить или разрешить размещение общего сегмента памяти в пространство подкачки с помощью следующих значений I<cmd>:"

#. type: TP
#: man-pages/man2/shmctl.2:250
#, no-wrap
msgid "B<SHM_LOCK> (Linux-specific)"
msgstr "B<SHM_LOCK> (есть только в Linux)"

#. type: Plain text
#: man-pages/man2/shmctl.2:262
msgid ""
"Prevent swapping of the shared memory segment.  The caller must fault in any"
" pages that are required to be present after locking is enabled.  If a "
"segment has been locked, then the (nonstandard)  B<SHM_LOCKED> flag of the "
"I<shm_perm.mode> field in the associated data structure retrieved by "
"B<IPC_STAT> will be set."
msgstr "Запрещает подкачку общего сегмента памяти. После включения блокировки вызывающий должен считать сбойными все страницы, наличие которых требуется. Если сегмент заблокирован, то в поле I<shm_perm.mode> устанавливается (нестандартный) флаг B<SHM_LOCKED> в связанной структуре, которая возвращается при операции B<IPC_STAT>."

#. type: TP
#: man-pages/man2/shmctl.2:262
#, no-wrap
msgid "B<SHM_UNLOCK> (Linux-specific)"
msgstr "B<SHM_UNLOCK> (есть только в Linux)"

#. type: Plain text
#: man-pages/man2/shmctl.2:265
msgid "Unlock the segment, allowing it to be swapped out."
msgstr "Разблокирует сегмент, разрешая выполнение подкачки."

#.  There was some weirdness in 2.6.9: SHM_LOCK and SHM_UNLOCK could
#.  be applied to a segment, regardless of ownership of the segment.
#.  This was a botch-up in the move to RLIMIT_MEMLOCK, and was fixed
#.  in 2.6.10.  MTK, May 2005
#. type: Plain text
#: man-pages/man2/shmctl.2:283
msgid ""
"In kernels before 2.6.10, only a privileged process could employ B<SHM_LOCK>"
" and B<SHM_UNLOCK>.  Since kernel 2.6.10, an unprivileged process can employ"
" these operations if its effective UID matches the owner or creator UID of "
"the segment, and (for B<SHM_LOCK>)  the amount of memory to be locked falls "
"within the B<RLIMIT_MEMLOCK> resource limit (see B<setrlimit>(2))."
msgstr "В ядрах до версии 2.6.10 только привилегированный процесс мог использовать B<SHM_LOCK> и B<SHM_UNLOCK>. Начиная с ядра версии 2.6.10 непривилегированный процесс может использовать эти операции, если его эффективный UID совпадает с UID владельца или создателя сегмента и (для B<SHM_LOCK>) количество блокируемой памяти находится в пределах ресурса B<RLIMIT_MEMLOCK> (см. B<setrlimit>(2))."

#. type: Plain text
#: man-pages/man2/shmctl.2:301
msgid ""
"A successful B<IPC_INFO> or B<SHM_INFO> operation returns the index of the "
"highest used entry in the kernel's internal array recording information "
"about all shared memory segments.  (This information can be used with "
"repeated B<SHM_STAT> operations to obtain information about all shared "
"memory segments on the system.)  A successful B<SHM_STAT> operation returns "
"the identifier of the shared memory segment whose index was given in "
"I<shmid>.  Other operations return 0 on success."
msgstr "При успешном выполнении операции B<IPC_INFO> или B<SHM_INFO> возвращается индекс самого последнего использованного элемента внутреннего массива ядра, в котором записывается информация о всех общих сегментах памяти (эта информация может быть использована в повторяющихся операциях B<SHM_STAT> для получения информации о всех общих сегментах памяти системы). При успешном выполнении операции B<SHM_STAT> возвращается идентификатор общего сегмента памяти, чей индекс был указан в I<shmid>. При успешном выполнении других операций возвращается 0."

#. type: Plain text
#: man-pages/man2/shmctl.2:305
msgid "On error, -1 is returned, and I<errno> is set appropriately."
msgstr "В случае ошибки возвращается -1 и значение I<errno> устанавливается соответствующим образом."

#. type: Plain text
#: man-pages/man2/shmctl.2:314
msgid ""
"B<IPC_STAT> or B<SHM_STAT> is requested and I<shm_perm.mode> does not allow "
"read access for I<shmid>, and the calling process does not have the "
"B<CAP_IPC_OWNER> capability."
msgstr "Указана операция B<IPC_STAT> или B<SHM_STAT>, но в I<shm_perm.mode> не установлено право на чтение I<shmid>, и вызывающий процесс не имеет мандата B<CAP_IPC_OWNER>."

#. type: Plain text
#: man-pages/man2/shmctl.2:325
msgid ""
"The argument I<cmd> has value B<IPC_SET> or B<IPC_STAT> but the address "
"pointed to by I<buf> isn't accessible."
msgstr "Значение аргумента I<cmd> равно B<IPC_SET> или B<IPC_STAT>, но адрес, указанный в I<buf>, недоступен."

#. type: TP
#: man-pages/man2/shmctl.2:325
#, no-wrap
msgid "B<EIDRM>"
msgstr "B<EIDRM>"

#. type: Plain text
#: man-pages/man2/shmctl.2:328
msgid "I<shmid> points to a removed identifier."
msgstr "Значение I<shmid> указывает на удалённый идентификатор."

#. type: Plain text
#: man-pages/man2/shmctl.2:337
msgid ""
"I<shmid> is not a valid identifier, or I<cmd> is not a valid command.  Or: "
"for a B<SHM_STAT> operation, the index value specified in I<shmid> referred "
"to an array slot that is currently unused."
msgstr "Значение I<shmid> содержит недопустимый идентификатор, или I<cmd> содержит недопустимую команду. Или (для B<SHM_STAT>) индекс I<shmid> ссылается на элемент массива, который в данный момент не используется."

#. type: Plain text
#: man-pages/man2/shmctl.2:348
msgid ""
"(In kernels since 2.6.9), B<SHM_LOCK> was specified and the size of the to-"
"be-locked segment would mean that the total bytes in locked shared memory "
"segments would exceed the limit for the real user ID of the calling process."
"  This limit is defined by the B<RLIMIT_MEMLOCK> soft resource limit (see "
"B<setrlimit>(2))."
msgstr "(в ядрах, начиная с 2.6.9) Указана операция B<SHM_LOCK> и размер блокируемого сегмента таков, что общее количество байт, блокируемое общими сегментами памяти, превысило бы ограничение, установленное для действительного идентификатора пользователя вызывающего процесса. Этот лимит определён мягким ограничителем ресурса B<RLIMIT_MEMLOCK> (см. B<setrlimit>(2))."

#. type: Plain text
#: man-pages/man2/shmctl.2:353
msgid ""
"B<IPC_STAT> is attempted, and the GID or UID value is too large to be stored"
" in the structure pointed to by I<buf>."
msgstr "Попытка выполнить B<IPC_STAT>, но значения GID или UID слишком велики для помещения в структуру, на которую указывает I<buf>."

#. type: TP
#: man-pages/man2/shmctl.2:353
#, no-wrap
msgid "B<EPERM>"
msgstr "B<EPERM>"

#. type: Plain text
#: man-pages/man2/shmctl.2:365
msgid ""
"B<IPC_SET> or B<IPC_RMID> is attempted, and the effective user ID of the "
"calling process is not that of the creator (found in I<shm_perm.cuid>), or "
"the owner (found in I<shm_perm.uid>), and the process was not privileged "
"(Linux: did not have the B<CAP_SYS_ADMIN> capability)."
msgstr "Попытка выполнить B<IPC_SET> или B<IPC_RMID>, но эффективный пользовательский идентификатор вызывающего процесса не равен идентификатору создателя (I<shm_perm.cuid>) или владельца (I<shm_perm.uid>) и процесс не привилегированный (Linux: не имеет мандата B<CAP_SYS_ADMIN>)."

#. type: Plain text
#: man-pages/man2/shmctl.2:377
msgid ""
"Or (in kernels before 2.6.9), B<SHM_LOCK> or B<SHM_UNLOCK> was specified, "
"but the process was not privileged (Linux: did not have the B<CAP_IPC_LOCK> "
"capability).  (Since Linux 2.6.9, this error can also occur if the "
"B<RLIMIT_MEMLOCK> is 0 and the caller is not privileged.)"
msgstr "Или (в ядрах до 2.6.9) процесс не имеет привилегий (Linux: не имеет мандата B<CAP_IPC_LOCK>) для выполнения B<SHM_LOCK> или B<SHM_UNLOCK>. Начиная с Linux 2.6.9 эта ошибка также возникает, если значение B<RLIMIT_MEMLOCK> равно 0 и вызывающий не имеет привилегий."

#.  SVr4 documents additional error conditions EINVAL,
#.  ENOENT, ENOSPC, ENOMEM, EEXIST.  Neither SVr4 nor SVID documents
#.  an EIDRM error condition.
#. type: Plain text
#: man-pages/man2/shmctl.2:382
msgid "SVr4, POSIX.1-2001."
msgstr "SVr4, POSIX.1-2001."

#.  Like Linux, the FreeBSD man pages still document
#.  the inclusion of these header files.
#. type: Plain text
#: man-pages/man2/shmctl.2:395
msgid ""
"The inclusion of I<E<lt>sys/types.hE<gt>> and I<E<lt>sys/ipc.hE<gt>> isn't "
"required on Linux or by any version of POSIX.  However, some old "
"implementations required the inclusion of these header files, and the SVID "
"also documented their inclusion.  Applications intended to be portable to "
"such old systems may need to include these header files."
msgstr "Включение файлов I<E<lt>sys/types.hE<gt>> и I<E<lt>sys/ipc.hE<gt>> не требуется в Linux или любых версий POSIX. Однако, некоторые старые реализации требуют включения данных заголовочных файлов, и это также требуется по SVID. В приложениях, которые нужно перенести на такие старые системы, может потребоваться включить данных заголовочные файлы."

#. type: Plain text
#: man-pages/man2/shmctl.2:407
msgid ""
"The B<IPC_INFO>, B<SHM_STAT> and B<SHM_INFO> operations are used by the "
"B<ipcs>(1)  program to provide information on allocated resources.  In the "
"future, these may modified or moved to a I</proc> filesystem interface."
msgstr "Операции B<IPC_INFO>, B<SHM_STAT> и B<SHM_INFO> используются программой B<ipcs>(1) для получения информации о выделенных ресурсах. В будущем для этого может быть задействован интерфейс файловой системы I</proc>."

#. type: Plain text
#: man-pages/man2/shmctl.2:415
msgid ""
"Linux permits a process to attach (B<shmat>(2))  a shared memory segment "
"that has already been marked for deletion using I<shmctl(IPC_RMID)>.  This "
"feature is not available on other UNIX implementations; portable "
"applications should avoid relying on it."
msgstr "Linux разрешает процессу подключаться (B<shmat>(2)) к общему сегменту память, который уже помечен как удалённый с помощью I<shmctl(IPC_RMID)>. Это свойство недоступно в других реализациях UNIX; в переносимых приложениях лучше не использовать это свойство."

#. type: Plain text
#: man-pages/man2/shmctl.2:428
msgid ""
"Various fields in a I<struct shmid_ds> were typed as I<short> under Linux "
"2.2 and have become I<long> under Linux 2.4.  To take advantage of this, a "
"recompilation under glibc-2.1.91 or later should suffice.  (The kernel "
"distinguishes old and new calls by an B<IPC_64> flag in I<cmd>.)"
msgstr "В Linux 2.2 различные поля I<struct shmid_ds> имели тип I<short>. В Linux 2.4 тип был изменён на I<long>. Для задействования преимуществ этого изменения необходима перекомпиляция программы с glibc-2.1.91 или более поздней версией (ядро различает старые и новые вызовы по флагу B<IPC_64> в аргументе I<cmd>)."

#. type: Plain text
#: man-pages/man2/shmctl.2:434
msgid ""
"B<mlock>(2), B<setrlimit>(2), B<shmget>(2), B<shmop>(2), B<capabilities>(7),"
" B<svipc>(7)"
msgstr "B<mlock>(2), B<setrlimit>(2), B<shmget>(2), B<shmop>(2), B<capabilities>(7), B<svipc>(7)"

#. type: TH
#: man-pages/man2/sched_setscheduler.2:26
#, no-wrap
msgid "SCHED_SETSCHEDULER"
msgstr "SCHED_SETSCHEDULER"

#. type: TH
#: man-pages/man2/sched_setscheduler.2:26
#, no-wrap
msgid "2014-05-21"
msgstr "2014-05-21"

#. type: Plain text
#: man-pages/man2/sched_setscheduler.2:30
msgid ""
"sched_setscheduler, sched_getscheduler - set and get scheduling "
"policy/parameters"
msgstr "sched_setscheduler, sched_getscheduler - устанавливает или получает алгоритм планирования (и его параметры)"

#. type: Plain text
#: man-pages/man2/sched_setscheduler.2:33
#, no-wrap
msgid "B<#include E<lt>sched.hE<gt>>\n"
msgstr "B<#include E<lt>sched.hE<gt>>\n"

#. type: Plain text
#: man-pages/man2/sched_setscheduler.2:35
#, no-wrap
msgid "B<int sched_setscheduler(pid_t >I<pid>B<, int >I<policy>B<,>\n"
msgstr "B<int sched_setscheduler(pid_t >I<pid>B<, int >I<policy>B<,>\n"

#. type: Plain text
#: man-pages/man2/sched_setscheduler.2:37
#, no-wrap
msgid "B<                       const struct sched_param *>I<param>B<);>\n"
msgstr "B<                       const struct sched_param *>I<param>B<);>\n"

#. type: Plain text
#: man-pages/man2/sched_setscheduler.2:39
#, no-wrap
msgid "B<int sched_getscheduler(pid_t >I<pid>B<);>\n"
msgstr "B<int sched_getscheduler(pid_t >I<pid>B<);>\n"

#. type: Plain text
#: man-pages/man2/sched_setscheduler.2:49
msgid ""
"The B<sched_setscheduler>()  system call sets both the scheduling policy and"
" parameters for the thread whose ID is specified in I<pid>.  If I<pid> "
"equals zero, the scheduling policy and parameters of the calling thread will"
" be set."
msgstr "Вызов B<sched_setscheduler>() задаёт алгоритм и параметры планирования выполнения нити с идентификатором I<pid>. Если I<pid> равен нулю, то будет изменён алгоритм и параметры планирования вызывающей нити."

#. type: Plain text
#: man-pages/man2/sched_setscheduler.2:53
msgid ""
"The scheduling parameters are specified in the I<param> argument, which is a"
" pointer to a structure of the following form:"
msgstr "Параметры планирования указываются в аргументе I<param>, который является указателем на следующую структуру:"

#. type: Plain text
#: man-pages/man2/sched_setscheduler.2:61
#, no-wrap
msgid ""
"struct sched_param {\n"
"    ...\n"
"    int sched_priority;\n"
"    ...\n"
"};\n"
msgstr "struct sched_param {\n    ...\n    int sched_priority;\n    ...\n};\n"

#. type: Plain text
#: man-pages/man2/sched_setscheduler.2:69
msgid ""
"In the current implementation, the structure contains only one field, "
"I<sched_priority>.  The interpretation of I<param> depends on the selected "
"policy."
msgstr "В текущей реализации структура содержит только одно поле — I<sched_priority>. Интерпретация I<param> зависит от выбранного алгоритма."

#. type: Plain text
#: man-pages/man2/sched_setscheduler.2:73
msgid ""
"Currently, Linux supports the following \"normal\" (i.e., non-real-time) "
"scheduling policies as values that may be specified in I<policy>:"
msgstr "В настоящее время в Linux поддерживаются следующие «обычные» (т. е. не реального времени) алгоритмы планирования, которые можно указать в I<policy>:"

#. type: TP
#: man-pages/man2/sched_setscheduler.2:73
#, no-wrap
msgid "B<SCHED_OTHER>"
msgstr "B<SCHED_OTHER>"

#.  In the 2.6 kernel sources, SCHED_OTHER is actually called
#.  SCHED_NORMAL.
#. type: Plain text
#: man-pages/man2/sched_setscheduler.2:78
msgid "the standard round-robin time-sharing policy;"
msgstr "алгоритм циклического обслуживания с разделением времени;"

#. type: TP
#: man-pages/man2/sched_setscheduler.2:78
#, no-wrap
msgid "B<SCHED_BATCH>"
msgstr "B<SCHED_BATCH>"

#. type: Plain text
#: man-pages/man2/sched_setscheduler.2:81
msgid "for \"batch\" style execution of processes; and"
msgstr "«пакетный» стиль выполнения процессов;"

#. type: TP
#: man-pages/man2/sched_setscheduler.2:81
#, no-wrap
msgid "B<SCHED_IDLE>"
msgstr "B<SCHED_IDLE>"

#. type: Plain text
#: man-pages/man2/sched_setscheduler.2:86
msgid "for running I<very> low priority background jobs."
msgstr "для выполнения фоновых заданий с I<очень> низким приоритетом."

#. type: Plain text
#: man-pages/man2/sched_setscheduler.2:90
msgid ""
"For each of the above policies, I<param-E<gt>sched_priority> must be 0."
msgstr "Для каждого алгоритма, перечисленного выше, значение I<param-E<gt>sched_priority> должно быть равно 0."

#. type: Plain text
#: man-pages/man2/sched_setscheduler.2:99
msgid ""
"Various \"real-time\" policies are also supported, for special time-critical"
" applications that need precise control over the way in which runnable "
"threads are selected for execution.  For the rules governing when a process "
"may use these policies, see B<sched>(7).  The real-time policies that may be"
" specified in I<policy> are:"
msgstr "Также поддерживаются различные алгоритмы «реального времени», для специальных, критичных ко времени приложений, которым требуется точное управление методом выбора приложением исполняемых нитей. Правила управления, когда процесс может использовать эти алгоритмы, смотрите в B<sched>(7). Алгоритмы реального времени, которые могут быть указаны в I<policy>:"

#. type: TP
#: man-pages/man2/sched_setscheduler.2:99
#, no-wrap
msgid "B<SCHED_FIFO>"
msgstr "B<SCHED_FIFO>"

#. type: Plain text
#: man-pages/man2/sched_setscheduler.2:102
msgid "a first-in, first-out policy; and"
msgstr "алгоритм «первым вошёл — первым вышел»;"

#. type: TP
#: man-pages/man2/sched_setscheduler.2:102
#, no-wrap
msgid "B<SCHED_RR>"
msgstr "B<SCHED_RR>"

#. type: Plain text
#: man-pages/man2/sched_setscheduler.2:105
msgid "a round-robin policy."
msgstr "алгоритм циклического обслуживания."

#. type: Plain text
#: man-pages/man2/sched_setscheduler.2:116
msgid ""
"For each of the above policies, I<param-E<gt>sched_priority> specifies a "
"scheduling priority for the thread.  This is a number in the range returned "
"by calling B<sched_get_priority_min>(2)  and B<sched_get_priority_min>(2)  "
"with the specified I<policy>.  On Linux, these system calls return, "
"respectively, 1 and 99."
msgstr "Для каждого перечисленного выше алгоритма в I<param-E<gt>sched_priority> задаётся приоритет планирования для нити. Это число в диапазоне, возвращаемом вызовами B<sched_get_priority_min>(2) и B<sched_get_priority_min>(2) с указанным I<policy>. В Linux эти системные вызовы возвращают 1 и 99, соответственно."

#. type: Plain text
#: man-pages/man2/sched_setscheduler.2:129
msgid ""
"Since Linux 2.6.32, the B<SCHED_RESET_ON_FORK> flag can be ORed in I<policy>"
" when calling B<sched_setscheduler>().  As a result of including this flag, "
"children created by B<fork>(2)  do not inherit privileged scheduling "
"policies.  See B<sched>(7)  for details."
msgstr "Начиная с Linux 2.6.32, флаг B<SCHED_RESET_ON_FORK> может быть добавлен (OR) в I<policy> при вызове B<sched_setscheduler>(). В результате включения этого флага потомок, созданный B<fork>(2), не наследует алгоритмы привилегированные алгоритмы планирования. Подробней смотрите в B<sched>(7)."

#. type: Plain text
#: man-pages/man2/sched_setscheduler.2:135
msgid ""
"B<sched_getscheduler>()  returns the current scheduling policy of the thread"
" identified by I<pid>.  If I<pid> equals zero, the policy of the calling "
"thread will be retrieved."
msgstr "Вызов B<sched_getscheduler>() возвращает текущий алгоритм планирования нити с идентификатором I<pid>. Если значение I<pid> равно нулю, то будет выдан алгоритм вызывающей нити."

#. type: Plain text
#: man-pages/man2/sched_setscheduler.2:145
msgid ""
"On success, B<sched_setscheduler>()  returns zero.  On success, "
"B<sched_getscheduler>()  returns the policy for the thread (a nonnegative "
"integer).  On error, both calls return -1, and I<errno> is set "
"appropriately."
msgstr "При успешном выполнении B<sched_setscheduler>()  возвращается ноль. При успешном выполнении B<sched_getscheduler>()  возвращается алгоритм нити (неотрицательное целое). При ошибках оба вызова возвращают -1, а переменной I<errno> присваивается соответствующее значение."

#. type: Plain text
#: man-pages/man2/sched_setscheduler.2:153
msgid "Invalid arguments: I<pid> is negative or I<param> is NULL."
msgstr "Некорректные аргументы: значение I<pid> отрицательно или I<param> равно NULL."

#. type: Plain text
#: man-pages/man2/sched_setscheduler.2:158
msgid ""
"(B<sched_setscheduler>())  I<policy> is not one of the recognized policies."
msgstr "(B<sched_setscheduler>()) Значение I<policy> не равно одному из известных значений алгоритмов."

#. type: Plain text
#: man-pages/man2/sched_setscheduler.2:164
msgid ""
"(B<sched_setscheduler>())  I<param> does not make sense for the specified "
"I<policy>."
msgstr "(B<sched_setscheduler>()) Значение I<param> не имеет смысла для заданного I<policy>."

#. type: Plain text
#: man-pages/man2/sched_setscheduler.2:167
msgid "The calling thread does not have appropriate privileges."
msgstr "Вызывающая нить не имеет достаточно привилегий."

#. type: Plain text
#: man-pages/man2/sched_setscheduler.2:170
msgid "The thread whose ID is I<pid> could not be found."
msgstr "Нить с идентификатором I<pid> не найдена."

#. type: Plain text
#: man-pages/man2/sched_setscheduler.2:173
msgid ""
"POSIX.1-2001 (but see BUGS below).  The B<SCHED_BATCH> and B<SCHED_IDLE> "
"policies are Linux-specific."
msgstr "POSIX.1-2001 (но смотрите ДЕФЕКТЫ далее). Алгоритмы B<SCHED_BATCH> и B<SCHED_IDLE> есть только в Linux."

#. type: Plain text
#: man-pages/man2/sched_setscheduler.2:177
msgid ""
"Further details of the semantics of all of the above \"normal\" and \"real-"
"time\" scheduling policies can be found in B<sched>(7)."
msgstr "Подробное описание семантики всех алгоритмов планирования («обычных» и «реального времени») можно найти в B<sched>(7)."

#. type: Plain text
#: man-pages/man2/sched_setscheduler.2:185
msgid ""
"POSIX systems on which B<sched_setscheduler>()  and B<sched_getscheduler>()"
"  are available define B<_POSIX_PRIORITY_SCHEDULING> in "
"I<E<lt>unistd.hE<gt>>."
msgstr "В системах POSIX, в которых доступны B<sched_setscheduler>() и B<sched_getscheduler>(), в I<E<lt>unistd.hE<gt>> определён макрос B<_POSIX_PRIORITY_SCHEDULING>."

#. type: Plain text
#: man-pages/man2/sched_setscheduler.2:193
msgid ""
"POSIX.1 does not detail the permissions that an unprivileged thread requires"
" in order to call B<sched_setscheduler>(), and details vary across systems."
"  For example, the Solaris 7 manual page says that the real or effective "
"user ID of the caller must match the real user ID or the save set-user-ID of"
" the target."
msgstr "В POSIX.1 не описаны права, которые требуются привилегированной нити для вызова B<sched_setscheduler>(), и в разных системах используются разные права. Например, в справочной странице Solaris 7 сказано, что реальный и эффективный пользовательский идентификатор вызывающего должен совпадать с реальным пользовательским идентификатором или сохранённым set-user-ID изменяемой нити."

#. type: Plain text
#: man-pages/man2/sched_setscheduler.2:214
msgid ""
"The scheduling policy and parameters are in fact per-thread attributes on "
"Linux.  The value returned from a call to B<gettid>(2)  can be passed in the"
" argument I<pid>.  Specifying I<pid> as 0 will operate on the attributes of "
"the calling thread, and passing the value returned from a call to "
"B<getpid>(2)  will operate on the attributes of the main thread of the "
"thread group.  (If you are using the POSIX threads API, then use "
"B<pthread_setschedparam>(3), B<pthread_getschedparam>(3), and "
"B<pthread_setschedprio>(3), instead of the B<sched_*>(2)  system calls.)"
msgstr "Алгоритм планирования и параметры, фактически, являются атрибутами нить в Linux. Значение, возвращаемое из вызова B<gettid>(2), можно передавать в аргументе I<pid>. При указании в I<pid> значения 0 операции будут выполняться на атрибутах вызывающей нити, а при передаче значения, полученном из вызова B<getpid>(2), операции будут выполнятся на атрибутах главной нити группы нитей (если вы используете интерфейс нитей POSIX, то используйте B<pthread_setschedparam>(3), B<pthread_getschedparam>(3) и B<pthread_setschedprio>(3) вместо системных вызовов B<sched_*>(2))."

#. type: Plain text
#: man-pages/man2/sched_setscheduler.2:222
msgid ""
"POSIX says that on success, B<sched_setscheduler>()  should return the "
"previous scheduling policy.  Linux B<sched_setscheduler>()  does not conform"
" to this requirement, since it always returns 0 on success."
msgstr "В POSIX указано, что при успешном выполнении B<sched_setscheduler>() должно возвращаться предыдущее значение алгоритма планирования. В Linux вызов B<sched_setscheduler>() не выполняет это требование, так как при успешном выполнении всегда возвращает 0."

#. type: Plain text
#: man-pages/man2/sched_setscheduler.2:240
msgid ""
"B<nice>(2), B<sched_get_priority_max>(2), B<sched_get_priority_min>(2), "
"B<sched_getaffinity>(2), B<sched_getattr>(2), B<sched_getparam>(2), "
"B<sched_rr_get_interval>(2), B<sched_setaffinity>(2), B<sched_setattr>(2), "
"B<sched_setparam>(2), B<sched_yield>(2), B<setpriority>(2), "
"B<capabilities>(7), B<cpuset>(7), B<sched>(7)"
msgstr "B<nice>(2), B<sched_get_priority_max>(2), B<sched_get_priority_min>(2), B<sched_getaffinity>(2), B<sched_getattr>(2), B<sched_getparam>(2), B<sched_rr_get_interval>(2), B<sched_setaffinity>(2), B<sched_setattr>(2), B<sched_setparam>(2), B<sched_yield>(2), B<setpriority>(2), B<capabilities>(7), B<cpuset>(7), B<sched>(7)"

#. type: TH
#: man-pages/man2/semget.2:36
#, no-wrap
msgid "SEMGET"
msgstr "SEMGET"

#. type: Plain text
#: man-pages/man2/semget.2:39
msgid "semget - get a System V semaphore set identifier"
msgstr "semget - считывает идентификатор набора семафоров System V"

#. type: Plain text
#: man-pages/man2/semget.2:44
#, no-wrap
msgid ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>sys/ipc.hE<gt>>\n"
"B<#include E<lt>sys/sem.hE<gt>>\n"
msgstr "B<#include E<lt>sys/types.hE<gt>>\nB<#include E<lt>sys/ipc.hE<gt>>\nB<#include E<lt>sys/sem.hE<gt>>\n"

#. type: Plain text
#: man-pages/man2/semget.2:49
msgid ""
"B<int semget(key_t >I<key>B<,> B<int >I<nsems>B<,> B<int >I<semflg>B<);>"
msgstr "B<int semget(key_t >I<key>B<,> B<int >I<nsems>B<,> B<int >I<semflg>B<);>"

#. type: Plain text
#: man-pages/man2/semget.2:67
msgid ""
"The B<semget>()  system call returns the System\\ V semaphore set identifier"
" associated with the argument I<key>.  A new set of I<nsems> semaphores is "
"created if I<key> has the value B<IPC_PRIVATE> or if no existing semaphore "
"set is associated with I<key> and B<IPC_CREAT> is specified in I<semflg>."
msgstr "Системный вызов B<semget>() возвращает идентификатор набора семафоров System\\ V, связанный с аргументом I<key>. Если значение I<key> равно B<IPC_PRIVATE> или с ключом I<key> не связано ни одного существующего набора семафора, а в I<semflg> задано B<IPC_CREAT>, создаётся новый набор из I<nsems> семафоров."

#. type: Plain text
#: man-pages/man2/semget.2:86
msgid ""
"If I<semflg> specifies both B<IPC_CREAT> and B<IPC_EXCL> and a semaphore set"
" already exists for I<key>, then B<semget>()  fails with I<errno> set to "
"B<EEXIST>.  (This is analogous to the effect of the combination B<O_CREAT | "
"O_EXCL> for B<open>(2).)"
msgstr "Если в I<semflg> одновременно указаны B<IPC_CREAT> и B<IPC_EXCL> и набор семафоров для I<key> уже существует, то B<semget>() завершается с ошибкой и I<errno> присваивается значение B<EEXIST> (такой же результат как с B<O_CREAT | O_EXCL> у B<open>(2))."

#. type: Plain text
#: man-pages/man2/semget.2:99
msgid ""
"Upon creation, the least significant 9 bits of the argument I<semflg> define"
" the permissions (for owner, group and others)  for the semaphore set.  "
"These bits have the same format, and the same meaning, as the I<mode> "
"argument of B<open>(2)  (though the execute permissions are not meaningful "
"for semaphores, and write permissions mean permission to alter semaphore "
"values)."
msgstr "При создании в 9 начальных битах аргумента I<semflg> указываются права (владелец, группа и др.) на набор семафоров. Формат значения битов совпадает с аргументом I<mode> вызова B<open>(2) (но права на выполнение для семафоров ничего не означают, а права на запись означают право изменять значения семафоров)."

#. type: Plain text
#: man-pages/man2/semget.2:107
msgid ""
"When creating a new semaphore set, B<semget>()  initializes the set's "
"associated data structure, I<semid_ds> (see B<semctl>(2)), as follows:"
msgstr "При создании нового набора семафоров B<semget>() инициализирует связанную с семафором структуру данных I<semid_ds> (см. B<semctl>(2)) следующим образом: "

#. type: Plain text
#: man-pages/man2/semget.2:112
msgid ""
"I<sem_perm.cuid> and I<sem_perm.uid> are set to the effective user ID of the"
" calling process."
msgstr "Полям I<sem_perm.cuid> и I<sem_perm.uid> присваиваются значения эффективного идентификатора пользователя вызывающего процесса."

#. type: Plain text
#: man-pages/man2/semget.2:117
msgid ""
"I<sem_perm.cgid> and I<sem_perm.gid> are set to the effective group ID of "
"the calling process."
msgstr "Полям I<sem_perm.cgid> и I<sem_perm.gid> присваиваются значения эффективного идентификатора группы вызывающего процесса."

#. type: Plain text
#: man-pages/man2/semget.2:122
msgid ""
"The least significant 9 bits of I<sem_perm.mode> are set to the least "
"significant 9 bits of I<semflg>."
msgstr "Младшим 9 битам I<sem_perm.mode> присваивается значение младших 9 бит I<semflg>."

#. type: Plain text
#: man-pages/man2/semget.2:126
msgid "I<sem_nsems> is set to the value of I<nsems>."
msgstr "Полю I<sem_nsems> присваивается значение I<nsems>."

#. type: Plain text
#: man-pages/man2/semget.2:129
msgid "I<sem_otime> is set to 0."
msgstr "Полю I<sem_otime> присваивается значение 0."

#. type: Plain text
#: man-pages/man2/semget.2:132
msgid "I<sem_ctime> is set to the current time."
msgstr "Полю I<sem_ctime> присваивается значение текущего времени."

#. type: Plain text
#: man-pages/man2/semget.2:143
msgid ""
"The argument I<nsems> can be 0 (a don't care)  when a semaphore set is not "
"being created.  Otherwise, I<nsems> must be greater than 0 and less than or "
"equal to the maximum number of semaphores per semaphore set (B<SEMMSL>)."
msgstr "Если набор семафоров не создаётся, то аргумент I<nsems> может быть равен 0 (не учитывать). Иначе аргумент I<nsems> должен быть больше 0 и меньше или равен максимальному количеству семафоров в наборе (B<SEMMSL>)."

#.  and a check is made to see if it is marked for destruction.
#. type: Plain text
#: man-pages/man2/semget.2:147
msgid "If the semaphore set already exists, the permissions are verified."
msgstr "Если набор семафоров уже существует, то проверяются права доступа."

#. type: Plain text
#: man-pages/man2/semget.2:153
msgid ""
"If successful, the return value will be the semaphore set identifier (a "
"nonnegative integer), otherwise, -1 is returned, with I<errno> indicating "
"the error."
msgstr "При успешном выполнении возвращается идентификатор набора семафоров (неотрицательное целое), иначе возвращается -1, а переменной I<errno> присваивается номер ошибки."

#. type: Plain text
#: man-pages/man2/semget.2:157
msgid "On failure, I<errno> will be set to one of the following:"
msgstr "При ошибке I<errno> присваиваются следующие значения:"

#. type: Plain text
#: man-pages/man2/semget.2:165
msgid ""
"A semaphore set exists for I<key>, but the calling process does not have "
"permission to access the set, and does not have the B<CAP_IPC_OWNER> "
"capability."
msgstr "Набор семафоров для ключа I<key> существует, но вызывающий процесс не имеет прав доступа к нему и не имеет мандата B<CAP_IPC_OWNER>."

#. type: TP
#: man-pages/man2/semget.2:165
#, no-wrap
msgid "B<EEXIST>"
msgstr "B<EEXIST>"

#.  .TP
#.  .B EIDRM
#.  The semaphore set is marked to be deleted.
#. type: Plain text
#: man-pages/man2/semget.2:177
msgid ""
"B<IPC_CREAT> and B<IPC_EXCL> were specified in I<semflg>, but a semaphore "
"set already exists for I<key>."
msgstr "В I<semflg> указаны B<IPC_CREAT> и B<IPC_EXCL>, но набор семафоров уже существует для I<key>."

#. type: Plain text
#: man-pages/man2/semget.2:183
msgid ""
"I<nsems> is less than 0 or greater than the limit on the number of "
"semaphores per semaphore set (B<SEMMSL>)."
msgstr "Значение I<nsems> меньше 0 или больше максимально возможного для набора количества семафоров (B<SEMMSL>)."

#. type: Plain text
#: man-pages/man2/semget.2:190
msgid ""
"A semaphore set corresponding to I<key> already exists, but I<nsems> is "
"larger than the number of semaphores in that set."
msgstr "Набор семафоров, соответствующий I<key>, уже существует, но I<nsems> больше, чем количество семафоров в этом наборе."

#. type: TP
#: man-pages/man2/semget.2:190
#, no-wrap
msgid "B<ENOENT>"
msgstr "B<ENOENT>"

#. type: Plain text
#: man-pages/man2/semget.2:198
msgid ""
"No semaphore set exists for I<key> and I<semflg> did not specify "
"B<IPC_CREAT>."
msgstr "Для ключа I<key> не существует набора семафоров и в I<semflg> нет флага B<IPC_CREAT>."

#. type: Plain text
#: man-pages/man2/semget.2:202
msgid ""
"A semaphore set has to be created but the system does not have enough memory"
" for the new data structure."
msgstr "Набор семафоров должен быть создан, но в системе не хватает памяти для хранения новой структуры данных."

#. type: Plain text
#: man-pages/man2/semget.2:210
msgid ""
"A semaphore set has to be created but the system limit for the maximum "
"number of semaphore sets (B<SEMMNI>), or the system wide maximum number of "
"semaphores (B<SEMMNS>), would be exceeded."
msgstr "Набор семафоров должен быть создан, но при этом будет превышен системный лимит на количество наборов семафоров (B<SEMMNI>) или системный лимит на количество семафоров (B<SEMMNS>)."

#. type: Plain text
#: man-pages/man2/semget.2:238
msgid ""
"B<IPC_PRIVATE> isn't a flag field but a I<key_t> type.  If this special "
"value is used for I<key>, the system call ignores all but the least "
"significant 9 bits of I<semflg> and creates a new semaphore set (on "
"success)."
msgstr "Значение B<IPC_PRIVATE> не поле флага, а тип I<key_t>. Если I<key> равно этому специальному значению, то системный вызов игнорирует всё кроме 9-ти младших битов I<semflg> и создаёт новый набор семафоров (при успешном выполнении)."

#. type: SS
#: man-pages/man2/semget.2:238
#, no-wrap
msgid "Semaphore initialization"
msgstr "Инициализация семафоров"

#.  In truth, every one of the many implementations that I've tested sets
#.  the values to zero, but I suppose there is/was some obscure
#.  implementation out there that does not.
#. type: Plain text
#: man-pages/man2/semget.2:250
msgid ""
"The values of the semaphores in a newly created set are indeterminate.  "
"(POSIX.1-2001 and POSIX.1-2008 are explicit on this point, although "
"POSIX.1-2008 notes that a future version of the standard may require an "
"implementation to initialize the semaphores to 0.)  Although Linux, like "
"many other implementations, initializes the semaphore values to 0, a "
"portable application cannot rely on this: it should explicitly initialize "
"the semaphores to the desired values."
msgstr "Значения только что созданных семафоров не определены (в POSIX.1-2001 и POSIX.1-2008 это указано явно, хотя в POSIX.1-2008 сказано, что в будущих версиях стандарта от реализации может потребоваться инициализировать семафоры 0). Хотя Linux, подобно многим другим реализациям, инициализирует семафоры значением 0, переносимое приложение не может полагаться на это: оно должно явно инициализировать семафоры нужным значением."

#. type: Plain text
#: man-pages/man2/semget.2:265
msgid ""
"Initialization can be done using B<semctl>(2)  B<SETVAL> or B<SETALL> "
"operation.  Where multiple peers do not know who will be the first to "
"initialize the set, checking for a nonzero I<sem_otime> in the associated "
"data structure retrieved by a B<semctl>(2)  B<IPC_STAT> operation can be "
"used to avoid races."
msgstr "Инициализацию можно выполнять с помощью B<semctl>(2) с операцией B<SETVAL> или B<SETALL>. При наличии нескольких абонентов неизвестно, кто первый выполнит инициализацию, и чтобы избежать состязательности нужно проверять I<sem_otime> на ненулевое значение в связанной структуре данных, получаемой с помощью B<semctl>(2) и операции B<IPC_STAT>."

#. type: SS
#: man-pages/man2/semget.2:265
#, no-wrap
msgid "Semaphore limits"
msgstr "Ограничения семафоров"

#. type: Plain text
#: man-pages/man2/semget.2:269
msgid ""
"The following limits on semaphore set resources affect the B<semget>()  "
"call:"
msgstr "Ниже приведены ограничения на ресурсы набора семафоров, оказывающие влияние на вызов B<semget>():"

#. type: TP
#: man-pages/man2/semget.2:269
#, no-wrap
msgid "B<SEMMNI>"
msgstr "B<SEMMNI>"

#.  This /proc file is not available in Linux 2.2 and earlier -- MTK
#. type: Plain text
#: man-pages/man2/semget.2:275
msgid ""
"System-wide limit on the number of semaphore sets: policy dependent (on "
"Linux, this limit can be read and modified via the fourth field of "
"I</proc/sys/kernel/sem>)."
msgstr "Ограничение на максимальное количество наборов семафоров в системе: зависит от политики (в Linux это ограничение можно получать и изменять через четвёртое поле I</proc/sys/kernel/sem>)."

#. type: TP
#: man-pages/man2/semget.2:275
#, no-wrap
msgid "B<SEMMSL>"
msgstr "B<SEMMSL>"

#. type: Plain text
#: man-pages/man2/semget.2:280
msgid ""
"Maximum number of semaphores per semaphore ID: implementation dependent (on "
"Linux, this limit can be read and modified via the first field of "
"I</proc/sys/kernel/sem>)."
msgstr "Максимальное количество семафоров на каждый ID семафора: зависит от реализации (в Linux это ограничение можно получать и изменять через первое поле I</proc/sys/kernel/sem>)."

#. type: TP
#: man-pages/man2/semget.2:280
#, no-wrap
msgid "B<SEMMNS>"
msgstr "B<SEMMNS>"

#. type: Plain text
#: man-pages/man2/semget.2:289
msgid ""
"System-wide limit on the number of semaphores: policy dependent (on Linux, "
"this limit can be read and modified via the second field of "
"I</proc/sys/kernel/sem>).  Note that number of semaphores system-wide is "
"also limited by the product of B<SEMMSL> and B<SEMMNI>."
msgstr "Ограничение на максимальное количество семафоров в системе: зависит от политики (в Linux это ограничение можно получать и изменять через второе поле I</proc/sys/kernel/sem>). Заметим, что количество семафоров в системе также ограничено произведением B<SEMMSL> и B<SEMMNI>."

#. type: Plain text
#: man-pages/man2/semget.2:295
msgid ""
"The name choice B<IPC_PRIVATE> was perhaps unfortunate, B<IPC_NEW> would "
"more clearly show its function."
msgstr "Имя B<IPC_PRIVATE>, возможно, было выбрано неудачно, B<IPC_NEW> отражает смысл действия более ясно."

#. type: Plain text
#: man-pages/man2/semget.2:301
msgid ""
"B<semctl>(2), B<semop>(2), B<ftok>(3), B<capabilities>(7), "
"B<sem_overview>(7), B<svipc>(7)"
msgstr "B<semctl>(2), B<semop>(2), B<ftok>(3), B<capabilities>(7), B<sem_overview>(7), B<svipc>(7)"

#. type: TH
#: man-pages/man2/sendmmsg.2:28
#, no-wrap
msgid "SENDMMSG"
msgstr "SENDMMSG"

#. type: Plain text
#: man-pages/man2/sendmmsg.2:31
msgid "sendmmsg - send multiple messages on a socket"
msgstr "sendmmsg - отправляет несколько сообщений в сокет"

#. type: Plain text
#: man-pages/man2/sendmmsg.2:35
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE          /* See feature_test_macros(7) */>\n"
"B<#include E<lt>sys/socket.hE<gt>>\n"
msgstr "B<#define _GNU_SOURCE          /* Смотрите feature_test_macros(7) */>\nB<#include E<lt>sys/socket.hE<gt>>\n"

#. type: Plain text
#: man-pages/man2/sendmmsg.2:39
#, no-wrap
msgid ""
"B<int sendmmsg(int >I<sockfd>B<, struct mmsghdr *>I<msgvec>B<, unsigned int >I<vlen>B<,>\n"
"B<             unsigned int >I<flags>B<);>\n"
msgstr "B<int sendmmsg(int >I<sockfd>B<, struct mmsghdr *>I<msgvec>B<, unsigned int >I<vlen>B<,>\nB<             unsigned int >I<flags>B<);>\n"

#.  See commit 228e548e602061b08ee8e8966f567c12aa079682
#. type: Plain text
#: man-pages/man2/sendmmsg.2:49
msgid ""
"The B<sendmmsg>()  system call is an extension of B<sendmsg>(2)  that allows"
" the caller to transmit multiple messages on a socket using a single system "
"call.  (This has performance benefits for some applications.)"
msgstr "Системный вызов B<sendmmsg>() является расширенной версией B<sendmsg>(2), позволяя вызывающему передавать несколько сообщений из сокета, используя только один системный вызов (в некоторых приложениях это позволяет получить выигрыш в производительности)."

#. type: Plain text
#: man-pages/man2/sendmmsg.2:54
msgid ""
"The I<sockfd> argument is the file descriptor of the socket on which data is"
" to be transmitted."
msgstr "Аргумент I<sockfd> представляет собой файловый дескриптор сокета для отправки данных."

#. type: Plain text
#: man-pages/man2/sendmmsg.2:62
msgid ""
"The I<msgvec> argument is a pointer to an array of I<mmsghdr> structures.  "
"The size of this array is specified in I<vlen>."
msgstr "Аргумент I<msgvec> является указателем на массив структур I<mmsghdr>. Размер этого массива указывается в I<vlen>."

#. type: Plain text
#: man-pages/man2/sendmmsg.2:68
msgid "The I<mmsghdr> structure is defined in I<E<lt>sys/socket.hE<gt>> as:"
msgstr "Структура I<mmsghdr> определена в I<E<lt>sys/socket.hE<gt>> следующим образом:"

#. type: Plain text
#: man-pages/man2/sendmmsg.2:75
#, no-wrap
msgid ""
"struct mmsghdr {\n"
"    struct msghdr msg_hdr;  /* Message header */\n"
"    unsigned int  msg_len;  /* Number of bytes transmitted */\n"
"};\n"
msgstr "struct mmsghdr {\n    struct msghdr msg_hdr;  /* заголовок сообщения */\n    unsigned int  msg_len;  /* кол-во переданных байт */\n};\n"

#. type: Plain text
#: man-pages/man2/sendmmsg.2:91
msgid ""
"The I<msg_hdr> field is a I<msghdr> structure, as described in "
"B<sendmsg>(2).  The I<msg_len> field is used to return the number of bytes "
"sent from the message in I<msg_hdr> (i.e., the same as the return value from"
" a single B<sendmsg>(2)  call)."
msgstr ""

#. type: Plain text
#: man-pages/man2/sendmmsg.2:97
msgid ""
"The I<flags> argument contains flags ORed together.  The flags are the same "
"as for B<sendmsg>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/sendmmsg.2:107
msgid ""
"A blocking B<sendmmsg>()  call blocks until I<vlen> messages have been sent."
"  A nonblocking call sends as many messages as possible (up to the limit "
"specified by I<vlen>)  and returns immediately."
msgstr ""

#. type: Plain text
#: man-pages/man2/sendmmsg.2:119
msgid ""
"On return from B<sendmmsg>(), the I<msg_len> fields of successive elements "
"of I<msgvec> are updated to contain the number of bytes transmitted from the"
" corresponding I<msg_hdr>.  The return value of the call indicates the "
"number of elements of I<msgvec> that have been updated."
msgstr ""

#. type: Plain text
#: man-pages/man2/sendmmsg.2:129
msgid ""
"On success, B<sendmmsg>()  returns the number of messages sent from "
"I<msgvec>; if this is less than I<vlen>, the caller can retry with a further"
" B<sendmmsg>()  call to send the remaining messages."
msgstr ""

#. type: Plain text
#: man-pages/man2/sendmmsg.2:133
msgid "On error, -1 is returned, and I<errno> is set to indicate the error."
msgstr "В случае ошибки возвращается -1, а I<errno> устанавливается в значение ошибки."

#.  commit 728ffb86f10873aaf4abd26dde691ee40ae731fe
#.      ... only return an error if no datagrams could be sent.
#.      If less than the requested number of messages were sent, the
#. application
#.      must retry starting at the first failed one and if the problem is
#.      persistent the error will be returned.
#.      This matches the behavior of other syscalls like read/write - it
#.      is not an error if less than the requested number of elements are
#. sent.
#. type: Plain text
#: man-pages/man2/sendmmsg.2:145
msgid ""
"Errors are as for B<sendmsg>(2).  An error is returned only if no datagrams "
"could be sent."
msgstr ""

#. type: Plain text
#: man-pages/man2/sendmmsg.2:150
msgid ""
"The B<sendmmsg>()  system call was added in Linux 3.0.  Support in glibc was"
" added in version 2.14."
msgstr "Системный вызов B<sendmmsg>() был добавлен в ядро Linux версии 3.0. Поддержка в glibc появилась в версии 2.14."

#. type: Plain text
#: man-pages/man2/sendmmsg.2:153
msgid "B<sendmmsg>()  is Linux-specific."
msgstr "Вызов B<sendmmsg>() есть только в Linux."

#.  commit 98382f419f32d2c12d021943b87dea555677144b
#.      net: Cap number of elements for sendmmsg
#.      To limit the amount of time we can spend in sendmmsg, cap the
#.      number of elements to UIO_MAXIOV (currently 1024).
#.      For error handling an application using sendmmsg needs to retry at
#.      the first unsent message, so capping is simpler and requires less
#.      application logic than returning EINVAL.
#. type: Plain text
#: man-pages/man2/sendmmsg.2:168
msgid "The value specified in I<vlen> is capped to B<UIO_MAXIOV> (1024)."
msgstr ""

#. type: Plain text
#: man-pages/man2/sendmmsg.2:177
msgid ""
"The example below uses B<sendmmsg>()  to send I<onetwo> and I<three> in two "
"distinct UDP datagrams using one system call.  The contents of the first "
"datagram originates from a pair of buffers."
msgstr ""

#. type: Plain text
#: man-pages/man2/sendmmsg.2:186
#, no-wrap
msgid ""
"#define _GNU_SOURCE\n"
"#include E<lt>netinet/ip.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>sys/types.hE<gt>\n"
"#include E<lt>sys/socket.hE<gt>\n"
msgstr "#define _GNU_SOURCE\n#include E<lt>netinet/ip.hE<gt>\n#include E<lt>stdio.hE<gt>\n#include E<lt>stdlib.hE<gt>\n#include E<lt>string.hE<gt>\n#include E<lt>sys/types.hE<gt>\n#include E<lt>sys/socket.hE<gt>\n"

#. type: Plain text
#: man-pages/man2/sendmmsg.2:195
#, no-wrap
msgid ""
"int\n"
"main(void)\n"
"{\n"
"    int sockfd;\n"
"    struct sockaddr_in sa;\n"
"    struct mmsghdr msg[2];\n"
"    struct iovec msg1[2], msg2;\n"
"    int retval;\n"
msgstr "int\nmain(void)\n{\n    int sockfd;\n    struct sockaddr_in sa;\n    struct mmsghdr msg[2];\n    struct iovec msg1[2], msg2;\n    int retval;\n"

#. type: Plain text
#: man-pages/man2/sendmmsg.2:201
#, no-wrap
msgid ""
"    sockfd = socket(AF_INET, SOCK_DGRAM, 0);\n"
"    if (sockfd == -1) {\n"
"        perror(\"socket()\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr "    sockfd = socket(AF_INET, SOCK_DGRAM, 0);\n    if (sockfd == -1) {\n        perror(\"socket()\");\n        exit(EXIT_FAILURE);\n    }\n"

#. type: Plain text
#: man-pages/man2/sendmmsg.2:209
#, no-wrap
msgid ""
"    sa.sin_family = AF_INET;\n"
"    sa.sin_addr.s_addr = htonl(INADDR_LOOPBACK);\n"
"    sa.sin_port = htons(1234);\n"
"    if (connect(sockfd, (struct sockaddr *) &sa, sizeof(sa)) == -1) {\n"
"        perror(\"connect()\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr "    sa.sin_family = AF_INET;\n    sa.sin_addr.s_addr = htonl(INADDR_LOOPBACK);\n    sa.sin_port = htons(1234);\n    if (connect(sockfd, (struct sockaddr *) &sa, sizeof(sa)) == -1) {\n        perror(\"connect()\");\n        exit(EXIT_FAILURE);\n    }\n"

#. type: Plain text
#: man-pages/man2/sendmmsg.2:215
#, no-wrap
msgid ""
"    memset(msg1, 0, sizeof(msg1));\n"
"    msg1[0].iov_base = \"one\";\n"
"    msg1[0].iov_len = 3;\n"
"    msg1[1].iov_base = \"two\";\n"
"    msg1[1].iov_len = 3;\n"
msgstr "    memset(msg1, 0, sizeof(msg1));\n    msg1[0].iov_base = \"one\";\n    msg1[0].iov_len = 3;\n    msg1[1].iov_base = \"two\";\n    msg1[1].iov_len = 3;\n"

#. type: Plain text
#: man-pages/man2/sendmmsg.2:219
#, no-wrap
msgid ""
"    memset(&msg2, 0, sizeof(msg2));\n"
"    msg2.iov_base = \"three\";\n"
"    msg2.iov_len = 5;\n"
msgstr "    memset(&msg2, 0, sizeof(msg2));\n    msg2.iov_base = \"three\";\n    msg2.iov_len = 5;\n"

#. type: Plain text
#: man-pages/man2/sendmmsg.2:223
#, no-wrap
msgid ""
"    memset(msg, 0, sizeof(msg));\n"
"    msg[0].msg_hdr.msg_iov = msg1;\n"
"    msg[0].msg_hdr.msg_iovlen = 2;\n"
msgstr "    memset(msg, 0, sizeof(msg));\n    msg[0].msg_hdr.msg_iov = msg1;\n    msg[0].msg_hdr.msg_iovlen = 2;\n"

#. type: Plain text
#: man-pages/man2/sendmmsg.2:226
#, no-wrap
msgid ""
"    msg[1].msg_hdr.msg_iov = &msg2;\n"
"    msg[1].msg_hdr.msg_iovlen = 1;\n"
msgstr "    msg[1].msg_hdr.msg_iov = &msg2;\n    msg[1].msg_hdr.msg_iovlen = 1;\n"

#. type: Plain text
#: man-pages/man2/sendmmsg.2:232
#, no-wrap
msgid ""
"    retval = sendmmsg(sockfd, msg, 2, 0);\n"
"    if (retval == -1)\n"
"        perror(\"sendmmsg()\");\n"
"    else\n"
"        printf(\"%d messages sent\\en\", retval);\n"
msgstr "    retval = sendmmsg(sockfd, msg, 2, 0);\n    if (retval == -1)\n        perror(\"sendmmsg()\");\n    else\n        printf(\"%d сообщений послано\\en\", retval);\n"

#. type: Plain text
#: man-pages/man2/sendmmsg.2:235
#, no-wrap
msgid ""
"    exit(0);\n"
"}\n"
msgstr "    exit(0);\n}\n"

#. type: Plain text
#: man-pages/man2/sendmmsg.2:240
msgid "B<recvmmsg>(2), B<sendmsg>(2), B<socket>(2), B<socket>(7)"
msgstr "B<recvmmsg>(2), B<sendmsg>(2), B<socket>(2), B<socket>(7)"

#. type: TH
#: man-pages/man2/setpgid.2:48
#, no-wrap
msgid "SETPGID"
msgstr "SETPGID"

#. type: TH
#: man-pages/man2/setpgid.2:48
#, no-wrap
msgid "2014-01-07"
msgstr "2014-01-07"

#. type: Plain text
#: man-pages/man2/setpgid.2:51
msgid "setpgid, getpgid, setpgrp, getpgrp - set/get process group"
msgstr "setpgid, getpgid, setpgrp, getpgrp - устанавливает/получает группу процессов"

#. type: Plain text
#: man-pages/man2/setpgid.2:53
msgid "B<#include E<lt>unistd.hE<gt>>"
msgstr "B<#include E<lt>unistd.hE<gt>>"

#. type: Plain text
#: man-pages/man2/setpgid.2:55
msgid "B<int setpgid(pid_t >I<pid>B<, pid_t >I<pgid>B<);>"
msgstr "B<int setpgid(pid_t >I<pid>B<, pid_t >I<pgid>B<);>"

#. type: Plain text
#: man-pages/man2/setpgid.2:57
msgid "B<pid_t getpgid(pid_t >I<pid>B<);>"
msgstr "B<pid_t getpgid(pid_t >I<pid>B<);>"

#. type: Plain text
#: man-pages/man2/setpgid.2:59
msgid "B<pid_t getpgrp(void);> /* POSIX.1 version */"
msgstr "B<pid_t getpgrp(void);> /* по версии POSIX.1 */"

#. type: Plain text
#: man-pages/man2/setpgid.2:62
msgid "B<pid_t getpgrp(pid_t >I<pid>B<);\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ > /* BSD version */"
msgstr "B<pid_t getpgrp(pid_t >I<pid>B<);> /* по версии BSD */"

#. type: Plain text
#: man-pages/man2/setpgid.2:64
msgid "B<int setpgrp(void);> /* System V version */"
msgstr "B<int setpgrp(void);> /* по версии System V */"

#. type: Plain text
#: man-pages/man2/setpgid.2:67
msgid "B<int setpgrp(pid_t >I<pid>B<, pid_t >I<pgid>B<);\\ > /* BSD version */"
msgstr "B<int setpgrp(pid_t >I<pid>B<, pid_t >I<pgid>B<);> /* по версии BSD */"

#. type: Plain text
#: man-pages/man2/setpgid.2:71
msgid ""
"Feature Test Macro Requirements for glibc (see B<feature_test_macros>(7)):"
msgstr "Требования макроса тестирования свойств для glibc (см. B<feature_test_macros>(7)):"

#. type: Plain text
#: man-pages/man2/setpgid.2:76
msgid "B<getpgid>():"
msgstr "B<getpgid>():"

#. type: Plain text
#: man-pages/man2/setpgid.2:79
msgid "_XOPEN_SOURCE\\ E<gt>=\\ 500 || _XOPEN_SOURCE\\ &&\\ _XOPEN_SOURCE_EXTENDED"
msgstr "_XOPEN_SOURCE\\ E<gt>=\\ 500 || _XOPEN_SOURCE\\ &&\\ _XOPEN_SOURCE_EXTENDED"

#. type: Plain text
#: man-pages/man2/setpgid.2:81
msgid "|| /* Since glibc 2.12: */ _POSIX_C_SOURCE\\ E<gt>=\\ 200809L"
msgstr "|| /* начиная с glibc 2.12: */ _POSIX_C_SOURCE\\ E<gt>=\\ 200809L"

#. type: Plain text
#: man-pages/man2/setpgid.2:84
msgid "B<setpgrp>() (POSIX.1):"
msgstr "B<setpgrp>() (POSIX.1):"

#. type: Plain text
#: man-pages/man2/setpgid.2:87
#, no-wrap
msgid ""
"    _SVID_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 500 ||\n"
"    _XOPEN_SOURCE\\ &&\\ _XOPEN_SOURCE_EXTENDED\n"
msgstr "    _SVID_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 500 ||\n    _XOPEN_SOURCE\\ &&\\ _XOPEN_SOURCE_EXTENDED\n"

#. type: Plain text
#: man-pages/man2/setpgid.2:89
#, no-wrap
msgid "    || /* Since glibc 2.19: */ _BSD_SOURCE\n"
msgstr "    || /* начиная с glibc 2.19: */ _BSD_SOURCE\n"

#. type: Plain text
#: man-pages/man2/setpgid.2:93
msgid "B<setpgrp>()\\ (BSD), B<getpgrp>()\\ (BSD) [before glibc 2.19]:"
msgstr "B<setpgrp>()\\ (BSD), B<getpgrp>()\\ (BSD) [до glibc 2.19]:"

#. type: Plain text
#: man-pages/man2/setpgid.2:97
#, no-wrap
msgid ""
"    _BSD_SOURCE &&\n"
"        !\\ (_POSIX_SOURCE || _POSIX_C_SOURCE || _XOPEN_SOURCE ||\n"
"           _XOPEN_SOURCE_EXTENDED || _GNU_SOURCE || _SVID_SOURCE)\n"
msgstr "    _BSD_SOURCE &&\n        !\\ (_POSIX_SOURCE || _POSIX_C_SOURCE || _XOPEN_SOURCE ||\n           _XOPEN_SOURCE_EXTENDED || _GNU_SOURCE || _SVID_SOURCE)\n"

#. type: Plain text
#: man-pages/man2/setpgid.2:109
msgid ""
"All of these interfaces are available on Linux, and are used for getting and"
" setting the process group ID (PGID) of a process.  The preferred, "
"POSIX.1-specified ways of doing this are: B<getpgrp>(void), for retrieving "
"the calling process's PGID; and B<setpgid>(), for setting a process's PGID."
msgstr "Все перечисленные интерфейсы доступны в Linux и используются для получения и установки идентификатора группы процессов (PGID). Предпочтительней использовать версию POSIX.1: B<getpgrp>(void) — для получения PGID вызывающего процесса; B<setpgid>() — для установки PGID вызывающего процесса."

#. type: Plain text
#: man-pages/man2/setpgid.2:134
msgid ""
"B<setpgid>()  sets the PGID of the process specified by I<pid> to I<pgid>.  "
"If I<pid> is zero, then the process ID of the calling process is used.  If "
"I<pgid> is zero, then the PGID of the process specified by I<pid> is made "
"the same as its process ID.  If B<setpgid>()  is used to move a process from"
" one process group to another (as is done by some shells when creating "
"pipelines), both process groups must be part of the same session (see "
"B<setsid>(2)  and B<credentials>(7)).  In this case, the I<pgid> specifies "
"an existing process group to be joined and the session ID of that group must"
" match the session ID of the joining process."
msgstr "Вызов B<setpgid>() устанавливает PGID у процесса с идентификатором I<pid> равным I<pgid>. Если значение I<pid> равно 0, то используется идентификатор вызывающего процесса. Если значение I<pgid> равно 0, то PGID процесса, указанного в I<pid>, становится равным его идентификатору процесса. Если B<setpgid>() используется для перевода процесса из одной группы в другую (это делают некоторые оболочки командной строки для объединения каналов процессов), то обе группы процессов должны быть частью одного сеанса (см. B<setsid>(2) и B<credentials>(7)). В этом случае в I<pgid> указывается существующая группа процессов, в которую нужно выполнить перевод и идентификатор сеанса этой группы должен совпадать с идентификатором сеанса переводимого процесса."

#. type: Plain text
#: man-pages/man2/setpgid.2:139
msgid ""
"The POSIX.1 version of B<getpgrp>(), which takes no arguments, returns the "
"PGID of the calling process."
msgstr "В версии POSIX.1 вызов B<getpgrp>() без аргументов возвращает PGID вызывающего процесса."

#. type: Plain text
#: man-pages/man2/setpgid.2:150
msgid ""
"B<getpgid>()  returns the PGID of the process specified by I<pid>.  If "
"I<pid> is zero, the process ID of the calling process is used.  (Retrieving "
"the PGID of a process other than the caller is rarely necessary, and the "
"POSIX.1 B<getpgrp>()  is preferred for that task.)"
msgstr "Вызов B<getpgid>() возвращает PGID процесса с заданным I<pid>. Если значение I<pid> равно нулю, то используется идентификатор вызывающего процесса (получение PGID процесса, отличного от вызывающего, требуется редко, а для этой задачи хорошо подходит POSIX.1 B<getpgrp>())."

#. type: Plain text
#: man-pages/man2/setpgid.2:155
msgid ""
"The System\\ V-style B<setpgrp>(), which takes no arguments, is equivalent "
"to I<setpgid(0,\\ 0)>."
msgstr "В версии System\\ V вызов B<setpgrp>() без аргументов эквивалентен I<setpgid(0,\\ 0)>."

#. type: Plain text
#: man-pages/man2/setpgid.2:163
msgid ""
"The BSD-specific B<setpgrp>()  call, which takes arguments I<pid> and "
"I<pgid>, is is a wrapper function that calls"
msgstr "В версии BSD вызов B<setpgrp>() с аргументами I<pid> и I<pgid> является обёрточной функцией, которая вызывает"

#. type: Plain text
#: man-pages/man2/setpgid.2:165
#, no-wrap
msgid "    setpgid(pid, pgid)\n"
msgstr "    setpgid(pid, pgid)\n"

#.  The true BSD setpgrp() system call differs in allowing the PGID
#.  to be set to arbitrary values, rather than being restricted to
#.  PGIDs in the same session.
#. type: Plain text
#: man-pages/man2/setpgid.2:176
msgid ""
"Since glibc 2.19, the BSD-specific B<setpgrp>()  function is no longer "
"exposed by I<E<lt>unistd.hE<gt>>; calls should be replaced with the "
"B<setpgid>()  call shown above."
msgstr "Начиная с glibc 2.19, BSD-функция B<setpgrp>() была удалена из I<E<lt>unistd.hE<gt>>; вызовы должны быть заменены на вызов B<setpgid>(), как показано выше."

#. type: Plain text
#: man-pages/man2/setpgid.2:182
msgid ""
"The BSD-specific B<getpgrp>()  call, which takes a single I<pid> argument, "
"is a wrapper function that calls"
msgstr "В версии BSD вызов B<getpgrp>() с аргументом I<pid> является обёрточной функцией, которая вызывает"

#. type: Plain text
#: man-pages/man2/setpgid.2:184
#, no-wrap
msgid "    getpgid(pid)\n"
msgstr "    getpgid(pid)\n"

#. type: Plain text
#: man-pages/man2/setpgid.2:195
msgid ""
"Since glibc 2.19, the BSD-specific B<getpgrp>()  function is no longer "
"exposed by I<E<lt>unistd.hE<gt>>; calls should be replaced with calls to the"
" POSIX.1 B<getpgrp>()  which takes no arguments (if the intent is to obtain "
"the caller's PGID), or with the B<getpgid>()  call shown above."
msgstr "Начиная с glibc 2.19, BSD-функция B<getpgrp>() была удалена из I<E<lt>unistd.hE<gt>>; вызовы должны быть заменены на вызов POSIX.1 B<getpgrp>(), который не имеет аргументов (если нужно получить PGID вызывающего), или на вызов B<getpgid>(), как показано выше."

#. type: Plain text
#: man-pages/man2/setpgid.2:204
msgid ""
"On success, B<setpgid>()  and B<setpgrp>()  return zero.  On error, -1 is "
"returned, and I<errno> is set appropriately."
msgstr "При успешном выполнении B<setpgid>()  and B<setpgrp>() возвращают 0. В случае ошибки возвращается -1, а I<errno> устанавливается в соответствующее значение."

#. type: Plain text
#: man-pages/man2/setpgid.2:208
msgid "The POSIX.1 B<getpgrp>()  always returns the PGID of the caller."
msgstr "Вызов B<getpgrp>() (POSIX.1) всегда возвращает PGID вызывающего процесса."

#. type: Plain text
#: man-pages/man2/setpgid.2:216
msgid ""
"B<getpgid>(), and the BSD-specific B<getpgrp>()  return a process group on "
"success.  On error, -1 is returned, and I<errno> is set appropriately."
msgstr "Вызовы B<getpgid>() и B<getpgrp>() (BSD) при успешном выполнении возвращают группу процессов. При ошибке возвращается -1, а значение I<errno> устанавливается соответствующим образом."

#. type: Plain text
#: man-pages/man2/setpgid.2:225
msgid ""
"An attempt was made to change the process group ID of one of the children of"
" the calling process and the child had already performed an B<execve>(2)  "
"(B<setpgid>(), B<setpgrp>())."
msgstr "Попытка изменить идентификатор группы процессов у одного из потомков вызывающего процесса, но потомок уже вызвал B<execve>(2) (B<setpgid>(), B<setpgrp>())."

#. type: Plain text
#: man-pages/man2/setpgid.2:231
msgid "I<pgid> is less than 0 (B<setpgid>(), B<setpgrp>())."
msgstr "Значение I<pgid> меньше 0 (B<setpgid>(), B<setpgrp>())."

#. type: Plain text
#: man-pages/man2/setpgid.2:240
msgid ""
"An attempt was made to move a process into a process group in a different "
"session, or to change the process group ID of one of the children of the "
"calling process and the child was in a different session, or to change the "
"process group ID of a session leader (B<setpgid>(), B<setpgrp>())."
msgstr "Попытка переместить процесс в группу процессов из другого сеанса или изменить идентификатор группы процессов у одного из потомков вызывающего процесса, но потомок находится в другом сеансе или изменить идентификатор группы процессов лидера сеанса (B<setpgid>(), B<setpgrp>())."

#. type: Plain text
#: man-pages/man2/setpgid.2:250
msgid ""
"For B<getpgid>(): I<pid> does not match any process.  For B<setpgid>(): "
"I<pid> is not the calling process and not a child of the calling process."
msgstr "Для B<getpgid>(): нет процесса с указанным I<pid>. Для B<setpgid>(): значение I<pid> не равно идентификатору вызывающего процесса или идентификатору потомка вызывающего процесса."

#. type: Plain text
#: man-pages/man2/setpgid.2:256
msgid ""
"B<setpgid>()  and the version of B<getpgrp>()  with no arguments conform to "
"POSIX.1-2001."
msgstr "Вызов B<setpgid>() и версия B<getpgrp>() без аргументов соответствуют POSIX.1-2001."

#. type: Plain text
#: man-pages/man2/setpgid.2:265
msgid ""
"POSIX.1-2001 also specifies B<getpgid>()  and the version of B<setpgrp>()  "
"that takes no arguments.  (POSIX.1-2008 marks this B<setpgrp>()  "
"specification as obsolete.)"
msgstr "В POSIX.1-2001 также определён вызов B<getpgid>() и его версия B<setpgrp>(), у которых нет аргументов (в POSIX.1-2008 определение B<setpgrp>() помечено как устаревшее)."

#. type: Plain text
#: man-pages/man2/setpgid.2:272
msgid ""
"The version of B<getpgrp>()  with one argument and the version of "
"B<setpgrp>()  that takes two arguments derive from 4.2BSD, and are not "
"specified by POSIX.1."
msgstr "Версия B<getpgrp>() с одним аргументом и версия B<setpgrp>() с двумя аргументами появились из 4.2BSD и отсутствуют в POSIX.1."

#. type: Plain text
#: man-pages/man2/setpgid.2:278
msgid ""
"A child created via B<fork>(2)  inherits its parent's process group ID.  The"
" PGID is preserved across an B<execve>(2)."
msgstr "Потомок, создаваемый с помощью B<fork>(2), наследует идентификатор группы процессов своего родителя. Значение PGID сохраняется при вызове B<execve>(2)."

#. type: Plain text
#: man-pages/man2/setpgid.2:281
msgid ""
"Each process group is a member of a session and each process is a member of "
"the session of which its process group is a member."
msgstr "Каждая группа процессов является членом сеанса и каждый процесс является членом сеанса, в который входит его группа процессов."

#. type: Plain text
#: man-pages/man2/setpgid.2:308
msgid ""
"A session can have a controlling terminal.  At any time, one (and only one) "
"of the process groups in the session can be the foreground process group for"
" the terminal; the remaining process groups are in the background.  If a "
"signal is generated from the terminal (e.g., typing the interrupt key to "
"generate B<SIGINT>), that signal is sent to the foreground process group.  "
"(See B<termios>(3)  for a description of the characters that generate "
"signals.)  Only the foreground process group may B<read>(2)  from the "
"terminal; if a background process group tries to B<read>(2)  from the "
"terminal, then the group is sent a B<SIGTTIN> signal, which suspends it.  "
"The B<tcgetpgrp>(3)  and B<tcsetpgrp>(3)  functions are used to get/set the "
"foreground process group of the controlling terminal."
msgstr "Сеанс может иметь управляющий терминал. В любой момент одна (и только одна) группа процессов в сеансе может являться приоритетной группой процессов (foreground process group) терминала; оставшиеся группы процессов выполняются в фоновом режиме. Если от терминала приходит сигнал (например, нажата клавиша прерывания и сгенерирован B<SIGINT>), то сигнал посылается в приоритетную группу процессов (смотрите в B<termios>(3) описание символов, для которых генерируются сигналы). Только приоритетная группа процессов может выполнять вызов B<read>(2) для терминала; если группа процессов в фоновом режиме пытается выполнить B<read>(2) для терминала, то группе посылается сигнал B<SIGTTIN>, который приостанавливает её выполнение. Функции B<tcgetpgrp>(3) и B<tcsetpgrp>(3) используются для получения/установки приоритетной группы процессов у управляющего терминала."

#. type: Plain text
#: man-pages/man2/setpgid.2:316
msgid ""
"The B<setpgid>()  and B<getpgrp>()  calls are used by programs such as "
"B<bash>(1)  to create process groups in order to implement shell job "
"control."
msgstr "Вызовы B<setpgid>() и B<getpgrp>() используются программами, например B<bash>(1), для создания группы процессов с целью реализации управления заданиями оболочки командной строки."

#. type: Plain text
#: man-pages/man2/setpgid.2:326
msgid ""
"If a session has a controlling terminal, and the B<CLOCAL> flag for that "
"terminal is not set, and a terminal hangup occurs, then the session leader "
"is sent a B<SIGHUP>.  If the session leader exits, then a B<SIGHUP> signal "
"will also be sent to each process in the foreground process group of the "
"controlling terminal."
msgstr "Если сеанс имеет управляющий терминал, у которого не установлен флаг B<CLOCAL> и возникает зависание (hangup) терминала, то лидеру сеанса посылается B<SIGHUP>. Если лидер сеанса существует, то сигнал B<SIGHUP> также посылается каждому процессу в приоритетной группе процессов управляющего терминала."

#.  exit.3 refers to the following text:
#. type: Plain text
#: man-pages/man2/setpgid.2:340
msgid ""
"If the exit of the process causes a process group to become orphaned, and if"
" any member of the newly orphaned process group is stopped, then a B<SIGHUP>"
" signal followed by a B<SIGCONT> signal will be sent to each process in the "
"newly orphaned process group.  An orphaned process group is one in which the"
" parent of every member of process group is either itself also a member of "
"the process group or is a member of a process group in a different session "
"(see also B<credentials>(7))."
msgstr "Если завершение процесса лишает группу процессов главы и если любой из такой группы процессов остановлен, то каждому процессу в группе посылается сигнал B<SIGHUP> с последующим B<SIGCONT>. Осиротевшей считается группа процессов, у которой родитель каждого члена группы процессов сам является членом группы процессов или членом группы процессов другого сеанса (см. также B<credentials>(7))."

#. type: Plain text
#: man-pages/man2/setpgid.2:346
msgid ""
"B<getuid>(2), B<setsid>(2), B<tcgetpgrp>(3), B<tcsetpgrp>(3), B<termios>(3),"
" B<credentials>(7)"
msgstr "B<getuid>(2), B<setsid>(2), B<tcgetpgrp>(3), B<tcsetpgrp>(3), B<termios>(3), B<credentials>(7)"

#. type: TH
#: man-pages/man2/sigpending.2:29
#, no-wrap
msgid "SIGPENDING"
msgstr "SIGPENDING"

#. type: TH
#: man-pages/man2/sigpending.2:29
#, no-wrap
msgid "2013-12-11"
msgstr "2013-12-11"

#. type: Plain text
#: man-pages/man2/sigpending.2:32
msgid "sigpending - examine pending signals"
msgstr "sigpending - проверка ожидающих сигналов"

#. type: Plain text
#: man-pages/man2/sigpending.2:34
msgid "B<#include E<lt>signal.hE<gt>>"
msgstr "B<#include E<lt>signal.hE<gt>>"

#. type: Plain text
#: man-pages/man2/sigpending.2:36
msgid "B<int sigpending(sigset_t *>I<set>B<);>"
msgstr "B<int sigpending(sigset_t *>I<set>B<);>"

#. type: Plain text
#: man-pages/man2/sigpending.2:45
msgid ""
"B<sigpending>(): _POSIX_C_SOURCE\\ E<gt>=\\ 1 || _XOPEN_SOURCE || "
"_POSIX_SOURCE"
msgstr "B<sigpending>(): _POSIX_C_SOURCE\\ E<gt>=\\ 1 || _XOPEN_SOURCE || _POSIX_SOURCE"

#. type: Plain text
#: man-pages/man2/sigpending.2:53
msgid ""
"B<sigpending>()  returns the set of signals that are pending for delivery to"
" the calling thread (i.e., the signals which have been raised while "
"blocked).  The mask of pending signals is returned in I<set>."
msgstr "Вызов B<sigpending>() возвращает набор сигналов, которые ожидают доставки в вызвавшую нить (т.е., сигналы, возникшие пока были заблокированы). Маска ожидающих сигналов возвращается в I<set>."

#. type: Plain text
#: man-pages/man2/sigpending.2:59
msgid ""
"B<sigpending>()  returns 0 on success and -1 on error.  In the event of an "
"error, I<errno> is set to indicate the cause."
msgstr "При успешном выполнении функция B<sigpending>() возвращает 0 и -1 при ошибке. В случае ошибки в I<errno> указывается номер ошибки."

#. type: Plain text
#: man-pages/man2/sigpending.2:64
msgid ""
"I<set> points to memory which is not a valid part of the process address "
"space."
msgstr "Аргумент I<set> указывает на память в недопустимой части адресуемого пространства."

#. type: Plain text
#: man-pages/man2/sigpending.2:70
msgid "See B<sigsetops>(3)  for details on manipulating signal sets."
msgstr "Подробная информация о работе с наборами сигналов есть на странице B<sigsetops>(3)."

#. type: Plain text
#: man-pages/man2/sigpending.2:74
msgid ""
"If a signal is both blocked and has a disposition of \"ignored\", it is "
"I<not> added to the mask of pending signals when generated."
msgstr "Если сигнал заблокирован и имеет обработчик «игнорировать», то он I<не> добавляется в маску ожидающих сигналов при генерации."

#. type: Plain text
#: man-pages/man2/sigpending.2:79
msgid ""
"The set of signals that is pending for a thread is the union of the set of "
"signals that is pending for that thread and the set of signals that is "
"pending for the process as a whole; see B<signal>(7)."
msgstr "Набор сигналов, ожидающих обработки в нити, представляет собой объединение набора сигналов, ожидающих обработки в этой нити и набора сигналов, ожидающих обработки всем процессом (см. B<signal>(7))."

#. type: Plain text
#: man-pages/man2/sigpending.2:91
msgid ""
"In versions of glibc up to and including 2.2.1, there is a bug in the "
"wrapper function for B<sigpending>()  which means that information about "
"pending real-time signals is not correctly returned."
msgstr "В версиях glibc до 2.2.1 включительно, был дефект в обёрточной функции к B<sigpending>(), из-за которого возвращалась некорректная информация об ожидающих сигналах реального времени."

#. type: Plain text
#: man-pages/man2/sigpending.2:98
msgid ""
"B<kill>(2), B<sigaction>(2), B<signal>(2), B<sigprocmask>(2), "
"B<sigsuspend>(2), B<sigsetops>(3), B<signal>(7)"
msgstr "B<kill>(2), B<sigaction>(2), B<signal>(2), B<sigprocmask>(2), B<sigsuspend>(2), B<sigsetops>(3), B<signal>(7)"

#. type: TH
#: man-pages/man2/socketcall.2:25
#, no-wrap
msgid "SOCKETCALL"
msgstr "SOCKETCALL"

#. type: TH
#: man-pages/man2/socketcall.2:25
#, no-wrap
msgid "2012-10-16"
msgstr "2012-10-16"

#. type: Plain text
#: man-pages/man2/socketcall.2:28
msgid "socketcall - socket system calls"
msgstr "socketcall - системные вызовы сокетов"

#. type: Plain text
#: man-pages/man2/socketcall.2:30
msgid "B<int socketcall(int >I<call>B<, unsigned long *>I<args>B<);>"
msgstr "B<int socketcall(int >I<call>B<, unsigned long *>I<args>B<);>"

#. type: Plain text
#: man-pages/man2/socketcall.2:38
msgid ""
"B<socketcall>()  is a common kernel entry point for the socket system calls."
"  I<call> determines which socket function to invoke.  I<args> points to a "
"block containing the actual arguments, which are passed through to the "
"appropriate call."
msgstr "B<socketcall>() \\(em это общая точка входа в ядро всех системных вызовов сокетов. В аргументе I<call> задаётся функция сокета, которая будет вызвана. Аргумент I<args> указывает на блок параметров функции, которые передаются соответствующему вызову."

#. type: Plain text
#: man-pages/man2/socketcall.2:42
msgid ""
"User programs should call the appropriate functions by their usual names.  "
"Only standard library implementors and kernel hackers need to know about "
"B<socketcall>()."
msgstr "Пользовательские программы должны оперировать обычными функциями, имеющими стандартные имена. О существовании B<socketcall>() необходимо знать лишь создателям стандартных библиотек и ядра."

#. type: Plain text
#: man-pages/man2/socketcall.2:45
msgid ""
"This call is specific to Linux, and should not be used in programs intended "
"to be portable."
msgstr "Эта функция есть только в Linux, и она не должна использоваться в переносимых программах."

#. type: Plain text
#: man-pages/man2/socketcall.2:53
msgid ""
"On a some architectures\\(emfor example, x86-64 and ARM\\(emthere is no "
"B<socketcall>()  system call; instead B<socket>(2), B<accept>(2), "
"B<bind>(2), and so on really are implemented as separate system calls."
msgstr "На некоторых архитектурах, например x86-64 и ARM, нет системного вызова B<socketcall>(); вместо него реализованы системные вызовы B<socket>(2), B<accept>(2), B<bind>(2) и т.д."

#. type: Plain text
#: man-pages/man2/socketcall.2:70
msgid ""
"B<accept>(2), B<bind>(2), B<connect>(2), B<getpeername>(2), "
"B<getsockname>(2), B<getsockopt>(2), B<listen>(2), B<recv>(2), "
"B<recvfrom>(2), B<recvmsg>(2), B<send>(2), B<sendmsg>(2), B<sendto>(2), "
"B<setsockopt>(2), B<shutdown>(2), B<socket>(2), B<socketpair>(2)"
msgstr "B<accept>(2), B<bind>(2), B<connect>(2), B<getpeername>(2), B<getsockname>(2), B<getsockopt>(2), B<listen>(2), B<recv>(2), B<recvfrom>(2), B<recvmsg>(2), B<send>(2), B<sendmsg>(2), B<sendto>(2), B<setsockopt>(2), B<shutdown>(2), B<socket>(2), B<socketpair>(2)"

#. type: TH
#: man-pages/man2/shmop.2:41
#, no-wrap
msgid "SHMOP"
msgstr "SHMOP"

#. type: Plain text
#: man-pages/man2/shmop.2:44
msgid "shmat, shmdt - System V shared memory operations"
msgstr "shmat, shmdt - операции с общей памятью System V"

#. type: Plain text
#: man-pages/man2/shmop.2:48
#, no-wrap
msgid ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>sys/shm.hE<gt>>\n"
msgstr "B<#include E<lt>sys/types.hE<gt>>\nB<#include E<lt>sys/shm.hE<gt>>\n"

#. type: Plain text
#: man-pages/man2/shmop.2:50
#, no-wrap
msgid ""
"B<void *shmat(int >I<shmid>B<, const void *>I<shmaddr>B<, int "
">I<shmflg>B<);>\n"
msgstr "B<void *shmat(int >I<shmid>B<, const void *>I<shmaddr>B<, int >I<shmflg>B<);>\n"

#. type: Plain text
#: man-pages/man2/shmop.2:52
#, no-wrap
msgid "B<int shmdt(const void *>I<shmaddr>B<);>\n"
msgstr "B<int shmdt(const void *>I<shmaddr>B<);>\n"

#. type: SS
#: man-pages/man2/shmop.2:54
#, no-wrap
msgid "shmat()"
msgstr "shmat()"

#. type: Plain text
#: man-pages/man2/shmop.2:62
msgid ""
"B<shmat>()  attaches the System\\ V shared memory segment identified by "
"I<shmid> to the address space of the calling process.  The attaching address"
" is specified by I<shmaddr> with one of the following criteria:"
msgstr "Вызов B<shmat>() подключает сегмент общей памяти System\\ V с идентификатором I<shmid> к адресному пространству вызывающего процесса. Адрес подключения, указанный в I<shmaddr>, учитывается следующим образом:"

#. type: Plain text
#: man-pages/man2/shmop.2:68
msgid ""
"If I<shmaddr> is NULL, the system chooses a suitable (unused) address at "
"which to attach the segment."
msgstr "Если значение I<shmaddr> равно NULL, то система выбирает подходящий (неиспользуемый) адрес для подключения сегмента."

#. type: Plain text
#: man-pages/man2/shmop.2:80
msgid ""
"If I<shmaddr> isn't NULL and B<SHM_RND> is specified in I<shmflg>, the "
"attach occurs at the address equal to I<shmaddr> rounded down to the nearest"
" multiple of B<SHMLBA>."
msgstr "Если значение I<shmaddr> не равно NULL, а в I<shmflg> указан флаг B<SHM_RND>, то подключение производится по адресу I<shmaddr>, округлённому до ближайшего значения кратного B<SHMLBA>."

#. type: Plain text
#: man-pages/man2/shmop.2:84
msgid ""
"Otherwise, I<shmaddr> must be a page-aligned address at which the attach "
"occurs."
msgstr "В противном случае I<shmaddr> должно быть выровнено по адресу страницы, к которому производится подключение."

#. type: Plain text
#: man-pages/man2/shmop.2:90
msgid ""
"In addition to B<SHM_RND>, the following flags may be specified in the "
"I<shmflg> bit-mask argument:"
msgstr "В дополнении к B<SHM_RND>, в аргументе битовой маски I<shmflg> могут быть указаны следующие флаги:"

#. type: TP
#: man-pages/man2/shmop.2:90
#, no-wrap
msgid "B<SHM_EXEC> (Linux-specific; since Linux 2.6.9)"
msgstr "B<SHM_EXEC> (есть только в Linux; начиная с Linux 2.6.9)"

#. type: Plain text
#: man-pages/man2/shmop.2:94
msgid ""
"Allow the contents of the segment to be executed.  The caller must have "
"execute permission on the segment."
msgstr "Разрешить выполнение содержимого сегмента. Вызывающий должен иметь права на выполнение сегмента."

#. type: TP
#: man-pages/man2/shmop.2:94
#, no-wrap
msgid "B<SHM_RDONLY>"
msgstr "B<SHM_RDONLY>"

#. type: Plain text
#: man-pages/man2/shmop.2:102
msgid ""
"Attach the segment for read-only access.  The process must have read "
"permission for the segment.  If this flag is not specified, the segment is "
"attached for read and write access, and the process must have read and write"
" permission for the segment.  There is no notion of a write-only shared "
"memory segment."
msgstr "Разрешить доступ к сегменту только для чтения. Процесс должен иметь права на чтение сегмента. Если этот флаг не указан, то сегмент подключается с правом чтения и записи, и процесс должен иметь права на чтение и запись сегмента. Об общих сегментах памяти, доступных только на запись, ничего не упоминается."

#. type: TP
#: man-pages/man2/shmop.2:102
#, no-wrap
msgid "B<SHM_REMAP> (Linux-specific)"
msgstr "B<SHM_REMAP> (есть только в Linux)"

#. type: Plain text
#: man-pages/man2/shmop.2:115
msgid ""
"This flag specifies that the mapping of the segment should replace any "
"existing mapping in the range starting at I<shmaddr> and continuing for the "
"size of the segment.  (Normally, an B<EINVAL> error would result if a "
"mapping already exists in this address range.)  In this case, I<shmaddr> "
"must not be NULL."
msgstr "Этот флаг указывает, что отображение сегмента должно замещать любые существующие отображения в диапазоне, начиная с I<shmaddr> и до размера сегмента (обычно выдается ошибка B<EINVAL>, если в этом диапазоне адресов уже есть отображение). В этом случае значение I<shmaddr> не должно быть равно NULL."

#. type: Plain text
#: man-pages/man2/shmop.2:122
msgid ""
"The B<brk>(2)  value of the calling process is not altered by the attach.  "
"The segment will automatically be detached at process exit.  The same "
"segment may be attached as a read and as a read-write one, and more than "
"once, in the process's address space."
msgstr "Значение B<brk>(2) вызывающего процесса от подключения не изменяется. При завершении работы процесса сегмент будет автоматически отсоединён. Один и тот же сегмент может быть подключён в адресное пространство процесса несколько раз, как только для чтения, так и для чтения-записи."

#. type: Plain text
#: man-pages/man2/shmop.2:130
msgid ""
"A successful B<shmat>()  call updates the members of the I<shmid_ds> "
"structure (see B<shmctl>(2))  associated with the shared memory segment as "
"follows:"
msgstr "При успешном выполнении системный вызов B<shmat>() обновляет поля структуры I<shmid_ds> (см. B<shmctl>(2)), связанной с общим сегментом памяти, следующим образом:"

#. type: Plain text
#: man-pages/man2/shmop.2:133
msgid "I<shm_atime> is set to the current time."
msgstr "Полю I<shm_atime> присваивается значение текущего времени."

#. type: Plain text
#: man-pages/man2/shmop.2:136 man-pages/man2/shmop.2:163
msgid "I<shm_lpid> is set to the process-ID of the calling process."
msgstr "Значение I<shm_lpid> устанавливается равным идентификатору вызывающего процесса."

#. type: Plain text
#: man-pages/man2/shmop.2:140
msgid "I<shm_nattch> is incremented by one."
msgstr "Значение I<shm_nattch> увеличивается на 1."

#. type: SS
#: man-pages/man2/shmop.2:140
#, no-wrap
msgid "shmdt()"
msgstr "shmdt()"

#. type: Plain text
#: man-pages/man2/shmop.2:151
msgid ""
"B<shmdt>()  detaches the shared memory segment located at the address "
"specified by I<shmaddr> from the address space of the calling process.  The "
"to-be-detached segment must be currently attached with I<shmaddr> equal to "
"the value returned by the attaching B<shmat>()  call."
msgstr "Вызов B<shmdt>() отключает сегмент общей памяти, находящийся по адресу I<shmaddr>, от адресного пространства вызывающего процесса. Отключаемый сегмент должен быть подключён по адресу I<shmaddr> с помощью вызова B<shmat>()."

#. type: Plain text
#: man-pages/man2/shmop.2:157
msgid ""
"On a successful B<shmdt>()  call, the system updates the members of the "
"I<shmid_ds> structure associated with the shared memory segment as follows:"
msgstr "При успешном выполнении вызов B<shmdt>() обновляет поля структуры I<shmid_ds>, связанной с общим сегментом памяти, следующим образом:"

#. type: Plain text
#: man-pages/man2/shmop.2:160
msgid "I<shm_dtime> is set to the current time."
msgstr "Полю I<shm_dtime> присваивается значение текущего времени."

#. type: Plain text
#: man-pages/man2/shmop.2:168
msgid ""
"I<shm_nattch> is decremented by one.  If it becomes 0 and the segment is "
"marked for deletion, the segment is deleted."
msgstr "Значение I<shm_nattch> уменьшается на 1. Если оно становится равным 0 и сегмент помечен для удаления, то сегмент удаляется."

#. type: Plain text
#: man-pages/man2/shmop.2:176
msgid ""
"On success, B<shmat>()  returns the address of the attached shared memory "
"segment; on error, I<(void\\ *)\\ -1> is returned, and I<errno> is set to "
"indicate the cause of the error."
msgstr "При успешном выполнении B<shmat>() возвращается адрес подключённого общего сегмента памяти; при ошибке возвращается I<(void\\ *)\\ -1>, а в I<errno> содержится код ошибки."

#. type: Plain text
#: man-pages/man2/shmop.2:182
msgid ""
"On success, B<shmdt>()  returns 0; on error -1 is returned, and I<errno> is "
"set to indicate the cause of the error."
msgstr "При успешном выполнении B<shmdt>() возвращается 0; при ошибке возвращается -1, а в I<errno> содержится код ошибки."

#. type: Plain text
#: man-pages/man2/shmop.2:188
msgid "When B<shmat>()  fails, I<errno> is set to one of the following:"
msgstr "Значения I<errno>, устанавливаемые при возникновении ошибок в B<shmat>():"

#. type: Plain text
#: man-pages/man2/shmop.2:194
msgid ""
"The calling process does not have the required permissions for the requested"
" attach type, and does not have the B<CAP_IPC_OWNER> capability."
msgstr "Вызывающий процесс не имеет прав для подключения заданного типа и не имеет мандата B<CAP_IPC_OWNER>."

#. type: Plain text
#: man-pages/man2/shmop.2:211
msgid ""
"Invalid I<shmid> value, unaligned (i.e., not page-aligned and B<SHM_RND> was"
" not specified) or invalid I<shmaddr> value, or can't attach segment at "
"I<shmaddr>, or B<SHM_REMAP> was specified and I<shmaddr> was NULL."
msgstr "Неправильное значение I<shmid>, не выровненное (по границе страницы и не указан B<SHM_RND>) или неправильное значение I<shmaddr>, или невозможно подключить сегмент по адресу I<shmaddr>, или был указан B<SHM_REMAP>, но I<shmaddr> равно NULL."

#. type: Plain text
#: man-pages/man2/shmop.2:214
msgid "Could not allocate memory for the descriptor or for the page tables."
msgstr "Невозможно выделить память для дескриптора или страничных таблиц."

#. type: Plain text
#: man-pages/man2/shmop.2:220
msgid "When B<shmdt>()  fails, I<errno> is set as follows:"
msgstr "Значения I<errno>, устанавливаемые при возникновении ошибок в B<shmdt>():"

#.  The following since 2.6.17-rc1:
#. type: Plain text
#: man-pages/man2/shmop.2:228
msgid ""
"There is no shared memory segment attached at I<shmaddr>; or, I<shmaddr> is "
"not aligned on a page boundary."
msgstr "По адресу I<shmaddr> подключённый общий сегмент памяти отсутствует; или значение I<shmaddr> не выровнено по границе страницы."

#. type: Plain text
#: man-pages/man2/shmop.2:247
msgid ""
"In SVID 3 (or perhaps earlier), the type of the I<shmaddr> argument was "
"changed from I<char\\ *> into I<const void\\ *>, and the returned type of "
"B<shmat>()  from I<char\\ *> into I<void\\ *>.  (Linux libc4 and libc5 have "
"the I<char\\ *> prototypes; glibc2 has I<void\\ *>.)"
msgstr "В SVID 3 (или, возможно, более ранних версиях)  тип аргумента I<shmaddr> был изменён с I<char\\ *> на I<const void\\ *>, а тип результата B<shmat>() — с I<char\\ *> на I<void\\ *> (в Linux libc4 и libc5 прототипы определены с I<char\\ *>; в glibc2 — I<void\\ *>)."

#. type: Plain text
#: man-pages/man2/shmop.2:252
msgid ""
"After a B<fork>(2), the child inherits the attached shared memory segments."
msgstr "При вызове B<fork>(2) потомки наследуют подключённые общие сегменты памяти."

#. type: Plain text
#: man-pages/man2/shmop.2:256
msgid ""
"After an B<execve>(2), all attached shared memory segments are detached from"
" the process."
msgstr "При вызове B<execve>(2) все подключённые общие сегменты памяти отключаются."

#. type: Plain text
#: man-pages/man2/shmop.2:260
msgid ""
"Upon B<_exit>(2), all attached shared memory segments are detached from the "
"process."
msgstr "При вызове B<_exit>(2) все подключённые общие сегменты памяти отключаются."

#. type: Plain text
#: man-pages/man2/shmop.2:272
msgid ""
"Using B<shmat>()  with I<shmaddr> equal to NULL is the preferred, portable "
"way of attaching a shared memory segment.  Be aware that the shared memory "
"segment attached in this way may be attached at different addresses in "
"different processes.  Therefore, any pointers maintained within the shared "
"memory must be made relative (typically to the starting address of the "
"segment), rather than absolute."
msgstr "Для улучшения переносимости программ при подключении общего сегмента памяти рекомендуется использовать B<shmat>() с аргументом I<shmaddr>, установленным в NULL. Необходимо учитывать, что сегмент памяти, подключаемый таким способом, в разных процессах может подключаться по разным адресам. Поэтому все указатели в области общей памяти должны быть не абсолютными, а относительными (как правило относительно адреса начала сегмента)."

#. type: Plain text
#: man-pages/man2/shmop.2:277
msgid ""
"On Linux, it is possible to attach a shared memory segment even if it is "
"already marked to be deleted.  However, POSIX.1-2001 does not specify this "
"behavior and many other implementations do not support it."
msgstr "В Linux сегмент общей памяти можно подключить даже если он помечен для удаление. Однако в POSIX.1-2001 об этом ничего не сказано и многие другие реализации это не поддерживают."

#. type: Plain text
#: man-pages/man2/shmop.2:280
msgid "The following system parameter affects B<shmat>():"
msgstr "На работу B<shmat>() влияют следующие системные параметры:"

#.  FIXME A good explanation of the rationale for the existence
#.  of SHMLBA would be useful here
#. type: TP
#: man-pages/man2/shmop.2:280
#, no-wrap
msgid "B<SHMLBA>"
msgstr "B<SHMLBA>"

#. type: Plain text
#: man-pages/man2/shmop.2:295
msgid ""
"Segment low boundary address multiple.  When explicitly specifying an attach"
" address in a call to B<shmat>(), the caller should ensure that the address "
"is a multiple of this value.  This is necessary on some architectures, in "
"order either to ensure good CPU cache performance or to ensure that "
"different attaches of the same segment have consistent views within the CPU "
"cache.  B<SHMLBA> is normally some multiple of the system page size (on many"
" Linux architectures, it is the same as the system page size)."
msgstr ""

#. type: Plain text
#: man-pages/man2/shmop.2:299
msgid ""
"The implementation places no intrinsic per-process limit on the number of "
"shared memory segments (B<SHMSEG>)."
msgstr "Реализацией не ограничивается количество общих сегментов общей памяти на процесс (B<SHMSEG>)."

#. type: Plain text
#: man-pages/man2/shmop.2:306
msgid ""
"B<brk>(2), B<mmap>(2), B<shmctl>(2), B<shmget>(2), B<capabilities>(7), "
"B<shm_overview>(7), B<svipc>(7)"
msgstr "B<brk>(2), B<mmap>(2), B<shmctl>(2), B<shmget>(2), B<capabilities>(7), B<shm_overview>(7), B<svipc>(7)"

#. type: TH
#: man-pages/man2/sync_file_range.2:30
#, no-wrap
msgid "SYNC_FILE_RANGE"
msgstr "SYNC_FILE_RANGE"

#. type: TH
#: man-pages/man2/sync_file_range.2:30
#, no-wrap
msgid "2013-04-01"
msgstr "2013-04-01"

#. type: Plain text
#: man-pages/man2/sync_file_range.2:33
msgid "sync_file_range - sync a file segment with disk"
msgstr ""

#. type: Plain text
#: man-pages/man2/sync_file_range.2:37
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>         /* See feature_test_macros(7) */\n"
"B<#include E<lt>fcntl.hE<gt>>\n"
msgstr "B<#define _GNU_SOURCE>         /* см. feature_test_macros(7) */\nB<#include E<lt>fcntl.hE<gt>>\n"

#. type: Plain text
#: man-pages/man2/sync_file_range.2:40
#, no-wrap
msgid ""
"B<int sync_file_range(int >I<fd>B<, off64_t >I<offset>B<, off64_t >I<nbytes>B<,>\n"
"B<                    unsigned int >I<flags>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/sync_file_range.2:47
msgid ""
"B<sync_file_range>()  permits fine control when synchronizing the open file "
"referred to by the file descriptor I<fd> with disk."
msgstr ""

#. type: Plain text
#: man-pages/man2/sync_file_range.2:61
msgid ""
"I<offset> is the starting byte of the file range to be synchronized.  "
"I<nbytes> specifies the length of the range to be synchronized, in bytes; if"
" I<nbytes> is zero, then all bytes from I<offset> through to the end of file"
" are synchronized.  Synchronization is in units of the system page size: "
"I<offset> is rounded down to a page boundary; I<(offset+nbytes-1)> is "
"rounded up to a page boundary."
msgstr ""

#. type: Plain text
#: man-pages/man2/sync_file_range.2:65
msgid ""
"The I<flags> bit-mask argument can include any of the following values:"
msgstr ""

#. type: TP
#: man-pages/man2/sync_file_range.2:65
#, no-wrap
msgid "B<SYNC_FILE_RANGE_WAIT_BEFORE>"
msgstr ""

#. type: Plain text
#: man-pages/man2/sync_file_range.2:70
msgid ""
"Wait upon write-out of all pages in the specified range that have already "
"been submitted to the device driver for write-out before performing any "
"write."
msgstr ""

#. type: TP
#: man-pages/man2/sync_file_range.2:70 man-pages/man2/sync_file_range.2:120
#, no-wrap
msgid "B<SYNC_FILE_RANGE_WRITE>"
msgstr ""

#. type: Plain text
#: man-pages/man2/sync_file_range.2:76
msgid ""
"Initiate write-out of all dirty pages in the specified range which are not "
"presently submitted write-out.  Note that even this may block if you attempt"
" to write more than request queue size."
msgstr ""

#. type: TP
#: man-pages/man2/sync_file_range.2:76
#, no-wrap
msgid "B<SYNC_FILE_RANGE_WAIT_AFTER>"
msgstr ""

#. type: Plain text
#: man-pages/man2/sync_file_range.2:80
msgid ""
"Wait upon write-out of all pages in the range after performing any write."
msgstr ""

#. type: Plain text
#: man-pages/man2/sync_file_range.2:84
msgid "Specifying I<flags> as 0 is permitted, as a no-op."
msgstr ""

#. type: SS
#: man-pages/man2/sync_file_range.2:84
#, no-wrap
msgid "Warning"
msgstr ""

#. type: Plain text
#: man-pages/man2/sync_file_range.2:100
msgid ""
"This system call is extremely dangerous and should not be used in portable "
"programs.  None of these operations writes out the file's metadata.  "
"Therefore, unless the application is strictly performing overwrites of "
"already-instantiated disk blocks, there are no guarantees that the data will"
" be available after a crash.  There is no user interface to know if a write "
"is purely an overwrite.  On filesystems using copy-on-write semantics (e.g.,"
" I<btrfs>)  an overwrite of existing allocated blocks is impossible.  When "
"writing into preallocated space, many filesystems also require calls into "
"the block allocator, which this system call does not sync out to disk.  This"
" system call does not flush disk write caches and thus does not provide any "
"data integrity on systems with volatile disk write caches."
msgstr ""

#. type: SS
#: man-pages/man2/sync_file_range.2:100
#, no-wrap
msgid "Some details"
msgstr ""

#. type: Plain text
#: man-pages/man2/sync_file_range.2:108
msgid ""
"B<SYNC_FILE_RANGE_WAIT_BEFORE> and B<SYNC_FILE_RANGE_WAIT_AFTER> will detect"
" any I/O errors or B<ENOSPC> conditions and will return these to the caller."
msgstr ""

#. type: Plain text
#: man-pages/man2/sync_file_range.2:112
msgid "Useful combinations of the I<flags> bits are:"
msgstr ""

#. type: TP
#: man-pages/man2/sync_file_range.2:112
#, no-wrap
msgid "B<SYNC_FILE_RANGE_WAIT_BEFORE | SYNC_FILE_RANGE_WRITE>"
msgstr ""

#. type: Plain text
#: man-pages/man2/sync_file_range.2:120
msgid ""
"Ensures that all pages in the specified range which were dirty when "
"B<sync_file_range>()  was called are placed under write-out.  This is a "
"start-write-for-data-integrity operation."
msgstr ""

#. type: Plain text
#: man-pages/man2/sync_file_range.2:127
msgid ""
"Start write-out of all dirty pages in the specified range which are not "
"presently under write-out.  This is an asynchronous flush-to-disk operation."
"  This is not suitable for data integrity operations."
msgstr ""

#. type: TP
#: man-pages/man2/sync_file_range.2:127
#, no-wrap
msgid "B<SYNC_FILE_RANGE_WAIT_BEFORE> (or B<SYNC_FILE_RANGE_WAIT_AFTER>)"
msgstr ""

#. type: Plain text
#: man-pages/man2/sync_file_range.2:134
msgid ""
"Wait for completion of write-out of all pages in the specified range.  This "
"can be used after an earlier B<SYNC_FILE_RANGE_WAIT_BEFORE | "
"SYNC_FILE_RANGE_WRITE> operation to wait for completion of that operation, "
"and obtain its result."
msgstr ""

#. type: TP
#: man-pages/man2/sync_file_range.2:134
#, no-wrap
msgid ""
"B<SYNC_FILE_RANGE_WAIT_BEFORE | SYNC_FILE_RANGE_WRITE | "
"SYNC_FILE_RANGE_WAIT_AFTER>"
msgstr "B<SYNC_FILE_RANGE_WAIT_BEFORE | SYNC_FILE_RANGE_WRITE | SYNC_FILE_RANGE_WAIT_AFTER>"

#. type: Plain text
#: man-pages/man2/sync_file_range.2:141
msgid ""
"This is a write-for-data-integrity operation that will ensure that all pages"
" in the specified range which were dirty when B<sync_file_range>()  was "
"called are committed to disk."
msgstr ""

#. type: Plain text
#: man-pages/man2/sync_file_range.2:147
msgid ""
"On success, B<sync_file_range>()  returns 0; on failure -1 is returned and "
"I<errno> is set to indicate the error."
msgstr ""

#. type: Plain text
#: man-pages/man2/sync_file_range.2:152
msgid "I<fd> is not a valid file descriptor."
msgstr "Значение I<fd> не является правильным файловым дескриптором."

#. type: Plain text
#: man-pages/man2/sync_file_range.2:160
msgid ""
"I<flags> specifies an invalid bit; or I<offset> or I<nbytes> is invalid."
msgstr ""

#. type: Plain text
#: man-pages/man2/sync_file_range.2:163
msgid "I/O error."
msgstr "Ошибка ввода-вывода."

#. type: Plain text
#: man-pages/man2/sync_file_range.2:166
msgid "Out of memory."
msgstr "Не хватает памяти."

#. type: Plain text
#: man-pages/man2/sync_file_range.2:169
msgid "Out of disk space."
msgstr ""

#. type: TP
#: man-pages/man2/sync_file_range.2:169
#, no-wrap
msgid "B<ESPIPE>"
msgstr "B<ESPIPE>"

#.  FIXME . (bug?) Actually, how can 'fd' refer to a symbolic link (S_ISLNK)?
#.  (In user space at least) it isn't possible to obtain a file descriptor
#.  for a symbolic link.
#. type: Plain text
#: man-pages/man2/sync_file_range.2:177
msgid ""
"I<fd> refers to something other than a regular file, a block device, a "
"directory, or a symbolic link."
msgstr ""

#. type: Plain text
#: man-pages/man2/sync_file_range.2:180
msgid "B<sync_file_range>()  appeared on Linux in kernel 2.6.17."
msgstr ""

#. type: Plain text
#: man-pages/man2/sync_file_range.2:183
msgid ""
"This system call is Linux-specific, and should be avoided in portable "
"programs."
msgstr ""

#.  See kernel commit edd5cd4a9424f22b0fa08bef5e299d41befd5622
#. type: Plain text
#: man-pages/man2/sync_file_range.2:200
msgid ""
"Some architectures (e.g., PowerPC, ARM)  need 64-bit arguments to be aligned"
" in a suitable pair of registers.  On such architectures, the call signature"
" of B<sync_file_range>()  shown in the SYNOPSIS would force a register to be"
" wasted as padding between the I<fd> and I<offset> arguments.  (See "
"B<syscall>(2)  for details.)  Therefore, these architectures define a "
"different system call that orders the arguments suitably:"
msgstr ""

#. type: Plain text
#: man-pages/man2/sync_file_range.2:205
#, no-wrap
msgid ""
"B<int sync_file_range2(int >I<fd>B<, unsigned int >I<flags>B<,>\n"
"B<                     off64_t >I<offset>B<, off64_t >I<nbytes>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/sync_file_range.2:210
msgid ""
"The behavior of this system call is otherwise exactly the same as "
"B<sync_file_range>()."
msgstr ""

#. type: Plain text
#: man-pages/man2/sync_file_range.2:221
msgid ""
"A system call with this signature first appeared on the ARM architecture in "
"Linux 2.6.20, with the name B<arm_sync_file_range>().  It was renamed in "
"Linux 2.6.22, when the analogous system call was added for PowerPC.  On "
"architectures where glibc support is provided, glibc transparently wraps "
"B<sync_file_range2>()  under the name B<sync_file_range>()."
msgstr ""

#. type: Plain text
#: man-pages/man2/sync_file_range.2:225
msgid "B<fdatasync>(2), B<fsync>(2), B<msync>(2), B<sync>(2)"
msgstr "B<fdatasync>(2), B<fsync>(2), B<msync>(2), B<sync>(2)"

#. type: TH
#: man-pages/man2/sigwaitinfo.2:25
#, no-wrap
msgid "SIGWAITINFO"
msgstr "SIGWAITINFO"

#. type: TH
#: man-pages/man2/sigwaitinfo.2:25
#, no-wrap
msgid "2013-09-04"
msgstr "2013-09-04"

#. type: Plain text
#: man-pages/man2/sigwaitinfo.2:28
msgid "sigwaitinfo, sigtimedwait - synchronously wait for queued signals"
msgstr "sigwaitinfo, sigtimedwait - синхронно ожидать запрошенные сигналы"

#. type: Plain text
#: man-pages/man2/sigwaitinfo.2:31
#, no-wrap
msgid "B<#include E<lt>signal.hE<gt>>\n"
msgstr "B<#include E<lt>signal.hE<gt>>\n"

#. type: Plain text
#: man-pages/man2/sigwaitinfo.2:33
#, no-wrap
msgid "B<int sigwaitinfo(const sigset_t *>I<set>B<, siginfo_t *>I<info>B<);>\n"
msgstr "B<int sigwaitinfo(const sigset_t *>I<set>B<, siginfo_t *>I<info>B<);>\n"

#. type: Plain text
#: man-pages/man2/sigwaitinfo.2:36
#, no-wrap
msgid ""
"B<int sigtimedwait(const sigset_t *>I<set>B<, siginfo_t *>I<info>B<, >\n"
"B<                 const struct timespec *>I<timeout>B<);>\n"
msgstr "B<int sigtimedwait(const sigset_t *>I<set>B<, siginfo_t *>I<info>B<, >\nB<                 const struct timespec *>I<timeout>B<);>\n"

#. type: Plain text
#: man-pages/man2/sigwaitinfo.2:46
msgid "B<sigwaitinfo>(), B<sigtimedwait>(): _POSIX_C_SOURCE\\ E<gt>=\\ 199309L"
msgstr "B<sigwaitinfo>(), B<sigtimedwait>(): _POSIX_C_SOURCE\\ E<gt>=\\ 199309L"

#. type: Plain text
#: man-pages/man2/sigwaitinfo.2:56
msgid ""
"B<sigwaitinfo>()  suspends execution of the calling thread until one of the "
"signals in I<set> is pending (If one of the signals in I<set> is already "
"pending for the calling thread, B<sigwaitinfo>()  will return immediately.)"
msgstr "B<sigwaitinfo>() приостанавливает исполнение вызывающий нити до тех пор, пока не будет ожидаться один из сигналов из набора I<set> (если один из сигналов в I<set> уже ожидает обработки вызывающей нитью, то B<sigwaitinfo>() завершит работу немедленно с возвратом информации об этом сигнале)."

#. type: Plain text
#: man-pages/man2/sigwaitinfo.2:68
msgid ""
"B<sigwaitinfo>()  removes the signal from the set of pending signals and "
"returns the signal number as its function result.  If the I<info> argument "
"is not NULL, then the buffer that it points to is used to return a structure"
" of type I<siginfo_t> (see B<sigaction>(2))  containing information about "
"the signal."
msgstr "B<sigwaitinfo>() удаляет сигнал из списка сигналов ожидающих обработки и возвращает номер сигнала как результат работы функции. Если аргумент I<info> не равен NULL, то в буфер, на который он указывает, записывается структура типа I<siginfo_t> (см. B<sigaction>(2)), содержащая информацию о сигнале."

#. type: Plain text
#: man-pages/man2/sigwaitinfo.2:76
msgid ""
"If multiple signals in I<set> are pending for the caller, the signal that is"
" retrieved by B<sigwaitinfo>()  is determined according to the usual "
"ordering rules; see B<signal>(7)  for further details."
msgstr "Если в I<set> ожидают обработки несколько сигналов, то сигнал, который получит B<sigwaitinfo>(), определяется согласно обычным правилам очерёдности; подробней смотрите в B<signal>(7)."

#. type: Plain text
#: man-pages/man2/sigwaitinfo.2:88
msgid ""
"B<sigtimedwait>()  operates in exactly the same way as B<sigwaitinfo>()  "
"except that it has an additional argument, I<timeout>, which specifies the "
"interval for which the thread is suspended waiting for a signal.  (This "
"interval will be rounded up to the system clock granularity, and kernel "
"scheduling delays mean that the interval may overrun by a small amount.)  "
"This argument is of the following type:"
msgstr "Системный вызов B<sigtimedwait>() работает аналогично B<sigwaitinfo>(), за исключением того, что он имеет дополнительный аргумент I<timeout>, задающий интервал,  на который приостанавливается процесс в ожидании сигнала. Данное значение интервала будет округлено до точности системных часов, а из-за задержки при планировании в ядре блокирующий интервал будет немного больше. Этот аргумент имеет следующий тип:"

#. type: Plain text
#: man-pages/man2/sigwaitinfo.2:95
#, no-wrap
msgid ""
"struct timespec {\n"
"    long    tv_sec;         /* seconds */\n"
"    long    tv_nsec;        /* nanoseconds */\n"
"}\n"
msgstr "struct timespec {\n    long    tv_sec;         /* секунды */\n    long    tv_nsec;        /* наносекунды */\n}\n"

#. type: Plain text
#: man-pages/man2/sigwaitinfo.2:105
msgid ""
"If both fields of this structure are specified as 0, a poll is performed: "
"B<sigtimedwait>()  returns immediately, either with information about a "
"signal that was pending for the caller, or with an error if none of the "
"signals in I<set> was pending."
msgstr "Если оба поля структуры равны 0, то исполняется опрос: B<sigtimedwait>() немедленно завершает работу, либо с информацией о сигнале, предназначенном вызывающему, либо с ошибкой, если ни один из сигналов в наборе I<set> не ожидает обработки."

#. type: Plain text
#: man-pages/man2/sigwaitinfo.2:114
msgid ""
"On success, both B<sigwaitinfo>()  and B<sigtimedwait>()  return a signal "
"number (i.e., a value greater than zero).  On failure both calls return -1, "
"with I<errno> set to indicate the error."
msgstr "При нормальном завершении работы B<sigwaitinfo>() и B<sigtimedwait>() возвращают номер сигнала (т.е. значение больше нуля). При ошибках оба вызова возвращают -1 и переменная I<errno> устанавливается соответственно ошибке."

#. type: TP
#: man-pages/man2/sigwaitinfo.2:115
#, no-wrap
msgid "B<EAGAIN>"
msgstr "B<EAGAIN>"

#. type: Plain text
#: man-pages/man2/sigwaitinfo.2:123
msgid ""
"No signal in I<set> was became pending within the I<timeout> period "
"specified to B<sigtimedwait>()."
msgstr "Ни одного сигнала в указанном наборе I<set> не появилось для обработки за время I<timeout>, указанном для B<sigtimedwait>()."

#. type: TP
#: man-pages/man2/sigwaitinfo.2:123
#, no-wrap
msgid "B<EINTR>"
msgstr "B<EINTR>"

#. type: Plain text
#: man-pages/man2/sigwaitinfo.2:129
msgid ""
"The wait was interrupted by a signal handler; see B<signal>(7).  (This "
"handler was for a signal other than one of those in I<set>.)"
msgstr "Ожидание было прервано обработчиком сигнала; см. B<signal>(7). (Этот обработчик был для другого сигнала, не из набора I<set>.)"

#. type: Plain text
#: man-pages/man2/sigwaitinfo.2:133
msgid "I<timeout> was invalid."
msgstr "Значение I<timeout> некорректно. "

#. type: Plain text
#: man-pages/man2/sigwaitinfo.2:153
msgid ""
"In normal usage, the calling program blocks the signals in I<set> via a "
"prior call to B<sigprocmask>(2)  (so that the default disposition for these "
"signals does not occur if they become pending between successive calls to "
"B<sigwaitinfo>()  or B<sigtimedwait>())  and does not establish handlers for"
" these signals.  In a multithreaded program, the signal should be blocked in"
" all threads, in order to prevent the signal being treated according to its "
"default disposition in a thread other than the one calling B<sigwaitinfo>()"
"  or B<sigtimedwait>())."
msgstr "При обычном использовании вызывающая программа блокирует сигналы в наборе I<set> через предыдущий вызов B<sigprocmask>(2) (для того, чтобы не сработали обработчики по умолчанию этих сигналов, если они появятся для обработки между последующими вызовами B<sigwaitinfo>() или B<sigtimedwait>()) и не устанавливает обработчики для этих сигналов. В многонитиевых программах сигнал должен быть заблокирован во всех нитях, чтобы предотвратить возврат сигнала нити, отличной от той, которая вызвала B<sigwaitinfo>() или B<sigtimedwait>())."

#. type: Plain text
#: man-pages/man2/sigwaitinfo.2:158
msgid ""
"The set of signals that is pending for a given thread is the union of the "
"set of signals that is pending specifically for that thread and the set of "
"signals that is pending for the process as a whole (see B<signal>(7))."
msgstr "Набор сигналов, ожидающих обработки в заданной нити, представляет собой объединение набора сигналов, ожидающих обработки именно в этой нити и набора сигналов, ожидающих обработки всем процессом (см. B<signal>(7))."

#. type: Plain text
#: man-pages/man2/sigwaitinfo.2:164
msgid "Attempts to wait for B<SIGKILL> and B<SIGSTOP> are silently ignored."
msgstr "Попытки ожидания B<SIGKILL> и B<SIGSTOP> просто игнорируются."

#. type: Plain text
#: man-pages/man2/sigwaitinfo.2:173
msgid ""
"If multiple threads of a process are blocked waiting for the same signal(s) "
"in B<sigwaitinfo>()  or B<sigtimedwait>(), then exactly one of the threads "
"will actually receive the signal if it becomes pending for the process as a "
"whole; which of the threads receives the signal is indeterminate."
msgstr "Если несколько нитей процесса заблокированы в ожидании одного сигнала(ов) в B<sigwaitinfo>() или B<sigtimedwait>(), то только одна нить действительно получит сигнал, если он станет доступен для ожидания всему процессу; какая именно нить примет сигнал неизвестно."

#. type: Plain text
#: man-pages/man2/sigwaitinfo.2:182
msgid ""
"POSIX leaves the meaning of a NULL value for the I<timeout> argument of "
"B<sigtimedwait>()  unspecified, permitting the possibility that this has the"
" same meaning as a call to B<sigwaitinfo>(), and indeed this is what is done"
" on Linux."
msgstr "POSIX оставляет неопределённое значение NULL в аргументе I<timeout> для B<sigtimedwait>(), допуская возможность того, что он имеет такое же значение, как и у вызова B<sigwaitinfo>(), и в самом деле это именно так в Linux."

#. type: Plain text
#: man-pages/man2/sigwaitinfo.2:187
msgid ""
"On Linux, B<sigwaitinfo>()  is a library function implemented on top of "
"B<sigtimedwait>()."
msgstr "В Linux, B<sigwaitinfo>() реализована в виде библиотечной функции, использующей B<sigtimedwait>()."

#. type: Plain text
#: man-pages/man2/sigwaitinfo.2:198
msgid ""
"B<kill>(2), B<sigaction>(2), B<signal>(2), B<signalfd>(2), B<sigpending>(2),"
" B<sigprocmask>(2), B<sigqueue>(3), B<sigsetops>(3), B<sigwait>(3), "
"B<signal>(7), B<time>(7)"
msgstr "B<kill>(2), B<sigaction>(2), B<signal>(2), B<signalfd>(2), B<sigpending>(2), B<sigprocmask>(2), B<sigqueue>(3), B<sigsetops>(3), B<sigwait>(3), B<signal>(7), B<time>(7)"

#. type: TH
#: man-pages/man2/syscall.2:40
#, no-wrap
msgid "SYSCALL"
msgstr "SYSCALL"

#. type: TH
#: man-pages/man2/syscall.2:40
#, no-wrap
msgid "2014-05-10"
msgstr "2014-05-10"

#. type: Plain text
#: man-pages/man2/syscall.2:43
msgid "syscall - indirect system call"
msgstr "syscall - непрямой системный вызов"

#. type: Plain text
#: man-pages/man2/syscall.2:48
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>         /* See feature_test_macros(7) */\n"
"B<#include E<lt>unistd.hE<gt>>\n"
"B<#include E<lt>sys/syscall.hE<gt>   >/* For SYS_xxx definitions */\n"
msgstr "B<#define _GNU_SOURCE>         /* см. feature_test_macros(7) */\nB<#include E<lt>unistd.hE<gt>>\nB<#include E<lt>sys/syscall.hE<gt>   >/* для определений SYS_xxx */\n"

#. type: Plain text
#: man-pages/man2/syscall.2:50
#, no-wrap
msgid "B<long syscall(long >I<number>B<, ...);>\n"
msgstr "B<long syscall(long >I<number>B<, ...);>\n"

#. type: Plain text
#: man-pages/man2/syscall.2:62
msgid ""
"B<syscall>()  is a small library function that invokes the system call whose"
" assembly language interface has the specified I<number> with the specified "
"arguments.  Employing B<syscall>()  is useful, for example, when invoking a "
"system call that has no wrapper function in the C library."
msgstr "B<syscall>() — это маленькая библиотечная функция, которая делает системный вызов, чей интерфейс ассемблерного языка  указывается в I<number>, с дополнительными аргументами. Выполнение B<syscall>() нужно, например, для запуска системного вызова, у которого нет обёрточной функции в библиотеке C."

#. type: Plain text
#: man-pages/man2/syscall.2:69
msgid ""
"B<syscall>()  saves CPU registers before making the system call, restores "
"the registers upon return from the system call, and stores any error code "
"returned by the system call in B<errno>(3)  if an error occurs."
msgstr "При вызове B<syscall>() сохраняет регистры ЦП до выполнения системного вызова, восстанавливает регистры при возврате из системного вызова и если возникла ошибка, то сохраняет любой код, полученный от системного вызова, в B<errno>(3)."

#. type: Plain text
#: man-pages/man2/syscall.2:72
msgid ""
"Symbolic constants for system call numbers can be found in the header file "
"I<E<lt>sys/syscall.hE<gt>>."
msgstr "Символьные константы для системных вызовов можно найти в заголовочном файле I<E<lt>sys/syscall.hE<gt>>."

#. type: Plain text
#: man-pages/man2/syscall.2:78
msgid ""
"The return value is defined by the system call being invoked.  In general, a"
" 0 return value indicates success.  A -1 return value indicates an error, "
"and an error code is stored in I<errno>."
msgstr "Возвращаемое значение определяется вызываемым системным вызовом. При успешном выполнении обычно возвращается 0. При ошибке возвращается -1, при этом код ошибки сохраняется в I<errno>."

#. type: Plain text
#: man-pages/man2/syscall.2:82
msgid "B<syscall>()  first appeared in 4BSD."
msgstr "Вызов B<syscall>() впервые появился в 4BSD."

#. type: SS
#: man-pages/man2/syscall.2:82
#, no-wrap
msgid "Architecture-specific requirements"
msgstr "Требования, зависящие от архитектуры"

#. type: Plain text
#: man-pages/man2/syscall.2:93
msgid ""
"Each architecture ABI has its own requirements on how system call arguments "
"are passed to the kernel.  For system calls that have a glibc wrapper (e.g.,"
" most system calls), glibc handles the details of copying arguments to the "
"right registers in a manner suitable for the architecture.  However, when "
"using B<syscall>()  to make a system call, the caller might need to handle "
"architecture-dependent details; this requirement is most commonly "
"encountered on certain 32-bit architectures."
msgstr "Каждый ABI архитектуры имеет свои собственные требования по передаче аргументов системного вызова в ядро. Для системных вызовов, имеющих обёртку в glibc (большинство системных вызовов), копирование аргументов в правильные регистры с учётом архитектуры выполняется в самой glibc. Однако при выполнении системного вызова через B<syscall>(), вызывающий сам должен учитывать особенности архитектуры; чаще всего это относится к 32-битным архитектурам."

#. type: Plain text
#: man-pages/man2/syscall.2:104
msgid ""
"For example, on the ARM architecture Embedded ABI (EABI), a 64-bit value "
"(e.g., I<long long>)  must be aligned to an even register pair.  Thus, using"
" B<syscall>()  instead of the wrapper provided by glibc, the B<readahead>()"
"  system call would be invoked as follows on the ARM architecture with the "
"EABI:"
msgstr "Например, на архитектуре ARM Embedded ABI (EABI) 64-битное значение (I<long long>) должно быть выровнено по чётной паре регистров. То есть, при использовании B<syscall>() вместо обёрточной функции glibc системный вызов B<readahead>() на ARM вызывался бы с учётом EABI следующим образом:"

#. type: Plain text
#: man-pages/man2/syscall.2:111
#, no-wrap
msgid ""
"syscall(SYS_readahead, fd, 0,\n"
"        (unsigned int) (offset E<gt>E<gt> 32),\n"
"        (unsigned int) (offset & 0xFFFFFFFF),\n"
"        count);\n"
msgstr "syscall(SYS_readahead, fd, 0,\n        (unsigned int) (offset E<gt>E<gt> 32),\n        (unsigned int) (offset & 0xFFFFFFFF),\n        count);\n"

#. type: Plain text
#: man-pages/man2/syscall.2:125
msgid ""
"Since the offset argument is 64 bits, and the first argument (I<fd>)  is "
"passed in I<r0>, the caller must manually split and align the 64-bit value "
"so that it is passed in the I<r2>/I<r3> register pair.  That means inserting"
" a dummy value into I<r1> (the second argument of 0)."
msgstr "Так как смещение аргумента 64 бита, и первый аргумент (I<fd>) передаётся в регистре I<r0>, вызывающий должен разделить и выровнять 64-битное значение так, чтобы оно передавалось в паре регистров I<r2>/I<r3>. Это выполняется вставкой пустого значения в I<r1> (второго аргумент 0)."

#.  Mike Frysinger: this issue ends up forcing MIPS
#.  O32 to take 7 arguments to syscall()
#. type: Plain text
#: man-pages/man2/syscall.2:130
msgid ""
"Similar issues can occur on MIPS with the O32 ABI, on PowerPC with the "
"32-bit ABI, and on Xtensa."
msgstr "Подобные сложности можно видеть на MIPS с O32 ABI, на PowerPC с 32-битным ABI и на Xtensa."

#. type: Plain text
#: man-pages/man2/syscall.2:141
msgid ""
"The affected system calls are B<fadvise64_64>(2), B<ftruncate64>(2), "
"B<posix_fadvise>(2), B<pread64>(2), B<pwrite64>(2), B<readahead>(2), "
"B<sync_file_range>(2), and B<truncate64>(2)."
msgstr "Это относится к системным вызовам B<fadvise64_64>(2), B<ftruncate64>(2), B<posix_fadvise>(2), B<pread64>(2), B<pwrite64>(2), B<readahead>(2), B<sync_file_range>(2) и B<truncate64>(2)."

#. type: SS
#: man-pages/man2/syscall.2:141
#, no-wrap
msgid "Architecture calling conventions"
msgstr "Архитектурные соглашения по вызовам"

#. type: Plain text
#: man-pages/man2/syscall.2:145
msgid ""
"Every architecture has its own way of invoking and passing arguments to the "
"kernel.  The details for various architectures are listed in the two tables "
"below."
msgstr "В каждой архитектуре есть собственный способ передачи аргументов вызову ядра. Особенности различных архитектур перечислены в двух таблицах ниже."

#. type: Plain text
#: man-pages/man2/syscall.2:152
msgid ""
"The first table lists the instruction used to transition to kernel mode, "
"(which might not be the fastest or best way to transition to the kernel, so "
"you might have to refer to B<vdso>(7)), the register used to indicate the "
"system call number, and the register used to return the system call result."
msgstr "Поля первой таблицы: инструкция для перехода в режим ядра (может быть не быстрым или лучшим способом перехода в ядро, лучше использовать B<vdso>(7)), регистр для указания номера системного вызова и регистр возврата результата работы системного вызова."

#. type: Plain text
#: man-pages/man2/syscall.2:155 man-pages/man2/syscall.2:182
#: man-pages/man2/syscall.2:187
msgid "CW<\\}>"
msgstr "CW<\\}>"

#. type: tbl table
#: man-pages/man2/syscall.2:157
#, no-wrap
msgid "CW<arch/ABI\tinstruction\tsyscall #\tretval\tNotes>\n"
msgstr "CW<Арх/ABI\tИнструкция\t№ syscall\tВозвр\tЗамечания>\n"

#. type: tbl table
#: man-pages/man2/syscall.2:158 man-pages/man2/syscall.2:190
#, no-wrap
msgid "CW<_>\n"
msgstr "CW<_>\n"

#. type: tbl table
#: man-pages/man2/syscall.2:159
#, no-wrap
msgid "CW<arm/OABI\tswi NR\t-\ta1\tNR is syscall #>\n"
msgstr "CW<arm/OABI\tswi NR\t-\ta1\tNR — № syscall>\n"

#. type: tbl table
#: man-pages/man2/syscall.2:160
#, no-wrap
msgid "CW<arm/EABI\tswi 0x0\tr7\tr0>\n"
msgstr "CW<arm/EABI\tswi 0x0\tr7\tr0>\n"

#. type: tbl table
#: man-pages/man2/syscall.2:161
#, no-wrap
msgid "CW<blackfin\texcpt 0x0\tP0\tR0>\n"
msgstr "CW<blackfin\texcpt 0x0\tP0\tR0>\n"

#. type: tbl table
#: man-pages/man2/syscall.2:162
#, no-wrap
msgid "CW<i386\tint $0x80\teax\teax>\n"
msgstr "CW<i386\tint $0x80\teax\teax>\n"

#. type: tbl table
#: man-pages/man2/syscall.2:163
#, no-wrap
msgid "CW<ia64\tbreak 0x100000\tr15\tr10/r8\tT{>\n"
msgstr "CW<ia64\tbreak 0x100000\tr15\tr10/r8\tT{>\n"

#. type: tbl table
#: man-pages/man2/syscall.2:164
#, no-wrap
msgid "CW<bool error/>\n"
msgstr "CW<логич. значение>\n"

#. type: tbl table
#: man-pages/man2/syscall.2:165
#, no-wrap
msgid "CW<.br>\n"
msgstr "CW<.br>\n"

#. type: tbl table
#: man-pages/man2/syscall.2:166
#, no-wrap
msgid "CW<errno value>\n"
msgstr "CW<ошибки/errno>\n"

#. type: tbl table
#: man-pages/man2/syscall.2:167
#, no-wrap
msgid "CW<T}>\n"
msgstr "CW<T}>\n"

#. type: tbl table
#: man-pages/man2/syscall.2:168
#, no-wrap
msgid "CW<parisc\tble 0x100(%sr2, %r0)\tr20\tr28>\n"
msgstr "CW<parisc\tble 0x100(%sr2, %r0)\tr20\tr28>\n"

#. type: tbl table
#: man-pages/man2/syscall.2:169
#, no-wrap
msgid "CW<s390\tsvc 0\tr1\tr2\tSee below>\n"
msgstr "CW<s390\tsvc 0\tr1\tr2\tСмотрите далее>\n"

#. type: tbl table
#: man-pages/man2/syscall.2:170
#, no-wrap
msgid "CW<s390x\tsvc 0\tr1\tr2\tSee below>\n"
msgstr "CW<s390x\tsvc 0\tr1\tr2\tСмотрите далее>\n"

#. type: tbl table
#: man-pages/man2/syscall.2:171
#, no-wrap
msgid "CW<sparc/32\tt 0x10\tg1\to0>\n"
msgstr "CW<sparc/32\tt 0x10\tg1\to0>\n"

#. type: tbl table
#: man-pages/man2/syscall.2:172
#, no-wrap
msgid "CW<sparc/64\tt 0x6d\tg1\to0>\n"
msgstr "CW<sparc/64\tt 0x6d\tg1\to0>\n"

#. type: tbl table
#: man-pages/man2/syscall.2:173
#, no-wrap
msgid "CW<x86_64\tsyscall\trax\trax>\n"
msgstr "CW<x86_64\tsyscall\trax\trax>\n"

#. type: Plain text
#: man-pages/man2/syscall.2:178
msgid ""
"For s390 and s390x, NR (the system call number)  may be passed directly with"
" \"svc NR\" if it is less than 256."
msgstr "Для s390 и s390x, NR (номер системного вызова) может передаваться напрямую с помощью «svc NR», если он меньше 256."

#. type: Plain text
#: man-pages/man2/syscall.2:184
msgid ""
"The second table shows the registers used to pass the system call arguments."
msgstr "Во второй таблице показаны регистры, которые используются для передачи аргументов в системный вызов."

#. type: tbl table
#: man-pages/man2/syscall.2:189
#, no-wrap
msgid "CW<arch/ABI\targ1\targ2\targ3\targ4\targ5\targ6\targ7>\n"
msgstr "CW<Аrch/ABI\tАрг1\tАрг2\tАрг3\tАрг4\tАрг5\tАрг6\tАрг7>\n"

#. type: tbl table
#: man-pages/man2/syscall.2:191
#, no-wrap
msgid "CW<arm/OABI\ta1\ta2\ta3\ta4\tv1\tv2\tv3>\n"
msgstr "CW<arm/OABI\ta1\ta2\ta3\ta4\tv1\tv2\tv3>\n"

#. type: tbl table
#: man-pages/man2/syscall.2:192
#, no-wrap
msgid "CW<arm/EABI\tr0\tr1\tr2\tr3\tr4\tr5\tr6>\n"
msgstr "CW<arm/EABI\tr0\tr1\tr2\tr3\tr4\tr5\tr6>\n"

#. type: tbl table
#: man-pages/man2/syscall.2:193
#, no-wrap
msgid "CW<blackfin\tR0\tR1\tR2\tR3\tR4\tR5\t->\n"
msgstr "CW<blackfin\tR0\tR1\tR2\tR3\tR4\tR5\t->\n"

#. type: tbl table
#: man-pages/man2/syscall.2:194
#, no-wrap
msgid "CW<i386\tebx\tecx\tedx\tesi\tedi\tebp\t->\n"
msgstr "CW<i386\tebx\tecx\tedx\tesi\tedi\tebp\t->\n"

#. type: tbl table
#: man-pages/man2/syscall.2:195
#, no-wrap
msgid "CW<ia64\tout0\tout1\tout2\tout3\tout4\tout5\t->\n"
msgstr "CW<ia64\tout0\tout1\tout2\tout3\tout4\tout5\t->\n"

#. type: tbl table
#: man-pages/man2/syscall.2:196
#, no-wrap
msgid "CW<parisc\tr26\tr25\tr24\tr23\tr22\tr21\t->\n"
msgstr "CW<parisc\tr26\tr25\tr24\tr23\tr22\tr21\t->\n"

#. type: tbl table
#: man-pages/man2/syscall.2:197
#, no-wrap
msgid "CW<s390\tr2\tr3\tr4\tr5\tr6\tr7\t->\n"
msgstr "CW<s390\tr2\tr3\tr4\tr5\tr6\tr7\t->\n"

#. type: tbl table
#: man-pages/man2/syscall.2:198
#, no-wrap
msgid "CW<s390x\tr2\tr3\tr4\tr5\tr6\tr7\t->\n"
msgstr "CW<s390x\tr2\tr3\tr4\tr5\tr6\tr7\t->\n"

#. type: tbl table
#: man-pages/man2/syscall.2:199
#, no-wrap
msgid "CW<sparc/32\to0\to1\to2\to3\to4\to5\t->\n"
msgstr "CW<sparc/32\to0\to1\to2\to3\to4\to5\t->\n"

#. type: tbl table
#: man-pages/man2/syscall.2:200
#, no-wrap
msgid "CW<sparc/64\to0\to1\to2\to3\to4\to5\t->\n"
msgstr "CW<sparc/64\to0\to1\to2\to3\to4\to5\t->\n"

#. type: tbl table
#: man-pages/man2/syscall.2:201
#, no-wrap
msgid "CW<x86_64\trdi\trsi\trdx\tr10\tr8\tr9\t->\n"
msgstr "CW<x86_64\trdi\trsi\trdx\tr10\tr8\tr9\t->\n"

#. type: Plain text
#: man-pages/man2/syscall.2:207
msgid "\\}"
msgstr "\\}"

#. type: Plain text
#: man-pages/man2/syscall.2:210
msgid ""
"Note that these tables don't cover the entire calling convention\\(emsome "
"architectures may indiscriminately clobber other registers not listed here."
msgstr "Заметим, что эти таблицы не описывают полное соглашение о вызове — некоторые архитектуры могут затирать другие регистры и это здесь не описано."

#. type: Plain text
#: man-pages/man2/syscall.2:217
#, no-wrap
msgid ""
"#define _GNU_SOURCE\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>sys/syscall.hE<gt>\n"
"#include E<lt>sys/types.hE<gt>\n"
"#include E<lt>signal.hE<gt>\n"
msgstr "#define _GNU_SOURCE\n#include E<lt>unistd.hE<gt>\n#include E<lt>sys/syscall.hE<gt>\n#include E<lt>sys/types.hE<gt>\n#include E<lt>signal.hE<gt>\n"

#. type: Plain text
#: man-pages/man2/syscall.2:222
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    pid_t tid;\n"
msgstr "int\nmain(int argc, char *argv[])\n{\n    pid_t tid;\n"

#. type: Plain text
#: man-pages/man2/syscall.2:226
#, no-wrap
msgid ""
"    tid = syscall(SYS_gettid);\n"
"    tid = syscall(SYS_tgkill, getpid(), tid, SIGHUP);\n"
"}\n"
msgstr "    tid = syscall(SYS_gettid);\n    tid = syscall(SYS_tgkill, getpid(), tid, SIGHUP);\n}\n"

#. type: Plain text
#: man-pages/man2/syscall.2:231
msgid "B<_syscall>(2), B<intro>(2), B<syscalls>(2), B<vdso>(7)"
msgstr "B<_syscall>(2), B<intro>(2), B<syscalls>(2), B<vdso>(7)"

#. type: TH
#: man-pages/man2/sched_setaffinity.2:34
#, no-wrap
msgid "SCHED_SETAFFINITY"
msgstr "SCHED_SETAFFINITY"

#. type: Plain text
#: man-pages/man2/sched_setaffinity.2:38
msgid ""
"sched_setaffinity, sched_getaffinity - set and get a thread's CPU affinity "
"mask"
msgstr "sched_setaffinity, sched_getaffinity - устанавливает и получает процессорную маску увязывания для нити"

#. type: Plain text
#: man-pages/man2/sched_setaffinity.2:42
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>             /* See feature_test_macros(7) */\n"
"B<#include E<lt>sched.hE<gt>>\n"
msgstr "B<#define _GNU_SOURCE>             /* Смотрите feature_test_macros(7) */\nB<#include E<lt>sched.hE<gt>>\n"

#. type: Plain text
#: man-pages/man2/sched_setaffinity.2:45
#, no-wrap
msgid ""
"B<int sched_setaffinity(pid_t >I<pid>B<, size_t >I<cpusetsize>B<,>\n"
"B<                      const cpu_set_t *>I<mask>B<);>\n"
msgstr "B<int sched_setaffinity(pid_t >I<pid>B<, size_t >I<cpusetsize>B<,>\nB<                      const cpu_set_t *>I<mask>B<);>\n"

#. type: Plain text
#: man-pages/man2/sched_setaffinity.2:48
#, no-wrap
msgid ""
"B<int sched_getaffinity(pid_t >I<pid>B<, size_t >I<cpusetsize>B<,>\n"
"B<                      cpu_set_t *>I<mask>B<);>\n"
msgstr "B<int sched_getaffinity(pid_t >I<pid>B<, size_t >I<cpusetsize>B<,>\nB<                      cpu_set_t *>I<mask>B<);>\n"

#. type: Plain text
#: man-pages/man2/sched_setaffinity.2:63
msgid ""
"A thread's CPU affinity mask determines the set of CPUs on which it is "
"eligible to run.  On a multiprocessor system, setting the CPU affinity mask "
"can be used to obtain performance benefits.  For example, by dedicating one "
"CPU to a particular thread (i.e., setting the affinity mask of that thread "
"to specify a single CPU, and setting the affinity mask of all other threads "
"to exclude that CPU), it is possible to ensure maximum execution speed for "
"that thread.  Restricting a thread to run on a single CPU also avoids the "
"performance cost caused by the cache invalidation that occurs when a thread "
"ceases to execute on one CPU and then recommences execution on a different "
"CPU."
msgstr "Процессорной маской увязывания нити задаётся набор процессоров, на которых разрешено выполняться нити. В многопроцессорных системах задание процессорной маски увязывания можно использовать для получения большей производительности. Например, выделение специального процессора определённой нити (т.е., задание в процессорной маске увязывания для нити одного ЦП и исключение этого ЦП из процессорных масок увязывания для остальных нитей) обеспечивает максимальную скорость выполнения этой нити. Ограничение для нити одним ЦП также исключает сокращение производительности в следствие недостоверности данных кэша, которая возникает, когда нить прекращает выполнение на одном ЦП и затем продолжает выполнение на другом."

#. type: Plain text
#: man-pages/man2/sched_setaffinity.2:70
msgid ""
"A CPU affinity mask is represented by the I<cpu_set_t> structure, a \"CPU "
"set\", pointed to by I<mask>.  A set of macros for manipulating CPU sets is "
"described in B<CPU_SET>(3)."
msgstr "Маска увязывания ЦП представляется в виде структуры I<cpu_set_t>, «набором процессоров», на которую указывает I<mask>. В B<CPU_SET>(3) описаны макросы для изменения набора ЦП."

#. type: Plain text
#: man-pages/man2/sched_setaffinity.2:85
msgid ""
"B<sched_setaffinity>()  sets the CPU affinity mask of the thread whose ID is"
" I<pid> to the value specified by I<mask>.  If I<pid> is zero, then the "
"calling thread is used.  The argument I<cpusetsize> is the length (in bytes)"
" of the data pointed to by I<mask>.  Normally this argument would be "
"specified as I<sizeof(cpu_set_t)>."
msgstr "Вызов B<sched_setaffinity>() устанавливает маску увязывания ЦП I<mask> для нити, чей ID указан в I<pid>. Если значение I<pid> равно нулю, то используется вызывающая нить. В аргументе I<cpusetsize> задаётся количество данных (в байтах), на которые указывает I<mask>. Обычно его значение указывается как I<sizeof(cpu_set_t)>."

#. type: Plain text
#: man-pages/man2/sched_setaffinity.2:92
msgid ""
"If the thread specified by I<pid> is not currently running on one of the "
"CPUs specified in I<mask>, then that thread is migrated to one of the CPUs "
"specified in I<mask>."
msgstr "Если нить, указанная в I<pid>, в данный момент не выполняется на одном из ЦП, заданном в I<mask>, то эта нить переносится на один из процессоров, назначаемых I<mask>."

#. type: Plain text
#: man-pages/man2/sched_setaffinity.2:107
msgid ""
"B<sched_getaffinity>()  writes the affinity mask of the thread whose ID is "
"I<pid> into the I<cpu_set_t> structure pointed to by I<mask>.  The "
"I<cpusetsize> argument specifies the size (in bytes) of I<mask>.  If I<pid> "
"is zero, then the mask of the calling thread is returned."
msgstr "Вызов B<sched_getaffinity>() записывает в структуру I<cpu_set_t>, на которую указывает I<mask>, значение маски увязывания ЦП для нити, чей ID указан в I<pid>. В аргументе I<cpusetsize> задаётся размер I<mask> (в байтах). Если значение I<pid> равно нулю, то возвращается маска вызывающей нити."

#. type: Plain text
#: man-pages/man2/sched_setaffinity.2:116
msgid ""
"On success, B<sched_setaffinity>()  and B<sched_getaffinity>()  return 0.  "
"On error, -1 is returned, and I<errno> is set appropriately."
msgstr "При успешном выполнении B<sched_setaffinity>() и B<sched_getaffinity>() возвращают 0. В случае ошибки возвращается -1, а I<errno> устанавливается в соответствующее значение."

#. type: Plain text
#: man-pages/man2/sched_setaffinity.2:120
msgid "A supplied memory address was invalid."
msgstr "Указан некорректный адрес памяти."

#. type: Plain text
#: man-pages/man2/sched_setaffinity.2:128
msgid ""
"The affinity bit mask I<mask> contains no processors that are currently "
"physically on the system and permitted to the thread according to any "
"restrictions that may be imposed by the \"cpuset\" mechanism described in "
"B<cpuset>(7)."
msgstr "В маске увязывания ЦП I<mask> указаны процессоры, которых физически нет в системе, и которые разрешены нити согласно любым ограничениям, которые могут налагаться механизмом «cpuset», описанном в B<cpuset>(7)."

#. type: Plain text
#: man-pages/man2/sched_setaffinity.2:135
msgid ""
"(B<sched_getaffinity>()  and, in kernels before 2.6.9, "
"B<sched_setaffinity>())  I<cpusetsize> is smaller than the size of the "
"affinity mask used by the kernel."
msgstr "(B<sched_getaffinity>() и, в ядрах до 2.6.9, B<sched_setaffinity>()) Значение I<cpusetsize> меньше размера маски увязывания, используемой в ядре."

#. type: Plain text
#: man-pages/man2/sched_setaffinity.2:145
msgid ""
"(B<sched_setaffinity>())  The calling thread does not have appropriate "
"privileges.  The caller needs an effective user ID equal to the real user ID"
" or effective user ID of the thread identified by I<pid>, or it must possess"
" the B<CAP_SYS_NICE> capability."
msgstr "(B<sched_setaffinity>()) Вызывающая нить не имеет достаточно прав. Вызывающему требуется иметь эффективный пользовательский ID равный реальному пользовательскому ID или эффективному пользовательскому ID нити, указанной в I<pid>, или он должен обладать мандатом B<CAP_SYS_NICE>."

#. type: Plain text
#: man-pages/man2/sched_setaffinity.2:159
msgid ""
"The CPU affinity system calls were introduced in Linux kernel 2.5.8.  The "
"system call wrappers were introduced in glibc 2.3.  Initially, the glibc "
"interfaces included a I<cpusetsize> argument, typed as I<unsigned int>.  In "
"glibc 2.3.3, the I<cpusetsize> argument was removed, but was then restored "
"in glibc 2.3.4, with type I<size_t>."
msgstr "Системные вызовы увязывания ЦП появились в ядре Linux версии 2.5.8. Обёрточные функции появились в glibc 2.3. Первоначально, в интерфейсе glibc присутствовал аргумент I<cpusetsize>, имевший тип I<unsigned int>. В glibc 2.3.3 аргумент I<cpusetsize> был удалён, но появился вновь в glibc 2.3.4 с типом I<size_t>."

#. type: Plain text
#: man-pages/man2/sched_setaffinity.2:161
msgid "These system calls are Linux-specific."
msgstr "Данные системные вызовы есть только в Linux."

#. type: Plain text
#: man-pages/man2/sched_setaffinity.2:174
msgid ""
"After a call to B<sched_setaffinity>(), the set of CPUs on which the thread "
"will actually run is the intersection of the set specified in the I<mask> "
"argument and the set of CPUs actually present on the system.  The system may"
" further restrict the set of CPUs on which the thread runs if the \"cpuset\""
" mechanism described in B<cpuset>(7)  is being used.  These restrictions on "
"the actual set of CPUs on which the thread will run are silently imposed by "
"the kernel."
msgstr "После вызова B<sched_setaffinity>() набор процессоров, на которых действительно будет выполняться нить, вычисляется пересечением набора из аргумента I<mask> и набором процессоров, присутствующих в системе. В дальнейшем, система может ограничить набор процессоров нити, если задействован механизм «cpuset», описанный в B<cpuset>(7). Эти ограничения на действительный набор процессоров, используемых для нити, без уведомления налагаются ядром."

#. type: Plain text
#: man-pages/man2/sched_setaffinity.2:177
msgid "B<sched>(7)  has a description of the Linux scheduling scheme."
msgstr "В B<sched>(7) приведено описание схемы планирования Linux."

#. type: Plain text
#: man-pages/man2/sched_setaffinity.2:194
msgid ""
"The affinity mask is a per-thread attribute that can be adjusted "
"independently for each of the threads in a thread group.  The value returned"
" from a call to B<gettid>(2)  can be passed in the argument I<pid>.  "
"Specifying I<pid> as 0 will set the attribute for the calling thread, and "
"passing the value returned from a call to B<getpid>(2)  will set the "
"attribute for the main thread of the thread group.  (If you are using the "
"POSIX threads API, then use B<pthread_setaffinity_np>(3)  instead of "
"B<sched_setaffinity>().)"
msgstr "Маска увязывания является атрибутом нити, которая может изменяться независимо для каждой нити в группе нитей. В аргументе I<pid> можно передавать значение, возвращаемое вызовом B<gettid>(2). При значении I<pid> равным 0 будет установлен атрибут вызывающей нити, а при передаче значения, возвращаемого вызовом B<getpid>(2), устанавливается атрибут главной нити группы нитей (при работе с программным интерфейсом POSIX используйте функцию B<pthread_setaffinity_np>(3) вместо B<sched_setaffinity>()). "

#. type: Plain text
#: man-pages/man2/sched_setaffinity.2:200
msgid ""
"A child created via B<fork>(2)  inherits its parent's CPU affinity mask.  "
"The affinity mask is preserved across an B<execve>(2)."
msgstr "Потомок, создаваемый с помощью B<fork>(2), наследует маску увязывания ЦП. Маска увязывания сохраняется при вызове B<execve>(2)."

#. type: Plain text
#: man-pages/man2/sched_setaffinity.2:214
msgid ""
"This manual page describes the glibc interface for the CPU affinity calls.  "
"The actual system call interface is slightly different, with the I<mask> "
"being typed as I<unsigned long\\ *>, reflecting the fact that the underlying"
" implementation of CPU sets is a simple bit mask.  On success, the raw "
"B<sched_getaffinity>()  system call returns the size (in bytes) of the "
"I<cpumask_t> data type that is used internally by the kernel to represent "
"the CPU set bit mask."
msgstr "В данной справочной странице описан интерфейс увязывания ЦП, используемый в glibc. Реальный интерфейс системных вызов чуть отличается: аргумент I<mask> имеет тип I<unsigned long\\ *>, отражая факт того, что используемая реализация наборов ЦП представляет собой просто битовую маску. При успешном выполнении ядерный системный вызов B<sched_getaffinity>() возвращает размер типа данных I<cpumask_t> (в байтах), который используется в ядре для представления битовой маски процессоров."

#. type: Plain text
#: man-pages/man2/sched_setaffinity.2:233
msgid ""
"B<taskset>(1), B<clone>(2), B<getcpu>(2), B<getpriority>(2), B<gettid>(2), "
"B<nice>(2), B<sched_get_priority_max>(2), B<sched_get_priority_min>(2), "
"B<sched_getscheduler>(2), B<sched_setscheduler>(2), B<setpriority>(2), "
"B<CPU_SET>(3), B<pthread_setaffinity_np>(3), B<sched_getcpu>(3), "
"B<capabilities>(7), B<cpuset>(7), B<sched>(7)"
msgstr "B<taskset>(1), B<clone>(2), B<getcpu>(2), B<getpriority>(2), B<gettid>(2), B<nice>(2), B<sched_get_priority_max>(2), B<sched_get_priority_min>(2), B<sched_getscheduler>(2), B<sched_setscheduler>(2), B<setpriority>(2), B<CPU_SET>(3), B<pthread_setaffinity_np>(3), B<sched_getcpu>(3), B<capabilities>(7), B<cpuset>(7), B<sched>(7)"

#. type: TH
#: man-pages/man2/sgetmask.2:26
#, no-wrap
msgid "SGETMASK"
msgstr "SGETMASK"

#. type: TH
#: man-pages/man2/sgetmask.2:26
#, no-wrap
msgid "2014-02-25"
msgstr "2014-02-25"

#. type: Plain text
#: man-pages/man2/sgetmask.2:29
msgid "sgetmask, ssetmask - manipulation of signal mask (obsolete)"
msgstr "sgetmask, ssetmask - работа с маской сигналов (устарел)"

#. type: Plain text
#: man-pages/man2/sgetmask.2:31
msgid "B<long sgetmask(void);>"
msgstr "B<long sgetmask(void);>"

#. type: Plain text
#: man-pages/man2/sgetmask.2:33
msgid "B<long ssetmask(long >I<newmask>B<);>"
msgstr "B<long ssetmask(long >I<newmask>B<);>"

#. type: Plain text
#: man-pages/man2/sgetmask.2:36
msgid ""
"I<Note>: There are no glibc wrappers for these system calls; see NOTES."
msgstr "I<Замечание>: В glibc нет обёрточных функций для этих системных вызовов; смотрите ЗАМЕЧАНИЯ."

#. type: Plain text
#: man-pages/man2/sgetmask.2:42
msgid ""
"These system calls are obsolete.  I<Do not use them>; use B<sigprocmask>(2)"
"  instead."
msgstr "Данные системные вызовы устарели. Используйте вместо них B<sigprocmask>(2)."

#. type: Plain text
#: man-pages/man2/sgetmask.2:45
msgid "B<sgetmask>()  returns the signal mask of the calling process."
msgstr "Вызов B<sgetmask>() возвращает маску сигналов вызывающего процесса."

#. type: Plain text
#: man-pages/man2/sgetmask.2:50
msgid ""
"B<ssetmask>()  sets the signal mask of the calling process to the value "
"given in I<newmask>.  The previous signal mask is returned."
msgstr "Вызов B<ssetmask>() устанавливает маску сигналов вызывающего процесса равной значению, указанному в I<newmask>. Возвращается предыдущее значение маски сигналов."

#. type: Plain text
#: man-pages/man2/sgetmask.2:59
msgid ""
"The signal masks dealt with by these two system calls are plain bit masks "
"(unlike the I<sigset_t> used by B<sigprocmask>(2)); use B<sigmask>(3)  to "
"create and inspect these masks."
msgstr "Маски сигналов обрабатываются этими системными вызовами как простые битовые маски (в отличие от I<sigset_t>, который используется в B<sigprocmask>(2)); для создания и проверки масок используйте B<sigmask>(3)."

#. type: Plain text
#: man-pages/man2/sgetmask.2:64
msgid ""
"B<sgetmask>()  always successfully returns the signal mask.  B<ssetmask>()  "
"always succeeds, and returns the previous signal mask."
msgstr "Вызов B<sgetmask>() всегда выполняется успешно и возвращает маску сигналов. Вызов B<ssetmask>() всегда выполняется успешно и возвращает предыдущее значение маски сигналов."

#. type: Plain text
#: man-pages/man2/sgetmask.2:66
msgid "These system calls always succeed."
msgstr "Данные системные вызовы всегда выполняются без ошибок."

#. type: Plain text
#: man-pages/man2/sgetmask.2:72
msgid ""
"Glibc does not provide wrappers for these obsolete system calls; in the "
"unlikely event that you want to call them, use B<syscall>(2)."
msgstr "В glibc нет обёрток для этих устаревших системных вызовов; вызывайте их через B<syscall>(2)."

#. type: Plain text
#: man-pages/man2/sgetmask.2:75
msgid ""
"These system calls are unaware of signal numbers greater than 31 (i.e., "
"real-time signals)."
msgstr "Данные системные вызовы ничего не знают о номерах сигналов больше 31 (т.е. сигналах реального времени)."

#. type: Plain text
#: man-pages/man2/sgetmask.2:77
msgid "These system calls do not exist on x86-64."
msgstr "Данные системные вызовы не существуют на x86-64."

#. type: Plain text
#: man-pages/man2/sgetmask.2:82
msgid "It is not possible to block B<SIGSTOP> or B<SIGKILL>."
msgstr "Они не могут заблокировать B<SIGSTOP> или B<SIGKILL>."

#. type: Plain text
#: man-pages/man2/sgetmask.2:84
msgid "B<sigprocmask>(2), B<signal>(7)"
msgstr "B<sigprocmask>(2), B<signal>(7)"

#. type: TH
#: man-pages/man2/shmget.2:38
#, no-wrap
msgid "SHMGET"
msgstr "SHMGET"

#. type: Plain text
#: man-pages/man2/shmget.2:41
msgid "shmget - allocates a System V shared memory segment"
msgstr "shmget - выделяет общий сегмент памяти System V"

#. type: Plain text
#: man-pages/man2/shmget.2:48
msgid "B<int shmget(key_t >I<key>B<, size_t >I<size>B<, int >I<shmflg>B<);>"
msgstr "B<int shmget(key_t >I<key>B<, size_t >I<size>B<, int >I<shmflg>B<);>"

#. type: Plain text
#: man-pages/man2/shmget.2:72
msgid ""
"B<shmget>()  returns the identifier of the System\\ V shared memory segment "
"associated with the value of the argument I<key>.  A new shared memory "
"segment, with size equal to the value of I<size> rounded up to a multiple of"
" B<PAGE_SIZE>, is created if I<key> has the value B<IPC_PRIVATE> or I<key> "
"isn't B<IPC_PRIVATE>, no shared memory segment corresponding to I<key> "
"exists, and B<IPC_CREAT> is specified in I<shmflg>."
msgstr "Вызов B<shmget>() возвращает идентификатор общего сегмента памяти System\\ V, соответствующего значению аргумента I<key>. Если значение I<key> равно B<IPC_PRIVATE> или если I<key> не равно B<IPC_PRIVATE>, но не существует общего сегмента памяти, который бы соответствовал значению I<key> и в I<shmflg> есть флаг B<IPC_CREAT>, то создаётся новый общий сегмент памяти размером I<size>, округлённым до значения, кратного B<PAGE_SIZE>."

#. type: Plain text
#: man-pages/man2/shmget.2:91
msgid ""
"If I<shmflg> specifies both B<IPC_CREAT> and B<IPC_EXCL> and a shared memory"
" segment already exists for I<key>, then B<shmget>()  fails with I<errno> "
"set to B<EEXIST>.  (This is analogous to the effect of the combination "
"B<O_CREAT | O_EXCL> for B<open>(2).)"
msgstr "Если в I<shmflg> одновременно указаны B<IPC_CREAT> и B<IPC_EXCL> и для значения I<key> уже существует общий сегмент памяти, то вызов B<shmget>() завершается с ошибкой и I<errno> присваивается B<EEXIST> (такой же результат как с B<O_CREAT | O_EXCL> у B<open>(2))."

#. type: Plain text
#: man-pages/man2/shmget.2:95
msgid "The value I<shmflg> is composed of:"
msgstr "Значение I<shmflg> составляется из следующих флагов:"

#. type: Plain text
#: man-pages/man2/shmget.2:102
msgid ""
"Create a new segment.  If this flag is not used, then B<shmget>()  will find"
" the segment associated with I<key> and check to see if the user has "
"permission to access the segment."
msgstr "Служит для создания нового сегмента. Если этого флага нет, то вызов B<shmget>() будет искать сегмент, соответствующий I<key>, и затем проверит, имеет ли пользователь права на доступ к сегменту."

#. type: Plain text
#: man-pages/man2/shmget.2:108
msgid ""
"This flag is used with B<IPC_CREAT> to ensure that this call creates the "
"segment.  If the segment already exists, the call fails."
msgstr "Этот флаг используется совместно с B<IPC_CREAT> для того, чтобы этот вызов создал сегмент. Если сегмент уже существует, то вызов завершается с ошибкой."

#. type: TP
#: man-pages/man2/shmget.2:108
#, no-wrap
msgid "B<SHM_HUGETLB> (since Linux 2.6)"
msgstr "B<SHM_HUGETLB> (начиная с Linux 2.6)"

#. type: Plain text
#: man-pages/man2/shmget.2:114
msgid ""
"Allocate the segment using \"huge pages.\" See the Linux kernel source file "
"I<Documentation/vm/hugetlbpage.txt> for further information."
msgstr "Выделять сегмент используя «огромные страницы». Дополнительную информацию смотрите в файле исходного кода ядра Linux I<Documentation/vm/hugetlbpage.txt>."

#. type: TP
#: man-pages/man2/shmget.2:114
#, no-wrap
msgid "B<SHM_NORESERVE> (since Linux 2.6.15)"
msgstr "B<SHM_NORESERVE> (начиная с Linux 2.6.15)"

#.  As at 2.6.17-rc2, this flag has no effect if SHM_HUGETLB was also
#.  specified.
#. type: Plain text
#: man-pages/man2/shmget.2:133
msgid ""
"This flag serves the same purpose as the B<mmap>(2)  B<MAP_NORESERVE> flag."
"  Do not reserve swap space for this segment.  When swap space is reserved, "
"one has the guarantee that it is possible to modify the segment.  When swap "
"space is not reserved one might get B<SIGSEGV> upon a write if no physical "
"memory is available.  See also the discussion of the file "
"I</proc/sys/vm/overcommit_memory> in B<proc>(5)."
msgstr "Этот флаг нужен для того же, что и флаг B<MAP_NORESERVE> у B<mmap>(2). Он указывает не резервировать место в пространстве подкачки для этого сегмента. Операцией резервирования места в пространстве подкачки гарантируется, что сегмент можно изменить. Если место не резервировать, то при записи можно получить сигнал B<SIGSEGV>, если кончится физическая память. Смотрите также обсуждение файла I</proc/sys/vm/overcommit_memory> в B<proc>(5)."

#. type: Plain text
#: man-pages/man2/shmget.2:143
msgid ""
"In addition to the above flags, the least significant 9 bits of I<shmflg> "
"specify the permissions granted to the owner, group, and others.  These bits"
" have the same format, and the same meaning, as the I<mode> argument of "
"B<open>(2).  Presently, execute permissions are not used by the system."
msgstr "В дополнении к перечисленным выше флагам в младших 9 битах I<shmflg> задаются права для владельца, группы и всех остальных. Формат значения битов совпадает с аргументом I<mode> вызова B<open>(2). В данный момент бит выполнения системой не используются."

#. type: Plain text
#: man-pages/man2/shmget.2:151
msgid ""
"When a new shared memory segment is created, its contents are initialized to"
" zero values, and its associated data structure, I<shmid_ds> (see "
"B<shmctl>(2)), is initialized as follows:"
msgstr "Если создаётся новый общий сегмент памяти, то его содержимое инициализируется нулями, а соответствующая ему структура данных I<shmid_ds> (см. B<shmctl>(2)) следующим образом:"

#. type: Plain text
#: man-pages/man2/shmget.2:156
msgid ""
"I<shm_perm.cuid> and I<shm_perm.uid> are set to the effective user ID of the"
" calling process."
msgstr "Полям I<shm_perm.cuid> и I<shm_perm.uid> присваиваются значения эффективного идентификатора пользователя вызывающего процесса."

#. type: Plain text
#: man-pages/man2/shmget.2:161
msgid ""
"I<shm_perm.cgid> and I<shm_perm.gid> are set to the effective group ID of "
"the calling process."
msgstr "Полям I<shm_perm.cgid> и I<shm_perm.gid> присваиваются значения эффективного идентификатора группы вызывающего процесса."

#. type: Plain text
#: man-pages/man2/shmget.2:166
msgid ""
"The least significant 9 bits of I<shm_perm.mode> are set to the least "
"significant 9 bit of I<shmflg>."
msgstr "Младшим 9 битам I<shm_perm.mode> присваивается значение младших 9 бит I<shmflg>."

#. type: Plain text
#: man-pages/man2/shmget.2:170
msgid "I<shm_segsz> is set to the value of I<size>."
msgstr "Полю I<shm_segsz> присваивается значение I<size>."

#. type: Plain text
#: man-pages/man2/shmget.2:177
msgid ""
"I<shm_lpid>, I<shm_nattch>, I<shm_atime>, and I<shm_dtime> are set to 0."
msgstr "Полям I<shm_lpid>, I<shm_nattch>, I<shm_atime> и I<shm_dtime> присваивается значение 0."

#. type: Plain text
#: man-pages/man2/shmget.2:180
msgid "I<shm_ctime> is set to the current time."
msgstr "Полю I<shm_ctime> присваивается значение текущего времени."

#. type: Plain text
#: man-pages/man2/shmget.2:183
msgid ""
"If the shared memory segment already exists, the permissions are verified, "
"and a check is made to see if it is marked for destruction."
msgstr "Если общий сегмент памяти уже существует, то проверяются права доступа к нему и не помечен ли он для удаления."

#. type: Plain text
#: man-pages/man2/shmget.2:188
msgid ""
"On success, a valid shared memory identifier is returned.  On error, -1 is "
"returned, and I<errno> is set to indicate the error."
msgstr "При успешном выполнении возвращается корректный идентификатор общей памяти. При ошибке возвращается -1, а в I<errno> записывается причина ошибки."

#. type: Plain text
#: man-pages/man2/shmget.2:192
msgid "On failure, I<errno> is set to one of the following:"
msgstr "В случае возникновения ошибки I<errno> может принимать следующие значения:"

#. type: Plain text
#: man-pages/man2/shmget.2:198
msgid ""
"The user does not have permission to access the shared memory segment, and "
"does not have the B<CAP_IPC_OWNER> capability."
msgstr "Пользователь не имеет прав доступа к общему сегменту памяти и не имеет мандата B<CAP_IPC_OWNER>."

#. type: Plain text
#: man-pages/man2/shmget.2:207
msgid ""
"B<IPC_CREAT> and B<IPC_EXCL> were specified in I<shmflg>, but a shared "
"memory segment already exists for I<key>."
msgstr "В I<shmflg> указаны B<IPC_CREAT> и B<IPC_EXCL>, но общий сегмент памяти уже существует для I<key>."

#. type: Plain text
#: man-pages/man2/shmget.2:215
msgid ""
"A new segment was to be created and I<size> is less than B<SHMIN> or greater"
" than B<SHMMAX>."
msgstr "Был создан новый сегмент и I<size> меньше B<SHMIN> или больше B<SHMMAX>."

#. type: Plain text
#: man-pages/man2/shmget.2:221
msgid ""
"A segment for the given I<key> exists, but I<size> is greater than the size "
"of that segment."
msgstr "Сегмент для заданного I<key> существует, но I<size> больше размера этого сегмента."

#. type: TP
#: man-pages/man2/shmget.2:221
#, no-wrap
msgid "B<ENFILE>"
msgstr "B<ENFILE>"

#.  [2.6.7] shmem_zero_setup()-->shmem_file_setup()-->get_empty_filp()
#. type: Plain text
#: man-pages/man2/shmget.2:225
msgid "The system limit on the total number of open files has been reached."
msgstr "Достигнуто максимальное количество открытых файлов в системе."

#. type: Plain text
#: man-pages/man2/shmget.2:230
msgid ""
"No segment exists for the given I<key>, and B<IPC_CREAT> was not specified."
msgstr "Не существует сегмента для ключа I<key> и флаг B<IPC_CREAT> не указан."

#. type: Plain text
#: man-pages/man2/shmget.2:233
msgid "No memory could be allocated for segment overhead."
msgstr "Не хватает памяти для выделения под перерасход сегмента."

#. type: Plain text
#: man-pages/man2/shmget.2:241
msgid ""
"All possible shared memory IDs have been taken (B<SHMMNI>), or allocating a "
"segment of the requested I<size> would cause the system to exceed the "
"system-wide limit on shared memory (B<SHMALL>)."
msgstr "Все возможные идентификаторы сегментов уже распределены (B<SHMMNI>) или размер выделяемого сегмента превысит системные лимиты по общей памяти (B<SHMALL>)."

#. type: Plain text
#: man-pages/man2/shmget.2:248
msgid ""
"The B<SHM_HUGETLB> flag was specified, but the caller was not privileged "
"(did not have the B<CAP_IPC_LOCK> capability)."
msgstr "Указан флаг B<SHM_HUGETLB>, но у вызывающего нет прав (нет мандата B<CAP_IPC_LOCK>)."

#. type: Plain text
#: man-pages/man2/shmget.2:256
msgid "B<SHM_HUGETLB> and B<SHM_NORESERVE> are Linux extensions."
msgstr "B<SHM_HUGETLB> и B<SHM_NORESERVE> являются расширениями Linux."

#. type: Plain text
#: man-pages/man2/shmget.2:280
msgid ""
"B<IPC_PRIVATE> isn't a flag field but a I<key_t> type.  If this special "
"value is used for I<key>, the system call ignores all but the least "
"significant 9 bits of I<shmflg> and creates a new shared memory segment."
msgstr "B<IPC_PRIVATE> — не поле флага, а тип I<key_t>. Если I<key> равно этому специальному значению, то системный вызов игнорирует всё кроме 9-ти младших битов I<shmflg> и создаёт новый общий сегмент памяти."

#. type: SS
#: man-pages/man2/shmget.2:280
#, no-wrap
msgid "Shared memory limits"
msgstr "Ограничения общей памяти"

#. type: Plain text
#: man-pages/man2/shmget.2:284
msgid ""
"The following limits on shared memory segment resources affect the "
"B<shmget>()  call:"
msgstr "Ниже приведены ограничения ресурсов на общий сегмент памяти, влияющие на вызов B<shmget>():"

#. type: TP
#: man-pages/man2/shmget.2:284
#, no-wrap
msgid "B<SHMALL>"
msgstr "B<SHMALL>"

#. type: Plain text
#: man-pages/man2/shmget.2:288
msgid ""
"System-wide limit on the number of shared memory pages.  Since Linux 2.4, "
"the default value for this limit is"
msgstr "Системный лимит на общее количество общих страниц памяти. Начиная с Linux 2.4, значение по умолчанию равно"

#. type: Plain text
#: man-pages/man2/shmget.2:290
#, no-wrap
msgid "    SHMMAX / PAGE_SIZE * (SHMMNI / 16)\n"
msgstr "    SHMMAX / PAGE_SIZE * (SHMMNI / 16)\n"

#. type: Plain text
#: man-pages/man2/shmget.2:299
msgid ""
"If B<SHMMAX> and B<SHMMNI> are not modified, this yields a limit for the "
"total memory used by all shared memory segments of 8 GB: with a 4kB page "
"size, this formula yields the value 2^21 (2,097,152); with 8kB page size, it"
" yields 2^20 (1048576)."
msgstr ""

#. type: Plain text
#: man-pages/man2/shmget.2:302
msgid ""
"On Linux, this limit can be read and modified via "
"I</proc/sys/kernel/shmall>."
msgstr "В Linux это ограничение можно прочитать и изменить через I</proc/sys/kernel/shmall>."

#. type: TP
#: man-pages/man2/shmget.2:302
#, no-wrap
msgid "B<SHMMAX>"
msgstr "B<SHMMAX>"

#. type: Plain text
#: man-pages/man2/shmget.2:306
msgid ""
"Maximum size in bytes for a shared memory segment.  Since Linux 2.2, the "
"default value of this limit is 0x2000000 (32MB)."
msgstr "Максимальный размер общего сегмента памяти в байтах. Начиная с Linux 2.2, значение по умолчанию равно 0x2000000 (32МБ)."

#. type: Plain text
#: man-pages/man2/shmget.2:309
msgid ""
"On Linux, this limit can be read and modified via "
"I</proc/sys/kernel/shmmax>."
msgstr "В Linux это ограничение можно прочитать и изменить через I</proc/sys/kernel/shmmax>."

#. type: TP
#: man-pages/man2/shmget.2:309
#, no-wrap
msgid "B<SHMMIN>"
msgstr "B<SHMMIN>"

#. type: Plain text
#: man-pages/man2/shmget.2:315
msgid ""
"Minimum size in bytes for a shared memory segment: implementation dependent "
"(currently 1 byte, though B<PAGE_SIZE> is the effective minimum size)."
msgstr "Минимальный размер общего сегмента памяти в байтах в системе: зависит от реализации (в настоящий момент равно 1 байту, хотя на самом деле минимальный выделяемый размер равен B<PAGE_SIZE>)."

#. type: TP
#: man-pages/man2/shmget.2:315
#, no-wrap
msgid "B<SHMMNI>"
msgstr "B<SHMMNI>"

#. type: Plain text
#: man-pages/man2/shmget.2:320
msgid ""
"System-wide limit on the number of shared memory segments.  In Linux 2.2, "
"the default value for this limit was 128; since Linux 2.4, the default value"
" is 4096."
msgstr "Системный лимит на общее количество общих сегментов памяти. Начиная с Linux 2.2, значение по умолчанию равно 128; начиная с Linux 2.4, значение по умолчанию равно 4096."

#.  Kernels between 2.4.x and 2.6.8 had an off-by-one error that meant
#.  that we could create one more segment than SHMMNI -- MTK
#.  This /proc file is not available in Linux 2.2 and earlier -- MTK
#. type: Plain text
#: man-pages/man2/shmget.2:326
msgid ""
"On Linux, this limit can be read and modified via "
"I</proc/sys/kernel/shmmni>."
msgstr "В Linux это ограничение можно прочитать и изменить через I</proc/sys/kernel/shmmni>."

#. type: Plain text
#: man-pages/man2/shmget.2:330
msgid ""
"The implementation has no specific limits for the per-process maximum number"
" of shared memory segments (B<SHMSEG>)."
msgstr "Реализацией не ограничивается максимальное количество общих сегментов памяти на процесс (B<SHMSEG>)."

#. type: SS
#: man-pages/man2/shmget.2:330
#, no-wrap
msgid "Linux notes"
msgstr "Замечания, касающиеся Linux"

#. type: Plain text
#: man-pages/man2/shmget.2:336
msgid ""
"Until version 2.3.30, Linux would return B<EIDRM> for a B<shmget>()  on a "
"shared memory segment scheduled for deletion."
msgstr "В Linux до версии 2.3.30 вызов B<shmget>() возвращал значение B<EIDRM>, если общий сегмент памяти был запланирован к удалению."

#. type: Plain text
#: man-pages/man2/shmget.2:349
msgid ""
"B<shmat>(2), B<shmctl>(2), B<shmdt>(2), B<ftok>(3), B<capabilities>(7), "
"B<shm_overview>(7), B<svipc>(7)"
msgstr "B<shmat>(2), B<shmctl>(2), B<shmdt>(2), B<ftok>(3), B<capabilities>(7), B<shm_overview>(7), B<svipc>(7)"

#. type: TH
#: man-pages/man2/setresuid.2:26
#, no-wrap
msgid "SETRESUID"
msgstr "SETRESUID"

#. type: Plain text
#: man-pages/man2/setresuid.2:29
msgid "setresuid, setresgid - set real, effective and saved user or group ID"
msgstr "setresuid, setresgid - устанавливает  реальный, эффективный и сохранённый пользовательский идентификатор или идентификатор группы"

#. type: Plain text
#: man-pages/man2/setresuid.2:31
msgid "B<#define _GNU_SOURCE> /* See feature_test_macros(7) */"
msgstr "B<#define _GNU_SOURCE> /* смотрите feature_test_macros(7) */"

#. type: Plain text
#: man-pages/man2/setresuid.2:35
msgid ""
"B<int setresuid(uid_t >I<ruid>B<, uid_t >I<euid>B<, uid_t >I<suid>B<);>"
msgstr "B<int setresuid(uid_t >I<ruid>B<, uid_t >I<euid>B<, uid_t >I<suid>B<);>"

#. type: Plain text
#: man-pages/man2/setresuid.2:37
msgid ""
"B<int setresgid(gid_t >I<rgid>B<, gid_t >I<egid>B<, gid_t >I<sgid>B<);>"
msgstr "B<int setresgid(gid_t >I<rgid>B<, gid_t >I<egid>B<, gid_t >I<sgid>B<);>"

#. type: Plain text
#: man-pages/man2/setresuid.2:41
msgid ""
"B<setresuid>()  sets the real user ID, the effective user ID, and the saved "
"set-user-ID of the calling process."
msgstr "Вызов B<setresuid>() устанавливает реальный идентификатор пользователя, эффективный идентификатор пользователя и сохранённый идентификатор пользователя вызывающего процесса."

#. type: Plain text
#: man-pages/man2/setresuid.2:47
msgid ""
"Unprivileged user processes may change the real UID, effective UID, and "
"saved set-user-ID, each to one of: the current real UID, the current "
"effective UID or the current saved set-user-ID."
msgstr "Непривилегированные пользовательские процессы могут изменять реальный идентификатор пользователя, эффективный идентификатор пользователя и сохранённый идентификатор пользователя на соответственно текущий реальный идентификатор пользователя, текущий  эффективный идентификатор пользователя и текущий  сохранённый идентификатор пользователя."

#. type: Plain text
#: man-pages/man2/setresuid.2:51
msgid ""
"Privileged processes (on Linux, those having the B<CAP_SETUID> capability)  "
"may set the real UID, effective UID, and saved set-user-ID to arbitrary "
"values."
msgstr "Привилегированные процессы (в Linux: имеющие мандат B<CAP_SETUID>) могут устанавливать произвольные значения для реального, эффективного и сохранённого идентификатора пользователя."

#. type: Plain text
#: man-pages/man2/setresuid.2:53
msgid ""
"If one of the arguments equals -1, the corresponding value is not changed."
msgstr "Если один из параметров равен -1, то соответствующее ему значение не изменяется."

#. type: Plain text
#: man-pages/man2/setresuid.2:57
msgid ""
"Regardless of what changes are made to the real UID, effective UID, and "
"saved set-user-ID, the filesystem UID is always set to the same value as the"
" (possibly new) effective UID."
msgstr "Независимо от того, как изменились реальный UID, эффективный UID и сохранённый UID идентификатор в файловой системе всегда устанавливается равным значению (возможно новому) эффективного UID."

#. type: Plain text
#: man-pages/man2/setresuid.2:64
msgid ""
"Completely analogously, B<setresgid>()  sets the real GID, effective GID, "
"and saved set-group-ID of the calling process (and always modifies the "
"filesystem GID to be the same as the effective GID), with the same "
"restrictions for unprivileged processes."
msgstr "Аналогично, B<setresgid>() устанавливает реальный GID, эффективный GID, и сохранённый GID вызывающего процесса (и всегда изменяет GID в файловой системе на значение эффективного GID) с теми же ограничениями для непривилегированных процессов."

#. type: Plain text
#: man-pages/man2/setresuid.2:76
msgid ""
"I<Note>: there are cases where B<setresuid>()  can fail even when the caller"
" is UID 0; it is a grave security error to omit checking for a failure "
"return from B<setresuid>()."
msgstr ""

#. type: Plain text
#: man-pages/man2/setresuid.2:84
msgid ""
"The call would change the caller's real UID (i.e., I<ruid> does not match "
"the caller's real UID), but there was a temporary failure allocating the "
"necessary kernel data structures."
msgstr "Вызов изменил бы настоящего реальный UID вызывающего (т. е. I<ruid> не совпадает с реальным UID вызывающего), но возникла временная ошибка при выделении памяти под необходимые структуры ядра."

#. type: Plain text
#: man-pages/man2/setresuid.2:99
msgid ""
"I<ruid> does not match the caller's real UID and this call would bring the "
"number of processes belonging to the real user ID I<ruid> over the caller's "
"B<RLIMIT_NPROC> resource limit.  Since Linux 3.1, this error case no longer "
"occurs (but robust applications should check for this error); see the "
"description of B<EAGAIN> in B<execve>(2)."
msgstr "Значение I<ruid> не совпадает с реальным UID вызывающего и этот вызов создал был превышение количества процессов, принадлежащих пользователю с реальным ID I<ruid> сверх ограничителя ресурсы B<RLIMIT_NPROC> вызывающего. Начиная с Linux 3.1 эта ошибка больше не возникает (но корректное приложение должно проверять эту ошибку); смотрите описание B<EAGAIN> в B<execve>(2)."

#. type: Plain text
#: man-pages/man2/setresuid.2:103
msgid ""
"The calling process is not privileged (did not have the B<CAP_SETUID> "
"capability) and tried to change the IDs to values that are not permitted."
msgstr "Вызывающий процесс не является привилегированным (не имеет мандата B<CAP_SETUID>) и пытается изменить значения идентификаторов, что запрещено."

#. type: Plain text
#: man-pages/man2/setresuid.2:105
msgid "These calls are available under Linux since Linux 2.1.44."
msgstr "Данные вызовы доступны в Linux начиная с версии 2.1.44."

#. type: Plain text
#: man-pages/man2/setresuid.2:108
msgid ""
"These calls are nonstandard; they also appear on HP-UX and some of the BSDs."
msgstr "Это нестандартные вызовы; также они есть в HP-UX и некоторых BSD."

#. type: Plain text
#: man-pages/man2/setresuid.2:112
msgid ""
"Under HP-UX and FreeBSD, the prototype is found in I<E<lt>unistd.hE<gt>>.  "
"Under Linux, the prototype is provided by glibc since version 2.3.2."
msgstr ""

#. type: Plain text
#: man-pages/man2/setresuid.2:128
msgid ""
"The original Linux B<setresuid>()  and B<setresgid>()  system calls "
"supported only 16-bit user and group IDs.  Subsequently, Linux 2.4 added "
"B<setresuid32>()  and B<setresgid32>(), supporting 32-bit IDs.  The glibc "
"B<setresuid>()  and B<setresgid>()  wrapper functions transparently deal "
"with the variations across kernel versions."
msgstr "Первоначальные версии системных вызовов B<setresuid>() и B<setresgid>() в Linux поддерживали только 16-битные идентификаторы пользователей и групп. Позднее в Linux 2.4 были добавлены вызовы B<setresuid32>() и B<setresgid32>(), поддерживающие 32-битные идентификаторы. В glibc обёрточные функции B<setresuid>() и B<setresgid>() работают одинаково вне зависимости от версий ядра."

#. type: Plain text
#: man-pages/man2/setresuid.2:136
msgid ""
"B<getresuid>(2), B<getuid>(2), B<setfsgid>(2), B<setfsuid>(2), "
"B<setreuid>(2), B<setuid>(2), B<capabilities>(7), B<credentials>(7)"
msgstr "B<getresuid>(2), B<getuid>(2), B<setfsgid>(2), B<setfsuid>(2), B<setreuid>(2), B<setuid>(2), B<capabilities>(7), B<credentials>(7)"

#. type: TH
#: man-pages/man2/sigprocmask.2:29
#, no-wrap
msgid "SIGPROCMASK"
msgstr "SIGPROCMASK"

#. type: TH
#: man-pages/man2/sigprocmask.2:29
#, no-wrap
msgid "2013-04-19"
msgstr "2013-04-19"

#. type: Plain text
#: man-pages/man2/sigprocmask.2:32
msgid "sigprocmask - examine and change blocked signals"
msgstr "sigprocmask - проверяет и изменяет блокировку сигналов"

#. type: Plain text
#: man-pages/man2/sigprocmask.2:37
msgid ""
"B<int sigprocmask(int >I<how>B<, const sigset_t *>I<set>B<,> B<sigset_t "
"*>I<oldset>B<);>"
msgstr "B<int sigprocmask(int >I<how>B<, const sigset_t *>I<set>B<,> B<sigset_t *>I<oldset>B<);>"

#. type: Plain text
#: man-pages/man2/sigprocmask.2:46
msgid ""
"B<sigprocmask>(): _POSIX_C_SOURCE\\ E<gt>=\\ 1 || _XOPEN_SOURCE || "
"_POSIX_SOURCE"
msgstr "B<sigprocmask>(): _POSIX_C_SOURCE\\ E<gt>=\\ 1 || _XOPEN_SOURCE || _POSIX_SOURCE"

#. type: Plain text
#: man-pages/man2/sigprocmask.2:55
msgid ""
"B<sigprocmask>()  is used to fetch and/or change the signal mask of the "
"calling thread.  The signal mask is the set of signals whose delivery is "
"currently blocked for the caller (see also B<signal>(7)  for more details)."
msgstr "Вызов B<sigprocmask>() используется для выборки и/или изменения маски сигналов вызывающей нити. Маска сигналов представляет собой набор сигналов, чья доставка в настоящее время заблокирована вызывающим (подробнее об этом смотрите также в B<signal>(7))."

#. type: Plain text
#: man-pages/man2/sigprocmask.2:59
msgid ""
"The behavior of the call is dependent on the value of I<how>, as follows."
msgstr "Работа вызова зависит от значения I<how>:"

#. type: TP
#: man-pages/man2/sigprocmask.2:59
#, no-wrap
msgid "B<SIG_BLOCK>"
msgstr "B<SIG_BLOCK>"

#. type: Plain text
#: man-pages/man2/sigprocmask.2:64
msgid ""
"The set of blocked signals is the union of the current set and the I<set> "
"argument."
msgstr "Набор блокируемых сигналов — объединение текущего набора и аргумента I<set>."

#. type: TP
#: man-pages/man2/sigprocmask.2:64
#, no-wrap
msgid "B<SIG_UNBLOCK>"
msgstr "B<SIG_UNBLOCK>"

#. type: Plain text
#: man-pages/man2/sigprocmask.2:70
msgid ""
"The signals in I<set> are removed from the current set of blocked signals.  "
"It is permissible to attempt to unblock a signal which is not blocked."
msgstr "Сигналы в I<set> удаляются из списка блокируемых сигналов. Допускается разблокировать незаблокированные сигналы."

#. type: TP
#: man-pages/man2/sigprocmask.2:70
#, no-wrap
msgid "B<SIG_SETMASK>"
msgstr "B<SIG_SETMASK>"

#. type: Plain text
#: man-pages/man2/sigprocmask.2:74
msgid "The set of blocked signals is set to the argument I<set>."
msgstr "Набор блокируемых сигналов приравнивается к аргументу I<set>."

#. type: Plain text
#: man-pages/man2/sigprocmask.2:79
msgid ""
"If I<oldset> is non-NULL, the previous value of the signal mask is stored in"
" I<oldset>."
msgstr "Если значение I<oldset> не равно NULL, то предыдущее значение маски сигналов записывается в I<oldset>."

#. type: Plain text
#: man-pages/man2/sigprocmask.2:88
msgid ""
"If I<set> is NULL, then the signal mask is unchanged (i.e., I<how> is "
"ignored), but the current value of the signal mask is nevertheless returned "
"in I<oldset> (if it is not NULL)."
msgstr "Если значение I<set> равно NULL, то маска сигналов не изменяется (т.е., значение I<how> игнорируется), но текущее значение маски сигналов всё же возвращается в I<oldset> (если его значение не равно NULL)."

#. type: Plain text
#: man-pages/man2/sigprocmask.2:93
msgid ""
"The use of B<sigprocmask>()  is unspecified in a multithreaded process; see "
"B<pthread_sigmask>(3)."
msgstr "Использование B<sigprocmask>() в многонитиевых процессах не определено; смотрите B<pthread_sigmask>(3)."

#. type: Plain text
#: man-pages/man2/sigprocmask.2:99
msgid ""
"B<sigprocmask>()  returns 0 on success and -1 on error.  In the event of an "
"error, I<errno> is set to indicate the cause."
msgstr "При успешном выполнении функция B<sigprocmask>() возвращает 0 и -1 при ошибке. В случае ошибки в I<errno> указывается номер ошибки."

#. type: Plain text
#: man-pages/man2/sigprocmask.2:107
msgid ""
"the I<set> or I<oldset> argument points outside the process's allocated "
"address space."
msgstr "аргумент I<set> или I<oldset> указывает за пределы выделенного адресного пространства процесса."

#. type: Plain text
#: man-pages/man2/sigprocmask.2:112
msgid "The value specified in I<how> was invalid."
msgstr "Неверное значение в I<how>."

#. type: Plain text
#: man-pages/man2/sigprocmask.2:118
msgid ""
"It is not possible to block B<SIGKILL> or B<SIGSTOP>.  Attempts to do so are"
" silently ignored."
msgstr "Невозможно заблокировать B<SIGKILL> или B<SIGSTOP>. Попытка выполнить это просто игнорируется."

#. type: Plain text
#: man-pages/man2/sigprocmask.2:120
msgid "Each of the threads in a process has its own signal mask."
msgstr "Каждая нить процесса имеют свою маску сигналов."

#. type: Plain text
#: man-pages/man2/sigprocmask.2:140
msgid ""
"If B<SIGBUS>, B<SIGFPE>, B<SIGILL>, or B<SIGSEGV> are generated while they "
"are blocked, the result is undefined, unless the signal was generated by "
"B<kill>(2), B<sigqueue>(3), or B<raise>(3)."
msgstr "Если генерируется сигнал B<SIGBUS>, B<SIGFPE>, B<SIGILL> или B<SIGSEGV>, а он заблокирован, то результат не определён, если сигнал был сгенерирован не из B<kill>(3), B<sigqueue>(3) или B<raise>(3)."

#. type: Plain text
#: man-pages/man2/sigprocmask.2:154
msgid ""
"B<kill>(2), B<pause>(2), B<sigaction>(2), B<signal>(2), B<sigpending>(2), "
"B<sigsuspend>(2), B<pthread_sigmask>(3), B<sigqueue>(3), B<sigsetops>(3), "
"B<signal>(7)"
msgstr "B<kill>(2), B<pause>(2), B<sigaction>(2), B<signal>(2), B<sigpending>(2), B<sigsuspend>(2), B<pthread_sigmask>(3), B<sigqueue>(3), B<sigsetops>(3), B<signal>(7)"

#. type: TH
#: man-pages/man2/setxattr.2:25
#, no-wrap
msgid "SETXATTR"
msgstr "SETXATTR"

#. type: TH
#: man-pages/man2/setxattr.2:25
#, no-wrap
msgid "2014-02-06"
msgstr "2014-02-06"

#. type: Plain text
#: man-pages/man2/setxattr.2:28
msgid "setxattr, lsetxattr, fsetxattr - set an extended attribute value"
msgstr "setxattr, lsetxattr, fsetxattr - устанавливает расширенное значение атрибутов"

#. type: Plain text
#: man-pages/man2/setxattr.2:33
#, no-wrap
msgid ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>sys/xattr.hE<gt>>\n"
msgstr "B<#include E<lt>sys/types.hE<gt>>\nB<#include E<lt>sys/xattr.hE<gt>>\n"

#. type: Plain text
#: man-pages/man2/setxattr.2:40
#, no-wrap
msgid ""
"B<int setxattr(const char\\ *>I<path>B<, const char\\ *>I<name>B<,>\n"
"B<              const void\\ *>I<value>B<, size_t >I<size>B<, int >I<flags>B<);>\n"
"B<int lsetxattr(const char\\ *>I<path>B<, const char\\ *>I<name>B<,>\n"
"B<              const void\\ *>I<value>B<, size_t >I<size>B<, int >I<flags>B<);>\n"
"B<int fsetxattr(int >I<fd>B<, const char\\ *>I<name>B<,>\n"
"B<              const void\\ *>I<value>B<, size_t >I<size>B<, int >I<flags>B<);>\n"
msgstr "B<int setxattr(const char\\ *>I<path>B<, const char\\ *>I<name>B<,>\nB<              const void\\ *>I<value>B<, size_t >I<size>B<, int >I<flags>B<);>\nB<int lsetxattr(const char\\ *>I<path>B<, const char\\ *>I<name>B<,>\nB<              const void\\ *>I<value>B<, size_t >I<size>B<, int >I<flags>B<);>\nB<int fsetxattr(int >I<fd>B<, const char\\ *>I<name>B<,>\nB<              const void\\ *>I<value>B<, size_t >I<size>B<, int >I<flags>B<);>\n"

#. type: Plain text
#: man-pages/man2/setxattr.2:53
msgid ""
"Extended attributes are I<name>:I<value> pairs associated with inodes "
"(files, directories, symbolic links, etc.).  They are extensions to the "
"normal attributes which are associated with all inodes in the system (i.e., "
"the B<stat>(2)  data).  A complete overview of extended attributes concepts "
"can be found in B<attr>(5)."
msgstr "Расширенные атрибуты представляют собой пару I<имя>:I<значение> и связываются с записями inode (файлы, каталоги, символьные ссылки и т.п.). Они являются расширениями к обычным атрибутам, связанным со всеми записями inode в системе (например, данные B<stat>(2)). Полное описание модели расширенных атрибутов можно найти в B<attr>(5)."

#. type: Plain text
#: man-pages/man2/setxattr.2:67
msgid ""
"B<setxattr>()  sets the I<value> of the extended attribute identified by "
"I<name> and associated with the given I<path> in the filesystem.  The "
"I<size> of the I<value> must be specified."
msgstr "B<setxattr>() устанавливает значение I<value> расширенного атрибута с именем, заданным в I<name> и связанного с заданным I<path> в файловой системе. Должен быть указан I<size> для I<value>."

#. type: Plain text
#: man-pages/man2/setxattr.2:73
msgid ""
"B<lsetxattr>()  is identical to B<setxattr>(), except in the case of a "
"symbolic link, where the extended attribute is set on the link itself, not "
"the file that it refers to."
msgstr "Вызов B<lsetxattr>() идентичен B<setxattr>(), за исключением случая работы с символьными ссылками; он устанавливает расширенный атрибут на ссылке, а не на том файле, на который она указывает."

#. type: Plain text
#: man-pages/man2/setxattr.2:83
msgid ""
"B<fsetxattr>()  is identical to B<setxattr>(), only the extended attribute "
"is set on the open file referred to by I<fd> (as returned by B<open>(2))  in"
" place of I<path>."
msgstr "Вызов B<fsetxattr>() идентичен B<setxattr>(), отличием является то, что расширенный атрибут устанавливается на открытом файле, на который указывает I<fd> (возвращаемом B<open>(2)), а не на указанном в I<path>."

#. type: Plain text
#: man-pages/man2/setxattr.2:93
msgid ""
"An extended attribute name is a simple null-terminated string.  The I<name> "
"includes a namespace prefix; there may be several, disjoint namespaces "
"associated with an individual inode.  The I<value> of an extended attribute "
"is a chunk of arbitrary textual or binary data of specified length."
msgstr "Имя расширенного атрибута представляет собой строку, заканчивающуюся NULL. Имя I<name> включает префикс пространства имён; их может быть несколько, разрозненные пространства ассоциируются с разными inode. Значением I<value> расширенного атрибута является произвольный кусок текстовых или двоичных данных определённой длины."

#. type: Plain text
#: man-pages/man2/setxattr.2:105
msgid ""
"The I<flags> argument can be used to refine the semantics of the operation."
"  B<XATTR_CREATE> specifies a pure create, which fails if the named "
"attribute exists already.  B<XATTR_REPLACE> specifies a pure replace "
"operation, which fails if the named attribute does not already exist.  By "
"default (no flags), the extended attribute will be created if need be, or "
"will simply replace the value if the attribute exists."
msgstr "Аргумент I<flags> может использоваться для уточнения семантики операций. B<XATTR_CREATE> определяет только создание и выдаёт ошибку, если указанный атрибут уже существует. B<XATTR_REPLACE> определяет только операцию замены и выдаёт ошибку, если указанный атрибут не существует. По умолчанию (без флагов) расширенный атрибут будет создан при необходимости, или просто заменит значение существующего атрибута."

#. type: Plain text
#: man-pages/man2/setxattr.2:110
msgid ""
"On success, zero is returned.  On failure, -1 is returned and I<errno> is "
"set appropriately."
msgstr "При успешном выполнении возвращается ноль. В случае ошибки возвращается -1, а I<errno> устанавливается в соответствующее значение."

#. type: TP
#: man-pages/man2/setxattr.2:111
#, no-wrap
msgid "B<EDQUOT>"
msgstr "B<EDQUOT>"

#. type: Plain text
#: man-pages/man2/setxattr.2:115
msgid ""
"Disk quota limits meant that there is insufficient space remaining to store "
"the extended attribute."
msgstr "Предел по дисковой квоте; не хватает пространства для сохранения расширенного атрибута."

#. type: Plain text
#: man-pages/man2/setxattr.2:119
msgid "B<XATTR_CREATE> was specified, and the attribute exists already."
msgstr "Указан B<XATTR_CREATE>, но атрибут уже существует."

#. type: TP
#: man-pages/man2/setxattr.2:119
#, no-wrap
msgid "B<ENOATTR>"
msgstr "B<ENOATTR>"

#. type: Plain text
#: man-pages/man2/setxattr.2:128
msgid ""
"B<XATTR_REPLACE> was specified, and the attribute does not exist.  "
"(B<ENOATTR> is defined to be a synonym for B<ENODATA> in "
"I<E<lt>attr/xattr.hE<gt>>.)"
msgstr "Указан B<XATTR_REPLACE>, но атрибут не существует (B<ENOATTR> — синоним B<ENODATA> в I<E<lt>attr/xattr.hE<gt>>)."

#. type: Plain text
#: man-pages/man2/setxattr.2:131
msgid "There is insufficient space remaining to store the extended attribute."
msgstr "Не хватает пространства для сохранения расширенного атрибута."

#. type: TP
#: man-pages/man2/setxattr.2:131
#, no-wrap
msgid "B<ENOTSUP>"
msgstr "B<ENOTSUP>"

#. type: Plain text
#: man-pages/man2/setxattr.2:137
msgid ""
"Extended attributes are not supported by the filesystem, or are disabled, "
"I<errno> is set to B<ENOTSUP>."
msgstr "Расширенные атрибуты не поддерживаются файловой системой или отключены, переменной I<errno> присваивается значение B<ENOTSUP>."

#. type: Plain text
#: man-pages/man2/setxattr.2:141
msgid "In addition, the errors documented in B<stat>(2)  can also occur."
msgstr "Также могут возникать ошибки, описанные в B<stat>(2)."

#. type: Plain text
#: man-pages/man2/setxattr.2:144
msgid ""
"These system calls have been available on Linux since kernel 2.4; glibc "
"support is provided since version 2.3."
msgstr "Данные системные вызовы доступны в Linux начиная с ядра версии 2.4; поддержка в glibc появилась в версии 2.3."

#. type: Plain text
#: man-pages/man2/setxattr.2:161
msgid ""
"B<getfattr>(1), B<setfattr>(1), B<getxattr>(2), B<listxattr>(2), B<open>(2),"
" B<removexattr>(2), B<stat>(2), B<attr>(5), B<symlink>(7)"
msgstr "B<getfattr>(1), B<setfattr>(1), B<getxattr>(2), B<listxattr>(2), B<open>(2), B<removexattr>(2), B<stat>(2), B<attr>(5), B<symlink>(7)"

#. type: TH
#: man-pages/man2/setgid.2:29
#, no-wrap
msgid "SETGID"
msgstr "SETGID"

#. type: TH
#: man-pages/man2/setgid.2:29
#, no-wrap
msgid "2010-11-22"
msgstr "2010-11-22"

#. type: Plain text
#: man-pages/man2/setgid.2:32
msgid "setgid - set group identity"
msgstr "setgid - устанавливает идентификатор группы процесса"

#. type: Plain text
#: man-pages/man2/setgid.2:34
msgid "B<#include E<lt>sys/types.hE<gt>>"
msgstr "B<#include E<lt>sys/types.hE<gt>>"

#. type: Plain text
#: man-pages/man2/setgid.2:38
msgid "B<int setgid(gid_t >I<gid>B<);>"
msgstr "B<int setgid(gid_t >I<gid>B<);>"

#. type: Plain text
#: man-pages/man2/setgid.2:43
msgid ""
"B<setgid>()  sets the effective group ID of the calling process.  If the "
"caller is the superuser, the real GID and saved set-group-ID are also set."
msgstr "B<setgid>() устанавливает идентификатор эффективной группы вызвавшего процесса. Если функция вызвана суперпользователем, то также устанавливаются действительный и сохраненной идентификаторы группы."

#. type: Plain text
#: man-pages/man2/setgid.2:53
msgid ""
"Under Linux, B<setgid>()  is implemented like the POSIX version with the "
"B<_POSIX_SAVED_IDS> feature.  This allows a set-group-ID program that is not"
" set-user-ID-root to drop all of its group privileges, do some un-privileged"
" work, and then reengage the original effective group ID in a secure manner."
msgstr "В Linux B<setgid>() реализован так же, как в версии POSIX где есть возможность B<_POSIX_SAVED_IDS>. Это позволяет set-group-ID-программам (не являющимся программами суперпользователя) сбросить привилегии группы, проделать непривилегированную работу и безопасно вернуть исходный эффективный идентификатор группы."

#. type: Plain text
#: man-pages/man2/setgid.2:66
msgid ""
"The calling process is not privileged (does not have the B<CAP_SETGID> "
"capability), and I<gid> does not match the real group ID or saved set-group-"
"ID of the calling process."
msgstr "У вызвавшего процесса нет прав (не имеет мандата B<CAP_SETGID>) и I<gid> не совпадает с эффективным идентификатором группы или сохраненным идентификатором группы."

#. type: Plain text
#: man-pages/man2/setgid.2:78
msgid ""
"The original Linux B<setgid>()  system call supported only 16-bit group IDs."
"  Subsequently, Linux 2.4 added B<setgid32>()  supporting 32-bit IDs.  The "
"glibc B<setgid>()  wrapper function transparently deals with the variation "
"across kernel versions."
msgstr "Первоначальная версия системного вызова B<setgid>() в Linux поддерживала только 16-битные идентификаторы групп. Позднее в Linux 2.4 был добавлен вызов B<setgid32>(), поддерживающий 32-битные идентификаторы. В glibc обёрточная функция B<gsetgid>() работает одинаково вне зависимости от версий ядра."

#. type: Plain text
#: man-pages/man2/setgid.2:83
msgid ""
"B<getgid>(2), B<setegid>(2), B<setregid>(2), B<capabilities>(7), "
"B<credentials>(7)"
msgstr "B<getgid>(2), B<setegid>(2), B<setregid>(2), B<capabilities>(7), B<credentials>(7)"

#. type: TH
#: man-pages/man2/sysctl.2:30
#, no-wrap
msgid "SYSCTL"
msgstr "SYSCTL"

#. type: TH
#: man-pages/man2/sysctl.2:30
#, no-wrap
msgid "2012-12-22"
msgstr "2012-12-22"

#. type: Plain text
#: man-pages/man2/sysctl.2:33
msgid "sysctl - read/write system parameters"
msgstr "sysctl - читает/записывает параметры системы"

#. type: Plain text
#: man-pages/man2/sysctl.2:36
#, no-wrap
msgid "B<#include E<lt>unistd.hE<gt>>\n"
msgstr "B<#include E<lt>unistd.hE<gt>>\n"

#. type: Plain text
#: man-pages/man2/sysctl.2:38
#, no-wrap
msgid "B<#include E<lt>linux/sysctl.hE<gt>>\n"
msgstr "B<#include E<lt>linux/sysctl.hE<gt>>\n"

#. type: Plain text
#: man-pages/man2/sysctl.2:40
#, no-wrap
msgid "B<int _sysctl(struct __sysctl_args *>I<args>B<);>\n"
msgstr "B<int _sysctl(struct __sysctl_args *>I<args>B<);>\n"

#. type: Plain text
#: man-pages/man2/sysctl.2:47
msgid "B<Do not use this system call!> See NOTES."
msgstr "B<Не используйте этот системный вызов!> Смотрите ЗАМЕЧАНИЯ."

#. type: Plain text
#: man-pages/man2/sysctl.2:54
msgid ""
"The B<_sysctl>()  call reads and/or writes kernel parameters.  For example, "
"the hostname, or the maximum number of open files.  The argument has the "
"form"
msgstr "Системный вызов B<_sysctl> считывает и/или изменяет параметры ядра. К ним относятся, например, имя машины или максимальное количество открытых файлов. Параметр имеет следующую структуру:"

#. type: Plain text
#: man-pages/man2/sysctl.2:66
#, no-wrap
msgid ""
"struct __sysctl_args {\n"
"    int    *name;    /* integer vector describing variable */\n"
"    int     nlen;    /* length of this vector */\n"
"    void   *oldval;  /* 0 or address where to store old value */\n"
"    size_t *oldlenp; /* available room for old value,\n"
"                        overwritten by actual size of old value */\n"
"    void   *newval;  /* 0 or address of new value */\n"
"    size_t  newlen;  /* size of new value */\n"
"};\n"
msgstr "struct __sysctl_args {\n    int    *name;    /* целочисленный вектор, описывающий\n                        переменную */\n    int     nlen;    /* длина этого вектора */\n    void   *oldval;  /* 0 или адрес старого значения */\n    size_t *oldlenp; /* размер старого значения, заменяется\n                        реальным размером старого значения */\n    void   *newval;  /* 0 или адрес нового значения */\n    size_t  newlen;  /* размер нового значения */\n};\n"

#. type: Plain text
#: man-pages/man2/sysctl.2:74
msgid ""
"This call does a search in a tree structure, possibly resembling a directory"
" tree under I</proc/sys>, and if the requested item is found calls some "
"appropriate routine to read or modify the value."
msgstr "Этот вызов производит поиск в древовидной структуре, возможно, похожей на структуру каталогов I</proc/sys>, и, если запрашиваемый элемент найден, вызывает соответствующую процедуру, читающую или изменяющую значение."

#. type: Plain text
#: man-pages/man2/sysctl.2:81
msgid ""
"Upon successful completion, B<_sysctl>()  returns 0.  Otherwise, a value of "
"-1 is returned and I<errno> is set to indicate the error."
msgstr "При успешном выполнении B<_sysctl>() возвращает 0. При ошибке возвращается -1, а переменной I<errno> присваивается номер ошибки."

#. type: Plain text
#: man-pages/man2/sysctl.2:88
msgid ""
"The invocation asked for the previous value by setting I<oldval> non-NULL, "
"but allowed zero room in I<oldlenp>."
msgstr "Был сделан запрос предыдущего значения путём установки не-NULL значения I<oldval>, но размер места под него в I<oldlenp> равен нулю."

#. type: TP
#: man-pages/man2/sysctl.2:88
#, no-wrap
msgid "B<ENOTDIR>"
msgstr "B<ENOTDIR>"

#. type: Plain text
#: man-pages/man2/sysctl.2:92
msgid "I<name> was not found."
msgstr "I<name> не найден."

#. type: TP
#: man-pages/man2/sysctl.2:92
#, no-wrap
msgid "B<EACCES>, B<EPERM>"
msgstr "B<EACCES>, B<EPERM>"

#. type: Plain text
#: man-pages/man2/sysctl.2:100
msgid ""
"No search permission for one of the encountered \"directories\", or no read "
"permission where I<oldval> was nonzero, or no write permission where "
"I<newval> was nonzero."
msgstr "Нет прав на поиск в одном из встретившихся «каталогов» или нет прав на чтение, если I<oldval> не равно нулю; или нет прав на запись, если I<newval> не равно нулю."

#. type: Plain text
#: man-pages/man2/sysctl.2:114
msgid ""
"This call is Linux-specific, and should not be used in programs intended to "
"be portable.  A B<sysctl>()  call has been present in Linux since version "
"1.3.57.  It originated in 4.4BSD.  Only Linux has the I</proc/sys> mirror, "
"and the object naming schemes differ between Linux and 4.4BSD, but the "
"declaration of the B<sysctl>()  function is the same in both."
msgstr "Этот вызов есть только в Linux и не должен использоваться в переносимых программах. Вызов B<sysctl>() впервые появился в Linux 1.3.57. Впервые он появился в 4.4BSD. Только в Linux существует зеркало I</proc/sys>, и схемы именования объектов в Linux и 4.4BSD различаются, но объявление функции B<sysctl>() одинаково в обеих системах."

#.  See http://lwn.net/Articles/247243/
#.  Though comments in suggest that it is needed by old glibc binaries,
#.  so maybe it's not going away.
#. type: Plain text
#: man-pages/man2/sysctl.2:131
msgid ""
"Glibc does not provide a wrapper for this system call; call it using "
"B<syscall>(2).  Or rather...  I<don't> call it: use of this system call has "
"long been discouraged, and it is so unloved that B<it is likely to disappear"
" in a future kernel version>.  Since Linux 2.6.24, uses of this system call "
"result in warnings in the kernel log.  Remove it from your programs now; use"
" the I</proc/sys> interface instead."
msgstr "В glibc отсутствует обёрточная функция для этого системного вызова; вызывайте его через B<syscall>(2).  Или лучше I<совсем> не используйте: использование данного системного вызова уже давно не рекомендуется и он так всем не нравится, что, B<вероятно, исчезнет в новой версии ядра>. Начиная с Linux 2.6.24, при использовании данного системного вызова записывается предупреждение в журнал ядра. Удалите вызов из своих программ прямо сейчас; вместо него используйте интерфейс I</proc/sys>."

#. type: Plain text
#: man-pages/man2/sysctl.2:135
msgid ""
"This system call is available only if the kernel was configured with the "
"B<CONFIG_SYSCTL_SYSCALL> option."
msgstr "Данный системный вызов доступен только, если ядро было собрано с параметром B<CONFIG_SYSCTL_SYSCALL>."

#. type: Plain text
#: man-pages/man2/sysctl.2:138
msgid ""
"The object names vary between kernel versions, making this system call "
"worthless for applications."
msgstr "Названия объектов различаются в разных версиях ядра, что делает данный вызов в приложениях бесполезным."

#. type: Plain text
#: man-pages/man2/sysctl.2:140
msgid "Not all available objects are properly documented."
msgstr "Не все существующие объекты описаны соответствующим образом."

#. type: Plain text
#: man-pages/man2/sysctl.2:143
msgid ""
"It is not yet possible to change operating system by writing to "
"I</proc/sys/kernel/ostype>."
msgstr "В настоящее время невозможно изменить тип операционной системы путём записи в файл I</proc/sys/kernel/ostype>."

#. type: Plain text
#: man-pages/man2/sysctl.2:152
#, no-wrap
msgid ""
"#define _GNU_SOURCE\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>sys/syscall.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>linux/sysctl.hE<gt>\n"
msgstr "#define _GNU_SOURCE\n#include E<lt>unistd.hE<gt>\n#include E<lt>sys/syscall.hE<gt>\n#include E<lt>string.hE<gt>\n#include E<lt>stdio.hE<gt>\n#include E<lt>stdlib.hE<gt>\n#include E<lt>linux/sysctl.hE<gt>\n"

#. type: Plain text
#: man-pages/man2/sysctl.2:154
#, no-wrap
msgid "int _sysctl(struct __sysctl_args *args );\n"
msgstr "int _sysctl(struct __sysctl_args *args );\n"

#. type: Plain text
#: man-pages/man2/sysctl.2:156
#, no-wrap
msgid "#define OSNAMESZ 100\n"
msgstr "#define OSNAMESZ 100\n"

#. type: Plain text
#: man-pages/man2/sysctl.2:164
#, no-wrap
msgid ""
"int\n"
"main(void)\n"
"{\n"
"    struct __sysctl_args args;\n"
"    char osname[OSNAMESZ];\n"
"    size_t osnamelth;\n"
"    int name[] = { CTL_KERN, KERN_OSTYPE };\n"
msgstr "int\nmain(void)\n{\n    struct __sysctl_args args;\n    char osname[OSNAMESZ];\n    size_t osnamelth;\n    int name[] = { CTL_KERN, KERN_OSTYPE };\n"

#. type: Plain text
#: man-pages/man2/sysctl.2:170
#, no-wrap
msgid ""
"    memset(&args, 0, sizeof(struct __sysctl_args));\n"
"    args.name = name;\n"
"    args.nlen = sizeof(name)/sizeof(name[0]);\n"
"    args.oldval = osname;\n"
"    args.oldlenp = &osnamelth;\n"
msgstr "    memset(&args, 0, sizeof(struct __sysctl_args));\n    args.name = name;\n    args.nlen = sizeof(name)/sizeof(name[0]);\n    args.oldval = osname;\n    args.oldlenp = &osnamelth;\n"

#. type: Plain text
#: man-pages/man2/sysctl.2:172
#, no-wrap
msgid "    osnamelth = sizeof(osname);\n"
msgstr "    osnamelth = sizeof(osname);\n"

#. type: Plain text
#: man-pages/man2/sysctl.2:180
#, no-wrap
msgid ""
"    if (syscall(SYS__sysctl, &args) == -1) {\n"
"        perror(\"_sysctl\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
"    printf(\"This machine is running %*s\\en\", osnamelth, osname);\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr "    if (syscall(SYS__sysctl, &args) == -1) {\n        perror(\"_sysctl\");\n        exit(EXIT_FAILURE);\n    }\n    printf(\"Эта машина работает в %*s\\en\", osnamelth, osname);\n    exit(EXIT_SUCCESS);\n}\n"

#. type: Plain text
#: man-pages/man2/sysctl.2:182
msgid "B<proc>(5)"
msgstr "B<proc>(5)"

#. type: TH
#: man-pages/man2/sysinfo.2:14
#, no-wrap
msgid "SYSINFO"
msgstr "SYSINFO"

#. type: TH
#: man-pages/man2/sysinfo.2:14
#, no-wrap
msgid "2012-05-05"
msgstr "2012-05-05"

#. type: Plain text
#: man-pages/man2/sysinfo.2:17
msgid "sysinfo - returns information on overall system statistics"
msgstr "sysinfo - возвращает общесистемную статистику"

#. type: Plain text
#: man-pages/man2/sysinfo.2:19
msgid "B<#include E<lt>sys/sysinfo.hE<gt>>"
msgstr "B<#include E<lt>sys/sysinfo.hE<gt>>"

#. type: Plain text
#: man-pages/man2/sysinfo.2:21
msgid "B<int sysinfo(struct sysinfo *>I<info>B<);>"
msgstr "B<int sysinfo(struct sysinfo *>I<info>B<);>"

#. type: Plain text
#: man-pages/man2/sysinfo.2:25
msgid ""
"Until Linux 2.3.16, B<sysinfo>()  used to return information in the "
"following structure:"
msgstr "В ядрах Linux версий, более ранних, чем 2.3.16, B<sysinfo>() возвращал следующую структуру:"

#. type: Plain text
#: man-pages/man2/sysinfo.2:40
#, no-wrap
msgid ""
"struct sysinfo {\n"
"    long uptime;             /* Seconds since boot */\n"
"    unsigned long loads[3];  /* 1, 5, and 15 minute load averages */\n"
"    unsigned long totalram;  /* Total usable main memory size */\n"
"    unsigned long freeram;   /* Available memory size */\n"
"    unsigned long sharedram; /* Amount of shared memory */\n"
"    unsigned long bufferram; /* Memory used by buffers */\n"
"    unsigned long totalswap; /* Total swap space size */\n"
"    unsigned long freeswap;  /* swap space still available */\n"
"    unsigned short procs;    /* Number of current processes */\n"
"    char _f[22];             /* Pads structure to 64 bytes */\n"
"};\n"
msgstr "struct sysinfo {\n    long uptime;             /* Количество секунд, прошедшее\n                                с загрузки системы */\n    unsigned long loads[3];  /* средняя 1, 5 и 15-минутная загруженность\n                                системы */\n    unsigned long totalram;  /* Общий объём доступной оперативной памяти */\n    unsigned long freeram;   /* Объём свободной памяти */\n    unsigned long sharedram; /* Объём общей памяти */\n    unsigned long bufferram; /* Объём памяти, использованной под буферы */\n    unsigned long totalswap; /* Общий объём области подкачки */\n    unsigned long freeswap;  /* Объём свободного пространства в области\n                                подкачки */\n    unsigned short procs;    /* Текущее количество процессов */\n    char _f[22];             /* Дополнение структуры до 64 байтов */\n};\n"

#. type: Plain text
#: man-pages/man2/sysinfo.2:44
msgid "and the sizes were given in bytes."
msgstr "все размеры считаются в байтах."

#. type: Plain text
#: man-pages/man2/sysinfo.2:47
msgid ""
"Since Linux 2.3.23 (i386), 2.3.48 (all architectures) the structure is:"
msgstr "Начиная с ядра версии 2.3.23 (i386), 2.3.48 (остальные архитектуры), структура стала следующей:"

#. type: Plain text
#: man-pages/man2/sysinfo.2:65
#, no-wrap
msgid ""
"struct sysinfo {\n"
"    long uptime;             /* Seconds since boot */\n"
"    unsigned long loads[3];  /* 1, 5, and 15 minute load averages */\n"
"    unsigned long totalram;  /* Total usable main memory size */\n"
"    unsigned long freeram;   /* Available memory size */\n"
"    unsigned long sharedram; /* Amount of shared memory */\n"
"    unsigned long bufferram; /* Memory used by buffers */\n"
"    unsigned long totalswap; /* Total swap space size */\n"
"    unsigned long freeswap;  /* swap space still available */\n"
"    unsigned short procs;    /* Number of current processes */\n"
"    unsigned long totalhigh; /* Total high memory size */\n"
"    unsigned long freehigh;  /* Available high memory size */\n"
"    unsigned int mem_unit;   /* Memory unit size in bytes */\n"
"    char _f[20-2*sizeof(long)-sizeof(int)]; /* Padding to 64 bytes */\n"
"};\n"
msgstr "struct sysinfo {\n    long uptime;             /* Количество секунд, прошедшее с загрузки\n                                системы */\n    unsigned long loads[3];  /* средняя 1,  и 15-минутная загруженность\n                                системы */\n    unsigned long totalram;  /* Общий объём доступной оперативной памяти */\n    unsigned long freeram;   /* Объём свободной памяти */\n    unsigned long sharedram; /* Объём общей памяти */\n    unsigned long bufferram; /* Объём памяти, использованной под буферы */\n    unsigned long totalswap; /* Общий объём области подкачки */\n    unsigned long freeswap;  /* Объём свободного пространства в области\n                                подкачки */\n    unsigned short procs;    /* Текущее количество процессов */\n    unsigned long totalhigh; /* Общий объём дальней (high) памяти */\n    unsigned long freehigh;  /* Объём свободной дальней памяти */\n    unsigned int mem_unit;   /* Размер элемента памяти в байтах */\n    char _f[20-2*sizeof(long)-sizeof(int)]; /* Дополнение до 64 байт */\n};\n"

#. type: Plain text
#: man-pages/man2/sysinfo.2:69
msgid "and the sizes are given as multiples of I<mem_unit> bytes."
msgstr "для получения размеров в байтах их надо умножить на I<mem_unit>."

#. type: Plain text
#: man-pages/man2/sysinfo.2:74
msgid ""
"B<sysinfo>()  provides a simple way of getting overall system statistics.  "
"This is more portable than reading I</dev/kmem>."
msgstr "B<sysinfo>() предоставляет простой способ получения общесистемной статистики. Это более переносимый способ по сравнению с чтением I</dev/kmem>."

#. type: Plain text
#: man-pages/man2/sysinfo.2:83
msgid "pointer to I<struct\\ sysinfo> is invalid"
msgstr "Недопустимый указатель на I<struct\\ sysinfo>"

#. type: Plain text
#: man-pages/man2/sysinfo.2:86
msgid ""
"This function is Linux-specific, and should not be used in programs intended"
" to be portable."
msgstr "Данная функция есть только в Linux и не должна использоваться в программах, которые задуманы как переносимые."

#. type: Plain text
#: man-pages/man2/sysinfo.2:94
msgid ""
"The Linux kernel has a B<sysinfo>()  system call since 0.98.pl6.  Linux libc"
" contains a B<sysinfo>()  routine since 5.3.5, and glibc has one since 1.90."
msgstr "Системный вызов B<sysinfo>() есть в ядре Linux начиная с версии 0.98.pl6. В Linux libc функция B<sysinfo>() появилась в версии 5.3.5, а в glibc начиная с 1.90."

#. type: TH
#: man-pages/man2/setfsuid.2:31
#, no-wrap
msgid "SETFSUID"
msgstr "SETFSUID"

#. type: TH
#: man-pages/man2/setfsuid.2:31
#, no-wrap
msgid "2013-08-08"
msgstr "2013-08-08"

#. type: Plain text
#: man-pages/man2/setfsuid.2:34
msgid "setfsuid - set user identity used for filesystem checks"
msgstr "setfsuid - устанавливает идентификатор пользователя для доступа к файловой системе"

#. type: Plain text
#: man-pages/man2/setfsuid.2:36
msgid "B<#include E<lt>sys/fsuid.hE<gt>>"
msgstr "B<#include E<lt>sys/fsuid.hE<gt>>"

#. type: Plain text
#: man-pages/man2/setfsuid.2:38
msgid "B<int setfsuid(uid_t >I<fsuid>B<);>"
msgstr "B<int setfsuid(uid_t >I<fsuid>B<);>"

#. type: Plain text
#: man-pages/man2/setfsuid.2:51
msgid ""
"The system call B<setfsuid>()  changes the value of the caller's filesystem "
"user ID\\(emthe user ID that the Linux kernel uses to check for all accesses"
" to the filesystem.  Normally, the value of the filesystem user ID will "
"shadow the value of the effective user ID.  In fact, whenever the effective "
"user ID is changed, the filesystem user ID will also be changed to the new "
"value of the effective user ID."
msgstr "Системный вызов B<setfsuid>() изменяет значение идентификатора пользователя файловой системы вызывающего — идентификатор пользователя, который ядро Linux использует для проверки при любом доступе к файловой системе. Обычно, значение идентификатора пользователя файловой системы равно теневому значению эффективного идентификатора пользователя. Более того, при изменении идентификатора эффективного идентификатора пользователя также изменяется и идентификатор пользователя файловой системы на новое значение идентификатора эффективного идентификатора пользователя."

#. type: Plain text
#: man-pages/man2/setfsuid.2:62
msgid ""
"Explicit calls to B<setfsuid>()  and B<setfsgid>(2)  are usually used only "
"by programs such as the Linux NFS server that need to change what user and "
"group ID is used for file access without a corresponding change in the real "
"and effective user and group IDs.  A change in the normal user IDs for a "
"program such as the NFS server is a security hole that can expose it to "
"unwanted signals.  (But see below.)"
msgstr "Вызовы B<setfsuid>() и B<setfsgid>(2) обычно используются только в программах Linux типа NFS-сервера, которым требуется изменить идентификатор пользователя и группы для доступа к файлам без изменения действительного и эффективного идентификаторов пользователя и группы. Изменение обычного идентификатора пользователя для программы типа NFS-сервера \\(em это нарушение безопасности, приводящее к возможному получению нежелательных сигналов от других групп (но читайте далее)."

#. type: Plain text
#: man-pages/man2/setfsuid.2:68
msgid ""
"B<setfsuid>()  will succeed only if the caller is the superuser or if "
"I<fsuid> matches either the caller's real user ID, effective user ID, saved "
"set-user-ID, or current filesystem user ID."
msgstr "Вызов B<setfsuid>() выполняется корректно, только если он был вызван суперпользователем или, если I<fsuid> совпадает с действительным, эффективным и сохранённым идентификатором пользователя или равен текущему значению идентификатора пользователя файловой системы вызывающего."

#. type: Plain text
#: man-pages/man2/setfsuid.2:71
msgid ""
"On both success and failure, this call returns the previous filesystem user "
"ID of the caller."
msgstr "При успешном выполнении или при ошибке данный вызов возвращает предыдущий идентификатор пользователя файловой системы вызвавшего."

#.  This system call is present since Linux 1.1.44
#.  and in libc since libc 4.7.6.
#. type: Plain text
#: man-pages/man2/setfsuid.2:75
msgid "This system call is present in Linux since version 1.2."
msgstr "Данный системный вызов доступен в Linux начиная с версии 1.2."

#. type: Plain text
#: man-pages/man2/setfsuid.2:79
msgid ""
"B<setfsuid>()  is Linux-specific and should not be used in programs intended"
" to be portable."
msgstr "Вызов B<setfsuid>() есть только в Linux и не должен использоваться в переносимых программах."

#. type: Plain text
#: man-pages/man2/setfsuid.2:85
msgid ""
"When glibc determines that the argument is not a valid user ID, it will "
"return -1 and set I<errno> to B<EINVAL> without attempting the system call."
msgstr "Если в glibc определяется, что в аргументе указан неправильный идентификатор пользователя, то возвращается -1, I<errno> присваивается значение B<EINVAL>, а системный вызов не выполняется."

#. type: Plain text
#: man-pages/man2/setfsuid.2:104
msgid ""
"At the time when this system call was introduced, one process could send a "
"signal to another process with the same effective user ID.  This meant that "
"if a privileged process changed its effective user ID for the purpose of "
"file permission checking, then it could become vulnerable to receiving "
"signals sent by another (unprivileged) process with the same user ID.  The "
"filesystem user ID attribute was thus added to allow a process to change its"
" user ID for the purposes of file permission checking without at the same "
"time becoming vulnerable to receiving unwanted signals.  Since Linux 2.0, "
"signal permission handling is different (see B<kill>(2)), with the result "
"that a process change can change its effective user ID without being "
"vulnerable to receiving signals from unwanted processes.  Thus, "
"B<setfsuid>()  is nowadays unneeded and should be avoided in new "
"applications (likewise for B<setfsgid>(2))."
msgstr "На момент появления данного системного вызова один процесс мог послать сигнал другому процессу с тем же эффективным идентификатором пользователя. Это означает, что если привилегированный процесс изменит свой эффективный идентификатор пользователя с целью проверки доступа к файлу, то он сможет стать уязвимым к приёму сигналов, посланных (непривилегированным) процессом с тем же идентификатором пользователя. Атрибут идентификатора пользователя файловой системы был добавлен как раз для того, чтобы позволить процессу изменить свой идентификатор пользователя для проверки доступа к файлу не боясь стать уязвимым к приёму нежелаемых сигналов. Начиная с Linux 2.0, обработка прав на сигналы была изменена (смотрите B<kill>(2)), что позволило процессу изменять свой эффективный идентификатор пользователя без боязни стать уязвимым к приёму нежелаемых сигналов от других процессов.Таким образом, сейчас системный вызов B<setfsuid>() уже не нужен и не должен использоваться в новых приложениях (как и B<setfsgid>(2))."

#. type: Plain text
#: man-pages/man2/setfsuid.2:114
msgid ""
"The original Linux B<setfsuid>()  system call supported only 16-bit user "
"IDs.  Subsequently, Linux 2.4 added B<setfsuid32>()  supporting 32-bit IDs."
"  The glibc B<setfsuid>()  wrapper function transparently deals with the "
"variation across kernel versions."
msgstr "Первоначальная версия системного вызова B<setfsuid>() в Linux поддерживала только 16-битные идентификаторы пользователя. Позднее в Linux 2.4 был добавлен вызов B<setfsuid32>(), поддерживающий 32-битные идентификаторы. В glibc обёрточная функция B<setfsuid>() работает одинаково вне зависимости от версий ядра."

#. type: Plain text
#: man-pages/man2/setfsuid.2:131
msgid ""
"No error indications of any kind are returned to the caller, and the fact "
"that both successful and unsuccessful calls return the same value makes it "
"impossible to directly determine whether the call succeeded or failed.  "
"Instead, the caller must resort to looking at the return value from a "
"further call such as I<setfsuid(-1)> (which will always fail), in order to "
"determine if a preceding call to B<setfsuid>()  changed the filesystem user "
"ID.  At the very least, B<EPERM> should be returned when the call fails "
"(because the caller lacks the B<CAP_SETUID> capability)."
msgstr "Вызывающему не возвращается никаких ошибок, и факт того, что успешном или неудачном выполнении возвращается одинаковое значение, делает невозможным напрямую определить как завершился вызов. Вместо этого, вызывающий должен получить значение из ещё одного вызова — I<setfsuid(-1)> (который всегда завершается с ошибкой), чтобы определить, изменил ли предыдущий вызов B<setfsuid>() идентификатор пользователя файловой системы. По крайней мере, должно быть получено значение B<EPERM>, если вызов завершится с ошибкой (так как у вызывающего нет мандата B<CAP_SETUID>)."

#. type: Plain text
#: man-pages/man2/setfsuid.2:135
msgid "B<kill>(2), B<setfsgid>(2), B<capabilities>(7), B<credentials>(7)"
msgstr "B<kill>(2), B<setfsgid>(2), B<capabilities>(7), B<credentials>(7)"

#. type: TH
#: man-pages/man2/setuid.2:30
#, no-wrap
msgid "SETUID"
msgstr "SETUID"

#. type: Plain text
#: man-pages/man2/setuid.2:33
msgid "setuid - set user identity"
msgstr "setuid - устанавливает идентификатор пользователя"

#. type: Plain text
#: man-pages/man2/setuid.2:39
msgid "B<int setuid(uid_t >I<uid>B<);>"
msgstr "B<int setuid(uid_t >I<uid>B<);>"

#. type: Plain text
#: man-pages/man2/setuid.2:44
msgid ""
"B<setuid>()  sets the effective user ID of the calling process.  If the "
"effective UID of the caller is root, the real UID and saved set-user-ID are "
"also set."
msgstr "B<setuid>() устанавливает эффективный идентификатор владельца вызывающего процесса. Если эффективный идентификатор вызывающего является суперпользователем (root), то также устанавливаются действительный и сохранённый идентификаторы."

#. type: Plain text
#: man-pages/man2/setuid.2:53
msgid ""
"Under Linux, B<setuid>()  is implemented like the POSIX version with the "
"B<_POSIX_SAVED_IDS> feature.  This allows a set-user-ID (other than root) "
"program to drop all of its user privileges, do some un-privileged work, and "
"then reengage the original effective user ID in a secure manner."
msgstr "В Linux B<setuid>() реализован как и в стандарте POSIX с возможностью B<_POSIX_SAVED_IDS>. Это позволяет setuid-программам (не setuid-root) сбрасывать все привилегии, делать непривилегированную работу, а затем безопасным путём возвращать себе исходный эффективный идентификатор пользователя."

#. type: Plain text
#: man-pages/man2/setuid.2:63
msgid ""
"If the user is root or the program is set-user-ID-root, special care must be"
" taken.  The B<setuid>()  function checks the effective user ID of the "
"caller and if it is the superuser, all process-related user ID's are set to "
"I<uid>.  After this has occurred, it is impossible for the program to regain"
" root privileges."
msgstr "Если пользователь root или программа установлена как setuid root, при работе требуется особая осторожность. Функция B<setuid>() проверяет эффективный идентификатор вызвавшего пользователя и, если это суперпользователь, то все устанавливаемые значения идентификаторов равны I<uid>. После этого программа уже никаким образом не сможет вернуть права пользователя root."

#. type: Plain text
#: man-pages/man2/setuid.2:70
msgid ""
"Thus, a set-user-ID-root program wishing to temporarily drop root "
"privileges, assume the identity of an unprivileged user, and then regain "
"root privileges afterward cannot use B<setuid>().  You can accomplish this "
"with B<seteuid>(2)."
msgstr "Таким образом, программа, принадлежащая root и с установленным битом setuid, собирающаяся временно сбросить права root и поработать с правами непривилегированного пользователя, а затем восстановить права root, не сможет использовать B<setuid>(). Требуемого результата можно достичь с помощью вызова B<seteuid>(2)."

#. type: Plain text
#: man-pages/man2/setuid.2:82
msgid ""
"I<Note>: there are cases where B<setuid>()  can fail even when the caller is"
" UID 0; it is a grave security error to omit checking for a failure return "
"from B<setuid>()."
msgstr ""

#. type: Plain text
#: man-pages/man2/setuid.2:90
msgid ""
"The call would change the caller's real UID (i.e., I<uid> does not match the"
" caller's real UID), but there was a temporary failure allocating the "
"necessary kernel data structures."
msgstr "Вызов изменил бы настоящего реальный UID вызывающего (т. е. I<uid> не совпадает с реальным UID вызывающего), но возникла временная ошибка при выделении памяти под необходимые структуры ядра."

#. type: Plain text
#: man-pages/man2/setuid.2:105
msgid ""
"I<uid> does not match the real user ID of the caller and this call would "
"bring the number of processes belonging to the real user ID I<uid> over the "
"caller's B<RLIMIT_NPROC> resource limit.  Since Linux 3.1, this error case "
"no longer occurs (but robust applications should check for this error); see "
"the description of B<EAGAIN> in B<execve>(2)."
msgstr "Значение I<uid> не совпадает с реальным UID вызывающего и этот вызов создал был превышение количества процессов, принадлежащих пользователю с реальным ID I<ruid> сверх ограничителя ресурсы B<RLIMIT_NPROC> вызывающего. Начиная с Linux 3.1 эта ошибка больше не возникает (но корректное приложение должно проверять эту ошибку); смотрите описание B<EAGAIN> в B<execve>(2)."

#. type: Plain text
#: man-pages/man2/setuid.2:112
msgid ""
"The user is not privileged (Linux: does not have the B<CAP_SETUID> "
"capability) and I<uid> does not match the real UID or saved set-user-ID of "
"the calling process."
msgstr "Пользователь не является суперпользователем (Linux: нет мандата B<CAP_SETUID>), а I<uid> не совпадает с действительным или сохранённым идентификатором пользователя вызывающего процесса."

#.  SVr4 documents an additional EINVAL error condition.
#. type: Plain text
#: man-pages/man2/setuid.2:117
msgid ""
"SVr4, POSIX.1-2001.  Not quite compatible with the 4.4BSD call, which sets "
"all of the real, saved, and effective user IDs."
msgstr "SVr4, POSIX.1-2001. Этот системный вызов не полностью совместим с 4.4BSD, который устанавливает действительный, эффективный и сохранённый идентификаторы пользователя."

#. type: Plain text
#: man-pages/man2/setuid.2:125
msgid ""
"Linux has the concept of the filesystem user ID, normally equal to the "
"effective user ID.  The B<setuid>()  call also sets the filesystem user ID "
"of the calling process.  See B<setfsuid>(2)."
msgstr "Linux поддерживает идентификатор пользователя файловой системы, обычно совпадающий с эффективным идентификатором. Системный вызов B<setuid>() также устанавливает идентификатор пользователя файловой системы вызывающего процесса. См. B<setfsuid>(2)."

#. type: Plain text
#: man-pages/man2/setuid.2:130
msgid ""
"If I<uid> is different from the old effective UID, the process will be "
"forbidden from leaving core dumps."
msgstr "Если I<uid> отличается от старого эффективного идентификатора, то процессу нельзя будет создавать core-файлы."

#. type: Plain text
#: man-pages/man2/setuid.2:140
msgid ""
"The original Linux B<setuid>()  system call supported only 16-bit user IDs."
"  Subsequently, Linux 2.4 added B<setuid32>()  supporting 32-bit IDs.  The "
"glibc B<setuid>()  wrapper function transparently deals with the variation "
"across kernel versions."
msgstr "Первоначальная версия системного вызова B<setuid>() в Linux поддерживала только 16-битные идентификаторы пользователя. Позднее в Linux 2.4 был добавлен вызов B<setuid32>(), поддерживающий 32-битные идентификаторы. В glibc обёрточная функция B<setuid>() работает одинаково вне зависимости от версий ядра."

#. type: Plain text
#: man-pages/man2/setuid.2:146
msgid ""
"B<getuid>(2), B<seteuid>(2), B<setfsuid>(2), B<setreuid>(2), "
"B<capabilities>(7), B<credentials>(7)"
msgstr "B<getuid>(2), B<seteuid>(2), B<setfsuid>(2), B<setreuid>(2), B<capabilities>(7), B<credentials>(7)"

#. type: TH
#: man-pages/man2/semctl.2:41
#, no-wrap
msgid "SEMCTL"
msgstr "SEMCTL"

#. type: TH
#: man-pages/man2/semctl.2:41
#, no-wrap
msgid "2013-06-03"
msgstr "2013-06-03"

#. type: Plain text
#: man-pages/man2/semctl.2:44
msgid "semctl - System V semaphore control operations"
msgstr "semctl - операции управления семафорами System V"

#. type: Plain text
#: man-pages/man2/semctl.2:51
#, no-wrap
msgid "B<int semctl(int >I<semid>B<, int >I<semnum>B<, int >I<cmd>B<, ...);>\n"
msgstr "B<int semctl(int >I<semid>B<, int >I<semnum>B<, int >I<cmd>B<, ...);>\n"

#. type: Plain text
#: man-pages/man2/semctl.2:62
msgid ""
"B<semctl>()  performs the control operation specified by I<cmd> on the "
"System\\ V semaphore set identified by I<semid>, or on the I<semnum>-th "
"semaphore of that set.  (The semaphores in a set are numbered starting at "
"0.)"
msgstr "Вызов semctl выполняет операцию, определённую в I<cmd>, над набором семафоров System\\ V, указанном в I<semid>, или над семафором с номером I<semnum> из этого набора (семафоры нумеруются, начиная с 0)."

#. type: Plain text
#: man-pages/man2/semctl.2:68
msgid ""
"This function has three or four arguments, depending on I<cmd>.  When there "
"are four, the fourth has the type I<union semun>.  The I<calling program> "
"must define this union as follows:"
msgstr "Данный вызов имеет три или четыре аргумента, в зависимости от значения I<cmd>. Если аргументов четыре, то четвертый аргумент arg имеет тип I<union semun>. В I<вызывающей программе> это объединение должно быть определено следующим образом:"

#. type: Plain text
#: man-pages/man2/semctl.2:78
#, no-wrap
msgid ""
"union semun {\n"
"    int              val;    /* Value for SETVAL */\n"
"    struct semid_ds *buf;    /* Buffer for IPC_STAT, IPC_SET */\n"
"    unsigned short  *array;  /* Array for GETALL, SETALL */\n"
"    struct seminfo  *__buf;  /* Buffer for IPC_INFO\n"
"                                (Linux-specific) */\n"
"};\n"
msgstr "union semun {\n    int              val;    /* значение для SETVAL */\n    struct semid_ds *buf;    /* буфер для IPC_STAT, IPC_SET */\n    unsigned short  *array;  /* массив для GETALL, SETALL */\n    struct seminfo  *__buf;  /* буфер для IPC_INFO\n                                (есть только в Linux) */\n};\n"

#. type: Plain text
#: man-pages/man2/semctl.2:84
msgid ""
"The I<semid_ds> data structure is defined in I<E<lt>sys/sem.hE<gt>> as "
"follows:"
msgstr "Структура данных I<semid_ds> определена в I<E<lt>sys/sem.hE<gt>> следующим образом:"

#. type: Plain text
#: man-pages/man2/semctl.2:93
#, no-wrap
msgid ""
"struct semid_ds {\n"
"    struct ipc_perm sem_perm;  /* Ownership and permissions */\n"
"    time_t          sem_otime; /* Last semop time */\n"
"    time_t          sem_ctime; /* Last change time */\n"
"    unsigned long   sem_nsems; /* No. of semaphores in set */\n"
"};\n"
msgstr "struct semid_ds {\n    struct ipc_perm sem_perm;  /* владелец и права */\n    time_t          sem_otime; /* время последней операции semop */\n    time_t          sem_ctime; /* время последнего изменения */\n    unsigned long  sem_nsems; /* кол-во семафоров в наборе */\n};\n"

#. type: Plain text
#: man-pages/man2/semctl.2:113
#, no-wrap
msgid ""
"struct ipc_perm {\n"
"    key_t          __key; /* Key supplied to semget(2) */\n"
"    uid_t          B<uid>;   /* Effective UID of owner */\n"
"    gid_t          B<gid>;   /* Effective GID of owner */\n"
"    uid_t          cuid;  /* Effective UID of creator */\n"
"    gid_t          cgid;  /* Effective GID of creator */\n"
"    unsigned short B<mode>;  /* Permissions */\n"
"    unsigned short __seq; /* Sequence number */\n"
"};\n"
msgstr "struct ipc_perm {\n    key_t          __key; /* ключ, передаваемый в semget(2) */\n    uid_t          B<uid>;   /* эффективный UID владельца */\n    gid_t          B<gid>;   /* эффективный GID владельца */\n    uid_t          cuid;  /* эффективный UID создателя */\n    gid_t          cgid;  /* эффективный GID создателя */\n    unsigned short B<mode>;  /* права */\n    unsigned short __seq; /* порядковый номер */\n};\n"

#. type: Plain text
#: man-pages/man2/semctl.2:131
msgid ""
"Copy information from the kernel data structure associated with I<semid> "
"into the I<semid_ds> structure pointed to by I<arg.buf>.  The argument "
"I<semnum> is ignored.  The calling process must have read permission on the "
"semaphore set."
msgstr "Копирует информацию из структуры данных ядра, связанной с I<semid>, в структуру I<semid_ds>, расположенную по адресу I<arg.buf>. Аргумент I<semnum> игнорируется. Вызывающий процесс должен иметь права на чтение набора семафоров."

#. type: Plain text
#: man-pages/man2/semctl.2:154
msgid ""
"Write the values of some members of the I<semid_ds> structure pointed to by "
"I<arg.buf> to the kernel data structure associated with this semaphore set, "
"updating also its I<sem_ctime> member.  The following members of the "
"structure are updated: I<sem_perm.uid>, I<sem_perm.gid>, and (the least "
"significant 9 bits of)  I<sem_perm.mode>.  The effective UID of the calling "
"process must match the owner (I<sem_perm.uid>)  or creator "
"(I<sem_perm.cuid>)  of the semaphore set, or the caller must be privileged."
"  The argument I<semnum> is ignored."
msgstr "Записывает значения некоторых полей структуры I<semid_ds>, на которую указывает I<arg.buf>, в структуру данных ядра, связанную с этим набором семафоров, также обновляя при этом поле I<sem_ctime>. Обновляются следующие поля структуры: I<sem_perm.uid>, I<sem_perm.gid> и (младшие 9 значащих битов) I<sem_perm.mode>. Эффективный UID вызывающего процесса должен совпадать с идентификатором владельца (I<sem_perm.uid>) или создателя (I<sem_perm.cuid>) набора семафоров, или вызывающий должен иметь расширенные права. Аргумент I<semnum> игнорируется."

#. type: Plain text
#: man-pages/man2/semctl.2:169
msgid ""
"Immediately remove the semaphore set, awakening all processes blocked in "
"B<semop>(2)  calls on the set (with an error return and I<errno> set to "
"B<EIDRM>).  The effective user ID of the calling process must match the "
"creator or owner of the semaphore set, or the caller must be privileged.  "
"The argument I<semnum> is ignored."
msgstr "Немедленно удаляет набор семафоров, пробуждая все процессы, заблокированные в вызове B<semop>(2) (при этом возвращается сообщение об ошибке, а I<errno> присваивается значение B<EIDRM>). Эффективный идентификатор пользователя вызывающего процесса должен совпадать с идентификатором создателя или владельца набора семафоров, или вызывающий должен иметь расширенные права. Аргумент I<semnum> игнорируется."

#. type: Plain text
#: man-pages/man2/semctl.2:181
msgid ""
"Return information about system-wide semaphore limits and parameters in the "
"structure pointed to by I<arg.__buf>.  This structure is of type I<seminfo>,"
" defined in I<E<lt>sys/sem.hE<gt>> if the B<_GNU_SOURCE> feature test macro "
"is defined:"
msgstr "Возвращает параметры и информацию о системных ограничениях семафоров в структуре, указанной в I<arg.__buf>. Данная структура имеет тип I<seminfo>, который определён в I<E<lt>sys/sem.hE<gt>>, если определён макрос тестирования свойств B<_GNU_SOURCE>:"

#. type: Plain text
#: man-pages/man2/semctl.2:203
#, no-wrap
msgid ""
"struct  seminfo {\n"
"    int semmap;  /* Number of entries in semaphore\n"
"                    map; unused within kernel */\n"
"    int semmni;  /* Maximum number of semaphore sets */\n"
"    int semmns;  /* Maximum number of semaphores in all\n"
"                    semaphore sets */\n"
"    int semmnu;  /* System-wide maximum number of undo\n"
"                    structures; unused within kernel */\n"
"    int semmsl;  /* Maximum number of semaphores in a\n"
"                    set */\n"
"    int semopm;  /* Maximum number of operations for\n"
"                    semop(2) */\n"
"    int semume;  /* Maximum number of undo entries per\n"
"                    process; unused within kernel */\n"
"    int semusz;  /* Size of struct sem_undo */\n"
"    int semvmx;  /* Maximum semaphore value */\n"
"    int semaem;  /* Max. value that can be recorded for\n"
"                    semaphore adjustment (SEM_UNDO) */\n"
"};\n"
msgstr "struct  seminfo {\n    int semmap;  /* количество записей в карте\n                    семафоров; не используется в ядре */\n    int semmni;  /* максимальное количество наборов\n                    семафоров */\n    int semmns;  /* максимальное количество семафоров во\n                     всех наборах семафоров */\n    int semmnu;  /* максимальное количество структур undo\n                    в системе; не используется в ядре */\n    int semmsl;  /* максимальное количество семафоров в\n                    наборе */\n    int semopm;  /* максимальное количество операция для\n                    semop(2) */\n    int semume;  /* максимальное количество записей undo на\n                    процесс; не используется в ядре */\n    int semusz;  /* размер struct sem_undo */\n    int semvmx;  /* максимальное значение семафора */\n    int semaem;  /* максимальное значение, которое может\n                    быть записано для регулирования\n                    семафора (SEM_UNDO) */\n};\n"

#. type: Plain text
#: man-pages/man2/semctl.2:217
msgid ""
"The I<semmsl>, I<semmns>, I<semopm>, and I<semmni> settings can be changed "
"via I</proc/sys/kernel/sem>; see B<proc>(5)  for details."
msgstr "Значения I<semmsl>, I<semmns>, I<semopm> и I<semmni> можно изменить через I</proc/sys/kernel/sem>; подробности в B<proc>(5)."

#. type: TP
#: man-pages/man2/semctl.2:217
#, no-wrap
msgid "B<SEM_INFO> (Linux-specific)"
msgstr "B<SEM_INFO> (есть только в Linux)"

#. type: Plain text
#: man-pages/man2/semctl.2:231
msgid ""
"Return a I<seminfo> structure containing the same information as for "
"B<IPC_INFO>, except that the following fields are returned with information "
"about system resources consumed by semaphores: the I<semusz> field returns "
"the number of semaphore sets that currently exist on the system; and the "
"I<semaem> field returns the total number of semaphores in all semaphore sets"
" on the system."
msgstr "Возвращает структуру I<seminfo>, содержащую такую же информацию что и для B<IPC_INFO>, за исключением того, что следующие поля содержат информацию о системных ресурсах, потребляемых семафорами: в поле I<semusz> возвращается количество наборов семафоров, существующих в системе; в поле I<semaem> возвращается общее количество семафоров во всех наборах семафоров в системе."

#. type: TP
#: man-pages/man2/semctl.2:231
#, no-wrap
msgid "B<SEM_STAT> (Linux-specific)"
msgstr "B<SEM_STAT> (есть только в Linux)"

#. type: Plain text
#: man-pages/man2/semctl.2:242
msgid ""
"Return a I<semid_ds> structure as for B<IPC_STAT>.  However, the I<semid> "
"argument is not a semaphore identifier, but instead an index into the "
"kernel's internal array that maintains information about all semaphore sets "
"on the system."
msgstr "Возвращает структуру I<semid_ds> как для B<IPC_STAT>. Однако аргумент I<semid> содержит не идентификатор семафора, а индекс во внутреннем массиве ядра, который хранит информацию о всех наборах семафоров в системе."

#. type: TP
#: man-pages/man2/semctl.2:242
#, no-wrap
msgid "B<GETALL>"
msgstr "B<GETALL>"

#. type: Plain text
#: man-pages/man2/semctl.2:253
msgid ""
"Return B<semval> (i.e., the current value)  for all semaphores of the set "
"into I<arg.array>.  The argument I<semnum> is ignored.  The calling process "
"must have read permission on the semaphore set."
msgstr "Возвращает значение B<semval> (т.е. текущее значение) всех семафоров в наборе в I<arg.array>. Аргумент I<semnum> игнорируется. Вызывающему процессу нужны права на чтение набора семафоров."

#. type: TP
#: man-pages/man2/semctl.2:253 man-pages/man2/semctl.2:351
#, no-wrap
msgid "B<GETNCNT>"
msgstr "B<GETNCNT>"

#. type: Plain text
#: man-pages/man2/semctl.2:266
msgid ""
"Return the value of B<semncnt> for the I<semnum>-th semaphore of the set "
"(i.e., the number of processes waiting for an increase of B<semval> for the "
"I<semnum>-th semaphore of the set).  The calling process must have read "
"permission on the semaphore set."
msgstr "Возвращает значение B<semncnt> для I<semnum>-того семафора (т.е., число процессов, ожидающих увеличения значения B<semval> в I<semnum>-ом семафоре набора). Вызывающему процессу нужны права на чтение набора семафоров."

#. type: TP
#: man-pages/man2/semctl.2:266 man-pages/man2/semctl.2:355
#, no-wrap
msgid "B<GETPID>"
msgstr "B<GETPID>"

#. type: Plain text
#: man-pages/man2/semctl.2:279
msgid ""
"Return the value of B<sempid> for the I<semnum>-th semaphore of the set "
"(i.e., the PID of the process that executed the last B<semop>(2)  call for "
"the I<semnum>-th semaphore of the set).  The calling process must have read "
"permission on the semaphore set."
msgstr "Возвращает значение B<sempid> для I<semnum>-того семафора (т.е., идентификатор процесса, который последним делал вызов B<semop>(2) для I<semnum>-того семафора набора). Вызывающему процессу нужны права на чтение набора семафоров."

#. type: TP
#: man-pages/man2/semctl.2:279 man-pages/man2/semctl.2:359
#, no-wrap
msgid "B<GETVAL>"
msgstr "B<GETVAL>"

#. type: Plain text
#: man-pages/man2/semctl.2:287
msgid ""
"Return the value of B<semval> for the I<semnum>-th semaphore of the set.  "
"The calling process must have read permission on the semaphore set."
msgstr "Возвращает значение B<semval> для I<semnum>-того семафора набора. Вызывающему процессу нужны права на чтение набора семафоров."

#. type: TP
#: man-pages/man2/semctl.2:287 man-pages/man2/semctl.2:363
#, no-wrap
msgid "B<GETZCNT>"
msgstr "B<GETZCNT>"

#. type: Plain text
#: man-pages/man2/semctl.2:300
msgid ""
"Return the value of B<semzcnt> for the I<semnum>-th semaphore of the set "
"(i.e., the number of processes waiting for B<semval> of the I<semnum>-th "
"semaphore of the set to become 0).  The calling process must have read "
"permission on the semaphore set."
msgstr "Возвращает значение B<semzcnt> для I<semnum>-того семафора (т.е., количество процессов, ожидающих, когда значение B<semval> I<semnum>-того семафора набора станет равным 0). Вызывающему процессу нужны права на чтение набора семафоров."

#. type: TP
#: man-pages/man2/semctl.2:300
#, no-wrap
msgid "B<SETALL>"
msgstr "B<SETALL>"

#. type: Plain text
#: man-pages/man2/semctl.2:322
msgid ""
"Set B<semval> for all semaphores of the set using I<arg.array>, updating "
"also the I<sem_ctime> member of the I<semid_ds> structure associated with "
"the set.  Undo entries (see B<semop>(2))  are cleared for altered semaphores"
" in all processes.  If the changes to semaphore values would permit blocked "
"B<semop>(2)  calls in other processes to proceed, then those processes are "
"woken up.  The argument I<semnum> is ignored.  The calling process must have"
" alter (write) permission on the semaphore set."
msgstr "Устанавливает значение B<semval> всех семафоров набора, используя I<arg.array> и изменяя также поле I<sem_ctime> структуры I<semid_ds>, связанной с набором. Записи undo (см. B<semop>(2)) очищаются для изменённых семафоров во всех процессах. Если изменения значений семафоров приводят к отмене блокировки в вызове B<semop>(2) других процессов, то эти процессы пробуждаются. Аргумент I<semnum> игнорируется. Вызывающему процессу нужны права на запись в набор семафоров."

#. type: TP
#: man-pages/man2/semctl.2:322
#, no-wrap
msgid "B<SETVAL>"
msgstr "B<SETVAL>"

#. type: Plain text
#: man-pages/man2/semctl.2:340
msgid ""
"Set the value of B<semval> to I<arg.val> for the I<semnum>-th semaphore of "
"the set, updating also the I<sem_ctime> member of the I<semid_ds> structure "
"associated with the set.  Undo entries are cleared for altered semaphores in"
" all processes.  If the changes to semaphore values would permit blocked "
"B<semop>(2)  calls in other processes to proceed, then those processes are "
"woken up.  The calling process must have alter permission on the semaphore "
"set."
msgstr "Устанавливает значение B<semval> равным I<arg.val> для I<semnum>-го семафора набора, изменяя также поле I<sem_ctime> в структуре I<semid_ds>, связанной с этим набором. Записи undo очищаются для изменённых семафоров во всех процессах. Если изменения значений семафоров приводят к отмене блокировки в вызове B<semop>(2) других процессов, то эти процессы пробуждаются. Аргумент I<semnum> игнорируется. Вызывающему процессу нужны права на запись в набор семафоров."

#. type: Plain text
#: man-pages/man2/semctl.2:347
msgid ""
"On failure, B<semctl>()  returns -1 with I<errno> indicating the error."
msgstr "При ошибке B<semctl>() возвращает -1, а переменной I<errno> присваивается номер ошибки."

#. type: Plain text
#: man-pages/man2/semctl.2:351
msgid ""
"Otherwise, the system call returns a nonnegative value depending on I<cmd> "
"as follows:"
msgstr "При успешном выполнении системный вызов возвращает положительное значение, зависящее от I<cmd>:"

#. type: Plain text
#: man-pages/man2/semctl.2:355
msgid "the value of B<semncnt>."
msgstr "значение B<semncnt>."

#. type: Plain text
#: man-pages/man2/semctl.2:359
msgid "the value of B<sempid>."
msgstr "значение B<sempid>."

#. type: Plain text
#: man-pages/man2/semctl.2:363
msgid "the value of B<semval>."
msgstr "значение B<semval>."

#. type: Plain text
#: man-pages/man2/semctl.2:367
msgid "the value of B<semzcnt>."
msgstr "значение B<semzcnt>."

#. type: TP
#: man-pages/man2/semctl.2:367
#, no-wrap
msgid "B<IPC_INFO>"
msgstr "B<IPC_INFO>"

#. type: Plain text
#: man-pages/man2/semctl.2:375
msgid ""
"the index of the highest used entry in the kernel's internal array recording"
" information about all semaphore sets.  (This information can be used with "
"repeated B<SEM_STAT> operations to obtain information about all semaphore "
"sets on the system.)"
msgstr "самое большое значение индекса, использованного в записи внутреннего массива ядра, содержащего информацию о всех наборах семафоров (эта информация может использоваться в повторяющихся операциях B<SEM_STAT> для получения информации о всех наборах семафоров в системе)."

#. type: TP
#: man-pages/man2/semctl.2:375
#, no-wrap
msgid "B<SEM_INFO>"
msgstr "B<SEM_INFO>"

#. type: Plain text
#: man-pages/man2/semctl.2:379
msgid "as for B<IPC_INFO>."
msgstr "как для B<IPC_INFO>."

#. type: TP
#: man-pages/man2/semctl.2:379
#, no-wrap
msgid "B<SEM_STAT>"
msgstr "B<SEM_STAT>"

#. type: Plain text
#: man-pages/man2/semctl.2:383
msgid "the identifier of the semaphore set whose index was given in I<semid>."
msgstr "идентификатор набора семафоров, индекс которого указан в I<semid>."

#. type: Plain text
#: man-pages/man2/semctl.2:387
msgid "All other I<cmd> values return 0 on success."
msgstr "Для всех остальных значений I<cmd> возвращается 0."

#. type: Plain text
#: man-pages/man2/semctl.2:410
msgid ""
"The argument I<cmd> has one of the values B<GETALL>, B<GETPID>, B<GETVAL>, "
"B<GETNCNT>, B<GETZCNT>, B<IPC_STAT>, B<SEM_STAT>, B<SETALL>, or B<SETVAL> "
"and the calling process does not have the required permissions on the "
"semaphore set and does not have the B<CAP_IPC_OWNER> capability."
msgstr "Аргумент I<cmd> равен B<GETALL>, B<GETPID>, B<GETVAL>, B<GETNCNT>, B<GETZCNT>, B<IPC_STAT>, B<SEM_STAT>, B<SETALL> или B<SETVAL> и вызывающий процесс не имеет достаточно прав на набор семафоров и не имеет мандата B<CAP_IPC_OWNER>."

#. type: Plain text
#: man-pages/man2/semctl.2:417
msgid "The address pointed to by I<arg.buf> or I<arg.array> isn't accessible."
msgstr "Адрес, указанный в I<arg.buf> или I<arg.array>, недоступен."

#. type: Plain text
#: man-pages/man2/semctl.2:420
msgid "The semaphore set was removed."
msgstr "Набор семафоров был удалён."

#. type: Plain text
#: man-pages/man2/semctl.2:431
msgid ""
"Invalid value for I<cmd> or I<semid>.  Or: for a B<SEM_STAT> operation, the "
"index value specified in I<semid> referred to an array slot that is "
"currently unused."
msgstr "Неверное значение I<cmd> или I<semid>. Или: при операции B<SEM_STAT> значение индекса, указанное в I<semid>, ссылается на место в массиве, которое в данные момент не используется."

#. type: Plain text
#: man-pages/man2/semctl.2:449
msgid ""
"The argument I<cmd> has the value B<IPC_SET> or B<IPC_RMID> but the "
"effective user ID of the calling process is not the creator (as found in "
"I<sem_perm.cuid>)  or the owner (as found in I<sem_perm.uid>)  of the "
"semaphore set, and the process does not have the B<CAP_SYS_ADMIN> "
"capability."
msgstr "Аргумент I<cmd> имеет значение B<IPC_SET> или B<IPC_RMID>, но эффективный идентификатор пользователя вызывающего процесса не совпадает с ID создателя (указанного в I<sem_perm.cuid>) или с ID владельца (указанного в I<sem_perm.uid>) набора семафоров, и процесс не имеет мандата B<CAP_SYS_ADMIN>."

#. type: TP
#: man-pages/man2/semctl.2:449
#, no-wrap
msgid "B<ERANGE>"
msgstr "B<ERANGE>"

#. type: Plain text
#: man-pages/man2/semctl.2:462
msgid ""
"The argument I<cmd> has the value B<SETALL> or B<SETVAL> and the value to "
"which B<semval> is to be set (for some semaphore of the set) is less than 0 "
"or greater than the implementation limit B<SEMVMX>."
msgstr "Аргумент I<cmd> имеет значение B<SETALL> или B<SETVAL> и значение, присваиваемое B<semval> (для какого-то семафора в наборе), меньше нуля или больше, чем ограничение реализации B<SEMVMX>."

#. type: Plain text
#: man-pages/man2/semctl.2:476
msgid ""
"POSIX.1-2001 specifies the I<sem_nsems> field of the I<semid_ds> structure "
"as having the type I<unsigned\\ short>, and the field is so defined on most "
"other systems.  It was also so defined on Linux 2.2 and earlier, but, since "
"Linux 2.4, the field has the type I<unsigned\\ long>."
msgstr "В POSIX.1-2001 указано, что поле I<sem_nsems> структуры I<semid_ds> имеет тип I<unsigned\\ short>, и это так на в большинстве других систем. Это было и в Linux 2.2 и более ранних версиях, но начиная с Linux 2.4 это поле имеет тип I<unsigned\\ long>."

#. type: Plain text
#: man-pages/man2/semctl.2:501
msgid ""
"The B<IPC_INFO>, B<SEM_STAT> and B<SEM_INFO> operations are used by the "
"B<ipcs>(1)  program to provide information on allocated resources.  In the "
"future these may modified or moved to a I</proc> filesystem interface."
msgstr "Операции B<IPC_INFO>, B<SEM_STAT> и B<SEM_INFO> используются программой B<ipcs>(1) для получения информации о выделенных ресурсах. В будущем для этого может быть задействован интерфейс файловой системы I</proc>."

#. type: Plain text
#: man-pages/man2/semctl.2:514
msgid ""
"Various fields in a I<struct semid_ds> were typed as I<short> under Linux "
"2.2 and have become I<long> under Linux 2.4.  To take advantage of this, a "
"recompilation under glibc-2.1.91 or later should suffice.  (The kernel "
"distinguishes old and new calls by an B<IPC_64> flag in I<cmd>.)"
msgstr "В Linux 2.2 различные поля I<struct semid_ds> имели тип I<short>. В Linux 2.4 тип был изменён на I<long>. Для задействования преимуществ этого изменения необходима перекомпиляция программы с glibc-2.1.91 или более поздней версией (ядро различает старые и новые вызовы по флагу B<IPC_64> в аргументе I<cmd>)."

#. type: Plain text
#: man-pages/man2/semctl.2:523
msgid ""
"In some earlier versions of glibc, the I<semun> union was defined in "
"I<E<lt>sys/sem.hE<gt>>, but POSIX.1-2001 requires that the caller define "
"this union.  On versions of glibc where this union is I<not> defined, the "
"macro B<_SEM_SEMUN_UNDEFINED> is defined in I<E<lt>sys/sem.hE<gt>>."
msgstr "В некоторых ранних версиях glibc объединение I<semun> определялось в I<E<lt>sys/sem.hE<gt>>, но в POSIX.1-2001 требовалось, чтобы это объединение определял вызывающий. В версиях glibc, в которых это объединение I<не> определено, в I<E<lt>sys/sem.hE<gt>> определён макрос B<_SEM_SEMUN_UNDEFINED>."

#. type: Plain text
#: man-pages/man2/semctl.2:527
msgid ""
"The following system limit on semaphore sets affects a B<semctl>()  call:"
msgstr "На работу наборов семафоров и вызова B<semctl>() влияет системное ограничение:"

#. type: TP
#: man-pages/man2/semctl.2:527
#, no-wrap
msgid "B<SEMVMX>"
msgstr "B<SEMVMX>"

#. type: Plain text
#: man-pages/man2/semctl.2:532
msgid "Maximum value for B<semval>: implementation dependent (32767)."
msgstr "Максимальное значение B<semval>: зависит от реализации (32767)."

#. type: Plain text
#: man-pages/man2/semctl.2:536
msgid ""
"For greater portability, it is best to always call B<semctl>()  with four "
"arguments."
msgstr "Для лучшей переносимости программ желательно всегда вызывать B<semctl>() c четырьмя аргументам."

#. type: Plain text
#: man-pages/man2/semctl.2:542
msgid ""
"B<ipc>(2), B<semget>(2), B<semop>(2), B<capabilities>(7), "
"B<sem_overview>(7), B<svipc>(7)"
msgstr "B<ipc>(2), B<semget>(2), B<semop>(2), B<capabilities>(7), B<sem_overview>(7), B<svipc>(7)"

#. type: TH
#: man-pages/man2/seteuid.2:29
#, no-wrap
msgid "SETEUID"
msgstr "SETEUID"

#. type: Plain text
#: man-pages/man2/seteuid.2:32
msgid "seteuid, setegid - set effective user or group ID"
msgstr "seteuid, setegid - устанавливает эффективный идентификатор пользователя или группы"

#. type: Plain text
#: man-pages/man2/seteuid.2:38
msgid "B<int seteuid(uid_t >I<euid>B<);>"
msgstr "B<int seteuid(uid_t >I<euid>B<);>"

#. type: Plain text
#: man-pages/man2/seteuid.2:40
msgid "B<int setegid(gid_t >I<egid>B<);>"
msgstr "B<int setegid(gid_t >I<egid>B<);>"

#. type: Plain text
#: man-pages/man2/seteuid.2:49
msgid "B<seteuid>(), B<setegid>():"
msgstr "B<seteuid>(), B<setegid>():"

#. type: Plain text
#: man-pages/man2/seteuid.2:51
msgid ""
"_BSD_SOURCE || _POSIX_C_SOURCE\\ E<gt>=\\ 200112L || _XOPEN_SOURCE\\ "
"E<gt>=\\ 600"
msgstr "_BSD_SOURCE || _POSIX_C_SOURCE\\ E<gt>=\\ 200112L || _XOPEN_SOURCE\\ E<gt>=\\ 600"

#. type: Plain text
#: man-pages/man2/seteuid.2:58
msgid ""
"B<seteuid>()  sets the effective user ID of the calling process.  "
"Unprivileged user processes may only set the effective user ID to the real "
"user ID, the effective user ID or the saved set-user-ID."
msgstr "B<seteuid>() устанавливает эффективный идентификатор пользователя вызывающего процесса. Непривилегированные пользовательские процессы могут менять эффективный идентификатор пользователя только на действительный, эффективный или сохранённый идентификатор пользователя."

#.  When
#.  .I euid
#.  equals \-1, nothing is changed.
#.  (This is an artifact of the implementation in glibc of seteuid()
#.  using setresuid(2).)
#. type: Plain text
#: man-pages/man2/seteuid.2:67
msgid "Precisely the same holds for B<setegid>()  with \"group\" instead of \"user\"."
msgstr "Тоже самое справедливо при работе B<setegid>() с \"групповым\" идентификатором, а не \"пользовательским\"."

#. type: Plain text
#: man-pages/man2/seteuid.2:79
msgid ""
"I<Note>: there are cases where B<seteuid>()  can fail even when the caller "
"is UID 0; it is a grave security error to omit checking for a failure return"
" from B<seteuid>()."
msgstr ""

#. type: Plain text
#: man-pages/man2/seteuid.2:98
msgid ""
"The calling process is not privileged (Linux: does not have the "
"B<CAP_SETUID> capability in the case of B<seteuid>(), or the B<CAP_SETGID> "
"capability in the case of B<setegid>())  and I<euid> (respectively, I<egid>)"
"  is not the real user (group) ID, the effective user (group) ID, or the "
"saved set-user-ID (saved set-group-ID)."
msgstr "Вызывающий процесс не имеет прав (Linux: не имеет мандата B<CAP_SETUID>, если вызывает B<seteuid>(), или B<CAP_SETGID>, если вызывает B<setegid>()) и I<euid> (и, соответственно, I<egid>) не является действительным, эффективным или сохранённым идентификатором пользователя (группы)."

#. type: Plain text
#: man-pages/man2/seteuid.2:100
msgid "4.3BSD, POSIX.1-2001."
msgstr "4.3BSD, POSIX.1-2001."

#. type: Plain text
#: man-pages/man2/seteuid.2:106
msgid ""
"Setting the effective user (group) ID to the saved set-user-ID (saved set-"
"group-ID) is possible since Linux 1.1.37 (1.1.38).  On an arbitrary system "
"one should check B<_POSIX_SAVED_IDS>."
msgstr "Установка эффективного идентификатора пользователя (группы) в сохранённый идентификатор пользователя (группы) возможна с версии Linux 1.1.37 (1.1.38). В других системах надо проверять B<_POSIX_SAVED_IDS>."

#. type: Plain text
#: man-pages/man2/seteuid.2:122
msgid ""
"Under libc4, libc5 and glibc 2.0 B<seteuid(>I<euid>B<)> is equivalent to "
"B<setreuid(-1,>I< euid>B<)> and hence may change the saved set-user-ID.  "
"Under glibc 2.1 and later it is equivalent to B<setresuid(-1,>I< euid>B<, "
"-1)> and hence does not change the saved set-user-ID.  Analogous remarks "
"hold for B<setegid>(), with the difference that the change in implementation"
" from B<setregid(-1,>I< egid>B<)> to B<setresgid(-1,>I< egid>B<, -1)> "
"occurred in glibc 2.2 or 2.3 (depending on the hardware architecture)."
msgstr "В libc4, libc5 и glibc 2.0 вызов B<seteuid(>I<euid>B<)>эквивалентен B<setreuid(-1,>I< euid>B<)>, и поэтому может изменить сохранённый идентификатор пользователя. В glibc 2.1 и новее он эквивалентен B<setresuid(-1,>I< euid>B<, -1)> и поэтому не изменяет сохранённый идентификатор пользователя. Аналогичные замечания относятся и к B<setegid>(), с той разницей, что изменение в реализации из B<setregid(-1,>I< egid>B<)> в B<setresgid(-1,>I< egid>B<, -1)> произошло в glibc 2.2 или 2.3 (зависит от аппаратной архитектуры)."

#. type: Plain text
#: man-pages/man2/seteuid.2:131
msgid ""
"According to POSIX.1, B<seteuid>()  (B<setegid>())  need not permit I<euid> "
"(I<egid>)  to be the same value as the current effective user (group) ID, "
"and some implementations do not permit this."
msgstr "Согласно POSIX.1, B<seteuid>() (B<setegid>()) необходимо запрещать I<euid> (I<egid>) равный текущему эффективному идентификатору пользователя (группе), и некоторые реализации не позволяют этого."

#. type: Plain text
#: man-pages/man2/seteuid.2:140
msgid ""
"On Linux, B<seteuid>()  and B<setegid>()  are implemented as library "
"functions that call, respectively, B<setreuid>(2)  and B<setresgid>(2)."
msgstr "В Linux, B<seteuid>() и B<setegid>() реализованы в виде библиотечных функций, которые вызывают B<setreuid>(2) и B<setresgid>(2), соответственно."

#. type: Plain text
#: man-pages/man2/seteuid.2:146
msgid ""
"B<geteuid>(2), B<setresuid>(2), B<setreuid>(2), B<setuid>(2), "
"B<capabilities>(7), B<credentials>(7)"
msgstr "B<geteuid>(2), B<setresuid>(2), B<setreuid>(2), B<setuid>(2), B<capabilities>(7), B<credentials>(7)"

#. type: TH
#: man-pages/man2/socket.2:43
#, no-wrap
msgid "2013-12-31"
msgstr "2013-12-31"

#. type: Plain text
#: man-pages/man2/socket.2:46
msgid "socket - create an endpoint for communication"
msgstr "socket - создаёт конечную точку соединения"

#. type: Plain text
#: man-pages/man2/socket.2:48
msgid "B<#include E<lt>sys/types.hE<gt>> /* See NOTES */"
msgstr "B<#include E<lt>sys/types.hE<gt>> /* смотрите ЗАМЕЧАНИЯ */"

#. type: Plain text
#: man-pages/man2/socket.2:52
msgid "B<int socket(int >I<domain>B<, int >I<type>B<, int >I<protocol>B<);>"
msgstr "B<int socket(int >I<domain>B<, int >I<type>B<, int >I<protocol>B<);>"

#. type: Plain text
#: man-pages/man2/socket.2:55
msgid ""
"B<socket>()  creates an endpoint for communication and returns a descriptor."
msgstr "B<socket>() создаёт конечную точку соединения и возвращает её дескриптор."

#. type: Plain text
#: man-pages/man2/socket.2:63
msgid ""
"The I<domain> argument specifies a communication domain; this selects the "
"protocol family which will be used for communication.  These families are "
"defined in I<E<lt>sys/socket.hE<gt>>.  The currently understood formats "
"include:"
msgstr "Параметр I<domain> задает домен соединения: выбирает семейство протоколов, которое будет использоваться для создания соединения. Семейства описаны в I<E<lt>sys/socket.hE<gt>>. В настоящее время распознаются такие форматы:"

#. type: tbl table
#: man-pages/man2/socket.2:66
#, no-wrap
msgid "Name:Purpose:Man page\n"
msgstr "Название:Назначение:Справочная страница\n"

#. type: tbl table
#: man-pages/man2/socket.2:67 man-pages/man2/socket.2:74
#: man-pages/man2/socket.2:79 man-pages/man2/socket.2:84
#: man-pages/man2/socket.2:87 man-pages/man2/socket.2:94
#: man-pages/man2/socket.2:99 man-pages/man2/socket.2:104
#: man-pages/man2/socket.2:107 man-pages/man2/socket.2:112
#, no-wrap
msgid "T{\n"
msgstr "T{\n"

#. type: tbl table
#: man-pages/man2/socket.2:68
#, no-wrap
msgid "B<AF_UNIX>, B<AF_LOCAL>\n"
msgstr "B<AF_UNIX>, B<AF_LOCAL>\n"

#. type: tbl table
#: man-pages/man2/socket.2:70
#, no-wrap
msgid "Local communication\n"
msgstr "Локальное соединение\n"

#. type: tbl table
#: man-pages/man2/socket.2:72
#, no-wrap
msgid "B<unix>(7)\n"
msgstr "B<unix>(7)\n"

#. type: tbl table
#: man-pages/man2/socket.2:75
#, no-wrap
msgid "B<AF_INET>\n"
msgstr "B<AF_INET>\n"

#. type: tbl table
#: man-pages/man2/socket.2:76
#, no-wrap
msgid "T}:IPv4 Internet protocols:T{\n"
msgstr "T}:Протоколы Интернет IPv4:T{\n"

#. type: tbl table
#: man-pages/man2/socket.2:77
#, no-wrap
msgid "B<ip>(7)\n"
msgstr "B<ip>(7)\n"

#. type: tbl table
#: man-pages/man2/socket.2:80
#, no-wrap
msgid "B<AF_INET6>\n"
msgstr "B<AF_INET6>\n"

#. type: tbl table
#: man-pages/man2/socket.2:81
#, no-wrap
msgid "T}:IPv6 Internet protocols:T{\n"
msgstr "T}:Протоколы Интернет IPv6:T{\n"

#. type: tbl table
#: man-pages/man2/socket.2:82
#, no-wrap
msgid "B<ipv6>(7)\n"
msgstr "B<ipv6>(7)\n"

#. type: tbl table
#: man-pages/man2/socket.2:85
#, no-wrap
msgid "B<AF_IPX>\n"
msgstr "B<AF_IPX>\n"

#. type: tbl table
#: man-pages/man2/socket.2:86
#, no-wrap
msgid "T}:IPX - Novell protocols:\n"
msgstr "T}:Протоколы Novell IPX:\n"

#. type: tbl table
#: man-pages/man2/socket.2:88
#, no-wrap
msgid "B<AF_NETLINK>\n"
msgstr "B<AF_NETLINK>\n"

#. type: tbl table
#: man-pages/man2/socket.2:90
#, no-wrap
msgid "Kernel user interface device\n"
msgstr "Устройство для взаимодействия с ядром\n"

#. type: tbl table
#: man-pages/man2/socket.2:92
#, no-wrap
msgid "B<netlink>(7)\n"
msgstr "B<netlink>(7)\n"

#. type: tbl table
#: man-pages/man2/socket.2:95
#, no-wrap
msgid "B<AF_X25>\n"
msgstr "B<AF_X25>\n"

#. type: tbl table
#: man-pages/man2/socket.2:96
#, no-wrap
msgid "T}:ITU-T X.25 / ISO-8208 protocol:T{\n"
msgstr "T}:Протокол ITU-T X.25/ISO-8208:T{\n"

#. type: tbl table
#: man-pages/man2/socket.2:97
#, no-wrap
msgid "B<x25>(7)\n"
msgstr "B<x25>(7)\n"

#. type: tbl table
#: man-pages/man2/socket.2:100
#, no-wrap
msgid "B<AF_AX25>\n"
msgstr "B<AF_AX25>\n"

#. type: tbl table
#: man-pages/man2/socket.2:102
#, no-wrap
msgid "Amateur radio AX.25 protocol\n"
msgstr "Протокол любительского радио AX.25\n"

#. type: tbl table
#: man-pages/man2/socket.2:103
#, no-wrap
msgid "T}:\n"
msgstr "T}:\n"

#. type: tbl table
#: man-pages/man2/socket.2:105
#, no-wrap
msgid "B<AF_ATMPVC>\n"
msgstr "B<AF_ATMPVC>\n"

#. type: tbl table
#: man-pages/man2/socket.2:106
#, no-wrap
msgid "T}:Access to raw ATM PVCs:\n"
msgstr "T}:Доступ к низкоуровневым PVC в ATM:\n"

#. type: tbl table
#: man-pages/man2/socket.2:108
#, no-wrap
msgid "B<AF_APPLETALK>\n"
msgstr "B<AF_APPLETALK>\n"

#. type: tbl table
#: man-pages/man2/socket.2:109
#, no-wrap
msgid "T}:AppleTalk:T{\n"
msgstr "T}:AppleTalk:T{\n"

#. type: tbl table
#: man-pages/man2/socket.2:110
#, no-wrap
msgid "B<ddp>(7)\n"
msgstr "B<ddp>(7)\n"

#. type: tbl table
#: man-pages/man2/socket.2:113
#, no-wrap
msgid "B<AF_PACKET>\n"
msgstr "B<AF_PACKET>\n"

#. type: tbl table
#: man-pages/man2/socket.2:115
#, no-wrap
msgid "Low level packet interface\n"
msgstr "Низкоуровневый пакетный интерфейс\n"

#. type: tbl table
#: man-pages/man2/socket.2:117
#, no-wrap
msgid "B<packet>(7)\n"
msgstr "B<packet>(7)\n"

#. type: Plain text
#: man-pages/man2/socket.2:126
msgid ""
"The socket has the indicated I<type>, which specifies the communication "
"semantics.  Currently defined types are:"
msgstr "Сокет имеет тип I<type>, задающий семантику соединения. В настоящее время определены следующие типы:"

#. type: TP
#: man-pages/man2/socket.2:126
#, no-wrap
msgid "B<SOCK_STREAM>"
msgstr "B<SOCK_STREAM>"

#. type: Plain text
#: man-pages/man2/socket.2:130
msgid ""
"Provides sequenced, reliable, two-way, connection-based byte streams.  An "
"out-of-band data transmission mechanism may be supported."
msgstr "Обеспечивает создание двусторонних, надёжных потоков байтов на основе установления соединения. Может также поддерживаться механизм внепоточных данных."

#. type: TP
#: man-pages/man2/socket.2:130
#, no-wrap
msgid "B<SOCK_DGRAM>"
msgstr "B<SOCK_DGRAM>"

#. type: Plain text
#: man-pages/man2/socket.2:134
msgid ""
"Supports datagrams (connectionless, unreliable messages of a fixed maximum "
"length)."
msgstr "Поддерживает дейтаграммы (ненадежные сообщения с ограниченной длиной без установки соединения)."

#. type: TP
#: man-pages/man2/socket.2:134
#, no-wrap
msgid "B<SOCK_SEQPACKET>"
msgstr "B<SOCK_SEQPACKET>"

#. type: Plain text
#: man-pages/man2/socket.2:139
msgid ""
"Provides a sequenced, reliable, two-way connection-based data transmission "
"path for datagrams of fixed maximum length; a consumer is required to read "
"an entire packet with each input system call."
msgstr "Обеспечивает работу последовательного двустороннего канала для передачи дейтаграмм на основе соединений; дейтаграммы имеют постоянный размер; от получателя требуется за один раз прочитать целый пакет."

#. type: TP
#: man-pages/man2/socket.2:139
#, no-wrap
msgid "B<SOCK_RAW>"
msgstr "B<SOCK_RAW>"

#. type: Plain text
#: man-pages/man2/socket.2:142
msgid "Provides raw network protocol access."
msgstr "Обеспечивает прямой доступ к сетевому протоколу."

#. type: TP
#: man-pages/man2/socket.2:142
#, no-wrap
msgid "B<SOCK_RDM>"
msgstr "B<SOCK_RDM>"

#. type: Plain text
#: man-pages/man2/socket.2:145
msgid "Provides a reliable datagram layer that does not guarantee ordering."
msgstr "Обеспечивает надежную доставку дейтаграмм без гарантии, что они будут расположены по порядку."

#. type: TP
#: man-pages/man2/socket.2:145
#, no-wrap
msgid "B<SOCK_PACKET>"
msgstr "B<SOCK_PACKET>"

#. type: Plain text
#: man-pages/man2/socket.2:150
msgid "Obsolete and should not be used in new programs; see B<packet>(7)."
msgstr "Устарел и не должен использоваться в новых программах; см. B<packet>(7)."

#. type: Plain text
#: man-pages/man2/socket.2:152
msgid "Some socket types may not be implemented by all protocol families."
msgstr "Некоторые типы сокетов могут быть не реализованы во всех семействах протоколов."

#. type: Plain text
#: man-pages/man2/socket.2:160
msgid ""
"Since Linux 2.6.27, the I<type> argument serves a second purpose: in "
"addition to specifying a socket type, it may include the bitwise OR of any "
"of the following values, to modify the behavior of B<socket>():"
msgstr "Начиная с Linux 2.6.27, аргумент I<type> предназначается для двух вещей: кроме определения типа сокета, для изменения поведения B<socket>() он может содержать побитово сложенные любые следующие значения:"

#. type: TP
#: man-pages/man2/socket.2:160
#, no-wrap
msgid "B<SOCK_NONBLOCK>"
msgstr "B<SOCK_NONBLOCK>"

#. type: Plain text
#: man-pages/man2/socket.2:168
msgid ""
"Set the B<O_NONBLOCK> file status flag on the new open file description.  "
"Using this flag saves extra calls to B<fcntl>(2)  to achieve the same "
"result."
msgstr "Устанавливает флаг состояния файла B<O_NONBLOCK> для нового открытого файлового дескриптора. Использование данного флага заменяет дополнительные вызовы B<fcntl>(2) для достижения того же результата."

#. type: TP
#: man-pages/man2/socket.2:168
#, no-wrap
msgid "B<SOCK_CLOEXEC>"
msgstr "B<SOCK_CLOEXEC>"

#. type: Plain text
#: man-pages/man2/socket.2:178
msgid ""
"Set the close-on-exec (B<FD_CLOEXEC>)  flag on the new file descriptor.  See"
" the description of the B<O_CLOEXEC> flag in B<open>(2)  for reasons why "
"this may be useful."
msgstr "Устанавливает флаг close-on-exec (B<FD_CLOEXEC>) для нового открытого файлового дескриптора. Смотрите описание флага B<O_CLOEXEC> в B<open>(2) для того, чтобы узнать как это может пригодиться."

#. type: Plain text
#: man-pages/man2/socket.2:194
msgid ""
"The I<protocol> specifies a particular protocol to be used with the socket."
"  Normally only a single protocol exists to support a particular socket type"
" within a given protocol family, in which case I<protocol> can be specified "
"as 0.  However, it is possible that many protocols may exist, in which case "
"a particular protocol must be specified in this manner.  The protocol number"
" to use is specific to the ``communication domain'' in which communication "
"is to take place; see B<protocols>(5).  See B<getprotoent>(3)  on how to map"
" protocol name strings to protocol numbers."
msgstr "В I<protocol> задаётся определённый протокол, используемый с сокетом. Обычно, только единственный протокол существует для поддержи определённого типа сокета с заданным семейством протоколов, в этом случае в I<protocol> можно указать 0. Однако, может существовать несколько протоколов, тогда нужно указать один из них. Номер используемого протокола зависит от \"домена соединения'', по которому устанавливается соединение; см. B<protocols>(5). Смотрите B<getprotoent>(3), где описано, как соотносить имена протоколов с их номерами."

#. type: Plain text
#: man-pages/man2/socket.2:224
msgid ""
"Sockets of type B<SOCK_STREAM> are full-duplex byte streams, similar to "
"pipes.  They do not preserve record boundaries.  A stream socket must be in "
"a I<connected> state before any data may be sent or received on it.  A "
"connection to another socket is created with a B<connect>(2)  call.  Once "
"connected, data may be transferred using B<read>(2)  and B<write>(2)  calls "
"or some variant of the B<send>(2)  and B<recv>(2)  calls.  When a session "
"has been completed a B<close>(2)  may be performed.  Out-of-band data may "
"also be transmitted as described in B<send>(2)  and received as described in"
" B<recv>(2)."
msgstr "Сокеты типа B<SOCK_STREAM> являются соединениями полнодуплексных байтовых потоков, похожими на каналы. Они не сохраняют границы записей. Потоковый сокет должен быть в состоянии I<соединения> перед тем, как из него можно будет отсылать данные или принимать их. Соединение с другим сокетом создается с помощью системного вызова B<connect>(2). После соединения данные можно передавать с помощью системных вызовов B<read>(2) и B<write>(2) или одного из вариантов системных вызовов B<send>(2) и B<recv>(2). Когда сеанс закончен, выполняется команда B<close>(2). Внепоточные данные могут передаваться, как описано в B<send>(2), и приниматься, как описано в B<recv>(2)."

#. type: Plain text
#: man-pages/man2/socket.2:250
msgid ""
"The communications protocols which implement a B<SOCK_STREAM> ensure that "
"data is not lost or duplicated.  If a piece of data for which the peer "
"protocol has buffer space cannot be successfully transmitted within a "
"reasonable length of time, then the connection is considered to be dead.  "
"When B<SO_KEEPALIVE> is enabled on the socket the protocol checks in a "
"protocol-specific manner if the other end is still alive.  A B<SIGPIPE> "
"signal is raised if a process sends or receives on a broken stream; this "
"causes naive processes, which do not handle the signal, to exit.  "
"B<SOCK_SEQPACKET> sockets employ the same system calls as B<SOCK_STREAM> "
"sockets.  The only difference is that B<read>(2)  calls will return only the"
" amount of data requested, and any data remaining in the arriving packet "
"will be discarded.  Also all message boundaries in incoming datagrams are "
"preserved."
msgstr "Протоколы связи, которые реализуют B<SOCK_STREAM>, следят, чтобы данные не были потеряны или дублированы. Если часть данных, для которых имеется место в буфере протокола, не может быть передана за определённое время, соединение считается разорванным. Когда в сокете включен флаг B<SO_KEEPALIVE>, протокол каким-либо способом проверяет, не отключена ли ещё другая сторона. Если процесс посылает или принимает данные, пользуясь «разорванным» потоком, ему выдаётся сигнал B<SIGPIPE>; это приводит к тому, что процессы, не обрабатывающие этот сигнал, завершаются. Сокеты B<SOCK_SEQPACKET> используют те же самые системные вызовы, что и сокеты B<SOCK_STREAM>. Единственное отличие в том, что вызовы B<read>(2) возвращают только запрошенное количество данных, а остальные данные пришедшего пакета будут отброшены. Границы сообщений во входящих дейтаграммах сохраняются."

#. type: Plain text
#: man-pages/man2/socket.2:260
msgid ""
"B<SOCK_DGRAM> and B<SOCK_RAW> sockets allow sending of datagrams to "
"correspondents named in B<sendto>(2)  calls.  Datagrams are generally "
"received with B<recvfrom>(2), which returns the next datagram along with the"
" address of its sender."
msgstr "Сокеты B<SOCK_DGRAM> и B<SOCK_RAW> позволяют посылать дейтаграммы принимающей стороне, заданной при вызове B<sendto>(2). Дейтаграммы обычно принимаются с помощью вызова B<recvfrom>(2), который возвращает следующую дейтаграмму с соответствующим обратным адресом."

#. type: Plain text
#: man-pages/man2/socket.2:267
msgid ""
"B<SOCK_PACKET> is an obsolete socket type to receive raw packets directly "
"from the device driver.  Use B<packet>(7)  instead."
msgstr "Тип B<SOCK_PACKET> считается устаревшим типом сокета; он позволяет получать необработанные пакеты прямо от драйвера устройства. Используйте вместо него B<packet>(7)."

#. type: Plain text
#: man-pages/man2/socket.2:290
msgid ""
"An B<fcntl>(2)  B<F_SETOWN> operation can be used to specify a process or "
"process group to receive a B<SIGURG> signal when the out-of-band data "
"arrives or B<SIGPIPE> signal when a B<SOCK_STREAM> connection breaks "
"unexpectedly.  This operation may also be used to set the process or process"
" group that receives the I/O and asynchronous notification of I/O events via"
" B<SIGIO>.  Using B<F_SETOWN> is equivalent to an B<ioctl>(2)  call with the"
" B<FIOSETOWN> or B<SIOCSPGRP> argument."
msgstr "Системный вызов B<fcntl>(2) с аргументом B<F_SETOWN> может использоваться для задания группы процессов, которая будет получать сигнал B<SIGURG>, когда прибывают внепоточные данные, или сигнал B<SIGPIPE>, когда соединение типа B<SOCK_STREAM> неожиданно обрывается. Этот вызов также можно использовать, чтобы задать процесс или группу процессов, которые получают асинхронные уведомления о событиях ввода-вывода с помощью B<SIGIO>. Использование B<F_SETOWN>  эквивалентно использованию вызова B<ioctl>(2) с аргументом B<FIOSETOWN> или B<SIOCSPGRP>."

#. type: Plain text
#: man-pages/man2/socket.2:300
msgid ""
"When the network signals an error condition to the protocol module (e.g., "
"using a ICMP message for IP) the pending error flag is set for the socket.  "
"The next operation on this socket will return the error code of the pending "
"error.  For some protocols it is possible to enable a per-socket error queue"
" to retrieve detailed information about the error; see B<IP_RECVERR> in "
"B<ip>(7)."
msgstr "Когда сеть сообщает модулю протокола об ошибке (например, в случае IP, используя ICMP-сообщение), то для сокета устанавливается флаг ожидающей ошибки. Следующая операция этого сокета вернёт код ожидающей ошибки. Некоторые протоколы позволяют организовывать очередь ошибок в сокете для получения подробной информацию об ошибке; см. B<IP_RECVERR> в B<ip>(7)."

#. type: Plain text
#: man-pages/man2/socket.2:310
msgid ""
"The operation of sockets is controlled by socket level I<options>.  These "
"options are defined in I<E<lt>sys/socket.hE<gt>>.  The functions "
"B<setsockopt>(2)  and B<getsockopt>(2)  are used to set and get options, "
"respectively."
msgstr "Операции сокетов контролируются их параметрами I<options>. Эти параметры описаны в I<E<lt>sys/socket.hE<gt>>. Вызовы B<setsockopt>(2) и B<getsockopt>(2) используются, чтобы установить и получить необходимые параметры соответственно."

#. type: Plain text
#: man-pages/man2/socket.2:315
msgid ""
"On success, a file descriptor for the new socket is returned.  On error, -1 "
"is returned, and I<errno> is set appropriately."
msgstr "В случае успешного выполнения возвращается дескриптор, ссылающийся на сокет. В случае ошибки возвращается -1, а значение I<errno> устанавливается соответствующим образом."

#. type: Plain text
#: man-pages/man2/socket.2:320
msgid ""
"Permission to create a socket of the specified type and/or protocol is "
"denied."
msgstr "Нет прав на создание сокета указанного типа и/или протокола."

#. type: TP
#: man-pages/man2/socket.2:320
#, no-wrap
msgid "B<EAFNOSUPPORT>"
msgstr "B<EAFNOSUPPORT>"

#. type: Plain text
#: man-pages/man2/socket.2:323
msgid "The implementation does not support the specified address family."
msgstr "Реализация не поддерживает указанное семейства адресов."

#. type: Plain text
#: man-pages/man2/socket.2:326
msgid "Unknown protocol, or protocol family not available."
msgstr "Неизвестный протокол или недоступное семейство протоколов."

#.  Since Linux 2.6.27
#. type: Plain text
#: man-pages/man2/socket.2:331
msgid "Invalid flags in I<type>."
msgstr "Неверные флаги в I<type>."

#. type: TP
#: man-pages/man2/socket.2:331
#, no-wrap
msgid "B<EMFILE>"
msgstr "B<EMFILE>"

#. type: Plain text
#: man-pages/man2/socket.2:334
msgid "Process file table overflow."
msgstr "Переполнение таблицы файлов процесса."

#. type: TP
#: man-pages/man2/socket.2:337
#, no-wrap
msgid "B<ENOBUFS> or B<ENOMEM>"
msgstr "B<ENOBUFS> или B<ENOMEM>"

#. type: Plain text
#: man-pages/man2/socket.2:342
msgid ""
"Insufficient memory is available.  The socket cannot be created until "
"sufficient resources are freed."
msgstr "Недостаточно памяти для создания сокета. Сокет не может быть создан, пока не будет освобождено достаточное количество ресурсов."

#. type: TP
#: man-pages/man2/socket.2:342
#, no-wrap
msgid "B<EPROTONOSUPPORT>"
msgstr "B<EPROTONOSUPPORT>"

#. type: Plain text
#: man-pages/man2/socket.2:346
msgid ""
"The protocol type or the specified protocol is not supported within this "
"domain."
msgstr "Тип протокола или указанный протокол не поддерживаются в этом домене."

#. type: Plain text
#: man-pages/man2/socket.2:348
msgid "Other errors may be generated by the underlying protocol modules."
msgstr "Другие ошибки могут быть созданы модулями протоколов более низкого уровня."

#. type: Plain text
#: man-pages/man2/socket.2:350
msgid "4.4BSD, POSIX.1-2001."
msgstr "4.4BSD, POSIX.1-2001."

#. type: Plain text
#: man-pages/man2/socket.2:356
msgid "The B<SOCK_NONBLOCK> and B<SOCK_CLOEXEC> flags are Linux-specific."
msgstr "Флаги B<SOCK_NONBLOCK> и B<SOCK_CLOEXEC> есть только в Linux."

#. type: Plain text
#: man-pages/man2/socket.2:362
msgid ""
"B<socket>()  appeared in 4.2BSD.  It is generally portable to/from non-BSD "
"systems supporting clones of the BSD socket layer (including System\\ V "
"variants)."
msgstr "Вызов B<socket>() появился в 4.2BSD. Обычно он переносим в/из не-BSD систем на уровне сокетов BSD (включая варианты System\\ V)."

#. type: Plain text
#: man-pages/man2/socket.2:368
msgid ""
"POSIX.1-2001 does not require the inclusion of I<E<lt>sys/types.hE<gt>>, and"
" this header file is not required on Linux.  However, some historical (BSD) "
"implementations required this header file, and portable applications are "
"probably wise to include it."
msgstr "В POSIX.1-2001 не требуется включение I<E<lt>sys/types.hE<gt>>, и этот заголовочный файл не требуется в Linux. Однако, некоторые старые (BSD) реализации требуют данный файл, и в переносимых приложениях для предосторожности, вероятно, он будет включён."

#. type: Plain text
#: man-pages/man2/socket.2:381
msgid ""
"The manifest constants used under 4.x BSD for protocol families are "
"B<PF_UNIX>, B<PF_INET>, and so on, while B<AF_UNIX>, B<AF_INET>, and so on "
"are used for address families.  However, already the BSD man page promises: "
"\"The protocol family generally is the same as the address family\", and "
"subsequent standards use AF_* everywhere."
msgstr "Для семейств протоколов в 4.x BSD используются константы B<PF_UNIX>, B<PF_INET>, B<PF_INET> и т. д., тогда как B<AF_UNIX>, B<AF_INET> и т. п. используется для указания семейства адресов. Однако, в справочной странице BSD сказано: «Обычно, семейство протоколов совпадает с семейством адресов» и во всех последующих стандартах используется AF_*."

#. type: Plain text
#: man-pages/man2/socket.2:386
msgid "An example of the use of B<socket>()  is shown in B<getaddrinfo>(3)."
msgstr "Пример использования B<socket>() показан в B<getaddrinfo>(3)."

#. type: Plain text
#: man-pages/man2/socket.2:409
msgid ""
"B<accept>(2), B<bind>(2), B<connect>(2), B<fcntl>(2), B<getpeername>(2), "
"B<getsockname>(2), B<getsockopt>(2), B<ioctl>(2), B<listen>(2), B<read>(2), "
"B<recv>(2), B<select>(2), B<send>(2), B<shutdown>(2), B<socketpair>(2), "
"B<write>(2), B<getprotoent>(3), B<ip>(7), B<socket>(7), B<tcp>(7), "
"B<udp>(7), B<unix>(7)"
msgstr "B<accept>(2), B<bind>(2), B<connect>(2), B<fcntl>(2), B<getpeername>(2), B<getsockname>(2), B<getsockopt>(2), B<ioctl>(2), B<listen>(2), B<read>(2), B<recv>(2), B<select>(2), B<send>(2), B<shutdown>(2), B<socketpair>(2), B<write>(2), B<getprotoent>(3), B<ip>(7), B<socket>(7), B<tcp>(7), B<udp>(7), B<unix>(7)"

#. type: Plain text
#: man-pages/man2/socket.2:414
msgid ""
"\\(lqAn Introductory 4.3BSD Interprocess Communication Tutorial\\(rq and "
"\\(lqBSD Interprocess Communication Tutorial\\(rq, reprinted in I<UNIX "
"Programmer's Supplementary Documents Volume 1.>"
msgstr "\\(lqAn Introductory 4.3BSD Interprocess Communication Tutorial\\(rq and \\(lqBSD Interprocess Communication Tutorial\\(rq, reprinted in I<UNIX Programmer's Supplementary Documents Volume 1.>"

#. type: TH
#: man-pages/man2/sched_yield.2:29
#, no-wrap
msgid "SCHED_YIELD"
msgstr "SCHED_YIELD"

#. type: TH
#: man-pages/man2/sched_yield.2:29
#, no-wrap
msgid "2014-04-28"
msgstr "2014-04-28"

#. type: Plain text
#: man-pages/man2/sched_yield.2:32
msgid "sched_yield - yield the processor"
msgstr "sched_yield - освободить процессор"

#. type: Plain text
#: man-pages/man2/sched_yield.2:34
msgid "B<#include E<lt>sched.hE<gt>>"
msgstr "B<#include E<lt>sched.hE<gt>>"

#. type: Plain text
#: man-pages/man2/sched_yield.2:36
msgid "B<int sched_yield(void);>"
msgstr "B<int sched_yield(void);>"

#. type: Plain text
#: man-pages/man2/sched_yield.2:41
msgid ""
"B<sched_yield>()  causes the calling thread to relinquish the CPU.  The "
"thread is moved to the end of the queue for its static priority and a new "
"thread gets to run."
msgstr "Вызов B<sched_yield>() заставляет вызывающую нить освободить процессор. Нить перемещается в конец очереди согласно её статическому приоритету, и управление передаётся другой нити."

#. type: Plain text
#: man-pages/man2/sched_yield.2:48
msgid ""
"On success, B<sched_yield>()  returns 0.  On error, -1 is returned, and "
"I<errno> is set appropriately."
msgstr "При удачном завершении B<sched_yield>() возвращается 0. При ошибке возвращается -1, а значение I<errno> устанавливается соответствующим образом."

#. type: Plain text
#: man-pages/man2/sched_yield.2:52
msgid "In the Linux implementation, B<sched_yield>()  always succeeds."
msgstr "В Linux-реализации B<sched_yield>() всегда завершается успешно."

#. type: Plain text
#: man-pages/man2/sched_yield.2:59
msgid ""
"If the calling thread is the only thread in the highest priority list at "
"that time, it will continue to run after a call to B<sched_yield>()."
msgstr "Если вызывающая нить единственная в списке с самым высоким приоритетом, то она продолжит выполняться после вызова B<sched_yield>()."

#. type: Plain text
#: man-pages/man2/sched_yield.2:66
msgid ""
"POSIX systems on which B<sched_yield>()  is available define "
"B<_POSIX_PRIORITY_SCHEDULING> in I<E<lt>unistd.hE<gt>>."
msgstr "В системах POSIX, в которых доступен вызов B<sched_yield>(), определён B<_POSIX_PRIORITY_SCHEDULING> в I<E<lt>unistd.hE<gt>>."

#. type: Plain text
#: man-pages/man2/sched_yield.2:79
msgid ""
"Strategic calls to B<sched_yield>()  can improve performance by giving other"
" threads or processes a chance to run when (heavily) contended resources "
"(e.g., mutexes)  have been released by the caller.  Avoid calling "
"B<sched_yield>()  unnecessarily or inappropriately (e.g., when resources "
"needed by other schedulable threads are still held by the caller), since "
"doing so will result in unnecessary context switches, which will degrade "
"system performance."
msgstr "Оперативные вызовы B<sched_yield>() могут улучшить производительность, давая другим нитям или процессам шанс поработать, когда (сильно) оспариваемые ресурсы (например, мьютексы) освобождаются вызывающим. Избегайте частых или нецелесообразных вызовов B<sched_yield>() (например, когда ресурсы, необходимые других планируемым нитям, по-прежнему удерживаются вызывающим), так как это приводит к чрезмерному переключению контекстов, что ухудшит производительность системы."

#. type: Plain text
#: man-pages/man2/sched_yield.2:80
msgid "B<sched>(7)"
msgstr "B<sched>(7)"

#. type: TH
#: man-pages/man2/sched_rr_get_interval.2:29
#, no-wrap
msgid "SCHED_RR_GET_INTERVAL"
msgstr "SCHED_RR_GET_INTERVAL"

#. type: Plain text
#: man-pages/man2/sched_rr_get_interval.2:32
msgid ""
"sched_rr_get_interval - get the SCHED_RR interval for the named process"
msgstr "sched_rr_get_interval - определяет временной интервал SCHED_RR для заданного процесса"

#. type: Plain text
#: man-pages/man2/sched_rr_get_interval.2:36
msgid ""
"B<int sched_rr_get_interval(pid_t >I<pid>B<, struct timespec * >I<tp>B<);>"
msgstr "B<int sched_rr_get_interval(pid_t >I<pid>B<, struct timespec * >I<tp>B<);>"

#. type: Plain text
#: man-pages/man2/sched_rr_get_interval.2:47
msgid ""
"B<sched_rr_get_interval>()  writes into the I<timespec> structure pointed to"
" by I<tp> the round-robin time quantum for the process identified by I<pid>."
"  The specified process should be running under the B<SCHED_RR> scheduling "
"policy."
msgstr "Вызов B<sched_rr_get_interval>() записывает циклический квант времени процесса I<pid> в структуру I<timespec>, на которую указывает I<tp>. Указанный процесс должен запускаться с политикой выполнения B<SCHED_RR>."

#. type: Plain text
#: man-pages/man2/sched_rr_get_interval.2:51
msgid "The I<timespec> structure has the following form:"
msgstr "Структура I<timespec> описана следующим образом:"

#. type: Plain text
#: man-pages/man2/sched_rr_get_interval.2:58
#, no-wrap
msgid ""
"struct timespec {\n"
"    time_t tv_sec;    /* seconds */\n"
"    long   tv_nsec;   /* nanoseconds */\n"
"};\n"
msgstr "struct timespec {\n    time_t tv_sec;        /* секунды */\n    long   tv_nsec;       /* наносекунды */\n};\n"

#.  FIXME . On Linux, sched_rr_get_interval()
#.  returns the timeslice for SCHED_OTHER processes -- this timeslice
#.  is influenced by the nice value.
#.  For SCHED_FIFO processes, this always returns 0.
#.  The round-robin time quantum value is not alterable under Linux
#.  1.3.81.
#. type: Plain text
#: man-pages/man2/sched_rr_get_interval.2:73
msgid ""
"If I<pid> is zero, the time quantum for the calling process is written into "
"I<*tp>."
msgstr "Если значение I<pid> равно нулю, то в I<*tp> записывается квант времени вызывающего процесса."

#. type: Plain text
#: man-pages/man2/sched_rr_get_interval.2:80
msgid ""
"On success, B<sched_rr_get_interval>()  returns 0.  On error, -1 is "
"returned, and I<errno> is set appropriately."
msgstr "При удачном выполнении B<sched_rr_get_interval>() возвращается 0. При ошибке возвращается -1, а значение I<errno> устанавливается соответствующим образом."

#. type: Plain text
#: man-pages/man2/sched_rr_get_interval.2:84
msgid "Problem with copying information to user space."
msgstr "Проблема с копированием информации в пространство пользователя."

#. type: Plain text
#: man-pages/man2/sched_rr_get_interval.2:87
msgid "Invalid pid."
msgstr "Неверное значение pid."

#. type: Plain text
#: man-pages/man2/sched_rr_get_interval.2:90
msgid "The system call is not yet implemented (only on rather old kernels)."
msgstr "Системный вызов ещё не реализован (только в старых ядрах)."

#. type: Plain text
#: man-pages/man2/sched_rr_get_interval.2:94
msgid "Could not find a process with the ID I<pid>."
msgstr "Не удалось найти процесс с идентификатором, указанном в I<pid>."

#. type: Plain text
#: man-pages/man2/sched_rr_get_interval.2:103
msgid ""
"POSIX systems on which B<sched_rr_get_interval>()  is available define "
"B<_POSIX_PRIORITY_SCHEDULING> in I<E<lt>unistd.hE<gt>>."
msgstr "В системах POSIX, в которых доступен вызов B<sched_rr_get_interval>(), определён B<_POSIX_PRIORITY_SCHEDULING> в I<E<lt>unistd.hE<gt>>."

#.  commit a4ec24b48ddef1e93f7578be53270f0b95ad666c
#. type: Plain text
#: man-pages/man2/sched_rr_get_interval.2:117
msgid ""
"POSIX does not specify any mechanism for controlling the size of the round-"
"robin time quantum.  Older Linux kernels provide a (nonportable) method of "
"doing this.  The quantum can be controlled by adjusting the process's nice "
"value (see B<setpriority>(2)).  Assigning a negative (i.e., high) nice value"
" results in a longer quantum; assigning a positive (i.e., low) nice value "
"results in a shorter quantum.  The default quantum is 0.1 seconds; the "
"degree to which changing the nice value affects the quantum has varied "
"somewhat across kernel versions.  This method of adjusting the quantum was "
"removed starting with Linux 2.6.24."
msgstr "В POSIX не определён какой-либо механизм для контроля размера циклического кванта времени. В старых ядрах Linux для этого создан (непереносимый) метод. Квант можно контролировать подгоняя значение любезности процесса (см. B<setpriority>(2)). Назначение отрицательного (т.е., высокого) значения любезности приведёт к более длинному кванту; назначение положительного (т.е., низкого) значения любезности приведёт к сокращению кванта. Квант по умолчанию равен 0.1 секунды; степень, с которой значение любезности влияет на квант, различается в разных версиях ядра. Данный метод подгонки кванта был удалён начиная с Linux 2.6.24."

#.  commit ce0dbbbb30aee6a835511d5be446462388ba9eee
#.  .SH BUGS
#.  As of Linux 1.3.81
#.  .BR sched_rr_get_interval ()
#.  returns with error
#.  ENOSYS, because SCHED_RR has not yet been fully implemented and tested
#.  properly.
#. type: Plain text
#: man-pages/man2/sched_rr_get_interval.2:132
msgid ""
"Linux 3.9 added a new mechanism for adjusting (and viewing) the B<SCHED_RR> "
"quantum: the I</proc/sys/kernel/sched_rr_timeslice_ms> file exposes the "
"quantum as a millisecond value, whose default is 100.  Writing 0 to this "
"file resets the quantum to the default value."
msgstr "В Linux 3.9 добавлен новый механизм регулировки (и просмотра) кванта B<SCHED_RR>: файл I</proc/sys/kernel/sched_rr_timeslice_ms> отражает квант как значение в миллисекундах, по умолчанию равное 100. Запись 0 в этот файл сбрасывает квант в значение по умолчанию."

#. type: TH
#: man-pages/man2/setsid.2:30
#, no-wrap
msgid "SETSID"
msgstr "SETSID"

#. type: TH
#: man-pages/man2/setsid.2:30
#, no-wrap
msgid "2013-02-11"
msgstr "2013-02-11"

#. type: Plain text
#: man-pages/man2/setsid.2:33
msgid "setsid - creates a session and sets the process group ID"
msgstr "setsid - создает сеанс и устанавливает идентификатор группы процесса"

#. type: Plain text
#: man-pages/man2/setsid.2:38
msgid "B<pid_t setsid(void);>"
msgstr "B<pid_t setsid(void);>"

#. type: Plain text
#: man-pages/man2/setsid.2:51
msgid ""
"B<setsid>()  creates a new session if the calling process is not a process "
"group leader.  The calling process is the leader of the new session, the "
"process group leader of the new process group, and has no controlling "
"terminal.  The process group ID and session ID of the calling process are "
"set to the PID of the calling process.  The calling process will be the only"
" process in this new process group and in this new session."
msgstr "B<setsid>() создаёт новый сеанс, если вызывающий процесс не является лидером группы процессов. Вызывающий процесс становится лидером нового сеанса, лидером новой группы процессов и не имеет управляющего терминала. Идентификатор группы процессов и сеанса вызывающего процесса устанавливаются равными идентификатору вызывающего процесса (PID). Вызывающий процесс будет единственным в этой новой группе процессов и новом сеансе."

#. type: Plain text
#: man-pages/man2/setsid.2:58
msgid ""
"On success, the (new) session ID of the calling process is returned.  On "
"error, I<(pid_t)\\ -1> is returned, and I<errno> is set to indicate the "
"error."
msgstr "При успешном выполнении возвращается идентификатор (нового) сеанса вызывающего процесса. В случае ошибки возвращается I<(pid_t)\\ -1>, а I<errno> устанавливается в соответствующее значение."

#. type: Plain text
#: man-pages/man2/setsid.2:65
msgid ""
"The process group ID of any process equals the PID of the calling process.  "
"Thus, in particular, B<setsid>()  fails if the calling process is already a "
"process group leader."
msgstr "Идентификатор группы процессов любого процесса равен PID вызывающего процесса. В этом случае, в частности, B<setsid>() завершается неудачно, если вызывающий процесс уже является лидером группы процессов."

#. type: Plain text
#: man-pages/man2/setsid.2:73
msgid ""
"A child created via B<fork>(2)  inherits its parent's session ID.  The "
"session ID is preserved across an B<execve>(2)."
msgstr "Потомок, создаваемый с помощью B<fork>(2), наследует ID сеанса своего родителя. Идентификатор сеанса сохраняется при вызове B<execve>(2)."

#. type: Plain text
#: man-pages/man2/setsid.2:84
msgid ""
"A process group leader is a process with process group ID equal to its PID."
"  In order to be sure that B<setsid>()  will succeed, B<fork>(2)  and "
"B<_exit>(2), and have the child do B<setsid>()."
msgstr "Лидер группы процессов \\(em это процесс, идентификатор группы процессов которого равен идентификатору самого процесса (PID). Для того, чтобы удостовериться, что функция B<setsid>() выполнится успешно, создайте дочерний процесс при помощи B<fork>(2) и B<_exit>(2), а затем в дочернем процессе сделайте вызов B<setsid>()."

#. type: Plain text
#: man-pages/man2/setsid.2:90
msgid ""
"B<setsid>(1), B<getsid>(2), B<setpgid>(2), B<setpgrp>(2), B<tcgetsid>(3), "
"B<credentials>(7)"
msgstr "B<setsid>(1), B<getsid>(2), B<setpgid>(2), B<setpgrp>(2), B<tcgetsid>(3), B<credentials>(7)"

#. type: TH
#: man-pages/man2/setreuid.2:45
#, no-wrap
msgid "SETREUID"
msgstr "SETREUID"

#. type: Plain text
#: man-pages/man2/setreuid.2:48
msgid "setreuid, setregid - set real and/or effective user or group ID"
msgstr "setreuid, setregid - устанавливает действительный и/или эффективный идентификатор пользователя или группы"

#. type: Plain text
#: man-pages/man2/setreuid.2:54
msgid "B<int setreuid(uid_t >I<ruid>B<, uid_t >I<euid>B<);>"
msgstr "B<int setreuid(uid_t >I<ruid>B<, uid_t >I<euid>B<);>"

#. type: Plain text
#: man-pages/man2/setreuid.2:56
msgid "B<int setregid(gid_t >I<rgid>B<, gid_t >I<egid>B<);>"
msgstr "B<int setregid(gid_t >I<rgid>B<, gid_t >I<egid>B<);>"

#. type: Plain text
#: man-pages/man2/setreuid.2:64
msgid "B<setreuid>(), B<setregid>():"
msgstr "B<setreuid>(), B<setregid>():"

#. type: Plain text
#: man-pages/man2/setreuid.2:68
msgid ""
"_BSD_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 500 || _XOPEN_SOURCE\\ &&\\ "
"_XOPEN_SOURCE_EXTENDED"
msgstr "_BSD_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 500 || _XOPEN_SOURCE\\ &&\\ _XOPEN_SOURCE_EXTENDED"

#. type: Plain text
#: man-pages/man2/setreuid.2:73
msgid ""
"B<setreuid>()  sets real and effective user IDs of the calling process."
msgstr "Вызов B<setreuid>() устанавливает действительный и эффективный идентификатор пользователя вызывающего процесса."

#. type: Plain text
#: man-pages/man2/setreuid.2:76
msgid ""
"Supplying a value of -1 for either the real or effective user ID forces the "
"system to leave that ID unchanged."
msgstr "Если указываемое значение действительного или эффективного идентификатора пользователя равно -1, то система не изменяет его."

#. type: Plain text
#: man-pages/man2/setreuid.2:79
msgid ""
"Unprivileged processes may only set the effective user ID to the real user "
"ID, the effective user ID, or the saved set-user-ID."
msgstr "Непривилегированные процессы могут изменять эффективный идентификатор пользователя на действующий, эффективный или сохранённый идентификатор пользователя."

#. type: Plain text
#: man-pages/man2/setreuid.2:82
msgid ""
"Unprivileged users may only set the real user ID to the real user ID or the "
"effective user ID."
msgstr "Непривилегированные пользователи могут изменять действительный идентификатор пользователя на эффективный или действительный идентификатор пользователя."

#. type: Plain text
#: man-pages/man2/setreuid.2:88
msgid ""
"If the real user ID is set (i.e., I<ruid> is not -1) or the effective user "
"ID is set to a value not equal to the previous real user ID, the saved set-"
"user-ID will be set to the new effective user ID."
msgstr "Если установлен действительный идентификатор пользователя (т. е., значение I<ruid> не равно -1) или установлено значение эффективного идентификатора пользователя в отличное от предыдущего значения действительного идентификатора пользователя, то значение сохранённого идентификатора пользователя будет установлено в новое значение эффективного идентификатора пользователя."

#. type: Plain text
#: man-pages/man2/setreuid.2:93
msgid ""
"Completely analogously, B<setregid>()  sets real and effective group ID's of"
" the calling process, and all of the above holds with \"group\" instead of "
"\"user\"."
msgstr "Аналогично B<setregid>() меняет действующий и эффективный идентификаторы группы вызывающего процесса, и всё описанное выше для пользователя справедливо и для группы."

#. type: Plain text
#: man-pages/man2/setreuid.2:105
msgid ""
"I<Note>: there are cases where B<setreuid>()  can fail even when the caller "
"is UID 0; it is a grave security error to omit checking for a failure return"
" from B<setreuid>()."
msgstr ""

#. type: Plain text
#: man-pages/man2/setreuid.2:144
msgid ""
"The calling process is not privileged (Linux: does not have the "
"B<CAP_SETUID> capability in the case of B<setreuid>(), or the B<CAP_SETGID> "
"capability in the case of B<setregid>())  and a change other than (i)  "
"swapping the effective user (group) ID with the real user (group) ID, or "
"(ii) setting one to the value of the other or (iii) setting the effective "
"user (group) ID to the value of the saved set-user-ID (saved set-group-ID) "
"was specified."
msgstr "Вызывающий процесс запущен без прав суперпользователя (Linux: не имеет мандата B<CAP_SETUID> при вызове B<setreuid>(), или мандата B<CAP_SETGID> при вызове B<setregid>()), а требуемые изменения не относятся к следующим: 1) взаимозамене эффективного идентификатора на действительный идентификатор пользователя (группы); 2) установке значения одного идентификатора в значение другого; 3) замене эффективного идентификатора пользователя (группы) на сохранённый идентификатор пользователя (группы)."

#. type: Plain text
#: man-pages/man2/setreuid.2:150
msgid ""
"POSIX.1-2001, 4.3BSD (the B<setreuid>()  and B<setregid>()  function calls "
"first appeared in 4.2BSD)."
msgstr "POSIX.1-2001, 4.3BSD (вызовы B<setreuid>() и B<setregid>() появились в 4.2BSD)."

#. type: Plain text
#: man-pages/man2/setreuid.2:154
msgid ""
"Setting the effective user (group) ID to the saved set-user-ID (saved set-"
"group-ID) is possible since Linux 1.1.37 (1.1.38)."
msgstr "Установка эффективного идентификатора пользователя (группы) в значение сохранённого идентификатора возможна с версии Linux 1.1.37 (1.1.38)."

#. type: Plain text
#: man-pages/man2/setreuid.2:171
msgid ""
"POSIX.1 does not specify all of possible ID changes that are permitted on "
"Linux for an unprivileged process.  For B<setreuid>(), the effective user ID"
" can be made the same as the real user ID or the save set-user-ID, and it is"
" unspecified whether unprivileged processes may set the real user ID to the "
"real user ID, the effective user ID, or the saved set-user-ID.  For "
"B<setregid>(), the real group ID can be changed to the value of the saved "
"set-group-ID, and the effective group ID can be changed to the value of the "
"real group ID or the saved set-group-ID.  The precise details of what ID "
"changes are permitted vary across implementations."
msgstr "В POSIX.1 не определены все возможные варианты изменения идентификаторов, разрешённые в Linux непривилегированным процессам. Вызов B<setreuid>() может изменить значение эффективного пользовательского идентификатора на действительный или сохранённый пользовательский идентификатор и не определено, может ли непривилегированный процесс установить действительный пользовательский идентификатор равным действительному, эффективному или сохранённому пользовательскому идентификатору. Вызов B<setregid>() может изменить действительный идентификатор группы на значение сохранённого идентификатора группы, а эффективный идентификатор группы — на значение действительного или сохранённого идентификатора группы. Действующие правила о разрешённых изменениях идентификаторов отличаются в разных реализациях."

#. type: Plain text
#: man-pages/man2/setreuid.2:174
msgid ""
"POSIX.1 makes no specification about the effect of these calls on the saved "
"set-user-ID and saved set-group-ID."
msgstr "В POSIX.1 ничего не сказано о работе этих вызовов над сохранённым идентификатором пользователя и группы."

#. type: Plain text
#: man-pages/man2/setreuid.2:190
msgid ""
"The original Linux B<setreuid>()  and B<setregid>()  system calls supported "
"only 16-bit user and group IDs.  Subsequently, Linux 2.4 added "
"B<setreuid32>()  and B<setregid32>(), supporting 32-bit IDs.  The glibc "
"B<setreuid>()  and B<setregid>()  wrapper functions transparently deal with "
"the variations across kernel versions."
msgstr "Первоначальные версии системных вызовов B<setreuid>() и B<setregid>() в Linux поддерживали только 16-битные идентификаторы пользователей и групп. Позднее в Linux 2.4 были добавлены вызовы B<setreuid32>() и B<setregid32>(), поддерживающие 32-битные идентификаторы. В glibc обёрточные функции B<setreuid>() и B<setregid>() работают одинаково вне зависимости от версий ядра."

#. type: Plain text
#: man-pages/man2/setreuid.2:197
msgid ""
"B<getgid>(2), B<getuid>(2), B<seteuid>(2), B<setgid>(2), B<setresuid>(2), "
"B<setuid>(2), B<capabilities>(7)"
msgstr "B<getgid>(2), B<getuid>(2), B<seteuid>(2), B<setgid>(2), B<setresuid>(2), B<setuid>(2), B<capabilities>(7)"

#. type: TH
#: man-pages/man2/swapon.2:37
#, no-wrap
msgid "SWAPON"
msgstr "SWAPON"

#. type: TH
#: man-pages/man2/swapon.2:37
#, no-wrap
msgid "2014-05-28"
msgstr "2014-05-28"

#. type: Plain text
#: man-pages/man2/swapon.2:40
msgid "swapon, swapoff - start/stop swapping to file/device"
msgstr "swapon, swapoff - запускает/останавливает подкачку данных в файл/устройство"

#. type: Plain text
#: man-pages/man2/swapon.2:44
msgid "B<#include E<lt>sys/swap.hE<gt>>"
msgstr "B<#include E<lt>sys/swap.hE<gt>>"

#. type: Plain text
#: man-pages/man2/swapon.2:46
msgid "B<int swapon(const char *>I<path>B<, int >I<swapflags>B<);>"
msgstr "B<int swapon(const char *>I<path>B<, int >I<swapflags>B<);>"

#. type: Plain text
#: man-pages/man2/swapon.2:48
msgid "B<int swapoff(const char *>I<path>B<);>"
msgstr "B<int swapoff(const char *>I<path>B<);>"

#. type: Plain text
#: man-pages/man2/swapon.2:55
msgid ""
"B<swapon>()  sets the swap area to the file or block device specified by "
"I<path>.  B<swapoff>()  stops swapping to the file or block device specified"
" by I<path>."
msgstr "B<swapon>() включает использование файла или блочного устройства, указанного в I<path>, в качестве подкачки данных. B<swapoff>() выключает использование файла или блочного устройства, указанного в I<path>, в качестве подкачки данных."

#. type: Plain text
#: man-pages/man2/swapon.2:65
msgid ""
"If the B<SWAP_FLAG_PREFER> flag is specified in the B<swapon>()  "
"I<swapflags> argument, the new swap area will have a higher priority than "
"default.  The priority is encoded within I<swapflags> as:"
msgstr "Если при вызове B<swapon>() в аргументе I<swapflags> установлен флаг B<SWAP_FLAG_PREFER>, то новое пространство подкачки будет иметь больший приоритет, чем используемый по умолчанию. Приоритет задаётся в I<swapflags> следующим образом:"

#. type: Plain text
#: man-pages/man2/swapon.2:68
msgid "I<(prio E<lt>E<lt> SWAP_FLAG_PRIO_SHIFT) & SWAP_FLAG_PRIO_MASK>"
msgstr "I<(prio E<lt>E<lt> SWAP_FLAG_PRIO_SHIFT) & SWAP_FLAG_PRIO_MASK>"

#. type: Plain text
#: man-pages/man2/swapon.2:80
msgid ""
"If the B<SWAP_FLAG_DISCARD> flag is specified in the B<swapon>()  "
"I<swapflags> argument, freed swap pages will be discarded before they are "
"reused, if the swap device supports the discard or trim operation.  (This "
"may improve performance on some Solid State Devices, but often it does not.)"
"  See also NOTES."
msgstr "Если в аргументе I<swapflags> вызова B<swapon>() указан флаг B<SWAP_FLAG_DISCARD>, то освобождаемые страницы подкачки будут исключены (discard) до того как они задействуются повторно (если устройство подкачки поддерживает операцию исключения или обрезки). Это может улучшить производительность на некоторых твёрдотельных накопителях, но, чаще всего, нет. Также смотрите ЗАМЕЧАНИЯ."

#. type: Plain text
#: man-pages/man2/swapon.2:84
msgid ""
"These functions may be used only by a privileged process (one having the "
"B<CAP_SYS_ADMIN> capability)."
msgstr "Эти функции могут использоваться только привилегированным процессом (имеющим мандат B<CAP_SYS_ADMIN>)."

#. type: SS
#: man-pages/man2/swapon.2:84
#, no-wrap
msgid "Priority"
msgstr "Приоритет"

#. type: Plain text
#: man-pages/man2/swapon.2:89
msgid ""
"Each swap area has a priority, either high or low.  The default priority is "
"low.  Within the low-priority areas, newer areas are even lower priority "
"than older areas."
msgstr "Каждое пространство подкачки имеет приоритет, высокий или низкий. По умолчанию задается низкий приоритет. Внутри пространств с низким приоритетом, новые пространства имеют ещё меньший приоритет, чем старые."

#. type: Plain text
#: man-pages/man2/swapon.2:95
msgid ""
"All priorities set with I<swapflags> are high-priority, higher than default."
"  They may have any nonnegative value chosen by the caller.  Higher numbers "
"mean higher priority."
msgstr "Все приоритеты, установленные с помощью I<swapflags>, выше используемого по умолчанию. Приоритет может быть любым неотрицательным числом (определяется вызывающим). Большее значение соответствует большему приоритету."

#. type: Plain text
#: man-pages/man2/swapon.2:103
msgid ""
"Swap pages are allocated from areas in priority order, highest priority "
"first.  For areas with different priorities, a higher-priority area is "
"exhausted before using a lower-priority area.  If two or more areas have the"
" same priority, and it is the highest priority available, pages are "
"allocated on a round-robin basis between them."
msgstr "Страницы подкачки располагаются в пространствах согласно убыванию их приоритета. Если приоритеты различаются, то сначала полностью заполняются пространства с большим приоритетом. Если два пространства имеют одинаковый приоритет, и это наибольший приоритет из свободных, страницы распределяются между ними по \"карусельному\" принципу."

#. type: Plain text
#: man-pages/man2/swapon.2:106
msgid ""
"As of Linux 1.3.6, the kernel usually follows these rules, but there are "
"exceptions."
msgstr "В Linux 1.3.6 работа ядра обычно следует этим правилам, но существуют исключения."

#. type: Plain text
#: man-pages/man2/swapon.2:119
msgid ""
"(for B<swapon>())  The specified I<path> is already being used as a swap "
"area."
msgstr "(для B<swapon>()) Указанный I<path> уже используется в качестве пространства подкачки."

#. type: Plain text
#: man-pages/man2/swapon.2:124
msgid ""
"The file I<path> exists, but refers neither to a regular file nor to a block"
" device;"
msgstr "Файл I<path> существует, но не ссылается на обычный файл или блочное устройство;"

#. type: Plain text
#: man-pages/man2/swapon.2:129
msgid ""
"(B<swapon>())  The indicated path does not contain a valid swap signature or"
" resides on an in-memory filesystem such as tmpfs."
msgstr "(B<swapon>()) Указанный путь не содержит правильной сигнатуры подкачки или располагается в файловой системе, работающей в памяти, например, tmpfs."

#. type: TP
#: man-pages/man2/swapon.2:129
#, no-wrap
msgid "B<EINVAL> (since Linux 3.4)"
msgstr "B<EINVAL> (начиная с Linux 3.4)"

#. type: Plain text
#: man-pages/man2/swapon.2:134
msgid "(B<swapon>())  An invalid flag value was specified in I<flags>."
msgstr "(B<swapon>()) В I<flags> указано неверное значение флага."

#. type: Plain text
#: man-pages/man2/swapon.2:139
msgid "(B<swapoff>())  I<path> is not currently a swap area."
msgstr "(B<swapoff>()) В настоящее время I<path> не является областью подкачки."

#. type: Plain text
#: man-pages/man2/swapon.2:147
msgid "The file I<path> does not exist."
msgstr "Файл I<path> не существует."

#. type: Plain text
#: man-pages/man2/swapon.2:150
msgid "The system has insufficient memory to start swapping."
msgstr "Не хватает памяти ядра для запуска процесса подкачки."

#. type: Plain text
#: man-pages/man2/swapon.2:157
msgid ""
"The caller does not have the B<CAP_SYS_ADMIN> capability.  Alternatively, "
"the maximum number of swap files are already in use; see NOTES below."
msgstr "Вызывающий не имеет мандата B<CAP_SYS_ADMIN>. Или превышен лимит количества используемых пространств подкачки; см. ЗАМЕЧАНИЯ далее."

#. type: Plain text
#: man-pages/man2/swapon.2:163
msgid ""
"These functions are Linux-specific and should not be used in programs "
"intended to be portable.  The second I<swapflags> argument was introduced in"
" Linux 1.3.2."
msgstr "Эти функции предназначены только для работы в Linux и не должны использоваться в переносимых программах. Второй параметр I<swapflags> впервые появился в Linux 1.3.2."

#. type: Plain text
#: man-pages/man2/swapon.2:166
msgid "The partition or path must be prepared with B<mkswap>(8)."
msgstr "Раздел или путь должны быть подготовлены к подкачке при помощи B<mkswap>(8)."

#. type: Plain text
#: man-pages/man2/swapon.2:186
msgid ""
"There is an upper limit on the number of swap files that may be used, "
"defined by the kernel constant B<MAX_SWAPFILES>.  Before kernel 2.4.10, "
"B<MAX_SWAPFILES> has the value 8; since kernel 2.4.10, it has the value 32."
"  Since kernel 2.6.18, the limit is decreased by 2 (thus: 30)  if the kernel"
" is built with the B<CONFIG_MIGRATION> option (which reserves two swap table"
" entries for the page migration features of B<mbind>(2)  and "
"B<migrate_pages>(2)).  Since kernel 2.6.32, the limit is further decreased "
"by 1 if the kernel is built with the B<CONFIG_MEMORY_FAILURE> option."
msgstr "Есть верхний предел на количество используемых файлов подкачки, он определяется константой ядра B<MAX_SWAPFILES>. До ядра версии 2.4.10 значение B<MAX_SWAPFILES> было равно 8; начиная с ядра 2.4.10, значение стало 32.  Начиная с ядра 2.6.18, предел уменьшается на 2 (то есть стало 30), если ядро собирается с параметром B<CONFIG_MIGRATION> (который резервирует 2 элемента таблицы подкачки для возможности переноса страниц B<mbind>(2) и B<migrate_pages>(2)). Начиная с ядра 2.6.32, предел ещё сокращается на 1, если ядро собирается с параметром B<CONFIG_MEMORY_FAILURE>."

#.  To be precise: 2.6.35.5
#. type: Plain text
#: man-pages/man2/swapon.2:197
msgid ""
"Discard of swap pages was introduced in kernel 2.6.29, then made conditional"
" on the B<SWAP_FLAG_DISCARD> flag in kernel 2.6.36, which still discards the"
" entire swap area when B<swapon>()  is called, even if that flag bit is not "
"set."
msgstr "Исключение (discard) страниц подкачки появилось в ядре версии 2.6.29, флаг условия B<SWAP_FLAG_DISCARD> появился в ядре версии 2.6.36, но пока при вызове B<swapon>() исключается вся область подкачки, даже если этот флаг не задан."

#. type: Plain text
#: man-pages/man2/swapon.2:200
msgid "B<mkswap>(8), B<swapoff>(8), B<swapon>(8)"
msgstr "B<mkswap>(8), B<swapoff>(8), B<swapon>(8)"

#. type: TH
#: man-pages/man2/setup.2:34
#, no-wrap
msgid "SETUP"
msgstr "SETUP"

#. type: TH
#: man-pages/man2/setup.2:34
#, no-wrap
msgid "2008-12-03"
msgstr "2008-12-03"

#. type: Plain text
#: man-pages/man2/setup.2:37
msgid "setup - setup devices and filesystems, mount root filesystem"
msgstr "setup - настраивает устройства и файловые системы, монтирует корневую файловую систему"

#. type: Plain text
#: man-pages/man2/setup.2:41
msgid "B<int setup(void);>"
msgstr "B<int setup(void);>"

#. type: Plain text
#: man-pages/man2/setup.2:47
msgid ""
"B<setup>()  is called once from within I<linux/init/main.c>.  It calls "
"initialization functions for devices and filesystems configured into the "
"kernel and then mounts the root filesystem."
msgstr "B<setup>() вызывается один раз из I<linux/init/main.c>. Она вызывает функции инициализации устройств и файловых систем, встроенных в ядро, и затем монтирует корневую файловую систему."

#. type: Plain text
#: man-pages/man2/setup.2:53
msgid ""
"No user process may call B<setup>().  Any user process, even a process with "
"superuser permission, will receive B<EPERM>."
msgstr "Ни один из пользовательских процессов не может вызвать B<setup>(). Любой пользовательский процесс даже с правами суперпользователя будет получать сообщение об ошибке с кодом B<EPERM>."

#. type: Plain text
#: man-pages/man2/setup.2:56
msgid "B<setup>()  always returns -1 for a user process."
msgstr "Вызов B<setup>() всегда возвращает пользовательскому процессу значение -1."

#. type: Plain text
#: man-pages/man2/setup.2:60
msgid "Always, for a user process."
msgstr "Всегда для пользовательского процесса."

#. type: Plain text
#: man-pages/man2/setup.2:62
msgid "Since Linux 2.1.121, no such function exists anymore."
msgstr "Начиная с Linux 2.1.121, эта функция не существует."

#. type: Plain text
#: man-pages/man2/setup.2:65
msgid ""
"This function is Linux-specific, and should not be used in programs intended"
" to be portable, or indeed in any programs at all."
msgstr "Эта функция применяется только в Linux и поэтому не должна использоваться в программах, предназначенных для переноса на другую платформу, и вообще не должна вызываться из пользовательских программ."

#. type: Plain text
#: man-pages/man2/setup.2:71
msgid ""
"The calling sequence varied: at some times I<setup ()> has had a single "
"argument I<void\\ *BIOS> and at other times a single argument I<int magic>."
msgstr "Вызывающая последовательность менялась: в некоторых версиях у I<setup ()> был один аргумент I<void\\ *BIOS>, а в некоторых — I<int magic>."

#. type: TH
#: man-pages/man2/sigaction.2:47
#, no-wrap
msgid "SIGACTION"
msgstr "SIGACTION"

#. type: TH
#: man-pages/man2/sigaction.2:47
#, no-wrap
msgid "2014-04-27"
msgstr "2014-04-27"

#. type: Plain text
#: man-pages/man2/sigaction.2:50
msgid "sigaction - examine and change a signal action"
msgstr "sigaction - получает и изменяет обработчик сигнала"

#. type: Plain text
#: man-pages/man2/sigaction.2:56
#, no-wrap
msgid ""
"B<int sigaction(int >I<signum>B<, const struct sigaction *>I<act>B<,>\n"
"B<              struct sigaction *>I<oldact>B<);>\n"
msgstr "B<int sigaction(int >I<signum>B<, const struct sigaction *>I<act>B<,>\nB<              struct sigaction *>I<oldact>B<);>\n"

#. type: Plain text
#: man-pages/man2/sigaction.2:66
msgid ""
"B<sigaction>(): _POSIX_C_SOURCE\\ E<gt>=\\ 1 || _XOPEN_SOURCE || "
"_POSIX_SOURCE"
msgstr "B<sigaction>(): _POSIX_C_SOURCE\\ E<gt>=\\ 1 || _XOPEN_SOURCE || _POSIX_SOURCE"

#. type: Plain text
#: man-pages/man2/sigaction.2:69
msgid "I<siginfo_t>: _POSIX_C_SOURCE E<gt>= 199309L"
msgstr "I<siginfo_t>: _POSIX_C_SOURCE E<gt>= 199309L"

#. type: Plain text
#: man-pages/man2/sigaction.2:78
msgid ""
"The B<sigaction>()  system call is used to change the action taken by a "
"process on receipt of a specific signal.  (See B<signal>(7)  for an overview"
" of signals.)"
msgstr "Системный вызов B<sigaction>() используется для изменения выполняемого процессом действия при получении определённого сигнала (список сигналов смотрите в B<signal>(7))."

#. type: Plain text
#: man-pages/man2/sigaction.2:84
msgid ""
"I<signum> specifies the signal and can be any valid signal except B<SIGKILL>"
" and B<SIGSTOP>."
msgstr "В I<signum> указывается сигнал; может принимать значение любого корректного сигнала за исключением B<SIGKILL> и B<SIGSTOP>."

#. type: Plain text
#: man-pages/man2/sigaction.2:95
msgid ""
"If I<act> is non-NULL, the new action for signal I<signum> is installed from"
" I<act>.  If I<oldact> is non-NULL, the previous action is saved in "
"I<oldact>."
msgstr "Если значение I<act> не равно NULL, то устанавливается новое действие для сигнала I<signum> из I<act>. Если значение I<oldact> не равно NULL, то предыдущее действие записывается в I<oldact>."

#. type: Plain text
#: man-pages/man2/sigaction.2:99
msgid "The I<sigaction> structure is defined as something like:"
msgstr "Структура I<sigaction> определена следующим образом:"

#. type: Plain text
#: man-pages/man2/sigaction.2:109
#, no-wrap
msgid ""
"struct sigaction {\n"
"    void     (*sa_handler)(int);\n"
"    void     (*sa_sigaction)(int, siginfo_t *, void *);\n"
"    sigset_t   sa_mask;\n"
"    int        sa_flags;\n"
"    void     (*sa_restorer)(void);\n"
"};\n"
msgstr "struct sigaction {\n    void     (*sa_handler)(int);\n    void     (*sa_sigaction)(int, siginfo_t *, void *);\n    sigset_t sa_mask;\n    int      sa_flags;\n    void     (*sa_restorer)(void);\n};\n"

#. type: Plain text
#: man-pages/man2/sigaction.2:116
msgid ""
"On some architectures a union is involved: do not assign to both "
"I<sa_handler> and I<sa_sigaction>."
msgstr "Для некоторых архитектур используется union: не выполняйте назначение одновременно I<sa_handler> и I<sa_sigaction>."

#. type: Plain text
#: man-pages/man2/sigaction.2:123
msgid ""
"The I<sa_restorer> element is obsolete and should not be used.  POSIX does "
"not specify a I<sa_restorer> element."
msgstr "Элемент I<sa_restorer> устарел и не должен использоваться. В POSIX не указан элемент I<sa_restorer>."

#. type: Plain text
#: man-pages/man2/sigaction.2:133
msgid ""
"I<sa_handler> specifies the action to be associated with I<signum> and may "
"be B<SIG_DFL> for the default action, B<SIG_IGN> to ignore this signal, or a"
" pointer to a signal handling function.  This function receives the signal "
"number as its only argument."
msgstr "I<sa_handler> указывает действие, которое должно быть связано с I<signum>; может принимать значение B<SIG_DFL> в качестве действия по умолчанию, B<SIG_IGN>, чтобы игнорировать этот сигнал, или принимать указатель на функцию управления сигналом. Данная функция получает номер сигнала в качестве своего единственного аргумента."

#. type: Plain text
#: man-pages/man2/sigaction.2:155
msgid ""
"If B<SA_SIGINFO> is specified in I<sa_flags>, then I<sa_sigaction> (instead "
"of I<sa_handler>)  specifies the signal-handling function for I<signum>.  "
"This function receives the signal number as its first argument, a pointer to"
" a I<siginfo_t> as its second argument and a pointer to a I<ucontext_t> "
"(cast to I<void\\ *>) as its third argument.  (Commonly, the handler "
"function doesn't make any use of the third argument.  See B<getcontext>(3)  "
"for further information about I<ucontext_t>.)"
msgstr "Если в I<sa_flags> указан B<SA_SIGINFO>, то I<sa_sigaction> (вместо I<sa_handler>) задаёт функцию обработки сигнала I<signum>. В первом аргументе функция принимает номер сигнала, во втором — указатель на I<siginfo_t> и в третьем — указатель на I<ucontext_t> (приведённый к I<void\\ *>) (вообще, функция-обработчик не используется третий аргумент. Подробней о I<ucontext_t> смотрите в B<getcontext>(3))."

#. type: Plain text
#: man-pages/man2/sigaction.2:165
msgid ""
"I<sa_mask> specifies a mask of signals which should be blocked (i.e., added "
"to the signal mask of the thread in which the signal handler is invoked)  "
"during execution of the signal handler.  In addition, the signal which "
"triggered the handler will be blocked, unless the B<SA_NODEFER> flag is "
"used."
msgstr "В I<sa_mask> задаётся маска сигналов, которые должны блокироваться (т.е. добавляется к маске сигналов нити, в которой вызывается обработчик сигнала) при выполнении обработчика сигнала. Также будет блокироваться и сигнал, вызвавший запуск обработчика, если только не был использован флаг B<SA_NODEFER>."

#. type: Plain text
#: man-pages/man2/sigaction.2:169
msgid ""
"I<sa_flags> specifies a set of flags which modify the behavior of the "
"signal.  It is formed by the bitwise OR of zero or more of the following:"
msgstr "В I<flag> указывается набор флагов, которые изменяют поведение сигнала. Он формируется побитовым ИЛИ из следующих флагов:"

#. type: TP
#: man-pages/man2/sigaction.2:170
#, no-wrap
msgid "B<SA_NOCLDSTOP>"
msgstr "B<SA_NOCLDSTOP>"

#. type: Plain text
#: man-pages/man2/sigaction.2:187
msgid ""
"If I<signum> is B<SIGCHLD>, do not receive notification when child processes"
" stop (i.e., when they receive one of B<SIGSTOP>, B<SIGTSTP>, B<SIGTTIN>, or"
" B<SIGTTOU>)  or resume (i.e., they receive B<SIGCONT>)  (see B<wait>(2)).  "
"This flag is meaningful only when establishing a handler for B<SIGCHLD>."
msgstr "Если значение I<signum> равно B<SIGCHLD>, то уведомление об остановке дочернего процесса (т.е., в тех случаях, когда дочерний процесс получает сигнал B<SIGSTOP>, B<SIGTSTP>, B<SIGTTIN> или B<SIGTTOU>) или возобновлении работы (т.е., когда дочерний процесс получает B<SIGCONT>) не будет получено (см. B<wait>(2)). Этот флаг имеет значение только когда установлен обработчик B<SIGCHLD>."

#. type: TP
#: man-pages/man2/sigaction.2:187
#, no-wrap
msgid "B<SA_NOCLDWAIT> (since Linux 2.6)"
msgstr "B<SA_NOCLDWAIT> (начиная с Linux 2.6)"

#.  To be precise: Linux 2.5.60 -- MTK
#. type: Plain text
#: man-pages/man2/sigaction.2:201
msgid ""
"If I<signum> is B<SIGCHLD>, do not transform children into zombies when they"
" terminate.  See also B<waitpid>(2).  This flag is meaningful only when "
"establishing a handler for B<SIGCHLD>, or when setting that signal's "
"disposition to B<SIG_DFL>."
msgstr "Если значение I<signum> равно B<SIGCHLD>, то дочерние процессы не будут переводиться в состояние зомби при завершении. Смотрите также B<waitpid>(2). Этот флаг имеет значение только когда установлен обработчик B<SIGCHLD> или когда обработчик сигнала установлен в B<SIG_DFL>."

#. type: Plain text
#: man-pages/man2/sigaction.2:213
msgid ""
"If the B<SA_NOCLDWAIT> flag is set when establishing a handler for "
"B<SIGCHLD>, POSIX.1 leaves it unspecified whether a B<SIGCHLD> signal is "
"generated when a child process terminates.  On Linux, a B<SIGCHLD> signal is"
" generated in this case; on some other implementations, it is not."
msgstr "Если флаг B<SA_NOCLDWAIT> не задан при установке обработчика B<SIGCHLD>, то по POSIX.1 остаётся неопределённым, будет ли генерироваться сигнал B<SIGCHLD> при завершении дочернего процесса. В Linux сигнал B<SIGCHLD> в этом случае генерируется; в некоторых других реализациях это не делается."

#. type: TP
#: man-pages/man2/sigaction.2:213
#, no-wrap
msgid "B<SA_NODEFER>"
msgstr "B<SA_NODEFER>"

#. type: Plain text
#: man-pages/man2/sigaction.2:220
msgid ""
"Do not prevent the signal from being received from within its own signal "
"handler.  This flag is meaningful only when establishing a signal handler.  "
"B<SA_NOMASK> is an obsolete, nonstandard synonym for this flag."
msgstr "Не препятствовать получению сигнала при его обработке обработчиком сигнала. Этот флаг имеет значение только когда установлен обработчик. Флаг B<SA_NOMASK> является устаревшим синонимом данного флага."

#. type: TP
#: man-pages/man2/sigaction.2:220
#, no-wrap
msgid "B<SA_ONSTACK>"
msgstr "B<SA_ONSTACK>"

#. type: Plain text
#: man-pages/man2/sigaction.2:226
msgid ""
"Call the signal handler on an alternate signal stack provided by "
"B<sigaltstack>(2).  If an alternate stack is not available, the default "
"stack will be used.  This flag is meaningful only when establishing a signal"
" handler."
msgstr "Вызывать обработчик сигнала в дополнительном стеке сигналов, предоставленном B<sigaltstack>(2). Если дополнительный стек недоступен, то будет использован стек по умолчанию. Этот флаг имеет значение только когда установлен обработчик."

#. type: TP
#: man-pages/man2/sigaction.2:226
#, no-wrap
msgid "B<SA_RESETHAND>"
msgstr "B<SA_RESETHAND>"

#. type: Plain text
#: man-pages/man2/sigaction.2:232
msgid ""
"Restore the signal action to the default upon entry to the signal handler.  "
"This flag is meaningful only when establishing a signal handler.  "
"B<SA_ONESHOT> is an obsolete, nonstandard synonym for this flag."
msgstr "Восстановить поведение сигнала в значение по умолчанию после входа в обработчик сигнала. Этот флаг имеет значение только когда установлен обработчик. Флаг B<SA_ONESHOT> является устаревшим синонимом данного флага."

#. type: TP
#: man-pages/man2/sigaction.2:232
#, no-wrap
msgid "B<SA_RESTART>"
msgstr "B<SA_RESTART>"

#. type: Plain text
#: man-pages/man2/sigaction.2:240
msgid ""
"Provide behavior compatible with BSD signal semantics by making certain "
"system calls restartable across signals.  This flag is meaningful only when "
"establishing a signal handler.  See B<signal>(7)  for a discussion of system"
" call restarting."
msgstr "Обеспечивать поведение совместимое с семантикой сигналов BSD, позволяя некоторым системным вызовам перезапускаться в то время, как идет обработка сигналов. Этот флаг имеет значение только когда установлен обработчик. О перезапуске системных вызовов смотрите в B<signal>(7)."

#. type: TP
#: man-pages/man2/sigaction.2:240
#, no-wrap
msgid "B<SA_SIGINFO> (since Linux 2.2)"
msgstr "B<SA_SIGINFO> (начиная с Linux 2.2)"

#.  (The
#.  .I sa_sigaction
#.  field was added in Linux 2.1.86.)
#. type: Plain text
#: man-pages/man2/sigaction.2:251
msgid ""
"The signal handler takes three arguments, not one.  In this case, "
"I<sa_sigaction> should be set instead of I<sa_handler>.  This flag is "
"meaningful only when establishing a signal handler."
msgstr "Обработчик сигнала требует трёх аргументов, а не одного. В этом случае надо использовать параметр I<sa_sigaction> вместо I<sa_handler>. Этот флаг имеет значение только когда установлен обработчик."

#. type: Plain text
#: man-pages/man2/sigaction.2:258
msgid ""
"The I<siginfo_t> argument to I<sa_sigaction> is a struct with the following "
"elements:"
msgstr "Аргумент I<siginfo_t> в I<sa_sigaction> представляет собой структуру из следующих элементов:"

#.  FIXME
#.  si_trapno seems to be only used on SPARC and Alpha;
#.  this page could use a little more detail on its purpose there.
#.  In the kernel: si_tid
#. type: Plain text
#: man-pages/man2/sigaction.2:289
#, no-wrap
msgid ""
"siginfo_t {\n"
"    int      si_signo;    /* Signal number */\n"
"    int      si_errno;    /* An errno value */\n"
"    int      si_code;     /* Signal code */\n"
"    int      si_trapno;   /* Trap number that caused\n"
"                             hardware-generated signal\n"
"                             (unused on most architectures) */\n"
"    pid_t    si_pid;      /* Sending process ID */\n"
"    uid_t    si_uid;      /* Real user ID of sending process */\n"
"    int      si_status;   /* Exit value or signal */\n"
"    clock_t  si_utime;    /* User time consumed */\n"
"    clock_t  si_stime;    /* System time consumed */\n"
"    sigval_t si_value;    /* Signal value */\n"
"    int      si_int;      /* POSIX.1b signal */\n"
"    void    *si_ptr;      /* POSIX.1b signal */\n"
"    int      si_overrun;  /* Timer overrun count; POSIX.1b timers */\n"
"    int      si_timerid;  /* Timer ID; POSIX.1b timers */\n"
"    void    *si_addr;     /* Memory location which caused fault */\n"
"    long     si_band;     /* Band event (was I<int> in\n"
"                             glibc 2.3.2 and earlier) */\n"
"    int      si_fd;       /* File descriptor */\n"
"    short    si_addr_lsb; /* Least significant bit of address\n"
"                             (since Linux 2.6.32) */\n"
"}\n"
msgstr "siginfo_t {\n    int      si_signo;    /* Номер сигнала */\n    int      si_errno;    /* Значение errno */\n    int      si_code;     /* Код сигнала */\n    int      si_trapno;   /* Номер ловушки, которую вызвал\n                             аппаратный сигнал\n                             (не используется для большинства\n                             архитектур) */\n    pid_t    si_pid;      /* Идентификатор процесса, пославшего\n                             сигнал */\n    uid_t    si_uid;      /* Реальный идентификатор пользователя\n                             процесса, пославшего сигнал */\n    int      si_status;   /* Выходное значение или номер сигнала */\n    clock_t  si_utime;    /* Использованное пользовательское время */\n    clock_t  si_stime;    /* Использованное системное время */\n    sigval_t si_value;    /* Значение сигнала */\n    int      si_int;      /* Сигнал POSIX.1b */\n    void    *si_ptr;      /* Сигнал POSIX.1b */\n    int      si_overrun;  /* Счётчик переполнения таймера; таймеры\n                             POSIX.1b */\n    int      si_timerid;  /* Идентификатор таймера; таймеры\n                             POSIX.1b */\n    void    *si_addr;     /* Адрес в памяти, приводящий к ошибке */\n    long      si_band;    /* Внутреннее событие (было I<int> в\n                             glibc 2.3.2 и более ранних */\n    int      si_fd;       /* Файловый дескриптор */\n    short    si_addr_lsb; /* Наименее значимый бит адреса\n                             (начиная с Linux 2.6.32) */\n}\n"

#. type: Plain text
#: man-pages/man2/sigaction.2:298
msgid ""
"I<si_signo>, I<si_errno> and I<si_code> are defined for all signals.  "
"(I<si_errno> is generally unused on Linux.)  The rest of the struct may be a"
" union, so that one should read only the fields that are meaningful for the "
"given signal:"
msgstr "Поля I<si_signo>, I<si_errno> и I<si_code> определены для всех сигналов. (I<si_errno> обычно не используется в Linux.) Оставшаяся часть структуры может представлять собой объединение, поэтому нужно читать только те поля, которые имеют смысл для заданного сигнала:"

#. type: Plain text
#: man-pages/man2/sigaction.2:313
msgid ""
"Signals sent with B<kill>(2)  and B<sigqueue>(3)  fill in I<si_pid> and "
"I<si_uid>.  In addition, signals sent with B<sigqueue>(3)  fill in I<si_int>"
" and I<si_ptr> with the values specified by the sender of the signal; see "
"B<sigqueue>(3)  for more details."
msgstr "Для сигналов, посылаемых B<kill>(3) и B<sigqueue>(3), заполняются I<si_pid> и I<si_uid>. Также для сигналов, посылаемых B<sigqueue>(3), заполняются I<si_int> и I<si_ptr> значениями, задаваемыми отправителем сигнала; подробней смотрите B<sigqueue>(3)."

#. type: Plain text
#: man-pages/man2/sigaction.2:329
msgid ""
"Signals sent by POSIX.1b timers (since Linux 2.6) fill in I<si_overrun> and "
"I<si_timerid>.  The I<si_timerid> field is an internal ID used by the kernel"
" to identify the timer; it is not the same as the timer ID returned by "
"B<timer_create>(2).  The I<si_overrun> field is the timer overrun count; "
"this is the same information as is obtained by a call to "
"B<timer_getoverrun>(2).  These fields are nonstandard Linux extensions."
msgstr "Для сигналов, посылаемых таймерами POSIX.1b (начиная с Linux 2.6), заполняются I<si_overrun> и I<si_timerid>. Поле I<si_timerid> является внутренним идентификатором, который используется ядром для различения таймеров; это не идентификатор таймера, возвращаемого B<timer_create>(2). Поле I<si_overrun> отражает счётчик превышения таймера; эту же информацию можно получить с помощью вызова B<timer_getoverrun>(2). Эти поля являются нестандартным расширением Linux."

#. type: Plain text
#: man-pages/man2/sigaction.2:344
msgid ""
"Signals sent for message queue notification (see the description of "
"B<SIGEV_SIGNAL> in B<mq_notify>(3))  fill in I<si_int>/I<si_ptr>, with the "
"I<sigev_value> supplied to B<mq_notify>(3); I<si_pid>, with the process ID "
"of the message sender; and I<si_uid>, with the real user ID of the message "
"sender."
msgstr "Для сигналов, посылаемых уведомлением очереди сообщений (см. описание B<SIGEV_SIGNAL> в B<mq_notify>(3)), заполняются I<si_int>/I<si_ptr>  значением I<sigev_value>, предоставляемым B<mq_notify>(3); I<si_pid> \\(em значением идентификатора процесса, отправившего сообщение; I<si_uid> \\(em значением реального идентификатора пользователя, отправившего сообщение."

#.  FIXME .
#.  When si_utime and si_stime where originally implemented, the
#.  measurement unit was HZ, which was the same as clock ticks
#.  (sysconf(_SC_CLK_TCK)).  In 2.6, HZ became configurable, and
#.  was *still* used as the unit to return the info these fields,
#.  with the result that the field values depended on the the
#.  configured HZ.  Of course, the should have been measured in
#.  USER_HZ instead, so that sysconf(_SC_CLK_TCK) could be used to
#.  convert to seconds.  I have a queued patch to fix this:
#.  http://thread.gmane.org/gmane.linux.kernel/698061/ .
#.  This patch made it into 2.6.27.
#.  But note that these fields still don't return the times of
#.  waited-for children (as is done by getrusage() and times()
#.  and wait4()).  Solaris 8 does include child times.
#. type: Plain text
#: man-pages/man2/sigaction.2:391
msgid ""
"B<SIGCHLD> fills in I<si_pid>, I<si_uid>, I<si_status>, I<si_utime>, and "
"I<si_stime>, providing information about the child.  The I<si_pid> field is "
"the process ID of the child; I<si_uid> is the child's real user ID.  The "
"I<si_status> field contains the exit status of the child (if I<si_code> is "
"B<CLD_EXITED>), or the signal number that caused the process to change "
"state.  The I<si_utime> and I<si_stime> contain the user and system CPU time"
" used by the child process; these fields do not include the times used by "
"waited-for children (unlike B<getrusage>(2)  and B<times>(2)).  In kernels "
"up to 2.6, and since 2.6.27, these fields report CPU time in units of "
"I<sysconf(_SC_CLK_TCK)>.  In 2.6 kernels before 2.6.27, a bug meant that "
"these fields reported time in units of the (configurable) system jiffy (see "
"B<time>(7))."
msgstr "Для B<SIGCHLD> заполняются I<si_pid>, I<si_uid>, I<si_status>, I<si_utime> и I<si_stime>, предоставляющие информацию о потомке. В поле I<si_pid> указывается идентификатор процесса потомка; в I<si_uid> — реальный пользовательский идентификатор потомка. В поле I<si_status> содержится код завершения потомка (если I<si_code> равно B<CLD_EXITED>) или номер сигнала, который вызвал изменение состояния процесса. Поля I<si_utime> и I<si_stime> содержат системное и пользовательское время ЦП, затраченное процессом-потомком; эти поля не содержат время, использованное на ожидание потомков (в отличие от B<getrusage>(2) и B<times>(2)). В ядрах до версии 2.6 и начиная с 2.6.27 эти поля содержат время ЦП в единицах I<sysconf(_SC_CLK_TCK)>. В ядрах 2.6 до 2.6.27 ошибочно считалось, что эти поля содержат время в единицах (настраиваемых) системных мигов (jiffy) (смотрите B<time>(7))."

#.  FIXME SIGTRAP also sets the following for ptrace_notify() ?
#.      info.si_code = exit_code;
#.      info.si_pid = task_pid_vnr(current);
#.      info.si_uid = current_uid();  /* Real UID */
#. type: Plain text
#: man-pages/man2/sigaction.2:427
msgid ""
"B<SIGILL>, B<SIGFPE>, B<SIGSEGV>, B<SIGBUS>, and B<SIGTRAP> fill in "
"I<si_addr> with the address of the fault.  On some architectures, these "
"signals also fill in the I<si_trapno> field.  Some suberrors of B<SIGBUS>, "
"in particular B<BUS_MCEERR_AO> and B<BUS_MCEERR_AR>, also fill in "
"I<si_addr_lsb>.  This field indicates the least significant bit of the "
"reported address and therefore the extent of the corruption.  For example, "
"if a full page was corrupted, I<si_addr_lsb> contains "
"I<log2(sysconf(_SC_PAGESIZE))>.  B<BUS_MCERR_*> and I<si_addr_lsb> are "
"Linux-specific extensions."
msgstr "Для B<SIGILL>, B<SIGFPE>, B<SIGSEGV>, B<SIGBUS> и B<SIGTRAP> заполняется поле I<si_addr> адресом ошибки. Для некоторых архитектур эти сигналы также заполняют поле I<si_trapno>. Некоторые отдельные варианты B<SIGBUS>, в частности B<BUS_MCEERR_AO> и B<BUS_MCEERR_AR>, также заполняют I<si_addr_lsb>. Это поле указывает наименее значимый бит сообщаемого адреса и поэтому показывает размер повреждения. Например, если была повреждена страница целиком, то I<si_addr_lsb> содержит I<log2(sysconf(_SC_PAGESIZE))>. B<BUS_MCERR_*> и I<si_addr_lsb> являются расширениями Linux."

#. type: Plain text
#: man-pages/man2/sigaction.2:441
msgid ""
"B<SIGIO>/B<SIGPOLL> (the two names are synonyms on Linux)  fills in "
"I<si_band> and I<si_fd>.  The I<si_band> event is a bit mask containing the "
"same values as are filled in the I<revents> field by B<poll>(2).  The "
"I<si_fd> field indicates the file descriptor for which the I/O event "
"occurred."
msgstr "Для B<SIGIO>/B<SIGPOLL> (синонимы в Linux) заполняются I<si_band> и I<si_fd>. Событие I<si_band> представляет собой битовую маску, содержащую те же значения, которые заполняются в поле I<revents> вызовом B<poll>(2). Поле I<si_fd> содержит файловый дескриптор, для которого произошло событие ввода-вывода."

#. type: Plain text
#: man-pages/man2/sigaction.2:448
msgid ""
"I<si_code> is a value (not a bit mask)  indicating why this signal was sent."
"  The following list shows the values which can be placed in I<si_code> for "
"any signal, along with reason that the signal was generated."
msgstr "В поле I<si_code> содержится значение (не маска битов), определяющее причину отправки сигнала. В следующей таблице приведены значения, которые могут быть в  I<si_code> для любого сигнала вместе с причиной возникновения сигнала:"

#. type: TP
#: man-pages/man2/sigaction.2:449
#, no-wrap
msgid "B<SI_USER>"
msgstr "B<SI_USER>"

#. type: TP
#: man-pages/man2/sigaction.2:452
#, no-wrap
msgid "B<SI_KERNEL>"
msgstr "B<SI_KERNEL>"

#. type: Plain text
#: man-pages/man2/sigaction.2:455
msgid "Sent by the kernel."
msgstr "посылается ядром"

#. type: TP
#: man-pages/man2/sigaction.2:455
#, no-wrap
msgid "B<SI_QUEUE>"
msgstr "B<SI_QUEUE>"

#. type: TP
#: man-pages/man2/sigaction.2:458
#, no-wrap
msgid "B<SI_TIMER>"
msgstr "B<SI_TIMER>"

#. type: Plain text
#: man-pages/man2/sigaction.2:461
msgid "POSIX timer expired"
msgstr "таймер POSIX истёк"

#. type: TP
#: man-pages/man2/sigaction.2:461
#, no-wrap
msgid "B<SI_MESGQ>"
msgstr "B<SI_MESGQ>"

#. type: Plain text
#: man-pages/man2/sigaction.2:465
msgid ""
"POSIX message queue state changed (since Linux 2.6.6); see B<mq_notify>(3)"
msgstr "изменилось состояние очереди сообщений POSIX (начиная с Linux 2.6.6); см. B<mq_notify>(3)"

#. type: TP
#: man-pages/man2/sigaction.2:465
#, no-wrap
msgid "B<SI_ASYNCIO>"
msgstr "B<SI_ASYNCIO>"

#. type: Plain text
#: man-pages/man2/sigaction.2:468
msgid "AIO completed"
msgstr "AIO завершён"

#. type: TP
#: man-pages/man2/sigaction.2:468
#, no-wrap
msgid "B<SI_SIGIO>"
msgstr "B<SI_SIGIO>"

#. type: Plain text
#: man-pages/man2/sigaction.2:477
msgid ""
"Queued B<SIGIO> (only in kernels up to Linux 2.2; from Linux 2.4 onward "
"B<SIGIO>/B<SIGPOLL> fills in I<si_code> as described below)."
msgstr "Queued B<SIGIO> (только в ядрах до Linux 2.2; начиная с Linux 2.4 B<SIGIO>/B<SIGPOLL> заполняют I<si_code> как описано выше)."

#. type: TP
#: man-pages/man2/sigaction.2:477
#, no-wrap
msgid "B<SI_TKILL>"
msgstr "B<SI_TKILL>"

#.  SI_DETHREAD is defined in 2.6.9 sources, but isn't implemented
#.  It appears to have been an idea that was tried during 2.5.6
#.  through to 2.5.24 and then was backed out.
#. type: Plain text
#: man-pages/man2/sigaction.2:486
msgid "B<tkill>(2)  or B<tgkill>(2)  (since Linux 2.4.19)"
msgstr "B<tkill>(2) или B<tgkill>(2) (начиная с Linux 2.4.19)"

#. type: Plain text
#: man-pages/man2/sigaction.2:493
msgid ""
"The following values can be placed in I<si_code> for a B<SIGILL> signal:"
msgstr "Следующие значения могут присутствовать в I<si_code> для сигнала B<SIGILL>:"

#. type: TP
#: man-pages/man2/sigaction.2:494
#, no-wrap
msgid "B<ILL_ILLOPC>"
msgstr "B<ILL_ILLOPC>"

#. type: Plain text
#: man-pages/man2/sigaction.2:497
msgid "illegal opcode"
msgstr "некорректный код инструкции"

#. type: TP
#: man-pages/man2/sigaction.2:497
#, no-wrap
msgid "B<ILL_ILLOPN>"
msgstr "B<ILL_ILLOPN>"

#. type: Plain text
#: man-pages/man2/sigaction.2:500
msgid "illegal operand"
msgstr "некорректный операнд"

#. type: TP
#: man-pages/man2/sigaction.2:500
#, no-wrap
msgid "B<ILL_ILLADR>"
msgstr "B<ILL_ILLADR>"

#. type: Plain text
#: man-pages/man2/sigaction.2:503
msgid "illegal addressing mode"
msgstr "некорректный режим адресации"

#. type: TP
#: man-pages/man2/sigaction.2:503
#, no-wrap
msgid "B<ILL_ILLTRP>"
msgstr "B<ILL_ILLTRP>"

#. type: Plain text
#: man-pages/man2/sigaction.2:506
msgid "illegal trap"
msgstr "некорректная ловушка"

#. type: TP
#: man-pages/man2/sigaction.2:506
#, no-wrap
msgid "B<ILL_PRVOPC>"
msgstr "B<ILL_PRVOPC>"

#. type: Plain text
#: man-pages/man2/sigaction.2:509
msgid "privileged opcode"
msgstr "привилегированная операция"

#. type: TP
#: man-pages/man2/sigaction.2:509
#, no-wrap
msgid "B<ILL_PRVREG>"
msgstr "B<ILL_PRVREG>"

#. type: Plain text
#: man-pages/man2/sigaction.2:512
msgid "privileged register"
msgstr "привилегированный регистр"

#. type: TP
#: man-pages/man2/sigaction.2:512
#, no-wrap
msgid "B<ILL_COPROC>"
msgstr "B<ILL_COPROC>"

#. type: Plain text
#: man-pages/man2/sigaction.2:515
msgid "coprocessor error"
msgstr "ошибка сопроцессора"

#. type: TP
#: man-pages/man2/sigaction.2:515
#, no-wrap
msgid "B<ILL_BADSTK>"
msgstr "B<ILL_BADSTK>"

#. type: Plain text
#: man-pages/man2/sigaction.2:518
msgid "internal stack error"
msgstr "внутренняя ошибка стека"

#. type: Plain text
#: man-pages/man2/sigaction.2:525
msgid ""
"The following values can be placed in I<si_code> for a B<SIGFPE> signal:"
msgstr "Следующие значения могут присутствовать в I<si_code> для сигнала B<SIGFPE>:"

#. type: TP
#: man-pages/man2/sigaction.2:526
#, no-wrap
msgid "B<FPE_INTDIV>"
msgstr "B<FPE_INTDIV>"

#. type: Plain text
#: man-pages/man2/sigaction.2:529
msgid "integer divide by zero"
msgstr "деление на ноль при работе с целыми числами"

#. type: TP
#: man-pages/man2/sigaction.2:529
#, no-wrap
msgid "B<FPE_INTOVF>"
msgstr "B<FPE_INTOVF>"

#. type: Plain text
#: man-pages/man2/sigaction.2:532
msgid "integer overflow"
msgstr "переполнение при работе с целыми числами"

#. type: TP
#: man-pages/man2/sigaction.2:532
#, no-wrap
msgid "B<FPE_FLTDIV>"
msgstr "B<FPE_FLTDIV>"

#. type: Plain text
#: man-pages/man2/sigaction.2:535
msgid "floating-point divide by zero"
msgstr "деление на ноль при работе с числами с плавающей запятой"

#. type: TP
#: man-pages/man2/sigaction.2:535
#, no-wrap
msgid "B<FPE_FLTOVF>"
msgstr "B<FPE_FLTOVF>"

#. type: Plain text
#: man-pages/man2/sigaction.2:538
msgid "floating-point overflow"
msgstr "переполнение при работе с числами с плавающей запятой"

#. type: TP
#: man-pages/man2/sigaction.2:538
#, no-wrap
msgid "B<FPE_FLTUND>"
msgstr "B<FPE_FLTUND>"

#. type: Plain text
#: man-pages/man2/sigaction.2:541
msgid "floating-point underflow"
msgstr "нехватка значения при работе с числами с плавающей запятой"

#. type: TP
#: man-pages/man2/sigaction.2:541
#, no-wrap
msgid "B<FPE_FLTRES>"
msgstr "B<FPE_FLTRES>"

#. type: Plain text
#: man-pages/man2/sigaction.2:544
msgid "floating-point inexact result"
msgstr "неточный результат при работе с числами с плавающей запятой"

#. type: TP
#: man-pages/man2/sigaction.2:544
#, no-wrap
msgid "B<FPE_FLTINV>"
msgstr "B<FPE_FLTINV>"

#. type: Plain text
#: man-pages/man2/sigaction.2:547
msgid "floating-point invalid operation"
msgstr "неправильная операция при работе с числами с плавающей запятой"

#. type: TP
#: man-pages/man2/sigaction.2:547
#, no-wrap
msgid "B<FPE_FLTSUB>"
msgstr "B<FPE_FLTSUB>"

#. type: Plain text
#: man-pages/man2/sigaction.2:550
msgid "subscript out of range"
msgstr "индекс вне разрешенных пределов при работе с числами с плавающей запятой"

#. type: Plain text
#: man-pages/man2/sigaction.2:557
msgid ""
"The following values can be placed in I<si_code> for a B<SIGSEGV> signal:"
msgstr "Следующие значения могут присутствовать в I<si_code> для сигнала B<SIGSEGV>:"

#. type: TP
#: man-pages/man2/sigaction.2:558
#, no-wrap
msgid "B<SEGV_MAPERR>"
msgstr "B<SEGV_MAPERR>"

#. type: Plain text
#: man-pages/man2/sigaction.2:561
msgid "address not mapped to object"
msgstr "адрес не соответствует объекту"

#. type: TP
#: man-pages/man2/sigaction.2:561
#, no-wrap
msgid "B<SEGV_ACCERR>"
msgstr "B<SEGV_ACCERR>"

#. type: Plain text
#: man-pages/man2/sigaction.2:564
msgid "invalid permissions for mapped object"
msgstr "некорректные права на отображённый объект"

#. type: Plain text
#: man-pages/man2/sigaction.2:571
msgid ""
"The following values can be placed in I<si_code> for a B<SIGBUS> signal:"
msgstr "Следующие значения могут присутствовать в I<si_code> для сигнала B<SIGBUS>:"

#. type: TP
#: man-pages/man2/sigaction.2:572
#, no-wrap
msgid "B<BUS_ADRALN>"
msgstr "B<BUS_ADRALN>"

#. type: Plain text
#: man-pages/man2/sigaction.2:575
msgid "invalid address alignment"
msgstr "некорректное выравнивание адреса"

#. type: TP
#: man-pages/man2/sigaction.2:575
#, no-wrap
msgid "B<BUS_ADRERR>"
msgstr "B<BUS_ADRERR>"

#. type: Plain text
#: man-pages/man2/sigaction.2:578
msgid "nonexistent physical address"
msgstr "несуществующий физический адрес"

#. type: TP
#: man-pages/man2/sigaction.2:578
#, no-wrap
msgid "B<BUS_OBJERR>"
msgstr "B<BUS_OBJERR>"

#. type: Plain text
#: man-pages/man2/sigaction.2:581
msgid "object-specific hardware error"
msgstr "аппаратная ошибка, специфичная для объекта"

#. type: TP
#: man-pages/man2/sigaction.2:581
#, no-wrap
msgid "B<BUS_MCEERR_AR> (since Linux 2.6.32)"
msgstr "B<BUS_MCEERR_AR> (начиная с Linux 2.6.32)"

#. type: Plain text
#: man-pages/man2/sigaction.2:584
msgid "Hardware memory error consumed on a machine check; action required."
msgstr "машинной проверкой устранена аппаратная ошибка памяти; требуется действие"

#. type: TP
#: man-pages/man2/sigaction.2:584
#, no-wrap
msgid "B<BUS_MCEERR_AO> (since Linux 2.6.32)"
msgstr "B<BUS_MCEERR_AO> (начиная с Linux 2.6.32)"

#. type: Plain text
#: man-pages/man2/sigaction.2:587
msgid ""
"Hardware memory error detected in process but not consumed; action optional."
msgstr "в процессе обнаружена аппаратная ошибка памяти, но не устранена; действие не обязательно"

#. type: Plain text
#: man-pages/man2/sigaction.2:594
msgid ""
"The following values can be placed in I<si_code> for a B<SIGTRAP> signal:"
msgstr "Следующие значения могут присутствовать в I<si_code> для сигнала B<SIGTRAP>:"

#. type: TP
#: man-pages/man2/sigaction.2:595
#, no-wrap
msgid "B<TRAP_BRKPT>"
msgstr "B<TRAP_BRKPT>"

#. type: Plain text
#: man-pages/man2/sigaction.2:598
msgid "process breakpoint"
msgstr "точка останова процесса"

#. type: TP
#: man-pages/man2/sigaction.2:598
#, no-wrap
msgid "B<TRAP_TRACE>"
msgstr "B<TRAP_TRACE>"

#. type: Plain text
#: man-pages/man2/sigaction.2:601
msgid "process trace trap"
msgstr "ловушка отладки процесса"

#. type: TP
#: man-pages/man2/sigaction.2:601
#, no-wrap
msgid "B<TRAP_BRANCH> (since Linux 2.4)"
msgstr "B<TRAP_BRANCH> (начиная с Linux 2.4)"

#. type: Plain text
#: man-pages/man2/sigaction.2:604
msgid "process taken branch trap"
msgstr "процесс пойман в ветвь ловушки"

#. type: TP
#: man-pages/man2/sigaction.2:604
#, no-wrap
msgid "B<TRAP_HWBKPT> (since Linux 2.4)"
msgstr "B<TRAP_HWBKPT> (начиная с Linux 2.4)"

#. type: Plain text
#: man-pages/man2/sigaction.2:607
msgid "hardware breakpoint/watchpoint"
msgstr "аппаратная точка прерывания/слежения"

#. type: Plain text
#: man-pages/man2/sigaction.2:614
msgid ""
"The following values can be placed in I<si_code> for a B<SIGCHLD> signal:"
msgstr "Следующие значения могут присутствовать в I<si_code> для сигнала B<SIGCHLD>:"

#. type: TP
#: man-pages/man2/sigaction.2:615
#, no-wrap
msgid "B<CLD_EXITED>"
msgstr "B<CLD_EXITED>"

#. type: Plain text
#: man-pages/man2/sigaction.2:618
msgid "child has exited"
msgstr "дочерний процесс завершил работу"

#. type: TP
#: man-pages/man2/sigaction.2:618
#, no-wrap
msgid "B<CLD_KILLED>"
msgstr "B<CLD_KILLED>"

#. type: Plain text
#: man-pages/man2/sigaction.2:621
msgid "child was killed"
msgstr "работа дочернего процесса была прервана (killed)"

#. type: TP
#: man-pages/man2/sigaction.2:621
#, no-wrap
msgid "B<CLD_DUMPED>"
msgstr "B<CLD_DUMPED>"

#. type: Plain text
#: man-pages/man2/sigaction.2:624
msgid "child terminated abnormally"
msgstr "дочерний процесс завершился некорректно"

#. type: TP
#: man-pages/man2/sigaction.2:624
#, no-wrap
msgid "B<CLD_TRAPPED>"
msgstr "B<CLD_TRAPPED>"

#. type: Plain text
#: man-pages/man2/sigaction.2:627
msgid "traced child has trapped"
msgstr "сработала ловушка в отлаживаемом дочернем процессе"

#. type: TP
#: man-pages/man2/sigaction.2:627
#, no-wrap
msgid "B<CLD_STOPPED>"
msgstr "B<CLD_STOPPED>"

#. type: Plain text
#: man-pages/man2/sigaction.2:630
msgid "child has stopped"
msgstr "дочерний процесс остановлен"

#. type: TP
#: man-pages/man2/sigaction.2:630
#, no-wrap
msgid "B<CLD_CONTINUED>"
msgstr "B<CLD_CONTINUED>"

#. type: Plain text
#: man-pages/man2/sigaction.2:633
msgid "stopped child has continued (since Linux 2.6.9)"
msgstr "остановленный дочерний процесс продолжил работу (начиная с Linux 2.6.9)"

#. type: Plain text
#: man-pages/man2/sigaction.2:640
msgid ""
"The following values can be placed in I<si_code> for a B<SIGIO>/B<SIGPOLL> "
"signal:"
msgstr "Следующие значения могут присутствовать в I<si_code> для сигнала B<SIGIO>/B<SIGPOLL>:"

#. type: TP
#: man-pages/man2/sigaction.2:641
#, no-wrap
msgid "B<POLL_IN>"
msgstr "B<POLL_IN>"

#. type: Plain text
#: man-pages/man2/sigaction.2:644
msgid "data input available"
msgstr "есть входные данные"

#. type: TP
#: man-pages/man2/sigaction.2:644
#, no-wrap
msgid "B<POLL_OUT>"
msgstr "B<POLL_OUT>"

#. type: Plain text
#: man-pages/man2/sigaction.2:647
msgid "output buffers available"
msgstr "освободились выходные буферы"

#. type: TP
#: man-pages/man2/sigaction.2:647
#, no-wrap
msgid "B<POLL_MSG>"
msgstr "B<POLL_MSG>"

#. type: Plain text
#: man-pages/man2/sigaction.2:650
msgid "input message available"
msgstr "есть входное сообщение"

#. type: TP
#: man-pages/man2/sigaction.2:650
#, no-wrap
msgid "B<POLL_ERR>"
msgstr "B<POLL_ERR>"

#. type: Plain text
#: man-pages/man2/sigaction.2:653
msgid "I/O error"
msgstr "ошибка ввода-вывода"

#. type: TP
#: man-pages/man2/sigaction.2:653
#, no-wrap
msgid "B<POLL_PRI>"
msgstr "B<POLL_PRI>"

#. type: Plain text
#: man-pages/man2/sigaction.2:656
msgid "high priority input available"
msgstr "есть входные данные высокого приоритета"

#. type: TP
#: man-pages/man2/sigaction.2:656
#, no-wrap
msgid "B<POLL_HUP>"
msgstr "B<POLL_HUP>"

#. type: Plain text
#: man-pages/man2/sigaction.2:659
msgid "device disconnected"
msgstr "устройство отключено"

#. type: Plain text
#: man-pages/man2/sigaction.2:665
msgid ""
"B<sigaction>()  returns 0 on success; on error, -1 is returned, and I<errno>"
" is set to indicate the error."
msgstr "При успешном выполнении B<sigaction>() возвращается 0; при ошибке возвращается -1, а в I<errno> содержится код ошибки."

#. type: Plain text
#: man-pages/man2/sigaction.2:670
msgid ""
"I<act> or I<oldact> points to memory which is not a valid part of the "
"process address space."
msgstr "I<act> или I<oldact> указывают на память, которая не является частью адресного пространства процесса."

#. type: Plain text
#: man-pages/man2/sigaction.2:677
msgid ""
"An invalid signal was specified.  This will also be generated if an attempt "
"is made to change the action for B<SIGKILL> or B<SIGSTOP>, which cannot be "
"caught or ignored."
msgstr "Указан некорректный сигнал. Также ошибка будет сгенерирована, если произведена попытка изменить действие для сигналов B<SIGKILL> или B<SIGSTOP>, которые не могут быть перехвачены или игнорированы."

#.  SVr4 does not document the EINTR condition.
#. type: Plain text
#: man-pages/man2/sigaction.2:680
msgid "POSIX.1-2001, SVr4."
msgstr "POSIX.1-2001, SVr4."

#. type: Plain text
#: man-pages/man2/sigaction.2:706
msgid ""
"According to POSIX, the behavior of a process is undefined after it ignores "
"a B<SIGFPE>, B<SIGILL>, or B<SIGSEGV> signal that was not generated by "
"B<kill>(2)  or B<raise>(3).  Integer division by zero has undefined result."
"  On some architectures it will generate a B<SIGFPE> signal.  (Also dividing"
" the most negative integer by -1 may generate B<SIGFPE>.)  Ignoring this "
"signal might lead to an endless loop."
msgstr "В соответствии с POSIX поведение процесса после игнорирования сигнала B<SIGFPE>, B<SIGILL> или B<SIGSEGV> не определено, если эти сигналы не были посланы при помощи функций B<kill>(2) или B<raise>(3). Деление целого числа на ноль имеет непредсказуемый результат. В некоторых архитектурах это приводит к появлению сигнала B<SIGFPE>. (Также, деление самого большого по модулю отрицательного числа на -1 тоже может приводить к B<SIGFPE>.) Игнорирование этого сигнала может привести к появлению бесконечного цикла."

#. type: Plain text
#: man-pages/man2/sigaction.2:723
msgid ""
"POSIX.1-1990 disallowed setting the action for B<SIGCHLD> to B<SIG_IGN>.  "
"POSIX.1-2001 allows this possibility, so that ignoring B<SIGCHLD> can be "
"used to prevent the creation of zombies (see B<wait>(2)).  Nevertheless, the"
" historical BSD and System\\ V behaviors for ignoring B<SIGCHLD> differ, so "
"that the only completely portable method of ensuring that terminated "
"children do not become zombies is to catch the B<SIGCHLD> signal and perform"
" a B<wait>(2)  or similar."
msgstr "POSIX.1-1990 запрещает установку действия для сигнала B<SIGCHLD> в B<SIG_IGN>. POSIX.1-2001 допускает такую возможность, поэтому игнорирование B<SIGCHLD> можно использовать для недопущения создания зомби (см. B<wait>(2)). Тем не менее, поведение BSD и System\\ V по игнорированию B<SIGCHLD> различается, поэтому есть только один переносимый способ убедиться, что завершившийся потомок не стал зомби — поймать сигнал B<SIGCHLD> и выполнить B<wait>(2) или подобный вызов."

#. type: Plain text
#: man-pages/man2/sigaction.2:736
msgid ""
"POSIX.1-1990 specified only B<SA_NOCLDSTOP>.  POSIX.1-2001 added "
"B<SA_NOCLDWAIT>, B<SA_RESETHAND>, B<SA_NODEFER>, and B<SA_SIGINFO>.  Use of "
"these latter values in I<sa_flags> may be less portable in applications "
"intended for older UNIX implementations."
msgstr "В POSIX.1-1990 указан только B<SA_NOCLDSTOP>. В POSIX.1-2001 добавлены B<SA_NOCLDWAIT>, B<SA_RESETHAND>, B<SA_NODEFER> и B<SA_SIGINFO>. Использование в приложениях последних значений в I<sa_flags> может оказаться менее переносимо на старые реализации UNIX."

#. type: Plain text
#: man-pages/man2/sigaction.2:740
msgid ""
"The B<SA_RESETHAND> flag is compatible with the SVr4 flag of the same name."
msgstr "Флаг B<SA_RESETHAND> совместим с одноимённым флагом из SVr4."

#. type: Plain text
#: man-pages/man2/sigaction.2:750
msgid ""
"The B<SA_NODEFER> flag is compatible with the SVr4 flag of the same name "
"under kernels 1.3.9 and newer.  On older kernels the Linux implementation "
"allowed the receipt of any signal, not just the one we are installing "
"(effectively overriding any I<sa_mask> settings)."
msgstr "Флаг B<SA_NODEFER> совместим с одноименным флагом SVr4 в ядре версии 1.3.9 и более поздних. В старых выпусках ядра Linux позволяли принимать и обрабатывать любые сигналы, а не только те, обработка которых уже задана (на деле это приводит к игнорированию установок I<sa_mask>)."

#. type: Plain text
#: man-pages/man2/sigaction.2:756
msgid ""
"B<sigaction>()  can be called with a NULL second argument to query the "
"current signal handler.  It can also be used to check whether a given signal"
" is valid for the current machine by calling it with NULL second and third "
"arguments."
msgstr "Для получения адреса текущего обработчика сигнала можно использовать вызов B<sigaction>(), указав NULL в качестве значения второго аргумента. Этот вызов можно также использовать для проверки доступности этого типа сигнала в конкретной системе, вызвав его с вторым и третьим аргументами, равными NULL."

#. type: Plain text
#: man-pages/man2/sigaction.2:762
msgid ""
"It is not possible to block B<SIGKILL> or B<SIGSTOP> (by specifying them in "
"I<sa_mask>).  Attempts to do so are silently ignored."
msgstr "Невозможно заблокировать сигналы B<SIGKILL> или B<SIGSTOP> (указав их в I<sa_mask>). Попытки это сделать будут просто игнорироваться."

#. type: Plain text
#: man-pages/man2/sigaction.2:771
msgid ""
"See B<signal>(7)  for a list of the async-signal-safe functions that can be "
"safely called inside from inside a signal handler."
msgstr "Список функций безопасных асинхронных сигналов, которые можно не опасаясь вызывать из обработчика сигналов, смотрите в B<signal>(7)."

#. type: SS
#: man-pages/man2/sigaction.2:771
#, no-wrap
msgid "Undocumented"
msgstr "Недокументированное"

#. type: Plain text
#: man-pages/man2/sigaction.2:781
msgid ""
"Before the introduction of B<SA_SIGINFO> it was also possible to get some "
"additional information, namely by using a I<sa_handler> with second argument"
" of type I<struct sigcontext>.  See the relevant Linux kernel sources for "
"details.  This use is obsolete now."
msgstr "До появления B<SA_SIGINFO> существовала возможность получить дополнительную информацию, используя I<sa_handler> со вторым параметром типа I<struct sigcontext>. См. соответствующий исходный код ядра Linux. В настоящее время этот механизм устарел."

#. type: Plain text
#: man-pages/man2/sigaction.2:790
msgid ""
"In kernels up to and including 2.6.13, specifying B<SA_NODEFER> in "
"I<sa_flags> prevents not only the delivered signal from being masked during "
"execution of the handler, but also the signals specified in I<sa_mask>.  "
"This bug was fixed in kernel 2.6.14."
msgstr "В ядрах по версию 2.6.13 включительно, указание B<SA_NODEFER> в I<sa_flags> предотвращает доставку сигнала  не только из маскируемого при выполнении обработчика, но также сигналов, указанных в I<sa_mask>. Этот дефект исправлен в ядре 2.6.14."

#. type: Plain text
#: man-pages/man2/sigaction.2:793
msgid "See B<mprotect>(2)."
msgstr "Смотрите в B<mprotect>(2)."

#. type: Plain text
#: man-pages/man2/sigaction.2:812
msgid ""
"B<kill>(1), B<kill>(2), B<killpg>(2), B<pause>(2), B<restart_syscall>(2), "
"B<sigaltstack>(2), B<signal>(2), B<signalfd>(2), B<sigpending>(2), "
"B<sigprocmask>(2), B<sigsuspend>(2), B<wait>(2), B<raise>(3), "
"B<siginterrupt>(3), B<sigqueue>(3), B<sigsetops>(3), B<sigvec>(3), "
"B<core>(5), B<signal>(7)"
msgstr "B<kill>(1), B<kill>(2), B<killpg>(2), B<pause>(2), B<restart_syscall>(2), B<sigaltstack>(2), B<signal>(2), B<signalfd>(2), B<sigpending>(2), B<sigprocmask>(2), B<sigsuspend>(2), B<wait>(2), B<raise>(3), B<siginterrupt>(3), B<sigqueue>(3), B<sigsetops>(3), B<sigvec>(3), B<core>(5), B<signal>(7)"

#. type: TH
#: man-pages/man2/syscalls.2:31
#, no-wrap
msgid "SYSCALLS"
msgstr "SYSCALLS"

#. type: Plain text
#: man-pages/man2/syscalls.2:34
msgid "syscalls - Linux system calls"
msgstr "syscalls - системные вызовы Linux"

#. type: Plain text
#: man-pages/man2/syscalls.2:36
msgid "Linux system calls."
msgstr "Системные вызовы Linux."

#. type: Plain text
#: man-pages/man2/syscalls.2:39
msgid ""
"The system call is the fundamental interface between an application and the "
"Linux kernel."
msgstr "Системный вызов \\(em это основной интерфейс между приложением и ядром Linux."

#. type: SS
#: man-pages/man2/syscalls.2:39
#, no-wrap
msgid "System calls and library wrapper functions"
msgstr "Системные вызовы и обёрточные библиотечные функции"

#. type: Plain text
#: man-pages/man2/syscalls.2:49
msgid ""
"System calls are generally not invoked directly, but rather via wrapper "
"functions in glibc (or perhaps some other library).  For details of direct "
"invocation of a system call, see B<intro>(2).  Often, but not always, the "
"name of the wrapper function is the same as the name of the system call that"
" it invokes.  For example, glibc contains a function B<truncate>()  which "
"invokes the underlying \"truncate\" system call."
msgstr "Обычно, системные вызовы не вызываются напрямую, это делается через обёрточную функцию из glibc (или другой библиотеки). Подробней о непосредственном вызове системного вызова, см. B<intro>(2). Часто, но не всегда, имя обёрточной функции совпадает с именем системного вызова, который она осуществляет. Например, в glibc есть функция B<truncate>(), которая осуществляет делающий всё работу системный вызов \"truncate\"."

#. type: Plain text
#: man-pages/man2/syscalls.2:67
msgid ""
"Often the glibc wrapper function is quite thin, doing little work other than"
" copying arguments to the right registers before invoking the system call, "
"and then setting I<errno> appropriately after the system call has returned."
"  (These are the same steps that are performed by B<syscall>(2), which can "
"be used to invoke system calls for which no wrapper function is provided.)  "
"Note: system calls indicate a failure by returning a negative error number "
"to the caller; when this happens, the wrapper function negates the returned "
"error number (to make it positive), copies it to I<errno>, and returns -1 to"
" the caller of the wrapper."
msgstr "Часто, обёрточная функция glibc очень маленькая, она просто копирует аргументы в нужные регистры перед запуском системного вызова, а затем присваивает переменной I<errno> значение, которое было возвращено системным вызовом. (Эти те же шаги выполняет B<syscall>(2), её можно использовать для осуществления системных вызовов, для которых нет обёрточных функций.) Замечание: системные вызовы указывают, что произошла ошибка возвращая отрицательное целое число вызывающей стороне; когда это происходит, обёрточная функция меняет знак у возвращённого значения (на положительный), копирует его в I<errno> и возвращает -1 вызвавшей обёртку функции."

#. type: Plain text
#: man-pages/man2/syscalls.2:79
msgid ""
"Sometimes, however, the wrapper function does some extra work before "
"invoking the system call.  For example, nowadays there are (for reasons "
"described below) two related system calls, B<truncate>(2)  and "
"B<truncate64>(2), and the glibc B<truncate>()  wrapper function checks which"
" of those system calls are provided by the kernel and determines which "
"should be employed."
msgstr "Иногда, однако, обёрточная функция производит дополнительную работу до осуществления системного вызова. Например, в настоящее время существует (по причинам, описанным далее) два похожих системных вызова \\(em B<truncate>(2) и B<truncate64>(2); обёрточная функция glibc B<truncate>() проверяет какой из системных вызовов предоставляет ядро и решает какой нужно задействовать."

#. type: SS
#: man-pages/man2/syscalls.2:79
#, no-wrap
msgid "System call list"
msgstr "Список системных вызовов"

#. type: Plain text
#: man-pages/man2/syscalls.2:87
msgid ""
"Below is a list of the Linux system calls.  In the list, the I<Kernel> "
"column indicates the kernel version for those system calls that were new in "
"Linux 2.2, or have appeared since that kernel version.  Note the following "
"points:"
msgstr "Далее приведён список список системных вызовов Linux. В колонке I<Ядро> указана версия ядра для системных вызовов, которые появились в Linux 2.2, и с какой именно версии. Также заметим следующее:"

#. type: Plain text
#: man-pages/man2/syscalls.2:90
msgid ""
"Where no kernel version is indicated, the system call appeared in kernel 1.0"
" or earlier."
msgstr "Если версия ядра не указана, то системный вызов появился в ядре 1.0 или более раннем."

#. type: Plain text
#: man-pages/man2/syscalls.2:96
msgid ""
"Where a system call is marked \"1.2\" this means the system call probably "
"appeared in a 1.1.x kernel version, and first appeared in a stable kernel "
"with 1.2.  (Development of the 1.2 kernel was initiated from a branch of "
"kernel 1.0.6 via the 1.1.x unstable kernel series.)"
msgstr "Системные вызовы, помеченные \"1.2\", скорее всего появились в в версиях ядра 1.1.x, и впервые появились в стабильном ядре 1.2. (Разработка ядра 1.2 началась с ответвления от ядра 1.0.6 и прошла несколько выпусков ядер 1.1.x.)"

#.  Was kernel 2.0 started from a branch of 1.2.10?
#.  At least from the timestamps of the tarballs of
#.  of 1.2.10 and 1.3.0, that's how it looks, but in
#.  fact the diff doesn't seem very clear, the
#.  1.3.0 .tar.bz is much bigger (2.0 MB) than the
#.  1.2.10 .tar.bz2 (1.8 MB), and AEB points out the
#.  timestamps of some files in 1.3.0 seem to be older
#.  than those in 1.2.10.  All of this suggests
#.  that there might not have been a clean branch point.
#. type: Plain text
#: man-pages/man2/syscalls.2:112
msgid ""
"Where a system call is marked \"2.0\" this means the system call probably "
"appeared in a 1.3.x kernel version, and first appeared in a stable kernel "
"with 2.0.  (Development of the 2.0 kernel was initiated from a branch of "
"kernel 1.2.x, somewhere around 1.2.10, via the 1.3.x unstable kernel "
"series.)"
msgstr "Системные вызовы, помеченные \"1.2\", скорее всего появились в в версиях ядра 1.3.x, и впервые появились в стабильном ядре 2.0. (Разработка ядра 2.0 началась с ответвления от ядра 1.2.x, начиная, приблизительно, с 1.2.10, и прошла несколько выпусков ядер 1.3.x.)"

#. type: Plain text
#: man-pages/man2/syscalls.2:118
msgid ""
"Where a system call is marked \"2.2\" this means the system call probably "
"appeared in a 2.1.x kernel version, and first appeared in a stable kernel "
"with 2.2.0.  (Development of the 2.2 kernel was initiated from a branch of "
"kernel 2.0.21 via the 2.1.x unstable kernel series.)"
msgstr "Системные вызовы, помеченные \"2.2\", скорее всего появились в в версиях ядра 2.1.x, и впервые появились в стабильном ядре 2.2.0. (Разработка ядра 2.2 началась с ответвления от ядра 2.0.21, и прошла несколько выпусков ядер 2.1.x.)"

#. type: Plain text
#: man-pages/man2/syscalls.2:124
msgid ""
"Where a system call is marked \"2.4\" this means the system call probably "
"appeared in a 2.3.x kernel version, and first appeared in a stable kernel "
"with 2.4.0.  (Development of the 2.4 kernel was initiated from a branch of "
"kernel 2.2.8 via the 2.3.x unstable kernel series.)"
msgstr "Системные вызовы, помеченные \"2.4\", скорее всего появились в в версиях ядра 2.3.x, и впервые появились в стабильном ядре 2.4.0. (Разработка ядра 2.4 началась с ответвления от ядра 2.2.8, и прошла несколько выпусков ядер 2.3.x.)"

#. type: Plain text
#: man-pages/man2/syscalls.2:130
msgid ""
"Where a system call is marked \"2.6\" this means the system call probably "
"appeared in a 2.5.x kernel version, and first appeared in a stable kernel "
"with 2.6.0.  (Development of kernel 2.6 was initiated from a branch of "
"kernel 2.4.15 via the 2.5.x unstable kernel series.)"
msgstr "Системные вызовы, помеченные \"2.6\", скорее всего появились в в версиях ядра 2.5.x, и впервые появились в стабильном ядре 2.6.0. (Разработка ядра 2.6 началась с ответвления от ядра 2.4.15, и прошла несколько выпусков ядер 2.5.x.)"

#. type: Plain text
#: man-pages/man2/syscalls.2:137
msgid ""
"Starting with kernel 2.6.0, the development model changed, and new system "
"calls may appear in each 2.6.x release.  In this case, the exact version "
"number where the system call appeared is shown.  This convention continues "
"with the 3.x kernel series, which followed on from kernel 2.6.39."
msgstr "Начиная с ядра 2.6.0 порядок разработки был изменён, и новые системные вызовы могут появляться в каждом выпуске 2.6.x. В этом случае для системного вызова указан точный номер версии. 2.6.39. Это соглашение продолжает действовать и в ядрах серии 3.x, которая началась после ядра версии 2.6.39."

#. type: Plain text
#: man-pages/man2/syscalls.2:145
msgid ""
"In some cases, a system call was added to a stable kernel series after it "
"branched from the previous stable kernel series, and then backported into "
"the earlier stable kernel series.  For example some system calls that "
"appeared in 2.6.x were also backported into a 2.4.x release after 2.4.15.  "
"When this is so, the version where the system call appeared in both of the "
"major kernel series is listed."
msgstr "Иногда системный вызов, добавленный в текущую на тот момент стабильную ветвь ядра, переносился в предыдущие стабильные ветви ядра. Например, некоторые системные вызовы, которые появились в в 2.6.x были перенесены и в выпуски 2.4.x, начиная с 2.4.15. Если это производилось, будут показаны основные версии обеих ветвей ядра."

#.  Looking at scripts/checksyscalls.sh in the kernel source is
#.  instructive about x86 specifics.
#. type: Plain text
#: man-pages/man2/syscalls.2:152
msgid ""
"The list of system calls that are available as at kernel 3.15 (or in a few "
"cases only on older kernels) is as follows:"
msgstr "Список системных вызовов, доступных в ядре версии 3.15 (или, в некоторых случаях, только в более старых ядрах):"

#. type: tbl table
#: man-pages/man2/syscalls.2:157
#, no-wrap
msgid "B<System call>\tB<Kernel>\tB<Notes>\n"
msgstr "B<Системный вызов>\tB<Ядро>\tB<Примечания>\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:159
#, no-wrap
msgid "B<_llseek>(2)\t1.2\n"
msgstr "B<_llseek>(2)\t1.2\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:160
#, no-wrap
msgid "B<_newselect>(2)\t2.0\n"
msgstr "B<_newselect>(2)\t2.0\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:161
#, no-wrap
msgid "B<_sysctl>(2)\t2.0\n"
msgstr "B<_sysctl>(2)\t2.0\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:162
#, no-wrap
msgid "B<accept>(2)\t2.0\tSee notes on B<socketcall>(2)\n"
msgstr "B<accept>(2)\t2.0\tсмотрите замечания по B<socketcall>(2)\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:163
#, no-wrap
msgid "B<accept4>(2)\t2.6.28\n"
msgstr "B<accept4>(2)\t2.6.28\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:164
#, no-wrap
msgid "B<access>(2)\t1.0\n"
msgstr "B<access>(2)\t1.0\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:165
#, no-wrap
msgid "B<acct>(2)\t1.0\n"
msgstr "B<acct>(2)\t1.0\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:166
#, no-wrap
msgid "B<add_key>(2)\t2.6.11\n"
msgstr "B<add_key>(2)\t2.6.11\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:167
#, no-wrap
msgid "B<adjtimex>(2)\t1.0\n"
msgstr "B<adjtimex>(2)\t1.0\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:168
#, no-wrap
msgid "B<alarm>(2)\t1.0\n"
msgstr "B<alarm>(2)\t1.0\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:169
#, no-wrap
msgid "B<alloc_hugepages>(2)\t2.5.36\tRemoved in 2.5.44\n"
msgstr "B<alloc_hugepages>(2)\t2.5.36\tудалён в 2.5.44\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:170
#, no-wrap
msgid "B<bdflush>(2)\t1.2\tT{\n"
msgstr "B<bdflush>(2)\t1.2\tT{\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:171
#, no-wrap
msgid "Deprecated (does nothing)\n"
msgstr "устарел (ничего не делает)\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:173
#, no-wrap
msgid "since 2.6\n"
msgstr "начиная с 2.6\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:175
#, no-wrap
msgid "B<bind>(2)\t2.0\tSee notes on B<socketcall>(2)\n"
msgstr "B<bind>(2)\t2.0\tсмотрите замечания по B<socketcall>(2)\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:176
#, no-wrap
msgid "B<brk>(2)\t1.0\n"
msgstr "B<brk>(2)\t1.0\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:177
#, no-wrap
msgid "B<cacheflush>(2)\t1.2\tNot on x86\n"
msgstr "B<cacheflush>(2)\t1.2\tне для x86\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:178
#, no-wrap
msgid "B<capget>(2)\t2.2\n"
msgstr "B<capget>(2)\t2.2\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:179
#, no-wrap
msgid "B<capset>(2)\t2.2\n"
msgstr "B<capset>(2)\t2.2\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:180
#, no-wrap
msgid "B<chdir>(2)\t1.0\n"
msgstr "B<chdir>(2)\t1.0\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:181
#, no-wrap
msgid "B<chmod>(2)\t1.0\n"
msgstr "B<chmod>(2)\t1.0\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:182
#, no-wrap
msgid "B<chown>(2)\t2.2\tT{\n"
msgstr "B<chown>(2)\t2.2\tT{\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:183 man-pages/man2/syscalls.2:315
#, no-wrap
msgid "See B<chown>(2) for\n"
msgstr "Смотрите в B<chown>(2)\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:185 man-pages/man2/syscalls.2:317
#, no-wrap
msgid "version details\n"
msgstr "подробности по версии\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:187
#, no-wrap
msgid "B<chown32>(2)\t2.4\n"
msgstr "B<chown32>(2)\t2.4\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:188
#, no-wrap
msgid "B<chroot>(2)\t1.0\n"
msgstr "B<chroot>(2)\t1.0\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:189
#, no-wrap
msgid "B<clock_adjtime>(2)\t2.6.39\n"
msgstr "B<clock_adjtime>(2)\t2.6.39\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:190
#, no-wrap
msgid "B<clock_getres>(2)\t2.6\n"
msgstr "B<clock_getres>(2)\t2.6\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:191
#, no-wrap
msgid "B<clock_gettime>(2)\t2.6\n"
msgstr "B<clock_gettime>(2)\t2.6\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:192
#, no-wrap
msgid "B<clock_nanosleep>(2)\t2.6\n"
msgstr "B<clock_nanosleep>(2)\t2.6\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:193
#, no-wrap
msgid "B<clock_settime>(2)\t2.6\n"
msgstr "B<clock_settime>(2)\t2.6\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:194
#, no-wrap
msgid "B<clone>(2)\t1.0\n"
msgstr "B<clone>(2)\t1.0\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:195
#, no-wrap
msgid "B<close>(2)\t1.0\n"
msgstr "B<close>(2)\t1.0\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:196
#, no-wrap
msgid "B<connect>(2)\t2.0\tSee notes on B<socketcall>(2)\n"
msgstr "B<connect>(2)\t2.0\t0\tсмотрите замечания по B<socketcall>(2)\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:197
#, no-wrap
msgid "B<creat>(2)\t1.0\n"
msgstr "B<creat>(2)\t1.0\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:198
#, no-wrap
msgid "B<create_module>(2)\t\tRemoved in 2.6\n"
msgstr "B<create_module>(2)\t\tудалён в 2.6\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:199
#, no-wrap
msgid "B<delete_module>(2)\t1.0\n"
msgstr "B<delete_module>(2)\t1.0\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:200
#, no-wrap
msgid "B<dup>(2)\t1.0\n"
msgstr "B<dup>(2)\t1.0\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:201
#, no-wrap
msgid "B<dup2>(2)\t1.0\n"
msgstr "B<dup2>(2)\t1.0\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:202
#, no-wrap
msgid "B<dup3>(2)\t2.6.27\n"
msgstr "B<dup3>(2)\t2.6.27\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:203
#, no-wrap
msgid "B<epoll_create>(2)\t2.6\n"
msgstr "B<epoll_create>(2)\t2.6\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:204
#, no-wrap
msgid "B<epoll_create1>(2)\t2.6.27\n"
msgstr "B<epoll_create1>(2)\t2.6.27\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:205
#, no-wrap
msgid "B<epoll_ctl>(2)\t2.6\n"
msgstr "B<epoll_ctl>(2)\t2.6\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:206
#, no-wrap
msgid "B<epoll_pwait>(2)\t2.6.19\n"
msgstr "B<epoll_pwait>(2)\t2.6.19\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:207
#, no-wrap
msgid "B<epoll_wait>(2)\t2.6\n"
msgstr "B<epoll_wait>(2)\t2.6\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:208
#, no-wrap
msgid "B<eventfd>(2)\t2.6.22\n"
msgstr "B<eventfd>(2)\t2.6.22\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:209
#, no-wrap
msgid "B<eventfd2>(2)\t2.6.27\n"
msgstr "B<eventfd2>(2)\t2.6.27\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:210
#, no-wrap
msgid "B<execve>(2)\t1.0\n"
msgstr "B<execve>(2)\t1.0\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:211
#, no-wrap
msgid "B<exit>(2)\t1.0\n"
msgstr "B<exit>(2)\t1.0\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:212
#, no-wrap
msgid "B<exit_group>(2)\t2.6\n"
msgstr "B<exit_group>(2)\t2.6\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:213
#, no-wrap
msgid "B<faccessat>(2)\t2.6.16\n"
msgstr "B<faccessat>(2)\t2.6.16\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:214
#, no-wrap
msgid "B<fadvise64>(2)\t2.6\n"
msgstr "B<fadvise64>(2)\t2.6\n"

#.  Implements \fBposix_fadvise\fP(2)
#. type: tbl table
#: man-pages/man2/syscalls.2:216
#, no-wrap
msgid "B<fadvise64_64>(2)\t2.6\n"
msgstr "B<fadvise64_64>(2)\t2.6\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:217
#, no-wrap
msgid "B<fallocate>(2)\t2.6.23\n"
msgstr "B<fallocate>(2)\t2.6.23\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:218
#, no-wrap
msgid "B<fanotify_init>(2)\t2.6.37\n"
msgstr "B<fanotify_init>(2)\t2.6.37\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:219
#, no-wrap
msgid "B<fanotify_mark>(2)\t2.6.37\n"
msgstr "B<fanotify_mark>(2)\t2.6.37\n"

#.  The fanotify calls were added in Linux 2.6.36,
#.  but disabled while the API was finalized.
#. type: tbl table
#: man-pages/man2/syscalls.2:222
#, no-wrap
msgid "B<fchdir>(2)\t1.0\n"
msgstr "B<fchdir>(2)\t1.0\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:223
#, no-wrap
msgid "B<fchmod>(2)\t1.0\n"
msgstr "B<fchmod>(2)\t1.0\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:224
#, no-wrap
msgid "B<fchmodat>(2)\t2.6.16\n"
msgstr "B<fchmodat>(2)\t2.6.16\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:225
#, no-wrap
msgid "B<fchown>(2)\t1.0\n"
msgstr "B<fchown>(2)\t1.0\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:226
#, no-wrap
msgid "B<fchown32>(2)\t2.4\n"
msgstr "B<fchown32>(2)\t2.4\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:227
#, no-wrap
msgid "B<fchownat>(2)\t2.6.16\n"
msgstr "B<fchownat>(2)\t2.6.16\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:228
#, no-wrap
msgid "B<fcntl>(2)\t1.0\n"
msgstr "B<fcntl>(2)\t1.0\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:229
#, no-wrap
msgid "B<fcntl64>(2)\t2.4\n"
msgstr "B<fcntl64>(2)\t2.4\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:230
#, no-wrap
msgid "B<fdatasync>(2)\t2.0\n"
msgstr "B<fdatasync>(2)\t2.0\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:231
#, no-wrap
msgid "B<fgetxattr>(2)\t2.6; 2.4.18\n"
msgstr "B<fgetxattr>(2)\t2.6; 2.4.18\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:232
#, no-wrap
msgid "B<finit_module>(2)\t3.8\n"
msgstr "B<finit_module>(2)\t3.8\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:233
#, no-wrap
msgid "B<flistxattr>(2)\t2.6; 2.4.18\n"
msgstr "B<flistxattr>(2)\t2.6; 2.4.18\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:234
#, no-wrap
msgid "B<flock>(2)\t2.0\n"
msgstr "B<flock>(2)\t2.0\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:235
#, no-wrap
msgid "B<fork>(2)\t1.0\n"
msgstr "B<fork>(2)\t1.0\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:236
#, no-wrap
msgid "B<free_hugepages>(2)\t2.5.36\tRemoved in 2.5.44\n"
msgstr "B<free_hugepages>(2)\t2.5.36\tудалён в 2.5.44\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:237
#, no-wrap
msgid "B<fremovexattr>(2)\t2.6; 2.4.18\n"
msgstr "B<fremovexattr>(2)\t2.6; 2.4.18\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:238
#, no-wrap
msgid "B<fsetxattr>(2)\t2.6; 2.4.18\n"
msgstr "B<fsetxattr>(2)\t2.6; 2.4.18\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:239
#, no-wrap
msgid "B<fstat>(2)\t1.0\n"
msgstr "B<fstat>(2)\t1.0\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:240
#, no-wrap
msgid "B<fstat64>(2)\t2.4\n"
msgstr "B<fstat64>(2)\t2.4\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:241
#, no-wrap
msgid "B<fstatat64>(2)\t2.6.16\n"
msgstr "B<fstatat64>(2)\t2.6.16\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:242
#, no-wrap
msgid "B<fstatfs>(2)\t1.0\n"
msgstr "B<fstatfs>(2)\t1.0\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:243
#, no-wrap
msgid "B<fstatfs64>(2)\t2.6\n"
msgstr "B<fstatfs64>(2)\t2.6\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:244
#, no-wrap
msgid "B<fsync>(2)\t1.0\t1.0\n"
msgstr "B<fsync>(2)\t1.0\t1.0\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:245
#, no-wrap
msgid "B<ftruncate>(2)\t1.0\n"
msgstr "B<ftruncate>(2)\t1.0\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:246
#, no-wrap
msgid "B<ftruncate64>(2)\t2.4\n"
msgstr "B<ftruncate64>(2)\t2.4\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:247
#, no-wrap
msgid "B<futex>(2)\t2.6\n"
msgstr "B<futex>(2)\t2.6\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:248
#, no-wrap
msgid "B<futimesat>(2)\t2.6.16\n"
msgstr "B<futimesat>(2)\t2.6.16\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:249
#, no-wrap
msgid "B<get_kernel_syms>(2)\t\tRemoved in 2.6\n"
msgstr "B<get_kernel_syms>(2)\t\tудалён в 2.6\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:250
#, no-wrap
msgid "B<get_mempolicy>(2)\t2.6.6\n"
msgstr "B<get_mempolicy>(2)\t2.6.6\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:251
#, no-wrap
msgid "B<get_robust_list>(2)\t2.6.17\n"
msgstr "B<get_robust_list>(2)\t2.6.17\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:252
#, no-wrap
msgid "B<get_thread_area>(2)\t2.6\n"
msgstr "B<get_thread_area>(2)\t2.6\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:253
#, no-wrap
msgid "B<getcpu>(2)\t2.6.19\n"
msgstr "B<getcpu>(2)\t2.6.19\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:254
#, no-wrap
msgid "B<getcwd>(2)\t2.2\n"
msgstr "B<getcwd>(2)\t2.2\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:255
#, no-wrap
msgid "B<getdents>(2)\t2.0\n"
msgstr "B<getdents>(2)\t2.0\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:256
#, no-wrap
msgid "B<getdents64>(2)\t2.4\n"
msgstr "B<getdents64>(2)\t2.4\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:257
#, no-wrap
msgid "B<getegid>(2)\t1.0\n"
msgstr "B<getegid>(2)\t1.0\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:258
#, no-wrap
msgid "B<getegid32>(2)\t2.4\n"
msgstr "B<getegid32>(2)\t2.4\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:259
#, no-wrap
msgid "B<geteuid>(2)\t1.0\n"
msgstr "B<geteuid>(2)\t1.0\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:260
#, no-wrap
msgid "B<geteuid32>(2)\t2.4\n"
msgstr "B<geteuid32>(2)\t2.4\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:261
#, no-wrap
msgid "B<getgid>(2)\t1.0\n"
msgstr "B<getgid>(2)\t1.0\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:262
#, no-wrap
msgid "B<getgid32>(2)\t2.4\n"
msgstr "B<getgid32>(2)\t2.4\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:263
#, no-wrap
msgid "B<getgroups>(2)\t1.0\n"
msgstr "B<getgroups>(2)\t1.0\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:264
#, no-wrap
msgid "B<getgroups32>(2)\t2.4\n"
msgstr "B<getgroups32>(2)\t2.4\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:265
#, no-wrap
msgid "B<getitimer>(2)\t1.0\n"
msgstr "B<getitimer>(2)\t1.0\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:266
#, no-wrap
msgid "B<getpeername>(2)\t2.0\tSee notes on B<socketcall>(2)\n"
msgstr "B<getpeername>(2)\t2.0\tсмотрите замечания по B<socketcall>(2)\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:267
#, no-wrap
msgid "B<getpagesize>(2)\t2.0\tNot on x86\n"
msgstr "B<getpagesize>(2)\t2.0\tне для x86\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:268
#, no-wrap
msgid "B<getpgid>(2)\t1.0\n"
msgstr "B<getpgid>(2)\t1.0\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:269
#, no-wrap
msgid "B<getpgrp>(2)\t1.0\n"
msgstr "B<getpgrp>(2)\t1.0\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:270
#, no-wrap
msgid "B<getpid>(2)\t1.0\n"
msgstr "B<getpid>(2)\t1.0\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:271
#, no-wrap
msgid "B<getppid>(2)\t1.0\n"
msgstr "B<getppid>(2)\t1.0\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:272
#, no-wrap
msgid "B<getpriority>(2)\t1.0\n"
msgstr "B<getpriority>(2)\t1.0\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:273
#, no-wrap
msgid "B<getresgid>(2)\t2.2\n"
msgstr "B<getresgid>(2)\t2.2\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:274
#, no-wrap
msgid "B<getresgid32>(2)\t2.4\n"
msgstr "B<getresgid32>(2)\t2.4\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:275
#, no-wrap
msgid "B<getresuid>(2)\t2.2\n"
msgstr "B<getresuid>(2)\t2.2\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:276
#, no-wrap
msgid "B<getresuid32>(2)\t2.4\n"
msgstr "B<getresuid32>(2)\t2.4\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:277
#, no-wrap
msgid "B<getrlimit>(2)\t1.0\n"
msgstr "B<getrlimit>(2)\t1.0\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:278
#, no-wrap
msgid "B<getrusage>(2)\t1.0\n"
msgstr "B<getrusage>(2)\t1.0\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:279
#, no-wrap
msgid "B<getsid>(2)\t2.0\n"
msgstr "B<getsid>(2)\t2.0\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:280
#, no-wrap
msgid "B<getsockname>(2)\t2.0\tSee notes on B<socketcall>(2)\n"
msgstr "B<getsockname>(2)\t2.0\tсмотрите замечания по B<socketcall>(2)\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:281
#, no-wrap
msgid "B<getsockopt>(2)\t2.0\tSee notes on B<socketcall>(2)\n"
msgstr "B<getsockopt>(2)\t2.0\tсмотрите замечания по B<socketcall>(2)\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:282
#, no-wrap
msgid "B<gettid>(2)\t2.4.11\n"
msgstr "B<gettid>(2)\t2.4.11\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:283
#, no-wrap
msgid "B<gettimeofday>(2)\t1.0\n"
msgstr "B<gettimeofday>(2)\t1.0\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:284
#, no-wrap
msgid "B<getuid>(2)\t1.0\n"
msgstr "B<getuid>(2)\t1.0\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:285
#, no-wrap
msgid "B<getuid32>(2)\t2.4\n"
msgstr "B<getuid32>(2)\t2.4\n"

#.  \fBgetunwind\fP(2)	2.4.8	ia64; DEPRECATED
#. type: tbl table
#: man-pages/man2/syscalls.2:287
#, no-wrap
msgid "B<getxattr>(2)\t2.6; 2.4.18\n"
msgstr "B<getxattr>(2)\t2.6; 2.4.18\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:288
#, no-wrap
msgid "B<init_module>(2)\t1.0\n"
msgstr "B<init_module>(2)\t1.0\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:289
#, no-wrap
msgid "B<inotify_add_watch>(2)\t2.6.13\n"
msgstr "B<inotify_add_watch>(2)\t2.6.13\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:290
#, no-wrap
msgid "B<inotify_init>(2)\t2.6.13\n"
msgstr "B<inotify_init>(2)\t2.6.13\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:291
#, no-wrap
msgid "B<inotify_init1>(2)\t2.6.27\n"
msgstr "B<inotify_init1>(2)\t2.6.27\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:292
#, no-wrap
msgid "B<inotify_rm_watch>(2)\t2.6.13\n"
msgstr "B<inotify_rm_watch>(2)\t2.6.13\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:293
#, no-wrap
msgid "B<io_cancel>(2)\t2.6\n"
msgstr "B<io_cancel>(2)\t2.6\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:294
#, no-wrap
msgid "B<io_destroy>(2)\t2.6\n"
msgstr "B<io_destroy>(2)\t2.6\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:295
#, no-wrap
msgid "B<io_getevents>(2)\t2.6\n"
msgstr "B<io_getevents>(2)\t2.6\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:296
#, no-wrap
msgid "B<io_setup>(2)\t2.6\n"
msgstr "B<io_setup>(2)\t2.6\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:297
#, no-wrap
msgid "B<io_submit>(2)\t2.6\n"
msgstr "B<io_submit>(2)\t2.6\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:298
#, no-wrap
msgid "B<ioctl>(2)\t1.0\n"
msgstr "B<ioctl>(2)\t1.0\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:299
#, no-wrap
msgid "B<ioperm>(2)\t1.0\n"
msgstr "B<ioperm>(2)\t1.0\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:300
#, no-wrap
msgid "B<iopl>(2)\t1.0\n"
msgstr "B<iopl>(2)\t1.0\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:301
#, no-wrap
msgid "B<ioprio_get>(2)\t2.6.13\n"
msgstr "B<ioprio_get>(2)\t2.6.13\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:302
#, no-wrap
msgid "B<ioprio_set>(2)\t2.6.13\n"
msgstr "B<ioprio_set>(2)\t2.6.13\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:303
#, no-wrap
msgid "B<ipc>(2)\t1.0\n"
msgstr "B<ipc>(2)\t1.0\n"

#.  Implements System V IPC calls
#. type: tbl table
#: man-pages/man2/syscalls.2:305
#, no-wrap
msgid "B<kcmp>(2)\t3.5\n"
msgstr "B<kcmp>(2)\t3.5\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:306
#, no-wrap
msgid "B<kern_features>(2)\t3.7\tSparc64\n"
msgstr "B<kern_features>(2)\t3.7\tSparc64\n"

#.  FIXME: document kern_features():
#.  commit 517ffce4e1a03aea979fe3a18a3dd1761a24fafb
#. type: tbl table
#: man-pages/man2/syscalls.2:309
#, no-wrap
msgid "B<kexec_load>(2)\t2.6.13\n"
msgstr "B<kexec_load>(2)\t2.6.13\n"

#.  The entry in the syscall table was reserved starting in 2.6.7
#.  Was named sys_kexec_load() from 2.6.7 to 2.6.16
#. type: tbl table
#: man-pages/man2/syscalls.2:312
#, no-wrap
msgid "B<keyctl>(2)\t2.6.11\n"
msgstr "B<keyctl>(2)\t2.6.11\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:313
#, no-wrap
msgid "B<kill>(2)\t1.0\n"
msgstr "B<kill>(2)\t1.0\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:314
#, no-wrap
msgid "B<lchown>(2)\t1.0\tT{\n"
msgstr "B<lchown>(2)\t1.0\tT{\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:319
#, no-wrap
msgid "B<lchown32>(2)\t2.4\n"
msgstr "B<lchown32>(2)\t2.4\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:320
#, no-wrap
msgid "B<lgetxattr>(2)\t2.6; 2.4.18\n"
msgstr "B<lgetxattr>(2)\t2.6; 2.4.18\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:321
#, no-wrap
msgid "B<link>(2)\t1.0\n"
msgstr "B<link>(2)\t1.0\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:322
#, no-wrap
msgid "B<linkat>(2)\t2.6.16\n"
msgstr "B<linkat>(2)\t2.6.16\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:323
#, no-wrap
msgid "B<listen>(2)\t2.0\tSee notes on B<socketcall>(2)\n"
msgstr "B<listen>(2)\t2.0\tсмотрите замечания по B<socketcall>(2)\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:324
#, no-wrap
msgid "B<listxattr>(2)\t2.6; 2.4.18\n"
msgstr "B<listxattr>(2)\t2.6; 2.4.18\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:325
#, no-wrap
msgid "B<llistxattr>(2)\t2.6; 2.4.18\n"
msgstr "B<llistxattr>(2)\t2.6; 2.4.18\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:326
#, no-wrap
msgid "B<lookup_dcookie>(2)\t2.6\n"
msgstr "B<lookup_dcookie>(2)\t2.6\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:327
#, no-wrap
msgid "B<lremovexattr>(2)\t2.6; 2.4.18\n"
msgstr "B<lremovexattr>(2)\t2.6; 2.4.18\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:328
#, no-wrap
msgid "B<lseek>(2)\t1.0\n"
msgstr "B<lseek>(2)\t1.0\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:329
#, no-wrap
msgid "B<lsetxattr>(2)\t2.6; 2.4.18\n"
msgstr "B<lsetxattr>(2)\t2.6; 2.4.18\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:330
#, no-wrap
msgid "B<lstat>(2)\t1.0\n"
msgstr "B<lstat>(2)\t1.0\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:331
#, no-wrap
msgid "B<lstat64>(2)\t2.4\n"
msgstr "B<lstat64>(2)\t2.4\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:332
#, no-wrap
msgid "B<madvise>(2)\t2.4\n"
msgstr "B<madvise>(2)\t2.4\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:333
#, no-wrap
msgid "B<mbind>(2)\t2.6.6\n"
msgstr "B<mbind>(2)\t2.6.6\n"

#.  \fBmemory_ordering\fP(2)	???	Sparc64
#. type: tbl table
#: man-pages/man2/syscalls.2:335
#, no-wrap
msgid "B<migrate_pages>(2)\t2.6.16\n"
msgstr "B<migrate_pages>(2)\t2.6.16\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:336
#, no-wrap
msgid "B<mincore>(2)\t2.4\n"
msgstr "B<mincore>(2)\t2.4\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:337
#, no-wrap
msgid "B<mkdir>(2)\t1.0\n"
msgstr "B<mkdir>(2)\t1.0\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:338
#, no-wrap
msgid "B<mkdirat>(2)\t2.6.16\n"
msgstr "B<mkdirat>(2)\t2.6.16\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:339
#, no-wrap
msgid "B<mknod>(2)\t1.0\n"
msgstr "B<mknod>(2)\t1.0\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:340
#, no-wrap
msgid "B<mknodat>(2)\t2.6.16\n"
msgstr "B<mknodat>(2)\t2.6.16\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:341
#, no-wrap
msgid "B<mlock>(2)\t2.0\n"
msgstr "B<mlock>(2)\t2.0\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:342
#, no-wrap
msgid "B<mlockall>(2)\t2.0\n"
msgstr "B<mlockall>(2)\t2.0\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:343
#, no-wrap
msgid "B<mmap>(2)\t1.0\n"
msgstr "B<mmap>(2)\t1.0\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:344
#, no-wrap
msgid "B<mmap2>(2)\t2.4\n"
msgstr "B<mmap2>(2)\t2.4\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:345
#, no-wrap
msgid "B<modify_ldt>(2)\t1.0\n"
msgstr "B<modify_ldt>(2)\t1.0\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:346
#, no-wrap
msgid "B<mount>(2)\t1.0\n"
msgstr "B<mount>(2)\t1.0\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:347
#, no-wrap
msgid "B<move_pages>(2)\t2.6.18\n"
msgstr "B<move_pages>(2)\t2.6.18\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:348
#, no-wrap
msgid "B<mprotect>(2)\t1.0\n"
msgstr "B<mprotect>(2)\t1.0\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:349
#, no-wrap
msgid "B<mq_getsetattr>(2)\t2.6.6\n"
msgstr "B<mq_getsetattr>(2)\t2.6.6\n"

#.  Implements \fBmq_getattr\fP(3) and \fBmq_setattr\fP(3)
#. type: tbl table
#: man-pages/man2/syscalls.2:351
#, no-wrap
msgid "B<mq_notify>(2)\t2.6.6\n"
msgstr "B<mq_notify>(2)\t2.6.6\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:352
#, no-wrap
msgid "B<mq_open>(2)\t2.6.6\n"
msgstr "B<mq_open>(2)\t2.6.6\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:353
#, no-wrap
msgid "B<mq_timedreceive>(2)\t2.6.6\n"
msgstr "B<mq_timedreceive>(2)\t2.6.6\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:354
#, no-wrap
msgid "B<mq_timedsend>(2)\t2.6.6\n"
msgstr "B<mq_timedsend>(2)\t2.6.6\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:355
#, no-wrap
msgid "B<mq_unlink>(2)\t2.6.6\n"
msgstr "B<mq_unlink>(2)\t2.6.6\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:356
#, no-wrap
msgid "B<mremap>(2)\t2.0\n"
msgstr "B<mremap>(2)\t2.0\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:357
#, no-wrap
msgid "B<msgctl>(2)\t2.0\tSee notes on B<ipc>(2)\n"
msgstr "B<msgctl>(2)\t2.0\tсмотрите замечания по B<ipc>(2)\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:358
#, no-wrap
msgid "B<msgget>(2)\t2.0\tSee notes on B<ipc>(2)\n"
msgstr "B<msgget>(2)\t2.0\tсмотрите замечания по B<ipc>(2)\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:359
#, no-wrap
msgid "B<msgrcv>(2)\t2.0\tSee notes on B<ipc>(2)\n"
msgstr "B<msgrcv>(2)\t2.0\tсмотрите замечания по B<ipc>(2)\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:360
#, no-wrap
msgid "B<msgsnd>(2)\t2.0\tSee notes on B<ipc>(2)\n"
msgstr "B<msgsnd>(2)\t2.0\tсмотрите замечания по B<ipc>(2)\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:361
#, no-wrap
msgid "B<msync>(2)\t2.0\n"
msgstr "B<msync>(2)\t2.0\n"

#.  \fBmultiplexer\fP(2)	??	__NR_multiplexer reserved on
#. 		PowerPC, but unimplemented?
#. type: tbl table
#: man-pages/man2/syscalls.2:364
#, no-wrap
msgid "B<munlock>(2)\t2.0\n"
msgstr "B<munlock>(2)\t2.0\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:365
#, no-wrap
msgid "B<munlockall>(2)\t2.0\n"
msgstr "B<munlockall>(2)\t2.0\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:366
#, no-wrap
msgid "B<munmap>(2)\t1.0\n"
msgstr "B<munmap>(2)\t1.0\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:367
#, no-wrap
msgid "B<name_to_handle_at>(2)\t2.6.39\n"
msgstr "B<name_to_handle_at>(2)\t2.6.39\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:368
#, no-wrap
msgid "B<nanosleep>(2)\t2.0\n"
msgstr "B<nanosleep>(2)\t2.0\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:369
#, no-wrap
msgid "B<nfsservctl>(2)\t2.2\tRemoved in 3.1\n"
msgstr "B<nfsservctl>(2)\t2.2\tудалён в 3.1\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:370
#, no-wrap
msgid "B<nice>(2)\t1.0\n"
msgstr "B<nice>(2)\t1.0\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:371
#, no-wrap
msgid "B<oldfstat>(2)\t1.0\n"
msgstr "B<oldfstat>(2)\t1.0\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:372
#, no-wrap
msgid "B<oldlstat>(2)\t1.0\n"
msgstr "B<oldlstat>(2)\t1.0\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:373
#, no-wrap
msgid "B<oldolduname>(2)\t1.0\n"
msgstr "B<oldolduname>(2)\t1.0\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:374
#, no-wrap
msgid "B<oldstat>(2)\t1.0\n"
msgstr "B<oldstat>(2)\t1.0\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:375
#, no-wrap
msgid "B<olduname>(2)\t1.0\n"
msgstr "B<olduname>(2)\t1.0\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:376
#, no-wrap
msgid "B<open>(2)\t1.0\n"
msgstr "B<open>(2)\t1.0\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:377
#, no-wrap
msgid "B<open_by_handle_at>(2)\t2.6.39\n"
msgstr "B<open_by_handle_at>(2)\t2.6.39\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:378
#, no-wrap
msgid "B<openat>(2)\t2.6.16\n"
msgstr "B<openat>(2)\t2.6.16\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:379
#, no-wrap
msgid "B<pause>(2)\t1.0\n"
msgstr "B<pause>(2)\t1.0\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:380
#, no-wrap
msgid "B<pciconfig_iobase>(2)\t2.2.15; 2.4\tNot on x86\n"
msgstr "B<pciconfig_iobase>(2)\t2.2.15; 2.4\tне в x86\n"

#.  Alpha, PowerPC, ARM; not x86
#. type: tbl table
#: man-pages/man2/syscalls.2:382
#, no-wrap
msgid "B<pciconfig_read>(2)\t2.0.26; 2.2\tNot on x86\n"
msgstr "B<pciconfig_read>(2)\t2.0.26; 2.2\tне в x86\n"

#.  , PowerPC, ARM; not x86
#. type: tbl table
#: man-pages/man2/syscalls.2:384
#, no-wrap
msgid "B<pciconfig_write>(2)\t2.0.26; 2.2\tNot on x86\n"
msgstr "B<pciconfig_write>(2)\t2.0.26; 2.2\tне в x86\n"

#.  , PowerPC, ARM; not x86
#. type: tbl table
#: man-pages/man2/syscalls.2:386
#, no-wrap
msgid "B<perf_event_open>(2)\t2.6.31\tT{\n"
msgstr "B<perf_event_open>(2)\t2.6.31\tT{\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:387
#, no-wrap
msgid "Was called perf_counter_open()\n"
msgstr "Назывался perf_counter_open()\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:389
#, no-wrap
msgid "in 2.6.31; renamed in 2.6.32\n"
msgstr "в 2.6.31; переименован в 2.6.32\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:391
#, no-wrap
msgid "B<personality>(2)\t1.2\n"
msgstr "B<personality>(2)\t1.2\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:392
#, no-wrap
msgid "B<perfctr>(2)\t2.2\tSparc; removed in 2.6.34\n"
msgstr "B<perfctr>(2)\t2.2\tSparc; удалён в 2.6.34\n"

#. 	commit c7d5a0050773e98d1094eaa9f2a1a793fafac300 removed perfctr()
#. type: tbl table
#: man-pages/man2/syscalls.2:394
#, no-wrap
msgid "B<perfmonctl>(2)\t2.4\tia64\n"
msgstr "B<perfmonctl>(2)\t2.4\tia64\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:395
#, no-wrap
msgid "B<pipe>(2)\t1.0\n"
msgstr "B<pipe>(2)\t1.0\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:396
#, no-wrap
msgid "B<pipe2>(2)\t2.6.27\n"
msgstr "B<pipe2>(2)\t2.6.27\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:397
#, no-wrap
msgid "B<pivot_root>(2)\t2.4\n"
msgstr "B<pivot_root>(2)\t2.4\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:398
#, no-wrap
msgid "B<poll>(2)\t2.0.36; 2.2\n"
msgstr "B<poll>(2)\t2.0.36; 2.2\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:399
#, no-wrap
msgid "B<ppc_rtas>(2)\t\tPowerPC only\n"
msgstr "B<ppc_rtas>(2)\t\tтолько для PowerPC\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:400
#, no-wrap
msgid "B<ppoll>(2)\t2.6.16\n"
msgstr "B<ppoll>(2)\t2.6.16\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:401
#, no-wrap
msgid "B<prctl>(2)\t2.2\n"
msgstr "B<prctl>(2)\t2.2\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:402
#, no-wrap
msgid "B<pread64>(2)\t\tT{\n"
msgstr "B<pread64>(2)\t\tT{\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:403
#, no-wrap
msgid "Added as \"pread\" in 2.2;\n"
msgstr "добавлен под именем «pread» в 2.2\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:405
#, no-wrap
msgid "renamed \"pread64\" in 2.6\n"
msgstr "переименован в «pread64» в 2.6\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:407
#, no-wrap
msgid "B<preadv>(2)\t2.6.30\n"
msgstr "B<preadv>(2)\t2.6.30\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:408
#, no-wrap
msgid "B<prlimit>(2)\t2.6.36\n"
msgstr "B<prlimit>(2)\t2.6.36\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:409
#, no-wrap
msgid "B<prlimit64>(2)\t2.6.36\n"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:410
#, no-wrap
msgid "B<process_vm_readv>(2)\t3.2\n"
msgstr "B<process_vm_readv>(2)\t3.2\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:411
#, no-wrap
msgid "B<process_vm_writev>(2)\t3.2\n"
msgstr "B<process_vm_writev>(2)\t3.2\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:412
#, no-wrap
msgid "B<pselect6>(2)\t2.6.16\n"
msgstr "B<pselect6>(2)\t2.6.16\n"

#.  Implements \fBpselect\fP(2)
#. type: tbl table
#: man-pages/man2/syscalls.2:414
#, no-wrap
msgid "B<ptrace>(2)\t1.0\n"
msgstr "B<ptrace>(2)\t1.0\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:415
#, no-wrap
msgid "B<pwrite64>(2)\t\tT{\n"
msgstr "B<pwrite64>(2)\t\tT{\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:416
#, no-wrap
msgid "Added as \"pwrite\" in 2.2;\n"
msgstr "добавлен под именем «pwrite» в 2.2\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:418
#, no-wrap
msgid "renamed \"pwrite64\" in 2.6\n"
msgstr "переименован в «pwrite64» в 2.6\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:420
#, no-wrap
msgid "B<pwritev>(2)\t2.6.30\n"
msgstr "B<pwritev>(2)\t2.6.30\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:421
#, no-wrap
msgid "B<query_module>(2)\t2.2\tRemoved in 2.6\n"
msgstr "B<query_module>(2)\t2.2\tудалён в 2.6\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:422
#, no-wrap
msgid "B<quotactl>(2)\t1.0\n"
msgstr "B<quotactl>(2)\t1.0\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:423
#, no-wrap
msgid "B<read>(2)\t1.0\n"
msgstr "B<read>(2)\t1.0\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:424
#, no-wrap
msgid "B<readahead>(2)\t2.4.13\n"
msgstr "B<readahead>(2)\t2.4.13\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:425
#, no-wrap
msgid "B<readdir>(2)\t1.0\n"
msgstr "B<readdir>(2)\t1.0\n"

#.  Supersedes \fBgetdents\fP(2)
#. type: tbl table
#: man-pages/man2/syscalls.2:427
#, no-wrap
msgid "B<readlink>(2)\t1.0\n"
msgstr "B<readlink>(2)\t1.0\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:428
#, no-wrap
msgid "B<readlinkat>(2)\t2.6.16\n"
msgstr "B<readlinkat>(2)\t2.6.16\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:429
#, no-wrap
msgid "B<readv>(2)\t2.0\n"
msgstr "B<readv>(2)\t2.0\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:430
#, no-wrap
msgid "B<reboot>(2)\t1.0\n"
msgstr "B<reboot>(2)\t1.0\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:431
#, no-wrap
msgid "B<recv>(2)\t2.0\tSee notes on B<socketcall>(2)\n"
msgstr "B<recv>(2)\t2.0\tсмотрите замечания по B<socketcall>(2)\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:432
#, no-wrap
msgid "B<recvfrom>(2)\t2.0\tSee notes on B<socketcall>(2)\n"
msgstr "B<recvfrom>(2)\t2.0\tсмотрите замечания по B<socketcall>(2)\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:433
#, no-wrap
msgid "B<recvmsg>(2)\t2.0\tSee notes on B<socketcall>(2)\n"
msgstr "B<recvmsg>(2)\t2.0\tсмотрите замечания по B<socketcall>(2)\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:434
#, no-wrap
msgid "B<recvmmsg>(2)\t2.6.33\n"
msgstr "B<recvmmsg>(2)\t2.6.33\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:435
#, no-wrap
msgid "B<remap_file_pages>(2)\t2.6\tDeprecated since 3.16\n"
msgstr ""

#. type: tbl table
#: man-pages/man2/syscalls.2:436
#, no-wrap
msgid "B<removexattr>(2)\t2.6; 2.4.18\n"
msgstr "B<removexattr>(2)\t2.6; 2.4.18\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:437
#, no-wrap
msgid "B<rename>(2)\t1.0\n"
msgstr "B<rename>(2)\t1.0\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:438
#, no-wrap
msgid "B<renameat>(2)\t2.6.16\n"
msgstr "B<renameat>(2)\t2.6.16\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:439
#, no-wrap
msgid "B<renameat2>(2)\t3.15\n"
msgstr "B<renameat2>(2)\t3.15\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:440
#, no-wrap
msgid "B<request_key>(2)\t2.6.11\n"
msgstr "B<request_key>(2)\t2.6.11\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:441
#, no-wrap
msgid "B<restart_syscall>(2)\t2.6\n"
msgstr "B<restart_syscall>(2)\t2.6\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:442
#, no-wrap
msgid "B<rmdir>(2)\t1.0\n"
msgstr "B<rmdir>(2)\t1.0\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:443
#, no-wrap
msgid "B<rt_sigaction>(2)\t2.2\n"
msgstr "B<rt_sigaction>(2)\t2.2\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:444
#, no-wrap
msgid "B<rt_sigpending>(2)\t2.2\n"
msgstr "B<rt_sigpending>(2)\t2.2\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:445
#, no-wrap
msgid "B<rt_sigprocmask>(2)\t2.2\n"
msgstr "B<rt_sigprocmask>(2)\t2.2\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:446
#, no-wrap
msgid "B<rt_sigqueueinfo>(2)\t2.2\n"
msgstr "B<rt_sigqueueinfo>(2)\t2.2\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:447
#, no-wrap
msgid "B<rt_sigreturn>(2)\t2.2\n"
msgstr "B<rt_sigreturn>(2)\t2.2\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:448
#, no-wrap
msgid "B<rt_sigsuspend>(2)\t2.2\n"
msgstr "B<rt_sigsuspend>(2)\t2.2\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:449
#, no-wrap
msgid "B<rt_sigtimedwait>(2)\t2.2\n"
msgstr "B<rt_sigtimedwait>(2)\t2.2\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:450
#, no-wrap
msgid "B<rt_tgsigqueueinfo>(2)\t2.6.31\n"
msgstr "B<rt_tgsigqueueinfo>(2)\t2.6.31\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:451
#, no-wrap
msgid "B<s390_runtime_instr>(2)\t3.7\ts390 only\n"
msgstr "B<s390_runtime_instr>(2)\t3.7\tтолько для s390\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:452
#, no-wrap
msgid "B<sched_get_priority_max>(2)\t2.0\n"
msgstr "B<sched_get_priority_max>(2)\t2.0\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:453
#, no-wrap
msgid "B<sched_get_priority_min>(2)\t2.0\n"
msgstr "B<sched_get_priority_min>(2)\t2.0\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:454
#, no-wrap
msgid "B<sched_getaffinity>(2)\t2.6\n"
msgstr "B<sched_getaffinity>(2)\t2.6\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:455
#, no-wrap
msgid "B<sched_getattr>(2)\t3.14\n"
msgstr "B<sched_getattr>(2)\t3.14\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:456
#, no-wrap
msgid "B<sched_getparam>(2)\t2.0\n"
msgstr "B<sched_getparam>(2)\t2.0\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:457
#, no-wrap
msgid "B<sched_getscheduler>(2)\t2.0\n"
msgstr "B<sched_getscheduler>(2)\t2.0\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:458
#, no-wrap
msgid "B<sched_rr_get_interval>(2)\t2.0\n"
msgstr "B<sched_rr_get_interval>(2)\t2.0\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:459
#, no-wrap
msgid "B<sched_setaffinity>(2)\t2.6\n"
msgstr "B<sched_setaffinity>(2)\t2.6\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:460
#, no-wrap
msgid "B<sched_setattr>(2)\t3.14\n"
msgstr "B<sched_setattr>(2)\t3.14\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:461
#, no-wrap
msgid "B<sched_setparam>(2)\t2.0\n"
msgstr "B<sched_setparam>(2)\t2.0\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:462
#, no-wrap
msgid "B<sched_setscheduler>(2)\t2.0\n"
msgstr "B<sched_setscheduler>(2)\t2.0\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:463
#, no-wrap
msgid "B<sched_yield>(2)\t2.0\n"
msgstr "B<sched_yield>(2)\t2.0\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:464
#, no-wrap
msgid "B<select>(2)\t1.0\n"
msgstr "B<select>(2)\t1.0\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:465
#, no-wrap
msgid "B<semctl>(2)\t2.0\tSee notes on B<ipc>(2)\n"
msgstr "B<semctl>(2)\t2.0\tсмотрите замечания по B<ipc>(2)\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:466
#, no-wrap
msgid "B<semget>(2)\t2.0\tSee notes on B<ipc>(2)\n"
msgstr "B<semget>(2)\t2.0\tсмотрите замечания по B<ipc>(2)\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:467
#, no-wrap
msgid "B<semop>(2)\t2.0\tSee notes on B<ipc>(2)\n"
msgstr "B<semop>(2)\t2.0\tсмотрите замечания по B<ipc>(2)\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:468
#, no-wrap
msgid "B<semtimedop>(2)\t2.6; 2.4.22\n"
msgstr "B<semtimedop>(2)\t2.6; 2.4.22\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:469
#, no-wrap
msgid "B<send>(2)\t2.0\tSee notes on B<socketcall>(2)\n"
msgstr "B<send>(2)\t2.0\tсмотрите замечания по B<socketcall>(2)\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:470
#, no-wrap
msgid "B<sendfile>(2)\t2.2\n"
msgstr "B<sendfile>(2)\t2.2\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:471
#, no-wrap
msgid "B<sendfile64>(2)\t2.6; 2.4.19\n"
msgstr "B<sendfile64>(2)\t2.6; 2.4.19\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:472
#, no-wrap
msgid "B<sendmmsg>(2)\t3.0\n"
msgstr "B<sendmmsg>(2)\t3.0\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:473
#, no-wrap
msgid "B<sendmsg>(2)\t2.0\tSee notes on B<socketcall>(2)\n"
msgstr "B<sendmsg>(2)\t2.0\tсмотрите замечания по B<socketcall>(2)\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:474
#, no-wrap
msgid "B<sendto>(2)\t2.0\tSee notes on B<socketcall>(2)\n"
msgstr "B<sendto>(2)\t2.0\tсмотрите замечания по B<socketcall>(2)\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:475
#, no-wrap
msgid "B<set_mempolicy>(2)\t2.6.6\n"
msgstr "B<set_mempolicy>(2)\t2.6.6\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:476
#, no-wrap
msgid "B<set_robust_list>(2)\t2.6.17\n"
msgstr "B<set_robust_list>(2)\t2.6.17\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:477
#, no-wrap
msgid "B<set_thread_area>(2)\t2.6\n"
msgstr "B<set_thread_area>(2)\t2.6\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:478
#, no-wrap
msgid "B<set_tid_address>(2)\t2.6\n"
msgstr "B<set_tid_address>(2)\t2.6\n"

#.  See http://lkml.org/lkml/2005/8/1/83
#.  "[PATCH] remove sys_set_zone_reclaim()"
#. type: tbl table
#: man-pages/man2/syscalls.2:481
#, no-wrap
msgid "B<setdomainname>(2)\t1.0\n"
msgstr "B<setdomainname>(2)\t1.0\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:482
#, no-wrap
msgid "B<setfsgid>(2)\t1.2\n"
msgstr "B<setfsgid>(2)\t1.2\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:483
#, no-wrap
msgid "B<setfsgid32>(2)\t2.4\n"
msgstr "B<setfsgid32>(2)\t2.4\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:484
#, no-wrap
msgid "B<setfsuid>(2)\t1.2\n"
msgstr "B<setfsuid>(2)\t1.2\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:485
#, no-wrap
msgid "B<setfsuid32>(2)\t2.4\n"
msgstr "B<setfsuid32>(2)\t2.4\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:486
#, no-wrap
msgid "B<setgid>(2)\t1.0\n"
msgstr "B<setgid>(2)\t1.0\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:487
#, no-wrap
msgid "B<setgid32>(2)\t2.4\n"
msgstr "B<setgid32>(2)\t2.4\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:488
#, no-wrap
msgid "B<setgroups>(2)\t1.0\n"
msgstr "B<setgroups>(2)\t1.0\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:489
#, no-wrap
msgid "B<setgroups32>(2)\t2.4\n"
msgstr "B<setgroups32>(2)\t2.4\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:490
#, no-wrap
msgid "B<sethostname>(2)\t1.0\n"
msgstr "B<sethostname>(2)\t1.0\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:491
#, no-wrap
msgid "B<setitimer>(2)\t1.0\n"
msgstr "B<setitimer>(2)\t1.0\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:492
#, no-wrap
msgid "B<setns>(2)\t3.0\n"
msgstr "B<setns>(2)\t3.0\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:493
#, no-wrap
msgid "B<setpgid>(2)\t1.0\n"
msgstr "B<setpgid>(2)\t1.0\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:494
#, no-wrap
msgid "B<setpriority>(2)\t1.0\n"
msgstr "B<setpriority>(2)\t1.0\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:495
#, no-wrap
msgid "B<setregid>(2)\t1.0\n"
msgstr "B<setregid>(2)\t1.0\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:496
#, no-wrap
msgid "B<setregid32>(2)\t2.4\n"
msgstr "B<setregid32>(2)\t2.4\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:497
#, no-wrap
msgid "B<setresgid>(2)\t2.2\n"
msgstr "B<setresgid>(2)\t2.2\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:498
#, no-wrap
msgid "B<setresgid32>(2)\t2.4\n"
msgstr "B<setresgid32>(2)\t2.4\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:499
#, no-wrap
msgid "B<setresuid>(2)\t2.2\n"
msgstr "B<setresuid>(2)\t2.2\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:500
#, no-wrap
msgid "B<setresuid32>(2)\t2.4\n"
msgstr "B<setresuid32>(2)\t2.4\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:501
#, no-wrap
msgid "B<setreuid>(2)\t1.0\n"
msgstr "B<setreuid>(2)\t1.0\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:502
#, no-wrap
msgid "B<setreuid32>(2)\t2.4\n"
msgstr "B<setreuid32>(2)\t2.4\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:503
#, no-wrap
msgid "B<setrlimit>(2)\t1.0\n"
msgstr "B<setrlimit>(2)\t1.0\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:504
#, no-wrap
msgid "B<setsid>(2)\t1.0\n"
msgstr "B<setsid>(2)\t1.0\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:505
#, no-wrap
msgid "B<setsockopt>(2)\t2.0\tSee notes on B<socketcall>(2)\n"
msgstr "B<setsockopt>(2)\t2.0\tсмотрите замечания по B<socketcall>(2)\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:506
#, no-wrap
msgid "B<settimeofday>(2)\t1.0\n"
msgstr "B<settimeofday>(2)\t1.0\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:507
#, no-wrap
msgid "B<setuid>(2)\t1.0\n"
msgstr "B<setuid>(2)\t1.0\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:508
#, no-wrap
msgid "B<setuid32>(2)\t2.4\n"
msgstr "B<setuid32>(2)\t2.4\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:509
#, no-wrap
msgid "B<setup>(2)\t\tRemoved in 2.2\n"
msgstr "B<setup>(2)\t\tудалён в 2.2\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:510
#, no-wrap
msgid "B<setxattr>(2)\t2.6; 2.4.18\n"
msgstr "B<setxattr>(2)\t2.6; 2.4.18\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:511
#, no-wrap
msgid "B<sgetmask>(2)\t1.0\n"
msgstr "B<sgetmask>(2)\t1.0\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:512
#, no-wrap
msgid "B<shmat>(2)\t2.0\tSee notes on B<ipc>(2)\n"
msgstr "B<shmat>(2)\t2.0\tсмотрите замечания по B<ipc>(2)\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:513
#, no-wrap
msgid "B<shmctl>(2)\t2.0\tSee notes on B<ipc>(2)\n"
msgstr "B<shmctl>(2)\t2.0\tсмотрите замечания по B<ipc>(2)\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:514
#, no-wrap
msgid "B<shmdt>(2)\t2.0\tSee notes on B<ipc>(2)\n"
msgstr "B<shmdt>(2)\t2.0\tсмотрите замечания по B<ipc>(2)\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:515
#, no-wrap
msgid "B<shmget>(2)\t2.0\tSee notes on B<ipc>(2)\n"
msgstr "B<shmget>(2)\t2.0\tсмотрите замечания по B<ipc>(2)\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:516
#, no-wrap
msgid "B<shutdown>(2)\t2.0\tSee notes on B<socketcall>(2)\n"
msgstr "B<shutdown>(2)\t2.0\tсмотрите замечания по B<socketcall>(2)\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:517
#, no-wrap
msgid "B<sigaction>(2)\t1.0\n"
msgstr "B<sigaction>(2)\t1.0\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:518
#, no-wrap
msgid "B<sigaltstack>(2)\t2.2\n"
msgstr "B<sigaltstack>(2)\t2.2\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:519
#, no-wrap
msgid "B<signal>(2)\t1.0\n"
msgstr "B<signal>(2)\t1.0\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:520
#, no-wrap
msgid "B<signalfd>(2)\t2.6.22\n"
msgstr "B<signalfd>(2)\t2.6.22\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:521
#, no-wrap
msgid "B<signalfd4>(2)\t2.6.27\n"
msgstr "B<signalfd4>(2)\t2.6.27\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:522
#, no-wrap
msgid "B<sigpending>(2)\t1.0\n"
msgstr "B<sigpending>(2)\t1.0\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:523
#, no-wrap
msgid "B<sigprocmask>(2)\t1.0\n"
msgstr "B<sigprocmask>(2)\t1.0\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:524
#, no-wrap
msgid "B<sigreturn>(2)\t1.0\n"
msgstr "B<sigreturn>(2)\t1.0\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:525
#, no-wrap
msgid "B<sigsuspend>(2)\t1.0\n"
msgstr "B<sigsuspend>(2)\t1.0\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:526
#, no-wrap
msgid "B<socket>(2)\t2.0\tSee notes on B<socketcall>(2)\n"
msgstr "B<socket>(2)\t2.0\tсмотрите замечания по B<socketcall>(2)\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:527
#, no-wrap
msgid "B<socketcall>(2)\t1.0\n"
msgstr "B<socketcall>(2)\t1.0\n"

#.  Implements BSD socket calls
#. type: tbl table
#: man-pages/man2/syscalls.2:529
#, no-wrap
msgid "B<socketpair>(2)\t2.0\tSee notes on B<socketcall>(2)\n"
msgstr "B<socketpair>(2)\t2.0\tсмотрите замечания по B<socketcall>(2)\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:530
#, no-wrap
msgid "B<splice>(2)\t2.6.17\n"
msgstr "B<splice>(2)\t2.6.17\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:531
#, no-wrap
msgid "B<spu_create>(2)\t2.6.16\tPowerPC only\n"
msgstr "B<spu_create>(2)\t2.6.16\tтолько для PowerPC\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:532
#, no-wrap
msgid "B<spu_run>(2)\t2.6.16\tPowerPC only\n"
msgstr "B<spu_run>(2)\t2.6.16\tтолько для PowerPC\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:533
#, no-wrap
msgid "B<ssetmask>(2)\t1.0\n"
msgstr "B<ssetmask>(2)\t1.0\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:534
#, no-wrap
msgid "B<stat>(2)\t1.0\n"
msgstr "B<stat>(2)\t1.0\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:535
#, no-wrap
msgid "B<stat64>(2)\t2.4\n"
msgstr "B<stat64>(2)\t2.4\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:536
#, no-wrap
msgid "B<statfs>(2)\t1.0\n"
msgstr "B<statfs>(2)\t1.0\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:537
#, no-wrap
msgid "B<statfs64>(2)\t2.6\n"
msgstr "B<statfs64>(2)\t2.6\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:538
#, no-wrap
msgid "B<stime>(2)\t1.0\n"
msgstr "B<stime>(2)\t1.0\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:539
#, no-wrap
msgid "B<subpage_prot>(2)\t2.6.25\tPowerPC if\n"
msgstr "B<subpage_prot>(2)\t2.6.25\tPowerPC, если\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:540
#, no-wrap
msgid "\t\tCONFIG_PPC_64K_PAGES\n"
msgstr "\t\tCONFIG_PPC_64K_PAGES\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:541
#, no-wrap
msgid "B<swapoff>(2)\t1.0\n"
msgstr "B<swapoff>(2)\t1.0\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:542
#, no-wrap
msgid "B<swapon>(2)\t1.0\n"
msgstr "B<swapon>(2)\t1.0\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:543
#, no-wrap
msgid "B<symlink>(2)\t1.0\n"
msgstr "B<symlink>(2)\t1.0\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:544
#, no-wrap
msgid "B<symlinkat>(2)\t2.6.16\n"
msgstr "B<symlinkat>(2)\t2.6.16\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:545
#, no-wrap
msgid "B<sync>(2)\t1.0\n"
msgstr "B<sync>(2)\t1.0\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:546
#, no-wrap
msgid "B<sync_file_range>(2)\t2.6.17\n"
msgstr "B<sync_file_range>(2)\t2.6.17\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:547
#, no-wrap
msgid "B<sync_file_range2>(2)\t2.6.22\tT{\n"
msgstr "B<sync_file_range2>(2)\t2.6.22\tT{\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:548
#, no-wrap
msgid "Architecture-specific\n"
msgstr "зависящий от архитектуры\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:549
#, no-wrap
msgid "variant of B<sync_file_range>(2)\n"
msgstr "вариант B<sync_file_range>(2)\n"

#.  PowerPC, ARM, tile
#.  First appeared on ARM, as arm_sync_file_range(), but later renamed
#.  \fBsys_debug_setcontext\fP(2)	???	PowerPC if CONFIG_PPC32
#. type: tbl table
#: man-pages/man2/syscalls.2:554
#, no-wrap
msgid "B<syncfs>(2)\t2.6.39\n"
msgstr "B<syncfs>(2)\t2.6.39\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:555
#, no-wrap
msgid "B<sysfs>(2)\t1.2\n"
msgstr "B<sysfs>(2)\t1.2\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:556
#, no-wrap
msgid "B<sysinfo>(2)\t1.0\n"
msgstr "B<sysinfo>(2)\t1.0\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:557
#, no-wrap
msgid "B<syslog>(2)\t1.0\n"
msgstr "B<syslog>(2)\t1.0\n"

#.  glibc interface is \fBklogctl\fP(3)
#. type: tbl table
#: man-pages/man2/syscalls.2:559
#, no-wrap
msgid "B<tee>(2)\t2.6.17\n"
msgstr "B<tee>(2)\t2.6.17\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:560
#, no-wrap
msgid "B<tgkill>(2)\t2.6\n"
msgstr "B<tgkill>(2)\t2.6\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:561
#, no-wrap
msgid "B<time>(2)\t1.0\n"
msgstr "B<time>(2)\t1.0\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:562
#, no-wrap
msgid "B<timer_create>(2)\t2.6\n"
msgstr "B<timer_create>(2)\t2.6\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:563
#, no-wrap
msgid "B<timer_delete>(2)\t2.6\n"
msgstr "B<timer_delete>(2)\t2.6\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:564
#, no-wrap
msgid "B<timer_getoverrun>(2)\t2.6\n"
msgstr "B<timer_getoverrun>(2)\t2.6\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:565
#, no-wrap
msgid "B<timer_gettime>(2)\t2.6\n"
msgstr "B<timer_gettime>(2)\t2.6\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:566
#, no-wrap
msgid "B<timer_settime>(2)\t2.6\n"
msgstr "B<timer_settime>(2)\t2.6\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:567
#, no-wrap
msgid "B<timerfd_create>(2)\t2.6.25\n"
msgstr "B<timerfd_create>(2)\t2.6.25\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:568
#, no-wrap
msgid "B<timerfd_gettime>(2)\t2.6.25\n"
msgstr "B<timerfd_gettime>(2)\t2.6.25\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:569
#, no-wrap
msgid "B<timerfd_settime>(2)\t2.6.25\n"
msgstr "B<timerfd_settime>(2)\t2.6.25\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:570
#, no-wrap
msgid "B<times>(2)\t1.0\n"
msgstr "B<times>(2)\t1.0\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:571
#, no-wrap
msgid "B<tkill>(2)\t2.6; 2.4.22\n"
msgstr "B<tkill>(2)\t2.6; 2.4.22\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:572
#, no-wrap
msgid "B<truncate>(2)\t1.0\n"
msgstr "B<truncate>(2)\t1.0\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:573
#, no-wrap
msgid "B<truncate64>(2)\t2.4\n"
msgstr "B<truncate64>(2)\t2.4\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:574
#, no-wrap
msgid "B<ugetrlimit>(2)\t2.4\n"
msgstr "B<ugetrlimit>(2)\t2.4\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:575
#, no-wrap
msgid "B<umask>(2)\t1.0\n"
msgstr "B<umask>(2)\t1.0\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:576
#, no-wrap
msgid "B<umount>(2)\t1.0\n"
msgstr "B<umount>(2)\t1.0\n"

#.  sys_oldumount() -- __NR_umount
#. type: tbl table
#: man-pages/man2/syscalls.2:578
#, no-wrap
msgid "B<umount2>(2)\t2.2\n"
msgstr "B<umount2>(2)\t2.2\n"

#.  sys_umount() -- __NR_umount2
#. type: tbl table
#: man-pages/man2/syscalls.2:580
#, no-wrap
msgid "B<uname>(2)\t1.0\n"
msgstr "B<uname>(2)\t1.0\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:581
#, no-wrap
msgid "B<unlink>(2)\t1.0\n"
msgstr "B<unlink>(2)\t1.0\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:582
#, no-wrap
msgid "B<unlinkat>(2)\t2.6.16\n"
msgstr "B<unlinkat>(2)\t2.6.16\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:583
#, no-wrap
msgid "B<unshare>(2)\t2.6.16\n"
msgstr "B<unshare>(2)\t2.6.16\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:584
#, no-wrap
msgid "B<uselib>(2)\t1.0\n"
msgstr "B<uselib>(2)\t1.0\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:585
#, no-wrap
msgid "B<ustat>(2)\t1.0\n"
msgstr "B<ustat>(2)\t1.0\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:586
#, no-wrap
msgid "B<utime>(2)\t1.0\n"
msgstr "B<utime>(2)\t1.0\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:587
#, no-wrap
msgid "B<utimensat>(2)\t2.6.22\n"
msgstr "B<utimensat>(2)\t2.6.22\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:588
#, no-wrap
msgid "B<utimes>(2)\t2.2\n"
msgstr "B<utimes>(2)\t2.2\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:589
#, no-wrap
msgid "B<utrap_install>(2)\t2.2\tSparc\n"
msgstr "B<utrap_install>(2)\t2.2\tSparc\n"

#.  FIXME: document utrap_install()
#.  There's a man page for Solaris 5.11
#. type: tbl table
#: man-pages/man2/syscalls.2:592
#, no-wrap
msgid "B<vfork>(2)\t2.2\n"
msgstr "B<vfork>(2)\t2.2\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:593
#, no-wrap
msgid "B<vhangup>(2)\t1.0\n"
msgstr "B<vhangup>(2)\t1.0\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:594
#, no-wrap
msgid "B<vm86old>(2)\t1.0\tT{\n"
msgstr "B<vm86old>(2)\t1.0\tT{\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:595
#, no-wrap
msgid "Was \"vm86\"; renamed in\n"
msgstr "ранее «vm86»; переименован в\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:596
#, no-wrap
msgid "2.0.28/2.2\n"
msgstr "2.0.28/2.2\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:598
#, no-wrap
msgid "B<vm86>(2)\t2.0.28; 2.2\n"
msgstr "B<vm86>(2)\t2.0.28; 2.2\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:599
#, no-wrap
msgid "B<vmsplice>(2)\t2.6.17\n"
msgstr "B<vmsplice>(2)\t2.6.17\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:600
#, no-wrap
msgid "B<wait4>(2)\t1.0\n"
msgstr "B<wait4>(2)\t1.0\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:601
#, no-wrap
msgid "B<waitid>(2)\t2.6.10\n"
msgstr "B<waitid>(2)\t2.6.10\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:602
#, no-wrap
msgid "B<waitpid>(2)\t1.0\n"
msgstr "B<waitpid>(2)\t1.0\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:603
#, no-wrap
msgid "B<write>(2)\t1.0\n"
msgstr "B<write>(2)\t1.0\n"

#. type: tbl table
#: man-pages/man2/syscalls.2:604
#, no-wrap
msgid "B<writev>(2)\t2.0\n"
msgstr "B<writev>(2)\t2.0\n"

#. type: Plain text
#: man-pages/man2/syscalls.2:613
msgid ""
"On many platforms, including x86-32, socket calls are all multiplexed (via "
"glibc wrapper functions) through B<socketcall>(2)  and similarly System\\ V "
"IPC calls are multiplexed through B<ipc>(2)."
msgstr "Для многих платформ, включая x86-32, все сокетные вызовы мультиплексируются (с помощью обёрточных функций glibc) через B<socketcall>(2), а подобные IPC вызовы System\\ V мультиплексируются через B<ipc>(2)."

#.  __NR_afs_syscall is 53 on Linux 2.6.22/i386
#.  __NR_break is 17 on Linux 2.6.22/i386
#.  __NR_ftime is 35 on Linux 2.6.22/i386
#.  __NR_getpmsg is 188 on Linux 2.6.22/i386
#.  __NR_gtty is 32 on Linux 2.6.22/i386
#.  __NR_idle is 112 on Linux 2.6.22/i386
#.  __NR_lock is 53 on Linux 2.6.22/i386
#.  __NR_madvise1 is 219 on Linux 2.6.22/i386
#.  __NR_mpx is 66 on Linux 2.6.22/i386
#.  Slot has been reused
#.  __NR_prof is 44 on Linux 2.6.22/i386
#.  __NR_profil is 98 on Linux 2.6.22/i386
#.  __NR_putpmsg is 189 on Linux 2.6.22/i386
#.  __NR_security is 223 on Linux 2.4/i386
#.  __NR_security is 223 on Linux 2.4/i386; absent on 2.6/i386, present
#.  on a couple of 2.6 architectures
#.  __NR_stty is 31 on Linux 2.6.22/i386
#.  The security call is for future use.
#.  __NR_tuxcall is 184 on x86_64, also on PPC and alpha
#.  __NR_ulimit is 58 on Linux 2.6.22/i386
#.  __NR_vserver is 273 on Linux 2.6.22/i386
#. type: Plain text
#: man-pages/man2/syscalls.2:658
msgid ""
"Although slots are reserved for them in the system call table, the following"
" system calls are not implemented in the standard kernel: B<afs_syscall>(2),"
" B<break>(2), B<ftime>(2), B<getpmsg>(2), B<gtty>(2), B<idle>(2), "
"B<lock>(2), B<madvise1>(2), B<mpx>(2), B<phys>(2), B<prof>(2), B<profil>(2),"
" B<putpmsg>(2), B<security>(2), B<stty>(2), B<tuxcall>(2), B<ulimit>(2), and"
" B<vserver>(2)  (see also B<unimplemented>(2)).  However, B<ftime>(3), "
"B<profil>(3), and B<ulimit>(3)  exist as library routines.  The slot for "
"B<phys>(2)  is in use since kernel 2.1.116 for B<umount>(2); B<phys>(2)  "
"will never be implemented.  The B<getpmsg>(2)  and B<putpmsg>(2)  calls are "
"for kernels patched to support STREAMS, and may never be in the standard "
"kernel."
msgstr ""

#. type: Plain text
#: man-pages/man2/syscalls.2:663
msgid ""
"There was briefly B<set_zone_reclaim>(2), added in Linux 2.6.13, and removed"
" in 2.6.16; this system call was never available to user space."
msgstr "На короткое время появлялся B<set_zone_reclaim>(2), добавленный в Linux 2.6.13 и удалённый в 2.6.16; данный системный вызов никогда не был доступен из пользовательского пространства."

#. type: Plain text
#: man-pages/man2/syscalls.2:680
msgid ""
"Roughly speaking, the code belonging to the system call with number __NR_xxx"
" defined in I</usr/include/asm/unistd.h> can be found in the Linux kernel "
"source in the routine I<sys_xxx>().  (The dispatch table for i386 can be "
"found in I</usr/src/linux/arch/i386/kernel/entry.S>.)  There are many "
"exceptions, however, mostly because older system calls were superseded by "
"newer ones, and this has been treated somewhat unsystematically.  On "
"platforms with proprietary operating-system emulation, such as parisc, "
"sparc, sparc64, and alpha, there are many additional system calls; mips64 "
"also contains a full set of 32-bit system calls."
msgstr "Чаще всего, код системного вызова с номером __NR_xxx, определённого в I</usr/include/asm/unistd.h>, можно найти в исходном коде ядра Linux в функции I<sys_xxx>(). (Таблицу вызовов для i386 можно найти в I</usr/src/linux/arch/i386/kernel/entry.S>.) Есть много исключений из этого правила, в основном из-за того, что большинство старых системных вызовов заменена на новые, при чём без всякой системы. На платформах с эмуляцией собственнических ОС, таких как parisc, sparc, sparc64 и alpha, существует много дополнительных системных вызовов; для mips64 также есть полный набор 32-битных системных вызовов."

#. type: Plain text
#: man-pages/man2/syscalls.2:699
msgid ""
"Over time, changes to the interfaces of some system calls have been "
"necessary.  One reason for such changes was the need to increase the size of"
" structures or scalar values passed to the system call.  Because of these "
"changes, there are now various groups of related system calls (e.g., "
"B<truncate>(2)  and B<truncate64>(2))  which perform similar tasks, but "
"which vary in details such as the size of their arguments.  (As noted "
"earlier, applications are generally unaware of this: the glibc wrapper "
"functions do some work to ensure that the right system call is invoked, and "
"that ABI compatibility is preserved for old binaries.)  Examples of systems "
"calls that exist in multiple versions are the following:"
msgstr "С течением времени при необходимости происходили изменения в интерфейсе некоторых системных вызовов. Одной из причин таких изменений была необходимость увеличения размера структур или скалярных значений передаваемых системному вызову. Из-за этих изменений появились различные группы похожих системных вызовов (например, B<truncate>(2) и B<truncate64>(2)), которые выполняют одинаковые задачи, но отличаются размером своих аргументов. (Как уже отмечалось, на приложения это не влияет: обёрточные функции glibc выполняют некоторые действия по запуску правильного системного вызова, и это обеспечивает совместимость по ABI для старых двоичных файлов.) Примеры системных вызовов, у которых есть несколько версий:"

#.  e.g., on 2.6.22/i386: __NR_oldstat 18, __NR_stat 106, __NR_stat64 195
#.  The stat system calls deal with three different data structures,
#.  defined in include/asm-i386/stat.h: __old_kernel_stat, stat, stat64
#. type: Plain text
#: man-pages/man2/syscalls.2:720
msgid ""
"By now there are three different versions of B<stat>(2): I<sys_stat>()  "
"(slot I<__NR_oldstat>), I<sys_newstat>()  (slot I<__NR_stat>), and "
"I<sys_stat64>()  (slot I<__NR_stat64>), with the last being the most "
"current.  A similar story applies for B<lstat>(2)  and B<fstat>(2)."
msgstr "В настоящее время есть три различные версии B<stat>(2): I<sys_stat>() (место I<__NR_oldstat>), I<sys_newstat>() (место I<__NR_stat>) и I<sys_stat64>() (место I<__NR_stat64>), последняя используется в в данный момент. Похожая ситуация с B<lstat>(2) и B<fstat>(2)."

#. type: Plain text
#: man-pages/man2/syscalls.2:731
msgid ""
"Similarly, the defines I<__NR_oldolduname>, I<__NR_olduname>, and "
"I<__NR_uname> refer to the routines I<sys_olduname>(), I<sys_uname>()  and "
"I<sys_newuname>()."
msgstr "Похожим образом определены I<__NR_oldolduname>, I<__NR_olduname> иI<__NR_uname> для вызовов I<sys_olduname>(), I<sys_uname>() и I<sys_newuname>()."

#. type: Plain text
#: man-pages/man2/syscalls.2:738
msgid ""
"In Linux 2.0, a new version of B<vm86>(2)  appeared, with the old and the "
"new kernel routines being named I<sys_vm86old>()  and I<sys_vm86>()."
msgstr "В Linux 2.0 появилась новая версия B<vm86>(2), новая и старая версии ядерных процедур называются I<sys_vm86old>() и I<sys_vm86>()."

#. type: Plain text
#: man-pages/man2/syscalls.2:749
msgid ""
"In Linux 2.4, a new version of B<getrlimit>(2)  appeared, with the old and "
"the new kernel routines being named I<sys_old_getrlimit>()  (slot "
"I<__NR_getrlimit>)  and I<sys_getrlimit>()  (slot I<__NR_ugetrlimit>)."
msgstr "В Linux 2.4 появилась новая версия B<getrlimit>(2) новая и старая версии ядерных процедур называются I<sys_old_getrlimit>() (место I<__NR_getrlimit>) и I<sys_getrlimit>() (место I<__NR_ugetrlimit>)."

#.  64-bit off_t changes: ftruncate64, *stat64,
#.  fcntl64 (because of the flock structure), getdents64, *statfs64
#. type: Plain text
#: man-pages/man2/syscalls.2:761
msgid ""
"Linux 2.4 increased the size of user and group IDs from 16 to 32 bits.  To "
"support this change, a range of system calls were added (e.g., "
"B<chown32>(2), B<getuid32>(2), B<getgroups32>(2), B<setresuid32>(2)), "
"superseding earlier calls of the same name without the \"32\" suffix."
msgstr "В Linux 2.4 увеличено размер поля ID пользователей и групп с 16 до 32 бит. Для поддержки этого изменения добавлено несколько системных вызовов (например, B<chown32>(2), B<getuid32>(2), B<getgroups32>(2), B<setresuid32>(2)), упраздняющих ранние вызовы с теми же именами, но без суффикса \"32\"."

#. type: Plain text
#: man-pages/man2/syscalls.2:778
msgid ""
"Linux 2.4 added support for applications on 32-bit architectures to access "
"large files (i.e., files for which the sizes and file offsets can't be "
"represented in 32 bits.)  To support this change, replacements were required"
" for system calls that deal with file offsets and sizes.  Thus the following"
" system calls were added: B<fcntl64>(2), B<ftruncate64>(2), "
"B<getdents64>(2), B<stat64>(2), B<statfs64>(2), and their analogs that work "
"with file descriptors or symbolic links.  These system calls supersede the "
"older system calls which, except in the case of the \"stat\" calls, have the"
" same name without the \"64\" suffix."
msgstr "В Linux 2.4 добавлена поддержка доступа к большим файлам (у которых размеры и смещения не умещаются в 32 бита) в приложениях на 32-битных архитектурах. Для этого потребовалось внести изменения в системные вызовы, работающие с размерами и смещениями по файлам. Были добавлены следующие системные вызовы: B<fcntl64>(2), B<ftruncate64>(2), B<getdents64>(2), B<stat64>(2), B<statfs64>(2) и их аналоги, которые обрабатывают файловые дескрипторы или символьные ссылки. Эти системные вызовы упраздняют старые системные вызовы, которые, за исключением вызовов \"stat\", называются также, но не имеют суффикса \"64\"."

#. type: Plain text
#: man-pages/man2/syscalls.2:782
msgid ""
"On newer platforms that only have 64-bit file access and 32-bit uids (e.g., "
"alpha, ia64, s390x) there are no *64 or *32 calls.  Where the *64 and *32 "
"calls exist, the other versions are obsolete."
msgstr "На новых платформах, которые имеют 64-битный доступ к файлам и 32-битные uid (например, alpha, ia64, s390x), нет ни *64 ни *32 вызовов. Там, где есть *64 и *32 вызовы, другие версии считаются устаревшими."

#. type: Plain text
#: man-pages/man2/syscalls.2:790
msgid ""
"The I<rt_sig*> calls were added in kernel 2.2 to support the addition of "
"real-time signals (see B<signal>(7)).  These system calls supersede the "
"older system calls of the same name without the \"rt_\" prefix."
msgstr "Вызовы I<rt_sig*> добавлены в ядро 2.2 для поддержки дополнительных сигналов реального времени (см. B<signal>(7)). Эти системные вызовы упраздняют старые системные вызовы с теми же именами, но без префикса \"rt_\"."

#.  (used by libc 6)
#.  .PP
#.  Two system call numbers,
#.  .IR __NR__llseek
#.  and
#.  .IR __NR__sysctl
#.  have an additional underscore absent in
#.  .IR sys_llseek ()
#.  and
#.  .IR sys_sysctl ().
#.  In kernel 2.1.81,
#.  .BR lchown (2)
#.  and
#.  .BR chown (2)
#.  were swapped; that is,
#.  .BR lchown (2)
#.  was added with the semantics that were then current for
#.  .BR chown (2),
#.  and the semantics of the latter call were changed to what
#.  they are today.
#. type: Plain text
#: man-pages/man2/syscalls.2:840
msgid ""
"The B<select>(2)  and B<mmap>(2)  system calls use five or more arguments, "
"which caused problems in the way argument passing on the i386 used to be set"
" up.  Thus, while other architectures have I<sys_select>()  and "
"I<sys_mmap>()  corresponding to I<__NR_select> and I<__NR_mmap>, on i386 one"
" finds I<old_select>()  and I<old_mmap>()  (routines that use a pointer to a"
" argument block) instead.  These days passing five arguments is not a "
"problem any more, and there is a I<__NR__newselect> that corresponds "
"directly to I<sys_select>()  and similarly I<__NR_mmap2>."
msgstr "В системных вызовах B<select>(2) и B<mmap>(2) используется пять или более аргументов, что вызывало проблемы определения способа передачи аргументов на i386. В следствии этого, тогда как на других архитектурах вызовы I<sys_select>() и I<sys_mmap>() соответствуют I<__NR_select> и I<__NR_mmap>, на i386 они соответствуют I<old_select>() и I<old_mmap>() (процедуры, использующие указатель на блок аргументов). В настоящее время больше нет проблемы с передачей более пяти аргументов и есть I<__NR__newselect>, который соответствует именно I<sys_select>(), и такая же ситуация с I<__NR_mmap2>."

#. type: Plain text
#: man-pages/man2/syscalls.2:845
msgid ""
"B<intro>(2), B<syscall>(2), B<unimplemented>(2), B<libc>(7), B<vdso>(7)"
msgstr "B<intro>(2), B<syscall>(2), B<unimplemented>(2), B<libc>(7), B<vdso>(7)"

#. type: TH
#: man-pages/man2/send.2:40
#, no-wrap
msgid "SEND"
msgstr "SEND"

#. type: Plain text
#: man-pages/man2/send.2:43
msgid "send, sendto, sendmsg - send a message on a socket"
msgstr "send, sendto, sendmsg - отправляет сообщения в сокет"

#. type: Plain text
#: man-pages/man2/send.2:47
#, no-wrap
msgid ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>sys/socket.hE<gt>>\n"
msgstr "B<#include E<lt>sys/types.hE<gt>>\nB<#include E<lt>sys/socket.hE<gt>>\n"

#. type: Plain text
#: man-pages/man2/send.2:50
#, no-wrap
msgid ""
"B<ssize_t send(int >I<sockfd>B<, const void *>I<buf>B<, size_t >I<len>B<, "
"int >I<flags>B<);>\n"
msgstr "B<ssize_t send(int >I<sockfd>B<, const void *>I<buf>B<, size_t >I<len>B<, int >I<flags>B<);>\n"

#. type: Plain text
#: man-pages/man2/send.2:54
#, no-wrap
msgid ""
"B<ssize_t sendto(int >I<sockfd>B<, const void *>I<buf>B<, size_t >I<len>B<, int >I<flags>B<,>\n"
"B<               const struct sockaddr *>I<dest_addr>B<, socklen_t >I<addrlen>B<);>\n"
msgstr "B<ssize_t sendto(int >I<sockfd>B<, const void *>I<buf>B<, size_t >I<len>B<, int >I<flags>B<,>\nB<               const struct sockaddr *>I<dest_addr>B<, socklen_t >I<addrlen>B<);>\n"

#. type: Plain text
#: man-pages/man2/send.2:57
#, no-wrap
msgid ""
"B<ssize_t sendmsg(int >I<sockfd>B<, const struct msghdr *>I<msg>B<, int "
">I<flags>B<);>\n"
msgstr "B<ssize_t sendmsg(int >I<sockfd>B<, const struct msghdr *>I<msg>B<, int >I<flags>B<);>\n"

#. type: Plain text
#: man-pages/man2/send.2:65
msgid ""
"The system calls B<send>(), B<sendto>(), and B<sendmsg>()  are used to "
"transmit a message to another socket."
msgstr "Системные вызовы B<send>(), B<sendto>() и B<sendmsg>() используются для пересылки сообщений в другой сокет."

#. type: Plain text
#: man-pages/man2/send.2:84
msgid ""
"The B<send>()  call may be used only when the socket is in a I<connected> "
"state (so that the intended recipient is known).  The only difference "
"between B<send>()  and B<write>(2)  is the presence of I<flags>.  With a "
"zero I<flags> argument, B<send>()  is equivalent to B<write>(2).  Also, the "
"following call"
msgstr "Вызов B<send>() можно использовать, только если сокет находится в состоянии I<соединения> (то есть известен получатель). Вызов B<send>() отличается от B<write>(2) только наличием аргумента I<flags>. Если значение I<flags> равно нулю, то вызов B<send>() эквивалентен B<write>(2). Также, вызов"

#. type: Plain text
#: man-pages/man2/send.2:86
#, no-wrap
msgid "    send(sockfd, buf, len, flags);\n"
msgstr "    send(sockfd, buf, len, flags);\n"

#. type: Plain text
#: man-pages/man2/send.2:88
msgid "is equivalent to"
msgstr "эквивалентен"

#. type: Plain text
#: man-pages/man2/send.2:90
#, no-wrap
msgid "    sendto(sockfd, buf, len, flags, NULL, 0);\n"
msgstr "    sendto(sockfd, buf, len, flags, NULL, 0);\n"

#. type: Plain text
#: man-pages/man2/send.2:94
msgid "The argument I<sockfd> is the file descriptor of the sending socket."
msgstr "Аргумент I<sockfd> представляет файловый дескриптор сокета отправления."

#. type: Plain text
#: man-pages/man2/send.2:122
msgid ""
"If B<sendto>()  is used on a connection-mode (B<SOCK_STREAM>, "
"B<SOCK_SEQPACKET>)  socket, the arguments I<dest_addr> and I<addrlen> are "
"ignored (and the error B<EISCONN> may be returned when they are not NULL and"
" 0), and the error B<ENOTCONN> is returned when the socket was not actually "
"connected.  Otherwise, the address of the target is given by I<dest_addr> "
"with I<addrlen> specifying its size.  For B<sendmsg>(), the address of the "
"target is given by I<msg.msg_name>, with I<msg.msg_namelen> specifying its "
"size."
msgstr "Если B<sendto>() используется с сокетом в режиме с установлением соединения (B<SOCK_STREAM>, B<SOCK_SEQPACKET>), то аргументы I<dest_addr> и I<addrlen> игнорируются (и может быть возвращена ошибка B<EISCONN>, если их значения не равны NULL и 0) и возвращается ошибка B<ENOTCONN>, если соединение через сокет не установлено. Иначе в I<dest_addr> задаётся адрес назначения и его размер в I<addrlen>. Для B<sendmsg>() адрес назначения указывается в I<msg.msg_name>, а его размер в I<msg.msg_namelen>."

#. type: Plain text
#: man-pages/man2/send.2:138
msgid ""
"For B<send>()  and B<sendto>(), the message is found in I<buf> and has "
"length I<len>.  For B<sendmsg>(), the message is pointed to by the elements "
"of the array I<msg.msg_iov>.  The B<sendmsg>()  call also allows sending "
"ancillary data (also known as control information)."
msgstr "У B<send>() и B<sendto>() сообщение находится в I<buf>, а его длина в I<len>. У B<sendmsg>() сообщение указывается в элементах массива I<msg.msg_iov>. Вызов B<sendmsg>() также позволяет отправлять вспомогательные данные (так называемую управляющую информацию)."

#. type: Plain text
#: man-pages/man2/send.2:143
msgid ""
"If the message is too long to pass atomically through the underlying "
"protocol, the error B<EMSGSIZE> is returned, and the message is not "
"transmitted."
msgstr "Если сообщение слишком длинно для передачи за раз через используемый нижележащий протокол, то возвращается ошибка B<EMSGSIZE> и сообщение не передаётся."

#. type: Plain text
#: man-pages/man2/send.2:147
msgid ""
"No indication of failure to deliver is implicit in a B<send>().  Locally "
"detected errors are indicated by a return value of -1."
msgstr "Неудачная отправка с помощью B<send>() никак не отмечается. При обнаружении локальных ошибок возвращается значение -1."

#. type: Plain text
#: man-pages/man2/send.2:160
msgid ""
"When the message does not fit into the send buffer of the socket, B<send>()"
"  normally blocks, unless the socket has been placed in nonblocking I/O "
"mode.  In nonblocking mode it would fail with the error B<EAGAIN> or "
"B<EWOULDBLOCK> in this case.  The B<select>(2)  call may be used to "
"determine when it is possible to send more data."
msgstr "Когда сообщение не помещается в буфер отправки сокета, выполнение блокируется в B<send>(), если сокет не находится в неблокирующем режиме. Если сокет находится в неблокирующем режиме, то  возвращается ошибка B<EAGAIN> или B<EWOULDBLOCK>. Для выяснения, возможна ли отправка данных, можно использовать вызов B<select>(2)."

#. type: SS
#: man-pages/man2/send.2:160
#, no-wrap
msgid "The flags argument"
msgstr "Аргумент флагов"

#.  FIXME ? document MSG_PROXY (which went away in 2.3.15)
#. type: Plain text
#: man-pages/man2/send.2:166
msgid ""
"The I<flags> argument is the bitwise OR of zero or more of the following "
"flags."
msgstr "Аргумент I<flags> является битовой маской и может содержать следующие флаги:"

#. type: TP
#: man-pages/man2/send.2:166
#, no-wrap
msgid "B<MSG_CONFIRM> (since Linux 2.3.15)"
msgstr "B<MSG_CONFIRM> (начиная с Linux 2.3.15)"

#. type: Plain text
#: man-pages/man2/send.2:180
msgid ""
"Tell the link layer that forward progress happened: you got a successful "
"reply from the other side.  If the link layer doesn't get this it will "
"regularly reprobe the neighbor (e.g., via a unicast ARP).  Only valid on "
"B<SOCK_DGRAM> and B<SOCK_RAW> sockets and currently implemented only for "
"IPv4 and IPv6.  See B<arp>(7)  for details."
msgstr "Сообщить уровню связи, что процесс пересылки произошел: вы получили успешный ответ с другой стороны. Если уровень связи не получит его, то он будет регулярно перепроверять наличие ответной стороны (например посредством однонаправленной передачи ARP). Это работает только с сокетами B<SOCK_DGRAM> и B<SOCK_RAW> и в настоящее время реализовано только для IPv4 и IPv6. В B<arp>(7) представлена более подробная информация."

#. type: TP
#: man-pages/man2/send.2:180
#, no-wrap
msgid "B<MSG_DONTROUTE>"
msgstr "B<MSG_DONTROUTE>"

#. type: Plain text
#: man-pages/man2/send.2:188
msgid ""
"Don't use a gateway to send out the packet, send to hosts only on directly "
"connected networks.  This is usually used only by diagnostic or routing "
"programs.  This is defined only for protocol families that route; packet "
"sockets don't."
msgstr "Не использовать маршрутизацию для отправки пакета, а посылать его только на узлы локальной сети. Обычно это используется в диагностических программах и программах маршрутизации. Этот флаг определён только для маршрутизируемых семейств протоколов; пакетные сокеты не используют маршрутизацию."

#. type: TP
#: man-pages/man2/send.2:188
#, no-wrap
msgid "B<MSG_DONTWAIT> (since Linux 2.2)"
msgstr "B<MSG_DONTWAIT> (начиная с Linux 2.2)"

#. type: Plain text
#: man-pages/man2/send.2:199
msgid ""
"Enables nonblocking operation; if the operation would block, B<EAGAIN> or "
"B<EWOULDBLOCK> is returned (this can also be enabled using the B<O_NONBLOCK>"
" flag with the B<F_SETFL> B<fcntl>(2))."
msgstr "Включить неблокирующий режим. Если операция могла бы привести к блокировке, возвращается B<EAGAIN> или B<EWOULDBLOCK> (этот режим можно также включить с помощью флага B<O_NONBLOCK> и операции B<F_SETFL> через вызов B<fcntl>(2))."

#. type: TP
#: man-pages/man2/send.2:199
#, no-wrap
msgid "B<MSG_EOR> (since Linux 2.2)"
msgstr "B<MSG_EOR> (начиная с Linux 2.2)"

#. type: Plain text
#: man-pages/man2/send.2:203
msgid ""
"Terminates a record (when this notion is supported, as for sockets of type "
"B<SOCK_SEQPACKET>)."
msgstr "Завершить запись (record) (если поддерживается, например в сокетах типа B<SOCK_SEQPACKET>)."

#. type: TP
#: man-pages/man2/send.2:203
#, no-wrap
msgid "B<MSG_MORE> (since Linux 2.4.4)"
msgstr "B<MSG_MORE> (начиная с Linux 2.4.4)"

#. type: Plain text
#: man-pages/man2/send.2:212
msgid ""
"The caller has more data to send.  This flag is used with TCP sockets to "
"obtain the same effect as the B<TCP_CORK> socket option (see B<tcp>(7)), "
"with the difference that this flag can be set on a per-call basis."
msgstr "Вызывающий имеет дополнительные данные для отправки. Этот флаг используется с сокетами TCP для получения такого же эффекта как с параметром сокета B<TCP_CORK> (см. B<tcp>(7)), с той разницей, что этот флаг можно устанавливать при каждом вызове."

#. type: Plain text
#: man-pages/man2/send.2:221
msgid ""
"Since Linux 2.6, this flag is also supported for UDP sockets, and informs "
"the kernel to package all of the data sent in calls with this flag set into "
"a single datagram which is transmitted only when a call is performed that "
"does not specify this flag.  (See also the B<UDP_CORK> socket option "
"described in B<udp>(7).)"
msgstr "Начиная с Linux 2.6 этот флаг также поддерживается для сокетов UDP и информирует ядро, о том что нужно упаковать все отправляемые данные вызовов с этим флагом в одну дейтаграмму, которая передаётся только когда выполняется вызов без указания этого флага (смотрите также описание параметра сокета B<UDP_CORK> в B<udp>(7))."

#. type: TP
#: man-pages/man2/send.2:221
#, no-wrap
msgid "B<MSG_NOSIGNAL> (since Linux 2.2)"
msgstr "B<MSG_NOSIGNAL> (начиная с Linux 2.2)"

#. type: Plain text
#: man-pages/man2/send.2:230
msgid ""
"Requests not to send B<SIGPIPE> on errors on stream oriented sockets when "
"the other end breaks the connection.  The B<EPIPE> error is still returned."
msgstr "Требовать не посылать сигнал B<SIGPIPE>, если при работе с ориентированным на поток сокетом другая сторона обрывает соединение. Код ошибки B<EPIPE> возвращается по-прежнему."

#. type: TP
#: man-pages/man2/send.2:230
#, no-wrap
msgid "B<MSG_OOB>"
msgstr "B<MSG_OOB>"

#. type: Plain text
#: man-pages/man2/send.2:239
msgid ""
"Sends I<out-of-band> data on sockets that support this notion (e.g., of type"
" B<SOCK_STREAM>); the underlying protocol must also support I<out-of-band> "
"data."
msgstr "Послать I<внепоточные данные>, если сокет это поддерживает (как, например, сокеты типа B<SOCK_STREAM>); протокол более низкого уровня также должен поддерживать I<внепоточные данные>. "

#. type: SS
#: man-pages/man2/send.2:239
#, no-wrap
msgid "sendmsg()"
msgstr "sendmsg()"

#. type: Plain text
#: man-pages/man2/send.2:245
msgid ""
"The definition of the I<msghdr> structure employed by B<sendmsg>()  is as "
"follows:"
msgstr "Определение структуры I<msghdr>, используемой B<sendmsg>():"

#. type: Plain text
#: man-pages/man2/send.2:257
#, no-wrap
msgid ""
"struct msghdr {\n"
"    void         *msg_name;       /* optional address */\n"
"    socklen_t     msg_namelen;    /* size of address */\n"
"    struct iovec *msg_iov;        /* scatter/gather array */\n"
"    size_t        msg_iovlen;     /* # elements in msg_iov */\n"
"    void         *msg_control;    /* ancillary data, see below */\n"
"    size_t        msg_controllen; /* ancillary data buffer len */\n"
"    int           msg_flags;      /* flags (unused) */\n"
"};\n"
msgstr "struct msghdr {\n    void         *msg_name;       /* необязательный адрес */\n    socklen_t     msg_namelen;    /* размер адреса */\n    struct iovec *msg_iov;        /* массив приёма/передачи */\n    size_t        msg_iovlen;     /* # количество элементов в msg_iov */\n    void         *msg_control;    /* вспомогательные данные,\n                                     смотрите ниже */\n    size_t        msg_controllen; /* размер буфера вспомогательных\n                                     данных */\n    int           msg_flags;      /* флаги (не используется) */\n};\n"

#. type: Plain text
#: man-pages/man2/send.2:269
msgid ""
"The I<msg_name> field is used on an unconnected socket to specify the target"
" address for a datagram.  It points to a buffer containing the address; the "
"I<msg_namelen> field should be set to the size of the address.  For a "
"connected socket, these fields should be specified as NULL and 0, "
"respectively."
msgstr "Поле I<msg_name> используется на неподключённом сокете для указания адреса назначения дейтаграммы. Оно указывает на буфер с адресом; в поле I<msg_namelen> должен быть указан размер адреса. Для подключённого сокета значения этих полей должны быть равны NULL и 0, соответственно."

#. type: Plain text
#: man-pages/man2/send.2:276
msgid ""
"The I<msg_iov> and I<msg_iovlen> fields specify scatter-gather locations, as"
" for B<writev>(2)."
msgstr "В полях I<msg_iov> и I<msg_iovlen> задаются места приёма/передачи, как для B<writev>(2)."

#. type: Plain text
#: man-pages/man2/send.2:287
msgid ""
"You may send control information using the I<msg_control> and "
"I<msg_controllen> members.  The maximum control buffer length the kernel can"
" process is limited per socket by the value in "
"I</proc/sys/net/core/optmem_max>; see B<socket>(7)."
msgstr "Управляющую информацию можно посылать через поля I<msg_control> и I<msg_controllen>. Максимальная длина управляющего буфера, которую поддерживает ядро, ограничена значением I</proc/sys/net/core/optmem_max>; см. B<socket>(7)."

#.  Still to be documented:
#.   Send file descriptors and user credentials using the
#.   msg_control* fields.
#. type: Plain text
#: man-pages/man2/send.2:294
msgid "The I<msg_flags> field is ignored."
msgstr "Поле I<msg_flags> игнорируется."

#. type: Plain text
#: man-pages/man2/send.2:299
msgid ""
"On success, these calls return the number of bytes sent.  On error, -1 is "
"returned, and I<errno> is set appropriately."
msgstr "При успешном выполнении эти вызовы возвращают количество отправленных байт. В случае ошибки возвращается -1, а I<errno> устанавливается в соответствующее значение."

#. type: Plain text
#: man-pages/man2/send.2:304
msgid ""
"These are some standard errors generated by the socket layer.  Additional "
"errors may be generated and returned from the underlying protocol modules; "
"see their respective manual pages."
msgstr "Здесь представлено несколько стандартных ошибок, возвращаемых с уровня сокетов. Могут также появиться другие ошибки, возвращаемые из соответствующих модулей протоколов; их описание находится в соответствующих справочных страницах."

#. type: Plain text
#: man-pages/man2/send.2:312
msgid ""
"(For UNIX domain sockets, which are identified by pathname)  Write "
"permission is denied on the destination socket file, or search permission is"
" denied for one of the directories the path prefix.  (See "
"B<path_resolution>(7).)"
msgstr "(для доменных сокетов UNIX, которые идентифицируются по имени пути) Нет прав на запись в файл сокета назначения или в одном из каталогов пути запрещён поиск (см. также B<path_resolution>(7))."

#. type: Plain text
#: man-pages/man2/send.2:315
msgid ""
"(For UDP sockets) An attempt was made to send to a network/broadcast address"
" as though it was a unicast address."
msgstr "(для сокетов UDP) Попытка отправки по сетевому/широковещательному адресу, как будто это был однозначный (unicast) адрес."

#. type: TP
#: man-pages/man2/send.2:315
#, no-wrap
msgid "B<EAGAIN> or B<EWOULDBLOCK>"
msgstr "B<EAGAIN> или B<EWOULDBLOCK>"

#.  Actually EAGAIN on Linux
#. type: Plain text
#: man-pages/man2/send.2:323
msgid ""
"The socket is marked nonblocking and the requested operation would block.  "
"POSIX.1-2001 allows either error to be returned for this case, and does not "
"require these constants to have the same value, so a portable application "
"should check for both possibilities."
msgstr "Сокет помечен как неблокирующий, но запрошенная операция привела бы к блокировке. POSIX.1-2001 допускает в этих случаях возврат ошибки и не требует, чтобы эти константы имели одинаковое значение, поэтому переносимое приложение должно проверять обе возможности."

#. type: Plain text
#: man-pages/man2/send.2:336
msgid ""
"(Internet domain datagram sockets)  The socket referred to by I<sockfd> had "
"not previously been bound to an address and, upon attempting to bind it to "
"an ephemeral port, it was determined that all port numbers in the ephemeral "
"port range are currently in use.  See the discussion of "
"I</proc/sys/net/ipv4/ip_local_port_range> in B<ip>(7)."
msgstr "(доменные дейтаграммные сокеты Интернета) Сокет, указанный I<sockfd>, ранее не был привязан к адресу и при попытке привязать его к эфемеридному порту, было определено, что все номера в диапазоне эфемеридных портов уже используются. Смотрите обсуждение I</proc/sys/net/ipv4/ip_local_port_range> в B<ip>(7)."

#. type: Plain text
#: man-pages/man2/send.2:339
msgid "An invalid descriptor was specified."
msgstr "Указан некорректный дескриптор."

#. type: TP
#: man-pages/man2/send.2:339
#, no-wrap
msgid "B<ECONNRESET>"
msgstr "B<ECONNRESET>"

#. type: Plain text
#: man-pages/man2/send.2:342
msgid "Connection reset by peer."
msgstr "Соединение сброшено другой стороной."

#. type: TP
#: man-pages/man2/send.2:342
#, no-wrap
msgid "B<EDESTADDRREQ>"
msgstr "B<EDESTADDRREQ>"

#. type: Plain text
#: man-pages/man2/send.2:345
msgid "The socket is not connection-mode, and no peer address is set."
msgstr "Сокет в режиме без установления соединения и адрес второй стороны не задан."

#. type: Plain text
#: man-pages/man2/send.2:348
msgid "An invalid user space address was specified for an argument."
msgstr "В аргументе указано неверное значение адреса пользовательского пространства."

#. type: Plain text
#: man-pages/man2/send.2:352
msgid "A signal occurred before any data was transmitted; see B<signal>(7)."
msgstr "Получен сигнал до начала передачи данных; смотрите B<signal>(7)."

#. type: Plain text
#: man-pages/man2/send.2:355
msgid "Invalid argument passed."
msgstr "Передан неверный аргумент."

#. type: TP
#: man-pages/man2/send.2:355
#, no-wrap
msgid "B<EISCONN>"
msgstr "B<EISCONN>"

#. type: Plain text
#: man-pages/man2/send.2:361
msgid ""
"The connection-mode socket was connected already but a recipient was "
"specified.  (Now either this error is returned, or the recipient "
"specification is ignored.)"
msgstr "Сокет в режиме с установлением соединения уже выполнил подключение, но указан получатель (теперь или возвращается эта ошибка, или игнорируется указание получателя)."

#. type: TP
#: man-pages/man2/send.2:361
#, no-wrap
msgid "B<EMSGSIZE>"
msgstr "B<EMSGSIZE>"

#.  (e.g., SOCK_DGRAM )
#. type: Plain text
#: man-pages/man2/send.2:367
msgid ""
"The socket type requires that message be sent atomically, and the size of "
"the message to be sent made this impossible."
msgstr "Для типа сокета требуется, чтобы сообщение было отослано за время одной операции (атомарно), а размер сообщения не позволяет этого."

#. type: TP
#: man-pages/man2/send.2:367
#, no-wrap
msgid "B<ENOBUFS>"
msgstr "B<ENOBUFS>"

#. type: Plain text
#: man-pages/man2/send.2:375
msgid ""
"The output queue for a network interface was full.  This generally indicates"
" that the interface has stopped sending, but may be caused by transient "
"congestion.  (Normally, this does not occur in Linux.  Packets are just "
"silently dropped when a device queue overflows.)"
msgstr "Исходящая очередь сетевого интерфейса заполнена. Обычно это означает, что интерфейс прекратил отправку, но это может быть также вызвано временной перегрузкой сети. Обычно, в Linux этого не происходит. Пакеты просто отбрасываются, когда очередь устройства переполняется."

#. type: Plain text
#: man-pages/man2/send.2:378
msgid "No memory available."
msgstr "Больше нет доступной памяти."

#. type: Plain text
#: man-pages/man2/send.2:381
msgid "The socket is not connected, and no target has been given."
msgstr "Сокет не подключён и назначение не задано."

#. type: Plain text
#: man-pages/man2/send.2:386
msgid "The argument I<sockfd> is not a socket."
msgstr "Аргумент I<sockfd> не является сокетом."

#. type: TP
#: man-pages/man2/send.2:386
#, no-wrap
msgid "B<EOPNOTSUPP>"
msgstr "B<EOPNOTSUPP>"

#. type: Plain text
#: man-pages/man2/send.2:391
msgid ""
"Some bit in the I<flags> argument is inappropriate for the socket type."
msgstr "Один из битов в аргументе I<flags> не может устанавливаться для этого типа сокета."

#. type: TP
#: man-pages/man2/send.2:391
#, no-wrap
msgid "B<EPIPE>"
msgstr "B<EPIPE>"

#. type: Plain text
#: man-pages/man2/send.2:400
msgid ""
"The local end has been shut down on a connection oriented socket.  In this "
"case, the process will also receive a B<SIGPIPE> unless B<MSG_NOSIGNAL> is "
"set."
msgstr "Локальный сокет, ориентированный на соединение, был закрыт. В этом случае процесс также получит сигнал B<SIGPIPE>, если не установлен флаг B<MSG_NOSIGNAL>."

#. type: Plain text
#: man-pages/man2/send.2:403
msgid "4.4BSD, SVr4, POSIX.1-2001.  These function calls appeared in 4.2BSD."
msgstr "4.4BSD, SVr4, POSIX.1-2001. Эти системные вызовы впервые появились в 4.2BSD."

#. type: Plain text
#: man-pages/man2/send.2:414
msgid ""
"POSIX.1-2001 describes only the B<MSG_OOB> and B<MSG_EOR> flags.  "
"POSIX.1-2008 adds a specification of B<MSG_NOSIGNAL>.  The B<MSG_CONFIRM> "
"flag is a Linux extension."
msgstr "В POSIX.1-2001 описаны только флаги B<MSG_OOB> и B<MSG_EOR>. В POSIX.1-2008 добавлено описание B<MSG_NOSIGNAL>. Флаг B<MSG_CONFIRM> является нестандартным расширением Linux."

#. type: Plain text
#: man-pages/man2/send.2:427
msgid ""
"The prototypes given above follow the Single UNIX Specification, as glibc2 "
"also does; the I<flags> argument was I<int> in 4.x BSD, but I<unsigned int> "
"in libc4 and libc5; the I<len> argument was I<int> in 4.x BSD and libc4, but"
" I<size_t> in libc5; the I<addrlen> argument was I<int> in 4.x BSD and libc4"
" and libc5.  See also B<accept>(2)."
msgstr "Вышеприведенные прототипы соответствуют Single UNIX Specification, а также glibc2. Аргумент I<flags> в BSD 4.x имеет тип I<int>, но в libc4 и libc5 его тип — I<unsigned int>. Аргумент I<len> в BSD 4.x и libc4 имеет тип I<int>, но в libc5 его тип — I<size_t>. Аргумент I<addrlen> в BSD 4.x, libc4 и libc5 имеет тип I<int>. Смотрите также accept(2)."

#.  glibc bug raised 12 Mar 2006
#.  http://sourceware.org/bugzilla/show_bug.cgi?id=2448
#.  The problem is an underlying kernel issue: the size of the
#.  __kernel_size_t type used to type this field varies
#.  across architectures, but socklen_t is always 32 bits.
#. type: Plain text
#: man-pages/man2/send.2:441
msgid ""
"According to POSIX.1-2001, the I<msg_controllen> field of the I<msghdr> "
"structure should be typed as I<socklen_t>, but glibc currently types it as "
"I<size_t>."
msgstr "В соответствие с POSIX.1-2001 поле I<msg_controllen> структуры I<msghdr> должно иметь тип I<socklen_t>, но в настоящее время в glibc оно имеет тип I<size_t>."

#. type: Plain text
#: man-pages/man2/send.2:446
msgid ""
"See B<sendmmsg>(2)  for information about a Linux-specific system call that "
"can be used to transmit multiple datagrams in a single call."
msgstr "В B<sendmmsg>(2) можно найти информацию о специальном системном вызове Linux, который можно использовать для передачи нескольких дейтаграмм за один вызов."

#. type: Plain text
#: man-pages/man2/send.2:451
msgid "Linux may return B<EPIPE> instead of B<ENOTCONN>."
msgstr "Linux может вернуть B<EPIPE> вместо B<ENOTCONN>."

#. type: Plain text
#: man-pages/man2/send.2:456
msgid "An example of the use of B<sendto>()  is shown in B<getaddrinfo>(3)."
msgstr "Пример использования B<sendto>() показан в B<getaddrinfo>(3)."

#. type: Plain text
#: man-pages/man2/send.2:470
msgid ""
"B<fcntl>(2), B<getsockopt>(2), B<recv>(2), B<select>(2), B<sendfile>(2), "
"B<sendmmsg>(2), B<shutdown>(2), B<socket>(2), B<write>(2), B<cmsg>(3), "
"B<ip>(7), B<socket>(7), B<tcp>(7), B<udp>(7)"
msgstr "B<fcntl>(2), B<getsockopt>(2), B<recv>(2), B<select>(2), B<sendfile>(2), B<sendmmsg>(2), B<shutdown>(2), B<socket>(2), B<write>(2), B<cmsg>(3), B<ip>(7), B<socket>(7), B<tcp>(7), B<udp>(7)"

#. type: TH
#: man-pages/man2/sendfile.2:19
#, no-wrap
msgid "SENDFILE"
msgstr "SENDFILE"

#. type: TH
#: man-pages/man2/sendfile.2:19
#, no-wrap
msgid "2011-09-14"
msgstr "2011-09-14"

#. type: Plain text
#: man-pages/man2/sendfile.2:22
msgid "sendfile - transfer data between file descriptors"
msgstr "sendfile - производит обмен данными между дескрипторами файлов"

#. type: Plain text
#: man-pages/man2/sendfile.2:24
msgid "B<#include E<lt>sys/sendfile.hE<gt>>"
msgstr "B<#include E<lt>sys/sendfile.hE<gt>>"

#.  The below is too ugly. Comments about glibc versions belong
#.  in the notes, not in the header.
#.  .B #include <features.h>
#.  .br
#.  .B #if (__GLIBC__==2 && __GLIBC_MINOR__>=1) || __GLIBC__>2
#.  .br
#.  .B #include <sys/sendfile.h>
#.  .br
#.  #else
#.  .br
#.  .B #include <sys/types.h>
#.  .br
#.  .B /* No system prototype before glibc 2.1. */
#.  .br
#.  .BI "ssize_t sendfile(int" " out_fd" ", int" " in_fd" ", off_t *" #.
#. offset ", size_t" " count" )
#.  .br
#.  .B #endif
#. type: Plain text
#: man-pages/man2/sendfile.2:47
msgid ""
"B<ssize_t sendfile(int>I< out_fd>B<, int>I< in_fd>B<, off_t *>I<offset>B<, "
"size_t>I< count>B<);>"
msgstr "B<ssize_t sendfile(int>I< out_fd>B<, int>I< in_fd>B<, off_t *>I<offset>B<, size_t>I< count>B<);>"

#. type: Plain text
#: man-pages/man2/sendfile.2:57
msgid ""
"B<sendfile>()  copies data between one file descriptor and another.  Because"
" this copying is done within the kernel, B<sendfile>()  is more efficient "
"than the combination of B<read>(2)  and B<write>(2), which would require "
"transferring data to and from user space."
msgstr "Вызов B<sendfile>() копирует данные из одного файлового дескриптора в другой. Так как копирование производится в ядре, использование B<sendfile>() более эффективно чем комбинация B<read>(2) и B<write>(2), в которой требуется скопировать данные в и из пользовательского пространства."

#. type: Plain text
#: man-pages/man2/sendfile.2:62
msgid ""
"I<in_fd> should be a file descriptor opened for reading and I<out_fd> should"
" be a descriptor opened for writing."
msgstr "В I<in_fd> должен указываться файловый дескриптор, открытый для чтения, а в I<out_fd> должен указываться файловый дескриптор, открытый для записи."

#. type: Plain text
#: man-pages/man2/sendfile.2:83
msgid ""
"If I<offset> is not NULL, then it points to a variable holding the file "
"offset from which B<sendfile>()  will start reading data from I<in_fd>.  "
"When B<sendfile>()  returns, this variable will be set to the offset of the "
"byte following the last byte that was read.  If I<offset> is not NULL, then "
"B<sendfile>()  does not modify the current file offset of I<in_fd>; "
"otherwise the current file offset is adjusted to reflect the number of bytes"
" read from I<in_fd>."
msgstr "Если значение I<offset> не равно NULL, то оно указывает на переменную, содержащую файловое смещение с которого B<sendfile>() начнёт чтение данных из I<in_fd>. При завершении B<sendfile>() значение этой переменной будет содержать указатель на следующий байт после последнего прочитанного. Если значение I<offset> не равно NULL, то B<sendfile>() не изменяет текущее файловое смещение I<in_fd>; иначе текущее файловое смещение изменяется для отражения количества прочитанных из I<in_fd> байт."

#. type: Plain text
#: man-pages/man2/sendfile.2:90
msgid ""
"If I<offset> is NULL, then data will be read from I<in_fd> starting at the "
"current file offset, and the file offset will be updated by the call."
msgstr "Если значение I<offset> равно NULL, то данные будут прочитаны из I<in_fd> начиная с текущего файлового смещения, и по окончании работы вызова файловое смещение будет обновлено."

#. type: Plain text
#: man-pages/man2/sendfile.2:93
msgid "I<count> is the number of bytes to copy between the file descriptors."
msgstr "В I<count> содержится количество байт, копируемых между файловыми дескрипторами."

#. type: Plain text
#: man-pages/man2/sendfile.2:100
msgid ""
"The I<in_fd> argument must correspond to a file which supports "
"B<mmap>(2)-like operations (i.e., it cannot be a socket)."
msgstr "Значение I<in_fd> должно описывать файл, который поддерживает операции типа B<mmap>(2) (т.е., не сокет)."

#. type: Plain text
#: man-pages/man2/sendfile.2:108
msgid ""
"In Linux kernels before 2.6.33, I<out_fd> must refer to a socket.  Since "
"Linux 2.6.33 it can be any file.  If it is a regular file, then "
"B<sendfile>()  changes the file offset appropriately."
msgstr "В ядрах Linux до версии 2.6.33, значение I<out_fd> должно указывать на сокет. Начиная с Linux 2.6.33 можно указывать любой файл. Если это обычный файл, то B<sendfile>() изменит файловое смещение соответствующим образом."

#. type: Plain text
#: man-pages/man2/sendfile.2:115
msgid ""
"If the transfer was successful, the number of bytes written to I<out_fd> is "
"returned.  On error, -1 is returned, and I<errno> is set appropriately."
msgstr "Если пересылка прошла успешно, то возвращается количество переданных в I<out_fd> байт. При ошибке возвращается -1, а переменной I<errno> присваивается номер ошибки."

#. type: Plain text
#: man-pages/man2/sendfile.2:121
msgid ""
"Nonblocking I/O has been selected using B<O_NONBLOCK> and the write would "
"block."
msgstr "Был выбран неблокирующий ввод-вывод с помощью B<O_NONBLOCK>, но запись привела бы блокировке."

#. type: Plain text
#: man-pages/man2/sendfile.2:125
msgid ""
"The input file was not opened for reading or the output file was not opened "
"for writing."
msgstr "Входной файл не открыт для чтения или выходной файл не открыт для записи."

#. type: Plain text
#: man-pages/man2/sendfile.2:128
msgid "Bad address."
msgstr "Неправильный адрес."

#. type: Plain text
#: man-pages/man2/sendfile.2:134
msgid ""
"Descriptor is not valid or locked, or an B<mmap>(2)-like operation is not "
"available for I<in_fd>."
msgstr "Неправильный или заблокированный дескриптор, или для I<in_fd> недоступна операция типа B<mmap>(2)."

#. type: Plain text
#: man-pages/man2/sendfile.2:138
msgid "Unspecified error while reading from I<in_fd>."
msgstr "Неизвестная ошибка при чтении I<in_fd>."

#. type: Plain text
#: man-pages/man2/sendfile.2:142
msgid "Insufficient memory to read from I<in_fd>."
msgstr "Не хватает памяти для чтения I<in_fd>."

#. type: Plain text
#: man-pages/man2/sendfile.2:148
msgid ""
"B<sendfile>()  is a new feature in Linux 2.2.  The include file "
"I<E<lt>sys/sendfile.hE<gt>> is present since glibc 2.1."
msgstr "Вызов B<sendfile>() впервые появился в Linux 2.2. Файл заголовков I<E<lt>sys/sendfile.hE<gt>> появился в glibc 2.1."

#. type: Plain text
#: man-pages/man2/sendfile.2:150
msgid "Not specified in POSIX.1-2001, or other standards."
msgstr "Отсутствует в POSIX.1-2001 и других стандартах."

#. type: Plain text
#: man-pages/man2/sendfile.2:155
msgid ""
"Other UNIX systems implement B<sendfile>()  with different semantics and "
"prototypes.  It should not be used in portable programs."
msgstr "В других системах UNIX вызов B<sendfile>() реализован с другими семантиками и прототипами. Не должен использоваться в переносимых программах."

#. type: Plain text
#: man-pages/man2/sendfile.2:165
msgid ""
"If you plan to use B<sendfile>()  for sending files to a TCP socket, but "
"need to send some header data in front of the file contents, you will find "
"it useful to employ the B<TCP_CORK> option, described in B<tcp>(7), to "
"minimize the number of packets and to tune performance."
msgstr "Если вы планируете использовать B<sendfile>() для отправки файлов через сокет TCP и вам нужно послать некоторые заголовочные данные перед содержимым файла, то обратите внимание на параметр B<TCP_CORK>, описанный в B<tcp>(7), он поможет минимизировать количество пакетов и оптимизировать производительность."

#. type: Plain text
#: man-pages/man2/sendfile.2:171
msgid ""
"In Linux 2.4 and earlier, I<out_fd> could also refer to a regular file, and "
"B<sendfile>()  changed the current offset of that file."
msgstr "В Linux 2.4 и более ранних, значение I<out_fd> может также указывать на обычный файл, и B<sendfile>() изменяет текущее смещение этого файла."

#. type: Plain text
#: man-pages/man2/sendfile.2:183
msgid ""
"The original Linux B<sendfile>()  system call was not designed to handle "
"large file offsets.  Consequently, Linux 2.4 added B<sendfile64>(), with a "
"wider type for the I<offset> argument.  The glibc B<sendfile>()  wrapper "
"function transparently deals with the kernel differences."
msgstr "Первоначальная версия Linux B<sendfile>() не была приспособлена для работы с большими файловыми смещениями. В последствии в Linux 2.4 был добавлен вызов B<sendfile64>() с более широким диапазоном значений аргумента I<offset>. В glibc B<sendfile>() представляет собой обёрточную функцию, которая делает незаметным разницу между версиями ядер."

#. type: Plain text
#: man-pages/man2/sendfile.2:192
msgid ""
"Applications may wish to fall back to B<read>(2)/B<write>(2)  in the case "
"where B<sendfile>()  fails with B<EINVAL> or B<ENOSYS>."
msgstr "Приложение может попытаться воспользоваться B<read>(2)/B<write>(2), если вызов B<sendfile>() завершится с ошибкой B<EINVAL> или B<ENOSYS>."

#. type: Plain text
#: man-pages/man2/sendfile.2:197
msgid ""
"The Linux-specific B<splice>(2)  call supports transferring data between "
"arbitrary files (e.g., a pair of sockets)."
msgstr "Специальный вызов Linux B<splice>(2) поддерживает пересылку данных между произвольными файлами (например, между парой сокетов)."

#. type: Plain text
#: man-pages/man2/sendfile.2:202
msgid "B<mmap>(2), B<open>(2), B<socket>(2), B<splice>(2)"
msgstr "B<mmap>(2), B<open>(2), B<socket>(2), B<splice>(2)"

#. type: TH
#: man-pages/man2/symlink.2:33
#, no-wrap
msgid "2014-05-05"
msgstr "2014-05-05"

#. type: Plain text
#: man-pages/man2/symlink.2:36
msgid "symlink, symlinkat - make a new name for a file"
msgstr "symlink, symlinkat - создаёт новое имя для файла"

#. type: Plain text
#: man-pages/man2/symlink.2:41
#, no-wrap
msgid "B<int symlink(const char *>I<target>B<, const char *>I<linkpath>B<);>\n"
msgstr "B<int symlink(const char *>I<target>B<, const char *>I<linkpath>B<);>\n"

#. type: Plain text
#: man-pages/man2/symlink.2:44
#, no-wrap
msgid ""
"B<#include E<lt>fcntl.hE<gt>           >/* Definition of AT_* constants */\n"
"B<#include E<lt>unistd.hE<gt>>\n"
msgstr "B<#include E<lt>fcntl.hE<gt>           >/* определения констант of AT_* */\nB<#include E<lt>unistd.hE<gt>>\n"

#. type: Plain text
#: man-pages/man2/symlink.2:47
#, no-wrap
msgid ""
"B<int symlinkat(const char *>I<target>B<, int >I<newdirfd>B<, const char "
"*>I<linkpath>B<);>\n"
msgstr "B<int symlinkat(const char *>I<target>B<, int >I<newdirfd>B<, const char *>I<linkpath>B<);>\n"

#. type: Plain text
#: man-pages/man2/symlink.2:56
msgid "B<symlink>():"
msgstr "B<symlink>():"

#. type: Plain text
#: man-pages/man2/symlink.2:59
msgid ""
"_BSD_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 500 || _XOPEN_SOURCE\\ &&\\ "
"_XOPEN_SOURCE_EXTENDED || _POSIX_C_SOURCE\\ E<gt>=\\ 200112L"
msgstr "_BSD_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 500 || _XOPEN_SOURCE\\ &&\\ _XOPEN_SOURCE_EXTENDED || _POSIX_C_SOURCE\\ E<gt>=\\ 200112L"

#. type: Plain text
#: man-pages/man2/symlink.2:62
msgid "B<symlinkat>():"
msgstr "B<symlinkat>():"

#. type: TP
#: man-pages/man2/symlink.2:65
#, no-wrap
msgid "Since glibc 2.10:"
msgstr "Начиная с glibc 2.10:"

#. type: Plain text
#: man-pages/man2/symlink.2:68
msgid "_XOPEN_SOURCE\\ E<gt>=\\ 700 || _POSIX_C_SOURCE\\ E<gt>=\\ 200809L"
msgstr "_XOPEN_SOURCE\\ E<gt>=\\ 700 || _POSIX_C_SOURCE\\ E<gt>=\\ 200809L"

#. type: TP
#: man-pages/man2/symlink.2:68
#, no-wrap
msgid "Before glibc 2.10:"
msgstr "До glibc 2.10:"

#. type: Plain text
#: man-pages/man2/symlink.2:71
msgid "_ATFILE_SOURCE"
msgstr "_ATFILE_SOURCE"

#. type: Plain text
#: man-pages/man2/symlink.2:80
msgid ""
"B<symlink>()  creates a symbolic link named I<linkpath> which contains the "
"string I<target>."
msgstr "Вызов B<symlink>() создаёт символьную ссылку с именем I<linkpath>, которая содержит строку I<target>."

#. type: Plain text
#: man-pages/man2/symlink.2:84
msgid ""
"Symbolic links are interpreted at run time as if the contents of the link "
"had been substituted into the path being followed to find a file or "
"directory."
msgstr "Символьные ссылки интерпретируются «на лету», как-будто бы содержимое ссылки было подставлено вместо пути, по которому идёт поиск файла или каталога."

#. type: Plain text
#: man-pages/man2/symlink.2:89
msgid ""
"Symbolic links may contain I<..> path components, which (if used at the "
"start of the link) refer to the parent directories of that in which the link"
" resides."
msgstr "Символьные ссылки могут содержать компоненты пути I<..>, которые (если используются в начале ссылки) ссылаются на родительский каталог того каталога, в котором находится ссылка."

#. type: Plain text
#: man-pages/man2/symlink.2:93
msgid ""
"A symbolic link (also known as a soft link) may point to an existing file or"
" to a nonexistent one; the latter case is known as a dangling link."
msgstr "Символьная ссылка (также известная как «мягкая ссылка») может указывать как на существующий, так и на несуществующий файлы; в последнем случае такая ссылка называется повисшей (dangling)."

#. type: Plain text
#: man-pages/man2/symlink.2:100
msgid ""
"The permissions of a symbolic link are irrelevant; the ownership is ignored "
"when following the link, but is checked when removal or renaming of the link"
" is requested and the link is in a directory with the sticky bit "
"(B<S_ISVTX>)  set."
msgstr "Права доступа символьной ссылки не имеют значения; принадлежность определённому владельцу игнорируется при переходе по ссылке, но проверяется при удалении или переименовании ссылки, а также ссылки в каталог с установленным закрепляющим (sticky) битом (B<S_ISVTX>)."

#. type: Plain text
#: man-pages/man2/symlink.2:106
msgid "If I<linkpath> exists, it will I<not> be overwritten."
msgstr "Если I<linkpath> существует, то он I<не> будет перезаписан."

#. type: SS
#: man-pages/man2/symlink.2:106
#, no-wrap
msgid "symlinkat()"
msgstr "symlinkat()"

#. type: Plain text
#: man-pages/man2/symlink.2:112
msgid ""
"The B<symlinkat>()  system call operates in exactly the same way as "
"B<symlink>(), except for the differences described here."
msgstr "Системный вызов B<symlinkat>() работает также как системный вызов B<symlink>(), за исключением случаев, описанных здесь."

#. type: Plain text
#: man-pages/man2/symlink.2:122
msgid ""
"If the pathname given in I<linkpath> is relative, then it is interpreted "
"relative to the directory referred to by the file descriptor I<newdirfd> "
"(rather than relative to the current working directory of the calling "
"process, as is done by B<symlink>()  for a relative pathname)."
msgstr "Если в I<linkpath> задан относительный путь, то он считается относительно каталога, на который ссылается файловый дескриптор I<newdirfd> (а не относительно текущего рабочего каталога вызывающего процесса, как это делается в B<symlink>())."

#. type: Plain text
#: man-pages/man2/symlink.2:134
msgid ""
"If I<linkpath> is relative and I<newdirfd> is the special value B<AT_FDCWD>,"
" then I<linkpath> is interpreted relative to the current working directory "
"of the calling process (like B<symlink>())."
msgstr "Если в I<linkpath> задан относительный путь и значение I<newdirfd> равно B<AT_FDCWD>, то I<linkpath> рассматривается относительно текущего рабочего каталога вызывающего процесса (как B<symlink>())."

#. type: Plain text
#: man-pages/man2/symlink.2:140
msgid "If I<linkpath> is absolute, then I<newdirfd> is ignored."
msgstr "Если в I<linkpath> задан абсолютный путь, то I<newdirfd> игнорируется."

#. type: Plain text
#: man-pages/man2/symlink.2:155
msgid ""
"Write access to the directory containing I<linkpath> is denied, or one of "
"the directories in the path prefix of I<linkpath> did not allow search "
"permission.  (See also B<path_resolution>(7).)"
msgstr "Нет прав на запись в каталог, содержащийся в I<linkpath>, или в одном из каталогов в I<linkpath> не разрешён поиск (смотрите также B<path_resolution>(7))."

#. type: Plain text
#: man-pages/man2/symlink.2:160
msgid ""
"The user's quota of resources on the filesystem has been exhausted.  The "
"resources could be inodes or disk blocks, depending on the filesystem "
"implementation."
msgstr "Исчерпана пользовательская квота на ресурсы файловой системы. Ресурсами могут быть иноды или дисковые блоки, в зависимости от реализации файловой системы."

#. type: Plain text
#: man-pages/man2/symlink.2:164
msgid "I<linkpath> already exists."
msgstr "I<linkpath> уже существует."

#. type: Plain text
#: man-pages/man2/symlink.2:167
msgid "I<target> or I<linkpath> points outside your accessible address space."
msgstr "Значение I<target> или I<linkpath> указывают за пределы доступного адресного пространства."

#. type: Plain text
#: man-pages/man2/symlink.2:170
msgid "An I/O error occurred."
msgstr "Произошла ошибка ввода-вывода."

#. type: TP
#: man-pages/man2/symlink.2:170
#, no-wrap
msgid "B<ELOOP>"
msgstr "B<ELOOP>"

#. type: Plain text
#: man-pages/man2/symlink.2:174
msgid "Too many symbolic links were encountered in resolving I<linkpath>."
msgstr "Во время определения I<linkpath> встретилось слишком много символьных ссылок."

#. type: TP
#: man-pages/man2/symlink.2:174
#, no-wrap
msgid "B<ENAMETOOLONG>"
msgstr "B<ENAMETOOLONG>"

#. type: Plain text
#: man-pages/man2/symlink.2:177
msgid "I<target> or I<linkpath> was too long."
msgstr "Слишком длинное значение аргумента I<target> или I<linkpath>."

#. type: Plain text
#: man-pages/man2/symlink.2:184
msgid ""
"A directory component in I<linkpath> does not exist or is a dangling "
"symbolic link, or I<target> is the empty string."
msgstr "Компонент пути I<linkpath> не существует или является повисшей символьной ссылкой или значение I<target> равно пустой строке."

#. type: Plain text
#: man-pages/man2/symlink.2:187
msgid "Insufficient kernel memory was available."
msgstr "Недостаточное количество памяти ядра."

#. type: Plain text
#: man-pages/man2/symlink.2:191
msgid ""
"The device containing the file has no room for the new directory entry."
msgstr "На устройстве, содержащем файл, нет места для создания нового элемента каталога."

#. type: Plain text
#: man-pages/man2/symlink.2:196
msgid ""
"A component used as a directory in I<linkpath> is not, in fact, a directory."
msgstr "Компонент пути, использованный как каталог в I<linkpath>, в действительности таковым не является."

#. type: Plain text
#: man-pages/man2/symlink.2:201
msgid ""
"The filesystem containing I<linkpath> does not support the creation of "
"symbolic links."
msgstr "Файловая система, содержащая I<linkpath>, не поддерживает создание символьных ссылок."

#. type: Plain text
#: man-pages/man2/symlink.2:205
msgid "I<linkpath> is on a read-only filesystem."
msgstr "I<linkpath> расположен в файловой системе, доступной только для чтения."

#. type: Plain text
#: man-pages/man2/symlink.2:208
msgid "The following additional errors can occur for B<symlinkat>():"
msgstr "В B<symlinkat>() дополнительно могут возникнуть следующие ошибки:"

#. type: Plain text
#: man-pages/man2/symlink.2:212
msgid "I<newdirfd> is not a valid file descriptor."
msgstr "Значение I<newdirfd> не является правильным файловым дескриптором."

#. type: Plain text
#: man-pages/man2/symlink.2:218
msgid ""
"I<linkpath> is a relative pathname and I<newdirfd> refers to a directory "
"that has been deleted."
msgstr "Значение I<linkpath> является относительным путём и I<newdirfd> ссылается на каталог, который был удалён."

#. type: Plain text
#: man-pages/man2/symlink.2:224
msgid ""
"I<linkpath> is relative and I<newdirfd> is a file descriptor referring to a "
"file other than a directory."
msgstr "Значение I<linkpath> содержит относительный путь и I<newdirfd> содержит файловый дескриптор, указывающий на файл, а не на каталог."

#. type: Plain text
#: man-pages/man2/symlink.2:228
msgid ""
"B<symlinkat>()  was added to Linux in kernel 2.6.16; library support was "
"added to glibc in version 2.4."
msgstr "Системный вызов B<symlinkat>() был добавлен в ядро Linux версии 2.6.16; поддержка в glibc доступна с версии 2.4."

#.  SVr4 documents additional error codes EDQUOT and ENOSYS.
#.  See
#.  .BR open (2)
#.  re multiple files with the same name, and NFS.
#. type: Plain text
#: man-pages/man2/symlink.2:235
msgid "B<symlink>(): SVr4, 4.3BSD, POSIX.1-2001, POSIX.1-2008."
msgstr "B<symlink>(): SVr4, 4.3BSD, POSIX.1-2001, POSIX.1-2008."

#. type: Plain text
#: man-pages/man2/symlink.2:238
msgid "B<symlinkat>(): POSIX.1-2008."
msgstr "B<symlinkat>(): POSIX.1-2008."

#. type: Plain text
#: man-pages/man2/symlink.2:242
msgid "No checking of I<target> is done."
msgstr "Не выполняется проверка I<target>."

#. type: Plain text
#: man-pages/man2/symlink.2:247
msgid ""
"Deleting the name referred to by a symbolic link will actually delete the "
"file (unless it also has other hard links).  If this behavior is not "
"desired, use B<link>(2)."
msgstr "При удаление имени, на который ссылается символьная ссылка, произойдёт удаление файла (если только у него нет других жёстких ссылок). Если такое поведение нежелательно, используйте B<link>(2)."

#. type: Plain text
#: man-pages/man2/symlink.2:257
msgid ""
"B<ln>(1), B<lchown>(2), B<link>(2), B<lstat>(2), B<open>(2), B<readlink>(2),"
" B<rename>(2), B<unlink>(2), B<path_resolution>(7), B<symlink>(7)"
msgstr "B<ln>(1), B<lchown>(2), B<link>(2), B<lstat>(2), B<open>(2), B<readlink>(2), B<rename>(2), B<unlink>(2), B<path_resolution>(7), B<symlink>(7)"

#. type: TH
#: man-pages/man2/socketpair.2:42
#, no-wrap
msgid "SOCKETPAIR"
msgstr "SOCKETPAIR"

#. type: TH
#: man-pages/man2/socketpair.2:42
#, no-wrap
msgid "2008-10-11"
msgstr "2008-10-11"

#. type: Plain text
#: man-pages/man2/socketpair.2:45
msgid "socketpair - create a pair of connected sockets"
msgstr "socketpair - создает пару присоединённых сокетов"

#. type: Plain text
#: man-pages/man2/socketpair.2:52
msgid ""
"B<int socketpair(int >I<domain>B<, int >I<type>B<, int >I<protocol>B<, int "
">I<sv>B<[2]);>"
msgstr "B<int socketpair(int >I<domain>B<, int >I<type>B<, int >I<protocol>B<, int >I<sv>B<[2]);>"

#. type: Plain text
#: man-pages/man2/socketpair.2:63
msgid ""
"The B<socketpair>()  call creates an unnamed pair of connected sockets in "
"the specified I<domain>, of the specified I<type>, and using the optionally "
"specified I<protocol>.  For further details of these arguments, see "
"B<socket>(2)."
msgstr "Вызов B<socketpair>() создает пару неименованых присоединённых сокетов в заданном домене  I<domain> заданного типа I<type>, используя (при необходимости) заданный протокол I<protocol>. Подробнее об этих аргументах можно узнать в B<socket>(2)."

#. type: Plain text
#: man-pages/man2/socketpair.2:69
msgid ""
"The descriptors used in referencing the new sockets are returned in I<sv>[0]"
" and I<sv>[1].  The two sockets are indistinguishable."
msgstr "Дескрипторы, используемые как ссылки на новые сокеты, возвращаются в I<sv>[0] и I<sv>[1]. Никаких различий между этими двумя сокетами нет."

#. type: Plain text
#: man-pages/man2/socketpair.2:78
msgid "The specified address family is not supported on this machine."
msgstr "Заданное семейство адресов не поддерживается в этой машине. "

#. type: Plain text
#: man-pages/man2/socketpair.2:83
msgid ""
"The address I<sv> does not specify a valid part of the process address "
"space."
msgstr "Адрес I<sv> не ссылается на адресное пространство процесса. "

#. type: Plain text
#: man-pages/man2/socketpair.2:86
msgid "Too many descriptors are in use by this process."
msgstr "Слишком много файловых дескрипторов используется процессом. "

#. type: Plain text
#: man-pages/man2/socketpair.2:92
msgid "The specified protocol does not support creation of socket pairs."
msgstr "Заданный протокол не поддерживает создание пар сокетов. "

#. type: Plain text
#: man-pages/man2/socketpair.2:95
msgid "The specified protocol is not supported on this machine."
msgstr "Заданный протокол не поддерживается на этой машине."

#. type: Plain text
#: man-pages/man2/socketpair.2:103
msgid ""
"4.4BSD, POSIX.1-2001.  The B<socketpair>()  function call appeared in "
"4.2BSD.  It is generally portable to/from non-BSD systems supporting clones "
"of the BSD socket layer (including System\\ V variants)."
msgstr "4.4BSD, POSIX.1-2001. Системный вызов B<socketpair>() впервые появился в 4.2BSD. Обычно он переносится в/из не-BSD систем, поддерживающих клоны слоя сокетов BSD (включая  варианты System\\ V)."

#. type: Plain text
#: man-pages/man2/socketpair.2:109
msgid ""
"On Linux, the only supported domain for this call is B<AF_UNIX> (or "
"synonymously, B<AF_LOCAL>).  (Most implementations have the same "
"restriction.)"
msgstr "В Linux единственным поддерживаемым доменом для этого вызова является B<AF_UNIX> (или его синоним B<AF_LOCAL>). (Большинство реализаций имеют такое же ограничение.)"

#. type: Plain text
#: man-pages/man2/socketpair.2:118
msgid ""
"Since Linux 2.6.27, B<socketpair>()  supports the B<SOCK_NONBLOCK> and "
"B<SOCK_CLOEXEC> flags described in B<socket>(2)."
msgstr "Начиная с Linux 2.6.27, B<socketpair>() поддерживает флаги B<SOCK_NONBLOCK> и B<SOCK_CLOEXEC>, описанные в B<socket>(2)."

#. type: Plain text
#: man-pages/man2/socketpair.2:130
msgid ""
"B<pipe>(2), B<read>(2), B<socket>(2), B<write>(2), B<socket>(7), B<unix>(7)"
msgstr "B<pipe>(2), B<read>(2), B<socket>(2), B<write>(2), B<socket>(7), B<unix>(7)"

#. type: TH
#: man-pages/man2/set_tid_address.2:25
#, no-wrap
msgid "SET_TID_ADDRESS"
msgstr "SET_TID_ADDRESS"

#. type: Plain text
#: man-pages/man2/set_tid_address.2:28
msgid "set_tid_address - set pointer to thread ID"
msgstr "set_tid_address - устанавливает указатель идентификатора нити"

#. type: Plain text
#: man-pages/man2/set_tid_address.2:31
#, no-wrap
msgid "B<#include E<lt>linux/unistd.hE<gt>>\n"
msgstr "B<#include E<lt>linux/unistd.hE<gt>>\n"

#. type: Plain text
#: man-pages/man2/set_tid_address.2:33
#, no-wrap
msgid "B<long set_tid_address(int *>I<tidptr>B<);>\n"
msgstr "B<long set_tid_address(int *>I<tidptr>B<);>\n"

#. type: Plain text
#: man-pages/man2/set_tid_address.2:40
msgid ""
"For each thread, the kernel maintains two attributes (addresses) called "
"I<set_child_tid> and I<clear_child_tid>.  These two attributes contain the "
"value NULL by default."
msgstr ""

#. type: TP
#: man-pages/man2/set_tid_address.2:40
#, no-wrap
msgid "I<set_child_tid>"
msgstr "I<set_child_tid>"

#. type: Plain text
#: man-pages/man2/set_tid_address.2:51
msgid ""
"If a thread is started using B<clone>(2)  with the B<CLONE_CHILD_SETTID> "
"flag, I<set_child_tid> is set to the value passed in the I<ctid> argument of"
" that system call."
msgstr ""

#. type: Plain text
#: man-pages/man2/set_tid_address.2:56
msgid ""
"When I<set_child_tid> is set, the very first thing the new thread does is to"
" write its thread ID at this address."
msgstr ""

#. type: TP
#: man-pages/man2/set_tid_address.2:56
#, no-wrap
msgid "I<clear_child_tid>"
msgstr "I<clear_child_tid>"

#. type: Plain text
#: man-pages/man2/set_tid_address.2:67
msgid ""
"If a thread is started using B<clone>(2)  with the B<CLONE_CHILD_CLEARTID> "
"flag, I<clear_child_tid> is set to the value passed in the I<ctid> argument "
"of that system call."
msgstr ""

#. type: Plain text
#: man-pages/man2/set_tid_address.2:74
msgid ""
"The system call B<set_tid_address>()  sets the I<clear_child_tid> value for "
"the calling thread to I<tidptr>."
msgstr ""

#. type: Plain text
#: man-pages/man2/set_tid_address.2:82
msgid ""
"When a thread whose I<clear_child_tid> is not NULL terminates, then, if the "
"thread is sharing memory with other threads, then 0 is written at the "
"address specified in I<clear_child_tid> and the kernel performs the "
"following operation:"
msgstr ""

#. type: Plain text
#: man-pages/man2/set_tid_address.2:84
#, no-wrap
msgid "    futex(clear_child_tid, FUTEX_WAKE, 1, NULL, NULL, 0);\n"
msgstr "    futex(clear_child_tid, FUTEX_WAKE, 1, NULL, NULL, 0);\n"

#. type: Plain text
#: man-pages/man2/set_tid_address.2:88
msgid ""
"The effect of this operation is to wake a single thread that is performing a"
" futex wait on the memory location.  Errors from the futex wake operation "
"are ignored."
msgstr ""

#. type: Plain text
#: man-pages/man2/set_tid_address.2:91
msgid "B<set_tid_address>()  always returns the caller's thread ID."
msgstr ""

#. type: Plain text
#: man-pages/man2/set_tid_address.2:94
msgid "B<set_tid_address>()  always succeeds."
msgstr "Вызов B<set_tid_address>() всегда завершается без ошибок."

#. type: Plain text
#: man-pages/man2/set_tid_address.2:97
msgid ""
"This call is present since Linux 2.5.48.  Details as given here are valid "
"since Linux 2.5.49."
msgstr "Данный вызов появился в Linux 2.5.48. Представленное здесь описание соответствует вызову, начиная с Linux 2.5.49."

#. type: Plain text
#: man-pages/man2/set_tid_address.2:99
msgid "This system call is Linux-specific."
msgstr "Данный вызов есть только в Linux."

#. type: Plain text
#: man-pages/man2/set_tid_address.2:102
msgid "B<clone>(2), B<futex>(2), B<gettid>(2)"
msgstr ""

#. type: TH
#: man-pages/man2/sched_get_priority_max.2:29
#, no-wrap
msgid "SCHED_GET_PRIORITY_MAX"
msgstr "SCHED_GET_PRIORITY_MAX"

#. type: TH
#: man-pages/man2/sched_get_priority_max.2:29
#, no-wrap
msgid "2014-05-12"
msgstr "2014-05-12"

#. type: Plain text
#: man-pages/man2/sched_get_priority_max.2:32
msgid ""
"sched_get_priority_max, sched_get_priority_min - get static priority range"
msgstr "sched_get_priority_max, sched_get_priority_min - возвращают статический диапазон приоритетов"

#. type: Plain text
#: man-pages/man2/sched_get_priority_max.2:36
msgid "B<int sched_get_priority_max(int >I<policy>B<);>"
msgstr "B<int sched_get_priority_max(int >I<policy>B<);>"

#. type: Plain text
#: man-pages/man2/sched_get_priority_max.2:38
msgid "B<int sched_get_priority_min(int >I<policy>B<);>"
msgstr "B<int sched_get_priority_min(int >I<policy>B<);>"

#. type: Plain text
#: man-pages/man2/sched_get_priority_max.2:59
msgid ""
"B<sched_get_priority_max>()  returns the maximum priority value that can be "
"used with the scheduling algorithm identified by I<policy>.  "
"B<sched_get_priority_min>()  returns the minimum priority value that can be "
"used with the scheduling algorithm identified by I<policy>.  Supported "
"I<policy> values are B<SCHED_FIFO>, B<SCHED_RR>, B<SCHED_OTHER>, "
"B<SCHED_BATCH>, B<SCHED_IDLE>, and B<SCHED_DEADLINE>.  Further details about"
" these policies can be found in B<sched>(7)."
msgstr "Вызов B<sched_get_priority_max>() возвращает максимальное значение приоритета, которое может использоваться с алгоритмом планирования, указанного в I<policy>. Вызов B<sched_get_priority_min>() возвращает минимальное значение приоритета, которое может использоваться с алгоритмом планирования, указанного в I<policy>. Поддерживаемые значения для I<policy>: B<SCHED_FIFO>, B<SCHED_RR>, B<SCHED_OTHER>, B<SCHED_BATCH>, B<SCHED_IDLE> и B<SCHED_DEADLINE>. Подробней об этих политиках смотрите в B<sched>(7)."

#. type: Plain text
#: man-pages/man2/sched_get_priority_max.2:68
msgid ""
"Processes with numerically higher priority values are scheduled before "
"processes with numerically lower priority values.  Thus, the value returned "
"by B<sched_get_priority_max>()  will be greater than the value returned by "
"B<sched_get_priority_min>()."
msgstr "Процессы с большим числовым значением приоритета планируются к выполнению раньше процессов с меньшим числовым значением приоритета. То есть значение, возвращаемое B<sched_get_priority_max>(), будет больше значения, возвращаемого B<sched_get_priority_min>()."

#. type: Plain text
#: man-pages/man2/sched_get_priority_max.2:76
msgid ""
"Linux allows the static priority range 1 to 99 for the B<SCHED_FIFO> and "
"B<SCHED_RR> policies, and the priority 0 for the remaining policies.  "
"Scheduling priority ranges for the various policies are not alterable."
msgstr "В Linux допускаются статические приоритеты в диапазоне от 1 до 99 для политик B<SCHED_FIFO> и B<SCHED_RR> и приоритет 0 для для остальных политик. Диапазоны планируемых приоритетов для различных политик назначить нельзя."

#. type: Plain text
#: man-pages/man2/sched_get_priority_max.2:88
msgid ""
"The range of scheduling priorities may vary on other POSIX systems, thus it "
"is a good idea for portable applications to use a virtual priority range and"
" map it to the interval given by B<sched_get_priority_max>()  and "
"B<sched_get_priority_min>().  POSIX.1-2001 requires a spread of at least 32 "
"between the maximum and the minimum values for B<SCHED_FIFO> and "
"B<SCHED_RR>."
msgstr "В разных системах POSIX диапазон планируемых приоритетов может различаться, то есть переносимое приложение должно использовать диапазон виртуальных приоритетов и отображать его в интервал, получаемый с помощью B<sched_get_priority_max>() и B<sched_get_priority_min>(). POSIX.1-2001 требует диапазон не менее 32 значений между максимальным и минимальным значениями для B<SCHED_FIFO> и B<SCHED_RR>."

#. type: Plain text
#: man-pages/man2/sched_get_priority_max.2:97
msgid ""
"POSIX systems on which B<sched_get_priority_max>()  and "
"B<sched_get_priority_min>()  are available define "
"B<_POSIX_PRIORITY_SCHEDULING> in I<E<lt>unistd.hE<gt>>."
msgstr "В системах POSIX, имеющих B<sched_get_priority_max>() и B<sched_get_priority_min>(), определено значение для B<_POSIX_PRIORITY_SCHEDULING> в I<E<lt>unistd.hE<gt>>."

#. type: Plain text
#: man-pages/man2/sched_get_priority_max.2:107
msgid ""
"On success, B<sched_get_priority_max>()  and B<sched_get_priority_min>()  "
"return the maximum/minimum priority value for the named scheduling policy.  "
"On error, -1 is returned, and I<errno> is set appropriately."
msgstr "При успешном выполнении B<sched_get_priority_max>() и B<sched_get_priority_min>() возвращают максимальное/минимальное значение приоритета для указанной политики планирования. В случае ошибки возвращается -1, а I<errno> устанавливается в соответствующее значение."

#. type: Plain text
#: man-pages/man2/sched_get_priority_max.2:113
msgid "The argument I<policy> does not identify a defined scheduling policy."
msgstr "Аргумент I<policy> не содержит допустимого значения политики планирования."

#. type: Plain text
#: man-pages/man2/sched_get_priority_max.2:124
msgid ""
"B<sched_getaffinity>(2), B<sched_getparam>(2), B<sched_getscheduler>(2), "
"B<sched_setaffinity>(2), B<sched_setparam>(2), B<sched_setscheduler>(2), "
"B<sched>(7)"
msgstr "B<sched_getaffinity>(2), B<sched_getparam>(2), B<sched_getscheduler>(2), B<sched_setaffinity>(2), B<sched_setparam>(2), B<sched_setscheduler>(2), B<sched>(7)"

#. type: TH
#: man-pages/man2/setfsgid.2:31
#, no-wrap
msgid "SETFSGID"
msgstr "SETFSGID"

#. type: Plain text
#: man-pages/man2/setfsgid.2:34
msgid "setfsgid - set group identity used for filesystem checks"
msgstr "setfsgid - устанавливает идентификатор группы для доступа к файловой системе"

#. type: Plain text
#: man-pages/man2/setfsgid.2:38
msgid "B<int setfsgid(uid_t >I<fsgid>B<);>"
msgstr "B<int setfsgid(uid_t >I<fsgid>B<);>"

#. type: Plain text
#: man-pages/man2/setfsgid.2:51
msgid ""
"The system call B<setfsgid>()  changes the value of the caller's filesystem "
"group ID\\(emthe group ID that the Linux kernel uses to check for all "
"accesses to the filesystem.  Normally, the value of the filesystem group ID "
"will shadow the value of the effective group ID.  In fact, whenever the "
"effective group ID is changed, the filesystem group ID will also be changed "
"to the new value of the effective group ID."
msgstr "Системный вызов B<setfsgid>() изменяет значение идентификатора группы файловой системы вызывающего — идентификатор группы, который ядро Linux использует для проверки при любом доступе к файловой системе. Обычно, значение идентификатора группы файловой системы равно теневому значению идентификатора эффективной группы. Более того, при изменении идентификатора эффективной группы также изменяется и идентификатор группы файловой системы на новое значение идентификатора эффективной группы."

#. type: Plain text
#: man-pages/man2/setfsgid.2:62
msgid ""
"Explicit calls to B<setfsuid>(2)  and B<setfsgid>()  are usually used only "
"by programs such as the Linux NFS server that need to change what user and "
"group ID is used for file access without a corresponding change in the real "
"and effective user and group IDs.  A change in the normal user IDs for a "
"program such as the NFS server is a security hole that can expose it to "
"unwanted signals.  (But see below.)"
msgstr "Вызовы B<setfsuid>(2) и B<setfsgid>() обычно используются только в программах Linux типа NFS-сервера, которым требуется изменить идентификатор пользователя и группы для доступа к файлам без изменения действительного и эффективного идентификаторов пользователя и группы. Изменение обычного идентификатора пользователя для программы типа NFS-сервера \\(em это нарушение безопасности, приводящее к возможному получению нежелательных сигналов от других групп (но читайте далее)."

#. type: Plain text
#: man-pages/man2/setfsgid.2:68
msgid ""
"B<setfsgid>()  will succeed only if the caller is the superuser or if "
"I<fsgid> matches either the caller's real group ID, effective group ID, "
"saved set-group-ID, or current the filesystem user ID."
msgstr "Вызов B<setfsgid>() выполняется корректно, только если он был вызван суперпользователем или, если I<fsgid> совпадает с идентификатором действительной, эффективной и сохранённой группы или равен текущему значению идентификатора пользователя файловой системы вызывающего."

#. type: Plain text
#: man-pages/man2/setfsgid.2:71
msgid ""
"On both success and failure, this call returns the previous filesystem group"
" ID of the caller."
msgstr "При успешном выполнении или при ошибке данный вызов возвращает предыдущий идентификатор группы файловой системы вызвавшего."

#. type: Plain text
#: man-pages/man2/setfsgid.2:79
msgid ""
"B<setfsgid>()  is Linux-specific and should not be used in programs intended"
" to be portable."
msgstr "Вызов B<setfsgid>() есть только в Linux и не должен использоваться в переносимых программах."

#. type: Plain text
#: man-pages/man2/setfsgid.2:85
msgid ""
"When glibc determines that the argument is not a valid group ID, it will "
"return -1 and set I<errno> to B<EINVAL> without attempting the system call."
msgstr "Если в glibc определяется, что в аргументе указан неправильный идентификатор группы, то возвращается -1, I<errno> присваивается значение B<EINVAL>, а системный вызов не выполняется."

#. type: Plain text
#: man-pages/man2/setfsgid.2:96
msgid ""
"Note that at the time this system call was introduced, a process could send "
"a signal to a process with the same effective user ID.  Today signal "
"permission handling is slightly different.  See B<setfsuid>(2)  for a "
"discussion of why the use of both B<setfsuid>(2)  and B<setfsgid>()  is "
"nowadays unneeded."
msgstr "Заметим, что до появления данного системного вызова, процесс мог отправить сигнал процессу с таким же действующим идентификатором пользователя. Сейчас обработка прав отправки сигнала происходит немного иначе. Смотрите в B<setfsuid>(2) описание почему использование B<setfsuid>(2) и B<setfsgid>() в настоящее время больше не требуется."

#. type: Plain text
#: man-pages/man2/setfsgid.2:106
msgid ""
"The original Linux B<setfsgid>()  system call supported only 16-bit group "
"IDs.  Subsequently, Linux 2.4 added B<setfsgid32>()  supporting 32-bit IDs."
"  The glibc B<setfsgid>()  wrapper function transparently deals with the "
"variation across kernel versions."
msgstr "Первоначальная версия системного вызова Linux B<setfsgid>() поддерживала только 16-битные идентификаторы групп. Позднее в Linux 2.4 был добавлен B<setfsgid32>(), поддерживающий 32-битные идентификаторы. Обёрточная функция glibc B<setfsgid>() скрывает это различие в версиях ядер."

#. type: Plain text
#: man-pages/man2/setfsgid.2:123
msgid ""
"No error indications of any kind are returned to the caller, and the fact "
"that both successful and unsuccessful calls return the same value makes it "
"impossible to directly determine whether the call succeeded or failed.  "
"Instead, the caller must resort to looking at the return value from a "
"further call such as I<setfsgid(-1)> (which will always fail), in order to "
"determine if a preceding call to B<setfsgid>()  changed the filesystem group"
" ID.  At the very least, B<EPERM> should be returned when the call fails "
"(because the caller lacks the B<CAP_SETGID> capability)."
msgstr "Вызывающему не возвращается никаких ошибок, и факт того, что успешном или неудачном выполнении возвращается одинаковое значение, делает невозможным напрямую определить как завершился вызов. Вместо этого, вызывающий должен получить значение из ещё одноговызова — I<setfsgid(-1)> (который всегда завершается с ошибкой), чтобы определить, изменил ли предыдущий вызов B<setfsgid>() идентификатор группы файловой системы. По крайней мере, должно быть получено значение B<EPERM>, если вызов завершится с ошибкой (так как у вызывающего нет мандата B<CAP_SETGID>)."

#. type: Plain text
#: man-pages/man2/setfsgid.2:127
msgid "B<kill>(2), B<setfsuid>(2), B<capabilities>(7), B<credentials>(7)"
msgstr "B<kill>(2), B<setfsuid>(2), B<capabilities>(7), B<credentials>(7)"

#. type: TH
#: man-pages/man2/stat.2:40
#, no-wrap
msgid "STAT"
msgstr "STAT"

#. type: Plain text
#: man-pages/man2/stat.2:43
msgid "stat, fstat, lstat, fstatat - get file status"
msgstr "stat, fstat, lstat, fstatat - считывает состояние файла"

#. type: Plain text
#: man-pages/man2/stat.2:46
#, no-wrap
msgid "B<#include E<lt>sys/types.hE<gt>>\n"
msgstr "B<#include E<lt>sys/types.hE<gt>>\n"

#. type: Plain text
#: man-pages/man2/stat.2:48
#, no-wrap
msgid "B<#include E<lt>sys/stat.hE<gt>>\n"
msgstr "B<#include E<lt>sys/stat.hE<gt>>\n"

#. type: Plain text
#: man-pages/man2/stat.2:52
#, no-wrap
msgid "B<int stat(const char *>I<pathname>B<, struct stat *>I<buf>B<);>\n"
msgstr "B<int stat(const char *>I<pathname>B<, struct stat *>I<buf>B<);>\n"

#. type: Plain text
#: man-pages/man2/stat.2:54
#, no-wrap
msgid "B<int fstat(int >I<fd>B<, struct stat *>I<buf>B<);>\n"
msgstr "B<int fstat(int >I<fd>B<, struct stat *>I<buf>B<);>\n"

#. type: Plain text
#: man-pages/man2/stat.2:56
#, no-wrap
msgid "B<int lstat(const char *>I<pathname>B<, struct stat *>I<buf>B<);>\n"
msgstr "B<int lstat(const char *>I<pathname>B<, struct stat *>I<buf>B<);>\n"

#. type: Plain text
#: man-pages/man2/stat.2:59
#, no-wrap
msgid ""
"B<#include E<lt>fcntl.hE<gt>           >/* Definition of AT_* constants */\n"
"B<#include E<lt>sys/stat.hE<gt>>\n"
msgstr "B<#include E<lt>fcntl.hE<gt>           >/* определения констант AT_* */\nB<#include E<lt>sys/stat.hE<gt>>\n"

#. type: Plain text
#: man-pages/man2/stat.2:63
#, no-wrap
msgid ""
"B<int fstatat(int >I<dirfd>B<, const char *>I<pathname>B<, struct stat *>I<buf>B<,>\n"
"B<            int >I<flags>B<);>\n"
msgstr "B<int fstatat(int >I<dirfd>B<, const char *>I<pathname>B<, struct stat *>I<buf>B<,>\nB<            int >I<flags>B<);>\n"

#. type: Plain text
#: man-pages/man2/stat.2:73
msgid "B<lstat>():"
msgstr "B<lstat>():"

#. type: Plain text
#: man-pages/man2/stat.2:75
msgid "/* glibc 2.19 and earlier */ _BSD_SOURCE ||"
msgstr "/* glibc 2.19 и старее */ _BSD_SOURCE ||"

#. type: Plain text
#: man-pages/man2/stat.2:77
msgid "/* Since glibc 2.20 */_DEFAULT_SOURCE ||"
msgstr "/* начиная с glibc 2.20 */_DEFAULT_SOURCE ||"

#. type: Plain text
#: man-pages/man2/stat.2:82
msgid "|| /* Since glibc 2.10: */ _POSIX_C_SOURCE\\ E<gt>=\\ 200112L"
msgstr "|| /* начиная с glibc 2.10: */ _POSIX_C_SOURCE\\ E<gt>=\\ 200112L"

#. type: Plain text
#: man-pages/man2/stat.2:85
msgid "B<fstatat>():"
msgstr "B<fstatat>():"

#. type: Plain text
#: man-pages/man2/stat.2:109
msgid ""
"These functions return information about a file, in the buffer pointed to by"
" I<stat>.  No permissions are required on the file itself, but\\(emin the "
"case of B<stat>(), B<fstatat>(), and B<lstat>()\\(emexecute (search) "
"permission is required on all of the directories in I<pathname> that lead to"
" the file."
msgstr "Данные системные вызовы возвращают информацию о файле в буфер, на который указывает I<stat>. Для этого не требуется иметь права доступа к самому файлу, но — в случае B<stat>(), B<fstatat>() и B<lstat>() — потребуются права выполнения (поиска) на все каталоги, указанные в полном имени файла I<pathname>."

#. type: Plain text
#: man-pages/man2/stat.2:118
msgid ""
"B<stat>()  and B<fstatat>()  retrieve information about the file pointed to "
"by I<pathname>; the differences for B<fstatat>()  are described below."
msgstr "Вызовы B<stat>() и B<fstatat>() возвращают информацию о файле, указанном в I<pathname>; различия с B<fstatat>() описаны далее."

#. type: Plain text
#: man-pages/man2/stat.2:126
msgid ""
"B<lstat>()  is identical to B<stat>(), except that if I<pathname> is a "
"symbolic link, then it returns information about the link itself, not the "
"file that it refers to."
msgstr "Вызов B<lstat>() идентичен B<stat>(), но в случае, если I<pathname> является символьной ссылкой, то возвращается информация о самой ссылке, а не о файле, на который она указывает."

#. type: Plain text
#: man-pages/man2/stat.2:133
msgid ""
"B<fstat>()  is identical to B<stat>(), except that the file about which "
"information is to be retrieved is specified by the file descriptor I<fd>."
msgstr "Вызов B<fstat>() идентичен B<stat>(), но опрашиваемый файл задаётся в виде файлового дескриптора I<fd>."

#. type: Plain text
#: man-pages/man2/stat.2:137
msgid ""
"All of these system calls return a I<stat> structure, which contains the "
"following fields:"
msgstr "Все эти системные вызовы возвращают структуру I<stat>, которая содержит следующие поля:"

#. type: Plain text
#: man-pages/man2/stat.2:151
#, no-wrap
msgid ""
"struct stat {\n"
"    dev_t     st_dev;         /* ID of device containing file */\n"
"    ino_t     st_ino;         /* inode number */\n"
"    mode_t    st_mode;        /* protection */\n"
"    nlink_t   st_nlink;       /* number of hard links */\n"
"    uid_t     st_uid;         /* user ID of owner */\n"
"    gid_t     st_gid;         /* group ID of owner */\n"
"    dev_t     st_rdev;        /* device ID (if special file) */\n"
"    off_t     st_size;        /* total size, in bytes */\n"
"    blksize_t st_blksize;     /* blocksize for filesystem I/O */\n"
"    blkcnt_t  st_blocks;      /* number of 512B blocks allocated */\n"
msgstr "struct stat {\n    dev_t     st_dev;         /* ID устройства с файлом */\n    ino_t     st_ino;         /* номер inode */\n    mode_t    st_mode;        /* права доступа */\n    nlink_t   st_nlink;       /* кол-во жёстких ссылок */\n    uid_t     st_uid;         /* ID пользователя-владельца */\n    gid_t     st_gid;         /* ID группы-владельца */\n    dev_t     st_rdev;        /* ID устройства (если это спец. файл) */\n    off_t     st_size;        /* полный размер в байтах */\n    blksize_t st_blksize;     /* размер блока ввода-вывода\n                                 файловой системы */\n    blkcnt_t  st_blocks;      /* кол-во выделенных блоков по 512Б */\n"

#. type: Plain text
#: man-pages/man2/stat.2:155
#, no-wrap
msgid ""
"    /* Since Linux 2.6, the kernel supports nanosecond\n"
"       precision for the following timestamp fields.\n"
"       For the details before Linux 2.6, see NOTES. */\n"
msgstr "    /* Начиная с Linux 2.6, ядро поддерживает точность до\n       наносекунд в следующих полям меток времени.\n       Подробней о версиях до Linux 2.6, смотрите ЗАМЕЧАНИЯ. */\n"

#. type: Plain text
#: man-pages/man2/stat.2:159
#, no-wrap
msgid ""
"    struct timespec st_atim;  /* time of last access */\n"
"    struct timespec st_mtim;  /* time of last modification */\n"
"    struct timespec st_ctim;  /* time of last status change */\n"
msgstr "    struct timespec st_atim;  /* время последнего доступа */\n    struct timespec st_mtim;  /* время последнего изменения */\n    struct timespec st_ctim;  /* время последней смены состояния */\n"

#. type: Plain text
#: man-pages/man2/stat.2:164
#, no-wrap
msgid ""
"#define st_atime st_atim.tv_sec      /* Backward compatibility */\n"
"#define st_mtime st_mtim.tv_sec\n"
"#define st_ctime st_ctim.tv_sec\n"
"};\n"
msgstr "#define st_atime st_atim.tv_sec      /* для обратной совместимости */\n#define st_mtime st_mtim.tv_sec\n#define st_ctime st_ctim.tv_sec\n};\n"

#. type: Plain text
#: man-pages/man2/stat.2:177
msgid ""
"I<Note:> the order of fields in the I<stat> structure varies somewhat across"
" architectures.  In addition, the definition above does not show the padding"
" bytes that may be present between some fields on various architectures.  "
"Consult the the glibc and kernel source code if you need to know the "
"details."
msgstr ""

#. type: Plain text
#: man-pages/man2/stat.2:186
msgid ""
"The I<st_dev> field describes the device on which this file resides.  (The "
"B<major>(3)  and B<minor>(3)  macros may be useful to decompose the device "
"ID in this field.)"
msgstr "Поле I<st_dev> описывает устройство, на котором расположен файл (для разбора идентификатора этого поля могут пригодиться макросы B<major>(3) и B<minor>(3))."

#. type: Plain text
#: man-pages/man2/stat.2:190
msgid ""
"The I<st_rdev> field describes the device that this file (inode) represents."
msgstr "Поле I<st_rdev> описывает устройство, который этот файл (inode) представляет."

#. type: Plain text
#: man-pages/man2/stat.2:197
msgid ""
"The I<st_size> field gives the size of the file (if it is a regular file or "
"a symbolic link) in bytes.  The size of a symbolic link is the length of the"
" pathname it contains, without a terminating null byte."
msgstr "В поле I<st_size> хранится размер файла (если он обычный или является символьной ссылкой) в байтах. Размер символьной ссылки равен длине пути файла, на который она ссылается, без конечного нулевого байта."

#. type: Plain text
#: man-pages/man2/stat.2:204
msgid ""
"The I<st_blocks> field indicates the number of blocks allocated to the file,"
" 512-byte units.  (This may be smaller than I<st_size>/512 when the file has"
" holes.)"
msgstr "В поле I<st_blocks> хранится размер файла в 512-байтных блоках (размер может быть меньше, чем I<st_size>/512, когда в файле есть пропуски (holes))."

#. type: Plain text
#: man-pages/man2/stat.2:210
msgid ""
"The I<st_blksize> field gives the \"preferred\" blocksize for efficient "
"filesystem I/O.  (Writing to a file in smaller chunks may cause an "
"inefficient read-modify-rewrite.)"
msgstr "В поле I<st_blksize> хранится «предпочтительный» размер блока для эффективного ввода/вывода в файловой системе (запись в файл более мелкими порциями может привести к неэффективному чтению/изменению/повторной записи)."

#. type: Plain text
#: man-pages/man2/stat.2:231
msgid ""
"Not all of the Linux filesystems implement all of the time fields.  Some "
"filesystem types allow mounting in such a way that file and/or directory "
"accesses do not cause an update of the I<st_atime> field.  (See I<noatime>, "
"I<nodiratime>, and I<relatime> in B<mount>(8), and related information in "
"B<mount>(2).)  In addition, I<st_atime> is not updated if a file is opened "
"with the B<O_NOATIME>; see B<open>(2)."
msgstr "Не во всех файловых системах Linux используются все поля меток времени. Некоторые файловые системы можно смонтировать так, что факт доступа к файлу или каталогу не вызовет изменение поля I<st_atime> (смотрите описание I<noatime>, I<nodiratime> и I<relatime> в B<mount>(8) и связанную с ними информацию в B<mount>(2)). Кроме того, поле I<st_atime> не обновляется, если файл открыт с флагом B<O_NOATIME>; см. B<open>(2)."

#. type: Plain text
#: man-pages/man2/stat.2:246
msgid ""
"The field I<st_atime> is changed by file accesses, for example, by "
"B<execve>(2), B<mknod>(2), B<pipe>(2), B<utime>(2)  and B<read>(2)  (of more"
" than zero bytes).  Other routines, like B<mmap>(2), may or may not update "
"I<st_atime>."
msgstr "Поле I<st_atime> изменяется при доступе к файлу, например, при выполнении B<execve>(2), B<mknod>(2), B<pipe>(2), B<utime>(2) и B<read>(2) (при чтении ненулевого количества байт). Другие процедуры, например B<mmap>(2), могут изменять I<st_atime>, но могут и не делать этого."

#. type: Plain text
#: man-pages/man2/stat.2:265
msgid ""
"The field I<st_mtime> is changed by file modifications, for example, by "
"B<mknod>(2), B<truncate>(2), B<utime>(2)  and B<write>(2)  (of more than "
"zero bytes).  Moreover, I<st_mtime> of a directory is changed by the "
"creation or deletion of files in that directory.  The I<st_mtime> field is "
"I<not> changed for changes in owner, group, hard link count, or mode."
msgstr "Поле I<st_mtime> изменяется при изменении файла, например, при выполнении B<mknod>(2), B<truncate>(2), B<utime>(2) и B<write>(2) (если записано не менее одного байта). Кроме того, поле I<st_mtime> у каталога изменяется при создании и удалении файлов в этом каталоге. Поле I<st_mtime> I<не изменяется>  при изменении владельца, группы, количества жёстких ссылок или режима доступа к нему."

#. type: Plain text
#: man-pages/man2/stat.2:270
msgid ""
"The field I<st_ctime> is changed by writing or by setting inode information "
"(i.e., owner, group, link count, mode, etc.)."
msgstr "Поле I<st_ctime> изменяется при записи или установке информации об inode (владельце, группе, количестве ссылок, режиме и т.д.)."

#. type: Plain text
#: man-pages/man2/stat.2:274
msgid ""
"The following mask values are defined for the file type component of the "
"I<st_mode> field:"
msgstr "Следующие значения масок определены для компонента типа файла поля I<st_mode>:"

#. type: tbl table
#: man-pages/man2/stat.2:277
#, no-wrap
msgid "S_IFMT\t0170000\tbit mask for the file type bit fields\n"
msgstr "S_IFMT\t0170000\tбитовая маска битовых полей для типа файла\n"

#. type: tbl table
#: man-pages/man2/stat.2:279
#, no-wrap
msgid "S_IFSOCK\t0140000\tsocket\n"
msgstr "S_IFSOCK\t0140000\tсокет\n"

#. type: tbl table
#: man-pages/man2/stat.2:280
#, no-wrap
msgid "S_IFLNK\t0120000\tsymbolic link\n"
msgstr "S_IFLNK\t0120000\tсимвольная ссылка\n"

#. type: tbl table
#: man-pages/man2/stat.2:281
#, no-wrap
msgid "S_IFREG\t0100000\tregular file\n"
msgstr "S_IFREG\t0100000\tобычный файл\n"

#. type: tbl table
#: man-pages/man2/stat.2:282
#, no-wrap
msgid "S_IFBLK\t0060000\tblock device\n"
msgstr "S_IFBLK\t0060000\tблочное устройство\n"

#. type: tbl table
#: man-pages/man2/stat.2:283
#, no-wrap
msgid "S_IFDIR\t0040000\tdirectory\n"
msgstr "S_IFDIR\t0040000\tкаталог\n"

#. type: tbl table
#: man-pages/man2/stat.2:284
#, no-wrap
msgid "S_IFCHR\t0020000\tcharacter device\n"
msgstr "S_IFCHR\t0020000\tсимвольное устройство\n"

#. type: tbl table
#: man-pages/man2/stat.2:285
#, no-wrap
msgid "S_IFIFO\t0010000\tFIFO\n"
msgstr "S_IFIFO\t0010000\tFIFO\n"

#. type: Plain text
#: man-pages/man2/stat.2:290
msgid "Thus, to test for a regular file (for example), one could write:"
msgstr "Таким образом, чтобы проверить обычный файл (например) на возможность записи:"

#. type: Plain text
#: man-pages/man2/stat.2:297
#, no-wrap
msgid ""
"stat(pathname, &sb);\n"
"if ((sb.st_mode & S_IFMT) == S_IFREG) {\n"
"    /* Handle regular file */\n"
"}\n"
msgstr "stat(pathname, &sb);\nif ((sb.st_mode & S_IFMT) == S_IFREG) {\n    /* обработка обычного файла */\n}\n"

#. type: Plain text
#: man-pages/man2/stat.2:304
msgid ""
"Because tests of the above form are common, additional macros are defined by"
" POSIX to allow the test of the file type in I<st_mode> to be written more "
"concisely:"
msgstr ""

#. type: TP
#: man-pages/man2/stat.2:305
#, no-wrap
msgid "B<S_ISREG>(m)"
msgstr "B<S_ISREG>(m)"

#. type: Plain text
#: man-pages/man2/stat.2:308
msgid "is it a regular file?"
msgstr "обычный файл?"

#. type: TP
#: man-pages/man2/stat.2:308
#, no-wrap
msgid "B<S_ISDIR>(m)"
msgstr "B<S_ISDIR>(m)"

#. type: Plain text
#: man-pages/man2/stat.2:311
msgid "directory?"
msgstr "каталог?"

#. type: TP
#: man-pages/man2/stat.2:311
#, no-wrap
msgid "B<S_ISCHR>(m)"
msgstr "B<S_ISCHR>(m)"

#. type: Plain text
#: man-pages/man2/stat.2:314
msgid "character device?"
msgstr "символьное устройство?"

#. type: TP
#: man-pages/man2/stat.2:314
#, no-wrap
msgid "B<S_ISBLK>(m)"
msgstr "B<S_ISBLK>(m)"

#. type: Plain text
#: man-pages/man2/stat.2:317
msgid "block device?"
msgstr "блочное устройство?"

#. type: TP
#: man-pages/man2/stat.2:317
#, no-wrap
msgid "B<S_ISFIFO>(m)"
msgstr "B<S_ISFIFO>(m)"

#. type: Plain text
#: man-pages/man2/stat.2:320
msgid "FIFO (named pipe)?"
msgstr "FIFO (именованный канал)?"

#. type: TP
#: man-pages/man2/stat.2:320
#, no-wrap
msgid "B<S_ISLNK>(m)"
msgstr "B<S_ISLNK>(m)"

#. type: Plain text
#: man-pages/man2/stat.2:323
msgid "symbolic link? (Not in POSIX.1-1996.)"
msgstr "символьная ссылка? (нет в POSIX.1-1996.)"

#. type: TP
#: man-pages/man2/stat.2:323
#, no-wrap
msgid "B<S_ISSOCK>(m)"
msgstr "B<S_ISSOCK>(m)"

#. type: Plain text
#: man-pages/man2/stat.2:326
msgid "socket? (Not in POSIX.1-1996.)"
msgstr "сокет? (нет в POSIX.1-1996.)"

#. type: Plain text
#: man-pages/man2/stat.2:329
msgid "The preceding code snippet could thus be rewritten as:"
msgstr ""

#. type: Plain text
#: man-pages/man2/stat.2:336
#, no-wrap
msgid ""
"stat(pathname, &sb);\n"
"if (S_ISREG(sb.st_mode)) {\n"
"    /* Handle regular file */\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/stat.2:360
msgid ""
"The definitions of most of the above file type test macros are provided if "
"any of the following feature test macros is defined: B<_BSD_SOURCE> (in "
"glibc 2.19 and earlier), B<_SVID_SOURCE> (in glibc 2.19 and earlier), or "
"B<_DEFAULT_SOURCE> (in glibc 2.20 and later).  In addition, definitions of "
"all of the above macros except B<S_IFSOCK> and B<S_ISSOCK>()  are provided "
"if B<_XOPEN_SOURCE> is defined.  The definition of B<S_IFSOCK> can also be "
"exposed by defining B<_XOPEN_SOURCE> with a value of 500 or greater."
msgstr ""

#. type: Plain text
#: man-pages/man2/stat.2:372
msgid ""
"The definition of B<S_ISSOCK>()  is exposed if any of the following feature "
"test macros is defined: B<_BSD_SOURCE> (in glibc 2.19 and earlier), "
"B<_DEFAULT_SOURCE> (in glibc 2.20 and later), B<_XOPEN_SOURCE> with a value "
"of 500 or greater, or B<_POSIX_C_SOURCE> with a value of 200112L or greater."
msgstr ""

#. type: Plain text
#: man-pages/man2/stat.2:377
msgid ""
"The following mask values are defined for the file permissions component of "
"the I<st_mode> field:"
msgstr ""

#. type: tbl table
#: man-pages/man2/stat.2:380
#, no-wrap
msgid "S_ISUID\t0004000\tset-user-ID bit\n"
msgstr "S_ISUID\t0004000\tбит set-user-ID\n"

#. type: tbl table
#: man-pages/man2/stat.2:381
#, no-wrap
msgid "S_ISGID\t0002000\tset-group-ID bit (see below)\n"
msgstr "S_ISGID\t0002000\tбит set-group-ID (см. далее)\n"

#. type: tbl table
#: man-pages/man2/stat.2:382
#, no-wrap
msgid "S_ISVTX\t0001000\tsticky bit (see below)\n"
msgstr "S_ISVTX\t0001000\tзакрепляющий бит (см. далее)\n"

#. type: tbl table
#: man-pages/man2/stat.2:384
#, no-wrap
msgid "S_IRWXU\t  00700\tmask for file owner permissions\n"
msgstr "S_IRWXU\t  00700\tмаска для прав доступа владельца файла\n"

#. type: tbl table
#: man-pages/man2/stat.2:385
#, no-wrap
msgid "S_IRUSR\t  00400\towner has read permission\n"
msgstr "S_IRUSR\t  00400\tвладелец имеет право чтения\n"

#. type: tbl table
#: man-pages/man2/stat.2:386
#, no-wrap
msgid "S_IWUSR\t  00200\towner has write permission\n"
msgstr "S_IWUSR\t  00200\tвладелец имеет право записи\n"

#. type: tbl table
#: man-pages/man2/stat.2:387
#, no-wrap
msgid "S_IXUSR\t  00100\towner has execute permission\n"
msgstr "S_IXUSR\t  00100\tвладелец имеет право выполнения\n"

#. type: tbl table
#: man-pages/man2/stat.2:389
#, no-wrap
msgid "S_IRWXG\t  00070\tmask for group permissions\n"
msgstr "S_IRWXG\t  00070\tмаска для прав доступа группы\n"

#. type: tbl table
#: man-pages/man2/stat.2:390
#, no-wrap
msgid "S_IRGRP\t  00040\tgroup has read permission\n"
msgstr "S_IRGRP\t  00040\tгруппа имеет право чтения\n"

#. type: tbl table
#: man-pages/man2/stat.2:391
#, no-wrap
msgid "S_IWGRP\t  00020\tgroup has write permission\n"
msgstr "S_IWGRP\t  00020\tгруппа имеет право записи\n"

#. type: tbl table
#: man-pages/man2/stat.2:392
#, no-wrap
msgid "S_IXGRP\t  00010\tgroup has execute permission\n"
msgstr "S_IXGRP\t  00010\tгруппа имеет право выполнения\n"

#. type: tbl table
#: man-pages/man2/stat.2:394
#, no-wrap
msgid "S_IRWXO\t  00007\tT{\n"
msgstr "S_IRWXO\t  00007\tT{\n"

#. type: tbl table
#: man-pages/man2/stat.2:395
#, no-wrap
msgid "mask for permissions for others (not in group)\n"
msgstr "маска прав доступа всех прочих (вне группы)\n"

#. type: tbl table
#: man-pages/man2/stat.2:397
#, no-wrap
msgid "S_IROTH\t  00004\tothers have read permission\n"
msgstr "S_IROTH\t  00004\tвсе прочие имеют право чтения\n"

#. type: tbl table
#: man-pages/man2/stat.2:398
#, no-wrap
msgid "S_IWOTH\t  00002\tothers have write permission\n"
msgstr "S_IWOTH\t  00002\tвсе прочие имеют право записи\n"

#. type: tbl table
#: man-pages/man2/stat.2:399
#, no-wrap
msgid "S_IXOTH\t  00001\tothers have execute permission\n"
msgstr "S_IXOTH\t  00001\tвсе прочие имеют право выполнения\n"

#. type: Plain text
#: man-pages/man2/stat.2:416
msgid ""
"The set-group-ID bit (B<S_ISGID>)  has several special uses.  For a "
"directory, it indicates that BSD semantics is to be used for that directory:"
" files created there inherit their group ID from the directory, not from the"
" effective group ID of the creating process, and directories created there "
"will also get the B<S_ISGID> bit set.  For a file that does not have the "
"group execution bit (B<S_IXGRP>)  set, the set-group-ID bit indicates "
"mandatory file/record locking."
msgstr "Бит set-group-ID (B<S_ISGID>) имеет несколько специальных применений. Для каталога он указывает, что используется семантика BSD: файлы, создаваемые в каталоге, наследуют ID группы этого каталога, а не фактическую группу создающего процесса, а для подкаталогов данного каталога также будет установлен бит B<S_ISGID>. Если файл не имеет бита выполнения группой (B<S_IXGRP>), то бит set-group-ID означает обязательную (mandatory) блокировку файла/записей."

#. type: Plain text
#: man-pages/man2/stat.2:425
msgid ""
"The sticky bit (B<S_ISVTX>)  on a directory means that a file in that "
"directory can be renamed or deleted only by the owner of the file, by the "
"owner of the directory, and by a privileged process."
msgstr "Закрепляющий (sticky) бит (B<S_ISVTX>) на каталоге означает, что файлы в этом каталоге могут быть удалены или переименованы только владельцем файла, владельцем каталога и привилегированным процессом."

#. type: SS
#: man-pages/man2/stat.2:425
#, no-wrap
msgid "fstatat()"
msgstr "fstatat()"

#. type: Plain text
#: man-pages/man2/stat.2:431
msgid ""
"The B<fstatat>()  system call operates in exactly the same way as B<stat>(),"
" except for the differences described here."
msgstr "Системный вызов B<fstatat>() работает также как системный вызов B<stat>(), за исключением случаев, описанных здесь."

#. type: Plain text
#: man-pages/man2/stat.2:441
msgid ""
"If the pathname given in I<pathname> is relative, then it is interpreted "
"relative to the directory referred to by the file descriptor I<dirfd> "
"(rather than relative to the current working directory of the calling "
"process, as is done by B<stat>()  for a relative pathname)."
msgstr "Если в I<pathname> задан относительный путь, то он считается относительно каталога, на который ссылается файловый дескриптор I<dirfd> (а не относительно текущего рабочего каталога вызывающего процесса, как это делается в B<stat>())."

#. type: Plain text
#: man-pages/man2/stat.2:453
msgid ""
"If I<pathname> is relative and I<dirfd> is the special value B<AT_FDCWD>, "
"then I<pathname> is interpreted relative to the current working directory of"
" the calling process (like B<stat>())."
msgstr "Если в I<pathname> задан относительный путь и значение I<dirfd> равно B<AT_FDCWD>, то I<pathname> рассматривается относительно текущего рабочего каталога вызывающего процесса (как B<stat>())."

#. type: Plain text
#: man-pages/man2/stat.2:459
msgid "If I<pathname> is absolute, then I<dirfd> is ignored."
msgstr "Если в I<pathname> задан абсолютный путь, то I<dirfd> игнорируется."

#. type: Plain text
#: man-pages/man2/stat.2:462
msgid ""
"I<flags> can either be 0, or include one or more of the following flags "
"ORed:"
msgstr "Значение I<flags> может быть 0, или включать один или более следующих флагов:"

#. type: TP
#: man-pages/man2/stat.2:462
#, no-wrap
msgid "B<AT_EMPTY_PATH> (since Linux 2.6.39)"
msgstr "B<AT_EMPTY_PATH> (начиная с Linux 2.6.39)"

#.  commit 65cfc6722361570bfe255698d9cd4dccaf47570d
#.  Before glibc 2.16, defining _ATFILE_SOURCE sufficed
#. type: Plain text
#: man-pages/man2/stat.2:485
msgid ""
"If I<pathname> is an empty string, operate on the file referred to by "
"I<dirfd> (which may have been obtained using the B<open>(2)  B<O_PATH> "
"flag).  If I<dirfd> is B<AT_FDCWD>, the call operates on the current working"
" directory.  In this case, I<dirfd> can refer to any type of file, not just "
"a directory.  This flag is Linux-specific; define B<_GNU_SOURCE> to obtain "
"its definition."
msgstr "Если значение I<pathname> равно пустой строке, то выполнять действие над файлом, на который указывает I<dirfd> (который может быть получен с помощью B<open>(2) с флагом B<O_PATH>). Если I<dirfd> равно B<AT_FDCWD>, то вызов выполняет действие над текущим рабочим каталогом. В этом случае, I<dirfd> может указывать на файл любого типа, а не только на каталог. Этот флаг есть только в Linux; для получения его определения определите B<_GNU_SOURCE>."

#. type: TP
#: man-pages/man2/stat.2:485
#, no-wrap
msgid "B<AT_NO_AUTOMOUNT> (since Linux 2.6.38)"
msgstr "B<AT_NO_AUTOMOUNT> (начиная с Linux 2.6.38)"

#.  Before glibc 2.16, defining _ATFILE_SOURCE sufficed
#. type: Plain text
#: man-pages/man2/stat.2:501
msgid ""
"Don't automount the terminal (\"basename\") component of I<pathname> if it "
"is a directory that is an automount point.  This allows the caller to gather"
" attributes of an automount point (rather than the location it would mount)."
"  This flag can be used in tools that scan directories to prevent mass-"
"automounting of a directory of automount points.  The B<AT_NO_AUTOMOUNT> "
"flag has no effect if the mount point has already been mounted over.  This "
"flag is Linux-specific; define B<_GNU_SOURCE> to obtain its definition."
msgstr "Не выполнять автоматическое монтирование конечного компонента («basename») I<pathname>, если это каталог, который является точкой монтирования. Это позволяет вызывающему получить атрибуты точки монтирования (а не расположения, где её предполагалось смонтировать). Этот флаг можно использовать в инструментах, сканирующих каталоги, для предотвращения массового автоматического монтирования каталогов в их точки монтирования. Флаг B<AT_NO_AUTOMOUNT> не учитывается, если к точке уже уже была выполнено монтирование. Этот флаг есть только Linux; для его получения нужно задать B<_GNU_SOURCE>."

#. type: TP
#: man-pages/man2/stat.2:501
#, no-wrap
msgid "B<AT_SYMLINK_NOFOLLOW>"
msgstr "B<AT_SYMLINK_NOFOLLOW>"

#. type: Plain text
#: man-pages/man2/stat.2:512
msgid ""
"If I<pathname> is a symbolic link, do not dereference it: instead return "
"information about the link itself, like B<lstat>().  (By default, "
"B<fstatat>()  dereferences symbolic links, like B<stat>().)"
msgstr "Если значение I<pathname> является символьной ссылкой, не разыменовывать её, а вернуть информацию о самой ссылке, как это делается в B<lstat>(). (По умолчанию, B<fstatat>() разыменовывает символьные ссылки как и B<stat>().)"

#. type: Plain text
#: man-pages/man2/stat.2:517
msgid "See B<openat>(2)  for an explanation of the need for B<fstatat>()."
msgstr "Смотрите в B<openat>(2) объяснение необходимости B<fstatat>()."

#. type: Plain text
#: man-pages/man2/stat.2:530
msgid ""
"Search permission is denied for one of the directories in the path prefix of"
" I<pathname>.  (See also B<path_resolution>(7).)"
msgstr "Запрещён поиск в одном из каталогов пути I<pathname> (смотрите также B<path_resolution>(7))."

#. type: Plain text
#: man-pages/man2/stat.2:534
msgid "I<fd> is bad."
msgstr "Неправильное значение I<fd>."

#. type: Plain text
#: man-pages/man2/stat.2:540
msgid "Too many symbolic links encountered while traversing the path."
msgstr "Во время определения пути встретилось слишком много символьных ссылок."

#. type: Plain text
#: man-pages/man2/stat.2:544
msgid "I<pathname> is too long."
msgstr "Слишком длинное значение аргумента I<pathname>."

#. type: Plain text
#: man-pages/man2/stat.2:551
msgid ""
"A component of I<pathname> does not exist, or I<pathname> is an empty "
"string."
msgstr "Компонент пути I<pathname> не существует или в I<pathname> указана пустая строка."

#. type: Plain text
#: man-pages/man2/stat.2:554
msgid "Out of memory (i.e., kernel memory)."
msgstr "Не хватает памяти (например, памяти ядра)."

#. type: Plain text
#: man-pages/man2/stat.2:559
msgid "A component of the path prefix of I<pathname> is not a directory."
msgstr "Компонент в префиксе пути I<pathname> не является каталогом."

#. type: Plain text
#: man-pages/man2/stat.2:578
msgid ""
"I<pathname> or I<fd> refers to a file whose size, inode number, or number of"
" blocks cannot be represented in, respectively, the types I<off_t>, "
"I<ino_t>, or I<blkcnt_t>.  This error can occur when, for example, an "
"application compiled on a 32-bit platform without I<-D_FILE_OFFSET_BITS=64> "
"calls B<stat>()  on a file whose size exceeds I<(1E<lt>E<lt>31)-1> bytes."
msgstr "Значение I<pathname> или I<fd> ссылаются на файл, чей размер, номер inode или количество блоков не может быть представлено с помощью типов I<off_t>, I<ino_t> или I<blkcnt_t>, соответственно. Эта ошибка может возникнуть, если, например, приложение собрано на 32-битной платформе без флага I<-D_FILE_OFFSET_BITS=64> при вызове B<stat>() для файла, чей размер превышает I<(1E<lt>E<lt>31)-1> байт."

#. type: Plain text
#: man-pages/man2/stat.2:581
msgid "The following additional errors can occur for B<fstatat>():"
msgstr "В B<fstatat>() дополнительно могут возникнуть следующие ошибки:"

#. type: Plain text
#: man-pages/man2/stat.2:585
msgid "I<dirfd> is not a valid file descriptor."
msgstr "Значение I<dirfd> не является правильным файловым дескриптором."

#. type: Plain text
#: man-pages/man2/stat.2:589
msgid "Invalid flag specified in I<flags>."
msgstr "Указано неверное значение в I<flags>."

#. type: Plain text
#: man-pages/man2/stat.2:595
msgid ""
"I<pathname> is relative and I<dirfd> is a file descriptor referring to a "
"file other than a directory."
msgstr "Значение I<pathname> содержит относительный путь и I<dirfd> содержит файловый дескриптор, указывающий на файл, а не на каталог."

#. type: Plain text
#: man-pages/man2/stat.2:599
msgid ""
"B<fstatat>()  was added to Linux in kernel 2.6.16; library support was added"
" to glibc in version 2.4."
msgstr "Вызов B<fstatat>() был добавлен в ядро Linux версии 2.6.16; поддержка в glibc доступна с версии 2.4."

#.  SVr4 documents additional
#.  .BR fstat ()
#.  error conditions EINTR, ENOLINK, and EOVERFLOW.  SVr4
#.  documents additional
#.  .BR stat ()
#.  and
#.  .BR lstat ()
#.  error conditions EINTR, EMULTIHOP, ENOLINK, and EOVERFLOW.
#. type: Plain text
#: man-pages/man2/stat.2:612
msgid ""
"B<stat>(), B<fstat>(), B<lstat>(): SVr4, 4.3BSD, POSIX.1-2001, POSIX.1.2008."
msgstr "B<stat>(), B<fstat>(), B<lstat>(): SVr4, 4.3BSD, POSIX.1-2001, POSIX.1.2008."

#. type: Plain text
#: man-pages/man2/stat.2:615
msgid "B<fstatat>(): POSIX.1-2008."
msgstr "B<fstatat>(): POSIX.1-2008."

#. type: Plain text
#: man-pages/man2/stat.2:629
msgid ""
"According to POSIX.1-2001, B<lstat>()  on a symbolic link need return valid "
"information only in the I<st_size> field and the file-type component of the "
"I<st_mode> field of the I<stat> structure.  POSIX.1-2008 tightens the "
"specification, requiring B<lstat>()  to return valid information in all "
"fields except the permission bits in I<st_mode>."
msgstr "Согласно POSIX.11-2001, B<lstat>() для символьной ссылки требует вернуть корректную информацию только в поле I<st_size> и компоненте типа файла в поле I<st_mode> структуры I<stat>. В POSIX.1-2008 более жёсткая спецификация, требующая, чтобы B<lstat>() возвращал корректную информацию во всех полях кроме битов доступа в I<st_mode>."

#. type: Plain text
#: man-pages/man2/stat.2:649
msgid ""
"Use of the I<st_blocks> and I<st_blksize> fields may be less portable.  "
"(They were introduced in BSD.  The interpretation differs between systems, "
"and possibly on a single system when NFS mounts are involved.)  If you need "
"to obtain the definition of the I<blkcnt_t> or I<blksize_t> types from "
"I<E<lt>sys/stat.hE<gt>>, then define B<_XOPEN_SOURCE> with the value 500 or "
"greater (before including I<any> header files)."
msgstr "Использование полей I<st_blocks> и I<st_blksize> может усложнить перенос на другие платформы (эти поля появились из BSD. В разных системах они трактуются по-разному и, вероятно, даже в одной системе при использовании NFS). Если вам нужно получить определение типа I<blkcnt_t> или I<blksize_t> из I<E<lt>sys/stat.hE<gt>>, то определите B<_XOPEN_SOURCE> со значением 500 или больше (до включения I<каких-либо> заголовочных файлов)."

#. type: Plain text
#: man-pages/man2/stat.2:667
msgid ""
"POSIX.1-1990 did not describe the B<S_IFMT>, B<S_IFSOCK>, B<S_IFLNK>, "
"B<S_IFREG>, B<S_IFBLK>, B<S_IFDIR>, B<S_IFCHR>, B<S_IFIFO>, B<S_ISVTX> "
"constants, but instead demanded the use of the macros B<S_ISDIR>(), and so "
"on.  The B<S_IF*> constants are present in POSIX.1-2001 and later."
msgstr "В POSIX.1-1990 не описаны константы B<S_IFMT>, B<S_IFSOCK>, B<S_IFLNK>, B<S_IFREG>, B<S_IFBLK>, B<S_IFDIR>, B<S_IFCHR>, B<S_IFIFO>, B<S_ISVTX>, вместо них требуется использовать макросы B<S_ISDIR>() и т.п. Константы B<S_IF*> определены в POSIX.1-2001 и новее."

#. type: Plain text
#: man-pages/man2/stat.2:675
msgid ""
"The B<S_ISLNK>()  and B<S_ISSOCK>()  macros are not in POSIX.1-1996, but "
"both are present in POSIX.1-2001; the former is from SVID 4, the latter from"
" SUSv2."
msgstr "Макросы B<S_ISLNK>() и B<S_ISSOCK>() не описаны в POSIX.1-1996, но есть в POSIX.1-2001; первый взят из SVID 4, последний из SUSv2."

#. type: Plain text
#: man-pages/man2/stat.2:685
msgid ""
"UNIX\\ V7 (and later systems) had B<S_IREAD>, B<S_IWRITE>, B<S_IEXEC>, where"
" POSIX prescribes the synonyms B<S_IRUSR>, B<S_IWUSR>, B<S_IXUSR>."
msgstr "В UNIX\\ V7 (и более поздних системах) есть B<S_IREAD>, B<S_IWRITE>, B<S_IEXEC>, для которых в POSIX есть синонимы B<S_IRUSR>, B<S_IWUSR>, B<S_IXUSR>."

#. type: SS
#: man-pages/man2/stat.2:685
#, no-wrap
msgid "Other systems"
msgstr "Другие системы"

#. type: Plain text
#: man-pages/man2/stat.2:687
msgid "Values that have been (or are) in use on various systems:"
msgstr "Значения, которые использовались (или используются) в различных системах:"

#. type: tbl table
#: man-pages/man2/stat.2:690
#, no-wrap
msgid "hex\tname\tls\toctal\tdescription\n"
msgstr "шест.\tимя\tls\tвосм.\tописание\n"

#. type: tbl table
#: man-pages/man2/stat.2:691
#, no-wrap
msgid "f000\tS_IFMT\t\t170000\tmask for file type\n"
msgstr "f000\tS_IFMT\t\t170000\tмаска типа файла\n"

#. type: tbl table
#: man-pages/man2/stat.2:692
#, no-wrap
msgid "0000\t\t\t000000\tT{\n"
msgstr "0000\t\t\t000000\tT{\n"

#. type: tbl table
#: man-pages/man2/stat.2:693
#, no-wrap
msgid "SCO out-of-service inode; BSD unknown type; SVID-v2 and XPG2\n"
msgstr "в SCO — недействующий inode; в BSD — неизвестный тип; в SVID-v2 и XPG2 —\n"

#. type: tbl table
#: man-pages/man2/stat.2:694
#, no-wrap
msgid "have both 0 and 0100000 for ordinary file\n"
msgstr "0 и 0100000 означают обычный файл\n"

#. type: tbl table
#: man-pages/man2/stat.2:696
#, no-wrap
msgid "1000\tS_IFIFO\tp|\t010000\tFIFO (named pipe)\n"
msgstr "1000\tS_IFIFO\tp|\t010000\tFIFO (именованный канал)\n"

#. type: tbl table
#: man-pages/man2/stat.2:697
#, no-wrap
msgid "2000\tS_IFCHR\tc\t020000\tcharacter special (V7)\n"
msgstr "2000\tS_IFCHR\tc\t020000\tсимвольный специальный (V7)\n"

#. type: tbl table
#: man-pages/man2/stat.2:698
#, no-wrap
msgid "3000\tS_IFMPC\t\t030000\tmultiplexed character special (V7)\n"
msgstr "3000\tS_IFMPC\t\t030000\tмультиплексированный символьный\n\t\t\t\tспециальный (V7)\n"

#. type: tbl table
#: man-pages/man2/stat.2:699
#, no-wrap
msgid "4000\tS_IFDIR\td/\t040000\tdirectory (V7)\n"
msgstr "4000\tS_IFDIR\td/\t040000\tкаталог (V7)\n"

#. type: tbl table
#: man-pages/man2/stat.2:700
#, no-wrap
msgid "5000\tS_IFNAM\t\t050000\tT{\n"
msgstr "5000\tS_IFNAM\t\t050000\tT{\n"

#. type: tbl table
#: man-pages/man2/stat.2:701
#, no-wrap
msgid "XENIX named special file with two subtypes, distinguished by\n"
msgstr "в XENIX — именованный специальный файл с двумя подтипами, различающимися\n"

#. type: tbl table
#: man-pages/man2/stat.2:702
#, no-wrap
msgid "I<st_rdev> values 1, 2\n"
msgstr "значениями I<st_rdev> — 1, 2\n"

#. type: tbl table
#: man-pages/man2/stat.2:704
#, no-wrap
msgid "0001\tS_INSEM\ts\t000001\tXENIX semaphore subtype of IFNAM\n"
msgstr "0001\tS_INSEM\ts\t000001\tподтип IFNAM семафора XENIX\n"

#. type: tbl table
#: man-pages/man2/stat.2:705
#, no-wrap
msgid "0002\tS_INSHD\tm\t000002\tXENIX shared data subtype of IFNAM\n"
msgstr "0002\tS_INSHD\tm\t000002\tподтип IFNAM общих данных XENIX\n"

#. type: tbl table
#: man-pages/man2/stat.2:706
#, no-wrap
msgid "6000\tS_IFBLK\tb\t060000\tblock special (V7)\n"
msgstr "6000\tS_IFBLK\tb\t060000\tблочный специальный (V7)\n"

#. type: tbl table
#: man-pages/man2/stat.2:707
#, no-wrap
msgid "7000\tS_IFMPB\t\t070000\tmultiplexed block special (V7)\n"
msgstr "7000\tS_IFMPB\t\t070000\tмультиплексированный блочный\n\t\t\t\tспециальный (V7)\n"

#. type: tbl table
#: man-pages/man2/stat.2:708
#, no-wrap
msgid "8000\tS_IFREG\t-\t100000\tregular (V7)\n"
msgstr "8000\tS_IFREG\t-\t100000\tобычный (V7)\n"

#. type: tbl table
#: man-pages/man2/stat.2:709
#, no-wrap
msgid "9000\tS_IFCMP\t\t110000\tVxFS compressed\n"
msgstr "9000\tS_IFCMP\t\t110000\tVxFS: сжатый\n"

#. type: tbl table
#: man-pages/man2/stat.2:710
#, no-wrap
msgid "9000\tS_IFNWK\tn\t110000\tnetwork special (HP-UX)\n"
msgstr "9000\tS_IFNWK\tn\t110000\tсетевой специальный (HP-UX)\n"

#. type: tbl table
#: man-pages/man2/stat.2:711
#, no-wrap
msgid "a000\tS_IFLNK\tl@\t120000\tsymbolic link (BSD)\n"
msgstr "a000\tS_IFLNK\tl@\t120000\tсимвольная ссылка (BSD)\n"

#. type: tbl table
#: man-pages/man2/stat.2:712
#, no-wrap
msgid "b000\tS_IFSHAD\t\t130000\tT{\n"
msgstr "b000\tS_IFSHAD\t\t130000\tT{\n"

#. type: tbl table
#: man-pages/man2/stat.2:713
#, no-wrap
msgid "Solaris shadow inode for ACL (not seen by user space)\n"
msgstr "в Solaris — теневой inode для ACL (не виден пользовательскими процессами)\n"

#. type: tbl table
#: man-pages/man2/stat.2:715
#, no-wrap
msgid "c000\tS_IFSOCK\ts=\t140000\tsocket (BSD; also \"S_IFSOC\" on VxFS)\n"
msgstr "c000\tS_IFSOCK\ts=\t140000\tсокет (BSD; также «S_IFSOC» в VxFS)\n"

#. type: tbl table
#: man-pages/man2/stat.2:716
#, no-wrap
msgid "d000\tS_IFDOOR\tDE<gt>\t150000\tSolaris door\n"
msgstr "d000\tS_IFDOOR\tDE<gt>\t150000\tSolaris: дверь\n"

#. type: tbl table
#: man-pages/man2/stat.2:717
#, no-wrap
msgid "e000\tS_IFWHT\tw%\t160000\tBSD whiteout (not used for inode)\n"
msgstr "e000\tS_IFWHT\tw%\t160000\tBSD whiteout (не используется для inode)\n"

#. type: tbl table
#: man-pages/man2/stat.2:718
#, no-wrap
msgid "0200\tS_ISVTX\t\t001000\tT{\n"
msgstr "0200\tS_ISVTX\t\t001000\tT{\n"

#. type: tbl table
#: man-pages/man2/stat.2:719
#, no-wrap
msgid "sticky bit: save swapped text even after use (V7)\n"
msgstr "закрепляющий бит: сохраняет код программы в файле подкачки даже после использования (V7)\n"

#. type: tbl table
#: man-pages/man2/stat.2:721
#, no-wrap
msgid "reserved (SVID-v2)\n"
msgstr "зарезервировано (SVID-v2)\n"

#. type: tbl table
#: man-pages/man2/stat.2:723
#, no-wrap
msgid "On nondirectories: don't cache this file (SunOS)\n"
msgstr "для не каталогов: не кэшировать этот файл (SunOS)\n"

#. type: tbl table
#: man-pages/man2/stat.2:725
#, no-wrap
msgid "On directories: restricted deletion flag (SVID-v4.2)\n"
msgstr "для каталогов: флаг ограниченного удаления (SVID-v4.2)\n"

#. type: tbl table
#: man-pages/man2/stat.2:727
#, no-wrap
msgid "0400\tS_ISGID\t\t002000\tT{\n"
msgstr "0400\tS_ISGID\t\t002000\tT{\n"

#. type: tbl table
#: man-pages/man2/stat.2:728
#, no-wrap
msgid "set-group-ID on execution (V7)\n"
msgstr "set-group-ID при выполнении (V7)\n"

#. type: tbl table
#: man-pages/man2/stat.2:730
#, no-wrap
msgid "for directories: use BSD semantics for propagation of GID\n"
msgstr "для каталогов: использовать семантику BSD для распространения GID\n"

#. type: tbl table
#: man-pages/man2/stat.2:732
#, no-wrap
msgid "0400\tS_ENFMT\t\t002000\tT{\n"
msgstr "0400\tS_ENFMT\t\t002000\tT{\n"

#. type: tbl table
#: man-pages/man2/stat.2:733
#, no-wrap
msgid "System V file locking enforcement (shared with S_ISGID)\n"
msgstr "жёсткая блокировка файлов в стиле System V (общий c S_ISGID)\n"

#. type: tbl table
#: man-pages/man2/stat.2:735
#, no-wrap
msgid "0800\tS_ISUID\t\t004000\tset-user-ID on execution (V7)\n"
msgstr "0800\tS_ISUID\t\t004000\tset-user-ID на выполнение (V7)\n"

#. type: tbl table
#: man-pages/man2/stat.2:736
#, no-wrap
msgid "0800\tS_CDF\t\t004000\tT{\n"
msgstr "0800\tS_CDF\t\t004000\tT{\n"

#. type: tbl table
#: man-pages/man2/stat.2:737
#, no-wrap
msgid "directory is a context dependent file (HP-UX)\n"
msgstr "каталог является файлом, зависящим от контекста (HP-UX)\n"

#. type: Plain text
#: man-pages/man2/stat.2:743
msgid "A sticky command appeared in Version 32V AT&T UNIX."
msgstr "Закрепляющий бит появился в Version 32V AT&T UNIX."

#. type: Plain text
#: man-pages/man2/stat.2:750
msgid ""
"On Linux, B<lstat>()  will generally not trigger automounter action, whereas"
" B<stat>()  will (but see B<fstatat>(2))."
msgstr "В Linux B<lstat>(), обычно, не вызывает автоматическое монтирование, в отличие от B<stat>() (но смотрите B<fstatat>(2))."

#. type: Plain text
#: man-pages/man2/stat.2:758
msgid ""
"For most files under the I</proc> directory, B<stat>()  does not return the "
"file size in the I<st_size> field; instead the field is returned with the "
"value 0."
msgstr "Для большинства файлов в каталоге I</proc> вызов B<stat>() не возвращает размер файла в поле I<st_size> (значение этого поля равно 0)."

#. type: SS
#: man-pages/man2/stat.2:758
#, no-wrap
msgid "Timestamp fields"
msgstr "Поля с отметками времени"

#. type: Plain text
#: man-pages/man2/stat.2:769
msgid ""
"Older kernels and older standards did not support nanosecond timestamp "
"fields.  Instead, there were three timestamp fields\\(emI<st_atime>, "
"I<st_mtime>, and I<st_ctime>\\(emtyped as I<time_t> that recorded timestamps"
" with one-second precision."
msgstr ""

#. type: Plain text
#: man-pages/man2/stat.2:791
msgid ""
"Since kernel 2.5.48, the I<stat> structure supports nanosecond resolution "
"for the three file timestamp fields.  The nanosecond components of each "
"timestamp are available via names of the form I<st_atim.tv_nsec> if the "
"B<_BSD_SOURCE> or B<_SVID_SOURCE> feature test macro is defined.  Nanosecond"
" timestamps are nowadays standardized, starting with POSIX.1-2008, and, "
"starting with version 2.12, glibc also exposes the nanosecond component "
"names if B<_POSIX_C_SOURCE> is defined with the value 200809L or greater, or"
" B<_XOPEN_SOURCE> is defined with the value 700 or greater.  If none of the "
"aforementioned macros are defined, then the nanosecond values are exposed "
"with names of the form I<st_atimensec>."
msgstr ""

#.  commit ef7f38359ea8b3e9c7f2cae9a4d4935f55ca9e80
#. type: Plain text
#: man-pages/man2/stat.2:798
msgid ""
"Nanosecond timestamps are supported on XFS, JFS, Btrfs, and ext4 (since "
"Linux 2.6.23).  Nanosecond timestamps are not supported in ext2, ext3, and "
"Reiserfs.  On filesystems that do not support subsecond timestamps, the "
"nanosecond fields are returned with the value 0."
msgstr ""

#. type: SS
#: man-pages/man2/stat.2:798
#, no-wrap
msgid "Underlying kernel interface"
msgstr "Ядерный интерфейс, лежащий в основе"

#.  A note from Andries Brouwer, July 2007
#.  > Is the story not rather more complicated for some calls like
#.  > stat(2)?
#.  Yes and no, mostly no. See /usr/include/sys/stat.h .
#.  The idea is here not so much that syscalls change, but that
#.  the definitions of struct stat and of the types dev_t and mode_t change.
#.  This means that libc (even if it does not call the kernel
#.  but only calls some internal function) must know what the
#.  format of dev_t or of struct stat is.
#.  The communication between the application and libc goes via
#.  the include file <sys/stat.h> that defines a _STAT_VER and
#.  _MKNOD_VER describing the layout of the data that user space
#.  uses. Each (almost each) occurrence of stat() is replaced by
#.  an occurrence of xstat() where the first parameter of xstat()
#.  is this version number _STAT_VER.
#.  Now, also the definitions used by the kernel change.
#.  But glibc copes with this in the standard way, and the
#.  struct stat as returned by the kernel is repacked into
#.  the struct stat as expected by the application.
#.  Thus, _STAT_VER and this setup cater for the application-libc
#.  interface, rather than the libc-kernel interface.
#.  (Note that the details depend on gcc being used as c compiler.)
#. type: Plain text
#: man-pages/man2/stat.2:850
msgid ""
"Over time, increases in the size of the I<stat> structure have led to three "
"successive versions of B<stat>(): I<sys_stat>()  (slot I<__NR_oldstat>), "
"I<sys_newstat>()  (slot I<__NR_stat>), and I<sys_stat64()> (new in kernel "
"2.4; slot I<__NR_stat64>).  The glibc B<stat>()  wrapper function hides "
"these details from applications, invoking the most recent version of the "
"system call provided by the kernel, and repacking the returned information "
"if required for old binaries.  Similar remarks apply for B<fstat>()  and "
"B<lstat>()."
msgstr "В течении долгого времени увеличение размера структуры I<stat> привело к появлению трёх новых версий B<stat>(): I<sys_stat>() (слот I<__NR_oldstat>), I<sys_newstat>() (слот I<__NR_stat>) и I<sys_stat64()> (новый в ядре 2.4; слот I<__NR_stat64>). Обёрточная функция glibc B<stat>() прячет эти подробности от приложений, вызывая самую новую версию системного вызова, предоставляемого ядром, и перепаковывая возвращаемую информацию, если это нужно для старых программ. Подобное замечание применимо к B<fstat>() и B<lstat>()."

#. type: Plain text
#: man-pages/man2/stat.2:855
msgid ""
"The underlying system call employed by the glibc B<fstatat>()  wrapper "
"function is actually called B<fstatat64>()."
msgstr "Нижележащий системный вызов, используемый обёрточной функцией B<fstatat>() в glibc, на самом деле вызывает B<fstatat64>()."

#. type: Plain text
#: man-pages/man2/stat.2:861
msgid ""
"The following program calls B<stat>()  and displays selected fields in the "
"returned I<stat> structure."
msgstr "Следующая программа вызывает B<stat>() и показывает некоторые поля из полученной структуры I<stat>."

#. type: Plain text
#: man-pages/man2/stat.2:868
#, no-wrap
msgid ""
"#include E<lt>sys/types.hE<gt>\n"
"#include E<lt>sys/stat.hE<gt>\n"
"#include E<lt>time.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
msgstr "#include E<lt>sys/types.hE<gt>\n#include E<lt>sys/stat.hE<gt>\n#include E<lt>time.hE<gt>\n#include E<lt>stdio.hE<gt>\n#include E<lt>stdlib.hE<gt>\n"

#. type: Plain text
#: man-pages/man2/stat.2:873
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    struct stat sb;\n"
msgstr "int\nmain(int argc, char *argv[])\n{\n    struct stat sb;\n"

#. type: Plain text
#: man-pages/man2/stat.2:878
#, no-wrap
msgid ""
"    if (argc != 2) {\n"
"        fprintf(stderr, \"Usage: %s E<lt>pathnameE<gt>\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr "    if (argc != 2) {\n        fprintf(stderr, \"Использование: %s E<lt>путьE<gt>\\en\", argv[0]);\n        exit(EXIT_FAILURE);\n    }\n"

#. type: Plain text
#: man-pages/man2/stat.2:883
#, no-wrap
msgid ""
"    if (stat(argv[1], &sb) == -1) {\n"
"        perror(\"stat\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr "    if (stat(argv[1], &sb) == -1) {\n        perror(\"stat\");\n        exit(EXIT_FAILURE);\n    }\n"

#. type: Plain text
#: man-pages/man2/stat.2:885
#, no-wrap
msgid "    printf(\"File type:                \");\n"
msgstr "    printf(\"Тип файла:                \");\n"

#. type: Plain text
#: man-pages/man2/stat.2:896
#, no-wrap
msgid ""
"    switch (sb.st_mode & S_IFMT) {\n"
"    case S_IFBLK:  printf(\"block device\\en\");            break;\n"
"    case S_IFCHR:  printf(\"character device\\en\");        break;\n"
"    case S_IFDIR:  printf(\"directory\\en\");               break;\n"
"    case S_IFIFO:  printf(\"FIFO/pipe\\en\");               break;\n"
"    case S_IFLNK:  printf(\"symlink\\en\");                 break;\n"
"    case S_IFREG:  printf(\"regular file\\en\");            break;\n"
"    case S_IFSOCK: printf(\"socket\\en\");                  break;\n"
"    default:       printf(\"unknown?\\en\");                break;\n"
"    }\n"
msgstr "    switch (sb.st_mode & S_IFMT) {\n    case S_IFBLK:  printf(\"блочное устройство\\en\");     break;\n    case S_IFCHR:  printf(\"символьное устройство\\en\");  break;\n    case S_IFDIR:  printf(\"каталог\\en\");                break;\n    case S_IFIFO:  printf(\"FIFO/канал\\en\");             break;\n    case S_IFLNK:  printf(\"символьная ссылка\\en\");      break;\n    case S_IFREG:  printf(\"обычный файл\\en\");           break;\n    case S_IFSOCK: printf(\"сокет\\en\");                  break;\n    default:       printf(\"неизвестно?\\en\");            break;\n    }\n"

#. type: Plain text
#: man-pages/man2/stat.2:898
#, no-wrap
msgid "    printf(\"I-node number:            %ld\\en\", (long) sb.st_ino);\n"
msgstr "    printf(\"номер inode:              %ld\\en\", (long) sb.st_ino);\n"

#. type: Plain text
#: man-pages/man2/stat.2:901
#, no-wrap
msgid ""
"    printf(\"Mode:                     %lo (octal)\\en\",\n"
"            (unsigned long) sb.st_mode);\n"
msgstr "    printf(\"Режим доступа:            %lo (octal)\\en\",\n            (unsigned long) sb.st_mode);\n"

#. type: Plain text
#: man-pages/man2/stat.2:905
#, no-wrap
msgid ""
"    printf(\"Link count:               %ld\\en\", (long) sb.st_nlink);\n"
"    printf(\"Ownership:                UID=%ld   GID=%ld\\en\",\n"
"            (long) sb.st_uid, (long) sb.st_gid);\n"
msgstr "    printf(\"Кол-во ссылок:            %ld\\en\", (long) sb.st_nlink);\n    printf(\"Владелец:                 UID=%ld   GID=%ld\\en\",\n            (long) sb.st_uid, (long) sb.st_gid);\n"

#. type: Plain text
#: man-pages/man2/stat.2:912
#, no-wrap
msgid ""
"    printf(\"Preferred I/O block size: %ld bytes\\en\",\n"
"            (long) sb.st_blksize);\n"
"    printf(\"File size:                %lld bytes\\en\",\n"
"            (long long) sb.st_size);\n"
"    printf(\"Blocks allocated:         %lld\\en\",\n"
"            (long long) sb.st_blocks);\n"
msgstr "    printf(\"Предпоч. размер бл. в/в:  %ld байт\\en\",\n            (long) sb.st_blksize);\n    printf(\"Размер файла:             %lld байт\\en\",\n            (long long) sb.st_size);\n    printf(\"Выделено блоков:          %lld\\en\",\n            (long long) sb.st_blocks);\n"

#. type: Plain text
#: man-pages/man2/stat.2:916
#, no-wrap
msgid ""
"    printf(\"Last status change:       %s\", ctime(&sb.st_ctime));\n"
"    printf(\"Last file access:         %s\", ctime(&sb.st_atime));\n"
"    printf(\"Last file modification:   %s\", ctime(&sb.st_mtime));\n"
msgstr "    printf(\"Посл. изм. состояния:     %s\", ctime(&sb.st_ctime));\n    printf(\"Посл. доступ к файлу:     %s\", ctime(&sb.st_atime));\n    printf(\"Посл. изм. файла:         %s\", ctime(&sb.st_mtime));\n"

#. type: Plain text
#: man-pages/man2/stat.2:919
#, no-wrap
msgid ""
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr "    exit(EXIT_SUCCESS);\n}\n"

#. type: Plain text
#: man-pages/man2/stat.2:929
msgid ""
"B<ls>(1), B<stat>(1), B<access>(2), B<chmod>(2), B<chown>(2), "
"B<readlink>(2), B<utime>(2), B<capabilities>(7), B<symlink>(7)"
msgstr "B<ls>(1), B<stat>(1), B<access>(2), B<chmod>(2), B<chown>(2), B<readlink>(2), B<utime>(2), B<capabilities>(7), B<symlink>(7)"

#. type: TH
#: man-pages/man2/sigsuspend.2:29
#, no-wrap
msgid "SIGSUSPEND"
msgstr "SIGSUSPEND"

#. type: Plain text
#: man-pages/man2/sigsuspend.2:32
msgid "sigsuspend - wait for a signal"
msgstr "sigsuspend - ожидает сигнала"

#. type: Plain text
#: man-pages/man2/sigsuspend.2:36
msgid "B<int sigsuspend(const sigset_t *>I<mask>B<);>"
msgstr "B<int sigsuspend(const sigset_t *>I<mask>B<);>"

#. type: Plain text
#: man-pages/man2/sigsuspend.2:45
msgid ""
"B<sigsuspend>(): _POSIX_C_SOURCE\\ E<gt>=\\ 1 || _XOPEN_SOURCE || "
"_POSIX_SOURCE"
msgstr "B<sigsuspend>(): _POSIX_C_SOURCE\\ E<gt>=\\ 1 || _XOPEN_SOURCE || _POSIX_SOURCE"

#. type: Plain text
#: man-pages/man2/sigsuspend.2:53
msgid ""
"B<sigsuspend>()  temporarily replaces the signal mask of the calling process"
" with the mask given by I<mask> and then suspends the process until delivery"
" of a signal whose action is to invoke a signal handler or to terminate a "
"process."
msgstr "Вызов B<sigsuspend>() временно заменяет маску сигналов вызывающего процесса маской, указанной в I<mask>, и затем приостанавливает процесс до тех пор, пока не поступит сигнал, для которого запустится обработчик сигнала или это приведёт к завершению процесса."

#. type: Plain text
#: man-pages/man2/sigsuspend.2:62
msgid ""
"If the signal terminates the process, then B<sigsuspend>()  does not return."
"  If the signal is caught, then B<sigsuspend>()  returns after the signal "
"handler returns, and the signal mask is restored to the state before the "
"call to B<sigsuspend>()."
msgstr "Если по сигналу процесс завершается, то вызов B<sigsuspend>() не возвращает управление обратно в программу. Если сигнал пойман, то возврат из B<sigsuspend>() произойдёт после завершения выполнения обработчика, и маска сигналов восстановится в значение, которое было до вызова B<sigsuspend>()."

#. type: Plain text
#: man-pages/man2/sigsuspend.2:70
msgid ""
"It is not possible to block B<SIGKILL> or B<SIGSTOP>; specifying these "
"signals in I<mask>, has no effect on the process's signal mask."
msgstr "Сигналы B<SIGKILL> и B<SIGSTOP> невозможно заблокировать; указание этих этих сигналов в I<mask> не влияет на маску сигналов процесса."

#. type: Plain text
#: man-pages/man2/sigsuspend.2:76
msgid ""
"B<sigsuspend>()  always returns -1, with I<errno> set to indicate the error "
"(normally, B<EINTR>)."
msgstr "Вызов B<sigsuspend>() всегда возвращает -1; I<errno> присваивается номер ошибки (обычно B<EINTR>)."

#. type: Plain text
#: man-pages/man2/sigsuspend.2:81
msgid ""
"I<mask> points to memory which is not a valid part of the process address "
"space."
msgstr "Аргумент I<mask> указывает на память в недопустимой части адресного пространства процесса."

#. type: Plain text
#: man-pages/man2/sigsuspend.2:84
msgid "The call was interrupted by a signal."
msgstr "Вызов был прерван сигналом."

#. type: Plain text
#: man-pages/man2/sigsuspend.2:104
msgid ""
"Normally, B<sigsuspend>()  is used in conjunction with B<sigprocmask>(2)  in"
" order to prevent delivery of a signal during the execution of a critical "
"code section.  The caller first blocks the signals with B<sigprocmask>(2).  "
"When the critical code has completed, the caller then waits for the signals "
"by calling B<sigsuspend>()  with the signal mask that was returned by "
"B<sigprocmask>(2)  (in the I<oldset> argument)."
msgstr "Обычно, B<sigsuspend>() используется вместе с B<sigprocmask>(2), чтобы предотвратить доставку сигнала при выполнении критического участка кода. Сначала вызывающий блокирует сигналы с помощью B<sigprocmask>(2). Когда критический участок выполнен, вызывающий начинает ждать сигналов с помощью вызова B<sigsuspend>(), указав маску, значение которой было возвращено вызовом B<sigprocmask>(2) (в аргументе I<oldset>)."

#. type: Plain text
#: man-pages/man2/sigsuspend.2:117
msgid ""
"B<kill>(2), B<pause>(2), B<sigaction>(2), B<signal>(2), B<sigprocmask>(2), "
"B<sigwaitinfo>(2), B<sigsetops>(3), B<sigwait>(3), B<signal>(7)"
msgstr "B<kill>(2), B<pause>(2), B<sigaction>(2), B<signal>(2), B<sigprocmask>(2), B<sigwaitinfo>(2), B<sigsetops>(3), B<sigwait>(3), B<signal>(7)"

#. type: TH
#: man-pages/man2/setns.2:8
#, no-wrap
msgid "SETNS"
msgstr "SETNS"

#. type: TH
#: man-pages/man2/setns.2:8
#, no-wrap
msgid "2013-01-01"
msgstr "2013-01-01"

#. type: Plain text
#: man-pages/man2/setns.2:11
msgid "setns - reassociate thread with a namespace"
msgstr ""

#. type: Plain text
#: man-pages/man2/setns.2:17
#, no-wrap
msgid "B<int setns(int >I<fd>B<, int >I<nstype>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/setns.2:21
msgid ""
"Given a file descriptor referring to a namespace, reassociate the calling "
"thread with that namespace."
msgstr ""

#. type: Plain text
#: man-pages/man2/setns.2:34
msgid ""
"The I<fd> argument is a file descriptor referring to one of the namespace "
"entries in a I</proc/[pid]/ns/> directory; see B<proc>(5)  for further "
"information on I</proc/[pid]/ns/>.  The calling thread will be reassociated "
"with the corresponding namespace, subject to any constraints imposed by the "
"I<nstype> argument."
msgstr ""

#. type: Plain text
#: man-pages/man2/setns.2:40
msgid ""
"The I<nstype> argument specifies which type of namespace the calling thread "
"may be reassociated with.  This argument can have one of the following "
"values:"
msgstr ""

#. type: TP
#: man-pages/man2/setns.2:40
#, no-wrap
msgid "B<0>"
msgstr "B<0>"

#. type: Plain text
#: man-pages/man2/setns.2:43
msgid "Allow any type of namespace to be joined."
msgstr ""

#. type: TP
#: man-pages/man2/setns.2:43
#, no-wrap
msgid "B<CLONE_NEWIPC>"
msgstr ""

#. type: Plain text
#: man-pages/man2/setns.2:47
msgid "I<fd> must refer to an IPC namespace."
msgstr ""

#. type: TP
#: man-pages/man2/setns.2:47
#, no-wrap
msgid "B<CLONE_NEWNET>"
msgstr ""

#. type: Plain text
#: man-pages/man2/setns.2:51
msgid "I<fd> must refer to a network namespace."
msgstr ""

#. type: TP
#: man-pages/man2/setns.2:51
#, no-wrap
msgid "B<CLONE_NEWUTS>"
msgstr ""

#. type: Plain text
#: man-pages/man2/setns.2:55
msgid "I<fd> must refer to a UTS namespace."
msgstr ""

#. type: Plain text
#: man-pages/man2/setns.2:70
msgid ""
"Specifying I<nstype> as 0 suffices if the caller knows (or does not care)  "
"what type of namespace is referred to by I<fd>.  Specifying a nonzero value "
"for I<nstype> is useful if the caller does not know what type of namespace "
"is referred to by I<fd> and wants to ensure that the namespace is of a "
"particular type.  (The caller might not know the type of the namespace "
"referred to by I<fd> if the file descriptor was opened by another process "
"and, for example, passed to the caller via a UNIX domain socket.)"
msgstr ""

#. type: Plain text
#: man-pages/man2/setns.2:77
msgid ""
"On success, I<setns>()  returns 0.  On failure, -1 is returned and I<errno> "
"is set to indicate the error."
msgstr ""

#. type: Plain text
#: man-pages/man2/setns.2:89
msgid ""
"I<fd> refers to a namespace whose type does not match that specified in "
"I<nstype>, or there is problem with reassociating the the thread with the "
"specified namespace."
msgstr ""

#. type: Plain text
#: man-pages/man2/setns.2:92
msgid "Cannot allocate sufficient memory to change the specified namespace."
msgstr ""

#. type: Plain text
#: man-pages/man2/setns.2:97
msgid ""
"The calling thread did not have the required privilege (B<CAP_SYS_ADMIN>)  "
"for this operation."
msgstr ""

#. type: Plain text
#: man-pages/man2/setns.2:102
msgid ""
"The B<setns>()  system call first appeared in Linux in kernel 3.0; library "
"support was added to glibc in version 2.14."
msgstr ""

#. type: Plain text
#: man-pages/man2/setns.2:106
msgid "The B<setns>()  system call is Linux-specific."
msgstr ""

#. type: Plain text
#: man-pages/man2/setns.2:112
msgid ""
"Not all of the attributes that can be shared when a new thread is created "
"using B<clone>(2)  can be changed using B<setns>()."
msgstr ""

#. type: Plain text
#: man-pages/man2/setns.2:121
msgid ""
"The program below takes two or more arguments.  The first argument specifies"
" the pathname of a namespace file in an existing I</proc/[pid]/ns/> "
"directory.  The remaining arguments specify a command and its arguments.  "
"The program opens the namespace file, joins that namespace using B<setns>(),"
" and executes the specified command inside that namespace."
msgstr ""

#. type: Plain text
#: man-pages/man2/setns.2:131
msgid ""
"The following shell session demonstrates the use of this program (compiled "
"as a binary named I<ns_exec>)  in conjunction with the B<CLONE_NEWUTS> "
"example program in the B<clone>(2)  man page (complied as a binary named "
"I<newuts>)."
msgstr ""

#. type: Plain text
#: man-pages/man2/setns.2:139
msgid ""
"We begin by executing the example program in B<clone>(2)  in the background."
"  That program creates a child in a separate UTS namespace.  The child "
"changes the hostname in its namespace, and then both processes display the "
"hostnames in their UTS namespaces, so that we can see that they are "
"different."
msgstr ""

#. type: Plain text
#: man-pages/man2/setns.2:151
#, no-wrap
msgid ""
"$ B<su>                   # Need privilege for namespace operations\n"
"Password:\n"
"# B<./newuts bizarro &>\n"
"[1] 3549\n"
"clone() returned 3550\n"
"uts.nodename in child:  bizarro\n"
"uts.nodename in parent: antero\n"
"# B<uname -n>             # Verify hostname in the shell\n"
"antero\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/setns.2:158
msgid ""
"We then run the program shown below, using it to execute a shell.  Inside "
"that shell, we verify that the hostname is the one set by the child created "
"by the first program:"
msgstr ""

#. type: Plain text
#: man-pages/man2/setns.2:164
#, no-wrap
msgid ""
"# B<./ns_exec /proc/3550/ns/uts /bin/bash>\n"
"# B<uname -n>             # Executed in shell started by ns_exec\n"
"bizarro\n"
msgstr ""

#. type: SS
#: man-pages/man2/setns.2:166
#, no-wrap
msgid "Program source"
msgstr "Исходный код программы"

#. type: Plain text
#: man-pages/man2/setns.2:174
#, no-wrap
msgid ""
"#define _GNU_SOURCE\n"
"#include E<lt>fcntl.hE<gt>\n"
"#include E<lt>sched.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/setns.2:177
#, no-wrap
msgid ""
"#define errExit(msg)    do { perror(msg); exit(EXIT_FAILURE); \\e\n"
"                        } while (0)\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/setns.2:182
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int fd;\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/setns.2:187
#, no-wrap
msgid ""
"    if (argc E<lt> 3) {\n"
"        fprintf(stderr, \"%s /proc/PID/ns/FILE cmd args...\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/setns.2:191
#, no-wrap
msgid ""
"    fd = open(argv[1], O_RDONLY);   /* Get descriptor for namespace */\n"
"    if (fd == -1)\n"
"        errExit(\"open\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/setns.2:194
#, no-wrap
msgid ""
"    if (setns(fd, 0) == -1)         /* Join that namespace */\n"
"        errExit(\"setns\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/setns.2:198
#, no-wrap
msgid ""
"    execvp(argv[2], &argv[2]);      /* Execute a command in namespace */\n"
"    errExit(\"execvp\");\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/setns.2:204
msgid "B<clone>(2), B<fork>(2), B<vfork>(2), B<proc>(5), B<unix>(7)"
msgstr "B<clone>(2), B<fork>(2), B<vfork>(2), B<proc>(5), B<unix>(7)"

#. type: TH
#: man-pages/man2/stime.2:30
#, no-wrap
msgid "STIME"
msgstr "STIME"

#. type: Plain text
#: man-pages/man2/stime.2:33
msgid "stime - set time"
msgstr "stime - устанавливает системное время"

#. type: Plain text
#: man-pages/man2/stime.2:35
msgid "B<#include E<lt>time.hE<gt>>"
msgstr "B<#include E<lt>time.hE<gt>>"

#. type: Plain text
#: man-pages/man2/stime.2:37
msgid "B<int stime(const time_t *>I<t>B<);>"
msgstr "B<int stime(const time_t *>I<t>B<);>"

#. type: Plain text
#: man-pages/man2/stime.2:45
msgid "B<stime>(): _SVID_SOURCE"
msgstr "B<stime>(): _SVID_SOURCE"

#. type: Plain text
#: man-pages/man2/stime.2:53
msgid ""
"B<stime>()  sets the system's idea of the time and date.  The time, pointed "
"to by I<t>, is measured in seconds since the Epoch, 1970-01-01 00:00:00 "
"+0000 (UTC).  B<stime>()  may be executed only by the superuser."
msgstr "Вызов B<stime>() устанавливает системное (не аппаратное) время и дату машины. Время, заданное в I<t>, измеряется в секундах с начала Эпохи, с 00:00:00 1 января 1970 года (UTC). Функцию B<stime>() может вызывать только суперпользователь."

#. type: Plain text
#: man-pages/man2/stime.2:62
msgid "Error in getting information from user space."
msgstr "Ошибка при получении информации из пространства пользователя."

#. type: Plain text
#: man-pages/man2/stime.2:68
msgid ""
"The calling process has insufficient privilege.  Under Linux, the "
"B<CAP_SYS_TIME> privilege is required."
msgstr ""

#. type: Plain text
#: man-pages/man2/stime.2:70
msgid "SVr4."
msgstr "SVr4."

#. type: Plain text
#: man-pages/man2/stime.2:73
msgid "B<date>(1), B<settimeofday>(2), B<capabilities>(7)"
msgstr "B<date>(1), B<settimeofday>(2), B<capabilities>(7)"

#. type: TH
#: man-pages/man2/syslog.2:33
#, no-wrap
msgid "SYSLOG"
msgstr "SYSLOG"

#. type: Plain text
#: man-pages/man2/syslog.2:37
msgid ""
"syslog, klogctl - read and/or clear kernel message ring buffer; set "
"console_loglevel"
msgstr "syslog, klogctl - читает и/или очищает кольцевой буфер сообщений ядра; устанавливает console_loglevel"

#. type: Plain text
#: man-pages/man2/syslog.2:41
#, no-wrap
msgid ""
"B<int syslog(int >I<type>B<, char *>I<bufp>B<, int >I<len>B<);>\n"
"B</* No wrapper provided in glibc */>\n"
msgstr "B<int syslog(int >I<type>B<, char *>I<bufp>B<, int >I<len>B<);>\nB</* не имеет обёртки в glibc */>\n"

#. type: Plain text
#: man-pages/man2/syslog.2:43
#, no-wrap
msgid "/* The glibc interface */\n"
msgstr "/* интерфейс glibc */\n"

#. type: Plain text
#: man-pages/man2/syslog.2:45
#, no-wrap
msgid "B<#include E<lt>sys/klog.hE<gt>>\n"
msgstr "B<#include E<lt>sys/klog.hE<gt>>\n"

#. type: Plain text
#: man-pages/man2/syslog.2:47
#, no-wrap
msgid "B<int klogctl(int >I<type>B<, char *>I<bufp>B<, int >I<len>B<);>\n"
msgstr "B<int klogctl(int >I<type>B<, char *>I<bufp>B<, int >I<len>B<);>\n"

#. type: Plain text
#: man-pages/man2/syslog.2:57
msgid ""
"I<Note>: Probably, you are looking for the C library function B<syslog>(), "
"which talks to B<syslogd>(8); see B<syslog>(3)  for details."
msgstr ""

#. type: Plain text
#: man-pages/man2/syslog.2:64
msgid ""
"This page describes the kernel B<syslog>()  system call, which is used to "
"control the kernel I<printk>()  buffer; the glibc wrapper function for the "
"system call is called B<klogctl>()."
msgstr ""

#. type: SS
#: man-pages/man2/syslog.2:64
#, no-wrap
msgid "The kernel log buffer"
msgstr "Буфер журнала ядра"

#.  Under "General setup" ==> "Kernel log buffer size"
#.  For 2.6, precisely the option seems to have appeared in 2.5.55.
#. type: Plain text
#: man-pages/man2/syslog.2:81
msgid ""
"The kernel has a cyclic buffer of length B<LOG_BUF_LEN> in which messages "
"given as arguments to the kernel function B<printk>()  are stored "
"(regardless of their log level).  In early kernels, B<LOG_BUF_LEN> had the "
"value 4096; from kernel 1.3.54, it was 8192; from kernel 2.1.113, it was "
"16384; since kernel 2.4.23/2.6, the value is a kernel configuration option "
"(B<CONFIG_LOG_BUF_SHIFT>, default value dependent on the architecture).  "
"Since Linux 2.6.6, the size can be queried with command type 10 (see below)."
msgstr ""

#. type: SS
#: man-pages/man2/syslog.2:81
#, no-wrap
msgid "Commands"
msgstr "Команды"

#. type: Plain text
#: man-pages/man2/syslog.2:88
msgid ""
"The I<type> argument determines the action taken by this function.  The list"
" below specifies the values for I<type>.  The symbolic names are defined in "
"the kernel source, but are not exported to user space; you will either need "
"to use the numbers, or define the names yourself."
msgstr "В аргументе I<type> задаётся действие функции. Далее приводится список со всеми значениями I<type>. Символические имена определены в исходном коде ядра, но не экспортируются в пользовательское пространство; вы должны использовать или номера, или определить имена самостоятельно."

#. type: TP
#: man-pages/man2/syslog.2:88
#, no-wrap
msgid "B<SYSLOG_ACTION_CLOSE> (0)"
msgstr "B<SYSLOG_ACTION_CLOSE> (0)"

#. type: Plain text
#: man-pages/man2/syslog.2:92
msgid "Close the log.  Currently a NOP."
msgstr "Закрыть журнал. Ничего не делает."

#. type: TP
#: man-pages/man2/syslog.2:92
#, no-wrap
msgid "B<SYSLOG_ACTION_OPEN> (1)"
msgstr "B<SYSLOG_ACTION_OPEN> (1)"

#. type: Plain text
#: man-pages/man2/syslog.2:96
msgid "Open the log.  Currently a NOP."
msgstr "Открыть журнал. Ничего не делает."

#. type: TP
#: man-pages/man2/syslog.2:96
#, no-wrap
msgid "B<SYSLOG_ACTION_READ> (2)"
msgstr "B<SYSLOG_ACTION_READ> (2)"

#. type: Plain text
#: man-pages/man2/syslog.2:108
msgid ""
"Read from the log.  The call waits until the kernel log buffer is nonempty, "
"and then reads at most I<len> bytes into the buffer pointed to by I<bufp>.  "
"The call returns the number of bytes read.  Bytes read from the log "
"disappear from the log buffer: the information can be read only once.  This "
"is the function executed by the kernel when a user program reads "
"I</proc/kmsg>."
msgstr "Читать из журнала. Вызов ждёт пока в буфере журнала ядра что-нибудь не появится и затем записывает максимум I<len> байт в буфер, указанный I<bufp>. Вызов возвращает количество прочитанных байт. Байты, прочитанные из журнала, исчезают из буфера журнала: информацию можно прочесть только один раз. Эта функция используется ядром когда пользовательская программа читает файл I</proc/kmsg>."

#. type: TP
#: man-pages/man2/syslog.2:108
#, no-wrap
msgid "B<SYSLOG_ACTION_READ_ALL> (3)"
msgstr "B<SYSLOG_ACTION_READ_ALL> (3)"

#. type: Plain text
#: man-pages/man2/syslog.2:118
msgid ""
"Read all messages remaining in the ring buffer, placing them in the buffer "
"pointed to by I<bufp>.  The call reads the last I<len> bytes from the log "
"buffer (nondestructively), but will not read more than was written into the "
"buffer since the last \"clear ring buffer\" command (see command 5 below))."
"  The call returns the number of bytes read."
msgstr ""

#. type: TP
#: man-pages/man2/syslog.2:118
#, no-wrap
msgid "B<SYSLOG_ACTION_READ_CLEAR> (4)"
msgstr "B<SYSLOG_ACTION_READ_CLEAR> (4)"

#. type: Plain text
#: man-pages/man2/syslog.2:124
msgid ""
"Read and clear all messages remaining in the ring buffer.  The call does "
"precisely the same as for a I<type> of 3, but also executes the \"clear ring"
" buffer\" command."
msgstr "Прочитать и стереть все сообщения, оставшиеся в кольцевом буфере. Вызов выполняет то же самое, что и  при I<type> равном 3, но ещё вызывает команду «очистка кольцевого буфера»."

#. type: TP
#: man-pages/man2/syslog.2:124
#, no-wrap
msgid "B<SYSLOG_ACTION_CLEAR> (5)"
msgstr "B<SYSLOG_ACTION_CLEAR> (5)"

#. type: Plain text
#: man-pages/man2/syslog.2:132
msgid ""
"The call executes just the \"clear ring buffer\" command.  The I<bufp> and "
"I<len> arguments are ignored."
msgstr "Вызов просто исполняет команду «очистка кольцевого буфера». Аргументы I<bufp> и I<len> игнорируются."

#. type: Plain text
#: man-pages/man2/syslog.2:143
msgid ""
"This command does not really clear the ring buffer.  Rather, it sets a "
"kernel bookkeeping variable that determines the results returned by commands"
" 3 (B<SYSLOG_ACTION_READ_ALL>)  and 4 (B<SYSLOG_ACTION_READ_CLEAR>).  This "
"command has no effect on commands 2 (B<SYSLOG_ACTION_READ>)  and 9 "
"(B<SYSLOG_ACTION_SIZE_UNREAD>)."
msgstr "Эта команда на самом деле не очищает кольцевой буфер. Вместо этого она изменяет переменную учёта в ядре, которая определяет результат, возвращаемый командами 3 (B<SYSLOG_ACTION_READ_ALL>)  и 4 (B<SYSLOG_ACTION_READ_CLEAR>). Эта команда не влияет на команды 2 (B<SYSLOG_ACTION_READ>) и 9 (B<SYSLOG_ACTION_SIZE_UNREAD>)."

#. type: TP
#: man-pages/man2/syslog.2:143
#, no-wrap
msgid "B<SYSLOG_ACTION_CONSOLE_OFF> (6)"
msgstr "B<SYSLOG_ACTION_CONSOLE_OFF> (6)"

#.  commit 1aaad49e856ce41adc07d8ae0c8ef35fc4483245
#. type: Plain text
#: man-pages/man2/syslog.2:161
msgid ""
"The command saves the current value of I<console_loglevel> and then sets "
"I<console_loglevel> to I<minimum_console_loglevel>, so that no messages are "
"printed to the console.  Before Linux 2.6.32, the command simply sets "
"I<console_loglevel> to I<minimum_console_loglevel>.  See the discussion of "
"I</proc/sys/kernel/printk>, below."
msgstr ""

#. type: Plain text
#: man-pages/man2/syslog.2:167 man-pages/man2/syslog.2:190
msgid "The I<bufp> and I<len> arguments are ignored."
msgstr ""

#. type: TP
#: man-pages/man2/syslog.2:167
#, no-wrap
msgid "B<SYSLOG_ACTION_CONSOLE_ON> (7)"
msgstr "B<SYSLOG_ACTION_CONSOLE_ON> (7)"

#.  commit 1aaad49e856ce41adc07d8ae0c8ef35fc4483245
#. type: Plain text
#: man-pages/man2/syslog.2:184
msgid ""
"If a previous B<SYSLOG_ACTION_CONSOLE_OFF> command has been performed, this "
"command restores I<console_loglevel> to the value that was saved by that "
"command.  Before Linux 2.6.32, this command simply sets I<console_loglevel> "
"to I<default_console_loglevel>.  See the discussion of "
"I</proc/sys/kernel/printk>, below."
msgstr ""

#. type: TP
#: man-pages/man2/syslog.2:190
#, no-wrap
msgid "B<SYSLOG_ACTION_CONSOLE_LEVEL> (8)"
msgstr "B<SYSLOG_ACTION_CONSOLE_LEVEL> (8)"

#. type: Plain text
#: man-pages/man2/syslog.2:207
msgid ""
"The call sets I<console_loglevel> to the value given in I<len>, which must "
"be an integer between 1 and 8 (inclusive).  The kernel silently enforces a "
"minimum value of I<minimum_console_loglevel> for I<len>.  See the I<log "
"level> section for details.  The I<bufp> argument is ignored."
msgstr ""

#. type: TP
#: man-pages/man2/syslog.2:207
#, no-wrap
msgid "B<SYSLOG_ACTION_SIZE_UNREAD> (9) (since Linux 2.4.10)"
msgstr "B<SYSLOG_ACTION_SIZE_UNREAD> (9) (начиная с Linux 2.4.10)"

#. type: Plain text
#: man-pages/man2/syslog.2:218
msgid ""
"The call returns the number of bytes currently available to be read from the"
" kernel log buffer via command 2 (B<SYSLOG_ACTION_READ>).  The I<bufp> and "
"I<len> arguments are ignored."
msgstr "Вызов возвращает количество байт, доступных для чтения из буфера журнала ядра командой 2 (B<SYSLOG_ACTION_READ>). Аргументы I<bufp> и I<len> игнорируются."

#. type: TP
#: man-pages/man2/syslog.2:218
#, no-wrap
msgid "B<SYSLOG_ACTION_SIZE_BUFFER> (10) (since Linux 2.6.6)"
msgstr "B<SYSLOG_ACTION_SIZE_BUFFER> (10) (начиная с Linux 2.6.6)"

#. type: Plain text
#: man-pages/man2/syslog.2:226
msgid ""
"This command returns the total size of the kernel log buffer.  The I<bufp> "
"and I<len> arguments are ignored."
msgstr "Эта команда возвращает полный размер буфера журнала ядра. Аргументы I<bufp> и I<len> игнорируются."

#. type: Plain text
#: man-pages/man2/syslog.2:245
msgid ""
"All commands except 3 and 10 require privilege.  In Linux kernels before "
"2.6.37, command types 3 and 10 are allowed to unprivileged processes; since "
"Linux 2.6.37, these commands are allowed to unprivileged processes only if "
"I</proc/sys/kernel/dmesg_restrict> has the value 0.  Before Linux 2.6.37, "
"\"privileged\" means that the caller has the B<CAP_SYS_ADMIN> capability.  "
"Since Linux 2.6.37, \"privileged\" means that the caller has either the "
"B<CAP_SYS_ADMIN> capability (now deprecated for this purpose) or the (new)  "
"B<CAP_SYSLOG> capability."
msgstr "Все команды кроме 3 и 10 требуют привилегий. В ядрах Linux до версии 2.6.37, команды 3 и 10 были доступны непривилегированным процессам; начиная с Linux 2.6.37, эти команды разрешены из непривилегированных процессов только, если значение I</proc/sys/kernel/dmesg_restrict> равно 0. До Linux 2.6.37 под «привилегиями» понималось, что вызывающий имеет мандат B<CAP_SYS_ADMIN>. Начиная с Linux 2.6.37 «привилегией» считается, что вызывающий имеет либо мандат B<CAP_SYS_ADMIN> (теперь устарел для такого использования), либо (новый) мандат B<CAP_SYSLOG>."

#. type: SS
#: man-pages/man2/syslog.2:245
#, no-wrap
msgid "/proc/sys/kernel/printk"
msgstr ""

#. type: Plain text
#: man-pages/man2/syslog.2:251
msgid ""
"I</proc/sys/kernel/printk> is a writable file containing four integer values"
" that influence kernel I<printk()> behavior when printing or logging error "
"messages.  The four values are:"
msgstr ""

#. type: TP
#: man-pages/man2/syslog.2:251
#, no-wrap
msgid "I<console_loglevel>"
msgstr ""

#.  since Linux 2.4
#. type: Plain text
#: man-pages/man2/syslog.2:269
msgid ""
"Only messages with a log level lower than this value will be printed to the "
"console.  The default value for this field is B<DEFAULT_CONSOLE_LOGLEVEL> "
"(7), but it is set to 4 if the kernel command line contains the word "
"\"quiet\", 10 if the kernel command line contains the word \"debug\", and to"
" 15 in case of a kernel fault (the 10 and 15 are just silly, and equivalent "
"to 8).  The value of I<console_loglevel> can be set (to a value in the range"
" 1-8) by a B<syslog>()  call with a I<type> of 8."
msgstr ""

#. type: TP
#: man-pages/man2/syslog.2:269
#, no-wrap
msgid "I<default_message_loglevel>"
msgstr ""

#.  commit 5af5bcb8d37f99ba415a1adc6da71051b84f93a5
#. type: Plain text
#: man-pages/man2/syslog.2:282
msgid ""
"This value will be used as the log level for I<printk()> messages that do "
"not have an explicit level.  Up to and including Linux 2.6.38, the hard-"
"coded default value for this field was 4 (B<KERN_WARNING>); since Linux "
"2.6.39, the default value is a defined by the kernel configuration option "
"B<CONFIG_DEFAULT_MESSAGE_LOGLEVEL>, which defaults to 4."
msgstr ""

#. type: TP
#: man-pages/man2/syslog.2:282
#, no-wrap
msgid "I<minimum_console_loglevel>"
msgstr ""

#. type: Plain text
#: man-pages/man2/syslog.2:287
msgid ""
"The value in this field is the minimum value to which I<console_loglevel> "
"can be set."
msgstr ""

#. type: TP
#: man-pages/man2/syslog.2:287
#, no-wrap
msgid "I<default_console_loglevel>"
msgstr ""

#. type: Plain text
#: man-pages/man2/syslog.2:293
msgid "This is the default value for I<console_loglevel>."
msgstr ""

#. type: SS
#: man-pages/man2/syslog.2:293
#, no-wrap
msgid "The log level"
msgstr ""

#. type: Plain text
#: man-pages/man2/syslog.2:301
msgid ""
"Every I<printk>()  message has its own log level.  If the log level is not "
"explicitly specified as part of the message, it defaults to "
"I<default_message_loglevel>.  The conventional meaning of the log level is "
"as follows:"
msgstr ""

#. type: tbl table
#: man-pages/man2/syslog.2:305
#, no-wrap
msgid "Kernel constant\tLevel value\tMeaning\n"
msgstr ""

#. type: tbl table
#: man-pages/man2/syslog.2:306
#, no-wrap
msgid "KERN_EMERG\t0\tSystem is unusable\n"
msgstr ""

#. type: tbl table
#: man-pages/man2/syslog.2:307
#, no-wrap
msgid "KERN_ALERT\t1\tAction must be taken immediately\n"
msgstr ""

#. type: tbl table
#: man-pages/man2/syslog.2:308
#, no-wrap
msgid "KERN_CRIT\t2\tCritical conditions\n"
msgstr ""

#. type: tbl table
#: man-pages/man2/syslog.2:309
#, no-wrap
msgid "KERN_ERR\t3\tError conditions\n"
msgstr ""

#. type: tbl table
#: man-pages/man2/syslog.2:310
#, no-wrap
msgid "KERN_WARNING\t4\tWarning conditions\n"
msgstr ""

#. type: tbl table
#: man-pages/man2/syslog.2:311
#, no-wrap
msgid "KERN_NOTICE\t5\tNormal but significant condition\n"
msgstr ""

#. type: tbl table
#: man-pages/man2/syslog.2:312
#, no-wrap
msgid "KERN_INFO\t6\tInformational\n"
msgstr ""

#. type: tbl table
#: man-pages/man2/syslog.2:313
#, no-wrap
msgid "KERN_DEBUG\t7\tDebug-level messages\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/syslog.2:321
msgid ""
"The kernel I<printk()> routine will print a message on the console only if "
"it has a log level less than the value of I<console_loglevel>."
msgstr ""

#. type: Plain text
#: man-pages/man2/syslog.2:334
msgid ""
"For I<type> equal to 2, 3, or 4, a successful call to B<syslog>()  returns "
"the number of bytes read.  For I<type> 9, B<syslog>()  returns the number of"
" bytes currently available to be read on the kernel log buffer.  For I<type>"
" 10, B<syslog>()  returns the total size of the kernel log buffer.  For "
"other values of I<type>, 0 is returned on success."
msgstr "При успешном выполнении и если I<type> равно 2, 3 или 4, B<syslog>() возвращает количество прочитанных байт. При I<type> равном 9, B<syslog>() возвращает количество байт, доступных для чтения из кольцевого буфера ядра. При I<type> равном 10, B<syslog>() возвращает полный размер кольцевого буфера ядра. При других значениях I<type> и успешном выполнении возвращается 0."

#. type: Plain text
#: man-pages/man2/syslog.2:337
msgid ""
"In case of error, -1 is returned, and I<errno> is set to indicate the error."
msgstr "При ошибке возвращается -1, а переменной I<errno> присваивается номер ошибки."

#. type: Plain text
#: man-pages/man2/syslog.2:355
msgid ""
"Bad arguments (e.g., bad I<type>; or for I<type> 2, 3, or 4, I<buf> is NULL,"
" or I<len> is less than zero; or for I<type> 8, the I<level> is outside the "
"range 1 to 8)."
msgstr "Неправильные значения параметров (например, некорректное значение I<type>; при I<type> равном 2, 3,  4, значение I<buf> равно NULL или значение I<len> меньше нуля; при I<type> равном 8, значение I<level> лежит вне диапазона от 1 до 8)."

#. type: Plain text
#: man-pages/man2/syslog.2:362
msgid ""
"This B<syslog>()  system call is not available, because the kernel was "
"compiled with the B<CONFIG_PRINTK> kernel-configuration option disabled."
msgstr "Системный вызов B<syslog>() недоступен, так как ядро было собрано с отключённым параметром B<CONFIG_PRINTK>."

#. type: Plain text
#: man-pages/man2/syslog.2:373
msgid ""
"An attempt was made to change I<console_loglevel> or clear the kernel "
"message ring buffer by a process without sufficient privilege (more "
"precisely: without the B<CAP_SYS_ADMIN> or B<CAP_SYSLOG> capability)."
msgstr ""

#. type: TP
#: man-pages/man2/syslog.2:373
#, no-wrap
msgid "B<ERESTARTSYS>"
msgstr "B<ERESTARTSYS>"

#. type: Plain text
#: man-pages/man2/syslog.2:377
msgid ""
"System call was interrupted by a signal; nothing was read.  (This can be "
"seen only during a trace.)"
msgstr "Системный вызов был прерван сигналом; ничего не было прочитано (может быть замечено только при трассировке)."

#. type: Plain text
#: man-pages/man2/syslog.2:380
msgid ""
"This system call is Linux-specific and should not be used in programs "
"intended to be portable."
msgstr "Данный системный вызов существует только в Linux и не должен использоваться переносимых программах."

#.  In libc4 and libc5 the number of this call was defined by
#.  .BR SYS_klog .
#.  In glibc 2.0 the syscall is baptized
#.  .BR klogctl ().
#. type: Plain text
#: man-pages/man2/syslog.2:388
msgid ""
"From the very start, people noted that it is unfortunate that a system call "
"and a library routine of the same name are entirely different animals."
msgstr ""

#. type: Plain text
#: man-pages/man2/syslog.2:390
msgid "B<syslog>(3), B<capabilities>(7)"
msgstr "B<syslog>(3), B<capabilities>(7)"

#. type: TH
#: man-pages/man2/select_tut.2:32
#, no-wrap
msgid "SELECT_TUT"
msgstr "SELECT_TUT"

#. type: TH
#: man-pages/man2/select_tut.2:32
#, no-wrap
msgid "2013-12-30"
msgstr "2013-12-30"

#. type: Plain text
#: man-pages/man2/select_tut.2:36
msgid ""
"select, pselect, FD_CLR, FD_ISSET, FD_SET, FD_ZERO - synchronous I/O "
"multiplexing"
msgstr "select, pselect, FD_CLR, FD_ISSET, FD_SET, FD_ZERO - многопоточный синхронный ввод-вывод"

#. type: Plain text
#: man-pages/man2/select_tut.2:39
#, no-wrap
msgid "/* According to POSIX.1-2001 */\n"
msgstr "/* В соответствие с POSIX.1-2001 */\n"

#. type: Plain text
#: man-pages/man2/select_tut.2:41 man-pages/man2/select_tut.2:62
#, no-wrap
msgid "B<#include E<lt>sys/select.hE<gt>>\n"
msgstr "B<#include E<lt>sys/select.hE<gt>>\n"

#. type: Plain text
#: man-pages/man2/select_tut.2:43
#, no-wrap
msgid "/* According to earlier standards */\n"
msgstr "/* В соответствие с более ранними стандартами */\n"

#. type: Plain text
#: man-pages/man2/select_tut.2:45
#, no-wrap
msgid "B<#include E<lt>sys/time.hE<gt>>\n"
msgstr "B<#include E<lt>sys/time.hE<gt>>\n"

#. type: Plain text
#: man-pages/man2/select_tut.2:52
#, no-wrap
msgid ""
"B<int select(int >I<nfds>B<, fd_set *>I<readfds>B<, fd_set *>I<writefds>B<,>\n"
"B<           fd_set *>I<exceptfds>B<, struct timeval *>I<utimeout>B<);>\n"
msgstr "B<int select(int >I<nfds>B<, fd_set *>I<readfds>B<, fd_set *>I<writefds>B<,>\nB<           fd_set *>I<exceptfds>B<, struct timeval *>I<utimeout>B<);>\n"

#. type: Plain text
#: man-pages/man2/select_tut.2:54
#, no-wrap
msgid "B<void FD_CLR(int >I<fd>B<, fd_set *>I<set>B<);>\n"
msgstr "B<void FD_CLR(int >I<fd>B<, fd_set *>I<set>B<);>\n"

#. type: Plain text
#: man-pages/man2/select_tut.2:56
#, no-wrap
msgid "B<int  FD_ISSET(int >I<fd>B<, fd_set *>I<set>B<);>\n"
msgstr "B<int  FD_ISSET(int >I<fd>B<, fd_set *>I<set>B<);>\n"

#. type: Plain text
#: man-pages/man2/select_tut.2:58
#, no-wrap
msgid "B<void FD_SET(int >I<fd>B<, fd_set *>I<set>B<);>\n"
msgstr "B<void FD_SET(int >I<fd>B<, fd_set *>I<set>B<);>\n"

#. type: Plain text
#: man-pages/man2/select_tut.2:60
#, no-wrap
msgid "B<void FD_ZERO(fd_set *>I<set>B<);>\n"
msgstr "B<void FD_ZERO(fd_set *>I<set>B<);>\n"

#. type: Plain text
#: man-pages/man2/select_tut.2:66
#, no-wrap
msgid ""
"B<int pselect(int >I<nfds>B<, fd_set *>I<readfds>B<, fd_set *>I<writefds>B<,>\n"
"B<            fd_set *>I<exceptfds>B<, const struct timespec *>I<ntimeout>B<,>\n"
"B<            const sigset_t *>I<sigmask>B<);>\n"
msgstr "B<int pselect(int >I<nfds>B<, fd_set *>I<readfds>B<, fd_set *>I<writefds>B<,>\nB<            fd_set *>I<exceptfds>B<, const struct timespec *>I<ntimeout>B<,>\nB<            const sigset_t *>I<sigmask>B<);>\n"

#. type: Plain text
#: man-pages/man2/select_tut.2:75
msgid ""
"B<pselect>(): _POSIX_C_SOURCE\\ E<gt>=\\ 200112L || _XOPEN_SOURCE\\ E<gt>=\\"
" 600"
msgstr "B<pselect>(): _POSIX_C_SOURCE\\ E<gt>=\\ 200112L || _XOPEN_SOURCE\\ E<gt>=\\ 600"

#. type: Plain text
#: man-pages/man2/select_tut.2:83
msgid ""
"B<select>()  (or B<pselect>())  is used to efficiently monitor multiple file"
" descriptors, to see if any of them is, or becomes, \"ready\"; that is, to "
"see whether I/O becomes possible, or an \"exceptional condition\" has "
"occurred on any of the descriptors."
msgstr "Вызов B<select>() (или B<pselect>()) используется для эффективного слежения за несколькими файловыми дескрипторами — для ожидания, когда какой-то из них не станет «готов», то есть появится возможность чтения-записи данных, или с дескриптором не возникнет «исключительная ситуация»."

#. type: Plain text
#: man-pages/man2/select_tut.2:108
msgid ""
"Its principal arguments are three \"sets\" of file descriptors: I<readfds>, "
"I<writefds>, and I<exceptfds>.  Each set is declared as type I<fd_set>, and "
"its contents can be manipulated with the macros B<FD_CLR>(), B<FD_ISSET>(), "
"B<FD_SET>(), and B<FD_ZERO>().  A newly declared set should first be cleared"
" using B<FD_ZERO>().  B<select>()  modifies the contents of the sets "
"according to the rules described below; after calling B<select>()  you can "
"test if a file descriptor is still present in a set with the B<FD_ISSET>()  "
"macro.  B<FD_ISSET>()  returns nonzero if a specified file descriptor is "
"present in a set and zero if it is not.  B<FD_CLR>()  removes a file "
"descriptor from a set."
msgstr "Основные параметры задаются в виде «набора» файловых дескрипторов: I<readfds>, I<writefds> и I<exceptfds>. Каждый набор имеет тип I<fd_set> и его содержимое можно изменять с помощью макросов B<FD_CLR>(), B<FD_ISSET>(), B<FD_SET>() и B<FD_ZERO>(). При создании нового набора сначала его нужно очистить с помощью B<FD_ZERO>(). Вызов B<select>() изменяет содержимое наборов в соответствии с правилами, описанными далее; после вызова B<select>() вы можете проверить существует ли ещё файловый дескриптор в наборе с помощью макроса B<FD_ISSET>(). Макрос B<FD_ISSET>() возвращает ненулевое значение, если указанный файловый дескриптор присутствует в наборе и ноль, если отсутствует. Макрос B<FD_CLR>() удаляет файловый дескриптор из набора."

#. type: SS
#: man-pages/man2/select_tut.2:108
#, no-wrap
msgid "Arguments"
msgstr "Аргументы"

#. type: TP
#: man-pages/man2/select_tut.2:109
#, no-wrap
msgid "I<readfds>"
msgstr "I<readfds>"

#. type: Plain text
#: man-pages/man2/select_tut.2:118
msgid ""
"This set is watched to see if data is available for reading from any of its "
"file descriptors.  After B<select>()  has returned, I<readfds> will be "
"cleared of all file descriptors except for those that are immediately "
"available for reading."
msgstr "Этот набор служит для слежения за появлением данных, доступных для чтения из любого файлового дескриптора. После возврата из B<select>() в I<readfds> остаются только те дескрипторы файлов, из которых возможно немедленное чтение."

#. type: TP
#: man-pages/man2/select_tut.2:118
#, no-wrap
msgid "I<writefds>"
msgstr "I<writefds>"

#. type: Plain text
#: man-pages/man2/select_tut.2:127
msgid ""
"This set is watched to see if there is space to write data to any of its "
"file descriptors.  After B<select>()  has returned, I<writefds> will be "
"cleared of all file descriptors except for those that are immediately "
"available for writing."
msgstr "Этот набор служит для слежения за появлением места для записи данных в любой из файловых дескрипторов набора. После возврата из B<select>() в I<writefds> остаются только те файловые дескрипторы, в которые возможна немедленная запись."

#. type: TP
#: man-pages/man2/select_tut.2:127
#, no-wrap
msgid "I<exceptfds>"
msgstr "I<exceptfds>"

#. type: Plain text
#: man-pages/man2/select_tut.2:149
msgid ""
"This set is watched for \"exceptional conditions\".  In practice, only one "
"such exceptional condition is common: the availability of I<out-of-band> "
"(OOB) data for reading from a TCP socket.  See B<recv>(2), B<send>(2), and "
"B<tcp>(7)  for more details about OOB data.  (One other less common case "
"where B<select>(2)  indicates an exceptional condition occurs with "
"pseudoterminals in packet mode; see B<tty_ioctl>(4).)  After B<select>()  "
"has returned, I<exceptfds> will be cleared of all file descriptors except "
"for those for which an exceptional condition has occurred."
msgstr "Этот набор служит для слежения за «исключительными ситуациями». На самом деле, отслеживается только одна распространённая исключительная ситуация: доступность I<внепоточных> (out-of-band — OOB) данных для чтения из сокета TCP. Более подробно о данных OOB смотрите в B<recv>(2), B<send>(2) и B<tcp>(7). Другая менее распространённая ситуация: B<select>(2) указывает на исключительную ситуацию с псевдотерминалом в пакетном режиме; см. B<tty_ioctl>(4). После возврата из B<select>() в I<exceptfds> остаются только те файловые дескрипторы, в которых произошла исключительная ситуация."

#. type: TP
#: man-pages/man2/select_tut.2:149
#, no-wrap
msgid "I<nfds>"
msgstr "I<nfds>"

#. type: Plain text
#: man-pages/man2/select_tut.2:156
msgid ""
"This is an integer one more than the maximum of any file descriptor in any "
"of the sets.  In other words, while adding file descriptors to each of the "
"sets, you must calculate the maximum integer value of all of them, then "
"increment this value by one, and then pass this as I<nfds>."
msgstr "Представляет собой целое число, на единицу большее максимального файлового дескриптора в любом из наборов. Другими словами, при добавлении файловых дескрипторов в наборы вам необходимо вычислять максимальное целое значение любого из них, а затем увеличивать это значение на единицу и передавать в I<nfds>."

#. type: TP
#: man-pages/man2/select_tut.2:156
#, no-wrap
msgid "I<utimeout>"
msgstr "I<utimeout>"

#. type: Plain text
#: man-pages/man2/select_tut.2:169
msgid ""
"This is the longest time B<select>()  may wait before returning, even if "
"nothing interesting happened.  If this value is passed as NULL, then "
"B<select>()  blocks indefinitely waiting for a file descriptor to become "
"ready.  I<utimeout> can be set to zero seconds, which causes B<select>()  to"
" return immediately, with information about the readiness of file "
"descriptors at the time of the call.  The structure I<struct timeval> is "
"defined as:"
msgstr "Этот аргумент задаёт наибольшее время, которое вызов B<select>() будет ожидать событий, по прошествии которого завершит работу, даже если ничего не произойдёт. Если значение этого аргумента равно NULL, то B<select>() будет ожидать бесконечно. Значение I<utimeout> может быть установлено в ноль секунд; в этом случае B<select>() возвратит управление немедленно, с информацией о готовности файловых дескрипторов на момент вызова. Структура I<struct timeval> определена следующим образом:"

#. type: Plain text
#: man-pages/man2/select_tut.2:176
#, no-wrap
msgid ""
"struct timeval {\n"
"    time_t tv_sec;    /* seconds */\n"
"    long tv_usec;     /* microseconds */\n"
"};\n"
msgstr "struct timeval {\n    time_t tv_sec;    /* секунды */\n    long tv_usec;     /* микросекунды */\n};\n"

#. type: TP
#: man-pages/man2/select_tut.2:178
#, no-wrap
msgid "I<ntimeout>"
msgstr "I<ntimeout>"

#. type: Plain text
#: man-pages/man2/select_tut.2:187
msgid ""
"This argument for B<pselect>()  has the same meaning as I<utimeout>, but "
"I<struct timespec> has nanosecond precision as follows:"
msgstr "Этот аргумент B<pselect>() имеет то же значение, что и I<utimeout>, но структура I<struct timespec> позволяет указывать время с точностью до наносекунд:"

#. type: Plain text
#: man-pages/man2/select_tut.2:194
#, no-wrap
msgid ""
"struct timespec {\n"
"    long tv_sec;    /* seconds */\n"
"    long tv_nsec;   /* nanoseconds */\n"
"};\n"
msgstr "struct timespec {\n    long tv_sec;    /* секунды */\n    long tv_nsec;   /* наносекунды */\n};\n"

#. type: TP
#: man-pages/man2/select_tut.2:196
#, no-wrap
msgid "I<sigmask>"
msgstr "I<sigmask>"

#. type: Plain text
#: man-pages/man2/select_tut.2:213
msgid ""
"This argument holds a set of signals that the kernel should unblock (i.e., "
"remove from the signal mask of the calling thread), while the caller is "
"blocked inside the B<pselect>()  call (see B<sigaddset>(3)  and "
"B<sigprocmask>(2)).  It may be NULL, in which case the call does not modify "
"the signal mask on entry and exit to the function.  In this case, "
"B<pselect>()  will then behave just like B<select>()."
msgstr "Этот аргумент содержит набор сигналов, которые ядро должно разблокировать (то есть удалить из маски сигналов вызывающей нити) на время, пока вызывающий заблокирован в вызове B<pselect>() (см. B<sigaddset>(3) и B<sigprocmask>(2)). В качестве аргумента может быть передано значение NULL — вызов не изменяет маску сигналов при входе и выходе из функции. То есть B<pselect>() ведёт себя как B<select>()."

#. type: SS
#: man-pages/man2/select_tut.2:213
#, no-wrap
msgid "Combining signal and data events"
msgstr "Комбинирование событий сигналов и данных"

#. type: Plain text
#: man-pages/man2/select_tut.2:257
msgid ""
"B<pselect>()  is useful if you are waiting for a signal as well as for file "
"descriptor(s) to become ready for I/O.  Programs that receive signals "
"normally use the signal handler only to raise a global flag.  The global "
"flag will indicate that the event must be processed in the main loop of the "
"program.  A signal will cause the B<select>()  (or B<pselect>())  call to "
"return with I<errno> set to B<EINTR>.  This behavior is essential so that "
"signals can be processed in the main loop of the program, otherwise "
"B<select>()  would block indefinitely.  Now, somewhere in the main loop will"
" be a conditional to check the global flag.  So we must ask: what if a "
"signal arrives after the conditional, but before the B<select>()  call? The "
"answer is that B<select>()  would block indefinitely, even though an event "
"is actually pending.  This race condition is solved by the B<pselect>()  "
"call.  This call can be used to set the signal mask to a set of signals that"
" are only to be received within the B<pselect>()  call.  For instance, let "
"us say that the event in question was the exit of a child process.  Before "
"the start of the main loop, we would block B<SIGCHLD> using "
"B<sigprocmask>(2).  Our B<pselect>()  call would enable B<SIGCHLD> by using "
"an empty signal mask.  Our program would look like:"
msgstr "Вызов B<pselect>() полезен как для ожидания сигнала, так и для ожидания готовности файлового дескриптора для ввода-вывода. Программы, принимающие сигналы, как правило, лишь выставляют в обработчике сигнала глобальный флаг, который означает, что требуется обработка события в главном цикле программы. Появление сигнала заставит вызов B<select>() (или B<pselect>()) вернуть управление вызвавшей программе; при этом I<errno> будет присвоено B<EINTR>. Это поведение продиктовано необходимостью обработки сигналов в главном цикле программы во избежание бесконечной блокировки B<select>(). В главном цикле программы должно быть условие, проверяющее глобальный флаг. Возникает вопрос: а что если сигнал придёт после проверки этого условия, но до вызова B<select>()? В этом случае программа навсегда останется в B<select>(), хотя и есть ожидающее событие. Для разрешения этой проблемы существует вызов B<pselect>(). Например, предположим что интересующее нас событие — это завершение дочернего процесса. Перед запуском главного цикла заблокируем B<SIGCHLD> с помощью B<sigprocmask>(2). Наш вызов B<pselect>() разблокирует B<SIGCHLD> указав пустую маску сигналов. Программа будет выглядеть так:"

#. type: Plain text
#: man-pages/man2/select_tut.2:260
#, no-wrap
msgid "static volatile sig_atomic_t got_SIGCHLD = 0;\n"
msgstr "static volatile sig_atomic_t got_SIGCHLD = 0;\n"

#. type: Plain text
#: man-pages/man2/select_tut.2:266
#, no-wrap
msgid ""
"static void\n"
"child_sig_handler(int sig)\n"
"{\n"
"    got_SIGCHLD = 1;\n"
"}\n"
msgstr "static void\nchild_sig_handler(int sig)\n{\n    got_SIGCHLD = 1;\n}\n"

#. type: Plain text
#: man-pages/man2/select_tut.2:274
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    sigset_t sigmask, empty_mask;\n"
"    struct sigaction sa;\n"
"    fd_set readfds, writefds, exceptfds;\n"
"    int r;\n"
msgstr "int\nmain(int argc, char *argv[])\n{\n    sigset_t sigmask, empty_mask;\n    struct sigaction sa;\n    fd_set readfds, writefds, exceptfds;\n    int r;\n"

#. type: Plain text
#: man-pages/man2/select_tut.2:281
#, no-wrap
msgid ""
"    sigemptyset(&sigmask);\n"
"    sigaddset(&sigmask, SIGCHLD);\n"
"    if (sigprocmask(SIG_BLOCK, &sigmask, NULL) == -1) {\n"
"        perror(\"sigprocmask\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr "    sigemptyset(&sigmask);\n    sigaddset(&sigmask, SIGCHLD);\n    if (sigprocmask(SIG_BLOCK, &sigmask, NULL) == -1) {\n        perror(\"sigprocmask\");\n        exit(EXIT_FAILURE);\n    }\n"

#. type: Plain text
#: man-pages/man2/select_tut.2:289
#, no-wrap
msgid ""
"    sa.sa_flags = 0;\n"
"    sa.sa_handler = child_sig_handler;\n"
"    sigemptyset(&sa.sa_mask);\n"
"    if (sigaction(SIGCHLD, &sa, NULL) == -1) {\n"
"        perror(\"sigaction\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr "    sa.sa_flags = 0;\n    sa.sa_handler = child_sig_handler;\n    sigemptyset(&sa.sa_mask);\n    if (sigaction(SIGCHLD, &sa, NULL) == -1) {\n        perror(\"sigaction\");\n        exit(EXIT_FAILURE);\n    }\n"

#. type: Plain text
#: man-pages/man2/select_tut.2:291
#, no-wrap
msgid "    sigemptyset(&empty_mask);\n"
msgstr "    sigemptyset(&empty_mask);\n"

#. type: Plain text
#: man-pages/man2/select_tut.2:295
#, no-wrap
msgid ""
"    for (;;) {          /* main loop */\n"
"        /* Initialize readfds, writefds, and exceptfds\n"
"           before the pselect() call. (Code omitted.) */\n"
msgstr "    for (;;) {          /* главный цикл */\n        /* Инициализация readfds, writefds и exceptfds\n           до вызова pselect() (код не показан). */\n"

#. type: Plain text
#: man-pages/man2/select_tut.2:301
#, no-wrap
msgid ""
"        r = pselect(nfds, &readfds, &writefds, &exceptfds,\n"
"                    NULL, &empty_mask);\n"
"        if (r == -1 && errno != EINTR) {\n"
"            /* Handle error */\n"
"        }\n"
msgstr "        r = pselect(nfds, &readfds, &writefds, &exceptfds,\n                    NULL, &empty_mask);\n        if (r == -1 && errno != EINTR) {\n            /* обработка ошибки */\n        }\n"

#. type: Plain text
#: man-pages/man2/select_tut.2:304
#, no-wrap
msgid ""
"        if (got_SIGCHLD) {\n"
"            got_SIGCHLD = 0;\n"
msgstr "        if (got_SIGCHLD) {\n            got_SIGCHLD = 0;\n"

#. type: Plain text
#: man-pages/man2/select_tut.2:308
#, no-wrap
msgid ""
"            /* Handle signalled event here; e.g., wait() for all\n"
"               terminated children. (Code omitted.) */\n"
"        }\n"
msgstr "            /* Здесь обработка сигнального события; например с\n               помощью wait() для завершения потомком (код не показан). */\n        }\n"

#. type: Plain text
#: man-pages/man2/select_tut.2:312
#, no-wrap
msgid ""
"        /* main body of program */\n"
"    }\n"
"}\n"
msgstr "        /* код основной программы */\n    }\n}\n"

#. type: SS
#: man-pages/man2/select_tut.2:313
#, no-wrap
msgid "Practical"
msgstr "Практика"

#. type: Plain text
#: man-pages/man2/select_tut.2:334
msgid ""
"So what is the point of B<select>()? Can't I just read and write to my "
"descriptors whenever I want? The point of B<select>()  is that it watches "
"multiple descriptors at the same time and properly puts the process to sleep"
" if there is no activity.  UNIX programmers often find themselves in a "
"position where they have to handle I/O from more than one file descriptor "
"where the data flow may be intermittent.  If you were to merely create a "
"sequence of B<read>(2)  and B<write>(2)  calls, you would find that one of "
"your calls may block waiting for data from/to a file descriptor, while "
"another file descriptor is unused though ready for I/O.  B<select>()  "
"efficiently copes with this situation."
msgstr "Итак, какой прок от использования B<select>()? Разве нельзя просто считывать и записывать данные в файловые дескрипторы когда этого захочется? Смысл использования B<select>() в том, что он позволяет следит за несколькими дескрипторами одновременно и корректно переводить процесс в режим ожидания, когда активности не наблюдается. Программисты UNIX часто попадают в ситуацию, когда необходимо обработать ввод-вывод из более чем одного файлового дескриптора в то время как поток данных может быть неравномерным. Если вы просто создадите последовательность вызовов B<read>(2) и B<write>(2), то можете попасть в ситуацию, когда один из вызовов будет ожидать данные из/в файлового дескриптора, в то время как другой будет простаивать, хотя данные для него уже появились. Вызов B<select>() позволяет эффективно справиться с такой ситуацией."

#. type: SS
#: man-pages/man2/select_tut.2:334
#, no-wrap
msgid "Select law"
msgstr "Правила использования"

#. type: Plain text
#: man-pages/man2/select_tut.2:347
msgid ""
"Many people who try to use B<select>()  come across behavior that is "
"difficult to understand and produces nonportable or borderline results.  For"
" instance, the above program is carefully written not to block at any point,"
" even though it does not set its file descriptors to nonblocking mode.  It "
"is easy to introduce subtle errors that will remove the advantage of using "
"B<select>(), so here is a list of essentials to watch for when using "
"B<select>()."
msgstr "Многие из тех, кто пытался использовать B<select>(), сталкивались с поведением, которое трудно понять, и которое приводило к непереносимым или просто плохим результатам. Например, вышеприведенная программа тщательно спланирована так, чтобы ни в каком случае не блокироваться, хотя для её файловых дескрипторов не установлен неблокирующий режим. Несложно перечислить не очевидные ошибки, которые лишат всех преимуществ использования B<select>(), поэтому вот список основных моментов, на которые нужно обращать внимание при использовании B<select>()."

#. type: Plain text
#: man-pages/man2/select_tut.2:356
msgid ""
"You should always try to use B<select>()  without a timeout.  Your program "
"should have nothing to do if there is no data available.  Code that depends "
"on timeouts is not usually portable and is difficult to debug."
msgstr "Всегда старайтесь использовать B<select>() без указания времени ожидания. Ваша программа не должна ничего делать, если нет данных. Код, зависимый от времени ожидания, обычно плохо переносим и сложен для отладки."

#. type: Plain text
#: man-pages/man2/select_tut.2:360
msgid ""
"The value I<nfds> must be properly calculated for efficiency as explained "
"above."
msgstr "Для повышения эффективности значение I<nfds> должно правильно вычисляться, как это объяснялось выше."

#. type: Plain text
#: man-pages/man2/select_tut.2:367
msgid ""
"No file descriptor must be added to any set if you do not intend to check "
"its result after the B<select>()  call, and respond appropriately.  See next"
" rule."
msgstr "Файловые дескрипторы не должны добавляться в наборы, если вы не планируете после вызова B<select>() проверять результат и соответствующим образом реагировать. Смотрите следующее правило."

#. type: Plain text
#: man-pages/man2/select_tut.2:373
msgid ""
"After B<select>()  returns, all file descriptors in all sets should be "
"checked to see if they are ready."
msgstr "После возврата из B<select>() должны быть проверены все файловые дескрипторы во всех наборах."

#. type: Plain text
#: man-pages/man2/select_tut.2:388
msgid ""
"The functions B<read>(2), B<recv>(2), B<write>(2), and B<send>(2)  do I<not>"
" necessarily read/write the full amount of data that you have requested.  If"
" they do read/write the full amount, it's because you have a low traffic "
"load and a fast stream.  This is not always going to be the case.  You "
"should cope with the case of your functions managing to send or receive only"
" a single byte."
msgstr "Вызовы B<read>(2), B<recv>(2), B<write>(2) и B<send>(2) I<не> обязательно считывают/записывают данные в полном объёме. Такое, конечно, возможно при низком трафике или быстром потоке, однако происходит далеко не всегда. Вы должны рассчитывать, что ваши функции получают/отправляют только один байт за раз."

#. type: TP
#: man-pages/man2/select_tut.2:388
#, no-wrap
msgid "6."
msgstr "6."

#. type: Plain text
#: man-pages/man2/select_tut.2:396
msgid ""
"Never read/write only in single bytes at a time unless you are really sure "
"that you have a small amount of data to process.  It is extremely "
"inefficient not to read/write as much data as you can buffer each time.  The"
" buffers in the example below are 1024 bytes although they could easily be "
"made larger."
msgstr "Никогда не считывайте/записывайте побайтно, если только вы не абсолютно уверены в том, что нужно обработать небольшой объём данных. Крайне неэффективно считывать/записывать меньшее количество байт, чем вы можете поместить в буфер за один раз. Буферы в вышеприведённом примере имеют размер 1024 байта, однако могут быть легко увеличены до максимального размера пакета в вашей локальной сети."

#. type: TP
#: man-pages/man2/select_tut.2:396
#, no-wrap
msgid "7."
msgstr "7."

#.  Nonetheless, you should still cope with these errors for completeness.
#. type: Plain text
#: man-pages/man2/select_tut.2:418
msgid ""
"The functions B<read>(2), B<recv>(2), B<write>(2), and B<send>(2)  as well "
"as the B<select>()  call can return -1 with I<errno> set to B<EINTR>, or "
"with I<errno> set to B<EAGAIN> (B<EWOULDBLOCK>).  These results must be "
"properly managed (not done properly above).  If your program is not going to"
" receive any signals, then it is unlikely you will get B<EINTR>.  If your "
"program does not set nonblocking I/O, you will not get B<EAGAIN>."
msgstr "Вызовы B<read>(2), B<recv>(2), B<write>(2) и B<send>(2) также как и B<select>() могут возвратить -1 с I<errno> равным B<EINTR>, или I<errno> равным B<EAGAIN> (B<EWOULDBLOCK>). Такие ситуации должны быть правильно обработаны (в вышеприведенной программе этого не сделано). Если ваша программа не собирается принимать сигналы, то маловероятно, что вы получите B<EINTR>. Если ваша программа не использует неблокирующий ввод-вывод, то вы не получите B<EAGAIN>."

#. type: TP
#: man-pages/man2/select_tut.2:418
#, no-wrap
msgid "8."
msgstr "8."

#. type: Plain text
#: man-pages/man2/select_tut.2:427
msgid ""
"Never call B<read>(2), B<recv>(2), B<write>(2), or B<send>(2)  with a buffer"
" length of zero."
msgstr "Никогда не вызывайте B<read>(2), B<recv>(2), B<write>(2) или B<send>(2) с буфером нулевой длины."

#. type: TP
#: man-pages/man2/select_tut.2:427
#, no-wrap
msgid "9."
msgstr "9."

#. type: Plain text
#: man-pages/man2/select_tut.2:443
msgid ""
"If the functions B<read>(2), B<recv>(2), B<write>(2), and B<send>(2)  fail "
"with errors other than those listed in B<7.>, or one of the input functions "
"returns 0, indicating end of file, then you should I<not> pass that "
"descriptor to B<select>()  again.  In the example below, I close the "
"descriptor immediately, and then set it to -1 to prevent it being included "
"in a set."
msgstr "Если вызовы B<read>(2), B<recv>(2), B<write>(2) и B<send>(2) завершаются с ошибками, отличными от перечисленных в пункте B<7.> или один из вызовов ввода вернул 0, что указывает на конец файла, то вы I<не> должны передавать этот дескриптор в B<select>() снова. В примере выше я немедленно закрываю дескриптор и устанавливаю его в -1 для предотвращения его включения в набор."

#. type: TP
#: man-pages/man2/select_tut.2:443
#, no-wrap
msgid "10."
msgstr "10."

#. type: Plain text
#: man-pages/man2/select_tut.2:450
msgid ""
"The timeout value must be initialized with each new call to B<select>(), "
"since some operating systems modify the structure.  B<pselect>()  however "
"does not modify its timeout structure."
msgstr "Значение времени ожидания должно быть инициализировано при каждом новом вызове B<select>(), так как некоторые операционные системы изменяют значение структуры. Однако B<pselect>() не изменяет структуру времени ожидания."

#. type: TP
#: man-pages/man2/select_tut.2:450
#, no-wrap
msgid "11."
msgstr "11."

#.  "I have heard" does not fill me with confidence, and doesn't
#.  belong in a man page, so I've commented this point out.
#.  .TP
#.  11.
#.  I have heard that the Windows socket layer does not cope with OOB data
#.  properly.
#.  It also does not cope with
#.  .BR select ()
#.  calls when no file descriptors are set at all.
#.  Having no file descriptors set is a useful
#.  way to sleep the process with subsecond precision by using the timeout.
#.  (See further on.)
#. type: Plain text
#: man-pages/man2/select_tut.2:469
msgid ""
"Since B<select>()  modifies its file descriptor sets, if the call is being "
"used in a loop, then the sets must be reinitialized before each call."
msgstr "Так как B<select>() изменяет переданные наборы файловых дескрипторов, то при использовании его в цикле наборы должны повторно инициализироваться перед каждым вызовом."

#. type: SS
#: man-pages/man2/select_tut.2:469
#, no-wrap
msgid "Usleep emulation"
msgstr "Эмуляция usleep"

#. type: Plain text
#: man-pages/man2/select_tut.2:476
msgid ""
"On systems that do not have a B<usleep>(3)  function, you can call "
"B<select>()  with a finite timeout and no file descriptors as follows:"
msgstr "В системах, не имеющих функции B<usleep>(3), вы можете использовать B<select>() с конечной задержкой и без файловых дескрипторов следующим образом:"

#. type: Plain text
#: man-pages/man2/select_tut.2:482
#, no-wrap
msgid ""
"    struct timeval tv;\n"
"    tv.tv_sec = 0;\n"
"    tv.tv_usec = 200000;  /* 0.2 seconds */\n"
"    select(0, NULL, NULL, NULL, &tv);\n"
msgstr "    struct timeval tv;\n    tv.tv_sec = 0;\n    tv.tv_usec = 200000;  /* 0.2 секунды */\n    select(0, NULL, NULL, NULL, &tv);\n"

#. type: Plain text
#: man-pages/man2/select_tut.2:485
msgid "This is guaranteed to work only on UNIX systems, however."
msgstr "Однако работа гарантируется только в системах UNIX."

#. type: Plain text
#: man-pages/man2/select_tut.2:490
msgid ""
"On success, B<select>()  returns the total number of file descriptors still "
"present in the file descriptor sets."
msgstr "При удачно завершении B<select>() возвращает общее число файловых дескрипторов, которые остались в наборах."

#. type: Plain text
#: man-pages/man2/select_tut.2:496
msgid ""
"If B<select>()  timed out, then the return value will be zero.  The file "
"descriptors set should be all empty (but may not be on some systems)."
msgstr "При выходе из B<select>() по окончании времени ожидания возвращается ноль. Все наборы файловых дескрипторов будут пусты (но могут быть не пусты на некоторых системах)."

#. type: Plain text
#: man-pages/man2/select_tut.2:503
msgid ""
"A return value of -1 indicates an error, with I<errno> being set "
"appropriately.  In the case of an error, the contents of the returned sets "
"and the I<struct timeout> contents are undefined and should not be used.  "
"B<pselect>()  however never modifies I<ntimeout>."
msgstr "Значение -1 указывает на ошибку, при этом I<errno> устанавливается соответствующим образом. В случае ошибки содержимое наборов и структуры I<struct timeout> не определено и не должно быть использовано. Однако вызов B<pselect>() никогда не изменяет I<ntimeout>."

#. type: Plain text
#: man-pages/man2/select_tut.2:512
msgid ""
"Generally speaking, all operating systems that support sockets also support "
"B<select>().  B<select>()  can be used to solve many problems in a portable "
"and efficient way that naive programmers try to solve in a more complicated "
"manner using threads, forking, IPCs, signals, memory sharing, and so on."
msgstr "В общем случае, все операционные системы, поддерживающие сокеты, поддерживают также и B<select>(). Вызов B<select>() можно применять для переносимого и эффективного решения многих задач, вместо которого многие программисты пытаются использовать нити, ветвление процессов, IPC, сигналы, разделение памяти и другие методы."

#. type: Plain text
#: man-pages/man2/select_tut.2:521
msgid ""
"The B<poll>(2)  system call has the same functionality as B<select>(), and "
"is somewhat more efficient when monitoring sparse file descriptor sets.  It "
"is nowadays widely available, but historically was less portable than "
"B<select>()."
msgstr "Системный вызов B<poll>(2) имеет такую же функциональность, как и B<select>() и иногда более эффективен для слежения за разреженным набором файловых дескрипторов. В настоящее время он стал широко распространён, но исторически является менее переносимым чем B<select>()."

#. type: Plain text
#: man-pages/man2/select_tut.2:529
msgid ""
"The Linux-specific B<epoll>(7)  API provides an interface that is more "
"efficient than B<select>(2)  and B<poll>(2)  when monitoring large numbers "
"of file descriptors."
msgstr "Программный интерфейс Linux B<epoll>(7) предоставляет более эффективный метод для слежения за большим количеством файловых дескрипторов чем B<select>(2) и B<poll>(2)."

#. type: Plain text
#: man-pages/man2/select_tut.2:534
msgid ""
"Here is an example that better demonstrates the true utility of B<select>()."
"  The listing below is a TCP forwarding program that forwards from one TCP "
"port to another."
msgstr "Вот пример, который лучше демонстрирует возможности B<select>(). Программа осуществляет перенаправление одного порта TCP в другой. "

#. type: Plain text
#: man-pages/man2/select_tut.2:547
#, no-wrap
msgid ""
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>sys/time.hE<gt>\n"
"#include E<lt>sys/types.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>signal.hE<gt>\n"
"#include E<lt>sys/socket.hE<gt>\n"
"#include E<lt>netinet/in.hE<gt>\n"
"#include E<lt>arpa/inet.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"
msgstr "#include E<lt>stdlib.hE<gt>\n#include E<lt>stdio.hE<gt>\n#include E<lt>unistd.hE<gt>\n#include E<lt>sys/time.hE<gt>\n#include E<lt>sys/types.hE<gt>\n#include E<lt>string.hE<gt>\n#include E<lt>signal.hE<gt>\n#include E<lt>sys/socket.hE<gt>\n#include E<lt>netinet/in.hE<gt>\n#include E<lt>arpa/inet.hE<gt>\n#include E<lt>errno.hE<gt>\n"

#. type: Plain text
#: man-pages/man2/select_tut.2:549
#, no-wrap
msgid "static int forward_port;\n"
msgstr "static int forward_port;\n"

#. type: Plain text
#: man-pages/man2/select_tut.2:552
#, no-wrap
msgid ""
"#undef max\n"
"#define max(x,y) ((x) E<gt> (y) ? (x) : (y))\n"
msgstr "#undef max\n#define max(x,y) ((x) E<gt> (y) ? (x) : (y))\n"

#. type: Plain text
#: man-pages/man2/select_tut.2:559
#, no-wrap
msgid ""
"static int\n"
"listen_socket(int listen_port)\n"
"{\n"
"    struct sockaddr_in a;\n"
"    int s;\n"
"    int yes;\n"
msgstr "static int\nlisten_socket(int listen_port)\n{\n    struct sockaddr_in a;\n    int s;\n    int yes;\n"

#. type: Plain text
#: man-pages/man2/select_tut.2:584
#, no-wrap
msgid ""
"    s = socket(AF_INET, SOCK_STREAM, 0);\n"
"    if (s == -1) {\n"
"        perror(\"socket\");\n"
"        return -1;\n"
"    }\n"
"    yes = 1;\n"
"    if (setsockopt(s, SOL_SOCKET, SO_REUSEADDR,\n"
"            &yes, sizeof(yes)) == -1) {\n"
"        perror(\"setsockopt\");\n"
"        close(s);\n"
"        return -1;\n"
"    }\n"
"    memset(&a, 0, sizeof(a));\n"
"    a.sin_port = htons(listen_port);\n"
"    a.sin_family = AF_INET;\n"
"    if (bind(s, (struct sockaddr *) &a, sizeof(a)) == -1) {\n"
"        perror(\"bind\");\n"
"        close(s);\n"
"        return -1;\n"
"    }\n"
"    printf(\"accepting connections on port %d\\en\", listen_port);\n"
"    listen(s, 10);\n"
"    return s;\n"
"}\n"
msgstr "    s = socket(AF_INET, SOCK_STREAM, 0);\n    if (s == -1) {\n        perror(\"socket\");\n        return -1;\n    }\n    yes = 1;\n    if (setsockopt(s, SOL_SOCKET, SO_REUSEADDR,\n            &yes, sizeof(yes)) == -1) {\n        perror(\"setsockopt\");\n        close(s);\n        return -1;\n    }\n    memset(&a, 0, sizeof(a));\n    a.sin_port = htons(listen_port);\n    a.sin_family = AF_INET;\n    if (bind(s, (struct sockaddr *) &a, sizeof(a)) == -1) {\n        perror(\"bind\");\n        close(s);\n        return -1;\n    }\n    printf(\"приём подключений к порту %d\\en\", listen_port);\n    listen(s, 10);\n    return s;\n}\n"

#. type: Plain text
#: man-pages/man2/select_tut.2:590
#, no-wrap
msgid ""
"static int\n"
"connect_socket(int connect_port, char *address)\n"
"{\n"
"    struct sockaddr_in a;\n"
"    int s;\n"
msgstr "static int\nconnect_socket(int connect_port, char *address)\n{\n    struct sockaddr_in a;\n    int s;\n"

#. type: Plain text
#: man-pages/man2/select_tut.2:597
#, no-wrap
msgid ""
"    s = socket(AF_INET, SOCK_STREAM, 0);\n"
"    if (s == -1) {\n"
"        perror(\"socket\");\n"
"        close(s);\n"
"        return -1;\n"
"    }\n"
msgstr "    s = socket(AF_INET, SOCK_STREAM, 0);\n    if (s == -1) {\n        perror(\"socket\");\n        close(s);\n        return -1;\n    }\n"

#. type: Plain text
#: man-pages/man2/select_tut.2:601
#, no-wrap
msgid ""
"    memset(&a, 0, sizeof(a));\n"
"    a.sin_port = htons(connect_port);\n"
"    a.sin_family = AF_INET;\n"
msgstr "    memset(&a, 0, sizeof(a));\n    a.sin_port = htons(connect_port);\n    a.sin_family = AF_INET;\n"

#. type: Plain text
#: man-pages/man2/select_tut.2:607
#, no-wrap
msgid ""
"    if (!inet_aton(address, (struct in_addr *) &a.sin_addr.s_addr)) {\n"
"        perror(\"bad IP address format\");\n"
"        close(s);\n"
"        return -1;\n"
"    }\n"
msgstr "    if (!inet_aton(address, (struct in_addr *) &a.sin_addr.s_addr)) {\n        perror(\"неправильный формат IP-адреса\");\n        close(s);\n        return -1;\n    }\n"

#. type: Plain text
#: man-pages/man2/select_tut.2:616
#, no-wrap
msgid ""
"    if (connect(s, (struct sockaddr *) &a, sizeof(a)) == -1) {\n"
"        perror(\"connect()\");\n"
"        shutdown(s, SHUT_RDWR);\n"
"        close(s);\n"
"        return -1;\n"
"    }\n"
"    return s;\n"
"}\n"
msgstr "    if (connect(s, (struct sockaddr *) &a, sizeof(a)) == -1) {\n        perror(\"connect()\");\n        shutdown(s, SHUT_RDWR);\n        close(s);\n        return -1;\n    }\n    return s;\n}\n"

#. type: Plain text
#: man-pages/man2/select_tut.2:624
#, no-wrap
msgid ""
"#define SHUT_FD1 do {                                \\e\n"
"                     if (fd1 E<gt>= 0) {                 \\e\n"
"                         shutdown(fd1, SHUT_RDWR);   \\e\n"
"                         close(fd1);                 \\e\n"
"                         fd1 = -1;                   \\e\n"
"                     }                               \\e\n"
"                 } while (0)\n"
msgstr "#define SHUT_FD1 do {                                \\e\n                     if (fd1 E<gt>= 0) {                 \\e\n                         shutdown(fd1, SHUT_RDWR);   \\e\n                         close(fd1);                 \\e\n                         fd1 = -1;                   \\e\n                     }                               \\e\n                 } while (0)\n"

#. type: Plain text
#: man-pages/man2/select_tut.2:632
#, no-wrap
msgid ""
"#define SHUT_FD2 do {                                \\e\n"
"                     if (fd2 E<gt>= 0) {                 \\e\n"
"                         shutdown(fd2, SHUT_RDWR);   \\e\n"
"                         close(fd2);                 \\e\n"
"                         fd2 = -1;                   \\e\n"
"                     }                               \\e\n"
"                 } while (0)\n"
msgstr "#define SHUT_FD2 do {                                \\e\n                     if (fd2 E<gt>= 0) {                 \\e\n                         shutdown(fd2, SHUT_RDWR);   \\e\n                         close(fd2);                 \\e\n                         fd2 = -1;                   \\e\n                     }                               \\e\n                 } while (0)\n"

#. type: Plain text
#: man-pages/man2/select_tut.2:634
#, no-wrap
msgid "#define BUF_SIZE 1024\n"
msgstr "#define BUF_SIZE 1024\n"

#. type: Plain text
#: man-pages/man2/select_tut.2:643
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int h;\n"
"    int fd1 = -1, fd2 = -1;\n"
"    char buf1[BUF_SIZE], buf2[BUF_SIZE];\n"
"    int buf1_avail, buf1_written;\n"
"    int buf2_avail, buf2_written;\n"
msgstr "int\nmain(int argc, char *argv[])\n{\n    int h;\n    int fd1 = -1, fd2 = -1;\n    char buf1[BUF_SIZE], buf2[BUF_SIZE];\n    int buf1_avail, buf1_written;\n    int buf2_avail, buf2_written;\n"

#. type: Plain text
#: man-pages/man2/select_tut.2:649
#, no-wrap
msgid ""
"    if (argc != 4) {\n"
"        fprintf(stderr, \"Usage\\en\\etfwd E<lt>listen-portE<gt> \"\n"
"                 \"E<lt>forward-to-portE<gt> E<lt>forward-to-ip-addressE<gt>\\en\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr "    if (argc != 4) {\n        fprintf(stderr, \"Использование\\en\\etfwd E<lt>прослушиваемый-портE<gt> \"\n                 \"E<lt>порт-перенаправленияE<gt> E<lt>ip-адрес-перенаправленияE<gt>\\en\");\n        exit(EXIT_FAILURE);\n    }\n"

#. type: Plain text
#: man-pages/man2/select_tut.2:651
#, no-wrap
msgid "    signal(SIGPIPE, SIG_IGN);\n"
msgstr "    signal(SIGPIPE, SIG_IGN);\n"

#. type: Plain text
#: man-pages/man2/select_tut.2:653
#, no-wrap
msgid "    forward_port = atoi(argv[2]);\n"
msgstr "    forward_port = atoi(argv[2]);\n"

#. type: Plain text
#: man-pages/man2/select_tut.2:657
#, no-wrap
msgid ""
"    h = listen_socket(atoi(argv[1]));\n"
"    if (h == -1)\n"
"        exit(EXIT_FAILURE);\n"
msgstr "    h = listen_socket(atoi(argv[1]));\n    if (h == -1)\n        exit(EXIT_FAILURE);\n"

#. type: Plain text
#: man-pages/man2/select_tut.2:661
#, no-wrap
msgid ""
"    for (;;) {\n"
"        int r, nfds = 0;\n"
"        fd_set rd, wr, er;\n"
msgstr "    for (;;) {\n        int r, nfds = 0;\n        fd_set rd, wr, er;\n"

#. type: Plain text
#: man-pages/man2/select_tut.2:691
#, no-wrap
msgid ""
"        FD_ZERO(&rd);\n"
"        FD_ZERO(&wr);\n"
"        FD_ZERO(&er);\n"
"        FD_SET(h, &rd);\n"
"        nfds = max(nfds, h);\n"
"        if (fd1 E<gt> 0 && buf1_avail E<lt> BUF_SIZE) {\n"
"            FD_SET(fd1, &rd);\n"
"            nfds = max(nfds, fd1);\n"
"        }\n"
"        if (fd2 E<gt> 0 && buf2_avail E<lt> BUF_SIZE) {\n"
"            FD_SET(fd2, &rd);\n"
"            nfds = max(nfds, fd2);\n"
"        }\n"
"        if (fd1 E<gt> 0 && buf2_avail - buf2_written E<gt> 0) {\n"
"            FD_SET(fd1, &wr);\n"
"            nfds = max(nfds, fd1);\n"
"        }\n"
"        if (fd2 E<gt> 0 && buf1_avail - buf1_written E<gt> 0) {\n"
"            FD_SET(fd2, &wr);\n"
"            nfds = max(nfds, fd2);\n"
"        }\n"
"        if (fd1 E<gt> 0) {\n"
"            FD_SET(fd1, &er);\n"
"            nfds = max(nfds, fd1);\n"
"        }\n"
"        if (fd2 E<gt> 0) {\n"
"            FD_SET(fd2, &er);\n"
"            nfds = max(nfds, fd2);\n"
"        }\n"
msgstr "        FD_ZERO(&rd);\n        FD_ZERO(&wr);\n        FD_ZERO(&er);\n        FD_SET(h, &rd);\n        nfds = max(nfds, h);\n        if (fd1 E<gt> 0 && buf1_avail E<lt> BUF_SIZE) {\n            FD_SET(fd1, &rd);\n            nfds = max(nfds, fd1);\n        }\n        if (fd2 E<gt> 0 && buf2_avail E<lt> BUF_SIZE) {\n            FD_SET(fd2, &rd);\n            nfds = max(nfds, fd2);\n        }\n        if (fd1 E<gt> 0 && buf2_avail - buf2_written E<gt> 0) {\n            FD_SET(fd1, &wr);\n            nfds = max(nfds, fd1);\n        }\n        if (fd2 E<gt> 0 && buf1_avail - buf1_written E<gt> 0) {\n            FD_SET(fd2, &wr);\n            nfds = max(nfds, fd2);\n        }\n        if (fd1 E<gt> 0) {\n            FD_SET(fd1, &er);\n            nfds = max(nfds, fd1);\n        }\n        if (fd2 E<gt> 0) {\n            FD_SET(fd2, &er);\n            nfds = max(nfds, fd2);\n        }\n"

#. type: Plain text
#: man-pages/man2/select_tut.2:693
#, no-wrap
msgid "        r = select(nfds + 1, &rd, &wr, &er, NULL);\n"
msgstr "        r = select(nfds + 1, &rd, &wr, &er, NULL);\n"

#. type: Plain text
#: man-pages/man2/select_tut.2:696
#, no-wrap
msgid ""
"        if (r == -1 && errno == EINTR)\n"
"            continue;\n"
msgstr "        if (r == -1 && errno == EINTR)\n            continue;\n"

#. type: Plain text
#: man-pages/man2/select_tut.2:701
#, no-wrap
msgid ""
"        if (r == -1) {\n"
"            perror(\"select()\");\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"
msgstr "        if (r == -1) {\n            perror(\"select()\");\n            exit(EXIT_FAILURE);\n        }\n"

#. type: Plain text
#: man-pages/man2/select_tut.2:705
#, no-wrap
msgid ""
"        if (FD_ISSET(h, &rd)) {\n"
"            unsigned int l;\n"
"            struct sockaddr_in client_address;\n"
msgstr "        if (FD_ISSET(h, &rd)) {\n            unsigned int l;\n            struct sockaddr_in client_address;\n"

#. type: Plain text
#: man-pages/man2/select_tut.2:724
#, no-wrap
msgid ""
"            memset(&client_address, 0, l = sizeof(client_address));\n"
"            r = accept(h, (struct sockaddr *) &client_address, &l);\n"
"            if (r == -1) {\n"
"                perror(\"accept()\");\n"
"            } else {\n"
"                SHUT_FD1;\n"
"                SHUT_FD2;\n"
"                buf1_avail = buf1_written = 0;\n"
"                buf2_avail = buf2_written = 0;\n"
"                fd1 = r;\n"
"                fd2 = connect_socket(forward_port, argv[3]);\n"
"                if (fd2 == -1)\n"
"                    SHUT_FD1;\n"
"                else\n"
"                    printf(\"connect from %s\\en\",\n"
"                            inet_ntoa(client_address.sin_addr));\n"
"            }\n"
"        }\n"
msgstr "            memset(&client_address, 0, l = sizeof(client_address));\n            r = accept(h, (struct sockaddr *) &client_address, &l);\n            if (r == -1) {\n                perror(\"accept()\");\n            } else {\n                SHUT_FD1;\n                SHUT_FD2;\n                buf1_avail = buf1_written = 0;\n                buf2_avail = buf2_written = 0;\n                fd1 = r;\n                fd2 = connect_socket(forward_port, argv[3]);\n                if (fd2 == -1)\n                    SHUT_FD1;\n                else\n                    printf(\"подключение от %s\\en\",\n                            inet_ntoa(client_address.sin_addr));\n            }\n        }\n"

#. type: Plain text
#: man-pages/man2/select_tut.2:726
#, no-wrap
msgid "        /* NB: read oob data before normal reads */\n"
msgstr "        /* NB: чтение данных oob до обычных */\n"

#. type: Plain text
#: man-pages/man2/select_tut.2:730
#, no-wrap
msgid ""
"        if (fd1 E<gt> 0)\n"
"            if (FD_ISSET(fd1, &er)) {\n"
"                char c;\n"
msgstr "        if (fd1 E<gt> 0)\n            if (FD_ISSET(fd1, &er)) {\n                char c;\n"

#. type: Plain text
#: man-pages/man2/select_tut.2:740
#, no-wrap
msgid ""
"                r = recv(fd1, &c, 1, MSG_OOB);\n"
"                if (r E<lt> 1)\n"
"                    SHUT_FD1;\n"
"                else\n"
"                    send(fd2, &c, 1, MSG_OOB);\n"
"            }\n"
"        if (fd2 E<gt> 0)\n"
"            if (FD_ISSET(fd2, &er)) {\n"
"                char c;\n"
msgstr "                r = recv(fd1, &c, 1, MSG_OOB);\n                if (r E<lt> 1)\n                    SHUT_FD1;\n                else\n                    send(fd2, &c, 1, MSG_OOB);\n            }\n        if (fd2 E<gt> 0)\n            if (FD_ISSET(fd2, &er)) {\n                char c;\n"

#. type: Plain text
#: man-pages/man2/select_tut.2:783
#, no-wrap
msgid ""
"                r = recv(fd2, &c, 1, MSG_OOB);\n"
"                if (r E<lt> 1)\n"
"                    SHUT_FD2;\n"
"                else\n"
"                    send(fd1, &c, 1, MSG_OOB);\n"
"            }\n"
"        if (fd1 E<gt> 0)\n"
"            if (FD_ISSET(fd1, &rd)) {\n"
"                r = read(fd1, buf1 + buf1_avail,\n"
"                          BUF_SIZE - buf1_avail);\n"
"                if (r E<lt> 1)\n"
"                    SHUT_FD1;\n"
"                else\n"
"                    buf1_avail += r;\n"
"            }\n"
"        if (fd2 E<gt> 0)\n"
"            if (FD_ISSET(fd2, &rd)) {\n"
"                r = read(fd2, buf2 + buf2_avail,\n"
"                          BUF_SIZE - buf2_avail);\n"
"                if (r E<lt> 1)\n"
"                    SHUT_FD2;\n"
"                else\n"
"                    buf2_avail += r;\n"
"            }\n"
"        if (fd1 E<gt> 0)\n"
"            if (FD_ISSET(fd1, &wr)) {\n"
"                r = write(fd1, buf2 + buf2_written,\n"
"                           buf2_avail - buf2_written);\n"
"                if (r E<lt> 1)\n"
"                    SHUT_FD1;\n"
"                else\n"
"                    buf2_written += r;\n"
"            }\n"
"        if (fd2 E<gt> 0)\n"
"            if (FD_ISSET(fd2, &wr)) {\n"
"                r = write(fd2, buf1 + buf1_written,\n"
"                           buf1_avail - buf1_written);\n"
"                if (r E<lt> 1)\n"
"                    SHUT_FD2;\n"
"                else\n"
"                    buf1_written += r;\n"
"            }\n"
msgstr "                r = recv(fd2, &c, 1, MSG_OOB);\n                if (r E<lt> 1)\n                    SHUT_FD2;\n                else\n                    send(fd1, &c, 1, MSG_OOB);\n            }\n        if (fd1 E<gt> 0)\n            if (FD_ISSET(fd1, &rd)) {\n                r = read(fd1, buf1 + buf1_avail,\n                          BUF_SIZE - buf1_avail);\n                if (r E<lt> 1)\n                    SHUT_FD1;\n                else\n                    buf1_avail += r;\n            }\n        if (fd2 E<gt> 0)\n            if (FD_ISSET(fd2, &rd)) {\n                r = read(fd2, buf2 + buf2_avail,\n                          BUF_SIZE - buf2_avail);\n                if (r E<lt> 1)\n                    SHUT_FD2;\n                else\n                    buf2_avail += r;\n            }\n        if (fd1 E<gt> 0)\n            if (FD_ISSET(fd1, &wr)) {\n                r = write(fd1, buf2 + buf2_written,\n                           buf2_avail - buf2_written);\n                if (r E<lt> 1)\n                    SHUT_FD1;\n                else\n                    buf2_written += r;\n            }\n        if (fd2 E<gt> 0)\n            if (FD_ISSET(fd2, &wr)) {\n                r = write(fd2, buf1 + buf1_written,\n                           buf1_avail - buf1_written);\n                if (r E<lt> 1)\n                    SHUT_FD2;\n                else\n                    buf1_written += r;\n            }\n"

#. type: Plain text
#: man-pages/man2/select_tut.2:785
#, no-wrap
msgid "        /* check if write data has caught read data */\n"
msgstr "        /* проверить, что записанные данные были прочитаны */\n"

#. type: Plain text
#: man-pages/man2/select_tut.2:790
#, no-wrap
msgid ""
"        if (buf1_written == buf1_avail)\n"
"            buf1_written = buf1_avail = 0;\n"
"        if (buf2_written == buf2_avail)\n"
"            buf2_written = buf2_avail = 0;\n"
msgstr "        if (buf1_written == buf1_avail)\n            buf1_written = buf1_avail = 0;\n        if (buf2_written == buf2_avail)\n            buf2_written = buf2_avail = 0;\n"

#. type: Plain text
#: man-pages/man2/select_tut.2:793
#, no-wrap
msgid ""
"        /* one side has closed the connection, keep\n"
"           writing to the other side until empty */\n"
msgstr "        /* одна из сторон закрыла соединение, продолжать\n           записывать, пока другая сторона не закончит */\n"

#. type: Plain text
#: man-pages/man2/select_tut.2:801
#, no-wrap
msgid ""
"        if (fd1 E<lt> 0 && buf1_avail - buf1_written == 0)\n"
"            SHUT_FD2;\n"
"        if (fd2 E<lt> 0 && buf2_avail - buf2_written == 0)\n"
"            SHUT_FD1;\n"
"    }\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr "        if (fd1 E<lt> 0 && buf1_avail - buf1_written == 0)\n            SHUT_FD2;\n        if (fd2 E<lt> 0 && buf2_avail - buf2_written == 0)\n            SHUT_FD1;\n    }\n    exit(EXIT_SUCCESS);\n}\n"

#. type: Plain text
#: man-pages/man2/select_tut.2:815
msgid ""
"The above program properly forwards most kinds of TCP connections including "
"OOB signal data transmitted by B<telnet> servers.  It handles the tricky "
"problem of having data flow in both directions simultaneously.  You might "
"think it more efficient to use a B<fork>(2)  call and devote a thread to "
"each stream.  This becomes more tricky than you might suspect.  Another idea"
" is to set nonblocking I/O using B<fcntl>(2).  This also has its problems "
"because you end up using inefficient timeouts."
msgstr "Вышеприведенная программа правильно перенаправляет большинство данных задач, использующих соединения TCP, включая внепоточные (OOB) данные, передаваемые серверами B<telnet>. Она справляется со сложной проблемой поддержания одновременного двустороннего обмена данными. Возможно, вы решите, что эффективнее использовать B<fork>(2) и выделить отдельную нить для каждого потока. На самом деле это сложнее, чем кажется. Другой идеей может быть использование неблокирующего ввода-вывода с помощью B<fcntl>(2). Это также может вызвать проблемы из-за того, что придётся использовать неэффективные таймауты."

#. type: Plain text
#: man-pages/man2/select_tut.2:821
msgid ""
"The program does not handle more than one simultaneous connection at a time,"
" although it could easily be extended to do this with a linked list of "
"buffers\\(emone for each connection.  At the moment, new connections cause "
"the current connection to be dropped."
msgstr "Программа не обрабатывает более одного соединения, однако она может быть легко доработана путем добавления связанного списка буферов — по одному на каждое соединение. В данный момент новые соединения приводят к закрытию текущего."

#. type: Plain text
#: man-pages/man2/select_tut.2:837
msgid ""
"B<accept>(2), B<connect>(2), B<ioctl>(2), B<poll>(2), B<read>(2), "
"B<recv>(2), B<select>(2), B<send>(2), B<sigprocmask>(2), B<write>(2), "
"B<sigaddset>(3), B<sigdelset>(3), B<sigemptyset>(3), B<sigfillset>(3), "
"B<sigismember>(3), B<epoll>(7)"
msgstr "B<accept>(2), B<connect>(2), B<ioctl>(2), B<poll>(2), B<read>(2), B<recv>(2), B<select>(2), B<send>(2), B<sigprocmask>(2), B<write>(2), B<sigaddset>(3), B<sigdelset>(3), B<sigemptyset>(3), B<sigfillset>(3), B<sigismember>(3), B<epoll>(7)"

#. type: Plain text
#: man-pages/man2/signal.2:39
msgid "signal - ANSI C signal handling"
msgstr "signal - работа с сигналами ANSI C"

#. type: Plain text
#: man-pages/man2/signal.2:43
msgid "B<typedef void (*sighandler_t)(int);>"
msgstr "B<typedef void (*sighandler_t)(int);>"

#. type: Plain text
#: man-pages/man2/signal.2:45
msgid "B<sighandler_t signal(int >I<signum>B<, sighandler_t >I<handler>B<);>"
msgstr "B<sighandler_t signal(int >I<signum>B<, sighandler_t >I<handler>B<);>"

#. type: Plain text
#: man-pages/man2/signal.2:54
msgid ""
"The behavior of B<signal>()  varies across UNIX versions, and has also "
"varied historically across different versions of Linux.  B<Avoid its use>: "
"use B<sigaction>(2)  instead.  See I<Portability> below."
msgstr "Работа вызова B<signal>() различается в различных версиях UNIX, и такая же ситуация исторически сложилась и в различных версиях Linux. B<Не используйте его>: используйте вместо него B<sigaction>(2). Смотрите абзац I<Переносимость> далее."

#. type: Plain text
#: man-pages/man2/signal.2:64
msgid ""
"B<signal>()  sets the disposition of the signal I<signum> to I<handler>, "
"which is either B<SIG_IGN>, B<SIG_DFL>, or the address of a programmer-"
"defined function (a \"signal handler\")."
msgstr "Вызов B<signal>() устанавливает обработчик сигнала с номером I<signum> в соответствии с параметром I<handler>, который может быть равен B<SIG_IGN>, B<SIG_DFL> или адресу функции пользователя (\"обработчик сигнала\")."

#. type: Plain text
#: man-pages/man2/signal.2:68
msgid ""
"If the signal I<signum> is delivered to the process, then one of the "
"following happens:"
msgstr "Если сигнал I<signum> доставляется процессу, то происходит следующее:"

#. type: Plain text
#: man-pages/man2/signal.2:73
msgid "If the disposition is set to B<SIG_IGN>, then the signal is ignored."
msgstr "Если значение обработчика равно B<SIG_IGN>, то сигнал игнорируется."

#. type: Plain text
#: man-pages/man2/signal.2:80
msgid ""
"If the disposition is set to B<SIG_DFL>, then the default action associated "
"with the signal (see B<signal>(7))  occurs."
msgstr "Если значение обработчика равно B<SIG_DFL>, то выполняется стандартное действие, связанное с сигналом (см. B<signal>(7))."

#. type: Plain text
#: man-pages/man2/signal.2:91
msgid ""
"If the disposition is set to a function, then first either the disposition "
"is reset to B<SIG_DFL>, or the signal is blocked (see I<Portability> below),"
" and then I<handler> is called with argument I<signum>.  If invocation of "
"the handler caused the signal to be blocked, then the signal is unblocked "
"upon return from the handler."
msgstr "Если значение обработчика равно адресу функции, то сначала значение обработчика сбрасывается в B<SIG_DFL> или сигнал блокируется (см. I<Переносимость> далее), а затем вызывается функция I<handler> с аргументом I<signum>. Если вызов обработчика приводит к блокировке сигнала, то сигнал разблокируется после возврата из обработчика."

#. type: Plain text
#: man-pages/man2/signal.2:97
msgid "The signals B<SIGKILL> and B<SIGSTOP> cannot be caught or ignored."
msgstr "Сигналы B<SIGKILL> и B<SIGSTOP> не могут быть перехвачены или игнорированы."

#. type: Plain text
#: man-pages/man2/signal.2:105
msgid ""
"B<signal>()  returns the previous value of the signal handler, or B<SIG_ERR>"
" on error.  In the event of an error, I<errno> is set to indicate the cause."
msgstr "Вызов B<signal>() возвращает предыдущее значение обработчика сигнала или B<SIG_ERR> при ошибке. В случае ошибки в I<errno> указывается номер ошибки."

#. type: Plain text
#: man-pages/man2/signal.2:110
msgid "I<signum> is invalid."
msgstr "Неверное значение I<signum>."

#. type: Plain text
#: man-pages/man2/signal.2:112
msgid "C89, C99, POSIX.1-2001."
msgstr "C89, C99, POSIX.1-2001."

#. type: Plain text
#: man-pages/man2/signal.2:116
msgid ""
"The effects of B<signal>()  in a multithreaded process are unspecified."
msgstr "Результат работы B<signal>() в многонитиевом процессе не регламентирован."

#. type: Plain text
#: man-pages/man2/signal.2:141
msgid ""
"See B<sigaction>(2)  for details on what happens when B<SIGCHLD> is set to "
"B<SIG_IGN>."
msgstr "О том, что происходит когда B<SIGCHLD> устанавливается в B<SIG_IGN>, смотрите на странице B<sigaction>(2)."

#. type: Plain text
#: man-pages/man2/signal.2:146
msgid ""
"See B<signal>(7)  for a list of the async-signal-safe functions that can be "
"safely called from inside a signal handler."
msgstr "Список асинхронных функций работы с сигналами, которые можно безопасно вызывать из обработчика сигналов, смотрите на странице B<signal>(7)."

#.  libc4 and libc5 define
#.  .IR SignalHandler ;
#. type: Plain text
#: man-pages/man2/signal.2:162
msgid ""
"The use of I<sighandler_t> is a GNU extension, exposed if B<_GNU_SOURCE> is "
"defined; glibc also defines (the BSD-derived)  I<sig_t> if B<_BSD_SOURCE> is"
" defined.  Without use of such a type, the declaration of B<signal>()  is "
"the somewhat harder to read:"
msgstr "Используемый I<sighandler_t> является расширением GNU, который определён, если существует макрос B<_GNU_SOURCE>; в glibc также есть I<sig_t> (появился из BSD), если определён B<_BSD_SOURCE>. Без использования такого типа объявление B<signal>() сложнее читать:"

#. type: Plain text
#: man-pages/man2/signal.2:166
#, no-wrap
msgid ""
"B<void ( *>I<signal>B<(int >I<signum>B<, void (*>I<handler>B<)(int)) ) "
"(int);>\n"
msgstr "B<void ( *>I<signal>B<(int >I<signum>B<, void (*>I<handler>B<)(int)) ) (int);>\n"

#. type: SS
#: man-pages/man2/signal.2:168
#, no-wrap
msgid "Portability"
msgstr "Переносимость"

#. type: Plain text
#: man-pages/man2/signal.2:180
msgid ""
"The only portable use of B<signal>()  is to set a signal's disposition to "
"B<SIG_DFL> or B<SIG_IGN>.  The semantics when using B<signal>()  to "
"establish a signal handler vary across systems (and POSIX.1 explicitly "
"permits this variation); B<do not use it for this purpose.>"
msgstr "Вызов B<signal>() считается переносимым, если обработчик сигнала равен B<SIG_DFL> или B<SIG_IGN>. Семантика при использовании B<signal>() для установки обработчика сигнала отличается в различных системах (и в POSIX.1 явно разрешена такая перемена); B<не используйте данный вызов для этой цели.>"

#. type: Plain text
#: man-pages/man2/signal.2:186
msgid ""
"POSIX.1 solved the portability mess by specifying B<sigaction>(2), which "
"provides explicit control of the semantics when a signal handler is invoked;"
" use that interface instead of B<signal>()."
msgstr "В POSIX.1 проблема переносимости решена введением B<sigaction>(2), который предоставляет явное управление семантикой при вызове обработчика сигнала; используйте этот интерфейс вместо B<signal>()."

#. type: Plain text
#: man-pages/man2/signal.2:196
msgid ""
"In the original UNIX systems, when a handler that was established using "
"B<signal>()  was invoked by the delivery of a signal, the disposition of the"
" signal would be reset to B<SIG_DFL>, and the system did not block delivery "
"of further instances of the signal.  This is equivalent to calling "
"B<sigaction>(2)  with the following flags:"
msgstr "В первых системах UNIX, когда обработчик, установленный с помощью B<signal>(), вызывался по получению сигнала, обработчик сигнала был бы сброшен в B<SIG_DFL>, и система не заблокировала бы доставку этого сигнала в последующие экземпляры."

#. type: Plain text
#: man-pages/man2/signal.2:198
#, no-wrap
msgid "    sa.sa_flags = SA_RESETHAND | SA_NODEFER;\n"
msgstr "    sa.sa_flags = SA_RESETHAND | SA_NODEFER;\n"

#. type: Plain text
#: man-pages/man2/signal.2:205
msgid ""
"System\\ V also provides these semantics for B<signal>().  This was bad "
"because the signal might be delivered again before the handler had a chance "
"to reestablish itself.  Furthermore, rapid deliveries of the same signal "
"could result in recursive invocations of the handler."
msgstr "System\\ V также предоставляет эту семантику B<signal>(). Это плохо, так как сигнал может быть доставлен снова, до того как обработчик сможет получить шанс его переустановить. Кроме того, скоростные доставки одного сигнала приводили к рекурсивным вызовам обработчика."

#. type: Plain text
#: man-pages/man2/signal.2:220
msgid ""
"BSD improved on this situation, but unfortunately also changed the semantics"
" of the existing B<signal>()  interface while doing so.  On BSD, when a "
"signal handler is invoked, the signal disposition is not reset, and further "
"instances of the signal are blocked from being delivered while the handler "
"is executing.  Furthermore, certain blocking system calls are automatically "
"restarted if interrupted by a signal handler (see B<signal>(7)).  The BSD "
"semantics are equivalent to calling B<sigaction>(2)  with the following "
"flags:"
msgstr "В BSD улучшили эту ситуацию, но, к сожалению, изменили существующую семантику для установки обработчика с помощью B<signal>(). В BSD при вызове обработчика сигнала обработчик сигнала не сбрасывается, и дальнейшие экземпляры сигнала блокируются и не доставляются пока выполняется обработчик. Кроме этого, некоторые блокирующие системные вызовы автоматически перезапускаются при прерывании обработчиком сигнала (смотрите B<signal>(7)). Семантика BSD эквивалентна вызову B<sigaction>(2) со следующими флагами:"

#. type: Plain text
#: man-pages/man2/signal.2:222
#, no-wrap
msgid "    sa.sa_flags = SA_RESTART;\n"
msgstr "    sa.sa_flags = SA_RESTART;\n"

#. type: Plain text
#: man-pages/man2/signal.2:224
msgid "The situation on Linux is as follows:"
msgstr "Ситуация в Linux:"

#. type: Plain text
#: man-pages/man2/signal.2:228
msgid "The kernel's B<signal>()  system call provides System\\ V semantics."
msgstr "Системный вызов ядра B<signal>() предоставляет семантику System\\ V."

#. type: Plain text
#: man-pages/man2/signal.2:244
msgid ""
"By default, in glibc 2 and later, the B<signal>()  wrapper function does not"
" invoke the kernel system call.  Instead, it calls B<sigaction>(2)  using "
"flags that supply BSD semantics.  This default behavior is provided as long "
"as the B<_BSD_SOURCE> feature test macro is defined.  By default, "
"B<_BSD_SOURCE> is defined; it is also implicitly defined if one defines "
"B<_GNU_SOURCE>, and can of course be explicitly defined."
msgstr "По умолчанию в glibc 2 и новее обёрточная функция B<signal>() не вызывает системный вызов ядра. Вместо этого она вызывает B<sigaction>(2) с флагами, которые активируют семантику BSD. Такое поведение по умолчанию устанавливается, если определён макрос тестирования свойств B<_BSD_SOURCE>. По умолчанию B<_BSD_SOURCE> определён; также, он неявно определён, если определён B<_GNU_SOURCE>, и, естественно, может быть определён вручную."

#.  System V semantics are also provided if one uses the separate
#.  .BR sysv_signal (3)
#.  function.
#. type: Plain text
#: man-pages/man2/signal.2:267
msgid ""
"On glibc 2 and later, if the B<_BSD_SOURCE> feature test macro is not "
"defined, then B<signal>()  provides System\\ V semantics.  (The default "
"implicit definition of B<_BSD_SOURCE> is not provided if one invokes "
"B<gcc>(1)  in one of its standard modes (I<-std=xxx> or I<-ansi>)  or "
"defines various other feature test macros such as B<_POSIX_SOURCE>, "
"B<_XOPEN_SOURCE>, or B<_SVID_SOURCE>; see B<feature_test_macros>(7).)"
msgstr "В glibc 2 и более новых, если не установлен макрос тестирования свойств B<_BSD_SOURCE>, то B<signal>() предоставляет семантику System\\ V (по умолчанию неявное определение B<_BSD_SOURCE> не происходит, если B<gcc>(1) вызывается в одном из своих стандартных режимов (I<-std=xxx> или I<-ansi>) или определяются другие макросы тестирования свойств, такие как B<_POSIX_SOURCE>, B<_XOPEN_SOURCE> или B<_SVID_SOURCE>; смотрите B<feature_test_macros>(7))."

#. type: Plain text
#: man-pages/man2/signal.2:278
msgid ""
"The B<signal>()  function in Linux libc4 and libc5 provide System\\ V "
"semantics.  If one on a libc5 system includes I<E<lt>bsd/signal.hE<gt>> "
"instead of I<E<lt>signal.hE<gt>>, then B<signal>()  provides BSD semantics."
msgstr "Функция B<signal>() в Linux libc4 и libc5 предоставляет семантику System\\ V. Если в некоторую систему с libc5 включён I<E<lt>bsd/signal.hE<gt>> вместо I<E<lt>signal.hE<gt>>, то B<signal>() предоставляет семантику BSD."

#. type: Plain text
#: man-pages/man2/signal.2:296
msgid ""
"B<kill>(1), B<alarm>(2), B<kill>(2), B<killpg>(2), B<pause>(2), "
"B<sigaction>(2), B<signalfd>(2), B<sigpending>(2), B<sigprocmask>(2), "
"B<sigsuspend>(2), B<bsd_signal>(3), B<raise>(3), B<siginterrupt>(3), "
"B<sigqueue>(3), B<sigsetops>(3), B<sigvec>(3), B<sysv_signal>(3), "
"B<signal>(7)"
msgstr "B<kill>(1), B<alarm>(2), B<kill>(2), B<killpg>(2), B<pause>(2), B<sigaction>(2), B<signalfd>(2), B<sigpending>(2), B<sigprocmask>(2), B<sigsuspend>(2), B<bsd_signal>(3), B<raise>(3), B<siginterrupt>(3), B<sigqueue>(3), B<sigsetops>(3), B<sigvec>(3), B<sysv_signal>(3), B<signal>(7)"

#. type: TH
#: man-pages/man2/set_mempolicy.2:27
#, no-wrap
msgid "SET_MEMPOLICY"
msgstr "SET_MEMPOLICY"

#. type: Plain text
#: man-pages/man2/set_mempolicy.2:30
msgid ""
"set_mempolicy - set default NUMA memory policy for a process and its "
"children"
msgstr "set_mempolicy - настраивает политику работы с памятью NUMA для процесса и его потомков"

#. type: Plain text
#: man-pages/man2/set_mempolicy.2:33
#, no-wrap
msgid "B<#include E<lt>numaif.hE<gt>>\n"
msgstr "B<#include E<lt>numaif.hE<gt>>\n"

#. type: Plain text
#: man-pages/man2/set_mempolicy.2:36
#, no-wrap
msgid ""
"B<long set_mempolicy(int >I<mode>B<, const unsigned long *>I<nodemask>B<,>\n"
"B<                   unsigned long >I<maxnode>B<);>\n"
msgstr "B<long set_mempolicy(int >I<mode>B<, const unsigned long *>I<nodemask>B<,>\nB<                   unsigned long >I<maxnode>B<);>\n"

#. type: Plain text
#: man-pages/man2/set_mempolicy.2:38
#, no-wrap
msgid "Link with I<-lnuma>.\n"
msgstr "Компонуется при указании параметра I<-lnuma>.\n"

#. type: Plain text
#: man-pages/man2/set_mempolicy.2:49
msgid ""
"B<set_mempolicy>()  sets the NUMA memory policy of the calling process, "
"which consists of a policy mode and zero or more nodes, to the values "
"specified by the I<mode>, I<nodemask> and I<maxnode> arguments."
msgstr "Вызов B<set_mempolicy>() устанавливает политику работы с памятью NUMA для вызывающего процесса, которая определяется режимом политики и нулём или более узлами (задаются в аргументах I<mode>, I<nodemask> и I<maxnode>)."

#. type: Plain text
#: man-pages/man2/set_mempolicy.2:54
msgid ""
"A NUMA machine has different memory controllers with different distances to "
"specific CPUs.  The memory policy defines from which node memory is "
"allocated for the process."
msgstr "Машина с NUMA имеет различные контроллеры памяти с различными расстояниями до определённых ЦП. Политикой памяти задаётся узел, на котором выделяется память для процесса."

#. type: Plain text
#: man-pages/man2/set_mempolicy.2:75
msgid ""
"This system call defines the default policy for the process.  The process "
"policy governs allocation of pages in the process's address space outside of"
" memory ranges controlled by a more specific policy set by B<mbind>(2).  The"
" process default policy also controls allocation of any pages for memory-"
"mapped files mapped using the B<mmap>(2)  call with the B<MAP_PRIVATE> flag "
"and that are only read [loaded] from by the process and of memory-mapped "
"files mapped using the B<mmap>(2)  call with the B<MAP_SHARED> flag, "
"regardless of the access type.  The policy is applied only when a new page "
"is allocated for the process.  For anonymous memory this is when the page is"
" first touched by the application."
msgstr "Этот системный вызов устанавливает в процессе политику по умолчанию. Политика процесса управляет выделением страниц в адресном пространстве процесса из областей памяти, которые не контролируются специальной политикой, заданной с помощью B<mbind>(2). Политикой процесса по умолчанию также контролируется выделение любых страниц для отображаемых в память файлов с помощью вызова B<mmap>(2) с флагом B<MAP_PRIVATE> (которые читаются (загружаются) только этим процессом) и для отображаемых в память файлов с помощью вызова B<mmap>(2) с флагом B<MAP_SHARED> (независимо от типа доступа). Эта политика применяется только когда процесс запрашивает выделение новой страницы. Для анонимной памяти это применяется, когда страница впервые затрагивается приложением."

#. type: Plain text
#: man-pages/man2/set_mempolicy.2:89
msgid ""
"The I<mode> argument must specify one of B<MPOL_DEFAULT>, B<MPOL_BIND>, "
"B<MPOL_INTERLEAVE>, or B<MPOL_PREFERRED>.  All modes except B<MPOL_DEFAULT> "
"require the caller to specify via the I<nodemask> argument one or more "
"nodes."
msgstr "В аргументе I<mode> должно быть указано B<MPOL_DEFAULT>, B<MPOL_BIND>, B<MPOL_INTERLEAVE> или B<MPOL_PREFERRED>. Для всех режимов, за исключением B<MPOL_DEFAULT>, в аргументе I<nodemask> требуется указать один или более узлов."

#. type: Plain text
#: man-pages/man2/set_mempolicy.2:97
msgid ""
"The I<mode> argument may also include an optional I<mode flag>.  The "
"supported I<mode flags> are:"
msgstr "Аргумент I<mode> также может содержать необязательный I<флаг режима>. Поддерживаемые I<флаги режима>:"

#. type: TP
#: man-pages/man2/set_mempolicy.2:97
#, no-wrap
msgid "B<MPOL_F_STATIC_NODES> (since Linux 2.6.26)"
msgstr "B<MPOL_F_STATIC_NODES> (начиная с Linux 2.6.26)"

#. type: Plain text
#: man-pages/man2/set_mempolicy.2:107
msgid ""
"A nonempty I<nodemask> specifies physical node ids.  Linux will not remap "
"the I<nodemask> when the process moves to a different cpuset context, nor "
"when the set of nodes allowed by the process's current cpuset context "
"changes."
msgstr "В аргументе I<nodemask> указываются идентификаторы физических узлов. Linux не будет перераспределять I<nodemask>, если процесс перемещается в другой контекст набора процессоров или когда изменяется набор узлов, который доступен процессу согласно текущему контексту набора процессоров."

#. type: TP
#: man-pages/man2/set_mempolicy.2:107
#, no-wrap
msgid "B<MPOL_F_RELATIVE_NODES> (since Linux 2.6.26)"
msgstr "B<MPOL_F_RELATIVE_NODES> (начиная с Linux 2.6.26)"

#. type: Plain text
#: man-pages/man2/set_mempolicy.2:113
msgid ""
"A nonempty I<nodemask> specifies node ids that are relative to the set of "
"node ids allowed by the process's current cpuset."
msgstr "В аргументе I<nodemask> указываются идентификаторы узлов из набора идентификаторов узлов, разрешённых процессу текущим контекстом набора процессоров."

#. type: Plain text
#: man-pages/man2/set_mempolicy.2:133
msgid ""
"I<nodemask> points to a bit mask of node IDs that contains up to I<maxnode> "
"bits.  The bit mask size is rounded to the next multiple of "
"I<sizeof(unsigned long)>, but the kernel will use bits only up to "
"I<maxnode>.  A NULL value of I<nodemask> or a I<maxnode> value of zero "
"specifies the empty set of nodes.  If the value of I<maxnode> is zero, the "
"I<nodemask> argument is ignored."
msgstr "В I<nodemask> указывается битовая маска идентификаторов узлов, которая может содержать до I<maxnode> бит. Размер битовой маски округляется до следующего значение кратного I<sizeof(unsigned long)>, но ядро будет использовать биты только до I<maxnode>. Значение NULL в I<nodemask> или I<maxnode> указывает на пустой набор узлов. Если значение I<maxnode> равно нулю, то аргумент I<nodemask> игнорируется."

#. type: Plain text
#: man-pages/man2/set_mempolicy.2:154
msgid ""
"Where a I<nodemask> is required, it must contain at least one node that is "
"on-line, allowed by the process's current cpuset context, [unless the "
"B<MPOL_F_STATIC_NODES> mode flag is specified], and contains memory.  If the"
" B<MPOL_F_STATIC_NODES> is set in I<mode> and a required I<nodemask> "
"contains no nodes that are allowed by the process's current cpuset context, "
"the memory policy reverts to I<local allocation>.  This effectively "
"overrides the specified policy until the process's cpuset context includes "
"one or more of the nodes specified by I<nodemask>."
msgstr "Если требуется аргумент I<nodemask>, то его значение должно содержать не менее одного работающего узла, разрешённого процессу из текущего контекста набора процессоров (если не указан флаг режима B<MPOL_F_STATIC_NODES>) и имеющего память Если в I<mode> установлен флаг B<MPOL_F_STATIC_NODES> и требуемое значение I<nodemask> не содержит узлов, разрешённых процессу из текущего контекста набора процессоров, то политика памяти возвращается обратно к I<локальному выделению>. Это эффективно заменяет указанную политику до тех пор, пока в текущий контекст набора процессоров процесса не добавится один или более узлов, указанных I<nodemask>."

#. type: Plain text
#: man-pages/man2/set_mempolicy.2:165
msgid ""
"The B<MPOL_DEFAULT> mode specifies that any nondefault process memory policy"
" be removed, so that the memory policy \"falls back\" to the system default "
"policy.  The system default policy is \"local allocation\"\\(emthat is, "
"allocate memory on the node of the CPU that triggered the allocation.  "
"I<nodemask> must be specified as NULL.  If the \"local node\" contains no "
"free memory, the system will attempt to allocate memory from a \"near by\" "
"node."
msgstr "Режим B<MPOL_DEFAULT> устанавливает, что любые политики памяти процесса, не равные политике по умолчанию, будут удалены, и политика памяти «вернётся» к системной политике по умолчанию. Системная политика по умолчанию — это «локальное выделение», то есть выделение памяти на узле с ЦП, на котором возник запрос выделения Значение I<nodemask> должно быть равно NULL. Если на «локальном узле» нет свободной памяти, то система попытается выделить память на «ближайшем» узле."

#. type: Plain text
#: man-pages/man2/set_mempolicy.2:182
msgid ""
"The B<MPOL_BIND> mode defines a strict policy that restricts memory "
"allocation to the nodes specified in I<nodemask>.  If I<nodemask> specifies "
"more than one node, page allocations will come from the node with the lowest"
" numeric node ID first, until that node contains no free memory.  "
"Allocations will then come from the node with the next highest node ID "
"specified in I<nodemask> and so forth, until none of the specified nodes "
"contain free memory.  Pages will not be allocated from any node not "
"specified in the I<nodemask>."
msgstr "Режим B<MPOL_BIND> устанавливает жёсткую политику, при которой выделение памяти выполняется только на узлах, заданных в I<nodemask>. Если в I<nodemask> указано более одного узла, то выделение страниц начнётся с узла с меньшим номером идентификатора и будет выполняться до тех пор, пока на нём не кончится свободная память. Затем выделение продолжится на узле со следующим большим номером идентификатора, указанного в I<nodemask>, и т.д. до тех пор, пока на всех указанных узлах не закончится свободная память. Страницы не будут выделяться на узлах, не указанных в I<nodemask>."

#.  NOTE:  the following sentence doesn't make sense in the context
#.  of set_mempolicy() -- no memory area specified.
#.  To be effective the memory area should be fairly large,
#.  at least 1MB or bigger.
#. type: Plain text
#: man-pages/man2/set_mempolicy.2:196
msgid ""
"B<MPOL_INTERLEAVE> interleaves page allocations across the nodes specified "
"in I<nodemask> in numeric node ID order.  This optimizes for bandwidth "
"instead of latency by spreading out pages and memory accesses to those pages"
" across multiple nodes.  However, accesses to a single page will still be "
"limited to the memory bandwidth of a single node."
msgstr "В режиме B<MPOL_INTERLEAVE> выделение страниц чередуется между узлами, указанными в I<nodemask>, согласно порядку номеров идентификаторов узлов. При этом происходит оптимизация полосы пропускания, а не задержки, так как происходит рассеивание страниц и доступ к этим страницам памяти, разносится по нескольким узлам. Однако доступ к отдельной странице по прежнему ограничен шириной канала с памятью на отдельном узле."

#. type: Plain text
#: man-pages/man2/set_mempolicy.2:213
msgid ""
"B<MPOL_PREFERRED> sets the preferred node for allocation.  The kernel will "
"try to allocate pages from this node first and fall back to \"near by\" "
"nodes if the preferred node is low on free memory.  If I<nodemask> specifies"
" more than one node ID, the first node in the mask will be selected as the "
"preferred node.  If the I<nodemask> and I<maxnode> arguments specify the "
"empty set, then the policy specifies \"local allocation\" (like the system "
"default policy discussed above)."
msgstr "В режиме B<MPOL_PREFERRED> задаётся предпочтительный узел для выделения памяти. Ядро будет пытаться сначала выделить страницы на этом узле и только после того как на предпочтительном узле не хватит памяти, попробует использовать «ближайшие» узлы. Если в I<nodemask> указано более одного идентификатора узла, то в качестве предпочтительного будет использован первый узел из маски. Если в аргументах I<nodemask> и I<maxnode> указан пустой набор, то политике предписывается использовать «локальное выделение» (как при системной политике по умолчанию, описанной ранее)."

#. type: Plain text
#: man-pages/man2/set_mempolicy.2:220
msgid ""
"The process memory policy is preserved across an B<execve>(2), and is "
"inherited by child processes created using B<fork>(2)  or B<clone>(2)."
msgstr "Политика памяти процесса сохраняется при вызове B<execve>(2) и наследуется дочерними процессами, созданными с помощью B<fork>(2) или B<clone>(2)."

#. type: Plain text
#: man-pages/man2/set_mempolicy.2:227
msgid ""
"On success, B<set_mempolicy>()  returns 0; on error, -1 is returned and "
"I<errno> is set to indicate the error."
msgstr "При успешном выполнении B<set_mempolicy>() возвращается 0; при ошибке возвращается -1, а в I<errno> содержится код ошибки."

#. type: Plain text
#: man-pages/man2/set_mempolicy.2:235
msgid ""
"Part of all of the memory range specified by I<nodemask> and I<maxnode> "
"points outside your accessible address space."
msgstr "Часть всего диапазона памяти, заданная в I<nodemask> и I<maxnode>, указывает за пределы доступного адресного пространства."

#. type: Plain text
#: man-pages/man2/set_mempolicy.2:272
msgid ""
"I<mode> is invalid.  Or, I<mode> is B<MPOL_DEFAULT> and I<nodemask> is "
"nonempty, or I<mode> is B<MPOL_BIND> or B<MPOL_INTERLEAVE> and I<nodemask> "
"is empty.  Or, I<maxnode> specifies more than a page worth of bits.  Or, "
"I<nodemask> specifies one or more node IDs that are greater than the maximum"
" supported node ID.  Or, none of the node IDs specified by I<nodemask> are "
"on-line and allowed by the process's current cpuset context, or none of the "
"specified nodes contain memory.  Or, the I<mode> argument specified both "
"B<MPOL_F_STATIC_NODES> and B<MPOL_F_RELATIVE_NODES>."
msgstr "Некорректное значение I<mode>. Или значение I<mode> равно B<MPOL_DEFAULT> и значение I<nodemask> не пусто, или I<mode> равно B<MPOL_BIND> или B<MPOL_INTERLEAVE> и значение I<nodemask> пусто. Или значение I<maxnode> больше чем количество значимых бит страницы. Или в I<nodemask> указан один или более идентификаторов узлов, значения которых больше чем максимальный поддерживаемый идентификатор узла. Или ни один из идентификаторов узлов, указанных в I<nodemask>, не работает или не разрешены для текущего набора контекста процесса, или ни один из узлов не содержит памяти. Или в аргументе I<mode> указаны B<MPOL_F_STATIC_NODES> и B<MPOL_F_RELATIVE_NODES> одновременно."

#. type: Plain text
#: man-pages/man2/set_mempolicy.2:279
msgid ""
"The B<set_mempolicy>(), system call was added to the Linux kernel in version"
" 2.6.7."
msgstr "Системный вызов B<set_mempolicy>() был добавлен в ядро Linux версии 2.6.7."

#. type: Plain text
#: man-pages/man2/set_mempolicy.2:286
msgid ""
"Process policy is not remembered if the page is swapped out.  When such a "
"page is paged back in, it will use the policy of the process or memory range"
" that is in effect at the time the page is allocated."
msgstr "Политика процесса не запоминается, если страница помещается в пространство подкачки. Когда страница возвращается в основную память, будет использована политика процесса или диапазона памяти, действующая на момент выделения страницы."

#. type: Plain text
#: man-pages/man2/set_mempolicy.2:289
msgid "For information on library support, see B<numa>(7)."
msgstr "Информация о библиотеке доступна в B<numa>(7)."

#. type: Plain text
#: man-pages/man2/set_mempolicy.2:297
msgid ""
"B<get_mempolicy>(2), B<getcpu>(2), B<mbind>(2), B<mmap>(2), B<numa>(3), "
"B<cpuset>(7), B<numa>(7), B<numactl>(8)"
msgstr "B<get_mempolicy>(2), B<getcpu>(2), B<mbind>(2), B<mmap>(2), B<numa>(3), B<cpuset>(7), B<numa>(7), B<numactl>(8)"

#. type: TH
#: man-pages/man2/sched_setparam.2:30
#, no-wrap
msgid "SCHED_SETPARAM"
msgstr "SCHED_SETPARAM"

#. type: TH
#: man-pages/man2/sched_setparam.2:30
#, no-wrap
msgid "2014-05-11"
msgstr "2014-05-11"

#. type: Plain text
#: man-pages/man2/sched_setparam.2:33
msgid "sched_setparam, sched_getparam - set and get scheduling parameters"
msgstr "sched_setparam, sched_getparam - получает и устанавливает параметры планирования"

#. type: Plain text
#: man-pages/man2/sched_setparam.2:38
#, no-wrap
msgid ""
"B<int sched_setparam(pid_t >I<pid>B<, const struct sched_param "
"*>I<param>B<);>\n"
msgstr "B<int sched_setparam(pid_t >I<pid>B<, const struct sched_param *>I<param>B<);>\n"

#. type: Plain text
#: man-pages/man2/sched_setparam.2:40
#, no-wrap
msgid ""
"B<int sched_getparam(pid_t >I<pid>B<, struct sched_param *>I<param>B<);>\n"
msgstr "B<int sched_getparam(pid_t >I<pid>B<, struct sched_param *>I<param>B<);>\n"

#. type: Plain text
#: man-pages/man2/sched_setparam.2:46
#, no-wrap
msgid ""
"B<struct sched_param {\n"
"    ...\n"
"    int >I<sched_priority>B<;\n"
"    ...\n"
"};>\n"
msgstr "B<struct sched_param {\n    ...\n    int >I<sched_priority>B<;\n    ...\n};>\n"

#. type: Plain text
#: man-pages/man2/sched_setparam.2:60
msgid ""
"B<sched_setparam>()  sets the scheduling parameters associated with the "
"scheduling policy for the process identified by I<pid>.  If I<pid> is zero, "
"then the parameters of the calling process are set.  The interpretation of "
"the argument I<param> depends on the scheduling policy of the process "
"identified by I<pid>.  See B<sched>(7)  for a description of the scheduling "
"policies supported under Linux."
msgstr "Вызов B<sched_setparam>() устанавливает параметры планирования процесса с идентификатором I<pid> в соответствии с его политикой планирования. Если I<pid> равен нулю, то устанавливаются параметры вызывающего процесса. Тип и значение аргумента I<param> зависит от политики планирования, назначенной процессу с идентификатором I<pid>. Описание алгоритмов планирования, поддерживаемых в Linux, смотрите в B<sched>(7)."

#. type: Plain text
#: man-pages/man2/sched_setparam.2:66
msgid ""
"B<sched_getparam>()  retrieves the scheduling parameters for the process "
"identified by I<pid>.  If I<pid> is zero, then the parameters of the calling"
" process are retrieved."
msgstr "Вызов B<sched_getparam>() получает текущие параметры планирования процесса с I<pid>. Если I<pid> равен нулю, то возвращаются параметры вызывающего процесса."

#. type: Plain text
#: man-pages/man2/sched_setparam.2:75
msgid ""
"B<sched_setparam>()  checks the validity of I<param> for the scheduling "
"policy of the thread.  The value I<param-E<gt>sched_priority> must lie "
"within the range given by B<sched_get_priority_min>(2)  and "
"B<sched_get_priority_max>(2)."
msgstr "Вызов B<sched_setparam>() проверяет соответствие значения аргумента I<param> политике планирования заданной нити. Значение I<param-E<gt>sched_priority> должно находиться в диапазоне от B<sched_get_priority_min>(2) до B<sched_get_priority_max>(2)."

#. type: Plain text
#: man-pages/man2/sched_setparam.2:79
msgid ""
"For a discussion of the privileges and resource limits related to scheduling"
" priority and policy, see B<sched>(7)."
msgstr "Описание привилегий и ограничений ресурсов, связанных с планирование и алгоритмами, смотрите в B<sched>(7)."

#. type: Plain text
#: man-pages/man2/sched_setparam.2:87
msgid ""
"POSIX systems on which B<sched_setparam>()  and B<sched_getparam>()  are "
"available define B<_POSIX_PRIORITY_SCHEDULING> in I<E<lt>unistd.hE<gt>>."
msgstr "В POSIX-системах, в которых существуют вызовы B<sched_setparam>() и B<sched_getparam>(), в I<E<lt>unistd.hE<gt>> определён макрос B<_POSIX_PRIORITY_SCHEDULING>."

#. type: Plain text
#: man-pages/man2/sched_setparam.2:96
msgid ""
"On success, B<sched_setparam>()  and B<sched_getparam>()  return 0.  On "
"error, -1 is returned, and I<errno> is set appropriately."
msgstr "При успешном выполнении B<sched_setparam>() и B<sched_getparam>() возвращают 0. В случае ошибки возвращается -1, а I<errno> устанавливается в соответствующее значение."

#. type: Plain text
#: man-pages/man2/sched_setparam.2:104
msgid "Invalid arguments: I<param> is NULL or I<pid> is negative"
msgstr "Некорректные аргументы: значение I<pid> отрицательно или I<param> равно NULL"

#. type: Plain text
#: man-pages/man2/sched_setparam.2:109
msgid ""
"(B<sched_setparam>())  The argument I<param> does not make sense for the "
"current scheduling policy."
msgstr "(B<sched_setparam>()) Аргумент I<param> не соответствует текущей политике планирования."

#. type: Plain text
#: man-pages/man2/sched_setparam.2:116
msgid ""
"(B<sched_setparam>())  The calling process does not have appropriate "
"privileges (Linux: does not have the B<CAP_SYS_NICE> capability)."
msgstr "(B<sched_setparam>()) Вызывающий процесс не имеет достаточного количества прав (Linux: не имеет мандата B<CAP_SYS_NICE>)."

#. type: Plain text
#: man-pages/man2/sched_setparam.2:119
msgid "The process whose ID is I<pid> could not be found."
msgstr "Процесс с идентификатором I<pid> не найден."

#. type: Plain text
#: man-pages/man2/sched_setparam.2:127
msgid ""
"Scheduling parameters are in fact per-thread attributes on Linux; see "
"B<sched>(7)."
msgstr "Параметры планирования в Linux, фактически, являются атрибутами нитей; смотрите B<sched>(7)."

#. type: Plain text
#: man-pages/man2/sched_setparam.2:141
msgid ""
"B<getpriority>(2), B<nice>(2), B<sched_get_priority_max>(2), "
"B<sched_get_priority_min>(2), B<sched_getaffinity>(2), "
"B<sched_getscheduler>(2), B<sched_setaffinity>(2), B<sched_setscheduler>(2),"
" B<sched_setattr>(2), B<setpriority>(2), B<capabilities>(7), B<sched>(7)"
msgstr "B<getpriority>(2), B<nice>(2), B<sched_get_priority_max>(2), B<sched_get_priority_min>(2), B<sched_getaffinity>(2), B<sched_getscheduler>(2), B<sched_setaffinity>(2), B<sched_setscheduler>(2), B<sched_setattr>(2), B<setpriority>(2), B<capabilities>(7), B<sched>(7)"

#. type: TH
#: man-pages/man2/sync.2:36
#, no-wrap
msgid "SYNC"
msgstr "SYNC"

#. type: Plain text
#: man-pages/man2/sync.2:39
msgid "sync, syncfs - commit buffer cache to disk"
msgstr "sync, syncfs - записывает буферный кэш на диск"

#. type: Plain text
#: man-pages/man2/sync.2:43
msgid "B<void sync(void);>"
msgstr "B<void sync(void);>"

#. type: Plain text
#: man-pages/man2/sync.2:45
msgid "B<int syncfs(int >I<fd>B<);>"
msgstr "B<int syncfs(int >I<fd>B<);>"

#. type: Plain text
#: man-pages/man2/sync.2:52
msgid "B<sync>():"
msgstr "B<sync>():"

#. type: Plain text
#: man-pages/man2/sync.2:60
msgid "B<syncfs>():"
msgstr "B<syncfs>():"

#. type: Plain text
#: man-pages/man2/sync.2:63
msgid "_GNU_SOURCE"
msgstr "_GNU_SOURCE"

#. type: Plain text
#: man-pages/man2/sync.2:69
msgid ""
"B<sync>()  causes all buffered modifications to file metadata and data to be"
" written to the underlying filesystems."
msgstr "Вызов B<sync>() приводит к записи в файловую систему всех изменений данных и метаданных файла, хранящихся в буфере."

#. type: Plain text
#: man-pages/man2/sync.2:76
msgid ""
"B<syncfs>()  is like B<sync>(), but synchronizes just the filesystem "
"containing file referred to by the open file descriptor I<fd>."
msgstr "Вызов B<syncfs>() подобен B<sync>(), но синхронизирует только файловую систему, содержащую файл, на который указывает открытый файловый дескриптор I<fd>."

#. type: Plain text
#: man-pages/man2/sync.2:82
msgid ""
"B<syncfs>()  returns 0 on success; on error, it returns -1 and sets I<errno>"
" to indicate the error."
msgstr "При нормальном завершении работы B<syncfs>() возвращает 0. В случае ошибки возвращается -1, а I<errno> устанавливается в соответствующее значение."

#. type: Plain text
#: man-pages/man2/sync.2:85
msgid "B<sync>()  is always successful."
msgstr "Вызов B<sync>() всегда выполняется без ошибок."

#. type: Plain text
#: man-pages/man2/sync.2:88
msgid "B<syncfs>()  can fail for at least the following reason:"
msgstr "Вызов B<syncfs>() может завершиться с ошибкой, по крайней мере, по следующей причине:"

#. type: Plain text
#: man-pages/man2/sync.2:96
msgid ""
"B<syncfs>()  first appeared in Linux 2.6.39; library support was added to "
"glibc in version 2.14."
msgstr "Системный вызов B<syncfs>() впервые появился в Linux 2.6.39; поддержка в glibc добавлена в версии 2.14."

#. type: Plain text
#: man-pages/man2/sync.2:99
msgid "B<sync>(): SVr4, 4.3BSD, POSIX.1-2001."
msgstr "B<sync>(): SVr4, 4.3BSD, POSIX.1-2001."

#. type: Plain text
#: man-pages/man2/sync.2:102
msgid "B<syncfs>()  is Linux-specific."
msgstr "B<syncfs>() есть только в Linux."

#. type: Plain text
#: man-pages/man2/sync.2:111
msgid ""
"Since glibc 2.2.2 the Linux prototype for B<sync>()  is as listed above, "
"following the various standards.  In libc4, libc5, and glibc up to 2.2.1 it "
"was \"int sync(void)\", and B<sync>()  always returned 0."
msgstr "Начиная с glibc 2.2.2 Linux-прототип B<sync>() стал соответствовать различным стандартам. В libc4, libc5 и glibc до версии 2.2.1, он объявлялся как «int sync(void)» и вызов B<sync>() всегда возвращал 0."

#. type: Plain text
#: man-pages/man2/sync.2:119
msgid ""
"According to the standard specification (e.g., POSIX.1-2001), B<sync>()  "
"schedules the writes, but may return before the actual writing is done.  "
"However, since version 1.3.20 Linux does actually wait.  (This still does "
"not guarantee data integrity: modern disks have large caches.)"
msgstr "В соответствии со стандартной спецификацией (например POSIX.1-2001), B<sync>() только планирует запись, и может закончить работу до того как запись будет на самом деле произведена. Однако в Linux, начиная с версии 1.3.20, выполняется ожидание завершения записи (это всё равно не гарантирует целостность данных: современные диски оснащаются большими кэшами)."

#. type: Plain text
#: man-pages/man2/sync.2:123
msgid "B<bdflush>(2), B<fdatasync>(2), B<fsync>(2), B<sync>(8)"
msgstr "B<bdflush>(2), B<fdatasync>(2), B<fsync>(2), B<sync>(8)"

#. type: TH
#: man-pages/man2/semop.2:35
#, no-wrap
msgid "SEMOP"
msgstr "SEMOP"

#. type: Plain text
#: man-pages/man2/semop.2:38
msgid "semop, semtimedop - System V semaphore operations"
msgstr "semop, semtimedop - операции с семафорами System V"

#. type: Plain text
#: man-pages/man2/semop.2:45
#, no-wrap
msgid ""
"B<int semop(int >I<semid>B<, struct sembuf *>I<sops>B<, size_t "
">I<nsops>B<);>\n"
msgstr "B<int semop(int >I<semid>B<, struct sembuf *>I<sops>B<, size_t >I<nsops>B<);>\n"

#. type: Plain text
#: man-pages/man2/semop.2:48
#, no-wrap
msgid ""
"B<int semtimedop(int >I<semid>B<, struct sembuf *>I<sops>B<, size_t >I<nsops>B<,>\n"
"B<               const struct timespec *>I<timeout>B<);>\n"
msgstr "B<int semtimedop(int >I<semid>B<, struct sembuf *>I<sops>B<, size_t >I<nsops>B<,>\nB<               const struct timespec *>I<timeout>B<);>\n"

#. type: Plain text
#: man-pages/man2/semop.2:57
msgid "B<semtimedop>(): _GNU_SOURCE"
msgstr "B<semtimedop>(): _GNU_SOURCE"

#. type: Plain text
#: man-pages/man2/semop.2:60
msgid ""
"Each semaphore in a System\\ V semaphore set has the following associated "
"values:"
msgstr "С каждым семафором в наборе семафоров System\\ V связаны следующие значения:"

#. type: Plain text
#: man-pages/man2/semop.2:67
#, no-wrap
msgid ""
"unsigned short  semval;   /* semaphore value */\n"
"unsigned short  semzcnt;  /* # waiting for zero */\n"
"unsigned short  semncnt;  /* # waiting for increase */\n"
"pid_t           sempid;   /* ID of process that did last op */\n"
msgstr "unsigned short  semval;   /* значение семафора */\nunsigned short  semzcnt;  /* # ожидает ноль */\nunsigned short  semncnt;  /* # ожидает увеличения */\npid_t           sempid;   /* ID процесса, выполнявшего последнюю \n                             операцию */\n"

#. type: Plain text
#: man-pages/man2/semop.2:81
msgid ""
"B<semop>()  performs operations on selected semaphores in the set indicated "
"by I<semid>.  Each of the I<nsops> elements in the array pointed to by "
"I<sops> specifies an operation to be performed on a single semaphore.  The "
"elements of this structure are of type I<struct sembuf>, containing the "
"following members:"
msgstr "Вызов B<semop>() производит операции над выбранными семафорами из набора семафоров I<semid>. В каждом из I<nsops> элементов массиве I<sops> указывается выполняемая операция над отдельным семафором. Элементы этой структуры имеют тип I<struct sembuf>, который содержит поля:"

#. type: Plain text
#: man-pages/man2/semop.2:87
#, no-wrap
msgid ""
"unsigned short sem_num;  /* semaphore number */\n"
"short          sem_op;   /* semaphore operation */\n"
"short          sem_flg;  /* operation flags */\n"
msgstr "unsigned short sem_num;  /* номер семафора */\nshort          sem_op;   /* операция над семафором */\nshort          sem_flg;  /* флаги операции */\n"

#. type: Plain text
#: man-pages/man2/semop.2:99
msgid ""
"Flags recognized in I<sem_flg> are B<IPC_NOWAIT> and B<SEM_UNDO>.  If an "
"operation specifies B<SEM_UNDO>, it will be automatically undone when the "
"process terminates."
msgstr "Флаги в I<sem_flg> могут иметь значения B<IPC_NOWAIT> и B<SEM_UNDO>. Если указан флаг B<SEM_UNDO>, то при завершении процесса будет выполнена откат операции."

#. type: Plain text
#: man-pages/man2/semop.2:114
msgid ""
"The set of operations contained in I<sops> is performed in I<array order>, "
"and I<atomically>, that is, the operations are performed either as a "
"complete unit, or not at all.  The behavior of the system call if not all "
"operations can be performed immediately depends on the presence of the "
"B<IPC_NOWAIT> flag in the individual I<sem_flg> fields, as noted below."
msgstr "Набор операций из I<sops> выполняется в I<порядке появления в массиве> и I<является атомарным>, то есть выполняются или все операции, или ни одной. Поведение системного вызова при обнаружении невозможности немедленного выполнения операций зависит от наличия флага B<IPC_NOWAIT> в полях I<sem_flg> отдельных операций, как это описано далее."

#. type: Plain text
#: man-pages/man2/semop.2:121
msgid ""
"Each operation is performed on the I<sem_num>-th semaphore of the semaphore "
"set, where the first semaphore of the set is numbered 0.  There are three "
"types of operation, distinguished by the value of I<sem_op>."
msgstr "Каждая операция выполняется над I<sem_num>-тым семафором из набора, где первый семафор имеет номер 0. Есть три типа операций, различающихся значением I<sem_op>."

#. type: Plain text
#: man-pages/man2/semop.2:136
msgid ""
"If I<sem_op> is a positive integer, the operation adds this value to the "
"semaphore value (I<semval>).  Furthermore, if B<SEM_UNDO> is specified for "
"this operation, the system subtracts the value I<sem_op> from the semaphore "
"adjustment (I<semadj>)  value for this semaphore.  This operation can always"
" proceed\\(emit never forces a thread to wait.  The calling process must "
"have alter permission on the semaphore set."
msgstr "Если значение I<sem_op> — положительное целое число, то оно добавляется к значению семафора (I<semval>). Если для операции стоит флаг B<SEM_UNDO>, то система вычитает значение I<sem_op> из значения регулировки (I<semadj>) семафора. Эта операция выполняется всегда и не переводит нить в режим ожидания. Вызывающий процесс должен иметь права на изменение набора семафоров."

#. type: Plain text
#: man-pages/man2/semop.2:161
msgid ""
"If I<sem_op> is zero, the process must have read permission on the semaphore"
" set.  This is a \"wait-for-zero\" operation: if I<semval> is zero, the "
"operation can immediately proceed.  Otherwise, if B<IPC_NOWAIT> is specified"
" in I<sem_flg>, B<semop>()  fails with I<errno> set to B<EAGAIN> (and none "
"of the operations in I<sops> is performed).  Otherwise, I<semzcnt> (the "
"count of threads waiting until this semaphore's value becomes zero)  is "
"incremented by one and the thread sleeps until one of the following occurs:"
msgstr "Если значение I<sem_op> равно нулю, то процесс должен иметь права на чтение набора семафоров. Эта операция «ожидания нуля»: если I<semval> равно нулю, то операция может выполнится сразу. Иначе, если в поле семафора I<sem_flg> указан флаг B<IPC_NOWAIT>, то B<semop>() завершается с ошибкой и I<errno> присваивается значение B<EAGAIN> (и ни одна операция из I<sops> не выполняется). Или же I<semzcnt> (счётчик нитей, ожидающих пока значение семафора не сравнялось с нулём) увеличивается на единицу, а нить переходит в режим ожидания пока не случится одно из:"

#. type: IP
#: man-pages/man2/semop.2:161 man-pages/man2/semop.2:166
#: man-pages/man2/semop.2:174 man-pages/man2/semop.2:184
#: man-pages/man2/semop.2:237 man-pages/man2/semop.2:242
#: man-pages/man2/semop.2:249 man-pages/man2/semop.2:259
#, no-wrap
msgid "\\(bu"
msgstr "\\(bu"

#. type: Plain text
#: man-pages/man2/semop.2:166
msgid ""
"I<semval> becomes 0, at which time the value of I<semzcnt> is decremented."
msgstr "Значение I<semval> станет равным 0, тогда значение I<semzcnt> уменьшается."

#. type: Plain text
#: man-pages/man2/semop.2:174
msgid ""
"The semaphore set is removed: B<semop>()  fails, with I<errno> set to "
"B<EIDRM>."
msgstr "Набор семафоров удалится: B<semop>() завершается с ошибкой, а I<errno> присваивается значение B<EIDRM>."

#. type: Plain text
#: man-pages/man2/semop.2:184
msgid ""
"The calling thread catches a signal: the value of I<semzcnt> is decremented "
"and B<semop>()  fails, with I<errno> set to B<EINTR>."
msgstr "Вызывающая нить получит сигнал: значение I<semncnt> уменьшается и B<semop>() завершается с ошибкой, а I<errno> присваивается значение B<EINTR>."

#. type: Plain text
#: man-pages/man2/semop.2:195
msgid ""
"The time limit specified by I<timeout> in a B<semtimedop>()  call expires: "
"B<semop>()  fails, with I<errno> set to B<EAGAIN>."
msgstr "Истечёт лимит времени I<timeout>, определённый в вызове B<semtimedop>(): B<semop>() завершается с ошибкой, а I<errno> присваивается значение B<EAGAIN>."

#. type: Plain text
#: man-pages/man2/semop.2:237
msgid ""
"If I<sem_op> is less than zero, the process must have alter permission on "
"the semaphore set.  If I<semval> is greater than or equal to the absolute "
"value of I<sem_op>, the operation can proceed immediately: the absolute "
"value of I<sem_op> is subtracted from I<semval>, and, if B<SEM_UNDO> is "
"specified for this operation, the system adds the absolute value of "
"I<sem_op> to the semaphore adjustment (I<semadj>)  value for this semaphore."
"  If the absolute value of I<sem_op> is greater than I<semval>, and "
"B<IPC_NOWAIT> is specified in I<sem_flg>, B<semop>()  fails, with I<errno> "
"set to B<EAGAIN> (and none of the operations in I<sops> is performed).  "
"Otherwise, I<semncnt> (the counter of threads waiting for this semaphore's "
"value to increase)  is incremented by one and the thread sleeps until one of"
" the following occurs:"
msgstr "Если значение I<sem_op> меньше нуля, то процесс должен иметь права на изменение набора семафоров. Если значение I<semval> больше или равно абсолютному значению I<sem_op>, то операция может выполнятся сразу: абсолютное значение I<sem_op> вычитается из I<semval>, и, если для этой операции установлен флаг B<SEM_UNDO>, система добавляет абсолютное значение I<sem_op> к значению регулировки (I<semadj>) семафора. Если абсолютное значение I<sem_op> больше I<semval>, и в I<sem_flg> указан B<IPC_NOWAIT>, то B<semop>() завершается с ошибкой, а I<errno> присваивается значение B<EAGAIN> (и ни одна операция из I<sops> не выполняется). Иначе I<semncnt> (счётчик нитей, ожидающих увеличения значения семафора) увеличивается на единицу, а нить переходит в режим ожидания пока не случится одно из:"

#. type: Plain text
#: man-pages/man2/semop.2:242
msgid ""
"I<semval> becomes greater than or equal to the absolute value of I<sem_op>: "
"the operation now proceeds, as described above."
msgstr "I<semval> становится больше или равно абсолютному значению I<sem_op>: операция продолжается как описано выше."

#. type: Plain text
#: man-pages/man2/semop.2:249
msgid ""
"The semaphore set is removed from the system: B<semop>()  fails, with "
"I<errno> set to B<EIDRM>."
msgstr "Набор семафоров удалится из системы: B<semop>() завершается с ошибкой, а I<errno> присваивается значение B<EIDRM>."

#. type: Plain text
#: man-pages/man2/semop.2:259
msgid ""
"The calling thread catches a signal: the value of I<semncnt> is decremented "
"and B<semop>()  fails, with I<errno> set to B<EINTR>."
msgstr "Вызывающая нить получит сигнал: значение I<semncnt> уменьшается и B<semop>() завершается с ошибкой, а I<errno> присваивается значение B<EINTR>."

#. type: Plain text
#: man-pages/man2/semop.2:268
msgid ""
"The time limit specified by I<timeout> in a B<semtimedop>()  call expires: "
"the system call fails, with I<errno> set to B<EAGAIN>."
msgstr "Истечёт лимит времени I<timeout>, определённый в вызове B<semtimedop>(): системный вызов завершается с ошибкой, а I<errno> присваивается значение B<EAGAIN>."

#.  and
#.  .I sem_ctime
#. type: Plain text
#: man-pages/man2/semop.2:279
msgid ""
"On successful completion, the I<sempid> value for each semaphore specified "
"in the array pointed to by I<sops> is set to the caller's process ID.  In "
"addition, the I<sem_otime> is set to the current time."
msgstr "При успешном выполнении значение I<sempid> для каждого семафора, указанного в массиве, на который указывает I<sops>, устанавливается равным идентификатору вызывающего процесса. Также I<sem_otime> присваивается значение текущего времени."

#. type: Plain text
#: man-pages/man2/semop.2:309
msgid ""
"B<semtimedop>()  behaves identically to B<semop>()  except that in those "
"cases where the calling thread would sleep, the duration of that sleep is "
"limited by the amount of elapsed time specified by the I<timespec> structure"
" whose address is passed in the I<timeout> argument.  (This sleep interval "
"will be rounded up to the system clock granularity, and kernel scheduling "
"delays mean that the interval may overrun by a small amount.)  If the "
"specified time limit has been reached, B<semtimedop>()  fails with I<errno> "
"set to B<EAGAIN> (and none of the operations in I<sops> is performed).  If "
"the I<timeout> argument is NULL, then B<semtimedop>()  behaves exactly like "
"B<semop>()."
msgstr "Системный вызов B<semtimedop>() ведёт себя идентично B<semop>(), за  исключением  того, что в случаях, когда вызывающая нить будет спать, длительность этого сна ограничена количеством времени, определяемым структурой I<timespec>, чей адрес передаётся в аргументе I<timeout>. Данное  значение интервала будет округлено до точности системных часов, а из-за задержки при планировании в ядре блокирующий интервал будет немного больше. Если достигнут указанный лимит времени, то B<semtimedop>() завершится с ошибкой, а I<errno> устанавливается в B<EAGAIN> (и ни одна из операций в I<sops> не выполняется). Если значение аргумента I<timeout> равно NULL, то B<semtimedop>() ведёт себя аналогично B<semop>()."

#. type: Plain text
#: man-pages/man2/semop.2:319
msgid ""
"If successful, B<semop>()  and B<semtimedop>()  return 0; otherwise they "
"return -1 with I<errno> indicating the error."
msgstr "При успешном выполнении B<semop>() и B<semtimedop>() возвращается 0; иначе возвращается -1, а переменной I<errno> присваивается номер ошибки."

#. type: TP
#: man-pages/man2/semop.2:323
#, no-wrap
msgid "B<E2BIG>"
msgstr "B<E2BIG>"

#. type: Plain text
#: man-pages/man2/semop.2:331
msgid ""
"The argument I<nsops> is greater than B<SEMOPM>, the maximum number of "
"operations allowed per system call."
msgstr "Значение аргумента I<nsops> больше B<SEMOPM>, максимального количества операций, которое может выполнить один системный вызов."

#. type: Plain text
#: man-pages/man2/semop.2:338
msgid ""
"The calling process does not have the permissions required to perform the "
"specified semaphore operations, and does not have the B<CAP_IPC_OWNER> "
"capability."
msgstr "Вызывающий процесс не имеет прав, требуемых для выполнения указанных операций над семафорами, и не имеет мандата B<CAP_IPC_OWNER>."

#. type: Plain text
#: man-pages/man2/semop.2:347
msgid ""
"An operation could not proceed immediately and either B<IPC_NOWAIT> was "
"specified in I<sem_flg> or the time limit specified in I<timeout> expired."
msgstr "Операция не может быть выполнена немедленно и, либо B<IPC_NOWAIT> был указан в I<sem_flg>, либо истекло время лимита, определённое в I<timeout>."

#. type: Plain text
#: man-pages/man2/semop.2:354
msgid ""
"An address specified in either the I<sops> or the I<timeout> argument isn't "
"accessible."
msgstr "Адрес, указанный в I<sops> или I<timeout>, не доступен."

#. type: TP
#: man-pages/man2/semop.2:354
#, no-wrap
msgid "B<EFBIG>"
msgstr "B<EFBIG>"

#. type: Plain text
#: man-pages/man2/semop.2:360
msgid ""
"For some operation the value of I<sem_num> is less than 0 or greater than or"
" equal to the number of semaphores in the set."
msgstr "Для некоторых операций значение I<sem_num> меньше нуля или больше или равно количеству семафоров в наборе."

#. type: Plain text
#: man-pages/man2/semop.2:367
msgid ""
"While blocked in this system call, the thread caught a signal; see "
"B<signal>(7)."
msgstr "Нить, находясь в режиме ожидания, получила сигнал; смотрите B<signal>(7)."

#. type: Plain text
#: man-pages/man2/semop.2:374
msgid ""
"The semaphore set doesn't exist, or I<semid> is less than zero, or I<nsops> "
"has a nonpositive value."
msgstr "Набор семафоров не существует, или значение I<semid> меньше нуля, или I<nsops> имеет не положительное значение."

#. type: Plain text
#: man-pages/man2/semop.2:382
msgid ""
"The I<sem_flg> of some operation specified B<SEM_UNDO> and the system does "
"not have enough memory to allocate the undo structure."
msgstr "Для некоторых операций в поле I<sem_flg> задан флаг B<SEM_UNDO>, и система не может выделить достаточно памяти для структуры откатов."

#. type: Plain text
#: man-pages/man2/semop.2:390
msgid ""
"For some operation I<sem_op+semval> is greater than B<SEMVMX>, the "
"implementation dependent maximum value for I<semval>."
msgstr "Для некоторых операций I<sem_op+semval> больше чем B<SEMVMX>, максимального значения I<semval> (зависит от реализации)."

#. type: Plain text
#: man-pages/man2/semop.2:397
msgid ""
"B<semtimedop>()  first appeared in Linux 2.5.52, and was subsequently "
"backported into kernel 2.4.22.  Glibc support for B<semtimedop>()  first "
"appeared in version 2.3.3."
msgstr "Вызов B<semtimedop>() впервые появился в Linux 2.5.52, а затем был перенесён в ядро версии 2.4.22. Поддержка в glibc для B<semtimedop>() впервые появилась в версии 2.3.3."

#. type: Plain text
#: man-pages/man2/semop.2:421
msgid ""
"The I<sem_undo> structures of a process aren't inherited by the child "
"produced by B<fork>(2), but they are inherited across an B<execve>(2)  "
"system call."
msgstr "Структуры процесса I<sem_undo> не наследуются потомками, созданными через B<fork>(2), но они наследуются при выполнении системного вызова B<execve>(2)."

#. type: Plain text
#: man-pages/man2/semop.2:427
msgid ""
"B<semop>()  is never automatically restarted after being interrupted by a "
"signal handler, regardless of the setting of the B<SA_RESTART> flag when "
"establishing a signal handler."
msgstr "Вызов B<semop>() никогда автоматически не перезапускается после прерывания обработчиком сигнала, независимо от установки флага B<SA_RESTART> при настройке обработчика сигнала."

#. type: Plain text
#: man-pages/man2/semop.2:452
msgid ""
"A semaphore adjustment (I<semadj>)  value is a per-process, per-semaphore "
"integer that is the negated sum of all operations performed on a semaphore "
"specifying the B<SEM_UNDO> flag.  Each process has a list of I<semadj> "
"values\\(emone value for each semaphore on which it has operated using "
"B<SEM_UNDO>.  When a process terminates, each of its per-semaphore I<semadj>"
" values is added to the corresponding semaphore, thus undoing the effect of "
"that process's operations on the semaphore (but see BUGS below).  When a "
"semaphore's value is directly set using the B<SETVAL> or B<SETALL> request "
"to B<semctl>(2), the corresponding I<semadj> values in all processes are "
"cleared."
msgstr "Значение регулировки семафора (I<semadj>) есть в каждом процессе. Это целое число — простой (отрицательный) счётчик всех операций над семафорами, для которых установлен флаг B<SEM_UNDO>. В каждом процессе есть список значений I<semadj> — по одному значению на каждый семафор, у которых установлен флаг B<SEM_UNDO>. При завершении процесса. каждое из значений I<semadj> семафора добавляется к соответствующему семафору, достигая таким образом эффекта выполнения операций процесса над семафорами (но смотрите раздел ДЕФЕКТЫ). Когда значение семафора явно устанавливается с помощью запроса B<SETVAL> или B<SETALL> вызовом B<semctl>(2), то соответствующие значения I<semadj> во всех процессах очищаются."

#. type: Plain text
#: man-pages/man2/semop.2:457
msgid ""
"The I<semval>, I<sempid>, I<semzcnt>, and I<semnct> values for a semaphore "
"can all be retrieved using appropriate B<semctl>(2)  calls."
msgstr "Значения I<semval>, I<sempid>, I<semzcnt> и I<semnct> семафора можно получить с помощью соответствующих вызовов B<semctl>(2)."

#. type: Plain text
#: man-pages/man2/semop.2:461
msgid ""
"The following limits on semaphore set resources affect the B<semop>()  call:"
msgstr "Ниже приведены лимиты ресурсов наборов семафоров, влияющие на вызов B<semop>():"

#. type: TP
#: man-pages/man2/semop.2:461
#, no-wrap
msgid "B<SEMOPM>"
msgstr "B<SEMOPM>"

#.  This /proc file is not available in Linux 2.2 and earlier -- MTK
#. type: Plain text
#: man-pages/man2/semop.2:469
msgid ""
"Maximum number of operations allowed for one B<semop>()  call (32)  (on "
"Linux, this limit can be read and modified via the third field of "
"I</proc/sys/kernel/sem>)."
msgstr "Наибольшее количество операций для одного вызова B<semop>() (32) (в Linux это ограничение можно получать и изменять через третье поле I</proc/sys/kernel/sem>)."

#. type: Plain text
#: man-pages/man2/semop.2:474
msgid ""
"Maximum allowable value for I<semval>: implementation dependent (32767)."
msgstr "Максимально допустимое значение I<semval>: зависит от реализации (32767)."

#. type: Plain text
#: man-pages/man2/semop.2:481
msgid ""
"The implementation has no intrinsic limits for the adjust on exit maximum "
"value (B<SEMAEM>), the system wide maximum number of undo structures "
"(B<SEMMNU>)  and the per-process maximum number of undo entries system "
"parameters."
msgstr "Реализация не накладывает существенных ограничений на максимальное значение (B<SEMAEM>), на которое можно изменить значение семафора при выходе, максимальное количество системных структур откатываемых операций (B<SEMMNU>) и максимальное количество элементов отката системных параметров на процесс."

#. type: Plain text
#: man-pages/man2/semop.2:502
msgid ""
"When a process terminates, its set of associated I<semadj> structures is "
"used to undo the effect of all of the semaphore operations it performed with"
" the B<SEM_UNDO> flag.  This raises a difficulty: if one (or more) of these "
"semaphore adjustments would result in an attempt to decrease a semaphore's "
"value below zero, what should an implementation do? One possible approach "
"would be to block until all the semaphore adjustments could be performed.  "
"This is however undesirable since it could force process termination to "
"block for arbitrarily long periods.  Another possibility is that such "
"semaphore adjustments could be ignored altogether (somewhat analogously to "
"failing when B<IPC_NOWAIT> is specified for a semaphore operation).  Linux "
"adopts a third approach: decreasing the semaphore value as far as possible "
"(i.e., to zero) and allowing process termination to proceed immediately."
msgstr "При завершении процесса его набор связанных структур I<semadj> используется для отката выполненных действий над семафорами, для которых был установлен флаг B<SEM_UNDO>. Это повышает сложность: если одно (или более) этих изменений семафоров привело бы в результате к попытке уменьшить значение семафора ниже нуля, что должно быть сделано в реализации? Одним из возможных решений была бы блокировка до тех пор, пока не выполнятся все изменения семафоров. Однако это нежелательно, так как это привело бы к блокированию процесса на неопределённый срок при его завершении. Другим вариантом является игнорирование сразу всех изменений семафоров (в некоторой степени, аналогично завершению с ошибкой, когда для операции с семафором указан B<IPC_NOWAIT>). В Linux используется третий вариант: уменьшение значения семафора до тех пор, пока это возможно ( т.е. до нуля) и разрешение немедленного завершения процесса."

#.  The bug report:
#.  http://marc.theaimsgroup.com/?l=linux-kernel&m=110260821123863&w=2
#.  the fix:
#.  http://marc.theaimsgroup.com/?l=linux-kernel&m=110261701025794&w=2
#. type: Plain text
#: man-pages/man2/semop.2:511
msgid ""
"In kernels 2.6.x, x E<lt>= 10, there is a bug that in some circumstances "
"prevents a thread that is waiting for a semaphore value to become zero from "
"being woken up when the value does actually become zero.  This bug is fixed "
"in kernel 2.6.11."
msgstr "В ядрах 2.6.x, где x E<lt>= 10, есть дефект, из-за которого при определённых обстоятельствах нить, ожидающая установления значения семафора равного нулю, не будет разбужен когда значение станет равным нулю. Этот дефект исправлен в ядре 2.6.11."

#. type: Plain text
#: man-pages/man2/semop.2:516
msgid ""
"The following code segment uses B<semop>()  to atomically wait for the value"
" of semaphore 0 to become zero, and then increment the semaphore value by "
"one."
msgstr "В следующем фрагменте кода используется B<semop>() для атомарного ожидания момента, когда значение семафора 0 станет равным нулю и последующего увеличения значения семафора на единицу."

#. type: Plain text
#: man-pages/man2/semop.2:520
#, no-wrap
msgid ""
"    struct sembuf sops[2];\n"
"    int semid;\n"
msgstr "    struct sembuf sops[2];\n    int semid;\n"

#. type: Plain text
#: man-pages/man2/semop.2:522
#, no-wrap
msgid "    /* Code to set I<semid> omitted */\n"
msgstr "    /* код для установки I<semid> не показан */\n"

#. type: Plain text
#: man-pages/man2/semop.2:526
#, no-wrap
msgid ""
"    sops[0].sem_num = 0;        /* Operate on semaphore 0 */\n"
"    sops[0].sem_op = 0;         /* Wait for value to equal 0 */\n"
"    sops[0].sem_flg = 0;\n"
msgstr "    sops[0].sem_num = 0;        /* применяем к семафору 0 */\n    sops[0].sem_op = 0;         /* ждём значения, равного 0 */\n    sops[0].sem_flg = 0;\n"

#. type: Plain text
#: man-pages/man2/semop.2:530
#, no-wrap
msgid ""
"    sops[1].sem_num = 0;        /* Operate on semaphore 0 */\n"
"    sops[1].sem_op = 1;         /* Increment value by one */\n"
"    sops[1].sem_flg = 0;\n"
msgstr "    sops[1].sem_num = 0;        /* применяем к семафору 0 */\n    sops[1].sem_op = 1;         /* увеличиваем значение на 1 */\n    sops[1].sem_flg = 0;\n"

#. type: Plain text
#: man-pages/man2/semop.2:535
#, no-wrap
msgid ""
"    if (semop(semid, sops, 2) == -1) {\n"
"        perror(\"semop\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr "    if (semop(semid, sops, 2) == -1) {\n        perror(\"semop\");\n        exit(EXIT_FAILURE);\n    }\n"

#. type: Plain text
#: man-pages/man2/semop.2:544
msgid ""
"B<clone>(2), B<semctl>(2), B<semget>(2), B<sigaction>(2), "
"B<capabilities>(7), B<sem_overview>(7), B<svipc>(7), B<time>(7)"
msgstr "B<clone>(2), B<semctl>(2), B<semget>(2), B<sigaction>(2), B<capabilities>(7), B<sem_overview>(7), B<svipc>(7), B<time>(7)"

#. type: TH
#: man-pages/man2/spu_create.2:25
#, no-wrap
msgid "SPU_CREATE"
msgstr "SPU_CREATE"

#. type: Plain text
#: man-pages/man2/spu_create.2:28
msgid "spu_create - create a new spu context"
msgstr "spu_create - создаёт новый контекст spu"

#. type: Plain text
#: man-pages/man2/spu_create.2:32
#, no-wrap
msgid ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>sys/spu.hE<gt>>\n"
msgstr "B<#include E<lt>sys/types.hE<gt>>\nB<#include E<lt>sys/spu.hE<gt>>\n"

#. type: Plain text
#: man-pages/man2/spu_create.2:36
#, no-wrap
msgid ""
"B<int spu_create(const char *>I<pathname>B<, int >I<flags>B<, mode_t >I<mode>B<);>\n"
"B<int spu_create(const char *>I<pathname>B<, int >I<flags>B<, mode_t >I<mode>B<,>\n"
"B<               int >I<neighbor_fd>B<);>\n"
msgstr "B<int spu_create(const char *>I<pathname>B<, int >I<flags>B<, mode_t >I<mode>B<);>\nB<int spu_create(const char *>I<pathname>B<, int >I<flags>B<, mode_t >I<mode>B<,>\nB<               int >I<neighbor_fd>B<);>\n"

#. type: Plain text
#: man-pages/man2/spu_create.2:59
msgid ""
"The B<spu_create>()  system call is used on PowerPC machines that implement "
"the Cell Broadband Engine Architecture in order to access Synergistic "
"Processor Units (SPUs).  It creates a new logical context for an SPU in "
"I<pathname> and returns a file descriptor associated with it.  I<pathname> "
"must refer to a nonexistent directory in the mount point of the SPU "
"filesystem (B<spufs>).  If B<spu_create>()  is successful, a directory is "
"created at I<pathname> and it is populated with the files described in "
"B<spufs>(7)."
msgstr "Системный вызов B<spu_create>() используется на машинах PowerPC с архитектурой Cell Broadband Engine для получения доступа к Synergistic Processor Unit (SPU). Он создаёт новый логический контекст для SPU в I<pathname> и возвращает связанный с ним файловый дескриптор. Аргумент I<pathname> должен указывать на несуществующий каталог в точке монтирования файловой системы SPU (B<spufs>). Если работа B<spu_create>() выполнена без ошибок, то создаётся каталог I<pathname>, а в нём создаются файлы, описанные в B<spufs>(7)."

#. type: Plain text
#: man-pages/man2/spu_create.2:78
msgid ""
"When a context is created, the returned file descriptor can only be passed "
"to B<spu_run>(2), used as the I<dirfd> argument to the B<*at> family of "
"system calls (e.g., B<openat>(2)), or closed; other operations are not "
"defined.  A logical SPU context is destroyed (along with all files created "
"within the context's I<pathname> directory) once the last reference to the "
"context has gone; this usually occurs when the file descriptor returned by "
"B<spu_create>()  is closed."
msgstr "После создания контекста, полученный файловый дескриптор может быть передан только B<spu_run>(2), семейству системных вызовов B<*at> (например, B<openat>(2)) в аргументе I<dirfd> или закрыт; другие операции не определены. Логический контекст SPU уничтожается (вместе с файлами, созданными внутри каталога контекста I<pathname>) после освобождения последней ссылки на контекст; обычно, это происходит после закрытия файлового дескриптора, возвращённого B<spu_create>()."

#. type: Plain text
#: man-pages/man2/spu_create.2:83
msgid ""
"The I<flags> argument can be zero or any bitwise OR-ed combination of the "
"following constants:"
msgstr "Аргумент I<flags> может быть равен нулю или содержать любую побитовую комбинацию (посредством OR) следующих констант:"

#. type: TP
#: man-pages/man2/spu_create.2:83
#, no-wrap
msgid "B<SPU_CREATE_EVENTS_ENABLED>"
msgstr "B<SPU_CREATE_EVENTS_ENABLED>"

#. type: Plain text
#: man-pages/man2/spu_create.2:89
msgid ""
"Rather than using signals for reporting DMA errors, use the I<event> "
"argument to B<spu_run>(2)."
msgstr "Вместо использования сигналов для сообщения об ошибках DMA, использовать аргумент I<event> в B<spu_run>(2)."

#. type: TP
#: man-pages/man2/spu_create.2:89
#, no-wrap
msgid "B<SPU_CREATE_GANG>"
msgstr "B<SPU_CREATE_GANG>"

#. type: Plain text
#: man-pages/man2/spu_create.2:97
msgid ""
"Create an SPU gang instead of a context.  (A gang is a group of SPU contexts"
" that are functionally related to each other and which share common "
"scheduling parameters\\(empriority and policy.  In the future, gang "
"scheduling may be implemented causing the group to be switched in and out as"
" a single unit.)"
msgstr "Создать блок (gang) SPU вместо контекста (блок — это группа контекстов SPU, которые близки по функциям и у которых общие параметры планирования — приоритет и политика. В будущем, планирование блока на включение и выключение может быть реализовано как единого целое)."

#. type: Plain text
#: man-pages/man2/spu_create.2:104
msgid ""
"A new directory will be created at the location specified by the I<pathname>"
" argument.  This gang may be used to hold other SPU contexts, by providing a"
" pathname that is within the gang directory to further calls to "
"B<spu_create>()."
msgstr "В месте, указанном в аргументе I<pathname>, будет создан новый каталог. Этот блок может использоваться для хранения других контекстов SPU, если указывать путь блока в последующих вызовах B<spu_create>()."

#. type: TP
#: man-pages/man2/spu_create.2:104
#, no-wrap
msgid "B<SPU_CREATE_NOSCHED>"
msgstr "B<SPU_CREATE_NOSCHED>"

#. type: Plain text
#: man-pages/man2/spu_create.2:110
msgid ""
"Create a context that is not affected by the SPU scheduler.  Once the "
"context is run, it will not be scheduled out until it is destroyed by the "
"creating process."
msgstr "Создать контекст, на который не влияет планировщик SPU. После запуска контекста, он не будет планироваться для выполнения пока не будет уничтожен создавшим его процессом."

#. type: Plain text
#: man-pages/man2/spu_create.2:121
msgid ""
"Because the context cannot be removed from the SPU, some functionality is "
"disabled for B<SPU_CREATE_NOSCHED> contexts.  Only a subset of the files "
"will be available in this context directory in B<spufs>.  Additionally, "
"B<SPU_CREATE_NOSCHED> contexts cannot dump a core file when crashing."
msgstr "Так как контекст не может быть удалён из SPU, у контекстов B<SPU_CREATE_NOSCHED> отключены некоторые возможности. Не все файлы будут доступны в каталоге этого контекста в B<spufs>. Также, для контекстов B<SPU_CREATE_NOSCHED> не может быть создан файл дампа при поломке."

#. type: Plain text
#: man-pages/man2/spu_create.2:127
msgid ""
"Creating B<SPU_CREATE_NOSCHED> contexts requires the B<CAP_SYS_NICE> "
"capability."
msgstr "Для создания контекстов B<SPU_CREATE_NOSCHED> требуется мандат B<CAP_SYS_NICE>."

#. type: TP
#: man-pages/man2/spu_create.2:127
#, no-wrap
msgid "B<SPU_CREATE_ISOLATE>"
msgstr "B<SPU_CREATE_ISOLATE>"

#. type: Plain text
#: man-pages/man2/spu_create.2:134
msgid ""
"Create an isolated SPU context.  Isolated contexts are protected from some "
"PPE (PowerPC Processing Element)  operations, such as access to the SPU "
"local store and the NPC register."
msgstr "Создать изолированный контекст SPU. Изолированные контексты защищены от некоторых операций PPE (PowerPC Processing Element), таких как доступ к локальному хранилищу SPU и регистру NPC."

#. type: Plain text
#: man-pages/man2/spu_create.2:140
msgid ""
"Creating B<SPU_CREATE_ISOLATE> contexts also requires the "
"B<SPU_CREATE_NOSCHED> flag."
msgstr "Для создания контекста B<SPU_CREATE_ISOLATE> также требуется флаг B<SPU_CREATE_NOSCHED>."

#. type: TP
#: man-pages/man2/spu_create.2:140
#, no-wrap
msgid "B<SPU_CREATE_AFFINITY_SPU>"
msgstr "B<SPU_CREATE_AFFINITY_SPU>"

#. type: Plain text
#: man-pages/man2/spu_create.2:148
msgid ""
"Create a context with affinity to another SPU context.  This affinity "
"information is used within the SPU scheduling algorithm.  Using this flag "
"requires that a file descriptor referring to the other SPU context be passed"
" in the I<neighbor_fd> argument."
msgstr "Создать контекст со связью с другим контекстом SPU. Эта информация о связи используется в алгоритме планирования SPU. При использовании этого флага требуется, чтобы файловый дескриптор, ссылающийся на другой контекст SPU, передавался в аргументе I<neighbor_fd>."

#. type: TP
#: man-pages/man2/spu_create.2:148
#, no-wrap
msgid "B<SPU_CREATE_AFFINITY_MEM>"
msgstr "B<SPU_CREATE_AFFINITY_MEM>"

#. type: Plain text
#: man-pages/man2/spu_create.2:153
msgid ""
"Create a context with affinity to system memory.  This affinity information "
"is used within the SPU scheduling algorithm."
msgstr "Создать контекст со связью с системной памятью. Эта информация о связи используется в алгоритме планирования SPU."

#. type: Plain text
#: man-pages/man2/spu_create.2:165
msgid ""
"The I<mode> argument (minus any bits set in the process's B<umask>(2))  "
"specifies the permissions used for creating the new directory in B<spufs>.  "
"See B<stat>(2)  for a full list of the possible I<mode> values."
msgstr "В аргументе I<mode> (не считая битов B<umask>(2) процесса) задаются права, которые используются при создании нового каталога в B<spufs>. Полное описание всех значений I<mode> смотрите в B<stat>(2)."

#. type: Plain text
#: man-pages/man2/spu_create.2:172
msgid ""
"On success, B<spu_create>()  returns a new file descriptor.  On error, -1 is"
" returned, and I<errno> is set to one of the error codes listed below."
msgstr "При успешном выполнении B<spu_create>() возвращается новый файловый дескриптор; при ошибке возвращается -1, а в I<errno> содержится один из кодов ошибки, описанных далее."

#. type: Plain text
#: man-pages/man2/spu_create.2:178
msgid ""
"The current user does not have write access to the B<spufs>(7)  mount point."
msgstr "Текущий пользователь не имеет прав на запись в точку монтирования B<spufs>(7)."

#. type: Plain text
#: man-pages/man2/spu_create.2:181
msgid "An SPU context already exists at the given pathname."
msgstr "Контекст SPU с указанным именем пути уже существует."

#. type: Plain text
#: man-pages/man2/spu_create.2:186
msgid ""
"I<pathname> is not a valid string pointer in the calling process's address "
"space."
msgstr "Значение I<pathname> не является допустимым строковым указателем в адресном пространстве вызывающего процесса."

#. type: Plain text
#: man-pages/man2/spu_create.2:192
msgid ""
"I<pathname> is not a directory in the B<spufs>(7)  mount point, or invalid "
"flags have been provided."
msgstr "Значение I<pathname> не является каталогом в точке монтирования B<spufs>(7), или указаны неправильные флаги."

#. type: Plain text
#: man-pages/man2/spu_create.2:196
msgid "Too many symbolic links were found while resolving I<pathname>."
msgstr "Во время определения I<pathname> встретилось слишком много символьных ссылок."

#. type: Plain text
#: man-pages/man2/spu_create.2:199
msgid "The process has reached its maximum open files limit."
msgstr "Было достигнуто ограничение по открытым файлам на процесс."

#. type: Plain text
#: man-pages/man2/spu_create.2:206
msgid "The system has reached the global open files limit."
msgstr "В системе было достигнуто глобальное ограничение по открытым файлам."

#. type: TP
#: man-pages/man2/spu_create.2:206
#, no-wrap
msgid "B<ENODEV>"
msgstr "B<ENODEV>"

#. type: Plain text
#: man-pages/man2/spu_create.2:210
msgid ""
"An isolated context was requested, but the hardware does not support SPU "
"isolation."
msgstr "Был запрошен изолированный контекст, но аппаратная часть не поддерживает изоляцию SPU."

#. type: Plain text
#: man-pages/man2/spu_create.2:215
msgid "Part of I<pathname> could not be resolved."
msgstr "Невозможно определить часть I<pathname>."

#. type: Plain text
#: man-pages/man2/spu_create.2:218
msgid "The kernel could not allocate all resources required."
msgstr "Ядро не может выделить все требуемые ресурсы."

#. type: Plain text
#: man-pages/man2/spu_create.2:223
msgid ""
"There are not enough SPU resources available to create a new context or the "
"user-specific limit for the number of SPU contexts has been reached."
msgstr "Недостаточно ресурсов SPU для создания нового контекста или достигнуто ограничение на количество контекстов SPU для пользователя."

#. type: Plain text
#: man-pages/man2/spu_create.2:228
msgid ""
"The functionality is not provided by the current system, because either the "
"hardware does not provide SPUs or the spufs module is not loaded."
msgstr "Возможность не предоставляется текущей системой, так как или аппаратура не предоставляет SPU, или не загружен модуль spufs."

#. type: Plain text
#: man-pages/man2/spu_create.2:233
msgid "A part of I<pathname> is not a directory."
msgstr "Часть I<pathname> не является каталогом."

#. type: Plain text
#: man-pages/man2/spu_create.2:240
msgid ""
"The I<SPU_CREATE_NOSCHED> flag has been given, but the user does not have "
"the B<CAP_SYS_NICE> capability."
msgstr "Указан флаг I<SPU_CREATE_NOSCHED>, но пользователь не имеет мандата B<CAP_SYS_NICE>."

#. type: Plain text
#: man-pages/man2/spu_create.2:246
msgid ""
"I<pathname> must point to a location beneath the mount point of B<spufs>.  "
"By convention, it gets mounted in I</spu>."
msgstr "Значение I<pathname> должно указываться относительно точки монтирования B<spufs>. По соглашению всё монтируется в I</spu>."

#. type: Plain text
#: man-pages/man2/spu_create.2:250
msgid "The B<spu_create>()  system call was added to Linux in kernel 2.6.16."
msgstr "Системный вызов B<spu_create>() был добавлен в ядро Linux версии 2.6.16."

#. type: Plain text
#: man-pages/man2/spu_create.2:254
msgid ""
"This call is Linux-specific and implemented only on the PowerPC "
"architecture.  Programs using this system call are not portable."
msgstr "Данный вызов существует только в Linux и реализован только для архитектуры PowerPC. Программы, использующие данный вызов, не переносимы."

#. type: Plain text
#: man-pages/man2/spu_create.2:265
msgid ""
"Glibc does not provide a wrapper for this system call; call it using "
"B<syscall>(2).  Note however, that B<spu_create>()  is meant to be used from"
" libraries that implement a more abstract interface to SPUs, not to be used "
"from regular applications.  See E<.UR "
"http://www.bsc.es\\:/projects\\:/deepcomputing\\:/linuxoncell/> E<.UE> for "
"the recommended libraries."
msgstr "В glibc нет обёртки для этого системного вызова; запускайте его с помощью B<syscall>(2). Однако заметим, что B<spu_run>() предназначен для работы в библиотеках, которые реализуют более абстрактный интерфейс к SPU и не должен вызываться из обычных приложений. Рекомендуемые библиотеки приведены на странице E<.UR http://www.bsc.es\\:/projects\\:/deepcomputing\\:/linuxoncell/> E<.UE .>"

#. type: Plain text
#: man-pages/man2/spu_create.2:270
msgid "See B<spu_run>(2)  for an example of the use of B<spu_create>()"
msgstr "В B<spu_run>(2) дан пример использования B<spu_create>()."

#. type: Plain text
#: man-pages/man2/spu_create.2:274
msgid "B<close>(2), B<spu_run>(2), B<capabilities>(7), B<spufs>(7)"
msgstr "B<close>(2), B<spu_run>(2), B<capabilities>(7), B<spufs>(7)"

#. type: TH
#: man-pages/man2/s390_runtime_instr.2:25
#, no-wrap
msgid "S390_RUNTIME_INSTR"
msgstr "S390_RUNTIME_INSTR"

#. type: TH
#: man-pages/man2/s390_runtime_instr.2:25
#, no-wrap
msgid "2012-12-17"
msgstr "2012-12-17"

#. type: Plain text
#: man-pages/man2/s390_runtime_instr.2:28
msgid "s390_runtime_instr - enable/disable s390 CPU run-time instrumentation"
msgstr ""

#. type: Plain text
#: man-pages/man2/s390_runtime_instr.2:31
#, no-wrap
msgid "B<#include E<lt>asm/runtime_instr.hE<gt>>\n"
msgstr "B<#include E<lt>asm/runtime_instr.hE<gt>>\n"

#. type: Plain text
#: man-pages/man2/s390_runtime_instr.2:33
#, no-wrap
msgid "B<int s390_runtime_instr(int >I<command>B<, int >I<signum>B<);>\n"
msgstr "B<int s390_runtime_instr(int >I<command>B<, int >I<signum>B<);>\n"

#. type: Plain text
#: man-pages/man2/s390_runtime_instr.2:39
msgid ""
"The B<s390_runtime_instr>()  system call starts or stops CPU run-time "
"instrumentation for the calling thread."
msgstr ""

#. type: Plain text
#: man-pages/man2/s390_runtime_instr.2:47
msgid ""
"The I<command> argument controls whether run-time instrumentation is started"
" (B<S390_RUNTIME_INSTR_START>, 1) or stopped (B<S390_RUNTIME_INSTR_STOP>, 2)"
" for the calling thread."
msgstr ""

#. type: Plain text
#: man-pages/man2/s390_runtime_instr.2:54
msgid ""
"The I<signum> argument specifies the number of a real-time signal.  The "
"real-time signal is sent to the thread if the run-time instrumentation "
"buffer is full or if the run-time-instrumentation-halted interrupt occurred."
msgstr ""

#. type: Plain text
#: man-pages/man2/s390_runtime_instr.2:65
msgid ""
"On success, B<s390_runtime_instr>()  returns 0 and enables the thread for "
"run-time instrumentation by assigning the thread a default run-time "
"instrumentation control block.  The caller can then read and modify the "
"control block and start the run-time instrumentation.  On error, -1 is "
"returned and I<errno> is set to one of the error codes listed below."
msgstr ""

#. type: Plain text
#: man-pages/man2/s390_runtime_instr.2:73
msgid ""
"The value specified in I<command> is not a valid command or the value "
"specified in I<signum> is not a real-time signal number."
msgstr ""

#. type: Plain text
#: man-pages/man2/s390_runtime_instr.2:76
msgid ""
"Allocating memory for the run-time instrumentation control block failed."
msgstr ""

#. type: Plain text
#: man-pages/man2/s390_runtime_instr.2:79
msgid "The run-time instrumentation facility is not available."
msgstr ""

#. type: Plain text
#: man-pages/man2/s390_runtime_instr.2:81
msgid "This system call is available since Linux 3.7."
msgstr ""

#. type: Plain text
#: man-pages/man2/s390_runtime_instr.2:84
msgid ""
"This Linux-specific system call is available only on the s390 architecture."
"  The run-time instrumentation facility is available beginning with System z"
" EC12."
msgstr ""

#. type: Plain text
#: man-pages/man2/s390_runtime_instr.2:88
msgid ""
"Glibc does not provide a wrapper for this system call, use B<syscall>(2)  to"
" call it."
msgstr ""

#. type: Plain text
#: man-pages/man2/s390_runtime_instr.2:90
msgid "B<syscall>(2), B<signal>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/sigaltstack.2:27
#, no-wrap
msgid "SIGALTSTACK"
msgstr "SIGALTSTACK"

#. type: TH
#: man-pages/man2/sigaltstack.2:27
#, no-wrap
msgid "2010-09-26"
msgstr "2010-09-26"

#. type: Plain text
#: man-pages/man2/sigaltstack.2:30
msgid "sigaltstack - set and/or get signal stack context"
msgstr "sigaltstack - считывает или устанавливает расположение стека сигналов"

#. type: Plain text
#: man-pages/man2/sigaltstack.2:34
msgid "B<int sigaltstack(const stack_t *>I<ss>B<, stack_t *>I<oss>B<);>"
msgstr "B<int sigaltstack(const stack_t *>I<ss>B<, stack_t *>I<oss>B<);>"

#. type: Plain text
#: man-pages/man2/sigaltstack.2:41
msgid "B<sigaltstack>():"
msgstr "B<sigaltstack>():"

#. type: Plain text
#: man-pages/man2/sigaltstack.2:60
msgid ""
"B<sigaltstack>()  allows a process to define a new alternate signal stack "
"and/or retrieve the state of an existing alternate signal stack.  An "
"alternate signal stack is used during the execution of a signal handler if "
"the establishment of that handler (see B<sigaction>(2))  requested it."
msgstr "Вызов B<sigaltstack>() позволяет процессу определить новый альтернативный стек сигналов и/или получить состояние уже имеющегося альтернативного стека сигналов. Альтернативный стек сигналов используется при выполнении обработчика сигналов, если он был запрошен при установлении обработчика (см. B<sigaction>(2))."

#. type: Plain text
#: man-pages/man2/sigaltstack.2:63
msgid ""
"The normal sequence of events for using an alternate signal stack is the "
"following:"
msgstr "Обычный порядок действий для использования альтернативного стека сигналов:"

#. type: Plain text
#: man-pages/man2/sigaltstack.2:67
msgid "Allocate an area of memory to be used for the alternate signal stack."
msgstr "Выделить область памяти, которая будет использована под альтернативный стек сигналов."

#. type: Plain text
#: man-pages/man2/sigaltstack.2:73
msgid ""
"Use B<sigaltstack>()  to inform the system of the existence and location of "
"the alternate signal stack."
msgstr "Вызвать B<sigaltstack>() для информирования системы о существовании и расположении альтернативного стека сигналов."

#. type: Plain text
#: man-pages/man2/sigaltstack.2:80
msgid ""
"When establishing a signal handler using B<sigaction>(2), inform the system "
"that the signal handler should be executed on the alternate signal stack by "
"specifying the B<SA_ONSTACK> flag."
msgstr "При установке обработчика сигналов с помощью B<sigaction>(2) (флагом B<SA_ONSTACK>) сообщить системе, что обработчик сигналов должен выполняться с альтернативным стеком сигналов."

#. type: Plain text
#: man-pages/man2/sigaltstack.2:88
msgid ""
"The I<ss> argument is used to specify a new alternate signal stack, while "
"the I<oss> argument is used to retrieve information about the currently "
"established signal stack.  If we are interested in performing just one of "
"these tasks, then the other argument can be specified as NULL.  Each of "
"these arguments is a structure of the following type:"
msgstr "Аргумент I<ss> используется для указания нового альтернативного стека сигналов, а аргумент I<oss> используется для получения информации об установленном в данный момент стеке сигналов. Если интересует какая-то одна из этих задач, то другой аргумент указывается как NULL. Каждый из аргументов представляет структуру следующего вида:"

#. type: Plain text
#: man-pages/man2/sigaltstack.2:96
#, no-wrap
msgid ""
"typedef struct {\n"
"    void  *ss_sp;     /* Base address of stack */\n"
"    int    ss_flags;  /* Flags */\n"
"    size_t ss_size;   /* Number of bytes in stack */\n"
"} stack_t;\n"
msgstr "typedef struct {\n    void  *ss_sp;     /* базовый адрес стека */\n    int    ss_flags;  /* флаги */\n    size_t ss_size;   /* количество байт в стеке */\n} stack_t;\n"

#. type: Plain text
#: man-pages/man2/sigaltstack.2:107
msgid ""
"To establish a new alternate signal stack, I<ss.ss_flags> is set to zero, "
"and I<ss.ss_sp> and I<ss.ss_size> specify the starting address and size of "
"the stack.  The constant B<SIGSTKSZ> is defined to be large enough to cover "
"the usual size requirements for an alternate signal stack, and the constant "
"B<MINSIGSTKSZ> defines the minimum size required to execute a signal "
"handler."
msgstr "Чтобы задать новой альтернативный стек сигналов поле I<ss.ss_flags> устанавливается в ноль, а в I<ss.ss_sp> и I<ss.ss_size> указываются начальный адрес и размер стека. Для определения альтернативного стека сигналов достаточного размера можно использовать константу B<SIGSTKSZ>, а для выделения стека минимального размера можно указать константу B<MINSIGSTKSZ>."

#. type: Plain text
#: man-pages/man2/sigaltstack.2:111
msgid ""
"When a signal handler is invoked on the alternate stack, the kernel "
"automatically aligns the address given in I<ss.ss_sp> to a suitable address "
"boundary for the underlying hardware architecture."
msgstr "При вызове обработчика сигнала с альтернативным стеком ядро автоматически выравнивает адрес, указанный в I<ss.ss_sp>, по границе адреса, подходящей для используемой аппаратной платформы."

#. type: Plain text
#: man-pages/man2/sigaltstack.2:116
msgid ""
"To disable an existing stack, specify I<ss.ss_flags> as B<SS_DISABLE>.  In "
"this case, the remaining fields in I<ss> are ignored."
msgstr "Для отключения существующего стека, укажите в I<ss.ss_flags> значение B<SS_DISABLE>. В этом случае остальные поля в I<ss> игнорируются."

#. type: Plain text
#: man-pages/man2/sigaltstack.2:124
msgid ""
"If I<oss> is not NULL, then it is used to return information about the "
"alternate signal stack which was in effect prior to the call to "
"B<sigaltstack>().  The I<oss.ss_sp> and I<oss.ss_size> fields return the "
"starting address and size of that stack.  The I<oss.ss_flags> may return "
"either of the following values:"
msgstr "Если I<oss> не равно NULL, то в нём возвращается информация об альтернативном стеке сигналов, который использовался до этого вызова B<sigaltstack>(). В полях I<oss.ss_sp> и I<oss.ss_size> возвращаются начальный адрес и размер стека. В I<oss.ss_flags> может быть возвращено одно из следующих значений:"

#. type: TP
#: man-pages/man2/sigaltstack.2:124
#, no-wrap
msgid "B<SS_ONSTACK>"
msgstr "B<SS_ONSTACK>"

#. type: Plain text
#: man-pages/man2/sigaltstack.2:130
msgid ""
"The process is currently executing on the alternate signal stack.  (Note "
"that it is not possible to change the alternate signal stack if the process "
"is currently executing on it.)"
msgstr "В данный момент альтернативный стек сигналов используется процессом (заметим, что в этот момент невозможно изменить альтернативный стек сигналов)."

#. type: TP
#: man-pages/man2/sigaltstack.2:130
#, no-wrap
msgid "B<SS_DISABLE>"
msgstr "B<SS_DISABLE>"

#. type: Plain text
#: man-pages/man2/sigaltstack.2:133
msgid "The alternate signal stack is currently disabled."
msgstr "В данный момент альтернативный стек сигналов выключен."

#. type: Plain text
#: man-pages/man2/sigaltstack.2:137
msgid ""
"B<sigaltstack>()  returns 0 on success, or -1 on failure with I<errno> set "
"to indicate the error."
msgstr "При успешном выполнении B<sigaltstack>() возвращается 0. В случае ошибки возвращается -1, а I<errno> устанавливается в соответствующее значение."

#. type: Plain text
#: man-pages/man2/sigaltstack.2:142
msgid ""
"Either I<ss> or I<oss> is not NULL and points to an area outside of the "
"process's address space."
msgstr "Значение I<ss> или I<oss> не равно NULL и указывает за пределы адресного пространства процесса."

#. type: Plain text
#: man-pages/man2/sigaltstack.2:147
msgid ""
"I<ss> is not NULL and the I<ss_flags> field contains a nonzero value other "
"than B<SS_DISABLE>."
msgstr "Значение I<ss> не равно NULL и в поле I<ss_flags> содержится ненулевое значение, не равное B<SS_DISABLE>."

#. type: Plain text
#: man-pages/man2/sigaltstack.2:153
msgid ""
"The specified size of the new alternate signal stack I<ss.ss_size> as less "
"than B<MINSTKSZ>."
msgstr "Указанный размер нового альтернативного стека сигналов I<ss.ss_size> меньше B<MINSTKSZ>."

#. type: Plain text
#: man-pages/man2/sigaltstack.2:158
msgid ""
"An attempt was made to change the alternate signal stack while it was active"
" (i.e., the process was already executing on the current alternate signal "
"stack)."
msgstr "Была попытка изменить альтернативный стек сигналов при его активности (т. е. текущий альтернативный стек сигналов уже задействован при выполнении процесса)."

#. type: Plain text
#: man-pages/man2/sigaltstack.2:160
msgid "SUSv2, SVr4, POSIX.1-2001."
msgstr "SUSv2, SVr4, POSIX.1-2001."

#. type: Plain text
#: man-pages/man2/sigaltstack.2:168
msgid ""
"The most common usage of an alternate signal stack is to handle the "
"B<SIGSEGV> signal that is generated if the space available for the normal "
"process stack is exhausted: in this case, a signal handler for B<SIGSEGV> "
"cannot be invoked on the process stack; if we wish to handle it, we must use"
" an alternate signal stack."
msgstr "В основном, альтернативный стек сигналов используется при обработке сигнала B<SIGSEGV>, который возникает при нехватке свободного места в обычном стеке процесса: в этом случае обработчик сигнала B<SIGSEGV> не может использовать стек процесса; если требуется обработка данного сигнала, нужно использовать альтернативный стек сигналов."

#. type: Plain text
#: man-pages/man2/sigaltstack.2:178
msgid ""
"Establishing an alternate signal stack is useful if a process expects that "
"it may exhaust its standard stack.  This may occur, for example, because the"
" stack grows so large that it encounters the upwardly growing heap, or it "
"reaches a limit established by a call to B<setrlimit(RLIMIT_STACK, &rlim)>."
"  If the standard stack is exhausted, the kernel sends the process a "
"B<SIGSEGV> signal.  In these circumstances the only way to catch this signal"
" is on an alternate signal stack."
msgstr "Назначение альтернативного стека сигналов полезно, если ожидается, что процесс может задействовать весь свой обычный стек. Это может случиться, например, когда стек становится настолько большим, что он встречается с растущей в вверх «кучей», или достигает ограничения, заданного вызовом B<setrlimit(RLIMIT_STACK, &rlim)>. Если стандартный стек закончился, то ядро посылает процессу сигнал B<SIGSEGV>. В этих условиях единственным способом поймать сигнал будет задействование альтернативного стека сигналов."

#. type: Plain text
#: man-pages/man2/sigaltstack.2:184
msgid ""
"On most hardware architectures supported by Linux, stacks grow downward.  "
"B<sigaltstack>()  automatically takes account of the direction of stack "
"growth."
msgstr "На большинстве аппаратных архитектур, поддерживаемых Linux, стеки растут сверху вниз. Вызов B<sigaltstack>() автоматически учтёт направление роста стека."

#. type: Plain text
#: man-pages/man2/sigaltstack.2:193
msgid ""
"Functions called from a signal handler executing on an alternate signal "
"stack will also use the alternate signal stack.  (This also applies to any "
"handlers invoked for other signals while the process is executing on the "
"alternate signal stack.)  Unlike the standard stack, the system does not "
"automatically extend the alternate signal stack.  Exceeding the allocated "
"size of the alternate signal stack will lead to unpredictable results."
msgstr "Функции, вызываемые из обработчика сигналов исполняемого с использованием альтернативного стека сигналов, также будут использовать альтернативный стек сигналов (это также применимо к любым обработчикам, вызванным по другим сигналам в то время как процесс выполняется с альтернативным стеком сигналов). В отличие от стандартного стека система автоматически не расширяет альтернативный стек сигналов. Превышение выделенного размера альтернативного стека сигналов приведёт к непредсказуемым результатам."

#. type: Plain text
#: man-pages/man2/sigaltstack.2:201
msgid ""
"A successful call to B<execve>(2)  removes any existing alternate signal "
"stack.  A child process created via B<fork>(2)  inherits a copy of its "
"parent's alternate signal stack settings."
msgstr "При успешном выполнении вызова B<execve>(2) любой существующий альтернативный стек сигналов удаляется. Дочерний процесс, созданный с помощью B<fork>(2), наследует копию настроек альтернативного стека сигналов своего родителя."

#. type: Plain text
#: man-pages/man2/sigaltstack.2:210
msgid ""
"B<sigaltstack>()  supersedes the older B<sigstack>()  call.  For backward "
"compatibility, glibc also provides B<sigstack>().  All new applications "
"should be written using B<sigaltstack>()."
msgstr "Вызов B<sigaltstack>() заменяет устаревший вызов B<sigstack>(). Для обратной совместимости в glibc также есть функция B<sigstack>(). Во всех новых приложениях нужно использовать B<sigaltstack>()."

#. type: SS
#: man-pages/man2/sigaltstack.2:210
#, no-wrap
msgid "History"
msgstr "История"

#. type: Plain text
#: man-pages/man2/sigaltstack.2:217
msgid ""
"4.2BSD had a B<sigstack>()  system call.  It used a slightly different "
"struct, and had the major disadvantage that the caller had to know the "
"direction of stack growth."
msgstr "Системный вызов B<sigstack>() появился в 4.2BSD. В нём использовалась слегка другая структура, и его главным недостатком было то, что вызывающий должен был учитывать направления роста стека."

#. type: Plain text
#: man-pages/man2/sigaltstack.2:220
msgid "The following code segment demonstrates the use of B<sigaltstack>():"
msgstr "В следующем сегменте кода показано использование B<sigaltstack>():"

#. type: Plain text
#: man-pages/man2/sigaltstack.2:224
#, no-wrap
msgid "stack_t ss;\n"
msgstr "stack_t ss;\n"

#. type: Plain text
#: man-pages/man2/sigaltstack.2:232
#, no-wrap
msgid ""
"ss.ss_sp = malloc(SIGSTKSZ);\n"
"if (ss.ss_sp == NULL)\n"
"    /* Handle error */;\n"
"ss.ss_size = SIGSTKSZ;\n"
"ss.ss_flags = 0;\n"
"if (sigaltstack(&ss, NULL) == -1)\n"
"    /* Handle error */;\n"
msgstr "ss.ss_sp = malloc(SIGSTKSZ);\nif (ss.ss_sp == NULL)\n    /* обработка ошибки */;\nss.ss_size = SIGSTKSZ;\nss.ss_flags = 0;\nif (sigaltstack(&ss, NULL) == -1)\n    /* обработка ошибки */;\n"

#. type: Plain text
#: man-pages/man2/sigaltstack.2:240
msgid ""
"B<execve>(2), B<setrlimit>(2), B<sigaction>(2), B<siglongjmp>(3), "
"B<sigsetjmp>(3), B<signal>(7)"
msgstr "B<execve>(2), B<setrlimit>(2), B<sigaction>(2), B<siglongjmp>(3), B<sigsetjmp>(3), B<signal>(7)"

#. type: TH
#: man-pages/man2/sysfs.2:27
#, no-wrap
msgid "SYSFS"
msgstr "SYSFS"

#. type: TH
#: man-pages/man2/sysfs.2:27
#, no-wrap
msgid "2010-06-27"
msgstr "2010-06-27"

#. type: Plain text
#: man-pages/man2/sysfs.2:30
msgid "sysfs - get filesystem type information"
msgstr "sysfs - получает информацию о типах файловых систем"

#. type: Plain text
#: man-pages/man2/sysfs.2:32
msgid "B<int sysfs(int >I<option>B<, const char *>I<fsname>B<);>"
msgstr "B<int sysfs(int >I<option>B<, const char *>I<fsname>B<);>"

#. type: Plain text
#: man-pages/man2/sysfs.2:34
msgid ""
"B<int sysfs(int >I<option>B<, unsigned int >I<fs_index>B<, char "
"*>I<buf>B<);>"
msgstr "B<int sysfs(int >I<option>B<, unsigned int >I<fs_index>B<, char *>I<buf>B<);>"

#. type: Plain text
#: man-pages/man2/sysfs.2:36
msgid "B<int sysfs(int >I<option>B<);>"
msgstr "B<int sysfs(int >I<option>B<);>"

#. type: Plain text
#: man-pages/man2/sysfs.2:45
msgid ""
"B<sysfs>()  returns information about the filesystem types currently present"
" in the kernel.  The specific form of the B<sysfs>()  call and the "
"information returned depends on the I<option> in effect:"
msgstr "B<sysfs>() возвращает информацию о типах файловой системы, которые имеются в ядре. Форма вызова B<sysfs>() и возвращаемая информация зависят от параметра I<option> согласно следующей таблице:"

#. type: TP
#: man-pages/man2/sysfs.2:45
#, no-wrap
msgid "B<1>"
msgstr "B<1>"

#. type: Plain text
#: man-pages/man2/sysfs.2:50
msgid ""
"Translate the filesystem identifier string I<fsname> into a filesystem type "
"index."
msgstr "Преобразовать строку с идентификатором типа файловой системы I<fsname> в индекс типа файловой системы."

#. type: TP
#: man-pages/man2/sysfs.2:50
#, no-wrap
msgid "B<2>"
msgstr "B<2>"

#. type: Plain text
#: man-pages/man2/sysfs.2:61
msgid ""
"Translate the filesystem type index I<fs_index> into a null-terminated "
"filesystem identifier string.  This string will be written to the buffer "
"pointed to by I<buf>.  Make sure that I<buf> has enough space to accept the "
"string."
msgstr "Преобразовать индекс типа файловой системы I<fs_index> в строку (оканчивающуюся null) с идентификатором типа файловой системы. Эта строка будет записана в буфер I<buf>. Убедитесь в том, что в I<buf> есть достаточно места для размещения этой строки."

#. type: TP
#: man-pages/man2/sysfs.2:61
#, no-wrap
msgid "B<3>"
msgstr "B<3>"

#. type: Plain text
#: man-pages/man2/sysfs.2:65
msgid ""
"Return the total number of filesystem types currently present in the kernel."
msgstr "Получить количество типов файловой системы, находящихся в настоящий момент в ядре."

#. type: Plain text
#: man-pages/man2/sysfs.2:67
msgid "The numbering of the filesystem type indexes begins with zero."
msgstr "Нумерация индексов типов файловой системы начинается с нуля."

#. type: Plain text
#: man-pages/man2/sysfs.2:79
msgid ""
"On success, B<sysfs>()  returns the filesystem index for option B<1>, zero "
"for option B<2>, and the number of currently configured filesystems for "
"option B<3>.  On error, -1 is returned, and I<errno> is set appropriately."
msgstr "При удачном завершении B<sysfs>() возвращает индекс типа файловой системы при значении option равном B<1>, ноль, если значение option равно B<2> и количество существующих в данный момент типов файловых систем в ядре при option, равном B<3>. При ошибке возвращается -1, а переменная I<errno> устанавливается соответствующим образом."

#. type: Plain text
#: man-pages/man2/sysfs.2:84
msgid "Either I<fsname> or I<buf> is outside your accessible address space."
msgstr "I<fsname> или I<buf> указывают на адрес за пределами адресного пространства процесса."

#. type: Plain text
#: man-pages/man2/sysfs.2:92
msgid ""
"I<fsname> is not a valid filesystem type identifier; I<fs_index> is out-of-"
"bounds; I<option> is invalid."
msgstr "I<fsname> не является правильным идентификатором типа файловой системы; превышены пределы I<fs_index>; неправильный параметр I<option>."

#. type: Plain text
#: man-pages/man2/sysfs.2:101
msgid ""
"This System-V derived system call is obsolete; don't use it.  On systems "
"with I</proc>, the same information can be obtained via "
"I</proc/filesystems>; use that interface instead."
msgstr "Данный вызов, унаследованный от System-V, устарел; не используйте его. В системах с I</proc> такую же информацию можно получить из I</proc/filesystems>; используйте данную возможность вместо этого вызова."

#. type: Plain text
#: man-pages/man2/sysfs.2:103
msgid ""
"There is no libc or glibc support.  There is no way to guess how large "
"I<buf> should be."
msgstr "Нет поддержки в libc и glibc. Нет способа определить необходимый размер буфера I<buf>."

#. type: TH
#: man-pages/man2/splice.2:26
#, no-wrap
msgid "SPLICE"
msgstr "SPLICE"

#. type: Plain text
#: man-pages/man2/splice.2:29
msgid "splice - splice data to/from a pipe"
msgstr "splice - подключает данные к каналу/выбирает данные из канала"

#.  Return type was long before glibc 2.7
#. type: Plain text
#: man-pages/man2/splice.2:38
#, no-wrap
msgid ""
"B<ssize_t splice(int >I<fd_in>B<, loff_t *>I<off_in>B<, int >I<fd_out>B<,>\n"
"B<               loff_t *>I<off_out>B<, size_t >I<len>B<, unsigned int >I<flags>B<);>\n"
msgstr "B<ssize_t splice(int >I<fd_in>B<, loff_t *>I<off_in>B<, int >I<fd_out>B<,>\nB<               loff_t *>I<off_out>B<, size_t >I<len>B<, unsigned int >I<flags>B<);>\n"

#. type: Plain text
#: man-pages/man2/splice.2:50
msgid ""
"B<splice>()  moves data between two file descriptors without copying between"
" kernel address space and user address space.  It transfers up to I<len> "
"bytes of data from the file descriptor I<fd_in> to the file descriptor "
"I<fd_out>, where one of the descriptors must refer to a pipe."
msgstr "Вызов B<splice>() перемещает данные между двумя файловыми дескрипторами не выполняя при этом копирование между адресным пространством пользователя и ядра. Он пересылает до I<len> байт данных из файлового дескриптора I<fd_in> в файловый дескриптор I<fd_out>, где один из дескрипторов должен ссылаться на канал."

#. type: Plain text
#: man-pages/man2/splice.2:80
msgid ""
"If I<fd_in> refers to a pipe, then I<off_in> must be NULL.  If I<fd_in> does"
" not refer to a pipe and I<off_in> is NULL, then bytes are read from "
"I<fd_in> starting from the current file offset, and the current file offset "
"is adjusted appropriately.  If I<fd_in> does not refer to a pipe and "
"I<off_in> is not NULL, then I<off_in> must point to a buffer which specifies"
" the starting offset from which bytes will be read from I<fd_in>; in this "
"case, the current file offset of I<fd_in> is not changed.  Analogous "
"statements apply for I<fd_out> and I<off_out>."
msgstr "Если I<fd_in> ссылается на канал, то значение I<off_in> должно равняться NULL. Если I<fd_in> не ссылается на канал и I<off_in> равно NULL, то чтение из I<fd_in> начинается с текущего файлового смещения, и текущее файловое смещение изменяется соответствующим образом. Если I<fd_in> не ссылается на канал и I<off_in> не равно NULL, то значение I<off_in> должно указывать на буфер со значением смещения, начиная с которого будет выполняться чтение из I<fd_in>; в этом случае текущее файловое смещение I<fd_in> не изменяется. Аналогичные правила применяются для I<fd_out> и I<off_out>."

#. type: Plain text
#: man-pages/man2/splice.2:85
msgid ""
"The I<flags> argument is a bit mask that is composed by ORing together zero "
"or more of the following values:"
msgstr "Аргумент I<flags> представляет собой битовую маску, которая составляется логическим сложением (OR) следующих значений:"

#. type: TP
#: man-pages/man2/splice.2:85
#, no-wrap
msgid "B<SPLICE_F_MOVE>"
msgstr "B<SPLICE_F_MOVE>"

#. type: Plain text
#: man-pages/man2/splice.2:98
msgid ""
"Attempt to move pages instead of copying.  This is only a hint to the "
"kernel: pages may still be copied if the kernel cannot move the pages from "
"the pipe, or if the pipe buffers don't refer to full pages.  The initial "
"implementation of this flag was buggy: therefore starting in Linux 2.6.21 it"
" is a no-op (but is still permitted in a B<splice>()  call); in the future, "
"a correct implementation may be restored."
msgstr "Пытаться переместить страницы, а не копировать их. Используется только как подсказка ядру: страницы всё равно будут копироваться, если ядро не сможет переместить страницы из канала, или если буферы канала не ссылаются на полные страницы. Первая реализация этого флага была с дефектами: поэтому начиная с Linux 2.6.21 этот флаг ни на что не влияет (но по прежнему разрешён в вызове B<splice>()); в будущем, возможно появится корректная реализация."

#. type: TP
#: man-pages/man2/splice.2:98
#, no-wrap
msgid "B<SPLICE_F_NONBLOCK>"
msgstr "B<SPLICE_F_NONBLOCK>"

#. type: Plain text
#: man-pages/man2/splice.2:107
msgid ""
"Do not block on I/O.  This makes the splice pipe operations nonblocking, but"
" B<splice>()  may nevertheless block because the file descriptors that are "
"spliced to/from may block (unless they have the B<O_NONBLOCK> flag set)."
msgstr "Не блокировать при вводе-выводе. Это делает операции соединения с каналом неблокируемыми, но B<splice>(), тем не менее, может заблокироваться, так как файловые дескрипторы, с которыми ведётся работа, могут блокироваться (если у них не установлен флаг B<O_NONBLOCK>)."

#. type: TP
#: man-pages/man2/splice.2:107
#, no-wrap
msgid "B<SPLICE_F_MORE>"
msgstr "B<SPLICE_F_MORE>"

#. type: Plain text
#: man-pages/man2/splice.2:121
msgid ""
"More data will be coming in a subsequent splice.  This is a helpful hint "
"when the I<fd_out> refers to a socket (see also the description of "
"B<MSG_MORE> in B<send>(2), and the description of B<TCP_CORK> in B<tcp>(7))"
msgstr "В следующем подключении будут дополнительные данные. Полезно указывать, когда I<fd_out> ссылается на сокет (смотрите также описание B<MSG_MORE> в B<send>(2) и описание B<TCP_CORK> в B<tcp>(7))."

#. type: TP
#: man-pages/man2/splice.2:121
#, no-wrap
msgid "B<SPLICE_F_GIFT>"
msgstr "B<SPLICE_F_GIFT>"

#. type: Plain text
#: man-pages/man2/splice.2:127
msgid "Unused for B<splice>(); see B<vmsplice>(2)."
msgstr "Не используется в B<splice>(); см. B<vmsplice>(2)."

#. type: Plain text
#: man-pages/man2/splice.2:136
msgid ""
"Upon successful completion, B<splice>()  returns the number of bytes spliced"
" to or from the pipe.  A return value of 0 means that there was no data to "
"transfer, and it would not make sense to block, because there are no writers"
" connected to the write end of the pipe referred to by I<fd_in>."
msgstr "При успешном выполнении B<splice>() возвращает количество байт, которые были записаны или получены из канала. Возвращаемое значение 0 означает, что нет данных для передачи, и блокировка не имеет смысла, так как нет процессов-писателей, подключённых к каналу для записи, на который указывает I<fd_in>."

#. type: Plain text
#: man-pages/man2/splice.2:142
msgid ""
"On error, B<splice>()  returns -1 and I<errno> is set to indicate the error."
msgstr "В случае ошибки B<splice>() возвращает -1, а I<errno> устанавливается в соответствующее значение."

#. type: Plain text
#: man-pages/man2/splice.2:149
msgid ""
"B<SPLICE_F_NONBLOCK> was specified in I<flags>, and the operation would "
"block."
msgstr ""

#. type: Plain text
#: man-pages/man2/splice.2:153
msgid ""
"One or both file descriptors are not valid, or do not have proper read-write"
" mode."
msgstr "Один или оба файловых дескриптора недействительны или в неправильном режиме чтения-записи."

#.  The append-mode error is given since 2.6.27; in earlier kernels,
#.  splice() in append mode was broken
#. type: Plain text
#: man-pages/man2/splice.2:161
msgid ""
"Target filesystem doesn't support splicing; target file is opened in append "
"mode; neither of the descriptors refers to a pipe; or offset given for "
"nonseekable device."
msgstr "Файловая система назначения не поддерживает соединение (splicing); файл назначения открыт в режиме добавления; ни один из дескрипторов не ссылается на канал; или указано смещение, но устройство не поддерживает поиск."

#. type: Plain text
#: man-pages/man2/splice.2:171
msgid ""
"Either I<off_in> or I<off_out> was not NULL, but the corresponding file "
"descriptor refers to a pipe."
msgstr "Значение I<off_in> или I<off_out> не равно NULL, но соответствующий файловый дескриптор ссылается на канал."

#. type: Plain text
#: man-pages/man2/splice.2:176
msgid ""
"The B<splice>()  system call first appeared in Linux 2.6.17; library support"
" was added to glibc in version 2.5."
msgstr "Системный вызов B<splice>() впервые появился в Linux 2.6.17; поддержка в glibc добавлена в версии 2.5."

#. type: Plain text
#: man-pages/man2/splice.2:188
msgid ""
"The three system calls B<splice>(), B<vmsplice>(2), and B<tee>(2), provide "
"user-space programs with full control over an arbitrary kernel buffer, "
"implemented within the kernel using the same type of buffer that is used for"
" a pipe.  In overview, these system calls perform the following tasks:"
msgstr "Три системных вызова — B<splice>(), B<vmsplice>(2), and B<tee>(2), предоставляют пользовательским программам полный контроль над произвольным буфером ядра; они реализованы в ядре на базе того же типа буферов, который используется для канала. Эти системные вызовы выполняют следующие задачи:"

#. type: TP
#: man-pages/man2/splice.2:188
#, no-wrap
msgid "B<splice>()"
msgstr "B<splice>()"

#. type: Plain text
#: man-pages/man2/splice.2:192
msgid ""
"moves data from the buffer to an arbitrary file descriptor, or vice versa, "
"or from one buffer to another."
msgstr "перемещает данные из буфера в произвольный файловый дескриптор или наоборот, и из одного буфера в другой."

#. type: TP
#: man-pages/man2/splice.2:192
#, no-wrap
msgid "B<tee>(2)"
msgstr "B<tee>(2)"

#. type: Plain text
#: man-pages/man2/splice.2:195
msgid "\"copies\" the data from one buffer to another."
msgstr "«копирует» данные из одного буфера в другой."

#. type: TP
#: man-pages/man2/splice.2:195
#, no-wrap
msgid "B<vmsplice>(2)"
msgstr "B<vmsplice>(2)"

#. type: Plain text
#: man-pages/man2/splice.2:198
msgid "\"copies\" data from user space into the buffer."
msgstr "«копирует» данные из пользовательского пространства в буфер."

#.  Linus: Now, imagine using the above in a media server, for example.
#.  Let's say that a year or two has passed, so that the video drivers
#.  have been updated to be able to do the splice thing, and what can
#.  you do? You can:
#.  - splice from the (mpeg or whatever - let's just assume that the video
#.    input is either digital or does the encoding on its own - like they
#.    pretty much all do) video input into a pipe (remember: no copies - the
#.    video input will just DMA directly into memory, and splice will just
#.    set up the pages in the pipe buffer)
#.  - tee that pipe to split it up
#.  - splice one end to a file (ie "save the compressed stream to disk")
#.  - splice the other end to a real-time video decoder window for your
#.    real-time viewing pleasure.
#.  Linus: Now, the advantage of splice()/tee() is that you can
#.  do zero-copy movement of data, and unlike sendfile() you can
#.  do it on _arbitrary_ data (and, as shown by "tee()", it's more
#.  than just sending the data to somebody else: you can duplicate
#.  the data and choose to forward it to two or more different
#.  users - for things like logging etc.).
#. type: Plain text
#: man-pages/man2/splice.2:229
msgid ""
"Though we talk of copying, actual copies are generally avoided.  The kernel "
"does this by implementing a pipe buffer as a set of reference-counted "
"pointers to pages of kernel memory.  The kernel creates \"copies\" of pages "
"in a buffer by creating new pointers (for the output buffer) referring to "
"the pages, and increasing the reference counts for the pages: only pointers "
"are copied, not the pages of the buffer."
msgstr "Хотя мы говорим о копировании, на самом деле копирования, обычно, не происходит. Ядро реализует канальный буфер как набор указателей со счётчиком ссылок на страницы памяти ядра. Ядро создаёт «копии» страниц в буфере посредством создания новых указателей (для выходного буфера), указывающих на страницы, и увеличивает счётчики ссылок страниц: копируются только указатели, а не страницы буфера."

#. type: Plain text
#: man-pages/man2/splice.2:232
msgid "See B<tee>(2)."
msgstr "См. B<tee>(2)."

#. type: Plain text
#: man-pages/man2/splice.2:235
msgid "B<sendfile>(2), B<tee>(2), B<vmsplice>(2)"
msgstr "B<sendfile>(2), B<tee>(2), B<vmsplice>(2)"

#. type: TH
#: man-pages/man2/spu_run.2:26
#, no-wrap
msgid "SPU_RUN"
msgstr "SPU_RUN"

#. type: Plain text
#: man-pages/man2/spu_run.2:29
msgid "spu_run - execute an SPU context"
msgstr "spu_run - выполняет контекст SPU"

#. type: Plain text
#: man-pages/man2/spu_run.2:32
#, no-wrap
msgid "B<#include E<lt>sys/spu.hE<gt>>\n"
msgstr "B<#include E<lt>sys/spu.hE<gt>>\n"

#. type: Plain text
#: man-pages/man2/spu_run.2:35
#, no-wrap
msgid ""
"B<int spu_run(int >I<fd>B<, unsigned int *>I<npc>B<, unsigned int "
"*>I<event>B<);>\n"
msgstr "B<int spu_run(int >I<fd>B<, unsigned int *>I<npc>B<, unsigned int *>I<event>B<);>\n"

#. type: Plain text
#: man-pages/man2/spu_run.2:53
msgid ""
"The B<spu_run>()  system call is used on PowerPC machines that implement the"
" Cell Broadband Engine Architecture in order to access Synergistic Processor"
" Units (SPUs).  The I<fd> argument is a file descriptor returned by "
"B<spu_create>(2)  that refers to a specific SPU context.  When the context "
"gets scheduled to a physical SPU, it starts execution at the instruction "
"pointer passed in I<npc>."
msgstr "Системный вызов B<spu_run>() используется на машинах PowerPC с архитектурой Cell Broadband Engine для получения доступа к Synergistic Processor Unit (SPU). Аргумент I<fd> представляет собой файловый дескриптор, возвращаемый вызовом B<spu_create>(2) и указывающий на определённый контекст SPU. Когда контекст планируется на физическом SPU, он запускается на выполнение начиная с инструкции, на которую указывает значение I<npc>."

#. type: Plain text
#: man-pages/man2/spu_run.2:62
msgid ""
"Execution of SPU code happens synchronously, meaning that B<spu_run>()  "
"blocks while the SPU is still running.  If there is a need to execute SPU "
"code in parallel with other code on either the main CPU or other SPUs, a new"
" thread of execution must be created first (e.g., using "
"B<pthread_create>(3))."
msgstr "Выполнение кода SPU происходит синхронно, то есть B<spu_run>() блокируется на время работы SPU. Если требуется параллельное выполнение кода SPU и кода на основном процессоре или других SPU, то сначала нужно создать новую нить выполнения (например с помощью B<pthread_create>(3))."

#. type: Plain text
#: man-pages/man2/spu_run.2:72
msgid ""
"When B<spu_run>()  returns, the current value of the SPU program counter is "
"written to I<npc>, so successive calls to B<spu_run>()  can use the same "
"I<npc> pointer."
msgstr "При завершении работы B<spu_run>() текущее значение программного счётчика SPU записывается в I<npc>, что позволяет использовать тот же указатель I<npc> в последующих вызовах B<spu_run>()."

#. type: Plain text
#: man-pages/man2/spu_run.2:82
msgid ""
"The I<event> argument provides a buffer for an extended status code.  If the"
" SPU context was created with the B<SPU_CREATE_EVENTS_ENABLED> flag, then "
"this buffer is populated by the Linux kernel before B<spu_run>()  returns."
msgstr "В аргументе I<event> указывается буфер для расширенного кода состояния. Если контекст SPU создан с флагом B<SPU_CREATE_EVENTS_ENABLED>, то ядро Linux заполняет этот буфер перед возвратом из B<spu_run>()."

#. type: Plain text
#: man-pages/man2/spu_run.2:84
msgid "The status code may be one (or more) of the following constants:"
msgstr "Код состояния может быть одной (или несколькими) из следующих констант:"

#. type: TP
#: man-pages/man2/spu_run.2:84
#, no-wrap
msgid "B<SPE_EVENT_DMA_ALIGNMENT>"
msgstr "B<SPE_EVENT_DMA_ALIGNMENT>"

#. type: Plain text
#: man-pages/man2/spu_run.2:87
msgid "A DMA alignment error occurred."
msgstr "Произошла ошибка выравнивания DMA."

#. type: TP
#: man-pages/man2/spu_run.2:87
#, no-wrap
msgid "B<SPE_EVENT_INVALID_DMA>"
msgstr "B<SPE_EVENT_INVALID_DMA>"

#. type: Plain text
#: man-pages/man2/spu_run.2:90
msgid "An invalid MFC DMA command was attempted."
msgstr "Попытка выполнить неверную команду MFC DMA."

#. type: TP
#: man-pages/man2/spu_run.2:90
#, no-wrap
msgid "B<SPE_EVENT_SPE_DATA_STORAGE>"
msgstr "B<SPE_EVENT_SPE_DATA_STORAGE>"

#. type: Plain text
#: man-pages/man2/spu_run.2:93
msgid "A DMA storage error occurred."
msgstr "Произошла ошибка хранилища DMA."

#. type: TP
#: man-pages/man2/spu_run.2:93
#, no-wrap
msgid "B<SPE_EVENT_SPE_ERROR>"
msgstr "B<SPE_EVENT_SPE_ERROR>"

#. type: Plain text
#: man-pages/man2/spu_run.2:96
msgid "An illegal instruction was executed."
msgstr "Выполнена недопустимая инструкция."

#. type: Plain text
#: man-pages/man2/spu_run.2:102
msgid ""
"NULL is a valid value for the I<event> argument.  In this case, the events "
"will not be reported to the calling process."
msgstr "Для аргумента I<event> допускается значение NULL. В этом случае информация о событиях не будет поступать в вызывающий процесс."

#. type: Plain text
#: man-pages/man2/spu_run.2:111
msgid ""
"On success, B<spu_run>()  returns the value of the I<spu_status> register.  "
"On error, it returns -1 and sets I<errno> to one of the error codes listed "
"below."
msgstr "При успешном выполнении B<spu_run>() возвращается значение регистра I<spu_status>. При ошибке возвращается -1, а в I<errno> содержится один из кодов ошибки, описанных далее."

#. type: Plain text
#: man-pages/man2/spu_run.2:120
msgid ""
"The I<spu_status> register value is a bit mask of status codes and "
"optionally a 14-bit code returned from the B<stop-and-signal> instruction on"
" the SPU.  The bit masks for the status codes are:"
msgstr "Значение регистра I<spu_status> представляет собой битовую маску кодов состояния и необязательный 14-битный код, возвращаемый при выполнении инструкции B<stop-and-signal> SPU. Битовые маски кодов состояний:"

#. type: TP
#: man-pages/man2/spu_run.2:120
#, no-wrap
msgid "B<0x02>"
msgstr "B<0x02>"

#. type: Plain text
#: man-pages/man2/spu_run.2:125
msgid "SPU was stopped by a B<stop-and-signal> instruction."
msgstr "SPU остановлен инструкцией B<stop-and-signal>."

#. type: TP
#: man-pages/man2/spu_run.2:125
#, no-wrap
msgid "B<0x04>"
msgstr "B<0x04>"

#. type: Plain text
#: man-pages/man2/spu_run.2:130
msgid "SPU was stopped by a B<halt> instruction."
msgstr "SPU остановлен инструкцией B<halt>."

#. type: TP
#: man-pages/man2/spu_run.2:130
#, no-wrap
msgid "B<0x08>"
msgstr "B<0x08>"

#. type: Plain text
#: man-pages/man2/spu_run.2:133
msgid "SPU is waiting for a channel."
msgstr "SPU ожидает канала."

#. type: TP
#: man-pages/man2/spu_run.2:133
#, no-wrap
msgid "B<0x10>"
msgstr "B<0x10>"

#. type: Plain text
#: man-pages/man2/spu_run.2:136
msgid "SPU is in single-step mode."
msgstr "SPU в пошаговом режиме."

#. type: TP
#: man-pages/man2/spu_run.2:136
#, no-wrap
msgid "B<0x20>"
msgstr "B<0x20>"

#. type: Plain text
#: man-pages/man2/spu_run.2:139
msgid "SPU has tried to execute an invalid instruction."
msgstr "SPU пытался выполнить неверную инструкцию."

#. type: TP
#: man-pages/man2/spu_run.2:139
#, no-wrap
msgid "B<0x40>"
msgstr "B<0x40>"

#. type: Plain text
#: man-pages/man2/spu_run.2:142
msgid "SPU has tried to access an invalid channel."
msgstr "SPU пытался получить доступ к неверному каналу."

#. type: TP
#: man-pages/man2/spu_run.2:142
#, no-wrap
msgid "B<0x3fff0000>"
msgstr "B<0x3fff0000>"

#. type: Plain text
#: man-pages/man2/spu_run.2:148
msgid ""
"The bits masked with this value contain the code returned from a B<stop-and-"
"signal> instruction.  These bits are valid only if the 0x02 bit is set."
msgstr "При наложении этой маски получается код, возвращаемый инструкцией B<stop-and-signal>. Полученные биты корректны только, если установлен бит 0x02."

#. type: Plain text
#: man-pages/man2/spu_run.2:153
msgid ""
"If B<spu_run>()  has not returned an error, one or more bits among the lower"
" eight ones are always set."
msgstr "Если B<spu_run>() не вернул ошибку, то один или более младших восьми битов всегда установлены."

#. type: Plain text
#: man-pages/man2/spu_run.2:164
msgid ""
"I<npc> is not a valid pointer, or I<event> is non-NULL and an invalid "
"pointer."
msgstr "Задан неправильный указатель в I<npc> или значение I<event> не равно NULL и является неправильным указателем."

#. type: Plain text
#: man-pages/man2/spu_run.2:174
msgid ""
"A signal occurred while B<spu_run>()  was in progress; see B<signal>(7).  "
"The I<npc> value has been updated to the new program counter value if "
"necessary."
msgstr "При выполнении B<spu_run>() получен сигнал; см. B<signal>(7). При необходимости, значение I<npc> обновляется до нового значения программного счётчика."

#. type: Plain text
#: man-pages/man2/spu_run.2:179
msgid "I<fd> is not a valid file descriptor returned from B<spu_create>(2)."
msgstr "Значение I<fd> не является правильным файловым дескриптором, возвращённым B<spu_create>(2)."

#. type: Plain text
#: man-pages/man2/spu_run.2:183
msgid ""
"There was not enough memory available to handle a page fault resulting from "
"a Memory Flow Controller (MFC) direct memory access."
msgstr "Недостаточно памяти для обработки страничного сбоя в результате прямого доступа Memory Flow Controller (MFC)."

#. type: Plain text
#: man-pages/man2/spu_run.2:192
msgid "The B<spu_run>()  system call was added to Linux in kernel 2.6.16."
msgstr "Системный вызов B<spu_run>() был добавлен в ядро Linux версии 2.6.16."

#. type: Plain text
#: man-pages/man2/spu_run.2:196
msgid ""
"This call is Linux-specific and implemented only by the PowerPC "
"architecture.  Programs using this system call are not portable."
msgstr "Данный вызов существует только в Linux и реализован только для архитектуры PowerPC. Программы, использующие данный вызов, не переносимы."

#. type: Plain text
#: man-pages/man2/spu_run.2:207
msgid ""
"Glibc does not provide a wrapper for this system call; call it using "
"B<syscall>(2).  Note however, that B<spu_run>()  is meant to be used from "
"libraries that implement a more abstract interface to SPUs, not to be used "
"from regular applications.  See E<.UR "
"http://www.bsc.es\\:/projects\\:/deepcomputing\\:/linuxoncell/> E<.UE> for "
"the recommended libraries."
msgstr "В glibc нет обёртки для этого системного вызова; запускайте его с помощью B<syscall>(2). Однако заметим, что B<spu_run>() предназначен для работы в библиотеках, которые реализуют более абстрактный интерфейс к SPU и не должен вызываться из обычных приложений. Рекомендуемые библиотеки приведены на странице E<.UR http://www.bsc.es\\:/projects\\:/deepcomputing\\:/linuxoncell/> E<.UE .>"

#. type: Plain text
#: man-pages/man2/spu_run.2:212
msgid ""
"The following is an example of running a simple, one-instruction SPU program"
" with the B<spu_run>()  system call."
msgstr "В следующем примере реализована простая программа, состоящая из одной инструкции SPU и системного вызова B<spu_run>()."

#. type: Plain text
#: man-pages/man2/spu_run.2:220
#, no-wrap
msgid ""
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdint.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>sys/types.hE<gt>\n"
"#include E<lt>fcntl.hE<gt>\n"
msgstr "#include E<lt>stdlib.hE<gt>\n#include E<lt>stdint.hE<gt>\n#include E<lt>unistd.hE<gt>\n#include E<lt>stdio.hE<gt>\n#include E<lt>sys/types.hE<gt>\n#include E<lt>fcntl.hE<gt>\n"

#. type: Plain text
#: man-pages/man2/spu_run.2:223
#, no-wrap
msgid ""
"#define handle_error(msg) \\e\n"
"    do { perror(msg); exit(EXIT_FAILURE); } while (0)\n"
msgstr "#define handle_error(msg) \\e\n    do { perror(msg); exit(EXIT_FAILURE); } while (0)\n"

#. type: Plain text
#: man-pages/man2/spu_run.2:228
#, no-wrap
msgid ""
"int main(void)\n"
"{\n"
"    int context, fd, spu_status;\n"
"    uint32_t instruction, npc;\n"
msgstr "int main(void)\n{\n    int context, fd, spu_status;\n    uint32_t instruction, npc;\n"

#. type: Plain text
#: man-pages/man2/spu_run.2:232
#, no-wrap
msgid ""
"    context = spu_create(\"/spu/example-context\", 0, 0755);\n"
"    if (context == -1)\n"
"        handle_error(\"spu_create\");\n"
msgstr "    context = spu_create(\"/spu/example-context\", 0, 0755);\n    if (context == -1)\n        handle_error(\"spu_create\");\n"

#. type: Plain text
#: man-pages/man2/spu_run.2:237
#, no-wrap
msgid ""
"    /* write a \\(aqstop 0x1234\\(aq instruction to the SPU\\(aqs\n"
"     * local store memory\n"
"     */\n"
"    instruction = 0x00001234;\n"
msgstr "    /* записать инструкцию \\(aqstop 0x1234\\(aq в локальное хранилище\n       памяти SPU\n     */\n    instruction = 0x00001234;\n"

#. type: Plain text
#: man-pages/man2/spu_run.2:242
#, no-wrap
msgid ""
"    fd = open(\"/spu/example-context/mem\", O_RDWR);\n"
"    if (fd == -1)\n"
"        handle_error(\"open\");\n"
"    write(fd, &instruction, sizeof(instruction));\n"
msgstr "    fd = open(\"/spu/example-context/mem\", O_RDWR);\n    if (fd == -1)\n        handle_error(\"open\");\n    write(fd, &instruction, sizeof(instruction));\n"

#. type: Plain text
#: man-pages/man2/spu_run.2:248
#, no-wrap
msgid ""
"    /* set npc to the starting instruction address of the\n"
"     * SPU program. Since we wrote the instruction at the\n"
"     * start of the mem file, the entry point will be 0x0\n"
"     */\n"
"    npc = 0;\n"
msgstr "    /* присвоить npc адрес начальной инструкции программы\n     * SPU. Так как мы записали инструкцию в начало\n     * файла mem, точка входа будет равна 0x0\n     */\n    npc = 0;\n"

#. type: Plain text
#: man-pages/man2/spu_run.2:252
#, no-wrap
msgid ""
"    spu_status = spu_run(context, &npc, NULL);\n"
"    if (spu_status == -1)\n"
"        handle_error(\"open\");\n"
msgstr "    spu_status = spu_run(context, &npc, NULL);\n    if (spu_status == -1)\n        handle_error(\"open\");\n"

#. type: Plain text
#: man-pages/man2/spu_run.2:258
#, no-wrap
msgid ""
"    /* we should see a status code of 0x1234002:\n"
"     *   0x00000002 (spu was stopped due to stop-and-signal)\n"
"     * | 0x12340000 (the stop-and-signal code)\n"
"     */\n"
"    printf(\"SPU Status: 0x%08x\\en\", spu_status);\n"
msgstr "    /* мы должны получить код состояния 0x1234002:\n     *   0x00000002 (spu остановлен из-за stop-and-signal)\n     * | 0x12340000 (код stop-and-signal)\n     */\n    printf(\"Состояние SPU: 0x%08x\\en\", spu_status);\n"

#. type: Plain text
#: man-pages/man2/spu_run.2:268
msgid "B<close>(2), B<spu_create>(2), B<capabilities>(7), B<spufs>(7)"
msgstr "B<close>(2), B<spu_create>(2), B<capabilities>(7), B<spufs>(7)"

#. type: TH
#: man-pages/man2/signalfd.2:20
#, no-wrap
msgid "SIGNALFD"
msgstr "SIGNALFD"

#. type: Plain text
#: man-pages/man2/signalfd.2:23
msgid "signalfd - create a file descriptor for accepting signals"
msgstr "signalfd - создаёт файловый дескриптор для приёма сигналов"

#. type: Plain text
#: man-pages/man2/signalfd.2:25
msgid "B<#include E<lt>sys/signalfd.hE<gt>>"
msgstr "B<#include E<lt>sys/signalfd.hE<gt>>"

#. type: Plain text
#: man-pages/man2/signalfd.2:27
msgid ""
"B<int signalfd(int >I<fd>B<, const sigset_t *>I<mask>B<, int >I<flags>B<);>"
msgstr "B<int signalfd(int >I<fd>B<, const sigset_t *>I<mask>B<, int >I<flags>B<);>"

#. type: Plain text
#: man-pages/man2/signalfd.2:38
msgid ""
"B<signalfd>()  creates a file descriptor that can be used to accept signals "
"targeted at the caller.  This provides an alternative to the use of a signal"
" handler or B<sigwaitinfo>(2), and has the advantage that the file "
"descriptor may be monitored by B<select>(2), B<poll>(2), and B<epoll>(7)."
msgstr "Вызов B<signalfd>() создаёт файловый дескриптор, который можно использовать для приёма сигналов, предназначенных вызывающему. Его можно использовать как замену обработчику сигналов или B<sigwaitinfo>(2); преимущество в том, что за файловым дескриптором можно следить с помощью B<select>(2), B<poll>(2) и B<epoll>(7)."

#. type: Plain text
#: man-pages/man2/signalfd.2:58
msgid ""
"The I<mask> argument specifies the set of signals that the caller wishes to "
"accept via the file descriptor.  This argument is a signal set whose "
"contents can be initialized using the macros described in B<sigsetops>(3).  "
"Normally, the set of signals to be received via the file descriptor should "
"be blocked using B<sigprocmask>(2), to prevent the signals being handled "
"according to their default dispositions.  It is not possible to receive "
"B<SIGKILL> or B<SIGSTOP> signals via a signalfd file descriptor; these "
"signals are silently ignored if specified in I<mask>."
msgstr "В аргументе I<mask> указывается набор сигналов, который вызывающий хочет принимать через файловый дескриптор. Этот аргумент, содержащий набор сигналов, можно инициализировать с помощью макросов, описанных в B<sigsetops>(3). Обычно, набор сигналов, принимаемых через файловый дескриптор, должен блокироваться с помощью B<sigprocmask>(2), чтобы предотвратить обработку сигналов назначенными им обработчиками по умолчанию. Через файловый дескриптор signalfd нельзя получить сигнал B<SIGKILL> или B<SIGSTOP>; при указании их в I<mask> они просто игнорируются."

#. type: Plain text
#: man-pages/man2/signalfd.2:72
msgid ""
"If the I<fd> argument is -1, then the call creates a new file descriptor and"
" associates the signal set specified in I<mask> with that descriptor.  If "
"I<fd> is not -1, then it must specify a valid existing signalfd file "
"descriptor, and I<mask> is used to replace the signal set associated with "
"that descriptor."
msgstr "Если значение аргумента I<fd> равно -1, то вызов создаёт новый файловый дескриптор и связывает с ним набор сигналов, указанный в I<mask>. Если I<fd> не равно -1, то в нём должен быть указан допустимый существующий файловый дескриптор signalfd, а значение I<mask> используется для замены набора сигналов, связанного с этим файловым дескриптором."

#. type: Plain text
#: man-pages/man2/signalfd.2:77
msgid ""
"Starting with Linux 2.6.27, the following values may be bitwise ORed in "
"I<flags> to change the behavior of B<signalfd>():"
msgstr ""

#. type: TP
#: man-pages/man2/signalfd.2:77
#, no-wrap
msgid "B<SFD_NONBLOCK>"
msgstr "B<SFD_NONBLOCK>"

#. type: TP
#: man-pages/man2/signalfd.2:85
#, no-wrap
msgid "B<SFD_CLOEXEC>"
msgstr "B<SFD_CLOEXEC>"

#. type: Plain text
#: man-pages/man2/signalfd.2:99
msgid ""
"In Linux up to version 2.6.26, the I<flags> argument is unused, and must be "
"specified as zero."
msgstr "До версии Linux 2.6.26 аргумент I<flags> не использовался, и должен быть равен нулю."

#. type: Plain text
#: man-pages/man2/signalfd.2:102
msgid ""
"B<signalfd>()  returns a file descriptor that supports the following "
"operations:"
msgstr "Вызов B<signalfd>() возвращает файловый дескриптор, который поддерживает следующие операции:"

#. type: Plain text
#: man-pages/man2/signalfd.2:121
msgid ""
"If one or more of the signals specified in I<mask> is pending for the "
"process, then the buffer supplied to B<read>(2)  is used to return one or "
"more I<signalfd_siginfo> structures (see below) that describe the signals.  "
"The B<read>(2)  returns information for as many signals as are pending and "
"will fit in the supplied buffer.  The buffer must be at least "
"I<sizeof(struct signalfd_siginfo)> bytes.  The return value of the "
"B<read>(2)  is the total number of bytes read."
msgstr "Если один или несколько сигналов, указанных в I<mask>, ожидают обработки, то буфер, указанный в B<read>(2), используется для возврата одной или нескольких структур I<signalfd_siginfo> (см. ниже), описывающих сигналы. Вызов B<read>(2) возвращает информацию о всех ожидающих сигналах, которые поместились в предоставленный буфер. Размер буфера должен быть не менее I<sizeof(struct signalfd_siginfo)> байт. Возвращаемое B<read>(2) значение представляет собой общее количество прочитанных байт."

#. type: Plain text
#: man-pages/man2/signalfd.2:129
msgid ""
"As a consequence of the B<read>(2), the signals are consumed, so that they "
"are no longer pending for the process (i.e., will not be caught by signal "
"handlers, and cannot be accepted using B<sigwaitinfo>(2))."
msgstr "После выполнения B<read>(2) сигналы считаются учтёнными, они больше не считаются ожидающими обработки (т.е., они не будут переданы обработчикам сигналов и не могут быть приняты с помощью B<sigwaitinfo>(2))."

#. type: Plain text
#: man-pages/man2/signalfd.2:140
msgid ""
"If none of the signals in I<mask> is pending for the process, then the "
"B<read>(2)  either blocks until one of the signals in I<mask> is generated "
"for the process, or fails with the error B<EAGAIN> if the file descriptor "
"has been made nonblocking."
msgstr "Если ни один из сигналов из I<mask> не ожидает обработки, то вызов B<read>(2) или блокируется до поступления сигналов согласно I<mask>, или завершается с ошибкой B<EAGAIN>, если файловый дескриптор помечен как неблокируемый."

#. type: TP
#: man-pages/man2/signalfd.2:140
#, no-wrap
msgid "B<poll>(2), B<select>(2) (and similar)"
msgstr "B<poll>(2), B<select>(2) (и подобные)"

#. type: Plain text
#: man-pages/man2/signalfd.2:153
msgid ""
"The file descriptor is readable (the B<select>(2)  I<readfds> argument; the "
"B<poll>(2)  B<POLLIN> flag)  if one or more of the signals in I<mask> is "
"pending for the process."
msgstr "Файловый дескриптор доступен для чтения (в B<select>(2) аргумент I<readfds>; в B<poll>(2) флаг B<POLLIN>), если один или более сигналов из I<mask> ожидают обработки."

#. type: Plain text
#: man-pages/man2/signalfd.2:160
msgid ""
"The signalfd file descriptor also supports the other file-descriptor "
"multiplexing APIs: B<pselect>(2), B<ppoll>(2), and B<epoll>(7)."
msgstr "Файловый дескриптор signalfd также поддерживает другие мультиплексные вызовы: B<pselect>(2), B<ppoll>(2) и B<epoll>(7)."

#. type: Plain text
#: man-pages/man2/signalfd.2:165
msgid ""
"When the file descriptor is no longer required it should be closed.  When "
"all file descriptors associated with the same signalfd object have been "
"closed, the resources for object are freed by the kernel."
msgstr "Если файловый дескриптор больше не требуется, его нужно закрыть. Когда все файловые дескрипторы, связанные с одним объектом signalfd, будут закрыты, ядро освобождает ресурсы объекта."

#. type: SS
#: man-pages/man2/signalfd.2:165
#, no-wrap
msgid "The signalfd_siginfo structure"
msgstr "Структура signalfd_siginfo"

#. type: Plain text
#: man-pages/man2/signalfd.2:171
msgid ""
"The format of the I<signalfd_siginfo> structure(s) returned by B<read>(2)s "
"from a signalfd file descriptor is as follows:"
msgstr "Формат структур(ы) I<signalfd_siginfo>, возвращаемых B<read>(2) из файлового дескриптора signalfd, имеет следующий вид:"

#.  ssi_trapno is unused on most arches
#.  FIXME Since Linux 2.6.37 there is 'uint16_t ssi_addr_lsb'
#.  which is not yet documented
#. type: Plain text
#: man-pages/man2/signalfd.2:198
#, no-wrap
msgid ""
"struct signalfd_siginfo {\n"
"    uint32_t ssi_signo;   /* Signal number */\n"
"    int32_t  ssi_errno;   /* Error number (unused) */\n"
"    int32_t  ssi_code;    /* Signal code */\n"
"    uint32_t ssi_pid;     /* PID of sender */\n"
"    uint32_t ssi_uid;     /* Real UID of sender */\n"
"    int32_t  ssi_fd;      /* File descriptor (SIGIO) */\n"
"    uint32_t ssi_tid;     /* Kernel timer ID (POSIX timers)\n"
"    uint32_t ssi_band;    /* Band event (SIGIO) */\n"
"    uint32_t ssi_overrun; /* POSIX timer overrun count */\n"
"    uint32_t ssi_trapno;  /* Trap number that caused signal */\n"
"    int32_t  ssi_status;  /* Exit status or signal (SIGCHLD) */\n"
"    int32_t  ssi_int;     /* Integer sent by sigqueue(3) */\n"
"    uint64_t ssi_ptr;     /* Pointer sent by sigqueue(3) */\n"
"    uint64_t ssi_utime;   /* User CPU time consumed (SIGCHLD) */\n"
"    uint64_t ssi_stime;   /* System CPU time consumed (SIGCHLD) */\n"
"    uint64_t ssi_addr;    /* Address that generated signal\n"
"                             (for hardware-generated signals) */\n"
"    uint8_t  pad[I<X>];      /* Pad size to 128 bytes (allow for\n"
"                              additional fields in the future) */\n"
"};\n"
msgstr "struct signalfd_siginfo {\n    uint33_t ssi_signo;   /* номер сигнала */\n    int33_t  ssi_errno;   /* номер ошибки (не используется) */\n    int32_t  ssi_code;    /* код сигнала */\n    uint32_t ssi_pid;     /* PID отправителя */\n    uint32_t ssi_uid;     /* реальный UID отправителя */\n    int32_t  ssi_fd;      /* файловый дескриптор (SIGIO) */\n    uint32_t ssi_tid;     /* ID таймера ядра (таймеры POSIX)\n    uint32_t ssi_band;    /* внутреннее событие (SIGIO) */\n    uint32_t ssi_overrun; /* счётчик переполнений таймера POSIX */\n    uint32_t ssi_trapno;  /* номер ловушки, поймавшей сигнал */\n    int32_t  ssi_status;  /* код выхода или сигнала (SIGCHLD) */\n    int32_t  ssi_int;     /* целое, посланное sigqueue(3) */\n    uint64_t ssi_ptr;     /* указатель, посланный sigqueue(3) */\n    uint64_t ssi_utime;   /* пользовательское потреблённое\n                             время ЦП (SIGCHLD) */\n    uint64_t ssi_stime;   /* системное потреблённое\n                             время ЦП (SIGCHLD) */\n    uint64_t ssi_addr;    /* сгенерированный сигналом адрес\n                              (для сигналов аппаратуры) */\n    uint8_t  pad[I<X>];      /* заполнитель до 128 байт (для\n                              будущих дополнительных полей) */\n};\n"

#. type: Plain text
#: man-pages/man2/signalfd.2:221
msgid ""
"Each of the fields in this structure is analogous to the similarly named "
"field in the I<siginfo_t> structure.  The I<siginfo_t> structure is "
"described in B<sigaction>(2).  Not all fields in the returned "
"I<signalfd_siginfo> structure will be valid for a specific signal; the set "
"of valid fields can be determined from the value returned in the I<ssi_code>"
" field.  This field is the analog of the I<siginfo_t> I<si_code> field; see "
"B<sigaction>(2)  for details."
msgstr "Каждое из полей в этой структуре аналогично полям с тем же именем в структуре I<siginfo_t>. Структура I<siginfo_t> описана в B<sigaction>(2). Не все поля в возвращаемой структуре I<signalfd_siginfo> будут заполнены правильно для каждого сигнала; набор допустимых полей можно определить по значению, возвращённому в поле I<ssi_code>. Это поле является аналогом поля I<si_code> в I<siginfo_t>; подробней смотрите в B<sigaction>(2)."

#. type: SS
#: man-pages/man2/signalfd.2:221
#, no-wrap
msgid "fork(2) semantics"
msgstr "Поведение при fork(2)"

#. type: Plain text
#: man-pages/man2/signalfd.2:229
msgid ""
"After a B<fork>(2), the child inherits a copy of the signalfd file "
"descriptor.  A B<read>(2)  from the file descriptor in the child will return"
" information about signals queued to the child."
msgstr "После вызова B<fork>(2) потомок наследует копию файлового дескриптора signalfd. Вызов B<read>(2) для файлового дескриптора в потомке вернёт информацию о сигналах для потомка."

#. type: SS
#: man-pages/man2/signalfd.2:229
#, no-wrap
msgid "execve(2) semantics"
msgstr "Поведение при execve(2)"

#. type: Plain text
#: man-pages/man2/signalfd.2:241
msgid ""
"Just like any other file descriptor, a signalfd file descriptor remains open"
" across an B<execve>(2), unless it has been marked for close-on-exec (see "
"B<fcntl>(2)).  Any signals that were available for reading before the "
"B<execve>(2)  remain available to the newly loaded program.  (This is "
"analogous to traditional signal semantics, where a blocked signal that is "
"pending remains pending across an B<execve>(2).)"
msgstr "Как и любой файловый дескриптор, файловый дескриптор signalfd остаётся открытым после B<execve>(2), если он не помечен как close-on-exec (см. B<fcntl>(2)). Все сигналы, которые были доступны для чтения перед B<execve>(2), остаются доступными и для новой загруженной программы (аналогично обычному поведению сигналов, когда блокированный сигнал, ожидающий обработки, остаётся в очереди ожидания после B<execve>(2))."

#. type: SS
#: man-pages/man2/signalfd.2:241
#, no-wrap
msgid "Thread semantics"
msgstr "Поведение в нитях"

#. type: Plain text
#: man-pages/man2/signalfd.2:251
msgid ""
"The semantics of signalfd file descriptors in a multithreaded program mirror"
" the standard semantics for signals.  In other words, when a thread reads "
"from a signalfd file descriptor, it will read the signals that are directed "
"to the thread itself and the signals that are directed to the process (i.e.,"
" the entire thread group).  (A thread will not be able to read signals that "
"are directed to other threads in the process.)"
msgstr "Поведение файловых дескрипторов signalfd в многонитиевых программах отражает стандартное поведение сигналов. Иначе говоря, когда нить выполняет чтение из файлового дескриптора signalfd, она прочтёт сигналы, которые предназначены самой нити и сигналы, предназначенные процессу (т.е., всей группе нитей). Нить не может прочитать сигналы, которые предназначены другим нитям процесса."

#. type: Plain text
#: man-pages/man2/signalfd.2:265
msgid ""
"On success, B<signalfd>()  returns a signalfd file descriptor; this is "
"either a new file descriptor (if I<fd> was -1), or I<fd> if I<fd> was a "
"valid signalfd file descriptor.  On error, -1 is returned and I<errno> is "
"set to indicate the error."
msgstr "При успешном выполнении B<signalfd>() возвращает файловый дескриптор signalfd; это будет или новый файловый дескриптор (если I<fd> равно -1), или I<fd>, если I<fd> содержит допустимый файловый дескриптор signalfd. При ошибке возвращается -1, а I<errno> присваивается соответствующее значение."

#. type: Plain text
#: man-pages/man2/signalfd.2:271
msgid "The I<fd> file descriptor is not a valid file descriptor."
msgstr "Неправильный файловый дескриптор в I<fd>."

#.  or, the
#.  .I sizemask
#.  argument is not equal to
#.  .IR sizeof(sigset_t) ;
#. type: Plain text
#: man-pages/man2/signalfd.2:279
msgid "I<fd> is not a valid signalfd file descriptor."
msgstr "Значение I<fd> не является правильным файловым дескриптором signalfd."

#. type: Plain text
#: man-pages/man2/signalfd.2:286
msgid ""
"I<flags> is invalid; or, in Linux 2.6.26 or earlier, I<flags> is nonzero."
msgstr "Неправильное значение I<flags> или, для Linux 2.6.26 и старее, I<flags> не равно 0."

#. type: Plain text
#: man-pages/man2/signalfd.2:289
msgid "The per-process limit of open file descriptors has been reached."
msgstr "Было достигнуто ограничение по открытым файловым дескриптором на процесс."

#. type: Plain text
#: man-pages/man2/signalfd.2:293
msgid ""
"The system-wide limit on the total number of open files has been reached."
msgstr "Достигнуто максимальное количество открытых файлов в системе."

#. type: Plain text
#: man-pages/man2/signalfd.2:296
msgid "Could not mount (internal) anonymous inode device."
msgstr "Не удалось смонтировать (внутреннее) безымянное устройство inode."

#. type: Plain text
#: man-pages/man2/signalfd.2:299
msgid ""
"There was insufficient memory to create a new signalfd file descriptor."
msgstr "Недостаточно памяти для создания нового файлового дескриптора signalfd."

#.  signalfd() is in glibc 2.7, but reportedly does not build
#. type: Plain text
#: man-pages/man2/signalfd.2:307
msgid ""
"B<signalfd>()  is available on Linux since kernel 2.6.22.  Working support "
"is provided in glibc since version 2.8.  The B<signalfd4>()  system call "
"(see NOTES) is available on Linux since kernel 2.6.27."
msgstr "Вызов B<signalfd>() доступен в Linux, начиная с ядра 2.6.22. Поддержка в glibc появилась в версии 2.8. Системный вызов B<signalfd4>() (см. ЗАМЕЧАНИЯ) доступен в Linux, начиная с ядра 2.6.27."

#. type: Plain text
#: man-pages/man2/signalfd.2:312
msgid "B<signalfd>()  and B<signalfd4>()  are Linux-specific."
msgstr "Вызовы B<signalfd>() и B<signalfd4>() есть только в Linux."

#. type: Plain text
#: man-pages/man2/signalfd.2:322
msgid ""
"The underlying Linux system call requires an additional argument, I<size_t "
"sizemask>, which specifies the size of the I<mask> argument.  The glibc "
"B<signalfd>()  wrapper function does not include this argument, since it "
"provides the required value for the underlying system call."
msgstr "Лежащий в основе системный вызов Linux требует дополнительного аргумента, I<size_t sizemask>, в котором указывается размер аргумента I<mask>. В обёрточной функции glibc B<signalfd>() нет этого аргумента — требуемое для системного вызова значение добавляется библиотекой."

#. type: Plain text
#: man-pages/man2/signalfd.2:336
msgid ""
"A process can create multiple signalfd file descriptors.  This makes it "
"possible to accept different signals on different file descriptors.  (This "
"may be useful if monitoring the file descriptors using B<select>(2), "
"B<poll>(2), or B<epoll>(7): the arrival of different signals will make "
"different descriptors ready.)  If a signal appears in the I<mask> of more "
"than one of the file descriptors, then occurrences of that signal can be "
"read (once) from any one of the descriptors."
msgstr "Процесс может создать несколько файловых дескрипторов signalfd. Это позволяет принимать различные сигналы через различные файловые дескрипторы (может быть полезно при слежении за файловым дескриптором с помощью B<select>(2), B<poll>(2) или B<epoll>(7): прибытие различных сигналов делает готовым различные дескрипторы). Если сигнал указан в I<mask> для нескольких файловых дескрипторов, то появление этого сигнала можно прочесть (однократно) из любого файлового дескриптора."

#. type: SS
#: man-pages/man2/signalfd.2:336
#, no-wrap
msgid "Underlying Linux system calls"
msgstr "Системные вызовы Linux, лежащие в основе"

#. type: Plain text
#: man-pages/man2/signalfd.2:352
msgid ""
"There are two underlying Linux system calls: B<signalfd>()  and the more "
"recent B<signalfd4>().  The former system call does not implement a I<flags>"
" argument.  The latter system call implements the I<flags> values described "
"above.  Starting with glibc 2.9, the B<signalfd>()  wrapper function will "
"use B<signalfd4>()  where it is available."
msgstr "Существуют два системных вызова Linux: B<signalfd>() и более новый B<signalfd4>(). В первом системном вызове не реализован аргумент I<flags>. Во втором системном вызове реализованы значения I<flags>, описанные ранее. Начиная с glibc 2.9, обёрточная функция B<signalfd>() использует B<signalfd4>(), если он доступен."

#.  The fix also was put into 2.6.24.5
#. type: Plain text
#: man-pages/man2/signalfd.2:360
msgid ""
"In kernels before 2.6.25, the I<ssi_ptr> and I<ssi_int> fields are not "
"filled in with the data accompanying a signal sent by B<sigqueue>(3)."
msgstr "В ядрах до версии 3.6.25, поля I<ssi_ptr> и I<ssi_int> не заполнялись данными, поступающими при посылке сигнала с помощью B<sigqueue>(3)."

#. type: Plain text
#: man-pages/man2/signalfd.2:370
msgid ""
"The program below accepts the signals B<SIGINT> and B<SIGQUIT> via a "
"signalfd file descriptor.  The program terminates after accepting a "
"B<SIGQUIT> signal.  The following shell session demonstrates the use of the "
"program:"
msgstr "Программа, представленная далее, принимает сигналы B<SIGINT> и B<SIGQUIT> через файловый дескриптор signalfd. Она завершает работу при приёме сигнала B<SIGQUIT>. Вот сеанс работы в оболочке, демонстрирующий использование программы:"

#. type: Plain text
#: man-pages/man2/signalfd.2:381
#, no-wrap
msgid ""
"$B< ./signalfd_demo>\n"
"B<^C>                   # Control-C generates SIGINT\n"
"Got SIGINT\n"
"B<^C>\n"
"Got SIGINT\n"
"B<^\\e>                    # Control-\\e generates SIGQUIT\n"
"Got SIGQUIT\n"
"$\n"
msgstr "$B< ./signalfd_demo>\nB<^C>                   # Control-C генерирует SIGINT\nПолучен SIGINT\nB<^C>\nПолучен SIGINT\nB<^\\e>                    # Control-\\e генерирует SIGQUIT\nПолучен SIGQUIT\n$\n"

#. type: Plain text
#: man-pages/man2/signalfd.2:391
#, no-wrap
msgid ""
"#include E<lt>sys/signalfd.hE<gt>\n"
"#include E<lt>signal.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
msgstr "#include E<lt>sys/signalfd.hE<gt>\n#include E<lt>signal.hE<gt>\n#include E<lt>unistd.hE<gt>\n#include E<lt>stdlib.hE<gt>\n#include E<lt>stdio.hE<gt>\n"

#. type: Plain text
#: man-pages/man2/signalfd.2:402
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    sigset_t mask;\n"
"    int sfd;\n"
"    struct signalfd_siginfo fdsi;\n"
"    ssize_t s;\n"
msgstr "int\nmain(int argc, char *argv[])\n{\n    sigset_t mask;\n    int sfd;\n    struct signalfd_siginfo fdsi;\n    ssize_t s;\n"

#. type: Plain text
#: man-pages/man2/signalfd.2:406
#, no-wrap
msgid ""
"    sigemptyset(&mask);\n"
"    sigaddset(&mask, SIGINT);\n"
"    sigaddset(&mask, SIGQUIT);\n"
msgstr "    sigemptyset(&mask);\n    sigaddset(&mask, SIGINT);\n    sigaddset(&mask, SIGQUIT);\n"

#. type: Plain text
#: man-pages/man2/signalfd.2:409
#, no-wrap
msgid ""
"    /* Block signals so that they aren\\(aqt handled\n"
"       according to their default dispositions */\n"
msgstr "    /* Заблокировать сигналы для того, чтобы они не обрабатывались\n       их обработчиками по умолчанию */\n"

#. type: Plain text
#: man-pages/man2/signalfd.2:412
#, no-wrap
msgid ""
"    if (sigprocmask(SIG_BLOCK, &mask, NULL) == -1)\n"
"        handle_error(\"sigprocmask\");\n"
msgstr "    if (sigprocmask(SIG_BLOCK, &mask, NULL) == -1)\n        handle_error(\"sigprocmask\");\n"

#. type: Plain text
#: man-pages/man2/signalfd.2:416
#, no-wrap
msgid ""
"    sfd = signalfd(-1, &mask, 0);\n"
"    if (sfd == -1)\n"
"        handle_error(\"signalfd\");\n"
msgstr "    sfd = signalfd(-1, &mask, 0);\n    if (sfd == -1)\n        handle_error(\"signalfd\");\n"

#. type: Plain text
#: man-pages/man2/signalfd.2:421
#, no-wrap
msgid ""
"    for (;;) {\n"
"        s = read(sfd, &fdsi, sizeof(struct signalfd_siginfo));\n"
"        if (s != sizeof(struct signalfd_siginfo))\n"
"            handle_error(\"read\");\n"
msgstr "    for (;;) {\n        s = read(sfd, &fdsi, sizeof(struct signalfd_siginfo));\n        if (s != sizeof(struct signalfd_siginfo))\n            handle_error(\"read\");\n"

#. type: Plain text
#: man-pages/man2/signalfd.2:432
#, no-wrap
msgid ""
"        if (fdsi.ssi_signo == SIGINT) {\n"
"            printf(\"Got SIGINT\\en\");\n"
"        } else if (fdsi.ssi_signo == SIGQUIT) {\n"
"            printf(\"Got SIGQUIT\\en\");\n"
"            exit(EXIT_SUCCESS);\n"
"        } else {\n"
"            printf(\"Read unexpected signal\\en\");\n"
"        }\n"
"    }\n"
"}\n"
msgstr "        if (fdsi.ssi_signo == SIGINT) {\n            printf(\"Получен SIGINT\\en\");\n        } else if (fdsi.ssi_signo == SIGQUIT) {\n            printf(\"Получен SIGQUIT\\en\");\n            exit(EXIT_SUCCESS);\n        } else {\n            printf(\"Прочитан неожидаемый сигнал\\en\");\n        }\n    }\n}\n"

#. type: Plain text
#: man-pages/man2/signalfd.2:445
msgid ""
"B<eventfd>(2), B<poll>(2), B<read>(2), B<select>(2), B<sigaction>(2), "
"B<sigprocmask>(2), B<sigwaitinfo>(2), B<timerfd_create>(2), B<sigsetops>(3),"
" B<sigwait>(3), B<epoll>(7), B<signal>(7)"
msgstr "B<eventfd>(2), B<poll>(2), B<read>(2), B<select>(2), B<sigaction>(2), B<sigprocmask>(2), B<sigwaitinfo>(2), B<timerfd_create>(2), B<sigsetops>(3), B<sigwait>(3), B<epoll>(7), B<signal>(7)"

#. type: TH
#: man-pages/man2/sigreturn.2:29
#, no-wrap
msgid "SIGRETURN"
msgstr "SIGRETURN"

#. type: TH
#: man-pages/man2/sigreturn.2:29
#, no-wrap
msgid "2013-07-30"
msgstr "2013-07-30"

#. type: Plain text
#: man-pages/man2/sigreturn.2:32
msgid "sigreturn - return from signal handler and cleanup stack frame"
msgstr "sigreturn - возвращается из обработчика сигнала и очищает кадр стека"

#. type: Plain text
#: man-pages/man2/sigreturn.2:34
msgid "B<int sigreturn(unsigned long >I<__unused>B<);>"
msgstr "B<int sigreturn(unsigned long >I<__unused>B<);>"

#. type: Plain text
#: man-pages/man2/sigreturn.2:42
msgid ""
"When the Linux kernel creates the stack frame for a signal handler, a call "
"to B<sigreturn>()  is inserted into the stack frame so that upon return from"
" the signal handler, B<sigreturn>()  will be called."
msgstr "При создании кадра стека для обработчика сигнала ядро Linux посылает в этот стек вызов функции B<sigreturn>() таким образом, чтобы при возвращении вызова из обработчика право управления было передано B<sigreturn>()."

#. type: Plain text
#: man-pages/man2/sigreturn.2:53
msgid ""
"This B<sigreturn>()  call undoes everything that was done\\(emchanging the "
"process's signal mask, switching stacks (see B<sigaltstack>(2))\\(emin order"
" to invoke the signal handler: it restores the process's signal mask, "
"switches stacks, and restores the process's context (registers, processor "
"flags), so that the process directly resumes execution at the point where it"
" was interrupted by the signal."
msgstr "Вызов B<sigreturn>() очищает всё что накопилось \\(em изменяет маску сигнала процесса, переключает стеки (см. B<sigaltstack>(2))\\(em порядок вызова обработчиков сигнала: он восстанавливает маску сигнала процесса, переключает стеки и восстанавливает контекст процесса (регистры, флаги процессора), так что процесс непосредственно возобновляет исполнение с точки где был прерван сигналом."

#. type: Plain text
#: man-pages/man2/sigreturn.2:56
msgid "B<sigreturn>()  never returns."
msgstr "B<sigreturn>() не возвращает значений.  "

#. type: Plain text
#: man-pages/man2/sigreturn.2:58
msgid "/usr/src/linux/arch/i386/kernel/signal.c"
msgstr "/usr/src/linux/arch/i386/kernel/signal.c"

#. type: Plain text
#: man-pages/man2/sigreturn.2:60
msgid "/usr/src/linux/arch/alpha/kernel/entry.S"
msgstr "/usr/src/linux/arch/alpha/kernel/entry.S"

#. type: Plain text
#: man-pages/man2/sigreturn.2:64
msgid ""
"B<sigreturn>()  is specific to Linux and should not be used in programs "
"intended to be portable."
msgstr "Вызов B<sigreturn>() есть только в Linux. Не рекомендуется использовать ее в программах, переносимых в другие системы."

#. type: Plain text
#: man-pages/man2/sigreturn.2:74
msgid ""
"The B<sigreturn>()  call is used by the kernel to implement signal handlers."
"  It should B<never> be called directly.  Better yet, the specific use of "
"the I<__unused> argument varies depending on the architecture."
msgstr "Вызов B<sigreturn>() используется ядром для реализации обработчиков сигнала. Его ни в коем случае нельзя вызывать непосредственно. Более того, значение и способ использования аргумента I<__unused> зависит от архитектуры."

#. type: Plain text
#: man-pages/man2/sigreturn.2:79
msgid ""
"B<kill>(2), B<restart_syscall>(2), B<sigaltstack>(2), B<signal>(2), "
"B<signal>(7)"
msgstr "B<kill>(2), B<restart_syscall>(2), B<sigaltstack>(2), B<signal>(2), B<signal>(7)"

#. type: TH
#: man-pages/man2/sched_setattr.2:26
#, no-wrap
msgid "SCHED_SETATTR"
msgstr ""

#. type: TH
#: man-pages/man2/sched_setattr.2:26
#, no-wrap
msgid "2014-05-13"
msgstr "2014-05-13"

#. type: Plain text
#: man-pages/man2/sched_setattr.2:30
msgid ""
"sched_setattr, sched_getattr - set and get scheduling policy and attributes"
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_setattr.2:36
#, no-wrap
msgid ""
"B<int sched_setattr(pid_t >I<pid>B<, const struct sched_attr *>I<attr>B<,>\n"
"B<                  unsigned int >I<flags>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_setattr.2:39
#, no-wrap
msgid ""
"B<int sched_getattr(pid_t >I<pid>B<, const struct sched_attr *>I<attr>B<,>\n"
"B<                  unsigned int >I<size>B<, unsigned int >I<flags>B<);>\n"
msgstr ""

#. type: SS
#: man-pages/man2/sched_setattr.2:42
#, no-wrap
msgid "sched_setattr()"
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_setattr.2:52
msgid ""
"The B<sched_setattr>()  system call sets the scheduling policy and "
"associated attributes for the thread whose ID is specified in I<pid>.  If "
"I<pid> equals zero, the scheduling policy and attributes of the calling "
"thread will be set."
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_setattr.2:86
msgid "Linux also provides the following policy:"
msgstr ""

#. type: TP
#: man-pages/man2/sched_setattr.2:86
#, no-wrap
msgid "B<SCHED_DEADLINE>"
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_setattr.2:91
msgid "a deadline scheduling policy; see B<sched>(7)  for details."
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_setattr.2:97
msgid ""
"The I<attr> argument is a pointer to a structure that defines the new "
"scheduling policy and attributes for the specified thread.  This structure "
"has the following form:"
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_setattr.2:113
#, no-wrap
msgid ""
"struct sched_attr {\n"
"    u32 size;              /* Size of this structure */\n"
"    u32 sched_policy;      /* Policy (SCHED_*) */\n"
"    u64 sched_flags;       /* Flags */\n"
"    s32 sched_nice;        /* Nice value (SCHED_OTHER,\n"
"                              SCHED_BATCH) */\n"
"    u32 sched_priority;    /* Static priority (SCHED_FIFO,\n"
"                              SCHED_RR) */\n"
"    /* Remaining fields are for SCHED_DEADLINE */\n"
"    u64 sched_runtime;\n"
"    u64 sched_deadline;\n"
"    u64 sched_period;\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_setattr.2:117
msgid "The fields of this structure are as follows:"
msgstr ""

#. type: TP
#: man-pages/man2/sched_setattr.2:117
#, no-wrap
msgid "B<size>"
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_setattr.2:132
msgid ""
"This field should be set to the size of the structure in bytes, as in "
"I<sizeof(struct sched_attr)>.  If the provided structure is smaller than the"
" kernel structure, any additional fields are assumed to be '0'.  If the "
"provided structure is larger than the kernel structure, the kernel verifies "
"that all additional fields are 0; if they are not, B<sched_setattr>()  fails"
" with the error B<E2BIG> and updates I<size> to contain the size of the "
"kernel structure."
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_setattr.2:146
msgid ""
"The above behavior when the size of the user-space I<sched_attr> structure "
"does not match the size of the kernel structure allows for future "
"extensibility of the interface.  Malformed applications that pass oversize "
"structures won't break in the future if the size of the kernel I<sched_attr>"
" structure is increased.  In the future, it could also allow applications "
"that know about a larger user-space I<sched_attr> structure to determine "
"whether they are running on an older kernel that does not support the larger"
" structure."
msgstr ""

#. type: TP
#: man-pages/man2/sched_setattr.2:146
#, no-wrap
msgid "I<sched_policy>"
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_setattr.2:151
msgid ""
"This field specifies the scheduling policy, as one of the B<SCHED_*> values "
"listed above."
msgstr ""

#. type: TP
#: man-pages/man2/sched_setattr.2:151
#, no-wrap
msgid "I<sched_flags>"
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_setattr.2:162
msgid ""
"This field contains flags controlling scheduling behavior.  Only one such "
"flag is currently defined: B<SCHED_FLAG_RESET_ON_FORK>.  As a result of "
"including this flag, children created by B<fork>(2)  do not inherit "
"privileged scheduling policies.  See B<sched>(7)  for details."
msgstr ""

#. type: TP
#: man-pages/man2/sched_setattr.2:162
#, no-wrap
msgid "I<sched_nice>"
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_setattr.2:173
msgid ""
"This field specifies the nice value to be set when specifying "
"I<sched_policy> as B<SCHED_OTHER> or B<SCHED_BATCH>.  The nice value is a "
"number in the range -20 (high priority)  to +19 (low priority); see "
"B<setpriority>(2)."
msgstr ""

#. type: TP
#: man-pages/man2/sched_setattr.2:173
#, no-wrap
msgid "I<sched_priority>"
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_setattr.2:186
msgid ""
"This field specifies the static priority to be set when specifying "
"I<sched_policy> as B<SCHED_FIFO> or B<SCHED_RR>.  The allowed range of "
"priorities for these policies can be determined using "
"B<sched_get_priority_min>(2)  and B<sched_get_priority_max>(2).  For other "
"policies, this field must be specified as 0."
msgstr ""

#. type: TP
#: man-pages/man2/sched_setattr.2:186
#, no-wrap
msgid "I<sched_runtime>"
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_setattr.2:195
msgid ""
"This field specifies the \"Runtime\" parameter for deadline scheduling.  The"
" value is expressed in nanoseconds.  This field, and the next two fields, "
"are used only for B<SCHED_DEADLINE> scheduling; for further details, see "
"B<sched>(7)."
msgstr ""

#. type: TP
#: man-pages/man2/sched_setattr.2:195
#, no-wrap
msgid "I<sched_deadline>"
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_setattr.2:199
msgid ""
"This field specifies the \"Deadline\" parameter for deadline scheduling.  "
"The value is expressed in nanoseconds."
msgstr ""

#. type: TP
#: man-pages/man2/sched_setattr.2:199
#, no-wrap
msgid "I<sched_period>"
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_setattr.2:203
msgid ""
"This field specifies the \"Period\" parameter for deadline scheduling.  The "
"value is expressed in nanoseconds."
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_setattr.2:210 man-pages/man2/sched_setattr.2:262
msgid ""
"The I<flags> argument is provided to allow for future extensions to the "
"interface; in the current implementation it must be specified as 0."
msgstr ""

#. type: SS
#: man-pages/man2/sched_setattr.2:210
#, no-wrap
msgid "sched_getattr()"
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_setattr.2:221
msgid ""
"The B<sched_getattr>()  system call fetches the scheduling policy and the "
"associated attributes for the thread whose ID is specified in I<pid>.  If "
"I<pid> equals zero, the scheduling policy and attributes of the calling "
"thread will be retrieved."
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_setattr.2:231
msgid ""
"The I<size> argument should be set to the size of the I<sched_attr> "
"structure as known to user space.  The value must be at least as large as "
"the size of the initially published I<sched_attr> structure, or the call "
"fails with the error B<EINVAL>."
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_setattr.2:241
msgid ""
"The retrieved scheduling attributes are placed in the fields of the "
"I<sched_attr> structure pointed to by I<attr>.  The kernel sets I<attr.size>"
" to the size of its I<sched_attr> structure."
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_setattr.2:257
msgid ""
"If the caller-provided I<attr> buffer is larger than the kernel's "
"I<sched_attr> structure, the additional bytes in the user-space structure "
"are not touched.  If the caller-provided structure is smaller than the "
"kernel I<sched_attr> structure and the kernel needs to return values outside"
" the provided space, B<sched_getattr>()  fails with the error B<E2BIG>.  As "
"with B<sched_setattr>(), these semantics allow for future extensibility of "
"the interface."
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_setattr.2:271
msgid ""
"On success, B<sched_setattr>()  and B<sched_getattr>()  return 0.  On error,"
" -1 is returned, and I<errno> is set to indicate the cause of the error."
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_setattr.2:276
msgid ""
"B<sched_getattr>()  and B<sched_setattr>()  can both fail for the following "
"reasons:"
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_setattr.2:284
msgid "I<attr> is NULL; or I<pid> is negative; or I<flags> is not zero."
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_setattr.2:293
msgid "In addition, B<sched_getattr>()  can fail for the following reasons:"
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_setattr.2:300
msgid "The buffer specified by I<size> and I<attr> is too small."
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_setattr.2:306
msgid ""
"I<size> is invalid; that is, it is smaller than the initial version of the "
"I<sched_attr> structure (48 bytes) or larger than the system page size."
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_setattr.2:310
msgid "In addition, B<sched_setattr>()  can fail for the following reasons:"
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_setattr.2:318
msgid ""
"The buffer specified by I<size> and I<attr> is larger than the kernel "
"structure, and one or more of the excess bytes is nonzero."
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_setattr.2:323
msgid "B<SCHED_DEADLINE> admission control failure, see B<sched>(7)."
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_setattr.2:339
msgid ""
"I<attr.sched_policy> is not one of the recognized policies; "
"I<attr.sched_flags> contains a flag other than B<SCHED_FLAG_RESET_ON_FORK>; "
"or I<attr.sched_priority> is invalid; or I<attr.sched_policy> is "
"B<SCHED_DEADLINE> and the deadline scheduling parameters in I<attr> are "
"invalid."
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_setattr.2:342
msgid "The caller does not have appropriate privileges."
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_setattr.2:348
msgid ""
"The caller's CPU affinity mask does not include all CPUs in the system (see "
"B<sched_setaffinity>(2))."
msgstr ""

#.  FIXME Add glibc version
#. type: Plain text
#: man-pages/man2/sched_setattr.2:351
msgid "These system calls first appeared in Linux 3.14."
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_setattr.2:353
msgid "These system calls are nonstandard Linux extensions."
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_setattr.2:369
msgid ""
"B<sched_setattr>()  provides a superset of the functionality of "
"B<sched_setscheduler>(2), B<sched_setparam>(2), B<nice>(2), and (other than "
"the ability to set the priority of all processes belonging to a specified "
"user or all processes in a specified group)  B<setpriority>(2).  "
"Analogously, B<sched_getattr()> provides a superset of the functionality of "
"B<sched_getscheduler>(2), B<sched_getparam>(2), and (partially)  "
"B<getpriority>(2)."
msgstr ""

#.  FIXME patch sent to Peter Zijlstra
#.  In Linux versions up to up 3.15,
#.  .\" FIXME patch from Peter Zijlstra pending
#.  .BR sched_setattr ()
#.  allowed a negative
#.  .I attr.sched_policy
#.  value.
#. type: Plain text
#: man-pages/man2/sched_setattr.2:385
msgid ""
"In Linux versions up to 3.15, B<sched_settattr>()  failed with the error "
"B<EFAULT> instead of B<E2BIG> for the case described in ERRORS."
msgstr ""

#. type: Plain text
#: man-pages/man2/sched_setattr.2:406
msgid ""
"B<nice>(2), B<sched_get_priority_max>(2), B<sched_get_priority_min>(2), "
"B<sched_getaffinity>(2), B<sched_getscheduler>(2), B<sched_getparam>(2), "
"B<sched_rr_get_interval>(2), B<sched_setaffinity>(2), "
"B<sched_setscheduler>(2), B<sched_setparam>(2), B<sched_yield>(2), "
"B<setpriority>(2), B<pthread_getschedparam>(3), B<pthread_setschedparam>(3),"
" B<pthread_setschedprio>(3), B<capabilities>(7), B<cpuset>(7), B<sched>(7)"
msgstr ""

#. type: TH
#: man-pages/man2/select.2:38
#, no-wrap
msgid "SELECT"
msgstr "SELECT"

#. type: TH
#: man-pages/man2/select.2:38
#, no-wrap
msgid "2014-01-31"
msgstr "2014-01-31"

#. type: Plain text
#: man-pages/man2/select.2:58
#, no-wrap
msgid ""
"B<int select(int >I<nfds>B<, fd_set *>I<readfds>B<, fd_set *>I<writefds>B<,>\n"
"B<           fd_set *>I<exceptfds>B<, struct timeval *>I<timeout>B<);>\n"
msgstr "B<int select(int >I<nfds>B<, fd_set *>I<readfds>B<, fd_set *>I<writefds>B<,>\nB<           fd_set *>I<exceptfds>B<, struct timeval *>I<timeout>B<);>\n"

#. type: Plain text
#: man-pages/man2/select.2:72
#, no-wrap
msgid ""
"B<int pselect(int >I<nfds>B<, fd_set *>I<readfds>B<, fd_set *>I<writefds>B<,>\n"
"B<            fd_set *>I<exceptfds>B<, const struct timespec *>I<timeout>B<,>\n"
"B<            const sigset_t *>I<sigmask>B<);>\n"
msgstr "B<int pselect(int >I<nfds>B<, fd_set *>I<readfds>B<, fd_set *>I<writefds>B<,>\nB<            fd_set *>I<exceptfds>B<, const struct timespec *>I<timeout>B<,>\nB<            const sigset_t *>I<sigmask>B<);>\n"

#. type: Plain text
#: man-pages/man2/select.2:92
msgid ""
"B<select>()  and B<pselect>()  allow a program to monitor multiple file "
"descriptors, waiting until one or more of the file descriptors become "
"\"ready\" for some class of I/O operation (e.g., input possible).  A file "
"descriptor is considered ready if it is possible to perform the "
"corresponding I/O operation (e.g., B<read>(2))  without blocking."
msgstr "Вызовы B<select>() и B<pselect>() позволяют программам отслеживать изменения нескольких файловых дескрипторов ожидая, когда один или более файловых дескрипторов станут \"готовы\" для операции ввода-вывода определённого типа (например, ввода). Файловый дескриптор считается готовым, если к нему возможно применить соответствующую операцию ввода-вывода (например, B<read>(2)) без блокировки."

#. type: Plain text
#: man-pages/man2/select.2:98
msgid ""
"The operation of B<select>()  and B<pselect>()  is identical, other than "
"these three differences:"
msgstr "Работа B<select>() и B<pselect>() идентична за исключением трёх моментов:"

#. type: TP
#: man-pages/man2/select.2:98
#, no-wrap
msgid "(i)"
msgstr "(i)"

#. type: Plain text
#: man-pages/man2/select.2:108
msgid ""
"B<select>()  uses a timeout that is a I<struct timeval> (with seconds and "
"microseconds), while B<pselect>()  uses a I<struct timespec> (with seconds "
"and nanoseconds)."
msgstr "В вызове B<select>() время ожидания задаётся в структуре I<struct timeval> (с секундами и микросекундами), а в B<pselect>() используется структура I<struct timespec> (с секундами и наносекундами)."

#. type: TP
#: man-pages/man2/select.2:108
#, no-wrap
msgid "(ii)"
msgstr "(ii)"

#. type: Plain text
#: man-pages/man2/select.2:116
msgid ""
"B<select>()  may update the I<timeout> argument to indicate how much time "
"was left.  B<pselect>()  does not change this argument."
msgstr "Вызов B<select>() может обновить аргумент I<timeout>, который показывает сколько времени прошло. Вызов B<pselect>() не изменяет этот аргумент."

#. type: TP
#: man-pages/man2/select.2:116
#, no-wrap
msgid "(iii)"
msgstr "(iii)"

#. type: Plain text
#: man-pages/man2/select.2:125
msgid ""
"B<select>()  has no I<sigmask> argument, and behaves as B<pselect>()  called"
" with NULL I<sigmask>."
msgstr "Вызов B<select>() не имеет аргумента I<sigmask>, и ведёт себя также как B<pselect>(), если при вызове было указано значение I<sigmask> равное NULL."

#. type: Plain text
#: man-pages/man2/select.2:143
msgid ""
"Three independent sets of file descriptors are watched.  Those listed in "
"I<readfds> will be watched to see if characters become available for reading"
" (more precisely, to see if a read will not block; in particular, a file "
"descriptor is also ready on end-of-file), those in I<writefds> will be "
"watched to see if a write will not block, and those in I<exceptfds> will be "
"watched for exceptions.  On exit, the sets are modified in place to indicate"
" which file descriptors actually changed status.  Each of the three file "
"descriptor sets may be specified as NULL if no file descriptors are to be "
"watched for the corresponding class of events."
msgstr "Отслеживаются 3 независимых набора файловых дескрипторов. В тех, что перечислены в I<readfds>, будет отслеживаться появление символов, доступных для чтения (говоря более точно, проверяется доступность чтения без блокировки; в частности, файловый дескриптор готов для чтения, если он указывает на конец файла); дескрипторы, указанные в I<writefds>, будут отслеживаться для возможности записи без блокировки, а указанные в I<exceptfds>, будут отслеживаться для обнаружения исключительных ситуаций. При возврате из вызова наборы изменяются, показывая какие файловые дескрипторы фактически изменили состояние. Значение любого из трёх наборов файловых дескрипторов может быть равно NULL, если слежение за определённым классом событий над файловыми дескрипторами не требуется."

#. type: Plain text
#: man-pages/man2/select.2:156
msgid ""
"Four macros are provided to manipulate the sets.  B<FD_ZERO>()  clears a "
"set.  B<FD_SET>()  and B<FD_CLR>()  respectively add and remove a given file"
" descriptor from a set.  B<FD_ISSET>()  tests to see if a file descriptor is"
" part of the set; this is useful after B<select>()  returns."
msgstr "Для манипуляций наборами существуют четыре макроса: B<FD_ZERO>() очищает набор;  B<FD_SET>() добавляет заданный файловый дескриптор к набору; B<FD_CLR>() удаляет файловый дескриптор из набора; B<FD_ISSET>() проверяет, является ли файловый дескриптор частью набора. Эти макросы полезны после возврата из вызова B<select>()."

#. type: Plain text
#: man-pages/man2/select.2:159
msgid ""
"I<nfds> is the highest-numbered file descriptor in any of the three sets, "
"plus 1."
msgstr "Значение I<nfds> на единицу больше самого большого номера файлового дескриптора из всех трёх наборов."

#. type: Plain text
#: man-pages/man2/select.2:166
msgid ""
"The I<timeout> argument specifies the interval that B<select>()  should "
"block waiting for a file descriptor to become ready.  The call will block "
"until either:"
msgstr "В аргументе I<timeout> указывается интервал, на который должен заблокироваться B<select>() в ожидании готовности файлового дескриптора. Вызов будет блокирован пока:"

#. type: Plain text
#: man-pages/man2/select.2:168
msgid "a file descriptor becomes ready;"
msgstr "файловый дескриптор не станет готов;"

#. type: Plain text
#: man-pages/man2/select.2:170
msgid "the call is interrupted by a signal handler; or"
msgstr "вызов не прервётся обработчиком сигнала;"

#. type: Plain text
#: man-pages/man2/select.2:172
msgid "the timeout expires."
msgstr "не истечёт время ожидания."

#. type: Plain text
#: man-pages/man2/select.2:189
msgid ""
"Note that the I<timeout> interval will be rounded up to the system clock "
"granularity, and kernel scheduling delays mean that the blocking interval "
"may overrun by a small amount.  If both fields of the I<timeval> structure "
"are zero, then B<select>()  returns immediately.  (This is useful for "
"polling.)  If I<timeout> is NULL (no timeout), B<select>()  can block "
"indefinitely."
msgstr "Заметим, что интервал I<timeout> будет округлён с точностью системных часов, а из-за задержки при планировании в ядре блокирующий интервал будет немного больше. Если оба поля структуры I<timeval> равны нулю, то B<select>() завершится немедленно (полезно при опросе (polling)). Если значение I<timeout> равно NULL (время ожидания не задано), то B<select>() может блокировать работу неопределённо долго."

#. type: Plain text
#: man-pages/man2/select.2:199
msgid ""
"I<sigmask> is a pointer to a signal mask (see B<sigprocmask>(2)); if it is "
"not NULL, then B<pselect>()  first replaces the current signal mask by the "
"one pointed to by I<sigmask>, then does the \"select\" function, and then "
"restores the original signal mask."
msgstr "Значение I<sigmask> является указателем на маску сигналов (смотрите B<sigprocmask>(2)); если оно не равно NULL, то сначала B<pselect>() заменяет текущую маску сигналов на заданную I<sigmask>, затем выполняет функцию «select», после чего восстанавливает первоначальную сигнальную маску."

#. type: Plain text
#: man-pages/man2/select.2:205
msgid ""
"Other than the difference in the precision of the I<timeout> argument, the "
"following B<pselect>()  call:"
msgstr "Кроме различия в точности аргумента I<timeout> вызов B<pselect>()"

#. type: Plain text
#: man-pages/man2/select.2:209
#, no-wrap
msgid ""
"    ready = pselect(nfds, &readfds, &writefds, &exceptfds,\n"
"                    timeout, &sigmask);\n"
msgstr "    ready = pselect(nfds, &readfds, &writefds, &exceptfds,\n                    timeout, &sigmask);\n"

#. type: Plain text
#: man-pages/man2/select.2:214
msgid "is equivalent to I<atomically> executing the following calls:"
msgstr "эквивалентен I<атомарному> выполнению следующих вызовов:"

#. type: Plain text
#: man-pages/man2/select.2:217
#, no-wrap
msgid "    sigset_t origmask;\n"
msgstr "    sigset_t origmask;\n"

#. type: Plain text
#: man-pages/man2/select.2:221
#, no-wrap
msgid ""
"    pthread_sigmask(SIG_SETMASK, &sigmask, &origmask);\n"
"    ready = select(nfds, &readfds, &writefds, &exceptfds, timeout);\n"
"    pthread_sigmask(SIG_SETMASK, &origmask, NULL);\n"
msgstr "    pthread_sigmask(SIG_SETMASK, &sigmask, &origmask);\n    ready = select(nfds, &readfds, &writefds, &exceptfds, timeout);\n    pthread_sigmask(SIG_SETMASK, &origmask, NULL);\n"

#. type: Plain text
#: man-pages/man2/select.2:242
msgid ""
"The reason that B<pselect>()  is needed is that if one wants to wait for "
"either a signal or for a file descriptor to become ready, then an atomic "
"test is needed to prevent race conditions.  (Suppose the signal handler sets"
" a global flag and returns.  Then a test of this global flag followed by a "
"call of B<select>()  could hang indefinitely if the signal arrived just "
"after the test but just before the call.  By contrast, B<pselect>()  allows "
"one to first block signals, handle the signals that have come in, then call "
"B<pselect>()  with the desired I<sigmask>, avoiding the race.)"
msgstr "Причина необходимости B<pselect>() в том, что если нужно ждать какого-то сигнала или готовности файлового дескриптора, то необходимо атомарное тестирование для избежания состязательности. (Предположим, что обработчик сигнала устанавливает глобальный флаг и завершается. В этом случае тест этого глобального флага после вызова B<select>() мог бы длиться бесконечно, если сигнал прибыл бы сразу после тестирования, но до вызова. В отличие от этого, B<pselect>() позволяет сначала заблокировать сигналы, обработать уже поступившие и затем вызвать B<pselect>() с желаемым значением I<sigmask>, избегая состязательности.)"

#. type: SS
#: man-pages/man2/select.2:242
#, no-wrap
msgid "The timeout"
msgstr "Время ожидания"

#. type: Plain text
#: man-pages/man2/select.2:246
msgid ""
"The time structures involved are defined in I<E<lt>sys/time.hE<gt>> and look"
" like"
msgstr "Используемые структуры времени определены в I<E<lt>sys/time.hE<gt>> и выглядят следующим образом:"

#. type: Plain text
#: man-pages/man2/select.2:253
#, no-wrap
msgid ""
"struct timeval {\n"
"    long    tv_sec;         /* seconds */\n"
"    long    tv_usec;        /* microseconds */\n"
"};\n"
msgstr "struct timeval {\n    long    tv_sec;         /* секунды */\n    long    tv_usec;        /* микросекунды */\n};\n"

#. type: Plain text
#: man-pages/man2/select.2:257
msgid "and"
msgstr "и"

#. type: Plain text
#: man-pages/man2/select.2:264
#, no-wrap
msgid ""
"struct timespec {\n"
"    long    tv_sec;         /* seconds */\n"
"    long    tv_nsec;        /* nanoseconds */\n"
"};\n"
msgstr "struct timespec {\n    long    tv_sec;         /* секунды */\n    long    tv_nsec;        /* наносекунды */\n};\n"

#. type: Plain text
#: man-pages/man2/select.2:268
msgid "(However, see below on the POSIX.1-2001 versions.)"
msgstr "(Однако, смотрите ниже про версию POSIX 1003.1-2001.)"

#. type: Plain text
#: man-pages/man2/select.2:276
msgid ""
"Some code calls B<select>()  with all three sets empty, I<nfds> zero, and a "
"non-NULL I<timeout> as a fairly portable way to sleep with subsecond "
"precision."
msgstr "Иногда B<select>() вызывается с пустыми наборами (всеми тремя), I<nfds> равным нулю и непустым I<timeout> для переносимой реализации перехода в режим ожидания (sleep) на периоды с точностью менее секунды."

#.  .PP - it is rumored that:
#.  On BSD, when a timeout occurs, the file descriptor bits are not changed.
#.  - it is certainly true that:
#.  Linux follows SUSv2 and sets the bit masks to zero upon a timeout.
#. type: Plain text
#: man-pages/man2/select.2:299
msgid ""
"On Linux, B<select>()  modifies I<timeout> to reflect the amount of time not"
" slept; most other implementations do not do this.  (POSIX.1-2001 permits "
"either behavior.)  This causes problems both when Linux code which reads "
"I<timeout> is ported to other operating systems, and when code is ported to "
"Linux that reuses a I<struct timeval> for multiple B<select>()s in a loop "
"without reinitializing it.  Consider I<timeout> to be undefined after "
"B<select>()  returns."
msgstr "В Linux вызов B<select>() изменяет I<timeout> для отражения времени, проведённого не в режиме ожидания; большая часть других реализаций этого не делает (согласно POSIX.1-2001 допускается любой из этих вариантов). Это вызывает проблемы как при переносе кода Linux, читающего I<timeout>, на другие операционные системы, так и при переносе на Linux кода, использующего I<struct timeval> для многократного вызова B<select>() в цикле без его переинициализации. Во избежание этого следует считать, что значение I<timeout> не определено после возврата из B<select>()."

#. type: Plain text
#: man-pages/man2/select.2:317
msgid ""
"On success, B<select>()  and B<pselect>()  return the number of file "
"descriptors contained in the three returned descriptor sets (that is, the "
"total number of bits that are set in I<readfds>, I<writefds>, I<exceptfds>)"
"  which may be zero if the timeout expires before anything interesting "
"happens.  On error, -1 is returned, and I<errno> is set to indicate the "
"error; the file descriptor sets are unmodified, and I<timeout> becomes "
"undefined."
msgstr "При успешном выполнении B<select>() и B<pselect>() возвращают количество файловых дескрипторов, находящихся в трёх возвращаемых наборах (то есть, общее количество бит, установленных в I<readfds>, I<writefds>, I<exceptfds>), при чём это количество может быть нулевым, если время ожидания истекло, а интересующие события так и не произошли. При ошибке возвращается значение -1, а переменной I<errno> присваивается соответствующий номер ошибки; наборы файловых дескрипторов не изменяются и значение I<timeout> становится неопределённым."

#. type: Plain text
#: man-pages/man2/select.2:323
msgid ""
"An invalid file descriptor was given in one of the sets.  (Perhaps a file "
"descriptor that was already closed, or one on which an error has occurred.)"
msgstr "В одном из наборов находится неверный файловый дескриптор (возможно файловый дескриптор уже закрыт, или при работе с ним произошла ошибка)."

#. type: Plain text
#: man-pages/man2/select.2:327
msgid "A signal was caught; see B<signal>(7)."
msgstr "При выполнении поступил сигнал; см. B<signal>(7)."

#. type: Plain text
#: man-pages/man2/select.2:333
msgid ""
"I<nfds> is negative or the value contained within I<timeout> is invalid."
msgstr "Значение I<nfds> отрицательно или значение I<timeout> некорректно."

#. type: Plain text
#: man-pages/man2/select.2:336
msgid "unable to allocate memory for internal tables."
msgstr "Не удалось выделить память для внутренних таблиц."

#. type: Plain text
#: man-pages/man2/select.2:342
msgid ""
"B<pselect>()  was added to Linux in kernel 2.6.16.  Prior to this, "
"B<pselect>()  was emulated in glibc (but see BUGS)."
msgstr "Вызов B<pselect>() был добавлен в ядро Linux версии 2.6.16. До этого B<pselect>() эмулировался в glibc (но, см. ДЕФЕКТЫ)."

#. type: Plain text
#: man-pages/man2/select.2:353
msgid ""
"B<select>()  conforms to POSIX.1-2001 and 4.4BSD (B<select>()  first "
"appeared in 4.2BSD).  Generally portable to/from non-BSD systems supporting "
"clones of the BSD socket layer (including System\\ V variants).  However, "
"note that the System\\ V variant typically sets the timeout variable before "
"exit, but the BSD variant does not."
msgstr "Вызов B<select>() соответствует POSIX.1-2001 и 4.4BSD (впервые B<select>() появился в 4.2BSD). Обычно перенос выполняется с не-BSD систем и на них, если они поддерживают уровень BSD-сокетов (включая варианты System\\ V). Однако, заметим, что вариант System\\ V, обычно, устанавливает значение переменной timeout перед выходом, а вариант BSD — нет."

#. type: Plain text
#: man-pages/man2/select.2:357
msgid "B<pselect>()  is defined in POSIX.1g, and in POSIX.1-2001."
msgstr "Вызов B<pselect>() определён в стандарте POSIX.1g и в POSIX 1004.1-2001."

#. type: Plain text
#: man-pages/man2/select.2:374
msgid ""
"An I<fd_set> is a fixed size buffer.  Executing B<FD_CLR>()  or B<FD_SET>()"
"  with a value of I<fd> that is negative or is equal to or larger than "
"B<FD_SETSIZE> will result in undefined behavior.  Moreover, POSIX requires "
"I<fd> to be a valid file descriptor."
msgstr "I<fd_set> представляет собой буфер фиксированного размера. Выполнение B<FD_CLR>() или B<FD_SET>() с отрицательным значением I<fd>, равным или большим чем B<FD_SETSIZE>, приводит к неопределённому поведению. Более того, согласно POSIX I<fd> должен быть корректным файловым дескриптором."

#. type: Plain text
#: man-pages/man2/select.2:383
msgid ""
"Concerning the types involved, the classical situation is that the two "
"fields of a I<timeval> structure are typed as I<long> (as shown above), and "
"the structure is defined in I<E<lt>sys/time.hE<gt>>.  The POSIX.1-2001 "
"situation is"
msgstr "Что касается задействованных типов, классическим вариантом является структура I<timeval> с двумя полями типа I<long> (как показано ниже), которая определена в I<E<lt>sys/time.hE<gt>>. В POSIX.1-2001:"

#. type: Plain text
#: man-pages/man2/select.2:390
#, no-wrap
msgid ""
"struct timeval {\n"
"    time_t         tv_sec;     /* seconds */\n"
"    suseconds_t    tv_usec;    /* microseconds */\n"
"};\n"
msgstr "struct timeval {\n    time_t         tv_sec;     /* секунды */\n    suseconds_t    tv_usec;    /* микросекунды */\n};\n"

#. type: Plain text
#: man-pages/man2/select.2:401
msgid ""
"where the structure is defined in I<E<lt>sys/select.hE<gt>> and the data "
"types I<time_t> and I<suseconds_t> are defined in I<E<lt>sys/types.hE<gt>>."
msgstr "где структура определена в I<E<lt>sys/select.hE<gt>>, а типы данных I<time_t> и I<suseconds_t> определены в I<E<lt>sys/types.hE<gt>>."

#. type: Plain text
#: man-pages/man2/select.2:413
msgid ""
"Concerning prototypes, the classical situation is that one should include "
"I<E<lt>time.hE<gt>> for B<select>().  The POSIX.1-2001 situation is that one"
" should include I<E<lt>sys/select.hE<gt>> for B<select>()  and B<pselect>()."
msgstr "Что касается прототипов, классическим вариантом является объявление B<select>() в I<E<lt>time.hE<gt>>. Согласно POSIX.1-2001 объявления B<select>() и B<pselect>() должны включаться в I<E<lt>sys/select.hE<gt>>."

#. type: Plain text
#: man-pages/man2/select.2:425
msgid ""
"Libc4 and libc5 do not have a I<E<lt>sys/select.hE<gt>> header; under glibc "
"2.0 and later this header exists.  Under glibc 2.0 it unconditionally gives "
"the wrong prototype for B<pselect>().  Under glibc 2.1 to 2.2.1 it gives "
"B<pselect>()  when B<_GNU_SOURCE> is defined.  Since glibc 2.2.2 the "
"requirements are as shown in the SYNOPSIS."
msgstr "В libc4 и libc5 нет заголовочного файла I<E<lt>sys/select.hE<gt>>; в glibc 2.0 и более поздних он есть. В glibc 2.0 прототип B<pselect>() ошибочно определен всегда. В glibc 2.1 до версии 2.2.1 B<pselect>() определён при определённом B<_GNU_SOURCE>. Требования, которые необходимы для работы с glibc начиная с версии 2.2.2, показаны в разделе ОБЗОР."

#. type: SS
#: man-pages/man2/select.2:425
#, no-wrap
msgid "Multithreaded applications"
msgstr "Многонитиевые приложения"

#. type: Plain text
#: man-pages/man2/select.2:441
msgid ""
"If a file descriptor being monitored by B<select>()  is closed in another "
"thread, the result is unspecified.  On some UNIX systems, B<select>()  "
"unblocks and returns, with an indication that the file descriptor is ready "
"(a subsequent I/O operation will likely fail with an error, unless another "
"the file descriptor reopened between the time B<select>()  returned and the "
"I/O operations was performed).  On Linux (and some other systems), closing "
"the file descriptor in another thread has no effect on B<select>().  In "
"summary, any application that relies on a particular behavior in this "
"scenario must be considered buggy."
msgstr "Если файловой дескриптор, отслеживаемый B<select>(), закрывается в другой нити, то результат непредсказуем. В некоторых системах UNIX B<select>() разблокируется и возвращает выполнение с указанием того, что файловый дескриптор готов (последующая операция ввода-вывода, вероятно, завершится с ошибкой, если другой файловый дескриптор не переоткроется между возвратом B<select>() и выполнением операций ввода-вывода). В Linux (и некоторых других системах), закрытие файлового дескриптора в другой нити не влияет на B<select>(). Резюмируя, любое приложение, которое полагается на определённое поведение в таком сценарии, должно считаться ошибочным."

#. type: Plain text
#: man-pages/man2/select.2:449
msgid ""
"The B<pselect>()  interface described in this page is implemented by glibc."
"  The underlying Linux system call is named B<pselect6>().  This system call"
" has somewhat different behavior from the glibc wrapper function."
msgstr "Интерфейс B<pselect>(), описанный в этой странице, реализован в glibc. Для этого используется системный вызов B<pselect6>(). Поведение данного системного вызова несколько отличается от обёрточной функции glibc."

#. type: Plain text
#: man-pages/man2/select.2:464
msgid ""
"The Linux B<pselect6>()  system call modifies its I<timeout> argument.  "
"However, the glibc wrapper function hides this behavior by using a local "
"variable for the timeout argument that is passed to the system call.  Thus, "
"the glibc B<pselect>()  function does not modify its I<timeout> argument; "
"this is the behavior required by POSIX.1-2001."
msgstr "В Linux системный вызов B<pselect6>() изменяет содержимое своего аргумента I<timeout>. Однако, обёрточная функция glibc скрывает это поведение используя локальную переменную для аргумента timeout при передаче в системный вызов. Таким образом, функция B<pselect>() в glibc не изменяет свой аргумент I<timeout>; это поведение требуется в POSIX.1-2001."

#. type: Plain text
#: man-pages/man2/select.2:470
msgid ""
"The final argument of the B<pselect6>()  system call is not a I<sigset_t\\ "
"*> pointer, but is instead a structure of the form:"
msgstr "Последний аргумент системного вызова B<pselect6>() не является указателем I<sigset_t\\ *>, он представляет собой структуру в виде:"

#. type: Plain text
#: man-pages/man2/select.2:478
#, no-wrap
msgid ""
"struct {\n"
"    const sigset_t *ss;     /* Pointer to signal set */\n"
"    size_t          ss_len; /* Size (in bytes) of object pointed\n"
"                               to by 'ss' */\n"
"};\n"
msgstr "struct {\n    const sigset_t *ss;     /* указатель на набор сигналов */\n    size_t          ss_len; /* размер (в байтах) объекта, на который\n                               указывает «ss» */\n};\n"

#. type: Plain text
#: man-pages/man2/select.2:485
msgid ""
"This allows the system call to obtain both a pointer to the signal set and "
"its size, while allowing for the fact that most architectures support a "
"maximum of 6 arguments to a system call."
msgstr "Это позволяет системному вызову получить и указатель на набор сигналов, так как в большинстве архитектур системным вызовам можно передать максимум 6 аргументов."

#. type: Plain text
#: man-pages/man2/select.2:491
msgid ""
"Glibc 2.0 provided a version of B<pselect>()  that did not take a I<sigmask>"
" argument."
msgstr "Glibc 2.0 предоставляет версию B<pselect>(), которая не принимает аргумент I<sigmask>."

#. type: Plain text
#: man-pages/man2/select.2:504
msgid ""
"Starting with version 2.1, glibc provided an emulation of B<pselect>()  that"
" was implemented using B<sigprocmask>(2)  and B<select>().  This "
"implementation remained vulnerable to the very race condition that "
"B<pselect>()  was designed to prevent.  Modern versions of glibc use the "
"(race-free)  B<pselect>()  system call on kernels where it is provided."
msgstr "Начиная с версии 2.1, glibc предоставляет эмуляцию B<pselect>(), которая реализована с помощью B<sigprocmask>(2) и B<select>(). Эта реализация остаётся уязвимой к той самой состязательности, для устранения которой и был разработан B<pselect>(). В современных версии glibc используется (бессостязательный) системный вызов B<pselect>(), если он предоставляется ядром."

#. type: Plain text
#: man-pages/man2/select.2:517
msgid ""
"On systems that lack B<pselect>(), reliable (and more portable) signal "
"trapping can be achieved using the self-pipe trick.  In this technique, a "
"signal handler writes a byte to a pipe whose other end is monitored by "
"B<select>()  in the main program.  (To avoid possibly blocking when writing "
"to a pipe that may be full or reading from a pipe that may be empty, "
"nonblocking I/O is used when reading from and writing to the pipe.)"
msgstr "В системах без B<pselect>(), надёжного (и более переносимого) перехвата сигнала можно достичь с помощью трюка с каналом в самого себя. В этом методе обработчик сигнала пишет байт в канал, чей второй конец отслеживается B<select>() в основной программе (чтобы избежать возможной блокировки при записи в канал, который может быть заполнен, или при чтении из канала, который может быть пуст, нужно использовать неблокирующий ввод/вывод)."

#.  Stevens discusses a case where accept can block after select
#.  returns successfully because of an intervening RST from the client.
#.  Maybe the kernel should have returned EIO in such a situation?
#. type: Plain text
#: man-pages/man2/select.2:533
msgid ""
"Under Linux, B<select>()  may report a socket file descriptor as \"ready for"
" reading\", while nevertheless a subsequent read blocks.  This could for "
"example happen when data has arrived but upon examination has wrong checksum"
" and is discarded.  There may be other circumstances in which a file "
"descriptor is spuriously reported as ready.  Thus it may be safer to use "
"B<O_NONBLOCK> on sockets that should not block."
msgstr "В Linux, вызов B<select>() может сообщать о файловом дескрипторе сокета как о «готовом для чтения», хотя при последующем чтении произойдёт блокировка. Это может случиться, например, когда данные прибыли, но при анализе их контрольная сумма не совпала и они были отброшены. Также могут быть другие обстоятельства, при которых файловый дескриптор ошибочно считается готовым. Поэтому, возможно безопасней будет использовать для сокетов B<O_NONBLOCK>, которые не должны блокироваться."

#. type: Plain text
#: man-pages/man2/select.2:548
msgid ""
"On Linux, B<select>()  also modifies I<timeout> if the call is interrupted "
"by a signal handler (i.e., the B<EINTR> error return).  This is not "
"permitted by POSIX.1-2001.  The Linux B<pselect>()  system call has the same"
" behavior, but the glibc wrapper hides this behavior by internally copying "
"the I<timeout> to a local variable and passing that variable to the system "
"call."
msgstr "В Linux, вызов B<select>() также изменяет I<timeout>, если он прерван обработчиком сигнала (т.е., возвращается ошибка B<EINTR>). Согласно POSIX.1-2001 это не разрешено. В Linux системный вызов B<pselect>() действует также, но обёртка glibc скрывает это поведение копируя перед вызовом I<timeout> в локальную переменную и передавая её в системный вызов."

#. type: Plain text
#: man-pages/man2/select.2:555
#, no-wrap
msgid ""
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>sys/time.hE<gt>\n"
"#include E<lt>sys/types.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
msgstr "#include E<lt>stdio.hE<gt>\n#include E<lt>stdlib.hE<gt>\n#include E<lt>sys/time.hE<gt>\n#include E<lt>sys/types.hE<gt>\n#include E<lt>unistd.hE<gt>\n"

#. type: Plain text
#: man-pages/man2/select.2:562
#, no-wrap
msgid ""
"int\n"
"main(void)\n"
"{\n"
"    fd_set rfds;\n"
"    struct timeval tv;\n"
"    int retval;\n"
msgstr "int\nmain(void)\n{\n    fd_set rfds;\n    struct timeval tv;\n    int retval;\n"

#. type: Plain text
#: man-pages/man2/select.2:566
#, no-wrap
msgid ""
"    /* Watch stdin (fd 0) to see when it has input. */\n"
"    FD_ZERO(&rfds);\n"
"    FD_SET(0, &rfds);\n"
msgstr "    /* Следить, когда в stdin (fd 0) что-нибудь появится. */\n    FD_ZERO(&rfds);\n    FD_SET(0, &rfds);\n"

#. type: Plain text
#: man-pages/man2/select.2:570
#, no-wrap
msgid ""
"    /* Wait up to five seconds. */\n"
"    tv.tv_sec = 5;\n"
"    tv.tv_usec = 0;\n"
msgstr "    /* Ждать не больше пяти секунд. */\n    tv.tv_sec = 5;\n    tv.tv_usec = 0;\n"

#. type: Plain text
#: man-pages/man2/select.2:573
#, no-wrap
msgid ""
"    retval = select(1, &rfds, NULL, NULL, &tv);\n"
"    /* Don't rely on the value of tv now! */\n"
msgstr "    retval = select(1, &rfds, NULL, NULL, &tv);\n    /* Больше не полагаться на значение tv! */\n"

#. type: Plain text
#: man-pages/man2/select.2:581
#, no-wrap
msgid ""
"    if (retval == -1)\n"
"        perror(\"select()\");\n"
"    else if (retval)\n"
"        printf(\"Data is available now.\\en\");\n"
"        /* FD_ISSET(0, &rfds) will be true. */\n"
"    else\n"
"        printf(\"No data within five seconds.\\en\");\n"
msgstr "    if (retval == -1)\n        perror(\"select()\");\n    else if (retval)\n        printf(\"Есть данные.\\en\");\n        /* FD_ISSET(0, &rfds) will be true. */\n    else\n        printf(\"Данные не появились в течение пяти секунд.\\en\");\n"

#. type: Plain text
#: man-pages/man2/select.2:596
msgid ""
"B<accept>(2), B<connect>(2), B<poll>(2), B<read>(2), B<recv>(2), B<send>(2),"
" B<sigprocmask>(2), B<write>(2), B<epoll>(7), B<time>(7)"
msgstr "B<accept>(2), B<connect>(2), B<poll>(2), B<read>(2), B<recv>(2), B<send>(2), B<sigprocmask>(2), B<write>(2), B<epoll>(7), B<time>(7)"

#. type: Plain text
#: man-pages/man2/select.2:598
msgid "For a tutorial with discussion and examples, see B<select_tut>(2)."
msgstr "Обсуждение и примеры смотрите в B<select_tut>(2)."

#. type: TH
#: man-pages/man2/statfs.2:28
#, no-wrap
msgid "STATFS"
msgstr "STATFS"

#. type: Plain text
#: man-pages/man2/statfs.2:31
msgid "statfs, fstatfs - get filesystem statistics"
msgstr "statfs, fstatfs - получить статистику по файловой системе"

#. type: Plain text
#: man-pages/man2/statfs.2:33
msgid "B<#include E<lt>sys/vfs.hE<gt> >/* or E<lt>sys/statfs.hE<gt> */"
msgstr "B<#include E<lt>sys/vfs.hE<gt> >/* или E<lt>sys/statfs.hE<gt> */"

#. type: Plain text
#: man-pages/man2/statfs.2:35
msgid "B<int statfs(const char *>I<path>B<, struct statfs *>I<buf>B<);>"
msgstr "B<int statfs(const char *>I<path>B<, struct statfs *>I<buf>B<);>"

#. type: Plain text
#: man-pages/man2/statfs.2:37
msgid "B<int fstatfs(int >I<fd>B<, struct statfs *>I<buf>B<);>"
msgstr "B<int fstatfs(int >I<fd>B<, struct statfs *>I<buf>B<);>"

#. type: Plain text
#: man-pages/man2/statfs.2:47
msgid ""
"The function B<statfs>()  returns information about a mounted filesystem.  "
"I<path> is the pathname of any file within the mounted filesystem.  I<buf> "
"is a pointer to a I<statfs> structure defined approximately as follows:"
msgstr "Функция B<statfs>() возвращает информацию о смонтированной файловой системе. I<path> является путём любого файла, расположенного в смонтированной файловой системе. I<buf> является указателем на структуру I<statfs>, определённую примерно следующим образом:"

#. type: Plain text
#: man-pages/man2/statfs.2:55
#, no-wrap
msgid ""
"#if __WORDSIZE == 32\t\t/* System word size */\n"
"# define __SWORD_TYPE           int\n"
"#else /* __WORDSIZE == 64 */\n"
"# define __SWORD_TYPE\t\tlong int\n"
"#endif\n"
msgstr "#if __WORDSIZE == 32\t\t/* размер слова в системе */\n# define __SWORD_TYPE\t\tint\n#else /* __WORDSIZE == 64 */\n# define __SWORD_TYPE\t\tlong int\n#endif\n"

#. type: Plain text
#: man-pages/man2/statfs.2:70
#, no-wrap
msgid ""
"struct statfs {\n"
"    __SWORD_TYPE f_type;    /* type of filesystem (see below) */\n"
"    __SWORD_TYPE f_bsize;   /* optimal transfer block size */\n"
"    fsblkcnt_t   f_blocks;  /* total data blocks in filesystem */\n"
"    fsblkcnt_t   f_bfree;   /* free blocks in fs */\n"
"    fsblkcnt_t   f_bavail;  /* free blocks available to\n"
"                               unprivileged user */\n"
"    fsfilcnt_t   f_files;   /* total file nodes in filesystem */\n"
"    fsfilcnt_t   f_ffree;   /* free file nodes in fs */\n"
"    fsid_t       f_fsid;    /* filesystem id */\n"
"    __SWORD_TYPE f_namelen; /* maximum length of filenames */\n"
"    __SWORD_TYPE f_frsize;  /* fragment size (since Linux 2.6) */\n"
"    __SWORD_TYPE f_spare[5];\n"
"};\n"
msgstr "struct statfs {\n    __SWORD_TYPE f_type;    /* тип файловой системы (см. далее) */\n    __SWORD_TYPE f_bsize;   /* оптимальный размер блока передачи */\n    fsblkcnt_t   f_blocks;  /* общее количество блоков в ФС */\n    fsblkcnt_t   f_bfree;   /* свободных блоков в ФС */\n    fsblkcnt_t   f_bavail;  /* свободных блоков, доступных\n                               обычному пользователю */\n    fsfilcnt_t   f_files;   /* общее количество файловых нод в ФС */\n    fsfilcnt_t   f_ffree;   /* свободных файловых нод в ФС */\n    fsid_t       f_fsid;    /* ID файловой системы */\n    __SWORD_TYPE f_namelen; /* максимальная длина имени файла */\n    __SWORD_TYPE f_frsize;  /* размер фрагмента (начиная с Linux 2.6) */\n    __SWORD_TYPE f_spare[5];\n};\n"

#. type: Plain text
#: man-pages/man2/statfs.2:72
#, no-wrap
msgid "Filesystem types:\n"
msgstr "Типы файловых систем:\n"

#. type: Plain text
#: man-pages/man2/statfs.2:142
#, no-wrap
msgid ""
"   ADFS_SUPER_MAGIC      0xadf5\n"
"   AFFS_SUPER_MAGIC      0xADFF\n"
"   BDEVFS_MAGIC          0x62646576\n"
"   BEFS_SUPER_MAGIC      0x42465331\n"
"   BFS_MAGIC             0x1BADFACE\n"
"   BINFMTFS_MAGIC        0x42494e4d\n"
"   BTRFS_SUPER_MAGIC     0x9123683E\n"
"   CGROUP_SUPER_MAGIC    0x27e0eb\n"
"   CIFS_MAGIC_NUMBER     0xFF534D42\n"
"   CODA_SUPER_MAGIC      0x73757245\n"
"   COH_SUPER_MAGIC       0x012FF7B7\n"
"   CRAMFS_MAGIC          0x28cd3d45\n"
"   DEBUGFS_MAGIC         0x64626720\n"
"   DEVFS_SUPER_MAGIC     0x1373\n"
"   DEVPTS_SUPER_MAGIC    0x1cd1\n"
"   EFIVARFS_MAGIC        0xde5e81e4\n"
"   EFS_SUPER_MAGIC       0x00414A53\n"
"   EXT_SUPER_MAGIC       0x137D\n"
"   EXT2_OLD_SUPER_MAGIC  0xEF51\n"
"   EXT2_SUPER_MAGIC      0xEF53\n"
"   EXT3_SUPER_MAGIC      0xEF53\n"
"   EXT4_SUPER_MAGIC      0xEF53\n"
"   FUSE_SUPER_MAGIC      0x65735546\n"
"   FUTEXFS_SUPER_MAGIC   0xBAD1DEA\n"
"   HFS_SUPER_MAGIC       0x4244\n"
"   HOSTFS_SUPER_MAGIC    0x00c0ffee\n"
"   HPFS_SUPER_MAGIC      0xF995E849\n"
"   HUGETLBFS_MAGIC       0x958458f6\n"
"   ISOFS_SUPER_MAGIC     0x9660\n"
"   JFFS2_SUPER_MAGIC     0x72b6\n"
"   JFS_SUPER_MAGIC       0x3153464a\n"
"   MINIX_SUPER_MAGIC     0x137F /* orig. minix */\n"
"   MINIX_SUPER_MAGIC2    0x138F /* 30 char minix */\n"
"   MINIX2_SUPER_MAGIC    0x2468 /* minix V2 */\n"
"   MINIX2_SUPER_MAGIC2   0x2478 /* minix V2, 30 char names */\n"
"   MINIX3_SUPER_MAGIC    0x4d5a /* minix V3 fs, 60 char names */\n"
"   MQUEUE_MAGIC          0x19800202\n"
"   MSDOS_SUPER_MAGIC     0x4d44\n"
"   NCP_SUPER_MAGIC       0x564c\n"
"   NFS_SUPER_MAGIC       0x6969\n"
"   NILFS_SUPER_MAGIC     0x3434\n"
"   NTFS_SB_MAGIC         0x5346544e\n"
"   OPENPROM_SUPER_MAGIC  0x9fa1\n"
"   PIPEFS_MAGIC          0x50495045\n"
"   PROC_SUPER_MAGIC      0x9fa0\n"
"   PSTOREFS_MAGIC        0x6165676C\n"
"   QNX4_SUPER_MAGIC      0x002f\n"
"   QNX6_SUPER_MAGIC      0x68191122\n"
"   RAMFS_MAGIC           0x858458f6\n"
"   REISERFS_SUPER_MAGIC  0x52654973\n"
"   ROMFS_MAGIC           0x7275\n"
"   SELINUX_MAGIC         0xf97cff8c\n"
"   SMACK_MAGIC           0x43415d53\n"
"   SMB_SUPER_MAGIC       0x517B\n"
"   SOCKFS_MAGIC          0x534F434B\n"
"   SQUASHFS_MAGIC        0x73717368\n"
"   SYSFS_MAGIC           0x62656572\n"
"   SYSV2_SUPER_MAGIC     0x012FF7B6\n"
"   SYSV4_SUPER_MAGIC     0x012FF7B5\n"
"   TMPFS_MAGIC           0x01021994\n"
"   UDF_SUPER_MAGIC       0x15013346\n"
"   UFS_MAGIC             0x00011954\n"
"   USBDEVICE_SUPER_MAGIC 0x9fa2\n"
"   V9FS_MAGIC            0x01021997\n"
"   VXFS_SUPER_MAGIC      0xa501FCF5\n"
"   XENFS_SUPER_MAGIC     0xabba1974\n"
"   XENIX_SUPER_MAGIC     0x012FF7B4\n"
"   XFS_SUPER_MAGIC       0x58465342\n"
"   _XIAFS_SUPER_MAGIC    0x012FD16D\n"
msgstr ""

#. type: Plain text
#: man-pages/man2/statfs.2:148
msgid ""
"Most of these MAGIC constants are defined in I</usr/include/linux/magic.h> "
"some are hardcoded in kernel sources."
msgstr ""

#. type: Plain text
#: man-pages/man2/statfs.2:152
msgid "Nobody knows what I<f_fsid> is supposed to contain (but see below)."
msgstr "Значение I<f_fsid> до конца не определено (но смотрите далее)."

#. type: Plain text
#: man-pages/man2/statfs.2:157
msgid ""
"Fields that are undefined for a particular filesystem are set to 0.  "
"B<fstatfs>()  returns the same information about an open file referenced by "
"descriptor I<fd>."
msgstr "Если поле отсутствует в файловой системе, то его значение устанавливается в 0. Вызов B<fstatfs>() возвращает ту же информацию об открытом файле, на который ссылается дескриптор I<fd>."

#. type: Plain text
#: man-pages/man2/statfs.2:170
msgid ""
"(B<statfs>())  Search permission is denied for a component of the path "
"prefix of I<path>.  (See also B<path_resolution>(7).)"
msgstr "(B<statfs>()) В одном из каталогов префикса пути I<path> не разрешён поиск (см. также B<path_resolution>(7))."

#. type: Plain text
#: man-pages/man2/statfs.2:175
msgid "(B<fstatfs>())  I<fd> is not a valid open file descriptor."
msgstr "(B<fstatfs>()) I<fd> не является корректным открытым дескриптором файла."

#. type: Plain text
#: man-pages/man2/statfs.2:181
msgid "I<buf> or I<path> points to an invalid address."
msgstr "Аргумент I<buf> или I<path> указывает на неправильный адрес."

#. type: Plain text
#: man-pages/man2/statfs.2:184
msgid "This call was interrupted by a signal."
msgstr "Данный вызов был прерван сигналом."

#. type: Plain text
#: man-pages/man2/statfs.2:187
msgid "An I/O error occurred while reading from the filesystem."
msgstr "При чтении файловой системы произошла ошибка ввода-вывода."

#. type: Plain text
#: man-pages/man2/statfs.2:192
msgid ""
"(B<statfs>())  Too many symbolic links were encountered in translating "
"I<path>."
msgstr "(B<statfs>()) Было обнаружено слишком много символьных ссылок при трансляции I<path>."

#. type: Plain text
#: man-pages/man2/statfs.2:197
msgid "(B<statfs>())  I<path> is too long."
msgstr "(B<statfs>()) Слишком длинное значение аргумента I<path>."

#. type: Plain text
#: man-pages/man2/statfs.2:203
msgid "(B<statfs>())  The file referred to by I<path> does not exist."
msgstr "(B<statfs>()) Файл, на который ссылается I<path>, не существует."

#. type: Plain text
#: man-pages/man2/statfs.2:209
msgid "The filesystem does not support this call."
msgstr "Файловая система не поддерживает данный вызов."

#. type: Plain text
#: man-pages/man2/statfs.2:215
msgid ""
"(B<statfs>())  A component of the path prefix of I<path> is not a directory."
msgstr "(B<statfs>()) Компонент в префиксе пути I<path> не является каталогом."

#. type: Plain text
#: man-pages/man2/statfs.2:218
msgid "Some values were too large to be represented in the returned struct."
msgstr "Некоторые значения слишком велики, чтобы быть представленными в возвращаемой структуре."

#. type: Plain text
#: man-pages/man2/statfs.2:224
msgid ""
"Linux-specific.  The Linux B<statfs>()  was inspired by the 4.4BSD one (but "
"they do not use the same structure)."
msgstr "Есть только в Linux. Вызов B<statfs>() основан на подобном из 4.4BSD (но они используют разные структуры)."

#. type: Plain text
#: man-pages/man2/statfs.2:246
msgid ""
"The original Linux B<statfs>()  and B<fstatfs>()  system calls were not "
"designed with extremely large file sizes in mind.  Subsequently, Linux 2.6 "
"added new B<statfs64>()  and B<fstatfs64>()  system calls that employ a new "
"structure, I<statfs64>.  The new structure contains the same fields as the "
"original I<statfs> structure, but the sizes of various fields are increased,"
" to accommodate large file sizes.  The glibc B<statfs>()  and B<fstatfs>()  "
"wrapper functions transparently deal with the kernel differences."
msgstr "Первые версии системных вызовов Linux B<statfs>() и B<fstatfs>() разрабатывались без учёта огромных размеров файлов. В последствии, в Linux 2.6 были добавлены системные вызовы B<statfs64>() и B<fstatfs64>(), в которых используется новая структура, I<statfs64>. Новая структура содержит те же поля что и первоначальная структура I<statfs>, но размеры некоторых полей были увеличены для учёта огромных размеров файлов. Обёрточные функции в glibc B<statfs>() и B<fstatfs>() прозрачно скрывают это различие ядер."

#. type: Plain text
#: man-pages/man2/statfs.2:251
msgid ""
"Some systems only have I<E<lt>sys/vfs.hE<gt>>, other systems also have "
"I<E<lt>sys/statfs.hE<gt>>, where the former includes the latter.  So it "
"seems including the former is the best choice."
msgstr "В одних системах есть только файл I<E<lt>sys/vfs.hE<gt>>, в других также есть файл I<E<lt>sys/statfs.hE<gt>>, при чём первый включает последний. Поэтому, вероятно, лучше включать первый."

#. type: Plain text
#: man-pages/man2/statfs.2:261
msgid ""
"LSB has deprecated the library calls B<statfs>()  and B<fstatfs>()  and "
"tells us to use B<statvfs>(2)  and B<fstatvfs>(2)  instead."
msgstr "В LSB библиотечные вызовы B<statfs>() и B<fstatfs>() помечены как устаревшие, вместе них предлагается использовать B<statvfs>(2) и B<fstatvfs>(2)."

#. type: SS
#: man-pages/man2/statfs.2:261
#, no-wrap
msgid "The f_fsid field"
msgstr "Поле f_fsid"

#. type: Plain text
#: man-pages/man2/statfs.2:286
msgid ""
"Solaris, Irix and POSIX have a system call B<statvfs>(2)  that returns a "
"I<struct statvfs> (defined in I<E<lt>sys/statvfs.hE<gt>>)  containing an "
"I<unsigned long> I<f_fsid>.  Linux, SunOS, HP-UX, 4.4BSD have a system call "
"B<statfs>()  that returns a I<struct statfs> (defined in "
"I<E<lt>sys/vfs.hE<gt>>)  containing a I<fsid_t> I<f_fsid>, where I<fsid_t> "
"is defined as I<struct { int val[2]; }>.  The same holds for FreeBSD, except"
" that it uses the include file I<E<lt>sys/mount.hE<gt>>."
msgstr "В Solaris, Irix и POSIX имеется системный вызов B<statvfs>(2), который возвращает I<struct statvfs> (определена в I<E<lt>sys/statvfs.hE<gt>>), и в ней содержится поле I<unsigned long> I<f_fsid>. В Linux, SunOS, HP-UX, 4.4BSD имеется системный вызов B<statfs>(), который возвращает I<struct statfs> (определена в I<E<lt>sys/vfs.hE<gt>>), и в ней содержится I<fsid_t> I<f_fsid>, где тип I<fsid_t> определён как I<struct { int val[2]; }>. Того же придерживается FreeBSD, за исключением того, что в ней используется включаемый файл I<E<lt>sys/mount.hE<gt>>."

#. type: Plain text
#: man-pages/man2/statfs.2:299
msgid ""
"The general idea is that I<f_fsid> contains some random stuff such that the "
"pair (I<f_fsid>,I<ino>)  uniquely determines a file.  Some operating systems"
" use (a variation on) the device number, or the device number combined with "
"the filesystem type.  Several operating systems restrict giving out the "
"I<f_fsid> field to the superuser only (and zero it for unprivileged users), "
"because this field is used in the filehandle of the filesystem when NFS-"
"exported, and giving it out is a security concern."
msgstr ""

#. type: Plain text
#: man-pages/man2/statfs.2:305
msgid ""
"Under some operating systems, the I<fsid> can be used as the second argument"
" to the B<sysfs>(2)  system call."
msgstr ""

#.  broken in commit ff0c7d15f9787b7e8c601533c015295cc68329f8
#.  fixed in commit d70ef97baf048412c395bb5d65791d8fe133a52b
#. type: Plain text
#: man-pages/man2/statfs.2:314
msgid ""
"From Linux 2.6.38 up to and including Linux 3.1, B<fstatfs>()  failed with "
"the error B<ENOSYS> for file descriptors created by B<pipe>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man2/statfs.2:317
msgid "B<stat>(2), B<statvfs>(2), B<path_resolution>(7)"
msgstr "B<stat>(2), B<statvfs>(2), B<path_resolution>(7)"

#. type: TH
#: man-pages/man2/subpage_prot.2:30
#, no-wrap
msgid "SUBPAGE_PROT"
msgstr "SUBPAGE_PROT"

#. type: Plain text
#: man-pages/man2/subpage_prot.2:33
msgid "subpage_prot - define a subpage protection for an address range"
msgstr "subpage_prot - определяет подстраничную защиту адресного диапазона"

#. type: Plain text
#: man-pages/man2/subpage_prot.2:37
#, no-wrap
msgid ""
"B<long subpage_prot(unsigned long >I<addr>B<, unsigned long >I<len>B<,>\n"
"B<                  uint32_t *>I<map>B<);>\n"
msgstr "B<long subpage_prot(unsigned long >I<addr>B<, unsigned long >I<len>B<,>\nB<                  uint32_t *>I<map>B<);>\n"

#. type: Plain text
#: man-pages/man2/subpage_prot.2:47
msgid ""
"The PowerPC-specific B<subpage_prot>()  system call provides the facility to"
" control the access permissions on individual 4kB subpages on systems "
"configured with a page size of 64kB."
msgstr "Системный вызов (есть только для PowerPC) B<subpage_prot>() предоставляет возможность контроля доступа к отдельным 4КБ подстраницам в системах, где размер страницы равен 64КБ."

#. type: Plain text
#: man-pages/man2/subpage_prot.2:54
msgid ""
"The protection map is applied to the memory pages in the region starting at "
"I<addr> and continuing for I<len> bytes.  Both of these arguments must be "
"aligned to a 64-kB boundary."
msgstr "Карта защиты налагается на страницы памяти для области, начинающейся с I<addr> и имеющей размер I<len> байт. Значения обоих аргументов должны быть выровнены на 64-КБ границу."

#. type: Plain text
#: man-pages/man2/subpage_prot.2:66
msgid ""
"The protection map is specified in the buffer pointed to by I<map>.  The map"
" has 2 bits per 4kB subpage; thus each 32-bit word specifies the protections"
" of 16 4kB subpages inside a 64kB page (so, the number of 32-bit words "
"pointed to by I<map> should equate to the number of 64-kB pages specified by"
" I<len>).  Each 2-bit field in the protection map is either 0 to allow any "
"access, 1 to prevent writes, or 2 or 3 to prevent all accesses."
msgstr "Карта защиты задаётся в буфере, на который указывает I<map>. В карте на каждую 4-килобайтную подстраницу выделяется 2 бита; таким образом, в каждом 32-битном слове задаётся защита для 16 4-килобайтных подстраниц внутри 64-килобайтной страницы (поэтому количество 32-битных слов, на которые указывает I<map>, должно быть равно количеству 64-килобайтных страниц, указанному в I<len>). Каждое 2-битное поле в карте защиты может быть: 0 — полный доступ, 1 — защита от записи, 2 или 3 — запрет на любой доступ."

#. type: Plain text
#: man-pages/man2/subpage_prot.2:71
msgid ""
"On success, B<subpage_prot>()  returns 0.  Otherwise, one of the error codes"
" specified below is returned."
msgstr "При успешном выполнении B<subpage_prot>() возвращается 0. В противном случае возвращается один из кодов ошибок, описанных далее."

#. type: Plain text
#: man-pages/man2/subpage_prot.2:77
msgid "The buffer referred to by I<map> is not accessible."
msgstr "Буфер, на который ссылается I<map>, недоступен."

#. type: Plain text
#: man-pages/man2/subpage_prot.2:87
msgid ""
"The I<addr> or I<len> arguments are incorrect.  Both of these arguments must"
" be aligned to a multiple of the system page size, and they must not refer "
"to a region outside of the address space of the process or to a region that "
"consists of huge pages."
msgstr "Некорректное значение аргумента I<addr> или I<len>. Оба значения должны быть кратны размеру системной страницы, и они не должны указывать на область вне адресного пространства процесса, или на область, которая состоит из огромных страниц."

#. type: Plain text
#: man-pages/man2/subpage_prot.2:96
msgid ""
"This system call is provided on the PowerPC architecture since Linux 2.6.25."
"  The system call is provided only if the kernel is configured with "
"B<CONFIG_PPC_64K_PAGES>.  No library support is provided."
msgstr "Данный системный вызов предоставляется для архитектуры PowerPC начиная с Linux 2.6.25. Для его сборки в ядре должен быть указан параметр B<CONFIG_PPC_64K_PAGES>. В библиотеке поддержка данного вызова отсутствует."

#. type: Plain text
#: man-pages/man2/subpage_prot.2:101
msgid ""
"Glibc does not provide a wrapper for this system call; call it using "
"B<syscall>(2)."
msgstr "В glibc нет обёртки для данного системного вызова; запускайте его с помощью B<syscall>(2)."

#. type: Plain text
#: man-pages/man2/subpage_prot.2:106
msgid ""
"Normal page protections (at the 64-kB page level) also apply; the subpage "
"protection mechanism is an additional constraint, so putting 0 in a 2-bit "
"field won't allow writes to a page that is otherwise write-protected."
msgstr "Обычная страничная защита также работает (на уровне 64-килобайтных страниц); механизм подстраничной защиты является дополнительным ограничением, поэтому указание 0 в 2-битном поле не разрешит запись в страницу, которая защищена от записи другим способом."

#. type: SS
#: man-pages/man2/subpage_prot.2:106
#, no-wrap
msgid "Rationale"
msgstr "Обоснование"

#.  In the initial implementation, it was the case that:
#.      In fact the whole process is switched to use 4k hardware pages when
#. the
#.      subpage_prot system call is used, but this could be improved in future
#.      to switch only the affected segments.
#.  But Paul Mackerass says (Oct 2010): I'm pretty sure we now only switch
#.  the affected segment, not the whole process.
#. type: Plain text
#: man-pages/man2/subpage_prot.2:128
msgid ""
"This system call is provided to assist writing emulators that operate using "
"64-kB pages on PowerPC systems.  When emulating systems such as x86, which "
"uses a smaller page size, the emulator can no longer use the memory-"
"management unit (MMU)  and normal system calls for controlling page "
"protections.  (The emulator could emulate the MMU by checking and possibly "
"remapping the address for each memory access in software, but that is slow.)"
"  The idea is that the emulator supplies an array of protection masks to "
"apply to a specified range of virtual addresses.  These masks are applied at"
" the level where hardware page-table entries (PTEs)  are inserted into the "
"hardware page table based on the Linux PTEs, so the Linux PTEs are not "
"affected.  Implicit in this is that the regions of the address space that "
"are protected are switched to use 4-kB hardware pages rather than 64-kB "
"hardware pages (on machines with hardware 64-kB page support)."
msgstr "Данный системный вызов предоставляется для облегчения написания эмуляторов, которые работают с 64-КБ страницами в системах PowerPC. При эмуляции систем, в которых используется меньший размер страницы (таких как x86), эмулятор не может использовать блок управления памятью (MMU) и обычные системные вызовы управления защитой страниц (эмулятор может эмулировать MMU с помощью ПО проверяя и, возможно, перераспределяя адрес при каждом обращении к памяти, но это медленно). Идея в том, что эмулятор задаёт массив защитных масок для указанного диапазона виртуальных адресов. Эти маски накладываются в месте, где аппаратные табличные записи страниц (PTE) вставляются в аппаратную таблицу страниц на основе Linux PTE, при этом Linux PTE не затрагиваются. В этом случае для защищённых областей адресного пространства начинают неявно использоваться 4-килобайтные аппаратные страницы, а не 64-килобайтные аппаратные страницы (на машинах с аппаратной поддержкой 64-килобайтных страниц)."

#. type: Plain text
#: man-pages/man2/subpage_prot.2:131
msgid "B<mprotect>(2), B<syscall>(2)"
msgstr "B<mprotect>(2), B<syscall>(2)"

#. type: Plain text
#: man-pages/man2/subpage_prot.2:133
msgid "I<Documentation/vm/hugetlbpage.txt> in the Linux kernel source tree"
msgstr "Файл I<Documentation/vm/hugetlbpage.txt> в дереве исходного кода ядра Linux"

#. type: TH
#: man-pages/man5/slabinfo.5:34
#, no-wrap
msgid "SLABINFO"
msgstr "SLABINFO"

#. type: TH
#: man-pages/man5/slabinfo.5:34
#, no-wrap
msgid "2007-09-30"
msgstr "2007-09-30"

#. type: Plain text
#: man-pages/man5/slabinfo.5:37
msgid "/proc/slabinfo - kernel slab allocator statistics"
msgstr "/proc/slabinfo - сводная таблица использования блоков кэша (slab) ядра"

#. type: Plain text
#: man-pages/man5/slabinfo.5:39
msgid "B<cat /proc/slabinfo>"
msgstr "B<cat /proc/slabinfo>"

#. type: Plain text
#: man-pages/man5/slabinfo.5:47
msgid ""
"Frequently used objects in the Linux kernel (buffer heads, inodes, dentries,"
" etc.)  have their own cache.  The file I</proc/slabinfo> gives statistics."
"  For example:"
msgstr "Часто используемые объекты в ядре Linux (заголовки буферов, записи inode, элементы dentry и т.п.) имеют свой собственный кэш-блок. В файле /proc/slabinfo отражена статистика их работы. Например:"

#. type: Plain text
#: man-pages/man5/slabinfo.5:64
#, no-wrap
msgid ""
"% cat /proc/slabinfo\n"
"slabinfo - version: 1.1\n"
"kmem_cache            60     78    100    2    2    1\n"
"blkdev_requests     5120   5120     96  128  128    1\n"
"mnt_cache             20     40     96    1    1    1\n"
"inode_cache         7005  14792    480 1598 1849    1\n"
"dentry_cache        5469   5880    128  183  196    1\n"
"filp                 726    760     96   19   19    1\n"
"buffer_head        67131  71240     96 1776 1781    1\n"
"vm_area_struct      1204   1652     64   23   28    1\n"
"\\&...\n"
"size-8192              1     17   8192    1   17    2\n"
"size-4096             41     73   4096   41   73    1\n"
"\\&...\n"
msgstr "% cat /proc/slabinfo\nslabinfo - version: 1.1\nkmem_cache            60     78    100    2    2    1\nblkdev_requests     5120   5120     96  128  128    1\nmnt_cache             20     40     96    1    1    1\ninode_cache         7005  14792    480 1598 1849    1\ndentry_cache        5469   5880    128  183  196    1\nfilp                 726    760     96   19   19    1\nbuffer_head        67131  71240     96 1776 1781    1\nvm_area_struct      1204   1652     64   23   28    1\n\\&...\nsize-8192              1     17   8192    1   17    2\nsize-4096             41     73   4096   41   73    1\n\\&...\n"

#. type: Plain text
#: man-pages/man5/slabinfo.5:72
msgid ""
"For each slab cache, the cache name, the number of currently active objects,"
" the total number of available objects, the size of each object in bytes, "
"the number of pages with at least one active object, the total number of "
"allocated pages, and the number of pages per slab are given."
msgstr "Для каждого кэш-блока выводится: название, количество активных объектов на текущий момент, общее число доступных объектов, размер каждого объекта в байтах, количество страниц как минимум с одним активным объектом, общее число размещённых страниц и число страниц в каждом блоке."

#. type: Plain text
#: man-pages/man5/slabinfo.5:77
msgid ""
"Note that because of object alignment and slab cache overhead, objects are "
"not normally packed tightly into pages.  Pages with even one in-use object "
"are considered in-use and cannot be freed."
msgstr "Заметим, что из-за выравнивания объектов и заголовков блоков кэша объекты обычно не упакованы ровно по страницам. Страницы даже с единственным используемым объектом уже сами считаются используемыми и не могут быть высвобождены."

#. type: Plain text
#: man-pages/man5/slabinfo.5:89
msgid ""
"Kernels compiled with slab cache statistics will also have \"(statistics)\" "
"in the first line of output, and will have 5 additional columns, namely: the"
" high water mark of active objects; the number of times objects have been "
"allocated; the number of times the cache has grown (new pages added to this "
"cache); the number of times the cache has been reaped (unused pages removed "
"from this cache); and the number of times there was an error allocating new "
"pages to this cache.  If slab cache statistics are not enabled for this "
"kernel, these columns will not be shown."
msgstr "Ядра, собранные с поддержкой статистики использования блоков кэша в начале вывода содержат строку \"(statistics)\", а также 5 дополнительных колонок: верхняя отметка для активных объектов; количество раз когда производилось размещение под объекты; количество увеличений размера кэша (то есть число добавлений новых страниц к кэшу); количество уплотнений кэша (то есть сколько раз удалялись пустые страницы из кэша); количество ошибок при размещении новых страниц в этом кэше. Если статистика блоков кэша не включена для ядра, то эти колонки не будут показаны."

#. type: Plain text
#: man-pages/man5/slabinfo.5:102
msgid ""
"SMP systems will also have \"(SMP)\" in the first line of output, and will "
"have two additional columns for each slab, reporting the slab allocation "
"policy for the CPU-local cache (to reduce the need for inter-CPU "
"synchronization when allocating objects from the cache).  The first column "
"is the per-CPU limit: the maximum number of objects that will be cached for "
"each CPU.  The second column is the batchcount: the maximum number of free "
"objects in the global cache that will be transferred to the per-CPU cache if"
" it is empty, or the number of objects to be returned to the global cache if"
" the per-CPU cache is full."
msgstr "Многопроцессорные системы имеют в начале вывода статистики строку \"(SMP)\", а также две дополнительных колонки для каждого блока, показывающие политики размещения блоков для локального кэша процессора (для снижения необходимости в межпроцессорной синхронизации при размещении объектов в кэше). Первая колонка хранит предел для каждого процессора: максимальное число кэшируемых объектов для каждого процессора. Второй колонкой является счетчик: максимальное число свободных объектов в общем кэше, передаваемое в кэш каждого процессора (если он пуст) или число объектов, возвращаемых в общий кэш, если кэш процессора заполнен полностью."

#. type: Plain text
#: man-pages/man5/slabinfo.5:114
msgid ""
"If both slab cache statistics and SMP are defined, there will be four "
"additional columns, reporting the per-CPU cache statistics.  The first two "
"are the per-CPU cache allocation hit and miss counts: the number of times an"
" object was or was not available in the per-CPU cache for allocation.  The "
"next two are the per-CPU cache free hit and miss counts: the number of times"
" a freed object could or could not fit within the per-CPU cache limit, "
"before flushing objects to the global cache."
msgstr "Если для блоков кэша показаны и statistics и SMP, то будет ещё четыре дополнительных колонки, сообщающих о статистике кэша для каждого процессора. Первые две являются счетчиками попадания и промахов кэша для каждого процессора: то есть сколько раз объект был (или не был) в кэше. Следующие две являются счетчиками попаданий и промахов высвобождений объектов, то есть сколько раз объект мог (или не мог) попасть внутрь предела кэша для каждого процессора перед сбросом объектов в глобальный кэш."

#. type: Plain text
#: man-pages/man5/slabinfo.5:117
msgid ""
"It is possible to tune the SMP per-CPU slab cache limit and batchcount via:"
msgstr "Можно настраивать границы и счетчики блоков кэша для каждого процессора (в мультипроцессорной системе SMP) с помощью:"

#. type: Plain text
#: man-pages/man5/slabinfo.5:121
#, no-wrap
msgid "echo \"I<cache_name limit batchcount>\" E<gt> /proc/slabinfo\n"
msgstr "echo \"I<cache_name limit batchcount>\" E<gt> /proc/slabinfo\n"

#. type: Plain text
#: man-pages/man5/slabinfo.5:125
msgid "I<E<lt>linux/slab.hE<gt>>"
msgstr "I<E<lt>linux/slab.hE<gt>>"

#. type: Plain text
#: man-pages/man5/slabinfo.5:129
msgid ""
"I</proc/slabinfo> exists since Linux 2.1.23.  SMP per-CPU caches exist since"
" Linux 2.4.0-test3."
msgstr "Файл I</proc/slabinfo> существует с Linux 2.1.23. Кэши для отдельных процессоров в многопроцессорных системах (SMP) существуют начиная с Linux 2.4.0-test3."

#. type: Plain text
#: man-pages/man5/slabinfo.5:134
msgid ""
"Since Linux 2.6.16 the file I</proc/slabinfo> is present only if the "
"B<CONFIG_SLAB> kernel configuration option is enabled."
msgstr "Начиная с Linux 2.6.16 файл I</proc/slabinfo> существует, только если включён параметр настройки ядра B<CONFIG_SLAB>."

#. type: TH
#: man-pages/man5/securetty.5:26
#, no-wrap
msgid "SECURETTY"
msgstr "SECURETTY"

#. type: TH
#: man-pages/man5/securetty.5:26
#, no-wrap
msgid "1992-12-29"
msgstr "1992-12-29"

#. type: Plain text
#: man-pages/man5/securetty.5:29
msgid "securetty - file which lists terminals from which root can log in"
msgstr "securetty - файл со списком терминалов, с которых пользователь root может входить в систему"

#. type: Plain text
#: man-pages/man5/securetty.5:41
msgid ""
"The file I</etc/securetty> is used by (some versions of)  B<login>(1).  The "
"file contains the device names of terminal lines (one per line, without "
"leading I</dev/>)  on which root is allowed to login.  See B<login.defs>(5)"
"  if you use the shadow suite."
msgstr "Файл I</etc/securetty> используется (некоторыми версиями) программы B<login>(1). Этот файл содержит имена устройств терминальных линий (по одному на строку, без начального I</dev/>), с которых пользователю root разрешается вход в систему. См. B<login.defs>(5), если используется механизм теневых паролей."

#. type: Plain text
#: man-pages/man5/securetty.5:43
msgid "I</etc/securetty>"
msgstr "I</etc/securetty>"

#. type: Plain text
#: man-pages/man5/securetty.5:45
msgid "B<login>(1), B<login.defs>(5)"
msgstr "B<login>(1), B<login.defs>(5)"

#. type: TH
#: man-pages/man5/services.5:34
#, no-wrap
msgid "SERVICES"
msgstr "SERVICES"

#. type: TH
#: man-pages/man5/services.5:34
#, no-wrap
msgid "2010-05-22"
msgstr "2010-05-22"

#. type: Plain text
#: man-pages/man5/services.5:37
msgid "services - Internet network services list"
msgstr "services - список служб сети Интернет"

#. type: Plain text
#: man-pages/man5/services.5:52
msgid ""
"B<services> is a plain ASCII file providing a mapping between human-friendly"
" textual names for internet services, and their underlying assigned port "
"numbers and protocol types.  Every networking program should look into this "
"file to get the port number (and protocol) for its service.  The C library "
"routines B<getservent>(3), B<getservbyname>(3), B<getservbyport>(3), "
"B<setservent>(3), and B<endservent>(3)  support querying this file from "
"programs."
msgstr "B<services> — это простой файл в кодировке ASCII, обеспечивающий распределение соответствующих текстовых имён между службами интернет, связанных с ними назначений портов и типов протоколов. Любая сетевая программа должна сначала обратиться к этому файлу для получения номера порта (и протокола) для своей службы. Функции библиотеки C B<getservent>(3), B<getservbyname>(3), B<getservbyport>(3), B<setservent>(3) и B<endservent>(3) выполняют запросы программ к этому файлу."

#. type: Plain text
#: man-pages/man5/services.5:58
msgid ""
"Port numbers are assigned by the IANA (Internet Assigned Numbers Authority),"
" and their current policy is to assign both TCP and UDP protocols when "
"assigning a port number.  Therefore, most entries will have two entries, "
"even for TCP-only services."
msgstr "Номера портов назначаются IANA (Internet Assigned Numbers Authority), и их текущей политикой является указание TCP- и UDP-протоколов при назначении номера порта. Следовательно, большинство элементов будет иметь двойные значения даже для служб, которые используют только TCP."

#. type: Plain text
#: man-pages/man5/services.5:70
msgid ""
"Port numbers below 1024 (so-called \"low numbered\" ports) can be bound to "
"only by root (see B<bind>(2), B<tcp>(7), and B<udp>(7)).  This is so clients"
" connecting to low numbered ports can trust that the service running on the "
"port is the standard implementation, and not a rogue service run by a user "
"of the machine.  Well-known port numbers specified by the IANA are normally "
"located in this root-only space."
msgstr "Номера портов меньше 1024 (так называемые «привилегированные» порты) могут быть задействованы только суперпользователем (смотрите B<bind>(2), B<tcp>(7) и B<udp>(7)). Это делается для того, чтобы клиенты, подключающиеся к привилегированным портам, могли не сомневаться в том, что служба, работающая на порту, обеспечивает стандартную реализацию, и не является «подставной» службой какого-нибудь пользователя в машине. Известные номера портов, определённые IANA, обычно располагаются только в пространстве суперпользователя."

#. type: Plain text
#: man-pages/man5/services.5:85
msgid ""
"The presence of an entry for a service in the B<services> file does not "
"necessarily mean that the service is currently running on the machine.  See "
"B<inetd.conf>(5)  for the configuration of Internet services offered.  Note "
"that not all networking services are started by B<inetd>(8), and so won't "
"appear in B<inetd.conf>(5).  In particular, news (NNTP) and mail (SMTP) "
"servers are often initialized from the system boot scripts."
msgstr "Присутствие элемента службы в файле B<services> не обязательно означает, что эта служба сейчас запущена на машине. Смотрите B<inetd.conf>(5) для знакомства с настройкой служб интернета. Заметим, что не все сетевые службы запускаются с помощью B<inetd>(8), и поэтому могут отсутствовать в B<inetd.conf>(5). В частности, серверы новостей (NNTP) и почтовые серверы (SMTP) часто запускаются с помощью системных загрузочных сценариев."

#. type: Plain text
#: man-pages/man5/services.5:94
msgid ""
"The location of the B<services> file is defined by B<_PATH_SERVICES> in "
"I<E<lt>netdb.hE<gt>>.  This is usually set to I</etc/services>."
msgstr "Расположение файла B<services> определяется B<_PATH_SERVICES> в I<E<lt>netdb.hE<gt>>. Обычно значением является I</etc/services>."

#. type: Plain text
#: man-pages/man5/services.5:96
msgid "Each line describes one service, and is of the form:"
msgstr "Каждая строка определяет одну службу и имеет следующий формат:"

#. type: Plain text
#: man-pages/man5/services.5:98
msgid "I<service-name\\ \\ \\ port>B</>I<protocol\\ \\ \\ >[I<aliases ...>]"
msgstr "I<имя-службы\\ \\ \\ порт>B</>I<протокол\\ \\ \\ >[I<псевдонимы ...>]"

#. type: TP
#: man-pages/man5/services.5:98
#, no-wrap
msgid "where:"
msgstr "где:"

#. type: TP
#: man-pages/man5/services.5:100
#, no-wrap
msgid "I<service-name>"
msgstr "I<имя-службы>"

#. type: Plain text
#: man-pages/man5/services.5:106
msgid ""
"is the friendly name the service is known by and looked up under.  It is "
"case sensitive.  Often, the client program is named after the I<service-"
"name>."
msgstr "Известное имя службы, по которому она в дальнейшем будет определяться. Регистр символов имеет значение. Часто клиентские программы называются по I<имени-службы>."

#. type: TP
#: man-pages/man5/services.5:106
#, no-wrap
msgid "I<port>"
msgstr "I<порт>"

#. type: Plain text
#: man-pages/man5/services.5:109
msgid "is the port number (in decimal) to use for this service."
msgstr "Номер порта (в десятичном формате), используемый данной службой."

#. type: TP
#: man-pages/man5/services.5:109
#, no-wrap
msgid "I<protocol>"
msgstr "I<протокол>"

#. type: Plain text
#: man-pages/man5/services.5:120
msgid ""
"is the type of protocol to be used.  This field should match an entry in the"
" B<protocols>(5)  file.  Typical values include B<tcp> and B<udp>."
msgstr "Тип протокола, который будет использоваться. Это поле должно совпадать с элементом в файле B<protocols>(5). Обычно, значением является B<tcp> и B<udp>."

#. type: TP
#: man-pages/man5/services.5:120
#, no-wrap
msgid "I<aliases>"
msgstr "I<псевдонимы>"

#. type: Plain text
#: man-pages/man5/services.5:126
msgid ""
"is an optional space or tab separated list of other names for this service."
"  Again, the names are case sensitive."
msgstr "Дополнительный список имён этой службы, разделённых символами табуляции или пробелами. Снова заметим, что имеет значение регистр символов."

#. type: Plain text
#: man-pages/man5/services.5:128
msgid "Either spaces or tabs may be used to separate the fields."
msgstr "Для разделения полей могут использоваться пробелы или символы табуляции."

#. type: Plain text
#: man-pages/man5/services.5:132
msgid ""
"Comments are started by the hash sign (#) and continue until the end of the "
"line.  Blank lines are skipped."
msgstr "Комментарии начинаются с символа решетки (#) и продолжаются до конца строки. Пустые строки пропускаются."

#. type: Plain text
#: man-pages/man5/services.5:143
msgid ""
"The I<service-name> should begin in the first column of the file, since "
"leading spaces are not stripped.  I<service-names> can be any printable "
"characters excluding space and tab.  However, a conservative choice of "
"characters should be used to minimize compatibility problems.  For example, "
"a-z, 0-9, and hyphen (-) would seem a sensible choice."
msgstr "I<Имя службы> должно начинаться с первого столбца файла, так как начальные пробелы не удаляются В I<имени службы> могут использоваться любые печатные символы (исключая пробелы и символы табуляции). Однако, лучше использовать стандартный набор символов для уменьшения проблем с совместимостью. Например, a-z, 0-9 и дефис (-) наиболее подходящий набор."

#. type: Plain text
#: man-pages/man5/services.5:152
msgid ""
"Lines not matching this format should not be present in the file.  "
"(Currently, they are silently skipped by B<getservent>(3), "
"B<getservbyname>(3), and B<getservbyport>(3).  However, this behavior should"
" not be relied on.)"
msgstr "В файле не должно быть строк в другом формате (в данный момент они просто пропускаются программами B<getservent>(3), B<getservbyname>(3) и B<getservbyport>(3). Однако, на это не стоит полагаться)."

#.  The following is not true as at glibc 2.8 (a line with a comma is
#.  ignored by getservent()); it's not clear if/when it was ever true.
#.    As a backward compatibility feature, the slash (/) between the
#.    .I port
#.    number and
#.    .I protocol
#.    name can in fact be either a slash or a comma (,).
#.    Use of the comma in
#.    modern installations is deprecated.
#. type: Plain text
#: man-pages/man5/services.5:165
msgid ""
"This file might be distributed over a network using a network-wide naming "
"service like Yellow Pages/NIS or BIND/Hesiod."
msgstr "Данный файл может распространяться по сети с помощью сетевых служб имён, таких как Yellow Pages/NIS или BIND/Hesiod."

#. type: Plain text
#: man-pages/man5/services.5:169
msgid "A sample B<services> file might look like this:"
msgstr "Пример файла B<services>:"

#. type: Plain text
#: man-pages/man5/services.5:182
#, no-wrap
msgid ""
"CW<netstat         15/tcp\n"
"qotd            17/tcp          quote\n"
"msp             18/tcp          # message send protocol\n"
"msp             18/udp          # message send protocol\n"
"chargen         19/tcp          ttytst source\n"
"chargen         19/udp          ttytst source\n"
"ftp             21/tcp\n"
"# 22 - unassigned\n"
"telnet          23/tcp>\n"
msgstr "CW<netstat         15/tcp\nqotd            17/tcp          quote\nmsp             18/tcp          # message send protocol\nmsp             18/udp          # message send protocol\nchargen         19/tcp          ttytst source\nchargen         19/udp          ttytst source\nftp             21/tcp\n# 22 - unassigned\ntelnet          23/tcp>\n"

#. type: TP
#: man-pages/man5/services.5:186
#, no-wrap
msgid "I</etc/services>"
msgstr "I</etc/services>"

#. type: Plain text
#: man-pages/man5/services.5:189
msgid "The Internet network services list"
msgstr "список сетевых служб интернет"

#. type: TP
#: man-pages/man5/services.5:189
#, no-wrap
msgid "I<E<lt>netdb.hE<gt>>"
msgstr "I<E<lt>netdb.hE<gt>>"

#.  .SH BUGS
#.  It's not clear when/if the following was ever true;
#.  it isn't true for glibc 2.8:
#.     There is a maximum of 35 aliases, due to the way the
#.     .BR getservent (3)
#.     code is written.
#.  It's not clear when/if the following was ever true;
#.  it isn't true for glibc 2.8:
#.     Lines longer than
#.     .B BUFSIZ
#.     (currently 1024) characters will be ignored by
#.     .BR getservent (3),
#.     .BR getservbyname (3),
#.     and
#.     .BR getservbyport (3).
#.     However, this will also cause the next line to be mis-parsed.
#. type: Plain text
#: man-pages/man5/services.5:210
msgid "Definition of B<_PATH_SERVICES>"
msgstr "Определение B<_PATH_SERVICES>"

#. type: Plain text
#: man-pages/man5/services.5:220
msgid ""
"B<listen>(2), B<endservent>(3), B<getservbyname>(3), B<getservbyport>(3), "
"B<getservent>(3), B<setservent>(3), B<inetd.conf>(5), B<protocols>(5), "
"B<inetd>(8)"
msgstr "B<listen>(2), B<endservent>(3), B<getservbyname>(3), B<getservbyport>(3), B<getservent>(3), B<setservent>(3), B<inetd.conf>(5), B<protocols>(5), B<inetd>(8)"

#. type: Plain text
#: man-pages/man5/services.5:221
msgid "Assigned Numbers RFC, most recently RFC\\ 1700, (AKA STD0002)."
msgstr "RFC с назначенными номерами, последний RFC\\ 1700, (т.н. STD0002)."

#. type: TH
#: man-pages/man5/shells.5:28
#, no-wrap
msgid "SHELLS"
msgstr "SHELLS"

#. type: TH
#: man-pages/man5/shells.5:28
#, no-wrap
msgid "2012-12-31"
msgstr "2012-12-31"

#. type: Plain text
#: man-pages/man5/shells.5:31
msgid "shells - pathnames of valid login shells"
msgstr "shells - полные имена файлов разрешённых входных оболочек"

#. type: Plain text
#: man-pages/man5/shells.5:37
msgid ""
"I</etc/shells> is a text file which contains the full pathnames of valid "
"login shells.  This file is consulted by B<chsh>(1)  and available to be "
"queried by other programs."
msgstr "I</etc/shells> - это текстовый файл, содержащий полные имена файлов разрешённых входных оболочек. Этот файл учитывается B<chsh>(1)  и может быть затребован другими программами."

#. type: Plain text
#: man-pages/man5/shells.5:43
msgid ""
"Be aware that there are programs which consult this file to find out if a "
"user is a normal user; for example, FTP daemons traditionally disallow "
"access to users with shells not included in this file."
msgstr "Удостоверьтесь, что те программы, которые учитывают этот файл, если пользователь является обычным пользователем; например, службы FTP, обычно, отключают доступ для тех пользователей, входные оболочки которых не указаны в этом файле."

#. type: Plain text
#: man-pages/man5/shells.5:45
msgid "I</etc/shells>"
msgstr "I</etc/shells>"

#. type: Plain text
#: man-pages/man5/shells.5:48
msgid "I</etc/shells> may contain the following paths:"
msgstr "I</etc/shells> может содержать следующие пути:"

#. type: Plain text
#: man-pages/man5/shells.5:51
msgid "I</bin/sh>"
msgstr "I</bin/sh>"

#. type: Plain text
#: man-pages/man5/shells.5:53
msgid "I</bin/bash>"
msgstr "I</bin/bash>"

#. type: Plain text
#: man-pages/man5/shells.5:55
msgid "I</bin/csh>"
msgstr "I</bin/csh>"

#. type: Plain text
#: man-pages/man5/shells.5:58
msgid "B<chsh>(1), B<getusershell>(3)"
msgstr "B<chsh>(1), B<getusershell>(3)"

#. type: TH
#: man-pages/man3/strlen.3:30
#, no-wrap
msgid "STRLEN"
msgstr "STRLEN"

#. type: Plain text
#: man-pages/man3/strlen.3:33
msgid "strlen - calculate the length of a string"
msgstr "strlen - вычисление длины строки"

#. type: Plain text
#: man-pages/man3/strlen.3:36
#, no-wrap
msgid "B<#include E<lt>string.hE<gt>>\n"
msgstr "B<#include E<lt>string.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/strlen.3:38
#, no-wrap
msgid "B<size_t strlen(const char *>I<s>B<);>\n"
msgstr "B<size_t strlen(const char *>I<s>B<);>\n"

#. type: Plain text
#: man-pages/man3/strlen.3:45
msgid ""
"The B<strlen>()  function calculates the length of the string I<s>, "
"excluding the terminating null byte (\\(aq\\e0\\(aq)."
msgstr "Функция B<strlen>() подсчитывает длину строки I<s> без учета завершающего байта null (\\(aq\\e0\\(aq)."

#. type: Plain text
#: man-pages/man3/strlen.3:50
msgid ""
"The B<strlen>()  function returns the number of bytes in the string I<s>."
msgstr "Функция B<strlen>() возвращает количество байт в строке I<s>."

#. type: SH
#: man-pages/man3/strlen.3:50
#, no-wrap
msgid "ATTRIBUTES"
msgstr "АТРИБУТЫ"

#. type: SS
#: man-pages/man3/strlen.3:51
#, no-wrap
msgid "Multithreading (see pthreads(7))"
msgstr "Многонитевость (смотрите pthreads(7))"

#. type: Plain text
#: man-pages/man3/strlen.3:55
msgid "The B<strlen>()  function is thread-safe."
msgstr "Функцию B<strlen>() можно использовать в нескольких нитях одновременно."

#. type: Plain text
#: man-pages/man3/strlen.3:57
msgid "SVr4, 4.3BSD, C89, C99."
msgstr "SVr4, 4.3BSD, C89, C99."

#. type: Plain text
#: man-pages/man3/strlen.3:61
msgid "B<string>(3), B<strnlen>(3), B<wcslen>(3), B<wcsnlen>(3)"
msgstr "B<string>(3), B<strnlen>(3), B<wcslen>(3), B<wcsnlen>(3)"

#. type: TH
#: man-pages/man3/shm_open.3:26
#, no-wrap
msgid "SHM_OPEN"
msgstr "SHM_OPEN"

#. type: TH
#: man-pages/man3/shm_open.3:26
#, no-wrap
msgid "2009-02-25"
msgstr "2009-02-25"

#. type: Plain text
#: man-pages/man3/shm_open.3:29
msgid ""
"shm_open, shm_unlink - create/open or unlink POSIX shared memory objects"
msgstr "shm_open, shm_unlink - создаёт/открывает или удаляет объекты общей памяти POSIX"

#. type: Plain text
#: man-pages/man3/shm_open.3:31
msgid "B<#include E<lt>sys/mman.hE<gt>>"
msgstr "B<#include E<lt>sys/mman.hE<gt>>"

#. type: Plain text
#: man-pages/man3/shm_open.3:33
msgid "B<#include E<lt>sys/stat.hE<gt>> /* For mode constants */"
msgstr "B<#include E<lt>sys/stat.hE<gt>> /* константы для mode */"

#. type: Plain text
#: man-pages/man3/shm_open.3:35
msgid "B<#include E<lt>fcntl.hE<gt>> /* For O_* constants */"
msgstr "B<#include E<lt>fcntl.hE<gt>>    /* константы O_* */"

#. type: Plain text
#: man-pages/man3/shm_open.3:37
msgid ""
"B<int shm_open(const char *>I<name>B<, int >I<oflag>B<, mode_t >I<mode>B<);>"
msgstr "B<int shm_open(const char *>I<name>B<, int >I<oflag>B<, mode_t >I<mode>B<);>"

#. type: Plain text
#: man-pages/man3/shm_open.3:39
msgid "B<int shm_unlink(const char *>I<name>B<);>"
msgstr "B<int shm_unlink(const char *>I<name>B<);>"

#. type: Plain text
#: man-pages/man3/shm_open.3:41
msgid "Link with I<-lrt>."
msgstr "Компонуется при указании параметра I<-lrt>."

#. type: Plain text
#: man-pages/man3/shm_open.3:53
msgid ""
"B<shm_open>()  creates and opens a new, or opens an existing, POSIX shared "
"memory object.  A POSIX shared memory object is in effect a handle which can"
" be used by unrelated processes to B<mmap>(2)  the same region of shared "
"memory.  The B<shm_unlink>()  function performs the converse operation, "
"removing an object previously created by B<shm_open>()."
msgstr "Функция B<shm_open>() создаёт и открывает новый (или открывает уже существующий) объект общей памяти POSIX. Объект общей памяти POSIX — это описатель, используемый несвязанными процессами для выполнения B<mmap>(2) для одной области общей памяти. Функция B<shm_unlink>() выполняет обратную операцию, удаляя объект, созданный ранее с помощью B<shm_open>()."

#.  glibc allows the initial slash to be omitted, and makes
#.  multiple initial slashes equivalent to a single slash.
#.  This differs from the implementation of POSIX message queues.
#.  glibc allows subdirectory components in the name, in which
#.  case the subdirectory must exist under /dev/shm, and allow the
#.  required permissions if a user wants to create a shared memory
#.  object in that subdirectory.
#. type: Plain text
#: man-pages/man3/shm_open.3:74
msgid ""
"The operation of B<shm_open>()  is analogous to that of B<open>(2).  I<name>"
" specifies the shared memory object to be created or opened.  For portable "
"use, a shared memory object should be identified by a name of the form "
"I</somename>; that is, a null-terminated string of up to B<NAME_MAX> (i.e., "
"255) characters consisting of an initial slash, followed by one or more "
"characters, none of which are slashes."
msgstr "Действие B<shm_open>() аналогично B<open>(2). Значением I<name> определяется создаваемый или открываемый объект общей памяти. Для использования в переносимых программах объект общей памяти должен опознаваться по имени в виде I</какое_то_имя>, то есть строкой, оканчивающейся null и длиной до I<NAME_MAX> (т.е., 255) символов, состоящей из начальной косой черты и одного или более символов (любых, кроме косой черты)."

#. type: Plain text
#: man-pages/man3/shm_open.3:81
msgid ""
"I<oflag> is a bit mask created by ORing together exactly one of B<O_RDONLY> "
"or B<O_RDWR> and any of the other flags listed here:"
msgstr "Аргумент I<oflag> содержит маску битов, созданную логическим сложением OR одного из флагов B<O_RDONLY> или B<O_RWDR> и любых других флагов, перечисленных далее:"

#. type: TP
#: man-pages/man3/shm_open.3:81
#, no-wrap
msgid "B<O_RDONLY>"
msgstr "B<O_RDONLY>"

#. type: Plain text
#: man-pages/man3/shm_open.3:89
msgid ""
"Open the object for read access.  A shared memory object opened in this way "
"can be B<mmap>(2)ed only for read (B<PROT_READ>)  access."
msgstr "Открыть объект для чтения. Открытый таким образом объект общей памяти можно указывать в B<mmap>(2) только для чтения (B<PROT_READ>)."

#. type: TP
#: man-pages/man3/shm_open.3:89
#, no-wrap
msgid "B<O_RDWR>"
msgstr "B<O_RDWR>"

#. type: Plain text
#: man-pages/man3/shm_open.3:92
msgid "Open the object for read-write access."
msgstr "Открыть объект для чтения и записи."

#. type: TP
#: man-pages/man3/shm_open.3:92
#, no-wrap
msgid "B<O_CREAT>"
msgstr "B<O_CREAT>"

#.  In truth it is actually the filesystem IDs on Linux, but these
#.  are nearly always the same as the effective IDs.  (MTK, Jul 05)
#. type: Plain text
#: man-pages/man3/shm_open.3:112
msgid ""
"Create the shared memory object if it does not exist.  The user and group "
"ownership of the object are taken from the corresponding effective IDs of "
"the calling process, and the object's permission bits are set according to "
"the low-order 9 bits of I<mode>, except that those bits set in the process "
"file mode creation mask (see B<umask>(2))  are cleared for the new object.  "
"A set of macro constants which can be used to define I<mode> is listed in "
"B<open>(2).  (Symbolic definitions of these constants can be obtained by "
"including I<E<lt>sys/stat.hE<gt>>.)"
msgstr "Создать объект общей памяти, если он не существует. Владелец и группа объекта устанавливаются из соответствующих эффективных ID вызвавшего процесса, а биты прав на объект устанавливаются в соответствии с младшими 9 битами I<mode>, за исключением того, что биты, установленные маске режима создания файла (см. B<umask>(2)), очищаются у новых объектов. Набор макросов-констант, используемых для определения I<mode>, описан в B<open>(2). Символические определения этих констант можно получить включением I<E<lt>sys/stat.hE<gt>>."

#. type: Plain text
#: man-pages/man3/shm_open.3:118
msgid ""
"A new shared memory object initially has zero length\\(emthe size of the "
"object can be set using B<ftruncate>(2).  The newly allocated bytes of a "
"shared memory object are automatically initialized to 0."
msgstr "Новый объект общей памяти изначально имеет нулевую длину; размер объекта можно установить, используя B<ftruncate>(2). Новые выделенные байты объекта общей памяти автоматически заполняются 0."

#. type: TP
#: man-pages/man3/shm_open.3:118
#, no-wrap
msgid "B<O_EXCL>"
msgstr "B<O_EXCL>"

#. type: Plain text
#: man-pages/man3/shm_open.3:127
msgid ""
"If B<O_CREAT> was also specified, and a shared memory object with the given "
"I<name> already exists, return an error.  The check for the existence of the"
" object, and its creation if it does not exist, are performed atomically."
msgstr "Если также был указан B<O_CREAT> и объект общей памяти с заданным I<name> уже существует, то возвращается ошибка. Проверка существования объекта и его создание, если он не существует, выполняется атомарно."

#. type: TP
#: man-pages/man3/shm_open.3:127
#, no-wrap
msgid "B<O_TRUNC>"
msgstr "B<O_TRUNC>"

#. type: Plain text
#: man-pages/man3/shm_open.3:130
msgid "If the shared memory object already exists, truncate it to zero bytes."
msgstr "Если объект общей памяти уже существует, то обрезать его до 0 байтов."

#. type: Plain text
#: man-pages/man3/shm_open.3:133
msgid ""
"Definitions of these flag values can be obtained by including "
"I<E<lt>fcntl.hE<gt>>."
msgstr "Определения значений этих флагов можно получить включением I<E<lt>fcntl.hE<gt>>."

#. type: Plain text
#: man-pages/man3/shm_open.3:144
msgid ""
"On successful completion B<shm_open>()  returns a new file descriptor "
"referring to the shared memory object.  This file descriptor is guaranteed "
"to be the lowest-numbered file descriptor not previously opened within the "
"process.  The B<FD_CLOEXEC> flag (see B<fcntl>(2))  is set for the file "
"descriptor."
msgstr "При успешном выполнении B<shm_open>() возвращает новый файловый дескриптор, ссылающийся на объект общей памяти. Этот файловый дескриптор гарантированно будет дескриптором файла с самым маленьким номером среди ещё не открытых процессом. У дескриптора файла устанавливается флаг B<FD_CLOEXEC> (см. B<fcntl>(2))."

#. type: Plain text
#: man-pages/man3/shm_open.3:153
msgid ""
"The file descriptor is normally used in subsequent calls to B<ftruncate>(2)"
"  (for a newly created object) and B<mmap>(2).  After a call to B<mmap>(2)  "
"the file descriptor may be closed without affecting the memory mapping."
msgstr "Дескриптор файла обычно используется в последующих вызовах B<ftruncate>(2) (для новых объектов) и B<mmap>(2). После вызова B<mmap>(2) дескриптор файла может быть закрыт без влияния на отображение памяти."

#. type: Plain text
#: man-pages/man3/shm_open.3:171
msgid ""
"The operation of B<shm_unlink>()  is analogous to B<unlink>(2): it removes a"
" shared memory object name, and, once all processes have unmapped the "
"object, de-allocates and destroys the contents of the associated memory "
"region.  After a successful B<shm_unlink>(), attempts to B<shm_open>()  an "
"object with the same I<name> will fail (unless B<O_CREAT> was specified, in "
"which case a new, distinct object is created)."
msgstr "Действие B<shm_unlink>() аналогично B<unlink>(2): оно удаляет имя объекта общей памяти и, как только все процессы завершили работу с объектом и отменили его отображение, очищает пространство и уничтожает связанную с ним область памяти. После успешного выполнения B<shm_unlink>() попытка выполнить B<shm_open>() для объекта с тем же именем I<name> выдаст ошибку (если только не был указан B<O_CREAT>, в этом случае создаётся новый, уже другой объект)."

#. type: Plain text
#: man-pages/man3/shm_open.3:180
msgid ""
"On success, B<shm_open>()  returns a nonnegative file descriptor.  On "
"failure, B<shm_open>()  returns -1.  B<shm_unlink>()  returns 0 on success, "
"or -1 on error."
msgstr "При успешном выполнении B<shm_open>() возвращает неотрицательный дескриптор файла. При ошибках B<shm_open>() возвращает -1. При успешном выполнении B<shm_unlink>() возвращает 0 и -1 при ошибке."

#. type: Plain text
#: man-pages/man3/shm_open.3:187
msgid ""
"On failure, I<errno> is set to indicate the cause of the error.  Values "
"which may appear in I<errno> include the following:"
msgstr "При ошибках в I<errno> записываются причины ошибки. Значения I<errno> могут быть такими:"

#. type: Plain text
#: man-pages/man3/shm_open.3:192
msgid "Permission to B<shm_unlink>()  the shared memory object was denied."
msgstr "Отказ в доступе для B<shm_unlink>() для объекта общей памяти."

#. type: Plain text
#: man-pages/man3/shm_open.3:202
msgid ""
"Permission was denied to B<shm_open>()  I<name> in the specified I<mode>, or"
" B<O_TRUNC> was specified and the caller does not have write permission on "
"the object."
msgstr "Отказ в доступе для B<shm_open>() с заданным I<name> и режимом I<mode>, или был указан B<O_TRUNC>, а вызывающий не имеет прав на запись для объекта."

#. type: Plain text
#: man-pages/man3/shm_open.3:213
msgid ""
"Both B<O_CREAT> and B<O_EXCL> were specified to B<shm_open>()  and the "
"shared memory object specified by I<name> already exists."
msgstr "В B<shm_open>() указаны B<O_CREAT> и B<O_EXCL>, но объект общей памяти I<name> уже существует."

#. type: Plain text
#: man-pages/man3/shm_open.3:220
msgid "The I<name> argument to B<shm_open>()  was invalid."
msgstr "Аргумент I<name> для B<shm_open>() некорректен."

#. type: Plain text
#: man-pages/man3/shm_open.3:223
msgid "The process already has the maximum number of files open."
msgstr "Процесс уже открыл максимально допустимое количество файлов."

#. type: Plain text
#: man-pages/man3/shm_open.3:229
msgid "The length of I<name> exceeds B<PATH_MAX>."
msgstr "Длина I<name> превышает B<PATH_MAX>."

#. type: Plain text
#: man-pages/man3/shm_open.3:233
msgid ""
"The limit on the total number of files open on the system has been reached."
msgstr "Достигнут предел общего количества открытых файлов в системе."

#. type: Plain text
#: man-pages/man3/shm_open.3:242
msgid ""
"An attempt was made to B<shm_open>()  a I<name> that did not exist, and "
"B<O_CREAT> was not specified."
msgstr "Была сделана попытка выполнить B<shm_open>() для несуществующего I<name> и при этом не был указан B<O_CREAT>."

#. type: Plain text
#: man-pages/man3/shm_open.3:249
msgid ""
"An attempt was to made to B<shm_unlink>()  a I<name> that does not exist."
msgstr "Была сделана попытка выполнить B<shm_unlink>() для несуществующего I<name>."

#. type: Plain text
#: man-pages/man3/shm_open.3:251
msgid "These functions are provided in glibc 2.2 and later."
msgstr "Эти функции присутствуют в glibc 2.2 и более новых."

#. type: Plain text
#: man-pages/man3/shm_open.3:257
msgid ""
"POSIX.1-2001 says that the group ownership of a newly created shared memory "
"object is set to either the calling process's effective group ID or \"a "
"system default group ID\"."
msgstr "В POSIX.1-2001 сказано, что группа-владелец нового объекта общей памяти устанавливается или в эффективный ID вызвавшего процесса, или «ID системной группы по умолчанию»."

#. type: Plain text
#: man-pages/man3/shm_open.3:266
msgid ""
"POSIX leaves the behavior of the combination of B<O_RDONLY> and B<O_TRUNC> "
"unspecified.  On Linux, this will successfully truncate an existing shared "
"memory object\\(emthis may not be so on other UNIX systems."
msgstr "POSIX оставляет неопределённым поведение при комбинации B<O_RDONLY> и B<O_TRUNC>. В Linux это приводит к успешному обрезанию существующего объекта общей памяти, но в других системах UNIX может быть по-другому."

#. type: Plain text
#: man-pages/man3/shm_open.3:271
msgid ""
"The POSIX shared memory object implementation on Linux 2.4 makes use of a "
"dedicated filesystem, which is normally mounted under I</dev/shm>."
msgstr "Реализация объектов общей памяти POSIX в Linux 2.4 использует выделенную файловую систему, которая обычно монтируется в I</dev/shm>."

#. type: Plain text
#: man-pages/man3/shm_open.3:281
msgid ""
"B<close>(2), B<fchmod>(2), B<fchown>(2), B<fcntl>(2), B<fstat>(2), "
"B<ftruncate>(2), B<mmap>(2), B<open>(2), B<umask>(2), B<shm_overview>(7)"
msgstr "B<close>(2), B<fchmod>(2), B<fchown>(2), B<fcntl>(2), B<fstat>(2), B<ftruncate>(2), B<mmap>(2), B<open>(2), B<umask>(2), B<shm_overview>(7)"

#. type: TH
#: man-pages/man3/strtoul.3:33
#, no-wrap
msgid "STRTOUL"
msgstr "STRTOUL"

#. type: TH
#: man-pages/man3/strtoul.3:33
#, no-wrap
msgid "2014-03-18"
msgstr "2014-03-18"

#. type: Plain text
#: man-pages/man3/strtoul.3:36
msgid ""
"strtoul, strtoull, strtouq - convert a string to an unsigned long integer"
msgstr "strtoul, strtoull, strtouq - преобразование строки в целое с типом unsigned long integer"

#. type: Plain text
#: man-pages/man3/strtoul.3:39
#, no-wrap
msgid "B<#include E<lt>stdlib.hE<gt>>\n"
msgstr "B<#include E<lt>stdlib.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/strtoul.3:42
#, no-wrap
msgid ""
"B<unsigned long int strtoul(const char *>I<nptr>B<, char **>I<endptr>B<, int"
" >I<base>B<);>\n"
msgstr "B<unsigned long int strtoul(const char *>I<nptr>B<, char **>I<endptr>B<, int >I<base>B<);>\n"

#. type: Plain text
#: man-pages/man3/strtoul.3:45
#, no-wrap
msgid ""
"B<unsigned long long int strtoull(const char *>I<nptr>B<, char **>I<endptr>B<,>\n"
"B<                                int >I<base>B<);>\n"
msgstr "B<unsigned long long int strtoull(const char *>I<nptr>B<, char **>I<endptr>B<,>\nB<                                int >I<base>B<);>\n"

#. type: Plain text
#: man-pages/man3/strtoul.3:54
msgid "B<strtoull>():"
msgstr "B<strtoull>():"

#. type: Plain text
#: man-pages/man3/strtoul.3:57
msgid ""
"_XOPEN_SOURCE\\ E<gt>=\\ 600 || _BSD_SOURCE || _SVID_SOURCE || "
"_ISOC99_SOURCE || _POSIX_C_SOURCE\\ E<gt>=\\ 200112L;"
msgstr "_XOPEN_SOURCE\\ E<gt>=\\ 600 || _BSD_SOURCE || _SVID_SOURCE || _ISOC99_SOURCE || _POSIX_C_SOURCE\\ E<gt>=\\ 200112L;"

#. type: Plain text
#: man-pages/man3/strtoul.3:60
msgid "or I<cc\\ -std=c99>"
msgstr "или I<cc\\ -std=c99>"

#. type: Plain text
#: man-pages/man3/strtoul.3:75
msgid ""
"The B<strtoul>()  function converts the initial part of the string in "
"I<nptr> to an I<unsigned long int> value according to the given I<base>, "
"which must be between 2 and 36 inclusive, or be the special value 0."
msgstr "Функция B<strtoul>() конвертирует начальную часть строки I<nptr> в число с типом I<unsigned long int> согласно системе счисления I<base>, которая должна иметь значение от 2 до 36 включительно или специальное значение 0."

#. type: Plain text
#: man-pages/man3/strtoul.3:89
msgid ""
"The string may begin with an arbitrary amount of white space (as determined "
"by B<isspace>(3))  followed by a single optional \\(aq+\\(aq or \\(aq-\\(aq "
"sign.  If I<base> is zero or 16, the string may then include a \"0x\" "
"prefix, and the number will be read in base 16; otherwise, a zero I<base> is"
" taken as 10 (decimal) unless the next character is \\(aq0\\(aq, in which "
"case it is taken as 8 (octal)."
msgstr "Строка может начинаться с произвольного количества пробельных символов (определяемых при помощи B<isspace>(3)), затем может быть указан знак «+» или «-». Если I<base> равно 0 или 16, то строка может начинаться с приставки «0x», что означает использование шестнадцатеричной системы исчисления; иначе, если I<base> равно нулю, то используется десятичная система счисления (кроме, когда последующий символ также равен «0»: в этом случае используется восьмеричная система исчисления)."

#. type: Plain text
#: man-pages/man3/strtoul.3:98
msgid ""
"The remainder of the string is converted to an I<unsigned long int> value in"
" the obvious manner, stopping at the first character which is not a valid "
"digit in the given base.  (In bases above 10, the letter \\(aqA\\(aq in "
"either uppercase or lowercase represents 10, \\(aqB\\(aq represents 11, and "
"so forth, with \\(aqZ\\(aq representing 35.)"
msgstr "Остаток строки конвертируется в число с типом I<unsigned long int>. Этот процесс останавливается, если в строке встречается некорректный символ для указанной системе счисления. В системах счисления больших 10, символ «A» в верхнем или нижнем регистре означает 10, «B» означает 11 и так далее до «Z», означающего 35."

#. type: Plain text
#: man-pages/man3/strtoul.3:119
msgid ""
"If I<endptr> is not NULL, B<strtoul>()  stores the address of the first "
"invalid character in I<*endptr>.  If there were no digits at all, "
"B<strtoul>()  stores the original value of I<nptr> in I<*endptr> (and "
"returns 0).  In particular, if I<*nptr> is not \\(aq\\e0\\(aq but "
"I<**endptr> is \\(aq\\e0\\(aq on return, the entire string is valid."
msgstr "Если значение I<endptr> не NULL, то B<strtoul>() записывает адрес первого некорректного значения в I<*endptr>. Если в строке вообще нет цифр, то B<strtoul>() сохраняет изначальное значение I<nptr> в I<*endptr> (и возвращает 0). В частности, если I<*nptr> не равно \\(aq\\e0\\(aq, но I<**endptr> равно \\(aq\\e0\\(aq при возврате, то вся строка состоит из корректных символов."

#. type: Plain text
#: man-pages/man3/strtoul.3:127
msgid ""
"The B<strtoull>()  function works just like the B<strtoul>()  function but "
"returns an I<unsigned long long int> value."
msgstr "Функция B<strtoull>() работает так же, как и B<strtoul>(), но возвращает число с типом I<unsigned long long int>."

#. type: Plain text
#: man-pages/man3/strtoul.3:148
msgid ""
"The B<strtoul>()  function returns either the result of the conversion or, "
"if there was a leading minus sign, the negation of the result of the "
"conversion represented as an unsigned value, unless the original "
"(nonnegated) value would overflow; in the latter case, B<strtoul>()  returns"
" B<ULONG_MAX> and sets I<errno> to B<ERANGE>.  Precisely the same holds for "
"B<strtoull>()  (with B<ULLONG_MAX> instead of B<ULONG_MAX>)."
msgstr "Функция B<strtoul>() возвращает результат преобразования, либо, если был указан знак минуса, возвращается отрицательный результат преобразования, представленный в виде положительного числа, если изначальное (неотрицательное) значение не вызывает переполнения; в этом случае B<strtoul>() возвращает B<ULONG_MAX>, а переменной I<errno> присваивается значение B<ERANGE>. То же самое относится к B<strtoull>(), только вместо B<ULONG_MAX> возвращается B<ULLONG_MAX>."

#. type: Plain text
#: man-pages/man3/strtoul.3:155
msgid "(not in C99)  The given I<base> contains an unsupported value."
msgstr "(нет в C99) Аргумент I<base> содержит неподдерживаемое значение."

#. type: Plain text
#: man-pages/man3/strtoul.3:158
msgid "The resulting value was out of range."
msgstr "Полученное значение вне диапазона."

#. type: Plain text
#: man-pages/man3/strtoul.3:165
msgid ""
"The implementation may also set I<errno> to B<EINVAL> in case no conversion "
"was performed (no digits seen, and 0 returned)."
msgstr "Реализация может также устанавливать I<errno> в B<EINVAL> в случае, когда преобразование не было выполнено (не было встречено цифр и возвращён 0)."

#. type: Plain text
#: man-pages/man3/strtoul.3:177
msgid ""
"The B<strtoul>(), B<strtoull>(), and B<strtouq>()  functions are thread-safe"
" with exceptions.  These functions can be safely used in multithreaded "
"applications, as long as B<setlocale>(3)  is not called to change the locale"
" during their execution."
msgstr "Функции B<strtoul>(), B<strtoull>() и B<strtouq>() можно использовать в нескольких нитях одновременно с несколькими исключениями. Эти функции можно использовать в многонитевых приложениях, если во время их работы не вызывать B<setlocale>(3)."

#. type: Plain text
#: man-pages/man3/strtoul.3:182
msgid ""
"B<strtoul>()  conforms to SVr4, C89, C99, and POSIX-2001, and B<strtoull>()"
"  to C99 and POSIX.1-2001."
msgstr "Функция B<strtoul>() соответствует SVr4, C89, C99 и POSIX-2001, а B<strtoull>() — C99 и POSIX.1-2001."

#. type: Plain text
#: man-pages/man3/strtoul.3:196
msgid ""
"Since B<strtoul>()  can legitimately return 0 or B<ULONG_MAX> (B<ULLONG_MAX>"
" for B<strtoull>())  on both success and failure, the calling program should"
" set I<errno> to 0 before the call, and then determine if an error occurred "
"by checking whether I<errno> has a nonzero value after the call."
msgstr "Так как B<strtoul>() может обоснованно вернуть 0 или B<ULONG_MAX> (B<ULLONG_MAX> для B<strtoull>()) при успешном выполнении и ошибке, вызывающая программа должна присвоить I<errno> значение 0 до вызова, а после вызова определить возникновение ошибки по ненулевому значению I<errno>."

#. type: Plain text
#: man-pages/man3/strtoul.3:200
msgid ""
"In locales other than the \"C\" locale, other strings may be accepted.  (For"
" example, the thousands separator of the current locale may be supported.)"
msgstr "При помощи локалей могут приниматься строки, отличные от допустимых в локали «C» (например, может поддерживаться разделитель тысяч из текущей локали)."

#. type: Plain text
#: man-pages/man3/strtoul.3:202
msgid "BSD also has"
msgstr "В BSD также есть функция "

#. type: Plain text
#: man-pages/man3/strtoul.3:206
#, no-wrap
msgid ""
"B<u_quad_t strtouq(const char *>I<nptr>B<, char **>I<endptr>B<, int "
">I<base>B<);>\n"
msgstr "B<u_quad_t strtouq(const char *>I<nptr>B<, char **>I<endptr>B<, int >I<base>B<);>\n"

#. type: Plain text
#: man-pages/man3/strtoul.3:215
msgid ""
"with completely analogous definition.  Depending on the wordsize of the "
"current architecture, this may be equivalent to B<strtoull>()  or to "
"B<strtoul>()."
msgstr "с полностью аналогичным определением. В зависимости от длины слова в текущей архитектуре, она может быть аналогом B<strtoull>() или B<strtoul>()."

#. type: Plain text
#: man-pages/man3/strtoul.3:220
msgid ""
"Negative values are considered valid input and are silently converted to the"
" equivalent I<unsigned long int> value."
msgstr "Отрицательные значения допустимы во входных данных и без ошибки преобразуются в эквивалентное значение с типом I<unsigned long int>."

#. type: Plain text
#: man-pages/man3/strtoul.3:225
msgid ""
"See the example on the B<strtol>(3)  manual page; the use of the functions "
"described in this manual page is similar."
msgstr "Пример можно найти в справочной странице B<strtol>(3); в ней показано похожее использование функций."

#. type: Plain text
#: man-pages/man3/strtoul.3:230
msgid "B<atof>(3), B<atoi>(3), B<atol>(3), B<strtod>(3), B<strtol>(3)"
msgstr "B<atof>(3), B<atoi>(3), B<atol>(3), B<strtod>(3), B<strtol>(3)"

#. type: TH
#: man-pages/man3/setbuf.3:48
#, no-wrap
msgid "SETBUF"
msgstr "SETBUF"

#. type: TH
#: man-pages/man3/setbuf.3:48
#, no-wrap
msgid "2014-02-18"
msgstr "2014-02-18"

#. type: Plain text
#: man-pages/man3/setbuf.3:51
msgid "setbuf, setbuffer, setlinebuf, setvbuf - stream buffering operations"
msgstr "setbuf, setbuffer, setlinebuf, setvbuf - операции с буферизацией потока"

#. type: Plain text
#: man-pages/man3/setbuf.3:54
#, no-wrap
msgid "B<#include E<lt>stdio.hE<gt>>\n"
msgstr "B<#include E<lt>stdio.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/setbuf.3:56
#, no-wrap
msgid "B<void setbuf(FILE *>I<stream>B<, char *>I<buf>B<);>\n"
msgstr "B<void setbuf(FILE *>I<stream>B<, char *>I<buf>B<);>\n"

#. type: Plain text
#: man-pages/man3/setbuf.3:58
#, no-wrap
msgid ""
"B<void setbuffer(FILE *>I<stream>B<, char *>I<buf>B<, size_t >I<size>B<);>\n"
msgstr "B<void setbuffer(FILE *>I<stream>B<, char *>I<buf>B<, size_t >I<size>B<);>\n"

#. type: Plain text
#: man-pages/man3/setbuf.3:60
#, no-wrap
msgid "B<void setlinebuf(FILE *>I<stream>B<);>\n"
msgstr "B<void setlinebuf(FILE *>I<stream>B<);>\n"

#. type: Plain text
#: man-pages/man3/setbuf.3:63
#, no-wrap
msgid ""
"B<int setvbuf(FILE *>I<stream>B<, char *>I<buf>B<, int >I<mode>B<, size_t "
">I<size>B<);>\n"
msgstr "B<int setvbuf(FILE *>I<stream>B<, char *>I<buf>B<, int >I<mode>B<, size_t >I<size>B<);>\n"

#. type: Plain text
#: man-pages/man3/setbuf.3:73
msgid "B<setbuffer>(), B<setlinebuf>(): _BSD_SOURCE"
msgstr "B<setbuffer>(), B<setlinebuf>(): _BSD_SOURCE"

#. type: Plain text
#: man-pages/man3/setbuf.3:96
msgid ""
"The three types of buffering available are unbuffered, block buffered, and "
"line buffered.  When an output stream is unbuffered, information appears on "
"the destination file or terminal as soon as written; when it is block "
"buffered many characters are saved up and written as a block; when it is "
"line buffered characters are saved up until a newline is output or input is "
"read from any stream attached to a terminal device (typically I<stdin>).  "
"The function B<fflush>(3)  may be used to force the block out early.  (See "
"B<fclose>(3).)  Normally all files are block buffered.  When the first I/O "
"operation occurs on a file, B<malloc>(3)  is called, and a buffer is "
"obtained.  If a stream refers to a terminal (as I<stdout> normally does), it"
" is line buffered.  The standard error stream I<stderr> is always unbuffered"
" by default."
msgstr "Существует три типа буферизации: отсутствие буферизации, блочная буферизация и строковая буферизация. Когда выходной поток не буферизируется, то информация незамедлительно оказывается на терминале (или в файле назначения); при блочной буферизации сначала сохраняется большое количество символов, а затем они записываются за один раз; при строковой буферизации все символы сохраняются в буфере до появления символа перевода строки при выводе или при вводе из любого потока, подключённого к устройству терминала (обычно, I<stdin>). Функцию B<fflush>(3) можно использовать для досрочного окончания блочной буферизации (см. B<fclose>(3)). Обычно, для файлов включена блочная буферизация. При первой операции ввода-вывода над файлом производится вызов B<malloc>(3) для организации буфера. Если поток ссылается на терминал (обычно для I<stdout>), то он буферизируется построчно. Стандартный поток ошибок I<stderr> по умолчанию никогда не буферизируется."

#. type: Plain text
#: man-pages/man3/setbuf.3:103
msgid ""
"The B<setvbuf>()  function may be used on any open stream to change its "
"buffer.  The I<mode> argument must be one of the following three macros:"
msgstr "Функция B<setvbuf>() может быть использована для изменения типа буферизации любого открытого потока. Параметр I<mode> должен быть одним из трёх следующих макросов:"

#. type: TP
#: man-pages/man3/setbuf.3:104
#, no-wrap
msgid "B<_IONBF>"
msgstr "B<_IONBF>"

#. type: Plain text
#: man-pages/man3/setbuf.3:107
msgid "unbuffered"
msgstr "отключить буферизацию"

#. type: TP
#: man-pages/man3/setbuf.3:107
#, no-wrap
msgid "B<_IOLBF>"
msgstr "B<_IOLBF>"

#. type: Plain text
#: man-pages/man3/setbuf.3:110
msgid "line buffered"
msgstr "строковая буферизация"

#. type: TP
#: man-pages/man3/setbuf.3:110
#, no-wrap
msgid "B<_IOFBF>"
msgstr "B<_IOFBF>"

#. type: Plain text
#: man-pages/man3/setbuf.3:113
msgid "fully buffered"
msgstr "полная буферизация"

#. type: Plain text
#: man-pages/man3/setbuf.3:129
msgid ""
"Except for unbuffered files, the I<buf> argument should point to a buffer at"
" least I<size> bytes long; this buffer will be used instead of the current "
"buffer.  If the argument I<buf> is NULL, only the mode is affected; a new "
"buffer will be allocated on the next read or write operation.  The "
"B<setvbuf>()  function may be used only after opening a stream and before "
"any other operations have been performed on it."
msgstr "За исключением небуферизованных файлов аргумент I<buf> должен указывать на буфер размером, как минимум, I<size> байт; этот буфер будет использоваться вместо текущего. Если аргумент I<buf> равен NULL, то это отразится только на типе буферизации; при следующей операции чтения или записи будет создан новый буфер. Функция B<setvbuf>() может быть использована только после открытия потока и до выполнения над ним любых операций."

#. type: Plain text
#: man-pages/man3/setbuf.3:135
msgid ""
"The other three calls are, in effect, simply aliases for calls to "
"B<setvbuf>().  The B<setbuf>()  function is exactly equivalent to the call"
msgstr "Остальные три вызова, фактически, являются псевдонимами вызова B<setvbuf>(). Функция B<setbuf>() в точности соответствует вызову"

#. type: Plain text
#: man-pages/man3/setbuf.3:138
msgid "setvbuf(stream, buf, buf ? _IOFBF : _IONBF, BUFSIZ);"
msgstr "setvbuf(stream, buf, buf ? _IOFBF : _IONBF, BUFSIZ);"

#. type: Plain text
#: man-pages/man3/setbuf.3:148
msgid ""
"The B<setbuffer>()  function is the same, except that the size of the buffer"
" is up to the caller, rather than being determined by the default B<BUFSIZ>."
"  The B<setlinebuf>()  function is exactly equivalent to the call:"
msgstr "Функция B<setbuffer>() также аналогична ей, но размер буфера в данном случае определяется вызывающим, а не размером по умолчанию B<BUFSIZ>. Функция B<setlinebuf>() полностью идентична вызову"

#. type: Plain text
#: man-pages/man3/setbuf.3:151
msgid "setvbuf(stream, NULL, _IOLBF, 0);"
msgstr "setvbuf(stream, NULL, _IOLBF, 0);"

#. type: Plain text
#: man-pages/man3/setbuf.3:162
msgid ""
"The function B<setvbuf>()  returns 0 on success.  It returns nonzero on "
"failure (I<mode> is invalid or the request cannot be honored).  It may set "
"I<errno> on failure."
msgstr "Функция B<setvbuf>() возвращает 0 при нормальном завершении работы. При ошибках она возвращает ненулевое значение (некорректное значение I<mode> или запрос невозможно выполнить). При ошибках может быть соответственно изменено значение I<errno>."

#. type: Plain text
#: man-pages/man3/setbuf.3:164
msgid "The other functions do not return a value."
msgstr "Другие функции не возвращают никаких значений."

#. type: Plain text
#: man-pages/man3/setbuf.3:173
msgid ""
"The B<setbuf>(), B<setbuffer>(), B<setlinebuf>(), and B<setvbuf>()  "
"functions are thread-safe."
msgstr "Функции B<setbuf>(), B<setbuffer>(), B<setlinebuf>() и B<setvbuf>() можно использовать в нескольких нитях одновременно."

#. type: Plain text
#: man-pages/man3/setbuf.3:179
msgid "The B<setbuf>()  and B<setvbuf>()  functions conform to C89 and C99."
msgstr "Функции B<setbuf>() и B<setvbuf>() соответствуют стандарту C89 и C99."

#. type: Plain text
#: man-pages/man3/setbuf.3:189
msgid ""
"The B<setbuffer>()  and B<setlinebuf>()  functions are not portable to "
"versions of BSD before 4.2BSD, and are available under Linux since libc "
"4.5.21.  On 4.2BSD and 4.3BSD systems, B<setbuf>()  always uses a suboptimal"
" buffer size and should be avoided."
msgstr "Функции B<setbuffer>() и B<setlinebuf>() не совпадают с версиями BSD до 4.2BSD, и доступны в Linux только в libc с версии 4.5.21. В системах 4.2BSD и 4.3BSD B<setbuf>() по умолчанию всегда использует не оптимальный размер буфера, и поэтому этого вызова функции следует избегать."

#. type: Plain text
#: man-pages/man3/setbuf.3:196
msgid ""
"You must make sure that the space that I<buf> points to still exists by the "
"time I<stream> is closed, which also happens at program termination.  For "
"example, the following is invalid:"
msgstr "Вы должны удостовериться, что пространство, на которое указывает I<buf>, всё ещё существует, в то время как I<stream> закрыт, что обычно случается при закрытии программы. Например, следующее будет неправильным:"

#. type: Plain text
#: man-pages/man3/setbuf.3:199
#, no-wrap
msgid "#include E<lt>stdio.hE<gt>\n"
msgstr "#include E<lt>stdio.hE<gt>\n"

#. type: Plain text
#: man-pages/man3/setbuf.3:208
#, no-wrap
msgid ""
"int\n"
"main(void)\n"
"{\n"
"    char buf[BUFSIZ];\n"
"    setbuf(stdin, buf);\n"
"    printf(\"Hello, world!\\en\");\n"
"    return 0;\n"
"}\n"
msgstr "int\nmain(void)\n{\n    char buf[BUFSIZ];\n    setbuf(stdin, buf);\n    printf(\"Hello, world!\\en\");\n    return 0;\n}\n"

#. type: Plain text
#: man-pages/man3/setbuf.3:216
msgid ""
"B<fclose>(3), B<fflush>(3), B<fopen>(3), B<fread>(3), B<malloc>(3), "
"B<printf>(3), B<puts>(3)"
msgstr "B<fclose>(3), B<fflush>(3), B<fopen>(3), B<fread>(3), B<malloc>(3), B<printf>(3), B<puts>(3)"

#. type: TH
#: man-pages/man3/strerror.3:39
#, no-wrap
msgid "STRERROR"
msgstr "STRERROR"

#. type: Plain text
#: man-pages/man3/strerror.3:42
msgid ""
"strerror, strerror_r, strerror_l - return string describing error number"
msgstr ""

#. type: Plain text
#: man-pages/man3/strerror.3:47
#, no-wrap
msgid "B<char *strerror(int >I<errnum>B<);>\n"
msgstr "B<char *strerror(int >I<errnum>B<);>\n"

#. type: Plain text
#: man-pages/man3/strerror.3:50
#, no-wrap
msgid ""
"B<int strerror_r(int >I<errnum>B<, char *>I<buf>B<, size_t >I<buflen>B<);>\n"
"            /* XSI-compliant */\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/strerror.3:53
#, no-wrap
msgid ""
"B<char *strerror_r(int >I<errnum>B<, char *>I<buf>B<, size_t >I<buflen>B<);>\n"
"            /* GNU-specific */\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/strerror.3:55
#, no-wrap
msgid "B<char *strerror_l(int >I<errnum>B<, locale_t >I<locale>B<);>\n"
msgstr "B<char *strerror_l(int >I<errnum>B<, locale_t >I<locale>B<);>\n"

#. type: Plain text
#: man-pages/man3/strerror.3:64
msgid "B<strerror_r>():"
msgstr "B<strerror_r>():"

#. type: Plain text
#: man-pages/man3/strerror.3:66
msgid "The XSI-compliant version is provided if:"
msgstr ""

#. type: Plain text
#: man-pages/man3/strerror.3:68
msgid ""
"(_POSIX_C_SOURCE\\ E<gt>=\\ 200112L || _XOPEN_SOURCE\\ E<gt>=\\ 600) && !\\ "
"_GNU_SOURCE"
msgstr "(_POSIX_C_SOURCE\\ E<gt>=\\ 200112L || _XOPEN_SOURCE\\ E<gt>=\\ 600) && !\\ _GNU_SOURCE"

#. type: Plain text
#: man-pages/man3/strerror.3:70
msgid "Otherwise, the GNU-specific version is provided."
msgstr ""

#. type: Plain text
#: man-pages/man3/strerror.3:95
msgid ""
"The B<strerror>()  function returns a pointer to a string that describes the"
" error code passed in the argument I<errnum>, possibly using the "
"B<LC_MESSAGES> part of the current locale to select the appropriate "
"language.  (For example, if I<errnum> is B<EINVAL>, the returned description"
" will be \"Invalid argument\".)  This string must not be modified by the "
"application, but may be modified by a subsequent call to B<strerror>()  or "
"B<strerror_l>().  No other library function, including B<perror>(3), will "
"modify this string."
msgstr ""

#. type: SS
#: man-pages/man3/strerror.3:95
#, no-wrap
msgid "strerror_r()"
msgstr "strerror_r()"

#. type: Plain text
#: man-pages/man3/strerror.3:116
msgid ""
"The B<strerror_r>()  function is similar to B<strerror>(), but is thread "
"safe.  This function is available in two versions: an XSI-compliant version "
"specified in POSIX.1-2001 (available since glibc 2.3.4, but not POSIX-"
"compliant until glibc 2.13), and a GNU-specific version (available since "
"glibc 2.0).  The XSI-compliant version is provided with the feature test "
"macros settings shown in the SYNOPSIS; otherwise the GNU-specific version is"
" provided.  If no feature test macros are explicitly defined, then (since "
"glibc 2.4)  B<_POSIX_SOURCE> is defined by default with the value 200112L, "
"so that the XSI-compliant version of B<strerror_r>()  is provided by "
"default."
msgstr ""

#. type: Plain text
#: man-pages/man3/strerror.3:124
msgid ""
"The XSI-compliant B<strerror_r>()  is preferred for portable applications.  "
"It returns the error string in the user-supplied buffer I<buf> of length "
"I<buflen>."
msgstr ""

#. type: Plain text
#: man-pages/man3/strerror.3:145
msgid ""
"The GNU-specific B<strerror_r>()  returns a pointer to a string containing "
"the error message.  This may be either a pointer to a string that the "
"function stores in I<buf>, or a pointer to some (immutable) static string "
"(in which case I<buf> is unused).  If the function stores a string in "
"I<buf>, then at most I<buflen> bytes are stored (the string may be truncated"
" if I<buflen> is too small and I<errnum> is unknown).  The string always "
"includes a terminating null byte (\\(aq\\e0\\(aq)."
msgstr ""

#. type: SS
#: man-pages/man3/strerror.3:145
#, no-wrap
msgid "strerror_l()"
msgstr "strerror_l()"

#. type: Plain text
#: man-pages/man3/strerror.3:160
msgid ""
"B<strerror_l>()  is like B<strerror>(), but maps I<errnum> to a locale-"
"dependent error message in the locale specified by I<locale>.  The behavior "
"of B<strerror_l>()  is undefined if I<locale> is the special locale object "
"B<LC_GLOBAL_LOCALE> or is not a valid locale object handle."
msgstr ""

#. type: Plain text
#: man-pages/man3/strerror.3:169
msgid ""
"The B<strerror>(), B<strerror_l>(), and the GNU-specific B<strerror_r>()  "
"functions return the appropriate error description string, or an \"Unknown "
"error nnn\" message if the error number is unknown."
msgstr ""

#. type: Plain text
#: man-pages/man3/strerror.3:178
msgid ""
"The XSI-compliant B<strerror_r>()  function returns 0 on success.  On error,"
" a (positive) error number is returned (since glibc 2.13), or -1 is returned"
" and I<errno> is set to indicate the error (glibc versions before 2.13)."
msgstr ""

#. type: Plain text
#: man-pages/man3/strerror.3:193
msgid ""
"POSIX.1-2001 and POSIX.1-2008 require that a successful call to "
"B<strerror>()  or B<strerror_l>()  shall leave I<errno> unchanged, and note "
"that, since no function return value is reserved to indicate an error, an "
"application that wishes to check for errors should initialize I<errno> to "
"zero before the call, and then check I<errno> after the call."
msgstr ""

#. type: Plain text
#: man-pages/man3/strerror.3:199
msgid "The value of I<errnum> is not a valid error number."
msgstr ""

#. type: Plain text
#: man-pages/man3/strerror.3:202
msgid ""
"Insufficient storage was supplied to contain the error description string."
msgstr ""

#. type: Plain text
#: man-pages/man3/strerror.3:207
msgid "The B<strerror>()  function is not thread-safe."
msgstr "Функцию B<strerror>() нельзя использовать в нескольких нитях одновременно."

#.  FIXME Need a thread-safety statement about strerror_l()
#. type: Plain text
#: man-pages/man3/strerror.3:212
msgid "The B<strerror_r>()  function is thread-safe."
msgstr "Функцию B<strerror_r>() можно использовать в нескольких нитях одновременно."

#. type: Plain text
#: man-pages/man3/strerror.3:216
msgid "The B<strerror_l>()  function first appeared in glibc 2.6."
msgstr "Функция B<strerror_l>() впервые появилась в glibc 2.6."

#. type: Plain text
#: man-pages/man3/strerror.3:221
msgid ""
"B<strerror>()  is specified by POSIX.1-2001, POSIX.1-2008, C89, and C99.  "
"B<strerror_r>()  is specified by POSIX.1-2001 and POSIX.1-2008."
msgstr ""

#. type: Plain text
#: man-pages/man3/strerror.3:224
msgid "B<strerror_l>()  is specified in POSIX.1-2008."
msgstr "Функция B<strerror_l>() описана в POSIX.1-2008."

#. type: Plain text
#: man-pages/man3/strerror.3:228
msgid "The GNU-specific B<strerror_r>()  function is a nonstandard extension."
msgstr "Функция GNU B<strerror_r>() является нестандартизованным расширением."

#.  e.g., Solaris 8, HP-UX 11
#.  e.g., FreeBSD 5.4, Tru64 5.1B
#. type: Plain text
#: man-pages/man3/strerror.3:248
msgid ""
"POSIX.1-2001 permits B<strerror>()  to set I<errno> if the call encounters "
"an error, but does not specify what value should be returned as the function"
" result in the event of an error.  On some systems, B<strerror>()  returns "
"NULL if the error number is unknown.  On other systems, B<strerror>()  "
"returns a string something like \"Error nnn occurred\" and sets I<errno> to "
"B<EINVAL> if the error number is unknown.  C99 and POSIX.1-2008 require the "
"return value to be non-NULL."
msgstr ""

#. type: Plain text
#: man-pages/man3/strerror.3:254
msgid ""
"B<err>(3), B<errno>(3), B<error>(3), B<perror>(3), B<strsignal>(3), "
"B<locale>(7)"
msgstr "B<err>(3), B<errno>(3), B<error>(3), B<perror>(3), B<strsignal>(3), B<locale>(7)"

#. type: TH
#: man-pages/man3/stdio_ext.3:25
#, no-wrap
msgid "STDIO_EXT"
msgstr ""

#. type: TH
#: man-pages/man3/stdio_ext.3:25
#, no-wrap
msgid "2013-06-21"
msgstr "2013-06-21"

#. type: Plain text
#: man-pages/man3/stdio_ext.3:30
msgid ""
"__fbufsize, __flbf, __fpending, __fpurge, __freadable, __freading, "
"__fsetlocking, __fwritable, __fwriting, _flushlbf - interfaces to stdio FILE"
" structure"
msgstr ""

#. type: Plain text
#: man-pages/man3/stdio_ext.3:32
msgid "B<#include E<lt>stdio.hE<gt>>"
msgstr "B<#include E<lt>stdio.hE<gt>>"

#. type: Plain text
#: man-pages/man3/stdio_ext.3:34
msgid "B<#include E<lt>stdio_ext.hE<gt>>"
msgstr ""

#. type: Plain text
#: man-pages/man3/stdio_ext.3:36
msgid "B<size_t __fbufsize(FILE *>I<stream>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man3/stdio_ext.3:38
msgid "B<size_t __fpending(FILE *>I<stream>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man3/stdio_ext.3:40
msgid "B<int __flbf(FILE *>I<stream>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man3/stdio_ext.3:42
msgid "B<int __freadable(FILE *>I<stream>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man3/stdio_ext.3:44
msgid "B<int __fwritable(FILE *>I<stream>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man3/stdio_ext.3:46
msgid "B<int __freading(FILE *>I<stream>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man3/stdio_ext.3:48
msgid "B<int __fwriting(FILE *>I<stream>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man3/stdio_ext.3:50
msgid "B<int __fsetlocking(FILE *>I<stream>B<, int >I<type>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man3/stdio_ext.3:52
msgid "B<void _flushlbf(void);>"
msgstr ""

#. type: Plain text
#: man-pages/man3/stdio_ext.3:54
msgid "B<void __fpurge(FILE *>I<stream>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man3/stdio_ext.3:59
msgid ""
"Solaris introduced routines to allow portable access to the internals of the"
" I<FILE> structure, and glibc also implemented these."
msgstr ""

#. type: Plain text
#: man-pages/man3/stdio_ext.3:64
msgid ""
"The B<__fbufsize>()  function returns the size of the buffer currently used "
"by the given stream."
msgstr ""

#. type: Plain text
#: man-pages/man3/stdio_ext.3:71
msgid ""
"The B<__fpending>()  function returns the number of bytes in the output "
"buffer.  For wide-oriented streams the unit is wide characters.  This "
"function is undefined on buffers in reading mode, or opened read-only."
msgstr ""

#. type: Plain text
#: man-pages/man3/stdio_ext.3:76
msgid ""
"The B<__flbf>()  function returns a nonzero value if the stream is line-"
"buffered, and zero otherwise."
msgstr ""

#. type: Plain text
#: man-pages/man3/stdio_ext.3:81
msgid ""
"The B<__freadable>()  function returns a nonzero value if the stream allows "
"reading, and zero otherwise."
msgstr ""

#. type: Plain text
#: man-pages/man3/stdio_ext.3:86
msgid ""
"The B<__fwritable>()  function returns a nonzero value if the stream allows "
"writing, and zero otherwise."
msgstr ""

#. type: Plain text
#: man-pages/man3/stdio_ext.3:92
msgid ""
"The B<__freading>()  function returns a nonzero value if the stream is read-"
"only, or if the last operation on the stream was a read operation, and zero "
"otherwise."
msgstr ""

#. type: Plain text
#: man-pages/man3/stdio_ext.3:98
msgid ""
"The B<__fwriting>()  function returns a nonzero value if the stream is "
"write-only (or append-only), or if the last operation on the stream was a "
"write operation, and zero otherwise."
msgstr ""

#. type: Plain text
#: man-pages/man3/stdio_ext.3:106
msgid ""
"The B<__fsetlocking>()  function can be used to select the desired type of "
"locking on the stream.  It returns the current type.  The I<type> argument "
"can take the following three values:"
msgstr ""

#. type: TP
#: man-pages/man3/stdio_ext.3:106
#, no-wrap
msgid "B<FSETLOCKING_INTERNAL>"
msgstr ""

#. type: Plain text
#: man-pages/man3/stdio_ext.3:111
msgid ""
"Perform implicit locking around every operation on the given stream (except "
"for the *_unlocked ones).  This is the default."
msgstr ""

#. type: TP
#: man-pages/man3/stdio_ext.3:111
#, no-wrap
msgid "B<FSETLOCKING_BYCALLER>"
msgstr ""

#. type: Plain text
#: man-pages/man3/stdio_ext.3:118
msgid ""
"The caller will take care of the locking (possibly using B<flockfile>(3)  in"
" case there is more than one thread), and the stdio routines will not do "
"locking until the state is reset to B<FSETLOCKING_INTERNAL>."
msgstr ""

#. type: TP
#: man-pages/man3/stdio_ext.3:118
#, no-wrap
msgid "B<FSETLOCKING_QUERY>"
msgstr ""

#. type: Plain text
#: man-pages/man3/stdio_ext.3:122
msgid "Don't change the type of locking.  (Only return it.)"
msgstr ""

#. type: Plain text
#: man-pages/man3/stdio_ext.3:128
msgid ""
"The B<_flushlbf>()  function flushes all line-buffered streams.  (Presumably"
" so that output to a terminal is forced out, say before reading keyboard "
"input.)"
msgstr ""

#. type: Plain text
#: man-pages/man3/stdio_ext.3:132
msgid ""
"The B<__fpurge>()  function discards the contents of the stream's buffer."
msgstr ""

#. type: Plain text
#: man-pages/man3/stdio_ext.3:141
msgid ""
"The B<__fbufsize>(), B<__fpending>(), B<__fpurge>()  and B<__fsetlocking>()"
"  functions do not lock the stream, so they are not thread-safe."
msgstr ""

#. type: Plain text
#: man-pages/man3/stdio_ext.3:151
msgid ""
"The B<__flbf>(), B<__freadable>(), B<__freading>(), B<__fwritable>(), "
"B<__fwriting>()  and B<_flushlbf>()  functions are thread-safe."
msgstr ""

#. type: Plain text
#: man-pages/man3/stdio_ext.3:153
msgid "B<flockfile>(3), B<fpurge>(3)"
msgstr "B<flockfile>(3), B<fpurge>(3)"

#. type: TH
#: man-pages/man3/sched_getcpu.3:26
#, no-wrap
msgid "SCHED_GETCPU"
msgstr "SCHED_GETCPU"

#. type: Plain text
#: man-pages/man3/sched_getcpu.3:29
msgid "sched_getcpu - determine CPU on which the calling thread is running"
msgstr "sched_getcpu - определяет ЦП, на котором выполняется вызывающая нить"

#. type: Plain text
#: man-pages/man3/sched_getcpu.3:34
#, no-wrap
msgid "B<int sched_getcpu(void);>\n"
msgstr "B<int sched_getcpu(void);>\n"

#. type: Plain text
#: man-pages/man3/sched_getcpu.3:42
msgid "B<sched_getcpu>():"
msgstr ""

#. type: TP
#: man-pages/man3/sched_getcpu.3:45
#, no-wrap
msgid "Since glibc 2.14:"
msgstr ""

#. type: TP
#: man-pages/man3/sched_getcpu.3:48
#, no-wrap
msgid "Before glibc 2.14:"
msgstr ""

#. type: Plain text
#: man-pages/man3/sched_getcpu.3:52
#, no-wrap
msgid ""
"_BSD_SOURCE || _SVID_SOURCE\n"
"    /* _GNU_SOURCE also suffices */\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/sched_getcpu.3:58
msgid ""
"B<sched_getcpu>()  returns the number of the CPU on which the calling thread"
" is currently executing."
msgstr "B<sched_getcpu>() возвращает номер центрального процессора, на котором выполняется вызывающая нить."

#. type: Plain text
#: man-pages/man3/sched_getcpu.3:65
msgid ""
"On success, B<sched_getcpu>()  returns a nonnegative CPU number.  On error, "
"-1 is returned and I<errno> is set to indicate the error."
msgstr "При успешном выполнении B<sched_getcpu>() возвращает неотрицательный номер ЦП. При ошибке возвращается -1 и I<errno> устанавливается в соответствующее значение."

#. type: Plain text
#: man-pages/man3/sched_getcpu.3:70
msgid "This kernel does not implement B<getcpu>(2)."
msgstr "В данном ядре B<getcpu>(2) не реализован."

#. type: Plain text
#: man-pages/man3/sched_getcpu.3:72
msgid "This function is available since glibc 2.6."
msgstr "Эта функция доступна в glibc начиная с версии 2.6."

#. type: Plain text
#: man-pages/man3/sched_getcpu.3:77
msgid "The B<sched_getcpu>()  function is thread-safe."
msgstr ""

#. type: Plain text
#: man-pages/man3/sched_getcpu.3:80
msgid "B<sched_getcpu>()  is glibc-specific."
msgstr "B<sched_getcpu>() есть только в glibc."

#. type: Plain text
#: man-pages/man3/sched_getcpu.3:82
msgid "The call"
msgstr "Вызов"

#. type: Plain text
#: man-pages/man3/sched_getcpu.3:86
#, no-wrap
msgid "cpu = sched_getcpu();\n"
msgstr "cpu = sched_getcpu();\n"

#. type: Plain text
#: man-pages/man3/sched_getcpu.3:92
msgid "is equivalent to the following B<getcpu>(2)  call:"
msgstr "эквивалентен следующему вызову B<getcpu>(2):"

#. type: Plain text
#: man-pages/man3/sched_getcpu.3:98
#, no-wrap
msgid ""
"int c, s;\n"
"s = getcpu(&c, NULL, NULL);\n"
"cpu = (s == -1) ? s : c;\n"
msgstr "int c, s;\ns = getcpu(&c, NULL, NULL);\ncpu = (s == -1) ? s : c;\n"

#. type: Plain text
#: man-pages/man3/sched_getcpu.3:102
msgid "B<getcpu>(2), B<sched>(7)"
msgstr ""

#. type: TH
#: man-pages/man3/swab.3:31
#, no-wrap
msgid "SWAB"
msgstr "SWAB"

#. type: Plain text
#: man-pages/man3/swab.3:34
msgid "swab - swap adjacent bytes"
msgstr "swab - меняет местами соседние байты"

#. type: Plain text
#: man-pages/man3/swab.3:38
#, no-wrap
msgid ""
"B<#define _XOPEN_SOURCE>       /* See feature_test_macros(7) */\n"
"B<#include E<lt>unistd.hE<gt>>\n"
msgstr "B<#define _XOPEN_SOURCE>       /* См. feature_test_macros(7) */\nB<#include E<lt>unistd.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/swab.3:40
#, no-wrap
msgid "B<void swab(const void *>I<from>B<, void *>I<to>B<, ssize_t >I<n>B<);>\n"
msgstr "B<void swab(const void *>I<from>B<, void *>I<to>B<, ssize_t >I<n>B<);>\n"

#. type: Plain text
#: man-pages/man3/swab.3:55
msgid ""
"The B<swab>()  function copies I<n> bytes from the array pointed to by "
"I<from> to the array pointed to by I<to>, exchanging adjacent even and odd "
"bytes.  This function is used to exchange data between machines that have "
"different low/high byte ordering."
msgstr ""

#. type: Plain text
#: man-pages/man3/swab.3:68
msgid ""
"This function does nothing when I<n> is negative.  When I<n> is positive and"
" odd, it handles I<n-1> bytes as above, and does something unspecified with "
"the last byte.  (In other words, I<n> should be even.)"
msgstr ""

#. type: Plain text
#: man-pages/man3/swab.3:72
msgid "The B<swab>()  function returns no value."
msgstr "Функция B<swab>() не возвращает никаких значений."

#. type: Plain text
#: man-pages/man3/swab.3:77
msgid "The B<swab>()  function is thread-safe."
msgstr ""

#. type: Plain text
#: man-pages/man3/swab.3:79
msgid "SVr4, 4.3BSD, POSIX.1-2001."
msgstr "SVr4, 4.3BSD, POSIX.1-2001."

#. type: Plain text
#: man-pages/man3/swab.3:80
msgid "B<bstring>(3)"
msgstr "B<bstring>(3)"

#. type: TH
#: man-pages/man3/significand.3:9
#, no-wrap
msgid "SIGNIFICAND"
msgstr "SIGNIFICAND"

#. type: TH
#: man-pages/man3/significand.3:9
#, no-wrap
msgid "2009-02-04"
msgstr "2009-02-04"

#. type: Plain text
#: man-pages/man3/significand.3:13
msgid ""
"significand, significandf, significandl - get mantissa of floating-point "
"number"
msgstr ""

#. type: Plain text
#: man-pages/man3/significand.3:15
msgid "B<#include E<lt>math.hE<gt>>"
msgstr "B<#include E<lt>math.hE<gt>>"

#. type: Plain text
#: man-pages/man3/significand.3:17
msgid "B<double significand(double >I<x>B<);>"
msgstr "B<double significand(double >I<x>B<);>"

#. type: Plain text
#: man-pages/man3/significand.3:19
msgid "B<float significandf(float >I<x>B<);>"
msgstr "B<float significandf(float >I<x>B<);>"

#. type: Plain text
#: man-pages/man3/significand.3:21
msgid "B<long double significandl(long double >I<x>B<);>"
msgstr "B<long double significandl(long double >I<x>B<);>"

#. type: Plain text
#: man-pages/man3/significand.3:23
msgid "Link with I<-lm>."
msgstr "Компонуется при указании параметра I<-lm>."

#. type: Plain text
#: man-pages/man3/significand.3:33
msgid "B<significand>(), B<significandf>(), B<significandl>():"
msgstr "B<significand>(), B<significandf>(), B<significandl>():"

#. type: Plain text
#: man-pages/man3/significand.3:35
msgid "_SVID_SOURCE || _BSD_SOURCE"
msgstr "_SVID_SOURCE || _BSD_SOURCE"

#. type: Plain text
#: man-pages/man3/significand.3:44
msgid ""
"The B<significand>()  function returns the mantissa of I<x> scaled to the "
"range [1,2).  It is equivalent to"
msgstr ""

#. type: Plain text
#: man-pages/man3/significand.3:47
msgid "scalb(x, (double) -ilogb(x))"
msgstr "scalb(x, (double) -ilogb(x))"

#. type: Plain text
#: man-pages/man3/significand.3:51
msgid ""
"This function exists mainly for use in certain standardized tests for IEEE "
"754 conformance."
msgstr ""

#.  .SH HISTORY
#.  This function came from BSD.
#. type: Plain text
#: man-pages/man3/significand.3:57
msgid ""
"These functions are nonstandard; the I<double> version is available on a "
"number of other systems."
msgstr ""

#. type: Plain text
#: man-pages/man3/significand.3:59
msgid "B<ilogb>(3), B<scalb>(3)"
msgstr "B<ilogb>(3), B<scalb>(3)"

#. type: TH
#: man-pages/man3/sigsetops.3:31
#, no-wrap
msgid "SIGSETOPS"
msgstr "SIGSETOPS"

#. type: TH
#: man-pages/man3/sigsetops.3:31
#, no-wrap
msgid "2014-04-14"
msgstr "2014-04-14"

#. type: Plain text
#: man-pages/man3/sigsetops.3:35
msgid ""
"sigemptyset, sigfillset, sigaddset, sigdelset, sigismember - POSIX signal "
"set operations"
msgstr ""

#. type: Plain text
#: man-pages/man3/sigsetops.3:39
msgid "B<int sigemptyset(sigset_t *>I<set>B<);>"
msgstr "B<int sigemptyset(sigset_t *>I<set>B<);>"

#. type: Plain text
#: man-pages/man3/sigsetops.3:41
msgid "B<int sigfillset(sigset_t *>I<set>B<);>"
msgstr "B<int sigfillset(sigset_t *>I<set>B<);>"

#. type: Plain text
#: man-pages/man3/sigsetops.3:43
msgid "B<int sigaddset(sigset_t *>I<set>B<, int >I<signum>B<);>"
msgstr "B<int sigaddset(sigset_t *>I<set>B<, int >I<signum>B<);>"

#. type: Plain text
#: man-pages/man3/sigsetops.3:45
msgid "B<int sigdelset(sigset_t *>I<set>B<, int >I<signum>B<);>"
msgstr "B<int sigdelset(sigset_t *>I<set>B<, int >I<signum>B<);>"

#. type: Plain text
#: man-pages/man3/sigsetops.3:47
msgid "B<int sigismember(const sigset_t *>I<set>B<, int >I<signum>B<);>"
msgstr "B<int sigismember(const sigset_t *>I<set>B<, int >I<signum>B<);>"

#. type: Plain text
#: man-pages/man3/sigsetops.3:59
msgid ""
"B<sigemptyset>(), B<sigfillset>(), B<sigaddset>(), B<sigdelset>(), "
"B<sigismember>():"
msgstr "B<sigemptyset>(), B<sigfillset>(), B<sigaddset>(), B<sigdelset>(), B<sigismember>():"

#. type: Plain text
#: man-pages/man3/sigsetops.3:61
msgid "_POSIX_C_SOURCE\\ E<gt>=\\ 1 || _XOPEN_SOURCE || _POSIX_SOURCE"
msgstr "_POSIX_C_SOURCE\\ E<gt>=\\ 1 || _XOPEN_SOURCE || _POSIX_SOURCE"

#. type: Plain text
#: man-pages/man3/sigsetops.3:65
msgid "These functions allow the manipulation of POSIX signal sets."
msgstr ""

#. type: Plain text
#: man-pages/man3/sigsetops.3:70
msgid ""
"B<sigemptyset>()  initializes the signal set given by I<set> to empty, with "
"all signals excluded from the set."
msgstr ""

#. type: Plain text
#: man-pages/man3/sigsetops.3:75
msgid "B<sigfillset>()  initializes I<set> to full, including all signals."
msgstr ""

#. type: Plain text
#: man-pages/man3/sigsetops.3:83
msgid ""
"B<sigaddset>()  and B<sigdelset>()  add and delete respectively signal "
"I<signum> from I<set>."
msgstr ""

#. type: Plain text
#: man-pages/man3/sigsetops.3:89
msgid "B<sigismember>()  tests whether I<signum> is a member of I<set>."
msgstr ""

#. type: Plain text
#: man-pages/man3/sigsetops.3:107
msgid ""
"Objects of type I<sigset_t> must be initialized by a call to either "
"B<sigemptyset>()  or B<sigfillset>()  before being passed to the functions "
"B<sigaddset>(), B<sigdelset>()  and B<sigismember>()  or the additional "
"glibc functions described below (B<sigisemptyset>(), B<sigandset>(), and "
"B<sigorset>()).  The results are undefined if this is not done."
msgstr ""

#. type: Plain text
#: man-pages/man3/sigsetops.3:114
msgid ""
"B<sigemptyset>(), B<sigfillset>(), B<sigaddset>(), and B<sigdelset>()  "
"return 0 on success and -1 on error."
msgstr ""

#. type: Plain text
#: man-pages/man3/sigsetops.3:126
msgid ""
"B<sigismember>()  returns 1 if I<signum> is a member of I<set>, 0 if "
"I<signum> is not a member, and -1 on error.  On error, these functions set "
"I<errno> to indicate the cause."
msgstr ""

#. type: Plain text
#: man-pages/man3/sigsetops.3:131
msgid "I<sig> is not a valid signal."
msgstr ""

#. type: Plain text
#: man-pages/man3/sigsetops.3:144
msgid ""
"The B<sigemptyset>(), B<sigfillset>(), B<sigaddset>(), B<sigdelset>(), "
"B<sigismember>(), B<sigisemptyset>(), B<sigorset>(), and B<sigandset>()  "
"functions are thread-safe."
msgstr ""

#. type: SS
#: man-pages/man3/sigsetops.3:147
#, no-wrap
msgid "Glibc notes"
msgstr ""

#. type: Plain text
#: man-pages/man3/sigsetops.3:153
msgid ""
"If the B<_GNU_SOURCE> feature test macro is defined, then "
"I<E<lt>signal.hE<gt>> exposes three other functions for manipulating signal "
"sets:"
msgstr ""

#. type: Plain text
#: man-pages/man3/sigsetops.3:160
#, no-wrap
msgid ""
"B<int sigisemptyset(const sigset_t *>I<set>B<);>\n"
"B<int sigorset(sigset_t *>I<dest>B<, const sigset_t *>I<left>B<,>\n"
"B<              const sigset_t *>I<right>B<);>\n"
"B<int sigandset(sigset_t *>I<dest>B<, const sigset_t *>I<left>B<,>\n"
"B<              const sigset_t *>I<right>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/sigsetops.3:166
msgid ""
"B<sigisemptyset>()  returns 1 if I<set> contains no signals, and 0 "
"otherwise."
msgstr ""

#. type: Plain text
#: man-pages/man3/sigsetops.3:182
msgid ""
"B<sigorset>()  places the union of the sets I<left> and I<right> in I<dest>."
"  B<sigandset>()  places the intersection of the sets I<left> and I<right> "
"in I<dest>.  Both functions return 0 on success, and -1 on failure."
msgstr ""

#. type: Plain text
#: man-pages/man3/sigsetops.3:185
msgid ""
"These functions are nonstandard (a few other systems provide similar "
"functions) and their use should be avoided in portable applications."
msgstr ""

#. type: Plain text
#: man-pages/man3/sigsetops.3:189
msgid "B<sigaction>(2), B<sigpending>(2), B<sigprocmask>(2), B<sigsuspend>(2)"
msgstr ""

#. type: TH
#: man-pages/man3/sem_unlink.3:26
#, no-wrap
msgid "SEM_UNLINK"
msgstr "SEM_UNLINK"

#. type: TH
#: man-pages/man3/sem_unlink.3:26
#, no-wrap
msgid "2014-02-26"
msgstr "2014-02-26"

#. type: Plain text
#: man-pages/man3/sem_unlink.3:29
msgid "sem_unlink - remove a named semaphore"
msgstr ""

#. type: Plain text
#: man-pages/man3/sem_unlink.3:32
#, no-wrap
msgid "B<#include E<lt>semaphore.hE<gt>>\n"
msgstr "B<#include E<lt>semaphore.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/sem_unlink.3:34
#, no-wrap
msgid "B<int sem_unlink(const char *>I<name>B<);>\n"
msgstr "B<int sem_unlink(const char *>I<name>B<);>\n"

#. type: Plain text
#: man-pages/man3/sem_unlink.3:37
msgid "Link with I<-pthread>."
msgstr ""

#. type: Plain text
#: man-pages/man3/sem_unlink.3:44
msgid ""
"B<sem_unlink>()  removes the named semaphore referred to by I<name>.  The "
"semaphore name is removed immediately.  The semaphore is destroyed once all "
"other processes that have the semaphore open close it."
msgstr ""

#. type: Plain text
#: man-pages/man3/sem_unlink.3:50
msgid ""
"On success B<sem_unlink>()  returns 0; on error, -1 is returned, with "
"I<errno> set to indicate the error."
msgstr ""

#. type: Plain text
#: man-pages/man3/sem_unlink.3:54
msgid "The caller does not have permission to unlink this semaphore."
msgstr ""

#. type: Plain text
#: man-pages/man3/sem_unlink.3:58
msgid "I<name> was too long."
msgstr ""

#. type: Plain text
#: man-pages/man3/sem_unlink.3:62
msgid "There is no semaphore with the given I<name>."
msgstr ""

#. type: Plain text
#: man-pages/man3/sem_unlink.3:67
msgid "The B<sem_unlink>()  function is thread-safe."
msgstr ""

#. type: Plain text
#: man-pages/man3/sem_unlink.3:74
msgid ""
"B<sem_getvalue>(3), B<sem_open>(3), B<sem_post>(3), B<sem_wait>(3), "
"B<sem_overview>(7)"
msgstr "B<sem_getvalue>(3), B<sem_open>(3), B<sem_post>(3), B<sem_wait>(3), B<sem_overview>(7)"

#. type: TH
#: man-pages/man3/sem_open.3:26
#, no-wrap
msgid "SEM_OPEN"
msgstr "SEM_OPEN"

#. type: Plain text
#: man-pages/man3/sem_open.3:29
msgid "sem_open - initialize and open a named semaphore"
msgstr ""

#. type: Plain text
#: man-pages/man3/sem_open.3:34
#, no-wrap
msgid ""
"B<#include E<lt>fcntl.hE<gt>>           /* For O_* constants */\n"
"B<#include E<lt>sys/stat.hE<gt>>        /* For mode constants */\n"
"B<#include E<lt>semaphore.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/sem_open.3:38
#, no-wrap
msgid ""
"B<sem_t *sem_open(const char *>I<name>B<, int >I<oflag>B<);>\n"
"B<sem_t *sem_open(const char *>I<name>B<, int >I<oflag>B<, >\n"
"B<                mode_t >I<mode>B<, unsigned int >I<value>B<);>\n"
msgstr "B<sem_t *sem_open(const char *>I<name>B<, int >I<oflag>B<);>\nB<sem_t *sem_open(const char *>I<name>B<, int >I<oflag>B<, >\nB<                mode_t >I<mode>B<, unsigned int >I<value>B<);>\n"

#. type: Plain text
#: man-pages/man3/sem_open.3:50
msgid ""
"B<sem_open>()  creates a new POSIX semaphore or opens an existing semaphore."
"  The semaphore is identified by I<name>.  For details of the construction "
"of I<name>, see B<sem_overview>(7)."
msgstr ""

#.  In reality the filesystem IDs are used on Linux.
#. type: Plain text
#: man-pages/man3/sem_open.3:76
msgid ""
"The I<oflag> argument specifies flags that control the operation of the "
"call.  (Definitions of the flags values can be obtained by including "
"I<E<lt>fcntl.hE<gt>>.)  If B<O_CREAT> is specified in I<oflag>, then the "
"semaphore is created if it does not already exist.  The owner (user ID) of "
"the semaphore is set to the effective user ID of the calling process.  The "
"group ownership (group ID) is set to the effective group ID of the calling "
"process.  If both B<O_CREAT> and B<O_EXCL> are specified in I<oflag>, then "
"an error is returned if a semaphore with the given I<name> already exists."
msgstr ""

#. type: Plain text
#: man-pages/man3/sem_open.3:104
msgid ""
"If B<O_CREAT> is specified in I<oflag>, then two additional arguments must "
"be supplied.  The I<mode> argument specifies the permissions to be placed on"
" the new semaphore, as for B<open>(2).  (Symbolic definitions for the "
"permissions bits can be obtained by including I<E<lt>sys/stat.hE<gt>>.)  The"
" permissions settings are masked against the process umask.  Both read and "
"write permission should be granted to each class of user that will access "
"the semaphore.  The I<value> argument specifies the initial value for the "
"new semaphore.  If B<O_CREAT> is specified, and a semaphore with the given "
"I<name> already exists, then I<mode> and I<value> are ignored."
msgstr ""

#. type: Plain text
#: man-pages/man3/sem_open.3:116
msgid ""
"On success, B<sem_open>()  returns the address of the new semaphore; this "
"address is used when calling other semaphore-related functions.  On error, "
"B<sem_open>()  returns B<SEM_FAILED>, with I<errno> set to indicate the "
"error."
msgstr ""

#. type: Plain text
#: man-pages/man3/sem_open.3:121
msgid ""
"The semaphore exists, but the caller does not have permission to open it."
msgstr ""

#. type: Plain text
#: man-pages/man3/sem_open.3:132
msgid ""
"Both B<O_CREAT> and B<O_EXCL> were specified in I<oflag>, but a semaphore "
"with this I<name> already exists."
msgstr ""

#. type: Plain text
#: man-pages/man3/sem_open.3:137
msgid "I<value> was greater than B<SEM_VALUE_MAX>."
msgstr ""

#. type: Plain text
#: man-pages/man3/sem_open.3:141
msgid "I<name> consists of just \"/\", followed by no other characters."
msgstr ""

#. type: Plain text
#: man-pages/man3/sem_open.3:144
msgid "The process already has the maximum number of files and open."
msgstr ""

#.  this error can occur if we have a name of the (nonportable) form
#.  /dir/name, and the directory /dev/shm/dir does not exist.
#. type: Plain text
#: man-pages/man3/sem_open.3:167
msgid ""
"The B<O_CREAT> flag was not specified in I<oflag> and no semaphore with this"
" I<name> exists; or, B<O_CREAT> was specified, but I<name> wasn't well "
"formed."
msgstr ""

#. type: Plain text
#: man-pages/man3/sem_open.3:170
msgid "Insufficient memory."
msgstr "Недостаточно памяти."

#. type: Plain text
#: man-pages/man3/sem_open.3:178
msgid ""
"B<sem_close>(3), B<sem_getvalue>(3), B<sem_post>(3), B<sem_unlink>(3), "
"B<sem_wait>(3), B<sem_overview>(7)"
msgstr ""

#. type: TH
#: man-pages/man3/sem_close.3:26
#, no-wrap
msgid "SEM_CLOSE"
msgstr "SEM_CLOSE"

#. type: Plain text
#: man-pages/man3/sem_close.3:29
msgid "sem_close - close a named semaphore"
msgstr ""

#. type: Plain text
#: man-pages/man3/sem_close.3:34
#, no-wrap
msgid "B<int sem_close(sem_t *>I<sem>B<);>\n"
msgstr "B<int sem_close(sem_t *>I<sem>B<);>\n"

#. type: Plain text
#: man-pages/man3/sem_close.3:43
msgid ""
"B<sem_close>()  closes the named semaphore referred to by I<sem>, allowing "
"any resources that the system has allocated to the calling process for this "
"semaphore to be freed."
msgstr ""

#. type: Plain text
#: man-pages/man3/sem_close.3:49
msgid ""
"On success B<sem_close>()  returns 0; on error, -1 is returned, with "
"I<errno> set to indicate the error."
msgstr ""

#. type: Plain text
#: man-pages/man3/sem_close.3:54
msgid "I<sem> is not a valid semaphore."
msgstr ""

#. type: Plain text
#: man-pages/man3/sem_close.3:60
msgid ""
"All open named semaphores are automatically closed on process termination, "
"or upon B<execve>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man3/sem_close.3:66
msgid ""
"B<sem_getvalue>(3), B<sem_open>(3), B<sem_post>(3), B<sem_unlink>(3), "
"B<sem_wait>(3), B<sem_overview>(7)"
msgstr "B<sem_getvalue>(3), B<sem_open>(3), B<sem_post>(3), B<sem_unlink>(3), B<sem_wait>(3), B<sem_overview>(7)"

#. type: TH
#: man-pages/man3/strpbrk.3:30
#, no-wrap
msgid "STRPBRK"
msgstr "STRPBRK"

#. type: Plain text
#: man-pages/man3/strpbrk.3:33
msgid "strpbrk - search a string for any of a set of bytes"
msgstr ""

#. type: Plain text
#: man-pages/man3/strpbrk.3:38
#, no-wrap
msgid "B<char *strpbrk(const char *>I<s>B<, const char *>I<accept>B<);>\n"
msgstr "B<char *strpbrk(const char *>I<s>B<, const char *>I<accept>B<);>\n"

#. type: Plain text
#: man-pages/man3/strpbrk.3:47
msgid ""
"The B<strpbrk>()  function locates the first occurrence in the string I<s> "
"of any of the bytes in the string I<accept>."
msgstr ""

#. type: Plain text
#: man-pages/man3/strpbrk.3:56
msgid ""
"The B<strpbrk>()  function returns a pointer to the byte in I<s> that "
"matches one of the bytes in I<accept>, or NULL if no such byte is found."
msgstr ""

#. type: Plain text
#: man-pages/man3/strpbrk.3:61
msgid "The B<strpbrk>()  function is thread-safe."
msgstr ""

#. type: Plain text
#: man-pages/man3/strpbrk.3:73
msgid ""
"B<index>(3), B<memchr>(3), B<rindex>(3), B<strchr>(3), B<string>(3), "
"B<strsep>(3), B<strspn>(3), B<strstr>(3), B<strtok>(3), B<wcspbrk>(3)"
msgstr "B<index>(3), B<memchr>(3), B<rindex>(3), B<strchr>(3), B<string>(3), B<strsep>(3), B<strspn>(3), B<strstr>(3), B<strtok>(3), B<wcspbrk>(3)"

#. type: TH
#: man-pages/man3/strsignal.3:30
#, no-wrap
msgid "STRSIGNAL"
msgstr "STRSIGNAL"

#. type: TH
#: man-pages/man3/strsignal.3:30
#, no-wrap
msgid "2010-09-15"
msgstr "2010-09-15"

#. type: Plain text
#: man-pages/man3/strsignal.3:33
msgid "strsignal - return string describing signal"
msgstr ""

#. type: Plain text
#: man-pages/man3/strsignal.3:38
#, no-wrap
msgid "B<char *strsignal(int >I<sig>B<);>\n"
msgstr "B<char *strsignal(int >I<sig>B<);>\n"

#. type: Plain text
#: man-pages/man3/strsignal.3:40
#, no-wrap
msgid "B<extern const char * const >I<sys_siglist>B<[];>\n"
msgstr "B<extern const char * const >I<sys_siglist>B<[];>\n"

#. type: Plain text
#: man-pages/man3/strsignal.3:48
msgid "B<strsignal>():"
msgstr "B<strsignal>():"

#. type: Plain text
#: man-pages/man3/strsignal.3:68
msgid ""
"The B<strsignal>()  function returns a string describing the signal number "
"passed in the argument I<sig>.  The string can be used only until the next "
"call to B<strsignal>()."
msgstr ""

#. type: Plain text
#: man-pages/man3/strsignal.3:77
msgid ""
"The array I<sys_siglist> holds the signal description strings indexed by "
"signal number.  The B<strsignal>()  function should be used if possible "
"instead of this array."
msgstr ""

#. type: Plain text
#: man-pages/man3/strsignal.3:84
msgid ""
"The B<strsignal>()  function returns the appropriate description string, or "
"an unknown signal message if the signal number is invalid.  On some systems "
"(but not on Linux), NULL may instead be returned for an invalid signal "
"number."
msgstr ""

#. type: Plain text
#: man-pages/man3/strsignal.3:87
msgid "POSIX.1-2008.  Present on Solaris and the BSDs."
msgstr ""

#. type: Plain text
#: man-pages/man3/strsignal.3:89
msgid "B<psignal>(3), B<strerror>(3)"
msgstr "B<psignal>(3), B<strerror>(3)"

#. type: TH
#: man-pages/man3/strcoll.3:30
#, no-wrap
msgid "STRCOLL"
msgstr "STRCOLL"

#. type: TH
#: man-pages/man3/strcoll.3:30
#, no-wrap
msgid "2010-09-20"
msgstr "2010-09-20"

#. type: Plain text
#: man-pages/man3/strcoll.3:33
msgid "strcoll - compare two strings using the current locale"
msgstr "strcoll - сравнение двух строк применяя правила текущей локали"

#. type: Plain text
#: man-pages/man3/strcoll.3:38
#, no-wrap
msgid "B<int strcoll(const char *>I<s1>B<, const char *>I<s2>B<);>\n"
msgstr "B<int strcoll(const char *>I<s1>B<, const char *>I<s2>B<);>\n"

#. type: Plain text
#: man-pages/man3/strcoll.3:58
msgid ""
"The B<strcoll>()  function compares the two strings I<s1> and I<s2>.  It "
"returns an integer less than, equal to, or greater than zero if I<s1> is "
"found, respectively, to be less than, to match, or be greater than I<s2>.  "
"The comparison is based on strings interpreted as appropriate for the "
"program's current locale for category B<LC_COLLATE>.  (See B<setlocale>(3).)"
msgstr "Функция B<strcoll>() сравнивает строки I<s1> и I<s2>. Она возвращает целое число, которое может быть меньше, равно или больше ноля, если выяснится, что I<s1> меньше, равна или больше I<s2> соответственно. Сравнение производится на основе правил текущей локали, указанной в категории B<LC_COLLATE> (см. B<setlocale>(3))."

#. type: Plain text
#: man-pages/man3/strcoll.3:69
msgid ""
"The B<strcoll>()  function returns an integer less than, equal to, or "
"greater than zero if I<s1> is found, respectively, to be less than, to "
"match, or be greater than I<s2>, when both are interpreted as appropriate "
"for the current locale."
msgstr "Функция B<strcoll>() возвращает целое число меньше, равное или большее нуля, если выяснится, что I<s1> меньше, равна или больше  I<s2> соответственно. При этом сравнение строк производится по правилам текущей локали."

#. type: Plain text
#: man-pages/man3/strcoll.3:80
msgid ""
"In the I<POSIX> or I<C> locales B<strcoll>()  is equivalent to B<strcmp>(3)."
msgstr "Если локаль равна I<POSIX> или I<C>, то работа функции B<strcoll>() эквивалентна B<strcmp>(3)."

#. type: Plain text
#: man-pages/man3/strcoll.3:87
msgid ""
"B<bcmp>(3), B<memcmp>(3), B<setlocale>(3), B<strcasecmp>(3), B<strcmp>(3), "
"B<string>(3), B<strxfrm>(3)"
msgstr "B<bcmp>(3), B<memcmp>(3), B<setlocale>(3), B<strcasecmp>(3), B<strcmp>(3), B<string>(3), B<strxfrm>(3)"

#. type: TH
#: man-pages/man3/strchr.3:33
#, no-wrap
msgid "STRCHR"
msgstr "STRCHR"

#. type: TH
#: man-pages/man3/strchr.3:33
#, no-wrap
msgid "2014-01-20"
msgstr "2014-01-20"

#. type: Plain text
#: man-pages/man3/strchr.3:36
msgid "strchr, strrchr, strchrnul - locate character in string"
msgstr "strchr, strrchr, strchrnul - определение местонахождения символа в строке"

#. type: Plain text
#: man-pages/man3/strchr.3:41
#, no-wrap
msgid "B<char *strchr(const char *>I<s>B<, int >I<c>B<);>\n"
msgstr "B<char *strchr(const char *>I<s>B<, int >I<c>B<);>\n"

#. type: Plain text
#: man-pages/man3/strchr.3:43
#, no-wrap
msgid "B<char *strrchr(const char *>I<s>B<, int >I<c>B<);>\n"
msgstr "B<char *strrchr(const char *>I<s>B<, int >I<c>B<);>\n"

#. type: Plain text
#: man-pages/man3/strchr.3:46
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>         /* See feature_test_macros(7) */\n"
"B<#include E<lt>string.hE<gt>>\n"
msgstr "B<#define _GNU_SOURCE>         /* см. feature_test_macros(7) */\nB<#include E<lt>string.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/strchr.3:48
#, no-wrap
msgid "B<char *strchrnul(const char *>I<s>B<, int >I<c>B<);>\n"
msgstr "B<char *strchrnul(const char *>I<s>B<, int >I<c>B<);>\n"

#. type: Plain text
#: man-pages/man3/strchr.3:57
msgid ""
"The B<strchr>()  function returns a pointer to the first occurrence of the "
"character I<c> in the string I<s>."
msgstr "Функция B<strchr>() возвращает указатель на местонахождение первого совпадения с символом I<c> в строке I<s>."

#. type: Plain text
#: man-pages/man3/strchr.3:65
msgid ""
"The B<strrchr>()  function returns a pointer to the last occurrence of the "
"character I<c> in the string I<s>."
msgstr "Функция B<strrchr>() возвращает указатель на местонахождение последнего совпадения с символом I<c> в строке I<s>."

#. type: Plain text
#: man-pages/man3/strchr.3:78
msgid ""
"The B<strchrnul>()  function is like B<strchr>()  except that if I<c> is not"
" found in I<s>, then it returns a pointer to the null byte at the end of "
"I<s>, rather than NULL."
msgstr "Функция B<strchrnul>() подобна B<strchr>(), за исключением того, что если символ I<c> не найден в строке I<s>, то возвращается указатель на байт null в конце I<s>, а не NULL."

#. type: Plain text
#: man-pages/man3/strchr.3:81
msgid ""
"Here \"character\" means \"byte\"; these functions do not work with wide or "
"multibyte characters."
msgstr "Здесь под «символом» подразумевается «байт» — данные функции не работают с широкими и многобайтными символами."

#. type: Plain text
#: man-pages/man3/strchr.3:93
msgid ""
"The B<strchr>()  and B<strrchr>()  functions return a pointer to the matched"
" character or NULL if the character is not found.  The terminating null byte"
" is considered part of the string, so that if I<c> is specified as "
"\\(aq\\e0\\(aq, these functions return a pointer to the terminator."
msgstr "Функции B<strchr>() и B<strrchr>() возвращает указатель на местонахождение первого совпадения с символом или NULL, если символ не найден. Завершающий байт null считается частью строки, и поэтому, если символ I<c> задан как \\(aq\\e0\\(aq, то эти функции возвращают указатель на завершающий символ."

#. type: Plain text
#: man-pages/man3/strchr.3:104
msgid ""
"The B<strchrnul>()  function returns a pointer to the matched character, or "
"a pointer to the null byte at the end of I<s> (i.e., I<s+strlen(s)>)  if the"
" character is not found."
msgstr "Функция B<strchrnul>() возвращает указатель на совпавший символ, или указатель на байт null в конце строки I<s> (т.е., I<s+strlen(s)>), если символ не найден."

#. type: Plain text
#: man-pages/man3/strchr.3:107
msgid "B<strchrnul>()  first appeared in glibc in version 2.1.1."
msgstr "Функция B<strchrnul>() впервые появилась в glibc версии 2.1.1."

#. type: Plain text
#: man-pages/man3/strchr.3:115
msgid ""
"The B<strchr>(), B<strrchr>(), and B<strchrnul>()  functions are thread-"
"safe."
msgstr "Функции B<strchr>(), B<strrchr>() и B<strchrnul>() можно использовать в нескольких нитях одновременно."

#. type: Plain text
#: man-pages/man3/strchr.3:122
msgid ""
"B<strchr>()  and B<strrchr>()  are in SVr4, 4.3BSD, C89, C99.  "
"B<strchrnul>()  is a GNU extension."
msgstr "Функции B<strchr>() и B<strrchr>() описаны в SVr4, 4.3BSD, C89, C99. Функция B<strchrnul>() является расширением GNU."

#. type: Plain text
#: man-pages/man3/strchr.3:134
msgid ""
"B<index>(3), B<memchr>(3), B<rindex>(3), B<string>(3), B<strlen>(3), "
"B<strpbrk>(3), B<strsep>(3), B<strspn>(3), B<strstr>(3), B<strtok>(3), "
"B<wcschr>(3), B<wcsrchr>(3)"
msgstr "B<index>(3), B<memchr>(3), B<rindex>(3), B<string>(3), B<strlen>(3), B<strpbrk>(3), B<strsep>(3), B<strspn>(3), B<strstr>(3), B<strtok>(3), B<wcschr>(3), B<wcsrchr>(3)"

#. type: TH
#: man-pages/man3/setaliasent.3:9
#, no-wrap
msgid "SETALIASENT"
msgstr "SETALIASENT"

#. type: TH
#: man-pages/man3/setaliasent.3:9
#, no-wrap
msgid "2003-09-09"
msgstr "2003-09-09"

#. type: Plain text
#: man-pages/man3/setaliasent.3:13
msgid ""
"setaliasent, endaliasent, getaliasent, getaliasent_r, getaliasbyname, "
"getaliasbyname_r - read an alias entry"
msgstr ""

#. type: Plain text
#: man-pages/man3/setaliasent.3:15
msgid "B<#include E<lt>aliases.hE<gt>>"
msgstr "B<#include E<lt>aliases.hE<gt>>"

#. type: Plain text
#: man-pages/man3/setaliasent.3:17
msgid "B<void setaliasent(void);>"
msgstr "B<void setaliasent(void);>"

#. type: Plain text
#: man-pages/man3/setaliasent.3:19
msgid "B<void endaliasent(void);>"
msgstr "B<void endaliasent(void);>"

#. type: Plain text
#: man-pages/man3/setaliasent.3:21
msgid "B<struct aliasent *getaliasent(void);>"
msgstr "B<struct aliasent *getaliasent(void);>"

#. type: Plain text
#: man-pages/man3/setaliasent.3:23
msgid "B<int getaliasent_r(struct aliasent *>I<result>B<,>"
msgstr "B<int getaliasent_r(struct aliasent *>I<result>B<,>"

#. type: Plain text
#: man-pages/man3/setaliasent.3:25 man-pages/man3/setaliasent.3:31
msgid ""
"B< char *>I<buffer>B<, size_t >I<buflen>B<, struct aliasent **>I<res>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man3/setaliasent.3:27
msgid "B<struct aliasent *getaliasbyname(const char *>I<name>B<);>"
msgstr "B<struct aliasent *getaliasbyname(const char *>I<name>B<);>"

#. type: Plain text
#: man-pages/man3/setaliasent.3:29
msgid ""
"B<int getaliasbyname_r(const char *>I<name>B<, struct aliasent "
"*>I<result>B<,>"
msgstr "B<int getaliasbyname_r(const char *>I<name>B<, struct aliasent *>I<result>B<,>"

#. type: Plain text
#: man-pages/man3/setaliasent.3:37
msgid ""
"One of the databases available with the Name Service Switch (NSS)  is the "
"aliases database, that contains mail aliases.  (To find out which databases "
"are supported, try I<getent --help>.)  Six functions are provided to access "
"the aliases database."
msgstr ""

#. type: Plain text
#: man-pages/man3/setaliasent.3:44
msgid ""
"The B<getaliasent>()  function returns a pointer to a structure containing "
"the group information from the aliases database.  The first time it is "
"called it returns the first entry; thereafter, it returns successive "
"entries."
msgstr ""

#. type: Plain text
#: man-pages/man3/setaliasent.3:49
msgid ""
"The B<setaliasent>()  function rewinds the file pointer to the beginning of "
"the aliases database."
msgstr ""

#. type: Plain text
#: man-pages/man3/setaliasent.3:53
msgid "The B<endaliasent>()  function closes the aliases database."
msgstr ""

#. type: Plain text
#: man-pages/man3/setaliasent.3:60
msgid ""
"B<getaliasent_r>()  is the reentrant version of the previous function.  The "
"requested structure is stored via the first argument but the programmer "
"needs to fill the other arguments also.  Not providing enough space causes "
"the function to fail."
msgstr ""

#. type: Plain text
#: man-pages/man3/setaliasent.3:66
msgid ""
"The function B<getaliasbyname>()  takes the name argument and searches the "
"aliases database.  The entry is returned as a pointer to a I<struct "
"aliasent>."
msgstr ""

#. type: Plain text
#: man-pages/man3/setaliasent.3:73
msgid ""
"B<getaliasbyname_r>()  is the reentrant version of the previous function.  "
"The requested structure is stored via the second argument but the programmer"
" needs to fill the other arguments also.  Not providing enough space causes "
"the function to fail."
msgstr ""

#. type: Plain text
#: man-pages/man3/setaliasent.3:78
msgid "The I<struct aliasent> is defined in I<E<lt>aliases.hE<gt>>:"
msgstr ""

#. type: Plain text
#: man-pages/man3/setaliasent.3:87
#, no-wrap
msgid ""
"struct aliasent {\n"
"    char    *alias_name;             /* alias name */\n"
"    size_t   alias_members_len;\n"
"    char   **alias_members;          /* alias name list */\n"
"    int      alias_local;\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/setaliasent.3:95
msgid ""
"The functions B<getaliasent_r>()  and B<getaliasbyname_r>()  return a "
"nonzero value on error."
msgstr ""

#. type: Plain text
#: man-pages/man3/setaliasent.3:101
msgid ""
"The default alias database is the file I</etc/aliases>.  This can be changed"
" in the I</etc/nsswitch.conf> file."
msgstr ""

#. type: Plain text
#: man-pages/man3/setaliasent.3:104
msgid ""
"These routines are glibc-specific.  The NeXT system has similar routines:"
msgstr ""

#. type: Plain text
#: man-pages/man3/setaliasent.3:108
#, no-wrap
msgid "#include E<lt>aliasdb.hE<gt>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/setaliasent.3:113
#, no-wrap
msgid ""
"void alias_setent(void);\n"
"void alias_endent(void);\n"
"alias_ent *alias_getent(void);\n"
"alias_ent *alias_getbyname(char *name);\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/setaliasent.3:119
msgid ""
"The following example compiles with I<gcc example.c -o example>.  It will "
"dump all names in the alias database."
msgstr ""

#. type: Plain text
#: man-pages/man3/setaliasent.3:125
#, no-wrap
msgid ""
"#include E<lt>aliases.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/setaliasent.3:144
#, no-wrap
msgid ""
"int\n"
"main(void)\n"
"{\n"
"    struct aliasent *al;\n"
"    setaliasent();\n"
"    for (;;) {\n"
"        al = getaliasent();\n"
"        if (al == NULL)\n"
"            break;\n"
"        printf(\"Name: %s\\en\", al-E<gt>alias_name);\n"
"    }\n"
"    if (errno) {\n"
"        perror(\"reading alias\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
"    endaliasent();\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/setaliasent.3:149
msgid "B<getgrent>(3), B<getpwent>(3), B<getspent>(3), B<aliases>(5)"
msgstr "B<getgrent>(3), B<getpwent>(3), B<getspent>(3), B<aliases>(5)"

#. type: TH
#: man-pages/man3/sin.3:35
#, no-wrap
msgid "SIN"
msgstr "SIN"

#. type: TH
#: man-pages/man3/sin.3:35
#, no-wrap
msgid "2013-12-16"
msgstr "2013-12-16"

#. type: Plain text
#: man-pages/man3/sin.3:38
msgid "sin, sinf, sinl - sine function"
msgstr "sin, sinf, sinl - функция вычисления синуса"

#. type: Plain text
#: man-pages/man3/sin.3:41
#, no-wrap
msgid "B<#include E<lt>math.hE<gt>>\n"
msgstr "B<#include E<lt>math.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/sin.3:43
#, no-wrap
msgid "B<double sin(double >I<x>B<);>\n"
msgstr "B<double sin(double >I<x>B<);>\n"

#. type: Plain text
#: man-pages/man3/sin.3:45
#, no-wrap
msgid "B<float sinf(float >I<x>B<);>\n"
msgstr "B<float sinf(float >I<x>B<);>\n"

#. type: Plain text
#: man-pages/man3/sin.3:47
#, no-wrap
msgid "B<long double sinl(long double >I<x>B<);>\n"
msgstr "B<long double sinl(long double >I<x>B<);>\n"

#. type: Plain text
#: man-pages/man3/sin.3:59
msgid "B<sinf>(), B<sinl>():"
msgstr "B<sinf>(), B<sinl>():"

#. type: Plain text
#: man-pages/man3/sin.3:62
msgid ""
"_BSD_SOURCE || _SVID_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 600 || "
"_ISOC99_SOURCE || _POSIX_C_SOURCE\\ E<gt>=\\ 200112L;"
msgstr "_BSD_SOURCE || _SVID_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 600 || _ISOC99_SOURCE || _POSIX_C_SOURCE\\ E<gt>=\\ 200112L;"

#. type: Plain text
#: man-pages/man3/sin.3:76
msgid ""
"The B<sin>()  function returns the sine of I<x>, where I<x> is given in "
"radians."
msgstr "Функция B<sin>() возвращает синус от I<x>, где I<x> указан в радианах."

#. type: Plain text
#: man-pages/man3/sin.3:79
msgid "On success, these functions return the sine of I<x>."
msgstr "В случае успеха эти функции возвращают синус от I<x>."

#. type: Plain text
#: man-pages/man3/sin.3:83
msgid "If I<x> is a NaN, a NaN is returned."
msgstr "Если I<x> имеет значение NaN, будет возвращено NaN."

#.  POSIX.1 allows an optional range error for subnormal x
#.  glibc 2.8 doesn't do this
#. type: Plain text
#: man-pages/man3/sin.3:92
msgid ""
"If I<x> is positive infinity or negative infinity, a domain error occurs, "
"and a NaN is returned."
msgstr "Если I<x> стремится к плюс бесконечности или минус бесконечности, то будет сгенерирована ошибка выхода за пределы области, а в качестве результата будет возвращено NaN."

#. type: Plain text
#: man-pages/man3/sin.3:97
msgid ""
"See B<math_error>(7)  for information on how to determine whether an error "
"has occurred when calling these functions."
msgstr "Смотрите B<math_error>(7), чтобы определить, какие ошибки могут возникать при вызове этих функций."

#. type: Plain text
#: man-pages/man3/sin.3:99
msgid "The following errors can occur:"
msgstr "Могут возникать следующие ошибки:"

#. type: TP
#: man-pages/man3/sin.3:99
#, no-wrap
msgid "Domain error: I<x> is an infinity"
msgstr "Ошибка области: I<x> стремится к бесконечности"

#. type: Plain text
#: man-pages/man3/sin.3:108
msgid ""
"I<errno> is set to B<EDOM> (but see BUGS).  An invalid floating-point "
"exception (B<FE_INVALID>)  is raised."
msgstr "I<errno> устанавливается в B<EDOM> (но см. ДЕФЕКТЫ). Возникает исключение неправильной плавающей точки (B<FE_INVALID>)."

#. type: Plain text
#: man-pages/man3/sin.3:116
msgid "The B<sin>(), B<sinf>(), and B<sinl>()  functions are thread-safe."
msgstr "Функции B<sin>(), B<sinf>() и B<sinl>() можно использовать в нескольких нитях одновременно."

#. type: Plain text
#: man-pages/man3/sin.3:122
msgid ""
"C99, POSIX.1-2001.  The variant returning I<double> also conforms to SVr4, "
"4.3BSD, C89."
msgstr "C99, POSIX.1-2001. Вариант, возвращающий значение типа I<double>, также соответствует SVr4, 4.3BSD и C89."

#.  http://sources.redhat.com/bugzilla/show_bug.cgi?id=6781
#. type: Plain text
#: man-pages/man3/sin.3:129
msgid ""
"Before version 2.10, the glibc implementation did not set I<errno> to "
"B<EDOM> when a domain error occurred."
msgstr "До версии 2.10 в реализации glibc при возникновении ошибки области I<errno> не устанавливалось в значение B<EDOM>."

#. type: Plain text
#: man-pages/man3/sin.3:137
msgid ""
"B<acos>(3), B<asin>(3), B<atan>(3), B<atan2>(3), B<cos>(3), B<csin>(3), "
"B<sincos>(3), B<tan>(3)"
msgstr "B<acos>(3), B<asin>(3), B<atan>(3), B<atan2>(3), B<cos>(3), B<csin>(3), B<sincos>(3), B<tan>(3)"

#. type: TH
#: man-pages/man3/sockatmark.3:25
#, no-wrap
msgid "SOCKATMARK"
msgstr "SOCKATMARK"

#. type: TH
#: man-pages/man3/sockatmark.3:25
#, no-wrap
msgid "2014-02-28"
msgstr "2014-02-28"

#. type: Plain text
#: man-pages/man3/sockatmark.3:28
msgid "sockatmark - determine whether socket is at out-of-band mark"
msgstr ""

#. type: Plain text
#: man-pages/man3/sockatmark.3:32
msgid "B<int sockatmark(int >I<sockfd>B<);>"
msgstr "B<int sockatmark(int >I<sockfd>B<);>"

#. type: Plain text
#: man-pages/man3/sockatmark.3:41
msgid ""
"B<sockatmark>(): _POSIX_C_SOURCE\\ E<gt>=\\ 200112L || _XOPEN_SOURCE\\ "
"E<gt>=\\ 600"
msgstr "B<sockatmark>(): _POSIX_C_SOURCE\\ E<gt>=\\ 200112L || _XOPEN_SOURCE\\ E<gt>=\\ 600"

#. type: Plain text
#: man-pages/man3/sockatmark.3:51
msgid ""
"B<sockatmark>()  returns a value indicating whether or not the socket "
"referred to by the file descriptor I<sockfd> is at the out-of-band mark.  If"
" the socket is at the mark, then 1 is returned; if the socket is not at the "
"mark, 0 is returned.  This function does not remove the out-of-band mark."
msgstr ""

#. type: Plain text
#: man-pages/man3/sockatmark.3:58
msgid ""
"A successful call to B<sockatmark>()  returns 1 if the socket is at the out-"
"of-band mark, or 0 if it is not.  On error, -1 is returned and I<errno> is "
"set to indicate the error."
msgstr ""

#. type: Plain text
#: man-pages/man3/sockatmark.3:63
msgid "I<sockfd> is not a valid file descriptor."
msgstr ""

#.  POSIX.1 says ENOTTY for this case
#. type: Plain text
#: man-pages/man3/sockatmark.3:70
msgid ""
"I<sockfd> is not a file descriptor to which B<sockatmark>()  can be applied."
msgstr ""

#. type: Plain text
#: man-pages/man3/sockatmark.3:73
msgid "B<sockatmark>()  was added to glibc in version 2.2.4."
msgstr "Функция B<sockatmark>() впервые появилась в glibc 2.2.4."

#. type: Plain text
#: man-pages/man3/sockatmark.3:78
msgid "The B<sockatmark>()  function is thread-safe."
msgstr ""

#. type: Plain text
#: man-pages/man3/sockatmark.3:87
msgid ""
"If B<sockatmark>()  returns 1, then the out-of-band data can be read using "
"the B<MSG_OOB> flag of B<recv>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man3/sockatmark.3:89
msgid "Out-of-band data is supported only on some stream socket protocols."
msgstr ""

#. type: Plain text
#: man-pages/man3/sockatmark.3:94
msgid ""
"B<sockatmark>()  can safely be called from a handler for the B<SIGURG> "
"signal."
msgstr ""

#. type: Plain text
#: man-pages/man3/sockatmark.3:100
msgid ""
"B<sockatmark>()  is implemented using the B<SIOCATMARK> B<ioctl>(2)  "
"operation."
msgstr ""

#. type: Plain text
#: man-pages/man3/sockatmark.3:104
msgid "Prior to glibc 2.4, B<sockatmark>()  did not work."
msgstr ""

#. type: Plain text
#: man-pages/man3/sockatmark.3:109
msgid ""
"The following code can be used after receipt of a B<SIGURG> signal to read "
"(and discard) all data up to the mark, and then read the byte of data at the"
" mark:"
msgstr ""

#. type: Plain text
#: man-pages/man3/sockatmark.3:114
#, no-wrap
msgid ""
"    char buf[BUF_LEN];\n"
"    char oobdata;\n"
"    int atmark, s;\n"
msgstr "    char buf[BUF_LEN];\n    char oobdata;\n    int atmark, s;\n"

#. type: Plain text
#: man-pages/man3/sockatmark.3:121
#, no-wrap
msgid ""
"    for (;;) {\n"
"        atmark = sockatmark(sockfd);\n"
"        if (atmark == -1) {\n"
"            perror(\"sockatmark\");\n"
"            break;\n"
"        }\n"
msgstr "    for (;;) {\n        atmark = sockatmark(sockfd);\n        if (atmark == -1) {\n            perror(\"sockatmark\");\n            break;\n        }\n"

#. type: Plain text
#: man-pages/man3/sockatmark.3:124
#, no-wrap
msgid ""
"        if (atmark)\n"
"            break;\n"
msgstr "        if (atmark)\n            break;\n"

#. type: Plain text
#: man-pages/man3/sockatmark.3:131
#, no-wrap
msgid ""
"        s = read(sockfd, buf, BUF_LEN) E<lt>= 0);\n"
"        if (s == -1)\n"
"            perror(\"read\");\n"
"        if (s E<lt>= 0)\n"
"            break;\n"
"    }\n"
msgstr "        s = read(sockfd, buf, BUF_LEN) E<lt>= 0);\n        if (s == -1)\n            perror(\"read\");\n        if (s E<lt>= 0)\n            break;\n    }\n"

#. type: Plain text
#: man-pages/man3/sockatmark.3:138
#, no-wrap
msgid ""
"    if (atmark == 1) {\n"
"        if (recv(sockfd, &oobdata, 1, MSG_OOB) == -1) {\n"
"            perror(\"recv\");\n"
"            ...\n"
"        }\n"
"    }\n"
msgstr "    if (atmark == 1) {\n        if (recv(sockfd, &oobdata, 1, MSG_OOB) == -1) {\n            perror(\"recv\");\n            ...\n        }\n    }\n"

#. type: Plain text
#: man-pages/man3/sockatmark.3:143
msgid "B<fcntl>(2), B<recv>(2), B<send>(2), B<tcp>(7)"
msgstr "B<fcntl>(2), B<recv>(2), B<send>(2), B<tcp>(7)"

#. type: TH
#: man-pages/man3/stdin.3:13
#, no-wrap
msgid "STDIN"
msgstr "STDIN"

#. type: TH
#: man-pages/man3/stdin.3:13
#, no-wrap
msgid "2008-07-14"
msgstr "2008-07-14"

#. type: Plain text
#: man-pages/man3/stdin.3:16
msgid "stdin, stdout, stderr - standard I/O streams"
msgstr "stdin, stdout, stderr - стандартные потоки ввода/вывода"

#. type: Plain text
#: man-pages/man3/stdin.3:23
#, no-wrap
msgid ""
"B<extern FILE *>I<stdin>B<;>\n"
"B<extern FILE *>I<stdout>B<;>\n"
"B<extern FILE *>I<stderr>B<;>\n"
msgstr "B<extern FILE *>I<stdin>B<;>\nB<extern FILE *>I<stdout>B<;>\nB<extern FILE *>I<stderr>B<;>\n"

#. type: Plain text
#: man-pages/man3/stdin.3:35
msgid ""
"Under normal circumstances every UNIX program has three streams opened for "
"it when it starts up, one for input, one for output, and one for printing "
"diagnostic or error messages.  These are typically attached to the user's "
"terminal (see B<tty>(4)  but might instead refer to files or other devices, "
"depending on what the parent process chose to set up.  (See also the "
"\"Redirection\" section of B<sh>(1).)"
msgstr ""

#. type: Plain text
#: man-pages/man3/stdin.3:45
msgid ""
"The input stream is referred to as \"standard input\"; the output stream is "
"referred to as \"standard output\"; and the error stream is referred to as "
"\"standard error\".  These terms are abbreviated to form the symbols used to"
" refer to these files, namely I<stdin>, I<stdout>, and I<stderr>."
msgstr ""

#. type: Plain text
#: man-pages/man3/stdin.3:54
msgid ""
"Each of these symbols is a B<stdio>(3)  macro of type pointer to I<FILE>, "
"and can be used with functions like B<fprintf>(3)  or B<fread>(3)."
msgstr ""

#. type: Plain text
#: man-pages/man3/stdin.3:63
msgid ""
"Since I<FILE>s are a buffering wrapper around UNIX file descriptors, the "
"same underlying files may also be accessed using the raw UNIX file "
"interface, that is, the functions like B<read>(2)  and B<lseek>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man3/stdin.3:82
msgid ""
"On program startup, the integer file descriptors associated with the streams"
" I<stdin>, I<stdout>, and I<stderr> are 0, 1, and 2, respectively.  The "
"preprocessor symbols B<STDIN_FILENO>, B<STDOUT_FILENO>, and B<STDERR_FILENO>"
" are defined with these values in I<E<lt>unistd.hE<gt>>.  (Applying "
"B<freopen>(3)  to one of these streams can change the file descriptor number"
" associated with the stream.)"
msgstr ""

#. type: Plain text
#: man-pages/man3/stdin.3:95
msgid ""
"Note that mixing use of I<FILE>s and raw file descriptors can produce "
"unexpected results and should generally be avoided.  (For the masochistic "
"among you: POSIX.1, section 8.2.3, describes in detail how this interaction "
"is supposed to work.)  A general rule is that file descriptors are handled "
"in the kernel, while stdio is just a library.  This means for example, that "
"after an B<exec>(3), the child inherits all open file descriptors, but all "
"old streams have become inaccessible."
msgstr ""

#. type: Plain text
#: man-pages/man3/stdin.3:113
msgid ""
"Since the symbols I<stdin>, I<stdout>, and I<stderr> are specified to be "
"macros, assigning to them is nonportable.  The standard streams can be made "
"to refer to different files with help of the library function B<freopen>(3),"
" specially introduced to make it possible to reassign I<stdin>, I<stdout>, "
"and I<stderr>.  The standard streams are closed by a call to B<exit>(3)  and"
" by normal program termination."
msgstr ""

#. type: Plain text
#: man-pages/man3/stdin.3:122
msgid ""
"The I<stdin>, I<stdout>, and I<stderr> macros conform to C89 and this "
"standard also stipulates that these three streams shall be open at program "
"startup."
msgstr ""

#. type: Plain text
#: man-pages/man3/stdin.3:154
msgid ""
"The stream I<stderr> is unbuffered.  The stream I<stdout> is line-buffered "
"when it points to a terminal.  Partial lines will not appear until "
"B<fflush>(3)  or B<exit>(3)  is called, or a newline is printed.  This can "
"produce unexpected results, especially with debugging output.  The buffering"
" mode of the standard streams (or any other stream)  can be changed using "
"the B<setbuf>(3)  or B<setvbuf>(3)  call.  Note that in case I<stdin> is "
"associated with a terminal, there may also be input buffering in the "
"terminal driver, entirely unrelated to stdio buffering.  (Indeed, normally "
"terminal input is line buffered in the kernel.)  This kernel input handling "
"can be modified using calls like B<tcsetattr>(3); see also B<stty>(1), and "
"B<termios>(3)."
msgstr ""

#. type: Plain text
#: man-pages/man3/stdin.3:159
msgid "B<csh>(1), B<sh>(1), B<open>(2), B<fopen>(3), B<stdio>(3)"
msgstr "B<csh>(1), B<sh>(1), B<open>(2), B<fopen>(3), B<stdio>(3)"

#. type: TH
#: man-pages/man3/stdarg.3:43
#, no-wrap
msgid "STDARG"
msgstr "STDARG"

#. type: TH
#: man-pages/man3/stdarg.3:43
#, no-wrap
msgid "2013-12-10"
msgstr "2013-12-10"

#. type: Plain text
#: man-pages/man3/stdarg.3:46
msgid "stdarg, va_start, va_arg, va_end, va_copy - variable argument lists"
msgstr ""

#. type: Plain text
#: man-pages/man3/stdarg.3:48
msgid "B<#include E<lt>stdarg.hE<gt>>"
msgstr "B<#include E<lt>stdarg.hE<gt>>"

#. type: Plain text
#: man-pages/man3/stdarg.3:50
msgid "B<void va_start(va_list >I<ap>B<, >I<last>B<);>"
msgstr "B<void va_start(va_list >I<ap>B<, >I<last>B<);>"

#. type: Plain text
#: man-pages/man3/stdarg.3:52
msgid "I<type>B< va_arg(va_list >I<ap>B<, >I<type>B<);>"
msgstr "I<type>B< va_arg(va_list >I<ap>B<, >I<type>B<);>"

#. type: Plain text
#: man-pages/man3/stdarg.3:54
msgid "B<void va_end(va_list >I<ap>B<);>"
msgstr "B<void va_end(va_list >I<ap>B<);>"

#. type: Plain text
#: man-pages/man3/stdarg.3:56
msgid "B<void va_copy(va_list >I<dest>B<, va_list >I<src>B<);>"
msgstr "B<void va_copy(va_list >I<dest>B<, va_list >I<src>B<);>"

#. type: Plain text
#: man-pages/man3/stdarg.3:65
msgid ""
"A function may be called with a varying number of arguments of varying "
"types.  The include file I<E<lt>stdarg.hE<gt>> declares a type I<va_list> "
"and defines three macros for stepping through a list of arguments whose "
"number and types are not known to the called function."
msgstr ""

#. type: Plain text
#: man-pages/man3/stdarg.3:73
msgid ""
"The called function must declare an object of type I<va_list> which is used "
"by the macros B<va_start>(), B<va_arg>(), and B<va_end>()."
msgstr ""

#. type: SS
#: man-pages/man3/stdarg.3:73
#, no-wrap
msgid "va_start()"
msgstr ""

#. type: Plain text
#: man-pages/man3/stdarg.3:83
msgid ""
"The B<va_start>()  macro initializes I<ap> for subsequent use by B<va_arg>()"
"  and B<va_end>(), and must be called first."
msgstr ""

#. type: Plain text
#: man-pages/man3/stdarg.3:88
msgid ""
"The argument I<last> is the name of the last argument before the variable "
"argument list, that is, the last argument of which the calling function "
"knows the type."
msgstr ""

#. type: Plain text
#: man-pages/man3/stdarg.3:93
msgid ""
"Because the address of this argument may be used in the B<va_start>()  "
"macro, it should not be declared as a register variable, or as a function or"
" an array type."
msgstr ""

#. type: SS
#: man-pages/man3/stdarg.3:93
#, no-wrap
msgid "va_arg()"
msgstr ""

#. type: Plain text
#: man-pages/man3/stdarg.3:115
msgid ""
"The B<va_arg>()  macro expands to an expression that has the type and value "
"of the next argument in the call.  The argument I<ap> is the I<va_list> "
"I<ap> initialized by B<va_start>().  Each call to B<va_arg>()  modifies "
"I<ap> so that the next call returns the next argument.  The argument I<type>"
" is a type name specified so that the type of a pointer to an object that "
"has the specified type can be obtained simply by adding a * to I<type>."
msgstr ""

#. type: Plain text
#: man-pages/man3/stdarg.3:123
msgid ""
"The first use of the B<va_arg>()  macro after that of the B<va_start>()  "
"macro returns the argument after I<last>.  Successive invocations return the"
" values of the remaining arguments."
msgstr ""

#. type: Plain text
#: man-pages/man3/stdarg.3:128
msgid ""
"If there is no next argument, or if I<type> is not compatible with the type "
"of the actual next argument (as promoted according to the default argument "
"promotions), random errors will occur."
msgstr ""

#. type: Plain text
#: man-pages/man3/stdarg.3:136
msgid ""
"If I<ap> is passed to a function that uses B<va_arg(>I<ap>B<,>I<type>B<),> "
"then the value of I<ap> is undefined after the return of that function."
msgstr ""

#. type: SS
#: man-pages/man3/stdarg.3:136
#, no-wrap
msgid "va_end()"
msgstr ""

#. type: Plain text
#: man-pages/man3/stdarg.3:155
msgid ""
"Each invocation of B<va_start>()  must be matched by a corresponding "
"invocation of B<va_end>()  in the same function.  After the call "
"B<va_end(>I<ap>B<)> the variable I<ap> is undefined.  Multiple traversals of"
" the list, each bracketed by B<va_start>()  and B<va_end>()  are possible.  "
"B<va_end>()  may be a macro or a function."
msgstr ""

#. type: SS
#: man-pages/man3/stdarg.3:155
#, no-wrap
msgid "va_copy()"
msgstr ""

#. type: Plain text
#: man-pages/man3/stdarg.3:172
msgid ""
"The B<va_copy>()  macro copies the (previously initialized) variable "
"argument list I<src> to I<dest>.  The behavior is as if B<va_start>()  were "
"applied to I<dest> with the same I<last> argument, followed by the same "
"number of B<va_arg>()  invocations that was used to reach the current state "
"of I<src>."
msgstr ""

#.  Proposal from clive@demon.net, 1997-02-28
#. type: Plain text
#: man-pages/man3/stdarg.3:179
msgid ""
"An obvious implementation would have a I<va_list> be a pointer to the stack "
"frame of the variadic function.  In such a setup (by far the most common) "
"there seems nothing against an assignment"
msgstr ""

#. type: Plain text
#: man-pages/man3/stdarg.3:183
#, no-wrap
msgid "va_list aq = ap;\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/stdarg.3:188
msgid ""
"Unfortunately, there are also systems that make it an array of pointers (of "
"length 1), and there one needs"
msgstr ""

#. type: Plain text
#: man-pages/man3/stdarg.3:193
#, no-wrap
msgid ""
"va_list aq;\n"
"*aq = *ap;\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/stdarg.3:209
msgid ""
"Finally, on systems where arguments are passed in registers, it may be "
"necessary for B<va_start>()  to allocate memory, store the arguments there, "
"and also an indication of which argument is next, so that B<va_arg>()  can "
"step through the list.  Now B<va_end>()  can free the allocated memory "
"again.  To accommodate this situation, C99 adds a macro B<va_copy>(), so "
"that the above assignment can be replaced by"
msgstr ""

#. type: Plain text
#: man-pages/man3/stdarg.3:216
#, no-wrap
msgid ""
"va_list aq;\n"
"va_copy(aq, ap);\n"
"\\&...\n"
"va_end(aq);\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/stdarg.3:229
msgid ""
"Each invocation of B<va_copy>()  must be matched by a corresponding "
"invocation of B<va_end>()  in the same function.  Some systems that do not "
"supply B<va_copy>()  have B<__va_copy> instead, since that was the name used"
" in the draft proposal."
msgstr ""

#. type: Plain text
#: man-pages/man3/stdarg.3:238
msgid ""
"The B<va_start>(), B<va_arg>(), B<va_end>(), and B<va_copy>()  macros are "
"thread-safe."
msgstr ""

#. type: Plain text
#: man-pages/man3/stdarg.3:248
msgid ""
"The B<va_start>(), B<va_arg>(), and B<va_end>()  macros conform to C89.  C99"
" defines the B<va_copy>()  macro."
msgstr ""

#. type: Plain text
#: man-pages/man3/stdarg.3:254
msgid ""
"These macros are I<not> compatible with the historic macros they replace.  A"
" backward-compatible version can be found in the include file "
"I<E<lt>varargs.hE<gt>>."
msgstr ""

#. type: Plain text
#: man-pages/man3/stdarg.3:256
msgid "The historic setup is:"
msgstr ""

#. type: Plain text
#: man-pages/man3/stdarg.3:260
#, no-wrap
msgid "#include E<lt>varargs.hE<gt>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/stdarg.3:266
#, no-wrap
msgid ""
"void\n"
"foo(va_alist)\n"
"    va_dcl\n"
"{\n"
"    va_list ap;\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/stdarg.3:275
#, no-wrap
msgid ""
"    va_start(ap);\n"
"    while (...) {\n"
"        ...\n"
"        x = va_arg(ap, type);\n"
"        ...\n"
"    }\n"
"    va_end(ap);\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/stdarg.3:284
msgid ""
"On some systems, I<va_end> contains a closing \\(aq}\\(aq matching a "
"\\(aq{\\(aq in I<va_start>, so that both macros must occur in the same "
"function, and in a way that allows this."
msgstr ""

#. type: Plain text
#: man-pages/man3/stdarg.3:300
msgid ""
"Unlike the B<varargs> macros, the B<stdarg> macros do not permit programmers"
" to code a function with no fixed arguments.  This problem generates work "
"mainly when converting B<varargs> code to B<stdarg> code, but it also "
"creates difficulties for variadic functions that wish to pass all of their "
"arguments on to a function that takes a I<va_list> argument, such as "
"B<vfprintf>(3)."
msgstr ""

#. type: Plain text
#: man-pages/man3/stdarg.3:305
msgid ""
"The function I<foo> takes a string of format characters and prints out the "
"argument associated with each format character based on the type."
msgstr ""

#. type: Plain text
#: man-pages/man3/stdarg.3:309
#, no-wrap
msgid ""
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdarg.hE<gt>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/stdarg.3:316
#, no-wrap
msgid ""
"void\n"
"foo(char *fmt, ...)\n"
"{\n"
"    va_list ap;\n"
"    int d;\n"
"    char c, *s;\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/stdarg.3:337
#, no-wrap
msgid ""
"    va_start(ap, fmt);\n"
"    while (*fmt)\n"
"        switch (*fmt++) {\n"
"        case \\(aqs\\(aq:              /* string */\n"
"            s = va_arg(ap, char *);\n"
"            printf(\"string %s\\en\", s);\n"
"            break;\n"
"        case \\(aqd\\(aq:              /* int */\n"
"            d = va_arg(ap, int);\n"
"            printf(\"int %d\\en\", d);\n"
"            break;\n"
"        case \\(aqc\\(aq:              /* char */\n"
"            /* need a cast here since va_arg only\n"
"               takes fully promoted types */\n"
"            c = (char) va_arg(ap, int);\n"
"            printf(\"char %c\\en\", c);\n"
"            break;\n"
"        }\n"
"    va_end(ap);\n"
"}\n"
msgstr ""

#. type: TH
#: man-pages/man3/strcasecmp.3:30
#, no-wrap
msgid "STRCASECMP"
msgstr "STRCASECMP"

#. type: Plain text
#: man-pages/man3/strcasecmp.3:33
msgid "strcasecmp, strncasecmp - compare two strings ignoring case"
msgstr "strcasecmp, strncasecmp - сравнение двух строк без учёта регистра"

#. type: Plain text
#: man-pages/man3/strcasecmp.3:36
#, no-wrap
msgid "B<#include E<lt>strings.hE<gt>>\n"
msgstr "B<#include E<lt>strings.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/strcasecmp.3:38
#, no-wrap
msgid "B<int strcasecmp(const char *>I<s1>B<, const char *>I<s2>B<);>\n"
msgstr "B<int strcasecmp(const char *>I<s1>B<, const char *>I<s2>B<);>\n"

#. type: Plain text
#: man-pages/man3/strcasecmp.3:40
#, no-wrap
msgid ""
"B<int strncasecmp(const char *>I<s1>B<, const char *>I<s2>B<, size_t "
">I<n>B<);>\n"
msgstr "B<int strncasecmp(const char *>I<s1>B<, const char *>I<s2>B<, size_t >I<n>B<);>\n"

#. type: Plain text
#: man-pages/man3/strcasecmp.3:55
msgid ""
"The B<strcasecmp>()  function compares the two strings I<s1> and I<s2>, "
"ignoring the case of the characters.  It returns an integer less than, equal"
" to, or greater than zero if I<s1> is found, respectively, to be less than, "
"to match, or be greater than I<s2>."
msgstr "Функция B<strcasecmp>() сравнивает строки I<s1> и I<s2>, игнорируя регистр символов. Она возвращает целое число, которое меньше, больше нуля или равно ему, если выяснится, что I<s1> меньше, равна или больше I<s2> соответственно."

#. type: Plain text
#: man-pages/man3/strcasecmp.3:63
msgid ""
"The B<strncasecmp>()  function is similar, except it compares the only first"
" I<n> bytes of I<s1>."
msgstr "Функция B<strncasecmp>() работает аналогичным образом, но сравниваются только первые I<n> байтов строки I<s1>."

#. type: Plain text
#: man-pages/man3/strcasecmp.3:76
msgid ""
"The B<strcasecmp>()  and B<strncasecmp>()  functions return an integer less "
"than, equal to, or greater than zero if I<s1> (or the first I<n> bytes "
"thereof) is found, respectively, to be less than, to match, or be greater "
"than I<s2>."
msgstr "Функции B<strcasecmp>() и B<strncasecmp>() возвращают целое число, которое меньше, больше нуля или равно ему, если строка I<s1> (или её первые I<n> байтов) соответственно меньше, больше или равна I<s2>."

#. type: Plain text
#: man-pages/man3/strcasecmp.3:92
msgid ""
"The B<strcasecmp>()  and B<strncasecmp>()  functions first appeared in "
"4.4BSD, where they were declared in I<E<lt>string.hE<gt>>.  Thus, for "
"reasons of historical compatibility, the glibc I<E<lt>string.hE<gt>> header "
"file also declares these functions, if the B<_DEFAULT_SOURCE> (or, in glibc "
"2.19 and earlier, B<_BSD_SOURCE>)  feature test macro is defined."
msgstr "Впервые, функции B<strcasecmp>() и B<strncasecmp>() появились в 4.4BSD, где они объявлялись в I<E<lt>string.hE<gt>>. Из-за этого, по причине исторической совместимости, в заголовочном файле glibc I<E<lt>string.hE<gt>> также объявлены эти функции, если определён макрос тестирования свойств B<_DEFAULT_SOURCE> (или, в glibc 2.19 и старее, B<_BSD_SOURCE>)."

#. type: Plain text
#: man-pages/man3/strcasecmp.3:100
msgid ""
"B<bcmp>(3), B<memcmp>(3), B<strcmp>(3), B<strcoll>(3), B<string>(3), "
"B<strncmp>(3), B<wcscasecmp>(3), B<wcsncasecmp>(3)"
msgstr "B<bcmp>(3), B<memcmp>(3), B<strcmp>(3), B<strcoll>(3), B<string>(3), B<strncmp>(3), B<wcscasecmp>(3), B<wcsncasecmp>(3)"

#. type: TH
#: man-pages/man3/strtoimax.3:24
#, no-wrap
msgid "STRTOIMAX"
msgstr "STRTOIMAX"

#. type: TH
#: man-pages/man3/strtoimax.3:24
#, no-wrap
msgid "2014-01-22"
msgstr "2014-01-22"

#. type: Plain text
#: man-pages/man3/strtoimax.3:27
msgid "strtoimax, strtoumax - convert string to integer"
msgstr "strtoimax, strtoumax - преобразует строку в integer"

#. type: Plain text
#: man-pages/man3/strtoimax.3:30
#, no-wrap
msgid "B<#include E<lt>inttypes.hE<gt>>\n"
msgstr "B<#include E<lt>inttypes.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/strtoimax.3:32
#, no-wrap
msgid ""
"B<intmax_t strtoimax(const char *>I<nptr>B<, char **>I<endptr>B<, int "
">I<base>B<);>\n"
msgstr "B<intmax_t strtoimax(const char *>I<nptr>B<, char **>I<endptr>B<, int >I<base>B<);>\n"

#. type: Plain text
#: man-pages/man3/strtoimax.3:34
#, no-wrap
msgid ""
"B<uintmax_t strtoumax(const char *>I<nptr>B<, char **>I<endptr>B<, int "
">I<base>B<);>\n"
msgstr "B<uintmax_t strtoumax(const char *>I<nptr>B<, char **>I<endptr>B<, int >I<base>B<);>\n"

#. type: Plain text
#: man-pages/man3/strtoimax.3:45
msgid ""
"These functions are just like B<strtol>(3)  and B<strtoul>(3), except that "
"they return a value of type I<intmax_t> and I<uintmax_t>, respectively."
msgstr ""

#. type: Plain text
#: man-pages/man3/strtoimax.3:58
msgid ""
"On success, the converted value is returned.  If nothing was found to "
"convert, zero is returned.  On overflow or underflow B<INTMAX_MAX> or "
"B<INTMAX_MIN> or B<UINTMAX_MAX> is returned, and I<errno> is set to "
"B<ERANGE>."
msgstr ""

#. type: Plain text
#: man-pages/man3/strtoimax.3:69
msgid ""
"The B<strtoimax>()  and B<strtoumax>()  functions are thread-safe with "
"exceptions.  These functions can be safely used in multithreaded "
"applications, as long as B<setlocale>(3)  is not called to change the locale"
" during their execution."
msgstr ""

#. type: Plain text
#: man-pages/man3/strtoimax.3:71
msgid "C99, POSIX.1-2001."
msgstr "C99, POSIX.1-2001."

#. type: Plain text
#: man-pages/man3/strtoimax.3:76
msgid ""
"B<imaxabs>(3), B<imaxdiv>(3), B<strtol>(3), B<strtoul>(3), B<wcstoimax>(3)"
msgstr "B<imaxabs>(3), B<imaxdiv>(3), B<strtol>(3), B<strtoul>(3), B<wcstoimax>(3)"

#. type: TH
#: man-pages/man3/sysv_signal.3:25
#, no-wrap
msgid "SYSV_SIGNAL"
msgstr "SYSV_SIGNAL"

#. type: TH
#: man-pages/man3/sysv_signal.3:25
#, no-wrap
msgid "2014-01-06"
msgstr "2014-01-06"

#. type: Plain text
#: man-pages/man3/sysv_signal.3:28
msgid "sysv_signal - signal handling with System V semantics"
msgstr ""

#. type: Plain text
#: man-pages/man3/sysv_signal.3:36
msgid ""
"B<sighandler_t sysv_signal(int >I<signum>B<, sighandler_t >I<handler>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man3/sysv_signal.3:41
msgid ""
"The B<sysv_signal>()  function takes the same arguments, and performs the "
"same task, as B<signal>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man3/sysv_signal.3:51
msgid ""
"However B<sysv_signal>()  provides the System V unreliable signal semantics,"
" that is: a) the disposition of the signal is reset to the default when the "
"handler is invoked; b) delivery of further instances of the signal is not "
"blocked while the signal handler is executing; and c) if the handler "
"interrupts (certain) blocking system calls, then the system call is not "
"automatically restarted."
msgstr ""

#. type: Plain text
#: man-pages/man3/sysv_signal.3:57
msgid ""
"The B<sysv_signal>()  function returns the previous value of the signal "
"handler, or B<SIG_ERR> on error."
msgstr ""

#. type: Plain text
#: man-pages/man3/sysv_signal.3:60
msgid "As for B<signal>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man3/sysv_signal.3:65
msgid "The B<sysv_signal>()  function is thread-safe."
msgstr "Функцию B<sysv_signal>() можно использовать в нескольких нитях одновременно."

#. type: Plain text
#: man-pages/man3/sysv_signal.3:67
msgid "This function is nonstandard."
msgstr ""

#. type: Plain text
#: man-pages/man3/sysv_signal.3:73
msgid ""
"Use of B<sysv_signal>()  should be avoided; use B<sigaction>(2)  instead."
msgstr ""

#. type: Plain text
#: man-pages/man3/sysv_signal.3:84
msgid ""
"On older Linux systems, B<sysv_signal>()  and B<signal>(2)  were equivalent."
"  But on newer systems, B<signal>(2)  provides reliable signal semantics; "
"see B<signal>(2)  for details."
msgstr ""

#. type: Plain text
#: man-pages/man3/sysv_signal.3:92
msgid ""
"The use of I<sighandler_t> is a GNU extension; this type is defined only if "
"the B<_GNU_SOURCE> feature test macro is defined."
msgstr ""

#. type: Plain text
#: man-pages/man3/sysv_signal.3:96
msgid "B<sigaction>(2), B<signal>(2), B<bsd_signal>(3), B<signal>(7)"
msgstr "B<sigaction>(2), B<signal>(2), B<bsd_signal>(3), B<signal>(7)"

#. type: TH
#: man-pages/man3/string.3:30
#, no-wrap
msgid "STRING"
msgstr "STRING"

#. type: TH
#: man-pages/man3/string.3:30
#, no-wrap
msgid "2014-01-04"
msgstr "2014-01-04"

#. type: Plain text
#: man-pages/man3/string.3:36
msgid ""
"stpcpy, strcasecmp, strcat, strchr, strcmp, strcoll, strcpy, strcspn, "
"strdup, strfry, strlen, strncat, strncmp, strncpy, strncasecmp, strpbrk, "
"strrchr, strsep, strspn, strstr, strtok, strxfrm, index, rindex - string "
"operations"
msgstr "stpcpy, strcasecmp, strcat, strchr, strcmp, strcoll, strcpy, strcspn, strdup, strfry, strlen, strncat, strncmp, strncpy, strncasecmp, strpbrk, strrchr, strsep, strspn, strstr, strtok, strxfrm, index, rindex - операции со строками"

#. type: Plain text
#: man-pages/man3/string.3:38
msgid "B<#include E<lt>strings.hE<gt>>"
msgstr "B<#include E<lt>strings.hE<gt>>"

#. type: TP
#: man-pages/man3/string.3:38
#, no-wrap
msgid "B<int strcasecmp(const char *>I<s1>B<, const char *>I<s2>B<);>"
msgstr "B<int strcasecmp(const char *>I<s1>B<, const char *>I<s2>B<);>"

#. type: Plain text
#: man-pages/man3/string.3:45
msgid "Compare the strings I<s1> and I<s2> ignoring case."
msgstr "Сравнение строк I<s1> и I<s2> без учета регистра."

#. type: TP
#: man-pages/man3/string.3:45
#, no-wrap
msgid ""
"B<int strncasecmp(const char *>I<s1>B<, const char *>I<s2>B<, size_t "
">I<n>B<);>"
msgstr "B<int strncasecmp(const char *>I<s1>B<, const char *>I<s2>B<, size_t >I<n>B<);>"

#. type: Plain text
#: man-pages/man3/string.3:54
msgid ""
"Compare the first I<n> characters of the strings I<s1> and I<s2> ignoring "
"case."
msgstr "Сравнивает первые I<n> символов строк I<s1> и I<s2> без учета регистра."

#. type: TP
#: man-pages/man3/string.3:54
#, no-wrap
msgid "B<char *index(const char *>I<s>B<, int >I<c>B<);>"
msgstr "B<char *index(const char *>I<s>B<, int >I<c>B<);>"

#. type: Plain text
#: man-pages/man3/string.3:60 man-pages/man3/string.3:90
msgid ""
"Return a pointer to the first occurrence of the character I<c> in the string"
" I<s>."
msgstr ""

#. type: TP
#: man-pages/man3/string.3:60
#, no-wrap
msgid "B<char *rindex(const char *>I<s>B<, int >I<c>B<);>"
msgstr "B<char *rindex(const char *>I<s>B<, int >I<c>B<);>"

#. type: Plain text
#: man-pages/man3/string.3:66 man-pages/man3/string.3:171
msgid ""
"Return a pointer to the last occurrence of the character I<c> in the string "
"I<s>."
msgstr ""

#. type: TP
#: man-pages/man3/string.3:66
#, no-wrap
msgid "B<#include E<lt>string.hE<gt>>"
msgstr "B<#include E<lt>string.hE<gt>>"

#. type: TP
#: man-pages/man3/string.3:68
#, no-wrap
msgid "B<char *stpcpy(char *>I<dest>B<, const char *>I<src>B<);>"
msgstr "B<char *stpcpy(char *>I<dest>B<, const char *>I<src>B<);>"

#. type: Plain text
#: man-pages/man3/string.3:76
msgid ""
"Copy a string from I<src> to I<dest>, returning a pointer to the end of the "
"resulting string at I<dest>."
msgstr ""

#. type: TP
#: man-pages/man3/string.3:76
#, no-wrap
msgid "B<char *strcat(char *>I<dest>B<, const char *>I<src>B<);>"
msgstr "B<char *strcat(char *>I<dest>B<, const char *>I<src>B<);>"

#. type: Plain text
#: man-pages/man3/string.3:84
msgid ""
"Append the string I<src> to the string I<dest>, returning a pointer I<dest>."
msgstr "Добавляет строку I<src> к строке I<dest>, возвращая указатель на I<dest>."

#. type: TP
#: man-pages/man3/string.3:84
#, no-wrap
msgid "B<char *strchr(const char *>I<s>B<, int >I<c>B<);>"
msgstr "B<char *strchr(const char *>I<s>B<, int >I<c>B<);>"

#. type: TP
#: man-pages/man3/string.3:90
#, no-wrap
msgid "B<int strcmp(const char *>I<s1>B<, const char *>I<s2>B<);>"
msgstr "B<int strcmp(const char *>I<s1>B<, const char *>I<s2>B<);>"

#. type: Plain text
#: man-pages/man3/string.3:96
msgid "Compare the strings I<s1> with I<s2>."
msgstr "Сравнивает строки I<s1> и I<s2>."

#. type: TP
#: man-pages/man3/string.3:96
#, no-wrap
msgid "B<int strcoll(const char *>I<s1>B<, const char *>I<s2>B<);>"
msgstr "B<int strcoll(const char *>I<s1>B<, const char *>I<s2>B<);>"

#. type: Plain text
#: man-pages/man3/string.3:103
msgid "Compare the strings I<s1> with I<s2> using the current locale."
msgstr ""

#. type: TP
#: man-pages/man3/string.3:103
#, no-wrap
msgid "B<char *strcpy(char *>I<dest>B<, const char *>I<src>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man3/string.3:111
msgid ""
"Copy the string I<src> to I<dest>, returning a pointer to the start of "
"I<dest>."
msgstr ""

#. type: TP
#: man-pages/man3/string.3:111
#, no-wrap
msgid "B<size_t strcspn(const char *>I<s>B<, const char *>I<reject>B<);>"
msgstr "B<size_t strcspn(const char *>I<s>B<, const char *>I<reject>B<);>"

#. type: Plain text
#: man-pages/man3/string.3:117
msgid ""
"Calculate the length of the initial segment of the string I<s> which does "
"not contain any of bytes in the string I<reject>,"
msgstr ""

#. type: TP
#: man-pages/man3/string.3:117
#, no-wrap
msgid "B<char *strdup(const char *>I<s>B<);>"
msgstr "B<char *strdup(const char *>I<s>B<);>"

#. type: Plain text
#: man-pages/man3/string.3:123
msgid ""
"Return a duplicate of the string I<s> in memory allocated using "
"B<malloc>(3)."
msgstr ""

#. type: TP
#: man-pages/man3/string.3:123
#, no-wrap
msgid "B<char *strfry(char *>I<string>B<);>"
msgstr "B<char *strfry(char *>I<string>B<);>"

#. type: Plain text
#: man-pages/man3/string.3:127
msgid "Randomly swap the characters in I<string>."
msgstr ""

#. type: TP
#: man-pages/man3/string.3:127
#, no-wrap
msgid "B<size_t strlen(const char *>I<s>B<);>"
msgstr "B<size_t strlen(const char *>I<s>B<);>"

#. type: Plain text
#: man-pages/man3/string.3:131
msgid "Return the length of the string I<s>."
msgstr "Возвращает длину строки I<s>."

#. type: TP
#: man-pages/man3/string.3:131
#, no-wrap
msgid ""
"B<char *strncat(char *>I<dest>B<, const char *>I<src>B<, size_t >I<n>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man3/string.3:141
msgid ""
"Append at most I<n> characters from the string I<src> to the string I<dest>,"
" returning a pointer to I<dest>."
msgstr ""

#. type: TP
#: man-pages/man3/string.3:141
#, no-wrap
msgid ""
"B<int strncmp(const char *>I<s1>B<, const char *>I<s2>B<, size_t >I<n>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man3/string.3:149
msgid "Compare at most I<n> bytes of the strings I<s1> and I<s2>."
msgstr ""

#. type: TP
#: man-pages/man3/string.3:149
#, no-wrap
msgid ""
"B<char *strncpy(char *>I<dest>B<, const char *>I<src>B<, size_t >I<n>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man3/string.3:159
msgid ""
"Copy at most I<n> bytes from string I<src> to I<dest>, returning a pointer "
"to the start of I<dest>."
msgstr ""

#. type: TP
#: man-pages/man3/string.3:159
#, no-wrap
msgid "B<char *strpbrk(const char *>I<s>B<, const char *>I<accept>B<);>"
msgstr "B<char *strpbrk(const char *>I<s>B<, const char *>I<accept>B<);>"

#. type: Plain text
#: man-pages/man3/string.3:165
msgid ""
"Return a pointer to the first occurrence in the string I<s> of one of the "
"bytes in the string I<accept>."
msgstr ""

#. type: TP
#: man-pages/man3/string.3:165
#, no-wrap
msgid "B<char *strrchr(const char *>I<s>B<, int >I<c>B<);>"
msgstr "B<char *strrchr(const char *>I<s>B<, int >I<c>B<);>"

#. type: TP
#: man-pages/man3/string.3:171
#, no-wrap
msgid "B<char *strsep(char **>I<stringp>B<, const char *>I<delim>B<);>"
msgstr "B<char *strsep(char **>I<stringp>B<, const char *>I<delim>B<);>"

#. type: Plain text
#: man-pages/man3/string.3:177
msgid ""
"Extract the initial token in I<stringp> that is delimited by one of the "
"bytes in I<delim>."
msgstr ""

#. type: TP
#: man-pages/man3/string.3:177
#, no-wrap
msgid "B<size_t strspn(const char *>I<s>B<, const char *>I<accept>B<);>"
msgstr "B<size_t strspn(const char *>I<s>B<, const char *>I<accept>B<);>"

#. type: Plain text
#: man-pages/man3/string.3:183
msgid ""
"Calculate the length of the starting segment in the string I<s> that "
"consists entirely of bytes in I<accept>."
msgstr ""

#. type: TP
#: man-pages/man3/string.3:183
#, no-wrap
msgid "B<char *strstr(const char *>I<haystack>B<, const char *>I<needle>B<);>"
msgstr "B<char *strstr(const char *>I<haystack>B<, const char *>I<needle>B<);>"

#. type: Plain text
#: man-pages/man3/string.3:190
msgid ""
"Find the first occurrence of the substring I<needle> in the string "
"I<haystack>, returning a pointer to the found substring."
msgstr ""

#. type: TP
#: man-pages/man3/string.3:190
#, no-wrap
msgid "B<char *strtok(char *>I<s>B<, const char *>I<delim>B<);>"
msgstr "B<char *strtok(char *>I<s>B<, const char *>I<delim>B<);>"

#. type: Plain text
#: man-pages/man3/string.3:196
msgid ""
"Extract tokens from the string I<s> that are delimited by one of the bytes "
"in I<delim>."
msgstr ""

#. type: TP
#: man-pages/man3/string.3:196
#, no-wrap
msgid ""
"B<size_t strxfrm(char *>I<dest>B<, const char *>I<src>B<, size_t >I<n>B<);>"
msgstr "B<size_t strxfrm(char *>I<dest>B<, const char *>I<src>B<, size_t >I<n>B<);>"

#. type: Plain text
#: man-pages/man3/string.3:204
msgid ""
"Transforms I<src> to the current locale and copies the first I<n> characters"
" to I<dest>."
msgstr ""

#. type: Plain text
#: man-pages/man3/string.3:208
msgid ""
"The string functions perform string operations on null-terminated strings.  "
"See the individual man pages for descriptions of each function."
msgstr "Данные функции предназначены для работы со строками, заканчивающимися null. Подробное описание функций смотрите в соответствующей справочной странице."

#. type: Plain text
#: man-pages/man3/string.3:232
msgid ""
"B<index>(3), B<rindex>(3), B<stpcpy>(3), B<strcasecmp>(3), B<strcat>(3), "
"B<strchr>(3), B<strcmp>(3), B<strcoll>(3), B<strcpy>(3), B<strcspn>(3), "
"B<strdup>(3), B<strfry>(3), B<strlen>(3), B<strncasecmp>(3), B<strncat>(3), "
"B<strncmp>(3), B<strncpy>(3), B<strpbrk>(3), B<strrchr>(3), B<strsep>(3), "
"B<strspn>(3), B<strstr>(3), B<strtok>(3), B<strxfrm>(3)"
msgstr "B<index>(3), B<rindex>(3), B<stpcpy>(3), B<strcasecmp>(3), B<strcat>(3), B<strchr>(3), B<strcmp>(3), B<strcoll>(3), B<strcpy>(3), B<strcspn>(3), B<strdup>(3), B<strfry>(3), B<strlen>(3), B<strncasecmp>(3), B<strncat>(3), B<strncmp>(3), B<strncpy>(3), B<strpbrk>(3), B<strrchr>(3), B<strsep>(3), B<strspn>(3), B<strstr>(3), B<strtok>(3), B<strxfrm>(3)"

#. type: TH
#: man-pages/man3/strnlen.3:13
#, no-wrap
msgid "STRNLEN"
msgstr "STRNLEN"

#. type: Plain text
#: man-pages/man3/strnlen.3:16
msgid "strnlen - determine the length of a fixed-size string"
msgstr "strnlen - вычисление длины строки постоянного размера"

#. type: Plain text
#: man-pages/man3/strnlen.3:21
#, no-wrap
msgid "B<size_t strnlen(const char *>I<s>B<, size_t >I<maxlen>B<);>\n"
msgstr "B<size_t strnlen(const char *>I<s>B<, size_t >I<maxlen>B<);>\n"

#. type: Plain text
#: man-pages/man3/strnlen.3:29
msgid "B<strnlen>():"
msgstr "B<strnlen>():"

#. type: Plain text
#: man-pages/man3/strnlen.3:58
msgid ""
"The B<strnlen>()  function returns the number of bytes in the string pointed"
" to by I<s>, excluding the terminating null byte (\\(aq\\e0\\(aq), but at "
"most I<maxlen>.  In doing this, B<strnlen>()  looks only at the first "
"I<maxlen> bytes at I<s> and never beyond I<s+maxlen>."
msgstr "Функция B<strnlen>() возвращает количество байт в строке, на которую указывает I<s>, не считая завершающего байта null (\\(aq\\e0\\(aq), но не более I<maxlen>. При этом B<strnlen>() обращается только к I<maxlen> байтам I<s> и никогда не выходит дальше I<s+maxlen>."

#. type: Plain text
#: man-pages/man3/strnlen.3:71
msgid ""
"The B<strnlen>()  function returns I<strlen(s)>, if that is less than "
"I<maxlen>, or I<maxlen> if there is no null byte (\\(aq\\e0\\(aq) among the "
"first I<maxlen> bytes pointed to by I<s>."
msgstr "Функция B<strnlen>() возвращает I<strlen(s)>, если оно меньше I<maxlen>, или I<maxlen>, если среди первых I<maxlen> байт, на которую указывает I<s>, не встретился байт null (\\(aq\\e0\\(aq)."

#. type: Plain text
#: man-pages/man3/strnlen.3:76
msgid "The B<strnlen>()  function is thread-safe."
msgstr "Функцию B<strnlen>() можно использовать в нескольких нитях одновременно."

#. type: Plain text
#: man-pages/man3/strnlen.3:78
msgid "POSIX.1-2008."
msgstr "POSIX.1-2008."

#. type: Plain text
#: man-pages/man3/strnlen.3:79
msgid "B<strlen>(3)"
msgstr "B<strlen>(3)"

#. type: TH
#: man-pages/man3/setenv.3:37
#, no-wrap
msgid "SETENV"
msgstr "SETENV"

#. type: TH
#: man-pages/man3/setenv.3:37
#, no-wrap
msgid "2013-10-11"
msgstr "2013-10-11"

#. type: Plain text
#: man-pages/man3/setenv.3:40
msgid "setenv - change or add an environment variable"
msgstr ""

#. type: Plain text
#: man-pages/man3/setenv.3:45
#, no-wrap
msgid ""
"B<int setenv(const char *>I<name>B<, const char *>I<value>B<, int "
">I<overwrite>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/setenv.3:47
#, no-wrap
msgid "B<int unsetenv(const char *>I<name>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/setenv.3:57
msgid "B<setenv>(), B<unsetenv>():"
msgstr ""

#. type: Plain text
#: man-pages/man3/setenv.3:94
msgid ""
"The B<setenv>()  function adds the variable I<name> to the environment with "
"the value I<value>, if I<name> does not already exist.  If I<name> does "
"exist in the environment, then its value is changed to I<value> if "
"I<overwrite> is nonzero; if I<overwrite> is zero, then the value of I<name> "
"is not changed (and B<setenv>()  returns a success status).  This function "
"makes copies of the strings pointed to by I<name> and I<value> (by contrast "
"with B<putenv>(3))."
msgstr ""

#. type: Plain text
#: man-pages/man3/setenv.3:105
msgid ""
"The B<unsetenv>()  function deletes the variable I<name> from the "
"environment.  If I<name> does not exist in the environment, then the "
"function succeeds, and the environment is unchanged."
msgstr ""

#. type: Plain text
#: man-pages/man3/setenv.3:112
msgid ""
"The B<setenv>()  function returns zero on success, or -1 on error, with "
"I<errno> set to indicate the cause of the error."
msgstr ""

#. type: Plain text
#: man-pages/man3/setenv.3:119
msgid ""
"The B<unsetenv>()  function returns zero on success, or -1 on error, with "
"I<errno> set to indicate the cause of the error."
msgstr ""

#. type: Plain text
#: man-pages/man3/setenv.3:125
msgid ""
"I<name> is NULL, points to a string of length 0, or contains an \\(aq=\\(aq "
"character."
msgstr ""

#. type: Plain text
#: man-pages/man3/setenv.3:128
msgid "Insufficient memory to add a new variable to the environment."
msgstr ""

#. type: Plain text
#: man-pages/man3/setenv.3:136
msgid ""
"POSIX.1-2001 does not require B<setenv>()  or B<unsetenv>()  to be "
"reentrant."
msgstr ""

#. type: Plain text
#: man-pages/man3/setenv.3:144
msgid ""
"Prior to glibc 2.2.2, B<unsetenv>()  was prototyped as returning I<void>; "
"more recent glibc versions follow the POSIX.1-2001-compliant prototype shown"
" in the SYNOPSIS."
msgstr ""

#. type: Plain text
#: man-pages/man3/setenv.3:153
msgid ""
"POSIX.1-2001 specifies that if I<name> contains an \\(aq=\\(aq character, "
"then B<setenv>()  should fail with the error B<EINVAL>; however, versions of"
" glibc before 2.3.4 allowed an \\(aq=\\(aq sign in I<name>."
msgstr ""

#. type: Plain text
#: man-pages/man3/setenv.3:157
msgid "B<clearenv>(3), B<getenv>(3), B<putenv>(3), B<environ>(7)"
msgstr "B<clearenv>(3), B<getenv>(3), B<putenv>(3), B<environ>(7)"

#. type: TH
#: man-pages/man3/scandir.3:62
#, no-wrap
msgid "SCANDIR"
msgstr "SCANDIR"

#. type: Plain text
#: man-pages/man3/scandir.3:66
msgid ""
"scandir, scandirat, alphasort, versionsort - scan a directory for matching "
"entries"
msgstr ""

#. type: Plain text
#: man-pages/man3/scandir.3:69
#, no-wrap
msgid "B<#include E<lt>dirent.hE<gt>>\n"
msgstr "B<#include E<lt>dirent.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/scandir.3:71
#, no-wrap
msgid ""
"B<int scandir(const char *>I<dirp>B<, struct dirent ***>I<namelist>B<,>\n"
msgstr "B<int scandir(const char *>I<dirp>B<, struct dirent ***>I<namelist>B<,>\n"

#. type: Plain text
#: man-pages/man3/scandir.3:74 man-pages/man3/scandir.3:90
#, no-wrap
msgid ""
"B<int (*>I<filter>B<)(const struct dirent *),>\n"
"B<int (*>I<compar>B<)(const struct dirent **, const struct dirent **));>\n"
msgstr "B<int (*>I<filter>B<)(const struct dirent *),>\nB<int (*>I<compar>B<)(const struct dirent **, const struct dirent **));>\n"

#. type: Plain text
#: man-pages/man3/scandir.3:77
#, no-wrap
msgid ""
"B<int alphasort(const struct dirent **>I<a>B<, const struct dirent "
"**>I<b>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/scandir.3:79
#, no-wrap
msgid ""
"B<int versionsort(const struct dirent **>I<a>B<, const struct dirent "
"**>I<b>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/scandir.3:82
#, no-wrap
msgid ""
"B<#include E<lt>fcntl.hE<gt>>          /* Definition of AT_* constants */\n"
"B<#include E<lt>dirent.hE<gt>>\n"
msgstr "B<#include E<lt>fcntl.hE<gt>>          /* определения констант AT_* */\nB<#include E<lt>dirent.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/scandir.3:86
msgid ""
"B<int scandirat(int >I<dirfd>B<, const char *>I<dirp>B<,> B<struct dirent "
"***>I<namelist>B<,>"
msgstr "B<int scandirat(int >I<dirfd>B<, const char *>I<dirp>B<,> B<struct dirent ***>I<namelist>B<,>"

#. type: Plain text
#: man-pages/man3/scandir.3:100
msgid "B<scandir>(), B<alphasort>():"
msgstr "B<scandir>(), B<alphasort>():"

#. type: Plain text
#: man-pages/man3/scandir.3:105
msgid "_BSD_SOURCE || _SVID_SOURCE"
msgstr "_BSD_SOURCE || _SVID_SOURCE"

#. type: Plain text
#: man-pages/man3/scandir.3:107
msgid "|| /* Since glibc 2.10: */"
msgstr ""

#. type: Plain text
#: man-pages/man3/scandir.3:109
msgid "(_POSIX_C_SOURCE\\ E<gt>=\\ 200809L || _XOPEN_SOURCE\\ E<gt>=\\ 700)"
msgstr ""

#. type: Plain text
#: man-pages/man3/scandir.3:115
msgid "B<versionsort>(): _GNU_SOURCE"
msgstr "B<versionsort>(): _GNU_SOURCE"

#. type: Plain text
#: man-pages/man3/scandir.3:118
msgid "B<scandirat>(): _GNU_SOURCE"
msgstr ""

#. type: Plain text
#: man-pages/man3/scandir.3:133
msgid ""
"The B<scandir>()  function scans the directory I<dirp>, calling I<filter>() "
"on each directory entry.  Entries for which I<filter>() returns nonzero are "
"stored in strings allocated via B<malloc>(3), sorted using B<qsort>(3)  with"
" the comparison function I<compar>(), and collected in array I<namelist> "
"which is allocated via B<malloc>(3).  If I<filter> is NULL, all entries are "
"selected."
msgstr ""

#. type: Plain text
#: man-pages/man3/scandir.3:145
msgid ""
"The B<alphasort>()  and B<versionsort>()  functions can be used as the "
"comparison function I<compar>().  The former sorts directory entries using "
"B<strcoll>(3), the latter using B<strverscmp>(3)  on the strings "
"I<(*a)-E<gt>d_name> and I<(*b)-E<gt>d_name>."
msgstr ""

#. type: SS
#: man-pages/man3/scandir.3:145
#, no-wrap
msgid "scandirat()"
msgstr ""

#. type: Plain text
#: man-pages/man3/scandir.3:151
msgid ""
"The B<scandirat>()  function operates in exactly the same way as "
"B<scandir>(), except for the differences described here."
msgstr "Системный вызов B<scandirat>() работает также как системный вызов B<scandir>(), за исключением случаев, описанных здесь."

#. type: Plain text
#: man-pages/man3/scandir.3:161
msgid ""
"If the pathname given in I<dirp> is relative, then it is interpreted "
"relative to the directory referred to by the file descriptor I<dirfd> "
"(rather than relative to the current working directory of the calling "
"process, as is done by B<scandir>()  for a relative pathname)."
msgstr ""

#. type: Plain text
#: man-pages/man3/scandir.3:173
msgid ""
"If I<dirp> is relative and I<dirfd> is the special value B<AT_FDCWD>, then "
"I<dirp> is interpreted relative to the current working directory of the "
"calling process (like B<scandir>())."
msgstr ""

#. type: Plain text
#: man-pages/man3/scandir.3:179
msgid "If I<dirp> is absolute, then I<dirfd> is ignored."
msgstr "Если в I<dirp> задан абсолютный путь, то I<dirfd> игнорируется."

#. type: Plain text
#: man-pages/man3/scandir.3:184
msgid "See B<openat>(2)  for an explanation of the need for B<scandirat>()."
msgstr "Смотрите в B<openat>(2) объяснение необходимости B<scandirat>()."

#. type: Plain text
#: man-pages/man3/scandir.3:192
msgid ""
"The B<scandir>()  function returns the number of directory entries selected."
"  On error, -1 is returned, with I<errno> set to indicate the cause of the "
"error."
msgstr ""

#. type: Plain text
#: man-pages/man3/scandir.3:200
msgid ""
"The B<alphasort>()  and B<versionsort>()  functions return an integer less "
"than, equal to, or greater than zero if the first argument is considered to "
"be respectively less than, equal to, or greater than the second."
msgstr ""

#. type: Plain text
#: man-pages/man3/scandir.3:204
msgid "The path in I<dirp> does not exist."
msgstr ""

#. type: Plain text
#: man-pages/man3/scandir.3:207
msgid "Insufficient memory to complete the operation."
msgstr ""

#. type: Plain text
#: man-pages/man3/scandir.3:210
msgid "The path in I<dirp> is not a directory."
msgstr ""

#. type: Plain text
#: man-pages/man3/scandir.3:213
msgid "The following additional errors can occur for B<scandirat>():"
msgstr ""

#. type: Plain text
#: man-pages/man3/scandir.3:223
msgid ""
"I<dirp> is a relative path and I<dirfd> is a file descriptor referring to a "
"file other than a directory."
msgstr "Значение I<dirp> содержит относительный путь и I<dirfd> содержит файловый дескриптор, указывающий на файл, а не на каталог."

#. type: Plain text
#: man-pages/man3/scandir.3:226
msgid "B<versionsort>()  was added to glibc in version 2.1."
msgstr ""

#. type: Plain text
#: man-pages/man3/scandir.3:229
msgid "B<scandirat>()  was added to glibc in version 2.15."
msgstr "Функция B<scandirat>() впервые появилась в glibc 2.15."

#. type: Plain text
#: man-pages/man3/scandir.3:233
msgid "B<alphasort>(), B<scandir>(): 4.3BSD, POSIX.1-2008."
msgstr "B<alphasort>(), B<scandir>(): 4.3BSD, POSIX.1-2008."

#.  .LP
#.  The functions
#.  .BR scandir ()
#.  and
#.  .BR alphasort ()
#.  are from 4.3BSD, and have been available under Linux since libc4.
#.  Libc4 and libc5 use the more precise prototype
#.  .sp
#.  .nf
#.     int alphasort(const struct dirent ** a,
#.                   const struct dirent **b);
#.  .fi
#.  .sp
#.  but glibc 2.0 returns to the imprecise BSD prototype.
#. type: Plain text
#: man-pages/man3/scandir.3:252
msgid "B<versionsort>()  and B<scandirat>()  are GNU extensions."
msgstr ""

#. type: Plain text
#: man-pages/man3/scandir.3:259
msgid ""
"Since glibc 2.1, B<alphasort>()  calls B<strcoll>(3); earlier it used "
"B<strcmp>(3)."
msgstr ""

#. type: Plain text
#: man-pages/man3/scandir.3:264
#, no-wrap
msgid ""
"#define _SVID_SOURCE\n"
"/* print files in current directory in reverse order */\n"
"#include E<lt>dirent.hE<gt>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/scandir.3:270
#, no-wrap
msgid ""
"int\n"
"main(void)\n"
"{\n"
"    struct dirent **namelist;\n"
"    int n;\n"
msgstr "int\nmain(void)\n{\n    struct dirent **namelist;\n    int n;\n"

#. type: Plain text
#: man-pages/man3/scandir.3:282
#, no-wrap
msgid ""
"    n = scandir(\".\", &namelist, NULL, alphasort);\n"
"    if (n E<lt> 0)\n"
"        perror(\"scandir\");\n"
"    else {\n"
"        while (n--) {\n"
"            printf(\"%s\\en\", namelist[n]-E<gt>d_name);\n"
"            free(namelist[n]);\n"
"        }\n"
"        free(namelist);\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/scandir.3:293
msgid ""
"B<closedir>(3), B<fnmatch>(3), B<opendir>(3), B<readdir>(3), "
"B<rewinddir>(3), B<seekdir>(3), B<strcmp>(3), B<strcoll>(3), "
"B<strverscmp>(3), B<telldir>(3)"
msgstr ""

#. type: TH
#: man-pages/man3/siginterrupt.3:31
#, no-wrap
msgid "SIGINTERRUPT"
msgstr "SIGINTERRUPT"

#. type: Plain text
#: man-pages/man3/siginterrupt.3:34
msgid "siginterrupt - allow signals to interrupt system calls"
msgstr ""

#. type: Plain text
#: man-pages/man3/siginterrupt.3:39
#, no-wrap
msgid "B<int siginterrupt(int >I<sig>B<, int >I<flag>B<);>\n"
msgstr "B<int siginterrupt(int >I<sig>B<, int >I<flag>B<);>\n"

#. type: Plain text
#: man-pages/man3/siginterrupt.3:47
msgid "B<siginterrupt>():"
msgstr "B<siginterrupt>():"

#. type: Plain text
#: man-pages/man3/siginterrupt.3:64
msgid ""
"The B<siginterrupt>()  function changes the restart behavior when a system "
"call is interrupted by the signal I<sig>.  If the I<flag> argument is false "
"(0), then system calls will be restarted if interrupted by the specified "
"signal I<sig>.  This is the default behavior in Linux."
msgstr ""

#. type: Plain text
#: man-pages/man3/siginterrupt.3:69
msgid ""
"If the I<flag> argument is true (1) and no data has been transferred, then a"
" system call interrupted by the signal I<sig> will return -1 and I<errno> "
"will be set to B<EINTR>."
msgstr ""

#. type: Plain text
#: man-pages/man3/siginterrupt.3:73
msgid ""
"If the I<flag> argument is true (1) and data transfer has started, then the "
"system call will be interrupted and will return the actual amount of data "
"transferred."
msgstr ""

#. type: Plain text
#: man-pages/man3/siginterrupt.3:83
msgid ""
"The B<siginterrupt>()  function returns 0 on success.  It returns -1 if the "
"signal number I<sig> is invalid, with I<errno> set to indicate the cause of "
"the error."
msgstr ""

#. type: Plain text
#: man-pages/man3/siginterrupt.3:87
msgid "The specified signal number is invalid."
msgstr ""

#. type: Plain text
#: man-pages/man3/siginterrupt.3:93
msgid ""
"The B<siginterrupt>()  function uses a global variable that is not "
"protected, so it is not thread-safe."
msgstr ""

#. type: Plain text
#: man-pages/man3/siginterrupt.3:102
msgid ""
"4.3BSD, POSIX.1-2001.  POSIX.1-2008 marks B<siginterrupt>()  as obsolete, "
"recommending the use of B<sigaction>(2)  with the B<SA_RESTART> flag "
"instead."
msgstr ""

#. type: Plain text
#: man-pages/man3/siginterrupt.3:103
msgid "B<signal>(2)"
msgstr "B<signal>(2)"

#. type: TH
#: man-pages/man3/statvfs.3:30
#, no-wrap
msgid "STATVFS"
msgstr "STATVFS"

#. type: TH
#: man-pages/man3/statvfs.3:30
#, no-wrap
msgid "2013-09-26"
msgstr "2013-09-26"

#. type: Plain text
#: man-pages/man3/statvfs.3:33
msgid "statvfs, fstatvfs - get filesystem statistics"
msgstr "statvfs, fstatvfs - получение статистики по файловой системе"

#. type: Plain text
#: man-pages/man3/statvfs.3:35
msgid "B<#include E<lt>sys/statvfs.hE<gt>>"
msgstr "B<#include E<lt>sys/statvfs.hE<gt>>"

#. type: Plain text
#: man-pages/man3/statvfs.3:37
msgid "B<int statvfs(const char *>I<path>B<, struct statvfs *>I<buf>B<);>"
msgstr "B<int statvfs(const char *>I<path>B<, struct statvfs *>I<buf>B<);>"

#. type: Plain text
#: man-pages/man3/statvfs.3:39
msgid "B<int fstatvfs(int >I<fd>B<, struct statvfs *>I<buf>B<);>"
msgstr "B<int fstatvfs(int >I<fd>B<, struct statvfs *>I<buf>B<);>"

#. type: Plain text
#: man-pages/man3/statvfs.3:49
msgid ""
"The function B<statvfs>()  returns information about a mounted filesystem.  "
"I<path> is the pathname of any file within the mounted filesystem.  I<buf> "
"is a pointer to a I<statvfs> structure defined approximately as follows:"
msgstr "Функция B<statvfs>() возвращает информацию о смонтированной файловой системе. I<path> является путём любого файла, расположенного в смонтированной файловой системе. I<buf> является указателем на структуру I<statvfs>, определённую примерно следующим образом:"

#. type: Plain text
#: man-pages/man3/statvfs.3:65
#, no-wrap
msgid ""
"struct statvfs {\n"
"    unsigned long  f_bsize;    /* filesystem block size */\n"
"    unsigned long  f_frsize;   /* fragment size */\n"
"    fsblkcnt_t     f_blocks;   /* size of fs in f_frsize units */\n"
"    fsblkcnt_t     f_bfree;    /* # free blocks */\n"
"    fsblkcnt_t     f_bavail;   /* # free blocks for unprivileged users */\n"
"    fsfilcnt_t     f_files;    /* # inodes */\n"
"    fsfilcnt_t     f_ffree;    /* # free inodes */\n"
"    fsfilcnt_t     f_favail;   /* # free inodes for unprivileged users */\n"
"    unsigned long  f_fsid;     /* filesystem ID */\n"
"    unsigned long  f_flag;     /* mount flags */\n"
"    unsigned long  f_namemax;  /* maximum filename length */\n"
"};\n"
msgstr "struct statvfs {\n    unsigned long  f_bsize;    /* размер блока файловой системы */\n    unsigned long  f_frsize;   /* размер фрагмента */\n    fsblkcnt_t     f_blocks;   /* размер ФС в единицах f_frsize */\n    fsblkcnt_t     f_bfree;    /* количество свободных блоков */\n    fsblkcnt_t     f_bavail;   /* количество свободных блоков \n                                  для непривилегированных пользователей */\n    fsfilcnt_t     f_files;    /* количество inodes */\n    fsfilcnt_t     f_ffree;    /* количество свободных inodes */\n    fsfilcnt_t     f_favail;   /* количество свободных inodes для \n                                  непривилегированных пользователей */\n    unsigned long  f_fsid;     /* идентификатор файловой системы */\n    unsigned long  f_flag;     /* параметры монтирования */\n    unsigned long  f_namemax;  /* максимальная длина имени файла */\n};\n"

#. type: Plain text
#: man-pages/man3/statvfs.3:76
msgid ""
"Here the types I<fsblkcnt_t> and I<fsfilcnt_t> are defined in "
"I<E<lt>sys/types.hE<gt>>.  Both used to be I<unsigned long>."
msgstr "Типы I<fsblkcnt_t> и I<fsfilcnt_t> определены в файле I<E<lt>sys/types.hE<gt>>. Для их определения используется тип I<unsigned long>."

#. type: Plain text
#: man-pages/man3/statvfs.3:82
msgid ""
"The field I<f_flag> is a bit mask (of mount flags, see B<mount>(8)).  Bits "
"defined by POSIX are"
msgstr "Поле I<f_flag> является битовой маской (из параметров монтирования, см. B<mount>(8)). Биты определены, согласно POSIX, следующим образом:"

#. type: TP
#: man-pages/man3/statvfs.3:82
#, no-wrap
msgid "B<ST_RDONLY>"
msgstr "B<ST_RDONLY>"

#. type: Plain text
#: man-pages/man3/statvfs.3:85
msgid "Read-only filesystem."
msgstr "Файловая система, доступная только для чтения."

#. type: TP
#: man-pages/man3/statvfs.3:85
#, no-wrap
msgid "B<ST_NOSUID>"
msgstr "B<ST_NOSUID>"

#. type: Plain text
#: man-pages/man3/statvfs.3:89
msgid "Set-user-ID/set-group-ID bits are ignored by B<exec>(3)."
msgstr "Биты Set-user-ID/set-group-ID игнорируются для B<exec>(3)."

#. type: Plain text
#: man-pages/man3/statvfs.3:92
msgid ""
"It is unspecified whether all members of the returned struct have meaningful"
" values on all filesystems."
msgstr "Не указывается, будут ли при любых файловых системах членам возвращаемой структуры присвоены осмысленные данные."

#. type: Plain text
#: man-pages/man3/statvfs.3:96
msgid ""
"B<fstatvfs>()  returns the same information about an open file referenced by"
" descriptor I<fd>."
msgstr "B<fstatvfs>() возвращает такую же информацию об открытом файле через его ссылку на дескриптор I<fd>."

#. type: Plain text
#: man-pages/man3/statvfs.3:109
msgid ""
"(B<statvfs>())  Search permission is denied for a component of the path "
"prefix of I<path>.  (See also B<path_resolution>(7).)"
msgstr "(B<statvfs>()) Нет права на поиск одного из компонентов префикса пути I<path> (см. также B<path_resolution>(7))."

#. type: Plain text
#: man-pages/man3/statvfs.3:114
msgid "(B<fstatvfs>())  I<fd> is not a valid open file descriptor."
msgstr "(B<fstatvfs>()) I<fd> не является корректным открытым дескриптором файла."

#. type: Plain text
#: man-pages/man3/statvfs.3:120
msgid "I<Buf> or I<path> points to an invalid address."
msgstr "I<Buf> или I<path> указывает на неправильный адрес."

#. type: Plain text
#: man-pages/man3/statvfs.3:131
msgid ""
"(B<statvfs>())  Too many symbolic links were encountered in translating "
"I<path>."
msgstr "(B<statvfs>()) Было обнаружено слишком много символьных ссылок при трансляции I<path>."

#. type: Plain text
#: man-pages/man3/statvfs.3:136
msgid "(B<statvfs>())  I<path> is too long."
msgstr "(B<statvfs>()) Слишком длинное значение аргумента I<path>."

#. type: Plain text
#: man-pages/man3/statvfs.3:142
msgid "(B<statvfs>())  The file referred to by I<path> does not exist."
msgstr "(B<statvfs>()) Файл, указанный в I<path>, не существует."

#. type: Plain text
#: man-pages/man3/statvfs.3:154
msgid ""
"(B<statvfs>())  A component of the path prefix of I<path> is not a "
"directory."
msgstr "(B<statvfs>()) Один из компонентов префикса пути I<path> не является каталогом."

#. type: Plain text
#: man-pages/man3/statvfs.3:164
msgid "The B<statvfs>()  and B<fstatvfs>()  functions are thread-safe."
msgstr "Функции B<statvfs>() и B<fstatvfs>() можно использовать в нескольких нитях одновременно."

#. type: Plain text
#: man-pages/man3/statvfs.3:172
msgid ""
"The Linux kernel has system calls B<statfs>(2)  and B<fstatfs>(2)  to "
"support this library call."
msgstr "Для поддержки данной библиотечной функции в ядре Linux есть системные вызовы B<statfs>(2) и B<fstatfs>(2)."

#. type: Plain text
#: man-pages/man3/statvfs.3:174
msgid "The current glibc implementations of"
msgstr "Текущие реализации glibc функций"

#. type: Plain text
#: man-pages/man3/statvfs.3:179
#, no-wrap
msgid ""
"   pathconf(path, _PC_REC_XFER_ALIGN);\n"
"   pathconf(path, _PC_ALLOC_SIZE_MIN);\n"
"   pathconf(path, _PC_REC_MIN_XFER_SIZE);\n"
msgstr "   pathconf(path, _PC_REC_XFER_ALIGN);\n   pathconf(path, _PC_ALLOC_SIZE_MIN);\n   pathconf(path, _PC_REC_MIN_XFER_SIZE);\n"

#. type: Plain text
#: man-pages/man3/statvfs.3:188
msgid ""
"respectively use the I<f_frsize>, I<f_frsize>, and I<f_bsize> fields of the "
"return value of I<statvfs(path,buf)>."
msgstr "используют, соответственно, поля I<f_frsize>, I<f_frsize> и I<f_bsize> из возвращаемого значения I<statvfs(path,buf)>."

#. type: Plain text
#: man-pages/man3/statvfs.3:189
msgid "B<statfs>(2)"
msgstr "B<statfs>(2)"

#. type: TH
#: man-pages/man3/scanf.3:52
#, no-wrap
msgid "SCANF"
msgstr "SCANF"

#. type: TH
#: man-pages/man3/scanf.3:52
#, no-wrap
msgid "2014-01-11"
msgstr "2014-01-11"

#. type: Plain text
#: man-pages/man3/scanf.3:55
msgid ""
"scanf, fscanf, sscanf, vscanf, vsscanf, vfscanf - input format conversion"
msgstr ""

#. type: Plain text
#: man-pages/man3/scanf.3:62
#, no-wrap
msgid ""
"B<int scanf(const char *>I<format>B<, ...);>\n"
"B<int fscanf(FILE *>I<stream>B<, const char *>I<format>B<, ...);>\n"
"B<int sscanf(const char *>I<str>B<, const char *>I<format>B<, ...);>\n"
msgstr "B<int scanf(const char *>I<format>B<, ...);>\nB<int fscanf(FILE *>I<stream>B<, const char *>I<format>B<, ...);>\nB<int sscanf(const char *>I<str>B<, const char *>I<format>B<, ...);>\n"

#. type: Plain text
#: man-pages/man3/scanf.3:64
#, no-wrap
msgid "B<#include E<lt>stdarg.hE<gt>>\n"
msgstr "B<#include E<lt>stdarg.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/scanf.3:68
#, no-wrap
msgid ""
"B<int vscanf(const char *>I<format>B<, va_list >I<ap>B<);>\n"
"B<int vsscanf(const char *>I<str>B<, const char *>I<format>B<, va_list >I<ap>B<);>\n"
"B<int vfscanf(FILE *>I<stream>B<, const char *>I<format>B<, va_list >I<ap>B<);>\n"
msgstr "B<int vscanf(const char *>I<format>B<, va_list >I<ap>B<);>\nB<int vsscanf(const char *>I<str>B<, const char *>I<format>B<, va_list >I<ap>B<);>\nB<int vfscanf(FILE *>I<stream>B<, const char *>I<format>B<, va_list >I<ap>B<);>\n"

#. type: Plain text
#: man-pages/man3/scanf.3:79
msgid "B<vscanf>(), B<vsscanf>(), B<vfscanf>():"
msgstr "B<vscanf>(), B<vsscanf>(), B<vfscanf>():"

#. type: Plain text
#: man-pages/man3/scanf.3:82
msgid ""
"_XOPEN_SOURCE\\ E<gt>=\\ 600 || _ISOC99_SOURCE || _POSIX_C_SOURCE\\ E<gt>=\\"
" 200112L;"
msgstr "_XOPEN_SOURCE\\ E<gt>=\\ 600 || _ISOC99_SOURCE || _POSIX_C_SOURCE\\ E<gt>=\\ 200112L;"

#. type: Plain text
#: man-pages/man3/scanf.3:85
msgid "or I<cc -std=c99>"
msgstr "или I<cc -std=c99>"

#. type: Plain text
#: man-pages/man3/scanf.3:104
msgid ""
"The B<scanf>()  family of functions scans input according to I<format> as "
"described below.  This format may contain I<conversion specifications>; the "
"results from such conversions, if any, are stored in the locations pointed "
"to by the I<pointer> arguments that follow I<format>.  Each I<pointer> "
"argument must be of a type that is appropriate for the value returned by the"
" corresponding conversion specification."
msgstr ""

#. type: Plain text
#: man-pages/man3/scanf.3:115
msgid ""
"If the number of conversion specifications in I<format> exceeds the number "
"of I<pointer> arguments, the results are undefined.  If the number of "
"I<pointer> arguments exceeds the number of conversion specifications, then "
"the excess I<pointer> arguments are evaluated, but are otherwise ignored."
msgstr ""

#. type: Plain text
#: man-pages/man3/scanf.3:127
msgid ""
"The B<scanf>()  function reads input from the standard input stream "
"I<stdin>, B<fscanf>()  reads input from the stream pointer I<stream>, and "
"B<sscanf>()  reads its input from the character string pointed to by I<str>."
msgstr ""

#. type: Plain text
#: man-pages/man3/scanf.3:145
msgid ""
"The B<vfscanf>()  function is analogous to B<vfprintf>(3)  and reads input "
"from the stream pointer I<stream> using a variable argument list of pointers"
" (see B<stdarg>(3).  The B<vscanf>()  function scans a variable argument "
"list from the standard input and the B<vsscanf>()  function scans it from a "
"string; these are analogous to the B<vprintf>(3)  and B<vsprintf>(3)  "
"functions respectively."
msgstr ""

#. type: Plain text
#: man-pages/man3/scanf.3:159
msgid ""
"The I<format> string consists of a sequence of I<directives> which describe "
"how to process the sequence of input characters.  If processing of a "
"directive fails, no further input is read, and B<scanf>()  returns.  A "
"\"failure\" can be either of the following: I<input failure>, meaning that "
"input characters were unavailable, or I<matching failure>, meaning that the "
"input was inappropriate (see below)."
msgstr ""

#. type: Plain text
#: man-pages/man3/scanf.3:161
msgid "A directive is one of the following:"
msgstr ""

#. type: Plain text
#: man-pages/man3/scanf.3:167
msgid ""
"A sequence of white-space characters (space, tab, newline, etc.; see "
"B<isspace>(3)).  This directive matches any amount of white space, including"
" none, in the input."
msgstr ""

#. type: Plain text
#: man-pages/man3/scanf.3:171
msgid ""
"An ordinary character (i.e., one other than white space or \\(aq%\\(aq).  "
"This character must exactly match the next character of input."
msgstr ""

#. type: Plain text
#: man-pages/man3/scanf.3:182
msgid ""
"A conversion specification, which commences with a \\(aq%\\(aq (percent) "
"character.  A sequence of characters from the input is converted according "
"to this specification, and the result is placed in the corresponding "
"I<pointer> argument.  If the next item of input does not match the "
"conversion specification, the conversion fails\\(emthis is a I<matching "
"failure>."
msgstr ""

#. type: Plain text
#: man-pages/man3/scanf.3:190
msgid ""
"Each I<conversion specification> in I<format> begins with either the "
"character \\(aq%\\(aq or the character sequence \"B<%>I<n>B<$>\" (see below "
"for the distinction) followed by:"
msgstr ""

#. type: Plain text
#: man-pages/man3/scanf.3:201
msgid ""
"An optional \\(aq*\\(aq assignment-suppression character: B<scanf>()  reads "
"input as directed by the conversion specification, but discards the input.  "
"No corresponding I<pointer> argument is required, and this specification is "
"not included in the count of successful assignments returned by B<scanf>()."
msgstr ""

#. type: Plain text
#: man-pages/man3/scanf.3:220
msgid ""
"An optional \\(aqm\\(aq character.  This is used with string conversions "
"(I<%s>, I<%c>, I<%[>), and relieves the caller of the need to allocate a "
"corresponding buffer to hold the input: instead, B<scanf>()  allocates a "
"buffer of sufficient size, and assigns the address of this buffer to the "
"corresponding I<pointer> argument, which should be a pointer to a I<char\\ "
"*> variable (this variable does not need to be initialized before the call)."
"  The caller should subsequently B<free>(3)  this buffer when it is no "
"longer required."
msgstr ""

#. type: Plain text
#: man-pages/man3/scanf.3:232
msgid ""
"An optional decimal integer which specifies the I<maximum field width>.  "
"Reading of characters stops either when this maximum is reached or when a "
"nonmatching character is found, whichever happens first.  Most conversions "
"discard initial white space characters (the exceptions are noted below), and"
" these discarded characters don't count toward the maximum field width.  "
"String input conversions store a terminating null byte (\\(aq\\e0\\(aq)  to "
"mark the end of the input; the maximum field width does not include this "
"terminator."
msgstr ""

#. type: Plain text
#: man-pages/man3/scanf.3:246
msgid ""
"An optional I<type modifier character>.  For example, the B<l> type modifier"
" is used with integer conversions such as B<%d> to specify that the "
"corresponding I<pointer> argument refers to a I<long int> rather than a "
"pointer to an I<int>."
msgstr ""

#. type: Plain text
#: man-pages/man3/scanf.3:251
msgid ""
"A I<conversion specifier> that specifies the type of input conversion to be "
"performed."
msgstr ""

#. type: Plain text
#: man-pages/man3/scanf.3:280
msgid ""
"The conversion specifications in I<format> are of two forms, either "
"beginning with \\(aq%\\(aq or beginning with \"B<%>I<n>B<$>\".  The two "
"forms should not be mixed in the same I<format> string, except that a string"
" containing \"B<%>I<n>B<$>\" specifications can include B<%%> and B<%*>.  If"
" I<format> contains \\(aq%\\(aq specifications, then these correspond in "
"order with successive I<pointer> arguments.  In the \"B<%>I<n>B<$>\" form "
"(which is specified in POSIX.1-2001, but not C99), I<n> is a decimal integer"
" that specifies that the converted input should be placed in the location "
"referred to by the I<n>-th I<pointer> argument following I<format>."
msgstr ""

#. type: SS
#: man-pages/man3/scanf.3:280
#, no-wrap
msgid "Conversions"
msgstr ""

#. type: Plain text
#: man-pages/man3/scanf.3:284
msgid ""
"The following I<type modifier characters> can appear in a conversion "
"specification:"
msgstr ""

#. type: TP
#: man-pages/man3/scanf.3:284
#, no-wrap
msgid "B<h>"
msgstr "B<h>"

#. type: Plain text
#: man-pages/man3/scanf.3:294
msgid ""
"Indicates that the conversion will be one of B<d>, B<i>, B<o>, B<u>, B<x>, "
"B<X>, or B<n> and the next pointer is a pointer to a I<short int> or "
"I<unsigned short int> (rather than I<int>)."
msgstr ""

#. type: TP
#: man-pages/man3/scanf.3:294
#, no-wrap
msgid "B<hh>"
msgstr "B<hh>"

#. type: Plain text
#: man-pages/man3/scanf.3:302
msgid ""
"As for B<h>, but the next pointer is a pointer to a I<signed char> or "
"I<unsigned char>."
msgstr ""

#. type: TP
#: man-pages/man3/scanf.3:302
#, no-wrap
msgid "B<j>"
msgstr "B<j>"

#. type: Plain text
#: man-pages/man3/scanf.3:311
msgid ""
"As for B<h>, but the next pointer is a pointer to an I<intmax_t> or a "
"I<uintmax_t>.  This modifier was introduced in C99."
msgstr ""

#. type: TP
#: man-pages/man3/scanf.3:311
#, no-wrap
msgid "B<l>"
msgstr "B<l>"

#.  This use of l was introduced in Amendment 1 to ISO C90.
#. type: Plain text
#: man-pages/man3/scanf.3:338
msgid ""
"Indicates either that the conversion will be one of B<d>, B<i>, B<o>, B<u>, "
"B<x>, B<X>, or B<n> and the next pointer is a pointer to a I<long int> or "
"I<unsigned long int> (rather than I<int>), or that the conversion will be "
"one of B<e>, B<f>, or B<g> and the next pointer is a pointer to I<double> "
"(rather than I<float>).  Specifying two B<l> characters is equivalent to "
"B<L>.  If used with B<%c> or B<%s>, the corresponding parameter is "
"considered as a pointer to a wide character or wide-character string "
"respectively."
msgstr ""

#. type: TP
#: man-pages/man3/scanf.3:338
#, no-wrap
msgid "B<L>"
msgstr "B<L>"

#.  MTK, Jul 05: The following is no longer true for modern
#.  ANSI C (i.e., C99):
#.  (Note that long long is not an
#.  ANSI C
#.  type. Any program using this will not be portable to all
#.  architectures).
#. type: Plain text
#: man-pages/man3/scanf.3:354
msgid ""
"Indicates that the conversion will be either B<e>, B<f>, or B<g> and the "
"next pointer is a pointer to I<long double> or the conversion will be B<d>, "
"B<i>, B<o>, B<u>, or B<x> and the next pointer is a pointer to I<long long>."
msgstr ""

#. type: TP
#: man-pages/man3/scanf.3:354
#, no-wrap
msgid "B<q>"
msgstr "B<q>"

#. type: Plain text
#: man-pages/man3/scanf.3:359
msgid "equivalent to B<L>.  This specifier does not exist in ANSI C."
msgstr ""

#. type: TP
#: man-pages/man3/scanf.3:359
#, no-wrap
msgid "B<t>"
msgstr ""

#. type: Plain text
#: man-pages/man3/scanf.3:366
msgid ""
"As for B<h>, but the next pointer is a pointer to a I<ptrdiff_t>.  This "
"modifier was introduced in C99."
msgstr ""

#. type: TP
#: man-pages/man3/scanf.3:366
#, no-wrap
msgid "B<z>"
msgstr "B<z>"

#. type: Plain text
#: man-pages/man3/scanf.3:373
msgid ""
"As for B<h>, but the next pointer is a pointer to a I<size_t>.  This "
"modifier was introduced in C99."
msgstr ""

#. type: Plain text
#: man-pages/man3/scanf.3:377
msgid "The following I<conversion specifiers> are available:"
msgstr ""

#. type: TP
#: man-pages/man3/scanf.3:377
#, no-wrap
msgid "B<%>"
msgstr ""

#. type: Plain text
#: man-pages/man3/scanf.3:386
msgid ""
"Matches a literal \\(aq%\\(aq.  That is, B<%\\&%> in the format string "
"matches a single input \\(aq%\\(aq character.  No conversion is done (but "
"initial white space characters are discarded), and assignment does not "
"occur."
msgstr ""

#. type: TP
#: man-pages/man3/scanf.3:386
#, no-wrap
msgid "B<d>"
msgstr ""

#. type: Plain text
#: man-pages/man3/scanf.3:391
msgid ""
"Matches an optionally signed decimal integer; the next pointer must be a "
"pointer to I<int>."
msgstr ""

#. type: TP
#: man-pages/man3/scanf.3:391
#, no-wrap
msgid "B<D>"
msgstr ""

#. type: Plain text
#: man-pages/man3/scanf.3:400
msgid ""
"Equivalent to I<ld>; this exists only for backward compatibility.  (Note: "
"thus only in libc4.  In libc5 and glibc the B<%D> is silently ignored, "
"causing old programs to fail mysteriously.)"
msgstr ""

#. type: TP
#: man-pages/man3/scanf.3:400
#, no-wrap
msgid "B<i>"
msgstr ""

#. type: Plain text
#: man-pages/man3/scanf.3:412
msgid ""
"Matches an optionally signed integer; the next pointer must be a pointer to "
"I<int>.  The integer is read in base 16 if it begins with I<0x> or I<0X>, in"
" base 8 if it begins with I<0>, and in base 10 otherwise.  Only characters "
"that correspond to the base are used."
msgstr ""

#. type: TP
#: man-pages/man3/scanf.3:412
#, no-wrap
msgid "B<o>"
msgstr ""

#. type: Plain text
#: man-pages/man3/scanf.3:416
msgid ""
"Matches an unsigned octal integer; the next pointer must be a pointer to "
"I<unsigned int>."
msgstr ""

#. type: TP
#: man-pages/man3/scanf.3:416
#, no-wrap
msgid "B<u>"
msgstr ""

#. type: Plain text
#: man-pages/man3/scanf.3:421
msgid ""
"Matches an unsigned decimal integer; the next pointer must be a pointer to "
"I<unsigned int>."
msgstr ""

#. type: TP
#: man-pages/man3/scanf.3:421
#, no-wrap
msgid "B<x>"
msgstr ""

#. type: Plain text
#: man-pages/man3/scanf.3:426
msgid ""
"Matches an unsigned hexadecimal integer; the next pointer must be a pointer "
"to I<unsigned int>."
msgstr ""

#. type: TP
#: man-pages/man3/scanf.3:426
#, no-wrap
msgid "B<X>"
msgstr ""

#. type: Plain text
#: man-pages/man3/scanf.3:430
msgid "Equivalent to B<x>."
msgstr ""

#. type: TP
#: man-pages/man3/scanf.3:430
#, no-wrap
msgid "B<f>"
msgstr ""

#. type: Plain text
#: man-pages/man3/scanf.3:435
msgid ""
"Matches an optionally signed floating-point number; the next pointer must be"
" a pointer to I<float>."
msgstr ""

#. type: TP
#: man-pages/man3/scanf.3:435
#, no-wrap
msgid "B<e>"
msgstr ""

#. type: Plain text
#: man-pages/man3/scanf.3:439 man-pages/man3/scanf.3:443
#: man-pages/man3/scanf.3:447
msgid "Equivalent to B<f>."
msgstr ""

#. type: TP
#: man-pages/man3/scanf.3:439
#, no-wrap
msgid "B<g>"
msgstr ""

#. type: TP
#: man-pages/man3/scanf.3:443
#, no-wrap
msgid "B<E>"
msgstr ""

#. type: TP
#: man-pages/man3/scanf.3:447
#, no-wrap
msgid "B<a>"
msgstr ""

#. type: Plain text
#: man-pages/man3/scanf.3:451
msgid "(C99) Equivalent to B<f>."
msgstr ""

#. type: TP
#: man-pages/man3/scanf.3:451
#, no-wrap
msgid "B<s>"
msgstr "B<s>"

#. type: Plain text
#: man-pages/man3/scanf.3:459
msgid ""
"Matches a sequence of non-white-space characters; the next pointer must be a"
" pointer to character array that is long enough to hold the input sequence "
"and the terminating null byte (\\(aq\\e0\\(aq), which is added "
"automatically.  The input string stops at white space or at the maximum "
"field width, whichever occurs first."
msgstr ""

#. type: TP
#: man-pages/man3/scanf.3:459
#, no-wrap
msgid "B<c>"
msgstr "B<c>"

#. type: Plain text
#: man-pages/man3/scanf.3:469
msgid ""
"Matches a sequence of characters whose length is specified by the I<maximum "
"field width> (default 1); the next pointer must be a pointer to I<char>, and"
" there must be enough room for all the characters (no terminating null byte "
"is added).  The usual skip of leading white space is suppressed.  To skip "
"white space first, use an explicit space in the format."
msgstr ""

#. type: TP
#: man-pages/man3/scanf.3:469
#, no-wrap
msgid "B<\\&[>"
msgstr ""

#. type: Plain text
#: man-pages/man3/scanf.3:502
msgid ""
"Matches a nonempty sequence of characters from the specified set of accepted"
" characters; the next pointer must be a pointer to I<char>, and there must "
"be enough room for all the characters in the string, plus a terminating null"
" byte.  The usual skip of leading white space is suppressed.  The string is "
"to be made up of characters in (or not in) a particular set; the set is "
"defined by the characters between the open bracket B<[> character and a "
"close bracket B<]> character.  The set I<excludes> those characters if the "
"first character after the open bracket is a circumflex (B<^>).  To include a"
" close bracket in the set, make it the first character after the open "
"bracket or the circumflex; any other position will end the set.  The hyphen "
"character B<-> is also special; when placed between two other characters, it"
" adds all intervening characters to the set.  To include a hyphen, make it "
"the last character before the final close bracket.  For instance, "
"B<[^]0-9-]> means the set \"everything except close bracket, zero through "
"nine, and hyphen\".  The string ends with the appearance of a character not "
"in the (or, with a circumflex, in) set or when the field width runs out."
msgstr ""

#. type: TP
#: man-pages/man3/scanf.3:502
#, no-wrap
msgid "B<p>"
msgstr "B<p>"

#. type: Plain text
#: man-pages/man3/scanf.3:510
msgid ""
"Matches a pointer value (as printed by B<%p> in B<printf>(3); the next "
"pointer must be a pointer to a pointer to I<void>."
msgstr ""

#. type: TP
#: man-pages/man3/scanf.3:510
#, no-wrap
msgid "B<n>"
msgstr "B<n>"

#. type: Plain text
#: man-pages/man3/scanf.3:530
msgid ""
"Nothing is expected; instead, the number of characters consumed thus far "
"from the input is stored through the next pointer, which must be a pointer "
"to I<int>.  This is I<not> a conversion, although it can be suppressed with "
"the B<*> assignment-suppression character.  The C standard says: \"Execution"
" of a B<%n> directive does not increment the assignment count returned at "
"the completion of execution\" but the Corrigendum seems to contradict this."
"  Probably it is wise not to make any assumptions on the effect of B<%n> "
"conversions on the return value."
msgstr ""

#. type: Plain text
#: man-pages/man3/scanf.3:535
msgid ""
"These functions return the number of input items successfully matched and "
"assigned, which can be fewer than provided for, or even zero in the event of"
" an early matching failure."
msgstr ""

#. type: Plain text
#: man-pages/man3/scanf.3:547
msgid ""
"The value B<EOF> is returned if the end of input is reached before either "
"the first successful conversion or a matching failure occurs.  B<EOF> is "
"also returned if a read error occurs, in which case the error indicator for "
"the stream (see B<ferror>(3))  is set, and I<errno> is set indicate the "
"error."
msgstr ""

#. type: Plain text
#: man-pages/man3/scanf.3:553
msgid ""
"The file descriptor underlying I<stream> is marked nonblocking, and the read"
" operation would block."
msgstr ""

#. type: Plain text
#: man-pages/man3/scanf.3:558
msgid ""
"The file descriptor underlying I<stream> is invalid, or not open for "
"reading."
msgstr ""

#. type: TP
#: man-pages/man3/scanf.3:558
#, no-wrap
msgid "B<EILSEQ>"
msgstr ""

#. type: Plain text
#: man-pages/man3/scanf.3:561
msgid "Input byte sequence does not form a valid character."
msgstr ""

#. type: Plain text
#: man-pages/man3/scanf.3:565
msgid "The read operation was interrupted by a signal; see B<signal>(7)."
msgstr ""

#. type: Plain text
#: man-pages/man3/scanf.3:570
msgid "Not enough arguments; or I<format> is NULL."
msgstr ""

#. type: Plain text
#: man-pages/man3/scanf.3:577
msgid ""
"The result of an integer conversion would exceed the size that can be stored"
" in the corresponding integer type."
msgstr ""

#. type: Plain text
#: man-pages/man3/scanf.3:587
msgid ""
"The functions B<fscanf>(), B<scanf>(), and B<sscanf>()  conform to C89 and "
"C99 and POSIX.1-2001.  These standards do not specify the B<ERANGE> error."
msgstr ""

#. type: Plain text
#: man-pages/man3/scanf.3:597
msgid ""
"The B<q> specifier is the 4.4BSD notation for I<long long>, while B<ll> or "
"the usage of B<L> in integer conversions is the GNU notation."
msgstr ""

#. type: Plain text
#: man-pages/man3/scanf.3:608
msgid ""
"The Linux version of these functions is based on the I<GNU> I<libio> "
"library.  Take a look at the I<info> documentation of I<GNU> I<libc "
"(glibc-1.08)> for a more concise description."
msgstr ""

#. type: SS
#: man-pages/man3/scanf.3:609
#, no-wrap
msgid "The 'a' assignment-allocation modifier"
msgstr ""

#. type: Plain text
#: man-pages/man3/scanf.3:620
msgid ""
"Originally, the GNU C library supported dynamic allocation for string inputs"
" (as a nonstandard extension) via the B<a> character.  (This feature is "
"present at least as far back as glibc 2.0.)  Thus, one could write the "
"following to have B<scanf>()  allocate a buffer for an input string, with a "
"pointer to that buffer being returned in I<*buf>:"
msgstr ""

#. type: Plain text
#: man-pages/man3/scanf.3:623
#, no-wrap
msgid ""
"    char *buf;\n"
"    scanf(\"%as\", &buf);\n"
msgstr "    char *buf;\n    scanf(\"%as\", &buf);\n"

#. type: Plain text
#: man-pages/man3/scanf.3:634
msgid ""
"The use of the letter B<a> for this purpose was problematic, since B<a> is "
"also specified by the ISO C standard as a synonym for B<f> (floating-point "
"input).  POSIX.1-2008 instead specifies the B<m> modifier for assignment "
"allocation (as documented in DESCRIPTION, above)."
msgstr ""

#. type: Plain text
#: man-pages/man3/scanf.3:646
msgid ""
"Note that the B<a> modifier is not available if the program is compiled with"
" I<gcc -std=c99> or I<gcc -D_ISOC99_SOURCE> (unless B<_GNU_SOURCE> is also "
"specified), in which case the B<a> is interpreted as a specifier for "
"floating-point numbers (see above)."
msgstr ""

#. type: Plain text
#: man-pages/man3/scanf.3:652
msgid ""
"Support for the B<m> modifier was added to glibc starting with version 2.7, "
"and new programs should use that modifier instead of B<a>."
msgstr ""

#. type: Plain text
#: man-pages/man3/scanf.3:658
msgid ""
"As well as being standardized by POSIX, the B<m> modifier has the following "
"further advantages over the use of B<a:>"
msgstr ""

#. type: Plain text
#: man-pages/man3/scanf.3:663
msgid "It may also be applied to B<%c> conversion specifiers (e.g., B<%3mc>)."
msgstr ""

#. type: Plain text
#: man-pages/man3/scanf.3:669
msgid ""
"It avoids ambiguity with respect to the B<%a> floating-point conversion "
"specifier (and is unaffected by I<gcc -std=c99> etc.)."
msgstr ""

#. type: Plain text
#: man-pages/man3/scanf.3:682
msgid ""
"All functions are fully C89 conformant, but provide the additional "
"specifiers B<q> and B<a> as well as an additional behavior of the B<L> and "
"B<l> specifiers.  The latter may be considered to be a bug, as it changes "
"the behavior of specifiers defined in C89."
msgstr ""

#. type: Plain text
#: man-pages/man3/scanf.3:698
msgid ""
"Some combinations of the type modifiers and conversion specifiers defined by"
" ANSI C do not make sense (e.g., B<%Ld>).  While they may have a well-"
"defined behavior on Linux, this need not to be so on other architectures.  "
"Therefore it usually is better to use modifiers that are not defined by ANSI"
" C at all, that is, use B<q> instead of B<L> in combination with B<d>, B<i>,"
" B<o>, B<u>, B<x>, and B<X> conversions or B<ll>."
msgstr ""

#. type: Plain text
#: man-pages/man3/scanf.3:704
msgid ""
"The usage of B<q> is not the same as on 4.4BSD, as it may be used in float "
"conversions equivalently to B<L>."
msgstr ""

#. type: Plain text
#: man-pages/man3/scanf.3:714
msgid ""
"To use the dynamic allocation conversion specifier, specify B<m> as a length"
" modifier (thus B<%ms> or B<%m[>I<range>B<]>).  The caller must B<free>(3)  "
"the returned string, as in the following example:"
msgstr ""

#. type: Plain text
#: man-pages/man3/scanf.3:719
#, no-wrap
msgid ""
"char *p;\n"
"int n;\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/scanf.3:730
#, no-wrap
msgid ""
"errno = 0;\n"
"n = scanf(\"%m[a-z]\", &p);\n"
"if (n == 1) {\n"
"    printf(\"read: %s\\en\", p);\n"
"    free(p);\n"
"} else if (errno != 0) {\n"
"    perror(\"scanf\");\n"
"} else {\n"
"    fprintf(stderr, \"No matching characters\\en\");\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/scanf.3:738
msgid ""
"As shown in the above example, it is necessary to call B<free>(3)  only if "
"the B<scanf>()  call successfully read a string."
msgstr ""

#. type: Plain text
#: man-pages/man3/scanf.3:744
msgid ""
"B<getc>(3), B<printf>(3), B<setlocale>(3), B<strtod>(3), B<strtol>(3), "
"B<strtoul>(3)"
msgstr ""

#. type: TH
#: man-pages/man3/sinh.3:36
#, no-wrap
msgid "SINH"
msgstr "SINH"

#. type: Plain text
#: man-pages/man3/sinh.3:39
msgid "sinh, sinhf, sinhl - hyperbolic sine function"
msgstr "sinh, sinhf, sinhl - функция вычисления гиперболического синуса"

#. type: Plain text
#: man-pages/man3/sinh.3:44
#, no-wrap
msgid "B<double sinh(double >I<x>B<);>\n"
msgstr "B<double sinh(double >I<x>B<);>\n"

#. type: Plain text
#: man-pages/man3/sinh.3:46
#, no-wrap
msgid "B<float sinhf(float >I<x>B<);>\n"
msgstr "B<float sinhf(float >I<x>B<);>\n"

#. type: Plain text
#: man-pages/man3/sinh.3:48
#, no-wrap
msgid "B<long double sinhl(long double >I<x>B<);>\n"
msgstr "B<long double sinhl(long double >I<x>B<);>\n"

#. type: Plain text
#: man-pages/man3/sinh.3:60
msgid "B<sinhf>(), B<sinhl>():"
msgstr "B<sinhf>(), B<sinhl>():"

#. type: Plain text
#: man-pages/man3/sinh.3:75
msgid ""
"The B<sinh>()  function returns the hyperbolic sine of I<x>, which is "
"defined mathematically as:"
msgstr "Функция B<sinh>() возвращает гиперболический синус от I<x>, как это математически определено:"

#. type: Plain text
#: man-pages/man3/sinh.3:78
#, no-wrap
msgid "    sinh(x) = (exp(x) - exp(-x)) / 2\n"
msgstr "    sinh(x) = (exp(x) - exp(-x)) / 2\n"

#. type: Plain text
#: man-pages/man3/sinh.3:82
msgid "On success, these functions return the hyperbolic sine of I<x>."
msgstr "В случае успеха данные функции возвращают гиперболический синус от I<x>."

#. type: Plain text
#: man-pages/man3/sinh.3:90
msgid "If I<x> is +0 (-0), +0 (-0) is returned."
msgstr "Если I<x> равно +0 (-0), будет возвращено +0 (-0)."

#. type: Plain text
#: man-pages/man3/sinh.3:95
msgid ""
"If I<x> is positive infinity (negative infinity), positive infinity "
"(negative infinity) is returned."
msgstr "Если I<x>  стремится к плюс или минус бесконечности, будет возвращена плюс или минус бесконечность."

#.  POSIX.1-2001 documents an optional range error (underflow)
#.  for subnormal x;
#.  glibc 2.8 does not do this.
#. type: Plain text
#: man-pages/man3/sinh.3:109
msgid ""
"If the result overflows, a range error occurs, and the functions return "
"B<HUGE_VAL>, B<HUGE_VALF>, or B<HUGE_VALL>, respectively, with the same sign"
" as I<x>."
msgstr "Если в результате превышена разрядность, то возникает ошибка диапазона и функции возвращают B<HUGE_VAL>, B<HUGE_VALF> или B<HUGE_VALL>, соответственно, с тем же знаком что и I<x>."

#. type: TP
#: man-pages/man3/sinh.3:116
#, no-wrap
msgid "Range error: result overflow"
msgstr "Ошибка диапазона: результат превысил разрядность"

#. type: Plain text
#: man-pages/man3/sinh.3:124
msgid ""
"I<errno> is set to B<ERANGE>.  An overflow floating-point exception "
"(B<FE_OVERFLOW>)  is raised."
msgstr "Значение I<errno> устанавливается в B<ERANGE>. Возникает исключение переполнения плавающей точки (B<FE_OVERFLOW>)."

#. type: Plain text
#: man-pages/man3/sinh.3:136
msgid ""
"B<acosh>(3), B<asinh>(3), B<atanh>(3), B<cosh>(3), B<csinh>(3), B<tanh>(3)"
msgstr "B<acosh>(3), B<asinh>(3), B<atanh>(3), B<cosh>(3), B<csinh>(3), B<tanh>(3)"

#. type: TH
#: man-pages/man3/strtol.3:31
#, no-wrap
msgid "STRTOL"
msgstr "STRTOL"

#. type: Plain text
#: man-pages/man3/strtol.3:34
msgid "strtol, strtoll, strtoq - convert a string to a long integer"
msgstr ""

#. type: Plain text
#: man-pages/man3/strtol.3:39
#, no-wrap
msgid ""
"B<long int strtol(const char *>I<nptr>B<, char **>I<endptr>B<, int "
">I<base>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/strtol.3:42
#, no-wrap
msgid ""
"B<long long int strtoll(const char *>I<nptr>B<, char **>I<endptr>B<, int "
">I<base>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/strtol.3:51
msgid "B<strtoll>():"
msgstr ""

#. type: Plain text
#: man-pages/man3/strtol.3:68
msgid ""
"The B<strtol>()  function converts the initial part of the string in I<nptr>"
" to a long integer value according to the given I<base>, which must be "
"between 2 and 36 inclusive, or be the special value 0."
msgstr ""

#. type: Plain text
#: man-pages/man3/strtol.3:90
msgid ""
"The remainder of the string is converted to a I<long int> value in the "
"obvious manner, stopping at the first character which is not a valid digit "
"in the given base.  (In bases above 10, the letter \\(aqA\\(aq in either "
"uppercase or lowercase represents 10, \\(aqB\\(aq represents 11, and so "
"forth, with \\(aqZ\\(aq representing 35.)"
msgstr ""

#. type: Plain text
#: man-pages/man3/strtol.3:111
msgid ""
"If I<endptr> is not NULL, B<strtol>()  stores the address of the first "
"invalid character in I<*endptr>.  If there were no digits at all, "
"B<strtol>()  stores the original value of I<nptr> in I<*endptr> (and returns"
" 0).  In particular, if I<*nptr> is not \\(aq\\e0\\(aq but I<**endptr> is "
"\\(aq\\e0\\(aq on return, the entire string is valid."
msgstr ""

#. type: Plain text
#: man-pages/man3/strtol.3:117
msgid ""
"The B<strtoll>()  function works just like the B<strtol>()  function but "
"returns a long long integer value."
msgstr ""

#. type: Plain text
#: man-pages/man3/strtol.3:144
msgid ""
"The B<strtol>()  function returns the result of the conversion, unless the "
"value would underflow or overflow.  If an underflow occurs, B<strtol>()  "
"returns B<LONG_MIN>.  If an overflow occurs, B<strtol>()  returns "
"B<LONG_MAX>.  In both cases, I<errno> is set to B<ERANGE>.  Precisely the "
"same holds for B<strtoll>()  (with B<LLONG_MIN> and B<LLONG_MAX> instead of "
"B<LONG_MIN> and B<LONG_MAX>)."
msgstr ""

#. type: Plain text
#: man-pages/man3/strtol.3:173
msgid ""
"The B<strtol>(), B<strtoll>(), and B<strtoq>()  functions are thread-safe "
"with exceptions.  These functions can be safely used in multithreaded "
"applications, as long as B<setlocale>(3)  is not called to change the locale"
" during their execution."
msgstr ""

#. type: Plain text
#: man-pages/man3/strtol.3:178
msgid ""
"B<strtol>()  conforms to SVr4, 4.3BSD, C89, C99, and POSIX.1-2001, and "
"B<strtoll>()  to C99 and POSIX.1-2001."
msgstr ""

#. type: Plain text
#: man-pages/man3/strtol.3:196
msgid ""
"Since B<strtol>()  can legitimately return 0, B<LONG_MAX>, or B<LONG_MIN> "
"(B<LLONG_MAX> or B<LLONG_MIN> for B<strtoll>())  on both success and "
"failure, the calling program should set I<errno> to 0 before the call, and "
"then determine if an error occurred by checking whether I<errno> has a "
"nonzero value after the call."
msgstr ""

#. type: Plain text
#: man-pages/man3/strtol.3:201
msgid ""
"According to POSIX.1-2001, in locales other than the \"C\" and \"POSIX\", "
"these functions may accept other, implementation-defined numeric strings."
msgstr ""

#. type: Plain text
#: man-pages/man3/strtol.3:207
#, no-wrap
msgid ""
"B<quad_t strtoq(const char *>I<nptr>B<, char **>I<endptr>B<, int "
">I<base>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/strtol.3:216
msgid ""
"with completely analogous definition.  Depending on the wordsize of the "
"current architecture, this may be equivalent to B<strtoll>()  or to "
"B<strtol>()."
msgstr ""

#. type: Plain text
#: man-pages/man3/strtol.3:230
msgid ""
"The program shown below demonstrates the use of B<strtol>().  The first "
"command-line argument specifies a string from which B<strtol>()  should "
"parse a number.  The second (optional) argument specifies the base to be "
"used for the conversion.  (This argument is converted to numeric form using "
"B<atoi>(3), a function that performs no error checking and has a simpler "
"interface than B<strtol>().)  Some examples of the results produced by this "
"program are the following:"
msgstr ""

#. type: Plain text
#: man-pages/man3/strtol.3:246
#, no-wrap
msgid ""
"$B< ./a.out 123>\n"
"strtol() returned 123\n"
"$B< ./a.out \\(aq    123\\(aq>\n"
"strtol() returned 123\n"
"$B< ./a.out 123abc>\n"
"strtol() returned 123\n"
"Further characters after number: abc\n"
"$B< ./a.out 123abc 55>\n"
"strtol: Invalid argument\n"
"$B< ./a.out \\(aq\\(aq>\n"
"No digits were found\n"
"$B< ./a.out 4000000000>\n"
"strtol: Numerical result out of range\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/strtol.3:255
#, no-wrap
msgid ""
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>limits.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/strtol.3:262
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int base;\n"
"    char *endptr, *str;\n"
"    long val;\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/strtol.3:267
#, no-wrap
msgid ""
"    if (argc E<lt> 2) {\n"
"        fprintf(stderr, \"Usage: %s str [base]\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/strtol.3:270
#, no-wrap
msgid ""
"    str = argv[1];\n"
"    base = (argc E<gt> 2) ? atoi(argv[2]) : 10;\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/strtol.3:273
#, no-wrap
msgid ""
"    errno = 0;    /* To distinguish success/failure after call */\n"
"    val = strtol(str, &endptr, base);\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/strtol.3:275
#, no-wrap
msgid "    /* Check for various possible errors */\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/strtol.3:281
#, no-wrap
msgid ""
"    if ((errno == ERANGE && (val == LONG_MAX || val == LONG_MIN))\n"
"            || (errno != 0 && val == 0)) {\n"
"        perror(\"strtol\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/strtol.3:286
#, no-wrap
msgid ""
"    if (endptr == str) {\n"
"        fprintf(stderr, \"No digits were found\\en\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/strtol.3:288
#, no-wrap
msgid "    /* If we got here, strtol() successfully parsed a number */\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/strtol.3:290
#, no-wrap
msgid "    printf(\"strtol() returned %ld\\en\", val);\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/strtol.3:293
#, no-wrap
msgid ""
"    if (*endptr != \\(aq\\e0\\(aq)        /* Not necessarily an error... */\n"
"        printf(\"Further characters after number: %s\\en\", endptr);\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/strtol.3:302
msgid "B<atof>(3), B<atoi>(3), B<atol>(3), B<strtod>(3), B<strtoul>(3)"
msgstr ""

#. type: TH
#: man-pages/man3/strfmon.3:24
#, no-wrap
msgid "STRFMON"
msgstr ""

#. type: TH
#: man-pages/man3/strfmon.3:24
#, no-wrap
msgid "2000-12-05"
msgstr ""

#. type: Plain text
#: man-pages/man3/strfmon.3:27
msgid "strfmon - convert monetary value to a string"
msgstr ""

#. type: Plain text
#: man-pages/man3/strfmon.3:29
msgid "B<#include E<lt>monetary.hE<gt>>"
msgstr ""

#. type: Plain text
#: man-pages/man3/strfmon.3:32
msgid ""
"B<ssize_t strfmon(char *>I<s>B<, size_t >I<max>B<, const char "
"*>I<format>B<,> B<...);>"
msgstr ""

#. type: Plain text
#: man-pages/man3/strfmon.3:43
msgid ""
"The B<strfmon>()  function formats the specified amounts according to the "
"format specification I<format> and places the result in the character array "
"I<s> of size I<max>."
msgstr ""

#. type: Plain text
#: man-pages/man3/strfmon.3:53
msgid ""
"Ordinary characters in I<format> are copied to I<s> without conversion.  "
"Conversion specifiers are introduced by a \\(aq%\\(aq character.  "
"Immediately following it there can be zero or more of the following flags:"
msgstr ""

#. type: TP
#: man-pages/man3/strfmon.3:53
#, no-wrap
msgid "B<=>I<f>"
msgstr ""

#. type: Plain text
#: man-pages/man3/strfmon.3:60
msgid ""
"The single-byte character I<f> is used as the numeric fill character (to be "
"used with a left precision, see below).  When not specified, the space "
"character is used."
msgstr ""

#. type: TP
#: man-pages/man3/strfmon.3:60
#, no-wrap
msgid "B<^>"
msgstr ""

#. type: Plain text
#: man-pages/man3/strfmon.3:65
msgid ""
"Do not use any grouping characters that might be defined for the current "
"locale.  By default, grouping is enabled."
msgstr ""

#. type: TP
#: man-pages/man3/strfmon.3:65
#, no-wrap
msgid "B<(> or B<+>"
msgstr ""

#. type: Plain text
#: man-pages/man3/strfmon.3:72
msgid ""
"The ( flag indicates that negative amounts should be enclosed between "
"parentheses.  The + flag indicates that signs should be handled in the "
"default way, that is, amounts are preceded by the locale's sign indication, "
"for example, nothing for positive, \"-\" for negative."
msgstr ""

#. type: TP
#: man-pages/man3/strfmon.3:72
#, no-wrap
msgid "B<!>"
msgstr ""

#. type: Plain text
#: man-pages/man3/strfmon.3:75
msgid "Omit the currency symbol."
msgstr ""

#. type: TP
#: man-pages/man3/strfmon.3:75
#, no-wrap
msgid "B<->"
msgstr "B<->"

#. type: Plain text
#: man-pages/man3/strfmon.3:79
msgid "Left justify all fields.  The default is right justification."
msgstr ""

#. type: Plain text
#: man-pages/man3/strfmon.3:85
msgid ""
"Next, there may be a field width: a decimal digit string specifying a "
"minimum field width in bytes.  The default is 0.  A result smaller than this"
" width is padded with spaces (on the left, unless the left-justify flag was "
"given)."
msgstr ""

#. type: Plain text
#: man-pages/man3/strfmon.3:92
msgid ""
"Next, there may be a left precision of the form \"#\" followed by a decimal "
"digit string.  If the number of digits left of the radix character is "
"smaller than this, the representation is padded on the left with the numeric"
" fill character.  Grouping characters are not counted in this field width."
msgstr ""

#. type: Plain text
#: man-pages/man3/strfmon.3:107
msgid ""
"Next, there may be a right precision of the form \".\" followed by a decimal"
" digit string.  The amount being formatted is rounded to the specified "
"number of digits prior to formatting.  The default is specified in the "
"I<frac_digits> and I<int_frac_digits> items of the current locale.  If the "
"right precision is 0, no radix character is printed.  (The radix character "
"here is determined by B<LC_MONETARY>, and may differ from that specified by "
"B<LC_NUMERIC>.)"
msgstr ""

#. type: Plain text
#: man-pages/man3/strfmon.3:111
msgid ""
"Finally, the conversion specification must be ended with a conversion "
"character.  The three conversion characters are"
msgstr ""

#. type: Plain text
#: man-pages/man3/strfmon.3:115
msgid ""
"(In this case, the entire specification must be exactly \"%%\".)  Put a "
"\\(aq%\\(aq character in the result string."
msgstr ""

#. type: Plain text
#: man-pages/man3/strfmon.3:120
msgid ""
"One argument of type I<double> is converted using the locale's international"
" currency format."
msgstr ""

#. type: Plain text
#: man-pages/man3/strfmon.3:125
msgid ""
"One argument of type I<double> is converted using the locale's national "
"currency format."
msgstr ""

#. type: Plain text
#: man-pages/man3/strfmon.3:138
msgid ""
"The B<strfmon>()  function returns the number of characters placed in the "
"array I<s>, not including the terminating null byte, provided the string, "
"including the terminating null byte, fits.  Otherwise, it sets I<errno> to "
"B<E2BIG>, returns -1, and the contents of the array is undefined."
msgstr ""

#. type: Plain text
#: man-pages/man3/strfmon.3:141
msgid "Not in POSIX.1-2001.  Present on several other systems."
msgstr ""

#. type: Plain text
#: man-pages/man3/strfmon.3:148
#, no-wrap
msgid ""
"strfmon(buf, sizeof(buf), \"[%^=*#6n] [%=*#6i]\",\n"
"        1234.567, 1234.567);\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/strfmon.3:152
msgid "outputs"
msgstr ""

#. type: Plain text
#: man-pages/man3/strfmon.3:155
msgid "[ fl **1234,57] [ NLG **1 234,57]"
msgstr ""

#. type: Plain text
#: man-pages/man3/strfmon.3:166
msgid ""
"in the Dutch locale (with fl for \"florijnen\" and NLG for Netherlands "
"Guilders).  The grouping character is very ugly because it takes as much "
"space as a digit, while it should not take more than half that, and will no "
"doubt cause confusion.  Surprisingly, the \"fl\" is preceded and followed by"
" a space, and \"NLG\" is preceded by one and followed by two spaces.  This "
"may be a bug in the locale files.  The Italian, Australian, Swiss, and "
"Portuguese locales yield"
msgstr ""

#. type: Plain text
#: man-pages/man3/strfmon.3:169
msgid "[ L. **1235] [ ITL **1.235]"
msgstr ""

#. type: Plain text
#: man-pages/man3/strfmon.3:171
msgid "[ $**1234.57] [ AUD **1,234.57]"
msgstr ""

#. type: Plain text
#: man-pages/man3/strfmon.3:173
msgid "[Fr. **1234,57] [CHF **1.234,57]"
msgstr ""

#. type: Plain text
#: man-pages/man3/strfmon.3:175
msgid "[ **1234$57Esc] [ **1.234$57PTE ]"
msgstr ""

#. type: Plain text
#: man-pages/man3/strfmon.3:179
msgid "B<setlocale>(3), B<sprintf>(3), B<locale>(7)"
msgstr ""

#. type: TH
#: man-pages/man3/stpcpy.3:25
#, no-wrap
msgid "STPCPY"
msgstr "STPCPY"

#. type: Plain text
#: man-pages/man3/stpcpy.3:28
msgid "stpcpy - copy a string returning a pointer to its end"
msgstr "stpcpy - копирование строки с возвращением указателя на её конец"

#. type: Plain text
#: man-pages/man3/stpcpy.3:33
#, no-wrap
msgid "B<char *stpcpy(char *>I<dest>B<, const char *>I<src>B<);>\n"
msgstr "B<char *stpcpy(char *>I<dest>B<, const char *>I<src>B<);>\n"

#. type: Plain text
#: man-pages/man3/stpcpy.3:41
msgid "B<stpcpy>():"
msgstr "B<stpcpy>():"

#. type: Plain text
#: man-pages/man3/stpcpy.3:63
msgid ""
"The B<stpcpy>()  function copies the string pointed to by I<src> (including "
"the terminating null byte (\\(aq\\e0\\(aq)) to the array pointed to by "
"I<dest>.  The strings may not overlap, and the destination string I<dest> "
"must be large enough to receive the copy."
msgstr "Функция B<strcpy>() копирует строку, указанную в I<src>, включая завершающий байт null (\\(aq\\e0\\(aq), в массив, указанный в I<dest>. Строки не могут перекрываться, а строка назначения I<dest> должна быть достаточно велика, чтобы хранить копию."

#. type: Plain text
#: man-pages/man3/stpcpy.3:71
msgid ""
"B<stpcpy>()  returns a pointer to the B<end> of the string I<dest> (that is,"
" the address of the terminating null byte)  rather than the beginning."
msgstr "Функция B<stpcpy>() возвращает указатель на B<конец> строки I<dest> (то есть адрес конечного байта null), а не на её начало."

#. type: Plain text
#: man-pages/man3/stpcpy.3:76
msgid "The B<stpcpy>()  function is thread-safe."
msgstr "Функцию B<stpcpy>() можно использовать в нескольких нитях одновременно."

#. type: Plain text
#: man-pages/man3/stpcpy.3:85
msgid ""
"This function was added to POSIX.1-2008.  Before that, it was not part of "
"the C or POSIX.1 standards, nor customary on UNIX systems.  It first "
"appeared at least as early as 1986, in the Lattice C AmigaDOS compiler, then"
" in the GNU fileutils and GNU textutils in 1989, and in the GNU C library by"
" 1992.  It is also present on the BSDs."
msgstr "Эта функция была добавлена в POSIX.1-2008. До этого, она не была частью стандарта C или POSIX.1, или обычной для систем UNIX. Впервые она появилась не раньше 1986 года в компиляторе Lattice C AmigaDOS, затем в GNU fileutils и GNU textutils в 1989 году, и в библиотеке GNU C в 1992 году. Также она есть в разных BSD."

#. type: Plain text
#: man-pages/man3/stpcpy.3:88
msgid "This function may overrun the buffer I<dest>."
msgstr "Эта функция может переполнить буфер I<dest>."

#. type: Plain text
#: man-pages/man3/stpcpy.3:98
msgid ""
"For example, this program uses B<stpcpy>()  to concatenate B<foo> and B<bar>"
" to produce B<foobar>, which it then prints."
msgstr "Данная программа использует B<stpcpy>() для объединения B<foo> и B<bar>, чтобы получить строку B<foobar>, которая затем выводится."

#. type: Plain text
#: man-pages/man3/stpcpy.3:103
#, no-wrap
msgid ""
"#define _GNU_SOURCE\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
msgstr "#define _GNU_SOURCE\n#include E<lt>string.hE<gt>\n#include E<lt>stdio.hE<gt>\n"

#. type: Plain text
#: man-pages/man3/stpcpy.3:109
#, no-wrap
msgid ""
"int\n"
"main(void)\n"
"{\n"
"    char buffer[20];\n"
"    char *to = buffer;\n"
msgstr "int\nmain(void)\n{\n    char buffer[20];\n    char *to = buffer;\n"

#. type: Plain text
#: man-pages/man3/stpcpy.3:114
#, no-wrap
msgid ""
"    to = stpcpy(to, \"foo\");\n"
"    to = stpcpy(to, \"bar\");\n"
"    printf(\"%s\\en\", buffer);\n"
"}\n"
msgstr "    to = stpcpy(to, \"foo\");\n    to = stpcpy(to, \"bar\");\n    printf(\"%s\\en\", buffer);\n}\n"

#. type: Plain text
#: man-pages/man3/stpcpy.3:123
msgid ""
"B<bcopy>(3), B<memccpy>(3), B<memcpy>(3), B<memmove>(3), B<stpncpy>(3), "
"B<strcpy>(3), B<string>(3), B<wcpcpy>(3)"
msgstr "B<bcopy>(3), B<memccpy>(3), B<memcpy>(3), B<memmove>(3), B<stpncpy>(3), B<strcpy>(3), B<string>(3), B<wcpcpy>(3)"

#. type: TH
#: man-pages/man3/seekdir.3:31
#, no-wrap
msgid "SEEKDIR"
msgstr "SEEKDIR"

#. type: TH
#: man-pages/man3/seekdir.3:31
#, no-wrap
msgid "2013-09-09"
msgstr "2013-09-09"

#. type: Plain text
#: man-pages/man3/seekdir.3:35
msgid ""
"seekdir - set the position of the next readdir() call in the directory "
"stream."
msgstr "seekdir - установить позицию для последующего вызова readdir() в потоке каталога."

#. type: Plain text
#: man-pages/man3/seekdir.3:40
#, no-wrap
msgid "B<void seekdir(DIR *>I<dirp>B<, long >I<loc>B<);>\n"
msgstr "B<void seekdir(DIR *>I<dirp>B<, long >I<loc>B<);>\n"

#. type: Plain text
#: man-pages/man3/seekdir.3:49
msgid "B<seekdir>(): _BSD_SOURCE || _SVID_SOURCE || _XOPEN_SOURCE"
msgstr "B<seekdir>(): _BSD_SOURCE || _SVID_SOURCE || _XOPEN_SOURCE"

#. type: Plain text
#: man-pages/man3/seekdir.3:60
msgid ""
"The B<seekdir>()  function sets the location in the directory stream from "
"which the next B<readdir>(2)  call will start.  The I<loc> argument should "
"be a value returned by a previous call to B<telldir>(3)."
msgstr ""

#. type: Plain text
#: man-pages/man3/seekdir.3:64
msgid "The B<seekdir>()  function returns no value."
msgstr "Функция B<seekdir>() не возвращает никаких значений."

#. type: Plain text
#: man-pages/man3/seekdir.3:69
msgid "The B<seekdir>()  function is thread-safe."
msgstr ""

#. type: Plain text
#: man-pages/man3/seekdir.3:83
msgid ""
"In glibc up to version 2.1.1, the type of the I<loc> argument was I<off_t>."
"  POSIX.1-2001 specifies I<long>, and this is the type used since glibc "
"2.1.2.  See B<telldir>(3)  for information on why you should be careful in "
"making any assumptions about the value in this argument."
msgstr ""

#. type: Plain text
#: man-pages/man3/seekdir.3:90
msgid ""
"B<lseek>(2), B<closedir>(3), B<opendir>(3), B<readdir>(3), B<rewinddir>(3), "
"B<scandir>(3), B<telldir>(3)"
msgstr "B<lseek>(2), B<closedir>(3), B<opendir>(3), B<readdir>(3), B<rewinddir>(3), B<scandir>(3), B<telldir>(3)"

#. type: TH
#: man-pages/man3/sincos.3:9
#, no-wrap
msgid "SINCOS"
msgstr "SINCOS"

#. type: TH
#: man-pages/man3/sincos.3:9
#, no-wrap
msgid "2013-12-23"
msgstr "2013-12-23"

#. type: Plain text
#: man-pages/man3/sincos.3:12
msgid "sincos, sincosf, sincosl - calculate sin and cos simultaneously"
msgstr "sincos, sincosf, sincosl - одновременное вычисление синуса и косинуса"

#. type: Plain text
#: man-pages/man3/sincos.3:16
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>         /* See feature_test_macros(7) */\n"
"B<#include E<lt>math.hE<gt>>\n"
msgstr "B<#define _GNU_SOURCE>         /* см. feature_test_macros(7) */\nB<#include E<lt>math.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/sincos.3:18
#, no-wrap
msgid "B<void sincos(double >I<x>B<, double *>I<sin>B<, double *>I<cos>B<);>\n"
msgstr "B<void sincos(double >I<x>B<, double *>I<sin>B<, double *>I<cos>B<);>\n"

#. type: Plain text
#: man-pages/man3/sincos.3:20
#, no-wrap
msgid "B<void sincosf(float >I<x>B<, float *>I<sin>B<, float *>I<cos>B<);>\n"
msgstr "B<void sincosf(float >I<x>B<, float *>I<sin>B<, float *>I<cos>B<);>\n"

#. type: Plain text
#: man-pages/man3/sincos.3:22
#, no-wrap
msgid ""
"B<void sincosl(long double >I<x>B<, long double *>I<sin>B<, long double "
"*>I<cos>B<);>\n"
msgstr "B<void sincosl(long double >I<x>B<, long double *>I<sin>B<, long double *>I<cos>B<);>\n"

#. type: Plain text
#: man-pages/man3/sincos.3:32
msgid ""
"Several applications need sine and cosine of the same angle I<x>.  This "
"function computes both at the same time, and stores the results in I<*sin> "
"and I<*cos>."
msgstr "Некоторым приложениям необходимы значения синуса и косинуса одного и того же угла I<x>. Данная функция вычисляет одновременно оба значения и сохраняет результаты в I<*sin> и I<*cos>."

#. type: Plain text
#: man-pages/man3/sincos.3:40
msgid "If I<x> is a NaN, a NaN is returned in I<*sin> and I<*cos>."
msgstr "Если I<x> имеет значение NaN, будет возвращено NaN для I<*sin> и I<*cos>."

#. type: Plain text
#: man-pages/man3/sincos.3:49
msgid ""
"If I<x> is positive infinity or negative infinity, a domain error occurs, "
"and a NaN is returned in I<*sin> and I<*cos>."
msgstr "Если I<x> стремится к плюс бесконечности или минус бесконечности, то будет сгенерирована ошибка выхода за пределы области, а в качестве результата в I<*sin> and I<*cos> будет возвращено NaN."

#. type: Plain text
#: man-pages/man3/sincos.3:52
msgid "These functions return I<void>."
msgstr "Эти функции возвращают I<void>."

#.  .I errno
#.  is set to
#.  .BR EDOM .
#. type: Plain text
#: man-pages/man3/sincos.3:67
msgid "An invalid floating-point exception (B<FE_INVALID>)  is raised."
msgstr "Возникает исключение неправильной плавающей точки (B<FE_INVALID>)."

#.  FIXME . Is it intentional that these functions do not set errno?
#.  sin() and cos() also don't set errno; bugs have been raised for
#.  those functions.
#.  See https://www.sourceware.org/bugzilla/show_bug.cgi?id=15467
#. type: Plain text
#: man-pages/man3/sincos.3:74
msgid "These functions do not set I<errno>."
msgstr "Эти функции не изменяют I<errno>."

#. type: Plain text
#: man-pages/man3/sincos.3:76
msgid "These functions first appeared in glibc in version 2.1."
msgstr "Эти функции впервые появились в glibc 2.1."

#. type: Plain text
#: man-pages/man3/sincos.3:84
msgid ""
"The B<sincos>(), B<sincosf>(), and B<sincosl>()  functions are thread-safe."
msgstr "Функции B<sincos>(), B<sincosf>() и B<sincosl>() можно использовать в нескольких нитях одновременно."

#. type: Plain text
#: man-pages/man3/sincos.3:86
msgid "This function is a GNU extension."
msgstr "Эта функция является расширением GNU."

#. type: Plain text
#: man-pages/man3/sincos.3:89
msgid "B<cos>(3), B<sin>(3), B<tan>(3)"
msgstr "B<cos>(3), B<sin>(3), B<tan>(3)"

#. type: TH
#: man-pages/man3/strfry.3:30
#, no-wrap
msgid "STRFRY"
msgstr "STRFRY"

#. type: Plain text
#: man-pages/man3/strfry.3:33
msgid "strfry - randomize a string"
msgstr ""

#. type: Plain text
#: man-pages/man3/strfry.3:36
#, no-wrap
msgid "B<#define _GNU_SOURCE>         /* See feature_test_macros(7) */\n"
msgstr "B<#define _GNU_SOURCE>         /* см. feature_test_macros(7) */\n"

#. type: Plain text
#: man-pages/man3/strfry.3:40
#, no-wrap
msgid "B<char *strfry(char *>I<string>B<);>\n"
msgstr "B<char *strfry(char *>I<string>B<);>\n"

#. type: Plain text
#: man-pages/man3/strfry.3:52
msgid ""
"The B<strfry>()  function randomizes the contents of I<string> by using "
"B<rand>(3)  to randomly swap characters in the string.  The result is an "
"anagram of I<string>."
msgstr ""

#. type: Plain text
#: man-pages/man3/strfry.3:57
msgid "The B<strfry>()  functions returns a pointer to the randomized string."
msgstr ""

#. type: Plain text
#: man-pages/man3/strfry.3:62
msgid "The B<strfry>()  function is unique to the GNU C Library."
msgstr "Функция B<strfry>() есть только в библиотеке GNU C."

#. type: Plain text
#: man-pages/man3/strfry.3:64
msgid "B<memfrob>(3), B<string>(3)"
msgstr "B<memfrob>(3), B<string>(3)"

#. type: TH
#: man-pages/man3/strxfrm.3:30
#, no-wrap
msgid "STRXFRM"
msgstr "STRXFRM"

#. type: TH
#: man-pages/man3/strxfrm.3:30
#, no-wrap
msgid "2012-05-10"
msgstr "2012-05-10"

#. type: Plain text
#: man-pages/man3/strxfrm.3:33
msgid "strxfrm - string transformation"
msgstr "strxfrm - преобразование строки"

#. type: Plain text
#: man-pages/man3/strxfrm.3:38
#, no-wrap
msgid ""
"B<size_t strxfrm(char *>I<dest>B<, const char *>I<src>B<, size_t "
">I<n>B<);>\n"
msgstr "B<size_t strxfrm(char *>I<dest>B<, const char *>I<src>B<, size_t >I<n>B<);>\n"

#. type: Plain text
#: man-pages/man3/strxfrm.3:62
msgid ""
"The B<strxfrm>()  function transforms the I<src> string into a form such "
"that the result of B<strcmp>(3)  on two strings that have been transformed "
"with B<strxfrm>()  is the same as the result of B<strcoll>(3)  on the two "
"strings before their transformation.  The first I<n> bytes of the "
"transformed string are placed in I<dest>.  The transformation is based on "
"the program's current locale for category B<LC_COLLATE>.  (See "
"B<setlocale>(3))."
msgstr "Функция B<strxfrm>() преобразует строку I<src> в такую форму, что выполнение B<strcmp>(3) над двумя такими строками, преобразованными посредством B<strxfrm>(), будет таким же, как и выполнение B<strcoll>(3) над строками до преобразования. Первые I<n> байт преобразованной строки помещаются в I<dest>. Преобразование основывается на настройках категории текущей локали B<LC_COLLATE> программы (смотрите B<setlocale>(3))."

#. type: Plain text
#: man-pages/man3/strxfrm.3:76
msgid ""
"The B<strxfrm>()  function returns the number of bytes required to store the"
" transformed string in I<dest> excluding the terminating null byte "
"(\\(aq\\e0\\(aq).  If the value returned is I<n> or more, the contents of "
"I<dest> are indeterminate."
msgstr "Функция B<strxfrm>() возвращает количество байт, необходимое для размещения преобразованной строки в I<dest> без завершающего байта null («\\e0»). Если возвращённое значение равно I<n> или больше этой величины, то содержимое I<dest> не определено."

#. type: Plain text
#: man-pages/man3/strxfrm.3:88
msgid ""
"In the I<POSIX> or I<C> locales B<strxfrm>()  is equivalent to copying the "
"string with B<strncpy>(3)."
msgstr "В локалях I<POSIX> или I<C> выполнение функции B<strxfrm>() эквивалентно копированию строки с помощью B<strncpy>(3)."

#. type: Plain text
#: man-pages/man3/strxfrm.3:95
msgid ""
"B<bcmp>(3), B<memcmp>(3), B<setlocale>(3), B<strcasecmp>(3), B<strcmp>(3), "
"B<strcoll>(3), B<string>(3)"
msgstr "B<bcmp>(3), B<memcmp>(3), B<setlocale>(3), B<strcasecmp>(3), B<strcmp>(3), B<strcoll>(3), B<string>(3)"

#. type: TH
#: man-pages/man3/strstr.3:33
#, no-wrap
msgid "STRSTR"
msgstr "STRSTR"

#. type: Plain text
#: man-pages/man3/strstr.3:36
msgid "strstr, strcasestr - locate a substring"
msgstr "strstr, strcasestr - поиск подстроки"

#. type: Plain text
#: man-pages/man3/strstr.3:41
#, no-wrap
msgid "B<char *strstr(const char *>I<haystack>B<, const char *>I<needle>B<);>\n"
msgstr "B<char *strstr(const char *>I<haystack>B<, const char *>I<needle>B<);>\n"

#. type: Plain text
#: man-pages/man3/strstr.3:47
#, no-wrap
msgid ""
"B<char *strcasestr(const char *>I<haystack>B<, const char *>I<needle>B<);>\n"
msgstr "B<char *strcasestr(const char *>I<haystack>B<, const char *>I<needle>B<);>\n"

#. type: Plain text
#: man-pages/man3/strstr.3:56
msgid ""
"The B<strstr>()  function finds the first occurrence of the substring "
"I<needle> in the string I<haystack>.  The terminating null bytes "
"(\\(aq\\e0\\(aq) are not compared."
msgstr "Функция B<strstr>() ищет первое соответствие подстроки I<needle> в строке I<haystack>. Конечные байты null (\\(aq\\e0\\(aq) не сравниваются."

#. type: Plain text
#: man-pages/man3/strstr.3:62
msgid ""
"The B<strcasestr>()  function is like B<strstr>(), but ignores the case of "
"both arguments."
msgstr "B<strcasestr>() аналогична B<strstr>(), но при этом игнорируется регистр обеих строк."

#. type: Plain text
#: man-pages/man3/strstr.3:65
msgid ""
"These functions return a pointer to the beginning of the located substring, "
"or NULL if the substring is not found."
msgstr "Данные функции возвращают указатель на начало найденной подстроки или NULL, если подстрока не найдена."

#. type: Plain text
#: man-pages/man3/strstr.3:70
msgid "The B<strstr>()  function is thread-safe."
msgstr "Функцию B<strstr>() можно использовать в нескольких нитях одновременно."

#. type: Plain text
#: man-pages/man3/strstr.3:77
msgid ""
"The B<strcasestr>()  function is thread-safe with exceptions.  It can be "
"safely used in multithreaded applications, as long as B<setlocale>(3)  is "
"not called to change the locale during its execution."
msgstr "Функцию B<strcasestr>() можно использовать в нескольких нитях одновременно с несколькими исключениями. Эту функцию можно использовать в многонитевых приложениях, если во время её работы не вызывать B<setlocale>(3)."

#. type: Plain text
#: man-pages/man3/strstr.3:84
msgid ""
"The B<strstr>()  function conforms to C89 and C99.  The B<strcasestr>()  "
"function is a nonstandard extension."
msgstr "Функция B<strstr>() соответствует C89 и C99. B<strcasestr>() является нестандартизованным расширением."

#. type: Plain text
#: man-pages/man3/strstr.3:96
msgid ""
"Early versions of Linux libc (like 4.5.26) would not allow an empty "
"I<needle> argument for B<strstr>().  Later versions (like 4.6.27) work "
"correctly, and return I<haystack> when I<needle> is empty."
msgstr "Ранние версии Linux libc (например, 4.5.26) могут не допускать пустой аргумент I<needle> для B<strstr>(). Поздние версии (например, 4.6.27) работают корректно и возвращают I<haystack> при пустом I<needle>."

#. type: Plain text
#: man-pages/man3/strstr.3:107
msgid ""
"B<index>(3), B<memchr>(3), B<rindex>(3), B<strcasecmp>(3), B<strchr>(3), "
"B<string>(3), B<strpbrk>(3), B<strsep>(3), B<strspn>(3), B<strtok>(3), "
"B<wcsstr>(3)"
msgstr "B<index>(3), B<memchr>(3), B<rindex>(3), B<strcasecmp>(3), B<strchr>(3), B<string>(3), B<strpbrk>(3), B<strsep>(3), B<strspn>(3), B<strtok>(3), B<wcsstr>(3)"

#. type: TH
#: man-pages/man3/strcat.3:32
#, no-wrap
msgid "STRCAT"
msgstr "STRCAT"

#. type: Plain text
#: man-pages/man3/strcat.3:35
msgid "strcat, strncat - concatenate two strings"
msgstr "strcat, strncat - объединяет две строки"

#. type: Plain text
#: man-pages/man3/strcat.3:40
#, no-wrap
msgid "B<char *strcat(char *>I<dest>B<, const char *>I<src>B<);>\n"
msgstr "B<char *strcat(char *>I<dest>B<, const char *>I<src>B<);>\n"

#. type: Plain text
#: man-pages/man3/strcat.3:42
#, no-wrap
msgid ""
"B<char *strncat(char *>I<dest>B<, const char *>I<src>B<, size_t >I<n>B<);>\n"
msgstr "B<char *strncat(char *>I<dest>B<, const char *>I<src>B<, size_t >I<n>B<);>\n"

#. type: Plain text
#: man-pages/man3/strcat.3:62
msgid ""
"The B<strcat>()  function appends the I<src> string to the I<dest> string, "
"overwriting the terminating null byte (\\(aq\\e0\\(aq) at the end of "
"I<dest>, and then adds a terminating null byte.  The strings may not "
"overlap, and the I<dest> string must have enough space for the result.  If "
"I<dest> is not large enough, program behavior is unpredictable; I<buffer "
"overruns are a favorite avenue for attacking secure programs>."
msgstr "Функция B<strcat>() добавляет строку I<src> к строке I<dest>, перезаписывая байт null (\\(aq\\e0\\(aq) в конце I<dest> и добавляет завершающий байт null. Строки не могут перекрываться, а в строке I<dest> должно хватать свободного места для размещения объединённой строки. Если размер I<dest> мал, то поведение программы непредсказуемо; I<переполнение буфера — любимое средство для атаки защищённых программ>."

#. type: Plain text
#: man-pages/man3/strcat.3:66
msgid "The B<strncat>()  function is similar, except that"
msgstr "Функция B<strncat>() работает аналогичным образом, но"

#. type: Plain text
#: man-pages/man3/strcat.3:72
msgid "it will use at most I<n> bytes from I<src>; and"
msgstr "задействует не более I<n> первых байт строки I<src> и"

#. type: Plain text
#: man-pages/man3/strcat.3:77
msgid ""
"I<src> does not need to be null-terminated if it contains I<n> or more "
"bytes."
msgstr "строка I<src> может не завершаться байтом null, если в ней содержится I<n> или более байт."

#. type: Plain text
#: man-pages/man3/strcat.3:83
msgid ""
"As with B<strcat>(), the resulting string in I<dest> is always null-"
"terminated."
msgstr "Как и B<strcat>(), строка-результат в I<dest> всегда заканчивается байтом null."

#. type: Plain text
#: man-pages/man3/strcat.3:102
msgid ""
"If I<src> contains I<n> or more bytes, B<strncat>()  writes I<n+1> bytes to "
"I<dest> (I<n> from I<src> plus the terminating null byte).  Therefore, the "
"size of I<dest> must be at least I<strlen(dest)+n+1>."
msgstr "Если в I<src> содержится I<n> или более байт, то B<strncat>() записывает I<n+1> байт в I<dest> (I<n> из I<src> плюс завершающий байт null). Поэтому размер I<dest> должен быть не менее I<strlen(dest)+n+1>."

#. type: Plain text
#: man-pages/man3/strcat.3:106
msgid "A simple implementation of B<strncat>()  might be:"
msgstr "Простейшей реализацией B<strncat>() может быть:"

#. type: Plain text
#: man-pages/man3/strcat.3:114
#, no-wrap
msgid ""
"char*\n"
"strncat(char *dest, const char *src, size_t n)\n"
"{\n"
"    size_t dest_len = strlen(dest);\n"
"    size_t i;\n"
msgstr "char*\nstrncat(char *dest, const char *src, size_t n)\n{\n    size_t dest_len = strlen(dest);\n    size_t i;\n"

#. type: Plain text
#: man-pages/man3/strcat.3:118
#, no-wrap
msgid ""
"    for (i = 0 ; i E<lt> n && src[i] != \\(aq\\e0\\(aq ; i++)\n"
"        dest[dest_len + i] = src[i];\n"
"    dest[dest_len + i] = \\(aq\\e0\\(aq;\n"
msgstr "    for (i = 0 ; i E<lt> n && src[i] != \\(aq\\e0\\(aq ; i++)\n        dest[dest_len + i] = src[i];\n    dest[dest_len + i] = \\(aq\\e0\\(aq;\n"

#. type: Plain text
#: man-pages/man3/strcat.3:121
#, no-wrap
msgid ""
"    return dest;\n"
"}\n"
msgstr "    return dest;\n}\n"

#. type: Plain text
#: man-pages/man3/strcat.3:130
msgid ""
"The B<strcat>()  and B<strncat>()  functions return a pointer to the "
"resulting string I<dest>."
msgstr "Функции B<strcat>() и B<strncat>() возвращают указатель на скопированную строку I<dest>."

#. type: Plain text
#: man-pages/man3/strcat.3:137
msgid "The B<strcat>()  and B<strncat>()  functions are thread-safe."
msgstr "Функции B<strcat>() и B<strncat>() можно использовать в нескольких нитях одновременно."

#. type: Plain text
#: man-pages/man3/strcat.3:141
msgid ""
"Some systems (the BSDs, Solaris, and others) provide the following function:"
msgstr "В некоторых системах (BSD, Solaris и других) есть следующая функция:"

#. type: Plain text
#: man-pages/man3/strcat.3:143
#, no-wrap
msgid "    size_t strlcat(char *dest, const char *src, size_t size);\n"
msgstr "    size_t strlcat(char *dest, const char *src, size_t size);\n"

#.  https://lwn.net/Articles/506530/
#. type: Plain text
#: man-pages/man3/strcat.3:176
msgid ""
"This function appends the null-terminated string I<src> to the string "
"I<dest>, copying at most I<size-strlen(dest)-1> from I<src>, and adds a null"
" terminator to the result, I<unless> I<size> is less than I<strlen(dest)>.  "
"This function fixes the buffer overrun problem of B<strcat>(), but the "
"caller must still handle the possibility of data loss if I<size> is too "
"small.  The function returns the length of the string B<strlcat>()  tried to"
" create; if the return value is greater than or equal to I<size>, data loss "
"occurred.  If data loss matters, the caller I<must> either check the "
"arguments before the call, or test the function return value.  B<strlcat>()"
"  is not present in glibc and is not standardized by POSIX, but is available"
" on Linux via the I<libbsd> library."
msgstr "Эта функция добавляет строку I<src>, оканчивающуюся null, к строке I<dest>, копируя не более I<size-strlen(dest)-1> байт из I<src>, и добавляет к результату конечный null, I<если> I<size> менее I<strlen(dest)>. Эта функция исправляет проблему с переполнением буфера в B<strcat>(), но вызывающий по прежнему должен рассматривать возможность потери данных, если I<size> слишком мал. Функция возвращает длину строки, которую B<strlcat>() пыталась создать; если возвращаемое значение больше или равно I<size>, то произошла потеря данных. Если потеря данных критична, то вызывающий I<должен> или проверять аргументы перед вызовом, или проверять возвращаемое функцией значение. Функция B<strlcat>() отсутствует в glibc и не стандартизована POSIX, но доступна в Linux в библиотеке I<libbsd>."

#. type: Plain text
#: man-pages/man3/strcat.3:184
msgid ""
"B<bcopy>(3), B<memccpy>(3), B<memcpy>(3), B<strcpy>(3), B<string>(3), "
"B<strncpy>(3), B<wcscat>(3), B<wcsncat>(3)"
msgstr "B<bcopy>(3), B<memccpy>(3), B<memcpy>(3), B<strcpy>(3), B<string>(3), B<strncpy>(3), B<wcscat>(3), B<wcsncat>(3)"

#. type: TH
#: man-pages/man3/setlogmask.3:25
#, no-wrap
msgid "SETLOGMASK"
msgstr "SETLOGMASK"

#. type: TH
#: man-pages/man3/setlogmask.3:25
#, no-wrap
msgid "2001-10-05"
msgstr "2001-10-05"

#. type: Plain text
#: man-pages/man3/setlogmask.3:28
msgid "setlogmask - set log priority mask"
msgstr ""

#. type: Plain text
#: man-pages/man3/setlogmask.3:31
#, no-wrap
msgid "B<#include E<lt>syslog.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/setlogmask.3:33
#, no-wrap
msgid "B<int setlogmask(int >I<mask>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/setlogmask.3:43
msgid ""
"A process has a log priority mask that determines which calls to "
"B<syslog>(3)  may be logged.  All other calls will be ignored.  Logging is "
"enabled for the priorities that have the corresponding bit set in I<mask>.  "
"The initial mask is such that logging is enabled for all priorities."
msgstr ""

#. type: Plain text
#: man-pages/man3/setlogmask.3:49
msgid ""
"The B<setlogmask>()  function sets this logmask for the calling process, and"
" returns the previous mask.  If the mask argument is 0, the current logmask "
"is not modified."
msgstr ""

#. type: Plain text
#: man-pages/man3/setlogmask.3:69
msgid ""
"The eight priorities are B<LOG_EMERG>, B<LOG_ALERT>, B<LOG_CRIT>, "
"B<LOG_ERR>, B<LOG_WARNING>, B<LOG_NOTICE>, B<LOG_INFO>, and B<LOG_DEBUG>.  "
"The bit corresponding to a priority I<p> is I<LOG_MASK(p)>.  Some systems "
"also provide a macro I<LOG_UPTO(p)> for the mask of all priorities in the "
"above list up to and including I<p>."
msgstr ""

#. type: Plain text
#: man-pages/man3/setlogmask.3:71
msgid "This function returns the previous log priority mask."
msgstr ""

#.  .SH NOTES
#.  The glibc logmask handling was broken in versions before glibc 2.1.1.
#. type: Plain text
#: man-pages/man3/setlogmask.3:75
msgid "None."
msgstr "Ничего."

#. type: Plain text
#: man-pages/man3/setlogmask.3:78
msgid "POSIX.1-2001.  Note that the description in POSIX.1-2001 is flawed."
msgstr ""

#. type: Plain text
#: man-pages/man3/setlogmask.3:81
msgid "B<closelog>(3), B<openlog>(3), B<syslog>(3)"
msgstr "B<closelog>(3), B<openlog>(3), B<syslog>(3)"

#. type: TH
#: man-pages/man3/sigwait.3:26
#, no-wrap
msgid "SIGWAIT"
msgstr "SIGWAIT"

#. type: Plain text
#: man-pages/man3/sigwait.3:29
msgid "sigwait - wait for a signal"
msgstr "sigwait - ожидание сигнала"

#. type: Plain text
#: man-pages/man3/sigwait.3:34
#, no-wrap
msgid "B< int sigwait(const sigset_t *>I<set>B<, int *>I<sig>B<);>\n"
msgstr "B< int sigwait(const sigset_t *>I<set>B<, int *>I<sig>B<);>\n"

#. type: Plain text
#: man-pages/man3/sigwait.3:44
msgid ""
"B<sigwait>(): _POSIX_C_SOURCE\\ E<gt>=\\ 1 || _XOPEN_SOURCE || _POSIX_SOURCE"
msgstr "B<sigwait>(): _POSIX_C_SOURCE\\ E<gt>=\\ 1 || _XOPEN_SOURCE || _POSIX_SOURCE"

#. type: Plain text
#: man-pages/man3/sigwait.3:56
msgid ""
"The B<sigwait>()  function suspends execution of the calling thread until "
"one of the signals specified in the signal set I<set> becomes pending.  The "
"function accepts the signal (removes it from the pending list of signals), "
"and returns the signal number in I<sig>."
msgstr ""

#. type: Plain text
#: man-pages/man3/sigwait.3:62
msgid ""
"The operation of B<sigwait>()  is the same as B<sigwaitinfo>(2), except "
"that:"
msgstr ""

#. type: Plain text
#: man-pages/man3/sigwait.3:67
msgid ""
"B<sigwait>()  returns only the signal number, rather than a I<siginfo_t> "
"structure describing the signal."
msgstr ""

#. type: Plain text
#: man-pages/man3/sigwait.3:69
msgid "The return values of the two functions are different."
msgstr ""

#. type: Plain text
#: man-pages/man3/sigwait.3:74
msgid ""
"On success, B<sigwait>()  returns 0.  On error, it returns a positive error "
"number (listed in ERRORS)."
msgstr ""

#.  Does not occur for glibc.
#. type: Plain text
#: man-pages/man3/sigwait.3:80
msgid "I<set> contains an invalid signal number."
msgstr ""

#. type: Plain text
#: man-pages/man3/sigwait.3:85
msgid "The B<sigwait>()  function is thread-safe."
msgstr ""

#. type: Plain text
#: man-pages/man3/sigwait.3:91
msgid "B<sigwait>()  is implemented using B<sigtimedwait>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man3/sigwait.3:94
msgid "See B<pthread_sigmask>(3)."
msgstr ""

#. type: Plain text
#: man-pages/man3/sigwait.3:101
msgid ""
"B<sigaction>(2), B<signalfd>(2), B<sigpending>(2), B<sigsuspend>(2), "
"B<sigwaitinfo>(2), B<sigsetops>(3), B<signal>(7)"
msgstr ""

#. type: TH
#: man-pages/man3/sem_init.3:26
#, no-wrap
msgid "SEM_INIT"
msgstr "SEM_INIT"

#. type: TH
#: man-pages/man3/sem_init.3:26
#, no-wrap
msgid "2014-03-10"
msgstr "2014-03-10"

#. type: Plain text
#: man-pages/man3/sem_init.3:29
msgid "sem_init - initialize an unnamed semaphore"
msgstr "sem_init - инициализация безымянного семафора"

#. type: Plain text
#: man-pages/man3/sem_init.3:34
#, no-wrap
msgid ""
"B<int sem_init(sem_t *>I<sem>B<, int >I<pshared>B<, unsigned int "
">I<value>B<);>\n"
msgstr "B<int sem_init(sem_t *>I<sem>B<, int >I<pshared>B<, unsigned int >I<value>B<);>\n"

#. type: Plain text
#: man-pages/man3/sem_init.3:44
msgid ""
"B<sem_init>()  initializes the unnamed semaphore at the address pointed to "
"by I<sem>.  The I<value> argument specifies the initial value for the "
"semaphore."
msgstr ""

#. type: Plain text
#: man-pages/man3/sem_init.3:49
msgid ""
"The I<pshared> argument indicates whether this semaphore is to be shared "
"between the threads of a process, or between processes."
msgstr ""

#. type: Plain text
#: man-pages/man3/sem_init.3:57
msgid ""
"If I<pshared> has the value 0, then the semaphore is shared between the "
"threads of a process, and should be located at some address that is visible "
"to all threads (e.g., a global variable, or a variable allocated dynamically"
" on the heap)."
msgstr ""

#. type: Plain text
#: man-pages/man3/sem_init.3:74
msgid ""
"If I<pshared> is nonzero, then the semaphore is shared between processes, "
"and should be located in a region of shared memory (see B<shm_open>(3), "
"B<mmap>(2), and B<shmget>(2)).  (Since a child created by B<fork>(2)  "
"inherits its parent's memory mappings, it can also access the semaphore.)  "
"Any process that can access the shared memory region can operate on the "
"semaphore using B<sem_post>(3), B<sem_wait>(3), and so on."
msgstr ""

#. type: Plain text
#: man-pages/man3/sem_init.3:77
msgid ""
"Initializing a semaphore that has already been initialized results in "
"undefined behavior."
msgstr ""

#. type: Plain text
#: man-pages/man3/sem_init.3:83
msgid ""
"B<sem_init>()  returns 0 on success; on error, -1 is returned, and I<errno> "
"is set to indicate the error."
msgstr ""

#. type: Plain text
#: man-pages/man3/sem_init.3:89
msgid "I<value> exceeds B<SEM_VALUE_MAX>."
msgstr ""

#. type: Plain text
#: man-pages/man3/sem_init.3:95
msgid ""
"I<pshared> is nonzero, but the system does not support process-shared "
"semaphores (see B<sem_overview>(7))."
msgstr ""

#. type: Plain text
#: man-pages/man3/sem_init.3:100
msgid "The B<sem_init>()  function is thread-safe."
msgstr "Функцию B<sem_init>() можно использовать в нескольких нитях одновременно."

#. type: Plain text
#: man-pages/man3/sem_init.3:107
msgid ""
"Bizarrely, POSIX.1-2001 does not specify the value that should be returned "
"by a successful call to B<sem_init>().  POSIX.1-2008 rectifies this, "
"specifying the zero return on success."
msgstr ""

#. type: Plain text
#: man-pages/man3/sem_init.3:111
msgid "B<sem_destroy>(3), B<sem_post>(3), B<sem_wait>(3), B<sem_overview>(7)"
msgstr ""

#. type: TH
#: man-pages/man3/sem_getvalue.3:26
#, no-wrap
msgid "SEM_GETVALUE"
msgstr ""

#. type: TH
#: man-pages/man3/sem_getvalue.3:26
#, no-wrap
msgid "2014-03-03"
msgstr "2014-03-03"

#. type: Plain text
#: man-pages/man3/sem_getvalue.3:29
msgid "sem_getvalue - get the value of a semaphore"
msgstr ""

#. type: Plain text
#: man-pages/man3/sem_getvalue.3:34
#, no-wrap
msgid "B<int sem_getvalue(sem_t *>I<sem>B<, int *>I<sval>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/sem_getvalue.3:43
msgid ""
"B<sem_getvalue>()  places the current value of the semaphore pointed to "
"I<sem> into the integer pointed to by I<sval>."
msgstr ""

#. type: Plain text
#: man-pages/man3/sem_getvalue.3:54
msgid ""
"If one or more processes or threads are blocked waiting to lock the "
"semaphore with B<sem_wait>(3), POSIX.1-2001 permits two possibilities for "
"the value returned in I<sval>: either 0 is returned; or a negative number "
"whose absolute value is the count of the number of processes and threads "
"currently blocked in B<sem_wait>(3).  Linux adopts the former behavior."
msgstr ""

#. type: Plain text
#: man-pages/man3/sem_getvalue.3:60
msgid ""
"B<sem_getvalue>()  returns 0 on success; on error, -1 is returned and "
"I<errno> is set to indicate the error."
msgstr ""

#. type: Plain text
#: man-pages/man3/sem_getvalue.3:70
msgid "The B<sem_getvalue>()  function is thread-safe."
msgstr ""

#. type: Plain text
#: man-pages/man3/sem_getvalue.3:76
msgid ""
"The value of the semaphore may already have changed by the time "
"B<sem_getvalue>()  returns."
msgstr ""

#. type: Plain text
#: man-pages/man3/sem_getvalue.3:79
msgid "B<sem_post>(3), B<sem_wait>(3), B<sem_overview>(7)"
msgstr ""

#. type: TH
#: man-pages/man3/sem_destroy.3:26
#, no-wrap
msgid "SEM_DESTROY"
msgstr "SEM_DESTROY"

#. type: Plain text
#: man-pages/man3/sem_destroy.3:29
msgid "sem_destroy - destroy an unnamed semaphore"
msgstr "sem_destroy - уничтожение безымянного семафора"

#. type: Plain text
#: man-pages/man3/sem_destroy.3:34
#, no-wrap
msgid "B<int sem_destroy(sem_t *>I<sem>B<);>\n"
msgstr "B<int sem_destroy(sem_t *>I<sem>B<);>\n"

#. type: Plain text
#: man-pages/man3/sem_destroy.3:41
msgid ""
"B<sem_destroy>()  destroys the unnamed semaphore at the address pointed to "
"by I<sem>."
msgstr ""

#. type: Plain text
#: man-pages/man3/sem_destroy.3:46
msgid ""
"Only a semaphore that has been initialized by B<sem_init>(3)  should be "
"destroyed using B<sem_destroy>()."
msgstr ""

#. type: Plain text
#: man-pages/man3/sem_destroy.3:51
msgid ""
"Destroying a semaphore that other processes or threads are currently blocked"
" on (in B<sem_wait>(3))  produces undefined behavior."
msgstr ""

#. type: Plain text
#: man-pages/man3/sem_destroy.3:55
msgid ""
"Using a semaphore that has been destroyed produces undefined results, until "
"the semaphore has been reinitialized using B<sem_init>(3)."
msgstr ""

#. type: Plain text
#: man-pages/man3/sem_destroy.3:61
msgid ""
"B<sem_destroy>()  returns 0 on success; on error, -1 is returned, and "
"I<errno> is set to indicate the error."
msgstr ""

#. type: Plain text
#: man-pages/man3/sem_destroy.3:71
msgid "The B<sem_destroy>()  function is thread-safe."
msgstr ""

#.  But not on NPTL, where sem_destroy () is a no-op..
#. type: Plain text
#: man-pages/man3/sem_destroy.3:79
msgid ""
"An unnamed semaphore should be destroyed with B<sem_destroy>()  before the "
"memory in which it is located is deallocated.  Failure to do this can result"
" in resource leaks on some implementations."
msgstr ""

#. type: Plain text
#: man-pages/man3/sem_destroy.3:83
msgid "B<sem_init>(3), B<sem_post>(3), B<sem_wait>(3), B<sem_overview>(7)"
msgstr "B<sem_init>(3), B<sem_post>(3), B<sem_wait>(3), B<sem_overview>(7)"

#. type: TH
#: man-pages/man3/sleep.3:26
#, no-wrap
msgid "SLEEP"
msgstr "SLEEP"

#. type: TH
#: man-pages/man3/sleep.3:26
#, no-wrap
msgid "2010-02-03"
msgstr "2010-02-03"

#. type: Plain text
#: man-pages/man3/sleep.3:29
msgid "sleep - sleep for the specified number of seconds"
msgstr "sleep - приостанавливает выполнение на заданное число секунд"

#. type: Plain text
#: man-pages/man3/sleep.3:34
#, no-wrap
msgid "B<unsigned int sleep(unsigned int >I<seconds>B<);>\n"
msgstr "B<unsigned int sleep(unsigned int >I<seconds>B<);>\n"

#. type: Plain text
#: man-pages/man3/sleep.3:40
msgid ""
"B<sleep>()  makes the calling thread sleep until I<seconds> seconds have "
"elapsed or a signal arrives which is not ignored."
msgstr "B<sleep>() заставляет работающую нить заснуть, пока не пройдёт I<seconds> секунд или пока не поступит сигнал, который невозможно проигнорировать."

#. type: Plain text
#: man-pages/man3/sleep.3:44
msgid ""
"Zero if the requested time has elapsed, or the number of seconds left to "
"sleep, if the call was interrupted by a signal handler."
msgstr "Ноль, если запрошенное время истекло, или число секунд, оставшихся до пробуждения в случае, когда вызов был прерван обработчиком сигнала."

#. type: Plain text
#: man-pages/man3/sleep.3:55
msgid ""
"B<sleep>()  may be implemented using B<SIGALRM>; mixing calls to B<alarm>(2)"
"  and B<sleep>()  is a bad idea."
msgstr "Функция B<sleep>() может быть реализована с помощью B<SIGALRM>; лучше не смешивать вызовы B<alarm>(2) и B<sleep>()."

#. type: Plain text
#: man-pages/man3/sleep.3:61
msgid ""
"Using B<longjmp>(3)  from a signal handler or modifying the handling of "
"B<SIGALRM> while sleeping will cause undefined results."
msgstr "Использование B<longjmp>(3) из обработчика сигнала или изменение обработки B<SIGALRM> в момент сна может привести к непредсказуемым результатам."

#. type: Plain text
#: man-pages/man3/sleep.3:65
msgid "B<alarm>(2), B<nanosleep>(2), B<signal>(2), B<signal>(7)"
msgstr "B<alarm>(2), B<nanosleep>(2), B<signal>(2), B<signal>(7)"

#. type: TH
#: man-pages/man3/setjmp.3:27
#, no-wrap
msgid "SETJMP"
msgstr "SETJMP"

#. type: Plain text
#: man-pages/man3/setjmp.3:30
msgid "setjmp, sigsetjmp - save stack context for nonlocal goto"
msgstr ""

#. type: Plain text
#: man-pages/man3/setjmp.3:32
msgid "B<#include E<lt>setjmp.hE<gt>>"
msgstr "B<#include E<lt>setjmp.hE<gt>>"

#. type: Plain text
#: man-pages/man3/setjmp.3:35
#, no-wrap
msgid "B<int setjmp(jmp_buf >I<env>B<);>\n"
msgstr "B<int setjmp(jmp_buf >I<env>B<);>\n"

#. type: Plain text
#: man-pages/man3/setjmp.3:37
#, no-wrap
msgid "B<int sigsetjmp(sigjmp_buf >I<env>B<, int >I<savesigs>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/setjmp.3:46
msgid "B<setjmp>(): see NOTES."
msgstr ""

#. type: Plain text
#: man-pages/man3/setjmp.3:49
msgid ""
"B<sigsetjmp>(): _POSIX_C_SOURCE\\ E<gt>=\\ 1 || _XOPEN_SOURCE || "
"_POSIX_C_SOURCE"
msgstr "B<sigsetjmp>(): _POSIX_C_SOURCE\\ E<gt>=\\ 1 || _XOPEN_SOURCE || _POSIX_C_SOURCE"

#. type: Plain text
#: man-pages/man3/setjmp.3:65
msgid ""
"B<setjmp>()  and B<longjmp>(3)  are useful for dealing with errors and "
"interrupts encountered in a low-level subroutine of a program.  B<setjmp>()"
"  saves the stack context/environment in I<env> for later use by "
"B<longjmp>(3).  The stack context will be invalidated if the function which "
"called B<setjmp>()  returns."
msgstr ""

#. type: Plain text
#: man-pages/man3/setjmp.3:78
msgid ""
"B<sigsetjmp>()  is similar to B<setjmp>().  If, and only if, I<savesigs> is "
"nonzero, the process's current signal mask is saved in I<env> and will be "
"restored if a B<siglongjmp>(3)  is later performed with this I<env>."
msgstr ""

#. type: Plain text
#: man-pages/man3/setjmp.3:88
msgid ""
"B<setjmp>()  and B<sigsetjmp>()  return 0 if returning directly, and nonzero"
" when returning from B<longjmp>(3)  or B<siglongjmp>(3)  using the saved "
"context."
msgstr ""

#. type: Plain text
#: man-pages/man3/setjmp.3:93
msgid ""
"C89, C99, and POSIX.1-2001 specify B<setjmp>().  POSIX.1-2001 specifies "
"B<sigsetjmp>()."
msgstr "Функция B<setjmp>() описана в C89, C99 и POSIX.1-2001. В POSIX.1-2001 определена функция B<sigsetjmp>()."

#. type: Plain text
#: man-pages/man3/setjmp.3:129
msgid ""
"POSIX does not specify whether B<setjmp>()  will save the signal mask (to be"
" later restored during B<longjmp>(3)).  In System V it will not.  In 4.3BSD "
"it will, and there is a function B<_setjmp> that will not.  On Linux with "
"glibc versions before 2.19, B<setjmp>()  follows the System V behavior by "
"default, but the BSD behavior is provided if the B<_BSD_SOURCE> feature test"
" macro is defined and none of B<_POSIX_SOURCE>, B<_POSIX_C_SOURCE>, "
"B<_XOPEN_SOURCE>, B<_XOPEN_SOURCE_EXTENDED>, B<_GNU_SOURCE>, or "
"B<_SVID_SOURCE> is defined.  Since glibc 2.19, I<E<lt>setjmp.hE<gt>> exposes"
" only the System V version of B<setjmp>().  Programs that need the BSD "
"semantics should replace calls to B<setjmp>()  with calls to B<sigsetjmp>()"
"  with a nonzero I<savesigs> argument."
msgstr ""

#. type: Plain text
#: man-pages/man3/setjmp.3:134
msgid ""
"If you want to portably save and restore signal masks, use B<sigsetjmp>()  "
"and B<siglongjmp>(3)."
msgstr ""

#. type: Plain text
#: man-pages/man3/setjmp.3:141
msgid ""
"B<setjmp>()  and B<sigsetjmp>()  make programs hard to understand and "
"maintain.  If possible, an alternative should be used."
msgstr ""

#. type: Plain text
#: man-pages/man3/setjmp.3:143
msgid "B<longjmp>(3), B<siglongjmp>(3)"
msgstr "B<longjmp>(3), B<siglongjmp>(3)"

#. type: TH
#: man-pages/man3/sigpause.3:25
#, no-wrap
msgid "SIGPAUSE"
msgstr ""

#. type: Plain text
#: man-pages/man3/sigpause.3:28
msgid "sigpause - atomically release blocked signals and wait for interrupt"
msgstr ""

#. type: Plain text
#: man-pages/man3/sigpause.3:33
#, no-wrap
msgid "B<int sigpause(int >I<sigmask>B<);  /* BSD (but see NOTES) */>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/sigpause.3:35
#, no-wrap
msgid "B<int sigpause(int >I<sig>B<);      /* System V / UNIX 95 */>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/sigpause.3:41
msgid "Don't use this function.  Use B<sigsuspend>(2)  instead."
msgstr ""

#. type: Plain text
#: man-pages/man3/sigpause.3:48
msgid ""
"The function B<sigpause>()  is designed to wait for some signal.  It changes"
" the process's signal mask (set of blocked signals), and then waits for a "
"signal to arrive.  Upon arrival of a signal, the original signal mask is "
"restored."
msgstr ""

#. type: Plain text
#: man-pages/man3/sigpause.3:56
msgid ""
"If B<sigpause>()  returns, it was interrupted by a signal and the return "
"value is -1 with I<errno> set to B<EINTR>."
msgstr ""

#. type: Plain text
#: man-pages/man3/sigpause.3:61
msgid "The B<sigpause>()  function is thread-safe."
msgstr "Функцию B<sigpause>() можно использовать в нескольких нитях одновременно."

#. type: Plain text
#: man-pages/man3/sigpause.3:65
msgid ""
"The System V version of B<sigpause>()  is standardized in POSIX.1-2001."
msgstr ""

#.  __xpg_sigpause: UNIX 95, spec 1170, SVID, SVr4, XPG
#. type: Plain text
#: man-pages/man3/sigpause.3:82
msgid ""
"The classical BSD version of this function appeared in 4.2BSD.  It sets the "
"process's signal mask to I<sigmask>.  UNIX 95 standardized the incompatible "
"System V version of this function, which removes only the specified signal "
"I<sig> from the process's signal mask.  The unfortunate situation with two "
"incompatible functions with the same name was solved by the "
"B<\\%sigsuspend>(2)  function, that takes a I<sigset_t\\ *> argument "
"(instead of an I<int>)."
msgstr ""

#. type: Plain text
#: man-pages/man3/sigpause.3:85
msgid ""
"On Linux, this routine is a system call only on the Sparc (sparc64)  "
"architecture."
msgstr ""

#. type: Plain text
#: man-pages/man3/sigpause.3:87
msgid "Libc4 and libc5 know only about the BSD version."
msgstr ""

#.  For the BSD version, one usually uses a zero
#.  .I sigmask
#.  to indicate that no signals are to be blocked.
#. type: Plain text
#: man-pages/man3/sigpause.3:111
msgid ""
"Glibc uses the BSD version if the B<_BSD_SOURCE> feature test macro is "
"defined and none of B<_POSIX_SOURCE>, B<_POSIX_C_SOURCE>, B<_XOPEN_SOURCE>, "
"B<_GNU_SOURCE>, or B<_SVID_SOURCE> is defined.  Otherwise, the System V "
"version is used (and B<_XOPEN_SOURCE> must be defined to obtain the "
"declaration).  Since glibc 2.19, only the System V version is exposed by "
"I<E<lt>signal.hE<gt>>; applications that formerly used the BSD B<sigpause>()"
"  should be amended to use B<sigsuspend>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man3/sigpause.3:118
msgid ""
"B<kill>(2), B<sigaction>(2), B<sigprocmask>(2), B<sigsuspend>(2), "
"B<sigblock>(3), B<sigvec>(3), B<feature_test_macros>(7)"
msgstr ""

#. type: TH
#: man-pages/man3/strtod.3:45
#, no-wrap
msgid "STRTOD"
msgstr "STRTOD"

#. type: Plain text
#: man-pages/man3/strtod.3:48
msgid ""
"strtod, strtof, strtold - convert ASCII string to floating-point number"
msgstr "strtod, strtof, strtold - конвертировать строку ASCII в число с плавающей точкой"

#. type: Plain text
#: man-pages/man3/strtod.3:50
msgid "B<#include E<lt>stdlib.hE<gt>>"
msgstr "B<#include E<lt>stdlib.hE<gt>>"

#. type: Plain text
#: man-pages/man3/strtod.3:52
msgid "B<double strtod(const char *>I<nptr>B<, char **>I<endptr>B<);>"
msgstr "B<double strtod(const char *>I<nptr>B<, char **>I<endptr>B<);>"

#. type: Plain text
#: man-pages/man3/strtod.3:54
msgid "B<float strtof(const char *>I<nptr>B<, char **>I<endptr>B<);>"
msgstr "B<float strtof(const char *>I<nptr>B<, char **>I<endptr>B<);>"

#. type: Plain text
#: man-pages/man3/strtod.3:56
msgid "B<long double strtold(const char *>I<nptr>B<, char **>I<endptr>B<);>"
msgstr "B<long double strtold(const char *>I<nptr>B<, char **>I<endptr>B<);>"

#. type: Plain text
#: man-pages/man3/strtod.3:65
msgid "B<strtof>(), B<strtold>():"
msgstr "B<strtof>(), B<strtold>():"

#. type: Plain text
#: man-pages/man3/strtod.3:87
msgid ""
"The B<strtod>(), B<strtof>(), and B<strtold>()  functions convert the "
"initial portion of the string pointed to by I<nptr> to I<double>, I<float>, "
"and I<long double> representation, respectively."
msgstr ""

#. type: Plain text
#: man-pages/man3/strtod.3:94
msgid ""
"The expected form of the (initial portion of the) string is optional leading"
" white space as recognized by B<isspace>(3), an optional plus (\\(aq+\\(aq) "
"or minus sign (\\(aq-\\(aq) and then either (i) a decimal number, or (ii) a "
"hexadecimal number, or (iii) an infinity, or (iv) a NAN (not-a-number)."
msgstr ""

#. type: Plain text
#: man-pages/man3/strtod.3:103
msgid ""
"A I<decimal number> consists of a nonempty sequence of decimal digits "
"possibly containing a radix character (decimal point, locale-dependent, "
"usually \\(aq.\\(aq), optionally followed by a decimal exponent.  A decimal "
"exponent consists of an \\(aqE\\(aq or \\(aqe\\(aq, followed by an optional "
"plus or minus sign, followed by a nonempty sequence of decimal digits, and "
"indicates multiplication by a power of 10."
msgstr ""

#. type: Plain text
#: man-pages/man3/strtod.3:114
msgid ""
"A I<hexadecimal number> consists of a \"0x\" or \"0X\" followed by a "
"nonempty sequence of hexadecimal digits possibly containing a radix "
"character, optionally followed by a binary exponent.  A binary exponent "
"consists of a \\(aqP\\(aq or \\(aqp\\(aq, followed by an optional plus or "
"minus sign, followed by a nonempty sequence of decimal digits, and indicates"
" multiplication by a power of 2.  At least one of radix character and binary"
" exponent must be present."
msgstr ""

#. type: Plain text
#: man-pages/man3/strtod.3:118
msgid "An I<infinity> is either \"INF\" or \"INFINITY\", disregarding case."
msgstr ""

#.  From glibc 2.8's stdlib/strtod_l.c:
#.      We expect it to be a number which is put in the
#.      mantissa of the number.
#. type: Plain text
#: man-pages/man3/strtod.3:128
msgid ""
"A I<NAN> is \"NAN\" (disregarding case) optionally followed by \\(aq(\\(aq, "
"a sequence of characters, followed by \\(aq)\\(aq.  The character string "
"specifies in an implementation-dependent way the type of NAN."
msgstr ""

#. type: Plain text
#: man-pages/man3/strtod.3:130
msgid "These functions return the converted value, if any."
msgstr ""

#. type: Plain text
#: man-pages/man3/strtod.3:137
msgid ""
"If I<endptr> is not NULL, a pointer to the character after the last "
"character used in the conversion is stored in the location referenced by "
"I<endptr>."
msgstr ""

#. type: Plain text
#: man-pages/man3/strtod.3:142
msgid ""
"If no conversion is performed, zero is returned and the value of I<nptr> is "
"stored in the location referenced by I<endptr>."
msgstr ""

#. type: Plain text
#: man-pages/man3/strtod.3:156
msgid ""
"If the correct value would cause overflow, plus or minus B<HUGE_VAL> "
"(B<HUGE_VALF>, B<HUGE_VALL>)  is returned (according to the sign of the "
"value), and B<ERANGE> is stored in I<errno>.  If the correct value would "
"cause underflow, zero is returned and B<ERANGE> is stored in I<errno>."
msgstr ""

#. type: Plain text
#: man-pages/man3/strtod.3:160
msgid "Overflow or underflow occurred."
msgstr ""

#. type: Plain text
#: man-pages/man3/strtod.3:172
msgid ""
"The B<strtod>(), B<strtof>(), and B<strtold>()  functions are thread-safe "
"with exceptions.  These functions can be safely used in multithreaded "
"applications, as long as B<setlocale>(3)  is not called to change the locale"
" during their execution."
msgstr ""

#. type: Plain text
#: man-pages/man3/strtod.3:177
msgid "C89 describes B<strtod>(), C99 describes the other two functions."
msgstr ""

#. type: Plain text
#: man-pages/man3/strtod.3:186
msgid ""
"Since 0 can legitimately be returned on both success and failure, the "
"calling program should set I<errno> to 0 before the call, and then determine"
" if an error occurred by checking whether I<errno> has a nonzero value after"
" the call."
msgstr ""

#. type: Plain text
#: man-pages/man3/strtod.3:196
msgid "B<atof>(3), B<atoi>(3), B<atol>(3), B<strtol>(3), B<strtoul>(3)"
msgstr "B<atof>(3), B<atoi>(3), B<atol>(3), B<strtol>(3), B<strtoul>(3)"

#. type: TH
#: man-pages/man3/system.3:31
#, no-wrap
msgid "SYSTEM"
msgstr ""

#. type: Plain text
#: man-pages/man3/system.3:34
msgid "system - execute a shell command"
msgstr ""

#. type: Plain text
#: man-pages/man3/system.3:39
#, no-wrap
msgid "B<int system(const char *>I<command>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/system.3:50
msgid ""
"The B<system>()  library function uses B<fork>(2)  to create a child process"
" that executes the shell command specified in I<command> using B<execl>(3)  "
"as follows:"
msgstr ""

#. type: Plain text
#: man-pages/man3/system.3:52
#, no-wrap
msgid "    execl(\"/bin/sh\", \"sh\", \"-c\", command, (char *) 0);\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/system.3:55
msgid "B<system>()  returns after the command has been completed."
msgstr ""

#. type: Plain text
#: man-pages/man3/system.3:67
msgid ""
"During execution of the command, B<SIGCHLD> will be blocked, and B<SIGINT> "
"and B<SIGQUIT> will be ignored, in the process that calls B<system>()  "
"(these signals will be handled according to their defaults inside the child "
"process that executes I<command>)."
msgstr ""

#. type: Plain text
#: man-pages/man3/system.3:73
msgid ""
"If I<command> is NULL, then B<system>()  returns a status indicating whether"
" a shell is available on the system"
msgstr ""

#. type: Plain text
#: man-pages/man3/system.3:77
msgid "The return value of B<system>()  is one of the following:"
msgstr ""

#. type: Plain text
#: man-pages/man3/system.3:82
msgid ""
"If I<command> is NULL, then a nonzero value if a shell is available, or 0 if"
" no shell is available."
msgstr ""

#. type: Plain text
#: man-pages/man3/system.3:86
msgid ""
"If a child process could not be created, or its status could not be "
"retrieved, the return value is -1."
msgstr ""

#. type: Plain text
#: man-pages/man3/system.3:91
msgid ""
"If a shell could not be executed in the child process, then the return value"
" is as though the child shell terminated by calling B<_exit>(2)  with the "
"status 127."
msgstr ""

#. type: Plain text
#: man-pages/man3/system.3:98
msgid ""
"If all system calls succeed, then the return value is the termination status"
" of the child shell used to execute I<command>.  (The termination status of "
"a shell is the termination status of the last command it executes.)"
msgstr ""

#. type: Plain text
#: man-pages/man3/system.3:107
msgid ""
"In the last two cases, the return value is a \"wait status\" that can be "
"examined using the macros described in B<waitpid>(2).  (i.e., B<WIFEXITED>()"
"  B<WEXITSTATUS>()  and so on)."
msgstr ""

#. type: Plain text
#: man-pages/man3/system.3:110
msgid "B<system>()  does not affect the wait status of any other children."
msgstr ""

#. type: Plain text
#: man-pages/man3/system.3:115
msgid "The B<system>()  function is thread-safe."
msgstr ""

#. type: Plain text
#: man-pages/man3/system.3:134
msgid ""
"B<system>()  provides simplicity and convenience: it handles all of the "
"details of calling B<fork>(2), B<execl>(3), and B<waitpid>(2), as well as "
"the necessary manipulations of signals; in addition, the shell performs the "
"usual substitutions and I/O redirections for I<command>.  The main cost of "
"B<system>()  is inefficiency: additional system calls are required to create"
" the process that runs the shell and to execute the shell."
msgstr ""

#. type: Plain text
#: man-pages/man3/system.3:146
msgid ""
"If the B<_XOPEN_SOURCE> feature test macro is defined (before including "
"I<any> header files), then the macros described in B<waitpid>(2)  "
"(B<WEXITSTATUS>(), etc.) are made available when including "
"I<E<lt>stdlib.hE<gt>>."
msgstr ""

#. type: Plain text
#: man-pages/man3/system.3:157
msgid ""
"As mentioned, B<system>()  ignores B<SIGINT> and B<SIGQUIT>.  This may make "
"programs that call it from a loop uninterruptible, unless they take care "
"themselves to check the exit status of the child.  For example:"
msgstr ""

#. type: Plain text
#: man-pages/man3/system.3:162
#, no-wrap
msgid ""
"    while (something) {\n"
"        int ret = system(\"foo\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/system.3:167
#, no-wrap
msgid ""
"        if (WIFSIGNALED(ret) &&\n"
"            (WTERMSIG(ret) == SIGINT || WTERMSIG(ret) == SIGQUIT))\n"
"                break;\n"
"    }\n"
msgstr "        if (WIFSIGNALED(ret) &&\n            (WTERMSIG(ret) == SIGINT || WTERMSIG(ret) == SIGQUIT))\n                break;\n    }\n"

#. type: Plain text
#: man-pages/man3/system.3:187
msgid ""
"Do not use B<system>()  from a program with set-user-ID or set-group-ID "
"privileges, because strange values for some environment variables might be "
"used to subvert system integrity.  Use the B<exec>(3)  family of functions "
"instead, but not B<execlp>(3)  or B<execvp>(3).  B<system>()  will not, in "
"fact, work properly from programs with set-user-ID or set-group-ID "
"privileges on systems on which I</bin/sh> is bash version 2, since bash 2 "
"drops privileges on startup.  (Debian uses a modified bash which does not do"
" this when invoked as B<sh>.)"
msgstr ""

#. type: Plain text
#: man-pages/man3/system.3:201
msgid ""
"In versions of glibc before 2.1.3, the check for the availability of "
"I</bin/sh> was not actually performed if I<command> was NULL; instead it was"
" always assumed to be available, and B<system>()  always returned 1 in this "
"case.  Since glibc 2.1.3, this check is performed because, even though "
"POSIX.1-2001 requires a conforming implementation to provide a shell, that "
"shell may not be available or executable if the calling program has "
"previously called B<chroot>(2)  (which is not specified by POSIX.1-2001)."
msgstr ""

#. type: Plain text
#: man-pages/man3/system.3:207
msgid ""
"It is possible for the shell command to terminate with a status of 127, "
"which yields a B<system>()  return value that is indistinguishable from the "
"case where a shell could not be executed in the child process."
msgstr ""

#. type: Plain text
#: man-pages/man3/system.3:214
msgid ""
"B<sh>(1), B<sigaction>(2), B<sigprocmask>(2), B<fork>(2), B<wait>(2), "
"B<exec>(3), B<signal>(7)"
msgstr ""

#. type: TH
#: man-pages/man3/setnetgrent.3:10
#, no-wrap
msgid "SETNETGRENT"
msgstr ""

#. type: Plain text
#: man-pages/man3/setnetgrent.3:14
msgid ""
"setnetgrent, endnetgrent, getnetgrent, getnetgrent_r, innetgr - handle "
"network group entries"
msgstr ""

#. type: Plain text
#: man-pages/man3/setnetgrent.3:17
#, no-wrap
msgid "B<#include E<lt>netdb.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/setnetgrent.3:19
#, no-wrap
msgid "B<int setnetgrent(const char *>I<netgroup>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/setnetgrent.3:21
#, no-wrap
msgid "B<void endnetgrent(void);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/setnetgrent.3:23
#, no-wrap
msgid ""
"B<int getnetgrent(char **>I<host>B<, char **>I<user>B<, char "
"**>I<domain>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/setnetgrent.3:26
#, no-wrap
msgid ""
"B<int getnetgrent_r(char **>I<host>B<, char **>I<user>B<,>\n"
"B<                  char **>I<domain>B<, char *>I<buf>B<, size_t >I<buflen>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/setnetgrent.3:29
#, no-wrap
msgid ""
"B<int innetgr(const char *>I<netgroup>B<, const char *>I<host>B<,>\n"
"B<            const char *>I<user>B<, const char *>I<domain>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/setnetgrent.3:43
msgid ""
"B<setnetgrent>(), B<endnetgrent>(), B<getnetgrent>(), B<getnetgrent_r>(), "
"B<innetgr>(): _BSD_SOURCE || _SVID_SOURCE"
msgstr ""

#. type: Plain text
#: man-pages/man3/setnetgrent.3:57
msgid ""
"The I<netgroup> is a SunOS invention.  A netgroup database is a list of "
"string triples (I<hostname>, I<username>, I<domainname>)  or other netgroup "
"names.  Any of the elements in a triple can be empty, which means that "
"anything matches.  The functions described here allow access to the netgroup"
" databases.  The file I</etc/nsswitch.conf> defines what database is "
"searched."
msgstr ""

#. type: Plain text
#: man-pages/man3/setnetgrent.3:77
msgid ""
"The B<setnetgrent>()  call defines the netgroup that will be searched by "
"subsequent B<getnetgrent>()  calls.  The B<getnetgrent>()  function "
"retrieves the next netgroup entry, and returns pointers in I<host>, I<user>,"
" I<domain>.  A null pointer means that the corresponding entry matches any "
"string.  The pointers are valid only as long as there is no call to other "
"netgroup-related functions.  To avoid this problem you can use the GNU "
"function B<getnetgrent_r>()  that stores the strings in the supplied buffer."
"  To free all allocated buffers use B<endnetgrent>()."
msgstr ""

#. type: Plain text
#: man-pages/man3/setnetgrent.3:86
msgid ""
"In most cases you want to check only if the triplet (I<hostname>, "
"I<username>, I<domainname>)  is a member of a netgroup.  The function "
"B<innetgr>()  can be used for this without calling the above three "
"functions.  Again, a null pointer is a wildcard and matches any string.  The"
" function is thread-safe."
msgstr ""

#. type: Plain text
#: man-pages/man3/setnetgrent.3:88
msgid "These functions return 1 on success and 0 for failure."
msgstr ""

#. type: Plain text
#: man-pages/man3/setnetgrent.3:90
msgid "I</etc/netgroup>"
msgstr "I</etc/netgroup>"

#. type: Plain text
#: man-pages/man3/setnetgrent.3:92
msgid "I</etc/nsswitch.conf>"
msgstr "I</etc/nsswitch.conf>"

#.  getnetgrent_r() is on Solaris 8 and AIX 5.1, but not the BSDs.
#. type: Plain text
#: man-pages/man3/setnetgrent.3:103
msgid ""
"These functions are not in POSIX.1-2001, but B<setnetgrent>(), "
"B<endnetgrent>(), B<getnetgrent>(), and B<innetgr>()  are available on most "
"UNIX systems.  B<getnetgrent_r>()  is not widely available on other systems."
msgstr ""

#. type: Plain text
#: man-pages/man3/setnetgrent.3:107
msgid "In the BSD implementation, B<setnetgrent>()  returns void."
msgstr ""

#. type: Plain text
#: man-pages/man3/setnetgrent.3:110
msgid "B<sethostent>(3), B<setprotoent>(3), B<setservent>(3)"
msgstr ""

#. type: TH
#: man-pages/man3/sem_post.3:26
#, no-wrap
msgid "SEM_POST"
msgstr ""

#. type: Plain text
#: man-pages/man3/sem_post.3:29
msgid "sem_post - unlock a semaphore"
msgstr ""

#. type: Plain text
#: man-pages/man3/sem_post.3:34
#, no-wrap
msgid "B<int sem_post(sem_t *>I<sem>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/sem_post.3:45
msgid ""
"B<sem_post>()  increments (unlocks) the semaphore pointed to by I<sem>.  If "
"the semaphore's value consequently becomes greater than zero, then another "
"process or thread blocked in a B<sem_wait>(3)  call will be woken up and "
"proceed to lock the semaphore."
msgstr ""

#. type: Plain text
#: man-pages/man3/sem_post.3:52
msgid ""
"B<sem_post>()  returns 0 on success; on error, the value of the semaphore is"
" left unchanged, -1 is returned, and I<errno> is set to indicate the error."
msgstr ""

#.  Added in POSIX.1-2008 TC1 (Austin Interpretation 213)
#. type: Plain text
#: man-pages/man3/sem_post.3:61
msgid "The maximum allowable value for a semaphore would be exceeded."
msgstr ""

#. type: Plain text
#: man-pages/man3/sem_post.3:66
msgid "The B<sem_post>()  function is thread-safe."
msgstr ""

#. type: Plain text
#: man-pages/man3/sem_post.3:72
msgid ""
"B<sem_post>()  is async-signal-safe: it may be safely called within a signal"
" handler."
msgstr ""

#. type: Plain text
#: man-pages/man3/sem_post.3:75
msgid "See B<sem_wait>(3)."
msgstr ""

#. type: Plain text
#: man-pages/man3/sem_post.3:78
msgid "B<sem_getvalue>(3), B<sem_wait>(3), B<sem_overview>(7)"
msgstr ""

#. type: TH
#: man-pages/man3/sigqueue.3:28
#, no-wrap
msgid "SIGQUEUE"
msgstr "SIGQUEUE"

#. type: Plain text
#: man-pages/man3/sigqueue.3:31
msgid "sigqueue - queue a signal and data to a process"
msgstr "sigqueue - вставляет сигнал и данные в очередь процесса"

#. type: Plain text
#: man-pages/man3/sigqueue.3:35
msgid ""
"B<int sigqueue(pid_t >I<pid>B<, int >I<sig>B<, const union sigval "
">I<value>B<);>"
msgstr "B<int sigqueue(pid_t >I<pid>B<, int >I<sig>B<, const union sigval >I<value>B<);>"

#. type: Plain text
#: man-pages/man3/sigqueue.3:43
msgid "B<sigqueue>(): _POSIX_C_SOURCE\\ E<gt>=\\ 199309L"
msgstr "B<sigqueue>(): _POSIX_C_SOURCE\\ E<gt>=\\ 199309L"

#. type: Plain text
#: man-pages/man3/sigqueue.3:55
msgid ""
"B<sigqueue>()  sends the signal specified in I<sig> to the process whose PID"
" is given in I<pid>.  The permissions required to send a signal are the same"
" as for B<kill>(2).  As with B<kill>(2), the null signal (0) can be used to "
"check if a process with a given PID exists."
msgstr "Вызов B<sigqueue>() отправляет сигнал, указанный в I<sig>, процессу с идентификатором PID, определённом в I<pid>. Требуются определённые права для отправки сигнала, такие же как для B<kill>(2). Как и в случае с B<kill>(2), пустой сигнал (0) может использоваться для проверки того, что заданный PID вообще существует."

#. type: Plain text
#: man-pages/man3/sigqueue.3:60
msgid ""
"The I<value> argument is used to specify an accompanying item of data "
"(either an integer or a pointer value) to be sent with the signal, and has "
"the following type:"
msgstr "Аргумент I<value> используется для указания сопутствующего элемента данных (либо целого, либо указателя), отправляемых сигналу, и имеет следующий тип:"

#. type: Plain text
#: man-pages/man3/sigqueue.3:67
#, no-wrap
msgid ""
"union sigval {\n"
"    int   sival_int;\n"
"    void *sival_ptr;\n"
"};\n"
msgstr "union sigval {\n    int   sival_int;\n    void *sival_ptr;\n};\n"

#. type: Plain text
#: man-pages/man3/sigqueue.3:83
msgid ""
"If the receiving process has installed a handler for this signal using the "
"B<SA_SIGINFO> flag to B<sigaction>(2), then it can obtain this data via the "
"I<si_value> field of the I<siginfo_t> structure passed as the second "
"argument to the handler.  Furthermore, the I<si_code> field of that "
"structure will be set to B<SI_QUEUE>."
msgstr "Если у процесса, принимающего сигнал, установлен обработчик посредством B<sigaction>(2) с флагом B<SA_SIGINFO>, то он может получить данные через поле I<si_value> структуры I<siginfo_t>, передаваемой как второй аргумент для обработчика. Кроме этого, значение поля I<si_code> этой структуры будет установлено в B<SI_QUEUE>."

#. type: Plain text
#: man-pages/man3/sigqueue.3:91
msgid ""
"On success, B<sigqueue>()  returns 0, indicating that the signal was "
"successfully queued to the receiving process.  Otherwise, -1 is returned and"
" I<errno> is set to indicate the error."
msgstr "При успешном выполнении B<sigqueue>() возвращается 0, что означает, что сигнал попал в очередь принимающего процесса. При ошибке возвращается -1 и в I<errno> содержится код ошибки."

#. type: Plain text
#: man-pages/man3/sigqueue.3:98
msgid ""
"The limit of signals which may be queued has been reached.  (See "
"B<signal>(7)  for further information.)"
msgstr "Достигнуто ограничение на количество сигналов в очереди (подробней об этом смотрите в B<signal>(7))."

#. type: Plain text
#: man-pages/man3/sigqueue.3:102
msgid "I<sig> was invalid."
msgstr "Значение I<sig> некорректно."

#. type: Plain text
#: man-pages/man3/sigqueue.3:108
msgid ""
"The process does not have permission to send the signal to the receiving "
"process.  For the required permissions, see B<kill>(2)."
msgstr "Процесс не имеет прав для отправки сигнала принимающему процессу. Требуемые права смотрите в B<kill>(2)."

#. type: Plain text
#: man-pages/man3/sigqueue.3:112
msgid "No process has a PID matching I<pid>."
msgstr "Нет процесса с идентификатором PID, соответствующем указанному I<pid>."

#. type: Plain text
#: man-pages/man3/sigqueue.3:114
msgid "This system call first appeared in Linux 2.2."
msgstr "Системный вызов впервые появился в Linux 2.2."

#. type: Plain text
#: man-pages/man3/sigqueue.3:119
msgid "The B<sigqueue>()  function is thread-safe."
msgstr "Функцию B<sigqueue>() можно использовать в нескольких нитях одновременно."

#. type: Plain text
#: man-pages/man3/sigqueue.3:129
msgid ""
"If this function results in the sending of a signal to the process that "
"invoked it, and that signal was not blocked by the calling thread, and no "
"other threads were willing to handle this signal (either by having it "
"unblocked, or by waiting for it using B<sigwait>(3)), then at least some "
"signal must be delivered to this thread before this function returns."
msgstr "Если этот вызов приводит к отправке сигнала процессу, который его вызвал, и этот сигнал не заблокирован вызывающей нитью, и никакие другие нити не желают обрабатывать сигнал (либо он для них не заблокирован, либо они ожидали его с помощью B<sigwait>(3), то, по меньшей мере, сигнал должен быть доставлен этой нити до завершения этого вызова."

#. type: Plain text
#: man-pages/man3/sigqueue.3:144
msgid ""
"On Linux, this function is implemented using the B<rt_sigqueueinfo>(2)  "
"system call.  The system call differs in its third argument, which is the "
"I<siginfo_t> structure that will be supplied to the receiving process's "
"signal handler or returned by the receiving process's B<sigtimedwait>(2)  "
"call.  Inside the glibc B<sigqueue>()  wrapper, this argument, I<uinfo>, is "
"initialized as follows:"
msgstr "В Linux эта функция реализована через системный вызов B<rt_sigqueueinfo>(2). Данный системный вызов отличается от неё третьим аргументом: структура I<siginfo_t>, которая будет предоставляться обработчику сигнала принимающего процесса или возвращаться вызовом B<sigtimedwait>(2) из принимающего процесса. В обёрточной функции glibc B<sigqueue>() этот аргумент, I<uinfo>, инициализируется следующим образом:"

#. type: Plain text
#: man-pages/man3/sigqueue.3:152
#, no-wrap
msgid ""
"uinfo.si_signo = sig;      /* Argument supplied to sigqueue() */\n"
"uinfo.si_code = SI_QUEUE;\n"
"uinfo.si_pid = getpid();   /* Process ID of sender */\n"
"uinfo.si_uid = getuid();   /* Real UID of sender */\n"
"uinfo.si_value = val;      /* Argument supplied to sigqueue() */\n"
msgstr "uinfo.si_signo = sig;      /* аргумент, передаваемый в sigqueue() */\nuinfo.si_code = SI_QUEUE;\nuinfo.si_pid = getpid();   /* ID процесса отправителя */\nuinfo.si_uid = getuid();   /* реальный UID отправителя */\nuinfo.si_value = val;      /* аргумент, передаваемый в sigqueue() */\n"

#. type: Plain text
#: man-pages/man3/sigqueue.3:161
msgid ""
"B<kill>(2), B<rt_sigqueueinfo>(2), B<sigaction>(2), B<signal>(2), "
"B<pthread_sigqueue>(3), B<sigwait>(3), B<signal>(7)"
msgstr "B<kill>(2), B<rt_sigqueueinfo>(2), B<sigaction>(2), B<signal>(2), B<pthread_sigqueue>(3), B<sigwait>(3), B<signal>(7)"

#. type: TH
#: man-pages/man3/strcmp.3:32
#, no-wrap
msgid "STRCMP"
msgstr "STRCMP"

#. type: Plain text
#: man-pages/man3/strcmp.3:35
msgid "strcmp, strncmp - compare two strings"
msgstr "strcmp, strncmp - сравнивает две строки"

#. type: Plain text
#: man-pages/man3/strcmp.3:40
#, no-wrap
msgid "B<int strcmp(const char *>I<s1>B<, const char *>I<s2>B<);>\n"
msgstr "B<int strcmp(const char *>I<s1>B<, const char *>I<s2>B<);>\n"

#. type: Plain text
#: man-pages/man3/strcmp.3:42
#, no-wrap
msgid ""
"B<int strncmp(const char *>I<s1>B<, const char *>I<s2>B<, size_t "
">I<n>B<);>\n"
msgstr "B<int strncmp(const char *>I<s1>B<, const char *>I<s2>B<, size_t >I<n>B<);>\n"

#. type: Plain text
#: man-pages/man3/strcmp.3:56
msgid ""
"The B<strcmp>()  function compares the two strings I<s1> and I<s2>.  It "
"returns an integer less than, equal to, or greater than zero if I<s1> is "
"found, respectively, to be less than, to match, or be greater than I<s2>."
msgstr "Функция B<strcmp>() сравнивает строки I<s1> и I<s2>. Она возвращает целое число, которое меньше, больше нуля или равно ему, если выяснится, что I<s1> меньше, равна или больше I<s2> соответственно."

#. type: Plain text
#: man-pages/man3/strcmp.3:66
msgid ""
"The B<strncmp>()  function is similar, except it compares the only first (at"
" most)  I<n> bytes of I<s1> and I<s2>."
msgstr "Функция B<strncmp>() работает аналогичным образом, но сравниваются только первые (не более) I<n> байт строки I<s1> и I<s2>."

#. type: Plain text
#: man-pages/man3/strcmp.3:79
msgid ""
"The B<strcmp>()  and B<strncmp>()  functions return an integer less than, "
"equal to, or greater than zero if I<s1> (or the first I<n> bytes thereof) is"
" found, respectively, to be less than, to match, or be greater than I<s2>."
msgstr "Функции B<strcmp>() и B<strncmp>() возвращают целое число, которое меньше, больше нуля или равно ему, если строка I<s1> (или её первые I<n> байтов) соответственно меньше, больше или равна I<s2>."

#. type: Plain text
#: man-pages/man3/strcmp.3:86
msgid "The B<strcmp>()  and B<strncmp>()  functions are thread-safe."
msgstr "Функции B<strcmp>() и B<strncmp>() можно использовать в нескольких нитях одновременно."

#. type: Plain text
#: man-pages/man3/strcmp.3:97
msgid ""
"B<bcmp>(3), B<memcmp>(3), B<strcasecmp>(3), B<strcoll>(3), B<string>(3), "
"B<strncasecmp>(3), B<strverscmp>(3), B<wcscmp>(3), B<wcsncmp>(3)"
msgstr "B<bcmp>(3), B<memcmp>(3), B<strcasecmp>(3), B<strcoll>(3), B<string>(3), B<strncasecmp>(3), B<strverscmp>(3), B<wcscmp>(3), B<wcsncmp>(3)"

#. type: TH
#: man-pages/man3/strptime.3:31
#, no-wrap
msgid "STRPTIME"
msgstr ""

#. type: TH
#: man-pages/man3/strptime.3:31
#, no-wrap
msgid "2014-01-17"
msgstr "2014-01-17"

#. type: Plain text
#: man-pages/man3/strptime.3:34
msgid ""
"strptime - convert a string representation of time to a time tm structure"
msgstr ""

#. type: Plain text
#: man-pages/man3/strptime.3:36
msgid "B<#define _XOPEN_SOURCE> /* See feature_test_macros(7) */"
msgstr ""

#. type: Plain text
#: man-pages/man3/strptime.3:41
msgid ""
"B<char *strptime(const char *>I<s>B<, const char *>I<format>B<,> B<struct tm"
" *>I<tm>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man3/strptime.3:54
msgid ""
"The B<strptime>()  function is the converse of B<strftime>(3); it converts "
"the character string pointed to by I<s> to values which are stored in the "
"\"broken-down time\" structure pointed to by I<tm>, using the format "
"specified by I<format>."
msgstr ""

#. type: Plain text
#: man-pages/man3/strptime.3:60
msgid ""
"The broken-down time structure I<tm> is defined in I<E<lt>time.hE<gt>> as "
"follows:"
msgstr ""

#. type: Plain text
#: man-pages/man3/strptime.3:74
#, no-wrap
msgid ""
"struct tm {\n"
"    int tm_sec;    /* Seconds (0-60) */\n"
"    int tm_min;    /* Minutes (0-59) */\n"
"    int tm_hour;   /* Hours (0-23) */\n"
"    int tm_mday;   /* Day of the month (1-31) */\n"
"    int tm_mon;    /* Month (0-11) */\n"
"    int tm_year;   /* Year - 1900 */\n"
"    int tm_wday;   /* Day of the week (0-6, Sunday = 0) */\n"
"    int tm_yday;   /* Day in the year (0-365, 1 Jan = 0) */\n"
"    int tm_isdst;  /* Daylight saving time */\n"
"};\n"
msgstr "struct tm {\n    int tm_sec;    /* секунды (0-60) */\n    int tm_min;    /* минуты (0-59) */\n    int tm_hour;   /* часы (0-23) */\n    int tm_mday;   /* день месяца (1-31) */\n    int tm_mon;    /* месяц (0-11) */\n    int tm_year;   /* год - 1900 */\n    int tm_wday;   /* день недели (0-6, воскресенье = 0) */\n    int tm_yday;   /* день года (0-365, 1 января = 0) */\n    int tm_isdst;  /* летнее время */\n};\n"

#. type: Plain text
#: man-pages/man3/strptime.3:81
msgid "For more details on the I<tm> structure, see B<ctime>(3)."
msgstr ""

#. type: Plain text
#: man-pages/man3/strptime.3:99
msgid ""
"The I<format> argument is a character string that consists of field "
"descriptors and text characters, reminiscent of B<scanf>(3).  Each field "
"descriptor consists of a B<%> character followed by another character that "
"specifies the replacement for the field descriptor.  All other characters in"
" the I<format> string must have a matching character in the input string, "
"except for whitespace, which matches zero or more whitespace characters in "
"the input string.  There should be white\\%space or other alphanumeric "
"characters between any two field descriptors."
msgstr ""

#. type: Plain text
#: man-pages/man3/strptime.3:108
msgid ""
"The B<strptime>()  function processes the input string from left to right.  "
"Each of the three possible input elements (whitespace, literal, or format) "
"are handled one after the other.  If the input cannot be matched to the "
"format string, the function stops.  The remainder of the format and input "
"strings are not processed."
msgstr ""

#. type: Plain text
#: man-pages/man3/strptime.3:114
msgid ""
"The supported input field descriptors are listed below.  In case a text "
"string (such as the name of a day of the week or a month name)  is to be "
"matched, the comparison is case insensitive.  In case a number is to be "
"matched, leading zeros are permitted but not required."
msgstr ""

#. type: TP
#: man-pages/man3/strptime.3:114
#, no-wrap
msgid "B<%%>"
msgstr ""

#. type: Plain text
#: man-pages/man3/strptime.3:119
msgid "The B<%> character."
msgstr ""

#. type: TP
#: man-pages/man3/strptime.3:119
#, no-wrap
msgid "B<%a> or B<%A>"
msgstr ""

#. type: Plain text
#: man-pages/man3/strptime.3:123
msgid ""
"The name of the day of the week according to the current locale, in "
"abbreviated form or the full name."
msgstr ""

#. type: TP
#: man-pages/man3/strptime.3:123
#, no-wrap
msgid "B<%b> or B<%B> or B<%h>"
msgstr ""

#. type: Plain text
#: man-pages/man3/strptime.3:127
msgid ""
"The month name according to the current locale, in abbreviated form or the "
"full name."
msgstr ""

#. type: TP
#: man-pages/man3/strptime.3:127
#, no-wrap
msgid "B<%c>"
msgstr "B<%c>"

#. type: Plain text
#: man-pages/man3/strptime.3:130
msgid "The date and time representation for the current locale."
msgstr ""

#. type: TP
#: man-pages/man3/strptime.3:130
#, no-wrap
msgid "B<%C>"
msgstr "B<%C>"

#. type: Plain text
#: man-pages/man3/strptime.3:133
msgid "The century number (0-99)."
msgstr ""

#. type: TP
#: man-pages/man3/strptime.3:133
#, no-wrap
msgid "B<%d> or B<%e>"
msgstr ""

#. type: Plain text
#: man-pages/man3/strptime.3:136
msgid "The day of month (1-31)."
msgstr ""

#. type: TP
#: man-pages/man3/strptime.3:136
#, no-wrap
msgid "B<%D>"
msgstr "B<%D>"

#. type: Plain text
#: man-pages/man3/strptime.3:146
msgid ""
"Equivalent to B<%m/%d/%y>.  (This is the American style date, very confusing"
" to non-Americans, especially since B<%d/%m/%y> is widely used in Europe.  "
"The ISO 8601 standard format is B<%Y-%m-%d>.)"
msgstr ""

#. type: TP
#: man-pages/man3/strptime.3:146
#, no-wrap
msgid "B<%H>"
msgstr ""

#. type: Plain text
#: man-pages/man3/strptime.3:149
msgid "The hour (0-23)."
msgstr ""

#. type: TP
#: man-pages/man3/strptime.3:149
#, no-wrap
msgid "B<%I>"
msgstr "B<%I>"

#. type: Plain text
#: man-pages/man3/strptime.3:152
msgid "The hour on a 12-hour clock (1-12)."
msgstr ""

#. type: TP
#: man-pages/man3/strptime.3:152
#, no-wrap
msgid "B<%j>"
msgstr ""

#. type: Plain text
#: man-pages/man3/strptime.3:155
msgid "The day number in the year (1-366)."
msgstr ""

#. type: TP
#: man-pages/man3/strptime.3:155
#, no-wrap
msgid "B<%m>"
msgstr ""

#. type: Plain text
#: man-pages/man3/strptime.3:158
msgid "The month number (1-12)."
msgstr ""

#. type: TP
#: man-pages/man3/strptime.3:158
#, no-wrap
msgid "B<%M>"
msgstr "B<%M>"

#. type: Plain text
#: man-pages/man3/strptime.3:161
msgid "The minute (0-59)."
msgstr ""

#. type: TP
#: man-pages/man3/strptime.3:161
#, no-wrap
msgid "B<%n>"
msgstr ""

#. type: Plain text
#: man-pages/man3/strptime.3:164 man-pages/man3/strptime.3:190
msgid "Arbitrary whitespace."
msgstr ""

#. type: TP
#: man-pages/man3/strptime.3:164
#, no-wrap
msgid "B<%p>"
msgstr "B<%p>"

#. type: Plain text
#: man-pages/man3/strptime.3:168
msgid "The locale's equivalent of AM or PM.  (Note: there may be none.)"
msgstr ""

#. type: TP
#: man-pages/man3/strptime.3:168
#, no-wrap
msgid "B<%r>"
msgstr "B<%r>"

#. type: Plain text
#: man-pages/man3/strptime.3:179
msgid ""
"The 12-hour clock time (using the locale's AM or PM).  In the POSIX locale "
"equivalent to B<%I:%M:%S %p>.  If I<t_fmt_ampm> is empty in the B<LC_TIME> "
"part of the current locale, then the behavior is undefined."
msgstr ""

#. type: TP
#: man-pages/man3/strptime.3:179
#, no-wrap
msgid "B<%R>"
msgstr "B<%R>"

#. type: Plain text
#: man-pages/man3/strptime.3:183
msgid "Equivalent to B<%H:%M>."
msgstr ""

#. type: TP
#: man-pages/man3/strptime.3:183
#, no-wrap
msgid "B<%S>"
msgstr "B<%S>"

#. type: Plain text
#: man-pages/man3/strptime.3:187
msgid ""
"The second (0-60; 60 may occur for leap seconds; earlier also 61 was "
"allowed)."
msgstr ""

#. type: TP
#: man-pages/man3/strptime.3:187
#, no-wrap
msgid "B<%t>"
msgstr "B<%t>"

#. type: TP
#: man-pages/man3/strptime.3:190
#, no-wrap
msgid "B<%T>"
msgstr ""

#. type: Plain text
#: man-pages/man3/strptime.3:194
msgid "Equivalent to B<%H:%M:%S>."
msgstr ""

#. type: TP
#: man-pages/man3/strptime.3:194
#, no-wrap
msgid "B<%U>"
msgstr "B<%U>"

#. type: Plain text
#: man-pages/man3/strptime.3:198
msgid ""
"The week number with Sunday the first day of the week (0-53).  The first "
"Sunday of January is the first day of week 1."
msgstr ""

#. type: TP
#: man-pages/man3/strptime.3:198
#, no-wrap
msgid "B<%w>"
msgstr "B<%w>"

#. type: Plain text
#: man-pages/man3/strptime.3:201
msgid "The ordinal number of the day of the week (0-6), with Sunday = 0."
msgstr ""

#. type: TP
#: man-pages/man3/strptime.3:201
#, no-wrap
msgid "B<%W>"
msgstr "B<%W>"

#. type: Plain text
#: man-pages/man3/strptime.3:205
msgid ""
"The week number with Monday the first day of the week (0-53).  The first "
"Monday of January is the first day of week 1."
msgstr ""

#. type: TP
#: man-pages/man3/strptime.3:205
#, no-wrap
msgid "B<%x>"
msgstr "B<%x>"

#. type: Plain text
#: man-pages/man3/strptime.3:208
msgid "The date, using the locale's date format."
msgstr ""

#. type: TP
#: man-pages/man3/strptime.3:208
#, no-wrap
msgid "B<%X>"
msgstr "B<%X>"

#. type: Plain text
#: man-pages/man3/strptime.3:211
msgid "The time, using the locale's time format."
msgstr ""

#. type: TP
#: man-pages/man3/strptime.3:211
#, no-wrap
msgid "B<%y>"
msgstr ""

#. type: Plain text
#: man-pages/man3/strptime.3:217
msgid ""
"The year within century (0-99).  When a century is not otherwise specified, "
"values in the range 69-99 refer to years in the twentieth century "
"(1969-1999); values in the range 00-68 refer to years in the twenty-first "
"century (2000-2068)."
msgstr ""

#. type: TP
#: man-pages/man3/strptime.3:217
#, no-wrap
msgid "B<%Y>"
msgstr ""

#. type: Plain text
#: man-pages/man3/strptime.3:220
msgid "The year, including century (for example, 1991)."
msgstr ""

#. type: Plain text
#: man-pages/man3/strptime.3:226
msgid ""
"Some field descriptors can be modified by the E or O modifier characters to "
"indicate that an alternative format or specification should be used.  If the"
" alternative format or specification does not exist in the current locale, "
"the unmodified field descriptor is used."
msgstr ""

#. type: Plain text
#: man-pages/man3/strptime.3:229
msgid ""
"The E modifier specifies that the input string may contain alternative "
"locale-dependent versions of the date and time representation:"
msgstr ""

#. type: TP
#: man-pages/man3/strptime.3:229
#, no-wrap
msgid "B<%Ec>"
msgstr ""

#. type: Plain text
#: man-pages/man3/strptime.3:232
msgid "The locale's alternative date and time representation."
msgstr ""

#. type: TP
#: man-pages/man3/strptime.3:232
#, no-wrap
msgid "B<%EC>"
msgstr ""

#. type: Plain text
#: man-pages/man3/strptime.3:235
msgid ""
"The name of the base year (period) in the locale's alternative "
"representation."
msgstr ""

#. type: TP
#: man-pages/man3/strptime.3:235
#, no-wrap
msgid "B<%Ex>"
msgstr ""

#. type: Plain text
#: man-pages/man3/strptime.3:238
msgid "The locale's alternative date representation."
msgstr ""

#. type: TP
#: man-pages/man3/strptime.3:238
#, no-wrap
msgid "B<%EX>"
msgstr ""

#. type: Plain text
#: man-pages/man3/strptime.3:241
msgid "The locale's alternative time representation."
msgstr ""

#. type: TP
#: man-pages/man3/strptime.3:241
#, no-wrap
msgid "B<%Ey>"
msgstr ""

#. type: Plain text
#: man-pages/man3/strptime.3:246
msgid ""
"The offset from B<%EC> (year only) in the locale's alternative "
"representation."
msgstr ""

#. type: TP
#: man-pages/man3/strptime.3:246
#, no-wrap
msgid "B<%EY>"
msgstr ""

#. type: Plain text
#: man-pages/man3/strptime.3:249
msgid "The full alternative year representation."
msgstr ""

#. type: Plain text
#: man-pages/man3/strptime.3:252
msgid ""
"The O modifier specifies that the numerical input may be in an alternative "
"locale-dependent format:"
msgstr ""

#. type: TP
#: man-pages/man3/strptime.3:252
#, no-wrap
msgid "B<%Od> or B<%Oe>"
msgstr ""

#. type: Plain text
#: man-pages/man3/strptime.3:256
msgid ""
"The day of the month using the locale's alternative numeric symbols; leading"
" zeros are permitted but not required."
msgstr ""

#. type: TP
#: man-pages/man3/strptime.3:256
#, no-wrap
msgid "B<%OH>"
msgstr ""

#. type: Plain text
#: man-pages/man3/strptime.3:259
msgid ""
"The hour (24-hour clock) using the locale's alternative numeric symbols."
msgstr ""

#. type: TP
#: man-pages/man3/strptime.3:259
#, no-wrap
msgid "B<%OI>"
msgstr ""

#. type: Plain text
#: man-pages/man3/strptime.3:262
msgid ""
"The hour (12-hour clock) using the locale's alternative numeric symbols."
msgstr ""

#. type: TP
#: man-pages/man3/strptime.3:262
#, no-wrap
msgid "B<%Om>"
msgstr ""

#. type: Plain text
#: man-pages/man3/strptime.3:265
msgid "The month using the locale's alternative numeric symbols."
msgstr ""

#. type: TP
#: man-pages/man3/strptime.3:265
#, no-wrap
msgid "B<%OM>"
msgstr ""

#. type: Plain text
#: man-pages/man3/strptime.3:268
msgid "The minutes using the locale's alternative numeric symbols."
msgstr ""

#. type: TP
#: man-pages/man3/strptime.3:268
#, no-wrap
msgid "B<%OS>"
msgstr ""

#. type: Plain text
#: man-pages/man3/strptime.3:271
msgid "The seconds using the locale's alternative numeric symbols."
msgstr ""

#. type: TP
#: man-pages/man3/strptime.3:271
#, no-wrap
msgid "B<%OU>"
msgstr ""

#. type: Plain text
#: man-pages/man3/strptime.3:275
msgid ""
"The week number of the year (Sunday as the first day of the week)  using the"
" locale's alternative numeric symbols."
msgstr ""

#. type: TP
#: man-pages/man3/strptime.3:275
#, no-wrap
msgid "B<%Ow>"
msgstr ""

#. type: Plain text
#: man-pages/man3/strptime.3:279
#, no-wrap
msgid ""
"The ordinal number of the day of the week (Sunday=0),\n"
" using the locale's alternative numeric symbols.\n"
msgstr ""

#. type: TP
#: man-pages/man3/strptime.3:279
#, no-wrap
msgid "B<%OW>"
msgstr ""

#. type: Plain text
#: man-pages/man3/strptime.3:283
msgid ""
"The week number of the year (Monday as the first day of the week)  using the"
" locale's alternative numeric symbols."
msgstr ""

#. type: TP
#: man-pages/man3/strptime.3:283
#, no-wrap
msgid "B<%Oy>"
msgstr ""

#. type: Plain text
#: man-pages/man3/strptime.3:288
msgid ""
"The year (offset from B<%C>)  using the locale's alternative numeric "
"symbols."
msgstr ""

#. type: Plain text
#: man-pages/man3/strptime.3:302
msgid ""
"The return value of the function is a pointer to the first character not "
"processed in this function call.  In case the input string contains more "
"characters than required by the format string, the return value points right"
" after the last consumed input character.  In case the whole input string is"
" consumed, the return value points to the null byte at the end of the "
"string.  If B<strptime>()  fails to match all of the format string and "
"therefore an error occurred, the function returns NULL."
msgstr ""

#. type: Plain text
#: man-pages/man3/strptime.3:304
msgid "SUSv2, POSIX.1-2001."
msgstr "SUSv2, POSIX.1-2001."

#. type: Plain text
#: man-pages/man3/strptime.3:320
msgid ""
"In principle, this function does not initialize I<tm> but stores only the "
"values specified.  This means that I<tm> should be initialized before the "
"call.  Details differ a bit between different UNIX systems.  The glibc "
"implementation does not touch those fields which are not explicitly "
"specified, except that it recomputes the I<tm_wday> and I<tm_yday> field if "
"any of the year, month, or day elements changed."
msgstr ""

#. type: Plain text
#: man-pages/man3/strptime.3:328
msgid ""
"This function is available since libc 4.6.8.  Linux libc4 and libc5 includes"
" define the prototype unconditionally; glibc2 includes provide a prototype "
"only when B<_XOPEN_SOURCE> or B<_GNU_SOURCE> are defined."
msgstr ""

#. type: Plain text
#: man-pages/man3/strptime.3:333
msgid ""
"Before libc 5.4.13 whitespace (and the \\(aqn\\(aq and \\(aqt\\(aq "
"specifications) was not handled, no \\(aqE\\(aq and \\(aqO\\(aq locale "
"modifier characters were accepted, and the \\(aqC\\(aq specification was a "
"synonym for the \\(aqc\\(aq specification."
msgstr ""

#.  In libc4 and libc5 the code for %I is broken (fixed in glibc;
#.  %OI was fixed in glibc 2.2.4).
#. type: Plain text
#: man-pages/man3/strptime.3:342
msgid ""
"The \\(aqy\\(aq (year in century) specification is taken to specify a year "
"in the 20th century by libc4 and libc5.  It is taken to be a year in the "
"range 1950-2049 by glibc 2.0.  It is taken to be a year in 1969-2068 since "
"glibc 2.1."
msgstr ""

#. type: Plain text
#: man-pages/man3/strptime.3:351
msgid ""
"For reasons of symmetry, glibc tries to support for B<strptime>()  the same "
"format characters as for B<strftime>(3).  (In most cases, the corresponding "
"fields are parsed, but no field in I<tm> is changed.)  This leads to"
msgstr ""

#. type: TP
#: man-pages/man3/strptime.3:351
#, no-wrap
msgid "B<%F>"
msgstr "B<%F>"

#. type: Plain text
#: man-pages/man3/strptime.3:356
msgid "Equivalent to B<%Y-%m-%d>, the ISO 8601 date format."
msgstr ""

#. type: TP
#: man-pages/man3/strptime.3:356
#, no-wrap
msgid "B<%g>"
msgstr ""

#. type: Plain text
#: man-pages/man3/strptime.3:360
msgid ""
"The year corresponding to the ISO week number, but without the century "
"(0-99)."
msgstr ""

#. type: TP
#: man-pages/man3/strptime.3:360
#, no-wrap
msgid "B<%G>"
msgstr ""

#. type: Plain text
#: man-pages/man3/strptime.3:364
msgid "The year corresponding to the ISO week number.  (For example, 1991.)"
msgstr ""

#. type: TP
#: man-pages/man3/strptime.3:364
#, no-wrap
msgid "B<%u>"
msgstr ""

#. type: Plain text
#: man-pages/man3/strptime.3:367
msgid "The day of the week as a decimal number (1-7, where Monday = 1)."
msgstr ""

#. type: TP
#: man-pages/man3/strptime.3:367
#, no-wrap
msgid "B<%V>"
msgstr ""

#. type: Plain text
#: man-pages/man3/strptime.3:374
msgid ""
"The ISO 8601:1988 week number as a decimal number (1-53).  If the week "
"(starting on Monday) containing 1 January has four or more days in the new "
"year, then it is considered week 1.  Otherwise, it is the last week of the "
"previous year, and the next week is week 1."
msgstr ""

#. type: TP
#: man-pages/man3/strptime.3:374
#, no-wrap
msgid "B<%z>"
msgstr ""

#. type: Plain text
#: man-pages/man3/strptime.3:377
msgid "An RFC-822/ISO 8601 standard timezone specification."
msgstr ""

#. type: TP
#: man-pages/man3/strptime.3:377
#, no-wrap
msgid "B<%Z>"
msgstr "B<%Z>"

#. type: Plain text
#: man-pages/man3/strptime.3:380
msgid "The timezone name."
msgstr ""

#. type: Plain text
#: man-pages/man3/strptime.3:396
msgid ""
"Similarly, because of GNU extensions to B<strftime>(3), B<%k> is accepted as"
" a synonym for B<%H>, and B<%l> should be accepted as a synonym for B<%I>, "
"and B<%P> is accepted as a synonym for B<%p>.  Finally"
msgstr ""

#. type: TP
#: man-pages/man3/strptime.3:396
#, no-wrap
msgid "B<%s>"
msgstr "B<%s>"

#. type: Plain text
#: man-pages/man3/strptime.3:400
msgid ""
"The number of seconds since the Epoch, 1970-01-01 00:00:00 +0000 (UTC).  "
"Leap seconds are not counted unless leap second support is available."
msgstr ""

#. type: Plain text
#: man-pages/man3/strptime.3:403
msgid ""
"The glibc implementation does not require whitespace between two field "
"descriptors."
msgstr ""

#. type: Plain text
#: man-pages/man3/strptime.3:408
msgid ""
"The following example demonstrates the use of B<strptime>()  and "
"B<strftime>(3)."
msgstr ""

#. type: Plain text
#: man-pages/man3/strptime.3:415
#, no-wrap
msgid ""
"#define _XOPEN_SOURCE\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>time.hE<gt>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/strptime.3:421
#, no-wrap
msgid ""
"int\n"
"main(void)\n"
"{\n"
"    struct tm tm;\n"
"    char buf[255];\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/strptime.3:428
#, no-wrap
msgid ""
"    memset(&tm, 0, sizeof(struct tm));\n"
"    strptime(\"2001-11-12 18:31:01\", \"%Y-%m-%d %H:%M:%S\", &tm);\n"
"    strftime(buf, sizeof(buf), \"%d %b %Y %H:%M\", &tm);\n"
"    puts(buf);\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/strptime.3:434
msgid ""
"B<time>(2), B<getdate>(3), B<scanf>(3), B<setlocale>(3), B<strftime>(3)"
msgstr ""

#. type: TH
#: man-pages/man3/sigset.3:26
#, no-wrap
msgid "SIGSET"
msgstr ""

#. type: Plain text
#: man-pages/man3/sigset.3:29
msgid "sigset, sighold, sigrelse, sigignore - System V signal API"
msgstr ""

#. type: Plain text
#: man-pages/man3/sigset.3:35
msgid "B<sighandler_t sigset(int >I<sig>B<, sighandler_t >I<disp>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man3/sigset.3:37
msgid "B<int sighold(int >I<sig>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man3/sigset.3:39
msgid "B<int sigrelse(int >I<sig>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man3/sigset.3:41
msgid "B<int sigignore(int >I<sig>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man3/sigset.3:52
msgid "B<sigset>(), B<sighold>(), B<sigrelse>(), B<sigignore>():"
msgstr ""

#. type: Plain text
#: man-pages/man3/sigset.3:65
msgid ""
"These functions are provided in glibc as a compatibility interface for "
"programs that make use of the historical System V signal API.  This API is "
"obsolete: new applications should use the POSIX signal API (B<sigaction>(2),"
" B<sigprocmask>(2), etc.)"
msgstr ""

#. type: Plain text
#: man-pages/man3/sigset.3:74
msgid ""
"The B<sigset>()  function modifies the disposition of the signal I<sig>.  "
"The I<disp> argument can be the address of a signal handler function, or one"
" of the following constants:"
msgstr ""

#. type: TP
#: man-pages/man3/sigset.3:74
#, no-wrap
msgid "B<SIG_DFL>"
msgstr ""

#. type: Plain text
#: man-pages/man3/sigset.3:79
msgid "Reset the disposition of I<sig> to the default."
msgstr ""

#. type: TP
#: man-pages/man3/sigset.3:79
#, no-wrap
msgid "B<SIG_IGN>"
msgstr ""

#. type: Plain text
#: man-pages/man3/sigset.3:83
msgid "Ignore I<sig>."
msgstr ""

#. type: TP
#: man-pages/man3/sigset.3:83
#, no-wrap
msgid "B<SIG_HOLD>"
msgstr ""

#. type: Plain text
#: man-pages/man3/sigset.3:90
msgid ""
"Add I<sig> to the process's signal mask, but leave the disposition of I<sig>"
" unchanged."
msgstr ""

#. type: Plain text
#: man-pages/man3/sigset.3:96
msgid ""
"If I<disp> specifies the address of a signal handler, then I<sig> is added "
"to the process's signal mask during execution of the handler."
msgstr ""

#. type: Plain text
#: man-pages/man3/sigset.3:104
msgid ""
"If I<disp> was specified as a value other than B<SIG_HOLD>, then I<sig> is "
"removed from the process's signal mask."
msgstr ""

#. type: Plain text
#: man-pages/man3/sigset.3:110
msgid "The dispositions for B<SIGKILL> and B<SIGSTOP> cannot be changed."
msgstr ""

#. type: Plain text
#: man-pages/man3/sigset.3:116
msgid ""
"The B<sighold>()  function adds I<sig> to the calling process's signal mask."
msgstr ""

#. type: Plain text
#: man-pages/man3/sigset.3:122
msgid ""
"The B<sigrelse>()  function removes I<sig> from the calling process's signal"
" mask."
msgstr ""

#. type: Plain text
#: man-pages/man3/sigset.3:129
msgid ""
"The B<sigignore>()  function sets the disposition of I<sig> to B<SIG_IGN>."
msgstr ""

#. type: Plain text
#: man-pages/man3/sigset.3:145
msgid ""
"On success, B<sigset>()  returns B<SIG_HOLD> if I<sig> was blocked before "
"the call, or the signal's previous disposition if it was not blocked before "
"the call.  On error, B<sigset>()  returns -1, with I<errno> set to indicate "
"the error.  (But see BUGS below.)"
msgstr ""

#. type: Plain text
#: man-pages/man3/sigset.3:154
msgid ""
"The B<sighold>(), B<sigrelse>(), and B<sigignore>()  functions return 0 on "
"success; on error, these functions return -1 and set I<errno> to indicate "
"the error."
msgstr ""

#. type: Plain text
#: man-pages/man3/sigset.3:161
msgid ""
"For B<sigset>()  see the ERRORS under B<sigaction>(2)  and "
"B<sigprocmask>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man3/sigset.3:168
msgid ""
"For B<sighold>()  and B<sigrelse>()  see the ERRORS under B<sigprocmask>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man3/sigset.3:173
msgid "For B<sigignore>(), see the errors under B<sigaction>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man3/sigset.3:190
msgid ""
"SVr4, POSIX.1-2001.  These functions are obsolete: do not use them in new "
"programs.  POSIX.1-2008 marks B<sighold>(), B<sigignore>(), B<sigpause>(), "
"B<sigrelse>(), and B<sigset>()  as obsolete, recommending the use of "
"B<sigaction>(2), B<sigprocmask>(2), B<pthread_sigmask>(3), and "
"B<sigsuspend>(2)  instead."
msgstr ""

#. type: Plain text
#: man-pages/man3/sigset.3:192
msgid "These functions appeared in glibc version 2.1."
msgstr ""

#. type: Plain text
#: man-pages/man3/sigset.3:198
msgid ""
"The I<sighandler_t> type is a GNU extension; it is used on this page only to"
" make the B<sigset>()  prototype more easily readable."
msgstr ""

#. type: Plain text
#: man-pages/man3/sigset.3:206
msgid ""
"The B<sigset>()  function provides reliable signal handling semantics (as "
"when calling B<sigaction>(2)  with I<sa_mask> equal to 0)."
msgstr ""

#. type: Plain text
#: man-pages/man3/sigset.3:224
msgid ""
"On System V, the B<signal>()  function provides unreliable semantics (as "
"when calling B<sigaction>(2)  with I<sa_mask> equal to I<SA_RESETHAND | "
"SA_NODEFER>).  On BSD, B<signal>()  provides reliable semantics.  "
"POSIX.1-2001 leaves these aspects of B<signal>()  unspecified.  See "
"B<signal>(2)  for further details."
msgstr ""

#. type: Plain text
#: man-pages/man3/sigset.3:232
msgid ""
"In order to wait for a signal, BSD and System V both provided a function "
"named B<sigpause>(3), but this function has a different argument on the two "
"systems.  See B<sigpause>(3)  for details."
msgstr ""

#. type: Plain text
#: man-pages/man3/sigset.3:241
msgid ""
"In versions of glibc before 2.2, B<sigset>()  did not unblock I<sig> if "
"I<disp> was specified as a value other than B<SIG_HOLD>."
msgstr ""

#.  See http://sourceware.org/bugzilla/show_bug.cgi?id=1951
#. type: Plain text
#: man-pages/man3/sigset.3:266
msgid ""
"In versions of glibc before 2.5, B<sigset>()  does not correctly return the "
"previous disposition of the signal in two cases.  First, if I<disp> is "
"specified as B<SIG_HOLD>, then a successful B<sigset>()  always returns "
"B<SIG_HOLD>.  Instead, it should return the previous disposition of the "
"signal (unless the signal was blocked, in which case B<SIG_HOLD> should be "
"returned).  Second, if the signal is currently blocked, then the return "
"value of a successful B<sigset>()  should be B<SIG_HOLD>.  Instead, the "
"previous disposition of the signal is returned.  These problems have been "
"fixed since glibc 2.5."
msgstr ""

#. type: Plain text
#: man-pages/man3/sigset.3:275
msgid ""
"B<kill>(2), B<pause>(2), B<sigaction>(2), B<signal>(2), B<sigprocmask>(2), "
"B<raise>(3), B<sigpause>(3), B<sigvec>(3), B<signal>(7)"
msgstr ""

#. type: TH
#: man-pages/man3/stdio.3:39
#, no-wrap
msgid "STDIO"
msgstr ""

#. type: TH
#: man-pages/man3/stdio.3:39
#, no-wrap
msgid "2001-12-26"
msgstr "2001-12-26"

#. type: Plain text
#: man-pages/man3/stdio.3:42
msgid "stdio - standard input/output library functions"
msgstr ""

#. type: Plain text
#: man-pages/man3/stdio.3:46
msgid "B<FILE *>I<stdin>B<;>"
msgstr ""

#. type: Plain text
#: man-pages/man3/stdio.3:48
msgid "B<FILE *>I<stdout>B<;>"
msgstr ""

#. type: Plain text
#: man-pages/man3/stdio.3:50
msgid "B<FILE *>I<stderr>B<;>"
msgstr ""

#. type: Plain text
#: man-pages/man3/stdio.3:57
msgid ""
"The standard I/O library provides a simple and efficient buffered stream I/O"
" interface.  Input and output is mapped into logical data streams and the "
"physical I/O characteristics are concealed.  The functions and macros are "
"listed below; more information is available from the individual man pages."
msgstr ""

#. type: Plain text
#: man-pages/man3/stdio.3:80
msgid ""
"A stream is associated with an external file (which may be a physical "
"device) by I<opening> a file, which may involve creating a new file.  "
"Creating an existing file causes its former contents to be discarded.  If a "
"file can support positioning requests (such as a disk file, as opposed to a "
"terminal), then a I<file position indicator> associated with the stream is "
"positioned at the start of the file (byte zero), unless the file is opened "
"with append mode.  If append mode is used, it is unspecified whether the "
"position indicator will be placed at the start or the end of the file.  The "
"position indicator is maintained by subsequent reads, writes and positioning"
" requests.  All input occurs as if the characters were read by successive "
"calls to the B<fgetc>(3)  function; all output takes place as if all "
"characters were written by successive calls to the B<fputc>(3)  function."
msgstr ""

#. type: Plain text
#: man-pages/man3/stdio.3:90
msgid ""
"A file is disassociated from a stream by I<closing> the file.  Output "
"streams are flushed (any unwritten buffer contents are transferred to the "
"host environment) before the stream is disassociated from the file.  The "
"value of a pointer to a I<FILE> object is indeterminate after a file is "
"closed (garbage)."
msgstr ""

#. type: Plain text
#: man-pages/man3/stdio.3:103
msgid ""
"A file may be subsequently reopened, by the same or another program "
"execution, and its contents reclaimed or modified (if it can be repositioned"
" at the start).  If the main function returns to its original caller, or the"
" B<exit>(3)  function is called, all open files are closed (hence all output"
" streams are flushed) before program termination.  Other methods of program "
"termination, such as B<abort>(3)  do not bother about closing files "
"properly."
msgstr ""

#. type: Plain text
#: man-pages/man3/stdio.3:119
msgid ""
"At program startup, three text streams are predefined and need not be opened"
" explicitly: I<standard input> (for reading conventional input), I<standard "
"output> (for writing conventional output), and I<standard error> (for "
"writing diagnostic output).  These streams are abbreviated "
"I<stdin>,I<stdout> and I<stderr>.  When opened, the standard error stream is"
" not fully buffered; the standard input and output streams are fully "
"buffered if and only if the streams do not refer to an interactive device."
msgstr ""

#. type: Plain text
#: man-pages/man3/stdio.3:129
msgid ""
"Output streams that refer to terminal devices are always line buffered by "
"default; pending output to such streams is written automatically whenever an"
" input stream that refers to a terminal device is read.  In cases where a "
"large amount of computation is done after printing part of a line on an "
"output terminal, it is necessary to B<fflush>(3)  the standard output before"
" going off and computing so that the output will appear."
msgstr ""

#. type: Plain text
#: man-pages/man3/stdio.3:143
msgid ""
"The I<stdio> library is a part of the library B<libc> and routines are "
"automatically loaded as needed by the compilers B<cc>(1)  and B<pc>(1).  The"
" SYNOPSIS sections of the following manual pages indicate which include "
"files are to be used, what the compiler declaration for the function looks "
"like and which external variables are of interest."
msgstr ""

#.  Not on Linux: .BR fropen ,
#.  Not on Linux: .BR fwopen ,
#. type: Plain text
#: man-pages/man3/stdio.3:183
msgid ""
"The following are defined as macros; these names may not be reused without "
"first removing their current definitions with B<#undef>: B<BUFSIZ>, B<EOF>, "
"B<FILENAME_MAX>, B<FOPEN_MAX>, B<L_cuserid>, B<L_ctermid>, B<L_tmpnam>, "
"B<NULL>, B<SEEK_END>, B<SEEK_SET>, B<SEEK_CUR>, B<TMP_MAX>, B<clearerr>, "
"B<feof>, B<ferror>, B<fileno>, B<getc>, B<getchar>, B<putc>, B<putchar>, "
"B<stderr>, B<stdin>, B<stdout>.  Function versions of the macro functions "
"B<feof>, B<ferror>, B<clearerr>, B<fileno>, B<getc>, B<getchar>, B<putc>, "
"and B<putchar> exist and will be used if the macros definitions are "
"explicitly removed."
msgstr ""

#. type: SS
#: man-pages/man3/stdio.3:183
#, no-wrap
msgid "List of functions"
msgstr ""

#. type: tbl table
#: man-pages/man3/stdio.3:188
#, no-wrap
msgid "Function\tDescription\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/stdio.3:189
#, no-wrap
msgid "_\n"
msgstr "_\n"

#. type: tbl table
#: man-pages/man3/stdio.3:190
#, no-wrap
msgid "clearerr\tcheck and reset stream status\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/stdio.3:191
#, no-wrap
msgid "fclose\tclose a stream\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/stdio.3:192
#, no-wrap
msgid "fdopen\tstream open functions\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/stdio.3:193
#, no-wrap
msgid "feof\tcheck and reset stream status\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/stdio.3:194
#, no-wrap
msgid "ferror\tcheck and reset stream status\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/stdio.3:195
#, no-wrap
msgid "fflush\tflush a stream\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/stdio.3:196
#, no-wrap
msgid "fgetc\tget next character or word from input stream\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/stdio.3:197
#, no-wrap
msgid "fgetpos\treposition a stream\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/stdio.3:198
#, no-wrap
msgid "fgets\tget a line from a stream\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/stdio.3:199
#, no-wrap
msgid "fileno\treturn the integer descriptor of the argument stream\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/stdio.3:200
#, no-wrap
msgid "fopen\tstream open functions\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/stdio.3:201
#, no-wrap
msgid "fprintf\tformatted output conversion\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/stdio.3:202
#, no-wrap
msgid "fpurge\tflush a stream\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/stdio.3:203
#, no-wrap
msgid "fputc\toutput a character or word to a stream\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/stdio.3:204
#, no-wrap
msgid "fputs\toutput a line to a stream\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/stdio.3:205
#, no-wrap
msgid "fread\tbinary stream input/output\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/stdio.3:206
#, no-wrap
msgid "freopen\tstream open functions\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/stdio.3:207
#, no-wrap
msgid "fscanf\tinput format conversion\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/stdio.3:208
#, no-wrap
msgid "fseek\treposition a stream\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/stdio.3:209
#, no-wrap
msgid "fsetpos\treposition a stream\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/stdio.3:210
#, no-wrap
msgid "ftell\treposition a stream\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/stdio.3:211
#, no-wrap
msgid "fwrite\tbinary stream input/output\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/stdio.3:212
#, no-wrap
msgid "getc\tget next character or word from input stream\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/stdio.3:213
#, no-wrap
msgid "getchar\tget next character or word from input stream\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/stdio.3:214
#, no-wrap
msgid "gets\tget a line from a stream\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/stdio.3:215
#, no-wrap
msgid "getw\tget next character or word from input stream\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/stdio.3:216
#, no-wrap
msgid "mktemp\tmake temporary filename (unique)\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/stdio.3:217
#, no-wrap
msgid "perror\tsystem error messages\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/stdio.3:218
#, no-wrap
msgid "printf\tformatted output conversion\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/stdio.3:219
#, no-wrap
msgid "putc\toutput a character or word to a stream\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/stdio.3:220
#, no-wrap
msgid "putchar\toutput a character or word to a stream\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/stdio.3:221
#, no-wrap
msgid "puts\toutput a line to a stream\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/stdio.3:222
#, no-wrap
msgid "putw\toutput a character or word to a stream\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/stdio.3:223
#, no-wrap
msgid "remove\tremove directory entry\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/stdio.3:224
#, no-wrap
msgid "rewind\treposition a stream\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/stdio.3:225
#, no-wrap
msgid "scanf\tinput format conversion\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/stdio.3:226
#, no-wrap
msgid "setbuf\tstream buffering operations\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/stdio.3:227
#, no-wrap
msgid "setbuffer\tstream buffering operations\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/stdio.3:228
#, no-wrap
msgid "setlinebuf\tstream buffering operations\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/stdio.3:229
#, no-wrap
msgid "setvbuf\tstream buffering operations\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/stdio.3:230
#, no-wrap
msgid "sprintf\tformatted output conversion\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/stdio.3:231
#, no-wrap
msgid "sscanf\tinput format conversion\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/stdio.3:232
#, no-wrap
msgid "strerror\tsystem error messages\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/stdio.3:233
#, no-wrap
msgid "sys_errlist\tsystem error messages\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/stdio.3:234
#, no-wrap
msgid "sys_nerr\tsystem error messages\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/stdio.3:235
#, no-wrap
msgid "tempnam\ttemporary file routines\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/stdio.3:236
#, no-wrap
msgid "tmpfile\ttemporary file routines\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/stdio.3:237
#, no-wrap
msgid "tmpnam\ttemporary file routines\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/stdio.3:238
#, no-wrap
msgid "ungetc\tun-get character from input stream\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/stdio.3:239
#, no-wrap
msgid "vfprintf\tformatted output conversion\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/stdio.3:240
#, no-wrap
msgid "vfscanf\tinput format conversion\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/stdio.3:241
#, no-wrap
msgid "vprintf\tformatted output conversion\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/stdio.3:242
#, no-wrap
msgid "vscanf\tinput format conversion\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/stdio.3:243
#, no-wrap
msgid "vsprintf\tformatted output conversion\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/stdio.3:244
#, no-wrap
msgid "vsscanf\tinput format conversion\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/stdio.3:250
msgid "The I<stdio> library conforms to C89."
msgstr ""

#. type: Plain text
#: man-pages/man3/stdio.3:256
msgid ""
"B<close>(2), B<open>(2), B<read>(2), B<write>(2), B<stdout>(3), "
"B<unlocked_stdio>(3)"
msgstr ""

#. type: TH
#: man-pages/man3/strverscmp.3:25
#, no-wrap
msgid "STRVERSCMP"
msgstr ""

#. type: TH
#: man-pages/man3/strverscmp.3:25
#, no-wrap
msgid "2001-12-19"
msgstr ""

#. type: Plain text
#: man-pages/man3/strverscmp.3:28
msgid "strverscmp - compare two version strings"
msgstr ""

#. type: Plain text
#: man-pages/man3/strverscmp.3:35
#, no-wrap
msgid "B<int strverscmp(const char *>I<s1>B<, const char *>I<s2>B<);>\n"
msgstr ""

#.  classical solution: "rename jan jan0 jan?"
#. type: Plain text
#: man-pages/man3/strverscmp.3:52
msgid ""
"Often one has files I<jan1>, I<jan2>, ..., I<jan9>, I<jan10>, ...  and it "
"feels wrong when B<ls>(1)  orders them I<jan1>, I<jan10>, ..., I<jan2>, ...,"
" I<jan9>.  In order to rectify this, GNU introduced the I<-v> option to "
"B<ls>(1), which is implemented using B<versionsort>(3), which again uses "
"B<strverscmp>()."
msgstr ""

#. type: Plain text
#: man-pages/man3/strverscmp.3:63
msgid ""
"Thus, the task of B<strverscmp>()  is to compare two strings and find the "
"\"right\" order, while B<strcmp>(3)  finds only the lexicographic order.  "
"This function does not use the locale category B<LC_COLLATE>, so is meant "
"mostly for situations where the strings are expected to be in ASCII."
msgstr ""

#. type: Plain text
#: man-pages/man3/strverscmp.3:81
msgid ""
"What this function does is the following.  If both strings are equal, return"
" 0.  Otherwise, find the position between two bytes with the property that "
"before it both strings are equal, while directly after it there is a "
"difference.  Find the largest consecutive digit strings containing (or "
"starting at, or ending at) this position.  If one or both of these is empty,"
" then return what B<strcmp>(3)  would have returned (numerical ordering of "
"byte values).  Otherwise, compare both digit strings numerically, where "
"digit strings with one or more leading zeros are interpreted as if they have"
" a decimal point in front (so that in particular digit strings with more "
"leading zeros come before digit strings with fewer leading zeros).  Thus, "
"the ordering is I<000>, I<00>, I<01>, I<010>, I<09>, I<0>, I<1>, I<9>, "
"I<10>."
msgstr ""

#. type: Plain text
#: man-pages/man3/strverscmp.3:90
msgid ""
"The B<strverscmp>()  function returns an integer less than, equal to, or "
"greater than zero if I<s1> is found, respectively, to be earlier than, equal"
" to, or later than I<s2>."
msgstr ""

#. type: Plain text
#: man-pages/man3/strverscmp.3:96
msgid "B<rename>(1), B<strcasecmp>(3), B<strcmp>(3), B<strcoll>(3)"
msgstr ""

#. type: TH
#: man-pages/man3/scalbln.3:27
#, no-wrap
msgid "SCALBLN"
msgstr "SCALBLN"

#. type: Plain text
#: man-pages/man3/scalbln.3:31
msgid ""
"scalbn, scalbnf, scalbnl, scalbln, scalblnf, scalblnl - multiply floating-"
"point number by integral power of radix"
msgstr ""

#. type: Plain text
#: man-pages/man3/scalbln.3:35
msgid "B<double scalbln(double >I<x>B<, long int >I<exp>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man3/scalbln.3:37
msgid "B<float scalblnf(float >I<x>B<, long int >I<exp>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man3/scalbln.3:39
msgid "B<long double scalblnl(long double >I<x>B<, long int >I<exp>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man3/scalbln.3:41
msgid "B<double scalbn(double >I<x>B<, int >I<exp>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man3/scalbln.3:43
msgid "B<float scalbnf(float >I<x>B<, int >I<exp>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man3/scalbln.3:45
msgid "B<long double scalbnl(long double >I<x>B<, int >I<exp>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man3/scalbln.3:57
msgid "B<scalbln>(), B<scalblnf>(), B<scalblnl>():"
msgstr ""

#. type: Plain text
#: man-pages/man3/scalbln.3:68
msgid "B<scalbn>(), B<scalbnf>(), B<scalbnl>():"
msgstr ""

#. type: Plain text
#: man-pages/man3/scalbln.3:85
msgid ""
"These functions multiply their first argument I<x> by B<FLT_RADIX> (probably"
" 2)  to the power of I<exp>, that is:"
msgstr ""

#. type: Plain text
#: man-pages/man3/scalbln.3:88
#, no-wrap
msgid "    x * FLT_RADIX ** exp\n"
msgstr ""

#.  not in /usr/include but in a gcc lib
#. type: Plain text
#: man-pages/man3/scalbln.3:95
msgid ""
"The definition of B<FLT_RADIX> can be obtained by including "
"I<E<lt>float.hE<gt>>."
msgstr ""

#. type: Plain text
#: man-pages/man3/scalbln.3:102
msgid "On success, these functions return I<x> * B<FLT_RADIX> ** I<exp>."
msgstr ""

#. type: Plain text
#: man-pages/man3/scalbln.3:125
msgid ""
"If the result overflows, a range error occurs, and the functions return "
"B<HUGE_VAL>, B<HUGE_VALF>, or B<HUGE_VALL>, respectively, with a sign the "
"same as I<x>."
msgstr ""

#. type: Plain text
#: man-pages/man3/scalbln.3:130
msgid ""
"If the result underflows, a range error occurs, and the functions return "
"zero, with a sign the same as I<x>."
msgstr ""

#. type: TP
#: man-pages/man3/scalbln.3:137
#, no-wrap
msgid "Range error, overflow"
msgstr "Ошибка диапазона, переполнение"

#.  .I errno
#.  is set to
#.  .BR ERANGE .
#. type: Plain text
#: man-pages/man3/scalbln.3:145
msgid "An overflow floating-point exception (B<FE_OVERFLOW>)  is raised."
msgstr "Вызывается исключение переполнения плавающей точки (B<FE_OVERFLOW>)."

#. type: TP
#: man-pages/man3/scalbln.3:145
#, no-wrap
msgid "Range error, underflow"
msgstr "Ошибка диапазона, исчезновение порядка"

#.  .I errno
#.  is set to
#.  .BR ERANGE .
#. type: Plain text
#: man-pages/man3/scalbln.3:153
msgid "An underflow floating-point exception (B<FE_UNDERFLOW>)  is raised."
msgstr ""

#. type: Plain text
#: man-pages/man3/scalbln.3:171
msgid ""
"The B<scalbn>(), B<scalbnf>(), B<scalbnl>(), B<scalbln>(), B<scalblnf>(), "
"and B<scalblnl>()  functions are thread-safe."
msgstr ""

#. type: Plain text
#: man-pages/man3/scalbln.3:182
msgid ""
"These functions differ from the obsolete functions described in B<scalb>(3)"
"  in the type of their second argument.  The functions described on this "
"page have a second argument of an integral type, while those in B<scalb>(3)"
"  have a second argument of type I<double>."
msgstr ""

#. type: Plain text
#: man-pages/man3/scalbln.3:189
msgid ""
"If B<FLT_RADIX> equals 2 (which is usual), then B<scalbn>()  is equivalent "
"to B<ldexp>(3)."
msgstr ""

#. type: Plain text
#: man-pages/man3/scalbln.3:191
msgid "B<ldexp>(3), B<scalb>(3)"
msgstr ""

#. type: TH
#: man-pages/man3/strsep.3:33
#, no-wrap
msgid "STRSEP"
msgstr "STRSEP"

#. type: Plain text
#: man-pages/man3/strsep.3:36
msgid "strsep - extract token from string"
msgstr "strsep - извлечение токена из строки"

#. type: Plain text
#: man-pages/man3/strsep.3:41
#, no-wrap
msgid "B<char *strsep(char **>I<stringp>B<, const char *>I<delim>B<);>\n"
msgstr "B<char *strsep(char **>I<stringp>B<, const char *>I<delim>B<);>\n"

#. type: Plain text
#: man-pages/man3/strsep.3:50
msgid "B<strsep>(): _BSD_SOURCE"
msgstr "B<strsep>(): _BSD_SOURCE"

#. type: Plain text
#: man-pages/man3/strsep.3:73
msgid ""
"If I<*stringp> is NULL, the B<strsep>()  function returns NULL and does "
"nothing else.  Otherwise, this function finds the first token in the string "
"I<*stringp>, that is delimited by one of the bytes in the string I<delim>.  "
"This token is terminated by overwriting the delimiter with a null byte "
"(\\(aq\\e0\\(aq), and I<*stringp> is updated to point past the token.  In "
"case no delimiter was found, the token is taken to be the entire string "
"I<*stringp>, and I<*stringp> is made NULL."
msgstr "Если значение I<*stringp> равно NULL, то функция B<strsep>() возвращает NULL и ничего не делает. В противном случае она ищет первый токен в строке I<*stringp>, который отделён в строке одним байтом из I<delim>. Этот токен завершается символом null (\\(aq\\e0\\(aq), который устанавливается на место символа разделителя, а значению I<*stringp> присваивается значение, указывающее на следующий символ после токена. Если разделитель не найден, то токеном считается вся строка I<*stringp> и значению I<*stringp> присваивается NULL."

#. type: Plain text
#: man-pages/man3/strsep.3:79
msgid ""
"The B<strsep>()  function returns a pointer to the token, that is, it "
"returns the original value of I<*stringp>."
msgstr "Функция B<strsep>() возвращает указатель на токен, то есть возвращает исходное значение I<*stringp>."

#. type: Plain text
#: man-pages/man3/strsep.3:84
msgid "The B<strsep>()  function is thread-safe."
msgstr "Функцию B<strsep>() можно использовать в нескольких нитях одновременно."

#. type: Plain text
#: man-pages/man3/strsep.3:86
msgid "4.4BSD."
msgstr "4.4BSD."

#. type: Plain text
#: man-pages/man3/strsep.3:95
msgid ""
"The B<strsep>()  function was introduced as a replacement for B<strtok>(3), "
"since the latter cannot handle empty fields.  However, B<strtok>(3)  "
"conforms to C89/C99 and hence is more portable."
msgstr "Функция B<strsep>() была введена в качестве замены функции B<strtok>(3), потому что последняя не может обрабатывать пустые поля. Тем не менее, функция B<strtok>(3) соответствует C89/C99 и поэтому более переносима."

#. type: Plain text
#: man-pages/man3/strsep.3:98
msgid "Be cautious when using this function.  If you do use it, note that:"
msgstr "Используйте данную функцию с осторожностью. Учитывайте, что:"

#. type: Plain text
#: man-pages/man3/strsep.3:100
msgid "This function modifies its first argument."
msgstr "Данная функция изменяет первый аргумент."

#. type: Plain text
#: man-pages/man3/strsep.3:102
msgid "This function cannot be used on constant strings."
msgstr "Эта функция не может использоваться со строками-константами."

#. type: Plain text
#: man-pages/man3/strsep.3:104
msgid "The identity of the delimiting character is lost."
msgstr "Теряется идентичность символа-разделителя."

#. type: Plain text
#: man-pages/man3/strsep.3:113
msgid ""
"B<index>(3), B<memchr>(3), B<rindex>(3), B<strchr>(3), B<string>(3), "
"B<strpbrk>(3), B<strspn>(3), B<strstr>(3), B<strtok>(3)"
msgstr "B<index>(3), B<memchr>(3), B<rindex>(3), B<strchr>(3), B<string>(3), B<strpbrk>(3), B<strspn>(3), B<strstr>(3), B<strtok>(3)"

#. type: TH
#: man-pages/man3/scalb.3:27
#, no-wrap
msgid "SCALB"
msgstr "SCALB"

#. type: TH
#: man-pages/man3/scalb.3:27
#, no-wrap
msgid "2013-03-23"
msgstr "2013-03-23"

#. type: Plain text
#: man-pages/man3/scalb.3:31
msgid ""
"scalb, scalbf, scalbl - multiply floating-point number by integral power of "
"radix (OBSOLETE)"
msgstr ""

#. type: Plain text
#: man-pages/man3/scalb.3:35
msgid "B<double scalb(double >I<x>B<, double >I<exp>B<);>"
msgstr "B<double scalb(double >I<x>B<, double >I<exp>B<);>"

#. type: Plain text
#: man-pages/man3/scalb.3:37
msgid "B<float scalbf(float >I<x>B<, float >I<exp>B<);>"
msgstr "B<float scalbf(float >I<x>B<, float >I<exp>B<);>"

#. type: Plain text
#: man-pages/man3/scalb.3:39
msgid "B<long double scalbl(long double >I<x>B<, long double >I<exp>B<);>"
msgstr "B<long double scalbl(long double >I<x>B<, long double >I<exp>B<);>"

#. type: Plain text
#: man-pages/man3/scalb.3:49
msgid "B<scalb>():"
msgstr "B<scalb>():"

#. type: Plain text
#: man-pages/man3/scalb.3:52
msgid ""
"_BSD_SOURCE || _SVID_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 500 || "
"_XOPEN_SOURCE\\ &&\\ _XOPEN_SOURCE_EXTENDED"
msgstr "_BSD_SOURCE || _SVID_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 500 || _XOPEN_SOURCE\\ &&\\ _XOPEN_SOURCE_EXTENDED"

#. type: Plain text
#: man-pages/man3/scalb.3:56
msgid "B<scalbf>(), B<scalbl>():"
msgstr "B<scalbf>(), B<scalbl>():"

#. type: Plain text
#: man-pages/man3/scalb.3:58
msgid "_BSD_SOURCE || _SVID_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 600"
msgstr "_BSD_SOURCE || _SVID_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 600"

#. type: Plain text
#: man-pages/man3/scalb.3:92
msgid "If I<x> or I<exp> is a NaN, a NaN is returned."
msgstr "Если значение I<x> или I<exp> равно NaN, будет возвращено NaN."

#. type: Plain text
#: man-pages/man3/scalb.3:100
msgid ""
"If I<x> is positive infinity (negative infinity), and I<exp> is not negative"
" infinity, positive infinity (negative infinity) is returned."
msgstr ""

#. type: Plain text
#: man-pages/man3/scalb.3:106
msgid ""
"If I<x> is +0 (-0), and I<exp> is not positive infinity, +0 (-0) is "
"returned."
msgstr ""

#. type: Plain text
#: man-pages/man3/scalb.3:114
msgid ""
"If I<x> is zero, and I<exp> is positive infinity, a domain error occurs, and"
" a NaN is returned."
msgstr ""

#. type: Plain text
#: man-pages/man3/scalb.3:123
msgid ""
"If I<x> is an infinity, and I<exp> is negative infinity, a domain error "
"occurs, and a NaN is returned."
msgstr ""

#. type: TP
#: man-pages/man3/scalb.3:145
#, no-wrap
msgid ""
"Domain error: I<x> is 0, and I<exp> is positive infinity, or I<x> is "
"positive infinity and I<exp> is negative infinity and the other argument is "
"not a NaN"
msgstr ""

#. type: Plain text
#: man-pages/man3/scalb.3:191
msgid ""
"B<scalb>()  is specified in POSIX.1-2001, but marked obsolescent.  "
"POSIX.1-2008 removes the specification of B<scalb>(), recommending the use "
"of B<scalbln>(3), B<scalblnf>(3), or B<scalblnl>(3)  instead.  The "
"B<scalb>()  function is from 4.3BSD."
msgstr ""

#.  Looking at header files: scalbf() is present on the
#.  BSDs, Tru64, HP-UX 11, Irix 6.5; scalbl() is on HP-UX 11 and Tru64.
#. type: Plain text
#: man-pages/man3/scalb.3:200
msgid ""
"B<scalbf>()  and B<scalbl>()  are unstandardized; B<scalbf>()  is "
"nevertheless present on several other systems"
msgstr ""

#. type: Plain text
#: man-pages/man3/scalb.3:202
msgid "B<ldexp>(3), B<scalbln>(3)"
msgstr ""

#. type: TH
#: man-pages/man3/strspn.3:30
#, no-wrap
msgid "STRSPN"
msgstr "STRSPN"

#. type: Plain text
#: man-pages/man3/strspn.3:33
msgid "strspn, strcspn - get length of a prefix substring"
msgstr "strspn, strcspn - определение длины префикса подстроки"

#. type: Plain text
#: man-pages/man3/strspn.3:38
#, no-wrap
msgid "B<size_t strspn(const char *>I<s>B<, const char *>I<accept>B<);>\n"
msgstr "B<size_t strspn(const char *>I<s>B<, const char *>I<accept>B<);>\n"

#. type: Plain text
#: man-pages/man3/strspn.3:40
#, no-wrap
msgid "B<size_t strcspn(const char *>I<s>B<, const char *>I<reject>B<);>\n"
msgstr "B<size_t strcspn(const char *>I<s>B<, const char *>I<reject>B<);>\n"

#. type: Plain text
#: man-pages/man3/strspn.3:49
msgid ""
"The B<strspn>()  function calculates the length (in bytes) of the initial "
"segment of I<s> which consists entirely of bytes in I<accept>."
msgstr "Функция B<strspn>() вычисляет длину (в байтах) начального сегмента строки I<s>, состоящего только из байт строки I<accept>."

#. type: Plain text
#: man-pages/man3/strspn.3:57
msgid ""
"The B<strcspn>()  function calculates the length of the initial segment of "
"I<s> which consists entirely of bytes not in I<reject>."
msgstr "Функция B<strcspn>() вычисляет длину начального сегмента строки I<s>, состоящего только из байт, не указанных в строке I<reject>."

#. type: Plain text
#: man-pages/man3/strspn.3:66
msgid ""
"The B<strspn>()  function returns the number of bytes in the initial segment"
" of I<s> which consist only of bytes from I<accept>."
msgstr "Функция B<strspn>() возвращает количество байт в начальном сегменте I<s>, который составляют байты из I<accept>."

#. type: Plain text
#: man-pages/man3/strspn.3:74
msgid ""
"The B<strcspn>()  function returns the number of bytes in the initial "
"segment of I<s> which are not in the string I<reject>."
msgstr "Функция B<strcspn>() возвращает количество байт в начальном сегменте I<s>, состоящем только из символов, не указанных в I<reject>."

#. type: Plain text
#: man-pages/man3/strspn.3:81
msgid "The B<strspn>()  and B<strcspn>()  functions are thread-safe."
msgstr "Функции B<strspn>() и B<strcspn>() можно использовать в нескольких нитях одновременно."

#. type: Plain text
#: man-pages/man3/strspn.3:94
msgid ""
"B<index>(3), B<memchr>(3), B<rindex>(3), B<strchr>(3), B<string>(3), "
"B<strpbrk>(3), B<strsep>(3), B<strstr>(3), B<strtok>(3), B<wcscspn>(3), "
"B<wcsspn>(3)"
msgstr "B<index>(3), B<memchr>(3), B<rindex>(3), B<strchr>(3), B<string>(3), B<strpbrk>(3), B<strsep>(3), B<strstr>(3), B<strtok>(3), B<wcscspn>(3), B<wcsspn>(3)"

#. type: TH
#: man-pages/man3/strdup.3:31
#, no-wrap
msgid "STRDUP"
msgstr "STRDUP"

#. type: Plain text
#: man-pages/man3/strdup.3:34
msgid "strdup, strndup, strdupa, strndupa - duplicate a string"
msgstr ""

#. type: Plain text
#: man-pages/man3/strdup.3:39
#, no-wrap
msgid "B<char *strdup(const char *>I<s>B<);>\n"
msgstr "B<char *strdup(const char *>I<s>B<);>\n"

#. type: Plain text
#: man-pages/man3/strdup.3:41
#, no-wrap
msgid "B<char *strndup(const char *>I<s>B<, size_t >I<n>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/strdup.3:43
#, no-wrap
msgid "B<char *strdupa(const char *>I<s>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/strdup.3:45
#, no-wrap
msgid "B<char *strndupa(const char *>I<s>B<, size_t >I<n>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/strdup.3:55
msgid "B<strdup>():"
msgstr ""

#. type: Plain text
#: man-pages/man3/strdup.3:58
msgid ""
"_SVID_SOURCE || _BSD_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 500 || "
"_XOPEN_SOURCE\\ &&\\ _XOPEN_SOURCE_EXTENDED"
msgstr "_SVID_SOURCE || _BSD_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 500 || _XOPEN_SOURCE\\ &&\\ _XOPEN_SOURCE_EXTENDED"

#. type: Plain text
#: man-pages/man3/strdup.3:63
msgid "B<strndup>():"
msgstr ""

#. type: Plain text
#: man-pages/man3/strdup.3:67
msgid "_POSIX_C_SOURCE\\ E<gt>=\\ 200809L || _XOPEN_SOURCE\\ E<gt>=\\ 700"
msgstr ""

#. type: Plain text
#: man-pages/man3/strdup.3:75
msgid "B<strdupa>(), B<strndupa>(): _GNU_SOURCE"
msgstr ""

#. type: Plain text
#: man-pages/man3/strdup.3:88
msgid ""
"The B<strdup>()  function returns a pointer to a new string which is a "
"duplicate of the string I<s>.  Memory for the new string is obtained with "
"B<malloc>(3), and can be freed with B<free>(3)."
msgstr ""

#. type: Plain text
#: man-pages/man3/strdup.3:101
msgid ""
"The B<strndup>()  function is similar, but copies at most I<n> bytes.  If "
"I<s> is longer than I<n>, only I<n> bytes are copied, and a terminating null"
" byte (\\(aq\\e0\\(aq) is added."
msgstr ""

#. type: Plain text
#: man-pages/man3/strdup.3:111
msgid ""
"B<strdupa>()  and B<strndupa>()  are similar, but use B<alloca>(3)  to "
"allocate the buffer.  They are available only when using the GNU GCC suite, "
"and suffer from the same limitations described in B<alloca>(3)."
msgstr ""

#. type: Plain text
#: man-pages/man3/strdup.3:119
msgid ""
"On success, the B<strdup>()  function returns a pointer to the duplicated "
"string.  It returns NULL if insufficient memory was available, with I<errno>"
" set to indicate the cause of the error."
msgstr ""

#. type: Plain text
#: man-pages/man3/strdup.3:123
msgid "Insufficient memory available to allocate duplicate string."
msgstr ""

#.  4.3BSD-Reno, not (first) 4.3BSD.
#. type: Plain text
#: man-pages/man3/strdup.3:133
msgid ""
"B<strdup>()  conforms to SVr4, 4.3BSD, POSIX.1-2001.  B<strndup>()  conforms"
" to POSIX.1-2008.  B<strdupa>()  and B<strndupa>()  are GNU extensions."
msgstr ""

#. type: Plain text
#: man-pages/man3/strdup.3:140
msgid ""
"B<alloca>(3), B<calloc>(3), B<free>(3), B<malloc>(3), B<realloc>(3), "
"B<string>(3), B<wcsdup>(3)"
msgstr ""

#. type: TH
#: man-pages/man3/strtok.3:32
#, no-wrap
msgid "STRTOK"
msgstr "STRTOK"

#. type: TH
#: man-pages/man3/strtok.3:32
#, no-wrap
msgid "2013-05-19"
msgstr "2013-05-19"

#. type: Plain text
#: man-pages/man3/strtok.3:35
msgid "strtok, strtok_r - extract tokens from strings"
msgstr "strtok, strtok_r - извлечение элементов (токенов) из строки"

#. type: Plain text
#: man-pages/man3/strtok.3:40
#, no-wrap
msgid "B<char *strtok(char *>I<str>B<, const char *>I<delim>B<);>\n"
msgstr "B<char *strtok(char *>I<str>B<, const char *>I<delim>B<);>\n"

#. type: Plain text
#: man-pages/man3/strtok.3:42
#, no-wrap
msgid ""
"B<char *strtok_r(char *>I<str>B<, const char *>I<delim>B<, char "
"**>I<saveptr>B<);>\n"
msgstr "B<char *strtok_r(char *>I<str>B<, const char *>I<delim>B<, char **>I<saveptr>B<);>\n"

#. type: Plain text
#: man-pages/man3/strtok.3:53
msgid ""
"B<strtok_r>(): _SVID_SOURCE || _BSD_SOURCE || _POSIX_C_SOURCE\\ E<gt>=\\ 1 "
"|| _XOPEN_SOURCE || _POSIX_SOURCE"
msgstr "B<strtok_r>(): _SVID_SOURCE || _BSD_SOURCE || _POSIX_C_SOURCE\\ E<gt>=\\ 1 || _XOPEN_SOURCE || _POSIX_SOURCE"

#. type: Plain text
#: man-pages/man3/strtok.3:66
msgid ""
"The B<strtok>()  function breaks a string into a sequence of zero or more "
"nonempty tokens.  On the first call to B<strtok>()  the string to be parsed "
"should be specified in I<str>.  In each subsequent call that should parse "
"the same string, I<str> must be NULL."
msgstr "Функция B<strtok>() разделяет строку на последовательность нуля или более непустых токенов. При первом вызове B<strtok>() анализируемую строку нужно указывать в аргументе I<str>. В каждом последующем вызове, в котором анализируется эта же строка, значение I<str> должно быть NULL."

#. type: Plain text
#: man-pages/man3/strtok.3:75
msgid ""
"The I<delim> argument specifies a set of bytes that delimit the tokens in "
"the parsed string.  The caller may specify different strings in I<delim> in "
"successive calls that parse the same string."
msgstr "В аргументе I<delim> задаётся набор байт, которые считаются разделителями токенов в анализируемой строке. Вызывающий может указывать разные строки в I<delim> в последующих вызовах при анализе той же строки."

#. type: Plain text
#: man-pages/man3/strtok.3:84
msgid ""
"Each call to B<strtok>()  returns a pointer to a null-terminated string "
"containing the next token.  This string does not include the delimiting "
"byte.  If no more tokens are found, B<strtok>()  returns NULL."
msgstr "Каждый вызов B<strtok>() возвращает указатель на строку, завершающуюся null, которая содержит следующий токен. Эта строка не включает байт-разделитель. Если больше токенов нет, то B<strtok>() возвращает NULL."

#. type: Plain text
#: man-pages/man3/strtok.3:104
msgid ""
"A sequence of calls to B<strtok>()  that operate on the same string "
"maintains a pointer that determines the point from which to start searching "
"for the next token.  The first call to B<strtok>()  sets this pointer to "
"point to the first byte of the string.  The start of the next token is "
"determined by scanning forward for the next nondelimiter byte in I<str>.  If"
" such a byte is found, it is taken as the start of the next token.  If no "
"such byte is found, then there are no more tokens, and B<strtok>()  returns "
"NULL.  (A string that is empty or that contains only delimiters will thus "
"cause B<strtok>()  to return NULL on the first call.)"
msgstr "Последовательность вызовов B<strtok>(), оперирующих одной строкой, поддерживает указатель, который определяет точку, с которой начинается поиск следующего токена. Первый вызов B<strtok>() назначает этому указателю ссылку на первый байт строки. Начало следующего токена определяется поиском вперёд в I<str> следующего байта не разделителя. Если байт найден, то он берётся в качестве начала следующего токена. Если такой байт не найден, то токенов больше нет и B<strtok>() возвращает NULL (для пустой строки или состоящей только из разделителей в этом случае NULL вернётся при первом вызове B<strtok>())."

#. type: Plain text
#: man-pages/man3/strtok.3:117
msgid ""
"The end of each token is found by scanning forward until either the next "
"delimiter byte is found or until the terminating null byte (\\(aq\\e0\\(aq) "
"is encountered.  If a delimiter byte is found, it is overwritten with a null"
" byte to terminate the current token, and B<strtok>()  saves a pointer to "
"the following byte; that pointer will be used as the starting point when "
"searching for the next token.  In this case, B<strtok>()  returns a pointer "
"to the start of the found token."
msgstr "Конец каждого токена находится поиском вперёд, длящемся до тех пор, пока не будет найден байт-разделитель или завершающий байт null (\\(aq\\e0\\(aq). Если найден байт-разделитель, то он заменяется байтом null для завершения текущего токена, и B<strtok>() сохраняет указатель на следующий байт; этот указатель будет использован в качестве начальной точки при поиске следующего токена. В этом случае B<strtok>() возвращает указатель на начало найденного токена."

#. type: Plain text
#: man-pages/man3/strtok.3:131
msgid ""
"From the above description, it follows that a sequence of two or more "
"contiguous delimiter bytes in the parsed string is considered to be a single"
" delimiter, and that delimiter bytes at the start or end of the string are "
"ignored.  Put another way: the tokens returned by B<strtok>()  are always "
"nonempty strings.  Thus, for example, given the string \"I<aaa;;bbb,>\", "
"successive calls to B<strtok>()  that specify the delimiter string \"I<;,>\""
" would return the strings \"I<aaa>\" and \"I<bbb>\", and then a null "
"pointer."
msgstr "Из описания выше следует, что последовательность из двух и более непрерывных байтов-разделителей в просматриваемой строке считается одним разделителем, а байты-разделители в начале или конце строки игнорируются. Другими словами, токены, возвращаемые B<strtok>() — всегда не пустые строки. То есть, например, если есть строка «I<aaa;;bbb,>», то последующие вызовы B<strtok>() с заданными разделителями строк «I<;,>» вернули бы строки «I<aaa>» и «I<bbb>», а затем указатель null."

#. type: Plain text
#: man-pages/man3/strtok.3:144
msgid ""
"The B<strtok_r>()  function is a reentrant version B<strtok>().  The "
"I<saveptr> argument is a pointer to a I<char\\ *> variable that is used "
"internally by B<strtok_r>()  in order to maintain context between successive"
" calls that parse the same string."
msgstr "Функция B<strtok_r>() является реентерабельной версией B<strtok>(). Аргумент I<saveptr> является указателем на переменную I<char\\ *>, которая используется внутри B<strtok_r>() для учёта контекста между последующими вызовами при анализе одной и той же строки."

#. type: Plain text
#: man-pages/man3/strtok.3:156
msgid ""
"On the first call to B<strtok_r>(), I<str> should point to the string to be "
"parsed, and the value of I<saveptr> is ignored.  In subsequent calls, I<str>"
" should be NULL, and I<saveptr> should be unchanged since the previous call."
msgstr "При первом вызове B<strtok_r>() значение I<str> должно указывать на анализируемую строку, а значение I<saveptr> игнорируется. При последующих вызовах значение I<str> должно быть NULL, а значение I<saveptr> не должно изменяться с момента предыдущего вызова."

#. type: Plain text
#: man-pages/man3/strtok.3:162
msgid ""
"Different strings may be parsed concurrently using sequences of calls to "
"B<strtok_r>()  that specify different I<saveptr> arguments."
msgstr "Одновременно могут анализироваться разные строки при нескольких запусках B<strtok_r>() с различными аргументами I<saveptr>."

#. type: Plain text
#: man-pages/man3/strtok.3:169
msgid ""
"The B<strtok>()  and B<strtok_r>()  functions return a pointer to the next "
"token, or NULL if there are no more tokens."
msgstr "Функции B<strtok>() и B<strtok_r>() возвращают указатель на следующий токен или NULL, если больше токенов нет."

#. type: Plain text
#: man-pages/man3/strtok.3:174
msgid "The B<strtok>()  function is not thread-safe."
msgstr "Функцию B<strtok>() нельзя использовать в нескольких нитях одновременно."

#. type: Plain text
#: man-pages/man3/strtok.3:178
msgid "The B<strtok_r>()  function is thread-safe."
msgstr "Функцию B<strtok_r>() можно использовать в нескольких нитях одновременно."

#. type: TP
#: man-pages/man3/strtok.3:179
#, no-wrap
msgid "B<strtok>()"
msgstr "B<strtok>()"

#. type: Plain text
#: man-pages/man3/strtok.3:182
msgid "SVr4, POSIX.1-2001, 4.3BSD, C89, C99."
msgstr "SVr4, POSIX.1-2001, 4.3BSD, C89, C99."

#. type: TP
#: man-pages/man3/strtok.3:182
#, no-wrap
msgid "B<strtok_r>()"
msgstr "B<strtok_r>()"

#. type: Plain text
#: man-pages/man3/strtok.3:188
msgid ""
"Be cautious when using these functions.  If you do use them, note that:"
msgstr "Используйте данные функции с осторожностью. Учитывайте, что:"

#. type: Plain text
#: man-pages/man3/strtok.3:190
msgid "These functions modify their first argument."
msgstr "Эти функции изменяют свой первый аргумент."

#. type: Plain text
#: man-pages/man3/strtok.3:192
msgid "These functions cannot be used on constant strings."
msgstr "Эти функции не могут использоваться со строками-константами."

#. type: Plain text
#: man-pages/man3/strtok.3:194
msgid "The identity of the delimiting byte is lost."
msgstr "Теряется идентичность байта-разделителя."

#. type: Plain text
#: man-pages/man3/strtok.3:201
msgid ""
"The B<strtok>()  function uses a static buffer while parsing, so it's not "
"thread safe.  Use B<strtok_r>()  if this matters to you."
msgstr "При анализе функция B<strtok>() использует статический буфер, поэтому не является безопасной для нитей. Используйте B<strtok_r>() в этом случае."

#. type: Plain text
#: man-pages/man3/strtok.3:210
msgid ""
"The program below uses nested loops that employ B<strtok_r>()  to break a "
"string into a two-level hierarchy of tokens.  The first command-line "
"argument specifies the string to be parsed.  The second argument specifies "
"the delimiter byte(s)  to be used to separate that string into \"major\" "
"tokens.  The third argument specifies the delimiter byte(s)  to be used to "
"separate the \"major\" tokens into subtokens."
msgstr "В программе, представленной далее, используются вложенные циклы, которые вызывают B<strtok_r>() для разделения строки на составляющие её токены. В первом параметре командной строки задаётся анализируемая строка. Во втором параметре задаётся байт(ы)- разделитель, который используется для деления строки на «составные» токены. В третьем параметре указывается байт(ы)- разделитель, который используется для разделения «составных» токенов на подтокены."

#. type: Plain text
#: man-pages/man3/strtok.3:212
msgid "An example of the output produced by this program is the following:"
msgstr "Пример результата вывода программы:"

#. type: Plain text
#: man-pages/man3/strtok.3:224
#, no-wrap
msgid ""
"$B< ./a.out \\(aqa/bbb///cc;xxx:yyy:\\(aq \\(aq:;\\(aq \\(aq/\\(aq>\n"
"1: a/bbb///cc\n"
"         --E<gt> a\n"
"         --E<gt> bbb\n"
"         --E<gt> cc\n"
"2: xxx\n"
"         --E<gt> xxx\n"
"3: yyy\n"
"         --E<gt> yyy\n"
msgstr "$B< ./a.out \\(aqa/bbb///cc;xxx:yyy:\\(aq \\(aq:;\\(aq \\(aq/\\(aq>\n1: a/bbb///cc\n         --E<gt> a\n         --E<gt> bbb\n         --E<gt> cc\n2: xxx\n         --E<gt> xxx\n3: yyy\n         --E<gt> yyy\n"

#. type: Plain text
#: man-pages/man3/strtok.3:232
#, no-wrap
msgid ""
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
msgstr "#include E<lt>stdio.hE<gt>\n#include E<lt>stdlib.hE<gt>\n#include E<lt>string.hE<gt>\n"

#. type: Plain text
#: man-pages/man3/strtok.3:239
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    char *str1, *str2, *token, *subtoken;\n"
"    char *saveptr1, *saveptr2;\n"
"    int j;\n"
msgstr "int\nmain(int argc, char *argv[])\n{\n    char *str1, *str2, *token, *subtoken;\n    char *saveptr1, *saveptr2;\n    int j;\n"

#. type: Plain text
#: man-pages/man3/strtok.3:245
#, no-wrap
msgid ""
"    if (argc != 4) {\n"
"        fprintf(stderr, \"Usage: %s string delim subdelim\\en\",\n"
"                argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr "    if (argc != 4) {\n        fprintf(stderr, \"Использование: %s string delim subdelim\\en\",\n                argv[0]);\n        exit(EXIT_FAILURE);\n    }\n"

#. type: Plain text
#: man-pages/man3/strtok.3:251
#, no-wrap
msgid ""
"    for (j = 1, str1 = argv[1]; ; j++, str1 = NULL) {\n"
"        token = strtok_r(str1, argv[2], &saveptr1);\n"
"        if (token == NULL)\n"
"            break;\n"
"        printf(\"%d: %s\\en\", j, token);\n"
msgstr "    for (j = 1, str1 = argv[1]; ; j++, str1 = NULL) {\n        token = strtok_r(str1, argv[2], &saveptr1);\n        if (token == NULL)\n            break;\n        printf(\"%d: %s\\en\", j, token);\n"

#. type: Plain text
#: man-pages/man3/strtok.3:259
#, no-wrap
msgid ""
"        for (str2 = token; ; str2 = NULL) {\n"
"            subtoken = strtok_r(str2, argv[3], &saveptr2);\n"
"            if (subtoken == NULL)\n"
"                break;\n"
"            printf(\"\\t --E<gt> %s\\en\", subtoken);\n"
"        }\n"
"    }\n"
msgstr "        for (str2 = token; ; str2 = NULL) {\n            subtoken = strtok_r(str2, argv[3], &saveptr2);\n            if (subtoken == NULL)\n                break;\n            printf(\"\\t --E<gt> %s\\en\", subtoken);\n        }\n    }\n"

#. type: Plain text
#: man-pages/man3/strtok.3:268
msgid ""
"Another example program using B<strtok>()  can be found in "
"B<getaddrinfo_a>(3)."
msgstr "Ещё один пример программы, использующей B<strtok>(), можно найти в B<getaddrinfo_a>(3)."

#. type: Plain text
#: man-pages/man3/strtok.3:278
msgid ""
"B<index>(3), B<memchr>(3), B<rindex>(3), B<strchr>(3), B<string>(3), "
"B<strpbrk>(3), B<strsep>(3), B<strspn>(3), B<strstr>(3), B<wcstok>(3)"
msgstr "B<index>(3), B<memchr>(3), B<rindex>(3), B<strchr>(3), B<string>(3), B<strpbrk>(3), B<strsep>(3), B<strspn>(3), B<strstr>(3), B<wcstok>(3)"

#. type: TH
#: man-pages/man3/sigvec.3:26
#, no-wrap
msgid "SIGVEC"
msgstr "SIGVEC"

#. type: Plain text
#: man-pages/man3/sigvec.3:29
msgid "sigvec, sigblock, sigsetmask, siggetmask, sigmask - BSD signal API"
msgstr ""

#. type: Plain text
#: man-pages/man3/sigvec.3:33
msgid ""
"B<int sigvec(int >I<sig>B<, const struct sigvec *>I<vec>B<, struct sigvec "
"*>I<ovec>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man3/sigvec.3:35
msgid "B<int sigmask(int >I<signum>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man3/sigvec.3:37
msgid "B<int sigblock(int >I<mask>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man3/sigvec.3:39
msgid "B<int sigsetmask(int >I<mask>B<);>"
msgstr ""

#. type: Plain text
#: man-pages/man3/sigvec.3:41
msgid "B<int siggetmask(void);>"
msgstr ""

#. type: Plain text
#: man-pages/man3/sigvec.3:49
msgid "All functions shown above: _BSD_SOURCE"
msgstr ""

#. type: Plain text
#: man-pages/man3/sigvec.3:56
msgid ""
"These functions are provided in glibc as a compatibility interface for "
"programs that make use of the historical BSD signal API.  This API is "
"obsolete: new applications should use the POSIX signal API (B<sigaction>(2),"
" B<sigprocmask>(2), etc.)."
msgstr ""

#. type: Plain text
#: man-pages/man3/sigvec.3:81
msgid ""
"The B<sigvec>()  function sets and/or gets the disposition of the signal "
"I<sig> (like the POSIX B<sigaction>(2)).  If I<vec> is not NULL, it points "
"to a I<sigvec> structure that defines the new disposition for I<sig>.  If "
"I<ovec> is not NULL, it points to a I<sigvec> structure that is used to "
"return the previous disposition of I<sig>.  To obtain the current "
"disposition of I<sig> without changing it, specify NULL for I<vec>, and a "
"non-null pointer for I<ovec>."
msgstr ""

#. type: Plain text
#: man-pages/man3/sigvec.3:91
msgid "The I<sigvec> structure has the following form:"
msgstr ""

#. type: Plain text
#: man-pages/man3/sigvec.3:99
#, no-wrap
msgid ""
"struct sigvec {\n"
"    void (*sv_handler)(int); /* Signal disposition */\n"
"    int    sv_mask;          /* Signals to be blocked in handler */\n"
"    int    sv_flags;         /* Flags */\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/sigvec.3:110
msgid ""
"The I<sv_handler> field specifies the disposition of the signal, and is "
"either: the address of a signal handler function; B<SIG_DFL>, meaning the "
"default disposition applies for the signal; or B<SIG_IGN>, meaning that the "
"signal is ignored."
msgstr ""

#. type: Plain text
#: man-pages/man3/sigvec.3:124
msgid ""
"If I<sv_handler> specifies the address of a signal handler, then I<sv_mask> "
"specifies a mask of signals that are to be blocked while the handler is "
"executing.  In addition, the signal for which the handler is invoked is also"
" blocked.  Attempts to block B<SIGKILL> or B<SIGSTOP> are silently ignored."
msgstr ""

#. type: Plain text
#: man-pages/man3/sigvec.3:131
msgid ""
"If I<sv_handler> specifies the address of a signal handler, then the "
"I<sv_flags> field specifies flags controlling what happens when the handler "
"is called.  This field may contain zero or more of the following flags:"
msgstr ""

#. type: TP
#: man-pages/man3/sigvec.3:131
#, no-wrap
msgid "B<SV_INTERRUPT>"
msgstr ""

#. type: Plain text
#: man-pages/man3/sigvec.3:139
msgid ""
"If the signal handler interrupts a blocking system call, then upon return "
"from the handler the system call will not be restarted: instead it will fail"
" with the error B<EINTR>.  If this flag is not specified, then system calls "
"are restarted by default."
msgstr ""

#. type: TP
#: man-pages/man3/sigvec.3:139
#, no-wrap
msgid "B<SV_RESETHAND>"
msgstr ""

#. type: Plain text
#: man-pages/man3/sigvec.3:148
msgid ""
"Reset the disposition of the signal to the default before calling the signal"
" handler.  If this flag is not specified, then the handler remains "
"established until explicitly removed by a later call to B<sigvec>()  or "
"until the process performs an B<execve>(2)."
msgstr ""

#. type: TP
#: man-pages/man3/sigvec.3:148
#, no-wrap
msgid "B<SV_ONSTACK>"
msgstr ""

#. type: Plain text
#: man-pages/man3/sigvec.3:155
msgid ""
"Handle the signal on the alternate signal stack (historically established "
"under BSD using the obsolete B<sigstack>()  function; the POSIX replacement "
"is B<sigaltstack>(2))."
msgstr ""

#. type: Plain text
#: man-pages/man3/sigvec.3:165
msgid ""
"The B<sigmask>()  macro constructs and returns a \"signal mask\" for "
"I<signum>.  For example, we can initialize the I<vec.sv_mask> field given to"
" B<sigvec>()  using code such as the following:"
msgstr ""

#. type: Plain text
#: man-pages/man3/sigvec.3:170
#, no-wrap
msgid ""
"    vec.sv_mask = sigmask(SIGQUIT) | sigmask(SIGABRT);\n"
"                /* Block SIGQUIT and SIGABRT during\n"
"                   handler execution */\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/sigvec.3:185
msgid ""
"The B<sigblock>()  function adds the signals in I<mask> to the process's "
"signal mask (like POSIX I<sigprocmask(SIG_BLOCK)>), and returns the "
"process's previous signal mask.  Attempts to block B<SIGKILL> or B<SIGSTOP> "
"are silently ignored."
msgstr ""

#. type: Plain text
#: man-pages/man3/sigvec.3:193
msgid ""
"The B<sigsetmask>()  function sets the process's signal mask to the value "
"given in I<mask> (like POSIX I<sigprocmask(SIG_SETMASK)>), and returns the "
"process's previous signal mask."
msgstr ""

#. type: Plain text
#: man-pages/man3/sigvec.3:199
msgid ""
"The B<siggetmask>()  function returns the process's current signal mask.  "
"This call is equivalent to I<sigblock(0)>."
msgstr ""

#. type: Plain text
#: man-pages/man3/sigvec.3:205
msgid ""
"The B<sigvec>()  function returns 0 on success; on error, it returns -1 and "
"sets I<errno> to indicate the error."
msgstr ""

#. type: Plain text
#: man-pages/man3/sigvec.3:211
msgid ""
"The B<sigblock>()  and B<sigsetmask>()  functions return the previous signal"
" mask."
msgstr ""

#. type: Plain text
#: man-pages/man3/sigvec.3:216
msgid "The B<sigmask>()  macro returns the signal mask for I<signum>."
msgstr ""

#. type: Plain text
#: man-pages/man3/sigvec.3:221
msgid "See the ERRORS under B<sigaction>(2)  and B<sigprocmask>(2)."
msgstr ""

#. type: Plain text
#: man-pages/man3/sigvec.3:230
msgid ""
"The B<sigvec>(), B<sigblock>(), B<sigsetmask>(), and B<siggetmask>()  "
"functions are thread-safe."
msgstr ""

#. type: Plain text
#: man-pages/man3/sigvec.3:234
msgid "The B<sigmask>()  macro is thread-safe."
msgstr ""

#. type: Plain text
#: man-pages/man3/sigvec.3:240
msgid ""
"All of these functions were in 4.3BSD, except B<siggetmask>(), whose origin "
"is unclear.  These functions are obsolete: do not use them in new programs."
msgstr ""

#. type: Plain text
#: man-pages/man3/sigvec.3:257
msgid ""
"On 4.3BSD, the B<signal>()  function provided reliable semantics (as when "
"calling B<sigvec>()  with I<vec.sv_mask> equal to 0).  On System V, "
"B<signal>()  provides unreliable semantics.  POSIX.1-2001 leaves these "
"aspects of B<signal>()  unspecified.  See B<signal>(2)  for further details."
msgstr ""

#. type: Plain text
#: man-pages/man3/sigvec.3:274
msgid ""
"B<kill>(2), B<pause>(2), B<sigaction>(2), B<signal>(2), B<sigprocmask>(2), "
"B<raise>(3), B<sigpause>(3), B<sigset>(3), B<signal>(7)"
msgstr ""

#. type: TH
#: man-pages/man3/setlocale.3:32
#, no-wrap
msgid "SETLOCALE"
msgstr ""

#. type: Plain text
#: man-pages/man3/setlocale.3:35
msgid "setlocale - set the current locale"
msgstr ""

#. type: Plain text
#: man-pages/man3/setlocale.3:38
#, no-wrap
msgid "B<#include E<lt>locale.hE<gt>>\n"
msgstr "B<#include E<lt>locale.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/setlocale.3:40
#, no-wrap
msgid "B<char *setlocale(int >I<category>B<, const char *>I<locale>B<);>\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/setlocale.3:45
msgid ""
"The B<setlocale>()  function is used to set or query the program's current "
"locale."
msgstr ""

#. type: Plain text
#: man-pages/man3/setlocale.3:53
msgid ""
"If I<locale> is not NULL, the program's current locale is modified according"
" to the arguments.  The argument I<category> determines which parts of the "
"program's current locale should be modified."
msgstr ""

#. type: tbl table
#: man-pages/man3/setlocale.3:56
#, no-wrap
msgid "Category\tGoverns\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/setlocale.3:57
#, no-wrap
msgid "LC_ALL\tAll of the locale\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/setlocale.3:58
#, no-wrap
msgid "LC_ADDRESS\tT{\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/setlocale.3:59
#, no-wrap
msgid "Formatting of addresses and\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/setlocale.3:61
#, no-wrap
msgid "geography-related items (*)\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/setlocale.3:63
#, no-wrap
msgid "LC_COLLATE\tString collation\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/setlocale.3:64
#, no-wrap
msgid "LC_CTYPE\tCharacter classification\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/setlocale.3:65
#, no-wrap
msgid "LC_IDENTIFICATION\tMetadata describing the locale (*)\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/setlocale.3:66
#, no-wrap
msgid "LC_MEASUREMENT\tT{\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/setlocale.3:67
#, no-wrap
msgid "Settings related to measurements\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/setlocale.3:69
#, no-wrap
msgid "(metric versus US customary) (*)\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/setlocale.3:71
#, no-wrap
msgid "LC_MESSAGES\tLocalizable natural-language messages\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/setlocale.3:72
#, no-wrap
msgid "LC_MONETARY\tFormatting of monetary values\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/setlocale.3:73
#, no-wrap
msgid "LC_NAME\tFormatting of salutations for persons (*)\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/setlocale.3:74
#, no-wrap
msgid "LC_NUMERIC\tFormatting of nonmonetary numeric values\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/setlocale.3:75
#, no-wrap
msgid "LC_PAPER\tSettings related to the standard paper size (*)\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/setlocale.3:76
#, no-wrap
msgid "LC_TELEPHONE\tFormats to be used with telephone services (*)\n"
msgstr ""

#. type: tbl table
#: man-pages/man3/setlocale.3:77
#, no-wrap
msgid "LC_TIME\tFormatting of date and time values\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/setlocale.3:84
msgid ""
"The categories marked with an asterisk in the above table are GNU "
"extensions.  For further information on these locale categories, see "
"B<locale>(7)."
msgstr ""

#. type: Plain text
#: man-pages/man3/setlocale.3:93
msgid ""
"The argument I<locale> is a pointer to a character string containing the "
"required setting of I<category>.  Such a string is either a well-known "
"constant like \"C\" or \"da_DK\" (see below), or an opaque string that was "
"returned by another call of B<setlocale>()."
msgstr ""

#. type: Plain text
#: man-pages/man3/setlocale.3:115
msgid ""
"If I<locale> is an empty string, B<\"\">, each part of the locale that "
"should be modified is set according to the environment variables.  The "
"details are implementation-dependent.  For glibc, first (regardless of "
"I<category>), the environment variable B<LC_ALL> is inspected, next the "
"environment variable with the same name as the category (see the table "
"above), and finally the environment variable B<LANG>.  The first existing "
"environment variable is used.  If its value is not a valid locale "
"specification, the locale is unchanged, and B<setlocale>()  returns NULL."
msgstr ""

#. type: Plain text
#: man-pages/man3/setlocale.3:124
msgid ""
"The locale B<\"C\"> or B<\"POSIX\"> is a portable locale; its B<LC_CTYPE> "
"part corresponds to the 7-bit ASCII character set."
msgstr ""

#. type: Plain text
#: man-pages/man3/setlocale.3:139
msgid ""
"A locale name is typically of the form "
"I<language>[_I<territory>][.I<codeset>][@I<modifier>], where I<language> is "
"an ISO 639 language code, I<territory> is an ISO 3166 country code, and "
"I<codeset> is a character set or encoding identifier like B<ISO-8859-1> or "
"B<UTF-8>.  For a list of all supported locales, try \"locale -a\", cf.\\& "
"B<locale>(1)."
msgstr ""

#. type: Plain text
#: man-pages/man3/setlocale.3:143
msgid ""
"If I<locale> is NULL, the current locale is only queried, not modified."
msgstr ""

#. type: Plain text
#: man-pages/man3/setlocale.3:148
msgid ""
"On startup of the main program, the portable B<\"C\"> locale is selected as "
"default.  A program may be made portable to all locales by calling:"
msgstr ""

#. type: Plain text
#: man-pages/man3/setlocale.3:151
#, no-wrap
msgid "    setlocale(LC_ALL, \"\");\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/setlocale.3:167
msgid ""
"after program initialization, by using the values returned from a "
"B<localeconv>(3)  call for locale-dependent information, by using the "
"multibyte and wide character functions for text processing if B<MB_CUR_MAX "
"E<gt> 1>, and by using B<strcoll>(3), B<wcscoll>(3)  or B<strxfrm>(3), "
"B<wcsxfrm>(3)  to compare strings."
msgstr ""

#. type: Plain text
#: man-pages/man3/setlocale.3:176
msgid ""
"A successful call to B<setlocale>()  returns an opaque string that "
"corresponds to the locale set.  This string may be allocated in static "
"storage.  The string returned is such that a subsequent call with that "
"string and its associated category will restore that part of the process's "
"locale.  The return value is NULL if the request cannot be honored."
msgstr ""

#. type: Plain text
#: man-pages/man3/setlocale.3:188
msgid ""
"B<locale>(1), B<localedef>(1), B<isalpha>(3), B<localeconv>(3), "
"B<nl_langinfo>(3), B<rpmatch>(3), B<strcoll>(3), B<strftime>(3), "
"B<charsets>(7), B<locale>(7)"
msgstr ""

#. type: TH
#: man-pages/man3/syslog.3:36
#, no-wrap
msgid "2012-08-17"
msgstr "2012-08-17"

#. type: Plain text
#: man-pages/man3/syslog.3:39
msgid ""
"closelog, openlog, syslog, vsyslog - send messages to the system logger"
msgstr "closelog, openlog, syslog, vsyslog - отправка сообщений в службу журналирования"

#. type: Plain text
#: man-pages/man3/syslog.3:41
msgid "B<#include E<lt>syslog.hE<gt>>"
msgstr "B<#include E<lt>syslog.hE<gt>>"

#. type: Plain text
#: man-pages/man3/syslog.3:43
msgid ""
"B<void openlog(const char *>I<ident>B<, int >I<option>B<, int "
">I<facility>B<);>"
msgstr "B<void openlog(const char *>I<ident>B<, int >I<option>B<, int >I<facility>B<);>"

#. type: Plain text
#: man-pages/man3/syslog.3:45
msgid "B<void syslog(int >I<priority>B<, const char *>I<format>B<, ...);>"
msgstr "B<void syslog(int >I<priority>B<, const char *>I<format>B<, ...);>"

#. type: Plain text
#: man-pages/man3/syslog.3:47
msgid "B<void closelog(void);>"
msgstr "B<void closelog(void);>"

#. type: Plain text
#: man-pages/man3/syslog.3:51
msgid ""
"B<void vsyslog(int >I<priority>B<, const char *>I<format>B<, va_list "
">I<ap>B<);>"
msgstr "B<void vsyslog(int >I<priority>B<, const char *>I<format>B<, va_list >I<ap>B<);>"

#. type: Plain text
#: man-pages/man3/syslog.3:59
msgid "B<vsyslog>(): _BSD_SOURCE"
msgstr "B<vsyslog>(): _BSD_SOURCE"

#. type: Plain text
#: man-pages/man3/syslog.3:65
msgid ""
"B<closelog>()  closes the descriptor being used to write to the system "
"logger.  The use of B<closelog>()  is optional."
msgstr "Функция B<closelog>() закрывает дескриптор, использованный для записи в службу журналирования. Использование B<closelog>() не обязательно."

#. type: Plain text
#: man-pages/man3/syslog.3:77
msgid ""
"B<openlog>()  opens a connection to the system logger for a program.  The "
"string pointed to by I<ident> is prepended to every message, and is "
"typically set to the program name.  If I<ident> is NULL, the program name is"
" used.  (POSIX.1-2008 does not specify the behavior when I<ident> is NULL.)"
msgstr "Функция B<openlog>() открывает для программы соединение со службой журналирования. Строка, на которую указывает I<ident>, будет предварять каждое сообщение, обычно это имя программы. Если значение I<ident> равно NULL, то используется имя программы (в POSIX.1-2008 не указано, что случается, если I<ident> равно NULL)."

#. type: Plain text
#: man-pages/man3/syslog.3:101
msgid ""
"The I<option> argument specifies flags which control the operation of "
"B<openlog>()  and subsequent calls to B<syslog>().  The I<facility> argument"
" establishes a default to be used if none is specified in subsequent calls "
"to B<syslog>().  Values for I<option> and I<facility> are given below.  The "
"use of B<openlog>()  is optional; it will automatically be called by "
"B<syslog>()  if necessary, in which case I<ident> will default to NULL."
msgstr "В аргументе I<option> указываются флаги, контролирующие действия B<openlog>() и последующих вызовов B<syslog>(). Аргумент I<facility> устанавливает значения по умолчанию (если не будет указано иначе) для последующих вызовов B<syslog>(). Значения для I<option> и I<facility> представлены ниже. Использование B<openlog>() не обязательно, она будет вызвана B<syslog>() в случае необходимости (в этом случае I<ident> будет установлено по умолчанию в NULL)."

#. type: Plain text
#: man-pages/man3/syslog.3:125
msgid ""
"B<syslog>()  generates a log message, which will be distributed by "
"B<syslogd>(8).  The I<priority> argument is formed by ORing the I<facility> "
"and the I<level> values (explained below).  The remaining arguments are a "
"I<format>, as in B<printf>(3)  and any arguments required by the I<format>, "
"except that the two character sequence B<%m> will be replaced by the error "
"message string I<strerror>(I<errno>).  A trailing newline may be added if "
"needed."
msgstr "Функция B<syslog>() создает сообщение журнала, которое доставляется B<syslogd>(8). Аргумент I<priority> формируется в результате логического OR значений I<facility> и I<level> (описанных ниже). Оставшиеся аргументы \\(em I<format> в формате B<printf>(3) и аргументы, необходимые для I<format>, за исключением последовательности двух символов B<%m>, заменяемых строкой ошибки I<strerror>(I<errno>). В случае необходимости можно добавить новую строку."

#. type: Plain text
#: man-pages/man3/syslog.3:134
msgid ""
"The function B<vsyslog>()  performs the same task as B<syslog>()  with the "
"difference that it takes a set of arguments which have been obtained using "
"the B<stdarg>(3)  variable argument list macros."
msgstr "Функция B<vsyslog>() выполняет то же самое, что и B<syslog>() с той лишь разницей, что она принимает набор аргументов, получаемых с использованием списка макросов B<stdarg>(3)."

#. type: Plain text
#: man-pages/man3/syslog.3:137
msgid ""
"The subsections below list the parameters used to set the values of "
"I<option>,I< facility>, and I<priority>."
msgstr "Следующий список используется в качестве значения для I<option>, I< facility> и I<priority>."

#. type: SS
#: man-pages/man3/syslog.3:137
#, no-wrap
msgid "option"
msgstr "параметр"

#. type: Plain text
#: man-pages/man3/syslog.3:143
msgid "The I<option> argument to B<openlog>()  is an OR of any of these:"
msgstr "Аргумент I<option> для B<openlog>() может образовываться логическим OR из следующих значений:"

#. type: TP
#: man-pages/man3/syslog.3:143
#, no-wrap
msgid "B<LOG_CONS>"
msgstr "B<LOG_CONS>"

#. type: Plain text
#: man-pages/man3/syslog.3:147
msgid ""
"Write directly to system console if there is an error while sending to "
"system logger."
msgstr "Писать напрямую в системную консоль, если при отправке в систему журналирования возникла ошибка."

#. type: TP
#: man-pages/man3/syslog.3:147
#, no-wrap
msgid "B<LOG_NDELAY>"
msgstr "B<LOG_NDELAY>"

#. type: Plain text
#: man-pages/man3/syslog.3:151
msgid ""
"Open the connection immediately (normally, the connection is opened when the"
" first message is logged)."
msgstr "Немедленно открыть соединение (обычно соединение открывается при первом сообщении)."

#. type: TP
#: man-pages/man3/syslog.3:151
#, no-wrap
msgid "B<LOG_NOWAIT>"
msgstr "B<LOG_NOWAIT>"

#. type: Plain text
#: man-pages/man3/syslog.3:157
msgid ""
"Don't wait for child processes that may have been created while logging the "
"message.  (The GNU C library does not create a child process, so this option"
" has no effect on Linux.)"
msgstr "Не ждать дочерних процессов, которые могут быть созданы во время журналирования сообщения (библиотека GNU C не создаёт дочерних процессов, так что в Linux этот параметр не действует)."

#. type: TP
#: man-pages/man3/syslog.3:157
#, no-wrap
msgid "B<LOG_ODELAY>"
msgstr "B<LOG_ODELAY>"

#. type: Plain text
#: man-pages/man3/syslog.3:165
msgid ""
"The converse of B<LOG_NDELAY>; opening of the connection is delayed until "
"B<syslog>()  is called.  (This is the default, and need not be specified.)"
msgstr "Противоположен B<LOG_NDELAY>; открытие подключения откладывается, пока не будет вызван B<syslog>() (этот параметр используется по умолчанию, нет необходимости выставлять его вручную)."

#. type: TP
#: man-pages/man3/syslog.3:165
#, no-wrap
msgid "B<LOG_PERROR>"
msgstr "B<LOG_PERROR>"

#. type: Plain text
#: man-pages/man3/syslog.3:169
msgid "(Not in POSIX.1-2001 or POSIX.1-2008.)  Print to I<stderr> as well."
msgstr "(Нет в POSIX.1-2001 или POSIX.1-2008.) Также выводить сообщение в I<stderr>."

#. type: TP
#: man-pages/man3/syslog.3:169
#, no-wrap
msgid "B<LOG_PID>"
msgstr "B<LOG_PID>"

#. type: Plain text
#: man-pages/man3/syslog.3:172
msgid "Include PID with each message."
msgstr "Включать PID в каждое сообщение."

#. type: SS
#: man-pages/man3/syslog.3:172
#, no-wrap
msgid "facility"
msgstr "объект"

#. type: Plain text
#: man-pages/man3/syslog.3:178
msgid ""
"The I<facility> argument is used to specify what type of program is logging "
"the message.  This lets the configuration file specify that messages from "
"different facilities will be handled differently."
msgstr "Аргумент I<facility> используется для указания типа программы, записывающей сообщение. Благодаря этому с помощью файла настройки можно по-разному обрабатывать сообщения от разных объектов."

#. type: TP
#: man-pages/man3/syslog.3:178
#, no-wrap
msgid "B<LOG_AUTH>"
msgstr "B<LOG_AUTH>"

#. type: Plain text
#: man-pages/man3/syslog.3:181
msgid "security/authorization messages"
msgstr "сообщения безопасности/авторизации"

#. type: TP
#: man-pages/man3/syslog.3:181
#, no-wrap
msgid "B<LOG_AUTHPRIV>"
msgstr "B<LOG_AUTHPRIV>"

#. type: Plain text
#: man-pages/man3/syslog.3:184
msgid "security/authorization messages (private)"
msgstr "сообщения безопасности/авторизации (private)"

#. type: TP
#: man-pages/man3/syslog.3:184
#, no-wrap
msgid "B<LOG_CRON>"
msgstr "B<LOG_CRON>"

#. type: Plain text
#: man-pages/man3/syslog.3:188
msgid "clock daemon (B<cron> and B<at>)"
msgstr "планировщик заданий (B<cron> и B<at>)"

#. type: TP
#: man-pages/man3/syslog.3:188
#, no-wrap
msgid "B<LOG_DAEMON>"
msgstr "B<LOG_DAEMON>"

#. type: Plain text
#: man-pages/man3/syslog.3:191
msgid "system daemons without separate facility value"
msgstr "системные службы без определенного значения объекта"

#. type: TP
#: man-pages/man3/syslog.3:191
#, no-wrap
msgid "B<LOG_FTP>"
msgstr "B<LOG_FTP>"

#. type: Plain text
#: man-pages/man3/syslog.3:194
msgid "ftp daemon"
msgstr "служба FTP"

#. type: TP
#: man-pages/man3/syslog.3:194
#, no-wrap
msgid "B<LOG_KERN>"
msgstr "B<LOG_KERN>"

#.  LOG_KERN has the value 0; if used as a facility, zero translates to:
#.  "use the default facility".
#. type: Plain text
#: man-pages/man3/syslog.3:199
msgid "kernel messages (these can't be generated from user processes)"
msgstr "сообщения ядра (не могут быть созданы пользовательскими процессами)"

#. type: TP
#: man-pages/man3/syslog.3:199
#, no-wrap
msgid "B<LOG_LOCAL0> through B<LOG_LOCAL7>"
msgstr "с B<LOG_LOCAL0> по B<LOG_LOCAL7>"

#. type: Plain text
#: man-pages/man3/syslog.3:202
msgid "reserved for local use"
msgstr "зарезервировано для локального использования"

#. type: TP
#: man-pages/man3/syslog.3:202
#, no-wrap
msgid "B<LOG_LPR>"
msgstr "B<LOG_LPR>"

#. type: Plain text
#: man-pages/man3/syslog.3:205
msgid "line printer subsystem"
msgstr "подсистема печати"

#. type: TP
#: man-pages/man3/syslog.3:205
#, no-wrap
msgid "B<LOG_MAIL>"
msgstr "B<LOG_MAIL>"

#. type: Plain text
#: man-pages/man3/syslog.3:208
msgid "mail subsystem"
msgstr "почтовая подсистема"

#. type: TP
#: man-pages/man3/syslog.3:208
#, no-wrap
msgid "B<LOG_NEWS>"
msgstr "B<LOG_NEWS>"

#. type: Plain text
#: man-pages/man3/syslog.3:211
msgid "USENET news subsystem"
msgstr "подсистема новостей USENET"

#. type: TP
#: man-pages/man3/syslog.3:211
#, no-wrap
msgid "B<LOG_SYSLOG>"
msgstr "B<LOG_SYSLOG>"

#. type: Plain text
#: man-pages/man3/syslog.3:215
msgid "messages generated internally by B<syslogd>(8)"
msgstr "сообщения, сгенерированные самой службой B<syslogd>(8)"

#. type: TP
#: man-pages/man3/syslog.3:215
#, no-wrap
msgid "B<LOG_USER> (default)"
msgstr "B<LOG_USER> (по умолчанию)"

#. type: Plain text
#: man-pages/man3/syslog.3:218
msgid "generic user-level messages"
msgstr "обычные сообщения пользовательского уровня"

#. type: TP
#: man-pages/man3/syslog.3:218
#, no-wrap
msgid "B<LOG_UUCP>"
msgstr "B<LOG_UUCP>"

#. type: Plain text
#: man-pages/man3/syslog.3:221
msgid "UUCP subsystem"
msgstr "подсистема UUCP"

#. type: SS
#: man-pages/man3/syslog.3:221
#, no-wrap
msgid "level"
msgstr "уровень"

#. type: Plain text
#: man-pages/man3/syslog.3:224
msgid ""
"This determines the importance of the message.  The levels are, in order of "
"decreasing importance:"
msgstr "Определяет важность сообщения. Ниже указаны уровни по уменьшению важности:"

#. type: TP
#: man-pages/man3/syslog.3:224
#, no-wrap
msgid "B<LOG_EMERG>"
msgstr "B<LOG_EMERG>"

#. type: Plain text
#: man-pages/man3/syslog.3:227
msgid "system is unusable"
msgstr "система в нерабочем состоянии"

#. type: TP
#: man-pages/man3/syslog.3:227
#, no-wrap
msgid "B<LOG_ALERT>"
msgstr "B<LOG_ALERT>"

#. type: Plain text
#: man-pages/man3/syslog.3:230
msgid "action must be taken immediately"
msgstr "необходимо срочное вмешательство"

#. type: TP
#: man-pages/man3/syslog.3:230
#, no-wrap
msgid "B<LOG_CRIT>"
msgstr "B<LOG_CRIT>"

#. type: Plain text
#: man-pages/man3/syslog.3:233
msgid "critical conditions"
msgstr "критические состояния"

#. type: TP
#: man-pages/man3/syslog.3:233
#, no-wrap
msgid "B<LOG_ERR>"
msgstr "B<LOG_ERR>"

#. type: Plain text
#: man-pages/man3/syslog.3:236
msgid "error conditions"
msgstr "ошибки"

#. type: TP
#: man-pages/man3/syslog.3:236
#, no-wrap
msgid "B<LOG_WARNING>"
msgstr "B<LOG_WARNING>"

#. type: Plain text
#: man-pages/man3/syslog.3:239
msgid "warning conditions"
msgstr "предупреждения"

#. type: TP
#: man-pages/man3/syslog.3:239
#, no-wrap
msgid "B<LOG_NOTICE>"
msgstr "B<LOG_NOTICE>"

#. type: Plain text
#: man-pages/man3/syslog.3:242
msgid "normal, but significant, condition"
msgstr "обычные, но важные сообщения"

#. type: TP
#: man-pages/man3/syslog.3:242
#, no-wrap
msgid "B<LOG_INFO>"
msgstr "B<LOG_INFO>"

#. type: Plain text
#: man-pages/man3/syslog.3:245
msgid "informational message"
msgstr "информационные сообщения"

#. type: TP
#: man-pages/man3/syslog.3:245
#, no-wrap
msgid "B<LOG_DEBUG>"
msgstr "B<LOG_DEBUG>"

#. type: Plain text
#: man-pages/man3/syslog.3:248
msgid "debug-level message"
msgstr "сообщения уровня отладки"

#. type: Plain text
#: man-pages/man3/syslog.3:252
msgid ""
"The function B<setlogmask>(3)  can be used to restrict logging to specified "
"levels only."
msgstr "Для ограничения журналирования только в определенные уровни можно использовать функцию B<setlogmask>(3)."

#.  .SH HISTORY
#.  A
#.  .BR syslog ()
#.  function call appeared in 4.2BSD.
#.  4.3BSD documents
#.  .BR openlog (),
#.  .BR syslog (),
#.  .BR closelog (),
#.  and
#.  .BR setlogmask ().
#.  4.3BSD-Reno also documents
#.  .BR vsyslog ().
#.  Of course early v* functions used the
#.  .I <varargs.h>
#.  mechanism, which is not compatible with
#.  .IR <stdarg.h> .
#. type: Plain text
#: man-pages/man3/syslog.3:296
msgid ""
"The functions B<openlog>(), B<closelog>(), and B<syslog>()  (but not "
"B<vsyslog>())  are specified in SUSv2, POSIX.1-2001, and POSIX.1-2008.  "
"POSIX.1-2001 specifies only the B<LOG_USER> and B<LOG_LOCAL*> values for "
"I<facility>.  However, with the exception of B<LOG_AUTHPRIV> and B<LOG_FTP>,"
" the other I<facility> values appear on most UNIX systems.  The "
"B<LOG_PERROR> value for I<option> is not specified by POSIX.1-2001 or "
"POSIX.1-2008, but is available in most versions of UNIX."
msgstr "Функции B<openlog>(), B<closelog>() и B<syslog>() (но не B<vsyslog>()) описаны в SUSv2, POSIX.1-2001 и POSIX.1-2008. В POSIX.1-2001 для I<facility> описаны только B<LOG_USER> и B<LOG_LOCAL*>. Однако, за исключением B<LOG_AUTHPRIV> и B<LOG_FTP>, остальные значения I<facility> присутствуют в большинстве систем UNIX. Значение B<LOG_PERROR> для I<option> не описано в POSIX.1-2001 или POSIX.1-2008, однако доступно в большинстве версий UNIX."

#. type: Plain text
#: man-pages/man3/syslog.3:308
msgid ""
"The argument I<ident> in the call of B<openlog>()  is probably stored as-is."
"  Thus, if the string it points to is changed, B<syslog>()  may start "
"prepending the changed string, and if the string it points to ceases to "
"exist, the results are undefined.  Most portable is to use a string "
"constant."
msgstr "Аргумент I<ident> при вызове B<openlog>() сохраняется как есть. Поэтому, если строка меняется, B<syslog>() может начать добавлять уже изменённую строку. Если строка перестаёт существовать, то это может привести к непредвиденным результатам. Наиболее переносимый способ в данном случае \\(em использовать строковую константу."

#. type: Plain text
#: man-pages/man3/syslog.3:311
msgid ""
"Never pass a string with user-supplied data as a format, use the following "
"instead:"
msgstr "Никогда не подставляйте пользовательские данные в качестве формата представления, используйте вместо этого:"

#. type: Plain text
#: man-pages/man3/syslog.3:314
#, no-wrap
msgid "    syslog(priority, \"%s\", string);\n"
msgstr "    syslog(priority, \"%s\", string);\n"

#. type: Plain text
#: man-pages/man3/syslog.3:319
msgid "B<logger>(1), B<setlogmask>(3), B<syslog.conf>(5), B<syslogd>(8)"
msgstr "B<logger>(1), B<setlogmask>(3), B<syslog.conf>(5), B<syslogd>(8)"

#. type: TH
#: man-pages/man3/stpncpy.3:14
#, no-wrap
msgid "STPNCPY"
msgstr "STPNCPY"

#. type: Plain text
#: man-pages/man3/stpncpy.3:17
msgid "stpncpy - copy a fixed-size string, returning a pointer to its end"
msgstr "stpncpy - копирование строки фиксированной длины с возвращением указателя на её конец"

#. type: Plain text
#: man-pages/man3/stpncpy.3:22
#, no-wrap
msgid ""
"B<char *stpncpy(char *>I<dest>B<, const char *>I<src>B<, size_t >I<n>B<);>\n"
msgstr "B<char *stpncpy(char *>I<dest>B<, const char *>I<src>B<, size_t >I<n>B<);>\n"

#. type: Plain text
#: man-pages/man3/stpncpy.3:30
msgid "B<stpncpy>():"
msgstr "B<stpncpy>():"

#. type: Plain text
#: man-pages/man3/stpncpy.3:74
msgid ""
"The B<stpncpy>()  function copies at most I<n> characters from the string "
"pointed to by I<src>, including the terminating null byte (\\(aq\\e0\\(aq), "
"to the array pointed to by I<dest>.  Exactly I<n> characters are written at "
"I<dest>.  If the length I<strlen(src)> is smaller than I<n>, the remaining "
"characters in the array pointed to by I<dest> are filled with null bytes "
"(\\(aq\\e0\\(aq), If the length I<strlen(src)> is greater than or equal to "
"I<n>, the string pointed to by I<dest> will not be null-terminated."
msgstr "Функция B<stpncpy>() копирует не более I<n> символов из строки, на которую ссылается указатель I<src>, включая конечный байт null (\\(aq\\e0\\(aq), в массив по указателю I<dest>. В I<dest> будет записано точно I<n> символов. Если длина I<strlen(src)> меньше I<n>, то оставшиеся символы в массиве I<dest> будут заполнены байтами null (\\(aq\\e\\(aq). Если длина I<strlen(src)> больше или равна I<n>, то строка, на которую ссылается указатель I<dest>, не будет завершаться null."

#. type: Plain text
#: man-pages/man3/stpncpy.3:76
msgid "The strings may not overlap."
msgstr "Строки не должны пересекаться."

#. type: Plain text
#: man-pages/man3/stpncpy.3:82
msgid ""
"The programmer must ensure that there is room for at least I<n> characters "
"at I<dest>."
msgstr "Программист должен быть уверен, что в I<dest> достаточно места для по крайней мере I<n> символов."

#. type: Plain text
#: man-pages/man3/stpncpy.3:91
msgid ""
"B<stpncpy>()  returns a pointer to the terminating null byte in I<dest>, or,"
" if I<dest> is not null-terminated, I<dest>+I<n>."
msgstr "B<stpncpy>() возвращает указатель на завершающий байт null в I<dest> или, если I<dest> не завершается null, I<dest>+I<n>."

#. type: Plain text
#: man-pages/man3/stpncpy.3:96
msgid "The B<stpncpy>()  function is thread-safe."
msgstr "Функцию B<stpncpy>() можно использовать в нескольких нитях одновременно."

#. type: Plain text
#: man-pages/man3/stpncpy.3:100
msgid ""
"This function was added to POSIX.1-2008.  Before that, it was a GNU "
"extension.  It first appeared in version 1.07 of the GNU C library in 1993."
msgstr "Эта функция была добавлена в POSIX.1-2008. До этого она считалась расширением GNU. Впервые она появилась в версии 1.07 библиотеки GNU C в 1993 году."

#. type: Plain text
#: man-pages/man3/stpncpy.3:102
msgid "B<strncpy>(3), B<wcpncpy>(3)"
msgstr "B<strncpy>(3), B<wcpncpy>(3)"

#. type: TH
#: man-pages/man3/signbit.3:11
#, no-wrap
msgid "SIGNBIT"
msgstr "SIGNBIT"

#. type: TH
#: man-pages/man3/signbit.3:11
#, no-wrap
msgid "2013-07-04"
msgstr "2013-07-04"

#. type: Plain text
#: man-pages/man3/signbit.3:14
msgid "signbit - test sign of a real floating-point number"
msgstr "signbit - проверка знака вещественного числа с плавающей точкой"

#. type: Plain text
#: man-pages/man3/signbit.3:18
msgid "B<int signbit(>I<x>B<);>"
msgstr "B<int signbit(>I<x>B<);>"

#. type: Plain text
#: man-pages/man3/signbit.3:28
msgid "B<signbit>():"
msgstr "B<signbit>():"

#. type: Plain text
#: man-pages/man3/signbit.3:42
msgid ""
"B<signbit>()  is a generic macro which can work on all real floating-point "
"types.  It returns a nonzero value if the value of I<x> has its sign bit "
"set."
msgstr "Функция B<signbit>() является общим макросом, который может работать со всем типами вещественных чисел с плавающей точкой. Она возвращает ненулевое значение, если у I<x> установлен бит знака."

#. type: Plain text
#: man-pages/man3/signbit.3:51
msgid ""
"This is not the same as I<x E<lt> 0.0>, because IEEE 754 floating point "
"allows zero to be signed.  The comparison I<-0.0 E<lt> 0.0> is false, but "
"I<signbit(-0.0)> will return a nonzero value."
msgstr "Это не подходит для I<x E<lt> 0.0>, так как, согласно IEEE 754, спецификация плавающей точки допускает, что ноль может иметь знак. Сравнение I<-0.0 E<lt> 0.0> будет ложным, однако I<signbit(-0.0)> вернет ненулевое значение."

#. type: Plain text
#: man-pages/man3/signbit.3:53
msgid "NaNs and infinities have a sign bit."
msgstr "Значение NaN и бесконечностей имеют бит знака."

#. type: Plain text
#: man-pages/man3/signbit.3:59
msgid ""
"The B<signbit>()  macro returns nonzero if the sign of I<x> is negative; "
"otherwise it returns zero."
msgstr "Макрос B<signbit>() возвращает ненулевое значение, если знак I<x> отрицателен, иначе он возвращает ноль."

#. type: Plain text
#: man-pages/man3/signbit.3:61
msgid "No errors occur."
msgstr "Ошибки не возникают."

#. type: Plain text
#: man-pages/man3/signbit.3:66
msgid "The B<signbit>()  macro is thread-safe."
msgstr "Макрос B<signbit>() можно использовать в нескольких нитях одновременно."

#. type: Plain text
#: man-pages/man3/signbit.3:70
msgid ""
"C99, POSIX.1-2001.  This function is defined in IEC 559 (and the appendix "
"with recommended functions in IEEE 754/IEEE 854)."
msgstr "C99, POSIX.1-2001. Данная функция определена в IEC 559 (и в приложении с рекомендуемыми функциями в IEEE 754/IEEE 854)."

#. type: Plain text
#: man-pages/man3/signbit.3:71
msgid "B<copysign>(3)"
msgstr "B<copysign>(3)"

#. type: TH
#: man-pages/man3/sysconf.3:27
#, no-wrap
msgid "SYSCONF"
msgstr "SYSCONF"

#. type: TH
#: man-pages/man3/sysconf.3:27
#, no-wrap
msgid "2014-03-20"
msgstr "2014-03-20"

#. type: Plain text
#: man-pages/man3/sysconf.3:30
msgid "sysconf - get configuration information at run time"
msgstr ""

#. type: Plain text
#: man-pages/man3/sysconf.3:35
#, no-wrap
msgid "B<long sysconf(int >I<name>B<);>\n"
msgstr "B<long sysconf(int >I<name>B<);>\n"

#. type: Plain text
#: man-pages/man3/sysconf.3:40
msgid ""
"POSIX allows an application to test at compile or run time whether certain "
"options are supported, or what the value is of certain configurable "
"constants or limits."
msgstr "Согласно POSIX, приложение может осуществлять проверку на стадии компиляции или выполнения поддержку определенных параметров или получать значения настраиваемых констант или ограничений."

#. type: Plain text
#: man-pages/man3/sysconf.3:46
msgid ""
"At compile time this is done by including I<E<lt>unistd.hE<gt>> and/or "
"I<E<lt>limits.hE<gt>> and testing the value of certain macros."
msgstr "На стадии компиляции это осуществляется при помощи включения I<E<lt>unistd.hE<gt>> и/или I<E<lt>limits.hE<gt>> и проверки значения определенного макроса."

#. type: Plain text
#: man-pages/man3/sysconf.3:56
msgid ""
"At run time, one can ask for numerical values using the present function "
"B<sysconf>().  One can ask for numerical values that may depend on the "
"filesystem a file is in using the calls B<fpathconf>(3)  and B<pathconf>(3)."
"  One can ask for string values using B<confstr>(3)."
msgstr ""

#.  except that sysconf(_SC_OPEN_MAX) may change answer after a call
#.  to setrlimit( ) which changes the RLIMIT_NOFILE soft limit
#. type: Plain text
#: man-pages/man3/sysconf.3:61
msgid ""
"The values obtained from these functions are system configuration constants."
"  They do not change during the lifetime of a process."
msgstr ""

#.  and 999 to indicate support for options no longer present in the latest
#.  standard. (?)
#. type: Plain text
#: man-pages/man3/sysconf.3:84
msgid ""
"For options, typically, there is a constant B<_POSIX_FOO> that may be "
"defined in I<E<lt>unistd.hE<gt>>.  If it is undefined, one should ask at run"
" time.  If it is defined to -1, then the option is not supported.  If it is "
"defined to 0, then relevant functions and headers exist, but one has to ask "
"at run time what degree of support is available.  If it is defined to a "
"value other than -1 or 0, then the option is supported.  Usually the value "
"(such as 200112L) indicates the year and month of the POSIX revision "
"describing the option.  Glibc uses the value 1 to indicate support as long "
"as the POSIX revision has not been published yet.  The B<sysconf>()  "
"argument will be B<_SC_FOO>.  For a list of options, see B<posixoptions>(7)."
msgstr ""

#. type: Plain text
#: man-pages/man3/sysconf.3:104
msgid ""
"For variables or limits, typically, there is a constant B<_FOO>, maybe "
"defined in I<E<lt>limits.hE<gt>>, or B<_POSIX_FOO>, maybe defined in "
"I<E<lt>unistd.hE<gt>>.  The constant will not be defined if the limit is "
"unspecified.  If the constant is defined, it gives a guaranteed value, and a"
" greater value might actually be supported.  If an application wants to take"
" advantage of values which may change between systems, a call to "
"B<sysconf>()  can be made.  The B<sysconf>()  argument will be B<_SC_FOO>."
msgstr ""

#. type: SS
#: man-pages/man3/sysconf.3:104
#, no-wrap
msgid "POSIX.1 variables"
msgstr ""

#. type: Plain text
#: man-pages/man3/sysconf.3:109
msgid ""
"We give the name of the variable, the name of the B<sysconf>()  argument "
"used to inquire about its value, and a short description."
msgstr ""

#.  [for the moment: only the things that are unconditionally present]
#.  .TP
#.  .BR AIO_LISTIO_MAX " - " _SC_AIO_LISTIO_MAX
#.  (if _POSIX_ASYNCHRONOUS_IO)
#.  Maximum number of I/O operations in a single list I/O call.
#.  Must not be less than _POSIX_AIO_LISTIO_MAX.
#.  .TP
#.  .BR AIO_MAX " - " _SC_AIO_MAX
#.  (if _POSIX_ASYNCHRONOUS_IO)
#.  Maximum number of outstanding asynchronous I/O operations.
#.  Must not be less than _POSIX_AIO_MAX.
#.  .TP
#.  .BR AIO_PRIO_DELTA_MAX " - " _SC_AIO_PRIO_DELTA_MAX
#.  (if _POSIX_ASYNCHRONOUS_IO)
#.  The maximum amount by which a process can decrease its
#.  asynchronous I/O priority level from its own scheduling priority.
#.  Must be nonnegative.
#. type: Plain text
#: man-pages/man3/sysconf.3:128
msgid "First, the POSIX.1 compatible values."
msgstr ""

#. type: TP
#: man-pages/man3/sysconf.3:128
#, no-wrap
msgid "B<ARG_MAX> - B<_SC_ARG_MAX>"
msgstr "B<ARG_MAX> - B<_SC_ARG_MAX>"

#. type: Plain text
#: man-pages/man3/sysconf.3:136
msgid ""
"The maximum length of the arguments to the B<exec>(3)  family of functions."
"  Must not be less than B<_POSIX_ARG_MAX> (4096)."
msgstr "Максимально допустимая длина аргументов для семейства функций B<exec>(3). Должна быть не меньше B<_POSIX_ARG_MAX> (4096)."

#. type: TP
#: man-pages/man3/sysconf.3:136
#, no-wrap
msgid "B<CHILD_MAX> - B<_SC_CHILD_MAX>"
msgstr "B<CHILD_MAX> - B<_SC_CHILD_MAX>"

#. type: Plain text
#: man-pages/man3/sysconf.3:142
msgid ""
"The maximum number of simultaneous processes per user ID.  Must not be less "
"than B<_POSIX_CHILD_MAX> (25)."
msgstr ""

#. type: TP
#: man-pages/man3/sysconf.3:142
#, no-wrap
msgid "B<HOST_NAME_MAX> - B<_SC_HOST_NAME_MAX>"
msgstr "B<HOST_NAME_MAX> - B<_SC_HOST_NAME_MAX>"

#. type: Plain text
#: man-pages/man3/sysconf.3:150
msgid ""
"Maximum length of a hostname, not including the terminating null byte, as "
"returned by B<gethostname>(2).  Must not be less than "
"B<_POSIX_HOST_NAME_MAX> (255)."
msgstr ""

#. type: TP
#: man-pages/man3/sysconf.3:150
#, no-wrap
msgid "B<LOGIN_NAME_MAX> - B<_SC_LOGIN_NAME_MAX>"
msgstr "B<LOGIN_NAME_MAX> - B<_SC_LOGIN_NAME_MAX>"

#. type: Plain text
#: man-pages/man3/sysconf.3:156
msgid ""
"Maximum length of a login name, including the terminating null byte.  Must "
"not be less than B<_POSIX_LOGIN_NAME_MAX> (9)."
msgstr "Максимально допустимая длина имени пользователя (включая завершающий null-байт). Должна быть не меньше B<_POSIX_LOGIN_NAME_MAX> (9)."

#. type: TP
#: man-pages/man3/sysconf.3:156
#, no-wrap
msgid "clock ticks - B<_SC_CLK_TCK>"
msgstr "такты часов - B<_SC_CLK_TCK>"

#. type: Plain text
#: man-pages/man3/sysconf.3:165
msgid ""
"The number of clock ticks per second.  The corresponding variable is "
"obsolete.  It was of course called B<CLK_TCK>.  (Note: the macro "
"B<CLOCKS_PER_SEC> does not give information: it must equal 1000000.)"
msgstr "Число тактов часов в секунду. Данная переменная устарела. Также она называлась B<CLK_TCK> (Примечание: макрос B<CLOCKS_PER_SEC> не дает необходимую информацию, он должен быть равен 1000000)."

#. type: TP
#: man-pages/man3/sysconf.3:165
#, no-wrap
msgid "B<OPEN_MAX> - B<_SC_OPEN_MAX>"
msgstr "B<OPEN_MAX> - B<_SC_OPEN_MAX>"

#. type: Plain text
#: man-pages/man3/sysconf.3:171
msgid ""
"The maximum number of files that a process can have open at any time.  Must "
"not be less than B<_POSIX_OPEN_MAX> (20)."
msgstr "Максимально допустимое число файлов, которое одновременно может открыть процесс. Должно быть не меньше B<_POSIX_OPEN_MAX> (20)."

#. type: TP
#: man-pages/man3/sysconf.3:171
#, no-wrap
msgid "B<PAGESIZE> - B<_SC_PAGESIZE>"
msgstr "B<PAGESIZE> - B<_SC_PAGESIZE>"

#. type: Plain text
#: man-pages/man3/sysconf.3:176
msgid ""
"Size of a page in bytes.  Must not be less than 1.  (Some systems use "
"PAGE_SIZE instead.)"
msgstr "Размер страницы в байтах. Должен быть не меньше 1 (в некоторых системах вместо этого используется PAGE_SIZE)."

#. type: TP
#: man-pages/man3/sysconf.3:176 man-pages/man3/sysconf.3:263
#, no-wrap
msgid "B<RE_DUP_MAX> - B<_SC_RE_DUP_MAX>"
msgstr "B<RE_DUP_MAX> - B<_SC_RE_DUP_MAX>"

#. type: Plain text
#: man-pages/man3/sysconf.3:185
msgid ""
"The number of repeated occurrences of a BRE permitted by B<regexec>(3)  and "
"B<regcomp>(3).  Must not be less than B<_POSIX2_RE_DUP_MAX> (255)."
msgstr "Число повторяемых совпадений BRE (Basic Regular Expression), разрешенных B<regexec>(3) и B<regcomp>(3). Должно быть не меньше B<_POSIX2_RE_DUP_MAX> (255)."

#. type: TP
#: man-pages/man3/sysconf.3:185
#, no-wrap
msgid "B<STREAM_MAX> - B<_SC_STREAM_MAX>"
msgstr "B<STREAM_MAX> - B<_SC_STREAM_MAX>"

#. type: Plain text
#: man-pages/man3/sysconf.3:194
msgid ""
"The maximum number of streams that a process can have open at any time.  If "
"defined, it has the same value as the standard C macro B<FOPEN_MAX>.  Must "
"not be less than B<_POSIX_STREAM_MAX> (8)."
msgstr "Максимально допустимое число потоков, которое может одновременно открывать процесс. Если определено, то оно имеет то же значение, что и стандартный макрос C B<FOPEN_MAX>. Должно быть не меньше B<_POSIX_STREAM_MAX> (8)."

#. type: TP
#: man-pages/man3/sysconf.3:194
#, no-wrap
msgid "B<SYMLOOP_MAX> - B<_SC_SYMLOOP_MAX>"
msgstr ""

#. type: Plain text
#: man-pages/man3/sysconf.3:202
msgid ""
"The maximum number of symbolic links seen in a pathname before resolution "
"returns B<ELOOP>.  Must not be less than B<_POSIX_SYMLOOP_MAX> (8)."
msgstr "Максимальное количество символических ссылок, допустимое при разрешении имени пути до того, как не будет возвращена ошибка B<ELOOP>. Должно быть не меньше B<_POSIX_SYMLOOP_MAX> (8)."

#. type: TP
#: man-pages/man3/sysconf.3:202
#, no-wrap
msgid "B<TTY_NAME_MAX> - B<_SC_TTY_NAME_MAX>"
msgstr ""

#. type: Plain text
#: man-pages/man3/sysconf.3:209
msgid ""
"The maximum length of terminal device name, including the terminating null "
"byte.  Must not be less than B<_POSIX_TTY_NAME_MAX> (9)."
msgstr ""

#. type: TP
#: man-pages/man3/sysconf.3:209
#, no-wrap
msgid "B<TZNAME_MAX> - B<_SC_TZNAME_MAX>"
msgstr ""

#. type: Plain text
#: man-pages/man3/sysconf.3:215
msgid ""
"The maximum number of bytes in a timezone name.  Must not be less than "
"B<_POSIX_TZNAME_MAX> (6)."
msgstr ""

#. type: TP
#: man-pages/man3/sysconf.3:215
#, no-wrap
msgid "B<_POSIX_VERSION> - B<_SC_VERSION>"
msgstr ""

#. type: Plain text
#: man-pages/man3/sysconf.3:223
msgid ""
"indicates the year and month the POSIX.1 standard was approved in the format"
" B<YYYYMML>; the value B<199009L> indicates the Sept. 1990 revision."
msgstr ""

#. type: SS
#: man-pages/man3/sysconf.3:223
#, no-wrap
msgid "POSIX.2 variables"
msgstr ""

#. type: Plain text
#: man-pages/man3/sysconf.3:225
msgid "Next, the POSIX.2 values, giving limits for utilities."
msgstr ""

#. type: TP
#: man-pages/man3/sysconf.3:225
#, no-wrap
msgid "B<BC_BASE_MAX> - B<_SC_BC_BASE_MAX>"
msgstr ""

#. type: Plain text
#: man-pages/man3/sysconf.3:232
msgid ""
"indicates the maximum I<obase> value accepted by the B<bc>(1)  utility."
msgstr ""

#. type: TP
#: man-pages/man3/sysconf.3:232
#, no-wrap
msgid "B<BC_DIM_MAX> - B<_SC_BC_DIM_MAX>"
msgstr ""

#. type: Plain text
#: man-pages/man3/sysconf.3:236
msgid ""
"indicates the maximum value of elements permitted in an array by B<bc>(1)."
msgstr ""

#. type: TP
#: man-pages/man3/sysconf.3:236
#, no-wrap
msgid "B<BC_SCALE_MAX> - B<_SC_BC_SCALE_MAX>"
msgstr ""

#. type: Plain text
#: man-pages/man3/sysconf.3:242
msgid "indicates the maximum I<scale> value allowed by B<bc>(1)."
msgstr ""

#. type: TP
#: man-pages/man3/sysconf.3:242
#, no-wrap
msgid "B<BC_STRING_MAX> - B<_SC_BC_STRING_MAX>"
msgstr "B<BC_STRING_MAX> - B<_SC_BC_STRING_MAX>"

#. type: Plain text
#: man-pages/man3/sysconf.3:246
msgid "indicates the maximum length of a string accepted by B<bc>(1)."
msgstr "отображает максимальную длину строки, которую может принимать B<bc>(1)."

#. type: TP
#: man-pages/man3/sysconf.3:246
#, no-wrap
msgid "B<COLL_WEIGHTS_MAX> - B<_SC_COLL_WEIGHTS_MAX>"
msgstr "B<COLL_WEIGHTS_MAX> - B<_SC_COLL_WEIGHTS_MAX>"

#. type: Plain text
#: man-pages/man3/sysconf.3:252
msgid ""
"indicates the maximum numbers of weights that can be assigned to an entry of"
" the B<LC_COLLATE order> keyword in the locale definition file,"
msgstr ""

#. type: TP
#: man-pages/man3/sysconf.3:252
#, no-wrap
msgid "B<EXPR_NEST_MAX> - B<_SC_EXPR_NEST_MAX>"
msgstr "B<EXPR_NEST_MAX> - B<_SC_EXPR_NEST_MAX>"

#. type: Plain text
#: man-pages/man3/sysconf.3:257
msgid ""
"is the maximum number of expressions which can be nested within parentheses "
"by B<expr>(1)."
msgstr ""

#. type: TP
#: man-pages/man3/sysconf.3:257
#, no-wrap
msgid "B<LINE_MAX> - B<_SC_LINE_MAX>"
msgstr "B<LINE_MAX> - B<_SC_LINE_MAX>"

#. type: Plain text
#: man-pages/man3/sysconf.3:263
msgid ""
"The maximum length of a utility's input line, either from standard input or "
"from a file.  This includes space for a trailing newline."
msgstr ""

#. type: Plain text
#: man-pages/man3/sysconf.3:269
msgid ""
"The maximum number of repeated occurrences of a regular expression when the "
"interval notation B<\\e{m,n\\e}> is used."
msgstr "Максимальное количество повторяемых совпадений регулярного выражения при указании интервала в нотации B<\\e{m,n\\e}>"

#. type: TP
#: man-pages/man3/sysconf.3:269
#, no-wrap
msgid "B<POSIX2_VERSION> - B<_SC_2_VERSION>"
msgstr "B<POSIX2_VERSION> - B<_SC_2_VERSION>"

#. type: Plain text
#: man-pages/man3/sysconf.3:273
msgid ""
"indicates the version of the POSIX.2 standard in the format of YYYYMML."
msgstr "отображает версию стандарта POSIX.2 в формате YYYYMML."

#. type: TP
#: man-pages/man3/sysconf.3:273
#, no-wrap
msgid "B<POSIX2_C_DEV> - B<_SC_2_C_DEV>"
msgstr "B<POSIX2_C_DEV> - B<_SC_2_C_DEV>"

#. type: Plain text
#: man-pages/man3/sysconf.3:277
msgid ""
"indicates whether the POSIX.2 C language development facilities are "
"supported."
msgstr ""

#. type: TP
#: man-pages/man3/sysconf.3:277
#, no-wrap
msgid "B<POSIX2_FORT_DEV> - B<_SC_2_FORT_DEV>"
msgstr "B<POSIX2_FORT_DEV> - B<_SC_2_FORT_DEV>"

#. type: Plain text
#: man-pages/man3/sysconf.3:281
msgid ""
"indicates whether the POSIX.2 FORTRAN development utilities are supported."
msgstr ""

#. type: TP
#: man-pages/man3/sysconf.3:281
#, no-wrap
msgid "B<POSIX2_FORT_RUN> - B<_SC_2_FORT_RUN>"
msgstr "B<POSIX2_FORT_RUN> - B<_SC_2_FORT_RUN>"

#. type: Plain text
#: man-pages/man3/sysconf.3:284
msgid ""
"indicates whether the POSIX.2 FORTRAN run-time utilities are supported."
msgstr ""

#. type: TP
#: man-pages/man3/sysconf.3:284
#, no-wrap
msgid "B<_POSIX2_LOCALEDEF> - B<_SC_2_LOCALEDEF>"
msgstr "B<_POSIX2_LOCALEDEF> - B<_SC_2_LOCALEDEF>"

#. type: Plain text
#: man-pages/man3/sysconf.3:289
msgid ""
"indicates whether the POSIX.2 creation of locates via B<localedef>(1)  is "
"supported."
msgstr ""

#. type: TP
#: man-pages/man3/sysconf.3:289
#, no-wrap
msgid "B<POSIX2_SW_DEV> - B<_SC_2_SW_DEV>"
msgstr "B<POSIX2_SW_DEV> - B<_SC_2_SW_DEV>"

#. type: Plain text
#: man-pages/man3/sysconf.3:293
msgid ""
"indicates whether the POSIX.2 software development utilities option is "
"supported."
msgstr "отображает, поддерживаются ли утилитами разработки ПО параметры POSIX.2."

#. type: Plain text
#: man-pages/man3/sysconf.3:295
msgid "These values also exist, but may not be standard."
msgstr "Также могут существовать следующие значения, однако они могут быть нестандартизированы."

#. type: TP
#: man-pages/man3/sysconf.3:295
#, no-wrap
msgid " - B<_SC_PHYS_PAGES>"
msgstr " - B<_SC_PHYS_PAGES>"

#. type: Plain text
#: man-pages/man3/sysconf.3:302
msgid ""
"The number of pages of physical memory.  Note that it is possible for the "
"product of this value and the value of B<_SC_PAGESIZE> to overflow."
msgstr ""

#. type: TP
#: man-pages/man3/sysconf.3:302
#, no-wrap
msgid " - B<_SC_AVPHYS_PAGES>"
msgstr " - B<_SC_AVPHYS_PAGES>"

#. type: Plain text
#: man-pages/man3/sysconf.3:305
msgid "The number of currently available pages of physical memory."
msgstr "Число доступных в данный момент страниц физической памяти."

#. type: TP
#: man-pages/man3/sysconf.3:305
#, no-wrap
msgid " - B<_SC_NPROCESSORS_CONF>"
msgstr " - B<_SC_NPROCESSORS_CONF>"

#. type: Plain text
#: man-pages/man3/sysconf.3:308
msgid "The number of processors configured."
msgstr "Число настроенных процессоров."

#. type: TP
#: man-pages/man3/sysconf.3:308
#, no-wrap
msgid " - B<_SC_NPROCESSORS_ONLN>"
msgstr " - B<_SC_NPROCESSORS_ONLN>"

#. type: Plain text
#: man-pages/man3/sysconf.3:311
msgid "The number of processors currently online (available)."
msgstr "Число процессоров онлайн (доступных)."

#. type: Plain text
#: man-pages/man3/sysconf.3:324
msgid ""
"If I<name> is invalid, -1 is returned, and I<errno> is set to B<EINVAL>.  "
"Otherwise, the value returned is the value of the system resource and "
"I<errno> is not changed.  In the case of options, a positive value is "
"returned if a queried option is available, and -1 if it is not.  In the case"
" of limits, -1 means that there is no definite limit."
msgstr ""

#. type: Plain text
#: man-pages/man3/sysconf.3:332
msgid ""
"It is difficult to use B<ARG_MAX> because it is not specified how much of "
"the argument space for B<exec>(3)  is consumed by the user's environment "
"variables."
msgstr ""

#. type: Plain text
#: man-pages/man3/sysconf.3:335
msgid ""
"Some returned values may be huge; they are not suitable for allocating "
"memory."
msgstr ""

#. type: Plain text
#: man-pages/man3/sysconf.3:343
msgid ""
"B<bc>(1), B<expr>(1), B<getconf>(1), B<locale>(1), B<confstr>(3), "
"B<fpathconf>(3), B<pathconf>(3), B<posixoptions>(7)"
msgstr "B<bc>(1), B<expr>(1), B<getconf>(1), B<locale>(1), B<confstr>(3), B<fpathconf>(3), B<pathconf>(3), B<posixoptions>(7)"

#. type: TH
#: man-pages/man3/strftime.3:37
#, no-wrap
msgid "STRFTIME"
msgstr ""

#. type: Plain text
#: man-pages/man3/strftime.3:40
msgid "strftime - format date and time"
msgstr ""

#. type: Plain text
#: man-pages/man3/strftime.3:43
#, no-wrap
msgid "B<#include E<lt>time.hE<gt>>\n"
msgstr "B<#include E<lt>time.hE<gt>>\n"

#. type: Plain text
#: man-pages/man3/strftime.3:46
#, no-wrap
msgid ""
"B<size_t strftime(char *>I<s>B<, size_t >I<max>B<, const char *>I<format>B<,>\n"
"B<                const struct tm *>I<tm>B<);>\n"
msgstr ""

#.  FIXME POSIX says: Local timezone information is used as though
#.  strftime() called tzset().  But this doesn't appear to be the case
#. type: Plain text
#: man-pages/man3/strftime.3:61
msgid ""
"The B<strftime>()  function formats the broken-down time I<tm> according to "
"the format specification I<format> and places the result in the character "
"array I<s> of size I<max>."
msgstr ""

#. type: Plain text
#: man-pages/man3/strftime.3:70
msgid ""
"The format specification is a null-terminated string and may contain special"
" character sequences called I<conversion specifications>, each of which is "
"introduced by a \\(aq%\\(aq character and terminated by some other character"
" known as a I<conversion specifier character>.  All other character "
"sequences are I<ordinary character sequences>."
msgstr ""

#. type: Plain text
#: man-pages/man3/strftime.3:78
msgid ""
"The characters of ordinary character sequences (including the null byte)  "
"are copied verbatim from I<format> to I<s>.  However, the characters of "
"conversion specifications are replaced as follows:"
msgstr ""

#. type: TP
#: man-pages/man3/strftime.3:78
#, no-wrap
msgid "B<%a>"
msgstr ""

#. type: Plain text
#: man-pages/man3/strftime.3:81
msgid ""
"The abbreviated name of the day of the week according to the current locale."
msgstr ""

#. type: TP
#: man-pages/man3/strftime.3:81
#, no-wrap
msgid "B<%A>"
msgstr ""

#. type: Plain text
#: man-pages/man3/strftime.3:84
msgid "The full name of the day of the week according to the current locale."
msgstr ""

#. type: TP
#: man-pages/man3/strftime.3:84
#, no-wrap
msgid "B<%b>"
msgstr ""

#. type: Plain text
#: man-pages/man3/strftime.3:87
msgid "The abbreviated month name according to the current locale."
msgstr ""

#. type: TP
#: man-pages/man3/strftime.3:87
#, no-wrap
msgid "B<%B>"
msgstr ""

#. type: Plain text
#: man-pages/man3/strftime.3:90
msgid "The full month name according to the current locale."
msgstr ""

#. type: Plain text
#: man-pages/man3/strftime.3:93
msgid "The preferred date and time representation for the current locale."
msgstr ""

#. type: Plain text
#: man-pages/man3/strftime.3:96
msgid "The century number (year/100) as a 2-digit integer. (SU)"
msgstr ""

#. type: TP
#: man-pages/man3/strftime.3:96
#, no-wrap
msgid "B<%d>"
msgstr ""

#. type: Plain text
#: man-pages/man3/strftime.3:99
msgid "The day of the month as a decimal number (range 01 to 31)."
msgstr ""

#. type: Plain text
#: man-pages/man3/strftime.3:109
msgid ""
"Equivalent to B<%m/%d/%y>.  (Yecch\\(emfor Americans only.  Americans should"
" note that in other countries B<%d/%m/%y> is rather common.  This means that"
" in international context this format is ambiguous and should not be used.) "
"(SU)"
msgstr ""

#. type: TP
#: man-pages/man3/strftime.3:109
#, no-wrap
msgid "B<%e>"
msgstr "B<%e>"

#. type: Plain text
#: man-pages/man3/strftime.3:115
msgid ""
"Like B<%d>, the day of the month as a decimal number, but a leading zero is "
"replaced by a space. (SU)"
msgstr ""

#. type: TP
#: man-pages/man3/strftime.3:115
#, no-wrap
msgid "B<%E>"
msgstr "B<%E>"

#. type: Plain text
#: man-pages/man3/strftime.3:118 man-pages/man3/strftime.3:177
msgid "Modifier: use alternative format, see below. (SU)"
msgstr ""

#. type: Plain text
#: man-pages/man3/strftime.3:123
msgid "Equivalent to B<%Y-%m-%d> (the ISO\\ 8601 date format). (C99)"
msgstr ""

#. type: Plain text
#: man-pages/man3/strftime.3:132
msgid ""
"The ISO\\ 8601 week-based year (see NOTES) with century as a decimal number."
"  The 4-digit year corresponding to the ISO week number (see B<%V>).  This "
"has the same format and value as B<%Y>, except that if the ISO week number "
"belongs to the previous or next year, that year is used instead. (TZ)"
msgstr ""

#. type: Plain text
#: man-pages/man3/strftime.3:137
msgid ""
"Like B<%G>, but without century, that is, with a 2-digit year (00-99). (TZ)"
msgstr ""

#. type: TP
#: man-pages/man3/strftime.3:137
#, no-wrap
msgid "B<%h>"
msgstr ""

#. type: Plain text
#: man-pages/man3/strftime.3:142
msgid "Equivalent to B<%b>.  (SU)"
msgstr ""

#. type: Plain text
#: man-pages/man3/strftime.3:145
msgid "The hour as a decimal number using a 24-hour clock (range 00 to 23)."
msgstr ""

#. type: Plain text
#: man-pages/man3/strftime.3:148
msgid "The hour as a decimal number using a 12-hour clock (range 01 to 12)."
msgstr ""

#. type: Plain text
#: man-pages/man3/strftime.3:151
msgid "The day of the year as a decimal number (range 001 to 366)."
msgstr ""

#. type: TP
#: man-pages/man3/strftime.3:151
#, no-wrap
msgid "B<%k>"
msgstr "B<%k>"

#. type: Plain text
#: man-pages/man3/strftime.3:158
msgid ""
"The hour (24-hour clock) as a decimal number (range 0 to 23); single digits "
"are preceded by a blank.  (See also B<%H>.)  (TZ)"
msgstr ""

#. type: TP
#: man-pages/man3/strftime.3:158
#, no-wrap
msgid "B<%l>"
msgstr ""

#. type: Plain text
#: man-pages/man3/strftime.3:165
msgid ""
"The hour (12-hour clock) as a decimal number (range 1 to 12); single digits "
"are preceded by a blank.  (See also B<%I>.)  (TZ)"
msgstr ""

#. type: Plain text
#: man-pages/man3/strftime.3:168
msgid "The month as a decimal number (range 01 to 12)."
msgstr ""

#. type: Plain text
#: man-pages/man3/strftime.3:171
msgid "The minute as a decimal number (range 00 to 59)."
msgstr ""

#. type: Plain text
#: man-pages/man3/strftime.3:174
msgid "A newline character. (SU)"
msgstr ""

#. type: TP
#: man-pages/man3/strftime.3:174
#, no-wrap
msgid "B<%O>"
msgstr "B<%O>"

#. type: Plain text
#: man-pages/man3/strftime.3:182
msgid ""
"Either \"AM\" or \"PM\" according to the given time value, or the "
"corresponding strings for the current locale.  Noon is treated as \"PM\" and"
" midnight as \"AM\"."
msgstr ""

#. type: TP
#: man-pages/man3/strftime.3:182
#, no-wrap
msgid "B<%P>"
msgstr "B<%P>"

#. type: Plain text
#: man-pages/man3/strftime.3:188
msgid ""
"Like B<%p> but in lowercase: \"am\" or \"pm\" or a corresponding string for "
"the current locale. (GNU)"
msgstr ""

#. type: Plain text
#: man-pages/man3/strftime.3:194
msgid ""
"The time in a.m. or p.m. notation.  In the POSIX locale this is equivalent "
"to B<%I:%M:%S %p>.  (SU)"
msgstr ""

#. type: Plain text
#: man-pages/man3/strftime.3:202
msgid ""
"The time in 24-hour notation (B<%H:%M>).  (SU)  For a version including the "
"seconds, see B<%T> below."
msgstr ""

#. type: Plain text
#: man-pages/man3/strftime.3:205
msgid ""
"The number of seconds since the Epoch, 1970-01-01 00:00:00 +0000 (UTC). (TZ)"
msgstr ""

#. type: Plain text
#: man-pages/man3/strftime.3:209
msgid ""
"The second as a decimal number (range 00 to 60).  (The range is up to 60 to "
"allow for occasional leap seconds.)"
msgstr ""

#. type: Plain text
#: man-pages/man3/strftime.3:212
msgid "A tab character. (SU)"
msgstr ""

#. type: Plain text
#: man-pages/man3/strftime.3:217
msgid "The time in 24-hour notation (B<%H:%M:%S>).  (SU)"
msgstr ""

#. type: Plain text
#: man-pages/man3/strftime.3:223
msgid ""
"The day of the week as a decimal, range 1 to 7, Monday being 1.  See also "
"B<%w>.  (SU)"
msgstr ""

#. type: Plain text
#: man-pages/man3/strftime.3:232
msgid ""
"The week number of the current year as a decimal number, range 00 to 53, "
"starting with the first Sunday as the first day of week 01.  See also B<%V> "
"and B<%W>."
msgstr ""

#. type: Plain text
#: man-pages/man3/strftime.3:242
msgid ""
"The ISO\\ 8601 week number (see NOTES) of the current year as a decimal "
"number, range 01 to 53, where week 1 is the first week that has at least 4 "
"days in the new year.  See also B<%U> and B<%W>.  (SU)"
msgstr ""

#. type: Plain text
#: man-pages/man3/strftime.3:247
msgid ""
"The day of the week as a decimal, range 0 to 6, Sunday being 0.  See also "
"B<%u>."
msgstr ""

#. type: Plain text
#: man-pages/man3/strftime.3:251
msgid ""
"The week number of the current year as a decimal number, range 00 to 53, "
"starting with the first Monday as the first day of week 01."
msgstr ""

#. type: Plain text
#: man-pages/man3/strftime.3:254
msgid ""
"The preferred date representation for the current locale without the time."
msgstr ""

#. type: Plain text
#: man-pages/man3/strftime.3:257
msgid ""
"The preferred time representation for the current locale without the date."
msgstr ""

#. type: Plain text
#: man-pages/man3/strftime.3:260
msgid "The year as a decimal number without a century (range 00 to 99)."
msgstr ""

#. type: Plain text
#: man-pages/man3/strftime.3:263
msgid "The year as a decimal number including the century."
msgstr ""

#. type: Plain text
#: man-pages/man3/strftime.3:270
msgid ""
"The I<+hhmm> or I<-hhmm> numeric timezone (that is, the hour and minute "
"offset from UTC). (SU)"
msgstr ""

#. type: Plain text
#: man-pages/man3/strftime.3:273
msgid "The timezone name or abbreviation."
msgstr ""

#. type: TP
#: man-pages/man3/strftime.3:273
#, no-wrap
msgid "B<%+>"
msgstr ""

#.  Nov 05 -- Not in Linux/glibc, but is in some BSDs (according to
#.  their man pages)
#. type: Plain text
#: man-pages/man3/strftime.3:281
msgid ""
"The date and time in B<date>(1)  format. (TZ)  (Not supported in glibc2.)"
msgstr ""

#. type: Plain text
#: man-pages/man3/strftime.3:284
msgid "A literal \\(aq%\\(aq character."
msgstr ""

#. type: Plain text
#: man-pages/man3/strftime.3:320
msgid ""
"Some conversion specifications can be modified by preceding the conversion "
"specifier character by the B<E> or B<O> I<modifier> to indicate that an "
"alternative format should be used.  If the alternative format or "
"specification does not exist for the current locale, the behavior will be as"
" if the unmodified conversion specification were used. (SU)  The Single UNIX"
" Specification mentions B<%Ec>, B<%EC>, B<%Ex>, B<%EX>, B<%Ey>, B<%EY>, "
"B<%Od>, B<%Oe>, B<%OH>, B<%OI>, B<%Om>, B<%OM>, B<%OS>, B<%Ou>, B<%OU>, "
"B<%OV>, B<%Ow>, B<%OW>, B<%Oy>, where the effect of the B<O> modifier is to "
"use alternative numeric symbols (say, roman numerals), and that of the E "
"modifier is to use a locale-dependent alternative representation."
msgstr ""

#. type: Plain text
#: man-pages/man3/strftime.3:327
msgid ""
"The broken-down time structure I<tm> is defined in I<E<lt>time.hE<gt>>.  See"
" also B<ctime>(3)."
msgstr ""

#. type: Plain text
#: man-pages/man3/strftime.3:347
msgid ""
"Provided that the result string, including the terminating null byte, does "
"not exceed I<max> bytes, B<strftime>()  returns the number of bytes "
"(excluding the terminating null byte)  placed in the array I<s>.  If the "
"length of the result string (including the terminating null byte)  would "
"exceed I<max> bytes, then B<strftime>()  returns 0, and the contents of the "
"array are undefined.  (This behavior applies since at least libc 4.4.4; very"
" old versions of libc, such as libc 4.4.1, would return I<max> if the array "
"was too small.)"
msgstr ""

#. type: Plain text
#: man-pages/man3/strftime.3:355
msgid ""
"Note that the return value 0 does not necessarily indicate an error.  For "
"example, in many locales B<%p> yields an empty string.  An empty I<format> "
"string will likewise yield an empty string."
msgstr ""

#. type: SH
#: man-pages/man3/strftime.3:355
#, no-wrap
msgid "ENVIRONMENT"
msgstr "ОКРУЖЕНИЕ"

#. type: Plain text
#: man-pages/man3/strftime.3:361
msgid "The environment variables B<TZ> and B<LC_TIME> are used."
msgstr ""

#. type: Plain text
#: man-pages/man3/strftime.3:378
msgid ""
"SVr4, C89, C99.  There are strict inclusions between the set of conversions "
"given in ANSI C (unmarked), those given in the Single UNIX Specification "
"(marked SU), those given in Olson's timezone package (marked TZ), and those "
"given in glibc (marked GNU), except that B<%+> is not supported in glibc2.  "
"On the other hand glibc2 has several more extensions.  POSIX.1 only refers "
"to ANSI C; POSIX.2 describes under B<date>(1)  several extensions that could"
" apply to B<strftime>()  as well.  The B<%F> conversion is in C99 and "
"POSIX.1-2001."
msgstr ""

#. type: Plain text
#: man-pages/man3/strftime.3:385
msgid ""
"In SUSv2, the B<%S> specifier allowed a range of 00 to 61, to allow for the "
"theoretical possibility of a minute that included a double leap second "
"(there never has been such a minute)."
msgstr ""

#. type: SS
#: man-pages/man3/strftime.3:386
#, no-wrap
msgid "ISO 8601 week dates"
msgstr ""

#. type: Plain text
#: man-pages/man3/strftime.3:411
msgid ""
"B<%G>, B<%g>, and B<%V> yield values calculated from the week-based year "
"defined by the ISO\\ 8601 standard.  In this system, weeks start on a "
"Monday, and are numbered from 01, for the first week, up to 52 or 53, for "
"the last week.  Week 1 is the first week where four or more days fall within"
" the new year (or, synonymously, week 01 is: the first week of the year that"
" contains a Thursday; or, the week that has 4 January in it).  When three of"
" fewer days of the first calendar week of the new year fall within that "
"year, then the ISO 8601 week-based system counts those days as part of week "
"53 of the preceding year.  For example, 1 January 2010 is a Friday, meaning "
"that just three days of that calendar week fall in 2010.  Thus, the ISO\\ "
"8601 week-based system considers these days to be part of week 53 (B<%V>)  "
"of the year 2009 (B<%G>); week 01 of ISO\\ 8601 year 2010 starts on Monday, "
"4 January 2010."
msgstr ""

#.  HP-UX and Tru64 also have features like this.
#. type: Plain text
#: man-pages/man3/strftime.3:427
msgid ""
"Glibc provides some extensions for conversion specifications.  (These "
"extensions are not specified in POSIX.1-2001, but a few other systems "
"provide similar features.)  Between the \\(aq%\\(aq character and the "
"conversion specifier character, an optional I<flag> and field I<width> may "
"be specified.  (These precede the B<E> or B<O> modifiers, if present.)"
msgstr ""

#. type: Plain text
#: man-pages/man3/strftime.3:429
msgid "The following flag characters are permitted:"
msgstr ""

#. type: TP
#: man-pages/man3/strftime.3:429
#, no-wrap
msgid "B<_>"
msgstr ""

#. type: Plain text
#: man-pages/man3/strftime.3:433
msgid "(underscore)  Pad a numeric result string with spaces."
msgstr ""

#. type: Plain text
#: man-pages/man3/strftime.3:437
msgid "(dash)  Do not pad a numeric result string."
msgstr ""

#. type: Plain text
#: man-pages/man3/strftime.3:441
msgid ""
"Pad a numeric result string with zeros even if the conversion specifier "
"character uses space-padding by default."
msgstr ""

#. type: Plain text
#: man-pages/man3/strftime.3:444
msgid "Convert alphabetic characters in result string to uppercase."
msgstr ""

#. type: TP
#: man-pages/man3/strftime.3:444
#, no-wrap
msgid "B<#>"
msgstr "B<#>"

#. type: Plain text
#: man-pages/man3/strftime.3:450
msgid ""
"Swap the case of the result string.  (This flag works only with certain "
"conversion specifier characters, and of these, it is only really useful with"
" B<%Z>.)"
msgstr ""

#. type: Plain text
#: man-pages/man3/strftime.3:454
msgid ""
"An optional decimal width specifier may follow the (possibly absent) flag.  "
"If the natural size of the field is smaller than this width, then the result"
" string is padded (on the left) to the specified width."
msgstr ""

#. type: Plain text
#: man-pages/man3/strftime.3:472
msgid ""
"If the output string would exceed I<max> bytes, I<errno> is I<not> set.  "
"This makes it impossible to distinguish this error case from cases where the"
" I<format> string legitimately produces a zero-length output string.  "
"POSIX.1-2001 does I<not> specify any I<errno> settings for B<strftime>()."
msgstr ""

#. type: Plain text
#: man-pages/man3/strftime.3:487
msgid ""
"Some buggy versions of B<gcc>(1)  complain about the use of B<%c>: "
"I<warning: `%c' yields only last 2 digits of year in some locales>.  Of "
"course programmers are encouraged to use B<%c>, it gives the preferred date "
"and time representation.  One meets all kinds of strange obfuscations to "
"circumvent this B<gcc>(1)  problem.  A relatively clean one is to add an "
"intermediate function"
msgstr ""

#. type: Plain text
#: man-pages/man3/strftime.3:496
#, no-wrap
msgid ""
"size_t\n"
"my_strftime(char *s, size_t max, const char *fmt,\n"
"            const struct tm *tm)\n"
"{\n"
"    return strftime(s, max, fmt, tm);\n"
"}\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/strftime.3:505
msgid ""
"Nowadays, B<gcc>(1)  provides the I<-Wno-format-y2k> option to prevent the "
"warning, so that the above workaround is no longer required."
msgstr ""

#. type: Plain text
#: man-pages/man3/strftime.3:508
msgid ""
"B<RFC\\ 2822-compliant date format> (with an English locale for %a and %b)"
msgstr ""

#. type: Plain text
#: man-pages/man3/strftime.3:511
msgid "%a,\\ %d\\ %b\\ %Y\\ %T\\ %z"
msgstr ""

#. type: Plain text
#: man-pages/man3/strftime.3:514
msgid ""
"B<RFC\\ 822-compliant date format> (with an English locale for %a and %b)"
msgstr ""

#. type: Plain text
#: man-pages/man3/strftime.3:517
msgid "%a,\\ %d\\ %b\\ %y\\ %T\\ %z"
msgstr ""

#. type: SS
#: man-pages/man3/strftime.3:517
#, no-wrap
msgid "Example program"
msgstr ""

#. type: Plain text
#: man-pages/man3/strftime.3:520
msgid "The program below can be used to experiment with B<strftime>()."
msgstr ""

#. type: Plain text
#: man-pages/man3/strftime.3:524
msgid ""
"Some examples of the result string produced by the glibc implementation of "
"B<strftime>()  are as follows:"
msgstr ""

#. type: Plain text
#: man-pages/man3/strftime.3:533
#, no-wrap
msgid ""
"$B< ./a.out \\(aq%m\\(aq>\n"
"Result string is \"11\"\n"
"$B< ./a.out \\(aq%5m\\(aq>\n"
"Result string is \"00011\"\n"
"$B< ./a.out \\(aq%_5m\\(aq>\n"
"Result string is \"   11\"\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/strftime.3:540
#, no-wrap
msgid ""
"#include E<lt>time.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
msgstr "#include E<lt>time.hE<gt>\n#include E<lt>stdio.hE<gt>\n#include E<lt>stdlib.hE<gt>\n"

#. type: Plain text
#: man-pages/man3/strftime.3:547
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    char outstr[200];\n"
"    time_t t;\n"
"    struct tm *tmp;\n"
msgstr "int\nmain(int argc, char *argv[])\n{\n    char outstr[200];\n    time_t t;\n    struct tm *tmp;\n"

#. type: Plain text
#: man-pages/man3/strftime.3:554
#, no-wrap
msgid ""
"    t = time(NULL);\n"
"    tmp = localtime(&t);\n"
"    if (tmp == NULL) {\n"
"        perror(\"localtime\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr "    t = time(NULL);\n    tmp = localtime(&t);\n    if (tmp == NULL) {\n        perror(\"localtime\");\n        exit(EXIT_FAILURE);\n    }\n"

#. type: Plain text
#: man-pages/man3/strftime.3:559
#, no-wrap
msgid ""
"    if (strftime(outstr, sizeof(outstr), argv[1], tmp) == 0) {\n"
"        fprintf(stderr, \"strftime returned 0\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr "    if (strftime(outstr, sizeof(outstr), argv[1], tmp) == 0) {\n        fprintf(stderr, \"strftime returned 0\");\n        exit(EXIT_FAILURE);\n    }\n"

#. type: Plain text
#: man-pages/man3/strftime.3:563
#, no-wrap
msgid ""
"    printf(\"Result string is \\e\"%s\\e\"\\en\", outstr);\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr "    printf(\"Result string is \\e\"%s\\e\"\\en\", outstr);\n    exit(EXIT_SUCCESS);\n}\n"

#. type: Plain text
#: man-pages/man3/strftime.3:570
msgid ""
"B<date>(1), B<time>(2), B<ctime>(3), B<setlocale>(3), B<sprintf>(3), "
"B<strptime>(3)"
msgstr "B<date>(1), B<time>(2), B<ctime>(3), B<setlocale>(3), B<sprintf>(3), B<strptime>(3)"

#. type: TH
#: man-pages/man3/sem_wait.3:26
#, no-wrap
msgid "SEM_WAIT"
msgstr ""

#. type: Plain text
#: man-pages/man3/sem_wait.3:29
msgid "sem_wait, sem_timedwait, sem_trywait - lock a semaphore"
msgstr ""

#. type: Plain text
#: man-pages/man3/sem_wait.3:34
#, no-wrap
msgid "B<int sem_wait(sem_t *>I<sem>B<);>\n"
msgstr "B<int sem_wait(sem_t *>I<sem>B<);>\n"

#. type: Plain text
#: man-pages/man3/sem_wait.3:36
#, no-wrap
msgid "B<int sem_trywait(sem_t *>I<sem>B<);>\n"
msgstr "B<int sem_trywait(sem_t *>I<sem>B<);>\n"

#. type: Plain text
#: man-pages/man3/sem_wait.3:38
#, no-wrap
msgid ""
"B<int sem_timedwait(sem_t *>I<sem>B<, const struct timespec "
"*>I<abs_timeout>B<);>\n"
msgstr "B<int sem_timedwait(sem_t *>I<sem>B<, const struct timespec *>I<abs_timeout>B<);>\n"

#. type: Plain text
#: man-pages/man3/sem_wait.3:49
msgid ""
"B<sem_timedwait>(): _POSIX_C_SOURCE\\ E<gt>=\\ 200112L || _XOPEN_SOURCE\\ "
"E<gt>=\\ 600"
msgstr "B<sem_timedwait>(): _POSIX_C_SOURCE\\ E<gt>=\\ 200112L || _XOPEN_SOURCE\\ E<gt>=\\ 600"

#. type: Plain text
#: man-pages/man3/sem_wait.3:59
msgid ""
"B<sem_wait>()  decrements (locks) the semaphore pointed to by I<sem>.  If "
"the semaphore's value is greater than zero, then the decrement proceeds, and"
" the function returns, immediately.  If the semaphore currently has the "
"value zero, then the call blocks until either it becomes possible to perform"
" the decrement (i.e., the semaphore value rises above zero), or a signal "
"handler interrupts the call."
msgstr ""

#. type: Plain text
#: man-pages/man3/sem_wait.3:69
msgid ""
"B<sem_trywait>()  is the same as B<sem_wait>(), except that if the decrement"
" cannot be immediately performed, then call returns an error (I<errno> set "
"to B<EAGAIN>)  instead of blocking."
msgstr ""

#. type: Plain text
#: man-pages/man3/sem_wait.3:82
msgid ""
"B<sem_timedwait>()  is the same as B<sem_wait>(), except that I<abs_timeout>"
" specifies a limit on the amount of time that the call should block if the "
"decrement cannot be immediately performed.  The I<abs_timeout> argument "
"points to a structure that specifies an absolute timeout in seconds and "
"nanoseconds since the Epoch, 1970-01-01 00:00:00 +0000 (UTC).  This "
"structure is defined as follows:"
msgstr ""

#. type: Plain text
#: man-pages/man3/sem_wait.3:89
#, no-wrap
msgid ""
"struct timespec {\n"
"    time_t tv_sec;      /* Seconds */\n"
"    long   tv_nsec;     /* Nanoseconds [0 .. 999999999] */\n"
"};\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/sem_wait.3:100
msgid ""
"If the timeout has already expired by the time of the call, and the "
"semaphore could not be locked immediately, then B<sem_timedwait>()  fails "
"with a timeout error (I<errno> set to B<ETIMEDOUT>)."
msgstr ""

#. type: Plain text
#: man-pages/man3/sem_wait.3:108
msgid ""
"If the operation can be performed immediately, then B<sem_timedwait>()  "
"never fails with a timeout error, regardless of the value of I<abs_timeout>."
"  Furthermore, the validity of I<abs_timeout> is not checked in this case."
msgstr ""

#. type: Plain text
#: man-pages/man3/sem_wait.3:114
msgid ""
"All of these functions return 0 on success; on error, the value of the "
"semaphore is left unchanged, -1 is returned, and I<errno> is set to indicate"
" the error."
msgstr ""

#. type: Plain text
#: man-pages/man3/sem_wait.3:119
msgid "The call was interrupted by a signal handler; see B<signal>(7)."
msgstr ""

#. type: Plain text
#: man-pages/man3/sem_wait.3:126
msgid "The following additional error can occur for B<sem_trywait>():"
msgstr ""

#. type: Plain text
#: man-pages/man3/sem_wait.3:130
msgid ""
"The operation could not be performed without blocking (i.e., the semaphore "
"currently has the value zero)."
msgstr ""

#. type: Plain text
#: man-pages/man3/sem_wait.3:133
msgid "The following additional errors can occur for B<sem_timedwait>():"
msgstr ""

#. type: Plain text
#: man-pages/man3/sem_wait.3:138
msgid ""
"The value of I<abs_timeout.tv_nsecs> is less than 0, or greater than or "
"equal to 1000 million."
msgstr ""

#. type: TP
#: man-pages/man3/sem_wait.3:138
#, no-wrap
msgid "B<ETIMEDOUT>"
msgstr "B<ETIMEDOUT>"

#.  POSIX.1-2001 also allows EDEADLK -- "A deadlock condition
#.  was detected", but this does not occur on Linux(?).
#. type: Plain text
#: man-pages/man3/sem_wait.3:143
msgid "The call timed out before the semaphore could be locked."
msgstr ""

#. type: Plain text
#: man-pages/man3/sem_wait.3:151
msgid ""
"The B<sem_wait>(), B<sem_trywait>(), and B<sem_timedwait>()  functions are "
"thread-safe."
msgstr ""

#.  sem_wait() is always interrupted on most other implementations,
#.  but on FreeBSD 5.4 SA_RESTART does cause restarting.
#. type: Plain text
#: man-pages/man3/sem_wait.3:161
msgid ""
"A signal handler always interrupts a blocked call to one of these functions,"
" regardless of the use of the B<sigaction>(2)  B<SA_RESTART> flag."
msgstr ""

#. type: Plain text
#: man-pages/man3/sem_wait.3:180
msgid ""
"The (somewhat trivial) program shown below operates on an unnamed semaphore."
"  The program expects two command-line arguments.  The first argument "
"specifies a seconds value that is used to set an alarm timer to generate a "
"B<SIGALRM> signal.  This handler performs a B<sem_post>(3)  to increment the"
" semaphore that is being waited on in I<main()> using B<sem_timedwait>().  "
"The second command-line argument specifies the length of the timeout, in "
"seconds, for B<sem_timedwait>().  The following shows what happens on two "
"different runs of the program:"
msgstr ""

#. type: Plain text
#: man-pages/man3/sem_wait.3:190
#, no-wrap
msgid ""
"$B< ./a.out 2 3>\n"
"About to call sem_timedwait()\n"
"sem_post() from handler\n"
"sem_timedwait() succeeded\n"
"$B< ./a.out 2 1>\n"
"About to call sem_timedwait()\n"
"sem_timedwait() timed out\n"
msgstr "$B< ./a.out 2 3>\nAbout to call sem_timedwait()\nsem_post() from handler\nsem_timedwait() succeeded\n$B< ./a.out 2 1>\nAbout to call sem_timedwait()\nsem_timedwait() timed out\n"

#. type: Plain text
#: man-pages/man3/sem_wait.3:203
#, no-wrap
msgid ""
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>semaphore.hE<gt>\n"
"#include E<lt>time.hE<gt>\n"
"#include E<lt>assert.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"
"#include E<lt>signal.hE<gt>\n"
msgstr "#include E<lt>unistd.hE<gt>\n#include E<lt>stdio.hE<gt>\n#include E<lt>stdlib.hE<gt>\n#include E<lt>semaphore.hE<gt>\n#include E<lt>time.hE<gt>\n#include E<lt>assert.hE<gt>\n#include E<lt>errno.hE<gt>\n#include E<lt>signal.hE<gt>\n"

#. type: Plain text
#: man-pages/man3/sem_wait.3:205
#, no-wrap
msgid "sem_t sem;\n"
msgstr "sem_t sem;\n"

#. type: Plain text
#: man-pages/man3/sem_wait.3:218
#, no-wrap
msgid ""
"static void\n"
"handler(int sig)\n"
"{\n"
"    write(STDOUT_FILENO, \"sem_post() from handler\\en\", 24);\n"
"    if (sem_post(&sem) == -1) {\n"
"        write(STDERR_FILENO, \"sem_post() failed\\en\", 18);\n"
"        _exit(EXIT_FAILURE);\n"
"    }\n"
"}\n"
msgstr "static void\nhandler(int sig)\n{\n    write(STDOUT_FILENO, \"sem_post() from handler\\en\", 24);\n    if (sem_post(&sem) == -1) {\n        write(STDERR_FILENO, \"sem_post() failed\\en\", 18);\n        _exit(EXIT_FAILURE);\n    }\n}\n"

#. type: Plain text
#: man-pages/man3/sem_wait.3:225
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    struct sigaction sa;\n"
"    struct timespec ts;\n"
"    int s;\n"
msgstr "int\nmain(int argc, char *argv[])\n{\n    struct sigaction sa;\n    struct timespec ts;\n    int s;\n"

#. type: Plain text
#: man-pages/man3/sem_wait.3:231
#, no-wrap
msgid ""
"    if (argc != 3) {\n"
"        fprintf(stderr, \"Usage: %s E<lt>alarm-secsE<gt> E<lt>wait-secsE<gt>\\en\",\n"
"                argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr "    if (argc != 3) {\n        fprintf(stderr, \"Usage: %s E<lt>alarm-secsE<gt> E<lt>wait-secsE<gt>\\en\",\n                argv[0]);\n        exit(EXIT_FAILURE);\n    }\n"

#. type: Plain text
#: man-pages/man3/sem_wait.3:234
#, no-wrap
msgid ""
"    if (sem_init(&sem, 0, 0) == -1)\n"
"        handle_error(\"sem_init\");\n"
msgstr "    if (sem_init(&sem, 0, 0) == -1)\n        handle_error(\"sem_init\");\n"

#. type: Plain text
#: man-pages/man3/sem_wait.3:236
#, no-wrap
msgid "    /* Establish SIGALRM handler; set alarm timer using argv[1] */\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/sem_wait.3:242
#, no-wrap
msgid ""
"    sa.sa_handler = handler;\n"
"    sigemptyset(&sa.sa_mask);\n"
"    sa.sa_flags = 0;\n"
"    if (sigaction(SIGALRM, &sa, NULL) == -1)\n"
"        handle_error(\"sigaction\");\n"
msgstr "    sa.sa_handler = handler;\n    sigemptyset(&sa.sa_mask);\n    sa.sa_flags = 0;\n    if (sigaction(SIGALRM, &sa, NULL) == -1)\n        handle_error(\"sigaction\");\n"

#. type: Plain text
#: man-pages/man3/sem_wait.3:244
#, no-wrap
msgid "    alarm(atoi(argv[1]));\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/sem_wait.3:247
#, no-wrap
msgid ""
"    /* Calculate relative interval as current time plus\n"
"       number of seconds given argv[2] */\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/sem_wait.3:250
#, no-wrap
msgid ""
"    if (clock_gettime(CLOCK_REALTIME, &ts) == -1)\n"
"        handle_error(\"clock_gettime\");\n"
msgstr "    if (clock_gettime(CLOCK_REALTIME, &ts) == -1)\n        handle_error(\"clock_gettime\");\n"

#. type: Plain text
#: man-pages/man3/sem_wait.3:252
#, no-wrap
msgid "    ts.tv_sec += atoi(argv[2]);\n"
msgstr "    ts.tv_sec += atoi(argv[2]);\n"

#. type: Plain text
#: man-pages/man3/sem_wait.3:256
#, no-wrap
msgid ""
"    printf(\"main() about to call sem_timedwait()\\en\");\n"
"    while ((s = sem_timedwait(&sem, &ts)) == -1 && errno == EINTR)\n"
"        continue;       /* Restart if interrupted by handler */\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/sem_wait.3:258
#, no-wrap
msgid "    /* Check what happened */\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/sem_wait.3:266
#, no-wrap
msgid ""
"    if (s == -1) {\n"
"        if (errno == ETIMEDOUT)\n"
"            printf(\"sem_timedwait() timed out\\en\");\n"
"        else\n"
"            perror(\"sem_timedwait\");\n"
"    } else\n"
"        printf(\"sem_timedwait() succeeded\\en\");\n"
msgstr "    if (s == -1) {\n        if (errno == ETIMEDOUT)\n            printf(\"sem_timedwait() timed out\\en\");\n        else\n            perror(\"sem_timedwait\");\n    } else\n        printf(\"sem_timedwait() succeeded\\en\");\n"

#. type: Plain text
#: man-pages/man3/sem_wait.3:269
#, no-wrap
msgid ""
"    exit((s == 0) ? EXIT_SUCCESS : EXIT_FAILURE);\n"
"}\n"
msgstr "    exit((s == 0) ? EXIT_SUCCESS : EXIT_FAILURE);\n}\n"

#. type: Plain text
#: man-pages/man3/sem_wait.3:275
msgid ""
"B<clock_gettime>(2), B<sem_getvalue>(3), B<sem_post>(3), B<sem_overview>(7),"
" B<time>(7)"
msgstr "B<clock_gettime>(2), B<sem_getvalue>(3), B<sem_post>(3), B<sem_overview>(7), B<time>(7)"

#. type: TH
#: man-pages/man3/sqrt.3:34
#, no-wrap
msgid "SQRT"
msgstr "SQRT"

#. type: Plain text
#: man-pages/man3/sqrt.3:37
msgid "sqrt, sqrtf, sqrtl - square root function"
msgstr "sqrt, sqrtf, sqrtl - функция извлечения квадратного корня"

#. type: Plain text
#: man-pages/man3/sqrt.3:42
#, no-wrap
msgid "B<double sqrt(double >I<x>B<);>\n"
msgstr "B<double sqrt(double >I<x>B<);>\n"

#. type: Plain text
#: man-pages/man3/sqrt.3:44
#, no-wrap
msgid "B<float sqrtf(float >I<x>B<);>\n"
msgstr "B<float sqrtf(float >I<x>B<);>\n"

#. type: Plain text
#: man-pages/man3/sqrt.3:46
#, no-wrap
msgid "B<long double sqrtl(long double >I<x>B<);>\n"
msgstr "B<long double sqrtl(long double >I<x>B<);>\n"

#. type: Plain text
#: man-pages/man3/sqrt.3:58
msgid "B<sqrtf>(), B<sqrtl>():"
msgstr "B<sqrtf>(), B<sqrtl>():"

#. type: Plain text
#: man-pages/man3/sqrt.3:71
msgid "The B<sqrt>()  function returns the nonnegative square root of I<x>."
msgstr "Функция B<sqrt>() возвращает неотрицательный квадратный корень от I<x>."

#. type: Plain text
#: man-pages/man3/sqrt.3:74
msgid "On success, these functions return the square root of I<x>."
msgstr "В случае успеха эти функции возвращают квадратный корень от I<x>."

#. type: Plain text
#: man-pages/man3/sqrt.3:86
msgid "If I<x> is positive infinity, positive infinity is returned."
msgstr "Если I<x> стремится к плюс бесконечности, то будет возвращена плюс бесконечность."

#. type: Plain text
#: man-pages/man3/sqrt.3:92
msgid "If I<x> is less than -0, a domain error occurs, and a NaN is returned."
msgstr "Если I<x> меньше -0, то будет сгенерирована ошибка выхода за пределы области, а в качестве результата будет возвращено NaN."

#. type: TP
#: man-pages/man3/sqrt.3:99
#, no-wrap
msgid "Domain error: I<x> less than -0"
msgstr "Ошибка области: I<x> меньше -0"

#. type: Plain text
#: man-pages/man3/sqrt.3:107
msgid ""
"I<errno> is set to B<EDOM>.  An invalid floating-point exception "
"(B<FE_INVALID>)  is raised."
msgstr "I<errno> устанавливается в B<EDOM>. Вызывается исключение неправильной плавающей точки (B<FE_INVALID>)."

#. type: Plain text
#: man-pages/man3/sqrt.3:116
msgid "B<cbrt>(3), B<csqrt>(3), B<hypot>(3)"
msgstr "B<cbrt>(3), B<csqrt>(3), B<hypot>(3)"

#. type: TH
#: man-pages/man3/strcpy.3:35
#, no-wrap
msgid "STRCPY"
msgstr "STRCPY"

#. type: Plain text
#: man-pages/man3/strcpy.3:38
msgid "strcpy, strncpy - copy a string"
msgstr "strcpy, strncpy - копирование строки"

#. type: Plain text
#: man-pages/man3/strcpy.3:43
#, no-wrap
msgid "B<char *strcpy(char *>I<dest>B<, const char *>I<src>B<);>\n"
msgstr "B<char *strcpy(char *>I<dest>B<, const char *>I<src>B<);>\n"

#. type: Plain text
#: man-pages/man3/strcpy.3:45
#, no-wrap
msgid ""
"B<char *strncpy(char *>I<dest>B<, const char *>I<src>B<, size_t >I<n>B<);>\n"
msgstr "B<char *strncpy(char *>I<dest>B<, const char *>I<src>B<, size_t >I<n>B<);>\n"

#. type: Plain text
#: man-pages/man3/strcpy.3:59
msgid ""
"The B<strcpy>()  function copies the string pointed to by I<src>, including "
"the terminating null byte (\\(aq\\e0\\(aq), to the buffer pointed to by "
"I<dest>.  The strings may not overlap, and the destination string I<dest> "
"must be large enough to receive the copy.  I<Beware of buffer overruns!> "
"(See BUGS.)"
msgstr ""

#. type: Plain text
#: man-pages/man3/strcpy.3:76
msgid ""
"The B<strncpy>()  function is similar, except that at most I<n> bytes of "
"I<src> are copied.  B<Warning>: If there is no null byte among the first "
"I<n> bytes of I<src>, the string placed in I<dest> will not be null-"
"terminated."
msgstr "Функция B<strncpy>() сходна, за исключением того, что скопировано будет только первые I<n> байт из I<src>.  B<Внимание>: если в первых I<n> байт из I<src> не окажется нулевого байта, то строка в I<dest> также не будет завершена нулевым байтом."

#. type: Plain text
#: man-pages/man3/strcpy.3:87
msgid ""
"If the length of I<src> is less than I<n>, B<strncpy>()  writes additional "
"null bytes to I<dest> to ensure that a total of I<n> bytes are written."
msgstr ""

#. type: Plain text
#: man-pages/man3/strcpy.3:91
msgid "A simple implementation of B<strncpy>()  might be:"
msgstr "Простейшей реализацией B<strncpy>() может быть:"

#. type: Plain text
#: man-pages/man3/strcpy.3:98
#, no-wrap
msgid ""
"char *\n"
"strncpy(char *dest, const char *src, size_t n)\n"
"{\n"
"    size_t i;\n"
msgstr "char *\nstrncpy(char *dest, const char *src, size_t n)\n{\n    size_t i;\n"

#. type: Plain text
#: man-pages/man3/strcpy.3:103
#, no-wrap
msgid ""
"    for (i = 0; i E<lt> n && src[i] != \\(aq\\e0\\(aq; i++)\n"
"        dest[i] = src[i];\n"
"    for ( ; i E<lt> n; i++)\n"
"        dest[i] = \\(aq\\e0\\(aq;\n"
msgstr "    for (i = 0; i E<lt> n && src[i] != \\(aq\\e0\\(aq; i++)\n        dest[i] = src[i];\n    for ( ; i E<lt> n; i++)\n        dest[i] = \\(aq\\e0\\(aq;\n"

#. type: Plain text
#: man-pages/man3/strcpy.3:116
msgid ""
"The B<strcpy>()  and B<strncpy>()  functions return a pointer to the "
"destination string I<dest>."
msgstr "Функции B<strcpy>() и B<strncpy>() возвращают указатель на скопированную строку I<dest>."

#. type: Plain text
#: man-pages/man3/strcpy.3:123
msgid "The B<strcpy>()  and B<strncpy>()  functions are thread-safe."
msgstr ""

#. type: Plain text
#: man-pages/man3/strcpy.3:138
msgid ""
"Some programmers consider B<strncpy>()  to be inefficient and error prone.  "
"If the programmer knows (i.e., includes code to test!)  that the size of "
"I<dest> is greater than the length of I<src>, then B<strcpy>()  can be used."
msgstr ""

#. type: Plain text
#: man-pages/man3/strcpy.3:147
msgid ""
"One valid (and intended) use of B<strncpy>()  is to copy a C string to a "
"fixed-length buffer while ensuring both that the buffer is not overflowed "
"and that unused bytes in the target buffer are zeroed out (perhaps to "
"prevent information leaks if the buffer is to be written to media or "
"transmitted to another process via an interprocess communication technique)."
msgstr ""

#. type: Plain text
#: man-pages/man3/strcpy.3:160
msgid ""
"If there is no terminating null byte in the first I<n> bytes of I<src>, "
"B<strncpy>()  produces an unterminated string in I<dest>.  If I<buf> has "
"length I<buflen>, you can force termination using something like the "
"following:"
msgstr ""

#. type: Plain text
#: man-pages/man3/strcpy.3:166
#, no-wrap
msgid ""
"strncpy(buf, str, buflen - 1);\n"
"if (buflen E<gt> 0)\n"
"    buf[buflen - 1]= \\(aq\\e0\\(aq;\n"
msgstr ""

#. type: Plain text
#: man-pages/man3/strcpy.3:176
msgid ""
"(Of course, the above technique ignores the fact that, if I<src> contains "
"more than I<buflen\\ -\\ 1> bytes, information is lost in the copying to "
"I<dest>.)"
msgstr ""

#. type: SS
#: man-pages/man3/strcpy.3:176
#, no-wrap
msgid "strlcpy()"
msgstr ""

#. type: Plain text
#: man-pages/man3/strcpy.3:180
#, no-wrap
msgid "    size_t strlcpy(char *dest, const char *src, size_t size);\n"
msgstr ""

#. http://static.usenix.org/event/usenix99/full_papers/millert/millert_html/index.html
#.      "strlcpy and strlcat - consistent, safe, string copy and
#. concatenation"
#.      1999 USENIX Annual Technical Conference
#.  https://lwn.net/Articles/506530/
#. type: Plain text
#: man-pages/man3/strcpy.3:215
msgid ""
"This function is similar to B<strncpy>(), but it copies at most I<size-1> "
"bytes to I<dest>, always adds a terminating null byte, and does not pad the "
"target with (further) null bytes.  This function fixes some of the problems "
"of B<strcpy>()  and B<strncpy>(), but the caller must still handle the "
"possibility of data loss if I<size> is too small.  The return value of the "
"function is the length of I<src>, which allows truncation to be easily "
"detected: if the return value is greater than or equal to I<size>, "
"truncation occurred.  If loss of data matters, the caller I<must> either "
"check the arguments before the call, or test the function return value.  "
"B<strlcpy>()  is not present in glibc and is not standardized by POSIX, but "
"is available on Linux via the I<libbsd> library."
msgstr ""

#. type: Plain text
#: man-pages/man3/strcpy.3:226
msgid ""
"If the destination string of a B<strcpy>()  is not large enough, then "
"anything might happen.  Overflowing fixed-length string buffers is a "
"favorite cracker technique for taking complete control of the machine.  Any "
"time a program reads or copies data into a buffer, the program first needs "
"to check that there's enough space.  This may be unnecessary if you can show"
" that overflow is impossible, but be careful: programs can get changed over "
"time, in ways that may make the impossible possible."
msgstr ""

#. type: Plain text
#: man-pages/man3/strcpy.3:236
msgid ""
"B<bcopy>(3), B<memccpy>(3), B<memcpy>(3), B<memmove>(3), B<stpcpy>(3), "
"B<stpncpy>(3), B<strdup>(3), B<string>(3), B<wcscpy>(3), B<wcsncpy>(3)"
msgstr ""
